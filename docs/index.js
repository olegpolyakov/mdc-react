(()=>{var __webpack_modules__={934:(__unused_webpack_module,__unused_webpack___webpack_exports__,__webpack_require__)=>{"use strict";eval('\n;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}\n;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/inheritsLoose.js\n\nfunction _inheritsLoose(subClass, superClass) {\n  subClass.prototype = Object.create(superClass.prototype);\n  subClass.prototype.constructor = subClass;\n  _setPrototypeOf(subClass, superClass);\n}\n// EXTERNAL MODULE: ./node_modules/react/index.js\nvar react = __webpack_require__(294);\n// EXTERNAL MODULE: ./node_modules/prop-types/index.js\nvar prop_types = __webpack_require__(697);\nvar prop_types_default = /*#__PURE__*/__webpack_require__.n(prop_types);\n;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/extends.js\nfunction extends_extends() {\n  extends_extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return extends_extends.apply(this, arguments);\n}\n;// CONCATENATED MODULE: ./node_modules/resolve-pathname/esm/resolve-pathname.js\nfunction isAbsolute(pathname) {\n  return pathname.charAt(0) === \'/\';\n}\n\n// About 1.5x faster than the two-arg version of Array#splice()\nfunction spliceOne(list, index) {\n  for (var i = index, k = i + 1, n = list.length; k < n; i += 1, k += 1) {\n    list[i] = list[k];\n  }\n\n  list.pop();\n}\n\n// This implementation is based heavily on node\'s url.parse\nfunction resolvePathname(to, from) {\n  if (from === undefined) from = \'\';\n\n  var toParts = (to && to.split(\'/\')) || [];\n  var fromParts = (from && from.split(\'/\')) || [];\n\n  var isToAbs = to && isAbsolute(to);\n  var isFromAbs = from && isAbsolute(from);\n  var mustEndAbs = isToAbs || isFromAbs;\n\n  if (to && isAbsolute(to)) {\n    // to is absolute\n    fromParts = toParts;\n  } else if (toParts.length) {\n    // to is relative, drop the filename\n    fromParts.pop();\n    fromParts = fromParts.concat(toParts);\n  }\n\n  if (!fromParts.length) return \'/\';\n\n  var hasTrailingSlash;\n  if (fromParts.length) {\n    var last = fromParts[fromParts.length - 1];\n    hasTrailingSlash = last === \'.\' || last === \'..\' || last === \'\';\n  } else {\n    hasTrailingSlash = false;\n  }\n\n  var up = 0;\n  for (var i = fromParts.length; i >= 0; i--) {\n    var part = fromParts[i];\n\n    if (part === \'.\') {\n      spliceOne(fromParts, i);\n    } else if (part === \'..\') {\n      spliceOne(fromParts, i);\n      up++;\n    } else if (up) {\n      spliceOne(fromParts, i);\n      up--;\n    }\n  }\n\n  if (!mustEndAbs) for (; up--; up) fromParts.unshift(\'..\');\n\n  if (\n    mustEndAbs &&\n    fromParts[0] !== \'\' &&\n    (!fromParts[0] || !isAbsolute(fromParts[0]))\n  )\n    fromParts.unshift(\'\');\n\n  var result = fromParts.join(\'/\');\n\n  if (hasTrailingSlash && result.substr(-1) !== \'/\') result += \'/\';\n\n  return result;\n}\n\n/* harmony default export */ const resolve_pathname = (resolvePathname);\n\n;// CONCATENATED MODULE: ./node_modules/tiny-invariant/dist/tiny-invariant.esm.js\nvar isProduction = "production" === \'production\';\nvar prefix = \'Invariant failed\';\nfunction tiny_invariant_esm_invariant(condition, message) {\n    if (condition) {\n        return;\n    }\n    if (isProduction) {\n        throw new Error(prefix);\n    }\n    throw new Error(prefix + ": " + (message || \'\'));\n}\n\n/* harmony default export */ const tiny_invariant_esm = (tiny_invariant_esm_invariant);\n\n;// CONCATENATED MODULE: ./node_modules/history/esm/history.js\n\n\n\n\n\n\nfunction addLeadingSlash(path) {\n  return path.charAt(0) === \'/\' ? path : \'/\' + path;\n}\nfunction stripLeadingSlash(path) {\n  return path.charAt(0) === \'/\' ? path.substr(1) : path;\n}\nfunction hasBasename(path, prefix) {\n  return path.toLowerCase().indexOf(prefix.toLowerCase()) === 0 && \'/?#\'.indexOf(path.charAt(prefix.length)) !== -1;\n}\nfunction stripBasename(path, prefix) {\n  return hasBasename(path, prefix) ? path.substr(prefix.length) : path;\n}\nfunction stripTrailingSlash(path) {\n  return path.charAt(path.length - 1) === \'/\' ? path.slice(0, -1) : path;\n}\nfunction parsePath(path) {\n  var pathname = path || \'/\';\n  var search = \'\';\n  var hash = \'\';\n  var hashIndex = pathname.indexOf(\'#\');\n\n  if (hashIndex !== -1) {\n    hash = pathname.substr(hashIndex);\n    pathname = pathname.substr(0, hashIndex);\n  }\n\n  var searchIndex = pathname.indexOf(\'?\');\n\n  if (searchIndex !== -1) {\n    search = pathname.substr(searchIndex);\n    pathname = pathname.substr(0, searchIndex);\n  }\n\n  return {\n    pathname: pathname,\n    search: search === \'?\' ? \'\' : search,\n    hash: hash === \'#\' ? \'\' : hash\n  };\n}\nfunction createPath(location) {\n  var pathname = location.pathname,\n      search = location.search,\n      hash = location.hash;\n  var path = pathname || \'/\';\n  if (search && search !== \'?\') path += search.charAt(0) === \'?\' ? search : "?" + search;\n  if (hash && hash !== \'#\') path += hash.charAt(0) === \'#\' ? hash : "#" + hash;\n  return path;\n}\n\nfunction history_createLocation(path, state, key, currentLocation) {\n  var location;\n\n  if (typeof path === \'string\') {\n    // Two-arg form: push(path, state)\n    location = parsePath(path);\n    location.state = state;\n  } else {\n    // One-arg form: push(location)\n    location = extends_extends({}, path);\n    if (location.pathname === undefined) location.pathname = \'\';\n\n    if (location.search) {\n      if (location.search.charAt(0) !== \'?\') location.search = \'?\' + location.search;\n    } else {\n      location.search = \'\';\n    }\n\n    if (location.hash) {\n      if (location.hash.charAt(0) !== \'#\') location.hash = \'#\' + location.hash;\n    } else {\n      location.hash = \'\';\n    }\n\n    if (state !== undefined && location.state === undefined) location.state = state;\n  }\n\n  try {\n    location.pathname = decodeURI(location.pathname);\n  } catch (e) {\n    if (e instanceof URIError) {\n      throw new URIError(\'Pathname "\' + location.pathname + \'" could not be decoded. \' + \'This is likely caused by an invalid percent-encoding.\');\n    } else {\n      throw e;\n    }\n  }\n\n  if (key) location.key = key;\n\n  if (currentLocation) {\n    // Resolve incomplete/relative pathname relative to current location.\n    if (!location.pathname) {\n      location.pathname = currentLocation.pathname;\n    } else if (location.pathname.charAt(0) !== \'/\') {\n      location.pathname = resolve_pathname(location.pathname, currentLocation.pathname);\n    }\n  } else {\n    // When there is no prior location and pathname is empty, set it to /\n    if (!location.pathname) {\n      location.pathname = \'/\';\n    }\n  }\n\n  return location;\n}\nfunction history_locationsAreEqual(a, b) {\n  return a.pathname === b.pathname && a.search === b.search && a.hash === b.hash && a.key === b.key && valueEqual(a.state, b.state);\n}\n\nfunction createTransitionManager() {\n  var prompt = null;\n\n  function setPrompt(nextPrompt) {\n     false ? 0 : void 0;\n    prompt = nextPrompt;\n    return function () {\n      if (prompt === nextPrompt) prompt = null;\n    };\n  }\n\n  function confirmTransitionTo(location, action, getUserConfirmation, callback) {\n    // TODO: If another transition starts while we\'re still confirming\n    // the previous one, we may end up in a weird state. Figure out the\n    // best way to handle this.\n    if (prompt != null) {\n      var result = typeof prompt === \'function\' ? prompt(location, action) : prompt;\n\n      if (typeof result === \'string\') {\n        if (typeof getUserConfirmation === \'function\') {\n          getUserConfirmation(result, callback);\n        } else {\n           false ? 0 : void 0;\n          callback(true);\n        }\n      } else {\n        // Return false from a transition hook to cancel the transition.\n        callback(result !== false);\n      }\n    } else {\n      callback(true);\n    }\n  }\n\n  var listeners = [];\n\n  function appendListener(fn) {\n    var isActive = true;\n\n    function listener() {\n      if (isActive) fn.apply(void 0, arguments);\n    }\n\n    listeners.push(listener);\n    return function () {\n      isActive = false;\n      listeners = listeners.filter(function (item) {\n        return item !== listener;\n      });\n    };\n  }\n\n  function notifyListeners() {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    listeners.forEach(function (listener) {\n      return listener.apply(void 0, args);\n    });\n  }\n\n  return {\n    setPrompt: setPrompt,\n    confirmTransitionTo: confirmTransitionTo,\n    appendListener: appendListener,\n    notifyListeners: notifyListeners\n  };\n}\n\nvar canUseDOM = !!(typeof window !== \'undefined\' && window.document && window.document.createElement);\nfunction getConfirmation(message, callback) {\n  callback(window.confirm(message)); // eslint-disable-line no-alert\n}\n/**\n * Returns true if the HTML5 history API is supported. Taken from Modernizr.\n *\n * https://github.com/Modernizr/Modernizr/blob/master/LICENSE\n * https://github.com/Modernizr/Modernizr/blob/master/feature-detects/history.js\n * changed to avoid false negatives for Windows Phones: https://github.com/reactjs/react-router/issues/586\n */\n\nfunction supportsHistory() {\n  var ua = window.navigator.userAgent;\n  if ((ua.indexOf(\'Android 2.\') !== -1 || ua.indexOf(\'Android 4.0\') !== -1) && ua.indexOf(\'Mobile Safari\') !== -1 && ua.indexOf(\'Chrome\') === -1 && ua.indexOf(\'Windows Phone\') === -1) return false;\n  return window.history && \'pushState\' in window.history;\n}\n/**\n * Returns true if browser fires popstate on hash change.\n * IE10 and IE11 do not.\n */\n\nfunction supportsPopStateOnHashChange() {\n  return window.navigator.userAgent.indexOf(\'Trident\') === -1;\n}\n/**\n * Returns false if using go(n) with hash history causes a full page reload.\n */\n\nfunction supportsGoWithoutReloadUsingHash() {\n  return window.navigator.userAgent.indexOf(\'Firefox\') === -1;\n}\n/**\n * Returns true if a given popstate event is an extraneous WebKit event.\n * Accounts for the fact that Chrome on iOS fires real popstate events\n * containing undefined state when pressing the back button.\n */\n\nfunction isExtraneousPopstateEvent(event) {\n  return event.state === undefined && navigator.userAgent.indexOf(\'CriOS\') === -1;\n}\n\nvar PopStateEvent = \'popstate\';\nvar HashChangeEvent = \'hashchange\';\n\nfunction getHistoryState() {\n  try {\n    return window.history.state || {};\n  } catch (e) {\n    // IE 11 sometimes throws when accessing window.history.state\n    // See https://github.com/ReactTraining/history/pull/289\n    return {};\n  }\n}\n/**\n * Creates a history object that uses the HTML5 history API including\n * pushState, replaceState, and the popstate event.\n */\n\n\nfunction createBrowserHistory(props) {\n  if (props === void 0) {\n    props = {};\n  }\n\n  !canUseDOM ?  false ? 0 : tiny_invariant_esm(false) : void 0;\n  var globalHistory = window.history;\n  var canUseHistory = supportsHistory();\n  var needsHashChangeListener = !supportsPopStateOnHashChange();\n  var _props = props,\n      _props$forceRefresh = _props.forceRefresh,\n      forceRefresh = _props$forceRefresh === void 0 ? false : _props$forceRefresh,\n      _props$getUserConfirm = _props.getUserConfirmation,\n      getUserConfirmation = _props$getUserConfirm === void 0 ? getConfirmation : _props$getUserConfirm,\n      _props$keyLength = _props.keyLength,\n      keyLength = _props$keyLength === void 0 ? 6 : _props$keyLength;\n  var basename = props.basename ? stripTrailingSlash(addLeadingSlash(props.basename)) : \'\';\n\n  function getDOMLocation(historyState) {\n    var _ref = historyState || {},\n        key = _ref.key,\n        state = _ref.state;\n\n    var _window$location = window.location,\n        pathname = _window$location.pathname,\n        search = _window$location.search,\n        hash = _window$location.hash;\n    var path = pathname + search + hash;\n     false ? 0 : void 0;\n    if (basename) path = stripBasename(path, basename);\n    return history_createLocation(path, state, key);\n  }\n\n  function createKey() {\n    return Math.random().toString(36).substr(2, keyLength);\n  }\n\n  var transitionManager = createTransitionManager();\n\n  function setState(nextState) {\n    extends_extends(history, nextState);\n\n    history.length = globalHistory.length;\n    transitionManager.notifyListeners(history.location, history.action);\n  }\n\n  function handlePopState(event) {\n    // Ignore extraneous popstate events in WebKit.\n    if (isExtraneousPopstateEvent(event)) return;\n    handlePop(getDOMLocation(event.state));\n  }\n\n  function handleHashChange() {\n    handlePop(getDOMLocation(getHistoryState()));\n  }\n\n  var forceNextPop = false;\n\n  function handlePop(location) {\n    if (forceNextPop) {\n      forceNextPop = false;\n      setState();\n    } else {\n      var action = \'POP\';\n      transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {\n        if (ok) {\n          setState({\n            action: action,\n            location: location\n          });\n        } else {\n          revertPop(location);\n        }\n      });\n    }\n  }\n\n  function revertPop(fromLocation) {\n    var toLocation = history.location; // TODO: We could probably make this more reliable by\n    // keeping a list of keys we\'ve seen in sessionStorage.\n    // Instead, we just default to 0 for keys we don\'t know.\n\n    var toIndex = allKeys.indexOf(toLocation.key);\n    if (toIndex === -1) toIndex = 0;\n    var fromIndex = allKeys.indexOf(fromLocation.key);\n    if (fromIndex === -1) fromIndex = 0;\n    var delta = toIndex - fromIndex;\n\n    if (delta) {\n      forceNextPop = true;\n      go(delta);\n    }\n  }\n\n  var initialLocation = getDOMLocation(getHistoryState());\n  var allKeys = [initialLocation.key]; // Public interface\n\n  function createHref(location) {\n    return basename + createPath(location);\n  }\n\n  function push(path, state) {\n     false ? 0 : void 0;\n    var action = \'PUSH\';\n    var location = history_createLocation(path, state, createKey(), history.location);\n    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {\n      if (!ok) return;\n      var href = createHref(location);\n      var key = location.key,\n          state = location.state;\n\n      if (canUseHistory) {\n        globalHistory.pushState({\n          key: key,\n          state: state\n        }, null, href);\n\n        if (forceRefresh) {\n          window.location.href = href;\n        } else {\n          var prevIndex = allKeys.indexOf(history.location.key);\n          var nextKeys = allKeys.slice(0, prevIndex + 1);\n          nextKeys.push(location.key);\n          allKeys = nextKeys;\n          setState({\n            action: action,\n            location: location\n          });\n        }\n      } else {\n         false ? 0 : void 0;\n        window.location.href = href;\n      }\n    });\n  }\n\n  function replace(path, state) {\n     false ? 0 : void 0;\n    var action = \'REPLACE\';\n    var location = history_createLocation(path, state, createKey(), history.location);\n    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {\n      if (!ok) return;\n      var href = createHref(location);\n      var key = location.key,\n          state = location.state;\n\n      if (canUseHistory) {\n        globalHistory.replaceState({\n          key: key,\n          state: state\n        }, null, href);\n\n        if (forceRefresh) {\n          window.location.replace(href);\n        } else {\n          var prevIndex = allKeys.indexOf(history.location.key);\n          if (prevIndex !== -1) allKeys[prevIndex] = location.key;\n          setState({\n            action: action,\n            location: location\n          });\n        }\n      } else {\n         false ? 0 : void 0;\n        window.location.replace(href);\n      }\n    });\n  }\n\n  function go(n) {\n    globalHistory.go(n);\n  }\n\n  function goBack() {\n    go(-1);\n  }\n\n  function goForward() {\n    go(1);\n  }\n\n  var listenerCount = 0;\n\n  function checkDOMListeners(delta) {\n    listenerCount += delta;\n\n    if (listenerCount === 1 && delta === 1) {\n      window.addEventListener(PopStateEvent, handlePopState);\n      if (needsHashChangeListener) window.addEventListener(HashChangeEvent, handleHashChange);\n    } else if (listenerCount === 0) {\n      window.removeEventListener(PopStateEvent, handlePopState);\n      if (needsHashChangeListener) window.removeEventListener(HashChangeEvent, handleHashChange);\n    }\n  }\n\n  var isBlocked = false;\n\n  function block(prompt) {\n    if (prompt === void 0) {\n      prompt = false;\n    }\n\n    var unblock = transitionManager.setPrompt(prompt);\n\n    if (!isBlocked) {\n      checkDOMListeners(1);\n      isBlocked = true;\n    }\n\n    return function () {\n      if (isBlocked) {\n        isBlocked = false;\n        checkDOMListeners(-1);\n      }\n\n      return unblock();\n    };\n  }\n\n  function listen(listener) {\n    var unlisten = transitionManager.appendListener(listener);\n    checkDOMListeners(1);\n    return function () {\n      checkDOMListeners(-1);\n      unlisten();\n    };\n  }\n\n  var history = {\n    length: globalHistory.length,\n    action: \'POP\',\n    location: initialLocation,\n    createHref: createHref,\n    push: push,\n    replace: replace,\n    go: go,\n    goBack: goBack,\n    goForward: goForward,\n    block: block,\n    listen: listen\n  };\n  return history;\n}\n\nvar HashChangeEvent$1 = \'hashchange\';\nvar HashPathCoders = {\n  hashbang: {\n    encodePath: function encodePath(path) {\n      return path.charAt(0) === \'!\' ? path : \'!/\' + stripLeadingSlash(path);\n    },\n    decodePath: function decodePath(path) {\n      return path.charAt(0) === \'!\' ? path.substr(1) : path;\n    }\n  },\n  noslash: {\n    encodePath: stripLeadingSlash,\n    decodePath: addLeadingSlash\n  },\n  slash: {\n    encodePath: addLeadingSlash,\n    decodePath: addLeadingSlash\n  }\n};\n\nfunction stripHash(url) {\n  var hashIndex = url.indexOf(\'#\');\n  return hashIndex === -1 ? url : url.slice(0, hashIndex);\n}\n\nfunction getHashPath() {\n  // We can\'t use window.location.hash here because it\'s not\n  // consistent across browsers - Firefox will pre-decode it!\n  var href = window.location.href;\n  var hashIndex = href.indexOf(\'#\');\n  return hashIndex === -1 ? \'\' : href.substring(hashIndex + 1);\n}\n\nfunction pushHashPath(path) {\n  window.location.hash = path;\n}\n\nfunction replaceHashPath(path) {\n  window.location.replace(stripHash(window.location.href) + \'#\' + path);\n}\n\nfunction createHashHistory(props) {\n  if (props === void 0) {\n    props = {};\n  }\n\n  !canUseDOM ?  false ? 0 : tiny_invariant_esm(false) : void 0;\n  var globalHistory = window.history;\n  var canGoWithoutReload = supportsGoWithoutReloadUsingHash();\n  var _props = props,\n      _props$getUserConfirm = _props.getUserConfirmation,\n      getUserConfirmation = _props$getUserConfirm === void 0 ? getConfirmation : _props$getUserConfirm,\n      _props$hashType = _props.hashType,\n      hashType = _props$hashType === void 0 ? \'slash\' : _props$hashType;\n  var basename = props.basename ? stripTrailingSlash(addLeadingSlash(props.basename)) : \'\';\n  var _HashPathCoders$hashT = HashPathCoders[hashType],\n      encodePath = _HashPathCoders$hashT.encodePath,\n      decodePath = _HashPathCoders$hashT.decodePath;\n\n  function getDOMLocation() {\n    var path = decodePath(getHashPath());\n     false ? 0 : void 0;\n    if (basename) path = stripBasename(path, basename);\n    return history_createLocation(path);\n  }\n\n  var transitionManager = createTransitionManager();\n\n  function setState(nextState) {\n    extends_extends(history, nextState);\n\n    history.length = globalHistory.length;\n    transitionManager.notifyListeners(history.location, history.action);\n  }\n\n  var forceNextPop = false;\n  var ignorePath = null;\n\n  function locationsAreEqual$$1(a, b) {\n    return a.pathname === b.pathname && a.search === b.search && a.hash === b.hash;\n  }\n\n  function handleHashChange() {\n    var path = getHashPath();\n    var encodedPath = encodePath(path);\n\n    if (path !== encodedPath) {\n      // Ensure we always have a properly-encoded hash.\n      replaceHashPath(encodedPath);\n    } else {\n      var location = getDOMLocation();\n      var prevLocation = history.location;\n      if (!forceNextPop && locationsAreEqual$$1(prevLocation, location)) return; // A hashchange doesn\'t always == location change.\n\n      if (ignorePath === createPath(location)) return; // Ignore this change; we already setState in push/replace.\n\n      ignorePath = null;\n      handlePop(location);\n    }\n  }\n\n  function handlePop(location) {\n    if (forceNextPop) {\n      forceNextPop = false;\n      setState();\n    } else {\n      var action = \'POP\';\n      transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {\n        if (ok) {\n          setState({\n            action: action,\n            location: location\n          });\n        } else {\n          revertPop(location);\n        }\n      });\n    }\n  }\n\n  function revertPop(fromLocation) {\n    var toLocation = history.location; // TODO: We could probably make this more reliable by\n    // keeping a list of paths we\'ve seen in sessionStorage.\n    // Instead, we just default to 0 for paths we don\'t know.\n\n    var toIndex = allPaths.lastIndexOf(createPath(toLocation));\n    if (toIndex === -1) toIndex = 0;\n    var fromIndex = allPaths.lastIndexOf(createPath(fromLocation));\n    if (fromIndex === -1) fromIndex = 0;\n    var delta = toIndex - fromIndex;\n\n    if (delta) {\n      forceNextPop = true;\n      go(delta);\n    }\n  } // Ensure the hash is encoded properly before doing anything else.\n\n\n  var path = getHashPath();\n  var encodedPath = encodePath(path);\n  if (path !== encodedPath) replaceHashPath(encodedPath);\n  var initialLocation = getDOMLocation();\n  var allPaths = [createPath(initialLocation)]; // Public interface\n\n  function createHref(location) {\n    var baseTag = document.querySelector(\'base\');\n    var href = \'\';\n\n    if (baseTag && baseTag.getAttribute(\'href\')) {\n      href = stripHash(window.location.href);\n    }\n\n    return href + \'#\' + encodePath(basename + createPath(location));\n  }\n\n  function push(path, state) {\n     false ? 0 : void 0;\n    var action = \'PUSH\';\n    var location = history_createLocation(path, undefined, undefined, history.location);\n    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {\n      if (!ok) return;\n      var path = createPath(location);\n      var encodedPath = encodePath(basename + path);\n      var hashChanged = getHashPath() !== encodedPath;\n\n      if (hashChanged) {\n        // We cannot tell if a hashchange was caused by a PUSH, so we\'d\n        // rather setState here and ignore the hashchange. The caveat here\n        // is that other hash histories in the page will consider it a POP.\n        ignorePath = path;\n        pushHashPath(encodedPath);\n        var prevIndex = allPaths.lastIndexOf(createPath(history.location));\n        var nextPaths = allPaths.slice(0, prevIndex + 1);\n        nextPaths.push(path);\n        allPaths = nextPaths;\n        setState({\n          action: action,\n          location: location\n        });\n      } else {\n         false ? 0 : void 0;\n        setState();\n      }\n    });\n  }\n\n  function replace(path, state) {\n     false ? 0 : void 0;\n    var action = \'REPLACE\';\n    var location = history_createLocation(path, undefined, undefined, history.location);\n    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {\n      if (!ok) return;\n      var path = createPath(location);\n      var encodedPath = encodePath(basename + path);\n      var hashChanged = getHashPath() !== encodedPath;\n\n      if (hashChanged) {\n        // We cannot tell if a hashchange was caused by a REPLACE, so we\'d\n        // rather setState here and ignore the hashchange. The caveat here\n        // is that other hash histories in the page will consider it a POP.\n        ignorePath = path;\n        replaceHashPath(encodedPath);\n      }\n\n      var prevIndex = allPaths.indexOf(createPath(history.location));\n      if (prevIndex !== -1) allPaths[prevIndex] = path;\n      setState({\n        action: action,\n        location: location\n      });\n    });\n  }\n\n  function go(n) {\n     false ? 0 : void 0;\n    globalHistory.go(n);\n  }\n\n  function goBack() {\n    go(-1);\n  }\n\n  function goForward() {\n    go(1);\n  }\n\n  var listenerCount = 0;\n\n  function checkDOMListeners(delta) {\n    listenerCount += delta;\n\n    if (listenerCount === 1 && delta === 1) {\n      window.addEventListener(HashChangeEvent$1, handleHashChange);\n    } else if (listenerCount === 0) {\n      window.removeEventListener(HashChangeEvent$1, handleHashChange);\n    }\n  }\n\n  var isBlocked = false;\n\n  function block(prompt) {\n    if (prompt === void 0) {\n      prompt = false;\n    }\n\n    var unblock = transitionManager.setPrompt(prompt);\n\n    if (!isBlocked) {\n      checkDOMListeners(1);\n      isBlocked = true;\n    }\n\n    return function () {\n      if (isBlocked) {\n        isBlocked = false;\n        checkDOMListeners(-1);\n      }\n\n      return unblock();\n    };\n  }\n\n  function listen(listener) {\n    var unlisten = transitionManager.appendListener(listener);\n    checkDOMListeners(1);\n    return function () {\n      checkDOMListeners(-1);\n      unlisten();\n    };\n  }\n\n  var history = {\n    length: globalHistory.length,\n    action: \'POP\',\n    location: initialLocation,\n    createHref: createHref,\n    push: push,\n    replace: replace,\n    go: go,\n    goBack: goBack,\n    goForward: goForward,\n    block: block,\n    listen: listen\n  };\n  return history;\n}\n\nfunction clamp(n, lowerBound, upperBound) {\n  return Math.min(Math.max(n, lowerBound), upperBound);\n}\n/**\n * Creates a history object that stores locations in memory.\n */\n\n\nfunction createMemoryHistory(props) {\n  if (props === void 0) {\n    props = {};\n  }\n\n  var _props = props,\n      getUserConfirmation = _props.getUserConfirmation,\n      _props$initialEntries = _props.initialEntries,\n      initialEntries = _props$initialEntries === void 0 ? [\'/\'] : _props$initialEntries,\n      _props$initialIndex = _props.initialIndex,\n      initialIndex = _props$initialIndex === void 0 ? 0 : _props$initialIndex,\n      _props$keyLength = _props.keyLength,\n      keyLength = _props$keyLength === void 0 ? 6 : _props$keyLength;\n  var transitionManager = createTransitionManager();\n\n  function setState(nextState) {\n    extends_extends(history, nextState);\n\n    history.length = history.entries.length;\n    transitionManager.notifyListeners(history.location, history.action);\n  }\n\n  function createKey() {\n    return Math.random().toString(36).substr(2, keyLength);\n  }\n\n  var index = clamp(initialIndex, 0, initialEntries.length - 1);\n  var entries = initialEntries.map(function (entry) {\n    return typeof entry === \'string\' ? history_createLocation(entry, undefined, createKey()) : history_createLocation(entry, undefined, entry.key || createKey());\n  }); // Public interface\n\n  var createHref = createPath;\n\n  function push(path, state) {\n     false ? 0 : void 0;\n    var action = \'PUSH\';\n    var location = history_createLocation(path, state, createKey(), history.location);\n    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {\n      if (!ok) return;\n      var prevIndex = history.index;\n      var nextIndex = prevIndex + 1;\n      var nextEntries = history.entries.slice(0);\n\n      if (nextEntries.length > nextIndex) {\n        nextEntries.splice(nextIndex, nextEntries.length - nextIndex, location);\n      } else {\n        nextEntries.push(location);\n      }\n\n      setState({\n        action: action,\n        location: location,\n        index: nextIndex,\n        entries: nextEntries\n      });\n    });\n  }\n\n  function replace(path, state) {\n     false ? 0 : void 0;\n    var action = \'REPLACE\';\n    var location = history_createLocation(path, state, createKey(), history.location);\n    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {\n      if (!ok) return;\n      history.entries[history.index] = location;\n      setState({\n        action: action,\n        location: location\n      });\n    });\n  }\n\n  function go(n) {\n    var nextIndex = clamp(history.index + n, 0, history.entries.length - 1);\n    var action = \'POP\';\n    var location = history.entries[nextIndex];\n    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {\n      if (ok) {\n        setState({\n          action: action,\n          location: location,\n          index: nextIndex\n        });\n      } else {\n        // Mimic the behavior of DOM histories by\n        // causing a render after a cancelled POP.\n        setState();\n      }\n    });\n  }\n\n  function goBack() {\n    go(-1);\n  }\n\n  function goForward() {\n    go(1);\n  }\n\n  function canGo(n) {\n    var nextIndex = history.index + n;\n    return nextIndex >= 0 && nextIndex < history.entries.length;\n  }\n\n  function block(prompt) {\n    if (prompt === void 0) {\n      prompt = false;\n    }\n\n    return transitionManager.setPrompt(prompt);\n  }\n\n  function listen(listener) {\n    return transitionManager.appendListener(listener);\n  }\n\n  var history = {\n    length: entries.length,\n    action: \'POP\',\n    location: entries[index],\n    index: index,\n    entries: entries,\n    createHref: createHref,\n    push: push,\n    replace: replace,\n    go: go,\n    goBack: goBack,\n    goForward: goForward,\n    canGo: canGo,\n    block: block,\n    listen: listen\n  };\n  return history;\n}\n\n\n\n;// CONCATENATED MODULE: ./node_modules/mini-create-react-context/dist/esm/index.js\n\n\n\n\n\nvar MAX_SIGNED_31_BIT_INT = 1073741823;\nvar commonjsGlobal = typeof globalThis !== \'undefined\' ? globalThis : typeof window !== \'undefined\' ? window : typeof __webpack_require__.g !== \'undefined\' ? __webpack_require__.g : {};\n\nfunction getUniqueId() {\n  var key = \'__global_unique_id__\';\n  return commonjsGlobal[key] = (commonjsGlobal[key] || 0) + 1;\n}\n\nfunction objectIs(x, y) {\n  if (x === y) {\n    return x !== 0 || 1 / x === 1 / y;\n  } else {\n    return x !== x && y !== y;\n  }\n}\n\nfunction createEventEmitter(value) {\n  var handlers = [];\n  return {\n    on: function on(handler) {\n      handlers.push(handler);\n    },\n    off: function off(handler) {\n      handlers = handlers.filter(function (h) {\n        return h !== handler;\n      });\n    },\n    get: function get() {\n      return value;\n    },\n    set: function set(newValue, changedBits) {\n      value = newValue;\n      handlers.forEach(function (handler) {\n        return handler(value, changedBits);\n      });\n    }\n  };\n}\n\nfunction onlyChild(children) {\n  return Array.isArray(children) ? children[0] : children;\n}\n\nfunction createReactContext(defaultValue, calculateChangedBits) {\n  var _Provider$childContex, _Consumer$contextType;\n\n  var contextProp = \'__create-react-context-\' + getUniqueId() + \'__\';\n\n  var Provider = /*#__PURE__*/function (_Component) {\n    _inheritsLoose(Provider, _Component);\n\n    function Provider() {\n      var _this;\n\n      _this = _Component.apply(this, arguments) || this;\n      _this.emitter = createEventEmitter(_this.props.value);\n      return _this;\n    }\n\n    var _proto = Provider.prototype;\n\n    _proto.getChildContext = function getChildContext() {\n      var _ref;\n\n      return _ref = {}, _ref[contextProp] = this.emitter, _ref;\n    };\n\n    _proto.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {\n      if (this.props.value !== nextProps.value) {\n        var oldValue = this.props.value;\n        var newValue = nextProps.value;\n        var changedBits;\n\n        if (objectIs(oldValue, newValue)) {\n          changedBits = 0;\n        } else {\n          changedBits = typeof calculateChangedBits === \'function\' ? calculateChangedBits(oldValue, newValue) : MAX_SIGNED_31_BIT_INT;\n\n          if (false) {}\n\n          changedBits |= 0;\n\n          if (changedBits !== 0) {\n            this.emitter.set(nextProps.value, changedBits);\n          }\n        }\n      }\n    };\n\n    _proto.render = function render() {\n      return this.props.children;\n    };\n\n    return Provider;\n  }(react.Component);\n\n  Provider.childContextTypes = (_Provider$childContex = {}, _Provider$childContex[contextProp] = (prop_types_default()).object.isRequired, _Provider$childContex);\n\n  var Consumer = /*#__PURE__*/function (_Component2) {\n    _inheritsLoose(Consumer, _Component2);\n\n    function Consumer() {\n      var _this2;\n\n      _this2 = _Component2.apply(this, arguments) || this;\n      _this2.state = {\n        value: _this2.getValue()\n      };\n\n      _this2.onUpdate = function (newValue, changedBits) {\n        var observedBits = _this2.observedBits | 0;\n\n        if ((observedBits & changedBits) !== 0) {\n          _this2.setState({\n            value: _this2.getValue()\n          });\n        }\n      };\n\n      return _this2;\n    }\n\n    var _proto2 = Consumer.prototype;\n\n    _proto2.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {\n      var observedBits = nextProps.observedBits;\n      this.observedBits = observedBits === undefined || observedBits === null ? MAX_SIGNED_31_BIT_INT : observedBits;\n    };\n\n    _proto2.componentDidMount = function componentDidMount() {\n      if (this.context[contextProp]) {\n        this.context[contextProp].on(this.onUpdate);\n      }\n\n      var observedBits = this.props.observedBits;\n      this.observedBits = observedBits === undefined || observedBits === null ? MAX_SIGNED_31_BIT_INT : observedBits;\n    };\n\n    _proto2.componentWillUnmount = function componentWillUnmount() {\n      if (this.context[contextProp]) {\n        this.context[contextProp].off(this.onUpdate);\n      }\n    };\n\n    _proto2.getValue = function getValue() {\n      if (this.context[contextProp]) {\n        return this.context[contextProp].get();\n      } else {\n        return defaultValue;\n      }\n    };\n\n    _proto2.render = function render() {\n      return onlyChild(this.props.children)(this.state.value);\n    };\n\n    return Consumer;\n  }(react.Component);\n\n  Consumer.contextTypes = (_Consumer$contextType = {}, _Consumer$contextType[contextProp] = (prop_types_default()).object, _Consumer$contextType);\n  return {\n    Provider: Provider,\n    Consumer: Consumer\n  };\n}\n\nvar index = react.createContext || createReactContext;\n\n/* harmony default export */ const esm = (index);\n\n// EXTERNAL MODULE: ./node_modules/path-to-regexp/index.js\nvar path_to_regexp = __webpack_require__(779);\nvar path_to_regexp_default = /*#__PURE__*/__webpack_require__.n(path_to_regexp);\n// EXTERNAL MODULE: ./node_modules/react-is/index.js\nvar react_is = __webpack_require__(864);\n;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/objectWithoutPropertiesLoose.js\nfunction objectWithoutPropertiesLoose_objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}\n// EXTERNAL MODULE: ./node_modules/hoist-non-react-statics/dist/hoist-non-react-statics.cjs.js\nvar hoist_non_react_statics_cjs = __webpack_require__(679);\n;// CONCATENATED MODULE: ./node_modules/react-router/esm/react-router.js\n\n\n\n\n\n\n\n\n\n\n\n\n\n// TODO: Replace with React.createContext once we can assume React 16+\n\nvar createNamedContext = function createNamedContext(name) {\n  var context = esm();\n  context.displayName = name;\n  return context;\n};\n\nvar historyContext = /*#__PURE__*/createNamedContext("Router-History");\n\nvar context = /*#__PURE__*/createNamedContext("Router");\n\n/**\n * The public API for putting history on context.\n */\n\nvar Router = /*#__PURE__*/function (_React$Component) {\n  _inheritsLoose(Router, _React$Component);\n\n  Router.computeRootMatch = function computeRootMatch(pathname) {\n    return {\n      path: "/",\n      url: "/",\n      params: {},\n      isExact: pathname === "/"\n    };\n  };\n\n  function Router(props) {\n    var _this;\n\n    _this = _React$Component.call(this, props) || this;\n    _this.state = {\n      location: props.history.location\n    }; // This is a bit of a hack. We have to start listening for location\n    // changes here in the constructor in case there are any <Redirect>s\n    // on the initial render. If there are, they will replace/push when\n    // they mount and since cDM fires in children before parents, we may\n    // get a new location before the <Router> is mounted.\n\n    _this._isMounted = false;\n    _this._pendingLocation = null;\n\n    if (!props.staticContext) {\n      _this.unlisten = props.history.listen(function (location) {\n        if (_this._isMounted) {\n          _this.setState({\n            location: location\n          });\n        } else {\n          _this._pendingLocation = location;\n        }\n      });\n    }\n\n    return _this;\n  }\n\n  var _proto = Router.prototype;\n\n  _proto.componentDidMount = function componentDidMount() {\n    this._isMounted = true;\n\n    if (this._pendingLocation) {\n      this.setState({\n        location: this._pendingLocation\n      });\n    }\n  };\n\n  _proto.componentWillUnmount = function componentWillUnmount() {\n    if (this.unlisten) {\n      this.unlisten();\n      this._isMounted = false;\n      this._pendingLocation = null;\n    }\n  };\n\n  _proto.render = function render() {\n    return /*#__PURE__*/react.createElement(context.Provider, {\n      value: {\n        history: this.props.history,\n        location: this.state.location,\n        match: Router.computeRootMatch(this.state.location.pathname),\n        staticContext: this.props.staticContext\n      }\n    }, /*#__PURE__*/react.createElement(historyContext.Provider, {\n      children: this.props.children || null,\n      value: this.props.history\n    }));\n  };\n\n  return Router;\n}(react.Component);\n\nif (false) {}\n\n/**\n * The public API for a <Router> that stores location in memory.\n */\n\nvar MemoryRouter = /*#__PURE__*/function (_React$Component) {\n  _inheritsLoose(MemoryRouter, _React$Component);\n\n  function MemoryRouter() {\n    var _this;\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;\n    _this.history = createMemoryHistory(_this.props);\n    return _this;\n  }\n\n  var _proto = MemoryRouter.prototype;\n\n  _proto.render = function render() {\n    return /*#__PURE__*/react.createElement(Router, {\n      history: this.history,\n      children: this.props.children\n    });\n  };\n\n  return MemoryRouter;\n}(react.Component);\n\nif (false) {}\n\nvar Lifecycle = /*#__PURE__*/function (_React$Component) {\n  _inheritsLoose(Lifecycle, _React$Component);\n\n  function Lifecycle() {\n    return _React$Component.apply(this, arguments) || this;\n  }\n\n  var _proto = Lifecycle.prototype;\n\n  _proto.componentDidMount = function componentDidMount() {\n    if (this.props.onMount) this.props.onMount.call(this, this);\n  };\n\n  _proto.componentDidUpdate = function componentDidUpdate(prevProps) {\n    if (this.props.onUpdate) this.props.onUpdate.call(this, this, prevProps);\n  };\n\n  _proto.componentWillUnmount = function componentWillUnmount() {\n    if (this.props.onUnmount) this.props.onUnmount.call(this, this);\n  };\n\n  _proto.render = function render() {\n    return null;\n  };\n\n  return Lifecycle;\n}(react.Component);\n\n/**\n * The public API for prompting the user before navigating away from a screen.\n */\n\nfunction Prompt(_ref) {\n  var message = _ref.message,\n      _ref$when = _ref.when,\n      when = _ref$when === void 0 ? true : _ref$when;\n  return /*#__PURE__*/React.createElement(context.Consumer, null, function (context) {\n    !context ?  false ? 0 : invariant(false) : void 0;\n    if (!when || context.staticContext) return null;\n    var method = context.history.block;\n    return /*#__PURE__*/React.createElement(Lifecycle, {\n      onMount: function onMount(self) {\n        self.release = method(message);\n      },\n      onUpdate: function onUpdate(self, prevProps) {\n        if (prevProps.message !== message) {\n          self.release();\n          self.release = method(message);\n        }\n      },\n      onUnmount: function onUnmount(self) {\n        self.release();\n      },\n      message: message\n    });\n  });\n}\n\nif (false) { var messageType; }\n\nvar cache = {};\nvar cacheLimit = 10000;\nvar cacheCount = 0;\n\nfunction compilePath(path) {\n  if (cache[path]) return cache[path];\n  var generator = pathToRegexp.compile(path);\n\n  if (cacheCount < cacheLimit) {\n    cache[path] = generator;\n    cacheCount++;\n  }\n\n  return generator;\n}\n/**\n * Public API for generating a URL pathname from a path and parameters.\n */\n\n\nfunction generatePath(path, params) {\n  if (path === void 0) {\n    path = "/";\n  }\n\n  if (params === void 0) {\n    params = {};\n  }\n\n  return path === "/" ? path : compilePath(path)(params, {\n    pretty: true\n  });\n}\n\n/**\n * The public API for navigating programmatically with a component.\n */\n\nfunction Redirect(_ref) {\n  var computedMatch = _ref.computedMatch,\n      to = _ref.to,\n      _ref$push = _ref.push,\n      push = _ref$push === void 0 ? false : _ref$push;\n  return /*#__PURE__*/React.createElement(context.Consumer, null, function (context) {\n    !context ?  false ? 0 : invariant(false) : void 0;\n    var history = context.history,\n        staticContext = context.staticContext;\n    var method = push ? history.push : history.replace;\n    var location = createLocation(computedMatch ? typeof to === "string" ? generatePath(to, computedMatch.params) : _extends({}, to, {\n      pathname: generatePath(to.pathname, computedMatch.params)\n    }) : to); // When rendering in a static context,\n    // set the new location immediately.\n\n    if (staticContext) {\n      method(location);\n      return null;\n    }\n\n    return /*#__PURE__*/React.createElement(Lifecycle, {\n      onMount: function onMount() {\n        method(location);\n      },\n      onUpdate: function onUpdate(self, prevProps) {\n        var prevLocation = createLocation(prevProps.to);\n\n        if (!locationsAreEqual(prevLocation, _extends({}, location, {\n          key: prevLocation.key\n        }))) {\n          method(location);\n        }\n      },\n      to: to\n    });\n  });\n}\n\nif (false) {}\n\nvar cache$1 = {};\nvar cacheLimit$1 = 10000;\nvar cacheCount$1 = 0;\n\nfunction compilePath$1(path, options) {\n  var cacheKey = "" + options.end + options.strict + options.sensitive;\n  var pathCache = cache$1[cacheKey] || (cache$1[cacheKey] = {});\n  if (pathCache[path]) return pathCache[path];\n  var keys = [];\n  var regexp = path_to_regexp_default()(path, keys, options);\n  var result = {\n    regexp: regexp,\n    keys: keys\n  };\n\n  if (cacheCount$1 < cacheLimit$1) {\n    pathCache[path] = result;\n    cacheCount$1++;\n  }\n\n  return result;\n}\n/**\n * Public API for matching a URL pathname to a path.\n */\n\n\nfunction matchPath(pathname, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  if (typeof options === "string" || Array.isArray(options)) {\n    options = {\n      path: options\n    };\n  }\n\n  var _options = options,\n      path = _options.path,\n      _options$exact = _options.exact,\n      exact = _options$exact === void 0 ? false : _options$exact,\n      _options$strict = _options.strict,\n      strict = _options$strict === void 0 ? false : _options$strict,\n      _options$sensitive = _options.sensitive,\n      sensitive = _options$sensitive === void 0 ? false : _options$sensitive;\n  var paths = [].concat(path);\n  return paths.reduce(function (matched, path) {\n    if (!path && path !== "") return null;\n    if (matched) return matched;\n\n    var _compilePath = compilePath$1(path, {\n      end: exact,\n      strict: strict,\n      sensitive: sensitive\n    }),\n        regexp = _compilePath.regexp,\n        keys = _compilePath.keys;\n\n    var match = regexp.exec(pathname);\n    if (!match) return null;\n    var url = match[0],\n        values = match.slice(1);\n    var isExact = pathname === url;\n    if (exact && !isExact) return null;\n    return {\n      path: path,\n      // the path used to match\n      url: path === "/" && url === "" ? "/" : url,\n      // the matched portion of the URL\n      isExact: isExact,\n      // whether or not we matched exactly\n      params: keys.reduce(function (memo, key, index) {\n        memo[key.name] = values[index];\n        return memo;\n      }, {})\n    };\n  }, null);\n}\n\nfunction isEmptyChildren(children) {\n  return react.Children.count(children) === 0;\n}\n\nfunction evalChildrenDev(children, props, path) {\n  var value = children(props);\n   false ? 0 : void 0;\n  return value || null;\n}\n/**\n * The public API for matching a single path and rendering.\n */\n\n\nvar Route = /*#__PURE__*/function (_React$Component) {\n  _inheritsLoose(Route, _React$Component);\n\n  function Route() {\n    return _React$Component.apply(this, arguments) || this;\n  }\n\n  var _proto = Route.prototype;\n\n  _proto.render = function render() {\n    var _this = this;\n\n    return /*#__PURE__*/react.createElement(context.Consumer, null, function (context$1) {\n      !context$1 ?  false ? 0 : tiny_invariant_esm(false) : void 0;\n      var location = _this.props.location || context$1.location;\n      var match = _this.props.computedMatch ? _this.props.computedMatch // <Switch> already computed the match for us\n      : _this.props.path ? matchPath(location.pathname, _this.props) : context$1.match;\n\n      var props = extends_extends({}, context$1, {\n        location: location,\n        match: match\n      });\n\n      var _this$props = _this.props,\n          children = _this$props.children,\n          component = _this$props.component,\n          render = _this$props.render; // Preact uses an empty array as children by\n      // default, so use null if that\'s the case.\n\n      if (Array.isArray(children) && isEmptyChildren(children)) {\n        children = null;\n      }\n\n      return /*#__PURE__*/react.createElement(context.Provider, {\n        value: props\n      }, props.match ? children ? typeof children === "function" ?  false ? 0 : children(props) : children : component ? /*#__PURE__*/react.createElement(component, props) : render ? render(props) : null : typeof children === "function" ?  false ? 0 : children(props) : null);\n    });\n  };\n\n  return Route;\n}(react.Component);\n\nif (false) {}\n\nfunction react_router_addLeadingSlash(path) {\n  return path.charAt(0) === "/" ? path : "/" + path;\n}\n\nfunction addBasename(basename, location) {\n  if (!basename) return location;\n  return extends_extends({}, location, {\n    pathname: react_router_addLeadingSlash(basename) + location.pathname\n  });\n}\n\nfunction react_router_stripBasename(basename, location) {\n  if (!basename) return location;\n  var base = react_router_addLeadingSlash(basename);\n  if (location.pathname.indexOf(base) !== 0) return location;\n  return extends_extends({}, location, {\n    pathname: location.pathname.substr(base.length)\n  });\n}\n\nfunction createURL(location) {\n  return typeof location === "string" ? location : createPath(location);\n}\n\nfunction staticHandler(methodName) {\n  return function () {\n      false ? 0 : tiny_invariant_esm(false) ;\n  };\n}\n\nfunction noop() {}\n/**\n * The public top-level API for a "static" <Router>, so-called because it\n * can\'t actually change the current location. Instead, it just records\n * location changes in a context object. Useful mainly in testing and\n * server-rendering scenarios.\n */\n\n\nvar StaticRouter = /*#__PURE__*/function (_React$Component) {\n  _inheritsLoose(StaticRouter, _React$Component);\n\n  function StaticRouter() {\n    var _this;\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;\n\n    _this.handlePush = function (location) {\n      return _this.navigateTo(location, "PUSH");\n    };\n\n    _this.handleReplace = function (location) {\n      return _this.navigateTo(location, "REPLACE");\n    };\n\n    _this.handleListen = function () {\n      return noop;\n    };\n\n    _this.handleBlock = function () {\n      return noop;\n    };\n\n    return _this;\n  }\n\n  var _proto = StaticRouter.prototype;\n\n  _proto.navigateTo = function navigateTo(location, action) {\n    var _this$props = this.props,\n        _this$props$basename = _this$props.basename,\n        basename = _this$props$basename === void 0 ? "" : _this$props$basename,\n        _this$props$context = _this$props.context,\n        context = _this$props$context === void 0 ? {} : _this$props$context;\n    context.action = action;\n    context.location = addBasename(basename, history_createLocation(location));\n    context.url = createURL(context.location);\n  };\n\n  _proto.render = function render() {\n    var _this$props2 = this.props,\n        _this$props2$basename = _this$props2.basename,\n        basename = _this$props2$basename === void 0 ? "" : _this$props2$basename,\n        _this$props2$context = _this$props2.context,\n        context = _this$props2$context === void 0 ? {} : _this$props2$context,\n        _this$props2$location = _this$props2.location,\n        location = _this$props2$location === void 0 ? "/" : _this$props2$location,\n        rest = objectWithoutPropertiesLoose_objectWithoutPropertiesLoose(_this$props2, ["basename", "context", "location"]);\n\n    var history = {\n      createHref: function createHref(path) {\n        return react_router_addLeadingSlash(basename + createURL(path));\n      },\n      action: "POP",\n      location: react_router_stripBasename(basename, history_createLocation(location)),\n      push: this.handlePush,\n      replace: this.handleReplace,\n      go: staticHandler("go"),\n      goBack: staticHandler("goBack"),\n      goForward: staticHandler("goForward"),\n      listen: this.handleListen,\n      block: this.handleBlock\n    };\n    return /*#__PURE__*/react.createElement(Router, extends_extends({}, rest, {\n      history: history,\n      staticContext: context\n    }));\n  };\n\n  return StaticRouter;\n}(react.Component);\n\nif (false) {}\n\n/**\n * The public API for rendering the first <Route> that matches.\n */\n\nvar Switch = /*#__PURE__*/function (_React$Component) {\n  _inheritsLoose(Switch, _React$Component);\n\n  function Switch() {\n    return _React$Component.apply(this, arguments) || this;\n  }\n\n  var _proto = Switch.prototype;\n\n  _proto.render = function render() {\n    var _this = this;\n\n    return /*#__PURE__*/react.createElement(context.Consumer, null, function (context) {\n      !context ?  false ? 0 : tiny_invariant_esm(false) : void 0;\n      var location = _this.props.location || context.location;\n      var element, match; // We use React.Children.forEach instead of React.Children.toArray().find()\n      // here because toArray adds keys to all child elements and we do not want\n      // to trigger an unmount/remount for two <Route>s that render the same\n      // component at different URLs.\n\n      react.Children.forEach(_this.props.children, function (child) {\n        if (match == null && /*#__PURE__*/react.isValidElement(child)) {\n          element = child;\n          var path = child.props.path || child.props.from;\n          match = path ? matchPath(location.pathname, extends_extends({}, child.props, {\n            path: path\n          })) : context.match;\n        }\n      });\n      return match ? /*#__PURE__*/react.cloneElement(element, {\n        location: location,\n        computedMatch: match\n      }) : null;\n    });\n  };\n\n  return Switch;\n}(react.Component);\n\nif (false) {}\n\n/**\n * A public higher-order component to access the imperative API\n */\n\nfunction withRouter(Component) {\n  var displayName = "withRouter(" + (Component.displayName || Component.name) + ")";\n\n  var C = function C(props) {\n    var wrappedComponentRef = props.wrappedComponentRef,\n        remainingProps = _objectWithoutPropertiesLoose(props, ["wrappedComponentRef"]);\n\n    return /*#__PURE__*/React.createElement(context.Consumer, null, function (context) {\n      !context ?  false ? 0 : invariant(false) : void 0;\n      return /*#__PURE__*/React.createElement(Component, _extends({}, remainingProps, context, {\n        ref: wrappedComponentRef\n      }));\n    });\n  };\n\n  C.displayName = displayName;\n  C.WrappedComponent = Component;\n\n  if (false) {}\n\n  return hoistStatics(C, Component);\n}\n\nvar useContext = react.useContext;\nfunction useHistory() {\n  if (false) {}\n\n  return useContext(historyContext);\n}\nfunction useLocation() {\n  if (false) {}\n\n  return useContext(context).location;\n}\nfunction useParams() {\n  if (false) {}\n\n  var match = useContext(context).match;\n  return match ? match.params : {};\n}\nfunction useRouteMatch(path) {\n  if (false) {}\n\n  var location = useLocation();\n  var match = useContext(context).match;\n  return path ? matchPath(location.pathname, path) : match;\n}\n\nif (false) { var secondaryBuildName, initialBuildName, buildNames, key, global; }\n\n\n//# sourceMappingURL=react-router.js.map\n\n;// CONCATENATED MODULE: ./node_modules/react-router-dom/esm/react-router-dom.js\n\n\n\n\n\n\n\n\n\n\n\n/**\n * The public API for a <Router> that uses HTML5 history.\n */\n\nvar BrowserRouter = /*#__PURE__*/function (_React$Component) {\n  _inheritsLoose(BrowserRouter, _React$Component);\n\n  function BrowserRouter() {\n    var _this;\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;\n    _this.history = createBrowserHistory(_this.props);\n    return _this;\n  }\n\n  var _proto = BrowserRouter.prototype;\n\n  _proto.render = function render() {\n    return /*#__PURE__*/react.createElement(Router, {\n      history: this.history,\n      children: this.props.children\n    });\n  };\n\n  return BrowserRouter;\n}(react.Component);\n\nif (false) {}\n\n/**\n * The public API for a <Router> that uses window.location.hash.\n */\n\nvar HashRouter = /*#__PURE__*/function (_React$Component) {\n  _inheritsLoose(HashRouter, _React$Component);\n\n  function HashRouter() {\n    var _this;\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;\n    _this.history = createHashHistory(_this.props);\n    return _this;\n  }\n\n  var _proto = HashRouter.prototype;\n\n  _proto.render = function render() {\n    return /*#__PURE__*/react.createElement(Router, {\n      history: this.history,\n      children: this.props.children\n    });\n  };\n\n  return HashRouter;\n}(react.Component);\n\nif (false) {}\n\nvar resolveToLocation = function resolveToLocation(to, currentLocation) {\n  return typeof to === "function" ? to(currentLocation) : to;\n};\nvar normalizeToLocation = function normalizeToLocation(to, currentLocation) {\n  return typeof to === "string" ? history_createLocation(to, null, null, currentLocation) : to;\n};\n\nvar forwardRefShim = function forwardRefShim(C) {\n  return C;\n};\n\nvar react_router_dom_forwardRef = react.forwardRef;\n\nif (typeof react_router_dom_forwardRef === "undefined") {\n  react_router_dom_forwardRef = forwardRefShim;\n}\n\nfunction isModifiedEvent(event) {\n  return !!(event.metaKey || event.altKey || event.ctrlKey || event.shiftKey);\n}\n\nvar LinkAnchor = react_router_dom_forwardRef(function (_ref, forwardedRef) {\n  var innerRef = _ref.innerRef,\n      navigate = _ref.navigate,\n      _onClick = _ref.onClick,\n      rest = objectWithoutPropertiesLoose_objectWithoutPropertiesLoose(_ref, ["innerRef", "navigate", "onClick"]);\n\n  var target = rest.target;\n\n  var props = extends_extends({}, rest, {\n    onClick: function onClick(event) {\n      try {\n        if (_onClick) _onClick(event);\n      } catch (ex) {\n        event.preventDefault();\n        throw ex;\n      }\n\n      if (!event.defaultPrevented && // onClick prevented default\n      event.button === 0 && ( // ignore everything but left clicks\n      !target || target === "_self") && // let browser handle "target=_blank" etc.\n      !isModifiedEvent(event) // ignore clicks with modifier keys\n      ) {\n          event.preventDefault();\n          navigate();\n        }\n    }\n  }); // React 15 compat\n\n\n  if (forwardRefShim !== react_router_dom_forwardRef) {\n    props.ref = forwardedRef || innerRef;\n  } else {\n    props.ref = innerRef;\n  }\n  /* eslint-disable-next-line jsx-a11y/anchor-has-content */\n\n\n  return /*#__PURE__*/react.createElement("a", props);\n});\n\nif (false) {}\n/**\n * The public API for rendering a history-aware <a>.\n */\n\n\nvar Link = react_router_dom_forwardRef(function (_ref2, forwardedRef) {\n  var _ref2$component = _ref2.component,\n      component = _ref2$component === void 0 ? LinkAnchor : _ref2$component,\n      replace = _ref2.replace,\n      to = _ref2.to,\n      innerRef = _ref2.innerRef,\n      rest = objectWithoutPropertiesLoose_objectWithoutPropertiesLoose(_ref2, ["component", "replace", "to", "innerRef"]);\n\n  return /*#__PURE__*/react.createElement(context.Consumer, null, function (context) {\n    !context ?  false ? 0 : tiny_invariant_esm(false) : void 0;\n    var history = context.history;\n    var location = normalizeToLocation(resolveToLocation(to, context.location), context.location);\n    var href = location ? history.createHref(location) : "";\n\n    var props = extends_extends({}, rest, {\n      href: href,\n      navigate: function navigate() {\n        var location = resolveToLocation(to, context.location);\n        var isDuplicateNavigation = createPath(context.location) === createPath(normalizeToLocation(location));\n        var method = replace || isDuplicateNavigation ? history.replace : history.push;\n        method(location);\n      }\n    }); // React 15 compat\n\n\n    if (forwardRefShim !== react_router_dom_forwardRef) {\n      props.ref = forwardedRef || innerRef;\n    } else {\n      props.innerRef = innerRef;\n    }\n\n    return /*#__PURE__*/react.createElement(component, props);\n  });\n});\n\nif (false) { var refType, toType; }\n\nvar forwardRefShim$1 = function forwardRefShim(C) {\n  return C;\n};\n\nvar forwardRef$1 = react.forwardRef;\n\nif (typeof forwardRef$1 === "undefined") {\n  forwardRef$1 = forwardRefShim$1;\n}\n\nfunction joinClassnames() {\n  for (var _len = arguments.length, classnames = new Array(_len), _key = 0; _key < _len; _key++) {\n    classnames[_key] = arguments[_key];\n  }\n\n  return classnames.filter(function (i) {\n    return i;\n  }).join(" ");\n}\n/**\n * A <Link> wrapper that knows if it\'s "active" or not.\n */\n\n\nvar NavLink = forwardRef$1(function (_ref, forwardedRef) {\n  var _ref$ariaCurrent = _ref["aria-current"],\n      ariaCurrent = _ref$ariaCurrent === void 0 ? "page" : _ref$ariaCurrent,\n      _ref$activeClassName = _ref.activeClassName,\n      activeClassName = _ref$activeClassName === void 0 ? "active" : _ref$activeClassName,\n      activeStyle = _ref.activeStyle,\n      classNameProp = _ref.className,\n      exact = _ref.exact,\n      isActiveProp = _ref.isActive,\n      locationProp = _ref.location,\n      sensitive = _ref.sensitive,\n      strict = _ref.strict,\n      styleProp = _ref.style,\n      to = _ref.to,\n      innerRef = _ref.innerRef,\n      rest = objectWithoutPropertiesLoose_objectWithoutPropertiesLoose(_ref, ["aria-current", "activeClassName", "activeStyle", "className", "exact", "isActive", "location", "sensitive", "strict", "style", "to", "innerRef"]);\n\n  return /*#__PURE__*/react.createElement(context.Consumer, null, function (context) {\n    !context ?  false ? 0 : tiny_invariant_esm(false) : void 0;\n    var currentLocation = locationProp || context.location;\n    var toLocation = normalizeToLocation(resolveToLocation(to, currentLocation), currentLocation);\n    var path = toLocation.pathname; // Regex taken from: https://github.com/pillarjs/path-to-regexp/blob/master/index.js#L202\n\n    var escapedPath = path && path.replace(/([.+*?=^!:${}()[\\]|/\\\\])/g, "\\\\$1");\n    var match = escapedPath ? matchPath(currentLocation.pathname, {\n      path: escapedPath,\n      exact: exact,\n      sensitive: sensitive,\n      strict: strict\n    }) : null;\n    var isActive = !!(isActiveProp ? isActiveProp(match, currentLocation) : match);\n    var className = typeof classNameProp === "function" ? classNameProp(isActive) : classNameProp;\n    var style = typeof styleProp === "function" ? styleProp(isActive) : styleProp;\n\n    if (isActive) {\n      className = joinClassnames(className, activeClassName);\n      style = extends_extends({}, style, activeStyle);\n    }\n\n    var props = extends_extends({\n      "aria-current": isActive && ariaCurrent || null,\n      className: className,\n      style: style,\n      to: toLocation\n    }, rest); // React 15 compat\n\n\n    if (forwardRefShim$1 !== forwardRef$1) {\n      props.ref = forwardedRef || innerRef;\n    } else {\n      props.innerRef = innerRef;\n    }\n\n    return /*#__PURE__*/react.createElement(Link, props);\n  });\n});\n\nif (false) { var ariaCurrentType; }\n\n\n//# sourceMappingURL=react-router-dom.js.map\n\n// EXTERNAL MODULE: ./node_modules/react-dom/index.js\nvar react_dom = __webpack_require__(935);\n// EXTERNAL MODULE: ./node_modules/classnames/index.js\nvar classnames = __webpack_require__(184);\nvar classnames_default = /*#__PURE__*/__webpack_require__.n(classnames);\n;// CONCATENATED MODULE: ./src/component.js\nvar _excluded = ["component", "fallback", "className", "children"];\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = component_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction component_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\nfunction createComponent(_ref, fn) {\n  var displayName = _ref.displayName,\n      propTypes = _ref.propTypes,\n      defaultProps = _ref.defaultProps;\n  var Component = fn.length > 1 ? /*#__PURE__*/forwardRef(fn) : fn;\n  Component.displayName = displayName;\n  Component.propTypes = propTypes;\n  Component.defaultProps = defaultProps;\n  return Component;\n}\nvar Clone = /*#__PURE__*/(0,react.forwardRef)(function Clone(_ref2, ref) {\n  var component = _ref2.component,\n      fallback = _ref2.fallback,\n      className = _ref2.className,\n      _ref2$children = _ref2.children,\n      children = _ref2$children === void 0 ? component : _ref2$children,\n      props = _objectWithoutProperties(_ref2, _excluded);\n\n  if ( /*#__PURE__*/(0,react.isValidElement)(component)) {\n    return /*#__PURE__*/(0,react.cloneElement)(component, _objectSpread({\n      ref: ref,\n      className: classnames_default()(className, component.props.className)\n    }, props));\n  } else if ( /*#__PURE__*/(0,react.isValidElement)(fallback)) {\n    return /*#__PURE__*/(0,react.cloneElement)(fallback, _objectSpread({\n      ref: ref,\n      className: classnames_default()(className, fallback.props.className)\n    }, props));\n  } else if (fallback) {\n    return /*#__PURE__*/(0,react.createElement)(fallback, _objectSpread({\n      ref: ref,\n      className: className\n    }, props), children);\n  } else {\n    return children;\n  }\n});\n\n;// CONCATENATED MODULE: ./src/icon/constants.js\nvar cssClasses = {\n  ROOT: \'mdc-icon\',\n  MATERIAL_ICONS: \'material-icons\',\n  LIGHT: \'mdc-icon--light\',\n  DARK: \'mdc-icon--dark\',\n  INACTIVE: \'mdc-icon--inactive\'\n};\n// EXTERNAL MODULE: ./node_modules/react/jsx-runtime.js\nvar jsx_runtime = __webpack_require__(893);\n;// CONCATENATED MODULE: ./src/icon/Icon.jsx\nvar Icon_excluded = ["size", "light", "dark", "inactive", "element", "component", "className"];\n\nfunction Icon_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction Icon_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { Icon_ownKeys(Object(source), true).forEach(function (key) { Icon_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { Icon_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction Icon_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction Icon_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = Icon_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction Icon_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\n\nvar Icon = /*#__PURE__*/(0,react.forwardRef)(function (_ref, ref) {\n  var _classnames;\n\n  var size = _ref.size,\n      _ref$light = _ref.light,\n      light = _ref$light === void 0 ? false : _ref$light,\n      _ref$dark = _ref.dark,\n      dark = _ref$dark === void 0 ? false : _ref$dark,\n      _ref$inactive = _ref.inactive,\n      inactive = _ref$inactive === void 0 ? false : _ref$inactive,\n      _ref$element = _ref.element,\n      element = _ref$element === void 0 ? \'i\' : _ref$element,\n      _ref$component = _ref.component,\n      Element = _ref$component === void 0 ? element : _ref$component,\n      className = _ref.className,\n      props = Icon_objectWithoutProperties(_ref, Icon_excluded);\n\n  var classNames = classnames_default()(cssClasses.ROOT, cssClasses.MATERIAL_ICONS, (_classnames = {}, Icon_defineProperty(_classnames, "".concat(cssClasses.ROOT, "--").concat(size), size), Icon_defineProperty(_classnames, cssClasses.LIGHT, light), Icon_defineProperty(_classnames, cssClasses.DARK, dark), Icon_defineProperty(_classnames, cssClasses.INACTIVE, inactive), _classnames), className);\n  return /*#__PURE__*/(0,jsx_runtime.jsx)(Element, Icon_objectSpread({\n    ref: ref,\n    className: classNames\n  }, props));\n});\nIcon.displayName = \'MDCIcon\';\nIcon.propTypes = {\n  size: (prop_types_default()).string,\n  dark: (prop_types_default()).bool,\n  light: (prop_types_default()).bool,\n  inactive: (prop_types_default()).bool\n};\n/* harmony default export */ const icon_Icon = (Icon);\n;// CONCATENATED MODULE: ./src/icon/index.js\n\n;// CONCATENATED MODULE: ./src/avatar/constants.js\nvar constants_cssClasses = {\n  ROOT: \'mdc-avatar\',\n  SMALL: \'mdc-avatar--small\',\n  MEDIUM: \'mdc-avatar--medium\',\n  LARGE: \'mdc-avatar--large\',\n  IMAGE: \'mdc-avatar__image\',\n  ICON: \'mdc-avatar__icon\',\n  TEXT: \'mdc-avatar__text\'\n};\n;// CONCATENATED MODULE: ./src/avatar/Avatar.jsx\nvar Avatar_excluded = ["src", "icon", "text", "size", "element", "component", "className", "alt", "children"];\n\nfunction Avatar_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction Avatar_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { Avatar_ownKeys(Object(source), true).forEach(function (key) { Avatar_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { Avatar_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction Avatar_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction Avatar_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = Avatar_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction Avatar_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\n\n\n\n\nvar Avatar = /*#__PURE__*/(0,react.forwardRef)(function (_ref, ref) {\n  var src = _ref.src,\n      icon = _ref.icon,\n      text = _ref.text,\n      size = _ref.size,\n      _ref$element = _ref.element,\n      element = _ref$element === void 0 ? \'span\' : _ref$element,\n      _ref$component = _ref.component,\n      Element = _ref$component === void 0 ? element : _ref$component,\n      className = _ref.className,\n      alt = _ref.alt,\n      _ref$children = _ref.children,\n      children = _ref$children === void 0 ? text : _ref$children,\n      props = Avatar_objectWithoutProperties(_ref, Avatar_excluded);\n\n  var classNames = classnames_default()(constants_cssClasses.ROOT, Avatar_defineProperty({}, "".concat(constants_cssClasses.ROOT, "--").concat(size), size), className);\n  return /*#__PURE__*/(0,jsx_runtime.jsxs)(Element, Avatar_objectSpread(Avatar_objectSpread({\n    ref: ref,\n    className: classNames\n  }, props), {}, {\n    children: [src && /*#__PURE__*/(0,jsx_runtime.jsx)("img", {\n      className: constants_cssClasses.IMAGE,\n      src: src,\n      alt: alt\n    }), icon && /*#__PURE__*/(0,jsx_runtime.jsx)(Clone, {\n      component: icon,\n      fallback: icon_Icon,\n      className: constants_cssClasses.ICON\n    }), children && /*#__PURE__*/(0,jsx_runtime.jsx)(Clone, {\n      component: children,\n      fallback: "span",\n      className: constants_cssClasses.TEXT\n    })]\n  }));\n});\nAvatar.displayName = \'MDCAvatar\';\nAvatar.propTypes = {\n  src: (prop_types_default()).string,\n  icon: (prop_types_default()).node,\n  text: (prop_types_default()).node,\n  size: prop_types_default().oneOf([\'small\', \'medium\', \'large\'])\n};\n/* harmony default export */ const avatar_Avatar = (Avatar);\n;// CONCATENATED MODULE: ./src/avatar/index.js\n\n;// CONCATENATED MODULE: ./src/badge/constants.js\nvar badge_constants_cssClasses = {\n  ROOT: \'mdc-badge\',\n  INSET: \'mdc-badge--inset\',\n  TRANSPARENT: \'mdc-badge--transparent\'\n};\n;// CONCATENATED MODULE: ./src/badge/Badge.jsx\nvar Badge_excluded = ["value", "inset", "transparent", "element", "className"];\n\nfunction Badge_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction Badge_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { Badge_ownKeys(Object(source), true).forEach(function (key) { Badge_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { Badge_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction Badge_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction Badge_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = Badge_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction Badge_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\n\nvar Badge = /*#__PURE__*/(0,react.forwardRef)(function (_ref, ref) {\n  var _classnames;\n\n  var value = _ref.value,\n      _ref$inset = _ref.inset,\n      inset = _ref$inset === void 0 ? false : _ref$inset,\n      _ref$transparent = _ref.transparent,\n      transparent = _ref$transparent === void 0 ? false : _ref$transparent,\n      _ref$element = _ref.element,\n      Element = _ref$element === void 0 ? \'span\' : _ref$element,\n      className = _ref.className,\n      props = Badge_objectWithoutProperties(_ref, Badge_excluded);\n\n  var classNames = classnames_default()(badge_constants_cssClasses.ROOT, (_classnames = {}, Badge_defineProperty(_classnames, badge_constants_cssClasses.INSET, inset), Badge_defineProperty(_classnames, badge_constants_cssClasses.TRANSPARENT, transparent), _classnames), className);\n  return /*#__PURE__*/(0,jsx_runtime.jsx)(Element, Badge_objectSpread({\n    ref: ref,\n    className: classNames,\n    "data-badge": value\n  }, props));\n});\nBadge.displayName = \'MDCBadge\';\nBadge.propTypes = {\n  value: prop_types_default().oneOfType([(prop_types_default()).number, (prop_types_default()).string]).isRequired,\n  inset: (prop_types_default()).bool,\n  transparent: (prop_types_default()).bool\n};\n/* harmony default export */ const badge_Badge = (Badge);\n;// CONCATENATED MODULE: ./src/badge/index.js\n\n;// CONCATENATED MODULE: ./node_modules/dom-helpers/esm/hasClass.js\n/**\n * Checks if a given element has a CSS class.\n * \n * @param element the element\n * @param className the CSS class name\n */\nfunction hasClass(element, className) {\n  if (element.classList) return !!className && element.classList.contains(className);\n  return (" " + (element.className.baseVal || element.className) + " ").indexOf(" " + className + " ") !== -1;\n}\n;// CONCATENATED MODULE: ./node_modules/dom-helpers/esm/addClass.js\n\n/**\n * Adds a CSS class to a given element.\n * \n * @param element the element\n * @param className the CSS class name\n */\n\nfunction addClass_addClass(element, className) {\n  if (element.classList) element.classList.add(className);else if (!hasClass(element, className)) if (typeof element.className === \'string\') element.className = element.className + " " + className;else element.setAttribute(\'class\', (element.className && element.className.baseVal || \'\') + " " + className);\n}\n;// CONCATENATED MODULE: ./node_modules/dom-helpers/esm/removeClass.js\nfunction replaceClassName(origClass, classToRemove) {\n  return origClass.replace(new RegExp("(^|\\\\s)" + classToRemove + "(?:\\\\s|$)", \'g\'), \'$1\').replace(/\\s+/g, \' \').replace(/^\\s*|\\s*$/g, \'\');\n}\n/**\n * Removes a CSS class from a given element.\n * \n * @param element the element\n * @param className the CSS class name\n */\n\n\nfunction removeClass_removeClass(element, className) {\n  if (element.classList) {\n    element.classList.remove(className);\n  } else if (typeof element.className === \'string\') {\n    element.className = replaceClassName(element.className, className);\n  } else {\n    element.setAttribute(\'class\', replaceClassName(element.className && element.className.baseVal || \'\', className));\n  }\n}\n;// CONCATENATED MODULE: ./node_modules/react-transition-group/esm/config.js\n/* harmony default export */ const config = ({\n  disabled: false\n});\n;// CONCATENATED MODULE: ./node_modules/react-transition-group/esm/TransitionGroupContext.js\n\n/* harmony default export */ const TransitionGroupContext = (react.createContext(null));\n;// CONCATENATED MODULE: ./node_modules/react-transition-group/esm/Transition.js\n\n\n\n\n\n\n\n\nvar UNMOUNTED = \'unmounted\';\nvar EXITED = \'exited\';\nvar ENTERING = \'entering\';\nvar ENTERED = \'entered\';\nvar EXITING = \'exiting\';\n/**\n * The Transition component lets you describe a transition from one component\n * state to another _over time_ with a simple declarative API. Most commonly\n * it\'s used to animate the mounting and unmounting of a component, but can also\n * be used to describe in-place transition states as well.\n *\n * ---\n *\n * **Note**: `Transition` is a platform-agnostic base component. If you\'re using\n * transitions in CSS, you\'ll probably want to use\n * [`CSSTransition`](https://reactcommunity.org/react-transition-group/css-transition)\n * instead. It inherits all the features of `Transition`, but contains\n * additional features necessary to play nice with CSS transitions (hence the\n * name of the component).\n *\n * ---\n *\n * By default the `Transition` component does not alter the behavior of the\n * component it renders, it only tracks "enter" and "exit" states for the\n * components. It\'s up to you to give meaning and effect to those states. For\n * example we can add styles to a component when it enters or exits:\n *\n * ```jsx\n * import { Transition } from \'react-transition-group\';\n *\n * const duration = 300;\n *\n * const defaultStyle = {\n *   transition: `opacity ${duration}ms ease-in-out`,\n *   opacity: 0,\n * }\n *\n * const transitionStyles = {\n *   entering: { opacity: 1 },\n *   entered:  { opacity: 1 },\n *   exiting:  { opacity: 0 },\n *   exited:  { opacity: 0 },\n * };\n *\n * const Fade = ({ in: inProp }) => (\n *   <Transition in={inProp} timeout={duration}>\n *     {state => (\n *       <div style={{\n *         ...defaultStyle,\n *         ...transitionStyles[state]\n *       }}>\n *         I\'m a fade Transition!\n *       </div>\n *     )}\n *   </Transition>\n * );\n * ```\n *\n * There are 4 main states a Transition can be in:\n *  - `\'entering\'`\n *  - `\'entered\'`\n *  - `\'exiting\'`\n *  - `\'exited\'`\n *\n * Transition state is toggled via the `in` prop. When `true` the component\n * begins the "Enter" stage. During this stage, the component will shift from\n * its current transition state, to `\'entering\'` for the duration of the\n * transition and then to the `\'entered\'` stage once it\'s complete. Let\'s take\n * the following example (we\'ll use the\n * [useState](https://reactjs.org/docs/hooks-reference.html#usestate) hook):\n *\n * ```jsx\n * function App() {\n *   const [inProp, setInProp] = useState(false);\n *   return (\n *     <div>\n *       <Transition in={inProp} timeout={500}>\n *         {state => (\n *           // ...\n *         )}\n *       </Transition>\n *       <button onClick={() => setInProp(true)}>\n *         Click to Enter\n *       </button>\n *     </div>\n *   );\n * }\n * ```\n *\n * When the button is clicked the component will shift to the `\'entering\'` state\n * and stay there for 500ms (the value of `timeout`) before it finally switches\n * to `\'entered\'`.\n *\n * When `in` is `false` the same thing happens except the state moves from\n * `\'exiting\'` to `\'exited\'`.\n */\n\nvar Transition = /*#__PURE__*/function (_React$Component) {\n  _inheritsLoose(Transition, _React$Component);\n\n  function Transition(props, context) {\n    var _this;\n\n    _this = _React$Component.call(this, props, context) || this;\n    var parentGroup = context; // In the context of a TransitionGroup all enters are really appears\n\n    var appear = parentGroup && !parentGroup.isMounting ? props.enter : props.appear;\n    var initialStatus;\n    _this.appearStatus = null;\n\n    if (props.in) {\n      if (appear) {\n        initialStatus = EXITED;\n        _this.appearStatus = ENTERING;\n      } else {\n        initialStatus = ENTERED;\n      }\n    } else {\n      if (props.unmountOnExit || props.mountOnEnter) {\n        initialStatus = UNMOUNTED;\n      } else {\n        initialStatus = EXITED;\n      }\n    }\n\n    _this.state = {\n      status: initialStatus\n    };\n    _this.nextCallback = null;\n    return _this;\n  }\n\n  Transition.getDerivedStateFromProps = function getDerivedStateFromProps(_ref, prevState) {\n    var nextIn = _ref.in;\n\n    if (nextIn && prevState.status === UNMOUNTED) {\n      return {\n        status: EXITED\n      };\n    }\n\n    return null;\n  } // getSnapshotBeforeUpdate(prevProps) {\n  //   let nextStatus = null\n  //   if (prevProps !== this.props) {\n  //     const { status } = this.state\n  //     if (this.props.in) {\n  //       if (status !== ENTERING && status !== ENTERED) {\n  //         nextStatus = ENTERING\n  //       }\n  //     } else {\n  //       if (status === ENTERING || status === ENTERED) {\n  //         nextStatus = EXITING\n  //       }\n  //     }\n  //   }\n  //   return { nextStatus }\n  // }\n  ;\n\n  var _proto = Transition.prototype;\n\n  _proto.componentDidMount = function componentDidMount() {\n    this.updateStatus(true, this.appearStatus);\n  };\n\n  _proto.componentDidUpdate = function componentDidUpdate(prevProps) {\n    var nextStatus = null;\n\n    if (prevProps !== this.props) {\n      var status = this.state.status;\n\n      if (this.props.in) {\n        if (status !== ENTERING && status !== ENTERED) {\n          nextStatus = ENTERING;\n        }\n      } else {\n        if (status === ENTERING || status === ENTERED) {\n          nextStatus = EXITING;\n        }\n      }\n    }\n\n    this.updateStatus(false, nextStatus);\n  };\n\n  _proto.componentWillUnmount = function componentWillUnmount() {\n    this.cancelNextCallback();\n  };\n\n  _proto.getTimeouts = function getTimeouts() {\n    var timeout = this.props.timeout;\n    var exit, enter, appear;\n    exit = enter = appear = timeout;\n\n    if (timeout != null && typeof timeout !== \'number\') {\n      exit = timeout.exit;\n      enter = timeout.enter; // TODO: remove fallback for next major\n\n      appear = timeout.appear !== undefined ? timeout.appear : enter;\n    }\n\n    return {\n      exit: exit,\n      enter: enter,\n      appear: appear\n    };\n  };\n\n  _proto.updateStatus = function updateStatus(mounting, nextStatus) {\n    if (mounting === void 0) {\n      mounting = false;\n    }\n\n    if (nextStatus !== null) {\n      // nextStatus will always be ENTERING or EXITING.\n      this.cancelNextCallback();\n\n      if (nextStatus === ENTERING) {\n        this.performEnter(mounting);\n      } else {\n        this.performExit();\n      }\n    } else if (this.props.unmountOnExit && this.state.status === EXITED) {\n      this.setState({\n        status: UNMOUNTED\n      });\n    }\n  };\n\n  _proto.performEnter = function performEnter(mounting) {\n    var _this2 = this;\n\n    var enter = this.props.enter;\n    var appearing = this.context ? this.context.isMounting : mounting;\n\n    var _ref2 = this.props.nodeRef ? [appearing] : [react_dom.findDOMNode(this), appearing],\n        maybeNode = _ref2[0],\n        maybeAppearing = _ref2[1];\n\n    var timeouts = this.getTimeouts();\n    var enterTimeout = appearing ? timeouts.appear : timeouts.enter; // no enter animation skip right to ENTERED\n    // if we are mounting and running this it means appear _must_ be set\n\n    if (!mounting && !enter || config.disabled) {\n      this.safeSetState({\n        status: ENTERED\n      }, function () {\n        _this2.props.onEntered(maybeNode);\n      });\n      return;\n    }\n\n    this.props.onEnter(maybeNode, maybeAppearing);\n    this.safeSetState({\n      status: ENTERING\n    }, function () {\n      _this2.props.onEntering(maybeNode, maybeAppearing);\n\n      _this2.onTransitionEnd(enterTimeout, function () {\n        _this2.safeSetState({\n          status: ENTERED\n        }, function () {\n          _this2.props.onEntered(maybeNode, maybeAppearing);\n        });\n      });\n    });\n  };\n\n  _proto.performExit = function performExit() {\n    var _this3 = this;\n\n    var exit = this.props.exit;\n    var timeouts = this.getTimeouts();\n    var maybeNode = this.props.nodeRef ? undefined : react_dom.findDOMNode(this); // no exit animation skip right to EXITED\n\n    if (!exit || config.disabled) {\n      this.safeSetState({\n        status: EXITED\n      }, function () {\n        _this3.props.onExited(maybeNode);\n      });\n      return;\n    }\n\n    this.props.onExit(maybeNode);\n    this.safeSetState({\n      status: EXITING\n    }, function () {\n      _this3.props.onExiting(maybeNode);\n\n      _this3.onTransitionEnd(timeouts.exit, function () {\n        _this3.safeSetState({\n          status: EXITED\n        }, function () {\n          _this3.props.onExited(maybeNode);\n        });\n      });\n    });\n  };\n\n  _proto.cancelNextCallback = function cancelNextCallback() {\n    if (this.nextCallback !== null) {\n      this.nextCallback.cancel();\n      this.nextCallback = null;\n    }\n  };\n\n  _proto.safeSetState = function safeSetState(nextState, callback) {\n    // This shouldn\'t be necessary, but there are weird race conditions with\n    // setState callbacks and unmounting in testing, so always make sure that\n    // we can cancel any pending setState callbacks after we unmount.\n    callback = this.setNextCallback(callback);\n    this.setState(nextState, callback);\n  };\n\n  _proto.setNextCallback = function setNextCallback(callback) {\n    var _this4 = this;\n\n    var active = true;\n\n    this.nextCallback = function (event) {\n      if (active) {\n        active = false;\n        _this4.nextCallback = null;\n        callback(event);\n      }\n    };\n\n    this.nextCallback.cancel = function () {\n      active = false;\n    };\n\n    return this.nextCallback;\n  };\n\n  _proto.onTransitionEnd = function onTransitionEnd(timeout, handler) {\n    this.setNextCallback(handler);\n    var node = this.props.nodeRef ? this.props.nodeRef.current : react_dom.findDOMNode(this);\n    var doesNotHaveTimeoutOrListener = timeout == null && !this.props.addEndListener;\n\n    if (!node || doesNotHaveTimeoutOrListener) {\n      setTimeout(this.nextCallback, 0);\n      return;\n    }\n\n    if (this.props.addEndListener) {\n      var _ref3 = this.props.nodeRef ? [this.nextCallback] : [node, this.nextCallback],\n          maybeNode = _ref3[0],\n          maybeNextCallback = _ref3[1];\n\n      this.props.addEndListener(maybeNode, maybeNextCallback);\n    }\n\n    if (timeout != null) {\n      setTimeout(this.nextCallback, timeout);\n    }\n  };\n\n  _proto.render = function render() {\n    var status = this.state.status;\n\n    if (status === UNMOUNTED) {\n      return null;\n    }\n\n    var _this$props = this.props,\n        children = _this$props.children,\n        _in = _this$props.in,\n        _mountOnEnter = _this$props.mountOnEnter,\n        _unmountOnExit = _this$props.unmountOnExit,\n        _appear = _this$props.appear,\n        _enter = _this$props.enter,\n        _exit = _this$props.exit,\n        _timeout = _this$props.timeout,\n        _addEndListener = _this$props.addEndListener,\n        _onEnter = _this$props.onEnter,\n        _onEntering = _this$props.onEntering,\n        _onEntered = _this$props.onEntered,\n        _onExit = _this$props.onExit,\n        _onExiting = _this$props.onExiting,\n        _onExited = _this$props.onExited,\n        _nodeRef = _this$props.nodeRef,\n        childProps = objectWithoutPropertiesLoose_objectWithoutPropertiesLoose(_this$props, ["children", "in", "mountOnEnter", "unmountOnExit", "appear", "enter", "exit", "timeout", "addEndListener", "onEnter", "onEntering", "onEntered", "onExit", "onExiting", "onExited", "nodeRef"]);\n\n    return (\n      /*#__PURE__*/\n      // allows for nested Transitions\n      react.createElement(TransitionGroupContext.Provider, {\n        value: null\n      }, typeof children === \'function\' ? children(status, childProps) : react.cloneElement(react.Children.only(children), childProps))\n    );\n  };\n\n  return Transition;\n}(react.Component);\n\nTransition.contextType = TransitionGroupContext;\nTransition.propTypes =  false ? 0 : {}; // Name the function so it is clearer in the documentation\n\nfunction Transition_noop() {}\n\nTransition.defaultProps = {\n  in: false,\n  mountOnEnter: false,\n  unmountOnExit: false,\n  appear: false,\n  enter: true,\n  exit: true,\n  onEnter: Transition_noop,\n  onEntering: Transition_noop,\n  onEntered: Transition_noop,\n  onExit: Transition_noop,\n  onExiting: Transition_noop,\n  onExited: Transition_noop\n};\nTransition.UNMOUNTED = UNMOUNTED;\nTransition.EXITED = EXITED;\nTransition.ENTERING = ENTERING;\nTransition.ENTERED = ENTERED;\nTransition.EXITING = EXITING;\n/* harmony default export */ const esm_Transition = (Transition);\n;// CONCATENATED MODULE: ./node_modules/react-transition-group/esm/CSSTransition.js\n\n\n\n\n\n\n\n\n\n\nvar _addClass = function addClass(node, classes) {\n  return node && classes && classes.split(\' \').forEach(function (c) {\n    return addClass_addClass(node, c);\n  });\n};\n\nvar removeClass = function removeClass(node, classes) {\n  return node && classes && classes.split(\' \').forEach(function (c) {\n    return removeClass_removeClass(node, c);\n  });\n};\n/**\n * A transition component inspired by the excellent\n * [ng-animate](https://docs.angularjs.org/api/ngAnimate) library, you should\n * use it if you\'re using CSS transitions or animations. It\'s built upon the\n * [`Transition`](https://reactcommunity.org/react-transition-group/transition)\n * component, so it inherits all of its props.\n *\n * `CSSTransition` applies a pair of class names during the `appear`, `enter`,\n * and `exit` states of the transition. The first class is applied and then a\n * second `*-active` class in order to activate the CSS transition. After the\n * transition, matching `*-done` class names are applied to persist the\n * transition state.\n *\n * ```jsx\n * function App() {\n *   const [inProp, setInProp] = useState(false);\n *   return (\n *     <div>\n *       <CSSTransition in={inProp} timeout={200} classNames="my-node">\n *         <div>\n *           {"I\'ll receive my-node-* classes"}\n *         </div>\n *       </CSSTransition>\n *       <button type="button" onClick={() => setInProp(true)}>\n *         Click to Enter\n *       </button>\n *     </div>\n *   );\n * }\n * ```\n *\n * When the `in` prop is set to `true`, the child component will first receive\n * the class `example-enter`, then the `example-enter-active` will be added in\n * the next tick. `CSSTransition` [forces a\n * reflow](https://github.com/reactjs/react-transition-group/blob/5007303e729a74be66a21c3e2205e4916821524b/src/CSSTransition.js#L208-L215)\n * between before adding the `example-enter-active`. This is an important trick\n * because it allows us to transition between `example-enter` and\n * `example-enter-active` even though they were added immediately one after\n * another. Most notably, this is what makes it possible for us to animate\n * _appearance_.\n *\n * ```css\n * .my-node-enter {\n *   opacity: 0;\n * }\n * .my-node-enter-active {\n *   opacity: 1;\n *   transition: opacity 200ms;\n * }\n * .my-node-exit {\n *   opacity: 1;\n * }\n * .my-node-exit-active {\n *   opacity: 0;\n *   transition: opacity 200ms;\n * }\n * ```\n *\n * `*-active` classes represent which styles you want to animate **to**, so it\'s\n * important to add `transition` declaration only to them, otherwise transitions\n * might not behave as intended! This might not be obvious when the transitions\n * are symmetrical, i.e. when `*-enter-active` is the same as `*-exit`, like in\n * the example above (minus `transition`), but it becomes apparent in more\n * complex transitions.\n *\n * **Note**: If you\'re using the\n * [`appear`](http://reactcommunity.org/react-transition-group/transition#Transition-prop-appear)\n * prop, make sure to define styles for `.appear-*` classes as well.\n */\n\n\nvar CSSTransition = /*#__PURE__*/function (_React$Component) {\n  _inheritsLoose(CSSTransition, _React$Component);\n\n  function CSSTransition() {\n    var _this;\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;\n    _this.appliedClasses = {\n      appear: {},\n      enter: {},\n      exit: {}\n    };\n\n    _this.onEnter = function (maybeNode, maybeAppearing) {\n      var _this$resolveArgument = _this.resolveArguments(maybeNode, maybeAppearing),\n          node = _this$resolveArgument[0],\n          appearing = _this$resolveArgument[1];\n\n      _this.removeClasses(node, \'exit\');\n\n      _this.addClass(node, appearing ? \'appear\' : \'enter\', \'base\');\n\n      if (_this.props.onEnter) {\n        _this.props.onEnter(maybeNode, maybeAppearing);\n      }\n    };\n\n    _this.onEntering = function (maybeNode, maybeAppearing) {\n      var _this$resolveArgument2 = _this.resolveArguments(maybeNode, maybeAppearing),\n          node = _this$resolveArgument2[0],\n          appearing = _this$resolveArgument2[1];\n\n      var type = appearing ? \'appear\' : \'enter\';\n\n      _this.addClass(node, type, \'active\');\n\n      if (_this.props.onEntering) {\n        _this.props.onEntering(maybeNode, maybeAppearing);\n      }\n    };\n\n    _this.onEntered = function (maybeNode, maybeAppearing) {\n      var _this$resolveArgument3 = _this.resolveArguments(maybeNode, maybeAppearing),\n          node = _this$resolveArgument3[0],\n          appearing = _this$resolveArgument3[1];\n\n      var type = appearing ? \'appear\' : \'enter\';\n\n      _this.removeClasses(node, type);\n\n      _this.addClass(node, type, \'done\');\n\n      if (_this.props.onEntered) {\n        _this.props.onEntered(maybeNode, maybeAppearing);\n      }\n    };\n\n    _this.onExit = function (maybeNode) {\n      var _this$resolveArgument4 = _this.resolveArguments(maybeNode),\n          node = _this$resolveArgument4[0];\n\n      _this.removeClasses(node, \'appear\');\n\n      _this.removeClasses(node, \'enter\');\n\n      _this.addClass(node, \'exit\', \'base\');\n\n      if (_this.props.onExit) {\n        _this.props.onExit(maybeNode);\n      }\n    };\n\n    _this.onExiting = function (maybeNode) {\n      var _this$resolveArgument5 = _this.resolveArguments(maybeNode),\n          node = _this$resolveArgument5[0];\n\n      _this.addClass(node, \'exit\', \'active\');\n\n      if (_this.props.onExiting) {\n        _this.props.onExiting(maybeNode);\n      }\n    };\n\n    _this.onExited = function (maybeNode) {\n      var _this$resolveArgument6 = _this.resolveArguments(maybeNode),\n          node = _this$resolveArgument6[0];\n\n      _this.removeClasses(node, \'exit\');\n\n      _this.addClass(node, \'exit\', \'done\');\n\n      if (_this.props.onExited) {\n        _this.props.onExited(maybeNode);\n      }\n    };\n\n    _this.resolveArguments = function (maybeNode, maybeAppearing) {\n      return _this.props.nodeRef ? [_this.props.nodeRef.current, maybeNode] // here `maybeNode` is actually `appearing`\n      : [maybeNode, maybeAppearing];\n    };\n\n    _this.getClassNames = function (type) {\n      var classNames = _this.props.classNames;\n      var isStringClassNames = typeof classNames === \'string\';\n      var prefix = isStringClassNames && classNames ? classNames + "-" : \'\';\n      var baseClassName = isStringClassNames ? "" + prefix + type : classNames[type];\n      var activeClassName = isStringClassNames ? baseClassName + "-active" : classNames[type + "Active"];\n      var doneClassName = isStringClassNames ? baseClassName + "-done" : classNames[type + "Done"];\n      return {\n        baseClassName: baseClassName,\n        activeClassName: activeClassName,\n        doneClassName: doneClassName\n      };\n    };\n\n    return _this;\n  }\n\n  var _proto = CSSTransition.prototype;\n\n  _proto.addClass = function addClass(node, type, phase) {\n    var className = this.getClassNames(type)[phase + "ClassName"];\n\n    var _this$getClassNames = this.getClassNames(\'enter\'),\n        doneClassName = _this$getClassNames.doneClassName;\n\n    if (type === \'appear\' && phase === \'done\' && doneClassName) {\n      className += " " + doneClassName;\n    } // This is to force a repaint,\n    // which is necessary in order to transition styles when adding a class name.\n\n\n    if (phase === \'active\') {\n      /* eslint-disable no-unused-expressions */\n      node && node.scrollTop;\n    }\n\n    if (className) {\n      this.appliedClasses[type][phase] = className;\n\n      _addClass(node, className);\n    }\n  };\n\n  _proto.removeClasses = function removeClasses(node, type) {\n    var _this$appliedClasses$ = this.appliedClasses[type],\n        baseClassName = _this$appliedClasses$.base,\n        activeClassName = _this$appliedClasses$.active,\n        doneClassName = _this$appliedClasses$.done;\n    this.appliedClasses[type] = {};\n\n    if (baseClassName) {\n      removeClass(node, baseClassName);\n    }\n\n    if (activeClassName) {\n      removeClass(node, activeClassName);\n    }\n\n    if (doneClassName) {\n      removeClass(node, doneClassName);\n    }\n  };\n\n  _proto.render = function render() {\n    var _this$props = this.props,\n        _ = _this$props.classNames,\n        props = objectWithoutPropertiesLoose_objectWithoutPropertiesLoose(_this$props, ["classNames"]);\n\n    return /*#__PURE__*/react.createElement(esm_Transition, extends_extends({}, props, {\n      onEnter: this.onEnter,\n      onEntered: this.onEntered,\n      onEntering: this.onEntering,\n      onExit: this.onExit,\n      onExiting: this.onExiting,\n      onExited: this.onExited\n    }));\n  };\n\n  return CSSTransition;\n}(react.Component);\n\nCSSTransition.defaultProps = {\n  classNames: \'\'\n};\nCSSTransition.propTypes =  false ? 0 : {};\n/* harmony default export */ const esm_CSSTransition = (CSSTransition);\n;// CONCATENATED MODULE: ./src/banner/constants.js\nvar numbers = {\n  BANNER_ANIMATION_CLOSE_TIME_MS: 250,\n  BANNER_ANIMATION_OPEN_TIME_MS: 300\n};\nvar banner_constants_cssClasses = {\n  ROOT: \'mdc-banner\',\n  FIXED: \'mdc-banner--fixed\',\n  CENTERED: \'mdc-banner--centered\',\n  MOBILE_STACKED: \'mdc-banner--mobile-stacked\',\n  APPEARING: \'mdc-banner--appearing\',\n  APPEARED: \'mdc-banner--appeared\',\n  OPENING: \'mdc-banner--opening\',\n  OPEN: \'mdc-banner--open\',\n  CLOSING: \'mdc-banner--closing\',\n  CONTENT: \'mdc-banner__content\',\n  GRAPHIC_TEXT_WRAPPER: \'mdc-banner__graphic-text-wrapper\',\n  GRAPHIC: \'mdc-banner__graphic\',\n  ICON: \'mdc-banner__icon\',\n  TEXT: \'mdc-banner__text\',\n  ACTIONS: \'mdc-banner__actions\',\n  PRIMARY_ACTION: \'mdc-banner__primary-action\',\n  SECONDARY_ACTION: \'mdc-banner__secondary-action\'\n};\n;// CONCATENATED MODULE: ./src/banner/Banner.jsx\nvar Banner_excluded = ["text", "icon", "graphic", "action", "primaryAction", "secondaryAction", "open", "fixed", "centered", "mobileStacked", "element", "component", "className", "children"];\n\nfunction Banner_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction Banner_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { Banner_ownKeys(Object(source), true).forEach(function (key) { Banner_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { Banner_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction Banner_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction Banner_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = Banner_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction Banner_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\n\n\n\n\n\nvar Banner = /*#__PURE__*/(0,react.forwardRef)(function (_ref, ref) {\n  var _classnames;\n\n  var text = _ref.text,\n      icon = _ref.icon,\n      _ref$graphic = _ref.graphic,\n      graphic = _ref$graphic === void 0 ? icon : _ref$graphic,\n      action = _ref.action,\n      _ref$primaryAction = _ref.primaryAction,\n      primaryAction = _ref$primaryAction === void 0 ? action : _ref$primaryAction,\n      secondaryAction = _ref.secondaryAction,\n      _ref$open = _ref.open,\n      open = _ref$open === void 0 ? false : _ref$open,\n      _ref$fixed = _ref.fixed,\n      fixed = _ref$fixed === void 0 ? false : _ref$fixed,\n      _ref$centered = _ref.centered,\n      centered = _ref$centered === void 0 ? false : _ref$centered,\n      _ref$mobileStacked = _ref.mobileStacked,\n      mobileStacked = _ref$mobileStacked === void 0 ? false : _ref$mobileStacked,\n      _ref$element = _ref.element,\n      element = _ref$element === void 0 ? \'div\' : _ref$element,\n      _ref$component = _ref.component,\n      Element = _ref$component === void 0 ? element : _ref$component,\n      className = _ref.className,\n      _ref$children = _ref.children,\n      children = _ref$children === void 0 ? text : _ref$children,\n      props = Banner_objectWithoutProperties(_ref, Banner_excluded);\n\n  var rootRef = (0,react.useRef)();\n  var contentRef = (0,react.useRef)();\n  (0,react.useImperativeHandle)(ref, function () {\n    return rootRef.current;\n  });\n  var handleEntering = (0,react.useCallback)(function (node, isAppearing) {\n    if (!isAppearing) {\n      node.style.height = "".concat(contentRef.current.offsetHeight, "px");\n    }\n  }, []);\n  var handleExiting = (0,react.useCallback)(function (node) {\n    node.style.height = \'0px\';\n  }, []);\n  var classNames = classnames_default()(banner_constants_cssClasses.ROOT, (_classnames = {}, Banner_defineProperty(_classnames, banner_constants_cssClasses.FIXED, fixed), Banner_defineProperty(_classnames, banner_constants_cssClasses.CENTERED, centered), Banner_defineProperty(_classnames, banner_constants_cssClasses.MOBILE_STACKED, mobileStacked), _classnames), className);\n\n  var content = /*#__PURE__*/(0,jsx_runtime.jsxs)("div", {\n    ref: contentRef,\n    className: banner_constants_cssClasses.CONTENT,\n    role: "status",\n    children: [/*#__PURE__*/(0,jsx_runtime.jsxs)("div", {\n      className: banner_constants_cssClasses.GRAPHIC_TEXT_WRAPPER,\n      children: [graphic && /*#__PURE__*/(0,jsx_runtime.jsx)("div", {\n        className: banner_constants_cssClasses.GRAPHIC,\n        children: /*#__PURE__*/(0,jsx_runtime.jsx)(Clone, {\n          component: graphic,\n          fallback: icon_Icon,\n          className: banner_constants_cssClasses.ICON\n        })\n      }), /*#__PURE__*/(0,jsx_runtime.jsx)(Clone, {\n        component: children,\n        fallback: "div",\n        className: banner_constants_cssClasses.TEXT\n      })]\n    }), primaryAction && /*#__PURE__*/(0,jsx_runtime.jsxs)("div", {\n      className: banner_constants_cssClasses.ACTIONS,\n      children: [secondaryAction && /*#__PURE__*/(0,jsx_runtime.jsx)(Clone, {\n        component: secondaryAction,\n        className: banner_constants_cssClasses.SECONDARY_ACTION\n      }), /*#__PURE__*/(0,jsx_runtime.jsx)(Clone, {\n        component: primaryAction,\n        className: banner_constants_cssClasses.PRIMARY_ACTION\n      })]\n    })]\n  });\n\n  return /*#__PURE__*/(0,jsx_runtime.jsx)(esm_CSSTransition, {\n    "in": open,\n    appear: open,\n    timeout: {\n      appear: 0,\n      enter: numbers.BANNER_ANIMATION_OPEN_TIME_MS,\n      exit: numbers.BANNER_ANIMATION_CLOSE_TIME_MS\n    },\n    classNames: {\n      appear: banner_constants_cssClasses.APPEARING,\n      appearDone: banner_constants_cssClasses.APPEARED,\n      enter: banner_constants_cssClasses.OPENING,\n      enterActive: banner_constants_cssClasses.OPEN,\n      enterDone: banner_constants_cssClasses.OPEN,\n      exit: banner_constants_cssClasses.CLOSING\n    },\n    mountOnEnter: true,\n    unmountOnExit: true,\n    onEntering: handleEntering,\n    onExiting: handleExiting,\n    children: /*#__PURE__*/(0,jsx_runtime.jsx)(Element, Banner_objectSpread(Banner_objectSpread({\n      ref: rootRef,\n      className: classNames,\n      role: "banner"\n    }, props), {}, {\n      children: content\n    }))\n  });\n});\nBanner.displayName = \'MDCBanner\';\nBanner.propTypes = {\n  text: (prop_types_default()).node.isRequired,\n  icon: (prop_types_default()).node,\n  graphic: (prop_types_default()).element,\n  action: (prop_types_default()).element,\n  primaryAction: (prop_types_default()).element,\n  secondaryAction: (prop_types_default()).element,\n  open: (prop_types_default()).bool,\n  appear: (prop_types_default()).bool,\n  fixed: (prop_types_default()).bool,\n  centered: (prop_types_default()).bool,\n  mobileStacked: (prop_types_default()).bool\n};\n/* harmony default export */ const banner_Banner = (Banner);\n;// CONCATENATED MODULE: ./src/banner/index.js\n\n;// CONCATENATED MODULE: ./src/button/constants.js\nvar button_constants_cssClasses = {\n  ROOT: \'mdc-button\',\n  RAISED: \'mdc-button--raised\',\n  UNELEVATED: \'mdc-button--unelevated\',\n  OUTLINED: \'mdc-button--outlined\',\n  TOUCH: \'mdc-button--touch\',\n  ICON_LEADING: \'mdc-button--icon-leading\',\n  ICON_TRAILING: \'mdc-button--icon-trailing\',\n  RIPPLE: \'mdc-button__ripple\',\n  ICON: \'mdc-button__icon\',\n  LABEL: \'mdc-button__label\',\n  TOUCH_ELEMENT: \'mdc-button__touch\'\n};\n;// CONCATENATED MODULE: ./src/button/Button.jsx\nvar Button_excluded = ["label", "icon", "leadingIcon", "trailingIcon", "raised", "unelevated", "outlined", "touch", "element", "component", "className", "children"];\n\nfunction Button_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction Button_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { Button_ownKeys(Object(source), true).forEach(function (key) { Button_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { Button_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction Button_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction Button_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = Button_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction Button_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\n\n\n\n\nvar Button = /*#__PURE__*/(0,react.forwardRef)(function (_ref, ref) {\n  var _classnames;\n\n  var label = _ref.label,\n      icon = _ref.icon,\n      _ref$leadingIcon = _ref.leadingIcon,\n      leadingIcon = _ref$leadingIcon === void 0 ? icon : _ref$leadingIcon,\n      trailingIcon = _ref.trailingIcon,\n      _ref$raised = _ref.raised,\n      raised = _ref$raised === void 0 ? false : _ref$raised,\n      _ref$unelevated = _ref.unelevated,\n      unelevated = _ref$unelevated === void 0 ? false : _ref$unelevated,\n      _ref$outlined = _ref.outlined,\n      outlined = _ref$outlined === void 0 ? false : _ref$outlined,\n      _ref$touch = _ref.touch,\n      touch = _ref$touch === void 0 ? false : _ref$touch,\n      _ref$element = _ref.element,\n      element = _ref$element === void 0 ? \'button\' : _ref$element,\n      _ref$component = _ref.component,\n      Element = _ref$component === void 0 ? element : _ref$component,\n      className = _ref.className,\n      _ref$children = _ref.children,\n      children = _ref$children === void 0 ? label : _ref$children,\n      props = Button_objectWithoutProperties(_ref, Button_excluded);\n\n  var classNames = classnames_default()(button_constants_cssClasses.ROOT, (_classnames = {}, Button_defineProperty(_classnames, button_constants_cssClasses.RAISED, raised), Button_defineProperty(_classnames, button_constants_cssClasses.UNELEVATED, unelevated), Button_defineProperty(_classnames, button_constants_cssClasses.OUTLINED, outlined), Button_defineProperty(_classnames, button_constants_cssClasses.TOUCH, touch), Button_defineProperty(_classnames, button_constants_cssClasses.ICON_LEADING, Boolean(leadingIcon)), Button_defineProperty(_classnames, button_constants_cssClasses.ICON_TRAILING, Boolean(trailingIcon)), _classnames), className);\n  return /*#__PURE__*/(0,jsx_runtime.jsxs)(Element, Button_objectSpread(Button_objectSpread({\n    ref: ref,\n    className: classNames\n  }, props), {}, {\n    children: [/*#__PURE__*/(0,jsx_runtime.jsx)("span", {\n      className: button_constants_cssClasses.RIPPLE\n    }), touch && /*#__PURE__*/(0,jsx_runtime.jsx)("span", {\n      className: button_constants_cssClasses.TOUCH_ELEMENT\n    }), leadingIcon && /*#__PURE__*/(0,jsx_runtime.jsx)(Clone, {\n      component: leadingIcon,\n      fallback: icon_Icon,\n      className: button_constants_cssClasses.ICON,\n      "aria-hidden": "true"\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)("span", {\n      className: button_constants_cssClasses.LABEL,\n      children: children\n    }), trailingIcon && /*#__PURE__*/(0,jsx_runtime.jsx)(Clone, {\n      component: trailingIcon,\n      fallback: icon_Icon,\n      className: button_constants_cssClasses.ICON,\n      "aria-hidden": "true"\n    })]\n  }));\n});\nButton.displayName = \'MDCButton\';\nButton.propTypes = {\n  label: (prop_types_default()).node,\n  icon: (prop_types_default()).node,\n  leadingIcon: (prop_types_default()).node,\n  trailingIcon: (prop_types_default()).node,\n  raised: (prop_types_default()).bool,\n  unelevated: (prop_types_default()).bool,\n  outlined: (prop_types_default()).bool,\n  touch: (prop_types_default()).bool\n};\n/* harmony default export */ const button_Button = (Button);\n;// CONCATENATED MODULE: ./src/button/index.js\n\n;// CONCATENATED MODULE: ./src/card/constants.js\nvar card_constants_cssClasses = {\n  ROOT: \'mdc-card\',\n  OUTLINED: \'mdc-card--outlined\',\n  TITLE: \'mdc-card__title\',\n  SUBTITLE: \'mdc-card__subtitle\',\n  OVERLINE: \'mdc-card__overline\',\n  ACTIONS: \'mdc-card__actions\',\n  ACTIONS_FULL_BLEED: \'mdc-card__actions--full-bleed\',\n  ACTION_BUTTONS: \'mdc-card__action-buttons\',\n  ACTION_ICONS: \'mdc-card__action-icons\',\n  ACTION: \'mdc-card__action\',\n  ACTION_BUTTON: \'mdc-card__action--button\',\n  ACTION_ICON: \'mdc-card__action--icon\',\n  CONTENT: \'mdc-card__content\',\n  HEADER: \'mdc-card__header\',\n  HEADER_GRAPHIC: \'mdc-card__header__graphic\',\n  HEADER_CONTENT: \'mdc-card__header__content\',\n  HEADER_ACTIONS: \'mdc-card__header__actions\',\n  MEDIA: \'mdc-card__media\',\n  MEDIA_SQUARE: \'mdc-card__media--square\',\n  MEDIA_WIDE: \'mdc-card__media--16-9\',\n  MEDIA_CONTENT: \'mdc-card__media-content\',\n  PRIMARY_ACTION: \'mdc-card__primary-action\',\n  SECTION: \'mdc-card__section\',\n  SECTION_PRIMARY: \'mdc-card__section--primary\',\n  SECTION_SECONDARY: \'mdc-card__section--secondary\',\n  RIPPLE: \'mdc-card__ripple\'\n};\n;// CONCATENATED MODULE: ./src/card/Card.jsx\nvar Card_excluded = ["outlined", "element", "component", "className"];\n\nfunction Card_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction Card_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { Card_ownKeys(Object(source), true).forEach(function (key) { Card_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { Card_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction Card_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction Card_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = Card_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction Card_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\n\nvar Card = /*#__PURE__*/(0,react.forwardRef)(function (_ref, ref) {\n  var _ref$outlined = _ref.outlined,\n      outlined = _ref$outlined === void 0 ? false : _ref$outlined,\n      _ref$element = _ref.element,\n      element = _ref$element === void 0 ? \'div\' : _ref$element,\n      _ref$component = _ref.component,\n      Element = _ref$component === void 0 ? element : _ref$component,\n      className = _ref.className,\n      props = Card_objectWithoutProperties(_ref, Card_excluded);\n\n  var classNames = classnames_default()(card_constants_cssClasses.ROOT, Card_defineProperty({}, card_constants_cssClasses.OUTLINED, outlined), className);\n  return /*#__PURE__*/(0,jsx_runtime.jsx)(Element, Card_objectSpread({\n    ref: ref,\n    className: classNames\n  }, props));\n});\nCard.displayName = \'MDCCard\';\nCard.propTypes = {\n  outlined: (prop_types_default()).bool\n};\n/* harmony default export */ const card_Card = (Card);\n;// CONCATENATED MODULE: ./src/card/CardAction.jsx\nvar CardAction_excluded = ["button", "icon", "component", "className", "children"];\n\nfunction CardAction_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction CardAction_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { CardAction_ownKeys(Object(source), true).forEach(function (key) { CardAction_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { CardAction_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction CardAction_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction CardAction_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = CardAction_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction CardAction_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\n\nfunction CardAction(_ref) {\n  var _classnames;\n\n  var _ref$button = _ref.button,\n      button = _ref$button === void 0 ? false : _ref$button,\n      _ref$icon = _ref.icon,\n      icon = _ref$icon === void 0 ? false : _ref$icon,\n      component = _ref.component,\n      className = _ref.className,\n      _ref$children = _ref.children,\n      children = _ref$children === void 0 ? component : _ref$children,\n      props = CardAction_objectWithoutProperties(_ref, CardAction_excluded);\n\n  var classNames = classnames_default()(card_constants_cssClasses.ACTION, (_classnames = {}, CardAction_defineProperty(_classnames, card_constants_cssClasses.ACTION_BUTTON, button), CardAction_defineProperty(_classnames, card_constants_cssClasses.ACTION_ICON, icon), _classnames), className);\n  return /*#__PURE__*/(0,jsx_runtime.jsx)(Clone, CardAction_objectSpread({\n    component: children,\n    className: classNames\n  }, props));\n}\nCardAction.displayName = \'MDCCardAction\';\nCardAction.propTypes = {\n  button: (prop_types_default()).bool,\n  icon: (prop_types_default()).bool\n};\n;// CONCATENATED MODULE: ./src/card/CardActions.jsx\nvar CardActions_excluded = ["fullBleed", "element", "className"];\n\nfunction CardActions_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction CardActions_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { CardActions_ownKeys(Object(source), true).forEach(function (key) { CardActions_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { CardActions_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction CardActions_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction CardActions_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = CardActions_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction CardActions_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\n\nvar CardActions = /*#__PURE__*/(0,react.forwardRef)(function (_ref, ref) {\n  var _ref$fullBleed = _ref.fullBleed,\n      fullBleed = _ref$fullBleed === void 0 ? false : _ref$fullBleed,\n      _ref$element = _ref.element,\n      Element = _ref$element === void 0 ? \'div\' : _ref$element,\n      className = _ref.className,\n      props = CardActions_objectWithoutProperties(_ref, CardActions_excluded);\n\n  var classNames = classnames_default()(card_constants_cssClasses.ACTIONS, CardActions_defineProperty({}, card_constants_cssClasses.ACTIONS_FULL_BLEED, fullBleed), className);\n  return /*#__PURE__*/(0,jsx_runtime.jsx)(Element, CardActions_objectSpread({\n    ref: ref,\n    className: classNames\n  }, props));\n});\nCardActions.displayName = \'MDCCardActions\';\nCardActions.propTypes = {\n  fullBleed: (prop_types_default()).bool\n};\n/* harmony default export */ const card_CardActions = (CardActions);\n;// CONCATENATED MODULE: ./src/card/CardActionButtons.jsx\nvar CardActionButtons_excluded = ["element", "component", "className", "children"];\n\nfunction CardActionButtons_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction CardActionButtons_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { CardActionButtons_ownKeys(Object(source), true).forEach(function (key) { CardActionButtons_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { CardActionButtons_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction CardActionButtons_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction CardActionButtons_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = CardActionButtons_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction CardActionButtons_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\n\nvar CardActionButtons = /*#__PURE__*/(0,react.forwardRef)(function (_ref, ref) {\n  var _ref$element = _ref.element,\n      element = _ref$element === void 0 ? \'div\' : _ref$element,\n      _ref$component = _ref.component,\n      Element = _ref$component === void 0 ? element : _ref$component,\n      className = _ref.className,\n      children = _ref.children,\n      props = CardActionButtons_objectWithoutProperties(_ref, CardActionButtons_excluded);\n\n  var classNames = classnames_default()(card_constants_cssClasses.ACTION_BUTTONS, className);\n  return /*#__PURE__*/(0,jsx_runtime.jsx)(Element, CardActionButtons_objectSpread(CardActionButtons_objectSpread({\n    ref: ref,\n    className: classNames\n  }, props), {}, {\n    children: /*#__PURE__*/(0,jsx_runtime.jsx)(Clone, {\n      component: children,\n      className: "".concat(card_constants_cssClasses.ACTION, " ").concat(card_constants_cssClasses.ACTION_BUTTON)\n    })\n  }));\n});\nCardActionButtons.displayName = \'MDCCardActionButtons\';\n/* harmony default export */ const card_CardActionButtons = (CardActionButtons);\n;// CONCATENATED MODULE: ./src/card/CardActionIcons.jsx\nvar CardActionIcons_excluded = ["element", "component", "className", "children"];\n\nfunction CardActionIcons_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction CardActionIcons_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { CardActionIcons_ownKeys(Object(source), true).forEach(function (key) { CardActionIcons_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { CardActionIcons_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction CardActionIcons_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction CardActionIcons_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = CardActionIcons_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction CardActionIcons_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\n\nvar CardActionIcons = /*#__PURE__*/(0,react.forwardRef)(function (_ref, ref) {\n  var _ref$element = _ref.element,\n      element = _ref$element === void 0 ? \'div\' : _ref$element,\n      _ref$component = _ref.component,\n      Element = _ref$component === void 0 ? element : _ref$component,\n      className = _ref.className,\n      children = _ref.children,\n      props = CardActionIcons_objectWithoutProperties(_ref, CardActionIcons_excluded);\n\n  var classNames = classnames_default()(card_constants_cssClasses.ACTION_ICONS, className);\n  return /*#__PURE__*/(0,jsx_runtime.jsx)(Element, CardActionIcons_objectSpread(CardActionIcons_objectSpread({\n    ref: ref,\n    className: classNames\n  }, props), {}, {\n    children: /*#__PURE__*/(0,jsx_runtime.jsx)(Clone, {\n      component: children,\n      className: "".concat(card_constants_cssClasses.ACTION, " ").concat(card_constants_cssClasses.ACTION_ICON)\n    })\n  }));\n});\nCardActionIcons.displayName = \'MDCCardActionIcons\';\n/* harmony default export */ const card_CardActionIcons = (CardActionIcons);\n;// CONCATENATED MODULE: ./src/card/CardHeader.jsx\nvar CardHeader_excluded = ["title", "subtitle", "overline", "graphic", "actions", "element", "component", "className", "children"];\n\nfunction CardHeader_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction CardHeader_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { CardHeader_ownKeys(Object(source), true).forEach(function (key) { CardHeader_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { CardHeader_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction CardHeader_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction CardHeader_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = CardHeader_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction CardHeader_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\n\n\n\nvar CardHeader = /*#__PURE__*/(0,react.forwardRef)(function (_ref, ref) {\n  var title = _ref.title,\n      subtitle = _ref.subtitle,\n      overline = _ref.overline,\n      graphic = _ref.graphic,\n      actions = _ref.actions,\n      _ref$element = _ref.element,\n      element = _ref$element === void 0 ? \'div\' : _ref$element,\n      _ref$component = _ref.component,\n      Element = _ref$component === void 0 ? element : _ref$component,\n      className = _ref.className,\n      children = _ref.children,\n      props = CardHeader_objectWithoutProperties(_ref, CardHeader_excluded);\n\n  var classNames = classnames_default()(card_constants_cssClasses.HEADER, className);\n  return /*#__PURE__*/(0,jsx_runtime.jsxs)(Element, CardHeader_objectSpread(CardHeader_objectSpread({\n    ref: ref,\n    className: classNames\n  }, props), {}, {\n    children: [graphic && /*#__PURE__*/(0,jsx_runtime.jsx)(Clone, {\n      component: graphic,\n      className: card_constants_cssClasses.HEADER_GRAPHIC\n    }), /*#__PURE__*/(0,jsx_runtime.jsxs)("div", {\n      className: card_constants_cssClasses.HEADER_CONTENT,\n      children: [overline && /*#__PURE__*/(0,jsx_runtime.jsx)(Clone, {\n        component: overline,\n        fallback: "span",\n        className: card_constants_cssClasses.OVERLINE\n      }), title && /*#__PURE__*/(0,jsx_runtime.jsx)(Clone, {\n        component: title,\n        fallback: "h2",\n        className: card_constants_cssClasses.TITLE\n      }), subtitle && /*#__PURE__*/(0,jsx_runtime.jsx)(Clone, {\n        component: subtitle,\n        fallback: "h3",\n        className: card_constants_cssClasses.SUBTITLE\n      }), children]\n    }), actions && /*#__PURE__*/(0,jsx_runtime.jsx)("div", {\n      className: card_constants_cssClasses.HEADER_ACTIONS,\n      children: react.Children.map(actions, function (action) {\n        return /*#__PURE__*/(0,jsx_runtime.jsx)(Clone, {\n          component: action,\n          className: card_constants_cssClasses.ACTION\n        });\n      })\n    })]\n  }));\n});\nCardHeader.displayName = \'MDCCardHeader\';\nCardHeader.propTypes = {\n  title: (prop_types_default()).node,\n  subtitle: (prop_types_default()).node,\n  overline: (prop_types_default()).node,\n  graphic: (prop_types_default()).element,\n  actions: prop_types_default().oneOfType([(prop_types_default()).element, prop_types_default().arrayOf((prop_types_default()).element)])\n};\n/* harmony default export */ const card_CardHeader = (CardHeader);\n;// CONCATENATED MODULE: ./src/card/CardMedia.jsx\nvar CardMedia_excluded = ["imageUrl", "content", "square", "wide", "element", "component", "className", "children"];\n\nfunction CardMedia_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction CardMedia_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { CardMedia_ownKeys(Object(source), true).forEach(function (key) { CardMedia_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { CardMedia_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction CardMedia_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction CardMedia_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = CardMedia_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction CardMedia_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\n\nvar CardMedia = /*#__PURE__*/(0,react.forwardRef)(function (_ref, ref) {\n  var _classnames;\n\n  var imageUrl = _ref.imageUrl,\n      content = _ref.content,\n      _ref$square = _ref.square,\n      square = _ref$square === void 0 ? false : _ref$square,\n      _ref$wide = _ref.wide,\n      wide = _ref$wide === void 0 ? false : _ref$wide,\n      _ref$element = _ref.element,\n      element = _ref$element === void 0 ? \'div\' : _ref$element,\n      _ref$component = _ref.component,\n      Element = _ref$component === void 0 ? element : _ref$component,\n      className = _ref.className,\n      _ref$children = _ref.children,\n      children = _ref$children === void 0 ? content : _ref$children,\n      props = CardMedia_objectWithoutProperties(_ref, CardMedia_excluded);\n\n  var classNames = classnames_default()(card_constants_cssClasses.MEDIA, (_classnames = {}, CardMedia_defineProperty(_classnames, card_constants_cssClasses.MEDIA_SQUARE, square), CardMedia_defineProperty(_classnames, card_constants_cssClasses.MEDIA_WIDE, wide), _classnames), className);\n  var style = imageUrl ? {\n    backgroundImage: "url(".concat(imageUrl, ")")\n  } : undefined;\n  return /*#__PURE__*/(0,jsx_runtime.jsx)(Element, CardMedia_objectSpread(CardMedia_objectSpread({\n    ref: ref,\n    className: classNames,\n    style: style\n  }, props), {}, {\n    children: children && /*#__PURE__*/(0,jsx_runtime.jsx)("div", {\n      className: card_constants_cssClasses.MEDIA_CONTENT,\n      children: children\n    })\n  }));\n});\nCardMedia.displayName = \'MDCCardMedia\';\nCardMedia.propTypes = {\n  imageUrl: (prop_types_default()).string,\n  content: (prop_types_default()).node,\n  square: (prop_types_default()).bool,\n  wide: (prop_types_default()).bool\n};\n/* harmony default export */ const card_CardMedia = (CardMedia);\n;// CONCATENATED MODULE: ./src/card/CardPrimaryAction.jsx\nvar CardPrimaryAction_excluded = ["element", "component", "className", "children"];\n\nfunction CardPrimaryAction_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction CardPrimaryAction_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { CardPrimaryAction_ownKeys(Object(source), true).forEach(function (key) { CardPrimaryAction_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { CardPrimaryAction_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction CardPrimaryAction_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction CardPrimaryAction_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = CardPrimaryAction_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction CardPrimaryAction_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\n\nvar CardPrimaryAction = /*#__PURE__*/(0,react.forwardRef)(function (_ref, ref) {\n  var _ref$element = _ref.element,\n      element = _ref$element === void 0 ? \'div\' : _ref$element,\n      _ref$component = _ref.component,\n      Element = _ref$component === void 0 ? element : _ref$component,\n      className = _ref.className,\n      children = _ref.children,\n      props = CardPrimaryAction_objectWithoutProperties(_ref, CardPrimaryAction_excluded);\n\n  var classNames = classnames_default()(card_constants_cssClasses.PRIMARY_ACTION, className);\n  return /*#__PURE__*/(0,jsx_runtime.jsxs)(Element, CardPrimaryAction_objectSpread(CardPrimaryAction_objectSpread({\n    ref: ref,\n    className: classNames,\n    tabIndex: "0"\n  }, props), {}, {\n    children: [children, /*#__PURE__*/(0,jsx_runtime.jsx)("div", {\n      className: card_constants_cssClasses.RIPPLE\n    })]\n  }));\n});\nCardPrimaryAction.displayName = \'MDCCardPrimaryAction\';\n/* harmony default export */ const card_CardPrimaryAction = (CardPrimaryAction);\n;// CONCATENATED MODULE: ./src/card/CardSection.jsx\nvar CardSection_excluded = ["primary", "secondary", "element", "component", "className"];\n\nfunction CardSection_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction CardSection_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { CardSection_ownKeys(Object(source), true).forEach(function (key) { CardSection_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { CardSection_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction CardSection_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction CardSection_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = CardSection_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction CardSection_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\n\nvar CardSection = /*#__PURE__*/(0,react.forwardRef)(function (_ref, ref) {\n  var _classnames;\n\n  var _ref$primary = _ref.primary,\n      primary = _ref$primary === void 0 ? false : _ref$primary,\n      _ref$secondary = _ref.secondary,\n      secondary = _ref$secondary === void 0 ? false : _ref$secondary,\n      _ref$element = _ref.element,\n      element = _ref$element === void 0 ? \'div\' : _ref$element,\n      _ref$component = _ref.component,\n      Element = _ref$component === void 0 ? element : _ref$component,\n      className = _ref.className,\n      props = CardSection_objectWithoutProperties(_ref, CardSection_excluded);\n\n  var classNames = classnames_default()(card_constants_cssClasses.SECTION, (_classnames = {}, CardSection_defineProperty(_classnames, card_constants_cssClasses.SECTION_PRIMARY, primary), CardSection_defineProperty(_classnames, card_constants_cssClasses.SECTION_SECONDARY, secondary), _classnames), className);\n  return /*#__PURE__*/(0,jsx_runtime.jsx)(Element, CardSection_objectSpread({\n    ref: ref,\n    className: classNames\n  }, props));\n});\nCardSection.displayName = \'MDCCardSection\';\nCardSection.propTypes = {\n  primary: (prop_types_default()).bool,\n  secondary: (prop_types_default()).bool\n};\n/* harmony default export */ const card_CardSection = (CardSection);\n;// CONCATENATED MODULE: ./src/card/index.js\n\n\n\n\n\n\n\n\n\ncard_Card.Action = CardAction;\ncard_Card.Actions = card_CardActions;\ncard_Card.ActionButtons = card_CardActionButtons;\ncard_Card.ActionIcons = card_CardActionIcons;\ncard_Card.Header = card_CardHeader;\ncard_Card.Media = card_CardMedia;\ncard_Card.PrimaryAction = card_CardPrimaryAction;\ncard_Card.Section = card_CardSection;\n\n;// CONCATENATED MODULE: ./src/checkbox/constants.js\nvar checkbox_constants_cssClasses = {\n  ROOT: \'mdc-checkbox\',\n  SELECTED: \'mdc-checkbox--selected\',\n  TOUCH: \'mdc-checkbox--touch\',\n  DISABLED: \'mdc-checkbox--disabled\',\n  ANIM_CHECKED_INDETERMINATE: \'mdc-checkbox--anim-checked-indeterminate\',\n  ANIM_CHECKED_UNCHECKED: \'mdc-checkbox--anim-checked-unchecked\',\n  ANIM_INDETERMINATE_CHECKED: \'mdc-checkbox--anim-indeterminate-checked\',\n  ANIM_INDETERMINATE_UNCHECKED: \'mdc-checkbox--anim-indeterminate-unchecked\',\n  ANIM_UNCHECKED_CHECKED: \'mdc-checkbox--anim-unchecked-checked\',\n  ANIM_UNCHECKED_INDETERMINATE: \'mdc-checkbox--anim-unchecked-indeterminate\',\n  NATIVE_CONTROL: \'mdc-checkbox__native-control\',\n  BACKGROUND: \'mdc-checkbox__background\',\n  CHECKMARK: \'mdc-checkbox__checkmark\',\n  CHECKMARK_PATH: \'mdc-checkbox__checkmark-path\',\n  MIXEDMARK: \'mdc-checkbox__mixedmark\',\n  RIPPLE: \'mdc-checkbox__ripple\'\n};\n;// CONCATENATED MODULE: ./src/checkbox/Checkbox.jsx\nvar Checkbox_excluded = ["checked", "indeterminate", "disabled", "touch", "onChange", "className"];\n\nfunction Checkbox_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction Checkbox_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { Checkbox_ownKeys(Object(source), true).forEach(function (key) { Checkbox_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { Checkbox_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction Checkbox_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction Checkbox_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = Checkbox_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction Checkbox_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\n\n\nvar Checkbox = /*#__PURE__*/(0,react.forwardRef)(function (_ref, ref) {\n  var _classnames;\n\n  var checked = _ref.checked,\n      indeterminate = _ref.indeterminate,\n      _ref$disabled = _ref.disabled,\n      disabled = _ref$disabled === void 0 ? false : _ref$disabled,\n      _ref$touch = _ref.touch,\n      touch = _ref$touch === void 0 ? false : _ref$touch,\n      _ref$onChange = _ref.onChange,\n      onChange = _ref$onChange === void 0 ? Function.prototype : _ref$onChange,\n      className = _ref.className,\n      props = Checkbox_objectWithoutProperties(_ref, Checkbox_excluded);\n\n  var inputRef = (0,react.useRef)();\n  (0,react.useEffect)(function () {\n    inputRef.current.indeterminate = indeterminate;\n  }, [indeterminate]);\n  var handleChange = (0,react.useCallback)(function (event) {\n    onChange(event, event.target.checked, event.target);\n  }, [onChange]);\n  var classNames = classnames_default()(checkbox_constants_cssClasses.ROOT, (_classnames = {}, Checkbox_defineProperty(_classnames, checkbox_constants_cssClasses.SELECTED, checked), Checkbox_defineProperty(_classnames, checkbox_constants_cssClasses.DISABLED, disabled), Checkbox_defineProperty(_classnames, checkbox_constants_cssClasses.TOUCH, touch), _classnames), className);\n  return /*#__PURE__*/(0,jsx_runtime.jsxs)("div", {\n    ref: ref,\n    className: classNames,\n    children: [/*#__PURE__*/(0,jsx_runtime.jsx)("input", Checkbox_objectSpread({\n      ref: inputRef,\n      className: checkbox_constants_cssClasses.NATIVE_CONTROL,\n      type: "checkbox",\n      checked: checked,\n      disabled: disabled,\n      onChange: handleChange\n    }, props)), /*#__PURE__*/(0,jsx_runtime.jsxs)("div", {\n      className: checkbox_constants_cssClasses.BACKGROUND,\n      children: [/*#__PURE__*/(0,jsx_runtime.jsx)("svg", {\n        className: checkbox_constants_cssClasses.CHECKMARK,\n        viewBox: "0 0 24 24",\n        children: /*#__PURE__*/(0,jsx_runtime.jsx)("path", {\n          className: checkbox_constants_cssClasses.CHECKMARK_PATH,\n          fill: "none",\n          d: "M1.73,12.91 8.1,19.28 22.79,4.59"\n        })\n      }), /*#__PURE__*/(0,jsx_runtime.jsx)("div", {\n        className: checkbox_constants_cssClasses.MIXEDMARK\n      })]\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)("div", {\n      className: checkbox_constants_cssClasses.RIPPLE\n    })]\n  });\n});\nCheckbox.displayName = \'MDCCheckbox\';\nCheckbox.propTypes = {\n  checked: (prop_types_default()).bool,\n  indeterminate: (prop_types_default()).bool,\n  disabled: (prop_types_default()).bool,\n  touch: (prop_types_default()).bool,\n  onChange: (prop_types_default()).func\n};\n/* harmony default export */ const checkbox_Checkbox = (Checkbox);\n;// CONCATENATED MODULE: ./src/checkbox/index.js\n\n;// CONCATENATED MODULE: ./src/chips/constants.js\nvar constants_numbers = {\n  SELECTING_ANIMATION_MS: 150,\n  DESELECTING_ANIMATION_MS: 100\n};\nvar chipSetCssClasses = {\n  ROOT: \'mdc-evolution-chip-set\',\n  OVERFLOW: \'mdc-evolution-chip-set--overflow\',\n  CHIPS: \'mdc-evolution-chip-set__chips\'\n};\nvar chipCssClasses = {\n  ROOT: \'mdc-evolution-chip\',\n  FILTER: \'mdc-evolution-chip--filter\',\n  SELECTABLE: \'mdc-evolution-chip--selectable\',\n  SELECTED: \'mdc-evolution-chip--selected\',\n  SELECTING: \'mdc-evolution-chip--selecting\',\n  SELECTING_WITH_PRIMARY_ICON: \'mdc-evolution-chip--selecting-with-primary-icon\',\n  DESELECTING: \'mdc-evolution-chip--deselecting\',\n  DESELECTING_WITH_PRIMARY_ICON: \'mdc-evolution-chip--deselecting-with-primary-icon\',\n  OUTLINED: \'mdc-evolution-chip--outlined\',\n  ENTER: \'mdc-evolution-chip--enter\',\n  EXIT: \'mdc-evolution-chip--exit\',\n  HIDDEN: \'mdc-evolution-chip--hidden\',\n  DISABLED: \'mdc-evolution-chip--disabled\',\n  TOUCH: \'mdc-evolution-chip--touch\',\n  WITH_PRIMARY_GRAPHIC: \'mdc-evolution-chip--with-primary-graphic\',\n  WITH_PRIMARY_ICON: \'mdc-evolution-chip--with-primary-icon\',\n  WITH_TRAILING_ACTION: \'mdc-evolution-chip--with-trailing-action\',\n  WITH_AVATAR: \'mdc-evolution-chip--with-avatar\',\n  CELL: \'mdc-evolution-chip__cell\',\n  PRIMARY_CELL: \'mdc-evolution-chip__cell--primary\',\n  TRAILING_CELL: \'mdc-evolution-chip__cell--trailing\',\n  ACTION: \'mdc-evolution-chip__action\',\n  PRIMARY_ACTION: \'mdc-evolution-chip__action--primary\',\n  TRAILING_ACTION: \'mdc-evolution-chip__action--trailing\',\n  PRESENTATIONAL_ACTION: \'mdc-evolution-chip__action--presentational\',\n  ACTION_TOUCH: \'mdc-evolution-chip__action-touch\',\n  RIPPLE: \'mdc-evolution-chip__ripple\',\n  PRIMARY_RIPPLE: \'mdc-evolution-chip__ripple--primary\',\n  TRAILING_RIPPLE: \'mdc-evolution-chip__ripple--trailing\',\n  GRAPHIC: \'mdc-evolution-chip__graphic\',\n  ICON: \'mdc-evolution-chip__icon\',\n  PRIMARY_ICON: \'mdc-evolution-chip__icon--primary\',\n  TRAILING_ICON: \'mdc-evolution-chip__icon--trailing\',\n  TEXT_LABEL: \'mdc-evolution-chip__text-label\',\n  CHECKMARK: \'mdc-evolution-chip__checkmark\',\n  CHECKMARK_SVG: \'mdc-evolution-chip__checkmark-svg\',\n  CHECKMARK_PATH: \'mdc-evolution-chip__checkmark-path\'\n};\n;// CONCATENATED MODULE: ./src/chips/ChipPrimaryAction.jsx\nvar ChipPrimaryAction_excluded = ["text", "graphic", "icon", "presentational", "selectable", "selected", "disabled", "element", "component", "children"];\n\nfunction ChipPrimaryAction_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction ChipPrimaryAction_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ChipPrimaryAction_ownKeys(Object(source), true).forEach(function (key) { ChipPrimaryAction_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ChipPrimaryAction_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction ChipPrimaryAction_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction ChipPrimaryAction_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = ChipPrimaryAction_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction ChipPrimaryAction_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\n\n\nfunction ChipPrimaryAction(_ref) {\n  var text = _ref.text,\n      graphic = _ref.graphic,\n      icon = _ref.icon,\n      _ref$presentational = _ref.presentational,\n      presentational = _ref$presentational === void 0 ? false : _ref$presentational,\n      _ref$selectable = _ref.selectable,\n      selectable = _ref$selectable === void 0 ? false : _ref$selectable,\n      _ref$selected = _ref.selected,\n      selected = _ref$selected === void 0 ? false : _ref$selected,\n      _ref$disabled = _ref.disabled,\n      disabled = _ref$disabled === void 0 ? false : _ref$disabled,\n      _ref$element = _ref.element,\n      element = _ref$element === void 0 ? \'button\' : _ref$element,\n      _ref$component = _ref.component,\n      Element = _ref$component === void 0 ? element : _ref$component,\n      _ref$children = _ref.children,\n      children = _ref$children === void 0 ? text : _ref$children,\n      props = ChipPrimaryAction_objectWithoutProperties(_ref, ChipPrimaryAction_excluded);\n\n  var isButton = Element === \'button\';\n  var classNames = classnames_default()(chipCssClasses.ACTION, chipCssClasses.PRIMARY_ACTION, ChipPrimaryAction_defineProperty({}, chipCssClasses.PRESENTATIONAL_ACTION, presentational));\n  return /*#__PURE__*/(0,jsx_runtime.jsxs)(Element, ChipPrimaryAction_objectSpread(ChipPrimaryAction_objectSpread({\n    className: classNames,\n    type: isButton ? \'button\' : undefined,\n    disabled: isButton && disabled,\n    tabIndex: disabled ? \'-1\' : \'0\',\n    role: !isButton ? \'option\' : undefined,\n    "aria-selected": !isButton ? selected : undefined,\n    "aria-disabled": !isButton ? disabled : undefined\n  }, props), {}, {\n    children: [/*#__PURE__*/(0,jsx_runtime.jsx)("span", {\n      className: "".concat(chipCssClasses.RIPPLE, " ").concat(chipCssClasses.PRIMARY_RIPPLE)\n    }), (graphic || icon || selectable) && /*#__PURE__*/(0,jsx_runtime.jsxs)("span", {\n      className: chipCssClasses.GRAPHIC,\n      children: [graphic, icon && /*#__PURE__*/(0,jsx_runtime.jsx)(Clone, {\n        component: icon,\n        fallback: icon_Icon,\n        className: "".concat(chipCssClasses.ICON, " ").concat(chipCssClasses.PRIMARY_ICON)\n      }), selectable && /*#__PURE__*/(0,jsx_runtime.jsx)("span", {\n        className: chipCssClasses.CHECKMARK,\n        children: /*#__PURE__*/(0,jsx_runtime.jsx)("svg", {\n          className: chipCssClasses.CHECKMARK_SVG,\n          viewBox: "-2 -3 30 30",\n          children: /*#__PURE__*/(0,jsx_runtime.jsx)("path", {\n            className: chipCssClasses.CHECKMARK_PATH,\n            fill: "none",\n            stroke: "black",\n            d: "M1.73,12.91 8.1,19.28 22.79,4.59"\n          })\n        })\n      })]\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)("span", {\n      className: chipCssClasses.TEXT_LABEL,\n      children: children\n    })]\n  }));\n}\n;// CONCATENATED MODULE: ./src/chips/ChipTrailingAction.jsx\nvar ChipTrailingAction_excluded = ["icon", "presentational"];\n\nfunction ChipTrailingAction_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction ChipTrailingAction_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ChipTrailingAction_ownKeys(Object(source), true).forEach(function (key) { ChipTrailingAction_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ChipTrailingAction_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction ChipTrailingAction_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction ChipTrailingAction_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = ChipTrailingAction_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction ChipTrailingAction_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\n\n\nfunction ChipTrailingAction(_ref) {\n  var icon = _ref.icon,\n      _ref$presentational = _ref.presentational,\n      presentational = _ref$presentational === void 0 ? false : _ref$presentational,\n      props = ChipTrailingAction_objectWithoutProperties(_ref, ChipTrailingAction_excluded);\n\n  var classNames = classnames_default()(chipCssClasses.ACTION, chipCssClasses.TRAILING_ACTION, ChipTrailingAction_defineProperty({}, chipCssClasses.PRESENTATIONAL_ACTION, presentational));\n  return /*#__PURE__*/(0,jsx_runtime.jsxs)("button", ChipTrailingAction_objectSpread(ChipTrailingAction_objectSpread({\n    className: classNames,\n    type: "button",\n    tabIndex: "-1",\n    "aria-hidden": "true"\n  }, props), {}, {\n    children: [/*#__PURE__*/(0,jsx_runtime.jsx)("span", {\n      className: "".concat(chipCssClasses.RIPPLE, " ").concat(chipCssClasses.TRAILING_RIPPLE)\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Clone, {\n      component: icon,\n      fallback: icon_Icon,\n      className: "".concat(chipCssClasses.ICON, " ").concat(chipCssClasses.TRAILING_ICON)\n    })]\n  }));\n}\n;// CONCATENATED MODULE: ./src/chips/Chip.jsx\nvar Chip_excluded = ["value", "text", "graphic", "icon", "primaryIcon", "trailingIcon", "selectable", "filter", "selected", "outlined", "disabled", "touch", "withAvatar", "element", "component", "className"];\n\nfunction Chip_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction Chip_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { Chip_ownKeys(Object(source), true).forEach(function (key) { Chip_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { Chip_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction Chip_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction Chip_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = Chip_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction Chip_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\n\n\n\n\n\n\nvar Chip = /*#__PURE__*/(0,react.forwardRef)(function (_ref, ref) {\n  var _classnames;\n\n  var value = _ref.value,\n      text = _ref.text,\n      graphic = _ref.graphic,\n      icon = _ref.icon,\n      _ref$primaryIcon = _ref.primaryIcon,\n      primaryIcon = _ref$primaryIcon === void 0 ? icon : _ref$primaryIcon,\n      trailingIcon = _ref.trailingIcon,\n      _ref$selectable = _ref.selectable,\n      selectable = _ref$selectable === void 0 ? false : _ref$selectable,\n      _ref$filter = _ref.filter,\n      filter = _ref$filter === void 0 ? false : _ref$filter,\n      _ref$selected = _ref.selected,\n      selected = _ref$selected === void 0 ? false : _ref$selected,\n      _ref$outlined = _ref.outlined,\n      outlined = _ref$outlined === void 0 ? false : _ref$outlined,\n      _ref$disabled = _ref.disabled,\n      disabled = _ref$disabled === void 0 ? false : _ref$disabled,\n      _ref$touch = _ref.touch,\n      touch = _ref$touch === void 0 ? false : _ref$touch,\n      _ref$withAvatar = _ref.withAvatar,\n      withAvatar = _ref$withAvatar === void 0 ? false : _ref$withAvatar,\n      _ref$element = _ref.element,\n      element = _ref$element === void 0 ? \'span\' : _ref$element,\n      _ref$component = _ref.component,\n      Element = _ref$component === void 0 ? element : _ref$component,\n      className = _ref.className,\n      props = Chip_objectWithoutProperties(_ref, Chip_excluded);\n\n  var withPrimaryGraphic = selectable || Boolean(graphic) || Boolean(primaryIcon);\n  var withPrimaryIcon = Boolean(primaryIcon);\n  var withTrailingAction = Boolean(trailingIcon);\n  var classNames = classnames_default()(chipCssClasses.ROOT, (_classnames = {}, Chip_defineProperty(_classnames, chipCssClasses.SELECTABLE, selectable), Chip_defineProperty(_classnames, chipCssClasses.FILTER, filter), Chip_defineProperty(_classnames, chipCssClasses.OUTLINED, outlined), Chip_defineProperty(_classnames, chipCssClasses.DISABLED, disabled), Chip_defineProperty(_classnames, chipCssClasses.TOUCH, touch), Chip_defineProperty(_classnames, chipCssClasses.WITH_PRIMARY_GRAPHIC, withPrimaryGraphic), Chip_defineProperty(_classnames, chipCssClasses.WITH_PRIMARY_ICON, withPrimaryIcon), Chip_defineProperty(_classnames, chipCssClasses.WITH_TRAILING_ACTION, withTrailingAction), Chip_defineProperty(_classnames, chipCssClasses.WITH_AVATAR, withAvatar), _classnames), className);\n  var selectingClass = withPrimaryIcon ? chipCssClasses.SELECTING_WITH_PRIMARY_ICON : chipCssClasses.SELECTING;\n  var deselectingClass = withPrimaryIcon ? chipCssClasses.DESELECTING_WITH_PRIMARY_ICON : chipCssClasses.DESELECTING;\n  return /*#__PURE__*/(0,jsx_runtime.jsx)(esm_CSSTransition, {\n    "in": selected,\n    appear: true,\n    timeout: {\n      enter: constants_numbers.SELECTING_ANIMATION_MS,\n      exit: constants_numbers.DESELECTING_ANIMATION_MS\n    },\n    classNames: {\n      enter: selectingClass,\n      enterActive: "".concat(chipCssClasses.SELECTED, " ").concat(selectingClass),\n      enterDone: chipCssClasses.SELECTED,\n      exit: deselectingClass,\n      exitActive: deselectingClass\n    },\n    children: /*#__PURE__*/(0,jsx_runtime.jsx)(Element, Chip_objectSpread(Chip_objectSpread({\n      ref: ref,\n      className: classNames,\n      "data-value": value,\n      role: selectable ? \'presentation\' : \'row\'\n    }, props), {}, {\n      children: selectable ? /*#__PURE__*/(0,jsx_runtime.jsx)(ChipPrimaryAction, {\n        element: "span",\n        text: text,\n        graphic: graphic,\n        icon: primaryIcon,\n        selectable: selectable,\n        selected: selected,\n        disabled: disabled\n      }) : /*#__PURE__*/(0,jsx_runtime.jsxs)(jsx_runtime.Fragment, {\n        children: [/*#__PURE__*/(0,jsx_runtime.jsx)("span", {\n          className: "".concat(chipCssClasses.CELL, " ").concat(chipCssClasses.PRIMARY_CELL),\n          role: "gridcell",\n          children: /*#__PURE__*/(0,jsx_runtime.jsx)(ChipPrimaryAction, {\n            text: text,\n            graphic: graphic,\n            icon: primaryIcon,\n            disabled: disabled\n          })\n        }), trailingIcon && /*#__PURE__*/(0,jsx_runtime.jsx)("span", {\n          className: "".concat(chipCssClasses.CELL, " ").concat(chipCssClasses.TRAILING_CELL),\n          role: "gridcell",\n          children: /*#__PURE__*/(0,jsx_runtime.jsx)(ChipTrailingAction, {\n            icon: trailingIcon,\n            disabled: disabled\n          })\n        })]\n      })\n    }))\n  });\n});\nChip.displayName = \'MDCChip\';\nChip.propTypes = {\n  value: (prop_types_default()).any,\n  text: (prop_types_default()).node,\n  leadingIcon: (prop_types_default()).node,\n  trailingIcon: (prop_types_default()).node,\n  selected: (prop_types_default()).bool,\n  outlined: (prop_types_default()).bool,\n  onClick: (prop_types_default()).func\n};\n/* harmony default export */ const chips_Chip = (Chip);\n;// CONCATENATED MODULE: ./src/types.js\nfunction _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }\n\nfunction isUndefined(value) {\n  return value === undefined;\n}\nfunction isNull(value) {\n  return value === null;\n}\nfunction isBoolean(value) {\n  return typeof value === \'boolean\';\n}\nfunction isNumber(value) {\n  return typeof value === \'number\';\n}\nfunction isString(value) {\n  return typeof value === \'string\';\n}\nfunction isArray(value) {\n  return Array.isArray(value);\n}\nfunction isObject(value) {\n  return _typeof(value) === \'object\' && !isNull(value) && !isArray(value);\n}\n;// CONCATENATED MODULE: ./src/chips/ChipSet.jsx\nvar ChipSet_excluded = ["value", "chips", "input", "choice", "filter", "overflow", "onChange", "element", "component", "className", "children"];\n\nfunction ChipSet_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction ChipSet_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ChipSet_ownKeys(Object(source), true).forEach(function (key) { ChipSet_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ChipSet_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction ChipSet_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction ChipSet_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = ChipSet_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction ChipSet_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\n\n\n\n\nvar ChipSet = /*#__PURE__*/(0,react.forwardRef)(function (_ref, ref) {\n  var value = _ref.value,\n      chips = _ref.chips,\n      _ref$input = _ref.input,\n      input = _ref$input === void 0 ? false : _ref$input,\n      _ref$choice = _ref.choice,\n      choice = _ref$choice === void 0 ? !input && !isUndefined(value) && !isArray(value) : _ref$choice,\n      _ref$filter = _ref.filter,\n      filter = _ref$filter === void 0 ? !input && !isUndefined(value) && isArray(value) : _ref$filter,\n      _ref$overflow = _ref.overflow,\n      overflow = _ref$overflow === void 0 ? false : _ref$overflow,\n      _ref$onChange = _ref.onChange,\n      onChange = _ref$onChange === void 0 ? Function.prototype : _ref$onChange,\n      _ref$element = _ref.element,\n      element = _ref$element === void 0 ? \'div\' : _ref$element,\n      _ref$component = _ref.component,\n      Element = _ref$component === void 0 ? element : _ref$component,\n      className = _ref.className,\n      _ref$children = _ref.children,\n      children = _ref$children === void 0 ? chips === null || chips === void 0 ? void 0 : chips.map(function (chip) {\n    return (0,react.createElement)(chips_Chip, chip);\n  }) : _ref$children,\n      props = ChipSet_objectWithoutProperties(_ref, ChipSet_excluded);\n\n  var handleClick = (0,react.useCallback)(function (event) {\n    var chipValue = event.currentTarget.dataset.value;\n    var newValue = choice ? chipValue : value.includes(chipValue) ? value.filter(function (v) {\n      return v !== chipValue;\n    }) : value.concat(chipValue);\n    onChange(newValue);\n  }, [value, choice, onChange]);\n  var classNames = classnames_default()(chipSetCssClasses.ROOT, ChipSet_defineProperty({}, chipSetCssClasses.OVERFLOW, overflow), className);\n  return /*#__PURE__*/(0,jsx_runtime.jsx)(Element, ChipSet_objectSpread(ChipSet_objectSpread({\n    ref: ref,\n    className: classNames,\n    role: filter ? \'listbox\' : \'grid\'\n  }, props), {}, {\n    children: /*#__PURE__*/(0,jsx_runtime.jsx)("div", {\n      className: chipSetCssClasses.CHIPS,\n      role: "presentation",\n      children: isUndefined(value) ? children : react.Children.map(children, function (chip) {\n        var chipValue = chip.props.value;\n        return (0,react.cloneElement)(chip, {\n          selectable: true,\n          selected: choice ? value === chipValue : value.includes(chipValue),\n          onClickCapture: choice || filter ? handleClick : undefined\n        });\n      })\n    })\n  }));\n});\nChipSet.displayName = \'MDCChipSet\';\nChipSet.propTypes = {\n  value: (prop_types_default()).any,\n  input: (prop_types_default()).bool,\n  choice: (prop_types_default()).bool,\n  filter: (prop_types_default()).bool,\n  overflow: (prop_types_default()).bool,\n  onChange: (prop_types_default()).func\n};\n/* harmony default export */ const chips_ChipSet = (ChipSet);\n;// CONCATENATED MODULE: ./src/chips/index.js\n\n\n;// CONCATENATED MODULE: ./src/circular-progress/constants.js\nvar strings = {\n  XMLNS: \'http://www.w3.org/2000/svg\'\n};\nvar sizeProps = {\n  large: {\n    viewBox: 48,\n    radius: 18,\n    strokeWidth: 4,\n    gapPatchStrokeWidth: 3.2,\n    strokeDasharray: 113.097,\n    indeterminateStrokeDashoffset: 56.549\n  },\n  medium: {\n    viewBox: 32,\n    radius: 12.5,\n    strokeWidth: 3,\n    gapPatchStrokeWidth: 2.4,\n    strokeDasharray: 78.54,\n    indeterminateStrokeDashoffset: 39.27\n  },\n  small: {\n    viewBox: 24,\n    radius: 8.75,\n    strokeWidth: 2.5,\n    gapPatchStrokeWidth: 2,\n    strokeDasharray: 54.978,\n    indeterminateStrokeDashoffset: 27.489\n  }\n};\nvar circular_progress_constants_cssClasses = {\n  ROOT: \'mdc-circular-progress\',\n  SMALL: \'mdc-circular-progress--small\',\n  MEDIUM: \'mdc-circular-progress--medium\',\n  LARGE: \'mdc-circular-progress--large\',\n  INDETERMINATE: \'mdc-circular-progress--indeterminate\',\n  CLOSED: \'mdc-circular-progress--closed\',\n  DETERMINATE_CONTAINER: \'mdc-circular-progress__determinate-container\',\n  DETERMINATE_CIRCLE_GRAPHIC: \'mdc-circular-progress__determinate-circle-graphic\',\n  DETERMINATE_TRACK: \'mdc-circular-progress__determinate-track\',\n  DETERMINATE_CIRCLE: \'mdc-circular-progress__determinate-circle\',\n  INDETERMINATE_CONTAINER: \'mdc-circular-progress__indeterminate-container\',\n  INDETERMINATE_CIRCLE_GRAPHIC: \'mdc-circular-progress__indeterminate-circle-graphic\',\n  SPINNER_LAYER: \'mdc-circular-progress__spinner-layer\',\n  COLOR: \'mdc-circular-progress__color\',\n  CIRCLE_CLIPPER: \'mdc-circular-progress__circle-clipper\',\n  CIRCLE_LEFT: \'mdc-circular-progress__circle-left\',\n  CIRCLE_RIGHT: \'mdc-circular-progress__circle-right\',\n  GAP_PATCH: \'mdc-circular-progress__gap-patch\'\n};\nvar Size = {\n  LARGE: \'large\',\n  MEDIUM: \'medium\',\n  SMALL: \'small\'\n};\n;// CONCATENATED MODULE: ./src/circular-progress/CircularProgress.jsx\nvar CircularProgress_excluded = ["value", "size", "indeterminate", "closed", "colorful", "className"];\n\nfunction CircularProgress_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction CircularProgress_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { CircularProgress_ownKeys(Object(source), true).forEach(function (key) { CircularProgress_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { CircularProgress_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction CircularProgress_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction CircularProgress_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = CircularProgress_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction CircularProgress_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\n\n\nvar CircularProgress = /*#__PURE__*/(0,react.forwardRef)(function (_ref, ref) {\n  var _classnames;\n\n  var _ref$value = _ref.value,\n      value = _ref$value === void 0 ? 0 : _ref$value,\n      _ref$size = _ref.size,\n      size = _ref$size === void 0 ? Size.MEDIUM : _ref$size,\n      _ref$indeterminate = _ref.indeterminate,\n      indeterminate = _ref$indeterminate === void 0 ? false : _ref$indeterminate,\n      _ref$closed = _ref.closed,\n      closed = _ref$closed === void 0 ? false : _ref$closed,\n      _ref$colorful = _ref.colorful,\n      colorful = _ref$colorful === void 0 ? false : _ref$colorful,\n      className = _ref.className,\n      props = CircularProgress_objectWithoutProperties(_ref, CircularProgress_excluded);\n\n  var classNames = classnames_default()(circular_progress_constants_cssClasses.ROOT, (_classnames = {}, CircularProgress_defineProperty(_classnames, "".concat(circular_progress_constants_cssClasses.ROOT, "--").concat(size), size), CircularProgress_defineProperty(_classnames, circular_progress_constants_cssClasses.INDETERMINATE, indeterminate), CircularProgress_defineProperty(_classnames, circular_progress_constants_cssClasses.CLOSED, closed), _classnames), className);\n  var _sizeProps$size = sizeProps[size],\n      viewBox = _sizeProps$size.viewBox,\n      radius = _sizeProps$size.radius,\n      strokeDasharray = _sizeProps$size.strokeDasharray,\n      strokeWidth = _sizeProps$size.strokeWidth,\n      gapPatchStrokeWidth = _sizeProps$size.gapPatchStrokeWidth,\n      indeterminateStrokeDashoffset = _sizeProps$size.indeterminateStrokeDashoffset;\n  var progress = value > 1 ? value / 100 : Number(value);\n  var cx = viewBox / 2,\n      cy = viewBox / 2;\n  var strokeDashoffset = 2 * Math.PI * radius * (1 - progress);\n  return /*#__PURE__*/(0,jsx_runtime.jsxs)("div", CircularProgress_objectSpread(CircularProgress_objectSpread({\n    ref: ref,\n    className: classNames,\n    role: "progressbar",\n    "aria-valuemin": 0,\n    "aria-valuemax": 1,\n    "aria-valuenow": progress\n  }, props), {}, {\n    children: [!indeterminate && /*#__PURE__*/(0,jsx_runtime.jsx)("div", {\n      className: circular_progress_constants_cssClasses.DETERMINATE_CONTAINER,\n      children: /*#__PURE__*/(0,jsx_runtime.jsxs)("svg", {\n        className: circular_progress_constants_cssClasses.DETERMINATE_CIRCLE_GRAPHIC,\n        viewBox: "0 0 ".concat(viewBox, " ").concat(viewBox),\n        xmlns: strings.XMLNS,\n        children: [/*#__PURE__*/(0,jsx_runtime.jsx)("circle", {\n          className: circular_progress_constants_cssClasses.DETERMINATE_TRACK,\n          cx: cx,\n          cy: cy,\n          r: radius,\n          strokeWidth: strokeWidth\n        }), /*#__PURE__*/(0,jsx_runtime.jsx)("circle", {\n          className: circular_progress_constants_cssClasses.DETERMINATE_CIRCLE,\n          cx: cx,\n          cy: cy,\n          r: radius,\n          strokeWidth: strokeWidth,\n          strokeDasharray: strokeDasharray,\n          strokeDashoffset: strokeDashoffset\n        })]\n      })\n    }), indeterminate && /*#__PURE__*/(0,jsx_runtime.jsx)("div", {\n      className: circular_progress_constants_cssClasses.INDETERMINATE_CONTAINER,\n      children: (colorful ? [1, 2, 3, 4] : [0]).map(function (n) {\n        return /*#__PURE__*/(0,jsx_runtime.jsxs)("div", {\n          className: classnames_default()(circular_progress_constants_cssClasses.SPINNER_LAYER, CircularProgress_defineProperty({}, "".concat(circular_progress_constants_cssClasses.PROGRESS_COLOR, "-").concat(n), n)),\n          children: [/*#__PURE__*/(0,jsx_runtime.jsx)("div", {\n            className: "".concat(circular_progress_constants_cssClasses.CIRCLE_CLIPPER, " ").concat(circular_progress_constants_cssClasses.CIRCLE_LEFT),\n            children: /*#__PURE__*/(0,jsx_runtime.jsx)("svg", {\n              className: circular_progress_constants_cssClasses.INDETERMINATE_CIRCLE_GRAPHIC,\n              viewBox: "0 0 ".concat(viewBox, " ").concat(viewBox),\n              xmlns: strings.XMLNS,\n              children: /*#__PURE__*/(0,jsx_runtime.jsx)("circle", {\n                cx: cx,\n                cy: cy,\n                r: radius,\n                strokeWidth: strokeWidth,\n                strokeDasharray: strokeDasharray,\n                strokeDashoffset: indeterminateStrokeDashoffset\n              })\n            })\n          }), /*#__PURE__*/(0,jsx_runtime.jsx)("div", {\n            className: circular_progress_constants_cssClasses.GAP_PATCH,\n            children: /*#__PURE__*/(0,jsx_runtime.jsx)("svg", {\n              className: circular_progress_constants_cssClasses.INDETERMINATE_CIRCLE_GRAPHIC,\n              viewBox: "0 0 ".concat(viewBox, " ").concat(viewBox),\n              xmlns: strings.XMLNS,\n              children: /*#__PURE__*/(0,jsx_runtime.jsx)("circle", {\n                cx: cx,\n                cy: cy,\n                r: radius,\n                strokeWidth: gapPatchStrokeWidth,\n                strokeDasharray: strokeDasharray,\n                strokeDashoffset: indeterminateStrokeDashoffset\n              })\n            })\n          }), /*#__PURE__*/(0,jsx_runtime.jsx)("div", {\n            className: "".concat(circular_progress_constants_cssClasses.CIRCLE_CLIPPER, " ").concat(circular_progress_constants_cssClasses.CIRCLE_RIGHT),\n            children: /*#__PURE__*/(0,jsx_runtime.jsx)("svg", {\n              className: circular_progress_constants_cssClasses.INDETERMINATE_CIRCLE_GRAPHIC,\n              viewBox: "0 0 ".concat(viewBox, " ").concat(viewBox),\n              xmlns: strings.XMLNS,\n              children: /*#__PURE__*/(0,jsx_runtime.jsx)("circle", {\n                cx: cx,\n                cy: cy,\n                r: radius,\n                strokeWidth: strokeWidth,\n                strokeDasharray: strokeDasharray,\n                strokeDashoffset: indeterminateStrokeDashoffset\n              })\n            })\n          })]\n        }, n);\n      })\n    })]\n  }));\n});\nCircularProgress.displayName = \'MDCCircularProgress\';\nCircularProgress.propTypes = {\n  value: prop_types_default().oneOfType([(prop_types_default()).number, (prop_types_default()).string]),\n  size: prop_types_default().oneOf([strings.SMALL, strings.MEDIUM, strings.LARGE]),\n  indeterminate: (prop_types_default()).bool,\n  closed: (prop_types_default()).bool,\n  colorful: (prop_types_default()).bool\n};\nCircularProgress.Size = Size;\n/* harmony default export */ const circular_progress_CircularProgress = (CircularProgress);\n;// CONCATENATED MODULE: ./src/circular-progress/index.js\n\n;// CONCATENATED MODULE: ./src/icon-button/constants.js\nvar icon_button_constants_cssClasses = {\n  ROOT: \'mdc-icon-button\',\n  TOUCH: \'mdc-icon-button--touch\',\n  MATERIAL_ICONS: \'material-icons\',\n  ICON: \'mdc-icon-button__icon\',\n  RIPPLE: \'mdc-icon-button__ripple\',\n  TOUCH_ELEMENT: \'mdc-icon-button__touch\'\n};\n;// CONCATENATED MODULE: ./src/icon-button/IconButton.jsx\nvar IconButton_excluded = ["icon", "touch", "element", "component", "className", "children"];\n\nfunction IconButton_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction IconButton_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { IconButton_ownKeys(Object(source), true).forEach(function (key) { IconButton_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { IconButton_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction IconButton_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction IconButton_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = IconButton_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction IconButton_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\n\n\n\nvar IconButton = /*#__PURE__*/(0,react.forwardRef)(function (_ref, ref) {\n  var _classnames;\n\n  var icon = _ref.icon,\n      _ref$touch = _ref.touch,\n      touch = _ref$touch === void 0 ? false : _ref$touch,\n      _ref$element = _ref.element,\n      element = _ref$element === void 0 ? \'button\' : _ref$element,\n      _ref$component = _ref.component,\n      Element = _ref$component === void 0 ? element : _ref$component,\n      className = _ref.className,\n      _ref$children = _ref.children,\n      children = _ref$children === void 0 ? icon : _ref$children,\n      props = IconButton_objectWithoutProperties(_ref, IconButton_excluded);\n\n  var classNames = classnames_default()(icon_button_constants_cssClasses.ROOT, (_classnames = {}, IconButton_defineProperty(_classnames, icon_button_constants_cssClasses.MATERIAL_ICONS, typeof children === \'string\'), IconButton_defineProperty(_classnames, icon_button_constants_cssClasses.TOUCH, touch), _classnames), className);\n  return /*#__PURE__*/(0,jsx_runtime.jsxs)(Element, IconButton_objectSpread(IconButton_objectSpread({\n    ref: ref,\n    className: classNames\n  }, props), {}, {\n    children: [/*#__PURE__*/(0,jsx_runtime.jsx)("div", {\n      className: icon_button_constants_cssClasses.RIPPLE\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Clone, {\n      component: children,\n      className: icon_button_constants_cssClasses.ICON\n    }), touch && /*#__PURE__*/(0,jsx_runtime.jsx)("div", {\n      className: icon_button_constants_cssClasses.TOUCH_ELEMENT\n    })]\n  }));\n});\nIconButton.displayName = \'MDCIconButton\';\nIconButton.propTypes = {\n  icon: (prop_types_default()).node\n};\n/* harmony default export */ const icon_button_IconButton = (IconButton);\n;// CONCATENATED MODULE: ./src/icon-button/index.js\n\n;// CONCATENATED MODULE: ./src/linear-progress/constants.js\nvar linear_progress_constants_cssClasses = {\n  ROOT: \'mdc-linear-progress\',\n  INDETERMINATE: \'mdc-linear-progress--indeterminate\',\n  ANIMATION_READY: \'mdc-linear-progress--animation-ready\',\n  CLOSED: \'mdc-linear-progress--closed\',\n  CLOSED_ANIMATION_OFF: \'mdc-linear-progress--closed-animation-off\',\n  BUFFER: \'mdc-linear-progress__buffer\',\n  BUFFER_BAR: \'mdc-linear-progress__buffer-bar\',\n  BUFFER_DOTS: \'mdc-linear-progress__buffer-dots\',\n  BAR: \'mdc-linear-progress__bar\',\n  PRIMARY_BAR: \'mdc-linear-progress__primary-bar\',\n  SECONDARY_BAR: \'mdc-linear-progress__secondary-bar\',\n  BAR_INNER: \'mdc-linear-progress__bar-inner\'\n};\n;// CONCATENATED MODULE: ./src/linear-progress/LinearProgress.jsx\nvar LinearProgress_excluded = ["value", "buffer", "indeterminate", "closed", "className"];\n\nfunction LinearProgress_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction LinearProgress_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { LinearProgress_ownKeys(Object(source), true).forEach(function (key) { LinearProgress_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { LinearProgress_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction LinearProgress_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction LinearProgress_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = LinearProgress_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction LinearProgress_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\n\n\nvar LinearProgress = /*#__PURE__*/(0,react.forwardRef)(function (_ref, ref) {\n  var _classnames;\n\n  var _ref$value = _ref.value,\n      value = _ref$value === void 0 ? 0 : _ref$value,\n      _ref$buffer = _ref.buffer,\n      buffer = _ref$buffer === void 0 ? 0 : _ref$buffer,\n      _ref$indeterminate = _ref.indeterminate,\n      indeterminate = _ref$indeterminate === void 0 ? false : _ref$indeterminate,\n      _ref$closed = _ref.closed,\n      closed = _ref$closed === void 0 ? false : _ref$closed,\n      className = _ref.className,\n      props = LinearProgress_objectWithoutProperties(_ref, LinearProgress_excluded);\n\n  var classNames = classnames_default()(linear_progress_constants_cssClasses.ROOT, (_classnames = {}, LinearProgress_defineProperty(_classnames, linear_progress_constants_cssClasses.INDETERMINATE, indeterminate), LinearProgress_defineProperty(_classnames, linear_progress_constants_cssClasses.ANIMATION_READY, indeterminate), LinearProgress_defineProperty(_classnames, linear_progress_constants_cssClasses.CLOSED, closed), _classnames), className);\n  var primaryBarStyle = {\n    transform: "scaleX(".concat(indeterminate ? 1 : value > 1 ? value * 0.01 : value, ")")\n  };\n  var bufferStyle = {\n    flexBasis: buffer ? "".concat(indeterminate ? 1 : buffer < 1 ? buffer * 100 : buffer, "%") : undefined\n  };\n  return /*#__PURE__*/(0,jsx_runtime.jsxs)("div", LinearProgress_objectSpread(LinearProgress_objectSpread({\n    ref: ref,\n    className: classNames,\n    role: "progressbar",\n    "aria-valuemin": "0",\n    "aria-valuemax": "1",\n    "aria-valuenow": value > 1 ? value * 0.01 : value\n  }, props), {}, {\n    children: [/*#__PURE__*/(0,jsx_runtime.jsxs)("div", {\n      className: linear_progress_constants_cssClasses.BUFFER,\n      children: [/*#__PURE__*/(0,jsx_runtime.jsx)("div", {\n        className: linear_progress_constants_cssClasses.BUFFER_BAR,\n        style: bufferStyle\n      }), /*#__PURE__*/(0,jsx_runtime.jsx)("div", {\n        className: linear_progress_constants_cssClasses.BUFFER_DOTS\n      })]\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)("div", {\n      className: "".concat(linear_progress_constants_cssClasses.BAR, " ").concat(linear_progress_constants_cssClasses.PRIMARY_BAR),\n      style: primaryBarStyle,\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)("span", {\n        className: linear_progress_constants_cssClasses.BAR_INNER\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)("div", {\n      className: "".concat(linear_progress_constants_cssClasses.BAR, " ").concat(linear_progress_constants_cssClasses.SECONDARY_BAR),\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)("span", {\n        className: linear_progress_constants_cssClasses.BAR_INNER\n      })\n    })]\n  }));\n});\nLinearProgress.displayName = \'MDCLinearProgress\';\nLinearProgress.propTypes = {\n  value: prop_types_default().oneOfType([(prop_types_default()).number, (prop_types_default()).string]),\n  buffer: prop_types_default().oneOfType([(prop_types_default()).number, (prop_types_default()).string]),\n  indeterminate: (prop_types_default()).bool,\n  closed: (prop_types_default()).bool\n};\n/* harmony default export */ const linear_progress_LinearProgress = (LinearProgress);\n;// CONCATENATED MODULE: ./src/linear-progress/index.js\n\n;// CONCATENATED MODULE: ./src/data-table/constants.js\nvar data_table_constants_cssClasses = {\n  ROOT: \'mdc-data-table\',\n  STICKY_HEADER: \'mdc-data-table--sticky-header\',\n  IN_PROGRESS: \'mdc-data-table--in-progress\',\n  TABLE_CONTAINER: \'mdc-data-table__table-container\',\n  TABLE: \'mdc-data-table__table\',\n  HEADER: \'mdc-data-table__header\',\n  HEADER_ROW: \'mdc-data-table__header-row\',\n  HEADER_ROW_CHECKBOX: \'mdc-data-table__header-row-checkbox\',\n  HEADER_CELL: \'mdc-data-table__header-cell\',\n  HEADER_CELL_CHECKBOX: \'mdc-data-table__header-cell--checkbox\',\n  HEADER_CELL_NUMERIC: \'mdc-data-table__header-cell--numeric\',\n  HEADER_CELL_WITH_SORT: \'mdc-data-table__header-cell--with-sort\',\n  HEADER_CELL_SORTED: \'mdc-data-table__header-cell--sorted\',\n  HEADER_CELL_SORTED_DESC: \'mdc-data-table__header-cell--sorted-descending\',\n  HEADER_CELL_WRAPPER: \'mdc-data-table__header-cell-wrapper\',\n  HEADER_CELL_LABEL: \'mdc-data-table__header-cell-label\',\n  CONTENT: \'mdc-data-table__content\',\n  ROW: \'mdc-data-table__row\',\n  ROW_CHECKBOX: \'mdc-data-table__row-checkbox\',\n  ROW_SELECTED: \'mdc-data-table__row--selected\',\n  CELL: \'mdc-data-table__cell\',\n  CELL_CHECKBOX: \'mdc-data-table__cell--checkbox\',\n  CELL_NUMERIC: \'mdc-data-table__cell--numeric\',\n  PAGINATION: \'mdc-data-table__pagination\',\n  PAGINATION_TRAILING: \'mdc-data-table__pagination-trailing\',\n  PAGINATION_ROWS_PER_PAGE: \'mdc-data-table__pagination-rows-per-page\',\n  PAGINATION_ROWS_PER_PAGE_LABEL: \'mdc-data-table__pagination-rows-per-page-label\',\n  PAGINATION_ROWS_PER_PAGE_SELECT: \'mdc-data-table__pagination-rows-per-page-select\',\n  PAGINATION_NAVIGATION: \'mdc-data-table__pagination-navigation\',\n  PAGINATION_TOTAL: \'mdc-data-table__pagination-total\',\n  PAGINATION_BUTTON: \'mdc-data-table__pagination-button\',\n  SORT_ICON_BUTTON: \'mdc-data-table__sort-icon-button\',\n  SORT_STATUS_LABEL: \'mdc-data-table__sort-status-label\',\n  PROGRESS_INDICATOR: \'mdc-data-table__progress-indicator\',\n  SCRIM: \'mdc-data-table__scrim\',\n  FOOTER: \'mdc-data-table__footer\',\n  LINEAR_PROGRESS: \'mdc-data-table__linear-progress\'\n};\n;// CONCATENATED MODULE: ./src/data-table/DataTableProgressIndicator.jsx\nfunction DataTableProgressIndicator_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction DataTableProgressIndicator_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { DataTableProgressIndicator_ownKeys(Object(source), true).forEach(function (key) { DataTableProgressIndicator_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { DataTableProgressIndicator_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction DataTableProgressIndicator_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n\n\n\n\n\nvar DataTableProgressIndicator = /*#__PURE__*/(0,react.forwardRef)(function (props, ref) {\n  return /*#__PURE__*/(0,jsx_runtime.jsxs)("div", DataTableProgressIndicator_objectSpread(DataTableProgressIndicator_objectSpread({\n    ref: ref,\n    className: data_table_constants_cssClasses.PROGRESS_INDICATOR\n  }, props), {}, {\n    children: [/*#__PURE__*/(0,jsx_runtime.jsx)("div", {\n      className: data_table_constants_cssClasses.SCRIM\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(linear_progress_LinearProgress, {\n      className: data_table_constants_cssClasses.LINEAR_PROGRESS,\n      indeterminate: true\n    })]\n  }));\n});\nDataTableProgressIndicator.displayName = \'MDCDataTableProgressIndicator\';\n/* harmony default export */ const data_table_DataTableProgressIndicator = (DataTableProgressIndicator);\n;// CONCATENATED MODULE: ./src/floating-label/constants.js\nvar floating_label_constants_cssClasses = {\n  ROOT: \'mdc-floating-label\',\n  FLOAT: \'mdc-floating-label--float-above\',\n  REQUIRED: \'mdc-floating-label--required\'\n};\n;// CONCATENATED MODULE: ./src/floating-label/FloatingLabel.jsx\nvar FloatingLabel_excluded = ["label", "float", "required", "className", "children"];\n\nfunction FloatingLabel_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction FloatingLabel_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { FloatingLabel_ownKeys(Object(source), true).forEach(function (key) { FloatingLabel_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { FloatingLabel_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction FloatingLabel_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction FloatingLabel_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = FloatingLabel_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction FloatingLabel_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\n\nvar FloatingLabel = /*#__PURE__*/(0,react.forwardRef)(function (_ref, ref) {\n  var _classnames;\n\n  var label = _ref.label,\n      _ref$float = _ref["float"],\n      _float = _ref$float === void 0 ? false : _ref$float,\n      _ref$required = _ref.required,\n      required = _ref$required === void 0 ? false : _ref$required,\n      className = _ref.className,\n      _ref$children = _ref.children,\n      children = _ref$children === void 0 ? label : _ref$children,\n      props = FloatingLabel_objectWithoutProperties(_ref, FloatingLabel_excluded);\n\n  var classNames = classnames_default()(floating_label_constants_cssClasses.ROOT, (_classnames = {}, FloatingLabel_defineProperty(_classnames, floating_label_constants_cssClasses.FLOAT, _float), FloatingLabel_defineProperty(_classnames, floating_label_constants_cssClasses.REQUIRED, required), _classnames), className);\n  return /*#__PURE__*/(0,jsx_runtime.jsx)("span", FloatingLabel_objectSpread(FloatingLabel_objectSpread({\n    ref: ref,\n    className: classNames\n  }, props), {}, {\n    children: children\n  }));\n});\nFloatingLabel.displayName = \'MDCFloatingLabel\';\nFloatingLabel.propTypes = {\n  label: (prop_types_default()).string,\n  "float": (prop_types_default()).bool,\n  required: (prop_types_default()).bool\n};\n/* harmony default export */ const floating_label_FloatingLabel = (FloatingLabel);\n;// CONCATENATED MODULE: ./src/floating-label/index.js\n\n;// CONCATENATED MODULE: ./src/line-ripple/constants.js\nvar line_ripple_constants_cssClasses = {\n  ROOT: \'mdc-line-ripple\',\n  ACTIVE: \'mdc-line-ripple--active\',\n  DEACTIVATING: \'mdc-line-ripple--deactivating\'\n};\n;// CONCATENATED MODULE: ./src/line-ripple/LineRipple.jsx\nvar LineRipple_excluded = ["active", "transformOrigin"];\n\nfunction LineRipple_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction LineRipple_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { LineRipple_ownKeys(Object(source), true).forEach(function (key) { LineRipple_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { LineRipple_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction LineRipple_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction LineRipple_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = LineRipple_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction LineRipple_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\n\nvar LineRipple = /*#__PURE__*/(0,react.forwardRef)(function (_ref, ref) {\n  var _ref$active = _ref.active,\n      active = _ref$active === void 0 ? false : _ref$active,\n      transformOrigin = _ref.transformOrigin,\n      props = LineRipple_objectWithoutProperties(_ref, LineRipple_excluded);\n\n  var style = transformOrigin && {\n    transformOrigin: "".concat(transformOrigin, "px")\n  };\n  var classNames = classnames_default()(line_ripple_constants_cssClasses.ROOT, LineRipple_defineProperty({}, line_ripple_constants_cssClasses.ACTIVE, active));\n  return /*#__PURE__*/(0,jsx_runtime.jsx)("span", LineRipple_objectSpread({\n    ref: ref,\n    style: style,\n    className: classNames\n  }, props));\n});\nLineRipple.displayName = \'MDCLineRipple\';\nLineRipple.propTypes = {\n  active: (prop_types_default()).bool\n};\n/* harmony default export */ const line_ripple_LineRipple = (LineRipple);\n;// CONCATENATED MODULE: ./src/line-ripple/index.js\n\n;// CONCATENATED MODULE: ./src/notched-outline/constants.js\nvar notched_outline_constants_numbers = {\n  NOTCH_SIZE_FACTOR: 0.75\n};\nvar notched_outline_constants_cssClasses = {\n  ROOT: \'mdc-notched-outline\',\n  NOTCHED: \'mdc-notched-outline--notched\',\n  UPGRADED: \'mdc-notched-outline--upgraded\',\n  NO_LABEL: \'mdc-notched-outline--no-label\',\n  LEADING: \'mdc-notched-outline__leading\',\n  NOTCH: \'mdc-notched-outline__notch\',\n  TRAILING: \'mdc-notched-outline__trailing\'\n};\n;// CONCATENATED MODULE: ./src/notched-outline/NotchedOutline.jsx\nvar NotchedOutline_excluded = ["notched", "className", "children"];\n\nfunction NotchedOutline_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction NotchedOutline_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { NotchedOutline_ownKeys(Object(source), true).forEach(function (key) { NotchedOutline_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { NotchedOutline_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction NotchedOutline_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction NotchedOutline_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = NotchedOutline_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction NotchedOutline_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\n\n\nvar NotchedOutline = /*#__PURE__*/(0,react.forwardRef)(function (_ref, ref) {\n  var _classnames;\n\n  var _ref$notched = _ref.notched,\n      notched = _ref$notched === void 0 ? false : _ref$notched,\n      className = _ref.className,\n      children = _ref.children,\n      props = NotchedOutline_objectWithoutProperties(_ref, NotchedOutline_excluded);\n\n  var notchRef = (0,react.useRef)();\n  (0,react.useLayoutEffect)(function () {\n    if (!notchRef.current) return;\n\n    if (notched) {\n      notchRef.current.style.width = "".concat((notchRef.current.clientWidth + 2) * notched_outline_constants_numbers.NOTCH_SIZE_FACTOR, "px");\n    } else {\n      notchRef.current.style.width = \'auto\';\n    }\n  }, [notched]);\n  var classNames = classnames_default()(notched_outline_constants_cssClasses.ROOT, notched_outline_constants_cssClasses.UPGRADED, (_classnames = {}, NotchedOutline_defineProperty(_classnames, notched_outline_constants_cssClasses.NOTCHED, notched), NotchedOutline_defineProperty(_classnames, notched_outline_constants_cssClasses.NO_LABEL, !children), _classnames), className);\n  return /*#__PURE__*/(0,jsx_runtime.jsxs)("span", NotchedOutline_objectSpread(NotchedOutline_objectSpread({\n    ref: ref,\n    className: classNames\n  }, props), {}, {\n    children: [/*#__PURE__*/(0,jsx_runtime.jsx)("span", {\n      className: notched_outline_constants_cssClasses.LEADING\n    }), children && /*#__PURE__*/(0,jsx_runtime.jsx)("span", {\n      ref: notchRef,\n      className: notched_outline_constants_cssClasses.NOTCH,\n      children: children\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)("span", {\n      className: notched_outline_constants_cssClasses.TRAILING\n    })]\n  }));\n});\nNotchedOutline.displayName = \'MDCNotchedOutline\';\nNotchedOutline.propTypes = {\n  notched: (prop_types_default()).bool\n};\n/* harmony default export */ const notched_outline_NotchedOutline = (NotchedOutline);\n;// CONCATENATED MODULE: ./src/notched-outline/index.js\n\n;// CONCATENATED MODULE: ./src/menu/constants.js\nvar menu_constants_numbers = {\n  TRANSITION_OPEN_DURATION: 120,\n  TRANSITION_CLOSE_DURATION: 75,\n  MARGIN_TO_EDGE: 32,\n  ANCHOR_TO_MENU_SURFACE_WIDTH_RATIO: 0.67,\n  TOUCH_EVENT_WAIT_MS: 30\n};\nvar menu_constants_cssClasses = {\n  ROOT: \'mdc-menu\',\n  SURFACE: \'mdc-menu-surface\',\n  SURFACE_ANCHOR: \'mdc-menu-surface--anchor\',\n  SURFACE_FIXED: \'mdc-menu-surface--fixed\',\n  SURFACE_OPEN: \'mdc-menu-surface--open\',\n  SURFACE_ANIMATING_OPEN: \'mdc-menu-surface--animating-open\',\n  SURFACE_ANIMATING_CLOSED: \'mdc-menu-surface--animating-closed\',\n  SURFACE_BELOW_ANCHOR: \'mdc-menu-surface--is-open-below\',\n  ITEM: \'mdc-menu-item\',\n  ITEM_SELECTED: \'mdc-menu-item--selected\',\n  SELECTION_GROUP: \'mdc-menu__selection-group\',\n  SELECTION_GROUP_ICON: \'mdc-menu__selection-group-icon\'\n};\nvar Origin = {\n  TOP_LEFT: \'top left\',\n  TOP_CENTER: \'top center\',\n  TOP_RIGHT: \'top right\',\n  CENTER_LEFT: \'center left\',\n  CENTER: \'center center\',\n  CENTER_RIGHT: \'center right\',\n  BOTTOM_LEFT: \'bottom left\',\n  BOTTOM_CENTER: \'bottom center\',\n  BOTTOM_RIGHT: \'bottom right\'\n};\n;// CONCATENATED MODULE: ./src/hooks.js\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\n\nfunction useCreated(fn) {\n  var _useState = useState(false),\n      _useState2 = _slicedToArray(_useState, 2),\n      created = _useState2[0],\n      setCreated = _useState2[1];\n\n  if (created) return;\n  fn();\n  setCreated(true);\n}\nfunction useMounted(fn) {\n  (0,react.useEffect)(function () {\n    return fn();\n  }, []);\n}\nfunction useUpdated(fn, deps) {\n  var _useState3 = (0,react.useState)(false),\n      _useState4 = _slicedToArray(_useState3, 2),\n      mounted = _useState4[0],\n      setMounted = _useState4[1];\n\n  (0,react.useEffect)(function () {\n    if (!mounted) return setMounted(true);\n    return fn();\n  }, deps);\n}\nfunction useUpdatedSync(fn, deps) {\n  var _useState5 = (0,react.useState)(false),\n      _useState6 = _slicedToArray(_useState5, 2),\n      mounted = _useState6[0],\n      setMounted = _useState6[1];\n\n  (0,react.useLayoutEffect)(function () {\n    if (!mounted) return setMounted(true);\n    return fn();\n  }, deps);\n}\nfunction useUnmounted(fn) {\n  (0,react.useEffect)(function () {\n    return function () {\n      return fn();\n    };\n  }, []);\n}\n;// CONCATENATED MODULE: ./src/list/constants.js\nvar listCssClasses = {\n  ROOT: \'mdc-list\'\n};\nvar listItemCssClasses = {\n  ROOT: \'mdc-list-item\',\n  ACTIVATED: \'mdc-list-item--activated\',\n  SELECTED: \'mdc-list-item--selected\',\n  DISABLED: \'mdc-list-item--disabled\',\n  NON_INTERACTIVE: \'mdc-list-item--non-interactive\',\n  ONE_LINE: \'mdc-list-item--with-one-line\',\n  TWO_LINES: \'mdc-list-item--with-two-lines\',\n  THREE_LINES: \'mdc-list-item--with-three-lines\',\n  OVERLINE: \'mdc-list-item--with-overline\',\n  LEADING_ICON: \'mdc-list-item--with-leading-icon\',\n  LEADING_IMAGE: \'mdc-list-item--with-leading-image\',\n  LEADING_THUMBNAIL: \'mdc-list-item--with-leading-thumbnail\',\n  LEADING_VIDEO: \'mdc-list-item--with-leading-video\',\n  LEADING_CHECKBOX: \'mdc-list-item--with-leading-checkbox\',\n  LEADING_RADIO: \'mdc-list-item--with-leading-radio\',\n  LEADING_SWITCH: \'mdc-list-item--with-leading-switch\',\n  TRAILING_ICON: \'mdc-list-item--with-trailing-icon\',\n  TRAILING_META: \'mdc-list-item--with-trailing-meta\',\n  TRAILING_CHECKBOX: \'mdc-list-item--with-trailing-checkbox\',\n  TRAILING_RADIO: \'mdc-list-item--with-trailing-radio\',\n  TRAILING_SWITCH: \'mdc-list-item--with-trailing-switch\',\n  START: \'mdc-list-item__start\',\n  CONTENT: \'mdc-list-item__content\',\n  END: \'mdc-list-item__end\',\n  OVERLINE_TEXT: \'mdc-list-item__overline-text\',\n  PRIMARY_TEXT: \'mdc-list-item__primary-text\',\n  SECONDARY_TEXT: \'mdc-list-item__secondary-text\',\n  RIPPLE: \'mdc-list-item__ripple\'\n};\nvar listGroupCssClasses = {\n  ROOT: \'mdc-list-group\',\n  SUBHEADER: \'mdc-list-group__subheader\'\n};\nvar listDividerCssClasses = {\n  ROOT: \'mdc-list-divider\',\n  LEADING_TEXT: \'mdc-list-divider--with-leading-text\',\n  LEADING_ICON: \'mdc-list-divider--with-leading-icon\',\n  LEADING_IMAGE: \'mdc-list-divider--with-leading-image\',\n  LEADING_VIDEO: \'mdc-list-divider--with-leading-video\',\n  LEADING_THUMBNAIL: \'mdc-list-divider--with-leading-thumbnail\',\n  LEADING_AVATAR: \'mdc-list-divider--with-leading-avatar\',\n  LEADING_CHECKBOX: \'mdc-list-divider--with-leading-checkbox\',\n  LEADING_SWITCH: \'mdc-list-divider--with-leading-switch\',\n  LEADING_RADIO: \'mdc-list-divider--with-leading-radio\'\n};\n;// CONCATENATED MODULE: ./src/list/ListItemContent.jsx\nvar ListItemContent_excluded = ["overline", "primary", "secondary", "overlineText", "primaryText", "secondaryText", "element", "component", "className", "children"];\n\nfunction ListItemContent_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction ListItemContent_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ListItemContent_ownKeys(Object(source), true).forEach(function (key) { ListItemContent_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ListItemContent_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction ListItemContent_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction ListItemContent_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = ListItemContent_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction ListItemContent_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\n\n\n\nvar ListItemContent = /*#__PURE__*/(0,react.forwardRef)(function (_ref, ref) {\n  var overline = _ref.overline,\n      primary = _ref.primary,\n      secondary = _ref.secondary,\n      _ref$overlineText = _ref.overlineText,\n      overlineText = _ref$overlineText === void 0 ? overline : _ref$overlineText,\n      _ref$primaryText = _ref.primaryText,\n      primaryText = _ref$primaryText === void 0 ? primary : _ref$primaryText,\n      _ref$secondaryText = _ref.secondaryText,\n      secondaryText = _ref$secondaryText === void 0 ? secondary : _ref$secondaryText,\n      _ref$element = _ref.element,\n      element = _ref$element === void 0 ? \'span\' : _ref$element,\n      _ref$component = _ref.component,\n      Element = _ref$component === void 0 ? element : _ref$component,\n      className = _ref.className,\n      children = _ref.children,\n      props = ListItemContent_objectWithoutProperties(_ref, ListItemContent_excluded);\n\n  var classNames = classnames_default()(listItemCssClasses.CONTENT, className);\n  return /*#__PURE__*/(0,jsx_runtime.jsxs)(Element, ListItemContent_objectSpread(ListItemContent_objectSpread({\n    ref: ref,\n    className: classNames\n  }, props), {}, {\n    children: [overlineText && /*#__PURE__*/(0,jsx_runtime.jsx)(Clone, {\n      component: overlineText,\n      fallback: "span",\n      className: listItemCssClasses.OVERLINE_TEXT\n    }), primaryText && /*#__PURE__*/(0,jsx_runtime.jsx)(Clone, {\n      component: primaryText,\n      fallback: "span",\n      className: listItemCssClasses.PRIMARY_TEXT\n    }), secondaryText && /*#__PURE__*/(0,jsx_runtime.jsx)(Clone, {\n      component: secondaryText,\n      fallback: "span",\n      className: listItemCssClasses.SECONDARY_TEXT\n    }), children]\n  }));\n});\nListItemContent.displayName = \'MDCListItemContent\';\nListItemContent.propTypes = {\n  overlineText: (prop_types_default()).node,\n  primaryText: (prop_types_default()).node,\n  secondaryText: (prop_types_default()).node\n};\n/* harmony default export */ const list_ListItemContent = (ListItemContent);\n;// CONCATENATED MODULE: ./src/list/ListItemEnd.jsx\nvar ListItemEnd_excluded = ["element", "component", "className"];\n\nfunction ListItemEnd_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction ListItemEnd_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ListItemEnd_ownKeys(Object(source), true).forEach(function (key) { ListItemEnd_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ListItemEnd_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction ListItemEnd_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction ListItemEnd_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = ListItemEnd_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction ListItemEnd_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\nvar ListItemEnd = /*#__PURE__*/(0,react.forwardRef)(function (_ref, ref) {\n  var _ref$element = _ref.element,\n      element = _ref$element === void 0 ? \'span\' : _ref$element,\n      _ref$component = _ref.component,\n      Element = _ref$component === void 0 ? element : _ref$component,\n      className = _ref.className,\n      props = ListItemEnd_objectWithoutProperties(_ref, ListItemEnd_excluded);\n\n  var classNames = classnames_default()(listItemCssClasses.END, className);\n  return /*#__PURE__*/(0,jsx_runtime.jsx)(Element, ListItemEnd_objectSpread({\n    ref: ref,\n    className: classNames\n  }, props));\n});\nListItemEnd.displayName = \'MDCListItemEnd\';\n/* harmony default export */ const list_ListItemEnd = (ListItemEnd);\n;// CONCATENATED MODULE: ./src/list/ListItemStart.jsx\nvar ListItemStart_excluded = ["element", "component", "className"];\n\nfunction ListItemStart_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction ListItemStart_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ListItemStart_ownKeys(Object(source), true).forEach(function (key) { ListItemStart_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ListItemStart_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction ListItemStart_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction ListItemStart_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = ListItemStart_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction ListItemStart_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\nvar ListItemStart = /*#__PURE__*/(0,react.forwardRef)(function (_ref, ref) {\n  var _ref$element = _ref.element,\n      element = _ref$element === void 0 ? \'span\' : _ref$element,\n      _ref$component = _ref.component,\n      Element = _ref$component === void 0 ? element : _ref$component,\n      className = _ref.className,\n      props = ListItemStart_objectWithoutProperties(_ref, ListItemStart_excluded);\n\n  var classNames = classnames_default()(listItemCssClasses.START, className);\n  return /*#__PURE__*/(0,jsx_runtime.jsx)(Element, ListItemStart_objectSpread({\n    ref: ref,\n    className: classNames\n  }, props));\n});\nListItemStart.displayName = \'MDCListItemStart\';\n/* harmony default export */ const list_ListItemStart = (ListItemStart);\n;// CONCATENATED MODULE: ./src/list/ListItem.jsx\nvar ListItem_excluded = ["start", "content", "end", "text", "overlineText", "primaryText", "secondaryText", "icon", "image", "thumbnail", "video", "leadingIcon", "leadingImage", "leadingThumbnail", "leadingVideo", "leadingCheckbox", "leadingRadio", "leadingSwitch", "meta", "trailingMeta", "trailingIcon", "trailingCheckbox", "trailingRadio", "trailingSwitch", "activated", "selected", "disabled", "nonInteractive", "withLeadingIcon", "withLeadingImage", "withLeadingThumbnail", "withLeadingVideo", "withLeadingCheckbox", "withLeadingRadio", "withLeadingSwitch", "withTrailingMeta", "withTrailingIcon", "withTrailingCheckbox", "withTrailingRadio", "withTrailingSwitch", "element", "component", "className", "children"];\n\nfunction ListItem_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction ListItem_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ListItem_ownKeys(Object(source), true).forEach(function (key) { ListItem_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ListItem_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction ListItem_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction ListItem_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = ListItem_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction ListItem_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\n\n\n\n\n\n\n\nvar ListItem = /*#__PURE__*/(0,react.forwardRef)(function (_ref, ref) {\n  var _classnames;\n\n  var start = _ref.start,\n      content = _ref.content,\n      end = _ref.end,\n      text = _ref.text,\n      overlineText = _ref.overlineText,\n      _ref$primaryText = _ref.primaryText,\n      primaryText = _ref$primaryText === void 0 ? text : _ref$primaryText,\n      secondaryText = _ref.secondaryText,\n      icon = _ref.icon,\n      image = _ref.image,\n      thumbnail = _ref.thumbnail,\n      video = _ref.video,\n      _ref$leadingIcon = _ref.leadingIcon,\n      leadingIcon = _ref$leadingIcon === void 0 ? icon : _ref$leadingIcon,\n      _ref$leadingImage = _ref.leadingImage,\n      leadingImage = _ref$leadingImage === void 0 ? image : _ref$leadingImage,\n      _ref$leadingThumbnail = _ref.leadingThumbnail,\n      leadingThumbnail = _ref$leadingThumbnail === void 0 ? thumbnail : _ref$leadingThumbnail,\n      _ref$leadingVideo = _ref.leadingVideo,\n      leadingVideo = _ref$leadingVideo === void 0 ? video : _ref$leadingVideo,\n      leadingCheckbox = _ref.leadingCheckbox,\n      leadingRadio = _ref.leadingRadio,\n      leadingSwitch = _ref.leadingSwitch,\n      meta = _ref.meta,\n      _ref$trailingMeta = _ref.trailingMeta,\n      trailingMeta = _ref$trailingMeta === void 0 ? meta : _ref$trailingMeta,\n      trailingIcon = _ref.trailingIcon,\n      trailingCheckbox = _ref.trailingCheckbox,\n      trailingRadio = _ref.trailingRadio,\n      trailingSwitch = _ref.trailingSwitch,\n      _ref$activated = _ref.activated,\n      activated = _ref$activated === void 0 ? false : _ref$activated,\n      _ref$selected = _ref.selected,\n      selected = _ref$selected === void 0 ? false : _ref$selected,\n      _ref$disabled = _ref.disabled,\n      disabled = _ref$disabled === void 0 ? false : _ref$disabled,\n      _ref$nonInteractive = _ref.nonInteractive,\n      nonInteractive = _ref$nonInteractive === void 0 ? false : _ref$nonInteractive,\n      _ref$withLeadingIcon = _ref.withLeadingIcon,\n      withLeadingIcon = _ref$withLeadingIcon === void 0 ? Boolean(leadingIcon) : _ref$withLeadingIcon,\n      _ref$withLeadingImage = _ref.withLeadingImage,\n      withLeadingImage = _ref$withLeadingImage === void 0 ? Boolean(leadingImage) : _ref$withLeadingImage,\n      _ref$withLeadingThumb = _ref.withLeadingThumbnail,\n      withLeadingThumbnail = _ref$withLeadingThumb === void 0 ? Boolean(leadingThumbnail) : _ref$withLeadingThumb,\n      _ref$withLeadingVideo = _ref.withLeadingVideo,\n      withLeadingVideo = _ref$withLeadingVideo === void 0 ? Boolean(leadingVideo) : _ref$withLeadingVideo,\n      _ref$withLeadingCheck = _ref.withLeadingCheckbox,\n      withLeadingCheckbox = _ref$withLeadingCheck === void 0 ? Boolean(leadingCheckbox) : _ref$withLeadingCheck,\n      _ref$withLeadingRadio = _ref.withLeadingRadio,\n      withLeadingRadio = _ref$withLeadingRadio === void 0 ? Boolean(leadingRadio) : _ref$withLeadingRadio,\n      _ref$withLeadingSwitc = _ref.withLeadingSwitch,\n      withLeadingSwitch = _ref$withLeadingSwitc === void 0 ? Boolean(leadingSwitch) : _ref$withLeadingSwitc,\n      _ref$withTrailingMeta = _ref.withTrailingMeta,\n      withTrailingMeta = _ref$withTrailingMeta === void 0 ? Boolean(trailingMeta) : _ref$withTrailingMeta,\n      _ref$withTrailingIcon = _ref.withTrailingIcon,\n      withTrailingIcon = _ref$withTrailingIcon === void 0 ? Boolean(trailingIcon) : _ref$withTrailingIcon,\n      _ref$withTrailingChec = _ref.withTrailingCheckbox,\n      withTrailingCheckbox = _ref$withTrailingChec === void 0 ? Boolean(trailingCheckbox) : _ref$withTrailingChec,\n      _ref$withTrailingRadi = _ref.withTrailingRadio,\n      withTrailingRadio = _ref$withTrailingRadi === void 0 ? Boolean(trailingRadio) : _ref$withTrailingRadi,\n      _ref$withTrailingSwit = _ref.withTrailingSwitch,\n      withTrailingSwitch = _ref$withTrailingSwit === void 0 ? Boolean(trailingSwitch) : _ref$withTrailingSwit,\n      _ref$element = _ref.element,\n      element = _ref$element === void 0 ? \'li\' : _ref$element,\n      _ref$component = _ref.component,\n      Element = _ref$component === void 0 ? element : _ref$component,\n      className = _ref.className,\n      children = _ref.children,\n      props = ListItem_objectWithoutProperties(_ref, ListItem_excluded);\n\n  var lines = Boolean(overlineText) + Boolean(primaryText) + Boolean(secondaryText);\n  var hasStart = Boolean(start || leadingIcon || leadingImage || leadingThumbnail || leadingVideo || leadingCheckbox || leadingRadio || leadingSwitch);\n  var hasContent = Boolean(content || overlineText || primaryText || secondaryText);\n  var hasEnd = Boolean(end || trailingMeta || trailingIcon || trailingCheckbox || trailingRadio || trailingSwitch);\n  var classNames = classnames_default()(listItemCssClasses.ROOT, (_classnames = {}, ListItem_defineProperty(_classnames, listItemCssClasses.ACTIVATED, activated), ListItem_defineProperty(_classnames, listItemCssClasses.SELECTED, selected), ListItem_defineProperty(_classnames, listItemCssClasses.DISABLED, disabled), ListItem_defineProperty(_classnames, listItemCssClasses.ONE_LINE, lines === 1), ListItem_defineProperty(_classnames, listItemCssClasses.TWO_LINES, lines === 2), ListItem_defineProperty(_classnames, listItemCssClasses.THREE_LINES, lines === 3), ListItem_defineProperty(_classnames, listItemCssClasses.NON_INTERACTIVE, nonInteractive), ListItem_defineProperty(_classnames, listItemCssClasses.OVERLINE, overlineText), ListItem_defineProperty(_classnames, listItemCssClasses.LEADING_ICON, withLeadingIcon), ListItem_defineProperty(_classnames, listItemCssClasses.LEADING_IMAGE, withLeadingImage), ListItem_defineProperty(_classnames, listItemCssClasses.LEADING_THUMBNAIL, withLeadingThumbnail), ListItem_defineProperty(_classnames, listItemCssClasses.LEADING_VIDEO, withLeadingVideo), ListItem_defineProperty(_classnames, listItemCssClasses.LEADING_CHECKBOX, withLeadingCheckbox), ListItem_defineProperty(_classnames, listItemCssClasses.LEADING_RADIO, withLeadingRadio), ListItem_defineProperty(_classnames, listItemCssClasses.LEADING_SWITCH, withLeadingSwitch), ListItem_defineProperty(_classnames, listItemCssClasses.TRAILING_ICON, withTrailingIcon), ListItem_defineProperty(_classnames, listItemCssClasses.TRAILING_META, withTrailingMeta), ListItem_defineProperty(_classnames, listItemCssClasses.TRAILING_CHECKBOX, withTrailingCheckbox), ListItem_defineProperty(_classnames, listItemCssClasses.TRAILING_RADIO, withTrailingRadio), ListItem_defineProperty(_classnames, listItemCssClasses.TRAILING_SWITCH, withTrailingSwitch), _classnames), className);\n  return /*#__PURE__*/(0,jsx_runtime.jsxs)(Element, ListItem_objectSpread(ListItem_objectSpread({\n    ref: ref,\n    className: classNames\n  }, props), {}, {\n    children: [/*#__PURE__*/(0,jsx_runtime.jsx)("span", {\n      className: listItemCssClasses.RIPPLE\n    }), hasStart && /*#__PURE__*/(0,jsx_runtime.jsxs)(list_ListItemStart, {\n      children: [start, leadingIcon && /*#__PURE__*/(0,jsx_runtime.jsx)(Clone, {\n        component: leadingIcon,\n        fallback: icon_Icon\n      }), leadingImage, leadingThumbnail, leadingVideo, leadingCheckbox, leadingRadio, leadingSwitch]\n    }), hasContent && /*#__PURE__*/(0,jsx_runtime.jsx)(list_ListItemContent, {\n      overlineText: overlineText,\n      primaryText: primaryText,\n      secondaryText: secondaryText,\n      children: content\n    }), hasEnd && /*#__PURE__*/(0,jsx_runtime.jsxs)(list_ListItemEnd, {\n      children: [end, trailingMeta, trailingIcon && /*#__PURE__*/(0,jsx_runtime.jsx)(Clone, {\n        component: trailingIcon,\n        fallback: icon_Icon\n      }), trailingCheckbox, trailingRadio, trailingSwitch]\n    }), children]\n  }));\n});\nListItem.displayName = \'MDCListItem\';\nListItem.propTypes = {\n  start: (prop_types_default()).node,\n  content: (prop_types_default()).node,\n  end: (prop_types_default()).node,\n  text: (prop_types_default()).node,\n  overlineText: (prop_types_default()).node,\n  primaryText: (prop_types_default()).node,\n  secondaryText: (prop_types_default()).node,\n  icon: (prop_types_default()).node,\n  image: (prop_types_default()).element,\n  thumbnail: (prop_types_default()).element,\n  video: (prop_types_default()).element,\n  leadingIcon: (prop_types_default()).node,\n  leadingImage: (prop_types_default()).element,\n  leadingThumbnail: (prop_types_default()).element,\n  leadingVideo: (prop_types_default()).element,\n  leadingCheckbox: (prop_types_default()).element,\n  leadingRadio: (prop_types_default()).element,\n  leadingSwitch: (prop_types_default()).element,\n  meta: (prop_types_default()).node,\n  trailingMeta: (prop_types_default()).node,\n  trailingIcon: (prop_types_default()).node,\n  trailingCheckbox: (prop_types_default()).element,\n  trailingRadio: (prop_types_default()).element,\n  trailingSwitch: (prop_types_default()).element,\n  activated: (prop_types_default()).bool,\n  selected: (prop_types_default()).bool,\n  disabled: (prop_types_default()).bool,\n  nonInteractive: (prop_types_default()).bool,\n  withLeadingIcon: (prop_types_default()).bool,\n  withLeadingImage: (prop_types_default()).bool,\n  withLeadingThumbnail: (prop_types_default()).bool,\n  withLeadingVideo: (prop_types_default()).bool,\n  withLeadingCheckbox: (prop_types_default()).bool,\n  withLeadingRadio: (prop_types_default()).bool,\n  withLeadingSwitch: (prop_types_default()).bool,\n  withTrailingMeta: (prop_types_default()).bool,\n  withTrailingIcon: (prop_types_default()).bool,\n  withTrailingCheckbox: (prop_types_default()).bool,\n  withTrailingRadio: (prop_types_default()).bool,\n  withTrailingSwitch: (prop_types_default()).bool\n};\n/* harmony default export */ const list_ListItem = (ListItem);\n;// CONCATENATED MODULE: ./src/list/List.jsx\nvar List_excluded = ["items", "element", "className", "children"];\n\nfunction List_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction List_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { List_ownKeys(Object(source), true).forEach(function (key) { List_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { List_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction List_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction List_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = List_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction List_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\n\n\n\nvar List = /*#__PURE__*/(0,react.forwardRef)(function (_ref, ref) {\n  var items = _ref.items,\n      _ref$element = _ref.element,\n      Element = _ref$element === void 0 ? \'ul\' : _ref$element,\n      className = _ref.className,\n      _ref$children = _ref.children,\n      children = _ref$children === void 0 ? items === null || items === void 0 ? void 0 : items.map(function (item) {\n    return (0,react.createElement)(list_ListItem, item);\n  }) : _ref$children,\n      props = List_objectWithoutProperties(_ref, List_excluded);\n\n  var classNames = classnames_default()(listCssClasses.ROOT, className);\n  return /*#__PURE__*/(0,jsx_runtime.jsx)(Element, List_objectSpread(List_objectSpread({\n    ref: ref,\n    className: classNames\n  }, props), {}, {\n    children: children\n  }));\n});\nList.displayName = \'MDCList\';\nlist_ListItem.propTypes = {\n  items: (prop_types_default()).array\n};\n/* harmony default export */ const list_List = (List);\n;// CONCATENATED MODULE: ./src/list/ListDivider.jsx\nvar ListDivider_excluded = ["withLeadingText", "withLeadingIcon", "withLeadingImage", "withLeadingThumbnail", "withLeadingVideo", "withLeadingCheckbox", "withLeadingRadio", "withLeadingSwitch", "element", "className"];\n\nfunction ListDivider_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction ListDivider_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ListDivider_ownKeys(Object(source), true).forEach(function (key) { ListDivider_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ListDivider_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction ListDivider_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction ListDivider_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = ListDivider_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction ListDivider_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\n\nvar ListDivider = /*#__PURE__*/(0,react.forwardRef)(function (_ref, ref) {\n  var _classnames;\n\n  var _ref$withLeadingText = _ref.withLeadingText,\n      withLeadingText = _ref$withLeadingText === void 0 ? false : _ref$withLeadingText,\n      _ref$withLeadingIcon = _ref.withLeadingIcon,\n      withLeadingIcon = _ref$withLeadingIcon === void 0 ? false : _ref$withLeadingIcon,\n      _ref$withLeadingImage = _ref.withLeadingImage,\n      withLeadingImage = _ref$withLeadingImage === void 0 ? false : _ref$withLeadingImage,\n      _ref$withLeadingThumb = _ref.withLeadingThumbnail,\n      withLeadingThumbnail = _ref$withLeadingThumb === void 0 ? false : _ref$withLeadingThumb,\n      _ref$withLeadingVideo = _ref.withLeadingVideo,\n      withLeadingVideo = _ref$withLeadingVideo === void 0 ? false : _ref$withLeadingVideo,\n      _ref$withLeadingCheck = _ref.withLeadingCheckbox,\n      withLeadingCheckbox = _ref$withLeadingCheck === void 0 ? false : _ref$withLeadingCheck,\n      _ref$withLeadingRadio = _ref.withLeadingRadio,\n      withLeadingRadio = _ref$withLeadingRadio === void 0 ? false : _ref$withLeadingRadio,\n      _ref$withLeadingSwitc = _ref.withLeadingSwitch,\n      withLeadingSwitch = _ref$withLeadingSwitc === void 0 ? false : _ref$withLeadingSwitc,\n      _ref$element = _ref.element,\n      Element = _ref$element === void 0 ? \'li\' : _ref$element,\n      className = _ref.className,\n      props = ListDivider_objectWithoutProperties(_ref, ListDivider_excluded);\n\n  var classNames = classnames_default()(listDividerCssClasses.ROOT, (_classnames = {}, ListDivider_defineProperty(_classnames, listDividerCssClasses.LEADING_TEXT, withLeadingText), ListDivider_defineProperty(_classnames, listDividerCssClasses.LEADING_ICON, withLeadingIcon), ListDivider_defineProperty(_classnames, listDividerCssClasses.LEADING_IMAGE, withLeadingImage), ListDivider_defineProperty(_classnames, listDividerCssClasses.LEADING_THUMBNAIL, withLeadingThumbnail), ListDivider_defineProperty(_classnames, listDividerCssClasses.LEADING_VIDEO, withLeadingVideo), ListDivider_defineProperty(_classnames, listDividerCssClasses.LEADING_CHECKBOX, withLeadingCheckbox), ListDivider_defineProperty(_classnames, listDividerCssClasses.LEADING_RADIO, withLeadingRadio), ListDivider_defineProperty(_classnames, listDividerCssClasses.LEADING_SWITCH, withLeadingSwitch), _classnames), className);\n  return /*#__PURE__*/(0,jsx_runtime.jsx)(Element, ListDivider_objectSpread({\n    ref: ref,\n    className: classNames,\n    role: Element === \'li\' ? \'separator\' : undefined\n  }, props));\n});\nListDivider.displayName = \'MDCListDivider\';\nListDivider.propTypes = {\n  withLeadingText: (prop_types_default()).bool,\n  withLeadingIcon: (prop_types_default()).bool,\n  withLeadingImage: (prop_types_default()).bool,\n  withLeadingThumbnail: (prop_types_default()).bool,\n  withLeadingVideo: (prop_types_default()).bool,\n  withLeadingAvatar: (prop_types_default()).bool,\n  withLeadingCheckbox: (prop_types_default()).bool,\n  withLeadingSwitch: (prop_types_default()).bool,\n  withLeadingRadio: (prop_types_default()).bool\n};\n/* harmony default export */ const list_ListDivider = (ListDivider);\n;// CONCATENATED MODULE: ./src/list/ListGroup.jsx\nvar ListGroup_excluded = ["element", "className"];\n\nfunction ListGroup_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction ListGroup_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ListGroup_ownKeys(Object(source), true).forEach(function (key) { ListGroup_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ListGroup_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction ListGroup_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction ListGroup_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = ListGroup_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction ListGroup_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\nvar ListGroup = /*#__PURE__*/(0,react.forwardRef)(function (_ref, ref) {\n  var _ref$element = _ref.element,\n      Element = _ref$element === void 0 ? \'div\' : _ref$element,\n      className = _ref.className,\n      props = ListGroup_objectWithoutProperties(_ref, ListGroup_excluded);\n\n  var classNames = classnames_default()(listGroupCssClasses.ROOT, className);\n  return /*#__PURE__*/(0,jsx_runtime.jsx)(Element, ListGroup_objectSpread({\n    ref: ref,\n    className: classNames\n  }, props));\n});\nListGroup.displayName = \'MDCListGroup\';\n/* harmony default export */ const list_ListGroup = (ListGroup);\n;// CONCATENATED MODULE: ./src/list/ListGroupSubheader.jsx\nvar ListGroupSubheader_excluded = ["title", "element", "className", "children"];\n\nfunction ListGroupSubheader_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction ListGroupSubheader_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ListGroupSubheader_ownKeys(Object(source), true).forEach(function (key) { ListGroupSubheader_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ListGroupSubheader_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction ListGroupSubheader_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction ListGroupSubheader_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = ListGroupSubheader_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction ListGroupSubheader_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\n\nvar ListGroupSubheader = /*#__PURE__*/(0,react.forwardRef)(function (_ref, ref) {\n  var title = _ref.title,\n      _ref$element = _ref.element,\n      Element = _ref$element === void 0 ? \'h3\' : _ref$element,\n      className = _ref.className,\n      _ref$children = _ref.children,\n      children = _ref$children === void 0 ? title : _ref$children,\n      props = ListGroupSubheader_objectWithoutProperties(_ref, ListGroupSubheader_excluded);\n\n  var classNames = classnames_default()(listGroupCssClasses.SUBHEADER, className);\n  return /*#__PURE__*/(0,jsx_runtime.jsx)(Element, ListGroupSubheader_objectSpread(ListGroupSubheader_objectSpread({\n    ref: ref,\n    className: classNames\n  }, props), {}, {\n    children: children\n  }));\n});\nListGroupSubheader.displayName = \'MDCListGroupSubheader\';\nListGroupSubheader.propTypes = {\n  title: (prop_types_default()).string\n};\n/* harmony default export */ const list_ListGroupSubheader = (ListGroupSubheader);\n;// CONCATENATED MODULE: ./src/list/index.js\n\n\n\n\n\n\n\n\nlist_List.Item = list_ListItem;\nlist_List.Divider = list_ListDivider;\nlist_List.Group = list_ListGroup;\nlist_ListGroup.Subheader = list_ListGroupSubheader;\nlist_ListItem.Content = list_ListItemContent;\nlist_ListItem.End = list_ListItemEnd;\nlist_ListItem.Start = list_ListItemStart;\n\n;// CONCATENATED MODULE: ./src/menu/MenuItem.jsx\nvar MenuItem_excluded = ["selected", "disabled", "className"];\n\nfunction MenuItem_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction MenuItem_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { MenuItem_ownKeys(Object(source), true).forEach(function (key) { MenuItem_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { MenuItem_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction MenuItem_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction MenuItem_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = MenuItem_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction MenuItem_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\n\nvar MenuItem = /*#__PURE__*/(0,react.forwardRef)(function (_ref, ref) {\n  var _ref$selected = _ref.selected,\n      selected = _ref$selected === void 0 ? false : _ref$selected,\n      _ref$disabled = _ref.disabled,\n      disabled = _ref$disabled === void 0 ? false : _ref$disabled,\n      className = _ref.className,\n      props = MenuItem_objectWithoutProperties(_ref, MenuItem_excluded);\n\n  var classNames = classnames_default()(menu_constants_cssClasses.ITEM, MenuItem_defineProperty({}, menu_constants_cssClasses.ITEM_SELECTED, selected), className);\n  return /*#__PURE__*/(0,jsx_runtime.jsx)(list_ListItem, MenuItem_objectSpread({\n    ref: ref,\n    role: "menuitem",\n    className: classNames,\n    selected: selected,\n    disabled: disabled,\n    "data-disabled": disabled || undefined,\n    tabIndex: disabled ? \'-1\' : undefined\n  }, props));\n});\nMenuItem.displayName = \'MDCMenuItem\';\nMenuItem.propTypes = MenuItem_objectSpread({}, list_ListItem.propTypes);\n/* harmony default export */ const menu_MenuItem = (MenuItem);\n;// CONCATENATED MODULE: ./src/modal/constants.js\nvar modal_constants_cssClasses = {\n  ROOT: \'mdc-modal\',\n  FIXED: \'mdc-modal--fixed\'\n};\n;// CONCATENATED MODULE: ./src/modal/Modal.jsx\n\n\n\n\nfunction Modal(_ref) {\n  var _ref$fixed = _ref.fixed,\n      fixed = _ref$fixed === void 0 ? false : _ref$fixed,\n      _ref$element = _ref.element,\n      element = _ref$element === void 0 ? \'div\' : _ref$element,\n      children = _ref.children;\n  var rootRef = (0,react.useRef)(document.createElement(element));\n  (0,react.useEffect)(function () {\n    var root = rootRef.current;\n    var activeElement = document.activeElement;\n    root.className = modal_constants_cssClasses.ROOT;\n\n    if (fixed) {\n      root.classList.add(modal_constants_cssClasses.FIXED);\n    }\n\n    document.body.appendChild(root);\n    root.firstChild.focus();\n    return function () {\n      activeElement.focus();\n      document.body.removeChild(root);\n    };\n  }, [fixed]);\n  return /*#__PURE__*/(0,react_dom.createPortal)(children, rootRef.current);\n}\nModal.displayName = \'MDCModal\';\nModal.propTypes = {\n  fixed: (prop_types_default()).bool,\n  element: (prop_types_default()).string,\n  children: (prop_types_default()).node.isRequired\n};\n;// CONCATENATED MODULE: ./src/modal/index.js\n\n;// CONCATENATED MODULE: ./src/layer/Layer.jsx\nvar Layer_excluded = ["modal", "fixed", "children"];\n\nfunction Layer_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction Layer_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { Layer_ownKeys(Object(source), true).forEach(function (key) { Layer_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { Layer_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction Layer_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction Layer_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = Layer_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction Layer_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\nfunction Layer(_ref) {\n  var _ref$modal = _ref.modal,\n      modal = _ref$modal === void 0 ? false : _ref$modal,\n      _ref$fixed = _ref.fixed,\n      fixed = _ref$fixed === void 0 ? false : _ref$fixed,\n      children = _ref.children,\n      props = Layer_objectWithoutProperties(_ref, Layer_excluded);\n\n  return /*#__PURE__*/(0,jsx_runtime.jsx)(esm_CSSTransition, Layer_objectSpread(Layer_objectSpread({}, props), {}, {\n    children: modal ? /*#__PURE__*/(0,jsx_runtime.jsx)(Modal, {\n      fixed: fixed,\n      children: children\n    }) : children\n  }));\n}\nLayer.displayName = \'MDCLayer\';\nLayer.propTypes = {\n  modal: (prop_types_default()).bool,\n  fixed: (prop_types_default()).bool\n};\n;// CONCATENATED MODULE: ./src/layer/index.js\n\n;// CONCATENATED MODULE: ./src/menu/utils.js\nfunction utils_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { utils_typeof = function _typeof(obj) { return typeof obj; }; } else { utils_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return utils_typeof(obj); }\n\nvar defaultValues = {\n  top: false,\n  bottom: false,\n  center: false,\n  left: false,\n  right: false\n};\nfunction getAnchorOrigin() {\n  var anchorOrigin = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \'\';\n\n  if (utils_typeof(anchorOrigin) === \'object\') {\n    return Object.assign({}, defaultValues, anchorOrigin);\n  }\n\n  var keys = anchorOrigin.split(\' \');\n  var values = keys.reduce(function (result, key) {\n    result[key] = true;\n    return result;\n  }, {});\n  return Object.assign({}, defaultValues, values);\n}\n;// CONCATENATED MODULE: ./src/menu/MenuSurface.jsx\nvar MenuSurface_excluded = ["anchor", "anchorRef", "anchorOrigin", "transformOrigin", "open", "modal", "quick", "fixed", "persistent", "fullWidth", "onClose", "onKeyDown", "className"];\n\nfunction MenuSurface_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction MenuSurface_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { MenuSurface_ownKeys(Object(source), true).forEach(function (key) { MenuSurface_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { MenuSurface_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction MenuSurface_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction MenuSurface_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = MenuSurface_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction MenuSurface_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\n\n\n\n\n\n\n\nvar MenuSurface = /*#__PURE__*/(0,react.forwardRef)(function (_ref, ref) {\n  var _classnames;\n\n  var anchor = _ref.anchor,\n      _anchorRef = _ref.anchorRef,\n      _ref$anchorOrigin = _ref.anchorOrigin,\n      _anchorOrigin = _ref$anchorOrigin === void 0 ? Origin.TOP_LEFT : _ref$anchorOrigin,\n      _ref$transformOrigin = _ref.transformOrigin,\n      _transformOrigin = _ref$transformOrigin === void 0 ? _anchorOrigin : _ref$transformOrigin,\n      _ref$open = _ref.open,\n      open = _ref$open === void 0 ? false : _ref$open,\n      _ref$modal = _ref.modal,\n      modal = _ref$modal === void 0 ? false : _ref$modal,\n      _ref$quick = _ref.quick,\n      quick = _ref$quick === void 0 ? false : _ref$quick,\n      _ref$fixed = _ref.fixed,\n      fixed = _ref$fixed === void 0 ? false : _ref$fixed,\n      _ref$persistent = _ref.persistent,\n      persistent = _ref$persistent === void 0 ? false : _ref$persistent,\n      _ref$fullWidth = _ref.fullWidth,\n      fullWidth = _ref$fullWidth === void 0 ? false : _ref$fullWidth,\n      _ref$onClose = _ref.onClose,\n      onClose = _ref$onClose === void 0 ? Function.prototype : _ref$onClose,\n      _ref$onKeyDown = _ref.onKeyDown,\n      onKeyDown = _ref$onKeyDown === void 0 ? Function.prototype : _ref$onKeyDown,\n      className = _ref.className,\n      props = MenuSurface_objectWithoutProperties(_ref, MenuSurface_excluded);\n\n  var rootRef = (0,react.useRef)();\n  var anchorRef = (0,react.useRef)(_anchorRef === null || _anchorRef === void 0 ? void 0 : _anchorRef.current);\n  (0,react.useImperativeHandle)(ref, function () {\n    return rootRef.current;\n  });\n  (0,react.useEffect)(function () {\n    if (!_anchorRef) return;\n    anchorRef.current = _anchorRef.current;\n  }, [_anchorRef]);\n  useUpdated(function () {\n    if (!open || persistent) return;\n\n    function handleBodyClick(event) {\n      onClose(event);\n    }\n\n    document.body.addEventListener(\'click\', handleBodyClick, true);\n    return function () {\n      document.body.removeEventListener(\'click\', handleBodyClick, true);\n    };\n  }, [open, persistent, onClose]);\n  useUpdated(function () {\n    if (!open || !rootRef.current || !anchorRef.current) return;\n    var anchor = anchorRef.current;\n    var _rootRef$current = rootRef.current,\n        width = _rootRef$current.clientWidth,\n        height = _rootRef$current.clientHeight;\n    var anchorClientRect = anchor.getBoundingClientRect();\n    var anchorDimensions = modal ? anchorClientRect : {\n      top: anchor.offsetTop,\n      left: anchor.offsetLeft,\n      bottom: anchor.offsetTop + anchor.offsetHeight,\n      right: anchor.offsetLeft + anchor.offsetWidth,\n      width: anchor.offsetWidth,\n      height: anchor.offsetHeight\n    };\n    var style = {\n      top: 0,\n      left: 0,\n      width: fullWidth ? \'100%\' : undefined,\n      maxWidth: fullWidth ? "".concat(anchorDimensions.width, "px") : undefined,\n      position: fixed ? \'fixed\' : \'absolute\',\n      transformOrigin: _transformOrigin\n    };\n    var scrollY = modal ? window.scrollY : 0;\n    var scrollX = modal ? window.scrollX : 0;\n    var anchorOrigin = getAnchorOrigin(_anchorOrigin);\n    var transformOrigin = getAnchorOrigin(_transformOrigin);\n\n    if (anchorOrigin.top) {\n      style.top = anchorDimensions.top;\n    } else if (anchorOrigin.bottom) {\n      style.top = anchorDimensions.bottom;\n    }\n\n    if (anchorOrigin.left) {\n      style.left = anchorDimensions.left;\n    } else if (anchorOrigin.right) {\n      style.left = anchorDimensions.right;\n    }\n\n    if (transformOrigin.top) {\n      var top = scrollY + style.top;\n      var bottomOverflow = scrollY + (anchorOrigin.bottom ? anchorClientRect.bottom : anchorClientRect.top) + height - window.innerHeight;\n      style.top = "".concat(bottomOverflow > 0 ? top - bottomOverflow : top, "px");\n    } else if (transformOrigin.bottom) {\n      var _top = scrollY + style.top - height;\n\n      var topOverflow = scrollY + (anchorOrigin.bottom ? anchorClientRect.bottom : anchorClientRect.top) - height;\n      style.top = "".concat(topOverflow > 0 ? _top : 0, "px");\n    }\n\n    if (transformOrigin.left) {\n      var left = style.left;\n      var rightOverflow = window.innerWidth - (anchorOrigin.left ? anchorClientRect.left : anchorClientRect.right) + width;\n      style.left = "".concat(rightOverflow > 0 ? left : left - Math.abs(rightOverflow), "px");\n    } else if (transformOrigin.right) {\n      var _left = style.left - width;\n\n      var leftOverflow = (anchorOrigin.right ? anchorClientRect.right : anchorClientRect.left) - width;\n      style.left = "".concat(leftOverflow > 0 ? _left : 0, "px");\n    }\n\n    rootRef.current.style.top = style.top;\n    rootRef.current.style.left = style.left;\n    rootRef.current.style.position = style.position;\n    rootRef.current.style.width = style.width;\n    rootRef.current.style.maxWidth = style.maxWidth;\n    rootRef.current.style.transformOrigin = style.transformOrigin;\n  }, [open, modal, _anchorOrigin, _transformOrigin]);\n  var handleKeyDown = (0,react.useCallback)(function (event) {\n    if (event.key === \'Escape\' && !persistent) {\n      event.stopPropagation();\n      onClose(event);\n    }\n\n    onKeyDown(event);\n  }, [persistent, onKeyDown, onClose]);\n\n  var isBelowAnchor = _anchorOrigin.includes(\'bottom\') && _transformOrigin.includes(\'top\');\n\n  var classNames = classnames_default()(menu_constants_cssClasses.SURFACE, (_classnames = {}, MenuSurface_defineProperty(_classnames, menu_constants_cssClasses.SURFACE_FIXED, fixed), MenuSurface_defineProperty(_classnames, menu_constants_cssClasses.SURFACE_BELOW_ANCHOR, isBelowAnchor), _classnames), className);\n  return /*#__PURE__*/(0,jsx_runtime.jsxs)(jsx_runtime.Fragment, {\n    children: [anchor && (0,react.cloneElement)(anchor, {\n      ref: anchorRef\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Layer, {\n      "in": open,\n      modal: modal,\n      timeout: quick ? 0 : {\n        enter: menu_constants_numbers.TRANSITION_OPEN_DURATION,\n        exit: menu_constants_numbers.TRANSITION_CLOSE_DURATION\n      },\n      classNames: quick ? {\n        enterDone: menu_constants_cssClasses.SURFACE_OPEN\n      } : {\n        enter: menu_constants_cssClasses.SURFACE_ANIMATING_OPEN,\n        enterActive: menu_constants_cssClasses.SURFACE_ANIMATING_OPEN,\n        enterDone: menu_constants_cssClasses.SURFACE_OPEN,\n        exit: menu_constants_cssClasses.SURFACE_OPEN,\n        exitActive: menu_constants_cssClasses.SURFACE_ANIMATING_CLOSED\n      },\n      mountOnEnter: true,\n      unmountOnExit: true,\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)("div", MenuSurface_objectSpread({\n        ref: rootRef,\n        className: classNames,\n        onKeyDown: handleKeyDown\n      }, props))\n    })]\n  });\n});\nMenuSurface.displayName = \'MDCMenuSurface\';\nMenuSurface.propTypes = {\n  anchor: (prop_types_default()).element,\n  anchorRef: (prop_types_default()).object,\n  anchorOrigin: prop_types_default().oneOf(Object.values(Origin)),\n  open: (prop_types_default()).bool,\n  modal: (prop_types_default()).bool,\n  quick: (prop_types_default()).bool,\n  fixed: (prop_types_default()).bool,\n  persistent: (prop_types_default()).bool,\n  fullWidth: (prop_types_default()).bool,\n  onClose: (prop_types_default()).func\n};\n/* harmony default export */ const menu_MenuSurface = (MenuSurface);\n;// CONCATENATED MODULE: ./src/menu/Menu.jsx\nvar Menu_excluded = ["open", "items", "listProps", "children", "className"];\n\nfunction Menu_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction Menu_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { Menu_ownKeys(Object(source), true).forEach(function (key) { Menu_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { Menu_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction Menu_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction Menu_slicedToArray(arr, i) { return Menu_arrayWithHoles(arr) || Menu_iterableToArrayLimit(arr, i) || Menu_unsupportedIterableToArray(arr, i) || Menu_nonIterableRest(); }\n\nfunction Menu_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction Menu_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return Menu_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return Menu_arrayLikeToArray(o, minLen); }\n\nfunction Menu_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction Menu_iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction Menu_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction Menu_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = Menu_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction Menu_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\n\n\n\n\n\n\nvar Menu = /*#__PURE__*/(0,react.forwardRef)(function (_ref, ref) {\n  var open = _ref.open,\n      items = _ref.items,\n      _ref$listProps = _ref.listProps,\n      listProps = _ref$listProps === void 0 ? {} : _ref$listProps,\n      _ref$children = _ref.children,\n      children = _ref$children === void 0 ? items === null || items === void 0 ? void 0 : items.map(function (item) {\n    return (0,react.createElement)(menu_MenuItem, item);\n  }) : _ref$children,\n      className = _ref.className,\n      props = Menu_objectWithoutProperties(_ref, Menu_excluded);\n\n  var listRef = (0,react.useRef)();\n\n  var _useState = (0,react.useState)(0),\n      _useState2 = Menu_slicedToArray(_useState, 2),\n      focusedChildIndex = _useState2[0],\n      setFocusedChildIndex = _useState2[1];\n\n  (0,react.useEffect)(function () {\n    if (open) {\n      setFocusedChildIndex(react.Children.toArray(children).findIndex(function (i) {\n        return i.props.selected;\n      }));\n    }\n  }, [open, children]);\n  useUpdated(function () {\n    if (open) {\n      var _listRef$current$chil;\n\n      (_listRef$current$chil = listRef.current.children[focusedChildIndex]) === null || _listRef$current$chil === void 0 ? void 0 : _listRef$current$chil.focus();\n    }\n  }, [focusedChildIndex, open]);\n  var handleKeyDown = (0,react.useCallback)(function (event) {\n    event.preventDefault();\n\n    if (event.key === \'ArrowDown\') {\n      setFocusedChildIndex(function (index) {\n        var nextIndex = index + 1;\n        return nextIndex < listRef.current.children.length ? nextIndex : index;\n      });\n    } else if (event.key === \'ArrowUp\') {\n      setFocusedChildIndex(function (index) {\n        var nextIndex = index - 1;\n        return nextIndex >= 0 ? nextIndex : index;\n      });\n    }\n  }, []);\n  var classNames = classnames_default()(menu_constants_cssClasses.ROOT, className);\n  return /*#__PURE__*/(0,jsx_runtime.jsx)(menu_MenuSurface, Menu_objectSpread(Menu_objectSpread({\n    ref: ref,\n    open: open,\n    className: classNames,\n    onKeyDown: handleKeyDown\n  }, props), {}, {\n    children: /*#__PURE__*/(0,jsx_runtime.jsx)(list_List, Menu_objectSpread(Menu_objectSpread({\n      ref: listRef,\n      role: "menu",\n      "aria-hidden": "true",\n      "aria-orientation": "vertical",\n      tabIndex: open ? 0 : -1\n    }, listProps), {}, {\n      children: react.Children.map(children, function (item, index) {\n        return /*#__PURE__*/(0,jsx_runtime.jsx)(Clone, {\n          component: item,\n          tabIndex: index === focusedChildIndex ? 0 : -1\n        });\n      })\n    }))\n  }));\n});\nMenu.displayName = \'MDCMenu\';\nMenu.propTypes = Menu_objectSpread(Menu_objectSpread({}, menu_MenuSurface.propTypes), {}, {\n  listProps: (prop_types_default()).object\n});\n/* harmony default export */ const menu_Menu = (Menu);\n;// CONCATENATED MODULE: ./src/menu/MenuAnchor.jsx\nvar MenuAnchor_excluded = ["wrap", "element", "className", "children"];\n\nfunction MenuAnchor_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction MenuAnchor_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { MenuAnchor_ownKeys(Object(source), true).forEach(function (key) { MenuAnchor_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { MenuAnchor_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction MenuAnchor_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction MenuAnchor_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = MenuAnchor_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction MenuAnchor_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\nvar MenuAnchor = /*#__PURE__*/(0,react.forwardRef)(function (_ref, ref) {\n  var _ref$wrap = _ref.wrap,\n      wrap = _ref$wrap === void 0 ? true : _ref$wrap,\n      _ref$element = _ref.element,\n      element = _ref$element === void 0 ? \'div\' : _ref$element,\n      className = _ref.className,\n      children = _ref.children,\n      props = MenuAnchor_objectWithoutProperties(_ref, MenuAnchor_excluded);\n\n  return wrap ? (0,react.createElement)(element, MenuAnchor_objectSpread({\n    ref: ref,\n    className: classnames_default()(menu_constants_cssClasses.SURFACE_ANCHOR, className)\n  }, props), children) : (0,react.cloneElement)(children, MenuAnchor_objectSpread({\n    ref: ref,\n    className: classnames_default()(children.props.className, menu_constants_cssClasses.SURFACE_ANCHOR)\n  }, props));\n});\nMenuAnchor.displayName = \'MDCMenuAnchor\';\n/* harmony default export */ const menu_MenuAnchor = (MenuAnchor);\n;// CONCATENATED MODULE: ./src/menu/MenuSelectionGroup.jsx\nvar MenuSelectionGroup_excluded = ["element"];\n\nfunction MenuSelectionGroup_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction MenuSelectionGroup_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { MenuSelectionGroup_ownKeys(Object(source), true).forEach(function (key) { MenuSelectionGroup_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { MenuSelectionGroup_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction MenuSelectionGroup_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction MenuSelectionGroup_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = MenuSelectionGroup_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction MenuSelectionGroup_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\nvar MenuSelectionGroup = /*#__PURE__*/(0,react.forwardRef)(function (_ref, ref) {\n  var _ref$element = _ref.element,\n      Element = _ref$element === void 0 ? \'ul\' : _ref$element,\n      props = MenuSelectionGroup_objectWithoutProperties(_ref, MenuSelectionGroup_excluded);\n\n  return /*#__PURE__*/(0,jsx_runtime.jsx)("li", {\n    ref: ref,\n    children: /*#__PURE__*/(0,jsx_runtime.jsx)(Element, MenuSelectionGroup_objectSpread({\n      className: "mdc-menu__selection-group"\n    }, props))\n  });\n});\nMenuSelectionGroup.displayName = \'MDCMenuSelectionGroup\';\n/* harmony default export */ const menu_MenuSelectionGroup = (MenuSelectionGroup);\n;// CONCATENATED MODULE: ./src/menu/MenuSelectionGroupIcon.jsx\nfunction MenuSelectionGroupIcon_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction MenuSelectionGroupIcon_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { MenuSelectionGroupIcon_ownKeys(Object(source), true).forEach(function (key) { MenuSelectionGroupIcon_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { MenuSelectionGroupIcon_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction MenuSelectionGroupIcon_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n\n\nfunction MenuSelectionGroupIcon(props) {\n  return /*#__PURE__*/(0,jsx_runtime.jsx)(icon_Icon, MenuSelectionGroupIcon_objectSpread({\n    className: "mdc-menu__selection-group-icon"\n  }, props));\n}\nMenuSelectionGroupIcon.displayName = \'MDCMenuSelectionGroupIcon\';\n;// CONCATENATED MODULE: ./src/menu/index.js\n\n\n\n\n\n\n\nmenu_Menu.Anchor = menu_MenuAnchor;\nmenu_Menu.Item = menu_MenuItem;\nmenu_Menu.Origin = Origin;\nmenu_Menu.Surface = menu_MenuSurface;\nmenu_Menu.SelectionGroup = menu_MenuSelectionGroup;\nmenu_Menu.SelectionGroupIcon = MenuSelectionGroupIcon;\n\n;// CONCATENATED MODULE: ./src/select/constants.js\nvar select_constants_cssClasses = {\n  ROOT: \'mdc-select\',\n  FILLED: \'mdc-select--filled\',\n  OUTLINED: \'mdc-select--outlined\',\n  ACTIVATED: \'mdc-select--activated\',\n  DISABLED: \'mdc-select--disabled\',\n  FOCUSED: \'mdc-select--focused\',\n  REQUIRED: \'mdc-select--required\',\n  INVALID: \'mdc-select--invalid\',\n  NO_LABEL: \'mdc-select--no-label\',\n  WITH_LEADING_ICON: \'mdc-select--with-leading-icon\',\n  SELECTED_TEXT: \'mdc-select__selected-text\',\n  SELECTED_TEXT_CONTAINER: \'mdc-select__selected-text-container\',\n  DROPDOWN_ICON: \'mdc-select__dropdown-icon\',\n  DROPDOWN_ICON_GRAPHIC: \'mdc-select__dropdown-icon-graphic\',\n  DROPDOWN_ICON_INACTIVE: \'mdc-select__dropdown-icon-inactive\',\n  DROPDOWN_ICON_ACTIVE: \'mdc-select__dropdown-icon-active\',\n  ICON: \'mdc-select__icon\',\n  MENU: \'mdc-select__menu\',\n  MENU_INVALID: \'mdc-select__menu--invalid\',\n  RIPPLE: \'mdc-select__ripple\',\n  ANCHOR: \'mdc-select__anchor\',\n  HELPER_TEXT: \'mdc-select-helper-text\',\n  VALIDATION_MESSAGE: \'mdc-select-helper-text--validation-msg\',\n  VALIDATION_MESSAGE_PERSISTENT: \'mdc-select-helper-text--validation-msg-persistent\'\n};\n;// CONCATENATED MODULE: ./src/select/DropdownIcon.jsx\n\n\n\n\nvar DropdownIcon = function DropdownIcon() {\n  return /*#__PURE__*/(0,jsx_runtime.jsx)("span", {\n    className: select_constants_cssClasses.DROPDOWN_ICON,\n    children: /*#__PURE__*/(0,jsx_runtime.jsxs)("svg", {\n      className: select_constants_cssClasses.DROPDOWN_ICON_GRAPHIC,\n      viewBox: "7 10 10 5",\n      focusable: "false",\n      children: [/*#__PURE__*/(0,jsx_runtime.jsx)("polygon", {\n        className: select_constants_cssClasses.DROPDOWN_ICON_INACTIVE,\n        stroke: "none",\n        fillRule: "evenodd",\n        points: "7 10 12 15 17 10"\n      }), /*#__PURE__*/(0,jsx_runtime.jsx)("polygon", {\n        className: select_constants_cssClasses.DROPDOWN_ICON_ACTIVE,\n        stroke: "none",\n        fillRule: "evenodd",\n        points: "7 15 12 10 17 15"\n      })]\n    })\n  });\n};\n\n/* harmony default export */ const select_DropdownIcon = (DropdownIcon);\n;// CONCATENATED MODULE: ./src/select/SelectOption.jsx\nvar SelectOption_excluded = ["selected", "checkbox", "onClick"];\n\nfunction SelectOption_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction SelectOption_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { SelectOption_ownKeys(Object(source), true).forEach(function (key) { SelectOption_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { SelectOption_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction SelectOption_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction SelectOption_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = SelectOption_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction SelectOption_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\nvar SelectOption = /*#__PURE__*/(0,react.forwardRef)(function (_ref, ref) {\n  var selected = _ref.selected,\n      _ref$checkbox = _ref.checkbox,\n      checkbox = _ref$checkbox === void 0 ? false : _ref$checkbox,\n      onClick = _ref.onClick,\n      props = SelectOption_objectWithoutProperties(_ref, SelectOption_excluded);\n\n  return /*#__PURE__*/(0,jsx_runtime.jsx)(menu_MenuItem, SelectOption_objectSpread({\n    ref: ref,\n    start: checkbox && /*#__PURE__*/(0,jsx_runtime.jsx)(checkbox_Checkbox, {\n      checked: selected\n    }),\n    selected: selected,\n    withLeadingCheckbox: checkbox,\n    onClick: onClick\n  }, props));\n});\nSelectOption.displayName = \'MDCSelectOption\';\n/* harmony default export */ const select_SelectOption = (SelectOption);\n;// CONCATENATED MODULE: ./src/select/HelperText.jsx\nvar HelperText_excluded = ["validation", "persistent", "element"];\n\nfunction HelperText_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction HelperText_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { HelperText_ownKeys(Object(source), true).forEach(function (key) { HelperText_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { HelperText_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction HelperText_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction HelperText_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = HelperText_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction HelperText_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\n\nvar HelperText = function HelperText(_ref) {\n  var _classnames;\n\n  var _ref$validation = _ref.validation,\n      validation = _ref$validation === void 0 ? false : _ref$validation,\n      _ref$persistent = _ref.persistent,\n      persistent = _ref$persistent === void 0 ? false : _ref$persistent,\n      _ref$element = _ref.element,\n      Element = _ref$element === void 0 ? \'p\' : _ref$element,\n      props = HelperText_objectWithoutProperties(_ref, HelperText_excluded);\n\n  var classNames = classnames_default()(select_constants_cssClasses.HELPER_TEXT, (_classnames = {}, HelperText_defineProperty(_classnames, select_constants_cssClasses.VALIDATION_MESSAGE, validation), HelperText_defineProperty(_classnames, select_constants_cssClasses.VALIDATION_MESSAGE_PERSISTENT, persistent), _classnames));\n  return /*#__PURE__*/(0,jsx_runtime.jsx)(Element, HelperText_objectSpread({\n    className: classNames\n  }, props));\n};\n\nHelperText.displayName = \'MDCSelectHelperText\';\nHelperText.propTypes = {\n  persistent: (prop_types_default()).bool,\n  validation: (prop_types_default()).bool\n};\n/* harmony default export */ const select_HelperText = (HelperText);\n;// CONCATENATED MODULE: ./src/select/Select.jsx\nvar Select_excluded = ["name", "value", "options", "label", "icon", "leadingIcon", "helperText", "filled", "outlined", "multiple", "disabled", "required", "onChange", "menuProps", "listProps", "helperTextProps", "className", "children"];\n\nfunction Select_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction Select_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { Select_ownKeys(Object(source), true).forEach(function (key) { Select_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { Select_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction Select_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || Select_unsupportedIterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return Select_arrayLikeToArray(arr); }\n\nfunction Select_slicedToArray(arr, i) { return Select_arrayWithHoles(arr) || Select_iterableToArrayLimit(arr, i) || Select_unsupportedIterableToArray(arr, i) || Select_nonIterableRest(); }\n\nfunction Select_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction Select_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return Select_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return Select_arrayLikeToArray(o, minLen); }\n\nfunction Select_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction Select_iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction Select_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction Select_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = Select_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction Select_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nvar Select = /*#__PURE__*/(0,react.forwardRef)(function (_ref, ref) {\n  var _classnames;\n\n  var name = _ref.name,\n      value = _ref.value,\n      options = _ref.options,\n      label = _ref.label,\n      icon = _ref.icon,\n      _ref$leadingIcon = _ref.leadingIcon,\n      leadingIcon = _ref$leadingIcon === void 0 ? icon : _ref$leadingIcon,\n      helperText = _ref.helperText,\n      _ref$filled = _ref.filled,\n      filled = _ref$filled === void 0 ? false : _ref$filled,\n      _ref$outlined = _ref.outlined,\n      outlined = _ref$outlined === void 0 ? false : _ref$outlined,\n      _ref$multiple = _ref.multiple,\n      multiple = _ref$multiple === void 0 ? isArray(value) : _ref$multiple,\n      _ref$disabled = _ref.disabled,\n      disabled = _ref$disabled === void 0 ? false : _ref$disabled,\n      _ref$required = _ref.required,\n      required = _ref$required === void 0 ? false : _ref$required,\n      _ref$onChange = _ref.onChange,\n      onChange = _ref$onChange === void 0 ? Function.prototype : _ref$onChange,\n      _ref$menuProps = _ref.menuProps,\n      menuProps = _ref$menuProps === void 0 ? {} : _ref$menuProps,\n      _ref$listProps = _ref.listProps,\n      listProps = _ref$listProps === void 0 ? {} : _ref$listProps,\n      _ref$helperTextProps = _ref.helperTextProps,\n      helperTextProps = _ref$helperTextProps === void 0 ? {} : _ref$helperTextProps,\n      className = _ref.className,\n      _ref$children = _ref.children,\n      children = _ref$children === void 0 ? options === null || options === void 0 ? void 0 : options.map(function (option) {\n    return (0,react.createElement)(select_SelectOption, option);\n  }) : _ref$children,\n      props = Select_objectWithoutProperties(_ref, Select_excluded);\n\n  var anchorRef = (0,react.useRef)();\n  var inputRef = (0,react.useRef)();\n  var menuRef = (0,react.useRef)();\n\n  var _useState = (0,react.useState)(false),\n      _useState2 = Select_slicedToArray(_useState, 2),\n      activated = _useState2[0],\n      setActivated = _useState2[1];\n\n  var _useState3 = (0,react.useState)(false),\n      _useState4 = Select_slicedToArray(_useState3, 2),\n      focused = _useState4[0],\n      setFocused = _useState4[1];\n\n  var _useState5 = (0,react.useState)(false),\n      _useState6 = Select_slicedToArray(_useState5, 2),\n      touched = _useState6[0],\n      setTouched = _useState6[1];\n\n  var _useState7 = (0,react.useState)(),\n      _useState8 = Select_slicedToArray(_useState7, 2),\n      selectedText = _useState8[0],\n      setSelectedText = _useState8[1];\n\n  var _useState9 = (0,react.useState)(),\n      _useState10 = Select_slicedToArray(_useState9, 2),\n      interactionCoords = _useState10[0],\n      setInteractionCoords = _useState10[1];\n\n  (0,react.useEffect)(function () {\n    if (multiple) {\n      var selectedOptions = react.Children.toArray(children).map(function (option) {\n        return option.props;\n      }).filter(function (option) {\n        return value.includes(option.value);\n      });\n\n      var _selectedText = selectedOptions.map(function (option) {\n        return option.text || option.children;\n      }).join(\', \');\n\n      setSelectedText(_selectedText);\n    } else {\n      var selectedOption = react.Children.toArray(children).map(function (option) {\n        return option.props;\n      }).find(function (option) {\n        return option.value === value;\n      });\n\n      if (selectedOption) {\n        setSelectedText(selectedOption.text || selectedOption.children);\n      }\n    }\n  }, [value, multiple, children]);\n  var handleAnchorClick = (0,react.useCallback)(function (event) {\n    if (activated) {\n      setActivated(false);\n      setFocused(false);\n    } else {\n      var targetClientRect = event.target.getBoundingClientRect();\n      setInteractionCoords({\n        x: event.clientX - targetClientRect.left,\n        y: event.clientY - targetClientRect.top\n      });\n      setActivated(true);\n      setFocused(true);\n    }\n  }, [activated]);\n  var handleOptionInteraction = (0,react.useCallback)(function (event) {\n    if (event.type === \'keydown\' && event.key !== \' \' && event.key !== \'Enter\') return;\n    var option = event.currentTarget.dataset;\n    if (option.disabled) return;\n\n    if (multiple) {\n      var values = new Set(value);\n      values.has(option.value) ? values["delete"](option.value) : values.add(option.value);\n      event.target = {\n        name: name,\n        value: _toConsumableArray(values)\n      };\n      onChange(event, _toConsumableArray(values));\n    } else {\n      event.target = {\n        name: name,\n        value: option.value\n      };\n      onChange(event, option.value);\n      setActivated(false);\n      setFocused(false);\n    }\n  }, [value, name, multiple, onChange]);\n  var handleMenuClose = (0,react.useCallback)(function (event) {\n    if (event.type === \'click\' && event.target === anchorRef.current) return;\n    if (multiple && event.type === \'click\' && event.path.includes(menuRef.current)) return;\n    setActivated(false);\n    setFocused(false);\n    setTouched(true);\n  }, [multiple]);\n  var handleKeyDown = (0,react.useCallback)(function (event) {\n    if (event.key === \' \' || event.key === \'Enter\' || event.key === \'ArrowDown\' || event.key === \'ArrowUp\') {\n      event.preventDefault();\n      event.stopPropagation();\n      setActivated(true);\n    }\n  }, []);\n  var hasValue = isArray(value) ? value.length > 0 : Boolean(value);\n  var focusedOrHasValue = focused || hasValue;\n  var isInvalid = touched && required && !hasValue;\n  var classNames = classnames_default()(select_constants_cssClasses.ROOT, (_classnames = {}, Select_defineProperty(_classnames, select_constants_cssClasses.FILLED, filled), Select_defineProperty(_classnames, select_constants_cssClasses.OUTLINED, outlined), Select_defineProperty(_classnames, select_constants_cssClasses.ACTIVATED, activated), Select_defineProperty(_classnames, select_constants_cssClasses.DISABLED, disabled), Select_defineProperty(_classnames, select_constants_cssClasses.FOCUSED, focused), Select_defineProperty(_classnames, select_constants_cssClasses.REQUIRED, required), Select_defineProperty(_classnames, select_constants_cssClasses.INVALID, isInvalid), Select_defineProperty(_classnames, select_constants_cssClasses.NO_LABEL, !label), Select_defineProperty(_classnames, select_constants_cssClasses.WITH_LEADING_ICON, leadingIcon), _classnames), className);\n  return /*#__PURE__*/(0,jsx_runtime.jsxs)(jsx_runtime.Fragment, {\n    children: [/*#__PURE__*/(0,jsx_runtime.jsxs)("div", {\n      ref: ref,\n      className: classNames,\n      children: [name && /*#__PURE__*/(0,jsx_runtime.jsx)("input", Select_objectSpread({\n        ref: inputRef,\n        type: "hidden",\n        name: name,\n        value: value,\n        required: required,\n        disabled: disabled\n      }, props)), /*#__PURE__*/(0,jsx_runtime.jsxs)("div", {\n        ref: anchorRef,\n        className: select_constants_cssClasses.ANCHOR,\n        "aria-required": required || undefined,\n        tabIndex: !disabled ? 0 : undefined,\n        onKeyDown: handleKeyDown,\n        onClick: handleAnchorClick,\n        children: [filled && /*#__PURE__*/(0,jsx_runtime.jsx)("div", {\n          className: select_constants_cssClasses.RIPPLE\n        }), filled && label && /*#__PURE__*/(0,jsx_runtime.jsx)(floating_label_FloatingLabel, {\n          label: label,\n          "float": focusedOrHasValue\n        }), outlined && /*#__PURE__*/(0,jsx_runtime.jsx)(notched_outline_NotchedOutline, {\n          notched: focusedOrHasValue,\n          children: label && /*#__PURE__*/(0,jsx_runtime.jsx)(floating_label_FloatingLabel, {\n            label: label,\n            "float": focusedOrHasValue\n          })\n        }), leadingIcon && /*#__PURE__*/(0,jsx_runtime.jsx)(Clone, {\n          component: leadingIcon,\n          fallback: icon_Icon,\n          className: select_constants_cssClasses.ICON,\n          tabIndex: "0",\n          role: "button"\n        }), /*#__PURE__*/(0,jsx_runtime.jsx)("span", {\n          className: select_constants_cssClasses.SELECTED_TEXT_CONTAINER,\n          children: /*#__PURE__*/(0,jsx_runtime.jsx)("span", {\n            className: select_constants_cssClasses.SELECTED_TEXT,\n            children: selectedText\n          })\n        }), /*#__PURE__*/(0,jsx_runtime.jsx)(select_DropdownIcon, {}), filled && /*#__PURE__*/(0,jsx_runtime.jsx)(line_ripple_LineRipple, {\n          active: focused,\n          transformOrigin: interactionCoords === null || interactionCoords === void 0 ? void 0 : interactionCoords.x\n        })]\n      }), /*#__PURE__*/(0,jsx_runtime.jsx)(menu_Menu, Select_objectSpread(Select_objectSpread({\n        ref: menuRef,\n        anchorRef: anchorRef,\n        className: select_constants_cssClasses.MENU,\n        open: activated,\n        anchorOrigin: Origin.BOTTOM_CENTER,\n        transformOrigin: Origin.TOP_CENTER,\n        fullWidth: true,\n        listProps: listProps,\n        onClose: handleMenuClose\n      }, menuProps), {}, {\n        children: react.Children.map(children, function (option) {\n          var optionValue = option.props.value;\n          return (0,react.cloneElement)(option, {\n            value: undefined,\n            \'data-value\': optionValue,\n            selected: !isUndefined(value) && (multiple ? value.includes(optionValue) : optionValue === value),\n            checkbox: multiple,\n            onClick: handleOptionInteraction,\n            onKeyDown: handleOptionInteraction\n          });\n        })\n      }))]\n    }), helperText && /*#__PURE__*/(0,jsx_runtime.jsx)(select_HelperText, Select_objectSpread(Select_objectSpread({}, helperTextProps), {}, {\n      children: helperText\n    }))]\n  });\n});\nSelect.displayName = \'MDCSelect\';\nSelect.propTypes = {\n  value: (prop_types_default()).any,\n  options: prop_types_default().arrayOf((prop_types_default()).object),\n  label: (prop_types_default()).string,\n  leadingIcon: (prop_types_default()).element,\n  helperText: (prop_types_default()).string,\n  filled: (prop_types_default()).bool,\n  outlined: (prop_types_default()).bool,\n  multiple: (prop_types_default()).bool,\n  disabled: (prop_types_default()).bool,\n  required: (prop_types_default()).bool,\n  children: prop_types_default().oneOfType([(prop_types_default()).element, prop_types_default().arrayOf((prop_types_default()).element)]),\n  menuProps: (prop_types_default()).object,\n  helperTextProps: (prop_types_default()).object,\n  onChange: (prop_types_default()).func\n};\n/* harmony default export */ const select_Select = (Select);\n;// CONCATENATED MODULE: ./src/select/index.js\n\n\nselect_Select.Option = select_SelectOption;\n\n;// CONCATENATED MODULE: ./src/data-table/DataTablePagination.jsx\nvar DataTablePagination_excluded = ["totalCount", "currentPage", "rowsPerPage", "onFirstPage", "onPrevPage", "onNextPage", "onLastPage", "className"];\n\nfunction DataTablePagination_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction DataTablePagination_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { DataTablePagination_ownKeys(Object(source), true).forEach(function (key) { DataTablePagination_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { DataTablePagination_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction DataTablePagination_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction DataTablePagination_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = DataTablePagination_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction DataTablePagination_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\n\n\n\nvar DataTablePagination = /*#__PURE__*/(0,react.forwardRef)(function (_ref, ref) {\n  var totalCount = _ref.totalCount,\n      _ref$currentPage = _ref.currentPage,\n      currentPage = _ref$currentPage === void 0 ? 1 : _ref$currentPage,\n      _ref$rowsPerPage = _ref.rowsPerPage,\n      rowsPerPage = _ref$rowsPerPage === void 0 ? 10 : _ref$rowsPerPage,\n      _ref$onFirstPage = _ref.onFirstPage,\n      onFirstPage = _ref$onFirstPage === void 0 ? Function.prototype : _ref$onFirstPage,\n      _ref$onPrevPage = _ref.onPrevPage,\n      onPrevPage = _ref$onPrevPage === void 0 ? Function.prototype : _ref$onPrevPage,\n      _ref$onNextPage = _ref.onNextPage,\n      onNextPage = _ref$onNextPage === void 0 ? Function.prototype : _ref$onNextPage,\n      _ref$onLastPage = _ref.onLastPage,\n      onLastPage = _ref$onLastPage === void 0 ? Function.prototype : _ref$onLastPage,\n      className = _ref.className,\n      props = DataTablePagination_objectWithoutProperties(_ref, DataTablePagination_excluded);\n\n  var classNames = classnames_default()(data_table_constants_cssClasses.PAGINATION, className);\n  return /*#__PURE__*/(0,jsx_runtime.jsx)("div", DataTablePagination_objectSpread(DataTablePagination_objectSpread({\n    ref: ref,\n    className: classNames\n  }, props), {}, {\n    children: /*#__PURE__*/(0,jsx_runtime.jsxs)("div", {\n      className: data_table_constants_cssClasses.PAGINATION_TRAILING,\n      children: [/*#__PURE__*/(0,jsx_runtime.jsxs)("div", {\n        className: data_table_constants_cssClasses.PAGINATION_ROWS_PER_PAGE,\n        children: [/*#__PURE__*/(0,jsx_runtime.jsx)("div", {\n          className: data_table_constants_cssClasses.PAGINATION_ROWS_PER_PAGE_LABEL,\n          children: "\\u0420\\u044F\\u0434\\u043E\\u0432 \\u043D\\u0430 \\u0441\\u0442\\u0440."\n        }), /*#__PURE__*/(0,jsx_runtime.jsx)(select_Select, {\n          className: data_table_constants_cssClasses.PAGINATION_ROWS_PER_PAGE_SELECT,\n          options: [10, 25, 50, 100].map(function (value) {\n            return {\n              key: value,\n              text: value //selected: value === rowsPerPage\n\n            };\n          })\n        })]\n      }), /*#__PURE__*/(0,jsx_runtime.jsxs)("div", {\n        className: data_table_constants_cssClasses.PAGINATION_NAVIGATION,\n        children: [/*#__PURE__*/(0,jsx_runtime.jsxs)("div", {\n          className: data_table_constants_cssClasses.PAGINATION_TOTAL,\n          children: [currentPage, "\\u2011", rowsPerPage, " \\u0438\\u0437 ", totalCount]\n        }), /*#__PURE__*/(0,jsx_runtime.jsx)(icon_button_IconButton, {\n          className: data_table_constants_cssClasses.PAGINATION_BUTTON,\n          icon: "first_page",\n          onClick: onFirstPage\n        }), /*#__PURE__*/(0,jsx_runtime.jsx)(icon_button_IconButton, {\n          className: data_table_constants_cssClasses.PAGINATION_BUTTON,\n          icon: "chevron_left",\n          onClick: onPrevPage\n        }), /*#__PURE__*/(0,jsx_runtime.jsx)(icon_button_IconButton, {\n          className: data_table_constants_cssClasses.PAGINATION_BUTTON,\n          icon: "chevron_right",\n          onClick: onNextPage\n        }), /*#__PURE__*/(0,jsx_runtime.jsx)(icon_button_IconButton, {\n          className: data_table_constants_cssClasses.PAGINATION_BUTTON,\n          icon: "last_page",\n          onClick: onLastPage\n        })]\n      })]\n    })\n  }));\n});\nDataTablePagination.displayName = \'MDCDataTablePagination\';\n/* harmony default export */ const data_table_DataTablePagination = (DataTablePagination);\n;// CONCATENATED MODULE: ./src/data-table/DataTable.jsx\nvar DataTable_excluded = ["stickyHeader", "inProgress", "pagination", "className", "children"];\n\nfunction DataTable_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction DataTable_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { DataTable_ownKeys(Object(source), true).forEach(function (key) { DataTable_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { DataTable_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction DataTable_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction DataTable_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = DataTable_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction DataTable_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\n\n\n\n\nvar DataTable = /*#__PURE__*/(0,react.forwardRef)(function (_ref, ref) {\n  var _classnames;\n\n  var _ref$stickyHeader = _ref.stickyHeader,\n      stickyHeader = _ref$stickyHeader === void 0 ? false : _ref$stickyHeader,\n      _ref$inProgress = _ref.inProgress,\n      inProgress = _ref$inProgress === void 0 ? false : _ref$inProgress,\n      pagination = _ref.pagination,\n      className = _ref.className,\n      children = _ref.children,\n      props = DataTable_objectWithoutProperties(_ref, DataTable_excluded);\n\n  var classNames = classnames_default()(data_table_constants_cssClasses.ROOT, (_classnames = {}, DataTable_defineProperty(_classnames, data_table_constants_cssClasses.STICKY_HEADER, stickyHeader), DataTable_defineProperty(_classnames, data_table_constants_cssClasses.IN_PROGRESS, inProgress), _classnames), className);\n  return /*#__PURE__*/(0,jsx_runtime.jsxs)("div", DataTable_objectSpread(DataTable_objectSpread({\n    ref: ref,\n    className: classNames\n  }, props), {}, {\n    children: [/*#__PURE__*/(0,jsx_runtime.jsx)("div", {\n      className: data_table_constants_cssClasses.TABLE_CONTAINER,\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)("table", {\n        className: data_table_constants_cssClasses.TABLE,\n        children: children\n      })\n    }), inProgress && /*#__PURE__*/(0,jsx_runtime.jsx)(data_table_DataTableProgressIndicator, {}), pagination && /*#__PURE__*/(0,jsx_runtime.jsx)(data_table_DataTablePagination, DataTable_objectSpread({}, pagination))]\n  }));\n});\nDataTable.displayName = \'MDCDataTable\';\nDataTable.propTypes = {\n  stickyHeader: (prop_types_default()).bool,\n  inProgress: (prop_types_default()).bool\n};\n/* harmony default export */ const data_table_DataTable = (DataTable);\n;// CONCATENATED MODULE: ./src/data-table/DataTableCell.jsx\nvar DataTableCell_excluded = ["checkbox", "numeric", "element", "scope", "className", "children"];\n\nfunction DataTableCell_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction DataTableCell_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { DataTableCell_ownKeys(Object(source), true).forEach(function (key) { DataTableCell_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { DataTableCell_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction DataTableCell_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction DataTableCell_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = DataTableCell_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction DataTableCell_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\n\n\nvar DataTableCell = /*#__PURE__*/(0,react.forwardRef)(function (_ref, ref) {\n  var _classnames;\n\n  var _ref$checkbox = _ref.checkbox,\n      checkbox = _ref$checkbox === void 0 ? false : _ref$checkbox,\n      _ref$numeric = _ref.numeric,\n      numeric = _ref$numeric === void 0 ? false : _ref$numeric,\n      _ref$element = _ref.element,\n      Element = _ref$element === void 0 ? \'td\' : _ref$element,\n      scope = _ref.scope,\n      className = _ref.className,\n      children = _ref.children,\n      props = DataTableCell_objectWithoutProperties(_ref, DataTableCell_excluded);\n\n  var classNames = classnames_default()(data_table_constants_cssClasses.CELL, (_classnames = {}, DataTableCell_defineProperty(_classnames, data_table_constants_cssClasses.CELL_CHECKBOX, checkbox), DataTableCell_defineProperty(_classnames, data_table_constants_cssClasses.CELL_NUMERIC, numeric), _classnames), className);\n  return /*#__PURE__*/(0,jsx_runtime.jsx)(Element, DataTableCell_objectSpread(DataTableCell_objectSpread({\n    ref: ref,\n    className: classNames,\n    scope: scope\n  }, props), {}, {\n    children: checkbox ? /*#__PURE__*/(0,jsx_runtime.jsx)(Clone, {\n      component: children,\n      className: data_table_constants_cssClasses.ROW_CHECKBOX\n    }) : children\n  }));\n});\nDataTableCell.displayName = \'MDCDataTableCell\';\nDataTableCell.propTypes = {\n  checkbox: (prop_types_default()).bool,\n  numeric: (prop_types_default()).bool\n};\n/* harmony default export */ const data_table_DataTableCell = (DataTableCell);\n;// CONCATENATED MODULE: ./src/data-table/DataTableContent.jsx\nvar DataTableContent_excluded = ["className"];\n\nfunction DataTableContent_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction DataTableContent_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { DataTableContent_ownKeys(Object(source), true).forEach(function (key) { DataTableContent_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { DataTableContent_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction DataTableContent_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction DataTableContent_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = DataTableContent_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction DataTableContent_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\nvar DataTableContent = /*#__PURE__*/(0,react.forwardRef)(function (_ref, ref) {\n  var className = _ref.className,\n      props = DataTableContent_objectWithoutProperties(_ref, DataTableContent_excluded);\n\n  var classNames = classnames_default()(data_table_constants_cssClasses.CONTENT, className);\n  return /*#__PURE__*/(0,jsx_runtime.jsx)("tbody", DataTableContent_objectSpread({\n    ref: ref,\n    className: classNames\n  }, props));\n});\nDataTableContent.displayName = \'MDCDataTableContent\';\n/* harmony default export */ const data_table_DataTableContent = (DataTableContent);\n;// CONCATENATED MODULE: ./src/data-table/DataTableFooter.jsx\nvar DataTableFooter_excluded = ["className"];\n\nfunction DataTableFooter_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction DataTableFooter_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { DataTableFooter_ownKeys(Object(source), true).forEach(function (key) { DataTableFooter_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { DataTableFooter_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction DataTableFooter_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction DataTableFooter_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = DataTableFooter_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction DataTableFooter_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\nvar DataTableFooter = /*#__PURE__*/(0,react.forwardRef)(function (_ref, ref) {\n  var className = _ref.className,\n      props = DataTableFooter_objectWithoutProperties(_ref, DataTableFooter_excluded);\n\n  var classNames = classnames_default()(data_table_constants_cssClasses.FOOTER, className);\n  return /*#__PURE__*/(0,jsx_runtime.jsx)("tfoot", DataTableFooter_objectSpread({\n    ref: ref,\n    className: classNames\n  }, props));\n});\nDataTableFooter.displayName = \'MDCDataTableFooter\';\n/* harmony default export */ const data_table_DataTableFooter = (DataTableFooter);\n;// CONCATENATED MODULE: ./src/data-table/DataTableHeader.jsx\nvar DataTableHeader_excluded = ["className"];\n\nfunction DataTableHeader_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction DataTableHeader_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { DataTableHeader_ownKeys(Object(source), true).forEach(function (key) { DataTableHeader_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { DataTableHeader_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction DataTableHeader_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction DataTableHeader_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = DataTableHeader_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction DataTableHeader_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\nvar DataTableHeader = /*#__PURE__*/(0,react.forwardRef)(function (_ref, ref) {\n  var className = _ref.className,\n      props = DataTableHeader_objectWithoutProperties(_ref, DataTableHeader_excluded);\n\n  var classNames = classnames_default()(data_table_constants_cssClasses.HEADER, className);\n  return /*#__PURE__*/(0,jsx_runtime.jsx)("thead", DataTableHeader_objectSpread({\n    ref: ref,\n    className: classNames\n  }, props));\n});\nDataTableHeader.displayName = \'MDCDataTableHeader\';\n/* harmony default export */ const data_table_DataTableHeader = (DataTableHeader);\n;// CONCATENATED MODULE: ./src/data-table/DataTableHeaderCell.jsx\nvar DataTableHeaderCell_excluded = ["value", "label", "checkbox", "numeric", "sort", "sortIconButton", "onSort", "element", "role", "scope", "className", "children"];\n\nfunction DataTableHeaderCell_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction DataTableHeaderCell_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { DataTableHeaderCell_ownKeys(Object(source), true).forEach(function (key) { DataTableHeaderCell_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { DataTableHeaderCell_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction DataTableHeaderCell_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction DataTableHeaderCell_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = DataTableHeaderCell_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction DataTableHeaderCell_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\n\n\n\n\nvar DataTableHeaderCell = /*#__PURE__*/(0,react.forwardRef)(function (_ref, ref) {\n  var _classnames;\n\n  var value = _ref.value,\n      label = _ref.label,\n      _ref$checkbox = _ref.checkbox,\n      checkbox = _ref$checkbox === void 0 ? false : _ref$checkbox,\n      _ref$numeric = _ref.numeric,\n      numeric = _ref$numeric === void 0 ? false : _ref$numeric,\n      sort = _ref.sort,\n      _ref$sortIconButton = _ref.sortIconButton,\n      sortIconButton = _ref$sortIconButton === void 0 ? \'arrow_upward\' : _ref$sortIconButton,\n      _ref$onSort = _ref.onSort,\n      onSort = _ref$onSort === void 0 ? Function.prototype : _ref$onSort,\n      _ref$element = _ref.element,\n      Element = _ref$element === void 0 ? \'th\' : _ref$element,\n      _ref$role = _ref.role,\n      role = _ref$role === void 0 ? \'columnheader\' : _ref$role,\n      _ref$scope = _ref.scope,\n      scope = _ref$scope === void 0 ? \'col\' : _ref$scope,\n      className = _ref.className,\n      _ref$children = _ref.children,\n      children = _ref$children === void 0 ? label : _ref$children,\n      props = DataTableHeaderCell_objectWithoutProperties(_ref, DataTableHeaderCell_excluded);\n\n  var handleSortIconClick = (0,react.useCallback)(function () {\n    onSort({\n      label: label,\n      value: value\n    });\n  }, [label, value, onSort]);\n  var withSort = typeof sort === \'number\';\n  var classNames = classnames_default()(data_table_constants_cssClasses.HEADER_CELL, (_classnames = {}, DataTableHeaderCell_defineProperty(_classnames, data_table_constants_cssClasses.HEADER_CELL_CHECKBOX, checkbox), DataTableHeaderCell_defineProperty(_classnames, data_table_constants_cssClasses.HEADER_CELL_NUMERIC, numeric), DataTableHeaderCell_defineProperty(_classnames, data_table_constants_cssClasses.HEADER_CELL_WITH_SORT, withSort), DataTableHeaderCell_defineProperty(_classnames, data_table_constants_cssClasses.HEADER_CELL_SORTED, sort === 1 || sort === -1), DataTableHeaderCell_defineProperty(_classnames, data_table_constants_cssClasses.HEADER_CELL_SORTED_DESC, sort === -1), _classnames), className);\n  return /*#__PURE__*/(0,jsx_runtime.jsx)(Element, DataTableHeaderCell_objectSpread(DataTableHeaderCell_objectSpread({\n    ref: ref,\n    className: classNames,\n    role: role,\n    scope: scope\n  }, props), {}, {\n    children: withSort ? /*#__PURE__*/(0,jsx_runtime.jsxs)("div", {\n      className: data_table_constants_cssClasses.HEADER_CELL_WRAPPER,\n      children: [/*#__PURE__*/(0,jsx_runtime.jsx)("div", {\n        className: data_table_constants_cssClasses.HEADER_CELL_LABEL,\n        children: children\n      }), /*#__PURE__*/(0,jsx_runtime.jsx)(Clone, {\n        component: sortIconButton,\n        fallback: icon_button_IconButton,\n        className: data_table_constants_cssClasses.SORT_ICON_BUTTON,\n        onClick: handleSortIconClick\n      }), /*#__PURE__*/(0,jsx_runtime.jsx)("div", {\n        className: data_table_constants_cssClasses.SORT_STATUS_LABEL,\n        "aria-hidden": "true"\n      })]\n    }) : checkbox ? /*#__PURE__*/(0,jsx_runtime.jsx)(Clone, {\n      component: children,\n      className: data_table_constants_cssClasses.HEADER_ROW_CHECKBOX\n    }) : children\n  }));\n});\nDataTableHeaderCell.displayName = \'MDCDataTableHeaderCell\';\nDataTableHeaderCell.propTypes = {\n  value: (prop_types_default()).any,\n  label: (prop_types_default()).string,\n  numeric: (prop_types_default()).bool,\n  checkbox: (prop_types_default()).bool,\n  sort: prop_types_default().oneOf([-1, 0, 1]),\n  sortIconButton: (prop_types_default()).node,\n  onSort: (prop_types_default()).func\n};\n/* harmony default export */ const data_table_DataTableHeaderCell = (DataTableHeaderCell);\n;// CONCATENATED MODULE: ./src/data-table/DataTableHeaderRow.jsx\nvar DataTableHeaderRow_excluded = ["className"];\n\nfunction DataTableHeaderRow_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction DataTableHeaderRow_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { DataTableHeaderRow_ownKeys(Object(source), true).forEach(function (key) { DataTableHeaderRow_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { DataTableHeaderRow_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction DataTableHeaderRow_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction DataTableHeaderRow_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = DataTableHeaderRow_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction DataTableHeaderRow_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\nvar DataTableHeaderRow = /*#__PURE__*/(0,react.forwardRef)(function (_ref, ref) {\n  var className = _ref.className,\n      props = DataTableHeaderRow_objectWithoutProperties(_ref, DataTableHeaderRow_excluded);\n\n  var classNames = classnames_default()(data_table_constants_cssClasses.HEADER_ROW, className);\n  return /*#__PURE__*/(0,jsx_runtime.jsx)("tr", DataTableHeaderRow_objectSpread({\n    ref: ref,\n    className: classNames\n  }, props));\n});\nDataTableHeaderRow.displayName = \'MDCDataTableHeaderRow\';\n/* harmony default export */ const data_table_DataTableHeaderRow = (DataTableHeaderRow);\n;// CONCATENATED MODULE: ./src/data-table/DataTableRow.jsx\nvar DataTableRow_excluded = ["selected", "className"];\n\nfunction DataTableRow_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction DataTableRow_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { DataTableRow_ownKeys(Object(source), true).forEach(function (key) { DataTableRow_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { DataTableRow_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction DataTableRow_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction DataTableRow_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = DataTableRow_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction DataTableRow_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\n\nvar DataTableRow = /*#__PURE__*/(0,react.forwardRef)(function (_ref, ref) {\n  var _ref$selected = _ref.selected,\n      selected = _ref$selected === void 0 ? false : _ref$selected,\n      className = _ref.className,\n      props = DataTableRow_objectWithoutProperties(_ref, DataTableRow_excluded);\n\n  var classNames = classnames_default()(data_table_constants_cssClasses.ROW, DataTableRow_defineProperty({}, data_table_constants_cssClasses.ROW_SELECTED, selected), className);\n  return /*#__PURE__*/(0,jsx_runtime.jsx)("tr", DataTableRow_objectSpread({\n    ref: ref,\n    className: classNames\n  }, props));\n});\nDataTableRow.displayName = \'MDCDataTableRow\';\nDataTableRow.propTypes = {\n  selected: (prop_types_default()).bool\n};\n/* harmony default export */ const data_table_DataTableRow = (DataTableRow);\n;// CONCATENATED MODULE: ./src/data-table/index.js\n\n\n\n\n\n\n\n\n\ndata_table_DataTable.Cell = data_table_DataTableCell;\ndata_table_DataTable.Content = data_table_DataTableContent;\ndata_table_DataTable.Footer = data_table_DataTableFooter;\ndata_table_DataTable.Header = data_table_DataTableHeader;\ndata_table_DataTable.HeaderCell = data_table_DataTableHeaderCell;\ndata_table_DataTable.HeaderRow = data_table_DataTableHeaderRow;\ndata_table_DataTable.Pagination = data_table_DataTablePagination;\ndata_table_DataTable.Row = data_table_DataTableRow;\n\n;// CONCATENATED MODULE: ./src/dialog/constants.js\nvar dialog_constants_numbers = {\n  DIALOG_ANIMATION_OPEN_TIME_MS: 150,\n  DIALOG_ANIMATION_CLOSE_TIME_MS: 75,\n  DEFAULT_ACTIONS_HEIGHT: 52\n};\nvar dialog_constants_cssClasses = {\n  ROOT: \'mdc-dialog\',\n  HEADER: \'mdc-dialog__header\',\n  TITLE: \'mdc-dialog__title\',\n  CLOSE: \'mdc-dialog__close\',\n  CONTENT: \'mdc-dialog__content\',\n  CONTAINER: \'mdc-dialog__container\',\n  ACTIONS: \'mdc-dialog__actions\',\n  BUTTON: \'mdc-dialog__button\',\n  SURFACE: \'mdc-dialog__surface\',\n  SCRIM: \'mdc-dialog__scrim\',\n  OPEN: \'mdc-dialog--open\',\n  OPENING: \'mdc-dialog--opening\',\n  CLOSING: \'mdc-dialog--closing\',\n  FULLSCREEN: \'mdc-dialog--fullscreen\',\n  SCROLLABLE: \'mdc-dialog--scrollable\',\n  STACKED: \'mdc-dialog--stacked\',\n  SCROLL_DIVIDER_HEADER: \'mdc-dialog-scroll-divider-header\',\n  SCROLL_DIVIDER_FOOTER: \'mdc-dialog-scroll-divider-footer\',\n  SCROLL_LOCK: \'mdc-dialog-scroll-lock\'\n};\n;// CONCATENATED MODULE: ./src/dialog/DialogHeader.jsx\nvar DialogHeader_excluded = ["title", "closeIcon", "fullscreen", "onClose", "children"];\n\nfunction DialogHeader_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction DialogHeader_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { DialogHeader_ownKeys(Object(source), true).forEach(function (key) { DialogHeader_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { DialogHeader_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction DialogHeader_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction DialogHeader_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = DialogHeader_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction DialogHeader_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\n\n\nvar DialogHeader = /*#__PURE__*/(0,react.forwardRef)(function (_ref, ref) {\n  var title = _ref.title,\n      closeIcon = _ref.closeIcon,\n      fullscreen = _ref.fullscreen,\n      onClose = _ref.onClose,\n      children = _ref.children,\n      props = DialogHeader_objectWithoutProperties(_ref, DialogHeader_excluded);\n\n  return /*#__PURE__*/(0,jsx_runtime.jsxs)("div", DialogHeader_objectSpread(DialogHeader_objectSpread({\n    ref: ref,\n    className: dialog_constants_cssClasses.HEADER\n  }, props), {}, {\n    children: [/*#__PURE__*/(0,jsx_runtime.jsx)(Clone, {\n      component: title,\n      fallback: "h2",\n      className: dialog_constants_cssClasses.TITLE\n    }), (fullscreen || closeIcon) && /*#__PURE__*/(0,jsx_runtime.jsx)(Clone, {\n      component: closeIcon,\n      fallback: /*#__PURE__*/(0,jsx_runtime.jsx)(icon_button_IconButton, {\n        icon: "close"\n      }),\n      className: dialog_constants_cssClasses.CLOSE,\n      onClick: onClose\n    }), children]\n  }));\n});\nDialogHeader.displayName = \'MDCDialogHeader\';\n/* harmony default export */ const dialog_DialogHeader = (DialogHeader);\n;// CONCATENATED MODULE: ./src/dialog/DialogContent.jsx\nfunction DialogContent_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction DialogContent_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { DialogContent_ownKeys(Object(source), true).forEach(function (key) { DialogContent_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { DialogContent_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction DialogContent_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n\n\n\nvar DialogContent = /*#__PURE__*/(0,react.forwardRef)(function (props, ref) {\n  return /*#__PURE__*/(0,jsx_runtime.jsx)("div", DialogContent_objectSpread({\n    ref: ref,\n    className: dialog_constants_cssClasses.CONTENT\n  }, props));\n});\nDialogContent.displayName = \'MDCDialogContent\';\n/* harmony default export */ const dialog_DialogContent = (DialogContent);\n;// CONCATENATED MODULE: ./src/dialog/DialogActions.jsx\n\n\n\n\nvar DialogActions = /*#__PURE__*/(0,react.forwardRef)(function (_ref, ref) {\n  var children = _ref.children;\n  return /*#__PURE__*/(0,jsx_runtime.jsx)("div", {\n    ref: ref,\n    className: dialog_constants_cssClasses.ACTIONS,\n    children: /*#__PURE__*/(0,jsx_runtime.jsx)(Clone, {\n      component: children,\n      className: dialog_constants_cssClasses.BUTTON\n    })\n  });\n});\nDialogActions.displayName = \'MDCDialogActions\';\n/* harmony default export */ const dialog_DialogActions = (DialogActions);\n;// CONCATENATED MODULE: ./src/dialog/Dialog.jsx\nvar Dialog_excluded = ["title", "content", "actions", "closeIcon", "open", "appear", "persistent", "fullscreen", "stacked", "autoStackButtons", "onClose", "element", "className", "children"];\n\nfunction Dialog_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction Dialog_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { Dialog_ownKeys(Object(source), true).forEach(function (key) { Dialog_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { Dialog_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction Dialog_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction Dialog_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = Dialog_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction Dialog_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\n\n\n\n\n\n\n\nvar Dialog = /*#__PURE__*/(0,react.forwardRef)(function (_ref, ref) {\n  var _classnames;\n\n  var title = _ref.title,\n      content = _ref.content,\n      actions = _ref.actions,\n      closeIcon = _ref.closeIcon,\n      _ref$open = _ref.open,\n      open = _ref$open === void 0 ? false : _ref$open,\n      _ref$appear = _ref.appear,\n      appear = _ref$appear === void 0 ? false : _ref$appear,\n      _ref$persistent = _ref.persistent,\n      persistent = _ref$persistent === void 0 ? false : _ref$persistent,\n      _ref$fullscreen = _ref.fullscreen,\n      fullscreen = _ref$fullscreen === void 0 ? false : _ref$fullscreen,\n      _ref$stacked = _ref.stacked,\n      stacked = _ref$stacked === void 0 ? false : _ref$stacked,\n      _ref$autoStackButtons = _ref.autoStackButtons,\n      autoStackButtons = _ref$autoStackButtons === void 0 ? false : _ref$autoStackButtons,\n      _ref$onClose = _ref.onClose,\n      onClose = _ref$onClose === void 0 ? Function.prototype : _ref$onClose,\n      _ref$element = _ref.element,\n      Element = _ref$element === void 0 ? \'div\' : _ref$element,\n      className = _ref.className,\n      _ref$children = _ref.children,\n      children = _ref$children === void 0 ? content : _ref$children,\n      props = Dialog_objectWithoutProperties(_ref, Dialog_excluded);\n\n  var rootRef = (0,react.useRef)();\n  var contentRef = (0,react.useRef)();\n  var actionsRef = (0,react.useRef)();\n  (0,react.useImperativeHandle)(ref, function () {\n    return rootRef.current;\n  });\n  useUpdated(function () {\n    if (persistent) return;\n\n    function handleDocumentKeyDown(event) {\n      if (event.key === \'Escape\' || event.keyCode === 27) {\n        event.stopPropagation();\n        onClose();\n      }\n    }\n\n    if (open) {\n      document.addEventListener(\'keydown\', handleDocumentKeyDown);\n    } else {\n      document.removeEventListener(\'keydown\', handleDocumentKeyDown);\n    }\n\n    return function () {\n      return document.removeEventListener(\'keydown\', handleDocumentKeyDown);\n    };\n  }, [open, persistent, onClose]);\n  useUpdated(function () {\n    if (!contentRef.current || !open) return;\n    var contentElement = contentRef.current;\n    var shouldScroll = contentElement.scrollHeight > contentElement.offsetHeight;\n\n    if (shouldScroll) {\n      rootRef.current.classList.add(dialog_constants_cssClasses.SCROLLABLE);\n    }\n  }, [open]);\n  useUpdated(function () {\n    if (!actionsRef.current || !open || !autoStackButtons) return;\n    var actionsElement = actionsRef.current;\n\n    if (actionsElement.clientHeight > dialog_constants_numbers.DEFAULT_ACTIONS_HEIGHT) {\n      rootRef.current.classList.add(dialog_constants_cssClasses.STACKED);\n    }\n  }, [open, autoStackButtons]);\n  useUpdated(function () {\n    if (!contentRef.current || !fullscreen) return;\n    var contentElement = contentRef.current;\n\n    function handleScroll() {\n      var isScrollAtTop = contentElement.scrollTop === 0;\n      var isScrollAtBottom = Math.ceil(contentElement.scrollHeight - contentElement.scrollTop) === contentElement.clientHeight;\n      rootRef.current.classList.toggle(dialog_constants_cssClasses.SCROLL_DIVIDER_HEADER, !isScrollAtTop);\n      rootRef.current.classList.toggle(dialog_constants_cssClasses.SCROLL_DIVIDER_FOOTER, !isScrollAtBottom);\n    }\n\n    contentElement.addEventListener(\'scroll\', handleScroll);\n\n    if (open) {\n      handleScroll();\n    }\n\n    return function () {\n      return contentElement.removeEventListener(\'scroll\', handleScroll);\n    };\n  }, [open, fullscreen]);\n  useUnmounted(function () {\n    document.body.classList.remove(dialog_constants_cssClasses.SCROLL_LOCK);\n  });\n  var handleEnter = (0,react.useCallback)(function () {\n    document.body.classList.add(dialog_constants_cssClasses.SCROLL_LOCK);\n  }, []);\n  var handleExited = (0,react.useCallback)(function () {\n    document.body.classList.remove(dialog_constants_cssClasses.SCROLL_LOCK);\n  }, []);\n  var handleScrimClick = (0,react.useCallback)(function () {\n    if (persistent) return;\n    onClose();\n  }, [persistent, onClose]);\n  var classNames = classnames_default()(dialog_constants_cssClasses.ROOT, (_classnames = {}, Dialog_defineProperty(_classnames, dialog_constants_cssClasses.FULLSCREEN, fullscreen), Dialog_defineProperty(_classnames, dialog_constants_cssClasses.STACKED, stacked), _classnames), className);\n  return /*#__PURE__*/(0,jsx_runtime.jsx)(Layer, {\n    modal: true,\n    "in": open,\n    appear: appear,\n    timeout: {\n      enter: dialog_constants_numbers.DIALOG_ANIMATION_OPEN_TIME_MS,\n      exit: dialog_constants_numbers.DIALOG_ANIMATION_CLOSE_TIME_MS\n    },\n    classNames: {\n      appear: dialog_constants_cssClasses.OPENING,\n      appearActive: dialog_constants_cssClasses.OPEN,\n      enter: dialog_constants_cssClasses.OPENING,\n      enterActive: dialog_constants_cssClasses.OPEN,\n      enterDone: dialog_constants_cssClasses.OPEN,\n      exit: dialog_constants_cssClasses.CLOSING\n    },\n    mountOnEnter: true,\n    unmountOnExit: true,\n    onEnter: handleEnter,\n    onExited: handleExited,\n    children: /*#__PURE__*/(0,jsx_runtime.jsxs)(Element, Dialog_objectSpread(Dialog_objectSpread({\n      ref: rootRef,\n      className: classNames\n    }, props), {}, {\n      children: [/*#__PURE__*/(0,jsx_runtime.jsx)("div", {\n        className: dialog_constants_cssClasses.CONTAINER,\n        children: /*#__PURE__*/(0,jsx_runtime.jsxs)("div", {\n          className: dialog_constants_cssClasses.SURFACE,\n          role: "alertdialog",\n          "aria-modal": "true",\n          children: [title && /*#__PURE__*/(0,jsx_runtime.jsx)(dialog_DialogHeader, {\n            title: title,\n            closeIcon: closeIcon,\n            fullscreen: fullscreen,\n            onClose: onClose\n          }), children && /*#__PURE__*/(0,jsx_runtime.jsx)(dialog_DialogContent, {\n            ref: contentRef,\n            children: children\n          }), actions && /*#__PURE__*/(0,jsx_runtime.jsx)(dialog_DialogActions, {\n            ref: actionsRef,\n            children: actions\n          })]\n        })\n      }), /*#__PURE__*/(0,jsx_runtime.jsx)("div", {\n        className: dialog_constants_cssClasses.SCRIM,\n        onClick: handleScrimClick\n      })]\n    }))\n  });\n});\nDialog.displayName = \'MDCDialog\';\nDialog.propTypes = {\n  title: (prop_types_default()).node,\n  closeIcon: (prop_types_default()).node,\n  content: (prop_types_default()).node,\n  actions: prop_types_default().oneOfType([(prop_types_default()).node, prop_types_default().arrayOf((prop_types_default()).node)]),\n  open: (prop_types_default()).bool,\n  appear: (prop_types_default()).bool,\n  confirmation: (prop_types_default()).bool,\n  persistent: (prop_types_default()).bool,\n  stacked: (prop_types_default()).bool,\n  fullscreen: (prop_types_default()).bool,\n  autoStackButtons: (prop_types_default()).bool,\n  onClose: (prop_types_default()).func\n};\n/* harmony default export */ const dialog_Dialog = (Dialog);\n;// CONCATENATED MODULE: ./src/dialog/index.js\n\n\n\n\ndialog_Dialog.Header = dialog_DialogHeader;\ndialog_Dialog.Content = dialog_DialogContent;\ndialog_Dialog.Actions = dialog_DialogActions;\n\n;// CONCATENATED MODULE: ./src/drawer/constants.js\nvar drawer_constants_numbers = {\n  ANIMATION_ENTER_TIME_MS: 250,\n  ANIMATION_EXIT_TIME_MS: 200\n};\nvar drawer_constants_cssClasses = {\n  ROOT: \'mdc-drawer\',\n  DISMISSIBLE: \'mdc-drawer--dismissible\',\n  MODAL: \'mdc-drawer--modal\',\n  OPEN: \'mdc-drawer--open\',\n  ANIMATE: \'mdc-drawer--animate\',\n  OPENING: \'mdc-drawer--opening\',\n  CLOSING: \'mdc-drawer--closing\',\n  CONTENT: \'mdc-drawer__content\',\n  HEADER: \'mdc-drawer__header\',\n  TITLE: \'mdc-drawer__title\',\n  SUBTITLE: \'mdc-drawer__subtitle\',\n  GRAPHIC: \'mdc-drawer__graphic\',\n  APP_CONTENT: \'mdc-drawer-app-content\',\n  SCRIM: \'mdc-drawer-scrim\'\n};\n;// CONCATENATED MODULE: ./src/drawer/Drawer.jsx\nvar Drawer_excluded = ["open", "appear", "dismissible", "modal", "appContentSelector", "onClose", "element", "component", "className", "children"];\n\nfunction Drawer_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction Drawer_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { Drawer_ownKeys(Object(source), true).forEach(function (key) { Drawer_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { Drawer_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction Drawer_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction Drawer_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = Drawer_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction Drawer_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\n\n\n\n\nvar Drawer = /*#__PURE__*/(0,react.forwardRef)(function (_ref, ref) {\n  var _classnames;\n\n  var _ref$open = _ref.open,\n      open = _ref$open === void 0 ? false : _ref$open,\n      _ref$appear = _ref.appear,\n      appear = _ref$appear === void 0 ? true : _ref$appear,\n      _ref$dismissible = _ref.dismissible,\n      dismissible = _ref$dismissible === void 0 ? false : _ref$dismissible,\n      _ref$modal = _ref.modal,\n      modal = _ref$modal === void 0 ? false : _ref$modal,\n      appContentSelector = _ref.appContentSelector,\n      _ref$onClose = _ref.onClose,\n      onClose = _ref$onClose === void 0 ? Function.prototype : _ref$onClose,\n      _ref$element = _ref.element,\n      element = _ref$element === void 0 ? \'aside\' : _ref$element,\n      _ref$component = _ref.component,\n      Element = _ref$component === void 0 ? element : _ref$component,\n      className = _ref.className,\n      children = _ref.children,\n      props = Drawer_objectWithoutProperties(_ref, Drawer_excluded);\n\n  var rootRef = (0,react.useRef)();\n  (0,react.useImperativeHandle)(ref, function () {\n    return rootRef.current;\n  });\n  (0,react.useEffect)(function () {\n    var _rootRef$current;\n\n    if (!dismissible) return;\n    var appContentElement = appContentSelector ? document.querySelector(appContentSelector) : (_rootRef$current = rootRef.current) === null || _rootRef$current === void 0 ? void 0 : _rootRef$current.nextElementSibling;\n    appContentElement === null || appContentElement === void 0 ? void 0 : appContentElement.classList.add(drawer_constants_cssClasses.APP_CONTENT);\n    return function () {\n      appContentElement === null || appContentElement === void 0 ? void 0 : appContentElement.classList.remove(drawer_constants_cssClasses.APP_CONTENT);\n    };\n  }, [dismissible, appContentSelector]);\n  (0,react.useEffect)(function () {\n    if (!modal) return;\n\n    function handleDocumentKeyDown(event) {\n      if (event.key && event.key === \'Escape\' || event.keyCode === 27) {\n        onClose();\n      }\n    }\n\n    document.addEventListener(\'keydown\', handleDocumentKeyDown);\n    return function () {\n      return document.removeEventListener(\'keydown\', handleDocumentKeyDown);\n    };\n  }, [modal, onClose]);\n  var classNames = classnames_default()(drawer_constants_cssClasses.ROOT, (_classnames = {}, Drawer_defineProperty(_classnames, drawer_constants_cssClasses.DISMISSIBLE, dismissible), Drawer_defineProperty(_classnames, drawer_constants_cssClasses.MODAL, modal), _classnames), className);\n  return /*#__PURE__*/(0,jsx_runtime.jsx)(Layer, {\n    modal: modal,\n    fixed: modal,\n    "in": open,\n    appear: appear,\n    timeout: {\n      enter: drawer_constants_numbers.ANIMATION_ENTER_TIME_MS,\n      exit: drawer_constants_numbers.ANIMATION_EXIT_TIME_MS\n    },\n    classNames: {\n      appear: drawer_constants_cssClasses.OPEN,\n      enter: "".concat(drawer_constants_cssClasses.OPEN, " ").concat(drawer_constants_cssClasses.ANIMATE),\n      enterActive: "".concat(drawer_constants_cssClasses.OPEN, " ").concat(drawer_constants_cssClasses.OPENING),\n      enterDone: drawer_constants_cssClasses.OPEN,\n      exit: "".concat(drawer_constants_cssClasses.OPEN, " ").concat(drawer_constants_cssClasses.CLOSING),\n      exitActive: drawer_constants_cssClasses.CLOSING\n    },\n    mountOnEnter: modal,\n    unmountOnExit: modal,\n    children: /*#__PURE__*/(0,jsx_runtime.jsxs)(jsx_runtime.Fragment, {\n      children: [/*#__PURE__*/(0,jsx_runtime.jsx)(Element, Drawer_objectSpread(Drawer_objectSpread({\n        ref: rootRef,\n        className: classNames\n      }, props), {}, {\n        children: children\n      })), modal && /*#__PURE__*/(0,jsx_runtime.jsx)("div", {\n        className: drawer_constants_cssClasses.SCRIM,\n        onClick: onClose\n      })]\n    })\n  });\n});\nDrawer.displayName = \'MDCDrawer\';\nDrawer.propTypes = {\n  open: (prop_types_default()).bool,\n  appear: (prop_types_default()).bool,\n  dismissible: (prop_types_default()).bool,\n  modal: (prop_types_default()).bool,\n  appContentSelector: (prop_types_default()).string,\n  onClose: (prop_types_default()).func\n};\n/* harmony default export */ const drawer_Drawer = (Drawer);\n;// CONCATENATED MODULE: ./src/drawer/DrawerHeader.jsx\nvar DrawerHeader_excluded = ["title", "subtitle", "graphic", "element", "children"];\n\nfunction DrawerHeader_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction DrawerHeader_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { DrawerHeader_ownKeys(Object(source), true).forEach(function (key) { DrawerHeader_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { DrawerHeader_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction DrawerHeader_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction DrawerHeader_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = DrawerHeader_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction DrawerHeader_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\n\n\nvar DrawerHeader = /*#__PURE__*/(0,react.forwardRef)(function (_ref, ref) {\n  var title = _ref.title,\n      subtitle = _ref.subtitle,\n      graphic = _ref.graphic,\n      _ref$element = _ref.element,\n      Element = _ref$element === void 0 ? \'header\' : _ref$element,\n      children = _ref.children,\n      props = DrawerHeader_objectWithoutProperties(_ref, DrawerHeader_excluded);\n\n  return /*#__PURE__*/(0,jsx_runtime.jsxs)(Element, DrawerHeader_objectSpread(DrawerHeader_objectSpread({\n    ref: ref,\n    className: drawer_constants_cssClasses.HEADER\n  }, props), {}, {\n    children: [graphic && /*#__PURE__*/(0,jsx_runtime.jsx)(Clone, {\n      component: graphic,\n      className: drawer_constants_cssClasses.GRAPHIC\n    }), title && /*#__PURE__*/(0,jsx_runtime.jsx)(Clone, {\n      component: title,\n      fallback: "h3",\n      className: drawer_constants_cssClasses.TITLE\n    }), subtitle && /*#__PURE__*/(0,jsx_runtime.jsx)(Clone, {\n      component: subtitle,\n      fallback: "h6",\n      className: drawer_constants_cssClasses.SUBTITLE\n    }), children]\n  }));\n});\nDrawerHeader.displayName = \'MDCDrawerHeader\';\nDrawerHeader.propTypes = {\n  title: (prop_types_default()).node,\n  subtitle: (prop_types_default()).node,\n  graphic: (prop_types_default()).element\n};\n/* harmony default export */ const drawer_DrawerHeader = (DrawerHeader);\n;// CONCATENATED MODULE: ./src/drawer/DrawerContent.jsx\nvar DrawerContent_excluded = ["element"];\n\nfunction DrawerContent_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction DrawerContent_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { DrawerContent_ownKeys(Object(source), true).forEach(function (key) { DrawerContent_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { DrawerContent_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction DrawerContent_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction DrawerContent_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = DrawerContent_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction DrawerContent_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\nvar DrawerContent = /*#__PURE__*/(0,react.forwardRef)(function (_ref, ref) {\n  var _ref$element = _ref.element,\n      Element = _ref$element === void 0 ? \'div\' : _ref$element,\n      props = DrawerContent_objectWithoutProperties(_ref, DrawerContent_excluded);\n\n  return /*#__PURE__*/(0,jsx_runtime.jsx)(Element, DrawerContent_objectSpread({\n    ref: ref,\n    className: drawer_constants_cssClasses.CONTENT\n  }, props));\n});\nDrawerContent.displayName = \'MDCDrawerContent\';\n/* harmony default export */ const drawer_DrawerContent = (DrawerContent);\n;// CONCATENATED MODULE: ./src/drawer/index.js\n\n\n\ndrawer_Drawer.Header = drawer_DrawerHeader;\ndrawer_Drawer.Content = drawer_DrawerContent;\n\n;// CONCATENATED MODULE: ./src/elevation/constants.js\nvar elevation_constants_cssClasses = {\n  ROOT: \'mdc-elevation\',\n  Z: \'mdc-elevation--z\',\n  TRANSITION: \'mdc-elevation-transition\'\n};\n;// CONCATENATED MODULE: ./src/elevation/Elevation.jsx\nvar Elevation_excluded = ["z", "transition", "element", "component", "className"];\n\nfunction Elevation_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction Elevation_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { Elevation_ownKeys(Object(source), true).forEach(function (key) { Elevation_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { Elevation_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction Elevation_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction Elevation_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = Elevation_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction Elevation_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\nvar Elevation = /*#__PURE__*/(0,react.forwardRef)(function (_ref, ref) {\n  var _classnames;\n\n  var _ref$z = _ref.z,\n      z = _ref$z === void 0 ? 0 : _ref$z,\n      _ref$transition = _ref.transition,\n      transition = _ref$transition === void 0 ? false : _ref$transition,\n      _ref$element = _ref.element,\n      element = _ref$element === void 0 ? \'div\' : _ref$element,\n      _ref$component = _ref.component,\n      Element = _ref$component === void 0 ? element : _ref$component,\n      className = _ref.className,\n      props = Elevation_objectWithoutProperties(_ref, Elevation_excluded);\n\n  var classNames = classnames_default()(elevation_constants_cssClasses.ROOT, (_classnames = {}, Elevation_defineProperty(_classnames, "".concat(elevation_constants_cssClasses.Z).concat(z), z), Elevation_defineProperty(_classnames, elevation_constants_cssClasses.TRANSITION, transition), _classnames), className);\n  return /*#__PURE__*/(0,jsx_runtime.jsx)(Element, Elevation_objectSpread({\n    ref: ref,\n    className: classNames\n  }, props));\n});\nElevation.displayName = \'MDCElevation\';\n/* harmony default export */ const elevation_Elevation = (Elevation);\n;// CONCATENATED MODULE: ./src/elevation/index.js\n\n;// CONCATENATED MODULE: ./src/fab/constants.js\nvar fab_constants_cssClasses = {\n  ROOT: \'mdc-fab\',\n  MINI: \'mdc-fab--mini\',\n  EXTENDED: \'mdc-fab--extended\',\n  EXITED: \'mdc-fab--exited\',\n  ICON: \'mdc-fab__icon\',\n  LABEL: \'mdc-fab__label\',\n  RIPPLE: \'mdc-fab__ripple\'\n};\n;// CONCATENATED MODULE: ./src/fab/FAB.jsx\nvar FAB_excluded = ["icon", "label", "leadingIcon", "trailingIcon", "mini", "exited", "element", "component", "className", "children"];\n\nfunction FAB_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction FAB_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { FAB_ownKeys(Object(source), true).forEach(function (key) { FAB_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { FAB_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction FAB_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction FAB_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = FAB_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction FAB_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\n\n\n\n\nvar FAB = /*#__PURE__*/(0,react.forwardRef)(function (_ref, ref) {\n  var _classnames;\n\n  var icon = _ref.icon,\n      label = _ref.label,\n      _ref$leadingIcon = _ref.leadingIcon,\n      leadingIcon = _ref$leadingIcon === void 0 ? icon : _ref$leadingIcon,\n      trailingIcon = _ref.trailingIcon,\n      _ref$mini = _ref.mini,\n      mini = _ref$mini === void 0 ? false : _ref$mini,\n      _ref$exited = _ref.exited,\n      exited = _ref$exited === void 0 ? false : _ref$exited,\n      _ref$element = _ref.element,\n      element = _ref$element === void 0 ? \'button\' : _ref$element,\n      _ref$component = _ref.component,\n      Element = _ref$component === void 0 ? element : _ref$component,\n      className = _ref.className,\n      _ref$children = _ref.children,\n      children = _ref$children === void 0 ? label : _ref$children,\n      props = FAB_objectWithoutProperties(_ref, FAB_excluded);\n\n  var classNames = classnames_default()(fab_constants_cssClasses.ROOT, (_classnames = {}, FAB_defineProperty(_classnames, fab_constants_cssClasses.MINI, mini), FAB_defineProperty(_classnames, fab_constants_cssClasses.EXTENDED, label), FAB_defineProperty(_classnames, fab_constants_cssClasses.EXITED, exited), _classnames), className);\n  return /*#__PURE__*/(0,jsx_runtime.jsxs)(Element, FAB_objectSpread(FAB_objectSpread({\n    ref: ref,\n    className: classNames\n  }, props), {}, {\n    children: [/*#__PURE__*/(0,jsx_runtime.jsx)("div", {\n      className: fab_constants_cssClasses.RIPPLE\n    }), leadingIcon && /*#__PURE__*/(0,jsx_runtime.jsx)(Clone, {\n      component: leadingIcon,\n      fallback: icon_Icon,\n      className: fab_constants_cssClasses.ICON\n    }), children && /*#__PURE__*/(0,jsx_runtime.jsx)("span", {\n      className: fab_constants_cssClasses.LABEL,\n      children: children\n    }), trailingIcon && /*#__PURE__*/(0,jsx_runtime.jsx)(Clone, {\n      component: trailingIcon,\n      fallback: icon_Icon,\n      className: fab_constants_cssClasses.ICON\n    })]\n  }));\n});\nFAB.displayName = \'MDCFAB\';\nFAB.propTypes = {\n  icon: (prop_types_default()).node,\n  label: (prop_types_default()).node,\n  leadingIcon: (prop_types_default()).node,\n  trailingIcon: (prop_types_default()).node,\n  mini: (prop_types_default()).bool,\n  exited: (prop_types_default()).bool\n};\n/* harmony default export */ const fab_FAB = (FAB);\n;// CONCATENATED MODULE: ./src/fab/index.js\n\n;// CONCATENATED MODULE: ./src/form-field/constants.js\nvar form_field_constants_cssClasses = {\n  ROOT: \'mdc-form-field\',\n  ALIGN_END: \'mdc-form-field--align-end\',\n  NOWRAP: \'mdc-form-field--nowrap\',\n  SPACE_BETWEEN: \'mdc-form-field--space-between\'\n};\n;// CONCATENATED MODULE: ./src/form-field/FormField.jsx\nvar FormField_excluded = ["label", "alignEnd", "nowrap", "spaceBetween", "element", "className", "children"];\n\nfunction FormField_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction FormField_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { FormField_ownKeys(Object(source), true).forEach(function (key) { FormField_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { FormField_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction FormField_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction FormField_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = FormField_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction FormField_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\n\n\nvar FormField = /*#__PURE__*/(0,react.forwardRef)(function (_ref, ref) {\n  var _classnames;\n\n  var label = _ref.label,\n      _ref$alignEnd = _ref.alignEnd,\n      alignEnd = _ref$alignEnd === void 0 ? false : _ref$alignEnd,\n      _ref$nowrap = _ref.nowrap,\n      nowrap = _ref$nowrap === void 0 ? false : _ref$nowrap,\n      _ref$spaceBetween = _ref.spaceBetween,\n      spaceBetween = _ref$spaceBetween === void 0 ? false : _ref$spaceBetween,\n      _ref$element = _ref.element,\n      Element = _ref$element === void 0 ? \'div\' : _ref$element,\n      className = _ref.className,\n      children = _ref.children,\n      props = FormField_objectWithoutProperties(_ref, FormField_excluded);\n\n  var classNames = classnames_default()(form_field_constants_cssClasses.ROOT, (_classnames = {}, FormField_defineProperty(_classnames, form_field_constants_cssClasses.ALIGN_END, alignEnd), FormField_defineProperty(_classnames, form_field_constants_cssClasses.NOWRAP, nowrap), FormField_defineProperty(_classnames, form_field_constants_cssClasses.SPACE_BETWEEN, spaceBetween), _classnames), className);\n  return /*#__PURE__*/(0,jsx_runtime.jsxs)(Element, FormField_objectSpread(FormField_objectSpread({\n    ref: ref,\n    className: classNames\n  }, props), {}, {\n    children: [children, label && /*#__PURE__*/(0,jsx_runtime.jsx)("label", {\n      htmlFor: children.props.id,\n      children: label\n    })]\n  }));\n});\nFormField.displayName = \'MDCFormField\';\nFormField.propTypes = {\n  label: (prop_types_default()).node,\n  alignEnd: (prop_types_default()).bool,\n  nowrap: (prop_types_default()).bool,\n  spaceBetween: (prop_types_default()).bool,\n  children: (prop_types_default()).any.isRequired\n};\n/* harmony default export */ const form_field_FormField = (FormField);\n;// CONCATENATED MODULE: ./src/form-field/index.js\n\n;// CONCATENATED MODULE: ./src/image-list/constants.js\nvar image_list_constants_cssClasses = {\n  IMAGE_LIST: \'mdc-image-list\',\n  IMAGE_LIST_MASONRY: \'mdc-image-list--masonry\',\n  IMAGE_LIST_WITH_TEXT_PROTECTION: \'mdc-image-list--with-text-protection\',\n  IMAGE_LIST_ITEM: \'mdc-image-list__item\',\n  IMAGE_LIST_IMAGE_ASPECT_CONTAINER: \'mdc-image-list__image-aspect-container\',\n  IMAGE_LIST_IMAGE: \'mdc-image-list__image\',\n  IMAGE_LIST_SUPPORTING: \'mdc-image-list__supporting\',\n  IMAGE_LIST_LABEL: \'mdc-image-list__label\'\n};\n;// CONCATENATED MODULE: ./src/image-list/ImageListItem.jsx\nvar ImageListItem_excluded = ["imageSrc", "label", "fixedAspect", "element", "className"];\n\nfunction ImageListItem_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction ImageListItem_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ImageListItem_ownKeys(Object(source), true).forEach(function (key) { ImageListItem_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ImageListItem_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction ImageListItem_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction ImageListItem_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = ImageListItem_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction ImageListItem_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\n\n\nvar ImageListItem = /*#__PURE__*/(0,react.forwardRef)(function (_ref, ref) {\n  var imageSrc = _ref.imageSrc,\n      label = _ref.label,\n      _ref$fixedAspect = _ref.fixedAspect,\n      fixedAspect = _ref$fixedAspect === void 0 ? true : _ref$fixedAspect,\n      _ref$element = _ref.element,\n      Element = _ref$element === void 0 ? \'li\' : _ref$element,\n      className = _ref.className,\n      props = ImageListItem_objectWithoutProperties(_ref, ImageListItem_excluded);\n\n  var classNames = classnames_default()(image_list_constants_cssClasses.IMAGE_LIST_ITEM, className);\n  return /*#__PURE__*/(0,jsx_runtime.jsxs)(Element, ImageListItem_objectSpread(ImageListItem_objectSpread({\n    ref: ref,\n    className: classNames\n  }, props), {}, {\n    children: [fixedAspect ? /*#__PURE__*/(0,jsx_runtime.jsx)("div", {\n      className: image_list_constants_cssClasses.IMAGE_LIST_IMAGE_ASPECT_CONTAINER,\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)("img", {\n        className: image_list_constants_cssClasses.IMAGE_LIST_IMAGE,\n        src: imageSrc,\n        alt: label\n      })\n    }) : /*#__PURE__*/(0,jsx_runtime.jsx)("img", {\n      className: image_list_constants_cssClasses.IMAGE_LIST_IMAGE,\n      src: imageSrc,\n      alt: label\n    }), label && /*#__PURE__*/(0,jsx_runtime.jsx)("div", {\n      className: image_list_constants_cssClasses.IMAGE_LIST_SUPPORTING,\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)("span", {\n        className: image_list_constants_cssClasses.IMAGE_LIST_LABEL,\n        children: label\n      })\n    })]\n  }));\n});\nImageListItem.displayName = \'MDCImageListItem\';\nImageListItem.propTypes = {\n  imageSrc: (prop_types_default()).string,\n  label: (prop_types_default()).node,\n  fixedAspect: (prop_types_default()).bool\n};\n/* harmony default export */ const image_list_ImageListItem = (ImageListItem);\n;// CONCATENATED MODULE: ./src/image-list/ImageList.jsx\nvar ImageList_excluded = ["items", "masonry", "withTextProtection", "element", "className", "children"];\n\nfunction ImageList_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction ImageList_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ImageList_ownKeys(Object(source), true).forEach(function (key) { ImageList_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ImageList_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction ImageList_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction ImageList_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = ImageList_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction ImageList_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\n\n\n\nvar ImageList = /*#__PURE__*/(0,react.forwardRef)(function (_ref, ref) {\n  var _classnames;\n\n  var items = _ref.items,\n      _ref$masonry = _ref.masonry,\n      masonry = _ref$masonry === void 0 ? false : _ref$masonry,\n      _ref$withTextProtecti = _ref.withTextProtection,\n      withTextProtection = _ref$withTextProtecti === void 0 ? false : _ref$withTextProtecti,\n      _ref$element = _ref.element,\n      Element = _ref$element === void 0 ? \'ul\' : _ref$element,\n      className = _ref.className,\n      _ref$children = _ref.children,\n      children = _ref$children === void 0 ? items === null || items === void 0 ? void 0 : items.map(function (item) {\n    return (0,react.createElement)(image_list_ImageListItem, item);\n  }) : _ref$children,\n      props = ImageList_objectWithoutProperties(_ref, ImageList_excluded);\n\n  var classNames = classnames_default()(image_list_constants_cssClasses.IMAGE_LIST, (_classnames = {}, ImageList_defineProperty(_classnames, image_list_constants_cssClasses.IMAGE_LIST_MASONRY, masonry), ImageList_defineProperty(_classnames, image_list_constants_cssClasses.IMAGE_LIST_WITH_TEXT_PROTECTION, withTextProtection), _classnames), className);\n  return /*#__PURE__*/(0,jsx_runtime.jsx)(Element, ImageList_objectSpread(ImageList_objectSpread({\n    ref: ref,\n    className: classNames\n  }, props), {}, {\n    children: react.Children.map(children, function (child) {\n      return (0,react.cloneElement)(child, {\n        fixedAspect: masonry ? false : undefined\n      });\n    })\n  }));\n});\nImageList.displayName = \'MDCImageList\';\nImageList.propTypes = {\n  items: (prop_types_default()).array,\n  masonry: (prop_types_default()).bool,\n  withTextProtection: (prop_types_default()).bool\n};\n/* harmony default export */ const image_list_ImageList = (ImageList);\n;// CONCATENATED MODULE: ./src/image-list/index.js\n\n\nimage_list_ImageList.Item = image_list_ImageListItem;\n\n;// CONCATENATED MODULE: ./src/layout/constants.js\nvar layout_constants_cssClasses = {\n  ROOT: \'mdc-layout\',\n  ROW: \'mdc-layout--row\',\n  COLUMN: \'mdc-layout--column\',\n  DIRECTION: \'mdc-layout--direction\',\n  WRAP: \'mdc-layout--wrap\',\n  WRAP_REVERSE: \'mdc-layout--wrap-reverse\',\n  ALIGN_ITEMS: \'mdc-layout--align-items\',\n  ALIGN_SELF: \'mdc-layout--align-self\',\n  JUSTIFY_CONTENT: \'mdc-layout--justify-content\'\n};\n;// CONCATENATED MODULE: ./src/layout/Layout.jsx\nvar Layout_excluded = ["row", "column", "direction", "wrap", "alignItems", "alignSelf", "justifyContent", "element", "component", "className"];\n\nfunction Layout_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction Layout_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { Layout_ownKeys(Object(source), true).forEach(function (key) { Layout_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { Layout_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction Layout_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction Layout_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = Layout_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction Layout_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\n\nvar Layout = /*#__PURE__*/(0,react.forwardRef)(function (_ref, ref) {\n  var _classnames;\n\n  var row = _ref.row,\n      column = _ref.column,\n      direction = _ref.direction,\n      wrap = _ref.wrap,\n      alignItems = _ref.alignItems,\n      alignSelf = _ref.alignSelf,\n      justifyContent = _ref.justifyContent,\n      _ref$element = _ref.element,\n      element = _ref$element === void 0 ? \'div\' : _ref$element,\n      _ref$component = _ref.component,\n      Element = _ref$component === void 0 ? element : _ref$component,\n      className = _ref.className,\n      props = Layout_objectWithoutProperties(_ref, Layout_excluded);\n\n  var classNames = classnames_default()(layout_constants_cssClasses.ROOT, (_classnames = {}, Layout_defineProperty(_classnames, layout_constants_cssClasses.ROW, row), Layout_defineProperty(_classnames, layout_constants_cssClasses.COLUMN, column), Layout_defineProperty(_classnames, "".concat(layout_constants_cssClasses.DIRECTION, "--").concat(direction), direction), Layout_defineProperty(_classnames, layout_constants_cssClasses.WRAP, wrap === true), Layout_defineProperty(_classnames, layout_constants_cssClasses.WRAP_REVERSE, wrap === \'reverse\'), Layout_defineProperty(_classnames, "".concat(layout_constants_cssClasses.ALIGN_ITEMS, "--").concat(alignItems), alignItems), Layout_defineProperty(_classnames, "".concat(layout_constants_cssClasses.ALIGN_SELF, "--").concat(alignSelf), alignSelf), Layout_defineProperty(_classnames, "".concat(layout_constants_cssClasses.JUSTIFY_CONTENT, "--").concat(justifyContent), justifyContent), _classnames), className);\n  return /*#__PURE__*/(0,jsx_runtime.jsx)(Element, Layout_objectSpread({\n    ref: ref,\n    className: classNames\n  }, props));\n});\nLayout.displayName = \'MDCLayout\';\nLayout.propTypes = {\n  row: (prop_types_default()).bool,\n  column: (prop_types_default()).bool,\n  direction: prop_types_default().oneOf([\'row\', \'column\']),\n  wrap: prop_types_default().oneOfType([(prop_types_default()).bool, (prop_types_default()).string]),\n  alignItems: prop_types_default().oneOf([\'start\', \'center\', \'end\']),\n  alignSelf: prop_types_default().oneOf([\'start\', \'center\', \'end\']),\n  justifyContent: prop_types_default().oneOf([\'start\', \'center\', \'end\', \'around\', \'between\'])\n};\n/* harmony default export */ const layout_Layout = (Layout);\n;// CONCATENATED MODULE: ./src/layout/index.js\n\n;// CONCATENATED MODULE: ./src/layout-grid/constants.js\nvar layout_grid_constants_cssClasses = {\n  ROOT: \'mdc-layout-grid\',\n  ALIGN: \'mdc-layout-grid--align\',\n  FIXED_COLUMN_WIDTH: \'mdc-layout-grid--fixed-column-width\',\n  INNER: \'mdc-layout-grid__inner\',\n  CELL: \'mdc-layout-grid__cell\',\n  CELL_SPAN: \'mdc-layout-grid__cell--span\',\n  CELL_ORDER: \'mdc-layout-grid__cell--order\',\n  CELL_ALIGN: \'mdc-layout-grid__cell--align\'\n};\n;// CONCATENATED MODULE: ./src/layout-grid/LayoutGrid.jsx\nvar LayoutGrid_excluded = ["align", "fixedColumnWidth", "element", "component", "className", "children"];\n\nfunction LayoutGrid_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction LayoutGrid_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { LayoutGrid_ownKeys(Object(source), true).forEach(function (key) { LayoutGrid_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { LayoutGrid_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction LayoutGrid_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction LayoutGrid_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = LayoutGrid_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction LayoutGrid_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\n\nvar LayoutGrid = /*#__PURE__*/(0,react.forwardRef)(function (_ref, ref) {\n  var _classnames;\n\n  var align = _ref.align,\n      _ref$fixedColumnWidth = _ref.fixedColumnWidth,\n      fixedColumnWidth = _ref$fixedColumnWidth === void 0 ? false : _ref$fixedColumnWidth,\n      _ref$element = _ref.element,\n      element = _ref$element === void 0 ? \'div\' : _ref$element,\n      _ref$component = _ref.component,\n      component = _ref$component === void 0 ? element : _ref$component,\n      className = _ref.className,\n      children = _ref.children,\n      props = LayoutGrid_objectWithoutProperties(_ref, LayoutGrid_excluded);\n\n  var Element = component;\n  var classNames = classnames_default()(layout_grid_constants_cssClasses.ROOT, (_classnames = {}, LayoutGrid_defineProperty(_classnames, "".concat(layout_grid_constants_cssClasses.ALIGN, "-").concat(align), align), LayoutGrid_defineProperty(_classnames, layout_grid_constants_cssClasses.FIXED_COLUMN_WIDTH, fixedColumnWidth), _classnames), className);\n  return /*#__PURE__*/(0,jsx_runtime.jsx)(Element, LayoutGrid_objectSpread(LayoutGrid_objectSpread({\n    ref: ref,\n    className: classNames\n  }, props), {}, {\n    children: /*#__PURE__*/(0,jsx_runtime.jsx)("div", {\n      className: layout_grid_constants_cssClasses.INNER,\n      children: children\n    })\n  }));\n});\nLayoutGrid.displayName = \'MDCLayoutGrid\';\nLayoutGrid.propTypes = {\n  align: prop_types_default().oneOf([\'left\', \'right\']),\n  fixedColumnWidth: (prop_types_default()).bool\n};\n/* harmony default export */ const layout_grid_LayoutGrid = (LayoutGrid);\n;// CONCATENATED MODULE: ./src/layout-grid/LayoutGridCell.jsx\nvar LayoutGridCell_excluded = ["span", "desktop", "tablet", "mobile", "order", "align", "grid", "element", "component", "className", "children"];\n\nfunction LayoutGridCell_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction LayoutGridCell_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { LayoutGridCell_ownKeys(Object(source), true).forEach(function (key) { LayoutGridCell_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { LayoutGridCell_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction LayoutGridCell_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction LayoutGridCell_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = LayoutGridCell_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction LayoutGridCell_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\n\nvar LayoutGridCell = /*#__PURE__*/(0,react.forwardRef)(function (_ref, ref) {\n  var _classnames;\n\n  var span = _ref.span,\n      desktop = _ref.desktop,\n      tablet = _ref.tablet,\n      mobile = _ref.mobile,\n      order = _ref.order,\n      align = _ref.align,\n      _ref$grid = _ref.grid,\n      grid = _ref$grid === void 0 ? false : _ref$grid,\n      _ref$element = _ref.element,\n      element = _ref$element === void 0 ? \'div\' : _ref$element,\n      _ref$component = _ref.component,\n      component = _ref$component === void 0 ? element : _ref$component,\n      className = _ref.className,\n      children = _ref.children,\n      props = LayoutGridCell_objectWithoutProperties(_ref, LayoutGridCell_excluded);\n\n  var Element = component;\n  var classNames = classnames_default()(layout_grid_constants_cssClasses.CELL, (_classnames = {}, LayoutGridCell_defineProperty(_classnames, "".concat(layout_grid_constants_cssClasses.CELL_SPAN, "-").concat(span), span), LayoutGridCell_defineProperty(_classnames, "".concat(layout_grid_constants_cssClasses.CELL_SPAN, "-").concat(desktop, "-desktop"), desktop), LayoutGridCell_defineProperty(_classnames, "".concat(layout_grid_constants_cssClasses.CELL_SPAN, "-").concat(tablet, "-tablet"), tablet), LayoutGridCell_defineProperty(_classnames, "".concat(layout_grid_constants_cssClasses.CELL_SPAN, "-").concat(mobile, "-mobile"), mobile), LayoutGridCell_defineProperty(_classnames, "".concat(layout_grid_constants_cssClasses.CELL_ORDER, "-").concat(order), order), LayoutGridCell_defineProperty(_classnames, "".concat(layout_grid_constants_cssClasses.CELL_ALIGN, "-").concat(align), align), _classnames), className);\n  return /*#__PURE__*/(0,jsx_runtime.jsx)(Element, LayoutGridCell_objectSpread(LayoutGridCell_objectSpread({\n    ref: ref,\n    className: classNames\n  }, props), {}, {\n    children: grid ? /*#__PURE__*/(0,jsx_runtime.jsx)("div", {\n      className: layout_grid_constants_cssClasses.INNER,\n      children: children\n    }) : children\n  }));\n});\nLayoutGridCell.displayName = \'MDCLayoutGridCell\';\nLayoutGridCell.propTypes = {\n  span: prop_types_default().oneOfType([(prop_types_default()).number, (prop_types_default()).string]),\n  desktop: (prop_types_default()).number,\n  tablet: (prop_types_default()).number,\n  mobile: (prop_types_default()).number,\n  order: (prop_types_default()).number,\n  align: prop_types_default().oneOf([\'top\', \'middle\', \'bottom\']),\n  grid: (prop_types_default()).bool\n};\n/* harmony default export */ const layout_grid_LayoutGridCell = (LayoutGridCell);\n;// CONCATENATED MODULE: ./src/layout-grid/index.js\n\n\nlayout_grid_LayoutGrid.Cell = layout_grid_LayoutGridCell;\n\n;// CONCATENATED MODULE: ./src/radio/constants.js\nvar radio_constants_cssClasses = {\n  ROOT: \'mdc-radio\',\n  DISABLED: \'mdc-radio--disabled\',\n  TOUCH: \'mdc-radio--touch\',\n  NATIVE_CONTROL: \'mdc-radio__native-control\',\n  BACKGROUND: \'mdc-radio__background\',\n  OUTER_CIRCLE: \'mdc-radio__outer-circle\',\n  INNER_CIRCLE: \'mdc-radio__inner-circle\',\n  RIPPLE: \'mdc-radio__ripple\'\n};\n;// CONCATENATED MODULE: ./src/radio/Radio.jsx\nvar Radio_excluded = ["value", "checked", "disabled", "touch", "onChange", "className"];\n\nfunction Radio_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction Radio_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { Radio_ownKeys(Object(source), true).forEach(function (key) { Radio_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { Radio_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction Radio_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction Radio_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = Radio_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction Radio_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\n\n\nvar Radio = /*#__PURE__*/(0,react.forwardRef)(function (_ref, ref) {\n  var _classnames;\n\n  var value = _ref.value,\n      checked = _ref.checked,\n      _ref$disabled = _ref.disabled,\n      disabled = _ref$disabled === void 0 ? false : _ref$disabled,\n      _ref$touch = _ref.touch,\n      touch = _ref$touch === void 0 ? false : _ref$touch,\n      _ref$onChange = _ref.onChange,\n      onChange = _ref$onChange === void 0 ? Function.prototype : _ref$onChange,\n      className = _ref.className,\n      props = Radio_objectWithoutProperties(_ref, Radio_excluded);\n\n  var inputRef = (0,react.useRef)();\n  var handleChange = (0,react.useCallback)(function (event) {\n    onChange(event, event.target.value, event.target);\n  }, [onChange]);\n  var classNames = classnames_default()(radio_constants_cssClasses.ROOT, (_classnames = {}, Radio_defineProperty(_classnames, radio_constants_cssClasses.DISABLED, disabled), Radio_defineProperty(_classnames, radio_constants_cssClasses.TOUCH, touch), _classnames), className);\n  return /*#__PURE__*/(0,jsx_runtime.jsxs)("div", {\n    ref: ref,\n    className: classNames,\n    children: [/*#__PURE__*/(0,jsx_runtime.jsx)("input", Radio_objectSpread({\n      ref: inputRef,\n      className: radio_constants_cssClasses.NATIVE_CONTROL,\n      type: "radio",\n      value: value,\n      checked: checked,\n      disabled: disabled,\n      onChange: handleChange\n    }, props)), /*#__PURE__*/(0,jsx_runtime.jsxs)("div", {\n      className: radio_constants_cssClasses.BACKGROUND,\n      children: [/*#__PURE__*/(0,jsx_runtime.jsx)("div", {\n        className: radio_constants_cssClasses.OUTER_CIRCLE\n      }), /*#__PURE__*/(0,jsx_runtime.jsx)("div", {\n        className: radio_constants_cssClasses.INNER_CIRCLE\n      })]\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)("div", {\n      className: radio_constants_cssClasses.RIPPLE\n    })]\n  });\n});\nRadio.displayName = \'MDCRadio\';\nRadio.propTypes = {\n  value: (prop_types_default()).any,\n  checked: (prop_types_default()).bool,\n  disabled: (prop_types_default()).bool,\n  touch: (prop_types_default()).bool,\n  onChange: (prop_types_default()).func\n};\n/* harmony default export */ const radio_Radio = (Radio);\n;// CONCATENATED MODULE: ./src/radio/index.js\n\n;// CONCATENATED MODULE: ./node_modules/tslib/tslib.es6.js\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nfunction __extends(d, b) {\r\n    if (typeof b !== "function" && b !== null)\r\n        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nvar __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nfunction __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === "function")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nfunction __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nfunction __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nfunction __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nfunction __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nfunction __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError("Generator is already executing.");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nvar __createBinding = Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n});\r\n\r\nfunction __exportStar(m, o) {\r\n    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);\r\n}\r\n\r\nfunction __values(o) {\r\n    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === "number") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");\r\n}\r\n\r\nfunction __read(o, n) {\r\n    var m = typeof Symbol === "function" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i["return"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nfunction __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nfunction __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n}\r\n\r\nfunction __spreadArray(to, from, pack) {\r\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\r\n        if (ar || !(i in from)) {\r\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\r\n            ar[i] = from[i];\r\n        }\r\n    }\r\n    return to.concat(ar || Array.prototype.slice.call(from));\r\n}\r\n\r\nfunction __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nfunction __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume("next", value); }\r\n    function reject(value) { resume("throw", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nfunction __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nfunction __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nfunction __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nvar __setModuleDefault = Object.create ? (function(o, v) {\r\n    Object.defineProperty(o, "default", { enumerable: true, value: v });\r\n}) : function(o, v) {\r\n    o["default"] = v;\r\n};\r\n\r\nfunction __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\r\n    __setModuleDefault(result, mod);\r\n    return result;\r\n}\r\n\r\nfunction __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nfunction __classPrivateFieldGet(receiver, state, kind, f) {\r\n    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");\r\n    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");\r\n    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);\r\n}\r\n\r\nfunction __classPrivateFieldSet(receiver, state, value, kind, f) {\r\n    if (kind === "m") throw new TypeError("Private method is not writable");\r\n    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");\r\n    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");\r\n    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\r\n}\r\n\n;// CONCATENATED MODULE: ./node_modules/@material/base/foundation.js\n/**\n * @license\n * Copyright 2016 Google Inc.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the "Software"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\nvar MDCFoundation = /** @class */ (function () {\n    function MDCFoundation(adapter) {\n        if (adapter === void 0) { adapter = {}; }\n        this.adapter = adapter;\n    }\n    Object.defineProperty(MDCFoundation, "cssClasses", {\n        get: function () {\n            // Classes extending MDCFoundation should implement this method to return an object which exports every\n            // CSS class the foundation class needs as a property. e.g. {ACTIVE: \'mdc-component--active\'}\n            return {};\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(MDCFoundation, "strings", {\n        get: function () {\n            // Classes extending MDCFoundation should implement this method to return an object which exports all\n            // semantic strings as constants. e.g. {ARIA_ROLE: \'tablist\'}\n            return {};\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(MDCFoundation, "numbers", {\n        get: function () {\n            // Classes extending MDCFoundation should implement this method to return an object which exports all\n            // of its semantic numbers as constants. e.g. {ANIMATION_DELAY_MS: 350}\n            return {};\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(MDCFoundation, "defaultAdapter", {\n        get: function () {\n            // Classes extending MDCFoundation may choose to implement this getter in order to provide a convenient\n            // way of viewing the necessary methods of an adapter. In the future, this could also be used for adapter\n            // validation.\n            return {};\n        },\n        enumerable: false,\n        configurable: true\n    });\n    MDCFoundation.prototype.init = function () {\n        // Subclasses should override this method to perform initialization routines (registering events, etc.)\n    };\n    MDCFoundation.prototype.destroy = function () {\n        // Subclasses should override this method to perform de-initialization routines (de-registering events, etc.)\n    };\n    return MDCFoundation;\n}());\n\n// tslint:disable-next-line:no-default-export Needed for backward compatibility with MDC Web v0.44.0 and earlier.\n/* harmony default export */ const foundation = ((/* unused pure expression or super */ null && (MDCFoundation)));\n//# sourceMappingURL=foundation.js.map\n;// CONCATENATED MODULE: ./node_modules/@material/base/component.js\n/**\n * @license\n * Copyright 2016 Google Inc.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the "Software"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\n\n\nvar MDCComponent = /** @class */ (function () {\n    function MDCComponent(root, foundation) {\n        var args = [];\n        for (var _i = 2; _i < arguments.length; _i++) {\n            args[_i - 2] = arguments[_i];\n        }\n        this.root = root;\n        this.initialize.apply(this, __spreadArray([], __read(args)));\n        // Note that we initialize foundation here and not within the constructor\'s\n        // default param so that this.root is defined and can be used within the\n        // foundation class.\n        this.foundation =\n            foundation === undefined ? this.getDefaultFoundation() : foundation;\n        this.foundation.init();\n        this.initialSyncWithDOM();\n    }\n    MDCComponent.attachTo = function (root) {\n        // Subclasses which extend MDCBase should provide an attachTo() method that takes a root element and\n        // returns an instantiated component with its root set to that element. Also note that in the cases of\n        // subclasses, an explicit foundation class will not have to be passed in; it will simply be initialized\n        // from getDefaultFoundation().\n        return new MDCComponent(root, new MDCFoundation({}));\n    };\n    /* istanbul ignore next: method param only exists for typing purposes; it does not need to be unit tested */\n    MDCComponent.prototype.initialize = function () {\n        var _args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            _args[_i] = arguments[_i];\n        }\n        // Subclasses can override this to do any additional setup work that would be considered part of a\n        // "constructor". Essentially, it is a hook into the parent constructor before the foundation is\n        // initialized. Any additional arguments besides root and foundation will be passed in here.\n    };\n    MDCComponent.prototype.getDefaultFoundation = function () {\n        // Subclasses must override this method to return a properly configured foundation class for the\n        // component.\n        throw new Error(\'Subclasses must override getDefaultFoundation to return a properly configured \' +\n            \'foundation class\');\n    };\n    MDCComponent.prototype.initialSyncWithDOM = function () {\n        // Subclasses should override this method if they need to perform work to synchronize with a host DOM\n        // object. An example of this would be a form control wrapper that needs to synchronize its internal state\n        // to some property or attribute of the host DOM. Please note: this is *not* the place to perform DOM\n        // reads/writes that would cause layout / paint, as this is called synchronously from within the constructor.\n    };\n    MDCComponent.prototype.destroy = function () {\n        // Subclasses may implement this method to release any resources / deregister any listeners they have\n        // attached. An example of this might be deregistering a resize event from the window object.\n        this.foundation.destroy();\n    };\n    MDCComponent.prototype.listen = function (evtType, handler, options) {\n        this.root.addEventListener(evtType, handler, options);\n    };\n    MDCComponent.prototype.unlisten = function (evtType, handler, options) {\n        this.root.removeEventListener(evtType, handler, options);\n    };\n    /**\n     * Fires a cross-browser-compatible custom event from the component root of the given type, with the given data.\n     */\n    MDCComponent.prototype.emit = function (evtType, evtData, shouldBubble) {\n        if (shouldBubble === void 0) { shouldBubble = false; }\n        var evt;\n        if (typeof CustomEvent === \'function\') {\n            evt = new CustomEvent(evtType, {\n                bubbles: shouldBubble,\n                detail: evtData,\n            });\n        }\n        else {\n            evt = document.createEvent(\'CustomEvent\');\n            evt.initCustomEvent(evtType, shouldBubble, false, evtData);\n        }\n        this.root.dispatchEvent(evt);\n    };\n    return MDCComponent;\n}());\n\n// tslint:disable-next-line:no-default-export Needed for backward compatibility with MDC Web v0.44.0 and earlier.\n/* harmony default export */ const component = ((/* unused pure expression or super */ null && (MDCComponent)));\n//# sourceMappingURL=component.js.map\n;// CONCATENATED MODULE: ./node_modules/@material/dom/events.js\n/**\n * @license\n * Copyright 2019 Google Inc.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the "Software"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\n/**\n * Determine whether the current browser supports passive event listeners, and\n * if so, use them.\n */\nfunction applyPassive(globalObj) {\n    if (globalObj === void 0) { globalObj = window; }\n    return supportsPassiveOption(globalObj) ?\n        { passive: true } :\n        false;\n}\nfunction supportsPassiveOption(globalObj) {\n    if (globalObj === void 0) { globalObj = window; }\n    // See\n    // https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener\n    var passiveSupported = false;\n    try {\n        var options = {\n            // This function will be called when the browser\n            // attempts to access the passive property.\n            get passive() {\n                passiveSupported = true;\n                return false;\n            }\n        };\n        var handler = function () { };\n        globalObj.document.addEventListener(\'test\', handler, options);\n        globalObj.document.removeEventListener(\'test\', handler, options);\n    }\n    catch (err) {\n        passiveSupported = false;\n    }\n    return passiveSupported;\n}\n//# sourceMappingURL=events.js.map\n;// CONCATENATED MODULE: ./node_modules/@material/dom/ponyfill.js\n/**\n * @license\n * Copyright 2018 Google Inc.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the "Software"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\n/**\n * @fileoverview A "ponyfill" is a polyfill that doesn\'t modify the global prototype chain.\n * This makes ponyfills safer than traditional polyfills, especially for libraries like MDC.\n */\nfunction closest(element, selector) {\n    if (element.closest) {\n        return element.closest(selector);\n    }\n    var el = element;\n    while (el) {\n        if (matches(el, selector)) {\n            return el;\n        }\n        el = el.parentElement;\n    }\n    return null;\n}\nfunction matches(element, selector) {\n    var nativeMatches = element.matches\n        || element.webkitMatchesSelector\n        || element.msMatchesSelector;\n    return nativeMatches.call(element, selector);\n}\n/**\n * Used to compute the estimated scroll width of elements. When an element is\n * hidden due to display: none; being applied to a parent element, the width is\n * returned as 0. However, the element will have a true width once no longer\n * inside a display: none context. This method computes an estimated width when\n * the element is hidden or returns the true width when the element is visble.\n * @param {Element} element the element whose width to estimate\n */\nfunction estimateScrollWidth(element) {\n    // Check the offsetParent. If the element inherits display: none from any\n    // parent, the offsetParent property will be null (see\n    // https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/offsetParent).\n    // This check ensures we only clone the node when necessary.\n    var htmlEl = element;\n    if (htmlEl.offsetParent !== null) {\n        return htmlEl.scrollWidth;\n    }\n    var clone = htmlEl.cloneNode(true);\n    clone.style.setProperty(\'position\', \'absolute\');\n    clone.style.setProperty(\'transform\', \'translate(-9999px, -9999px)\');\n    document.documentElement.appendChild(clone);\n    var scrollWidth = clone.scrollWidth;\n    document.documentElement.removeChild(clone);\n    return scrollWidth;\n}\n//# sourceMappingURL=ponyfill.js.map\n;// CONCATENATED MODULE: ./node_modules/@material/ripple/constants.js\n/**\n * @license\n * Copyright 2016 Google Inc.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the "Software"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\nvar ripple_constants_cssClasses = {\n    // Ripple is a special case where the "root" component is really a "mixin" of sorts,\n    // given that it\'s an \'upgrade\' to an existing component. That being said it is the root\n    // CSS class that all other CSS classes derive from.\n    BG_FOCUSED: \'mdc-ripple-upgraded--background-focused\',\n    FG_ACTIVATION: \'mdc-ripple-upgraded--foreground-activation\',\n    FG_DEACTIVATION: \'mdc-ripple-upgraded--foreground-deactivation\',\n    ROOT: \'mdc-ripple-upgraded\',\n    UNBOUNDED: \'mdc-ripple-upgraded--unbounded\',\n};\nvar constants_strings = {\n    VAR_FG_SCALE: \'--mdc-ripple-fg-scale\',\n    VAR_FG_SIZE: \'--mdc-ripple-fg-size\',\n    VAR_FG_TRANSLATE_END: \'--mdc-ripple-fg-translate-end\',\n    VAR_FG_TRANSLATE_START: \'--mdc-ripple-fg-translate-start\',\n    VAR_LEFT: \'--mdc-ripple-left\',\n    VAR_TOP: \'--mdc-ripple-top\',\n};\nvar ripple_constants_numbers = {\n    DEACTIVATION_TIMEOUT_MS: 225,\n    FG_DEACTIVATION_MS: 150,\n    INITIAL_ORIGIN_SCALE: 0.6,\n    PADDING: 10,\n    TAP_DELAY_MS: 300, // Delay between touch and simulated mouse events on touch devices\n};\n//# sourceMappingURL=constants.js.map\n;// CONCATENATED MODULE: ./node_modules/@material/ripple/util.js\n/**\n * Stores result from supportsCssVariables to avoid redundant processing to\n * detect CSS custom variable support.\n */\nvar supportsCssVariables_;\nfunction supportsCssVariables(windowObj, forceRefresh) {\n    if (forceRefresh === void 0) { forceRefresh = false; }\n    var CSS = windowObj.CSS;\n    var supportsCssVars = supportsCssVariables_;\n    if (typeof supportsCssVariables_ === \'boolean\' && !forceRefresh) {\n        return supportsCssVariables_;\n    }\n    var supportsFunctionPresent = CSS && typeof CSS.supports === \'function\';\n    if (!supportsFunctionPresent) {\n        return false;\n    }\n    var explicitlySupportsCssVars = CSS.supports(\'--css-vars\', \'yes\');\n    // See: https://bugs.webkit.org/show_bug.cgi?id=154669\n    // See: README section on Safari\n    var weAreFeatureDetectingSafari10plus = (CSS.supports(\'(--css-vars: yes)\') &&\n        CSS.supports(\'color\', \'#00000000\'));\n    supportsCssVars =\n        explicitlySupportsCssVars || weAreFeatureDetectingSafari10plus;\n    if (!forceRefresh) {\n        supportsCssVariables_ = supportsCssVars;\n    }\n    return supportsCssVars;\n}\nfunction getNormalizedEventCoords(evt, pageOffset, clientRect) {\n    if (!evt) {\n        return { x: 0, y: 0 };\n    }\n    var x = pageOffset.x, y = pageOffset.y;\n    var documentX = x + clientRect.left;\n    var documentY = y + clientRect.top;\n    var normalizedX;\n    var normalizedY;\n    // Determine touch point relative to the ripple container.\n    if (evt.type === \'touchstart\') {\n        var touchEvent = evt;\n        normalizedX = touchEvent.changedTouches[0].pageX - documentX;\n        normalizedY = touchEvent.changedTouches[0].pageY - documentY;\n    }\n    else {\n        var mouseEvent = evt;\n        normalizedX = mouseEvent.pageX - documentX;\n        normalizedY = mouseEvent.pageY - documentY;\n    }\n    return { x: normalizedX, y: normalizedY };\n}\n//# sourceMappingURL=util.js.map\n;// CONCATENATED MODULE: ./node_modules/@material/ripple/foundation.js\n/**\n * @license\n * Copyright 2016 Google Inc.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the "Software"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\n\n\n\n\n// Activation events registered on the root element of each instance for activation\nvar ACTIVATION_EVENT_TYPES = [\n    \'touchstart\', \'pointerdown\', \'mousedown\', \'keydown\',\n];\n// Deactivation events registered on documentElement when a pointer-related down event occurs\nvar POINTER_DEACTIVATION_EVENT_TYPES = [\n    \'touchend\', \'pointerup\', \'mouseup\', \'contextmenu\',\n];\n// simultaneous nested activations\nvar activatedTargets = [];\nvar MDCRippleFoundation = /** @class */ (function (_super) {\n    __extends(MDCRippleFoundation, _super);\n    function MDCRippleFoundation(adapter) {\n        var _this = _super.call(this, __assign(__assign({}, MDCRippleFoundation.defaultAdapter), adapter)) || this;\n        _this.activationAnimationHasEnded = false;\n        _this.activationTimer = 0;\n        _this.fgDeactivationRemovalTimer = 0;\n        _this.fgScale = \'0\';\n        _this.frame = { width: 0, height: 0 };\n        _this.initialSize = 0;\n        _this.layoutFrame = 0;\n        _this.maxRadius = 0;\n        _this.unboundedCoords = { left: 0, top: 0 };\n        _this.activationState = _this.defaultActivationState();\n        _this.activationTimerCallback = function () {\n            _this.activationAnimationHasEnded = true;\n            _this.runDeactivationUXLogicIfReady();\n        };\n        _this.activateHandler = function (e) {\n            _this.activateImpl(e);\n        };\n        _this.deactivateHandler = function () {\n            _this.deactivateImpl();\n        };\n        _this.focusHandler = function () {\n            _this.handleFocus();\n        };\n        _this.blurHandler = function () {\n            _this.handleBlur();\n        };\n        _this.resizeHandler = function () {\n            _this.layout();\n        };\n        return _this;\n    }\n    Object.defineProperty(MDCRippleFoundation, "cssClasses", {\n        get: function () {\n            return ripple_constants_cssClasses;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(MDCRippleFoundation, "strings", {\n        get: function () {\n            return constants_strings;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(MDCRippleFoundation, "numbers", {\n        get: function () {\n            return ripple_constants_numbers;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(MDCRippleFoundation, "defaultAdapter", {\n        get: function () {\n            return {\n                addClass: function () { return undefined; },\n                browserSupportsCssVars: function () { return true; },\n                computeBoundingRect: function () {\n                    return ({ top: 0, right: 0, bottom: 0, left: 0, width: 0, height: 0 });\n                },\n                containsEventTarget: function () { return true; },\n                deregisterDocumentInteractionHandler: function () { return undefined; },\n                deregisterInteractionHandler: function () { return undefined; },\n                deregisterResizeHandler: function () { return undefined; },\n                getWindowPageOffset: function () { return ({ x: 0, y: 0 }); },\n                isSurfaceActive: function () { return true; },\n                isSurfaceDisabled: function () { return true; },\n                isUnbounded: function () { return true; },\n                registerDocumentInteractionHandler: function () { return undefined; },\n                registerInteractionHandler: function () { return undefined; },\n                registerResizeHandler: function () { return undefined; },\n                removeClass: function () { return undefined; },\n                updateCssVariable: function () { return undefined; },\n            };\n        },\n        enumerable: false,\n        configurable: true\n    });\n    MDCRippleFoundation.prototype.init = function () {\n        var _this = this;\n        var supportsPressRipple = this.supportsPressRipple();\n        this.registerRootHandlers(supportsPressRipple);\n        if (supportsPressRipple) {\n            var _a = MDCRippleFoundation.cssClasses, ROOT_1 = _a.ROOT, UNBOUNDED_1 = _a.UNBOUNDED;\n            requestAnimationFrame(function () {\n                _this.adapter.addClass(ROOT_1);\n                if (_this.adapter.isUnbounded()) {\n                    _this.adapter.addClass(UNBOUNDED_1);\n                    // Unbounded ripples need layout logic applied immediately to set coordinates for both shade and ripple\n                    _this.layoutInternal();\n                }\n            });\n        }\n    };\n    MDCRippleFoundation.prototype.destroy = function () {\n        var _this = this;\n        if (this.supportsPressRipple()) {\n            if (this.activationTimer) {\n                clearTimeout(this.activationTimer);\n                this.activationTimer = 0;\n                this.adapter.removeClass(MDCRippleFoundation.cssClasses.FG_ACTIVATION);\n            }\n            if (this.fgDeactivationRemovalTimer) {\n                clearTimeout(this.fgDeactivationRemovalTimer);\n                this.fgDeactivationRemovalTimer = 0;\n                this.adapter.removeClass(MDCRippleFoundation.cssClasses.FG_DEACTIVATION);\n            }\n            var _a = MDCRippleFoundation.cssClasses, ROOT_2 = _a.ROOT, UNBOUNDED_2 = _a.UNBOUNDED;\n            requestAnimationFrame(function () {\n                _this.adapter.removeClass(ROOT_2);\n                _this.adapter.removeClass(UNBOUNDED_2);\n                _this.removeCssVars();\n            });\n        }\n        this.deregisterRootHandlers();\n        this.deregisterDeactivationHandlers();\n    };\n    /**\n     * @param evt Optional event containing position information.\n     */\n    MDCRippleFoundation.prototype.activate = function (evt) {\n        this.activateImpl(evt);\n    };\n    MDCRippleFoundation.prototype.deactivate = function () {\n        this.deactivateImpl();\n    };\n    MDCRippleFoundation.prototype.layout = function () {\n        var _this = this;\n        if (this.layoutFrame) {\n            cancelAnimationFrame(this.layoutFrame);\n        }\n        this.layoutFrame = requestAnimationFrame(function () {\n            _this.layoutInternal();\n            _this.layoutFrame = 0;\n        });\n    };\n    MDCRippleFoundation.prototype.setUnbounded = function (unbounded) {\n        var UNBOUNDED = MDCRippleFoundation.cssClasses.UNBOUNDED;\n        if (unbounded) {\n            this.adapter.addClass(UNBOUNDED);\n        }\n        else {\n            this.adapter.removeClass(UNBOUNDED);\n        }\n    };\n    MDCRippleFoundation.prototype.handleFocus = function () {\n        var _this = this;\n        requestAnimationFrame(function () { return _this.adapter.addClass(MDCRippleFoundation.cssClasses.BG_FOCUSED); });\n    };\n    MDCRippleFoundation.prototype.handleBlur = function () {\n        var _this = this;\n        requestAnimationFrame(function () { return _this.adapter.removeClass(MDCRippleFoundation.cssClasses.BG_FOCUSED); });\n    };\n    /**\n     * We compute this property so that we are not querying information about the client\n     * until the point in time where the foundation requests it. This prevents scenarios where\n     * client-side feature-detection may happen too early, such as when components are rendered on the server\n     * and then initialized at mount time on the client.\n     */\n    MDCRippleFoundation.prototype.supportsPressRipple = function () {\n        return this.adapter.browserSupportsCssVars();\n    };\n    MDCRippleFoundation.prototype.defaultActivationState = function () {\n        return {\n            activationEvent: undefined,\n            hasDeactivationUXRun: false,\n            isActivated: false,\n            isProgrammatic: false,\n            wasActivatedByPointer: false,\n            wasElementMadeActive: false,\n        };\n    };\n    /**\n     * supportsPressRipple Passed from init to save a redundant function call\n     */\n    MDCRippleFoundation.prototype.registerRootHandlers = function (supportsPressRipple) {\n        var e_1, _a;\n        if (supportsPressRipple) {\n            try {\n                for (var ACTIVATION_EVENT_TYPES_1 = __values(ACTIVATION_EVENT_TYPES), ACTIVATION_EVENT_TYPES_1_1 = ACTIVATION_EVENT_TYPES_1.next(); !ACTIVATION_EVENT_TYPES_1_1.done; ACTIVATION_EVENT_TYPES_1_1 = ACTIVATION_EVENT_TYPES_1.next()) {\n                    var evtType = ACTIVATION_EVENT_TYPES_1_1.value;\n                    this.adapter.registerInteractionHandler(evtType, this.activateHandler);\n                }\n            }\n            catch (e_1_1) { e_1 = { error: e_1_1 }; }\n            finally {\n                try {\n                    if (ACTIVATION_EVENT_TYPES_1_1 && !ACTIVATION_EVENT_TYPES_1_1.done && (_a = ACTIVATION_EVENT_TYPES_1.return)) _a.call(ACTIVATION_EVENT_TYPES_1);\n                }\n                finally { if (e_1) throw e_1.error; }\n            }\n            if (this.adapter.isUnbounded()) {\n                this.adapter.registerResizeHandler(this.resizeHandler);\n            }\n        }\n        this.adapter.registerInteractionHandler(\'focus\', this.focusHandler);\n        this.adapter.registerInteractionHandler(\'blur\', this.blurHandler);\n    };\n    MDCRippleFoundation.prototype.registerDeactivationHandlers = function (evt) {\n        var e_2, _a;\n        if (evt.type === \'keydown\') {\n            this.adapter.registerInteractionHandler(\'keyup\', this.deactivateHandler);\n        }\n        else {\n            try {\n                for (var POINTER_DEACTIVATION_EVENT_TYPES_1 = __values(POINTER_DEACTIVATION_EVENT_TYPES), POINTER_DEACTIVATION_EVENT_TYPES_1_1 = POINTER_DEACTIVATION_EVENT_TYPES_1.next(); !POINTER_DEACTIVATION_EVENT_TYPES_1_1.done; POINTER_DEACTIVATION_EVENT_TYPES_1_1 = POINTER_DEACTIVATION_EVENT_TYPES_1.next()) {\n                    var evtType = POINTER_DEACTIVATION_EVENT_TYPES_1_1.value;\n                    this.adapter.registerDocumentInteractionHandler(evtType, this.deactivateHandler);\n                }\n            }\n            catch (e_2_1) { e_2 = { error: e_2_1 }; }\n            finally {\n                try {\n                    if (POINTER_DEACTIVATION_EVENT_TYPES_1_1 && !POINTER_DEACTIVATION_EVENT_TYPES_1_1.done && (_a = POINTER_DEACTIVATION_EVENT_TYPES_1.return)) _a.call(POINTER_DEACTIVATION_EVENT_TYPES_1);\n                }\n                finally { if (e_2) throw e_2.error; }\n            }\n        }\n    };\n    MDCRippleFoundation.prototype.deregisterRootHandlers = function () {\n        var e_3, _a;\n        try {\n            for (var ACTIVATION_EVENT_TYPES_2 = __values(ACTIVATION_EVENT_TYPES), ACTIVATION_EVENT_TYPES_2_1 = ACTIVATION_EVENT_TYPES_2.next(); !ACTIVATION_EVENT_TYPES_2_1.done; ACTIVATION_EVENT_TYPES_2_1 = ACTIVATION_EVENT_TYPES_2.next()) {\n                var evtType = ACTIVATION_EVENT_TYPES_2_1.value;\n                this.adapter.deregisterInteractionHandler(evtType, this.activateHandler);\n            }\n        }\n        catch (e_3_1) { e_3 = { error: e_3_1 }; }\n        finally {\n            try {\n                if (ACTIVATION_EVENT_TYPES_2_1 && !ACTIVATION_EVENT_TYPES_2_1.done && (_a = ACTIVATION_EVENT_TYPES_2.return)) _a.call(ACTIVATION_EVENT_TYPES_2);\n            }\n            finally { if (e_3) throw e_3.error; }\n        }\n        this.adapter.deregisterInteractionHandler(\'focus\', this.focusHandler);\n        this.adapter.deregisterInteractionHandler(\'blur\', this.blurHandler);\n        if (this.adapter.isUnbounded()) {\n            this.adapter.deregisterResizeHandler(this.resizeHandler);\n        }\n    };\n    MDCRippleFoundation.prototype.deregisterDeactivationHandlers = function () {\n        var e_4, _a;\n        this.adapter.deregisterInteractionHandler(\'keyup\', this.deactivateHandler);\n        try {\n            for (var POINTER_DEACTIVATION_EVENT_TYPES_2 = __values(POINTER_DEACTIVATION_EVENT_TYPES), POINTER_DEACTIVATION_EVENT_TYPES_2_1 = POINTER_DEACTIVATION_EVENT_TYPES_2.next(); !POINTER_DEACTIVATION_EVENT_TYPES_2_1.done; POINTER_DEACTIVATION_EVENT_TYPES_2_1 = POINTER_DEACTIVATION_EVENT_TYPES_2.next()) {\n                var evtType = POINTER_DEACTIVATION_EVENT_TYPES_2_1.value;\n                this.adapter.deregisterDocumentInteractionHandler(evtType, this.deactivateHandler);\n            }\n        }\n        catch (e_4_1) { e_4 = { error: e_4_1 }; }\n        finally {\n            try {\n                if (POINTER_DEACTIVATION_EVENT_TYPES_2_1 && !POINTER_DEACTIVATION_EVENT_TYPES_2_1.done && (_a = POINTER_DEACTIVATION_EVENT_TYPES_2.return)) _a.call(POINTER_DEACTIVATION_EVENT_TYPES_2);\n            }\n            finally { if (e_4) throw e_4.error; }\n        }\n    };\n    MDCRippleFoundation.prototype.removeCssVars = function () {\n        var _this = this;\n        var rippleStrings = MDCRippleFoundation.strings;\n        var keys = Object.keys(rippleStrings);\n        keys.forEach(function (key) {\n            if (key.indexOf(\'VAR_\') === 0) {\n                _this.adapter.updateCssVariable(rippleStrings[key], null);\n            }\n        });\n    };\n    MDCRippleFoundation.prototype.activateImpl = function (evt) {\n        var _this = this;\n        if (this.adapter.isSurfaceDisabled()) {\n            return;\n        }\n        var activationState = this.activationState;\n        if (activationState.isActivated) {\n            return;\n        }\n        // Avoid reacting to follow-on events fired by touch device after an already-processed user interaction\n        var previousActivationEvent = this.previousActivationEvent;\n        var isSameInteraction = previousActivationEvent && evt !== undefined && previousActivationEvent.type !== evt.type;\n        if (isSameInteraction) {\n            return;\n        }\n        activationState.isActivated = true;\n        activationState.isProgrammatic = evt === undefined;\n        activationState.activationEvent = evt;\n        activationState.wasActivatedByPointer = activationState.isProgrammatic ? false : evt !== undefined && (evt.type === \'mousedown\' || evt.type === \'touchstart\' || evt.type === \'pointerdown\');\n        var hasActivatedChild = evt !== undefined &&\n            activatedTargets.length > 0 &&\n            activatedTargets.some(function (target) { return _this.adapter.containsEventTarget(target); });\n        if (hasActivatedChild) {\n            // Immediately reset activation state, while preserving logic that prevents touch follow-on events\n            this.resetActivationState();\n            return;\n        }\n        if (evt !== undefined) {\n            activatedTargets.push(evt.target);\n            this.registerDeactivationHandlers(evt);\n        }\n        activationState.wasElementMadeActive = this.checkElementMadeActive(evt);\n        if (activationState.wasElementMadeActive) {\n            this.animateActivation();\n        }\n        requestAnimationFrame(function () {\n            // Reset array on next frame after the current event has had a chance to bubble to prevent ancestor ripples\n            activatedTargets = [];\n            if (!activationState.wasElementMadeActive\n                && evt !== undefined\n                && (evt.key === \' \' || evt.keyCode === 32)) {\n                // If space was pressed, try again within an rAF call to detect :active, because different UAs report\n                // active states inconsistently when they\'re called within event handling code:\n                // - https://bugs.chromium.org/p/chromium/issues/detail?id=635971\n                // - https://bugzilla.mozilla.org/show_bug.cgi?id=1293741\n                // We try first outside rAF to support Edge, which does not exhibit this problem, but will crash if a CSS\n                // variable is set within a rAF callback for a submit button interaction (#2241).\n                activationState.wasElementMadeActive = _this.checkElementMadeActive(evt);\n                if (activationState.wasElementMadeActive) {\n                    _this.animateActivation();\n                }\n            }\n            if (!activationState.wasElementMadeActive) {\n                // Reset activation state immediately if element was not made active.\n                _this.activationState = _this.defaultActivationState();\n            }\n        });\n    };\n    MDCRippleFoundation.prototype.checkElementMadeActive = function (evt) {\n        return (evt !== undefined && evt.type === \'keydown\') ?\n            this.adapter.isSurfaceActive() :\n            true;\n    };\n    MDCRippleFoundation.prototype.animateActivation = function () {\n        var _this = this;\n        var _a = MDCRippleFoundation.strings, VAR_FG_TRANSLATE_START = _a.VAR_FG_TRANSLATE_START, VAR_FG_TRANSLATE_END = _a.VAR_FG_TRANSLATE_END;\n        var _b = MDCRippleFoundation.cssClasses, FG_DEACTIVATION = _b.FG_DEACTIVATION, FG_ACTIVATION = _b.FG_ACTIVATION;\n        var DEACTIVATION_TIMEOUT_MS = MDCRippleFoundation.numbers.DEACTIVATION_TIMEOUT_MS;\n        this.layoutInternal();\n        var translateStart = \'\';\n        var translateEnd = \'\';\n        if (!this.adapter.isUnbounded()) {\n            var _c = this.getFgTranslationCoordinates(), startPoint = _c.startPoint, endPoint = _c.endPoint;\n            translateStart = startPoint.x + "px, " + startPoint.y + "px";\n            translateEnd = endPoint.x + "px, " + endPoint.y + "px";\n        }\n        this.adapter.updateCssVariable(VAR_FG_TRANSLATE_START, translateStart);\n        this.adapter.updateCssVariable(VAR_FG_TRANSLATE_END, translateEnd);\n        // Cancel any ongoing activation/deactivation animations\n        clearTimeout(this.activationTimer);\n        clearTimeout(this.fgDeactivationRemovalTimer);\n        this.rmBoundedActivationClasses();\n        this.adapter.removeClass(FG_DEACTIVATION);\n        // Force layout in order to re-trigger the animation.\n        this.adapter.computeBoundingRect();\n        this.adapter.addClass(FG_ACTIVATION);\n        this.activationTimer = setTimeout(function () {\n            _this.activationTimerCallback();\n        }, DEACTIVATION_TIMEOUT_MS);\n    };\n    MDCRippleFoundation.prototype.getFgTranslationCoordinates = function () {\n        var _a = this.activationState, activationEvent = _a.activationEvent, wasActivatedByPointer = _a.wasActivatedByPointer;\n        var startPoint;\n        if (wasActivatedByPointer) {\n            startPoint = getNormalizedEventCoords(activationEvent, this.adapter.getWindowPageOffset(), this.adapter.computeBoundingRect());\n        }\n        else {\n            startPoint = {\n                x: this.frame.width / 2,\n                y: this.frame.height / 2,\n            };\n        }\n        // Center the element around the start point.\n        startPoint = {\n            x: startPoint.x - (this.initialSize / 2),\n            y: startPoint.y - (this.initialSize / 2),\n        };\n        var endPoint = {\n            x: (this.frame.width / 2) - (this.initialSize / 2),\n            y: (this.frame.height / 2) - (this.initialSize / 2),\n        };\n        return { startPoint: startPoint, endPoint: endPoint };\n    };\n    MDCRippleFoundation.prototype.runDeactivationUXLogicIfReady = function () {\n        var _this = this;\n        // This method is called both when a pointing device is released, and when the activation animation ends.\n        // The deactivation animation should only run after both of those occur.\n        var FG_DEACTIVATION = MDCRippleFoundation.cssClasses.FG_DEACTIVATION;\n        var _a = this.activationState, hasDeactivationUXRun = _a.hasDeactivationUXRun, isActivated = _a.isActivated;\n        var activationHasEnded = hasDeactivationUXRun || !isActivated;\n        if (activationHasEnded && this.activationAnimationHasEnded) {\n            this.rmBoundedActivationClasses();\n            this.adapter.addClass(FG_DEACTIVATION);\n            this.fgDeactivationRemovalTimer = setTimeout(function () {\n                _this.adapter.removeClass(FG_DEACTIVATION);\n            }, ripple_constants_numbers.FG_DEACTIVATION_MS);\n        }\n    };\n    MDCRippleFoundation.prototype.rmBoundedActivationClasses = function () {\n        var FG_ACTIVATION = MDCRippleFoundation.cssClasses.FG_ACTIVATION;\n        this.adapter.removeClass(FG_ACTIVATION);\n        this.activationAnimationHasEnded = false;\n        this.adapter.computeBoundingRect();\n    };\n    MDCRippleFoundation.prototype.resetActivationState = function () {\n        var _this = this;\n        this.previousActivationEvent = this.activationState.activationEvent;\n        this.activationState = this.defaultActivationState();\n        // Touch devices may fire additional events for the same interaction within a short time.\n        // Store the previous event until it\'s safe to assume that subsequent events are for new interactions.\n        setTimeout(function () { return _this.previousActivationEvent = undefined; }, MDCRippleFoundation.numbers.TAP_DELAY_MS);\n    };\n    MDCRippleFoundation.prototype.deactivateImpl = function () {\n        var _this = this;\n        var activationState = this.activationState;\n        // This can happen in scenarios such as when you have a keyup event that blurs the element.\n        if (!activationState.isActivated) {\n            return;\n        }\n        var state = __assign({}, activationState);\n        if (activationState.isProgrammatic) {\n            requestAnimationFrame(function () {\n                _this.animateDeactivation(state);\n            });\n            this.resetActivationState();\n        }\n        else {\n            this.deregisterDeactivationHandlers();\n            requestAnimationFrame(function () {\n                _this.activationState.hasDeactivationUXRun = true;\n                _this.animateDeactivation(state);\n                _this.resetActivationState();\n            });\n        }\n    };\n    MDCRippleFoundation.prototype.animateDeactivation = function (_a) {\n        var wasActivatedByPointer = _a.wasActivatedByPointer, wasElementMadeActive = _a.wasElementMadeActive;\n        if (wasActivatedByPointer || wasElementMadeActive) {\n            this.runDeactivationUXLogicIfReady();\n        }\n    };\n    MDCRippleFoundation.prototype.layoutInternal = function () {\n        var _this = this;\n        this.frame = this.adapter.computeBoundingRect();\n        var maxDim = Math.max(this.frame.height, this.frame.width);\n        // Surface diameter is treated differently for unbounded vs. bounded ripples.\n        // Unbounded ripple diameter is calculated smaller since the surface is expected to already be padded appropriately\n        // to extend the hitbox, and the ripple is expected to meet the edges of the padded hitbox (which is typically\n        // square). Bounded ripples, on the other hand, are fully expected to expand beyond the surface\'s longest diameter\n        // (calculated based on the diagonal plus a constant padding), and are clipped at the surface\'s border via\n        // `overflow: hidden`.\n        var getBoundedRadius = function () {\n            var hypotenuse = Math.sqrt(Math.pow(_this.frame.width, 2) + Math.pow(_this.frame.height, 2));\n            return hypotenuse + MDCRippleFoundation.numbers.PADDING;\n        };\n        this.maxRadius = this.adapter.isUnbounded() ? maxDim : getBoundedRadius();\n        // Ripple is sized as a fraction of the largest dimension of the surface, then scales up using a CSS scale transform\n        var initialSize = Math.floor(maxDim * MDCRippleFoundation.numbers.INITIAL_ORIGIN_SCALE);\n        // Unbounded ripple size should always be even number to equally center align.\n        if (this.adapter.isUnbounded() && initialSize % 2 !== 0) {\n            this.initialSize = initialSize - 1;\n        }\n        else {\n            this.initialSize = initialSize;\n        }\n        this.fgScale = "" + this.maxRadius / this.initialSize;\n        this.updateLayoutCssVars();\n    };\n    MDCRippleFoundation.prototype.updateLayoutCssVars = function () {\n        var _a = MDCRippleFoundation.strings, VAR_FG_SIZE = _a.VAR_FG_SIZE, VAR_LEFT = _a.VAR_LEFT, VAR_TOP = _a.VAR_TOP, VAR_FG_SCALE = _a.VAR_FG_SCALE;\n        this.adapter.updateCssVariable(VAR_FG_SIZE, this.initialSize + "px");\n        this.adapter.updateCssVariable(VAR_FG_SCALE, this.fgScale);\n        if (this.adapter.isUnbounded()) {\n            this.unboundedCoords = {\n                left: Math.round((this.frame.width / 2) - (this.initialSize / 2)),\n                top: Math.round((this.frame.height / 2) - (this.initialSize / 2)),\n            };\n            this.adapter.updateCssVariable(VAR_LEFT, this.unboundedCoords.left + "px");\n            this.adapter.updateCssVariable(VAR_TOP, this.unboundedCoords.top + "px");\n        }\n    };\n    return MDCRippleFoundation;\n}(MDCFoundation));\n\n// tslint:disable-next-line:no-default-export Needed for backward compatibility with MDC Web v0.44.0 and earlier.\n/* harmony default export */ const ripple_foundation = ((/* unused pure expression or super */ null && (MDCRippleFoundation)));\n//# sourceMappingURL=foundation.js.map\n;// CONCATENATED MODULE: ./node_modules/@material/ripple/component.js\n/**\n * @license\n * Copyright 2016 Google Inc.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the "Software"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\n\n\n\n\n\n\nvar MDCRipple = /** @class */ (function (_super) {\n    __extends(MDCRipple, _super);\n    function MDCRipple() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.disabled = false;\n        return _this;\n    }\n    MDCRipple.attachTo = function (root, opts) {\n        if (opts === void 0) { opts = {\n            isUnbounded: undefined\n        }; }\n        var ripple = new MDCRipple(root);\n        // Only override unbounded behavior if option is explicitly specified\n        if (opts.isUnbounded !== undefined) {\n            ripple.unbounded = opts.isUnbounded;\n        }\n        return ripple;\n    };\n    MDCRipple.createAdapter = function (instance) {\n        return {\n            addClass: function (className) { return instance.root.classList.add(className); },\n            browserSupportsCssVars: function () { return supportsCssVariables(window); },\n            computeBoundingRect: function () { return instance.root.getBoundingClientRect(); },\n            containsEventTarget: function (target) { return instance.root.contains(target); },\n            deregisterDocumentInteractionHandler: function (evtType, handler) {\n                return document.documentElement.removeEventListener(evtType, handler, applyPassive());\n            },\n            deregisterInteractionHandler: function (evtType, handler) {\n                return instance.root\n                    .removeEventListener(evtType, handler, applyPassive());\n            },\n            deregisterResizeHandler: function (handler) {\n                return window.removeEventListener(\'resize\', handler);\n            },\n            getWindowPageOffset: function () {\n                return ({ x: window.pageXOffset, y: window.pageYOffset });\n            },\n            isSurfaceActive: function () { return matches(instance.root, \':active\'); },\n            isSurfaceDisabled: function () { return Boolean(instance.disabled); },\n            isUnbounded: function () { return Boolean(instance.unbounded); },\n            registerDocumentInteractionHandler: function (evtType, handler) {\n                return document.documentElement.addEventListener(evtType, handler, applyPassive());\n            },\n            registerInteractionHandler: function (evtType, handler) {\n                return instance.root\n                    .addEventListener(evtType, handler, applyPassive());\n            },\n            registerResizeHandler: function (handler) {\n                return window.addEventListener(\'resize\', handler);\n            },\n            removeClass: function (className) { return instance.root.classList.remove(className); },\n            updateCssVariable: function (varName, value) {\n                return instance.root.style.setProperty(varName, value);\n            },\n        };\n    };\n    Object.defineProperty(MDCRipple.prototype, "unbounded", {\n        get: function () {\n            return Boolean(this.isUnbounded);\n        },\n        set: function (unbounded) {\n            this.isUnbounded = Boolean(unbounded);\n            this.setUnbounded();\n        },\n        enumerable: false,\n        configurable: true\n    });\n    MDCRipple.prototype.activate = function () {\n        this.foundation.activate();\n    };\n    MDCRipple.prototype.deactivate = function () {\n        this.foundation.deactivate();\n    };\n    MDCRipple.prototype.layout = function () {\n        this.foundation.layout();\n    };\n    MDCRipple.prototype.getDefaultFoundation = function () {\n        return new MDCRippleFoundation(MDCRipple.createAdapter(this));\n    };\n    MDCRipple.prototype.initialSyncWithDOM = function () {\n        var root = this.root;\n        this.isUnbounded = \'mdcRippleIsUnbounded\' in root.dataset;\n    };\n    /**\n     * Closure Compiler throws an access control error when directly accessing a\n     * protected or private property inside a getter/setter, like unbounded above.\n     * By accessing the protected property inside a method, we solve that problem.\n     * That\'s why this function exists.\n     */\n    MDCRipple.prototype.setUnbounded = function () {\n        this.foundation.setUnbounded(Boolean(this.isUnbounded));\n    };\n    return MDCRipple;\n}(MDCComponent));\n\n//# sourceMappingURL=component.js.map\n;// CONCATENATED MODULE: ./src/ripple/Ripple.jsx\nvar Ripple_excluded = ["unbounded", "disabled", "className", "element"];\n\nfunction Ripple_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction Ripple_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { Ripple_ownKeys(Object(source), true).forEach(function (key) { Ripple_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { Ripple_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction Ripple_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction Ripple_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = Ripple_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction Ripple_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\nfunction Ripple(_ref) {\n  var _ref$unbounded = _ref.unbounded,\n      unbounded = _ref$unbounded === void 0 ? false : _ref$unbounded,\n      _ref$disabled = _ref.disabled,\n      disabled = _ref$disabled === void 0 ? false : _ref$disabled,\n      className = _ref.className,\n      _ref$element = _ref.element,\n      Element = _ref$element === void 0 ? \'span\' : _ref$element,\n      props = Ripple_objectWithoutProperties(_ref, Ripple_excluded);\n\n  var rootRef = (0,react.useRef)();\n  var rippleRef = (0,react.useRef)();\n  (0,react.useEffect)(function () {\n    if (disabled) return;\n\n    if (!rippleRef.current) {\n      rippleRef.current = new MDCRipple(rootRef.current.parentNode);\n    }\n\n    rippleRef.current.unbounded = unbounded;\n    return function () {\n      return rippleRef.current.destroy();\n    };\n  }, [disabled, unbounded]);\n  var classNames = classnames_default()(className);\n  return /*#__PURE__*/(0,jsx_runtime.jsx)(Element, Ripple_objectSpread({\n    ref: rootRef,\n    className: classNames\n  }, props));\n}\nRipple.displayName = \'MDCRipple\';\n;// CONCATENATED MODULE: ./src/ripple/constants.js\nvar src_ripple_constants_cssClasses = {\n  ROOT: \'mdc-ripple-upgraded\',\n  UNBOUNDED: \'mdc-ripple-upgraded--unbounded\',\n  BG_FOCUSED: \'mdc-ripple-upgraded--background-focused\',\n  FG_ACTIVATION: \'mdc-ripple-upgraded--foreground-activation\',\n  FG_DEACTIVATION: \'mdc-ripple-upgraded--foreground-deactivation\',\n  SURFACE: \'mdc-ripple-surface\',\n  SURFACE_PRIMARY: \'mdc-ripple-surface--primary\',\n  SURFACE_ACCENT: \'mdc-ripple-surface--accent\'\n};\nvar ripple_constants_strings = {\n  VAR_FG_SCALE: \'--mdc-ripple-fg-scale\',\n  VAR_FG_SIZE: \'--mdc-ripple-fg-size\',\n  VAR_FG_TRANSLATE_END: \'--mdc-ripple-fg-translate-end\',\n  VAR_FG_TRANSLATE_START: \'--mdc-ripple-fg-translate-start\',\n  VAR_LEFT: \'--mdc-ripple-left\',\n  VAR_TOP: \'--mdc-ripple-top\'\n};\nvar src_ripple_constants_numbers = {\n  DEACTIVATION_TIMEOUT_MS: 225,\n  // Corresponds to $mdc-ripple-translate-duration (i.e. activation animation duration)\n  FG_DEACTIVATION_MS: 150,\n  // Corresponds to $mdc-ripple-fade-out-duration (i.e. deactivation animation duration)\n  INITIAL_ORIGIN_SCALE: 0.6,\n  PADDING: 10,\n  TAP_DELAY_MS: 300 // Delay between touch and simulated mouse events on touch devices\n\n};\n;// CONCATENATED MODULE: ./src/ripple/hooks.js\n\n\nfunction useRipple(rootRef) {\n  var unbounded = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  var rippleRef = (0,react.useRef)();\n  (0,react.useEffect)(function () {\n    if (!rippleRef.current) {\n      rippleRef.current = new MDCRipple(rootRef.current);\n    }\n\n    rippleRef.current.unbounded = unbounded;\n    return function () {\n      return rippleRef.current.destroy();\n    };\n  }, [rootRef, unbounded]);\n  return rippleRef.current;\n}\n;// CONCATENATED MODULE: ./src/ripple/RippleSurface.jsx\nvar RippleSurface_excluded = ["primary", "accent", "className", "element"];\n\nfunction RippleSurface_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction RippleSurface_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { RippleSurface_ownKeys(Object(source), true).forEach(function (key) { RippleSurface_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { RippleSurface_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction RippleSurface_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction RippleSurface_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = RippleSurface_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction RippleSurface_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\n\n\nvar RippleSurface = /*#__PURE__*/(0,react.forwardRef)(function (_ref, ref) {\n  var _classnames;\n\n  var primary = _ref.primary,\n      accent = _ref.accent,\n      className = _ref.className,\n      _ref$element = _ref.element,\n      Element = _ref$element === void 0 ? \'div\' : _ref$element,\n      props = RippleSurface_objectWithoutProperties(_ref, RippleSurface_excluded);\n\n  var rootRef = (0,react.useRef)();\n  (0,react.useImperativeHandle)(ref, function () {\n    return rootRef.current;\n  });\n  useRipple(rootRef);\n  var classNames = classnames_default()(src_ripple_constants_cssClasses.SURFACE, (_classnames = {}, RippleSurface_defineProperty(_classnames, src_ripple_constants_cssClasses.SURFACE_PRIMARY, primary), RippleSurface_defineProperty(_classnames, src_ripple_constants_cssClasses.SURFACE_ACCENT, accent), _classnames), className);\n  return /*#__PURE__*/(0,jsx_runtime.jsx)(Element, RippleSurface_objectSpread({\n    ref: rootRef,\n    className: classNames\n  }, props));\n});\nRippleSurface.displayName = \'MDCRippleSurface\';\nRippleSurface.propTypes = {\n  primary: (prop_types_default()).bool,\n  accent: (prop_types_default()).bool\n};\n/* harmony default export */ const ripple_RippleSurface = (RippleSurface);\n;// CONCATENATED MODULE: ./src/ripple/index.js\n\n\n;// CONCATENATED MODULE: ./src/segmented-button/constants.js\nvar segmented_button_constants_cssClasses = {\n  ROOT: \'mdc-segmented-button\',\n  SINGLE_SELECT: \'mdc-segmented-button--single-select\',\n  SEGMENT: \'mdc-segmented-button__segment\',\n  SEGMENT_SELECTED: \'mdc-segmented-button__segment--selected\',\n  ICON: \'mdc-segmented-button__icon\',\n  LABEL: \'mdc-segmented-button__label\',\n  RIPPLE: \'mdc-segmented-button__ripple\',\n  TOUCH: \'mdc-segmented-button--touch\',\n  TOUCH_ELEMENT: \'mdc-segmented-button__touch\'\n};\n;// CONCATENATED MODULE: ./src/segmented-button/SegmentedButtonSegment.jsx\nvar SegmentedButtonSegment_excluded = ["label", "icon", "selected", "touch", "ripple", "element", "component", "className", "children"];\n\nfunction SegmentedButtonSegment_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction SegmentedButtonSegment_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { SegmentedButtonSegment_ownKeys(Object(source), true).forEach(function (key) { SegmentedButtonSegment_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { SegmentedButtonSegment_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction SegmentedButtonSegment_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction SegmentedButtonSegment_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = SegmentedButtonSegment_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction SegmentedButtonSegment_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\n\n\n\n\nvar SegmentedButtonSegment = /*#__PURE__*/(0,react.forwardRef)(function (_ref, ref) {\n  var _classnames;\n\n  var label = _ref.label,\n      icon = _ref.icon,\n      selected = _ref.selected,\n      touch = _ref.touch,\n      ripple = _ref.ripple,\n      _ref$element = _ref.element,\n      element = _ref$element === void 0 ? \'button\' : _ref$element,\n      _ref$component = _ref.component,\n      Element = _ref$component === void 0 ? element : _ref$component,\n      className = _ref.className,\n      _ref$children = _ref.children,\n      children = _ref$children === void 0 ? label : _ref$children,\n      props = SegmentedButtonSegment_objectWithoutProperties(_ref, SegmentedButtonSegment_excluded);\n\n  var classNames = classnames_default()(segmented_button_constants_cssClasses.SEGMENT, (_classnames = {}, SegmentedButtonSegment_defineProperty(_classnames, segmented_button_constants_cssClasses.SEGMENT_SELECTED, selected), SegmentedButtonSegment_defineProperty(_classnames, segmented_button_constants_cssClasses.TOUCH, touch), _classnames), className);\n  return /*#__PURE__*/(0,jsx_runtime.jsxs)(Element, SegmentedButtonSegment_objectSpread(SegmentedButtonSegment_objectSpread({\n    ref: ref,\n    className: classNames\n  }, props), {}, {\n    children: [ripple && /*#__PURE__*/(0,jsx_runtime.jsx)("div", {\n      className: segmented_button_constants_cssClasses.RIPPLE\n    }), touch && /*#__PURE__*/(0,jsx_runtime.jsx)("div", {\n      className: segmented_button_constants_cssClasses.TOUCH_ELEMENT\n    }), icon && /*#__PURE__*/(0,jsx_runtime.jsx)(Clone, {\n      component: icon,\n      fallback: icon_Icon,\n      className: segmented_button_constants_cssClasses.ICON\n    }), children && /*#__PURE__*/(0,jsx_runtime.jsx)("span", {\n      className: segmented_button_constants_cssClasses.LABEL,\n      children: children\n    })]\n  }));\n});\nSegmentedButtonSegment.displayName = \'MDCSegmentedButtonSegment\';\nSegmentedButtonSegment.propTypes = {\n  label: (prop_types_default()).string,\n  icon: (prop_types_default()).node,\n  selected: (prop_types_default()).bool,\n  ripple: (prop_types_default()).bool\n};\n/* harmony default export */ const segmented_button_SegmentedButtonSegment = (SegmentedButtonSegment);\n;// CONCATENATED MODULE: ./src/segmented-button/SegmentedButton.jsx\nvar SegmentedButton_excluded = ["value", "segments", "singleSelect", "ripple", "touch", "onChange", "element", "component", "className", "children"];\n\nfunction SegmentedButton_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction SegmentedButton_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { SegmentedButton_ownKeys(Object(source), true).forEach(function (key) { SegmentedButton_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { SegmentedButton_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction SegmentedButton_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction SegmentedButton_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = SegmentedButton_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction SegmentedButton_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\n\n\n\n\nvar SegmentedButton = /*#__PURE__*/(0,react.forwardRef)(function (_ref, ref) {\n  var value = _ref.value,\n      segments = _ref.segments,\n      _ref$singleSelect = _ref.singleSelect,\n      singleSelect = _ref$singleSelect === void 0 ? !isUndefined(value) && !isArray(value) : _ref$singleSelect,\n      _ref$ripple = _ref.ripple,\n      ripple = _ref$ripple === void 0 ? true : _ref$ripple,\n      _ref$touch = _ref.touch,\n      touch = _ref$touch === void 0 ? false : _ref$touch,\n      _ref$onChange = _ref.onChange,\n      onChange = _ref$onChange === void 0 ? Function.prototype : _ref$onChange,\n      _ref$element = _ref.element,\n      element = _ref$element === void 0 ? \'div\' : _ref$element,\n      _ref$component = _ref.component,\n      Element = _ref$component === void 0 ? element : _ref$component,\n      className = _ref.className,\n      _ref$children = _ref.children,\n      children = _ref$children === void 0 ? segments === null || segments === void 0 ? void 0 : segments.map(function (segment) {\n    return (0,react.createElement)(segmented_button_SegmentedButtonSegment, segment);\n  }) : _ref$children,\n      props = SegmentedButton_objectWithoutProperties(_ref, SegmentedButton_excluded);\n\n  var handleClick = (0,react.useCallback)(function (event) {\n    var segmentValue = event.currentTarget.value;\n    var newValue = singleSelect ? segmentValue : value.includes(segmentValue) ? value.filter(function (v) {\n      return v !== segmentValue;\n    }) : value.concat(segmentValue);\n    onChange(newValue);\n  }, [value, singleSelect, onChange]);\n  var classNames = classnames_default()(segmented_button_constants_cssClasses.ROOT, SegmentedButton_defineProperty({}, segmented_button_constants_cssClasses.SINGLE_SELECT, singleSelect), className);\n  return /*#__PURE__*/(0,jsx_runtime.jsx)(Element, SegmentedButton_objectSpread(SegmentedButton_objectSpread({\n    ref: ref,\n    className: classNames,\n    role: singleSelect ? \'radiogroup\' : \'group\'\n  }, props), {}, {\n    children: isUndefined(value) ? children : react.Children.map(children, function (segment) {\n      var _clone;\n\n      var ariaProp = singleSelect ? \'aria-checked\' : \'aria-pressed\';\n      var selected = singleSelect ? value === segment.props.value : value.includes(segment.props.value);\n      return (0,react.cloneElement)(segment, (_clone = {\n        ripple: ripple,\n        touch: touch,\n        selected: selected,\n        role: singleSelect ? \'radio\' : undefined\n      }, SegmentedButton_defineProperty(_clone, ariaProp, selected), SegmentedButton_defineProperty(_clone, "onClickCapture", handleClick), _clone));\n    })\n  }));\n});\nSegmentedButton.displayName = \'MDCSegmentedButton\';\nSegmentedButton.propTypes = {\n  value: (prop_types_default()).any,\n  segments: prop_types_default().arrayOf(prop_types_default().oneOfType([(prop_types_default()).object, (prop_types_default()).element])),\n  singleSelect: (prop_types_default()).bool,\n  ripple: (prop_types_default()).bool,\n  touch: (prop_types_default()).bool,\n  onChange: (prop_types_default()).func\n};\n/* harmony default export */ const segmented_button_SegmentedButton = (SegmentedButton);\n;// CONCATENATED MODULE: ./src/segmented-button/index.js\n\n\nsegmented_button_SegmentedButton.Segment = segmented_button_SegmentedButtonSegment;\n\n;// CONCATENATED MODULE: ./src/side-sheet/constants.js\nvar side_sheet_constants_numbers = {\n  ANIMATION_ENTER_TIME_MS: 250,\n  ANIMATION_EXIT_TIME_MS: 200\n};\nvar side_sheet_constants_cssClasses = {\n  ROOT: \'mdc-side-sheet\',\n  DISMISSIBLE: \'mdc-side-sheet--dismissible\',\n  MODAL: \'mdc-side-sheet--modal\',\n  OPEN: \'mdc-side-sheet--open\',\n  ANIMATE: \'mdc-side-sheet--animate\',\n  OPENING: \'mdc-side-sheet--opening\',\n  CLOSING: \'mdc-side-sheet--closing\',\n  CONTENT: \'mdc-side-sheet__content\',\n  HEADER: \'mdc-side-sheet__header\',\n  TITLE: \'mdc-side-sheet__title\',\n  CLOSE_BUTTON: \'mdc-side-sheet__close-button\',\n  APP_CONTENT: \'mdc-side-sheet-app-content\',\n  SCRIM: \'mdc-side-sheet-scrim\'\n};\n;// CONCATENATED MODULE: ./src/side-sheet/SideSheetHeader.jsx\nvar SideSheetHeader_excluded = ["title", "closeIcon", "onClose", "element"];\n\nfunction SideSheetHeader_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction SideSheetHeader_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { SideSheetHeader_ownKeys(Object(source), true).forEach(function (key) { SideSheetHeader_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { SideSheetHeader_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction SideSheetHeader_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction SideSheetHeader_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = SideSheetHeader_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction SideSheetHeader_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\n\n\nvar SideSheetHeader = /*#__PURE__*/(0,react.forwardRef)(function (_ref, ref) {\n  var title = _ref.title,\n      closeIcon = _ref.closeIcon,\n      onClose = _ref.onClose,\n      _ref$element = _ref.element,\n      Element = _ref$element === void 0 ? \'header\' : _ref$element,\n      props = SideSheetHeader_objectWithoutProperties(_ref, SideSheetHeader_excluded);\n\n  return /*#__PURE__*/(0,jsx_runtime.jsxs)(Element, SideSheetHeader_objectSpread(SideSheetHeader_objectSpread({\n    ref: ref,\n    className: side_sheet_constants_cssClasses.HEADER\n  }, props), {}, {\n    children: [title && /*#__PURE__*/(0,jsx_runtime.jsx)(Clone, {\n      component: title,\n      fallback: "h3",\n      className: side_sheet_constants_cssClasses.TITLE\n    }), closeIcon && /*#__PURE__*/(0,jsx_runtime.jsx)(Clone, {\n      component: closeIcon,\n      fallback: icon_button_IconButton,\n      className: side_sheet_constants_cssClasses.CLOSE_BUTTON,\n      onClick: onClose\n    })]\n  }));\n});\nSideSheetHeader.displayName = \'MDCSideSheetHeader\';\n/* harmony default export */ const side_sheet_SideSheetHeader = (SideSheetHeader);\n;// CONCATENATED MODULE: ./src/side-sheet/SideSheetContent.jsx\nvar SideSheetContent_excluded = ["element"];\n\nfunction SideSheetContent_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction SideSheetContent_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { SideSheetContent_ownKeys(Object(source), true).forEach(function (key) { SideSheetContent_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { SideSheetContent_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction SideSheetContent_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction SideSheetContent_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = SideSheetContent_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction SideSheetContent_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\nvar SideSheetContent = /*#__PURE__*/(0,react.forwardRef)(function (_ref, ref) {\n  var _ref$element = _ref.element,\n      Element = _ref$element === void 0 ? \'div\' : _ref$element,\n      props = SideSheetContent_objectWithoutProperties(_ref, SideSheetContent_excluded);\n\n  return /*#__PURE__*/(0,jsx_runtime.jsx)(Element, SideSheetContent_objectSpread({\n    ref: ref,\n    className: side_sheet_constants_cssClasses.CONTENT\n  }, props));\n});\nSideSheetContent.displayName = \'MDCSideSheetContent\';\n/* harmony default export */ const side_sheet_SideSheetContent = (SideSheetContent);\n;// CONCATENATED MODULE: ./src/side-sheet/SideSheet.jsx\nvar SideSheet_excluded = ["title", "content", "closeIcon", "open", "appear", "dismissible", "modal", "appContentSelector", "onClose", "element", "component", "className", "children"];\n\nfunction SideSheet_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction SideSheet_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { SideSheet_ownKeys(Object(source), true).forEach(function (key) { SideSheet_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { SideSheet_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction SideSheet_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction SideSheet_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = SideSheet_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction SideSheet_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\n\n\n\n\n\n\nvar SideSheet = /*#__PURE__*/(0,react.forwardRef)(function (_ref, ref) {\n  var _classnames;\n\n  var title = _ref.title,\n      content = _ref.content,\n      closeIcon = _ref.closeIcon,\n      _ref$open = _ref.open,\n      open = _ref$open === void 0 ? false : _ref$open,\n      _ref$appear = _ref.appear,\n      appear = _ref$appear === void 0 ? false : _ref$appear,\n      _ref$dismissible = _ref.dismissible,\n      dismissible = _ref$dismissible === void 0 ? false : _ref$dismissible,\n      _ref$modal = _ref.modal,\n      modal = _ref$modal === void 0 ? false : _ref$modal,\n      appContentSelector = _ref.appContentSelector,\n      _ref$onClose = _ref.onClose,\n      onClose = _ref$onClose === void 0 ? Function.prototype : _ref$onClose,\n      _ref$element = _ref.element,\n      element = _ref$element === void 0 ? \'aside\' : _ref$element,\n      _ref$component = _ref.component,\n      Element = _ref$component === void 0 ? element : _ref$component,\n      className = _ref.className,\n      children = _ref.children,\n      props = SideSheet_objectWithoutProperties(_ref, SideSheet_excluded);\n\n  var rootRef = (0,react.useRef)();\n  (0,react.useImperativeHandle)(ref, function () {\n    return rootRef.current;\n  });\n  (0,react.useEffect)(function () {\n    if (!dismissible) return;\n    var appContentElement = appContentSelector ? document.querySelector(appContentSelector) : rootRef.current.nextElementSibling;\n    appContentElement === null || appContentElement === void 0 ? void 0 : appContentElement.classList.add(side_sheet_constants_cssClasses.APP_CONTENT);\n    return function () {\n      appContentElement === null || appContentElement === void 0 ? void 0 : appContentElement.classList.remove(side_sheet_constants_cssClasses.APP_CONTENT);\n    };\n  }, [dismissible, appContentSelector]);\n  (0,react.useEffect)(function () {\n    if (!modal) return;\n\n    function handleDocumentKeyDown(event) {\n      if (event.key && event.key === \'Escape\' || event.keyCode === 27) {\n        onClose();\n      }\n    }\n\n    document.addEventListener(\'keydown\', handleDocumentKeyDown);\n    return function () {\n      return document.removeEventListener(\'keydown\', handleDocumentKeyDown);\n    };\n  }, [modal, onClose]);\n  var classNames = classnames_default()(side_sheet_constants_cssClasses.ROOT, (_classnames = {}, SideSheet_defineProperty(_classnames, side_sheet_constants_cssClasses.DISMISSIBLE, dismissible), SideSheet_defineProperty(_classnames, side_sheet_constants_cssClasses.MODAL, modal), _classnames), className);\n  return /*#__PURE__*/(0,jsx_runtime.jsx)(Layer, {\n    modal: modal,\n    fixed: modal,\n    "in": open,\n    appear: appear,\n    timeout: {\n      enter: side_sheet_constants_numbers.ANIMATION_ENTER_TIME_MS,\n      exit: side_sheet_constants_numbers.ANIMATION_EXIT_TIME_MS\n    },\n    classNames: {\n      appear: side_sheet_constants_cssClasses.OPEN,\n      enter: "".concat(side_sheet_constants_cssClasses.OPEN, " ").concat(side_sheet_constants_cssClasses.ANIMATE),\n      enterActive: "".concat(side_sheet_constants_cssClasses.OPEN, " ").concat(side_sheet_constants_cssClasses.OPENING),\n      enterDone: side_sheet_constants_cssClasses.OPEN,\n      exit: "".concat(side_sheet_constants_cssClasses.OPEN, " ").concat(side_sheet_constants_cssClasses.CLOSING),\n      exitActive: side_sheet_constants_cssClasses.CLOSING\n    },\n    mountOnEnter: modal,\n    unmountOnExit: modal,\n    children: /*#__PURE__*/(0,jsx_runtime.jsxs)(jsx_runtime.Fragment, {\n      children: [/*#__PURE__*/(0,jsx_runtime.jsxs)(Element, SideSheet_objectSpread(SideSheet_objectSpread({\n        ref: rootRef,\n        className: classNames\n      }, props), {}, {\n        children: [(title || closeIcon) && /*#__PURE__*/(0,jsx_runtime.jsx)(side_sheet_SideSheetHeader, {\n          title: title,\n          onClose: onClose,\n          closeIcon: closeIcon\n        }), content && /*#__PURE__*/(0,jsx_runtime.jsx)(side_sheet_SideSheetContent, {\n          children: content\n        }), children]\n      })), modal && /*#__PURE__*/(0,jsx_runtime.jsx)("div", {\n        className: side_sheet_constants_cssClasses.SCRIM,\n        onClick: onClose\n      })]\n    })\n  });\n});\nSideSheet.displayName = \'MDCSideSheet\';\nSideSheet.propTypes = {\n  title: (prop_types_default()).string,\n  content: (prop_types_default()).node,\n  closeIcon: (prop_types_default()).node,\n  open: (prop_types_default()).bool,\n  appear: (prop_types_default()).bool,\n  dismissible: (prop_types_default()).bool,\n  modal: (prop_types_default()).bool,\n  appContentSelector: (prop_types_default()).string,\n  onClose: (prop_types_default()).func\n};\n/* harmony default export */ const side_sheet_SideSheet = (SideSheet);\n;// CONCATENATED MODULE: ./src/side-sheet/SideSheetAppContent.jsx\nvar SideSheetAppContent_excluded = ["element", "className"];\n\nfunction SideSheetAppContent_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction SideSheetAppContent_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { SideSheetAppContent_ownKeys(Object(source), true).forEach(function (key) { SideSheetAppContent_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { SideSheetAppContent_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction SideSheetAppContent_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction SideSheetAppContent_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = SideSheetAppContent_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction SideSheetAppContent_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\nvar SideSheetAppContent = /*#__PURE__*/(0,react.forwardRef)(function (_ref, ref) {\n  var _ref$element = _ref.element,\n      Element = _ref$element === void 0 ? \'div\' : _ref$element,\n      className = _ref.className,\n      props = SideSheetAppContent_objectWithoutProperties(_ref, SideSheetAppContent_excluded);\n\n  var classNames = classnames_default()(side_sheet_constants_cssClasses.APP_CONTENT, className);\n  return /*#__PURE__*/(0,jsx_runtime.jsx)(Element, SideSheetAppContent_objectSpread({\n    ref: ref,\n    className: classNames\n  }, props));\n});\nSideSheetAppContent.displayName = \'MDCSideSheetAppContent\';\n/* harmony default export */ const side_sheet_SideSheetAppContent = (SideSheetAppContent);\n;// CONCATENATED MODULE: ./src/side-sheet/index.js\n\n\n\n\nside_sheet_SideSheet.Header = side_sheet_SideSheetHeader;\nside_sheet_SideSheet.Content = side_sheet_SideSheetContent;\nside_sheet_SideSheet.AppContent = side_sheet_SideSheetAppContent;\n\n;// CONCATENATED MODULE: ./src/constants.js\nvar Key = {\n  ARROW_LEFT: \'ArrowLeft\',\n  ARROW_UP: \'ArrowUp\',\n  ARROW_RIGHT: \'ArrowRight\',\n  ARROW_DOWN: \'ArrowDown\',\n  HOME: \'Home\',\n  END: \'End\',\n  PAGE_UP: \'PageUp\',\n  PAGE_DOWN: \'PageDown\'\n};\nvar KeyCode = {\n  PAGE_UP: 33,\n  PAGE_DOWN: 34,\n  END: 35,\n  HOME: 36,\n  ARROW_LEFT: 37,\n  ARROW_UP: 38,\n  ARROW_RIGHT: 39,\n  ARROW_DOWN: 40\n};\n;// CONCATENATED MODULE: ./src/utils.js\n\nfunction getEventKey(event) {\n  switch (event.key || event.keyCode) {\n    case Key.ARROW_LEFT:\n    case KeyCode.ARROW_LEFT:\n      return Key.ARROW_LEFT;\n\n    case Key.ARROW_UP:\n    case KeyCode.ARROW_UP:\n      return Key.ARROW_UP;\n\n    case Key.ARROW_RIGHT:\n    case KeyCode.ARROW_RIGHT:\n      return Key.ARROW_RIGHT;\n\n    case Key.ARROW_DOWN:\n    case KeyCode.ARROW_DOWN:\n      return Key.ARROW_DOWN;\n\n    case Key.HOME:\n    case KeyCode.HOME:\n      return Key.HOME;\n\n    case Key.END:\n    case KeyCode.END:\n      return Key.END;\n\n    case Key.PAGE_UP:\n    case KeyCode.PAGE_UP:\n      return Key.PAGE_UP;\n\n    case Key.PAGE_DOWN:\n    case KeyCode.PAGE_DOWN:\n      return Key.PAGE_DOWN;\n\n    default:\n      return undefined;\n  }\n}\nfunction getPageX(event) {\n  var _event$targetTouches;\n\n  if (((_event$targetTouches = event.targetTouches) === null || _event$targetTouches === void 0 ? void 0 : _event$targetTouches.length) > 0) {\n    return event.targetTouches[0].pageX;\n  }\n\n  return event.pageX;\n}\nfunction getPageY(event) {\n  var _event$targetTouches2;\n\n  if (((_event$targetTouches2 = event.targetTouches) === null || _event$targetTouches2 === void 0 ? void 0 : _event$targetTouches2.length) > 0) {\n    return event.targetTouches[0].pageY;\n  }\n\n  return event.pageY;\n}\n;// CONCATENATED MODULE: ./src/slider/constants.js\nvar slider_constants_numbers = {\n  THUMB_WIDTH: 48\n};\nvar slider_constants_cssClasses = {\n  ROOT: \'mdc-slider\',\n  RANGE: \'mdc-slider--range\',\n  DISCRETE: \'mdc-slider--discrete\',\n  DISABLED: \'mdc-slider--disabled\',\n  INPUT: \'mdc-slider__input\',\n  TRACK: \'mdc-slider__track\',\n  TRACK_INACTIVE: \'mdc-slider__track--inactive\',\n  TRACK_ACTIVE: \'mdc-slider__track--active\',\n  TRACK_ACTIVE_FILL: \'mdc-slider__track--active_fill\',\n  TICK_MARKS: \'mdc-slider__tick-marks\',\n  TICK_MARK_ACTIVE: \'mdc-slider__tick-mark--active\',\n  TICK_MARK_INACTIVE: \'mdc-slider__tick-mark--inactive\',\n  THUMB: \'mdc-slider__thumb\',\n  THUMB_TOP: \'mdc-slider__thumb--top\',\n  THUMB_FOCUSED: \'mdc-slider__thumb--focused\',\n  THUMB_WITH_INDICATOR: \'mdc-slider__thumb--with-indicator\',\n  THUMB_KNOB: \'mdc-slider__thumb-knob\',\n  VALUE_INDICATOR_CONTAINER: \'mdc-slider__value-indicator-container\',\n  VALUE_INDICATOR: \'mdc-slider__value-indicator\',\n  VALUE_INDICATOR_TEXT: \'mdc-slider__value-indicator-text\'\n};\n;// CONCATENATED MODULE: ./src/slider/utils.js\n\nfunction getValueForEventKey(eventKey, value, min, max, step) {\n  var delta = Number(step) || (max - min) / 100;\n\n  switch (eventKey) {\n    case Key.ARROW_LEFT:\n    case Key.ARROW_DOWN:\n      return value - delta;\n\n    case Key.ARROW_RIGHT:\n    case Key.ARROW_UP:\n      return value + delta;\n\n    case Key.HOME:\n      return min;\n\n    case Key.END:\n      return max;\n\n    default:\n      return NaN;\n  }\n}\n;// CONCATENATED MODULE: ./src/slider/Input.jsx\nvar Input_excluded = ["value"];\n\nfunction Input_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction Input_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { Input_ownKeys(Object(source), true).forEach(function (key) { Input_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { Input_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction Input_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction Input_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = Input_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction Input_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\nvar Input = /*#__PURE__*/(0,react.forwardRef)(function (_ref, ref) {\n  var value = _ref.value,\n      props = Input_objectWithoutProperties(_ref, Input_excluded);\n\n  return /*#__PURE__*/(0,jsx_runtime.jsx)("input", Input_objectSpread({\n    ref: ref,\n    className: slider_constants_cssClasses.INPUT,\n    type: "range",\n    value: Math.round(value),\n    onChange: Function.prototype\n  }, props));\n});\nInput.displayName = \'MDCSliderInput\';\n/* harmony default export */ const slider_Input = (Input);\n;// CONCATENATED MODULE: ./src/slider/TickMarks.jsx\nfunction TickMarks_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n\n\n\n\nvar TickMarks = function TickMarks(_ref) {\n  var value = _ref.value,\n      max = _ref.max,\n      _ref$step = _ref.step,\n      step = _ref$step === void 0 ? 1 : _ref$step;\n  return /*#__PURE__*/(0,jsx_runtime.jsx)("div", {\n    className: slider_constants_cssClasses.TICK_MARKS,\n    children: Array.from(new Array(max / step + 1)).map(function (_, i) {\n      return i * step;\n    }).map(function (tickValue, index) {\n      var _classnames;\n\n      return /*#__PURE__*/(0,jsx_runtime.jsx)("div", {\n        className: classnames_default()((_classnames = {}, TickMarks_defineProperty(_classnames, slider_constants_cssClasses.TICK_MARK_ACTIVE, tickValue <= value), TickMarks_defineProperty(_classnames, slider_constants_cssClasses.TICK_MARK_INACTIVE, tickValue > value), _classnames))\n      }, index);\n    })\n  });\n};\n\nTickMarks.displayName = \'MDCSliderTickMarks\';\n/* harmony default export */ const slider_TickMarks = (TickMarks);\n;// CONCATENATED MODULE: ./src/slider/Track.jsx\n\n\n\n\n\nvar Track = /*#__PURE__*/(0,react.forwardRef)(function (_ref, ref) {\n  var value = _ref.value,\n      min = _ref.min,\n      max = _ref.max,\n      step = _ref.step,\n      discrete = _ref.discrete,\n      tickMarks = _ref.tickMarks;\n  var style = {\n    transform: "scaleX(".concat((value - min) / (max - min), ")")\n  };\n  return /*#__PURE__*/(0,jsx_runtime.jsxs)("div", {\n    ref: ref,\n    className: slider_constants_cssClasses.TRACK,\n    children: [/*#__PURE__*/(0,jsx_runtime.jsx)("div", {\n      className: slider_constants_cssClasses.TRACK_INACTIVE\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)("div", {\n      className: slider_constants_cssClasses.TRACK_ACTIVE,\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)("div", {\n        className: slider_constants_cssClasses.TRACK_ACTIVE_FILL,\n        style: style\n      })\n    }), discrete && tickMarks && /*#__PURE__*/(0,jsx_runtime.jsx)(slider_TickMarks, {\n      value: value,\n      max: max,\n      step: step\n    })]\n  });\n});\nTrack.displayName = \'MDCSliderTrack\';\n/* harmony default export */ const slider_Track = (Track);\n;// CONCATENATED MODULE: ./src/slider/Thumb.jsx\nvar Thumb_excluded = ["value", "min", "max", "discrete", "disabled", "onStartInteraction", "onEndInteraction"];\n\nfunction Thumb_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction Thumb_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { Thumb_ownKeys(Object(source), true).forEach(function (key) { Thumb_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { Thumb_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction Thumb_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction Thumb_slicedToArray(arr, i) { return Thumb_arrayWithHoles(arr) || Thumb_iterableToArrayLimit(arr, i) || Thumb_unsupportedIterableToArray(arr, i) || Thumb_nonIterableRest(); }\n\nfunction Thumb_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction Thumb_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return Thumb_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return Thumb_arrayLikeToArray(o, minLen); }\n\nfunction Thumb_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction Thumb_iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction Thumb_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction Thumb_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = Thumb_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction Thumb_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\n\nvar Thumb = /*#__PURE__*/(0,react.forwardRef)(function (_ref, ref) {\n  var _classnames;\n\n  var value = _ref.value,\n      min = _ref.min,\n      max = _ref.max,\n      discrete = _ref.discrete,\n      disabled = _ref.disabled,\n      onStartInteraction = _ref.onStartInteraction,\n      onEndInteraction = _ref.onEndInteraction,\n      props = Thumb_objectWithoutProperties(_ref, Thumb_excluded);\n\n  var _useState = (0,react.useState)(false),\n      _useState2 = Thumb_slicedToArray(_useState, 2),\n      focused = _useState2[0],\n      setFocused = _useState2[1];\n\n  var handleFocus = (0,react.useCallback)(function () {\n    setFocused(true);\n  }, []);\n  var handleBlur = (0,react.useCallback)(function () {\n    setFocused(false);\n  }, []);\n  var classNames = classnames_default()(slider_constants_cssClasses.THUMB, (_classnames = {}, Thumb_defineProperty(_classnames, slider_constants_cssClasses.THUMB_FOCUSED, focused), Thumb_defineProperty(_classnames, slider_constants_cssClasses.THUMB_WITH_INDICATOR, discrete && focused), _classnames));\n  var style = {\n    left: "calc(".concat((value - min) / (max - min) * 100, "% - ").concat(slider_constants_numbers.THUMB_WIDTH * 0.5, "px)")\n  };\n  return /*#__PURE__*/(0,jsx_runtime.jsxs)("div", Thumb_objectSpread(Thumb_objectSpread({\n    ref: ref,\n    className: classNames,\n    role: "slider",\n    tabIndex: disabled ? \'-1\' : \'0\',\n    "aria-valuemin": "0",\n    "aria-valuemax": "100",\n    "aria-valuenow": "50",\n    "aria-disabled": disabled || undefined,\n    style: style,\n    onFocus: handleFocus,\n    onBlur: handleBlur,\n    onMouseDown: onStartInteraction,\n    onMouseUp: onEndInteraction,\n    onTouchStart: onStartInteraction,\n    onTouchEnd: onEndInteraction\n  }, props), {}, {\n    children: [discrete && /*#__PURE__*/(0,jsx_runtime.jsx)("div", {\n      className: slider_constants_cssClasses.VALUE_INDICATOR_CONTAINER,\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)("div", {\n        className: slider_constants_cssClasses.VALUE_INDICATOR,\n        children: /*#__PURE__*/(0,jsx_runtime.jsx)("span", {\n          className: slider_constants_cssClasses.VALUE_INDICATOR_TEXT,\n          children: value\n        })\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)("div", {\n      className: slider_constants_cssClasses.THUMB_KNOB\n    })]\n  }));\n});\nThumb.displayName = \'MDCSliderThumb\';\n/* harmony default export */ const slider_Thumb = (Thumb);\n;// CONCATENATED MODULE: ./src/slider/Slider.jsx\nvar Slider_excluded = ["name", "value", "min", "max", "step", "discrete", "disabled", "tickMarks", "onChange", "className"];\n\nfunction Slider_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction Slider_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { Slider_ownKeys(Object(source), true).forEach(function (key) { Slider_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { Slider_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction Slider_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction Slider_slicedToArray(arr, i) { return Slider_arrayWithHoles(arr) || Slider_iterableToArrayLimit(arr, i) || Slider_unsupportedIterableToArray(arr, i) || Slider_nonIterableRest(); }\n\nfunction Slider_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction Slider_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return Slider_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return Slider_arrayLikeToArray(o, minLen); }\n\nfunction Slider_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction Slider_iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction Slider_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction Slider_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = Slider_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction Slider_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\n\n\n\n\n\n\n\n\nvar Slider = /*#__PURE__*/(0,react.forwardRef)(function (_ref, ref) {\n  var _classnames;\n\n  var name = _ref.name,\n      _ref$value = _ref.value,\n      value = _ref$value === void 0 ? 0 : _ref$value,\n      _ref$min = _ref.min,\n      min = _ref$min === void 0 ? 0 : _ref$min,\n      _ref$max = _ref.max,\n      max = _ref$max === void 0 ? 100 : _ref$max,\n      step = _ref.step,\n      _ref$discrete = _ref.discrete,\n      discrete = _ref$discrete === void 0 ? false : _ref$discrete,\n      _ref$disabled = _ref.disabled,\n      disabled = _ref$disabled === void 0 ? false : _ref$disabled,\n      _ref$tickMarks = _ref.tickMarks,\n      tickMarks = _ref$tickMarks === void 0 ? false : _ref$tickMarks,\n      _ref$onChange = _ref.onChange,\n      onChange = _ref$onChange === void 0 ? Function.prototype : _ref$onChange,\n      className = _ref.className,\n      props = Slider_objectWithoutProperties(_ref, Slider_excluded);\n\n  var inputRef = (0,react.useRef)();\n  var trackRef = (0,react.useRef)();\n\n  var _useState = (0,react.useState)(false),\n      _useState2 = Slider_slicedToArray(_useState, 2),\n      active = _useState2[0],\n      setActive = _useState2[1];\n\n  useUpdated(function () {\n    if (disabled) return;\n\n    if (active) {\n      document.body.addEventListener(\'mousemove\', handleMove);\n      document.body.addEventListener(\'touchmove\', handleMove);\n      document.body.addEventListener(\'mouseup\', handleUp);\n      document.body.addEventListener(\'touchend\', handleUp);\n    } else {\n      document.body.removeEventListener(\'mousemove\', handleMove);\n      document.body.removeEventListener(\'touchmove\', handleMove);\n      document.body.removeEventListener(\'mouseup\', handleUp);\n      document.body.removeEventListener(\'touchend\', handleUp);\n    }\n\n    return function () {\n      document.body.removeEventListener(\'mousemove\', handleMove);\n      document.body.removeEventListener(\'touchmove\', handleMove);\n      document.body.removeEventListener(\'mouseup\', handleUp);\n      document.body.removeEventListener(\'touchend\', handleUp);\n    };\n  }, [active]);\n  var updateValue = (0,react.useCallback)(function (newValue) {\n    if (newValue < min) {\n      newValue = Number(min);\n    } else if (newValue > max) {\n      newValue = Number(max);\n    }\n\n    if (step) {\n      newValue = Math.round(newValue / step) * step;\n    }\n\n    onChange(newValue);\n  }, [min, max, step, onChange]);\n  var handleMove = (0,react.useCallback)(function (event) {\n    var trackClientRect = trackRef.current.getBoundingClientRect();\n    var pageX = getPageX(event);\n    var offsetX = pageX - trackClientRect.left;\n    var percent = offsetX / trackClientRect.width;\n    var value = Number(min) + percent * (max - min);\n    updateValue(value);\n  }, [min, max, updateValue]);\n  var handleKeyDown = (0,react.useCallback)(function (event) {\n    event.preventDefault();\n    var value = Number(inputRef.current.value);\n    var eventKey = getEventKey(event);\n    var newValue = getValueForEventKey(eventKey, value, min, max, step);\n    if (isNaN(newValue)) return;\n    updateValue(newValue);\n  }, [min, max, step, updateValue]);\n  var handleRootInteraction = (0,react.useCallback)(function (event) {\n    handleMove(event);\n  }, [handleMove]);\n  var handleUp = (0,react.useCallback)(function () {\n    setActive(false);\n  }, []);\n  var handleThumbStartInteraction = (0,react.useCallback)(function () {\n    setActive(true);\n  }, []);\n  var handleThumbEndInteraction = (0,react.useCallback)(function () {\n    setActive(false);\n  }, []);\n  var classNames = classnames_default()(slider_constants_cssClasses.ROOT, (_classnames = {}, Slider_defineProperty(_classnames, slider_constants_cssClasses.DISCRETE, discrete), Slider_defineProperty(_classnames, slider_constants_cssClasses.DISABLED, disabled), _classnames), className);\n  return /*#__PURE__*/(0,jsx_runtime.jsxs)("div", Slider_objectSpread(Slider_objectSpread({\n    ref: ref,\n    className: classNames,\n    onMouseDown: handleRootInteraction,\n    onTouchStart: handleRootInteraction\n  }, props), {}, {\n    children: [/*#__PURE__*/(0,jsx_runtime.jsx)(slider_Input, {\n      ref: inputRef,\n      name: name,\n      value: value,\n      min: min,\n      max: max,\n      step: step,\n      disabled: disabled\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(slider_Track, {\n      ref: trackRef,\n      value: value,\n      min: min,\n      max: max,\n      step: step,\n      discrete: discrete,\n      tickMarks: tickMarks\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(slider_Thumb, {\n      value: value,\n      min: min,\n      max: max,\n      discrete: discrete,\n      onStartInteraction: handleThumbStartInteraction,\n      onEndInteraction: handleThumbEndInteraction,\n      onKeyDown: handleKeyDown\n    })]\n  }));\n});\nSlider.displayName = \'MDCSlider\';\nSlider.propTypes = {\n  value: prop_types_default().oneOfType([(prop_types_default()).number, (prop_types_default()).string]),\n  min: prop_types_default().oneOfType([(prop_types_default()).number, (prop_types_default()).string]),\n  max: prop_types_default().oneOfType([(prop_types_default()).number, (prop_types_default()).string]),\n  step: prop_types_default().oneOfType([(prop_types_default()).number, (prop_types_default()).string]),\n  discrete: (prop_types_default()).bool,\n  disabled: (prop_types_default()).bool,\n  tickMarks: (prop_types_default()).bool,\n  onChange: (prop_types_default()).func\n};\n/* harmony default export */ const slider_Slider = (Slider);\n;// CONCATENATED MODULE: ./src/slider/index.js\n\n;// CONCATENATED MODULE: ./src/snackbar/constants.js\nvar snackbar_constants_numbers = {\n  DEFAULT_AUTO_DISMISS_TIMEOUT_MS: 5000,\n  ANIMATION_OPEN_TIME_MS: 150,\n  ANIMATION_CLOSE_TIME_MS: 75\n};\nvar snackbar_constants_cssClasses = {\n  ROOT: \'mdc-snackbar\',\n  LEADING: \'mdc-snackbar--leading\',\n  STACKED: \'mdc-snackbar--stacked\',\n  OPENING: \'mdc-snackbar--opening\',\n  OPEN: \'mdc-snackbar--open\',\n  CLOSING: \'mdc-snackbar--closing\',\n  SURFACE: \'mdc-snackbar__surface\',\n  LABEL: \'mdc-snackbar__label\',\n  ACTIONS: \'mdc-snackbar__actions\',\n  ACTION: \'mdc-snackbar__action\',\n  DISMISS: \'mdc-snackbar__dismiss\'\n};\n;// CONCATENATED MODULE: ./src/snackbar/Snackbar.jsx\nvar Snackbar_excluded = ["label", "action", "dismissIcon", "open", "appear", "leading", "stacked", "dismissible", "timeout", "closeOnEscape", "onClose", "element", "className", "children"];\n\nfunction Snackbar_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction Snackbar_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { Snackbar_ownKeys(Object(source), true).forEach(function (key) { Snackbar_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { Snackbar_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction Snackbar_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction Snackbar_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = Snackbar_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction Snackbar_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\n\n\n\n\n\n\nvar Snackbar = /*#__PURE__*/(0,react.forwardRef)(function (_ref, ref) {\n  var _classnames;\n\n  var label = _ref.label,\n      action = _ref.action,\n      _ref$dismissIcon = _ref.dismissIcon,\n      dismissIcon = _ref$dismissIcon === void 0 ? \'close\' : _ref$dismissIcon,\n      _ref$open = _ref.open,\n      open = _ref$open === void 0 ? false : _ref$open,\n      _ref$appear = _ref.appear,\n      appear = _ref$appear === void 0 ? false : _ref$appear,\n      _ref$leading = _ref.leading,\n      leading = _ref$leading === void 0 ? false : _ref$leading,\n      _ref$stacked = _ref.stacked,\n      stacked = _ref$stacked === void 0 ? false : _ref$stacked,\n      _ref$dismissible = _ref.dismissible,\n      dismissible = _ref$dismissible === void 0 ? true : _ref$dismissible,\n      _ref$timeout = _ref.timeout,\n      timeout = _ref$timeout === void 0 ? snackbar_constants_numbers.DEFAULT_AUTO_DISMISS_TIMEOUT_MS : _ref$timeout,\n      _ref$closeOnEscape = _ref.closeOnEscape,\n      closeOnEscape = _ref$closeOnEscape === void 0 ? true : _ref$closeOnEscape,\n      _ref$onClose = _ref.onClose,\n      onClose = _ref$onClose === void 0 ? Function.prototype : _ref$onClose,\n      _ref$element = _ref.element,\n      Element = _ref$element === void 0 ? \'div\' : _ref$element,\n      className = _ref.className,\n      _ref$children = _ref.children,\n      children = _ref$children === void 0 ? label : _ref$children,\n      props = Snackbar_objectWithoutProperties(_ref, Snackbar_excluded);\n\n  var timeoutRef = (0,react.useRef)();\n  useUpdated(function () {\n    if (open) {\n      timeoutRef.current = setTimeout(function () {\n        timeoutRef.current = null;\n        onClose();\n      }, timeout);\n    } else {\n      if (timeoutRef.current) {\n        clearTimeout(timeoutRef.current);\n        timeoutRef.current = null;\n      }\n    }\n\n    return function () {\n      return clearTimeout(timeoutRef.current);\n    };\n  }, [open]);\n  var handleKeyDown = (0,react.useCallback)(function (event) {\n    if (closeOnEscape && event.key === \'Escape\' || event.keyCode === 27) {\n      onClose();\n    }\n  }, [closeOnEscape, onClose]);\n  var classNames = classnames_default()(snackbar_constants_cssClasses.ROOT, (_classnames = {}, Snackbar_defineProperty(_classnames, snackbar_constants_cssClasses.LEADING, leading), Snackbar_defineProperty(_classnames, snackbar_constants_cssClasses.STACKED, stacked), _classnames), className);\n  return /*#__PURE__*/(0,jsx_runtime.jsx)(Layer, {\n    modal: true,\n    "in": open,\n    appear: appear,\n    timeout: {\n      enter: snackbar_constants_numbers.ANIMATION_OPEN_TIME_MS,\n      exit: snackbar_constants_numbers.ANIMATION_CLOSE_TIME_MS\n    },\n    classNames: {\n      appear: snackbar_constants_cssClasses.OPENING,\n      appearActive: snackbar_constants_cssClasses.OPEN,\n      enter: snackbar_constants_cssClasses.OPENING,\n      enterActive: snackbar_constants_cssClasses.OPEN,\n      enterDone: snackbar_constants_cssClasses.OPEN,\n      exit: snackbar_constants_cssClasses.CLOSING\n    },\n    mountOnEnter: true,\n    unmountOnExit: true,\n    children: /*#__PURE__*/(0,jsx_runtime.jsx)(Element, Snackbar_objectSpread(Snackbar_objectSpread({\n      ref: ref,\n      className: classNames,\n      onKeyDown: handleKeyDown\n    }, props), {}, {\n      children: /*#__PURE__*/(0,jsx_runtime.jsxs)("div", {\n        className: snackbar_constants_cssClasses.SURFACE,\n        role: "status",\n        "aria-relevant": "additions",\n        children: [/*#__PURE__*/(0,jsx_runtime.jsx)("div", {\n          className: snackbar_constants_cssClasses.LABEL,\n          "aria-atomic": "false",\n          children: children\n        }), /*#__PURE__*/(0,jsx_runtime.jsxs)("div", {\n          className: snackbar_constants_cssClasses.ACTIONS,\n          "aria-atomic": "true",\n          children: [action && /*#__PURE__*/(0,jsx_runtime.jsx)(Clone, {\n            component: action,\n            className: snackbar_constants_cssClasses.ACTION\n          }), dismissible && /*#__PURE__*/(0,jsx_runtime.jsx)(Clone, {\n            component: dismissIcon,\n            fallback: icon_button_IconButton,\n            className: snackbar_constants_cssClasses.DISMISS,\n            onClick: onClose\n          })]\n        })]\n      })\n    }))\n  });\n});\nSnackbar.displayName = \'MDCSnackbar\';\nSnackbar.propTypes = {\n  label: (prop_types_default()).string,\n  action: (prop_types_default()).element,\n  dismissIcon: (prop_types_default()).node,\n  open: (prop_types_default()).bool,\n  appear: (prop_types_default()).bool,\n  leading: (prop_types_default()).bool,\n  stacked: (prop_types_default()).bool,\n  dismissible: (prop_types_default()).bool,\n  timeout: (prop_types_default()).number,\n  closeOnEscape: (prop_types_default()).bool,\n  onClose: (prop_types_default()).func\n};\n/* harmony default export */ const snackbar_Snackbar = (Snackbar);\n;// CONCATENATED MODULE: ./src/snackbar/index.js\n\n;// CONCATENATED MODULE: ./src/switch/constants.js\nvar switch_constants_cssClasses = {\n  ROOT: \'mdc-switch\',\n  SELECTED: \'mdc-switch--selected\',\n  UNSELECTED: \'mdc-switch--unselected\',\n  TRACK: \'mdc-switch__track\',\n  HANDLE_TRACK: \'mdc-switch__handle-track\',\n  HANDLE: \'mdc-switch__handle\',\n  SHADOW: \'mdc-switch__shadow\',\n  ELEVATION_OVERLAY: \'mdc-elevation-overlay\',\n  RIPPLE: \'mdc-switch__ripple\',\n  ICONS: \'mdc-switch__icons\',\n  ICON: \'mdc-switch__icon\',\n  ICON_ON: \'mdc-switch__icon--on\',\n  ICON_OFF: \'mdc-switch__icon--off\'\n};\n;// CONCATENATED MODULE: ./src/switch/Switch.jsx\nvar Switch_excluded = ["selected", "onChange", "className"];\n\nfunction Switch_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction Switch_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { Switch_ownKeys(Object(source), true).forEach(function (key) { Switch_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { Switch_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction Switch_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction Switch_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = Switch_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction Switch_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\n\n\nvar Switch_Switch = /*#__PURE__*/(0,react.forwardRef)(function (_ref, ref) {\n  var _classnames;\n\n  var _ref$selected = _ref.selected,\n      selected = _ref$selected === void 0 ? false : _ref$selected,\n      _ref$onChange = _ref.onChange,\n      onChange = _ref$onChange === void 0 ? Function.prototype : _ref$onChange,\n      className = _ref.className,\n      props = Switch_objectWithoutProperties(_ref, Switch_excluded);\n\n  var handleClick = (0,react.useCallback)(function (event) {\n    onChange(event, !selected, event.target);\n  }, [selected, onChange]);\n  var classNames = classnames_default()(switch_constants_cssClasses.ROOT, (_classnames = {}, Switch_defineProperty(_classnames, switch_constants_cssClasses.SELECTED, selected), Switch_defineProperty(_classnames, switch_constants_cssClasses.UNSELECTED, !selected), _classnames), className);\n  return /*#__PURE__*/(0,jsx_runtime.jsxs)("button", Switch_objectSpread(Switch_objectSpread({\n    ref: ref,\n    type: "button",\n    className: classNames,\n    role: "switch",\n    "aria-checked": selected,\n    onClick: handleClick\n  }, props), {}, {\n    children: [/*#__PURE__*/(0,jsx_runtime.jsx)("div", {\n      className: switch_constants_cssClasses.TRACK\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)("div", {\n      className: switch_constants_cssClasses.HANDLE_TRACK,\n      children: /*#__PURE__*/(0,jsx_runtime.jsxs)("div", {\n        className: switch_constants_cssClasses.HANDLE,\n        children: [/*#__PURE__*/(0,jsx_runtime.jsx)("div", {\n          className: switch_constants_cssClasses.SHADOW,\n          children: /*#__PURE__*/(0,jsx_runtime.jsx)("div", {\n            className: switch_constants_cssClasses.ELEVATION_OVERLAY\n          })\n        }), /*#__PURE__*/(0,jsx_runtime.jsx)("div", {\n          className: switch_constants_cssClasses.RIPPLE\n        }), /*#__PURE__*/(0,jsx_runtime.jsxs)("div", {\n          className: switch_constants_cssClasses.ICONS,\n          children: [/*#__PURE__*/(0,jsx_runtime.jsx)("svg", {\n            className: "".concat(switch_constants_cssClasses.ICON, " ").concat(switch_constants_cssClasses.ICON_ON),\n            viewBox: "0 0 24 24",\n            children: /*#__PURE__*/(0,jsx_runtime.jsx)("path", {\n              d: "M19.69,5.23L8.96,15.96l-4.23-4.23L2.96,13.5l6,6L21.46,7L19.69,5.23z"\n            })\n          }), /*#__PURE__*/(0,jsx_runtime.jsx)("svg", {\n            className: "".concat(switch_constants_cssClasses.ICON, " ").concat(switch_constants_cssClasses.ICON_OFF),\n            viewBox: "0 0 24 24",\n            children: /*#__PURE__*/(0,jsx_runtime.jsx)("path", {\n              d: "M20 13H4v-2h16v2z"\n            })\n          })]\n        })]\n      })\n    })]\n  }));\n});\nSwitch_Switch.displayName = \'MDCSwitch\';\nSwitch_Switch.propTypes = {\n  checked: (prop_types_default()).bool,\n  disabled: (prop_types_default()).bool,\n  onChange: (prop_types_default()).func\n};\n/* harmony default export */ const switch_Switch = (Switch_Switch);\n;// CONCATENATED MODULE: ./src/switch/index.js\n\n;// CONCATENATED MODULE: ./src/tabs/constants.js\nvar tabClassNames = {\n  ROOT: \'mdc-tab\',\n  ACTIVE: \'mdc-tab--active\',\n  STACKED: \'mdc-tab--stacked\',\n  MIN_WIDTH: \'mdc-tab--min-width\',\n  CONTENT: \'mdc-tab__content\',\n  ICON: \'mdc-tab__icon\',\n  LABEL: \'mdc-tab__text-label\',\n  RIPPLE: \'mdc-tab__ripple\'\n};\nvar barCssClasses = {\n  ROOT: \'mdc-tab-bar\'\n};\nvar scrollerCssClasses = {\n  ROOT: \'mdc-tab-scroller\',\n  ALIGN: \'mdc-tab-scroller--align\',\n  ANIMATING: \'mdc-tab-scroller--animating\',\n  SCROLL_AREA: \'mdc-tab-scroller__scroll-area\',\n  SCROLL_AREA_SCROLL: \'mdc-tab-scroller__scroll-area--scroll\',\n  SCROLL_CONTENT: \'mdc-tab-scroller__scroll-content\'\n};\nvar indicatorCssClasses = {\n  ROOT: \'mdc-tab-indicator\',\n  ACTIVE: \'mdc-tab-indicator--active\',\n  FADE: \'mdc-tab-indicator--fade\',\n  NO_TRANSITION: \'mdc-tab-indicator--no-transition\',\n  CONTENT: \'mdc-tab-indicator__content\',\n  CONTENT_ICON: \'mdc-tab-indicator__content--icon material-icons\',\n  CONTENT_UNDERLINE: \'mdc-tab-indicator__content--underline\'\n};\nvar Align = {\n  START: \'start\',\n  CENTER: \'center\',\n  END: \'end\'\n};\n;// CONCATENATED MODULE: ./src/tabs/context.js\n\n/* harmony default export */ const tabs_context = (/*#__PURE__*/(0,react.createContext)());\n;// CONCATENATED MODULE: ./src/tabs/TabIndicator.jsx\nvar TabIndicator_excluded = ["icon", "active", "fade", "underline"];\n\nfunction TabIndicator_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction TabIndicator_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { TabIndicator_ownKeys(Object(source), true).forEach(function (key) { TabIndicator_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { TabIndicator_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction TabIndicator_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction TabIndicator_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = TabIndicator_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction TabIndicator_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\n\n\n\nvar TabIndicator = /*#__PURE__*/(0,react.forwardRef)(function (_ref, ref) {\n  var _classnames, _classnames2;\n\n  var icon = _ref.icon,\n      _ref$active = _ref.active,\n      active = _ref$active === void 0 ? false : _ref$active,\n      _ref$fade = _ref.fade,\n      fade = _ref$fade === void 0 ? false : _ref$fade,\n      _ref$underline = _ref.underline,\n      underline = _ref$underline === void 0 ? !icon : _ref$underline,\n      props = TabIndicator_objectWithoutProperties(_ref, TabIndicator_excluded);\n\n  var _useContext = (0,react.useContext)(tabs_context),\n      previousTab = _useContext.previousTab;\n\n  var rootRef = (0,react.useRef)();\n  var contentRef = (0,react.useRef)();\n  (0,react.useImperativeHandle)(ref, function () {\n    return rootRef.current;\n  });\n  useUpdatedSync(function () {\n    if (fade || !active || !previousTab) return;\n    var activeIndicator = rootRef.current;\n    var previousIndicator = previousTab.querySelector(\'.mdc-tab-indicator\');\n    var previousIndicatorClientRect = previousIndicator.getBoundingClientRect();\n    var activeIndicatorClientRect = activeIndicator.getBoundingClientRect();\n    var xPosition = previousIndicatorClientRect.left - activeIndicatorClientRect.left;\n    var widthDelta = previousIndicatorClientRect.width / activeIndicatorClientRect.width;\n    rootRef.current.classList.add(indicatorCssClasses.NO_TRANSITION);\n    contentRef.current.style.transform = "translateX(".concat(xPosition, "px) scaleX(").concat(widthDelta, ")"); // Force repaint before updating classes and transform to ensure the transform properly takes effect\n\n    contentRef.current.getBoundingClientRect();\n    rootRef.current.classList.remove(indicatorCssClasses.NO_TRANSITION);\n    contentRef.current.style.transform = \'\';\n  }, [fade, active]);\n  var rootClassNames = classnames_default()(indicatorCssClasses.ROOT, (_classnames = {}, TabIndicator_defineProperty(_classnames, indicatorCssClasses.ACTIVE, active), TabIndicator_defineProperty(_classnames, indicatorCssClasses.FADE, fade), _classnames));\n  var contentClassNames = classnames_default()(indicatorCssClasses.CONTENT, (_classnames2 = {}, TabIndicator_defineProperty(_classnames2, indicatorCssClasses.CONTENT_ICON, icon), TabIndicator_defineProperty(_classnames2, indicatorCssClasses.CONTENT_UNDERLINE, underline), _classnames2));\n  return /*#__PURE__*/(0,jsx_runtime.jsx)("span", TabIndicator_objectSpread(TabIndicator_objectSpread({\n    ref: rootRef,\n    className: rootClassNames\n  }, props), {}, {\n    children: /*#__PURE__*/(0,jsx_runtime.jsx)("span", {\n      ref: contentRef,\n      className: contentClassNames,\n      children: icon\n    })\n  }));\n});\nTabIndicator.displayName = \'MDCTabIndicator\';\nTabIndicator.propTypes = {\n  icon: (prop_types_default()).node,\n  active: (prop_types_default()).bool,\n  fade: (prop_types_default()).bool,\n  underline: (prop_types_default()).bool\n};\n/* harmony default export */ const tabs_TabIndicator = (TabIndicator);\n;// CONCATENATED MODULE: ./src/tabs/Tab.jsx\nvar Tab_excluded = ["value", "icon", "label", "indicatorIcon", "active", "stacked", "minWidth", "minWidthIndicator", "fade", "underline", "onClick", "element", "component", "className", "children"];\n\nfunction Tab_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction Tab_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { Tab_ownKeys(Object(source), true).forEach(function (key) { Tab_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { Tab_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction Tab_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction Tab_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = Tab_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction Tab_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\n\n\n\n\n\nvar Tab = /*#__PURE__*/(0,react.forwardRef)(function (_ref, ref) {\n  var _classnames;\n\n  var value = _ref.value,\n      icon = _ref.icon,\n      label = _ref.label,\n      indicatorIcon = _ref.indicatorIcon,\n      _ref$active = _ref.active,\n      active = _ref$active === void 0 ? false : _ref$active,\n      _ref$stacked = _ref.stacked,\n      stacked = _ref$stacked === void 0 ? false : _ref$stacked,\n      _ref$minWidth = _ref.minWidth,\n      minWidth = _ref$minWidth === void 0 ? false : _ref$minWidth,\n      _ref$minWidthIndicato = _ref.minWidthIndicator,\n      minWidthIndicator = _ref$minWidthIndicato === void 0 ? false : _ref$minWidthIndicato,\n      _ref$fade = _ref.fade,\n      fade = _ref$fade === void 0 ? false : _ref$fade,\n      _ref$underline = _ref.underline,\n      underline = _ref$underline === void 0 ? !indicatorIcon : _ref$underline,\n      _ref$onClick = _ref.onClick,\n      onClick = _ref$onClick === void 0 ? Function.prototype : _ref$onClick,\n      _ref$element = _ref.element,\n      element = _ref$element === void 0 ? \'button\' : _ref$element,\n      _ref$component = _ref.component,\n      Element = _ref$component === void 0 ? element : _ref$component,\n      className = _ref.className,\n      _ref$children = _ref.children,\n      children = _ref$children === void 0 ? label : _ref$children,\n      props = Tab_objectWithoutProperties(_ref, Tab_excluded);\n\n  var rootRef = (0,react.useRef)();\n  (0,react.useImperativeHandle)(ref, function () {\n    return rootRef.current;\n  });\n  var handleClick = (0,react.useCallback)(function () {\n    onClick(rootRef.current, value);\n  }, [value, onClick]);\n  var classNames = classnames_default()(tabClassNames.ROOT, (_classnames = {}, Tab_defineProperty(_classnames, tabClassNames.ACTIVE, active), Tab_defineProperty(_classnames, tabClassNames.STACKED, stacked), Tab_defineProperty(_classnames, tabClassNames.MIN_WIDTH, minWidth), _classnames), className);\n  return /*#__PURE__*/(0,jsx_runtime.jsxs)(Element, Tab_objectSpread(Tab_objectSpread({\n    ref: rootRef,\n    className: classNames,\n    "data-value": value,\n    role: "tab",\n    "aria-selected": active ? \'true\' : \'false\',\n    tabIndex: active ? 0 : -1,\n    onClick: handleClick\n  }, props), {}, {\n    children: [/*#__PURE__*/(0,jsx_runtime.jsxs)("div", {\n      className: tabClassNames.CONTENT,\n      children: [icon && /*#__PURE__*/(0,jsx_runtime.jsx)(Clone, {\n        component: icon,\n        fallback: icon_Icon,\n        className: tabClassNames.ICON\n      }), children && /*#__PURE__*/(0,jsx_runtime.jsx)("span", {\n        className: tabClassNames.LABEL,\n        children: children\n      }), minWidthIndicator && /*#__PURE__*/(0,jsx_runtime.jsx)(tabs_TabIndicator, {\n        icon: indicatorIcon,\n        active: active,\n        fade: fade,\n        underline: underline\n      })]\n    }), !minWidthIndicator && /*#__PURE__*/(0,jsx_runtime.jsx)(tabs_TabIndicator, {\n      icon: indicatorIcon,\n      active: active,\n      fade: fade,\n      underline: underline\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)("div", {\n      className: tabClassNames.RIPPLE\n    })]\n  }));\n});\nTab.displayName = \'MDCTab\';\nTab.propTypes = {\n  value: (prop_types_default()).any,\n  icon: (prop_types_default()).node,\n  label: (prop_types_default()).node,\n  indicatorIcon: (prop_types_default()).node,\n  active: (prop_types_default()).bool,\n  stacked: (prop_types_default()).bool,\n  minWidth: (prop_types_default()).bool,\n  minWidthIndicator: (prop_types_default()).bool,\n  fade: (prop_types_default()).bool,\n  underline: (prop_types_default()).bool,\n  onActivate: (prop_types_default()).func\n};\n/* harmony default export */ const tabs_Tab = (Tab);\n;// CONCATENATED MODULE: ./src/tabs/TabScroller.jsx\nvar TabScroller_excluded = ["align", "activeTab", "children"];\n\nfunction TabScroller_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction TabScroller_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { TabScroller_ownKeys(Object(source), true).forEach(function (key) { TabScroller_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { TabScroller_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction TabScroller_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction TabScroller_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = TabScroller_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction TabScroller_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\n\nvar TabScroller = /*#__PURE__*/(0,react.forwardRef)(function (_ref, ref) {\n  var align = _ref.align,\n      activeTab = _ref.activeTab,\n      children = _ref.children,\n      props = TabScroller_objectWithoutProperties(_ref, TabScroller_excluded);\n\n  var scrollAreaRef = (0,react.useRef)();\n  var scrollContentRef = (0,react.useRef)();\n  useMounted(function () {\n    var scrollAreaWidth = scrollAreaRef.current.offsetWidth;\n    var scrollContentWidth = scrollContentRef.current.offsetWidth;\n\n    if (scrollContentWidth > scrollAreaWidth) {\n      scrollAreaRef.current.classList.add(scrollerCssClasses.SCROLL_AREA_SCROLL);\n    }\n  });\n  useUpdated(function () {\n    if (!activeTab) return;\n    var scrollAreaWidth = scrollAreaRef.current.offsetWidth;\n    var tabWidth = activeTab.offsetWidth;\n    var tabHalfWidth = tabWidth * 0.5;\n    var offsetLeft = activeTab.offsetLeft - scrollAreaRef.current.scrollLeft;\n    var offsetLeftDelta = activeTab.offsetLeft - scrollAreaRef.current.scrollLeft;\n    var offsetRight = activeTab.offsetLeft + tabWidth - scrollAreaRef.current.scrollLeft;\n    var offsetRightDelta = scrollAreaWidth - offsetRight;\n\n    if (offsetRight > scrollAreaWidth || offsetRightDelta < tabHalfWidth) {\n      scrollAreaRef.current.scrollBy({\n        left: offsetRight > scrollAreaWidth ? Math.abs(offsetRightDelta) + tabHalfWidth : tabHalfWidth - offsetRightDelta,\n        behavior: \'smooth\'\n      });\n    } else if (offsetLeft < 0 || offsetLeftDelta < tabHalfWidth) {\n      scrollAreaRef.current.scrollBy({\n        left: offsetLeft < 0 ? offsetLeftDelta - tabHalfWidth : -(tabHalfWidth - offsetLeftDelta),\n        behavior: \'smooth\'\n      });\n    }\n  }, [activeTab]);\n  var classNames = classnames_default()(scrollerCssClasses.ROOT, TabScroller_defineProperty({}, "".concat(scrollerCssClasses.ALIGN, "-").concat(align), align));\n  return /*#__PURE__*/(0,jsx_runtime.jsx)("div", TabScroller_objectSpread(TabScroller_objectSpread({\n    ref: ref,\n    className: classNames\n  }, props), {}, {\n    children: /*#__PURE__*/(0,jsx_runtime.jsx)("div", {\n      ref: scrollAreaRef,\n      className: scrollerCssClasses.SCROLL_AREA,\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)("div", {\n        ref: scrollContentRef,\n        className: scrollerCssClasses.SCROLL_CONTENT,\n        children: children\n      })\n    })\n  }));\n});\nTabScroller.displayName = \'MDCTabScroller\';\n/* harmony default export */ const tabs_TabScroller = (TabScroller);\n;// CONCATENATED MODULE: ./src/tabs/TabBar.jsx\nvar TabBar_excluded = ["tabs", "value", "align", "indicatorIcon", "stacked", "minWidth", "minWidthIndicator", "fade", "iconIndicator", "underlineIndicator", "onChange", "element", "component", "className", "children"];\n\nfunction TabBar_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction TabBar_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { TabBar_ownKeys(Object(source), true).forEach(function (key) { TabBar_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { TabBar_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction TabBar_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction TabBar_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = TabBar_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction TabBar_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\n\n\n\n\n\n\nvar TabBar = /*#__PURE__*/(0,react.forwardRef)(function (_ref, ref) {\n  var tabs = _ref.tabs,\n      value = _ref.value,\n      align = _ref.align,\n      indicatorIcon = _ref.indicatorIcon,\n      _ref$stacked = _ref.stacked,\n      stacked = _ref$stacked === void 0 ? false : _ref$stacked,\n      _ref$minWidth = _ref.minWidth,\n      minWidth = _ref$minWidth === void 0 ? false : _ref$minWidth,\n      _ref$minWidthIndicato = _ref.minWidthIndicator,\n      minWidthIndicator = _ref$minWidthIndicato === void 0 ? false : _ref$minWidthIndicato,\n      _ref$fade = _ref.fade,\n      fade = _ref$fade === void 0 ? false : _ref$fade,\n      _ref$iconIndicator = _ref.iconIndicator,\n      iconIndicator = _ref$iconIndicator === void 0 ? Boolean(indicatorIcon) : _ref$iconIndicator,\n      _ref$underlineIndicat = _ref.underlineIndicator,\n      underlineIndicator = _ref$underlineIndicat === void 0 ? !iconIndicator : _ref$underlineIndicat,\n      _ref$onChange = _ref.onChange,\n      onChange = _ref$onChange === void 0 ? Function.prototype : _ref$onChange,\n      _ref$element = _ref.element,\n      element = _ref$element === void 0 ? \'div\' : _ref$element,\n      _ref$component = _ref.component,\n      Element = _ref$component === void 0 ? element : _ref$component,\n      className = _ref.className,\n      _ref$children = _ref.children,\n      children = _ref$children === void 0 ? tabs === null || tabs === void 0 ? void 0 : tabs.map(function (tab) {\n    return (0,react.createElement)(tabs_Tab, tab);\n  }) : _ref$children,\n      props = TabBar_objectWithoutProperties(_ref, TabBar_excluded);\n\n  var rootRef = (0,react.useRef)();\n  var activeTabRef = (0,react.useRef)();\n  var previousTabRef = (0,react.useRef)();\n  (0,react.useImperativeHandle)(ref, function () {\n    return rootRef.current;\n  });\n  (0,react.useEffect)(function () {\n    activeTabRef.current = rootRef.current.querySelector(".".concat(tabClassNames.ACTIVE));\n  }, []);\n  var handleTabClick = (0,react.useCallback)(function (element, value) {\n    previousTabRef.current = activeTabRef.current;\n    activeTabRef.current = element;\n    onChange(value);\n  }, [onChange]);\n  var classNames = classnames_default()(barCssClasses.ROOT, className);\n  return /*#__PURE__*/(0,jsx_runtime.jsx)(Element, TabBar_objectSpread(TabBar_objectSpread({\n    ref: rootRef,\n    className: classNames,\n    role: "tablist"\n  }, props), {}, {\n    children: !isUndefined(value) ? /*#__PURE__*/(0,jsx_runtime.jsx)(tabs_context.Provider, {\n      value: {\n        activeTab: activeTabRef.current,\n        previousTab: previousTabRef.current\n      },\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(tabs_TabScroller, {\n        align: align,\n        activeTab: activeTabRef.current,\n        children: react.Children.map(children, function (tab, index) {\n          var tabValue = isUndefined(tab.props.value) ? index : tab.props.value;\n          return (0,react.cloneElement)(tab, {\n            value: tabValue,\n            active: tabValue === value,\n            indicatorIcon: tab.props.indicatorIcon || indicatorIcon,\n            stacked: tab.props.stacked || stacked,\n            minWidth: tab.props.minWidth || minWidth,\n            minWidthIndicator: tab.props.minWidthIndicator || minWidthIndicator,\n            fade: fade,\n            underline: underlineIndicator,\n            onClick: handleTabClick\n          });\n        })\n      })\n    }) : children\n  }));\n});\nTabBar.displayName = \'MDCTabBar\';\nTabBar.propTypes = {\n  align: prop_types_default().oneOf(Object.values(Align)),\n  indicatorIcon: (prop_types_default()).node,\n  stacked: (prop_types_default()).bool,\n  minWidth: (prop_types_default()).bool,\n  fade: (prop_types_default()).bool,\n  iconIndicator: (prop_types_default()).bool,\n  underlineIndicator: (prop_types_default()).bool,\n  onChange: (prop_types_default()).func\n};\nTabBar.Align = Align;\n/* harmony default export */ const tabs_TabBar = (TabBar);\n;// CONCATENATED MODULE: ./src/tabs/index.js\n\n\n;// CONCATENATED MODULE: ./src/tooltip/constants.js\nvar tooltip_constants_numbers = {\n  BOUNDED_ANCHOR_GAP: 4,\n  UNBOUNDED_ANCHOR_GAP: 8,\n  MIN_VIEWPORT_TOOLTIP_THRESHOLD: 8,\n  ENTER_DURATION_MS: 150,\n  EXIT_DURATION_MS: 75,\n  HIDE_DELAY_MS: 600,\n  SHOW_DELAY_MS: 500,\n  MIN_HEIGHT: 24,\n  MAX_WIDTH: 200,\n  CARET_INDENTATION: 24,\n  ANIMATION_SCALE: 0.8\n};\nvar tooltip_constants_cssClasses = {\n  ROOT: \'mdc-tooltip\',\n  RICH: \'mdc-tooltip--rich\',\n  MULTILINE: \'mdc-tooltip--multiline\',\n  SHOWING: \'mdc-tooltip--showing\',\n  ACTIONS: \'mdc-tooltip--rich-actions\',\n  SHOWING_TRANSITION: \'mdc-tooltip--showing-transition\',\n  SHOWN: \'mdc-tooltip--shown\',\n  HIDE: \'mdc-tooltip--hide\',\n  HIDE_TRANSITION: \'mdc-tooltip--hide-transition\',\n  SURFACE: \'mdc-tooltip__surface\',\n  SURFACE_ANIMATION: \'mdc-tooltip__surface-animation\',\n  TITLE: \'mdc-tooltip__title\',\n  CONTENT: \'mdc-tooltip__content\',\n  CONTENT_LINK: \'mdc-tooltip__content-link\',\n  ACTION: \'mdc-tooltip__action\',\n  CARET_TOP: \'mdc-tooltip__caret-surface-top\',\n  CARET_BOTTOM: \'mdc-tooltip__caret-surface-bottom\'\n};\n;// CONCATENATED MODULE: ./src/tooltip/Tooltip.jsx\nfunction Tooltip_slicedToArray(arr, i) { return Tooltip_arrayWithHoles(arr) || Tooltip_iterableToArrayLimit(arr, i) || Tooltip_unsupportedIterableToArray(arr, i) || Tooltip_nonIterableRest(); }\n\nfunction Tooltip_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction Tooltip_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return Tooltip_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return Tooltip_arrayLikeToArray(o, minLen); }\n\nfunction Tooltip_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction Tooltip_iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction Tooltip_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\n\n\n\n\n\n\n\n\nvar Tooltip = /*#__PURE__*/(0,react.forwardRef)(function (_ref, ref) {\n  var label = _ref.label,\n      _ref$element = _ref.element,\n      Element = _ref$element === void 0 ? \'div\' : _ref$element,\n      className = _ref.className,\n      children = _ref.children;\n  var tooltipRef = (0,react.useRef)();\n  var targetRef = (0,react.useRef)(null);\n\n  var _useState = (0,react.useState)(false),\n      _useState2 = Tooltip_slicedToArray(_useState, 2),\n      active = _useState2[0],\n      setActive = _useState2[1];\n\n  (0,react.useImperativeHandle)(ref, function () {\n    return tooltipRef.current;\n  });\n  (0,react.useEffect)(function () {\n    function handleScroll() {\n      setActive(function (active) {\n        return active && !active;\n      });\n    }\n\n    document.addEventListener(\'scroll\', handleScroll);\n    return function () {\n      document.removeEventListener(\'scroll\', handleScroll);\n    };\n  }, []);\n  var handleMouseEnter = (0,react.useCallback)(function (event) {\n    targetRef.current = event.currentTarget;\n    setActive(true);\n  }, []);\n  var handleMouseLeave = (0,react.useCallback)(function () {\n    targetRef.current = null;\n    setActive(false);\n  }, []);\n  var handleEntering = (0,react.useCallback)(function () {\n    var tooltipRect = tooltipRef.current.getBoundingClientRect();\n    var targetRect = targetRef.current.getBoundingClientRect();\n    var top = targetRect.top + targetRect.height + tooltip_constants_numbers.UNBOUNDED_ANCHOR_GAP;\n    var left = targetRect.left + targetRect.width * 0.5 - tooltipRect.width * 0.5;\n    var right = left + tooltipRect.width;\n    var bottom = top + tooltipRect.height;\n    var overflowBottom = window.innerHeight - bottom;\n    var overflowRight = window.innerWidth - right;\n\n    if (tooltipRect.height > tooltip_constants_numbers.MIN_HEIGHT && tooltipRect.width >= tooltip_constants_numbers.MAX_WIDTH) {\n      tooltipRef.current.classList.add(tooltip_constants_cssClasses.MULTILINE);\n    }\n\n    if (overflowBottom < 0) {\n      tooltipRef.current.style.top = "".concat(targetRect.top - tooltipRect.height - tooltip_constants_numbers.UNBOUNDED_ANCHOR_GAP, "px");\n    } else {\n      tooltipRef.current.style.top = "".concat(top, "px");\n    }\n\n    if (overflowRight < 0) {\n      tooltipRef.current.style.left = "".concat(targetRect.right - tooltipRect.width, "px");\n    } else {\n      tooltipRef.current.style.left = "".concat(left < 0 ? targetRect.left : left, "px");\n    }\n  }, []);\n  var classNames = classnames_default()(tooltip_constants_cssClasses.ROOT, className);\n  return /*#__PURE__*/(0,jsx_runtime.jsxs)(jsx_runtime.Fragment, {\n    children: [/*#__PURE__*/(0,jsx_runtime.jsx)(Clone, {\n      component: children,\n      onMouseEnter: handleMouseEnter,\n      onMouseLeave: handleMouseLeave\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Layer, {\n      modal: true,\n      "in": active,\n      timeout: {\n        enter: tooltip_constants_numbers.SHOW_DELAY_MS,\n        exit: tooltip_constants_numbers.HIDE_DELAY_MS\n      },\n      classNames: {\n        enter: tooltip_constants_cssClasses.SHOWING_TRANSITION,\n        enterActive: "".concat(tooltip_constants_cssClasses.SHOWING_TRANSITION, " ").concat(tooltip_constants_cssClasses.SHOWING),\n        enterDone: "".concat(tooltip_constants_cssClasses.SHOWING_TRANSITION, " ").concat(tooltip_constants_cssClasses.SHOWN),\n        exit: "".concat(tooltip_constants_cssClasses.HIDE_TRANSITION, " ").concat(tooltip_constants_cssClasses.HIDE),\n        exitActive: "".concat(tooltip_constants_cssClasses.HIDE_TRANSITION, " ").concat(tooltip_constants_cssClasses.HIDE)\n      },\n      onEntering: handleEntering,\n      mountOnEnter: true,\n      unmountOnExit: true,\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(Element, {\n        ref: tooltipRef,\n        className: classNames,\n        role: "tooltip",\n        "aria-hidden": active ? undefined : \'true\',\n        children: /*#__PURE__*/(0,jsx_runtime.jsx)("div", {\n          className: "".concat(tooltip_constants_cssClasses.SURFACE, " ").concat(tooltip_constants_cssClasses.SURFACE_ANIMATION),\n          children: label\n        })\n      })\n    })]\n  });\n});\nTooltip.displayName = \'MDCTooltip\';\n/* harmony default export */ const tooltip_Tooltip = (Tooltip);\n;// CONCATENATED MODULE: ./src/tooltip/RichTooltip.jsx\nfunction RichTooltip_slicedToArray(arr, i) { return RichTooltip_arrayWithHoles(arr) || RichTooltip_iterableToArrayLimit(arr, i) || RichTooltip_unsupportedIterableToArray(arr, i) || RichTooltip_nonIterableRest(); }\n\nfunction RichTooltip_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction RichTooltip_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return RichTooltip_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return RichTooltip_arrayLikeToArray(o, minLen); }\n\nfunction RichTooltip_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction RichTooltip_iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction RichTooltip_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\n\n\n\n\n\n\n\n\nvar RichTooltip = /*#__PURE__*/(0,react.forwardRef)(function (_ref, ref) {\n  var title = _ref.title,\n      content = _ref.content,\n      actions = _ref.actions,\n      _ref$element = _ref.element,\n      Element = _ref$element === void 0 ? \'div\' : _ref$element,\n      className = _ref.className,\n      children = _ref.children;\n  var tooltipRef = (0,react.useRef)();\n  var targetRef = (0,react.useRef)();\n\n  var _useState = (0,react.useState)(false),\n      _useState2 = RichTooltip_slicedToArray(_useState, 2),\n      active = _useState2[0],\n      setActive = _useState2[1];\n\n  (0,react.useImperativeHandle)(ref, function () {\n    return tooltipRef.current;\n  });\n  (0,react.useEffect)(function () {\n    function handleScroll() {\n      setActive(function (active) {\n        return active && !active;\n      });\n    }\n\n    document.addEventListener(\'scroll\', handleScroll);\n    return function () {\n      document.removeEventListener(\'scroll\', handleScroll);\n    };\n  }, []);\n  var handleTargetMouseEnter = (0,react.useCallback)(function () {\n    setActive(true);\n  }, []);\n  var handleTargetMouseLeave = (0,react.useCallback)(function () {\n    setActive(false);\n  }, []);\n  var handleTooltipMouseEnter = (0,react.useCallback)(function () {\n    setActive(true);\n  }, []);\n  var handleTooltipMouseLeave = (0,react.useCallback)(function () {\n    setActive(false);\n  }, []);\n  var handleEntering = (0,react.useCallback)(function () {\n    var tooltipRect = tooltipRef.current.getBoundingClientRect();\n    var targetRect = targetRef.current.getBoundingClientRect();\n    var width = tooltipRef.current.firstChild.clientWidth;\n    var height = tooltipRef.current.firstChild.scrollHeight;\n    var top = targetRect.bottom + window.scrollY + tooltip_constants_numbers.UNBOUNDED_ANCHOR_GAP;\n    var left = targetRect.right + window.scrollX + tooltip_constants_numbers.UNBOUNDED_ANCHOR_GAP;\n    var right = left + width + tooltip_constants_numbers.MIN_VIEWPORT_TOOLTIP_THRESHOLD;\n    var bottom = top + height + tooltip_constants_numbers.MIN_VIEWPORT_TOOLTIP_THRESHOLD;\n    var overflowBottom = window.innerHeight - bottom;\n    var overflowRight = window.innerWidth - right;\n\n    if (overflowBottom < 0) {\n      tooltipRef.current.style.top = "".concat(top + overflowBottom, "px");\n    } else {\n      tooltipRef.current.style.top = "".concat(top, "px");\n    }\n\n    if (overflowRight < 0) {\n      tooltipRef.current.style.left = "".concat(targetRect.right - tooltipRect.width, "px");\n    } else {\n      tooltipRef.current.style.left = "".concat(left < 0 ? targetRect.left : left, "px");\n    }\n\n    tooltipRef.current.getBoundingClientRect();\n  }, []);\n  var classNames = classnames_default()(tooltip_constants_cssClasses.ROOT, tooltip_constants_cssClasses.RICH, className);\n  return /*#__PURE__*/(0,jsx_runtime.jsxs)(jsx_runtime.Fragment, {\n    children: [/*#__PURE__*/(0,jsx_runtime.jsx)(Clone, {\n      component: children,\n      ref: targetRef,\n      onMouseEnter: handleTargetMouseEnter,\n      onMouseLeave: handleTargetMouseLeave\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Layer, {\n      modal: true,\n      "in": active,\n      timeout: {\n        enter: tooltip_constants_numbers.SHOW_DELAY_MS,\n        exit: tooltip_constants_numbers.HIDE_DELAY_MS\n      },\n      classNames: {\n        enter: tooltip_constants_cssClasses.SHOWING_TRANSITION,\n        enterActive: "".concat(tooltip_constants_cssClasses.SHOWING_TRANSITION, " ").concat(tooltip_constants_cssClasses.SHOWING),\n        enterDone: "".concat(tooltip_constants_cssClasses.SHOWING_TRANSITION, " ").concat(tooltip_constants_cssClasses.SHOWN),\n        exit: tooltip_constants_cssClasses.SHOWN,\n        exitActive: "".concat(tooltip_constants_cssClasses.HIDE_TRANSITION, " ").concat(tooltip_constants_cssClasses.SHOWN),\n        exitDone: "".concat(tooltip_constants_cssClasses.HIDE_TRANSITION, " ").concat(tooltip_constants_cssClasses.HIDE)\n      },\n      mountOnEnter: true,\n      unmountOnExit: true,\n      onEntering: handleEntering,\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(Element, {\n        ref: tooltipRef,\n        className: classNames,\n        role: "tooltip",\n        "aria-hidden": active ? undefined : \'true\',\n        "aria-expanded": active ? \'true\' : undefined,\n        onMouseEnter: handleTooltipMouseEnter,\n        onMouseLeave: handleTooltipMouseLeave,\n        children: /*#__PURE__*/(0,jsx_runtime.jsxs)("div", {\n          className: "".concat(tooltip_constants_cssClasses.SURFACE, " ").concat(tooltip_constants_cssClasses.SURFACE_ANIMATION),\n          children: [title && /*#__PURE__*/(0,jsx_runtime.jsx)("h2", {\n            className: tooltip_constants_cssClasses.TITLE,\n            children: title\n          }), content && /*#__PURE__*/(0,jsx_runtime.jsx)("p", {\n            className: tooltip_constants_cssClasses.CONTENT,\n            children: content\n          }), actions && /*#__PURE__*/(0,jsx_runtime.jsx)("div", {\n            className: tooltip_constants_cssClasses.ACTIONS,\n            children: react.Children.map(actions, function (action) {\n              return /*#__PURE__*/(0,jsx_runtime.jsx)(Clone, {\n                component: action,\n                "aria-label": "action"\n              });\n            })\n          })]\n        })\n      })\n    })]\n  });\n});\nRichTooltip.displayName = \'MDCRichTooltip\';\n/* harmony default export */ const tooltip_RichTooltip = (RichTooltip);\n;// CONCATENATED MODULE: ./src/tooltip/index.js\n\n\n;// CONCATENATED MODULE: ./src/text-field/constants.js\nvar text_field_constants_cssClasses = {\n  ROOT: \'mdc-text-field\',\n  FILLED: \'mdc-text-field--filled\',\n  OUTLINED: \'mdc-text-field--outlined\',\n  TEXTAREA: \'mdc-text-field--textarea\',\n  DISABLED: \'mdc-text-field--disabled\',\n  FOCUSED: \'mdc-text-field--focused\',\n  INVALID: \'mdc-text-field--invalid\',\n  LABEL_FLOATING: \'mdc-text-field--label-floating\',\n  NO_LABEL: \'mdc-text-field--no-label\',\n  END_ALIGNED: \'mdc-text-field--end-aligned\',\n  WITH_LEADING_ICON: \'mdc-text-field--with-leading-icon\',\n  WITH_TRAILING_ICON: \'mdc-text-field--with-trailing-icon\',\n  WITH_INTERNAL_COUNTER: \'mdc-text-field--with-internal-counter\',\n  ICON: \'mdc-text-field__icon\',\n  ICON_LEADING: \'mdc-text-field__icon--leading\',\n  ICON_TRAILING: \'mdc-text-field__icon--leading\',\n  INPUT: \'mdc-text-field__input\',\n  AFFIX: \'mdc-text-field__affix\',\n  AFFIX_PREFIX: \'mdc-text-field__affix--prefix\',\n  AFFIX_SUFFIX: \'mdc-text-field__affix--suffix\',\n  RESIZER: \'mdc-text-field__resizer\',\n  RIPPLE: \'mdc-text-field__ripple\',\n  HELPER_LINE: \'mdc-text-field-helper-line\',\n  HELPER_TEXT: \'mdc-text-field-helper-text\',\n  HELPER_TEXT_PERSISTENT: \'mdc-text-field-helper-text--persistent\',\n  HELPER_TEXT_VALIDATION: \'mdc-text-field-helper-text--validation-msg\',\n  CHARACTER_COUNTER: \'mdc-text-field-character-counter\'\n};\n;// CONCATENATED MODULE: ./src/text-field/HelperText.jsx\nvar text_field_HelperText_excluded = ["persistent", "validation"];\n\nfunction text_field_HelperText_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction text_field_HelperText_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { text_field_HelperText_ownKeys(Object(source), true).forEach(function (key) { text_field_HelperText_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { text_field_HelperText_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction text_field_HelperText_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction text_field_HelperText_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = text_field_HelperText_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction text_field_HelperText_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\n\nvar HelperText_HelperText = function HelperText(_ref) {\n  var _classnames;\n\n  var _ref$persistent = _ref.persistent,\n      persistent = _ref$persistent === void 0 ? false : _ref$persistent,\n      _ref$validation = _ref.validation,\n      validation = _ref$validation === void 0 ? false : _ref$validation,\n      props = text_field_HelperText_objectWithoutProperties(_ref, text_field_HelperText_excluded);\n\n  var classNames = classnames_default()(text_field_constants_cssClasses.HELPER_TEXT, (_classnames = {}, text_field_HelperText_defineProperty(_classnames, text_field_constants_cssClasses.HELPER_TEXT_PERSISTENT, persistent), text_field_HelperText_defineProperty(_classnames, text_field_constants_cssClasses.HELPER_TEXT_VALIDATION, validation), _classnames));\n  return /*#__PURE__*/(0,jsx_runtime.jsx)("div", text_field_HelperText_objectSpread({\n    className: classNames\n  }, props));\n};\n\nHelperText_HelperText.displayName = \'MDCTextFieldHelperText\';\nHelperText_HelperText.propTypes = {\n  persistent: (prop_types_default()).bool,\n  validation: (prop_types_default()).bool\n};\n/* harmony default export */ const text_field_HelperText = (HelperText_HelperText);\n;// CONCATENATED MODULE: ./src/text-field/CharacterCounter.jsx\nvar CharacterCounter_excluded = ["value", "maxValue"];\n\nfunction CharacterCounter_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction CharacterCounter_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { CharacterCounter_ownKeys(Object(source), true).forEach(function (key) { CharacterCounter_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { CharacterCounter_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction CharacterCounter_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction CharacterCounter_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = CharacterCounter_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction CharacterCounter_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\nfunction CharacterCounter(_ref) {\n  var _ref$value = _ref.value,\n      value = _ref$value === void 0 ? 0 : _ref$value,\n      maxValue = _ref.maxValue,\n      props = CharacterCounter_objectWithoutProperties(_ref, CharacterCounter_excluded);\n\n  return /*#__PURE__*/(0,jsx_runtime.jsx)("div", CharacterCounter_objectSpread(CharacterCounter_objectSpread({\n    className: "mdc-text-field-character-counter"\n  }, props), {}, {\n    children: "".concat(value, " / ").concat(maxValue)\n  }));\n}\nCharacterCounter.displayName = \'MDCTextFieldCharacterCounter\';\nCharacterCounter.propTypes = {\n  value: (prop_types_default()).number,\n  maxValue: (prop_types_default()).number\n};\n;// CONCATENATED MODULE: ./src/text-field/Input.jsx\nvar text_field_Input_excluded = ["textarea", "autoResize", "element"];\n\nfunction text_field_Input_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction text_field_Input_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { text_field_Input_ownKeys(Object(source), true).forEach(function (key) { text_field_Input_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { text_field_Input_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction text_field_Input_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction text_field_Input_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = text_field_Input_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction text_field_Input_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\nvar Input_Input = /*#__PURE__*/(0,react.forwardRef)(function (_ref, ref) {\n  var textarea = _ref.textarea,\n      autoResize = _ref.autoResize,\n      _ref$element = _ref.element,\n      Element = _ref$element === void 0 ? textarea ? \'textarea\' : \'input\' : _ref$element,\n      props = text_field_Input_objectWithoutProperties(_ref, text_field_Input_excluded);\n\n  (0,react.useLayoutEffect)(function () {\n    if (!autoResize) return;\n    var element = ref.current;\n\n    function setHeight() {\n      element.style.height = \'1rem\';\n      element.style.height = "".concat(element.scrollHeight, "px");\n    }\n\n    setHeight();\n    element.addEventListener(\'input\', setHeight);\n    return function () {\n      return element.removeEventListener(\'input\', setHeight);\n    };\n  }, [autoResize, ref]);\n  return /*#__PURE__*/(0,jsx_runtime.jsx)(Element, text_field_Input_objectSpread({\n    ref: ref,\n    className: text_field_constants_cssClasses.INPUT\n  }, props));\n});\nInput_Input.displayName = \'MDCTextFieldInput\';\n/* harmony default export */ const text_field_Input = (Input_Input);\n;// CONCATENATED MODULE: ./src/text-field/Resizer.jsx\nvar Resizer_excluded = ["textarea", "autoResize", "children"];\n\nfunction Resizer_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction Resizer_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { Resizer_ownKeys(Object(source), true).forEach(function (key) { Resizer_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { Resizer_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction Resizer_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction Resizer_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = Resizer_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction Resizer_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\nvar Resizer = function Resizer(_ref) {\n  var textarea = _ref.textarea,\n      autoResize = _ref.autoResize,\n      children = _ref.children,\n      props = Resizer_objectWithoutProperties(_ref, Resizer_excluded);\n\n  return textarea && !autoResize ? /*#__PURE__*/(0,jsx_runtime.jsx)("span", Resizer_objectSpread(Resizer_objectSpread({\n    className: text_field_constants_cssClasses.RESIZER\n  }, props), {}, {\n    children: children\n  })) : children;\n};\n\nResizer.displayName = \'MDCTextFieldResizer\';\n/* harmony default export */ const text_field_Resizer = (Resizer);\n;// CONCATENATED MODULE: ./src/text-field/TextField.jsx\nvar TextField_excluded = ["value", "defaultValue", "label", "leadingIcon", "trailingIcon", "prefix", "suffix", "persistentHelperText", "helperText", "validationMessage", "filled", "outlined", "fullWidth", "disabled", "textarea", "endAligned", "autoResize", "internalCounter", "className", "element", "onChange"];\n\nfunction TextField_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction TextField_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { TextField_ownKeys(Object(source), true).forEach(function (key) { TextField_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { TextField_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction TextField_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction TextField_slicedToArray(arr, i) { return TextField_arrayWithHoles(arr) || TextField_iterableToArrayLimit(arr, i) || TextField_unsupportedIterableToArray(arr, i) || TextField_nonIterableRest(); }\n\nfunction TextField_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction TextField_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return TextField_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return TextField_arrayLikeToArray(o, minLen); }\n\nfunction TextField_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction TextField_iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction TextField_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction TextField_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = TextField_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction TextField_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nvar TextField = /*#__PURE__*/(0,react.forwardRef)(function (_ref, ref) {\n  var _inputRef$current2, _classnames, _inputRef$current3;\n\n  var value = _ref.value,\n      defaultValue = _ref.defaultValue,\n      label = _ref.label,\n      leadingIcon = _ref.leadingIcon,\n      trailingIcon = _ref.trailingIcon,\n      prefix = _ref.prefix,\n      suffix = _ref.suffix,\n      persistentHelperText = _ref.persistentHelperText,\n      _ref$helperText = _ref.helperText,\n      helperText = _ref$helperText === void 0 ? persistentHelperText : _ref$helperText,\n      validationMessage = _ref.validationMessage,\n      _ref$filled = _ref.filled,\n      filled = _ref$filled === void 0 ? false : _ref$filled,\n      _ref$outlined = _ref.outlined,\n      outlined = _ref$outlined === void 0 ? false : _ref$outlined,\n      _ref$fullWidth = _ref.fullWidth,\n      fullWidth = _ref$fullWidth === void 0 ? false : _ref$fullWidth,\n      _ref$disabled = _ref.disabled,\n      disabled = _ref$disabled === void 0 ? false : _ref$disabled,\n      _ref$textarea = _ref.textarea,\n      textarea = _ref$textarea === void 0 ? false : _ref$textarea,\n      _ref$endAligned = _ref.endAligned,\n      endAligned = _ref$endAligned === void 0 ? false : _ref$endAligned,\n      _ref$autoResize = _ref.autoResize,\n      autoResize = _ref$autoResize === void 0 ? false : _ref$autoResize,\n      _ref$internalCounter = _ref.internalCounter,\n      internalCounter = _ref$internalCounter === void 0 ? false : _ref$internalCounter,\n      className = _ref.className,\n      _ref$element = _ref.element,\n      Element = _ref$element === void 0 ? \'label\' : _ref$element,\n      _ref$onChange = _ref.onChange,\n      onChange = _ref$onChange === void 0 ? Function.prototype : _ref$onChange,\n      props = TextField_objectWithoutProperties(_ref, TextField_excluded);\n\n  var inputRef = (0,react.useRef)();\n\n  var _useState = (0,react.useState)(false),\n      _useState2 = TextField_slicedToArray(_useState, 2),\n      focused = _useState2[0],\n      setFocused = _useState2[1];\n\n  var _useState3 = (0,react.useState)(false),\n      _useState4 = TextField_slicedToArray(_useState3, 2),\n      touched = _useState4[0],\n      setTouched = _useState4[1];\n\n  var _useState5 = (0,react.useState)(true),\n      _useState6 = TextField_slicedToArray(_useState5, 2),\n      valid = _useState6[0],\n      setValid = _useState6[1];\n\n  var _useState7 = (0,react.useState)(),\n      _useState8 = TextField_slicedToArray(_useState7, 2),\n      interactionCoords = _useState8[0],\n      setInteractionCoords = _useState8[1];\n\n  var _useState9 = (0,react.useState)((value === null || value === void 0 ? void 0 : value.length) || (defaultValue === null || defaultValue === void 0 ? void 0 : defaultValue.value) || 0),\n      _useState10 = TextField_slicedToArray(_useState9, 2),\n      count = _useState10[0],\n      setCount = _useState10[1];\n\n  var handleInteraction = (0,react.useCallback)(function (event) {\n    var targetClientRect = event.target.getBoundingClientRect();\n    setInteractionCoords({\n      x: event.clientX - targetClientRect.left,\n      y: event.clientY - targetClientRect.top\n    });\n  }, []);\n  var handleInputFocus = (0,react.useCallback)(function () {\n    setFocused(true);\n    setTouched(true);\n  }, []);\n  var handleInputBlur = (0,react.useCallback)(function () {\n    setFocused(false);\n    setInteractionCoords();\n  }, []);\n  var handleInputChange = (0,react.useCallback)(function (event) {\n    var _inputRef$current;\n\n    var value = inputRef.current.value;\n    var isValid = (_inputRef$current = inputRef.current) === null || _inputRef$current === void 0 ? void 0 : _inputRef$current.validity.valid;\n    setCount(value.length);\n    setValid(isValid);\n    onChange(event, value);\n  }, [onChange]);\n  var focusedOrHasValue = focused || value !== undefined && value !== null && value !== \'\' || defaultValue !== undefined && defaultValue !== null && defaultValue !== \'\' || Boolean((_inputRef$current2 = inputRef.current) === null || _inputRef$current2 === void 0 ? void 0 : _inputRef$current2.value);\n  var hasHelperLine = helperText || validationMessage || props.maxLength;\n  var classNames = classnames_default()(text_field_constants_cssClasses.ROOT, (_classnames = {}, TextField_defineProperty(_classnames, text_field_constants_cssClasses.FILLED, filled && !fullWidth), TextField_defineProperty(_classnames, text_field_constants_cssClasses.OUTLINED, outlined && !fullWidth), TextField_defineProperty(_classnames, text_field_constants_cssClasses.TEXTAREA, textarea), TextField_defineProperty(_classnames, text_field_constants_cssClasses.DISABLED, disabled), TextField_defineProperty(_classnames, text_field_constants_cssClasses.FOCUSED, focused), TextField_defineProperty(_classnames, text_field_constants_cssClasses.INVALID, !valid && touched), TextField_defineProperty(_classnames, text_field_constants_cssClasses.LABEL_FLOATING, focusedOrHasValue), TextField_defineProperty(_classnames, text_field_constants_cssClasses.NO_LABEL, !label), TextField_defineProperty(_classnames, text_field_constants_cssClasses.END_ALIGNED, endAligned), TextField_defineProperty(_classnames, text_field_constants_cssClasses.WITH_LEADING_ICON, leadingIcon), TextField_defineProperty(_classnames, text_field_constants_cssClasses.WITH_TRAILING_ICON, trailingIcon), TextField_defineProperty(_classnames, text_field_constants_cssClasses.WITH_INTERNAL_COUNTER, internalCounter), _classnames), className);\n  return /*#__PURE__*/(0,jsx_runtime.jsxs)(jsx_runtime.Fragment, {\n    children: [/*#__PURE__*/(0,jsx_runtime.jsxs)(Element, {\n      ref: ref,\n      className: classNames,\n      onMouseDown: handleInteraction,\n      onTouchStart: handleInteraction,\n      children: [filled && /*#__PURE__*/(0,jsx_runtime.jsx)("div", {\n        className: text_field_constants_cssClasses.RIPPLE\n      }), filled && label && /*#__PURE__*/(0,jsx_runtime.jsx)(floating_label_FloatingLabel, {\n        label: label,\n        "float": focusedOrHasValue\n      }), outlined && /*#__PURE__*/(0,jsx_runtime.jsx)(notched_outline_NotchedOutline, {\n        notched: focusedOrHasValue,\n        children: label && /*#__PURE__*/(0,jsx_runtime.jsx)(floating_label_FloatingLabel, {\n          label: label,\n          "float": focusedOrHasValue\n        })\n      }), leadingIcon && /*#__PURE__*/(0,jsx_runtime.jsx)(Clone, {\n        component: leadingIcon,\n        fallback: icon_Icon,\n        className: "".concat(text_field_constants_cssClasses.ICON, " ").concat(text_field_constants_cssClasses.ICON_LEADING),\n        tabIndex: "0",\n        role: "button"\n      }), prefix && /*#__PURE__*/(0,jsx_runtime.jsx)("span", {\n        className: "".concat(text_field_constants_cssClasses.AFFIX, " ").concat(text_field_constants_cssClasses.AFFIX_PREFIX),\n        children: prefix\n      }), /*#__PURE__*/(0,jsx_runtime.jsxs)(text_field_Resizer, {\n        textarea: textarea,\n        autoResize: autoResize,\n        children: [/*#__PURE__*/(0,jsx_runtime.jsx)(text_field_Input, TextField_objectSpread({\n          ref: inputRef,\n          value: value,\n          defaultValue: defaultValue,\n          textarea: textarea,\n          autoResize: autoResize,\n          disabled: disabled,\n          onInput: handleInputChange,\n          onFocus: handleInputFocus,\n          onBlur: handleInputBlur\n        }, props)), internalCounter && /*#__PURE__*/(0,jsx_runtime.jsx)(CharacterCounter, {\n          value: count,\n          maxValue: props.maxLength\n        })]\n      }), suffix && /*#__PURE__*/(0,jsx_runtime.jsx)("span", {\n        className: "".concat(text_field_constants_cssClasses.AFFIX, " ").concat(text_field_constants_cssClasses.AFFIX_SUFFIX),\n        children: suffix\n      }), trailingIcon && /*#__PURE__*/(0,jsx_runtime.jsx)(Clone, {\n        component: trailingIcon,\n        fallback: icon_Icon,\n        className: "".concat(text_field_constants_cssClasses.ICON, " ").concat(text_field_constants_cssClasses.ICON_TRAILING),\n        tabIndex: "0",\n        role: "button"\n      }), filled && /*#__PURE__*/(0,jsx_runtime.jsx)(line_ripple_LineRipple, {\n        active: focused,\n        transformOrigin: interactionCoords === null || interactionCoords === void 0 ? void 0 : interactionCoords.x\n      })]\n    }), hasHelperLine && /*#__PURE__*/(0,jsx_runtime.jsxs)("div", {\n      className: text_field_constants_cssClasses.HELPER_LINE,\n      children: [helperText && /*#__PURE__*/(0,jsx_runtime.jsx)(text_field_HelperText, {\n        persistent: Boolean(persistentHelperText),\n        children: helperText\n      }), validationMessage && !valid && /*#__PURE__*/(0,jsx_runtime.jsx)(text_field_HelperText, {\n        validation: true,\n        children: typeof validationMessage === \'string\' ? validationMessage : (_inputRef$current3 = inputRef.current) === null || _inputRef$current3 === void 0 ? void 0 : _inputRef$current3.validationMessage\n      }), props.maxLength && !internalCounter && /*#__PURE__*/(0,jsx_runtime.jsx)(CharacterCounter, {\n        value: count,\n        maxValue: props.maxLength\n      })]\n    })]\n  });\n});\nTextField.displayName = \'MDCTextField\';\nTextField.propTypes = {\n  value: (prop_types_default()).any,\n  label: (prop_types_default()).string,\n  leadingIcon: (prop_types_default()).node,\n  trailingIcon: (prop_types_default()).node,\n  prefix: (prop_types_default()).string,\n  suffix: (prop_types_default()).string,\n  outline: (prop_types_default()).bool,\n  fullWidth: (prop_types_default()).bool,\n  textarea: (prop_types_default()).bool,\n  dense: (prop_types_default()).bool,\n  disabled: (prop_types_default()).bool,\n  helperText: (prop_types_default()).string,\n  persistentHelperText: (prop_types_default()).string,\n  validationMessage: prop_types_default().oneOfType([(prop_types_default()).bool, (prop_types_default()).string])\n};\n/* harmony default export */ const text_field_TextField = (TextField);\n;// CONCATENATED MODULE: ./src/text-field/index.js\n\n;// CONCATENATED MODULE: ./src/top-app-bar/constants.js\nvar top_app_bar_constants_numbers = {\n  DEBOUNCE_THROTTLE_RESIZE_TIME_MS: 100,\n  MAX_TOP_APP_BAR_HEIGHT: 128\n};\nvar top_app_bar_constants_cssClasses = {\n  ROOT: \'mdc-top-app-bar\',\n  STICKY: \'mdc-top-app-bar--sticky\',\n  STICKY_HIDDEN: \'mdc-top-app-bar--sticky-hidden\',\n  STICKY_SHOWN: \'mdc-top-app-bar--sticky-shown\',\n  FIXED: \'mdc-top-app-bar--fixed\',\n  FIXED_SCROLLED: \'mdc-top-app-bar--fixed-scrolled\',\n  FIXED_ADJUST: \'mdc-top-app-bar--fixed-adjust\',\n  PROMINENT: \'mdc-top-app-bar--prominent\',\n  PROMINENT_FIXED_ADJUST: \'mdc-top-app-bar--prominent-fixed-adjust\',\n  DENSE: \'mdc-top-app-bar--dense\',\n  DENSE_FIXED_ADJUST: \'mdc-top-app-bar--dense-fixed-adjust\',\n  DENSE_PROMINENT_FIXED_ADJUST: \'mdc-top-app-bar--dense-prominent-fixed-adjust\',\n  SHORT: \'mdc-top-app-bar--short\',\n  SHORT_COLLAPSED: \'mdc-top-app-bar--short-collapsed\',\n  SHORT_FIXED_ADJUST: \'mdc-top-app-bar--short-fixed-adjust\',\n  ROW: \'mdc-top-app-bar__row\',\n  SECTION: \'mdc-top-app-bar__section\',\n  SECTION_ALIGN_START: \'mdc-top-app-bar__section--align-start\',\n  SECTION_ALIGN_CENTER: \'mdc-top-app-bar__section--align-center\',\n  SECTION_ALIGN_END: \'mdc-top-app-bar__section--align-end\',\n  NAVIGATION_ICON: \'mdc-top-app-bar__navigation-icon\',\n  ACTION_ITEM: \'mdc-top-app-bar__action-item\',\n  TITLE: \'mdc-top-app-bar__title\'\n};\nvar constants_Align = {\n  START: \'start\',\n  CENTER: \'center\',\n  END: \'end\'\n};\n;// CONCATENATED MODULE: ./src/top-app-bar/TopAppBarRow.jsx\nvar TopAppBarRow_excluded = ["element", "className"];\n\nfunction TopAppBarRow_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction TopAppBarRow_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { TopAppBarRow_ownKeys(Object(source), true).forEach(function (key) { TopAppBarRow_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { TopAppBarRow_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction TopAppBarRow_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction TopAppBarRow_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = TopAppBarRow_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction TopAppBarRow_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\nvar TopAppBarRow = /*#__PURE__*/(0,react.forwardRef)(function (_ref, ref) {\n  var _ref$element = _ref.element,\n      Element = _ref$element === void 0 ? \'div\' : _ref$element,\n      className = _ref.className,\n      props = TopAppBarRow_objectWithoutProperties(_ref, TopAppBarRow_excluded);\n\n  var classNames = classnames_default()(top_app_bar_constants_cssClasses.ROW, className);\n  return /*#__PURE__*/(0,jsx_runtime.jsx)(Element, TopAppBarRow_objectSpread({\n    ref: ref,\n    className: classNames\n  }, props));\n});\nTopAppBarRow.displayName = \'MDCTopAppBarRow\';\n/* harmony default export */ const top_app_bar_TopAppBarRow = (TopAppBarRow);\n;// CONCATENATED MODULE: ./src/top-app-bar/TopAppBarSection.jsx\nvar TopAppBarSection_excluded = ["align", "element", "className"];\n\nfunction TopAppBarSection_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction TopAppBarSection_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { TopAppBarSection_ownKeys(Object(source), true).forEach(function (key) { TopAppBarSection_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { TopAppBarSection_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction TopAppBarSection_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction TopAppBarSection_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = TopAppBarSection_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction TopAppBarSection_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\n\nvar TopAppBarSection = /*#__PURE__*/(0,react.forwardRef)(function (_ref, ref) {\n  var _classnames;\n\n  var align = _ref.align,\n      _ref$element = _ref.element,\n      Element = _ref$element === void 0 ? \'section\' : _ref$element,\n      className = _ref.className,\n      props = TopAppBarSection_objectWithoutProperties(_ref, TopAppBarSection_excluded);\n\n  var classNames = classnames_default()(top_app_bar_constants_cssClasses.SECTION, (_classnames = {}, TopAppBarSection_defineProperty(_classnames, top_app_bar_constants_cssClasses.SECTION_ALIGN_START, align === constants_Align.START), TopAppBarSection_defineProperty(_classnames, top_app_bar_constants_cssClasses.SECTION_ALIGN_CENTER, align === constants_Align.CENTER), TopAppBarSection_defineProperty(_classnames, top_app_bar_constants_cssClasses.SECTION_ALIGN_END, align === constants_Align.END), _classnames), className);\n  return /*#__PURE__*/(0,jsx_runtime.jsx)(Element, TopAppBarSection_objectSpread({\n    ref: ref,\n    className: classNames\n  }, props));\n});\nTopAppBarSection.displayName = \'MDCTopAppBarSection\';\nTopAppBarSection.propTypes = {\n  align: prop_types_default().oneOf(Object.values(constants_Align))\n};\n/* harmony default export */ const top_app_bar_TopAppBarSection = (TopAppBarSection);\n;// CONCATENATED MODULE: ./src/top-app-bar/TopAppBar.jsx\nvar TopAppBar_excluded = ["title", "navigationIcon", "actionItems", "fixed", "sticky", "dense", "prominent", "short", "collapsed", "onNavigationIconClick", "element", "component", "className", "children"];\n\nfunction TopAppBar_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction TopAppBar_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { TopAppBar_ownKeys(Object(source), true).forEach(function (key) { TopAppBar_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { TopAppBar_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction TopAppBar_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction TopAppBar_slicedToArray(arr, i) { return TopAppBar_arrayWithHoles(arr) || TopAppBar_iterableToArrayLimit(arr, i) || TopAppBar_unsupportedIterableToArray(arr, i) || TopAppBar_nonIterableRest(); }\n\nfunction TopAppBar_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction TopAppBar_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return TopAppBar_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return TopAppBar_arrayLikeToArray(o, minLen); }\n\nfunction TopAppBar_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction TopAppBar_iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction TopAppBar_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction TopAppBar_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = TopAppBar_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction TopAppBar_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\n\n\n\n\n\n\nvar TopAppBar = /*#__PURE__*/(0,react.forwardRef)(function (_ref, ref) {\n  var _classnames;\n\n  var title = _ref.title,\n      navigationIcon = _ref.navigationIcon,\n      actionItems = _ref.actionItems,\n      _ref$fixed = _ref.fixed,\n      fixed = _ref$fixed === void 0 ? false : _ref$fixed,\n      _ref$sticky = _ref.sticky,\n      sticky = _ref$sticky === void 0 ? false : _ref$sticky,\n      _ref$dense = _ref.dense,\n      dense = _ref$dense === void 0 ? false : _ref$dense,\n      _ref$prominent = _ref.prominent,\n      prominent = _ref$prominent === void 0 ? false : _ref$prominent,\n      _ref$short = _ref["short"],\n      _short = _ref$short === void 0 ? false : _ref$short,\n      _ref$collapsed = _ref.collapsed,\n      collapsed = _ref$collapsed === void 0 ? false : _ref$collapsed,\n      _ref$onNavigationIcon = _ref.onNavigationIconClick,\n      onNavigationIconClick = _ref$onNavigationIcon === void 0 ? Function.prototype : _ref$onNavigationIcon,\n      _ref$element = _ref.element,\n      element = _ref$element === void 0 ? \'header\' : _ref$element,\n      _ref$component = _ref.component,\n      Element = _ref$component === void 0 ? element : _ref$component,\n      className = _ref.className,\n      children = _ref.children,\n      props = TopAppBar_objectWithoutProperties(_ref, TopAppBar_excluded);\n\n  var rootRef = (0,react.useRef)();\n\n  var _useState = (0,react.useState)(false),\n      _useState2 = TopAppBar_slicedToArray(_useState, 2),\n      scrolled = _useState2[0],\n      setScrolled = _useState2[1];\n\n  var _useState3 = (0,react.useState)(false),\n      _useState4 = TopAppBar_slicedToArray(_useState3, 2),\n      hidden = _useState4[0],\n      setHidden = _useState4[1];\n\n  (0,react.useImperativeHandle)(ref, function () {\n    return rootRef.current;\n  });\n  (0,react.useEffect)(function () {\n    var lastScrollPosition = 0;\n\n    function handleScroll() {\n      var scrollValue = window.pageYOffset;\n\n      if (fixed) {\n        setScrolled(scrollValue > 0);\n      } else if (sticky) {\n        var currentScrollPosition = Math.max(scrollValue, 0);\n        var diff = currentScrollPosition - lastScrollPosition;\n        var shouldHide = diff > 0;\n        lastScrollPosition = currentScrollPosition;\n        setHidden(shouldHide);\n      }\n    }\n\n    window.addEventListener(\'scroll\', handleScroll);\n    return function () {\n      window.removeEventListener(\'scroll\', handleScroll);\n    };\n  }, [fixed, sticky]);\n  var classNames = classnames_default()(top_app_bar_constants_cssClasses.ROOT, (_classnames = {}, TopAppBar_defineProperty(_classnames, top_app_bar_constants_cssClasses.FIXED, fixed), TopAppBar_defineProperty(_classnames, top_app_bar_constants_cssClasses.STICKY, sticky), TopAppBar_defineProperty(_classnames, top_app_bar_constants_cssClasses.DENSE, dense), TopAppBar_defineProperty(_classnames, top_app_bar_constants_cssClasses.PROMINENT, prominent), TopAppBar_defineProperty(_classnames, top_app_bar_constants_cssClasses.SHORT, _short), TopAppBar_defineProperty(_classnames, top_app_bar_constants_cssClasses.SHORT_COLLAPSED, _short && collapsed), TopAppBar_defineProperty(_classnames, top_app_bar_constants_cssClasses.FIXED_SCROLLED, fixed && scrolled), TopAppBar_defineProperty(_classnames, top_app_bar_constants_cssClasses.STICKY_HIDDEN, sticky && hidden), TopAppBar_defineProperty(_classnames, top_app_bar_constants_cssClasses.STICKY_SHOWN, sticky && !hidden), _classnames), className);\n  return /*#__PURE__*/(0,jsx_runtime.jsx)(Element, TopAppBar_objectSpread(TopAppBar_objectSpread({\n    ref: rootRef,\n    className: classNames\n  }, props), {}, {\n    children: children || /*#__PURE__*/(0,jsx_runtime.jsxs)(top_app_bar_TopAppBarRow, {\n      children: [(title || navigationIcon) && /*#__PURE__*/(0,jsx_runtime.jsxs)(top_app_bar_TopAppBarSection, {\n        align: constants_Align.START,\n        children: [navigationIcon && /*#__PURE__*/(0,jsx_runtime.jsx)(Clone, {\n          component: navigationIcon,\n          fallback: icon_button_IconButton,\n          className: top_app_bar_constants_cssClasses.NAVIGATION_ICON,\n          onClick: onNavigationIconClick\n        }), title && /*#__PURE__*/(0,jsx_runtime.jsx)(Clone, {\n          component: title,\n          fallback: "span",\n          className: top_app_bar_constants_cssClasses.TITLE\n        })]\n      }), actionItems && /*#__PURE__*/(0,jsx_runtime.jsx)(top_app_bar_TopAppBarSection, {\n        align: constants_Align.END,\n        children: react.Children.map(actionItems, function (item) {\n          return /*#__PURE__*/(0,jsx_runtime.jsx)(Clone, {\n            component: item,\n            className: top_app_bar_constants_cssClasses.ACTION_ITEM\n          });\n        })\n      })]\n    })\n  }));\n});\nTopAppBar.displayName = \'MDCTopAppBar\';\nTopAppBar.propTypes = {\n  title: (prop_types_default()).node,\n  navigationIcon: (prop_types_default()).node,\n  actionItems: prop_types_default().oneOfType([(prop_types_default()).element, prop_types_default().arrayOf((prop_types_default()).element)]),\n  fixed: (prop_types_default()).bool,\n  sticky: (prop_types_default()).bool,\n  dense: (prop_types_default()).bool,\n  prominent: (prop_types_default()).bool,\n  "short": (prop_types_default()).bool,\n  collapsed: (prop_types_default()).bool\n};\n/* harmony default export */ const top_app_bar_TopAppBar = (TopAppBar);\n;// CONCATENATED MODULE: ./src/top-app-bar/TopAppBarActionItem.jsx\nvar TopAppBarActionItem_excluded = ["element", "component", "className"];\n\nfunction TopAppBarActionItem_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction TopAppBarActionItem_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { TopAppBarActionItem_ownKeys(Object(source), true).forEach(function (key) { TopAppBarActionItem_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { TopAppBarActionItem_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction TopAppBarActionItem_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction TopAppBarActionItem_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = TopAppBarActionItem_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction TopAppBarActionItem_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\nvar TopAppBarActionItem = /*#__PURE__*/(0,react.forwardRef)(function (_ref, ref) {\n  var _ref$element = _ref.element,\n      element = _ref$element === void 0 ? \'span\' : _ref$element,\n      _ref$component = _ref.component,\n      Element = _ref$component === void 0 ? element : _ref$component,\n      className = _ref.className,\n      props = TopAppBarActionItem_objectWithoutProperties(_ref, TopAppBarActionItem_excluded);\n\n  var classNames = classnames_default()(top_app_bar_constants_cssClasses.ACTION_ITEM, className);\n  return /*#__PURE__*/(0,jsx_runtime.jsx)(Element, TopAppBarActionItem_objectSpread({\n    ref: ref,\n    className: classNames\n  }, props));\n});\nTopAppBarActionItem.displayName = \'MDCTopAppBarActionItem\';\n/* harmony default export */ const top_app_bar_TopAppBarActionItem = (TopAppBarActionItem);\n;// CONCATENATED MODULE: ./src/top-app-bar/TopAppBarFixedAdjust.jsx\nvar TopAppBarFixedAdjust_excluded = ["dense", "prominent", "short", "element", "component", "className"];\n\nfunction TopAppBarFixedAdjust_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction TopAppBarFixedAdjust_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { TopAppBarFixedAdjust_ownKeys(Object(source), true).forEach(function (key) { TopAppBarFixedAdjust_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { TopAppBarFixedAdjust_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction TopAppBarFixedAdjust_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction TopAppBarFixedAdjust_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = TopAppBarFixedAdjust_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction TopAppBarFixedAdjust_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\nvar TopAppBarFixedAdjust = /*#__PURE__*/(0,react.forwardRef)(function (_ref, ref) {\n  var _classnames;\n\n  var _ref$dense = _ref.dense,\n      dense = _ref$dense === void 0 ? false : _ref$dense,\n      _ref$prominent = _ref.prominent,\n      prominent = _ref$prominent === void 0 ? false : _ref$prominent,\n      _ref$short = _ref["short"],\n      _short = _ref$short === void 0 ? false : _ref$short,\n      _ref$element = _ref.element,\n      element = _ref$element === void 0 ? \'div\' : _ref$element,\n      _ref$component = _ref.component,\n      Element = _ref$component === void 0 ? element : _ref$component,\n      className = _ref.className,\n      props = TopAppBarFixedAdjust_objectWithoutProperties(_ref, TopAppBarFixedAdjust_excluded);\n\n  var classNames = classnames_default()(top_app_bar_constants_cssClasses.FIXED_ADJUST, (_classnames = {}, TopAppBarFixedAdjust_defineProperty(_classnames, top_app_bar_constants_cssClasses.DENSE_FIXED_ADJUST, dense), TopAppBarFixedAdjust_defineProperty(_classnames, top_app_bar_constants_cssClasses.PROMINENT_FIXED_ADJUST, prominent), TopAppBarFixedAdjust_defineProperty(_classnames, top_app_bar_constants_cssClasses.DENSE_PROMINENT_FIXED_ADJUST, dense && prominent), TopAppBarFixedAdjust_defineProperty(_classnames, top_app_bar_constants_cssClasses.SHORT_FIXED_ADJUST, _short), _classnames), className);\n  return /*#__PURE__*/(0,jsx_runtime.jsx)(Element, TopAppBarFixedAdjust_objectSpread({\n    ref: ref,\n    className: classNames\n  }, props));\n});\nTopAppBarFixedAdjust.displayName = \'MDCTopAppBarFixedAdjust\';\n/* harmony default export */ const top_app_bar_TopAppBarFixedAdjust = (TopAppBarFixedAdjust);\n;// CONCATENATED MODULE: ./src/top-app-bar/TopAppBarNavigationIcon.jsx\nvar TopAppBarNavigationIcon_excluded = ["className"];\n\nfunction TopAppBarNavigationIcon_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction TopAppBarNavigationIcon_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { TopAppBarNavigationIcon_ownKeys(Object(source), true).forEach(function (key) { TopAppBarNavigationIcon_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { TopAppBarNavigationIcon_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction TopAppBarNavigationIcon_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction TopAppBarNavigationIcon_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = TopAppBarNavigationIcon_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction TopAppBarNavigationIcon_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\n\nvar TopAppBarNavigationIcon = /*#__PURE__*/(0,react.forwardRef)(function (_ref, ref) {\n  var className = _ref.className,\n      props = TopAppBarNavigationIcon_objectWithoutProperties(_ref, TopAppBarNavigationIcon_excluded);\n\n  var classNames = classnames_default()(top_app_bar_constants_cssClasses.NAVIGATION_ICON, className);\n  return /*#__PURE__*/(0,jsx_runtime.jsx)(icon_button_IconButton, TopAppBarNavigationIcon_objectSpread({\n    ref: ref,\n    className: classNames\n  }, props));\n});\nTopAppBarNavigationIcon.displayName = \'MDCTopAppBarNavigationIcon\';\n/* harmony default export */ const top_app_bar_TopAppBarNavigationIcon = (TopAppBarNavigationIcon);\n;// CONCATENATED MODULE: ./src/top-app-bar/TopAppBarTitle.jsx\nvar TopAppBarTitle_excluded = ["element", "className"];\n\nfunction TopAppBarTitle_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction TopAppBarTitle_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { TopAppBarTitle_ownKeys(Object(source), true).forEach(function (key) { TopAppBarTitle_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { TopAppBarTitle_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction TopAppBarTitle_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction TopAppBarTitle_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = TopAppBarTitle_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction TopAppBarTitle_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\nvar TopAppBarTitle = /*#__PURE__*/(0,react.forwardRef)(function (_ref, ref) {\n  var _ref$element = _ref.element,\n      Element = _ref$element === void 0 ? \'span\' : _ref$element,\n      className = _ref.className,\n      props = TopAppBarTitle_objectWithoutProperties(_ref, TopAppBarTitle_excluded);\n\n  var classNames = classnames_default()(top_app_bar_constants_cssClasses.TITLE, className);\n  return /*#__PURE__*/(0,jsx_runtime.jsx)(Element, TopAppBarTitle_objectSpread({\n    ref: ref,\n    className: classNames\n  }, props));\n});\nTopAppBarTitle.displayName = \'MDCTopAppBarTitle\';\n/* harmony default export */ const top_app_bar_TopAppBarTitle = (TopAppBarTitle);\n;// CONCATENATED MODULE: ./src/top-app-bar/index.js\n\n\n\n\n\n\n\ntop_app_bar_TopAppBar.ActionItem = top_app_bar_TopAppBarActionItem;\ntop_app_bar_TopAppBar.FixedAdjust = top_app_bar_TopAppBarFixedAdjust;\ntop_app_bar_TopAppBar.NavigationIcon = top_app_bar_TopAppBarNavigationIcon;\ntop_app_bar_TopAppBar.Row = top_app_bar_TopAppBarRow;\ntop_app_bar_TopAppBar.Section = top_app_bar_TopAppBarSection;\ntop_app_bar_TopAppBar.Title = top_app_bar_TopAppBarTitle;\n\n;// CONCATENATED MODULE: ./src/typography/constants.js\nvar elementsByType = {\n  headline1: \'h1\',\n  headline2: \'h2\',\n  headline3: \'h3\',\n  headline4: \'h4\',\n  headline5: \'h5\',\n  headline6: \'h6\',\n  subtitle1: \'h5\',\n  subtitle2: \'h6\',\n  body1: \'p\',\n  body2: \'p\',\n  button: \'span\',\n  caption: \'span\',\n  overline: \'span\'\n};\nvar typography_constants_cssClasses = {\n  ROOT: \'mdc-typography\',\n  DISPLAY: \'mdc-typography--display\',\n  ALIGN: \'mdc-typography--align\',\n  NO_MARGIN: \'mdc-typography--no-margin\',\n  NO_WRAP: \'mdc-typography--no-wrap\'\n};\n;// CONCATENATED MODULE: ./src/typography/Typography.jsx\nvar Typography_excluded = ["type", "display", "align", "noMargin", "noWrap", "element", "component", "className"];\n\nfunction Typography_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction Typography_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { Typography_ownKeys(Object(source), true).forEach(function (key) { Typography_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { Typography_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction Typography_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction Typography_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = Typography_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction Typography_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\n\nvar Typography = /*#__PURE__*/(0,react.forwardRef)(function (_ref, ref) {\n  var _classnames;\n\n  var _ref$type = _ref.type,\n      type = _ref$type === void 0 ? \'body1\' : _ref$type,\n      display = _ref.display,\n      align = _ref.align,\n      _ref$noMargin = _ref.noMargin,\n      noMargin = _ref$noMargin === void 0 ? false : _ref$noMargin,\n      _ref$noWrap = _ref.noWrap,\n      noWrap = _ref$noWrap === void 0 ? false : _ref$noWrap,\n      _ref$element = _ref.element,\n      element = _ref$element === void 0 ? elementsByType[type] : _ref$element,\n      _ref$component = _ref.component,\n      Element = _ref$component === void 0 ? element : _ref$component,\n      className = _ref.className,\n      props = Typography_objectWithoutProperties(_ref, Typography_excluded);\n\n  var classNames = classnames_default()(typography_constants_cssClasses.ROOT, "".concat(typography_constants_cssClasses.ROOT, "--").concat(type), (_classnames = {}, Typography_defineProperty(_classnames, "".concat(typography_constants_cssClasses.DISPLAY, "-").concat(display), display), Typography_defineProperty(_classnames, "".concat(typography_constants_cssClasses.ALIGN, "-").concat(align), align), Typography_defineProperty(_classnames, typography_constants_cssClasses.NO_MARGIN, noMargin), Typography_defineProperty(_classnames, typography_constants_cssClasses.NO_WRAP, noWrap), _classnames), className);\n  return /*#__PURE__*/(0,jsx_runtime.jsx)(Element, Typography_objectSpread({\n    ref: ref,\n    className: classNames\n  }, props));\n});\nTypography.displayName = \'MDCTypography\';\nTypography.propTypes = {\n  type: prop_types_default().oneOf(Object.keys(elementsByType)),\n  display: prop_types_default().oneOf([\'block\', \'inline\', \'inline-block\']),\n  align: prop_types_default().oneOf([\'left\', \'center\', \'right\', \'justify\']),\n  noMargin: (prop_types_default()).bool,\n  noWrap: (prop_types_default()).bool\n};\n/* harmony default export */ const typography_Typography = (Typography);\n;// CONCATENATED MODULE: ./src/typography/index.js\n\n;// CONCATENATED MODULE: ./src/index.js\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n;// CONCATENATED MODULE: ./docs/src/components/Page/index.jsx\nvar Page_excluded = ["id", "title", "description", "links", "children"];\n\nfunction Page_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction Page_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { Page_ownKeys(Object(source), true).forEach(function (key) { Page_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { Page_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction Page_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction Page_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = Page_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction Page_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\nfunction Page(_ref) {\n  var id = _ref.id,\n      title = _ref.title,\n      description = _ref.description,\n      links = _ref.links,\n      children = _ref.children,\n      props = Page_objectWithoutProperties(_ref, Page_excluded);\n\n  return /*#__PURE__*/(0,jsx_runtime.jsxs)("article", Page_objectSpread(Page_objectSpread({\n    id: "".concat(id, "-page"),\n    className: "page"\n  }, props), {}, {\n    children: [/*#__PURE__*/(0,jsx_runtime.jsxs)("header", {\n      className: "page-header",\n      children: [/*#__PURE__*/(0,jsx_runtime.jsx)(typography_Typography, {\n        className: "page-title",\n        type: "headline4",\n        noMargin: true,\n        children: title\n      }), description && /*#__PURE__*/(0,jsx_runtime.jsx)(typography_Typography, {\n        className: "page-description",\n        type: "body1",\n        noMargin: true,\n        children: description\n      }), links && /*#__PURE__*/(0,jsx_runtime.jsxs)(list_List, {\n        children: [links.guide && /*#__PURE__*/(0,jsx_runtime.jsx)(list_List.Item, {\n          children: /*#__PURE__*/(0,jsx_runtime.jsx)("a", {\n            href: links.guide,\n            target: "_blank",\n            rel: "noreferrer",\n            children: "Guide"\n          })\n        }), links.docs && /*#__PURE__*/(0,jsx_runtime.jsx)(list_List.Item, {\n          children: /*#__PURE__*/(0,jsx_runtime.jsx)("a", {\n            href: links.docs,\n            target: "_blank",\n            rel: "noreferrer",\n            children: "Docs"\n          })\n        })]\n      })]\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)("div", {\n      className: "page-content",\n      children: children\n    })]\n  }));\n}\n;// CONCATENATED MODULE: ./docs/src/components/Section/index.jsx\nvar Section_excluded = ["title", "children", "className"];\n\nfunction Section_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction Section_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { Section_ownKeys(Object(source), true).forEach(function (key) { Section_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { Section_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction Section_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction Section_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = Section_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction Section_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\n\nfunction Section(_ref) {\n  var title = _ref.title,\n      children = _ref.children,\n      className = _ref.className,\n      props = Section_objectWithoutProperties(_ref, Section_excluded);\n\n  var classNames = classnames_default()(\'section\', className);\n  return /*#__PURE__*/(0,jsx_runtime.jsxs)("section", Section_objectSpread(Section_objectSpread({\n    className: classNames\n  }, props), {}, {\n    children: [title && /*#__PURE__*/(0,jsx_runtime.jsx)(typography_Typography, {\n      className: "section-title",\n      type: "headline6",\n      children: title\n    }), children]\n  }));\n}\n;// CONCATENATED MODULE: ./docs/src/components/Code/index.jsx\nfunction Code_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { Code_typeof = function _typeof(obj) { return typeof obj; }; } else { Code_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return Code_typeof(obj); }\n\nfunction Code_slicedToArray(arr, i) { return Code_arrayWithHoles(arr) || Code_iterableToArrayLimit(arr, i) || Code_unsupportedIterableToArray(arr, i) || Code_nonIterableRest(); }\n\nfunction Code_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction Code_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return Code_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return Code_arrayLikeToArray(o, minLen); }\n\nfunction Code_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction Code_iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction Code_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\n\n\n\n\n\nfunction Code(_ref) {\n  var setup = _ref.setup,\n      children = _ref.children;\n\n  var _useState = (0,react.useState)(false),\n      _useState2 = Code_slicedToArray(_useState, 2),\n      isCodeOpen = _useState2[0],\n      setCodeOpen = _useState2[1];\n\n  return /*#__PURE__*/(0,jsx_runtime.jsx)("section", {\n    className: "code",\n    children: /*#__PURE__*/(0,jsx_runtime.jsxs)(card_Card, {\n      outlined: true,\n      children: [/*#__PURE__*/(0,jsx_runtime.jsxs)(card_Card.Section, {\n        primary: true,\n        children: [setup, children]\n      }), isCodeOpen && /*#__PURE__*/(0,jsx_runtime.jsx)(card_Card.Section, {\n        secondary: true,\n        children: /*#__PURE__*/(0,jsx_runtime.jsx)("pre", {\n          children: /*#__PURE__*/(0,jsx_runtime.jsx)("code", {\n            children: react.Children.toArray(children).map(function (component) {\n              return printComponent(component);\n            }).join(\'\\n\')\n          })\n        })\n      }), /*#__PURE__*/(0,jsx_runtime.jsx)(card_Card.Actions, {\n        children: /*#__PURE__*/(0,jsx_runtime.jsx)(button_Button, {\n          label: isCodeOpen ? \'Hide code\' : \'Show code\',\n          onClick: function onClick() {\n            return setCodeOpen(function (v) {\n              return !v;\n            });\n          }\n        })\n      })]\n    })\n  });\n}\n\nfunction printComponent(component) {\n  var depth = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  var displayName = component.type.displayName.replace(\'MDC\', \'\');\n  var children = component.props.children;\n  var props = Object.entries(component.props).filter(function (_ref2) {\n    var _ref3 = Code_slicedToArray(_ref2, 2),\n        key = _ref3[0],\n        value = _ref3[1];\n\n    return key !== \'children\' && value !== undefined;\n  });\n  var indent = \'  \'.repeat(depth);\n  var result = indent + "<".concat(displayName);\n\n  if (!isEmpty(props)) {\n    result += " ".concat(printProps(props, depth + 1));\n  }\n\n  if (!children) {\n    result += result.endsWith(\'\\n\') ? indent + \'/>\' : \' />\';\n  } else if ( /*#__PURE__*/(0,react.isValidElement)(children)) {\n    result += ">\\n".concat(printComponent(children, depth + 1), "\\n").concat(indent, "</").concat(displayName, ">");\n  } else if (Array.isArray(children)) {\n    result += result.endsWith(\'\\n\') ? indent + \'>\\n\' : \'>\\n\';\n    result += children.map(function (child) {\n      return printComponent(child, depth + 1);\n    }).join(\'\\n\');\n    result += "\\n".concat(indent, "</").concat(displayName, ">");\n  } else {\n    result += ">".concat(children, "</").concat(displayName, ">");\n  }\n\n  return result;\n}\n\nfunction printProps(props, depth) {\n  var result = \'\';\n  var indent = \'  \'.repeat(depth);\n\n  if (props.length < 3) {\n    result += props.map(printProp).join(\' \');\n  } else {\n    result += "\\n".concat(indent).concat(props.map(printProp).join(\'\\n\' + indent), "\\n");\n  }\n\n  return result;\n}\n\nfunction printProp(_ref4) {\n  var _ref5 = Code_slicedToArray(_ref4, 2),\n      key = _ref5[0],\n      value = _ref5[1];\n\n  if (value === true) {\n    return key;\n  } else if (typeof value === \'string\') {\n    return "".concat(key, "=\\"").concat(value, "\\"");\n  } else {\n    return "".concat(key, "={").concat(printValue(value), "}");\n  }\n}\n\nfunction printValue(value) {\n  if (typeof value === \'string\') {\n    return "\'".concat(value, "\'");\n  } else if (Array.isArray(value)) {\n    return "[".concat(value.map(function (v) {\n      return printValue(v);\n    }).join(\', \'), "]");\n  } else if ( /*#__PURE__*/(0,react.isValidElement)(value)) {\n    return printComponent(value);\n  } else if (typeof value === \'function\') {\n    return "".concat(value.name || \'[Function]\');\n  } else {\n    return value;\n  }\n}\n\nfunction isEmpty(value) {\n  if (!value) {\n    return true;\n  } else if (Array.isArray(value)) {\n    return value.length === 0;\n  } else if (Code_typeof(value) === \'object\') {\n    return Object.keys(value).length === 0;\n  }\n}\n;// CONCATENATED MODULE: ./docs/src/pages/Avatar/index.jsx\nfunction Avatar_slicedToArray(arr, i) { return Avatar_arrayWithHoles(arr) || Avatar_iterableToArrayLimit(arr, i) || Avatar_unsupportedIterableToArray(arr, i) || Avatar_nonIterableRest(); }\n\nfunction Avatar_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction Avatar_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return Avatar_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return Avatar_arrayLikeToArray(o, minLen); }\n\nfunction Avatar_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction Avatar_iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction Avatar_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\n\n\n\n\n\n\n\nvar id = \'avatar\';\nvar title = \'Avatar\';\nvar description = \'Avatars are found throughout material design with uses in everything from tables to dialog menus.\';\nfunction AvatarPage() {\n  var _useState = (0,react.useState)(\'medium\'),\n      _useState2 = Avatar_slicedToArray(_useState, 2),\n      size = _useState2[0],\n      setSize = _useState2[1];\n\n  var _useState3 = (0,react.useState)(\'image\'),\n      _useState4 = Avatar_slicedToArray(_useState3, 2),\n      content = _useState4[0],\n      setContent = _useState4[1];\n\n  return /*#__PURE__*/(0,jsx_runtime.jsx)(Page, {\n    id: id,\n    title: title,\n    description: description,\n    children: /*#__PURE__*/(0,jsx_runtime.jsxs)(Section, {\n      title: "Demo",\n      children: [/*#__PURE__*/(0,jsx_runtime.jsxs)(layout_Layout, {\n        row: true,\n        children: [/*#__PURE__*/(0,jsx_runtime.jsxs)("fieldset", {\n          children: [/*#__PURE__*/(0,jsx_runtime.jsx)("legend", {\n            children: "Content"\n          }), /*#__PURE__*/(0,jsx_runtime.jsx)(segmented_button_SegmentedButton, {\n            segments: [{\n              value: \'image\',\n              label: \'Image\'\n            }, {\n              value: \'icon\',\n              label: \'Icon\'\n            }, {\n              value: \'text\',\n              label: \'Text\'\n            }],\n            value: content,\n            onChange: setContent\n          })]\n        }), /*#__PURE__*/(0,jsx_runtime.jsxs)("fieldset", {\n          children: [/*#__PURE__*/(0,jsx_runtime.jsx)("legend", {\n            children: "Size"\n          }), /*#__PURE__*/(0,jsx_runtime.jsx)(segmented_button_SegmentedButton, {\n            segments: [{\n              value: \'small\',\n              label: \'Small\'\n            }, {\n              value: \'medium\',\n              label: \'Medium\'\n            }, {\n              value: \'large\',\n              label: \'Large\'\n            }],\n            value: size,\n            onChange: setSize\n          })]\n        })]\n      }), /*#__PURE__*/(0,jsx_runtime.jsx)(Code, {\n        children: /*#__PURE__*/(0,jsx_runtime.jsx)(avatar_Avatar, {\n          src: content === \'image\' ? \'https://placeimg.com/128/128/people\' : undefined,\n          icon: content === \'icon\' ? \'star\' : undefined,\n          text: content === \'text\' ? \'MD\' : undefined,\n          size: size\n        })\n      })]\n    })\n  });\n}\n;// CONCATENATED MODULE: ./docs/src/pages/Badge/index.jsx\n\n\n\n\n\n\nvar Badge_id = \'badge\';\nvar Badge_title = \'Badge\';\nvar Badge_description = \'Badge generates a small badge to the top-right of its child(ren).\';\nfunction BadgePage() {\n  return /*#__PURE__*/(0,jsx_runtime.jsxs)(Page, {\n    id: Badge_id,\n    title: Badge_title,\n    description: Badge_description,\n    children: [/*#__PURE__*/(0,jsx_runtime.jsx)(Section, {\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(Code, {\n        title: "Badge with text",\n        children: /*#__PURE__*/(0,jsx_runtime.jsx)(badge_Badge, {\n          value: "3",\n          children: "Text"\n        })\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Section, {\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(Code, {\n        title: "Badge with an icon",\n        children: /*#__PURE__*/(0,jsx_runtime.jsx)(badge_Badge, {\n          value: "3",\n          children: /*#__PURE__*/(0,jsx_runtime.jsx)(icon_Icon, {\n            children: "star"\n          })\n        })\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Section, {\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(Code, {\n        title: "Badge with an icon button",\n        children: /*#__PURE__*/(0,jsx_runtime.jsx)(badge_Badge, {\n          value: "3",\n          inset: true,\n          children: /*#__PURE__*/(0,jsx_runtime.jsx)(icon_button_IconButton, {\n            icon: "star"\n          })\n        })\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Section, {\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(Code, {\n        title: "Badge with a button",\n        children: /*#__PURE__*/(0,jsx_runtime.jsx)(badge_Badge, {\n          value: "3",\n          children: /*#__PURE__*/(0,jsx_runtime.jsx)(button_Button, {\n            children: "Button"\n          })\n        })\n      })\n    })]\n  });\n}\n;// CONCATENATED MODULE: ./docs/src/pages/Banner/index.jsx\nfunction Banner_slicedToArray(arr, i) { return Banner_arrayWithHoles(arr) || Banner_iterableToArrayLimit(arr, i) || Banner_unsupportedIterableToArray(arr, i) || Banner_nonIterableRest(); }\n\nfunction Banner_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction Banner_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return Banner_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return Banner_arrayLikeToArray(o, minLen); }\n\nfunction Banner_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction Banner_iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction Banner_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\n\n\n\n\n\n\n\n\nvar Banner_id = \'banner\';\nvar Banner_title = \'Banner\';\nvar Banner_description = \'A banner displays a prominent message and related optional actions.\';\nvar links = {\n  docs: \'https://github.com/material-components/material-components-web/tree/master/packages/mdc-banner\',\n  guide: \'https://material.io/components/banners\'\n};\nfunction Banner_BadgePage() {\n  var _useState = (0,react.useState)(false),\n      _useState2 = Banner_slicedToArray(_useState, 2),\n      isOpen1 = _useState2[0],\n      setOpen1 = _useState2[1];\n\n  var _useState3 = (0,react.useState)(false),\n      _useState4 = Banner_slicedToArray(_useState3, 2),\n      isOpen2 = _useState4[0],\n      setOpen2 = _useState4[1];\n\n  var _useState5 = (0,react.useState)(false),\n      _useState6 = Banner_slicedToArray(_useState5, 2),\n      isOpen3 = _useState6[0],\n      setOpen3 = _useState6[1];\n\n  var _useState7 = (0,react.useState)(false),\n      _useState8 = Banner_slicedToArray(_useState7, 2),\n      isOpen4 = _useState8[0],\n      setOpen4 = _useState8[1];\n\n  return /*#__PURE__*/(0,jsx_runtime.jsxs)(Page, {\n    id: Banner_id,\n    title: Banner_title,\n    description: Banner_description,\n    links: links,\n    children: [/*#__PURE__*/(0,jsx_runtime.jsx)(Section, {\n      title: "Banner with text",\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(Code, {\n        setup: /*#__PURE__*/(0,jsx_runtime.jsx)(top_app_bar_TopAppBar, {\n          title: "Title",\n          actionItems: /*#__PURE__*/(0,jsx_runtime.jsx)(button_Button, {\n            label: "Toggle",\n            onClick: function onClick() {\n              return setOpen1(function (v) {\n                return !v;\n              });\n            }\n          })\n        }),\n        children: /*#__PURE__*/(0,jsx_runtime.jsx)(banner_Banner, {\n          text: "Lorem ipsum",\n          open: isOpen1\n        })\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Section, {\n      title: "Banner with icon and text",\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(Code, {\n        setup: /*#__PURE__*/(0,jsx_runtime.jsx)(top_app_bar_TopAppBar, {\n          title: "Title",\n          actionItems: /*#__PURE__*/(0,jsx_runtime.jsx)(button_Button, {\n            label: "Toggle",\n            onClick: function onClick() {\n              return setOpen2(function (v) {\n                return !v;\n              });\n            }\n          })\n        }),\n        children: /*#__PURE__*/(0,jsx_runtime.jsx)(banner_Banner, {\n          icon: "warning",\n          text: "Lorem ipsum",\n          open: isOpen2\n        })\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Section, {\n      title: "Banner with icon, text and actions",\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(Code, {\n        setup: /*#__PURE__*/(0,jsx_runtime.jsx)(top_app_bar_TopAppBar, {\n          title: "Title",\n          actionItems: /*#__PURE__*/(0,jsx_runtime.jsx)(button_Button, {\n            label: "Toggle",\n            onClick: function onClick() {\n              return setOpen3(function (v) {\n                return !v;\n              });\n            }\n          })\n        }),\n        children: /*#__PURE__*/(0,jsx_runtime.jsx)(banner_Banner, {\n          icon: "warning",\n          text: "Lorem ipsum",\n          action: /*#__PURE__*/(0,jsx_runtime.jsx)(button_Button, {\n            children: "OK"\n          }),\n          open: isOpen3\n        })\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Section, {\n      title: "Banner with icon, text and actions",\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(Code, {\n        setup: /*#__PURE__*/(0,jsx_runtime.jsx)(top_app_bar_TopAppBar, {\n          title: "Title",\n          actionItems: /*#__PURE__*/(0,jsx_runtime.jsx)(button_Button, {\n            label: "Toggle",\n            onClick: function onClick() {\n              return setOpen4(function (v) {\n                return !v;\n              });\n            }\n          })\n        }),\n        children: /*#__PURE__*/(0,jsx_runtime.jsx)(banner_Banner, {\n          icon: "warning",\n          text: "Lorem ipsum",\n          primaryAction: /*#__PURE__*/(0,jsx_runtime.jsx)(button_Button, {\n            children: "OK"\n          }),\n          secondaryAction: /*#__PURE__*/(0,jsx_runtime.jsx)(button_Button, {\n            children: "Close"\n          }),\n          open: isOpen4\n        })\n      })\n    })]\n  });\n}\n;// CONCATENATED MODULE: ./docs/src/pages/Button/index.jsx\nfunction Button_slicedToArray(arr, i) { return Button_arrayWithHoles(arr) || Button_iterableToArrayLimit(arr, i) || Button_unsupportedIterableToArray(arr, i) || Button_nonIterableRest(); }\n\nfunction Button_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction Button_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return Button_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return Button_arrayLikeToArray(o, minLen); }\n\nfunction Button_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction Button_iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction Button_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\n\n\n\n\n\n\n\nvar Button_id = \'button\';\nvar Button_title = \'Button\';\nvar Button_description = \'Buttons communicate an action a user can take. They are typically placed throughout your UI, in places like dialogs, forms, cards, and toolbars.\';\nvar Button_links = {\n  docs: \'https://github.com/material-components/material-components-web/tree/master/packages/mdc-button\',\n  guide: \'https://material.io/components/buttons\'\n};\nfunction ButtonPage() {\n  var _useState = (0,react.useState)(\'plain\'),\n      _useState2 = Button_slicedToArray(_useState, 2),\n      type = _useState2[0],\n      setType = _useState2[1];\n\n  var _useState3 = (0,react.useState)(false),\n      _useState4 = Button_slicedToArray(_useState3, 2),\n      leadingIcon = _useState4[0],\n      setLeadingIcon = _useState4[1];\n\n  var _useState5 = (0,react.useState)(false),\n      _useState6 = Button_slicedToArray(_useState5, 2),\n      trailingIcon = _useState6[0],\n      setTrailingIcon = _useState6[1];\n\n  var outlined = type === \'outlined\' || undefined;\n  var unelevated = type === \'unelevated\' || undefined;\n  var raised = type === \'raised\' || undefined;\n  return /*#__PURE__*/(0,jsx_runtime.jsx)(Page, {\n    id: Button_id,\n    title: Button_title,\n    description: Button_description,\n    links: Button_links,\n    children: /*#__PURE__*/(0,jsx_runtime.jsxs)(Section, {\n      title: "Demo",\n      children: [/*#__PURE__*/(0,jsx_runtime.jsxs)(layout_Layout, {\n        row: true,\n        children: [/*#__PURE__*/(0,jsx_runtime.jsxs)("fieldset", {\n          children: [/*#__PURE__*/(0,jsx_runtime.jsx)("legend", {\n            children: "Type"\n          }), /*#__PURE__*/(0,jsx_runtime.jsx)(segmented_button_SegmentedButton, {\n            segments: [{\n              value: \'plain\',\n              label: \'Plain\'\n            }, {\n              value: \'outlined\',\n              label: \'Outlined\'\n            }, {\n              value: \'unelevated\',\n              label: \'Unelevated\'\n            }, {\n              value: \'raised\',\n              label: \'Raised\'\n            }],\n            value: type,\n            onChange: setType\n          })]\n        }), /*#__PURE__*/(0,jsx_runtime.jsxs)("fieldset", {\n          children: [/*#__PURE__*/(0,jsx_runtime.jsx)("legend", {\n            children: "Icons"\n          }), /*#__PURE__*/(0,jsx_runtime.jsxs)(segmented_button_SegmentedButton, {\n            children: [/*#__PURE__*/(0,jsx_runtime.jsx)(segmented_button_SegmentedButton.Segment, {\n              label: "Leading Icon",\n              selected: leadingIcon,\n              onClick: function onClick() {\n                return setLeadingIcon(function (v) {\n                  return !v;\n                });\n              }\n            }), /*#__PURE__*/(0,jsx_runtime.jsx)(segmented_button_SegmentedButton.Segment, {\n              label: "Trailing Icon",\n              selected: trailingIcon,\n              onClick: function onClick() {\n                return setTrailingIcon(function (v) {\n                  return !v;\n                });\n              }\n            })]\n          })]\n        })]\n      }), /*#__PURE__*/(0,jsx_runtime.jsx)(Code, {\n        children: /*#__PURE__*/(0,jsx_runtime.jsx)(button_Button, {\n          leadingIcon: leadingIcon ? \'save\' : undefined,\n          trailingIcon: trailingIcon ? \'close\' : undefined,\n          outlined: outlined,\n          unelevated: unelevated,\n          raised: raised,\n          children: "Button"\n        })\n      })]\n    })\n  });\n}\n;// CONCATENATED MODULE: ./docs/src/pages/Card/index.jsx\n\n\n\n\n\n\nvar Card_id = \'card\';\nvar Card_title = \'Card\';\nvar Card_description = \'Cards contain content and actions about a single subject.\';\nvar Card_links = {\n  docs: \'https://github.com/material-components/material-components-web/tree/master/packages/mdc-card\',\n  guide: \'https://material.io/components/cards\'\n};\n\'\';\nfunction CardPage() {\n  return /*#__PURE__*/(0,jsx_runtime.jsxs)(Page, {\n    id: Card_id,\n    title: Card_title,\n    description: Card_description,\n    links: Card_links,\n    children: [/*#__PURE__*/(0,jsx_runtime.jsx)(Section, {\n      title: "Basic",\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(Code, {\n        children: /*#__PURE__*/(0,jsx_runtime.jsx)(card_Card, {\n          children: /*#__PURE__*/(0,jsx_runtime.jsx)(card_Card.Header, {\n            overline: "Overline",\n            title: "Title",\n            subtitle: "Subtitle"\n          })\n        })\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Section, {\n      title: "Primary action",\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(Code, {\n        children: /*#__PURE__*/(0,jsx_runtime.jsx)(card_Card, {\n          children: /*#__PURE__*/(0,jsx_runtime.jsx)(card_Card.PrimaryAction, {\n            children: /*#__PURE__*/(0,jsx_runtime.jsx)(card_Card.Header, {\n              overline: "Overline",\n              title: "Title",\n              subtitle: "Subtitle"\n            })\n          })\n        })\n      })\n    })]\n  });\n}\n;// CONCATENATED MODULE: ./docs/src/pages/Checkbox/index.jsx\nfunction Checkbox_slicedToArray(arr, i) { return Checkbox_arrayWithHoles(arr) || Checkbox_iterableToArrayLimit(arr, i) || Checkbox_unsupportedIterableToArray(arr, i) || Checkbox_nonIterableRest(); }\n\nfunction Checkbox_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction Checkbox_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return Checkbox_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return Checkbox_arrayLikeToArray(o, minLen); }\n\nfunction Checkbox_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction Checkbox_iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction Checkbox_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\n\n\n\n\n\n\n\nvar Checkbox_id = \'checkbox\';\nvar Checkbox_title = \'Checkbox\';\nvar Checkbox_description = \'Checkboxes allow the user to select multiple options from a set.\';\nvar Checkbox_links = {\n  docs: \'https://github.com/material-components/material-components-web/tree/master/packages/mdc-checkbox\',\n  guide: \'https://material.io/components/checkboxes\'\n};\nfunction CheckboxPage() {\n  var _useState = (0,react.useState)(false),\n      _useState2 = Checkbox_slicedToArray(_useState, 2),\n      isChecked = _useState2[0],\n      setChecked = _useState2[1];\n\n  return /*#__PURE__*/(0,jsx_runtime.jsxs)(Page, {\n    id: Checkbox_id,\n    title: Checkbox_title,\n    description: Checkbox_description,\n    links: Checkbox_links,\n    children: [/*#__PURE__*/(0,jsx_runtime.jsx)(Section, {\n      title: "Controlled",\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(Code, {\n        children: /*#__PURE__*/(0,jsx_runtime.jsx)(checkbox_Checkbox, {\n          checked: isChecked,\n          onChange: function onChange() {\n            return setChecked(function (v) {\n              return !v;\n            });\n          }\n        })\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Section, {\n      title: "Uncontrolled",\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(Code, {\n        children: /*#__PURE__*/(0,jsx_runtime.jsx)(checkbox_Checkbox, {\n          defaultChecked: false\n        })\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Section, {\n      title: "Indeterminate",\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(Code, {\n        children: /*#__PURE__*/(0,jsx_runtime.jsx)(checkbox_Checkbox, {\n          indeterminate: true,\n          defaultChecked: false\n        })\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Section, {\n      title: "Disabled",\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(Code, {\n        children: /*#__PURE__*/(0,jsx_runtime.jsx)(checkbox_Checkbox, {\n          disabled: true\n        })\n      })\n    })]\n  });\n}\n;// CONCATENATED MODULE: ./docs/src/pages/Chips/index.jsx\nfunction Chips_slicedToArray(arr, i) { return Chips_arrayWithHoles(arr) || Chips_iterableToArrayLimit(arr, i) || Chips_unsupportedIterableToArray(arr, i) || Chips_nonIterableRest(); }\n\nfunction Chips_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction Chips_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return Chips_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return Chips_arrayLikeToArray(o, minLen); }\n\nfunction Chips_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction Chips_iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction Chips_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\n\n\n\n\n\n\n\nvar Chips_id = \'chips\';\nvar Chips_title = \'Chips\';\nvar Chips_description = \'Chips are compact elements that allow users to enter information, select a choice, filter content, or trigger an action.\';\nvar Chips_links = {\n  docs: \'https://github.com/material-components/material-components-web/tree/master/packages/mdc-chips\',\n  guide: \'https://material.io/components/chips\'\n};\nfunction ChipsPage() {\n  var _useState = (0,react.useState)(\'foo\'),\n      _useState2 = Chips_slicedToArray(_useState, 2),\n      choiceChip = _useState2[0],\n      setChoiceChips = _useState2[1];\n\n  var _useState3 = (0,react.useState)([\'foo\']),\n      _useState4 = Chips_slicedToArray(_useState3, 2),\n      filterChips = _useState4[0],\n      setFilterChips = _useState4[1];\n\n  return /*#__PURE__*/(0,jsx_runtime.jsxs)(Page, {\n    id: Chips_id,\n    title: Chips_title,\n    description: Chips_description,\n    links: Chips_links,\n    children: [/*#__PURE__*/(0,jsx_runtime.jsx)(Section, {\n      title: "Basic chips",\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(Code, {\n        children: /*#__PURE__*/(0,jsx_runtime.jsxs)(chips_ChipSet, {\n          children: [/*#__PURE__*/(0,jsx_runtime.jsx)(chips_Chip, {\n            text: "Foo"\n          }), /*#__PURE__*/(0,jsx_runtime.jsx)(chips_Chip, {\n            text: "Bar"\n          }), /*#__PURE__*/(0,jsx_runtime.jsx)(chips_Chip, {\n            text: "Baz"\n          })]\n        })\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Section, {\n      title: "Chips with icons",\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(Code, {\n        children: /*#__PURE__*/(0,jsx_runtime.jsxs)(chips_ChipSet, {\n          children: [/*#__PURE__*/(0,jsx_runtime.jsx)(chips_Chip, {\n            text: "Foo",\n            icon: "star"\n          }), /*#__PURE__*/(0,jsx_runtime.jsx)(chips_Chip, {\n            text: "Bar",\n            icon: "star"\n          }), /*#__PURE__*/(0,jsx_runtime.jsx)(chips_Chip, {\n            text: "Baz",\n            icon: "star"\n          })]\n        })\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Section, {\n      title: "Chips with trailing icons",\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(Code, {\n        children: /*#__PURE__*/(0,jsx_runtime.jsxs)(chips_ChipSet, {\n          children: [/*#__PURE__*/(0,jsx_runtime.jsx)(chips_Chip, {\n            text: "Foo",\n            trailingIcon: "delete"\n          }), /*#__PURE__*/(0,jsx_runtime.jsx)(chips_Chip, {\n            text: "Bar",\n            trailingIcon: "delete"\n          }), /*#__PURE__*/(0,jsx_runtime.jsx)(chips_Chip, {\n            text: "Baz",\n            trailingIcon: "delete"\n          })]\n        })\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Section, {\n      title: "Chips with avatars",\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(Code, {\n        children: /*#__PURE__*/(0,jsx_runtime.jsxs)(chips_ChipSet, {\n          children: [/*#__PURE__*/(0,jsx_runtime.jsx)(chips_Chip, {\n            text: "Foo",\n            graphic: /*#__PURE__*/(0,jsx_runtime.jsx)(avatar_Avatar, {\n              src: "https://placeimg.com/128/128/people",\n              small: true\n            }),\n            withAvatar: true\n          }), /*#__PURE__*/(0,jsx_runtime.jsx)(chips_Chip, {\n            text: "Bar",\n            graphic: /*#__PURE__*/(0,jsx_runtime.jsx)(avatar_Avatar, {\n              src: "https://placeimg.com/128/128/people",\n              small: true\n            }),\n            withAvatar: true\n          }), /*#__PURE__*/(0,jsx_runtime.jsx)(chips_Chip, {\n            text: "Baz",\n            graphic: /*#__PURE__*/(0,jsx_runtime.jsx)(avatar_Avatar, {\n              src: "https://placeimg.com/128/128/people",\n              small: true\n            }),\n            withAvatar: true\n          })]\n        })\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Section, {\n      title: "Choice chips",\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(Code, {\n        children: /*#__PURE__*/(0,jsx_runtime.jsxs)(chips_ChipSet, {\n          value: choiceChip,\n          onChange: function onChange(value) {\n            return setChoiceChips(value);\n          },\n          children: [/*#__PURE__*/(0,jsx_runtime.jsx)(chips_Chip, {\n            value: "foo",\n            text: "Foo"\n          }), /*#__PURE__*/(0,jsx_runtime.jsx)(chips_Chip, {\n            value: "bar",\n            text: "Bar"\n          }), /*#__PURE__*/(0,jsx_runtime.jsx)(chips_Chip, {\n            value: "baz",\n            text: "Baz"\n          })]\n        })\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Section, {\n      title: "Filter chips",\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(Code, {\n        children: /*#__PURE__*/(0,jsx_runtime.jsxs)(chips_ChipSet, {\n          value: filterChips,\n          onChange: function onChange(value) {\n            return setFilterChips(value);\n          },\n          children: [/*#__PURE__*/(0,jsx_runtime.jsx)(chips_Chip, {\n            value: "foo",\n            text: "Foo"\n          }), /*#__PURE__*/(0,jsx_runtime.jsx)(chips_Chip, {\n            value: "bar",\n            text: "Bar"\n          }), /*#__PURE__*/(0,jsx_runtime.jsx)(chips_Chip, {\n            value: "baz",\n            text: "Baz"\n          })]\n        })\n      })\n    })]\n  });\n}\n;// CONCATENATED MODULE: ./docs/src/pages/CircularProgress/index.jsx\nfunction CircularProgress_slicedToArray(arr, i) { return CircularProgress_arrayWithHoles(arr) || CircularProgress_iterableToArrayLimit(arr, i) || CircularProgress_unsupportedIterableToArray(arr, i) || CircularProgress_nonIterableRest(); }\n\nfunction CircularProgress_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction CircularProgress_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return CircularProgress_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return CircularProgress_arrayLikeToArray(o, minLen); }\n\nfunction CircularProgress_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction CircularProgress_iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction CircularProgress_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\n\n\n\n\n\n\n\nvar CircularProgress_id = \'circular-progress\';\nvar CircularProgress_title = \'Circular Progress\';\nvar CircularProgress_description = \'Circular progress indicators display progress by animating an indicator along an invisible circular track in a clockwise direction.\';\nvar CircularProgress_links = {\n  docs: \'https://github.com/material-components/material-components-web/tree/master/packages/mdc-circular-progress\',\n  guide: \'https://material.io/components/progress-indicators#circular-progress-indicators\'\n};\nfunction CircularProgressPage() {\n  var _useState = (0,react.useState)(false),\n      _useState2 = CircularProgress_slicedToArray(_useState, 2),\n      isClosed = _useState2[0],\n      setClosed = _useState2[1];\n\n  return /*#__PURE__*/(0,jsx_runtime.jsxs)(Page, {\n    id: CircularProgress_id,\n    title: CircularProgress_title,\n    description: CircularProgress_description,\n    links: CircularProgress_links,\n    children: [/*#__PURE__*/(0,jsx_runtime.jsx)(Section, {\n      children: /*#__PURE__*/(0,jsx_runtime.jsxs)(Code, {\n        children: [/*#__PURE__*/(0,jsx_runtime.jsx)(circular_progress_CircularProgress, {\n          value: "42",\n          size: "small"\n        }), /*#__PURE__*/(0,jsx_runtime.jsx)(circular_progress_CircularProgress, {\n          value: "42",\n          size: "medium"\n        }), /*#__PURE__*/(0,jsx_runtime.jsx)(circular_progress_CircularProgress, {\n          value: "42",\n          size: "large"\n        })]\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Section, {\n      children: /*#__PURE__*/(0,jsx_runtime.jsxs)(Code, {\n        children: [/*#__PURE__*/(0,jsx_runtime.jsx)(circular_progress_CircularProgress, {\n          indeterminate: true,\n          size: "small"\n        }), /*#__PURE__*/(0,jsx_runtime.jsx)(circular_progress_CircularProgress, {\n          indeterminate: true,\n          size: "medium"\n        }), /*#__PURE__*/(0,jsx_runtime.jsx)(circular_progress_CircularProgress, {\n          indeterminate: true,\n          size: "large"\n        })]\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Section, {\n      children: /*#__PURE__*/(0,jsx_runtime.jsxs)(Code, {\n        children: [/*#__PURE__*/(0,jsx_runtime.jsx)(circular_progress_CircularProgress, {\n          size: "small",\n          indeterminate: true,\n          colorful: true\n        }), /*#__PURE__*/(0,jsx_runtime.jsx)(circular_progress_CircularProgress, {\n          size: "medium",\n          indeterminate: true,\n          colorful: true\n        }), /*#__PURE__*/(0,jsx_runtime.jsx)(circular_progress_CircularProgress, {\n          size: "large",\n          indeterminate: true,\n          colorful: true\n        })]\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Section, {\n      title: "Closed circular progress",\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(Code, {\n        setup: /*#__PURE__*/(0,jsx_runtime.jsx)(button_Button, {\n          label: "Toggle",\n          outlined: true,\n          onClick: function onClick() {\n            return setClosed(function (v) {\n              return !v;\n            });\n          }\n        }),\n        children: /*#__PURE__*/(0,jsx_runtime.jsx)(circular_progress_CircularProgress, {\n          size: "medium",\n          indeterminate: true,\n          closed: isClosed\n        })\n      })\n    })]\n  });\n}\n;// CONCATENATED MODULE: ./docs/src/pages/DataTable/index.jsx\nfunction DataTable_slicedToArray(arr, i) { return DataTable_arrayWithHoles(arr) || DataTable_iterableToArrayLimit(arr, i) || DataTable_unsupportedIterableToArray(arr, i) || DataTable_nonIterableRest(); }\n\nfunction DataTable_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction DataTable_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return DataTable_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return DataTable_arrayLikeToArray(o, minLen); }\n\nfunction DataTable_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction DataTable_iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction DataTable_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\n\n\n\n\n\n\n\nvar DataTable_id = \'data-table\';\nvar DataTable_title = \'Data Table\';\nvar DataTable_description = \'Data tables display sets of data across rows and columns.\';\nvar DataTable_links = {\n  docs: \'https://github.com/material-components/material-components-web/tree/master/packages/mdc-data-table\',\n  guide: \'https://material.io/components/data-tables\'\n};\nvar table = [[\'Frozen yogurt\', 24, 4.0, \'Super tasty\'], [\'Ice cream sandwich\', 37, 4.33333333333, \'I like ice cream more\'], [\'Eclair\', 24, 6.0, \'New filing flavor\']];\nfunction DataTablePage() {\n  var _useState = (0,react.useState)(table),\n      _useState2 = DataTable_slicedToArray(_useState, 2),\n      data = _useState2[0],\n      setData = _useState2[1];\n\n  var _useState3 = (0,react.useState)(0),\n      _useState4 = DataTable_slicedToArray(_useState3, 2),\n      sort = _useState4[0],\n      setSort = _useState4[1];\n\n  var handleSort = (0,react.useCallback)(function () {\n    setSort(function (sort) {\n      if (sort === -1) {\n        setData(function (data) {\n          return data.slice().sort(function (a, b) {\n            return a[1] - b[1];\n          });\n        });\n        setSort(1);\n      } else {\n        setData(function (data) {\n          return data.slice().sort(function (a, b) {\n            return b[1] - a[1];\n          });\n        });\n        setSort(-1);\n      }\n    });\n  }, []);\n  return /*#__PURE__*/(0,jsx_runtime.jsx)(Page, {\n    id: DataTable_id,\n    title: DataTable_title,\n    description: DataTable_description,\n    links: DataTable_links,\n    children: /*#__PURE__*/(0,jsx_runtime.jsx)(Section, {\n      title: "Sortable data table",\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(Code, {\n        children: /*#__PURE__*/(0,jsx_runtime.jsxs)(data_table_DataTable, {\n          children: [/*#__PURE__*/(0,jsx_runtime.jsx)(data_table_DataTable.Header, {\n            children: /*#__PURE__*/(0,jsx_runtime.jsxs)(data_table_DataTable.HeaderRow, {\n              children: [/*#__PURE__*/(0,jsx_runtime.jsx)(data_table_DataTable.HeaderCell, {\n                children: "Dessert"\n              }), /*#__PURE__*/(0,jsx_runtime.jsx)(data_table_DataTable.HeaderCell, {\n                numeric: true,\n                sort: sort,\n                onSort: handleSort,\n                children: "Carbs (g)"\n              }), /*#__PURE__*/(0,jsx_runtime.jsx)(data_table_DataTable.HeaderCell, {\n                numeric: true,\n                children: "Protein (g)"\n              }), /*#__PURE__*/(0,jsx_runtime.jsx)(data_table_DataTable.HeaderCell, {\n                children: "Comments"\n              })]\n            })\n          }), /*#__PURE__*/(0,jsx_runtime.jsx)(data_table_DataTable.Content, {\n            children: data.map(function (row, index) {\n              return /*#__PURE__*/(0,jsx_runtime.jsx)(data_table_DataTable.Row, {\n                children: row.map(function (value, index) {\n                  return /*#__PURE__*/(0,jsx_runtime.jsx)(data_table_DataTable.Cell, {\n                    scope: index === 0 ? \'row\' : undefined,\n                    numeric: typeof value === \'number\' || undefined,\n                    children: value\n                  }, index);\n                })\n              }, index);\n            })\n          })]\n        })\n      })\n    })\n  });\n}\n;// CONCATENATED MODULE: ./docs/src/pages/Dialog/index.jsx\nfunction Dialog_slicedToArray(arr, i) { return Dialog_arrayWithHoles(arr) || Dialog_iterableToArrayLimit(arr, i) || Dialog_unsupportedIterableToArray(arr, i) || Dialog_nonIterableRest(); }\n\nfunction Dialog_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction Dialog_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return Dialog_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return Dialog_arrayLikeToArray(o, minLen); }\n\nfunction Dialog_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction Dialog_iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction Dialog_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\n\n\n\n\n\n\n\nvar Dialog_id = \'dialog\';\nvar Dialog_title = \'Dialog\';\nvar Dialog_description = \'Dialogs inform users about a specific task and may contain critical information, require decisions, or involve multiple tasks.\';\nvar Dialog_links = {\n  docs: \'https://github.com/material-components/material-components-web/tree/master/packages/mdc-dialog\',\n  guide: \'https://material.io/components/dialogs\'\n};\nfunction DialogPage() {\n  var _useState = (0,react.useState)(false),\n      _useState2 = Dialog_slicedToArray(_useState, 2),\n      isBasicOpen = _useState2[0],\n      setBasicOpen = _useState2[1];\n\n  var _useState3 = (0,react.useState)(false),\n      _useState4 = Dialog_slicedToArray(_useState3, 2),\n      isConfirmationOpen = _useState4[0],\n      setConfirmationOpen = _useState4[1];\n\n  var _useState5 = (0,react.useState)(false),\n      _useState6 = Dialog_slicedToArray(_useState5, 2),\n      isStackingOpen = _useState6[0],\n      setStackingOpen = _useState6[1];\n\n  var _useState7 = (0,react.useState)(false),\n      _useState8 = Dialog_slicedToArray(_useState7, 2),\n      isScrollableOpen = _useState8[0],\n      setScrollableOpen = _useState8[1];\n\n  var _useState9 = (0,react.useState)(false),\n      _useState10 = Dialog_slicedToArray(_useState9, 2),\n      isFullscreenOpen = _useState10[0],\n      setFullscreenOpen = _useState10[1];\n\n  return /*#__PURE__*/(0,jsx_runtime.jsxs)(Page, {\n    id: Dialog_id,\n    title: Dialog_title,\n    description: Dialog_description,\n    links: Dialog_links,\n    children: [/*#__PURE__*/(0,jsx_runtime.jsx)(Section, {\n      title: "Basic dialog",\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(Code, {\n        setup: /*#__PURE__*/(0,jsx_runtime.jsx)(button_Button, {\n          onClick: function onClick() {\n            return setBasicOpen(function (v) {\n              return !v;\n            });\n          },\n          children: "Open"\n        }),\n        children: /*#__PURE__*/(0,jsx_runtime.jsx)(dialog_Dialog, {\n          title: "Title",\n          content: "Content",\n          open: isBasicOpen,\n          onClose: function onClose() {\n            return setBasicOpen(function (v) {\n              return !v;\n            });\n          }\n        })\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Section, {\n      title: "Confirmation dialog",\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(Code, {\n        setup: /*#__PURE__*/(0,jsx_runtime.jsx)(button_Button, {\n          onClick: function onClick() {\n            return setConfirmationOpen(function (v) {\n              return !v;\n            });\n          },\n          children: "Open"\n        }),\n        children: /*#__PURE__*/(0,jsx_runtime.jsx)(dialog_Dialog, {\n          title: "Title",\n          content: "Are you sure?",\n          open: isConfirmationOpen,\n          persistent: true,\n          autoStackButtons: true,\n          actions: [/*#__PURE__*/(0,jsx_runtime.jsx)(button_Button, {\n            onClick: function onClick() {\n              return setConfirmationOpen(function (v) {\n                return !v;\n              });\n            },\n            children: "Close"\n          }, "close"), /*#__PURE__*/(0,jsx_runtime.jsx)(button_Button, {\n            children: "Confirm"\n          }, "confirm")],\n          onClose: function onClose() {\n            return setConfirmationOpen(function (v) {\n              return !v;\n            });\n          }\n        })\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Section, {\n      title: "Dialog with stacking buttons",\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(Code, {\n        setup: /*#__PURE__*/(0,jsx_runtime.jsx)(button_Button, {\n          onClick: function onClick() {\n            return setStackingOpen(function (v) {\n              return !v;\n            });\n          },\n          children: "Open"\n        }),\n        children: /*#__PURE__*/(0,jsx_runtime.jsx)(dialog_Dialog, {\n          title: "Title",\n          open: isStackingOpen,\n          autoStackButtons: true,\n          actions: [/*#__PURE__*/(0,jsx_runtime.jsx)(button_Button, {\n            onClick: function onClick() {\n              return setStackingOpen(function (v) {\n                return !v;\n              });\n            },\n            children: "A very very very very very long button"\n          }, "close"), /*#__PURE__*/(0,jsx_runtime.jsx)(button_Button, {\n            children: "A very very very very very long button"\n          }, "confirm")],\n          onClose: function onClose() {\n            return setStackingOpen(function (v) {\n              return !v;\n            });\n          }\n        })\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Section, {\n      title: "Scrollable dialog",\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(Code, {\n        setup: /*#__PURE__*/(0,jsx_runtime.jsx)(button_Button, {\n          onClick: function onClick() {\n            return setScrollableOpen(function (v) {\n              return !v;\n            });\n          },\n          children: "Open"\n        }),\n        children: /*#__PURE__*/(0,jsx_runtime.jsx)(dialog_Dialog, {\n          title: "Title",\n          open: isScrollableOpen,\n          actions: /*#__PURE__*/(0,jsx_runtime.jsx)(button_Button, {\n            onClick: function onClick() {\n              return setScrollableOpen(function (v) {\n                return !v;\n              });\n            },\n            children: "Close"\n          }),\n          onClose: function onClose() {\n            return setScrollableOpen(function (v) {\n              return !v;\n            });\n          },\n          children: "Lorem ipsum dolor sit amet consectetur adipisicing elit. Sunt earum quibusdam dolor hic accusamus, deserunt libero? Deleniti ratione libero, eveniet neque aliquam repellat dicta obcaecati atque, sequi voluptatem explicabo beatae! Lorem ipsum dolor sit amet consectetur adipisicing elit. Veritatis animi vel cupiditate eveniet? Laudantium recusandae illo minus saepe itaque dolores fugiat, perferendis nostrum! Assumenda fugiat fuga deserunt omnis odit dicta! Lorem ipsum dolor sit amet consectetur adipisicing elit. Minus accusantium a quisquam in repudiandae et ullam cum dignissimos exercitationem, blanditiis perspiciatis alias hic vel, laudantium aliquam omnis recusandae nemo animi. Lorem ipsum dolor sit amet consectetur adipisicing elit. Sunt earum quibusdam dolor hic accusamus, deserunt libero? Deleniti ratione libero, eveniet neque aliquam repellat dicta obcaecati atque, sequi voluptatem explicabo beatae! Lorem ipsum dolor sit amet consectetur adipisicing elit. Veritatis animi vel cupiditate eveniet? Laudantium recusandae illo minus saepe itaque dolores fugiat, perferendis nostrum! Assumenda fugiat fuga deserunt omnis odit dicta! Lorem ipsum dolor sit amet consectetur adipisicing elit. Minus accusantium a quisquam in repudiandae et ullam cum dignissimos exercitationem, blanditiis perspiciatis alias hic vel, laudantium aliquam omnis recusandae nemo animi. Lorem ipsum dolor sit amet consectetur adipisicing elit. Sunt earum quibusdam dolor hic accusamus, deserunt libero? Deleniti ratione libero, eveniet neque aliquam repellat dicta obcaecati atque, sequi voluptatem explicabo beatae! Lorem ipsum dolor sit amet consectetur adipisicing elit. Veritatis animi vel cupiditate eveniet? Laudantium recusandae illo minus saepe itaque dolores fugiat, perferendis nostrum! Assumenda fugiat fuga deserunt omnis odit dicta! Lorem ipsum dolor sit amet consectetur adipisicing elit. Minus accusantium a quisquam in repudiandae et ullam cum dignissimos exercitationem, blanditiis perspiciatis alias hic vel, laudantium aliquam omnis recusandae nemo animi. Lorem ipsum dolor sit amet consectetur adipisicing elit. Sunt earum quibusdam dolor hic accusamus, deserunt libero? Deleniti ratione libero, eveniet neque aliquam repellat dicta obcaecati atque, sequi voluptatem explicabo beatae! Lorem ipsum dolor sit amet consectetur adipisicing elit. Veritatis animi vel cupiditate eveniet? Laudantium recusandae illo minus saepe itaque dolores fugiat, perferendis nostrum! Assumenda fugiat fuga deserunt omnis odit dicta! Lorem ipsum dolor sit amet consectetur adipisicing elit. Minus accusantium a quisquam in repudiandae et ullam cum dignissimos exercitationem, blanditiis perspiciatis alias hic vel, laudantium aliquam omnis recusandae nemo animi. Lorem ipsum dolor sit amet consectetur adipisicing elit. Sunt earum quibusdam dolor hic accusamus, deserunt libero? Deleniti ratione libero, eveniet neque aliquam repellat dicta obcaecati atque, sequi voluptatem explicabo beatae! Lorem ipsum dolor sit amet consectetur adipisicing elit. Veritatis animi vel cupiditate eveniet? Laudantium recusandae illo minus saepe itaque dolores fugiat, perferendis nostrum! Assumenda fugiat fuga deserunt omnis odit dicta! Lorem ipsum dolor sit amet consectetur adipisicing elit. Minus accusantium a quisquam in repudiandae et ullam cum dignissimos exercitationem, blanditiis perspiciatis alias hic vel, laudantium aliquam omnis recusandae nemo animi. Lorem ipsum dolor sit amet consectetur adipisicing elit. Sunt earum quibusdam dolor hic accusamus, deserunt libero? Deleniti ratione libero, eveniet neque aliquam repellat dicta obcaecati atque, sequi voluptatem explicabo beatae! Lorem ipsum dolor sit amet consectetur adipisicing elit. Veritatis animi vel cupiditate eveniet? Laudantium recusandae illo minus saepe itaque dolores fugiat, perferendis nostrum! Assumenda fugiat fuga deserunt omnis odit dicta! Lorem ipsum dolor sit amet consectetur adipisicing elit. Minus accusantium a quisquam in repudiandae et ullam cum dignissimos exercitationem, blanditiis perspiciatis alias hic vel, laudantium aliquam omnis recusandae nemo animi."\n        })\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Section, {\n      title: "Fullscreen dialog",\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(Code, {\n        setup: /*#__PURE__*/(0,jsx_runtime.jsx)(button_Button, {\n          onClick: function onClick() {\n            return setFullscreenOpen(function (v) {\n              return !v;\n            });\n          },\n          children: "Open"\n        }),\n        children: /*#__PURE__*/(0,jsx_runtime.jsx)(dialog_Dialog, {\n          title: "Fullscreen Dialog",\n          open: isFullscreenOpen,\n          fullscreen: true,\n          actions: /*#__PURE__*/(0,jsx_runtime.jsx)(button_Button, {\n            onClick: function onClick() {\n              return setFullscreenOpen(function (v) {\n                return !v;\n              });\n            },\n            children: "Close"\n          }),\n          onClose: function onClose() {\n            return setFullscreenOpen(function (v) {\n              return !v;\n            });\n          },\n          children: "Lorem ipsum dolor sit amet consectetur adipisicing elit. Sunt earum quibusdam dolor hic accusamus, deserunt libero? Deleniti ratione libero, eveniet neque aliquam repellat dicta obcaecati atque, sequi voluptatem explicabo beatae! Lorem ipsum dolor sit amet consectetur adipisicing elit. Veritatis animi vel cupiditate eveniet? Laudantium recusandae illo minus saepe itaque dolores fugiat, perferendis nostrum! Assumenda fugiat fuga deserunt omnis odit dicta! Lorem ipsum dolor sit amet consectetur adipisicing elit. Minus accusantium a quisquam in repudiandae et ullam cum dignissimos exercitationem, blanditiis perspiciatis alias hic vel, laudantium aliquam omnis recusandae nemo animi. Lorem ipsum dolor sit amet consectetur adipisicing elit. Sunt earum quibusdam dolor hic accusamus, deserunt libero? Deleniti ratione libero, eveniet neque aliquam repellat dicta obcaecati atque, sequi voluptatem explicabo beatae! Lorem ipsum dolor sit amet consectetur adipisicing elit. Veritatis animi vel cupiditate eveniet? Laudantium recusandae illo minus saepe itaque dolores fugiat, perferendis nostrum! Assumenda fugiat fuga deserunt omnis odit dicta! Lorem ipsum dolor sit amet consectetur adipisicing elit. Minus accusantium a quisquam in repudiandae et ullam cum dignissimos exercitationem, blanditiis perspiciatis alias hic vel, laudantium aliquam omnis recusandae nemo animi. Lorem ipsum dolor sit amet consectetur adipisicing elit. Sunt earum quibusdam dolor hic accusamus, deserunt libero? Deleniti ratione libero, eveniet neque aliquam repellat dicta obcaecati atque, sequi voluptatem explicabo beatae! Lorem ipsum dolor sit amet consectetur adipisicing elit. Veritatis animi vel cupiditate eveniet? Laudantium recusandae illo minus saepe itaque dolores fugiat, perferendis nostrum! Assumenda fugiat fuga deserunt omnis odit dicta! Lorem ipsum dolor sit amet consectetur adipisicing elit. Minus accusantium a quisquam in repudiandae et ullam cum dignissimos exercitationem, blanditiis perspiciatis alias hic vel, laudantium aliquam omnis recusandae nemo animi. Lorem ipsum dolor sit amet consectetur adipisicing elit. Sunt earum quibusdam dolor hic accusamus, deserunt libero? Deleniti ratione libero, eveniet neque aliquam repellat dicta obcaecati atque, sequi voluptatem explicabo beatae! Lorem ipsum dolor sit amet consectetur adipisicing elit. Veritatis animi vel cupiditate eveniet? Laudantium recusandae illo minus saepe itaque dolores fugiat, perferendis nostrum! Assumenda fugiat fuga deserunt omnis odit dicta! Lorem ipsum dolor sit amet consectetur adipisicing elit. Minus accusantium a quisquam in repudiandae et ullam cum dignissimos exercitationem, blanditiis perspiciatis alias hic vel, laudantium aliquam omnis recusandae nemo animi. Lorem ipsum dolor sit amet consectetur adipisicing elit. Sunt earum quibusdam dolor hic accusamus, deserunt libero? Deleniti ratione libero, eveniet neque aliquam repellat dicta obcaecati atque, sequi voluptatem explicabo beatae! Lorem ipsum dolor sit amet consectetur adipisicing elit. Veritatis animi vel cupiditate eveniet? Laudantium recusandae illo minus saepe itaque dolores fugiat, perferendis nostrum! Assumenda fugiat fuga deserunt omnis odit dicta! Lorem ipsum dolor sit amet consectetur adipisicing elit. Minus accusantium a quisquam in repudiandae et ullam cum dignissimos exercitationem, blanditiis perspiciatis alias hic vel, laudantium aliquam omnis recusandae nemo animi. Lorem ipsum dolor sit amet consectetur adipisicing elit. Sunt earum quibusdam dolor hic accusamus, deserunt libero? Deleniti ratione libero, eveniet neque aliquam repellat dicta obcaecati atque, sequi voluptatem explicabo beatae! Lorem ipsum dolor sit amet consectetur adipisicing elit. Veritatis animi vel cupiditate eveniet? Laudantium recusandae illo minus saepe itaque dolores fugiat, perferendis nostrum! Assumenda fugiat fuga deserunt omnis odit dicta! Lorem ipsum dolor sit amet consectetur adipisicing elit. Minus accusantium a quisquam in repudiandae et ullam cum dignissimos exercitationem, blanditiis perspiciatis alias hic vel, laudantium aliquam omnis recusandae nemo animi."\n        })\n      })\n    })]\n  });\n}\n;// CONCATENATED MODULE: ./docs/src/pages/Drawer/index.jsx\nfunction Drawer_slicedToArray(arr, i) { return Drawer_arrayWithHoles(arr) || Drawer_iterableToArrayLimit(arr, i) || Drawer_unsupportedIterableToArray(arr, i) || Drawer_nonIterableRest(); }\n\nfunction Drawer_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction Drawer_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return Drawer_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return Drawer_arrayLikeToArray(o, minLen); }\n\nfunction Drawer_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction Drawer_iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction Drawer_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\n\n\n\n\n\n\n\nvar Drawer_id = \'drawer\';\nvar Drawer_title = \'Drawer\';\nvar Drawer_description = \'Navigation drawers provide access to destinations in your app.\';\nvar Drawer_links = {\n  docs: \'https://github.com/material-components/material-components-web/tree/master/packages/mdc-drawer\',\n  guide: \'https://material.io/components/navigation-drawer\'\n};\nfunction DrawerPage() {\n  var _useState = (0,react.useState)(false),\n      _useState2 = Drawer_slicedToArray(_useState, 2),\n      isDismissibleOpen = _useState2[0],\n      setDismissibleOpen = _useState2[1];\n\n  var _useState3 = (0,react.useState)(false),\n      _useState4 = Drawer_slicedToArray(_useState3, 2),\n      isModalOpen = _useState4[0],\n      setModalOpen = _useState4[1];\n\n  return /*#__PURE__*/(0,jsx_runtime.jsxs)(Page, {\n    id: Drawer_id,\n    title: Drawer_title,\n    description: Drawer_description,\n    links: Drawer_links,\n    children: [/*#__PURE__*/(0,jsx_runtime.jsx)(Section, {\n      title: "Permanent drawer",\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(Code, {\n        children: /*#__PURE__*/(0,jsx_runtime.jsx)(drawer_Drawer, {\n          children: /*#__PURE__*/(0,jsx_runtime.jsx)(drawer_Drawer.Header, {\n            title: "Title"\n          })\n        })\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Section, {\n      title: "Dismissible drawer",\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(Code, {\n        setup: /*#__PURE__*/(0,jsx_runtime.jsx)(button_Button, {\n          label: "Toggle",\n          onClick: function onClick() {\n            return setDismissibleOpen(function (v) {\n              return !v;\n            });\n          }\n        }),\n        children: /*#__PURE__*/(0,jsx_runtime.jsx)(drawer_Drawer, {\n          open: isDismissibleOpen,\n          dismissible: true,\n          children: /*#__PURE__*/(0,jsx_runtime.jsx)(drawer_Drawer.Header, {\n            title: "Title"\n          })\n        })\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Section, {\n      title: "Modal drawer",\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(Code, {\n        setup: /*#__PURE__*/(0,jsx_runtime.jsx)(button_Button, {\n          label: "Toggle",\n          onClick: function onClick() {\n            return setModalOpen(function (v) {\n              return !v;\n            });\n          }\n        }),\n        children: /*#__PURE__*/(0,jsx_runtime.jsx)(drawer_Drawer, {\n          open: isModalOpen,\n          onClose: function onClose() {\n            return setModalOpen(function (v) {\n              return !v;\n            });\n          },\n          modal: true,\n          children: /*#__PURE__*/(0,jsx_runtime.jsx)(drawer_Drawer.Header, {\n            title: "Title"\n          })\n        })\n      })\n    })]\n  });\n}\n;// CONCATENATED MODULE: ./docs/src/pages/Elevation/index.jsx\nfunction Elevation_slicedToArray(arr, i) { return Elevation_arrayWithHoles(arr) || Elevation_iterableToArrayLimit(arr, i) || Elevation_unsupportedIterableToArray(arr, i) || Elevation_nonIterableRest(); }\n\nfunction Elevation_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction Elevation_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return Elevation_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return Elevation_arrayLikeToArray(o, minLen); }\n\nfunction Elevation_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction Elevation_iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction Elevation_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\n\n\n\n\n\n\n\nvar Elevation_id = \'elevation\';\nvar Elevation_title = \'Elevation\';\nvar Elevation_description = \'Elevation is the relative distance between two surfaces along the z-axis.\';\nvar Elevation_links = {\n  docs: \'https://github.com/material-components/material-components-web/tree/master/packages/mdc-elevation\',\n  guide: \'https://material.io/design/environment/elevation\'\n};\nfunction ElevationPage() {\n  var _useState = (0,react.useState)(0),\n      _useState2 = Elevation_slicedToArray(_useState, 2),\n      z = _useState2[0],\n      setZ = _useState2[1];\n\n  var handleChange = (0,react.useCallback)(function (value) {\n    setZ(value);\n  }, []);\n  return /*#__PURE__*/(0,jsx_runtime.jsx)(Page, {\n    id: Elevation_id,\n    title: Elevation_title,\n    description: Elevation_description,\n    links: Elevation_links,\n    children: /*#__PURE__*/(0,jsx_runtime.jsx)(Section, {\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(Code, {\n        setup: /*#__PURE__*/(0,jsx_runtime.jsx)(slider_Slider, {\n          value: z,\n          min: "0",\n          max: "24",\n          step: "1",\n          discrete: true,\n          tickMarks: true,\n          onChange: handleChange\n        }),\n        children: /*#__PURE__*/(0,jsx_runtime.jsx)(elevation_Elevation, {\n          z: z\n        })\n      })\n    })\n  });\n}\n;// CONCATENATED MODULE: ./docs/src/pages/FAB/index.jsx\nfunction FAB_slicedToArray(arr, i) { return FAB_arrayWithHoles(arr) || FAB_iterableToArrayLimit(arr, i) || FAB_unsupportedIterableToArray(arr, i) || FAB_nonIterableRest(); }\n\nfunction FAB_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction FAB_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return FAB_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return FAB_arrayLikeToArray(o, minLen); }\n\nfunction FAB_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction FAB_iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction FAB_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\n\n\n\n\n\n\n\nvar FAB_id = \'fab\';\nvar FAB_title = \'FAB\';\nvar FAB_description = \'A floating action button (FAB) represents the primary action of a screen.\';\nvar FAB_links = {\n  docs: \'https://github.com/material-components/material-components-web/tree/master/packages/mdc-fab\',\n  guide: \'https://material.io/components/buttons-floating-action-button\'\n};\nfunction FABPage() {\n  var _useState = (0,react.useState)(false),\n      _useState2 = FAB_slicedToArray(_useState, 2),\n      isExited = _useState2[0],\n      setExited = _useState2[1];\n\n  return /*#__PURE__*/(0,jsx_runtime.jsxs)(Page, {\n    id: FAB_id,\n    title: FAB_title,\n    description: FAB_description,\n    links: FAB_links,\n    children: [/*#__PURE__*/(0,jsx_runtime.jsx)(Section, {\n      title: "Basic FAB",\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(Code, {\n        children: /*#__PURE__*/(0,jsx_runtime.jsx)(fab_FAB, {\n          icon: "star"\n        })\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Section, {\n      title: "Mini FAB",\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(Code, {\n        children: /*#__PURE__*/(0,jsx_runtime.jsx)(fab_FAB, {\n          icon: "star",\n          mini: true\n        })\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Section, {\n      title: "Extended FAB",\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(Code, {\n        children: /*#__PURE__*/(0,jsx_runtime.jsx)(fab_FAB, {\n          icon: "star",\n          label: "Star"\n        })\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Section, {\n      title: "Extended FAB with a trailing icon",\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(Code, {\n        children: /*#__PURE__*/(0,jsx_runtime.jsx)(fab_FAB, {\n          label: "Star",\n          trailingIcon: "star"\n        })\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Section, {\n      title: "Animated FAB",\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(Code, {\n        setup: /*#__PURE__*/(0,jsx_runtime.jsx)(button_Button, {\n          label: "Toggle",\n          onClick: function onClick() {\n            return setExited(function (v) {\n              return !v;\n            });\n          }\n        }),\n        children: /*#__PURE__*/(0,jsx_runtime.jsx)(fab_FAB, {\n          icon: "star",\n          exited: isExited\n        })\n      })\n    })]\n  });\n}\n;// CONCATENATED MODULE: ./docs/src/pages/FormField/index.jsx\n\n\n\n\n\n\n\nvar FormField_id = \'form-field\';\nvar FormField_title = \'Form Field\';\nvar FormField_description = \'Form Field aligns a form field (for example, a checkbox) with its label and makes it RTL-aware.\';\nvar FormField_links = {\n  docs: \'https://github.com/material-components/material-components-web/tree/master/packages/mdc-form-field\'\n};\nfunction FormFieldPage() {\n  return /*#__PURE__*/(0,jsx_runtime.jsxs)(Page, {\n    id: FormField_id,\n    title: FormField_title,\n    description: FormField_description,\n    links: FormField_links,\n    children: [/*#__PURE__*/(0,jsx_runtime.jsx)(Section, {\n      title: "Basic form field",\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(Code, {\n        children: /*#__PURE__*/(0,jsx_runtime.jsx)(form_field_FormField, {\n          label: "Label",\n          children: /*#__PURE__*/(0,jsx_runtime.jsx)(checkbox_Checkbox, {})\n        })\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Section, {\n      title: "Form field that goes before the element",\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(Code, {\n        children: /*#__PURE__*/(0,jsx_runtime.jsx)(form_field_FormField, {\n          label: "Label",\n          alignEnd: true,\n          children: /*#__PURE__*/(0,jsx_runtime.jsx)(checkbox_Checkbox, {})\n        })\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Section, {\n      title: "No wrap form field",\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(Code, {\n        children: /*#__PURE__*/(0,jsx_runtime.jsx)(form_field_FormField, {\n          label: "Label",\n          nowrap: true,\n          children: /*#__PURE__*/(0,jsx_runtime.jsx)(checkbox_Checkbox, {})\n        })\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Section, {\n      title: "Form field with space between",\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(Code, {\n        children: /*#__PURE__*/(0,jsx_runtime.jsx)(form_field_FormField, {\n          label: "Label",\n          spaceBetween: true,\n          children: /*#__PURE__*/(0,jsx_runtime.jsx)(checkbox_Checkbox, {})\n        })\n      })\n    })]\n  });\n}\n// EXTERNAL MODULE: ./node_modules/marked/lib/marked.js\nvar marked = __webpack_require__(84);\nvar marked_default = /*#__PURE__*/__webpack_require__.n(marked);\n// EXTERNAL MODULE: ./node_modules/highlight.js/lib/core.js\nvar core = __webpack_require__(390);\n;// CONCATENATED MODULE: ./node_modules/highlight.js/es/core.js\n// https://nodejs.org/api/packages.html#packages_writing_dual_packages_while_avoiding_or_minimizing_hazards\n\n/* harmony default export */ const es_core = (core);\n\n;// CONCATENATED MODULE: ./node_modules/highlight.js/es/languages/javascript.js\nconst IDENT_RE = \'[A-Za-z$_][0-9A-Za-z$_]*\';\nconst KEYWORDS = [\n  "as", // for exports\n  "in",\n  "of",\n  "if",\n  "for",\n  "while",\n  "finally",\n  "var",\n  "new",\n  "function",\n  "do",\n  "return",\n  "void",\n  "else",\n  "break",\n  "catch",\n  "instanceof",\n  "with",\n  "throw",\n  "case",\n  "default",\n  "try",\n  "switch",\n  "continue",\n  "typeof",\n  "delete",\n  "let",\n  "yield",\n  "const",\n  "class",\n  // JS handles these with a special rule\n  // "get",\n  // "set",\n  "debugger",\n  "async",\n  "await",\n  "static",\n  "import",\n  "from",\n  "export",\n  "extends"\n];\nconst LITERALS = [\n  "true",\n  "false",\n  "null",\n  "undefined",\n  "NaN",\n  "Infinity"\n];\n\nconst TYPES = [\n  "Intl",\n  "DataView",\n  "Number",\n  "Math",\n  "Date",\n  "String",\n  "RegExp",\n  "Object",\n  "Function",\n  "Boolean",\n  "Error",\n  "Symbol",\n  "Set",\n  "Map",\n  "WeakSet",\n  "WeakMap",\n  "Proxy",\n  "Reflect",\n  "JSON",\n  "Promise",\n  "Float64Array",\n  "Int16Array",\n  "Int32Array",\n  "Int8Array",\n  "Uint16Array",\n  "Uint32Array",\n  "Float32Array",\n  "Array",\n  "Uint8Array",\n  "Uint8ClampedArray",\n  "ArrayBuffer",\n  "BigInt64Array",\n  "BigUint64Array",\n  "BigInt"\n];\n\nconst ERROR_TYPES = [\n  "EvalError",\n  "InternalError",\n  "RangeError",\n  "ReferenceError",\n  "SyntaxError",\n  "TypeError",\n  "URIError"\n];\n\nconst BUILT_IN_GLOBALS = [\n  "setInterval",\n  "setTimeout",\n  "clearInterval",\n  "clearTimeout",\n\n  "require",\n  "exports",\n\n  "eval",\n  "isFinite",\n  "isNaN",\n  "parseFloat",\n  "parseInt",\n  "decodeURI",\n  "decodeURIComponent",\n  "encodeURI",\n  "encodeURIComponent",\n  "escape",\n  "unescape"\n];\n\nconst BUILT_IN_VARIABLES = [\n  "arguments",\n  "this",\n  "super",\n  "console",\n  "window",\n  "document",\n  "localStorage",\n  "module",\n  "global" // Node.js\n];\n\nconst BUILT_INS = [].concat(\n  BUILT_IN_GLOBALS,\n  TYPES,\n  ERROR_TYPES\n);\n\n/**\n * @param {string} value\n * @returns {RegExp}\n * */\n\n/**\n * @param {RegExp | string } re\n * @returns {string}\n */\nfunction source(re) {\n  if (!re) return null;\n  if (typeof re === "string") return re;\n\n  return re.source;\n}\n\n/**\n * @param {RegExp | string } re\n * @returns {string}\n */\nfunction lookahead(re) {\n  return concat(\'(?=\', re, \')\');\n}\n\n/**\n * @param {...(RegExp | string) } args\n * @returns {string}\n */\nfunction concat(...args) {\n  const joined = args.map((x) => source(x)).join("");\n  return joined;\n}\n\n/*\nLanguage: JavaScript\nDescription: JavaScript (JS) is a lightweight, interpreted, or just-in-time compiled programming language with first-class functions.\nCategory: common, scripting, web\nWebsite: https://developer.mozilla.org/en-US/docs/Web/JavaScript\n*/\n\n/** @type LanguageFn */\nfunction javascript(hljs) {\n  /**\n   * Takes a string like "<Booger" and checks to see\n   * if we can find a matching "</Booger" later in the\n   * content.\n   * @param {RegExpMatchArray} match\n   * @param {{after:number}} param1\n   */\n  const hasClosingTag = (match, { after }) => {\n    const tag = "</" + match[0].slice(1);\n    const pos = match.input.indexOf(tag, after);\n    return pos !== -1;\n  };\n\n  const IDENT_RE$1 = IDENT_RE;\n  const FRAGMENT = {\n    begin: \'<>\',\n    end: \'</>\'\n  };\n  const XML_TAG = {\n    begin: /<[A-Za-z0-9\\\\._:-]+/,\n    end: /\\/[A-Za-z0-9\\\\._:-]+>|\\/>/,\n    /**\n     * @param {RegExpMatchArray} match\n     * @param {CallbackResponse} response\n     */\n    isTrulyOpeningTag: (match, response) => {\n      const afterMatchIndex = match[0].length + match.index;\n      const nextChar = match.input[afterMatchIndex];\n      // nested type?\n      // HTML should not include another raw `<` inside a tag\n      // But a type might: `<Array<Array<number>>`, etc.\n      if (nextChar === "<") {\n        response.ignoreMatch();\n        return;\n      }\n      // <something>\n      // This is now either a tag or a type.\n      if (nextChar === ">") {\n        // if we cannot find a matching closing tag, then we\n        // will ignore it\n        if (!hasClosingTag(match, { after: afterMatchIndex })) {\n          response.ignoreMatch();\n        }\n      }\n    }\n  };\n  const KEYWORDS$1 = {\n    $pattern: IDENT_RE,\n    keyword: KEYWORDS,\n    literal: LITERALS,\n    built_in: BUILT_INS,\n    "variable.language": BUILT_IN_VARIABLES\n  };\n\n  // https://tc39.es/ecma262/#sec-literals-numeric-literals\n  const decimalDigits = \'[0-9](_?[0-9])*\';\n  const frac = `\\\\.(${decimalDigits})`;\n  // DecimalIntegerLiteral, including Annex B NonOctalDecimalIntegerLiteral\n  // https://tc39.es/ecma262/#sec-additional-syntax-numeric-literals\n  const decimalInteger = `0|[1-9](_?[0-9])*|0[0-7]*[89][0-9]*`;\n  const NUMBER = {\n    className: \'number\',\n    variants: [\n      // DecimalLiteral\n      { begin: `(\\\\b(${decimalInteger})((${frac})|\\\\.)?|(${frac}))` +\n        `[eE][+-]?(${decimalDigits})\\\\b` },\n      { begin: `\\\\b(${decimalInteger})\\\\b((${frac})\\\\b|\\\\.)?|(${frac})\\\\b` },\n\n      // DecimalBigIntegerLiteral\n      { begin: `\\\\b(0|[1-9](_?[0-9])*)n\\\\b` },\n\n      // NonDecimalIntegerLiteral\n      { begin: "\\\\b0[xX][0-9a-fA-F](_?[0-9a-fA-F])*n?\\\\b" },\n      { begin: "\\\\b0[bB][0-1](_?[0-1])*n?\\\\b" },\n      { begin: "\\\\b0[oO][0-7](_?[0-7])*n?\\\\b" },\n\n      // LegacyOctalIntegerLiteral (does not include underscore separators)\n      // https://tc39.es/ecma262/#sec-additional-syntax-numeric-literals\n      { begin: "\\\\b0[0-7]+n?\\\\b" },\n    ],\n    relevance: 0\n  };\n\n  const SUBST = {\n    className: \'subst\',\n    begin: \'\\\\$\\\\{\',\n    end: \'\\\\}\',\n    keywords: KEYWORDS$1,\n    contains: [] // defined later\n  };\n  const HTML_TEMPLATE = {\n    begin: \'html`\',\n    end: \'\',\n    starts: {\n      end: \'`\',\n      returnEnd: false,\n      contains: [\n        hljs.BACKSLASH_ESCAPE,\n        SUBST\n      ],\n      subLanguage: \'xml\'\n    }\n  };\n  const CSS_TEMPLATE = {\n    begin: \'css`\',\n    end: \'\',\n    starts: {\n      end: \'`\',\n      returnEnd: false,\n      contains: [\n        hljs.BACKSLASH_ESCAPE,\n        SUBST\n      ],\n      subLanguage: \'css\'\n    }\n  };\n  const TEMPLATE_STRING = {\n    className: \'string\',\n    begin: \'`\',\n    end: \'`\',\n    contains: [\n      hljs.BACKSLASH_ESCAPE,\n      SUBST\n    ]\n  };\n  const JSDOC_COMMENT = hljs.COMMENT(\n    /\\/\\*\\*(?!\\/)/,\n    \'\\\\*/\',\n    {\n      relevance: 0,\n      contains: [\n        {\n          begin: \'(?=@[A-Za-z]+)\',\n          relevance: 0,\n          contains: [\n            {\n              className: \'doctag\',\n              begin: \'@[A-Za-z]+\'\n            },\n            {\n              className: \'type\',\n              begin: \'\\\\{\',\n              end: \'\\\\}\',\n              excludeEnd: true,\n              excludeBegin: true,\n              relevance: 0\n            },\n            {\n              className: \'variable\',\n              begin: IDENT_RE$1 + \'(?=\\\\s*(-)|$)\',\n              endsParent: true,\n              relevance: 0\n            },\n            // eat spaces (not newlines) so we can find\n            // types or variables\n            {\n              begin: /(?=[^\\n])\\s/,\n              relevance: 0\n            }\n          ]\n        }\n      ]\n    }\n  );\n  const COMMENT = {\n    className: "comment",\n    variants: [\n      JSDOC_COMMENT,\n      hljs.C_BLOCK_COMMENT_MODE,\n      hljs.C_LINE_COMMENT_MODE\n    ]\n  };\n  const SUBST_INTERNALS = [\n    hljs.APOS_STRING_MODE,\n    hljs.QUOTE_STRING_MODE,\n    HTML_TEMPLATE,\n    CSS_TEMPLATE,\n    TEMPLATE_STRING,\n    NUMBER,\n    hljs.REGEXP_MODE\n  ];\n  SUBST.contains = SUBST_INTERNALS\n    .concat({\n      // we need to pair up {} inside our subst to prevent\n      // it from ending too early by matching another }\n      begin: /\\{/,\n      end: /\\}/,\n      keywords: KEYWORDS$1,\n      contains: [\n        "self"\n      ].concat(SUBST_INTERNALS)\n    });\n  const SUBST_AND_COMMENTS = [].concat(COMMENT, SUBST.contains);\n  const PARAMS_CONTAINS = SUBST_AND_COMMENTS.concat([\n    // eat recursive parens in sub expressions\n    {\n      begin: /\\(/,\n      end: /\\)/,\n      keywords: KEYWORDS$1,\n      contains: ["self"].concat(SUBST_AND_COMMENTS)\n    }\n  ]);\n  const PARAMS = {\n    className: \'params\',\n    begin: /\\(/,\n    end: /\\)/,\n    excludeBegin: true,\n    excludeEnd: true,\n    keywords: KEYWORDS$1,\n    contains: PARAMS_CONTAINS\n  };\n\n  // ES6 classes\n  const CLASS_OR_EXTENDS = {\n    variants: [\n      {\n        match: [\n          /class/,\n          /\\s+/,\n          IDENT_RE$1\n        ],\n        scope: {\n          1: "keyword",\n          3: "title.class"\n        }\n      },\n      {\n        match: [\n          /extends/,\n          /\\s+/,\n          concat(IDENT_RE$1, "(", concat(/\\./, IDENT_RE$1), ")*")\n        ],\n        scope: {\n          1: "keyword",\n          3: "title.class.inherited"\n        }\n      }\n    ]\n  };\n\n  const CLASS_REFERENCE = {\n    relevance: 0,\n    match: /\\b[A-Z][a-z]+([A-Z][a-z]+)*/,\n    className: "title.class",\n    keywords: {\n      _: [\n        // se we still get relevance credit for JS library classes\n        ...TYPES,\n        ...ERROR_TYPES\n      ]\n    }\n  };\n\n  const USE_STRICT = {\n    label: "use_strict",\n    className: \'meta\',\n    relevance: 10,\n    begin: /^\\s*[\'"]use (strict|asm)[\'"]/\n  };\n\n  const FUNCTION_DEFINITION = {\n    variants: [\n      {\n        match: [\n          /function/,\n          /\\s+/,\n          IDENT_RE$1,\n          /(?=\\s*\\()/\n        ]\n      },\n      // anonymous function\n      {\n        match: [\n          /function/,\n          /\\s*(?=\\()/\n        ]\n      }\n    ],\n    className: {\n      1: "keyword",\n      3: "title.function"\n    },\n    label: "func.def",\n    contains: [ PARAMS ],\n    illegal: /%/\n  };\n\n  const UPPER_CASE_CONSTANT = {\n    relevance: 0,\n    match: /\\b[A-Z][A-Z_0-9]+\\b/,\n    className: "variable.constant"\n  };\n\n  function noneOf(list) {\n    return concat("(?!", list.join("|"), ")");\n  }\n\n  const FUNCTION_CALL = {\n    match: concat(\n      /\\b/,\n      noneOf([\n        ...BUILT_IN_GLOBALS,\n        "super"\n      ]),\n      IDENT_RE$1, lookahead(/\\(/)),\n    className: "title.function",\n    relevance: 0\n  };\n\n  const PROPERTY_ACCESS = {\n    begin: concat(/\\./, lookahead(\n      concat(IDENT_RE$1, /(?![0-9A-Za-z$_(])/)\n    )),\n    end: IDENT_RE$1,\n    excludeBegin: true,\n    keywords: "prototype",\n    className: "property",\n    relevance: 0\n  };\n\n  const GETTER_OR_SETTER = {\n    match: [\n      /get|set/,\n      /\\s+/,\n      IDENT_RE$1,\n      /(?=\\()/\n    ],\n    className: {\n      1: "keyword",\n      3: "title.function"\n    },\n    contains: [\n      { // eat to avoid empty params\n        begin: /\\(\\)/\n      },\n      PARAMS\n    ]\n  };\n\n  const FUNC_LEAD_IN_RE = \'(\\\\(\' +\n    \'[^()]*(\\\\(\' +\n    \'[^()]*(\\\\(\' +\n    \'[^()]*\' +\n    \'\\\\)[^()]*)*\' +\n    \'\\\\)[^()]*)*\' +\n    \'\\\\)|\' + hljs.UNDERSCORE_IDENT_RE + \')\\\\s*=>\';\n\n  const FUNCTION_VARIABLE = {\n    match: [\n      /const|var|let/, /\\s+/,\n      IDENT_RE$1, /\\s*/,\n      /=\\s*/,\n      lookahead(FUNC_LEAD_IN_RE)\n    ],\n    className: {\n      1: "keyword",\n      3: "title.function"\n    },\n    contains: [\n      PARAMS\n    ]\n  };\n\n  return {\n    name: \'Javascript\',\n    aliases: [\'js\', \'jsx\', \'mjs\', \'cjs\'],\n    keywords: KEYWORDS$1,\n    // this will be extended by TypeScript\n    exports: { PARAMS_CONTAINS },\n    illegal: /#(?![$_A-z])/,\n    contains: [\n      hljs.SHEBANG({\n        label: "shebang",\n        binary: "node",\n        relevance: 5\n      }),\n      USE_STRICT,\n      hljs.APOS_STRING_MODE,\n      hljs.QUOTE_STRING_MODE,\n      HTML_TEMPLATE,\n      CSS_TEMPLATE,\n      TEMPLATE_STRING,\n      COMMENT,\n      NUMBER,\n      CLASS_REFERENCE,\n      {\n        className: \'attr\',\n        begin: IDENT_RE$1 + lookahead(\':\'),\n        relevance: 0\n      },\n      FUNCTION_VARIABLE,\n      { // "value" container\n        begin: \'(\' + hljs.RE_STARTERS_RE + \'|\\\\b(case|return|throw)\\\\b)\\\\s*\',\n        keywords: \'return throw case\',\n        relevance: 0,\n        contains: [\n          COMMENT,\n          hljs.REGEXP_MODE,\n          {\n            className: \'function\',\n            // we have to count the parens to make sure we actually have the\n            // correct bounding ( ) before the =>.  There could be any number of\n            // sub-expressions inside also surrounded by parens.\n            begin: FUNC_LEAD_IN_RE,\n            returnBegin: true,\n            end: \'\\\\s*=>\',\n            contains: [\n              {\n                className: \'params\',\n                variants: [\n                  {\n                    begin: hljs.UNDERSCORE_IDENT_RE,\n                    relevance: 0\n                  },\n                  {\n                    className: null,\n                    begin: /\\(\\s*\\)/,\n                    skip: true\n                  },\n                  {\n                    begin: /\\(/,\n                    end: /\\)/,\n                    excludeBegin: true,\n                    excludeEnd: true,\n                    keywords: KEYWORDS$1,\n                    contains: PARAMS_CONTAINS\n                  }\n                ]\n              }\n            ]\n          },\n          { // could be a comma delimited list of params to a function call\n            begin: /,/,\n            relevance: 0\n          },\n          {\n            match: /\\s+/,\n            relevance: 0\n          },\n          { // JSX\n            variants: [\n              { begin: FRAGMENT.begin, end: FRAGMENT.end },\n              {\n                begin: XML_TAG.begin,\n                // we carefully check the opening tag to see if it truly\n                // is a tag and not a false positive\n                \'on:begin\': XML_TAG.isTrulyOpeningTag,\n                end: XML_TAG.end\n              }\n            ],\n            subLanguage: \'xml\',\n            contains: [\n              {\n                begin: XML_TAG.begin,\n                end: XML_TAG.end,\n                skip: true,\n                contains: [\'self\']\n              }\n            ]\n          }\n        ],\n      },\n      FUNCTION_DEFINITION,\n      {\n        // prevent this from getting swallowed up by function\n        // since they appear "function like"\n        beginKeywords: "while if switch catch for"\n      },\n      {\n        // we have to count the parens to make sure we actually have the correct\n        // bounding ( ).  There could be any number of sub-expressions inside\n        // also surrounded by parens.\n        begin: \'\\\\b(?!function)\' + hljs.UNDERSCORE_IDENT_RE +\n          \'\\\\(\' + // first parens\n          \'[^()]*(\\\\(\' +\n            \'[^()]*(\\\\(\' +\n              \'[^()]*\' +\n            \'\\\\)[^()]*)*\' +\n          \'\\\\)[^()]*)*\' +\n          \'\\\\)\\\\s*\\\\{\', // end parens\n        returnBegin:true,\n        label: "func.def",\n        contains: [\n          PARAMS,\n          hljs.inherit(hljs.TITLE_MODE, { begin: IDENT_RE$1, className: "title.function" })\n        ]\n      },\n      // catch ... so it won\'t trigger the property rule below\n      {\n        match: /\\.\\.\\./,\n        relevance: 0\n      },\n      PROPERTY_ACCESS,\n      // hack: prevents detection of keywords in some circumstances\n      // .keyword()\n      // $keyword = x\n      {\n        match: \'\\\\$\' + IDENT_RE$1,\n        relevance: 0\n      },\n      {\n        match: [ /\\bconstructor(?=\\s*\\()/ ],\n        className: { 1: "title.function" },\n        contains: [ PARAMS ]\n      },\n      FUNCTION_CALL,\n      UPPER_CASE_CONSTANT,\n      CLASS_OR_EXTENDS,\n      GETTER_OR_SETTER,\n      {\n        match: /\\$[(.]/ // relevance booster for a pattern common to JS libs: `$(something)` and `$.something`\n      }\n    ]\n  };\n}\n\n/* harmony default export */ const languages_javascript = (javascript);\n\n;// CONCATENATED MODULE: ./node_modules/highlight.js/es/languages/scss.js\nconst MODES = (hljs) => {\n  return {\n    IMPORTANT: {\n      scope: \'meta\',\n      begin: \'!important\'\n    },\n    HEXCOLOR: {\n      scope: \'number\',\n      begin: \'#([a-fA-F0-9]{6}|[a-fA-F0-9]{3})\'\n    },\n    ATTRIBUTE_SELECTOR_MODE: {\n      scope: \'selector-attr\',\n      begin: /\\[/,\n      end: /\\]/,\n      illegal: \'$\',\n      contains: [\n        hljs.APOS_STRING_MODE,\n        hljs.QUOTE_STRING_MODE\n      ]\n    },\n    CSS_NUMBER_MODE: {\n      scope: \'number\',\n      begin: hljs.NUMBER_RE + \'(\' +\n        \'%|em|ex|ch|rem\' +\n        \'|vw|vh|vmin|vmax\' +\n        \'|cm|mm|in|pt|pc|px\' +\n        \'|deg|grad|rad|turn\' +\n        \'|s|ms\' +\n        \'|Hz|kHz\' +\n        \'|dpi|dpcm|dppx\' +\n        \')?\',\n      relevance: 0\n    },\n    CSS_VARIABLE: {\n      className: "attr",\n      begin: /--[A-Za-z][A-Za-z0-9_-]*/\n    }\n  };\n};\n\nconst TAGS = [\n  \'a\',\n  \'abbr\',\n  \'address\',\n  \'article\',\n  \'aside\',\n  \'audio\',\n  \'b\',\n  \'blockquote\',\n  \'body\',\n  \'button\',\n  \'canvas\',\n  \'caption\',\n  \'cite\',\n  \'code\',\n  \'dd\',\n  \'del\',\n  \'details\',\n  \'dfn\',\n  \'div\',\n  \'dl\',\n  \'dt\',\n  \'em\',\n  \'fieldset\',\n  \'figcaption\',\n  \'figure\',\n  \'footer\',\n  \'form\',\n  \'h1\',\n  \'h2\',\n  \'h3\',\n  \'h4\',\n  \'h5\',\n  \'h6\',\n  \'header\',\n  \'hgroup\',\n  \'html\',\n  \'i\',\n  \'iframe\',\n  \'img\',\n  \'input\',\n  \'ins\',\n  \'kbd\',\n  \'label\',\n  \'legend\',\n  \'li\',\n  \'main\',\n  \'mark\',\n  \'menu\',\n  \'nav\',\n  \'object\',\n  \'ol\',\n  \'p\',\n  \'q\',\n  \'quote\',\n  \'samp\',\n  \'section\',\n  \'span\',\n  \'strong\',\n  \'summary\',\n  \'sup\',\n  \'table\',\n  \'tbody\',\n  \'td\',\n  \'textarea\',\n  \'tfoot\',\n  \'th\',\n  \'thead\',\n  \'time\',\n  \'tr\',\n  \'ul\',\n  \'var\',\n  \'video\'\n];\n\nconst MEDIA_FEATURES = [\n  \'any-hover\',\n  \'any-pointer\',\n  \'aspect-ratio\',\n  \'color\',\n  \'color-gamut\',\n  \'color-index\',\n  \'device-aspect-ratio\',\n  \'device-height\',\n  \'device-width\',\n  \'display-mode\',\n  \'forced-colors\',\n  \'grid\',\n  \'height\',\n  \'hover\',\n  \'inverted-colors\',\n  \'monochrome\',\n  \'orientation\',\n  \'overflow-block\',\n  \'overflow-inline\',\n  \'pointer\',\n  \'prefers-color-scheme\',\n  \'prefers-contrast\',\n  \'prefers-reduced-motion\',\n  \'prefers-reduced-transparency\',\n  \'resolution\',\n  \'scan\',\n  \'scripting\',\n  \'update\',\n  \'width\',\n  // TODO: find a better solution?\n  \'min-width\',\n  \'max-width\',\n  \'min-height\',\n  \'max-height\'\n];\n\n// https://developer.mozilla.org/en-US/docs/Web/CSS/Pseudo-classes\nconst PSEUDO_CLASSES = [\n  \'active\',\n  \'any-link\',\n  \'blank\',\n  \'checked\',\n  \'current\',\n  \'default\',\n  \'defined\',\n  \'dir\', // dir()\n  \'disabled\',\n  \'drop\',\n  \'empty\',\n  \'enabled\',\n  \'first\',\n  \'first-child\',\n  \'first-of-type\',\n  \'fullscreen\',\n  \'future\',\n  \'focus\',\n  \'focus-visible\',\n  \'focus-within\',\n  \'has\', // has()\n  \'host\', // host or host()\n  \'host-context\', // host-context()\n  \'hover\',\n  \'indeterminate\',\n  \'in-range\',\n  \'invalid\',\n  \'is\', // is()\n  \'lang\', // lang()\n  \'last-child\',\n  \'last-of-type\',\n  \'left\',\n  \'link\',\n  \'local-link\',\n  \'not\', // not()\n  \'nth-child\', // nth-child()\n  \'nth-col\', // nth-col()\n  \'nth-last-child\', // nth-last-child()\n  \'nth-last-col\', // nth-last-col()\n  \'nth-last-of-type\', //nth-last-of-type()\n  \'nth-of-type\', //nth-of-type()\n  \'only-child\',\n  \'only-of-type\',\n  \'optional\',\n  \'out-of-range\',\n  \'past\',\n  \'placeholder-shown\',\n  \'read-only\',\n  \'read-write\',\n  \'required\',\n  \'right\',\n  \'root\',\n  \'scope\',\n  \'target\',\n  \'target-within\',\n  \'user-invalid\',\n  \'valid\',\n  \'visited\',\n  \'where\' // where()\n];\n\n// https://developer.mozilla.org/en-US/docs/Web/CSS/Pseudo-elements\nconst PSEUDO_ELEMENTS = [\n  \'after\',\n  \'backdrop\',\n  \'before\',\n  \'cue\',\n  \'cue-region\',\n  \'first-letter\',\n  \'first-line\',\n  \'grammar-error\',\n  \'marker\',\n  \'part\',\n  \'placeholder\',\n  \'selection\',\n  \'slotted\',\n  \'spelling-error\'\n];\n\nconst ATTRIBUTES = [\n  \'align-content\',\n  \'align-items\',\n  \'align-self\',\n  \'animation\',\n  \'animation-delay\',\n  \'animation-direction\',\n  \'animation-duration\',\n  \'animation-fill-mode\',\n  \'animation-iteration-count\',\n  \'animation-name\',\n  \'animation-play-state\',\n  \'animation-timing-function\',\n  \'auto\',\n  \'backface-visibility\',\n  \'background\',\n  \'background-attachment\',\n  \'background-clip\',\n  \'background-color\',\n  \'background-image\',\n  \'background-origin\',\n  \'background-position\',\n  \'background-repeat\',\n  \'background-size\',\n  \'border\',\n  \'border-bottom\',\n  \'border-bottom-color\',\n  \'border-bottom-left-radius\',\n  \'border-bottom-right-radius\',\n  \'border-bottom-style\',\n  \'border-bottom-width\',\n  \'border-collapse\',\n  \'border-color\',\n  \'border-image\',\n  \'border-image-outset\',\n  \'border-image-repeat\',\n  \'border-image-slice\',\n  \'border-image-source\',\n  \'border-image-width\',\n  \'border-left\',\n  \'border-left-color\',\n  \'border-left-style\',\n  \'border-left-width\',\n  \'border-radius\',\n  \'border-right\',\n  \'border-right-color\',\n  \'border-right-style\',\n  \'border-right-width\',\n  \'border-spacing\',\n  \'border-style\',\n  \'border-top\',\n  \'border-top-color\',\n  \'border-top-left-radius\',\n  \'border-top-right-radius\',\n  \'border-top-style\',\n  \'border-top-width\',\n  \'border-width\',\n  \'bottom\',\n  \'box-decoration-break\',\n  \'box-shadow\',\n  \'box-sizing\',\n  \'break-after\',\n  \'break-before\',\n  \'break-inside\',\n  \'caption-side\',\n  \'clear\',\n  \'clip\',\n  \'clip-path\',\n  \'color\',\n  \'column-count\',\n  \'column-fill\',\n  \'column-gap\',\n  \'column-rule\',\n  \'column-rule-color\',\n  \'column-rule-style\',\n  \'column-rule-width\',\n  \'column-span\',\n  \'column-width\',\n  \'columns\',\n  \'content\',\n  \'counter-increment\',\n  \'counter-reset\',\n  \'cursor\',\n  \'direction\',\n  \'display\',\n  \'empty-cells\',\n  \'filter\',\n  \'flex\',\n  \'flex-basis\',\n  \'flex-direction\',\n  \'flex-flow\',\n  \'flex-grow\',\n  \'flex-shrink\',\n  \'flex-wrap\',\n  \'float\',\n  \'font\',\n  \'font-display\',\n  \'font-family\',\n  \'font-feature-settings\',\n  \'font-kerning\',\n  \'font-language-override\',\n  \'font-size\',\n  \'font-size-adjust\',\n  \'font-smoothing\',\n  \'font-stretch\',\n  \'font-style\',\n  \'font-variant\',\n  \'font-variant-ligatures\',\n  \'font-variation-settings\',\n  \'font-weight\',\n  \'height\',\n  \'hyphens\',\n  \'icon\',\n  \'image-orientation\',\n  \'image-rendering\',\n  \'image-resolution\',\n  \'ime-mode\',\n  \'inherit\',\n  \'initial\',\n  \'justify-content\',\n  \'left\',\n  \'letter-spacing\',\n  \'line-height\',\n  \'list-style\',\n  \'list-style-image\',\n  \'list-style-position\',\n  \'list-style-type\',\n  \'margin\',\n  \'margin-bottom\',\n  \'margin-left\',\n  \'margin-right\',\n  \'margin-top\',\n  \'marks\',\n  \'mask\',\n  \'max-height\',\n  \'max-width\',\n  \'min-height\',\n  \'min-width\',\n  \'nav-down\',\n  \'nav-index\',\n  \'nav-left\',\n  \'nav-right\',\n  \'nav-up\',\n  \'none\',\n  \'normal\',\n  \'object-fit\',\n  \'object-position\',\n  \'opacity\',\n  \'order\',\n  \'orphans\',\n  \'outline\',\n  \'outline-color\',\n  \'outline-offset\',\n  \'outline-style\',\n  \'outline-width\',\n  \'overflow\',\n  \'overflow-wrap\',\n  \'overflow-x\',\n  \'overflow-y\',\n  \'padding\',\n  \'padding-bottom\',\n  \'padding-left\',\n  \'padding-right\',\n  \'padding-top\',\n  \'page-break-after\',\n  \'page-break-before\',\n  \'page-break-inside\',\n  \'perspective\',\n  \'perspective-origin\',\n  \'pointer-events\',\n  \'position\',\n  \'quotes\',\n  \'resize\',\n  \'right\',\n  \'src\', // @font-face\n  \'tab-size\',\n  \'table-layout\',\n  \'text-align\',\n  \'text-align-last\',\n  \'text-decoration\',\n  \'text-decoration-color\',\n  \'text-decoration-line\',\n  \'text-decoration-style\',\n  \'text-indent\',\n  \'text-overflow\',\n  \'text-rendering\',\n  \'text-shadow\',\n  \'text-transform\',\n  \'text-underline-position\',\n  \'top\',\n  \'transform\',\n  \'transform-origin\',\n  \'transform-style\',\n  \'transition\',\n  \'transition-delay\',\n  \'transition-duration\',\n  \'transition-property\',\n  \'transition-timing-function\',\n  \'unicode-bidi\',\n  \'vertical-align\',\n  \'visibility\',\n  \'white-space\',\n  \'widows\',\n  \'width\',\n  \'word-break\',\n  \'word-spacing\',\n  \'word-wrap\',\n  \'z-index\'\n  // reverse makes sure longer attributes `font-weight` are matched fully\n  // instead of getting false positives on say `font`\n].reverse();\n\n/*\nLanguage: SCSS\nDescription: Scss is an extension of the syntax of CSS.\nAuthor: Kurt Emch <kurt@kurtemch.com>\nWebsite: https://sass-lang.com\nCategory: common, css, web\n*/\n\n/** @type LanguageFn */\nfunction scss(hljs) {\n  const modes = MODES(hljs);\n  const PSEUDO_ELEMENTS$1 = PSEUDO_ELEMENTS;\n  const PSEUDO_CLASSES$1 = PSEUDO_CLASSES;\n\n  const AT_IDENTIFIER = \'@[a-z-]+\'; // @font-face\n  const AT_MODIFIERS = "and or not only";\n  const IDENT_RE = \'[a-zA-Z-][a-zA-Z0-9_-]*\';\n  const VARIABLE = {\n    className: \'variable\',\n    begin: \'(\\\\$\' + IDENT_RE + \')\\\\b\'\n  };\n\n  return {\n    name: \'SCSS\',\n    case_insensitive: true,\n    illegal: \'[=/|\\\']\',\n    contains: [\n      hljs.C_LINE_COMMENT_MODE,\n      hljs.C_BLOCK_COMMENT_MODE,\n      {\n        className: \'selector-id\',\n        begin: \'#[A-Za-z0-9_-]+\',\n        relevance: 0\n      },\n      {\n        className: \'selector-class\',\n        begin: \'\\\\.[A-Za-z0-9_-]+\',\n        relevance: 0\n      },\n      modes.ATTRIBUTE_SELECTOR_MODE,\n      {\n        className: \'selector-tag\',\n        begin: \'\\\\b(\' + TAGS.join(\'|\') + \')\\\\b\',\n        // was there, before, but why?\n        relevance: 0\n      },\n      {\n        className: \'selector-pseudo\',\n        begin: \':(\' + PSEUDO_CLASSES$1.join(\'|\') + \')\'\n      },\n      {\n        className: \'selector-pseudo\',\n        begin: \'::(\' + PSEUDO_ELEMENTS$1.join(\'|\') + \')\'\n      },\n      VARIABLE,\n      { // pseudo-selector params\n        begin: /\\(/,\n        end: /\\)/,\n        contains: [ modes.CSS_NUMBER_MODE ]\n      },\n      modes.CSS_VARIABLE,\n      {\n        className: \'attribute\',\n        begin: \'\\\\b(\' + ATTRIBUTES.join(\'|\') + \')\\\\b\'\n      },\n      {\n        begin: \'\\\\b(whitespace|wait|w-resize|visible|vertical-text|vertical-ideographic|uppercase|upper-roman|upper-alpha|underline|transparent|top|thin|thick|text|text-top|text-bottom|tb-rl|table-header-group|table-footer-group|sw-resize|super|strict|static|square|solid|small-caps|separate|se-resize|scroll|s-resize|rtl|row-resize|ridge|right|repeat|repeat-y|repeat-x|relative|progress|pointer|overline|outside|outset|oblique|nowrap|not-allowed|normal|none|nw-resize|no-repeat|no-drop|newspaper|ne-resize|n-resize|move|middle|medium|ltr|lr-tb|lowercase|lower-roman|lower-alpha|loose|list-item|line|line-through|line-edge|lighter|left|keep-all|justify|italic|inter-word|inter-ideograph|inside|inset|inline|inline-block|inherit|inactive|ideograph-space|ideograph-parenthesis|ideograph-numeric|ideograph-alpha|horizontal|hidden|help|hand|groove|fixed|ellipsis|e-resize|double|dotted|distribute|distribute-space|distribute-letter|distribute-all-lines|disc|disabled|default|decimal|dashed|crosshair|collapse|col-resize|circle|char|center|capitalize|break-word|break-all|bottom|both|bolder|bold|block|bidi-override|below|baseline|auto|always|all-scroll|absolute|table|table-cell)\\\\b\'\n      },\n      {\n        begin: \':\',\n        end: \';\',\n        contains: [\n          VARIABLE,\n          modes.HEXCOLOR,\n          modes.CSS_NUMBER_MODE,\n          hljs.QUOTE_STRING_MODE,\n          hljs.APOS_STRING_MODE,\n          modes.IMPORTANT\n        ]\n      },\n      // matching these here allows us to treat them more like regular CSS\n      // rules so everything between the {} gets regular rule highlighting,\n      // which is what we want for page and font-face\n      {\n        begin: \'@(page|font-face)\',\n        keywords: {\n          $pattern: AT_IDENTIFIER,\n          keyword: \'@page @font-face\'\n        }\n      },\n      {\n        begin: \'@\',\n        end: \'[{;]\',\n        returnBegin: true,\n        keywords: {\n          $pattern: /[a-z-]+/,\n          keyword: AT_MODIFIERS,\n          attribute: MEDIA_FEATURES.join(" ")\n        },\n        contains: [\n          {\n            begin: AT_IDENTIFIER,\n            className: "keyword"\n          },\n          {\n            begin: /[a-z-]+(?=:)/,\n            className: "attribute"\n          },\n          VARIABLE,\n          hljs.QUOTE_STRING_MODE,\n          hljs.APOS_STRING_MODE,\n          modes.HEXCOLOR,\n          modes.CSS_NUMBER_MODE\n        ]\n      }\n    ]\n  };\n}\n\n/* harmony default export */ const languages_scss = (scss);\n\n;// CONCATENATED MODULE: ./node_modules/highlight.js/es/languages/shell.js\n/*\nLanguage: Shell Session\nRequires: bash.js\nAuthor: TSUYUSATO Kitsune <make.just.on@gmail.com>\nCategory: common\nAudit: 2020\n*/\n\n/** @type LanguageFn */\nfunction shell(hljs) {\n  return {\n    name: \'Shell Session\',\n    aliases: [ \'console\', \'shellsession\' ],\n    contains: [\n      {\n        className: \'meta\',\n        // We cannot add \\s (spaces) in the regular expression otherwise it will be too broad and produce unexpected result.\n        // For instance, in the following example, it would match "echo /path/to/home >" as a prompt:\n        // echo /path/to/home > t.exe\n        begin: /^\\s{0,3}[/~\\w\\d[\\]()@-]*[>%$#][ ]?/,\n        starts: {\n          end: /[^\\\\](?=\\s*$)/,\n          subLanguage: \'bash\'\n        }\n      }\n    ]\n  };\n}\n\n/* harmony default export */ const languages_shell = (shell);\n\n;// CONCATENATED MODULE: ./node_modules/highlight.js/es/languages/plaintext.js\n/*\nLanguage: Plain text\nAuthor: Egor Rogov (e.rogov@postgrespro.ru)\nDescription: Plain text without any highlighting.\nCategory: common\n*/\n\nfunction plaintext(hljs) {\n  return {\n    name: \'Plain text\',\n    aliases: [\n      \'text\',\n      \'txt\'\n    ],\n    disableAutodetect: true\n  };\n}\n\n/* harmony default export */ const languages_plaintext = (plaintext);\n\n;// CONCATENATED MODULE: ./docs/src/utils/markdown.js\n\n\n\n\n\n\n\nes_core.registerLanguage(\'javascript\', languages_javascript);\n\nes_core.registerLanguage(\'scss\', languages_scss);\n\nes_core.registerLanguage(\'shell\', languages_shell);\n\nes_core.registerLanguage(\'plaintext\', languages_plaintext);\n\nmarked_default().setOptions({\n  highlight: function highlight(code, lang) {\n    var language = es_core.getLanguage(lang) ? lang : \'plaintext\';\n    return es_core.highlight(code, {\n      language: language\n    }).value;\n  },\n  langPrefix: \'hljs language-\'\n});\n/* harmony default export */ const markdown = ((marked_default()));\n// EXTERNAL MODULE: ./README.md\nvar README = __webpack_require__(996);\n;// CONCATENATED MODULE: ./docs/src/pages/Home/index.jsx\n\n\n\n\n\nvar html = markdown(README);\nfunction HomePage() {\n  return /*#__PURE__*/(0,jsx_runtime.jsx)(Page, {\n    id: "home",\n    children: /*#__PURE__*/(0,jsx_runtime.jsx)("article", {\n      className: "markdown",\n      dangerouslySetInnerHTML: {\n        __html: html\n      }\n    })\n  });\n}\n;// CONCATENATED MODULE: ./docs/src/pages/IconButton/index.jsx\nfunction IconButton_slicedToArray(arr, i) { return IconButton_arrayWithHoles(arr) || IconButton_iterableToArrayLimit(arr, i) || IconButton_unsupportedIterableToArray(arr, i) || IconButton_nonIterableRest(); }\n\nfunction IconButton_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction IconButton_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return IconButton_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return IconButton_arrayLikeToArray(o, minLen); }\n\nfunction IconButton_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction IconButton_iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction IconButton_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\n\n\n\n\n\n\n\nvar IconButton_id = \'icon-button\';\nvar IconButton_title = \'Icon Button\';\nvar IconButton_description = \'Icon buttons allow users to take actions, and make choices, with a single tap.\';\nvar IconButton_links = {\n  docs: \'https://github.com/material-components/material-components-web/tree/master/packages/mdc-icon-button\',\n  guide: \'https://material.io/components/buttons\'\n};\nfunction IconButtonPage() {\n  var _useState = (0,react.useState)(true),\n      _useState2 = IconButton_slicedToArray(_useState, 2),\n      isOn = _useState2[0],\n      setOn = _useState2[1];\n\n  return /*#__PURE__*/(0,jsx_runtime.jsxs)(Page, {\n    id: IconButton_id,\n    title: IconButton_title,\n    description: IconButton_description,\n    links: IconButton_links,\n    children: [/*#__PURE__*/(0,jsx_runtime.jsx)(Section, {\n      title: "Basic icon button",\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(Code, {\n        children: /*#__PURE__*/(0,jsx_runtime.jsx)(icon_button_IconButton, {\n          icon: "star"\n        })\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Section, {\n      title: "Toggling icon button",\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(Code, {\n        children: /*#__PURE__*/(0,jsx_runtime.jsx)(icon_button_IconButton, {\n          icon: isOn ? \'favorite\' : \'favorite_border\',\n          onClick: function onClick() {\n            return setOn(function (v) {\n              return !v;\n            });\n          }\n        })\n      })\n    })]\n  });\n}\n;// CONCATENATED MODULE: ./docs/src/pages/ImageList/index.jsx\nfunction pages_ImageList_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction pages_ImageList_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { pages_ImageList_ownKeys(Object(source), true).forEach(function (key) { pages_ImageList_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { pages_ImageList_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction pages_ImageList_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n\nvar ImageList_id = \'image-list\';\nvar ImageList_title = \'Image List\';\nvar ImageList_description = \'Image lists display a collection of images in an organized grid.\';\nvar ImageList_links = {\n  docs: \'https://github.com/material-components/material-components-web/tree/master/packages/mdc-image-list\',\n  guide: \'https://material.io/components/image-lists\'\n};\n\n\n\n\n\n\nvar standardItems = new Array(15).fill(1).map(function () {\n  return {\n    imageSrc: \'https://placeimg.com/360/360/any\',\n    label: \'Text Label\'\n  };\n});\nvar masonryItems = new Array(15).fill(1).map(function () {\n  return {\n    imageSrc: "https://placeimg.com/".concat(Math.random() > 0.5 ? \'480/360\' : \'360/480\', "/any"),\n    label: \'Text Label\'\n  };\n});\nfunction ImageListPage() {\n  return /*#__PURE__*/(0,jsx_runtime.jsxs)(Page, {\n    id: ImageList_id,\n    title: ImageList_title,\n    description: ImageList_description,\n    links: ImageList_links,\n    children: [/*#__PURE__*/(0,jsx_runtime.jsx)(Section, {\n      id: "standard-image-list",\n      title: "Standard Image List",\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(Code, {\n        children: /*#__PURE__*/(0,jsx_runtime.jsx)(image_list_ImageList, {\n          children: standardItems.map(function (item, index) {\n            return /*#__PURE__*/(0,jsx_runtime.jsx)(image_list_ImageList.Item, pages_ImageList_objectSpread({}, item), index);\n          })\n        })\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Section, {\n      id: "standard-image-list",\n      title: "Standard Image List with Text Protection",\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(Code, {\n        children: /*#__PURE__*/(0,jsx_runtime.jsx)(image_list_ImageList, {\n          withTextProtection: true,\n          children: standardItems.map(function (item, index) {\n            return /*#__PURE__*/(0,jsx_runtime.jsx)(image_list_ImageList.Item, pages_ImageList_objectSpread({}, item), index);\n          })\n        })\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Section, {\n      id: "masonry-image-list",\n      title: "Masonry Image Lis",\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(Code, {\n        children: /*#__PURE__*/(0,jsx_runtime.jsx)(image_list_ImageList, {\n          masonry: true,\n          children: masonryItems.map(function (item, index) {\n            return /*#__PURE__*/(0,jsx_runtime.jsx)(image_list_ImageList.Item, pages_ImageList_objectSpread({}, item), index);\n          })\n        })\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Section, {\n      id: "masonry-image-list",\n      title: "Masonry Image List with Text Protection",\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(Code, {\n        children: /*#__PURE__*/(0,jsx_runtime.jsx)(image_list_ImageList, {\n          masonry: true,\n          withTextProtection: true,\n          children: masonryItems.map(function (item, index) {\n            return /*#__PURE__*/(0,jsx_runtime.jsx)(image_list_ImageList.Item, pages_ImageList_objectSpread({}, item), index);\n          })\n        })\n      })\n    })]\n  });\n}\n;// CONCATENATED MODULE: ./docs/src/pages/LayoutGrid/index.jsx\n\n\n\n\n\n\n\nvar LayoutGrid_id = \'layout-grid\';\nvar LayoutGrid_title = \'Layout Grid\';\nvar LayoutGrid_description = \'Material designs responsive UI is based on a 12-column grid layout.\';\nvar LayoutGrid_links = {\n  docs: \'https://github.com/material-components/material-components-web/tree/master/packages/mdc-layout-grid\',\n  guide: \'https://material.io/design/layout/responsive-layout-grid.html\'\n};\nfunction LayoutGridPage() {\n  return /*#__PURE__*/(0,jsx_runtime.jsxs)(Page, {\n    id: LayoutGrid_id,\n    title: LayoutGrid_title,\n    description: LayoutGrid_description,\n    links: LayoutGrid_links,\n    children: [/*#__PURE__*/(0,jsx_runtime.jsx)(Section, {\n      title: "Basic grid",\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(Code, {\n        children: /*#__PURE__*/(0,jsx_runtime.jsxs)(layout_grid_LayoutGrid, {\n          children: [/*#__PURE__*/(0,jsx_runtime.jsx)(layout_grid_LayoutGrid.Cell, {\n            span: "6"\n          }), /*#__PURE__*/(0,jsx_runtime.jsx)(layout_grid_LayoutGrid.Cell, {\n            span: "3"\n          }), /*#__PURE__*/(0,jsx_runtime.jsx)(layout_grid_LayoutGrid.Cell, {\n            span: "2"\n          }), /*#__PURE__*/(0,jsx_runtime.jsx)(layout_grid_LayoutGrid.Cell, {\n            span: "1"\n          }), /*#__PURE__*/(0,jsx_runtime.jsx)(layout_grid_LayoutGrid.Cell, {\n            span: "3"\n          }), /*#__PURE__*/(0,jsx_runtime.jsx)(layout_grid_LayoutGrid.Cell, {\n            span: "1"\n          }), /*#__PURE__*/(0,jsx_runtime.jsx)(layout_grid_LayoutGrid.Cell, {\n            span: "8"\n          })]\n        })\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Section, {\n      title: "Nested grid",\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(Code, {\n        children: /*#__PURE__*/(0,jsx_runtime.jsxs)(layout_grid_LayoutGrid, {\n          children: [/*#__PURE__*/(0,jsx_runtime.jsxs)(layout_grid_LayoutGrid.Cell, {\n            grid: true,\n            children: [/*#__PURE__*/(0,jsx_runtime.jsx)(layout_grid_LayoutGrid.Cell, {}), /*#__PURE__*/(0,jsx_runtime.jsx)(layout_grid_LayoutGrid.Cell, {}), /*#__PURE__*/(0,jsx_runtime.jsx)(layout_grid_LayoutGrid.Cell, {})]\n          }), /*#__PURE__*/(0,jsx_runtime.jsx)(layout_grid_LayoutGrid.Cell, {}), /*#__PURE__*/(0,jsx_runtime.jsx)(layout_grid_LayoutGrid.Cell, {})]\n        })\n      })\n    })]\n  });\n}\n;// CONCATENATED MODULE: ./docs/src/pages/LinearProgress/index.jsx\nfunction LinearProgress_slicedToArray(arr, i) { return LinearProgress_arrayWithHoles(arr) || LinearProgress_iterableToArrayLimit(arr, i) || LinearProgress_unsupportedIterableToArray(arr, i) || LinearProgress_nonIterableRest(); }\n\nfunction LinearProgress_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction LinearProgress_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return LinearProgress_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return LinearProgress_arrayLikeToArray(o, minLen); }\n\nfunction LinearProgress_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction LinearProgress_iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction LinearProgress_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\n\n\n\n\n\n\n\nvar LinearProgress_id = \'linear-progress\';\nvar LinearProgress_title = \'Linear Progress\';\nvar LinearProgress_description = \'Progress indicators display the length of a process or express an unspecified wait time.\';\nvar LinearProgress_links = {\n  docs: \'\',\n  guide: \'\'\n};\nfunction LinearProgressPage() {\n  var _useState = (0,react.useState)(true),\n      _useState2 = LinearProgress_slicedToArray(_useState, 2),\n      isClosed = _useState2[0],\n      setClosed = _useState2[1];\n\n  return /*#__PURE__*/(0,jsx_runtime.jsxs)(Page, {\n    id: LinearProgress_id,\n    title: LinearProgress_title,\n    description: LinearProgress_description,\n    links: LinearProgress_links,\n    children: [/*#__PURE__*/(0,jsx_runtime.jsx)(Section, {\n      title: "Basic linear progress",\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(Code, {\n        children: /*#__PURE__*/(0,jsx_runtime.jsx)(linear_progress_LinearProgress, {\n          value: "42"\n        })\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Section, {\n      title: "Linear progress with a buffer",\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(Code, {\n        children: /*#__PURE__*/(0,jsx_runtime.jsx)(linear_progress_LinearProgress, {\n          value: "42",\n          buffer: "84"\n        })\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Section, {\n      title: "Indeterminate linear progress",\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(Code, {\n        children: /*#__PURE__*/(0,jsx_runtime.jsx)(linear_progress_LinearProgress, {\n          indeterminate: true\n        })\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Section, {\n      title: "Closed linear progress",\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(Code, {\n        setup: /*#__PURE__*/(0,jsx_runtime.jsx)(button_Button, {\n          onClick: function onClick() {\n            return setClosed(function (v) {\n              return !v;\n            });\n          },\n          children: "Toggle"\n        }),\n        children: /*#__PURE__*/(0,jsx_runtime.jsx)(linear_progress_LinearProgress, {\n          closed: isClosed,\n          value: "42"\n        })\n      })\n    })]\n  });\n}\n;// CONCATENATED MODULE: ./docs/src/pages/List/index.jsx\n\n\n\n\n\n\nvar List_id = \'list\';\nvar List_title = \'List\';\nvar List_description = \'Lists present multiple line items vertically as a single continuous element.\';\nvar List_links = {\n  docs: \'https://github.com/material-components/material-components-web/tree/master/packages/mdc-list\',\n  guide: \'https://material.io/components/lists\'\n};\nfunction ListPage() {\n  return /*#__PURE__*/(0,jsx_runtime.jsxs)(Page, {\n    id: List_id,\n    title: List_title,\n    description: List_description,\n    links: List_links,\n    children: [/*#__PURE__*/(0,jsx_runtime.jsx)(Section, {\n      title: "Single-line list",\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(Code, {\n        children: /*#__PURE__*/(0,jsx_runtime.jsxs)(list_List, {\n          children: [/*#__PURE__*/(0,jsx_runtime.jsx)(list_ListItem, {\n            text: "Item 1"\n          }), /*#__PURE__*/(0,jsx_runtime.jsx)(list_ListItem, {\n            text: "Item 2"\n          }), /*#__PURE__*/(0,jsx_runtime.jsx)(list_ListItem, {\n            text: "Item 3"\n          })]\n        })\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsxs)(Section, {\n      title: "Two-line list",\n      children: [/*#__PURE__*/(0,jsx_runtime.jsx)(Code, {\n        children: /*#__PURE__*/(0,jsx_runtime.jsxs)(list_List, {\n          children: [/*#__PURE__*/(0,jsx_runtime.jsx)(list_ListItem, {\n            primaryText: "Item 1",\n            secondaryText: "Secondary text"\n          }), /*#__PURE__*/(0,jsx_runtime.jsx)(list_ListItem, {\n            primaryText: "Item 2",\n            secondaryText: "Secondary text"\n          }), /*#__PURE__*/(0,jsx_runtime.jsx)(list_ListItem, {\n            primaryText: "Item 3",\n            secondaryText: "Secondary text"\n          })]\n        })\n      }), /*#__PURE__*/(0,jsx_runtime.jsx)(Code, {\n        children: /*#__PURE__*/(0,jsx_runtime.jsxs)(list_List, {\n          children: [/*#__PURE__*/(0,jsx_runtime.jsx)(list_ListItem, {\n            overlineText: "Overline",\n            primaryText: "Item 1"\n          }), /*#__PURE__*/(0,jsx_runtime.jsx)(list_ListItem, {\n            overlineText: "Overline",\n            primaryText: "Item 2"\n          }), /*#__PURE__*/(0,jsx_runtime.jsx)(list_ListItem, {\n            overlineText: "Overline",\n            primaryText: "Item 3"\n          })]\n        })\n      })]\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Section, {\n      title: "Three-line list",\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(Code, {\n        children: /*#__PURE__*/(0,jsx_runtime.jsxs)(list_List, {\n          children: [/*#__PURE__*/(0,jsx_runtime.jsx)(list_ListItem, {\n            overlineText: "Overline",\n            primaryText: "Item 1",\n            secondaryText: "Secondary text"\n          }), /*#__PURE__*/(0,jsx_runtime.jsx)(list_ListItem, {\n            overlineText: "Overline",\n            primaryText: "Item 2",\n            secondaryText: "Secondary text"\n          }), /*#__PURE__*/(0,jsx_runtime.jsx)(list_ListItem, {\n            overlineText: "Overline",\n            primaryText: "Item 3",\n            secondaryText: "Secondary text"\n          })]\n        })\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Section, {\n      title: "List with icons",\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(Code, {\n        children: /*#__PURE__*/(0,jsx_runtime.jsxs)(list_List, {\n          children: [/*#__PURE__*/(0,jsx_runtime.jsx)(list_ListItem, {\n            icon: "star",\n            text: "Item 1"\n          }), /*#__PURE__*/(0,jsx_runtime.jsx)(list_ListItem, {\n            icon: "star",\n            text: "Item 2"\n          }), /*#__PURE__*/(0,jsx_runtime.jsx)(list_ListItem, {\n            icon: "star",\n            text: "Item 3"\n          })]\n        })\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Section, {\n      title: "List with images",\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(Code, {\n        children: /*#__PURE__*/(0,jsx_runtime.jsxs)(list_List, {\n          children: [/*#__PURE__*/(0,jsx_runtime.jsx)(list_ListItem, {\n            image: /*#__PURE__*/(0,jsx_runtime.jsx)("img", {\n              src: "https://placeimg.com/56/56/any"\n            }),\n            text: "Item 1"\n          }), /*#__PURE__*/(0,jsx_runtime.jsx)(list_ListItem, {\n            image: /*#__PURE__*/(0,jsx_runtime.jsx)("img", {\n              src: "https://placeimg.com/56/56/any"\n            }),\n            text: "Item 2"\n          }), /*#__PURE__*/(0,jsx_runtime.jsx)(list_ListItem, {\n            image: /*#__PURE__*/(0,jsx_runtime.jsx)("img", {\n              src: "https://placeimg.com/56/56/any"\n            }),\n            text: "Item 3"\n          })]\n        })\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Section, {\n      title: "List with thumbnails",\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(Code, {\n        children: /*#__PURE__*/(0,jsx_runtime.jsxs)(list_List, {\n          children: [/*#__PURE__*/(0,jsx_runtime.jsx)(list_ListItem, {\n            thumbnail: /*#__PURE__*/(0,jsx_runtime.jsx)("img", {\n              src: "https://placeimg.com/40/40/people"\n            }),\n            text: "Item 1"\n          }), /*#__PURE__*/(0,jsx_runtime.jsx)(list_ListItem, {\n            thumbnail: /*#__PURE__*/(0,jsx_runtime.jsx)("img", {\n              src: "https://placeimg.com/40/40/people"\n            }),\n            text: "Item 2"\n          }), /*#__PURE__*/(0,jsx_runtime.jsx)(list_ListItem, {\n            thumbnail: /*#__PURE__*/(0,jsx_runtime.jsx)("img", {\n              src: "https://placeimg.com/40/40/people"\n            }),\n            text: "Item 3"\n          })]\n        })\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Section, {\n      title: "List with videos",\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(Code, {\n        children: /*#__PURE__*/(0,jsx_runtime.jsxs)(list_List, {\n          children: [/*#__PURE__*/(0,jsx_runtime.jsx)(list_ListItem, {\n            video: /*#__PURE__*/(0,jsx_runtime.jsx)("img", {\n              src: "https://placeimg.com/100/56/people"\n            }),\n            text: "Item 1"\n          }), /*#__PURE__*/(0,jsx_runtime.jsx)(list_ListItem, {\n            video: /*#__PURE__*/(0,jsx_runtime.jsx)("img", {\n              src: "https://placeimg.com/100/56/people"\n            }),\n            text: "Item 2"\n          }), /*#__PURE__*/(0,jsx_runtime.jsx)(list_ListItem, {\n            video: /*#__PURE__*/(0,jsx_runtime.jsx)("img", {\n              src: "https://placeimg.com/100/56/people"\n            }),\n            text: "Item 3"\n          })]\n        })\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Section, {\n      title: "List with checkboxes",\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(Code, {\n        children: /*#__PURE__*/(0,jsx_runtime.jsxs)(list_List, {\n          children: [/*#__PURE__*/(0,jsx_runtime.jsx)(list_ListItem, {\n            leadingCheckbox: /*#__PURE__*/(0,jsx_runtime.jsx)(checkbox_Checkbox, {\n              defaultChecked: false\n            }),\n            text: "Item 1"\n          }), /*#__PURE__*/(0,jsx_runtime.jsx)(list_ListItem, {\n            leadingCheckbox: /*#__PURE__*/(0,jsx_runtime.jsx)(checkbox_Checkbox, {\n              defaultChecked: false\n            }),\n            text: "Item 2"\n          }), /*#__PURE__*/(0,jsx_runtime.jsx)(list_ListItem, {\n            leadingCheckbox: /*#__PURE__*/(0,jsx_runtime.jsx)(checkbox_Checkbox, {\n              defaultChecked: false\n            }),\n            text: "Item 3"\n          })]\n        })\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Section, {\n      title: "List with radios",\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(Code, {\n        children: /*#__PURE__*/(0,jsx_runtime.jsxs)(list_List, {\n          children: [/*#__PURE__*/(0,jsx_runtime.jsx)(list_ListItem, {\n            leadingRadio: /*#__PURE__*/(0,jsx_runtime.jsx)(radio_Radio, {}),\n            text: "Item 1"\n          }), /*#__PURE__*/(0,jsx_runtime.jsx)(list_ListItem, {\n            leadingRadio: /*#__PURE__*/(0,jsx_runtime.jsx)(radio_Radio, {\n              checked: true\n            }),\n            text: "Item 2"\n          }), /*#__PURE__*/(0,jsx_runtime.jsx)(list_ListItem, {\n            leadingRadio: /*#__PURE__*/(0,jsx_runtime.jsx)(radio_Radio, {}),\n            text: "Item 3"\n          })]\n        })\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Section, {\n      title: "List with switches",\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(Code, {\n        children: /*#__PURE__*/(0,jsx_runtime.jsxs)(list_List, {\n          children: [/*#__PURE__*/(0,jsx_runtime.jsx)(list_ListItem, {\n            leadingSwitch: /*#__PURE__*/(0,jsx_runtime.jsx)(switch_Switch, {}),\n            text: "Item 1"\n          }), /*#__PURE__*/(0,jsx_runtime.jsx)(list_ListItem, {\n            leadingSwitch: /*#__PURE__*/(0,jsx_runtime.jsx)(switch_Switch, {\n              checked: true\n            }),\n            text: "Item 2"\n          }), /*#__PURE__*/(0,jsx_runtime.jsx)(list_ListItem, {\n            leadingSwitch: /*#__PURE__*/(0,jsx_runtime.jsx)(switch_Switch, {}),\n            text: "Item 3"\n          })]\n        })\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Section, {\n      title: "List with trailing icons",\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(Code, {\n        children: /*#__PURE__*/(0,jsx_runtime.jsxs)(list_List, {\n          children: [/*#__PURE__*/(0,jsx_runtime.jsx)(list_ListItem, {\n            text: "Item 1",\n            trailingIcon: "info"\n          }), /*#__PURE__*/(0,jsx_runtime.jsx)(list_ListItem, {\n            text: "Item 2",\n            trailingIcon: "info"\n          }), /*#__PURE__*/(0,jsx_runtime.jsx)(list_ListItem, {\n            text: "Item 3",\n            trailingIcon: "info"\n          })]\n        })\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Section, {\n      title: "List with trailing meta",\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(Code, {\n        children: /*#__PURE__*/(0,jsx_runtime.jsxs)(list_List, {\n          children: [/*#__PURE__*/(0,jsx_runtime.jsx)(list_ListItem, {\n            text: "Item 1",\n            meta: "Meta"\n          }), /*#__PURE__*/(0,jsx_runtime.jsx)(list_ListItem, {\n            text: "Item 2",\n            meta: "Meta"\n          }), /*#__PURE__*/(0,jsx_runtime.jsx)(list_ListItem, {\n            text: "Item 3",\n            meta: "Meta"\n          })]\n        })\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Section, {\n      title: "List with trailing checkboxes",\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(Code, {\n        children: /*#__PURE__*/(0,jsx_runtime.jsxs)(list_List, {\n          children: [/*#__PURE__*/(0,jsx_runtime.jsx)(list_ListItem, {\n            text: "Item 1",\n            trailingCheckbox: /*#__PURE__*/(0,jsx_runtime.jsx)(checkbox_Checkbox, {})\n          }), /*#__PURE__*/(0,jsx_runtime.jsx)(list_ListItem, {\n            text: "Item 2",\n            trailingCheckbox: /*#__PURE__*/(0,jsx_runtime.jsx)(checkbox_Checkbox, {\n              checked: true\n            })\n          }), /*#__PURE__*/(0,jsx_runtime.jsx)(list_ListItem, {\n            text: "Item 3",\n            trailingCheckbox: /*#__PURE__*/(0,jsx_runtime.jsx)(checkbox_Checkbox, {})\n          })]\n        })\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Section, {\n      title: "List with trailing radios",\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(Code, {\n        children: /*#__PURE__*/(0,jsx_runtime.jsxs)(list_List, {\n          children: [/*#__PURE__*/(0,jsx_runtime.jsx)(list_ListItem, {\n            text: "Item 1",\n            trailingRadio: /*#__PURE__*/(0,jsx_runtime.jsx)(radio_Radio, {})\n          }), /*#__PURE__*/(0,jsx_runtime.jsx)(list_ListItem, {\n            text: "Item 2",\n            trailingRadio: /*#__PURE__*/(0,jsx_runtime.jsx)(radio_Radio, {\n              checked: true\n            })\n          }), /*#__PURE__*/(0,jsx_runtime.jsx)(list_ListItem, {\n            text: "Item 3",\n            trailingRadio: /*#__PURE__*/(0,jsx_runtime.jsx)(radio_Radio, {})\n          })]\n        })\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Section, {\n      title: "List with trailing switches",\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(Code, {\n        children: /*#__PURE__*/(0,jsx_runtime.jsxs)(list_List, {\n          children: [/*#__PURE__*/(0,jsx_runtime.jsx)(list_ListItem, {\n            text: "Item 1",\n            trailingSwitch: /*#__PURE__*/(0,jsx_runtime.jsx)(switch_Switch, {})\n          }), /*#__PURE__*/(0,jsx_runtime.jsx)(list_ListItem, {\n            text: "Item 2",\n            trailingSwitch: /*#__PURE__*/(0,jsx_runtime.jsx)(switch_Switch, {\n              selected: true\n            })\n          }), /*#__PURE__*/(0,jsx_runtime.jsx)(list_ListItem, {\n            text: "Item 3",\n            trailingSwitch: /*#__PURE__*/(0,jsx_runtime.jsx)(switch_Switch, {})\n          })]\n        })\n      })\n    })]\n  });\n}\n;// CONCATENATED MODULE: ./docs/src/pages/Menu/index.jsx\nfunction pages_Menu_slicedToArray(arr, i) { return pages_Menu_arrayWithHoles(arr) || pages_Menu_iterableToArrayLimit(arr, i) || pages_Menu_unsupportedIterableToArray(arr, i) || pages_Menu_nonIterableRest(); }\n\nfunction pages_Menu_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction pages_Menu_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return pages_Menu_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return pages_Menu_arrayLikeToArray(o, minLen); }\n\nfunction pages_Menu_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction pages_Menu_iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction pages_Menu_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\n\n\n\n\n\n\n\n\nvar Menu_id = \'menu\';\nvar Menu_title = \'Menu\';\nvar Menu_description = \'Menus display a list of choices on temporary surfaces.\';\nvar Menu_links = {\n  docs: \'https://github.com/material-components/material-components-web/tree/master/packages/mdc-menu\',\n  guide: \'https://material.io/components/menus\'\n};\nfunction MenuPage() {\n  var _useState = (0,react.useState)(false),\n      _useState2 = pages_Menu_slicedToArray(_useState, 2),\n      isBasicOpen = _useState2[0],\n      setBasicOpen = _useState2[1];\n\n  var _useState3 = (0,react.useState)(false),\n      _useState4 = pages_Menu_slicedToArray(_useState3, 2),\n      isQuickOpen = _useState4[0],\n      setQuickOpen = _useState4[1];\n\n  var _useState5 = (0,react.useState)(false),\n      _useState6 = pages_Menu_slicedToArray(_useState5, 2),\n      isPersistentOpen = _useState6[0],\n      setPersistentOpen = _useState6[1];\n\n  var _useState7 = (0,react.useState)(false),\n      _useState8 = pages_Menu_slicedToArray(_useState7, 2),\n      isAnchoredOpen = _useState8[0],\n      setAnchoredOpen = _useState8[1];\n\n  var _useState9 = (0,react.useState)(menu_Menu.Origin.TOP_LEFT),\n      _useState10 = pages_Menu_slicedToArray(_useState9, 2),\n      anchorPosition = _useState10[0],\n      setAnchorPosition = _useState10[1];\n\n  var _useState11 = (0,react.useState)(menu_Menu.Origin.TOP_LEFT),\n      _useState12 = pages_Menu_slicedToArray(_useState11, 2),\n      anchorOrigin = _useState12[0],\n      setAnchorOrigin = _useState12[1];\n\n  var _useState13 = (0,react.useState)(menu_Menu.Origin.TOP_LEFT),\n      _useState14 = pages_Menu_slicedToArray(_useState13, 2),\n      transformOrigin = _useState14[0],\n      setTransformOrigin = _useState14[1];\n\n  var handleAnchorPositionChange = (0,react.useCallback)(function (event, value) {\n    setAnchorPosition(value);\n  }, []);\n  var handleAnchorOriginChange = (0,react.useCallback)(function (event, value) {\n    setAnchorOrigin(value);\n  }, []);\n  var handleTransformOriginChange = (0,react.useCallback)(function (event, value) {\n    setTransformOrigin(value);\n  }, []);\n  return /*#__PURE__*/(0,jsx_runtime.jsxs)(Page, {\n    id: Menu_id,\n    title: Menu_title,\n    description: Menu_description,\n    links: Menu_links,\n    children: [/*#__PURE__*/(0,jsx_runtime.jsx)(Section, {\n      title: "Basic menu",\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(Code, {\n        children: /*#__PURE__*/(0,jsx_runtime.jsxs)(menu_Menu, {\n          anchor: /*#__PURE__*/(0,jsx_runtime.jsx)(button_Button, {\n            label: "Open",\n            outlined: true,\n            onClick: function onClick() {\n              return setBasicOpen(true);\n            }\n          }),\n          open: isBasicOpen,\n          modal: true,\n          onClose: function onClose() {\n            setBasicOpen(false);\n          },\n          children: [/*#__PURE__*/(0,jsx_runtime.jsx)(menu_Menu.Item, {\n            text: "Foo"\n          }), /*#__PURE__*/(0,jsx_runtime.jsx)(menu_Menu.Item, {\n            text: "Bar"\n          }), /*#__PURE__*/(0,jsx_runtime.jsx)(menu_Menu.Item, {\n            text: "Baz"\n          })]\n        })\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Section, {\n      title: "Quick menu",\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(Code, {\n        children: /*#__PURE__*/(0,jsx_runtime.jsxs)(menu_Menu, {\n          anchor: /*#__PURE__*/(0,jsx_runtime.jsx)(button_Button, {\n            label: "Open",\n            outlined: true,\n            onClick: function onClick() {\n              return setQuickOpen(true);\n            }\n          }),\n          open: isQuickOpen,\n          quick: true,\n          onClose: function onClose() {\n            setQuickOpen(false);\n          },\n          children: [/*#__PURE__*/(0,jsx_runtime.jsx)(menu_Menu.Item, {\n            text: "Foo"\n          }), /*#__PURE__*/(0,jsx_runtime.jsx)(menu_Menu.Item, {\n            text: "Bar"\n          }), /*#__PURE__*/(0,jsx_runtime.jsx)(menu_Menu.Item, {\n            text: "Baz"\n          })]\n        })\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Section, {\n      title: "Persistent menu",\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(Code, {\n        children: /*#__PURE__*/(0,jsx_runtime.jsxs)(menu_Menu, {\n          anchor: /*#__PURE__*/(0,jsx_runtime.jsx)(button_Button, {\n            label: "Open",\n            outlined: true,\n            onClick: function onClick() {\n              return setPersistentOpen(function (v) {\n                return !v;\n              });\n            }\n          }),\n          open: isPersistentOpen,\n          persistent: true,\n          children: [/*#__PURE__*/(0,jsx_runtime.jsx)(menu_Menu.Item, {\n            text: "Foo",\n            onClick: function onClick() {\n              return setPersistentOpen(false);\n            }\n          }), /*#__PURE__*/(0,jsx_runtime.jsx)(menu_Menu.Item, {\n            text: "Bar",\n            onClick: function onClick() {\n              return setPersistentOpen(false);\n            }\n          }), /*#__PURE__*/(0,jsx_runtime.jsx)(menu_Menu.Item, {\n            text: "Baz",\n            onClick: function onClick() {\n              return setPersistentOpen(false);\n            }\n          })]\n        })\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsxs)(Section, {\n      id: "menu-origin",\n      className: "origin--".concat(anchorPosition.replace(\' \', \'-\')),\n      title: "Menu origin",\n      children: [/*#__PURE__*/(0,jsx_runtime.jsxs)(layout_grid_LayoutGrid, {\n        children: [/*#__PURE__*/(0,jsx_runtime.jsx)(layout_grid_LayoutGrid.Cell, {\n          children: /*#__PURE__*/(0,jsx_runtime.jsxs)("fieldset", {\n            children: [/*#__PURE__*/(0,jsx_runtime.jsx)(typography_Typography, {\n              element: "legend",\n              type: "caption",\n              noMargin: true,\n              children: "Anchor position"\n            }), /*#__PURE__*/(0,jsx_runtime.jsx)(form_field_FormField, {\n              label: "Top left",\n              children: /*#__PURE__*/(0,jsx_runtime.jsx)(radio_Radio, {\n                value: menu_Menu.Origin.TOP_LEFT,\n                checked: anchorPosition === menu_Menu.Origin.TOP_LEFT,\n                onChange: handleAnchorPositionChange\n              })\n            }), /*#__PURE__*/(0,jsx_runtime.jsx)(form_field_FormField, {\n              label: "Top right",\n              children: /*#__PURE__*/(0,jsx_runtime.jsx)(radio_Radio, {\n                value: menu_Menu.Origin.TOP_RIGHT,\n                checked: anchorPosition === menu_Menu.Origin.TOP_RIGHT,\n                onChange: handleAnchorPositionChange\n              })\n            }), /*#__PURE__*/(0,jsx_runtime.jsx)(form_field_FormField, {\n              label: "Bottom left",\n              children: /*#__PURE__*/(0,jsx_runtime.jsx)(radio_Radio, {\n                value: menu_Menu.Origin.BOTTOM_LEFT,\n                checked: anchorPosition === menu_Menu.Origin.BOTTOM_LEFT,\n                onChange: handleAnchorPositionChange\n              })\n            }), /*#__PURE__*/(0,jsx_runtime.jsx)(form_field_FormField, {\n              label: "Bottom right",\n              children: /*#__PURE__*/(0,jsx_runtime.jsx)(radio_Radio, {\n                value: menu_Menu.Origin.BOTTOM_RIGHT,\n                checked: anchorPosition === menu_Menu.Origin.BOTTOM_RIGHT,\n                onChange: handleAnchorPositionChange\n              })\n            })]\n          })\n        }), /*#__PURE__*/(0,jsx_runtime.jsx)(layout_grid_LayoutGrid.Cell, {\n          children: /*#__PURE__*/(0,jsx_runtime.jsxs)("fieldset", {\n            children: [/*#__PURE__*/(0,jsx_runtime.jsx)(typography_Typography, {\n              element: "legend",\n              type: "caption",\n              noMargin: true,\n              children: "Anchor origin"\n            }), /*#__PURE__*/(0,jsx_runtime.jsx)(form_field_FormField, {\n              label: "Top left",\n              children: /*#__PURE__*/(0,jsx_runtime.jsx)(radio_Radio, {\n                value: menu_Menu.Origin.TOP_LEFT,\n                checked: anchorOrigin === menu_Menu.Origin.TOP_LEFT,\n                onChange: handleAnchorOriginChange\n              })\n            }), /*#__PURE__*/(0,jsx_runtime.jsx)(form_field_FormField, {\n              label: "Top right",\n              children: /*#__PURE__*/(0,jsx_runtime.jsx)(radio_Radio, {\n                value: menu_Menu.Origin.TOP_RIGHT,\n                checked: anchorOrigin === menu_Menu.Origin.TOP_RIGHT,\n                onChange: handleAnchorOriginChange\n              })\n            }), /*#__PURE__*/(0,jsx_runtime.jsx)(form_field_FormField, {\n              label: "Bottom left",\n              children: /*#__PURE__*/(0,jsx_runtime.jsx)(radio_Radio, {\n                value: menu_Menu.Origin.BOTTOM_LEFT,\n                checked: anchorOrigin === menu_Menu.Origin.BOTTOM_LEFT,\n                onChange: handleAnchorOriginChange\n              })\n            }), /*#__PURE__*/(0,jsx_runtime.jsx)(form_field_FormField, {\n              label: "Bottom right",\n              children: /*#__PURE__*/(0,jsx_runtime.jsx)(radio_Radio, {\n                value: menu_Menu.Origin.BOTTOM_RIGHT,\n                checked: anchorOrigin === menu_Menu.Origin.BOTTOM_RIGHT,\n                onChange: handleAnchorOriginChange\n              })\n            })]\n          })\n        }), /*#__PURE__*/(0,jsx_runtime.jsx)(layout_grid_LayoutGrid.Cell, {\n          children: /*#__PURE__*/(0,jsx_runtime.jsxs)("fieldset", {\n            children: [/*#__PURE__*/(0,jsx_runtime.jsx)(typography_Typography, {\n              element: "legend",\n              type: "caption",\n              noMargin: true,\n              children: "Transform origin"\n            }), /*#__PURE__*/(0,jsx_runtime.jsx)(form_field_FormField, {\n              label: "Top left",\n              children: /*#__PURE__*/(0,jsx_runtime.jsx)(radio_Radio, {\n                value: menu_Menu.Origin.TOP_LEFT,\n                checked: transformOrigin === menu_Menu.Origin.TOP_LEFT,\n                onChange: handleTransformOriginChange\n              })\n            }), /*#__PURE__*/(0,jsx_runtime.jsx)(form_field_FormField, {\n              label: "Top right",\n              children: /*#__PURE__*/(0,jsx_runtime.jsx)(radio_Radio, {\n                value: menu_Menu.Origin.TOP_RIGHT,\n                checked: transformOrigin === menu_Menu.Origin.TOP_RIGHT,\n                onChange: handleTransformOriginChange\n              })\n            }), /*#__PURE__*/(0,jsx_runtime.jsx)(form_field_FormField, {\n              label: "Bottom left",\n              children: /*#__PURE__*/(0,jsx_runtime.jsx)(radio_Radio, {\n                value: menu_Menu.Origin.BOTTOM_LEFT,\n                checked: transformOrigin === menu_Menu.Origin.BOTTOM_LEFT,\n                onChange: handleTransformOriginChange\n              })\n            }), /*#__PURE__*/(0,jsx_runtime.jsx)(form_field_FormField, {\n              label: "Bottom right",\n              children: /*#__PURE__*/(0,jsx_runtime.jsx)(radio_Radio, {\n                value: menu_Menu.Origin.BOTTOM_RIGHT,\n                checked: transformOrigin === menu_Menu.Origin.BOTTOM_RIGHT,\n                onChange: handleTransformOriginChange\n              })\n            })]\n          })\n        })]\n      }), /*#__PURE__*/(0,jsx_runtime.jsx)(Code, {\n        children: /*#__PURE__*/(0,jsx_runtime.jsxs)(menu_Menu, {\n          anchor: /*#__PURE__*/(0,jsx_runtime.jsx)(button_Button, {\n            label: isPersistentOpen ? \'Close\' : \'Open\',\n            outlined: true,\n            onClick: function onClick() {\n              return setAnchoredOpen(function (v) {\n                return !v;\n              });\n            }\n          }),\n          anchorOrigin: anchorOrigin,\n          transformOrigin: transformOrigin,\n          open: isAnchoredOpen,\n          onClose: function onClose() {\n            setAnchoredOpen(false);\n          },\n          children: [/*#__PURE__*/(0,jsx_runtime.jsx)(menu_Menu.Item, {\n            text: "Foo"\n          }), /*#__PURE__*/(0,jsx_runtime.jsx)(menu_Menu.Item, {\n            text: "Bar"\n          }), /*#__PURE__*/(0,jsx_runtime.jsx)(menu_Menu.Item, {\n            text: "Baz"\n          })]\n        })\n      })]\n    })]\n  });\n}\n;// CONCATENATED MODULE: ./docs/src/pages/Radio/index.jsx\nfunction Radio_slicedToArray(arr, i) { return Radio_arrayWithHoles(arr) || Radio_iterableToArrayLimit(arr, i) || Radio_unsupportedIterableToArray(arr, i) || Radio_nonIterableRest(); }\n\nfunction Radio_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction Radio_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return Radio_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return Radio_arrayLikeToArray(o, minLen); }\n\nfunction Radio_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction Radio_iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction Radio_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\n\n\n\n\n\n\n\nvar Radio_id = \'radio\';\nvar Radio_title = \'Radio\';\nvar Radio_description = \'Radio buttons allow users to select one option from a set.\';\nvar Radio_links = {\n  docs: \'https://github.com/material-components/material-components-web/tree/master/packages/mdc-radio\',\n  guide: \'https://material.io/components/radio-buttons\'\n};\nfunction RadioPage() {\n  var _useState = (0,react.useState)(\'yes\'),\n      _useState2 = Radio_slicedToArray(_useState, 2),\n      value1 = _useState2[0],\n      setValue1 = _useState2[1];\n\n  var _useState3 = (0,react.useState)(\'yes\'),\n      _useState4 = Radio_slicedToArray(_useState3, 2),\n      value2 = _useState4[0],\n      setValue2 = _useState4[1];\n\n  var handleChange1 = (0,react.useCallback)(function (event, value) {\n    setValue1(value);\n  }, []);\n  var handleChange2 = (0,react.useCallback)(function (event, value) {\n    setValue2(value);\n  }, []);\n  return /*#__PURE__*/(0,jsx_runtime.jsxs)(Page, {\n    id: Radio_id,\n    title: Radio_title,\n    description: Radio_description,\n    links: Radio_links,\n    children: [/*#__PURE__*/(0,jsx_runtime.jsx)(Section, {\n      title: "Basic radio",\n      children: /*#__PURE__*/(0,jsx_runtime.jsxs)(Code, {\n        children: [/*#__PURE__*/(0,jsx_runtime.jsx)(form_field_FormField, {\n          label: "Yes",\n          children: /*#__PURE__*/(0,jsx_runtime.jsx)(radio_Radio, {\n            name: "answer1",\n            value: "yes",\n            checked: value1 === \'yes\',\n            onChange: handleChange1\n          })\n        }), /*#__PURE__*/(0,jsx_runtime.jsx)(form_field_FormField, {\n          label: "No",\n          children: /*#__PURE__*/(0,jsx_runtime.jsx)(radio_Radio, {\n            name: "answer1",\n            value: "no",\n            checked: value1 === \'no\',\n            onChange: handleChange1\n          })\n        }), /*#__PURE__*/(0,jsx_runtime.jsx)(form_field_FormField, {\n          label: "Maybe",\n          children: /*#__PURE__*/(0,jsx_runtime.jsx)(radio_Radio, {\n            name: "answer1",\n            value: "maybe",\n            checked: value1 === \'maybe\',\n            onChange: handleChange1\n          })\n        })]\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Section, {\n      title: "Disabled radio",\n      children: /*#__PURE__*/(0,jsx_runtime.jsxs)(Code, {\n        children: [/*#__PURE__*/(0,jsx_runtime.jsx)(form_field_FormField, {\n          label: "Yes",\n          children: /*#__PURE__*/(0,jsx_runtime.jsx)(radio_Radio, {\n            name: "answer2",\n            value: "yes",\n            checked: value2 === \'yes\',\n            onChange: handleChange2\n          })\n        }), /*#__PURE__*/(0,jsx_runtime.jsx)(form_field_FormField, {\n          label: "No",\n          children: /*#__PURE__*/(0,jsx_runtime.jsx)(radio_Radio, {\n            name: "answer2",\n            value: "no",\n            checked: value2 === \'no\',\n            onChange: handleChange2\n          })\n        }), /*#__PURE__*/(0,jsx_runtime.jsx)(form_field_FormField, {\n          label: "Maybe",\n          children: /*#__PURE__*/(0,jsx_runtime.jsx)(radio_Radio, {\n            name: "answer2",\n            value: "maybe",\n            checked: value2 === \'maybe\',\n            disabled: true,\n            onChange: handleChange2\n          })\n        })]\n      })\n    })]\n  });\n}\n;// CONCATENATED MODULE: ./docs/src/pages/Ripple/index.jsx\n\n\n\n\nfunction Ripple_RadioPage() {\n  return /*#__PURE__*/(0,jsx_runtime.jsx)(Page, {\n    title: "Ripple",\n    children: /*#__PURE__*/(0,jsx_runtime.jsx)(Section, {\n      title: "Basic ripple",\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(elevation_Elevation, {\n        z: "5",\n        children: /*#__PURE__*/(0,jsx_runtime.jsx)(ripple_RippleSurface, {\n          style: {\n            height: \'100px\'\n          }\n        })\n      })\n    })\n  });\n}\n;// CONCATENATED MODULE: ./docs/src/pages/SegmentedButton/index.jsx\nfunction SegmentedButton_slicedToArray(arr, i) { return SegmentedButton_arrayWithHoles(arr) || SegmentedButton_iterableToArrayLimit(arr, i) || SegmentedButton_unsupportedIterableToArray(arr, i) || SegmentedButton_nonIterableRest(); }\n\nfunction SegmentedButton_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction SegmentedButton_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return SegmentedButton_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return SegmentedButton_arrayLikeToArray(o, minLen); }\n\nfunction SegmentedButton_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction SegmentedButton_iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction SegmentedButton_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\n\n\n\n\n\n\n\nvar SegmentedButton_id = \'segmented-button\';\nvar SegmentedButton_title = \'Segmented Button\';\nvar SegmentedButton_description = \'Segmented buttons allow users to toggle the selected states of grouped buttons.\';\nvar SegmentedButton_links = {\n  docs: \'https://github.com/material-components/material-components-web/tree/master/packages/mdc-segmented-button\',\n  guide: \'https://material.io/components/buttons#toggle-button\'\n};\nfunction SegmentedButtonPage() {\n  var _useState = (0,react.useState)(\'star\'),\n      _useState2 = SegmentedButton_slicedToArray(_useState, 2),\n      value1 = _useState2[0],\n      setValue1 = _useState2[1];\n\n  var _useState3 = (0,react.useState)(\'star\'),\n      _useState4 = SegmentedButton_slicedToArray(_useState3, 2),\n      value2 = _useState4[0],\n      setValue2 = _useState4[1];\n\n  var _useState5 = (0,react.useState)(\'star\'),\n      _useState6 = SegmentedButton_slicedToArray(_useState5, 2),\n      value3 = _useState6[0],\n      setValue3 = _useState6[1];\n\n  return /*#__PURE__*/(0,jsx_runtime.jsxs)(Page, {\n    id: SegmentedButton_id,\n    title: SegmentedButton_title,\n    description: SegmentedButton_description,\n    links: SegmentedButton_links,\n    children: [/*#__PURE__*/(0,jsx_runtime.jsx)(Section, {\n      title: "Text",\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(Code, {\n        children: /*#__PURE__*/(0,jsx_runtime.jsxs)(segmented_button_SegmentedButton, {\n          value: value1,\n          onChange: setValue1,\n          children: [/*#__PURE__*/(0,jsx_runtime.jsx)(segmented_button_SegmentedButton.Segment, {\n            value: "star",\n            label: "star"\n          }), /*#__PURE__*/(0,jsx_runtime.jsx)(segmented_button_SegmentedButton.Segment, {\n            value: "favorite",\n            label: "favorite"\n          })]\n        })\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Section, {\n      title: "Icons",\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(Code, {\n        children: /*#__PURE__*/(0,jsx_runtime.jsxs)(segmented_button_SegmentedButton, {\n          value: value2,\n          onChange: setValue2,\n          children: [/*#__PURE__*/(0,jsx_runtime.jsx)(segmented_button_SegmentedButton.Segment, {\n            value: "star",\n            icon: "star"\n          }), /*#__PURE__*/(0,jsx_runtime.jsx)(segmented_button_SegmentedButton.Segment, {\n            value: "favorite",\n            icon: "favorite"\n          })]\n        })\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Section, {\n      title: "Text with Icons",\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(Code, {\n        children: /*#__PURE__*/(0,jsx_runtime.jsxs)(segmented_button_SegmentedButton, {\n          value: value3,\n          onChange: setValue3,\n          children: [/*#__PURE__*/(0,jsx_runtime.jsx)(segmented_button_SegmentedButton.Segment, {\n            value: "star",\n            icon: "star",\n            label: "star"\n          }), /*#__PURE__*/(0,jsx_runtime.jsx)(segmented_button_SegmentedButton.Segment, {\n            value: "favorite",\n            icon: "favorite",\n            label: "favorite"\n          })]\n        })\n      })\n    })]\n  });\n}\n;// CONCATENATED MODULE: ./docs/src/pages/Select/index.jsx\nfunction pages_Select_slicedToArray(arr, i) { return pages_Select_arrayWithHoles(arr) || pages_Select_iterableToArrayLimit(arr, i) || pages_Select_unsupportedIterableToArray(arr, i) || pages_Select_nonIterableRest(); }\n\nfunction pages_Select_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction pages_Select_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return pages_Select_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return pages_Select_arrayLikeToArray(o, minLen); }\n\nfunction pages_Select_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction pages_Select_iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction pages_Select_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\n\n\n\n\n\n\n\nvar Select_id = \'select\';\nvar Select_title = \'Select\';\nvar Select_description = \'Segmented buttons allow users to toggle the selected states of grouped buttons.\';\nvar Select_links = {\n  docs: \'https://github.com/material-components/material-components-web/tree/master/packages/mdc-select\'\n};\nfunction SelectPage() {\n  var _useState = (0,react.useState)(),\n      _useState2 = pages_Select_slicedToArray(_useState, 2),\n      filled = _useState2[0],\n      setFilled = _useState2[1];\n\n  var _useState3 = (0,react.useState)(),\n      _useState4 = pages_Select_slicedToArray(_useState3, 2),\n      outlined = _useState4[0],\n      setOutlined = _useState4[1];\n\n  var _useState5 = (0,react.useState)(\'foo\'),\n      _useState6 = pages_Select_slicedToArray(_useState5, 2),\n      preselected = _useState6[0],\n      setPreselected = _useState6[1];\n\n  var _useState7 = (0,react.useState)([]),\n      _useState8 = pages_Select_slicedToArray(_useState7, 2),\n      multiple = _useState8[0],\n      setMultiple = _useState8[1];\n\n  var _useState9 = (0,react.useState)(),\n      _useState10 = pages_Select_slicedToArray(_useState9, 2),\n      icon = _useState10[0],\n      setIcon = _useState10[1];\n\n  return /*#__PURE__*/(0,jsx_runtime.jsxs)(Page, {\n    id: Select_id,\n    title: Select_title,\n    description: Select_description,\n    links: Select_links,\n    children: [/*#__PURE__*/(0,jsx_runtime.jsx)(Section, {\n      title: "Filled select",\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(Code, {\n        children: /*#__PURE__*/(0,jsx_runtime.jsxs)(select_Select, {\n          label: "Choose",\n          value: filled,\n          filled: true,\n          onChange: function onChange(event, value) {\n            return setFilled(value);\n          },\n          children: [/*#__PURE__*/(0,jsx_runtime.jsx)(select_Select.Option, {\n            value: "foo",\n            text: "Foo"\n          }), /*#__PURE__*/(0,jsx_runtime.jsx)(select_Select.Option, {\n            value: "bar",\n            text: "Bar"\n          }), /*#__PURE__*/(0,jsx_runtime.jsx)(select_Select.Option, {\n            value: "baz",\n            text: "Baz"\n          })]\n        })\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Section, {\n      title: "Outlined select",\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(Code, {\n        children: /*#__PURE__*/(0,jsx_runtime.jsxs)(select_Select, {\n          label: "Choose",\n          value: outlined,\n          outlined: true,\n          onChange: function onChange(event, value) {\n            return setOutlined(value);\n          },\n          children: [/*#__PURE__*/(0,jsx_runtime.jsx)(select_Select.Option, {\n            value: "foo",\n            text: "Foo"\n          }), /*#__PURE__*/(0,jsx_runtime.jsx)(select_Select.Option, {\n            value: "bar",\n            text: "Bar"\n          }), /*#__PURE__*/(0,jsx_runtime.jsx)(select_Select.Option, {\n            value: "baz",\n            text: "Baz"\n          })]\n        })\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Section, {\n      title: "Preselected select",\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(Code, {\n        children: /*#__PURE__*/(0,jsx_runtime.jsxs)(select_Select, {\n          label: "Choose",\n          value: preselected,\n          filled: true,\n          onChange: function onChange(event, value) {\n            return setPreselected(value);\n          },\n          children: [/*#__PURE__*/(0,jsx_runtime.jsx)(select_Select.Option, {\n            value: "foo",\n            text: "Foo"\n          }), /*#__PURE__*/(0,jsx_runtime.jsx)(select_Select.Option, {\n            value: "bar",\n            text: "Bar"\n          }), /*#__PURE__*/(0,jsx_runtime.jsx)(select_Select.Option, {\n            value: "baz",\n            text: "Baz"\n          })]\n        })\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Section, {\n      title: "Multiple select",\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(Code, {\n        children: /*#__PURE__*/(0,jsx_runtime.jsxs)(select_Select, {\n          label: "Choose",\n          value: multiple,\n          filled: true,\n          onChange: function onChange(event, value) {\n            return setMultiple(value);\n          },\n          children: [/*#__PURE__*/(0,jsx_runtime.jsx)(select_Select.Option, {\n            value: "foo",\n            text: "Foo"\n          }), /*#__PURE__*/(0,jsx_runtime.jsx)(select_Select.Option, {\n            value: "bar",\n            text: "Bar"\n          }), /*#__PURE__*/(0,jsx_runtime.jsx)(select_Select.Option, {\n            value: "baz",\n            text: "Baz"\n          })]\n        })\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Section, {\n      title: "Select with an icon",\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(Code, {\n        children: /*#__PURE__*/(0,jsx_runtime.jsxs)(select_Select, {\n          label: "Choose",\n          value: icon,\n          icon: "star",\n          filled: true,\n          onChange: function onChange(event, value) {\n            return setIcon(value);\n          },\n          children: [/*#__PURE__*/(0,jsx_runtime.jsx)(select_Select.Option, {\n            value: "foo",\n            text: "Foo"\n          }), /*#__PURE__*/(0,jsx_runtime.jsx)(select_Select.Option, {\n            value: "bar",\n            text: "Bar"\n          }), /*#__PURE__*/(0,jsx_runtime.jsx)(select_Select.Option, {\n            value: "baz",\n            text: "Baz"\n          })]\n        })\n      })\n    })]\n  });\n}\n;// CONCATENATED MODULE: ./docs/src/pages/SideSheet/index.jsx\nfunction SideSheet_slicedToArray(arr, i) { return SideSheet_arrayWithHoles(arr) || SideSheet_iterableToArrayLimit(arr, i) || SideSheet_unsupportedIterableToArray(arr, i) || SideSheet_nonIterableRest(); }\n\nfunction SideSheet_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction SideSheet_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return SideSheet_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return SideSheet_arrayLikeToArray(o, minLen); }\n\nfunction SideSheet_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction SideSheet_iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction SideSheet_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\n\n\n\n\n\n\n\nvar SideSheet_id = \'side-sheet\';\nvar SideSheet_title = \'Side Sheet\';\nvar SideSheet_description = \'Side sheets are surfaces containing supplementary content that are anchored to the left or right edge of the screen.\';\nvar SideSheet_links = {\n  guide: \'https://material.io/components/sheets-side\'\n};\nfunction SideSheetPage() {\n  var _useState = (0,react.useState)(false),\n      _useState2 = SideSheet_slicedToArray(_useState, 2),\n      isDismissibleOpen = _useState2[0],\n      setDismissibleOpen = _useState2[1];\n\n  var _useState3 = (0,react.useState)(false),\n      _useState4 = SideSheet_slicedToArray(_useState3, 2),\n      isModalOpen = _useState4[0],\n      setModalOpen = _useState4[1];\n\n  return /*#__PURE__*/(0,jsx_runtime.jsxs)(Page, {\n    id: SideSheet_id,\n    title: SideSheet_title,\n    description: SideSheet_description,\n    links: SideSheet_links,\n    children: [/*#__PURE__*/(0,jsx_runtime.jsx)(Section, {\n      title: "Basic side sheet",\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(Code, {\n        children: /*#__PURE__*/(0,jsx_runtime.jsx)(side_sheet_SideSheet, {\n          title: "Title",\n          children: "Content"\n        })\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Section, {\n      title: "Dismissible side sheet",\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(Code, {\n        setup: /*#__PURE__*/(0,jsx_runtime.jsx)(button_Button, {\n          label: "Toggle",\n          outlined: true,\n          onClick: function onClick() {\n            return setDismissibleOpen(function (v) {\n              return !v;\n            });\n          }\n        }),\n        children: /*#__PURE__*/(0,jsx_runtime.jsx)(side_sheet_SideSheet, {\n          title: "Title",\n          closeIcon: "close",\n          open: isDismissibleOpen,\n          dismissible: true,\n          onClose: function onClose() {\n            return setDismissibleOpen(false);\n          },\n          children: "Content"\n        })\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Section, {\n      title: "Modal side sheet",\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(Code, {\n        setup: /*#__PURE__*/(0,jsx_runtime.jsx)(button_Button, {\n          label: "Open",\n          outlined: true,\n          onClick: function onClick() {\n            return setModalOpen(true);\n          }\n        }),\n        children: /*#__PURE__*/(0,jsx_runtime.jsx)(side_sheet_SideSheet, {\n          title: "Title",\n          closeIcon: "close",\n          open: isModalOpen,\n          modal: true,\n          onClose: function onClose() {\n            return setModalOpen(false);\n          },\n          children: "Content"\n        })\n      })\n    })]\n  });\n}\n;// CONCATENATED MODULE: ./docs/src/pages/Slider/index.jsx\nfunction pages_Slider_slicedToArray(arr, i) { return pages_Slider_arrayWithHoles(arr) || pages_Slider_iterableToArrayLimit(arr, i) || pages_Slider_unsupportedIterableToArray(arr, i) || pages_Slider_nonIterableRest(); }\n\nfunction pages_Slider_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction pages_Slider_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return pages_Slider_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return pages_Slider_arrayLikeToArray(o, minLen); }\n\nfunction pages_Slider_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction pages_Slider_iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction pages_Slider_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\n\n\n\n\n\n\n\nvar Slider_id = \'slider\';\nvar Slider_title = \'Slider\';\nvar Slider_description = \'Sliders allow users to make selections from a range of values.\';\nvar Slider_links = {\n  docs: \'https://github.com/material-components/material-components-web/tree/master/packages/mdc-slider\',\n  guide: \'https://material.io/components/sliders\'\n};\nfunction SliderPage() {\n  var _useState = (0,react.useState)(50),\n      _useState2 = pages_Slider_slicedToArray(_useState, 2),\n      value1 = _useState2[0],\n      setValue1 = _useState2[1];\n\n  var _useState3 = (0,react.useState)(50),\n      _useState4 = pages_Slider_slicedToArray(_useState3, 2),\n      value2 = _useState4[0],\n      setValue2 = _useState4[1];\n\n  var _useState5 = (0,react.useState)(50),\n      _useState6 = pages_Slider_slicedToArray(_useState5, 2),\n      value3 = _useState6[0],\n      setValue3 = _useState6[1];\n\n  return /*#__PURE__*/(0,jsx_runtime.jsxs)(Page, {\n    id: Slider_id,\n    title: Slider_title,\n    description: Slider_description,\n    links: Slider_links,\n    children: [/*#__PURE__*/(0,jsx_runtime.jsx)(Section, {\n      title: "Continuous slider",\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(Code, {\n        children: /*#__PURE__*/(0,jsx_runtime.jsx)(slider_Slider, {\n          value: value1,\n          onChange: setValue1\n        })\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Section, {\n      title: "Discrete slider",\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(Code, {\n        children: /*#__PURE__*/(0,jsx_runtime.jsx)(slider_Slider, {\n          value: value2,\n          step: "10",\n          discrete: true,\n          onChange: setValue2\n        })\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Section, {\n      title: "Discrete slider with tick marks",\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(Code, {\n        children: /*#__PURE__*/(0,jsx_runtime.jsx)(slider_Slider, {\n          value: value3,\n          step: "10",\n          discrete: true,\n          tickMarks: true,\n          onChange: setValue3\n        })\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Section, {\n      title: "Disabled slider",\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(Code, {\n        children: /*#__PURE__*/(0,jsx_runtime.jsx)(slider_Slider, {\n          value: 42,\n          disabled: true\n        })\n      })\n    })]\n  });\n}\n;// CONCATENATED MODULE: ./docs/src/pages/Snackbar/index.jsx\nfunction Snackbar_slicedToArray(arr, i) { return Snackbar_arrayWithHoles(arr) || Snackbar_iterableToArrayLimit(arr, i) || Snackbar_unsupportedIterableToArray(arr, i) || Snackbar_nonIterableRest(); }\n\nfunction Snackbar_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction Snackbar_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return Snackbar_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return Snackbar_arrayLikeToArray(o, minLen); }\n\nfunction Snackbar_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction Snackbar_iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction Snackbar_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\n\n\n\n\n\n\n\nvar Snackbar_id = \'snackbar\';\nvar Snackbar_title = \'Snackbar\';\nvar Snackbar_description = \'Snackbars provide brief messages about app processes at the bottom of the screen.\';\nvar Snackbar_links = {\n  docs: \'https://github.com/material-components/material-components-web/tree/master/packages/mdc-snackbar\',\n  guide: \'https://material.io/components/snackbars\'\n};\nfunction SnackbarPage() {\n  var _useState = (0,react.useState)(false),\n      _useState2 = Snackbar_slicedToArray(_useState, 2),\n      isOpen = _useState2[0],\n      setOpen = _useState2[1];\n\n  var _useState3 = (0,react.useState)(5000),\n      _useState4 = Snackbar_slicedToArray(_useState3, 2),\n      timeout = _useState4[0],\n      setTimeout = _useState4[1];\n\n  var _useState5 = (0,react.useState)(false),\n      _useState6 = Snackbar_slicedToArray(_useState5, 2),\n      hasAction = _useState6[0],\n      setHasAction = _useState6[1];\n\n  var _useState7 = (0,react.useState)(false),\n      _useState8 = Snackbar_slicedToArray(_useState7, 2),\n      isLeading = _useState8[0],\n      setLeading = _useState8[1];\n\n  var _useState9 = (0,react.useState)(false),\n      _useState10 = Snackbar_slicedToArray(_useState9, 2),\n      isStacked = _useState10[0],\n      setStacked = _useState10[1];\n\n  return /*#__PURE__*/(0,jsx_runtime.jsx)(Page, {\n    id: Snackbar_id,\n    title: Snackbar_title,\n    description: Snackbar_description,\n    links: Snackbar_links,\n    children: /*#__PURE__*/(0,jsx_runtime.jsxs)(Section, {\n      title: "Demo",\n      children: [/*#__PURE__*/(0,jsx_runtime.jsxs)(layout_Layout, {\n        row: true,\n        children: [/*#__PURE__*/(0,jsx_runtime.jsxs)("fieldset", {\n          children: [/*#__PURE__*/(0,jsx_runtime.jsx)("legend", {\n            children: "Elements"\n          }), /*#__PURE__*/(0,jsx_runtime.jsx)(segmented_button_SegmentedButton, {\n            children: /*#__PURE__*/(0,jsx_runtime.jsx)(segmented_button_SegmentedButton.Segment, {\n              label: "Action",\n              selected: hasAction,\n              onClick: function onClick() {\n                return setHasAction(function (v) {\n                  return !v;\n                });\n              }\n            })\n          })]\n        }), /*#__PURE__*/(0,jsx_runtime.jsxs)("fieldset", {\n          children: [/*#__PURE__*/(0,jsx_runtime.jsx)("legend", {\n            children: "Variants"\n          }), /*#__PURE__*/(0,jsx_runtime.jsxs)(segmented_button_SegmentedButton, {\n            children: [/*#__PURE__*/(0,jsx_runtime.jsx)(segmented_button_SegmentedButton.Segment, {\n              label: "Leading",\n              selected: isLeading,\n              onClick: function onClick() {\n                return setLeading(function (v) {\n                  return !v;\n                });\n              }\n            }), /*#__PURE__*/(0,jsx_runtime.jsx)(segmented_button_SegmentedButton.Segment, {\n              label: "Stacked",\n              selected: isStacked,\n              onClick: function onClick() {\n                return setStacked(function (v) {\n                  return !v;\n                });\n              }\n            })]\n          })]\n        }), /*#__PURE__*/(0,jsx_runtime.jsx)(text_field_TextField, {\n          label: "Timeout",\n          value: timeout,\n          suffix: "ms",\n          outlined: true,\n          onChange: function onChange(_, value) {\n            return setTimeout(value);\n          }\n        })]\n      }), /*#__PURE__*/(0,jsx_runtime.jsx)(Code, {\n        setup: /*#__PURE__*/(0,jsx_runtime.jsx)(button_Button, {\n          label: "Show",\n          outlined: true,\n          onClick: function onClick() {\n            return setOpen(true);\n          }\n        }),\n        children: /*#__PURE__*/(0,jsx_runtime.jsx)(snackbar_Snackbar, {\n          open: isOpen,\n          timeout: timeout,\n          label: "Message",\n          action: hasAction ? /*#__PURE__*/(0,jsx_runtime.jsx)(button_Button, {\n            children: "Action"\n          }) : undefined,\n          leading: isLeading || undefined,\n          stacked: isStacked || undefined,\n          onClose: function onClose() {\n            return setOpen(undefined);\n          }\n        })\n      })]\n    })\n  });\n}\n;// CONCATENATED MODULE: ./docs/src/pages/Switch/index.jsx\nfunction Switch_slicedToArray(arr, i) { return Switch_arrayWithHoles(arr) || Switch_iterableToArrayLimit(arr, i) || Switch_unsupportedIterableToArray(arr, i) || Switch_nonIterableRest(); }\n\nfunction Switch_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction Switch_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return Switch_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return Switch_arrayLikeToArray(o, minLen); }\n\nfunction Switch_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction Switch_iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction Switch_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\n\n\n\n\n\n\n\nvar Switch_id = \'switch\';\nvar Switch_title = \'Switch\';\nvar Switch_description = \'Switches toggle the state of a single item on or off.\';\nvar Switch_links = {\n  docs: \'https://github.com/material-components/material-components-web/tree/master/packages/mdc-switch\',\n  guide: \'https://material.io/components/switches\'\n};\nfunction SwitchPage() {\n  var _useState = (0,react.useState)(false),\n      _useState2 = Switch_slicedToArray(_useState, 2),\n      isSelected = _useState2[0],\n      setSelected = _useState2[1];\n\n  return /*#__PURE__*/(0,jsx_runtime.jsxs)(Page, {\n    id: Switch_id,\n    title: Switch_title,\n    description: Switch_description,\n    links: Switch_links,\n    children: [/*#__PURE__*/(0,jsx_runtime.jsx)(Section, {\n      title: "Basic switch",\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(Code, {\n        children: /*#__PURE__*/(0,jsx_runtime.jsx)(switch_Switch, {\n          selected: isSelected,\n          onChange: function onChange() {\n            return setSelected(function (v) {\n              return !v;\n            });\n          }\n        })\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Section, {\n      title: "Disabled switch",\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(Code, {\n        children: /*#__PURE__*/(0,jsx_runtime.jsx)(switch_Switch, {\n          disabled: true\n        })\n      })\n    })]\n  });\n}\n;// CONCATENATED MODULE: ./docs/src/pages/Tabs/index.jsx\nfunction Tabs_slicedToArray(arr, i) { return Tabs_arrayWithHoles(arr) || Tabs_iterableToArrayLimit(arr, i) || Tabs_unsupportedIterableToArray(arr, i) || Tabs_nonIterableRest(); }\n\nfunction Tabs_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction Tabs_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return Tabs_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return Tabs_arrayLikeToArray(o, minLen); }\n\nfunction Tabs_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction Tabs_iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction Tabs_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\n\n\n\n\n\n\n\nvar Tabs_id = \'tabs\';\nvar Tabs_title = \'Tabs\';\nvar Tabs_description = \'Tabs organize content across different screens, data sets, and other interactions.\';\nvar Tabs_links = {\n  docs: \'https://github.com/material-components/material-components-web/tree/master/packages/mdc-tab-bar\',\n  guide: \'https://material.io/components/tabs\'\n};\nfunction Tabs_SwitchPage() {\n  var _useState = (0,react.useState)(0),\n      _useState2 = Tabs_slicedToArray(_useState, 2),\n      basic = _useState2[0],\n      setBasic = _useState2[1];\n\n  var _useState3 = (0,react.useState)(0),\n      _useState4 = Tabs_slicedToArray(_useState3, 2),\n      minWidth = _useState4[0],\n      setMinWidth = _useState4[1];\n\n  var _useState5 = (0,react.useState)(0),\n      _useState6 = Tabs_slicedToArray(_useState5, 2),\n      minWidthIndicator = _useState6[0],\n      setMinWidthIndicator = _useState6[1];\n\n  var _useState7 = (0,react.useState)(0),\n      _useState8 = Tabs_slicedToArray(_useState7, 2),\n      minWidthWithMinWidthIndicator = _useState8[0],\n      setMinWidthWithMinWidthIndicator = _useState8[1];\n\n  var _useState9 = (0,react.useState)(0),\n      _useState10 = Tabs_slicedToArray(_useState9, 2),\n      fade = _useState10[0],\n      setFade = _useState10[1];\n\n  var _useState11 = (0,react.useState)(0),\n      _useState12 = Tabs_slicedToArray(_useState11, 2),\n      icons = _useState12[0],\n      setIcons = _useState12[1];\n\n  var _useState13 = (0,react.useState)(0),\n      _useState14 = Tabs_slicedToArray(_useState13, 2),\n      stackedIcons = _useState14[0],\n      setStackedIcons = _useState14[1];\n\n  var _useState15 = (0,react.useState)(0),\n      _useState16 = Tabs_slicedToArray(_useState15, 2),\n      onlyIcons = _useState16[0],\n      setOnlyIcons = _useState16[1];\n\n  var _useState17 = (0,react.useState)(0),\n      _useState18 = Tabs_slicedToArray(_useState17, 2),\n      iconIndicator = _useState18[0],\n      setIconIndicator = _useState18[1];\n\n  var _useState19 = (0,react.useState)(0),\n      _useState20 = Tabs_slicedToArray(_useState19, 2),\n      scroll = _useState20[0],\n      setScroll = _useState20[1];\n\n  return /*#__PURE__*/(0,jsx_runtime.jsxs)(Page, {\n    id: Tabs_id,\n    title: Tabs_title,\n    description: Tabs_description,\n    links: Tabs_links,\n    children: [/*#__PURE__*/(0,jsx_runtime.jsx)(Section, {\n      title: "Basic tabs",\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(Code, {\n        children: /*#__PURE__*/(0,jsx_runtime.jsxs)(tabs_TabBar, {\n          value: basic,\n          onChange: function onChange(value) {\n            return setBasic(value);\n          },\n          children: [/*#__PURE__*/(0,jsx_runtime.jsx)(tabs_Tab, {\n            label: "Tab 1"\n          }), /*#__PURE__*/(0,jsx_runtime.jsx)(tabs_Tab, {\n            label: "Tab 2"\n          }), /*#__PURE__*/(0,jsx_runtime.jsx)(tabs_Tab, {\n            label: "Tab 3"\n          })]\n        })\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Section, {\n      title: "Min width tabs",\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(Code, {\n        children: /*#__PURE__*/(0,jsx_runtime.jsxs)(tabs_TabBar, {\n          value: minWidth,\n          minWidth: true,\n          onChange: function onChange(value) {\n            return setMinWidth(value);\n          },\n          children: [/*#__PURE__*/(0,jsx_runtime.jsx)(tabs_Tab, {\n            label: "Tab 1"\n          }), /*#__PURE__*/(0,jsx_runtime.jsx)(tabs_Tab, {\n            label: "Tab 2"\n          }), /*#__PURE__*/(0,jsx_runtime.jsx)(tabs_Tab, {\n            label: "Tab 3"\n          })]\n        })\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Section, {\n      title: "Tabs with min width indicator",\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(Code, {\n        children: /*#__PURE__*/(0,jsx_runtime.jsxs)(tabs_TabBar, {\n          value: minWidthIndicator,\n          minWidthIndicator: true,\n          onChange: function onChange(value) {\n            return setMinWidthIndicator(value);\n          },\n          children: [/*#__PURE__*/(0,jsx_runtime.jsx)(tabs_Tab, {\n            label: "Tab 1"\n          }), /*#__PURE__*/(0,jsx_runtime.jsx)(tabs_Tab, {\n            label: "Tab 2"\n          }), /*#__PURE__*/(0,jsx_runtime.jsx)(tabs_Tab, {\n            label: "Tab 3"\n          })]\n        })\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Section, {\n      title: "Min width tabs with min width indicator",\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(Code, {\n        children: /*#__PURE__*/(0,jsx_runtime.jsxs)(tabs_TabBar, {\n          value: minWidthWithMinWidthIndicator,\n          minWidth: true,\n          minWidthIndicator: true,\n          onChange: function onChange(value) {\n            return setMinWidthWithMinWidthIndicator(value);\n          },\n          children: [/*#__PURE__*/(0,jsx_runtime.jsx)(tabs_Tab, {\n            label: "Tab 1"\n          }), /*#__PURE__*/(0,jsx_runtime.jsx)(tabs_Tab, {\n            label: "Tab 2"\n          }), /*#__PURE__*/(0,jsx_runtime.jsx)(tabs_Tab, {\n            label: "Tab 3"\n          })]\n        })\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Section, {\n      title: "Tabs with fading indicator",\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(Code, {\n        children: /*#__PURE__*/(0,jsx_runtime.jsxs)(tabs_TabBar, {\n          value: fade,\n          fade: true,\n          onChange: function onChange(value) {\n            return setFade(value);\n          },\n          children: [/*#__PURE__*/(0,jsx_runtime.jsx)(tabs_Tab, {\n            label: "Tab 1"\n          }), /*#__PURE__*/(0,jsx_runtime.jsx)(tabs_Tab, {\n            label: "Tab 2"\n          }), /*#__PURE__*/(0,jsx_runtime.jsx)(tabs_Tab, {\n            label: "Tab 3"\n          })]\n        })\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Section, {\n      title: "Tabs with icons",\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(Code, {\n        children: /*#__PURE__*/(0,jsx_runtime.jsxs)(tabs_TabBar, {\n          value: icons,\n          onChange: function onChange(value) {\n            return setIcons(value);\n          },\n          children: [/*#__PURE__*/(0,jsx_runtime.jsx)(tabs_Tab, {\n            icon: "star",\n            label: "Tab 1"\n          }), /*#__PURE__*/(0,jsx_runtime.jsx)(tabs_Tab, {\n            icon: "favorite",\n            label: "Tab 2"\n          }), /*#__PURE__*/(0,jsx_runtime.jsx)(tabs_Tab, {\n            icon: "settings",\n            label: "Tab 3"\n          })]\n        })\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Section, {\n      title: "Tabs with stacked icons",\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(Code, {\n        children: /*#__PURE__*/(0,jsx_runtime.jsxs)(tabs_TabBar, {\n          value: stackedIcons,\n          stacked: true,\n          onChange: function onChange(value) {\n            return setStackedIcons(value);\n          },\n          children: [/*#__PURE__*/(0,jsx_runtime.jsx)(tabs_Tab, {\n            icon: "star",\n            label: "Tab 1"\n          }), /*#__PURE__*/(0,jsx_runtime.jsx)(tabs_Tab, {\n            icon: "favorite",\n            label: "Tab 2"\n          }), /*#__PURE__*/(0,jsx_runtime.jsx)(tabs_Tab, {\n            icon: "settings",\n            label: "Tab 3"\n          })]\n        })\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Section, {\n      title: "Tabs with icons only",\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(Code, {\n        children: /*#__PURE__*/(0,jsx_runtime.jsxs)(tabs_TabBar, {\n          value: onlyIcons,\n          indicatorIcon: "star",\n          onChange: function onChange(value) {\n            return setOnlyIcons(value);\n          },\n          children: [/*#__PURE__*/(0,jsx_runtime.jsx)(tabs_Tab, {\n            icon: "star"\n          }), /*#__PURE__*/(0,jsx_runtime.jsx)(tabs_Tab, {\n            icon: "favorite"\n          }), /*#__PURE__*/(0,jsx_runtime.jsx)(tabs_Tab, {\n            icon: "settings"\n          })]\n        })\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Section, {\n      title: "Tabs with icon indicator",\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(Code, {\n        children: /*#__PURE__*/(0,jsx_runtime.jsxs)(tabs_TabBar, {\n          value: iconIndicator,\n          onChange: function onChange(value) {\n            return setIconIndicator(value);\n          },\n          children: [/*#__PURE__*/(0,jsx_runtime.jsx)(tabs_Tab, {\n            label: "Tab 1"\n          }), /*#__PURE__*/(0,jsx_runtime.jsx)(tabs_Tab, {\n            label: "Tab 2"\n          }), /*#__PURE__*/(0,jsx_runtime.jsx)(tabs_Tab, {\n            label: "Tab 3"\n          })]\n        })\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Section, {\n      title: "Scrolling tabs",\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(Code, {\n        children: /*#__PURE__*/(0,jsx_runtime.jsxs)(tabs_TabBar, {\n          value: scroll,\n          onChange: function onChange(value) {\n            return setScroll(value);\n          },\n          children: [/*#__PURE__*/(0,jsx_runtime.jsx)(tabs_Tab, {\n            label: "Tab 1"\n          }), /*#__PURE__*/(0,jsx_runtime.jsx)(tabs_Tab, {\n            label: "Tab 2"\n          }), /*#__PURE__*/(0,jsx_runtime.jsx)(tabs_Tab, {\n            label: "Tab 3"\n          }), /*#__PURE__*/(0,jsx_runtime.jsx)(tabs_Tab, {\n            label: "Tab 4"\n          }), /*#__PURE__*/(0,jsx_runtime.jsx)(tabs_Tab, {\n            label: "Tab 5"\n          }), /*#__PURE__*/(0,jsx_runtime.jsx)(tabs_Tab, {\n            label: "Tab 6"\n          }), /*#__PURE__*/(0,jsx_runtime.jsx)(tabs_Tab, {\n            label: "Tab 7"\n          }), /*#__PURE__*/(0,jsx_runtime.jsx)(tabs_Tab, {\n            label: "Tab 8"\n          }), /*#__PURE__*/(0,jsx_runtime.jsx)(tabs_Tab, {\n            label: "Tab 9"\n          }), /*#__PURE__*/(0,jsx_runtime.jsx)(tabs_Tab, {\n            label: "Tab 10"\n          }), /*#__PURE__*/(0,jsx_runtime.jsx)(tabs_Tab, {\n            label: "Tab 11"\n          }), /*#__PURE__*/(0,jsx_runtime.jsx)(tabs_Tab, {\n            label: "Tab 12"\n          }), /*#__PURE__*/(0,jsx_runtime.jsx)(tabs_Tab, {\n            label: "Tab 13"\n          }), /*#__PURE__*/(0,jsx_runtime.jsx)(tabs_Tab, {\n            label: "Tab 14"\n          }), /*#__PURE__*/(0,jsx_runtime.jsx)(tabs_Tab, {\n            label: "Tab 15"\n          })]\n        })\n      })\n    })]\n  });\n}\n;// CONCATENATED MODULE: ./docs/src/pages/TextField/index.jsx\nfunction pages_TextField_slicedToArray(arr, i) { return pages_TextField_arrayWithHoles(arr) || pages_TextField_iterableToArrayLimit(arr, i) || pages_TextField_unsupportedIterableToArray(arr, i) || pages_TextField_nonIterableRest(); }\n\nfunction pages_TextField_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction pages_TextField_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return pages_TextField_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return pages_TextField_arrayLikeToArray(o, minLen); }\n\nfunction pages_TextField_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction pages_TextField_iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction pages_TextField_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\n\n\n\n\n\n\n\nvar TextField_id = \'text-field\';\nvar TextField_title = \'Text Field\';\nvar TextField_description = \'Text fields let users enter and edit text.\';\nvar TextField_links = {\n  docs: \'https://github.com/material-components/material-components-web/tree/master/packages/mdc-textfield\',\n  guide: \'https://material.io/components/text-fields\'\n};\nfunction TypographyPage() {\n  var _useState = (0,react.useState)(\'filled\'),\n      _useState2 = pages_TextField_slicedToArray(_useState, 2),\n      type = _useState2[0],\n      setType = _useState2[1];\n\n  var isFilled = type === \'filled\' || undefined;\n  var isOutlined = type === \'outlined\' || undefined;\n  return /*#__PURE__*/(0,jsx_runtime.jsxs)(Page, {\n    id: TextField_id,\n    title: TextField_title,\n    description: TextField_description,\n    links: TextField_links,\n    children: [/*#__PURE__*/(0,jsx_runtime.jsxs)(tabs_TabBar, {\n      value: type,\n      onChange: setType,\n      minWidth: true,\n      children: [/*#__PURE__*/(0,jsx_runtime.jsx)(tabs_Tab, {\n        value: "filled",\n        label: "Filled"\n      }), /*#__PURE__*/(0,jsx_runtime.jsx)(tabs_Tab, {\n        value: "outlined",\n        label: "Outlined"\n      })]\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Section, {\n      title: "Basic text field",\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(Code, {\n        children: /*#__PURE__*/(0,jsx_runtime.jsx)(text_field_TextField, {\n          defaultValue: "",\n          filled: isFilled,\n          outlined: isOutlined\n        })\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Section, {\n      title: "Text field with a label",\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(Code, {\n        children: /*#__PURE__*/(0,jsx_runtime.jsx)(text_field_TextField, {\n          defaultValue: "",\n          label: "Label",\n          filled: isFilled,\n          outlined: isOutlined\n        })\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Section, {\n      title: "Textarea",\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(Code, {\n        children: /*#__PURE__*/(0,jsx_runtime.jsx)(text_field_TextField, {\n          defaultValue: "",\n          label: "Label",\n          textarea: true,\n          filled: isFilled,\n          outlined: isOutlined\n        })\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Section, {\n      title: "Autoresizable textarea",\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(Code, {\n        children: /*#__PURE__*/(0,jsx_runtime.jsx)(text_field_TextField, {\n          defaultValue: "",\n          label: "Label",\n          textarea: true,\n          autoResize: true,\n          filled: isFilled,\n          outlined: isOutlined\n        })\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Section, {\n      title: "Pre-filled text field",\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(Code, {\n        children: /*#__PURE__*/(0,jsx_runtime.jsx)(text_field_TextField, {\n          defaultValue: "Some text",\n          label: "Label",\n          filled: isFilled,\n          outlined: isOutlined\n        })\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Section, {\n      title: "With helper text",\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(Code, {\n        children: /*#__PURE__*/(0,jsx_runtime.jsx)(text_field_TextField, {\n          defaultValue: "",\n          helperText: "Helper text",\n          filled: isFilled,\n          outlined: isOutlined\n        })\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Section, {\n      title: "With persistent helper text",\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(Code, {\n        children: /*#__PURE__*/(0,jsx_runtime.jsx)(text_field_TextField, {\n          defaultValue: "",\n          persistentHelperText: "Helper text",\n          filled: isFilled,\n          outlined: isOutlined\n        })\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Section, {\n      title: "Text field with validation message",\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(Code, {\n        children: /*#__PURE__*/(0,jsx_runtime.jsx)(text_field_TextField, {\n          defaultValue: "",\n          label: "Label",\n          required: true,\n          validationMessage: "Validation message",\n          filled: isFilled,\n          outlined: isOutlined\n        })\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Section, {\n      title: "Text field with a character counter",\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(Code, {\n        children: /*#__PURE__*/(0,jsx_runtime.jsx)(text_field_TextField, {\n          defaultValue: "",\n          label: "Label",\n          maxLength: 10,\n          filled: isFilled,\n          outlined: isOutlined\n        })\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Section, {\n      title: "Text field with an internal character counter",\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(Code, {\n        children: /*#__PURE__*/(0,jsx_runtime.jsx)(text_field_TextField, {\n          defaultValue: "",\n          label: "Label",\n          maxLength: 120,\n          filled: isFilled,\n          outlined: isOutlined,\n          textarea: true,\n          internalCounter: true\n        })\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Section, {\n      title: "Text field with a prefix",\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(Code, {\n        children: /*#__PURE__*/(0,jsx_runtime.jsx)(text_field_TextField, {\n          defaultValue: "",\n          label: "Label",\n          prefix: "@",\n          filled: isFilled,\n          outlined: isOutlined\n        })\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Section, {\n      title: "Text field with a suffix",\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(Code, {\n        children: /*#__PURE__*/(0,jsx_runtime.jsx)(text_field_TextField, {\n          defaultValue: "",\n          label: "Label",\n          suffix: "$",\n          filled: isFilled,\n          outlined: isOutlined\n        })\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Section, {\n      title: "Text field with a leading icon",\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(Code, {\n        children: /*#__PURE__*/(0,jsx_runtime.jsx)(text_field_TextField, {\n          defaultValue: "",\n          leadingIcon: "star",\n          filled: isFilled,\n          outlined: isOutlined\n        })\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Section, {\n      title: "Text field with a trailing icon",\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(Code, {\n        children: /*#__PURE__*/(0,jsx_runtime.jsx)(text_field_TextField, {\n          defaultValue: "",\n          trailingIcon: "edit",\n          filled: isFilled,\n          outlined: isOutlined\n        })\n      })\n    })]\n  });\n}\n;// CONCATENATED MODULE: ./docs/src/pages/Tooltip/index.jsx\n\n\n\n\n\n\nvar Tooltip_id = \'tooltip\';\nvar Tooltip_title = \'Tooltip\';\nvar Tooltip_description = \'Tooltips display informative text when users hover over, focus on, or tap an element.\';\nvar Tooltip_links = {\n  docs: \'https://github.com/material-components/material-components-web/tree/master/packages/mdc-tooltip\',\n  guide: \'https://material.io/components/tooltips\'\n};\nfunction TooltipPage() {\n  return /*#__PURE__*/(0,jsx_runtime.jsxs)(Page, {\n    id: Tooltip_id,\n    title: Tooltip_title,\n    description: Tooltip_description,\n    links: Tooltip_links,\n    children: [/*#__PURE__*/(0,jsx_runtime.jsx)(Section, {\n      title: "Basic tooltip",\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(Code, {\n        children: /*#__PURE__*/(0,jsx_runtime.jsx)(tooltip_Tooltip, {\n          label: "Star",\n          children: /*#__PURE__*/(0,jsx_runtime.jsx)(icon_button_IconButton, {\n            icon: "star"\n          })\n        })\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Section, {\n      title: "Multiline tooltip",\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(Code, {\n        children: /*#__PURE__*/(0,jsx_runtime.jsx)(tooltip_Tooltip, {\n          label: "This is a star icon button, you should click on it",\n          children: /*#__PURE__*/(0,jsx_runtime.jsx)(icon_button_IconButton, {\n            icon: "star"\n          })\n        })\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Section, {\n      title: "Rich tooltip",\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(Code, {\n        children: /*#__PURE__*/(0,jsx_runtime.jsx)(tooltip_RichTooltip, {\n          title: "Title",\n          content: "Default rich tooltips are shown when users hover over or focus on their anchor element. They remain shown when users focus/hover over the contents of the rich tooltip, but becomes hidden if the users focus/hover outside of the anchor element or the tooltip contents. If the user clicks within the contents of the tooltip, the tooltip will also be hidden.",\n          children: /*#__PURE__*/(0,jsx_runtime.jsx)(icon_button_IconButton, {\n            icon: "star"\n          })\n        })\n      })\n    })]\n  });\n}\n;// CONCATENATED MODULE: ./docs/src/pages/TopAppBar/index.jsx\nfunction pages_TopAppBar_slicedToArray(arr, i) { return pages_TopAppBar_arrayWithHoles(arr) || pages_TopAppBar_iterableToArrayLimit(arr, i) || pages_TopAppBar_unsupportedIterableToArray(arr, i) || pages_TopAppBar_nonIterableRest(); }\n\nfunction pages_TopAppBar_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction pages_TopAppBar_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return pages_TopAppBar_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return pages_TopAppBar_arrayLikeToArray(o, minLen); }\n\nfunction pages_TopAppBar_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction pages_TopAppBar_iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction pages_TopAppBar_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\n\n\n\n\n\n\n\n\nvar TopAppBar_id = \'top-app-bar\';\nvar TopAppBar_title = \'Top App Bar\';\nvar TopAppBar_description = \'The top app bar displays information and actions relating to the current screen.\';\nvar TopAppBar_links = {\n  docs: \'https://github.com/material-components/material-components-web/tree/master/packages/mdc-top-app-bar\',\n  guide: \'https://material.io/components/app-bars-top\'\n};\nfunction TopAppBarPage() {\n  var _useState = (0,react.useState)(false),\n      _useState2 = pages_TopAppBar_slicedToArray(_useState, 2),\n      isCollapsed = _useState2[0],\n      setCollapsed = _useState2[1];\n\n  var actionItems = [/*#__PURE__*/(0,jsx_runtime.jsx)(icon_button_IconButton, {\n    icon: "add"\n  }, "add"), /*#__PURE__*/(0,jsx_runtime.jsx)(icon_button_IconButton, {\n    icon: "edit"\n  }, "edit"), /*#__PURE__*/(0,jsx_runtime.jsx)(icon_button_IconButton, {\n    icon: "delete"\n  }, "delete")];\n  return /*#__PURE__*/(0,jsx_runtime.jsxs)(Page, {\n    id: TopAppBar_id,\n    title: TopAppBar_title,\n    description: TopAppBar_description,\n    links: TopAppBar_links,\n    children: [/*#__PURE__*/(0,jsx_runtime.jsx)(Section, {\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(Code, {\n        children: /*#__PURE__*/(0,jsx_runtime.jsx)(top_app_bar_TopAppBar, {\n          title: "Basic",\n          navigationIcon: "menu",\n          actionItems: actionItems\n        })\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Section, {\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(Code, {\n        children: /*#__PURE__*/(0,jsx_runtime.jsx)(top_app_bar_TopAppBar, {\n          title: "Dense",\n          navigationIcon: "menu",\n          actionItems: actionItems,\n          dense: true\n        })\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Section, {\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(Code, {\n        children: /*#__PURE__*/(0,jsx_runtime.jsx)(top_app_bar_TopAppBar, {\n          title: "Prominent",\n          navigationIcon: "menu",\n          actionItems: actionItems,\n          prominent: true\n        })\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Section, {\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(Code, {\n        children: /*#__PURE__*/(0,jsx_runtime.jsx)(top_app_bar_TopAppBar, {\n          title: "Short",\n          navigationIcon: "menu",\n          "short": true,\n          collapsed: isCollapsed,\n          onNavigationIconClick: function onNavigationIconClick() {\n            return setCollapsed(function (v) {\n              return !v;\n            });\n          }\n        })\n      })\n    })]\n  });\n}\n;// CONCATENATED MODULE: ./docs/src/pages/Typography/index.jsx\n\n\n\n\n\n\nvar Typography_id = \'typography\';\nvar Typography_title = \'Typography\';\nvar Typography_description = \'Typography expresses hierarchy and brand presence.\';\nvar Typography_links = {\n  docs: \'https://github.com/material-components/material-components-web/tree/master/packages/mdc-typography\',\n  guide: \'https://material.io/design/typography\'\n};\nfunction Typography_TypographyPage() {\n  return /*#__PURE__*/(0,jsx_runtime.jsxs)(Page, {\n    id: Typography_id,\n    title: Typography_title,\n    description: Typography_description,\n    links: Typography_links,\n    children: [/*#__PURE__*/(0,jsx_runtime.jsx)(Section, {\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(Code, {\n        children: /*#__PURE__*/(0,jsx_runtime.jsx)(typography_Typography, {\n          type: "headline1",\n          noMargin: true,\n          children: "Headline 1"\n        })\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Section, {\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(Code, {\n        children: /*#__PURE__*/(0,jsx_runtime.jsx)(typography_Typography, {\n          type: "headline2",\n          noMargin: true,\n          children: "Headline 2"\n        })\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Section, {\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(Code, {\n        children: /*#__PURE__*/(0,jsx_runtime.jsx)(typography_Typography, {\n          type: "headline3",\n          noMargin: true,\n          children: "Headline 3"\n        })\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Section, {\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(Code, {\n        children: /*#__PURE__*/(0,jsx_runtime.jsx)(typography_Typography, {\n          type: "headline4",\n          noMargin: true,\n          children: "Headline 4"\n        })\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Section, {\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(Code, {\n        children: /*#__PURE__*/(0,jsx_runtime.jsx)(typography_Typography, {\n          type: "headline5",\n          noMargin: true,\n          children: "Headline 5"\n        })\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Section, {\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(Code, {\n        children: /*#__PURE__*/(0,jsx_runtime.jsx)(typography_Typography, {\n          type: "headline6",\n          noMargin: true,\n          children: "Headline 6"\n        })\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Section, {\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(Code, {\n        children: /*#__PURE__*/(0,jsx_runtime.jsx)(typography_Typography, {\n          type: "subtitle1",\n          noMargin: true,\n          children: "Subtitle 1"\n        })\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Section, {\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(Code, {\n        children: /*#__PURE__*/(0,jsx_runtime.jsx)(typography_Typography, {\n          type: "subtitle2",\n          noMargin: true,\n          children: "Subtitle 2"\n        })\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Section, {\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(Code, {\n        children: /*#__PURE__*/(0,jsx_runtime.jsx)(typography_Typography, {\n          type: "body1",\n          noMargin: true,\n          children: "Body 1"\n        })\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Section, {\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(Code, {\n        children: /*#__PURE__*/(0,jsx_runtime.jsx)(typography_Typography, {\n          type: "body2",\n          noMargin: true,\n          children: "Body 2"\n        })\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Section, {\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(Code, {\n        children: /*#__PURE__*/(0,jsx_runtime.jsx)(typography_Typography, {\n          type: "caption",\n          children: "Caption"\n        })\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Section, {\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(Code, {\n        children: /*#__PURE__*/(0,jsx_runtime.jsx)(typography_Typography, {\n          type: "button",\n          children: "Button"\n        })\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Section, {\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(Code, {\n        children: /*#__PURE__*/(0,jsx_runtime.jsx)(typography_Typography, {\n          type: "overline",\n          children: "Overline"\n        })\n      })\n    })]\n  });\n}\n;// CONCATENATED MODULE: ./docs/src/pages/index.js\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n;// CONCATENATED MODULE: ./docs/src/routes.js\n\n/* harmony default export */ const routes = ([{\n  title: \'Avatar\',\n  url: \'/avatar\',\n  component: AvatarPage\n}, {\n  title: \'Badge\',\n  url: \'/badge\',\n  component: BadgePage\n}, {\n  title: \'Banner\',\n  url: \'/banner\',\n  component: Banner_BadgePage,\n  imageUrl: \'https://lh3.googleusercontent.com/tOZdWbfWtIc5GHTWsW0Daqj5I6lCCrUN8-YuEVjSn87JNN6x6PEjfmne-gpBo4jHBI4gqLmi0kLVpubF41ZT2mM8glkLzo2iWgK_-jY=w760-h380\'\n}, {\n  title: \'Button\',\n  url: \'/button\',\n  component: ButtonPage,\n  imageUrl: \'https://lh3.googleusercontent.com/GHRz-5S00u7WkRGl8iUm8ezoR6eoB2NJztu-trJv3raMDvpSACeQ5O0KOoAG7SRHJNDM_mT04Hei1NwjTN-ZsIFms_bsQ4zxRyxdQQ=w760-h380\'\n}, {\n  title: \'Card\',\n  url: \'/card\',\n  component: CardPage,\n  imageUrl: \'https://lh3.googleusercontent.com/FyE3qjGwwnoeMgiyOuIxdxTQQM9Cr0ftNakOXOA8cp137rKN09BFHraERm1NPUFBTGxVgchkdl6UABc11ZcJDML4ui466W2BFIxc9Q=w760-h380\'\n}, {\n  title: \'Checkbox\',\n  url: \'/checkbox\',\n  component: CheckboxPage\n}, {\n  title: \'Chips\',\n  url: \'/chips\',\n  component: ChipsPage\n}, {\n  title: \'Circular Progress\',\n  url: \'/circular-progress\',\n  component: CircularProgressPage\n}, {\n  title: \'DataTable\',\n  url: \'/data-table\',\n  component: DataTablePage\n}, {\n  title: \'Dialog\',\n  url: \'/dialog\',\n  component: DialogPage\n}, {\n  title: \'Drawer\',\n  url: \'/drawer\',\n  component: DrawerPage\n}, {\n  title: \'Elevation\',\n  url: \'/elevation\',\n  component: ElevationPage\n}, {\n  title: \'FAB\',\n  url: \'/fab\',\n  component: FABPage,\n  imageUrl: \'https://lh3.googleusercontent.com/T8dlYzaaU2SV86x6lqNMjlHcrFdKv85QMW1UnJShGwklRQyuUqZIklOjnEuqrZzF1h84ohrzz2ITajbT9IdljofNFmP5csEq6G7W=w760-h380\'\n}, {\n  title: \'Form Field\',\n  url: \'/form-field\',\n  component: FormFieldPage\n}, {\n  title: \'Icon Button\',\n  url: \'/icon-button\',\n  component: IconButtonPage\n}, {\n  title: \'Image List\',\n  url: \'/image-list\',\n  component: ImageListPage\n}, {\n  title: \'Layout Grid\',\n  url: \'/layout-grid\',\n  component: LayoutGridPage\n}, {\n  title: \'Linear Progress\',\n  url: \'/linear-progress\',\n  component: LinearProgressPage\n}, {\n  title: \'List\',\n  url: \'/list\',\n  component: ListPage\n}, {\n  title: \'Menu\',\n  url: \'/menu\',\n  component: MenuPage\n}, {\n  title: \'Radio\',\n  url: \'/radio\',\n  component: RadioPage\n}, {\n  title: \'Ripple\',\n  url: \'/ripple\',\n  component: Ripple_RadioPage\n}, {\n  title: \'Segmented Button\',\n  url: \'/segmented-button\',\n  component: SegmentedButtonPage,\n  imageUrl: \'\'\n}, {\n  title: \'Select\',\n  url: \'/select\',\n  component: SelectPage,\n  imageUrl: \'\'\n}, {\n  title: \'Side Sheet\',\n  url: \'/side-sheet\',\n  component: SideSheetPage,\n  imageUrl: \'\'\n}, {\n  title: \'Slider\',\n  url: \'/slider\',\n  component: SliderPage,\n  imageUrl: \'https://lh3.googleusercontent.com/w6nNeLcjpXypo2U6_gvunUesgTNOAqzEzb5ZzxxT4AyGH_M_L_EHrybg9sJNg78BDHyeCPIQCe3Hk2sTglU0EQe7cOBsqUMFicq1lg=w760-h380\'\n}, {\n  title: \'Snackbar\',\n  url: \'/snackbar\',\n  component: SnackbarPage,\n  imageUrl: \'https://lh3.googleusercontent.com/fGgZPDOszTD-2ReAC85l5op7wCE3uvnPta13Aib2bSlzN8LXoNYlDG6fY5DY1qKqbLTbGGlx9VgahUDdjDgdjq8sJNqoIY4-GPxKRA=w760-h380\'\n}, {\n  title: \'Switch\',\n  url: \'/switch\',\n  component: SwitchPage\n}, {\n  title: \'Tabs\',\n  url: \'/tabs\',\n  component: Tabs_SwitchPage,\n  imageUrl: \'https://lh3.googleusercontent.com/AYFp2VmMn9nslx18M6Es9C57S7p3zkiQVLl3PHvMu-OpbvK1FlLJN2MHfFNZfmfMCk1drCw84FKebz5STJ7QN69IHhH9WF1Kklir=w760-h380\'\n}, {\n  title: \'Text Field\',\n  url: \'/text-field\',\n  component: TypographyPage,\n  imageUrl: \'https://lh3.googleusercontent.com/Lxb_jZfXkASZ1DCzNhyS3IG7mIsPhBVmaX20Hn7XnwpS_Po9wQIC-5rEwUsYlb5TkgMjqI45-j1w4i4WM4wSlA-b0qKtmJ69hV0j=w760-h380\'\n}, {\n  title: \'Tooltip\',\n  url: \'/tooltip\',\n  component: TooltipPage,\n  imageUrl: \'https://lh3.googleusercontent.com/Asm1KHPsUD-GDDglcItzvl2LKWsyrMzKMrWDA5siHaF7PAvngniS57PMZTHFsDHkHsjT9dPWC5tEpRBG7i5syZ7sbRiRpL9oE84F=w760-h380\'\n}, {\n  title: \'Top App Bar\',\n  url: \'/top-app-bar\',\n  component: TopAppBarPage,\n  imageUrl: \'https://lh3.googleusercontent.com/eot96a-qjAr0QypKKf-6qSJGQQqW086-GV2vv0D9F358-VFiJSWifg6-q38vbI_JsxCPnbJNzjCH12OFDXJBzScB3h__HXLwKWkjYA=w760-h380\'\n}, {\n  title: \'Typography\',\n  url: \'/typography\',\n  component: Typography_TypographyPage\n}]);\n;// CONCATENATED MODULE: ./docs/src/App.jsx\n\n\n\n\n\n\n\nfunction App() {\n  return /*#__PURE__*/(0,jsx_runtime.jsxs)("div", {\n    className: "app",\n    children: [/*#__PURE__*/(0,jsx_runtime.jsx)(top_app_bar_TopAppBar, {\n      className: "app-top-bar",\n      navigationIcon: /*#__PURE__*/(0,jsx_runtime.jsx)(icon_button_IconButton, {\n        icon: /*#__PURE__*/(0,jsx_runtime.jsx)(Link, {\n          to: "/",\n          children: /*#__PURE__*/(0,jsx_runtime.jsx)("img", {\n            src: "https://material-components.github.io/material-components-web-catalog/static/media/ic_component_24px_white.svg",\n            alt: ""\n          })\n        })\n      }),\n      title: "MDC React",\n      actionItems: [/*#__PURE__*/(0,jsx_runtime.jsx)(icon_button_IconButton, {\n        element: "a",\n        href: "https://github.com/olegpolyakov/mdc-react",\n        target: "_blank",\n        icon: "code",\n        title: "Code"\n      }, "code"), /*#__PURE__*/(0,jsx_runtime.jsx)(icon_button_IconButton, {\n        element: "a",\n        href: "https://github.com/olegpolyakov/mdc-react/issues",\n        target: "_blank",\n        icon: "bug_report",\n        title: "Issues"\n      }, "issues"), /*#__PURE__*/(0,jsx_runtime.jsx)(icon_button_IconButton, {\n        element: "a",\n        href: "https://github.com/olegpolyakov/mdc-react/discussions",\n        target: "_blank",\n        icon: "forum",\n        title: "Discussions"\n      }, "discussions")]\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(drawer_Drawer, {\n      className: "app-drawer",\n      dismissible: true,\n      open: true,\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(drawer_Drawer.Content, {\n        children: /*#__PURE__*/(0,jsx_runtime.jsx)(list_List, {\n          element: "nav",\n          children: routes.map(function (route) {\n            return /*#__PURE__*/(0,jsx_runtime.jsx)(list_List.Item, {\n              component: NavLink,\n              to: route.url,\n              primaryText: route.title,\n              activeClassName: "mdc-list-item--activated"\n            }, route.url);\n          })\n        })\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)("main", {\n      className: "app-content mdc-drawer-app-content",\n      children: /*#__PURE__*/(0,jsx_runtime.jsxs)(Switch, {\n        children: [/*#__PURE__*/(0,jsx_runtime.jsx)(Route, {\n          exact: true,\n          path: "/",\n          component: HomePage\n        }), routes.map(function (route) {\n          return /*#__PURE__*/(0,jsx_runtime.jsx)(Route, {\n            path: route.url,\n            exact: route.exact,\n            component: route.component\n          }, route.url);\n        })]\n      })\n    })]\n  });\n}\n;// CONCATENATED MODULE: ./docs/src/index.js\n\n\n\n\n\n(0,react_dom.render)( /*#__PURE__*/(0,jsx_runtime.jsx)(BrowserRouter, {\n  basename: "mdc-react",\n  children: /*#__PURE__*/(0,jsx_runtime.jsx)(App, {})\n}), document.querySelector(\'#root\'));//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFFVDtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsUUFBUTtBQUNSLFFBQVEsTUFBcUMsR0FBRyxDQUErRztBQUMvSjtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0EsSUFBSSxNQUFxQyxHQUFHLENBQWdQO0FBQzVSO0FBQ0EsbUJBQW1CLHNCQUFjO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLFFBQVE7QUFDUixRQUFRLE1BQXFDLEdBQUcsQ0FBa0g7QUFDbEs7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVB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QUNsRDtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0Esd0NBQXdDLHNCQUFzQjtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0EsRUFBRSxjQUFjOztBQUVoQjtBQUNBOztBQUVBLHdFQUF3RSxhQUFhO0FBQ3JGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQixlQUFlO0FBQ2Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxpQkFBaUI7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFlBQVk7QUFDWjtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxZQUFZO0FBQ1o7QUFDQSxnQkFBZ0IsMENBQTBDO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxnREFBZ0Q7QUFDMUY7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLHFCQUFxQixxQkFBcUI7QUFDMUM7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMkRBQWUsVUFBVSxFQUFDOzs7QUMxckIxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSw0QkFBNEIsRUFBRSxhQUFhLEVBQUU7QUFDN0MsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0Es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QTtBQURKLE1BekRKO0FBQUEsSUFESjtBQTBFSCxDOztBQ3hGRDtBQUNBO0FBRUE7QUFFQTs7QUFFQVUsb0JBQU0sZUFDRixvQkFBQyxhQUFEO0FBQVEsVUFBUSxFQUFDLFdBQWpCO0FBQUEseUJBQ0ksb0JBQUMsR0FBRDtBQURKLEVBREUsRUFJRnZ6QixRQUFRLENBQUNvTyxhQUFULENBQXVCLE9BQXZCLENBSkUsQ0FBTiIsInNvdXJjZXMiOlsid2VicGFjazovL21kYy1yZWFjdC8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9zZXRQcm90b3R5cGVPZi5qcz8wNmQwIiwid2VicGFjazovL21kYy1yZWFjdC8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9pbmhlcml0c0xvb3NlLmpzPzkzYmQiLCJ3ZWJwYWNrOi8vbWRjLXJlYWN0Ly4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2V4dGVuZHMuanM/Yzc0ZSIsIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9ub2RlX21vZHVsZXMvcmVzb2x2ZS1wYXRobmFtZS9lc20vcmVzb2x2ZS1wYXRobmFtZS5qcz85NDIxIiwid2VicGFjazovL21kYy1yZWFjdC8uL25vZGVfbW9kdWxlcy90aW55LWludmFyaWFudC9kaXN0L3RpbnktaW52YXJpYW50LmVzbS5qcz9mNTFmIiwid2VicGFjazovL21kYy1yZWFjdC8uL25vZGVfbW9kdWxlcy9oaXN0b3J5L2VzbS9oaXN0b3J5LmpzPzJlMTAiLCJ3ZWJwYWNrOi8vbWRjLXJlYWN0Ly4vbm9kZV9tb2R1bGVzL21pbmktY3JlYXRlLXJlYWN0LWNvbnRleHQvZGlzdC9lc20vaW5kZXguanM/YjQ0OCIsIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZS5qcz9hYWM0Iiwid2VicGFjazovL21kYy1yZWFjdC8uL25vZGVfbW9kdWxlcy9yZWFjdC1yb3V0ZXIvZXNtL3JlYWN0LXJvdXRlci5qcz80ZjJlIiwid2VicGFjazovL21kYy1yZWFjdC8uL25vZGVfbW9kdWxlcy9yZWFjdC1yb3V0ZXItZG9tL2VzbS9yZWFjdC1yb3V0ZXItZG9tLmpzP2U3OTIiLCJ3ZWJwYWNrOi8vbWRjLXJlYWN0Ly4vc3JjL2NvbXBvbmVudC5qcz9hMjkwIiwid2VicGFjazovL21kYy1yZWFjdC8uL3NyYy9pY29uL2NvbnN0YW50cy5qcz9iNGRlIiwid2VicGFjazovL21kYy1yZWFjdC8uL3NyYy9pY29uL0ljb24uanN4PzNiYjkiLCJ3ZWJwYWNrOi8vbWRjLXJlYWN0Ly4vc3JjL2ljb24vaW5kZXguanM/YTZhNSIsIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9zcmMvYXZhdGFyL2NvbnN0YW50cy5qcz9iZmVlIiwid2VicGFjazovL21kYy1yZWFjdC8uL3NyYy9hdmF0YXIvQXZhdGFyLmpzeD8zYjAwIiwid2VicGFjazovL21kYy1yZWFjdC8uL3NyYy9hdmF0YXIvaW5kZXguanM/ZWQ3MSIsIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9zcmMvYmFkZ2UvY29uc3RhbnRzLmpzPzRmNDkiLCJ3ZWJwYWNrOi8vbWRjLXJlYWN0Ly4vc3JjL2JhZGdlL0JhZGdlLmpzeD83NjUxIiwid2VicGFjazovL21kYy1yZWFjdC8uL3NyYy9iYWRnZS9pbmRleC5qcz9jYjBjIiwid2VicGFjazovL21kYy1yZWFjdC8uL25vZGVfbW9kdWxlcy9kb20taGVscGVycy9lc20vaGFzQ2xhc3MuanM/Mjk3NSIsIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9ub2RlX21vZHVsZXMvZG9tLWhlbHBlcnMvZXNtL2FkZENsYXNzLmpzPzc2OTMiLCJ3ZWJwYWNrOi8vbWRjLXJlYWN0Ly4vbm9kZV9tb2R1bGVzL2RvbS1oZWxwZXJzL2VzbS9yZW1vdmVDbGFzcy5qcz9kNWE5Iiwid2VicGFjazovL21kYy1yZWFjdC8uL25vZGVfbW9kdWxlcy9yZWFjdC10cmFuc2l0aW9uLWdyb3VwL2VzbS9jb25maWcuanM/MmE0MiIsIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9ub2RlX21vZHVsZXMvcmVhY3QtdHJhbnNpdGlvbi1ncm91cC9lc20vVHJhbnNpdGlvbkdyb3VwQ29udGV4dC5qcz9kMGY0Iiwid2VicGFjazovL21kYy1yZWFjdC8uL25vZGVfbW9kdWxlcy9yZWFjdC10cmFuc2l0aW9uLWdyb3VwL2VzbS9UcmFuc2l0aW9uLmpzPzc1MWIiLCJ3ZWJwYWNrOi8vbWRjLXJlYWN0Ly4vbm9kZV9tb2R1bGVzL3JlYWN0LXRyYW5zaXRpb24tZ3JvdXAvZXNtL0NTU1RyYW5zaXRpb24uanM/YTUwZiIsIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9zcmMvYmFubmVyL2NvbnN0YW50cy5qcz9kODg4Iiwid2VicGFjazovL21kYy1yZWFjdC8uL3NyYy9iYW5uZXIvQmFubmVyLmpzeD9lMjJiIiwid2VicGFjazovL21kYy1yZWFjdC8uL3NyYy9iYW5uZXIvaW5kZXguanM/YzgwYSIsIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9zcmMvYnV0dG9uL2NvbnN0YW50cy5qcz9lNTY0Iiwid2VicGFjazovL21kYy1yZWFjdC8uL3NyYy9idXR0b24vQnV0dG9uLmpzeD9iYWQ0Iiwid2VicGFjazovL21kYy1yZWFjdC8uL3NyYy9idXR0b24vaW5kZXguanM/MjA4ZiIsIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9zcmMvY2FyZC9jb25zdGFudHMuanM/ZTE3ZiIsIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9zcmMvY2FyZC9DYXJkLmpzeD80MTUyIiwid2VicGFjazovL21kYy1yZWFjdC8uL3NyYy9jYXJkL0NhcmRBY3Rpb24uanN4P2JkZmYiLCJ3ZWJwYWNrOi8vbWRjLXJlYWN0Ly4vc3JjL2NhcmQvQ2FyZEFjdGlvbnMuanN4P2NmNTQiLCJ3ZWJwYWNrOi8vbWRjLXJlYWN0Ly4vc3JjL2NhcmQvQ2FyZEFjdGlvbkJ1dHRvbnMuanN4PzJmNGUiLCJ3ZWJwYWNrOi8vbWRjLXJlYWN0Ly4vc3JjL2NhcmQvQ2FyZEFjdGlvbkljb25zLmpzeD81Y2U5Iiwid2VicGFjazovL21kYy1yZWFjdC8uL3NyYy9jYXJkL0NhcmRIZWFkZXIuanN4PzAxMGUiLCJ3ZWJwYWNrOi8vbWRjLXJlYWN0Ly4vc3JjL2NhcmQvQ2FyZE1lZGlhLmpzeD84Nzk5Iiwid2VicGFjazovL21kYy1yZWFjdC8uL3NyYy9jYXJkL0NhcmRQcmltYXJ5QWN0aW9uLmpzeD80OTA3Iiwid2VicGFjazovL21kYy1yZWFjdC8uL3NyYy9jYXJkL0NhcmRTZWN0aW9uLmpzeD9mOTk1Iiwid2VicGFjazovL21kYy1yZWFjdC8uL3NyYy9jYXJkL2luZGV4LmpzPzUyM2UiLCJ3ZWJwYWNrOi8vbWRjLXJlYWN0Ly4vc3JjL2NoZWNrYm94L2NvbnN0YW50cy5qcz9kOGMxIiwid2VicGFjazovL21kYy1yZWFjdC8uL3NyYy9jaGVja2JveC9DaGVja2JveC5qc3g/MzIxYyIsIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9zcmMvY2hlY2tib3gvaW5kZXguanM/MTBmYiIsIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9zcmMvY2hpcHMvY29uc3RhbnRzLmpzPzZmNjYiLCJ3ZWJwYWNrOi8vbWRjLXJlYWN0Ly4vc3JjL2NoaXBzL0NoaXBQcmltYXJ5QWN0aW9uLmpzeD9iMWI1Iiwid2VicGFjazovL21kYy1yZWFjdC8uL3NyYy9jaGlwcy9DaGlwVHJhaWxpbmdBY3Rpb24uanN4PzNlNzAiLCJ3ZWJwYWNrOi8vbWRjLXJlYWN0Ly4vc3JjL2NoaXBzL0NoaXAuanN4P2EzNWQiLCJ3ZWJwYWNrOi8vbWRjLXJlYWN0Ly4vc3JjL3R5cGVzLmpzPzY3OTIiLCJ3ZWJwYWNrOi8vbWRjLXJlYWN0Ly4vc3JjL2NoaXBzL0NoaXBTZXQuanN4P2YwYjUiLCJ3ZWJwYWNrOi8vbWRjLXJlYWN0Ly4vc3JjL2NoaXBzL2luZGV4LmpzP2RhNDUiLCJ3ZWJwYWNrOi8vbWRjLXJlYWN0Ly4vc3JjL2NpcmN1bGFyLXByb2dyZXNzL2NvbnN0YW50cy5qcz8xMzA5Iiwid2VicGFjazovL21kYy1yZWFjdC8uL3NyYy9jaXJjdWxhci1wcm9ncmVzcy9DaXJjdWxhclByb2dyZXNzLmpzeD8yMGFhIiwid2VicGFjazovL21kYy1yZWFjdC8uL3NyYy9jaXJjdWxhci1wcm9ncmVzcy9pbmRleC5qcz8xYjU0Iiwid2VicGFjazovL21kYy1yZWFjdC8uL3NyYy9pY29uLWJ1dHRvbi9jb25zdGFudHMuanM/MjFlNiIsIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9zcmMvaWNvbi1idXR0b24vSWNvbkJ1dHRvbi5qc3g/ODRmZiIsIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9zcmMvaWNvbi1idXR0b24vaW5kZXguanM/MTliMiIsIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9zcmMvbGluZWFyLXByb2dyZXNzL2NvbnN0YW50cy5qcz81ZTliIiwid2VicGFjazovL21kYy1yZWFjdC8uL3NyYy9saW5lYXItcHJvZ3Jlc3MvTGluZWFyUHJvZ3Jlc3MuanN4P2RhMmIiLCJ3ZWJwYWNrOi8vbWRjLXJlYWN0Ly4vc3JjL2xpbmVhci1wcm9ncmVzcy9pbmRleC5qcz9jOTQ4Iiwid2VicGFjazovL21kYy1yZWFjdC8uL3NyYy9kYXRhLXRhYmxlL2NvbnN0YW50cy5qcz9iNGM3Iiwid2VicGFjazovL21kYy1yZWFjdC8uL3NyYy9kYXRhLXRhYmxlL0RhdGFUYWJsZVByb2dyZXNzSW5kaWNhdG9yLmpzeD8xNTI5Iiwid2VicGFjazovL21kYy1yZWFjdC8uL3NyYy9mbG9hdGluZy1sYWJlbC9jb25zdGFudHMuanM/NWU0NCIsIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9zcmMvZmxvYXRpbmctbGFiZWwvRmxvYXRpbmdMYWJlbC5qc3g/NDlhNyIsIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9zcmMvZmxvYXRpbmctbGFiZWwvaW5kZXguanM/N2RiZCIsIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9zcmMvbGluZS1yaXBwbGUvY29uc3RhbnRzLmpzPzNjNzAiLCJ3ZWJwYWNrOi8vbWRjLXJlYWN0Ly4vc3JjL2xpbmUtcmlwcGxlL0xpbmVSaXBwbGUuanN4PzQ3NTIiLCJ3ZWJwYWNrOi8vbWRjLXJlYWN0Ly4vc3JjL2xpbmUtcmlwcGxlL2luZGV4LmpzPzBiYzkiLCJ3ZWJwYWNrOi8vbWRjLXJlYWN0Ly4vc3JjL25vdGNoZWQtb3V0bGluZS9jb25zdGFudHMuanM/Y2I4ZCIsIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9zcmMvbm90Y2hlZC1vdXRsaW5lL05vdGNoZWRPdXRsaW5lLmpzeD82OWU5Iiwid2VicGFjazovL21kYy1yZWFjdC8uL3NyYy9ub3RjaGVkLW91dGxpbmUvaW5kZXguanM/ZDY3ZSIsIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9zcmMvbWVudS9jb25zdGFudHMuanM/YWM0MCIsIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9zcmMvaG9va3MuanM/ZjcxMCIsIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9zcmMvbGlzdC9jb25zdGFudHMuanM/ODg4ZiIsIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9zcmMvbGlzdC9MaXN0SXRlbUNvbnRlbnQuanN4P2M5YWIiLCJ3ZWJwYWNrOi8vbWRjLXJlYWN0Ly4vc3JjL2xpc3QvTGlzdEl0ZW1FbmQuanN4PzNiNWUiLCJ3ZWJwYWNrOi8vbWRjLXJlYWN0Ly4vc3JjL2xpc3QvTGlzdEl0ZW1TdGFydC5qc3g/OGJjZSIsIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9zcmMvbGlzdC9MaXN0SXRlbS5qc3g/NTJkMSIsIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9zcmMvbGlzdC9MaXN0LmpzeD8zZWI5Iiwid2VicGFjazovL21kYy1yZWFjdC8uL3NyYy9saXN0L0xpc3REaXZpZGVyLmpzeD8zYmJhIiwid2VicGFjazovL21kYy1yZWFjdC8uL3NyYy9saXN0L0xpc3RHcm91cC5qc3g/YjZmNiIsIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9zcmMvbGlzdC9MaXN0R3JvdXBTdWJoZWFkZXIuanN4PzI5ZTUiLCJ3ZWJwYWNrOi8vbWRjLXJlYWN0Ly4vc3JjL2xpc3QvaW5kZXguanM/NTM1NCIsIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9zcmMvbWVudS9NZW51SXRlbS5qc3g/MzRjYSIsIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9zcmMvbW9kYWwvY29uc3RhbnRzLmpzPzZkNTMiLCJ3ZWJwYWNrOi8vbWRjLXJlYWN0Ly4vc3JjL21vZGFsL01vZGFsLmpzeD82M2ZjIiwid2VicGFjazovL21kYy1yZWFjdC8uL3NyYy9tb2RhbC9pbmRleC5qcz83ZTY4Iiwid2VicGFjazovL21kYy1yZWFjdC8uL3NyYy9sYXllci9MYXllci5qc3g/MzI0MSIsIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9zcmMvbGF5ZXIvaW5kZXguanM/ZGNlZSIsIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9zcmMvbWVudS91dGlscy5qcz9iODlmIiwid2VicGFjazovL21kYy1yZWFjdC8uL3NyYy9tZW51L01lbnVTdXJmYWNlLmpzeD9mODEyIiwid2VicGFjazovL21kYy1yZWFjdC8uL3NyYy9tZW51L01lbnUuanN4PzAxM2EiLCJ3ZWJwYWNrOi8vbWRjLXJlYWN0Ly4vc3JjL21lbnUvTWVudUFuY2hvci5qc3g/NmYxMCIsIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9zcmMvbWVudS9NZW51U2VsZWN0aW9uR3JvdXAuanN4PzA5MTAiLCJ3ZWJwYWNrOi8vbWRjLXJlYWN0Ly4vc3JjL21lbnUvTWVudVNlbGVjdGlvbkdyb3VwSWNvbi5qc3g/ZmE2OCIsIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9zcmMvbWVudS9pbmRleC5qcz84ZjU0Iiwid2VicGFjazovL21kYy1yZWFjdC8uL3NyYy9zZWxlY3QvY29uc3RhbnRzLmpzP2ZlYTkiLCJ3ZWJwYWNrOi8vbWRjLXJlYWN0Ly4vc3JjL3NlbGVjdC9Ecm9wZG93bkljb24uanN4P2I3ODUiLCJ3ZWJwYWNrOi8vbWRjLXJlYWN0Ly4vc3JjL3NlbGVjdC9TZWxlY3RPcHRpb24uanN4P2E2YWMiLCJ3ZWJwYWNrOi8vbWRjLXJlYWN0Ly4vc3JjL3NlbGVjdC9IZWxwZXJUZXh0LmpzeD82ZTUyIiwid2VicGFjazovL21kYy1yZWFjdC8uL3NyYy9zZWxlY3QvU2VsZWN0LmpzeD9jZDE0Iiwid2VicGFjazovL21kYy1yZWFjdC8uL3NyYy9zZWxlY3QvaW5kZXguanM/OWNkZCIsIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9zcmMvZGF0YS10YWJsZS9EYXRhVGFibGVQYWdpbmF0aW9uLmpzeD8yNGJhIiwid2VicGFjazovL21kYy1yZWFjdC8uL3NyYy9kYXRhLXRhYmxlL0RhdGFUYWJsZS5qc3g/MjM1OSIsIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9zcmMvZGF0YS10YWJsZS9EYXRhVGFibGVDZWxsLmpzeD9kYWVmIiwid2VicGFjazovL21kYy1yZWFjdC8uL3NyYy9kYXRhLXRhYmxlL0RhdGFUYWJsZUNvbnRlbnQuanN4P2I3MWYiLCJ3ZWJwYWNrOi8vbWRjLXJlYWN0Ly4vc3JjL2RhdGEtdGFibGUvRGF0YVRhYmxlRm9vdGVyLmpzeD9lY2VhIiwid2VicGFjazovL21kYy1yZWFjdC8uL3NyYy9kYXRhLXRhYmxlL0RhdGFUYWJsZUhlYWRlci5qc3g/MTA2NCIsIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9zcmMvZGF0YS10YWJsZS9EYXRhVGFibGVIZWFkZXJDZWxsLmpzeD8yOGRkIiwid2VicGFjazovL21kYy1yZWFjdC8uL3NyYy9kYXRhLXRhYmxlL0RhdGFUYWJsZUhlYWRlclJvdy5qc3g/YTIxMCIsIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9zcmMvZGF0YS10YWJsZS9EYXRhVGFibGVSb3cuanN4PzFhOWYiLCJ3ZWJwYWNrOi8vbWRjLXJlYWN0Ly4vc3JjL2RhdGEtdGFibGUvaW5kZXguanM/ZDhlNyIsIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9zcmMvZGlhbG9nL2NvbnN0YW50cy5qcz9iNDI5Iiwid2VicGFjazovL21kYy1yZWFjdC8uL3NyYy9kaWFsb2cvRGlhbG9nSGVhZGVyLmpzeD83MjExIiwid2VicGFjazovL21kYy1yZWFjdC8uL3NyYy9kaWFsb2cvRGlhbG9nQ29udGVudC5qc3g/ZmQ1NyIsIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9zcmMvZGlhbG9nL0RpYWxvZ0FjdGlvbnMuanN4PzE5NTIiLCJ3ZWJwYWNrOi8vbWRjLXJlYWN0Ly4vc3JjL2RpYWxvZy9EaWFsb2cuanN4P2MyYjUiLCJ3ZWJwYWNrOi8vbWRjLXJlYWN0Ly4vc3JjL2RpYWxvZy9pbmRleC5qcz80ZDgzIiwid2VicGFjazovL21kYy1yZWFjdC8uL3NyYy9kcmF3ZXIvY29uc3RhbnRzLmpzPzlkNjkiLCJ3ZWJwYWNrOi8vbWRjLXJlYWN0Ly4vc3JjL2RyYXdlci9EcmF3ZXIuanN4PzUwYWMiLCJ3ZWJwYWNrOi8vbWRjLXJlYWN0Ly4vc3JjL2RyYXdlci9EcmF3ZXJIZWFkZXIuanN4PzRjNDgiLCJ3ZWJwYWNrOi8vbWRjLXJlYWN0Ly4vc3JjL2RyYXdlci9EcmF3ZXJDb250ZW50LmpzeD9hNDY2Iiwid2VicGFjazovL21kYy1yZWFjdC8uL3NyYy9kcmF3ZXIvaW5kZXguanM/NzA4MyIsIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9zcmMvZWxldmF0aW9uL2NvbnN0YW50cy5qcz82NTVkIiwid2VicGFjazovL21kYy1yZWFjdC8uL3NyYy9lbGV2YXRpb24vRWxldmF0aW9uLmpzeD9jNDJiIiwid2VicGFjazovL21kYy1yZWFjdC8uL3NyYy9lbGV2YXRpb24vaW5kZXguanM/ODhlYSIsIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9zcmMvZmFiL2NvbnN0YW50cy5qcz80NzRmIiwid2VicGFjazovL21kYy1yZWFjdC8uL3NyYy9mYWIvRkFCLmpzeD84NTc4Iiwid2VicGFjazovL21kYy1yZWFjdC8uL3NyYy9mYWIvaW5kZXguanM/YWY3OCIsIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9zcmMvZm9ybS1maWVsZC9jb25zdGFudHMuanM/OWY5ZiIsIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9zcmMvZm9ybS1maWVsZC9Gb3JtRmllbGQuanN4Pzg1MjgiLCJ3ZWJwYWNrOi8vbWRjLXJlYWN0Ly4vc3JjL2Zvcm0tZmllbGQvaW5kZXguanM/NWVkMiIsIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9zcmMvaW1hZ2UtbGlzdC9jb25zdGFudHMuanM/YTdhNyIsIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9zcmMvaW1hZ2UtbGlzdC9JbWFnZUxpc3RJdGVtLmpzeD8zNjQ0Iiwid2VicGFjazovL21kYy1yZWFjdC8uL3NyYy9pbWFnZS1saXN0L0ltYWdlTGlzdC5qc3g/ZGYxMyIsIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9zcmMvaW1hZ2UtbGlzdC9pbmRleC5qcz81YWJjIiwid2VicGFjazovL21kYy1yZWFjdC8uL3NyYy9sYXlvdXQvY29uc3RhbnRzLmpzPzI3ZDUiLCJ3ZWJwYWNrOi8vbWRjLXJlYWN0Ly4vc3JjL2xheW91dC9MYXlvdXQuanN4P2I0MDEiLCJ3ZWJwYWNrOi8vbWRjLXJlYWN0Ly4vc3JjL2xheW91dC9pbmRleC5qcz9mMzc2Iiwid2VicGFjazovL21kYy1yZWFjdC8uL3NyYy9sYXlvdXQtZ3JpZC9jb25zdGFudHMuanM/YTg2MSIsIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9zcmMvbGF5b3V0LWdyaWQvTGF5b3V0R3JpZC5qc3g/ZTVhYSIsIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9zcmMvbGF5b3V0LWdyaWQvTGF5b3V0R3JpZENlbGwuanN4P2U2NzMiLCJ3ZWJwYWNrOi8vbWRjLXJlYWN0Ly4vc3JjL2xheW91dC1ncmlkL2luZGV4LmpzP2RjMTIiLCJ3ZWJwYWNrOi8vbWRjLXJlYWN0Ly4vc3JjL3JhZGlvL2NvbnN0YW50cy5qcz82NjY0Iiwid2VicGFjazovL21kYy1yZWFjdC8uL3NyYy9yYWRpby9SYWRpby5qc3g/MWZhZSIsIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9zcmMvcmFkaW8vaW5kZXguanM/Mjc5MiIsIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9ub2RlX21vZHVsZXMvdHNsaWIvdHNsaWIuZXM2LmpzPzlhYjQiLCJ3ZWJwYWNrOi8vbWRjLXJlYWN0Ly4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC9iYXNlL2ZvdW5kYXRpb24uanM/NjY4OSIsIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL2Jhc2UvY29tcG9uZW50LmpzPzgxMzYiLCJ3ZWJwYWNrOi8vbWRjLXJlYWN0Ly4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC9kb20vZXZlbnRzLmpzPzkzNzMiLCJ3ZWJwYWNrOi8vbWRjLXJlYWN0Ly4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC9kb20vcG9ueWZpbGwuanM/ZDg3ZiIsIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL3JpcHBsZS9jb25zdGFudHMuanM/NjQ1ZSIsIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL3JpcHBsZS91dGlsLmpzPzFkZmMiLCJ3ZWJwYWNrOi8vbWRjLXJlYWN0Ly4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC9yaXBwbGUvZm91bmRhdGlvbi5qcz80MzAzIiwid2VicGFjazovL21kYy1yZWFjdC8uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvcmlwcGxlL2NvbXBvbmVudC5qcz80MGZmIiwid2VicGFjazovL21kYy1yZWFjdC8uL3NyYy9yaXBwbGUvUmlwcGxlLmpzeD8xZjZmIiwid2VicGFjazovL21kYy1yZWFjdC8uL3NyYy9yaXBwbGUvY29uc3RhbnRzLmpzPzU0YjAiLCJ3ZWJwYWNrOi8vbWRjLXJlYWN0Ly4vc3JjL3JpcHBsZS9ob29rcy5qcz84NzA0Iiwid2VicGFjazovL21kYy1yZWFjdC8uL3NyYy9yaXBwbGUvUmlwcGxlU3VyZmFjZS5qc3g/MGMwOCIsIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9zcmMvcmlwcGxlL2luZGV4LmpzPzk0MjIiLCJ3ZWJwYWNrOi8vbWRjLXJlYWN0Ly4vc3JjL3NlZ21lbnRlZC1idXR0b24vY29uc3RhbnRzLmpzPzczNGYiLCJ3ZWJwYWNrOi8vbWRjLXJlYWN0Ly4vc3JjL3NlZ21lbnRlZC1idXR0b24vU2VnbWVudGVkQnV0dG9uU2VnbWVudC5qc3g/MTQ3OCIsIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9zcmMvc2VnbWVudGVkLWJ1dHRvbi9TZWdtZW50ZWRCdXR0b24uanN4PzU4Y2YiLCJ3ZWJwYWNrOi8vbWRjLXJlYWN0Ly4vc3JjL3NlZ21lbnRlZC1idXR0b24vaW5kZXguanM/MDczOCIsIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9zcmMvc2lkZS1zaGVldC9jb25zdGFudHMuanM/MjE4NiIsIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9zcmMvc2lkZS1zaGVldC9TaWRlU2hlZXRIZWFkZXIuanN4PzMwZTYiLCJ3ZWJwYWNrOi8vbWRjLXJlYWN0Ly4vc3JjL3NpZGUtc2hlZXQvU2lkZVNoZWV0Q29udGVudC5qc3g/OTIxYSIsIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9zcmMvc2lkZS1zaGVldC9TaWRlU2hlZXQuanN4PzYyYzQiLCJ3ZWJwYWNrOi8vbWRjLXJlYWN0Ly4vc3JjL3NpZGUtc2hlZXQvU2lkZVNoZWV0QXBwQ29udGVudC5qc3g/ZWU5MyIsIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9zcmMvc2lkZS1zaGVldC9pbmRleC5qcz81NTRiIiwid2VicGFjazovL21kYy1yZWFjdC8uL3NyYy9jb25zdGFudHMuanM/NWZiMCIsIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9zcmMvdXRpbHMuanM/MDI1ZSIsIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9zcmMvc2xpZGVyL2NvbnN0YW50cy5qcz85MjM0Iiwid2VicGFjazovL21kYy1yZWFjdC8uL3NyYy9zbGlkZXIvdXRpbHMuanM/NjRmYSIsIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9zcmMvc2xpZGVyL0lucHV0LmpzeD80ZTQxIiwid2VicGFjazovL21kYy1yZWFjdC8uL3NyYy9zbGlkZXIvVGlja01hcmtzLmpzeD8zMzEzIiwid2VicGFjazovL21kYy1yZWFjdC8uL3NyYy9zbGlkZXIvVHJhY2suanN4Pzg2N2IiLCJ3ZWJwYWNrOi8vbWRjLXJlYWN0Ly4vc3JjL3NsaWRlci9UaHVtYi5qc3g/NGZiNSIsIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9zcmMvc2xpZGVyL1NsaWRlci5qc3g/MGZhMCIsIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9zcmMvc2xpZGVyL2luZGV4LmpzPzZlMTUiLCJ3ZWJwYWNrOi8vbWRjLXJlYWN0Ly4vc3JjL3NuYWNrYmFyL2NvbnN0YW50cy5qcz9hMGE0Iiwid2VicGFjazovL21kYy1yZWFjdC8uL3NyYy9zbmFja2Jhci9TbmFja2Jhci5qc3g/MmRkMCIsIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9zcmMvc25hY2tiYXIvaW5kZXguanM/ZDgwNyIsIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9zcmMvc3dpdGNoL2NvbnN0YW50cy5qcz9jMGFkIiwid2VicGFjazovL21kYy1yZWFjdC8uL3NyYy9zd2l0Y2gvU3dpdGNoLmpzeD9mMTNiIiwid2VicGFjazovL21kYy1yZWFjdC8uL3NyYy9zd2l0Y2gvaW5kZXguanM/NzdlOCIsIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9zcmMvdGFicy9jb25zdGFudHMuanM/YjRjZSIsIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9zcmMvdGFicy9jb250ZXh0LmpzPzFlNWEiLCJ3ZWJwYWNrOi8vbWRjLXJlYWN0Ly4vc3JjL3RhYnMvVGFiSW5kaWNhdG9yLmpzeD9mYWE5Iiwid2VicGFjazovL21kYy1yZWFjdC8uL3NyYy90YWJzL1RhYi5qc3g/NDVkMCIsIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9zcmMvdGFicy9UYWJTY3JvbGxlci5qc3g/ZjYwNiIsIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9zcmMvdGFicy9UYWJCYXIuanN4P2E2YTUiLCJ3ZWJwYWNrOi8vbWRjLXJlYWN0Ly4vc3JjL3RhYnMvaW5kZXguanM/ZjIzNSIsIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9zcmMvdG9vbHRpcC9jb25zdGFudHMuanM/Mzg4ZCIsIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9zcmMvdG9vbHRpcC9Ub29sdGlwLmpzeD8yNDZiIiwid2VicGFjazovL21kYy1yZWFjdC8uL3NyYy90b29sdGlwL1JpY2hUb29sdGlwLmpzeD9jMDUzIiwid2VicGFjazovL21kYy1yZWFjdC8uL3NyYy90b29sdGlwL2luZGV4LmpzPzI2OTEiLCJ3ZWJwYWNrOi8vbWRjLXJlYWN0Ly4vc3JjL3RleHQtZmllbGQvY29uc3RhbnRzLmpzPzBhMWMiLCJ3ZWJwYWNrOi8vbWRjLXJlYWN0Ly4vc3JjL3RleHQtZmllbGQvSGVscGVyVGV4dC5qc3g/YzUwNCIsIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9zcmMvdGV4dC1maWVsZC9DaGFyYWN0ZXJDb3VudGVyLmpzeD83ZjIwIiwid2VicGFjazovL21kYy1yZWFjdC8uL3NyYy90ZXh0LWZpZWxkL0lucHV0LmpzeD82ZDFkIiwid2VicGFjazovL21kYy1yZWFjdC8uL3NyYy90ZXh0LWZpZWxkL1Jlc2l6ZXIuanN4P2U1NzkiLCJ3ZWJwYWNrOi8vbWRjLXJlYWN0Ly4vc3JjL3RleHQtZmllbGQvVGV4dEZpZWxkLmpzeD9hNmQ5Iiwid2VicGFjazovL21kYy1yZWFjdC8uL3NyYy90ZXh0LWZpZWxkL2luZGV4LmpzPzVkMGYiLCJ3ZWJwYWNrOi8vbWRjLXJlYWN0Ly4vc3JjL3RvcC1hcHAtYmFyL2NvbnN0YW50cy5qcz8xN2FkIiwid2VicGFjazovL21kYy1yZWFjdC8uL3NyYy90b3AtYXBwLWJhci9Ub3BBcHBCYXJSb3cuanN4PzcxMzQiLCJ3ZWJwYWNrOi8vbWRjLXJlYWN0Ly4vc3JjL3RvcC1hcHAtYmFyL1RvcEFwcEJhclNlY3Rpb24uanN4P2Y1ZWEiLCJ3ZWJwYWNrOi8vbWRjLXJlYWN0Ly4vc3JjL3RvcC1hcHAtYmFyL1RvcEFwcEJhci5qc3g/ZWUzMyIsIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9zcmMvdG9wLWFwcC1iYXIvVG9wQXBwQmFyQWN0aW9uSXRlbS5qc3g/NTI3NiIsIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9zcmMvdG9wLWFwcC1iYXIvVG9wQXBwQmFyRml4ZWRBZGp1c3QuanN4PzViZWQiLCJ3ZWJwYWNrOi8vbWRjLXJlYWN0Ly4vc3JjL3RvcC1hcHAtYmFyL1RvcEFwcEJhck5hdmlnYXRpb25JY29uLmpzeD85ZDM2Iiwid2VicGFjazovL21kYy1yZWFjdC8uL3NyYy90b3AtYXBwLWJhci9Ub3BBcHBCYXJUaXRsZS5qc3g/NzZmYSIsIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9zcmMvdG9wLWFwcC1iYXIvaW5kZXguanM/NjI2NSIsIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9zcmMvdHlwb2dyYXBoeS9jb25zdGFudHMuanM/NTA4NSIsIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9zcmMvdHlwb2dyYXBoeS9UeXBvZ3JhcGh5LmpzeD8zNTkwIiwid2VicGFjazovL21kYy1yZWFjdC8uL3NyYy90eXBvZ3JhcGh5L2luZGV4LmpzPzYzYzQiLCJ3ZWJwYWNrOi8vbWRjLXJlYWN0Ly4vc3JjL2luZGV4LmpzP2I2MzUiLCJ3ZWJwYWNrOi8vbWRjLXJlYWN0Ly4vZG9jcy9zcmMvY29tcG9uZW50cy9QYWdlL2luZGV4LmpzeD8wZDI2Iiwid2VicGFjazovL21kYy1yZWFjdC8uL2RvY3Mvc3JjL2NvbXBvbmVudHMvU2VjdGlvbi9pbmRleC5qc3g/NzdkZCIsIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9kb2NzL3NyYy9jb21wb25lbnRzL0NvZGUvaW5kZXguanN4P2JkNTgiLCJ3ZWJwYWNrOi8vbWRjLXJlYWN0Ly4vZG9jcy9zcmMvcGFnZXMvQXZhdGFyL2luZGV4LmpzeD8wMmRhIiwid2VicGFjazovL21kYy1yZWFjdC8uL2RvY3Mvc3JjL3BhZ2VzL0JhZGdlL2luZGV4LmpzeD8yNTcyIiwid2VicGFjazovL21kYy1yZWFjdC8uL2RvY3Mvc3JjL3BhZ2VzL0Jhbm5lci9pbmRleC5qc3g/YTFmOSIsIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9kb2NzL3NyYy9wYWdlcy9CdXR0b24vaW5kZXguanN4PzBlNDYiLCJ3ZWJwYWNrOi8vbWRjLXJlYWN0Ly4vZG9jcy9zcmMvcGFnZXMvQ2FyZC9pbmRleC5qc3g/OGQ2ZiIsIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9kb2NzL3NyYy9wYWdlcy9DaGVja2JveC9pbmRleC5qc3g/ODJjNiIsIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9kb2NzL3NyYy9wYWdlcy9DaGlwcy9pbmRleC5qc3g/MDUzOCIsIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9kb2NzL3NyYy9wYWdlcy9DaXJjdWxhclByb2dyZXNzL2luZGV4LmpzeD9jODg1Iiwid2VicGFjazovL21kYy1yZWFjdC8uL2RvY3Mvc3JjL3BhZ2VzL0RhdGFUYWJsZS9pbmRleC5qc3g/NTlhZCIsIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9kb2NzL3NyYy9wYWdlcy9EaWFsb2cvaW5kZXguanN4PzYwMGYiLCJ3ZWJwYWNrOi8vbWRjLXJlYWN0Ly4vZG9jcy9zcmMvcGFnZXMvRHJhd2VyL2luZGV4LmpzeD9hODQ2Iiwid2VicGFjazovL21kYy1yZWFjdC8uL2RvY3Mvc3JjL3BhZ2VzL0VsZXZhdGlvbi9pbmRleC5qc3g/YjlkNCIsIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9kb2NzL3NyYy9wYWdlcy9GQUIvaW5kZXguanN4PzY5Y2MiLCJ3ZWJwYWNrOi8vbWRjLXJlYWN0Ly4vZG9jcy9zcmMvcGFnZXMvRm9ybUZpZWxkL2luZGV4LmpzeD85OTJjIiwid2VicGFjazovL21kYy1yZWFjdC8uL25vZGVfbW9kdWxlcy9oaWdobGlnaHQuanMvZXMvY29yZS5qcz9iN2I4Iiwid2VicGFjazovL21kYy1yZWFjdC8uL25vZGVfbW9kdWxlcy9oaWdobGlnaHQuanMvZXMvbGFuZ3VhZ2VzL2phdmFzY3JpcHQuanM/YWM3MSIsIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9ub2RlX21vZHVsZXMvaGlnaGxpZ2h0LmpzL2VzL2xhbmd1YWdlcy9zY3NzLmpzPzM4ZjEiLCJ3ZWJwYWNrOi8vbWRjLXJlYWN0Ly4vbm9kZV9tb2R1bGVzL2hpZ2hsaWdodC5qcy9lcy9sYW5ndWFnZXMvc2hlbGwuanM/NzdiYiIsIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9ub2RlX21vZHVsZXMvaGlnaGxpZ2h0LmpzL2VzL2xhbmd1YWdlcy9wbGFpbnRleHQuanM/MGEyMSIsIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9kb2NzL3NyYy91dGlscy9tYXJrZG93bi5qcz8yYjA2Iiwid2VicGFjazovL21kYy1yZWFjdC8uL2RvY3Mvc3JjL3BhZ2VzL0hvbWUvaW5kZXguanN4P2ExMDQiLCJ3ZWJwYWNrOi8vbWRjLXJlYWN0Ly4vZG9jcy9zcmMvcGFnZXMvSWNvbkJ1dHRvbi9pbmRleC5qc3g/ZGNkMSIsIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9kb2NzL3NyYy9wYWdlcy9JbWFnZUxpc3QvaW5kZXguanN4PzliMDEiLCJ3ZWJwYWNrOi8vbWRjLXJlYWN0Ly4vZG9jcy9zcmMvcGFnZXMvTGF5b3V0R3JpZC9pbmRleC5qc3g/MGVmMiIsIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9kb2NzL3NyYy9wYWdlcy9MaW5lYXJQcm9ncmVzcy9pbmRleC5qc3g/NzY4NCIsIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9kb2NzL3NyYy9wYWdlcy9MaXN0L2luZGV4LmpzeD9kYTNiIiwid2VicGFjazovL21kYy1yZWFjdC8uL2RvY3Mvc3JjL3BhZ2VzL01lbnUvaW5kZXguanN4P2Q5Y2UiLCJ3ZWJwYWNrOi8vbWRjLXJlYWN0Ly4vZG9jcy9zcmMvcGFnZXMvUmFkaW8vaW5kZXguanN4PzE5NjYiLCJ3ZWJwYWNrOi8vbWRjLXJlYWN0Ly4vZG9jcy9zcmMvcGFnZXMvUmlwcGxlL2luZGV4LmpzeD9hOTYzIiwid2VicGFjazovL21kYy1yZWFjdC8uL2RvY3Mvc3JjL3BhZ2VzL1NlZ21lbnRlZEJ1dHRvbi9pbmRleC5qc3g/M2RiZSIsIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9kb2NzL3NyYy9wYWdlcy9TZWxlY3QvaW5kZXguanN4P2RmZDEiLCJ3ZWJwYWNrOi8vbWRjLXJlYWN0Ly4vZG9jcy9zcmMvcGFnZXMvU2lkZVNoZWV0L2luZGV4LmpzeD85MzQ1Iiwid2VicGFjazovL21kYy1yZWFjdC8uL2RvY3Mvc3JjL3BhZ2VzL1NsaWRlci9pbmRleC5qc3g/YWY4OSIsIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9kb2NzL3NyYy9wYWdlcy9TbmFja2Jhci9pbmRleC5qc3g/NWFiNCIsIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9kb2NzL3NyYy9wYWdlcy9Td2l0Y2gvaW5kZXguanN4Pzk2NzciLCJ3ZWJwYWNrOi8vbWRjLXJlYWN0Ly4vZG9jcy9zcmMvcGFnZXMvVGFicy9pbmRleC5qc3g/ZWJkZCIsIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9kb2NzL3NyYy9wYWdlcy9UZXh0RmllbGQvaW5kZXguanN4P2JjMWEiLCJ3ZWJwYWNrOi8vbWRjLXJlYWN0Ly4vZG9jcy9zcmMvcGFnZXMvVG9vbHRpcC9pbmRleC5qc3g/OWIzMyIsIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9kb2NzL3NyYy9wYWdlcy9Ub3BBcHBCYXIvaW5kZXguanN4P2NiMzUiLCJ3ZWJwYWNrOi8vbWRjLXJlYWN0Ly4vZG9jcy9zcmMvcGFnZXMvVHlwb2dyYXBoeS9pbmRleC5qc3g/MDQ4MyIsIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9kb2NzL3NyYy9wYWdlcy9pbmRleC5qcz9kMWEzIiwid2VicGFjazovL21kYy1yZWFjdC8uL2RvY3Mvc3JjL3JvdXRlcy5qcz85YjQ1Iiwid2VicGFjazovL21kYy1yZWFjdC8uL2RvY3Mvc3JjL0FwcC5qc3g/OTViYSIsIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9kb2NzL3NyYy9pbmRleC5qcz8wYjUxIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7XG4gIF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkge1xuICAgIG8uX19wcm90b19fID0gcDtcbiAgICByZXR1cm4gbztcbiAgfTtcblxuICByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApO1xufSIsImltcG9ydCBzZXRQcm90b3R5cGVPZiBmcm9tIFwiLi9zZXRQcm90b3R5cGVPZi5qc1wiO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gX2luaGVyaXRzTG9vc2Uoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHtcbiAgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzLnByb3RvdHlwZSk7XG4gIHN1YkNsYXNzLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IHN1YkNsYXNzO1xuICBzZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7XG59IiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gX2V4dGVuZHMoKSB7XG4gIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07XG5cbiAgICAgIGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHtcbiAgICAgICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRhcmdldDtcbiAgfTtcblxuICByZXR1cm4gX2V4dGVuZHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn0iLCJmdW5jdGlvbiBpc0Fic29sdXRlKHBhdGhuYW1lKSB7XG4gIHJldHVybiBwYXRobmFtZS5jaGFyQXQoMCkgPT09ICcvJztcbn1cblxuLy8gQWJvdXQgMS41eCBmYXN0ZXIgdGhhbiB0aGUgdHdvLWFyZyB2ZXJzaW9uIG9mIEFycmF5I3NwbGljZSgpXG5mdW5jdGlvbiBzcGxpY2VPbmUobGlzdCwgaW5kZXgpIHtcbiAgZm9yICh2YXIgaSA9IGluZGV4LCBrID0gaSArIDEsIG4gPSBsaXN0Lmxlbmd0aDsgayA8IG47IGkgKz0gMSwgayArPSAxKSB7XG4gICAgbGlzdFtpXSA9IGxpc3Rba107XG4gIH1cblxuICBsaXN0LnBvcCgpO1xufVxuXG4vLyBUaGlzIGltcGxlbWVudGF0aW9uIGlzIGJhc2VkIGhlYXZpbHkgb24gbm9kZSdzIHVybC5wYXJzZVxuZnVuY3Rpb24gcmVzb2x2ZVBhdGhuYW1lKHRvLCBmcm9tKSB7XG4gIGlmIChmcm9tID09PSB1bmRlZmluZWQpIGZyb20gPSAnJztcblxuICB2YXIgdG9QYXJ0cyA9ICh0byAmJiB0by5zcGxpdCgnLycpKSB8fCBbXTtcbiAgdmFyIGZyb21QYXJ0cyA9IChmcm9tICYmIGZyb20uc3BsaXQoJy8nKSkgfHwgW107XG5cbiAgdmFyIGlzVG9BYnMgPSB0byAmJiBpc0Fic29sdXRlKHRvKTtcbiAgdmFyIGlzRnJvbUFicyA9IGZyb20gJiYgaXNBYnNvbHV0ZShmcm9tKTtcbiAgdmFyIG11c3RFbmRBYnMgPSBpc1RvQWJzIHx8IGlzRnJvbUFicztcblxuICBpZiAodG8gJiYgaXNBYnNvbHV0ZSh0bykpIHtcbiAgICAvLyB0byBpcyBhYnNvbHV0ZVxuICAgIGZyb21QYXJ0cyA9IHRvUGFydHM7XG4gIH0gZWxzZSBpZiAodG9QYXJ0cy5sZW5ndGgpIHtcbiAgICAvLyB0byBpcyByZWxhdGl2ZSwgZHJvcCB0aGUgZmlsZW5hbWVcbiAgICBmcm9tUGFydHMucG9wKCk7XG4gICAgZnJvbVBhcnRzID0gZnJvbVBhcnRzLmNvbmNhdCh0b1BhcnRzKTtcbiAgfVxuXG4gIGlmICghZnJvbVBhcnRzLmxlbmd0aCkgcmV0dXJuICcvJztcblxuICB2YXIgaGFzVHJhaWxpbmdTbGFzaDtcbiAgaWYgKGZyb21QYXJ0cy5sZW5ndGgpIHtcbiAgICB2YXIgbGFzdCA9IGZyb21QYXJ0c1tmcm9tUGFydHMubGVuZ3RoIC0gMV07XG4gICAgaGFzVHJhaWxpbmdTbGFzaCA9IGxhc3QgPT09ICcuJyB8fCBsYXN0ID09PSAnLi4nIHx8IGxhc3QgPT09ICcnO1xuICB9IGVsc2Uge1xuICAgIGhhc1RyYWlsaW5nU2xhc2ggPSBmYWxzZTtcbiAgfVxuXG4gIHZhciB1cCA9IDA7XG4gIGZvciAodmFyIGkgPSBmcm9tUGFydHMubGVuZ3RoOyBpID49IDA7IGktLSkge1xuICAgIHZhciBwYXJ0ID0gZnJvbVBhcnRzW2ldO1xuXG4gICAgaWYgKHBhcnQgPT09ICcuJykge1xuICAgICAgc3BsaWNlT25lKGZyb21QYXJ0cywgaSk7XG4gICAgfSBlbHNlIGlmIChwYXJ0ID09PSAnLi4nKSB7XG4gICAgICBzcGxpY2VPbmUoZnJvbVBhcnRzLCBpKTtcbiAgICAgIHVwKys7XG4gICAgfSBlbHNlIGlmICh1cCkge1xuICAgICAgc3BsaWNlT25lKGZyb21QYXJ0cywgaSk7XG4gICAgICB1cC0tO1xuICAgIH1cbiAgfVxuXG4gIGlmICghbXVzdEVuZEFicykgZm9yICg7IHVwLS07IHVwKSBmcm9tUGFydHMudW5zaGlmdCgnLi4nKTtcblxuICBpZiAoXG4gICAgbXVzdEVuZEFicyAmJlxuICAgIGZyb21QYXJ0c1swXSAhPT0gJycgJiZcbiAgICAoIWZyb21QYXJ0c1swXSB8fCAhaXNBYnNvbHV0ZShmcm9tUGFydHNbMF0pKVxuICApXG4gICAgZnJvbVBhcnRzLnVuc2hpZnQoJycpO1xuXG4gIHZhciByZXN1bHQgPSBmcm9tUGFydHMuam9pbignLycpO1xuXG4gIGlmIChoYXNUcmFpbGluZ1NsYXNoICYmIHJlc3VsdC5zdWJzdHIoLTEpICE9PSAnLycpIHJlc3VsdCArPSAnLyc7XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgcmVzb2x2ZVBhdGhuYW1lO1xuIiwidmFyIGlzUHJvZHVjdGlvbiA9IHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbic7XG52YXIgcHJlZml4ID0gJ0ludmFyaWFudCBmYWlsZWQnO1xuZnVuY3Rpb24gaW52YXJpYW50KGNvbmRpdGlvbiwgbWVzc2FnZSkge1xuICAgIGlmIChjb25kaXRpb24pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoaXNQcm9kdWN0aW9uKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihwcmVmaXgpO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IocHJlZml4ICsgXCI6IFwiICsgKG1lc3NhZ2UgfHwgJycpKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgaW52YXJpYW50O1xuIiwiaW1wb3J0IF9leHRlbmRzIGZyb20gJ0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2V4dGVuZHMnO1xuaW1wb3J0IHJlc29sdmVQYXRobmFtZSBmcm9tICdyZXNvbHZlLXBhdGhuYW1lJztcbmltcG9ydCB2YWx1ZUVxdWFsIGZyb20gJ3ZhbHVlLWVxdWFsJztcbmltcG9ydCB3YXJuaW5nIGZyb20gJ3Rpbnktd2FybmluZyc7XG5pbXBvcnQgaW52YXJpYW50IGZyb20gJ3RpbnktaW52YXJpYW50JztcblxuZnVuY3Rpb24gYWRkTGVhZGluZ1NsYXNoKHBhdGgpIHtcbiAgcmV0dXJuIHBhdGguY2hhckF0KDApID09PSAnLycgPyBwYXRoIDogJy8nICsgcGF0aDtcbn1cbmZ1bmN0aW9uIHN0cmlwTGVhZGluZ1NsYXNoKHBhdGgpIHtcbiAgcmV0dXJuIHBhdGguY2hhckF0KDApID09PSAnLycgPyBwYXRoLnN1YnN0cigxKSA6IHBhdGg7XG59XG5mdW5jdGlvbiBoYXNCYXNlbmFtZShwYXRoLCBwcmVmaXgpIHtcbiAgcmV0dXJuIHBhdGgudG9Mb3dlckNhc2UoKS5pbmRleE9mKHByZWZpeC50b0xvd2VyQ2FzZSgpKSA9PT0gMCAmJiAnLz8jJy5pbmRleE9mKHBhdGguY2hhckF0KHByZWZpeC5sZW5ndGgpKSAhPT0gLTE7XG59XG5mdW5jdGlvbiBzdHJpcEJhc2VuYW1lKHBhdGgsIHByZWZpeCkge1xuICByZXR1cm4gaGFzQmFzZW5hbWUocGF0aCwgcHJlZml4KSA/IHBhdGguc3Vic3RyKHByZWZpeC5sZW5ndGgpIDogcGF0aDtcbn1cbmZ1bmN0aW9uIHN0cmlwVHJhaWxpbmdTbGFzaChwYXRoKSB7XG4gIHJldHVybiBwYXRoLmNoYXJBdChwYXRoLmxlbmd0aCAtIDEpID09PSAnLycgPyBwYXRoLnNsaWNlKDAsIC0xKSA6IHBhdGg7XG59XG5mdW5jdGlvbiBwYXJzZVBhdGgocGF0aCkge1xuICB2YXIgcGF0aG5hbWUgPSBwYXRoIHx8ICcvJztcbiAgdmFyIHNlYXJjaCA9ICcnO1xuICB2YXIgaGFzaCA9ICcnO1xuICB2YXIgaGFzaEluZGV4ID0gcGF0aG5hbWUuaW5kZXhPZignIycpO1xuXG4gIGlmIChoYXNoSW5kZXggIT09IC0xKSB7XG4gICAgaGFzaCA9IHBhdGhuYW1lLnN1YnN0cihoYXNoSW5kZXgpO1xuICAgIHBhdGhuYW1lID0gcGF0aG5hbWUuc3Vic3RyKDAsIGhhc2hJbmRleCk7XG4gIH1cblxuICB2YXIgc2VhcmNoSW5kZXggPSBwYXRobmFtZS5pbmRleE9mKCc/Jyk7XG5cbiAgaWYgKHNlYXJjaEluZGV4ICE9PSAtMSkge1xuICAgIHNlYXJjaCA9IHBhdGhuYW1lLnN1YnN0cihzZWFyY2hJbmRleCk7XG4gICAgcGF0aG5hbWUgPSBwYXRobmFtZS5zdWJzdHIoMCwgc2VhcmNoSW5kZXgpO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBwYXRobmFtZTogcGF0aG5hbWUsXG4gICAgc2VhcmNoOiBzZWFyY2ggPT09ICc/JyA/ICcnIDogc2VhcmNoLFxuICAgIGhhc2g6IGhhc2ggPT09ICcjJyA/ICcnIDogaGFzaFxuICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlUGF0aChsb2NhdGlvbikge1xuICB2YXIgcGF0aG5hbWUgPSBsb2NhdGlvbi5wYXRobmFtZSxcbiAgICAgIHNlYXJjaCA9IGxvY2F0aW9uLnNlYXJjaCxcbiAgICAgIGhhc2ggPSBsb2NhdGlvbi5oYXNoO1xuICB2YXIgcGF0aCA9IHBhdGhuYW1lIHx8ICcvJztcbiAgaWYgKHNlYXJjaCAmJiBzZWFyY2ggIT09ICc/JykgcGF0aCArPSBzZWFyY2guY2hhckF0KDApID09PSAnPycgPyBzZWFyY2ggOiBcIj9cIiArIHNlYXJjaDtcbiAgaWYgKGhhc2ggJiYgaGFzaCAhPT0gJyMnKSBwYXRoICs9IGhhc2guY2hhckF0KDApID09PSAnIycgPyBoYXNoIDogXCIjXCIgKyBoYXNoO1xuICByZXR1cm4gcGF0aDtcbn1cblxuZnVuY3Rpb24gY3JlYXRlTG9jYXRpb24ocGF0aCwgc3RhdGUsIGtleSwgY3VycmVudExvY2F0aW9uKSB7XG4gIHZhciBsb2NhdGlvbjtcblxuICBpZiAodHlwZW9mIHBhdGggPT09ICdzdHJpbmcnKSB7XG4gICAgLy8gVHdvLWFyZyBmb3JtOiBwdXNoKHBhdGgsIHN0YXRlKVxuICAgIGxvY2F0aW9uID0gcGFyc2VQYXRoKHBhdGgpO1xuICAgIGxvY2F0aW9uLnN0YXRlID0gc3RhdGU7XG4gIH0gZWxzZSB7XG4gICAgLy8gT25lLWFyZyBmb3JtOiBwdXNoKGxvY2F0aW9uKVxuICAgIGxvY2F0aW9uID0gX2V4dGVuZHMoe30sIHBhdGgpO1xuICAgIGlmIChsb2NhdGlvbi5wYXRobmFtZSA9PT0gdW5kZWZpbmVkKSBsb2NhdGlvbi5wYXRobmFtZSA9ICcnO1xuXG4gICAgaWYgKGxvY2F0aW9uLnNlYXJjaCkge1xuICAgICAgaWYgKGxvY2F0aW9uLnNlYXJjaC5jaGFyQXQoMCkgIT09ICc/JykgbG9jYXRpb24uc2VhcmNoID0gJz8nICsgbG9jYXRpb24uc2VhcmNoO1xuICAgIH0gZWxzZSB7XG4gICAgICBsb2NhdGlvbi5zZWFyY2ggPSAnJztcbiAgICB9XG5cbiAgICBpZiAobG9jYXRpb24uaGFzaCkge1xuICAgICAgaWYgKGxvY2F0aW9uLmhhc2guY2hhckF0KDApICE9PSAnIycpIGxvY2F0aW9uLmhhc2ggPSAnIycgKyBsb2NhdGlvbi5oYXNoO1xuICAgIH0gZWxzZSB7XG4gICAgICBsb2NhdGlvbi5oYXNoID0gJyc7XG4gICAgfVxuXG4gICAgaWYgKHN0YXRlICE9PSB1bmRlZmluZWQgJiYgbG9jYXRpb24uc3RhdGUgPT09IHVuZGVmaW5lZCkgbG9jYXRpb24uc3RhdGUgPSBzdGF0ZTtcbiAgfVxuXG4gIHRyeSB7XG4gICAgbG9jYXRpb24ucGF0aG5hbWUgPSBkZWNvZGVVUkkobG9jYXRpb24ucGF0aG5hbWUpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgaWYgKGUgaW5zdGFuY2VvZiBVUklFcnJvcikge1xuICAgICAgdGhyb3cgbmV3IFVSSUVycm9yKCdQYXRobmFtZSBcIicgKyBsb2NhdGlvbi5wYXRobmFtZSArICdcIiBjb3VsZCBub3QgYmUgZGVjb2RlZC4gJyArICdUaGlzIGlzIGxpa2VseSBjYXVzZWQgYnkgYW4gaW52YWxpZCBwZXJjZW50LWVuY29kaW5nLicpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBlO1xuICAgIH1cbiAgfVxuXG4gIGlmIChrZXkpIGxvY2F0aW9uLmtleSA9IGtleTtcblxuICBpZiAoY3VycmVudExvY2F0aW9uKSB7XG4gICAgLy8gUmVzb2x2ZSBpbmNvbXBsZXRlL3JlbGF0aXZlIHBhdGhuYW1lIHJlbGF0aXZlIHRvIGN1cnJlbnQgbG9jYXRpb24uXG4gICAgaWYgKCFsb2NhdGlvbi5wYXRobmFtZSkge1xuICAgICAgbG9jYXRpb24ucGF0aG5hbWUgPSBjdXJyZW50TG9jYXRpb24ucGF0aG5hbWU7XG4gICAgfSBlbHNlIGlmIChsb2NhdGlvbi5wYXRobmFtZS5jaGFyQXQoMCkgIT09ICcvJykge1xuICAgICAgbG9jYXRpb24ucGF0aG5hbWUgPSByZXNvbHZlUGF0aG5hbWUobG9jYXRpb24ucGF0aG5hbWUsIGN1cnJlbnRMb2NhdGlvbi5wYXRobmFtZSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIFdoZW4gdGhlcmUgaXMgbm8gcHJpb3IgbG9jYXRpb24gYW5kIHBhdGhuYW1lIGlzIGVtcHR5LCBzZXQgaXQgdG8gL1xuICAgIGlmICghbG9jYXRpb24ucGF0aG5hbWUpIHtcbiAgICAgIGxvY2F0aW9uLnBhdGhuYW1lID0gJy8nO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBsb2NhdGlvbjtcbn1cbmZ1bmN0aW9uIGxvY2F0aW9uc0FyZUVxdWFsKGEsIGIpIHtcbiAgcmV0dXJuIGEucGF0aG5hbWUgPT09IGIucGF0aG5hbWUgJiYgYS5zZWFyY2ggPT09IGIuc2VhcmNoICYmIGEuaGFzaCA9PT0gYi5oYXNoICYmIGEua2V5ID09PSBiLmtleSAmJiB2YWx1ZUVxdWFsKGEuc3RhdGUsIGIuc3RhdGUpO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVUcmFuc2l0aW9uTWFuYWdlcigpIHtcbiAgdmFyIHByb21wdCA9IG51bGw7XG5cbiAgZnVuY3Rpb24gc2V0UHJvbXB0KG5leHRQcm9tcHQpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyB3YXJuaW5nKHByb21wdCA9PSBudWxsLCAnQSBoaXN0b3J5IHN1cHBvcnRzIG9ubHkgb25lIHByb21wdCBhdCBhIHRpbWUnKSA6IHZvaWQgMDtcbiAgICBwcm9tcHQgPSBuZXh0UHJvbXB0O1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAocHJvbXB0ID09PSBuZXh0UHJvbXB0KSBwcm9tcHQgPSBudWxsO1xuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBjb25maXJtVHJhbnNpdGlvblRvKGxvY2F0aW9uLCBhY3Rpb24sIGdldFVzZXJDb25maXJtYXRpb24sIGNhbGxiYWNrKSB7XG4gICAgLy8gVE9ETzogSWYgYW5vdGhlciB0cmFuc2l0aW9uIHN0YXJ0cyB3aGlsZSB3ZSdyZSBzdGlsbCBjb25maXJtaW5nXG4gICAgLy8gdGhlIHByZXZpb3VzIG9uZSwgd2UgbWF5IGVuZCB1cCBpbiBhIHdlaXJkIHN0YXRlLiBGaWd1cmUgb3V0IHRoZVxuICAgIC8vIGJlc3Qgd2F5IHRvIGhhbmRsZSB0aGlzLlxuICAgIGlmIChwcm9tcHQgIT0gbnVsbCkge1xuICAgICAgdmFyIHJlc3VsdCA9IHR5cGVvZiBwcm9tcHQgPT09ICdmdW5jdGlvbicgPyBwcm9tcHQobG9jYXRpb24sIGFjdGlvbikgOiBwcm9tcHQ7XG5cbiAgICAgIGlmICh0eXBlb2YgcmVzdWx0ID09PSAnc3RyaW5nJykge1xuICAgICAgICBpZiAodHlwZW9mIGdldFVzZXJDb25maXJtYXRpb24gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICBnZXRVc2VyQ29uZmlybWF0aW9uKHJlc3VsdCwgY2FsbGJhY2spO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IHdhcm5pbmcoZmFsc2UsICdBIGhpc3RvcnkgbmVlZHMgYSBnZXRVc2VyQ29uZmlybWF0aW9uIGZ1bmN0aW9uIGluIG9yZGVyIHRvIHVzZSBhIHByb21wdCBtZXNzYWdlJykgOiB2b2lkIDA7XG4gICAgICAgICAgY2FsbGJhY2sodHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFJldHVybiBmYWxzZSBmcm9tIGEgdHJhbnNpdGlvbiBob29rIHRvIGNhbmNlbCB0aGUgdHJhbnNpdGlvbi5cbiAgICAgICAgY2FsbGJhY2socmVzdWx0ICE9PSBmYWxzZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNhbGxiYWNrKHRydWUpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBsaXN0ZW5lcnMgPSBbXTtcblxuICBmdW5jdGlvbiBhcHBlbmRMaXN0ZW5lcihmbikge1xuICAgIHZhciBpc0FjdGl2ZSA9IHRydWU7XG5cbiAgICBmdW5jdGlvbiBsaXN0ZW5lcigpIHtcbiAgICAgIGlmIChpc0FjdGl2ZSkgZm4uYXBwbHkodm9pZCAwLCBhcmd1bWVudHMpO1xuICAgIH1cblxuICAgIGxpc3RlbmVycy5wdXNoKGxpc3RlbmVyKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgaXNBY3RpdmUgPSBmYWxzZTtcbiAgICAgIGxpc3RlbmVycyA9IGxpc3RlbmVycy5maWx0ZXIoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgcmV0dXJuIGl0ZW0gIT09IGxpc3RlbmVyO1xuICAgICAgfSk7XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG5vdGlmeUxpc3RlbmVycygpIHtcbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgbGlzdGVuZXJzLmZvckVhY2goZnVuY3Rpb24gKGxpc3RlbmVyKSB7XG4gICAgICByZXR1cm4gbGlzdGVuZXIuYXBwbHkodm9pZCAwLCBhcmdzKTtcbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgc2V0UHJvbXB0OiBzZXRQcm9tcHQsXG4gICAgY29uZmlybVRyYW5zaXRpb25UbzogY29uZmlybVRyYW5zaXRpb25UbyxcbiAgICBhcHBlbmRMaXN0ZW5lcjogYXBwZW5kTGlzdGVuZXIsXG4gICAgbm90aWZ5TGlzdGVuZXJzOiBub3RpZnlMaXN0ZW5lcnNcbiAgfTtcbn1cblxudmFyIGNhblVzZURPTSA9ICEhKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5kb2N1bWVudCAmJiB3aW5kb3cuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCk7XG5mdW5jdGlvbiBnZXRDb25maXJtYXRpb24obWVzc2FnZSwgY2FsbGJhY2spIHtcbiAgY2FsbGJhY2sod2luZG93LmNvbmZpcm0obWVzc2FnZSkpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWFsZXJ0XG59XG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgSFRNTDUgaGlzdG9yeSBBUEkgaXMgc3VwcG9ydGVkLiBUYWtlbiBmcm9tIE1vZGVybml6ci5cbiAqXG4gKiBodHRwczovL2dpdGh1Yi5jb20vTW9kZXJuaXpyL01vZGVybml6ci9ibG9iL21hc3Rlci9MSUNFTlNFXG4gKiBodHRwczovL2dpdGh1Yi5jb20vTW9kZXJuaXpyL01vZGVybml6ci9ibG9iL21hc3Rlci9mZWF0dXJlLWRldGVjdHMvaGlzdG9yeS5qc1xuICogY2hhbmdlZCB0byBhdm9pZCBmYWxzZSBuZWdhdGl2ZXMgZm9yIFdpbmRvd3MgUGhvbmVzOiBodHRwczovL2dpdGh1Yi5jb20vcmVhY3Rqcy9yZWFjdC1yb3V0ZXIvaXNzdWVzLzU4NlxuICovXG5cbmZ1bmN0aW9uIHN1cHBvcnRzSGlzdG9yeSgpIHtcbiAgdmFyIHVhID0gd2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQ7XG4gIGlmICgodWEuaW5kZXhPZignQW5kcm9pZCAyLicpICE9PSAtMSB8fCB1YS5pbmRleE9mKCdBbmRyb2lkIDQuMCcpICE9PSAtMSkgJiYgdWEuaW5kZXhPZignTW9iaWxlIFNhZmFyaScpICE9PSAtMSAmJiB1YS5pbmRleE9mKCdDaHJvbWUnKSA9PT0gLTEgJiYgdWEuaW5kZXhPZignV2luZG93cyBQaG9uZScpID09PSAtMSkgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gd2luZG93Lmhpc3RvcnkgJiYgJ3B1c2hTdGF0ZScgaW4gd2luZG93Lmhpc3Rvcnk7XG59XG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiBicm93c2VyIGZpcmVzIHBvcHN0YXRlIG9uIGhhc2ggY2hhbmdlLlxuICogSUUxMCBhbmQgSUUxMSBkbyBub3QuXG4gKi9cblxuZnVuY3Rpb24gc3VwcG9ydHNQb3BTdGF0ZU9uSGFzaENoYW5nZSgpIHtcbiAgcmV0dXJuIHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoJ1RyaWRlbnQnKSA9PT0gLTE7XG59XG4vKipcbiAqIFJldHVybnMgZmFsc2UgaWYgdXNpbmcgZ28obikgd2l0aCBoYXNoIGhpc3RvcnkgY2F1c2VzIGEgZnVsbCBwYWdlIHJlbG9hZC5cbiAqL1xuXG5mdW5jdGlvbiBzdXBwb3J0c0dvV2l0aG91dFJlbG9hZFVzaW5nSGFzaCgpIHtcbiAgcmV0dXJuIHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoJ0ZpcmVmb3gnKSA9PT0gLTE7XG59XG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiBhIGdpdmVuIHBvcHN0YXRlIGV2ZW50IGlzIGFuIGV4dHJhbmVvdXMgV2ViS2l0IGV2ZW50LlxuICogQWNjb3VudHMgZm9yIHRoZSBmYWN0IHRoYXQgQ2hyb21lIG9uIGlPUyBmaXJlcyByZWFsIHBvcHN0YXRlIGV2ZW50c1xuICogY29udGFpbmluZyB1bmRlZmluZWQgc3RhdGUgd2hlbiBwcmVzc2luZyB0aGUgYmFjayBidXR0b24uXG4gKi9cblxuZnVuY3Rpb24gaXNFeHRyYW5lb3VzUG9wc3RhdGVFdmVudChldmVudCkge1xuICByZXR1cm4gZXZlbnQuc3RhdGUgPT09IHVuZGVmaW5lZCAmJiBuYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoJ0NyaU9TJykgPT09IC0xO1xufVxuXG52YXIgUG9wU3RhdGVFdmVudCA9ICdwb3BzdGF0ZSc7XG52YXIgSGFzaENoYW5nZUV2ZW50ID0gJ2hhc2hjaGFuZ2UnO1xuXG5mdW5jdGlvbiBnZXRIaXN0b3J5U3RhdGUoKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIHdpbmRvdy5oaXN0b3J5LnN0YXRlIHx8IHt9O1xuICB9IGNhdGNoIChlKSB7XG4gICAgLy8gSUUgMTEgc29tZXRpbWVzIHRocm93cyB3aGVuIGFjY2Vzc2luZyB3aW5kb3cuaGlzdG9yeS5zdGF0ZVxuICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vUmVhY3RUcmFpbmluZy9oaXN0b3J5L3B1bGwvMjg5XG4gICAgcmV0dXJuIHt9O1xuICB9XG59XG4vKipcbiAqIENyZWF0ZXMgYSBoaXN0b3J5IG9iamVjdCB0aGF0IHVzZXMgdGhlIEhUTUw1IGhpc3RvcnkgQVBJIGluY2x1ZGluZ1xuICogcHVzaFN0YXRlLCByZXBsYWNlU3RhdGUsIGFuZCB0aGUgcG9wc3RhdGUgZXZlbnQuXG4gKi9cblxuXG5mdW5jdGlvbiBjcmVhdGVCcm93c2VySGlzdG9yeShwcm9wcykge1xuICBpZiAocHJvcHMgPT09IHZvaWQgMCkge1xuICAgIHByb3BzID0ge307XG4gIH1cblxuICAhY2FuVXNlRE9NID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnQnJvd3NlciBoaXN0b3J5IG5lZWRzIGEgRE9NJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICB2YXIgZ2xvYmFsSGlzdG9yeSA9IHdpbmRvdy5oaXN0b3J5O1xuICB2YXIgY2FuVXNlSGlzdG9yeSA9IHN1cHBvcnRzSGlzdG9yeSgpO1xuICB2YXIgbmVlZHNIYXNoQ2hhbmdlTGlzdGVuZXIgPSAhc3VwcG9ydHNQb3BTdGF0ZU9uSGFzaENoYW5nZSgpO1xuICB2YXIgX3Byb3BzID0gcHJvcHMsXG4gICAgICBfcHJvcHMkZm9yY2VSZWZyZXNoID0gX3Byb3BzLmZvcmNlUmVmcmVzaCxcbiAgICAgIGZvcmNlUmVmcmVzaCA9IF9wcm9wcyRmb3JjZVJlZnJlc2ggPT09IHZvaWQgMCA/IGZhbHNlIDogX3Byb3BzJGZvcmNlUmVmcmVzaCxcbiAgICAgIF9wcm9wcyRnZXRVc2VyQ29uZmlybSA9IF9wcm9wcy5nZXRVc2VyQ29uZmlybWF0aW9uLFxuICAgICAgZ2V0VXNlckNvbmZpcm1hdGlvbiA9IF9wcm9wcyRnZXRVc2VyQ29uZmlybSA9PT0gdm9pZCAwID8gZ2V0Q29uZmlybWF0aW9uIDogX3Byb3BzJGdldFVzZXJDb25maXJtLFxuICAgICAgX3Byb3BzJGtleUxlbmd0aCA9IF9wcm9wcy5rZXlMZW5ndGgsXG4gICAgICBrZXlMZW5ndGggPSBfcHJvcHMka2V5TGVuZ3RoID09PSB2b2lkIDAgPyA2IDogX3Byb3BzJGtleUxlbmd0aDtcbiAgdmFyIGJhc2VuYW1lID0gcHJvcHMuYmFzZW5hbWUgPyBzdHJpcFRyYWlsaW5nU2xhc2goYWRkTGVhZGluZ1NsYXNoKHByb3BzLmJhc2VuYW1lKSkgOiAnJztcblxuICBmdW5jdGlvbiBnZXRET01Mb2NhdGlvbihoaXN0b3J5U3RhdGUpIHtcbiAgICB2YXIgX3JlZiA9IGhpc3RvcnlTdGF0ZSB8fCB7fSxcbiAgICAgICAga2V5ID0gX3JlZi5rZXksXG4gICAgICAgIHN0YXRlID0gX3JlZi5zdGF0ZTtcblxuICAgIHZhciBfd2luZG93JGxvY2F0aW9uID0gd2luZG93LmxvY2F0aW9uLFxuICAgICAgICBwYXRobmFtZSA9IF93aW5kb3ckbG9jYXRpb24ucGF0aG5hbWUsXG4gICAgICAgIHNlYXJjaCA9IF93aW5kb3ckbG9jYXRpb24uc2VhcmNoLFxuICAgICAgICBoYXNoID0gX3dpbmRvdyRsb2NhdGlvbi5oYXNoO1xuICAgIHZhciBwYXRoID0gcGF0aG5hbWUgKyBzZWFyY2ggKyBoYXNoO1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IHdhcm5pbmcoIWJhc2VuYW1lIHx8IGhhc0Jhc2VuYW1lKHBhdGgsIGJhc2VuYW1lKSwgJ1lvdSBhcmUgYXR0ZW1wdGluZyB0byB1c2UgYSBiYXNlbmFtZSBvbiBhIHBhZ2Ugd2hvc2UgVVJMIHBhdGggZG9lcyBub3QgYmVnaW4gJyArICd3aXRoIHRoZSBiYXNlbmFtZS4gRXhwZWN0ZWQgcGF0aCBcIicgKyBwYXRoICsgJ1wiIHRvIGJlZ2luIHdpdGggXCInICsgYmFzZW5hbWUgKyAnXCIuJykgOiB2b2lkIDA7XG4gICAgaWYgKGJhc2VuYW1lKSBwYXRoID0gc3RyaXBCYXNlbmFtZShwYXRoLCBiYXNlbmFtZSk7XG4gICAgcmV0dXJuIGNyZWF0ZUxvY2F0aW9uKHBhdGgsIHN0YXRlLCBrZXkpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlS2V5KCkge1xuICAgIHJldHVybiBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zdWJzdHIoMiwga2V5TGVuZ3RoKTtcbiAgfVxuXG4gIHZhciB0cmFuc2l0aW9uTWFuYWdlciA9IGNyZWF0ZVRyYW5zaXRpb25NYW5hZ2VyKCk7XG5cbiAgZnVuY3Rpb24gc2V0U3RhdGUobmV4dFN0YXRlKSB7XG4gICAgX2V4dGVuZHMoaGlzdG9yeSwgbmV4dFN0YXRlKTtcblxuICAgIGhpc3RvcnkubGVuZ3RoID0gZ2xvYmFsSGlzdG9yeS5sZW5ndGg7XG4gICAgdHJhbnNpdGlvbk1hbmFnZXIubm90aWZ5TGlzdGVuZXJzKGhpc3RvcnkubG9jYXRpb24sIGhpc3RvcnkuYWN0aW9uKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGhhbmRsZVBvcFN0YXRlKGV2ZW50KSB7XG4gICAgLy8gSWdub3JlIGV4dHJhbmVvdXMgcG9wc3RhdGUgZXZlbnRzIGluIFdlYktpdC5cbiAgICBpZiAoaXNFeHRyYW5lb3VzUG9wc3RhdGVFdmVudChldmVudCkpIHJldHVybjtcbiAgICBoYW5kbGVQb3AoZ2V0RE9NTG9jYXRpb24oZXZlbnQuc3RhdGUpKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGhhbmRsZUhhc2hDaGFuZ2UoKSB7XG4gICAgaGFuZGxlUG9wKGdldERPTUxvY2F0aW9uKGdldEhpc3RvcnlTdGF0ZSgpKSk7XG4gIH1cblxuICB2YXIgZm9yY2VOZXh0UG9wID0gZmFsc2U7XG5cbiAgZnVuY3Rpb24gaGFuZGxlUG9wKGxvY2F0aW9uKSB7XG4gICAgaWYgKGZvcmNlTmV4dFBvcCkge1xuICAgICAgZm9yY2VOZXh0UG9wID0gZmFsc2U7XG4gICAgICBzZXRTdGF0ZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgYWN0aW9uID0gJ1BPUCc7XG4gICAgICB0cmFuc2l0aW9uTWFuYWdlci5jb25maXJtVHJhbnNpdGlvblRvKGxvY2F0aW9uLCBhY3Rpb24sIGdldFVzZXJDb25maXJtYXRpb24sIGZ1bmN0aW9uIChvaykge1xuICAgICAgICBpZiAob2spIHtcbiAgICAgICAgICBzZXRTdGF0ZSh7XG4gICAgICAgICAgICBhY3Rpb246IGFjdGlvbixcbiAgICAgICAgICAgIGxvY2F0aW9uOiBsb2NhdGlvblxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldmVydFBvcChsb2NhdGlvbik7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJldmVydFBvcChmcm9tTG9jYXRpb24pIHtcbiAgICB2YXIgdG9Mb2NhdGlvbiA9IGhpc3RvcnkubG9jYXRpb247IC8vIFRPRE86IFdlIGNvdWxkIHByb2JhYmx5IG1ha2UgdGhpcyBtb3JlIHJlbGlhYmxlIGJ5XG4gICAgLy8ga2VlcGluZyBhIGxpc3Qgb2Yga2V5cyB3ZSd2ZSBzZWVuIGluIHNlc3Npb25TdG9yYWdlLlxuICAgIC8vIEluc3RlYWQsIHdlIGp1c3QgZGVmYXVsdCB0byAwIGZvciBrZXlzIHdlIGRvbid0IGtub3cuXG5cbiAgICB2YXIgdG9JbmRleCA9IGFsbEtleXMuaW5kZXhPZih0b0xvY2F0aW9uLmtleSk7XG4gICAgaWYgKHRvSW5kZXggPT09IC0xKSB0b0luZGV4ID0gMDtcbiAgICB2YXIgZnJvbUluZGV4ID0gYWxsS2V5cy5pbmRleE9mKGZyb21Mb2NhdGlvbi5rZXkpO1xuICAgIGlmIChmcm9tSW5kZXggPT09IC0xKSBmcm9tSW5kZXggPSAwO1xuICAgIHZhciBkZWx0YSA9IHRvSW5kZXggLSBmcm9tSW5kZXg7XG5cbiAgICBpZiAoZGVsdGEpIHtcbiAgICAgIGZvcmNlTmV4dFBvcCA9IHRydWU7XG4gICAgICBnbyhkZWx0YSk7XG4gICAgfVxuICB9XG5cbiAgdmFyIGluaXRpYWxMb2NhdGlvbiA9IGdldERPTUxvY2F0aW9uKGdldEhpc3RvcnlTdGF0ZSgpKTtcbiAgdmFyIGFsbEtleXMgPSBbaW5pdGlhbExvY2F0aW9uLmtleV07IC8vIFB1YmxpYyBpbnRlcmZhY2VcblxuICBmdW5jdGlvbiBjcmVhdGVIcmVmKGxvY2F0aW9uKSB7XG4gICAgcmV0dXJuIGJhc2VuYW1lICsgY3JlYXRlUGF0aChsb2NhdGlvbik7XG4gIH1cblxuICBmdW5jdGlvbiBwdXNoKHBhdGgsIHN0YXRlKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gd2FybmluZyghKHR5cGVvZiBwYXRoID09PSAnb2JqZWN0JyAmJiBwYXRoLnN0YXRlICE9PSB1bmRlZmluZWQgJiYgc3RhdGUgIT09IHVuZGVmaW5lZCksICdZb3Ugc2hvdWxkIGF2b2lkIHByb3ZpZGluZyBhIDJuZCBzdGF0ZSBhcmd1bWVudCB0byBwdXNoIHdoZW4gdGhlIDFzdCAnICsgJ2FyZ3VtZW50IGlzIGEgbG9jYXRpb24tbGlrZSBvYmplY3QgdGhhdCBhbHJlYWR5IGhhcyBzdGF0ZTsgaXQgaXMgaWdub3JlZCcpIDogdm9pZCAwO1xuICAgIHZhciBhY3Rpb24gPSAnUFVTSCc7XG4gICAgdmFyIGxvY2F0aW9uID0gY3JlYXRlTG9jYXRpb24ocGF0aCwgc3RhdGUsIGNyZWF0ZUtleSgpLCBoaXN0b3J5LmxvY2F0aW9uKTtcbiAgICB0cmFuc2l0aW9uTWFuYWdlci5jb25maXJtVHJhbnNpdGlvblRvKGxvY2F0aW9uLCBhY3Rpb24sIGdldFVzZXJDb25maXJtYXRpb24sIGZ1bmN0aW9uIChvaykge1xuICAgICAgaWYgKCFvaykgcmV0dXJuO1xuICAgICAgdmFyIGhyZWYgPSBjcmVhdGVIcmVmKGxvY2F0aW9uKTtcbiAgICAgIHZhciBrZXkgPSBsb2NhdGlvbi5rZXksXG4gICAgICAgICAgc3RhdGUgPSBsb2NhdGlvbi5zdGF0ZTtcblxuICAgICAgaWYgKGNhblVzZUhpc3RvcnkpIHtcbiAgICAgICAgZ2xvYmFsSGlzdG9yeS5wdXNoU3RhdGUoe1xuICAgICAgICAgIGtleToga2V5LFxuICAgICAgICAgIHN0YXRlOiBzdGF0ZVxuICAgICAgICB9LCBudWxsLCBocmVmKTtcblxuICAgICAgICBpZiAoZm9yY2VSZWZyZXNoKSB7XG4gICAgICAgICAgd2luZG93LmxvY2F0aW9uLmhyZWYgPSBocmVmO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBwcmV2SW5kZXggPSBhbGxLZXlzLmluZGV4T2YoaGlzdG9yeS5sb2NhdGlvbi5rZXkpO1xuICAgICAgICAgIHZhciBuZXh0S2V5cyA9IGFsbEtleXMuc2xpY2UoMCwgcHJldkluZGV4ICsgMSk7XG4gICAgICAgICAgbmV4dEtleXMucHVzaChsb2NhdGlvbi5rZXkpO1xuICAgICAgICAgIGFsbEtleXMgPSBuZXh0S2V5cztcbiAgICAgICAgICBzZXRTdGF0ZSh7XG4gICAgICAgICAgICBhY3Rpb246IGFjdGlvbixcbiAgICAgICAgICAgIGxvY2F0aW9uOiBsb2NhdGlvblxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyB3YXJuaW5nKHN0YXRlID09PSB1bmRlZmluZWQsICdCcm93c2VyIGhpc3RvcnkgY2Fubm90IHB1c2ggc3RhdGUgaW4gYnJvd3NlcnMgdGhhdCBkbyBub3Qgc3VwcG9ydCBIVE1MNSBoaXN0b3J5JykgOiB2b2lkIDA7XG4gICAgICAgIHdpbmRvdy5sb2NhdGlvbi5ocmVmID0gaHJlZjtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlcGxhY2UocGF0aCwgc3RhdGUpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyB3YXJuaW5nKCEodHlwZW9mIHBhdGggPT09ICdvYmplY3QnICYmIHBhdGguc3RhdGUgIT09IHVuZGVmaW5lZCAmJiBzdGF0ZSAhPT0gdW5kZWZpbmVkKSwgJ1lvdSBzaG91bGQgYXZvaWQgcHJvdmlkaW5nIGEgMm5kIHN0YXRlIGFyZ3VtZW50IHRvIHJlcGxhY2Ugd2hlbiB0aGUgMXN0ICcgKyAnYXJndW1lbnQgaXMgYSBsb2NhdGlvbi1saWtlIG9iamVjdCB0aGF0IGFscmVhZHkgaGFzIHN0YXRlOyBpdCBpcyBpZ25vcmVkJykgOiB2b2lkIDA7XG4gICAgdmFyIGFjdGlvbiA9ICdSRVBMQUNFJztcbiAgICB2YXIgbG9jYXRpb24gPSBjcmVhdGVMb2NhdGlvbihwYXRoLCBzdGF0ZSwgY3JlYXRlS2V5KCksIGhpc3RvcnkubG9jYXRpb24pO1xuICAgIHRyYW5zaXRpb25NYW5hZ2VyLmNvbmZpcm1UcmFuc2l0aW9uVG8obG9jYXRpb24sIGFjdGlvbiwgZ2V0VXNlckNvbmZpcm1hdGlvbiwgZnVuY3Rpb24gKG9rKSB7XG4gICAgICBpZiAoIW9rKSByZXR1cm47XG4gICAgICB2YXIgaHJlZiA9IGNyZWF0ZUhyZWYobG9jYXRpb24pO1xuICAgICAgdmFyIGtleSA9IGxvY2F0aW9uLmtleSxcbiAgICAgICAgICBzdGF0ZSA9IGxvY2F0aW9uLnN0YXRlO1xuXG4gICAgICBpZiAoY2FuVXNlSGlzdG9yeSkge1xuICAgICAgICBnbG9iYWxIaXN0b3J5LnJlcGxhY2VTdGF0ZSh7XG4gICAgICAgICAga2V5OiBrZXksXG4gICAgICAgICAgc3RhdGU6IHN0YXRlXG4gICAgICAgIH0sIG51bGwsIGhyZWYpO1xuXG4gICAgICAgIGlmIChmb3JjZVJlZnJlc2gpIHtcbiAgICAgICAgICB3aW5kb3cubG9jYXRpb24ucmVwbGFjZShocmVmKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgcHJldkluZGV4ID0gYWxsS2V5cy5pbmRleE9mKGhpc3RvcnkubG9jYXRpb24ua2V5KTtcbiAgICAgICAgICBpZiAocHJldkluZGV4ICE9PSAtMSkgYWxsS2V5c1twcmV2SW5kZXhdID0gbG9jYXRpb24ua2V5O1xuICAgICAgICAgIHNldFN0YXRlKHtcbiAgICAgICAgICAgIGFjdGlvbjogYWN0aW9uLFxuICAgICAgICAgICAgbG9jYXRpb246IGxvY2F0aW9uXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IHdhcm5pbmcoc3RhdGUgPT09IHVuZGVmaW5lZCwgJ0Jyb3dzZXIgaGlzdG9yeSBjYW5ub3QgcmVwbGFjZSBzdGF0ZSBpbiBicm93c2VycyB0aGF0IGRvIG5vdCBzdXBwb3J0IEhUTUw1IGhpc3RvcnknKSA6IHZvaWQgMDtcbiAgICAgICAgd2luZG93LmxvY2F0aW9uLnJlcGxhY2UoaHJlZik7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBnbyhuKSB7XG4gICAgZ2xvYmFsSGlzdG9yeS5nbyhuKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdvQmFjaygpIHtcbiAgICBnbygtMSk7XG4gIH1cblxuICBmdW5jdGlvbiBnb0ZvcndhcmQoKSB7XG4gICAgZ28oMSk7XG4gIH1cblxuICB2YXIgbGlzdGVuZXJDb3VudCA9IDA7XG5cbiAgZnVuY3Rpb24gY2hlY2tET01MaXN0ZW5lcnMoZGVsdGEpIHtcbiAgICBsaXN0ZW5lckNvdW50ICs9IGRlbHRhO1xuXG4gICAgaWYgKGxpc3RlbmVyQ291bnQgPT09IDEgJiYgZGVsdGEgPT09IDEpIHtcbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFBvcFN0YXRlRXZlbnQsIGhhbmRsZVBvcFN0YXRlKTtcbiAgICAgIGlmIChuZWVkc0hhc2hDaGFuZ2VMaXN0ZW5lcikgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoSGFzaENoYW5nZUV2ZW50LCBoYW5kbGVIYXNoQ2hhbmdlKTtcbiAgICB9IGVsc2UgaWYgKGxpc3RlbmVyQ291bnQgPT09IDApIHtcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFBvcFN0YXRlRXZlbnQsIGhhbmRsZVBvcFN0YXRlKTtcbiAgICAgIGlmIChuZWVkc0hhc2hDaGFuZ2VMaXN0ZW5lcikgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoSGFzaENoYW5nZUV2ZW50LCBoYW5kbGVIYXNoQ2hhbmdlKTtcbiAgICB9XG4gIH1cblxuICB2YXIgaXNCbG9ja2VkID0gZmFsc2U7XG5cbiAgZnVuY3Rpb24gYmxvY2socHJvbXB0KSB7XG4gICAgaWYgKHByb21wdCA9PT0gdm9pZCAwKSB7XG4gICAgICBwcm9tcHQgPSBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgdW5ibG9jayA9IHRyYW5zaXRpb25NYW5hZ2VyLnNldFByb21wdChwcm9tcHQpO1xuXG4gICAgaWYgKCFpc0Jsb2NrZWQpIHtcbiAgICAgIGNoZWNrRE9NTGlzdGVuZXJzKDEpO1xuICAgICAgaXNCbG9ja2VkID0gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKGlzQmxvY2tlZCkge1xuICAgICAgICBpc0Jsb2NrZWQgPSBmYWxzZTtcbiAgICAgICAgY2hlY2tET01MaXN0ZW5lcnMoLTEpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdW5ibG9jaygpO1xuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBsaXN0ZW4obGlzdGVuZXIpIHtcbiAgICB2YXIgdW5saXN0ZW4gPSB0cmFuc2l0aW9uTWFuYWdlci5hcHBlbmRMaXN0ZW5lcihsaXN0ZW5lcik7XG4gICAgY2hlY2tET01MaXN0ZW5lcnMoMSk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIGNoZWNrRE9NTGlzdGVuZXJzKC0xKTtcbiAgICAgIHVubGlzdGVuKCk7XG4gICAgfTtcbiAgfVxuXG4gIHZhciBoaXN0b3J5ID0ge1xuICAgIGxlbmd0aDogZ2xvYmFsSGlzdG9yeS5sZW5ndGgsXG4gICAgYWN0aW9uOiAnUE9QJyxcbiAgICBsb2NhdGlvbjogaW5pdGlhbExvY2F0aW9uLFxuICAgIGNyZWF0ZUhyZWY6IGNyZWF0ZUhyZWYsXG4gICAgcHVzaDogcHVzaCxcbiAgICByZXBsYWNlOiByZXBsYWNlLFxuICAgIGdvOiBnbyxcbiAgICBnb0JhY2s6IGdvQmFjayxcbiAgICBnb0ZvcndhcmQ6IGdvRm9yd2FyZCxcbiAgICBibG9jazogYmxvY2ssXG4gICAgbGlzdGVuOiBsaXN0ZW5cbiAgfTtcbiAgcmV0dXJuIGhpc3Rvcnk7XG59XG5cbnZhciBIYXNoQ2hhbmdlRXZlbnQkMSA9ICdoYXNoY2hhbmdlJztcbnZhciBIYXNoUGF0aENvZGVycyA9IHtcbiAgaGFzaGJhbmc6IHtcbiAgICBlbmNvZGVQYXRoOiBmdW5jdGlvbiBlbmNvZGVQYXRoKHBhdGgpIHtcbiAgICAgIHJldHVybiBwYXRoLmNoYXJBdCgwKSA9PT0gJyEnID8gcGF0aCA6ICchLycgKyBzdHJpcExlYWRpbmdTbGFzaChwYXRoKTtcbiAgICB9LFxuICAgIGRlY29kZVBhdGg6IGZ1bmN0aW9uIGRlY29kZVBhdGgocGF0aCkge1xuICAgICAgcmV0dXJuIHBhdGguY2hhckF0KDApID09PSAnIScgPyBwYXRoLnN1YnN0cigxKSA6IHBhdGg7XG4gICAgfVxuICB9LFxuICBub3NsYXNoOiB7XG4gICAgZW5jb2RlUGF0aDogc3RyaXBMZWFkaW5nU2xhc2gsXG4gICAgZGVjb2RlUGF0aDogYWRkTGVhZGluZ1NsYXNoXG4gIH0sXG4gIHNsYXNoOiB7XG4gICAgZW5jb2RlUGF0aDogYWRkTGVhZGluZ1NsYXNoLFxuICAgIGRlY29kZVBhdGg6IGFkZExlYWRpbmdTbGFzaFxuICB9XG59O1xuXG5mdW5jdGlvbiBzdHJpcEhhc2godXJsKSB7XG4gIHZhciBoYXNoSW5kZXggPSB1cmwuaW5kZXhPZignIycpO1xuICByZXR1cm4gaGFzaEluZGV4ID09PSAtMSA/IHVybCA6IHVybC5zbGljZSgwLCBoYXNoSW5kZXgpO1xufVxuXG5mdW5jdGlvbiBnZXRIYXNoUGF0aCgpIHtcbiAgLy8gV2UgY2FuJ3QgdXNlIHdpbmRvdy5sb2NhdGlvbi5oYXNoIGhlcmUgYmVjYXVzZSBpdCdzIG5vdFxuICAvLyBjb25zaXN0ZW50IGFjcm9zcyBicm93c2VycyAtIEZpcmVmb3ggd2lsbCBwcmUtZGVjb2RlIGl0IVxuICB2YXIgaHJlZiA9IHdpbmRvdy5sb2NhdGlvbi5ocmVmO1xuICB2YXIgaGFzaEluZGV4ID0gaHJlZi5pbmRleE9mKCcjJyk7XG4gIHJldHVybiBoYXNoSW5kZXggPT09IC0xID8gJycgOiBocmVmLnN1YnN0cmluZyhoYXNoSW5kZXggKyAxKTtcbn1cblxuZnVuY3Rpb24gcHVzaEhhc2hQYXRoKHBhdGgpIHtcbiAgd2luZG93LmxvY2F0aW9uLmhhc2ggPSBwYXRoO1xufVxuXG5mdW5jdGlvbiByZXBsYWNlSGFzaFBhdGgocGF0aCkge1xuICB3aW5kb3cubG9jYXRpb24ucmVwbGFjZShzdHJpcEhhc2god2luZG93LmxvY2F0aW9uLmhyZWYpICsgJyMnICsgcGF0aCk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUhhc2hIaXN0b3J5KHByb3BzKSB7XG4gIGlmIChwcm9wcyA9PT0gdm9pZCAwKSB7XG4gICAgcHJvcHMgPSB7fTtcbiAgfVxuXG4gICFjYW5Vc2VET00gPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdIYXNoIGhpc3RvcnkgbmVlZHMgYSBET00nKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gIHZhciBnbG9iYWxIaXN0b3J5ID0gd2luZG93Lmhpc3Rvcnk7XG4gIHZhciBjYW5Hb1dpdGhvdXRSZWxvYWQgPSBzdXBwb3J0c0dvV2l0aG91dFJlbG9hZFVzaW5nSGFzaCgpO1xuICB2YXIgX3Byb3BzID0gcHJvcHMsXG4gICAgICBfcHJvcHMkZ2V0VXNlckNvbmZpcm0gPSBfcHJvcHMuZ2V0VXNlckNvbmZpcm1hdGlvbixcbiAgICAgIGdldFVzZXJDb25maXJtYXRpb24gPSBfcHJvcHMkZ2V0VXNlckNvbmZpcm0gPT09IHZvaWQgMCA/IGdldENvbmZpcm1hdGlvbiA6IF9wcm9wcyRnZXRVc2VyQ29uZmlybSxcbiAgICAgIF9wcm9wcyRoYXNoVHlwZSA9IF9wcm9wcy5oYXNoVHlwZSxcbiAgICAgIGhhc2hUeXBlID0gX3Byb3BzJGhhc2hUeXBlID09PSB2b2lkIDAgPyAnc2xhc2gnIDogX3Byb3BzJGhhc2hUeXBlO1xuICB2YXIgYmFzZW5hbWUgPSBwcm9wcy5iYXNlbmFtZSA/IHN0cmlwVHJhaWxpbmdTbGFzaChhZGRMZWFkaW5nU2xhc2gocHJvcHMuYmFzZW5hbWUpKSA6ICcnO1xuICB2YXIgX0hhc2hQYXRoQ29kZXJzJGhhc2hUID0gSGFzaFBhdGhDb2RlcnNbaGFzaFR5cGVdLFxuICAgICAgZW5jb2RlUGF0aCA9IF9IYXNoUGF0aENvZGVycyRoYXNoVC5lbmNvZGVQYXRoLFxuICAgICAgZGVjb2RlUGF0aCA9IF9IYXNoUGF0aENvZGVycyRoYXNoVC5kZWNvZGVQYXRoO1xuXG4gIGZ1bmN0aW9uIGdldERPTUxvY2F0aW9uKCkge1xuICAgIHZhciBwYXRoID0gZGVjb2RlUGF0aChnZXRIYXNoUGF0aCgpKTtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyB3YXJuaW5nKCFiYXNlbmFtZSB8fCBoYXNCYXNlbmFtZShwYXRoLCBiYXNlbmFtZSksICdZb3UgYXJlIGF0dGVtcHRpbmcgdG8gdXNlIGEgYmFzZW5hbWUgb24gYSBwYWdlIHdob3NlIFVSTCBwYXRoIGRvZXMgbm90IGJlZ2luICcgKyAnd2l0aCB0aGUgYmFzZW5hbWUuIEV4cGVjdGVkIHBhdGggXCInICsgcGF0aCArICdcIiB0byBiZWdpbiB3aXRoIFwiJyArIGJhc2VuYW1lICsgJ1wiLicpIDogdm9pZCAwO1xuICAgIGlmIChiYXNlbmFtZSkgcGF0aCA9IHN0cmlwQmFzZW5hbWUocGF0aCwgYmFzZW5hbWUpO1xuICAgIHJldHVybiBjcmVhdGVMb2NhdGlvbihwYXRoKTtcbiAgfVxuXG4gIHZhciB0cmFuc2l0aW9uTWFuYWdlciA9IGNyZWF0ZVRyYW5zaXRpb25NYW5hZ2VyKCk7XG5cbiAgZnVuY3Rpb24gc2V0U3RhdGUobmV4dFN0YXRlKSB7XG4gICAgX2V4dGVuZHMoaGlzdG9yeSwgbmV4dFN0YXRlKTtcblxuICAgIGhpc3RvcnkubGVuZ3RoID0gZ2xvYmFsSGlzdG9yeS5sZW5ndGg7XG4gICAgdHJhbnNpdGlvbk1hbmFnZXIubm90aWZ5TGlzdGVuZXJzKGhpc3RvcnkubG9jYXRpb24sIGhpc3RvcnkuYWN0aW9uKTtcbiAgfVxuXG4gIHZhciBmb3JjZU5leHRQb3AgPSBmYWxzZTtcbiAgdmFyIGlnbm9yZVBhdGggPSBudWxsO1xuXG4gIGZ1bmN0aW9uIGxvY2F0aW9uc0FyZUVxdWFsJCQxKGEsIGIpIHtcbiAgICByZXR1cm4gYS5wYXRobmFtZSA9PT0gYi5wYXRobmFtZSAmJiBhLnNlYXJjaCA9PT0gYi5zZWFyY2ggJiYgYS5oYXNoID09PSBiLmhhc2g7XG4gIH1cblxuICBmdW5jdGlvbiBoYW5kbGVIYXNoQ2hhbmdlKCkge1xuICAgIHZhciBwYXRoID0gZ2V0SGFzaFBhdGgoKTtcbiAgICB2YXIgZW5jb2RlZFBhdGggPSBlbmNvZGVQYXRoKHBhdGgpO1xuXG4gICAgaWYgKHBhdGggIT09IGVuY29kZWRQYXRoKSB7XG4gICAgICAvLyBFbnN1cmUgd2UgYWx3YXlzIGhhdmUgYSBwcm9wZXJseS1lbmNvZGVkIGhhc2guXG4gICAgICByZXBsYWNlSGFzaFBhdGgoZW5jb2RlZFBhdGgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgbG9jYXRpb24gPSBnZXRET01Mb2NhdGlvbigpO1xuICAgICAgdmFyIHByZXZMb2NhdGlvbiA9IGhpc3RvcnkubG9jYXRpb247XG4gICAgICBpZiAoIWZvcmNlTmV4dFBvcCAmJiBsb2NhdGlvbnNBcmVFcXVhbCQkMShwcmV2TG9jYXRpb24sIGxvY2F0aW9uKSkgcmV0dXJuOyAvLyBBIGhhc2hjaGFuZ2UgZG9lc24ndCBhbHdheXMgPT0gbG9jYXRpb24gY2hhbmdlLlxuXG4gICAgICBpZiAoaWdub3JlUGF0aCA9PT0gY3JlYXRlUGF0aChsb2NhdGlvbikpIHJldHVybjsgLy8gSWdub3JlIHRoaXMgY2hhbmdlOyB3ZSBhbHJlYWR5IHNldFN0YXRlIGluIHB1c2gvcmVwbGFjZS5cblxuICAgICAgaWdub3JlUGF0aCA9IG51bGw7XG4gICAgICBoYW5kbGVQb3AobG9jYXRpb24pO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGhhbmRsZVBvcChsb2NhdGlvbikge1xuICAgIGlmIChmb3JjZU5leHRQb3ApIHtcbiAgICAgIGZvcmNlTmV4dFBvcCA9IGZhbHNlO1xuICAgICAgc2V0U3RhdGUoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGFjdGlvbiA9ICdQT1AnO1xuICAgICAgdHJhbnNpdGlvbk1hbmFnZXIuY29uZmlybVRyYW5zaXRpb25Ubyhsb2NhdGlvbiwgYWN0aW9uLCBnZXRVc2VyQ29uZmlybWF0aW9uLCBmdW5jdGlvbiAob2spIHtcbiAgICAgICAgaWYgKG9rKSB7XG4gICAgICAgICAgc2V0U3RhdGUoe1xuICAgICAgICAgICAgYWN0aW9uOiBhY3Rpb24sXG4gICAgICAgICAgICBsb2NhdGlvbjogbG9jYXRpb25cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXZlcnRQb3AobG9jYXRpb24pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZXZlcnRQb3AoZnJvbUxvY2F0aW9uKSB7XG4gICAgdmFyIHRvTG9jYXRpb24gPSBoaXN0b3J5LmxvY2F0aW9uOyAvLyBUT0RPOiBXZSBjb3VsZCBwcm9iYWJseSBtYWtlIHRoaXMgbW9yZSByZWxpYWJsZSBieVxuICAgIC8vIGtlZXBpbmcgYSBsaXN0IG9mIHBhdGhzIHdlJ3ZlIHNlZW4gaW4gc2Vzc2lvblN0b3JhZ2UuXG4gICAgLy8gSW5zdGVhZCwgd2UganVzdCBkZWZhdWx0IHRvIDAgZm9yIHBhdGhzIHdlIGRvbid0IGtub3cuXG5cbiAgICB2YXIgdG9JbmRleCA9IGFsbFBhdGhzLmxhc3RJbmRleE9mKGNyZWF0ZVBhdGgodG9Mb2NhdGlvbikpO1xuICAgIGlmICh0b0luZGV4ID09PSAtMSkgdG9JbmRleCA9IDA7XG4gICAgdmFyIGZyb21JbmRleCA9IGFsbFBhdGhzLmxhc3RJbmRleE9mKGNyZWF0ZVBhdGgoZnJvbUxvY2F0aW9uKSk7XG4gICAgaWYgKGZyb21JbmRleCA9PT0gLTEpIGZyb21JbmRleCA9IDA7XG4gICAgdmFyIGRlbHRhID0gdG9JbmRleCAtIGZyb21JbmRleDtcblxuICAgIGlmIChkZWx0YSkge1xuICAgICAgZm9yY2VOZXh0UG9wID0gdHJ1ZTtcbiAgICAgIGdvKGRlbHRhKTtcbiAgICB9XG4gIH0gLy8gRW5zdXJlIHRoZSBoYXNoIGlzIGVuY29kZWQgcHJvcGVybHkgYmVmb3JlIGRvaW5nIGFueXRoaW5nIGVsc2UuXG5cblxuICB2YXIgcGF0aCA9IGdldEhhc2hQYXRoKCk7XG4gIHZhciBlbmNvZGVkUGF0aCA9IGVuY29kZVBhdGgocGF0aCk7XG4gIGlmIChwYXRoICE9PSBlbmNvZGVkUGF0aCkgcmVwbGFjZUhhc2hQYXRoKGVuY29kZWRQYXRoKTtcbiAgdmFyIGluaXRpYWxMb2NhdGlvbiA9IGdldERPTUxvY2F0aW9uKCk7XG4gIHZhciBhbGxQYXRocyA9IFtjcmVhdGVQYXRoKGluaXRpYWxMb2NhdGlvbildOyAvLyBQdWJsaWMgaW50ZXJmYWNlXG5cbiAgZnVuY3Rpb24gY3JlYXRlSHJlZihsb2NhdGlvbikge1xuICAgIHZhciBiYXNlVGFnID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignYmFzZScpO1xuICAgIHZhciBocmVmID0gJyc7XG5cbiAgICBpZiAoYmFzZVRhZyAmJiBiYXNlVGFnLmdldEF0dHJpYnV0ZSgnaHJlZicpKSB7XG4gICAgICBocmVmID0gc3RyaXBIYXNoKHdpbmRvdy5sb2NhdGlvbi5ocmVmKTtcbiAgICB9XG5cbiAgICByZXR1cm4gaHJlZiArICcjJyArIGVuY29kZVBhdGgoYmFzZW5hbWUgKyBjcmVhdGVQYXRoKGxvY2F0aW9uKSk7XG4gIH1cblxuICBmdW5jdGlvbiBwdXNoKHBhdGgsIHN0YXRlKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gd2FybmluZyhzdGF0ZSA9PT0gdW5kZWZpbmVkLCAnSGFzaCBoaXN0b3J5IGNhbm5vdCBwdXNoIHN0YXRlOyBpdCBpcyBpZ25vcmVkJykgOiB2b2lkIDA7XG4gICAgdmFyIGFjdGlvbiA9ICdQVVNIJztcbiAgICB2YXIgbG9jYXRpb24gPSBjcmVhdGVMb2NhdGlvbihwYXRoLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgaGlzdG9yeS5sb2NhdGlvbik7XG4gICAgdHJhbnNpdGlvbk1hbmFnZXIuY29uZmlybVRyYW5zaXRpb25Ubyhsb2NhdGlvbiwgYWN0aW9uLCBnZXRVc2VyQ29uZmlybWF0aW9uLCBmdW5jdGlvbiAob2spIHtcbiAgICAgIGlmICghb2spIHJldHVybjtcbiAgICAgIHZhciBwYXRoID0gY3JlYXRlUGF0aChsb2NhdGlvbik7XG4gICAgICB2YXIgZW5jb2RlZFBhdGggPSBlbmNvZGVQYXRoKGJhc2VuYW1lICsgcGF0aCk7XG4gICAgICB2YXIgaGFzaENoYW5nZWQgPSBnZXRIYXNoUGF0aCgpICE9PSBlbmNvZGVkUGF0aDtcblxuICAgICAgaWYgKGhhc2hDaGFuZ2VkKSB7XG4gICAgICAgIC8vIFdlIGNhbm5vdCB0ZWxsIGlmIGEgaGFzaGNoYW5nZSB3YXMgY2F1c2VkIGJ5IGEgUFVTSCwgc28gd2UnZFxuICAgICAgICAvLyByYXRoZXIgc2V0U3RhdGUgaGVyZSBhbmQgaWdub3JlIHRoZSBoYXNoY2hhbmdlLiBUaGUgY2F2ZWF0IGhlcmVcbiAgICAgICAgLy8gaXMgdGhhdCBvdGhlciBoYXNoIGhpc3RvcmllcyBpbiB0aGUgcGFnZSB3aWxsIGNvbnNpZGVyIGl0IGEgUE9QLlxuICAgICAgICBpZ25vcmVQYXRoID0gcGF0aDtcbiAgICAgICAgcHVzaEhhc2hQYXRoKGVuY29kZWRQYXRoKTtcbiAgICAgICAgdmFyIHByZXZJbmRleCA9IGFsbFBhdGhzLmxhc3RJbmRleE9mKGNyZWF0ZVBhdGgoaGlzdG9yeS5sb2NhdGlvbikpO1xuICAgICAgICB2YXIgbmV4dFBhdGhzID0gYWxsUGF0aHMuc2xpY2UoMCwgcHJldkluZGV4ICsgMSk7XG4gICAgICAgIG5leHRQYXRocy5wdXNoKHBhdGgpO1xuICAgICAgICBhbGxQYXRocyA9IG5leHRQYXRocztcbiAgICAgICAgc2V0U3RhdGUoe1xuICAgICAgICAgIGFjdGlvbjogYWN0aW9uLFxuICAgICAgICAgIGxvY2F0aW9uOiBsb2NhdGlvblxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IHdhcm5pbmcoZmFsc2UsICdIYXNoIGhpc3RvcnkgY2Fubm90IFBVU0ggdGhlIHNhbWUgcGF0aDsgYSBuZXcgZW50cnkgd2lsbCBub3QgYmUgYWRkZWQgdG8gdGhlIGhpc3Rvcnkgc3RhY2snKSA6IHZvaWQgMDtcbiAgICAgICAgc2V0U3RhdGUoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlcGxhY2UocGF0aCwgc3RhdGUpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyB3YXJuaW5nKHN0YXRlID09PSB1bmRlZmluZWQsICdIYXNoIGhpc3RvcnkgY2Fubm90IHJlcGxhY2Ugc3RhdGU7IGl0IGlzIGlnbm9yZWQnKSA6IHZvaWQgMDtcbiAgICB2YXIgYWN0aW9uID0gJ1JFUExBQ0UnO1xuICAgIHZhciBsb2NhdGlvbiA9IGNyZWF0ZUxvY2F0aW9uKHBhdGgsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBoaXN0b3J5LmxvY2F0aW9uKTtcbiAgICB0cmFuc2l0aW9uTWFuYWdlci5jb25maXJtVHJhbnNpdGlvblRvKGxvY2F0aW9uLCBhY3Rpb24sIGdldFVzZXJDb25maXJtYXRpb24sIGZ1bmN0aW9uIChvaykge1xuICAgICAgaWYgKCFvaykgcmV0dXJuO1xuICAgICAgdmFyIHBhdGggPSBjcmVhdGVQYXRoKGxvY2F0aW9uKTtcbiAgICAgIHZhciBlbmNvZGVkUGF0aCA9IGVuY29kZVBhdGgoYmFzZW5hbWUgKyBwYXRoKTtcbiAgICAgIHZhciBoYXNoQ2hhbmdlZCA9IGdldEhhc2hQYXRoKCkgIT09IGVuY29kZWRQYXRoO1xuXG4gICAgICBpZiAoaGFzaENoYW5nZWQpIHtcbiAgICAgICAgLy8gV2UgY2Fubm90IHRlbGwgaWYgYSBoYXNoY2hhbmdlIHdhcyBjYXVzZWQgYnkgYSBSRVBMQUNFLCBzbyB3ZSdkXG4gICAgICAgIC8vIHJhdGhlciBzZXRTdGF0ZSBoZXJlIGFuZCBpZ25vcmUgdGhlIGhhc2hjaGFuZ2UuIFRoZSBjYXZlYXQgaGVyZVxuICAgICAgICAvLyBpcyB0aGF0IG90aGVyIGhhc2ggaGlzdG9yaWVzIGluIHRoZSBwYWdlIHdpbGwgY29uc2lkZXIgaXQgYSBQT1AuXG4gICAgICAgIGlnbm9yZVBhdGggPSBwYXRoO1xuICAgICAgICByZXBsYWNlSGFzaFBhdGgoZW5jb2RlZFBhdGgpO1xuICAgICAgfVxuXG4gICAgICB2YXIgcHJldkluZGV4ID0gYWxsUGF0aHMuaW5kZXhPZihjcmVhdGVQYXRoKGhpc3RvcnkubG9jYXRpb24pKTtcbiAgICAgIGlmIChwcmV2SW5kZXggIT09IC0xKSBhbGxQYXRoc1twcmV2SW5kZXhdID0gcGF0aDtcbiAgICAgIHNldFN0YXRlKHtcbiAgICAgICAgYWN0aW9uOiBhY3Rpb24sXG4gICAgICAgIGxvY2F0aW9uOiBsb2NhdGlvblxuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBnbyhuKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gd2FybmluZyhjYW5Hb1dpdGhvdXRSZWxvYWQsICdIYXNoIGhpc3RvcnkgZ28obikgY2F1c2VzIGEgZnVsbCBwYWdlIHJlbG9hZCBpbiB0aGlzIGJyb3dzZXInKSA6IHZvaWQgMDtcbiAgICBnbG9iYWxIaXN0b3J5LmdvKG4pO1xuICB9XG5cbiAgZnVuY3Rpb24gZ29CYWNrKCkge1xuICAgIGdvKC0xKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdvRm9yd2FyZCgpIHtcbiAgICBnbygxKTtcbiAgfVxuXG4gIHZhciBsaXN0ZW5lckNvdW50ID0gMDtcblxuICBmdW5jdGlvbiBjaGVja0RPTUxpc3RlbmVycyhkZWx0YSkge1xuICAgIGxpc3RlbmVyQ291bnQgKz0gZGVsdGE7XG5cbiAgICBpZiAobGlzdGVuZXJDb3VudCA9PT0gMSAmJiBkZWx0YSA9PT0gMSkge1xuICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoSGFzaENoYW5nZUV2ZW50JDEsIGhhbmRsZUhhc2hDaGFuZ2UpO1xuICAgIH0gZWxzZSBpZiAobGlzdGVuZXJDb3VudCA9PT0gMCkge1xuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoSGFzaENoYW5nZUV2ZW50JDEsIGhhbmRsZUhhc2hDaGFuZ2UpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBpc0Jsb2NrZWQgPSBmYWxzZTtcblxuICBmdW5jdGlvbiBibG9jayhwcm9tcHQpIHtcbiAgICBpZiAocHJvbXB0ID09PSB2b2lkIDApIHtcbiAgICAgIHByb21wdCA9IGZhbHNlO1xuICAgIH1cblxuICAgIHZhciB1bmJsb2NrID0gdHJhbnNpdGlvbk1hbmFnZXIuc2V0UHJvbXB0KHByb21wdCk7XG5cbiAgICBpZiAoIWlzQmxvY2tlZCkge1xuICAgICAgY2hlY2tET01MaXN0ZW5lcnMoMSk7XG4gICAgICBpc0Jsb2NrZWQgPSB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoaXNCbG9ja2VkKSB7XG4gICAgICAgIGlzQmxvY2tlZCA9IGZhbHNlO1xuICAgICAgICBjaGVja0RPTUxpc3RlbmVycygtMSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB1bmJsb2NrKCk7XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGxpc3RlbihsaXN0ZW5lcikge1xuICAgIHZhciB1bmxpc3RlbiA9IHRyYW5zaXRpb25NYW5hZ2VyLmFwcGVuZExpc3RlbmVyKGxpc3RlbmVyKTtcbiAgICBjaGVja0RPTUxpc3RlbmVycygxKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgY2hlY2tET01MaXN0ZW5lcnMoLTEpO1xuICAgICAgdW5saXN0ZW4oKTtcbiAgICB9O1xuICB9XG5cbiAgdmFyIGhpc3RvcnkgPSB7XG4gICAgbGVuZ3RoOiBnbG9iYWxIaXN0b3J5Lmxlbmd0aCxcbiAgICBhY3Rpb246ICdQT1AnLFxuICAgIGxvY2F0aW9uOiBpbml0aWFsTG9jYXRpb24sXG4gICAgY3JlYXRlSHJlZjogY3JlYXRlSHJlZixcbiAgICBwdXNoOiBwdXNoLFxuICAgIHJlcGxhY2U6IHJlcGxhY2UsXG4gICAgZ286IGdvLFxuICAgIGdvQmFjazogZ29CYWNrLFxuICAgIGdvRm9yd2FyZDogZ29Gb3J3YXJkLFxuICAgIGJsb2NrOiBibG9jayxcbiAgICBsaXN0ZW46IGxpc3RlblxuICB9O1xuICByZXR1cm4gaGlzdG9yeTtcbn1cblxuZnVuY3Rpb24gY2xhbXAobiwgbG93ZXJCb3VuZCwgdXBwZXJCb3VuZCkge1xuICByZXR1cm4gTWF0aC5taW4oTWF0aC5tYXgobiwgbG93ZXJCb3VuZCksIHVwcGVyQm91bmQpO1xufVxuLyoqXG4gKiBDcmVhdGVzIGEgaGlzdG9yeSBvYmplY3QgdGhhdCBzdG9yZXMgbG9jYXRpb25zIGluIG1lbW9yeS5cbiAqL1xuXG5cbmZ1bmN0aW9uIGNyZWF0ZU1lbW9yeUhpc3RvcnkocHJvcHMpIHtcbiAgaWYgKHByb3BzID09PSB2b2lkIDApIHtcbiAgICBwcm9wcyA9IHt9O1xuICB9XG5cbiAgdmFyIF9wcm9wcyA9IHByb3BzLFxuICAgICAgZ2V0VXNlckNvbmZpcm1hdGlvbiA9IF9wcm9wcy5nZXRVc2VyQ29uZmlybWF0aW9uLFxuICAgICAgX3Byb3BzJGluaXRpYWxFbnRyaWVzID0gX3Byb3BzLmluaXRpYWxFbnRyaWVzLFxuICAgICAgaW5pdGlhbEVudHJpZXMgPSBfcHJvcHMkaW5pdGlhbEVudHJpZXMgPT09IHZvaWQgMCA/IFsnLyddIDogX3Byb3BzJGluaXRpYWxFbnRyaWVzLFxuICAgICAgX3Byb3BzJGluaXRpYWxJbmRleCA9IF9wcm9wcy5pbml0aWFsSW5kZXgsXG4gICAgICBpbml0aWFsSW5kZXggPSBfcHJvcHMkaW5pdGlhbEluZGV4ID09PSB2b2lkIDAgPyAwIDogX3Byb3BzJGluaXRpYWxJbmRleCxcbiAgICAgIF9wcm9wcyRrZXlMZW5ndGggPSBfcHJvcHMua2V5TGVuZ3RoLFxuICAgICAga2V5TGVuZ3RoID0gX3Byb3BzJGtleUxlbmd0aCA9PT0gdm9pZCAwID8gNiA6IF9wcm9wcyRrZXlMZW5ndGg7XG4gIHZhciB0cmFuc2l0aW9uTWFuYWdlciA9IGNyZWF0ZVRyYW5zaXRpb25NYW5hZ2VyKCk7XG5cbiAgZnVuY3Rpb24gc2V0U3RhdGUobmV4dFN0YXRlKSB7XG4gICAgX2V4dGVuZHMoaGlzdG9yeSwgbmV4dFN0YXRlKTtcblxuICAgIGhpc3RvcnkubGVuZ3RoID0gaGlzdG9yeS5lbnRyaWVzLmxlbmd0aDtcbiAgICB0cmFuc2l0aW9uTWFuYWdlci5ub3RpZnlMaXN0ZW5lcnMoaGlzdG9yeS5sb2NhdGlvbiwgaGlzdG9yeS5hY3Rpb24pO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlS2V5KCkge1xuICAgIHJldHVybiBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zdWJzdHIoMiwga2V5TGVuZ3RoKTtcbiAgfVxuXG4gIHZhciBpbmRleCA9IGNsYW1wKGluaXRpYWxJbmRleCwgMCwgaW5pdGlhbEVudHJpZXMubGVuZ3RoIC0gMSk7XG4gIHZhciBlbnRyaWVzID0gaW5pdGlhbEVudHJpZXMubWFwKGZ1bmN0aW9uIChlbnRyeSkge1xuICAgIHJldHVybiB0eXBlb2YgZW50cnkgPT09ICdzdHJpbmcnID8gY3JlYXRlTG9jYXRpb24oZW50cnksIHVuZGVmaW5lZCwgY3JlYXRlS2V5KCkpIDogY3JlYXRlTG9jYXRpb24oZW50cnksIHVuZGVmaW5lZCwgZW50cnkua2V5IHx8IGNyZWF0ZUtleSgpKTtcbiAgfSk7IC8vIFB1YmxpYyBpbnRlcmZhY2VcblxuICB2YXIgY3JlYXRlSHJlZiA9IGNyZWF0ZVBhdGg7XG5cbiAgZnVuY3Rpb24gcHVzaChwYXRoLCBzdGF0ZSkge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IHdhcm5pbmcoISh0eXBlb2YgcGF0aCA9PT0gJ29iamVjdCcgJiYgcGF0aC5zdGF0ZSAhPT0gdW5kZWZpbmVkICYmIHN0YXRlICE9PSB1bmRlZmluZWQpLCAnWW91IHNob3VsZCBhdm9pZCBwcm92aWRpbmcgYSAybmQgc3RhdGUgYXJndW1lbnQgdG8gcHVzaCB3aGVuIHRoZSAxc3QgJyArICdhcmd1bWVudCBpcyBhIGxvY2F0aW9uLWxpa2Ugb2JqZWN0IHRoYXQgYWxyZWFkeSBoYXMgc3RhdGU7IGl0IGlzIGlnbm9yZWQnKSA6IHZvaWQgMDtcbiAgICB2YXIgYWN0aW9uID0gJ1BVU0gnO1xuICAgIHZhciBsb2NhdGlvbiA9IGNyZWF0ZUxvY2F0aW9uKHBhdGgsIHN0YXRlLCBjcmVhdGVLZXkoKSwgaGlzdG9yeS5sb2NhdGlvbik7XG4gICAgdHJhbnNpdGlvbk1hbmFnZXIuY29uZmlybVRyYW5zaXRpb25Ubyhsb2NhdGlvbiwgYWN0aW9uLCBnZXRVc2VyQ29uZmlybWF0aW9uLCBmdW5jdGlvbiAob2spIHtcbiAgICAgIGlmICghb2spIHJldHVybjtcbiAgICAgIHZhciBwcmV2SW5kZXggPSBoaXN0b3J5LmluZGV4O1xuICAgICAgdmFyIG5leHRJbmRleCA9IHByZXZJbmRleCArIDE7XG4gICAgICB2YXIgbmV4dEVudHJpZXMgPSBoaXN0b3J5LmVudHJpZXMuc2xpY2UoMCk7XG5cbiAgICAgIGlmIChuZXh0RW50cmllcy5sZW5ndGggPiBuZXh0SW5kZXgpIHtcbiAgICAgICAgbmV4dEVudHJpZXMuc3BsaWNlKG5leHRJbmRleCwgbmV4dEVudHJpZXMubGVuZ3RoIC0gbmV4dEluZGV4LCBsb2NhdGlvbik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuZXh0RW50cmllcy5wdXNoKGxvY2F0aW9uKTtcbiAgICAgIH1cblxuICAgICAgc2V0U3RhdGUoe1xuICAgICAgICBhY3Rpb246IGFjdGlvbixcbiAgICAgICAgbG9jYXRpb246IGxvY2F0aW9uLFxuICAgICAgICBpbmRleDogbmV4dEluZGV4LFxuICAgICAgICBlbnRyaWVzOiBuZXh0RW50cmllc1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiByZXBsYWNlKHBhdGgsIHN0YXRlKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gd2FybmluZyghKHR5cGVvZiBwYXRoID09PSAnb2JqZWN0JyAmJiBwYXRoLnN0YXRlICE9PSB1bmRlZmluZWQgJiYgc3RhdGUgIT09IHVuZGVmaW5lZCksICdZb3Ugc2hvdWxkIGF2b2lkIHByb3ZpZGluZyBhIDJuZCBzdGF0ZSBhcmd1bWVudCB0byByZXBsYWNlIHdoZW4gdGhlIDFzdCAnICsgJ2FyZ3VtZW50IGlzIGEgbG9jYXRpb24tbGlrZSBvYmplY3QgdGhhdCBhbHJlYWR5IGhhcyBzdGF0ZTsgaXQgaXMgaWdub3JlZCcpIDogdm9pZCAwO1xuICAgIHZhciBhY3Rpb24gPSAnUkVQTEFDRSc7XG4gICAgdmFyIGxvY2F0aW9uID0gY3JlYXRlTG9jYXRpb24ocGF0aCwgc3RhdGUsIGNyZWF0ZUtleSgpLCBoaXN0b3J5LmxvY2F0aW9uKTtcbiAgICB0cmFuc2l0aW9uTWFuYWdlci5jb25maXJtVHJhbnNpdGlvblRvKGxvY2F0aW9uLCBhY3Rpb24sIGdldFVzZXJDb25maXJtYXRpb24sIGZ1bmN0aW9uIChvaykge1xuICAgICAgaWYgKCFvaykgcmV0dXJuO1xuICAgICAgaGlzdG9yeS5lbnRyaWVzW2hpc3RvcnkuaW5kZXhdID0gbG9jYXRpb247XG4gICAgICBzZXRTdGF0ZSh7XG4gICAgICAgIGFjdGlvbjogYWN0aW9uLFxuICAgICAgICBsb2NhdGlvbjogbG9jYXRpb25cbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gZ28obikge1xuICAgIHZhciBuZXh0SW5kZXggPSBjbGFtcChoaXN0b3J5LmluZGV4ICsgbiwgMCwgaGlzdG9yeS5lbnRyaWVzLmxlbmd0aCAtIDEpO1xuICAgIHZhciBhY3Rpb24gPSAnUE9QJztcbiAgICB2YXIgbG9jYXRpb24gPSBoaXN0b3J5LmVudHJpZXNbbmV4dEluZGV4XTtcbiAgICB0cmFuc2l0aW9uTWFuYWdlci5jb25maXJtVHJhbnNpdGlvblRvKGxvY2F0aW9uLCBhY3Rpb24sIGdldFVzZXJDb25maXJtYXRpb24sIGZ1bmN0aW9uIChvaykge1xuICAgICAgaWYgKG9rKSB7XG4gICAgICAgIHNldFN0YXRlKHtcbiAgICAgICAgICBhY3Rpb246IGFjdGlvbixcbiAgICAgICAgICBsb2NhdGlvbjogbG9jYXRpb24sXG4gICAgICAgICAgaW5kZXg6IG5leHRJbmRleFxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIE1pbWljIHRoZSBiZWhhdmlvciBvZiBET00gaGlzdG9yaWVzIGJ5XG4gICAgICAgIC8vIGNhdXNpbmcgYSByZW5kZXIgYWZ0ZXIgYSBjYW5jZWxsZWQgUE9QLlxuICAgICAgICBzZXRTdGF0ZSgpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gZ29CYWNrKCkge1xuICAgIGdvKC0xKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdvRm9yd2FyZCgpIHtcbiAgICBnbygxKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNhbkdvKG4pIHtcbiAgICB2YXIgbmV4dEluZGV4ID0gaGlzdG9yeS5pbmRleCArIG47XG4gICAgcmV0dXJuIG5leHRJbmRleCA+PSAwICYmIG5leHRJbmRleCA8IGhpc3RvcnkuZW50cmllcy5sZW5ndGg7XG4gIH1cblxuICBmdW5jdGlvbiBibG9jayhwcm9tcHQpIHtcbiAgICBpZiAocHJvbXB0ID09PSB2b2lkIDApIHtcbiAgICAgIHByb21wdCA9IGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiB0cmFuc2l0aW9uTWFuYWdlci5zZXRQcm9tcHQocHJvbXB0KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGxpc3RlbihsaXN0ZW5lcikge1xuICAgIHJldHVybiB0cmFuc2l0aW9uTWFuYWdlci5hcHBlbmRMaXN0ZW5lcihsaXN0ZW5lcik7XG4gIH1cblxuICB2YXIgaGlzdG9yeSA9IHtcbiAgICBsZW5ndGg6IGVudHJpZXMubGVuZ3RoLFxuICAgIGFjdGlvbjogJ1BPUCcsXG4gICAgbG9jYXRpb246IGVudHJpZXNbaW5kZXhdLFxuICAgIGluZGV4OiBpbmRleCxcbiAgICBlbnRyaWVzOiBlbnRyaWVzLFxuICAgIGNyZWF0ZUhyZWY6IGNyZWF0ZUhyZWYsXG4gICAgcHVzaDogcHVzaCxcbiAgICByZXBsYWNlOiByZXBsYWNlLFxuICAgIGdvOiBnbyxcbiAgICBnb0JhY2s6IGdvQmFjayxcbiAgICBnb0ZvcndhcmQ6IGdvRm9yd2FyZCxcbiAgICBjYW5HbzogY2FuR28sXG4gICAgYmxvY2s6IGJsb2NrLFxuICAgIGxpc3RlbjogbGlzdGVuXG4gIH07XG4gIHJldHVybiBoaXN0b3J5O1xufVxuXG5leHBvcnQgeyBjcmVhdGVCcm93c2VySGlzdG9yeSwgY3JlYXRlSGFzaEhpc3RvcnksIGNyZWF0ZU1lbW9yeUhpc3RvcnksIGNyZWF0ZUxvY2F0aW9uLCBsb2NhdGlvbnNBcmVFcXVhbCwgcGFyc2VQYXRoLCBjcmVhdGVQYXRoIH07XG4iLCJpbXBvcnQgUmVhY3QsIHsgQ29tcG9uZW50IH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IF9pbmhlcml0c0xvb3NlIGZyb20gJ0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2luaGVyaXRzTG9vc2UnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCB3YXJuaW5nIGZyb20gJ3Rpbnktd2FybmluZyc7XG5cbnZhciBNQVhfU0lHTkVEXzMxX0JJVF9JTlQgPSAxMDczNzQxODIzO1xudmFyIGNvbW1vbmpzR2xvYmFsID0gdHlwZW9mIGdsb2JhbFRoaXMgIT09ICd1bmRlZmluZWQnID8gZ2xvYmFsVGhpcyA6IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gd2luZG93IDogdHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWwgOiB7fTtcblxuZnVuY3Rpb24gZ2V0VW5pcXVlSWQoKSB7XG4gIHZhciBrZXkgPSAnX19nbG9iYWxfdW5pcXVlX2lkX18nO1xuICByZXR1cm4gY29tbW9uanNHbG9iYWxba2V5XSA9IChjb21tb25qc0dsb2JhbFtrZXldIHx8IDApICsgMTtcbn1cblxuZnVuY3Rpb24gb2JqZWN0SXMoeCwgeSkge1xuICBpZiAoeCA9PT0geSkge1xuICAgIHJldHVybiB4ICE9PSAwIHx8IDEgLyB4ID09PSAxIC8geTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4geCAhPT0geCAmJiB5ICE9PSB5O1xuICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUV2ZW50RW1pdHRlcih2YWx1ZSkge1xuICB2YXIgaGFuZGxlcnMgPSBbXTtcbiAgcmV0dXJuIHtcbiAgICBvbjogZnVuY3Rpb24gb24oaGFuZGxlcikge1xuICAgICAgaGFuZGxlcnMucHVzaChoYW5kbGVyKTtcbiAgICB9LFxuICAgIG9mZjogZnVuY3Rpb24gb2ZmKGhhbmRsZXIpIHtcbiAgICAgIGhhbmRsZXJzID0gaGFuZGxlcnMuZmlsdGVyKGZ1bmN0aW9uIChoKSB7XG4gICAgICAgIHJldHVybiBoICE9PSBoYW5kbGVyO1xuICAgICAgfSk7XG4gICAgfSxcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gc2V0KG5ld1ZhbHVlLCBjaGFuZ2VkQml0cykge1xuICAgICAgdmFsdWUgPSBuZXdWYWx1ZTtcbiAgICAgIGhhbmRsZXJzLmZvckVhY2goZnVuY3Rpb24gKGhhbmRsZXIpIHtcbiAgICAgICAgcmV0dXJuIGhhbmRsZXIodmFsdWUsIGNoYW5nZWRCaXRzKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gb25seUNoaWxkKGNoaWxkcmVuKSB7XG4gIHJldHVybiBBcnJheS5pc0FycmF5KGNoaWxkcmVuKSA/IGNoaWxkcmVuWzBdIDogY2hpbGRyZW47XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVJlYWN0Q29udGV4dChkZWZhdWx0VmFsdWUsIGNhbGN1bGF0ZUNoYW5nZWRCaXRzKSB7XG4gIHZhciBfUHJvdmlkZXIkY2hpbGRDb250ZXgsIF9Db25zdW1lciRjb250ZXh0VHlwZTtcblxuICB2YXIgY29udGV4dFByb3AgPSAnX19jcmVhdGUtcmVhY3QtY29udGV4dC0nICsgZ2V0VW5pcXVlSWQoKSArICdfXyc7XG5cbiAgdmFyIFByb3ZpZGVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfQ29tcG9uZW50KSB7XG4gICAgX2luaGVyaXRzTG9vc2UoUHJvdmlkZXIsIF9Db21wb25lbnQpO1xuXG4gICAgZnVuY3Rpb24gUHJvdmlkZXIoKSB7XG4gICAgICB2YXIgX3RoaXM7XG5cbiAgICAgIF90aGlzID0gX0NvbXBvbmVudC5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICBfdGhpcy5lbWl0dGVyID0gY3JlYXRlRXZlbnRFbWl0dGVyKF90aGlzLnByb3BzLnZhbHVlKTtcbiAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG5cbiAgICB2YXIgX3Byb3RvID0gUHJvdmlkZXIucHJvdG90eXBlO1xuXG4gICAgX3Byb3RvLmdldENoaWxkQ29udGV4dCA9IGZ1bmN0aW9uIGdldENoaWxkQ29udGV4dCgpIHtcbiAgICAgIHZhciBfcmVmO1xuXG4gICAgICByZXR1cm4gX3JlZiA9IHt9LCBfcmVmW2NvbnRleHRQcm9wXSA9IHRoaXMuZW1pdHRlciwgX3JlZjtcbiAgICB9O1xuXG4gICAgX3Byb3RvLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgPSBmdW5jdGlvbiBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKG5leHRQcm9wcykge1xuICAgICAgaWYgKHRoaXMucHJvcHMudmFsdWUgIT09IG5leHRQcm9wcy52YWx1ZSkge1xuICAgICAgICB2YXIgb2xkVmFsdWUgPSB0aGlzLnByb3BzLnZhbHVlO1xuICAgICAgICB2YXIgbmV3VmFsdWUgPSBuZXh0UHJvcHMudmFsdWU7XG4gICAgICAgIHZhciBjaGFuZ2VkQml0cztcblxuICAgICAgICBpZiAob2JqZWN0SXMob2xkVmFsdWUsIG5ld1ZhbHVlKSkge1xuICAgICAgICAgIGNoYW5nZWRCaXRzID0gMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjaGFuZ2VkQml0cyA9IHR5cGVvZiBjYWxjdWxhdGVDaGFuZ2VkQml0cyA9PT0gJ2Z1bmN0aW9uJyA/IGNhbGN1bGF0ZUNoYW5nZWRCaXRzKG9sZFZhbHVlLCBuZXdWYWx1ZSkgOiBNQVhfU0lHTkVEXzMxX0JJVF9JTlQ7XG5cbiAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgd2FybmluZygoY2hhbmdlZEJpdHMgJiBNQVhfU0lHTkVEXzMxX0JJVF9JTlQpID09PSBjaGFuZ2VkQml0cywgJ2NhbGN1bGF0ZUNoYW5nZWRCaXRzOiBFeHBlY3RlZCB0aGUgcmV0dXJuIHZhbHVlIHRvIGJlIGEgJyArICczMS1iaXQgaW50ZWdlci4gSW5zdGVhZCByZWNlaXZlZDogJyArIGNoYW5nZWRCaXRzKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjaGFuZ2VkQml0cyB8PSAwO1xuXG4gICAgICAgICAgaWYgKGNoYW5nZWRCaXRzICE9PSAwKSB7XG4gICAgICAgICAgICB0aGlzLmVtaXR0ZXIuc2V0KG5leHRQcm9wcy52YWx1ZSwgY2hhbmdlZEJpdHMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICBfcHJvdG8ucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgICAgcmV0dXJuIHRoaXMucHJvcHMuY2hpbGRyZW47XG4gICAgfTtcblxuICAgIHJldHVybiBQcm92aWRlcjtcbiAgfShDb21wb25lbnQpO1xuXG4gIFByb3ZpZGVyLmNoaWxkQ29udGV4dFR5cGVzID0gKF9Qcm92aWRlciRjaGlsZENvbnRleCA9IHt9LCBfUHJvdmlkZXIkY2hpbGRDb250ZXhbY29udGV4dFByb3BdID0gUHJvcFR5cGVzLm9iamVjdC5pc1JlcXVpcmVkLCBfUHJvdmlkZXIkY2hpbGRDb250ZXgpO1xuXG4gIHZhciBDb25zdW1lciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0NvbXBvbmVudDIpIHtcbiAgICBfaW5oZXJpdHNMb29zZShDb25zdW1lciwgX0NvbXBvbmVudDIpO1xuXG4gICAgZnVuY3Rpb24gQ29uc3VtZXIoKSB7XG4gICAgICB2YXIgX3RoaXMyO1xuXG4gICAgICBfdGhpczIgPSBfQ29tcG9uZW50Mi5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICBfdGhpczIuc3RhdGUgPSB7XG4gICAgICAgIHZhbHVlOiBfdGhpczIuZ2V0VmFsdWUoKVxuICAgICAgfTtcblxuICAgICAgX3RoaXMyLm9uVXBkYXRlID0gZnVuY3Rpb24gKG5ld1ZhbHVlLCBjaGFuZ2VkQml0cykge1xuICAgICAgICB2YXIgb2JzZXJ2ZWRCaXRzID0gX3RoaXMyLm9ic2VydmVkQml0cyB8IDA7XG5cbiAgICAgICAgaWYgKChvYnNlcnZlZEJpdHMgJiBjaGFuZ2VkQml0cykgIT09IDApIHtcbiAgICAgICAgICBfdGhpczIuc2V0U3RhdGUoe1xuICAgICAgICAgICAgdmFsdWU6IF90aGlzMi5nZXRWYWx1ZSgpXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHJldHVybiBfdGhpczI7XG4gICAgfVxuXG4gICAgdmFyIF9wcm90bzIgPSBDb25zdW1lci5wcm90b3R5cGU7XG5cbiAgICBfcHJvdG8yLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgPSBmdW5jdGlvbiBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKG5leHRQcm9wcykge1xuICAgICAgdmFyIG9ic2VydmVkQml0cyA9IG5leHRQcm9wcy5vYnNlcnZlZEJpdHM7XG4gICAgICB0aGlzLm9ic2VydmVkQml0cyA9IG9ic2VydmVkQml0cyA9PT0gdW5kZWZpbmVkIHx8IG9ic2VydmVkQml0cyA9PT0gbnVsbCA/IE1BWF9TSUdORURfMzFfQklUX0lOVCA6IG9ic2VydmVkQml0cztcbiAgICB9O1xuXG4gICAgX3Byb3RvMi5jb21wb25lbnREaWRNb3VudCA9IGZ1bmN0aW9uIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgICAgaWYgKHRoaXMuY29udGV4dFtjb250ZXh0UHJvcF0pIHtcbiAgICAgICAgdGhpcy5jb250ZXh0W2NvbnRleHRQcm9wXS5vbih0aGlzLm9uVXBkYXRlKTtcbiAgICAgIH1cblxuICAgICAgdmFyIG9ic2VydmVkQml0cyA9IHRoaXMucHJvcHMub2JzZXJ2ZWRCaXRzO1xuICAgICAgdGhpcy5vYnNlcnZlZEJpdHMgPSBvYnNlcnZlZEJpdHMgPT09IHVuZGVmaW5lZCB8fCBvYnNlcnZlZEJpdHMgPT09IG51bGwgPyBNQVhfU0lHTkVEXzMxX0JJVF9JTlQgOiBvYnNlcnZlZEJpdHM7XG4gICAgfTtcblxuICAgIF9wcm90bzIuY29tcG9uZW50V2lsbFVubW91bnQgPSBmdW5jdGlvbiBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICAgIGlmICh0aGlzLmNvbnRleHRbY29udGV4dFByb3BdKSB7XG4gICAgICAgIHRoaXMuY29udGV4dFtjb250ZXh0UHJvcF0ub2ZmKHRoaXMub25VcGRhdGUpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBfcHJvdG8yLmdldFZhbHVlID0gZnVuY3Rpb24gZ2V0VmFsdWUoKSB7XG4gICAgICBpZiAodGhpcy5jb250ZXh0W2NvbnRleHRQcm9wXSkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb250ZXh0W2NvbnRleHRQcm9wXS5nZXQoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBkZWZhdWx0VmFsdWU7XG4gICAgICB9XG4gICAgfTtcblxuICAgIF9wcm90bzIucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgICAgcmV0dXJuIG9ubHlDaGlsZCh0aGlzLnByb3BzLmNoaWxkcmVuKSh0aGlzLnN0YXRlLnZhbHVlKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIENvbnN1bWVyO1xuICB9KENvbXBvbmVudCk7XG5cbiAgQ29uc3VtZXIuY29udGV4dFR5cGVzID0gKF9Db25zdW1lciRjb250ZXh0VHlwZSA9IHt9LCBfQ29uc3VtZXIkY29udGV4dFR5cGVbY29udGV4dFByb3BdID0gUHJvcFR5cGVzLm9iamVjdCwgX0NvbnN1bWVyJGNvbnRleHRUeXBlKTtcbiAgcmV0dXJuIHtcbiAgICBQcm92aWRlcjogUHJvdmlkZXIsXG4gICAgQ29uc3VtZXI6IENvbnN1bWVyXG4gIH07XG59XG5cbnZhciBpbmRleCA9IFJlYWN0LmNyZWF0ZUNvbnRleHQgfHwgY3JlYXRlUmVhY3RDb250ZXh0O1xuXG5leHBvcnQgZGVmYXVsdCBpbmRleDtcbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpIHtcbiAgaWYgKHNvdXJjZSA9PSBudWxsKSByZXR1cm4ge307XG4gIHZhciB0YXJnZXQgPSB7fTtcbiAgdmFyIHNvdXJjZUtleXMgPSBPYmplY3Qua2V5cyhzb3VyY2UpO1xuICB2YXIga2V5LCBpO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBzb3VyY2VLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAga2V5ID0gc291cmNlS2V5c1tpXTtcbiAgICBpZiAoZXhjbHVkZWQuaW5kZXhPZihrZXkpID49IDApIGNvbnRpbnVlO1xuICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufSIsImltcG9ydCBfaW5oZXJpdHNMb29zZSBmcm9tICdAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9pbmhlcml0c0xvb3NlJztcbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IHsgY3JlYXRlTWVtb3J5SGlzdG9yeSwgY3JlYXRlTG9jYXRpb24sIGxvY2F0aW9uc0FyZUVxdWFsLCBjcmVhdGVQYXRoIH0gZnJvbSAnaGlzdG9yeSc7XG5pbXBvcnQgd2FybmluZyBmcm9tICd0aW55LXdhcm5pbmcnO1xuaW1wb3J0IGNyZWF0ZUNvbnRleHQgZnJvbSAnbWluaS1jcmVhdGUtcmVhY3QtY29udGV4dCc7XG5pbXBvcnQgaW52YXJpYW50IGZyb20gJ3RpbnktaW52YXJpYW50JztcbmltcG9ydCBfZXh0ZW5kcyBmcm9tICdAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9leHRlbmRzJztcbmltcG9ydCBwYXRoVG9SZWdleHAgZnJvbSAncGF0aC10by1yZWdleHAnO1xuaW1wb3J0IHsgaXNWYWxpZEVsZW1lbnRUeXBlIH0gZnJvbSAncmVhY3QtaXMnO1xuaW1wb3J0IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlIGZyb20gJ0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UnO1xuaW1wb3J0IGhvaXN0U3RhdGljcyBmcm9tICdob2lzdC1ub24tcmVhY3Qtc3RhdGljcyc7XG5cbi8vIFRPRE86IFJlcGxhY2Ugd2l0aCBSZWFjdC5jcmVhdGVDb250ZXh0IG9uY2Ugd2UgY2FuIGFzc3VtZSBSZWFjdCAxNitcblxudmFyIGNyZWF0ZU5hbWVkQ29udGV4dCA9IGZ1bmN0aW9uIGNyZWF0ZU5hbWVkQ29udGV4dChuYW1lKSB7XG4gIHZhciBjb250ZXh0ID0gY3JlYXRlQ29udGV4dCgpO1xuICBjb250ZXh0LmRpc3BsYXlOYW1lID0gbmFtZTtcbiAgcmV0dXJuIGNvbnRleHQ7XG59O1xuXG52YXIgaGlzdG9yeUNvbnRleHQgPSAvKiNfX1BVUkVfXyovY3JlYXRlTmFtZWRDb250ZXh0KFwiUm91dGVyLUhpc3RvcnlcIik7XG5cbnZhciBjb250ZXh0ID0gLyojX19QVVJFX18qL2NyZWF0ZU5hbWVkQ29udGV4dChcIlJvdXRlclwiKTtcblxuLyoqXG4gKiBUaGUgcHVibGljIEFQSSBmb3IgcHV0dGluZyBoaXN0b3J5IG9uIGNvbnRleHQuXG4gKi9cblxudmFyIFJvdXRlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX1JlYWN0JENvbXBvbmVudCkge1xuICBfaW5oZXJpdHNMb29zZShSb3V0ZXIsIF9SZWFjdCRDb21wb25lbnQpO1xuXG4gIFJvdXRlci5jb21wdXRlUm9vdE1hdGNoID0gZnVuY3Rpb24gY29tcHV0ZVJvb3RNYXRjaChwYXRobmFtZSkge1xuICAgIHJldHVybiB7XG4gICAgICBwYXRoOiBcIi9cIixcbiAgICAgIHVybDogXCIvXCIsXG4gICAgICBwYXJhbXM6IHt9LFxuICAgICAgaXNFeGFjdDogcGF0aG5hbWUgPT09IFwiL1wiXG4gICAgfTtcbiAgfTtcblxuICBmdW5jdGlvbiBSb3V0ZXIocHJvcHMpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBfdGhpcyA9IF9SZWFjdCRDb21wb25lbnQuY2FsbCh0aGlzLCBwcm9wcykgfHwgdGhpcztcbiAgICBfdGhpcy5zdGF0ZSA9IHtcbiAgICAgIGxvY2F0aW9uOiBwcm9wcy5oaXN0b3J5LmxvY2F0aW9uXG4gICAgfTsgLy8gVGhpcyBpcyBhIGJpdCBvZiBhIGhhY2suIFdlIGhhdmUgdG8gc3RhcnQgbGlzdGVuaW5nIGZvciBsb2NhdGlvblxuICAgIC8vIGNoYW5nZXMgaGVyZSBpbiB0aGUgY29uc3RydWN0b3IgaW4gY2FzZSB0aGVyZSBhcmUgYW55IDxSZWRpcmVjdD5zXG4gICAgLy8gb24gdGhlIGluaXRpYWwgcmVuZGVyLiBJZiB0aGVyZSBhcmUsIHRoZXkgd2lsbCByZXBsYWNlL3B1c2ggd2hlblxuICAgIC8vIHRoZXkgbW91bnQgYW5kIHNpbmNlIGNETSBmaXJlcyBpbiBjaGlsZHJlbiBiZWZvcmUgcGFyZW50cywgd2UgbWF5XG4gICAgLy8gZ2V0IGEgbmV3IGxvY2F0aW9uIGJlZm9yZSB0aGUgPFJvdXRlcj4gaXMgbW91bnRlZC5cblxuICAgIF90aGlzLl9pc01vdW50ZWQgPSBmYWxzZTtcbiAgICBfdGhpcy5fcGVuZGluZ0xvY2F0aW9uID0gbnVsbDtcblxuICAgIGlmICghcHJvcHMuc3RhdGljQ29udGV4dCkge1xuICAgICAgX3RoaXMudW5saXN0ZW4gPSBwcm9wcy5oaXN0b3J5Lmxpc3RlbihmdW5jdGlvbiAobG9jYXRpb24pIHtcbiAgICAgICAgaWYgKF90aGlzLl9pc01vdW50ZWQpIHtcbiAgICAgICAgICBfdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICBsb2NhdGlvbjogbG9jYXRpb25cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBfdGhpcy5fcGVuZGluZ0xvY2F0aW9uID0gbG9jYXRpb247XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBSb3V0ZXIucHJvdG90eXBlO1xuXG4gIF9wcm90by5jb21wb25lbnREaWRNb3VudCA9IGZ1bmN0aW9uIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgIHRoaXMuX2lzTW91bnRlZCA9IHRydWU7XG5cbiAgICBpZiAodGhpcy5fcGVuZGluZ0xvY2F0aW9uKSB7XG4gICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgbG9jYXRpb246IHRoaXMuX3BlbmRpbmdMb2NhdGlvblxuICAgICAgfSk7XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5jb21wb25lbnRXaWxsVW5tb3VudCA9IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgIGlmICh0aGlzLnVubGlzdGVuKSB7XG4gICAgICB0aGlzLnVubGlzdGVuKCk7XG4gICAgICB0aGlzLl9pc01vdW50ZWQgPSBmYWxzZTtcbiAgICAgIHRoaXMuX3BlbmRpbmdMb2NhdGlvbiA9IG51bGw7XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KGNvbnRleHQuUHJvdmlkZXIsIHtcbiAgICAgIHZhbHVlOiB7XG4gICAgICAgIGhpc3Rvcnk6IHRoaXMucHJvcHMuaGlzdG9yeSxcbiAgICAgICAgbG9jYXRpb246IHRoaXMuc3RhdGUubG9jYXRpb24sXG4gICAgICAgIG1hdGNoOiBSb3V0ZXIuY29tcHV0ZVJvb3RNYXRjaCh0aGlzLnN0YXRlLmxvY2F0aW9uLnBhdGhuYW1lKSxcbiAgICAgICAgc3RhdGljQ29udGV4dDogdGhpcy5wcm9wcy5zdGF0aWNDb250ZXh0XG4gICAgICB9XG4gICAgfSwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoaGlzdG9yeUNvbnRleHQuUHJvdmlkZXIsIHtcbiAgICAgIGNoaWxkcmVuOiB0aGlzLnByb3BzLmNoaWxkcmVuIHx8IG51bGwsXG4gICAgICB2YWx1ZTogdGhpcy5wcm9wcy5oaXN0b3J5XG4gICAgfSkpO1xuICB9O1xuXG4gIHJldHVybiBSb3V0ZXI7XG59KFJlYWN0LkNvbXBvbmVudCk7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgUm91dGVyLnByb3BUeXBlcyA9IHtcbiAgICBjaGlsZHJlbjogUHJvcFR5cGVzLm5vZGUsXG4gICAgaGlzdG9yeTogUHJvcFR5cGVzLm9iamVjdC5pc1JlcXVpcmVkLFxuICAgIHN0YXRpY0NvbnRleHQ6IFByb3BUeXBlcy5vYmplY3RcbiAgfTtcblxuICBSb3V0ZXIucHJvdG90eXBlLmNvbXBvbmVudERpZFVwZGF0ZSA9IGZ1bmN0aW9uIChwcmV2UHJvcHMpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyB3YXJuaW5nKHByZXZQcm9wcy5oaXN0b3J5ID09PSB0aGlzLnByb3BzLmhpc3RvcnksIFwiWW91IGNhbm5vdCBjaGFuZ2UgPFJvdXRlciBoaXN0b3J5PlwiKSA6IHZvaWQgMDtcbiAgfTtcbn1cblxuLyoqXG4gKiBUaGUgcHVibGljIEFQSSBmb3IgYSA8Um91dGVyPiB0aGF0IHN0b3JlcyBsb2NhdGlvbiBpbiBtZW1vcnkuXG4gKi9cblxudmFyIE1lbW9yeVJvdXRlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX1JlYWN0JENvbXBvbmVudCkge1xuICBfaW5oZXJpdHNMb29zZShNZW1vcnlSb3V0ZXIsIF9SZWFjdCRDb21wb25lbnQpO1xuXG4gIGZ1bmN0aW9uIE1lbW9yeVJvdXRlcigpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgX3RoaXMgPSBfUmVhY3QkQ29tcG9uZW50LmNhbGwuYXBwbHkoX1JlYWN0JENvbXBvbmVudCwgW3RoaXNdLmNvbmNhdChhcmdzKSkgfHwgdGhpcztcbiAgICBfdGhpcy5oaXN0b3J5ID0gY3JlYXRlTWVtb3J5SGlzdG9yeShfdGhpcy5wcm9wcyk7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IE1lbW9yeVJvdXRlci5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoUm91dGVyLCB7XG4gICAgICBoaXN0b3J5OiB0aGlzLmhpc3RvcnksXG4gICAgICBjaGlsZHJlbjogdGhpcy5wcm9wcy5jaGlsZHJlblxuICAgIH0pO1xuICB9O1xuXG4gIHJldHVybiBNZW1vcnlSb3V0ZXI7XG59KFJlYWN0LkNvbXBvbmVudCk7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgTWVtb3J5Um91dGVyLnByb3BUeXBlcyA9IHtcbiAgICBpbml0aWFsRW50cmllczogUHJvcFR5cGVzLmFycmF5LFxuICAgIGluaXRpYWxJbmRleDogUHJvcFR5cGVzLm51bWJlcixcbiAgICBnZXRVc2VyQ29uZmlybWF0aW9uOiBQcm9wVHlwZXMuZnVuYyxcbiAgICBrZXlMZW5ndGg6IFByb3BUeXBlcy5udW1iZXIsXG4gICAgY2hpbGRyZW46IFByb3BUeXBlcy5ub2RlXG4gIH07XG5cbiAgTWVtb3J5Um91dGVyLnByb3RvdHlwZS5jb21wb25lbnREaWRNb3VudCA9IGZ1bmN0aW9uICgpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyB3YXJuaW5nKCF0aGlzLnByb3BzLmhpc3RvcnksIFwiPE1lbW9yeVJvdXRlcj4gaWdub3JlcyB0aGUgaGlzdG9yeSBwcm9wLiBUbyB1c2UgYSBjdXN0b20gaGlzdG9yeSwgXCIgKyBcInVzZSBgaW1wb3J0IHsgUm91dGVyIH1gIGluc3RlYWQgb2YgYGltcG9ydCB7IE1lbW9yeVJvdXRlciBhcyBSb3V0ZXIgfWAuXCIpIDogdm9pZCAwO1xuICB9O1xufVxuXG52YXIgTGlmZWN5Y2xlID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfUmVhY3QkQ29tcG9uZW50KSB7XG4gIF9pbmhlcml0c0xvb3NlKExpZmVjeWNsZSwgX1JlYWN0JENvbXBvbmVudCk7XG5cbiAgZnVuY3Rpb24gTGlmZWN5Y2xlKCkge1xuICAgIHJldHVybiBfUmVhY3QkQ29tcG9uZW50LmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBMaWZlY3ljbGUucHJvdG90eXBlO1xuXG4gIF9wcm90by5jb21wb25lbnREaWRNb3VudCA9IGZ1bmN0aW9uIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgIGlmICh0aGlzLnByb3BzLm9uTW91bnQpIHRoaXMucHJvcHMub25Nb3VudC5jYWxsKHRoaXMsIHRoaXMpO1xuICB9O1xuXG4gIF9wcm90by5jb21wb25lbnREaWRVcGRhdGUgPSBmdW5jdGlvbiBjb21wb25lbnREaWRVcGRhdGUocHJldlByb3BzKSB7XG4gICAgaWYgKHRoaXMucHJvcHMub25VcGRhdGUpIHRoaXMucHJvcHMub25VcGRhdGUuY2FsbCh0aGlzLCB0aGlzLCBwcmV2UHJvcHMpO1xuICB9O1xuXG4gIF9wcm90by5jb21wb25lbnRXaWxsVW5tb3VudCA9IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgIGlmICh0aGlzLnByb3BzLm9uVW5tb3VudCkgdGhpcy5wcm9wcy5vblVubW91bnQuY2FsbCh0aGlzLCB0aGlzKTtcbiAgfTtcblxuICBfcHJvdG8ucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgIHJldHVybiBudWxsO1xuICB9O1xuXG4gIHJldHVybiBMaWZlY3ljbGU7XG59KFJlYWN0LkNvbXBvbmVudCk7XG5cbi8qKlxuICogVGhlIHB1YmxpYyBBUEkgZm9yIHByb21wdGluZyB0aGUgdXNlciBiZWZvcmUgbmF2aWdhdGluZyBhd2F5IGZyb20gYSBzY3JlZW4uXG4gKi9cblxuZnVuY3Rpb24gUHJvbXB0KF9yZWYpIHtcbiAgdmFyIG1lc3NhZ2UgPSBfcmVmLm1lc3NhZ2UsXG4gICAgICBfcmVmJHdoZW4gPSBfcmVmLndoZW4sXG4gICAgICB3aGVuID0gX3JlZiR3aGVuID09PSB2b2lkIDAgPyB0cnVlIDogX3JlZiR3aGVuO1xuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoY29udGV4dC5Db25zdW1lciwgbnVsbCwgZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICAhY29udGV4dCA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgXCJZb3Ugc2hvdWxkIG5vdCB1c2UgPFByb21wdD4gb3V0c2lkZSBhIDxSb3V0ZXI+XCIpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgICBpZiAoIXdoZW4gfHwgY29udGV4dC5zdGF0aWNDb250ZXh0KSByZXR1cm4gbnVsbDtcbiAgICB2YXIgbWV0aG9kID0gY29udGV4dC5oaXN0b3J5LmJsb2NrO1xuICAgIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChMaWZlY3ljbGUsIHtcbiAgICAgIG9uTW91bnQ6IGZ1bmN0aW9uIG9uTW91bnQoc2VsZikge1xuICAgICAgICBzZWxmLnJlbGVhc2UgPSBtZXRob2QobWVzc2FnZSk7XG4gICAgICB9LFxuICAgICAgb25VcGRhdGU6IGZ1bmN0aW9uIG9uVXBkYXRlKHNlbGYsIHByZXZQcm9wcykge1xuICAgICAgICBpZiAocHJldlByb3BzLm1lc3NhZ2UgIT09IG1lc3NhZ2UpIHtcbiAgICAgICAgICBzZWxmLnJlbGVhc2UoKTtcbiAgICAgICAgICBzZWxmLnJlbGVhc2UgPSBtZXRob2QobWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBvblVubW91bnQ6IGZ1bmN0aW9uIG9uVW5tb3VudChzZWxmKSB7XG4gICAgICAgIHNlbGYucmVsZWFzZSgpO1xuICAgICAgfSxcbiAgICAgIG1lc3NhZ2U6IG1lc3NhZ2VcbiAgICB9KTtcbiAgfSk7XG59XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgdmFyIG1lc3NhZ2VUeXBlID0gUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLmZ1bmMsIFByb3BUeXBlcy5zdHJpbmddKTtcbiAgUHJvbXB0LnByb3BUeXBlcyA9IHtcbiAgICB3aGVuOiBQcm9wVHlwZXMuYm9vbCxcbiAgICBtZXNzYWdlOiBtZXNzYWdlVHlwZS5pc1JlcXVpcmVkXG4gIH07XG59XG5cbnZhciBjYWNoZSA9IHt9O1xudmFyIGNhY2hlTGltaXQgPSAxMDAwMDtcbnZhciBjYWNoZUNvdW50ID0gMDtcblxuZnVuY3Rpb24gY29tcGlsZVBhdGgocGF0aCkge1xuICBpZiAoY2FjaGVbcGF0aF0pIHJldHVybiBjYWNoZVtwYXRoXTtcbiAgdmFyIGdlbmVyYXRvciA9IHBhdGhUb1JlZ2V4cC5jb21waWxlKHBhdGgpO1xuXG4gIGlmIChjYWNoZUNvdW50IDwgY2FjaGVMaW1pdCkge1xuICAgIGNhY2hlW3BhdGhdID0gZ2VuZXJhdG9yO1xuICAgIGNhY2hlQ291bnQrKztcbiAgfVxuXG4gIHJldHVybiBnZW5lcmF0b3I7XG59XG4vKipcbiAqIFB1YmxpYyBBUEkgZm9yIGdlbmVyYXRpbmcgYSBVUkwgcGF0aG5hbWUgZnJvbSBhIHBhdGggYW5kIHBhcmFtZXRlcnMuXG4gKi9cblxuXG5mdW5jdGlvbiBnZW5lcmF0ZVBhdGgocGF0aCwgcGFyYW1zKSB7XG4gIGlmIChwYXRoID09PSB2b2lkIDApIHtcbiAgICBwYXRoID0gXCIvXCI7XG4gIH1cblxuICBpZiAocGFyYW1zID09PSB2b2lkIDApIHtcbiAgICBwYXJhbXMgPSB7fTtcbiAgfVxuXG4gIHJldHVybiBwYXRoID09PSBcIi9cIiA/IHBhdGggOiBjb21waWxlUGF0aChwYXRoKShwYXJhbXMsIHtcbiAgICBwcmV0dHk6IHRydWVcbiAgfSk7XG59XG5cbi8qKlxuICogVGhlIHB1YmxpYyBBUEkgZm9yIG5hdmlnYXRpbmcgcHJvZ3JhbW1hdGljYWxseSB3aXRoIGEgY29tcG9uZW50LlxuICovXG5cbmZ1bmN0aW9uIFJlZGlyZWN0KF9yZWYpIHtcbiAgdmFyIGNvbXB1dGVkTWF0Y2ggPSBfcmVmLmNvbXB1dGVkTWF0Y2gsXG4gICAgICB0byA9IF9yZWYudG8sXG4gICAgICBfcmVmJHB1c2ggPSBfcmVmLnB1c2gsXG4gICAgICBwdXNoID0gX3JlZiRwdXNoID09PSB2b2lkIDAgPyBmYWxzZSA6IF9yZWYkcHVzaDtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KGNvbnRleHQuQ29uc3VtZXIsIG51bGwsIGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgIWNvbnRleHQgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsIFwiWW91IHNob3VsZCBub3QgdXNlIDxSZWRpcmVjdD4gb3V0c2lkZSBhIDxSb3V0ZXI+XCIpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgICB2YXIgaGlzdG9yeSA9IGNvbnRleHQuaGlzdG9yeSxcbiAgICAgICAgc3RhdGljQ29udGV4dCA9IGNvbnRleHQuc3RhdGljQ29udGV4dDtcbiAgICB2YXIgbWV0aG9kID0gcHVzaCA/IGhpc3RvcnkucHVzaCA6IGhpc3RvcnkucmVwbGFjZTtcbiAgICB2YXIgbG9jYXRpb24gPSBjcmVhdGVMb2NhdGlvbihjb21wdXRlZE1hdGNoID8gdHlwZW9mIHRvID09PSBcInN0cmluZ1wiID8gZ2VuZXJhdGVQYXRoKHRvLCBjb21wdXRlZE1hdGNoLnBhcmFtcykgOiBfZXh0ZW5kcyh7fSwgdG8sIHtcbiAgICAgIHBhdGhuYW1lOiBnZW5lcmF0ZVBhdGgodG8ucGF0aG5hbWUsIGNvbXB1dGVkTWF0Y2gucGFyYW1zKVxuICAgIH0pIDogdG8pOyAvLyBXaGVuIHJlbmRlcmluZyBpbiBhIHN0YXRpYyBjb250ZXh0LFxuICAgIC8vIHNldCB0aGUgbmV3IGxvY2F0aW9uIGltbWVkaWF0ZWx5LlxuXG4gICAgaWYgKHN0YXRpY0NvbnRleHQpIHtcbiAgICAgIG1ldGhvZChsb2NhdGlvbik7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoTGlmZWN5Y2xlLCB7XG4gICAgICBvbk1vdW50OiBmdW5jdGlvbiBvbk1vdW50KCkge1xuICAgICAgICBtZXRob2QobG9jYXRpb24pO1xuICAgICAgfSxcbiAgICAgIG9uVXBkYXRlOiBmdW5jdGlvbiBvblVwZGF0ZShzZWxmLCBwcmV2UHJvcHMpIHtcbiAgICAgICAgdmFyIHByZXZMb2NhdGlvbiA9IGNyZWF0ZUxvY2F0aW9uKHByZXZQcm9wcy50byk7XG5cbiAgICAgICAgaWYgKCFsb2NhdGlvbnNBcmVFcXVhbChwcmV2TG9jYXRpb24sIF9leHRlbmRzKHt9LCBsb2NhdGlvbiwge1xuICAgICAgICAgIGtleTogcHJldkxvY2F0aW9uLmtleVxuICAgICAgICB9KSkpIHtcbiAgICAgICAgICBtZXRob2QobG9jYXRpb24pO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgdG86IHRvXG4gICAgfSk7XG4gIH0pO1xufVxuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gIFJlZGlyZWN0LnByb3BUeXBlcyA9IHtcbiAgICBwdXNoOiBQcm9wVHlwZXMuYm9vbCxcbiAgICBmcm9tOiBQcm9wVHlwZXMuc3RyaW5nLFxuICAgIHRvOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMuc3RyaW5nLCBQcm9wVHlwZXMub2JqZWN0XSkuaXNSZXF1aXJlZFxuICB9O1xufVxuXG52YXIgY2FjaGUkMSA9IHt9O1xudmFyIGNhY2hlTGltaXQkMSA9IDEwMDAwO1xudmFyIGNhY2hlQ291bnQkMSA9IDA7XG5cbmZ1bmN0aW9uIGNvbXBpbGVQYXRoJDEocGF0aCwgb3B0aW9ucykge1xuICB2YXIgY2FjaGVLZXkgPSBcIlwiICsgb3B0aW9ucy5lbmQgKyBvcHRpb25zLnN0cmljdCArIG9wdGlvbnMuc2Vuc2l0aXZlO1xuICB2YXIgcGF0aENhY2hlID0gY2FjaGUkMVtjYWNoZUtleV0gfHwgKGNhY2hlJDFbY2FjaGVLZXldID0ge30pO1xuICBpZiAocGF0aENhY2hlW3BhdGhdKSByZXR1cm4gcGF0aENhY2hlW3BhdGhdO1xuICB2YXIga2V5cyA9IFtdO1xuICB2YXIgcmVnZXhwID0gcGF0aFRvUmVnZXhwKHBhdGgsIGtleXMsIG9wdGlvbnMpO1xuICB2YXIgcmVzdWx0ID0ge1xuICAgIHJlZ2V4cDogcmVnZXhwLFxuICAgIGtleXM6IGtleXNcbiAgfTtcblxuICBpZiAoY2FjaGVDb3VudCQxIDwgY2FjaGVMaW1pdCQxKSB7XG4gICAgcGF0aENhY2hlW3BhdGhdID0gcmVzdWx0O1xuICAgIGNhY2hlQ291bnQkMSsrO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbi8qKlxuICogUHVibGljIEFQSSBmb3IgbWF0Y2hpbmcgYSBVUkwgcGF0aG5hbWUgdG8gYSBwYXRoLlxuICovXG5cblxuZnVuY3Rpb24gbWF0Y2hQYXRoKHBhdGhuYW1lLCBvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICBvcHRpb25zID0ge307XG4gIH1cblxuICBpZiAodHlwZW9mIG9wdGlvbnMgPT09IFwic3RyaW5nXCIgfHwgQXJyYXkuaXNBcnJheShvcHRpb25zKSkge1xuICAgIG9wdGlvbnMgPSB7XG4gICAgICBwYXRoOiBvcHRpb25zXG4gICAgfTtcbiAgfVxuXG4gIHZhciBfb3B0aW9ucyA9IG9wdGlvbnMsXG4gICAgICBwYXRoID0gX29wdGlvbnMucGF0aCxcbiAgICAgIF9vcHRpb25zJGV4YWN0ID0gX29wdGlvbnMuZXhhY3QsXG4gICAgICBleGFjdCA9IF9vcHRpb25zJGV4YWN0ID09PSB2b2lkIDAgPyBmYWxzZSA6IF9vcHRpb25zJGV4YWN0LFxuICAgICAgX29wdGlvbnMkc3RyaWN0ID0gX29wdGlvbnMuc3RyaWN0LFxuICAgICAgc3RyaWN0ID0gX29wdGlvbnMkc3RyaWN0ID09PSB2b2lkIDAgPyBmYWxzZSA6IF9vcHRpb25zJHN0cmljdCxcbiAgICAgIF9vcHRpb25zJHNlbnNpdGl2ZSA9IF9vcHRpb25zLnNlbnNpdGl2ZSxcbiAgICAgIHNlbnNpdGl2ZSA9IF9vcHRpb25zJHNlbnNpdGl2ZSA9PT0gdm9pZCAwID8gZmFsc2UgOiBfb3B0aW9ucyRzZW5zaXRpdmU7XG4gIHZhciBwYXRocyA9IFtdLmNvbmNhdChwYXRoKTtcbiAgcmV0dXJuIHBhdGhzLnJlZHVjZShmdW5jdGlvbiAobWF0Y2hlZCwgcGF0aCkge1xuICAgIGlmICghcGF0aCAmJiBwYXRoICE9PSBcIlwiKSByZXR1cm4gbnVsbDtcbiAgICBpZiAobWF0Y2hlZCkgcmV0dXJuIG1hdGNoZWQ7XG5cbiAgICB2YXIgX2NvbXBpbGVQYXRoID0gY29tcGlsZVBhdGgkMShwYXRoLCB7XG4gICAgICBlbmQ6IGV4YWN0LFxuICAgICAgc3RyaWN0OiBzdHJpY3QsXG4gICAgICBzZW5zaXRpdmU6IHNlbnNpdGl2ZVxuICAgIH0pLFxuICAgICAgICByZWdleHAgPSBfY29tcGlsZVBhdGgucmVnZXhwLFxuICAgICAgICBrZXlzID0gX2NvbXBpbGVQYXRoLmtleXM7XG5cbiAgICB2YXIgbWF0Y2ggPSByZWdleHAuZXhlYyhwYXRobmFtZSk7XG4gICAgaWYgKCFtYXRjaCkgcmV0dXJuIG51bGw7XG4gICAgdmFyIHVybCA9IG1hdGNoWzBdLFxuICAgICAgICB2YWx1ZXMgPSBtYXRjaC5zbGljZSgxKTtcbiAgICB2YXIgaXNFeGFjdCA9IHBhdGhuYW1lID09PSB1cmw7XG4gICAgaWYgKGV4YWN0ICYmICFpc0V4YWN0KSByZXR1cm4gbnVsbDtcbiAgICByZXR1cm4ge1xuICAgICAgcGF0aDogcGF0aCxcbiAgICAgIC8vIHRoZSBwYXRoIHVzZWQgdG8gbWF0Y2hcbiAgICAgIHVybDogcGF0aCA9PT0gXCIvXCIgJiYgdXJsID09PSBcIlwiID8gXCIvXCIgOiB1cmwsXG4gICAgICAvLyB0aGUgbWF0Y2hlZCBwb3J0aW9uIG9mIHRoZSBVUkxcbiAgICAgIGlzRXhhY3Q6IGlzRXhhY3QsXG4gICAgICAvLyB3aGV0aGVyIG9yIG5vdCB3ZSBtYXRjaGVkIGV4YWN0bHlcbiAgICAgIHBhcmFtczoga2V5cy5yZWR1Y2UoZnVuY3Rpb24gKG1lbW8sIGtleSwgaW5kZXgpIHtcbiAgICAgICAgbWVtb1trZXkubmFtZV0gPSB2YWx1ZXNbaW5kZXhdO1xuICAgICAgICByZXR1cm4gbWVtbztcbiAgICAgIH0sIHt9KVxuICAgIH07XG4gIH0sIG51bGwpO1xufVxuXG5mdW5jdGlvbiBpc0VtcHR5Q2hpbGRyZW4oY2hpbGRyZW4pIHtcbiAgcmV0dXJuIFJlYWN0LkNoaWxkcmVuLmNvdW50KGNoaWxkcmVuKSA9PT0gMDtcbn1cblxuZnVuY3Rpb24gZXZhbENoaWxkcmVuRGV2KGNoaWxkcmVuLCBwcm9wcywgcGF0aCkge1xuICB2YXIgdmFsdWUgPSBjaGlsZHJlbihwcm9wcyk7XG4gIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IHdhcm5pbmcodmFsdWUgIT09IHVuZGVmaW5lZCwgXCJZb3UgcmV0dXJuZWQgYHVuZGVmaW5lZGAgZnJvbSB0aGUgYGNoaWxkcmVuYCBmdW5jdGlvbiBvZiBcIiArIChcIjxSb3V0ZVwiICsgKHBhdGggPyBcIiBwYXRoPVxcXCJcIiArIHBhdGggKyBcIlxcXCJcIiA6IFwiXCIpICsgXCI+LCBidXQgeW91IFwiKSArIFwic2hvdWxkIGhhdmUgcmV0dXJuZWQgYSBSZWFjdCBlbGVtZW50IG9yIGBudWxsYFwiKSA6IHZvaWQgMDtcbiAgcmV0dXJuIHZhbHVlIHx8IG51bGw7XG59XG4vKipcbiAqIFRoZSBwdWJsaWMgQVBJIGZvciBtYXRjaGluZyBhIHNpbmdsZSBwYXRoIGFuZCByZW5kZXJpbmcuXG4gKi9cblxuXG52YXIgUm91dGUgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9SZWFjdCRDb21wb25lbnQpIHtcbiAgX2luaGVyaXRzTG9vc2UoUm91dGUsIF9SZWFjdCRDb21wb25lbnQpO1xuXG4gIGZ1bmN0aW9uIFJvdXRlKCkge1xuICAgIHJldHVybiBfUmVhY3QkQ29tcG9uZW50LmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBSb3V0ZS5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KGNvbnRleHQuQ29uc3VtZXIsIG51bGwsIGZ1bmN0aW9uIChjb250ZXh0JDEpIHtcbiAgICAgICFjb250ZXh0JDEgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsIFwiWW91IHNob3VsZCBub3QgdXNlIDxSb3V0ZT4gb3V0c2lkZSBhIDxSb3V0ZXI+XCIpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgICAgIHZhciBsb2NhdGlvbiA9IF90aGlzLnByb3BzLmxvY2F0aW9uIHx8IGNvbnRleHQkMS5sb2NhdGlvbjtcbiAgICAgIHZhciBtYXRjaCA9IF90aGlzLnByb3BzLmNvbXB1dGVkTWF0Y2ggPyBfdGhpcy5wcm9wcy5jb21wdXRlZE1hdGNoIC8vIDxTd2l0Y2g+IGFscmVhZHkgY29tcHV0ZWQgdGhlIG1hdGNoIGZvciB1c1xuICAgICAgOiBfdGhpcy5wcm9wcy5wYXRoID8gbWF0Y2hQYXRoKGxvY2F0aW9uLnBhdGhuYW1lLCBfdGhpcy5wcm9wcykgOiBjb250ZXh0JDEubWF0Y2g7XG5cbiAgICAgIHZhciBwcm9wcyA9IF9leHRlbmRzKHt9LCBjb250ZXh0JDEsIHtcbiAgICAgICAgbG9jYXRpb246IGxvY2F0aW9uLFxuICAgICAgICBtYXRjaDogbWF0Y2hcbiAgICAgIH0pO1xuXG4gICAgICB2YXIgX3RoaXMkcHJvcHMgPSBfdGhpcy5wcm9wcyxcbiAgICAgICAgICBjaGlsZHJlbiA9IF90aGlzJHByb3BzLmNoaWxkcmVuLFxuICAgICAgICAgIGNvbXBvbmVudCA9IF90aGlzJHByb3BzLmNvbXBvbmVudCxcbiAgICAgICAgICByZW5kZXIgPSBfdGhpcyRwcm9wcy5yZW5kZXI7IC8vIFByZWFjdCB1c2VzIGFuIGVtcHR5IGFycmF5IGFzIGNoaWxkcmVuIGJ5XG4gICAgICAvLyBkZWZhdWx0LCBzbyB1c2UgbnVsbCBpZiB0aGF0J3MgdGhlIGNhc2UuXG5cbiAgICAgIGlmIChBcnJheS5pc0FycmF5KGNoaWxkcmVuKSAmJiBpc0VtcHR5Q2hpbGRyZW4oY2hpbGRyZW4pKSB7XG4gICAgICAgIGNoaWxkcmVuID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KGNvbnRleHQuUHJvdmlkZXIsIHtcbiAgICAgICAgdmFsdWU6IHByb3BzXG4gICAgICB9LCBwcm9wcy5tYXRjaCA/IGNoaWxkcmVuID8gdHlwZW9mIGNoaWxkcmVuID09PSBcImZ1bmN0aW9uXCIgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBldmFsQ2hpbGRyZW5EZXYoY2hpbGRyZW4sIHByb3BzLCBfdGhpcy5wcm9wcy5wYXRoKSA6IGNoaWxkcmVuKHByb3BzKSA6IGNoaWxkcmVuIDogY29tcG9uZW50ID8gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoY29tcG9uZW50LCBwcm9wcykgOiByZW5kZXIgPyByZW5kZXIocHJvcHMpIDogbnVsbCA6IHR5cGVvZiBjaGlsZHJlbiA9PT0gXCJmdW5jdGlvblwiID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gZXZhbENoaWxkcmVuRGV2KGNoaWxkcmVuLCBwcm9wcywgX3RoaXMucHJvcHMucGF0aCkgOiBjaGlsZHJlbihwcm9wcykgOiBudWxsKTtcbiAgICB9KTtcbiAgfTtcblxuICByZXR1cm4gUm91dGU7XG59KFJlYWN0LkNvbXBvbmVudCk7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgUm91dGUucHJvcFR5cGVzID0ge1xuICAgIGNoaWxkcmVuOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMuZnVuYywgUHJvcFR5cGVzLm5vZGVdKSxcbiAgICBjb21wb25lbnQ6IGZ1bmN0aW9uIGNvbXBvbmVudChwcm9wcywgcHJvcE5hbWUpIHtcbiAgICAgIGlmIChwcm9wc1twcm9wTmFtZV0gJiYgIWlzVmFsaWRFbGVtZW50VHlwZShwcm9wc1twcm9wTmFtZV0pKSB7XG4gICAgICAgIHJldHVybiBuZXcgRXJyb3IoXCJJbnZhbGlkIHByb3AgJ2NvbXBvbmVudCcgc3VwcGxpZWQgdG8gJ1JvdXRlJzogdGhlIHByb3AgaXMgbm90IGEgdmFsaWQgUmVhY3QgY29tcG9uZW50XCIpO1xuICAgICAgfVxuICAgIH0sXG4gICAgZXhhY3Q6IFByb3BUeXBlcy5ib29sLFxuICAgIGxvY2F0aW9uOiBQcm9wVHlwZXMub2JqZWN0LFxuICAgIHBhdGg6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5zdHJpbmcsIFByb3BUeXBlcy5hcnJheU9mKFByb3BUeXBlcy5zdHJpbmcpXSksXG4gICAgcmVuZGVyOiBQcm9wVHlwZXMuZnVuYyxcbiAgICBzZW5zaXRpdmU6IFByb3BUeXBlcy5ib29sLFxuICAgIHN0cmljdDogUHJvcFR5cGVzLmJvb2xcbiAgfTtcblxuICBSb3V0ZS5wcm90b3R5cGUuY29tcG9uZW50RGlkTW91bnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gd2FybmluZyghKHRoaXMucHJvcHMuY2hpbGRyZW4gJiYgIWlzRW1wdHlDaGlsZHJlbih0aGlzLnByb3BzLmNoaWxkcmVuKSAmJiB0aGlzLnByb3BzLmNvbXBvbmVudCksIFwiWW91IHNob3VsZCBub3QgdXNlIDxSb3V0ZSBjb21wb25lbnQ+IGFuZCA8Um91dGUgY2hpbGRyZW4+IGluIHRoZSBzYW1lIHJvdXRlOyA8Um91dGUgY29tcG9uZW50PiB3aWxsIGJlIGlnbm9yZWRcIikgOiB2b2lkIDA7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gd2FybmluZyghKHRoaXMucHJvcHMuY2hpbGRyZW4gJiYgIWlzRW1wdHlDaGlsZHJlbih0aGlzLnByb3BzLmNoaWxkcmVuKSAmJiB0aGlzLnByb3BzLnJlbmRlciksIFwiWW91IHNob3VsZCBub3QgdXNlIDxSb3V0ZSByZW5kZXI+IGFuZCA8Um91dGUgY2hpbGRyZW4+IGluIHRoZSBzYW1lIHJvdXRlOyA8Um91dGUgcmVuZGVyPiB3aWxsIGJlIGlnbm9yZWRcIikgOiB2b2lkIDA7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gd2FybmluZyghKHRoaXMucHJvcHMuY29tcG9uZW50ICYmIHRoaXMucHJvcHMucmVuZGVyKSwgXCJZb3Ugc2hvdWxkIG5vdCB1c2UgPFJvdXRlIGNvbXBvbmVudD4gYW5kIDxSb3V0ZSByZW5kZXI+IGluIHRoZSBzYW1lIHJvdXRlOyA8Um91dGUgcmVuZGVyPiB3aWxsIGJlIGlnbm9yZWRcIikgOiB2b2lkIDA7XG4gIH07XG5cbiAgUm91dGUucHJvdG90eXBlLmNvbXBvbmVudERpZFVwZGF0ZSA9IGZ1bmN0aW9uIChwcmV2UHJvcHMpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyB3YXJuaW5nKCEodGhpcy5wcm9wcy5sb2NhdGlvbiAmJiAhcHJldlByb3BzLmxvY2F0aW9uKSwgJzxSb3V0ZT4gZWxlbWVudHMgc2hvdWxkIG5vdCBjaGFuZ2UgZnJvbSB1bmNvbnRyb2xsZWQgdG8gY29udHJvbGxlZCAob3IgdmljZSB2ZXJzYSkuIFlvdSBpbml0aWFsbHkgdXNlZCBubyBcImxvY2F0aW9uXCIgcHJvcCBhbmQgdGhlbiBwcm92aWRlZCBvbmUgb24gYSBzdWJzZXF1ZW50IHJlbmRlci4nKSA6IHZvaWQgMDtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyB3YXJuaW5nKCEoIXRoaXMucHJvcHMubG9jYXRpb24gJiYgcHJldlByb3BzLmxvY2F0aW9uKSwgJzxSb3V0ZT4gZWxlbWVudHMgc2hvdWxkIG5vdCBjaGFuZ2UgZnJvbSBjb250cm9sbGVkIHRvIHVuY29udHJvbGxlZCAob3IgdmljZSB2ZXJzYSkuIFlvdSBwcm92aWRlZCBhIFwibG9jYXRpb25cIiBwcm9wIGluaXRpYWxseSBidXQgb21pdHRlZCBpdCBvbiBhIHN1YnNlcXVlbnQgcmVuZGVyLicpIDogdm9pZCAwO1xuICB9O1xufVxuXG5mdW5jdGlvbiBhZGRMZWFkaW5nU2xhc2gocGF0aCkge1xuICByZXR1cm4gcGF0aC5jaGFyQXQoMCkgPT09IFwiL1wiID8gcGF0aCA6IFwiL1wiICsgcGF0aDtcbn1cblxuZnVuY3Rpb24gYWRkQmFzZW5hbWUoYmFzZW5hbWUsIGxvY2F0aW9uKSB7XG4gIGlmICghYmFzZW5hbWUpIHJldHVybiBsb2NhdGlvbjtcbiAgcmV0dXJuIF9leHRlbmRzKHt9LCBsb2NhdGlvbiwge1xuICAgIHBhdGhuYW1lOiBhZGRMZWFkaW5nU2xhc2goYmFzZW5hbWUpICsgbG9jYXRpb24ucGF0aG5hbWVcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHN0cmlwQmFzZW5hbWUoYmFzZW5hbWUsIGxvY2F0aW9uKSB7XG4gIGlmICghYmFzZW5hbWUpIHJldHVybiBsb2NhdGlvbjtcbiAgdmFyIGJhc2UgPSBhZGRMZWFkaW5nU2xhc2goYmFzZW5hbWUpO1xuICBpZiAobG9jYXRpb24ucGF0aG5hbWUuaW5kZXhPZihiYXNlKSAhPT0gMCkgcmV0dXJuIGxvY2F0aW9uO1xuICByZXR1cm4gX2V4dGVuZHMoe30sIGxvY2F0aW9uLCB7XG4gICAgcGF0aG5hbWU6IGxvY2F0aW9uLnBhdGhuYW1lLnN1YnN0cihiYXNlLmxlbmd0aClcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVVSTChsb2NhdGlvbikge1xuICByZXR1cm4gdHlwZW9mIGxvY2F0aW9uID09PSBcInN0cmluZ1wiID8gbG9jYXRpb24gOiBjcmVhdGVQYXRoKGxvY2F0aW9uKTtcbn1cblxuZnVuY3Rpb24gc3RhdGljSGFuZGxlcihtZXRob2ROYW1lKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgXCJZb3UgY2Fubm90ICVzIHdpdGggPFN0YXRpY1JvdXRlcj5cIiwgbWV0aG9kTmFtZSkgOiBpbnZhcmlhbnQoZmFsc2UpIDtcbiAgfTtcbn1cblxuZnVuY3Rpb24gbm9vcCgpIHt9XG4vKipcbiAqIFRoZSBwdWJsaWMgdG9wLWxldmVsIEFQSSBmb3IgYSBcInN0YXRpY1wiIDxSb3V0ZXI+LCBzby1jYWxsZWQgYmVjYXVzZSBpdFxuICogY2FuJ3QgYWN0dWFsbHkgY2hhbmdlIHRoZSBjdXJyZW50IGxvY2F0aW9uLiBJbnN0ZWFkLCBpdCBqdXN0IHJlY29yZHNcbiAqIGxvY2F0aW9uIGNoYW5nZXMgaW4gYSBjb250ZXh0IG9iamVjdC4gVXNlZnVsIG1haW5seSBpbiB0ZXN0aW5nIGFuZFxuICogc2VydmVyLXJlbmRlcmluZyBzY2VuYXJpb3MuXG4gKi9cblxuXG52YXIgU3RhdGljUm91dGVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfUmVhY3QkQ29tcG9uZW50KSB7XG4gIF9pbmhlcml0c0xvb3NlKFN0YXRpY1JvdXRlciwgX1JlYWN0JENvbXBvbmVudCk7XG5cbiAgZnVuY3Rpb24gU3RhdGljUm91dGVyKCkge1xuICAgIHZhciBfdGhpcztcblxuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICBfdGhpcyA9IF9SZWFjdCRDb21wb25lbnQuY2FsbC5hcHBseShfUmVhY3QkQ29tcG9uZW50LCBbdGhpc10uY29uY2F0KGFyZ3MpKSB8fCB0aGlzO1xuXG4gICAgX3RoaXMuaGFuZGxlUHVzaCA9IGZ1bmN0aW9uIChsb2NhdGlvbikge1xuICAgICAgcmV0dXJuIF90aGlzLm5hdmlnYXRlVG8obG9jYXRpb24sIFwiUFVTSFwiKTtcbiAgICB9O1xuXG4gICAgX3RoaXMuaGFuZGxlUmVwbGFjZSA9IGZ1bmN0aW9uIChsb2NhdGlvbikge1xuICAgICAgcmV0dXJuIF90aGlzLm5hdmlnYXRlVG8obG9jYXRpb24sIFwiUkVQTEFDRVwiKTtcbiAgICB9O1xuXG4gICAgX3RoaXMuaGFuZGxlTGlzdGVuID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIG5vb3A7XG4gICAgfTtcblxuICAgIF90aGlzLmhhbmRsZUJsb2NrID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIG5vb3A7XG4gICAgfTtcblxuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBTdGF0aWNSb3V0ZXIucHJvdG90eXBlO1xuXG4gIF9wcm90by5uYXZpZ2F0ZVRvID0gZnVuY3Rpb24gbmF2aWdhdGVUbyhsb2NhdGlvbiwgYWN0aW9uKSB7XG4gICAgdmFyIF90aGlzJHByb3BzID0gdGhpcy5wcm9wcyxcbiAgICAgICAgX3RoaXMkcHJvcHMkYmFzZW5hbWUgPSBfdGhpcyRwcm9wcy5iYXNlbmFtZSxcbiAgICAgICAgYmFzZW5hbWUgPSBfdGhpcyRwcm9wcyRiYXNlbmFtZSA9PT0gdm9pZCAwID8gXCJcIiA6IF90aGlzJHByb3BzJGJhc2VuYW1lLFxuICAgICAgICBfdGhpcyRwcm9wcyRjb250ZXh0ID0gX3RoaXMkcHJvcHMuY29udGV4dCxcbiAgICAgICAgY29udGV4dCA9IF90aGlzJHByb3BzJGNvbnRleHQgPT09IHZvaWQgMCA/IHt9IDogX3RoaXMkcHJvcHMkY29udGV4dDtcbiAgICBjb250ZXh0LmFjdGlvbiA9IGFjdGlvbjtcbiAgICBjb250ZXh0LmxvY2F0aW9uID0gYWRkQmFzZW5hbWUoYmFzZW5hbWUsIGNyZWF0ZUxvY2F0aW9uKGxvY2F0aW9uKSk7XG4gICAgY29udGV4dC51cmwgPSBjcmVhdGVVUkwoY29udGV4dC5sb2NhdGlvbik7XG4gIH07XG5cbiAgX3Byb3RvLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICB2YXIgX3RoaXMkcHJvcHMyID0gdGhpcy5wcm9wcyxcbiAgICAgICAgX3RoaXMkcHJvcHMyJGJhc2VuYW1lID0gX3RoaXMkcHJvcHMyLmJhc2VuYW1lLFxuICAgICAgICBiYXNlbmFtZSA9IF90aGlzJHByb3BzMiRiYXNlbmFtZSA9PT0gdm9pZCAwID8gXCJcIiA6IF90aGlzJHByb3BzMiRiYXNlbmFtZSxcbiAgICAgICAgX3RoaXMkcHJvcHMyJGNvbnRleHQgPSBfdGhpcyRwcm9wczIuY29udGV4dCxcbiAgICAgICAgY29udGV4dCA9IF90aGlzJHByb3BzMiRjb250ZXh0ID09PSB2b2lkIDAgPyB7fSA6IF90aGlzJHByb3BzMiRjb250ZXh0LFxuICAgICAgICBfdGhpcyRwcm9wczIkbG9jYXRpb24gPSBfdGhpcyRwcm9wczIubG9jYXRpb24sXG4gICAgICAgIGxvY2F0aW9uID0gX3RoaXMkcHJvcHMyJGxvY2F0aW9uID09PSB2b2lkIDAgPyBcIi9cIiA6IF90aGlzJHByb3BzMiRsb2NhdGlvbixcbiAgICAgICAgcmVzdCA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKF90aGlzJHByb3BzMiwgW1wiYmFzZW5hbWVcIiwgXCJjb250ZXh0XCIsIFwibG9jYXRpb25cIl0pO1xuXG4gICAgdmFyIGhpc3RvcnkgPSB7XG4gICAgICBjcmVhdGVIcmVmOiBmdW5jdGlvbiBjcmVhdGVIcmVmKHBhdGgpIHtcbiAgICAgICAgcmV0dXJuIGFkZExlYWRpbmdTbGFzaChiYXNlbmFtZSArIGNyZWF0ZVVSTChwYXRoKSk7XG4gICAgICB9LFxuICAgICAgYWN0aW9uOiBcIlBPUFwiLFxuICAgICAgbG9jYXRpb246IHN0cmlwQmFzZW5hbWUoYmFzZW5hbWUsIGNyZWF0ZUxvY2F0aW9uKGxvY2F0aW9uKSksXG4gICAgICBwdXNoOiB0aGlzLmhhbmRsZVB1c2gsXG4gICAgICByZXBsYWNlOiB0aGlzLmhhbmRsZVJlcGxhY2UsXG4gICAgICBnbzogc3RhdGljSGFuZGxlcihcImdvXCIpLFxuICAgICAgZ29CYWNrOiBzdGF0aWNIYW5kbGVyKFwiZ29CYWNrXCIpLFxuICAgICAgZ29Gb3J3YXJkOiBzdGF0aWNIYW5kbGVyKFwiZ29Gb3J3YXJkXCIpLFxuICAgICAgbGlzdGVuOiB0aGlzLmhhbmRsZUxpc3RlbixcbiAgICAgIGJsb2NrOiB0aGlzLmhhbmRsZUJsb2NrXG4gICAgfTtcbiAgICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoUm91dGVyLCBfZXh0ZW5kcyh7fSwgcmVzdCwge1xuICAgICAgaGlzdG9yeTogaGlzdG9yeSxcbiAgICAgIHN0YXRpY0NvbnRleHQ6IGNvbnRleHRcbiAgICB9KSk7XG4gIH07XG5cbiAgcmV0dXJuIFN0YXRpY1JvdXRlcjtcbn0oUmVhY3QuQ29tcG9uZW50KTtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICBTdGF0aWNSb3V0ZXIucHJvcFR5cGVzID0ge1xuICAgIGJhc2VuYW1lOiBQcm9wVHlwZXMuc3RyaW5nLFxuICAgIGNvbnRleHQ6IFByb3BUeXBlcy5vYmplY3QsXG4gICAgbG9jYXRpb246IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5zdHJpbmcsIFByb3BUeXBlcy5vYmplY3RdKVxuICB9O1xuXG4gIFN0YXRpY1JvdXRlci5wcm90b3R5cGUuY29tcG9uZW50RGlkTW91bnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gd2FybmluZyghdGhpcy5wcm9wcy5oaXN0b3J5LCBcIjxTdGF0aWNSb3V0ZXI+IGlnbm9yZXMgdGhlIGhpc3RvcnkgcHJvcC4gVG8gdXNlIGEgY3VzdG9tIGhpc3RvcnksIFwiICsgXCJ1c2UgYGltcG9ydCB7IFJvdXRlciB9YCBpbnN0ZWFkIG9mIGBpbXBvcnQgeyBTdGF0aWNSb3V0ZXIgYXMgUm91dGVyIH1gLlwiKSA6IHZvaWQgMDtcbiAgfTtcbn1cblxuLyoqXG4gKiBUaGUgcHVibGljIEFQSSBmb3IgcmVuZGVyaW5nIHRoZSBmaXJzdCA8Um91dGU+IHRoYXQgbWF0Y2hlcy5cbiAqL1xuXG52YXIgU3dpdGNoID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfUmVhY3QkQ29tcG9uZW50KSB7XG4gIF9pbmhlcml0c0xvb3NlKFN3aXRjaCwgX1JlYWN0JENvbXBvbmVudCk7XG5cbiAgZnVuY3Rpb24gU3dpdGNoKCkge1xuICAgIHJldHVybiBfUmVhY3QkQ29tcG9uZW50LmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBTd2l0Y2gucHJvdG90eXBlO1xuXG4gIF9wcm90by5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChjb250ZXh0LkNvbnN1bWVyLCBudWxsLCBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgICAgIWNvbnRleHQgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsIFwiWW91IHNob3VsZCBub3QgdXNlIDxTd2l0Y2g+IG91dHNpZGUgYSA8Um91dGVyPlwiKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gICAgICB2YXIgbG9jYXRpb24gPSBfdGhpcy5wcm9wcy5sb2NhdGlvbiB8fCBjb250ZXh0LmxvY2F0aW9uO1xuICAgICAgdmFyIGVsZW1lbnQsIG1hdGNoOyAvLyBXZSB1c2UgUmVhY3QuQ2hpbGRyZW4uZm9yRWFjaCBpbnN0ZWFkIG9mIFJlYWN0LkNoaWxkcmVuLnRvQXJyYXkoKS5maW5kKClcbiAgICAgIC8vIGhlcmUgYmVjYXVzZSB0b0FycmF5IGFkZHMga2V5cyB0byBhbGwgY2hpbGQgZWxlbWVudHMgYW5kIHdlIGRvIG5vdCB3YW50XG4gICAgICAvLyB0byB0cmlnZ2VyIGFuIHVubW91bnQvcmVtb3VudCBmb3IgdHdvIDxSb3V0ZT5zIHRoYXQgcmVuZGVyIHRoZSBzYW1lXG4gICAgICAvLyBjb21wb25lbnQgYXQgZGlmZmVyZW50IFVSTHMuXG5cbiAgICAgIFJlYWN0LkNoaWxkcmVuLmZvckVhY2goX3RoaXMucHJvcHMuY2hpbGRyZW4sIGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICBpZiAobWF0Y2ggPT0gbnVsbCAmJiAvKiNfX1BVUkVfXyovUmVhY3QuaXNWYWxpZEVsZW1lbnQoY2hpbGQpKSB7XG4gICAgICAgICAgZWxlbWVudCA9IGNoaWxkO1xuICAgICAgICAgIHZhciBwYXRoID0gY2hpbGQucHJvcHMucGF0aCB8fCBjaGlsZC5wcm9wcy5mcm9tO1xuICAgICAgICAgIG1hdGNoID0gcGF0aCA/IG1hdGNoUGF0aChsb2NhdGlvbi5wYXRobmFtZSwgX2V4dGVuZHMoe30sIGNoaWxkLnByb3BzLCB7XG4gICAgICAgICAgICBwYXRoOiBwYXRoXG4gICAgICAgICAgfSkpIDogY29udGV4dC5tYXRjaDtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gbWF0Y2ggPyAvKiNfX1BVUkVfXyovUmVhY3QuY2xvbmVFbGVtZW50KGVsZW1lbnQsIHtcbiAgICAgICAgbG9jYXRpb246IGxvY2F0aW9uLFxuICAgICAgICBjb21wdXRlZE1hdGNoOiBtYXRjaFxuICAgICAgfSkgOiBudWxsO1xuICAgIH0pO1xuICB9O1xuXG4gIHJldHVybiBTd2l0Y2g7XG59KFJlYWN0LkNvbXBvbmVudCk7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgU3dpdGNoLnByb3BUeXBlcyA9IHtcbiAgICBjaGlsZHJlbjogUHJvcFR5cGVzLm5vZGUsXG4gICAgbG9jYXRpb246IFByb3BUeXBlcy5vYmplY3RcbiAgfTtcblxuICBTd2l0Y2gucHJvdG90eXBlLmNvbXBvbmVudERpZFVwZGF0ZSA9IGZ1bmN0aW9uIChwcmV2UHJvcHMpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyB3YXJuaW5nKCEodGhpcy5wcm9wcy5sb2NhdGlvbiAmJiAhcHJldlByb3BzLmxvY2F0aW9uKSwgJzxTd2l0Y2g+IGVsZW1lbnRzIHNob3VsZCBub3QgY2hhbmdlIGZyb20gdW5jb250cm9sbGVkIHRvIGNvbnRyb2xsZWQgKG9yIHZpY2UgdmVyc2EpLiBZb3UgaW5pdGlhbGx5IHVzZWQgbm8gXCJsb2NhdGlvblwiIHByb3AgYW5kIHRoZW4gcHJvdmlkZWQgb25lIG9uIGEgc3Vic2VxdWVudCByZW5kZXIuJykgOiB2b2lkIDA7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gd2FybmluZyghKCF0aGlzLnByb3BzLmxvY2F0aW9uICYmIHByZXZQcm9wcy5sb2NhdGlvbiksICc8U3dpdGNoPiBlbGVtZW50cyBzaG91bGQgbm90IGNoYW5nZSBmcm9tIGNvbnRyb2xsZWQgdG8gdW5jb250cm9sbGVkIChvciB2aWNlIHZlcnNhKS4gWW91IHByb3ZpZGVkIGEgXCJsb2NhdGlvblwiIHByb3AgaW5pdGlhbGx5IGJ1dCBvbWl0dGVkIGl0IG9uIGEgc3Vic2VxdWVudCByZW5kZXIuJykgOiB2b2lkIDA7XG4gIH07XG59XG5cbi8qKlxuICogQSBwdWJsaWMgaGlnaGVyLW9yZGVyIGNvbXBvbmVudCB0byBhY2Nlc3MgdGhlIGltcGVyYXRpdmUgQVBJXG4gKi9cblxuZnVuY3Rpb24gd2l0aFJvdXRlcihDb21wb25lbnQpIHtcbiAgdmFyIGRpc3BsYXlOYW1lID0gXCJ3aXRoUm91dGVyKFwiICsgKENvbXBvbmVudC5kaXNwbGF5TmFtZSB8fCBDb21wb25lbnQubmFtZSkgKyBcIilcIjtcblxuICB2YXIgQyA9IGZ1bmN0aW9uIEMocHJvcHMpIHtcbiAgICB2YXIgd3JhcHBlZENvbXBvbmVudFJlZiA9IHByb3BzLndyYXBwZWRDb21wb25lbnRSZWYsXG4gICAgICAgIHJlbWFpbmluZ1Byb3BzID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UocHJvcHMsIFtcIndyYXBwZWRDb21wb25lbnRSZWZcIl0pO1xuXG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KGNvbnRleHQuQ29uc3VtZXIsIG51bGwsIGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgICAhY29udGV4dCA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgXCJZb3Ugc2hvdWxkIG5vdCB1c2UgPFwiICsgZGlzcGxheU5hbWUgKyBcIiAvPiBvdXRzaWRlIGEgPFJvdXRlcj5cIikgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KENvbXBvbmVudCwgX2V4dGVuZHMoe30sIHJlbWFpbmluZ1Byb3BzLCBjb250ZXh0LCB7XG4gICAgICAgIHJlZjogd3JhcHBlZENvbXBvbmVudFJlZlxuICAgICAgfSkpO1xuICAgIH0pO1xuICB9O1xuXG4gIEMuZGlzcGxheU5hbWUgPSBkaXNwbGF5TmFtZTtcbiAgQy5XcmFwcGVkQ29tcG9uZW50ID0gQ29tcG9uZW50O1xuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICBDLnByb3BUeXBlcyA9IHtcbiAgICAgIHdyYXBwZWRDb21wb25lbnRSZWY6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5zdHJpbmcsIFByb3BUeXBlcy5mdW5jLCBQcm9wVHlwZXMub2JqZWN0XSlcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIGhvaXN0U3RhdGljcyhDLCBDb21wb25lbnQpO1xufVxuXG52YXIgdXNlQ29udGV4dCA9IFJlYWN0LnVzZUNvbnRleHQ7XG5mdW5jdGlvbiB1c2VIaXN0b3J5KCkge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgISh0eXBlb2YgdXNlQ29udGV4dCA9PT0gXCJmdW5jdGlvblwiKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgXCJZb3UgbXVzdCB1c2UgUmVhY3QgPj0gMTYuOCBpbiBvcmRlciB0byB1c2UgdXNlSGlzdG9yeSgpXCIpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgfVxuXG4gIHJldHVybiB1c2VDb250ZXh0KGhpc3RvcnlDb250ZXh0KTtcbn1cbmZ1bmN0aW9uIHVzZUxvY2F0aW9uKCkge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgISh0eXBlb2YgdXNlQ29udGV4dCA9PT0gXCJmdW5jdGlvblwiKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgXCJZb3UgbXVzdCB1c2UgUmVhY3QgPj0gMTYuOCBpbiBvcmRlciB0byB1c2UgdXNlTG9jYXRpb24oKVwiKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gIH1cblxuICByZXR1cm4gdXNlQ29udGV4dChjb250ZXh0KS5sb2NhdGlvbjtcbn1cbmZ1bmN0aW9uIHVzZVBhcmFtcygpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICEodHlwZW9mIHVzZUNvbnRleHQgPT09IFwiZnVuY3Rpb25cIikgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsIFwiWW91IG11c3QgdXNlIFJlYWN0ID49IDE2LjggaW4gb3JkZXIgdG8gdXNlIHVzZVBhcmFtcygpXCIpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgfVxuXG4gIHZhciBtYXRjaCA9IHVzZUNvbnRleHQoY29udGV4dCkubWF0Y2g7XG4gIHJldHVybiBtYXRjaCA/IG1hdGNoLnBhcmFtcyA6IHt9O1xufVxuZnVuY3Rpb24gdXNlUm91dGVNYXRjaChwYXRoKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAhKHR5cGVvZiB1c2VDb250ZXh0ID09PSBcImZ1bmN0aW9uXCIpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCBcIllvdSBtdXN0IHVzZSBSZWFjdCA+PSAxNi44IGluIG9yZGVyIHRvIHVzZSB1c2VSb3V0ZU1hdGNoKClcIikgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICB9XG5cbiAgdmFyIGxvY2F0aW9uID0gdXNlTG9jYXRpb24oKTtcbiAgdmFyIG1hdGNoID0gdXNlQ29udGV4dChjb250ZXh0KS5tYXRjaDtcbiAgcmV0dXJuIHBhdGggPyBtYXRjaFBhdGgobG9jYXRpb24ucGF0aG5hbWUsIHBhdGgpIDogbWF0Y2g7XG59XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICB2YXIgZ2xvYmFsID0gd2luZG93O1xuICAgIHZhciBrZXkgPSBcIl9fcmVhY3Rfcm91dGVyX2J1aWxkX19cIjtcbiAgICB2YXIgYnVpbGROYW1lcyA9IHtcbiAgICAgIGNqczogXCJDb21tb25KU1wiLFxuICAgICAgZXNtOiBcIkVTIG1vZHVsZXNcIixcbiAgICAgIHVtZDogXCJVTURcIlxuICAgIH07XG5cbiAgICBpZiAoZ2xvYmFsW2tleV0gJiYgZ2xvYmFsW2tleV0gIT09IFwiZXNtXCIpIHtcbiAgICAgIHZhciBpbml0aWFsQnVpbGROYW1lID0gYnVpbGROYW1lc1tnbG9iYWxba2V5XV07XG4gICAgICB2YXIgc2Vjb25kYXJ5QnVpbGROYW1lID0gYnVpbGROYW1lc1tcImVzbVwiXTsgLy8gVE9ETzogQWRkIGxpbmsgdG8gYXJ0aWNsZSB0aGF0IGV4cGxhaW5zIGluIGRldGFpbCBob3cgdG8gYXZvaWRcbiAgICAgIC8vIGxvYWRpbmcgMiBkaWZmZXJlbnQgYnVpbGRzLlxuXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJZb3UgYXJlIGxvYWRpbmcgdGhlIFwiICsgc2Vjb25kYXJ5QnVpbGROYW1lICsgXCIgYnVpbGQgb2YgUmVhY3QgUm91dGVyIFwiICsgKFwib24gYSBwYWdlIHRoYXQgaXMgYWxyZWFkeSBydW5uaW5nIHRoZSBcIiArIGluaXRpYWxCdWlsZE5hbWUgKyBcIiBcIikgKyBcImJ1aWxkLCBzbyB0aGluZ3Mgd29uJ3Qgd29yayByaWdodC5cIik7XG4gICAgfVxuXG4gICAgZ2xvYmFsW2tleV0gPSBcImVzbVwiO1xuICB9XG59XG5cbmV4cG9ydCB7IE1lbW9yeVJvdXRlciwgUHJvbXB0LCBSZWRpcmVjdCwgUm91dGUsIFJvdXRlciwgU3RhdGljUm91dGVyLCBTd2l0Y2gsIGhpc3RvcnlDb250ZXh0IGFzIF9fSGlzdG9yeUNvbnRleHQsIGNvbnRleHQgYXMgX19Sb3V0ZXJDb250ZXh0LCBnZW5lcmF0ZVBhdGgsIG1hdGNoUGF0aCwgdXNlSGlzdG9yeSwgdXNlTG9jYXRpb24sIHVzZVBhcmFtcywgdXNlUm91dGVNYXRjaCwgd2l0aFJvdXRlciB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVhY3Qtcm91dGVyLmpzLm1hcFxuIiwiaW1wb3J0IHsgUm91dGVyLCBfX1JvdXRlckNvbnRleHQsIG1hdGNoUGF0aCB9IGZyb20gJ3JlYWN0LXJvdXRlcic7XG5leHBvcnQgeyBNZW1vcnlSb3V0ZXIsIFByb21wdCwgUmVkaXJlY3QsIFJvdXRlLCBSb3V0ZXIsIFN0YXRpY1JvdXRlciwgU3dpdGNoLCBnZW5lcmF0ZVBhdGgsIG1hdGNoUGF0aCwgdXNlSGlzdG9yeSwgdXNlTG9jYXRpb24sIHVzZVBhcmFtcywgdXNlUm91dGVNYXRjaCwgd2l0aFJvdXRlciB9IGZyb20gJ3JlYWN0LXJvdXRlcic7XG5pbXBvcnQgX2luaGVyaXRzTG9vc2UgZnJvbSAnQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vaW5oZXJpdHNMb29zZSc7XG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgY3JlYXRlQnJvd3Nlckhpc3RvcnksIGNyZWF0ZUhhc2hIaXN0b3J5LCBjcmVhdGVMb2NhdGlvbiwgY3JlYXRlUGF0aCB9IGZyb20gJ2hpc3RvcnknO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCB3YXJuaW5nIGZyb20gJ3Rpbnktd2FybmluZyc7XG5pbXBvcnQgX2V4dGVuZHMgZnJvbSAnQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vZXh0ZW5kcyc7XG5pbXBvcnQgX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UgZnJvbSAnQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZSc7XG5pbXBvcnQgaW52YXJpYW50IGZyb20gJ3RpbnktaW52YXJpYW50JztcblxuLyoqXG4gKiBUaGUgcHVibGljIEFQSSBmb3IgYSA8Um91dGVyPiB0aGF0IHVzZXMgSFRNTDUgaGlzdG9yeS5cbiAqL1xuXG52YXIgQnJvd3NlclJvdXRlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX1JlYWN0JENvbXBvbmVudCkge1xuICBfaW5oZXJpdHNMb29zZShCcm93c2VyUm91dGVyLCBfUmVhY3QkQ29tcG9uZW50KTtcblxuICBmdW5jdGlvbiBCcm93c2VyUm91dGVyKCkge1xuICAgIHZhciBfdGhpcztcblxuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICBfdGhpcyA9IF9SZWFjdCRDb21wb25lbnQuY2FsbC5hcHBseShfUmVhY3QkQ29tcG9uZW50LCBbdGhpc10uY29uY2F0KGFyZ3MpKSB8fCB0aGlzO1xuICAgIF90aGlzLmhpc3RvcnkgPSBjcmVhdGVCcm93c2VySGlzdG9yeShfdGhpcy5wcm9wcyk7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IEJyb3dzZXJSb3V0ZXIucHJvdG90eXBlO1xuXG4gIF9wcm90by5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFJvdXRlciwge1xuICAgICAgaGlzdG9yeTogdGhpcy5oaXN0b3J5LFxuICAgICAgY2hpbGRyZW46IHRoaXMucHJvcHMuY2hpbGRyZW5cbiAgICB9KTtcbiAgfTtcblxuICByZXR1cm4gQnJvd3NlclJvdXRlcjtcbn0oUmVhY3QuQ29tcG9uZW50KTtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICBCcm93c2VyUm91dGVyLnByb3BUeXBlcyA9IHtcbiAgICBiYXNlbmFtZTogUHJvcFR5cGVzLnN0cmluZyxcbiAgICBjaGlsZHJlbjogUHJvcFR5cGVzLm5vZGUsXG4gICAgZm9yY2VSZWZyZXNoOiBQcm9wVHlwZXMuYm9vbCxcbiAgICBnZXRVc2VyQ29uZmlybWF0aW9uOiBQcm9wVHlwZXMuZnVuYyxcbiAgICBrZXlMZW5ndGg6IFByb3BUeXBlcy5udW1iZXJcbiAgfTtcblxuICBCcm93c2VyUm91dGVyLnByb3RvdHlwZS5jb21wb25lbnREaWRNb3VudCA9IGZ1bmN0aW9uICgpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyB3YXJuaW5nKCF0aGlzLnByb3BzLmhpc3RvcnksIFwiPEJyb3dzZXJSb3V0ZXI+IGlnbm9yZXMgdGhlIGhpc3RvcnkgcHJvcC4gVG8gdXNlIGEgY3VzdG9tIGhpc3RvcnksIFwiICsgXCJ1c2UgYGltcG9ydCB7IFJvdXRlciB9YCBpbnN0ZWFkIG9mIGBpbXBvcnQgeyBCcm93c2VyUm91dGVyIGFzIFJvdXRlciB9YC5cIikgOiB2b2lkIDA7XG4gIH07XG59XG5cbi8qKlxuICogVGhlIHB1YmxpYyBBUEkgZm9yIGEgPFJvdXRlcj4gdGhhdCB1c2VzIHdpbmRvdy5sb2NhdGlvbi5oYXNoLlxuICovXG5cbnZhciBIYXNoUm91dGVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfUmVhY3QkQ29tcG9uZW50KSB7XG4gIF9pbmhlcml0c0xvb3NlKEhhc2hSb3V0ZXIsIF9SZWFjdCRDb21wb25lbnQpO1xuXG4gIGZ1bmN0aW9uIEhhc2hSb3V0ZXIoKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIF90aGlzID0gX1JlYWN0JENvbXBvbmVudC5jYWxsLmFwcGx5KF9SZWFjdCRDb21wb25lbnQsIFt0aGlzXS5jb25jYXQoYXJncykpIHx8IHRoaXM7XG4gICAgX3RoaXMuaGlzdG9yeSA9IGNyZWF0ZUhhc2hIaXN0b3J5KF90aGlzLnByb3BzKTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICB2YXIgX3Byb3RvID0gSGFzaFJvdXRlci5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoUm91dGVyLCB7XG4gICAgICBoaXN0b3J5OiB0aGlzLmhpc3RvcnksXG4gICAgICBjaGlsZHJlbjogdGhpcy5wcm9wcy5jaGlsZHJlblxuICAgIH0pO1xuICB9O1xuXG4gIHJldHVybiBIYXNoUm91dGVyO1xufShSZWFjdC5Db21wb25lbnQpO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gIEhhc2hSb3V0ZXIucHJvcFR5cGVzID0ge1xuICAgIGJhc2VuYW1lOiBQcm9wVHlwZXMuc3RyaW5nLFxuICAgIGNoaWxkcmVuOiBQcm9wVHlwZXMubm9kZSxcbiAgICBnZXRVc2VyQ29uZmlybWF0aW9uOiBQcm9wVHlwZXMuZnVuYyxcbiAgICBoYXNoVHlwZTogUHJvcFR5cGVzLm9uZU9mKFtcImhhc2hiYW5nXCIsIFwibm9zbGFzaFwiLCBcInNsYXNoXCJdKVxuICB9O1xuXG4gIEhhc2hSb3V0ZXIucHJvdG90eXBlLmNvbXBvbmVudERpZE1vdW50ID0gZnVuY3Rpb24gKCkge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IHdhcm5pbmcoIXRoaXMucHJvcHMuaGlzdG9yeSwgXCI8SGFzaFJvdXRlcj4gaWdub3JlcyB0aGUgaGlzdG9yeSBwcm9wLiBUbyB1c2UgYSBjdXN0b20gaGlzdG9yeSwgXCIgKyBcInVzZSBgaW1wb3J0IHsgUm91dGVyIH1gIGluc3RlYWQgb2YgYGltcG9ydCB7IEhhc2hSb3V0ZXIgYXMgUm91dGVyIH1gLlwiKSA6IHZvaWQgMDtcbiAgfTtcbn1cblxudmFyIHJlc29sdmVUb0xvY2F0aW9uID0gZnVuY3Rpb24gcmVzb2x2ZVRvTG9jYXRpb24odG8sIGN1cnJlbnRMb2NhdGlvbikge1xuICByZXR1cm4gdHlwZW9mIHRvID09PSBcImZ1bmN0aW9uXCIgPyB0byhjdXJyZW50TG9jYXRpb24pIDogdG87XG59O1xudmFyIG5vcm1hbGl6ZVRvTG9jYXRpb24gPSBmdW5jdGlvbiBub3JtYWxpemVUb0xvY2F0aW9uKHRvLCBjdXJyZW50TG9jYXRpb24pIHtcbiAgcmV0dXJuIHR5cGVvZiB0byA9PT0gXCJzdHJpbmdcIiA/IGNyZWF0ZUxvY2F0aW9uKHRvLCBudWxsLCBudWxsLCBjdXJyZW50TG9jYXRpb24pIDogdG87XG59O1xuXG52YXIgZm9yd2FyZFJlZlNoaW0gPSBmdW5jdGlvbiBmb3J3YXJkUmVmU2hpbShDKSB7XG4gIHJldHVybiBDO1xufTtcblxudmFyIGZvcndhcmRSZWYgPSBSZWFjdC5mb3J3YXJkUmVmO1xuXG5pZiAodHlwZW9mIGZvcndhcmRSZWYgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgZm9yd2FyZFJlZiA9IGZvcndhcmRSZWZTaGltO1xufVxuXG5mdW5jdGlvbiBpc01vZGlmaWVkRXZlbnQoZXZlbnQpIHtcbiAgcmV0dXJuICEhKGV2ZW50Lm1ldGFLZXkgfHwgZXZlbnQuYWx0S2V5IHx8IGV2ZW50LmN0cmxLZXkgfHwgZXZlbnQuc2hpZnRLZXkpO1xufVxuXG52YXIgTGlua0FuY2hvciA9IGZvcndhcmRSZWYoZnVuY3Rpb24gKF9yZWYsIGZvcndhcmRlZFJlZikge1xuICB2YXIgaW5uZXJSZWYgPSBfcmVmLmlubmVyUmVmLFxuICAgICAgbmF2aWdhdGUgPSBfcmVmLm5hdmlnYXRlLFxuICAgICAgX29uQ2xpY2sgPSBfcmVmLm9uQ2xpY2ssXG4gICAgICByZXN0ID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UoX3JlZiwgW1wiaW5uZXJSZWZcIiwgXCJuYXZpZ2F0ZVwiLCBcIm9uQ2xpY2tcIl0pO1xuXG4gIHZhciB0YXJnZXQgPSByZXN0LnRhcmdldDtcblxuICB2YXIgcHJvcHMgPSBfZXh0ZW5kcyh7fSwgcmVzdCwge1xuICAgIG9uQ2xpY2s6IGZ1bmN0aW9uIG9uQ2xpY2soZXZlbnQpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmIChfb25DbGljaykgX29uQ2xpY2soZXZlbnQpO1xuICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgdGhyb3cgZXg7XG4gICAgICB9XG5cbiAgICAgIGlmICghZXZlbnQuZGVmYXVsdFByZXZlbnRlZCAmJiAvLyBvbkNsaWNrIHByZXZlbnRlZCBkZWZhdWx0XG4gICAgICBldmVudC5idXR0b24gPT09IDAgJiYgKCAvLyBpZ25vcmUgZXZlcnl0aGluZyBidXQgbGVmdCBjbGlja3NcbiAgICAgICF0YXJnZXQgfHwgdGFyZ2V0ID09PSBcIl9zZWxmXCIpICYmIC8vIGxldCBicm93c2VyIGhhbmRsZSBcInRhcmdldD1fYmxhbmtcIiBldGMuXG4gICAgICAhaXNNb2RpZmllZEV2ZW50KGV2ZW50KSAvLyBpZ25vcmUgY2xpY2tzIHdpdGggbW9kaWZpZXIga2V5c1xuICAgICAgKSB7XG4gICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICBuYXZpZ2F0ZSgpO1xuICAgICAgICB9XG4gICAgfVxuICB9KTsgLy8gUmVhY3QgMTUgY29tcGF0XG5cblxuICBpZiAoZm9yd2FyZFJlZlNoaW0gIT09IGZvcndhcmRSZWYpIHtcbiAgICBwcm9wcy5yZWYgPSBmb3J3YXJkZWRSZWYgfHwgaW5uZXJSZWY7XG4gIH0gZWxzZSB7XG4gICAgcHJvcHMucmVmID0gaW5uZXJSZWY7XG4gIH1cbiAgLyogZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGpzeC1hMTF5L2FuY2hvci1oYXMtY29udGVudCAqL1xuXG5cbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwiYVwiLCBwcm9wcyk7XG59KTtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICBMaW5rQW5jaG9yLmRpc3BsYXlOYW1lID0gXCJMaW5rQW5jaG9yXCI7XG59XG4vKipcbiAqIFRoZSBwdWJsaWMgQVBJIGZvciByZW5kZXJpbmcgYSBoaXN0b3J5LWF3YXJlIDxhPi5cbiAqL1xuXG5cbnZhciBMaW5rID0gZm9yd2FyZFJlZihmdW5jdGlvbiAoX3JlZjIsIGZvcndhcmRlZFJlZikge1xuICB2YXIgX3JlZjIkY29tcG9uZW50ID0gX3JlZjIuY29tcG9uZW50LFxuICAgICAgY29tcG9uZW50ID0gX3JlZjIkY29tcG9uZW50ID09PSB2b2lkIDAgPyBMaW5rQW5jaG9yIDogX3JlZjIkY29tcG9uZW50LFxuICAgICAgcmVwbGFjZSA9IF9yZWYyLnJlcGxhY2UsXG4gICAgICB0byA9IF9yZWYyLnRvLFxuICAgICAgaW5uZXJSZWYgPSBfcmVmMi5pbm5lclJlZixcbiAgICAgIHJlc3QgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShfcmVmMiwgW1wiY29tcG9uZW50XCIsIFwicmVwbGFjZVwiLCBcInRvXCIsIFwiaW5uZXJSZWZcIl0pO1xuXG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChfX1JvdXRlckNvbnRleHQuQ29uc3VtZXIsIG51bGwsIGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgIWNvbnRleHQgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsIFwiWW91IHNob3VsZCBub3QgdXNlIDxMaW5rPiBvdXRzaWRlIGEgPFJvdXRlcj5cIikgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICAgIHZhciBoaXN0b3J5ID0gY29udGV4dC5oaXN0b3J5O1xuICAgIHZhciBsb2NhdGlvbiA9IG5vcm1hbGl6ZVRvTG9jYXRpb24ocmVzb2x2ZVRvTG9jYXRpb24odG8sIGNvbnRleHQubG9jYXRpb24pLCBjb250ZXh0LmxvY2F0aW9uKTtcbiAgICB2YXIgaHJlZiA9IGxvY2F0aW9uID8gaGlzdG9yeS5jcmVhdGVIcmVmKGxvY2F0aW9uKSA6IFwiXCI7XG5cbiAgICB2YXIgcHJvcHMgPSBfZXh0ZW5kcyh7fSwgcmVzdCwge1xuICAgICAgaHJlZjogaHJlZixcbiAgICAgIG5hdmlnYXRlOiBmdW5jdGlvbiBuYXZpZ2F0ZSgpIHtcbiAgICAgICAgdmFyIGxvY2F0aW9uID0gcmVzb2x2ZVRvTG9jYXRpb24odG8sIGNvbnRleHQubG9jYXRpb24pO1xuICAgICAgICB2YXIgaXNEdXBsaWNhdGVOYXZpZ2F0aW9uID0gY3JlYXRlUGF0aChjb250ZXh0LmxvY2F0aW9uKSA9PT0gY3JlYXRlUGF0aChub3JtYWxpemVUb0xvY2F0aW9uKGxvY2F0aW9uKSk7XG4gICAgICAgIHZhciBtZXRob2QgPSByZXBsYWNlIHx8IGlzRHVwbGljYXRlTmF2aWdhdGlvbiA/IGhpc3RvcnkucmVwbGFjZSA6IGhpc3RvcnkucHVzaDtcbiAgICAgICAgbWV0aG9kKGxvY2F0aW9uKTtcbiAgICAgIH1cbiAgICB9KTsgLy8gUmVhY3QgMTUgY29tcGF0XG5cblxuICAgIGlmIChmb3J3YXJkUmVmU2hpbSAhPT0gZm9yd2FyZFJlZikge1xuICAgICAgcHJvcHMucmVmID0gZm9yd2FyZGVkUmVmIHx8IGlubmVyUmVmO1xuICAgIH0gZWxzZSB7XG4gICAgICBwcm9wcy5pbm5lclJlZiA9IGlubmVyUmVmO1xuICAgIH1cblxuICAgIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChjb21wb25lbnQsIHByb3BzKTtcbiAgfSk7XG59KTtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICB2YXIgdG9UeXBlID0gUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLnN0cmluZywgUHJvcFR5cGVzLm9iamVjdCwgUHJvcFR5cGVzLmZ1bmNdKTtcbiAgdmFyIHJlZlR5cGUgPSBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMuc3RyaW5nLCBQcm9wVHlwZXMuZnVuYywgUHJvcFR5cGVzLnNoYXBlKHtcbiAgICBjdXJyZW50OiBQcm9wVHlwZXMuYW55XG4gIH0pXSk7XG4gIExpbmsuZGlzcGxheU5hbWUgPSBcIkxpbmtcIjtcbiAgTGluay5wcm9wVHlwZXMgPSB7XG4gICAgaW5uZXJSZWY6IHJlZlR5cGUsXG4gICAgb25DbGljazogUHJvcFR5cGVzLmZ1bmMsXG4gICAgcmVwbGFjZTogUHJvcFR5cGVzLmJvb2wsXG4gICAgdGFyZ2V0OiBQcm9wVHlwZXMuc3RyaW5nLFxuICAgIHRvOiB0b1R5cGUuaXNSZXF1aXJlZFxuICB9O1xufVxuXG52YXIgZm9yd2FyZFJlZlNoaW0kMSA9IGZ1bmN0aW9uIGZvcndhcmRSZWZTaGltKEMpIHtcbiAgcmV0dXJuIEM7XG59O1xuXG52YXIgZm9yd2FyZFJlZiQxID0gUmVhY3QuZm9yd2FyZFJlZjtcblxuaWYgKHR5cGVvZiBmb3J3YXJkUmVmJDEgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgZm9yd2FyZFJlZiQxID0gZm9yd2FyZFJlZlNoaW0kMTtcbn1cblxuZnVuY3Rpb24gam9pbkNsYXNzbmFtZXMoKSB7XG4gIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBjbGFzc25hbWVzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgIGNsYXNzbmFtZXNbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gIH1cblxuICByZXR1cm4gY2xhc3NuYW1lcy5maWx0ZXIoZnVuY3Rpb24gKGkpIHtcbiAgICByZXR1cm4gaTtcbiAgfSkuam9pbihcIiBcIik7XG59XG4vKipcbiAqIEEgPExpbms+IHdyYXBwZXIgdGhhdCBrbm93cyBpZiBpdCdzIFwiYWN0aXZlXCIgb3Igbm90LlxuICovXG5cblxudmFyIE5hdkxpbmsgPSBmb3J3YXJkUmVmJDEoZnVuY3Rpb24gKF9yZWYsIGZvcndhcmRlZFJlZikge1xuICB2YXIgX3JlZiRhcmlhQ3VycmVudCA9IF9yZWZbXCJhcmlhLWN1cnJlbnRcIl0sXG4gICAgICBhcmlhQ3VycmVudCA9IF9yZWYkYXJpYUN1cnJlbnQgPT09IHZvaWQgMCA/IFwicGFnZVwiIDogX3JlZiRhcmlhQ3VycmVudCxcbiAgICAgIF9yZWYkYWN0aXZlQ2xhc3NOYW1lID0gX3JlZi5hY3RpdmVDbGFzc05hbWUsXG4gICAgICBhY3RpdmVDbGFzc05hbWUgPSBfcmVmJGFjdGl2ZUNsYXNzTmFtZSA9PT0gdm9pZCAwID8gXCJhY3RpdmVcIiA6IF9yZWYkYWN0aXZlQ2xhc3NOYW1lLFxuICAgICAgYWN0aXZlU3R5bGUgPSBfcmVmLmFjdGl2ZVN0eWxlLFxuICAgICAgY2xhc3NOYW1lUHJvcCA9IF9yZWYuY2xhc3NOYW1lLFxuICAgICAgZXhhY3QgPSBfcmVmLmV4YWN0LFxuICAgICAgaXNBY3RpdmVQcm9wID0gX3JlZi5pc0FjdGl2ZSxcbiAgICAgIGxvY2F0aW9uUHJvcCA9IF9yZWYubG9jYXRpb24sXG4gICAgICBzZW5zaXRpdmUgPSBfcmVmLnNlbnNpdGl2ZSxcbiAgICAgIHN0cmljdCA9IF9yZWYuc3RyaWN0LFxuICAgICAgc3R5bGVQcm9wID0gX3JlZi5zdHlsZSxcbiAgICAgIHRvID0gX3JlZi50byxcbiAgICAgIGlubmVyUmVmID0gX3JlZi5pbm5lclJlZixcbiAgICAgIHJlc3QgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShfcmVmLCBbXCJhcmlhLWN1cnJlbnRcIiwgXCJhY3RpdmVDbGFzc05hbWVcIiwgXCJhY3RpdmVTdHlsZVwiLCBcImNsYXNzTmFtZVwiLCBcImV4YWN0XCIsIFwiaXNBY3RpdmVcIiwgXCJsb2NhdGlvblwiLCBcInNlbnNpdGl2ZVwiLCBcInN0cmljdFwiLCBcInN0eWxlXCIsIFwidG9cIiwgXCJpbm5lclJlZlwiXSk7XG5cbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KF9fUm91dGVyQ29udGV4dC5Db25zdW1lciwgbnVsbCwgZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICAhY29udGV4dCA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgXCJZb3Ugc2hvdWxkIG5vdCB1c2UgPE5hdkxpbms+IG91dHNpZGUgYSA8Um91dGVyPlwiKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gICAgdmFyIGN1cnJlbnRMb2NhdGlvbiA9IGxvY2F0aW9uUHJvcCB8fCBjb250ZXh0LmxvY2F0aW9uO1xuICAgIHZhciB0b0xvY2F0aW9uID0gbm9ybWFsaXplVG9Mb2NhdGlvbihyZXNvbHZlVG9Mb2NhdGlvbih0bywgY3VycmVudExvY2F0aW9uKSwgY3VycmVudExvY2F0aW9uKTtcbiAgICB2YXIgcGF0aCA9IHRvTG9jYXRpb24ucGF0aG5hbWU7IC8vIFJlZ2V4IHRha2VuIGZyb206IGh0dHBzOi8vZ2l0aHViLmNvbS9waWxsYXJqcy9wYXRoLXRvLXJlZ2V4cC9ibG9iL21hc3Rlci9pbmRleC5qcyNMMjAyXG5cbiAgICB2YXIgZXNjYXBlZFBhdGggPSBwYXRoICYmIHBhdGgucmVwbGFjZSgvKFsuKyo/PV4hOiR7fSgpW1xcXXwvXFxcXF0pL2csIFwiXFxcXCQxXCIpO1xuICAgIHZhciBtYXRjaCA9IGVzY2FwZWRQYXRoID8gbWF0Y2hQYXRoKGN1cnJlbnRMb2NhdGlvbi5wYXRobmFtZSwge1xuICAgICAgcGF0aDogZXNjYXBlZFBhdGgsXG4gICAgICBleGFjdDogZXhhY3QsXG4gICAgICBzZW5zaXRpdmU6IHNlbnNpdGl2ZSxcbiAgICAgIHN0cmljdDogc3RyaWN0XG4gICAgfSkgOiBudWxsO1xuICAgIHZhciBpc0FjdGl2ZSA9ICEhKGlzQWN0aXZlUHJvcCA/IGlzQWN0aXZlUHJvcChtYXRjaCwgY3VycmVudExvY2F0aW9uKSA6IG1hdGNoKTtcbiAgICB2YXIgY2xhc3NOYW1lID0gdHlwZW9mIGNsYXNzTmFtZVByb3AgPT09IFwiZnVuY3Rpb25cIiA/IGNsYXNzTmFtZVByb3AoaXNBY3RpdmUpIDogY2xhc3NOYW1lUHJvcDtcbiAgICB2YXIgc3R5bGUgPSB0eXBlb2Ygc3R5bGVQcm9wID09PSBcImZ1bmN0aW9uXCIgPyBzdHlsZVByb3AoaXNBY3RpdmUpIDogc3R5bGVQcm9wO1xuXG4gICAgaWYgKGlzQWN0aXZlKSB7XG4gICAgICBjbGFzc05hbWUgPSBqb2luQ2xhc3NuYW1lcyhjbGFzc05hbWUsIGFjdGl2ZUNsYXNzTmFtZSk7XG4gICAgICBzdHlsZSA9IF9leHRlbmRzKHt9LCBzdHlsZSwgYWN0aXZlU3R5bGUpO1xuICAgIH1cblxuICAgIHZhciBwcm9wcyA9IF9leHRlbmRzKHtcbiAgICAgIFwiYXJpYS1jdXJyZW50XCI6IGlzQWN0aXZlICYmIGFyaWFDdXJyZW50IHx8IG51bGwsXG4gICAgICBjbGFzc05hbWU6IGNsYXNzTmFtZSxcbiAgICAgIHN0eWxlOiBzdHlsZSxcbiAgICAgIHRvOiB0b0xvY2F0aW9uXG4gICAgfSwgcmVzdCk7IC8vIFJlYWN0IDE1IGNvbXBhdFxuXG5cbiAgICBpZiAoZm9yd2FyZFJlZlNoaW0kMSAhPT0gZm9yd2FyZFJlZiQxKSB7XG4gICAgICBwcm9wcy5yZWYgPSBmb3J3YXJkZWRSZWYgfHwgaW5uZXJSZWY7XG4gICAgfSBlbHNlIHtcbiAgICAgIHByb3BzLmlubmVyUmVmID0gaW5uZXJSZWY7XG4gICAgfVxuXG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KExpbmssIHByb3BzKTtcbiAgfSk7XG59KTtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICBOYXZMaW5rLmRpc3BsYXlOYW1lID0gXCJOYXZMaW5rXCI7XG4gIHZhciBhcmlhQ3VycmVudFR5cGUgPSBQcm9wVHlwZXMub25lT2YoW1wicGFnZVwiLCBcInN0ZXBcIiwgXCJsb2NhdGlvblwiLCBcImRhdGVcIiwgXCJ0aW1lXCIsIFwidHJ1ZVwiLCBcImZhbHNlXCJdKTtcbiAgTmF2TGluay5wcm9wVHlwZXMgPSBfZXh0ZW5kcyh7fSwgTGluay5wcm9wVHlwZXMsIHtcbiAgICBcImFyaWEtY3VycmVudFwiOiBhcmlhQ3VycmVudFR5cGUsXG4gICAgYWN0aXZlQ2xhc3NOYW1lOiBQcm9wVHlwZXMuc3RyaW5nLFxuICAgIGFjdGl2ZVN0eWxlOiBQcm9wVHlwZXMub2JqZWN0LFxuICAgIGNsYXNzTmFtZTogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLnN0cmluZywgUHJvcFR5cGVzLmZ1bmNdKSxcbiAgICBleGFjdDogUHJvcFR5cGVzLmJvb2wsXG4gICAgaXNBY3RpdmU6IFByb3BUeXBlcy5mdW5jLFxuICAgIGxvY2F0aW9uOiBQcm9wVHlwZXMub2JqZWN0LFxuICAgIHNlbnNpdGl2ZTogUHJvcFR5cGVzLmJvb2wsXG4gICAgc3RyaWN0OiBQcm9wVHlwZXMuYm9vbCxcbiAgICBzdHlsZTogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLm9iamVjdCwgUHJvcFR5cGVzLmZ1bmNdKVxuICB9KTtcbn1cblxuZXhwb3J0IHsgQnJvd3NlclJvdXRlciwgSGFzaFJvdXRlciwgTGluaywgTmF2TGluayB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVhY3Qtcm91dGVyLWRvbS5qcy5tYXBcbiIsImltcG9ydCB7IGlzVmFsaWRFbGVtZW50LCBmb3J3YXJkUmVmLCBjbG9uZUVsZW1lbnQsIGNyZWF0ZUVsZW1lbnQgfSBmcm9tICdyZWFjdCc7XHJcbmltcG9ydCBjbGFzc25hbWVzIGZyb20gJ2NsYXNzbmFtZXMnO1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUNvbXBvbmVudCh7IGRpc3BsYXlOYW1lLCBwcm9wVHlwZXMsIGRlZmF1bHRQcm9wcywgfSwgZm4pIHtcclxuICAgIGNvbnN0IENvbXBvbmVudCA9IGZuLmxlbmd0aCA+IDEgPyBmb3J3YXJkUmVmKGZuKSA6IGZuO1xyXG5cclxuICAgIENvbXBvbmVudC5kaXNwbGF5TmFtZSA9IGRpc3BsYXlOYW1lO1xyXG4gICAgQ29tcG9uZW50LnByb3BUeXBlcyA9IHByb3BUeXBlcztcclxuICAgIENvbXBvbmVudC5kZWZhdWx0UHJvcHMgPSBkZWZhdWx0UHJvcHM7XHJcblxyXG4gICAgcmV0dXJuIENvbXBvbmVudDtcclxufVxyXG5cclxuZXhwb3J0IGNvbnN0IENsb25lID0gZm9yd2FyZFJlZihmdW5jdGlvbiBDbG9uZSh7XHJcbiAgICBjb21wb25lbnQsXHJcbiAgICBmYWxsYmFjayxcclxuXHJcbiAgICBjbGFzc05hbWUsXHJcbiAgICBjaGlsZHJlbiA9IGNvbXBvbmVudCxcclxuICAgIC4uLnByb3BzXHJcbn0sIHJlZikge1xyXG4gICAgaWYgKGlzVmFsaWRFbGVtZW50KGNvbXBvbmVudCkpIHtcclxuICAgICAgICByZXR1cm4gY2xvbmVFbGVtZW50KGNvbXBvbmVudCwge1xyXG4gICAgICAgICAgICByZWYsXHJcbiAgICAgICAgICAgIGNsYXNzTmFtZTogY2xhc3NuYW1lcyhjbGFzc05hbWUsIGNvbXBvbmVudC5wcm9wcy5jbGFzc05hbWUpLFxyXG4gICAgICAgICAgICAuLi5wcm9wc1xyXG4gICAgICAgIH0pO1xyXG4gICAgfSBlbHNlIGlmIChpc1ZhbGlkRWxlbWVudChmYWxsYmFjaykpIHtcclxuICAgICAgICByZXR1cm4gY2xvbmVFbGVtZW50KGZhbGxiYWNrLCB7XHJcbiAgICAgICAgICAgIHJlZixcclxuICAgICAgICAgICAgY2xhc3NOYW1lOiBjbGFzc25hbWVzKGNsYXNzTmFtZSwgZmFsbGJhY2sucHJvcHMuY2xhc3NOYW1lKSxcclxuICAgICAgICAgICAgLi4ucHJvcHNcclxuICAgICAgICB9KTtcclxuICAgIH0gZWxzZSBpZiAoZmFsbGJhY2spIHtcclxuICAgICAgICByZXR1cm4gY3JlYXRlRWxlbWVudChmYWxsYmFjaywge1xyXG4gICAgICAgICAgICByZWYsXHJcbiAgICAgICAgICAgIGNsYXNzTmFtZSxcclxuICAgICAgICAgICAgLi4ucHJvcHNcclxuICAgICAgICB9LCBjaGlsZHJlbik7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIHJldHVybiBjaGlsZHJlbjtcclxuICAgIH1cclxufSk7XHJcblxyXG5leHBvcnQge1xyXG4gICAgaXNWYWxpZEVsZW1lbnQgYXMgaXNFbGVtZW50LFxyXG4gICAgY2xvbmVFbGVtZW50IGFzIGNsb25lLFxyXG4gICAgY3JlYXRlRWxlbWVudCBhcyBjcmVhdGVcclxufTsiLCJleHBvcnQgY29uc3QgY3NzQ2xhc3NlcyA9IHtcclxuICAgIFJPT1Q6ICdtZGMtaWNvbicsXHJcbiAgICBNQVRFUklBTF9JQ09OUzogJ21hdGVyaWFsLWljb25zJyxcclxuICAgIExJR0hUOiAnbWRjLWljb24tLWxpZ2h0JyxcclxuICAgIERBUks6ICdtZGMtaWNvbi0tZGFyaycsXHJcbiAgICBJTkFDVElWRTogJ21kYy1pY29uLS1pbmFjdGl2ZSdcclxufTsiLCJpbXBvcnQgeyBmb3J3YXJkUmVmIH0gZnJvbSAncmVhY3QnO1xyXG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xyXG5pbXBvcnQgY2xhc3NuYW1lcyBmcm9tICdjbGFzc25hbWVzJztcclxuXHJcbmltcG9ydCB7IGNzc0NsYXNzZXMgfSBmcm9tICcuL2NvbnN0YW50cyc7XHJcblxyXG5jb25zdCBJY29uID0gZm9yd2FyZFJlZigoe1xyXG4gICAgc2l6ZSxcclxuICAgIGxpZ2h0ID0gZmFsc2UsXHJcbiAgICBkYXJrID0gZmFsc2UsXHJcbiAgICBpbmFjdGl2ZSA9IGZhbHNlLFxyXG5cclxuICAgIGVsZW1lbnQgPSAnaScsXHJcbiAgICBjb21wb25lbnQ6IEVsZW1lbnQgPSBlbGVtZW50LFxyXG4gICAgY2xhc3NOYW1lLFxyXG4gICAgLi4ucHJvcHNcclxufSwgcmVmKSA9PiB7XHJcbiAgICBjb25zdCBjbGFzc05hbWVzID0gY2xhc3NuYW1lcyhjc3NDbGFzc2VzLlJPT1QsIGNzc0NsYXNzZXMuTUFURVJJQUxfSUNPTlMsIHtcclxuICAgICAgICBbYCR7Y3NzQ2xhc3Nlcy5ST09UfS0tJHtzaXplfWBdOiBzaXplLFxyXG4gICAgICAgIFtjc3NDbGFzc2VzLkxJR0hUXTogbGlnaHQsXHJcbiAgICAgICAgW2Nzc0NsYXNzZXMuREFSS106IGRhcmssXHJcbiAgICAgICAgW2Nzc0NsYXNzZXMuSU5BQ1RJVkVdOiBpbmFjdGl2ZVxyXG4gICAgfSwgY2xhc3NOYW1lKTtcclxuXHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAgIDxFbGVtZW50IHJlZj17cmVmfSBjbGFzc05hbWU9e2NsYXNzTmFtZXN9IHsuLi5wcm9wc30gLz5cclxuICAgICk7XHJcbn0pO1xyXG5cclxuSWNvbi5kaXNwbGF5TmFtZSA9ICdNRENJY29uJztcclxuXHJcbkljb24ucHJvcFR5cGVzID0ge1xyXG4gICAgc2l6ZTogUHJvcFR5cGVzLnN0cmluZyxcclxuICAgIGRhcms6IFByb3BUeXBlcy5ib29sLFxyXG4gICAgbGlnaHQ6IFByb3BUeXBlcy5ib29sLFxyXG4gICAgaW5hY3RpdmU6IFByb3BUeXBlcy5ib29sXHJcbn07XHJcblxyXG5leHBvcnQgZGVmYXVsdCBJY29uOyIsImV4cG9ydCB7IGRlZmF1bHQgfSBmcm9tICcuL0ljb24nOyIsImV4cG9ydCBjb25zdCBjc3NDbGFzc2VzID0ge1xyXG4gICAgUk9PVDogJ21kYy1hdmF0YXInLFxyXG4gICAgU01BTEw6ICdtZGMtYXZhdGFyLS1zbWFsbCcsXHJcbiAgICBNRURJVU06ICdtZGMtYXZhdGFyLS1tZWRpdW0nLFxyXG4gICAgTEFSR0U6ICdtZGMtYXZhdGFyLS1sYXJnZScsXHJcblxyXG4gICAgSU1BR0U6ICdtZGMtYXZhdGFyX19pbWFnZScsXHJcbiAgICBJQ09OOiAnbWRjLWF2YXRhcl9faWNvbicsXHJcbiAgICBURVhUOiAnbWRjLWF2YXRhcl9fdGV4dCdcclxufTsiLCJpbXBvcnQgeyBmb3J3YXJkUmVmIH0gZnJvbSAncmVhY3QnO1xyXG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xyXG5pbXBvcnQgY2xhc3NuYW1lcyBmcm9tICdjbGFzc25hbWVzJztcclxuXHJcbmltcG9ydCB7IENsb25lIH0gZnJvbSAnLi4vY29tcG9uZW50JztcclxuaW1wb3J0IEljb24gZnJvbSAnLi4vaWNvbic7XHJcblxyXG5pbXBvcnQgeyBjc3NDbGFzc2VzIH0gZnJvbSAnLi9jb25zdGFudHMnO1xyXG5cclxuY29uc3QgQXZhdGFyID0gZm9yd2FyZFJlZigoe1xyXG4gICAgc3JjLFxyXG4gICAgaWNvbixcclxuICAgIHRleHQsXHJcbiAgICBzaXplLFxyXG5cclxuICAgIGVsZW1lbnQgPSAnc3BhbicsXHJcbiAgICBjb21wb25lbnQ6IEVsZW1lbnQgPSBlbGVtZW50LFxyXG4gICAgY2xhc3NOYW1lLFxyXG4gICAgYWx0LFxyXG4gICAgY2hpbGRyZW4gPSB0ZXh0LFxyXG4gICAgLi4ucHJvcHNcclxufSwgcmVmKSA9PiB7XHJcbiAgICBjb25zdCBjbGFzc05hbWVzID0gY2xhc3NuYW1lcyhjc3NDbGFzc2VzLlJPT1QsIHtcclxuICAgICAgICBbYCR7Y3NzQ2xhc3Nlcy5ST09UfS0tJHtzaXplfWBdOiBzaXplXHJcbiAgICB9LCBjbGFzc05hbWUpO1xyXG5cclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgPEVsZW1lbnQgcmVmPXtyZWZ9IGNsYXNzTmFtZT17Y2xhc3NOYW1lc30gey4uLnByb3BzfT5cclxuICAgICAgICAgICAge3NyYyAmJlxyXG4gICAgICAgICAgICAgICAgPGltZyBjbGFzc05hbWU9e2Nzc0NsYXNzZXMuSU1BR0V9IHNyYz17c3JjfSBhbHQ9e2FsdH0gLz5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAge2ljb24gJiZcclxuICAgICAgICAgICAgICAgIDxDbG9uZVxyXG4gICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudD17aWNvbn1cclxuICAgICAgICAgICAgICAgICAgICBmYWxsYmFjaz17SWNvbn1cclxuICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU9e2Nzc0NsYXNzZXMuSUNPTn1cclxuICAgICAgICAgICAgICAgIC8+XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHtjaGlsZHJlbiAmJlxyXG4gICAgICAgICAgICAgICAgPENsb25lXHJcbiAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50PXtjaGlsZHJlbn1cclxuICAgICAgICAgICAgICAgICAgICBmYWxsYmFjaz1cInNwYW5cIlxyXG4gICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT17Y3NzQ2xhc3Nlcy5URVhUfVxyXG4gICAgICAgICAgICAgICAgLz5cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIDwvRWxlbWVudD5cclxuICAgICk7XHJcbn0pO1xyXG5cclxuQXZhdGFyLmRpc3BsYXlOYW1lID0gJ01EQ0F2YXRhcic7XHJcblxyXG5BdmF0YXIucHJvcFR5cGVzID0ge1xyXG4gICAgc3JjOiBQcm9wVHlwZXMuc3RyaW5nLFxyXG4gICAgaWNvbjogUHJvcFR5cGVzLm5vZGUsXHJcbiAgICB0ZXh0OiBQcm9wVHlwZXMubm9kZSxcclxuICAgIHNpemU6IFByb3BUeXBlcy5vbmVPZihbJ3NtYWxsJywgJ21lZGl1bScsICdsYXJnZSddKVxyXG59O1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgQXZhdGFyOyIsImV4cG9ydCB7IGRlZmF1bHQgfSBmcm9tICcuL0F2YXRhcic7IiwiZXhwb3J0IGNvbnN0IGNzc0NsYXNzZXMgPSB7XHJcbiAgICBST09UOiAnbWRjLWJhZGdlJyxcclxuICAgIElOU0VUOiAnbWRjLWJhZGdlLS1pbnNldCcsXHJcbiAgICBUUkFOU1BBUkVOVDogJ21kYy1iYWRnZS0tdHJhbnNwYXJlbnQnXHJcbn07IiwiaW1wb3J0IHsgZm9yd2FyZFJlZiB9IGZyb20gJ3JlYWN0JztcclxuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcclxuaW1wb3J0IGNsYXNzbmFtZXMgZnJvbSAnY2xhc3NuYW1lcyc7XHJcblxyXG5pbXBvcnQgeyBjc3NDbGFzc2VzIH0gZnJvbSAnLi9jb25zdGFudHMnO1xyXG5cclxuY29uc3QgQmFkZ2UgPSBmb3J3YXJkUmVmKCh7XHJcbiAgICB2YWx1ZSxcclxuICAgIGluc2V0ID0gZmFsc2UsXHJcbiAgICB0cmFuc3BhcmVudCA9IGZhbHNlLFxyXG5cclxuICAgIGVsZW1lbnQ6IEVsZW1lbnQgPSAnc3BhbicsXHJcbiAgICBjbGFzc05hbWUsXHJcbiAgICAuLi5wcm9wc1xyXG59LCByZWYpID0+IHtcclxuICAgIGNvbnN0IGNsYXNzTmFtZXMgPSBjbGFzc25hbWVzKGNzc0NsYXNzZXMuUk9PVCwge1xyXG4gICAgICAgIFtjc3NDbGFzc2VzLklOU0VUXTogaW5zZXQsXHJcbiAgICAgICAgW2Nzc0NsYXNzZXMuVFJBTlNQQVJFTlRdOiB0cmFuc3BhcmVudFxyXG4gICAgfSwgY2xhc3NOYW1lKTtcclxuXHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAgIDxFbGVtZW50XHJcbiAgICAgICAgICAgIHJlZj17cmVmfVxyXG4gICAgICAgICAgICBjbGFzc05hbWU9e2NsYXNzTmFtZXN9XHJcbiAgICAgICAgICAgIGRhdGEtYmFkZ2U9e3ZhbHVlfVxyXG4gICAgICAgICAgICB7Li4ucHJvcHN9XHJcbiAgICAgICAgLz5cclxuICAgICk7XHJcbn0pO1xyXG5cclxuQmFkZ2UuZGlzcGxheU5hbWUgPSAnTURDQmFkZ2UnO1xyXG5cclxuQmFkZ2UucHJvcFR5cGVzID0ge1xyXG4gICAgdmFsdWU6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5udW1iZXIsIFByb3BUeXBlcy5zdHJpbmddKS5pc1JlcXVpcmVkLFxyXG4gICAgaW5zZXQ6IFByb3BUeXBlcy5ib29sLFxyXG4gICAgdHJhbnNwYXJlbnQ6IFByb3BUeXBlcy5ib29sXHJcbn07XHJcblxyXG5leHBvcnQgZGVmYXVsdCBCYWRnZTsiLCJleHBvcnQgeyBkZWZhdWx0IH0gZnJvbSAnLi9CYWRnZSc7IiwiLyoqXG4gKiBDaGVja3MgaWYgYSBnaXZlbiBlbGVtZW50IGhhcyBhIENTUyBjbGFzcy5cbiAqIFxuICogQHBhcmFtIGVsZW1lbnQgdGhlIGVsZW1lbnRcbiAqIEBwYXJhbSBjbGFzc05hbWUgdGhlIENTUyBjbGFzcyBuYW1lXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGhhc0NsYXNzKGVsZW1lbnQsIGNsYXNzTmFtZSkge1xuICBpZiAoZWxlbWVudC5jbGFzc0xpc3QpIHJldHVybiAhIWNsYXNzTmFtZSAmJiBlbGVtZW50LmNsYXNzTGlzdC5jb250YWlucyhjbGFzc05hbWUpO1xuICByZXR1cm4gKFwiIFwiICsgKGVsZW1lbnQuY2xhc3NOYW1lLmJhc2VWYWwgfHwgZWxlbWVudC5jbGFzc05hbWUpICsgXCIgXCIpLmluZGV4T2YoXCIgXCIgKyBjbGFzc05hbWUgKyBcIiBcIikgIT09IC0xO1xufSIsImltcG9ydCBoYXNDbGFzcyBmcm9tICcuL2hhc0NsYXNzJztcbi8qKlxuICogQWRkcyBhIENTUyBjbGFzcyB0byBhIGdpdmVuIGVsZW1lbnQuXG4gKiBcbiAqIEBwYXJhbSBlbGVtZW50IHRoZSBlbGVtZW50XG4gKiBAcGFyYW0gY2xhc3NOYW1lIHRoZSBDU1MgY2xhc3MgbmFtZVxuICovXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGFkZENsYXNzKGVsZW1lbnQsIGNsYXNzTmFtZSkge1xuICBpZiAoZWxlbWVudC5jbGFzc0xpc3QpIGVsZW1lbnQuY2xhc3NMaXN0LmFkZChjbGFzc05hbWUpO2Vsc2UgaWYgKCFoYXNDbGFzcyhlbGVtZW50LCBjbGFzc05hbWUpKSBpZiAodHlwZW9mIGVsZW1lbnQuY2xhc3NOYW1lID09PSAnc3RyaW5nJykgZWxlbWVudC5jbGFzc05hbWUgPSBlbGVtZW50LmNsYXNzTmFtZSArIFwiIFwiICsgY2xhc3NOYW1lO2Vsc2UgZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgKGVsZW1lbnQuY2xhc3NOYW1lICYmIGVsZW1lbnQuY2xhc3NOYW1lLmJhc2VWYWwgfHwgJycpICsgXCIgXCIgKyBjbGFzc05hbWUpO1xufSIsImZ1bmN0aW9uIHJlcGxhY2VDbGFzc05hbWUob3JpZ0NsYXNzLCBjbGFzc1RvUmVtb3ZlKSB7XG4gIHJldHVybiBvcmlnQ2xhc3MucmVwbGFjZShuZXcgUmVnRXhwKFwiKF58XFxcXHMpXCIgKyBjbGFzc1RvUmVtb3ZlICsgXCIoPzpcXFxcc3wkKVwiLCAnZycpLCAnJDEnKS5yZXBsYWNlKC9cXHMrL2csICcgJykucmVwbGFjZSgvXlxccyp8XFxzKiQvZywgJycpO1xufVxuLyoqXG4gKiBSZW1vdmVzIGEgQ1NTIGNsYXNzIGZyb20gYSBnaXZlbiBlbGVtZW50LlxuICogXG4gKiBAcGFyYW0gZWxlbWVudCB0aGUgZWxlbWVudFxuICogQHBhcmFtIGNsYXNzTmFtZSB0aGUgQ1NTIGNsYXNzIG5hbWVcbiAqL1xuXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHJlbW92ZUNsYXNzKGVsZW1lbnQsIGNsYXNzTmFtZSkge1xuICBpZiAoZWxlbWVudC5jbGFzc0xpc3QpIHtcbiAgICBlbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoY2xhc3NOYW1lKTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgZWxlbWVudC5jbGFzc05hbWUgPT09ICdzdHJpbmcnKSB7XG4gICAgZWxlbWVudC5jbGFzc05hbWUgPSByZXBsYWNlQ2xhc3NOYW1lKGVsZW1lbnQuY2xhc3NOYW1lLCBjbGFzc05hbWUpO1xuICB9IGVsc2Uge1xuICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKCdjbGFzcycsIHJlcGxhY2VDbGFzc05hbWUoZWxlbWVudC5jbGFzc05hbWUgJiYgZWxlbWVudC5jbGFzc05hbWUuYmFzZVZhbCB8fCAnJywgY2xhc3NOYW1lKSk7XG4gIH1cbn0iLCJleHBvcnQgZGVmYXVsdCB7XG4gIGRpc2FibGVkOiBmYWxzZVxufTsiLCJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuZXhwb3J0IGRlZmF1bHQgUmVhY3QuY3JlYXRlQ29udGV4dChudWxsKTsiLCJpbXBvcnQgX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2VcIjtcbmltcG9ydCBfaW5oZXJpdHNMb29zZSBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vaW5oZXJpdHNMb29zZVwiO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUmVhY3RET00gZnJvbSAncmVhY3QtZG9tJztcbmltcG9ydCBjb25maWcgZnJvbSAnLi9jb25maWcnO1xuaW1wb3J0IHsgdGltZW91dHNTaGFwZSB9IGZyb20gJy4vdXRpbHMvUHJvcFR5cGVzJztcbmltcG9ydCBUcmFuc2l0aW9uR3JvdXBDb250ZXh0IGZyb20gJy4vVHJhbnNpdGlvbkdyb3VwQ29udGV4dCc7XG5leHBvcnQgdmFyIFVOTU9VTlRFRCA9ICd1bm1vdW50ZWQnO1xuZXhwb3J0IHZhciBFWElURUQgPSAnZXhpdGVkJztcbmV4cG9ydCB2YXIgRU5URVJJTkcgPSAnZW50ZXJpbmcnO1xuZXhwb3J0IHZhciBFTlRFUkVEID0gJ2VudGVyZWQnO1xuZXhwb3J0IHZhciBFWElUSU5HID0gJ2V4aXRpbmcnO1xuLyoqXG4gKiBUaGUgVHJhbnNpdGlvbiBjb21wb25lbnQgbGV0cyB5b3UgZGVzY3JpYmUgYSB0cmFuc2l0aW9uIGZyb20gb25lIGNvbXBvbmVudFxuICogc3RhdGUgdG8gYW5vdGhlciBfb3ZlciB0aW1lXyB3aXRoIGEgc2ltcGxlIGRlY2xhcmF0aXZlIEFQSS4gTW9zdCBjb21tb25seVxuICogaXQncyB1c2VkIHRvIGFuaW1hdGUgdGhlIG1vdW50aW5nIGFuZCB1bm1vdW50aW5nIG9mIGEgY29tcG9uZW50LCBidXQgY2FuIGFsc29cbiAqIGJlIHVzZWQgdG8gZGVzY3JpYmUgaW4tcGxhY2UgdHJhbnNpdGlvbiBzdGF0ZXMgYXMgd2VsbC5cbiAqXG4gKiAtLS1cbiAqXG4gKiAqKk5vdGUqKjogYFRyYW5zaXRpb25gIGlzIGEgcGxhdGZvcm0tYWdub3N0aWMgYmFzZSBjb21wb25lbnQuIElmIHlvdSdyZSB1c2luZ1xuICogdHJhbnNpdGlvbnMgaW4gQ1NTLCB5b3UnbGwgcHJvYmFibHkgd2FudCB0byB1c2VcbiAqIFtgQ1NTVHJhbnNpdGlvbmBdKGh0dHBzOi8vcmVhY3Rjb21tdW5pdHkub3JnL3JlYWN0LXRyYW5zaXRpb24tZ3JvdXAvY3NzLXRyYW5zaXRpb24pXG4gKiBpbnN0ZWFkLiBJdCBpbmhlcml0cyBhbGwgdGhlIGZlYXR1cmVzIG9mIGBUcmFuc2l0aW9uYCwgYnV0IGNvbnRhaW5zXG4gKiBhZGRpdGlvbmFsIGZlYXR1cmVzIG5lY2Vzc2FyeSB0byBwbGF5IG5pY2Ugd2l0aCBDU1MgdHJhbnNpdGlvbnMgKGhlbmNlIHRoZVxuICogbmFtZSBvZiB0aGUgY29tcG9uZW50KS5cbiAqXG4gKiAtLS1cbiAqXG4gKiBCeSBkZWZhdWx0IHRoZSBgVHJhbnNpdGlvbmAgY29tcG9uZW50IGRvZXMgbm90IGFsdGVyIHRoZSBiZWhhdmlvciBvZiB0aGVcbiAqIGNvbXBvbmVudCBpdCByZW5kZXJzLCBpdCBvbmx5IHRyYWNrcyBcImVudGVyXCIgYW5kIFwiZXhpdFwiIHN0YXRlcyBmb3IgdGhlXG4gKiBjb21wb25lbnRzLiBJdCdzIHVwIHRvIHlvdSB0byBnaXZlIG1lYW5pbmcgYW5kIGVmZmVjdCB0byB0aG9zZSBzdGF0ZXMuIEZvclxuICogZXhhbXBsZSB3ZSBjYW4gYWRkIHN0eWxlcyB0byBhIGNvbXBvbmVudCB3aGVuIGl0IGVudGVycyBvciBleGl0czpcbiAqXG4gKiBgYGBqc3hcbiAqIGltcG9ydCB7IFRyYW5zaXRpb24gfSBmcm9tICdyZWFjdC10cmFuc2l0aW9uLWdyb3VwJztcbiAqXG4gKiBjb25zdCBkdXJhdGlvbiA9IDMwMDtcbiAqXG4gKiBjb25zdCBkZWZhdWx0U3R5bGUgPSB7XG4gKiAgIHRyYW5zaXRpb246IGBvcGFjaXR5ICR7ZHVyYXRpb259bXMgZWFzZS1pbi1vdXRgLFxuICogICBvcGFjaXR5OiAwLFxuICogfVxuICpcbiAqIGNvbnN0IHRyYW5zaXRpb25TdHlsZXMgPSB7XG4gKiAgIGVudGVyaW5nOiB7IG9wYWNpdHk6IDEgfSxcbiAqICAgZW50ZXJlZDogIHsgb3BhY2l0eTogMSB9LFxuICogICBleGl0aW5nOiAgeyBvcGFjaXR5OiAwIH0sXG4gKiAgIGV4aXRlZDogIHsgb3BhY2l0eTogMCB9LFxuICogfTtcbiAqXG4gKiBjb25zdCBGYWRlID0gKHsgaW46IGluUHJvcCB9KSA9PiAoXG4gKiAgIDxUcmFuc2l0aW9uIGluPXtpblByb3B9IHRpbWVvdXQ9e2R1cmF0aW9ufT5cbiAqICAgICB7c3RhdGUgPT4gKFxuICogICAgICAgPGRpdiBzdHlsZT17e1xuICogICAgICAgICAuLi5kZWZhdWx0U3R5bGUsXG4gKiAgICAgICAgIC4uLnRyYW5zaXRpb25TdHlsZXNbc3RhdGVdXG4gKiAgICAgICB9fT5cbiAqICAgICAgICAgSSdtIGEgZmFkZSBUcmFuc2l0aW9uIVxuICogICAgICAgPC9kaXY+XG4gKiAgICAgKX1cbiAqICAgPC9UcmFuc2l0aW9uPlxuICogKTtcbiAqIGBgYFxuICpcbiAqIFRoZXJlIGFyZSA0IG1haW4gc3RhdGVzIGEgVHJhbnNpdGlvbiBjYW4gYmUgaW46XG4gKiAgLSBgJ2VudGVyaW5nJ2BcbiAqICAtIGAnZW50ZXJlZCdgXG4gKiAgLSBgJ2V4aXRpbmcnYFxuICogIC0gYCdleGl0ZWQnYFxuICpcbiAqIFRyYW5zaXRpb24gc3RhdGUgaXMgdG9nZ2xlZCB2aWEgdGhlIGBpbmAgcHJvcC4gV2hlbiBgdHJ1ZWAgdGhlIGNvbXBvbmVudFxuICogYmVnaW5zIHRoZSBcIkVudGVyXCIgc3RhZ2UuIER1cmluZyB0aGlzIHN0YWdlLCB0aGUgY29tcG9uZW50IHdpbGwgc2hpZnQgZnJvbVxuICogaXRzIGN1cnJlbnQgdHJhbnNpdGlvbiBzdGF0ZSwgdG8gYCdlbnRlcmluZydgIGZvciB0aGUgZHVyYXRpb24gb2YgdGhlXG4gKiB0cmFuc2l0aW9uIGFuZCB0aGVuIHRvIHRoZSBgJ2VudGVyZWQnYCBzdGFnZSBvbmNlIGl0J3MgY29tcGxldGUuIExldCdzIHRha2VcbiAqIHRoZSBmb2xsb3dpbmcgZXhhbXBsZSAod2UnbGwgdXNlIHRoZVxuICogW3VzZVN0YXRlXShodHRwczovL3JlYWN0anMub3JnL2RvY3MvaG9va3MtcmVmZXJlbmNlLmh0bWwjdXNlc3RhdGUpIGhvb2spOlxuICpcbiAqIGBgYGpzeFxuICogZnVuY3Rpb24gQXBwKCkge1xuICogICBjb25zdCBbaW5Qcm9wLCBzZXRJblByb3BdID0gdXNlU3RhdGUoZmFsc2UpO1xuICogICByZXR1cm4gKFxuICogICAgIDxkaXY+XG4gKiAgICAgICA8VHJhbnNpdGlvbiBpbj17aW5Qcm9wfSB0aW1lb3V0PXs1MDB9PlxuICogICAgICAgICB7c3RhdGUgPT4gKFxuICogICAgICAgICAgIC8vIC4uLlxuICogICAgICAgICApfVxuICogICAgICAgPC9UcmFuc2l0aW9uPlxuICogICAgICAgPGJ1dHRvbiBvbkNsaWNrPXsoKSA9PiBzZXRJblByb3AodHJ1ZSl9PlxuICogICAgICAgICBDbGljayB0byBFbnRlclxuICogICAgICAgPC9idXR0b24+XG4gKiAgICAgPC9kaXY+XG4gKiAgICk7XG4gKiB9XG4gKiBgYGBcbiAqXG4gKiBXaGVuIHRoZSBidXR0b24gaXMgY2xpY2tlZCB0aGUgY29tcG9uZW50IHdpbGwgc2hpZnQgdG8gdGhlIGAnZW50ZXJpbmcnYCBzdGF0ZVxuICogYW5kIHN0YXkgdGhlcmUgZm9yIDUwMG1zICh0aGUgdmFsdWUgb2YgYHRpbWVvdXRgKSBiZWZvcmUgaXQgZmluYWxseSBzd2l0Y2hlc1xuICogdG8gYCdlbnRlcmVkJ2AuXG4gKlxuICogV2hlbiBgaW5gIGlzIGBmYWxzZWAgdGhlIHNhbWUgdGhpbmcgaGFwcGVucyBleGNlcHQgdGhlIHN0YXRlIG1vdmVzIGZyb21cbiAqIGAnZXhpdGluZydgIHRvIGAnZXhpdGVkJ2AuXG4gKi9cblxudmFyIFRyYW5zaXRpb24gPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9SZWFjdCRDb21wb25lbnQpIHtcbiAgX2luaGVyaXRzTG9vc2UoVHJhbnNpdGlvbiwgX1JlYWN0JENvbXBvbmVudCk7XG5cbiAgZnVuY3Rpb24gVHJhbnNpdGlvbihwcm9wcywgY29udGV4dCkge1xuICAgIHZhciBfdGhpcztcblxuICAgIF90aGlzID0gX1JlYWN0JENvbXBvbmVudC5jYWxsKHRoaXMsIHByb3BzLCBjb250ZXh0KSB8fCB0aGlzO1xuICAgIHZhciBwYXJlbnRHcm91cCA9IGNvbnRleHQ7IC8vIEluIHRoZSBjb250ZXh0IG9mIGEgVHJhbnNpdGlvbkdyb3VwIGFsbCBlbnRlcnMgYXJlIHJlYWxseSBhcHBlYXJzXG5cbiAgICB2YXIgYXBwZWFyID0gcGFyZW50R3JvdXAgJiYgIXBhcmVudEdyb3VwLmlzTW91bnRpbmcgPyBwcm9wcy5lbnRlciA6IHByb3BzLmFwcGVhcjtcbiAgICB2YXIgaW5pdGlhbFN0YXR1cztcbiAgICBfdGhpcy5hcHBlYXJTdGF0dXMgPSBudWxsO1xuXG4gICAgaWYgKHByb3BzLmluKSB7XG4gICAgICBpZiAoYXBwZWFyKSB7XG4gICAgICAgIGluaXRpYWxTdGF0dXMgPSBFWElURUQ7XG4gICAgICAgIF90aGlzLmFwcGVhclN0YXR1cyA9IEVOVEVSSU5HO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW5pdGlhbFN0YXR1cyA9IEVOVEVSRUQ7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChwcm9wcy51bm1vdW50T25FeGl0IHx8IHByb3BzLm1vdW50T25FbnRlcikge1xuICAgICAgICBpbml0aWFsU3RhdHVzID0gVU5NT1VOVEVEO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW5pdGlhbFN0YXR1cyA9IEVYSVRFRDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBfdGhpcy5zdGF0ZSA9IHtcbiAgICAgIHN0YXR1czogaW5pdGlhbFN0YXR1c1xuICAgIH07XG4gICAgX3RoaXMubmV4dENhbGxiYWNrID0gbnVsbDtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICBUcmFuc2l0aW9uLmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyA9IGZ1bmN0aW9uIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyhfcmVmLCBwcmV2U3RhdGUpIHtcbiAgICB2YXIgbmV4dEluID0gX3JlZi5pbjtcblxuICAgIGlmIChuZXh0SW4gJiYgcHJldlN0YXRlLnN0YXR1cyA9PT0gVU5NT1VOVEVEKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzdGF0dXM6IEVYSVRFRFxuICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfSAvLyBnZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZShwcmV2UHJvcHMpIHtcbiAgLy8gICBsZXQgbmV4dFN0YXR1cyA9IG51bGxcbiAgLy8gICBpZiAocHJldlByb3BzICE9PSB0aGlzLnByb3BzKSB7XG4gIC8vICAgICBjb25zdCB7IHN0YXR1cyB9ID0gdGhpcy5zdGF0ZVxuICAvLyAgICAgaWYgKHRoaXMucHJvcHMuaW4pIHtcbiAgLy8gICAgICAgaWYgKHN0YXR1cyAhPT0gRU5URVJJTkcgJiYgc3RhdHVzICE9PSBFTlRFUkVEKSB7XG4gIC8vICAgICAgICAgbmV4dFN0YXR1cyA9IEVOVEVSSU5HXG4gIC8vICAgICAgIH1cbiAgLy8gICAgIH0gZWxzZSB7XG4gIC8vICAgICAgIGlmIChzdGF0dXMgPT09IEVOVEVSSU5HIHx8IHN0YXR1cyA9PT0gRU5URVJFRCkge1xuICAvLyAgICAgICAgIG5leHRTdGF0dXMgPSBFWElUSU5HXG4gIC8vICAgICAgIH1cbiAgLy8gICAgIH1cbiAgLy8gICB9XG4gIC8vICAgcmV0dXJuIHsgbmV4dFN0YXR1cyB9XG4gIC8vIH1cbiAgO1xuXG4gIHZhciBfcHJvdG8gPSBUcmFuc2l0aW9uLnByb3RvdHlwZTtcblxuICBfcHJvdG8uY29tcG9uZW50RGlkTW91bnQgPSBmdW5jdGlvbiBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICB0aGlzLnVwZGF0ZVN0YXR1cyh0cnVlLCB0aGlzLmFwcGVhclN0YXR1cyk7XG4gIH07XG5cbiAgX3Byb3RvLmNvbXBvbmVudERpZFVwZGF0ZSA9IGZ1bmN0aW9uIGNvbXBvbmVudERpZFVwZGF0ZShwcmV2UHJvcHMpIHtcbiAgICB2YXIgbmV4dFN0YXR1cyA9IG51bGw7XG5cbiAgICBpZiAocHJldlByb3BzICE9PSB0aGlzLnByb3BzKSB7XG4gICAgICB2YXIgc3RhdHVzID0gdGhpcy5zdGF0ZS5zdGF0dXM7XG5cbiAgICAgIGlmICh0aGlzLnByb3BzLmluKSB7XG4gICAgICAgIGlmIChzdGF0dXMgIT09IEVOVEVSSU5HICYmIHN0YXR1cyAhPT0gRU5URVJFRCkge1xuICAgICAgICAgIG5leHRTdGF0dXMgPSBFTlRFUklORztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHN0YXR1cyA9PT0gRU5URVJJTkcgfHwgc3RhdHVzID09PSBFTlRFUkVEKSB7XG4gICAgICAgICAgbmV4dFN0YXR1cyA9IEVYSVRJTkc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLnVwZGF0ZVN0YXR1cyhmYWxzZSwgbmV4dFN0YXR1cyk7XG4gIH07XG5cbiAgX3Byb3RvLmNvbXBvbmVudFdpbGxVbm1vdW50ID0gZnVuY3Rpb24gY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgdGhpcy5jYW5jZWxOZXh0Q2FsbGJhY2soKTtcbiAgfTtcblxuICBfcHJvdG8uZ2V0VGltZW91dHMgPSBmdW5jdGlvbiBnZXRUaW1lb3V0cygpIHtcbiAgICB2YXIgdGltZW91dCA9IHRoaXMucHJvcHMudGltZW91dDtcbiAgICB2YXIgZXhpdCwgZW50ZXIsIGFwcGVhcjtcbiAgICBleGl0ID0gZW50ZXIgPSBhcHBlYXIgPSB0aW1lb3V0O1xuXG4gICAgaWYgKHRpbWVvdXQgIT0gbnVsbCAmJiB0eXBlb2YgdGltZW91dCAhPT0gJ251bWJlcicpIHtcbiAgICAgIGV4aXQgPSB0aW1lb3V0LmV4aXQ7XG4gICAgICBlbnRlciA9IHRpbWVvdXQuZW50ZXI7IC8vIFRPRE86IHJlbW92ZSBmYWxsYmFjayBmb3IgbmV4dCBtYWpvclxuXG4gICAgICBhcHBlYXIgPSB0aW1lb3V0LmFwcGVhciAhPT0gdW5kZWZpbmVkID8gdGltZW91dC5hcHBlYXIgOiBlbnRlcjtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgZXhpdDogZXhpdCxcbiAgICAgIGVudGVyOiBlbnRlcixcbiAgICAgIGFwcGVhcjogYXBwZWFyXG4gICAgfTtcbiAgfTtcblxuICBfcHJvdG8udXBkYXRlU3RhdHVzID0gZnVuY3Rpb24gdXBkYXRlU3RhdHVzKG1vdW50aW5nLCBuZXh0U3RhdHVzKSB7XG4gICAgaWYgKG1vdW50aW5nID09PSB2b2lkIDApIHtcbiAgICAgIG1vdW50aW5nID0gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKG5leHRTdGF0dXMgIT09IG51bGwpIHtcbiAgICAgIC8vIG5leHRTdGF0dXMgd2lsbCBhbHdheXMgYmUgRU5URVJJTkcgb3IgRVhJVElORy5cbiAgICAgIHRoaXMuY2FuY2VsTmV4dENhbGxiYWNrKCk7XG5cbiAgICAgIGlmIChuZXh0U3RhdHVzID09PSBFTlRFUklORykge1xuICAgICAgICB0aGlzLnBlcmZvcm1FbnRlcihtb3VudGluZyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnBlcmZvcm1FeGl0KCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0aGlzLnByb3BzLnVubW91bnRPbkV4aXQgJiYgdGhpcy5zdGF0ZS5zdGF0dXMgPT09IEVYSVRFRCkge1xuICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgIHN0YXR1czogVU5NT1VOVEVEXG4gICAgICB9KTtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLnBlcmZvcm1FbnRlciA9IGZ1bmN0aW9uIHBlcmZvcm1FbnRlcihtb3VudGluZykge1xuICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgdmFyIGVudGVyID0gdGhpcy5wcm9wcy5lbnRlcjtcbiAgICB2YXIgYXBwZWFyaW5nID0gdGhpcy5jb250ZXh0ID8gdGhpcy5jb250ZXh0LmlzTW91bnRpbmcgOiBtb3VudGluZztcblxuICAgIHZhciBfcmVmMiA9IHRoaXMucHJvcHMubm9kZVJlZiA/IFthcHBlYXJpbmddIDogW1JlYWN0RE9NLmZpbmRET01Ob2RlKHRoaXMpLCBhcHBlYXJpbmddLFxuICAgICAgICBtYXliZU5vZGUgPSBfcmVmMlswXSxcbiAgICAgICAgbWF5YmVBcHBlYXJpbmcgPSBfcmVmMlsxXTtcblxuICAgIHZhciB0aW1lb3V0cyA9IHRoaXMuZ2V0VGltZW91dHMoKTtcbiAgICB2YXIgZW50ZXJUaW1lb3V0ID0gYXBwZWFyaW5nID8gdGltZW91dHMuYXBwZWFyIDogdGltZW91dHMuZW50ZXI7IC8vIG5vIGVudGVyIGFuaW1hdGlvbiBza2lwIHJpZ2h0IHRvIEVOVEVSRURcbiAgICAvLyBpZiB3ZSBhcmUgbW91bnRpbmcgYW5kIHJ1bm5pbmcgdGhpcyBpdCBtZWFucyBhcHBlYXIgX211c3RfIGJlIHNldFxuXG4gICAgaWYgKCFtb3VudGluZyAmJiAhZW50ZXIgfHwgY29uZmlnLmRpc2FibGVkKSB7XG4gICAgICB0aGlzLnNhZmVTZXRTdGF0ZSh7XG4gICAgICAgIHN0YXR1czogRU5URVJFRFxuICAgICAgfSwgZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpczIucHJvcHMub25FbnRlcmVkKG1heWJlTm9kZSk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLnByb3BzLm9uRW50ZXIobWF5YmVOb2RlLCBtYXliZUFwcGVhcmluZyk7XG4gICAgdGhpcy5zYWZlU2V0U3RhdGUoe1xuICAgICAgc3RhdHVzOiBFTlRFUklOR1xuICAgIH0sIGZ1bmN0aW9uICgpIHtcbiAgICAgIF90aGlzMi5wcm9wcy5vbkVudGVyaW5nKG1heWJlTm9kZSwgbWF5YmVBcHBlYXJpbmcpO1xuXG4gICAgICBfdGhpczIub25UcmFuc2l0aW9uRW5kKGVudGVyVGltZW91dCwgZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpczIuc2FmZVNldFN0YXRlKHtcbiAgICAgICAgICBzdGF0dXM6IEVOVEVSRURcbiAgICAgICAgfSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIF90aGlzMi5wcm9wcy5vbkVudGVyZWQobWF5YmVOb2RlLCBtYXliZUFwcGVhcmluZyk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH07XG5cbiAgX3Byb3RvLnBlcmZvcm1FeGl0ID0gZnVuY3Rpb24gcGVyZm9ybUV4aXQoKSB7XG4gICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICB2YXIgZXhpdCA9IHRoaXMucHJvcHMuZXhpdDtcbiAgICB2YXIgdGltZW91dHMgPSB0aGlzLmdldFRpbWVvdXRzKCk7XG4gICAgdmFyIG1heWJlTm9kZSA9IHRoaXMucHJvcHMubm9kZVJlZiA/IHVuZGVmaW5lZCA6IFJlYWN0RE9NLmZpbmRET01Ob2RlKHRoaXMpOyAvLyBubyBleGl0IGFuaW1hdGlvbiBza2lwIHJpZ2h0IHRvIEVYSVRFRFxuXG4gICAgaWYgKCFleGl0IHx8IGNvbmZpZy5kaXNhYmxlZCkge1xuICAgICAgdGhpcy5zYWZlU2V0U3RhdGUoe1xuICAgICAgICBzdGF0dXM6IEVYSVRFRFxuICAgICAgfSwgZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpczMucHJvcHMub25FeGl0ZWQobWF5YmVOb2RlKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMucHJvcHMub25FeGl0KG1heWJlTm9kZSk7XG4gICAgdGhpcy5zYWZlU2V0U3RhdGUoe1xuICAgICAgc3RhdHVzOiBFWElUSU5HXG4gICAgfSwgZnVuY3Rpb24gKCkge1xuICAgICAgX3RoaXMzLnByb3BzLm9uRXhpdGluZyhtYXliZU5vZGUpO1xuXG4gICAgICBfdGhpczMub25UcmFuc2l0aW9uRW5kKHRpbWVvdXRzLmV4aXQsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3RoaXMzLnNhZmVTZXRTdGF0ZSh7XG4gICAgICAgICAgc3RhdHVzOiBFWElURURcbiAgICAgICAgfSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIF90aGlzMy5wcm9wcy5vbkV4aXRlZChtYXliZU5vZGUpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9O1xuXG4gIF9wcm90by5jYW5jZWxOZXh0Q2FsbGJhY2sgPSBmdW5jdGlvbiBjYW5jZWxOZXh0Q2FsbGJhY2soKSB7XG4gICAgaWYgKHRoaXMubmV4dENhbGxiYWNrICE9PSBudWxsKSB7XG4gICAgICB0aGlzLm5leHRDYWxsYmFjay5jYW5jZWwoKTtcbiAgICAgIHRoaXMubmV4dENhbGxiYWNrID0gbnVsbDtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLnNhZmVTZXRTdGF0ZSA9IGZ1bmN0aW9uIHNhZmVTZXRTdGF0ZShuZXh0U3RhdGUsIGNhbGxiYWNrKSB7XG4gICAgLy8gVGhpcyBzaG91bGRuJ3QgYmUgbmVjZXNzYXJ5LCBidXQgdGhlcmUgYXJlIHdlaXJkIHJhY2UgY29uZGl0aW9ucyB3aXRoXG4gICAgLy8gc2V0U3RhdGUgY2FsbGJhY2tzIGFuZCB1bm1vdW50aW5nIGluIHRlc3RpbmcsIHNvIGFsd2F5cyBtYWtlIHN1cmUgdGhhdFxuICAgIC8vIHdlIGNhbiBjYW5jZWwgYW55IHBlbmRpbmcgc2V0U3RhdGUgY2FsbGJhY2tzIGFmdGVyIHdlIHVubW91bnQuXG4gICAgY2FsbGJhY2sgPSB0aGlzLnNldE5leHRDYWxsYmFjayhjYWxsYmFjayk7XG4gICAgdGhpcy5zZXRTdGF0ZShuZXh0U3RhdGUsIGNhbGxiYWNrKTtcbiAgfTtcblxuICBfcHJvdG8uc2V0TmV4dENhbGxiYWNrID0gZnVuY3Rpb24gc2V0TmV4dENhbGxiYWNrKGNhbGxiYWNrKSB7XG4gICAgdmFyIF90aGlzNCA9IHRoaXM7XG5cbiAgICB2YXIgYWN0aXZlID0gdHJ1ZTtcblxuICAgIHRoaXMubmV4dENhbGxiYWNrID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICBpZiAoYWN0aXZlKSB7XG4gICAgICAgIGFjdGl2ZSA9IGZhbHNlO1xuICAgICAgICBfdGhpczQubmV4dENhbGxiYWNrID0gbnVsbDtcbiAgICAgICAgY2FsbGJhY2soZXZlbnQpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB0aGlzLm5leHRDYWxsYmFjay5jYW5jZWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBhY3RpdmUgPSBmYWxzZTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIHRoaXMubmV4dENhbGxiYWNrO1xuICB9O1xuXG4gIF9wcm90by5vblRyYW5zaXRpb25FbmQgPSBmdW5jdGlvbiBvblRyYW5zaXRpb25FbmQodGltZW91dCwgaGFuZGxlcikge1xuICAgIHRoaXMuc2V0TmV4dENhbGxiYWNrKGhhbmRsZXIpO1xuICAgIHZhciBub2RlID0gdGhpcy5wcm9wcy5ub2RlUmVmID8gdGhpcy5wcm9wcy5ub2RlUmVmLmN1cnJlbnQgOiBSZWFjdERPTS5maW5kRE9NTm9kZSh0aGlzKTtcbiAgICB2YXIgZG9lc05vdEhhdmVUaW1lb3V0T3JMaXN0ZW5lciA9IHRpbWVvdXQgPT0gbnVsbCAmJiAhdGhpcy5wcm9wcy5hZGRFbmRMaXN0ZW5lcjtcblxuICAgIGlmICghbm9kZSB8fCBkb2VzTm90SGF2ZVRpbWVvdXRPckxpc3RlbmVyKSB7XG4gICAgICBzZXRUaW1lb3V0KHRoaXMubmV4dENhbGxiYWNrLCAwKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5wcm9wcy5hZGRFbmRMaXN0ZW5lcikge1xuICAgICAgdmFyIF9yZWYzID0gdGhpcy5wcm9wcy5ub2RlUmVmID8gW3RoaXMubmV4dENhbGxiYWNrXSA6IFtub2RlLCB0aGlzLm5leHRDYWxsYmFja10sXG4gICAgICAgICAgbWF5YmVOb2RlID0gX3JlZjNbMF0sXG4gICAgICAgICAgbWF5YmVOZXh0Q2FsbGJhY2sgPSBfcmVmM1sxXTtcblxuICAgICAgdGhpcy5wcm9wcy5hZGRFbmRMaXN0ZW5lcihtYXliZU5vZGUsIG1heWJlTmV4dENhbGxiYWNrKTtcbiAgICB9XG5cbiAgICBpZiAodGltZW91dCAhPSBudWxsKSB7XG4gICAgICBzZXRUaW1lb3V0KHRoaXMubmV4dENhbGxiYWNrLCB0aW1lb3V0KTtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICB2YXIgc3RhdHVzID0gdGhpcy5zdGF0ZS5zdGF0dXM7XG5cbiAgICBpZiAoc3RhdHVzID09PSBVTk1PVU5URUQpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHZhciBfdGhpcyRwcm9wcyA9IHRoaXMucHJvcHMsXG4gICAgICAgIGNoaWxkcmVuID0gX3RoaXMkcHJvcHMuY2hpbGRyZW4sXG4gICAgICAgIF9pbiA9IF90aGlzJHByb3BzLmluLFxuICAgICAgICBfbW91bnRPbkVudGVyID0gX3RoaXMkcHJvcHMubW91bnRPbkVudGVyLFxuICAgICAgICBfdW5tb3VudE9uRXhpdCA9IF90aGlzJHByb3BzLnVubW91bnRPbkV4aXQsXG4gICAgICAgIF9hcHBlYXIgPSBfdGhpcyRwcm9wcy5hcHBlYXIsXG4gICAgICAgIF9lbnRlciA9IF90aGlzJHByb3BzLmVudGVyLFxuICAgICAgICBfZXhpdCA9IF90aGlzJHByb3BzLmV4aXQsXG4gICAgICAgIF90aW1lb3V0ID0gX3RoaXMkcHJvcHMudGltZW91dCxcbiAgICAgICAgX2FkZEVuZExpc3RlbmVyID0gX3RoaXMkcHJvcHMuYWRkRW5kTGlzdGVuZXIsXG4gICAgICAgIF9vbkVudGVyID0gX3RoaXMkcHJvcHMub25FbnRlcixcbiAgICAgICAgX29uRW50ZXJpbmcgPSBfdGhpcyRwcm9wcy5vbkVudGVyaW5nLFxuICAgICAgICBfb25FbnRlcmVkID0gX3RoaXMkcHJvcHMub25FbnRlcmVkLFxuICAgICAgICBfb25FeGl0ID0gX3RoaXMkcHJvcHMub25FeGl0LFxuICAgICAgICBfb25FeGl0aW5nID0gX3RoaXMkcHJvcHMub25FeGl0aW5nLFxuICAgICAgICBfb25FeGl0ZWQgPSBfdGhpcyRwcm9wcy5vbkV4aXRlZCxcbiAgICAgICAgX25vZGVSZWYgPSBfdGhpcyRwcm9wcy5ub2RlUmVmLFxuICAgICAgICBjaGlsZFByb3BzID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UoX3RoaXMkcHJvcHMsIFtcImNoaWxkcmVuXCIsIFwiaW5cIiwgXCJtb3VudE9uRW50ZXJcIiwgXCJ1bm1vdW50T25FeGl0XCIsIFwiYXBwZWFyXCIsIFwiZW50ZXJcIiwgXCJleGl0XCIsIFwidGltZW91dFwiLCBcImFkZEVuZExpc3RlbmVyXCIsIFwib25FbnRlclwiLCBcIm9uRW50ZXJpbmdcIiwgXCJvbkVudGVyZWRcIiwgXCJvbkV4aXRcIiwgXCJvbkV4aXRpbmdcIiwgXCJvbkV4aXRlZFwiLCBcIm5vZGVSZWZcIl0pO1xuXG4gICAgcmV0dXJuIChcbiAgICAgIC8qI19fUFVSRV9fKi9cbiAgICAgIC8vIGFsbG93cyBmb3IgbmVzdGVkIFRyYW5zaXRpb25zXG4gICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFRyYW5zaXRpb25Hcm91cENvbnRleHQuUHJvdmlkZXIsIHtcbiAgICAgICAgdmFsdWU6IG51bGxcbiAgICAgIH0sIHR5cGVvZiBjaGlsZHJlbiA9PT0gJ2Z1bmN0aW9uJyA/IGNoaWxkcmVuKHN0YXR1cywgY2hpbGRQcm9wcykgOiBSZWFjdC5jbG9uZUVsZW1lbnQoUmVhY3QuQ2hpbGRyZW4ub25seShjaGlsZHJlbiksIGNoaWxkUHJvcHMpKVxuICAgICk7XG4gIH07XG5cbiAgcmV0dXJuIFRyYW5zaXRpb247XG59KFJlYWN0LkNvbXBvbmVudCk7XG5cblRyYW5zaXRpb24uY29udGV4dFR5cGUgPSBUcmFuc2l0aW9uR3JvdXBDb250ZXh0O1xuVHJhbnNpdGlvbi5wcm9wVHlwZXMgPSBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyB7XG4gIC8qKlxuICAgKiBBIFJlYWN0IHJlZmVyZW5jZSB0byBET00gZWxlbWVudCB0aGF0IG5lZWQgdG8gdHJhbnNpdGlvbjpcbiAgICogaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzUxMTI3MTMwLzQ2NzE5MzJcbiAgICpcbiAgICogICAtIFdoZW4gYG5vZGVSZWZgIHByb3AgaXMgdXNlZCwgYG5vZGVgIGlzIG5vdCBwYXNzZWQgdG8gY2FsbGJhY2sgZnVuY3Rpb25zXG4gICAqICAgICAgKGUuZy4gYG9uRW50ZXJgKSBiZWNhdXNlIHVzZXIgYWxyZWFkeSBoYXMgZGlyZWN0IGFjY2VzcyB0byB0aGUgbm9kZS5cbiAgICogICAtIFdoZW4gY2hhbmdpbmcgYGtleWAgcHJvcCBvZiBgVHJhbnNpdGlvbmAgaW4gYSBgVHJhbnNpdGlvbkdyb3VwYCBhIG5ld1xuICAgKiAgICAgYG5vZGVSZWZgIG5lZWQgdG8gYmUgcHJvdmlkZWQgdG8gYFRyYW5zaXRpb25gIHdpdGggY2hhbmdlZCBga2V5YCBwcm9wXG4gICAqICAgICAoc2VlXG4gICAqICAgICBbdGVzdC9DU1NUcmFuc2l0aW9uLXRlc3QuanNdKGh0dHBzOi8vZ2l0aHViLmNvbS9yZWFjdGpzL3JlYWN0LXRyYW5zaXRpb24tZ3JvdXAvYmxvYi8xMzQzNWY4OTdiM2FiNzFmNmUxOWQ3MjRmMTQ1NTk2ZjU5MTA1ODFjL3Rlc3QvQ1NTVHJhbnNpdGlvbi10ZXN0LmpzI0wzNjItTDQzNykpLlxuICAgKi9cbiAgbm9kZVJlZjogUHJvcFR5cGVzLnNoYXBlKHtcbiAgICBjdXJyZW50OiB0eXBlb2YgRWxlbWVudCA9PT0gJ3VuZGVmaW5lZCcgPyBQcm9wVHlwZXMuYW55IDogZnVuY3Rpb24gKHByb3BWYWx1ZSwga2V5LCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lLCBzZWNyZXQpIHtcbiAgICAgIHZhciB2YWx1ZSA9IHByb3BWYWx1ZVtrZXldO1xuICAgICAgcmV0dXJuIFByb3BUeXBlcy5pbnN0YW5jZU9mKHZhbHVlICYmICdvd25lckRvY3VtZW50JyBpbiB2YWx1ZSA/IHZhbHVlLm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXcuRWxlbWVudCA6IEVsZW1lbnQpKHByb3BWYWx1ZSwga2V5LCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lLCBzZWNyZXQpO1xuICAgIH1cbiAgfSksXG5cbiAgLyoqXG4gICAqIEEgYGZ1bmN0aW9uYCBjaGlsZCBjYW4gYmUgdXNlZCBpbnN0ZWFkIG9mIGEgUmVhY3QgZWxlbWVudC4gVGhpcyBmdW5jdGlvbiBpc1xuICAgKiBjYWxsZWQgd2l0aCB0aGUgY3VycmVudCB0cmFuc2l0aW9uIHN0YXR1cyAoYCdlbnRlcmluZydgLCBgJ2VudGVyZWQnYCxcbiAgICogYCdleGl0aW5nJ2AsIGAnZXhpdGVkJ2ApLCB3aGljaCBjYW4gYmUgdXNlZCB0byBhcHBseSBjb250ZXh0XG4gICAqIHNwZWNpZmljIHByb3BzIHRvIGEgY29tcG9uZW50LlxuICAgKlxuICAgKiBgYGBqc3hcbiAgICogPFRyYW5zaXRpb24gaW49e3RoaXMuc3RhdGUuaW59IHRpbWVvdXQ9ezE1MH0+XG4gICAqICAge3N0YXRlID0+IChcbiAgICogICAgIDxNeUNvbXBvbmVudCBjbGFzc05hbWU9e2BmYWRlIGZhZGUtJHtzdGF0ZX1gfSAvPlxuICAgKiAgICl9XG4gICAqIDwvVHJhbnNpdGlvbj5cbiAgICogYGBgXG4gICAqL1xuICBjaGlsZHJlbjogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZCwgUHJvcFR5cGVzLmVsZW1lbnQuaXNSZXF1aXJlZF0pLmlzUmVxdWlyZWQsXG5cbiAgLyoqXG4gICAqIFNob3cgdGhlIGNvbXBvbmVudDsgdHJpZ2dlcnMgdGhlIGVudGVyIG9yIGV4aXQgc3RhdGVzXG4gICAqL1xuICBpbjogUHJvcFR5cGVzLmJvb2wsXG5cbiAgLyoqXG4gICAqIEJ5IGRlZmF1bHQgdGhlIGNoaWxkIGNvbXBvbmVudCBpcyBtb3VudGVkIGltbWVkaWF0ZWx5IGFsb25nIHdpdGhcbiAgICogdGhlIHBhcmVudCBgVHJhbnNpdGlvbmAgY29tcG9uZW50LiBJZiB5b3Ugd2FudCB0byBcImxhenkgbW91bnRcIiB0aGUgY29tcG9uZW50IG9uIHRoZVxuICAgKiBmaXJzdCBgaW49e3RydWV9YCB5b3UgY2FuIHNldCBgbW91bnRPbkVudGVyYC4gQWZ0ZXIgdGhlIGZpcnN0IGVudGVyIHRyYW5zaXRpb24gdGhlIGNvbXBvbmVudCB3aWxsIHN0YXlcbiAgICogbW91bnRlZCwgZXZlbiBvbiBcImV4aXRlZFwiLCB1bmxlc3MgeW91IGFsc28gc3BlY2lmeSBgdW5tb3VudE9uRXhpdGAuXG4gICAqL1xuICBtb3VudE9uRW50ZXI6IFByb3BUeXBlcy5ib29sLFxuXG4gIC8qKlxuICAgKiBCeSBkZWZhdWx0IHRoZSBjaGlsZCBjb21wb25lbnQgc3RheXMgbW91bnRlZCBhZnRlciBpdCByZWFjaGVzIHRoZSBgJ2V4aXRlZCdgIHN0YXRlLlxuICAgKiBTZXQgYHVubW91bnRPbkV4aXRgIGlmIHlvdSdkIHByZWZlciB0byB1bm1vdW50IHRoZSBjb21wb25lbnQgYWZ0ZXIgaXQgZmluaXNoZXMgZXhpdGluZy5cbiAgICovXG4gIHVubW91bnRPbkV4aXQ6IFByb3BUeXBlcy5ib29sLFxuXG4gIC8qKlxuICAgKiBCeSBkZWZhdWx0IHRoZSBjaGlsZCBjb21wb25lbnQgZG9lcyBub3QgcGVyZm9ybSB0aGUgZW50ZXIgdHJhbnNpdGlvbiB3aGVuXG4gICAqIGl0IGZpcnN0IG1vdW50cywgcmVnYXJkbGVzcyBvZiB0aGUgdmFsdWUgb2YgYGluYC4gSWYgeW91IHdhbnQgdGhpc1xuICAgKiBiZWhhdmlvciwgc2V0IGJvdGggYGFwcGVhcmAgYW5kIGBpbmAgdG8gYHRydWVgLlxuICAgKlxuICAgKiA+ICoqTm90ZSoqOiB0aGVyZSBhcmUgbm8gc3BlY2lhbCBhcHBlYXIgc3RhdGVzIGxpa2UgYGFwcGVhcmluZ2AvYGFwcGVhcmVkYCwgdGhpcyBwcm9wXG4gICAqID4gb25seSBhZGRzIGFuIGFkZGl0aW9uYWwgZW50ZXIgdHJhbnNpdGlvbi4gSG93ZXZlciwgaW4gdGhlXG4gICAqID4gYDxDU1NUcmFuc2l0aW9uPmAgY29tcG9uZW50IHRoYXQgZmlyc3QgZW50ZXIgdHJhbnNpdGlvbiBkb2VzIHJlc3VsdCBpblxuICAgKiA+IGFkZGl0aW9uYWwgYC5hcHBlYXItKmAgY2xhc3NlcywgdGhhdCB3YXkgeW91IGNhbiBjaG9vc2UgdG8gc3R5bGUgaXRcbiAgICogPiBkaWZmZXJlbnRseS5cbiAgICovXG4gIGFwcGVhcjogUHJvcFR5cGVzLmJvb2wsXG5cbiAgLyoqXG4gICAqIEVuYWJsZSBvciBkaXNhYmxlIGVudGVyIHRyYW5zaXRpb25zLlxuICAgKi9cbiAgZW50ZXI6IFByb3BUeXBlcy5ib29sLFxuXG4gIC8qKlxuICAgKiBFbmFibGUgb3IgZGlzYWJsZSBleGl0IHRyYW5zaXRpb25zLlxuICAgKi9cbiAgZXhpdDogUHJvcFR5cGVzLmJvb2wsXG5cbiAgLyoqXG4gICAqIFRoZSBkdXJhdGlvbiBvZiB0aGUgdHJhbnNpdGlvbiwgaW4gbWlsbGlzZWNvbmRzLlxuICAgKiBSZXF1aXJlZCB1bmxlc3MgYGFkZEVuZExpc3RlbmVyYCBpcyBwcm92aWRlZC5cbiAgICpcbiAgICogWW91IG1heSBzcGVjaWZ5IGEgc2luZ2xlIHRpbWVvdXQgZm9yIGFsbCB0cmFuc2l0aW9uczpcbiAgICpcbiAgICogYGBganN4XG4gICAqIHRpbWVvdXQ9ezUwMH1cbiAgICogYGBgXG4gICAqXG4gICAqIG9yIGluZGl2aWR1YWxseTpcbiAgICpcbiAgICogYGBganN4XG4gICAqIHRpbWVvdXQ9e3tcbiAgICogIGFwcGVhcjogNTAwLFxuICAgKiAgZW50ZXI6IDMwMCxcbiAgICogIGV4aXQ6IDUwMCxcbiAgICogfX1cbiAgICogYGBgXG4gICAqXG4gICAqIC0gYGFwcGVhcmAgZGVmYXVsdHMgdG8gdGhlIHZhbHVlIG9mIGBlbnRlcmBcbiAgICogLSBgZW50ZXJgIGRlZmF1bHRzIHRvIGAwYFxuICAgKiAtIGBleGl0YCBkZWZhdWx0cyB0byBgMGBcbiAgICpcbiAgICogQHR5cGUge251bWJlciB8IHsgZW50ZXI/OiBudW1iZXIsIGV4aXQ/OiBudW1iZXIsIGFwcGVhcj86IG51bWJlciB9fVxuICAgKi9cbiAgdGltZW91dDogZnVuY3Rpb24gdGltZW91dChwcm9wcykge1xuICAgIHZhciBwdCA9IHRpbWVvdXRzU2hhcGU7XG4gICAgaWYgKCFwcm9wcy5hZGRFbmRMaXN0ZW5lcikgcHQgPSBwdC5pc1JlcXVpcmVkO1xuXG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgcmV0dXJuIHB0LmFwcGx5KHZvaWQgMCwgW3Byb3BzXS5jb25jYXQoYXJncykpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBBZGQgYSBjdXN0b20gdHJhbnNpdGlvbiBlbmQgdHJpZ2dlci4gQ2FsbGVkIHdpdGggdGhlIHRyYW5zaXRpb25pbmdcbiAgICogRE9NIG5vZGUgYW5kIGEgYGRvbmVgIGNhbGxiYWNrLiBBbGxvd3MgZm9yIG1vcmUgZmluZSBncmFpbmVkIHRyYW5zaXRpb24gZW5kXG4gICAqIGxvZ2ljLiBUaW1lb3V0cyBhcmUgc3RpbGwgdXNlZCBhcyBhIGZhbGxiYWNrIGlmIHByb3ZpZGVkLlxuICAgKlxuICAgKiAqKk5vdGUqKjogd2hlbiBgbm9kZVJlZmAgcHJvcCBpcyBwYXNzZWQsIGBub2RlYCBpcyBub3QgcGFzc2VkLlxuICAgKlxuICAgKiBgYGBqc3hcbiAgICogYWRkRW5kTGlzdGVuZXI9eyhub2RlLCBkb25lKSA9PiB7XG4gICAqICAgLy8gdXNlIHRoZSBjc3MgdHJhbnNpdGlvbmVuZCBldmVudCB0byBtYXJrIHRoZSBmaW5pc2ggb2YgYSB0cmFuc2l0aW9uXG4gICAqICAgbm9kZS5hZGRFdmVudExpc3RlbmVyKCd0cmFuc2l0aW9uZW5kJywgZG9uZSwgZmFsc2UpO1xuICAgKiB9fVxuICAgKiBgYGBcbiAgICovXG4gIGFkZEVuZExpc3RlbmVyOiBQcm9wVHlwZXMuZnVuYyxcblxuICAvKipcbiAgICogQ2FsbGJhY2sgZmlyZWQgYmVmb3JlIHRoZSBcImVudGVyaW5nXCIgc3RhdHVzIGlzIGFwcGxpZWQuIEFuIGV4dHJhIHBhcmFtZXRlclxuICAgKiBgaXNBcHBlYXJpbmdgIGlzIHN1cHBsaWVkIHRvIGluZGljYXRlIGlmIHRoZSBlbnRlciBzdGFnZSBpcyBvY2N1cnJpbmcgb24gdGhlIGluaXRpYWwgbW91bnRcbiAgICpcbiAgICogKipOb3RlKio6IHdoZW4gYG5vZGVSZWZgIHByb3AgaXMgcGFzc2VkLCBgbm9kZWAgaXMgbm90IHBhc3NlZC5cbiAgICpcbiAgICogQHR5cGUgRnVuY3Rpb24obm9kZTogSHRtbEVsZW1lbnQsIGlzQXBwZWFyaW5nOiBib29sKSAtPiB2b2lkXG4gICAqL1xuICBvbkVudGVyOiBQcm9wVHlwZXMuZnVuYyxcblxuICAvKipcbiAgICogQ2FsbGJhY2sgZmlyZWQgYWZ0ZXIgdGhlIFwiZW50ZXJpbmdcIiBzdGF0dXMgaXMgYXBwbGllZC4gQW4gZXh0cmEgcGFyYW1ldGVyXG4gICAqIGBpc0FwcGVhcmluZ2AgaXMgc3VwcGxpZWQgdG8gaW5kaWNhdGUgaWYgdGhlIGVudGVyIHN0YWdlIGlzIG9jY3VycmluZyBvbiB0aGUgaW5pdGlhbCBtb3VudFxuICAgKlxuICAgKiAqKk5vdGUqKjogd2hlbiBgbm9kZVJlZmAgcHJvcCBpcyBwYXNzZWQsIGBub2RlYCBpcyBub3QgcGFzc2VkLlxuICAgKlxuICAgKiBAdHlwZSBGdW5jdGlvbihub2RlOiBIdG1sRWxlbWVudCwgaXNBcHBlYXJpbmc6IGJvb2wpXG4gICAqL1xuICBvbkVudGVyaW5nOiBQcm9wVHlwZXMuZnVuYyxcblxuICAvKipcbiAgICogQ2FsbGJhY2sgZmlyZWQgYWZ0ZXIgdGhlIFwiZW50ZXJlZFwiIHN0YXR1cyBpcyBhcHBsaWVkLiBBbiBleHRyYSBwYXJhbWV0ZXJcbiAgICogYGlzQXBwZWFyaW5nYCBpcyBzdXBwbGllZCB0byBpbmRpY2F0ZSBpZiB0aGUgZW50ZXIgc3RhZ2UgaXMgb2NjdXJyaW5nIG9uIHRoZSBpbml0aWFsIG1vdW50XG4gICAqXG4gICAqICoqTm90ZSoqOiB3aGVuIGBub2RlUmVmYCBwcm9wIGlzIHBhc3NlZCwgYG5vZGVgIGlzIG5vdCBwYXNzZWQuXG4gICAqXG4gICAqIEB0eXBlIEZ1bmN0aW9uKG5vZGU6IEh0bWxFbGVtZW50LCBpc0FwcGVhcmluZzogYm9vbCkgLT4gdm9pZFxuICAgKi9cbiAgb25FbnRlcmVkOiBQcm9wVHlwZXMuZnVuYyxcblxuICAvKipcbiAgICogQ2FsbGJhY2sgZmlyZWQgYmVmb3JlIHRoZSBcImV4aXRpbmdcIiBzdGF0dXMgaXMgYXBwbGllZC5cbiAgICpcbiAgICogKipOb3RlKio6IHdoZW4gYG5vZGVSZWZgIHByb3AgaXMgcGFzc2VkLCBgbm9kZWAgaXMgbm90IHBhc3NlZC5cbiAgICpcbiAgICogQHR5cGUgRnVuY3Rpb24obm9kZTogSHRtbEVsZW1lbnQpIC0+IHZvaWRcbiAgICovXG4gIG9uRXhpdDogUHJvcFR5cGVzLmZ1bmMsXG5cbiAgLyoqXG4gICAqIENhbGxiYWNrIGZpcmVkIGFmdGVyIHRoZSBcImV4aXRpbmdcIiBzdGF0dXMgaXMgYXBwbGllZC5cbiAgICpcbiAgICogKipOb3RlKio6IHdoZW4gYG5vZGVSZWZgIHByb3AgaXMgcGFzc2VkLCBgbm9kZWAgaXMgbm90IHBhc3NlZC5cbiAgICpcbiAgICogQHR5cGUgRnVuY3Rpb24obm9kZTogSHRtbEVsZW1lbnQpIC0+IHZvaWRcbiAgICovXG4gIG9uRXhpdGluZzogUHJvcFR5cGVzLmZ1bmMsXG5cbiAgLyoqXG4gICAqIENhbGxiYWNrIGZpcmVkIGFmdGVyIHRoZSBcImV4aXRlZFwiIHN0YXR1cyBpcyBhcHBsaWVkLlxuICAgKlxuICAgKiAqKk5vdGUqKjogd2hlbiBgbm9kZVJlZmAgcHJvcCBpcyBwYXNzZWQsIGBub2RlYCBpcyBub3QgcGFzc2VkXG4gICAqXG4gICAqIEB0eXBlIEZ1bmN0aW9uKG5vZGU6IEh0bWxFbGVtZW50KSAtPiB2b2lkXG4gICAqL1xuICBvbkV4aXRlZDogUHJvcFR5cGVzLmZ1bmNcbn0gOiB7fTsgLy8gTmFtZSB0aGUgZnVuY3Rpb24gc28gaXQgaXMgY2xlYXJlciBpbiB0aGUgZG9jdW1lbnRhdGlvblxuXG5mdW5jdGlvbiBub29wKCkge31cblxuVHJhbnNpdGlvbi5kZWZhdWx0UHJvcHMgPSB7XG4gIGluOiBmYWxzZSxcbiAgbW91bnRPbkVudGVyOiBmYWxzZSxcbiAgdW5tb3VudE9uRXhpdDogZmFsc2UsXG4gIGFwcGVhcjogZmFsc2UsXG4gIGVudGVyOiB0cnVlLFxuICBleGl0OiB0cnVlLFxuICBvbkVudGVyOiBub29wLFxuICBvbkVudGVyaW5nOiBub29wLFxuICBvbkVudGVyZWQ6IG5vb3AsXG4gIG9uRXhpdDogbm9vcCxcbiAgb25FeGl0aW5nOiBub29wLFxuICBvbkV4aXRlZDogbm9vcFxufTtcblRyYW5zaXRpb24uVU5NT1VOVEVEID0gVU5NT1VOVEVEO1xuVHJhbnNpdGlvbi5FWElURUQgPSBFWElURUQ7XG5UcmFuc2l0aW9uLkVOVEVSSU5HID0gRU5URVJJTkc7XG5UcmFuc2l0aW9uLkVOVEVSRUQgPSBFTlRFUkVEO1xuVHJhbnNpdGlvbi5FWElUSU5HID0gRVhJVElORztcbmV4cG9ydCBkZWZhdWx0IFRyYW5zaXRpb247IiwiaW1wb3J0IF9leHRlbmRzIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9leHRlbmRzXCI7XG5pbXBvcnQgX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2VcIjtcbmltcG9ydCBfaW5oZXJpdHNMb29zZSBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vaW5oZXJpdHNMb29zZVwiO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCBhZGRPbmVDbGFzcyBmcm9tICdkb20taGVscGVycy9hZGRDbGFzcyc7XG5pbXBvcnQgcmVtb3ZlT25lQ2xhc3MgZnJvbSAnZG9tLWhlbHBlcnMvcmVtb3ZlQ2xhc3MnO1xuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBUcmFuc2l0aW9uIGZyb20gJy4vVHJhbnNpdGlvbic7XG5pbXBvcnQgeyBjbGFzc05hbWVzU2hhcGUgfSBmcm9tICcuL3V0aWxzL1Byb3BUeXBlcyc7XG5cbnZhciBfYWRkQ2xhc3MgPSBmdW5jdGlvbiBhZGRDbGFzcyhub2RlLCBjbGFzc2VzKSB7XG4gIHJldHVybiBub2RlICYmIGNsYXNzZXMgJiYgY2xhc3Nlcy5zcGxpdCgnICcpLmZvckVhY2goZnVuY3Rpb24gKGMpIHtcbiAgICByZXR1cm4gYWRkT25lQ2xhc3Mobm9kZSwgYyk7XG4gIH0pO1xufTtcblxudmFyIHJlbW92ZUNsYXNzID0gZnVuY3Rpb24gcmVtb3ZlQ2xhc3Mobm9kZSwgY2xhc3Nlcykge1xuICByZXR1cm4gbm9kZSAmJiBjbGFzc2VzICYmIGNsYXNzZXMuc3BsaXQoJyAnKS5mb3JFYWNoKGZ1bmN0aW9uIChjKSB7XG4gICAgcmV0dXJuIHJlbW92ZU9uZUNsYXNzKG5vZGUsIGMpO1xuICB9KTtcbn07XG4vKipcbiAqIEEgdHJhbnNpdGlvbiBjb21wb25lbnQgaW5zcGlyZWQgYnkgdGhlIGV4Y2VsbGVudFxuICogW25nLWFuaW1hdGVdKGh0dHBzOi8vZG9jcy5hbmd1bGFyanMub3JnL2FwaS9uZ0FuaW1hdGUpIGxpYnJhcnksIHlvdSBzaG91bGRcbiAqIHVzZSBpdCBpZiB5b3UncmUgdXNpbmcgQ1NTIHRyYW5zaXRpb25zIG9yIGFuaW1hdGlvbnMuIEl0J3MgYnVpbHQgdXBvbiB0aGVcbiAqIFtgVHJhbnNpdGlvbmBdKGh0dHBzOi8vcmVhY3Rjb21tdW5pdHkub3JnL3JlYWN0LXRyYW5zaXRpb24tZ3JvdXAvdHJhbnNpdGlvbilcbiAqIGNvbXBvbmVudCwgc28gaXQgaW5oZXJpdHMgYWxsIG9mIGl0cyBwcm9wcy5cbiAqXG4gKiBgQ1NTVHJhbnNpdGlvbmAgYXBwbGllcyBhIHBhaXIgb2YgY2xhc3MgbmFtZXMgZHVyaW5nIHRoZSBgYXBwZWFyYCwgYGVudGVyYCxcbiAqIGFuZCBgZXhpdGAgc3RhdGVzIG9mIHRoZSB0cmFuc2l0aW9uLiBUaGUgZmlyc3QgY2xhc3MgaXMgYXBwbGllZCBhbmQgdGhlbiBhXG4gKiBzZWNvbmQgYCotYWN0aXZlYCBjbGFzcyBpbiBvcmRlciB0byBhY3RpdmF0ZSB0aGUgQ1NTIHRyYW5zaXRpb24uIEFmdGVyIHRoZVxuICogdHJhbnNpdGlvbiwgbWF0Y2hpbmcgYCotZG9uZWAgY2xhc3MgbmFtZXMgYXJlIGFwcGxpZWQgdG8gcGVyc2lzdCB0aGVcbiAqIHRyYW5zaXRpb24gc3RhdGUuXG4gKlxuICogYGBganN4XG4gKiBmdW5jdGlvbiBBcHAoKSB7XG4gKiAgIGNvbnN0IFtpblByb3AsIHNldEluUHJvcF0gPSB1c2VTdGF0ZShmYWxzZSk7XG4gKiAgIHJldHVybiAoXG4gKiAgICAgPGRpdj5cbiAqICAgICAgIDxDU1NUcmFuc2l0aW9uIGluPXtpblByb3B9IHRpbWVvdXQ9ezIwMH0gY2xhc3NOYW1lcz1cIm15LW5vZGVcIj5cbiAqICAgICAgICAgPGRpdj5cbiAqICAgICAgICAgICB7XCJJJ2xsIHJlY2VpdmUgbXktbm9kZS0qIGNsYXNzZXNcIn1cbiAqICAgICAgICAgPC9kaXY+XG4gKiAgICAgICA8L0NTU1RyYW5zaXRpb24+XG4gKiAgICAgICA8YnV0dG9uIHR5cGU9XCJidXR0b25cIiBvbkNsaWNrPXsoKSA9PiBzZXRJblByb3AodHJ1ZSl9PlxuICogICAgICAgICBDbGljayB0byBFbnRlclxuICogICAgICAgPC9idXR0b24+XG4gKiAgICAgPC9kaXY+XG4gKiAgICk7XG4gKiB9XG4gKiBgYGBcbiAqXG4gKiBXaGVuIHRoZSBgaW5gIHByb3AgaXMgc2V0IHRvIGB0cnVlYCwgdGhlIGNoaWxkIGNvbXBvbmVudCB3aWxsIGZpcnN0IHJlY2VpdmVcbiAqIHRoZSBjbGFzcyBgZXhhbXBsZS1lbnRlcmAsIHRoZW4gdGhlIGBleGFtcGxlLWVudGVyLWFjdGl2ZWAgd2lsbCBiZSBhZGRlZCBpblxuICogdGhlIG5leHQgdGljay4gYENTU1RyYW5zaXRpb25gIFtmb3JjZXMgYVxuICogcmVmbG93XShodHRwczovL2dpdGh1Yi5jb20vcmVhY3Rqcy9yZWFjdC10cmFuc2l0aW9uLWdyb3VwL2Jsb2IvNTAwNzMwM2U3MjlhNzRiZTY2YTIxYzNlMjIwNWU0OTE2ODIxNTI0Yi9zcmMvQ1NTVHJhbnNpdGlvbi5qcyNMMjA4LUwyMTUpXG4gKiBiZXR3ZWVuIGJlZm9yZSBhZGRpbmcgdGhlIGBleGFtcGxlLWVudGVyLWFjdGl2ZWAuIFRoaXMgaXMgYW4gaW1wb3J0YW50IHRyaWNrXG4gKiBiZWNhdXNlIGl0IGFsbG93cyB1cyB0byB0cmFuc2l0aW9uIGJldHdlZW4gYGV4YW1wbGUtZW50ZXJgIGFuZFxuICogYGV4YW1wbGUtZW50ZXItYWN0aXZlYCBldmVuIHRob3VnaCB0aGV5IHdlcmUgYWRkZWQgaW1tZWRpYXRlbHkgb25lIGFmdGVyXG4gKiBhbm90aGVyLiBNb3N0IG5vdGFibHksIHRoaXMgaXMgd2hhdCBtYWtlcyBpdCBwb3NzaWJsZSBmb3IgdXMgdG8gYW5pbWF0ZVxuICogX2FwcGVhcmFuY2VfLlxuICpcbiAqIGBgYGNzc1xuICogLm15LW5vZGUtZW50ZXIge1xuICogICBvcGFjaXR5OiAwO1xuICogfVxuICogLm15LW5vZGUtZW50ZXItYWN0aXZlIHtcbiAqICAgb3BhY2l0eTogMTtcbiAqICAgdHJhbnNpdGlvbjogb3BhY2l0eSAyMDBtcztcbiAqIH1cbiAqIC5teS1ub2RlLWV4aXQge1xuICogICBvcGFjaXR5OiAxO1xuICogfVxuICogLm15LW5vZGUtZXhpdC1hY3RpdmUge1xuICogICBvcGFjaXR5OiAwO1xuICogICB0cmFuc2l0aW9uOiBvcGFjaXR5IDIwMG1zO1xuICogfVxuICogYGBgXG4gKlxuICogYCotYWN0aXZlYCBjbGFzc2VzIHJlcHJlc2VudCB3aGljaCBzdHlsZXMgeW91IHdhbnQgdG8gYW5pbWF0ZSAqKnRvKiosIHNvIGl0J3NcbiAqIGltcG9ydGFudCB0byBhZGQgYHRyYW5zaXRpb25gIGRlY2xhcmF0aW9uIG9ubHkgdG8gdGhlbSwgb3RoZXJ3aXNlIHRyYW5zaXRpb25zXG4gKiBtaWdodCBub3QgYmVoYXZlIGFzIGludGVuZGVkISBUaGlzIG1pZ2h0IG5vdCBiZSBvYnZpb3VzIHdoZW4gdGhlIHRyYW5zaXRpb25zXG4gKiBhcmUgc3ltbWV0cmljYWwsIGkuZS4gd2hlbiBgKi1lbnRlci1hY3RpdmVgIGlzIHRoZSBzYW1lIGFzIGAqLWV4aXRgLCBsaWtlIGluXG4gKiB0aGUgZXhhbXBsZSBhYm92ZSAobWludXMgYHRyYW5zaXRpb25gKSwgYnV0IGl0IGJlY29tZXMgYXBwYXJlbnQgaW4gbW9yZVxuICogY29tcGxleCB0cmFuc2l0aW9ucy5cbiAqXG4gKiAqKk5vdGUqKjogSWYgeW91J3JlIHVzaW5nIHRoZVxuICogW2BhcHBlYXJgXShodHRwOi8vcmVhY3Rjb21tdW5pdHkub3JnL3JlYWN0LXRyYW5zaXRpb24tZ3JvdXAvdHJhbnNpdGlvbiNUcmFuc2l0aW9uLXByb3AtYXBwZWFyKVxuICogcHJvcCwgbWFrZSBzdXJlIHRvIGRlZmluZSBzdHlsZXMgZm9yIGAuYXBwZWFyLSpgIGNsYXNzZXMgYXMgd2VsbC5cbiAqL1xuXG5cbnZhciBDU1NUcmFuc2l0aW9uID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfUmVhY3QkQ29tcG9uZW50KSB7XG4gIF9pbmhlcml0c0xvb3NlKENTU1RyYW5zaXRpb24sIF9SZWFjdCRDb21wb25lbnQpO1xuXG4gIGZ1bmN0aW9uIENTU1RyYW5zaXRpb24oKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIF90aGlzID0gX1JlYWN0JENvbXBvbmVudC5jYWxsLmFwcGx5KF9SZWFjdCRDb21wb25lbnQsIFt0aGlzXS5jb25jYXQoYXJncykpIHx8IHRoaXM7XG4gICAgX3RoaXMuYXBwbGllZENsYXNzZXMgPSB7XG4gICAgICBhcHBlYXI6IHt9LFxuICAgICAgZW50ZXI6IHt9LFxuICAgICAgZXhpdDoge31cbiAgICB9O1xuXG4gICAgX3RoaXMub25FbnRlciA9IGZ1bmN0aW9uIChtYXliZU5vZGUsIG1heWJlQXBwZWFyaW5nKSB7XG4gICAgICB2YXIgX3RoaXMkcmVzb2x2ZUFyZ3VtZW50ID0gX3RoaXMucmVzb2x2ZUFyZ3VtZW50cyhtYXliZU5vZGUsIG1heWJlQXBwZWFyaW5nKSxcbiAgICAgICAgICBub2RlID0gX3RoaXMkcmVzb2x2ZUFyZ3VtZW50WzBdLFxuICAgICAgICAgIGFwcGVhcmluZyA9IF90aGlzJHJlc29sdmVBcmd1bWVudFsxXTtcblxuICAgICAgX3RoaXMucmVtb3ZlQ2xhc3Nlcyhub2RlLCAnZXhpdCcpO1xuXG4gICAgICBfdGhpcy5hZGRDbGFzcyhub2RlLCBhcHBlYXJpbmcgPyAnYXBwZWFyJyA6ICdlbnRlcicsICdiYXNlJyk7XG5cbiAgICAgIGlmIChfdGhpcy5wcm9wcy5vbkVudGVyKSB7XG4gICAgICAgIF90aGlzLnByb3BzLm9uRW50ZXIobWF5YmVOb2RlLCBtYXliZUFwcGVhcmluZyk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIF90aGlzLm9uRW50ZXJpbmcgPSBmdW5jdGlvbiAobWF5YmVOb2RlLCBtYXliZUFwcGVhcmluZykge1xuICAgICAgdmFyIF90aGlzJHJlc29sdmVBcmd1bWVudDIgPSBfdGhpcy5yZXNvbHZlQXJndW1lbnRzKG1heWJlTm9kZSwgbWF5YmVBcHBlYXJpbmcpLFxuICAgICAgICAgIG5vZGUgPSBfdGhpcyRyZXNvbHZlQXJndW1lbnQyWzBdLFxuICAgICAgICAgIGFwcGVhcmluZyA9IF90aGlzJHJlc29sdmVBcmd1bWVudDJbMV07XG5cbiAgICAgIHZhciB0eXBlID0gYXBwZWFyaW5nID8gJ2FwcGVhcicgOiAnZW50ZXInO1xuXG4gICAgICBfdGhpcy5hZGRDbGFzcyhub2RlLCB0eXBlLCAnYWN0aXZlJyk7XG5cbiAgICAgIGlmIChfdGhpcy5wcm9wcy5vbkVudGVyaW5nKSB7XG4gICAgICAgIF90aGlzLnByb3BzLm9uRW50ZXJpbmcobWF5YmVOb2RlLCBtYXliZUFwcGVhcmluZyk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIF90aGlzLm9uRW50ZXJlZCA9IGZ1bmN0aW9uIChtYXliZU5vZGUsIG1heWJlQXBwZWFyaW5nKSB7XG4gICAgICB2YXIgX3RoaXMkcmVzb2x2ZUFyZ3VtZW50MyA9IF90aGlzLnJlc29sdmVBcmd1bWVudHMobWF5YmVOb2RlLCBtYXliZUFwcGVhcmluZyksXG4gICAgICAgICAgbm9kZSA9IF90aGlzJHJlc29sdmVBcmd1bWVudDNbMF0sXG4gICAgICAgICAgYXBwZWFyaW5nID0gX3RoaXMkcmVzb2x2ZUFyZ3VtZW50M1sxXTtcblxuICAgICAgdmFyIHR5cGUgPSBhcHBlYXJpbmcgPyAnYXBwZWFyJyA6ICdlbnRlcic7XG5cbiAgICAgIF90aGlzLnJlbW92ZUNsYXNzZXMobm9kZSwgdHlwZSk7XG5cbiAgICAgIF90aGlzLmFkZENsYXNzKG5vZGUsIHR5cGUsICdkb25lJyk7XG5cbiAgICAgIGlmIChfdGhpcy5wcm9wcy5vbkVudGVyZWQpIHtcbiAgICAgICAgX3RoaXMucHJvcHMub25FbnRlcmVkKG1heWJlTm9kZSwgbWF5YmVBcHBlYXJpbmcpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBfdGhpcy5vbkV4aXQgPSBmdW5jdGlvbiAobWF5YmVOb2RlKSB7XG4gICAgICB2YXIgX3RoaXMkcmVzb2x2ZUFyZ3VtZW50NCA9IF90aGlzLnJlc29sdmVBcmd1bWVudHMobWF5YmVOb2RlKSxcbiAgICAgICAgICBub2RlID0gX3RoaXMkcmVzb2x2ZUFyZ3VtZW50NFswXTtcblxuICAgICAgX3RoaXMucmVtb3ZlQ2xhc3Nlcyhub2RlLCAnYXBwZWFyJyk7XG5cbiAgICAgIF90aGlzLnJlbW92ZUNsYXNzZXMobm9kZSwgJ2VudGVyJyk7XG5cbiAgICAgIF90aGlzLmFkZENsYXNzKG5vZGUsICdleGl0JywgJ2Jhc2UnKTtcblxuICAgICAgaWYgKF90aGlzLnByb3BzLm9uRXhpdCkge1xuICAgICAgICBfdGhpcy5wcm9wcy5vbkV4aXQobWF5YmVOb2RlKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgX3RoaXMub25FeGl0aW5nID0gZnVuY3Rpb24gKG1heWJlTm9kZSkge1xuICAgICAgdmFyIF90aGlzJHJlc29sdmVBcmd1bWVudDUgPSBfdGhpcy5yZXNvbHZlQXJndW1lbnRzKG1heWJlTm9kZSksXG4gICAgICAgICAgbm9kZSA9IF90aGlzJHJlc29sdmVBcmd1bWVudDVbMF07XG5cbiAgICAgIF90aGlzLmFkZENsYXNzKG5vZGUsICdleGl0JywgJ2FjdGl2ZScpO1xuXG4gICAgICBpZiAoX3RoaXMucHJvcHMub25FeGl0aW5nKSB7XG4gICAgICAgIF90aGlzLnByb3BzLm9uRXhpdGluZyhtYXliZU5vZGUpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBfdGhpcy5vbkV4aXRlZCA9IGZ1bmN0aW9uIChtYXliZU5vZGUpIHtcbiAgICAgIHZhciBfdGhpcyRyZXNvbHZlQXJndW1lbnQ2ID0gX3RoaXMucmVzb2x2ZUFyZ3VtZW50cyhtYXliZU5vZGUpLFxuICAgICAgICAgIG5vZGUgPSBfdGhpcyRyZXNvbHZlQXJndW1lbnQ2WzBdO1xuXG4gICAgICBfdGhpcy5yZW1vdmVDbGFzc2VzKG5vZGUsICdleGl0Jyk7XG5cbiAgICAgIF90aGlzLmFkZENsYXNzKG5vZGUsICdleGl0JywgJ2RvbmUnKTtcblxuICAgICAgaWYgKF90aGlzLnByb3BzLm9uRXhpdGVkKSB7XG4gICAgICAgIF90aGlzLnByb3BzLm9uRXhpdGVkKG1heWJlTm9kZSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIF90aGlzLnJlc29sdmVBcmd1bWVudHMgPSBmdW5jdGlvbiAobWF5YmVOb2RlLCBtYXliZUFwcGVhcmluZykge1xuICAgICAgcmV0dXJuIF90aGlzLnByb3BzLm5vZGVSZWYgPyBbX3RoaXMucHJvcHMubm9kZVJlZi5jdXJyZW50LCBtYXliZU5vZGVdIC8vIGhlcmUgYG1heWJlTm9kZWAgaXMgYWN0dWFsbHkgYGFwcGVhcmluZ2BcbiAgICAgIDogW21heWJlTm9kZSwgbWF5YmVBcHBlYXJpbmddO1xuICAgIH07XG5cbiAgICBfdGhpcy5nZXRDbGFzc05hbWVzID0gZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgIHZhciBjbGFzc05hbWVzID0gX3RoaXMucHJvcHMuY2xhc3NOYW1lcztcbiAgICAgIHZhciBpc1N0cmluZ0NsYXNzTmFtZXMgPSB0eXBlb2YgY2xhc3NOYW1lcyA9PT0gJ3N0cmluZyc7XG4gICAgICB2YXIgcHJlZml4ID0gaXNTdHJpbmdDbGFzc05hbWVzICYmIGNsYXNzTmFtZXMgPyBjbGFzc05hbWVzICsgXCItXCIgOiAnJztcbiAgICAgIHZhciBiYXNlQ2xhc3NOYW1lID0gaXNTdHJpbmdDbGFzc05hbWVzID8gXCJcIiArIHByZWZpeCArIHR5cGUgOiBjbGFzc05hbWVzW3R5cGVdO1xuICAgICAgdmFyIGFjdGl2ZUNsYXNzTmFtZSA9IGlzU3RyaW5nQ2xhc3NOYW1lcyA/IGJhc2VDbGFzc05hbWUgKyBcIi1hY3RpdmVcIiA6IGNsYXNzTmFtZXNbdHlwZSArIFwiQWN0aXZlXCJdO1xuICAgICAgdmFyIGRvbmVDbGFzc05hbWUgPSBpc1N0cmluZ0NsYXNzTmFtZXMgPyBiYXNlQ2xhc3NOYW1lICsgXCItZG9uZVwiIDogY2xhc3NOYW1lc1t0eXBlICsgXCJEb25lXCJdO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgYmFzZUNsYXNzTmFtZTogYmFzZUNsYXNzTmFtZSxcbiAgICAgICAgYWN0aXZlQ2xhc3NOYW1lOiBhY3RpdmVDbGFzc05hbWUsXG4gICAgICAgIGRvbmVDbGFzc05hbWU6IGRvbmVDbGFzc05hbWVcbiAgICAgIH07XG4gICAgfTtcblxuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBDU1NUcmFuc2l0aW9uLnByb3RvdHlwZTtcblxuICBfcHJvdG8uYWRkQ2xhc3MgPSBmdW5jdGlvbiBhZGRDbGFzcyhub2RlLCB0eXBlLCBwaGFzZSkge1xuICAgIHZhciBjbGFzc05hbWUgPSB0aGlzLmdldENsYXNzTmFtZXModHlwZSlbcGhhc2UgKyBcIkNsYXNzTmFtZVwiXTtcblxuICAgIHZhciBfdGhpcyRnZXRDbGFzc05hbWVzID0gdGhpcy5nZXRDbGFzc05hbWVzKCdlbnRlcicpLFxuICAgICAgICBkb25lQ2xhc3NOYW1lID0gX3RoaXMkZ2V0Q2xhc3NOYW1lcy5kb25lQ2xhc3NOYW1lO1xuXG4gICAgaWYgKHR5cGUgPT09ICdhcHBlYXInICYmIHBoYXNlID09PSAnZG9uZScgJiYgZG9uZUNsYXNzTmFtZSkge1xuICAgICAgY2xhc3NOYW1lICs9IFwiIFwiICsgZG9uZUNsYXNzTmFtZTtcbiAgICB9IC8vIFRoaXMgaXMgdG8gZm9yY2UgYSByZXBhaW50LFxuICAgIC8vIHdoaWNoIGlzIG5lY2Vzc2FyeSBpbiBvcmRlciB0byB0cmFuc2l0aW9uIHN0eWxlcyB3aGVuIGFkZGluZyBhIGNsYXNzIG5hbWUuXG5cblxuICAgIGlmIChwaGFzZSA9PT0gJ2FjdGl2ZScpIHtcbiAgICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC1leHByZXNzaW9ucyAqL1xuICAgICAgbm9kZSAmJiBub2RlLnNjcm9sbFRvcDtcbiAgICB9XG5cbiAgICBpZiAoY2xhc3NOYW1lKSB7XG4gICAgICB0aGlzLmFwcGxpZWRDbGFzc2VzW3R5cGVdW3BoYXNlXSA9IGNsYXNzTmFtZTtcblxuICAgICAgX2FkZENsYXNzKG5vZGUsIGNsYXNzTmFtZSk7XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5yZW1vdmVDbGFzc2VzID0gZnVuY3Rpb24gcmVtb3ZlQ2xhc3Nlcyhub2RlLCB0eXBlKSB7XG4gICAgdmFyIF90aGlzJGFwcGxpZWRDbGFzc2VzJCA9IHRoaXMuYXBwbGllZENsYXNzZXNbdHlwZV0sXG4gICAgICAgIGJhc2VDbGFzc05hbWUgPSBfdGhpcyRhcHBsaWVkQ2xhc3NlcyQuYmFzZSxcbiAgICAgICAgYWN0aXZlQ2xhc3NOYW1lID0gX3RoaXMkYXBwbGllZENsYXNzZXMkLmFjdGl2ZSxcbiAgICAgICAgZG9uZUNsYXNzTmFtZSA9IF90aGlzJGFwcGxpZWRDbGFzc2VzJC5kb25lO1xuICAgIHRoaXMuYXBwbGllZENsYXNzZXNbdHlwZV0gPSB7fTtcblxuICAgIGlmIChiYXNlQ2xhc3NOYW1lKSB7XG4gICAgICByZW1vdmVDbGFzcyhub2RlLCBiYXNlQ2xhc3NOYW1lKTtcbiAgICB9XG5cbiAgICBpZiAoYWN0aXZlQ2xhc3NOYW1lKSB7XG4gICAgICByZW1vdmVDbGFzcyhub2RlLCBhY3RpdmVDbGFzc05hbWUpO1xuICAgIH1cblxuICAgIGlmIChkb25lQ2xhc3NOYW1lKSB7XG4gICAgICByZW1vdmVDbGFzcyhub2RlLCBkb25lQ2xhc3NOYW1lKTtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICB2YXIgX3RoaXMkcHJvcHMgPSB0aGlzLnByb3BzLFxuICAgICAgICBfID0gX3RoaXMkcHJvcHMuY2xhc3NOYW1lcyxcbiAgICAgICAgcHJvcHMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShfdGhpcyRwcm9wcywgW1wiY2xhc3NOYW1lc1wiXSk7XG5cbiAgICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoVHJhbnNpdGlvbiwgX2V4dGVuZHMoe30sIHByb3BzLCB7XG4gICAgICBvbkVudGVyOiB0aGlzLm9uRW50ZXIsXG4gICAgICBvbkVudGVyZWQ6IHRoaXMub25FbnRlcmVkLFxuICAgICAgb25FbnRlcmluZzogdGhpcy5vbkVudGVyaW5nLFxuICAgICAgb25FeGl0OiB0aGlzLm9uRXhpdCxcbiAgICAgIG9uRXhpdGluZzogdGhpcy5vbkV4aXRpbmcsXG4gICAgICBvbkV4aXRlZDogdGhpcy5vbkV4aXRlZFxuICAgIH0pKTtcbiAgfTtcblxuICByZXR1cm4gQ1NTVHJhbnNpdGlvbjtcbn0oUmVhY3QuQ29tcG9uZW50KTtcblxuQ1NTVHJhbnNpdGlvbi5kZWZhdWx0UHJvcHMgPSB7XG4gIGNsYXNzTmFtZXM6ICcnXG59O1xuQ1NTVHJhbnNpdGlvbi5wcm9wVHlwZXMgPSBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBfZXh0ZW5kcyh7fSwgVHJhbnNpdGlvbi5wcm9wVHlwZXMsIHtcbiAgLyoqXG4gICAqIFRoZSBhbmltYXRpb24gY2xhc3NOYW1lcyBhcHBsaWVkIHRvIHRoZSBjb21wb25lbnQgYXMgaXQgYXBwZWFycywgZW50ZXJzLFxuICAgKiBleGl0cyBvciBoYXMgZmluaXNoZWQgdGhlIHRyYW5zaXRpb24uIEEgc2luZ2xlIG5hbWUgY2FuIGJlIHByb3ZpZGVkLCB3aGljaFxuICAgKiB3aWxsIGJlIHN1ZmZpeGVkIGZvciBlYWNoIHN0YWdlLCBlLmcuIGBjbGFzc05hbWVzPVwiZmFkZVwiYCBhcHBsaWVzOlxuICAgKlxuICAgKiAtIGBmYWRlLWFwcGVhcmAsIGBmYWRlLWFwcGVhci1hY3RpdmVgLCBgZmFkZS1hcHBlYXItZG9uZWBcbiAgICogLSBgZmFkZS1lbnRlcmAsIGBmYWRlLWVudGVyLWFjdGl2ZWAsIGBmYWRlLWVudGVyLWRvbmVgXG4gICAqIC0gYGZhZGUtZXhpdGAsIGBmYWRlLWV4aXQtYWN0aXZlYCwgYGZhZGUtZXhpdC1kb25lYFxuICAgKlxuICAgKiBBIGZldyBkZXRhaWxzIHRvIG5vdGUgYWJvdXQgaG93IHRoZXNlIGNsYXNzZXMgYXJlIGFwcGxpZWQ6XG4gICAqXG4gICAqIDEuIFRoZXkgYXJlIF9qb2luZWRfIHdpdGggdGhlIG9uZXMgdGhhdCBhcmUgYWxyZWFkeSBkZWZpbmVkIG9uIHRoZSBjaGlsZFxuICAgKiAgICBjb21wb25lbnQsIHNvIGlmIHlvdSB3YW50IHRvIGFkZCBzb21lIGJhc2Ugc3R5bGVzLCB5b3UgY2FuIHVzZVxuICAgKiAgICBgY2xhc3NOYW1lYCB3aXRob3V0IHdvcnJ5aW5nIHRoYXQgaXQgd2lsbCBiZSBvdmVycmlkZGVuLlxuICAgKlxuICAgKiAyLiBJZiB0aGUgdHJhbnNpdGlvbiBjb21wb25lbnQgbW91bnRzIHdpdGggYGluPXtmYWxzZX1gLCBubyBjbGFzc2VzIGFyZVxuICAgKiAgICBhcHBsaWVkIHlldC4gWW91IG1pZ2h0IGJlIGV4cGVjdGluZyBgKi1leGl0LWRvbmVgLCBidXQgaWYgeW91IHRoaW5rXG4gICAqICAgIGFib3V0IGl0LCBhIGNvbXBvbmVudCBjYW5ub3QgZmluaXNoIGV4aXRpbmcgaWYgaXQgaGFzbid0IGVudGVyZWQgeWV0LlxuICAgKlxuICAgKiAyLiBgZmFkZS1hcHBlYXItZG9uZWAgYW5kIGBmYWRlLWVudGVyLWRvbmVgIHdpbGwgX2JvdGhfIGJlIGFwcGxpZWQuIFRoaXNcbiAgICogICAgYWxsb3dzIHlvdSB0byBkZWZpbmUgZGlmZmVyZW50IGJlaGF2aW9yIGZvciB3aGVuIGFwcGVhcmluZyBpcyBkb25lIGFuZFxuICAgKiAgICB3aGVuIHJlZ3VsYXIgZW50ZXJpbmcgaXMgZG9uZSwgdXNpbmcgc2VsZWN0b3JzIGxpa2VcbiAgICogICAgYC5mYWRlLWVudGVyLWRvbmU6bm90KC5mYWRlLWFwcGVhci1kb25lKWAuIEZvciBleGFtcGxlLCB5b3UgY291bGQgYXBwbHlcbiAgICogICAgYW4gZXBpYyBlbnRyYW5jZSBhbmltYXRpb24gd2hlbiBlbGVtZW50IGZpcnN0IGFwcGVhcnMgaW4gdGhlIERPTSB1c2luZ1xuICAgKiAgICBbQW5pbWF0ZS5jc3NdKGh0dHBzOi8vZGFuZWRlbi5naXRodWIuaW8vYW5pbWF0ZS5jc3MvKS4gT3RoZXJ3aXNlIHlvdSBjYW5cbiAgICogICAgc2ltcGx5IHVzZSBgZmFkZS1lbnRlci1kb25lYCBmb3IgZGVmaW5pbmcgYm90aCBjYXNlcy5cbiAgICpcbiAgICogRWFjaCBpbmRpdmlkdWFsIGNsYXNzTmFtZXMgY2FuIGFsc28gYmUgc3BlY2lmaWVkIGluZGVwZW5kZW50bHkgbGlrZTpcbiAgICpcbiAgICogYGBganNcbiAgICogY2xhc3NOYW1lcz17e1xuICAgKiAgYXBwZWFyOiAnbXktYXBwZWFyJyxcbiAgICogIGFwcGVhckFjdGl2ZTogJ215LWFjdGl2ZS1hcHBlYXInLFxuICAgKiAgYXBwZWFyRG9uZTogJ215LWRvbmUtYXBwZWFyJyxcbiAgICogIGVudGVyOiAnbXktZW50ZXInLFxuICAgKiAgZW50ZXJBY3RpdmU6ICdteS1hY3RpdmUtZW50ZXInLFxuICAgKiAgZW50ZXJEb25lOiAnbXktZG9uZS1lbnRlcicsXG4gICAqICBleGl0OiAnbXktZXhpdCcsXG4gICAqICBleGl0QWN0aXZlOiAnbXktYWN0aXZlLWV4aXQnLFxuICAgKiAgZXhpdERvbmU6ICdteS1kb25lLWV4aXQnLFxuICAgKiB9fVxuICAgKiBgYGBcbiAgICpcbiAgICogSWYgeW91IHdhbnQgdG8gc2V0IHRoZXNlIGNsYXNzZXMgdXNpbmcgQ1NTIE1vZHVsZXM6XG4gICAqXG4gICAqIGBgYGpzXG4gICAqIGltcG9ydCBzdHlsZXMgZnJvbSAnLi9zdHlsZXMuY3NzJztcbiAgICogYGBgXG4gICAqXG4gICAqIHlvdSBtaWdodCB3YW50IHRvIHVzZSBjYW1lbENhc2UgaW4geW91ciBDU1MgZmlsZSwgdGhhdCB3YXkgY291bGQgc2ltcGx5XG4gICAqIHNwcmVhZCB0aGVtIGluc3RlYWQgb2YgbGlzdGluZyB0aGVtIG9uZSBieSBvbmU6XG4gICAqXG4gICAqIGBgYGpzXG4gICAqIGNsYXNzTmFtZXM9e3sgLi4uc3R5bGVzIH19XG4gICAqIGBgYFxuICAgKlxuICAgKiBAdHlwZSB7c3RyaW5nIHwge1xuICAgKiAgYXBwZWFyPzogc3RyaW5nLFxuICAgKiAgYXBwZWFyQWN0aXZlPzogc3RyaW5nLFxuICAgKiAgYXBwZWFyRG9uZT86IHN0cmluZyxcbiAgICogIGVudGVyPzogc3RyaW5nLFxuICAgKiAgZW50ZXJBY3RpdmU/OiBzdHJpbmcsXG4gICAqICBlbnRlckRvbmU/OiBzdHJpbmcsXG4gICAqICBleGl0Pzogc3RyaW5nLFxuICAgKiAgZXhpdEFjdGl2ZT86IHN0cmluZyxcbiAgICogIGV4aXREb25lPzogc3RyaW5nLFxuICAgKiB9fVxuICAgKi9cbiAgY2xhc3NOYW1lczogY2xhc3NOYW1lc1NoYXBlLFxuXG4gIC8qKlxuICAgKiBBIGA8VHJhbnNpdGlvbj5gIGNhbGxiYWNrIGZpcmVkIGltbWVkaWF0ZWx5IGFmdGVyIHRoZSAnZW50ZXInIG9yICdhcHBlYXInIGNsYXNzIGlzXG4gICAqIGFwcGxpZWQuXG4gICAqXG4gICAqICoqTm90ZSoqOiB3aGVuIGBub2RlUmVmYCBwcm9wIGlzIHBhc3NlZCwgYG5vZGVgIGlzIG5vdCBwYXNzZWQuXG4gICAqXG4gICAqIEB0eXBlIEZ1bmN0aW9uKG5vZGU6IEh0bWxFbGVtZW50LCBpc0FwcGVhcmluZzogYm9vbClcbiAgICovXG4gIG9uRW50ZXI6IFByb3BUeXBlcy5mdW5jLFxuXG4gIC8qKlxuICAgKiBBIGA8VHJhbnNpdGlvbj5gIGNhbGxiYWNrIGZpcmVkIGltbWVkaWF0ZWx5IGFmdGVyIHRoZSAnZW50ZXItYWN0aXZlJyBvclxuICAgKiAnYXBwZWFyLWFjdGl2ZScgY2xhc3MgaXMgYXBwbGllZC5cbiAgICpcbiAgICogKipOb3RlKio6IHdoZW4gYG5vZGVSZWZgIHByb3AgaXMgcGFzc2VkLCBgbm9kZWAgaXMgbm90IHBhc3NlZC5cbiAgICpcbiAgICogQHR5cGUgRnVuY3Rpb24obm9kZTogSHRtbEVsZW1lbnQsIGlzQXBwZWFyaW5nOiBib29sKVxuICAgKi9cbiAgb25FbnRlcmluZzogUHJvcFR5cGVzLmZ1bmMsXG5cbiAgLyoqXG4gICAqIEEgYDxUcmFuc2l0aW9uPmAgY2FsbGJhY2sgZmlyZWQgaW1tZWRpYXRlbHkgYWZ0ZXIgdGhlICdlbnRlcicgb3JcbiAgICogJ2FwcGVhcicgY2xhc3NlcyBhcmUgKipyZW1vdmVkKiogYW5kIHRoZSBgZG9uZWAgY2xhc3MgaXMgYWRkZWQgdG8gdGhlIERPTSBub2RlLlxuICAgKlxuICAgKiAqKk5vdGUqKjogd2hlbiBgbm9kZVJlZmAgcHJvcCBpcyBwYXNzZWQsIGBub2RlYCBpcyBub3QgcGFzc2VkLlxuICAgKlxuICAgKiBAdHlwZSBGdW5jdGlvbihub2RlOiBIdG1sRWxlbWVudCwgaXNBcHBlYXJpbmc6IGJvb2wpXG4gICAqL1xuICBvbkVudGVyZWQ6IFByb3BUeXBlcy5mdW5jLFxuXG4gIC8qKlxuICAgKiBBIGA8VHJhbnNpdGlvbj5gIGNhbGxiYWNrIGZpcmVkIGltbWVkaWF0ZWx5IGFmdGVyIHRoZSAnZXhpdCcgY2xhc3MgaXNcbiAgICogYXBwbGllZC5cbiAgICpcbiAgICogKipOb3RlKio6IHdoZW4gYG5vZGVSZWZgIHByb3AgaXMgcGFzc2VkLCBgbm9kZWAgaXMgbm90IHBhc3NlZFxuICAgKlxuICAgKiBAdHlwZSBGdW5jdGlvbihub2RlOiBIdG1sRWxlbWVudClcbiAgICovXG4gIG9uRXhpdDogUHJvcFR5cGVzLmZ1bmMsXG5cbiAgLyoqXG4gICAqIEEgYDxUcmFuc2l0aW9uPmAgY2FsbGJhY2sgZmlyZWQgaW1tZWRpYXRlbHkgYWZ0ZXIgdGhlICdleGl0LWFjdGl2ZScgaXMgYXBwbGllZC5cbiAgICpcbiAgICogKipOb3RlKio6IHdoZW4gYG5vZGVSZWZgIHByb3AgaXMgcGFzc2VkLCBgbm9kZWAgaXMgbm90IHBhc3NlZFxuICAgKlxuICAgKiBAdHlwZSBGdW5jdGlvbihub2RlOiBIdG1sRWxlbWVudClcbiAgICovXG4gIG9uRXhpdGluZzogUHJvcFR5cGVzLmZ1bmMsXG5cbiAgLyoqXG4gICAqIEEgYDxUcmFuc2l0aW9uPmAgY2FsbGJhY2sgZmlyZWQgaW1tZWRpYXRlbHkgYWZ0ZXIgdGhlICdleGl0JyBjbGFzc2VzXG4gICAqIGFyZSAqKnJlbW92ZWQqKiBhbmQgdGhlIGBleGl0LWRvbmVgIGNsYXNzIGlzIGFkZGVkIHRvIHRoZSBET00gbm9kZS5cbiAgICpcbiAgICogKipOb3RlKio6IHdoZW4gYG5vZGVSZWZgIHByb3AgaXMgcGFzc2VkLCBgbm9kZWAgaXMgbm90IHBhc3NlZFxuICAgKlxuICAgKiBAdHlwZSBGdW5jdGlvbihub2RlOiBIdG1sRWxlbWVudClcbiAgICovXG4gIG9uRXhpdGVkOiBQcm9wVHlwZXMuZnVuY1xufSkgOiB7fTtcbmV4cG9ydCBkZWZhdWx0IENTU1RyYW5zaXRpb247IiwiZXhwb3J0IGNvbnN0IG51bWJlcnMgPSB7XHJcbiAgICBCQU5ORVJfQU5JTUFUSU9OX0NMT1NFX1RJTUVfTVM6IDI1MCxcclxuICAgIEJBTk5FUl9BTklNQVRJT05fT1BFTl9USU1FX01TOiAzMDAsXHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgY3NzQ2xhc3NlcyA9IHtcclxuICAgIFJPT1Q6ICdtZGMtYmFubmVyJyxcclxuICAgIEZJWEVEOiAnbWRjLWJhbm5lci0tZml4ZWQnLFxyXG4gICAgQ0VOVEVSRUQ6ICdtZGMtYmFubmVyLS1jZW50ZXJlZCcsXHJcbiAgICBNT0JJTEVfU1RBQ0tFRDogJ21kYy1iYW5uZXItLW1vYmlsZS1zdGFja2VkJyxcclxuICAgIEFQUEVBUklORzogJ21kYy1iYW5uZXItLWFwcGVhcmluZycsXHJcbiAgICBBUFBFQVJFRDogJ21kYy1iYW5uZXItLWFwcGVhcmVkJyxcclxuICAgIE9QRU5JTkc6ICdtZGMtYmFubmVyLS1vcGVuaW5nJyxcclxuICAgIE9QRU46ICdtZGMtYmFubmVyLS1vcGVuJyxcclxuICAgIENMT1NJTkc6ICdtZGMtYmFubmVyLS1jbG9zaW5nJyxcclxuXHJcbiAgICBDT05URU5UOiAnbWRjLWJhbm5lcl9fY29udGVudCcsXHJcbiAgICBHUkFQSElDX1RFWFRfV1JBUFBFUjogJ21kYy1iYW5uZXJfX2dyYXBoaWMtdGV4dC13cmFwcGVyJyxcclxuICAgIEdSQVBISUM6ICdtZGMtYmFubmVyX19ncmFwaGljJyxcclxuICAgIElDT046ICdtZGMtYmFubmVyX19pY29uJyxcclxuICAgIFRFWFQ6ICdtZGMtYmFubmVyX190ZXh0JyxcclxuICAgIEFDVElPTlM6ICdtZGMtYmFubmVyX19hY3Rpb25zJyxcclxuICAgIFBSSU1BUllfQUNUSU9OOiAnbWRjLWJhbm5lcl9fcHJpbWFyeS1hY3Rpb24nLFxyXG4gICAgU0VDT05EQVJZX0FDVElPTjogJ21kYy1iYW5uZXJfX3NlY29uZGFyeS1hY3Rpb24nXHJcbn07IiwiaW1wb3J0IHsgZm9yd2FyZFJlZiwgdXNlUmVmLCB1c2VDYWxsYmFjaywgdXNlSW1wZXJhdGl2ZUhhbmRsZSB9IGZyb20gJ3JlYWN0JztcclxuaW1wb3J0IHsgQ1NTVHJhbnNpdGlvbiB9IGZyb20gJ3JlYWN0LXRyYW5zaXRpb24tZ3JvdXAnO1xyXG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xyXG5pbXBvcnQgY2xhc3NuYW1lcyBmcm9tICdjbGFzc25hbWVzJztcclxuXHJcbmltcG9ydCB7IENsb25lIH0gZnJvbSAnLi4vY29tcG9uZW50JztcclxuaW1wb3J0IEljb24gZnJvbSAnLi4vaWNvbic7XHJcblxyXG5pbXBvcnQgeyBudW1iZXJzLCBjc3NDbGFzc2VzIH0gZnJvbSAnLi9jb25zdGFudHMnO1xyXG5cclxuY29uc3QgQmFubmVyID0gZm9yd2FyZFJlZigoe1xyXG4gICAgdGV4dCxcclxuICAgIGljb24sXHJcbiAgICBncmFwaGljID0gaWNvbixcclxuICAgIGFjdGlvbixcclxuICAgIHByaW1hcnlBY3Rpb24gPSBhY3Rpb24sXHJcbiAgICBzZWNvbmRhcnlBY3Rpb24sXHJcbiAgICBvcGVuID0gZmFsc2UsXHJcbiAgICBmaXhlZCA9IGZhbHNlLFxyXG4gICAgY2VudGVyZWQgPSBmYWxzZSxcclxuICAgIG1vYmlsZVN0YWNrZWQgPSBmYWxzZSxcclxuXHJcbiAgICBlbGVtZW50ID0gJ2RpdicsXHJcbiAgICBjb21wb25lbnQ6IEVsZW1lbnQgPSBlbGVtZW50LFxyXG4gICAgY2xhc3NOYW1lLFxyXG4gICAgY2hpbGRyZW4gPSB0ZXh0LFxyXG4gICAgLi4ucHJvcHNcclxufSwgcmVmKSA9PiB7XHJcbiAgICBjb25zdCByb290UmVmID0gdXNlUmVmKCk7XHJcbiAgICBjb25zdCBjb250ZW50UmVmID0gdXNlUmVmKCk7XHJcblxyXG4gICAgdXNlSW1wZXJhdGl2ZUhhbmRsZShyZWYsICgpID0+IHJvb3RSZWYuY3VycmVudCk7XHJcblxyXG4gICAgY29uc3QgaGFuZGxlRW50ZXJpbmcgPSB1c2VDYWxsYmFjaygobm9kZSwgaXNBcHBlYXJpbmcpID0+IHtcclxuICAgICAgICBpZiAoIWlzQXBwZWFyaW5nKSB7XHJcbiAgICAgICAgICAgIG5vZGUuc3R5bGUuaGVpZ2h0ID0gYCR7Y29udGVudFJlZi5jdXJyZW50Lm9mZnNldEhlaWdodH1weGA7XHJcbiAgICAgICAgfVxyXG4gICAgfSwgW10pO1xyXG5cclxuICAgIGNvbnN0IGhhbmRsZUV4aXRpbmcgPSB1c2VDYWxsYmFjayhub2RlID0+IHtcclxuICAgICAgICBub2RlLnN0eWxlLmhlaWdodCA9ICcwcHgnO1xyXG4gICAgfSwgW10pO1xyXG5cclxuICAgIGNvbnN0IGNsYXNzTmFtZXMgPSBjbGFzc25hbWVzKGNzc0NsYXNzZXMuUk9PVCwge1xyXG4gICAgICAgIFtjc3NDbGFzc2VzLkZJWEVEXTogZml4ZWQsXHJcbiAgICAgICAgW2Nzc0NsYXNzZXMuQ0VOVEVSRURdOiBjZW50ZXJlZCxcclxuICAgICAgICBbY3NzQ2xhc3Nlcy5NT0JJTEVfU1RBQ0tFRF06IG1vYmlsZVN0YWNrZWRcclxuICAgIH0sIGNsYXNzTmFtZSk7XHJcblxyXG4gICAgY29uc3QgY29udGVudCA9IChcclxuICAgICAgICA8ZGl2IHJlZj17Y29udGVudFJlZn0gY2xhc3NOYW1lPXtjc3NDbGFzc2VzLkNPTlRFTlR9IHJvbGU9XCJzdGF0dXNcIj5cclxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9e2Nzc0NsYXNzZXMuR1JBUEhJQ19URVhUX1dSQVBQRVJ9PlxyXG4gICAgICAgICAgICAgICAge2dyYXBoaWMgJiZcclxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17Y3NzQ2xhc3Nlcy5HUkFQSElDfT5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPENsb25lXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21wb25lbnQ9e2dyYXBoaWN9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmYWxsYmFjaz17SWNvbn1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT17Y3NzQ2xhc3Nlcy5JQ09OfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvPlxyXG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIDxDbG9uZVxyXG4gICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudD17Y2hpbGRyZW59XHJcbiAgICAgICAgICAgICAgICAgICAgZmFsbGJhY2s9XCJkaXZcIlxyXG4gICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT17Y3NzQ2xhc3Nlcy5URVhUfVxyXG4gICAgICAgICAgICAgICAgLz5cclxuICAgICAgICAgICAgPC9kaXY+XHJcblxyXG4gICAgICAgICAgICB7cHJpbWFyeUFjdGlvbiAmJlxyXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9e2Nzc0NsYXNzZXMuQUNUSU9OU30+XHJcbiAgICAgICAgICAgICAgICAgICAge3NlY29uZGFyeUFjdGlvbiAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8Q2xvbmVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudD17c2Vjb25kYXJ5QWN0aW9ufVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPXtjc3NDbGFzc2VzLlNFQ09OREFSWV9BQ1RJT059XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8+XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICA8Q2xvbmVcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50PXtwcmltYXJ5QWN0aW9ufVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU9e2Nzc0NsYXNzZXMuUFJJTUFSWV9BQ1RJT059XHJcbiAgICAgICAgICAgICAgICAgICAgLz5cclxuICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgPC9kaXY+XHJcbiAgICApO1xyXG5cclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgPENTU1RyYW5zaXRpb25cclxuICAgICAgICAgICAgaW49e29wZW59XHJcbiAgICAgICAgICAgIGFwcGVhcj17b3Blbn1cclxuICAgICAgICAgICAgdGltZW91dD17e1xyXG4gICAgICAgICAgICAgICAgYXBwZWFyOiAwLFxyXG4gICAgICAgICAgICAgICAgZW50ZXI6IG51bWJlcnMuQkFOTkVSX0FOSU1BVElPTl9PUEVOX1RJTUVfTVMsXHJcbiAgICAgICAgICAgICAgICBleGl0OiBudW1iZXJzLkJBTk5FUl9BTklNQVRJT05fQ0xPU0VfVElNRV9NU1xyXG4gICAgICAgICAgICB9fVxyXG4gICAgICAgICAgICBjbGFzc05hbWVzPXt7XHJcbiAgICAgICAgICAgICAgICBhcHBlYXI6IGNzc0NsYXNzZXMuQVBQRUFSSU5HLFxyXG4gICAgICAgICAgICAgICAgYXBwZWFyRG9uZTogY3NzQ2xhc3Nlcy5BUFBFQVJFRCxcclxuICAgICAgICAgICAgICAgIGVudGVyOiBjc3NDbGFzc2VzLk9QRU5JTkcsXHJcbiAgICAgICAgICAgICAgICBlbnRlckFjdGl2ZTogY3NzQ2xhc3Nlcy5PUEVOLFxyXG4gICAgICAgICAgICAgICAgZW50ZXJEb25lOiBjc3NDbGFzc2VzLk9QRU4sXHJcbiAgICAgICAgICAgICAgICBleGl0OiBjc3NDbGFzc2VzLkNMT1NJTkdcclxuICAgICAgICAgICAgfX1cclxuICAgICAgICAgICAgbW91bnRPbkVudGVyXHJcbiAgICAgICAgICAgIHVubW91bnRPbkV4aXRcclxuICAgICAgICAgICAgb25FbnRlcmluZz17aGFuZGxlRW50ZXJpbmd9XHJcbiAgICAgICAgICAgIG9uRXhpdGluZz17aGFuZGxlRXhpdGluZ31cclxuICAgICAgICA+XHJcbiAgICAgICAgICAgIDxFbGVtZW50IHJlZj17cm9vdFJlZn0gY2xhc3NOYW1lPXtjbGFzc05hbWVzfSByb2xlPVwiYmFubmVyXCIgey4uLnByb3BzfT5cclxuICAgICAgICAgICAgICAgIHtjb250ZW50fVxyXG4gICAgICAgICAgICA8L0VsZW1lbnQ+XHJcbiAgICAgICAgPC9DU1NUcmFuc2l0aW9uPlxyXG4gICAgKTtcclxufSk7XHJcblxyXG5CYW5uZXIuZGlzcGxheU5hbWUgPSAnTURDQmFubmVyJztcclxuXHJcbkJhbm5lci5wcm9wVHlwZXMgPSB7XHJcbiAgICB0ZXh0OiBQcm9wVHlwZXMubm9kZS5pc1JlcXVpcmVkLFxyXG4gICAgaWNvbjogUHJvcFR5cGVzLm5vZGUsXHJcbiAgICBncmFwaGljOiBQcm9wVHlwZXMuZWxlbWVudCxcclxuICAgIGFjdGlvbjogUHJvcFR5cGVzLmVsZW1lbnQsXHJcbiAgICBwcmltYXJ5QWN0aW9uOiBQcm9wVHlwZXMuZWxlbWVudCxcclxuICAgIHNlY29uZGFyeUFjdGlvbjogUHJvcFR5cGVzLmVsZW1lbnQsXHJcbiAgICBvcGVuOiBQcm9wVHlwZXMuYm9vbCxcclxuICAgIGFwcGVhcjogUHJvcFR5cGVzLmJvb2wsXHJcbiAgICBmaXhlZDogUHJvcFR5cGVzLmJvb2wsXHJcbiAgICBjZW50ZXJlZDogUHJvcFR5cGVzLmJvb2wsXHJcbiAgICBtb2JpbGVTdGFja2VkOiBQcm9wVHlwZXMuYm9vbFxyXG59O1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgQmFubmVyOyIsImV4cG9ydCB7IGRlZmF1bHQgfSBmcm9tICcuL0Jhbm5lcic7IiwiZXhwb3J0IGNvbnN0IGNzc0NsYXNzZXMgPSB7XHJcbiAgICBST09UOiAnbWRjLWJ1dHRvbicsXHJcbiAgICBSQUlTRUQ6ICdtZGMtYnV0dG9uLS1yYWlzZWQnLFxyXG4gICAgVU5FTEVWQVRFRDogJ21kYy1idXR0b24tLXVuZWxldmF0ZWQnLFxyXG4gICAgT1VUTElORUQ6ICdtZGMtYnV0dG9uLS1vdXRsaW5lZCcsXHJcbiAgICBUT1VDSDogJ21kYy1idXR0b24tLXRvdWNoJyxcclxuICAgIElDT05fTEVBRElORzogJ21kYy1idXR0b24tLWljb24tbGVhZGluZycsXHJcbiAgICBJQ09OX1RSQUlMSU5HOiAnbWRjLWJ1dHRvbi0taWNvbi10cmFpbGluZycsXHJcblxyXG4gICAgUklQUExFOiAnbWRjLWJ1dHRvbl9fcmlwcGxlJyxcclxuICAgIElDT046ICdtZGMtYnV0dG9uX19pY29uJyxcclxuICAgIExBQkVMOiAnbWRjLWJ1dHRvbl9fbGFiZWwnLFxyXG4gICAgVE9VQ0hfRUxFTUVOVDogJ21kYy1idXR0b25fX3RvdWNoJ1xyXG59OyIsImltcG9ydCB7IGZvcndhcmRSZWYgfSBmcm9tICdyZWFjdCc7XHJcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XHJcbmltcG9ydCBjbGFzc25hbWVzIGZyb20gJ2NsYXNzbmFtZXMnO1xyXG5cclxuaW1wb3J0IHsgQ2xvbmUgfSBmcm9tICcuLi9jb21wb25lbnQnO1xyXG5pbXBvcnQgSWNvbiBmcm9tICcuLi9pY29uJztcclxuaW1wb3J0IHsgY3NzQ2xhc3NlcyB9IGZyb20gJy4vY29uc3RhbnRzJztcclxuXHJcbmNvbnN0IEJ1dHRvbiA9IGZvcndhcmRSZWYoKHtcclxuICAgIGxhYmVsLFxyXG4gICAgaWNvbixcclxuICAgIGxlYWRpbmdJY29uID0gaWNvbixcclxuICAgIHRyYWlsaW5nSWNvbixcclxuICAgIHJhaXNlZCA9IGZhbHNlLFxyXG4gICAgdW5lbGV2YXRlZCA9IGZhbHNlLFxyXG4gICAgb3V0bGluZWQgPSBmYWxzZSxcclxuICAgIHRvdWNoID0gZmFsc2UsXHJcblxyXG4gICAgZWxlbWVudCA9ICdidXR0b24nLFxyXG4gICAgY29tcG9uZW50OiBFbGVtZW50ID0gZWxlbWVudCxcclxuICAgIGNsYXNzTmFtZSxcclxuICAgIGNoaWxkcmVuID0gbGFiZWwsXHJcbiAgICAuLi5wcm9wc1xyXG59LCByZWYpID0+IHtcclxuICAgIGNvbnN0IGNsYXNzTmFtZXMgPSBjbGFzc25hbWVzKGNzc0NsYXNzZXMuUk9PVCwge1xyXG4gICAgICAgIFtjc3NDbGFzc2VzLlJBSVNFRF06IHJhaXNlZCxcclxuICAgICAgICBbY3NzQ2xhc3Nlcy5VTkVMRVZBVEVEXTogdW5lbGV2YXRlZCxcclxuICAgICAgICBbY3NzQ2xhc3Nlcy5PVVRMSU5FRF06IG91dGxpbmVkLFxyXG4gICAgICAgIFtjc3NDbGFzc2VzLlRPVUNIXTogdG91Y2gsXHJcbiAgICAgICAgW2Nzc0NsYXNzZXMuSUNPTl9MRUFESU5HXTogQm9vbGVhbihsZWFkaW5nSWNvbiksXHJcbiAgICAgICAgW2Nzc0NsYXNzZXMuSUNPTl9UUkFJTElOR106IEJvb2xlYW4odHJhaWxpbmdJY29uKVxyXG4gICAgfSwgY2xhc3NOYW1lKTtcclxuXHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAgIDxFbGVtZW50IHJlZj17cmVmfSBjbGFzc05hbWU9e2NsYXNzTmFtZXN9IHsuLi5wcm9wc30+XHJcbiAgICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT17Y3NzQ2xhc3Nlcy5SSVBQTEV9IC8+XHJcblxyXG4gICAgICAgICAgICB7dG91Y2ggJiZcclxuICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT17Y3NzQ2xhc3Nlcy5UT1VDSF9FTEVNRU5UfSAvPlxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB7bGVhZGluZ0ljb24gJiZcclxuICAgICAgICAgICAgICAgIDxDbG9uZVxyXG4gICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudD17bGVhZGluZ0ljb259XHJcbiAgICAgICAgICAgICAgICAgICAgZmFsbGJhY2s9e0ljb259XHJcbiAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPXtjc3NDbGFzc2VzLklDT059XHJcbiAgICAgICAgICAgICAgICAgICAgYXJpYS1oaWRkZW49XCJ0cnVlXCJcclxuICAgICAgICAgICAgICAgIC8+XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT17Y3NzQ2xhc3Nlcy5MQUJFTH0+e2NoaWxkcmVufTwvc3Bhbj5cclxuXHJcbiAgICAgICAgICAgIHt0cmFpbGluZ0ljb24gJiZcclxuICAgICAgICAgICAgICAgIDxDbG9uZVxyXG4gICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudD17dHJhaWxpbmdJY29ufVxyXG4gICAgICAgICAgICAgICAgICAgIGZhbGxiYWNrPXtJY29ufVxyXG4gICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT17Y3NzQ2xhc3Nlcy5JQ09OfVxyXG4gICAgICAgICAgICAgICAgICAgIGFyaWEtaGlkZGVuPVwidHJ1ZVwiXHJcbiAgICAgICAgICAgICAgICAvPlxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgPC9FbGVtZW50PlxyXG4gICAgKTtcclxufSk7XHJcblxyXG5CdXR0b24uZGlzcGxheU5hbWUgPSAnTURDQnV0dG9uJztcclxuXHJcbkJ1dHRvbi5wcm9wVHlwZXMgPSB7XHJcbiAgICBsYWJlbDogUHJvcFR5cGVzLm5vZGUsXHJcbiAgICBpY29uOiBQcm9wVHlwZXMubm9kZSxcclxuICAgIGxlYWRpbmdJY29uOiBQcm9wVHlwZXMubm9kZSxcclxuICAgIHRyYWlsaW5nSWNvbjogUHJvcFR5cGVzLm5vZGUsXHJcbiAgICByYWlzZWQ6IFByb3BUeXBlcy5ib29sLFxyXG4gICAgdW5lbGV2YXRlZDogUHJvcFR5cGVzLmJvb2wsXHJcbiAgICBvdXRsaW5lZDogUHJvcFR5cGVzLmJvb2wsXHJcbiAgICB0b3VjaDogUHJvcFR5cGVzLmJvb2xcclxufTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IEJ1dHRvbjsiLCJleHBvcnQgeyBkZWZhdWx0IH0gZnJvbSAnLi9CdXR0b24nOyIsImV4cG9ydCBjb25zdCBjc3NDbGFzc2VzID0ge1xyXG4gICAgUk9PVDogJ21kYy1jYXJkJyxcclxuICAgIE9VVExJTkVEOiAnbWRjLWNhcmQtLW91dGxpbmVkJyxcclxuXHJcbiAgICBUSVRMRTogJ21kYy1jYXJkX190aXRsZScsXHJcbiAgICBTVUJUSVRMRTogJ21kYy1jYXJkX19zdWJ0aXRsZScsXHJcbiAgICBPVkVSTElORTogJ21kYy1jYXJkX19vdmVybGluZScsXHJcblxyXG4gICAgQUNUSU9OUzogJ21kYy1jYXJkX19hY3Rpb25zJyxcclxuICAgIEFDVElPTlNfRlVMTF9CTEVFRDogJ21kYy1jYXJkX19hY3Rpb25zLS1mdWxsLWJsZWVkJyxcclxuXHJcbiAgICBBQ1RJT05fQlVUVE9OUzogJ21kYy1jYXJkX19hY3Rpb24tYnV0dG9ucycsXHJcbiAgICBBQ1RJT05fSUNPTlM6ICdtZGMtY2FyZF9fYWN0aW9uLWljb25zJyxcclxuXHJcbiAgICBBQ1RJT046ICdtZGMtY2FyZF9fYWN0aW9uJyxcclxuICAgIEFDVElPTl9CVVRUT046ICdtZGMtY2FyZF9fYWN0aW9uLS1idXR0b24nLFxyXG4gICAgQUNUSU9OX0lDT046ICdtZGMtY2FyZF9fYWN0aW9uLS1pY29uJyxcclxuXHJcbiAgICBDT05URU5UOiAnbWRjLWNhcmRfX2NvbnRlbnQnLFxyXG5cclxuICAgIEhFQURFUjogJ21kYy1jYXJkX19oZWFkZXInLFxyXG4gICAgSEVBREVSX0dSQVBISUM6ICdtZGMtY2FyZF9faGVhZGVyX19ncmFwaGljJyxcclxuICAgIEhFQURFUl9DT05URU5UOiAnbWRjLWNhcmRfX2hlYWRlcl9fY29udGVudCcsXHJcbiAgICBIRUFERVJfQUNUSU9OUzogJ21kYy1jYXJkX19oZWFkZXJfX2FjdGlvbnMnLFxyXG5cclxuICAgIE1FRElBOiAnbWRjLWNhcmRfX21lZGlhJyxcclxuICAgIE1FRElBX1NRVUFSRTogJ21kYy1jYXJkX19tZWRpYS0tc3F1YXJlJyxcclxuICAgIE1FRElBX1dJREU6ICdtZGMtY2FyZF9fbWVkaWEtLTE2LTknLFxyXG4gICAgTUVESUFfQ09OVEVOVDogJ21kYy1jYXJkX19tZWRpYS1jb250ZW50JyxcclxuXHJcbiAgICBQUklNQVJZX0FDVElPTjogJ21kYy1jYXJkX19wcmltYXJ5LWFjdGlvbicsXHJcblxyXG4gICAgU0VDVElPTjogJ21kYy1jYXJkX19zZWN0aW9uJyxcclxuICAgIFNFQ1RJT05fUFJJTUFSWTogJ21kYy1jYXJkX19zZWN0aW9uLS1wcmltYXJ5JyxcclxuICAgIFNFQ1RJT05fU0VDT05EQVJZOiAnbWRjLWNhcmRfX3NlY3Rpb24tLXNlY29uZGFyeScsXHJcblxyXG4gICAgUklQUExFOiAnbWRjLWNhcmRfX3JpcHBsZSdcclxufTsiLCJpbXBvcnQgeyBmb3J3YXJkUmVmIH0gZnJvbSAncmVhY3QnO1xyXG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xyXG5pbXBvcnQgY2xhc3NuYW1lcyBmcm9tICdjbGFzc25hbWVzJztcclxuXHJcbmltcG9ydCB7IGNzc0NsYXNzZXMgfSBmcm9tICcuL2NvbnN0YW50cyc7XHJcblxyXG5jb25zdCBDYXJkID0gZm9yd2FyZFJlZigoe1xyXG4gICAgb3V0bGluZWQgPSBmYWxzZSxcclxuXHJcbiAgICBlbGVtZW50ID0gJ2RpdicsXHJcbiAgICBjb21wb25lbnQ6IEVsZW1lbnQgPSBlbGVtZW50LFxyXG4gICAgY2xhc3NOYW1lLFxyXG4gICAgLi4ucHJvcHNcclxufSwgcmVmKSA9PiB7XHJcbiAgICBjb25zdCBjbGFzc05hbWVzID0gY2xhc3NuYW1lcyhjc3NDbGFzc2VzLlJPT1QsIHtcclxuICAgICAgICBbY3NzQ2xhc3Nlcy5PVVRMSU5FRF06IG91dGxpbmVkXHJcbiAgICB9LCBjbGFzc05hbWUpO1xyXG5cclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgPEVsZW1lbnQgcmVmPXtyZWZ9IGNsYXNzTmFtZT17Y2xhc3NOYW1lc30gey4uLnByb3BzfSAvPlxyXG4gICAgKTtcclxufSk7XHJcblxyXG5DYXJkLmRpc3BsYXlOYW1lID0gJ01EQ0NhcmQnO1xyXG5cclxuQ2FyZC5wcm9wVHlwZXMgPSB7XHJcbiAgICBvdXRsaW5lZDogUHJvcFR5cGVzLmJvb2xcclxufTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IENhcmQ7IiwiaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcclxuaW1wb3J0IGNsYXNzbmFtZXMgZnJvbSAnY2xhc3NuYW1lcyc7XHJcblxyXG5pbXBvcnQgeyBDbG9uZSB9IGZyb20gJy4uL2NvbXBvbmVudCc7XHJcblxyXG5pbXBvcnQgeyBjc3NDbGFzc2VzIH0gZnJvbSAnLi9jb25zdGFudHMnO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gQ2FyZEFjdGlvbih7XHJcbiAgICBidXR0b24gPSBmYWxzZSxcclxuICAgIGljb24gPSBmYWxzZSxcclxuXHJcbiAgICBjb21wb25lbnQsXHJcbiAgICBjbGFzc05hbWUsXHJcbiAgICBjaGlsZHJlbiA9IGNvbXBvbmVudCxcclxuICAgIC4uLnByb3BzXHJcbn0pIHtcclxuICAgIGNvbnN0IGNsYXNzTmFtZXMgPSBjbGFzc25hbWVzKGNzc0NsYXNzZXMuQUNUSU9OLCB7XHJcbiAgICAgICAgW2Nzc0NsYXNzZXMuQUNUSU9OX0JVVFRPTl06IGJ1dHRvbixcclxuICAgICAgICBbY3NzQ2xhc3Nlcy5BQ1RJT05fSUNPTl06IGljb25cclxuICAgIH0sIGNsYXNzTmFtZSk7XHJcblxyXG4gICAgcmV0dXJuIChcclxuICAgICAgICA8Q2xvbmVcclxuICAgICAgICAgICAgY29tcG9uZW50PXtjaGlsZHJlbn1cclxuICAgICAgICAgICAgY2xhc3NOYW1lPXtjbGFzc05hbWVzfVxyXG4gICAgICAgICAgICB7Li4ucHJvcHN9XHJcbiAgICAgICAgLz5cclxuICAgICk7XHJcbn1cclxuXHJcbkNhcmRBY3Rpb24uZGlzcGxheU5hbWUgPSAnTURDQ2FyZEFjdGlvbic7XHJcblxyXG5DYXJkQWN0aW9uLnByb3BUeXBlcyA9IHtcclxuICAgIGJ1dHRvbjogUHJvcFR5cGVzLmJvb2wsXHJcbiAgICBpY29uOiBQcm9wVHlwZXMuYm9vbFxyXG59OyIsImltcG9ydCB7IGZvcndhcmRSZWYgfSBmcm9tICdyZWFjdCc7XHJcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XHJcbmltcG9ydCBjbGFzc25hbWVzIGZyb20gJ2NsYXNzbmFtZXMnO1xyXG5cclxuaW1wb3J0IHsgY3NzQ2xhc3NlcyB9IGZyb20gJy4vY29uc3RhbnRzJztcclxuXHJcbmNvbnN0IENhcmRBY3Rpb25zID0gZm9yd2FyZFJlZigoe1xyXG4gICAgZnVsbEJsZWVkID0gZmFsc2UsXHJcblxyXG4gICAgZWxlbWVudDogRWxlbWVudCA9ICdkaXYnLFxyXG4gICAgY2xhc3NOYW1lLFxyXG4gICAgLi4ucHJvcHNcclxufSwgcmVmKSA9PiB7XHJcbiAgICBjb25zdCBjbGFzc05hbWVzID0gY2xhc3NuYW1lcyhjc3NDbGFzc2VzLkFDVElPTlMsIHtcclxuICAgICAgICBbY3NzQ2xhc3Nlcy5BQ1RJT05TX0ZVTExfQkxFRURdOiBmdWxsQmxlZWRcclxuICAgIH0sIGNsYXNzTmFtZSk7XHJcblxyXG4gICAgcmV0dXJuIChcclxuICAgICAgICA8RWxlbWVudCByZWY9e3JlZn0gY2xhc3NOYW1lPXtjbGFzc05hbWVzfSB7Li4ucHJvcHN9IC8+XHJcbiAgICApO1xyXG59KTtcclxuXHJcbkNhcmRBY3Rpb25zLmRpc3BsYXlOYW1lID0gJ01EQ0NhcmRBY3Rpb25zJztcclxuXHJcbkNhcmRBY3Rpb25zLnByb3BUeXBlcyA9IHtcclxuICAgIGZ1bGxCbGVlZDogUHJvcFR5cGVzLmJvb2xcclxufTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IENhcmRBY3Rpb25zOyIsImltcG9ydCB7IGZvcndhcmRSZWYgfSBmcm9tICdyZWFjdCc7XHJcbmltcG9ydCBjbGFzc25hbWVzIGZyb20gJ2NsYXNzbmFtZXMnO1xyXG5cclxuaW1wb3J0IHsgQ2xvbmUgfSBmcm9tICcuLi9jb21wb25lbnQnO1xyXG5cclxuaW1wb3J0IHsgY3NzQ2xhc3NlcyB9IGZyb20gJy4vY29uc3RhbnRzJztcclxuXHJcbmNvbnN0IENhcmRBY3Rpb25CdXR0b25zID0gZm9yd2FyZFJlZigoe1xyXG4gICAgZWxlbWVudCA9ICdkaXYnLFxyXG4gICAgY29tcG9uZW50OiBFbGVtZW50ID0gZWxlbWVudCxcclxuICAgIGNsYXNzTmFtZSxcclxuICAgIGNoaWxkcmVuLFxyXG4gICAgLi4ucHJvcHNcclxufSwgcmVmKSA9PiB7XHJcbiAgICBjb25zdCBjbGFzc05hbWVzID0gY2xhc3NuYW1lcyhjc3NDbGFzc2VzLkFDVElPTl9CVVRUT05TLCBjbGFzc05hbWUpO1xyXG5cclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgPEVsZW1lbnQgcmVmPXtyZWZ9IGNsYXNzTmFtZT17Y2xhc3NOYW1lc30gey4uLnByb3BzfT5cclxuICAgICAgICAgICAgPENsb25lXHJcbiAgICAgICAgICAgICAgICBjb21wb25lbnQ9e2NoaWxkcmVufVxyXG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lPXtgJHtjc3NDbGFzc2VzLkFDVElPTn0gJHtjc3NDbGFzc2VzLkFDVElPTl9CVVRUT059YH1cclxuICAgICAgICAgICAgLz5cclxuICAgICAgICA8L0VsZW1lbnQ+XHJcbiAgICApO1xyXG59KTtcclxuXHJcbkNhcmRBY3Rpb25CdXR0b25zLmRpc3BsYXlOYW1lID0gJ01EQ0NhcmRBY3Rpb25CdXR0b25zJztcclxuXHJcbmV4cG9ydCBkZWZhdWx0IENhcmRBY3Rpb25CdXR0b25zOyIsImltcG9ydCB7IGZvcndhcmRSZWYgfSBmcm9tICdyZWFjdCc7XHJcbmltcG9ydCBjbGFzc25hbWVzIGZyb20gJ2NsYXNzbmFtZXMnO1xyXG5cclxuaW1wb3J0IHsgQ2xvbmUgfSBmcm9tICcuLi9jb21wb25lbnQnO1xyXG5cclxuaW1wb3J0IHsgY3NzQ2xhc3NlcyB9IGZyb20gJy4vY29uc3RhbnRzJztcclxuXHJcbmNvbnN0IENhcmRBY3Rpb25JY29ucyA9IGZvcndhcmRSZWYoKHtcclxuICAgIGVsZW1lbnQgPSAnZGl2JyxcclxuICAgIGNvbXBvbmVudDogRWxlbWVudCA9IGVsZW1lbnQsXHJcbiAgICBjbGFzc05hbWUsXHJcbiAgICBjaGlsZHJlbixcclxuICAgIC4uLnByb3BzXHJcbn0sIHJlZikgPT4ge1xyXG4gICAgY29uc3QgY2xhc3NOYW1lcyA9IGNsYXNzbmFtZXMoY3NzQ2xhc3Nlcy5BQ1RJT05fSUNPTlMsIGNsYXNzTmFtZSk7XHJcblxyXG4gICAgcmV0dXJuIChcclxuICAgICAgICA8RWxlbWVudCByZWY9e3JlZn0gY2xhc3NOYW1lPXtjbGFzc05hbWVzfSB7Li4ucHJvcHN9PlxyXG4gICAgICAgICAgICA8Q2xvbmVcclxuICAgICAgICAgICAgICAgIGNvbXBvbmVudD17Y2hpbGRyZW59XHJcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU9e2Ake2Nzc0NsYXNzZXMuQUNUSU9OfSAke2Nzc0NsYXNzZXMuQUNUSU9OX0lDT059YH1cclxuICAgICAgICAgICAgLz5cclxuICAgICAgICA8L0VsZW1lbnQ+XHJcbiAgICApO1xyXG59KTtcclxuXHJcbkNhcmRBY3Rpb25JY29ucy5kaXNwbGF5TmFtZSA9ICdNRENDYXJkQWN0aW9uSWNvbnMnO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgQ2FyZEFjdGlvbkljb25zOyIsImltcG9ydCB7IENoaWxkcmVuLCBmb3J3YXJkUmVmIH0gZnJvbSAncmVhY3QnO1xyXG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xyXG5pbXBvcnQgY2xhc3NuYW1lcyBmcm9tICdjbGFzc25hbWVzJztcclxuXHJcbmltcG9ydCB7IENsb25lIH0gZnJvbSAnLi4vY29tcG9uZW50JztcclxuXHJcbmltcG9ydCB7IGNzc0NsYXNzZXMgfSBmcm9tICcuL2NvbnN0YW50cyc7XHJcblxyXG5jb25zdCBDYXJkSGVhZGVyID0gZm9yd2FyZFJlZigoe1xyXG4gICAgdGl0bGUsXHJcbiAgICBzdWJ0aXRsZSxcclxuICAgIG92ZXJsaW5lLFxyXG4gICAgZ3JhcGhpYyxcclxuICAgIGFjdGlvbnMsXHJcblxyXG4gICAgZWxlbWVudCA9ICdkaXYnLFxyXG4gICAgY29tcG9uZW50OiBFbGVtZW50ID0gZWxlbWVudCxcclxuICAgIGNsYXNzTmFtZSxcclxuICAgIGNoaWxkcmVuLFxyXG4gICAgLi4ucHJvcHNcclxufSwgcmVmKSA9PiB7XHJcbiAgICBjb25zdCBjbGFzc05hbWVzID0gY2xhc3NuYW1lcyhjc3NDbGFzc2VzLkhFQURFUiwgY2xhc3NOYW1lKTtcclxuXHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAgIDxFbGVtZW50IHJlZj17cmVmfSBjbGFzc05hbWU9e2NsYXNzTmFtZXN9IHsuLi5wcm9wc30+XHJcbiAgICAgICAgICAgIHtncmFwaGljICYmXHJcbiAgICAgICAgICAgICAgICA8Q2xvbmVcclxuICAgICAgICAgICAgICAgICAgICBjb21wb25lbnQ9e2dyYXBoaWN9XHJcbiAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPXtjc3NDbGFzc2VzLkhFQURFUl9HUkFQSElDfVxyXG4gICAgICAgICAgICAgICAgLz5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9e2Nzc0NsYXNzZXMuSEVBREVSX0NPTlRFTlR9PlxyXG4gICAgICAgICAgICAgICAge292ZXJsaW5lICYmXHJcbiAgICAgICAgICAgICAgICAgICAgPENsb25lXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudD17b3ZlcmxpbmV9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZhbGxiYWNrPVwic3BhblwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT17Y3NzQ2xhc3Nlcy5PVkVSTElORX1cclxuICAgICAgICAgICAgICAgICAgICAvPlxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHt0aXRsZSAmJlxyXG4gICAgICAgICAgICAgICAgICAgIDxDbG9uZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb21wb25lbnQ9e3RpdGxlfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmYWxsYmFjaz1cImgyXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPXtjc3NDbGFzc2VzLlRJVExFfVxyXG4gICAgICAgICAgICAgICAgICAgIC8+XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAge3N1YnRpdGxlICYmXHJcbiAgICAgICAgICAgICAgICAgICAgPENsb25lXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudD17c3VidGl0bGV9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZhbGxiYWNrPVwiaDNcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU9e2Nzc0NsYXNzZXMuU1VCVElUTEV9XHJcbiAgICAgICAgICAgICAgICAgICAgLz5cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICB7Y2hpbGRyZW59XHJcbiAgICAgICAgICAgIDwvZGl2PlxyXG5cclxuICAgICAgICAgICAge2FjdGlvbnMgJiZcclxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXtjc3NDbGFzc2VzLkhFQURFUl9BQ1RJT05TfT5cclxuICAgICAgICAgICAgICAgICAgICB7Q2hpbGRyZW4ubWFwKGFjdGlvbnMsIGFjdGlvbiA9PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8Q2xvbmVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudD17YWN0aW9ufVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPXtjc3NDbGFzc2VzLkFDVElPTn1cclxuICAgICAgICAgICAgICAgICAgICAgICAgLz5cclxuICAgICAgICAgICAgICAgICAgICApfVxyXG4gICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICA8L0VsZW1lbnQ+XHJcbiAgICApO1xyXG59KTtcclxuXHJcbkNhcmRIZWFkZXIuZGlzcGxheU5hbWUgPSAnTURDQ2FyZEhlYWRlcic7XHJcblxyXG5DYXJkSGVhZGVyLnByb3BUeXBlcyA9IHtcclxuICAgIHRpdGxlOiBQcm9wVHlwZXMubm9kZSxcclxuICAgIHN1YnRpdGxlOiBQcm9wVHlwZXMubm9kZSxcclxuICAgIG92ZXJsaW5lOiBQcm9wVHlwZXMubm9kZSxcclxuICAgIGdyYXBoaWM6IFByb3BUeXBlcy5lbGVtZW50LFxyXG4gICAgYWN0aW9uczogUHJvcFR5cGVzLm9uZU9mVHlwZShbXHJcbiAgICAgICAgUHJvcFR5cGVzLmVsZW1lbnQsXHJcbiAgICAgICAgUHJvcFR5cGVzLmFycmF5T2YoUHJvcFR5cGVzLmVsZW1lbnQpXHJcbiAgICBdKVxyXG59O1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgQ2FyZEhlYWRlcjsiLCJpbXBvcnQgeyBmb3J3YXJkUmVmIH0gZnJvbSAncmVhY3QnO1xyXG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xyXG5pbXBvcnQgY2xhc3NuYW1lcyBmcm9tICdjbGFzc25hbWVzJztcclxuXHJcbmltcG9ydCB7IGNzc0NsYXNzZXMgfSBmcm9tICcuL2NvbnN0YW50cyc7XHJcblxyXG5jb25zdCBDYXJkTWVkaWEgPSBmb3J3YXJkUmVmKCh7XHJcbiAgICBpbWFnZVVybCxcclxuICAgIGNvbnRlbnQsXHJcbiAgICBzcXVhcmUgPSBmYWxzZSxcclxuICAgIHdpZGUgPSBmYWxzZSxcclxuXHJcbiAgICBlbGVtZW50ID0gJ2RpdicsXHJcbiAgICBjb21wb25lbnQ6IEVsZW1lbnQgPSBlbGVtZW50LFxyXG4gICAgY2xhc3NOYW1lLFxyXG4gICAgY2hpbGRyZW4gPSBjb250ZW50LFxyXG4gICAgLi4ucHJvcHNcclxufSwgcmVmKSA9PiB7XHJcbiAgICBjb25zdCBjbGFzc05hbWVzID0gY2xhc3NuYW1lcyhjc3NDbGFzc2VzLk1FRElBLCB7XHJcbiAgICAgICAgW2Nzc0NsYXNzZXMuTUVESUFfU1FVQVJFXTogc3F1YXJlLFxyXG4gICAgICAgIFtjc3NDbGFzc2VzLk1FRElBX1dJREVdOiB3aWRlLFxyXG4gICAgfSwgY2xhc3NOYW1lKTtcclxuXHJcbiAgICBjb25zdCBzdHlsZSA9IGltYWdlVXJsID8ge1xyXG4gICAgICAgIGJhY2tncm91bmRJbWFnZTogYHVybCgke2ltYWdlVXJsfSlgXHJcbiAgICB9IDogdW5kZWZpbmVkO1xyXG5cclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgPEVsZW1lbnQgcmVmPXtyZWZ9IGNsYXNzTmFtZT17Y2xhc3NOYW1lc30gc3R5bGU9e3N0eWxlfSB7Li4ucHJvcHN9PlxyXG4gICAgICAgICAgICB7Y2hpbGRyZW4gJiZcclxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXtjc3NDbGFzc2VzLk1FRElBX0NPTlRFTlR9PntjaGlsZHJlbn08L2Rpdj5cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIDwvRWxlbWVudD5cclxuICAgICk7XHJcbn0pO1xyXG5cclxuQ2FyZE1lZGlhLmRpc3BsYXlOYW1lID0gJ01EQ0NhcmRNZWRpYSc7XHJcblxyXG5DYXJkTWVkaWEucHJvcFR5cGVzID0ge1xyXG4gICAgaW1hZ2VVcmw6IFByb3BUeXBlcy5zdHJpbmcsXHJcbiAgICBjb250ZW50OiBQcm9wVHlwZXMubm9kZSxcclxuICAgIHNxdWFyZTogUHJvcFR5cGVzLmJvb2wsXHJcbiAgICB3aWRlOiBQcm9wVHlwZXMuYm9vbFxyXG59O1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgQ2FyZE1lZGlhOyIsImltcG9ydCB7IGZvcndhcmRSZWYgfSBmcm9tICdyZWFjdCc7XHJcbmltcG9ydCBjbGFzc25hbWVzIGZyb20gJ2NsYXNzbmFtZXMnO1xyXG5cclxuaW1wb3J0IHsgY3NzQ2xhc3NlcyB9IGZyb20gJy4vY29uc3RhbnRzJztcclxuXHJcbmNvbnN0IENhcmRQcmltYXJ5QWN0aW9uID0gZm9yd2FyZFJlZigoe1xyXG4gICAgZWxlbWVudCA9ICdkaXYnLFxyXG4gICAgY29tcG9uZW50OiBFbGVtZW50ID0gZWxlbWVudCxcclxuICAgIGNsYXNzTmFtZSxcclxuICAgIGNoaWxkcmVuLFxyXG4gICAgLi4ucHJvcHNcclxufSwgcmVmKSA9PiB7XHJcbiAgICBjb25zdCBjbGFzc05hbWVzID0gY2xhc3NuYW1lcyhjc3NDbGFzc2VzLlBSSU1BUllfQUNUSU9OLCBjbGFzc05hbWUpO1xyXG5cclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgPEVsZW1lbnQgcmVmPXtyZWZ9IGNsYXNzTmFtZT17Y2xhc3NOYW1lc30gdGFiSW5kZXg9XCIwXCIgey4uLnByb3BzfT5cclxuICAgICAgICAgICAge2NoaWxkcmVufVxyXG5cclxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9e2Nzc0NsYXNzZXMuUklQUExFfSAvPlxyXG4gICAgICAgIDwvRWxlbWVudD5cclxuICAgICk7XHJcbn0pO1xyXG5cclxuQ2FyZFByaW1hcnlBY3Rpb24uZGlzcGxheU5hbWUgPSAnTURDQ2FyZFByaW1hcnlBY3Rpb24nO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgQ2FyZFByaW1hcnlBY3Rpb247IiwiaW1wb3J0IHsgZm9yd2FyZFJlZiB9IGZyb20gJ3JlYWN0JztcclxuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcclxuaW1wb3J0IGNsYXNzbmFtZXMgZnJvbSAnY2xhc3NuYW1lcyc7XHJcblxyXG5pbXBvcnQgeyBjc3NDbGFzc2VzIH0gZnJvbSAnLi9jb25zdGFudHMnO1xyXG5cclxuY29uc3QgQ2FyZFNlY3Rpb24gPSBmb3J3YXJkUmVmKCh7XHJcbiAgICBwcmltYXJ5ID0gZmFsc2UsXHJcbiAgICBzZWNvbmRhcnkgPSBmYWxzZSxcclxuXHJcbiAgICBlbGVtZW50ID0gJ2RpdicsXHJcbiAgICBjb21wb25lbnQ6IEVsZW1lbnQgPSBlbGVtZW50LFxyXG4gICAgY2xhc3NOYW1lLFxyXG4gICAgLi4ucHJvcHNcclxufSwgcmVmKSA9PiB7XHJcbiAgICBjb25zdCBjbGFzc05hbWVzID0gY2xhc3NuYW1lcyhjc3NDbGFzc2VzLlNFQ1RJT04sIHtcclxuICAgICAgICBbY3NzQ2xhc3Nlcy5TRUNUSU9OX1BSSU1BUlldOiBwcmltYXJ5LFxyXG4gICAgICAgIFtjc3NDbGFzc2VzLlNFQ1RJT05fU0VDT05EQVJZXTogc2Vjb25kYXJ5LFxyXG4gICAgfSwgY2xhc3NOYW1lKTtcclxuXHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAgIDxFbGVtZW50IHJlZj17cmVmfSBjbGFzc05hbWU9e2NsYXNzTmFtZXN9IHsuLi5wcm9wc30gLz5cclxuICAgICk7XHJcbn0pO1xyXG5cclxuQ2FyZFNlY3Rpb24uZGlzcGxheU5hbWUgPSAnTURDQ2FyZFNlY3Rpb24nO1xyXG5cclxuQ2FyZFNlY3Rpb24ucHJvcFR5cGVzID0ge1xyXG4gICAgcHJpbWFyeTogUHJvcFR5cGVzLmJvb2wsXHJcbiAgICBzZWNvbmRhcnk6IFByb3BUeXBlcy5ib29sXHJcbn07XHJcblxyXG5leHBvcnQgZGVmYXVsdCBDYXJkU2VjdGlvbjsiLCJpbXBvcnQgQ2FyZCBmcm9tICcuL0NhcmQnO1xyXG5pbXBvcnQgQ2FyZEFjdGlvbiBmcm9tICcuL0NhcmRBY3Rpb24nO1xyXG5pbXBvcnQgQ2FyZEFjdGlvbnMgZnJvbSAnLi9DYXJkQWN0aW9ucyc7XHJcbmltcG9ydCBDYXJkQWN0aW9uQnV0dG9ucyBmcm9tICcuL0NhcmRBY3Rpb25CdXR0b25zJztcclxuaW1wb3J0IENhcmRBY3Rpb25JY29ucyBmcm9tICcuL0NhcmRBY3Rpb25JY29ucyc7XHJcbmltcG9ydCBDYXJkSGVhZGVyIGZyb20gJy4vQ2FyZEhlYWRlcic7XHJcbmltcG9ydCBDYXJkTWVkaWEgZnJvbSAnLi9DYXJkTWVkaWEnO1xyXG5pbXBvcnQgQ2FyZFByaW1hcnlBY3Rpb24gZnJvbSAnLi9DYXJkUHJpbWFyeUFjdGlvbic7XHJcbmltcG9ydCBDYXJkU2VjdGlvbiBmcm9tICcuL0NhcmRTZWN0aW9uJztcclxuXHJcbkNhcmQuQWN0aW9uID0gQ2FyZEFjdGlvbjtcclxuQ2FyZC5BY3Rpb25zID0gQ2FyZEFjdGlvbnM7XHJcbkNhcmQuQWN0aW9uQnV0dG9ucyA9IENhcmRBY3Rpb25CdXR0b25zO1xyXG5DYXJkLkFjdGlvbkljb25zID0gQ2FyZEFjdGlvbkljb25zO1xyXG5DYXJkLkhlYWRlciA9IENhcmRIZWFkZXI7XHJcbkNhcmQuTWVkaWEgPSBDYXJkTWVkaWE7XHJcbkNhcmQuUHJpbWFyeUFjdGlvbiA9IENhcmRQcmltYXJ5QWN0aW9uO1xyXG5DYXJkLlNlY3Rpb24gPSBDYXJkU2VjdGlvbjtcclxuXHJcbmV4cG9ydCB7XHJcbiAgICBDYXJkIGFzIGRlZmF1bHQsXHJcbiAgICBDYXJkQWN0aW9uLFxyXG4gICAgQ2FyZEFjdGlvbnMsXHJcbiAgICBDYXJkQWN0aW9uQnV0dG9ucyxcclxuICAgIENhcmRBY3Rpb25JY29ucyxcclxuICAgIENhcmRIZWFkZXIsXHJcbiAgICBDYXJkTWVkaWEsXHJcbiAgICBDYXJkUHJpbWFyeUFjdGlvbixcclxuICAgIENhcmRTZWN0aW9uXHJcbn07IiwiZXhwb3J0IGNvbnN0IGNzc0NsYXNzZXMgPSB7XHJcbiAgICBST09UOiAnbWRjLWNoZWNrYm94JyxcclxuICAgIFNFTEVDVEVEOiAnbWRjLWNoZWNrYm94LS1zZWxlY3RlZCcsXHJcbiAgICBUT1VDSDogJ21kYy1jaGVja2JveC0tdG91Y2gnLFxyXG4gICAgRElTQUJMRUQ6ICdtZGMtY2hlY2tib3gtLWRpc2FibGVkJyxcclxuICAgIEFOSU1fQ0hFQ0tFRF9JTkRFVEVSTUlOQVRFOiAnbWRjLWNoZWNrYm94LS1hbmltLWNoZWNrZWQtaW5kZXRlcm1pbmF0ZScsXHJcbiAgICBBTklNX0NIRUNLRURfVU5DSEVDS0VEOiAnbWRjLWNoZWNrYm94LS1hbmltLWNoZWNrZWQtdW5jaGVja2VkJyxcclxuICAgIEFOSU1fSU5ERVRFUk1JTkFURV9DSEVDS0VEOiAnbWRjLWNoZWNrYm94LS1hbmltLWluZGV0ZXJtaW5hdGUtY2hlY2tlZCcsXHJcbiAgICBBTklNX0lOREVURVJNSU5BVEVfVU5DSEVDS0VEOiAnbWRjLWNoZWNrYm94LS1hbmltLWluZGV0ZXJtaW5hdGUtdW5jaGVja2VkJyxcclxuICAgIEFOSU1fVU5DSEVDS0VEX0NIRUNLRUQ6ICdtZGMtY2hlY2tib3gtLWFuaW0tdW5jaGVja2VkLWNoZWNrZWQnLFxyXG4gICAgQU5JTV9VTkNIRUNLRURfSU5ERVRFUk1JTkFURTogJ21kYy1jaGVja2JveC0tYW5pbS11bmNoZWNrZWQtaW5kZXRlcm1pbmF0ZScsXHJcblxyXG4gICAgTkFUSVZFX0NPTlRST0w6ICdtZGMtY2hlY2tib3hfX25hdGl2ZS1jb250cm9sJyxcclxuICAgIEJBQ0tHUk9VTkQ6ICdtZGMtY2hlY2tib3hfX2JhY2tncm91bmQnLFxyXG4gICAgQ0hFQ0tNQVJLOiAnbWRjLWNoZWNrYm94X19jaGVja21hcmsnLFxyXG4gICAgQ0hFQ0tNQVJLX1BBVEg6ICdtZGMtY2hlY2tib3hfX2NoZWNrbWFyay1wYXRoJyxcclxuICAgIE1JWEVETUFSSzogJ21kYy1jaGVja2JveF9fbWl4ZWRtYXJrJyxcclxuICAgIFJJUFBMRTogJ21kYy1jaGVja2JveF9fcmlwcGxlJ1xyXG59OyIsImltcG9ydCB7IGZvcndhcmRSZWYsIHVzZVJlZiwgdXNlRWZmZWN0LCB1c2VDYWxsYmFjayB9IGZyb20gJ3JlYWN0JztcclxuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcclxuaW1wb3J0IGNsYXNzbmFtZXMgZnJvbSAnY2xhc3NuYW1lcyc7XHJcblxyXG5pbXBvcnQgeyBjc3NDbGFzc2VzIH0gZnJvbSAnLi9jb25zdGFudHMnO1xyXG5cclxuY29uc3QgQ2hlY2tib3ggPSBmb3J3YXJkUmVmKCh7XHJcbiAgICBjaGVja2VkLFxyXG4gICAgaW5kZXRlcm1pbmF0ZSxcclxuICAgIGRpc2FibGVkID0gZmFsc2UsXHJcbiAgICB0b3VjaCA9IGZhbHNlLFxyXG4gICAgb25DaGFuZ2UgPSBGdW5jdGlvbi5wcm90b3R5cGUsXHJcblxyXG4gICAgY2xhc3NOYW1lLFxyXG4gICAgLi4ucHJvcHNcclxufSwgcmVmKSA9PiB7XHJcbiAgICBjb25zdCBpbnB1dFJlZiA9IHVzZVJlZigpO1xyXG5cclxuICAgIHVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICAgICAgaW5wdXRSZWYuY3VycmVudC5pbmRldGVybWluYXRlID0gaW5kZXRlcm1pbmF0ZTtcclxuICAgIH0sIFtpbmRldGVybWluYXRlXSk7XHJcblxyXG4gICAgY29uc3QgaGFuZGxlQ2hhbmdlID0gdXNlQ2FsbGJhY2soZXZlbnQgPT4ge1xyXG4gICAgICAgIG9uQ2hhbmdlKGV2ZW50LCBldmVudC50YXJnZXQuY2hlY2tlZCwgZXZlbnQudGFyZ2V0KTtcclxuICAgIH0sIFtvbkNoYW5nZV0pO1xyXG5cclxuICAgIGNvbnN0IGNsYXNzTmFtZXMgPSBjbGFzc25hbWVzKGNzc0NsYXNzZXMuUk9PVCwge1xyXG4gICAgICAgIFtjc3NDbGFzc2VzLlNFTEVDVEVEXTogY2hlY2tlZCxcclxuICAgICAgICBbY3NzQ2xhc3Nlcy5ESVNBQkxFRF06IGRpc2FibGVkLFxyXG4gICAgICAgIFtjc3NDbGFzc2VzLlRPVUNIXTogdG91Y2hcclxuICAgIH0sIGNsYXNzTmFtZSk7XHJcblxyXG4gICAgcmV0dXJuIChcclxuICAgICAgICA8ZGl2IHJlZj17cmVmfSBjbGFzc05hbWU9e2NsYXNzTmFtZXN9PlxyXG4gICAgICAgICAgICA8aW5wdXRcclxuICAgICAgICAgICAgICAgIHJlZj17aW5wdXRSZWZ9XHJcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU9e2Nzc0NsYXNzZXMuTkFUSVZFX0NPTlRST0x9XHJcbiAgICAgICAgICAgICAgICB0eXBlPVwiY2hlY2tib3hcIlxyXG4gICAgICAgICAgICAgICAgY2hlY2tlZD17Y2hlY2tlZH1cclxuICAgICAgICAgICAgICAgIGRpc2FibGVkPXtkaXNhYmxlZH1cclxuICAgICAgICAgICAgICAgIG9uQ2hhbmdlPXtoYW5kbGVDaGFuZ2V9XHJcbiAgICAgICAgICAgICAgICB7Li4ucHJvcHN9XHJcbiAgICAgICAgICAgIC8+XHJcblxyXG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17Y3NzQ2xhc3Nlcy5CQUNLR1JPVU5EfT5cclxuICAgICAgICAgICAgICAgIDxzdmcgY2xhc3NOYW1lPXtjc3NDbGFzc2VzLkNIRUNLTUFSS30gdmlld0JveD1cIjAgMCAyNCAyNFwiPlxyXG4gICAgICAgICAgICAgICAgICAgIDxwYXRoIGNsYXNzTmFtZT17Y3NzQ2xhc3Nlcy5DSEVDS01BUktfUEFUSH0gZmlsbD1cIm5vbmVcIiBkPVwiTTEuNzMsMTIuOTEgOC4xLDE5LjI4IDIyLjc5LDQuNTlcIiAvPlxyXG4gICAgICAgICAgICAgICAgPC9zdmc+XHJcblxyXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9e2Nzc0NsYXNzZXMuTUlYRURNQVJLfSAvPlxyXG4gICAgICAgICAgICA8L2Rpdj5cclxuXHJcbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXtjc3NDbGFzc2VzLlJJUFBMRX0gLz5cclxuICAgICAgICA8L2Rpdj5cclxuICAgICk7XHJcbn0pO1xyXG5cclxuQ2hlY2tib3guZGlzcGxheU5hbWUgPSAnTURDQ2hlY2tib3gnO1xyXG5cclxuQ2hlY2tib3gucHJvcFR5cGVzID0ge1xyXG4gICAgY2hlY2tlZDogUHJvcFR5cGVzLmJvb2wsXHJcbiAgICBpbmRldGVybWluYXRlOiBQcm9wVHlwZXMuYm9vbCxcclxuICAgIGRpc2FibGVkOiBQcm9wVHlwZXMuYm9vbCxcclxuICAgIHRvdWNoOiBQcm9wVHlwZXMuYm9vbCxcclxuICAgIG9uQ2hhbmdlOiBQcm9wVHlwZXMuZnVuY1xyXG59O1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgQ2hlY2tib3g7IiwiZXhwb3J0IHsgZGVmYXVsdCB9IGZyb20gJy4vQ2hlY2tib3gnOyIsImV4cG9ydCBjb25zdCBudW1iZXJzID0ge1xyXG4gICAgU0VMRUNUSU5HX0FOSU1BVElPTl9NUzogMTUwLFxyXG4gICAgREVTRUxFQ1RJTkdfQU5JTUFUSU9OX01TOiAxMDBcclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCBjaGlwU2V0Q3NzQ2xhc3NlcyA9IHtcclxuICAgIFJPT1Q6ICdtZGMtZXZvbHV0aW9uLWNoaXAtc2V0JyxcclxuICAgIE9WRVJGTE9XOiAnbWRjLWV2b2x1dGlvbi1jaGlwLXNldC0tb3ZlcmZsb3cnLFxyXG4gICAgQ0hJUFM6ICdtZGMtZXZvbHV0aW9uLWNoaXAtc2V0X19jaGlwcydcclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCBjaGlwQ3NzQ2xhc3NlcyA9IHtcclxuICAgIFJPT1Q6ICdtZGMtZXZvbHV0aW9uLWNoaXAnLFxyXG4gICAgRklMVEVSOiAnbWRjLWV2b2x1dGlvbi1jaGlwLS1maWx0ZXInLFxyXG4gICAgU0VMRUNUQUJMRTogJ21kYy1ldm9sdXRpb24tY2hpcC0tc2VsZWN0YWJsZScsXHJcbiAgICBTRUxFQ1RFRDogJ21kYy1ldm9sdXRpb24tY2hpcC0tc2VsZWN0ZWQnLFxyXG4gICAgU0VMRUNUSU5HOiAnbWRjLWV2b2x1dGlvbi1jaGlwLS1zZWxlY3RpbmcnLFxyXG4gICAgU0VMRUNUSU5HX1dJVEhfUFJJTUFSWV9JQ09OOiAnbWRjLWV2b2x1dGlvbi1jaGlwLS1zZWxlY3Rpbmctd2l0aC1wcmltYXJ5LWljb24nLFxyXG4gICAgREVTRUxFQ1RJTkc6ICdtZGMtZXZvbHV0aW9uLWNoaXAtLWRlc2VsZWN0aW5nJyxcclxuICAgIERFU0VMRUNUSU5HX1dJVEhfUFJJTUFSWV9JQ09OOiAnbWRjLWV2b2x1dGlvbi1jaGlwLS1kZXNlbGVjdGluZy13aXRoLXByaW1hcnktaWNvbicsXHJcbiAgICBPVVRMSU5FRDogJ21kYy1ldm9sdXRpb24tY2hpcC0tb3V0bGluZWQnLFxyXG4gICAgRU5URVI6ICdtZGMtZXZvbHV0aW9uLWNoaXAtLWVudGVyJyxcclxuICAgIEVYSVQ6ICdtZGMtZXZvbHV0aW9uLWNoaXAtLWV4aXQnLFxyXG4gICAgSElEREVOOiAnbWRjLWV2b2x1dGlvbi1jaGlwLS1oaWRkZW4nLFxyXG4gICAgRElTQUJMRUQ6ICdtZGMtZXZvbHV0aW9uLWNoaXAtLWRpc2FibGVkJyxcclxuICAgIFRPVUNIOiAnbWRjLWV2b2x1dGlvbi1jaGlwLS10b3VjaCcsXHJcbiAgICBXSVRIX1BSSU1BUllfR1JBUEhJQzogJ21kYy1ldm9sdXRpb24tY2hpcC0td2l0aC1wcmltYXJ5LWdyYXBoaWMnLFxyXG4gICAgV0lUSF9QUklNQVJZX0lDT046ICdtZGMtZXZvbHV0aW9uLWNoaXAtLXdpdGgtcHJpbWFyeS1pY29uJyxcclxuICAgIFdJVEhfVFJBSUxJTkdfQUNUSU9OOiAnbWRjLWV2b2x1dGlvbi1jaGlwLS13aXRoLXRyYWlsaW5nLWFjdGlvbicsXHJcbiAgICBXSVRIX0FWQVRBUjogJ21kYy1ldm9sdXRpb24tY2hpcC0td2l0aC1hdmF0YXInLFxyXG5cclxuICAgIENFTEw6ICdtZGMtZXZvbHV0aW9uLWNoaXBfX2NlbGwnLFxyXG4gICAgUFJJTUFSWV9DRUxMOiAnbWRjLWV2b2x1dGlvbi1jaGlwX19jZWxsLS1wcmltYXJ5JyxcclxuICAgIFRSQUlMSU5HX0NFTEw6ICdtZGMtZXZvbHV0aW9uLWNoaXBfX2NlbGwtLXRyYWlsaW5nJyxcclxuXHJcbiAgICBBQ1RJT046ICdtZGMtZXZvbHV0aW9uLWNoaXBfX2FjdGlvbicsXHJcbiAgICBQUklNQVJZX0FDVElPTjogJ21kYy1ldm9sdXRpb24tY2hpcF9fYWN0aW9uLS1wcmltYXJ5JyxcclxuICAgIFRSQUlMSU5HX0FDVElPTjogJ21kYy1ldm9sdXRpb24tY2hpcF9fYWN0aW9uLS10cmFpbGluZycsXHJcbiAgICBQUkVTRU5UQVRJT05BTF9BQ1RJT046ICdtZGMtZXZvbHV0aW9uLWNoaXBfX2FjdGlvbi0tcHJlc2VudGF0aW9uYWwnLFxyXG4gICAgQUNUSU9OX1RPVUNIOiAnbWRjLWV2b2x1dGlvbi1jaGlwX19hY3Rpb24tdG91Y2gnLFxyXG5cclxuICAgIFJJUFBMRTogJ21kYy1ldm9sdXRpb24tY2hpcF9fcmlwcGxlJyxcclxuICAgIFBSSU1BUllfUklQUExFOiAnbWRjLWV2b2x1dGlvbi1jaGlwX19yaXBwbGUtLXByaW1hcnknLFxyXG4gICAgVFJBSUxJTkdfUklQUExFOiAnbWRjLWV2b2x1dGlvbi1jaGlwX19yaXBwbGUtLXRyYWlsaW5nJyxcclxuXHJcbiAgICBHUkFQSElDOiAnbWRjLWV2b2x1dGlvbi1jaGlwX19ncmFwaGljJyxcclxuICAgIElDT046ICdtZGMtZXZvbHV0aW9uLWNoaXBfX2ljb24nLFxyXG4gICAgUFJJTUFSWV9JQ09OOiAnbWRjLWV2b2x1dGlvbi1jaGlwX19pY29uLS1wcmltYXJ5JyxcclxuICAgIFRSQUlMSU5HX0lDT046ICdtZGMtZXZvbHV0aW9uLWNoaXBfX2ljb24tLXRyYWlsaW5nJyxcclxuICAgIFRFWFRfTEFCRUw6ICdtZGMtZXZvbHV0aW9uLWNoaXBfX3RleHQtbGFiZWwnLFxyXG4gICAgQ0hFQ0tNQVJLOiAnbWRjLWV2b2x1dGlvbi1jaGlwX19jaGVja21hcmsnLFxyXG4gICAgQ0hFQ0tNQVJLX1NWRzogJ21kYy1ldm9sdXRpb24tY2hpcF9fY2hlY2ttYXJrLXN2ZycsXHJcbiAgICBDSEVDS01BUktfUEFUSDogJ21kYy1ldm9sdXRpb24tY2hpcF9fY2hlY2ttYXJrLXBhdGgnXHJcbn07IiwiaW1wb3J0IGNsYXNzbmFtZXMgZnJvbSAnY2xhc3NuYW1lcyc7XHJcblxyXG5pbXBvcnQgeyBDbG9uZSB9IGZyb20gJy4uL2NvbXBvbmVudCc7XHJcbmltcG9ydCBJY29uIGZyb20gJy4uL2ljb24nO1xyXG5cclxuaW1wb3J0IHsgY2hpcENzc0NsYXNzZXMgYXMgY3NzQ2xhc3NlcyB9IGZyb20gJy4vY29uc3RhbnRzJztcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIENoaXBQcmltYXJ5QWN0aW9uKHtcclxuICAgIHRleHQsXHJcbiAgICBncmFwaGljLFxyXG4gICAgaWNvbixcclxuICAgIHByZXNlbnRhdGlvbmFsID0gZmFsc2UsXHJcbiAgICBzZWxlY3RhYmxlID0gZmFsc2UsXHJcbiAgICBzZWxlY3RlZCA9IGZhbHNlLFxyXG4gICAgZGlzYWJsZWQgPSBmYWxzZSxcclxuXHJcbiAgICBlbGVtZW50ID0gJ2J1dHRvbicsXHJcbiAgICBjb21wb25lbnQ6IEVsZW1lbnQgPSBlbGVtZW50LFxyXG4gICAgY2hpbGRyZW4gPSB0ZXh0LFxyXG4gICAgLi4ucHJvcHNcclxufSkge1xyXG4gICAgY29uc3QgaXNCdXR0b24gPSBFbGVtZW50ID09PSAnYnV0dG9uJztcclxuICAgIGNvbnN0IGNsYXNzTmFtZXMgPSBjbGFzc25hbWVzKGNzc0NsYXNzZXMuQUNUSU9OLCBjc3NDbGFzc2VzLlBSSU1BUllfQUNUSU9OLCB7XHJcbiAgICAgICAgW2Nzc0NsYXNzZXMuUFJFU0VOVEFUSU9OQUxfQUNUSU9OXTogcHJlc2VudGF0aW9uYWxcclxuICAgIH0pO1xyXG5cclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgPEVsZW1lbnRcclxuICAgICAgICAgICAgY2xhc3NOYW1lPXtjbGFzc05hbWVzfVxyXG4gICAgICAgICAgICB0eXBlPXtpc0J1dHRvbiA/ICdidXR0b24nIDogdW5kZWZpbmVkfVxyXG4gICAgICAgICAgICBkaXNhYmxlZD17aXNCdXR0b24gJiYgZGlzYWJsZWR9XHJcbiAgICAgICAgICAgIHRhYkluZGV4PXtkaXNhYmxlZCA/ICctMScgOiAnMCd9XHJcbiAgICAgICAgICAgIHJvbGU9eyFpc0J1dHRvbiA/ICdvcHRpb24nIDogdW5kZWZpbmVkfVxyXG4gICAgICAgICAgICBhcmlhLXNlbGVjdGVkPXshaXNCdXR0b24gPyBzZWxlY3RlZCA6IHVuZGVmaW5lZH1cclxuICAgICAgICAgICAgYXJpYS1kaXNhYmxlZD17IWlzQnV0dG9uID8gZGlzYWJsZWQgOiB1bmRlZmluZWR9XHJcbiAgICAgICAgICAgIHsuLi5wcm9wc31cclxuICAgICAgICA+XHJcbiAgICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT17YCR7Y3NzQ2xhc3Nlcy5SSVBQTEV9ICR7Y3NzQ2xhc3Nlcy5QUklNQVJZX1JJUFBMRX1gfSAvPlxyXG5cclxuICAgICAgICAgICAgeyhncmFwaGljIHx8IGljb24gfHwgc2VsZWN0YWJsZSkgJiZcclxuICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT17Y3NzQ2xhc3Nlcy5HUkFQSElDfT5cclxuICAgICAgICAgICAgICAgICAgICB7Z3JhcGhpY31cclxuXHJcbiAgICAgICAgICAgICAgICAgICAge2ljb24gJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgPENsb25lXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21wb25lbnQ9e2ljb259XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmYWxsYmFjaz17SWNvbn1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT17YCR7Y3NzQ2xhc3Nlcy5JQ09OfSAke2Nzc0NsYXNzZXMuUFJJTUFSWV9JQ09OfWB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8+XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICB7c2VsZWN0YWJsZSAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9e2Nzc0NsYXNzZXMuQ0hFQ0tNQVJLfT5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzdmcgY2xhc3NOYW1lPXtjc3NDbGFzc2VzLkNIRUNLTUFSS19TVkd9IHZpZXdCb3g9XCItMiAtMyAzMCAzMFwiPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxwYXRoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT17Y3NzQ2xhc3Nlcy5DSEVDS01BUktfUEFUSH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsbD1cIm5vbmVcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHJva2U9XCJibGFja1wiIGQ9XCJNMS43MywxMi45MSA4LjEsMTkuMjggMjIuNzksNC41OVwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLz5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvc3ZnPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8L3NwYW4+XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgPC9zcGFuPlxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9e2Nzc0NsYXNzZXMuVEVYVF9MQUJFTH0+e2NoaWxkcmVufTwvc3Bhbj5cclxuICAgICAgICA8L0VsZW1lbnQ+XHJcbiAgICApO1xyXG59IiwiaW1wb3J0IGNsYXNzbmFtZXMgZnJvbSAnY2xhc3NuYW1lcyc7XHJcblxyXG5pbXBvcnQgeyBDbG9uZSB9IGZyb20gJy4uL2NvbXBvbmVudCc7XHJcbmltcG9ydCBJY29uIGZyb20gJy4uL2ljb24nO1xyXG5cclxuaW1wb3J0IHsgY2hpcENzc0NsYXNzZXMgYXMgY3NzQ2xhc3NlcyB9IGZyb20gJy4vY29uc3RhbnRzJztcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIENoaXBUcmFpbGluZ0FjdGlvbih7XHJcbiAgICBpY29uLFxyXG4gICAgcHJlc2VudGF0aW9uYWwgPSBmYWxzZSxcclxuICAgIC4uLnByb3BzXHJcbn0pIHtcclxuICAgIGNvbnN0IGNsYXNzTmFtZXMgPSBjbGFzc25hbWVzKGNzc0NsYXNzZXMuQUNUSU9OLCBjc3NDbGFzc2VzLlRSQUlMSU5HX0FDVElPTiwge1xyXG4gICAgICAgIFtjc3NDbGFzc2VzLlBSRVNFTlRBVElPTkFMX0FDVElPTl06IHByZXNlbnRhdGlvbmFsXHJcbiAgICB9KTtcclxuXHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAgIDxidXR0b25cclxuICAgICAgICAgICAgY2xhc3NOYW1lPXtjbGFzc05hbWVzfVxyXG4gICAgICAgICAgICB0eXBlPVwiYnV0dG9uXCJcclxuICAgICAgICAgICAgdGFiSW5kZXg9XCItMVwiXHJcbiAgICAgICAgICAgIGFyaWEtaGlkZGVuPVwidHJ1ZVwiXHJcbiAgICAgICAgICAgIHsuLi5wcm9wc31cclxuICAgICAgICA+XHJcbiAgICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT17YCR7Y3NzQ2xhc3Nlcy5SSVBQTEV9ICR7Y3NzQ2xhc3Nlcy5UUkFJTElOR19SSVBQTEV9YH0gLz5cclxuXHJcbiAgICAgICAgICAgIDxDbG9uZVxyXG4gICAgICAgICAgICAgICAgY29tcG9uZW50PXtpY29ufVxyXG4gICAgICAgICAgICAgICAgZmFsbGJhY2s9e0ljb259XHJcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU9e2Ake2Nzc0NsYXNzZXMuSUNPTn0gJHtjc3NDbGFzc2VzLlRSQUlMSU5HX0lDT059YH1cclxuICAgICAgICAgICAgLz5cclxuICAgICAgICA8L2J1dHRvbj5cclxuICAgICk7XHJcbn0iLCJpbXBvcnQgeyBmb3J3YXJkUmVmIH0gZnJvbSAncmVhY3QnO1xyXG5pbXBvcnQgeyBDU1NUcmFuc2l0aW9uIH0gZnJvbSAncmVhY3QtdHJhbnNpdGlvbi1ncm91cCc7XHJcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XHJcbmltcG9ydCBjbGFzc25hbWVzIGZyb20gJ2NsYXNzbmFtZXMnO1xyXG5cclxuaW1wb3J0IHsgbnVtYmVycywgY2hpcENzc0NsYXNzZXMgYXMgY3NzQ2xhc3NlcyB9IGZyb20gJy4vY29uc3RhbnRzJztcclxuaW1wb3J0IENoaXBQcmltYXJ5QWN0aW9uIGZyb20gJy4vQ2hpcFByaW1hcnlBY3Rpb24nO1xyXG5pbXBvcnQgQ2hpcFRyYWlsaW5nQWN0aW9uIGZyb20gJy4vQ2hpcFRyYWlsaW5nQWN0aW9uJztcclxuXHJcbmNvbnN0IENoaXAgPSBmb3J3YXJkUmVmKCh7XHJcbiAgICB2YWx1ZSxcclxuICAgIHRleHQsXHJcbiAgICBncmFwaGljLFxyXG4gICAgaWNvbixcclxuICAgIHByaW1hcnlJY29uID0gaWNvbixcclxuICAgIHRyYWlsaW5nSWNvbixcclxuICAgIHNlbGVjdGFibGUgPSBmYWxzZSxcclxuICAgIGZpbHRlciA9IGZhbHNlLFxyXG4gICAgc2VsZWN0ZWQgPSBmYWxzZSxcclxuICAgIG91dGxpbmVkID0gZmFsc2UsXHJcbiAgICBkaXNhYmxlZCA9IGZhbHNlLFxyXG4gICAgdG91Y2ggPSBmYWxzZSxcclxuICAgIHdpdGhBdmF0YXIgPSBmYWxzZSxcclxuXHJcbiAgICBlbGVtZW50ID0gJ3NwYW4nLFxyXG4gICAgY29tcG9uZW50OiBFbGVtZW50ID0gZWxlbWVudCxcclxuICAgIGNsYXNzTmFtZSxcclxuICAgIC4uLnByb3BzXHJcbn0sIHJlZikgPT4ge1xyXG4gICAgY29uc3Qgd2l0aFByaW1hcnlHcmFwaGljID0gc2VsZWN0YWJsZSB8fCBCb29sZWFuKGdyYXBoaWMpIHx8IEJvb2xlYW4ocHJpbWFyeUljb24pO1xyXG4gICAgY29uc3Qgd2l0aFByaW1hcnlJY29uID0gQm9vbGVhbihwcmltYXJ5SWNvbik7XHJcbiAgICBjb25zdCB3aXRoVHJhaWxpbmdBY3Rpb24gPSBCb29sZWFuKHRyYWlsaW5nSWNvbik7XHJcblxyXG4gICAgY29uc3QgY2xhc3NOYW1lcyA9IGNsYXNzbmFtZXMoY3NzQ2xhc3Nlcy5ST09ULCB7XHJcbiAgICAgICAgW2Nzc0NsYXNzZXMuU0VMRUNUQUJMRV06IHNlbGVjdGFibGUsXHJcbiAgICAgICAgW2Nzc0NsYXNzZXMuRklMVEVSXTogZmlsdGVyLFxyXG4gICAgICAgIFtjc3NDbGFzc2VzLk9VVExJTkVEXTogb3V0bGluZWQsXHJcbiAgICAgICAgW2Nzc0NsYXNzZXMuRElTQUJMRURdOiBkaXNhYmxlZCxcclxuICAgICAgICBbY3NzQ2xhc3Nlcy5UT1VDSF06IHRvdWNoLFxyXG4gICAgICAgIFtjc3NDbGFzc2VzLldJVEhfUFJJTUFSWV9HUkFQSElDXTogd2l0aFByaW1hcnlHcmFwaGljLFxyXG4gICAgICAgIFtjc3NDbGFzc2VzLldJVEhfUFJJTUFSWV9JQ09OXTogd2l0aFByaW1hcnlJY29uLFxyXG4gICAgICAgIFtjc3NDbGFzc2VzLldJVEhfVFJBSUxJTkdfQUNUSU9OXTogd2l0aFRyYWlsaW5nQWN0aW9uLFxyXG4gICAgICAgIFtjc3NDbGFzc2VzLldJVEhfQVZBVEFSXTogd2l0aEF2YXRhclxyXG4gICAgfSwgY2xhc3NOYW1lKTtcclxuXHJcbiAgICBjb25zdCBzZWxlY3RpbmdDbGFzcyA9IHdpdGhQcmltYXJ5SWNvbiA/IGNzc0NsYXNzZXMuU0VMRUNUSU5HX1dJVEhfUFJJTUFSWV9JQ09OIDogY3NzQ2xhc3Nlcy5TRUxFQ1RJTkc7XHJcbiAgICBjb25zdCBkZXNlbGVjdGluZ0NsYXNzID0gd2l0aFByaW1hcnlJY29uID8gY3NzQ2xhc3Nlcy5ERVNFTEVDVElOR19XSVRIX1BSSU1BUllfSUNPTiA6IGNzc0NsYXNzZXMuREVTRUxFQ1RJTkc7XHJcblxyXG4gICAgcmV0dXJuIChcclxuICAgICAgICA8Q1NTVHJhbnNpdGlvblxyXG4gICAgICAgICAgICBpbj17c2VsZWN0ZWR9XHJcbiAgICAgICAgICAgIGFwcGVhclxyXG4gICAgICAgICAgICB0aW1lb3V0PXt7XHJcbiAgICAgICAgICAgICAgICBlbnRlcjogbnVtYmVycy5TRUxFQ1RJTkdfQU5JTUFUSU9OX01TLFxyXG4gICAgICAgICAgICAgICAgZXhpdDogbnVtYmVycy5ERVNFTEVDVElOR19BTklNQVRJT05fTVNcclxuICAgICAgICAgICAgfX1cclxuICAgICAgICAgICAgY2xhc3NOYW1lcz17e1xyXG4gICAgICAgICAgICAgICAgZW50ZXI6IHNlbGVjdGluZ0NsYXNzLFxyXG4gICAgICAgICAgICAgICAgZW50ZXJBY3RpdmU6IGAke2Nzc0NsYXNzZXMuU0VMRUNURUR9ICR7c2VsZWN0aW5nQ2xhc3N9YCxcclxuICAgICAgICAgICAgICAgIGVudGVyRG9uZTogY3NzQ2xhc3Nlcy5TRUxFQ1RFRCxcclxuICAgICAgICAgICAgICAgIGV4aXQ6IGRlc2VsZWN0aW5nQ2xhc3MsXHJcbiAgICAgICAgICAgICAgICBleGl0QWN0aXZlOiBkZXNlbGVjdGluZ0NsYXNzXHJcbiAgICAgICAgICAgIH19XHJcbiAgICAgICAgPlxyXG4gICAgICAgICAgICA8RWxlbWVudFxyXG4gICAgICAgICAgICAgICAgcmVmPXtyZWZ9XHJcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU9e2NsYXNzTmFtZXN9XHJcbiAgICAgICAgICAgICAgICBkYXRhLXZhbHVlPXt2YWx1ZX1cclxuICAgICAgICAgICAgICAgIHJvbGU9e3NlbGVjdGFibGUgPyAncHJlc2VudGF0aW9uJyA6ICdyb3cnfVxyXG4gICAgICAgICAgICAgICAgey4uLnByb3BzfVxyXG4gICAgICAgICAgICA+XHJcbiAgICAgICAgICAgICAgICB7c2VsZWN0YWJsZSA/XHJcbiAgICAgICAgICAgICAgICAgICAgPENoaXBQcmltYXJ5QWN0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnQ9XCJzcGFuXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dD17dGV4dH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZ3JhcGhpYz17Z3JhcGhpY31cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWNvbj17cHJpbWFyeUljb259XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdGFibGU9e3NlbGVjdGFibGV9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdGVkPXtzZWxlY3RlZH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZGlzYWJsZWQ9e2Rpc2FibGVkfVxyXG4gICAgICAgICAgICAgICAgICAgIC8+XHJcbiAgICAgICAgICAgICAgICAgICAgOlxyXG4gICAgICAgICAgICAgICAgICAgIDw+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT17YCR7Y3NzQ2xhc3Nlcy5DRUxMfSAke2Nzc0NsYXNzZXMuUFJJTUFSWV9DRUxMfWB9IHJvbGU9XCJncmlkY2VsbFwiPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPENoaXBQcmltYXJ5QWN0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dD17dGV4dH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBncmFwaGljPXtncmFwaGljfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGljb249e3ByaW1hcnlJY29ufVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpc2FibGVkPXtkaXNhYmxlZH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDwvc3Bhbj5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHt0cmFpbGluZ0ljb24gJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT17YCR7Y3NzQ2xhc3Nlcy5DRUxMfSAke2Nzc0NsYXNzZXMuVFJBSUxJTkdfQ0VMTH1gfSByb2xlPVwiZ3JpZGNlbGxcIj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8Q2hpcFRyYWlsaW5nQWN0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGljb249e3RyYWlsaW5nSWNvbn1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlzYWJsZWQ9e2Rpc2FibGVkfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L3NwYW4+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICA8Lz5cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgPC9FbGVtZW50PlxyXG4gICAgICAgIDwvQ1NTVHJhbnNpdGlvbj5cclxuICAgICk7XHJcbn0pO1xyXG5cclxuQ2hpcC5kaXNwbGF5TmFtZSA9ICdNRENDaGlwJztcclxuXHJcbkNoaXAucHJvcFR5cGVzID0ge1xyXG4gICAgdmFsdWU6IFByb3BUeXBlcy5hbnksXHJcbiAgICB0ZXh0OiBQcm9wVHlwZXMubm9kZSxcclxuICAgIGxlYWRpbmdJY29uOiBQcm9wVHlwZXMubm9kZSxcclxuICAgIHRyYWlsaW5nSWNvbjogUHJvcFR5cGVzLm5vZGUsXHJcbiAgICBzZWxlY3RlZDogUHJvcFR5cGVzLmJvb2wsXHJcbiAgICBvdXRsaW5lZDogUHJvcFR5cGVzLmJvb2wsXHJcbiAgICBvbkNsaWNrOiBQcm9wVHlwZXMuZnVuY1xyXG59O1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgQ2hpcDsiLCJleHBvcnQgZnVuY3Rpb24gaXNVbmRlZmluZWQodmFsdWUpIHtcclxuICAgIHJldHVybiB2YWx1ZSA9PT0gdW5kZWZpbmVkO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gaXNOdWxsKHZhbHVlKSB7XHJcbiAgICByZXR1cm4gdmFsdWUgPT09IG51bGw7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBpc0Jvb2xlYW4odmFsdWUpIHtcclxuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJztcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGlzTnVtYmVyKHZhbHVlKSB7XHJcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJztcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGlzU3RyaW5nKHZhbHVlKSB7XHJcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJztcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGlzQXJyYXkodmFsdWUpIHtcclxuICAgIHJldHVybiBBcnJheS5pc0FycmF5KHZhbHVlKTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGlzT2JqZWN0KHZhbHVlKSB7XHJcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiAhaXNOdWxsKHZhbHVlKSAmJiAhaXNBcnJheSh2YWx1ZSk7XHJcbn0iLCJpbXBvcnQgeyBDaGlsZHJlbiwgZm9yd2FyZFJlZiwgdXNlQ2FsbGJhY2sgfSBmcm9tICdyZWFjdCc7XHJcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XHJcbmltcG9ydCBjbGFzc25hbWVzIGZyb20gJ2NsYXNzbmFtZXMnO1xyXG5cclxuaW1wb3J0IHsgaXNVbmRlZmluZWQsIGlzQXJyYXkgfSBmcm9tICcuLi90eXBlcyc7XHJcbmltcG9ydCB7IGNsb25lLCBjcmVhdGUgfSBmcm9tICcuLi9jb21wb25lbnQnO1xyXG5cclxuaW1wb3J0IHsgY2hpcFNldENzc0NsYXNzZXMgYXMgY3NzQ2xhc3NlcyB9IGZyb20gJy4vY29uc3RhbnRzJztcclxuaW1wb3J0IENoaXAgZnJvbSAnLi9DaGlwJztcclxuXHJcbmNvbnN0IENoaXBTZXQgPSBmb3J3YXJkUmVmKCh7XHJcbiAgICB2YWx1ZSxcclxuICAgIGNoaXBzLFxyXG4gICAgaW5wdXQgPSBmYWxzZSxcclxuICAgIGNob2ljZSA9ICghaW5wdXQgJiYgIWlzVW5kZWZpbmVkKHZhbHVlKSAmJiAhaXNBcnJheSh2YWx1ZSkpLFxyXG4gICAgZmlsdGVyID0gKCFpbnB1dCAmJiAhaXNVbmRlZmluZWQodmFsdWUpICYmIGlzQXJyYXkodmFsdWUpKSxcclxuICAgIG92ZXJmbG93ID0gZmFsc2UsXHJcbiAgICBvbkNoYW5nZSA9IEZ1bmN0aW9uLnByb3RvdHlwZSxcclxuXHJcbiAgICBlbGVtZW50ID0gJ2RpdicsXHJcbiAgICBjb21wb25lbnQ6IEVsZW1lbnQgPSBlbGVtZW50LFxyXG4gICAgY2xhc3NOYW1lLFxyXG4gICAgY2hpbGRyZW4gPSBjaGlwcz8ubWFwKGNoaXAgPT4gY3JlYXRlKENoaXAsIGNoaXApKSxcclxuICAgIC4uLnByb3BzXHJcbn0sIHJlZikgPT4ge1xyXG4gICAgY29uc3QgaGFuZGxlQ2xpY2sgPSB1c2VDYWxsYmFjayhldmVudCA9PiB7XHJcbiAgICAgICAgY29uc3QgY2hpcFZhbHVlID0gZXZlbnQuY3VycmVudFRhcmdldC5kYXRhc2V0LnZhbHVlO1xyXG4gICAgICAgIGNvbnN0IG5ld1ZhbHVlID0gY2hvaWNlID8gY2hpcFZhbHVlIDpcclxuICAgICAgICAgICAgKHZhbHVlLmluY2x1ZGVzKGNoaXBWYWx1ZSkgP1xyXG4gICAgICAgICAgICAgICAgdmFsdWUuZmlsdGVyKHYgPT4gdiAhPT0gY2hpcFZhbHVlKSA6XHJcbiAgICAgICAgICAgICAgICB2YWx1ZS5jb25jYXQoY2hpcFZhbHVlKVxyXG4gICAgICAgICAgICApO1xyXG5cclxuICAgICAgICBvbkNoYW5nZShuZXdWYWx1ZSk7XHJcbiAgICB9LCBbdmFsdWUsIGNob2ljZSwgb25DaGFuZ2VdKTtcclxuXHJcbiAgICBjb25zdCBjbGFzc05hbWVzID0gY2xhc3NuYW1lcyhjc3NDbGFzc2VzLlJPT1QsIHtcclxuICAgICAgICBbY3NzQ2xhc3Nlcy5PVkVSRkxPV106IG92ZXJmbG93XHJcbiAgICB9LCBjbGFzc05hbWUpO1xyXG5cclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgPEVsZW1lbnQgcmVmPXtyZWZ9IGNsYXNzTmFtZT17Y2xhc3NOYW1lc30gcm9sZT17ZmlsdGVyID8gJ2xpc3Rib3gnIDogJ2dyaWQnfSB7Li4ucHJvcHN9PlxyXG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17Y3NzQ2xhc3Nlcy5DSElQU30gcm9sZT1cInByZXNlbnRhdGlvblwiPlxyXG4gICAgICAgICAgICAgICAge2lzVW5kZWZpbmVkKHZhbHVlKSA/IGNoaWxkcmVuIDpcclxuICAgICAgICAgICAgICAgICAgICBDaGlsZHJlbi5tYXAoY2hpbGRyZW4sIGNoaXAgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjaGlwVmFsdWUgPSBjaGlwLnByb3BzLnZhbHVlO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNsb25lKGNoaXAsIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdGFibGU6IHRydWUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3RlZDogY2hvaWNlID8gdmFsdWUgPT09IGNoaXBWYWx1ZSA6IHZhbHVlLmluY2x1ZGVzKGNoaXBWYWx1ZSksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbkNsaWNrQ2FwdHVyZTogKGNob2ljZSB8fCBmaWx0ZXIpID8gaGFuZGxlQ2xpY2sgOiB1bmRlZmluZWQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgIDwvRWxlbWVudD5cclxuICAgICk7XHJcbn0pO1xyXG5cclxuQ2hpcFNldC5kaXNwbGF5TmFtZSA9ICdNRENDaGlwU2V0JztcclxuXHJcbkNoaXBTZXQucHJvcFR5cGVzID0ge1xyXG4gICAgdmFsdWU6IFByb3BUeXBlcy5hbnksXHJcbiAgICBpbnB1dDogUHJvcFR5cGVzLmJvb2wsXHJcbiAgICBjaG9pY2U6IFByb3BUeXBlcy5ib29sLFxyXG4gICAgZmlsdGVyOiBQcm9wVHlwZXMuYm9vbCxcclxuICAgIG92ZXJmbG93OiBQcm9wVHlwZXMuYm9vbCxcclxuICAgIG9uQ2hhbmdlOiBQcm9wVHlwZXMuZnVuY1xyXG59O1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgQ2hpcFNldDsiLCJleHBvcnQgeyBkZWZhdWx0IGFzIENoaXAgfSBmcm9tICcuL0NoaXAnO1xyXG5leHBvcnQgeyBkZWZhdWx0IGFzIENoaXBTZXQgfSBmcm9tICcuL0NoaXBTZXQnOyIsImV4cG9ydCBjb25zdCBzdHJpbmdzID0ge1xyXG4gICAgWE1MTlM6ICdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZycsXHJcbn07XHJcblxyXG5leHBvcnQgY29uc3Qgc2l6ZVByb3BzID0ge1xyXG4gICAgbGFyZ2U6IHtcclxuICAgICAgICB2aWV3Qm94OiA0OCxcclxuICAgICAgICByYWRpdXM6IDE4LFxyXG4gICAgICAgIHN0cm9rZVdpZHRoOiA0LFxyXG4gICAgICAgIGdhcFBhdGNoU3Ryb2tlV2lkdGg6IDMuMixcclxuICAgICAgICBzdHJva2VEYXNoYXJyYXk6IDExMy4wOTcsXHJcbiAgICAgICAgaW5kZXRlcm1pbmF0ZVN0cm9rZURhc2hvZmZzZXQ6IDU2LjU0OVxyXG4gICAgfSxcclxuICAgIG1lZGl1bToge1xyXG4gICAgICAgIHZpZXdCb3g6IDMyLFxyXG4gICAgICAgIHJhZGl1czogMTIuNSxcclxuICAgICAgICBzdHJva2VXaWR0aDogMyxcclxuICAgICAgICBnYXBQYXRjaFN0cm9rZVdpZHRoOiAyLjQsXHJcbiAgICAgICAgc3Ryb2tlRGFzaGFycmF5OiA3OC41NCxcclxuICAgICAgICBpbmRldGVybWluYXRlU3Ryb2tlRGFzaG9mZnNldDogMzkuMjdcclxuICAgIH0sXHJcbiAgICBzbWFsbDoge1xyXG4gICAgICAgIHZpZXdCb3g6IDI0LFxyXG4gICAgICAgIHJhZGl1czogOC43NSxcclxuICAgICAgICBzdHJva2VXaWR0aDogMi41LFxyXG4gICAgICAgIGdhcFBhdGNoU3Ryb2tlV2lkdGg6IDIsXHJcbiAgICAgICAgc3Ryb2tlRGFzaGFycmF5OiA1NC45NzgsXHJcbiAgICAgICAgaW5kZXRlcm1pbmF0ZVN0cm9rZURhc2hvZmZzZXQ6IDI3LjQ4OVxyXG4gICAgfVxyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IGNzc0NsYXNzZXMgPSB7XHJcbiAgICBST09UOiAnbWRjLWNpcmN1bGFyLXByb2dyZXNzJyxcclxuICAgIFNNQUxMOiAnbWRjLWNpcmN1bGFyLXByb2dyZXNzLS1zbWFsbCcsXHJcbiAgICBNRURJVU06ICdtZGMtY2lyY3VsYXItcHJvZ3Jlc3MtLW1lZGl1bScsXHJcbiAgICBMQVJHRTogJ21kYy1jaXJjdWxhci1wcm9ncmVzcy0tbGFyZ2UnLFxyXG4gICAgSU5ERVRFUk1JTkFURTogJ21kYy1jaXJjdWxhci1wcm9ncmVzcy0taW5kZXRlcm1pbmF0ZScsXHJcbiAgICBDTE9TRUQ6ICdtZGMtY2lyY3VsYXItcHJvZ3Jlc3MtLWNsb3NlZCcsXHJcblxyXG4gICAgREVURVJNSU5BVEVfQ09OVEFJTkVSOiAnbWRjLWNpcmN1bGFyLXByb2dyZXNzX19kZXRlcm1pbmF0ZS1jb250YWluZXInLFxyXG4gICAgREVURVJNSU5BVEVfQ0lSQ0xFX0dSQVBISUM6ICdtZGMtY2lyY3VsYXItcHJvZ3Jlc3NfX2RldGVybWluYXRlLWNpcmNsZS1ncmFwaGljJyxcclxuICAgIERFVEVSTUlOQVRFX1RSQUNLOiAnbWRjLWNpcmN1bGFyLXByb2dyZXNzX19kZXRlcm1pbmF0ZS10cmFjaycsXHJcbiAgICBERVRFUk1JTkFURV9DSVJDTEU6ICdtZGMtY2lyY3VsYXItcHJvZ3Jlc3NfX2RldGVybWluYXRlLWNpcmNsZScsXHJcblxyXG4gICAgSU5ERVRFUk1JTkFURV9DT05UQUlORVI6ICdtZGMtY2lyY3VsYXItcHJvZ3Jlc3NfX2luZGV0ZXJtaW5hdGUtY29udGFpbmVyJyxcclxuICAgIElOREVURVJNSU5BVEVfQ0lSQ0xFX0dSQVBISUM6ICdtZGMtY2lyY3VsYXItcHJvZ3Jlc3NfX2luZGV0ZXJtaW5hdGUtY2lyY2xlLWdyYXBoaWMnLFxyXG5cclxuICAgIFNQSU5ORVJfTEFZRVI6ICdtZGMtY2lyY3VsYXItcHJvZ3Jlc3NfX3NwaW5uZXItbGF5ZXInLFxyXG4gICAgQ09MT1I6ICdtZGMtY2lyY3VsYXItcHJvZ3Jlc3NfX2NvbG9yJyxcclxuICAgIENJUkNMRV9DTElQUEVSOiAnbWRjLWNpcmN1bGFyLXByb2dyZXNzX19jaXJjbGUtY2xpcHBlcicsXHJcbiAgICBDSVJDTEVfTEVGVDogJ21kYy1jaXJjdWxhci1wcm9ncmVzc19fY2lyY2xlLWxlZnQnLFxyXG4gICAgQ0lSQ0xFX1JJR0hUOiAnbWRjLWNpcmN1bGFyLXByb2dyZXNzX19jaXJjbGUtcmlnaHQnLFxyXG4gICAgR0FQX1BBVENIOiAnbWRjLWNpcmN1bGFyLXByb2dyZXNzX19nYXAtcGF0Y2gnXHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgU2l6ZSA9IHtcclxuICAgIExBUkdFOiAnbGFyZ2UnLFxyXG4gICAgTUVESVVNOiAnbWVkaXVtJyxcclxuICAgIFNNQUxMOiAnc21hbGwnXHJcbn07IiwiaW1wb3J0IHsgZm9yd2FyZFJlZiB9IGZyb20gJ3JlYWN0JztcclxuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcclxuaW1wb3J0IGNsYXNzbmFtZXMgZnJvbSAnY2xhc3NuYW1lcyc7XHJcblxyXG5pbXBvcnQgeyBzdHJpbmdzLCBjc3NDbGFzc2VzLCBzaXplUHJvcHMsIFNpemUgfSBmcm9tICcuL2NvbnN0YW50cyc7XHJcblxyXG5jb25zdCBDaXJjdWxhclByb2dyZXNzID0gZm9yd2FyZFJlZigoe1xyXG4gICAgdmFsdWUgPSAwLFxyXG4gICAgc2l6ZSA9IFNpemUuTUVESVVNLFxyXG4gICAgaW5kZXRlcm1pbmF0ZSA9IGZhbHNlLFxyXG4gICAgY2xvc2VkID0gZmFsc2UsXHJcbiAgICBjb2xvcmZ1bCA9IGZhbHNlLFxyXG5cclxuICAgIGNsYXNzTmFtZSxcclxuICAgIC4uLnByb3BzXHJcbn0sIHJlZikgPT4ge1xyXG4gICAgY29uc3QgY2xhc3NOYW1lcyA9IGNsYXNzbmFtZXMoY3NzQ2xhc3Nlcy5ST09ULCB7XHJcbiAgICAgICAgW2Ake2Nzc0NsYXNzZXMuUk9PVH0tLSR7c2l6ZX1gXTogc2l6ZSxcclxuICAgICAgICBbY3NzQ2xhc3Nlcy5JTkRFVEVSTUlOQVRFXTogaW5kZXRlcm1pbmF0ZSxcclxuICAgICAgICBbY3NzQ2xhc3Nlcy5DTE9TRURdOiBjbG9zZWRcclxuICAgIH0sIGNsYXNzTmFtZSk7XHJcblxyXG4gICAgY29uc3QgeyB2aWV3Qm94LCByYWRpdXMsIHN0cm9rZURhc2hhcnJheSwgc3Ryb2tlV2lkdGgsIGdhcFBhdGNoU3Ryb2tlV2lkdGgsIGluZGV0ZXJtaW5hdGVTdHJva2VEYXNob2Zmc2V0IH0gPSBzaXplUHJvcHNbc2l6ZV07XHJcbiAgICBjb25zdCBwcm9ncmVzcyA9IHZhbHVlID4gMSA/ICh2YWx1ZSAvIDEwMCkgOiBOdW1iZXIodmFsdWUpO1xyXG4gICAgY29uc3QgY3ggPSB2aWV3Qm94IC8gMiwgY3kgPSB2aWV3Qm94IC8gMjtcclxuICAgIGNvbnN0IHN0cm9rZURhc2hvZmZzZXQgPSAoMiAqIE1hdGguUEkgKiByYWRpdXMpICogKDEgLSBwcm9ncmVzcyk7XHJcblxyXG4gICAgcmV0dXJuIChcclxuICAgICAgICA8ZGl2XHJcbiAgICAgICAgICAgIHJlZj17cmVmfVxyXG4gICAgICAgICAgICBjbGFzc05hbWU9e2NsYXNzTmFtZXN9XHJcbiAgICAgICAgICAgIHJvbGU9XCJwcm9ncmVzc2JhclwiXHJcbiAgICAgICAgICAgIGFyaWEtdmFsdWVtaW49ezB9XHJcbiAgICAgICAgICAgIGFyaWEtdmFsdWVtYXg9ezF9XHJcbiAgICAgICAgICAgIGFyaWEtdmFsdWVub3c9e3Byb2dyZXNzfVxyXG4gICAgICAgICAgICB7Li4ucHJvcHN9XHJcbiAgICAgICAgPlxyXG4gICAgICAgICAgICB7IWluZGV0ZXJtaW5hdGUgJiZcclxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXtjc3NDbGFzc2VzLkRFVEVSTUlOQVRFX0NPTlRBSU5FUn0+XHJcbiAgICAgICAgICAgICAgICAgICAgPHN2ZyBjbGFzc05hbWU9e2Nzc0NsYXNzZXMuREVURVJNSU5BVEVfQ0lSQ0xFX0dSQVBISUN9IHZpZXdCb3g9e2AwIDAgJHt2aWV3Qm94fSAke3ZpZXdCb3h9YH0geG1sbnM9e3N0cmluZ3MuWE1MTlN9PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8Y2lyY2xlIGNsYXNzTmFtZT17Y3NzQ2xhc3Nlcy5ERVRFUk1JTkFURV9UUkFDS30gY3g9e2N4fSBjeT17Y3l9IHI9e3JhZGl1c30gc3Ryb2tlV2lkdGg9e3N0cm9rZVdpZHRofSAvPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8Y2lyY2xlIGNsYXNzTmFtZT17Y3NzQ2xhc3Nlcy5ERVRFUk1JTkFURV9DSVJDTEV9IGN4PXtjeH0gY3k9e2N5fSByPXtyYWRpdXN9IHN0cm9rZVdpZHRoPXtzdHJva2VXaWR0aH0gc3Ryb2tlRGFzaGFycmF5PXtzdHJva2VEYXNoYXJyYXl9IHN0cm9rZURhc2hvZmZzZXQ9e3N0cm9rZURhc2hvZmZzZXR9IC8+XHJcbiAgICAgICAgICAgICAgICAgICAgPC9zdmc+XHJcbiAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAge2luZGV0ZXJtaW5hdGUgJiZcclxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXtjc3NDbGFzc2VzLklOREVURVJNSU5BVEVfQ09OVEFJTkVSfT5cclxuICAgICAgICAgICAgICAgICAgICB7KGNvbG9yZnVsID8gWzEsIDIsIDMsIDRdIDogWzBdKS5tYXAobiA9PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGtleT17bn0gY2xhc3NOYW1lPXtjbGFzc25hbWVzKGNzc0NsYXNzZXMuU1BJTk5FUl9MQVlFUiwgeyBbYCR7Y3NzQ2xhc3Nlcy5QUk9HUkVTU19DT0xPUn0tJHtufWBdOiBuIH0pfT5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXtgJHtjc3NDbGFzc2VzLkNJUkNMRV9DTElQUEVSfSAke2Nzc0NsYXNzZXMuQ0lSQ0xFX0xFRlR9YH0+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHN2ZyBjbGFzc05hbWU9e2Nzc0NsYXNzZXMuSU5ERVRFUk1JTkFURV9DSVJDTEVfR1JBUEhJQ30gdmlld0JveD17YDAgMCAke3ZpZXdCb3h9ICR7dmlld0JveH1gfSB4bWxucz17c3RyaW5ncy5YTUxOU30+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxjaXJjbGUgY3g9e2N4fSBjeT17Y3l9IHI9e3JhZGl1c30gc3Ryb2tlV2lkdGg9e3N0cm9rZVdpZHRofSBzdHJva2VEYXNoYXJyYXk9e3N0cm9rZURhc2hhcnJheX0gc3Ryb2tlRGFzaG9mZnNldD17aW5kZXRlcm1pbmF0ZVN0cm9rZURhc2hvZmZzZXR9IC8+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9zdmc+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj48ZGl2IGNsYXNzTmFtZT17Y3NzQ2xhc3Nlcy5HQVBfUEFUQ0h9PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzdmcgY2xhc3NOYW1lPXtjc3NDbGFzc2VzLklOREVURVJNSU5BVEVfQ0lSQ0xFX0dSQVBISUN9IHZpZXdCb3g9e2AwIDAgJHt2aWV3Qm94fSAke3ZpZXdCb3h9YH0geG1sbnM9e3N0cmluZ3MuWE1MTlN9PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8Y2lyY2xlIGN4PXtjeH0gY3k9e2N5fSByPXtyYWRpdXN9IHN0cm9rZVdpZHRoPXtnYXBQYXRjaFN0cm9rZVdpZHRofSBzdHJva2VEYXNoYXJyYXk9e3N0cm9rZURhc2hhcnJheX0gc3Ryb2tlRGFzaG9mZnNldD17aW5kZXRlcm1pbmF0ZVN0cm9rZURhc2hvZmZzZXR9IC8+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9zdmc+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj48ZGl2IGNsYXNzTmFtZT17YCR7Y3NzQ2xhc3Nlcy5DSVJDTEVfQ0xJUFBFUn0gJHtjc3NDbGFzc2VzLkNJUkNMRV9SSUdIVH1gfT5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3ZnIGNsYXNzTmFtZT17Y3NzQ2xhc3Nlcy5JTkRFVEVSTUlOQVRFX0NJUkNMRV9HUkFQSElDfSB2aWV3Qm94PXtgMCAwICR7dmlld0JveH0gJHt2aWV3Qm94fWB9IHhtbG5zPXtzdHJpbmdzLlhNTE5TfT5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGNpcmNsZSBjeD17Y3h9IGN5PXtjeX0gcj17cmFkaXVzfSBzdHJva2VXaWR0aD17c3Ryb2tlV2lkdGh9IHN0cm9rZURhc2hhcnJheT17c3Ryb2tlRGFzaGFycmF5fSBzdHJva2VEYXNob2Zmc2V0PXtpbmRldGVybWluYXRlU3Ryb2tlRGFzaG9mZnNldH0gLz5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L3N2Zz5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgICAgICAgICApfVxyXG4gICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICA8L2Rpdj5cclxuICAgICk7XHJcbn0pO1xyXG5cclxuQ2lyY3VsYXJQcm9ncmVzcy5kaXNwbGF5TmFtZSA9ICdNRENDaXJjdWxhclByb2dyZXNzJztcclxuXHJcbkNpcmN1bGFyUHJvZ3Jlc3MucHJvcFR5cGVzID0ge1xyXG4gICAgdmFsdWU6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5udW1iZXIsIFByb3BUeXBlcy5zdHJpbmddKSxcclxuICAgIHNpemU6IFByb3BUeXBlcy5vbmVPZihbc3RyaW5ncy5TTUFMTCwgc3RyaW5ncy5NRURJVU0sIHN0cmluZ3MuTEFSR0VdKSxcclxuICAgIGluZGV0ZXJtaW5hdGU6IFByb3BUeXBlcy5ib29sLFxyXG4gICAgY2xvc2VkOiBQcm9wVHlwZXMuYm9vbCxcclxuICAgIGNvbG9yZnVsOiBQcm9wVHlwZXMuYm9vbFxyXG59O1xyXG5cclxuQ2lyY3VsYXJQcm9ncmVzcy5TaXplID0gU2l6ZTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IENpcmN1bGFyUHJvZ3Jlc3M7IiwiZXhwb3J0IHsgZGVmYXVsdCB9IGZyb20gJy4vQ2lyY3VsYXJQcm9ncmVzcyc7IiwiZXhwb3J0IGNvbnN0IGNzc0NsYXNzZXMgPSB7XHJcbiAgICBST09UOiAnbWRjLWljb24tYnV0dG9uJyxcclxuICAgIFRPVUNIOiAnbWRjLWljb24tYnV0dG9uLS10b3VjaCcsXHJcbiAgICBNQVRFUklBTF9JQ09OUzogJ21hdGVyaWFsLWljb25zJyxcclxuXHJcbiAgICBJQ09OOiAnbWRjLWljb24tYnV0dG9uX19pY29uJyxcclxuICAgIFJJUFBMRTogJ21kYy1pY29uLWJ1dHRvbl9fcmlwcGxlJyxcclxuICAgIFRPVUNIX0VMRU1FTlQ6ICdtZGMtaWNvbi1idXR0b25fX3RvdWNoJ1xyXG59OyIsImltcG9ydCB7IGZvcndhcmRSZWYgfSBmcm9tICdyZWFjdCc7XHJcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XHJcbmltcG9ydCBjbGFzc25hbWVzIGZyb20gJ2NsYXNzbmFtZXMnO1xyXG5cclxuaW1wb3J0IHsgQ2xvbmUgfSBmcm9tICcuLi9jb21wb25lbnQnO1xyXG5cclxuaW1wb3J0IHsgY3NzQ2xhc3NlcyB9IGZyb20gJy4vY29uc3RhbnRzJztcclxuXHJcbmNvbnN0IEljb25CdXR0b24gPSBmb3J3YXJkUmVmKCh7XHJcbiAgICBpY29uLFxyXG4gICAgdG91Y2ggPSBmYWxzZSxcclxuXHJcbiAgICBlbGVtZW50ID0gJ2J1dHRvbicsXHJcbiAgICBjb21wb25lbnQ6IEVsZW1lbnQgPSBlbGVtZW50LFxyXG4gICAgY2xhc3NOYW1lLFxyXG4gICAgY2hpbGRyZW4gPSBpY29uLFxyXG4gICAgLi4ucHJvcHNcclxufSwgcmVmKSA9PiB7XHJcbiAgICBjb25zdCBjbGFzc05hbWVzID0gY2xhc3NuYW1lcyhjc3NDbGFzc2VzLlJPT1QsIHtcclxuICAgICAgICBbY3NzQ2xhc3Nlcy5NQVRFUklBTF9JQ09OU106IHR5cGVvZiBjaGlsZHJlbiA9PT0gJ3N0cmluZycsXHJcbiAgICAgICAgW2Nzc0NsYXNzZXMuVE9VQ0hdOiB0b3VjaFxyXG4gICAgfSwgY2xhc3NOYW1lKTtcclxuXHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAgIDxFbGVtZW50IHJlZj17cmVmfSBjbGFzc05hbWU9e2NsYXNzTmFtZXN9IHsuLi5wcm9wc30+XHJcbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXtjc3NDbGFzc2VzLlJJUFBMRX0gLz5cclxuXHJcbiAgICAgICAgICAgIDxDbG9uZVxyXG4gICAgICAgICAgICAgICAgY29tcG9uZW50PXtjaGlsZHJlbn1cclxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZT17Y3NzQ2xhc3Nlcy5JQ09OfVxyXG4gICAgICAgICAgICAvPlxyXG5cclxuICAgICAgICAgICAge3RvdWNoICYmXHJcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17Y3NzQ2xhc3Nlcy5UT1VDSF9FTEVNRU5UfSAvPlxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgPC9FbGVtZW50PlxyXG4gICAgKTtcclxufSk7XHJcblxyXG5JY29uQnV0dG9uLmRpc3BsYXlOYW1lID0gJ01EQ0ljb25CdXR0b24nO1xyXG5cclxuSWNvbkJ1dHRvbi5wcm9wVHlwZXMgPSB7XHJcbiAgICBpY29uOiBQcm9wVHlwZXMubm9kZVxyXG59O1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgSWNvbkJ1dHRvbjsiLCJleHBvcnQgeyBkZWZhdWx0IH0gZnJvbSAnLi9JY29uQnV0dG9uJzsiLCJleHBvcnQgY29uc3QgY3NzQ2xhc3NlcyA9IHtcclxuICAgIFJPT1Q6ICdtZGMtbGluZWFyLXByb2dyZXNzJyxcclxuICAgIElOREVURVJNSU5BVEU6ICdtZGMtbGluZWFyLXByb2dyZXNzLS1pbmRldGVybWluYXRlJyxcclxuICAgIEFOSU1BVElPTl9SRUFEWTogJ21kYy1saW5lYXItcHJvZ3Jlc3MtLWFuaW1hdGlvbi1yZWFkeScsXHJcbiAgICBDTE9TRUQ6ICdtZGMtbGluZWFyLXByb2dyZXNzLS1jbG9zZWQnLFxyXG4gICAgQ0xPU0VEX0FOSU1BVElPTl9PRkY6ICdtZGMtbGluZWFyLXByb2dyZXNzLS1jbG9zZWQtYW5pbWF0aW9uLW9mZicsXHJcblxyXG4gICAgQlVGRkVSOiAnbWRjLWxpbmVhci1wcm9ncmVzc19fYnVmZmVyJyxcclxuICAgIEJVRkZFUl9CQVI6ICdtZGMtbGluZWFyLXByb2dyZXNzX19idWZmZXItYmFyJyxcclxuICAgIEJVRkZFUl9ET1RTOiAnbWRjLWxpbmVhci1wcm9ncmVzc19fYnVmZmVyLWRvdHMnLFxyXG5cclxuICAgIEJBUjogJ21kYy1saW5lYXItcHJvZ3Jlc3NfX2JhcicsXHJcbiAgICBQUklNQVJZX0JBUjogJ21kYy1saW5lYXItcHJvZ3Jlc3NfX3ByaW1hcnktYmFyJyxcclxuICAgIFNFQ09OREFSWV9CQVI6ICdtZGMtbGluZWFyLXByb2dyZXNzX19zZWNvbmRhcnktYmFyJyxcclxuICAgIEJBUl9JTk5FUjogJ21kYy1saW5lYXItcHJvZ3Jlc3NfX2Jhci1pbm5lcidcclxufTsiLCJpbXBvcnQgeyBmb3J3YXJkUmVmIH0gZnJvbSAncmVhY3QnO1xyXG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xyXG5pbXBvcnQgY2xhc3NuYW1lcyBmcm9tICdjbGFzc25hbWVzJztcclxuXHJcbmltcG9ydCB7IGNzc0NsYXNzZXMgfSBmcm9tICcuL2NvbnN0YW50cyc7XHJcblxyXG5jb25zdCBMaW5lYXJQcm9ncmVzcyA9IGZvcndhcmRSZWYoKHtcclxuICAgIHZhbHVlID0gMCxcclxuICAgIGJ1ZmZlciA9IDAsXHJcbiAgICBpbmRldGVybWluYXRlID0gZmFsc2UsXHJcbiAgICBjbG9zZWQgPSBmYWxzZSxcclxuXHJcbiAgICBjbGFzc05hbWUsXHJcbiAgICAuLi5wcm9wc1xyXG59LCByZWYpID0+IHtcclxuICAgIGNvbnN0IGNsYXNzTmFtZXMgPSBjbGFzc25hbWVzKGNzc0NsYXNzZXMuUk9PVCwge1xyXG4gICAgICAgIFtjc3NDbGFzc2VzLklOREVURVJNSU5BVEVdOiBpbmRldGVybWluYXRlLFxyXG4gICAgICAgIFtjc3NDbGFzc2VzLkFOSU1BVElPTl9SRUFEWV06IGluZGV0ZXJtaW5hdGUsXHJcbiAgICAgICAgW2Nzc0NsYXNzZXMuQ0xPU0VEXTogY2xvc2VkXHJcbiAgICB9LCBjbGFzc05hbWUpO1xyXG5cclxuICAgIGNvbnN0IHByaW1hcnlCYXJTdHlsZSA9IHtcclxuICAgICAgICB0cmFuc2Zvcm06IGBzY2FsZVgoJHtpbmRldGVybWluYXRlID8gMSA6ICh2YWx1ZSA+IDEgPyAodmFsdWUgKiAwLjAxKSA6IHZhbHVlKX0pYFxyXG4gICAgfTtcclxuXHJcbiAgICBjb25zdCBidWZmZXJTdHlsZSA9IHtcclxuICAgICAgICBmbGV4QmFzaXM6IGJ1ZmZlciA/IGAke2luZGV0ZXJtaW5hdGUgPyAxIDogKGJ1ZmZlciA8IDEgPyAoYnVmZmVyICogMTAwKSA6IGJ1ZmZlcil9JWAgOiB1bmRlZmluZWRcclxuICAgIH07XHJcblxyXG4gICAgcmV0dXJuIChcclxuICAgICAgICA8ZGl2XHJcbiAgICAgICAgICAgIHJlZj17cmVmfVxyXG4gICAgICAgICAgICBjbGFzc05hbWU9e2NsYXNzTmFtZXN9XHJcbiAgICAgICAgICAgIHJvbGU9XCJwcm9ncmVzc2JhclwiXHJcbiAgICAgICAgICAgIGFyaWEtdmFsdWVtaW49XCIwXCJcclxuICAgICAgICAgICAgYXJpYS12YWx1ZW1heD1cIjFcIlxyXG4gICAgICAgICAgICBhcmlhLXZhbHVlbm93PXt2YWx1ZSA+IDEgPyAodmFsdWUgKiAwLjAxKSA6IHZhbHVlfVxyXG4gICAgICAgICAgICB7Li4ucHJvcHN9XHJcbiAgICAgICAgPlxyXG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17Y3NzQ2xhc3Nlcy5CVUZGRVJ9PlxyXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9e2Nzc0NsYXNzZXMuQlVGRkVSX0JBUn0gc3R5bGU9e2J1ZmZlclN0eWxlfSAvPlxyXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9e2Nzc0NsYXNzZXMuQlVGRkVSX0RPVFN9IC8+XHJcbiAgICAgICAgICAgIDwvZGl2PlxyXG5cclxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9e2Ake2Nzc0NsYXNzZXMuQkFSfSAke2Nzc0NsYXNzZXMuUFJJTUFSWV9CQVJ9YH0gc3R5bGU9e3ByaW1hcnlCYXJTdHlsZX0+XHJcbiAgICAgICAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9e2Nzc0NsYXNzZXMuQkFSX0lOTkVSfSAvPlxyXG4gICAgICAgICAgICA8L2Rpdj5cclxuXHJcbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXtgJHtjc3NDbGFzc2VzLkJBUn0gJHtjc3NDbGFzc2VzLlNFQ09OREFSWV9CQVJ9YH0+XHJcbiAgICAgICAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9e2Nzc0NsYXNzZXMuQkFSX0lOTkVSfSAvPlxyXG4gICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICA8L2Rpdj5cclxuICAgICk7XHJcbn0pO1xyXG5cclxuTGluZWFyUHJvZ3Jlc3MuZGlzcGxheU5hbWUgPSAnTURDTGluZWFyUHJvZ3Jlc3MnO1xyXG5cclxuTGluZWFyUHJvZ3Jlc3MucHJvcFR5cGVzID0ge1xyXG4gICAgdmFsdWU6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5udW1iZXIsIFByb3BUeXBlcy5zdHJpbmddKSxcclxuICAgIGJ1ZmZlcjogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLm51bWJlciwgUHJvcFR5cGVzLnN0cmluZ10pLFxyXG4gICAgaW5kZXRlcm1pbmF0ZTogUHJvcFR5cGVzLmJvb2wsXHJcbiAgICBjbG9zZWQ6IFByb3BUeXBlcy5ib29sXHJcbn07XHJcblxyXG5leHBvcnQgZGVmYXVsdCBMaW5lYXJQcm9ncmVzczsiLCJleHBvcnQgeyBkZWZhdWx0IH0gZnJvbSAnLi9MaW5lYXJQcm9ncmVzcyc7IiwiZXhwb3J0IGNvbnN0IGNzc0NsYXNzZXMgPSB7XHJcbiAgICBST09UOiAnbWRjLWRhdGEtdGFibGUnLFxyXG4gICAgU1RJQ0tZX0hFQURFUjogJ21kYy1kYXRhLXRhYmxlLS1zdGlja3ktaGVhZGVyJyxcclxuICAgIElOX1BST0dSRVNTOiAnbWRjLWRhdGEtdGFibGUtLWluLXByb2dyZXNzJyxcclxuXHJcbiAgICBUQUJMRV9DT05UQUlORVI6ICdtZGMtZGF0YS10YWJsZV9fdGFibGUtY29udGFpbmVyJyxcclxuICAgIFRBQkxFOiAnbWRjLWRhdGEtdGFibGVfX3RhYmxlJyxcclxuXHJcbiAgICBIRUFERVI6ICdtZGMtZGF0YS10YWJsZV9faGVhZGVyJyxcclxuICAgIEhFQURFUl9ST1c6ICdtZGMtZGF0YS10YWJsZV9faGVhZGVyLXJvdycsXHJcbiAgICBIRUFERVJfUk9XX0NIRUNLQk9YOiAnbWRjLWRhdGEtdGFibGVfX2hlYWRlci1yb3ctY2hlY2tib3gnLFxyXG4gICAgSEVBREVSX0NFTEw6ICdtZGMtZGF0YS10YWJsZV9faGVhZGVyLWNlbGwnLFxyXG4gICAgSEVBREVSX0NFTExfQ0hFQ0tCT1g6ICdtZGMtZGF0YS10YWJsZV9faGVhZGVyLWNlbGwtLWNoZWNrYm94JyxcclxuICAgIEhFQURFUl9DRUxMX05VTUVSSUM6ICdtZGMtZGF0YS10YWJsZV9faGVhZGVyLWNlbGwtLW51bWVyaWMnLFxyXG4gICAgSEVBREVSX0NFTExfV0lUSF9TT1JUOiAnbWRjLWRhdGEtdGFibGVfX2hlYWRlci1jZWxsLS13aXRoLXNvcnQnLFxyXG4gICAgSEVBREVSX0NFTExfU09SVEVEOiAnbWRjLWRhdGEtdGFibGVfX2hlYWRlci1jZWxsLS1zb3J0ZWQnLFxyXG4gICAgSEVBREVSX0NFTExfU09SVEVEX0RFU0M6ICdtZGMtZGF0YS10YWJsZV9faGVhZGVyLWNlbGwtLXNvcnRlZC1kZXNjZW5kaW5nJyxcclxuICAgIEhFQURFUl9DRUxMX1dSQVBQRVI6ICdtZGMtZGF0YS10YWJsZV9faGVhZGVyLWNlbGwtd3JhcHBlcicsXHJcbiAgICBIRUFERVJfQ0VMTF9MQUJFTDogJ21kYy1kYXRhLXRhYmxlX19oZWFkZXItY2VsbC1sYWJlbCcsXHJcblxyXG4gICAgQ09OVEVOVDogJ21kYy1kYXRhLXRhYmxlX19jb250ZW50JyxcclxuXHJcbiAgICBST1c6ICdtZGMtZGF0YS10YWJsZV9fcm93JyxcclxuICAgIFJPV19DSEVDS0JPWDogJ21kYy1kYXRhLXRhYmxlX19yb3ctY2hlY2tib3gnLFxyXG4gICAgUk9XX1NFTEVDVEVEOiAnbWRjLWRhdGEtdGFibGVfX3Jvdy0tc2VsZWN0ZWQnLFxyXG5cclxuICAgIENFTEw6ICdtZGMtZGF0YS10YWJsZV9fY2VsbCcsXHJcbiAgICBDRUxMX0NIRUNLQk9YOiAnbWRjLWRhdGEtdGFibGVfX2NlbGwtLWNoZWNrYm94JyxcclxuICAgIENFTExfTlVNRVJJQzogJ21kYy1kYXRhLXRhYmxlX19jZWxsLS1udW1lcmljJyxcclxuXHJcbiAgICBQQUdJTkFUSU9OOiAnbWRjLWRhdGEtdGFibGVfX3BhZ2luYXRpb24nLFxyXG4gICAgUEFHSU5BVElPTl9UUkFJTElORzogJ21kYy1kYXRhLXRhYmxlX19wYWdpbmF0aW9uLXRyYWlsaW5nJyxcclxuICAgIFBBR0lOQVRJT05fUk9XU19QRVJfUEFHRTogJ21kYy1kYXRhLXRhYmxlX19wYWdpbmF0aW9uLXJvd3MtcGVyLXBhZ2UnLFxyXG4gICAgUEFHSU5BVElPTl9ST1dTX1BFUl9QQUdFX0xBQkVMOiAnbWRjLWRhdGEtdGFibGVfX3BhZ2luYXRpb24tcm93cy1wZXItcGFnZS1sYWJlbCcsXHJcbiAgICBQQUdJTkFUSU9OX1JPV1NfUEVSX1BBR0VfU0VMRUNUOiAnbWRjLWRhdGEtdGFibGVfX3BhZ2luYXRpb24tcm93cy1wZXItcGFnZS1zZWxlY3QnLFxyXG4gICAgUEFHSU5BVElPTl9OQVZJR0FUSU9OOiAnbWRjLWRhdGEtdGFibGVfX3BhZ2luYXRpb24tbmF2aWdhdGlvbicsXHJcbiAgICBQQUdJTkFUSU9OX1RPVEFMOiAnbWRjLWRhdGEtdGFibGVfX3BhZ2luYXRpb24tdG90YWwnLFxyXG4gICAgUEFHSU5BVElPTl9CVVRUT046ICdtZGMtZGF0YS10YWJsZV9fcGFnaW5hdGlvbi1idXR0b24nLFxyXG5cclxuICAgIFNPUlRfSUNPTl9CVVRUT046ICdtZGMtZGF0YS10YWJsZV9fc29ydC1pY29uLWJ1dHRvbicsXHJcbiAgICBTT1JUX1NUQVRVU19MQUJFTDogJ21kYy1kYXRhLXRhYmxlX19zb3J0LXN0YXR1cy1sYWJlbCcsXHJcbiAgICBQUk9HUkVTU19JTkRJQ0FUT1I6ICdtZGMtZGF0YS10YWJsZV9fcHJvZ3Jlc3MtaW5kaWNhdG9yJyxcclxuICAgIFNDUklNOiAnbWRjLWRhdGEtdGFibGVfX3NjcmltJyxcclxuICAgIEZPT1RFUjogJ21kYy1kYXRhLXRhYmxlX19mb290ZXInLFxyXG4gICAgTElORUFSX1BST0dSRVNTOiAnbWRjLWRhdGEtdGFibGVfX2xpbmVhci1wcm9ncmVzcydcclxufTsiLCJpbXBvcnQgeyBmb3J3YXJkUmVmIH0gZnJvbSAncmVhY3QnO1xyXG5cclxuaW1wb3J0IExpbmVhclByb2dyZXNzIGZyb20gJy4uL2xpbmVhci1wcm9ncmVzcyc7XHJcblxyXG5pbXBvcnQgeyBjc3NDbGFzc2VzIH0gZnJvbSAnLi9jb25zdGFudHMnO1xyXG5cclxuY29uc3QgRGF0YVRhYmxlUHJvZ3Jlc3NJbmRpY2F0b3IgPSBmb3J3YXJkUmVmKChwcm9wcywgcmVmKSA9PiB7XHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAgIDxkaXYgcmVmPXtyZWZ9IGNsYXNzTmFtZT17Y3NzQ2xhc3Nlcy5QUk9HUkVTU19JTkRJQ0FUT1J9IHsuLi5wcm9wc30+XHJcbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXtjc3NDbGFzc2VzLlNDUklNfSAvPlxyXG5cclxuICAgICAgICAgICAgPExpbmVhclByb2dyZXNzIGNsYXNzTmFtZT17Y3NzQ2xhc3Nlcy5MSU5FQVJfUFJPR1JFU1N9IGluZGV0ZXJtaW5hdGUgLz5cclxuICAgICAgICA8L2Rpdj5cclxuICAgICk7XHJcbn0pO1xyXG5cclxuRGF0YVRhYmxlUHJvZ3Jlc3NJbmRpY2F0b3IuZGlzcGxheU5hbWUgPSAnTURDRGF0YVRhYmxlUHJvZ3Jlc3NJbmRpY2F0b3InO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgRGF0YVRhYmxlUHJvZ3Jlc3NJbmRpY2F0b3I7IiwiZXhwb3J0IGNvbnN0IGNzc0NsYXNzZXMgPSB7XHJcbiAgICBST09UOiAnbWRjLWZsb2F0aW5nLWxhYmVsJyxcclxuICAgIEZMT0FUOiAnbWRjLWZsb2F0aW5nLWxhYmVsLS1mbG9hdC1hYm92ZScsXHJcbiAgICBSRVFVSVJFRDogJ21kYy1mbG9hdGluZy1sYWJlbC0tcmVxdWlyZWQnXHJcbn07IiwiaW1wb3J0IHsgZm9yd2FyZFJlZiB9IGZyb20gJ3JlYWN0JztcclxuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcclxuaW1wb3J0IGNsYXNzbmFtZXMgZnJvbSAnY2xhc3NuYW1lcyc7XHJcblxyXG5pbXBvcnQgeyBjc3NDbGFzc2VzIH0gZnJvbSAnLi9jb25zdGFudHMnO1xyXG5cclxuY29uc3QgRmxvYXRpbmdMYWJlbCA9IGZvcndhcmRSZWYoKHtcclxuICAgIGxhYmVsLFxyXG4gICAgZmxvYXQgPSBmYWxzZSxcclxuICAgIHJlcXVpcmVkID0gZmFsc2UsXHJcblxyXG4gICAgY2xhc3NOYW1lLFxyXG4gICAgY2hpbGRyZW4gPSBsYWJlbCxcclxuICAgIC4uLnByb3BzXHJcbn0sIHJlZikgPT4ge1xyXG4gICAgY29uc3QgY2xhc3NOYW1lcyA9IGNsYXNzbmFtZXMoY3NzQ2xhc3Nlcy5ST09ULCB7XHJcbiAgICAgICAgW2Nzc0NsYXNzZXMuRkxPQVRdOiBmbG9hdCxcclxuICAgICAgICBbY3NzQ2xhc3Nlcy5SRVFVSVJFRF06IHJlcXVpcmVkXHJcbiAgICB9LCBjbGFzc05hbWUpO1xyXG5cclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgPHNwYW4gcmVmPXtyZWZ9IGNsYXNzTmFtZT17Y2xhc3NOYW1lc30gey4uLnByb3BzfT5cclxuICAgICAgICAgICAge2NoaWxkcmVufVxyXG4gICAgICAgIDwvc3Bhbj5cclxuICAgICk7XHJcbn0pO1xyXG5cclxuRmxvYXRpbmdMYWJlbC5kaXNwbGF5TmFtZSA9ICdNRENGbG9hdGluZ0xhYmVsJztcclxuXHJcbkZsb2F0aW5nTGFiZWwucHJvcFR5cGVzID0ge1xyXG4gICAgbGFiZWw6IFByb3BUeXBlcy5zdHJpbmcsXHJcbiAgICBmbG9hdDogUHJvcFR5cGVzLmJvb2wsXHJcbiAgICByZXF1aXJlZDogUHJvcFR5cGVzLmJvb2xcclxufTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IEZsb2F0aW5nTGFiZWw7IiwiZXhwb3J0IHsgZGVmYXVsdCB9IGZyb20gJy4vRmxvYXRpbmdMYWJlbCc7IiwiZXhwb3J0IGNvbnN0IGNzc0NsYXNzZXMgPSB7XHJcbiAgICBST09UOiAnbWRjLWxpbmUtcmlwcGxlJyxcclxuICAgIEFDVElWRTogJ21kYy1saW5lLXJpcHBsZS0tYWN0aXZlJyxcclxuICAgIERFQUNUSVZBVElORzogJ21kYy1saW5lLXJpcHBsZS0tZGVhY3RpdmF0aW5nJ1xyXG59OyIsImltcG9ydCB7IGZvcndhcmRSZWYgfSBmcm9tICdyZWFjdCc7XHJcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XHJcbmltcG9ydCBjbGFzc25hbWVzIGZyb20gJ2NsYXNzbmFtZXMnO1xyXG5cclxuaW1wb3J0IHsgY3NzQ2xhc3NlcyB9IGZyb20gJy4vY29uc3RhbnRzJztcclxuXHJcbmNvbnN0IExpbmVSaXBwbGUgPSBmb3J3YXJkUmVmKCh7XHJcbiAgICBhY3RpdmUgPSBmYWxzZSxcclxuICAgIHRyYW5zZm9ybU9yaWdpbixcclxuXHJcbiAgICAuLi5wcm9wc1xyXG59LCByZWYpID0+IHtcclxuICAgIGNvbnN0IHN0eWxlID0gdHJhbnNmb3JtT3JpZ2luICYmIHtcclxuICAgICAgICB0cmFuc2Zvcm1PcmlnaW46IGAke3RyYW5zZm9ybU9yaWdpbn1weGBcclxuICAgIH07XHJcblxyXG4gICAgY29uc3QgY2xhc3NOYW1lcyA9IGNsYXNzbmFtZXMoY3NzQ2xhc3Nlcy5ST09ULCB7XHJcbiAgICAgICAgW2Nzc0NsYXNzZXMuQUNUSVZFXTogYWN0aXZlXHJcbiAgICB9KTtcclxuXHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAgIDxzcGFuXHJcbiAgICAgICAgICAgIHJlZj17cmVmfVxyXG4gICAgICAgICAgICBzdHlsZT17c3R5bGV9XHJcbiAgICAgICAgICAgIGNsYXNzTmFtZT17Y2xhc3NOYW1lc31cclxuICAgICAgICAgICAgey4uLnByb3BzfVxyXG4gICAgICAgIC8+XHJcbiAgICApO1xyXG59KTtcclxuXHJcbkxpbmVSaXBwbGUuZGlzcGxheU5hbWUgPSAnTURDTGluZVJpcHBsZSc7XHJcblxyXG5MaW5lUmlwcGxlLnByb3BUeXBlcyA9IHtcclxuICAgIGFjdGl2ZTogUHJvcFR5cGVzLmJvb2xcclxufTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IExpbmVSaXBwbGU7IiwiZXhwb3J0IHsgZGVmYXVsdCB9IGZyb20gJy4vTGluZVJpcHBsZSc7IiwiZXhwb3J0IGNvbnN0IG51bWJlcnMgPSB7XHJcbiAgICBOT1RDSF9TSVpFX0ZBQ1RPUjogMC43NVxyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IGNzc0NsYXNzZXMgPSB7XHJcbiAgICBST09UOiAnbWRjLW5vdGNoZWQtb3V0bGluZScsXHJcbiAgICBOT1RDSEVEOiAnbWRjLW5vdGNoZWQtb3V0bGluZS0tbm90Y2hlZCcsXHJcbiAgICBVUEdSQURFRDogJ21kYy1ub3RjaGVkLW91dGxpbmUtLXVwZ3JhZGVkJyxcclxuICAgIE5PX0xBQkVMOiAnbWRjLW5vdGNoZWQtb3V0bGluZS0tbm8tbGFiZWwnLFxyXG5cclxuICAgIExFQURJTkc6ICdtZGMtbm90Y2hlZC1vdXRsaW5lX19sZWFkaW5nJyxcclxuICAgIE5PVENIOiAnbWRjLW5vdGNoZWQtb3V0bGluZV9fbm90Y2gnLFxyXG4gICAgVFJBSUxJTkc6ICdtZGMtbm90Y2hlZC1vdXRsaW5lX190cmFpbGluZydcclxufTsiLCJpbXBvcnQgeyBmb3J3YXJkUmVmLCB1c2VSZWYsIHVzZUxheW91dEVmZmVjdCB9IGZyb20gJ3JlYWN0JztcclxuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcclxuaW1wb3J0IGNsYXNzbmFtZXMgZnJvbSAnY2xhc3NuYW1lcyc7XHJcblxyXG5pbXBvcnQgeyBudW1iZXJzLCBjc3NDbGFzc2VzIH0gZnJvbSAnLi9jb25zdGFudHMnO1xyXG5cclxuY29uc3QgTm90Y2hlZE91dGxpbmUgPSBmb3J3YXJkUmVmKCh7XHJcbiAgICBub3RjaGVkID0gZmFsc2UsXHJcblxyXG4gICAgY2xhc3NOYW1lLFxyXG4gICAgY2hpbGRyZW4sXHJcbiAgICAuLi5wcm9wc1xyXG59LCByZWYpID0+IHtcclxuICAgIGNvbnN0IG5vdGNoUmVmID0gdXNlUmVmKCk7XHJcblxyXG4gICAgdXNlTGF5b3V0RWZmZWN0KCgpID0+IHtcclxuICAgICAgICBpZiAoIW5vdGNoUmVmLmN1cnJlbnQpIHJldHVybjtcclxuXHJcbiAgICAgICAgaWYgKG5vdGNoZWQpIHtcclxuICAgICAgICAgICAgbm90Y2hSZWYuY3VycmVudC5zdHlsZS53aWR0aCA9IGAkeyhub3RjaFJlZi5jdXJyZW50LmNsaWVudFdpZHRoICsgMikgKiBudW1iZXJzLk5PVENIX1NJWkVfRkFDVE9SfXB4YDtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBub3RjaFJlZi5jdXJyZW50LnN0eWxlLndpZHRoID0gJ2F1dG8nO1xyXG4gICAgICAgIH1cclxuICAgIH0sIFtub3RjaGVkXSk7XHJcblxyXG4gICAgY29uc3QgY2xhc3NOYW1lcyA9IGNsYXNzbmFtZXMoY3NzQ2xhc3Nlcy5ST09ULCBjc3NDbGFzc2VzLlVQR1JBREVELCB7XHJcbiAgICAgICAgW2Nzc0NsYXNzZXMuTk9UQ0hFRF06IG5vdGNoZWQsXHJcbiAgICAgICAgW2Nzc0NsYXNzZXMuTk9fTEFCRUxdOiAhY2hpbGRyZW5cclxuICAgIH0sIGNsYXNzTmFtZSk7XHJcblxyXG4gICAgcmV0dXJuIChcclxuICAgICAgICA8c3BhbiByZWY9e3JlZn0gY2xhc3NOYW1lPXtjbGFzc05hbWVzfSB7Li4ucHJvcHN9PlxyXG4gICAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9e2Nzc0NsYXNzZXMuTEVBRElOR30gLz5cclxuXHJcbiAgICAgICAgICAgIHtjaGlsZHJlbiAmJlxyXG4gICAgICAgICAgICAgICAgPHNwYW4gcmVmPXtub3RjaFJlZn0gY2xhc3NOYW1lPXtjc3NDbGFzc2VzLk5PVENIfT5cclxuICAgICAgICAgICAgICAgICAgICB7Y2hpbGRyZW59XHJcbiAgICAgICAgICAgICAgICA8L3NwYW4+XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT17Y3NzQ2xhc3Nlcy5UUkFJTElOR30gLz5cclxuICAgICAgICA8L3NwYW4+XHJcbiAgICApO1xyXG59KTtcclxuXHJcbk5vdGNoZWRPdXRsaW5lLmRpc3BsYXlOYW1lID0gJ01EQ05vdGNoZWRPdXRsaW5lJztcclxuXHJcbk5vdGNoZWRPdXRsaW5lLnByb3BUeXBlcyA9IHtcclxuICAgIG5vdGNoZWQ6IFByb3BUeXBlcy5ib29sXHJcbn07XHJcblxyXG5leHBvcnQgZGVmYXVsdCBOb3RjaGVkT3V0bGluZTsiLCJleHBvcnQgeyBkZWZhdWx0IH0gZnJvbSAnLi9Ob3RjaGVkT3V0bGluZSc7IiwiZXhwb3J0IGNvbnN0IG51bWJlcnMgPSB7XHJcbiAgICBUUkFOU0lUSU9OX09QRU5fRFVSQVRJT046IDEyMCxcclxuICAgIFRSQU5TSVRJT05fQ0xPU0VfRFVSQVRJT046IDc1LFxyXG4gICAgTUFSR0lOX1RPX0VER0U6IDMyLFxyXG4gICAgQU5DSE9SX1RPX01FTlVfU1VSRkFDRV9XSURUSF9SQVRJTzogMC42NyxcclxuICAgIFRPVUNIX0VWRU5UX1dBSVRfTVM6IDMwXHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgY3NzQ2xhc3NlcyA9IHtcclxuICAgIFJPT1Q6ICdtZGMtbWVudScsXHJcblxyXG4gICAgU1VSRkFDRTogJ21kYy1tZW51LXN1cmZhY2UnLFxyXG4gICAgU1VSRkFDRV9BTkNIT1I6ICdtZGMtbWVudS1zdXJmYWNlLS1hbmNob3InLFxyXG4gICAgU1VSRkFDRV9GSVhFRDogJ21kYy1tZW51LXN1cmZhY2UtLWZpeGVkJyxcclxuICAgIFNVUkZBQ0VfT1BFTjogJ21kYy1tZW51LXN1cmZhY2UtLW9wZW4nLFxyXG4gICAgU1VSRkFDRV9BTklNQVRJTkdfT1BFTjogJ21kYy1tZW51LXN1cmZhY2UtLWFuaW1hdGluZy1vcGVuJyxcclxuICAgIFNVUkZBQ0VfQU5JTUFUSU5HX0NMT1NFRDogJ21kYy1tZW51LXN1cmZhY2UtLWFuaW1hdGluZy1jbG9zZWQnLFxyXG4gICAgU1VSRkFDRV9CRUxPV19BTkNIT1I6ICdtZGMtbWVudS1zdXJmYWNlLS1pcy1vcGVuLWJlbG93JyxcclxuXHJcbiAgICBJVEVNOiAnbWRjLW1lbnUtaXRlbScsXHJcbiAgICBJVEVNX1NFTEVDVEVEOiAnbWRjLW1lbnUtaXRlbS0tc2VsZWN0ZWQnLFxyXG5cclxuICAgIFNFTEVDVElPTl9HUk9VUDogJ21kYy1tZW51X19zZWxlY3Rpb24tZ3JvdXAnLFxyXG4gICAgU0VMRUNUSU9OX0dST1VQX0lDT046ICdtZGMtbWVudV9fc2VsZWN0aW9uLWdyb3VwLWljb24nXHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgT3JpZ2luID0ge1xyXG4gICAgVE9QX0xFRlQ6ICd0b3AgbGVmdCcsXHJcbiAgICBUT1BfQ0VOVEVSOiAndG9wIGNlbnRlcicsXHJcbiAgICBUT1BfUklHSFQ6ICd0b3AgcmlnaHQnLFxyXG4gICAgQ0VOVEVSX0xFRlQ6ICdjZW50ZXIgbGVmdCcsXHJcbiAgICBDRU5URVI6ICdjZW50ZXIgY2VudGVyJyxcclxuICAgIENFTlRFUl9SSUdIVDogJ2NlbnRlciByaWdodCcsXHJcbiAgICBCT1RUT01fTEVGVDogJ2JvdHRvbSBsZWZ0JyxcclxuICAgIEJPVFRPTV9DRU5URVI6ICdib3R0b20gY2VudGVyJyxcclxuICAgIEJPVFRPTV9SSUdIVDogJ2JvdHRvbSByaWdodCdcclxufTsiLCJpbXBvcnQgeyB1c2VFZmZlY3QsIHVzZUxheW91dEVmZmVjdCwgdXNlU3RhdGUgfSBmcm9tICdyZWFjdCc7XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gdXNlQ3JlYXRlZChmbikge1xyXG4gICAgY29uc3QgW2NyZWF0ZWQsIHNldENyZWF0ZWRdID0gdXNlU3RhdGUoZmFsc2UpO1xyXG5cclxuICAgIGlmIChjcmVhdGVkKSByZXR1cm47XHJcblxyXG4gICAgZm4oKTtcclxuICAgIHNldENyZWF0ZWQodHJ1ZSk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiB1c2VNb3VudGVkKGZuKSB7XHJcbiAgICB1c2VFZmZlY3QoKCkgPT4gZm4oKSwgW10pO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gdXNlVXBkYXRlZChmbiwgZGVwcykge1xyXG4gICAgY29uc3QgW21vdW50ZWQsIHNldE1vdW50ZWRdID0gdXNlU3RhdGUoZmFsc2UpO1xyXG5cclxuICAgIHVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICAgICAgaWYgKCFtb3VudGVkKSByZXR1cm4gc2V0TW91bnRlZCh0cnVlKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIGZuKCk7XHJcbiAgICB9LCBkZXBzKTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIHVzZVVwZGF0ZWRTeW5jKGZuLCBkZXBzKSB7XHJcbiAgICBjb25zdCBbbW91bnRlZCwgc2V0TW91bnRlZF0gPSB1c2VTdGF0ZShmYWxzZSk7XHJcblxyXG4gICAgdXNlTGF5b3V0RWZmZWN0KCgpID0+IHtcclxuICAgICAgICBpZiAoIW1vdW50ZWQpIHJldHVybiBzZXRNb3VudGVkKHRydWUpO1xyXG5cclxuICAgICAgICByZXR1cm4gZm4oKTtcclxuICAgIH0sIGRlcHMpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gdXNlVW5tb3VudGVkKGZuKSB7XHJcbiAgICB1c2VFZmZlY3QoKCkgPT4gKCkgPT4gZm4oKSwgW10pO1xyXG59IiwiZXhwb3J0IGNvbnN0IGxpc3RDc3NDbGFzc2VzID0ge1xyXG4gICAgUk9PVDogJ21kYy1saXN0J1xyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IGxpc3RJdGVtQ3NzQ2xhc3NlcyA9IHtcclxuICAgIFJPT1Q6ICdtZGMtbGlzdC1pdGVtJyxcclxuICAgIEFDVElWQVRFRDogJ21kYy1saXN0LWl0ZW0tLWFjdGl2YXRlZCcsXHJcbiAgICBTRUxFQ1RFRDogJ21kYy1saXN0LWl0ZW0tLXNlbGVjdGVkJyxcclxuICAgIERJU0FCTEVEOiAnbWRjLWxpc3QtaXRlbS0tZGlzYWJsZWQnLFxyXG4gICAgTk9OX0lOVEVSQUNUSVZFOiAnbWRjLWxpc3QtaXRlbS0tbm9uLWludGVyYWN0aXZlJyxcclxuXHJcbiAgICBPTkVfTElORTogJ21kYy1saXN0LWl0ZW0tLXdpdGgtb25lLWxpbmUnLFxyXG4gICAgVFdPX0xJTkVTOiAnbWRjLWxpc3QtaXRlbS0td2l0aC10d28tbGluZXMnLFxyXG4gICAgVEhSRUVfTElORVM6ICdtZGMtbGlzdC1pdGVtLS13aXRoLXRocmVlLWxpbmVzJyxcclxuICAgIE9WRVJMSU5FOiAnbWRjLWxpc3QtaXRlbS0td2l0aC1vdmVybGluZScsXHJcbiAgICBMRUFESU5HX0lDT046ICdtZGMtbGlzdC1pdGVtLS13aXRoLWxlYWRpbmctaWNvbicsXHJcbiAgICBMRUFESU5HX0lNQUdFOiAnbWRjLWxpc3QtaXRlbS0td2l0aC1sZWFkaW5nLWltYWdlJyxcclxuICAgIExFQURJTkdfVEhVTUJOQUlMOiAnbWRjLWxpc3QtaXRlbS0td2l0aC1sZWFkaW5nLXRodW1ibmFpbCcsXHJcbiAgICBMRUFESU5HX1ZJREVPOiAnbWRjLWxpc3QtaXRlbS0td2l0aC1sZWFkaW5nLXZpZGVvJyxcclxuICAgIExFQURJTkdfQ0hFQ0tCT1g6ICdtZGMtbGlzdC1pdGVtLS13aXRoLWxlYWRpbmctY2hlY2tib3gnLFxyXG4gICAgTEVBRElOR19SQURJTzogJ21kYy1saXN0LWl0ZW0tLXdpdGgtbGVhZGluZy1yYWRpbycsXHJcbiAgICBMRUFESU5HX1NXSVRDSDogJ21kYy1saXN0LWl0ZW0tLXdpdGgtbGVhZGluZy1zd2l0Y2gnLFxyXG4gICAgVFJBSUxJTkdfSUNPTjogJ21kYy1saXN0LWl0ZW0tLXdpdGgtdHJhaWxpbmctaWNvbicsXHJcbiAgICBUUkFJTElOR19NRVRBOiAnbWRjLWxpc3QtaXRlbS0td2l0aC10cmFpbGluZy1tZXRhJyxcclxuICAgIFRSQUlMSU5HX0NIRUNLQk9YOiAnbWRjLWxpc3QtaXRlbS0td2l0aC10cmFpbGluZy1jaGVja2JveCcsXHJcbiAgICBUUkFJTElOR19SQURJTzogJ21kYy1saXN0LWl0ZW0tLXdpdGgtdHJhaWxpbmctcmFkaW8nLFxyXG4gICAgVFJBSUxJTkdfU1dJVENIOiAnbWRjLWxpc3QtaXRlbS0td2l0aC10cmFpbGluZy1zd2l0Y2gnLFxyXG5cclxuICAgIFNUQVJUOiAnbWRjLWxpc3QtaXRlbV9fc3RhcnQnLFxyXG4gICAgQ09OVEVOVDogJ21kYy1saXN0LWl0ZW1fX2NvbnRlbnQnLFxyXG4gICAgRU5EOiAnbWRjLWxpc3QtaXRlbV9fZW5kJyxcclxuXHJcbiAgICBPVkVSTElORV9URVhUOiAnbWRjLWxpc3QtaXRlbV9fb3ZlcmxpbmUtdGV4dCcsXHJcbiAgICBQUklNQVJZX1RFWFQ6ICdtZGMtbGlzdC1pdGVtX19wcmltYXJ5LXRleHQnLFxyXG4gICAgU0VDT05EQVJZX1RFWFQ6ICdtZGMtbGlzdC1pdGVtX19zZWNvbmRhcnktdGV4dCcsXHJcblxyXG4gICAgUklQUExFOiAnbWRjLWxpc3QtaXRlbV9fcmlwcGxlJ1xyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IGxpc3RHcm91cENzc0NsYXNzZXMgPSB7XHJcbiAgICBST09UOiAnbWRjLWxpc3QtZ3JvdXAnLFxyXG4gICAgU1VCSEVBREVSOiAnbWRjLWxpc3QtZ3JvdXBfX3N1YmhlYWRlcidcclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCBsaXN0RGl2aWRlckNzc0NsYXNzZXMgPSB7XHJcbiAgICBST09UOiAnbWRjLWxpc3QtZGl2aWRlcicsXHJcbiAgICBMRUFESU5HX1RFWFQ6ICdtZGMtbGlzdC1kaXZpZGVyLS13aXRoLWxlYWRpbmctdGV4dCcsXHJcbiAgICBMRUFESU5HX0lDT046ICdtZGMtbGlzdC1kaXZpZGVyLS13aXRoLWxlYWRpbmctaWNvbicsXHJcbiAgICBMRUFESU5HX0lNQUdFOiAnbWRjLWxpc3QtZGl2aWRlci0td2l0aC1sZWFkaW5nLWltYWdlJyxcclxuICAgIExFQURJTkdfVklERU86ICdtZGMtbGlzdC1kaXZpZGVyLS13aXRoLWxlYWRpbmctdmlkZW8nLFxyXG4gICAgTEVBRElOR19USFVNQk5BSUw6ICdtZGMtbGlzdC1kaXZpZGVyLS13aXRoLWxlYWRpbmctdGh1bWJuYWlsJyxcclxuICAgIExFQURJTkdfQVZBVEFSOiAnbWRjLWxpc3QtZGl2aWRlci0td2l0aC1sZWFkaW5nLWF2YXRhcicsXHJcbiAgICBMRUFESU5HX0NIRUNLQk9YOiAnbWRjLWxpc3QtZGl2aWRlci0td2l0aC1sZWFkaW5nLWNoZWNrYm94JyxcclxuICAgIExFQURJTkdfU1dJVENIOiAnbWRjLWxpc3QtZGl2aWRlci0td2l0aC1sZWFkaW5nLXN3aXRjaCcsXHJcbiAgICBMRUFESU5HX1JBRElPOiAnbWRjLWxpc3QtZGl2aWRlci0td2l0aC1sZWFkaW5nLXJhZGlvJyxcclxufTsiLCJpbXBvcnQgeyBmb3J3YXJkUmVmIH0gZnJvbSAncmVhY3QnO1xyXG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xyXG5pbXBvcnQgY2xhc3NuYW1lcyBmcm9tICdjbGFzc25hbWVzJztcclxuXHJcbmltcG9ydCB7IENsb25lIH0gZnJvbSAnLi4vY29tcG9uZW50JztcclxuXHJcbmltcG9ydCB7IGxpc3RJdGVtQ3NzQ2xhc3NlcyBhcyBjc3NDbGFzc2VzIH0gZnJvbSAnLi9jb25zdGFudHMnO1xyXG5cclxuY29uc3QgTGlzdEl0ZW1Db250ZW50ID0gZm9yd2FyZFJlZigoe1xyXG4gICAgb3ZlcmxpbmUsXHJcbiAgICBwcmltYXJ5LFxyXG4gICAgc2Vjb25kYXJ5LFxyXG4gICAgb3ZlcmxpbmVUZXh0ID0gb3ZlcmxpbmUsXHJcbiAgICBwcmltYXJ5VGV4dCA9IHByaW1hcnksXHJcbiAgICBzZWNvbmRhcnlUZXh0ID0gc2Vjb25kYXJ5LFxyXG5cclxuICAgIGVsZW1lbnQgPSAnc3BhbicsXHJcbiAgICBjb21wb25lbnQ6IEVsZW1lbnQgPSBlbGVtZW50LFxyXG4gICAgY2xhc3NOYW1lLFxyXG4gICAgY2hpbGRyZW4sXHJcbiAgICAuLi5wcm9wc1xyXG59LCByZWYpID0+IHtcclxuICAgIGNvbnN0IGNsYXNzTmFtZXMgPSBjbGFzc25hbWVzKGNzc0NsYXNzZXMuQ09OVEVOVCwgY2xhc3NOYW1lKTtcclxuXHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAgIDxFbGVtZW50IHJlZj17cmVmfSBjbGFzc05hbWU9e2NsYXNzTmFtZXN9IHsuLi5wcm9wc30+XHJcbiAgICAgICAgICAgIHtvdmVybGluZVRleHQgJiZcclxuICAgICAgICAgICAgICAgIDxDbG9uZVxyXG4gICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudD17b3ZlcmxpbmVUZXh0fVxyXG4gICAgICAgICAgICAgICAgICAgIGZhbGxiYWNrPVwic3BhblwiXHJcbiAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPXtjc3NDbGFzc2VzLk9WRVJMSU5FX1RFWFR9XHJcbiAgICAgICAgICAgICAgICAvPlxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB7cHJpbWFyeVRleHQgJiZcclxuICAgICAgICAgICAgICAgIDxDbG9uZVxyXG4gICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudD17cHJpbWFyeVRleHR9XHJcbiAgICAgICAgICAgICAgICAgICAgZmFsbGJhY2s9XCJzcGFuXCJcclxuICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU9e2Nzc0NsYXNzZXMuUFJJTUFSWV9URVhUfVxyXG4gICAgICAgICAgICAgICAgLz5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAge3NlY29uZGFyeVRleHQgJiZcclxuICAgICAgICAgICAgICAgIDxDbG9uZVxyXG4gICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudD17c2Vjb25kYXJ5VGV4dH1cclxuICAgICAgICAgICAgICAgICAgICBmYWxsYmFjaz1cInNwYW5cIlxyXG4gICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT17Y3NzQ2xhc3Nlcy5TRUNPTkRBUllfVEVYVH1cclxuICAgICAgICAgICAgICAgIC8+XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHtjaGlsZHJlbn1cclxuICAgICAgICA8L0VsZW1lbnQ+XHJcbiAgICApO1xyXG59KTtcclxuXHJcbkxpc3RJdGVtQ29udGVudC5kaXNwbGF5TmFtZSA9ICdNRENMaXN0SXRlbUNvbnRlbnQnO1xyXG5cclxuTGlzdEl0ZW1Db250ZW50LnByb3BUeXBlcyA9IHtcclxuICAgIG92ZXJsaW5lVGV4dDogUHJvcFR5cGVzLm5vZGUsXHJcbiAgICBwcmltYXJ5VGV4dDogUHJvcFR5cGVzLm5vZGUsXHJcbiAgICBzZWNvbmRhcnlUZXh0OiBQcm9wVHlwZXMubm9kZVxyXG59O1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgTGlzdEl0ZW1Db250ZW50OyIsImltcG9ydCB7IGZvcndhcmRSZWYgfSBmcm9tICdyZWFjdCc7XHJcbmltcG9ydCBjbGFzc25hbWVzIGZyb20gJ2NsYXNzbmFtZXMnO1xyXG5cclxuaW1wb3J0IHsgbGlzdEl0ZW1Dc3NDbGFzc2VzIGFzIGNzc0NsYXNzZXMgfSBmcm9tICcuL2NvbnN0YW50cyc7XHJcblxyXG5jb25zdCBMaXN0SXRlbUVuZCA9IGZvcndhcmRSZWYoKHtcclxuICAgIGVsZW1lbnQgPSAnc3BhbicsXHJcbiAgICBjb21wb25lbnQ6IEVsZW1lbnQgPSBlbGVtZW50LFxyXG4gICAgY2xhc3NOYW1lLFxyXG4gICAgLi4ucHJvcHNcclxufSwgcmVmKSA9PiB7XHJcbiAgICBjb25zdCBjbGFzc05hbWVzID0gY2xhc3NuYW1lcyhjc3NDbGFzc2VzLkVORCwgY2xhc3NOYW1lKTtcclxuXHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAgIDxFbGVtZW50IHJlZj17cmVmfSBjbGFzc05hbWU9e2NsYXNzTmFtZXN9IHsuLi5wcm9wc30gLz5cclxuICAgICk7XHJcbn0pO1xyXG5cclxuTGlzdEl0ZW1FbmQuZGlzcGxheU5hbWUgPSAnTURDTGlzdEl0ZW1FbmQnO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgTGlzdEl0ZW1FbmQ7IiwiaW1wb3J0IHsgZm9yd2FyZFJlZiB9IGZyb20gJ3JlYWN0JztcclxuaW1wb3J0IGNsYXNzbmFtZXMgZnJvbSAnY2xhc3NuYW1lcyc7XHJcblxyXG5pbXBvcnQgeyBsaXN0SXRlbUNzc0NsYXNzZXMgYXMgY3NzQ2xhc3NlcyB9IGZyb20gJy4vY29uc3RhbnRzJztcclxuXHJcbmNvbnN0IExpc3RJdGVtU3RhcnQgPSBmb3J3YXJkUmVmKCh7XHJcbiAgICBlbGVtZW50ID0gJ3NwYW4nLFxyXG4gICAgY29tcG9uZW50OiBFbGVtZW50ID0gZWxlbWVudCxcclxuICAgIGNsYXNzTmFtZSxcclxuICAgIC4uLnByb3BzXHJcbn0sIHJlZikgPT4ge1xyXG4gICAgY29uc3QgY2xhc3NOYW1lcyA9IGNsYXNzbmFtZXMoY3NzQ2xhc3Nlcy5TVEFSVCwgY2xhc3NOYW1lKTtcclxuXHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAgIDxFbGVtZW50IHJlZj17cmVmfSBjbGFzc05hbWU9e2NsYXNzTmFtZXN9IHsuLi5wcm9wc30gLz5cclxuICAgICk7XHJcbn0pO1xyXG5cclxuTGlzdEl0ZW1TdGFydC5kaXNwbGF5TmFtZSA9ICdNRENMaXN0SXRlbVN0YXJ0JztcclxuXHJcbmV4cG9ydCBkZWZhdWx0IExpc3RJdGVtU3RhcnQ7IiwiaW1wb3J0IHsgZm9yd2FyZFJlZiB9IGZyb20gJ3JlYWN0JztcclxuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcclxuaW1wb3J0IGNsYXNzbmFtZXMgZnJvbSAnY2xhc3NuYW1lcyc7XHJcblxyXG5pbXBvcnQgeyBDbG9uZSB9IGZyb20gJy4uL2NvbXBvbmVudCc7XHJcbmltcG9ydCBJY29uIGZyb20gJy4uL2ljb24nO1xyXG5cclxuaW1wb3J0IHsgbGlzdEl0ZW1Dc3NDbGFzc2VzIGFzIGNzc0NsYXNzZXMgfSBmcm9tICcuL2NvbnN0YW50cyc7XHJcbmltcG9ydCBMaXN0SXRlbUNvbnRlbnQgZnJvbSAnLi9MaXN0SXRlbUNvbnRlbnQnO1xyXG5pbXBvcnQgTGlzdEl0ZW1FbmQgZnJvbSAnLi9MaXN0SXRlbUVuZCc7XHJcbmltcG9ydCBMaXN0SXRlbVN0YXJ0IGZyb20gJy4vTGlzdEl0ZW1TdGFydCc7XHJcblxyXG5jb25zdCBMaXN0SXRlbSA9IGZvcndhcmRSZWYoKHtcclxuICAgIHN0YXJ0LFxyXG4gICAgY29udGVudCxcclxuICAgIGVuZCxcclxuICAgIHRleHQsXHJcbiAgICBvdmVybGluZVRleHQsXHJcbiAgICBwcmltYXJ5VGV4dCA9IHRleHQsXHJcbiAgICBzZWNvbmRhcnlUZXh0LFxyXG4gICAgaWNvbixcclxuICAgIGltYWdlLFxyXG4gICAgdGh1bWJuYWlsLFxyXG4gICAgdmlkZW8sXHJcbiAgICBsZWFkaW5nSWNvbiA9IGljb24sXHJcbiAgICBsZWFkaW5nSW1hZ2UgPSBpbWFnZSxcclxuICAgIGxlYWRpbmdUaHVtYm5haWwgPSB0aHVtYm5haWwsXHJcbiAgICBsZWFkaW5nVmlkZW8gPSB2aWRlbyxcclxuICAgIGxlYWRpbmdDaGVja2JveCxcclxuICAgIGxlYWRpbmdSYWRpbyxcclxuICAgIGxlYWRpbmdTd2l0Y2gsXHJcbiAgICBtZXRhLFxyXG4gICAgdHJhaWxpbmdNZXRhID0gbWV0YSxcclxuICAgIHRyYWlsaW5nSWNvbixcclxuICAgIHRyYWlsaW5nQ2hlY2tib3gsXHJcbiAgICB0cmFpbGluZ1JhZGlvLFxyXG4gICAgdHJhaWxpbmdTd2l0Y2gsXHJcbiAgICBhY3RpdmF0ZWQgPSBmYWxzZSxcclxuICAgIHNlbGVjdGVkID0gZmFsc2UsXHJcbiAgICBkaXNhYmxlZCA9IGZhbHNlLFxyXG4gICAgbm9uSW50ZXJhY3RpdmUgPSBmYWxzZSxcclxuICAgIHdpdGhMZWFkaW5nSWNvbiA9IEJvb2xlYW4obGVhZGluZ0ljb24pLFxyXG4gICAgd2l0aExlYWRpbmdJbWFnZSA9IEJvb2xlYW4obGVhZGluZ0ltYWdlKSxcclxuICAgIHdpdGhMZWFkaW5nVGh1bWJuYWlsID0gQm9vbGVhbihsZWFkaW5nVGh1bWJuYWlsKSxcclxuICAgIHdpdGhMZWFkaW5nVmlkZW8gPSBCb29sZWFuKGxlYWRpbmdWaWRlbyksXHJcbiAgICB3aXRoTGVhZGluZ0NoZWNrYm94ID0gQm9vbGVhbihsZWFkaW5nQ2hlY2tib3gpLFxyXG4gICAgd2l0aExlYWRpbmdSYWRpbyA9IEJvb2xlYW4obGVhZGluZ1JhZGlvKSxcclxuICAgIHdpdGhMZWFkaW5nU3dpdGNoID0gQm9vbGVhbihsZWFkaW5nU3dpdGNoKSxcclxuICAgIHdpdGhUcmFpbGluZ01ldGEgPSBCb29sZWFuKHRyYWlsaW5nTWV0YSksXHJcbiAgICB3aXRoVHJhaWxpbmdJY29uID0gQm9vbGVhbih0cmFpbGluZ0ljb24pLFxyXG4gICAgd2l0aFRyYWlsaW5nQ2hlY2tib3ggPSBCb29sZWFuKHRyYWlsaW5nQ2hlY2tib3gpLFxyXG4gICAgd2l0aFRyYWlsaW5nUmFkaW8gPSBCb29sZWFuKHRyYWlsaW5nUmFkaW8pLFxyXG4gICAgd2l0aFRyYWlsaW5nU3dpdGNoID0gQm9vbGVhbih0cmFpbGluZ1N3aXRjaCksXHJcblxyXG4gICAgZWxlbWVudCA9ICdsaScsXHJcbiAgICBjb21wb25lbnQ6IEVsZW1lbnQgPSBlbGVtZW50LFxyXG4gICAgY2xhc3NOYW1lLFxyXG4gICAgY2hpbGRyZW4sXHJcbiAgICAuLi5wcm9wc1xyXG59LCByZWYpID0+IHtcclxuICAgIGNvbnN0IGxpbmVzID0gQm9vbGVhbihvdmVybGluZVRleHQpICsgQm9vbGVhbihwcmltYXJ5VGV4dCkgKyBCb29sZWFuKHNlY29uZGFyeVRleHQpO1xyXG4gICAgY29uc3QgaGFzU3RhcnQgPSBCb29sZWFuKFxyXG4gICAgICAgIHN0YXJ0IHx8IGxlYWRpbmdJY29uIHx8IGxlYWRpbmdJbWFnZSB8fCBsZWFkaW5nVGh1bWJuYWlsIHx8XHJcbiAgICAgICAgbGVhZGluZ1ZpZGVvIHx8IGxlYWRpbmdDaGVja2JveCB8fCBsZWFkaW5nUmFkaW8gfHwgbGVhZGluZ1N3aXRjaFxyXG4gICAgKTtcclxuICAgIGNvbnN0IGhhc0NvbnRlbnQgPSBCb29sZWFuKGNvbnRlbnQgfHwgb3ZlcmxpbmVUZXh0IHx8IHByaW1hcnlUZXh0IHx8IHNlY29uZGFyeVRleHQpO1xyXG4gICAgY29uc3QgaGFzRW5kID0gQm9vbGVhbihcclxuICAgICAgICBlbmQgfHwgdHJhaWxpbmdNZXRhIHx8IHRyYWlsaW5nSWNvbiB8fFxyXG4gICAgICAgIHRyYWlsaW5nQ2hlY2tib3ggfHwgdHJhaWxpbmdSYWRpbyB8fCB0cmFpbGluZ1N3aXRjaFxyXG4gICAgKTtcclxuXHJcbiAgICBjb25zdCBjbGFzc05hbWVzID0gY2xhc3NuYW1lcyhjc3NDbGFzc2VzLlJPT1QsIHtcclxuICAgICAgICBbY3NzQ2xhc3Nlcy5BQ1RJVkFURURdOiBhY3RpdmF0ZWQsXHJcbiAgICAgICAgW2Nzc0NsYXNzZXMuU0VMRUNURURdOiBzZWxlY3RlZCxcclxuICAgICAgICBbY3NzQ2xhc3Nlcy5ESVNBQkxFRF06IGRpc2FibGVkLFxyXG4gICAgICAgIFtjc3NDbGFzc2VzLk9ORV9MSU5FXTogbGluZXMgPT09IDEsXHJcbiAgICAgICAgW2Nzc0NsYXNzZXMuVFdPX0xJTkVTXTogbGluZXMgPT09IDIsXHJcbiAgICAgICAgW2Nzc0NsYXNzZXMuVEhSRUVfTElORVNdOiBsaW5lcyA9PT0gMyxcclxuICAgICAgICBbY3NzQ2xhc3Nlcy5OT05fSU5URVJBQ1RJVkVdOiBub25JbnRlcmFjdGl2ZSxcclxuICAgICAgICBbY3NzQ2xhc3Nlcy5PVkVSTElORV06IG92ZXJsaW5lVGV4dCxcclxuICAgICAgICBbY3NzQ2xhc3Nlcy5MRUFESU5HX0lDT05dOiB3aXRoTGVhZGluZ0ljb24sXHJcbiAgICAgICAgW2Nzc0NsYXNzZXMuTEVBRElOR19JTUFHRV06IHdpdGhMZWFkaW5nSW1hZ2UsXHJcbiAgICAgICAgW2Nzc0NsYXNzZXMuTEVBRElOR19USFVNQk5BSUxdOiB3aXRoTGVhZGluZ1RodW1ibmFpbCxcclxuICAgICAgICBbY3NzQ2xhc3Nlcy5MRUFESU5HX1ZJREVPXTogd2l0aExlYWRpbmdWaWRlbyxcclxuICAgICAgICBbY3NzQ2xhc3Nlcy5MRUFESU5HX0NIRUNLQk9YXTogd2l0aExlYWRpbmdDaGVja2JveCxcclxuICAgICAgICBbY3NzQ2xhc3Nlcy5MRUFESU5HX1JBRElPXTogd2l0aExlYWRpbmdSYWRpbyxcclxuICAgICAgICBbY3NzQ2xhc3Nlcy5MRUFESU5HX1NXSVRDSF06IHdpdGhMZWFkaW5nU3dpdGNoLFxyXG4gICAgICAgIFtjc3NDbGFzc2VzLlRSQUlMSU5HX0lDT05dOiB3aXRoVHJhaWxpbmdJY29uLFxyXG4gICAgICAgIFtjc3NDbGFzc2VzLlRSQUlMSU5HX01FVEFdOiB3aXRoVHJhaWxpbmdNZXRhLFxyXG4gICAgICAgIFtjc3NDbGFzc2VzLlRSQUlMSU5HX0NIRUNLQk9YXTogd2l0aFRyYWlsaW5nQ2hlY2tib3gsXHJcbiAgICAgICAgW2Nzc0NsYXNzZXMuVFJBSUxJTkdfUkFESU9dOiB3aXRoVHJhaWxpbmdSYWRpbyxcclxuICAgICAgICBbY3NzQ2xhc3Nlcy5UUkFJTElOR19TV0lUQ0hdOiB3aXRoVHJhaWxpbmdTd2l0Y2hcclxuICAgIH0sIGNsYXNzTmFtZSk7XHJcblxyXG4gICAgcmV0dXJuIChcclxuICAgICAgICA8RWxlbWVudCByZWY9e3JlZn0gY2xhc3NOYW1lPXtjbGFzc05hbWVzfSB7Li4ucHJvcHN9PlxyXG4gICAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9e2Nzc0NsYXNzZXMuUklQUExFfSAvPlxyXG5cclxuICAgICAgICAgICAge2hhc1N0YXJ0ICYmXHJcbiAgICAgICAgICAgICAgICA8TGlzdEl0ZW1TdGFydD5cclxuICAgICAgICAgICAgICAgICAgICB7c3RhcnR9XHJcbiAgICAgICAgICAgICAgICAgICAge2xlYWRpbmdJY29uICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxDbG9uZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50PXtsZWFkaW5nSWNvbn1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZhbGxiYWNrPXtJY29ufVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvPlxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB7bGVhZGluZ0ltYWdlfVxyXG4gICAgICAgICAgICAgICAgICAgIHtsZWFkaW5nVGh1bWJuYWlsfVxyXG4gICAgICAgICAgICAgICAgICAgIHtsZWFkaW5nVmlkZW99XHJcbiAgICAgICAgICAgICAgICAgICAge2xlYWRpbmdDaGVja2JveH1cclxuICAgICAgICAgICAgICAgICAgICB7bGVhZGluZ1JhZGlvfVxyXG4gICAgICAgICAgICAgICAgICAgIHtsZWFkaW5nU3dpdGNofVxyXG4gICAgICAgICAgICAgICAgPC9MaXN0SXRlbVN0YXJ0PlxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB7aGFzQ29udGVudCAmJlxyXG4gICAgICAgICAgICAgICAgPExpc3RJdGVtQ29udGVudFxyXG4gICAgICAgICAgICAgICAgICAgIG92ZXJsaW5lVGV4dD17b3ZlcmxpbmVUZXh0fVxyXG4gICAgICAgICAgICAgICAgICAgIHByaW1hcnlUZXh0PXtwcmltYXJ5VGV4dH1cclxuICAgICAgICAgICAgICAgICAgICBzZWNvbmRhcnlUZXh0PXtzZWNvbmRhcnlUZXh0fVxyXG4gICAgICAgICAgICAgICAgPlxyXG4gICAgICAgICAgICAgICAgICAgIHtjb250ZW50fVxyXG4gICAgICAgICAgICAgICAgPC9MaXN0SXRlbUNvbnRlbnQ+XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHtoYXNFbmQgJiZcclxuICAgICAgICAgICAgICAgIDxMaXN0SXRlbUVuZD5cclxuICAgICAgICAgICAgICAgICAgICB7ZW5kfVxyXG4gICAgICAgICAgICAgICAgICAgIHt0cmFpbGluZ01ldGF9XHJcbiAgICAgICAgICAgICAgICAgICAge3RyYWlsaW5nSWNvbiAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8Q2xvbmVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudD17dHJhaWxpbmdJY29ufVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmFsbGJhY2s9e0ljb259XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8+XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHt0cmFpbGluZ0NoZWNrYm94fVxyXG4gICAgICAgICAgICAgICAgICAgIHt0cmFpbGluZ1JhZGlvfVxyXG4gICAgICAgICAgICAgICAgICAgIHt0cmFpbGluZ1N3aXRjaH1cclxuICAgICAgICAgICAgICAgIDwvTGlzdEl0ZW1FbmQ+XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHtjaGlsZHJlbn1cclxuICAgICAgICA8L0VsZW1lbnQ+XHJcbiAgICApO1xyXG59KTtcclxuXHJcbkxpc3RJdGVtLmRpc3BsYXlOYW1lID0gJ01EQ0xpc3RJdGVtJztcclxuXHJcbkxpc3RJdGVtLnByb3BUeXBlcyA9IHtcclxuICAgIHN0YXJ0OiBQcm9wVHlwZXMubm9kZSxcclxuICAgIGNvbnRlbnQ6IFByb3BUeXBlcy5ub2RlLFxyXG4gICAgZW5kOiBQcm9wVHlwZXMubm9kZSxcclxuICAgIHRleHQ6IFByb3BUeXBlcy5ub2RlLFxyXG4gICAgb3ZlcmxpbmVUZXh0OiBQcm9wVHlwZXMubm9kZSxcclxuICAgIHByaW1hcnlUZXh0OiBQcm9wVHlwZXMubm9kZSxcclxuICAgIHNlY29uZGFyeVRleHQ6IFByb3BUeXBlcy5ub2RlLFxyXG4gICAgaWNvbjogUHJvcFR5cGVzLm5vZGUsXHJcbiAgICBpbWFnZTogUHJvcFR5cGVzLmVsZW1lbnQsXHJcbiAgICB0aHVtYm5haWw6IFByb3BUeXBlcy5lbGVtZW50LFxyXG4gICAgdmlkZW86IFByb3BUeXBlcy5lbGVtZW50LFxyXG4gICAgbGVhZGluZ0ljb246IFByb3BUeXBlcy5ub2RlLFxyXG4gICAgbGVhZGluZ0ltYWdlOiBQcm9wVHlwZXMuZWxlbWVudCxcclxuICAgIGxlYWRpbmdUaHVtYm5haWw6IFByb3BUeXBlcy5lbGVtZW50LFxyXG4gICAgbGVhZGluZ1ZpZGVvOiBQcm9wVHlwZXMuZWxlbWVudCxcclxuICAgIGxlYWRpbmdDaGVja2JveDogUHJvcFR5cGVzLmVsZW1lbnQsXHJcbiAgICBsZWFkaW5nUmFkaW86IFByb3BUeXBlcy5lbGVtZW50LFxyXG4gICAgbGVhZGluZ1N3aXRjaDogUHJvcFR5cGVzLmVsZW1lbnQsXHJcbiAgICBtZXRhOiBQcm9wVHlwZXMubm9kZSxcclxuICAgIHRyYWlsaW5nTWV0YTogUHJvcFR5cGVzLm5vZGUsXHJcbiAgICB0cmFpbGluZ0ljb246IFByb3BUeXBlcy5ub2RlLFxyXG4gICAgdHJhaWxpbmdDaGVja2JveDogUHJvcFR5cGVzLmVsZW1lbnQsXHJcbiAgICB0cmFpbGluZ1JhZGlvOiBQcm9wVHlwZXMuZWxlbWVudCxcclxuICAgIHRyYWlsaW5nU3dpdGNoOiBQcm9wVHlwZXMuZWxlbWVudCxcclxuICAgIGFjdGl2YXRlZDogUHJvcFR5cGVzLmJvb2wsXHJcbiAgICBzZWxlY3RlZDogUHJvcFR5cGVzLmJvb2wsXHJcbiAgICBkaXNhYmxlZDogUHJvcFR5cGVzLmJvb2wsXHJcbiAgICBub25JbnRlcmFjdGl2ZTogUHJvcFR5cGVzLmJvb2wsXHJcbiAgICB3aXRoTGVhZGluZ0ljb246IFByb3BUeXBlcy5ib29sLFxyXG4gICAgd2l0aExlYWRpbmdJbWFnZTogUHJvcFR5cGVzLmJvb2wsXHJcbiAgICB3aXRoTGVhZGluZ1RodW1ibmFpbDogUHJvcFR5cGVzLmJvb2wsXHJcbiAgICB3aXRoTGVhZGluZ1ZpZGVvOiBQcm9wVHlwZXMuYm9vbCxcclxuICAgIHdpdGhMZWFkaW5nQ2hlY2tib3g6IFByb3BUeXBlcy5ib29sLFxyXG4gICAgd2l0aExlYWRpbmdSYWRpbzogUHJvcFR5cGVzLmJvb2wsXHJcbiAgICB3aXRoTGVhZGluZ1N3aXRjaDogUHJvcFR5cGVzLmJvb2wsXHJcbiAgICB3aXRoVHJhaWxpbmdNZXRhOiBQcm9wVHlwZXMuYm9vbCxcclxuICAgIHdpdGhUcmFpbGluZ0ljb246IFByb3BUeXBlcy5ib29sLFxyXG4gICAgd2l0aFRyYWlsaW5nQ2hlY2tib3g6IFByb3BUeXBlcy5ib29sLFxyXG4gICAgd2l0aFRyYWlsaW5nUmFkaW86IFByb3BUeXBlcy5ib29sLFxyXG4gICAgd2l0aFRyYWlsaW5nU3dpdGNoOiBQcm9wVHlwZXMuYm9vbFxyXG59O1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgTGlzdEl0ZW07IiwiaW1wb3J0IHsgZm9yd2FyZFJlZiB9IGZyb20gJ3JlYWN0JztcclxuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcclxuaW1wb3J0IGNsYXNzbmFtZXMgZnJvbSAnY2xhc3NuYW1lcyc7XHJcblxyXG5pbXBvcnQgeyBjcmVhdGUgfSBmcm9tICcuLi9jb21wb25lbnQnO1xyXG5cclxuaW1wb3J0IHsgbGlzdENzc0NsYXNzZXMgYXMgY3NzQ2xhc3NlcyB9IGZyb20gJy4vY29uc3RhbnRzJztcclxuaW1wb3J0IExpc3RJdGVtIGZyb20gJy4vTGlzdEl0ZW0nO1xyXG5cclxuY29uc3QgTGlzdCA9IGZvcndhcmRSZWYoKHtcclxuICAgIGl0ZW1zLFxyXG5cclxuICAgIGVsZW1lbnQ6IEVsZW1lbnQgPSAndWwnLFxyXG4gICAgY2xhc3NOYW1lLFxyXG4gICAgY2hpbGRyZW4gPSBpdGVtcz8ubWFwKGl0ZW0gPT4gY3JlYXRlKExpc3RJdGVtLCBpdGVtKSksXHJcbiAgICAuLi5wcm9wc1xyXG59LCByZWYpID0+IHtcclxuICAgIGNvbnN0IGNsYXNzTmFtZXMgPSBjbGFzc25hbWVzKGNzc0NsYXNzZXMuUk9PVCwgY2xhc3NOYW1lKTtcclxuXHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAgIDxFbGVtZW50IHJlZj17cmVmfSBjbGFzc05hbWU9e2NsYXNzTmFtZXN9IHsuLi5wcm9wc30+XHJcbiAgICAgICAgICAgIHtjaGlsZHJlbn1cclxuICAgICAgICA8L0VsZW1lbnQ+XHJcbiAgICApO1xyXG59KTtcclxuXHJcbkxpc3QuZGlzcGxheU5hbWUgPSAnTURDTGlzdCc7XHJcblxyXG5MaXN0SXRlbS5wcm9wVHlwZXMgPSB7XHJcbiAgICBpdGVtczogUHJvcFR5cGVzLmFycmF5XHJcbn07XHJcblxyXG5leHBvcnQgZGVmYXVsdCBMaXN0OyIsImltcG9ydCB7IGZvcndhcmRSZWYgfSBmcm9tICdyZWFjdCc7XHJcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XHJcbmltcG9ydCBjbGFzc25hbWVzIGZyb20gJ2NsYXNzbmFtZXMnO1xyXG5cclxuaW1wb3J0IHsgbGlzdERpdmlkZXJDc3NDbGFzc2VzIGFzIGNzc0NsYXNzZXMgfSBmcm9tICcuL2NvbnN0YW50cyc7XHJcblxyXG5jb25zdCBMaXN0RGl2aWRlciA9IGZvcndhcmRSZWYoKHtcclxuICAgIHdpdGhMZWFkaW5nVGV4dCA9IGZhbHNlLFxyXG4gICAgd2l0aExlYWRpbmdJY29uID0gZmFsc2UsXHJcbiAgICB3aXRoTGVhZGluZ0ltYWdlID0gZmFsc2UsXHJcbiAgICB3aXRoTGVhZGluZ1RodW1ibmFpbCA9IGZhbHNlLFxyXG4gICAgd2l0aExlYWRpbmdWaWRlbyA9IGZhbHNlLFxyXG4gICAgd2l0aExlYWRpbmdDaGVja2JveCA9IGZhbHNlLFxyXG4gICAgd2l0aExlYWRpbmdSYWRpbyA9IGZhbHNlLFxyXG4gICAgd2l0aExlYWRpbmdTd2l0Y2ggPSBmYWxzZSxcclxuXHJcbiAgICBlbGVtZW50OiBFbGVtZW50ID0gJ2xpJyxcclxuICAgIGNsYXNzTmFtZSxcclxuICAgIC4uLnByb3BzXHJcbn0sIHJlZikgPT4ge1xyXG4gICAgY29uc3QgY2xhc3NOYW1lcyA9IGNsYXNzbmFtZXMoY3NzQ2xhc3Nlcy5ST09ULCB7XHJcbiAgICAgICAgW2Nzc0NsYXNzZXMuTEVBRElOR19URVhUXTogd2l0aExlYWRpbmdUZXh0LFxyXG4gICAgICAgIFtjc3NDbGFzc2VzLkxFQURJTkdfSUNPTl06IHdpdGhMZWFkaW5nSWNvbixcclxuICAgICAgICBbY3NzQ2xhc3Nlcy5MRUFESU5HX0lNQUdFXTogd2l0aExlYWRpbmdJbWFnZSxcclxuICAgICAgICBbY3NzQ2xhc3Nlcy5MRUFESU5HX1RIVU1CTkFJTF06IHdpdGhMZWFkaW5nVGh1bWJuYWlsLFxyXG4gICAgICAgIFtjc3NDbGFzc2VzLkxFQURJTkdfVklERU9dOiB3aXRoTGVhZGluZ1ZpZGVvLFxyXG4gICAgICAgIFtjc3NDbGFzc2VzLkxFQURJTkdfQ0hFQ0tCT1hdOiB3aXRoTGVhZGluZ0NoZWNrYm94LFxyXG4gICAgICAgIFtjc3NDbGFzc2VzLkxFQURJTkdfUkFESU9dOiB3aXRoTGVhZGluZ1JhZGlvLFxyXG4gICAgICAgIFtjc3NDbGFzc2VzLkxFQURJTkdfU1dJVENIXTogd2l0aExlYWRpbmdTd2l0Y2hcclxuICAgIH0sIGNsYXNzTmFtZSk7XHJcblxyXG4gICAgcmV0dXJuIChcclxuICAgICAgICA8RWxlbWVudFxyXG4gICAgICAgICAgICByZWY9e3JlZn1cclxuICAgICAgICAgICAgY2xhc3NOYW1lPXtjbGFzc05hbWVzfVxyXG4gICAgICAgICAgICByb2xlPXtFbGVtZW50ID09PSAnbGknID8gJ3NlcGFyYXRvcicgOiB1bmRlZmluZWR9XHJcbiAgICAgICAgICAgIHsuLi5wcm9wc31cclxuICAgICAgICAvPlxyXG4gICAgKTtcclxufSk7XHJcblxyXG5MaXN0RGl2aWRlci5kaXNwbGF5TmFtZSA9ICdNRENMaXN0RGl2aWRlcic7XHJcblxyXG5MaXN0RGl2aWRlci5wcm9wVHlwZXMgPSB7XHJcbiAgICB3aXRoTGVhZGluZ1RleHQ6IFByb3BUeXBlcy5ib29sLFxyXG4gICAgd2l0aExlYWRpbmdJY29uOiBQcm9wVHlwZXMuYm9vbCxcclxuICAgIHdpdGhMZWFkaW5nSW1hZ2U6IFByb3BUeXBlcy5ib29sLFxyXG4gICAgd2l0aExlYWRpbmdUaHVtYm5haWw6IFByb3BUeXBlcy5ib29sLFxyXG4gICAgd2l0aExlYWRpbmdWaWRlbzogUHJvcFR5cGVzLmJvb2wsXHJcbiAgICB3aXRoTGVhZGluZ0F2YXRhcjogUHJvcFR5cGVzLmJvb2wsXHJcbiAgICB3aXRoTGVhZGluZ0NoZWNrYm94OiBQcm9wVHlwZXMuYm9vbCxcclxuICAgIHdpdGhMZWFkaW5nU3dpdGNoOiBQcm9wVHlwZXMuYm9vbCxcclxuICAgIHdpdGhMZWFkaW5nUmFkaW86IFByb3BUeXBlcy5ib29sXHJcbn07XHJcblxyXG5leHBvcnQgZGVmYXVsdCBMaXN0RGl2aWRlcjsiLCJpbXBvcnQgeyBmb3J3YXJkUmVmIH0gZnJvbSAncmVhY3QnO1xyXG5pbXBvcnQgY2xhc3NuYW1lcyBmcm9tICdjbGFzc25hbWVzJztcclxuXHJcbmltcG9ydCB7IGxpc3RHcm91cENzc0NsYXNzZXMgYXMgY3NzQ2xhc3NlcyB9IGZyb20gJy4vY29uc3RhbnRzJztcclxuXHJcbmNvbnN0IExpc3RHcm91cCA9IGZvcndhcmRSZWYoKHtcclxuICAgIGVsZW1lbnQ6IEVsZW1lbnQgPSAnZGl2JyxcclxuICAgIGNsYXNzTmFtZSxcclxuICAgIC4uLnByb3BzXHJcbn0sIHJlZikgPT4ge1xyXG4gICAgY29uc3QgY2xhc3NOYW1lcyA9IGNsYXNzbmFtZXMoY3NzQ2xhc3Nlcy5ST09ULCBjbGFzc05hbWUpO1xyXG5cclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgPEVsZW1lbnQgcmVmPXtyZWZ9IGNsYXNzTmFtZT17Y2xhc3NOYW1lc30gey4uLnByb3BzfSAvPlxyXG4gICAgKTtcclxufSk7XHJcblxyXG5MaXN0R3JvdXAuZGlzcGxheU5hbWUgPSAnTURDTGlzdEdyb3VwJztcclxuXHJcbmV4cG9ydCBkZWZhdWx0IExpc3RHcm91cDsiLCJpbXBvcnQgeyBmb3J3YXJkUmVmIH0gZnJvbSAncmVhY3QnO1xyXG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xyXG5pbXBvcnQgY2xhc3NuYW1lcyBmcm9tICdjbGFzc25hbWVzJztcclxuXHJcbmltcG9ydCB7IGxpc3RHcm91cENzc0NsYXNzZXMgYXMgY3NzQ2xhc3NlcyB9IGZyb20gJy4vY29uc3RhbnRzJztcclxuXHJcbmNvbnN0IExpc3RHcm91cFN1YmhlYWRlciA9IGZvcndhcmRSZWYoKHtcclxuICAgIHRpdGxlLFxyXG5cclxuICAgIGVsZW1lbnQ6IEVsZW1lbnQgPSAnaDMnLFxyXG4gICAgY2xhc3NOYW1lLFxyXG4gICAgY2hpbGRyZW4gPSB0aXRsZSxcclxuICAgIC4uLnByb3BzXHJcbn0sIHJlZikgPT4ge1xyXG4gICAgY29uc3QgY2xhc3NOYW1lcyA9IGNsYXNzbmFtZXMoY3NzQ2xhc3Nlcy5TVUJIRUFERVIsIGNsYXNzTmFtZSk7XHJcblxyXG4gICAgcmV0dXJuIChcclxuICAgICAgICA8RWxlbWVudCByZWY9e3JlZn0gY2xhc3NOYW1lPXtjbGFzc05hbWVzfSB7Li4ucHJvcHN9PntjaGlsZHJlbn08L0VsZW1lbnQ+XHJcbiAgICApO1xyXG59KTtcclxuXHJcbkxpc3RHcm91cFN1YmhlYWRlci5kaXNwbGF5TmFtZSA9ICdNRENMaXN0R3JvdXBTdWJoZWFkZXInO1xyXG5cclxuTGlzdEdyb3VwU3ViaGVhZGVyLnByb3BUeXBlcyA9IHtcclxuICAgIHRpdGxlOiBQcm9wVHlwZXMuc3RyaW5nXHJcbn07XHJcblxyXG5leHBvcnQgZGVmYXVsdCBMaXN0R3JvdXBTdWJoZWFkZXI7IiwiaW1wb3J0IExpc3QgZnJvbSAnLi9MaXN0JztcclxuaW1wb3J0IExpc3REaXZpZGVyIGZyb20gJy4vTGlzdERpdmlkZXInO1xyXG5pbXBvcnQgTGlzdEdyb3VwIGZyb20gJy4vTGlzdEdyb3VwJztcclxuaW1wb3J0IExpc3RHcm91cFN1YmhlYWRlciBmcm9tICcuL0xpc3RHcm91cFN1YmhlYWRlcic7XHJcbmltcG9ydCBMaXN0SXRlbSBmcm9tICcuL0xpc3RJdGVtJztcclxuaW1wb3J0IExpc3RJdGVtQ29udGVudCBmcm9tICcuL0xpc3RJdGVtQ29udGVudCc7XHJcbmltcG9ydCBMaXN0SXRlbUVuZCBmcm9tICcuL0xpc3RJdGVtRW5kJztcclxuaW1wb3J0IExpc3RJdGVtU3RhcnQgZnJvbSAnLi9MaXN0SXRlbVN0YXJ0JztcclxuXHJcbkxpc3QuSXRlbSA9IExpc3RJdGVtO1xyXG5MaXN0LkRpdmlkZXIgPSBMaXN0RGl2aWRlcjtcclxuTGlzdC5Hcm91cCA9IExpc3RHcm91cDtcclxuTGlzdEdyb3VwLlN1YmhlYWRlciA9IExpc3RHcm91cFN1YmhlYWRlcjtcclxuTGlzdEl0ZW0uQ29udGVudCA9IExpc3RJdGVtQ29udGVudDtcclxuTGlzdEl0ZW0uRW5kID0gTGlzdEl0ZW1FbmQ7XHJcbkxpc3RJdGVtLlN0YXJ0ID0gTGlzdEl0ZW1TdGFydDtcclxuXHJcbmV4cG9ydCB7XHJcbiAgICBMaXN0IGFzIGRlZmF1bHQsXHJcbiAgICBMaXN0RGl2aWRlcixcclxuICAgIExpc3RHcm91cCxcclxuICAgIExpc3RHcm91cFN1YmhlYWRlcixcclxuICAgIExpc3RJdGVtLFxyXG4gICAgTGlzdEl0ZW1TdGFydCxcclxuICAgIExpc3RJdGVtRW5kLFxyXG4gICAgTGlzdEl0ZW1Db250ZW50XHJcbn07IiwiaW1wb3J0IHsgZm9yd2FyZFJlZiB9IGZyb20gJ3JlYWN0JztcclxuaW1wb3J0IGNsYXNzbmFtZXMgZnJvbSAnY2xhc3NuYW1lcyc7XHJcblxyXG5pbXBvcnQgeyBMaXN0SXRlbSB9IGZyb20gJy4uL2xpc3QnO1xyXG5pbXBvcnQgeyBjc3NDbGFzc2VzIH0gZnJvbSAnLi9jb25zdGFudHMnO1xyXG5cclxuY29uc3QgTWVudUl0ZW0gPSBmb3J3YXJkUmVmKCh7XHJcbiAgICBzZWxlY3RlZCA9IGZhbHNlLFxyXG4gICAgZGlzYWJsZWQgPSBmYWxzZSxcclxuXHJcbiAgICBjbGFzc05hbWUsXHJcbiAgICAuLi5wcm9wc1xyXG59LCByZWYpID0+IHtcclxuICAgIGNvbnN0IGNsYXNzTmFtZXMgPSBjbGFzc25hbWVzKGNzc0NsYXNzZXMuSVRFTSwge1xyXG4gICAgICAgIFtjc3NDbGFzc2VzLklURU1fU0VMRUNURURdOiBzZWxlY3RlZFxyXG4gICAgfSwgY2xhc3NOYW1lKTtcclxuXHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAgIDxMaXN0SXRlbVxyXG4gICAgICAgICAgICByZWY9e3JlZn1cclxuICAgICAgICAgICAgcm9sZT1cIm1lbnVpdGVtXCJcclxuICAgICAgICAgICAgY2xhc3NOYW1lPXtjbGFzc05hbWVzfVxyXG4gICAgICAgICAgICBzZWxlY3RlZD17c2VsZWN0ZWR9XHJcbiAgICAgICAgICAgIGRpc2FibGVkPXtkaXNhYmxlZH1cclxuICAgICAgICAgICAgZGF0YS1kaXNhYmxlZD17ZGlzYWJsZWQgfHwgdW5kZWZpbmVkfVxyXG4gICAgICAgICAgICB0YWJJbmRleD17ZGlzYWJsZWQgPyAnLTEnIDogdW5kZWZpbmVkfVxyXG4gICAgICAgICAgICB7Li4ucHJvcHN9XHJcbiAgICAgICAgLz5cclxuICAgICk7XHJcbn0pO1xyXG5cclxuTWVudUl0ZW0uZGlzcGxheU5hbWUgPSAnTURDTWVudUl0ZW0nO1xyXG5cclxuTWVudUl0ZW0ucHJvcFR5cGVzID0ge1xyXG4gICAgLi4uTGlzdEl0ZW0ucHJvcFR5cGVzXHJcbn07XHJcblxyXG5leHBvcnQgZGVmYXVsdCBNZW51SXRlbTsiLCJleHBvcnQgY29uc3QgY3NzQ2xhc3NlcyA9IHtcclxuICAgIFJPT1Q6ICdtZGMtbW9kYWwnLFxyXG4gICAgRklYRUQ6ICdtZGMtbW9kYWwtLWZpeGVkJ1xyXG59OyIsImltcG9ydCB7IHVzZVJlZiwgdXNlRWZmZWN0IH0gZnJvbSAncmVhY3QnO1xyXG5pbXBvcnQgeyBjcmVhdGVQb3J0YWwgfSBmcm9tICdyZWFjdC1kb20nO1xyXG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xyXG5cclxuaW1wb3J0IHsgY3NzQ2xhc3NlcyB9IGZyb20gJy4vY29uc3RhbnRzJztcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIE1vZGFsKHtcclxuICAgIGZpeGVkID0gZmFsc2UsXHJcbiAgICBlbGVtZW50ID0gJ2RpdicsXHJcbiAgICBjaGlsZHJlblxyXG59KSB7XHJcbiAgICBjb25zdCByb290UmVmID0gdXNlUmVmKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoZWxlbWVudCkpO1xyXG5cclxuICAgIHVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICAgICAgY29uc3Qgcm9vdCA9IHJvb3RSZWYuY3VycmVudDtcclxuICAgICAgICBjb25zdCBhY3RpdmVFbGVtZW50ID0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudDtcclxuXHJcbiAgICAgICAgcm9vdC5jbGFzc05hbWUgPSBjc3NDbGFzc2VzLlJPT1Q7XHJcblxyXG4gICAgICAgIGlmIChmaXhlZCkge1xyXG4gICAgICAgICAgICByb290LmNsYXNzTGlzdC5hZGQoY3NzQ2xhc3Nlcy5GSVhFRCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHJvb3QpO1xyXG4gICAgICAgIHJvb3QuZmlyc3RDaGlsZC5mb2N1cygpO1xyXG5cclxuICAgICAgICByZXR1cm4gKCkgPT4ge1xyXG4gICAgICAgICAgICBhY3RpdmVFbGVtZW50LmZvY3VzKCk7XHJcbiAgICAgICAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQocm9vdCk7XHJcbiAgICAgICAgfTtcclxuICAgIH0sIFtmaXhlZF0pO1xyXG5cclxuICAgIHJldHVybiBjcmVhdGVQb3J0YWwoY2hpbGRyZW4sIHJvb3RSZWYuY3VycmVudCk7XHJcbn1cclxuXHJcbk1vZGFsLmRpc3BsYXlOYW1lID0gJ01EQ01vZGFsJztcclxuXHJcbk1vZGFsLnByb3BUeXBlcyA9IHtcclxuICAgIGZpeGVkOiBQcm9wVHlwZXMuYm9vbCxcclxuICAgIGVsZW1lbnQ6IFByb3BUeXBlcy5zdHJpbmcsXHJcbiAgICBjaGlsZHJlbjogUHJvcFR5cGVzLm5vZGUuaXNSZXF1aXJlZFxyXG59OyIsImV4cG9ydCB7IGRlZmF1bHQgfSBmcm9tICcuL01vZGFsJzsiLCJpbXBvcnQgeyBDU1NUcmFuc2l0aW9uIH0gZnJvbSAncmVhY3QtdHJhbnNpdGlvbi1ncm91cCc7XHJcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XHJcblxyXG5pbXBvcnQgTW9kYWwgZnJvbSAnLi4vbW9kYWwnO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gTGF5ZXIoe1xyXG4gICAgbW9kYWwgPSBmYWxzZSxcclxuICAgIGZpeGVkID0gZmFsc2UsXHJcblxyXG4gICAgY2hpbGRyZW4sXHJcbiAgICAuLi5wcm9wc1xyXG59KSB7XHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAgIDxDU1NUcmFuc2l0aW9uIHsuLi5wcm9wc30+XHJcbiAgICAgICAgICAgIHttb2RhbCA/XHJcbiAgICAgICAgICAgICAgICA8TW9kYWwgZml4ZWQ9e2ZpeGVkfT5cclxuICAgICAgICAgICAgICAgICAgICB7Y2hpbGRyZW59XHJcbiAgICAgICAgICAgICAgICA8L01vZGFsPlxyXG4gICAgICAgICAgICAgICAgOlxyXG4gICAgICAgICAgICAgICAgY2hpbGRyZW5cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIDwvQ1NTVHJhbnNpdGlvbj5cclxuICAgICk7XHJcbn1cclxuXHJcbkxheWVyLmRpc3BsYXlOYW1lID0gJ01EQ0xheWVyJztcclxuXHJcbkxheWVyLnByb3BUeXBlcyA9IHtcclxuICAgIG1vZGFsOiBQcm9wVHlwZXMuYm9vbCxcclxuICAgIGZpeGVkOiBQcm9wVHlwZXMuYm9vbFxyXG59OyIsImV4cG9ydCB7IGRlZmF1bHQgfSBmcm9tICcuL0xheWVyJzsiLCJjb25zdCBkZWZhdWx0VmFsdWVzID0ge1xyXG4gICAgdG9wOiBmYWxzZSxcclxuICAgIGJvdHRvbTogZmFsc2UsXHJcbiAgICBjZW50ZXI6IGZhbHNlLFxyXG4gICAgbGVmdDogZmFsc2UsXHJcbiAgICByaWdodDogZmFsc2VcclxufTtcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRBbmNob3JPcmlnaW4oYW5jaG9yT3JpZ2luID0gJycpIHtcclxuICAgIGlmICh0eXBlb2YgYW5jaG9yT3JpZ2luID09PSAnb2JqZWN0Jykge1xyXG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBkZWZhdWx0VmFsdWVzLCBhbmNob3JPcmlnaW4pO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IGtleXMgPSBhbmNob3JPcmlnaW4uc3BsaXQoJyAnKTtcclxuXHJcbiAgICBjb25zdCB2YWx1ZXMgPSBrZXlzLnJlZHVjZSgocmVzdWx0LCBrZXkpID0+IHtcclxuICAgICAgICByZXN1bHRba2V5XSA9IHRydWU7XHJcblxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9LCB7fSk7XHJcblxyXG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIGRlZmF1bHRWYWx1ZXMsIHZhbHVlcyk7XHJcbn0iLCJpbXBvcnQgeyBmb3J3YXJkUmVmLCB1c2VSZWYsIHVzZUltcGVyYXRpdmVIYW5kbGUsIHVzZUNhbGxiYWNrLCB1c2VFZmZlY3QgfSBmcm9tICdyZWFjdCc7XHJcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XHJcbmltcG9ydCBjbGFzc25hbWVzIGZyb20gJ2NsYXNzbmFtZXMnO1xyXG5cclxuaW1wb3J0IHsgdXNlVXBkYXRlZCB9IGZyb20gJy4uL2hvb2tzJztcclxuaW1wb3J0IHsgY2xvbmUgfSBmcm9tICcuLi9jb21wb25lbnQnO1xyXG5pbXBvcnQgTGF5ZXIgZnJvbSAnLi4vbGF5ZXInO1xyXG5cclxuaW1wb3J0IHsgbnVtYmVycywgY3NzQ2xhc3NlcywgT3JpZ2luIH0gZnJvbSAnLi9jb25zdGFudHMnO1xyXG5pbXBvcnQgeyBnZXRBbmNob3JPcmlnaW4gfSBmcm9tICcuL3V0aWxzJztcclxuXHJcbmNvbnN0IE1lbnVTdXJmYWNlID0gZm9yd2FyZFJlZigoe1xyXG4gICAgYW5jaG9yLFxyXG4gICAgYW5jaG9yUmVmOiBfYW5jaG9yUmVmLFxyXG4gICAgYW5jaG9yT3JpZ2luOiBfYW5jaG9yT3JpZ2luID0gT3JpZ2luLlRPUF9MRUZULFxyXG4gICAgdHJhbnNmb3JtT3JpZ2luOiBfdHJhbnNmb3JtT3JpZ2luID0gX2FuY2hvck9yaWdpbixcclxuICAgIG9wZW4gPSBmYWxzZSxcclxuICAgIG1vZGFsID0gZmFsc2UsXHJcbiAgICBxdWljayA9IGZhbHNlLFxyXG4gICAgZml4ZWQgPSBmYWxzZSxcclxuICAgIHBlcnNpc3RlbnQgPSBmYWxzZSxcclxuICAgIGZ1bGxXaWR0aCA9IGZhbHNlLFxyXG4gICAgb25DbG9zZSA9IEZ1bmN0aW9uLnByb3RvdHlwZSxcclxuICAgIG9uS2V5RG93biA9IEZ1bmN0aW9uLnByb3RvdHlwZSxcclxuXHJcbiAgICBjbGFzc05hbWUsXHJcbiAgICAuLi5wcm9wc1xyXG59LCByZWYpID0+IHtcclxuICAgIGNvbnN0IHJvb3RSZWYgPSB1c2VSZWYoKTtcclxuICAgIGNvbnN0IGFuY2hvclJlZiA9IHVzZVJlZihfYW5jaG9yUmVmPy5jdXJyZW50KTtcclxuXHJcbiAgICB1c2VJbXBlcmF0aXZlSGFuZGxlKHJlZiwgKCkgPT4gcm9vdFJlZi5jdXJyZW50KTtcclxuXHJcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgICAgIGlmICghX2FuY2hvclJlZikgcmV0dXJuO1xyXG5cclxuICAgICAgICBhbmNob3JSZWYuY3VycmVudCA9IF9hbmNob3JSZWYuY3VycmVudDtcclxuICAgIH0sIFtfYW5jaG9yUmVmXSk7XHJcblxyXG4gICAgdXNlVXBkYXRlZCgoKSA9PiB7XHJcbiAgICAgICAgaWYgKCFvcGVuIHx8IHBlcnNpc3RlbnQpIHJldHVybjtcclxuXHJcbiAgICAgICAgZnVuY3Rpb24gaGFuZGxlQm9keUNsaWNrKGV2ZW50KSB7XHJcbiAgICAgICAgICAgIG9uQ2xvc2UoZXZlbnQpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZG9jdW1lbnQuYm9keS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGhhbmRsZUJvZHlDbGljaywgdHJ1ZSk7XHJcblxyXG4gICAgICAgIHJldHVybiAoKSA9PiB7XHJcbiAgICAgICAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snLCBoYW5kbGVCb2R5Q2xpY2ssIHRydWUpO1xyXG4gICAgICAgIH07XHJcbiAgICB9LCBbb3BlbiwgcGVyc2lzdGVudCwgb25DbG9zZV0pO1xyXG5cclxuICAgIHVzZVVwZGF0ZWQoKCkgPT4ge1xyXG4gICAgICAgIGlmICghb3BlbiB8fCAhcm9vdFJlZi5jdXJyZW50IHx8ICFhbmNob3JSZWYuY3VycmVudCkgcmV0dXJuO1xyXG5cclxuICAgICAgICBjb25zdCBhbmNob3IgPSBhbmNob3JSZWYuY3VycmVudDtcclxuICAgICAgICBjb25zdCB7IGNsaWVudFdpZHRoOiB3aWR0aCwgY2xpZW50SGVpZ2h0OiBoZWlnaHQgfSA9IHJvb3RSZWYuY3VycmVudDtcclxuICAgICAgICBjb25zdCBhbmNob3JDbGllbnRSZWN0ID0gYW5jaG9yLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xyXG4gICAgICAgIGNvbnN0IGFuY2hvckRpbWVuc2lvbnMgPSBtb2RhbCA/IGFuY2hvckNsaWVudFJlY3QgOiB7XHJcbiAgICAgICAgICAgIHRvcDogYW5jaG9yLm9mZnNldFRvcCxcclxuICAgICAgICAgICAgbGVmdDogYW5jaG9yLm9mZnNldExlZnQsXHJcbiAgICAgICAgICAgIGJvdHRvbTogYW5jaG9yLm9mZnNldFRvcCArIGFuY2hvci5vZmZzZXRIZWlnaHQsXHJcbiAgICAgICAgICAgIHJpZ2h0OiBhbmNob3Iub2Zmc2V0TGVmdCArIGFuY2hvci5vZmZzZXRXaWR0aCxcclxuICAgICAgICAgICAgd2lkdGg6IGFuY2hvci5vZmZzZXRXaWR0aCxcclxuICAgICAgICAgICAgaGVpZ2h0OiBhbmNob3Iub2Zmc2V0SGVpZ2h0XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgY29uc3Qgc3R5bGUgPSB7XHJcbiAgICAgICAgICAgIHRvcDogMCxcclxuICAgICAgICAgICAgbGVmdDogMCxcclxuICAgICAgICAgICAgd2lkdGg6IGZ1bGxXaWR0aCA/ICcxMDAlJyA6IHVuZGVmaW5lZCxcclxuICAgICAgICAgICAgbWF4V2lkdGg6IGZ1bGxXaWR0aCA/IGAke2FuY2hvckRpbWVuc2lvbnMud2lkdGh9cHhgIDogdW5kZWZpbmVkLFxyXG4gICAgICAgICAgICBwb3NpdGlvbjogZml4ZWQgPyAnZml4ZWQnIDogJ2Fic29sdXRlJyxcclxuICAgICAgICAgICAgdHJhbnNmb3JtT3JpZ2luOiBfdHJhbnNmb3JtT3JpZ2luXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgY29uc3Qgc2Nyb2xsWSA9IChtb2RhbCA/IHdpbmRvdy5zY3JvbGxZIDogMCk7XHJcbiAgICAgICAgY29uc3Qgc2Nyb2xsWCA9IChtb2RhbCA/IHdpbmRvdy5zY3JvbGxYIDogMCk7XHJcblxyXG4gICAgICAgIGNvbnN0IGFuY2hvck9yaWdpbiA9IGdldEFuY2hvck9yaWdpbihfYW5jaG9yT3JpZ2luKTtcclxuICAgICAgICBjb25zdCB0cmFuc2Zvcm1PcmlnaW4gPSBnZXRBbmNob3JPcmlnaW4oX3RyYW5zZm9ybU9yaWdpbik7XHJcblxyXG4gICAgICAgIGlmIChhbmNob3JPcmlnaW4udG9wKSB7XHJcbiAgICAgICAgICAgIHN0eWxlLnRvcCA9IGFuY2hvckRpbWVuc2lvbnMudG9wO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoYW5jaG9yT3JpZ2luLmJvdHRvbSkge1xyXG4gICAgICAgICAgICBzdHlsZS50b3AgPSBhbmNob3JEaW1lbnNpb25zLmJvdHRvbTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChhbmNob3JPcmlnaW4ubGVmdCkge1xyXG4gICAgICAgICAgICBzdHlsZS5sZWZ0ID0gYW5jaG9yRGltZW5zaW9ucy5sZWZ0O1xyXG4gICAgICAgIH0gZWxzZSBpZiAoYW5jaG9yT3JpZ2luLnJpZ2h0KSB7XHJcbiAgICAgICAgICAgIHN0eWxlLmxlZnQgPSBhbmNob3JEaW1lbnNpb25zLnJpZ2h0O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHRyYW5zZm9ybU9yaWdpbi50b3ApIHtcclxuICAgICAgICAgICAgY29uc3QgdG9wID0gc2Nyb2xsWSArIHN0eWxlLnRvcDtcclxuICAgICAgICAgICAgY29uc3QgYm90dG9tT3ZlcmZsb3cgPSBzY3JvbGxZICsgKGFuY2hvck9yaWdpbi5ib3R0b20gPyBhbmNob3JDbGllbnRSZWN0LmJvdHRvbSA6IGFuY2hvckNsaWVudFJlY3QudG9wKSArIGhlaWdodCAtIHdpbmRvdy5pbm5lckhlaWdodDtcclxuXHJcbiAgICAgICAgICAgIHN0eWxlLnRvcCA9IGAke2JvdHRvbU92ZXJmbG93ID4gMCA/ICh0b3AgLSBib3R0b21PdmVyZmxvdykgOiB0b3B9cHhgO1xyXG4gICAgICAgIH0gZWxzZSBpZiAodHJhbnNmb3JtT3JpZ2luLmJvdHRvbSkge1xyXG4gICAgICAgICAgICBjb25zdCB0b3AgPSBzY3JvbGxZICsgc3R5bGUudG9wIC0gaGVpZ2h0O1xyXG4gICAgICAgICAgICBjb25zdCB0b3BPdmVyZmxvdyA9IHNjcm9sbFkgKyAoYW5jaG9yT3JpZ2luLmJvdHRvbSA/IGFuY2hvckNsaWVudFJlY3QuYm90dG9tIDogYW5jaG9yQ2xpZW50UmVjdC50b3ApIC0gaGVpZ2h0O1xyXG5cclxuICAgICAgICAgICAgc3R5bGUudG9wID0gYCR7dG9wT3ZlcmZsb3cgPiAwID8gdG9wIDogMH1weGA7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAodHJhbnNmb3JtT3JpZ2luLmxlZnQpIHtcclxuICAgICAgICAgICAgY29uc3QgbGVmdCA9IHN0eWxlLmxlZnQ7XHJcbiAgICAgICAgICAgIGNvbnN0IHJpZ2h0T3ZlcmZsb3cgPSB3aW5kb3cuaW5uZXJXaWR0aCAtIChhbmNob3JPcmlnaW4ubGVmdCA/IGFuY2hvckNsaWVudFJlY3QubGVmdCA6IGFuY2hvckNsaWVudFJlY3QucmlnaHQpICsgd2lkdGg7XHJcblxyXG4gICAgICAgICAgICBzdHlsZS5sZWZ0ID0gYCR7cmlnaHRPdmVyZmxvdyA+IDAgPyBsZWZ0IDogbGVmdCAtIE1hdGguYWJzKHJpZ2h0T3ZlcmZsb3cpfXB4YDtcclxuICAgICAgICB9IGVsc2UgaWYgKHRyYW5zZm9ybU9yaWdpbi5yaWdodCkge1xyXG4gICAgICAgICAgICBjb25zdCBsZWZ0ID0gc3R5bGUubGVmdCAtIHdpZHRoO1xyXG4gICAgICAgICAgICBjb25zdCBsZWZ0T3ZlcmZsb3cgPSAoYW5jaG9yT3JpZ2luLnJpZ2h0ID8gYW5jaG9yQ2xpZW50UmVjdC5yaWdodCA6IGFuY2hvckNsaWVudFJlY3QubGVmdCkgLSB3aWR0aDtcclxuXHJcbiAgICAgICAgICAgIHN0eWxlLmxlZnQgPSBgJHtsZWZ0T3ZlcmZsb3cgPiAwID8gbGVmdCA6IDB9cHhgO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcm9vdFJlZi5jdXJyZW50LnN0eWxlLnRvcCA9IHN0eWxlLnRvcDtcclxuICAgICAgICByb290UmVmLmN1cnJlbnQuc3R5bGUubGVmdCA9IHN0eWxlLmxlZnQ7XHJcbiAgICAgICAgcm9vdFJlZi5jdXJyZW50LnN0eWxlLnBvc2l0aW9uID0gc3R5bGUucG9zaXRpb247XHJcbiAgICAgICAgcm9vdFJlZi5jdXJyZW50LnN0eWxlLndpZHRoID0gc3R5bGUud2lkdGg7XHJcbiAgICAgICAgcm9vdFJlZi5jdXJyZW50LnN0eWxlLm1heFdpZHRoID0gc3R5bGUubWF4V2lkdGg7XHJcbiAgICAgICAgcm9vdFJlZi5jdXJyZW50LnN0eWxlLnRyYW5zZm9ybU9yaWdpbiA9IHN0eWxlLnRyYW5zZm9ybU9yaWdpbjtcclxuICAgIH0sIFtvcGVuLCBtb2RhbCwgX2FuY2hvck9yaWdpbiwgX3RyYW5zZm9ybU9yaWdpbl0pO1xyXG5cclxuICAgIGNvbnN0IGhhbmRsZUtleURvd24gPSB1c2VDYWxsYmFjayhldmVudCA9PiB7XHJcbiAgICAgICAgaWYgKGV2ZW50LmtleSA9PT0gJ0VzY2FwZScgJiYgIXBlcnNpc3RlbnQpIHtcclxuICAgICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XHJcbiAgICAgICAgICAgIG9uQ2xvc2UoZXZlbnQpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgb25LZXlEb3duKGV2ZW50KTtcclxuICAgIH0sIFtwZXJzaXN0ZW50LCBvbktleURvd24sIG9uQ2xvc2VdKTtcclxuXHJcbiAgICBjb25zdCBpc0JlbG93QW5jaG9yID0gKFxyXG4gICAgICAgIF9hbmNob3JPcmlnaW4uaW5jbHVkZXMoJ2JvdHRvbScpICYmXHJcbiAgICAgICAgX3RyYW5zZm9ybU9yaWdpbi5pbmNsdWRlcygndG9wJylcclxuICAgICk7XHJcblxyXG4gICAgY29uc3QgY2xhc3NOYW1lcyA9IGNsYXNzbmFtZXMoY3NzQ2xhc3Nlcy5TVVJGQUNFLCB7XHJcbiAgICAgICAgW2Nzc0NsYXNzZXMuU1VSRkFDRV9GSVhFRF06IGZpeGVkLFxyXG4gICAgICAgIFtjc3NDbGFzc2VzLlNVUkZBQ0VfQkVMT1dfQU5DSE9SXTogaXNCZWxvd0FuY2hvclxyXG4gICAgfSwgY2xhc3NOYW1lKTtcclxuXHJcbiAgICByZXR1cm4gKDw+XHJcbiAgICAgICAge2FuY2hvciAmJlxyXG4gICAgICAgICAgICBjbG9uZShhbmNob3IsIHsgcmVmOiBhbmNob3JSZWYgfSlcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIDxMYXllclxyXG4gICAgICAgICAgICBpbj17b3Blbn1cclxuICAgICAgICAgICAgbW9kYWw9e21vZGFsfVxyXG4gICAgICAgICAgICB0aW1lb3V0PXtxdWljayA/IDAgOiB7XHJcbiAgICAgICAgICAgICAgICBlbnRlcjogbnVtYmVycy5UUkFOU0lUSU9OX09QRU5fRFVSQVRJT04sXHJcbiAgICAgICAgICAgICAgICBleGl0OiBudW1iZXJzLlRSQU5TSVRJT05fQ0xPU0VfRFVSQVRJT05cclxuICAgICAgICAgICAgfX1cclxuICAgICAgICAgICAgY2xhc3NOYW1lcz17cXVpY2sgPyB7XHJcbiAgICAgICAgICAgICAgICBlbnRlckRvbmU6IGNzc0NsYXNzZXMuU1VSRkFDRV9PUEVOLFxyXG4gICAgICAgICAgICB9IDoge1xyXG4gICAgICAgICAgICAgICAgZW50ZXI6IGNzc0NsYXNzZXMuU1VSRkFDRV9BTklNQVRJTkdfT1BFTixcclxuICAgICAgICAgICAgICAgIGVudGVyQWN0aXZlOiBjc3NDbGFzc2VzLlNVUkZBQ0VfQU5JTUFUSU5HX09QRU4sXHJcbiAgICAgICAgICAgICAgICBlbnRlckRvbmU6IGNzc0NsYXNzZXMuU1VSRkFDRV9PUEVOLFxyXG4gICAgICAgICAgICAgICAgZXhpdDogY3NzQ2xhc3Nlcy5TVVJGQUNFX09QRU4sXHJcbiAgICAgICAgICAgICAgICBleGl0QWN0aXZlOiBjc3NDbGFzc2VzLlNVUkZBQ0VfQU5JTUFUSU5HX0NMT1NFRFxyXG4gICAgICAgICAgICB9fVxyXG4gICAgICAgICAgICBtb3VudE9uRW50ZXJcclxuICAgICAgICAgICAgdW5tb3VudE9uRXhpdFxyXG4gICAgICAgID5cclxuICAgICAgICAgICAgPGRpdlxyXG4gICAgICAgICAgICAgICAgcmVmPXtyb290UmVmfVxyXG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lPXtjbGFzc05hbWVzfVxyXG4gICAgICAgICAgICAgICAgb25LZXlEb3duPXtoYW5kbGVLZXlEb3dufVxyXG4gICAgICAgICAgICAgICAgey4uLnByb3BzfVxyXG4gICAgICAgICAgICAvPlxyXG4gICAgICAgIDwvTGF5ZXI+XHJcbiAgICA8Lz4pO1xyXG59KTtcclxuXHJcbk1lbnVTdXJmYWNlLmRpc3BsYXlOYW1lID0gJ01EQ01lbnVTdXJmYWNlJztcclxuXHJcbk1lbnVTdXJmYWNlLnByb3BUeXBlcyA9IHtcclxuICAgIGFuY2hvcjogUHJvcFR5cGVzLmVsZW1lbnQsXHJcbiAgICBhbmNob3JSZWY6IFByb3BUeXBlcy5vYmplY3QsXHJcbiAgICBhbmNob3JPcmlnaW46IFByb3BUeXBlcy5vbmVPZihPYmplY3QudmFsdWVzKE9yaWdpbikpLFxyXG4gICAgb3BlbjogUHJvcFR5cGVzLmJvb2wsXHJcbiAgICBtb2RhbDogUHJvcFR5cGVzLmJvb2wsXHJcbiAgICBxdWljazogUHJvcFR5cGVzLmJvb2wsXHJcbiAgICBmaXhlZDogUHJvcFR5cGVzLmJvb2wsXHJcbiAgICBwZXJzaXN0ZW50OiBQcm9wVHlwZXMuYm9vbCxcclxuICAgIGZ1bGxXaWR0aDogUHJvcFR5cGVzLmJvb2wsXHJcbiAgICBvbkNsb3NlOiBQcm9wVHlwZXMuZnVuY1xyXG59O1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgTWVudVN1cmZhY2U7IiwiaW1wb3J0IHsgZm9yd2FyZFJlZiwgdXNlU3RhdGUsIHVzZUVmZmVjdCwgdXNlQ2FsbGJhY2ssIHVzZVJlZiwgQ2hpbGRyZW4gfSBmcm9tICdyZWFjdCc7XHJcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XHJcbmltcG9ydCBjbGFzc25hbWVzIGZyb20gJ2NsYXNzbmFtZXMnO1xyXG5cclxuaW1wb3J0IHsgdXNlVXBkYXRlZCB9IGZyb20gJy4uL2hvb2tzJztcclxuaW1wb3J0IHsgQ2xvbmUsIGNyZWF0ZSB9IGZyb20gJy4uL2NvbXBvbmVudCc7XHJcbmltcG9ydCBMaXN0IGZyb20gJy4uL2xpc3QnO1xyXG5cclxuaW1wb3J0IHsgY3NzQ2xhc3NlcyB9IGZyb20gJy4vY29uc3RhbnRzJztcclxuaW1wb3J0IE1lbnVJdGVtIGZyb20gJy4vTWVudUl0ZW0nO1xyXG5pbXBvcnQgTWVudVN1cmZhY2UgZnJvbSAnLi9NZW51U3VyZmFjZSc7XHJcblxyXG5jb25zdCBNZW51ID0gZm9yd2FyZFJlZigoe1xyXG4gICAgb3BlbixcclxuICAgIGl0ZW1zLFxyXG4gICAgbGlzdFByb3BzID0ge30sXHJcblxyXG4gICAgY2hpbGRyZW4gPSBpdGVtcz8ubWFwKGl0ZW0gPT4gY3JlYXRlKE1lbnVJdGVtLCBpdGVtKSksXHJcbiAgICBjbGFzc05hbWUsXHJcbiAgICAuLi5wcm9wc1xyXG59LCByZWYpID0+IHtcclxuICAgIGNvbnN0IGxpc3RSZWYgPSB1c2VSZWYoKTtcclxuXHJcbiAgICBjb25zdCBbZm9jdXNlZENoaWxkSW5kZXgsIHNldEZvY3VzZWRDaGlsZEluZGV4XSA9IHVzZVN0YXRlKDApO1xyXG5cclxuICAgIHVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICAgICAgaWYgKG9wZW4pIHtcclxuICAgICAgICAgICAgc2V0Rm9jdXNlZENoaWxkSW5kZXgoXHJcbiAgICAgICAgICAgICAgICBDaGlsZHJlbi50b0FycmF5KGNoaWxkcmVuKS5maW5kSW5kZXgoaSA9PiBpLnByb3BzLnNlbGVjdGVkKVxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgIH1cclxuICAgIH0sIFtvcGVuLCBjaGlsZHJlbl0pO1xyXG5cclxuICAgIHVzZVVwZGF0ZWQoKCkgPT4ge1xyXG4gICAgICAgIGlmIChvcGVuKSB7XHJcbiAgICAgICAgICAgIGxpc3RSZWYuY3VycmVudC5jaGlsZHJlbltmb2N1c2VkQ2hpbGRJbmRleF0/LmZvY3VzKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfSwgW2ZvY3VzZWRDaGlsZEluZGV4LCBvcGVuXSk7XHJcblxyXG4gICAgY29uc3QgaGFuZGxlS2V5RG93biA9IHVzZUNhbGxiYWNrKGV2ZW50ID0+IHtcclxuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xyXG5cclxuICAgICAgICBpZiAoZXZlbnQua2V5ID09PSAnQXJyb3dEb3duJykge1xyXG4gICAgICAgICAgICBzZXRGb2N1c2VkQ2hpbGRJbmRleChpbmRleCA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBuZXh0SW5kZXggPSBpbmRleCArIDE7XHJcblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5leHRJbmRleCA8IGxpc3RSZWYuY3VycmVudC5jaGlsZHJlbi5sZW5ndGggPyBuZXh0SW5kZXggOiBpbmRleDtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSBlbHNlIGlmIChldmVudC5rZXkgPT09ICdBcnJvd1VwJykge1xyXG4gICAgICAgICAgICBzZXRGb2N1c2VkQ2hpbGRJbmRleChpbmRleCA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBuZXh0SW5kZXggPSBpbmRleCAtIDE7XHJcblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5leHRJbmRleCA+PSAwID8gbmV4dEluZGV4IDogaW5kZXg7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH0sIFtdKTtcclxuXHJcbiAgICBjb25zdCBjbGFzc05hbWVzID0gY2xhc3NuYW1lcyhjc3NDbGFzc2VzLlJPT1QsIGNsYXNzTmFtZSk7XHJcblxyXG4gICAgcmV0dXJuIChcclxuICAgICAgICA8TWVudVN1cmZhY2VcclxuICAgICAgICAgICAgcmVmPXtyZWZ9XHJcbiAgICAgICAgICAgIG9wZW49e29wZW59XHJcbiAgICAgICAgICAgIGNsYXNzTmFtZT17Y2xhc3NOYW1lc31cclxuICAgICAgICAgICAgb25LZXlEb3duPXtoYW5kbGVLZXlEb3dufVxyXG4gICAgICAgICAgICB7Li4ucHJvcHN9XHJcbiAgICAgICAgPlxyXG4gICAgICAgICAgICA8TGlzdFxyXG4gICAgICAgICAgICAgICAgcmVmPXtsaXN0UmVmfVxyXG4gICAgICAgICAgICAgICAgcm9sZT1cIm1lbnVcIlxyXG4gICAgICAgICAgICAgICAgYXJpYS1oaWRkZW49XCJ0cnVlXCJcclxuICAgICAgICAgICAgICAgIGFyaWEtb3JpZW50YXRpb249XCJ2ZXJ0aWNhbFwiXHJcbiAgICAgICAgICAgICAgICB0YWJJbmRleD17b3BlbiA/IDAgOiAtMX1cclxuICAgICAgICAgICAgICAgIHsuLi5saXN0UHJvcHN9XHJcbiAgICAgICAgICAgID5cclxuICAgICAgICAgICAgICAgIHtDaGlsZHJlbi5tYXAoY2hpbGRyZW4sIChpdGVtLCBpbmRleCkgPT5cclxuICAgICAgICAgICAgICAgICAgICA8Q2xvbmVcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50PXtpdGVtfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0YWJJbmRleD17KGluZGV4ID09PSBmb2N1c2VkQ2hpbGRJbmRleCkgPyAwIDogLTF9XHJcbiAgICAgICAgICAgICAgICAgICAgLz5cclxuICAgICAgICAgICAgICAgICl9XHJcbiAgICAgICAgICAgIDwvTGlzdD5cclxuICAgICAgICA8L01lbnVTdXJmYWNlPlxyXG4gICAgKTtcclxufSk7XHJcblxyXG5NZW51LmRpc3BsYXlOYW1lID0gJ01EQ01lbnUnO1xyXG5cclxuTWVudS5wcm9wVHlwZXMgPSB7XHJcbiAgICAuLi5NZW51U3VyZmFjZS5wcm9wVHlwZXMsXHJcbiAgICBsaXN0UHJvcHM6IFByb3BUeXBlcy5vYmplY3RcclxufTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IE1lbnU7IiwiaW1wb3J0IHsgZm9yd2FyZFJlZiB9IGZyb20gJ3JlYWN0JztcclxuaW1wb3J0IGNsYXNzbmFtZXMgZnJvbSAnY2xhc3NuYW1lcyc7XHJcblxyXG5pbXBvcnQgeyBjcmVhdGUsIGNsb25lIH0gZnJvbSAnLi4vY29tcG9uZW50JztcclxuaW1wb3J0IHsgY3NzQ2xhc3NlcyB9IGZyb20gJy4vY29uc3RhbnRzJztcclxuXHJcbmNvbnN0IE1lbnVBbmNob3IgPSBmb3J3YXJkUmVmKCh7XHJcbiAgICB3cmFwID0gdHJ1ZSxcclxuXHJcbiAgICBlbGVtZW50ID0gJ2RpdicsXHJcbiAgICBjbGFzc05hbWUsXHJcbiAgICBjaGlsZHJlbixcclxuICAgIC4uLnByb3BzXHJcbn0sIHJlZikgPT4ge1xyXG4gICAgcmV0dXJuIHdyYXAgP1xyXG4gICAgICAgIGNyZWF0ZShlbGVtZW50LCB7XHJcbiAgICAgICAgICAgIHJlZixcclxuICAgICAgICAgICAgY2xhc3NOYW1lOiBjbGFzc25hbWVzKGNzc0NsYXNzZXMuU1VSRkFDRV9BTkNIT1IsIGNsYXNzTmFtZSksXHJcbiAgICAgICAgICAgIC4uLnByb3BzXHJcbiAgICAgICAgfSwgY2hpbGRyZW4pXHJcbiAgICAgICAgOlxyXG4gICAgICAgIGNsb25lKGNoaWxkcmVuLCB7XHJcbiAgICAgICAgICAgIHJlZixcclxuICAgICAgICAgICAgY2xhc3NOYW1lOiBjbGFzc25hbWVzKGNoaWxkcmVuLnByb3BzLmNsYXNzTmFtZSwgY3NzQ2xhc3Nlcy5TVVJGQUNFX0FOQ0hPUiksXHJcbiAgICAgICAgICAgIC4uLnByb3BzXHJcbiAgICAgICAgfSk7XHJcbn0pO1xyXG5cclxuTWVudUFuY2hvci5kaXNwbGF5TmFtZSA9ICdNRENNZW51QW5jaG9yJztcclxuXHJcbmV4cG9ydCBkZWZhdWx0IE1lbnVBbmNob3I7IiwiaW1wb3J0IHsgZm9yd2FyZFJlZiB9IGZyb20gJ3JlYWN0JztcclxuXHJcbmNvbnN0IE1lbnVTZWxlY3Rpb25Hcm91cCA9IGZvcndhcmRSZWYoKHtcclxuICAgIGVsZW1lbnQ6IEVsZW1lbnQgPSAndWwnLFxyXG4gICAgLi4ucHJvcHNcclxufSwgcmVmKSA9PiB7XHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAgIDxsaSByZWY9e3JlZn0+XHJcbiAgICAgICAgICAgIDxFbGVtZW50IGNsYXNzTmFtZT1cIm1kYy1tZW51X19zZWxlY3Rpb24tZ3JvdXBcIiB7Li4ucHJvcHN9IC8+XHJcbiAgICAgICAgPC9saT5cclxuICAgICk7XHJcbn0pO1xyXG5cclxuTWVudVNlbGVjdGlvbkdyb3VwLmRpc3BsYXlOYW1lID0gJ01EQ01lbnVTZWxlY3Rpb25Hcm91cCc7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBNZW51U2VsZWN0aW9uR3JvdXA7IiwiaW1wb3J0IEljb24gZnJvbSAnLi4vaWNvbic7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBNZW51U2VsZWN0aW9uR3JvdXBJY29uKHByb3BzKSB7XHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAgIDxJY29uXHJcbiAgICAgICAgICAgIGNsYXNzTmFtZT1cIm1kYy1tZW51X19zZWxlY3Rpb24tZ3JvdXAtaWNvblwiXHJcbiAgICAgICAgICAgIHsuLi5wcm9wc31cclxuICAgICAgICAvPlxyXG4gICAgKTtcclxufVxyXG5cclxuTWVudVNlbGVjdGlvbkdyb3VwSWNvbi5kaXNwbGF5TmFtZSA9ICdNRENNZW51U2VsZWN0aW9uR3JvdXBJY29uJzsiLCJpbXBvcnQgeyBPcmlnaW4gYXMgTWVudU9yaWdpbiB9IGZyb20gJy4vY29uc3RhbnRzJztcclxuaW1wb3J0IE1lbnUgZnJvbSAnLi9NZW51JztcclxuaW1wb3J0IE1lbnVBbmNob3IgZnJvbSAnLi9NZW51QW5jaG9yJztcclxuaW1wb3J0IE1lbnVJdGVtIGZyb20gJy4vTWVudUl0ZW0nO1xyXG5pbXBvcnQgTWVudVN1cmZhY2UgZnJvbSAnLi9NZW51U3VyZmFjZSc7XHJcbmltcG9ydCBNZW51U2VsZWN0aW9uR3JvdXAgZnJvbSAnLi9NZW51U2VsZWN0aW9uR3JvdXAnO1xyXG5pbXBvcnQgTWVudVNlbGVjdGlvbkdyb3VwSWNvbiBmcm9tICcuL01lbnVTZWxlY3Rpb25Hcm91cEljb24nO1xyXG5cclxuTWVudS5BbmNob3IgPSBNZW51QW5jaG9yO1xyXG5NZW51Lkl0ZW0gPSBNZW51SXRlbTtcclxuTWVudS5PcmlnaW4gPSBNZW51T3JpZ2luO1xyXG5NZW51LlN1cmZhY2UgPSBNZW51U3VyZmFjZTtcclxuTWVudS5TZWxlY3Rpb25Hcm91cCA9IE1lbnVTZWxlY3Rpb25Hcm91cDtcclxuTWVudS5TZWxlY3Rpb25Hcm91cEljb24gPSBNZW51U2VsZWN0aW9uR3JvdXBJY29uO1xyXG5cclxuZXhwb3J0IHtcclxuICAgIE1lbnUgYXMgZGVmYXVsdCxcclxuICAgIE1lbnVBbmNob3IsXHJcbiAgICBNZW51SXRlbSxcclxuICAgIE1lbnVPcmlnaW4sXHJcbiAgICBNZW51U3VyZmFjZSxcclxuICAgIE1lbnVTZWxlY3Rpb25Hcm91cCxcclxuICAgIE1lbnVTZWxlY3Rpb25Hcm91cEljb25cclxufTsiLCJleHBvcnQgY29uc3QgY3NzQ2xhc3NlcyA9IHtcclxuICAgIFJPT1Q6ICdtZGMtc2VsZWN0JyxcclxuICAgIEZJTExFRDogJ21kYy1zZWxlY3QtLWZpbGxlZCcsXHJcbiAgICBPVVRMSU5FRDogJ21kYy1zZWxlY3QtLW91dGxpbmVkJyxcclxuICAgIEFDVElWQVRFRDogJ21kYy1zZWxlY3QtLWFjdGl2YXRlZCcsXHJcbiAgICBESVNBQkxFRDogJ21kYy1zZWxlY3QtLWRpc2FibGVkJyxcclxuICAgIEZPQ1VTRUQ6ICdtZGMtc2VsZWN0LS1mb2N1c2VkJyxcclxuICAgIFJFUVVJUkVEOiAnbWRjLXNlbGVjdC0tcmVxdWlyZWQnLFxyXG4gICAgSU5WQUxJRDogJ21kYy1zZWxlY3QtLWludmFsaWQnLFxyXG4gICAgTk9fTEFCRUw6ICdtZGMtc2VsZWN0LS1uby1sYWJlbCcsXHJcbiAgICBXSVRIX0xFQURJTkdfSUNPTjogJ21kYy1zZWxlY3QtLXdpdGgtbGVhZGluZy1pY29uJyxcclxuXHJcbiAgICBTRUxFQ1RFRF9URVhUOiAnbWRjLXNlbGVjdF9fc2VsZWN0ZWQtdGV4dCcsXHJcbiAgICBTRUxFQ1RFRF9URVhUX0NPTlRBSU5FUjogJ21kYy1zZWxlY3RfX3NlbGVjdGVkLXRleHQtY29udGFpbmVyJyxcclxuXHJcbiAgICBEUk9QRE9XTl9JQ09OOiAnbWRjLXNlbGVjdF9fZHJvcGRvd24taWNvbicsXHJcbiAgICBEUk9QRE9XTl9JQ09OX0dSQVBISUM6ICdtZGMtc2VsZWN0X19kcm9wZG93bi1pY29uLWdyYXBoaWMnLFxyXG4gICAgRFJPUERPV05fSUNPTl9JTkFDVElWRTogJ21kYy1zZWxlY3RfX2Ryb3Bkb3duLWljb24taW5hY3RpdmUnLFxyXG4gICAgRFJPUERPV05fSUNPTl9BQ1RJVkU6ICdtZGMtc2VsZWN0X19kcm9wZG93bi1pY29uLWFjdGl2ZScsXHJcblxyXG4gICAgSUNPTjogJ21kYy1zZWxlY3RfX2ljb24nLFxyXG5cclxuICAgIE1FTlU6ICdtZGMtc2VsZWN0X19tZW51JyxcclxuICAgIE1FTlVfSU5WQUxJRDogJ21kYy1zZWxlY3RfX21lbnUtLWludmFsaWQnLFxyXG5cclxuICAgIFJJUFBMRTogJ21kYy1zZWxlY3RfX3JpcHBsZScsXHJcblxyXG4gICAgQU5DSE9SOiAnbWRjLXNlbGVjdF9fYW5jaG9yJyxcclxuXHJcbiAgICBIRUxQRVJfVEVYVDogJ21kYy1zZWxlY3QtaGVscGVyLXRleHQnLFxyXG4gICAgVkFMSURBVElPTl9NRVNTQUdFOiAnbWRjLXNlbGVjdC1oZWxwZXItdGV4dC0tdmFsaWRhdGlvbi1tc2cnLFxyXG4gICAgVkFMSURBVElPTl9NRVNTQUdFX1BFUlNJU1RFTlQ6ICdtZGMtc2VsZWN0LWhlbHBlci10ZXh0LS12YWxpZGF0aW9uLW1zZy1wZXJzaXN0ZW50J1xyXG59OyIsImltcG9ydCB7IGNzc0NsYXNzZXMgfSBmcm9tICcuL2NvbnN0YW50cyc7XHJcblxyXG5jb25zdCBEcm9wZG93bkljb24gPSAoKSA9PiB7XHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAgIDxzcGFuIGNsYXNzTmFtZT17Y3NzQ2xhc3Nlcy5EUk9QRE9XTl9JQ09OfT5cclxuICAgICAgICAgICAgPHN2Z1xyXG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lPXtjc3NDbGFzc2VzLkRST1BET1dOX0lDT05fR1JBUEhJQ31cclxuICAgICAgICAgICAgICAgIHZpZXdCb3g9XCI3IDEwIDEwIDVcIlxyXG4gICAgICAgICAgICAgICAgZm9jdXNhYmxlPVwiZmFsc2VcIlxyXG4gICAgICAgICAgICA+XHJcbiAgICAgICAgICAgICAgICA8cG9seWdvblxyXG4gICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT17Y3NzQ2xhc3Nlcy5EUk9QRE9XTl9JQ09OX0lOQUNUSVZFfVxyXG4gICAgICAgICAgICAgICAgICAgIHN0cm9rZT1cIm5vbmVcIlxyXG4gICAgICAgICAgICAgICAgICAgIGZpbGxSdWxlPVwiZXZlbm9kZFwiXHJcbiAgICAgICAgICAgICAgICAgICAgcG9pbnRzPVwiNyAxMCAxMiAxNSAxNyAxMFwiXHJcbiAgICAgICAgICAgICAgICAvPlxyXG5cclxuICAgICAgICAgICAgICAgIDxwb2x5Z29uXHJcbiAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPXtjc3NDbGFzc2VzLkRST1BET1dOX0lDT05fQUNUSVZFfVxyXG4gICAgICAgICAgICAgICAgICAgIHN0cm9rZT1cIm5vbmVcIlxyXG4gICAgICAgICAgICAgICAgICAgIGZpbGxSdWxlPVwiZXZlbm9kZFwiXHJcbiAgICAgICAgICAgICAgICAgICAgcG9pbnRzPVwiNyAxNSAxMiAxMCAxNyAxNVwiXHJcbiAgICAgICAgICAgICAgICAvPlxyXG4gICAgICAgICAgICA8L3N2Zz5cclxuICAgICAgICA8L3NwYW4+XHJcbiAgICApO1xyXG59O1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgRHJvcGRvd25JY29uOyIsImltcG9ydCB7IGZvcndhcmRSZWYgfSBmcm9tICdyZWFjdCc7XHJcblxyXG5pbXBvcnQgQ2hlY2tib3ggZnJvbSAnLi4vY2hlY2tib3gnO1xyXG5pbXBvcnQgeyBNZW51SXRlbSB9IGZyb20gJy4uL21lbnUnO1xyXG5cclxuY29uc3QgU2VsZWN0T3B0aW9uID0gZm9yd2FyZFJlZigoe1xyXG4gICAgc2VsZWN0ZWQsXHJcbiAgICBjaGVja2JveCA9IGZhbHNlLFxyXG4gICAgb25DbGljayxcclxuICAgIC4uLnByb3BzXHJcbn0sIHJlZikgPT4ge1xyXG4gICAgcmV0dXJuIChcclxuICAgICAgICA8TWVudUl0ZW1cclxuICAgICAgICAgICAgcmVmPXtyZWZ9XHJcbiAgICAgICAgICAgIHN0YXJ0PXtjaGVja2JveCAmJiA8Q2hlY2tib3ggY2hlY2tlZD17c2VsZWN0ZWR9IC8+fVxyXG4gICAgICAgICAgICBzZWxlY3RlZD17c2VsZWN0ZWR9XHJcbiAgICAgICAgICAgIHdpdGhMZWFkaW5nQ2hlY2tib3g9e2NoZWNrYm94fVxyXG4gICAgICAgICAgICBvbkNsaWNrPXtvbkNsaWNrfVxyXG4gICAgICAgICAgICB7Li4ucHJvcHN9XHJcbiAgICAgICAgLz5cclxuICAgICk7XHJcbn0pO1xyXG5cclxuU2VsZWN0T3B0aW9uLmRpc3BsYXlOYW1lID0gJ01EQ1NlbGVjdE9wdGlvbic7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBTZWxlY3RPcHRpb247IiwiaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcclxuaW1wb3J0IGNsYXNzbmFtZXMgZnJvbSAnY2xhc3NuYW1lcyc7XHJcblxyXG5pbXBvcnQgeyBjc3NDbGFzc2VzIH0gZnJvbSAnLi9jb25zdGFudHMnO1xyXG5cclxuY29uc3QgSGVscGVyVGV4dCA9ICh7XHJcbiAgICB2YWxpZGF0aW9uID0gZmFsc2UsXHJcbiAgICBwZXJzaXN0ZW50ID0gZmFsc2UsXHJcblxyXG4gICAgZWxlbWVudDogRWxlbWVudCA9ICdwJyxcclxuICAgIC4uLnByb3BzXHJcbn0pID0+IHtcclxuICAgIGNvbnN0IGNsYXNzTmFtZXMgPSBjbGFzc25hbWVzKGNzc0NsYXNzZXMuSEVMUEVSX1RFWFQsIHtcclxuICAgICAgICBbY3NzQ2xhc3Nlcy5WQUxJREFUSU9OX01FU1NBR0VdOiB2YWxpZGF0aW9uLFxyXG4gICAgICAgIFtjc3NDbGFzc2VzLlZBTElEQVRJT05fTUVTU0FHRV9QRVJTSVNURU5UXTogcGVyc2lzdGVudFxyXG4gICAgfSk7XHJcblxyXG4gICAgcmV0dXJuIChcclxuICAgICAgICA8RWxlbWVudCBjbGFzc05hbWU9e2NsYXNzTmFtZXN9IHsuLi5wcm9wc30gLz5cclxuICAgICk7XHJcbn07XHJcblxyXG5IZWxwZXJUZXh0LmRpc3BsYXlOYW1lID0gJ01EQ1NlbGVjdEhlbHBlclRleHQnO1xyXG5cclxuSGVscGVyVGV4dC5wcm9wVHlwZXMgPSB7XHJcbiAgICBwZXJzaXN0ZW50OiBQcm9wVHlwZXMuYm9vbCxcclxuICAgIHZhbGlkYXRpb246IFByb3BUeXBlcy5ib29sXHJcbn07XHJcblxyXG5leHBvcnQgZGVmYXVsdCBIZWxwZXJUZXh0OyIsImltcG9ydCB7IHVzZVJlZiwgdXNlU3RhdGUsIHVzZUVmZmVjdCwgdXNlQ2FsbGJhY2ssIENoaWxkcmVuLCBmb3J3YXJkUmVmIH0gZnJvbSAncmVhY3QnO1xyXG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xyXG5pbXBvcnQgY2xhc3NuYW1lcyBmcm9tICdjbGFzc25hbWVzJztcclxuXHJcbmltcG9ydCB7IGlzVW5kZWZpbmVkLCBpc0FycmF5IH0gZnJvbSAnLi4vdHlwZXMnO1xyXG5pbXBvcnQgeyBDbG9uZSwgY3JlYXRlLCBjbG9uZSB9IGZyb20gJy4uL2NvbXBvbmVudCc7XHJcbmltcG9ydCBGbG9hdGluZ0xhYmVsIGZyb20gJy4uL2Zsb2F0aW5nLWxhYmVsJztcclxuaW1wb3J0IEljb24gZnJvbSAnLi4vaWNvbic7XHJcbmltcG9ydCBMaW5lUmlwcGxlIGZyb20gJy4uL2xpbmUtcmlwcGxlJztcclxuaW1wb3J0IE5vdGNoZWRPdXRsaW5lIGZyb20gJy4uL25vdGNoZWQtb3V0bGluZSc7XHJcbmltcG9ydCBNZW51LCB7IE1lbnVPcmlnaW4gfSBmcm9tICcuLi9tZW51JztcclxuXHJcbmltcG9ydCB7IGNzc0NsYXNzZXMgfSBmcm9tICcuL2NvbnN0YW50cyc7XHJcbmltcG9ydCBEcm9wZG93bkljb24gZnJvbSAnLi9Ecm9wZG93bkljb24nO1xyXG5pbXBvcnQgU2VsZWN0T3B0aW9uIGZyb20gJy4vU2VsZWN0T3B0aW9uJztcclxuaW1wb3J0IEhlbHBlclRleHQgZnJvbSAnLi9IZWxwZXJUZXh0JztcclxuXHJcbmNvbnN0IFNlbGVjdCA9IGZvcndhcmRSZWYoKHtcclxuICAgIG5hbWUsXHJcbiAgICB2YWx1ZSxcclxuICAgIG9wdGlvbnMsXHJcbiAgICBsYWJlbCxcclxuICAgIGljb24sXHJcbiAgICBsZWFkaW5nSWNvbiA9IGljb24sXHJcbiAgICBoZWxwZXJUZXh0LFxyXG4gICAgZmlsbGVkID0gZmFsc2UsXHJcbiAgICBvdXRsaW5lZCA9IGZhbHNlLFxyXG4gICAgbXVsdGlwbGUgPSBpc0FycmF5KHZhbHVlKSxcclxuICAgIGRpc2FibGVkID0gZmFsc2UsXHJcbiAgICByZXF1aXJlZCA9IGZhbHNlLFxyXG4gICAgb25DaGFuZ2UgPSBGdW5jdGlvbi5wcm90b3R5cGUsXHJcbiAgICBtZW51UHJvcHMgPSB7fSxcclxuICAgIGxpc3RQcm9wcyA9IHt9LFxyXG4gICAgaGVscGVyVGV4dFByb3BzID0ge30sXHJcblxyXG4gICAgY2xhc3NOYW1lLFxyXG4gICAgY2hpbGRyZW4gPSBvcHRpb25zPy5tYXAob3B0aW9uID0+IGNyZWF0ZShTZWxlY3RPcHRpb24sIG9wdGlvbikpLFxyXG4gICAgLi4ucHJvcHNcclxufSwgcmVmKSA9PiB7XHJcbiAgICBjb25zdCBhbmNob3JSZWYgPSB1c2VSZWYoKTtcclxuICAgIGNvbnN0IGlucHV0UmVmID0gdXNlUmVmKCk7XHJcbiAgICBjb25zdCBtZW51UmVmID0gdXNlUmVmKCk7XHJcblxyXG4gICAgY29uc3QgW2FjdGl2YXRlZCwgc2V0QWN0aXZhdGVkXSA9IHVzZVN0YXRlKGZhbHNlKTtcclxuICAgIGNvbnN0IFtmb2N1c2VkLCBzZXRGb2N1c2VkXSA9IHVzZVN0YXRlKGZhbHNlKTtcclxuICAgIGNvbnN0IFt0b3VjaGVkLCBzZXRUb3VjaGVkXSA9IHVzZVN0YXRlKGZhbHNlKTtcclxuICAgIGNvbnN0IFtzZWxlY3RlZFRleHQsIHNldFNlbGVjdGVkVGV4dF0gPSB1c2VTdGF0ZSgpO1xyXG4gICAgY29uc3QgW2ludGVyYWN0aW9uQ29vcmRzLCBzZXRJbnRlcmFjdGlvbkNvb3Jkc10gPSB1c2VTdGF0ZSgpO1xyXG5cclxuICAgIHVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICAgICAgaWYgKG11bHRpcGxlKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHNlbGVjdGVkT3B0aW9ucyA9IChDaGlsZHJlbi50b0FycmF5KGNoaWxkcmVuKS5tYXAob3B0aW9uID0+IG9wdGlvbi5wcm9wcykpXHJcbiAgICAgICAgICAgICAgICAuZmlsdGVyKG9wdGlvbiA9PiB2YWx1ZS5pbmNsdWRlcyhvcHRpb24udmFsdWUpKTtcclxuXHJcbiAgICAgICAgICAgIGNvbnN0IHNlbGVjdGVkVGV4dCA9IHNlbGVjdGVkT3B0aW9ucy5tYXAob3B0aW9uID0+IG9wdGlvbi50ZXh0IHx8IG9wdGlvbi5jaGlsZHJlbikuam9pbignLCAnKTtcclxuICAgICAgICAgICAgc2V0U2VsZWN0ZWRUZXh0KHNlbGVjdGVkVGV4dCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgY29uc3Qgc2VsZWN0ZWRPcHRpb24gPSAoQ2hpbGRyZW4udG9BcnJheShjaGlsZHJlbikubWFwKG9wdGlvbiA9PiBvcHRpb24ucHJvcHMpKVxyXG4gICAgICAgICAgICAgICAgLmZpbmQob3B0aW9uID0+IG9wdGlvbi52YWx1ZSA9PT0gdmFsdWUpO1xyXG5cclxuICAgICAgICAgICAgaWYgKHNlbGVjdGVkT3B0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICBzZXRTZWxlY3RlZFRleHQoc2VsZWN0ZWRPcHRpb24udGV4dCB8fCBzZWxlY3RlZE9wdGlvbi5jaGlsZHJlbik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9LCBbdmFsdWUsIG11bHRpcGxlLCBjaGlsZHJlbl0pO1xyXG5cclxuICAgIGNvbnN0IGhhbmRsZUFuY2hvckNsaWNrID0gdXNlQ2FsbGJhY2soZXZlbnQgPT4ge1xyXG4gICAgICAgIGlmIChhY3RpdmF0ZWQpIHtcclxuICAgICAgICAgICAgc2V0QWN0aXZhdGVkKGZhbHNlKTtcclxuICAgICAgICAgICAgc2V0Rm9jdXNlZChmYWxzZSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgY29uc3QgdGFyZ2V0Q2xpZW50UmVjdCA9IGV2ZW50LnRhcmdldC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcclxuXHJcbiAgICAgICAgICAgIHNldEludGVyYWN0aW9uQ29vcmRzKHtcclxuICAgICAgICAgICAgICAgIHg6IGV2ZW50LmNsaWVudFggLSB0YXJnZXRDbGllbnRSZWN0LmxlZnQsXHJcbiAgICAgICAgICAgICAgICB5OiBldmVudC5jbGllbnRZIC0gdGFyZ2V0Q2xpZW50UmVjdC50b3BcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICBzZXRBY3RpdmF0ZWQodHJ1ZSk7XHJcbiAgICAgICAgICAgIHNldEZvY3VzZWQodHJ1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSwgW2FjdGl2YXRlZF0pO1xyXG5cclxuICAgIGNvbnN0IGhhbmRsZU9wdGlvbkludGVyYWN0aW9uID0gdXNlQ2FsbGJhY2soZXZlbnQgPT4ge1xyXG4gICAgICAgIGlmIChcclxuICAgICAgICAgICAgZXZlbnQudHlwZSA9PT0gJ2tleWRvd24nICYmXHJcbiAgICAgICAgICAgIGV2ZW50LmtleSAhPT0gJyAnICYmXHJcbiAgICAgICAgICAgIGV2ZW50LmtleSAhPT0gJ0VudGVyJ1xyXG4gICAgICAgICkgcmV0dXJuO1xyXG5cclxuICAgICAgICBjb25zdCBvcHRpb24gPSBldmVudC5jdXJyZW50VGFyZ2V0LmRhdGFzZXQ7XHJcblxyXG4gICAgICAgIGlmIChvcHRpb24uZGlzYWJsZWQpIHJldHVybjtcclxuXHJcbiAgICAgICAgaWYgKG11bHRpcGxlKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlcyA9IG5ldyBTZXQodmFsdWUpO1xyXG5cclxuICAgICAgICAgICAgdmFsdWVzLmhhcyhvcHRpb24udmFsdWUpID9cclxuICAgICAgICAgICAgICAgIHZhbHVlcy5kZWxldGUob3B0aW9uLnZhbHVlKSA6XHJcbiAgICAgICAgICAgICAgICB2YWx1ZXMuYWRkKG9wdGlvbi52YWx1ZSk7XHJcblxyXG4gICAgICAgICAgICBldmVudC50YXJnZXQgPSB7IG5hbWUsIHZhbHVlOiBbLi4udmFsdWVzXSB9O1xyXG5cclxuICAgICAgICAgICAgb25DaGFuZ2UoZXZlbnQsIFsuLi52YWx1ZXNdKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBldmVudC50YXJnZXQgPSB7IG5hbWUsIHZhbHVlOiBvcHRpb24udmFsdWUgfTtcclxuXHJcbiAgICAgICAgICAgIG9uQ2hhbmdlKGV2ZW50LCBvcHRpb24udmFsdWUpO1xyXG5cclxuICAgICAgICAgICAgc2V0QWN0aXZhdGVkKGZhbHNlKTtcclxuICAgICAgICAgICAgc2V0Rm9jdXNlZChmYWxzZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSwgW3ZhbHVlLCBuYW1lLCBtdWx0aXBsZSwgb25DaGFuZ2VdKTtcclxuXHJcbiAgICBjb25zdCBoYW5kbGVNZW51Q2xvc2UgPSB1c2VDYWxsYmFjayhldmVudCA9PiB7XHJcbiAgICAgICAgaWYgKGV2ZW50LnR5cGUgPT09ICdjbGljaycgJiYgZXZlbnQudGFyZ2V0ID09PSBhbmNob3JSZWYuY3VycmVudCkgcmV0dXJuO1xyXG4gICAgICAgIGlmIChtdWx0aXBsZSAmJiBldmVudC50eXBlID09PSAnY2xpY2snICYmIGV2ZW50LnBhdGguaW5jbHVkZXMobWVudVJlZi5jdXJyZW50KSkgcmV0dXJuO1xyXG5cclxuICAgICAgICBzZXRBY3RpdmF0ZWQoZmFsc2UpO1xyXG4gICAgICAgIHNldEZvY3VzZWQoZmFsc2UpO1xyXG4gICAgICAgIHNldFRvdWNoZWQodHJ1ZSk7XHJcbiAgICB9LCBbbXVsdGlwbGVdKTtcclxuXHJcbiAgICBjb25zdCBoYW5kbGVLZXlEb3duID0gdXNlQ2FsbGJhY2soZXZlbnQgPT4ge1xyXG4gICAgICAgIGlmIChcclxuICAgICAgICAgICAgZXZlbnQua2V5ID09PSAnICcgfHxcclxuICAgICAgICAgICAgZXZlbnQua2V5ID09PSAnRW50ZXInIHx8XHJcbiAgICAgICAgICAgIGV2ZW50LmtleSA9PT0gJ0Fycm93RG93bicgfHxcclxuICAgICAgICAgICAgZXZlbnQua2V5ID09PSAnQXJyb3dVcCdcclxuICAgICAgICApIHtcclxuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XHJcblxyXG4gICAgICAgICAgICBzZXRBY3RpdmF0ZWQodHJ1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSwgW10pO1xyXG5cclxuICAgIGNvbnN0IGhhc1ZhbHVlID0gaXNBcnJheSh2YWx1ZSkgPyB2YWx1ZS5sZW5ndGggPiAwIDogQm9vbGVhbih2YWx1ZSk7XHJcbiAgICBjb25zdCBmb2N1c2VkT3JIYXNWYWx1ZSA9IGZvY3VzZWQgfHwgaGFzVmFsdWU7XHJcbiAgICBjb25zdCBpc0ludmFsaWQgPSB0b3VjaGVkICYmIHJlcXVpcmVkICYmICFoYXNWYWx1ZTtcclxuXHJcbiAgICBjb25zdCBjbGFzc05hbWVzID0gY2xhc3NuYW1lcyhjc3NDbGFzc2VzLlJPT1QsIHtcclxuICAgICAgICBbY3NzQ2xhc3Nlcy5GSUxMRURdOiBmaWxsZWQsXHJcbiAgICAgICAgW2Nzc0NsYXNzZXMuT1VUTElORURdOiBvdXRsaW5lZCxcclxuICAgICAgICBbY3NzQ2xhc3Nlcy5BQ1RJVkFURURdOiBhY3RpdmF0ZWQsXHJcbiAgICAgICAgW2Nzc0NsYXNzZXMuRElTQUJMRURdOiBkaXNhYmxlZCxcclxuICAgICAgICBbY3NzQ2xhc3Nlcy5GT0NVU0VEXTogZm9jdXNlZCxcclxuICAgICAgICBbY3NzQ2xhc3Nlcy5SRVFVSVJFRF06IHJlcXVpcmVkLFxyXG4gICAgICAgIFtjc3NDbGFzc2VzLklOVkFMSURdOiBpc0ludmFsaWQsXHJcbiAgICAgICAgW2Nzc0NsYXNzZXMuTk9fTEFCRUxdOiAhbGFiZWwsXHJcbiAgICAgICAgW2Nzc0NsYXNzZXMuV0lUSF9MRUFESU5HX0lDT05dOiBsZWFkaW5nSWNvblxyXG4gICAgfSwgY2xhc3NOYW1lKTtcclxuXHJcbiAgICByZXR1cm4gKDw+XHJcbiAgICAgICAgPGRpdiByZWY9e3JlZn0gY2xhc3NOYW1lPXtjbGFzc05hbWVzfT5cclxuICAgICAgICAgICAge25hbWUgJiZcclxuICAgICAgICAgICAgICAgIDxpbnB1dFxyXG4gICAgICAgICAgICAgICAgICAgIHJlZj17aW5wdXRSZWZ9XHJcbiAgICAgICAgICAgICAgICAgICAgdHlwZT1cImhpZGRlblwiXHJcbiAgICAgICAgICAgICAgICAgICAgbmFtZT17bmFtZX1cclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZT17dmFsdWV9XHJcbiAgICAgICAgICAgICAgICAgICAgcmVxdWlyZWQ9e3JlcXVpcmVkfVxyXG4gICAgICAgICAgICAgICAgICAgIGRpc2FibGVkPXtkaXNhYmxlZH1cclxuICAgICAgICAgICAgICAgICAgICB7Li4ucHJvcHN9XHJcbiAgICAgICAgICAgICAgICAvPlxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICA8ZGl2XHJcbiAgICAgICAgICAgICAgICByZWY9e2FuY2hvclJlZn1cclxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZT17Y3NzQ2xhc3Nlcy5BTkNIT1J9XHJcbiAgICAgICAgICAgICAgICBhcmlhLXJlcXVpcmVkPXtyZXF1aXJlZCB8fCB1bmRlZmluZWR9XHJcbiAgICAgICAgICAgICAgICB0YWJJbmRleD17IWRpc2FibGVkID8gMCA6IHVuZGVmaW5lZH1cclxuICAgICAgICAgICAgICAgIG9uS2V5RG93bj17aGFuZGxlS2V5RG93bn1cclxuICAgICAgICAgICAgICAgIG9uQ2xpY2s9e2hhbmRsZUFuY2hvckNsaWNrfVxyXG4gICAgICAgICAgICA+XHJcbiAgICAgICAgICAgICAgICB7ZmlsbGVkICYmXHJcbiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9e2Nzc0NsYXNzZXMuUklQUExFfSAvPlxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHtmaWxsZWQgJiYgbGFiZWwgJiZcclxuICAgICAgICAgICAgICAgICAgICA8RmxvYXRpbmdMYWJlbFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBsYWJlbD17bGFiZWx9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZsb2F0PXtmb2N1c2VkT3JIYXNWYWx1ZX1cclxuICAgICAgICAgICAgICAgICAgICAvPlxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHtvdXRsaW5lZCAmJlxyXG4gICAgICAgICAgICAgICAgICAgIDxOb3RjaGVkT3V0bGluZSBub3RjaGVkPXtmb2N1c2VkT3JIYXNWYWx1ZX0+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHtsYWJlbCAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPEZsb2F0aW5nTGFiZWxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYWJlbD17bGFiZWx9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmxvYXQ9e2ZvY3VzZWRPckhhc1ZhbHVlfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLz5cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIDwvTm90Y2hlZE91dGxpbmU+XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAge2xlYWRpbmdJY29uICYmXHJcbiAgICAgICAgICAgICAgICAgICAgPENsb25lXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudD17bGVhZGluZ0ljb259XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZhbGxiYWNrPXtJY29ufVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU9e2Nzc0NsYXNzZXMuSUNPTn1cclxuICAgICAgICAgICAgICAgICAgICAgICAgdGFiSW5kZXg9XCIwXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgcm9sZT1cImJ1dHRvblwiXHJcbiAgICAgICAgICAgICAgICAgICAgLz5cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9e2Nzc0NsYXNzZXMuU0VMRUNURURfVEVYVF9DT05UQUlORVJ9PlxyXG4gICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT17Y3NzQ2xhc3Nlcy5TRUxFQ1RFRF9URVhUfT57c2VsZWN0ZWRUZXh0fTwvc3Bhbj5cclxuICAgICAgICAgICAgICAgIDwvc3Bhbj5cclxuXHJcbiAgICAgICAgICAgICAgICA8RHJvcGRvd25JY29uIC8+XHJcblxyXG4gICAgICAgICAgICAgICAge2ZpbGxlZCAmJlxyXG4gICAgICAgICAgICAgICAgICAgIDxMaW5lUmlwcGxlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjdGl2ZT17Zm9jdXNlZH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtT3JpZ2luPXtpbnRlcmFjdGlvbkNvb3Jkcz8ueH1cclxuICAgICAgICAgICAgICAgICAgICAvPlxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICA8L2Rpdj5cclxuXHJcbiAgICAgICAgICAgIDxNZW51XHJcbiAgICAgICAgICAgICAgICByZWY9e21lbnVSZWZ9XHJcbiAgICAgICAgICAgICAgICBhbmNob3JSZWY9e2FuY2hvclJlZn1cclxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZT17Y3NzQ2xhc3Nlcy5NRU5VfVxyXG4gICAgICAgICAgICAgICAgb3Blbj17YWN0aXZhdGVkfVxyXG4gICAgICAgICAgICAgICAgYW5jaG9yT3JpZ2luPXtNZW51T3JpZ2luLkJPVFRPTV9DRU5URVJ9XHJcbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm1PcmlnaW49e01lbnVPcmlnaW4uVE9QX0NFTlRFUn1cclxuICAgICAgICAgICAgICAgIGZ1bGxXaWR0aFxyXG4gICAgICAgICAgICAgICAgbGlzdFByb3BzPXtsaXN0UHJvcHN9XHJcbiAgICAgICAgICAgICAgICBvbkNsb3NlPXtoYW5kbGVNZW51Q2xvc2V9XHJcbiAgICAgICAgICAgICAgICB7Li4ubWVudVByb3BzfVxyXG4gICAgICAgICAgICA+XHJcbiAgICAgICAgICAgICAgICB7Q2hpbGRyZW4ubWFwKGNoaWxkcmVuLCBvcHRpb24gPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG9wdGlvblZhbHVlID0gb3B0aW9uLnByb3BzLnZhbHVlO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2xvbmUob3B0aW9uLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiB1bmRlZmluZWQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICdkYXRhLXZhbHVlJzogb3B0aW9uVmFsdWUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdGVkOiAhaXNVbmRlZmluZWQodmFsdWUpICYmIChtdWx0aXBsZSA/IHZhbHVlLmluY2x1ZGVzKG9wdGlvblZhbHVlKSA6IG9wdGlvblZhbHVlID09PSB2YWx1ZSksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoZWNrYm94OiBtdWx0aXBsZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgb25DbGljazogaGFuZGxlT3B0aW9uSW50ZXJhY3Rpb24sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uS2V5RG93bjogaGFuZGxlT3B0aW9uSW50ZXJhY3Rpb25cclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH0pfVxyXG4gICAgICAgICAgICA8L01lbnU+XHJcbiAgICAgICAgPC9kaXY+XHJcblxyXG4gICAgICAgIHtoZWxwZXJUZXh0ICYmXHJcbiAgICAgICAgICAgIDxIZWxwZXJUZXh0IHsuLi5oZWxwZXJUZXh0UHJvcHN9PntoZWxwZXJUZXh0fTwvSGVscGVyVGV4dD5cclxuICAgICAgICB9XHJcbiAgICA8Lz4pO1xyXG59KTtcclxuXHJcblNlbGVjdC5kaXNwbGF5TmFtZSA9ICdNRENTZWxlY3QnO1xyXG5cclxuU2VsZWN0LnByb3BUeXBlcyA9IHtcclxuICAgIHZhbHVlOiBQcm9wVHlwZXMuYW55LFxyXG4gICAgb3B0aW9uczogUHJvcFR5cGVzLmFycmF5T2YoUHJvcFR5cGVzLm9iamVjdCksXHJcbiAgICBsYWJlbDogUHJvcFR5cGVzLnN0cmluZyxcclxuICAgIGxlYWRpbmdJY29uOiBQcm9wVHlwZXMuZWxlbWVudCxcclxuICAgIGhlbHBlclRleHQ6IFByb3BUeXBlcy5zdHJpbmcsXHJcbiAgICBmaWxsZWQ6IFByb3BUeXBlcy5ib29sLFxyXG4gICAgb3V0bGluZWQ6IFByb3BUeXBlcy5ib29sLFxyXG4gICAgbXVsdGlwbGU6IFByb3BUeXBlcy5ib29sLFxyXG4gICAgZGlzYWJsZWQ6IFByb3BUeXBlcy5ib29sLFxyXG4gICAgcmVxdWlyZWQ6IFByb3BUeXBlcy5ib29sLFxyXG4gICAgY2hpbGRyZW46IFByb3BUeXBlcy5vbmVPZlR5cGUoW1xyXG4gICAgICAgIFByb3BUeXBlcy5lbGVtZW50LFxyXG4gICAgICAgIFByb3BUeXBlcy5hcnJheU9mKFByb3BUeXBlcy5lbGVtZW50KVxyXG4gICAgXSksXHJcbiAgICBtZW51UHJvcHM6IFByb3BUeXBlcy5vYmplY3QsXHJcbiAgICBoZWxwZXJUZXh0UHJvcHM6IFByb3BUeXBlcy5vYmplY3QsXHJcbiAgICBvbkNoYW5nZTogUHJvcFR5cGVzLmZ1bmNcclxufTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IFNlbGVjdDsiLCJpbXBvcnQgU2VsZWN0IGZyb20gJy4vU2VsZWN0JztcclxuaW1wb3J0IFNlbGVjdE9wdGlvbiBmcm9tICcuL1NlbGVjdE9wdGlvbic7XHJcblxyXG5TZWxlY3QuT3B0aW9uID0gU2VsZWN0T3B0aW9uO1xyXG5cclxuZXhwb3J0IHtcclxuICAgIFNlbGVjdCBhcyBkZWZhdWx0LFxyXG4gICAgU2VsZWN0T3B0aW9uXHJcbn07IiwiaW1wb3J0IHsgZm9yd2FyZFJlZiB9IGZyb20gJ3JlYWN0JztcclxuaW1wb3J0IGNsYXNzbmFtZXMgZnJvbSAnY2xhc3NuYW1lcyc7XHJcblxyXG5pbXBvcnQgSWNvbkJ1dHRvbiBmcm9tICcuLi9pY29uLWJ1dHRvbic7XHJcbmltcG9ydCBTZWxlY3QgZnJvbSAnLi4vc2VsZWN0JztcclxuXHJcbmltcG9ydCB7IGNzc0NsYXNzZXMgfSBmcm9tICcuL2NvbnN0YW50cyc7XHJcblxyXG5jb25zdCBEYXRhVGFibGVQYWdpbmF0aW9uID0gZm9yd2FyZFJlZigoe1xyXG4gICAgdG90YWxDb3VudCxcclxuICAgIGN1cnJlbnRQYWdlID0gMSxcclxuICAgIHJvd3NQZXJQYWdlID0gMTAsXHJcbiAgICBvbkZpcnN0UGFnZSA9IEZ1bmN0aW9uLnByb3RvdHlwZSxcclxuICAgIG9uUHJldlBhZ2UgPSBGdW5jdGlvbi5wcm90b3R5cGUsXHJcbiAgICBvbk5leHRQYWdlID0gRnVuY3Rpb24ucHJvdG90eXBlLFxyXG4gICAgb25MYXN0UGFnZSA9IEZ1bmN0aW9uLnByb3RvdHlwZSxcclxuXHJcbiAgICBjbGFzc05hbWUsXHJcbiAgICAuLi5wcm9wc1xyXG59LCByZWYpID0+IHtcclxuICAgIGNvbnN0IGNsYXNzTmFtZXMgPSBjbGFzc25hbWVzKGNzc0NsYXNzZXMuUEFHSU5BVElPTiwgY2xhc3NOYW1lKTtcclxuXHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAgIDxkaXYgcmVmPXtyZWZ9IGNsYXNzTmFtZT17Y2xhc3NOYW1lc30gey4uLnByb3BzfT5cclxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9e2Nzc0NsYXNzZXMuUEFHSU5BVElPTl9UUkFJTElOR30+XHJcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17Y3NzQ2xhc3Nlcy5QQUdJTkFUSU9OX1JPV1NfUEVSX1BBR0V9PlxyXG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXtjc3NDbGFzc2VzLlBBR0lOQVRJT05fUk9XU19QRVJfUEFHRV9MQUJFTH0+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgINCg0Y/QtNC+0LIg0L3QsCDRgdGC0YAuXHJcbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIDxTZWxlY3RcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPXtjc3NDbGFzc2VzLlBBR0lOQVRJT05fUk9XU19QRVJfUEFHRV9TRUxFQ1R9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnM9e1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgWzEwLCAyNSwgNTAsIDEwMF0ubWFwKHZhbHVlID0+ICh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5OiB2YWx1ZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0OiB2YWx1ZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL3NlbGVjdGVkOiB2YWx1ZSA9PT0gcm93c1BlclBhZ2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgLz5cclxuICAgICAgICAgICAgICAgIDwvZGl2PlxyXG5cclxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXtjc3NDbGFzc2VzLlBBR0lOQVRJT05fTkFWSUdBVElPTn0+XHJcbiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9e2Nzc0NsYXNzZXMuUEFHSU5BVElPTl9UT1RBTH0+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHtjdXJyZW50UGFnZX3igJF7cm93c1BlclBhZ2V9INC40Lcge3RvdGFsQ291bnR9XHJcbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIDxJY29uQnV0dG9uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT17Y3NzQ2xhc3Nlcy5QQUdJTkFUSU9OX0JVVFRPTn1cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWNvbj1cImZpcnN0X3BhZ2VcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBvbkNsaWNrPXtvbkZpcnN0UGFnZX1cclxuICAgICAgICAgICAgICAgICAgICAvPlxyXG5cclxuICAgICAgICAgICAgICAgICAgICA8SWNvbkJ1dHRvblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU9e2Nzc0NsYXNzZXMuUEFHSU5BVElPTl9CVVRUT059XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGljb249XCJjaGV2cm9uX2xlZnRcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBvbkNsaWNrPXtvblByZXZQYWdlfVxyXG4gICAgICAgICAgICAgICAgICAgIC8+XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIDxJY29uQnV0dG9uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT17Y3NzQ2xhc3Nlcy5QQUdJTkFUSU9OX0JVVFRPTn1cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWNvbj1cImNoZXZyb25fcmlnaHRcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBvbkNsaWNrPXtvbk5leHRQYWdlfVxyXG4gICAgICAgICAgICAgICAgICAgIC8+XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIDxJY29uQnV0dG9uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT17Y3NzQ2xhc3Nlcy5QQUdJTkFUSU9OX0JVVFRPTn1cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWNvbj1cImxhc3RfcGFnZVwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2xpY2s9e29uTGFzdFBhZ2V9XHJcbiAgICAgICAgICAgICAgICAgICAgLz5cclxuICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICA8L2Rpdj5cclxuICAgICk7XHJcbn0pO1xyXG5cclxuRGF0YVRhYmxlUGFnaW5hdGlvbi5kaXNwbGF5TmFtZSA9ICdNRENEYXRhVGFibGVQYWdpbmF0aW9uJztcclxuXHJcbmV4cG9ydCBkZWZhdWx0IERhdGFUYWJsZVBhZ2luYXRpb247IiwiaW1wb3J0IHsgZm9yd2FyZFJlZiB9IGZyb20gJ3JlYWN0JztcclxuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcclxuaW1wb3J0IGNsYXNzbmFtZXMgZnJvbSAnY2xhc3NuYW1lcyc7XHJcblxyXG5pbXBvcnQgRGF0YVRhYmxlUHJvZ3Jlc3NJbmRpY2F0b3IgZnJvbSAnLi9EYXRhVGFibGVQcm9ncmVzc0luZGljYXRvcic7XHJcbmltcG9ydCBEYXRhVGFibGVQYWdpbmF0aW9uIGZyb20gJy4vRGF0YVRhYmxlUGFnaW5hdGlvbic7XHJcbmltcG9ydCB7IGNzc0NsYXNzZXMgfSBmcm9tICcuL2NvbnN0YW50cyc7XHJcblxyXG5jb25zdCBEYXRhVGFibGUgPSBmb3J3YXJkUmVmKCh7XHJcbiAgICBzdGlja3lIZWFkZXIgPSBmYWxzZSxcclxuICAgIGluUHJvZ3Jlc3MgPSBmYWxzZSxcclxuICAgIHBhZ2luYXRpb24sXHJcblxyXG4gICAgY2xhc3NOYW1lLFxyXG4gICAgY2hpbGRyZW4sXHJcbiAgICAuLi5wcm9wc1xyXG59LCByZWYpID0+IHtcclxuICAgIGNvbnN0IGNsYXNzTmFtZXMgPSBjbGFzc25hbWVzKGNzc0NsYXNzZXMuUk9PVCwge1xyXG4gICAgICAgIFtjc3NDbGFzc2VzLlNUSUNLWV9IRUFERVJdOiBzdGlja3lIZWFkZXIsXHJcbiAgICAgICAgW2Nzc0NsYXNzZXMuSU5fUFJPR1JFU1NdOiBpblByb2dyZXNzXHJcbiAgICB9LCBjbGFzc05hbWUpO1xyXG5cclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgPGRpdiByZWY9e3JlZn0gY2xhc3NOYW1lPXtjbGFzc05hbWVzfSB7Li4ucHJvcHN9PlxyXG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17Y3NzQ2xhc3Nlcy5UQUJMRV9DT05UQUlORVJ9PlxyXG4gICAgICAgICAgICAgICAgPHRhYmxlIGNsYXNzTmFtZT17Y3NzQ2xhc3Nlcy5UQUJMRX0+XHJcbiAgICAgICAgICAgICAgICAgICAge2NoaWxkcmVufVxyXG4gICAgICAgICAgICAgICAgPC90YWJsZT5cclxuICAgICAgICAgICAgPC9kaXY+XHJcblxyXG4gICAgICAgICAgICB7aW5Qcm9ncmVzcyAmJlxyXG4gICAgICAgICAgICAgICAgPERhdGFUYWJsZVByb2dyZXNzSW5kaWNhdG9yIC8+XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHtwYWdpbmF0aW9uICYmXHJcbiAgICAgICAgICAgICAgICA8RGF0YVRhYmxlUGFnaW5hdGlvbiB7Li4ucGFnaW5hdGlvbn0gLz5cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIDwvZGl2PlxyXG4gICAgKTtcclxufSk7XHJcblxyXG5EYXRhVGFibGUuZGlzcGxheU5hbWUgPSAnTURDRGF0YVRhYmxlJztcclxuXHJcbkRhdGFUYWJsZS5wcm9wVHlwZXMgPSB7XHJcbiAgICBzdGlja3lIZWFkZXI6IFByb3BUeXBlcy5ib29sLFxyXG4gICAgaW5Qcm9ncmVzczogUHJvcFR5cGVzLmJvb2xcclxufTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IERhdGFUYWJsZTsiLCJpbXBvcnQgeyBmb3J3YXJkUmVmIH0gZnJvbSAncmVhY3QnO1xyXG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xyXG5pbXBvcnQgY2xhc3NuYW1lcyBmcm9tICdjbGFzc25hbWVzJztcclxuXHJcbmltcG9ydCB7IENsb25lIH0gZnJvbSAnLi4vY29tcG9uZW50JztcclxuXHJcbmltcG9ydCB7IGNzc0NsYXNzZXMgfSBmcm9tICcuL2NvbnN0YW50cyc7XHJcblxyXG5jb25zdCBEYXRhVGFibGVDZWxsID0gZm9yd2FyZFJlZigoe1xyXG4gICAgY2hlY2tib3ggPSBmYWxzZSxcclxuICAgIG51bWVyaWMgPSBmYWxzZSxcclxuXHJcbiAgICBlbGVtZW50OiBFbGVtZW50ID0gJ3RkJyxcclxuICAgIHNjb3BlLFxyXG4gICAgY2xhc3NOYW1lLFxyXG4gICAgY2hpbGRyZW4sXHJcbiAgICAuLi5wcm9wc1xyXG59LCByZWYpID0+IHtcclxuICAgIGNvbnN0IGNsYXNzTmFtZXMgPSBjbGFzc25hbWVzKGNzc0NsYXNzZXMuQ0VMTCwge1xyXG4gICAgICAgIFtjc3NDbGFzc2VzLkNFTExfQ0hFQ0tCT1hdOiBjaGVja2JveCxcclxuICAgICAgICBbY3NzQ2xhc3Nlcy5DRUxMX05VTUVSSUNdOiBudW1lcmljXHJcbiAgICB9LCBjbGFzc05hbWUpO1xyXG5cclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgPEVsZW1lbnQgcmVmPXtyZWZ9IGNsYXNzTmFtZT17Y2xhc3NOYW1lc30gc2NvcGU9e3Njb3BlfSB7Li4ucHJvcHN9PlxyXG4gICAgICAgICAgICB7Y2hlY2tib3ggP1xyXG4gICAgICAgICAgICAgICAgPENsb25lXHJcbiAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50PXtjaGlsZHJlbn1cclxuICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU9e2Nzc0NsYXNzZXMuUk9XX0NIRUNLQk9YfVxyXG4gICAgICAgICAgICAgICAgLz5cclxuICAgICAgICAgICAgICAgIDpcclxuICAgICAgICAgICAgICAgIGNoaWxkcmVuXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICA8L0VsZW1lbnQ+XHJcbiAgICApO1xyXG59KTtcclxuXHJcbkRhdGFUYWJsZUNlbGwuZGlzcGxheU5hbWUgPSAnTURDRGF0YVRhYmxlQ2VsbCc7XHJcblxyXG5EYXRhVGFibGVDZWxsLnByb3BUeXBlcyA9IHtcclxuICAgIGNoZWNrYm94OiBQcm9wVHlwZXMuYm9vbCxcclxuICAgIG51bWVyaWM6IFByb3BUeXBlcy5ib29sXHJcbn07XHJcblxyXG5leHBvcnQgZGVmYXVsdCBEYXRhVGFibGVDZWxsOyIsImltcG9ydCB7IGZvcndhcmRSZWYgfSBmcm9tICdyZWFjdCc7XHJcbmltcG9ydCBjbGFzc25hbWVzIGZyb20gJ2NsYXNzbmFtZXMnO1xyXG5cclxuaW1wb3J0IHsgY3NzQ2xhc3NlcyB9IGZyb20gJy4vY29uc3RhbnRzJztcclxuXHJcbmNvbnN0IERhdGFUYWJsZUNvbnRlbnQgPSBmb3J3YXJkUmVmKCh7IGNsYXNzTmFtZSwgLi4ucHJvcHMgfSwgcmVmKSA9PiB7XHJcbiAgICBjb25zdCBjbGFzc05hbWVzID0gY2xhc3NuYW1lcyhjc3NDbGFzc2VzLkNPTlRFTlQsIGNsYXNzTmFtZSk7XHJcblxyXG4gICAgcmV0dXJuIChcclxuICAgICAgICA8dGJvZHkgcmVmPXtyZWZ9IGNsYXNzTmFtZT17Y2xhc3NOYW1lc30gey4uLnByb3BzfSAvPlxyXG4gICAgKTtcclxufSk7XHJcblxyXG5EYXRhVGFibGVDb250ZW50LmRpc3BsYXlOYW1lID0gJ01EQ0RhdGFUYWJsZUNvbnRlbnQnO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgRGF0YVRhYmxlQ29udGVudDsiLCJpbXBvcnQgeyBmb3J3YXJkUmVmIH0gZnJvbSAncmVhY3QnO1xyXG5pbXBvcnQgY2xhc3NuYW1lcyBmcm9tICdjbGFzc25hbWVzJztcclxuXHJcbmltcG9ydCB7IGNzc0NsYXNzZXMgfSBmcm9tICcuL2NvbnN0YW50cyc7XHJcblxyXG5jb25zdCBEYXRhVGFibGVGb290ZXIgPSBmb3J3YXJkUmVmKCh7IGNsYXNzTmFtZSwgLi4ucHJvcHMgfSwgcmVmKSA9PiB7XHJcbiAgICBjb25zdCBjbGFzc05hbWVzID0gY2xhc3NuYW1lcyhjc3NDbGFzc2VzLkZPT1RFUiwgY2xhc3NOYW1lKTtcclxuXHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAgIDx0Zm9vdCByZWY9e3JlZn0gY2xhc3NOYW1lPXtjbGFzc05hbWVzfSB7Li4ucHJvcHN9IC8+XHJcbiAgICApO1xyXG59KTtcclxuXHJcbkRhdGFUYWJsZUZvb3Rlci5kaXNwbGF5TmFtZSA9ICdNRENEYXRhVGFibGVGb290ZXInO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgRGF0YVRhYmxlRm9vdGVyOyIsImltcG9ydCB7IGZvcndhcmRSZWYgfSBmcm9tICdyZWFjdCc7XHJcbmltcG9ydCBjbGFzc25hbWVzIGZyb20gJ2NsYXNzbmFtZXMnO1xyXG5cclxuaW1wb3J0IHsgY3NzQ2xhc3NlcyB9IGZyb20gJy4vY29uc3RhbnRzJztcclxuXHJcbmNvbnN0IERhdGFUYWJsZUhlYWRlciA9IGZvcndhcmRSZWYoKHsgY2xhc3NOYW1lLCAuLi5wcm9wcyB9LCByZWYpID0+IHtcclxuICAgIGNvbnN0IGNsYXNzTmFtZXMgPSBjbGFzc25hbWVzKGNzc0NsYXNzZXMuSEVBREVSLCBjbGFzc05hbWUpO1xyXG5cclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgPHRoZWFkIHJlZj17cmVmfSBjbGFzc05hbWU9e2NsYXNzTmFtZXN9IHsuLi5wcm9wc30gLz5cclxuICAgICk7XHJcbn0pO1xyXG5cclxuRGF0YVRhYmxlSGVhZGVyLmRpc3BsYXlOYW1lID0gJ01EQ0RhdGFUYWJsZUhlYWRlcic7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBEYXRhVGFibGVIZWFkZXI7IiwiaW1wb3J0IHsgZm9yd2FyZFJlZiwgdXNlQ2FsbGJhY2sgfSBmcm9tICdyZWFjdCc7XHJcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XHJcbmltcG9ydCBjbGFzc25hbWVzIGZyb20gJ2NsYXNzbmFtZXMnO1xyXG5cclxuaW1wb3J0IHsgQ2xvbmUgfSBmcm9tICcuLi9jb21wb25lbnQnO1xyXG5pbXBvcnQgSWNvbkJ1dHRvbiBmcm9tICcuLi9pY29uLWJ1dHRvbic7XHJcblxyXG5pbXBvcnQgeyBjc3NDbGFzc2VzIH0gZnJvbSAnLi9jb25zdGFudHMnO1xyXG5cclxuY29uc3QgRGF0YVRhYmxlSGVhZGVyQ2VsbCA9IGZvcndhcmRSZWYoKHtcclxuICAgIHZhbHVlLFxyXG4gICAgbGFiZWwsXHJcbiAgICBjaGVja2JveCA9IGZhbHNlLFxyXG4gICAgbnVtZXJpYyA9IGZhbHNlLFxyXG4gICAgc29ydCxcclxuICAgIHNvcnRJY29uQnV0dG9uID0gJ2Fycm93X3Vwd2FyZCcsXHJcbiAgICBvblNvcnQgPSBGdW5jdGlvbi5wcm90b3R5cGUsXHJcblxyXG4gICAgZWxlbWVudDogRWxlbWVudCA9ICd0aCcsXHJcbiAgICByb2xlID0gJ2NvbHVtbmhlYWRlcicsXHJcbiAgICBzY29wZSA9ICdjb2wnLFxyXG4gICAgY2xhc3NOYW1lLFxyXG4gICAgY2hpbGRyZW4gPSBsYWJlbCxcclxuICAgIC4uLnByb3BzXHJcbn0sIHJlZikgPT4ge1xyXG4gICAgY29uc3QgaGFuZGxlU29ydEljb25DbGljayA9IHVzZUNhbGxiYWNrKCgpID0+IHtcclxuICAgICAgICBvblNvcnQoeyBsYWJlbCwgdmFsdWUgfSk7XHJcbiAgICB9LCBbbGFiZWwsIHZhbHVlLCBvblNvcnRdKTtcclxuXHJcbiAgICBjb25zdCB3aXRoU29ydCA9IHR5cGVvZiBzb3J0ID09PSAnbnVtYmVyJztcclxuXHJcbiAgICBjb25zdCBjbGFzc05hbWVzID0gY2xhc3NuYW1lcyhjc3NDbGFzc2VzLkhFQURFUl9DRUxMLCB7XHJcbiAgICAgICAgW2Nzc0NsYXNzZXMuSEVBREVSX0NFTExfQ0hFQ0tCT1hdOiBjaGVja2JveCxcclxuICAgICAgICBbY3NzQ2xhc3Nlcy5IRUFERVJfQ0VMTF9OVU1FUklDXTogbnVtZXJpYyxcclxuICAgICAgICBbY3NzQ2xhc3Nlcy5IRUFERVJfQ0VMTF9XSVRIX1NPUlRdOiB3aXRoU29ydCxcclxuICAgICAgICBbY3NzQ2xhc3Nlcy5IRUFERVJfQ0VMTF9TT1JURURdOiBzb3J0ID09PSAxIHx8IHNvcnQgPT09IC0xLFxyXG4gICAgICAgIFtjc3NDbGFzc2VzLkhFQURFUl9DRUxMX1NPUlRFRF9ERVNDXTogc29ydCA9PT0gLTFcclxuICAgIH0sIGNsYXNzTmFtZSk7XHJcblxyXG4gICAgcmV0dXJuIChcclxuICAgICAgICA8RWxlbWVudFxyXG4gICAgICAgICAgICByZWY9e3JlZn1cclxuICAgICAgICAgICAgY2xhc3NOYW1lPXtjbGFzc05hbWVzfVxyXG4gICAgICAgICAgICByb2xlPXtyb2xlfVxyXG4gICAgICAgICAgICBzY29wZT17c2NvcGV9XHJcbiAgICAgICAgICAgIHsuLi5wcm9wc31cclxuICAgICAgICA+XHJcbiAgICAgICAgICAgIHt3aXRoU29ydCA/XHJcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17Y3NzQ2xhc3Nlcy5IRUFERVJfQ0VMTF9XUkFQUEVSfT5cclxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17Y3NzQ2xhc3Nlcy5IRUFERVJfQ0VMTF9MQUJFTH0+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHtjaGlsZHJlbn1cclxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgPENsb25lXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudD17c29ydEljb25CdXR0b259XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZhbGxiYWNrPXtJY29uQnV0dG9ufVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU9e2Nzc0NsYXNzZXMuU09SVF9JQ09OX0JVVFRPTn1cclxuICAgICAgICAgICAgICAgICAgICAgICAgb25DbGljaz17aGFuZGxlU29ydEljb25DbGlja31cclxuICAgICAgICAgICAgICAgICAgICAvPlxyXG5cclxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17Y3NzQ2xhc3Nlcy5TT1JUX1NUQVRVU19MQUJFTH0gYXJpYS1oaWRkZW49XCJ0cnVlXCIgLz5cclxuICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICAgICAgOlxyXG4gICAgICAgICAgICAgICAgKGNoZWNrYm94ID9cclxuICAgICAgICAgICAgICAgICAgICA8Q2xvbmVcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50PXtjaGlsZHJlbn1cclxuICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPXtjc3NDbGFzc2VzLkhFQURFUl9ST1dfQ0hFQ0tCT1h9XHJcbiAgICAgICAgICAgICAgICAgICAgLz5cclxuICAgICAgICAgICAgICAgICAgICA6XHJcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW5cclxuICAgICAgICAgICAgICAgIClcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIDwvRWxlbWVudD5cclxuICAgICk7XHJcbn0pO1xyXG5cclxuRGF0YVRhYmxlSGVhZGVyQ2VsbC5kaXNwbGF5TmFtZSA9ICdNRENEYXRhVGFibGVIZWFkZXJDZWxsJztcclxuXHJcbkRhdGFUYWJsZUhlYWRlckNlbGwucHJvcFR5cGVzID0ge1xyXG4gICAgdmFsdWU6IFByb3BUeXBlcy5hbnksXHJcbiAgICBsYWJlbDogUHJvcFR5cGVzLnN0cmluZyxcclxuICAgIG51bWVyaWM6IFByb3BUeXBlcy5ib29sLFxyXG4gICAgY2hlY2tib3g6IFByb3BUeXBlcy5ib29sLFxyXG4gICAgc29ydDogUHJvcFR5cGVzLm9uZU9mKFstMSwgMCwgMV0pLFxyXG4gICAgc29ydEljb25CdXR0b246IFByb3BUeXBlcy5ub2RlLFxyXG4gICAgb25Tb3J0OiBQcm9wVHlwZXMuZnVuY1xyXG59O1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgRGF0YVRhYmxlSGVhZGVyQ2VsbDsiLCJpbXBvcnQgeyBmb3J3YXJkUmVmIH0gZnJvbSAncmVhY3QnO1xyXG5pbXBvcnQgY2xhc3NuYW1lcyBmcm9tICdjbGFzc25hbWVzJztcclxuXHJcbmltcG9ydCB7IGNzc0NsYXNzZXMgfSBmcm9tICcuL2NvbnN0YW50cyc7XHJcblxyXG5jb25zdCBEYXRhVGFibGVIZWFkZXJSb3cgPSBmb3J3YXJkUmVmKCh7IGNsYXNzTmFtZSwgLi4ucHJvcHMgfSwgcmVmKSA9PiB7XHJcbiAgICBjb25zdCBjbGFzc05hbWVzID0gY2xhc3NuYW1lcyhjc3NDbGFzc2VzLkhFQURFUl9ST1csIGNsYXNzTmFtZSk7XHJcblxyXG4gICAgcmV0dXJuIChcclxuICAgICAgICA8dHIgcmVmPXtyZWZ9IGNsYXNzTmFtZT17Y2xhc3NOYW1lc30gey4uLnByb3BzfSAvPlxyXG4gICAgKTtcclxufSk7XHJcblxyXG5EYXRhVGFibGVIZWFkZXJSb3cuZGlzcGxheU5hbWUgPSAnTURDRGF0YVRhYmxlSGVhZGVyUm93JztcclxuXHJcbmV4cG9ydCBkZWZhdWx0IERhdGFUYWJsZUhlYWRlclJvdzsiLCJpbXBvcnQgeyBmb3J3YXJkUmVmIH0gZnJvbSAncmVhY3QnO1xyXG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xyXG5pbXBvcnQgY2xhc3NuYW1lcyBmcm9tICdjbGFzc25hbWVzJztcclxuXHJcbmltcG9ydCB7IGNzc0NsYXNzZXMgfSBmcm9tICcuL2NvbnN0YW50cyc7XHJcblxyXG5jb25zdCBEYXRhVGFibGVSb3cgPSBmb3J3YXJkUmVmKCh7XHJcbiAgICBzZWxlY3RlZCA9IGZhbHNlLFxyXG5cclxuICAgIGNsYXNzTmFtZSxcclxuICAgIC4uLnByb3BzXHJcbn0sIHJlZikgPT4ge1xyXG4gICAgY29uc3QgY2xhc3NOYW1lcyA9IGNsYXNzbmFtZXMoY3NzQ2xhc3Nlcy5ST1csIHtcclxuICAgICAgICBbY3NzQ2xhc3Nlcy5ST1dfU0VMRUNURURdOiBzZWxlY3RlZFxyXG4gICAgfSwgY2xhc3NOYW1lKTtcclxuXHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAgIDx0ciByZWY9e3JlZn0gY2xhc3NOYW1lPXtjbGFzc05hbWVzfSB7Li4ucHJvcHN9IC8+XHJcbiAgICApO1xyXG59KTtcclxuXHJcbkRhdGFUYWJsZVJvdy5kaXNwbGF5TmFtZSA9ICdNRENEYXRhVGFibGVSb3cnO1xyXG5cclxuRGF0YVRhYmxlUm93LnByb3BUeXBlcyA9IHtcclxuICAgIHNlbGVjdGVkOiBQcm9wVHlwZXMuYm9vbFxyXG59O1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgRGF0YVRhYmxlUm93OyIsImltcG9ydCBEYXRhVGFibGUgZnJvbSAnLi9EYXRhVGFibGUnO1xyXG5pbXBvcnQgRGF0YVRhYmxlQ2VsbCBmcm9tICcuL0RhdGFUYWJsZUNlbGwnO1xyXG5pbXBvcnQgRGF0YVRhYmxlQ29udGVudCBmcm9tICcuL0RhdGFUYWJsZUNvbnRlbnQnO1xyXG5pbXBvcnQgRGF0YVRhYmxlRm9vdGVyIGZyb20gJy4vRGF0YVRhYmxlRm9vdGVyJztcclxuaW1wb3J0IERhdGFUYWJsZUhlYWRlciBmcm9tICcuL0RhdGFUYWJsZUhlYWRlcic7XHJcbmltcG9ydCBEYXRhVGFibGVIZWFkZXJDZWxsIGZyb20gJy4vRGF0YVRhYmxlSGVhZGVyQ2VsbCc7XHJcbmltcG9ydCBEYXRhVGFibGVIZWFkZXJSb3cgZnJvbSAnLi9EYXRhVGFibGVIZWFkZXJSb3cnO1xyXG5pbXBvcnQgRGF0YVRhYmxlUGFnaW5hdGlvbiBmcm9tICcuL0RhdGFUYWJsZVBhZ2luYXRpb24nO1xyXG5pbXBvcnQgRGF0YVRhYmxlUm93IGZyb20gJy4vRGF0YVRhYmxlUm93JztcclxuXHJcbkRhdGFUYWJsZS5DZWxsID0gRGF0YVRhYmxlQ2VsbDtcclxuRGF0YVRhYmxlLkNvbnRlbnQgPSBEYXRhVGFibGVDb250ZW50O1xyXG5EYXRhVGFibGUuRm9vdGVyID0gRGF0YVRhYmxlRm9vdGVyO1xyXG5EYXRhVGFibGUuSGVhZGVyID0gRGF0YVRhYmxlSGVhZGVyO1xyXG5EYXRhVGFibGUuSGVhZGVyQ2VsbCA9IERhdGFUYWJsZUhlYWRlckNlbGw7XHJcbkRhdGFUYWJsZS5IZWFkZXJSb3cgPSBEYXRhVGFibGVIZWFkZXJSb3c7XHJcbkRhdGFUYWJsZS5QYWdpbmF0aW9uID0gRGF0YVRhYmxlUGFnaW5hdGlvbjtcclxuRGF0YVRhYmxlLlJvdyA9IERhdGFUYWJsZVJvdztcclxuXHJcbmV4cG9ydCB7XHJcbiAgICBEYXRhVGFibGUgYXMgZGVmYXVsdCxcclxuICAgIERhdGFUYWJsZUNlbGwsXHJcbiAgICBEYXRhVGFibGVDb250ZW50LFxyXG4gICAgRGF0YVRhYmxlRm9vdGVyLFxyXG4gICAgRGF0YVRhYmxlSGVhZGVyLFxyXG4gICAgRGF0YVRhYmxlSGVhZGVyQ2VsbCxcclxuICAgIERhdGFUYWJsZUhlYWRlclJvdyxcclxuICAgIERhdGFUYWJsZVBhZ2luYXRpb24sXHJcbiAgICBEYXRhVGFibGVSb3dcclxufTsiLCJleHBvcnQgY29uc3QgbnVtYmVycyA9IHtcclxuICAgIERJQUxPR19BTklNQVRJT05fT1BFTl9USU1FX01TOiAxNTAsXHJcbiAgICBESUFMT0dfQU5JTUFUSU9OX0NMT1NFX1RJTUVfTVM6IDc1LFxyXG4gICAgREVGQVVMVF9BQ1RJT05TX0hFSUdIVDogNTJcclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCBjc3NDbGFzc2VzID0ge1xyXG4gICAgUk9PVDogJ21kYy1kaWFsb2cnLFxyXG4gICAgSEVBREVSOiAnbWRjLWRpYWxvZ19faGVhZGVyJyxcclxuICAgIFRJVExFOiAnbWRjLWRpYWxvZ19fdGl0bGUnLFxyXG4gICAgQ0xPU0U6ICdtZGMtZGlhbG9nX19jbG9zZScsXHJcbiAgICBDT05URU5UOiAnbWRjLWRpYWxvZ19fY29udGVudCcsXHJcbiAgICBDT05UQUlORVI6ICdtZGMtZGlhbG9nX19jb250YWluZXInLFxyXG4gICAgQUNUSU9OUzogJ21kYy1kaWFsb2dfX2FjdGlvbnMnLFxyXG4gICAgQlVUVE9OOiAnbWRjLWRpYWxvZ19fYnV0dG9uJyxcclxuICAgIFNVUkZBQ0U6ICdtZGMtZGlhbG9nX19zdXJmYWNlJyxcclxuICAgIFNDUklNOiAnbWRjLWRpYWxvZ19fc2NyaW0nLFxyXG5cclxuICAgIE9QRU46ICdtZGMtZGlhbG9nLS1vcGVuJyxcclxuICAgIE9QRU5JTkc6ICdtZGMtZGlhbG9nLS1vcGVuaW5nJyxcclxuICAgIENMT1NJTkc6ICdtZGMtZGlhbG9nLS1jbG9zaW5nJyxcclxuICAgIEZVTExTQ1JFRU46ICdtZGMtZGlhbG9nLS1mdWxsc2NyZWVuJyxcclxuICAgIFNDUk9MTEFCTEU6ICdtZGMtZGlhbG9nLS1zY3JvbGxhYmxlJyxcclxuICAgIFNUQUNLRUQ6ICdtZGMtZGlhbG9nLS1zdGFja2VkJyxcclxuXHJcbiAgICBTQ1JPTExfRElWSURFUl9IRUFERVI6ICdtZGMtZGlhbG9nLXNjcm9sbC1kaXZpZGVyLWhlYWRlcicsXHJcbiAgICBTQ1JPTExfRElWSURFUl9GT09URVI6ICdtZGMtZGlhbG9nLXNjcm9sbC1kaXZpZGVyLWZvb3RlcicsXHJcbiAgICBTQ1JPTExfTE9DSzogJ21kYy1kaWFsb2ctc2Nyb2xsLWxvY2snXHJcbn07IiwiaW1wb3J0IHsgZm9yd2FyZFJlZiB9IGZyb20gJ3JlYWN0JztcclxuXHJcbmltcG9ydCB7IENsb25lIH0gZnJvbSAnLi4vY29tcG9uZW50JztcclxuaW1wb3J0IEljb25CdXR0b24gZnJvbSAnLi4vaWNvbi1idXR0b24nO1xyXG5cclxuaW1wb3J0IHsgY3NzQ2xhc3NlcyB9IGZyb20gJy4vY29uc3RhbnRzJztcclxuXHJcbmNvbnN0IERpYWxvZ0hlYWRlciA9IGZvcndhcmRSZWYoKHtcclxuICAgIHRpdGxlLFxyXG4gICAgY2xvc2VJY29uLFxyXG4gICAgZnVsbHNjcmVlbixcclxuICAgIG9uQ2xvc2UsXHJcblxyXG4gICAgY2hpbGRyZW4sXHJcbiAgICAuLi5wcm9wc1xyXG59LCByZWYpID0+IHtcclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgPGRpdiByZWY9e3JlZn0gY2xhc3NOYW1lPXtjc3NDbGFzc2VzLkhFQURFUn0gey4uLnByb3BzfT5cclxuICAgICAgICAgICAgPENsb25lXHJcbiAgICAgICAgICAgICAgICBjb21wb25lbnQ9e3RpdGxlfVxyXG4gICAgICAgICAgICAgICAgZmFsbGJhY2s9XCJoMlwiXHJcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU9e2Nzc0NsYXNzZXMuVElUTEV9XHJcbiAgICAgICAgICAgIC8+XHJcblxyXG4gICAgICAgICAgICB7KGZ1bGxzY3JlZW4gfHwgY2xvc2VJY29uKSAmJlxyXG4gICAgICAgICAgICAgICAgPENsb25lXHJcbiAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50PXtjbG9zZUljb259XHJcbiAgICAgICAgICAgICAgICAgICAgZmFsbGJhY2s9ezxJY29uQnV0dG9uIGljb249XCJjbG9zZVwiIC8+fVxyXG4gICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT17Y3NzQ2xhc3Nlcy5DTE9TRX1cclxuICAgICAgICAgICAgICAgICAgICBvbkNsaWNrPXtvbkNsb3NlfVxyXG4gICAgICAgICAgICAgICAgLz5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAge2NoaWxkcmVufVxyXG4gICAgICAgIDwvZGl2PlxyXG4gICAgKTtcclxufSk7XHJcblxyXG5EaWFsb2dIZWFkZXIuZGlzcGxheU5hbWUgPSAnTURDRGlhbG9nSGVhZGVyJztcclxuXHJcbmV4cG9ydCBkZWZhdWx0IERpYWxvZ0hlYWRlcjsiLCJpbXBvcnQgeyBmb3J3YXJkUmVmIH0gZnJvbSAncmVhY3QnO1xyXG5cclxuaW1wb3J0IHsgY3NzQ2xhc3NlcyB9IGZyb20gJy4vY29uc3RhbnRzJztcclxuXHJcbmNvbnN0IERpYWxvZ0NvbnRlbnQgPSBmb3J3YXJkUmVmKChwcm9wcywgcmVmKSA9PiB7XHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAgIDxkaXYgcmVmPXtyZWZ9IGNsYXNzTmFtZT17Y3NzQ2xhc3Nlcy5DT05URU5UfSB7Li4ucHJvcHN9IC8+XHJcbiAgICApO1xyXG59KTtcclxuXHJcbkRpYWxvZ0NvbnRlbnQuZGlzcGxheU5hbWUgPSAnTURDRGlhbG9nQ29udGVudCc7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBEaWFsb2dDb250ZW50OyIsImltcG9ydCB7IGZvcndhcmRSZWYgfSBmcm9tICdyZWFjdCc7XHJcblxyXG5pbXBvcnQgeyBDbG9uZSB9IGZyb20gJy4uL2NvbXBvbmVudCc7XHJcblxyXG5pbXBvcnQgeyBjc3NDbGFzc2VzIH0gZnJvbSAnLi9jb25zdGFudHMnO1xyXG5cclxuY29uc3QgRGlhbG9nQWN0aW9ucyA9IGZvcndhcmRSZWYoKHsgY2hpbGRyZW4gfSwgcmVmKSA9PiB7XHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAgIDxkaXYgcmVmPXtyZWZ9IGNsYXNzTmFtZT17Y3NzQ2xhc3Nlcy5BQ1RJT05TfT5cclxuICAgICAgICAgICAgPENsb25lXHJcbiAgICAgICAgICAgICAgICBjb21wb25lbnQ9e2NoaWxkcmVufVxyXG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lPXtjc3NDbGFzc2VzLkJVVFRPTn1cclxuICAgICAgICAgICAgLz5cclxuICAgICAgICA8L2Rpdj5cclxuICAgICk7XHJcbn0pO1xyXG5cclxuRGlhbG9nQWN0aW9ucy5kaXNwbGF5TmFtZSA9ICdNRENEaWFsb2dBY3Rpb25zJztcclxuXHJcbmV4cG9ydCBkZWZhdWx0IERpYWxvZ0FjdGlvbnM7IiwiaW1wb3J0IHsgZm9yd2FyZFJlZiwgdXNlUmVmLCB1c2VDYWxsYmFjaywgdXNlSW1wZXJhdGl2ZUhhbmRsZSB9IGZyb20gJ3JlYWN0JztcclxuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcclxuaW1wb3J0IGNsYXNzbmFtZXMgZnJvbSAnY2xhc3NuYW1lcyc7XHJcblxyXG5pbXBvcnQgeyB1c2VVcGRhdGVkLCB1c2VVbm1vdW50ZWQgfSBmcm9tICcuLi9ob29rcyc7XHJcbmltcG9ydCBMYXllciBmcm9tICcuLi9sYXllcic7XHJcblxyXG5pbXBvcnQgeyBudW1iZXJzLCBjc3NDbGFzc2VzIH0gZnJvbSAnLi9jb25zdGFudHMnO1xyXG5pbXBvcnQgRGlhbG9nSGVhZGVyIGZyb20gJy4vRGlhbG9nSGVhZGVyJztcclxuaW1wb3J0IERpYWxvZ0NvbnRlbnQgZnJvbSAnLi9EaWFsb2dDb250ZW50JztcclxuaW1wb3J0IERpYWxvZ0FjdGlvbnMgZnJvbSAnLi9EaWFsb2dBY3Rpb25zJztcclxuXHJcbmNvbnN0IERpYWxvZyA9IGZvcndhcmRSZWYoKHtcclxuICAgIHRpdGxlLFxyXG4gICAgY29udGVudCxcclxuICAgIGFjdGlvbnMsXHJcbiAgICBjbG9zZUljb24sXHJcbiAgICBvcGVuID0gZmFsc2UsXHJcbiAgICBhcHBlYXIgPSBmYWxzZSxcclxuICAgIHBlcnNpc3RlbnQgPSBmYWxzZSxcclxuICAgIGZ1bGxzY3JlZW4gPSBmYWxzZSxcclxuICAgIHN0YWNrZWQgPSBmYWxzZSxcclxuICAgIGF1dG9TdGFja0J1dHRvbnMgPSBmYWxzZSxcclxuICAgIG9uQ2xvc2UgPSBGdW5jdGlvbi5wcm90b3R5cGUsXHJcblxyXG4gICAgZWxlbWVudDogRWxlbWVudCA9ICdkaXYnLFxyXG4gICAgY2xhc3NOYW1lLFxyXG4gICAgY2hpbGRyZW4gPSBjb250ZW50LFxyXG4gICAgLi4ucHJvcHNcclxufSwgcmVmKSA9PiB7XHJcbiAgICBjb25zdCByb290UmVmID0gdXNlUmVmKCk7XHJcbiAgICBjb25zdCBjb250ZW50UmVmID0gdXNlUmVmKCk7XHJcbiAgICBjb25zdCBhY3Rpb25zUmVmID0gdXNlUmVmKCk7XHJcblxyXG4gICAgdXNlSW1wZXJhdGl2ZUhhbmRsZShyZWYsICgpID0+IHJvb3RSZWYuY3VycmVudCk7XHJcblxyXG4gICAgdXNlVXBkYXRlZCgoKSA9PiB7XHJcbiAgICAgICAgaWYgKHBlcnNpc3RlbnQpIHJldHVybjtcclxuXHJcbiAgICAgICAgZnVuY3Rpb24gaGFuZGxlRG9jdW1lbnRLZXlEb3duKGV2ZW50KSB7XHJcbiAgICAgICAgICAgIGlmIChldmVudC5rZXkgPT09ICdFc2NhcGUnIHx8IGV2ZW50LmtleUNvZGUgPT09IDI3KSB7XHJcbiAgICAgICAgICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcclxuICAgICAgICAgICAgICAgIG9uQ2xvc2UoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKG9wZW4pIHtcclxuICAgICAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIGhhbmRsZURvY3VtZW50S2V5RG93bik7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIGhhbmRsZURvY3VtZW50S2V5RG93bik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gKCkgPT4gZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIGhhbmRsZURvY3VtZW50S2V5RG93bik7XHJcbiAgICB9LCBbb3BlbiwgcGVyc2lzdGVudCwgb25DbG9zZV0pO1xyXG5cclxuICAgIHVzZVVwZGF0ZWQoKCkgPT4ge1xyXG4gICAgICAgIGlmICghY29udGVudFJlZi5jdXJyZW50IHx8ICFvcGVuKSByZXR1cm47XHJcblxyXG4gICAgICAgIGNvbnN0IGNvbnRlbnRFbGVtZW50ID0gY29udGVudFJlZi5jdXJyZW50O1xyXG4gICAgICAgIGNvbnN0IHNob3VsZFNjcm9sbCA9IGNvbnRlbnRFbGVtZW50LnNjcm9sbEhlaWdodCA+IGNvbnRlbnRFbGVtZW50Lm9mZnNldEhlaWdodDtcclxuXHJcbiAgICAgICAgaWYgKHNob3VsZFNjcm9sbCkge1xyXG4gICAgICAgICAgICByb290UmVmLmN1cnJlbnQuY2xhc3NMaXN0LmFkZChjc3NDbGFzc2VzLlNDUk9MTEFCTEUpO1xyXG4gICAgICAgIH1cclxuICAgIH0sIFtvcGVuXSk7XHJcblxyXG4gICAgdXNlVXBkYXRlZCgoKSA9PiB7XHJcbiAgICAgICAgaWYgKCFhY3Rpb25zUmVmLmN1cnJlbnQgfHwgIW9wZW4gfHwgIWF1dG9TdGFja0J1dHRvbnMpIHJldHVybjtcclxuXHJcbiAgICAgICAgY29uc3QgYWN0aW9uc0VsZW1lbnQgPSBhY3Rpb25zUmVmLmN1cnJlbnQ7XHJcblxyXG4gICAgICAgIGlmIChhY3Rpb25zRWxlbWVudC5jbGllbnRIZWlnaHQgPiBudW1iZXJzLkRFRkFVTFRfQUNUSU9OU19IRUlHSFQpIHtcclxuICAgICAgICAgICAgcm9vdFJlZi5jdXJyZW50LmNsYXNzTGlzdC5hZGQoY3NzQ2xhc3Nlcy5TVEFDS0VEKTtcclxuICAgICAgICB9XHJcbiAgICB9LCBbb3BlbiwgYXV0b1N0YWNrQnV0dG9uc10pO1xyXG5cclxuICAgIHVzZVVwZGF0ZWQoKCkgPT4ge1xyXG4gICAgICAgIGlmICghY29udGVudFJlZi5jdXJyZW50IHx8ICFmdWxsc2NyZWVuKSByZXR1cm47XHJcblxyXG4gICAgICAgIGNvbnN0IGNvbnRlbnRFbGVtZW50ID0gY29udGVudFJlZi5jdXJyZW50O1xyXG5cclxuICAgICAgICBmdW5jdGlvbiBoYW5kbGVTY3JvbGwoKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGlzU2Nyb2xsQXRUb3AgPSBjb250ZW50RWxlbWVudC5zY3JvbGxUb3AgPT09IDA7XHJcbiAgICAgICAgICAgIGNvbnN0IGlzU2Nyb2xsQXRCb3R0b20gPSBNYXRoLmNlaWwoY29udGVudEVsZW1lbnQuc2Nyb2xsSGVpZ2h0IC0gY29udGVudEVsZW1lbnQuc2Nyb2xsVG9wKSA9PT0gY29udGVudEVsZW1lbnQuY2xpZW50SGVpZ2h0O1xyXG5cclxuICAgICAgICAgICAgcm9vdFJlZi5jdXJyZW50LmNsYXNzTGlzdC50b2dnbGUoY3NzQ2xhc3Nlcy5TQ1JPTExfRElWSURFUl9IRUFERVIsICFpc1Njcm9sbEF0VG9wKTtcclxuICAgICAgICAgICAgcm9vdFJlZi5jdXJyZW50LmNsYXNzTGlzdC50b2dnbGUoY3NzQ2xhc3Nlcy5TQ1JPTExfRElWSURFUl9GT09URVIsICFpc1Njcm9sbEF0Qm90dG9tKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbnRlbnRFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIGhhbmRsZVNjcm9sbCk7XHJcblxyXG4gICAgICAgIGlmIChvcGVuKSB7XHJcbiAgICAgICAgICAgIGhhbmRsZVNjcm9sbCgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuICgpID0+IGNvbnRlbnRFbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIGhhbmRsZVNjcm9sbCk7XHJcbiAgICB9LCBbb3BlbiwgZnVsbHNjcmVlbl0pO1xyXG5cclxuICAgIHVzZVVubW91bnRlZCgoKSA9PiB7XHJcbiAgICAgICAgZG9jdW1lbnQuYm9keS5jbGFzc0xpc3QucmVtb3ZlKGNzc0NsYXNzZXMuU0NST0xMX0xPQ0spO1xyXG4gICAgfSk7XHJcblxyXG4gICAgY29uc3QgaGFuZGxlRW50ZXIgPSB1c2VDYWxsYmFjaygoKSA9PiB7XHJcbiAgICAgICAgZG9jdW1lbnQuYm9keS5jbGFzc0xpc3QuYWRkKGNzc0NsYXNzZXMuU0NST0xMX0xPQ0spO1xyXG4gICAgfSwgW10pO1xyXG5cclxuICAgIGNvbnN0IGhhbmRsZUV4aXRlZCA9IHVzZUNhbGxiYWNrKCgpID0+IHtcclxuICAgICAgICBkb2N1bWVudC5ib2R5LmNsYXNzTGlzdC5yZW1vdmUoY3NzQ2xhc3Nlcy5TQ1JPTExfTE9DSyk7XHJcbiAgICB9LCBbXSk7XHJcblxyXG4gICAgY29uc3QgaGFuZGxlU2NyaW1DbGljayA9IHVzZUNhbGxiYWNrKCgpID0+IHtcclxuICAgICAgICBpZiAocGVyc2lzdGVudCkgcmV0dXJuO1xyXG5cclxuICAgICAgICBvbkNsb3NlKCk7XHJcbiAgICB9LCBbcGVyc2lzdGVudCwgb25DbG9zZV0pO1xyXG5cclxuICAgIGNvbnN0IGNsYXNzTmFtZXMgPSBjbGFzc25hbWVzKGNzc0NsYXNzZXMuUk9PVCwge1xyXG4gICAgICAgIFtjc3NDbGFzc2VzLkZVTExTQ1JFRU5dOiBmdWxsc2NyZWVuLFxyXG4gICAgICAgIFtjc3NDbGFzc2VzLlNUQUNLRURdOiBzdGFja2VkXHJcbiAgICB9LCBjbGFzc05hbWUpO1xyXG5cclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgPExheWVyXHJcbiAgICAgICAgICAgIG1vZGFsXHJcbiAgICAgICAgICAgIGluPXtvcGVufVxyXG4gICAgICAgICAgICBhcHBlYXI9e2FwcGVhcn1cclxuICAgICAgICAgICAgdGltZW91dD17e1xyXG4gICAgICAgICAgICAgICAgZW50ZXI6IG51bWJlcnMuRElBTE9HX0FOSU1BVElPTl9PUEVOX1RJTUVfTVMsXHJcbiAgICAgICAgICAgICAgICBleGl0OiBudW1iZXJzLkRJQUxPR19BTklNQVRJT05fQ0xPU0VfVElNRV9NU1xyXG4gICAgICAgICAgICB9fVxyXG4gICAgICAgICAgICBjbGFzc05hbWVzPXt7XHJcbiAgICAgICAgICAgICAgICBhcHBlYXI6IGNzc0NsYXNzZXMuT1BFTklORyxcclxuICAgICAgICAgICAgICAgIGFwcGVhckFjdGl2ZTogY3NzQ2xhc3Nlcy5PUEVOLFxyXG4gICAgICAgICAgICAgICAgZW50ZXI6IGNzc0NsYXNzZXMuT1BFTklORyxcclxuICAgICAgICAgICAgICAgIGVudGVyQWN0aXZlOiBjc3NDbGFzc2VzLk9QRU4sXHJcbiAgICAgICAgICAgICAgICBlbnRlckRvbmU6IGNzc0NsYXNzZXMuT1BFTixcclxuICAgICAgICAgICAgICAgIGV4aXQ6IGNzc0NsYXNzZXMuQ0xPU0lOR1xyXG4gICAgICAgICAgICB9fVxyXG4gICAgICAgICAgICBtb3VudE9uRW50ZXJcclxuICAgICAgICAgICAgdW5tb3VudE9uRXhpdFxyXG4gICAgICAgICAgICBvbkVudGVyPXtoYW5kbGVFbnRlcn1cclxuICAgICAgICAgICAgb25FeGl0ZWQ9e2hhbmRsZUV4aXRlZH1cclxuICAgICAgICA+XHJcbiAgICAgICAgICAgIDxFbGVtZW50XHJcbiAgICAgICAgICAgICAgICByZWY9e3Jvb3RSZWZ9XHJcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU9e2NsYXNzTmFtZXN9XHJcbiAgICAgICAgICAgICAgICB7Li4ucHJvcHN9XHJcbiAgICAgICAgICAgID5cclxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXtjc3NDbGFzc2VzLkNPTlRBSU5FUn0+XHJcbiAgICAgICAgICAgICAgICAgICAgPGRpdlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU9e2Nzc0NsYXNzZXMuU1VSRkFDRX1cclxuICAgICAgICAgICAgICAgICAgICAgICAgcm9sZT1cImFsZXJ0ZGlhbG9nXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgYXJpYS1tb2RhbD1cInRydWVcIlxyXG4gICAgICAgICAgICAgICAgICAgID5cclxuICAgICAgICAgICAgICAgICAgICAgICAge3RpdGxlICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8RGlhbG9nSGVhZGVyXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGU9e3RpdGxlfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsb3NlSWNvbj17Y2xvc2VJY29ufVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZ1bGxzY3JlZW49e2Z1bGxzY3JlZW59XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb25DbG9zZT17b25DbG9zZX1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHtjaGlsZHJlbiAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPERpYWxvZ0NvbnRlbnQgcmVmPXtjb250ZW50UmVmfT57Y2hpbGRyZW59PC9EaWFsb2dDb250ZW50PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICB7YWN0aW9ucyAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPERpYWxvZ0FjdGlvbnMgcmVmPXthY3Rpb25zUmVmfT57YWN0aW9uc308L0RpYWxvZ0FjdGlvbnM+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgICAgIDwvZGl2PlxyXG5cclxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXtjc3NDbGFzc2VzLlNDUklNfSBvbkNsaWNrPXtoYW5kbGVTY3JpbUNsaWNrfSAvPlxyXG4gICAgICAgICAgICA8L0VsZW1lbnQ+XHJcbiAgICAgICAgPC9MYXllcj5cclxuICAgICk7XHJcbn0pO1xyXG5cclxuRGlhbG9nLmRpc3BsYXlOYW1lID0gJ01EQ0RpYWxvZyc7XHJcblxyXG5EaWFsb2cucHJvcFR5cGVzID0ge1xyXG4gICAgdGl0bGU6IFByb3BUeXBlcy5ub2RlLFxyXG4gICAgY2xvc2VJY29uOiBQcm9wVHlwZXMubm9kZSxcclxuICAgIGNvbnRlbnQ6IFByb3BUeXBlcy5ub2RlLFxyXG4gICAgYWN0aW9uczogUHJvcFR5cGVzLm9uZU9mVHlwZShbXHJcbiAgICAgICAgUHJvcFR5cGVzLm5vZGUsXHJcbiAgICAgICAgUHJvcFR5cGVzLmFycmF5T2YoUHJvcFR5cGVzLm5vZGUpXHJcbiAgICBdKSxcclxuICAgIG9wZW46IFByb3BUeXBlcy5ib29sLFxyXG4gICAgYXBwZWFyOiBQcm9wVHlwZXMuYm9vbCxcclxuICAgIGNvbmZpcm1hdGlvbjogUHJvcFR5cGVzLmJvb2wsXHJcbiAgICBwZXJzaXN0ZW50OiBQcm9wVHlwZXMuYm9vbCxcclxuICAgIHN0YWNrZWQ6IFByb3BUeXBlcy5ib29sLFxyXG4gICAgZnVsbHNjcmVlbjogUHJvcFR5cGVzLmJvb2wsXHJcbiAgICBhdXRvU3RhY2tCdXR0b25zOiBQcm9wVHlwZXMuYm9vbCxcclxuICAgIG9uQ2xvc2U6IFByb3BUeXBlcy5mdW5jXHJcbn07XHJcblxyXG5leHBvcnQgZGVmYXVsdCBEaWFsb2c7IiwiaW1wb3J0IERpYWxvZyBmcm9tICcuL0RpYWxvZyc7XHJcbmltcG9ydCBEaWFsb2dIZWFkZXIgZnJvbSAnLi9EaWFsb2dIZWFkZXInO1xyXG5pbXBvcnQgRGlhbG9nQ29udGVudCBmcm9tICcuL0RpYWxvZ0NvbnRlbnQnO1xyXG5pbXBvcnQgRGlhbG9nQWN0aW9ucyBmcm9tICcuL0RpYWxvZ0FjdGlvbnMnO1xyXG5cclxuRGlhbG9nLkhlYWRlciA9IERpYWxvZ0hlYWRlcjtcclxuRGlhbG9nLkNvbnRlbnQgPSBEaWFsb2dDb250ZW50O1xyXG5EaWFsb2cuQWN0aW9ucyA9IERpYWxvZ0FjdGlvbnM7XHJcblxyXG5leHBvcnQge1xyXG4gICAgRGlhbG9nIGFzIGRlZmF1bHQsXHJcbiAgICBEaWFsb2dIZWFkZXIsXHJcbiAgICBEaWFsb2dDb250ZW50LFxyXG4gICAgRGlhbG9nQWN0aW9uc1xyXG59OyIsImV4cG9ydCBjb25zdCBudW1iZXJzID0ge1xyXG4gICAgQU5JTUFUSU9OX0VOVEVSX1RJTUVfTVM6IDI1MCxcclxuICAgIEFOSU1BVElPTl9FWElUX1RJTUVfTVM6IDIwMFxyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IGNzc0NsYXNzZXMgPSB7XHJcbiAgICBST09UOiAnbWRjLWRyYXdlcicsXHJcbiAgICBESVNNSVNTSUJMRTogJ21kYy1kcmF3ZXItLWRpc21pc3NpYmxlJyxcclxuICAgIE1PREFMOiAnbWRjLWRyYXdlci0tbW9kYWwnLFxyXG4gICAgT1BFTjogJ21kYy1kcmF3ZXItLW9wZW4nLFxyXG4gICAgQU5JTUFURTogJ21kYy1kcmF3ZXItLWFuaW1hdGUnLFxyXG4gICAgT1BFTklORzogJ21kYy1kcmF3ZXItLW9wZW5pbmcnLFxyXG4gICAgQ0xPU0lORzogJ21kYy1kcmF3ZXItLWNsb3NpbmcnLFxyXG5cclxuICAgIENPTlRFTlQ6ICdtZGMtZHJhd2VyX19jb250ZW50JyxcclxuICAgIEhFQURFUjogJ21kYy1kcmF3ZXJfX2hlYWRlcicsXHJcbiAgICBUSVRMRTogJ21kYy1kcmF3ZXJfX3RpdGxlJyxcclxuICAgIFNVQlRJVExFOiAnbWRjLWRyYXdlcl9fc3VidGl0bGUnLFxyXG4gICAgR1JBUEhJQzogJ21kYy1kcmF3ZXJfX2dyYXBoaWMnLFxyXG5cclxuICAgIEFQUF9DT05URU5UOiAnbWRjLWRyYXdlci1hcHAtY29udGVudCcsXHJcbiAgICBTQ1JJTTogJ21kYy1kcmF3ZXItc2NyaW0nLFxyXG59OyIsImltcG9ydCB7IGZvcndhcmRSZWYsIHVzZVJlZiwgdXNlSW1wZXJhdGl2ZUhhbmRsZSwgdXNlRWZmZWN0IH0gZnJvbSAncmVhY3QnO1xyXG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xyXG5pbXBvcnQgY2xhc3NuYW1lcyBmcm9tICdjbGFzc25hbWVzJztcclxuXHJcbmltcG9ydCBMYXllciBmcm9tICcuLi9sYXllcic7XHJcblxyXG5pbXBvcnQgeyBudW1iZXJzLCBjc3NDbGFzc2VzIH0gZnJvbSAnLi9jb25zdGFudHMnO1xyXG5cclxuY29uc3QgRHJhd2VyID0gZm9yd2FyZFJlZigoe1xyXG4gICAgb3BlbiA9IGZhbHNlLFxyXG4gICAgYXBwZWFyID0gdHJ1ZSxcclxuICAgIGRpc21pc3NpYmxlID0gZmFsc2UsXHJcbiAgICBtb2RhbCA9IGZhbHNlLFxyXG4gICAgYXBwQ29udGVudFNlbGVjdG9yLFxyXG4gICAgb25DbG9zZSA9IEZ1bmN0aW9uLnByb3RvdHlwZSxcclxuXHJcbiAgICBlbGVtZW50ID0gJ2FzaWRlJyxcclxuICAgIGNvbXBvbmVudDogRWxlbWVudCA9IGVsZW1lbnQsXHJcbiAgICBjbGFzc05hbWUsXHJcbiAgICBjaGlsZHJlbixcclxuICAgIC4uLnByb3BzXHJcbn0sIHJlZikgPT4ge1xyXG4gICAgY29uc3Qgcm9vdFJlZiA9IHVzZVJlZigpO1xyXG5cclxuICAgIHVzZUltcGVyYXRpdmVIYW5kbGUocmVmLCAoKSA9PiByb290UmVmLmN1cnJlbnQpO1xyXG5cclxuICAgIHVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICAgICAgaWYgKCFkaXNtaXNzaWJsZSkgcmV0dXJuO1xyXG5cclxuICAgICAgICBjb25zdCBhcHBDb250ZW50RWxlbWVudCA9IGFwcENvbnRlbnRTZWxlY3RvciA/XHJcbiAgICAgICAgICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoYXBwQ29udGVudFNlbGVjdG9yKSA6XHJcbiAgICAgICAgICAgIHJvb3RSZWYuY3VycmVudD8ubmV4dEVsZW1lbnRTaWJsaW5nO1xyXG5cclxuICAgICAgICBhcHBDb250ZW50RWxlbWVudD8uY2xhc3NMaXN0LmFkZChjc3NDbGFzc2VzLkFQUF9DT05URU5UKTtcclxuXHJcbiAgICAgICAgcmV0dXJuICgpID0+IHtcclxuICAgICAgICAgICAgYXBwQ29udGVudEVsZW1lbnQ/LmNsYXNzTGlzdC5yZW1vdmUoY3NzQ2xhc3Nlcy5BUFBfQ09OVEVOVCk7XHJcbiAgICAgICAgfTtcclxuICAgIH0sIFtkaXNtaXNzaWJsZSwgYXBwQ29udGVudFNlbGVjdG9yXSk7XHJcblxyXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgICAgICBpZiAoIW1vZGFsKSByZXR1cm47XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIGhhbmRsZURvY3VtZW50S2V5RG93bihldmVudCkge1xyXG4gICAgICAgICAgICBpZiAoZXZlbnQua2V5ICYmIGV2ZW50LmtleSA9PT0gJ0VzY2FwZScgfHwgZXZlbnQua2V5Q29kZSA9PT0gMjcpIHtcclxuICAgICAgICAgICAgICAgIG9uQ2xvc2UoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIGhhbmRsZURvY3VtZW50S2V5RG93bik7XHJcblxyXG4gICAgICAgIHJldHVybiAoKSA9PiBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdrZXlkb3duJywgaGFuZGxlRG9jdW1lbnRLZXlEb3duKTtcclxuICAgIH0sIFttb2RhbCwgb25DbG9zZV0pO1xyXG5cclxuICAgIGNvbnN0IGNsYXNzTmFtZXMgPSBjbGFzc25hbWVzKGNzc0NsYXNzZXMuUk9PVCwge1xyXG4gICAgICAgIFtjc3NDbGFzc2VzLkRJU01JU1NJQkxFXTogZGlzbWlzc2libGUsXHJcbiAgICAgICAgW2Nzc0NsYXNzZXMuTU9EQUxdOiBtb2RhbFxyXG4gICAgfSwgY2xhc3NOYW1lKTtcclxuXHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAgIDxMYXllclxyXG4gICAgICAgICAgICBtb2RhbD17bW9kYWx9XHJcbiAgICAgICAgICAgIGZpeGVkPXttb2RhbH1cclxuICAgICAgICAgICAgaW49e29wZW59XHJcbiAgICAgICAgICAgIGFwcGVhcj17YXBwZWFyfVxyXG4gICAgICAgICAgICB0aW1lb3V0PXt7XHJcbiAgICAgICAgICAgICAgICBlbnRlcjogbnVtYmVycy5BTklNQVRJT05fRU5URVJfVElNRV9NUyxcclxuICAgICAgICAgICAgICAgIGV4aXQ6IG51bWJlcnMuQU5JTUFUSU9OX0VYSVRfVElNRV9NU1xyXG4gICAgICAgICAgICB9fVxyXG4gICAgICAgICAgICBjbGFzc05hbWVzPXt7XHJcbiAgICAgICAgICAgICAgICBhcHBlYXI6IGNzc0NsYXNzZXMuT1BFTixcclxuICAgICAgICAgICAgICAgIGVudGVyOiBgJHtjc3NDbGFzc2VzLk9QRU59ICR7Y3NzQ2xhc3Nlcy5BTklNQVRFfWAsXHJcbiAgICAgICAgICAgICAgICBlbnRlckFjdGl2ZTogYCR7Y3NzQ2xhc3Nlcy5PUEVOfSAke2Nzc0NsYXNzZXMuT1BFTklOR31gLFxyXG4gICAgICAgICAgICAgICAgZW50ZXJEb25lOiBjc3NDbGFzc2VzLk9QRU4sXHJcbiAgICAgICAgICAgICAgICBleGl0OiBgJHtjc3NDbGFzc2VzLk9QRU59ICR7Y3NzQ2xhc3Nlcy5DTE9TSU5HfWAsXHJcbiAgICAgICAgICAgICAgICBleGl0QWN0aXZlOiBjc3NDbGFzc2VzLkNMT1NJTkdcclxuICAgICAgICAgICAgfX1cclxuICAgICAgICAgICAgbW91bnRPbkVudGVyPXttb2RhbH1cclxuICAgICAgICAgICAgdW5tb3VudE9uRXhpdD17bW9kYWx9XHJcbiAgICAgICAgPlxyXG4gICAgICAgICAgICA8PlxyXG4gICAgICAgICAgICAgICAgPEVsZW1lbnRcclxuICAgICAgICAgICAgICAgICAgICByZWY9e3Jvb3RSZWZ9XHJcbiAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPXtjbGFzc05hbWVzfVxyXG4gICAgICAgICAgICAgICAgICAgIHsuLi5wcm9wc31cclxuICAgICAgICAgICAgICAgID5cclxuICAgICAgICAgICAgICAgICAgICB7Y2hpbGRyZW59XHJcbiAgICAgICAgICAgICAgICA8L0VsZW1lbnQ+XHJcblxyXG4gICAgICAgICAgICAgICAge21vZGFsICYmXHJcbiAgICAgICAgICAgICAgICAgICAgPGRpdlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU9e2Nzc0NsYXNzZXMuU0NSSU19XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2xpY2s9e29uQ2xvc2V9XHJcbiAgICAgICAgICAgICAgICAgICAgLz5cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgPC8+XHJcbiAgICAgICAgPC9MYXllcj5cclxuICAgICk7XHJcbn0pO1xyXG5cclxuRHJhd2VyLmRpc3BsYXlOYW1lID0gJ01EQ0RyYXdlcic7XHJcblxyXG5EcmF3ZXIucHJvcFR5cGVzID0ge1xyXG4gICAgb3BlbjogUHJvcFR5cGVzLmJvb2wsXHJcbiAgICBhcHBlYXI6IFByb3BUeXBlcy5ib29sLFxyXG4gICAgZGlzbWlzc2libGU6IFByb3BUeXBlcy5ib29sLFxyXG4gICAgbW9kYWw6IFByb3BUeXBlcy5ib29sLFxyXG4gICAgYXBwQ29udGVudFNlbGVjdG9yOiBQcm9wVHlwZXMuc3RyaW5nLFxyXG4gICAgb25DbG9zZTogUHJvcFR5cGVzLmZ1bmNcclxufTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IERyYXdlcjsiLCJpbXBvcnQgeyBmb3J3YXJkUmVmIH0gZnJvbSAncmVhY3QnO1xyXG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xyXG5cclxuaW1wb3J0IHsgQ2xvbmUgfSBmcm9tICcuLi9jb21wb25lbnQnO1xyXG5cclxuaW1wb3J0IHsgY3NzQ2xhc3NlcyB9IGZyb20gJy4vY29uc3RhbnRzJztcclxuXHJcbmNvbnN0IERyYXdlckhlYWRlciA9IGZvcndhcmRSZWYoKHtcclxuICAgIHRpdGxlLFxyXG4gICAgc3VidGl0bGUsXHJcbiAgICBncmFwaGljLFxyXG5cclxuICAgIGVsZW1lbnQ6IEVsZW1lbnQgPSAnaGVhZGVyJyxcclxuICAgIGNoaWxkcmVuLFxyXG4gICAgLi4ucHJvcHNcclxufSwgcmVmKSA9PiB7XHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAgIDxFbGVtZW50IHJlZj17cmVmfSBjbGFzc05hbWU9e2Nzc0NsYXNzZXMuSEVBREVSfSB7Li4ucHJvcHN9PlxyXG4gICAgICAgICAgICB7Z3JhcGhpYyAmJlxyXG4gICAgICAgICAgICAgICAgPENsb25lXHJcbiAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50PXtncmFwaGljfVxyXG4gICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT17Y3NzQ2xhc3Nlcy5HUkFQSElDfVxyXG4gICAgICAgICAgICAgICAgLz5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAge3RpdGxlICYmXHJcbiAgICAgICAgICAgICAgICA8Q2xvbmVcclxuICAgICAgICAgICAgICAgICAgICBjb21wb25lbnQ9e3RpdGxlfVxyXG4gICAgICAgICAgICAgICAgICAgIGZhbGxiYWNrPVwiaDNcIlxyXG4gICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT17Y3NzQ2xhc3Nlcy5USVRMRX1cclxuICAgICAgICAgICAgICAgIC8+XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHtzdWJ0aXRsZSAmJlxyXG4gICAgICAgICAgICAgICAgPENsb25lXHJcbiAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50PXtzdWJ0aXRsZX1cclxuICAgICAgICAgICAgICAgICAgICBmYWxsYmFjaz1cImg2XCJcclxuICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU9e2Nzc0NsYXNzZXMuU1VCVElUTEV9XHJcbiAgICAgICAgICAgICAgICAvPlxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB7Y2hpbGRyZW59XHJcbiAgICAgICAgPC9FbGVtZW50PlxyXG4gICAgKTtcclxufSk7XHJcblxyXG5EcmF3ZXJIZWFkZXIuZGlzcGxheU5hbWUgPSAnTURDRHJhd2VySGVhZGVyJztcclxuXHJcbkRyYXdlckhlYWRlci5wcm9wVHlwZXMgPSB7XHJcbiAgICB0aXRsZTogUHJvcFR5cGVzLm5vZGUsXHJcbiAgICBzdWJ0aXRsZTogUHJvcFR5cGVzLm5vZGUsXHJcbiAgICBncmFwaGljOiBQcm9wVHlwZXMuZWxlbWVudFxyXG59O1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgRHJhd2VySGVhZGVyOyIsImltcG9ydCB7IGZvcndhcmRSZWYgfSBmcm9tICdyZWFjdCc7XHJcblxyXG5pbXBvcnQgeyBjc3NDbGFzc2VzIH0gZnJvbSAnLi9jb25zdGFudHMnO1xyXG5cclxuY29uc3QgRHJhd2VyQ29udGVudCA9IGZvcndhcmRSZWYoKHtcclxuICAgIGVsZW1lbnQ6IEVsZW1lbnQgPSAnZGl2JyxcclxuICAgIC4uLnByb3BzXHJcbn0sIHJlZikgPT4ge1xyXG4gICAgcmV0dXJuIChcclxuICAgICAgICA8RWxlbWVudCByZWY9e3JlZn0gY2xhc3NOYW1lPXtjc3NDbGFzc2VzLkNPTlRFTlR9IHsuLi5wcm9wc30gLz5cclxuICAgICk7XHJcbn0pO1xyXG5cclxuRHJhd2VyQ29udGVudC5kaXNwbGF5TmFtZSA9ICdNRENEcmF3ZXJDb250ZW50JztcclxuXHJcbmV4cG9ydCBkZWZhdWx0IERyYXdlckNvbnRlbnQ7IiwiaW1wb3J0IERyYXdlciBmcm9tICcuL0RyYXdlcic7XHJcbmltcG9ydCBEcmF3ZXJIZWFkZXIgZnJvbSAnLi9EcmF3ZXJIZWFkZXInO1xyXG5pbXBvcnQgRHJhd2VyQ29udGVudCBmcm9tICcuL0RyYXdlckNvbnRlbnQnO1xyXG5cclxuRHJhd2VyLkhlYWRlciA9IERyYXdlckhlYWRlcjtcclxuRHJhd2VyLkNvbnRlbnQgPSBEcmF3ZXJDb250ZW50O1xyXG5cclxuZXhwb3J0IHtcclxuICAgIERyYXdlciBhcyBkZWZhdWx0LFxyXG4gICAgRHJhd2VySGVhZGVyLFxyXG4gICAgRHJhd2VyQ29udGVudFxyXG59OyIsImV4cG9ydCBjb25zdCBjc3NDbGFzc2VzID0ge1xyXG4gICAgUk9PVDogJ21kYy1lbGV2YXRpb24nLFxyXG4gICAgWjogJ21kYy1lbGV2YXRpb24tLXonLFxyXG4gICAgVFJBTlNJVElPTjogJ21kYy1lbGV2YXRpb24tdHJhbnNpdGlvbidcclxufTsiLCJpbXBvcnQgeyBmb3J3YXJkUmVmIH0gZnJvbSAncmVhY3QnO1xyXG5pbXBvcnQgY2xhc3NuYW1lcyBmcm9tICdjbGFzc25hbWVzJztcclxuXHJcbmltcG9ydCB7IGNzc0NsYXNzZXMgfSBmcm9tICcuL2NvbnN0YW50cyc7XHJcblxyXG5jb25zdCBFbGV2YXRpb24gPSBmb3J3YXJkUmVmKCh7XHJcbiAgICB6ID0gMCxcclxuICAgIHRyYW5zaXRpb24gPSBmYWxzZSxcclxuXHJcbiAgICBlbGVtZW50ID0gJ2RpdicsXHJcbiAgICBjb21wb25lbnQ6IEVsZW1lbnQgPSBlbGVtZW50LFxyXG4gICAgY2xhc3NOYW1lLFxyXG4gICAgLi4ucHJvcHNcclxufSwgcmVmKSA9PiB7XHJcbiAgICBjb25zdCBjbGFzc05hbWVzID0gY2xhc3NuYW1lcyhjc3NDbGFzc2VzLlJPT1QsIHtcclxuICAgICAgICBbYCR7Y3NzQ2xhc3Nlcy5afSR7en1gXTogeixcclxuICAgICAgICBbY3NzQ2xhc3Nlcy5UUkFOU0lUSU9OXTogdHJhbnNpdGlvblxyXG4gICAgfSwgY2xhc3NOYW1lKTtcclxuXHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAgIDxFbGVtZW50IHJlZj17cmVmfSBjbGFzc05hbWU9e2NsYXNzTmFtZXN9IHsuLi5wcm9wc30gLz5cclxuICAgICk7XHJcbn0pO1xyXG5cclxuRWxldmF0aW9uLmRpc3BsYXlOYW1lID0gJ01EQ0VsZXZhdGlvbic7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBFbGV2YXRpb247IiwiZXhwb3J0IHsgZGVmYXVsdCB9IGZyb20gJy4vRWxldmF0aW9uJzsiLCJleHBvcnQgY29uc3QgY3NzQ2xhc3NlcyA9IHtcclxuICAgIFJPT1Q6ICdtZGMtZmFiJyxcclxuICAgIE1JTkk6ICdtZGMtZmFiLS1taW5pJyxcclxuICAgIEVYVEVOREVEOiAnbWRjLWZhYi0tZXh0ZW5kZWQnLFxyXG4gICAgRVhJVEVEOiAnbWRjLWZhYi0tZXhpdGVkJyxcclxuXHJcbiAgICBJQ09OOiAnbWRjLWZhYl9faWNvbicsXHJcbiAgICBMQUJFTDogJ21kYy1mYWJfX2xhYmVsJyxcclxuICAgIFJJUFBMRTogJ21kYy1mYWJfX3JpcHBsZSdcclxufTsiLCJpbXBvcnQgeyBmb3J3YXJkUmVmIH0gZnJvbSAncmVhY3QnO1xyXG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xyXG5pbXBvcnQgY2xhc3NuYW1lcyBmcm9tICdjbGFzc25hbWVzJztcclxuXHJcbmltcG9ydCB7IENsb25lIH0gZnJvbSAnLi4vY29tcG9uZW50JztcclxuaW1wb3J0IEljb24gZnJvbSAnLi4vaWNvbic7XHJcblxyXG5pbXBvcnQgeyBjc3NDbGFzc2VzIH0gZnJvbSAnLi9jb25zdGFudHMnO1xyXG5cclxuY29uc3QgRkFCID0gZm9yd2FyZFJlZigoe1xyXG4gICAgaWNvbixcclxuICAgIGxhYmVsLFxyXG4gICAgbGVhZGluZ0ljb24gPSBpY29uLFxyXG4gICAgdHJhaWxpbmdJY29uLFxyXG4gICAgbWluaSA9IGZhbHNlLFxyXG4gICAgZXhpdGVkID0gZmFsc2UsXHJcblxyXG4gICAgZWxlbWVudCA9ICdidXR0b24nLFxyXG4gICAgY29tcG9uZW50OiBFbGVtZW50ID0gZWxlbWVudCxcclxuICAgIGNsYXNzTmFtZSxcclxuICAgIGNoaWxkcmVuID0gbGFiZWwsXHJcbiAgICAuLi5wcm9wc1xyXG59LCByZWYpID0+IHtcclxuICAgIGNvbnN0IGNsYXNzTmFtZXMgPSBjbGFzc25hbWVzKGNzc0NsYXNzZXMuUk9PVCwge1xyXG4gICAgICAgIFtjc3NDbGFzc2VzLk1JTkldOiBtaW5pLFxyXG4gICAgICAgIFtjc3NDbGFzc2VzLkVYVEVOREVEXTogbGFiZWwsXHJcbiAgICAgICAgW2Nzc0NsYXNzZXMuRVhJVEVEXTogZXhpdGVkXHJcbiAgICB9LCBjbGFzc05hbWUpO1xyXG5cclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgPEVsZW1lbnQgcmVmPXtyZWZ9IGNsYXNzTmFtZT17Y2xhc3NOYW1lc30gey4uLnByb3BzfT5cclxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9e2Nzc0NsYXNzZXMuUklQUExFfSAvPlxyXG5cclxuICAgICAgICAgICAge2xlYWRpbmdJY29uICYmXHJcbiAgICAgICAgICAgICAgICA8Q2xvbmVcclxuICAgICAgICAgICAgICAgICAgICBjb21wb25lbnQ9e2xlYWRpbmdJY29ufVxyXG4gICAgICAgICAgICAgICAgICAgIGZhbGxiYWNrPXtJY29ufVxyXG4gICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT17Y3NzQ2xhc3Nlcy5JQ09OfVxyXG4gICAgICAgICAgICAgICAgLz5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAge2NoaWxkcmVuICYmXHJcbiAgICAgICAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9e2Nzc0NsYXNzZXMuTEFCRUx9PntjaGlsZHJlbn08L3NwYW4+XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHt0cmFpbGluZ0ljb24gJiZcclxuICAgICAgICAgICAgICAgIDxDbG9uZVxyXG4gICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudD17dHJhaWxpbmdJY29ufVxyXG4gICAgICAgICAgICAgICAgICAgIGZhbGxiYWNrPXtJY29ufVxyXG4gICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT17Y3NzQ2xhc3Nlcy5JQ09OfVxyXG4gICAgICAgICAgICAgICAgLz5cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIDwvRWxlbWVudD5cclxuICAgICk7XHJcbn0pO1xyXG5cclxuRkFCLmRpc3BsYXlOYW1lID0gJ01EQ0ZBQic7XHJcblxyXG5GQUIucHJvcFR5cGVzID0ge1xyXG4gICAgaWNvbjogUHJvcFR5cGVzLm5vZGUsXHJcbiAgICBsYWJlbDogUHJvcFR5cGVzLm5vZGUsXHJcbiAgICBsZWFkaW5nSWNvbjogUHJvcFR5cGVzLm5vZGUsXHJcbiAgICB0cmFpbGluZ0ljb246IFByb3BUeXBlcy5ub2RlLFxyXG4gICAgbWluaTogUHJvcFR5cGVzLmJvb2wsXHJcbiAgICBleGl0ZWQ6IFByb3BUeXBlcy5ib29sXHJcbn07XHJcblxyXG5leHBvcnQgZGVmYXVsdCBGQUI7IiwiZXhwb3J0IHsgZGVmYXVsdCB9IGZyb20gJy4vRkFCJzsiLCJleHBvcnQgY29uc3QgY3NzQ2xhc3NlcyA9IHtcclxuICAgIFJPT1Q6ICdtZGMtZm9ybS1maWVsZCcsXHJcbiAgICBBTElHTl9FTkQ6ICdtZGMtZm9ybS1maWVsZC0tYWxpZ24tZW5kJyxcclxuICAgIE5PV1JBUDogJ21kYy1mb3JtLWZpZWxkLS1ub3dyYXAnLFxyXG4gICAgU1BBQ0VfQkVUV0VFTjogJ21kYy1mb3JtLWZpZWxkLS1zcGFjZS1iZXR3ZWVuJ1xyXG59OyIsImltcG9ydCB7IGZvcndhcmRSZWYgfSBmcm9tICdyZWFjdCc7XHJcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XHJcbmltcG9ydCBjbGFzc25hbWVzIGZyb20gJ2NsYXNzbmFtZXMnO1xyXG5cclxuaW1wb3J0IHsgY3NzQ2xhc3NlcyB9IGZyb20gJy4vY29uc3RhbnRzJztcclxuXHJcbmNvbnN0IEZvcm1GaWVsZCA9IGZvcndhcmRSZWYoKHtcclxuICAgIGxhYmVsLFxyXG4gICAgYWxpZ25FbmQgPSBmYWxzZSxcclxuICAgIG5vd3JhcCA9IGZhbHNlLFxyXG4gICAgc3BhY2VCZXR3ZWVuID0gZmFsc2UsXHJcblxyXG4gICAgZWxlbWVudDogRWxlbWVudCA9ICdkaXYnLFxyXG4gICAgY2xhc3NOYW1lLFxyXG4gICAgY2hpbGRyZW4sXHJcbiAgICAuLi5wcm9wc1xyXG59LCByZWYpID0+IHtcclxuICAgIGNvbnN0IGNsYXNzTmFtZXMgPSBjbGFzc25hbWVzKGNzc0NsYXNzZXMuUk9PVCwge1xyXG4gICAgICAgIFtjc3NDbGFzc2VzLkFMSUdOX0VORF06IGFsaWduRW5kLFxyXG4gICAgICAgIFtjc3NDbGFzc2VzLk5PV1JBUF06IG5vd3JhcCxcclxuICAgICAgICBbY3NzQ2xhc3Nlcy5TUEFDRV9CRVRXRUVOXTogc3BhY2VCZXR3ZWVuXHJcbiAgICB9LCBjbGFzc05hbWUpO1xyXG5cclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgPEVsZW1lbnQgcmVmPXtyZWZ9IGNsYXNzTmFtZT17Y2xhc3NOYW1lc30gey4uLnByb3BzfT5cclxuICAgICAgICAgICAge2NoaWxkcmVufVxyXG5cclxuICAgICAgICAgICAge2xhYmVsICYmXHJcbiAgICAgICAgICAgICAgICA8bGFiZWwgaHRtbEZvcj17Y2hpbGRyZW4ucHJvcHMuaWR9PntsYWJlbH08L2xhYmVsPlxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgPC9FbGVtZW50PlxyXG4gICAgKTtcclxufSk7XHJcblxyXG5Gb3JtRmllbGQuZGlzcGxheU5hbWUgPSAnTURDRm9ybUZpZWxkJztcclxuXHJcbkZvcm1GaWVsZC5wcm9wVHlwZXMgPSB7XHJcbiAgICBsYWJlbDogUHJvcFR5cGVzLm5vZGUsXHJcbiAgICBhbGlnbkVuZDogUHJvcFR5cGVzLmJvb2wsXHJcbiAgICBub3dyYXA6IFByb3BUeXBlcy5ib29sLFxyXG4gICAgc3BhY2VCZXR3ZWVuOiBQcm9wVHlwZXMuYm9vbCxcclxuICAgIGNoaWxkcmVuOiBQcm9wVHlwZXMuYW55LmlzUmVxdWlyZWRcclxufTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IEZvcm1GaWVsZDsiLCJleHBvcnQgeyBkZWZhdWx0IH0gZnJvbSAnLi9Gb3JtRmllbGQnOyIsImV4cG9ydCBjb25zdCBjc3NDbGFzc2VzID0ge1xyXG4gICAgSU1BR0VfTElTVDogJ21kYy1pbWFnZS1saXN0JyxcclxuICAgIElNQUdFX0xJU1RfTUFTT05SWTogJ21kYy1pbWFnZS1saXN0LS1tYXNvbnJ5JyxcclxuICAgIElNQUdFX0xJU1RfV0lUSF9URVhUX1BST1RFQ1RJT046ICdtZGMtaW1hZ2UtbGlzdC0td2l0aC10ZXh0LXByb3RlY3Rpb24nLFxyXG5cclxuICAgIElNQUdFX0xJU1RfSVRFTTogJ21kYy1pbWFnZS1saXN0X19pdGVtJyxcclxuICAgIElNQUdFX0xJU1RfSU1BR0VfQVNQRUNUX0NPTlRBSU5FUjogJ21kYy1pbWFnZS1saXN0X19pbWFnZS1hc3BlY3QtY29udGFpbmVyJyxcclxuICAgIElNQUdFX0xJU1RfSU1BR0U6ICdtZGMtaW1hZ2UtbGlzdF9faW1hZ2UnLFxyXG4gICAgSU1BR0VfTElTVF9TVVBQT1JUSU5HOiAnbWRjLWltYWdlLWxpc3RfX3N1cHBvcnRpbmcnLFxyXG4gICAgSU1BR0VfTElTVF9MQUJFTDogJ21kYy1pbWFnZS1saXN0X19sYWJlbCdcclxufTsiLCJpbXBvcnQgeyBmb3J3YXJkUmVmIH0gZnJvbSAncmVhY3QnO1xyXG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xyXG5pbXBvcnQgY2xhc3NuYW1lcyBmcm9tICdjbGFzc25hbWVzJztcclxuXHJcbmltcG9ydCB7IGNzc0NsYXNzZXMgfSBmcm9tICcuL2NvbnN0YW50cyc7XHJcblxyXG5jb25zdCBJbWFnZUxpc3RJdGVtID0gZm9yd2FyZFJlZigoe1xyXG4gICAgaW1hZ2VTcmMsXHJcbiAgICBsYWJlbCxcclxuICAgIGZpeGVkQXNwZWN0ID0gdHJ1ZSxcclxuXHJcbiAgICBlbGVtZW50OiBFbGVtZW50ID0gJ2xpJyxcclxuICAgIGNsYXNzTmFtZSxcclxuICAgIC4uLnByb3BzXHJcbn0sIHJlZikgPT4ge1xyXG4gICAgY29uc3QgY2xhc3NOYW1lcyA9IGNsYXNzbmFtZXMoY3NzQ2xhc3Nlcy5JTUFHRV9MSVNUX0lURU0sIGNsYXNzTmFtZSk7XHJcblxyXG4gICAgcmV0dXJuIChcclxuICAgICAgICA8RWxlbWVudCByZWY9e3JlZn0gY2xhc3NOYW1lPXtjbGFzc05hbWVzfSB7Li4ucHJvcHN9PlxyXG4gICAgICAgICAgICB7Zml4ZWRBc3BlY3QgP1xyXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9e2Nzc0NsYXNzZXMuSU1BR0VfTElTVF9JTUFHRV9BU1BFQ1RfQ09OVEFJTkVSfT5cclxuICAgICAgICAgICAgICAgICAgICA8aW1nIGNsYXNzTmFtZT17Y3NzQ2xhc3Nlcy5JTUFHRV9MSVNUX0lNQUdFfSBzcmM9e2ltYWdlU3JjfSBhbHQ9e2xhYmVsfSAvPlxyXG4gICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICAgICA6XHJcbiAgICAgICAgICAgICAgICA8aW1nIGNsYXNzTmFtZT17Y3NzQ2xhc3Nlcy5JTUFHRV9MSVNUX0lNQUdFfSBzcmM9e2ltYWdlU3JjfSBhbHQ9e2xhYmVsfSAvPlxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB7bGFiZWwgJiZcclxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXtjc3NDbGFzc2VzLklNQUdFX0xJU1RfU1VQUE9SVElOR30+XHJcbiAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3NOYW1lPXtjc3NDbGFzc2VzLklNQUdFX0xJU1RfTEFCRUx9PntsYWJlbH08L3NwYW4+XHJcbiAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIDwvRWxlbWVudD5cclxuICAgICk7XHJcbn0pO1xyXG5cclxuSW1hZ2VMaXN0SXRlbS5kaXNwbGF5TmFtZSA9ICdNRENJbWFnZUxpc3RJdGVtJztcclxuXHJcbkltYWdlTGlzdEl0ZW0ucHJvcFR5cGVzID0ge1xyXG4gICAgaW1hZ2VTcmM6IFByb3BUeXBlcy5zdHJpbmcsXHJcbiAgICBsYWJlbDogUHJvcFR5cGVzLm5vZGUsXHJcbiAgICBmaXhlZEFzcGVjdDogUHJvcFR5cGVzLmJvb2xcclxufTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IEltYWdlTGlzdEl0ZW07IiwiaW1wb3J0IHsgQ2hpbGRyZW4sIGZvcndhcmRSZWYgfSBmcm9tICdyZWFjdCc7XHJcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XHJcbmltcG9ydCBjbGFzc25hbWVzIGZyb20gJ2NsYXNzbmFtZXMnO1xyXG5cclxuaW1wb3J0IHsgY2xvbmUsIGNyZWF0ZSB9IGZyb20gJy4uL2NvbXBvbmVudCc7XHJcblxyXG5pbXBvcnQgeyBjc3NDbGFzc2VzIH0gZnJvbSAnLi9jb25zdGFudHMnO1xyXG5pbXBvcnQgSW1hZ2VMaXN0SXRlbSBmcm9tICcuL0ltYWdlTGlzdEl0ZW0nO1xyXG5cclxuY29uc3QgSW1hZ2VMaXN0ID0gZm9yd2FyZFJlZigoe1xyXG4gICAgaXRlbXMsXHJcbiAgICBtYXNvbnJ5ID0gZmFsc2UsXHJcbiAgICB3aXRoVGV4dFByb3RlY3Rpb24gPSBmYWxzZSxcclxuXHJcbiAgICBlbGVtZW50OiBFbGVtZW50ID0gJ3VsJyxcclxuICAgIGNsYXNzTmFtZSxcclxuICAgIGNoaWxkcmVuID0gaXRlbXM/Lm1hcChpdGVtID0+IGNyZWF0ZShJbWFnZUxpc3RJdGVtLCBpdGVtKSksXHJcbiAgICAuLi5wcm9wc1xyXG59LCByZWYpID0+IHtcclxuICAgIGNvbnN0IGNsYXNzTmFtZXMgPSBjbGFzc25hbWVzKGNzc0NsYXNzZXMuSU1BR0VfTElTVCwge1xyXG4gICAgICAgIFtjc3NDbGFzc2VzLklNQUdFX0xJU1RfTUFTT05SWV06IG1hc29ucnksXHJcbiAgICAgICAgW2Nzc0NsYXNzZXMuSU1BR0VfTElTVF9XSVRIX1RFWFRfUFJPVEVDVElPTl06IHdpdGhUZXh0UHJvdGVjdGlvblxyXG4gICAgfSwgY2xhc3NOYW1lKTtcclxuXHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAgIDxFbGVtZW50IHJlZj17cmVmfSBjbGFzc05hbWU9e2NsYXNzTmFtZXN9IHsuLi5wcm9wc30+XHJcbiAgICAgICAgICAgIHtDaGlsZHJlbi5tYXAoY2hpbGRyZW4sIGNoaWxkID0+XHJcbiAgICAgICAgICAgICAgICBjbG9uZShjaGlsZCwge1xyXG4gICAgICAgICAgICAgICAgICAgIGZpeGVkQXNwZWN0OiBtYXNvbnJ5ID8gZmFsc2UgOiB1bmRlZmluZWRcclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICl9XHJcbiAgICAgICAgPC9FbGVtZW50PlxyXG4gICAgKTtcclxufSk7XHJcblxyXG5JbWFnZUxpc3QuZGlzcGxheU5hbWUgPSAnTURDSW1hZ2VMaXN0JztcclxuXHJcbkltYWdlTGlzdC5wcm9wVHlwZXMgPSB7XHJcbiAgICBpdGVtczogUHJvcFR5cGVzLmFycmF5LFxyXG4gICAgbWFzb25yeTogUHJvcFR5cGVzLmJvb2wsXHJcbiAgICB3aXRoVGV4dFByb3RlY3Rpb246IFByb3BUeXBlcy5ib29sXHJcbn07XHJcblxyXG5leHBvcnQgZGVmYXVsdCBJbWFnZUxpc3Q7IiwiaW1wb3J0IEltYWdlTGlzdCBmcm9tICcuL0ltYWdlTGlzdCc7XHJcbmltcG9ydCBJbWFnZUxpc3RJdGVtIGZyb20gJy4vSW1hZ2VMaXN0SXRlbSc7XHJcblxyXG5JbWFnZUxpc3QuSXRlbSA9IEltYWdlTGlzdEl0ZW07XHJcblxyXG5leHBvcnQge1xyXG4gICAgSW1hZ2VMaXN0IGFzIGRlZmF1bHQsXHJcbiAgICBJbWFnZUxpc3RJdGVtXHJcbn07IiwiZXhwb3J0IGNvbnN0IGNzc0NsYXNzZXMgPSB7XHJcbiAgICBST09UOiAnbWRjLWxheW91dCcsXHJcbiAgICBST1c6ICdtZGMtbGF5b3V0LS1yb3cnLFxyXG4gICAgQ09MVU1OOiAnbWRjLWxheW91dC0tY29sdW1uJyxcclxuICAgIERJUkVDVElPTjogJ21kYy1sYXlvdXQtLWRpcmVjdGlvbicsXHJcbiAgICBXUkFQOiAnbWRjLWxheW91dC0td3JhcCcsXHJcbiAgICBXUkFQX1JFVkVSU0U6ICdtZGMtbGF5b3V0LS13cmFwLXJldmVyc2UnLFxyXG4gICAgQUxJR05fSVRFTVM6ICdtZGMtbGF5b3V0LS1hbGlnbi1pdGVtcycsXHJcbiAgICBBTElHTl9TRUxGOiAnbWRjLWxheW91dC0tYWxpZ24tc2VsZicsXHJcbiAgICBKVVNUSUZZX0NPTlRFTlQ6ICdtZGMtbGF5b3V0LS1qdXN0aWZ5LWNvbnRlbnQnXHJcbn07IiwiaW1wb3J0IHsgZm9yd2FyZFJlZiB9IGZyb20gJ3JlYWN0JztcclxuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcclxuaW1wb3J0IGNsYXNzbmFtZXMgZnJvbSAnY2xhc3NuYW1lcyc7XHJcblxyXG5pbXBvcnQgeyBjc3NDbGFzc2VzIH0gZnJvbSAnLi9jb25zdGFudHMnO1xyXG5cclxuY29uc3QgTGF5b3V0ID0gZm9yd2FyZFJlZigoe1xyXG4gICAgcm93LFxyXG4gICAgY29sdW1uLFxyXG4gICAgZGlyZWN0aW9uLFxyXG4gICAgd3JhcCxcclxuICAgIGFsaWduSXRlbXMsXHJcbiAgICBhbGlnblNlbGYsXHJcbiAgICBqdXN0aWZ5Q29udGVudCxcclxuXHJcbiAgICBlbGVtZW50ID0gJ2RpdicsXHJcbiAgICBjb21wb25lbnQ6IEVsZW1lbnQgPSBlbGVtZW50LFxyXG4gICAgY2xhc3NOYW1lLFxyXG4gICAgLi4ucHJvcHNcclxufSwgcmVmKSA9PiB7XHJcbiAgICBjb25zdCBjbGFzc05hbWVzID0gY2xhc3NuYW1lcyhjc3NDbGFzc2VzLlJPT1QsIHtcclxuICAgICAgICBbY3NzQ2xhc3Nlcy5ST1ddOiByb3csXHJcbiAgICAgICAgW2Nzc0NsYXNzZXMuQ09MVU1OXTogY29sdW1uLFxyXG4gICAgICAgIFtgJHtjc3NDbGFzc2VzLkRJUkVDVElPTn0tLSR7ZGlyZWN0aW9ufWBdOiBkaXJlY3Rpb24sXHJcbiAgICAgICAgW2Nzc0NsYXNzZXMuV1JBUF06IHdyYXAgPT09IHRydWUsXHJcbiAgICAgICAgW2Nzc0NsYXNzZXMuV1JBUF9SRVZFUlNFXTogd3JhcCA9PT0gJ3JldmVyc2UnLFxyXG4gICAgICAgIFtgJHtjc3NDbGFzc2VzLkFMSUdOX0lURU1TfS0tJHthbGlnbkl0ZW1zfWBdOiBhbGlnbkl0ZW1zLFxyXG4gICAgICAgIFtgJHtjc3NDbGFzc2VzLkFMSUdOX1NFTEZ9LS0ke2FsaWduU2VsZn1gXTogYWxpZ25TZWxmLFxyXG4gICAgICAgIFtgJHtjc3NDbGFzc2VzLkpVU1RJRllfQ09OVEVOVH0tLSR7anVzdGlmeUNvbnRlbnR9YF06IGp1c3RpZnlDb250ZW50XHJcbiAgICB9LCBjbGFzc05hbWUpO1xyXG5cclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgPEVsZW1lbnQgcmVmPXtyZWZ9IGNsYXNzTmFtZT17Y2xhc3NOYW1lc30gey4uLnByb3BzfSAvPlxyXG4gICAgKTtcclxufSk7XHJcblxyXG5MYXlvdXQuZGlzcGxheU5hbWUgPSAnTURDTGF5b3V0JztcclxuXHJcbkxheW91dC5wcm9wVHlwZXMgPSB7XHJcbiAgICByb3c6IFByb3BUeXBlcy5ib29sLFxyXG4gICAgY29sdW1uOiBQcm9wVHlwZXMuYm9vbCxcclxuICAgIGRpcmVjdGlvbjogUHJvcFR5cGVzLm9uZU9mKFsncm93JywgJ2NvbHVtbiddKSxcclxuICAgIHdyYXA6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5ib29sLCBQcm9wVHlwZXMuc3RyaW5nXSksXHJcbiAgICBhbGlnbkl0ZW1zOiBQcm9wVHlwZXMub25lT2YoWydzdGFydCcsICdjZW50ZXInLCAnZW5kJ10pLFxyXG4gICAgYWxpZ25TZWxmOiBQcm9wVHlwZXMub25lT2YoWydzdGFydCcsICdjZW50ZXInLCAnZW5kJ10pLFxyXG4gICAganVzdGlmeUNvbnRlbnQ6IFByb3BUeXBlcy5vbmVPZihbJ3N0YXJ0JywgJ2NlbnRlcicsICdlbmQnLCAnYXJvdW5kJywgJ2JldHdlZW4nXSlcclxufTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IExheW91dDsiLCJleHBvcnQgeyBkZWZhdWx0IH0gZnJvbSAnLi9MYXlvdXQnOyIsImV4cG9ydCBjb25zdCBjc3NDbGFzc2VzID0ge1xyXG4gICAgUk9PVDogJ21kYy1sYXlvdXQtZ3JpZCcsXHJcbiAgICBBTElHTjogJ21kYy1sYXlvdXQtZ3JpZC0tYWxpZ24nLFxyXG4gICAgRklYRURfQ09MVU1OX1dJRFRIOiAnbWRjLWxheW91dC1ncmlkLS1maXhlZC1jb2x1bW4td2lkdGgnLFxyXG5cclxuICAgIElOTkVSOiAnbWRjLWxheW91dC1ncmlkX19pbm5lcicsXHJcblxyXG4gICAgQ0VMTDogJ21kYy1sYXlvdXQtZ3JpZF9fY2VsbCcsXHJcbiAgICBDRUxMX1NQQU46ICdtZGMtbGF5b3V0LWdyaWRfX2NlbGwtLXNwYW4nLFxyXG4gICAgQ0VMTF9PUkRFUjogJ21kYy1sYXlvdXQtZ3JpZF9fY2VsbC0tb3JkZXInLFxyXG4gICAgQ0VMTF9BTElHTjogJ21kYy1sYXlvdXQtZ3JpZF9fY2VsbC0tYWxpZ24nXHJcbn07IiwiaW1wb3J0IHsgZm9yd2FyZFJlZiB9IGZyb20gJ3JlYWN0JztcclxuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcclxuaW1wb3J0IGNsYXNzbmFtZXMgZnJvbSAnY2xhc3NuYW1lcyc7XHJcbmltcG9ydCB7IGNzc0NsYXNzZXMgfSBmcm9tICcuL2NvbnN0YW50cyc7XHJcblxyXG5jb25zdCBMYXlvdXRHcmlkID0gZm9yd2FyZFJlZigoe1xyXG4gICAgYWxpZ24sXHJcbiAgICBmaXhlZENvbHVtbldpZHRoID0gZmFsc2UsXHJcblxyXG4gICAgZWxlbWVudCA9ICdkaXYnLFxyXG4gICAgY29tcG9uZW50ID0gZWxlbWVudCxcclxuICAgIGNsYXNzTmFtZSxcclxuICAgIGNoaWxkcmVuLFxyXG4gICAgLi4ucHJvcHNcclxufSwgcmVmKSA9PiB7XHJcbiAgICBjb25zdCBFbGVtZW50ID0gY29tcG9uZW50O1xyXG4gICAgY29uc3QgY2xhc3NOYW1lcyA9IGNsYXNzbmFtZXMoY3NzQ2xhc3Nlcy5ST09ULCB7XHJcbiAgICAgICAgW2Ake2Nzc0NsYXNzZXMuQUxJR059LSR7YWxpZ259YF06IGFsaWduLFxyXG4gICAgICAgIFtjc3NDbGFzc2VzLkZJWEVEX0NPTFVNTl9XSURUSF06IGZpeGVkQ29sdW1uV2lkdGhcclxuICAgIH0sIGNsYXNzTmFtZSk7XHJcblxyXG4gICAgcmV0dXJuIChcclxuICAgICAgICA8RWxlbWVudCByZWY9e3JlZn0gY2xhc3NOYW1lPXtjbGFzc05hbWVzfSB7Li4ucHJvcHN9PlxyXG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17Y3NzQ2xhc3Nlcy5JTk5FUn0+e2NoaWxkcmVufTwvZGl2PlxyXG4gICAgICAgIDwvRWxlbWVudD5cclxuICAgICk7XHJcbn0pO1xyXG5cclxuTGF5b3V0R3JpZC5kaXNwbGF5TmFtZSA9ICdNRENMYXlvdXRHcmlkJztcclxuXHJcbkxheW91dEdyaWQucHJvcFR5cGVzID0ge1xyXG4gICAgYWxpZ246IFByb3BUeXBlcy5vbmVPZihbJ2xlZnQnLCAncmlnaHQnXSksXHJcbiAgICBmaXhlZENvbHVtbldpZHRoOiBQcm9wVHlwZXMuYm9vbFxyXG59O1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgTGF5b3V0R3JpZDsiLCJpbXBvcnQgeyBmb3J3YXJkUmVmIH0gZnJvbSAncmVhY3QnO1xyXG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xyXG5pbXBvcnQgY2xhc3NuYW1lcyBmcm9tICdjbGFzc25hbWVzJztcclxuaW1wb3J0IHsgY3NzQ2xhc3NlcyB9IGZyb20gJy4vY29uc3RhbnRzJztcclxuXHJcbmNvbnN0IExheW91dEdyaWRDZWxsID0gZm9yd2FyZFJlZigoe1xyXG4gICAgc3BhbixcclxuICAgIGRlc2t0b3AsXHJcbiAgICB0YWJsZXQsXHJcbiAgICBtb2JpbGUsXHJcbiAgICBvcmRlcixcclxuICAgIGFsaWduLFxyXG4gICAgZ3JpZCA9IGZhbHNlLFxyXG5cclxuICAgIGVsZW1lbnQgPSAnZGl2JyxcclxuICAgIGNvbXBvbmVudCA9IGVsZW1lbnQsXHJcbiAgICBjbGFzc05hbWUsXHJcbiAgICBjaGlsZHJlbixcclxuICAgIC4uLnByb3BzXHJcbn0sIHJlZikgPT4ge1xyXG4gICAgY29uc3QgRWxlbWVudCA9IGNvbXBvbmVudDtcclxuICAgIGNvbnN0IGNsYXNzTmFtZXMgPSBjbGFzc25hbWVzKGNzc0NsYXNzZXMuQ0VMTCwge1xyXG4gICAgICAgIFtgJHtjc3NDbGFzc2VzLkNFTExfU1BBTn0tJHtzcGFufWBdOiBzcGFuLFxyXG4gICAgICAgIFtgJHtjc3NDbGFzc2VzLkNFTExfU1BBTn0tJHtkZXNrdG9wfS1kZXNrdG9wYF06IGRlc2t0b3AsXHJcbiAgICAgICAgW2Ake2Nzc0NsYXNzZXMuQ0VMTF9TUEFOfS0ke3RhYmxldH0tdGFibGV0YF06IHRhYmxldCxcclxuICAgICAgICBbYCR7Y3NzQ2xhc3Nlcy5DRUxMX1NQQU59LSR7bW9iaWxlfS1tb2JpbGVgXTogbW9iaWxlLFxyXG4gICAgICAgIFtgJHtjc3NDbGFzc2VzLkNFTExfT1JERVJ9LSR7b3JkZXJ9YF06IG9yZGVyLFxyXG4gICAgICAgIFtgJHtjc3NDbGFzc2VzLkNFTExfQUxJR059LSR7YWxpZ259YF06IGFsaWduXHJcbiAgICB9LCBjbGFzc05hbWUpO1xyXG5cclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgPEVsZW1lbnQgcmVmPXtyZWZ9IGNsYXNzTmFtZT17Y2xhc3NOYW1lc30gey4uLnByb3BzfT5cclxuICAgICAgICAgICAge2dyaWQgP1xyXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9e2Nzc0NsYXNzZXMuSU5ORVJ9PlxyXG4gICAgICAgICAgICAgICAgICAgIHtjaGlsZHJlbn1cclxuICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICAgICAgOlxyXG4gICAgICAgICAgICAgICAgY2hpbGRyZW5cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIDwvRWxlbWVudD5cclxuICAgICk7XHJcbn0pO1xyXG5cclxuTGF5b3V0R3JpZENlbGwuZGlzcGxheU5hbWUgPSAnTURDTGF5b3V0R3JpZENlbGwnO1xyXG5cclxuTGF5b3V0R3JpZENlbGwucHJvcFR5cGVzID0ge1xyXG4gICAgc3BhbjogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLm51bWJlciwgUHJvcFR5cGVzLnN0cmluZ10pLFxyXG4gICAgZGVza3RvcDogUHJvcFR5cGVzLm51bWJlcixcclxuICAgIHRhYmxldDogUHJvcFR5cGVzLm51bWJlcixcclxuICAgIG1vYmlsZTogUHJvcFR5cGVzLm51bWJlcixcclxuICAgIG9yZGVyOiBQcm9wVHlwZXMubnVtYmVyLFxyXG4gICAgYWxpZ246IFByb3BUeXBlcy5vbmVPZihbJ3RvcCcsICdtaWRkbGUnLCAnYm90dG9tJ10pLFxyXG4gICAgZ3JpZDogUHJvcFR5cGVzLmJvb2xcclxufTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IExheW91dEdyaWRDZWxsOyIsImltcG9ydCBMYXlvdXRHcmlkIGZyb20gJy4vTGF5b3V0R3JpZCc7XHJcbmltcG9ydCBMYXlvdXRHcmlkQ2VsbCBmcm9tICcuL0xheW91dEdyaWRDZWxsJztcclxuXHJcbkxheW91dEdyaWQuQ2VsbCA9IExheW91dEdyaWRDZWxsO1xyXG5cclxuZXhwb3J0IHtcclxuICAgIExheW91dEdyaWQgYXMgZGVmYXVsdCxcclxuICAgIExheW91dEdyaWRDZWxsXHJcbn07IiwiZXhwb3J0IGNvbnN0IGNzc0NsYXNzZXMgPSB7XHJcbiAgICBST09UOiAnbWRjLXJhZGlvJyxcclxuICAgIERJU0FCTEVEOiAnbWRjLXJhZGlvLS1kaXNhYmxlZCcsXHJcbiAgICBUT1VDSDogJ21kYy1yYWRpby0tdG91Y2gnLFxyXG5cclxuICAgIE5BVElWRV9DT05UUk9MOiAnbWRjLXJhZGlvX19uYXRpdmUtY29udHJvbCcsXHJcbiAgICBCQUNLR1JPVU5EOiAnbWRjLXJhZGlvX19iYWNrZ3JvdW5kJyxcclxuICAgIE9VVEVSX0NJUkNMRTogJ21kYy1yYWRpb19fb3V0ZXItY2lyY2xlJyxcclxuICAgIElOTkVSX0NJUkNMRTogJ21kYy1yYWRpb19faW5uZXItY2lyY2xlJyxcclxuICAgIFJJUFBMRTogJ21kYy1yYWRpb19fcmlwcGxlJ1xyXG59OyIsImltcG9ydCB7IHVzZVJlZiwgdXNlQ2FsbGJhY2ssIGZvcndhcmRSZWYgfSBmcm9tICdyZWFjdCc7XHJcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XHJcbmltcG9ydCBjbGFzc25hbWVzIGZyb20gJ2NsYXNzbmFtZXMnO1xyXG5cclxuaW1wb3J0IHsgY3NzQ2xhc3NlcyB9IGZyb20gJy4vY29uc3RhbnRzJztcclxuXHJcbmNvbnN0IFJhZGlvID0gZm9yd2FyZFJlZigoe1xyXG4gICAgdmFsdWUsXHJcbiAgICBjaGVja2VkLFxyXG4gICAgZGlzYWJsZWQgPSBmYWxzZSxcclxuICAgIHRvdWNoID0gZmFsc2UsXHJcbiAgICBvbkNoYW5nZSA9IEZ1bmN0aW9uLnByb3RvdHlwZSxcclxuXHJcbiAgICBjbGFzc05hbWUsXHJcbiAgICAuLi5wcm9wc1xyXG59LCByZWYpID0+IHtcclxuICAgIGNvbnN0IGlucHV0UmVmID0gdXNlUmVmKCk7XHJcblxyXG4gICAgY29uc3QgaGFuZGxlQ2hhbmdlID0gdXNlQ2FsbGJhY2soZXZlbnQgPT4ge1xyXG4gICAgICAgIG9uQ2hhbmdlKGV2ZW50LCBldmVudC50YXJnZXQudmFsdWUsIGV2ZW50LnRhcmdldCk7XHJcbiAgICB9LCBbb25DaGFuZ2VdKTtcclxuXHJcbiAgICBjb25zdCBjbGFzc05hbWVzID0gY2xhc3NuYW1lcyhjc3NDbGFzc2VzLlJPT1QsIHtcclxuICAgICAgICBbY3NzQ2xhc3Nlcy5ESVNBQkxFRF06IGRpc2FibGVkLFxyXG4gICAgICAgIFtjc3NDbGFzc2VzLlRPVUNIXTogdG91Y2hcclxuICAgIH0sIGNsYXNzTmFtZSk7XHJcblxyXG4gICAgcmV0dXJuIChcclxuICAgICAgICA8ZGl2IHJlZj17cmVmfSBjbGFzc05hbWU9e2NsYXNzTmFtZXN9PlxyXG4gICAgICAgICAgICA8aW5wdXRcclxuICAgICAgICAgICAgICAgIHJlZj17aW5wdXRSZWZ9XHJcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU9e2Nzc0NsYXNzZXMuTkFUSVZFX0NPTlRST0x9XHJcbiAgICAgICAgICAgICAgICB0eXBlPVwicmFkaW9cIlxyXG4gICAgICAgICAgICAgICAgdmFsdWU9e3ZhbHVlfVxyXG4gICAgICAgICAgICAgICAgY2hlY2tlZD17Y2hlY2tlZH1cclxuICAgICAgICAgICAgICAgIGRpc2FibGVkPXtkaXNhYmxlZH1cclxuICAgICAgICAgICAgICAgIG9uQ2hhbmdlPXtoYW5kbGVDaGFuZ2V9XHJcbiAgICAgICAgICAgICAgICB7Li4ucHJvcHN9XHJcbiAgICAgICAgICAgIC8+XHJcblxyXG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17Y3NzQ2xhc3Nlcy5CQUNLR1JPVU5EfT5cclxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXtjc3NDbGFzc2VzLk9VVEVSX0NJUkNMRX0gLz5cclxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXtjc3NDbGFzc2VzLklOTkVSX0NJUkNMRX0gLz5cclxuICAgICAgICAgICAgPC9kaXY+XHJcblxyXG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17Y3NzQ2xhc3Nlcy5SSVBQTEV9IC8+XHJcbiAgICAgICAgPC9kaXY+XHJcbiAgICApO1xyXG59KTtcclxuXHJcblJhZGlvLmRpc3BsYXlOYW1lID0gJ01EQ1JhZGlvJztcclxuXHJcblJhZGlvLnByb3BUeXBlcyA9IHtcclxuICAgIHZhbHVlOiBQcm9wVHlwZXMuYW55LFxyXG4gICAgY2hlY2tlZDogUHJvcFR5cGVzLmJvb2wsXHJcbiAgICBkaXNhYmxlZDogUHJvcFR5cGVzLmJvb2wsXHJcbiAgICB0b3VjaDogUHJvcFR5cGVzLmJvb2wsXHJcbiAgICBvbkNoYW5nZTogUHJvcFR5cGVzLmZ1bmNcclxufTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IFJhZGlvOyIsImV4cG9ydCB7IGRlZmF1bHQgfSBmcm9tICcuL1JhZGlvJzsiLCIvKiEgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uXHJcblxyXG5QZXJtaXNzaW9uIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBhbmQvb3IgZGlzdHJpYnV0ZSB0aGlzIHNvZnR3YXJlIGZvciBhbnlcclxucHVycG9zZSB3aXRoIG9yIHdpdGhvdXQgZmVlIGlzIGhlcmVieSBncmFudGVkLlxyXG5cclxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiBBTkQgVEhFIEFVVEhPUiBESVNDTEFJTVMgQUxMIFdBUlJBTlRJRVMgV0lUSFxyXG5SRUdBUkQgVE8gVEhJUyBTT0ZUV0FSRSBJTkNMVURJTkcgQUxMIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFlcclxuQU5EIEZJVE5FU1MuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1IgQkUgTElBQkxFIEZPUiBBTlkgU1BFQ0lBTCwgRElSRUNULFxyXG5JTkRJUkVDVCwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIE9SIEFOWSBEQU1BR0VTIFdIQVRTT0VWRVIgUkVTVUxUSU5HIEZST01cclxuTE9TUyBPRiBVU0UsIERBVEEgT1IgUFJPRklUUywgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIE5FR0xJR0VOQ0UgT1JcclxuT1RIRVIgVE9SVElPVVMgQUNUSU9OLCBBUklTSU5HIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFVTRSBPUlxyXG5QRVJGT1JNQU5DRSBPRiBUSElTIFNPRlRXQVJFLlxyXG4qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xyXG4vKiBnbG9iYWwgUmVmbGVjdCwgUHJvbWlzZSAqL1xyXG5cclxudmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbihkLCBiKSB7XHJcbiAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XHJcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxyXG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XHJcbiAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxufTtcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2V4dGVuZHMoZCwgYikge1xyXG4gICAgaWYgKHR5cGVvZiBiICE9PSBcImZ1bmN0aW9uXCIgJiYgYiAhPT0gbnVsbClcclxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcIiArIFN0cmluZyhiKSArIFwiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcIik7XHJcbiAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XHJcbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XHJcbn1cclxuXHJcbmV4cG9ydCB2YXIgX19hc3NpZ24gPSBmdW5jdGlvbigpIHtcclxuICAgIF9fYXNzaWduID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiBfX2Fzc2lnbih0KSB7XHJcbiAgICAgICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XHJcbiAgICAgICAgICAgIHMgPSBhcmd1bWVudHNbaV07XHJcbiAgICAgICAgICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSkgdFtwXSA9IHNbcF07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0O1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIF9fYXNzaWduLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX3Jlc3QocywgZSkge1xyXG4gICAgdmFyIHQgPSB7fTtcclxuICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSAmJiBlLmluZGV4T2YocCkgPCAwKVxyXG4gICAgICAgIHRbcF0gPSBzW3BdO1xyXG4gICAgaWYgKHMgIT0gbnVsbCAmJiB0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyA9PT0gXCJmdW5jdGlvblwiKVxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBwID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzKTsgaSA8IHAubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKGUuaW5kZXhPZihwW2ldKSA8IDAgJiYgT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHMsIHBbaV0pKVxyXG4gICAgICAgICAgICAgICAgdFtwW2ldXSA9IHNbcFtpXV07XHJcbiAgICAgICAgfVxyXG4gICAgcmV0dXJuIHQ7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2RlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XHJcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xyXG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcclxuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XHJcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19wYXJhbShwYXJhbUluZGV4LCBkZWNvcmF0b3IpIHtcclxuICAgIHJldHVybiBmdW5jdGlvbiAodGFyZ2V0LCBrZXkpIHsgZGVjb3JhdG9yKHRhcmdldCwga2V5LCBwYXJhbUluZGV4KTsgfVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19tZXRhZGF0YShtZXRhZGF0YUtleSwgbWV0YWRhdGFWYWx1ZSkge1xyXG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKG1ldGFkYXRhS2V5LCBtZXRhZGF0YVZhbHVlKTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fYXdhaXRlcih0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcclxuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxyXG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxyXG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxyXG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XHJcbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xyXG4gICAgfSk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2dlbmVyYXRvcih0aGlzQXJnLCBib2R5KSB7XHJcbiAgICB2YXIgXyA9IHsgbGFiZWw6IDAsIHNlbnQ6IGZ1bmN0aW9uKCkgeyBpZiAodFswXSAmIDEpIHRocm93IHRbMV07IHJldHVybiB0WzFdOyB9LCB0cnlzOiBbXSwgb3BzOiBbXSB9LCBmLCB5LCB0LCBnO1xyXG4gICAgcmV0dXJuIGcgPSB7IG5leHQ6IHZlcmIoMCksIFwidGhyb3dcIjogdmVyYigxKSwgXCJyZXR1cm5cIjogdmVyYigyKSB9LCB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgKGdbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSksIGc7XHJcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgcmV0dXJuIGZ1bmN0aW9uICh2KSB7IHJldHVybiBzdGVwKFtuLCB2XSk7IH07IH1cclxuICAgIGZ1bmN0aW9uIHN0ZXAob3ApIHtcclxuICAgICAgICBpZiAoZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IGV4ZWN1dGluZy5cIik7XHJcbiAgICAgICAgd2hpbGUgKF8pIHRyeSB7XHJcbiAgICAgICAgICAgIGlmIChmID0gMSwgeSAmJiAodCA9IG9wWzBdICYgMiA/IHlbXCJyZXR1cm5cIl0gOiBvcFswXSA/IHlbXCJ0aHJvd1wiXSB8fCAoKHQgPSB5W1wicmV0dXJuXCJdKSAmJiB0LmNhbGwoeSksIDApIDogeS5uZXh0KSAmJiAhKHQgPSB0LmNhbGwoeSwgb3BbMV0pKS5kb25lKSByZXR1cm4gdDtcclxuICAgICAgICAgICAgaWYgKHkgPSAwLCB0KSBvcCA9IFtvcFswXSAmIDIsIHQudmFsdWVdO1xyXG4gICAgICAgICAgICBzd2l0Y2ggKG9wWzBdKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDA6IGNhc2UgMTogdCA9IG9wOyBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgNDogXy5sYWJlbCsrOyByZXR1cm4geyB2YWx1ZTogb3BbMV0sIGRvbmU6IGZhbHNlIH07XHJcbiAgICAgICAgICAgICAgICBjYXNlIDU6IF8ubGFiZWwrKzsgeSA9IG9wWzFdOyBvcCA9IFswXTsgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDc6IG9wID0gXy5vcHMucG9wKCk7IF8udHJ5cy5wb3AoKTsgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghKHQgPSBfLnRyeXMsIHQgPSB0Lmxlbmd0aCA+IDAgJiYgdFt0Lmxlbmd0aCAtIDFdKSAmJiAob3BbMF0gPT09IDYgfHwgb3BbMF0gPT09IDIpKSB7IF8gPSAwOyBjb250aW51ZTsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gMyAmJiAoIXQgfHwgKG9wWzFdID4gdFswXSAmJiBvcFsxXSA8IHRbM10pKSkgeyBfLmxhYmVsID0gb3BbMV07IGJyZWFrOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSA2ICYmIF8ubGFiZWwgPCB0WzFdKSB7IF8ubGFiZWwgPSB0WzFdOyB0ID0gb3A7IGJyZWFrOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHQgJiYgXy5sYWJlbCA8IHRbMl0pIHsgXy5sYWJlbCA9IHRbMl07IF8ub3BzLnB1c2gob3ApOyBicmVhazsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0WzJdKSBfLm9wcy5wb3AoKTtcclxuICAgICAgICAgICAgICAgICAgICBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIG9wID0gYm9keS5jYWxsKHRoaXNBcmcsIF8pO1xyXG4gICAgICAgIH0gY2F0Y2ggKGUpIHsgb3AgPSBbNiwgZV07IHkgPSAwOyB9IGZpbmFsbHkgeyBmID0gdCA9IDA7IH1cclxuICAgICAgICBpZiAob3BbMF0gJiA1KSB0aHJvdyBvcFsxXTsgcmV0dXJuIHsgdmFsdWU6IG9wWzBdID8gb3BbMV0gOiB2b2lkIDAsIGRvbmU6IHRydWUgfTtcclxuICAgIH1cclxufVxyXG5cclxuZXhwb3J0IHZhciBfX2NyZWF0ZUJpbmRpbmcgPSBPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XHJcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH0pO1xyXG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xyXG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcclxuICAgIG9bazJdID0gbVtrXTtcclxufSk7XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19leHBvcnRTdGFyKG0sIG8pIHtcclxuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKHAgIT09IFwiZGVmYXVsdFwiICYmICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobywgcCkpIF9fY3JlYXRlQmluZGluZyhvLCBtLCBwKTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fdmFsdWVzKG8pIHtcclxuICAgIHZhciBzID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIFN5bWJvbC5pdGVyYXRvciwgbSA9IHMgJiYgb1tzXSwgaSA9IDA7XHJcbiAgICBpZiAobSkgcmV0dXJuIG0uY2FsbChvKTtcclxuICAgIGlmIChvICYmIHR5cGVvZiBvLmxlbmd0aCA9PT0gXCJudW1iZXJcIikgcmV0dXJuIHtcclxuICAgICAgICBuZXh0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGlmIChvICYmIGkgPj0gby5sZW5ndGgpIG8gPSB2b2lkIDA7XHJcbiAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiBvICYmIG9baSsrXSwgZG9uZTogIW8gfTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihzID8gXCJPYmplY3QgaXMgbm90IGl0ZXJhYmxlLlwiIDogXCJTeW1ib2wuaXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19yZWFkKG8sIG4pIHtcclxuICAgIHZhciBtID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXTtcclxuICAgIGlmICghbSkgcmV0dXJuIG87XHJcbiAgICB2YXIgaSA9IG0uY2FsbChvKSwgciwgYXIgPSBbXSwgZTtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgd2hpbGUgKChuID09PSB2b2lkIDAgfHwgbi0tID4gMCkgJiYgIShyID0gaS5uZXh0KCkpLmRvbmUpIGFyLnB1c2goci52YWx1ZSk7XHJcbiAgICB9XHJcbiAgICBjYXRjaCAoZXJyb3IpIHsgZSA9IHsgZXJyb3I6IGVycm9yIH07IH1cclxuICAgIGZpbmFsbHkge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGlmIChyICYmICFyLmRvbmUgJiYgKG0gPSBpW1wicmV0dXJuXCJdKSkgbS5jYWxsKGkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmaW5hbGx5IHsgaWYgKGUpIHRocm93IGUuZXJyb3I7IH1cclxuICAgIH1cclxuICAgIHJldHVybiBhcjtcclxufVxyXG5cclxuLyoqIEBkZXByZWNhdGVkICovXHJcbmV4cG9ydCBmdW5jdGlvbiBfX3NwcmVhZCgpIHtcclxuICAgIGZvciAodmFyIGFyID0gW10sIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKVxyXG4gICAgICAgIGFyID0gYXIuY29uY2F0KF9fcmVhZChhcmd1bWVudHNbaV0pKTtcclxuICAgIHJldHVybiBhcjtcclxufVxyXG5cclxuLyoqIEBkZXByZWNhdGVkICovXHJcbmV4cG9ydCBmdW5jdGlvbiBfX3NwcmVhZEFycmF5cygpIHtcclxuICAgIGZvciAodmFyIHMgPSAwLCBpID0gMCwgaWwgPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgaWw7IGkrKykgcyArPSBhcmd1bWVudHNbaV0ubGVuZ3RoO1xyXG4gICAgZm9yICh2YXIgciA9IEFycmF5KHMpLCBrID0gMCwgaSA9IDA7IGkgPCBpbDsgaSsrKVxyXG4gICAgICAgIGZvciAodmFyIGEgPSBhcmd1bWVudHNbaV0sIGogPSAwLCBqbCA9IGEubGVuZ3RoOyBqIDwgamw7IGorKywgaysrKVxyXG4gICAgICAgICAgICByW2tdID0gYVtqXTtcclxuICAgIHJldHVybiByO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19zcHJlYWRBcnJheSh0bywgZnJvbSwgcGFjaykge1xyXG4gICAgaWYgKHBhY2sgfHwgYXJndW1lbnRzLmxlbmd0aCA9PT0gMikgZm9yICh2YXIgaSA9IDAsIGwgPSBmcm9tLmxlbmd0aCwgYXI7IGkgPCBsOyBpKyspIHtcclxuICAgICAgICBpZiAoYXIgfHwgIShpIGluIGZyb20pKSB7XHJcbiAgICAgICAgICAgIGlmICghYXIpIGFyID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZnJvbSwgMCwgaSk7XHJcbiAgICAgICAgICAgIGFyW2ldID0gZnJvbVtpXTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdG8uY29uY2F0KGFyIHx8IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGZyb20pKTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fYXdhaXQodikge1xyXG4gICAgcmV0dXJuIHRoaXMgaW5zdGFuY2VvZiBfX2F3YWl0ID8gKHRoaXMudiA9IHYsIHRoaXMpIDogbmV3IF9fYXdhaXQodik7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2FzeW5jR2VuZXJhdG9yKHRoaXNBcmcsIF9hcmd1bWVudHMsIGdlbmVyYXRvcikge1xyXG4gICAgaWYgKCFTeW1ib2wuYXN5bmNJdGVyYXRvcikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN5bWJvbC5hc3luY0l0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcclxuICAgIHZhciBnID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pLCBpLCBxID0gW107XHJcbiAgICByZXR1cm4gaSA9IHt9LCB2ZXJiKFwibmV4dFwiKSwgdmVyYihcInRocm93XCIpLCB2ZXJiKFwicmV0dXJuXCIpLCBpW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0sIGk7XHJcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgaWYgKGdbbl0pIGlbbl0gPSBmdW5jdGlvbiAodikgeyByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKGEsIGIpIHsgcS5wdXNoKFtuLCB2LCBhLCBiXSkgPiAxIHx8IHJlc3VtZShuLCB2KTsgfSk7IH07IH1cclxuICAgIGZ1bmN0aW9uIHJlc3VtZShuLCB2KSB7IHRyeSB7IHN0ZXAoZ1tuXSh2KSk7IH0gY2F0Y2ggKGUpIHsgc2V0dGxlKHFbMF1bM10sIGUpOyB9IH1cclxuICAgIGZ1bmN0aW9uIHN0ZXAocikgeyByLnZhbHVlIGluc3RhbmNlb2YgX19hd2FpdCA/IFByb21pc2UucmVzb2x2ZShyLnZhbHVlLnYpLnRoZW4oZnVsZmlsbCwgcmVqZWN0KSA6IHNldHRsZShxWzBdWzJdLCByKTsgfVxyXG4gICAgZnVuY3Rpb24gZnVsZmlsbCh2YWx1ZSkgeyByZXN1bWUoXCJuZXh0XCIsIHZhbHVlKTsgfVxyXG4gICAgZnVuY3Rpb24gcmVqZWN0KHZhbHVlKSB7IHJlc3VtZShcInRocm93XCIsIHZhbHVlKTsgfVxyXG4gICAgZnVuY3Rpb24gc2V0dGxlKGYsIHYpIHsgaWYgKGYodiksIHEuc2hpZnQoKSwgcS5sZW5ndGgpIHJlc3VtZShxWzBdWzBdLCBxWzBdWzFdKTsgfVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19hc3luY0RlbGVnYXRvcihvKSB7XHJcbiAgICB2YXIgaSwgcDtcclxuICAgIHJldHVybiBpID0ge30sIHZlcmIoXCJuZXh0XCIpLCB2ZXJiKFwidGhyb3dcIiwgZnVuY3Rpb24gKGUpIHsgdGhyb3cgZTsgfSksIHZlcmIoXCJyZXR1cm5cIiksIGlbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0sIGk7XHJcbiAgICBmdW5jdGlvbiB2ZXJiKG4sIGYpIHsgaVtuXSA9IG9bbl0gPyBmdW5jdGlvbiAodikgeyByZXR1cm4gKHAgPSAhcCkgPyB7IHZhbHVlOiBfX2F3YWl0KG9bbl0odikpLCBkb25lOiBuID09PSBcInJldHVyblwiIH0gOiBmID8gZih2KSA6IHY7IH0gOiBmOyB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2FzeW5jVmFsdWVzKG8pIHtcclxuICAgIGlmICghU3ltYm9sLmFzeW5jSXRlcmF0b3IpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTeW1ib2wuYXN5bmNJdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XHJcbiAgICB2YXIgbSA9IG9bU3ltYm9sLmFzeW5jSXRlcmF0b3JdLCBpO1xyXG4gICAgcmV0dXJuIG0gPyBtLmNhbGwobykgOiAobyA9IHR5cGVvZiBfX3ZhbHVlcyA9PT0gXCJmdW5jdGlvblwiID8gX192YWx1ZXMobykgOiBvW1N5bWJvbC5pdGVyYXRvcl0oKSwgaSA9IHt9LCB2ZXJiKFwibmV4dFwiKSwgdmVyYihcInRocm93XCIpLCB2ZXJiKFwicmV0dXJuXCIpLCBpW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0sIGkpO1xyXG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IGlbbl0gPSBvW25dICYmIGZ1bmN0aW9uICh2KSB7IHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7IHYgPSBvW25dKHYpLCBzZXR0bGUocmVzb2x2ZSwgcmVqZWN0LCB2LmRvbmUsIHYudmFsdWUpOyB9KTsgfTsgfVxyXG4gICAgZnVuY3Rpb24gc2V0dGxlKHJlc29sdmUsIHJlamVjdCwgZCwgdikgeyBQcm9taXNlLnJlc29sdmUodikudGhlbihmdW5jdGlvbih2KSB7IHJlc29sdmUoeyB2YWx1ZTogdiwgZG9uZTogZCB9KTsgfSwgcmVqZWN0KTsgfVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19tYWtlVGVtcGxhdGVPYmplY3QoY29va2VkLCByYXcpIHtcclxuICAgIGlmIChPYmplY3QuZGVmaW5lUHJvcGVydHkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KGNvb2tlZCwgXCJyYXdcIiwgeyB2YWx1ZTogcmF3IH0pOyB9IGVsc2UgeyBjb29rZWQucmF3ID0gcmF3OyB9XHJcbiAgICByZXR1cm4gY29va2VkO1xyXG59O1xyXG5cclxudmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9IE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgdikge1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2IH0pO1xyXG59KSA6IGZ1bmN0aW9uKG8sIHYpIHtcclxuICAgIG9bXCJkZWZhdWx0XCJdID0gdjtcclxufTtcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2ltcG9ydFN0YXIobW9kKSB7XHJcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xyXG4gICAgdmFyIHJlc3VsdCA9IHt9O1xyXG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKGsgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGspO1xyXG4gICAgX19zZXRNb2R1bGVEZWZhdWx0KHJlc3VsdCwgbW9kKTtcclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2ltcG9ydERlZmF1bHQobW9kKSB7XHJcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IGRlZmF1bHQ6IG1vZCB9O1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19jbGFzc1ByaXZhdGVGaWVsZEdldChyZWNlaXZlciwgc3RhdGUsIGtpbmQsIGYpIHtcclxuICAgIGlmIChraW5kID09PSBcImFcIiAmJiAhZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByaXZhdGUgYWNjZXNzb3Igd2FzIGRlZmluZWQgd2l0aG91dCBhIGdldHRlclwiKTtcclxuICAgIGlmICh0eXBlb2Ygc3RhdGUgPT09IFwiZnVuY3Rpb25cIiA/IHJlY2VpdmVyICE9PSBzdGF0ZSB8fCAhZiA6ICFzdGF0ZS5oYXMocmVjZWl2ZXIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IHJlYWQgcHJpdmF0ZSBtZW1iZXIgZnJvbSBhbiBvYmplY3Qgd2hvc2UgY2xhc3MgZGlkIG5vdCBkZWNsYXJlIGl0XCIpO1xyXG4gICAgcmV0dXJuIGtpbmQgPT09IFwibVwiID8gZiA6IGtpbmQgPT09IFwiYVwiID8gZi5jYWxsKHJlY2VpdmVyKSA6IGYgPyBmLnZhbHVlIDogc3RhdGUuZ2V0KHJlY2VpdmVyKTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fY2xhc3NQcml2YXRlRmllbGRTZXQocmVjZWl2ZXIsIHN0YXRlLCB2YWx1ZSwga2luZCwgZikge1xyXG4gICAgaWYgKGtpbmQgPT09IFwibVwiKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJpdmF0ZSBtZXRob2QgaXMgbm90IHdyaXRhYmxlXCIpO1xyXG4gICAgaWYgKGtpbmQgPT09IFwiYVwiICYmICFmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJpdmF0ZSBhY2Nlc3NvciB3YXMgZGVmaW5lZCB3aXRob3V0IGEgc2V0dGVyXCIpO1xyXG4gICAgaWYgKHR5cGVvZiBzdGF0ZSA9PT0gXCJmdW5jdGlvblwiID8gcmVjZWl2ZXIgIT09IHN0YXRlIHx8ICFmIDogIXN0YXRlLmhhcyhyZWNlaXZlcikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3Qgd3JpdGUgcHJpdmF0ZSBtZW1iZXIgdG8gYW4gb2JqZWN0IHdob3NlIGNsYXNzIGRpZCBub3QgZGVjbGFyZSBpdFwiKTtcclxuICAgIHJldHVybiAoa2luZCA9PT0gXCJhXCIgPyBmLmNhbGwocmVjZWl2ZXIsIHZhbHVlKSA6IGYgPyBmLnZhbHVlID0gdmFsdWUgOiBzdGF0ZS5zZXQocmVjZWl2ZXIsIHZhbHVlKSksIHZhbHVlO1xyXG59XHJcbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuXG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICpcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4gKiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbiAqIFRIRSBTT0ZUV0FSRS5cbiAqL1xudmFyIE1EQ0ZvdW5kYXRpb24gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTURDRm91bmRhdGlvbihhZGFwdGVyKSB7XG4gICAgICAgIGlmIChhZGFwdGVyID09PSB2b2lkIDApIHsgYWRhcHRlciA9IHt9OyB9XG4gICAgICAgIHRoaXMuYWRhcHRlciA9IGFkYXB0ZXI7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNRENGb3VuZGF0aW9uLCBcImNzc0NsYXNzZXNcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8vIENsYXNzZXMgZXh0ZW5kaW5nIE1EQ0ZvdW5kYXRpb24gc2hvdWxkIGltcGxlbWVudCB0aGlzIG1ldGhvZCB0byByZXR1cm4gYW4gb2JqZWN0IHdoaWNoIGV4cG9ydHMgZXZlcnlcbiAgICAgICAgICAgIC8vIENTUyBjbGFzcyB0aGUgZm91bmRhdGlvbiBjbGFzcyBuZWVkcyBhcyBhIHByb3BlcnR5LiBlLmcuIHtBQ1RJVkU6ICdtZGMtY29tcG9uZW50LS1hY3RpdmUnfVxuICAgICAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1EQ0ZvdW5kYXRpb24sIFwic3RyaW5nc1wiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgLy8gQ2xhc3NlcyBleHRlbmRpbmcgTURDRm91bmRhdGlvbiBzaG91bGQgaW1wbGVtZW50IHRoaXMgbWV0aG9kIHRvIHJldHVybiBhbiBvYmplY3Qgd2hpY2ggZXhwb3J0cyBhbGxcbiAgICAgICAgICAgIC8vIHNlbWFudGljIHN0cmluZ3MgYXMgY29uc3RhbnRzLiBlLmcuIHtBUklBX1JPTEU6ICd0YWJsaXN0J31cbiAgICAgICAgICAgIHJldHVybiB7fTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNRENGb3VuZGF0aW9uLCBcIm51bWJlcnNcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8vIENsYXNzZXMgZXh0ZW5kaW5nIE1EQ0ZvdW5kYXRpb24gc2hvdWxkIGltcGxlbWVudCB0aGlzIG1ldGhvZCB0byByZXR1cm4gYW4gb2JqZWN0IHdoaWNoIGV4cG9ydHMgYWxsXG4gICAgICAgICAgICAvLyBvZiBpdHMgc2VtYW50aWMgbnVtYmVycyBhcyBjb25zdGFudHMuIGUuZy4ge0FOSU1BVElPTl9ERUxBWV9NUzogMzUwfVxuICAgICAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1EQ0ZvdW5kYXRpb24sIFwiZGVmYXVsdEFkYXB0ZXJcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8vIENsYXNzZXMgZXh0ZW5kaW5nIE1EQ0ZvdW5kYXRpb24gbWF5IGNob29zZSB0byBpbXBsZW1lbnQgdGhpcyBnZXR0ZXIgaW4gb3JkZXIgdG8gcHJvdmlkZSBhIGNvbnZlbmllbnRcbiAgICAgICAgICAgIC8vIHdheSBvZiB2aWV3aW5nIHRoZSBuZWNlc3NhcnkgbWV0aG9kcyBvZiBhbiBhZGFwdGVyLiBJbiB0aGUgZnV0dXJlLCB0aGlzIGNvdWxkIGFsc28gYmUgdXNlZCBmb3IgYWRhcHRlclxuICAgICAgICAgICAgLy8gdmFsaWRhdGlvbi5cbiAgICAgICAgICAgIHJldHVybiB7fTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE1EQ0ZvdW5kYXRpb24ucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIFN1YmNsYXNzZXMgc2hvdWxkIG92ZXJyaWRlIHRoaXMgbWV0aG9kIHRvIHBlcmZvcm0gaW5pdGlhbGl6YXRpb24gcm91dGluZXMgKHJlZ2lzdGVyaW5nIGV2ZW50cywgZXRjLilcbiAgICB9O1xuICAgIE1EQ0ZvdW5kYXRpb24ucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIFN1YmNsYXNzZXMgc2hvdWxkIG92ZXJyaWRlIHRoaXMgbWV0aG9kIHRvIHBlcmZvcm0gZGUtaW5pdGlhbGl6YXRpb24gcm91dGluZXMgKGRlLXJlZ2lzdGVyaW5nIGV2ZW50cywgZXRjLilcbiAgICB9O1xuICAgIHJldHVybiBNRENGb3VuZGF0aW9uO1xufSgpKTtcbmV4cG9ydCB7IE1EQ0ZvdW5kYXRpb24gfTtcbi8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpuby1kZWZhdWx0LWV4cG9ydCBOZWVkZWQgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHkgd2l0aCBNREMgV2ViIHYwLjQ0LjAgYW5kIGVhcmxpZXIuXG5leHBvcnQgZGVmYXVsdCBNRENGb3VuZGF0aW9uO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Zm91bmRhdGlvbi5qcy5tYXAiLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLlxuICpcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbiAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuICogYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4gKiBUSEUgU09GVFdBUkUuXG4gKi9cbmltcG9ydCB7IF9fcmVhZCwgX19zcHJlYWRBcnJheSB9IGZyb20gXCJ0c2xpYlwiO1xuaW1wb3J0IHsgTURDRm91bmRhdGlvbiB9IGZyb20gJy4vZm91bmRhdGlvbic7XG52YXIgTURDQ29tcG9uZW50ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1EQ0NvbXBvbmVudChyb290LCBmb3VuZGF0aW9uKSB7XG4gICAgICAgIHZhciBhcmdzID0gW107XG4gICAgICAgIGZvciAodmFyIF9pID0gMjsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICBhcmdzW19pIC0gMl0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucm9vdCA9IHJvb3Q7XG4gICAgICAgIHRoaXMuaW5pdGlhbGl6ZS5hcHBseSh0aGlzLCBfX3NwcmVhZEFycmF5KFtdLCBfX3JlYWQoYXJncykpKTtcbiAgICAgICAgLy8gTm90ZSB0aGF0IHdlIGluaXRpYWxpemUgZm91bmRhdGlvbiBoZXJlIGFuZCBub3Qgd2l0aGluIHRoZSBjb25zdHJ1Y3RvcidzXG4gICAgICAgIC8vIGRlZmF1bHQgcGFyYW0gc28gdGhhdCB0aGlzLnJvb3QgaXMgZGVmaW5lZCBhbmQgY2FuIGJlIHVzZWQgd2l0aGluIHRoZVxuICAgICAgICAvLyBmb3VuZGF0aW9uIGNsYXNzLlxuICAgICAgICB0aGlzLmZvdW5kYXRpb24gPVxuICAgICAgICAgICAgZm91bmRhdGlvbiA9PT0gdW5kZWZpbmVkID8gdGhpcy5nZXREZWZhdWx0Rm91bmRhdGlvbigpIDogZm91bmRhdGlvbjtcbiAgICAgICAgdGhpcy5mb3VuZGF0aW9uLmluaXQoKTtcbiAgICAgICAgdGhpcy5pbml0aWFsU3luY1dpdGhET00oKTtcbiAgICB9XG4gICAgTURDQ29tcG9uZW50LmF0dGFjaFRvID0gZnVuY3Rpb24gKHJvb3QpIHtcbiAgICAgICAgLy8gU3ViY2xhc3NlcyB3aGljaCBleHRlbmQgTURDQmFzZSBzaG91bGQgcHJvdmlkZSBhbiBhdHRhY2hUbygpIG1ldGhvZCB0aGF0IHRha2VzIGEgcm9vdCBlbGVtZW50IGFuZFxuICAgICAgICAvLyByZXR1cm5zIGFuIGluc3RhbnRpYXRlZCBjb21wb25lbnQgd2l0aCBpdHMgcm9vdCBzZXQgdG8gdGhhdCBlbGVtZW50LiBBbHNvIG5vdGUgdGhhdCBpbiB0aGUgY2FzZXMgb2ZcbiAgICAgICAgLy8gc3ViY2xhc3NlcywgYW4gZXhwbGljaXQgZm91bmRhdGlvbiBjbGFzcyB3aWxsIG5vdCBoYXZlIHRvIGJlIHBhc3NlZCBpbjsgaXQgd2lsbCBzaW1wbHkgYmUgaW5pdGlhbGl6ZWRcbiAgICAgICAgLy8gZnJvbSBnZXREZWZhdWx0Rm91bmRhdGlvbigpLlxuICAgICAgICByZXR1cm4gbmV3IE1EQ0NvbXBvbmVudChyb290LCBuZXcgTURDRm91bmRhdGlvbih7fSkpO1xuICAgIH07XG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQ6IG1ldGhvZCBwYXJhbSBvbmx5IGV4aXN0cyBmb3IgdHlwaW5nIHB1cnBvc2VzOyBpdCBkb2VzIG5vdCBuZWVkIHRvIGJlIHVuaXQgdGVzdGVkICovXG4gICAgTURDQ29tcG9uZW50LnByb3RvdHlwZS5pbml0aWFsaXplID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX2FyZ3MgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIF9hcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgIH1cbiAgICAgICAgLy8gU3ViY2xhc3NlcyBjYW4gb3ZlcnJpZGUgdGhpcyB0byBkbyBhbnkgYWRkaXRpb25hbCBzZXR1cCB3b3JrIHRoYXQgd291bGQgYmUgY29uc2lkZXJlZCBwYXJ0IG9mIGFcbiAgICAgICAgLy8gXCJjb25zdHJ1Y3RvclwiLiBFc3NlbnRpYWxseSwgaXQgaXMgYSBob29rIGludG8gdGhlIHBhcmVudCBjb25zdHJ1Y3RvciBiZWZvcmUgdGhlIGZvdW5kYXRpb24gaXNcbiAgICAgICAgLy8gaW5pdGlhbGl6ZWQuIEFueSBhZGRpdGlvbmFsIGFyZ3VtZW50cyBiZXNpZGVzIHJvb3QgYW5kIGZvdW5kYXRpb24gd2lsbCBiZSBwYXNzZWQgaW4gaGVyZS5cbiAgICB9O1xuICAgIE1EQ0NvbXBvbmVudC5wcm90b3R5cGUuZ2V0RGVmYXVsdEZvdW5kYXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIFN1YmNsYXNzZXMgbXVzdCBvdmVycmlkZSB0aGlzIG1ldGhvZCB0byByZXR1cm4gYSBwcm9wZXJseSBjb25maWd1cmVkIGZvdW5kYXRpb24gY2xhc3MgZm9yIHRoZVxuICAgICAgICAvLyBjb21wb25lbnQuXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignU3ViY2xhc3NlcyBtdXN0IG92ZXJyaWRlIGdldERlZmF1bHRGb3VuZGF0aW9uIHRvIHJldHVybiBhIHByb3Blcmx5IGNvbmZpZ3VyZWQgJyArXG4gICAgICAgICAgICAnZm91bmRhdGlvbiBjbGFzcycpO1xuICAgIH07XG4gICAgTURDQ29tcG9uZW50LnByb3RvdHlwZS5pbml0aWFsU3luY1dpdGhET00gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIFN1YmNsYXNzZXMgc2hvdWxkIG92ZXJyaWRlIHRoaXMgbWV0aG9kIGlmIHRoZXkgbmVlZCB0byBwZXJmb3JtIHdvcmsgdG8gc3luY2hyb25pemUgd2l0aCBhIGhvc3QgRE9NXG4gICAgICAgIC8vIG9iamVjdC4gQW4gZXhhbXBsZSBvZiB0aGlzIHdvdWxkIGJlIGEgZm9ybSBjb250cm9sIHdyYXBwZXIgdGhhdCBuZWVkcyB0byBzeW5jaHJvbml6ZSBpdHMgaW50ZXJuYWwgc3RhdGVcbiAgICAgICAgLy8gdG8gc29tZSBwcm9wZXJ0eSBvciBhdHRyaWJ1dGUgb2YgdGhlIGhvc3QgRE9NLiBQbGVhc2Ugbm90ZTogdGhpcyBpcyAqbm90KiB0aGUgcGxhY2UgdG8gcGVyZm9ybSBET01cbiAgICAgICAgLy8gcmVhZHMvd3JpdGVzIHRoYXQgd291bGQgY2F1c2UgbGF5b3V0IC8gcGFpbnQsIGFzIHRoaXMgaXMgY2FsbGVkIHN5bmNocm9ub3VzbHkgZnJvbSB3aXRoaW4gdGhlIGNvbnN0cnVjdG9yLlxuICAgIH07XG4gICAgTURDQ29tcG9uZW50LnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBTdWJjbGFzc2VzIG1heSBpbXBsZW1lbnQgdGhpcyBtZXRob2QgdG8gcmVsZWFzZSBhbnkgcmVzb3VyY2VzIC8gZGVyZWdpc3RlciBhbnkgbGlzdGVuZXJzIHRoZXkgaGF2ZVxuICAgICAgICAvLyBhdHRhY2hlZC4gQW4gZXhhbXBsZSBvZiB0aGlzIG1pZ2h0IGJlIGRlcmVnaXN0ZXJpbmcgYSByZXNpemUgZXZlbnQgZnJvbSB0aGUgd2luZG93IG9iamVjdC5cbiAgICAgICAgdGhpcy5mb3VuZGF0aW9uLmRlc3Ryb3koKTtcbiAgICB9O1xuICAgIE1EQ0NvbXBvbmVudC5wcm90b3R5cGUubGlzdGVuID0gZnVuY3Rpb24gKGV2dFR5cGUsIGhhbmRsZXIsIG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5yb290LmFkZEV2ZW50TGlzdGVuZXIoZXZ0VHlwZSwgaGFuZGxlciwgb3B0aW9ucyk7XG4gICAgfTtcbiAgICBNRENDb21wb25lbnQucHJvdG90eXBlLnVubGlzdGVuID0gZnVuY3Rpb24gKGV2dFR5cGUsIGhhbmRsZXIsIG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5yb290LnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZ0VHlwZSwgaGFuZGxlciwgb3B0aW9ucyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBGaXJlcyBhIGNyb3NzLWJyb3dzZXItY29tcGF0aWJsZSBjdXN0b20gZXZlbnQgZnJvbSB0aGUgY29tcG9uZW50IHJvb3Qgb2YgdGhlIGdpdmVuIHR5cGUsIHdpdGggdGhlIGdpdmVuIGRhdGEuXG4gICAgICovXG4gICAgTURDQ29tcG9uZW50LnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24gKGV2dFR5cGUsIGV2dERhdGEsIHNob3VsZEJ1YmJsZSkge1xuICAgICAgICBpZiAoc2hvdWxkQnViYmxlID09PSB2b2lkIDApIHsgc2hvdWxkQnViYmxlID0gZmFsc2U7IH1cbiAgICAgICAgdmFyIGV2dDtcbiAgICAgICAgaWYgKHR5cGVvZiBDdXN0b21FdmVudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgZXZ0ID0gbmV3IEN1c3RvbUV2ZW50KGV2dFR5cGUsIHtcbiAgICAgICAgICAgICAgICBidWJibGVzOiBzaG91bGRCdWJibGUsXG4gICAgICAgICAgICAgICAgZGV0YWlsOiBldnREYXRhLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBldnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnQ3VzdG9tRXZlbnQnKTtcbiAgICAgICAgICAgIGV2dC5pbml0Q3VzdG9tRXZlbnQoZXZ0VHlwZSwgc2hvdWxkQnViYmxlLCBmYWxzZSwgZXZ0RGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yb290LmRpc3BhdGNoRXZlbnQoZXZ0KTtcbiAgICB9O1xuICAgIHJldHVybiBNRENDb21wb25lbnQ7XG59KCkpO1xuZXhwb3J0IHsgTURDQ29tcG9uZW50IH07XG4vLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8tZGVmYXVsdC1leHBvcnQgTmVlZGVkIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5IHdpdGggTURDIFdlYiB2MC40NC4wIGFuZCBlYXJsaWVyLlxuZXhwb3J0IGRlZmF1bHQgTURDQ29tcG9uZW50O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29tcG9uZW50LmpzLm1hcCIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE5IEdvb2dsZSBJbmMuXG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICpcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4gKiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbiAqIFRIRSBTT0ZUV0FSRS5cbiAqL1xuLyoqXG4gKiBEZXRlcm1pbmUgd2hldGhlciB0aGUgY3VycmVudCBicm93c2VyIHN1cHBvcnRzIHBhc3NpdmUgZXZlbnQgbGlzdGVuZXJzLCBhbmRcbiAqIGlmIHNvLCB1c2UgdGhlbS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFwcGx5UGFzc2l2ZShnbG9iYWxPYmopIHtcbiAgICBpZiAoZ2xvYmFsT2JqID09PSB2b2lkIDApIHsgZ2xvYmFsT2JqID0gd2luZG93OyB9XG4gICAgcmV0dXJuIHN1cHBvcnRzUGFzc2l2ZU9wdGlvbihnbG9iYWxPYmopID9cbiAgICAgICAgeyBwYXNzaXZlOiB0cnVlIH0gOlxuICAgICAgICBmYWxzZTtcbn1cbmZ1bmN0aW9uIHN1cHBvcnRzUGFzc2l2ZU9wdGlvbihnbG9iYWxPYmopIHtcbiAgICBpZiAoZ2xvYmFsT2JqID09PSB2b2lkIDApIHsgZ2xvYmFsT2JqID0gd2luZG93OyB9XG4gICAgLy8gU2VlXG4gICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0V2ZW50VGFyZ2V0L2FkZEV2ZW50TGlzdGVuZXJcbiAgICB2YXIgcGFzc2l2ZVN1cHBvcnRlZCA9IGZhbHNlO1xuICAgIHRyeSB7XG4gICAgICAgIHZhciBvcHRpb25zID0ge1xuICAgICAgICAgICAgLy8gVGhpcyBmdW5jdGlvbiB3aWxsIGJlIGNhbGxlZCB3aGVuIHRoZSBicm93c2VyXG4gICAgICAgICAgICAvLyBhdHRlbXB0cyB0byBhY2Nlc3MgdGhlIHBhc3NpdmUgcHJvcGVydHkuXG4gICAgICAgICAgICBnZXQgcGFzc2l2ZSgpIHtcbiAgICAgICAgICAgICAgICBwYXNzaXZlU3VwcG9ydGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHZhciBoYW5kbGVyID0gZnVuY3Rpb24gKCkgeyB9O1xuICAgICAgICBnbG9iYWxPYmouZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndGVzdCcsIGhhbmRsZXIsIG9wdGlvbnMpO1xuICAgICAgICBnbG9iYWxPYmouZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigndGVzdCcsIGhhbmRsZXIsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHBhc3NpdmVTdXBwb3J0ZWQgPSBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHBhc3NpdmVTdXBwb3J0ZWQ7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ldmVudHMuanMubWFwIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTggR29vZ2xlIEluYy5cbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuICogVEhFIFNPRlRXQVJFLlxuICovXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgQSBcInBvbnlmaWxsXCIgaXMgYSBwb2x5ZmlsbCB0aGF0IGRvZXNuJ3QgbW9kaWZ5IHRoZSBnbG9iYWwgcHJvdG90eXBlIGNoYWluLlxuICogVGhpcyBtYWtlcyBwb255ZmlsbHMgc2FmZXIgdGhhbiB0cmFkaXRpb25hbCBwb2x5ZmlsbHMsIGVzcGVjaWFsbHkgZm9yIGxpYnJhcmllcyBsaWtlIE1EQy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNsb3Nlc3QoZWxlbWVudCwgc2VsZWN0b3IpIHtcbiAgICBpZiAoZWxlbWVudC5jbG9zZXN0KSB7XG4gICAgICAgIHJldHVybiBlbGVtZW50LmNsb3Nlc3Qoc2VsZWN0b3IpO1xuICAgIH1cbiAgICB2YXIgZWwgPSBlbGVtZW50O1xuICAgIHdoaWxlIChlbCkge1xuICAgICAgICBpZiAobWF0Y2hlcyhlbCwgc2VsZWN0b3IpKSB7XG4gICAgICAgICAgICByZXR1cm4gZWw7XG4gICAgICAgIH1cbiAgICAgICAgZWwgPSBlbC5wYXJlbnRFbGVtZW50O1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbmV4cG9ydCBmdW5jdGlvbiBtYXRjaGVzKGVsZW1lbnQsIHNlbGVjdG9yKSB7XG4gICAgdmFyIG5hdGl2ZU1hdGNoZXMgPSBlbGVtZW50Lm1hdGNoZXNcbiAgICAgICAgfHwgZWxlbWVudC53ZWJraXRNYXRjaGVzU2VsZWN0b3JcbiAgICAgICAgfHwgZWxlbWVudC5tc01hdGNoZXNTZWxlY3RvcjtcbiAgICByZXR1cm4gbmF0aXZlTWF0Y2hlcy5jYWxsKGVsZW1lbnQsIHNlbGVjdG9yKTtcbn1cbi8qKlxuICogVXNlZCB0byBjb21wdXRlIHRoZSBlc3RpbWF0ZWQgc2Nyb2xsIHdpZHRoIG9mIGVsZW1lbnRzLiBXaGVuIGFuIGVsZW1lbnQgaXNcbiAqIGhpZGRlbiBkdWUgdG8gZGlzcGxheTogbm9uZTsgYmVpbmcgYXBwbGllZCB0byBhIHBhcmVudCBlbGVtZW50LCB0aGUgd2lkdGggaXNcbiAqIHJldHVybmVkIGFzIDAuIEhvd2V2ZXIsIHRoZSBlbGVtZW50IHdpbGwgaGF2ZSBhIHRydWUgd2lkdGggb25jZSBubyBsb25nZXJcbiAqIGluc2lkZSBhIGRpc3BsYXk6IG5vbmUgY29udGV4dC4gVGhpcyBtZXRob2QgY29tcHV0ZXMgYW4gZXN0aW1hdGVkIHdpZHRoIHdoZW5cbiAqIHRoZSBlbGVtZW50IGlzIGhpZGRlbiBvciByZXR1cm5zIHRoZSB0cnVlIHdpZHRoIHdoZW4gdGhlIGVsZW1lbnQgaXMgdmlzYmxlLlxuICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50IHRoZSBlbGVtZW50IHdob3NlIHdpZHRoIHRvIGVzdGltYXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlc3RpbWF0ZVNjcm9sbFdpZHRoKGVsZW1lbnQpIHtcbiAgICAvLyBDaGVjayB0aGUgb2Zmc2V0UGFyZW50LiBJZiB0aGUgZWxlbWVudCBpbmhlcml0cyBkaXNwbGF5OiBub25lIGZyb20gYW55XG4gICAgLy8gcGFyZW50LCB0aGUgb2Zmc2V0UGFyZW50IHByb3BlcnR5IHdpbGwgYmUgbnVsbCAoc2VlXG4gICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0hUTUxFbGVtZW50L29mZnNldFBhcmVudCkuXG4gICAgLy8gVGhpcyBjaGVjayBlbnN1cmVzIHdlIG9ubHkgY2xvbmUgdGhlIG5vZGUgd2hlbiBuZWNlc3NhcnkuXG4gICAgdmFyIGh0bWxFbCA9IGVsZW1lbnQ7XG4gICAgaWYgKGh0bWxFbC5vZmZzZXRQYXJlbnQgIT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGh0bWxFbC5zY3JvbGxXaWR0aDtcbiAgICB9XG4gICAgdmFyIGNsb25lID0gaHRtbEVsLmNsb25lTm9kZSh0cnVlKTtcbiAgICBjbG9uZS5zdHlsZS5zZXRQcm9wZXJ0eSgncG9zaXRpb24nLCAnYWJzb2x1dGUnKTtcbiAgICBjbG9uZS5zdHlsZS5zZXRQcm9wZXJ0eSgndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZSgtOTk5OXB4LCAtOTk5OXB4KScpO1xuICAgIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5hcHBlbmRDaGlsZChjbG9uZSk7XG4gICAgdmFyIHNjcm9sbFdpZHRoID0gY2xvbmUuc2Nyb2xsV2lkdGg7XG4gICAgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnJlbW92ZUNoaWxkKGNsb25lKTtcbiAgICByZXR1cm4gc2Nyb2xsV2lkdGg7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wb255ZmlsbC5qcy5tYXAiLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLlxuICpcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbiAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuICogYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4gKiBUSEUgU09GVFdBUkUuXG4gKi9cbmV4cG9ydCB2YXIgY3NzQ2xhc3NlcyA9IHtcbiAgICAvLyBSaXBwbGUgaXMgYSBzcGVjaWFsIGNhc2Ugd2hlcmUgdGhlIFwicm9vdFwiIGNvbXBvbmVudCBpcyByZWFsbHkgYSBcIm1peGluXCIgb2Ygc29ydHMsXG4gICAgLy8gZ2l2ZW4gdGhhdCBpdCdzIGFuICd1cGdyYWRlJyB0byBhbiBleGlzdGluZyBjb21wb25lbnQuIFRoYXQgYmVpbmcgc2FpZCBpdCBpcyB0aGUgcm9vdFxuICAgIC8vIENTUyBjbGFzcyB0aGF0IGFsbCBvdGhlciBDU1MgY2xhc3NlcyBkZXJpdmUgZnJvbS5cbiAgICBCR19GT0NVU0VEOiAnbWRjLXJpcHBsZS11cGdyYWRlZC0tYmFja2dyb3VuZC1mb2N1c2VkJyxcbiAgICBGR19BQ1RJVkFUSU9OOiAnbWRjLXJpcHBsZS11cGdyYWRlZC0tZm9yZWdyb3VuZC1hY3RpdmF0aW9uJyxcbiAgICBGR19ERUFDVElWQVRJT046ICdtZGMtcmlwcGxlLXVwZ3JhZGVkLS1mb3JlZ3JvdW5kLWRlYWN0aXZhdGlvbicsXG4gICAgUk9PVDogJ21kYy1yaXBwbGUtdXBncmFkZWQnLFxuICAgIFVOQk9VTkRFRDogJ21kYy1yaXBwbGUtdXBncmFkZWQtLXVuYm91bmRlZCcsXG59O1xuZXhwb3J0IHZhciBzdHJpbmdzID0ge1xuICAgIFZBUl9GR19TQ0FMRTogJy0tbWRjLXJpcHBsZS1mZy1zY2FsZScsXG4gICAgVkFSX0ZHX1NJWkU6ICctLW1kYy1yaXBwbGUtZmctc2l6ZScsXG4gICAgVkFSX0ZHX1RSQU5TTEFURV9FTkQ6ICctLW1kYy1yaXBwbGUtZmctdHJhbnNsYXRlLWVuZCcsXG4gICAgVkFSX0ZHX1RSQU5TTEFURV9TVEFSVDogJy0tbWRjLXJpcHBsZS1mZy10cmFuc2xhdGUtc3RhcnQnLFxuICAgIFZBUl9MRUZUOiAnLS1tZGMtcmlwcGxlLWxlZnQnLFxuICAgIFZBUl9UT1A6ICctLW1kYy1yaXBwbGUtdG9wJyxcbn07XG5leHBvcnQgdmFyIG51bWJlcnMgPSB7XG4gICAgREVBQ1RJVkFUSU9OX1RJTUVPVVRfTVM6IDIyNSxcbiAgICBGR19ERUFDVElWQVRJT05fTVM6IDE1MCxcbiAgICBJTklUSUFMX09SSUdJTl9TQ0FMRTogMC42LFxuICAgIFBBRERJTkc6IDEwLFxuICAgIFRBUF9ERUxBWV9NUzogMzAwLCAvLyBEZWxheSBiZXR3ZWVuIHRvdWNoIGFuZCBzaW11bGF0ZWQgbW91c2UgZXZlbnRzIG9uIHRvdWNoIGRldmljZXNcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb25zdGFudHMuanMubWFwIiwiLyoqXG4gKiBTdG9yZXMgcmVzdWx0IGZyb20gc3VwcG9ydHNDc3NWYXJpYWJsZXMgdG8gYXZvaWQgcmVkdW5kYW50IHByb2Nlc3NpbmcgdG9cbiAqIGRldGVjdCBDU1MgY3VzdG9tIHZhcmlhYmxlIHN1cHBvcnQuXG4gKi9cbnZhciBzdXBwb3J0c0Nzc1ZhcmlhYmxlc187XG5leHBvcnQgZnVuY3Rpb24gc3VwcG9ydHNDc3NWYXJpYWJsZXMod2luZG93T2JqLCBmb3JjZVJlZnJlc2gpIHtcbiAgICBpZiAoZm9yY2VSZWZyZXNoID09PSB2b2lkIDApIHsgZm9yY2VSZWZyZXNoID0gZmFsc2U7IH1cbiAgICB2YXIgQ1NTID0gd2luZG93T2JqLkNTUztcbiAgICB2YXIgc3VwcG9ydHNDc3NWYXJzID0gc3VwcG9ydHNDc3NWYXJpYWJsZXNfO1xuICAgIGlmICh0eXBlb2Ygc3VwcG9ydHNDc3NWYXJpYWJsZXNfID09PSAnYm9vbGVhbicgJiYgIWZvcmNlUmVmcmVzaCkge1xuICAgICAgICByZXR1cm4gc3VwcG9ydHNDc3NWYXJpYWJsZXNfO1xuICAgIH1cbiAgICB2YXIgc3VwcG9ydHNGdW5jdGlvblByZXNlbnQgPSBDU1MgJiYgdHlwZW9mIENTUy5zdXBwb3J0cyA9PT0gJ2Z1bmN0aW9uJztcbiAgICBpZiAoIXN1cHBvcnRzRnVuY3Rpb25QcmVzZW50KSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdmFyIGV4cGxpY2l0bHlTdXBwb3J0c0Nzc1ZhcnMgPSBDU1Muc3VwcG9ydHMoJy0tY3NzLXZhcnMnLCAneWVzJyk7XG4gICAgLy8gU2VlOiBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTU0NjY5XG4gICAgLy8gU2VlOiBSRUFETUUgc2VjdGlvbiBvbiBTYWZhcmlcbiAgICB2YXIgd2VBcmVGZWF0dXJlRGV0ZWN0aW5nU2FmYXJpMTBwbHVzID0gKENTUy5zdXBwb3J0cygnKC0tY3NzLXZhcnM6IHllcyknKSAmJlxuICAgICAgICBDU1Muc3VwcG9ydHMoJ2NvbG9yJywgJyMwMDAwMDAwMCcpKTtcbiAgICBzdXBwb3J0c0Nzc1ZhcnMgPVxuICAgICAgICBleHBsaWNpdGx5U3VwcG9ydHNDc3NWYXJzIHx8IHdlQXJlRmVhdHVyZURldGVjdGluZ1NhZmFyaTEwcGx1cztcbiAgICBpZiAoIWZvcmNlUmVmcmVzaCkge1xuICAgICAgICBzdXBwb3J0c0Nzc1ZhcmlhYmxlc18gPSBzdXBwb3J0c0Nzc1ZhcnM7XG4gICAgfVxuICAgIHJldHVybiBzdXBwb3J0c0Nzc1ZhcnM7XG59XG5leHBvcnQgZnVuY3Rpb24gZ2V0Tm9ybWFsaXplZEV2ZW50Q29vcmRzKGV2dCwgcGFnZU9mZnNldCwgY2xpZW50UmVjdCkge1xuICAgIGlmICghZXZ0KSB7XG4gICAgICAgIHJldHVybiB7IHg6IDAsIHk6IDAgfTtcbiAgICB9XG4gICAgdmFyIHggPSBwYWdlT2Zmc2V0LngsIHkgPSBwYWdlT2Zmc2V0Lnk7XG4gICAgdmFyIGRvY3VtZW50WCA9IHggKyBjbGllbnRSZWN0LmxlZnQ7XG4gICAgdmFyIGRvY3VtZW50WSA9IHkgKyBjbGllbnRSZWN0LnRvcDtcbiAgICB2YXIgbm9ybWFsaXplZFg7XG4gICAgdmFyIG5vcm1hbGl6ZWRZO1xuICAgIC8vIERldGVybWluZSB0b3VjaCBwb2ludCByZWxhdGl2ZSB0byB0aGUgcmlwcGxlIGNvbnRhaW5lci5cbiAgICBpZiAoZXZ0LnR5cGUgPT09ICd0b3VjaHN0YXJ0Jykge1xuICAgICAgICB2YXIgdG91Y2hFdmVudCA9IGV2dDtcbiAgICAgICAgbm9ybWFsaXplZFggPSB0b3VjaEV2ZW50LmNoYW5nZWRUb3VjaGVzWzBdLnBhZ2VYIC0gZG9jdW1lbnRYO1xuICAgICAgICBub3JtYWxpemVkWSA9IHRvdWNoRXZlbnQuY2hhbmdlZFRvdWNoZXNbMF0ucGFnZVkgLSBkb2N1bWVudFk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB2YXIgbW91c2VFdmVudCA9IGV2dDtcbiAgICAgICAgbm9ybWFsaXplZFggPSBtb3VzZUV2ZW50LnBhZ2VYIC0gZG9jdW1lbnRYO1xuICAgICAgICBub3JtYWxpemVkWSA9IG1vdXNlRXZlbnQucGFnZVkgLSBkb2N1bWVudFk7XG4gICAgfVxuICAgIHJldHVybiB7IHg6IG5vcm1hbGl6ZWRYLCB5OiBub3JtYWxpemVkWSB9O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXRpbC5qcy5tYXAiLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLlxuICpcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbiAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuICogYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4gKiBUSEUgU09GVFdBUkUuXG4gKi9cbmltcG9ydCB7IF9fYXNzaWduLCBfX2V4dGVuZHMsIF9fdmFsdWVzIH0gZnJvbSBcInRzbGliXCI7XG5pbXBvcnQgeyBNRENGb3VuZGF0aW9uIH0gZnJvbSAnQG1hdGVyaWFsL2Jhc2UvZm91bmRhdGlvbic7XG5pbXBvcnQgeyBjc3NDbGFzc2VzLCBudW1iZXJzLCBzdHJpbmdzIH0gZnJvbSAnLi9jb25zdGFudHMnO1xuaW1wb3J0IHsgZ2V0Tm9ybWFsaXplZEV2ZW50Q29vcmRzIH0gZnJvbSAnLi91dGlsJztcbi8vIEFjdGl2YXRpb24gZXZlbnRzIHJlZ2lzdGVyZWQgb24gdGhlIHJvb3QgZWxlbWVudCBvZiBlYWNoIGluc3RhbmNlIGZvciBhY3RpdmF0aW9uXG52YXIgQUNUSVZBVElPTl9FVkVOVF9UWVBFUyA9IFtcbiAgICAndG91Y2hzdGFydCcsICdwb2ludGVyZG93bicsICdtb3VzZWRvd24nLCAna2V5ZG93bicsXG5dO1xuLy8gRGVhY3RpdmF0aW9uIGV2ZW50cyByZWdpc3RlcmVkIG9uIGRvY3VtZW50RWxlbWVudCB3aGVuIGEgcG9pbnRlci1yZWxhdGVkIGRvd24gZXZlbnQgb2NjdXJzXG52YXIgUE9JTlRFUl9ERUFDVElWQVRJT05fRVZFTlRfVFlQRVMgPSBbXG4gICAgJ3RvdWNoZW5kJywgJ3BvaW50ZXJ1cCcsICdtb3VzZXVwJywgJ2NvbnRleHRtZW51Jyxcbl07XG4vLyBzaW11bHRhbmVvdXMgbmVzdGVkIGFjdGl2YXRpb25zXG52YXIgYWN0aXZhdGVkVGFyZ2V0cyA9IFtdO1xudmFyIE1EQ1JpcHBsZUZvdW5kYXRpb24gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE1EQ1JpcHBsZUZvdW5kYXRpb24sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTURDUmlwcGxlRm91bmRhdGlvbihhZGFwdGVyKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIF9fYXNzaWduKF9fYXNzaWduKHt9LCBNRENSaXBwbGVGb3VuZGF0aW9uLmRlZmF1bHRBZGFwdGVyKSwgYWRhcHRlcikpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLmFjdGl2YXRpb25BbmltYXRpb25IYXNFbmRlZCA9IGZhbHNlO1xuICAgICAgICBfdGhpcy5hY3RpdmF0aW9uVGltZXIgPSAwO1xuICAgICAgICBfdGhpcy5mZ0RlYWN0aXZhdGlvblJlbW92YWxUaW1lciA9IDA7XG4gICAgICAgIF90aGlzLmZnU2NhbGUgPSAnMCc7XG4gICAgICAgIF90aGlzLmZyYW1lID0geyB3aWR0aDogMCwgaGVpZ2h0OiAwIH07XG4gICAgICAgIF90aGlzLmluaXRpYWxTaXplID0gMDtcbiAgICAgICAgX3RoaXMubGF5b3V0RnJhbWUgPSAwO1xuICAgICAgICBfdGhpcy5tYXhSYWRpdXMgPSAwO1xuICAgICAgICBfdGhpcy51bmJvdW5kZWRDb29yZHMgPSB7IGxlZnQ6IDAsIHRvcDogMCB9O1xuICAgICAgICBfdGhpcy5hY3RpdmF0aW9uU3RhdGUgPSBfdGhpcy5kZWZhdWx0QWN0aXZhdGlvblN0YXRlKCk7XG4gICAgICAgIF90aGlzLmFjdGl2YXRpb25UaW1lckNhbGxiYWNrID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMuYWN0aXZhdGlvbkFuaW1hdGlvbkhhc0VuZGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIF90aGlzLnJ1bkRlYWN0aXZhdGlvblVYTG9naWNJZlJlYWR5KCk7XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLmFjdGl2YXRlSGFuZGxlciA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICBfdGhpcy5hY3RpdmF0ZUltcGwoZSk7XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLmRlYWN0aXZhdGVIYW5kbGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMuZGVhY3RpdmF0ZUltcGwoKTtcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuZm9jdXNIYW5kbGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMuaGFuZGxlRm9jdXMoKTtcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuYmx1ckhhbmRsZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpcy5oYW5kbGVCbHVyKCk7XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLnJlc2l6ZUhhbmRsZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpcy5sYXlvdXQoKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTURDUmlwcGxlRm91bmRhdGlvbiwgXCJjc3NDbGFzc2VzXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gY3NzQ2xhc3NlcztcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNRENSaXBwbGVGb3VuZGF0aW9uLCBcInN0cmluZ3NcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBzdHJpbmdzO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1EQ1JpcHBsZUZvdW5kYXRpb24sIFwibnVtYmVyc1wiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bWJlcnM7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTURDUmlwcGxlRm91bmRhdGlvbiwgXCJkZWZhdWx0QWRhcHRlclwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBhZGRDbGFzczogZnVuY3Rpb24gKCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9LFxuICAgICAgICAgICAgICAgIGJyb3dzZXJTdXBwb3J0c0Nzc1ZhcnM6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRydWU7IH0sXG4gICAgICAgICAgICAgICAgY29tcHV0ZUJvdW5kaW5nUmVjdDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKHsgdG9wOiAwLCByaWdodDogMCwgYm90dG9tOiAwLCBsZWZ0OiAwLCB3aWR0aDogMCwgaGVpZ2h0OiAwIH0pO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgY29udGFpbnNFdmVudFRhcmdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdHJ1ZTsgfSxcbiAgICAgICAgICAgICAgICBkZXJlZ2lzdGVyRG9jdW1lbnRJbnRlcmFjdGlvbkhhbmRsZXI6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSxcbiAgICAgICAgICAgICAgICBkZXJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyOiBmdW5jdGlvbiAoKSB7IHJldHVybiB1bmRlZmluZWQ7IH0sXG4gICAgICAgICAgICAgICAgZGVyZWdpc3RlclJlc2l6ZUhhbmRsZXI6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSxcbiAgICAgICAgICAgICAgICBnZXRXaW5kb3dQYWdlT2Zmc2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiAoeyB4OiAwLCB5OiAwIH0pOyB9LFxuICAgICAgICAgICAgICAgIGlzU3VyZmFjZUFjdGl2ZTogZnVuY3Rpb24gKCkgeyByZXR1cm4gdHJ1ZTsgfSxcbiAgICAgICAgICAgICAgICBpc1N1cmZhY2VEaXNhYmxlZDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdHJ1ZTsgfSxcbiAgICAgICAgICAgICAgICBpc1VuYm91bmRlZDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdHJ1ZTsgfSxcbiAgICAgICAgICAgICAgICByZWdpc3RlckRvY3VtZW50SW50ZXJhY3Rpb25IYW5kbGVyOiBmdW5jdGlvbiAoKSB7IHJldHVybiB1bmRlZmluZWQ7IH0sXG4gICAgICAgICAgICAgICAgcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXI6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSxcbiAgICAgICAgICAgICAgICByZWdpc3RlclJlc2l6ZUhhbmRsZXI6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSxcbiAgICAgICAgICAgICAgICByZW1vdmVDbGFzczogZnVuY3Rpb24gKCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9LFxuICAgICAgICAgICAgICAgIHVwZGF0ZUNzc1ZhcmlhYmxlOiBmdW5jdGlvbiAoKSB7IHJldHVybiB1bmRlZmluZWQ7IH0sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgTURDUmlwcGxlRm91bmRhdGlvbi5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIHN1cHBvcnRzUHJlc3NSaXBwbGUgPSB0aGlzLnN1cHBvcnRzUHJlc3NSaXBwbGUoKTtcbiAgICAgICAgdGhpcy5yZWdpc3RlclJvb3RIYW5kbGVycyhzdXBwb3J0c1ByZXNzUmlwcGxlKTtcbiAgICAgICAgaWYgKHN1cHBvcnRzUHJlc3NSaXBwbGUpIHtcbiAgICAgICAgICAgIHZhciBfYSA9IE1EQ1JpcHBsZUZvdW5kYXRpb24uY3NzQ2xhc3NlcywgUk9PVF8xID0gX2EuUk9PVCwgVU5CT1VOREVEXzEgPSBfYS5VTkJPVU5ERUQ7XG4gICAgICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIF90aGlzLmFkYXB0ZXIuYWRkQ2xhc3MoUk9PVF8xKTtcbiAgICAgICAgICAgICAgICBpZiAoX3RoaXMuYWRhcHRlci5pc1VuYm91bmRlZCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmFkYXB0ZXIuYWRkQ2xhc3MoVU5CT1VOREVEXzEpO1xuICAgICAgICAgICAgICAgICAgICAvLyBVbmJvdW5kZWQgcmlwcGxlcyBuZWVkIGxheW91dCBsb2dpYyBhcHBsaWVkIGltbWVkaWF0ZWx5IHRvIHNldCBjb29yZGluYXRlcyBmb3IgYm90aCBzaGFkZSBhbmQgcmlwcGxlXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmxheW91dEludGVybmFsKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE1EQ1JpcHBsZUZvdW5kYXRpb24ucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICh0aGlzLnN1cHBvcnRzUHJlc3NSaXBwbGUoKSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuYWN0aXZhdGlvblRpbWVyKSB7XG4gICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuYWN0aXZhdGlvblRpbWVyKTtcbiAgICAgICAgICAgICAgICB0aGlzLmFjdGl2YXRpb25UaW1lciA9IDA7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGFwdGVyLnJlbW92ZUNsYXNzKE1EQ1JpcHBsZUZvdW5kYXRpb24uY3NzQ2xhc3Nlcy5GR19BQ1RJVkFUSU9OKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmZnRGVhY3RpdmF0aW9uUmVtb3ZhbFRpbWVyKSB7XG4gICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuZmdEZWFjdGl2YXRpb25SZW1vdmFsVGltZXIpO1xuICAgICAgICAgICAgICAgIHRoaXMuZmdEZWFjdGl2YXRpb25SZW1vdmFsVGltZXIgPSAwO1xuICAgICAgICAgICAgICAgIHRoaXMuYWRhcHRlci5yZW1vdmVDbGFzcyhNRENSaXBwbGVGb3VuZGF0aW9uLmNzc0NsYXNzZXMuRkdfREVBQ1RJVkFUSU9OKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBfYSA9IE1EQ1JpcHBsZUZvdW5kYXRpb24uY3NzQ2xhc3NlcywgUk9PVF8yID0gX2EuUk9PVCwgVU5CT1VOREVEXzIgPSBfYS5VTkJPVU5ERUQ7XG4gICAgICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIF90aGlzLmFkYXB0ZXIucmVtb3ZlQ2xhc3MoUk9PVF8yKTtcbiAgICAgICAgICAgICAgICBfdGhpcy5hZGFwdGVyLnJlbW92ZUNsYXNzKFVOQk9VTkRFRF8yKTtcbiAgICAgICAgICAgICAgICBfdGhpcy5yZW1vdmVDc3NWYXJzKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRlcmVnaXN0ZXJSb290SGFuZGxlcnMoKTtcbiAgICAgICAgdGhpcy5kZXJlZ2lzdGVyRGVhY3RpdmF0aW9uSGFuZGxlcnMoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSBldnQgT3B0aW9uYWwgZXZlbnQgY29udGFpbmluZyBwb3NpdGlvbiBpbmZvcm1hdGlvbi5cbiAgICAgKi9cbiAgICBNRENSaXBwbGVGb3VuZGF0aW9uLnByb3RvdHlwZS5hY3RpdmF0ZSA9IGZ1bmN0aW9uIChldnQpIHtcbiAgICAgICAgdGhpcy5hY3RpdmF0ZUltcGwoZXZ0KTtcbiAgICB9O1xuICAgIE1EQ1JpcHBsZUZvdW5kYXRpb24ucHJvdG90eXBlLmRlYWN0aXZhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuZGVhY3RpdmF0ZUltcGwoKTtcbiAgICB9O1xuICAgIE1EQ1JpcHBsZUZvdW5kYXRpb24ucHJvdG90eXBlLmxheW91dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKHRoaXMubGF5b3V0RnJhbWUpIHtcbiAgICAgICAgICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMubGF5b3V0RnJhbWUpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubGF5b3V0RnJhbWUgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMubGF5b3V0SW50ZXJuYWwoKTtcbiAgICAgICAgICAgIF90aGlzLmxheW91dEZyYW1lID0gMDtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBNRENSaXBwbGVGb3VuZGF0aW9uLnByb3RvdHlwZS5zZXRVbmJvdW5kZWQgPSBmdW5jdGlvbiAodW5ib3VuZGVkKSB7XG4gICAgICAgIHZhciBVTkJPVU5ERUQgPSBNRENSaXBwbGVGb3VuZGF0aW9uLmNzc0NsYXNzZXMuVU5CT1VOREVEO1xuICAgICAgICBpZiAodW5ib3VuZGVkKSB7XG4gICAgICAgICAgICB0aGlzLmFkYXB0ZXIuYWRkQ2xhc3MoVU5CT1VOREVEKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuYWRhcHRlci5yZW1vdmVDbGFzcyhVTkJPVU5ERUQpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBNRENSaXBwbGVGb3VuZGF0aW9uLnByb3RvdHlwZS5oYW5kbGVGb2N1cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLmFkYXB0ZXIuYWRkQ2xhc3MoTURDUmlwcGxlRm91bmRhdGlvbi5jc3NDbGFzc2VzLkJHX0ZPQ1VTRUQpOyB9KTtcbiAgICB9O1xuICAgIE1EQ1JpcHBsZUZvdW5kYXRpb24ucHJvdG90eXBlLmhhbmRsZUJsdXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5hZGFwdGVyLnJlbW92ZUNsYXNzKE1EQ1JpcHBsZUZvdW5kYXRpb24uY3NzQ2xhc3Nlcy5CR19GT0NVU0VEKTsgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBXZSBjb21wdXRlIHRoaXMgcHJvcGVydHkgc28gdGhhdCB3ZSBhcmUgbm90IHF1ZXJ5aW5nIGluZm9ybWF0aW9uIGFib3V0IHRoZSBjbGllbnRcbiAgICAgKiB1bnRpbCB0aGUgcG9pbnQgaW4gdGltZSB3aGVyZSB0aGUgZm91bmRhdGlvbiByZXF1ZXN0cyBpdC4gVGhpcyBwcmV2ZW50cyBzY2VuYXJpb3Mgd2hlcmVcbiAgICAgKiBjbGllbnQtc2lkZSBmZWF0dXJlLWRldGVjdGlvbiBtYXkgaGFwcGVuIHRvbyBlYXJseSwgc3VjaCBhcyB3aGVuIGNvbXBvbmVudHMgYXJlIHJlbmRlcmVkIG9uIHRoZSBzZXJ2ZXJcbiAgICAgKiBhbmQgdGhlbiBpbml0aWFsaXplZCBhdCBtb3VudCB0aW1lIG9uIHRoZSBjbGllbnQuXG4gICAgICovXG4gICAgTURDUmlwcGxlRm91bmRhdGlvbi5wcm90b3R5cGUuc3VwcG9ydHNQcmVzc1JpcHBsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWRhcHRlci5icm93c2VyU3VwcG9ydHNDc3NWYXJzKCk7XG4gICAgfTtcbiAgICBNRENSaXBwbGVGb3VuZGF0aW9uLnByb3RvdHlwZS5kZWZhdWx0QWN0aXZhdGlvblN0YXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYWN0aXZhdGlvbkV2ZW50OiB1bmRlZmluZWQsXG4gICAgICAgICAgICBoYXNEZWFjdGl2YXRpb25VWFJ1bjogZmFsc2UsXG4gICAgICAgICAgICBpc0FjdGl2YXRlZDogZmFsc2UsXG4gICAgICAgICAgICBpc1Byb2dyYW1tYXRpYzogZmFsc2UsXG4gICAgICAgICAgICB3YXNBY3RpdmF0ZWRCeVBvaW50ZXI6IGZhbHNlLFxuICAgICAgICAgICAgd2FzRWxlbWVudE1hZGVBY3RpdmU6IGZhbHNlLFxuICAgICAgICB9O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogc3VwcG9ydHNQcmVzc1JpcHBsZSBQYXNzZWQgZnJvbSBpbml0IHRvIHNhdmUgYSByZWR1bmRhbnQgZnVuY3Rpb24gY2FsbFxuICAgICAqL1xuICAgIE1EQ1JpcHBsZUZvdW5kYXRpb24ucHJvdG90eXBlLnJlZ2lzdGVyUm9vdEhhbmRsZXJzID0gZnVuY3Rpb24gKHN1cHBvcnRzUHJlc3NSaXBwbGUpIHtcbiAgICAgICAgdmFyIGVfMSwgX2E7XG4gICAgICAgIGlmIChzdXBwb3J0c1ByZXNzUmlwcGxlKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIEFDVElWQVRJT05fRVZFTlRfVFlQRVNfMSA9IF9fdmFsdWVzKEFDVElWQVRJT05fRVZFTlRfVFlQRVMpLCBBQ1RJVkFUSU9OX0VWRU5UX1RZUEVTXzFfMSA9IEFDVElWQVRJT05fRVZFTlRfVFlQRVNfMS5uZXh0KCk7ICFBQ1RJVkFUSU9OX0VWRU5UX1RZUEVTXzFfMS5kb25lOyBBQ1RJVkFUSU9OX0VWRU5UX1RZUEVTXzFfMSA9IEFDVElWQVRJT05fRVZFTlRfVFlQRVNfMS5uZXh0KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGV2dFR5cGUgPSBBQ1RJVkFUSU9OX0VWRU5UX1RZUEVTXzFfMS52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGFwdGVyLnJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyKGV2dFR5cGUsIHRoaXMuYWN0aXZhdGVIYW5kbGVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZV8xXzEpIHsgZV8xID0geyBlcnJvcjogZV8xXzEgfTsgfVxuICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKEFDVElWQVRJT05fRVZFTlRfVFlQRVNfMV8xICYmICFBQ1RJVkFUSU9OX0VWRU5UX1RZUEVTXzFfMS5kb25lICYmIChfYSA9IEFDVElWQVRJT05fRVZFTlRfVFlQRVNfMS5yZXR1cm4pKSBfYS5jYWxsKEFDVElWQVRJT05fRVZFTlRfVFlQRVNfMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZV8xKSB0aHJvdyBlXzEuZXJyb3I7IH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmFkYXB0ZXIuaXNVbmJvdW5kZWQoKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuYWRhcHRlci5yZWdpc3RlclJlc2l6ZUhhbmRsZXIodGhpcy5yZXNpemVIYW5kbGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFkYXB0ZXIucmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXIoJ2ZvY3VzJywgdGhpcy5mb2N1c0hhbmRsZXIpO1xuICAgICAgICB0aGlzLmFkYXB0ZXIucmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXIoJ2JsdXInLCB0aGlzLmJsdXJIYW5kbGVyKTtcbiAgICB9O1xuICAgIE1EQ1JpcHBsZUZvdW5kYXRpb24ucHJvdG90eXBlLnJlZ2lzdGVyRGVhY3RpdmF0aW9uSGFuZGxlcnMgPSBmdW5jdGlvbiAoZXZ0KSB7XG4gICAgICAgIHZhciBlXzIsIF9hO1xuICAgICAgICBpZiAoZXZ0LnR5cGUgPT09ICdrZXlkb3duJykge1xuICAgICAgICAgICAgdGhpcy5hZGFwdGVyLnJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyKCdrZXl1cCcsIHRoaXMuZGVhY3RpdmF0ZUhhbmRsZXIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBQT0lOVEVSX0RFQUNUSVZBVElPTl9FVkVOVF9UWVBFU18xID0gX192YWx1ZXMoUE9JTlRFUl9ERUFDVElWQVRJT05fRVZFTlRfVFlQRVMpLCBQT0lOVEVSX0RFQUNUSVZBVElPTl9FVkVOVF9UWVBFU18xXzEgPSBQT0lOVEVSX0RFQUNUSVZBVElPTl9FVkVOVF9UWVBFU18xLm5leHQoKTsgIVBPSU5URVJfREVBQ1RJVkFUSU9OX0VWRU5UX1RZUEVTXzFfMS5kb25lOyBQT0lOVEVSX0RFQUNUSVZBVElPTl9FVkVOVF9UWVBFU18xXzEgPSBQT0lOVEVSX0RFQUNUSVZBVElPTl9FVkVOVF9UWVBFU18xLm5leHQoKSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZXZ0VHlwZSA9IFBPSU5URVJfREVBQ1RJVkFUSU9OX0VWRU5UX1RZUEVTXzFfMS52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGFwdGVyLnJlZ2lzdGVyRG9jdW1lbnRJbnRlcmFjdGlvbkhhbmRsZXIoZXZ0VHlwZSwgdGhpcy5kZWFjdGl2YXRlSGFuZGxlcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVfMl8xKSB7IGVfMiA9IHsgZXJyb3I6IGVfMl8xIH07IH1cbiAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChQT0lOVEVSX0RFQUNUSVZBVElPTl9FVkVOVF9UWVBFU18xXzEgJiYgIVBPSU5URVJfREVBQ1RJVkFUSU9OX0VWRU5UX1RZUEVTXzFfMS5kb25lICYmIChfYSA9IFBPSU5URVJfREVBQ1RJVkFUSU9OX0VWRU5UX1RZUEVTXzEucmV0dXJuKSkgX2EuY2FsbChQT0lOVEVSX0RFQUNUSVZBVElPTl9FVkVOVF9UWVBFU18xKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZmluYWxseSB7IGlmIChlXzIpIHRocm93IGVfMi5lcnJvcjsgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBNRENSaXBwbGVGb3VuZGF0aW9uLnByb3RvdHlwZS5kZXJlZ2lzdGVyUm9vdEhhbmRsZXJzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZV8zLCBfYTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZvciAodmFyIEFDVElWQVRJT05fRVZFTlRfVFlQRVNfMiA9IF9fdmFsdWVzKEFDVElWQVRJT05fRVZFTlRfVFlQRVMpLCBBQ1RJVkFUSU9OX0VWRU5UX1RZUEVTXzJfMSA9IEFDVElWQVRJT05fRVZFTlRfVFlQRVNfMi5uZXh0KCk7ICFBQ1RJVkFUSU9OX0VWRU5UX1RZUEVTXzJfMS5kb25lOyBBQ1RJVkFUSU9OX0VWRU5UX1RZUEVTXzJfMSA9IEFDVElWQVRJT05fRVZFTlRfVFlQRVNfMi5uZXh0KCkpIHtcbiAgICAgICAgICAgICAgICB2YXIgZXZ0VHlwZSA9IEFDVElWQVRJT05fRVZFTlRfVFlQRVNfMl8xLnZhbHVlO1xuICAgICAgICAgICAgICAgIHRoaXMuYWRhcHRlci5kZXJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyKGV2dFR5cGUsIHRoaXMuYWN0aXZhdGVIYW5kbGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZV8zXzEpIHsgZV8zID0geyBlcnJvcjogZV8zXzEgfTsgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaWYgKEFDVElWQVRJT05fRVZFTlRfVFlQRVNfMl8xICYmICFBQ1RJVkFUSU9OX0VWRU5UX1RZUEVTXzJfMS5kb25lICYmIChfYSA9IEFDVElWQVRJT05fRVZFTlRfVFlQRVNfMi5yZXR1cm4pKSBfYS5jYWxsKEFDVElWQVRJT05fRVZFTlRfVFlQRVNfMik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaW5hbGx5IHsgaWYgKGVfMykgdGhyb3cgZV8zLmVycm9yOyB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hZGFwdGVyLmRlcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXIoJ2ZvY3VzJywgdGhpcy5mb2N1c0hhbmRsZXIpO1xuICAgICAgICB0aGlzLmFkYXB0ZXIuZGVyZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcignYmx1cicsIHRoaXMuYmx1ckhhbmRsZXIpO1xuICAgICAgICBpZiAodGhpcy5hZGFwdGVyLmlzVW5ib3VuZGVkKCkpIHtcbiAgICAgICAgICAgIHRoaXMuYWRhcHRlci5kZXJlZ2lzdGVyUmVzaXplSGFuZGxlcih0aGlzLnJlc2l6ZUhhbmRsZXIpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBNRENSaXBwbGVGb3VuZGF0aW9uLnByb3RvdHlwZS5kZXJlZ2lzdGVyRGVhY3RpdmF0aW9uSGFuZGxlcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBlXzQsIF9hO1xuICAgICAgICB0aGlzLmFkYXB0ZXIuZGVyZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcigna2V5dXAnLCB0aGlzLmRlYWN0aXZhdGVIYW5kbGVyKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZvciAodmFyIFBPSU5URVJfREVBQ1RJVkFUSU9OX0VWRU5UX1RZUEVTXzIgPSBfX3ZhbHVlcyhQT0lOVEVSX0RFQUNUSVZBVElPTl9FVkVOVF9UWVBFUyksIFBPSU5URVJfREVBQ1RJVkFUSU9OX0VWRU5UX1RZUEVTXzJfMSA9IFBPSU5URVJfREVBQ1RJVkFUSU9OX0VWRU5UX1RZUEVTXzIubmV4dCgpOyAhUE9JTlRFUl9ERUFDVElWQVRJT05fRVZFTlRfVFlQRVNfMl8xLmRvbmU7IFBPSU5URVJfREVBQ1RJVkFUSU9OX0VWRU5UX1RZUEVTXzJfMSA9IFBPSU5URVJfREVBQ1RJVkFUSU9OX0VWRU5UX1RZUEVTXzIubmV4dCgpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGV2dFR5cGUgPSBQT0lOVEVSX0RFQUNUSVZBVElPTl9FVkVOVF9UWVBFU18yXzEudmFsdWU7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGFwdGVyLmRlcmVnaXN0ZXJEb2N1bWVudEludGVyYWN0aW9uSGFuZGxlcihldnRUeXBlLCB0aGlzLmRlYWN0aXZhdGVIYW5kbGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZV80XzEpIHsgZV80ID0geyBlcnJvcjogZV80XzEgfTsgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaWYgKFBPSU5URVJfREVBQ1RJVkFUSU9OX0VWRU5UX1RZUEVTXzJfMSAmJiAhUE9JTlRFUl9ERUFDVElWQVRJT05fRVZFTlRfVFlQRVNfMl8xLmRvbmUgJiYgKF9hID0gUE9JTlRFUl9ERUFDVElWQVRJT05fRVZFTlRfVFlQRVNfMi5yZXR1cm4pKSBfYS5jYWxsKFBPSU5URVJfREVBQ1RJVkFUSU9OX0VWRU5UX1RZUEVTXzIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmluYWxseSB7IGlmIChlXzQpIHRocm93IGVfNC5lcnJvcjsgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBNRENSaXBwbGVGb3VuZGF0aW9uLnByb3RvdHlwZS5yZW1vdmVDc3NWYXJzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgcmlwcGxlU3RyaW5ncyA9IE1EQ1JpcHBsZUZvdW5kYXRpb24uc3RyaW5ncztcbiAgICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhyaXBwbGVTdHJpbmdzKTtcbiAgICAgICAga2V5cy5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgIGlmIChrZXkuaW5kZXhPZignVkFSXycpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuYWRhcHRlci51cGRhdGVDc3NWYXJpYWJsZShyaXBwbGVTdHJpbmdzW2tleV0sIG51bGwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIE1EQ1JpcHBsZUZvdW5kYXRpb24ucHJvdG90eXBlLmFjdGl2YXRlSW1wbCA9IGZ1bmN0aW9uIChldnQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKHRoaXMuYWRhcHRlci5pc1N1cmZhY2VEaXNhYmxlZCgpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGFjdGl2YXRpb25TdGF0ZSA9IHRoaXMuYWN0aXZhdGlvblN0YXRlO1xuICAgICAgICBpZiAoYWN0aXZhdGlvblN0YXRlLmlzQWN0aXZhdGVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gQXZvaWQgcmVhY3RpbmcgdG8gZm9sbG93LW9uIGV2ZW50cyBmaXJlZCBieSB0b3VjaCBkZXZpY2UgYWZ0ZXIgYW4gYWxyZWFkeS1wcm9jZXNzZWQgdXNlciBpbnRlcmFjdGlvblxuICAgICAgICB2YXIgcHJldmlvdXNBY3RpdmF0aW9uRXZlbnQgPSB0aGlzLnByZXZpb3VzQWN0aXZhdGlvbkV2ZW50O1xuICAgICAgICB2YXIgaXNTYW1lSW50ZXJhY3Rpb24gPSBwcmV2aW91c0FjdGl2YXRpb25FdmVudCAmJiBldnQgIT09IHVuZGVmaW5lZCAmJiBwcmV2aW91c0FjdGl2YXRpb25FdmVudC50eXBlICE9PSBldnQudHlwZTtcbiAgICAgICAgaWYgKGlzU2FtZUludGVyYWN0aW9uKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgYWN0aXZhdGlvblN0YXRlLmlzQWN0aXZhdGVkID0gdHJ1ZTtcbiAgICAgICAgYWN0aXZhdGlvblN0YXRlLmlzUHJvZ3JhbW1hdGljID0gZXZ0ID09PSB1bmRlZmluZWQ7XG4gICAgICAgIGFjdGl2YXRpb25TdGF0ZS5hY3RpdmF0aW9uRXZlbnQgPSBldnQ7XG4gICAgICAgIGFjdGl2YXRpb25TdGF0ZS53YXNBY3RpdmF0ZWRCeVBvaW50ZXIgPSBhY3RpdmF0aW9uU3RhdGUuaXNQcm9ncmFtbWF0aWMgPyBmYWxzZSA6IGV2dCAhPT0gdW5kZWZpbmVkICYmIChldnQudHlwZSA9PT0gJ21vdXNlZG93bicgfHwgZXZ0LnR5cGUgPT09ICd0b3VjaHN0YXJ0JyB8fCBldnQudHlwZSA9PT0gJ3BvaW50ZXJkb3duJyk7XG4gICAgICAgIHZhciBoYXNBY3RpdmF0ZWRDaGlsZCA9IGV2dCAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICBhY3RpdmF0ZWRUYXJnZXRzLmxlbmd0aCA+IDAgJiZcbiAgICAgICAgICAgIGFjdGl2YXRlZFRhcmdldHMuc29tZShmdW5jdGlvbiAodGFyZ2V0KSB7IHJldHVybiBfdGhpcy5hZGFwdGVyLmNvbnRhaW5zRXZlbnRUYXJnZXQodGFyZ2V0KTsgfSk7XG4gICAgICAgIGlmIChoYXNBY3RpdmF0ZWRDaGlsZCkge1xuICAgICAgICAgICAgLy8gSW1tZWRpYXRlbHkgcmVzZXQgYWN0aXZhdGlvbiBzdGF0ZSwgd2hpbGUgcHJlc2VydmluZyBsb2dpYyB0aGF0IHByZXZlbnRzIHRvdWNoIGZvbGxvdy1vbiBldmVudHNcbiAgICAgICAgICAgIHRoaXMucmVzZXRBY3RpdmF0aW9uU3RhdGUoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXZ0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGFjdGl2YXRlZFRhcmdldHMucHVzaChldnQudGFyZ2V0KTtcbiAgICAgICAgICAgIHRoaXMucmVnaXN0ZXJEZWFjdGl2YXRpb25IYW5kbGVycyhldnQpO1xuICAgICAgICB9XG4gICAgICAgIGFjdGl2YXRpb25TdGF0ZS53YXNFbGVtZW50TWFkZUFjdGl2ZSA9IHRoaXMuY2hlY2tFbGVtZW50TWFkZUFjdGl2ZShldnQpO1xuICAgICAgICBpZiAoYWN0aXZhdGlvblN0YXRlLndhc0VsZW1lbnRNYWRlQWN0aXZlKSB7XG4gICAgICAgICAgICB0aGlzLmFuaW1hdGVBY3RpdmF0aW9uKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8vIFJlc2V0IGFycmF5IG9uIG5leHQgZnJhbWUgYWZ0ZXIgdGhlIGN1cnJlbnQgZXZlbnQgaGFzIGhhZCBhIGNoYW5jZSB0byBidWJibGUgdG8gcHJldmVudCBhbmNlc3RvciByaXBwbGVzXG4gICAgICAgICAgICBhY3RpdmF0ZWRUYXJnZXRzID0gW107XG4gICAgICAgICAgICBpZiAoIWFjdGl2YXRpb25TdGF0ZS53YXNFbGVtZW50TWFkZUFjdGl2ZVxuICAgICAgICAgICAgICAgICYmIGV2dCAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgJiYgKGV2dC5rZXkgPT09ICcgJyB8fCBldnQua2V5Q29kZSA9PT0gMzIpKSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgc3BhY2Ugd2FzIHByZXNzZWQsIHRyeSBhZ2FpbiB3aXRoaW4gYW4gckFGIGNhbGwgdG8gZGV0ZWN0IDphY3RpdmUsIGJlY2F1c2UgZGlmZmVyZW50IFVBcyByZXBvcnRcbiAgICAgICAgICAgICAgICAvLyBhY3RpdmUgc3RhdGVzIGluY29uc2lzdGVudGx5IHdoZW4gdGhleSdyZSBjYWxsZWQgd2l0aGluIGV2ZW50IGhhbmRsaW5nIGNvZGU6XG4gICAgICAgICAgICAgICAgLy8gLSBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD02MzU5NzFcbiAgICAgICAgICAgICAgICAvLyAtIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTEyOTM3NDFcbiAgICAgICAgICAgICAgICAvLyBXZSB0cnkgZmlyc3Qgb3V0c2lkZSByQUYgdG8gc3VwcG9ydCBFZGdlLCB3aGljaCBkb2VzIG5vdCBleGhpYml0IHRoaXMgcHJvYmxlbSwgYnV0IHdpbGwgY3Jhc2ggaWYgYSBDU1NcbiAgICAgICAgICAgICAgICAvLyB2YXJpYWJsZSBpcyBzZXQgd2l0aGluIGEgckFGIGNhbGxiYWNrIGZvciBhIHN1Ym1pdCBidXR0b24gaW50ZXJhY3Rpb24gKCMyMjQxKS5cbiAgICAgICAgICAgICAgICBhY3RpdmF0aW9uU3RhdGUud2FzRWxlbWVudE1hZGVBY3RpdmUgPSBfdGhpcy5jaGVja0VsZW1lbnRNYWRlQWN0aXZlKGV2dCk7XG4gICAgICAgICAgICAgICAgaWYgKGFjdGl2YXRpb25TdGF0ZS53YXNFbGVtZW50TWFkZUFjdGl2ZSkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5hbmltYXRlQWN0aXZhdGlvbigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghYWN0aXZhdGlvblN0YXRlLndhc0VsZW1lbnRNYWRlQWN0aXZlKSB7XG4gICAgICAgICAgICAgICAgLy8gUmVzZXQgYWN0aXZhdGlvbiBzdGF0ZSBpbW1lZGlhdGVseSBpZiBlbGVtZW50IHdhcyBub3QgbWFkZSBhY3RpdmUuXG4gICAgICAgICAgICAgICAgX3RoaXMuYWN0aXZhdGlvblN0YXRlID0gX3RoaXMuZGVmYXVsdEFjdGl2YXRpb25TdGF0ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIE1EQ1JpcHBsZUZvdW5kYXRpb24ucHJvdG90eXBlLmNoZWNrRWxlbWVudE1hZGVBY3RpdmUgPSBmdW5jdGlvbiAoZXZ0KSB7XG4gICAgICAgIHJldHVybiAoZXZ0ICE9PSB1bmRlZmluZWQgJiYgZXZ0LnR5cGUgPT09ICdrZXlkb3duJykgP1xuICAgICAgICAgICAgdGhpcy5hZGFwdGVyLmlzU3VyZmFjZUFjdGl2ZSgpIDpcbiAgICAgICAgICAgIHRydWU7XG4gICAgfTtcbiAgICBNRENSaXBwbGVGb3VuZGF0aW9uLnByb3RvdHlwZS5hbmltYXRlQWN0aXZhdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIF9hID0gTURDUmlwcGxlRm91bmRhdGlvbi5zdHJpbmdzLCBWQVJfRkdfVFJBTlNMQVRFX1NUQVJUID0gX2EuVkFSX0ZHX1RSQU5TTEFURV9TVEFSVCwgVkFSX0ZHX1RSQU5TTEFURV9FTkQgPSBfYS5WQVJfRkdfVFJBTlNMQVRFX0VORDtcbiAgICAgICAgdmFyIF9iID0gTURDUmlwcGxlRm91bmRhdGlvbi5jc3NDbGFzc2VzLCBGR19ERUFDVElWQVRJT04gPSBfYi5GR19ERUFDVElWQVRJT04sIEZHX0FDVElWQVRJT04gPSBfYi5GR19BQ1RJVkFUSU9OO1xuICAgICAgICB2YXIgREVBQ1RJVkFUSU9OX1RJTUVPVVRfTVMgPSBNRENSaXBwbGVGb3VuZGF0aW9uLm51bWJlcnMuREVBQ1RJVkFUSU9OX1RJTUVPVVRfTVM7XG4gICAgICAgIHRoaXMubGF5b3V0SW50ZXJuYWwoKTtcbiAgICAgICAgdmFyIHRyYW5zbGF0ZVN0YXJ0ID0gJyc7XG4gICAgICAgIHZhciB0cmFuc2xhdGVFbmQgPSAnJztcbiAgICAgICAgaWYgKCF0aGlzLmFkYXB0ZXIuaXNVbmJvdW5kZWQoKSkge1xuICAgICAgICAgICAgdmFyIF9jID0gdGhpcy5nZXRGZ1RyYW5zbGF0aW9uQ29vcmRpbmF0ZXMoKSwgc3RhcnRQb2ludCA9IF9jLnN0YXJ0UG9pbnQsIGVuZFBvaW50ID0gX2MuZW5kUG9pbnQ7XG4gICAgICAgICAgICB0cmFuc2xhdGVTdGFydCA9IHN0YXJ0UG9pbnQueCArIFwicHgsIFwiICsgc3RhcnRQb2ludC55ICsgXCJweFwiO1xuICAgICAgICAgICAgdHJhbnNsYXRlRW5kID0gZW5kUG9pbnQueCArIFwicHgsIFwiICsgZW5kUG9pbnQueSArIFwicHhcIjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFkYXB0ZXIudXBkYXRlQ3NzVmFyaWFibGUoVkFSX0ZHX1RSQU5TTEFURV9TVEFSVCwgdHJhbnNsYXRlU3RhcnQpO1xuICAgICAgICB0aGlzLmFkYXB0ZXIudXBkYXRlQ3NzVmFyaWFibGUoVkFSX0ZHX1RSQU5TTEFURV9FTkQsIHRyYW5zbGF0ZUVuZCk7XG4gICAgICAgIC8vIENhbmNlbCBhbnkgb25nb2luZyBhY3RpdmF0aW9uL2RlYWN0aXZhdGlvbiBhbmltYXRpb25zXG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLmFjdGl2YXRpb25UaW1lcik7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLmZnRGVhY3RpdmF0aW9uUmVtb3ZhbFRpbWVyKTtcbiAgICAgICAgdGhpcy5ybUJvdW5kZWRBY3RpdmF0aW9uQ2xhc3NlcygpO1xuICAgICAgICB0aGlzLmFkYXB0ZXIucmVtb3ZlQ2xhc3MoRkdfREVBQ1RJVkFUSU9OKTtcbiAgICAgICAgLy8gRm9yY2UgbGF5b3V0IGluIG9yZGVyIHRvIHJlLXRyaWdnZXIgdGhlIGFuaW1hdGlvbi5cbiAgICAgICAgdGhpcy5hZGFwdGVyLmNvbXB1dGVCb3VuZGluZ1JlY3QoKTtcbiAgICAgICAgdGhpcy5hZGFwdGVyLmFkZENsYXNzKEZHX0FDVElWQVRJT04pO1xuICAgICAgICB0aGlzLmFjdGl2YXRpb25UaW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMuYWN0aXZhdGlvblRpbWVyQ2FsbGJhY2soKTtcbiAgICAgICAgfSwgREVBQ1RJVkFUSU9OX1RJTUVPVVRfTVMpO1xuICAgIH07XG4gICAgTURDUmlwcGxlRm91bmRhdGlvbi5wcm90b3R5cGUuZ2V0RmdUcmFuc2xhdGlvbkNvb3JkaW5hdGVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX2EgPSB0aGlzLmFjdGl2YXRpb25TdGF0ZSwgYWN0aXZhdGlvbkV2ZW50ID0gX2EuYWN0aXZhdGlvbkV2ZW50LCB3YXNBY3RpdmF0ZWRCeVBvaW50ZXIgPSBfYS53YXNBY3RpdmF0ZWRCeVBvaW50ZXI7XG4gICAgICAgIHZhciBzdGFydFBvaW50O1xuICAgICAgICBpZiAod2FzQWN0aXZhdGVkQnlQb2ludGVyKSB7XG4gICAgICAgICAgICBzdGFydFBvaW50ID0gZ2V0Tm9ybWFsaXplZEV2ZW50Q29vcmRzKGFjdGl2YXRpb25FdmVudCwgdGhpcy5hZGFwdGVyLmdldFdpbmRvd1BhZ2VPZmZzZXQoKSwgdGhpcy5hZGFwdGVyLmNvbXB1dGVCb3VuZGluZ1JlY3QoKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzdGFydFBvaW50ID0ge1xuICAgICAgICAgICAgICAgIHg6IHRoaXMuZnJhbWUud2lkdGggLyAyLFxuICAgICAgICAgICAgICAgIHk6IHRoaXMuZnJhbWUuaGVpZ2h0IC8gMixcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ2VudGVyIHRoZSBlbGVtZW50IGFyb3VuZCB0aGUgc3RhcnQgcG9pbnQuXG4gICAgICAgIHN0YXJ0UG9pbnQgPSB7XG4gICAgICAgICAgICB4OiBzdGFydFBvaW50LnggLSAodGhpcy5pbml0aWFsU2l6ZSAvIDIpLFxuICAgICAgICAgICAgeTogc3RhcnRQb2ludC55IC0gKHRoaXMuaW5pdGlhbFNpemUgLyAyKSxcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGVuZFBvaW50ID0ge1xuICAgICAgICAgICAgeDogKHRoaXMuZnJhbWUud2lkdGggLyAyKSAtICh0aGlzLmluaXRpYWxTaXplIC8gMiksXG4gICAgICAgICAgICB5OiAodGhpcy5mcmFtZS5oZWlnaHQgLyAyKSAtICh0aGlzLmluaXRpYWxTaXplIC8gMiksXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB7IHN0YXJ0UG9pbnQ6IHN0YXJ0UG9pbnQsIGVuZFBvaW50OiBlbmRQb2ludCB9O1xuICAgIH07XG4gICAgTURDUmlwcGxlRm91bmRhdGlvbi5wcm90b3R5cGUucnVuRGVhY3RpdmF0aW9uVVhMb2dpY0lmUmVhZHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIC8vIFRoaXMgbWV0aG9kIGlzIGNhbGxlZCBib3RoIHdoZW4gYSBwb2ludGluZyBkZXZpY2UgaXMgcmVsZWFzZWQsIGFuZCB3aGVuIHRoZSBhY3RpdmF0aW9uIGFuaW1hdGlvbiBlbmRzLlxuICAgICAgICAvLyBUaGUgZGVhY3RpdmF0aW9uIGFuaW1hdGlvbiBzaG91bGQgb25seSBydW4gYWZ0ZXIgYm90aCBvZiB0aG9zZSBvY2N1ci5cbiAgICAgICAgdmFyIEZHX0RFQUNUSVZBVElPTiA9IE1EQ1JpcHBsZUZvdW5kYXRpb24uY3NzQ2xhc3Nlcy5GR19ERUFDVElWQVRJT047XG4gICAgICAgIHZhciBfYSA9IHRoaXMuYWN0aXZhdGlvblN0YXRlLCBoYXNEZWFjdGl2YXRpb25VWFJ1biA9IF9hLmhhc0RlYWN0aXZhdGlvblVYUnVuLCBpc0FjdGl2YXRlZCA9IF9hLmlzQWN0aXZhdGVkO1xuICAgICAgICB2YXIgYWN0aXZhdGlvbkhhc0VuZGVkID0gaGFzRGVhY3RpdmF0aW9uVVhSdW4gfHwgIWlzQWN0aXZhdGVkO1xuICAgICAgICBpZiAoYWN0aXZhdGlvbkhhc0VuZGVkICYmIHRoaXMuYWN0aXZhdGlvbkFuaW1hdGlvbkhhc0VuZGVkKSB7XG4gICAgICAgICAgICB0aGlzLnJtQm91bmRlZEFjdGl2YXRpb25DbGFzc2VzKCk7XG4gICAgICAgICAgICB0aGlzLmFkYXB0ZXIuYWRkQ2xhc3MoRkdfREVBQ1RJVkFUSU9OKTtcbiAgICAgICAgICAgIHRoaXMuZmdEZWFjdGl2YXRpb25SZW1vdmFsVGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5hZGFwdGVyLnJlbW92ZUNsYXNzKEZHX0RFQUNUSVZBVElPTik7XG4gICAgICAgICAgICB9LCBudW1iZXJzLkZHX0RFQUNUSVZBVElPTl9NUyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE1EQ1JpcHBsZUZvdW5kYXRpb24ucHJvdG90eXBlLnJtQm91bmRlZEFjdGl2YXRpb25DbGFzc2VzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgRkdfQUNUSVZBVElPTiA9IE1EQ1JpcHBsZUZvdW5kYXRpb24uY3NzQ2xhc3Nlcy5GR19BQ1RJVkFUSU9OO1xuICAgICAgICB0aGlzLmFkYXB0ZXIucmVtb3ZlQ2xhc3MoRkdfQUNUSVZBVElPTik7XG4gICAgICAgIHRoaXMuYWN0aXZhdGlvbkFuaW1hdGlvbkhhc0VuZGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuYWRhcHRlci5jb21wdXRlQm91bmRpbmdSZWN0KCk7XG4gICAgfTtcbiAgICBNRENSaXBwbGVGb3VuZGF0aW9uLnByb3RvdHlwZS5yZXNldEFjdGl2YXRpb25TdGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5wcmV2aW91c0FjdGl2YXRpb25FdmVudCA9IHRoaXMuYWN0aXZhdGlvblN0YXRlLmFjdGl2YXRpb25FdmVudDtcbiAgICAgICAgdGhpcy5hY3RpdmF0aW9uU3RhdGUgPSB0aGlzLmRlZmF1bHRBY3RpdmF0aW9uU3RhdGUoKTtcbiAgICAgICAgLy8gVG91Y2ggZGV2aWNlcyBtYXkgZmlyZSBhZGRpdGlvbmFsIGV2ZW50cyBmb3IgdGhlIHNhbWUgaW50ZXJhY3Rpb24gd2l0aGluIGEgc2hvcnQgdGltZS5cbiAgICAgICAgLy8gU3RvcmUgdGhlIHByZXZpb3VzIGV2ZW50IHVudGlsIGl0J3Mgc2FmZSB0byBhc3N1bWUgdGhhdCBzdWJzZXF1ZW50IGV2ZW50cyBhcmUgZm9yIG5ldyBpbnRlcmFjdGlvbnMuXG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMucHJldmlvdXNBY3RpdmF0aW9uRXZlbnQgPSB1bmRlZmluZWQ7IH0sIE1EQ1JpcHBsZUZvdW5kYXRpb24ubnVtYmVycy5UQVBfREVMQVlfTVMpO1xuICAgIH07XG4gICAgTURDUmlwcGxlRm91bmRhdGlvbi5wcm90b3R5cGUuZGVhY3RpdmF0ZUltcGwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBhY3RpdmF0aW9uU3RhdGUgPSB0aGlzLmFjdGl2YXRpb25TdGF0ZTtcbiAgICAgICAgLy8gVGhpcyBjYW4gaGFwcGVuIGluIHNjZW5hcmlvcyBzdWNoIGFzIHdoZW4geW91IGhhdmUgYSBrZXl1cCBldmVudCB0aGF0IGJsdXJzIHRoZSBlbGVtZW50LlxuICAgICAgICBpZiAoIWFjdGl2YXRpb25TdGF0ZS5pc0FjdGl2YXRlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzdGF0ZSA9IF9fYXNzaWduKHt9LCBhY3RpdmF0aW9uU3RhdGUpO1xuICAgICAgICBpZiAoYWN0aXZhdGlvblN0YXRlLmlzUHJvZ3JhbW1hdGljKSB7XG4gICAgICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIF90aGlzLmFuaW1hdGVEZWFjdGl2YXRpb24oc3RhdGUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLnJlc2V0QWN0aXZhdGlvblN0YXRlKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmRlcmVnaXN0ZXJEZWFjdGl2YXRpb25IYW5kbGVycygpO1xuICAgICAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5hY3RpdmF0aW9uU3RhdGUuaGFzRGVhY3RpdmF0aW9uVVhSdW4gPSB0cnVlO1xuICAgICAgICAgICAgICAgIF90aGlzLmFuaW1hdGVEZWFjdGl2YXRpb24oc3RhdGUpO1xuICAgICAgICAgICAgICAgIF90aGlzLnJlc2V0QWN0aXZhdGlvblN0YXRlKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgTURDUmlwcGxlRm91bmRhdGlvbi5wcm90b3R5cGUuYW5pbWF0ZURlYWN0aXZhdGlvbiA9IGZ1bmN0aW9uIChfYSkge1xuICAgICAgICB2YXIgd2FzQWN0aXZhdGVkQnlQb2ludGVyID0gX2Eud2FzQWN0aXZhdGVkQnlQb2ludGVyLCB3YXNFbGVtZW50TWFkZUFjdGl2ZSA9IF9hLndhc0VsZW1lbnRNYWRlQWN0aXZlO1xuICAgICAgICBpZiAod2FzQWN0aXZhdGVkQnlQb2ludGVyIHx8IHdhc0VsZW1lbnRNYWRlQWN0aXZlKSB7XG4gICAgICAgICAgICB0aGlzLnJ1bkRlYWN0aXZhdGlvblVYTG9naWNJZlJlYWR5KCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE1EQ1JpcHBsZUZvdW5kYXRpb24ucHJvdG90eXBlLmxheW91dEludGVybmFsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLmZyYW1lID0gdGhpcy5hZGFwdGVyLmNvbXB1dGVCb3VuZGluZ1JlY3QoKTtcbiAgICAgICAgdmFyIG1heERpbSA9IE1hdGgubWF4KHRoaXMuZnJhbWUuaGVpZ2h0LCB0aGlzLmZyYW1lLndpZHRoKTtcbiAgICAgICAgLy8gU3VyZmFjZSBkaWFtZXRlciBpcyB0cmVhdGVkIGRpZmZlcmVudGx5IGZvciB1bmJvdW5kZWQgdnMuIGJvdW5kZWQgcmlwcGxlcy5cbiAgICAgICAgLy8gVW5ib3VuZGVkIHJpcHBsZSBkaWFtZXRlciBpcyBjYWxjdWxhdGVkIHNtYWxsZXIgc2luY2UgdGhlIHN1cmZhY2UgaXMgZXhwZWN0ZWQgdG8gYWxyZWFkeSBiZSBwYWRkZWQgYXBwcm9wcmlhdGVseVxuICAgICAgICAvLyB0byBleHRlbmQgdGhlIGhpdGJveCwgYW5kIHRoZSByaXBwbGUgaXMgZXhwZWN0ZWQgdG8gbWVldCB0aGUgZWRnZXMgb2YgdGhlIHBhZGRlZCBoaXRib3ggKHdoaWNoIGlzIHR5cGljYWxseVxuICAgICAgICAvLyBzcXVhcmUpLiBCb3VuZGVkIHJpcHBsZXMsIG9uIHRoZSBvdGhlciBoYW5kLCBhcmUgZnVsbHkgZXhwZWN0ZWQgdG8gZXhwYW5kIGJleW9uZCB0aGUgc3VyZmFjZSdzIGxvbmdlc3QgZGlhbWV0ZXJcbiAgICAgICAgLy8gKGNhbGN1bGF0ZWQgYmFzZWQgb24gdGhlIGRpYWdvbmFsIHBsdXMgYSBjb25zdGFudCBwYWRkaW5nKSwgYW5kIGFyZSBjbGlwcGVkIGF0IHRoZSBzdXJmYWNlJ3MgYm9yZGVyIHZpYVxuICAgICAgICAvLyBgb3ZlcmZsb3c6IGhpZGRlbmAuXG4gICAgICAgIHZhciBnZXRCb3VuZGVkUmFkaXVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGh5cG90ZW51c2UgPSBNYXRoLnNxcnQoTWF0aC5wb3coX3RoaXMuZnJhbWUud2lkdGgsIDIpICsgTWF0aC5wb3coX3RoaXMuZnJhbWUuaGVpZ2h0LCAyKSk7XG4gICAgICAgICAgICByZXR1cm4gaHlwb3RlbnVzZSArIE1EQ1JpcHBsZUZvdW5kYXRpb24ubnVtYmVycy5QQURESU5HO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLm1heFJhZGl1cyA9IHRoaXMuYWRhcHRlci5pc1VuYm91bmRlZCgpID8gbWF4RGltIDogZ2V0Qm91bmRlZFJhZGl1cygpO1xuICAgICAgICAvLyBSaXBwbGUgaXMgc2l6ZWQgYXMgYSBmcmFjdGlvbiBvZiB0aGUgbGFyZ2VzdCBkaW1lbnNpb24gb2YgdGhlIHN1cmZhY2UsIHRoZW4gc2NhbGVzIHVwIHVzaW5nIGEgQ1NTIHNjYWxlIHRyYW5zZm9ybVxuICAgICAgICB2YXIgaW5pdGlhbFNpemUgPSBNYXRoLmZsb29yKG1heERpbSAqIE1EQ1JpcHBsZUZvdW5kYXRpb24ubnVtYmVycy5JTklUSUFMX09SSUdJTl9TQ0FMRSk7XG4gICAgICAgIC8vIFVuYm91bmRlZCByaXBwbGUgc2l6ZSBzaG91bGQgYWx3YXlzIGJlIGV2ZW4gbnVtYmVyIHRvIGVxdWFsbHkgY2VudGVyIGFsaWduLlxuICAgICAgICBpZiAodGhpcy5hZGFwdGVyLmlzVW5ib3VuZGVkKCkgJiYgaW5pdGlhbFNpemUgJSAyICE9PSAwKSB7XG4gICAgICAgICAgICB0aGlzLmluaXRpYWxTaXplID0gaW5pdGlhbFNpemUgLSAxO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5pbml0aWFsU2l6ZSA9IGluaXRpYWxTaXplO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZmdTY2FsZSA9IFwiXCIgKyB0aGlzLm1heFJhZGl1cyAvIHRoaXMuaW5pdGlhbFNpemU7XG4gICAgICAgIHRoaXMudXBkYXRlTGF5b3V0Q3NzVmFycygpO1xuICAgIH07XG4gICAgTURDUmlwcGxlRm91bmRhdGlvbi5wcm90b3R5cGUudXBkYXRlTGF5b3V0Q3NzVmFycyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9hID0gTURDUmlwcGxlRm91bmRhdGlvbi5zdHJpbmdzLCBWQVJfRkdfU0laRSA9IF9hLlZBUl9GR19TSVpFLCBWQVJfTEVGVCA9IF9hLlZBUl9MRUZULCBWQVJfVE9QID0gX2EuVkFSX1RPUCwgVkFSX0ZHX1NDQUxFID0gX2EuVkFSX0ZHX1NDQUxFO1xuICAgICAgICB0aGlzLmFkYXB0ZXIudXBkYXRlQ3NzVmFyaWFibGUoVkFSX0ZHX1NJWkUsIHRoaXMuaW5pdGlhbFNpemUgKyBcInB4XCIpO1xuICAgICAgICB0aGlzLmFkYXB0ZXIudXBkYXRlQ3NzVmFyaWFibGUoVkFSX0ZHX1NDQUxFLCB0aGlzLmZnU2NhbGUpO1xuICAgICAgICBpZiAodGhpcy5hZGFwdGVyLmlzVW5ib3VuZGVkKCkpIHtcbiAgICAgICAgICAgIHRoaXMudW5ib3VuZGVkQ29vcmRzID0ge1xuICAgICAgICAgICAgICAgIGxlZnQ6IE1hdGgucm91bmQoKHRoaXMuZnJhbWUud2lkdGggLyAyKSAtICh0aGlzLmluaXRpYWxTaXplIC8gMikpLFxuICAgICAgICAgICAgICAgIHRvcDogTWF0aC5yb3VuZCgodGhpcy5mcmFtZS5oZWlnaHQgLyAyKSAtICh0aGlzLmluaXRpYWxTaXplIC8gMikpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMuYWRhcHRlci51cGRhdGVDc3NWYXJpYWJsZShWQVJfTEVGVCwgdGhpcy51bmJvdW5kZWRDb29yZHMubGVmdCArIFwicHhcIik7XG4gICAgICAgICAgICB0aGlzLmFkYXB0ZXIudXBkYXRlQ3NzVmFyaWFibGUoVkFSX1RPUCwgdGhpcy51bmJvdW5kZWRDb29yZHMudG9wICsgXCJweFwiKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIE1EQ1JpcHBsZUZvdW5kYXRpb247XG59KE1EQ0ZvdW5kYXRpb24pKTtcbmV4cG9ydCB7IE1EQ1JpcHBsZUZvdW5kYXRpb24gfTtcbi8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpuby1kZWZhdWx0LWV4cG9ydCBOZWVkZWQgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHkgd2l0aCBNREMgV2ViIHYwLjQ0LjAgYW5kIGVhcmxpZXIuXG5leHBvcnQgZGVmYXVsdCBNRENSaXBwbGVGb3VuZGF0aW9uO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Zm91bmRhdGlvbi5qcy5tYXAiLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLlxuICpcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbiAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuICogYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4gKiBUSEUgU09GVFdBUkUuXG4gKi9cbmltcG9ydCB7IF9fZXh0ZW5kcyB9IGZyb20gXCJ0c2xpYlwiO1xuaW1wb3J0IHsgTURDQ29tcG9uZW50IH0gZnJvbSAnQG1hdGVyaWFsL2Jhc2UvY29tcG9uZW50JztcbmltcG9ydCB7IGFwcGx5UGFzc2l2ZSB9IGZyb20gJ0BtYXRlcmlhbC9kb20vZXZlbnRzJztcbmltcG9ydCB7IG1hdGNoZXMgfSBmcm9tICdAbWF0ZXJpYWwvZG9tL3BvbnlmaWxsJztcbmltcG9ydCB7IE1EQ1JpcHBsZUZvdW5kYXRpb24gfSBmcm9tICcuL2ZvdW5kYXRpb24nO1xuaW1wb3J0ICogYXMgdXRpbCBmcm9tICcuL3V0aWwnO1xudmFyIE1EQ1JpcHBsZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTURDUmlwcGxlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE1EQ1JpcHBsZSgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLmRpc2FibGVkID0gZmFsc2U7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgTURDUmlwcGxlLmF0dGFjaFRvID0gZnVuY3Rpb24gKHJvb3QsIG9wdHMpIHtcbiAgICAgICAgaWYgKG9wdHMgPT09IHZvaWQgMCkgeyBvcHRzID0ge1xuICAgICAgICAgICAgaXNVbmJvdW5kZWQ6IHVuZGVmaW5lZFxuICAgICAgICB9OyB9XG4gICAgICAgIHZhciByaXBwbGUgPSBuZXcgTURDUmlwcGxlKHJvb3QpO1xuICAgICAgICAvLyBPbmx5IG92ZXJyaWRlIHVuYm91bmRlZCBiZWhhdmlvciBpZiBvcHRpb24gaXMgZXhwbGljaXRseSBzcGVjaWZpZWRcbiAgICAgICAgaWYgKG9wdHMuaXNVbmJvdW5kZWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmlwcGxlLnVuYm91bmRlZCA9IG9wdHMuaXNVbmJvdW5kZWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJpcHBsZTtcbiAgICB9O1xuICAgIE1EQ1JpcHBsZS5jcmVhdGVBZGFwdGVyID0gZnVuY3Rpb24gKGluc3RhbmNlKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBhZGRDbGFzczogZnVuY3Rpb24gKGNsYXNzTmFtZSkgeyByZXR1cm4gaW5zdGFuY2Uucm9vdC5jbGFzc0xpc3QuYWRkKGNsYXNzTmFtZSk7IH0sXG4gICAgICAgICAgICBicm93c2VyU3VwcG9ydHNDc3NWYXJzOiBmdW5jdGlvbiAoKSB7IHJldHVybiB1dGlsLnN1cHBvcnRzQ3NzVmFyaWFibGVzKHdpbmRvdyk7IH0sXG4gICAgICAgICAgICBjb21wdXRlQm91bmRpbmdSZWN0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbnN0YW5jZS5yb290LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpOyB9LFxuICAgICAgICAgICAgY29udGFpbnNFdmVudFRhcmdldDogZnVuY3Rpb24gKHRhcmdldCkgeyByZXR1cm4gaW5zdGFuY2Uucm9vdC5jb250YWlucyh0YXJnZXQpOyB9LFxuICAgICAgICAgICAgZGVyZWdpc3RlckRvY3VtZW50SW50ZXJhY3Rpb25IYW5kbGVyOiBmdW5jdGlvbiAoZXZ0VHlwZSwgaGFuZGxlcikge1xuICAgICAgICAgICAgICAgIHJldHVybiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihldnRUeXBlLCBoYW5kbGVyLCBhcHBseVBhc3NpdmUoKSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZGVyZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcjogZnVuY3Rpb24gKGV2dFR5cGUsIGhhbmRsZXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaW5zdGFuY2Uucm9vdFxuICAgICAgICAgICAgICAgICAgICAucmVtb3ZlRXZlbnRMaXN0ZW5lcihldnRUeXBlLCBoYW5kbGVyLCBhcHBseVBhc3NpdmUoKSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZGVyZWdpc3RlclJlc2l6ZUhhbmRsZXI6IGZ1bmN0aW9uIChoYW5kbGVyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdyZXNpemUnLCBoYW5kbGVyKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBnZXRXaW5kb3dQYWdlT2Zmc2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICh7IHg6IHdpbmRvdy5wYWdlWE9mZnNldCwgeTogd2luZG93LnBhZ2VZT2Zmc2V0IH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGlzU3VyZmFjZUFjdGl2ZTogZnVuY3Rpb24gKCkgeyByZXR1cm4gbWF0Y2hlcyhpbnN0YW5jZS5yb290LCAnOmFjdGl2ZScpOyB9LFxuICAgICAgICAgICAgaXNTdXJmYWNlRGlzYWJsZWQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIEJvb2xlYW4oaW5zdGFuY2UuZGlzYWJsZWQpOyB9LFxuICAgICAgICAgICAgaXNVbmJvdW5kZWQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIEJvb2xlYW4oaW5zdGFuY2UudW5ib3VuZGVkKTsgfSxcbiAgICAgICAgICAgIHJlZ2lzdGVyRG9jdW1lbnRJbnRlcmFjdGlvbkhhbmRsZXI6IGZ1bmN0aW9uIChldnRUeXBlLCBoYW5kbGVyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5hZGRFdmVudExpc3RlbmVyKGV2dFR5cGUsIGhhbmRsZXIsIGFwcGx5UGFzc2l2ZSgpKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICByZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcjogZnVuY3Rpb24gKGV2dFR5cGUsIGhhbmRsZXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaW5zdGFuY2Uucm9vdFxuICAgICAgICAgICAgICAgICAgICAuYWRkRXZlbnRMaXN0ZW5lcihldnRUeXBlLCBoYW5kbGVyLCBhcHBseVBhc3NpdmUoKSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcmVnaXN0ZXJSZXNpemVIYW5kbGVyOiBmdW5jdGlvbiAoaGFuZGxlcikge1xuICAgICAgICAgICAgICAgIHJldHVybiB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgaGFuZGxlcik7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcmVtb3ZlQ2xhc3M6IGZ1bmN0aW9uIChjbGFzc05hbWUpIHsgcmV0dXJuIGluc3RhbmNlLnJvb3QuY2xhc3NMaXN0LnJlbW92ZShjbGFzc05hbWUpOyB9LFxuICAgICAgICAgICAgdXBkYXRlQ3NzVmFyaWFibGU6IGZ1bmN0aW9uICh2YXJOYW1lLCB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpbnN0YW5jZS5yb290LnN0eWxlLnNldFByb3BlcnR5KHZhck5hbWUsIHZhbHVlKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTURDUmlwcGxlLnByb3RvdHlwZSwgXCJ1bmJvdW5kZWRcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBCb29sZWFuKHRoaXMuaXNVbmJvdW5kZWQpO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh1bmJvdW5kZWQpIHtcbiAgICAgICAgICAgIHRoaXMuaXNVbmJvdW5kZWQgPSBCb29sZWFuKHVuYm91bmRlZCk7XG4gICAgICAgICAgICB0aGlzLnNldFVuYm91bmRlZCgpO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgTURDUmlwcGxlLnByb3RvdHlwZS5hY3RpdmF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5mb3VuZGF0aW9uLmFjdGl2YXRlKCk7XG4gICAgfTtcbiAgICBNRENSaXBwbGUucHJvdG90eXBlLmRlYWN0aXZhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuZm91bmRhdGlvbi5kZWFjdGl2YXRlKCk7XG4gICAgfTtcbiAgICBNRENSaXBwbGUucHJvdG90eXBlLmxheW91dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5mb3VuZGF0aW9uLmxheW91dCgpO1xuICAgIH07XG4gICAgTURDUmlwcGxlLnByb3RvdHlwZS5nZXREZWZhdWx0Rm91bmRhdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBNRENSaXBwbGVGb3VuZGF0aW9uKE1EQ1JpcHBsZS5jcmVhdGVBZGFwdGVyKHRoaXMpKTtcbiAgICB9O1xuICAgIE1EQ1JpcHBsZS5wcm90b3R5cGUuaW5pdGlhbFN5bmNXaXRoRE9NID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcm9vdCA9IHRoaXMucm9vdDtcbiAgICAgICAgdGhpcy5pc1VuYm91bmRlZCA9ICdtZGNSaXBwbGVJc1VuYm91bmRlZCcgaW4gcm9vdC5kYXRhc2V0O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ2xvc3VyZSBDb21waWxlciB0aHJvd3MgYW4gYWNjZXNzIGNvbnRyb2wgZXJyb3Igd2hlbiBkaXJlY3RseSBhY2Nlc3NpbmcgYVxuICAgICAqIHByb3RlY3RlZCBvciBwcml2YXRlIHByb3BlcnR5IGluc2lkZSBhIGdldHRlci9zZXR0ZXIsIGxpa2UgdW5ib3VuZGVkIGFib3ZlLlxuICAgICAqIEJ5IGFjY2Vzc2luZyB0aGUgcHJvdGVjdGVkIHByb3BlcnR5IGluc2lkZSBhIG1ldGhvZCwgd2Ugc29sdmUgdGhhdCBwcm9ibGVtLlxuICAgICAqIFRoYXQncyB3aHkgdGhpcyBmdW5jdGlvbiBleGlzdHMuXG4gICAgICovXG4gICAgTURDUmlwcGxlLnByb3RvdHlwZS5zZXRVbmJvdW5kZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuZm91bmRhdGlvbi5zZXRVbmJvdW5kZWQoQm9vbGVhbih0aGlzLmlzVW5ib3VuZGVkKSk7XG4gICAgfTtcbiAgICByZXR1cm4gTURDUmlwcGxlO1xufShNRENDb21wb25lbnQpKTtcbmV4cG9ydCB7IE1EQ1JpcHBsZSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29tcG9uZW50LmpzLm1hcCIsImltcG9ydCB7IHVzZUVmZmVjdCwgdXNlUmVmIH0gZnJvbSAncmVhY3QnO1xyXG5pbXBvcnQgeyBNRENSaXBwbGUgfSBmcm9tICdAbWF0ZXJpYWwvcmlwcGxlJztcclxuaW1wb3J0IGNsYXNzbmFtZXMgZnJvbSAnY2xhc3NuYW1lcyc7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBSaXBwbGUoe1xyXG4gICAgdW5ib3VuZGVkID0gZmFsc2UsXHJcbiAgICBkaXNhYmxlZCA9IGZhbHNlLFxyXG4gICAgY2xhc3NOYW1lLFxyXG4gICAgZWxlbWVudDogRWxlbWVudCA9ICdzcGFuJyxcclxuICAgIC4uLnByb3BzXHJcbn0pIHtcclxuICAgIGNvbnN0IHJvb3RSZWYgPSB1c2VSZWYoKTtcclxuICAgIGNvbnN0IHJpcHBsZVJlZiA9IHVzZVJlZigpO1xyXG5cclxuICAgIHVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICAgICAgaWYgKGRpc2FibGVkKSByZXR1cm47XHJcblxyXG4gICAgICAgIGlmICghcmlwcGxlUmVmLmN1cnJlbnQpIHtcclxuICAgICAgICAgICAgcmlwcGxlUmVmLmN1cnJlbnQgPSBuZXcgTURDUmlwcGxlKHJvb3RSZWYuY3VycmVudC5wYXJlbnROb2RlKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJpcHBsZVJlZi5jdXJyZW50LnVuYm91bmRlZCA9IHVuYm91bmRlZDtcclxuXHJcbiAgICAgICAgcmV0dXJuICgpID0+IHJpcHBsZVJlZi5jdXJyZW50LmRlc3Ryb3koKTtcclxuICAgIH0sIFtkaXNhYmxlZCwgdW5ib3VuZGVkXSk7XHJcblxyXG4gICAgY29uc3QgY2xhc3NOYW1lcyA9IGNsYXNzbmFtZXMoY2xhc3NOYW1lKTtcclxuXHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAgIDxFbGVtZW50XHJcbiAgICAgICAgICAgIHJlZj17cm9vdFJlZn1cclxuICAgICAgICAgICAgY2xhc3NOYW1lPXtjbGFzc05hbWVzfVxyXG4gICAgICAgICAgICB7Li4ucHJvcHN9XHJcbiAgICAgICAgLz5cclxuICAgICk7XHJcbn1cclxuXHJcblJpcHBsZS5kaXNwbGF5TmFtZSA9ICdNRENSaXBwbGUnOyIsImV4cG9ydCBjb25zdCBjc3NDbGFzc2VzID0ge1xyXG4gICAgUk9PVDogJ21kYy1yaXBwbGUtdXBncmFkZWQnLFxyXG4gICAgVU5CT1VOREVEOiAnbWRjLXJpcHBsZS11cGdyYWRlZC0tdW5ib3VuZGVkJyxcclxuICAgIEJHX0ZPQ1VTRUQ6ICdtZGMtcmlwcGxlLXVwZ3JhZGVkLS1iYWNrZ3JvdW5kLWZvY3VzZWQnLFxyXG4gICAgRkdfQUNUSVZBVElPTjogJ21kYy1yaXBwbGUtdXBncmFkZWQtLWZvcmVncm91bmQtYWN0aXZhdGlvbicsXHJcbiAgICBGR19ERUFDVElWQVRJT046ICdtZGMtcmlwcGxlLXVwZ3JhZGVkLS1mb3JlZ3JvdW5kLWRlYWN0aXZhdGlvbicsXHJcblxyXG4gICAgU1VSRkFDRTogJ21kYy1yaXBwbGUtc3VyZmFjZScsXHJcbiAgICBTVVJGQUNFX1BSSU1BUlk6ICdtZGMtcmlwcGxlLXN1cmZhY2UtLXByaW1hcnknLFxyXG4gICAgU1VSRkFDRV9BQ0NFTlQ6ICdtZGMtcmlwcGxlLXN1cmZhY2UtLWFjY2VudCdcclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCBzdHJpbmdzID0ge1xyXG4gICAgVkFSX0ZHX1NDQUxFOiAnLS1tZGMtcmlwcGxlLWZnLXNjYWxlJyxcclxuICAgIFZBUl9GR19TSVpFOiAnLS1tZGMtcmlwcGxlLWZnLXNpemUnLFxyXG4gICAgVkFSX0ZHX1RSQU5TTEFURV9FTkQ6ICctLW1kYy1yaXBwbGUtZmctdHJhbnNsYXRlLWVuZCcsXHJcbiAgICBWQVJfRkdfVFJBTlNMQVRFX1NUQVJUOiAnLS1tZGMtcmlwcGxlLWZnLXRyYW5zbGF0ZS1zdGFydCcsXHJcbiAgICBWQVJfTEVGVDogJy0tbWRjLXJpcHBsZS1sZWZ0JyxcclxuICAgIFZBUl9UT1A6ICctLW1kYy1yaXBwbGUtdG9wJyxcclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCBudW1iZXJzID0ge1xyXG4gICAgREVBQ1RJVkFUSU9OX1RJTUVPVVRfTVM6IDIyNSwgLy8gQ29ycmVzcG9uZHMgdG8gJG1kYy1yaXBwbGUtdHJhbnNsYXRlLWR1cmF0aW9uIChpLmUuIGFjdGl2YXRpb24gYW5pbWF0aW9uIGR1cmF0aW9uKVxyXG4gICAgRkdfREVBQ1RJVkFUSU9OX01TOiAxNTAsIC8vIENvcnJlc3BvbmRzIHRvICRtZGMtcmlwcGxlLWZhZGUtb3V0LWR1cmF0aW9uIChpLmUuIGRlYWN0aXZhdGlvbiBhbmltYXRpb24gZHVyYXRpb24pXHJcbiAgICBJTklUSUFMX09SSUdJTl9TQ0FMRTogMC42LFxyXG4gICAgUEFERElORzogMTAsXHJcbiAgICBUQVBfREVMQVlfTVM6IDMwMCwgLy8gRGVsYXkgYmV0d2VlbiB0b3VjaCBhbmQgc2ltdWxhdGVkIG1vdXNlIGV2ZW50cyBvbiB0b3VjaCBkZXZpY2VzXHJcbn07IiwiaW1wb3J0IHsgdXNlRWZmZWN0LCB1c2VSZWYgfSBmcm9tICdyZWFjdCc7XHJcbmltcG9ydCB7IE1EQ1JpcHBsZSB9IGZyb20gJ0BtYXRlcmlhbC9yaXBwbGUnO1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIHVzZVJpcHBsZShyb290UmVmLCB1bmJvdW5kZWQgPSBmYWxzZSkge1xyXG4gICAgY29uc3QgcmlwcGxlUmVmID0gdXNlUmVmKCk7XHJcblxyXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgICAgICBpZiAoIXJpcHBsZVJlZi5jdXJyZW50KSB7XHJcbiAgICAgICAgICAgIHJpcHBsZVJlZi5jdXJyZW50ID0gbmV3IE1EQ1JpcHBsZShyb290UmVmLmN1cnJlbnQpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmlwcGxlUmVmLmN1cnJlbnQudW5ib3VuZGVkID0gdW5ib3VuZGVkO1xyXG5cclxuICAgICAgICByZXR1cm4gKCkgPT4gcmlwcGxlUmVmLmN1cnJlbnQuZGVzdHJveSgpO1xyXG4gICAgfSwgW3Jvb3RSZWYsIHVuYm91bmRlZF0pO1xyXG5cclxuICAgIHJldHVybiByaXBwbGVSZWYuY3VycmVudDtcclxufSIsImltcG9ydCB7IGZvcndhcmRSZWYsIHVzZVJlZiwgdXNlSW1wZXJhdGl2ZUhhbmRsZSB9IGZyb20gJ3JlYWN0JztcclxuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcclxuaW1wb3J0IGNsYXNzbmFtZXMgZnJvbSAnY2xhc3NuYW1lcyc7XHJcblxyXG5pbXBvcnQgeyBjc3NDbGFzc2VzIH0gZnJvbSAnLi9jb25zdGFudHMnO1xyXG5pbXBvcnQgeyB1c2VSaXBwbGUgfSBmcm9tICcuL2hvb2tzJztcclxuXHJcbmNvbnN0IFJpcHBsZVN1cmZhY2UgPSBmb3J3YXJkUmVmKCh7XHJcbiAgICBwcmltYXJ5LFxyXG4gICAgYWNjZW50LFxyXG5cclxuICAgIGNsYXNzTmFtZSxcclxuICAgIGVsZW1lbnQ6IEVsZW1lbnQgPSAnZGl2JyxcclxuICAgIC4uLnByb3BzXHJcbn0sIHJlZikgPT4ge1xyXG4gICAgY29uc3Qgcm9vdFJlZiA9IHVzZVJlZigpO1xyXG5cclxuICAgIHVzZUltcGVyYXRpdmVIYW5kbGUocmVmLCAoKSA9PiByb290UmVmLmN1cnJlbnQpO1xyXG4gICAgdXNlUmlwcGxlKHJvb3RSZWYpO1xyXG5cclxuICAgIGNvbnN0IGNsYXNzTmFtZXMgPSBjbGFzc25hbWVzKGNzc0NsYXNzZXMuU1VSRkFDRSwge1xyXG4gICAgICAgIFtjc3NDbGFzc2VzLlNVUkZBQ0VfUFJJTUFSWV06IHByaW1hcnksXHJcbiAgICAgICAgW2Nzc0NsYXNzZXMuU1VSRkFDRV9BQ0NFTlRdOiBhY2NlbnRcclxuICAgIH0sIGNsYXNzTmFtZSk7XHJcblxyXG4gICAgcmV0dXJuIChcclxuICAgICAgICA8RWxlbWVudFxyXG4gICAgICAgICAgICByZWY9e3Jvb3RSZWZ9XHJcbiAgICAgICAgICAgIGNsYXNzTmFtZT17Y2xhc3NOYW1lc31cclxuICAgICAgICAgICAgey4uLnByb3BzfVxyXG4gICAgICAgIC8+XHJcbiAgICApO1xyXG59KTtcclxuXHJcblJpcHBsZVN1cmZhY2UuZGlzcGxheU5hbWUgPSAnTURDUmlwcGxlU3VyZmFjZSc7XHJcblxyXG5SaXBwbGVTdXJmYWNlLnByb3BUeXBlcyA9IHtcclxuICAgIHByaW1hcnk6IFByb3BUeXBlcy5ib29sLFxyXG4gICAgYWNjZW50OiBQcm9wVHlwZXMuYm9vbFxyXG59O1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgUmlwcGxlU3VyZmFjZTsiLCJleHBvcnQgeyBkZWZhdWx0IGFzIFJpcHBsZSB9IGZyb20gJy4vUmlwcGxlJztcclxuZXhwb3J0IHsgZGVmYXVsdCBhcyBSaXBwbGVTdXJmYWNlIH0gZnJvbSAnLi9SaXBwbGVTdXJmYWNlJzsiLCJleHBvcnQgY29uc3QgY3NzQ2xhc3NlcyA9IHtcclxuICAgIFJPT1Q6ICdtZGMtc2VnbWVudGVkLWJ1dHRvbicsXHJcbiAgICBTSU5HTEVfU0VMRUNUOiAnbWRjLXNlZ21lbnRlZC1idXR0b24tLXNpbmdsZS1zZWxlY3QnLFxyXG5cclxuICAgIFNFR01FTlQ6ICdtZGMtc2VnbWVudGVkLWJ1dHRvbl9fc2VnbWVudCcsXHJcbiAgICBTRUdNRU5UX1NFTEVDVEVEOiAnbWRjLXNlZ21lbnRlZC1idXR0b25fX3NlZ21lbnQtLXNlbGVjdGVkJyxcclxuXHJcbiAgICBJQ09OOiAnbWRjLXNlZ21lbnRlZC1idXR0b25fX2ljb24nLFxyXG4gICAgTEFCRUw6ICdtZGMtc2VnbWVudGVkLWJ1dHRvbl9fbGFiZWwnLFxyXG4gICAgUklQUExFOiAnbWRjLXNlZ21lbnRlZC1idXR0b25fX3JpcHBsZScsXHJcbiAgICBUT1VDSDogJ21kYy1zZWdtZW50ZWQtYnV0dG9uLS10b3VjaCcsXHJcbiAgICBUT1VDSF9FTEVNRU5UOiAnbWRjLXNlZ21lbnRlZC1idXR0b25fX3RvdWNoJ1xyXG59OyIsImltcG9ydCB7IGZvcndhcmRSZWYgfSBmcm9tICdyZWFjdCc7XHJcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XHJcbmltcG9ydCBjbGFzc25hbWVzIGZyb20gJ2NsYXNzbmFtZXMnO1xyXG5cclxuaW1wb3J0IHsgQ2xvbmUgfSBmcm9tICcuLi9jb21wb25lbnQnO1xyXG5pbXBvcnQgSWNvbiBmcm9tICcuLi9pY29uJztcclxuXHJcbmltcG9ydCB7IGNzc0NsYXNzZXMgfSBmcm9tICcuL2NvbnN0YW50cyc7XHJcblxyXG5jb25zdCBTZWdtZW50ZWRCdXR0b25TZWdtZW50ID0gZm9yd2FyZFJlZigoe1xyXG4gICAgbGFiZWwsXHJcbiAgICBpY29uLFxyXG4gICAgc2VsZWN0ZWQsXHJcbiAgICB0b3VjaCxcclxuICAgIHJpcHBsZSxcclxuXHJcbiAgICBlbGVtZW50ID0gJ2J1dHRvbicsXHJcbiAgICBjb21wb25lbnQ6IEVsZW1lbnQgPSBlbGVtZW50LFxyXG4gICAgY2xhc3NOYW1lLFxyXG4gICAgY2hpbGRyZW4gPSBsYWJlbCxcclxuICAgIC4uLnByb3BzXHJcbn0sIHJlZikgPT4ge1xyXG4gICAgY29uc3QgY2xhc3NOYW1lcyA9IGNsYXNzbmFtZXMoY3NzQ2xhc3Nlcy5TRUdNRU5ULCB7XHJcbiAgICAgICAgW2Nzc0NsYXNzZXMuU0VHTUVOVF9TRUxFQ1RFRF06IHNlbGVjdGVkLFxyXG4gICAgICAgIFtjc3NDbGFzc2VzLlRPVUNIXTogdG91Y2hcclxuICAgIH0sIGNsYXNzTmFtZSk7XHJcblxyXG4gICAgcmV0dXJuIChcclxuICAgICAgICA8RWxlbWVudFxyXG4gICAgICAgICAgICByZWY9e3JlZn1cclxuICAgICAgICAgICAgY2xhc3NOYW1lPXtjbGFzc05hbWVzfVxyXG4gICAgICAgICAgICB7Li4ucHJvcHN9XHJcbiAgICAgICAgPlxyXG4gICAgICAgICAgICB7cmlwcGxlICYmXHJcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17Y3NzQ2xhc3Nlcy5SSVBQTEV9IC8+XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHt0b3VjaCAmJlxyXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9e2Nzc0NsYXNzZXMuVE9VQ0hfRUxFTUVOVH0gLz5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAge2ljb24gJiZcclxuICAgICAgICAgICAgICAgIDxDbG9uZVxyXG4gICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudD17aWNvbn1cclxuICAgICAgICAgICAgICAgICAgICBmYWxsYmFjaz17SWNvbn1cclxuICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU9e2Nzc0NsYXNzZXMuSUNPTn1cclxuICAgICAgICAgICAgICAgIC8+XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHtjaGlsZHJlbiAmJlxyXG4gICAgICAgICAgICAgICAgPHNwYW4gY2xhc3NOYW1lPXtjc3NDbGFzc2VzLkxBQkVMfT57Y2hpbGRyZW59PC9zcGFuPlxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgPC9FbGVtZW50PlxyXG4gICAgKTtcclxufSk7XHJcblxyXG5TZWdtZW50ZWRCdXR0b25TZWdtZW50LmRpc3BsYXlOYW1lID0gJ01EQ1NlZ21lbnRlZEJ1dHRvblNlZ21lbnQnO1xyXG5cclxuU2VnbWVudGVkQnV0dG9uU2VnbWVudC5wcm9wVHlwZXMgPSB7XHJcbiAgICBsYWJlbDogUHJvcFR5cGVzLnN0cmluZyxcclxuICAgIGljb246IFByb3BUeXBlcy5ub2RlLFxyXG4gICAgc2VsZWN0ZWQ6IFByb3BUeXBlcy5ib29sLFxyXG4gICAgcmlwcGxlOiBQcm9wVHlwZXMuYm9vbFxyXG59O1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgU2VnbWVudGVkQnV0dG9uU2VnbWVudDsiLCJpbXBvcnQgeyBmb3J3YXJkUmVmLCBDaGlsZHJlbiwgdXNlQ2FsbGJhY2sgfSBmcm9tICdyZWFjdCc7XHJcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XHJcbmltcG9ydCBjbGFzc25hbWVzIGZyb20gJ2NsYXNzbmFtZXMnO1xyXG5cclxuaW1wb3J0IHsgaXNVbmRlZmluZWQsIGlzQXJyYXkgfSBmcm9tICcuLi90eXBlcyc7XHJcbmltcG9ydCB7IGNyZWF0ZSwgY2xvbmUgfSBmcm9tICcuLi9jb21wb25lbnQnO1xyXG5cclxuaW1wb3J0IHsgY3NzQ2xhc3NlcyB9IGZyb20gJy4vY29uc3RhbnRzJztcclxuaW1wb3J0IFNlZ21lbnRlZEJ1dHRvblNlZ21lbnQgZnJvbSAnLi9TZWdtZW50ZWRCdXR0b25TZWdtZW50JztcclxuXHJcbmNvbnN0IFNlZ21lbnRlZEJ1dHRvbiA9IGZvcndhcmRSZWYoKHtcclxuICAgIHZhbHVlLFxyXG4gICAgc2VnbWVudHMsXHJcbiAgICBzaW5nbGVTZWxlY3QgPSAhaXNVbmRlZmluZWQodmFsdWUpICYmICFpc0FycmF5KHZhbHVlKSxcclxuICAgIHJpcHBsZSA9IHRydWUsXHJcbiAgICB0b3VjaCA9IGZhbHNlLFxyXG4gICAgb25DaGFuZ2UgPSBGdW5jdGlvbi5wcm90b3R5cGUsXHJcblxyXG4gICAgZWxlbWVudCA9ICdkaXYnLFxyXG4gICAgY29tcG9uZW50OiBFbGVtZW50ID0gZWxlbWVudCxcclxuICAgIGNsYXNzTmFtZSxcclxuICAgIGNoaWxkcmVuID0gc2VnbWVudHM/Lm1hcChzZWdtZW50ID0+IGNyZWF0ZShTZWdtZW50ZWRCdXR0b25TZWdtZW50LCBzZWdtZW50KSksXHJcbiAgICAuLi5wcm9wc1xyXG59LCByZWYpID0+IHtcclxuICAgIGNvbnN0IGhhbmRsZUNsaWNrID0gdXNlQ2FsbGJhY2soZXZlbnQgPT4ge1xyXG4gICAgICAgIGNvbnN0IHNlZ21lbnRWYWx1ZSA9IGV2ZW50LmN1cnJlbnRUYXJnZXQudmFsdWU7XHJcbiAgICAgICAgY29uc3QgbmV3VmFsdWUgPSBzaW5nbGVTZWxlY3QgPyBzZWdtZW50VmFsdWUgOlxyXG4gICAgICAgICAgICAodmFsdWUuaW5jbHVkZXMoc2VnbWVudFZhbHVlKSA/XHJcbiAgICAgICAgICAgICAgICB2YWx1ZS5maWx0ZXIodiA9PiB2ICE9PSBzZWdtZW50VmFsdWUpIDpcclxuICAgICAgICAgICAgICAgIHZhbHVlLmNvbmNhdChzZWdtZW50VmFsdWUpXHJcbiAgICAgICAgICAgICk7XHJcblxyXG4gICAgICAgIG9uQ2hhbmdlKG5ld1ZhbHVlKTtcclxuICAgIH0sIFt2YWx1ZSwgc2luZ2xlU2VsZWN0LCBvbkNoYW5nZV0pO1xyXG5cclxuICAgIGNvbnN0IGNsYXNzTmFtZXMgPSBjbGFzc25hbWVzKGNzc0NsYXNzZXMuUk9PVCwge1xyXG4gICAgICAgIFtjc3NDbGFzc2VzLlNJTkdMRV9TRUxFQ1RdOiBzaW5nbGVTZWxlY3RcclxuICAgIH0sIGNsYXNzTmFtZSk7XHJcblxyXG4gICAgcmV0dXJuIChcclxuICAgICAgICA8RWxlbWVudFxyXG4gICAgICAgICAgICByZWY9e3JlZn1cclxuICAgICAgICAgICAgY2xhc3NOYW1lPXtjbGFzc05hbWVzfVxyXG4gICAgICAgICAgICByb2xlPXtzaW5nbGVTZWxlY3QgPyAncmFkaW9ncm91cCcgOiAnZ3JvdXAnfVxyXG4gICAgICAgICAgICB7Li4ucHJvcHN9XHJcbiAgICAgICAgPlxyXG4gICAgICAgICAgICB7aXNVbmRlZmluZWQodmFsdWUpID8gY2hpbGRyZW4gOlxyXG4gICAgICAgICAgICAgICAgQ2hpbGRyZW4ubWFwKGNoaWxkcmVuLCBzZWdtZW50ID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBhcmlhUHJvcCA9IHNpbmdsZVNlbGVjdCA/ICdhcmlhLWNoZWNrZWQnIDogJ2FyaWEtcHJlc3NlZCc7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2VsZWN0ZWQgPSBzaW5nbGVTZWxlY3QgP1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9PT0gc2VnbWVudC5wcm9wcy52YWx1ZSA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlLmluY2x1ZGVzKHNlZ21lbnQucHJvcHMudmFsdWUpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2xvbmUoc2VnbWVudCwge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByaXBwbGUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvdWNoLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3RlZCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgcm9sZTogc2luZ2xlU2VsZWN0ID8gJ3JhZGlvJyA6IHVuZGVmaW5lZCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgW2FyaWFQcm9wXTogc2VsZWN0ZWQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2xpY2tDYXB0dXJlOiBoYW5kbGVDbGlja1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIDwvRWxlbWVudD5cclxuICAgICk7XHJcbn0pO1xyXG5cclxuU2VnbWVudGVkQnV0dG9uLmRpc3BsYXlOYW1lID0gJ01EQ1NlZ21lbnRlZEJ1dHRvbic7XHJcblxyXG5TZWdtZW50ZWRCdXR0b24ucHJvcFR5cGVzID0ge1xyXG4gICAgdmFsdWU6IFByb3BUeXBlcy5hbnksXHJcbiAgICBzZWdtZW50czogUHJvcFR5cGVzLmFycmF5T2YoUHJvcFR5cGVzLm9uZU9mVHlwZShbXHJcbiAgICAgICAgUHJvcFR5cGVzLm9iamVjdCxcclxuICAgICAgICBQcm9wVHlwZXMuZWxlbWVudFxyXG4gICAgXSkpLFxyXG4gICAgc2luZ2xlU2VsZWN0OiBQcm9wVHlwZXMuYm9vbCxcclxuICAgIHJpcHBsZTogUHJvcFR5cGVzLmJvb2wsXHJcbiAgICB0b3VjaDogUHJvcFR5cGVzLmJvb2wsXHJcbiAgICBvbkNoYW5nZTogUHJvcFR5cGVzLmZ1bmNcclxufTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IFNlZ21lbnRlZEJ1dHRvbjsiLCJpbXBvcnQgU2VnbWVudGVkQnV0dG9uIGZyb20gJy4vU2VnbWVudGVkQnV0dG9uJztcclxuaW1wb3J0IFNlZ21lbnRlZEJ1dHRvblNlZ21lbnQgZnJvbSAnLi9TZWdtZW50ZWRCdXR0b25TZWdtZW50JztcclxuXHJcblNlZ21lbnRlZEJ1dHRvbi5TZWdtZW50ID0gU2VnbWVudGVkQnV0dG9uU2VnbWVudDtcclxuXHJcbmV4cG9ydCB7XHJcbiAgICBTZWdtZW50ZWRCdXR0b24gYXMgZGVmYXVsdCxcclxuICAgIFNlZ21lbnRlZEJ1dHRvblNlZ21lbnRcclxufTsiLCJleHBvcnQgY29uc3QgbnVtYmVycyA9IHtcclxuICAgIEFOSU1BVElPTl9FTlRFUl9USU1FX01TOiAyNTAsXHJcbiAgICBBTklNQVRJT05fRVhJVF9USU1FX01TOiAyMDBcclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCBjc3NDbGFzc2VzID0ge1xyXG4gICAgUk9PVDogJ21kYy1zaWRlLXNoZWV0JyxcclxuICAgIERJU01JU1NJQkxFOiAnbWRjLXNpZGUtc2hlZXQtLWRpc21pc3NpYmxlJyxcclxuICAgIE1PREFMOiAnbWRjLXNpZGUtc2hlZXQtLW1vZGFsJyxcclxuICAgIE9QRU46ICdtZGMtc2lkZS1zaGVldC0tb3BlbicsXHJcbiAgICBBTklNQVRFOiAnbWRjLXNpZGUtc2hlZXQtLWFuaW1hdGUnLFxyXG4gICAgT1BFTklORzogJ21kYy1zaWRlLXNoZWV0LS1vcGVuaW5nJyxcclxuICAgIENMT1NJTkc6ICdtZGMtc2lkZS1zaGVldC0tY2xvc2luZycsXHJcblxyXG4gICAgQ09OVEVOVDogJ21kYy1zaWRlLXNoZWV0X19jb250ZW50JyxcclxuICAgIEhFQURFUjogJ21kYy1zaWRlLXNoZWV0X19oZWFkZXInLFxyXG4gICAgVElUTEU6ICdtZGMtc2lkZS1zaGVldF9fdGl0bGUnLFxyXG4gICAgQ0xPU0VfQlVUVE9OOiAnbWRjLXNpZGUtc2hlZXRfX2Nsb3NlLWJ1dHRvbicsXHJcblxyXG4gICAgQVBQX0NPTlRFTlQ6ICdtZGMtc2lkZS1zaGVldC1hcHAtY29udGVudCcsXHJcbiAgICBTQ1JJTTogJ21kYy1zaWRlLXNoZWV0LXNjcmltJyxcclxufTsiLCJpbXBvcnQgeyBmb3J3YXJkUmVmIH0gZnJvbSAncmVhY3QnO1xyXG5cclxuaW1wb3J0IHsgQ2xvbmUgfSBmcm9tICcuLi9jb21wb25lbnQnO1xyXG5pbXBvcnQgSWNvbkJ1dHRvbiBmcm9tICcuLi9pY29uLWJ1dHRvbic7XHJcblxyXG5pbXBvcnQgeyBjc3NDbGFzc2VzIH0gZnJvbSAnLi9jb25zdGFudHMnO1xyXG5cclxuY29uc3QgU2lkZVNoZWV0SGVhZGVyID0gZm9yd2FyZFJlZigoe1xyXG4gICAgdGl0bGUsXHJcbiAgICBjbG9zZUljb24sXHJcbiAgICBvbkNsb3NlLFxyXG5cclxuICAgIGVsZW1lbnQ6IEVsZW1lbnQgPSAnaGVhZGVyJyxcclxuICAgIC4uLnByb3BzXHJcbn0sIHJlZikgPT4ge1xyXG4gICAgcmV0dXJuIChcclxuICAgICAgICA8RWxlbWVudCByZWY9e3JlZn0gY2xhc3NOYW1lPXtjc3NDbGFzc2VzLkhFQURFUn0gey4uLnByb3BzfT5cclxuICAgICAgICAgICAge3RpdGxlICYmXHJcbiAgICAgICAgICAgICAgICA8Q2xvbmVcclxuICAgICAgICAgICAgICAgICAgICBjb21wb25lbnQ9e3RpdGxlfVxyXG4gICAgICAgICAgICAgICAgICAgIGZhbGxiYWNrPVwiaDNcIlxyXG4gICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT17Y3NzQ2xhc3Nlcy5USVRMRX1cclxuICAgICAgICAgICAgICAgIC8+XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHtjbG9zZUljb24gJiZcclxuICAgICAgICAgICAgICAgIDxDbG9uZVxyXG4gICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudD17Y2xvc2VJY29ufVxyXG4gICAgICAgICAgICAgICAgICAgIGZhbGxiYWNrPXtJY29uQnV0dG9ufVxyXG4gICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT17Y3NzQ2xhc3Nlcy5DTE9TRV9CVVRUT059XHJcbiAgICAgICAgICAgICAgICAgICAgb25DbGljaz17b25DbG9zZX1cclxuICAgICAgICAgICAgICAgIC8+XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICA8L0VsZW1lbnQ+XHJcbiAgICApO1xyXG59KTtcclxuXHJcblNpZGVTaGVldEhlYWRlci5kaXNwbGF5TmFtZSA9ICdNRENTaWRlU2hlZXRIZWFkZXInO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgU2lkZVNoZWV0SGVhZGVyOyIsImltcG9ydCB7IGZvcndhcmRSZWYgfSBmcm9tICdyZWFjdCc7XHJcblxyXG5pbXBvcnQgeyBjc3NDbGFzc2VzIH0gZnJvbSAnLi9jb25zdGFudHMnO1xyXG5cclxuY29uc3QgU2lkZVNoZWV0Q29udGVudCA9IGZvcndhcmRSZWYoKHsgZWxlbWVudDogRWxlbWVudCA9ICdkaXYnLCAuLi5wcm9wcyB9LCByZWYpID0+IHtcclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgPEVsZW1lbnQgcmVmPXtyZWZ9IGNsYXNzTmFtZT17Y3NzQ2xhc3Nlcy5DT05URU5UfSB7Li4ucHJvcHN9IC8+XHJcbiAgICApO1xyXG59KTtcclxuXHJcblNpZGVTaGVldENvbnRlbnQuZGlzcGxheU5hbWUgPSAnTURDU2lkZVNoZWV0Q29udGVudCc7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBTaWRlU2hlZXRDb250ZW50OyIsImltcG9ydCB7IGZvcndhcmRSZWYsIHVzZVJlZiwgdXNlSW1wZXJhdGl2ZUhhbmRsZSwgdXNlRWZmZWN0IH0gZnJvbSAncmVhY3QnO1xyXG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xyXG5pbXBvcnQgY2xhc3NuYW1lcyBmcm9tICdjbGFzc25hbWVzJztcclxuXHJcbmltcG9ydCBMYXllciBmcm9tICcuLi9sYXllcic7XHJcblxyXG5pbXBvcnQgeyBudW1iZXJzLCBjc3NDbGFzc2VzIH0gZnJvbSAnLi9jb25zdGFudHMnO1xyXG5pbXBvcnQgU2lkZVNoZWV0SGVhZGVyIGZyb20gJy4vU2lkZVNoZWV0SGVhZGVyJztcclxuaW1wb3J0IFNpZGVTaGVldENvbnRlbnQgZnJvbSAnLi9TaWRlU2hlZXRDb250ZW50JztcclxuXHJcbmNvbnN0IFNpZGVTaGVldCA9IGZvcndhcmRSZWYoKHtcclxuICAgIHRpdGxlLFxyXG4gICAgY29udGVudCxcclxuICAgIGNsb3NlSWNvbixcclxuICAgIG9wZW4gPSBmYWxzZSxcclxuICAgIGFwcGVhciA9IGZhbHNlLFxyXG4gICAgZGlzbWlzc2libGUgPSBmYWxzZSxcclxuICAgIG1vZGFsID0gZmFsc2UsXHJcbiAgICBhcHBDb250ZW50U2VsZWN0b3IsXHJcbiAgICBvbkNsb3NlID0gRnVuY3Rpb24ucHJvdG90eXBlLFxyXG5cclxuICAgIGVsZW1lbnQgPSAnYXNpZGUnLFxyXG4gICAgY29tcG9uZW50OiBFbGVtZW50ID0gZWxlbWVudCxcclxuICAgIGNsYXNzTmFtZSxcclxuICAgIGNoaWxkcmVuLFxyXG4gICAgLi4ucHJvcHNcclxufSwgcmVmKSA9PiB7XHJcbiAgICBjb25zdCByb290UmVmID0gdXNlUmVmKCk7XHJcblxyXG4gICAgdXNlSW1wZXJhdGl2ZUhhbmRsZShyZWYsICgpID0+IHJvb3RSZWYuY3VycmVudCk7XHJcblxyXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgICAgICBpZiAoIWRpc21pc3NpYmxlKSByZXR1cm47XHJcblxyXG4gICAgICAgIGNvbnN0IGFwcENvbnRlbnRFbGVtZW50ID0gYXBwQ29udGVudFNlbGVjdG9yID9cclxuICAgICAgICAgICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvcihhcHBDb250ZW50U2VsZWN0b3IpIDpcclxuICAgICAgICAgICAgcm9vdFJlZi5jdXJyZW50Lm5leHRFbGVtZW50U2libGluZztcclxuXHJcbiAgICAgICAgYXBwQ29udGVudEVsZW1lbnQ/LmNsYXNzTGlzdC5hZGQoY3NzQ2xhc3Nlcy5BUFBfQ09OVEVOVCk7XHJcblxyXG4gICAgICAgIHJldHVybiAoKSA9PiB7XHJcbiAgICAgICAgICAgIGFwcENvbnRlbnRFbGVtZW50Py5jbGFzc0xpc3QucmVtb3ZlKGNzc0NsYXNzZXMuQVBQX0NPTlRFTlQpO1xyXG4gICAgICAgIH07XHJcbiAgICB9LCBbZGlzbWlzc2libGUsIGFwcENvbnRlbnRTZWxlY3Rvcl0pO1xyXG5cclxuICAgIHVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICAgICAgaWYgKCFtb2RhbCkgcmV0dXJuO1xyXG5cclxuICAgICAgICBmdW5jdGlvbiBoYW5kbGVEb2N1bWVudEtleURvd24oZXZlbnQpIHtcclxuICAgICAgICAgICAgaWYgKGV2ZW50LmtleSAmJiBldmVudC5rZXkgPT09ICdFc2NhcGUnIHx8IGV2ZW50LmtleUNvZGUgPT09IDI3KSB7XHJcbiAgICAgICAgICAgICAgICBvbkNsb3NlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCBoYW5kbGVEb2N1bWVudEtleURvd24pO1xyXG5cclxuICAgICAgICByZXR1cm4gKCkgPT4gZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIGhhbmRsZURvY3VtZW50S2V5RG93bik7XHJcbiAgICB9LCBbbW9kYWwsIG9uQ2xvc2VdKTtcclxuXHJcbiAgICBjb25zdCBjbGFzc05hbWVzID0gY2xhc3NuYW1lcyhjc3NDbGFzc2VzLlJPT1QsIHtcclxuICAgICAgICBbY3NzQ2xhc3Nlcy5ESVNNSVNTSUJMRV06IGRpc21pc3NpYmxlLFxyXG4gICAgICAgIFtjc3NDbGFzc2VzLk1PREFMXTogbW9kYWxcclxuICAgIH0sIGNsYXNzTmFtZSk7XHJcblxyXG4gICAgcmV0dXJuIChcclxuICAgICAgICA8TGF5ZXJcclxuICAgICAgICAgICAgbW9kYWw9e21vZGFsfVxyXG4gICAgICAgICAgICBmaXhlZD17bW9kYWx9XHJcbiAgICAgICAgICAgIGluPXtvcGVufVxyXG4gICAgICAgICAgICBhcHBlYXI9e2FwcGVhcn1cclxuICAgICAgICAgICAgdGltZW91dD17e1xyXG4gICAgICAgICAgICAgICAgZW50ZXI6IG51bWJlcnMuQU5JTUFUSU9OX0VOVEVSX1RJTUVfTVMsXHJcbiAgICAgICAgICAgICAgICBleGl0OiBudW1iZXJzLkFOSU1BVElPTl9FWElUX1RJTUVfTVNcclxuICAgICAgICAgICAgfX1cclxuICAgICAgICAgICAgY2xhc3NOYW1lcz17e1xyXG4gICAgICAgICAgICAgICAgYXBwZWFyOiBjc3NDbGFzc2VzLk9QRU4sXHJcbiAgICAgICAgICAgICAgICBlbnRlcjogYCR7Y3NzQ2xhc3Nlcy5PUEVOfSAke2Nzc0NsYXNzZXMuQU5JTUFURX1gLFxyXG4gICAgICAgICAgICAgICAgZW50ZXJBY3RpdmU6IGAke2Nzc0NsYXNzZXMuT1BFTn0gJHtjc3NDbGFzc2VzLk9QRU5JTkd9YCxcclxuICAgICAgICAgICAgICAgIGVudGVyRG9uZTogY3NzQ2xhc3Nlcy5PUEVOLFxyXG4gICAgICAgICAgICAgICAgZXhpdDogYCR7Y3NzQ2xhc3Nlcy5PUEVOfSAke2Nzc0NsYXNzZXMuQ0xPU0lOR31gLFxyXG4gICAgICAgICAgICAgICAgZXhpdEFjdGl2ZTogY3NzQ2xhc3Nlcy5DTE9TSU5HXHJcbiAgICAgICAgICAgIH19XHJcbiAgICAgICAgICAgIG1vdW50T25FbnRlcj17bW9kYWx9XHJcbiAgICAgICAgICAgIHVubW91bnRPbkV4aXQ9e21vZGFsfVxyXG4gICAgICAgID5cclxuICAgICAgICAgICAgPD5cclxuICAgICAgICAgICAgICAgIDxFbGVtZW50XHJcbiAgICAgICAgICAgICAgICAgICAgcmVmPXtyb290UmVmfVxyXG4gICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT17Y2xhc3NOYW1lc31cclxuICAgICAgICAgICAgICAgICAgICB7Li4ucHJvcHN9XHJcbiAgICAgICAgICAgICAgICA+XHJcbiAgICAgICAgICAgICAgICAgICAgeyh0aXRsZSB8fCBjbG9zZUljb24pICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxTaWRlU2hlZXRIZWFkZXJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlPXt0aXRsZX1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2xvc2U9e29uQ2xvc2V9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbG9zZUljb249e2Nsb3NlSWNvbn1cclxuICAgICAgICAgICAgICAgICAgICAgICAgLz5cclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHtjb250ZW50ICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxTaWRlU2hlZXRDb250ZW50PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge2NvbnRlbnR9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDwvU2lkZVNoZWV0Q29udGVudD5cclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHtjaGlsZHJlbn1cclxuICAgICAgICAgICAgICAgIDwvRWxlbWVudD5cclxuXHJcbiAgICAgICAgICAgICAgICB7bW9kYWwgJiZcclxuICAgICAgICAgICAgICAgICAgICA8ZGl2XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT17Y3NzQ2xhc3Nlcy5TQ1JJTX1cclxuICAgICAgICAgICAgICAgICAgICAgICAgb25DbGljaz17b25DbG9zZX1cclxuICAgICAgICAgICAgICAgICAgICAvPlxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICA8Lz5cclxuICAgICAgICA8L0xheWVyPlxyXG4gICAgKTtcclxufSk7XHJcblxyXG5TaWRlU2hlZXQuZGlzcGxheU5hbWUgPSAnTURDU2lkZVNoZWV0JztcclxuXHJcblNpZGVTaGVldC5wcm9wVHlwZXMgPSB7XHJcbiAgICB0aXRsZTogUHJvcFR5cGVzLnN0cmluZyxcclxuICAgIGNvbnRlbnQ6IFByb3BUeXBlcy5ub2RlLFxyXG4gICAgY2xvc2VJY29uOiBQcm9wVHlwZXMubm9kZSxcclxuICAgIG9wZW46IFByb3BUeXBlcy5ib29sLFxyXG4gICAgYXBwZWFyOiBQcm9wVHlwZXMuYm9vbCxcclxuICAgIGRpc21pc3NpYmxlOiBQcm9wVHlwZXMuYm9vbCxcclxuICAgIG1vZGFsOiBQcm9wVHlwZXMuYm9vbCxcclxuICAgIGFwcENvbnRlbnRTZWxlY3RvcjogUHJvcFR5cGVzLnN0cmluZyxcclxuICAgIG9uQ2xvc2U6IFByb3BUeXBlcy5mdW5jXHJcbn07XHJcblxyXG5leHBvcnQgZGVmYXVsdCBTaWRlU2hlZXQ7IiwiaW1wb3J0IHsgZm9yd2FyZFJlZiB9IGZyb20gJ3JlYWN0JztcclxuaW1wb3J0IGNsYXNzbmFtZXMgZnJvbSAnY2xhc3NuYW1lcyc7XHJcblxyXG5pbXBvcnQgeyBjc3NDbGFzc2VzIH0gZnJvbSAnLi9jb25zdGFudHMnO1xyXG5cclxuY29uc3QgU2lkZVNoZWV0QXBwQ29udGVudCA9IGZvcndhcmRSZWYoKHsgZWxlbWVudDogRWxlbWVudCA9ICdkaXYnLCBjbGFzc05hbWUsIC4uLnByb3BzIH0sIHJlZikgPT4ge1xyXG4gICAgY29uc3QgY2xhc3NOYW1lcyA9IGNsYXNzbmFtZXMoY3NzQ2xhc3Nlcy5BUFBfQ09OVEVOVCwgY2xhc3NOYW1lKTtcclxuXHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAgIDxFbGVtZW50IHJlZj17cmVmfSBjbGFzc05hbWU9e2NsYXNzTmFtZXN9IHsuLi5wcm9wc30gLz5cclxuICAgICk7XHJcbn0pO1xyXG5cclxuU2lkZVNoZWV0QXBwQ29udGVudC5kaXNwbGF5TmFtZSA9ICdNRENTaWRlU2hlZXRBcHBDb250ZW50JztcclxuXHJcbmV4cG9ydCBkZWZhdWx0IFNpZGVTaGVldEFwcENvbnRlbnQ7IiwiaW1wb3J0IFNpZGVTaGVldCBmcm9tICcuL1NpZGVTaGVldCc7XHJcbmltcG9ydCBTaWRlU2hlZXRIZWFkZXIgZnJvbSAnLi9TaWRlU2hlZXRIZWFkZXInO1xyXG5pbXBvcnQgU2lkZVNoZWV0Q29udGVudCBmcm9tICcuL1NpZGVTaGVldENvbnRlbnQnO1xyXG5pbXBvcnQgU2lkZVNoZWV0QXBwQ29udGVudCBmcm9tICcuL1NpZGVTaGVldEFwcENvbnRlbnQnO1xyXG5cclxuU2lkZVNoZWV0LkhlYWRlciA9IFNpZGVTaGVldEhlYWRlcjtcclxuU2lkZVNoZWV0LkNvbnRlbnQgPSBTaWRlU2hlZXRDb250ZW50O1xyXG5TaWRlU2hlZXQuQXBwQ29udGVudCA9IFNpZGVTaGVldEFwcENvbnRlbnQ7XHJcblxyXG5leHBvcnQge1xyXG4gICAgU2lkZVNoZWV0IGFzIGRlZmF1bHQsXHJcbiAgICBTaWRlU2hlZXRIZWFkZXIsXHJcbiAgICBTaWRlU2hlZXRDb250ZW50LFxyXG4gICAgU2lkZVNoZWV0QXBwQ29udGVudFxyXG59OyIsImV4cG9ydCBjb25zdCBLZXkgPSB7XHJcbiAgICBBUlJPV19MRUZUOiAnQXJyb3dMZWZ0JyxcclxuICAgIEFSUk9XX1VQOiAnQXJyb3dVcCcsXHJcbiAgICBBUlJPV19SSUdIVDogJ0Fycm93UmlnaHQnLFxyXG4gICAgQVJST1dfRE9XTjogJ0Fycm93RG93bicsXHJcbiAgICBIT01FOiAnSG9tZScsXHJcbiAgICBFTkQ6ICdFbmQnLFxyXG4gICAgUEFHRV9VUDogJ1BhZ2VVcCcsXHJcbiAgICBQQUdFX0RPV046ICdQYWdlRG93bidcclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCBLZXlDb2RlID0ge1xyXG4gICAgUEFHRV9VUDogMzMsXHJcbiAgICBQQUdFX0RPV046IDM0LFxyXG4gICAgRU5EOiAzNSxcclxuICAgIEhPTUU6IDM2LFxyXG4gICAgQVJST1dfTEVGVDogMzcsXHJcbiAgICBBUlJPV19VUDogMzgsXHJcbiAgICBBUlJPV19SSUdIVDogMzksXHJcbiAgICBBUlJPV19ET1dOOiA0MFxyXG59OyIsImltcG9ydCB7IEtleSwgS2V5Q29kZSB9IGZyb20gJy4vY29uc3RhbnRzJztcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRFdmVudEtleShldmVudCkge1xyXG4gICAgc3dpdGNoIChldmVudC5rZXkgfHwgZXZlbnQua2V5Q29kZSkge1xyXG4gICAgICAgIGNhc2UgS2V5LkFSUk9XX0xFRlQ6XHJcbiAgICAgICAgY2FzZSBLZXlDb2RlLkFSUk9XX0xFRlQ6XHJcbiAgICAgICAgICAgIHJldHVybiBLZXkuQVJST1dfTEVGVDtcclxuXHJcbiAgICAgICAgY2FzZSBLZXkuQVJST1dfVVA6XHJcbiAgICAgICAgY2FzZSBLZXlDb2RlLkFSUk9XX1VQOlxyXG4gICAgICAgICAgICByZXR1cm4gS2V5LkFSUk9XX1VQO1xyXG5cclxuICAgICAgICBjYXNlIEtleS5BUlJPV19SSUdIVDpcclxuICAgICAgICBjYXNlIEtleUNvZGUuQVJST1dfUklHSFQ6XHJcbiAgICAgICAgICAgIHJldHVybiBLZXkuQVJST1dfUklHSFQ7XHJcblxyXG4gICAgICAgIGNhc2UgS2V5LkFSUk9XX0RPV046XHJcbiAgICAgICAgY2FzZSBLZXlDb2RlLkFSUk9XX0RPV046XHJcbiAgICAgICAgICAgIHJldHVybiBLZXkuQVJST1dfRE9XTjtcclxuXHJcbiAgICAgICAgY2FzZSBLZXkuSE9NRTpcclxuICAgICAgICBjYXNlIEtleUNvZGUuSE9NRTpcclxuICAgICAgICAgICAgcmV0dXJuIEtleS5IT01FO1xyXG5cclxuICAgICAgICBjYXNlIEtleS5FTkQ6XHJcbiAgICAgICAgY2FzZSBLZXlDb2RlLkVORDpcclxuICAgICAgICAgICAgcmV0dXJuIEtleS5FTkQ7XHJcblxyXG4gICAgICAgIGNhc2UgS2V5LlBBR0VfVVA6XHJcbiAgICAgICAgY2FzZSBLZXlDb2RlLlBBR0VfVVA6XHJcbiAgICAgICAgICAgIHJldHVybiBLZXkuUEFHRV9VUDtcclxuXHJcbiAgICAgICAgY2FzZSBLZXkuUEFHRV9ET1dOOlxyXG4gICAgICAgIGNhc2UgS2V5Q29kZS5QQUdFX0RPV046XHJcbiAgICAgICAgICAgIHJldHVybiBLZXkuUEFHRV9ET1dOO1xyXG5cclxuICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgfVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gZ2V0UGFnZVgoZXZlbnQpIHtcclxuICAgIGlmIChldmVudC50YXJnZXRUb3VjaGVzPy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgcmV0dXJuIGV2ZW50LnRhcmdldFRvdWNoZXNbMF0ucGFnZVg7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGV2ZW50LnBhZ2VYO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gZ2V0UGFnZVkoZXZlbnQpIHtcclxuICAgIGlmIChldmVudC50YXJnZXRUb3VjaGVzPy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgcmV0dXJuIGV2ZW50LnRhcmdldFRvdWNoZXNbMF0ucGFnZVk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGV2ZW50LnBhZ2VZO1xyXG59IiwiZXhwb3J0IGNvbnN0IG51bWJlcnMgPSB7XHJcbiAgICBUSFVNQl9XSURUSDogNDhcclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCBjc3NDbGFzc2VzID0ge1xyXG4gICAgUk9PVDogJ21kYy1zbGlkZXInLFxyXG4gICAgUkFOR0U6ICdtZGMtc2xpZGVyLS1yYW5nZScsXHJcbiAgICBESVNDUkVURTogJ21kYy1zbGlkZXItLWRpc2NyZXRlJyxcclxuICAgIERJU0FCTEVEOiAnbWRjLXNsaWRlci0tZGlzYWJsZWQnLFxyXG5cclxuICAgIElOUFVUOiAnbWRjLXNsaWRlcl9faW5wdXQnLFxyXG5cclxuICAgIFRSQUNLOiAnbWRjLXNsaWRlcl9fdHJhY2snLFxyXG4gICAgVFJBQ0tfSU5BQ1RJVkU6ICdtZGMtc2xpZGVyX190cmFjay0taW5hY3RpdmUnLFxyXG4gICAgVFJBQ0tfQUNUSVZFOiAnbWRjLXNsaWRlcl9fdHJhY2stLWFjdGl2ZScsXHJcbiAgICBUUkFDS19BQ1RJVkVfRklMTDogJ21kYy1zbGlkZXJfX3RyYWNrLS1hY3RpdmVfZmlsbCcsXHJcblxyXG4gICAgVElDS19NQVJLUzogJ21kYy1zbGlkZXJfX3RpY2stbWFya3MnLFxyXG4gICAgVElDS19NQVJLX0FDVElWRTogJ21kYy1zbGlkZXJfX3RpY2stbWFyay0tYWN0aXZlJyxcclxuICAgIFRJQ0tfTUFSS19JTkFDVElWRTogJ21kYy1zbGlkZXJfX3RpY2stbWFyay0taW5hY3RpdmUnLFxyXG5cclxuICAgIFRIVU1COiAnbWRjLXNsaWRlcl9fdGh1bWInLFxyXG4gICAgVEhVTUJfVE9QOiAnbWRjLXNsaWRlcl9fdGh1bWItLXRvcCcsXHJcbiAgICBUSFVNQl9GT0NVU0VEOiAnbWRjLXNsaWRlcl9fdGh1bWItLWZvY3VzZWQnLFxyXG4gICAgVEhVTUJfV0lUSF9JTkRJQ0FUT1I6ICdtZGMtc2xpZGVyX190aHVtYi0td2l0aC1pbmRpY2F0b3InLFxyXG4gICAgVEhVTUJfS05PQjogJ21kYy1zbGlkZXJfX3RodW1iLWtub2InLFxyXG5cclxuICAgIFZBTFVFX0lORElDQVRPUl9DT05UQUlORVI6ICdtZGMtc2xpZGVyX192YWx1ZS1pbmRpY2F0b3ItY29udGFpbmVyJyxcclxuICAgIFZBTFVFX0lORElDQVRPUjogJ21kYy1zbGlkZXJfX3ZhbHVlLWluZGljYXRvcicsXHJcbiAgICBWQUxVRV9JTkRJQ0FUT1JfVEVYVDogJ21kYy1zbGlkZXJfX3ZhbHVlLWluZGljYXRvci10ZXh0J1xyXG59OyIsImltcG9ydCB7IEtleSB9IGZyb20gJy4uL2NvbnN0YW50cyc7XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gZ2V0VmFsdWVGb3JFdmVudEtleShldmVudEtleSwgdmFsdWUsIG1pbiwgbWF4LCBzdGVwKSB7XHJcbiAgICBjb25zdCBkZWx0YSA9IE51bWJlcihzdGVwKSB8fCAobWF4IC0gbWluKSAvIDEwMDtcclxuXHJcbiAgICBzd2l0Y2ggKGV2ZW50S2V5KSB7XHJcbiAgICAgICAgY2FzZSBLZXkuQVJST1dfTEVGVDpcclxuICAgICAgICBjYXNlIEtleS5BUlJPV19ET1dOOlxyXG4gICAgICAgICAgICByZXR1cm4gdmFsdWUgLSBkZWx0YTtcclxuXHJcbiAgICAgICAgY2FzZSBLZXkuQVJST1dfUklHSFQ6XHJcbiAgICAgICAgY2FzZSBLZXkuQVJST1dfVVA6XHJcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZSArIGRlbHRhO1xyXG5cclxuICAgICAgICBjYXNlIEtleS5IT01FOlxyXG4gICAgICAgICAgICByZXR1cm4gbWluO1xyXG5cclxuICAgICAgICBjYXNlIEtleS5FTkQ6XHJcbiAgICAgICAgICAgIHJldHVybiBtYXg7XHJcblxyXG4gICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgIHJldHVybiBOYU47XHJcbiAgICB9XHJcbn0iLCJpbXBvcnQgeyBmb3J3YXJkUmVmIH0gZnJvbSAncmVhY3QnO1xyXG5cclxuaW1wb3J0IHsgY3NzQ2xhc3NlcyB9IGZyb20gJy4vY29uc3RhbnRzJztcclxuXHJcbmNvbnN0IElucHV0ID0gZm9yd2FyZFJlZigoe1xyXG4gICAgdmFsdWUsXHJcbiAgICAuLi5wcm9wc1xyXG59LCByZWYpID0+IHtcclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgPGlucHV0XHJcbiAgICAgICAgICAgIHJlZj17cmVmfVxyXG4gICAgICAgICAgICBjbGFzc05hbWU9e2Nzc0NsYXNzZXMuSU5QVVR9XHJcbiAgICAgICAgICAgIHR5cGU9XCJyYW5nZVwiXHJcbiAgICAgICAgICAgIHZhbHVlPXtNYXRoLnJvdW5kKHZhbHVlKX1cclxuICAgICAgICAgICAgb25DaGFuZ2U9e0Z1bmN0aW9uLnByb3RvdHlwZX1cclxuICAgICAgICAgICAgey4uLnByb3BzfVxyXG4gICAgICAgIC8+XHJcbiAgICApO1xyXG59KTtcclxuXHJcbklucHV0LmRpc3BsYXlOYW1lID0gJ01EQ1NsaWRlcklucHV0JztcclxuXHJcbmV4cG9ydCBkZWZhdWx0IElucHV0OyIsImltcG9ydCBjbGFzc25hbWVzIGZyb20gJ2NsYXNzbmFtZXMnO1xyXG5cclxuaW1wb3J0IHsgY3NzQ2xhc3NlcyB9IGZyb20gJy4vY29uc3RhbnRzJztcclxuXHJcbmNvbnN0IFRpY2tNYXJrcyA9ICh7XHJcbiAgICB2YWx1ZSxcclxuICAgIG1heCxcclxuICAgIHN0ZXAgPSAxXHJcbn0pID0+IHtcclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgPGRpdiBjbGFzc05hbWU9e2Nzc0NsYXNzZXMuVElDS19NQVJLU30+XHJcbiAgICAgICAgICAgIHtBcnJheS5mcm9tKG5ldyBBcnJheShtYXggLyBzdGVwICsgMSkpXHJcbiAgICAgICAgICAgICAgICAubWFwKChfLCBpKSA9PiBpICogc3RlcClcclxuICAgICAgICAgICAgICAgIC5tYXAoKHRpY2tWYWx1ZSwgaW5kZXgpID0+XHJcbiAgICAgICAgICAgICAgICAgICAgPGRpdlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBrZXk9e2luZGV4fVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU9e1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3NuYW1lcyh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW2Nzc0NsYXNzZXMuVElDS19NQVJLX0FDVElWRV06IHRpY2tWYWx1ZSA8PSB2YWx1ZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbY3NzQ2xhc3Nlcy5USUNLX01BUktfSU5BQ1RJVkVdOiB0aWNrVmFsdWUgPiB2YWx1ZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIC8+XHJcbiAgICAgICAgICAgICAgICApXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICA8L2Rpdj5cclxuICAgICk7XHJcbn07XHJcblxyXG5UaWNrTWFya3MuZGlzcGxheU5hbWUgPSAnTURDU2xpZGVyVGlja01hcmtzJztcclxuXHJcbmV4cG9ydCBkZWZhdWx0IFRpY2tNYXJrczsiLCJpbXBvcnQgeyBmb3J3YXJkUmVmIH0gZnJvbSAncmVhY3QnO1xyXG5cclxuaW1wb3J0IHsgY3NzQ2xhc3NlcyB9IGZyb20gJy4vY29uc3RhbnRzJztcclxuaW1wb3J0IFRpY2tNYXJrcyBmcm9tICcuL1RpY2tNYXJrcyc7XHJcblxyXG5jb25zdCBUcmFjayA9IGZvcndhcmRSZWYoKHtcclxuICAgIHZhbHVlLFxyXG4gICAgbWluLFxyXG4gICAgbWF4LFxyXG4gICAgc3RlcCxcclxuICAgIGRpc2NyZXRlLFxyXG4gICAgdGlja01hcmtzXHJcbn0sIHJlZikgPT4ge1xyXG4gICAgY29uc3Qgc3R5bGUgPSB7XHJcbiAgICAgICAgdHJhbnNmb3JtOiBgc2NhbGVYKCR7KHZhbHVlIC0gbWluKSAvIChtYXggLSBtaW4pfSlgXHJcbiAgICB9O1xyXG5cclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgPGRpdiByZWY9e3JlZn0gY2xhc3NOYW1lPXtjc3NDbGFzc2VzLlRSQUNLfT5cclxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9e2Nzc0NsYXNzZXMuVFJBQ0tfSU5BQ1RJVkV9IC8+XHJcblxyXG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17Y3NzQ2xhc3Nlcy5UUkFDS19BQ1RJVkV9PlxyXG4gICAgICAgICAgICAgICAgPGRpdlxyXG4gICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT17Y3NzQ2xhc3Nlcy5UUkFDS19BQ1RJVkVfRklMTH1cclxuICAgICAgICAgICAgICAgICAgICBzdHlsZT17c3R5bGV9XHJcbiAgICAgICAgICAgICAgICAvPlxyXG4gICAgICAgICAgICA8L2Rpdj5cclxuXHJcbiAgICAgICAgICAgIHtkaXNjcmV0ZSAmJiB0aWNrTWFya3MgJiZcclxuICAgICAgICAgICAgICAgIDxUaWNrTWFya3NcclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZT17dmFsdWV9XHJcbiAgICAgICAgICAgICAgICAgICAgbWF4PXttYXh9XHJcbiAgICAgICAgICAgICAgICAgICAgc3RlcD17c3RlcH1cclxuICAgICAgICAgICAgICAgIC8+XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICA8L2Rpdj5cclxuICAgICk7XHJcbn0pO1xyXG5cclxuVHJhY2suZGlzcGxheU5hbWUgPSAnTURDU2xpZGVyVHJhY2snO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgVHJhY2s7IiwiaW1wb3J0IHsgZm9yd2FyZFJlZiwgdXNlU3RhdGUsIHVzZUNhbGxiYWNrIH0gZnJvbSAncmVhY3QnO1xyXG5pbXBvcnQgY2xhc3NuYW1lcyBmcm9tICdjbGFzc25hbWVzJztcclxuXHJcbmltcG9ydCB7IG51bWJlcnMsIGNzc0NsYXNzZXMgfSBmcm9tICcuL2NvbnN0YW50cyc7XHJcblxyXG5jb25zdCBUaHVtYiA9IGZvcndhcmRSZWYoKHtcclxuICAgIHZhbHVlLFxyXG4gICAgbWluLFxyXG4gICAgbWF4LFxyXG4gICAgZGlzY3JldGUsXHJcbiAgICBkaXNhYmxlZCxcclxuICAgIG9uU3RhcnRJbnRlcmFjdGlvbixcclxuICAgIG9uRW5kSW50ZXJhY3Rpb24sXHJcbiAgICAuLi5wcm9wc1xyXG59LCByZWYpID0+IHtcclxuICAgIGNvbnN0IFtmb2N1c2VkLCBzZXRGb2N1c2VkXSA9IHVzZVN0YXRlKGZhbHNlKTtcclxuXHJcbiAgICBjb25zdCBoYW5kbGVGb2N1cyA9IHVzZUNhbGxiYWNrKCgpID0+IHtcclxuICAgICAgICBzZXRGb2N1c2VkKHRydWUpO1xyXG4gICAgfSwgW10pO1xyXG5cclxuICAgIGNvbnN0IGhhbmRsZUJsdXIgPSB1c2VDYWxsYmFjaygoKSA9PiB7XHJcbiAgICAgICAgc2V0Rm9jdXNlZChmYWxzZSk7XHJcbiAgICB9LCBbXSk7XHJcblxyXG4gICAgY29uc3QgY2xhc3NOYW1lcyA9IGNsYXNzbmFtZXMoY3NzQ2xhc3Nlcy5USFVNQiwge1xyXG4gICAgICAgIFtjc3NDbGFzc2VzLlRIVU1CX0ZPQ1VTRURdOiBmb2N1c2VkLFxyXG4gICAgICAgIFtjc3NDbGFzc2VzLlRIVU1CX1dJVEhfSU5ESUNBVE9SXTogZGlzY3JldGUgJiYgZm9jdXNlZFxyXG4gICAgfSk7XHJcblxyXG4gICAgY29uc3Qgc3R5bGUgPSB7XHJcbiAgICAgICAgbGVmdDogYGNhbGMoJHsodmFsdWUgLSBtaW4pIC8gKG1heCAtIG1pbikgKiAxMDB9JSAtICR7bnVtYmVycy5USFVNQl9XSURUSCAqIDAuNX1weClgXHJcbiAgICB9O1xyXG5cclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgPGRpdlxyXG4gICAgICAgICAgICByZWY9e3JlZn1cclxuICAgICAgICAgICAgY2xhc3NOYW1lPXtjbGFzc05hbWVzfVxyXG4gICAgICAgICAgICByb2xlPVwic2xpZGVyXCJcclxuICAgICAgICAgICAgdGFiSW5kZXg9e2Rpc2FibGVkID8gJy0xJyA6ICcwJ31cclxuICAgICAgICAgICAgYXJpYS12YWx1ZW1pbj1cIjBcIlxyXG4gICAgICAgICAgICBhcmlhLXZhbHVlbWF4PVwiMTAwXCJcclxuICAgICAgICAgICAgYXJpYS12YWx1ZW5vdz1cIjUwXCJcclxuICAgICAgICAgICAgYXJpYS1kaXNhYmxlZD17ZGlzYWJsZWQgfHwgdW5kZWZpbmVkfVxyXG4gICAgICAgICAgICBzdHlsZT17c3R5bGV9XHJcbiAgICAgICAgICAgIG9uRm9jdXM9e2hhbmRsZUZvY3VzfVxyXG4gICAgICAgICAgICBvbkJsdXI9e2hhbmRsZUJsdXJ9XHJcbiAgICAgICAgICAgIG9uTW91c2VEb3duPXtvblN0YXJ0SW50ZXJhY3Rpb259XHJcbiAgICAgICAgICAgIG9uTW91c2VVcD17b25FbmRJbnRlcmFjdGlvbn1cclxuICAgICAgICAgICAgb25Ub3VjaFN0YXJ0PXtvblN0YXJ0SW50ZXJhY3Rpb259XHJcbiAgICAgICAgICAgIG9uVG91Y2hFbmQ9e29uRW5kSW50ZXJhY3Rpb259XHJcbiAgICAgICAgICAgIHsuLi5wcm9wc31cclxuICAgICAgICA+XHJcbiAgICAgICAgICAgIHtkaXNjcmV0ZSAmJlxyXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9e2Nzc0NsYXNzZXMuVkFMVUVfSU5ESUNBVE9SX0NPTlRBSU5FUn0+XHJcbiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9e2Nzc0NsYXNzZXMuVkFMVUVfSU5ESUNBVE9SfT5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3NOYW1lPXtjc3NDbGFzc2VzLlZBTFVFX0lORElDQVRPUl9URVhUfT57dmFsdWV9PC9zcGFuPlxyXG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXtjc3NDbGFzc2VzLlRIVU1CX0tOT0J9IC8+XHJcbiAgICAgICAgPC9kaXY+XHJcbiAgICApO1xyXG59KTtcclxuXHJcblRodW1iLmRpc3BsYXlOYW1lID0gJ01EQ1NsaWRlclRodW1iJztcclxuXHJcbmV4cG9ydCBkZWZhdWx0IFRodW1iOyIsImltcG9ydCB7IGZvcndhcmRSZWYsIHVzZVJlZiwgdXNlU3RhdGUsIHVzZUNhbGxiYWNrIH0gZnJvbSAncmVhY3QnO1xyXG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xyXG5pbXBvcnQgY2xhc3NuYW1lcyBmcm9tICdjbGFzc25hbWVzJztcclxuXHJcbmltcG9ydCB7IHVzZVVwZGF0ZWQgfSBmcm9tICcuLi9ob29rcyc7XHJcbmltcG9ydCB7IGdldEV2ZW50S2V5LCBnZXRQYWdlWCB9IGZyb20gJy4uL3V0aWxzJztcclxuXHJcbmltcG9ydCB7IGNzc0NsYXNzZXMgfSBmcm9tICcuL2NvbnN0YW50cyc7XHJcbmltcG9ydCB7IGdldFZhbHVlRm9yRXZlbnRLZXkgfSBmcm9tICcuL3V0aWxzJztcclxuaW1wb3J0IElucHV0IGZyb20gJy4vSW5wdXQnO1xyXG5pbXBvcnQgVHJhY2sgZnJvbSAnLi9UcmFjayc7XHJcbmltcG9ydCBUaHVtYiBmcm9tICcuL1RodW1iJztcclxuXHJcbmNvbnN0IFNsaWRlciA9IGZvcndhcmRSZWYoKHtcclxuICAgIG5hbWUsXHJcbiAgICB2YWx1ZSA9IDAsXHJcbiAgICBtaW4gPSAwLFxyXG4gICAgbWF4ID0gMTAwLFxyXG4gICAgc3RlcCxcclxuICAgIGRpc2NyZXRlID0gZmFsc2UsXHJcbiAgICBkaXNhYmxlZCA9IGZhbHNlLFxyXG4gICAgdGlja01hcmtzID0gZmFsc2UsXHJcbiAgICBvbkNoYW5nZSA9IEZ1bmN0aW9uLnByb3RvdHlwZSxcclxuXHJcbiAgICBjbGFzc05hbWUsXHJcbiAgICAuLi5wcm9wc1xyXG59LCByZWYpID0+IHtcclxuICAgIGNvbnN0IGlucHV0UmVmID0gdXNlUmVmKCk7XHJcbiAgICBjb25zdCB0cmFja1JlZiA9IHVzZVJlZigpO1xyXG5cclxuICAgIGNvbnN0IFthY3RpdmUsIHNldEFjdGl2ZV0gPSB1c2VTdGF0ZShmYWxzZSk7XHJcblxyXG4gICAgdXNlVXBkYXRlZCgoKSA9PiB7XHJcbiAgICAgICAgaWYgKGRpc2FibGVkKSByZXR1cm47XHJcblxyXG4gICAgICAgIGlmIChhY3RpdmUpIHtcclxuICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBoYW5kbGVNb3ZlKTtcclxuICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5hZGRFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCBoYW5kbGVNb3ZlKTtcclxuICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgaGFuZGxlVXApO1xyXG4gICAgICAgICAgICBkb2N1bWVudC5ib2R5LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgaGFuZGxlVXApO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgaGFuZGxlTW92ZSk7XHJcbiAgICAgICAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgaGFuZGxlTW92ZSk7XHJcbiAgICAgICAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIGhhbmRsZVVwKTtcclxuICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIGhhbmRsZVVwKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiAoKSA9PiB7XHJcbiAgICAgICAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgaGFuZGxlTW92ZSk7XHJcbiAgICAgICAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgaGFuZGxlTW92ZSk7XHJcbiAgICAgICAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIGhhbmRsZVVwKTtcclxuICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIGhhbmRsZVVwKTtcclxuICAgICAgICB9O1xyXG4gICAgfSwgW2FjdGl2ZV0pO1xyXG5cclxuICAgIGNvbnN0IHVwZGF0ZVZhbHVlID0gdXNlQ2FsbGJhY2sobmV3VmFsdWUgPT4ge1xyXG4gICAgICAgIGlmIChuZXdWYWx1ZSA8IG1pbikge1xyXG4gICAgICAgICAgICBuZXdWYWx1ZSA9IE51bWJlcihtaW4pO1xyXG4gICAgICAgIH0gZWxzZSBpZiAobmV3VmFsdWUgPiBtYXgpIHtcclxuICAgICAgICAgICAgbmV3VmFsdWUgPSBOdW1iZXIobWF4KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChzdGVwKSB7XHJcbiAgICAgICAgICAgIG5ld1ZhbHVlID0gTWF0aC5yb3VuZChuZXdWYWx1ZSAvIHN0ZXApICogc3RlcDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIG9uQ2hhbmdlKG5ld1ZhbHVlKTtcclxuICAgIH0sIFttaW4sIG1heCwgc3RlcCwgb25DaGFuZ2VdKTtcclxuXHJcbiAgICBjb25zdCBoYW5kbGVNb3ZlID0gdXNlQ2FsbGJhY2soZXZlbnQgPT4ge1xyXG4gICAgICAgIGNvbnN0IHRyYWNrQ2xpZW50UmVjdCA9IHRyYWNrUmVmLmN1cnJlbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XHJcbiAgICAgICAgY29uc3QgcGFnZVggPSBnZXRQYWdlWChldmVudCk7XHJcbiAgICAgICAgY29uc3Qgb2Zmc2V0WCA9IHBhZ2VYIC0gdHJhY2tDbGllbnRSZWN0LmxlZnQ7XHJcbiAgICAgICAgY29uc3QgcGVyY2VudCA9IG9mZnNldFggLyB0cmFja0NsaWVudFJlY3Qud2lkdGg7XHJcbiAgICAgICAgY29uc3QgdmFsdWUgPSBOdW1iZXIobWluKSArIHBlcmNlbnQgKiAobWF4IC0gbWluKTtcclxuXHJcbiAgICAgICAgdXBkYXRlVmFsdWUodmFsdWUpO1xyXG4gICAgfSwgW21pbiwgbWF4LCB1cGRhdGVWYWx1ZV0pO1xyXG5cclxuICAgIGNvbnN0IGhhbmRsZUtleURvd24gPSB1c2VDYWxsYmFjayhldmVudCA9PiB7XHJcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcclxuXHJcbiAgICAgICAgY29uc3QgdmFsdWUgPSBOdW1iZXIoaW5wdXRSZWYuY3VycmVudC52YWx1ZSk7XHJcbiAgICAgICAgY29uc3QgZXZlbnRLZXkgPSBnZXRFdmVudEtleShldmVudCk7XHJcbiAgICAgICAgY29uc3QgbmV3VmFsdWUgPSBnZXRWYWx1ZUZvckV2ZW50S2V5KGV2ZW50S2V5LCB2YWx1ZSwgbWluLCBtYXgsIHN0ZXApO1xyXG5cclxuICAgICAgICBpZiAoaXNOYU4obmV3VmFsdWUpKSByZXR1cm47XHJcblxyXG4gICAgICAgIHVwZGF0ZVZhbHVlKG5ld1ZhbHVlKTtcclxuICAgIH0sIFttaW4sIG1heCwgc3RlcCwgdXBkYXRlVmFsdWVdKTtcclxuXHJcbiAgICBjb25zdCBoYW5kbGVSb290SW50ZXJhY3Rpb24gPSB1c2VDYWxsYmFjayhldmVudCA9PiB7XHJcbiAgICAgICAgaGFuZGxlTW92ZShldmVudCk7XHJcbiAgICB9LCBbaGFuZGxlTW92ZV0pO1xyXG5cclxuICAgIGNvbnN0IGhhbmRsZVVwID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xyXG4gICAgICAgIHNldEFjdGl2ZShmYWxzZSk7XHJcbiAgICB9LCBbXSk7XHJcblxyXG4gICAgY29uc3QgaGFuZGxlVGh1bWJTdGFydEludGVyYWN0aW9uID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xyXG4gICAgICAgIHNldEFjdGl2ZSh0cnVlKTtcclxuICAgIH0sIFtdKTtcclxuXHJcbiAgICBjb25zdCBoYW5kbGVUaHVtYkVuZEludGVyYWN0aW9uID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xyXG4gICAgICAgIHNldEFjdGl2ZShmYWxzZSk7XHJcbiAgICB9LCBbXSk7XHJcblxyXG4gICAgY29uc3QgY2xhc3NOYW1lcyA9IGNsYXNzbmFtZXMoY3NzQ2xhc3Nlcy5ST09ULCB7XHJcbiAgICAgICAgW2Nzc0NsYXNzZXMuRElTQ1JFVEVdOiBkaXNjcmV0ZSxcclxuICAgICAgICBbY3NzQ2xhc3Nlcy5ESVNBQkxFRF06IGRpc2FibGVkXHJcbiAgICB9LCBjbGFzc05hbWUpO1xyXG5cclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgPGRpdlxyXG4gICAgICAgICAgICByZWY9e3JlZn1cclxuICAgICAgICAgICAgY2xhc3NOYW1lPXtjbGFzc05hbWVzfVxyXG4gICAgICAgICAgICBvbk1vdXNlRG93bj17aGFuZGxlUm9vdEludGVyYWN0aW9ufVxyXG4gICAgICAgICAgICBvblRvdWNoU3RhcnQ9e2hhbmRsZVJvb3RJbnRlcmFjdGlvbn1cclxuICAgICAgICAgICAgey4uLnByb3BzfVxyXG4gICAgICAgID5cclxuICAgICAgICAgICAgPElucHV0XHJcbiAgICAgICAgICAgICAgICByZWY9e2lucHV0UmVmfVxyXG4gICAgICAgICAgICAgICAgbmFtZT17bmFtZX1cclxuICAgICAgICAgICAgICAgIHZhbHVlPXt2YWx1ZX1cclxuICAgICAgICAgICAgICAgIG1pbj17bWlufVxyXG4gICAgICAgICAgICAgICAgbWF4PXttYXh9XHJcbiAgICAgICAgICAgICAgICBzdGVwPXtzdGVwfVxyXG4gICAgICAgICAgICAgICAgZGlzYWJsZWQ9e2Rpc2FibGVkfVxyXG4gICAgICAgICAgICAvPlxyXG5cclxuICAgICAgICAgICAgPFRyYWNrXHJcbiAgICAgICAgICAgICAgICByZWY9e3RyYWNrUmVmfVxyXG4gICAgICAgICAgICAgICAgdmFsdWU9e3ZhbHVlfVxyXG4gICAgICAgICAgICAgICAgbWluPXttaW59XHJcbiAgICAgICAgICAgICAgICBtYXg9e21heH1cclxuICAgICAgICAgICAgICAgIHN0ZXA9e3N0ZXB9XHJcbiAgICAgICAgICAgICAgICBkaXNjcmV0ZT17ZGlzY3JldGV9XHJcbiAgICAgICAgICAgICAgICB0aWNrTWFya3M9e3RpY2tNYXJrc31cclxuICAgICAgICAgICAgLz5cclxuXHJcbiAgICAgICAgICAgIDxUaHVtYlxyXG4gICAgICAgICAgICAgICAgdmFsdWU9e3ZhbHVlfVxyXG4gICAgICAgICAgICAgICAgbWluPXttaW59XHJcbiAgICAgICAgICAgICAgICBtYXg9e21heH1cclxuICAgICAgICAgICAgICAgIGRpc2NyZXRlPXtkaXNjcmV0ZX1cclxuICAgICAgICAgICAgICAgIG9uU3RhcnRJbnRlcmFjdGlvbj17aGFuZGxlVGh1bWJTdGFydEludGVyYWN0aW9ufVxyXG4gICAgICAgICAgICAgICAgb25FbmRJbnRlcmFjdGlvbj17aGFuZGxlVGh1bWJFbmRJbnRlcmFjdGlvbn1cclxuICAgICAgICAgICAgICAgIG9uS2V5RG93bj17aGFuZGxlS2V5RG93bn1cclxuICAgICAgICAgICAgLz5cclxuICAgICAgICA8L2Rpdj5cclxuICAgICk7XHJcbn0pO1xyXG5cclxuU2xpZGVyLmRpc3BsYXlOYW1lID0gJ01EQ1NsaWRlcic7XHJcblxyXG5TbGlkZXIucHJvcFR5cGVzID0ge1xyXG4gICAgdmFsdWU6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1xyXG4gICAgICAgIFByb3BUeXBlcy5udW1iZXIsXHJcbiAgICAgICAgUHJvcFR5cGVzLnN0cmluZ1xyXG4gICAgXSksXHJcbiAgICBtaW46IFByb3BUeXBlcy5vbmVPZlR5cGUoW1xyXG4gICAgICAgIFByb3BUeXBlcy5udW1iZXIsXHJcbiAgICAgICAgUHJvcFR5cGVzLnN0cmluZ1xyXG4gICAgXSksXHJcbiAgICBtYXg6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1xyXG4gICAgICAgIFByb3BUeXBlcy5udW1iZXIsXHJcbiAgICAgICAgUHJvcFR5cGVzLnN0cmluZ1xyXG4gICAgXSksXHJcbiAgICBzdGVwOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtcclxuICAgICAgICBQcm9wVHlwZXMubnVtYmVyLFxyXG4gICAgICAgIFByb3BUeXBlcy5zdHJpbmdcclxuICAgIF0pLFxyXG4gICAgZGlzY3JldGU6IFByb3BUeXBlcy5ib29sLFxyXG4gICAgZGlzYWJsZWQ6IFByb3BUeXBlcy5ib29sLFxyXG4gICAgdGlja01hcmtzOiBQcm9wVHlwZXMuYm9vbCxcclxuICAgIG9uQ2hhbmdlOiBQcm9wVHlwZXMuZnVuY1xyXG59O1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgU2xpZGVyOyIsImV4cG9ydCB7IGRlZmF1bHQgfSBmcm9tICcuL1NsaWRlcic7IiwiZXhwb3J0IGNvbnN0IG51bWJlcnMgPSB7XHJcbiAgICBERUZBVUxUX0FVVE9fRElTTUlTU19USU1FT1VUX01TOiA1MDAwLFxyXG4gICAgQU5JTUFUSU9OX09QRU5fVElNRV9NUzogMTUwLFxyXG4gICAgQU5JTUFUSU9OX0NMT1NFX1RJTUVfTVM6IDc1XHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgY3NzQ2xhc3NlcyA9IHtcclxuICAgIFJPT1Q6ICdtZGMtc25hY2tiYXInLFxyXG4gICAgTEVBRElORzogJ21kYy1zbmFja2Jhci0tbGVhZGluZycsXHJcbiAgICBTVEFDS0VEOiAnbWRjLXNuYWNrYmFyLS1zdGFja2VkJyxcclxuICAgIE9QRU5JTkc6ICdtZGMtc25hY2tiYXItLW9wZW5pbmcnLFxyXG4gICAgT1BFTjogJ21kYy1zbmFja2Jhci0tb3BlbicsXHJcbiAgICBDTE9TSU5HOiAnbWRjLXNuYWNrYmFyLS1jbG9zaW5nJyxcclxuXHJcbiAgICBTVVJGQUNFOiAnbWRjLXNuYWNrYmFyX19zdXJmYWNlJyxcclxuICAgIExBQkVMOiAnbWRjLXNuYWNrYmFyX19sYWJlbCcsXHJcbiAgICBBQ1RJT05TOiAnbWRjLXNuYWNrYmFyX19hY3Rpb25zJyxcclxuICAgIEFDVElPTjogJ21kYy1zbmFja2Jhcl9fYWN0aW9uJyxcclxuICAgIERJU01JU1M6ICdtZGMtc25hY2tiYXJfX2Rpc21pc3MnXHJcbn07IiwiaW1wb3J0IHsgZm9yd2FyZFJlZiwgdXNlUmVmLCB1c2VDYWxsYmFjayB9IGZyb20gJ3JlYWN0JztcclxuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcclxuaW1wb3J0IGNsYXNzbmFtZXMgZnJvbSAnY2xhc3NuYW1lcyc7XHJcblxyXG5pbXBvcnQgeyB1c2VVcGRhdGVkIH0gZnJvbSAnLi4vaG9va3MnO1xyXG5pbXBvcnQgeyBDbG9uZSB9IGZyb20gJy4uL2NvbXBvbmVudCc7XHJcbmltcG9ydCBMYXllciBmcm9tICcuLi9sYXllcic7XHJcbmltcG9ydCBJY29uQnV0dG9uIGZyb20gJy4uL2ljb24tYnV0dG9uJztcclxuXHJcbmltcG9ydCB7IG51bWJlcnMsIGNzc0NsYXNzZXMgfSBmcm9tICcuL2NvbnN0YW50cyc7XHJcblxyXG5jb25zdCBTbmFja2JhciA9IGZvcndhcmRSZWYoKHtcclxuICAgIGxhYmVsLFxyXG4gICAgYWN0aW9uLFxyXG4gICAgZGlzbWlzc0ljb24gPSAnY2xvc2UnLFxyXG4gICAgb3BlbiA9IGZhbHNlLFxyXG4gICAgYXBwZWFyID0gZmFsc2UsXHJcbiAgICBsZWFkaW5nID0gZmFsc2UsXHJcbiAgICBzdGFja2VkID0gZmFsc2UsXHJcbiAgICBkaXNtaXNzaWJsZSA9IHRydWUsXHJcbiAgICB0aW1lb3V0ID0gbnVtYmVycy5ERUZBVUxUX0FVVE9fRElTTUlTU19USU1FT1VUX01TLFxyXG4gICAgY2xvc2VPbkVzY2FwZSA9IHRydWUsXHJcbiAgICBvbkNsb3NlID0gRnVuY3Rpb24ucHJvdG90eXBlLFxyXG5cclxuICAgIGVsZW1lbnQ6IEVsZW1lbnQgPSAnZGl2JyxcclxuICAgIGNsYXNzTmFtZSxcclxuICAgIGNoaWxkcmVuID0gbGFiZWwsXHJcbiAgICAuLi5wcm9wc1xyXG59LCByZWYpID0+IHtcclxuICAgIGNvbnN0IHRpbWVvdXRSZWYgPSB1c2VSZWYoKTtcclxuXHJcbiAgICB1c2VVcGRhdGVkKCgpID0+IHtcclxuICAgICAgICBpZiAob3Blbikge1xyXG4gICAgICAgICAgICB0aW1lb3V0UmVmLmN1cnJlbnQgPSBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICAgICAgICAgIHRpbWVvdXRSZWYuY3VycmVudCA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICBvbkNsb3NlKCk7XHJcbiAgICAgICAgICAgIH0sIHRpbWVvdXQpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGlmICh0aW1lb3V0UmVmLmN1cnJlbnQpIHtcclxuICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0UmVmLmN1cnJlbnQpO1xyXG4gICAgICAgICAgICAgICAgdGltZW91dFJlZi5jdXJyZW50ID0gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuICgpID0+IGNsZWFyVGltZW91dCh0aW1lb3V0UmVmLmN1cnJlbnQpO1xyXG4gICAgfSwgW29wZW5dKTtcclxuXHJcbiAgICBjb25zdCBoYW5kbGVLZXlEb3duID0gdXNlQ2FsbGJhY2soZXZlbnQgPT4ge1xyXG4gICAgICAgIGlmIChjbG9zZU9uRXNjYXBlICYmIGV2ZW50LmtleSA9PT0gJ0VzY2FwZScgfHwgZXZlbnQua2V5Q29kZSA9PT0gMjcpIHtcclxuICAgICAgICAgICAgb25DbG9zZSgpO1xyXG4gICAgICAgIH1cclxuICAgIH0sIFtjbG9zZU9uRXNjYXBlLCBvbkNsb3NlXSk7XHJcblxyXG4gICAgY29uc3QgY2xhc3NOYW1lcyA9IGNsYXNzbmFtZXMoY3NzQ2xhc3Nlcy5ST09ULCB7XHJcbiAgICAgICAgW2Nzc0NsYXNzZXMuTEVBRElOR106IGxlYWRpbmcsXHJcbiAgICAgICAgW2Nzc0NsYXNzZXMuU1RBQ0tFRF06IHN0YWNrZWRcclxuICAgIH0sIGNsYXNzTmFtZSk7XHJcblxyXG4gICAgcmV0dXJuIChcclxuICAgICAgICA8TGF5ZXJcclxuICAgICAgICAgICAgbW9kYWxcclxuICAgICAgICAgICAgaW49e29wZW59XHJcbiAgICAgICAgICAgIGFwcGVhcj17YXBwZWFyfVxyXG4gICAgICAgICAgICB0aW1lb3V0PXt7XHJcbiAgICAgICAgICAgICAgICBlbnRlcjogbnVtYmVycy5BTklNQVRJT05fT1BFTl9USU1FX01TLFxyXG4gICAgICAgICAgICAgICAgZXhpdDogbnVtYmVycy5BTklNQVRJT05fQ0xPU0VfVElNRV9NU1xyXG4gICAgICAgICAgICB9fVxyXG4gICAgICAgICAgICBjbGFzc05hbWVzPXt7XHJcbiAgICAgICAgICAgICAgICBhcHBlYXI6IGNzc0NsYXNzZXMuT1BFTklORyxcclxuICAgICAgICAgICAgICAgIGFwcGVhckFjdGl2ZTogY3NzQ2xhc3Nlcy5PUEVOLFxyXG4gICAgICAgICAgICAgICAgZW50ZXI6IGNzc0NsYXNzZXMuT1BFTklORyxcclxuICAgICAgICAgICAgICAgIGVudGVyQWN0aXZlOiBjc3NDbGFzc2VzLk9QRU4sXHJcbiAgICAgICAgICAgICAgICBlbnRlckRvbmU6IGNzc0NsYXNzZXMuT1BFTixcclxuICAgICAgICAgICAgICAgIGV4aXQ6IGNzc0NsYXNzZXMuQ0xPU0lOR1xyXG4gICAgICAgICAgICB9fVxyXG4gICAgICAgICAgICBtb3VudE9uRW50ZXJcclxuICAgICAgICAgICAgdW5tb3VudE9uRXhpdFxyXG4gICAgICAgID5cclxuICAgICAgICAgICAgPEVsZW1lbnRcclxuICAgICAgICAgICAgICAgIHJlZj17cmVmfVxyXG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lPXtjbGFzc05hbWVzfVxyXG4gICAgICAgICAgICAgICAgb25LZXlEb3duPXtoYW5kbGVLZXlEb3dufVxyXG4gICAgICAgICAgICAgICAgey4uLnByb3BzfVxyXG4gICAgICAgICAgICA+XHJcbiAgICAgICAgICAgICAgICA8ZGl2XHJcbiAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPXtjc3NDbGFzc2VzLlNVUkZBQ0V9XHJcbiAgICAgICAgICAgICAgICAgICAgcm9sZT1cInN0YXR1c1wiXHJcbiAgICAgICAgICAgICAgICAgICAgYXJpYS1yZWxldmFudD1cImFkZGl0aW9uc1wiXHJcbiAgICAgICAgICAgICAgICA+XHJcbiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9e2Nzc0NsYXNzZXMuTEFCRUx9IGFyaWEtYXRvbWljPVwiZmFsc2VcIj57Y2hpbGRyZW59PC9kaXY+XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXtjc3NDbGFzc2VzLkFDVElPTlN9IGFyaWEtYXRvbWljPVwidHJ1ZVwiPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB7YWN0aW9uICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8Q2xvbmVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21wb25lbnQ9e2FjdGlvbn1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU9e2Nzc0NsYXNzZXMuQUNUSU9OfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLz5cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAge2Rpc21pc3NpYmxlICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8Q2xvbmVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21wb25lbnQ9e2Rpc21pc3NJY29ufVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZhbGxiYWNrPXtJY29uQnV0dG9ufVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT17Y3NzQ2xhc3Nlcy5ESVNNSVNTfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2xpY2s9e29uQ2xvc2V9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgPC9FbGVtZW50PlxyXG4gICAgICAgIDwvTGF5ZXI+XHJcbiAgICApO1xyXG59KTtcclxuXHJcblNuYWNrYmFyLmRpc3BsYXlOYW1lID0gJ01EQ1NuYWNrYmFyJztcclxuXHJcblNuYWNrYmFyLnByb3BUeXBlcyA9IHtcclxuICAgIGxhYmVsOiBQcm9wVHlwZXMuc3RyaW5nLFxyXG4gICAgYWN0aW9uOiBQcm9wVHlwZXMuZWxlbWVudCxcclxuICAgIGRpc21pc3NJY29uOiBQcm9wVHlwZXMubm9kZSxcclxuICAgIG9wZW46IFByb3BUeXBlcy5ib29sLFxyXG4gICAgYXBwZWFyOiBQcm9wVHlwZXMuYm9vbCxcclxuICAgIGxlYWRpbmc6IFByb3BUeXBlcy5ib29sLFxyXG4gICAgc3RhY2tlZDogUHJvcFR5cGVzLmJvb2wsXHJcbiAgICBkaXNtaXNzaWJsZTogUHJvcFR5cGVzLmJvb2wsXHJcbiAgICB0aW1lb3V0OiBQcm9wVHlwZXMubnVtYmVyLFxyXG4gICAgY2xvc2VPbkVzY2FwZTogUHJvcFR5cGVzLmJvb2wsXHJcbiAgICBvbkNsb3NlOiBQcm9wVHlwZXMuZnVuY1xyXG59O1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgU25hY2tiYXI7IiwiZXhwb3J0IHsgZGVmYXVsdCB9IGZyb20gJy4vU25hY2tiYXInOyIsImV4cG9ydCBjb25zdCBjc3NDbGFzc2VzID0ge1xyXG4gICAgUk9PVDogJ21kYy1zd2l0Y2gnLFxyXG4gICAgU0VMRUNURUQ6ICdtZGMtc3dpdGNoLS1zZWxlY3RlZCcsXHJcbiAgICBVTlNFTEVDVEVEOiAnbWRjLXN3aXRjaC0tdW5zZWxlY3RlZCcsXHJcblxyXG4gICAgVFJBQ0s6ICdtZGMtc3dpdGNoX190cmFjaycsXHJcbiAgICBIQU5ETEVfVFJBQ0s6ICdtZGMtc3dpdGNoX19oYW5kbGUtdHJhY2snLFxyXG4gICAgSEFORExFOiAnbWRjLXN3aXRjaF9faGFuZGxlJyxcclxuICAgIFNIQURPVzogJ21kYy1zd2l0Y2hfX3NoYWRvdycsXHJcbiAgICBFTEVWQVRJT05fT1ZFUkxBWTogJ21kYy1lbGV2YXRpb24tb3ZlcmxheScsXHJcbiAgICBSSVBQTEU6ICdtZGMtc3dpdGNoX19yaXBwbGUnLFxyXG4gICAgSUNPTlM6ICdtZGMtc3dpdGNoX19pY29ucycsXHJcblxyXG4gICAgSUNPTjogJ21kYy1zd2l0Y2hfX2ljb24nLFxyXG4gICAgSUNPTl9PTjogJ21kYy1zd2l0Y2hfX2ljb24tLW9uJyxcclxuICAgIElDT05fT0ZGOiAnbWRjLXN3aXRjaF9faWNvbi0tb2ZmJ1xyXG59OyIsImltcG9ydCB7IGZvcndhcmRSZWYsIHVzZUNhbGxiYWNrIH0gZnJvbSAncmVhY3QnO1xyXG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xyXG5pbXBvcnQgY2xhc3NuYW1lcyBmcm9tICdjbGFzc25hbWVzJztcclxuXHJcbmltcG9ydCB7IGNzc0NsYXNzZXMgfSBmcm9tICcuL2NvbnN0YW50cyc7XHJcblxyXG5jb25zdCBTd2l0Y2ggPSBmb3J3YXJkUmVmKCh7XHJcbiAgICBzZWxlY3RlZCA9IGZhbHNlLFxyXG4gICAgb25DaGFuZ2UgPSBGdW5jdGlvbi5wcm90b3R5cGUsXHJcblxyXG4gICAgY2xhc3NOYW1lLFxyXG4gICAgLi4ucHJvcHNcclxufSwgcmVmKSA9PiB7XHJcblxyXG4gICAgY29uc3QgaGFuZGxlQ2xpY2sgPSB1c2VDYWxsYmFjayhldmVudCA9PiB7XHJcbiAgICAgICAgb25DaGFuZ2UoZXZlbnQsICFzZWxlY3RlZCwgZXZlbnQudGFyZ2V0KTtcclxuICAgIH0sIFtzZWxlY3RlZCwgb25DaGFuZ2VdKTtcclxuXHJcbiAgICBjb25zdCBjbGFzc05hbWVzID0gY2xhc3NuYW1lcyhjc3NDbGFzc2VzLlJPT1QsIHtcclxuICAgICAgICBbY3NzQ2xhc3Nlcy5TRUxFQ1RFRF06IHNlbGVjdGVkLFxyXG4gICAgICAgIFtjc3NDbGFzc2VzLlVOU0VMRUNURURdOiAhc2VsZWN0ZWRcclxuICAgIH0sIGNsYXNzTmFtZSk7XHJcblxyXG4gICAgcmV0dXJuIChcclxuICAgICAgICA8YnV0dG9uXHJcbiAgICAgICAgICAgIHJlZj17cmVmfVxyXG4gICAgICAgICAgICB0eXBlPVwiYnV0dG9uXCJcclxuICAgICAgICAgICAgY2xhc3NOYW1lPXtjbGFzc05hbWVzfVxyXG4gICAgICAgICAgICByb2xlPVwic3dpdGNoXCJcclxuICAgICAgICAgICAgYXJpYS1jaGVja2VkPXtzZWxlY3RlZH1cclxuICAgICAgICAgICAgb25DbGljaz17aGFuZGxlQ2xpY2t9XHJcbiAgICAgICAgICAgIHsuLi5wcm9wc31cclxuICAgICAgICA+XHJcbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXtjc3NDbGFzc2VzLlRSQUNLfSAvPlxyXG5cclxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9e2Nzc0NsYXNzZXMuSEFORExFX1RSQUNLfT5cclxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXtjc3NDbGFzc2VzLkhBTkRMRX0+XHJcbiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9e2Nzc0NsYXNzZXMuU0hBRE9XfT5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9e2Nzc0NsYXNzZXMuRUxFVkFUSU9OX09WRVJMQVl9IC8+XHJcbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXtjc3NDbGFzc2VzLlJJUFBMRX0gLz5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9e2Nzc0NsYXNzZXMuSUNPTlN9PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8c3ZnIGNsYXNzTmFtZT17YCR7Y3NzQ2xhc3Nlcy5JQ09OfSAke2Nzc0NsYXNzZXMuSUNPTl9PTn1gfSB2aWV3Qm94PVwiMCAwIDI0IDI0XCI+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8cGF0aCBkPVwiTTE5LjY5LDUuMjNMOC45NiwxNS45NmwtNC4yMy00LjIzTDIuOTYsMTMuNWw2LDZMMjEuNDYsN0wxOS42OSw1LjIzelwiIC8+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDwvc3ZnPlxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPHN2ZyBjbGFzc05hbWU9e2Ake2Nzc0NsYXNzZXMuSUNPTn0gJHtjc3NDbGFzc2VzLklDT05fT0ZGfWB9IHZpZXdCb3g9XCIwIDAgMjQgMjRcIj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxwYXRoIGQ9XCJNMjAgMTNINHYtMmgxNnYyelwiIC8+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDwvc3ZnPlxyXG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgIDwvYnV0dG9uPlxyXG4gICAgKTtcclxufSk7XHJcblxyXG5Td2l0Y2guZGlzcGxheU5hbWUgPSAnTURDU3dpdGNoJztcclxuXHJcblN3aXRjaC5wcm9wVHlwZXMgPSB7XHJcbiAgICBjaGVja2VkOiBQcm9wVHlwZXMuYm9vbCxcclxuICAgIGRpc2FibGVkOiBQcm9wVHlwZXMuYm9vbCxcclxuICAgIG9uQ2hhbmdlOiBQcm9wVHlwZXMuZnVuY1xyXG59O1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgU3dpdGNoOyIsImV4cG9ydCB7IGRlZmF1bHQgfSBmcm9tICcuL1N3aXRjaCc7IiwiZXhwb3J0IGNvbnN0IHRhYkNsYXNzTmFtZXMgPSB7XHJcbiAgICBST09UOiAnbWRjLXRhYicsXHJcbiAgICBBQ1RJVkU6ICdtZGMtdGFiLS1hY3RpdmUnLFxyXG4gICAgU1RBQ0tFRDogJ21kYy10YWItLXN0YWNrZWQnLFxyXG4gICAgTUlOX1dJRFRIOiAnbWRjLXRhYi0tbWluLXdpZHRoJyxcclxuXHJcbiAgICBDT05URU5UOiAnbWRjLXRhYl9fY29udGVudCcsXHJcbiAgICBJQ09OOiAnbWRjLXRhYl9faWNvbicsXHJcbiAgICBMQUJFTDogJ21kYy10YWJfX3RleHQtbGFiZWwnLFxyXG4gICAgUklQUExFOiAnbWRjLXRhYl9fcmlwcGxlJ1xyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IGJhckNzc0NsYXNzZXMgPSB7XHJcbiAgICBST09UOiAnbWRjLXRhYi1iYXInXHJcbn07XHJcblxyXG5leHBvcnQgY29uc3Qgc2Nyb2xsZXJDc3NDbGFzc2VzID0ge1xyXG4gICAgUk9PVDogJ21kYy10YWItc2Nyb2xsZXInLFxyXG4gICAgQUxJR046ICdtZGMtdGFiLXNjcm9sbGVyLS1hbGlnbicsXHJcbiAgICBBTklNQVRJTkc6ICdtZGMtdGFiLXNjcm9sbGVyLS1hbmltYXRpbmcnLFxyXG5cclxuICAgIFNDUk9MTF9BUkVBOiAnbWRjLXRhYi1zY3JvbGxlcl9fc2Nyb2xsLWFyZWEnLFxyXG4gICAgU0NST0xMX0FSRUFfU0NST0xMOiAnbWRjLXRhYi1zY3JvbGxlcl9fc2Nyb2xsLWFyZWEtLXNjcm9sbCcsXHJcbiAgICBTQ1JPTExfQ09OVEVOVDogJ21kYy10YWItc2Nyb2xsZXJfX3Njcm9sbC1jb250ZW50J1xyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IGluZGljYXRvckNzc0NsYXNzZXMgPSB7XHJcbiAgICBST09UOiAnbWRjLXRhYi1pbmRpY2F0b3InLFxyXG4gICAgQUNUSVZFOiAnbWRjLXRhYi1pbmRpY2F0b3ItLWFjdGl2ZScsXHJcbiAgICBGQURFOiAnbWRjLXRhYi1pbmRpY2F0b3ItLWZhZGUnLFxyXG4gICAgTk9fVFJBTlNJVElPTjogJ21kYy10YWItaW5kaWNhdG9yLS1uby10cmFuc2l0aW9uJyxcclxuXHJcbiAgICBDT05URU5UOiAnbWRjLXRhYi1pbmRpY2F0b3JfX2NvbnRlbnQnLFxyXG4gICAgQ09OVEVOVF9JQ09OOiAnbWRjLXRhYi1pbmRpY2F0b3JfX2NvbnRlbnQtLWljb24gbWF0ZXJpYWwtaWNvbnMnLFxyXG4gICAgQ09OVEVOVF9VTkRFUkxJTkU6ICdtZGMtdGFiLWluZGljYXRvcl9fY29udGVudC0tdW5kZXJsaW5lJ1xyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IEFsaWduID0ge1xyXG4gICAgU1RBUlQ6ICdzdGFydCcsXHJcbiAgICBDRU5URVI6ICdjZW50ZXInLFxyXG4gICAgRU5EOiAnZW5kJ1xyXG59OyIsImltcG9ydCB7IGNyZWF0ZUNvbnRleHQgfSBmcm9tICdyZWFjdCc7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBjcmVhdGVDb250ZXh0KCk7IiwiaW1wb3J0IHsgZm9yd2FyZFJlZiwgdXNlQ29udGV4dCwgdXNlSW1wZXJhdGl2ZUhhbmRsZSwgdXNlUmVmIH0gZnJvbSAncmVhY3QnO1xyXG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xyXG5pbXBvcnQgY2xhc3NuYW1lcyBmcm9tICdjbGFzc25hbWVzJztcclxuXHJcbmltcG9ydCB7IHVzZVVwZGF0ZWRTeW5jIH0gZnJvbSAnLi4vaG9va3MnO1xyXG5cclxuaW1wb3J0IHsgaW5kaWNhdG9yQ3NzQ2xhc3NlcyBhcyBjc3NDbGFzc2VzIH0gZnJvbSAnLi9jb25zdGFudHMnO1xyXG5pbXBvcnQgVGFiQ29udGV4dCBmcm9tICcuL2NvbnRleHQnO1xyXG5cclxuY29uc3QgVGFiSW5kaWNhdG9yID0gZm9yd2FyZFJlZigoe1xyXG4gICAgaWNvbixcclxuICAgIGFjdGl2ZSA9IGZhbHNlLFxyXG4gICAgZmFkZSA9IGZhbHNlLFxyXG4gICAgdW5kZXJsaW5lID0gIWljb24sXHJcblxyXG4gICAgLi4ucHJvcHNcclxufSwgcmVmKSA9PiB7XHJcbiAgICBjb25zdCB7IHByZXZpb3VzVGFiIH0gPSB1c2VDb250ZXh0KFRhYkNvbnRleHQpO1xyXG5cclxuICAgIGNvbnN0IHJvb3RSZWYgPSB1c2VSZWYoKTtcclxuICAgIGNvbnN0IGNvbnRlbnRSZWYgPSB1c2VSZWYoKTtcclxuXHJcbiAgICB1c2VJbXBlcmF0aXZlSGFuZGxlKHJlZiwgKCkgPT4gcm9vdFJlZi5jdXJyZW50KTtcclxuXHJcbiAgICB1c2VVcGRhdGVkU3luYygoKSA9PiB7XHJcbiAgICAgICAgaWYgKGZhZGUgfHwgIWFjdGl2ZSB8fCAhcHJldmlvdXNUYWIpIHJldHVybjtcclxuXHJcbiAgICAgICAgY29uc3QgYWN0aXZlSW5kaWNhdG9yID0gcm9vdFJlZi5jdXJyZW50O1xyXG4gICAgICAgIGNvbnN0IHByZXZpb3VzSW5kaWNhdG9yID0gcHJldmlvdXNUYWIucXVlcnlTZWxlY3RvcignLm1kYy10YWItaW5kaWNhdG9yJyk7XHJcbiAgICAgICAgY29uc3QgcHJldmlvdXNJbmRpY2F0b3JDbGllbnRSZWN0ID0gcHJldmlvdXNJbmRpY2F0b3IuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XHJcbiAgICAgICAgY29uc3QgYWN0aXZlSW5kaWNhdG9yQ2xpZW50UmVjdCA9IGFjdGl2ZUluZGljYXRvci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcclxuXHJcbiAgICAgICAgY29uc3QgeFBvc2l0aW9uID0gcHJldmlvdXNJbmRpY2F0b3JDbGllbnRSZWN0LmxlZnQgLSBhY3RpdmVJbmRpY2F0b3JDbGllbnRSZWN0LmxlZnQ7XHJcbiAgICAgICAgY29uc3Qgd2lkdGhEZWx0YSA9IHByZXZpb3VzSW5kaWNhdG9yQ2xpZW50UmVjdC53aWR0aCAvIGFjdGl2ZUluZGljYXRvckNsaWVudFJlY3Qud2lkdGg7XHJcblxyXG4gICAgICAgIHJvb3RSZWYuY3VycmVudC5jbGFzc0xpc3QuYWRkKGNzc0NsYXNzZXMuTk9fVFJBTlNJVElPTik7XHJcbiAgICAgICAgY29udGVudFJlZi5jdXJyZW50LnN0eWxlLnRyYW5zZm9ybSA9IGB0cmFuc2xhdGVYKCR7eFBvc2l0aW9ufXB4KSBzY2FsZVgoJHt3aWR0aERlbHRhfSlgO1xyXG4gICAgICAgIC8vIEZvcmNlIHJlcGFpbnQgYmVmb3JlIHVwZGF0aW5nIGNsYXNzZXMgYW5kIHRyYW5zZm9ybSB0byBlbnN1cmUgdGhlIHRyYW5zZm9ybSBwcm9wZXJseSB0YWtlcyBlZmZlY3RcclxuICAgICAgICBjb250ZW50UmVmLmN1cnJlbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XHJcbiAgICAgICAgcm9vdFJlZi5jdXJyZW50LmNsYXNzTGlzdC5yZW1vdmUoY3NzQ2xhc3Nlcy5OT19UUkFOU0lUSU9OKTtcclxuICAgICAgICBjb250ZW50UmVmLmN1cnJlbnQuc3R5bGUudHJhbnNmb3JtID0gJyc7XHJcbiAgICB9LCBbZmFkZSwgYWN0aXZlXSk7XHJcblxyXG4gICAgY29uc3Qgcm9vdENsYXNzTmFtZXMgPSBjbGFzc25hbWVzKGNzc0NsYXNzZXMuUk9PVCwge1xyXG4gICAgICAgIFtjc3NDbGFzc2VzLkFDVElWRV06IGFjdGl2ZSxcclxuICAgICAgICBbY3NzQ2xhc3Nlcy5GQURFXTogZmFkZVxyXG4gICAgfSk7XHJcblxyXG4gICAgY29uc3QgY29udGVudENsYXNzTmFtZXMgPSBjbGFzc25hbWVzKGNzc0NsYXNzZXMuQ09OVEVOVCwge1xyXG4gICAgICAgIFtjc3NDbGFzc2VzLkNPTlRFTlRfSUNPTl06IGljb24sXHJcbiAgICAgICAgW2Nzc0NsYXNzZXMuQ09OVEVOVF9VTkRFUkxJTkVdOiB1bmRlcmxpbmVcclxuICAgIH0pO1xyXG5cclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgPHNwYW4gcmVmPXtyb290UmVmfSBjbGFzc05hbWU9e3Jvb3RDbGFzc05hbWVzfSB7Li4ucHJvcHN9PlxyXG4gICAgICAgICAgICA8c3BhblxyXG4gICAgICAgICAgICAgICAgcmVmPXtjb250ZW50UmVmfVxyXG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lPXtjb250ZW50Q2xhc3NOYW1lc31cclxuICAgICAgICAgICAgPlxyXG4gICAgICAgICAgICAgICAge2ljb259XHJcbiAgICAgICAgICAgIDwvc3Bhbj5cclxuICAgICAgICA8L3NwYW4+XHJcbiAgICApO1xyXG59KTtcclxuXHJcblRhYkluZGljYXRvci5kaXNwbGF5TmFtZSA9ICdNRENUYWJJbmRpY2F0b3InO1xyXG5cclxuVGFiSW5kaWNhdG9yLnByb3BUeXBlcyA9IHtcclxuICAgIGljb246IFByb3BUeXBlcy5ub2RlLFxyXG4gICAgYWN0aXZlOiBQcm9wVHlwZXMuYm9vbCxcclxuICAgIGZhZGU6IFByb3BUeXBlcy5ib29sLFxyXG4gICAgdW5kZXJsaW5lOiBQcm9wVHlwZXMuYm9vbFxyXG59O1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgVGFiSW5kaWNhdG9yOyIsImltcG9ydCB7IGZvcndhcmRSZWYsIHVzZVJlZiwgdXNlQ2FsbGJhY2ssIHVzZUltcGVyYXRpdmVIYW5kbGUgfSBmcm9tICdyZWFjdCc7XHJcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XHJcbmltcG9ydCBjbGFzc25hbWVzIGZyb20gJ2NsYXNzbmFtZXMnO1xyXG5cclxuaW1wb3J0IHsgQ2xvbmUgfSBmcm9tICcuLi9jb21wb25lbnQnO1xyXG5pbXBvcnQgSWNvbiBmcm9tICcuLi9pY29uJztcclxuXHJcbmltcG9ydCB7IHRhYkNsYXNzTmFtZXMgYXMgY3NzQ2xhc3NlcyB9IGZyb20gJy4vY29uc3RhbnRzJztcclxuaW1wb3J0IFRhYkluZGljYXRvciBmcm9tICcuL1RhYkluZGljYXRvcic7XHJcblxyXG5jb25zdCBUYWIgPSBmb3J3YXJkUmVmKCh7XHJcbiAgICB2YWx1ZSxcclxuICAgIGljb24sXHJcbiAgICBsYWJlbCxcclxuICAgIGluZGljYXRvckljb24sXHJcbiAgICBhY3RpdmUgPSBmYWxzZSxcclxuICAgIHN0YWNrZWQgPSBmYWxzZSxcclxuICAgIG1pbldpZHRoID0gZmFsc2UsXHJcbiAgICBtaW5XaWR0aEluZGljYXRvciA9IGZhbHNlLFxyXG4gICAgZmFkZSA9IGZhbHNlLFxyXG4gICAgdW5kZXJsaW5lID0gIWluZGljYXRvckljb24sXHJcbiAgICBvbkNsaWNrID0gRnVuY3Rpb24ucHJvdG90eXBlLFxyXG5cclxuICAgIGVsZW1lbnQgPSAnYnV0dG9uJyxcclxuICAgIGNvbXBvbmVudDogRWxlbWVudCA9IGVsZW1lbnQsXHJcbiAgICBjbGFzc05hbWUsXHJcbiAgICBjaGlsZHJlbiA9IGxhYmVsLFxyXG4gICAgLi4ucHJvcHNcclxufSwgcmVmKSA9PiB7XHJcbiAgICBjb25zdCByb290UmVmID0gdXNlUmVmKCk7XHJcblxyXG4gICAgdXNlSW1wZXJhdGl2ZUhhbmRsZShyZWYsICgpID0+IHJvb3RSZWYuY3VycmVudCk7XHJcblxyXG4gICAgY29uc3QgaGFuZGxlQ2xpY2sgPSB1c2VDYWxsYmFjaygoKSA9PiB7XHJcbiAgICAgICAgb25DbGljayhyb290UmVmLmN1cnJlbnQsIHZhbHVlKTtcclxuICAgIH0sIFt2YWx1ZSwgb25DbGlja10pO1xyXG5cclxuICAgIGNvbnN0IGNsYXNzTmFtZXMgPSBjbGFzc25hbWVzKGNzc0NsYXNzZXMuUk9PVCwge1xyXG4gICAgICAgIFtjc3NDbGFzc2VzLkFDVElWRV06IGFjdGl2ZSxcclxuICAgICAgICBbY3NzQ2xhc3Nlcy5TVEFDS0VEXTogc3RhY2tlZCxcclxuICAgICAgICBbY3NzQ2xhc3Nlcy5NSU5fV0lEVEhdOiBtaW5XaWR0aFxyXG4gICAgfSwgY2xhc3NOYW1lKTtcclxuXHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAgIDxFbGVtZW50XHJcbiAgICAgICAgICAgIHJlZj17cm9vdFJlZn1cclxuICAgICAgICAgICAgY2xhc3NOYW1lPXtjbGFzc05hbWVzfVxyXG4gICAgICAgICAgICBkYXRhLXZhbHVlPXt2YWx1ZX1cclxuICAgICAgICAgICAgcm9sZT1cInRhYlwiXHJcbiAgICAgICAgICAgIGFyaWEtc2VsZWN0ZWQ9e2FjdGl2ZSA/ICd0cnVlJyA6ICdmYWxzZSd9XHJcbiAgICAgICAgICAgIHRhYkluZGV4PXthY3RpdmUgPyAwIDogLTF9XHJcbiAgICAgICAgICAgIG9uQ2xpY2s9e2hhbmRsZUNsaWNrfVxyXG4gICAgICAgICAgICB7Li4ucHJvcHN9XHJcbiAgICAgICAgPlxyXG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17Y3NzQ2xhc3Nlcy5DT05URU5UfT5cclxuICAgICAgICAgICAgICAgIHtpY29uICYmXHJcbiAgICAgICAgICAgICAgICAgICAgPENsb25lXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudD17aWNvbn1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZmFsbGJhY2s9e0ljb259XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT17Y3NzQ2xhc3Nlcy5JQ09OfVxyXG4gICAgICAgICAgICAgICAgICAgIC8+XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAge2NoaWxkcmVuICYmXHJcbiAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3NOYW1lPXtjc3NDbGFzc2VzLkxBQkVMfT57Y2hpbGRyZW59PC9zcGFuPlxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHttaW5XaWR0aEluZGljYXRvciAmJlxyXG4gICAgICAgICAgICAgICAgICAgIDxUYWJJbmRpY2F0b3JcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWNvbj17aW5kaWNhdG9ySWNvbn1cclxuICAgICAgICAgICAgICAgICAgICAgICAgYWN0aXZlPXthY3RpdmV9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZhZGU9e2ZhZGV9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHVuZGVybGluZT17dW5kZXJsaW5lfVxyXG4gICAgICAgICAgICAgICAgICAgIC8+XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIDwvZGl2PlxyXG5cclxuICAgICAgICAgICAgeyFtaW5XaWR0aEluZGljYXRvciAmJlxyXG4gICAgICAgICAgICAgICAgPFRhYkluZGljYXRvclxyXG4gICAgICAgICAgICAgICAgICAgIGljb249e2luZGljYXRvckljb259XHJcbiAgICAgICAgICAgICAgICAgICAgYWN0aXZlPXthY3RpdmV9XHJcbiAgICAgICAgICAgICAgICAgICAgZmFkZT17ZmFkZX1cclxuICAgICAgICAgICAgICAgICAgICB1bmRlcmxpbmU9e3VuZGVybGluZX1cclxuICAgICAgICAgICAgICAgIC8+XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXtjc3NDbGFzc2VzLlJJUFBMRX0gLz5cclxuICAgICAgICA8L0VsZW1lbnQ+XHJcbiAgICApO1xyXG59KTtcclxuXHJcblRhYi5kaXNwbGF5TmFtZSA9ICdNRENUYWInO1xyXG5cclxuVGFiLnByb3BUeXBlcyA9IHtcclxuICAgIHZhbHVlOiBQcm9wVHlwZXMuYW55LFxyXG4gICAgaWNvbjogUHJvcFR5cGVzLm5vZGUsXHJcbiAgICBsYWJlbDogUHJvcFR5cGVzLm5vZGUsXHJcbiAgICBpbmRpY2F0b3JJY29uOiBQcm9wVHlwZXMubm9kZSxcclxuICAgIGFjdGl2ZTogUHJvcFR5cGVzLmJvb2wsXHJcbiAgICBzdGFja2VkOiBQcm9wVHlwZXMuYm9vbCxcclxuICAgIG1pbldpZHRoOiBQcm9wVHlwZXMuYm9vbCxcclxuICAgIG1pbldpZHRoSW5kaWNhdG9yOiBQcm9wVHlwZXMuYm9vbCxcclxuICAgIGZhZGU6IFByb3BUeXBlcy5ib29sLFxyXG4gICAgdW5kZXJsaW5lOiBQcm9wVHlwZXMuYm9vbCxcclxuICAgIG9uQWN0aXZhdGU6IFByb3BUeXBlcy5mdW5jXHJcbn07XHJcblxyXG5leHBvcnQgZGVmYXVsdCBUYWI7IiwiaW1wb3J0IHsgZm9yd2FyZFJlZiwgdXNlUmVmIH0gZnJvbSAncmVhY3QnO1xyXG5pbXBvcnQgY2xhc3NuYW1lcyBmcm9tICdjbGFzc25hbWVzJztcclxuXHJcbmltcG9ydCB7IHVzZU1vdW50ZWQsIHVzZVVwZGF0ZWQgfSBmcm9tICcuLi9ob29rcyc7XHJcblxyXG5pbXBvcnQgeyBzY3JvbGxlckNzc0NsYXNzZXMgYXMgY3NzQ2xhc3NlcyB9IGZyb20gJy4vY29uc3RhbnRzJztcclxuXHJcbmNvbnN0IFRhYlNjcm9sbGVyID0gZm9yd2FyZFJlZigoe1xyXG4gICAgYWxpZ24sXHJcbiAgICBhY3RpdmVUYWIsXHJcblxyXG4gICAgY2hpbGRyZW4sXHJcbiAgICAuLi5wcm9wc1xyXG59LCByZWYpID0+IHtcclxuICAgIGNvbnN0IHNjcm9sbEFyZWFSZWYgPSB1c2VSZWYoKTtcclxuICAgIGNvbnN0IHNjcm9sbENvbnRlbnRSZWYgPSB1c2VSZWYoKTtcclxuXHJcbiAgICB1c2VNb3VudGVkKCgpID0+IHtcclxuICAgICAgICBjb25zdCBzY3JvbGxBcmVhV2lkdGggPSBzY3JvbGxBcmVhUmVmLmN1cnJlbnQub2Zmc2V0V2lkdGg7XHJcbiAgICAgICAgY29uc3Qgc2Nyb2xsQ29udGVudFdpZHRoID0gc2Nyb2xsQ29udGVudFJlZi5jdXJyZW50Lm9mZnNldFdpZHRoO1xyXG5cclxuICAgICAgICBpZiAoc2Nyb2xsQ29udGVudFdpZHRoID4gc2Nyb2xsQXJlYVdpZHRoKSB7XHJcbiAgICAgICAgICAgIHNjcm9sbEFyZWFSZWYuY3VycmVudC5jbGFzc0xpc3QuYWRkKGNzc0NsYXNzZXMuU0NST0xMX0FSRUFfU0NST0xMKTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICB1c2VVcGRhdGVkKCgpID0+IHtcclxuICAgICAgICBpZiAoIWFjdGl2ZVRhYikgcmV0dXJuO1xyXG5cclxuICAgICAgICBjb25zdCBzY3JvbGxBcmVhV2lkdGggPSBzY3JvbGxBcmVhUmVmLmN1cnJlbnQub2Zmc2V0V2lkdGg7XHJcbiAgICAgICAgY29uc3QgdGFiV2lkdGggPSBhY3RpdmVUYWIub2Zmc2V0V2lkdGg7XHJcbiAgICAgICAgY29uc3QgdGFiSGFsZldpZHRoID0gdGFiV2lkdGggKiAwLjU7XHJcbiAgICAgICAgY29uc3Qgb2Zmc2V0TGVmdCA9IGFjdGl2ZVRhYi5vZmZzZXRMZWZ0IC0gc2Nyb2xsQXJlYVJlZi5jdXJyZW50LnNjcm9sbExlZnQ7XHJcbiAgICAgICAgY29uc3Qgb2Zmc2V0TGVmdERlbHRhID0gYWN0aXZlVGFiLm9mZnNldExlZnQgLSBzY3JvbGxBcmVhUmVmLmN1cnJlbnQuc2Nyb2xsTGVmdDtcclxuICAgICAgICBjb25zdCBvZmZzZXRSaWdodCA9IGFjdGl2ZVRhYi5vZmZzZXRMZWZ0ICsgdGFiV2lkdGggLSBzY3JvbGxBcmVhUmVmLmN1cnJlbnQuc2Nyb2xsTGVmdDtcclxuICAgICAgICBjb25zdCBvZmZzZXRSaWdodERlbHRhID0gc2Nyb2xsQXJlYVdpZHRoIC0gb2Zmc2V0UmlnaHQ7XHJcblxyXG4gICAgICAgIGlmIChvZmZzZXRSaWdodCA+IHNjcm9sbEFyZWFXaWR0aCB8fCBvZmZzZXRSaWdodERlbHRhIDwgdGFiSGFsZldpZHRoKSB7XHJcbiAgICAgICAgICAgIHNjcm9sbEFyZWFSZWYuY3VycmVudC5zY3JvbGxCeSh7XHJcbiAgICAgICAgICAgICAgICBsZWZ0OiBvZmZzZXRSaWdodCA+IHNjcm9sbEFyZWFXaWR0aCA/IE1hdGguYWJzKG9mZnNldFJpZ2h0RGVsdGEpICsgdGFiSGFsZldpZHRoIDogdGFiSGFsZldpZHRoIC0gb2Zmc2V0UmlnaHREZWx0YSxcclxuICAgICAgICAgICAgICAgIGJlaGF2aW9yOiAnc21vb3RoJ1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9IGVsc2UgaWYgKG9mZnNldExlZnQgPCAwIHx8IG9mZnNldExlZnREZWx0YSA8IHRhYkhhbGZXaWR0aCkge1xyXG4gICAgICAgICAgICBzY3JvbGxBcmVhUmVmLmN1cnJlbnQuc2Nyb2xsQnkoe1xyXG4gICAgICAgICAgICAgICAgbGVmdDogb2Zmc2V0TGVmdCA8IDAgPyBvZmZzZXRMZWZ0RGVsdGEgLSB0YWJIYWxmV2lkdGggOiAtKHRhYkhhbGZXaWR0aCAtIG9mZnNldExlZnREZWx0YSksXHJcbiAgICAgICAgICAgICAgICBiZWhhdmlvcjogJ3Ntb290aCdcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSwgW2FjdGl2ZVRhYl0pO1xyXG5cclxuICAgIGNvbnN0IGNsYXNzTmFtZXMgPSBjbGFzc25hbWVzKGNzc0NsYXNzZXMuUk9PVCwge1xyXG4gICAgICAgIFtgJHtjc3NDbGFzc2VzLkFMSUdOfS0ke2FsaWdufWBdOiBhbGlnblxyXG4gICAgfSk7XHJcblxyXG4gICAgcmV0dXJuIChcclxuICAgICAgICA8ZGl2IHJlZj17cmVmfSBjbGFzc05hbWU9e2NsYXNzTmFtZXN9IHsuLi5wcm9wc30+XHJcbiAgICAgICAgICAgIDxkaXYgcmVmPXtzY3JvbGxBcmVhUmVmfSBjbGFzc05hbWU9e2Nzc0NsYXNzZXMuU0NST0xMX0FSRUF9PlxyXG4gICAgICAgICAgICAgICAgPGRpdiByZWY9e3Njcm9sbENvbnRlbnRSZWZ9IGNsYXNzTmFtZT17Y3NzQ2xhc3Nlcy5TQ1JPTExfQ09OVEVOVH0+XHJcbiAgICAgICAgICAgICAgICAgICAge2NoaWxkcmVufVxyXG4gICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgIDwvZGl2PlxyXG4gICAgKTtcclxufSk7XHJcblxyXG5UYWJTY3JvbGxlci5kaXNwbGF5TmFtZSA9ICdNRENUYWJTY3JvbGxlcic7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBUYWJTY3JvbGxlcjsiLCJpbXBvcnQgeyBDaGlsZHJlbiwgZm9yd2FyZFJlZiwgdXNlQ2FsbGJhY2ssIHVzZUVmZmVjdCwgdXNlSW1wZXJhdGl2ZUhhbmRsZSwgdXNlUmVmIH0gZnJvbSAncmVhY3QnO1xyXG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xyXG5pbXBvcnQgY2xhc3NuYW1lcyBmcm9tICdjbGFzc25hbWVzJztcclxuXHJcbmltcG9ydCB7IGlzVW5kZWZpbmVkIH0gZnJvbSAnLi4vdHlwZXMnO1xyXG5pbXBvcnQgeyBjcmVhdGUsIGNsb25lIH0gZnJvbSAnLi4vY29tcG9uZW50JztcclxuXHJcbmltcG9ydCB7IGJhckNzc0NsYXNzZXMgYXMgY3NzQ2xhc3NlcywgdGFiQ2xhc3NOYW1lcywgQWxpZ24gfSBmcm9tICcuL2NvbnN0YW50cyc7XHJcbmltcG9ydCBUYWJDb250ZXh0IGZyb20gJy4vY29udGV4dCc7XHJcbmltcG9ydCBUYWIgZnJvbSAnLi9UYWInO1xyXG5pbXBvcnQgVGFiU2Nyb2xsZXIgZnJvbSAnLi9UYWJTY3JvbGxlcic7XHJcblxyXG5jb25zdCBUYWJCYXIgPSBmb3J3YXJkUmVmKCh7XHJcbiAgICB0YWJzLFxyXG4gICAgdmFsdWUsXHJcbiAgICBhbGlnbixcclxuICAgIGluZGljYXRvckljb24sXHJcbiAgICBzdGFja2VkID0gZmFsc2UsXHJcbiAgICBtaW5XaWR0aCA9IGZhbHNlLFxyXG4gICAgbWluV2lkdGhJbmRpY2F0b3IgPSBmYWxzZSxcclxuICAgIGZhZGUgPSBmYWxzZSxcclxuICAgIGljb25JbmRpY2F0b3IgPSBCb29sZWFuKGluZGljYXRvckljb24pLFxyXG4gICAgdW5kZXJsaW5lSW5kaWNhdG9yID0gIWljb25JbmRpY2F0b3IsXHJcbiAgICBvbkNoYW5nZSA9IEZ1bmN0aW9uLnByb3RvdHlwZSxcclxuXHJcbiAgICBlbGVtZW50ID0gJ2RpdicsXHJcbiAgICBjb21wb25lbnQ6IEVsZW1lbnQgPSBlbGVtZW50LFxyXG4gICAgY2xhc3NOYW1lLFxyXG4gICAgY2hpbGRyZW4gPSB0YWJzPy5tYXAodGFiID0+IGNyZWF0ZShUYWIsIHRhYikpLFxyXG4gICAgLi4ucHJvcHNcclxufSwgcmVmKSA9PiB7XHJcbiAgICBjb25zdCByb290UmVmID0gdXNlUmVmKCk7XHJcbiAgICBjb25zdCBhY3RpdmVUYWJSZWYgPSB1c2VSZWYoKTtcclxuICAgIGNvbnN0IHByZXZpb3VzVGFiUmVmID0gdXNlUmVmKCk7XHJcblxyXG4gICAgdXNlSW1wZXJhdGl2ZUhhbmRsZShyZWYsICgpID0+IHJvb3RSZWYuY3VycmVudCk7XHJcblxyXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgICAgICBhY3RpdmVUYWJSZWYuY3VycmVudCA9IHJvb3RSZWYuY3VycmVudC5xdWVyeVNlbGVjdG9yKGAuJHt0YWJDbGFzc05hbWVzLkFDVElWRX1gKTtcclxuICAgIH0sIFtdKTtcclxuXHJcbiAgICBjb25zdCBoYW5kbGVUYWJDbGljayA9IHVzZUNhbGxiYWNrKChlbGVtZW50LCB2YWx1ZSkgPT4ge1xyXG4gICAgICAgIHByZXZpb3VzVGFiUmVmLmN1cnJlbnQgPSBhY3RpdmVUYWJSZWYuY3VycmVudDtcclxuICAgICAgICBhY3RpdmVUYWJSZWYuY3VycmVudCA9IGVsZW1lbnQ7XHJcbiAgICAgICAgb25DaGFuZ2UodmFsdWUpO1xyXG4gICAgfSwgW29uQ2hhbmdlXSk7XHJcblxyXG4gICAgY29uc3QgY2xhc3NOYW1lcyA9IGNsYXNzbmFtZXMoY3NzQ2xhc3Nlcy5ST09ULCBjbGFzc05hbWUpO1xyXG5cclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgPEVsZW1lbnRcclxuICAgICAgICAgICAgcmVmPXtyb290UmVmfVxyXG4gICAgICAgICAgICBjbGFzc05hbWU9e2NsYXNzTmFtZXN9XHJcbiAgICAgICAgICAgIHJvbGU9XCJ0YWJsaXN0XCJcclxuICAgICAgICAgICAgey4uLnByb3BzfVxyXG4gICAgICAgID5cclxuICAgICAgICAgICAgeyFpc1VuZGVmaW5lZCh2YWx1ZSkgP1xyXG4gICAgICAgICAgICAgICAgPFRhYkNvbnRleHQuUHJvdmlkZXIgdmFsdWU9e3tcclxuICAgICAgICAgICAgICAgICAgICBhY3RpdmVUYWI6IGFjdGl2ZVRhYlJlZi5jdXJyZW50LFxyXG4gICAgICAgICAgICAgICAgICAgIHByZXZpb3VzVGFiOiBwcmV2aW91c1RhYlJlZi5jdXJyZW50XHJcbiAgICAgICAgICAgICAgICB9fT5cclxuICAgICAgICAgICAgICAgICAgICA8VGFiU2Nyb2xsZXJcclxuICAgICAgICAgICAgICAgICAgICAgICAgYWxpZ249e2FsaWdufVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBhY3RpdmVUYWI9e2FjdGl2ZVRhYlJlZi5jdXJyZW50fVxyXG4gICAgICAgICAgICAgICAgICAgID5cclxuICAgICAgICAgICAgICAgICAgICAgICAge0NoaWxkcmVuLm1hcChjaGlsZHJlbiwgKHRhYiwgaW5kZXgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHRhYlZhbHVlID0gaXNVbmRlZmluZWQodGFiLnByb3BzLnZhbHVlKSA/IGluZGV4IDogdGFiLnByb3BzLnZhbHVlO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjbG9uZSh0YWIsIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdGFiVmFsdWUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWN0aXZlOiB0YWJWYWx1ZSA9PT0gdmFsdWUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kaWNhdG9ySWNvbjogdGFiLnByb3BzLmluZGljYXRvckljb24gfHwgaW5kaWNhdG9ySWNvbixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFja2VkOiB0YWIucHJvcHMuc3RhY2tlZCB8fCBzdGFja2VkLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1pbldpZHRoOiB0YWIucHJvcHMubWluV2lkdGggfHwgbWluV2lkdGgsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWluV2lkdGhJbmRpY2F0b3I6IHRhYi5wcm9wcy5taW5XaWR0aEluZGljYXRvciB8fCBtaW5XaWR0aEluZGljYXRvcixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmYWRlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVuZGVybGluZTogdW5kZXJsaW5lSW5kaWNhdG9yLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2xpY2s6IGhhbmRsZVRhYkNsaWNrXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSl9XHJcbiAgICAgICAgICAgICAgICAgICAgPC9UYWJTY3JvbGxlcj5cclxuICAgICAgICAgICAgICAgIDwvVGFiQ29udGV4dC5Qcm92aWRlcj5cclxuICAgICAgICAgICAgICAgIDpcclxuICAgICAgICAgICAgICAgIGNoaWxkcmVuXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICA8L0VsZW1lbnQ+XHJcbiAgICApO1xyXG59KTtcclxuXHJcblRhYkJhci5kaXNwbGF5TmFtZSA9ICdNRENUYWJCYXInO1xyXG5cclxuVGFiQmFyLnByb3BUeXBlcyA9IHtcclxuICAgIGFsaWduOiBQcm9wVHlwZXMub25lT2YoT2JqZWN0LnZhbHVlcyhBbGlnbikpLFxyXG4gICAgaW5kaWNhdG9ySWNvbjogUHJvcFR5cGVzLm5vZGUsXHJcbiAgICBzdGFja2VkOiBQcm9wVHlwZXMuYm9vbCxcclxuICAgIG1pbldpZHRoOiBQcm9wVHlwZXMuYm9vbCxcclxuICAgIGZhZGU6IFByb3BUeXBlcy5ib29sLFxyXG4gICAgaWNvbkluZGljYXRvcjogUHJvcFR5cGVzLmJvb2wsXHJcbiAgICB1bmRlcmxpbmVJbmRpY2F0b3I6IFByb3BUeXBlcy5ib29sLFxyXG4gICAgb25DaGFuZ2U6IFByb3BUeXBlcy5mdW5jXHJcbn07XHJcblxyXG5UYWJCYXIuQWxpZ24gPSBBbGlnbjtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IFRhYkJhcjsiLCJleHBvcnQgeyBkZWZhdWx0IGFzIFRhYiB9IGZyb20gJy4vVGFiJztcclxuZXhwb3J0IHsgZGVmYXVsdCBhcyBUYWJCYXIgfSBmcm9tICcuL1RhYkJhcic7IiwiZXhwb3J0IGNvbnN0IG51bWJlcnMgPSB7XHJcbiAgICBCT1VOREVEX0FOQ0hPUl9HQVA6IDQsXHJcbiAgICBVTkJPVU5ERURfQU5DSE9SX0dBUDogOCxcclxuICAgIE1JTl9WSUVXUE9SVF9UT09MVElQX1RIUkVTSE9MRDogOCxcclxuICAgIEVOVEVSX0RVUkFUSU9OX01TOiAxNTAsXHJcbiAgICBFWElUX0RVUkFUSU9OX01TOiA3NSxcclxuICAgIEhJREVfREVMQVlfTVM6IDYwMCxcclxuICAgIFNIT1dfREVMQVlfTVM6IDUwMCxcclxuICAgIE1JTl9IRUlHSFQ6IDI0LFxyXG4gICAgTUFYX1dJRFRIOiAyMDAsXHJcbiAgICBDQVJFVF9JTkRFTlRBVElPTjogMjQsXHJcbiAgICBBTklNQVRJT05fU0NBTEU6IDAuOFxyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IGNzc0NsYXNzZXMgPSB7XHJcbiAgICBST09UOiAnbWRjLXRvb2x0aXAnLFxyXG4gICAgUklDSDogJ21kYy10b29sdGlwLS1yaWNoJyxcclxuICAgIE1VTFRJTElORTogJ21kYy10b29sdGlwLS1tdWx0aWxpbmUnLFxyXG4gICAgU0hPV0lORzogJ21kYy10b29sdGlwLS1zaG93aW5nJyxcclxuICAgIEFDVElPTlM6ICdtZGMtdG9vbHRpcC0tcmljaC1hY3Rpb25zJyxcclxuICAgIFNIT1dJTkdfVFJBTlNJVElPTjogJ21kYy10b29sdGlwLS1zaG93aW5nLXRyYW5zaXRpb24nLFxyXG4gICAgU0hPV046ICdtZGMtdG9vbHRpcC0tc2hvd24nLFxyXG4gICAgSElERTogJ21kYy10b29sdGlwLS1oaWRlJyxcclxuICAgIEhJREVfVFJBTlNJVElPTjogJ21kYy10b29sdGlwLS1oaWRlLXRyYW5zaXRpb24nLFxyXG5cclxuICAgIFNVUkZBQ0U6ICdtZGMtdG9vbHRpcF9fc3VyZmFjZScsXHJcbiAgICBTVVJGQUNFX0FOSU1BVElPTjogJ21kYy10b29sdGlwX19zdXJmYWNlLWFuaW1hdGlvbicsXHJcblxyXG4gICAgVElUTEU6ICdtZGMtdG9vbHRpcF9fdGl0bGUnLFxyXG5cclxuICAgIENPTlRFTlQ6ICdtZGMtdG9vbHRpcF9fY29udGVudCcsXHJcbiAgICBDT05URU5UX0xJTks6ICdtZGMtdG9vbHRpcF9fY29udGVudC1saW5rJyxcclxuXHJcbiAgICBBQ1RJT046ICdtZGMtdG9vbHRpcF9fYWN0aW9uJyxcclxuXHJcbiAgICBDQVJFVF9UT1A6ICdtZGMtdG9vbHRpcF9fY2FyZXQtc3VyZmFjZS10b3AnLFxyXG4gICAgQ0FSRVRfQk9UVE9NOiAnbWRjLXRvb2x0aXBfX2NhcmV0LXN1cmZhY2UtYm90dG9tJ1xyXG59OyIsImltcG9ydCB7IHVzZVJlZiwgdXNlU3RhdGUsIHVzZUVmZmVjdCwgdXNlQ2FsbGJhY2ssIHVzZUltcGVyYXRpdmVIYW5kbGUsIGZvcndhcmRSZWYgfSBmcm9tICdyZWFjdCc7XHJcbmltcG9ydCBjbGFzc25hbWVzIGZyb20gJ2NsYXNzbmFtZXMnO1xyXG5cclxuaW1wb3J0IHsgQ2xvbmUgfSBmcm9tICcuLi9jb21wb25lbnQnO1xyXG5pbXBvcnQgTGF5ZXIgZnJvbSAnLi4vbGF5ZXInO1xyXG5cclxuaW1wb3J0IHsgbnVtYmVycywgY3NzQ2xhc3NlcyB9IGZyb20gJy4vY29uc3RhbnRzJztcclxuXHJcbmNvbnN0IFRvb2x0aXAgPSBmb3J3YXJkUmVmKCh7XHJcbiAgICBsYWJlbCxcclxuXHJcbiAgICBlbGVtZW50OiBFbGVtZW50ID0gJ2RpdicsXHJcbiAgICBjbGFzc05hbWUsXHJcbiAgICBjaGlsZHJlblxyXG59LCByZWYpID0+IHtcclxuICAgIGNvbnN0IHRvb2x0aXBSZWYgPSB1c2VSZWYoKTtcclxuICAgIGNvbnN0IHRhcmdldFJlZiA9IHVzZVJlZihudWxsKTtcclxuICAgIGNvbnN0IFthY3RpdmUsIHNldEFjdGl2ZV0gPSB1c2VTdGF0ZShmYWxzZSk7XHJcblxyXG4gICAgdXNlSW1wZXJhdGl2ZUhhbmRsZShyZWYsICgpID0+IHRvb2x0aXBSZWYuY3VycmVudCk7XHJcblxyXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgICAgICBmdW5jdGlvbiBoYW5kbGVTY3JvbGwoKSB7XHJcbiAgICAgICAgICAgIHNldEFjdGl2ZShhY3RpdmUgPT4gYWN0aXZlICYmICFhY3RpdmUpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgaGFuZGxlU2Nyb2xsKTtcclxuXHJcbiAgICAgICAgcmV0dXJuICgpID0+IHtcclxuICAgICAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgaGFuZGxlU2Nyb2xsKTtcclxuICAgICAgICB9O1xyXG4gICAgfSwgW10pO1xyXG5cclxuICAgIGNvbnN0IGhhbmRsZU1vdXNlRW50ZXIgPSB1c2VDYWxsYmFjayhldmVudCA9PiB7XHJcbiAgICAgICAgdGFyZ2V0UmVmLmN1cnJlbnQgPSBldmVudC5jdXJyZW50VGFyZ2V0O1xyXG4gICAgICAgIHNldEFjdGl2ZSh0cnVlKTtcclxuICAgIH0sIFtdKTtcclxuXHJcbiAgICBjb25zdCBoYW5kbGVNb3VzZUxlYXZlID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xyXG4gICAgICAgIHRhcmdldFJlZi5jdXJyZW50ID0gbnVsbDtcclxuICAgICAgICBzZXRBY3RpdmUoZmFsc2UpO1xyXG4gICAgfSwgW10pO1xyXG5cclxuICAgIGNvbnN0IGhhbmRsZUVudGVyaW5nID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IHRvb2x0aXBSZWN0ID0gdG9vbHRpcFJlZi5jdXJyZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xyXG4gICAgICAgIGNvbnN0IHRhcmdldFJlY3QgPSB0YXJnZXRSZWYuY3VycmVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcclxuXHJcbiAgICAgICAgY29uc3QgdG9wID0gKHRhcmdldFJlY3QudG9wICsgdGFyZ2V0UmVjdC5oZWlnaHQgKyBudW1iZXJzLlVOQk9VTkRFRF9BTkNIT1JfR0FQKTtcclxuICAgICAgICBjb25zdCBsZWZ0ID0gKHRhcmdldFJlY3QubGVmdCArIHRhcmdldFJlY3Qud2lkdGggKiAwLjUgLSB0b29sdGlwUmVjdC53aWR0aCAqIDAuNSk7XHJcbiAgICAgICAgY29uc3QgcmlnaHQgPSBsZWZ0ICsgdG9vbHRpcFJlY3Qud2lkdGg7XHJcbiAgICAgICAgY29uc3QgYm90dG9tID0gdG9wICsgdG9vbHRpcFJlY3QuaGVpZ2h0O1xyXG4gICAgICAgIGNvbnN0IG92ZXJmbG93Qm90dG9tID0gd2luZG93LmlubmVySGVpZ2h0IC0gYm90dG9tO1xyXG4gICAgICAgIGNvbnN0IG92ZXJmbG93UmlnaHQgPSB3aW5kb3cuaW5uZXJXaWR0aCAtIHJpZ2h0O1xyXG5cclxuICAgICAgICBpZiAoXHJcbiAgICAgICAgICAgIHRvb2x0aXBSZWN0LmhlaWdodCA+IG51bWJlcnMuTUlOX0hFSUdIVCAmJlxyXG4gICAgICAgICAgICB0b29sdGlwUmVjdC53aWR0aCA+PSBudW1iZXJzLk1BWF9XSURUSFxyXG4gICAgICAgICkge1xyXG4gICAgICAgICAgICB0b29sdGlwUmVmLmN1cnJlbnQuY2xhc3NMaXN0LmFkZChjc3NDbGFzc2VzLk1VTFRJTElORSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAob3ZlcmZsb3dCb3R0b20gPCAwKSB7XHJcbiAgICAgICAgICAgIHRvb2x0aXBSZWYuY3VycmVudC5zdHlsZS50b3AgPSBgJHt0YXJnZXRSZWN0LnRvcCAtIHRvb2x0aXBSZWN0LmhlaWdodCAtIG51bWJlcnMuVU5CT1VOREVEX0FOQ0hPUl9HQVB9cHhgO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHRvb2x0aXBSZWYuY3VycmVudC5zdHlsZS50b3AgPSBgJHt0b3B9cHhgO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKG92ZXJmbG93UmlnaHQgPCAwKSB7XHJcbiAgICAgICAgICAgIHRvb2x0aXBSZWYuY3VycmVudC5zdHlsZS5sZWZ0ID0gYCR7dGFyZ2V0UmVjdC5yaWdodCAtIHRvb2x0aXBSZWN0LndpZHRofXB4YDtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0b29sdGlwUmVmLmN1cnJlbnQuc3R5bGUubGVmdCA9IGAke2xlZnQgPCAwID8gdGFyZ2V0UmVjdC5sZWZ0IDogbGVmdH1weGA7XHJcbiAgICAgICAgfVxyXG4gICAgfSwgW10pO1xyXG5cclxuICAgIGNvbnN0IGNsYXNzTmFtZXMgPSBjbGFzc25hbWVzKGNzc0NsYXNzZXMuUk9PVCwgY2xhc3NOYW1lKTtcclxuXHJcbiAgICByZXR1cm4gKDw+XHJcbiAgICAgICAgPENsb25lXHJcbiAgICAgICAgICAgIGNvbXBvbmVudD17Y2hpbGRyZW59XHJcbiAgICAgICAgICAgIG9uTW91c2VFbnRlcj17aGFuZGxlTW91c2VFbnRlcn1cclxuICAgICAgICAgICAgb25Nb3VzZUxlYXZlPXtoYW5kbGVNb3VzZUxlYXZlfVxyXG4gICAgICAgIC8+XHJcblxyXG4gICAgICAgIDxMYXllclxyXG4gICAgICAgICAgICBtb2RhbFxyXG4gICAgICAgICAgICBpbj17YWN0aXZlfVxyXG4gICAgICAgICAgICB0aW1lb3V0PXt7XHJcbiAgICAgICAgICAgICAgICBlbnRlcjogbnVtYmVycy5TSE9XX0RFTEFZX01TLFxyXG4gICAgICAgICAgICAgICAgZXhpdDogbnVtYmVycy5ISURFX0RFTEFZX01TXHJcbiAgICAgICAgICAgIH19XHJcbiAgICAgICAgICAgIGNsYXNzTmFtZXM9e3tcclxuICAgICAgICAgICAgICAgIGVudGVyOiBjc3NDbGFzc2VzLlNIT1dJTkdfVFJBTlNJVElPTixcclxuICAgICAgICAgICAgICAgIGVudGVyQWN0aXZlOiBgJHtjc3NDbGFzc2VzLlNIT1dJTkdfVFJBTlNJVElPTn0gJHtjc3NDbGFzc2VzLlNIT1dJTkd9YCxcclxuICAgICAgICAgICAgICAgIGVudGVyRG9uZTogYCR7Y3NzQ2xhc3Nlcy5TSE9XSU5HX1RSQU5TSVRJT059ICR7Y3NzQ2xhc3Nlcy5TSE9XTn1gLFxyXG4gICAgICAgICAgICAgICAgZXhpdDogYCR7Y3NzQ2xhc3Nlcy5ISURFX1RSQU5TSVRJT059ICR7Y3NzQ2xhc3Nlcy5ISURFfWAsXHJcbiAgICAgICAgICAgICAgICBleGl0QWN0aXZlOiBgJHtjc3NDbGFzc2VzLkhJREVfVFJBTlNJVElPTn0gJHtjc3NDbGFzc2VzLkhJREV9YFxyXG4gICAgICAgICAgICB9fVxyXG4gICAgICAgICAgICBvbkVudGVyaW5nPXtoYW5kbGVFbnRlcmluZ31cclxuICAgICAgICAgICAgbW91bnRPbkVudGVyXHJcbiAgICAgICAgICAgIHVubW91bnRPbkV4aXRcclxuICAgICAgICA+XHJcbiAgICAgICAgICAgIDxFbGVtZW50XHJcbiAgICAgICAgICAgICAgICByZWY9e3Rvb2x0aXBSZWZ9XHJcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU9e2NsYXNzTmFtZXN9XHJcbiAgICAgICAgICAgICAgICByb2xlPVwidG9vbHRpcFwiXHJcbiAgICAgICAgICAgICAgICBhcmlhLWhpZGRlbj17YWN0aXZlID8gdW5kZWZpbmVkIDogJ3RydWUnfVxyXG4gICAgICAgICAgICA+XHJcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17YCR7Y3NzQ2xhc3Nlcy5TVVJGQUNFfSAke2Nzc0NsYXNzZXMuU1VSRkFDRV9BTklNQVRJT059YH0+XHJcbiAgICAgICAgICAgICAgICAgICAge2xhYmVsfVxyXG4gICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgIDwvRWxlbWVudD5cclxuICAgICAgICA8L0xheWVyPlxyXG4gICAgPC8+KTtcclxufSk7XHJcblxyXG5Ub29sdGlwLmRpc3BsYXlOYW1lID0gJ01EQ1Rvb2x0aXAnO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgVG9vbHRpcDsiLCJpbXBvcnQgeyBDaGlsZHJlbiwgZm9yd2FyZFJlZiwgdXNlQ2FsbGJhY2ssIHVzZUVmZmVjdCwgdXNlSW1wZXJhdGl2ZUhhbmRsZSwgdXNlUmVmLCB1c2VTdGF0ZSB9IGZyb20gJ3JlYWN0JztcclxuaW1wb3J0IGNsYXNzbmFtZXMgZnJvbSAnY2xhc3NuYW1lcyc7XHJcblxyXG5pbXBvcnQgeyBDbG9uZSB9IGZyb20gJy4uL2NvbXBvbmVudCc7XHJcbmltcG9ydCBMYXllciBmcm9tICcuLi9sYXllcic7XHJcblxyXG5pbXBvcnQgeyBudW1iZXJzLCBjc3NDbGFzc2VzIH0gZnJvbSAnLi9jb25zdGFudHMnO1xyXG5cclxuY29uc3QgUmljaFRvb2x0aXAgPSBmb3J3YXJkUmVmKCh7XHJcbiAgICB0aXRsZSxcclxuICAgIGNvbnRlbnQsXHJcbiAgICBhY3Rpb25zLFxyXG5cclxuICAgIGVsZW1lbnQ6IEVsZW1lbnQgPSAnZGl2JyxcclxuICAgIGNsYXNzTmFtZSxcclxuICAgIGNoaWxkcmVuXHJcbn0sIHJlZikgPT4ge1xyXG4gICAgY29uc3QgdG9vbHRpcFJlZiA9IHVzZVJlZigpO1xyXG4gICAgY29uc3QgdGFyZ2V0UmVmID0gdXNlUmVmKCk7XHJcblxyXG4gICAgY29uc3QgW2FjdGl2ZSwgc2V0QWN0aXZlXSA9IHVzZVN0YXRlKGZhbHNlKTtcclxuXHJcbiAgICB1c2VJbXBlcmF0aXZlSGFuZGxlKHJlZiwgKCkgPT4gdG9vbHRpcFJlZi5jdXJyZW50KTtcclxuXHJcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgICAgIGZ1bmN0aW9uIGhhbmRsZVNjcm9sbCgpIHtcclxuICAgICAgICAgICAgc2V0QWN0aXZlKGFjdGl2ZSA9PiBhY3RpdmUgJiYgIWFjdGl2ZSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdzY3JvbGwnLCBoYW5kbGVTY3JvbGwpO1xyXG5cclxuICAgICAgICByZXR1cm4gKCkgPT4ge1xyXG4gICAgICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdzY3JvbGwnLCBoYW5kbGVTY3JvbGwpO1xyXG4gICAgICAgIH07XHJcbiAgICB9LCBbXSk7XHJcblxyXG4gICAgY29uc3QgaGFuZGxlVGFyZ2V0TW91c2VFbnRlciA9IHVzZUNhbGxiYWNrKCgpID0+IHtcclxuICAgICAgICBzZXRBY3RpdmUodHJ1ZSk7XHJcbiAgICB9LCBbXSk7XHJcblxyXG4gICAgY29uc3QgaGFuZGxlVGFyZ2V0TW91c2VMZWF2ZSA9IHVzZUNhbGxiYWNrKCgpID0+IHtcclxuICAgICAgICBzZXRBY3RpdmUoZmFsc2UpO1xyXG4gICAgfSwgW10pO1xyXG5cclxuICAgIGNvbnN0IGhhbmRsZVRvb2x0aXBNb3VzZUVudGVyID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xyXG4gICAgICAgIHNldEFjdGl2ZSh0cnVlKTtcclxuICAgIH0sIFtdKTtcclxuXHJcbiAgICBjb25zdCBoYW5kbGVUb29sdGlwTW91c2VMZWF2ZSA9IHVzZUNhbGxiYWNrKCgpID0+IHtcclxuICAgICAgICBzZXRBY3RpdmUoZmFsc2UpO1xyXG4gICAgfSwgW10pO1xyXG5cclxuICAgIGNvbnN0IGhhbmRsZUVudGVyaW5nID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IHRvb2x0aXBSZWN0ID0gdG9vbHRpcFJlZi5jdXJyZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xyXG4gICAgICAgIGNvbnN0IHRhcmdldFJlY3QgPSB0YXJnZXRSZWYuY3VycmVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcclxuXHJcbiAgICAgICAgY29uc3Qgd2lkdGggPSB0b29sdGlwUmVmLmN1cnJlbnQuZmlyc3RDaGlsZC5jbGllbnRXaWR0aDtcclxuICAgICAgICBjb25zdCBoZWlnaHQgPSB0b29sdGlwUmVmLmN1cnJlbnQuZmlyc3RDaGlsZC5zY3JvbGxIZWlnaHQ7XHJcbiAgICAgICAgY29uc3QgdG9wID0gdGFyZ2V0UmVjdC5ib3R0b20gKyB3aW5kb3cuc2Nyb2xsWSArIG51bWJlcnMuVU5CT1VOREVEX0FOQ0hPUl9HQVA7XHJcbiAgICAgICAgY29uc3QgbGVmdCA9IHRhcmdldFJlY3QucmlnaHQgKyB3aW5kb3cuc2Nyb2xsWCArIG51bWJlcnMuVU5CT1VOREVEX0FOQ0hPUl9HQVA7XHJcbiAgICAgICAgY29uc3QgcmlnaHQgPSBsZWZ0ICsgd2lkdGggKyBudW1iZXJzLk1JTl9WSUVXUE9SVF9UT09MVElQX1RIUkVTSE9MRDtcclxuICAgICAgICBjb25zdCBib3R0b20gPSB0b3AgKyBoZWlnaHQgKyBudW1iZXJzLk1JTl9WSUVXUE9SVF9UT09MVElQX1RIUkVTSE9MRDtcclxuICAgICAgICBjb25zdCBvdmVyZmxvd0JvdHRvbSA9IHdpbmRvdy5pbm5lckhlaWdodCAtIGJvdHRvbTtcclxuICAgICAgICBjb25zdCBvdmVyZmxvd1JpZ2h0ID0gd2luZG93LmlubmVyV2lkdGggLSByaWdodDtcclxuXHJcbiAgICAgICAgaWYgKG92ZXJmbG93Qm90dG9tIDwgMCkge1xyXG4gICAgICAgICAgICB0b29sdGlwUmVmLmN1cnJlbnQuc3R5bGUudG9wID0gYCR7dG9wICsgb3ZlcmZsb3dCb3R0b219cHhgO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHRvb2x0aXBSZWYuY3VycmVudC5zdHlsZS50b3AgPSBgJHt0b3B9cHhgO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKG92ZXJmbG93UmlnaHQgPCAwKSB7XHJcbiAgICAgICAgICAgIHRvb2x0aXBSZWYuY3VycmVudC5zdHlsZS5sZWZ0ID0gYCR7dGFyZ2V0UmVjdC5yaWdodCAtIHRvb2x0aXBSZWN0LndpZHRofXB4YDtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0b29sdGlwUmVmLmN1cnJlbnQuc3R5bGUubGVmdCA9IGAke2xlZnQgPCAwID8gdGFyZ2V0UmVjdC5sZWZ0IDogbGVmdH1weGA7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0b29sdGlwUmVmLmN1cnJlbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XHJcbiAgICB9LCBbXSk7XHJcblxyXG4gICAgY29uc3QgY2xhc3NOYW1lcyA9IGNsYXNzbmFtZXMoY3NzQ2xhc3Nlcy5ST09ULCBjc3NDbGFzc2VzLlJJQ0gsIGNsYXNzTmFtZSk7XHJcblxyXG4gICAgcmV0dXJuICg8PlxyXG4gICAgICAgIDxDbG9uZVxyXG4gICAgICAgICAgICBjb21wb25lbnQ9e2NoaWxkcmVufVxyXG4gICAgICAgICAgICByZWY9e3RhcmdldFJlZn1cclxuICAgICAgICAgICAgb25Nb3VzZUVudGVyPXtoYW5kbGVUYXJnZXRNb3VzZUVudGVyfVxyXG4gICAgICAgICAgICBvbk1vdXNlTGVhdmU9e2hhbmRsZVRhcmdldE1vdXNlTGVhdmV9XHJcbiAgICAgICAgLz5cclxuXHJcbiAgICAgICAgPExheWVyXHJcbiAgICAgICAgICAgIG1vZGFsXHJcbiAgICAgICAgICAgIGluPXthY3RpdmV9XHJcbiAgICAgICAgICAgIHRpbWVvdXQ9e3tcclxuICAgICAgICAgICAgICAgIGVudGVyOiBudW1iZXJzLlNIT1dfREVMQVlfTVMsXHJcbiAgICAgICAgICAgICAgICBleGl0OiBudW1iZXJzLkhJREVfREVMQVlfTVNcclxuICAgICAgICAgICAgfX1cclxuICAgICAgICAgICAgY2xhc3NOYW1lcz17e1xyXG4gICAgICAgICAgICAgICAgZW50ZXI6IGNzc0NsYXNzZXMuU0hPV0lOR19UUkFOU0lUSU9OLFxyXG4gICAgICAgICAgICAgICAgZW50ZXJBY3RpdmU6IGAke2Nzc0NsYXNzZXMuU0hPV0lOR19UUkFOU0lUSU9OfSAke2Nzc0NsYXNzZXMuU0hPV0lOR31gLFxyXG4gICAgICAgICAgICAgICAgZW50ZXJEb25lOiBgJHtjc3NDbGFzc2VzLlNIT1dJTkdfVFJBTlNJVElPTn0gJHtjc3NDbGFzc2VzLlNIT1dOfWAsXHJcbiAgICAgICAgICAgICAgICBleGl0OiBjc3NDbGFzc2VzLlNIT1dOLFxyXG4gICAgICAgICAgICAgICAgZXhpdEFjdGl2ZTogYCR7Y3NzQ2xhc3Nlcy5ISURFX1RSQU5TSVRJT059ICR7Y3NzQ2xhc3Nlcy5TSE9XTn1gLFxyXG4gICAgICAgICAgICAgICAgZXhpdERvbmU6IGAke2Nzc0NsYXNzZXMuSElERV9UUkFOU0lUSU9OfSAke2Nzc0NsYXNzZXMuSElERX1gXHJcbiAgICAgICAgICAgIH19XHJcbiAgICAgICAgICAgIG1vdW50T25FbnRlclxyXG4gICAgICAgICAgICB1bm1vdW50T25FeGl0XHJcbiAgICAgICAgICAgIG9uRW50ZXJpbmc9e2hhbmRsZUVudGVyaW5nfVxyXG4gICAgICAgID5cclxuICAgICAgICAgICAgPEVsZW1lbnRcclxuICAgICAgICAgICAgICAgIHJlZj17dG9vbHRpcFJlZn1cclxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZT17Y2xhc3NOYW1lc31cclxuICAgICAgICAgICAgICAgIHJvbGU9XCJ0b29sdGlwXCJcclxuICAgICAgICAgICAgICAgIGFyaWEtaGlkZGVuPXthY3RpdmUgPyB1bmRlZmluZWQgOiAndHJ1ZSd9XHJcbiAgICAgICAgICAgICAgICBhcmlhLWV4cGFuZGVkPXthY3RpdmUgPyAndHJ1ZScgOiB1bmRlZmluZWR9XHJcbiAgICAgICAgICAgICAgICBvbk1vdXNlRW50ZXI9e2hhbmRsZVRvb2x0aXBNb3VzZUVudGVyfVxyXG4gICAgICAgICAgICAgICAgb25Nb3VzZUxlYXZlPXtoYW5kbGVUb29sdGlwTW91c2VMZWF2ZX1cclxuICAgICAgICAgICAgPlxyXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9e2Ake2Nzc0NsYXNzZXMuU1VSRkFDRX0gJHtjc3NDbGFzc2VzLlNVUkZBQ0VfQU5JTUFUSU9OfWB9PlxyXG4gICAgICAgICAgICAgICAgICAgIHt0aXRsZSAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8aDIgY2xhc3NOYW1lPXtjc3NDbGFzc2VzLlRJVExFfT57dGl0bGV9PC9oMj5cclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHtjb250ZW50ICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxwIGNsYXNzTmFtZT17Y3NzQ2xhc3Nlcy5DT05URU5UfT57Y29udGVudH08L3A+XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICB7YWN0aW9ucyAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17Y3NzQ2xhc3Nlcy5BQ1RJT05TfT5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtDaGlsZHJlbi5tYXAoYWN0aW9ucywgYWN0aW9uID0+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPENsb25lXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudD17YWN0aW9ufVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmlhLWxhYmVsPVwiYWN0aW9uXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKX1cclxuICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgIDwvRWxlbWVudD5cclxuICAgICAgICA8L0xheWVyPlxyXG4gICAgPC8+KTtcclxufSk7XHJcblxyXG5SaWNoVG9vbHRpcC5kaXNwbGF5TmFtZSA9ICdNRENSaWNoVG9vbHRpcCc7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBSaWNoVG9vbHRpcDsiLCJleHBvcnQgeyBkZWZhdWx0IGFzIFRvb2x0aXAgfSBmcm9tICcuL1Rvb2x0aXAnO1xyXG5leHBvcnQgeyBkZWZhdWx0IGFzIFJpY2hUb29sdGlwIH0gZnJvbSAnLi9SaWNoVG9vbHRpcCc7IiwiZXhwb3J0IGNvbnN0IGNzc0NsYXNzZXMgPSB7XHJcbiAgICBST09UOiAnbWRjLXRleHQtZmllbGQnLFxyXG4gICAgRklMTEVEOiAnbWRjLXRleHQtZmllbGQtLWZpbGxlZCcsXHJcbiAgICBPVVRMSU5FRDogJ21kYy10ZXh0LWZpZWxkLS1vdXRsaW5lZCcsXHJcbiAgICBURVhUQVJFQTogJ21kYy10ZXh0LWZpZWxkLS10ZXh0YXJlYScsXHJcbiAgICBESVNBQkxFRDogJ21kYy10ZXh0LWZpZWxkLS1kaXNhYmxlZCcsXHJcbiAgICBGT0NVU0VEOiAnbWRjLXRleHQtZmllbGQtLWZvY3VzZWQnLFxyXG4gICAgSU5WQUxJRDogJ21kYy10ZXh0LWZpZWxkLS1pbnZhbGlkJyxcclxuICAgIExBQkVMX0ZMT0FUSU5HOiAnbWRjLXRleHQtZmllbGQtLWxhYmVsLWZsb2F0aW5nJyxcclxuICAgIE5PX0xBQkVMOiAnbWRjLXRleHQtZmllbGQtLW5vLWxhYmVsJyxcclxuICAgIEVORF9BTElHTkVEOiAnbWRjLXRleHQtZmllbGQtLWVuZC1hbGlnbmVkJyxcclxuICAgIFdJVEhfTEVBRElOR19JQ09OOiAnbWRjLXRleHQtZmllbGQtLXdpdGgtbGVhZGluZy1pY29uJyxcclxuICAgIFdJVEhfVFJBSUxJTkdfSUNPTjogJ21kYy10ZXh0LWZpZWxkLS13aXRoLXRyYWlsaW5nLWljb24nLFxyXG4gICAgV0lUSF9JTlRFUk5BTF9DT1VOVEVSOiAnbWRjLXRleHQtZmllbGQtLXdpdGgtaW50ZXJuYWwtY291bnRlcicsXHJcblxyXG4gICAgSUNPTjogJ21kYy10ZXh0LWZpZWxkX19pY29uJyxcclxuICAgIElDT05fTEVBRElORzogJ21kYy10ZXh0LWZpZWxkX19pY29uLS1sZWFkaW5nJyxcclxuICAgIElDT05fVFJBSUxJTkc6ICdtZGMtdGV4dC1maWVsZF9faWNvbi0tbGVhZGluZycsXHJcblxyXG4gICAgSU5QVVQ6ICdtZGMtdGV4dC1maWVsZF9faW5wdXQnLFxyXG5cclxuICAgIEFGRklYOiAnbWRjLXRleHQtZmllbGRfX2FmZml4JyxcclxuICAgIEFGRklYX1BSRUZJWDogJ21kYy10ZXh0LWZpZWxkX19hZmZpeC0tcHJlZml4JyxcclxuICAgIEFGRklYX1NVRkZJWDogJ21kYy10ZXh0LWZpZWxkX19hZmZpeC0tc3VmZml4JyxcclxuXHJcbiAgICBSRVNJWkVSOiAnbWRjLXRleHQtZmllbGRfX3Jlc2l6ZXInLFxyXG5cclxuICAgIFJJUFBMRTogJ21kYy10ZXh0LWZpZWxkX19yaXBwbGUnLFxyXG5cclxuICAgIEhFTFBFUl9MSU5FOiAnbWRjLXRleHQtZmllbGQtaGVscGVyLWxpbmUnLFxyXG4gICAgSEVMUEVSX1RFWFQ6ICdtZGMtdGV4dC1maWVsZC1oZWxwZXItdGV4dCcsXHJcbiAgICBIRUxQRVJfVEVYVF9QRVJTSVNURU5UOiAnbWRjLXRleHQtZmllbGQtaGVscGVyLXRleHQtLXBlcnNpc3RlbnQnLFxyXG4gICAgSEVMUEVSX1RFWFRfVkFMSURBVElPTjogJ21kYy10ZXh0LWZpZWxkLWhlbHBlci10ZXh0LS12YWxpZGF0aW9uLW1zZycsXHJcblxyXG4gICAgQ0hBUkFDVEVSX0NPVU5URVI6ICdtZGMtdGV4dC1maWVsZC1jaGFyYWN0ZXItY291bnRlcicsXHJcbn07IiwiaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcclxuaW1wb3J0IGNsYXNzbmFtZXMgZnJvbSAnY2xhc3NuYW1lcyc7XHJcblxyXG5pbXBvcnQgeyBjc3NDbGFzc2VzIH0gZnJvbSAnLi9jb25zdGFudHMnO1xyXG5cclxuY29uc3QgSGVscGVyVGV4dCA9ICh7XHJcbiAgICBwZXJzaXN0ZW50ID0gZmFsc2UsXHJcbiAgICB2YWxpZGF0aW9uID0gZmFsc2UsXHJcblxyXG4gICAgLi4ucHJvcHNcclxufSkgPT4ge1xyXG4gICAgY29uc3QgY2xhc3NOYW1lcyA9IGNsYXNzbmFtZXMoY3NzQ2xhc3Nlcy5IRUxQRVJfVEVYVCwge1xyXG4gICAgICAgIFtjc3NDbGFzc2VzLkhFTFBFUl9URVhUX1BFUlNJU1RFTlRdOiBwZXJzaXN0ZW50LFxyXG4gICAgICAgIFtjc3NDbGFzc2VzLkhFTFBFUl9URVhUX1ZBTElEQVRJT05dOiB2YWxpZGF0aW9uXHJcbiAgICB9KTtcclxuXHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPXtjbGFzc05hbWVzfSB7Li4ucHJvcHN9IC8+XHJcbiAgICApO1xyXG59O1xyXG5cclxuSGVscGVyVGV4dC5kaXNwbGF5TmFtZSA9ICdNRENUZXh0RmllbGRIZWxwZXJUZXh0JztcclxuXHJcbkhlbHBlclRleHQucHJvcFR5cGVzID0ge1xyXG4gICAgcGVyc2lzdGVudDogUHJvcFR5cGVzLmJvb2wsXHJcbiAgICB2YWxpZGF0aW9uOiBQcm9wVHlwZXMuYm9vbFxyXG59O1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgSGVscGVyVGV4dDsiLCJpbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gQ2hhcmFjdGVyQ291bnRlcih7XHJcbiAgICB2YWx1ZSA9IDAsXHJcbiAgICBtYXhWYWx1ZSxcclxuXHJcbiAgICAuLi5wcm9wc1xyXG59KSB7XHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPVwibWRjLXRleHQtZmllbGQtY2hhcmFjdGVyLWNvdW50ZXJcIiB7Li4ucHJvcHN9PlxyXG4gICAgICAgICAgICB7YCR7dmFsdWV9IC8gJHttYXhWYWx1ZX1gfVxyXG4gICAgICAgIDwvZGl2PlxyXG4gICAgKTtcclxufVxyXG5cclxuQ2hhcmFjdGVyQ291bnRlci5kaXNwbGF5TmFtZSA9ICdNRENUZXh0RmllbGRDaGFyYWN0ZXJDb3VudGVyJztcclxuXHJcbkNoYXJhY3RlckNvdW50ZXIucHJvcFR5cGVzID0ge1xyXG4gICAgdmFsdWU6IFByb3BUeXBlcy5udW1iZXIsXHJcbiAgICBtYXhWYWx1ZTogUHJvcFR5cGVzLm51bWJlclxyXG59OyIsImltcG9ydCB7IGZvcndhcmRSZWYsIHVzZUxheW91dEVmZmVjdCB9IGZyb20gJ3JlYWN0JztcclxuXHJcbmltcG9ydCB7IGNzc0NsYXNzZXMgfSBmcm9tICcuL2NvbnN0YW50cyc7XHJcblxyXG5jb25zdCBJbnB1dCA9IGZvcndhcmRSZWYoKHtcclxuICAgIHRleHRhcmVhLFxyXG4gICAgYXV0b1Jlc2l6ZSxcclxuICAgIGVsZW1lbnQ6IEVsZW1lbnQgPSB0ZXh0YXJlYSA/ICd0ZXh0YXJlYScgOiAnaW5wdXQnLFxyXG4gICAgLi4ucHJvcHNcclxufSwgcmVmKSA9PiB7XHJcbiAgICB1c2VMYXlvdXRFZmZlY3QoKCkgPT4ge1xyXG4gICAgICAgIGlmICghYXV0b1Jlc2l6ZSkgcmV0dXJuO1xyXG5cclxuICAgICAgICBjb25zdCBlbGVtZW50ID0gcmVmLmN1cnJlbnQ7XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIHNldEhlaWdodCgpIHtcclxuICAgICAgICAgICAgZWxlbWVudC5zdHlsZS5oZWlnaHQgPSAnMXJlbSc7XHJcbiAgICAgICAgICAgIGVsZW1lbnQuc3R5bGUuaGVpZ2h0ID0gYCR7ZWxlbWVudC5zY3JvbGxIZWlnaHR9cHhgO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgc2V0SGVpZ2h0KCk7XHJcblxyXG4gICAgICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignaW5wdXQnLCBzZXRIZWlnaHQpO1xyXG5cclxuICAgICAgICByZXR1cm4gKCkgPT4gZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdpbnB1dCcsIHNldEhlaWdodCk7XHJcbiAgICB9LCBbYXV0b1Jlc2l6ZSwgcmVmXSk7XHJcblxyXG4gICAgcmV0dXJuIChcclxuICAgICAgICA8RWxlbWVudFxyXG4gICAgICAgICAgICByZWY9e3JlZn1cclxuICAgICAgICAgICAgY2xhc3NOYW1lPXtjc3NDbGFzc2VzLklOUFVUfVxyXG4gICAgICAgICAgICB7Li4ucHJvcHN9XHJcbiAgICAgICAgLz5cclxuICAgICk7XHJcbn0pO1xyXG5cclxuSW5wdXQuZGlzcGxheU5hbWUgPSAnTURDVGV4dEZpZWxkSW5wdXQnO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgSW5wdXQ7IiwiaW1wb3J0IHsgY3NzQ2xhc3NlcyB9IGZyb20gJy4vY29uc3RhbnRzJztcclxuXHJcbmNvbnN0IFJlc2l6ZXIgPSAoe1xyXG4gICAgdGV4dGFyZWEsXHJcbiAgICBhdXRvUmVzaXplLFxyXG4gICAgY2hpbGRyZW4sXHJcbiAgICAuLi5wcm9wc1xyXG59KSA9PiB7XHJcbiAgICByZXR1cm4gKHRleHRhcmVhICYmICFhdXRvUmVzaXplKSA/IChcclxuICAgICAgICA8c3BhbiBjbGFzc05hbWU9e2Nzc0NsYXNzZXMuUkVTSVpFUn0gey4uLnByb3BzfT5cclxuICAgICAgICAgICAge2NoaWxkcmVufVxyXG4gICAgICAgIDwvc3Bhbj5cclxuICAgICkgOiBjaGlsZHJlbjtcclxufTtcclxuXHJcblJlc2l6ZXIuZGlzcGxheU5hbWUgPSAnTURDVGV4dEZpZWxkUmVzaXplcic7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBSZXNpemVyOyIsImltcG9ydCB7IGZvcndhcmRSZWYsIHVzZVJlZiwgdXNlU3RhdGUsIHVzZUNhbGxiYWNrIH0gZnJvbSAncmVhY3QnO1xyXG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xyXG5pbXBvcnQgY2xhc3NuYW1lcyBmcm9tICdjbGFzc25hbWVzJztcclxuXHJcbmltcG9ydCB7IENsb25lIH0gZnJvbSAnLi4vY29tcG9uZW50JztcclxuaW1wb3J0IE5vdGNoZWRPdXRsaW5lIGZyb20gJy4uL25vdGNoZWQtb3V0bGluZSc7XHJcbmltcG9ydCBMaW5lUmlwcGxlIGZyb20gJy4uL2xpbmUtcmlwcGxlJztcclxuaW1wb3J0IEZsb2F0aW5nTGFiZWwgZnJvbSAnLi4vZmxvYXRpbmctbGFiZWwnO1xyXG5pbXBvcnQgSWNvbiBmcm9tICcuLi9pY29uJztcclxuXHJcbmltcG9ydCB7IGNzc0NsYXNzZXMgfSBmcm9tICcuL2NvbnN0YW50cyc7XHJcbmltcG9ydCBIZWxwZXJUZXh0IGZyb20gJy4vSGVscGVyVGV4dCc7XHJcbmltcG9ydCBDaGFyYWN0ZXJDb3VudGVyIGZyb20gJy4vQ2hhcmFjdGVyQ291bnRlcic7XHJcbmltcG9ydCBJbnB1dCBmcm9tICcuL0lucHV0JztcclxuaW1wb3J0IFJlc2l6ZXIgZnJvbSAnLi9SZXNpemVyJztcclxuXHJcbmNvbnN0IFRleHRGaWVsZCA9IGZvcndhcmRSZWYoKHtcclxuICAgIHZhbHVlLFxyXG4gICAgZGVmYXVsdFZhbHVlLFxyXG4gICAgbGFiZWwsXHJcbiAgICBsZWFkaW5nSWNvbixcclxuICAgIHRyYWlsaW5nSWNvbixcclxuICAgIHByZWZpeCxcclxuICAgIHN1ZmZpeCxcclxuICAgIHBlcnNpc3RlbnRIZWxwZXJUZXh0LFxyXG4gICAgaGVscGVyVGV4dCA9IHBlcnNpc3RlbnRIZWxwZXJUZXh0LFxyXG4gICAgdmFsaWRhdGlvbk1lc3NhZ2UsXHJcbiAgICBmaWxsZWQgPSBmYWxzZSxcclxuICAgIG91dGxpbmVkID0gZmFsc2UsXHJcbiAgICBmdWxsV2lkdGggPSBmYWxzZSxcclxuICAgIGRpc2FibGVkID0gZmFsc2UsXHJcbiAgICB0ZXh0YXJlYSA9IGZhbHNlLFxyXG4gICAgZW5kQWxpZ25lZCA9IGZhbHNlLFxyXG4gICAgYXV0b1Jlc2l6ZSA9IGZhbHNlLFxyXG4gICAgaW50ZXJuYWxDb3VudGVyID0gZmFsc2UsXHJcblxyXG4gICAgY2xhc3NOYW1lLFxyXG4gICAgZWxlbWVudDogRWxlbWVudCA9ICdsYWJlbCcsXHJcbiAgICBvbkNoYW5nZSA9IEZ1bmN0aW9uLnByb3RvdHlwZSxcclxuICAgIC4uLnByb3BzXHJcbn0sIHJlZikgPT4ge1xyXG4gICAgY29uc3QgaW5wdXRSZWYgPSB1c2VSZWYoKTtcclxuXHJcbiAgICBjb25zdCBbZm9jdXNlZCwgc2V0Rm9jdXNlZF0gPSB1c2VTdGF0ZShmYWxzZSk7XHJcbiAgICBjb25zdCBbdG91Y2hlZCwgc2V0VG91Y2hlZF0gPSB1c2VTdGF0ZShmYWxzZSk7XHJcbiAgICBjb25zdCBbdmFsaWQsIHNldFZhbGlkXSA9IHVzZVN0YXRlKHRydWUpO1xyXG4gICAgY29uc3QgW2ludGVyYWN0aW9uQ29vcmRzLCBzZXRJbnRlcmFjdGlvbkNvb3Jkc10gPSB1c2VTdGF0ZSgpO1xyXG4gICAgY29uc3QgW2NvdW50LCBzZXRDb3VudF0gPSB1c2VTdGF0ZSh2YWx1ZT8ubGVuZ3RoIHx8IGRlZmF1bHRWYWx1ZT8udmFsdWUgfHwgMCk7XHJcblxyXG4gICAgY29uc3QgaGFuZGxlSW50ZXJhY3Rpb24gPSB1c2VDYWxsYmFjayhldmVudCA9PiB7XHJcbiAgICAgICAgY29uc3QgdGFyZ2V0Q2xpZW50UmVjdCA9IGV2ZW50LnRhcmdldC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcclxuXHJcbiAgICAgICAgc2V0SW50ZXJhY3Rpb25Db29yZHMoe1xyXG4gICAgICAgICAgICB4OiBldmVudC5jbGllbnRYIC0gdGFyZ2V0Q2xpZW50UmVjdC5sZWZ0LFxyXG4gICAgICAgICAgICB5OiBldmVudC5jbGllbnRZIC0gdGFyZ2V0Q2xpZW50UmVjdC50b3BcclxuICAgICAgICB9KTtcclxuICAgIH0sIFtdKTtcclxuXHJcbiAgICBjb25zdCBoYW5kbGVJbnB1dEZvY3VzID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xyXG4gICAgICAgIHNldEZvY3VzZWQodHJ1ZSk7XHJcbiAgICAgICAgc2V0VG91Y2hlZCh0cnVlKTtcclxuICAgIH0sIFtdKTtcclxuXHJcbiAgICBjb25zdCBoYW5kbGVJbnB1dEJsdXIgPSB1c2VDYWxsYmFjaygoKSA9PiB7XHJcbiAgICAgICAgc2V0Rm9jdXNlZChmYWxzZSk7XHJcbiAgICAgICAgc2V0SW50ZXJhY3Rpb25Db29yZHMoKTtcclxuICAgIH0sIFtdKTtcclxuXHJcbiAgICBjb25zdCBoYW5kbGVJbnB1dENoYW5nZSA9IHVzZUNhbGxiYWNrKGV2ZW50ID0+IHtcclxuICAgICAgICBjb25zdCB2YWx1ZSA9IGlucHV0UmVmLmN1cnJlbnQudmFsdWU7XHJcbiAgICAgICAgY29uc3QgaXNWYWxpZCA9IGlucHV0UmVmLmN1cnJlbnQ/LnZhbGlkaXR5LnZhbGlkO1xyXG5cclxuICAgICAgICBzZXRDb3VudCh2YWx1ZS5sZW5ndGgpO1xyXG4gICAgICAgIHNldFZhbGlkKGlzVmFsaWQpO1xyXG4gICAgICAgIG9uQ2hhbmdlKGV2ZW50LCB2YWx1ZSk7XHJcbiAgICB9LCBbb25DaGFuZ2VdKTtcclxuXHJcbiAgICBjb25zdCBmb2N1c2VkT3JIYXNWYWx1ZSA9IChcclxuICAgICAgICBmb2N1c2VkIHx8XHJcbiAgICAgICAgKHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgIT09IG51bGwgJiYgdmFsdWUgIT09ICcnKSB8fFxyXG4gICAgICAgIChkZWZhdWx0VmFsdWUgIT09IHVuZGVmaW5lZCAmJiBkZWZhdWx0VmFsdWUgIT09IG51bGwgJiYgZGVmYXVsdFZhbHVlICE9PSAnJykgfHxcclxuICAgICAgICBCb29sZWFuKGlucHV0UmVmLmN1cnJlbnQ/LnZhbHVlKVxyXG4gICAgKTtcclxuXHJcbiAgICBjb25zdCBoYXNIZWxwZXJMaW5lID0gaGVscGVyVGV4dCB8fCB2YWxpZGF0aW9uTWVzc2FnZSB8fCBwcm9wcy5tYXhMZW5ndGg7XHJcblxyXG4gICAgY29uc3QgY2xhc3NOYW1lcyA9IGNsYXNzbmFtZXMoY3NzQ2xhc3Nlcy5ST09ULCB7XHJcbiAgICAgICAgW2Nzc0NsYXNzZXMuRklMTEVEXTogZmlsbGVkICYmICFmdWxsV2lkdGgsXHJcbiAgICAgICAgW2Nzc0NsYXNzZXMuT1VUTElORURdOiBvdXRsaW5lZCAmJiAhZnVsbFdpZHRoLFxyXG4gICAgICAgIFtjc3NDbGFzc2VzLlRFWFRBUkVBXTogdGV4dGFyZWEsXHJcbiAgICAgICAgW2Nzc0NsYXNzZXMuRElTQUJMRURdOiBkaXNhYmxlZCxcclxuICAgICAgICBbY3NzQ2xhc3Nlcy5GT0NVU0VEXTogZm9jdXNlZCxcclxuICAgICAgICBbY3NzQ2xhc3Nlcy5JTlZBTElEXTogIXZhbGlkICYmIHRvdWNoZWQsXHJcbiAgICAgICAgW2Nzc0NsYXNzZXMuTEFCRUxfRkxPQVRJTkddOiBmb2N1c2VkT3JIYXNWYWx1ZSxcclxuICAgICAgICBbY3NzQ2xhc3Nlcy5OT19MQUJFTF06ICFsYWJlbCxcclxuICAgICAgICBbY3NzQ2xhc3Nlcy5FTkRfQUxJR05FRF06IGVuZEFsaWduZWQsXHJcbiAgICAgICAgW2Nzc0NsYXNzZXMuV0lUSF9MRUFESU5HX0lDT05dOiBsZWFkaW5nSWNvbixcclxuICAgICAgICBbY3NzQ2xhc3Nlcy5XSVRIX1RSQUlMSU5HX0lDT05dOiB0cmFpbGluZ0ljb24sXHJcbiAgICAgICAgW2Nzc0NsYXNzZXMuV0lUSF9JTlRFUk5BTF9DT1VOVEVSXTogaW50ZXJuYWxDb3VudGVyXHJcbiAgICB9LCBjbGFzc05hbWUpO1xyXG5cclxuICAgIHJldHVybiAoPD5cclxuICAgICAgICA8RWxlbWVudFxyXG4gICAgICAgICAgICByZWY9e3JlZn1cclxuICAgICAgICAgICAgY2xhc3NOYW1lPXtjbGFzc05hbWVzfVxyXG4gICAgICAgICAgICBvbk1vdXNlRG93bj17aGFuZGxlSW50ZXJhY3Rpb259XHJcbiAgICAgICAgICAgIG9uVG91Y2hTdGFydD17aGFuZGxlSW50ZXJhY3Rpb259XHJcbiAgICAgICAgPlxyXG4gICAgICAgICAgICB7ZmlsbGVkICYmXHJcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17Y3NzQ2xhc3Nlcy5SSVBQTEV9IC8+XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHtmaWxsZWQgJiYgbGFiZWwgJiZcclxuICAgICAgICAgICAgICAgIDxGbG9hdGluZ0xhYmVsXHJcbiAgICAgICAgICAgICAgICAgICAgbGFiZWw9e2xhYmVsfVxyXG4gICAgICAgICAgICAgICAgICAgIGZsb2F0PXtmb2N1c2VkT3JIYXNWYWx1ZX1cclxuICAgICAgICAgICAgICAgIC8+XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHtvdXRsaW5lZCAmJlxyXG4gICAgICAgICAgICAgICAgPE5vdGNoZWRPdXRsaW5lIG5vdGNoZWQ9e2ZvY3VzZWRPckhhc1ZhbHVlfT5cclxuICAgICAgICAgICAgICAgICAgICB7bGFiZWwgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgPEZsb2F0aW5nTGFiZWxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsPXtsYWJlbH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZsb2F0PXtmb2N1c2VkT3JIYXNWYWx1ZX1cclxuICAgICAgICAgICAgICAgICAgICAgICAgLz5cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICA8L05vdGNoZWRPdXRsaW5lPlxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB7bGVhZGluZ0ljb24gJiZcclxuICAgICAgICAgICAgICAgIDxDbG9uZVxyXG4gICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudD17bGVhZGluZ0ljb259XHJcbiAgICAgICAgICAgICAgICAgICAgZmFsbGJhY2s9e0ljb259XHJcbiAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPXtgJHtjc3NDbGFzc2VzLklDT059ICR7Y3NzQ2xhc3Nlcy5JQ09OX0xFQURJTkd9YH1cclxuICAgICAgICAgICAgICAgICAgICB0YWJJbmRleD1cIjBcIlxyXG4gICAgICAgICAgICAgICAgICAgIHJvbGU9XCJidXR0b25cIlxyXG4gICAgICAgICAgICAgICAgLz5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAge3ByZWZpeCAmJlxyXG4gICAgICAgICAgICAgICAgPHNwYW4gY2xhc3NOYW1lPXtgJHtjc3NDbGFzc2VzLkFGRklYfSAke2Nzc0NsYXNzZXMuQUZGSVhfUFJFRklYfWB9PntwcmVmaXh9PC9zcGFuPlxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICA8UmVzaXplclxyXG4gICAgICAgICAgICAgICAgdGV4dGFyZWE9e3RleHRhcmVhfVxyXG4gICAgICAgICAgICAgICAgYXV0b1Jlc2l6ZT17YXV0b1Jlc2l6ZX1cclxuICAgICAgICAgICAgPlxyXG4gICAgICAgICAgICAgICAgPElucHV0XHJcbiAgICAgICAgICAgICAgICAgICAgcmVmPXtpbnB1dFJlZn1cclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZT17dmFsdWV9XHJcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdFZhbHVlPXtkZWZhdWx0VmFsdWV9XHJcbiAgICAgICAgICAgICAgICAgICAgdGV4dGFyZWE9e3RleHRhcmVhfVxyXG4gICAgICAgICAgICAgICAgICAgIGF1dG9SZXNpemU9e2F1dG9SZXNpemV9XHJcbiAgICAgICAgICAgICAgICAgICAgZGlzYWJsZWQ9e2Rpc2FibGVkfVxyXG4gICAgICAgICAgICAgICAgICAgIG9uSW5wdXQ9e2hhbmRsZUlucHV0Q2hhbmdlfVxyXG4gICAgICAgICAgICAgICAgICAgIG9uRm9jdXM9e2hhbmRsZUlucHV0Rm9jdXN9XHJcbiAgICAgICAgICAgICAgICAgICAgb25CbHVyPXtoYW5kbGVJbnB1dEJsdXJ9XHJcbiAgICAgICAgICAgICAgICAgICAgey4uLnByb3BzfVxyXG4gICAgICAgICAgICAgICAgLz5cclxuXHJcbiAgICAgICAgICAgICAgICB7aW50ZXJuYWxDb3VudGVyICYmXHJcbiAgICAgICAgICAgICAgICAgICAgPENoYXJhY3RlckNvdW50ZXJcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU9e2NvdW50fVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXhWYWx1ZT17cHJvcHMubWF4TGVuZ3RofVxyXG4gICAgICAgICAgICAgICAgICAgIC8+XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIDwvUmVzaXplcj5cclxuXHJcbiAgICAgICAgICAgIHtzdWZmaXggJiZcclxuICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT17YCR7Y3NzQ2xhc3Nlcy5BRkZJWH0gJHtjc3NDbGFzc2VzLkFGRklYX1NVRkZJWH1gfT57c3VmZml4fTwvc3Bhbj5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAge3RyYWlsaW5nSWNvbiAmJlxyXG4gICAgICAgICAgICAgICAgPENsb25lXHJcbiAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50PXt0cmFpbGluZ0ljb259XHJcbiAgICAgICAgICAgICAgICAgICAgZmFsbGJhY2s9e0ljb259XHJcbiAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPXtgJHtjc3NDbGFzc2VzLklDT059ICR7Y3NzQ2xhc3Nlcy5JQ09OX1RSQUlMSU5HfWB9XHJcbiAgICAgICAgICAgICAgICAgICAgdGFiSW5kZXg9XCIwXCJcclxuICAgICAgICAgICAgICAgICAgICByb2xlPVwiYnV0dG9uXCJcclxuICAgICAgICAgICAgICAgIC8+XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHtmaWxsZWQgJiZcclxuICAgICAgICAgICAgICAgIDxMaW5lUmlwcGxlXHJcbiAgICAgICAgICAgICAgICAgICAgYWN0aXZlPXtmb2N1c2VkfVxyXG4gICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybU9yaWdpbj17aW50ZXJhY3Rpb25Db29yZHM/Lnh9XHJcbiAgICAgICAgICAgICAgICAvPlxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgPC9FbGVtZW50PlxyXG5cclxuICAgICAgICB7aGFzSGVscGVyTGluZSAmJlxyXG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17Y3NzQ2xhc3Nlcy5IRUxQRVJfTElORX0+XHJcbiAgICAgICAgICAgICAgICB7aGVscGVyVGV4dCAmJlxyXG4gICAgICAgICAgICAgICAgICAgIDxIZWxwZXJUZXh0IHBlcnNpc3RlbnQ9e0Jvb2xlYW4ocGVyc2lzdGVudEhlbHBlclRleHQpfT57aGVscGVyVGV4dH08L0hlbHBlclRleHQ+XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgeyh2YWxpZGF0aW9uTWVzc2FnZSAmJiAhdmFsaWQpICYmXHJcbiAgICAgICAgICAgICAgICAgICAgPEhlbHBlclRleHQgdmFsaWRhdGlvbj57dHlwZW9mIHZhbGlkYXRpb25NZXNzYWdlID09PSAnc3RyaW5nJyA/IHZhbGlkYXRpb25NZXNzYWdlIDogaW5wdXRSZWYuY3VycmVudD8udmFsaWRhdGlvbk1lc3NhZ2V9PC9IZWxwZXJUZXh0PlxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHsocHJvcHMubWF4TGVuZ3RoICYmICFpbnRlcm5hbENvdW50ZXIpICYmXHJcbiAgICAgICAgICAgICAgICAgICAgPENoYXJhY3RlckNvdW50ZXJcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU9e2NvdW50fVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXhWYWx1ZT17cHJvcHMubWF4TGVuZ3RofVxyXG4gICAgICAgICAgICAgICAgICAgIC8+XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgIH1cclxuICAgIDwvPik7XHJcbn0pO1xyXG5cclxuVGV4dEZpZWxkLmRpc3BsYXlOYW1lID0gJ01EQ1RleHRGaWVsZCc7XHJcblxyXG5UZXh0RmllbGQucHJvcFR5cGVzID0ge1xyXG4gICAgdmFsdWU6IFByb3BUeXBlcy5hbnksXHJcbiAgICBsYWJlbDogUHJvcFR5cGVzLnN0cmluZyxcclxuICAgIGxlYWRpbmdJY29uOiBQcm9wVHlwZXMubm9kZSxcclxuICAgIHRyYWlsaW5nSWNvbjogUHJvcFR5cGVzLm5vZGUsXHJcbiAgICBwcmVmaXg6IFByb3BUeXBlcy5zdHJpbmcsXHJcbiAgICBzdWZmaXg6IFByb3BUeXBlcy5zdHJpbmcsXHJcbiAgICBvdXRsaW5lOiBQcm9wVHlwZXMuYm9vbCxcclxuICAgIGZ1bGxXaWR0aDogUHJvcFR5cGVzLmJvb2wsXHJcbiAgICB0ZXh0YXJlYTogUHJvcFR5cGVzLmJvb2wsXHJcbiAgICBkZW5zZTogUHJvcFR5cGVzLmJvb2wsXHJcbiAgICBkaXNhYmxlZDogUHJvcFR5cGVzLmJvb2wsXHJcbiAgICBoZWxwZXJUZXh0OiBQcm9wVHlwZXMuc3RyaW5nLFxyXG4gICAgcGVyc2lzdGVudEhlbHBlclRleHQ6IFByb3BUeXBlcy5zdHJpbmcsXHJcbiAgICB2YWxpZGF0aW9uTWVzc2FnZTogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLmJvb2wsIFByb3BUeXBlcy5zdHJpbmddKVxyXG59O1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgVGV4dEZpZWxkOyIsImV4cG9ydCB7IGRlZmF1bHQgfSBmcm9tICcuL1RleHRGaWVsZCc7IiwiZXhwb3J0IGNvbnN0IG51bWJlcnMgPSB7XHJcbiAgICBERUJPVU5DRV9USFJPVFRMRV9SRVNJWkVfVElNRV9NUzogMTAwLFxyXG4gICAgTUFYX1RPUF9BUFBfQkFSX0hFSUdIVDogMTI4XHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgY3NzQ2xhc3NlcyA9IHtcclxuICAgIFJPT1Q6ICdtZGMtdG9wLWFwcC1iYXInLFxyXG4gICAgU1RJQ0tZOiAnbWRjLXRvcC1hcHAtYmFyLS1zdGlja3knLFxyXG4gICAgU1RJQ0tZX0hJRERFTjogJ21kYy10b3AtYXBwLWJhci0tc3RpY2t5LWhpZGRlbicsXHJcbiAgICBTVElDS1lfU0hPV046ICdtZGMtdG9wLWFwcC1iYXItLXN0aWNreS1zaG93bicsXHJcbiAgICBGSVhFRDogJ21kYy10b3AtYXBwLWJhci0tZml4ZWQnLFxyXG4gICAgRklYRURfU0NST0xMRUQ6ICdtZGMtdG9wLWFwcC1iYXItLWZpeGVkLXNjcm9sbGVkJyxcclxuICAgIEZJWEVEX0FESlVTVDogJ21kYy10b3AtYXBwLWJhci0tZml4ZWQtYWRqdXN0JyxcclxuICAgIFBST01JTkVOVDogJ21kYy10b3AtYXBwLWJhci0tcHJvbWluZW50JyxcclxuICAgIFBST01JTkVOVF9GSVhFRF9BREpVU1Q6ICdtZGMtdG9wLWFwcC1iYXItLXByb21pbmVudC1maXhlZC1hZGp1c3QnLFxyXG4gICAgREVOU0U6ICdtZGMtdG9wLWFwcC1iYXItLWRlbnNlJyxcclxuICAgIERFTlNFX0ZJWEVEX0FESlVTVDogJ21kYy10b3AtYXBwLWJhci0tZGVuc2UtZml4ZWQtYWRqdXN0JyxcclxuICAgIERFTlNFX1BST01JTkVOVF9GSVhFRF9BREpVU1Q6ICdtZGMtdG9wLWFwcC1iYXItLWRlbnNlLXByb21pbmVudC1maXhlZC1hZGp1c3QnLFxyXG4gICAgU0hPUlQ6ICdtZGMtdG9wLWFwcC1iYXItLXNob3J0JyxcclxuICAgIFNIT1JUX0NPTExBUFNFRDogJ21kYy10b3AtYXBwLWJhci0tc2hvcnQtY29sbGFwc2VkJyxcclxuICAgIFNIT1JUX0ZJWEVEX0FESlVTVDogJ21kYy10b3AtYXBwLWJhci0tc2hvcnQtZml4ZWQtYWRqdXN0JyxcclxuXHJcbiAgICBST1c6ICdtZGMtdG9wLWFwcC1iYXJfX3JvdycsXHJcblxyXG4gICAgU0VDVElPTjogJ21kYy10b3AtYXBwLWJhcl9fc2VjdGlvbicsXHJcbiAgICBTRUNUSU9OX0FMSUdOX1NUQVJUOiAnbWRjLXRvcC1hcHAtYmFyX19zZWN0aW9uLS1hbGlnbi1zdGFydCcsXHJcbiAgICBTRUNUSU9OX0FMSUdOX0NFTlRFUjogJ21kYy10b3AtYXBwLWJhcl9fc2VjdGlvbi0tYWxpZ24tY2VudGVyJyxcclxuICAgIFNFQ1RJT05fQUxJR05fRU5EOiAnbWRjLXRvcC1hcHAtYmFyX19zZWN0aW9uLS1hbGlnbi1lbmQnLFxyXG5cclxuICAgIE5BVklHQVRJT05fSUNPTjogJ21kYy10b3AtYXBwLWJhcl9fbmF2aWdhdGlvbi1pY29uJyxcclxuXHJcbiAgICBBQ1RJT05fSVRFTTogJ21kYy10b3AtYXBwLWJhcl9fYWN0aW9uLWl0ZW0nLFxyXG5cclxuICAgIFRJVExFOiAnbWRjLXRvcC1hcHAtYmFyX190aXRsZSdcclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCBBbGlnbiA9IHtcclxuICAgIFNUQVJUOiAnc3RhcnQnLFxyXG4gICAgQ0VOVEVSOiAnY2VudGVyJyxcclxuICAgIEVORDogJ2VuZCdcclxufTsiLCJpbXBvcnQgeyBmb3J3YXJkUmVmIH0gZnJvbSAncmVhY3QnO1xyXG5pbXBvcnQgY2xhc3NuYW1lcyBmcm9tICdjbGFzc25hbWVzJztcclxuXHJcbmltcG9ydCB7IGNzc0NsYXNzZXMgfSBmcm9tICcuL2NvbnN0YW50cyc7XHJcblxyXG5jb25zdCBUb3BBcHBCYXJSb3cgPSBmb3J3YXJkUmVmKCh7XHJcbiAgICBlbGVtZW50OiBFbGVtZW50ID0gJ2RpdicsXHJcbiAgICBjbGFzc05hbWUsXHJcbiAgICAuLi5wcm9wc1xyXG59LCByZWYpID0+IHtcclxuICAgIGNvbnN0IGNsYXNzTmFtZXMgPSBjbGFzc25hbWVzKGNzc0NsYXNzZXMuUk9XLCBjbGFzc05hbWUpO1xyXG5cclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgPEVsZW1lbnQgcmVmPXtyZWZ9IGNsYXNzTmFtZT17Y2xhc3NOYW1lc30gey4uLnByb3BzfSAvPlxyXG4gICAgKTtcclxufSk7XHJcblxyXG5Ub3BBcHBCYXJSb3cuZGlzcGxheU5hbWUgPSAnTURDVG9wQXBwQmFyUm93JztcclxuXHJcbmV4cG9ydCBkZWZhdWx0IFRvcEFwcEJhclJvdzsiLCJpbXBvcnQgeyBmb3J3YXJkUmVmIH0gZnJvbSAncmVhY3QnO1xyXG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xyXG5pbXBvcnQgY2xhc3NuYW1lcyBmcm9tICdjbGFzc25hbWVzJztcclxuXHJcbmltcG9ydCB7IGNzc0NsYXNzZXMsIEFsaWduIH0gZnJvbSAnLi9jb25zdGFudHMnO1xyXG5cclxuY29uc3QgVG9wQXBwQmFyU2VjdGlvbiA9IGZvcndhcmRSZWYoKHtcclxuICAgIGFsaWduLFxyXG5cclxuICAgIGVsZW1lbnQ6IEVsZW1lbnQgPSAnc2VjdGlvbicsXHJcbiAgICBjbGFzc05hbWUsXHJcbiAgICAuLi5wcm9wc1xyXG59LCByZWYpID0+IHtcclxuICAgIGNvbnN0IGNsYXNzTmFtZXMgPSBjbGFzc25hbWVzKGNzc0NsYXNzZXMuU0VDVElPTiwge1xyXG4gICAgICAgIFtjc3NDbGFzc2VzLlNFQ1RJT05fQUxJR05fU1RBUlRdOiBhbGlnbiA9PT0gQWxpZ24uU1RBUlQsXHJcbiAgICAgICAgW2Nzc0NsYXNzZXMuU0VDVElPTl9BTElHTl9DRU5URVJdOiBhbGlnbiA9PT0gQWxpZ24uQ0VOVEVSLFxyXG4gICAgICAgIFtjc3NDbGFzc2VzLlNFQ1RJT05fQUxJR05fRU5EXTogYWxpZ24gPT09IEFsaWduLkVORFxyXG4gICAgfSwgY2xhc3NOYW1lKTtcclxuXHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAgIDxFbGVtZW50IHJlZj17cmVmfSBjbGFzc05hbWU9e2NsYXNzTmFtZXN9IHsuLi5wcm9wc30gLz5cclxuICAgICk7XHJcbn0pO1xyXG5cclxuVG9wQXBwQmFyU2VjdGlvbi5kaXNwbGF5TmFtZSA9ICdNRENUb3BBcHBCYXJTZWN0aW9uJztcclxuXHJcblRvcEFwcEJhclNlY3Rpb24ucHJvcFR5cGVzID0ge1xyXG4gICAgYWxpZ246IFByb3BUeXBlcy5vbmVPZihPYmplY3QudmFsdWVzKEFsaWduKSlcclxufTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IFRvcEFwcEJhclNlY3Rpb247IiwiaW1wb3J0IHsgZm9yd2FyZFJlZiwgdXNlUmVmLCB1c2VTdGF0ZSwgdXNlRWZmZWN0LCB1c2VJbXBlcmF0aXZlSGFuZGxlLCBDaGlsZHJlbiB9IGZyb20gJ3JlYWN0JztcclxuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcclxuaW1wb3J0IGNsYXNzbmFtZXMgZnJvbSAnY2xhc3NuYW1lcyc7XHJcblxyXG5pbXBvcnQgeyBDbG9uZSB9IGZyb20gJy4uL2NvbXBvbmVudCc7XHJcbmltcG9ydCBJY29uQnV0dG9uIGZyb20gJy4uL2ljb24tYnV0dG9uJztcclxuXHJcbmltcG9ydCB7IGNzc0NsYXNzZXMsIEFsaWduIH0gZnJvbSAnLi9jb25zdGFudHMnO1xyXG5pbXBvcnQgVG9wQXBwQmFyUm93IGZyb20gJy4vVG9wQXBwQmFyUm93JztcclxuaW1wb3J0IFRvcEFwcEJhclNlY3Rpb24gZnJvbSAnLi9Ub3BBcHBCYXJTZWN0aW9uJztcclxuXHJcbmNvbnN0IFRvcEFwcEJhciA9IGZvcndhcmRSZWYoKHtcclxuICAgIHRpdGxlLFxyXG4gICAgbmF2aWdhdGlvbkljb24sXHJcbiAgICBhY3Rpb25JdGVtcyxcclxuICAgIGZpeGVkID0gZmFsc2UsXHJcbiAgICBzdGlja3kgPSBmYWxzZSxcclxuICAgIGRlbnNlID0gZmFsc2UsXHJcbiAgICBwcm9taW5lbnQgPSBmYWxzZSxcclxuICAgIHNob3J0ID0gZmFsc2UsXHJcbiAgICBjb2xsYXBzZWQgPSBmYWxzZSxcclxuICAgIG9uTmF2aWdhdGlvbkljb25DbGljayA9IEZ1bmN0aW9uLnByb3RvdHlwZSxcclxuXHJcbiAgICBlbGVtZW50ID0gJ2hlYWRlcicsXHJcbiAgICBjb21wb25lbnQ6IEVsZW1lbnQgPSBlbGVtZW50LFxyXG4gICAgY2xhc3NOYW1lLFxyXG4gICAgY2hpbGRyZW4sXHJcbiAgICAuLi5wcm9wc1xyXG59LCByZWYpID0+IHtcclxuICAgIGNvbnN0IHJvb3RSZWYgPSB1c2VSZWYoKTtcclxuICAgIGNvbnN0IFtzY3JvbGxlZCwgc2V0U2Nyb2xsZWRdID0gdXNlU3RhdGUoZmFsc2UpO1xyXG4gICAgY29uc3QgW2hpZGRlbiwgc2V0SGlkZGVuXSA9IHVzZVN0YXRlKGZhbHNlKTtcclxuXHJcbiAgICB1c2VJbXBlcmF0aXZlSGFuZGxlKHJlZiwgKCkgPT4gcm9vdFJlZi5jdXJyZW50KTtcclxuXHJcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgICAgIGxldCBsYXN0U2Nyb2xsUG9zaXRpb24gPSAwO1xyXG5cclxuICAgICAgICBmdW5jdGlvbiBoYW5kbGVTY3JvbGwoKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHNjcm9sbFZhbHVlID0gd2luZG93LnBhZ2VZT2Zmc2V0O1xyXG5cclxuICAgICAgICAgICAgaWYgKGZpeGVkKSB7XHJcbiAgICAgICAgICAgICAgICBzZXRTY3JvbGxlZChzY3JvbGxWYWx1ZSA+IDApO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHN0aWNreSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgY3VycmVudFNjcm9sbFBvc2l0aW9uID0gTWF0aC5tYXgoc2Nyb2xsVmFsdWUsIDApO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZGlmZiA9IGN1cnJlbnRTY3JvbGxQb3NpdGlvbiAtIGxhc3RTY3JvbGxQb3NpdGlvbjtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHNob3VsZEhpZGUgPSBkaWZmID4gMDtcclxuXHJcbiAgICAgICAgICAgICAgICBsYXN0U2Nyb2xsUG9zaXRpb24gPSBjdXJyZW50U2Nyb2xsUG9zaXRpb247XHJcblxyXG4gICAgICAgICAgICAgICAgc2V0SGlkZGVuKHNob3VsZEhpZGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgaGFuZGxlU2Nyb2xsKTtcclxuXHJcbiAgICAgICAgcmV0dXJuICgpID0+IHtcclxuICAgICAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIGhhbmRsZVNjcm9sbCk7XHJcbiAgICAgICAgfTtcclxuICAgIH0sIFtmaXhlZCwgc3RpY2t5XSk7XHJcblxyXG4gICAgY29uc3QgY2xhc3NOYW1lcyA9IGNsYXNzbmFtZXMoY3NzQ2xhc3Nlcy5ST09ULCB7XHJcbiAgICAgICAgW2Nzc0NsYXNzZXMuRklYRURdOiBmaXhlZCxcclxuICAgICAgICBbY3NzQ2xhc3Nlcy5TVElDS1ldOiBzdGlja3ksXHJcbiAgICAgICAgW2Nzc0NsYXNzZXMuREVOU0VdOiBkZW5zZSxcclxuICAgICAgICBbY3NzQ2xhc3Nlcy5QUk9NSU5FTlRdOiBwcm9taW5lbnQsXHJcbiAgICAgICAgW2Nzc0NsYXNzZXMuU0hPUlRdOiBzaG9ydCxcclxuICAgICAgICBbY3NzQ2xhc3Nlcy5TSE9SVF9DT0xMQVBTRURdOiBzaG9ydCAmJiBjb2xsYXBzZWQsXHJcbiAgICAgICAgW2Nzc0NsYXNzZXMuRklYRURfU0NST0xMRURdOiBmaXhlZCAmJiBzY3JvbGxlZCxcclxuICAgICAgICBbY3NzQ2xhc3Nlcy5TVElDS1lfSElEREVOXTogc3RpY2t5ICYmIGhpZGRlbixcclxuICAgICAgICBbY3NzQ2xhc3Nlcy5TVElDS1lfU0hPV05dOiBzdGlja3kgJiYgIWhpZGRlblxyXG4gICAgfSwgY2xhc3NOYW1lKTtcclxuXHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAgIDxFbGVtZW50XHJcbiAgICAgICAgICAgIHJlZj17cm9vdFJlZn1cclxuICAgICAgICAgICAgY2xhc3NOYW1lPXtjbGFzc05hbWVzfVxyXG4gICAgICAgICAgICB7Li4ucHJvcHN9XHJcbiAgICAgICAgPlxyXG4gICAgICAgICAgICB7Y2hpbGRyZW4gfHxcclxuICAgICAgICAgICAgICAgIDxUb3BBcHBCYXJSb3c+XHJcbiAgICAgICAgICAgICAgICAgICAgeyh0aXRsZSB8fCBuYXZpZ2F0aW9uSWNvbikgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgPFRvcEFwcEJhclNlY3Rpb24gYWxpZ249e0FsaWduLlNUQVJUfT5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtuYXZpZ2F0aW9uSWNvbiAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxDbG9uZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21wb25lbnQ9e25hdmlnYXRpb25JY29ufVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmYWxsYmFjaz17SWNvbkJ1dHRvbn1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPXtjc3NDbGFzc2VzLk5BVklHQVRJT05fSUNPTn1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb25DbGljaz17b25OYXZpZ2F0aW9uSWNvbkNsaWNrfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge3RpdGxlICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPENsb25lXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudD17dGl0bGV9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZhbGxiYWNrPVwic3BhblwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT17Y3NzQ2xhc3Nlcy5USVRMRX1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8L1RvcEFwcEJhclNlY3Rpb24+XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICB7YWN0aW9uSXRlbXMgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgPFRvcEFwcEJhclNlY3Rpb24gYWxpZ249e0FsaWduLkVORH0+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7Q2hpbGRyZW4ubWFwKGFjdGlvbkl0ZW1zLCBpdGVtID0+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPENsb25lXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudD17aXRlbX1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPXtjc3NDbGFzc2VzLkFDVElPTl9JVEVNfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8L1RvcEFwcEJhclNlY3Rpb24+XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgPC9Ub3BBcHBCYXJSb3c+XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICA8L0VsZW1lbnQ+XHJcbiAgICApO1xyXG59KTtcclxuXHJcblRvcEFwcEJhci5kaXNwbGF5TmFtZSA9ICdNRENUb3BBcHBCYXInO1xyXG5cclxuVG9wQXBwQmFyLnByb3BUeXBlcyA9IHtcclxuICAgIHRpdGxlOiBQcm9wVHlwZXMubm9kZSxcclxuICAgIG5hdmlnYXRpb25JY29uOiBQcm9wVHlwZXMubm9kZSxcclxuICAgIGFjdGlvbkl0ZW1zOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtcclxuICAgICAgICBQcm9wVHlwZXMuZWxlbWVudCxcclxuICAgICAgICBQcm9wVHlwZXMuYXJyYXlPZihQcm9wVHlwZXMuZWxlbWVudCksXHJcbiAgICBdKSxcclxuICAgIGZpeGVkOiBQcm9wVHlwZXMuYm9vbCxcclxuICAgIHN0aWNreTogUHJvcFR5cGVzLmJvb2wsXHJcbiAgICBkZW5zZTogUHJvcFR5cGVzLmJvb2wsXHJcbiAgICBwcm9taW5lbnQ6IFByb3BUeXBlcy5ib29sLFxyXG4gICAgc2hvcnQ6IFByb3BUeXBlcy5ib29sLFxyXG4gICAgY29sbGFwc2VkOiBQcm9wVHlwZXMuYm9vbFxyXG59O1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgVG9wQXBwQmFyOyIsImltcG9ydCB7IGZvcndhcmRSZWYgfSBmcm9tICdyZWFjdCc7XHJcbmltcG9ydCBjbGFzc25hbWVzIGZyb20gJ2NsYXNzbmFtZXMnO1xyXG5pbXBvcnQgeyBjc3NDbGFzc2VzIH0gZnJvbSAnLi9jb25zdGFudHMnO1xyXG5cclxuY29uc3QgVG9wQXBwQmFyQWN0aW9uSXRlbSA9IGZvcndhcmRSZWYoKHtcclxuICAgIGVsZW1lbnQgPSAnc3BhbicsXHJcbiAgICBjb21wb25lbnQ6IEVsZW1lbnQgPSBlbGVtZW50LFxyXG4gICAgY2xhc3NOYW1lLFxyXG4gICAgLi4ucHJvcHNcclxufSwgcmVmKSA9PiB7XHJcbiAgICBjb25zdCBjbGFzc05hbWVzID0gY2xhc3NuYW1lcyhjc3NDbGFzc2VzLkFDVElPTl9JVEVNLCBjbGFzc05hbWUpO1xyXG5cclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgPEVsZW1lbnQgcmVmPXtyZWZ9IGNsYXNzTmFtZT17Y2xhc3NOYW1lc30gey4uLnByb3BzfSAvPlxyXG4gICAgKTtcclxufSk7XHJcblxyXG5Ub3BBcHBCYXJBY3Rpb25JdGVtLmRpc3BsYXlOYW1lID0gJ01EQ1RvcEFwcEJhckFjdGlvbkl0ZW0nO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgVG9wQXBwQmFyQWN0aW9uSXRlbTsiLCJpbXBvcnQgeyBmb3J3YXJkUmVmIH0gZnJvbSAncmVhY3QnO1xyXG5pbXBvcnQgY2xhc3NuYW1lcyBmcm9tICdjbGFzc25hbWVzJztcclxuXHJcbmltcG9ydCB7IGNzc0NsYXNzZXMgfSBmcm9tICcuL2NvbnN0YW50cyc7XHJcblxyXG5jb25zdCBUb3BBcHBCYXJGaXhlZEFkanVzdCA9IGZvcndhcmRSZWYoKHtcclxuICAgIGRlbnNlID0gZmFsc2UsXHJcbiAgICBwcm9taW5lbnQgPSBmYWxzZSxcclxuICAgIHNob3J0ID0gZmFsc2UsXHJcblxyXG4gICAgZWxlbWVudCA9ICdkaXYnLFxyXG4gICAgY29tcG9uZW50OiBFbGVtZW50ID0gZWxlbWVudCxcclxuICAgIGNsYXNzTmFtZSxcclxuICAgIC4uLnByb3BzXHJcbn0sIHJlZikgPT4ge1xyXG4gICAgY29uc3QgY2xhc3NOYW1lcyA9IGNsYXNzbmFtZXMoY3NzQ2xhc3Nlcy5GSVhFRF9BREpVU1QsIHtcclxuICAgICAgICBbY3NzQ2xhc3Nlcy5ERU5TRV9GSVhFRF9BREpVU1RdOiBkZW5zZSxcclxuICAgICAgICBbY3NzQ2xhc3Nlcy5QUk9NSU5FTlRfRklYRURfQURKVVNUXTogcHJvbWluZW50LFxyXG4gICAgICAgIFtjc3NDbGFzc2VzLkRFTlNFX1BST01JTkVOVF9GSVhFRF9BREpVU1RdOiBkZW5zZSAmJiBwcm9taW5lbnQsXHJcbiAgICAgICAgW2Nzc0NsYXNzZXMuU0hPUlRfRklYRURfQURKVVNUXTogc2hvcnRcclxuICAgIH0sIGNsYXNzTmFtZSk7XHJcblxyXG4gICAgcmV0dXJuIChcclxuICAgICAgICA8RWxlbWVudCByZWY9e3JlZn0gY2xhc3NOYW1lPXtjbGFzc05hbWVzfSB7Li4ucHJvcHN9IC8+XHJcbiAgICApO1xyXG59KTtcclxuXHJcblRvcEFwcEJhckZpeGVkQWRqdXN0LmRpc3BsYXlOYW1lID0gJ01EQ1RvcEFwcEJhckZpeGVkQWRqdXN0JztcclxuXHJcbmV4cG9ydCBkZWZhdWx0IFRvcEFwcEJhckZpeGVkQWRqdXN0OyIsImltcG9ydCB7IGZvcndhcmRSZWYgfSBmcm9tICdyZWFjdCc7XHJcbmltcG9ydCBjbGFzc25hbWVzIGZyb20gJ2NsYXNzbmFtZXMnO1xyXG5cclxuaW1wb3J0IEljb25CdXR0b24gZnJvbSAnLi4vaWNvbi1idXR0b24nO1xyXG5cclxuaW1wb3J0IHsgY3NzQ2xhc3NlcyB9IGZyb20gJy4vY29uc3RhbnRzJztcclxuXHJcbmNvbnN0IFRvcEFwcEJhck5hdmlnYXRpb25JY29uID0gZm9yd2FyZFJlZigoeyBjbGFzc05hbWUsIC4uLnByb3BzIH0sIHJlZikgPT4ge1xyXG4gICAgY29uc3QgY2xhc3NOYW1lcyA9IGNsYXNzbmFtZXMoY3NzQ2xhc3Nlcy5OQVZJR0FUSU9OX0lDT04sIGNsYXNzTmFtZSk7XHJcblxyXG4gICAgcmV0dXJuIChcclxuICAgICAgICA8SWNvbkJ1dHRvbiByZWY9e3JlZn0gY2xhc3NOYW1lPXtjbGFzc05hbWVzfSB7Li4ucHJvcHN9IC8+XHJcbiAgICApO1xyXG59KTtcclxuXHJcblRvcEFwcEJhck5hdmlnYXRpb25JY29uLmRpc3BsYXlOYW1lID0gJ01EQ1RvcEFwcEJhck5hdmlnYXRpb25JY29uJztcclxuXHJcbmV4cG9ydCBkZWZhdWx0IFRvcEFwcEJhck5hdmlnYXRpb25JY29uOyIsImltcG9ydCB7IGZvcndhcmRSZWYgfSBmcm9tICdyZWFjdCc7XHJcbmltcG9ydCBjbGFzc25hbWVzIGZyb20gJ2NsYXNzbmFtZXMnO1xyXG5cclxuaW1wb3J0IHsgY3NzQ2xhc3NlcyB9IGZyb20gJy4vY29uc3RhbnRzJztcclxuXHJcbmNvbnN0IFRvcEFwcEJhclRpdGxlID0gZm9yd2FyZFJlZigoe1xyXG4gICAgZWxlbWVudDogRWxlbWVudCA9ICdzcGFuJyxcclxuICAgIGNsYXNzTmFtZSxcclxuICAgIC4uLnByb3BzXHJcbn0sIHJlZikgPT4ge1xyXG4gICAgY29uc3QgY2xhc3NOYW1lcyA9IGNsYXNzbmFtZXMoY3NzQ2xhc3Nlcy5USVRMRSwgY2xhc3NOYW1lKTtcclxuXHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAgIDxFbGVtZW50IHJlZj17cmVmfSBjbGFzc05hbWU9e2NsYXNzTmFtZXN9IHsuLi5wcm9wc30gLz5cclxuICAgICk7XHJcbn0pO1xyXG5cclxuVG9wQXBwQmFyVGl0bGUuZGlzcGxheU5hbWUgPSAnTURDVG9wQXBwQmFyVGl0bGUnO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgVG9wQXBwQmFyVGl0bGU7IiwiaW1wb3J0IFRvcEFwcEJhciBmcm9tICcuL1RvcEFwcEJhcic7XHJcbmltcG9ydCBUb3BBcHBCYXJBY3Rpb25JdGVtIGZyb20gJy4vVG9wQXBwQmFyQWN0aW9uSXRlbSc7XHJcbmltcG9ydCBUb3BBcHBCYXJGaXhlZEFkanVzdCBmcm9tICcuL1RvcEFwcEJhckZpeGVkQWRqdXN0JztcclxuaW1wb3J0IFRvcEFwcEJhck5hdmlnYXRpb25JY29uIGZyb20gJy4vVG9wQXBwQmFyTmF2aWdhdGlvbkljb24nO1xyXG5pbXBvcnQgVG9wQXBwQmFyUm93IGZyb20gJy4vVG9wQXBwQmFyUm93JztcclxuaW1wb3J0IFRvcEFwcEJhclNlY3Rpb24gZnJvbSAnLi9Ub3BBcHBCYXJTZWN0aW9uJztcclxuaW1wb3J0IFRvcEFwcEJhclRpdGxlIGZyb20gJy4vVG9wQXBwQmFyVGl0bGUnO1xyXG5cclxuVG9wQXBwQmFyLkFjdGlvbkl0ZW0gPSBUb3BBcHBCYXJBY3Rpb25JdGVtO1xyXG5Ub3BBcHBCYXIuRml4ZWRBZGp1c3QgPSBUb3BBcHBCYXJGaXhlZEFkanVzdDtcclxuVG9wQXBwQmFyLk5hdmlnYXRpb25JY29uID0gVG9wQXBwQmFyTmF2aWdhdGlvbkljb247XHJcblRvcEFwcEJhci5Sb3cgPSBUb3BBcHBCYXJSb3c7XHJcblRvcEFwcEJhci5TZWN0aW9uID0gVG9wQXBwQmFyU2VjdGlvbjtcclxuVG9wQXBwQmFyLlRpdGxlID0gVG9wQXBwQmFyVGl0bGU7XHJcblxyXG5leHBvcnQge1xyXG4gICAgVG9wQXBwQmFyIGFzIGRlZmF1bHQsXHJcbiAgICBUb3BBcHBCYXJBY3Rpb25JdGVtLFxyXG4gICAgVG9wQXBwQmFyRml4ZWRBZGp1c3QsXHJcbiAgICBUb3BBcHBCYXJOYXZpZ2F0aW9uSWNvbixcclxuICAgIFRvcEFwcEJhclJvdyxcclxuICAgIFRvcEFwcEJhclNlY3Rpb24sXHJcbiAgICBUb3BBcHBCYXJUaXRsZVxyXG59OyIsImV4cG9ydCBjb25zdCBlbGVtZW50c0J5VHlwZSA9IHtcclxuICAgIGhlYWRsaW5lMTogJ2gxJyxcclxuICAgIGhlYWRsaW5lMjogJ2gyJyxcclxuICAgIGhlYWRsaW5lMzogJ2gzJyxcclxuICAgIGhlYWRsaW5lNDogJ2g0JyxcclxuICAgIGhlYWRsaW5lNTogJ2g1JyxcclxuICAgIGhlYWRsaW5lNjogJ2g2JyxcclxuICAgIHN1YnRpdGxlMTogJ2g1JyxcclxuICAgIHN1YnRpdGxlMjogJ2g2JyxcclxuICAgIGJvZHkxOiAncCcsXHJcbiAgICBib2R5MjogJ3AnLFxyXG4gICAgYnV0dG9uOiAnc3BhbicsXHJcbiAgICBjYXB0aW9uOiAnc3BhbicsXHJcbiAgICBvdmVybGluZTogJ3NwYW4nXHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgY3NzQ2xhc3NlcyA9IHtcclxuICAgIFJPT1Q6ICdtZGMtdHlwb2dyYXBoeScsXHJcbiAgICBESVNQTEFZOiAnbWRjLXR5cG9ncmFwaHktLWRpc3BsYXknLFxyXG4gICAgQUxJR046ICdtZGMtdHlwb2dyYXBoeS0tYWxpZ24nLFxyXG4gICAgTk9fTUFSR0lOOiAnbWRjLXR5cG9ncmFwaHktLW5vLW1hcmdpbicsXHJcbiAgICBOT19XUkFQOiAnbWRjLXR5cG9ncmFwaHktLW5vLXdyYXAnXHJcbn07IiwiaW1wb3J0IHsgZm9yd2FyZFJlZiB9IGZyb20gJ3JlYWN0JztcclxuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcclxuaW1wb3J0IGNsYXNzbmFtZXMgZnJvbSAnY2xhc3NuYW1lcyc7XHJcblxyXG5pbXBvcnQgeyBlbGVtZW50c0J5VHlwZSwgY3NzQ2xhc3NlcyB9IGZyb20gJy4vY29uc3RhbnRzJztcclxuXHJcbmNvbnN0IFR5cG9ncmFwaHkgPSBmb3J3YXJkUmVmKCh7XHJcbiAgICB0eXBlID0gJ2JvZHkxJyxcclxuICAgIGRpc3BsYXksXHJcbiAgICBhbGlnbixcclxuICAgIG5vTWFyZ2luID0gZmFsc2UsXHJcbiAgICBub1dyYXAgPSBmYWxzZSxcclxuXHJcbiAgICBlbGVtZW50ID0gZWxlbWVudHNCeVR5cGVbdHlwZV0sXHJcbiAgICBjb21wb25lbnQ6IEVsZW1lbnQgPSBlbGVtZW50LFxyXG4gICAgY2xhc3NOYW1lLFxyXG4gICAgLi4ucHJvcHNcclxufSwgcmVmKSA9PiB7XHJcbiAgICBjb25zdCBjbGFzc05hbWVzID0gY2xhc3NuYW1lcyhjc3NDbGFzc2VzLlJPT1QsIGAke2Nzc0NsYXNzZXMuUk9PVH0tLSR7dHlwZX1gLCB7XHJcbiAgICAgICAgW2Ake2Nzc0NsYXNzZXMuRElTUExBWX0tJHtkaXNwbGF5fWBdOiBkaXNwbGF5LFxyXG4gICAgICAgIFtgJHtjc3NDbGFzc2VzLkFMSUdOfS0ke2FsaWdufWBdOiBhbGlnbixcclxuICAgICAgICBbY3NzQ2xhc3Nlcy5OT19NQVJHSU5dOiBub01hcmdpbixcclxuICAgICAgICBbY3NzQ2xhc3Nlcy5OT19XUkFQXTogbm9XcmFwXHJcbiAgICB9LCBjbGFzc05hbWUpO1xyXG5cclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgPEVsZW1lbnQgcmVmPXtyZWZ9IGNsYXNzTmFtZT17Y2xhc3NOYW1lc30gey4uLnByb3BzfSAvPlxyXG4gICAgKTtcclxufSk7XHJcblxyXG5UeXBvZ3JhcGh5LmRpc3BsYXlOYW1lID0gJ01EQ1R5cG9ncmFwaHknO1xyXG5cclxuVHlwb2dyYXBoeS5wcm9wVHlwZXMgPSB7XHJcbiAgICB0eXBlOiBQcm9wVHlwZXMub25lT2YoT2JqZWN0LmtleXMoZWxlbWVudHNCeVR5cGUpKSxcclxuICAgIGRpc3BsYXk6IFByb3BUeXBlcy5vbmVPZihbJ2Jsb2NrJywgJ2lubGluZScsICdpbmxpbmUtYmxvY2snXSksXHJcbiAgICBhbGlnbjogUHJvcFR5cGVzLm9uZU9mKFsnbGVmdCcsICdjZW50ZXInLCAncmlnaHQnLCAnanVzdGlmeSddKSxcclxuICAgIG5vTWFyZ2luOiBQcm9wVHlwZXMuYm9vbCxcclxuICAgIG5vV3JhcDogUHJvcFR5cGVzLmJvb2xcclxufTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IFR5cG9ncmFwaHk7IiwiZXhwb3J0IHsgZGVmYXVsdCB9IGZyb20gJy4vVHlwb2dyYXBoeSc7IiwiZXhwb3J0IHsgZGVmYXVsdCBhcyBBdmF0YXIgfSBmcm9tICcuL2F2YXRhcic7XHJcbmV4cG9ydCB7IGRlZmF1bHQgYXMgQmFkZ2UgfSBmcm9tICcuL2JhZGdlJztcclxuZXhwb3J0IHsgZGVmYXVsdCBhcyBCYW5uZXIgfSBmcm9tICcuL2Jhbm5lcic7XHJcbmV4cG9ydCB7IGRlZmF1bHQgYXMgQnV0dG9uIH0gZnJvbSAnLi9idXR0b24nO1xyXG5leHBvcnQgeyBkZWZhdWx0IGFzIENhcmQsIENhcmRBY3Rpb24sIENhcmRBY3Rpb25zLCBDYXJkQWN0aW9uQnV0dG9ucywgQ2FyZEFjdGlvbkljb25zLCBDYXJkSGVhZGVyLCBDYXJkTWVkaWEsIENhcmRQcmltYXJ5QWN0aW9uLCBDYXJkU2VjdGlvbiB9IGZyb20gJy4vY2FyZCc7XHJcbmV4cG9ydCB7IGRlZmF1bHQgYXMgQ2hlY2tib3ggfSBmcm9tICcuL2NoZWNrYm94JztcclxuZXhwb3J0IHsgQ2hpcCwgQ2hpcFNldCB9IGZyb20gJy4vY2hpcHMnO1xyXG5leHBvcnQgeyBkZWZhdWx0IGFzIENpcmN1bGFyUHJvZ3Jlc3MgfSBmcm9tICcuL2NpcmN1bGFyLXByb2dyZXNzJztcclxuZXhwb3J0IHsgZGVmYXVsdCBhcyBJY29uIH0gZnJvbSAnLi9pY29uJztcclxuZXhwb3J0IHsgZGVmYXVsdCBhcyBJY29uQnV0dG9uIH0gZnJvbSAnLi9pY29uLWJ1dHRvbic7XHJcbmV4cG9ydCB7IGRlZmF1bHQgYXMgRGF0YVRhYmxlLCBEYXRhVGFibGVIZWFkZXIsIERhdGFUYWJsZUhlYWRlclJvdywgRGF0YVRhYmxlSGVhZGVyQ2VsbCwgRGF0YVRhYmxlQ29udGVudCwgRGF0YVRhYmxlUm93LCBEYXRhVGFibGVDZWxsLCBEYXRhVGFibGVGb290ZXIgfSBmcm9tICcuL2RhdGEtdGFibGUnO1xyXG5leHBvcnQgeyBkZWZhdWx0IGFzIERpYWxvZywgRGlhbG9nSGVhZGVyLCBEaWFsb2dDb250ZW50LCBEaWFsb2dBY3Rpb25zIH0gZnJvbSAnLi9kaWFsb2cnO1xyXG5leHBvcnQgeyBkZWZhdWx0IGFzIERyYXdlciwgRHJhd2VySGVhZGVyLCBEcmF3ZXJDb250ZW50IH0gZnJvbSAnLi9kcmF3ZXInO1xyXG5leHBvcnQgeyBkZWZhdWx0IGFzIEVsZXZhdGlvbiB9IGZyb20gJy4vZWxldmF0aW9uJztcclxuZXhwb3J0IHsgZGVmYXVsdCBhcyBGQUIgfSBmcm9tICcuL2ZhYic7XHJcbmV4cG9ydCB7IGRlZmF1bHQgYXMgRmxvYXRpbmdMYWJlbCB9IGZyb20gJy4vZmxvYXRpbmctbGFiZWwnO1xyXG5leHBvcnQgeyBkZWZhdWx0IGFzIEZvcm1GaWVsZCB9IGZyb20gJy4vZm9ybS1maWVsZCc7XHJcbmV4cG9ydCB7IGRlZmF1bHQgYXMgSW1hZ2VMaXN0LCBJbWFnZUxpc3RJdGVtIH0gZnJvbSAnLi9pbWFnZS1saXN0JztcclxuZXhwb3J0IHsgZGVmYXVsdCBhcyBMYXlvdXQgfSBmcm9tICcuL2xheW91dCc7XHJcbmV4cG9ydCB7IGRlZmF1bHQgYXMgTGF5b3V0R3JpZCwgTGF5b3V0R3JpZENlbGwgfSBmcm9tICcuL2xheW91dC1ncmlkJztcclxuZXhwb3J0IHsgZGVmYXVsdCBhcyBMaW5lYXJQcm9ncmVzcyB9IGZyb20gJy4vbGluZWFyLXByb2dyZXNzJztcclxuZXhwb3J0IHsgZGVmYXVsdCBhcyBMaW5lUmlwcGxlIH0gZnJvbSAnLi9saW5lLXJpcHBsZSc7XHJcbmV4cG9ydCB7IGRlZmF1bHQgYXMgTGlzdCwgTGlzdERpdmlkZXIsIExpc3RJdGVtLCBMaXN0SXRlbUNvbnRlbnQsIExpc3RJdGVtRW5kLCBMaXN0SXRlbVN0YXJ0LCBMaXN0R3JvdXAsIExpc3RHcm91cFN1YmhlYWRlciB9IGZyb20gJy4vbGlzdCc7XHJcbmV4cG9ydCB7IGRlZmF1bHQgYXMgTWVudSwgTWVudUFuY2hvciwgTWVudUl0ZW0sIE1lbnVPcmlnaW4sIE1lbnVTdXJmYWNlLCBNZW51U2VsZWN0aW9uR3JvdXAsIE1lbnVTZWxlY3Rpb25Hcm91cEljb24gfSBmcm9tICcuL21lbnUnO1xyXG5leHBvcnQgeyBkZWZhdWx0IGFzIE5vdGNoZWRPdXRsaW5lIH0gZnJvbSAnLi9ub3RjaGVkLW91dGxpbmUnO1xyXG5leHBvcnQgeyBkZWZhdWx0IGFzIFJhZGlvIH0gZnJvbSAnLi9yYWRpbyc7XHJcbmV4cG9ydCB7IFJpcHBsZSwgUmlwcGxlU3VyZmFjZSB9IGZyb20gJy4vcmlwcGxlJztcclxuZXhwb3J0IHsgZGVmYXVsdCBhcyBTZWdtZW50ZWRCdXR0b24sIFNlZ21lbnRlZEJ1dHRvblNlZ21lbnQgfSBmcm9tICcuL3NlZ21lbnRlZC1idXR0b24nO1xyXG5leHBvcnQgeyBkZWZhdWx0IGFzIFNpZGVTaGVldCwgU2lkZVNoZWV0SGVhZGVyLCBTaWRlU2hlZXRDb250ZW50IH0gZnJvbSAnLi9zaWRlLXNoZWV0JztcclxuZXhwb3J0IHsgZGVmYXVsdCBhcyBTZWxlY3QsIFNlbGVjdE9wdGlvbiB9IGZyb20gJy4vc2VsZWN0JztcclxuZXhwb3J0IHsgZGVmYXVsdCBhcyBTbGlkZXIgfSBmcm9tICcuL3NsaWRlcic7XHJcbmV4cG9ydCB7IGRlZmF1bHQgYXMgU25hY2tiYXIgfSBmcm9tICcuL3NuYWNrYmFyJztcclxuZXhwb3J0IHsgZGVmYXVsdCBhcyBTd2l0Y2ggfSBmcm9tICcuL3N3aXRjaCc7XHJcbmV4cG9ydCB7IFRhYiwgVGFiQmFyIH0gZnJvbSAnLi90YWJzJztcclxuZXhwb3J0IHsgVG9vbHRpcCwgUmljaFRvb2x0aXAgfSBmcm9tICcuL3Rvb2x0aXAnO1xyXG5leHBvcnQgeyBkZWZhdWx0IGFzIFRleHRGaWVsZCB9IGZyb20gJy4vdGV4dC1maWVsZCc7XHJcbmV4cG9ydCB7IGRlZmF1bHQgYXMgVG9wQXBwQmFyLCBUb3BBcHBCYXJBY3Rpb25JdGVtLCBUb3BBcHBCYXJOYXZpZ2F0aW9uSWNvbiwgVG9wQXBwQmFyUm93LCBUb3BBcHBCYXJTZWN0aW9uLCBUb3BBcHBCYXJUaXRsZSB9IGZyb20gJy4vdG9wLWFwcC1iYXInO1xyXG5leHBvcnQgeyBkZWZhdWx0IGFzIFR5cG9ncmFwaHkgfSBmcm9tICcuL3R5cG9ncmFwaHknOyIsImltcG9ydCB7IExpc3QsIFR5cG9ncmFwaHkgfSBmcm9tICdtZGMtcmVhY3QnO1xyXG5cclxuaW1wb3J0ICcuL2luZGV4LnNjc3MnO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gUGFnZSh7XHJcbiAgICBpZCxcclxuICAgIHRpdGxlLFxyXG4gICAgZGVzY3JpcHRpb24sXHJcbiAgICBsaW5rcyxcclxuXHJcbiAgICBjaGlsZHJlbixcclxuICAgIC4uLnByb3BzXHJcbn0pIHtcclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgPGFydGljbGUgaWQ9e2Ake2lkfS1wYWdlYH0gY2xhc3NOYW1lPVwicGFnZVwiIHsuLi5wcm9wc30+XHJcbiAgICAgICAgICAgIDxoZWFkZXIgY2xhc3NOYW1lPVwicGFnZS1oZWFkZXJcIj5cclxuICAgICAgICAgICAgICAgIDxUeXBvZ3JhcGh5IGNsYXNzTmFtZT1cInBhZ2UtdGl0bGVcIiB0eXBlPVwiaGVhZGxpbmU0XCIgbm9NYXJnaW4+e3RpdGxlfTwvVHlwb2dyYXBoeT5cclxuXHJcbiAgICAgICAgICAgICAgICB7ZGVzY3JpcHRpb24gJiZcclxuICAgICAgICAgICAgICAgICAgICA8VHlwb2dyYXBoeSBjbGFzc05hbWU9XCJwYWdlLWRlc2NyaXB0aW9uXCIgdHlwZT1cImJvZHkxXCIgbm9NYXJnaW4+e2Rlc2NyaXB0aW9ufTwvVHlwb2dyYXBoeT5cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICB7bGlua3MgJiZcclxuICAgICAgICAgICAgICAgICAgICA8TGlzdD5cclxuICAgICAgICAgICAgICAgICAgICAgICAge2xpbmtzLmd1aWRlICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8TGlzdC5JdGVtPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxhIGhyZWY9e2xpbmtzLmd1aWRlfSB0YXJnZXQ9XCJfYmxhbmtcIiByZWw9XCJub3JlZmVycmVyXCI+R3VpZGU8L2E+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L0xpc3QuSXRlbT5cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAge2xpbmtzLmRvY3MgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxMaXN0Lkl0ZW0+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGEgaHJlZj17bGlua3MuZG9jc30gdGFyZ2V0PVwiX2JsYW5rXCIgcmVsPVwibm9yZWZlcnJlclwiPkRvY3M8L2E+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L0xpc3QuSXRlbT5cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIDwvTGlzdD5cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgPC9oZWFkZXI+XHJcblxyXG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInBhZ2UtY29udGVudFwiPlxyXG4gICAgICAgICAgICAgICAge2NoaWxkcmVufVxyXG4gICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICA8L2FydGljbGU+XHJcbiAgICApO1xyXG59IiwiaW1wb3J0IHsgVHlwb2dyYXBoeSB9IGZyb20gJ21kYy1yZWFjdCc7XHJcbmltcG9ydCBjbGFzc25hbWVzIGZyb20gJ2NsYXNzbmFtZXMnO1xyXG5cclxuaW1wb3J0ICcuL2luZGV4LnNjc3MnO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gU2VjdGlvbih7IHRpdGxlLCBjaGlsZHJlbiwgY2xhc3NOYW1lLCAuLi5wcm9wcyB9KSB7XHJcbiAgICBjb25zdCBjbGFzc05hbWVzID0gY2xhc3NuYW1lcygnc2VjdGlvbicsIGNsYXNzTmFtZSk7XHJcblxyXG4gICAgcmV0dXJuIChcclxuICAgICAgICA8c2VjdGlvbiBjbGFzc05hbWU9e2NsYXNzTmFtZXN9IHsuLi5wcm9wc30+XHJcbiAgICAgICAgICAgIHt0aXRsZSAmJlxyXG4gICAgICAgICAgICAgICAgPFR5cG9ncmFwaHkgY2xhc3NOYW1lPVwic2VjdGlvbi10aXRsZVwiIHR5cGU9XCJoZWFkbGluZTZcIj57dGl0bGV9PC9UeXBvZ3JhcGh5PlxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB7Y2hpbGRyZW59XHJcbiAgICAgICAgPC9zZWN0aW9uPlxyXG4gICAgKTtcclxufSIsImltcG9ydCB7IENoaWxkcmVuLCBpc1ZhbGlkRWxlbWVudCwgdXNlU3RhdGUgfSBmcm9tICdyZWFjdCc7XHJcbmltcG9ydCB7IENhcmQsIEJ1dHRvbiB9IGZyb20gJ21kYy1yZWFjdCc7XHJcblxyXG5pbXBvcnQgJy4vaW5kZXguc2Nzcyc7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBDb2RlKHsgc2V0dXAsIGNoaWxkcmVuIH0pIHtcclxuICAgIGNvbnN0IFtpc0NvZGVPcGVuLCBzZXRDb2RlT3Blbl0gPSB1c2VTdGF0ZShmYWxzZSk7XHJcblxyXG4gICAgcmV0dXJuIChcclxuICAgICAgICA8c2VjdGlvbiBjbGFzc05hbWU9XCJjb2RlXCI+XHJcbiAgICAgICAgICAgIDxDYXJkIG91dGxpbmVkPlxyXG4gICAgICAgICAgICAgICAgPENhcmQuU2VjdGlvbiBwcmltYXJ5PlxyXG4gICAgICAgICAgICAgICAgICAgIHtzZXR1cH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAge2NoaWxkcmVufVxyXG4gICAgICAgICAgICAgICAgPC9DYXJkLlNlY3Rpb24+XHJcblxyXG4gICAgICAgICAgICAgICAge2lzQ29kZU9wZW4gJiZcclxuICAgICAgICAgICAgICAgICAgICA8Q2FyZC5TZWN0aW9uIHNlY29uZGFyeT5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPHByZT5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxjb2RlPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtDaGlsZHJlbi50b0FycmF5KGNoaWxkcmVuKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAubWFwKGNvbXBvbmVudCA9PiBwcmludENvbXBvbmVudChjb21wb25lbnQpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuam9pbignXFxuJylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2NvZGU+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDwvcHJlPlxyXG4gICAgICAgICAgICAgICAgICAgIDwvQ2FyZC5TZWN0aW9uPlxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIDxDYXJkLkFjdGlvbnM+XHJcbiAgICAgICAgICAgICAgICAgICAgPEJ1dHRvbiBsYWJlbD17aXNDb2RlT3BlbiA/ICdIaWRlIGNvZGUnIDogJ1Nob3cgY29kZSd9IG9uQ2xpY2s9eygpID0+IHNldENvZGVPcGVuKHYgPT4gIXYpfSAvPlxyXG4gICAgICAgICAgICAgICAgPC9DYXJkLkFjdGlvbnM+XHJcbiAgICAgICAgICAgIDwvQ2FyZD5cclxuICAgICAgICA8L3NlY3Rpb24+XHJcbiAgICApO1xyXG59XHJcblxyXG5mdW5jdGlvbiBwcmludENvbXBvbmVudChjb21wb25lbnQsIGRlcHRoID0gMCkge1xyXG4gICAgY29uc3QgZGlzcGxheU5hbWUgPSBjb21wb25lbnQudHlwZS5kaXNwbGF5TmFtZS5yZXBsYWNlKCdNREMnLCAnJyk7XHJcbiAgICBjb25zdCBjaGlsZHJlbiA9IGNvbXBvbmVudC5wcm9wcy5jaGlsZHJlbjtcclxuICAgIGNvbnN0IHByb3BzID0gT2JqZWN0LmVudHJpZXMoY29tcG9uZW50LnByb3BzKS5maWx0ZXIoKFtrZXksIHZhbHVlXSkgPT4ga2V5ICE9PSAnY2hpbGRyZW4nICYmIHZhbHVlICE9PSB1bmRlZmluZWQpO1xyXG4gICAgY29uc3QgaW5kZW50ID0gJyAgJy5yZXBlYXQoZGVwdGgpO1xyXG5cclxuICAgIGxldCByZXN1bHQgPSBpbmRlbnQgKyBgPCR7ZGlzcGxheU5hbWV9YDtcclxuXHJcbiAgICBpZiAoIWlzRW1wdHkocHJvcHMpKSB7XHJcbiAgICAgICAgcmVzdWx0ICs9IGAgJHtwcmludFByb3BzKHByb3BzLCBkZXB0aCArIDEpfWA7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKCFjaGlsZHJlbikge1xyXG4gICAgICAgIHJlc3VsdCArPSByZXN1bHQuZW5kc1dpdGgoJ1xcbicpID8gKGluZGVudCArICcvPicpIDogJyAvPic7XHJcbiAgICB9IGVsc2UgaWYgKGlzVmFsaWRFbGVtZW50KGNoaWxkcmVuKSkge1xyXG4gICAgICAgIHJlc3VsdCArPSBgPlxcbiR7cHJpbnRDb21wb25lbnQoY2hpbGRyZW4sIGRlcHRoICsgMSl9XFxuJHtpbmRlbnR9PC8ke2Rpc3BsYXlOYW1lfT5gO1xyXG4gICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGNoaWxkcmVuKSkge1xyXG4gICAgICAgIHJlc3VsdCArPSByZXN1bHQuZW5kc1dpdGgoJ1xcbicpID8gKGluZGVudCArICc+XFxuJykgOiAnPlxcbic7XHJcblxyXG4gICAgICAgIHJlc3VsdCArPSBjaGlsZHJlbi5tYXAoY2hpbGQgPT4gcHJpbnRDb21wb25lbnQoY2hpbGQsIGRlcHRoICsgMSkpLmpvaW4oJ1xcbicpO1xyXG5cclxuICAgICAgICByZXN1bHQgKz0gYFxcbiR7aW5kZW50fTwvJHtkaXNwbGF5TmFtZX0+YDtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcmVzdWx0ICs9IGA+JHtjaGlsZHJlbn08LyR7ZGlzcGxheU5hbWV9PmA7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufVxyXG5cclxuZnVuY3Rpb24gcHJpbnRQcm9wcyhwcm9wcywgZGVwdGgpIHtcclxuICAgIGxldCByZXN1bHQgPSAnJztcclxuICAgIGNvbnN0IGluZGVudCA9ICcgICcucmVwZWF0KGRlcHRoKTtcclxuXHJcbiAgICBpZiAocHJvcHMubGVuZ3RoIDwgMykge1xyXG4gICAgICAgIHJlc3VsdCArPSBwcm9wcy5tYXAocHJpbnRQcm9wKS5qb2luKCcgJyk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIHJlc3VsdCArPSBgXFxuJHtpbmRlbnR9JHtwcm9wcy5tYXAocHJpbnRQcm9wKS5qb2luKCdcXG4nICsgaW5kZW50KX1cXG5gO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHByaW50UHJvcChba2V5LCB2YWx1ZV0pIHtcclxuICAgIGlmICh2YWx1ZSA9PT0gdHJ1ZSkge1xyXG4gICAgICAgIHJldHVybiBrZXk7XHJcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICByZXR1cm4gYCR7a2V5fT1cIiR7dmFsdWV9XCJgO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICByZXR1cm4gYCR7a2V5fT17JHtwcmludFZhbHVlKHZhbHVlKX19YDtcclxuICAgIH1cclxufVxyXG5cclxuZnVuY3Rpb24gcHJpbnRWYWx1ZSh2YWx1ZSkge1xyXG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICByZXR1cm4gYCcke3ZhbHVlfSdgO1xyXG4gICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xyXG4gICAgICAgIHJldHVybiBgWyR7dmFsdWUubWFwKHYgPT4gcHJpbnRWYWx1ZSh2KSkuam9pbignLCAnKX1dYDtcclxuICAgIH0gZWxzZSBpZiAoaXNWYWxpZEVsZW1lbnQodmFsdWUpKSB7XHJcbiAgICAgICAgcmV0dXJuIHByaW50Q29tcG9uZW50KHZhbHVlKTtcclxuICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgcmV0dXJuIGAke3ZhbHVlLm5hbWUgfHwgJ1tGdW5jdGlvbl0nfWA7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgIH1cclxufVxyXG5cclxuZnVuY3Rpb24gaXNFbXB0eSh2YWx1ZSkge1xyXG4gICAgaWYgKCF2YWx1ZSkge1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xyXG4gICAgICAgIHJldHVybiB2YWx1ZS5sZW5ndGggPT09IDA7XHJcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcpIHtcclxuICAgICAgICByZXR1cm4gT2JqZWN0LmtleXModmFsdWUpLmxlbmd0aCA9PT0gMDtcclxuICAgIH1cclxufSIsImltcG9ydCB7IHVzZVN0YXRlIH0gZnJvbSAncmVhY3QnO1xyXG5pbXBvcnQge1xyXG4gICAgQXZhdGFyLFxyXG4gICAgTGF5b3V0LFxyXG4gICAgU2VnbWVudGVkQnV0dG9uXHJcbn0gZnJvbSAnbWRjLXJlYWN0JztcclxuXHJcbmltcG9ydCBQYWdlIGZyb20gJ0AvY29tcG9uZW50cy9QYWdlJztcclxuaW1wb3J0IFNlY3Rpb24gZnJvbSAnQC9jb21wb25lbnRzL1NlY3Rpb24nO1xyXG5pbXBvcnQgQ29kZSBmcm9tICdAL2NvbXBvbmVudHMvQ29kZSc7XHJcblxyXG5jb25zdCBpZCA9ICdhdmF0YXInO1xyXG5jb25zdCB0aXRsZSA9ICdBdmF0YXInO1xyXG5jb25zdCBkZXNjcmlwdGlvbiA9ICdBdmF0YXJzIGFyZSBmb3VuZCB0aHJvdWdob3V0IG1hdGVyaWFsIGRlc2lnbiB3aXRoIHVzZXMgaW4gZXZlcnl0aGluZyBmcm9tIHRhYmxlcyB0byBkaWFsb2cgbWVudXMuJztcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIEF2YXRhclBhZ2UoKSB7XHJcbiAgICBjb25zdCBbc2l6ZSwgc2V0U2l6ZV0gPSB1c2VTdGF0ZSgnbWVkaXVtJyk7XHJcbiAgICBjb25zdCBbY29udGVudCwgc2V0Q29udGVudF0gPSB1c2VTdGF0ZSgnaW1hZ2UnKTtcclxuXHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAgIDxQYWdlXHJcbiAgICAgICAgICAgIGlkPXtpZH1cclxuICAgICAgICAgICAgdGl0bGU9e3RpdGxlfVxyXG4gICAgICAgICAgICBkZXNjcmlwdGlvbj17ZGVzY3JpcHRpb259XHJcbiAgICAgICAgPlxyXG4gICAgICAgICAgICA8U2VjdGlvbiB0aXRsZT1cIkRlbW9cIj5cclxuICAgICAgICAgICAgICAgIDxMYXlvdXQgcm93PlxyXG4gICAgICAgICAgICAgICAgICAgIDxmaWVsZHNldD5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPGxlZ2VuZD5Db250ZW50PC9sZWdlbmQ+XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8U2VnbWVudGVkQnV0dG9uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWdtZW50cz17W1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgdmFsdWU6ICdpbWFnZScsIGxhYmVsOiAnSW1hZ2UnIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeyB2YWx1ZTogJ2ljb24nLCBsYWJlbDogJ0ljb24nIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeyB2YWx1ZTogJ3RleHQnLCBsYWJlbDogJ1RleHQnIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF19XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZT17Y29udGVudH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2hhbmdlPXtzZXRDb250ZW50fVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvPlxyXG4gICAgICAgICAgICAgICAgICAgIDwvZmllbGRzZXQ+XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIDxmaWVsZHNldD5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPGxlZ2VuZD5TaXplPC9sZWdlbmQ+XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8U2VnbWVudGVkQnV0dG9uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWdtZW50cz17W1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgdmFsdWU6ICdzbWFsbCcsIGxhYmVsOiAnU21hbGwnIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeyB2YWx1ZTogJ21lZGl1bScsIGxhYmVsOiAnTWVkaXVtJyB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgdmFsdWU6ICdsYXJnZScsIGxhYmVsOiAnTGFyZ2UnIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF19XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZT17c2l6ZX1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2hhbmdlPXtzZXRTaXplfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvPlxyXG4gICAgICAgICAgICAgICAgICAgIDwvZmllbGRzZXQ+XHJcbiAgICAgICAgICAgICAgICA8L0xheW91dD5cclxuXHJcbiAgICAgICAgICAgICAgICA8Q29kZT5cclxuICAgICAgICAgICAgICAgICAgICA8QXZhdGFyXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNyYz17Y29udGVudCA9PT0gJ2ltYWdlJyA/ICdodHRwczovL3BsYWNlaW1nLmNvbS8xMjgvMTI4L3Blb3BsZScgOiB1bmRlZmluZWR9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGljb249e2NvbnRlbnQgPT09ICdpY29uJyA/ICdzdGFyJyA6IHVuZGVmaW5lZH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dD17Y29udGVudCA9PT0gJ3RleHQnID8gJ01EJyA6IHVuZGVmaW5lZH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgc2l6ZT17c2l6ZX1cclxuICAgICAgICAgICAgICAgICAgICAvPlxyXG4gICAgICAgICAgICAgICAgPC9Db2RlPlxyXG4gICAgICAgICAgICA8L1NlY3Rpb24+XHJcbiAgICAgICAgPC9QYWdlPlxyXG4gICAgKTtcclxufSIsImltcG9ydCB7IEJhZGdlLCBCdXR0b24sIEljb24sIEljb25CdXR0b24gfSBmcm9tICdtZGMtcmVhY3QnO1xyXG5cclxuaW1wb3J0IFBhZ2UgZnJvbSAnQC9jb21wb25lbnRzL1BhZ2UnO1xyXG5pbXBvcnQgU2VjdGlvbiBmcm9tICdAL2NvbXBvbmVudHMvU2VjdGlvbic7XHJcbmltcG9ydCBDb2RlIGZyb20gJ0AvY29tcG9uZW50cy9Db2RlJztcclxuXHJcbmNvbnN0IGlkID0gJ2JhZGdlJztcclxuY29uc3QgdGl0bGUgPSAnQmFkZ2UnO1xyXG5jb25zdCBkZXNjcmlwdGlvbiA9ICdCYWRnZSBnZW5lcmF0ZXMgYSBzbWFsbCBiYWRnZSB0byB0aGUgdG9wLXJpZ2h0IG9mIGl0cyBjaGlsZChyZW4pLic7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBCYWRnZVBhZ2UoKSB7XHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAgIDxQYWdlIGlkPXtpZH0gdGl0bGU9e3RpdGxlfSBkZXNjcmlwdGlvbj17ZGVzY3JpcHRpb259PlxyXG4gICAgICAgICAgICA8U2VjdGlvbj5cclxuICAgICAgICAgICAgICAgIDxDb2RlIHRpdGxlPVwiQmFkZ2Ugd2l0aCB0ZXh0XCI+XHJcbiAgICAgICAgICAgICAgICAgICAgPEJhZGdlIHZhbHVlPVwiM1wiPlRleHQ8L0JhZGdlPlxyXG4gICAgICAgICAgICAgICAgPC9Db2RlPlxyXG4gICAgICAgICAgICA8L1NlY3Rpb24+XHJcblxyXG4gICAgICAgICAgICA8U2VjdGlvbj5cclxuICAgICAgICAgICAgICAgIDxDb2RlIHRpdGxlPVwiQmFkZ2Ugd2l0aCBhbiBpY29uXCI+XHJcbiAgICAgICAgICAgICAgICAgICAgPEJhZGdlIHZhbHVlPVwiM1wiPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8SWNvbj5zdGFyPC9JY29uPlxyXG4gICAgICAgICAgICAgICAgICAgIDwvQmFkZ2U+XHJcbiAgICAgICAgICAgICAgICA8L0NvZGU+XHJcbiAgICAgICAgICAgIDwvU2VjdGlvbj5cclxuXHJcbiAgICAgICAgICAgIDxTZWN0aW9uPlxyXG4gICAgICAgICAgICAgICAgPENvZGUgdGl0bGU9XCJCYWRnZSB3aXRoIGFuIGljb24gYnV0dG9uXCI+XHJcbiAgICAgICAgICAgICAgICAgICAgPEJhZGdlIHZhbHVlPVwiM1wiIGluc2V0PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8SWNvbkJ1dHRvbiBpY29uPVwic3RhclwiIC8+XHJcbiAgICAgICAgICAgICAgICAgICAgPC9CYWRnZT5cclxuICAgICAgICAgICAgICAgIDwvQ29kZT5cclxuICAgICAgICAgICAgPC9TZWN0aW9uPlxyXG5cclxuICAgICAgICAgICAgPFNlY3Rpb24+XHJcbiAgICAgICAgICAgICAgICA8Q29kZSB0aXRsZT1cIkJhZGdlIHdpdGggYSBidXR0b25cIj5cclxuICAgICAgICAgICAgICAgICAgICA8QmFkZ2UgdmFsdWU9XCIzXCI+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxCdXR0b24+QnV0dG9uPC9CdXR0b24+XHJcbiAgICAgICAgICAgICAgICAgICAgPC9CYWRnZT5cclxuICAgICAgICAgICAgICAgIDwvQ29kZT5cclxuICAgICAgICAgICAgPC9TZWN0aW9uPlxyXG4gICAgICAgIDwvUGFnZT5cclxuICAgICk7XHJcbn0iLCJpbXBvcnQgeyB1c2VTdGF0ZSB9IGZyb20gJ3JlYWN0JztcclxuaW1wb3J0IHtcclxuICAgIEJhbm5lcixcclxuICAgIEJ1dHRvbixcclxuICAgIFRvcEFwcEJhclxyXG59IGZyb20gJ21kYy1yZWFjdCc7XHJcblxyXG5pbXBvcnQgUGFnZSBmcm9tICdAL2NvbXBvbmVudHMvUGFnZSc7XHJcbmltcG9ydCBTZWN0aW9uIGZyb20gJ0AvY29tcG9uZW50cy9TZWN0aW9uJztcclxuaW1wb3J0IENvZGUgZnJvbSAnQC9jb21wb25lbnRzL0NvZGUnO1xyXG5cclxuaW1wb3J0ICcuL2luZGV4LnNjc3MnO1xyXG5cclxuY29uc3QgaWQgPSAnYmFubmVyJztcclxuY29uc3QgdGl0bGUgPSAnQmFubmVyJztcclxuY29uc3QgZGVzY3JpcHRpb24gPSAnQSBiYW5uZXIgZGlzcGxheXMgYSBwcm9taW5lbnQgbWVzc2FnZSBhbmQgcmVsYXRlZCBvcHRpb25hbCBhY3Rpb25zLic7XHJcbmNvbnN0IGxpbmtzID0ge1xyXG4gICAgZG9jczogJ2h0dHBzOi8vZ2l0aHViLmNvbS9tYXRlcmlhbC1jb21wb25lbnRzL21hdGVyaWFsLWNvbXBvbmVudHMtd2ViL3RyZWUvbWFzdGVyL3BhY2thZ2VzL21kYy1iYW5uZXInLFxyXG4gICAgZ3VpZGU6ICdodHRwczovL21hdGVyaWFsLmlvL2NvbXBvbmVudHMvYmFubmVycydcclxufTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIEJhZGdlUGFnZSgpIHtcclxuICAgIGNvbnN0IFtpc09wZW4xLCBzZXRPcGVuMV0gPSB1c2VTdGF0ZShmYWxzZSk7XHJcbiAgICBjb25zdCBbaXNPcGVuMiwgc2V0T3BlbjJdID0gdXNlU3RhdGUoZmFsc2UpO1xyXG4gICAgY29uc3QgW2lzT3BlbjMsIHNldE9wZW4zXSA9IHVzZVN0YXRlKGZhbHNlKTtcclxuICAgIGNvbnN0IFtpc09wZW40LCBzZXRPcGVuNF0gPSB1c2VTdGF0ZShmYWxzZSk7XHJcblxyXG4gICAgcmV0dXJuIChcclxuICAgICAgICA8UGFnZSBpZD17aWR9IHRpdGxlPXt0aXRsZX0gZGVzY3JpcHRpb249e2Rlc2NyaXB0aW9ufSBsaW5rcz17bGlua3N9PlxyXG4gICAgICAgICAgICA8U2VjdGlvbiB0aXRsZT1cIkJhbm5lciB3aXRoIHRleHRcIj5cclxuICAgICAgICAgICAgICAgIDxDb2RlXHJcbiAgICAgICAgICAgICAgICAgICAgc2V0dXA9e1xyXG4gICAgICAgICAgICAgICAgICAgICAgICA8VG9wQXBwQmFyXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aXRsZT1cIlRpdGxlXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFjdGlvbkl0ZW1zPXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8QnV0dG9uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsPVwiVG9nZ2xlXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb25DbGljaz17KCkgPT4gc2V0T3BlbjEodiA9PiAhdil9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLz5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgLz5cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICA+XHJcbiAgICAgICAgICAgICAgICAgICAgPEJhbm5lclxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0PVwiTG9yZW0gaXBzdW1cIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBvcGVuPXtpc09wZW4xfVxyXG4gICAgICAgICAgICAgICAgICAgIC8+XHJcbiAgICAgICAgICAgICAgICA8L0NvZGU+XHJcbiAgICAgICAgICAgIDwvU2VjdGlvbj5cclxuXHJcbiAgICAgICAgICAgIDxTZWN0aW9uIHRpdGxlPVwiQmFubmVyIHdpdGggaWNvbiBhbmQgdGV4dFwiPlxyXG4gICAgICAgICAgICAgICAgPENvZGVcclxuICAgICAgICAgICAgICAgICAgICBzZXR1cD17XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxUb3BBcHBCYXJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlPVwiVGl0bGVcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWN0aW9uSXRlbXM9e1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxCdXR0b25cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWw9XCJUb2dnbGVcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbkNsaWNrPXsoKSA9PiBzZXRPcGVuMih2ID0+ICF2KX1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvPlxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgID5cclxuICAgICAgICAgICAgICAgICAgICA8QmFubmVyXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGljb249XCJ3YXJuaW5nXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dD1cIkxvcmVtIGlwc3VtXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgb3Blbj17aXNPcGVuMn1cclxuICAgICAgICAgICAgICAgICAgICAvPlxyXG4gICAgICAgICAgICAgICAgPC9Db2RlPlxyXG4gICAgICAgICAgICA8L1NlY3Rpb24+XHJcblxyXG4gICAgICAgICAgICA8U2VjdGlvbiB0aXRsZT1cIkJhbm5lciB3aXRoIGljb24sIHRleHQgYW5kIGFjdGlvbnNcIj5cclxuICAgICAgICAgICAgICAgIDxDb2RlXHJcbiAgICAgICAgICAgICAgICAgICAgc2V0dXA9e1xyXG4gICAgICAgICAgICAgICAgICAgICAgICA8VG9wQXBwQmFyXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aXRsZT1cIlRpdGxlXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFjdGlvbkl0ZW1zPXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8QnV0dG9uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsPVwiVG9nZ2xlXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb25DbGljaz17KCkgPT4gc2V0T3BlbjModiA9PiAhdil9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLz5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgLz5cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICA+XHJcbiAgICAgICAgICAgICAgICAgICAgPEJhbm5lclxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpY29uPVwid2FybmluZ1wiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ9XCJMb3JlbSBpcHN1bVwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjdGlvbj17PEJ1dHRvbj5PSzwvQnV0dG9uPn1cclxuICAgICAgICAgICAgICAgICAgICAgICAgb3Blbj17aXNPcGVuM31cclxuICAgICAgICAgICAgICAgICAgICAvPlxyXG4gICAgICAgICAgICAgICAgPC9Db2RlPlxyXG4gICAgICAgICAgICA8L1NlY3Rpb24+XHJcblxyXG4gICAgICAgICAgICA8U2VjdGlvbiB0aXRsZT1cIkJhbm5lciB3aXRoIGljb24sIHRleHQgYW5kIGFjdGlvbnNcIj5cclxuICAgICAgICAgICAgICAgIDxDb2RlXHJcbiAgICAgICAgICAgICAgICAgICAgc2V0dXA9e1xyXG4gICAgICAgICAgICAgICAgICAgICAgICA8VG9wQXBwQmFyXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aXRsZT1cIlRpdGxlXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFjdGlvbkl0ZW1zPXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8QnV0dG9uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsPVwiVG9nZ2xlXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb25DbGljaz17KCkgPT4gc2V0T3BlbjQodiA9PiAhdil9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLz5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgLz5cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICA+XHJcbiAgICAgICAgICAgICAgICAgICAgPEJhbm5lclxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpY29uPVwid2FybmluZ1wiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ9XCJMb3JlbSBpcHN1bVwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHByaW1hcnlBY3Rpb249ezxCdXR0b24+T0s8L0J1dHRvbj59XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlY29uZGFyeUFjdGlvbj17PEJ1dHRvbj5DbG9zZTwvQnV0dG9uPn1cclxuICAgICAgICAgICAgICAgICAgICAgICAgb3Blbj17aXNPcGVuNH1cclxuICAgICAgICAgICAgICAgICAgICAvPlxyXG4gICAgICAgICAgICAgICAgPC9Db2RlPlxyXG4gICAgICAgICAgICA8L1NlY3Rpb24+XHJcbiAgICAgICAgPC9QYWdlPlxyXG4gICAgKTtcclxufSIsImltcG9ydCB7IHVzZVN0YXRlIH0gZnJvbSAncmVhY3QnO1xyXG5pbXBvcnQge1xyXG4gICAgQnV0dG9uLFxyXG4gICAgTGF5b3V0LFxyXG4gICAgU2VnbWVudGVkQnV0dG9uXHJcbn0gZnJvbSAnbWRjLXJlYWN0JztcclxuXHJcbmltcG9ydCBQYWdlIGZyb20gJ0AvY29tcG9uZW50cy9QYWdlJztcclxuaW1wb3J0IFNlY3Rpb24gZnJvbSAnQC9jb21wb25lbnRzL1NlY3Rpb24nO1xyXG5pbXBvcnQgQ29kZSBmcm9tICdAL2NvbXBvbmVudHMvQ29kZSc7XHJcblxyXG5jb25zdCBpZCA9ICdidXR0b24nO1xyXG5jb25zdCB0aXRsZSA9ICdCdXR0b24nO1xyXG5jb25zdCBkZXNjcmlwdGlvbiA9ICdCdXR0b25zIGNvbW11bmljYXRlIGFuIGFjdGlvbiBhIHVzZXIgY2FuIHRha2UuIFRoZXkgYXJlIHR5cGljYWxseSBwbGFjZWQgdGhyb3VnaG91dCB5b3VyIFVJLCBpbiBwbGFjZXMgbGlrZSBkaWFsb2dzLCBmb3JtcywgY2FyZHMsIGFuZCB0b29sYmFycy4nO1xyXG5jb25zdCBsaW5rcyA9IHtcclxuICAgIGRvY3M6ICdodHRwczovL2dpdGh1Yi5jb20vbWF0ZXJpYWwtY29tcG9uZW50cy9tYXRlcmlhbC1jb21wb25lbnRzLXdlYi90cmVlL21hc3Rlci9wYWNrYWdlcy9tZGMtYnV0dG9uJyxcclxuICAgIGd1aWRlOiAnaHR0cHM6Ly9tYXRlcmlhbC5pby9jb21wb25lbnRzL2J1dHRvbnMnXHJcbn07XHJcblxyXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBCdXR0b25QYWdlKCkge1xyXG4gICAgY29uc3QgW3R5cGUsIHNldFR5cGVdID0gdXNlU3RhdGUoJ3BsYWluJyk7XHJcbiAgICBjb25zdCBbbGVhZGluZ0ljb24sIHNldExlYWRpbmdJY29uXSA9IHVzZVN0YXRlKGZhbHNlKTtcclxuICAgIGNvbnN0IFt0cmFpbGluZ0ljb24sIHNldFRyYWlsaW5nSWNvbl0gPSB1c2VTdGF0ZShmYWxzZSk7XHJcblxyXG4gICAgY29uc3Qgb3V0bGluZWQgPSB0eXBlID09PSAnb3V0bGluZWQnIHx8IHVuZGVmaW5lZDtcclxuICAgIGNvbnN0IHVuZWxldmF0ZWQgPSB0eXBlID09PSAndW5lbGV2YXRlZCcgfHwgdW5kZWZpbmVkO1xyXG4gICAgY29uc3QgcmFpc2VkID0gdHlwZSA9PT0gJ3JhaXNlZCcgfHwgdW5kZWZpbmVkO1xyXG5cclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgPFBhZ2UgaWQ9e2lkfSB0aXRsZT17dGl0bGV9IGRlc2NyaXB0aW9uPXtkZXNjcmlwdGlvbn0gbGlua3M9e2xpbmtzfT5cclxuICAgICAgICAgICAgPFNlY3Rpb24gdGl0bGU9XCJEZW1vXCI+XHJcbiAgICAgICAgICAgICAgICA8TGF5b3V0IHJvdz5cclxuICAgICAgICAgICAgICAgICAgICA8ZmllbGRzZXQ+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxsZWdlbmQ+VHlwZTwvbGVnZW5kPlxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPFNlZ21lbnRlZEJ1dHRvblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VnbWVudHM9e1tcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7IHZhbHVlOiAncGxhaW4nLCBsYWJlbDogJ1BsYWluJyB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgdmFsdWU6ICdvdXRsaW5lZCcsIGxhYmVsOiAnT3V0bGluZWQnIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeyB2YWx1ZTogJ3VuZWxldmF0ZWQnLCBsYWJlbDogJ1VuZWxldmF0ZWQnIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeyB2YWx1ZTogJ3JhaXNlZCcsIGxhYmVsOiAnUmFpc2VkJyB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBdfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU9e3R5cGV9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbkNoYW5nZT17c2V0VHlwZX1cclxuICAgICAgICAgICAgICAgICAgICAgICAgLz5cclxuICAgICAgICAgICAgICAgICAgICA8L2ZpZWxkc2V0PlxyXG5cclxuICAgICAgICAgICAgICAgICAgICA8ZmllbGRzZXQ+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxsZWdlbmQ+SWNvbnM8L2xlZ2VuZD5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxTZWdtZW50ZWRCdXR0b24+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8U2VnbWVudGVkQnV0dG9uLlNlZ21lbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYWJlbD1cIkxlYWRpbmcgSWNvblwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0ZWQ9e2xlYWRpbmdJY29ufVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2xpY2s9eygpID0+IHNldExlYWRpbmdJY29uKHYgPT4gIXYpfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLz5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8U2VnbWVudGVkQnV0dG9uLlNlZ21lbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYWJlbD1cIlRyYWlsaW5nIEljb25cIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdGVkPXt0cmFpbGluZ0ljb259XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb25DbGljaz17KCkgPT4gc2V0VHJhaWxpbmdJY29uKHYgPT4gIXYpfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLz5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPC9TZWdtZW50ZWRCdXR0b24+XHJcbiAgICAgICAgICAgICAgICAgICAgPC9maWVsZHNldD5cclxuICAgICAgICAgICAgICAgIDwvTGF5b3V0PlxyXG5cclxuICAgICAgICAgICAgICAgIDxDb2RlPlxyXG4gICAgICAgICAgICAgICAgICAgIDxCdXR0b25cclxuICAgICAgICAgICAgICAgICAgICAgICAgbGVhZGluZ0ljb249e2xlYWRpbmdJY29uID8gJ3NhdmUnIDogdW5kZWZpbmVkfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0cmFpbGluZ0ljb249e3RyYWlsaW5nSWNvbiA/ICdjbG9zZScgOiB1bmRlZmluZWR9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dGxpbmVkPXtvdXRsaW5lZH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgdW5lbGV2YXRlZD17dW5lbGV2YXRlZH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgcmFpc2VkPXtyYWlzZWR9XHJcbiAgICAgICAgICAgICAgICAgICAgPkJ1dHRvbjwvQnV0dG9uPlxyXG4gICAgICAgICAgICAgICAgPC9Db2RlPlxyXG4gICAgICAgICAgICA8L1NlY3Rpb24+XHJcbiAgICAgICAgPC9QYWdlPlxyXG4gICAgKTtcclxufSIsImltcG9ydCB7IENhcmQgfSBmcm9tICdtZGMtcmVhY3QnO1xyXG5cclxuaW1wb3J0IFBhZ2UgZnJvbSAnQC9jb21wb25lbnRzL1BhZ2UnO1xyXG5pbXBvcnQgU2VjdGlvbiBmcm9tICdAL2NvbXBvbmVudHMvU2VjdGlvbic7XHJcbmltcG9ydCBDb2RlIGZyb20gJ0AvY29tcG9uZW50cy9Db2RlJztcclxuXHJcbmNvbnN0IGlkID0gJ2NhcmQnO1xyXG5jb25zdCB0aXRsZSA9ICdDYXJkJztcclxuY29uc3QgZGVzY3JpcHRpb24gPSAnQ2FyZHMgY29udGFpbiBjb250ZW50IGFuZCBhY3Rpb25zIGFib3V0IGEgc2luZ2xlIHN1YmplY3QuJztcclxuY29uc3QgbGlua3MgPSB7XHJcbiAgICBkb2NzOiAnaHR0cHM6Ly9naXRodWIuY29tL21hdGVyaWFsLWNvbXBvbmVudHMvbWF0ZXJpYWwtY29tcG9uZW50cy13ZWIvdHJlZS9tYXN0ZXIvcGFja2FnZXMvbWRjLWNhcmQnLFxyXG4gICAgZ3VpZGU6ICdodHRwczovL21hdGVyaWFsLmlvL2NvbXBvbmVudHMvY2FyZHMnXHJcbn07ICcnO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gQ2FyZFBhZ2UoKSB7XHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAgIDxQYWdlIGlkPXtpZH0gdGl0bGU9e3RpdGxlfSBkZXNjcmlwdGlvbj17ZGVzY3JpcHRpb259IGxpbmtzPXtsaW5rc30+XHJcbiAgICAgICAgICAgIDxTZWN0aW9uIHRpdGxlPVwiQmFzaWNcIj5cclxuICAgICAgICAgICAgICAgIDxDb2RlPlxyXG4gICAgICAgICAgICAgICAgICAgIDxDYXJkPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8Q2FyZC5IZWFkZXJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG92ZXJsaW5lPVwiT3ZlcmxpbmVcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGU9XCJUaXRsZVwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWJ0aXRsZT1cIlN1YnRpdGxlXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgLz5cclxuICAgICAgICAgICAgICAgICAgICA8L0NhcmQ+XHJcbiAgICAgICAgICAgICAgICA8L0NvZGU+XHJcbiAgICAgICAgICAgIDwvU2VjdGlvbj5cclxuXHJcbiAgICAgICAgICAgIDxTZWN0aW9uIHRpdGxlPVwiUHJpbWFyeSBhY3Rpb25cIj5cclxuICAgICAgICAgICAgICAgIDxDb2RlPlxyXG4gICAgICAgICAgICAgICAgICAgIDxDYXJkPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8Q2FyZC5QcmltYXJ5QWN0aW9uPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPENhcmQuSGVhZGVyXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3ZlcmxpbmU9XCJPdmVybGluZVwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGU9XCJUaXRsZVwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3VidGl0bGU9XCJTdWJ0aXRsZVwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8L0NhcmQuUHJpbWFyeUFjdGlvbj5cclxuICAgICAgICAgICAgICAgICAgICA8L0NhcmQ+XHJcbiAgICAgICAgICAgICAgICA8L0NvZGU+XHJcbiAgICAgICAgICAgIDwvU2VjdGlvbj5cclxuICAgICAgICA8L1BhZ2U+XHJcbiAgICApO1xyXG59IiwiaW1wb3J0IHsgdXNlU3RhdGUgfSBmcm9tICdyZWFjdCc7XHJcbmltcG9ydCB7IENoZWNrYm94IH0gZnJvbSAnbWRjLXJlYWN0JztcclxuXHJcbmltcG9ydCBQYWdlIGZyb20gJ0AvY29tcG9uZW50cy9QYWdlJztcclxuaW1wb3J0IFNlY3Rpb24gZnJvbSAnQC9jb21wb25lbnRzL1NlY3Rpb24nO1xyXG5pbXBvcnQgQ29kZSBmcm9tICdAL2NvbXBvbmVudHMvQ29kZSc7XHJcblxyXG5jb25zdCBpZCA9ICdjaGVja2JveCc7XHJcbmNvbnN0IHRpdGxlID0gJ0NoZWNrYm94JztcclxuY29uc3QgZGVzY3JpcHRpb24gPSAnQ2hlY2tib3hlcyBhbGxvdyB0aGUgdXNlciB0byBzZWxlY3QgbXVsdGlwbGUgb3B0aW9ucyBmcm9tIGEgc2V0Lic7XHJcbmNvbnN0IGxpbmtzID0ge1xyXG4gICAgZG9jczogJ2h0dHBzOi8vZ2l0aHViLmNvbS9tYXRlcmlhbC1jb21wb25lbnRzL21hdGVyaWFsLWNvbXBvbmVudHMtd2ViL3RyZWUvbWFzdGVyL3BhY2thZ2VzL21kYy1jaGVja2JveCcsXHJcbiAgICBndWlkZTogJ2h0dHBzOi8vbWF0ZXJpYWwuaW8vY29tcG9uZW50cy9jaGVja2JveGVzJ1xyXG59O1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gQ2hlY2tib3hQYWdlKCkge1xyXG4gICAgY29uc3QgW2lzQ2hlY2tlZCwgc2V0Q2hlY2tlZF0gPSB1c2VTdGF0ZShmYWxzZSk7XHJcblxyXG4gICAgcmV0dXJuIChcclxuICAgICAgICA8UGFnZSBpZD17aWR9IHRpdGxlPXt0aXRsZX0gZGVzY3JpcHRpb249e2Rlc2NyaXB0aW9ufSBsaW5rcz17bGlua3N9PlxyXG4gICAgICAgICAgICA8U2VjdGlvbiB0aXRsZT1cIkNvbnRyb2xsZWRcIj5cclxuICAgICAgICAgICAgICAgIDxDb2RlPlxyXG4gICAgICAgICAgICAgICAgICAgIDxDaGVja2JveFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjaGVja2VkPXtpc0NoZWNrZWR9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2hhbmdlPXsoKSA9PiBzZXRDaGVja2VkKHYgPT4gIXYpfVxyXG4gICAgICAgICAgICAgICAgICAgIC8+XHJcbiAgICAgICAgICAgICAgICA8L0NvZGU+XHJcbiAgICAgICAgICAgIDwvU2VjdGlvbj5cclxuXHJcbiAgICAgICAgICAgIDxTZWN0aW9uIHRpdGxlPVwiVW5jb250cm9sbGVkXCI+XHJcbiAgICAgICAgICAgICAgICA8Q29kZT5cclxuICAgICAgICAgICAgICAgICAgICA8Q2hlY2tib3hcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdENoZWNrZWQ9e2ZhbHNlfVxyXG4gICAgICAgICAgICAgICAgICAgIC8+XHJcbiAgICAgICAgICAgICAgICA8L0NvZGU+XHJcbiAgICAgICAgICAgIDwvU2VjdGlvbj5cclxuXHJcbiAgICAgICAgICAgIDxTZWN0aW9uIHRpdGxlPVwiSW5kZXRlcm1pbmF0ZVwiPlxyXG4gICAgICAgICAgICAgICAgPENvZGU+XHJcbiAgICAgICAgICAgICAgICAgICAgPENoZWNrYm94XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZGV0ZXJtaW5hdGVcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdENoZWNrZWQ9e2ZhbHNlfVxyXG4gICAgICAgICAgICAgICAgICAgIC8+XHJcbiAgICAgICAgICAgICAgICA8L0NvZGU+XHJcbiAgICAgICAgICAgIDwvU2VjdGlvbj5cclxuXHJcbiAgICAgICAgICAgIDxTZWN0aW9uIHRpdGxlPVwiRGlzYWJsZWRcIj5cclxuICAgICAgICAgICAgICAgIDxDb2RlPlxyXG4gICAgICAgICAgICAgICAgICAgIDxDaGVja2JveCBkaXNhYmxlZCAvPlxyXG4gICAgICAgICAgICAgICAgPC9Db2RlPlxyXG4gICAgICAgICAgICA8L1NlY3Rpb24+XHJcbiAgICAgICAgPC9QYWdlPlxyXG4gICAgKTtcclxufSIsImltcG9ydCB7IHVzZVN0YXRlIH0gZnJvbSAncmVhY3QnO1xyXG5pbXBvcnQge1xyXG4gICAgQXZhdGFyLFxyXG4gICAgQ2hpcFNldCwgQ2hpcFxyXG59IGZyb20gJ21kYy1yZWFjdCc7XHJcblxyXG5pbXBvcnQgUGFnZSBmcm9tICdAL2NvbXBvbmVudHMvUGFnZSc7XHJcbmltcG9ydCBTZWN0aW9uIGZyb20gJ0AvY29tcG9uZW50cy9TZWN0aW9uJztcclxuaW1wb3J0IENvZGUgZnJvbSAnQC9jb21wb25lbnRzL0NvZGUnO1xyXG5cclxuY29uc3QgaWQgPSAnY2hpcHMnO1xyXG5jb25zdCB0aXRsZSA9ICdDaGlwcyc7XHJcbmNvbnN0IGRlc2NyaXB0aW9uID0gJ0NoaXBzIGFyZSBjb21wYWN0IGVsZW1lbnRzIHRoYXQgYWxsb3cgdXNlcnMgdG8gZW50ZXIgaW5mb3JtYXRpb24sIHNlbGVjdCBhIGNob2ljZSwgZmlsdGVyIGNvbnRlbnQsIG9yIHRyaWdnZXIgYW4gYWN0aW9uLic7XHJcbmNvbnN0IGxpbmtzID0ge1xyXG4gICAgZG9jczogJ2h0dHBzOi8vZ2l0aHViLmNvbS9tYXRlcmlhbC1jb21wb25lbnRzL21hdGVyaWFsLWNvbXBvbmVudHMtd2ViL3RyZWUvbWFzdGVyL3BhY2thZ2VzL21kYy1jaGlwcycsXHJcbiAgICBndWlkZTogJ2h0dHBzOi8vbWF0ZXJpYWwuaW8vY29tcG9uZW50cy9jaGlwcydcclxufTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIENoaXBzUGFnZSgpIHtcclxuICAgIGNvbnN0IFtjaG9pY2VDaGlwLCBzZXRDaG9pY2VDaGlwc10gPSB1c2VTdGF0ZSgnZm9vJyk7XHJcbiAgICBjb25zdCBbZmlsdGVyQ2hpcHMsIHNldEZpbHRlckNoaXBzXSA9IHVzZVN0YXRlKFsnZm9vJ10pO1xyXG5cclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgPFBhZ2UgaWQ9e2lkfSB0aXRsZT17dGl0bGV9IGRlc2NyaXB0aW9uPXtkZXNjcmlwdGlvbn0gbGlua3M9e2xpbmtzfT5cclxuICAgICAgICAgICAgPFNlY3Rpb24gdGl0bGU9XCJCYXNpYyBjaGlwc1wiPlxyXG4gICAgICAgICAgICAgICAgPENvZGU+XHJcbiAgICAgICAgICAgICAgICAgICAgPENoaXBTZXQ+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxDaGlwIHRleHQ9XCJGb29cIiAvPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8Q2hpcCB0ZXh0PVwiQmFyXCIgLz5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPENoaXAgdGV4dD1cIkJhelwiIC8+XHJcbiAgICAgICAgICAgICAgICAgICAgPC9DaGlwU2V0PlxyXG4gICAgICAgICAgICAgICAgPC9Db2RlPlxyXG4gICAgICAgICAgICA8L1NlY3Rpb24+XHJcblxyXG4gICAgICAgICAgICA8U2VjdGlvbiB0aXRsZT1cIkNoaXBzIHdpdGggaWNvbnNcIj5cclxuICAgICAgICAgICAgICAgIDxDb2RlPlxyXG4gICAgICAgICAgICAgICAgICAgIDxDaGlwU2V0PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8Q2hpcCB0ZXh0PVwiRm9vXCIgaWNvbj1cInN0YXJcIiAvPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8Q2hpcCB0ZXh0PVwiQmFyXCIgaWNvbj1cInN0YXJcIiAvPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8Q2hpcCB0ZXh0PVwiQmF6XCIgaWNvbj1cInN0YXJcIiAvPlxyXG4gICAgICAgICAgICAgICAgICAgIDwvQ2hpcFNldD5cclxuICAgICAgICAgICAgICAgIDwvQ29kZT5cclxuICAgICAgICAgICAgPC9TZWN0aW9uPlxyXG5cclxuICAgICAgICAgICAgPFNlY3Rpb24gdGl0bGU9XCJDaGlwcyB3aXRoIHRyYWlsaW5nIGljb25zXCI+XHJcbiAgICAgICAgICAgICAgICA8Q29kZT5cclxuICAgICAgICAgICAgICAgICAgICA8Q2hpcFNldD5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPENoaXAgdGV4dD1cIkZvb1wiIHRyYWlsaW5nSWNvbj1cImRlbGV0ZVwiIC8+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxDaGlwIHRleHQ9XCJCYXJcIiB0cmFpbGluZ0ljb249XCJkZWxldGVcIiAvPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8Q2hpcCB0ZXh0PVwiQmF6XCIgdHJhaWxpbmdJY29uPVwiZGVsZXRlXCIgLz5cclxuICAgICAgICAgICAgICAgICAgICA8L0NoaXBTZXQ+XHJcbiAgICAgICAgICAgICAgICA8L0NvZGU+XHJcbiAgICAgICAgICAgIDwvU2VjdGlvbj5cclxuXHJcbiAgICAgICAgICAgIDxTZWN0aW9uIHRpdGxlPVwiQ2hpcHMgd2l0aCBhdmF0YXJzXCI+XHJcbiAgICAgICAgICAgICAgICA8Q29kZT5cclxuICAgICAgICAgICAgICAgICAgICA8Q2hpcFNldD5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPENoaXAgdGV4dD1cIkZvb1wiIGdyYXBoaWM9ezxBdmF0YXIgc3JjPVwiaHR0cHM6Ly9wbGFjZWltZy5jb20vMTI4LzEyOC9wZW9wbGVcIiBzbWFsbCAvPn0gd2l0aEF2YXRhciAvPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8Q2hpcCB0ZXh0PVwiQmFyXCIgZ3JhcGhpYz17PEF2YXRhciBzcmM9XCJodHRwczovL3BsYWNlaW1nLmNvbS8xMjgvMTI4L3Blb3BsZVwiIHNtYWxsIC8+fSB3aXRoQXZhdGFyIC8+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxDaGlwIHRleHQ9XCJCYXpcIiBncmFwaGljPXs8QXZhdGFyIHNyYz1cImh0dHBzOi8vcGxhY2VpbWcuY29tLzEyOC8xMjgvcGVvcGxlXCIgc21hbGwgLz59IHdpdGhBdmF0YXIgLz5cclxuICAgICAgICAgICAgICAgICAgICA8L0NoaXBTZXQ+XHJcbiAgICAgICAgICAgICAgICA8L0NvZGU+XHJcbiAgICAgICAgICAgIDwvU2VjdGlvbj5cclxuXHJcbiAgICAgICAgICAgIDxTZWN0aW9uIHRpdGxlPVwiQ2hvaWNlIGNoaXBzXCI+XHJcbiAgICAgICAgICAgICAgICA8Q29kZT5cclxuICAgICAgICAgICAgICAgICAgICA8Q2hpcFNldCB2YWx1ZT17Y2hvaWNlQ2hpcH0gb25DaGFuZ2U9e3ZhbHVlID0+IHNldENob2ljZUNoaXBzKHZhbHVlKX0+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxDaGlwIHZhbHVlPVwiZm9vXCIgdGV4dD1cIkZvb1wiIC8+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxDaGlwIHZhbHVlPVwiYmFyXCIgdGV4dD1cIkJhclwiIC8+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxDaGlwIHZhbHVlPVwiYmF6XCIgdGV4dD1cIkJhelwiIC8+XHJcbiAgICAgICAgICAgICAgICAgICAgPC9DaGlwU2V0PlxyXG4gICAgICAgICAgICAgICAgPC9Db2RlPlxyXG4gICAgICAgICAgICA8L1NlY3Rpb24+XHJcblxyXG4gICAgICAgICAgICA8U2VjdGlvbiB0aXRsZT1cIkZpbHRlciBjaGlwc1wiPlxyXG4gICAgICAgICAgICAgICAgPENvZGU+XHJcbiAgICAgICAgICAgICAgICAgICAgPENoaXBTZXQgdmFsdWU9e2ZpbHRlckNoaXBzfSBvbkNoYW5nZT17dmFsdWUgPT4gc2V0RmlsdGVyQ2hpcHModmFsdWUpfT5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPENoaXAgdmFsdWU9XCJmb29cIiB0ZXh0PVwiRm9vXCIgLz5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPENoaXAgdmFsdWU9XCJiYXJcIiB0ZXh0PVwiQmFyXCIgLz5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPENoaXAgdmFsdWU9XCJiYXpcIiB0ZXh0PVwiQmF6XCIgLz5cclxuICAgICAgICAgICAgICAgICAgICA8L0NoaXBTZXQ+XHJcbiAgICAgICAgICAgICAgICA8L0NvZGU+XHJcbiAgICAgICAgICAgIDwvU2VjdGlvbj5cclxuICAgICAgICA8L1BhZ2U+XHJcbiAgICApO1xyXG59IiwiaW1wb3J0IHsgdXNlU3RhdGUgfSBmcm9tICdyZWFjdCc7XHJcbmltcG9ydCB7IEJ1dHRvbiwgQ2lyY3VsYXJQcm9ncmVzcyB9IGZyb20gJ21kYy1yZWFjdCc7XHJcblxyXG5pbXBvcnQgUGFnZSBmcm9tICdAL2NvbXBvbmVudHMvUGFnZSc7XHJcbmltcG9ydCBTZWN0aW9uIGZyb20gJ0AvY29tcG9uZW50cy9TZWN0aW9uJztcclxuaW1wb3J0IENvZGUgZnJvbSAnQC9jb21wb25lbnRzL0NvZGUnO1xyXG5cclxuY29uc3QgaWQgPSAnY2lyY3VsYXItcHJvZ3Jlc3MnO1xyXG5jb25zdCB0aXRsZSA9ICdDaXJjdWxhciBQcm9ncmVzcyc7XHJcbmNvbnN0IGRlc2NyaXB0aW9uID0gJ0NpcmN1bGFyIHByb2dyZXNzIGluZGljYXRvcnMgZGlzcGxheSBwcm9ncmVzcyBieSBhbmltYXRpbmcgYW4gaW5kaWNhdG9yIGFsb25nIGFuIGludmlzaWJsZSBjaXJjdWxhciB0cmFjayBpbiBhIGNsb2Nrd2lzZSBkaXJlY3Rpb24uJztcclxuY29uc3QgbGlua3MgPSB7XHJcbiAgICBkb2NzOiAnaHR0cHM6Ly9naXRodWIuY29tL21hdGVyaWFsLWNvbXBvbmVudHMvbWF0ZXJpYWwtY29tcG9uZW50cy13ZWIvdHJlZS9tYXN0ZXIvcGFja2FnZXMvbWRjLWNpcmN1bGFyLXByb2dyZXNzJyxcclxuICAgIGd1aWRlOiAnaHR0cHM6Ly9tYXRlcmlhbC5pby9jb21wb25lbnRzL3Byb2dyZXNzLWluZGljYXRvcnMjY2lyY3VsYXItcHJvZ3Jlc3MtaW5kaWNhdG9ycydcclxufTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIENpcmN1bGFyUHJvZ3Jlc3NQYWdlKCkge1xyXG4gICAgY29uc3QgW2lzQ2xvc2VkLCBzZXRDbG9zZWRdID0gdXNlU3RhdGUoZmFsc2UpO1xyXG5cclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgPFBhZ2UgaWQ9e2lkfSB0aXRsZT17dGl0bGV9IGRlc2NyaXB0aW9uPXtkZXNjcmlwdGlvbn0gbGlua3M9e2xpbmtzfT5cclxuICAgICAgICAgICAgPFNlY3Rpb24+XHJcbiAgICAgICAgICAgICAgICA8Q29kZT5cclxuICAgICAgICAgICAgICAgICAgICA8Q2lyY3VsYXJQcm9ncmVzc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZT1cIjQyXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2l6ZT1cInNtYWxsXCJcclxuICAgICAgICAgICAgICAgICAgICAvPlxyXG5cclxuICAgICAgICAgICAgICAgICAgICA8Q2lyY3VsYXJQcm9ncmVzc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZT1cIjQyXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2l6ZT1cIm1lZGl1bVwiXHJcbiAgICAgICAgICAgICAgICAgICAgLz5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgPENpcmN1bGFyUHJvZ3Jlc3NcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU9XCI0MlwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNpemU9XCJsYXJnZVwiXHJcbiAgICAgICAgICAgICAgICAgICAgLz5cclxuICAgICAgICAgICAgICAgIDwvQ29kZT5cclxuICAgICAgICAgICAgPC9TZWN0aW9uPlxyXG5cclxuICAgICAgICAgICAgPFNlY3Rpb24+XHJcbiAgICAgICAgICAgICAgICA8Q29kZT5cclxuICAgICAgICAgICAgICAgICAgICA8Q2lyY3VsYXJQcm9ncmVzc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmRldGVybWluYXRlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNpemU9XCJzbWFsbFwiXHJcbiAgICAgICAgICAgICAgICAgICAgLz5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgPENpcmN1bGFyUHJvZ3Jlc3NcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXRlcm1pbmF0ZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzaXplPVwibWVkaXVtXCJcclxuICAgICAgICAgICAgICAgICAgICAvPlxyXG5cclxuICAgICAgICAgICAgICAgICAgICA8Q2lyY3VsYXJQcm9ncmVzc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmRldGVybWluYXRlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNpemU9XCJsYXJnZVwiXHJcbiAgICAgICAgICAgICAgICAgICAgLz5cclxuICAgICAgICAgICAgICAgIDwvQ29kZT5cclxuICAgICAgICAgICAgPC9TZWN0aW9uPlxyXG5cclxuICAgICAgICAgICAgPFNlY3Rpb24+XHJcbiAgICAgICAgICAgICAgICA8Q29kZT5cclxuICAgICAgICAgICAgICAgICAgICA8Q2lyY3VsYXJQcm9ncmVzc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzaXplPVwic21hbGxcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmRldGVybWluYXRlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yZnVsXHJcbiAgICAgICAgICAgICAgICAgICAgLz5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgPENpcmN1bGFyUHJvZ3Jlc3NcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2l6ZT1cIm1lZGl1bVwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZGV0ZXJtaW5hdGVcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29sb3JmdWxcclxuICAgICAgICAgICAgICAgICAgICAvPlxyXG5cclxuICAgICAgICAgICAgICAgICAgICA8Q2lyY3VsYXJQcm9ncmVzc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzaXplPVwibGFyZ2VcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmRldGVybWluYXRlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yZnVsXHJcbiAgICAgICAgICAgICAgICAgICAgLz5cclxuICAgICAgICAgICAgICAgIDwvQ29kZT5cclxuICAgICAgICAgICAgPC9TZWN0aW9uPlxyXG5cclxuICAgICAgICAgICAgPFNlY3Rpb24gdGl0bGU9XCJDbG9zZWQgY2lyY3VsYXIgcHJvZ3Jlc3NcIj5cclxuICAgICAgICAgICAgICAgIDxDb2RlXHJcbiAgICAgICAgICAgICAgICAgICAgc2V0dXA9e1xyXG4gICAgICAgICAgICAgICAgICAgICAgICA8QnV0dG9uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYWJlbD1cIlRvZ2dsZVwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRsaW5lZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb25DbGljaz17KCkgPT4gc2V0Q2xvc2VkKHYgPT4gIXYpfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvPlxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgID5cclxuICAgICAgICAgICAgICAgICAgICA8Q2lyY3VsYXJQcm9ncmVzc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzaXplPVwibWVkaXVtXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXRlcm1pbmF0ZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjbG9zZWQ9e2lzQ2xvc2VkfVxyXG4gICAgICAgICAgICAgICAgICAgIC8+XHJcbiAgICAgICAgICAgICAgICA8L0NvZGU+XHJcbiAgICAgICAgICAgIDwvU2VjdGlvbj5cclxuICAgICAgICA8L1BhZ2U+XHJcbiAgICApO1xyXG59IiwiaW1wb3J0IHsgdXNlQ2FsbGJhY2ssIHVzZVN0YXRlIH0gZnJvbSAncmVhY3QnO1xyXG5pbXBvcnQgeyBEYXRhVGFibGUgfSBmcm9tICdtZGMtcmVhY3QnO1xyXG5cclxuaW1wb3J0IFBhZ2UgZnJvbSAnQC9jb21wb25lbnRzL1BhZ2UnO1xyXG5pbXBvcnQgU2VjdGlvbiBmcm9tICdAL2NvbXBvbmVudHMvU2VjdGlvbic7XHJcbmltcG9ydCBDb2RlIGZyb20gJ0AvY29tcG9uZW50cy9Db2RlJztcclxuXHJcbmNvbnN0IGlkID0gJ2RhdGEtdGFibGUnO1xyXG5jb25zdCB0aXRsZSA9ICdEYXRhIFRhYmxlJztcclxuY29uc3QgZGVzY3JpcHRpb24gPSAnRGF0YSB0YWJsZXMgZGlzcGxheSBzZXRzIG9mIGRhdGEgYWNyb3NzIHJvd3MgYW5kIGNvbHVtbnMuJztcclxuY29uc3QgbGlua3MgPSB7XHJcbiAgICBkb2NzOiAnaHR0cHM6Ly9naXRodWIuY29tL21hdGVyaWFsLWNvbXBvbmVudHMvbWF0ZXJpYWwtY29tcG9uZW50cy13ZWIvdHJlZS9tYXN0ZXIvcGFja2FnZXMvbWRjLWRhdGEtdGFibGUnLFxyXG4gICAgZ3VpZGU6ICdodHRwczovL21hdGVyaWFsLmlvL2NvbXBvbmVudHMvZGF0YS10YWJsZXMnXHJcbn07XHJcblxyXG5jb25zdCB0YWJsZSA9IFtcclxuICAgIFsnRnJvemVuIHlvZ3VydCcsIDI0LCA0LjAsICdTdXBlciB0YXN0eSddLFxyXG4gICAgWydJY2UgY3JlYW0gc2FuZHdpY2gnLCAzNywgNC4zMzMzMzMzMzMzMywgJ0kgbGlrZSBpY2UgY3JlYW0gbW9yZSddLFxyXG4gICAgWydFY2xhaXInLCAyNCwgNi4wLCAnTmV3IGZpbGluZyBmbGF2b3InXVxyXG5dO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gRGF0YVRhYmxlUGFnZSgpIHtcclxuICAgIGNvbnN0IFtkYXRhLCBzZXREYXRhXSA9IHVzZVN0YXRlKHRhYmxlKTtcclxuICAgIGNvbnN0IFtzb3J0LCBzZXRTb3J0XSA9IHVzZVN0YXRlKDApO1xyXG5cclxuICAgIGNvbnN0IGhhbmRsZVNvcnQgPSB1c2VDYWxsYmFjaygoKSA9PiB7XHJcbiAgICAgICAgc2V0U29ydChzb3J0ID0+IHtcclxuICAgICAgICAgICAgaWYgKHNvcnQgPT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICBzZXREYXRhKGRhdGEgPT4gZGF0YS5zbGljZSgpLnNvcnQoKGEsIGIpID0+IGFbMV0gLSBiWzFdKSk7XHJcbiAgICAgICAgICAgICAgICBzZXRTb3J0KDEpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgc2V0RGF0YShkYXRhID0+IGRhdGEuc2xpY2UoKS5zb3J0KChhLCBiKSA9PiBiWzFdIC0gYVsxXSkpO1xyXG4gICAgICAgICAgICAgICAgc2V0U29ydCgtMSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH0sIFtdKTtcclxuXHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAgIDxQYWdlIGlkPXtpZH0gdGl0bGU9e3RpdGxlfSBkZXNjcmlwdGlvbj17ZGVzY3JpcHRpb259IGxpbmtzPXtsaW5rc30+XHJcbiAgICAgICAgICAgIDxTZWN0aW9uIHRpdGxlPVwiU29ydGFibGUgZGF0YSB0YWJsZVwiPlxyXG4gICAgICAgICAgICAgICAgPENvZGU+XHJcbiAgICAgICAgICAgICAgICAgICAgPERhdGFUYWJsZT5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPERhdGFUYWJsZS5IZWFkZXI+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8RGF0YVRhYmxlLkhlYWRlclJvdz5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8RGF0YVRhYmxlLkhlYWRlckNlbGw+RGVzc2VydDwvRGF0YVRhYmxlLkhlYWRlckNlbGw+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPERhdGFUYWJsZS5IZWFkZXJDZWxsIG51bWVyaWMgc29ydD17c29ydH0gb25Tb3J0PXtoYW5kbGVTb3J0fT5DYXJicyAoZyk8L0RhdGFUYWJsZS5IZWFkZXJDZWxsPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxEYXRhVGFibGUuSGVhZGVyQ2VsbCBudW1lcmljPlByb3RlaW4gKGcpPC9EYXRhVGFibGUuSGVhZGVyQ2VsbD5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8RGF0YVRhYmxlLkhlYWRlckNlbGw+Q29tbWVudHM8L0RhdGFUYWJsZS5IZWFkZXJDZWxsPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9EYXRhVGFibGUuSGVhZGVyUm93PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8L0RhdGFUYWJsZS5IZWFkZXI+XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8RGF0YVRhYmxlLkNvbnRlbnQ+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7ZGF0YS5tYXAoKHJvdywgaW5kZXgpID0+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPERhdGFUYWJsZS5Sb3cga2V5PXtpbmRleH0+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtyb3cubWFwKCh2YWx1ZSwgaW5kZXgpID0+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8RGF0YVRhYmxlLkNlbGwga2V5PXtpbmRleH0gc2NvcGU9e2luZGV4ID09PSAwID8gJ3JvdycgOiB1bmRlZmluZWR9IG51bWVyaWM9e3R5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgfHwgdW5kZWZpbmVkfT5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7dmFsdWV9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L0RhdGFUYWJsZS5DZWxsPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvRGF0YVRhYmxlLlJvdz5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICl9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDwvRGF0YVRhYmxlLkNvbnRlbnQ+XHJcbiAgICAgICAgICAgICAgICAgICAgPC9EYXRhVGFibGU+XHJcbiAgICAgICAgICAgICAgICA8L0NvZGU+XHJcbiAgICAgICAgICAgIDwvU2VjdGlvbj5cclxuICAgICAgICA8L1BhZ2U+XHJcbiAgICApO1xyXG59IiwiaW1wb3J0IHsgdXNlU3RhdGUgfSBmcm9tICdyZWFjdCc7XHJcbmltcG9ydCB7XHJcbiAgICBCdXR0b24sXHJcbiAgICBEaWFsb2dcclxufSBmcm9tICdtZGMtcmVhY3QnO1xyXG5cclxuaW1wb3J0IFBhZ2UgZnJvbSAnQC9jb21wb25lbnRzL1BhZ2UnO1xyXG5pbXBvcnQgU2VjdGlvbiBmcm9tICdAL2NvbXBvbmVudHMvU2VjdGlvbic7XHJcbmltcG9ydCBDb2RlIGZyb20gJ0AvY29tcG9uZW50cy9Db2RlJztcclxuXHJcbmNvbnN0IGlkID0gJ2RpYWxvZyc7XHJcbmNvbnN0IHRpdGxlID0gJ0RpYWxvZyc7XHJcbmNvbnN0IGRlc2NyaXB0aW9uID0gJ0RpYWxvZ3MgaW5mb3JtIHVzZXJzIGFib3V0IGEgc3BlY2lmaWMgdGFzayBhbmQgbWF5IGNvbnRhaW4gY3JpdGljYWwgaW5mb3JtYXRpb24sIHJlcXVpcmUgZGVjaXNpb25zLCBvciBpbnZvbHZlIG11bHRpcGxlIHRhc2tzLic7XHJcbmNvbnN0IGxpbmtzID0ge1xyXG4gICAgZG9jczogJ2h0dHBzOi8vZ2l0aHViLmNvbS9tYXRlcmlhbC1jb21wb25lbnRzL21hdGVyaWFsLWNvbXBvbmVudHMtd2ViL3RyZWUvbWFzdGVyL3BhY2thZ2VzL21kYy1kaWFsb2cnLFxyXG4gICAgZ3VpZGU6ICdodHRwczovL21hdGVyaWFsLmlvL2NvbXBvbmVudHMvZGlhbG9ncydcclxufTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIERpYWxvZ1BhZ2UoKSB7XHJcbiAgICBjb25zdCBbaXNCYXNpY09wZW4sIHNldEJhc2ljT3Blbl0gPSB1c2VTdGF0ZShmYWxzZSk7XHJcbiAgICBjb25zdCBbaXNDb25maXJtYXRpb25PcGVuLCBzZXRDb25maXJtYXRpb25PcGVuXSA9IHVzZVN0YXRlKGZhbHNlKTtcclxuICAgIGNvbnN0IFtpc1N0YWNraW5nT3Blbiwgc2V0U3RhY2tpbmdPcGVuXSA9IHVzZVN0YXRlKGZhbHNlKTtcclxuICAgIGNvbnN0IFtpc1Njcm9sbGFibGVPcGVuLCBzZXRTY3JvbGxhYmxlT3Blbl0gPSB1c2VTdGF0ZShmYWxzZSk7XHJcbiAgICBjb25zdCBbaXNGdWxsc2NyZWVuT3Blbiwgc2V0RnVsbHNjcmVlbk9wZW5dID0gdXNlU3RhdGUoZmFsc2UpO1xyXG5cclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgPFBhZ2UgaWQ9e2lkfSB0aXRsZT17dGl0bGV9IGRlc2NyaXB0aW9uPXtkZXNjcmlwdGlvbn0gbGlua3M9e2xpbmtzfT5cclxuICAgICAgICAgICAgPFNlY3Rpb24gdGl0bGU9XCJCYXNpYyBkaWFsb2dcIj5cclxuICAgICAgICAgICAgICAgIDxDb2RlXHJcbiAgICAgICAgICAgICAgICAgICAgc2V0dXA9e1xyXG4gICAgICAgICAgICAgICAgICAgICAgICA8QnV0dG9uIG9uQ2xpY2s9eygpID0+IHNldEJhc2ljT3Blbih2ID0+ICF2KX0+T3BlbjwvQnV0dG9uPlxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgID5cclxuICAgICAgICAgICAgICAgICAgICA8RGlhbG9nXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlPVwiVGl0bGVcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50PVwiQ29udGVudFwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wZW49e2lzQmFzaWNPcGVufVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBvbkNsb3NlPXsoKSA9PiBzZXRCYXNpY09wZW4odiA9PiAhdil9XHJcbiAgICAgICAgICAgICAgICAgICAgLz5cclxuICAgICAgICAgICAgICAgIDwvQ29kZT5cclxuICAgICAgICAgICAgPC9TZWN0aW9uPlxyXG5cclxuICAgICAgICAgICAgPFNlY3Rpb24gdGl0bGU9XCJDb25maXJtYXRpb24gZGlhbG9nXCI+XHJcbiAgICAgICAgICAgICAgICA8Q29kZVxyXG4gICAgICAgICAgICAgICAgICAgIHNldHVwPXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgPEJ1dHRvbiBvbkNsaWNrPXsoKSA9PiBzZXRDb25maXJtYXRpb25PcGVuKHYgPT4gIXYpfT5PcGVuPC9CdXR0b24+XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgPlxyXG4gICAgICAgICAgICAgICAgICAgIDxEaWFsb2dcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGU9XCJUaXRsZVwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ9XCJBcmUgeW91IHN1cmU/XCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgb3Blbj17aXNDb25maXJtYXRpb25PcGVufVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwZXJzaXN0ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGF1dG9TdGFja0J1dHRvbnNcclxuICAgICAgICAgICAgICAgICAgICAgICAgYWN0aW9ucz17W1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPEJ1dHRvbiBrZXk9XCJjbG9zZVwiIG9uQ2xpY2s9eygpID0+IHNldENvbmZpcm1hdGlvbk9wZW4odiA9PiAhdil9PkNsb3NlPC9CdXR0b24+LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPEJ1dHRvbiBrZXk9XCJjb25maXJtXCI+Q29uZmlybTwvQnV0dG9uPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBdfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBvbkNsb3NlPXsoKSA9PiBzZXRDb25maXJtYXRpb25PcGVuKHYgPT4gIXYpfVxyXG4gICAgICAgICAgICAgICAgICAgIC8+XHJcbiAgICAgICAgICAgICAgICA8L0NvZGU+XHJcbiAgICAgICAgICAgIDwvU2VjdGlvbj5cclxuXHJcbiAgICAgICAgICAgIDxTZWN0aW9uIHRpdGxlPVwiRGlhbG9nIHdpdGggc3RhY2tpbmcgYnV0dG9uc1wiPlxyXG4gICAgICAgICAgICAgICAgPENvZGVcclxuICAgICAgICAgICAgICAgICAgICBzZXR1cD17XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxCdXR0b24gb25DbGljaz17KCkgPT4gc2V0U3RhY2tpbmdPcGVuKHYgPT4gIXYpfT5PcGVuPC9CdXR0b24+XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgPlxyXG4gICAgICAgICAgICAgICAgICAgIDxEaWFsb2dcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGU9XCJUaXRsZVwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wZW49e2lzU3RhY2tpbmdPcGVufVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBhdXRvU3RhY2tCdXR0b25zXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjdGlvbnM9e1tcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxCdXR0b24ga2V5PVwiY2xvc2VcIiBvbkNsaWNrPXsoKSA9PiBzZXRTdGFja2luZ09wZW4odiA9PiAhdil9PkEgdmVyeSB2ZXJ5IHZlcnkgdmVyeSB2ZXJ5IGxvbmcgYnV0dG9uPC9CdXR0b24+LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPEJ1dHRvbiBrZXk9XCJjb25maXJtXCI+QSB2ZXJ5IHZlcnkgdmVyeSB2ZXJ5IHZlcnkgbG9uZyBidXR0b248L0J1dHRvbj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgXX1cclxuICAgICAgICAgICAgICAgICAgICAgICAgb25DbG9zZT17KCkgPT4gc2V0U3RhY2tpbmdPcGVuKHYgPT4gIXYpfVxyXG4gICAgICAgICAgICAgICAgICAgIC8+XHJcbiAgICAgICAgICAgICAgICA8L0NvZGU+XHJcbiAgICAgICAgICAgIDwvU2VjdGlvbj5cclxuXHJcbiAgICAgICAgICAgIDxTZWN0aW9uIHRpdGxlPVwiU2Nyb2xsYWJsZSBkaWFsb2dcIj5cclxuICAgICAgICAgICAgICAgIDxDb2RlXHJcbiAgICAgICAgICAgICAgICAgICAgc2V0dXA9e1xyXG4gICAgICAgICAgICAgICAgICAgICAgICA8QnV0dG9uIG9uQ2xpY2s9eygpID0+IHNldFNjcm9sbGFibGVPcGVuKHYgPT4gIXYpfT5PcGVuPC9CdXR0b24+XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgPlxyXG4gICAgICAgICAgICAgICAgICAgIDxEaWFsb2dcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGU9XCJUaXRsZVwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wZW49e2lzU2Nyb2xsYWJsZU9wZW59XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjdGlvbnM9e1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPEJ1dHRvbiBvbkNsaWNrPXsoKSA9PiBzZXRTY3JvbGxhYmxlT3Blbih2ID0+ICF2KX0+Q2xvc2U8L0J1dHRvbj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBvbkNsb3NlPXsoKSA9PiBzZXRTY3JvbGxhYmxlT3Blbih2ID0+ICF2KX1cclxuICAgICAgICAgICAgICAgICAgICA+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIExvcmVtIGlwc3VtIGRvbG9yIHNpdCBhbWV0IGNvbnNlY3RldHVyIGFkaXBpc2ljaW5nIGVsaXQuIFN1bnQgZWFydW0gcXVpYnVzZGFtIGRvbG9yIGhpYyBhY2N1c2FtdXMsIGRlc2VydW50IGxpYmVybz8gRGVsZW5pdGkgcmF0aW9uZSBsaWJlcm8sIGV2ZW5pZXQgbmVxdWUgYWxpcXVhbSByZXBlbGxhdCBkaWN0YSBvYmNhZWNhdGkgYXRxdWUsIHNlcXVpIHZvbHVwdGF0ZW0gZXhwbGljYWJvIGJlYXRhZSFcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIExvcmVtIGlwc3VtIGRvbG9yIHNpdCBhbWV0IGNvbnNlY3RldHVyIGFkaXBpc2ljaW5nIGVsaXQuIFZlcml0YXRpcyBhbmltaSB2ZWwgY3VwaWRpdGF0ZSBldmVuaWV0PyBMYXVkYW50aXVtIHJlY3VzYW5kYWUgaWxsbyBtaW51cyBzYWVwZSBpdGFxdWUgZG9sb3JlcyBmdWdpYXQsIHBlcmZlcmVuZGlzIG5vc3RydW0hIEFzc3VtZW5kYSBmdWdpYXQgZnVnYSBkZXNlcnVudCBvbW5pcyBvZGl0IGRpY3RhIVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgTG9yZW0gaXBzdW0gZG9sb3Igc2l0IGFtZXQgY29uc2VjdGV0dXIgYWRpcGlzaWNpbmcgZWxpdC4gTWludXMgYWNjdXNhbnRpdW0gYSBxdWlzcXVhbSBpbiByZXB1ZGlhbmRhZSBldCB1bGxhbSBjdW0gZGlnbmlzc2ltb3MgZXhlcmNpdGF0aW9uZW0sIGJsYW5kaXRpaXMgcGVyc3BpY2lhdGlzIGFsaWFzIGhpYyB2ZWwsIGxhdWRhbnRpdW0gYWxpcXVhbSBvbW5pcyByZWN1c2FuZGFlIG5lbW8gYW5pbWkuXHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBMb3JlbSBpcHN1bSBkb2xvciBzaXQgYW1ldCBjb25zZWN0ZXR1ciBhZGlwaXNpY2luZyBlbGl0LiBTdW50IGVhcnVtIHF1aWJ1c2RhbSBkb2xvciBoaWMgYWNjdXNhbXVzLCBkZXNlcnVudCBsaWJlcm8/IERlbGVuaXRpIHJhdGlvbmUgbGliZXJvLCBldmVuaWV0IG5lcXVlIGFsaXF1YW0gcmVwZWxsYXQgZGljdGEgb2JjYWVjYXRpIGF0cXVlLCBzZXF1aSB2b2x1cHRhdGVtIGV4cGxpY2FibyBiZWF0YWUhXHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBMb3JlbSBpcHN1bSBkb2xvciBzaXQgYW1ldCBjb25zZWN0ZXR1ciBhZGlwaXNpY2luZyBlbGl0LiBWZXJpdGF0aXMgYW5pbWkgdmVsIGN1cGlkaXRhdGUgZXZlbmlldD8gTGF1ZGFudGl1bSByZWN1c2FuZGFlIGlsbG8gbWludXMgc2FlcGUgaXRhcXVlIGRvbG9yZXMgZnVnaWF0LCBwZXJmZXJlbmRpcyBub3N0cnVtISBBc3N1bWVuZGEgZnVnaWF0IGZ1Z2EgZGVzZXJ1bnQgb21uaXMgb2RpdCBkaWN0YSFcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIExvcmVtIGlwc3VtIGRvbG9yIHNpdCBhbWV0IGNvbnNlY3RldHVyIGFkaXBpc2ljaW5nIGVsaXQuIE1pbnVzIGFjY3VzYW50aXVtIGEgcXVpc3F1YW0gaW4gcmVwdWRpYW5kYWUgZXQgdWxsYW0gY3VtIGRpZ25pc3NpbW9zIGV4ZXJjaXRhdGlvbmVtLCBibGFuZGl0aWlzIHBlcnNwaWNpYXRpcyBhbGlhcyBoaWMgdmVsLCBsYXVkYW50aXVtIGFsaXF1YW0gb21uaXMgcmVjdXNhbmRhZSBuZW1vIGFuaW1pLlxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgTG9yZW0gaXBzdW0gZG9sb3Igc2l0IGFtZXQgY29uc2VjdGV0dXIgYWRpcGlzaWNpbmcgZWxpdC4gU3VudCBlYXJ1bSBxdWlidXNkYW0gZG9sb3IgaGljIGFjY3VzYW11cywgZGVzZXJ1bnQgbGliZXJvPyBEZWxlbml0aSByYXRpb25lIGxpYmVybywgZXZlbmlldCBuZXF1ZSBhbGlxdWFtIHJlcGVsbGF0IGRpY3RhIG9iY2FlY2F0aSBhdHF1ZSwgc2VxdWkgdm9sdXB0YXRlbSBleHBsaWNhYm8gYmVhdGFlIVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgTG9yZW0gaXBzdW0gZG9sb3Igc2l0IGFtZXQgY29uc2VjdGV0dXIgYWRpcGlzaWNpbmcgZWxpdC4gVmVyaXRhdGlzIGFuaW1pIHZlbCBjdXBpZGl0YXRlIGV2ZW5pZXQ/IExhdWRhbnRpdW0gcmVjdXNhbmRhZSBpbGxvIG1pbnVzIHNhZXBlIGl0YXF1ZSBkb2xvcmVzIGZ1Z2lhdCwgcGVyZmVyZW5kaXMgbm9zdHJ1bSEgQXNzdW1lbmRhIGZ1Z2lhdCBmdWdhIGRlc2VydW50IG9tbmlzIG9kaXQgZGljdGEhXHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBMb3JlbSBpcHN1bSBkb2xvciBzaXQgYW1ldCBjb25zZWN0ZXR1ciBhZGlwaXNpY2luZyBlbGl0LiBNaW51cyBhY2N1c2FudGl1bSBhIHF1aXNxdWFtIGluIHJlcHVkaWFuZGFlIGV0IHVsbGFtIGN1bSBkaWduaXNzaW1vcyBleGVyY2l0YXRpb25lbSwgYmxhbmRpdGlpcyBwZXJzcGljaWF0aXMgYWxpYXMgaGljIHZlbCwgbGF1ZGFudGl1bSBhbGlxdWFtIG9tbmlzIHJlY3VzYW5kYWUgbmVtbyBhbmltaS5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIExvcmVtIGlwc3VtIGRvbG9yIHNpdCBhbWV0IGNvbnNlY3RldHVyIGFkaXBpc2ljaW5nIGVsaXQuIFN1bnQgZWFydW0gcXVpYnVzZGFtIGRvbG9yIGhpYyBhY2N1c2FtdXMsIGRlc2VydW50IGxpYmVybz8gRGVsZW5pdGkgcmF0aW9uZSBsaWJlcm8sIGV2ZW5pZXQgbmVxdWUgYWxpcXVhbSByZXBlbGxhdCBkaWN0YSBvYmNhZWNhdGkgYXRxdWUsIHNlcXVpIHZvbHVwdGF0ZW0gZXhwbGljYWJvIGJlYXRhZSFcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIExvcmVtIGlwc3VtIGRvbG9yIHNpdCBhbWV0IGNvbnNlY3RldHVyIGFkaXBpc2ljaW5nIGVsaXQuIFZlcml0YXRpcyBhbmltaSB2ZWwgY3VwaWRpdGF0ZSBldmVuaWV0PyBMYXVkYW50aXVtIHJlY3VzYW5kYWUgaWxsbyBtaW51cyBzYWVwZSBpdGFxdWUgZG9sb3JlcyBmdWdpYXQsIHBlcmZlcmVuZGlzIG5vc3RydW0hIEFzc3VtZW5kYSBmdWdpYXQgZnVnYSBkZXNlcnVudCBvbW5pcyBvZGl0IGRpY3RhIVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgTG9yZW0gaXBzdW0gZG9sb3Igc2l0IGFtZXQgY29uc2VjdGV0dXIgYWRpcGlzaWNpbmcgZWxpdC4gTWludXMgYWNjdXNhbnRpdW0gYSBxdWlzcXVhbSBpbiByZXB1ZGlhbmRhZSBldCB1bGxhbSBjdW0gZGlnbmlzc2ltb3MgZXhlcmNpdGF0aW9uZW0sIGJsYW5kaXRpaXMgcGVyc3BpY2lhdGlzIGFsaWFzIGhpYyB2ZWwsIGxhdWRhbnRpdW0gYWxpcXVhbSBvbW5pcyByZWN1c2FuZGFlIG5lbW8gYW5pbWkuXHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBMb3JlbSBpcHN1bSBkb2xvciBzaXQgYW1ldCBjb25zZWN0ZXR1ciBhZGlwaXNpY2luZyBlbGl0LiBTdW50IGVhcnVtIHF1aWJ1c2RhbSBkb2xvciBoaWMgYWNjdXNhbXVzLCBkZXNlcnVudCBsaWJlcm8/IERlbGVuaXRpIHJhdGlvbmUgbGliZXJvLCBldmVuaWV0IG5lcXVlIGFsaXF1YW0gcmVwZWxsYXQgZGljdGEgb2JjYWVjYXRpIGF0cXVlLCBzZXF1aSB2b2x1cHRhdGVtIGV4cGxpY2FibyBiZWF0YWUhXHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBMb3JlbSBpcHN1bSBkb2xvciBzaXQgYW1ldCBjb25zZWN0ZXR1ciBhZGlwaXNpY2luZyBlbGl0LiBWZXJpdGF0aXMgYW5pbWkgdmVsIGN1cGlkaXRhdGUgZXZlbmlldD8gTGF1ZGFudGl1bSByZWN1c2FuZGFlIGlsbG8gbWludXMgc2FlcGUgaXRhcXVlIGRvbG9yZXMgZnVnaWF0LCBwZXJmZXJlbmRpcyBub3N0cnVtISBBc3N1bWVuZGEgZnVnaWF0IGZ1Z2EgZGVzZXJ1bnQgb21uaXMgb2RpdCBkaWN0YSFcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIExvcmVtIGlwc3VtIGRvbG9yIHNpdCBhbWV0IGNvbnNlY3RldHVyIGFkaXBpc2ljaW5nIGVsaXQuIE1pbnVzIGFjY3VzYW50aXVtIGEgcXVpc3F1YW0gaW4gcmVwdWRpYW5kYWUgZXQgdWxsYW0gY3VtIGRpZ25pc3NpbW9zIGV4ZXJjaXRhdGlvbmVtLCBibGFuZGl0aWlzIHBlcnNwaWNpYXRpcyBhbGlhcyBoaWMgdmVsLCBsYXVkYW50aXVtIGFsaXF1YW0gb21uaXMgcmVjdXNhbmRhZSBuZW1vIGFuaW1pLlxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgTG9yZW0gaXBzdW0gZG9sb3Igc2l0IGFtZXQgY29uc2VjdGV0dXIgYWRpcGlzaWNpbmcgZWxpdC4gU3VudCBlYXJ1bSBxdWlidXNkYW0gZG9sb3IgaGljIGFjY3VzYW11cywgZGVzZXJ1bnQgbGliZXJvPyBEZWxlbml0aSByYXRpb25lIGxpYmVybywgZXZlbmlldCBuZXF1ZSBhbGlxdWFtIHJlcGVsbGF0IGRpY3RhIG9iY2FlY2F0aSBhdHF1ZSwgc2VxdWkgdm9sdXB0YXRlbSBleHBsaWNhYm8gYmVhdGFlIVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgTG9yZW0gaXBzdW0gZG9sb3Igc2l0IGFtZXQgY29uc2VjdGV0dXIgYWRpcGlzaWNpbmcgZWxpdC4gVmVyaXRhdGlzIGFuaW1pIHZlbCBjdXBpZGl0YXRlIGV2ZW5pZXQ/IExhdWRhbnRpdW0gcmVjdXNhbmRhZSBpbGxvIG1pbnVzIHNhZXBlIGl0YXF1ZSBkb2xvcmVzIGZ1Z2lhdCwgcGVyZmVyZW5kaXMgbm9zdHJ1bSEgQXNzdW1lbmRhIGZ1Z2lhdCBmdWdhIGRlc2VydW50IG9tbmlzIG9kaXQgZGljdGEhXHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBMb3JlbSBpcHN1bSBkb2xvciBzaXQgYW1ldCBjb25zZWN0ZXR1ciBhZGlwaXNpY2luZyBlbGl0LiBNaW51cyBhY2N1c2FudGl1bSBhIHF1aXNxdWFtIGluIHJlcHVkaWFuZGFlIGV0IHVsbGFtIGN1bSBkaWduaXNzaW1vcyBleGVyY2l0YXRpb25lbSwgYmxhbmRpdGlpcyBwZXJzcGljaWF0aXMgYWxpYXMgaGljIHZlbCwgbGF1ZGFudGl1bSBhbGlxdWFtIG9tbmlzIHJlY3VzYW5kYWUgbmVtbyBhbmltaS5cclxuICAgICAgICAgICAgICAgICAgICA8L0RpYWxvZz5cclxuICAgICAgICAgICAgICAgIDwvQ29kZT5cclxuICAgICAgICAgICAgPC9TZWN0aW9uPlxyXG5cclxuICAgICAgICAgICAgPFNlY3Rpb24gdGl0bGU9XCJGdWxsc2NyZWVuIGRpYWxvZ1wiPlxyXG4gICAgICAgICAgICAgICAgPENvZGVcclxuICAgICAgICAgICAgICAgICAgICBzZXR1cD17XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxCdXR0b24gb25DbGljaz17KCkgPT4gc2V0RnVsbHNjcmVlbk9wZW4odiA9PiAhdil9Pk9wZW48L0J1dHRvbj5cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICA+XHJcbiAgICAgICAgICAgICAgICAgICAgPERpYWxvZ1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aXRsZT1cIkZ1bGxzY3JlZW4gRGlhbG9nXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgb3Blbj17aXNGdWxsc2NyZWVuT3Blbn1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZnVsbHNjcmVlblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBhY3Rpb25zPXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxCdXR0b24gb25DbGljaz17KCkgPT4gc2V0RnVsbHNjcmVlbk9wZW4odiA9PiAhdil9PkNsb3NlPC9CdXR0b24+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgb25DbG9zZT17KCkgPT4gc2V0RnVsbHNjcmVlbk9wZW4odiA9PiAhdil9XHJcbiAgICAgICAgICAgICAgICAgICAgPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBMb3JlbSBpcHN1bSBkb2xvciBzaXQgYW1ldCBjb25zZWN0ZXR1ciBhZGlwaXNpY2luZyBlbGl0LiBTdW50IGVhcnVtIHF1aWJ1c2RhbSBkb2xvciBoaWMgYWNjdXNhbXVzLCBkZXNlcnVudCBsaWJlcm8/IERlbGVuaXRpIHJhdGlvbmUgbGliZXJvLCBldmVuaWV0IG5lcXVlIGFsaXF1YW0gcmVwZWxsYXQgZGljdGEgb2JjYWVjYXRpIGF0cXVlLCBzZXF1aSB2b2x1cHRhdGVtIGV4cGxpY2FibyBiZWF0YWUhXHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBMb3JlbSBpcHN1bSBkb2xvciBzaXQgYW1ldCBjb25zZWN0ZXR1ciBhZGlwaXNpY2luZyBlbGl0LiBWZXJpdGF0aXMgYW5pbWkgdmVsIGN1cGlkaXRhdGUgZXZlbmlldD8gTGF1ZGFudGl1bSByZWN1c2FuZGFlIGlsbG8gbWludXMgc2FlcGUgaXRhcXVlIGRvbG9yZXMgZnVnaWF0LCBwZXJmZXJlbmRpcyBub3N0cnVtISBBc3N1bWVuZGEgZnVnaWF0IGZ1Z2EgZGVzZXJ1bnQgb21uaXMgb2RpdCBkaWN0YSFcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIExvcmVtIGlwc3VtIGRvbG9yIHNpdCBhbWV0IGNvbnNlY3RldHVyIGFkaXBpc2ljaW5nIGVsaXQuIE1pbnVzIGFjY3VzYW50aXVtIGEgcXVpc3F1YW0gaW4gcmVwdWRpYW5kYWUgZXQgdWxsYW0gY3VtIGRpZ25pc3NpbW9zIGV4ZXJjaXRhdGlvbmVtLCBibGFuZGl0aWlzIHBlcnNwaWNpYXRpcyBhbGlhcyBoaWMgdmVsLCBsYXVkYW50aXVtIGFsaXF1YW0gb21uaXMgcmVjdXNhbmRhZSBuZW1vIGFuaW1pLlxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgTG9yZW0gaXBzdW0gZG9sb3Igc2l0IGFtZXQgY29uc2VjdGV0dXIgYWRpcGlzaWNpbmcgZWxpdC4gU3VudCBlYXJ1bSBxdWlidXNkYW0gZG9sb3IgaGljIGFjY3VzYW11cywgZGVzZXJ1bnQgbGliZXJvPyBEZWxlbml0aSByYXRpb25lIGxpYmVybywgZXZlbmlldCBuZXF1ZSBhbGlxdWFtIHJlcGVsbGF0IGRpY3RhIG9iY2FlY2F0aSBhdHF1ZSwgc2VxdWkgdm9sdXB0YXRlbSBleHBsaWNhYm8gYmVhdGFlIVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgTG9yZW0gaXBzdW0gZG9sb3Igc2l0IGFtZXQgY29uc2VjdGV0dXIgYWRpcGlzaWNpbmcgZWxpdC4gVmVyaXRhdGlzIGFuaW1pIHZlbCBjdXBpZGl0YXRlIGV2ZW5pZXQ/IExhdWRhbnRpdW0gcmVjdXNhbmRhZSBpbGxvIG1pbnVzIHNhZXBlIGl0YXF1ZSBkb2xvcmVzIGZ1Z2lhdCwgcGVyZmVyZW5kaXMgbm9zdHJ1bSEgQXNzdW1lbmRhIGZ1Z2lhdCBmdWdhIGRlc2VydW50IG9tbmlzIG9kaXQgZGljdGEhXHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBMb3JlbSBpcHN1bSBkb2xvciBzaXQgYW1ldCBjb25zZWN0ZXR1ciBhZGlwaXNpY2luZyBlbGl0LiBNaW51cyBhY2N1c2FudGl1bSBhIHF1aXNxdWFtIGluIHJlcHVkaWFuZGFlIGV0IHVsbGFtIGN1bSBkaWduaXNzaW1vcyBleGVyY2l0YXRpb25lbSwgYmxhbmRpdGlpcyBwZXJzcGljaWF0aXMgYWxpYXMgaGljIHZlbCwgbGF1ZGFudGl1bSBhbGlxdWFtIG9tbmlzIHJlY3VzYW5kYWUgbmVtbyBhbmltaS5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIExvcmVtIGlwc3VtIGRvbG9yIHNpdCBhbWV0IGNvbnNlY3RldHVyIGFkaXBpc2ljaW5nIGVsaXQuIFN1bnQgZWFydW0gcXVpYnVzZGFtIGRvbG9yIGhpYyBhY2N1c2FtdXMsIGRlc2VydW50IGxpYmVybz8gRGVsZW5pdGkgcmF0aW9uZSBsaWJlcm8sIGV2ZW5pZXQgbmVxdWUgYWxpcXVhbSByZXBlbGxhdCBkaWN0YSBvYmNhZWNhdGkgYXRxdWUsIHNlcXVpIHZvbHVwdGF0ZW0gZXhwbGljYWJvIGJlYXRhZSFcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIExvcmVtIGlwc3VtIGRvbG9yIHNpdCBhbWV0IGNvbnNlY3RldHVyIGFkaXBpc2ljaW5nIGVsaXQuIFZlcml0YXRpcyBhbmltaSB2ZWwgY3VwaWRpdGF0ZSBldmVuaWV0PyBMYXVkYW50aXVtIHJlY3VzYW5kYWUgaWxsbyBtaW51cyBzYWVwZSBpdGFxdWUgZG9sb3JlcyBmdWdpYXQsIHBlcmZlcmVuZGlzIG5vc3RydW0hIEFzc3VtZW5kYSBmdWdpYXQgZnVnYSBkZXNlcnVudCBvbW5pcyBvZGl0IGRpY3RhIVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgTG9yZW0gaXBzdW0gZG9sb3Igc2l0IGFtZXQgY29uc2VjdGV0dXIgYWRpcGlzaWNpbmcgZWxpdC4gTWludXMgYWNjdXNhbnRpdW0gYSBxdWlzcXVhbSBpbiByZXB1ZGlhbmRhZSBldCB1bGxhbSBjdW0gZGlnbmlzc2ltb3MgZXhlcmNpdGF0aW9uZW0sIGJsYW5kaXRpaXMgcGVyc3BpY2lhdGlzIGFsaWFzIGhpYyB2ZWwsIGxhdWRhbnRpdW0gYWxpcXVhbSBvbW5pcyByZWN1c2FuZGFlIG5lbW8gYW5pbWkuXHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBMb3JlbSBpcHN1bSBkb2xvciBzaXQgYW1ldCBjb25zZWN0ZXR1ciBhZGlwaXNpY2luZyBlbGl0LiBTdW50IGVhcnVtIHF1aWJ1c2RhbSBkb2xvciBoaWMgYWNjdXNhbXVzLCBkZXNlcnVudCBsaWJlcm8/IERlbGVuaXRpIHJhdGlvbmUgbGliZXJvLCBldmVuaWV0IG5lcXVlIGFsaXF1YW0gcmVwZWxsYXQgZGljdGEgb2JjYWVjYXRpIGF0cXVlLCBzZXF1aSB2b2x1cHRhdGVtIGV4cGxpY2FibyBiZWF0YWUhXHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBMb3JlbSBpcHN1bSBkb2xvciBzaXQgYW1ldCBjb25zZWN0ZXR1ciBhZGlwaXNpY2luZyBlbGl0LiBWZXJpdGF0aXMgYW5pbWkgdmVsIGN1cGlkaXRhdGUgZXZlbmlldD8gTGF1ZGFudGl1bSByZWN1c2FuZGFlIGlsbG8gbWludXMgc2FlcGUgaXRhcXVlIGRvbG9yZXMgZnVnaWF0LCBwZXJmZXJlbmRpcyBub3N0cnVtISBBc3N1bWVuZGEgZnVnaWF0IGZ1Z2EgZGVzZXJ1bnQgb21uaXMgb2RpdCBkaWN0YSFcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIExvcmVtIGlwc3VtIGRvbG9yIHNpdCBhbWV0IGNvbnNlY3RldHVyIGFkaXBpc2ljaW5nIGVsaXQuIE1pbnVzIGFjY3VzYW50aXVtIGEgcXVpc3F1YW0gaW4gcmVwdWRpYW5kYWUgZXQgdWxsYW0gY3VtIGRpZ25pc3NpbW9zIGV4ZXJjaXRhdGlvbmVtLCBibGFuZGl0aWlzIHBlcnNwaWNpYXRpcyBhbGlhcyBoaWMgdmVsLCBsYXVkYW50aXVtIGFsaXF1YW0gb21uaXMgcmVjdXNhbmRhZSBuZW1vIGFuaW1pLlxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgTG9yZW0gaXBzdW0gZG9sb3Igc2l0IGFtZXQgY29uc2VjdGV0dXIgYWRpcGlzaWNpbmcgZWxpdC4gU3VudCBlYXJ1bSBxdWlidXNkYW0gZG9sb3IgaGljIGFjY3VzYW11cywgZGVzZXJ1bnQgbGliZXJvPyBEZWxlbml0aSByYXRpb25lIGxpYmVybywgZXZlbmlldCBuZXF1ZSBhbGlxdWFtIHJlcGVsbGF0IGRpY3RhIG9iY2FlY2F0aSBhdHF1ZSwgc2VxdWkgdm9sdXB0YXRlbSBleHBsaWNhYm8gYmVhdGFlIVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgTG9yZW0gaXBzdW0gZG9sb3Igc2l0IGFtZXQgY29uc2VjdGV0dXIgYWRpcGlzaWNpbmcgZWxpdC4gVmVyaXRhdGlzIGFuaW1pIHZlbCBjdXBpZGl0YXRlIGV2ZW5pZXQ/IExhdWRhbnRpdW0gcmVjdXNhbmRhZSBpbGxvIG1pbnVzIHNhZXBlIGl0YXF1ZSBkb2xvcmVzIGZ1Z2lhdCwgcGVyZmVyZW5kaXMgbm9zdHJ1bSEgQXNzdW1lbmRhIGZ1Z2lhdCBmdWdhIGRlc2VydW50IG9tbmlzIG9kaXQgZGljdGEhXHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBMb3JlbSBpcHN1bSBkb2xvciBzaXQgYW1ldCBjb25zZWN0ZXR1ciBhZGlwaXNpY2luZyBlbGl0LiBNaW51cyBhY2N1c2FudGl1bSBhIHF1aXNxdWFtIGluIHJlcHVkaWFuZGFlIGV0IHVsbGFtIGN1bSBkaWduaXNzaW1vcyBleGVyY2l0YXRpb25lbSwgYmxhbmRpdGlpcyBwZXJzcGljaWF0aXMgYWxpYXMgaGljIHZlbCwgbGF1ZGFudGl1bSBhbGlxdWFtIG9tbmlzIHJlY3VzYW5kYWUgbmVtbyBhbmltaS5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIExvcmVtIGlwc3VtIGRvbG9yIHNpdCBhbWV0IGNvbnNlY3RldHVyIGFkaXBpc2ljaW5nIGVsaXQuIFN1bnQgZWFydW0gcXVpYnVzZGFtIGRvbG9yIGhpYyBhY2N1c2FtdXMsIGRlc2VydW50IGxpYmVybz8gRGVsZW5pdGkgcmF0aW9uZSBsaWJlcm8sIGV2ZW5pZXQgbmVxdWUgYWxpcXVhbSByZXBlbGxhdCBkaWN0YSBvYmNhZWNhdGkgYXRxdWUsIHNlcXVpIHZvbHVwdGF0ZW0gZXhwbGljYWJvIGJlYXRhZSFcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIExvcmVtIGlwc3VtIGRvbG9yIHNpdCBhbWV0IGNvbnNlY3RldHVyIGFkaXBpc2ljaW5nIGVsaXQuIFZlcml0YXRpcyBhbmltaSB2ZWwgY3VwaWRpdGF0ZSBldmVuaWV0PyBMYXVkYW50aXVtIHJlY3VzYW5kYWUgaWxsbyBtaW51cyBzYWVwZSBpdGFxdWUgZG9sb3JlcyBmdWdpYXQsIHBlcmZlcmVuZGlzIG5vc3RydW0hIEFzc3VtZW5kYSBmdWdpYXQgZnVnYSBkZXNlcnVudCBvbW5pcyBvZGl0IGRpY3RhIVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgTG9yZW0gaXBzdW0gZG9sb3Igc2l0IGFtZXQgY29uc2VjdGV0dXIgYWRpcGlzaWNpbmcgZWxpdC4gTWludXMgYWNjdXNhbnRpdW0gYSBxdWlzcXVhbSBpbiByZXB1ZGlhbmRhZSBldCB1bGxhbSBjdW0gZGlnbmlzc2ltb3MgZXhlcmNpdGF0aW9uZW0sIGJsYW5kaXRpaXMgcGVyc3BpY2lhdGlzIGFsaWFzIGhpYyB2ZWwsIGxhdWRhbnRpdW0gYWxpcXVhbSBvbW5pcyByZWN1c2FuZGFlIG5lbW8gYW5pbWkuXHJcbiAgICAgICAgICAgICAgICAgICAgPC9EaWFsb2c+XHJcbiAgICAgICAgICAgICAgICA8L0NvZGU+XHJcbiAgICAgICAgICAgIDwvU2VjdGlvbj5cclxuICAgICAgICA8L1BhZ2U+XHJcbiAgICApO1xyXG59IiwiaW1wb3J0IHsgdXNlU3RhdGUgfSBmcm9tICdyZWFjdCc7XHJcbmltcG9ydCB7IEJ1dHRvbiwgRHJhd2VyIH0gZnJvbSAnbWRjLXJlYWN0JztcclxuXHJcbmltcG9ydCBQYWdlIGZyb20gJ0AvY29tcG9uZW50cy9QYWdlJztcclxuaW1wb3J0IFNlY3Rpb24gZnJvbSAnQC9jb21wb25lbnRzL1NlY3Rpb24nO1xyXG5pbXBvcnQgQ29kZSBmcm9tICdAL2NvbXBvbmVudHMvQ29kZSc7XHJcblxyXG5jb25zdCBpZCA9ICdkcmF3ZXInO1xyXG5jb25zdCB0aXRsZSA9ICdEcmF3ZXInO1xyXG5jb25zdCBkZXNjcmlwdGlvbiA9ICdOYXZpZ2F0aW9uIGRyYXdlcnMgcHJvdmlkZSBhY2Nlc3MgdG8gZGVzdGluYXRpb25zIGluIHlvdXIgYXBwLic7XHJcbmNvbnN0IGxpbmtzID0ge1xyXG4gICAgZG9jczogJ2h0dHBzOi8vZ2l0aHViLmNvbS9tYXRlcmlhbC1jb21wb25lbnRzL21hdGVyaWFsLWNvbXBvbmVudHMtd2ViL3RyZWUvbWFzdGVyL3BhY2thZ2VzL21kYy1kcmF3ZXInLFxyXG4gICAgZ3VpZGU6ICdodHRwczovL21hdGVyaWFsLmlvL2NvbXBvbmVudHMvbmF2aWdhdGlvbi1kcmF3ZXInXHJcbn07XHJcblxyXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBEcmF3ZXJQYWdlKCkge1xyXG4gICAgY29uc3QgW2lzRGlzbWlzc2libGVPcGVuLCBzZXREaXNtaXNzaWJsZU9wZW5dID0gdXNlU3RhdGUoZmFsc2UpO1xyXG4gICAgY29uc3QgW2lzTW9kYWxPcGVuLCBzZXRNb2RhbE9wZW5dID0gdXNlU3RhdGUoZmFsc2UpO1xyXG5cclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgPFBhZ2UgaWQ9e2lkfSB0aXRsZT17dGl0bGV9IGRlc2NyaXB0aW9uPXtkZXNjcmlwdGlvbn0gbGlua3M9e2xpbmtzfT5cclxuICAgICAgICAgICAgPFNlY3Rpb24gdGl0bGU9XCJQZXJtYW5lbnQgZHJhd2VyXCI+XHJcbiAgICAgICAgICAgICAgICA8Q29kZT5cclxuICAgICAgICAgICAgICAgICAgICA8RHJhd2VyPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8RHJhd2VyLkhlYWRlciB0aXRsZT1cIlRpdGxlXCIgLz5cclxuICAgICAgICAgICAgICAgICAgICA8L0RyYXdlcj5cclxuICAgICAgICAgICAgICAgIDwvQ29kZT5cclxuICAgICAgICAgICAgPC9TZWN0aW9uPlxyXG5cclxuICAgICAgICAgICAgPFNlY3Rpb24gdGl0bGU9XCJEaXNtaXNzaWJsZSBkcmF3ZXJcIj5cclxuICAgICAgICAgICAgICAgIDxDb2RlXHJcbiAgICAgICAgICAgICAgICAgICAgc2V0dXA9e1xyXG4gICAgICAgICAgICAgICAgICAgICAgICA8QnV0dG9uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYWJlbD1cIlRvZ2dsZVwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbkNsaWNrPXsoKSA9PiBzZXREaXNtaXNzaWJsZU9wZW4odiA9PiAhdil9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8+XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgPlxyXG4gICAgICAgICAgICAgICAgICAgIDxEcmF3ZXJcclxuICAgICAgICAgICAgICAgICAgICAgICAgb3Blbj17aXNEaXNtaXNzaWJsZU9wZW59XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpc21pc3NpYmxlXHJcbiAgICAgICAgICAgICAgICAgICAgPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8RHJhd2VyLkhlYWRlciB0aXRsZT1cIlRpdGxlXCIgLz5cclxuICAgICAgICAgICAgICAgICAgICA8L0RyYXdlcj5cclxuICAgICAgICAgICAgICAgIDwvQ29kZT5cclxuICAgICAgICAgICAgPC9TZWN0aW9uPlxyXG5cclxuICAgICAgICAgICAgPFNlY3Rpb24gdGl0bGU9XCJNb2RhbCBkcmF3ZXJcIj5cclxuICAgICAgICAgICAgICAgIDxDb2RlXHJcbiAgICAgICAgICAgICAgICAgICAgc2V0dXA9e1xyXG4gICAgICAgICAgICAgICAgICAgICAgICA8QnV0dG9uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYWJlbD1cIlRvZ2dsZVwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbkNsaWNrPXsoKSA9PiBzZXRNb2RhbE9wZW4odiA9PiAhdil9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8+XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgPlxyXG4gICAgICAgICAgICAgICAgICAgIDxEcmF3ZXJcclxuICAgICAgICAgICAgICAgICAgICAgICAgb3Blbj17aXNNb2RhbE9wZW59XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2xvc2U9eygpID0+IHNldE1vZGFsT3Blbih2ID0+ICF2KX1cclxuICAgICAgICAgICAgICAgICAgICAgICAgbW9kYWxcclxuICAgICAgICAgICAgICAgICAgICA+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxEcmF3ZXIuSGVhZGVyIHRpdGxlPVwiVGl0bGVcIiAvPlxyXG4gICAgICAgICAgICAgICAgICAgIDwvRHJhd2VyPlxyXG4gICAgICAgICAgICAgICAgPC9Db2RlPlxyXG4gICAgICAgICAgICA8L1NlY3Rpb24+XHJcbiAgICAgICAgPC9QYWdlPlxyXG4gICAgKTtcclxufSIsImltcG9ydCB7IEVsZXZhdGlvbiwgU2xpZGVyIH0gZnJvbSAnbWRjLXJlYWN0JztcclxuXHJcbmltcG9ydCBQYWdlIGZyb20gJ0AvY29tcG9uZW50cy9QYWdlJztcclxuaW1wb3J0IFNlY3Rpb24gZnJvbSAnQC9jb21wb25lbnRzL1NlY3Rpb24nO1xyXG5pbXBvcnQgQ29kZSBmcm9tICdAL2NvbXBvbmVudHMvQ29kZSc7XHJcbmltcG9ydCB7IHVzZUNhbGxiYWNrLCB1c2VTdGF0ZSB9IGZyb20gJ3JlYWN0JztcclxuXHJcbmltcG9ydCAnLi9pbmRleC5zY3NzJztcclxuXHJcbmNvbnN0IGlkID0gJ2VsZXZhdGlvbic7XHJcbmNvbnN0IHRpdGxlID0gJ0VsZXZhdGlvbic7XHJcbmNvbnN0IGRlc2NyaXB0aW9uID0gJ0VsZXZhdGlvbiBpcyB0aGUgcmVsYXRpdmUgZGlzdGFuY2UgYmV0d2VlbiB0d28gc3VyZmFjZXMgYWxvbmcgdGhlIHotYXhpcy4nO1xyXG5jb25zdCBsaW5rcyA9IHtcclxuICAgIGRvY3M6ICdodHRwczovL2dpdGh1Yi5jb20vbWF0ZXJpYWwtY29tcG9uZW50cy9tYXRlcmlhbC1jb21wb25lbnRzLXdlYi90cmVlL21hc3Rlci9wYWNrYWdlcy9tZGMtZWxldmF0aW9uJyxcclxuICAgIGd1aWRlOiAnaHR0cHM6Ly9tYXRlcmlhbC5pby9kZXNpZ24vZW52aXJvbm1lbnQvZWxldmF0aW9uJ1xyXG59O1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gRWxldmF0aW9uUGFnZSgpIHtcclxuICAgIGNvbnN0IFt6LCBzZXRaXSA9IHVzZVN0YXRlKDApO1xyXG5cclxuICAgIGNvbnN0IGhhbmRsZUNoYW5nZSA9IHVzZUNhbGxiYWNrKHZhbHVlID0+IHtcclxuICAgICAgICBzZXRaKHZhbHVlKTtcclxuICAgIH0sIFtdKTtcclxuXHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAgIDxQYWdlIGlkPXtpZH0gdGl0bGU9e3RpdGxlfSBkZXNjcmlwdGlvbj17ZGVzY3JpcHRpb259IGxpbmtzPXtsaW5rc30+XHJcbiAgICAgICAgICAgIDxTZWN0aW9uPlxyXG4gICAgICAgICAgICAgICAgPENvZGVcclxuICAgICAgICAgICAgICAgICAgICBzZXR1cD17XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxTbGlkZXJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlPXt6fVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWluPVwiMFwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXg9XCIyNFwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGVwPVwiMVwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXNjcmV0ZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGlja01hcmtzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbkNoYW5nZT17aGFuZGxlQ2hhbmdlfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvPlxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgID5cclxuICAgICAgICAgICAgICAgICAgICA8RWxldmF0aW9uIHo9e3p9IC8+XHJcbiAgICAgICAgICAgICAgICA8L0NvZGU+XHJcbiAgICAgICAgICAgIDwvU2VjdGlvbj5cclxuICAgICAgICA8L1BhZ2U+XHJcbiAgICApO1xyXG59IiwiaW1wb3J0IHsgdXNlU3RhdGUgfSBmcm9tICdyZWFjdCc7XHJcbmltcG9ydCB7IEJ1dHRvbiwgRkFCIH0gZnJvbSAnbWRjLXJlYWN0JztcclxuXHJcbmltcG9ydCBQYWdlIGZyb20gJ0AvY29tcG9uZW50cy9QYWdlJztcclxuaW1wb3J0IFNlY3Rpb24gZnJvbSAnQC9jb21wb25lbnRzL1NlY3Rpb24nO1xyXG5pbXBvcnQgQ29kZSBmcm9tICdAL2NvbXBvbmVudHMvQ29kZSc7XHJcblxyXG5jb25zdCBpZCA9ICdmYWInO1xyXG5jb25zdCB0aXRsZSA9ICdGQUInO1xyXG5jb25zdCBkZXNjcmlwdGlvbiA9ICdBIGZsb2F0aW5nIGFjdGlvbiBidXR0b24gKEZBQikgcmVwcmVzZW50cyB0aGUgcHJpbWFyeSBhY3Rpb24gb2YgYSBzY3JlZW4uJztcclxuY29uc3QgbGlua3MgPSB7XHJcbiAgICBkb2NzOiAnaHR0cHM6Ly9naXRodWIuY29tL21hdGVyaWFsLWNvbXBvbmVudHMvbWF0ZXJpYWwtY29tcG9uZW50cy13ZWIvdHJlZS9tYXN0ZXIvcGFja2FnZXMvbWRjLWZhYicsXHJcbiAgICBndWlkZTogJ2h0dHBzOi8vbWF0ZXJpYWwuaW8vY29tcG9uZW50cy9idXR0b25zLWZsb2F0aW5nLWFjdGlvbi1idXR0b24nXHJcbn07XHJcblxyXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBGQUJQYWdlKCkge1xyXG4gICAgY29uc3QgW2lzRXhpdGVkLCBzZXRFeGl0ZWRdID0gdXNlU3RhdGUoZmFsc2UpO1xyXG5cclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgPFBhZ2UgaWQ9e2lkfSB0aXRsZT17dGl0bGV9IGRlc2NyaXB0aW9uPXtkZXNjcmlwdGlvbn0gbGlua3M9e2xpbmtzfT5cclxuICAgICAgICAgICAgPFNlY3Rpb24gdGl0bGU9XCJCYXNpYyBGQUJcIj5cclxuICAgICAgICAgICAgICAgIDxDb2RlPlxyXG4gICAgICAgICAgICAgICAgICAgIDxGQUJcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWNvbj1cInN0YXJcIlxyXG4gICAgICAgICAgICAgICAgICAgIC8+XHJcbiAgICAgICAgICAgICAgICA8L0NvZGU+XHJcbiAgICAgICAgICAgIDwvU2VjdGlvbj5cclxuXHJcbiAgICAgICAgICAgIDxTZWN0aW9uIHRpdGxlPVwiTWluaSBGQUJcIj5cclxuICAgICAgICAgICAgICAgIDxDb2RlPlxyXG4gICAgICAgICAgICAgICAgICAgIDxGQUJcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWNvbj1cInN0YXJcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBtaW5pXHJcbiAgICAgICAgICAgICAgICAgICAgLz5cclxuICAgICAgICAgICAgICAgIDwvQ29kZT5cclxuICAgICAgICAgICAgPC9TZWN0aW9uPlxyXG5cclxuICAgICAgICAgICAgPFNlY3Rpb24gdGl0bGU9XCJFeHRlbmRlZCBGQUJcIj5cclxuICAgICAgICAgICAgICAgIDxDb2RlPlxyXG4gICAgICAgICAgICAgICAgICAgIDxGQUJcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWNvbj1cInN0YXJcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBsYWJlbD1cIlN0YXJcIlxyXG4gICAgICAgICAgICAgICAgICAgIC8+XHJcbiAgICAgICAgICAgICAgICA8L0NvZGU+XHJcbiAgICAgICAgICAgIDwvU2VjdGlvbj5cclxuXHJcbiAgICAgICAgICAgIDxTZWN0aW9uIHRpdGxlPVwiRXh0ZW5kZWQgRkFCIHdpdGggYSB0cmFpbGluZyBpY29uXCI+XHJcbiAgICAgICAgICAgICAgICA8Q29kZT5cclxuICAgICAgICAgICAgICAgICAgICA8RkFCXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsPVwiU3RhclwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYWlsaW5nSWNvbj1cInN0YXJcIlxyXG4gICAgICAgICAgICAgICAgICAgIC8+XHJcbiAgICAgICAgICAgICAgICA8L0NvZGU+XHJcbiAgICAgICAgICAgIDwvU2VjdGlvbj5cclxuXHJcbiAgICAgICAgICAgIDxTZWN0aW9uIHRpdGxlPVwiQW5pbWF0ZWQgRkFCXCI+XHJcbiAgICAgICAgICAgICAgICA8Q29kZVxyXG4gICAgICAgICAgICAgICAgICAgIHNldHVwPXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgPEJ1dHRvblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWw9XCJUb2dnbGVcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb25DbGljaz17KCkgPT4gc2V0RXhpdGVkKHYgPT4gIXYpfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvPlxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgID5cclxuICAgICAgICAgICAgICAgICAgICA8RkFCXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGljb249XCJzdGFyXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgZXhpdGVkPXtpc0V4aXRlZH1cclxuICAgICAgICAgICAgICAgICAgICAvPlxyXG4gICAgICAgICAgICAgICAgPC9Db2RlPlxyXG4gICAgICAgICAgICA8L1NlY3Rpb24+XHJcbiAgICAgICAgPC9QYWdlPlxyXG4gICAgKTtcclxufSIsImltcG9ydCB7XHJcbiAgICBDaGVja2JveCxcclxuICAgIEZvcm1GaWVsZFxyXG59IGZyb20gJ21kYy1yZWFjdCc7XHJcblxyXG5pbXBvcnQgUGFnZSBmcm9tICdAL2NvbXBvbmVudHMvUGFnZSc7XHJcbmltcG9ydCBTZWN0aW9uIGZyb20gJ0AvY29tcG9uZW50cy9TZWN0aW9uJztcclxuaW1wb3J0IENvZGUgZnJvbSAnQC9jb21wb25lbnRzL0NvZGUnO1xyXG5cclxuaW1wb3J0ICcuL2luZGV4LnNjc3MnO1xyXG5cclxuY29uc3QgaWQgPSAnZm9ybS1maWVsZCc7XHJcbmNvbnN0IHRpdGxlID0gJ0Zvcm0gRmllbGQnO1xyXG5jb25zdCBkZXNjcmlwdGlvbiA9ICdGb3JtIEZpZWxkIGFsaWducyBhIGZvcm0gZmllbGQgKGZvciBleGFtcGxlLCBhIGNoZWNrYm94KSB3aXRoIGl0cyBsYWJlbCBhbmQgbWFrZXMgaXQgUlRMLWF3YXJlLic7XHJcbmNvbnN0IGxpbmtzID0ge1xyXG4gICAgZG9jczogJ2h0dHBzOi8vZ2l0aHViLmNvbS9tYXRlcmlhbC1jb21wb25lbnRzL21hdGVyaWFsLWNvbXBvbmVudHMtd2ViL3RyZWUvbWFzdGVyL3BhY2thZ2VzL21kYy1mb3JtLWZpZWxkJ1xyXG59O1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gRm9ybUZpZWxkUGFnZSgpIHtcclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgPFBhZ2UgaWQ9e2lkfSB0aXRsZT17dGl0bGV9IGRlc2NyaXB0aW9uPXtkZXNjcmlwdGlvbn0gbGlua3M9e2xpbmtzfT5cclxuICAgICAgICAgICAgPFNlY3Rpb24gdGl0bGU9XCJCYXNpYyBmb3JtIGZpZWxkXCI+XHJcbiAgICAgICAgICAgICAgICA8Q29kZT5cclxuICAgICAgICAgICAgICAgICAgICA8Rm9ybUZpZWxkIGxhYmVsPVwiTGFiZWxcIj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPENoZWNrYm94IC8+XHJcbiAgICAgICAgICAgICAgICAgICAgPC9Gb3JtRmllbGQ+XHJcbiAgICAgICAgICAgICAgICA8L0NvZGU+XHJcbiAgICAgICAgICAgIDwvU2VjdGlvbj5cclxuXHJcbiAgICAgICAgICAgIDxTZWN0aW9uIHRpdGxlPVwiRm9ybSBmaWVsZCB0aGF0IGdvZXMgYmVmb3JlIHRoZSBlbGVtZW50XCI+XHJcbiAgICAgICAgICAgICAgICA8Q29kZT5cclxuICAgICAgICAgICAgICAgICAgICA8Rm9ybUZpZWxkIGxhYmVsPVwiTGFiZWxcIiBhbGlnbkVuZD5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPENoZWNrYm94IC8+XHJcbiAgICAgICAgICAgICAgICAgICAgPC9Gb3JtRmllbGQ+XHJcbiAgICAgICAgICAgICAgICA8L0NvZGU+XHJcbiAgICAgICAgICAgIDwvU2VjdGlvbj5cclxuXHJcbiAgICAgICAgICAgIDxTZWN0aW9uIHRpdGxlPVwiTm8gd3JhcCBmb3JtIGZpZWxkXCI+XHJcbiAgICAgICAgICAgICAgICA8Q29kZT5cclxuICAgICAgICAgICAgICAgICAgICA8Rm9ybUZpZWxkIGxhYmVsPVwiTGFiZWxcIiBub3dyYXA+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxDaGVja2JveCAvPlxyXG4gICAgICAgICAgICAgICAgICAgIDwvRm9ybUZpZWxkPlxyXG4gICAgICAgICAgICAgICAgPC9Db2RlPlxyXG4gICAgICAgICAgICA8L1NlY3Rpb24+XHJcblxyXG4gICAgICAgICAgICA8U2VjdGlvbiB0aXRsZT1cIkZvcm0gZmllbGQgd2l0aCBzcGFjZSBiZXR3ZWVuXCI+XHJcbiAgICAgICAgICAgICAgICA8Q29kZT5cclxuICAgICAgICAgICAgICAgICAgICA8Rm9ybUZpZWxkIGxhYmVsPVwiTGFiZWxcIiBzcGFjZUJldHdlZW4+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxDaGVja2JveCAvPlxyXG4gICAgICAgICAgICAgICAgICAgIDwvRm9ybUZpZWxkPlxyXG4gICAgICAgICAgICAgICAgPC9Db2RlPlxyXG4gICAgICAgICAgICA8L1NlY3Rpb24+XHJcbiAgICAgICAgPC9QYWdlPlxyXG4gICAgKTtcclxufSIsIi8vIGh0dHBzOi8vbm9kZWpzLm9yZy9hcGkvcGFja2FnZXMuaHRtbCNwYWNrYWdlc193cml0aW5nX2R1YWxfcGFja2FnZXNfd2hpbGVfYXZvaWRpbmdfb3JfbWluaW1pemluZ19oYXphcmRzXG5pbXBvcnQgaGxqcyBmcm9tICcuLi9saWIvY29yZS5qcyc7XG5leHBvcnQgZGVmYXVsdCBobGpzO1xuIiwiY29uc3QgSURFTlRfUkUgPSAnW0EtWmEteiRfXVswLTlBLVphLXokX10qJztcbmNvbnN0IEtFWVdPUkRTID0gW1xuICBcImFzXCIsIC8vIGZvciBleHBvcnRzXG4gIFwiaW5cIixcbiAgXCJvZlwiLFxuICBcImlmXCIsXG4gIFwiZm9yXCIsXG4gIFwid2hpbGVcIixcbiAgXCJmaW5hbGx5XCIsXG4gIFwidmFyXCIsXG4gIFwibmV3XCIsXG4gIFwiZnVuY3Rpb25cIixcbiAgXCJkb1wiLFxuICBcInJldHVyblwiLFxuICBcInZvaWRcIixcbiAgXCJlbHNlXCIsXG4gIFwiYnJlYWtcIixcbiAgXCJjYXRjaFwiLFxuICBcImluc3RhbmNlb2ZcIixcbiAgXCJ3aXRoXCIsXG4gIFwidGhyb3dcIixcbiAgXCJjYXNlXCIsXG4gIFwiZGVmYXVsdFwiLFxuICBcInRyeVwiLFxuICBcInN3aXRjaFwiLFxuICBcImNvbnRpbnVlXCIsXG4gIFwidHlwZW9mXCIsXG4gIFwiZGVsZXRlXCIsXG4gIFwibGV0XCIsXG4gIFwieWllbGRcIixcbiAgXCJjb25zdFwiLFxuICBcImNsYXNzXCIsXG4gIC8vIEpTIGhhbmRsZXMgdGhlc2Ugd2l0aCBhIHNwZWNpYWwgcnVsZVxuICAvLyBcImdldFwiLFxuICAvLyBcInNldFwiLFxuICBcImRlYnVnZ2VyXCIsXG4gIFwiYXN5bmNcIixcbiAgXCJhd2FpdFwiLFxuICBcInN0YXRpY1wiLFxuICBcImltcG9ydFwiLFxuICBcImZyb21cIixcbiAgXCJleHBvcnRcIixcbiAgXCJleHRlbmRzXCJcbl07XG5jb25zdCBMSVRFUkFMUyA9IFtcbiAgXCJ0cnVlXCIsXG4gIFwiZmFsc2VcIixcbiAgXCJudWxsXCIsXG4gIFwidW5kZWZpbmVkXCIsXG4gIFwiTmFOXCIsXG4gIFwiSW5maW5pdHlcIlxuXTtcblxuY29uc3QgVFlQRVMgPSBbXG4gIFwiSW50bFwiLFxuICBcIkRhdGFWaWV3XCIsXG4gIFwiTnVtYmVyXCIsXG4gIFwiTWF0aFwiLFxuICBcIkRhdGVcIixcbiAgXCJTdHJpbmdcIixcbiAgXCJSZWdFeHBcIixcbiAgXCJPYmplY3RcIixcbiAgXCJGdW5jdGlvblwiLFxuICBcIkJvb2xlYW5cIixcbiAgXCJFcnJvclwiLFxuICBcIlN5bWJvbFwiLFxuICBcIlNldFwiLFxuICBcIk1hcFwiLFxuICBcIldlYWtTZXRcIixcbiAgXCJXZWFrTWFwXCIsXG4gIFwiUHJveHlcIixcbiAgXCJSZWZsZWN0XCIsXG4gIFwiSlNPTlwiLFxuICBcIlByb21pc2VcIixcbiAgXCJGbG9hdDY0QXJyYXlcIixcbiAgXCJJbnQxNkFycmF5XCIsXG4gIFwiSW50MzJBcnJheVwiLFxuICBcIkludDhBcnJheVwiLFxuICBcIlVpbnQxNkFycmF5XCIsXG4gIFwiVWludDMyQXJyYXlcIixcbiAgXCJGbG9hdDMyQXJyYXlcIixcbiAgXCJBcnJheVwiLFxuICBcIlVpbnQ4QXJyYXlcIixcbiAgXCJVaW50OENsYW1wZWRBcnJheVwiLFxuICBcIkFycmF5QnVmZmVyXCIsXG4gIFwiQmlnSW50NjRBcnJheVwiLFxuICBcIkJpZ1VpbnQ2NEFycmF5XCIsXG4gIFwiQmlnSW50XCJcbl07XG5cbmNvbnN0IEVSUk9SX1RZUEVTID0gW1xuICBcIkV2YWxFcnJvclwiLFxuICBcIkludGVybmFsRXJyb3JcIixcbiAgXCJSYW5nZUVycm9yXCIsXG4gIFwiUmVmZXJlbmNlRXJyb3JcIixcbiAgXCJTeW50YXhFcnJvclwiLFxuICBcIlR5cGVFcnJvclwiLFxuICBcIlVSSUVycm9yXCJcbl07XG5cbmNvbnN0IEJVSUxUX0lOX0dMT0JBTFMgPSBbXG4gIFwic2V0SW50ZXJ2YWxcIixcbiAgXCJzZXRUaW1lb3V0XCIsXG4gIFwiY2xlYXJJbnRlcnZhbFwiLFxuICBcImNsZWFyVGltZW91dFwiLFxuXG4gIFwicmVxdWlyZVwiLFxuICBcImV4cG9ydHNcIixcblxuICBcImV2YWxcIixcbiAgXCJpc0Zpbml0ZVwiLFxuICBcImlzTmFOXCIsXG4gIFwicGFyc2VGbG9hdFwiLFxuICBcInBhcnNlSW50XCIsXG4gIFwiZGVjb2RlVVJJXCIsXG4gIFwiZGVjb2RlVVJJQ29tcG9uZW50XCIsXG4gIFwiZW5jb2RlVVJJXCIsXG4gIFwiZW5jb2RlVVJJQ29tcG9uZW50XCIsXG4gIFwiZXNjYXBlXCIsXG4gIFwidW5lc2NhcGVcIlxuXTtcblxuY29uc3QgQlVJTFRfSU5fVkFSSUFCTEVTID0gW1xuICBcImFyZ3VtZW50c1wiLFxuICBcInRoaXNcIixcbiAgXCJzdXBlclwiLFxuICBcImNvbnNvbGVcIixcbiAgXCJ3aW5kb3dcIixcbiAgXCJkb2N1bWVudFwiLFxuICBcImxvY2FsU3RvcmFnZVwiLFxuICBcIm1vZHVsZVwiLFxuICBcImdsb2JhbFwiIC8vIE5vZGUuanNcbl07XG5cbmNvbnN0IEJVSUxUX0lOUyA9IFtdLmNvbmNhdChcbiAgQlVJTFRfSU5fR0xPQkFMUyxcbiAgVFlQRVMsXG4gIEVSUk9SX1RZUEVTXG4pO1xuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZVxuICogQHJldHVybnMge1JlZ0V4cH1cbiAqICovXG5cbi8qKlxuICogQHBhcmFtIHtSZWdFeHAgfCBzdHJpbmcgfSByZVxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gc291cmNlKHJlKSB7XG4gIGlmICghcmUpIHJldHVybiBudWxsO1xuICBpZiAodHlwZW9mIHJlID09PSBcInN0cmluZ1wiKSByZXR1cm4gcmU7XG5cbiAgcmV0dXJuIHJlLnNvdXJjZTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge1JlZ0V4cCB8IHN0cmluZyB9IHJlXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBsb29rYWhlYWQocmUpIHtcbiAgcmV0dXJuIGNvbmNhdCgnKD89JywgcmUsICcpJyk7XG59XG5cbi8qKlxuICogQHBhcmFtIHsuLi4oUmVnRXhwIHwgc3RyaW5nKSB9IGFyZ3NcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGNvbmNhdCguLi5hcmdzKSB7XG4gIGNvbnN0IGpvaW5lZCA9IGFyZ3MubWFwKCh4KSA9PiBzb3VyY2UoeCkpLmpvaW4oXCJcIik7XG4gIHJldHVybiBqb2luZWQ7XG59XG5cbi8qXG5MYW5ndWFnZTogSmF2YVNjcmlwdFxuRGVzY3JpcHRpb246IEphdmFTY3JpcHQgKEpTKSBpcyBhIGxpZ2h0d2VpZ2h0LCBpbnRlcnByZXRlZCwgb3IganVzdC1pbi10aW1lIGNvbXBpbGVkIHByb2dyYW1taW5nIGxhbmd1YWdlIHdpdGggZmlyc3QtY2xhc3MgZnVuY3Rpb25zLlxuQ2F0ZWdvcnk6IGNvbW1vbiwgc2NyaXB0aW5nLCB3ZWJcbldlYnNpdGU6IGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHRcbiovXG5cbi8qKiBAdHlwZSBMYW5ndWFnZUZuICovXG5mdW5jdGlvbiBqYXZhc2NyaXB0KGhsanMpIHtcbiAgLyoqXG4gICAqIFRha2VzIGEgc3RyaW5nIGxpa2UgXCI8Qm9vZ2VyXCIgYW5kIGNoZWNrcyB0byBzZWVcbiAgICogaWYgd2UgY2FuIGZpbmQgYSBtYXRjaGluZyBcIjwvQm9vZ2VyXCIgbGF0ZXIgaW4gdGhlXG4gICAqIGNvbnRlbnQuXG4gICAqIEBwYXJhbSB7UmVnRXhwTWF0Y2hBcnJheX0gbWF0Y2hcbiAgICogQHBhcmFtIHt7YWZ0ZXI6bnVtYmVyfX0gcGFyYW0xXG4gICAqL1xuICBjb25zdCBoYXNDbG9zaW5nVGFnID0gKG1hdGNoLCB7IGFmdGVyIH0pID0+IHtcbiAgICBjb25zdCB0YWcgPSBcIjwvXCIgKyBtYXRjaFswXS5zbGljZSgxKTtcbiAgICBjb25zdCBwb3MgPSBtYXRjaC5pbnB1dC5pbmRleE9mKHRhZywgYWZ0ZXIpO1xuICAgIHJldHVybiBwb3MgIT09IC0xO1xuICB9O1xuXG4gIGNvbnN0IElERU5UX1JFJDEgPSBJREVOVF9SRTtcbiAgY29uc3QgRlJBR01FTlQgPSB7XG4gICAgYmVnaW46ICc8PicsXG4gICAgZW5kOiAnPC8+J1xuICB9O1xuICBjb25zdCBYTUxfVEFHID0ge1xuICAgIGJlZ2luOiAvPFtBLVphLXowLTlcXFxcLl86LV0rLyxcbiAgICBlbmQ6IC9cXC9bQS1aYS16MC05XFxcXC5fOi1dKz58XFwvPi8sXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtSZWdFeHBNYXRjaEFycmF5fSBtYXRjaFxuICAgICAqIEBwYXJhbSB7Q2FsbGJhY2tSZXNwb25zZX0gcmVzcG9uc2VcbiAgICAgKi9cbiAgICBpc1RydWx5T3BlbmluZ1RhZzogKG1hdGNoLCByZXNwb25zZSkgPT4ge1xuICAgICAgY29uc3QgYWZ0ZXJNYXRjaEluZGV4ID0gbWF0Y2hbMF0ubGVuZ3RoICsgbWF0Y2guaW5kZXg7XG4gICAgICBjb25zdCBuZXh0Q2hhciA9IG1hdGNoLmlucHV0W2FmdGVyTWF0Y2hJbmRleF07XG4gICAgICAvLyBuZXN0ZWQgdHlwZT9cbiAgICAgIC8vIEhUTUwgc2hvdWxkIG5vdCBpbmNsdWRlIGFub3RoZXIgcmF3IGA8YCBpbnNpZGUgYSB0YWdcbiAgICAgIC8vIEJ1dCBhIHR5cGUgbWlnaHQ6IGA8QXJyYXk8QXJyYXk8bnVtYmVyPj5gLCBldGMuXG4gICAgICBpZiAobmV4dENoYXIgPT09IFwiPFwiKSB7XG4gICAgICAgIHJlc3BvbnNlLmlnbm9yZU1hdGNoKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIC8vIDxzb21ldGhpbmc+XG4gICAgICAvLyBUaGlzIGlzIG5vdyBlaXRoZXIgYSB0YWcgb3IgYSB0eXBlLlxuICAgICAgaWYgKG5leHRDaGFyID09PSBcIj5cIikge1xuICAgICAgICAvLyBpZiB3ZSBjYW5ub3QgZmluZCBhIG1hdGNoaW5nIGNsb3NpbmcgdGFnLCB0aGVuIHdlXG4gICAgICAgIC8vIHdpbGwgaWdub3JlIGl0XG4gICAgICAgIGlmICghaGFzQ2xvc2luZ1RhZyhtYXRjaCwgeyBhZnRlcjogYWZ0ZXJNYXRjaEluZGV4IH0pKSB7XG4gICAgICAgICAgcmVzcG9uc2UuaWdub3JlTWF0Y2goKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgY29uc3QgS0VZV09SRFMkMSA9IHtcbiAgICAkcGF0dGVybjogSURFTlRfUkUsXG4gICAga2V5d29yZDogS0VZV09SRFMsXG4gICAgbGl0ZXJhbDogTElURVJBTFMsXG4gICAgYnVpbHRfaW46IEJVSUxUX0lOUyxcbiAgICBcInZhcmlhYmxlLmxhbmd1YWdlXCI6IEJVSUxUX0lOX1ZBUklBQkxFU1xuICB9O1xuXG4gIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtbGl0ZXJhbHMtbnVtZXJpYy1saXRlcmFsc1xuICBjb25zdCBkZWNpbWFsRGlnaXRzID0gJ1swLTldKF8/WzAtOV0pKic7XG4gIGNvbnN0IGZyYWMgPSBgXFxcXC4oJHtkZWNpbWFsRGlnaXRzfSlgO1xuICAvLyBEZWNpbWFsSW50ZWdlckxpdGVyYWwsIGluY2x1ZGluZyBBbm5leCBCIE5vbk9jdGFsRGVjaW1hbEludGVnZXJMaXRlcmFsXG4gIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYWRkaXRpb25hbC1zeW50YXgtbnVtZXJpYy1saXRlcmFsc1xuICBjb25zdCBkZWNpbWFsSW50ZWdlciA9IGAwfFsxLTldKF8/WzAtOV0pKnwwWzAtN10qWzg5XVswLTldKmA7XG4gIGNvbnN0IE5VTUJFUiA9IHtcbiAgICBjbGFzc05hbWU6ICdudW1iZXInLFxuICAgIHZhcmlhbnRzOiBbXG4gICAgICAvLyBEZWNpbWFsTGl0ZXJhbFxuICAgICAgeyBiZWdpbjogYChcXFxcYigke2RlY2ltYWxJbnRlZ2VyfSkoKCR7ZnJhY30pfFxcXFwuKT98KCR7ZnJhY30pKWAgK1xuICAgICAgICBgW2VFXVsrLV0/KCR7ZGVjaW1hbERpZ2l0c30pXFxcXGJgIH0sXG4gICAgICB7IGJlZ2luOiBgXFxcXGIoJHtkZWNpbWFsSW50ZWdlcn0pXFxcXGIoKCR7ZnJhY30pXFxcXGJ8XFxcXC4pP3woJHtmcmFjfSlcXFxcYmAgfSxcblxuICAgICAgLy8gRGVjaW1hbEJpZ0ludGVnZXJMaXRlcmFsXG4gICAgICB7IGJlZ2luOiBgXFxcXGIoMHxbMS05XShfP1swLTldKSopblxcXFxiYCB9LFxuXG4gICAgICAvLyBOb25EZWNpbWFsSW50ZWdlckxpdGVyYWxcbiAgICAgIHsgYmVnaW46IFwiXFxcXGIwW3hYXVswLTlhLWZBLUZdKF8/WzAtOWEtZkEtRl0pKm4/XFxcXGJcIiB9LFxuICAgICAgeyBiZWdpbjogXCJcXFxcYjBbYkJdWzAtMV0oXz9bMC0xXSkqbj9cXFxcYlwiIH0sXG4gICAgICB7IGJlZ2luOiBcIlxcXFxiMFtvT11bMC03XShfP1swLTddKSpuP1xcXFxiXCIgfSxcblxuICAgICAgLy8gTGVnYWN5T2N0YWxJbnRlZ2VyTGl0ZXJhbCAoZG9lcyBub3QgaW5jbHVkZSB1bmRlcnNjb3JlIHNlcGFyYXRvcnMpXG4gICAgICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFkZGl0aW9uYWwtc3ludGF4LW51bWVyaWMtbGl0ZXJhbHNcbiAgICAgIHsgYmVnaW46IFwiXFxcXGIwWzAtN10rbj9cXFxcYlwiIH0sXG4gICAgXSxcbiAgICByZWxldmFuY2U6IDBcbiAgfTtcblxuICBjb25zdCBTVUJTVCA9IHtcbiAgICBjbGFzc05hbWU6ICdzdWJzdCcsXG4gICAgYmVnaW46ICdcXFxcJFxcXFx7JyxcbiAgICBlbmQ6ICdcXFxcfScsXG4gICAga2V5d29yZHM6IEtFWVdPUkRTJDEsXG4gICAgY29udGFpbnM6IFtdIC8vIGRlZmluZWQgbGF0ZXJcbiAgfTtcbiAgY29uc3QgSFRNTF9URU1QTEFURSA9IHtcbiAgICBiZWdpbjogJ2h0bWxgJyxcbiAgICBlbmQ6ICcnLFxuICAgIHN0YXJ0czoge1xuICAgICAgZW5kOiAnYCcsXG4gICAgICByZXR1cm5FbmQ6IGZhbHNlLFxuICAgICAgY29udGFpbnM6IFtcbiAgICAgICAgaGxqcy5CQUNLU0xBU0hfRVNDQVBFLFxuICAgICAgICBTVUJTVFxuICAgICAgXSxcbiAgICAgIHN1Ykxhbmd1YWdlOiAneG1sJ1xuICAgIH1cbiAgfTtcbiAgY29uc3QgQ1NTX1RFTVBMQVRFID0ge1xuICAgIGJlZ2luOiAnY3NzYCcsXG4gICAgZW5kOiAnJyxcbiAgICBzdGFydHM6IHtcbiAgICAgIGVuZDogJ2AnLFxuICAgICAgcmV0dXJuRW5kOiBmYWxzZSxcbiAgICAgIGNvbnRhaW5zOiBbXG4gICAgICAgIGhsanMuQkFDS1NMQVNIX0VTQ0FQRSxcbiAgICAgICAgU1VCU1RcbiAgICAgIF0sXG4gICAgICBzdWJMYW5ndWFnZTogJ2NzcydcbiAgICB9XG4gIH07XG4gIGNvbnN0IFRFTVBMQVRFX1NUUklORyA9IHtcbiAgICBjbGFzc05hbWU6ICdzdHJpbmcnLFxuICAgIGJlZ2luOiAnYCcsXG4gICAgZW5kOiAnYCcsXG4gICAgY29udGFpbnM6IFtcbiAgICAgIGhsanMuQkFDS1NMQVNIX0VTQ0FQRSxcbiAgICAgIFNVQlNUXG4gICAgXVxuICB9O1xuICBjb25zdCBKU0RPQ19DT01NRU5UID0gaGxqcy5DT01NRU5UKFxuICAgIC9cXC9cXCpcXCooPyFcXC8pLyxcbiAgICAnXFxcXCovJyxcbiAgICB7XG4gICAgICByZWxldmFuY2U6IDAsXG4gICAgICBjb250YWluczogW1xuICAgICAgICB7XG4gICAgICAgICAgYmVnaW46ICcoPz1AW0EtWmEtel0rKScsXG4gICAgICAgICAgcmVsZXZhbmNlOiAwLFxuICAgICAgICAgIGNvbnRhaW5zOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGNsYXNzTmFtZTogJ2RvY3RhZycsXG4gICAgICAgICAgICAgIGJlZ2luOiAnQFtBLVphLXpdKydcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGNsYXNzTmFtZTogJ3R5cGUnLFxuICAgICAgICAgICAgICBiZWdpbjogJ1xcXFx7JyxcbiAgICAgICAgICAgICAgZW5kOiAnXFxcXH0nLFxuICAgICAgICAgICAgICBleGNsdWRlRW5kOiB0cnVlLFxuICAgICAgICAgICAgICBleGNsdWRlQmVnaW46IHRydWUsXG4gICAgICAgICAgICAgIHJlbGV2YW5jZTogMFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgY2xhc3NOYW1lOiAndmFyaWFibGUnLFxuICAgICAgICAgICAgICBiZWdpbjogSURFTlRfUkUkMSArICcoPz1cXFxccyooLSl8JCknLFxuICAgICAgICAgICAgICBlbmRzUGFyZW50OiB0cnVlLFxuICAgICAgICAgICAgICByZWxldmFuY2U6IDBcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAvLyBlYXQgc3BhY2VzIChub3QgbmV3bGluZXMpIHNvIHdlIGNhbiBmaW5kXG4gICAgICAgICAgICAvLyB0eXBlcyBvciB2YXJpYWJsZXNcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgYmVnaW46IC8oPz1bXlxcbl0pXFxzLyxcbiAgICAgICAgICAgICAgcmVsZXZhbmNlOiAwXG4gICAgICAgICAgICB9XG4gICAgICAgICAgXVxuICAgICAgICB9XG4gICAgICBdXG4gICAgfVxuICApO1xuICBjb25zdCBDT01NRU5UID0ge1xuICAgIGNsYXNzTmFtZTogXCJjb21tZW50XCIsXG4gICAgdmFyaWFudHM6IFtcbiAgICAgIEpTRE9DX0NPTU1FTlQsXG4gICAgICBobGpzLkNfQkxPQ0tfQ09NTUVOVF9NT0RFLFxuICAgICAgaGxqcy5DX0xJTkVfQ09NTUVOVF9NT0RFXG4gICAgXVxuICB9O1xuICBjb25zdCBTVUJTVF9JTlRFUk5BTFMgPSBbXG4gICAgaGxqcy5BUE9TX1NUUklOR19NT0RFLFxuICAgIGhsanMuUVVPVEVfU1RSSU5HX01PREUsXG4gICAgSFRNTF9URU1QTEFURSxcbiAgICBDU1NfVEVNUExBVEUsXG4gICAgVEVNUExBVEVfU1RSSU5HLFxuICAgIE5VTUJFUixcbiAgICBobGpzLlJFR0VYUF9NT0RFXG4gIF07XG4gIFNVQlNULmNvbnRhaW5zID0gU1VCU1RfSU5URVJOQUxTXG4gICAgLmNvbmNhdCh7XG4gICAgICAvLyB3ZSBuZWVkIHRvIHBhaXIgdXAge30gaW5zaWRlIG91ciBzdWJzdCB0byBwcmV2ZW50XG4gICAgICAvLyBpdCBmcm9tIGVuZGluZyB0b28gZWFybHkgYnkgbWF0Y2hpbmcgYW5vdGhlciB9XG4gICAgICBiZWdpbjogL1xcey8sXG4gICAgICBlbmQ6IC9cXH0vLFxuICAgICAga2V5d29yZHM6IEtFWVdPUkRTJDEsXG4gICAgICBjb250YWluczogW1xuICAgICAgICBcInNlbGZcIlxuICAgICAgXS5jb25jYXQoU1VCU1RfSU5URVJOQUxTKVxuICAgIH0pO1xuICBjb25zdCBTVUJTVF9BTkRfQ09NTUVOVFMgPSBbXS5jb25jYXQoQ09NTUVOVCwgU1VCU1QuY29udGFpbnMpO1xuICBjb25zdCBQQVJBTVNfQ09OVEFJTlMgPSBTVUJTVF9BTkRfQ09NTUVOVFMuY29uY2F0KFtcbiAgICAvLyBlYXQgcmVjdXJzaXZlIHBhcmVucyBpbiBzdWIgZXhwcmVzc2lvbnNcbiAgICB7XG4gICAgICBiZWdpbjogL1xcKC8sXG4gICAgICBlbmQ6IC9cXCkvLFxuICAgICAga2V5d29yZHM6IEtFWVdPUkRTJDEsXG4gICAgICBjb250YWluczogW1wic2VsZlwiXS5jb25jYXQoU1VCU1RfQU5EX0NPTU1FTlRTKVxuICAgIH1cbiAgXSk7XG4gIGNvbnN0IFBBUkFNUyA9IHtcbiAgICBjbGFzc05hbWU6ICdwYXJhbXMnLFxuICAgIGJlZ2luOiAvXFwoLyxcbiAgICBlbmQ6IC9cXCkvLFxuICAgIGV4Y2x1ZGVCZWdpbjogdHJ1ZSxcbiAgICBleGNsdWRlRW5kOiB0cnVlLFxuICAgIGtleXdvcmRzOiBLRVlXT1JEUyQxLFxuICAgIGNvbnRhaW5zOiBQQVJBTVNfQ09OVEFJTlNcbiAgfTtcblxuICAvLyBFUzYgY2xhc3Nlc1xuICBjb25zdCBDTEFTU19PUl9FWFRFTkRTID0ge1xuICAgIHZhcmlhbnRzOiBbXG4gICAgICB7XG4gICAgICAgIG1hdGNoOiBbXG4gICAgICAgICAgL2NsYXNzLyxcbiAgICAgICAgICAvXFxzKy8sXG4gICAgICAgICAgSURFTlRfUkUkMVxuICAgICAgICBdLFxuICAgICAgICBzY29wZToge1xuICAgICAgICAgIDE6IFwia2V5d29yZFwiLFxuICAgICAgICAgIDM6IFwidGl0bGUuY2xhc3NcIlxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBtYXRjaDogW1xuICAgICAgICAgIC9leHRlbmRzLyxcbiAgICAgICAgICAvXFxzKy8sXG4gICAgICAgICAgY29uY2F0KElERU5UX1JFJDEsIFwiKFwiLCBjb25jYXQoL1xcLi8sIElERU5UX1JFJDEpLCBcIikqXCIpXG4gICAgICAgIF0sXG4gICAgICAgIHNjb3BlOiB7XG4gICAgICAgICAgMTogXCJrZXl3b3JkXCIsXG4gICAgICAgICAgMzogXCJ0aXRsZS5jbGFzcy5pbmhlcml0ZWRcIlxuICAgICAgICB9XG4gICAgICB9XG4gICAgXVxuICB9O1xuXG4gIGNvbnN0IENMQVNTX1JFRkVSRU5DRSA9IHtcbiAgICByZWxldmFuY2U6IDAsXG4gICAgbWF0Y2g6IC9cXGJbQS1aXVthLXpdKyhbQS1aXVthLXpdKykqLyxcbiAgICBjbGFzc05hbWU6IFwidGl0bGUuY2xhc3NcIixcbiAgICBrZXl3b3Jkczoge1xuICAgICAgXzogW1xuICAgICAgICAvLyBzZSB3ZSBzdGlsbCBnZXQgcmVsZXZhbmNlIGNyZWRpdCBmb3IgSlMgbGlicmFyeSBjbGFzc2VzXG4gICAgICAgIC4uLlRZUEVTLFxuICAgICAgICAuLi5FUlJPUl9UWVBFU1xuICAgICAgXVxuICAgIH1cbiAgfTtcblxuICBjb25zdCBVU0VfU1RSSUNUID0ge1xuICAgIGxhYmVsOiBcInVzZV9zdHJpY3RcIixcbiAgICBjbGFzc05hbWU6ICdtZXRhJyxcbiAgICByZWxldmFuY2U6IDEwLFxuICAgIGJlZ2luOiAvXlxccypbJ1wiXXVzZSAoc3RyaWN0fGFzbSlbJ1wiXS9cbiAgfTtcblxuICBjb25zdCBGVU5DVElPTl9ERUZJTklUSU9OID0ge1xuICAgIHZhcmlhbnRzOiBbXG4gICAgICB7XG4gICAgICAgIG1hdGNoOiBbXG4gICAgICAgICAgL2Z1bmN0aW9uLyxcbiAgICAgICAgICAvXFxzKy8sXG4gICAgICAgICAgSURFTlRfUkUkMSxcbiAgICAgICAgICAvKD89XFxzKlxcKCkvXG4gICAgICAgIF1cbiAgICAgIH0sXG4gICAgICAvLyBhbm9ueW1vdXMgZnVuY3Rpb25cbiAgICAgIHtcbiAgICAgICAgbWF0Y2g6IFtcbiAgICAgICAgICAvZnVuY3Rpb24vLFxuICAgICAgICAgIC9cXHMqKD89XFwoKS9cbiAgICAgICAgXVxuICAgICAgfVxuICAgIF0sXG4gICAgY2xhc3NOYW1lOiB7XG4gICAgICAxOiBcImtleXdvcmRcIixcbiAgICAgIDM6IFwidGl0bGUuZnVuY3Rpb25cIlxuICAgIH0sXG4gICAgbGFiZWw6IFwiZnVuYy5kZWZcIixcbiAgICBjb250YWluczogWyBQQVJBTVMgXSxcbiAgICBpbGxlZ2FsOiAvJS9cbiAgfTtcblxuICBjb25zdCBVUFBFUl9DQVNFX0NPTlNUQU5UID0ge1xuICAgIHJlbGV2YW5jZTogMCxcbiAgICBtYXRjaDogL1xcYltBLVpdW0EtWl8wLTldK1xcYi8sXG4gICAgY2xhc3NOYW1lOiBcInZhcmlhYmxlLmNvbnN0YW50XCJcbiAgfTtcblxuICBmdW5jdGlvbiBub25lT2YobGlzdCkge1xuICAgIHJldHVybiBjb25jYXQoXCIoPyFcIiwgbGlzdC5qb2luKFwifFwiKSwgXCIpXCIpO1xuICB9XG5cbiAgY29uc3QgRlVOQ1RJT05fQ0FMTCA9IHtcbiAgICBtYXRjaDogY29uY2F0KFxuICAgICAgL1xcYi8sXG4gICAgICBub25lT2YoW1xuICAgICAgICAuLi5CVUlMVF9JTl9HTE9CQUxTLFxuICAgICAgICBcInN1cGVyXCJcbiAgICAgIF0pLFxuICAgICAgSURFTlRfUkUkMSwgbG9va2FoZWFkKC9cXCgvKSksXG4gICAgY2xhc3NOYW1lOiBcInRpdGxlLmZ1bmN0aW9uXCIsXG4gICAgcmVsZXZhbmNlOiAwXG4gIH07XG5cbiAgY29uc3QgUFJPUEVSVFlfQUNDRVNTID0ge1xuICAgIGJlZ2luOiBjb25jYXQoL1xcLi8sIGxvb2thaGVhZChcbiAgICAgIGNvbmNhdChJREVOVF9SRSQxLCAvKD8hWzAtOUEtWmEteiRfKF0pLylcbiAgICApKSxcbiAgICBlbmQ6IElERU5UX1JFJDEsXG4gICAgZXhjbHVkZUJlZ2luOiB0cnVlLFxuICAgIGtleXdvcmRzOiBcInByb3RvdHlwZVwiLFxuICAgIGNsYXNzTmFtZTogXCJwcm9wZXJ0eVwiLFxuICAgIHJlbGV2YW5jZTogMFxuICB9O1xuXG4gIGNvbnN0IEdFVFRFUl9PUl9TRVRURVIgPSB7XG4gICAgbWF0Y2g6IFtcbiAgICAgIC9nZXR8c2V0LyxcbiAgICAgIC9cXHMrLyxcbiAgICAgIElERU5UX1JFJDEsXG4gICAgICAvKD89XFwoKS9cbiAgICBdLFxuICAgIGNsYXNzTmFtZToge1xuICAgICAgMTogXCJrZXl3b3JkXCIsXG4gICAgICAzOiBcInRpdGxlLmZ1bmN0aW9uXCJcbiAgICB9LFxuICAgIGNvbnRhaW5zOiBbXG4gICAgICB7IC8vIGVhdCB0byBhdm9pZCBlbXB0eSBwYXJhbXNcbiAgICAgICAgYmVnaW46IC9cXChcXCkvXG4gICAgICB9LFxuICAgICAgUEFSQU1TXG4gICAgXVxuICB9O1xuXG4gIGNvbnN0IEZVTkNfTEVBRF9JTl9SRSA9ICcoXFxcXCgnICtcbiAgICAnW14oKV0qKFxcXFwoJyArXG4gICAgJ1teKCldKihcXFxcKCcgK1xuICAgICdbXigpXSonICtcbiAgICAnXFxcXClbXigpXSopKicgK1xuICAgICdcXFxcKVteKCldKikqJyArXG4gICAgJ1xcXFwpfCcgKyBobGpzLlVOREVSU0NPUkVfSURFTlRfUkUgKyAnKVxcXFxzKj0+JztcblxuICBjb25zdCBGVU5DVElPTl9WQVJJQUJMRSA9IHtcbiAgICBtYXRjaDogW1xuICAgICAgL2NvbnN0fHZhcnxsZXQvLCAvXFxzKy8sXG4gICAgICBJREVOVF9SRSQxLCAvXFxzKi8sXG4gICAgICAvPVxccyovLFxuICAgICAgbG9va2FoZWFkKEZVTkNfTEVBRF9JTl9SRSlcbiAgICBdLFxuICAgIGNsYXNzTmFtZToge1xuICAgICAgMTogXCJrZXl3b3JkXCIsXG4gICAgICAzOiBcInRpdGxlLmZ1bmN0aW9uXCJcbiAgICB9LFxuICAgIGNvbnRhaW5zOiBbXG4gICAgICBQQVJBTVNcbiAgICBdXG4gIH07XG5cbiAgcmV0dXJuIHtcbiAgICBuYW1lOiAnSmF2YXNjcmlwdCcsXG4gICAgYWxpYXNlczogWydqcycsICdqc3gnLCAnbWpzJywgJ2NqcyddLFxuICAgIGtleXdvcmRzOiBLRVlXT1JEUyQxLFxuICAgIC8vIHRoaXMgd2lsbCBiZSBleHRlbmRlZCBieSBUeXBlU2NyaXB0XG4gICAgZXhwb3J0czogeyBQQVJBTVNfQ09OVEFJTlMgfSxcbiAgICBpbGxlZ2FsOiAvIyg/IVskX0Etel0pLyxcbiAgICBjb250YWluczogW1xuICAgICAgaGxqcy5TSEVCQU5HKHtcbiAgICAgICAgbGFiZWw6IFwic2hlYmFuZ1wiLFxuICAgICAgICBiaW5hcnk6IFwibm9kZVwiLFxuICAgICAgICByZWxldmFuY2U6IDVcbiAgICAgIH0pLFxuICAgICAgVVNFX1NUUklDVCxcbiAgICAgIGhsanMuQVBPU19TVFJJTkdfTU9ERSxcbiAgICAgIGhsanMuUVVPVEVfU1RSSU5HX01PREUsXG4gICAgICBIVE1MX1RFTVBMQVRFLFxuICAgICAgQ1NTX1RFTVBMQVRFLFxuICAgICAgVEVNUExBVEVfU1RSSU5HLFxuICAgICAgQ09NTUVOVCxcbiAgICAgIE5VTUJFUixcbiAgICAgIENMQVNTX1JFRkVSRU5DRSxcbiAgICAgIHtcbiAgICAgICAgY2xhc3NOYW1lOiAnYXR0cicsXG4gICAgICAgIGJlZ2luOiBJREVOVF9SRSQxICsgbG9va2FoZWFkKCc6JyksXG4gICAgICAgIHJlbGV2YW5jZTogMFxuICAgICAgfSxcbiAgICAgIEZVTkNUSU9OX1ZBUklBQkxFLFxuICAgICAgeyAvLyBcInZhbHVlXCIgY29udGFpbmVyXG4gICAgICAgIGJlZ2luOiAnKCcgKyBobGpzLlJFX1NUQVJURVJTX1JFICsgJ3xcXFxcYihjYXNlfHJldHVybnx0aHJvdylcXFxcYilcXFxccyonLFxuICAgICAgICBrZXl3b3JkczogJ3JldHVybiB0aHJvdyBjYXNlJyxcbiAgICAgICAgcmVsZXZhbmNlOiAwLFxuICAgICAgICBjb250YWluczogW1xuICAgICAgICAgIENPTU1FTlQsXG4gICAgICAgICAgaGxqcy5SRUdFWFBfTU9ERSxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBjbGFzc05hbWU6ICdmdW5jdGlvbicsXG4gICAgICAgICAgICAvLyB3ZSBoYXZlIHRvIGNvdW50IHRoZSBwYXJlbnMgdG8gbWFrZSBzdXJlIHdlIGFjdHVhbGx5IGhhdmUgdGhlXG4gICAgICAgICAgICAvLyBjb3JyZWN0IGJvdW5kaW5nICggKSBiZWZvcmUgdGhlID0+LiAgVGhlcmUgY291bGQgYmUgYW55IG51bWJlciBvZlxuICAgICAgICAgICAgLy8gc3ViLWV4cHJlc3Npb25zIGluc2lkZSBhbHNvIHN1cnJvdW5kZWQgYnkgcGFyZW5zLlxuICAgICAgICAgICAgYmVnaW46IEZVTkNfTEVBRF9JTl9SRSxcbiAgICAgICAgICAgIHJldHVybkJlZ2luOiB0cnVlLFxuICAgICAgICAgICAgZW5kOiAnXFxcXHMqPT4nLFxuICAgICAgICAgICAgY29udGFpbnM6IFtcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogJ3BhcmFtcycsXG4gICAgICAgICAgICAgICAgdmFyaWFudHM6IFtcbiAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgYmVnaW46IGhsanMuVU5ERVJTQ09SRV9JREVOVF9SRSxcbiAgICAgICAgICAgICAgICAgICAgcmVsZXZhbmNlOiAwXG4gICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIGJlZ2luOiAvXFwoXFxzKlxcKS8sXG4gICAgICAgICAgICAgICAgICAgIHNraXA6IHRydWVcbiAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGJlZ2luOiAvXFwoLyxcbiAgICAgICAgICAgICAgICAgICAgZW5kOiAvXFwpLyxcbiAgICAgICAgICAgICAgICAgICAgZXhjbHVkZUJlZ2luOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBleGNsdWRlRW5kOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBrZXl3b3JkczogS0VZV09SRFMkMSxcbiAgICAgICAgICAgICAgICAgICAgY29udGFpbnM6IFBBUkFNU19DT05UQUlOU1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgXVxuICAgICAgICAgIH0sXG4gICAgICAgICAgeyAvLyBjb3VsZCBiZSBhIGNvbW1hIGRlbGltaXRlZCBsaXN0IG9mIHBhcmFtcyB0byBhIGZ1bmN0aW9uIGNhbGxcbiAgICAgICAgICAgIGJlZ2luOiAvLC8sXG4gICAgICAgICAgICByZWxldmFuY2U6IDBcbiAgICAgICAgICB9LFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIG1hdGNoOiAvXFxzKy8sXG4gICAgICAgICAgICByZWxldmFuY2U6IDBcbiAgICAgICAgICB9LFxuICAgICAgICAgIHsgLy8gSlNYXG4gICAgICAgICAgICB2YXJpYW50czogW1xuICAgICAgICAgICAgICB7IGJlZ2luOiBGUkFHTUVOVC5iZWdpbiwgZW5kOiBGUkFHTUVOVC5lbmQgfSxcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGJlZ2luOiBYTUxfVEFHLmJlZ2luLFxuICAgICAgICAgICAgICAgIC8vIHdlIGNhcmVmdWxseSBjaGVjayB0aGUgb3BlbmluZyB0YWcgdG8gc2VlIGlmIGl0IHRydWx5XG4gICAgICAgICAgICAgICAgLy8gaXMgYSB0YWcgYW5kIG5vdCBhIGZhbHNlIHBvc2l0aXZlXG4gICAgICAgICAgICAgICAgJ29uOmJlZ2luJzogWE1MX1RBRy5pc1RydWx5T3BlbmluZ1RhZyxcbiAgICAgICAgICAgICAgICBlbmQ6IFhNTF9UQUcuZW5kXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBzdWJMYW5ndWFnZTogJ3htbCcsXG4gICAgICAgICAgICBjb250YWluczogW1xuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgYmVnaW46IFhNTF9UQUcuYmVnaW4sXG4gICAgICAgICAgICAgICAgZW5kOiBYTUxfVEFHLmVuZCxcbiAgICAgICAgICAgICAgICBza2lwOiB0cnVlLFxuICAgICAgICAgICAgICAgIGNvbnRhaW5zOiBbJ3NlbGYnXVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBdXG4gICAgICAgICAgfVxuICAgICAgICBdLFxuICAgICAgfSxcbiAgICAgIEZVTkNUSU9OX0RFRklOSVRJT04sXG4gICAgICB7XG4gICAgICAgIC8vIHByZXZlbnQgdGhpcyBmcm9tIGdldHRpbmcgc3dhbGxvd2VkIHVwIGJ5IGZ1bmN0aW9uXG4gICAgICAgIC8vIHNpbmNlIHRoZXkgYXBwZWFyIFwiZnVuY3Rpb24gbGlrZVwiXG4gICAgICAgIGJlZ2luS2V5d29yZHM6IFwid2hpbGUgaWYgc3dpdGNoIGNhdGNoIGZvclwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICAvLyB3ZSBoYXZlIHRvIGNvdW50IHRoZSBwYXJlbnMgdG8gbWFrZSBzdXJlIHdlIGFjdHVhbGx5IGhhdmUgdGhlIGNvcnJlY3RcbiAgICAgICAgLy8gYm91bmRpbmcgKCApLiAgVGhlcmUgY291bGQgYmUgYW55IG51bWJlciBvZiBzdWItZXhwcmVzc2lvbnMgaW5zaWRlXG4gICAgICAgIC8vIGFsc28gc3Vycm91bmRlZCBieSBwYXJlbnMuXG4gICAgICAgIGJlZ2luOiAnXFxcXGIoPyFmdW5jdGlvbiknICsgaGxqcy5VTkRFUlNDT1JFX0lERU5UX1JFICtcbiAgICAgICAgICAnXFxcXCgnICsgLy8gZmlyc3QgcGFyZW5zXG4gICAgICAgICAgJ1teKCldKihcXFxcKCcgK1xuICAgICAgICAgICAgJ1teKCldKihcXFxcKCcgK1xuICAgICAgICAgICAgICAnW14oKV0qJyArXG4gICAgICAgICAgICAnXFxcXClbXigpXSopKicgK1xuICAgICAgICAgICdcXFxcKVteKCldKikqJyArXG4gICAgICAgICAgJ1xcXFwpXFxcXHMqXFxcXHsnLCAvLyBlbmQgcGFyZW5zXG4gICAgICAgIHJldHVybkJlZ2luOnRydWUsXG4gICAgICAgIGxhYmVsOiBcImZ1bmMuZGVmXCIsXG4gICAgICAgIGNvbnRhaW5zOiBbXG4gICAgICAgICAgUEFSQU1TLFxuICAgICAgICAgIGhsanMuaW5oZXJpdChobGpzLlRJVExFX01PREUsIHsgYmVnaW46IElERU5UX1JFJDEsIGNsYXNzTmFtZTogXCJ0aXRsZS5mdW5jdGlvblwiIH0pXG4gICAgICAgIF1cbiAgICAgIH0sXG4gICAgICAvLyBjYXRjaCAuLi4gc28gaXQgd29uJ3QgdHJpZ2dlciB0aGUgcHJvcGVydHkgcnVsZSBiZWxvd1xuICAgICAge1xuICAgICAgICBtYXRjaDogL1xcLlxcLlxcLi8sXG4gICAgICAgIHJlbGV2YW5jZTogMFxuICAgICAgfSxcbiAgICAgIFBST1BFUlRZX0FDQ0VTUyxcbiAgICAgIC8vIGhhY2s6IHByZXZlbnRzIGRldGVjdGlvbiBvZiBrZXl3b3JkcyBpbiBzb21lIGNpcmN1bXN0YW5jZXNcbiAgICAgIC8vIC5rZXl3b3JkKClcbiAgICAgIC8vICRrZXl3b3JkID0geFxuICAgICAge1xuICAgICAgICBtYXRjaDogJ1xcXFwkJyArIElERU5UX1JFJDEsXG4gICAgICAgIHJlbGV2YW5jZTogMFxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgbWF0Y2g6IFsgL1xcYmNvbnN0cnVjdG9yKD89XFxzKlxcKCkvIF0sXG4gICAgICAgIGNsYXNzTmFtZTogeyAxOiBcInRpdGxlLmZ1bmN0aW9uXCIgfSxcbiAgICAgICAgY29udGFpbnM6IFsgUEFSQU1TIF1cbiAgICAgIH0sXG4gICAgICBGVU5DVElPTl9DQUxMLFxuICAgICAgVVBQRVJfQ0FTRV9DT05TVEFOVCxcbiAgICAgIENMQVNTX09SX0VYVEVORFMsXG4gICAgICBHRVRURVJfT1JfU0VUVEVSLFxuICAgICAge1xuICAgICAgICBtYXRjaDogL1xcJFsoLl0vIC8vIHJlbGV2YW5jZSBib29zdGVyIGZvciBhIHBhdHRlcm4gY29tbW9uIHRvIEpTIGxpYnM6IGAkKHNvbWV0aGluZylgIGFuZCBgJC5zb21ldGhpbmdgXG4gICAgICB9XG4gICAgXVxuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBqYXZhc2NyaXB0O1xuIiwiY29uc3QgTU9ERVMgPSAoaGxqcykgPT4ge1xuICByZXR1cm4ge1xuICAgIElNUE9SVEFOVDoge1xuICAgICAgc2NvcGU6ICdtZXRhJyxcbiAgICAgIGJlZ2luOiAnIWltcG9ydGFudCdcbiAgICB9LFxuICAgIEhFWENPTE9SOiB7XG4gICAgICBzY29wZTogJ251bWJlcicsXG4gICAgICBiZWdpbjogJyMoW2EtZkEtRjAtOV17Nn18W2EtZkEtRjAtOV17M30pJ1xuICAgIH0sXG4gICAgQVRUUklCVVRFX1NFTEVDVE9SX01PREU6IHtcbiAgICAgIHNjb3BlOiAnc2VsZWN0b3ItYXR0cicsXG4gICAgICBiZWdpbjogL1xcWy8sXG4gICAgICBlbmQ6IC9cXF0vLFxuICAgICAgaWxsZWdhbDogJyQnLFxuICAgICAgY29udGFpbnM6IFtcbiAgICAgICAgaGxqcy5BUE9TX1NUUklOR19NT0RFLFxuICAgICAgICBobGpzLlFVT1RFX1NUUklOR19NT0RFXG4gICAgICBdXG4gICAgfSxcbiAgICBDU1NfTlVNQkVSX01PREU6IHtcbiAgICAgIHNjb3BlOiAnbnVtYmVyJyxcbiAgICAgIGJlZ2luOiBobGpzLk5VTUJFUl9SRSArICcoJyArXG4gICAgICAgICclfGVtfGV4fGNofHJlbScgK1xuICAgICAgICAnfHZ3fHZofHZtaW58dm1heCcgK1xuICAgICAgICAnfGNtfG1tfGlufHB0fHBjfHB4JyArXG4gICAgICAgICd8ZGVnfGdyYWR8cmFkfHR1cm4nICtcbiAgICAgICAgJ3xzfG1zJyArXG4gICAgICAgICd8SHp8a0h6JyArXG4gICAgICAgICd8ZHBpfGRwY218ZHBweCcgK1xuICAgICAgICAnKT8nLFxuICAgICAgcmVsZXZhbmNlOiAwXG4gICAgfSxcbiAgICBDU1NfVkFSSUFCTEU6IHtcbiAgICAgIGNsYXNzTmFtZTogXCJhdHRyXCIsXG4gICAgICBiZWdpbjogLy0tW0EtWmEtel1bQS1aYS16MC05Xy1dKi9cbiAgICB9XG4gIH07XG59O1xuXG5jb25zdCBUQUdTID0gW1xuICAnYScsXG4gICdhYmJyJyxcbiAgJ2FkZHJlc3MnLFxuICAnYXJ0aWNsZScsXG4gICdhc2lkZScsXG4gICdhdWRpbycsXG4gICdiJyxcbiAgJ2Jsb2NrcXVvdGUnLFxuICAnYm9keScsXG4gICdidXR0b24nLFxuICAnY2FudmFzJyxcbiAgJ2NhcHRpb24nLFxuICAnY2l0ZScsXG4gICdjb2RlJyxcbiAgJ2RkJyxcbiAgJ2RlbCcsXG4gICdkZXRhaWxzJyxcbiAgJ2RmbicsXG4gICdkaXYnLFxuICAnZGwnLFxuICAnZHQnLFxuICAnZW0nLFxuICAnZmllbGRzZXQnLFxuICAnZmlnY2FwdGlvbicsXG4gICdmaWd1cmUnLFxuICAnZm9vdGVyJyxcbiAgJ2Zvcm0nLFxuICAnaDEnLFxuICAnaDInLFxuICAnaDMnLFxuICAnaDQnLFxuICAnaDUnLFxuICAnaDYnLFxuICAnaGVhZGVyJyxcbiAgJ2hncm91cCcsXG4gICdodG1sJyxcbiAgJ2knLFxuICAnaWZyYW1lJyxcbiAgJ2ltZycsXG4gICdpbnB1dCcsXG4gICdpbnMnLFxuICAna2JkJyxcbiAgJ2xhYmVsJyxcbiAgJ2xlZ2VuZCcsXG4gICdsaScsXG4gICdtYWluJyxcbiAgJ21hcmsnLFxuICAnbWVudScsXG4gICduYXYnLFxuICAnb2JqZWN0JyxcbiAgJ29sJyxcbiAgJ3AnLFxuICAncScsXG4gICdxdW90ZScsXG4gICdzYW1wJyxcbiAgJ3NlY3Rpb24nLFxuICAnc3BhbicsXG4gICdzdHJvbmcnLFxuICAnc3VtbWFyeScsXG4gICdzdXAnLFxuICAndGFibGUnLFxuICAndGJvZHknLFxuICAndGQnLFxuICAndGV4dGFyZWEnLFxuICAndGZvb3QnLFxuICAndGgnLFxuICAndGhlYWQnLFxuICAndGltZScsXG4gICd0cicsXG4gICd1bCcsXG4gICd2YXInLFxuICAndmlkZW8nXG5dO1xuXG5jb25zdCBNRURJQV9GRUFUVVJFUyA9IFtcbiAgJ2FueS1ob3ZlcicsXG4gICdhbnktcG9pbnRlcicsXG4gICdhc3BlY3QtcmF0aW8nLFxuICAnY29sb3InLFxuICAnY29sb3ItZ2FtdXQnLFxuICAnY29sb3ItaW5kZXgnLFxuICAnZGV2aWNlLWFzcGVjdC1yYXRpbycsXG4gICdkZXZpY2UtaGVpZ2h0JyxcbiAgJ2RldmljZS13aWR0aCcsXG4gICdkaXNwbGF5LW1vZGUnLFxuICAnZm9yY2VkLWNvbG9ycycsXG4gICdncmlkJyxcbiAgJ2hlaWdodCcsXG4gICdob3ZlcicsXG4gICdpbnZlcnRlZC1jb2xvcnMnLFxuICAnbW9ub2Nocm9tZScsXG4gICdvcmllbnRhdGlvbicsXG4gICdvdmVyZmxvdy1ibG9jaycsXG4gICdvdmVyZmxvdy1pbmxpbmUnLFxuICAncG9pbnRlcicsXG4gICdwcmVmZXJzLWNvbG9yLXNjaGVtZScsXG4gICdwcmVmZXJzLWNvbnRyYXN0JyxcbiAgJ3ByZWZlcnMtcmVkdWNlZC1tb3Rpb24nLFxuICAncHJlZmVycy1yZWR1Y2VkLXRyYW5zcGFyZW5jeScsXG4gICdyZXNvbHV0aW9uJyxcbiAgJ3NjYW4nLFxuICAnc2NyaXB0aW5nJyxcbiAgJ3VwZGF0ZScsXG4gICd3aWR0aCcsXG4gIC8vIFRPRE86IGZpbmQgYSBiZXR0ZXIgc29sdXRpb24/XG4gICdtaW4td2lkdGgnLFxuICAnbWF4LXdpZHRoJyxcbiAgJ21pbi1oZWlnaHQnLFxuICAnbWF4LWhlaWdodCdcbl07XG5cbi8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0NTUy9Qc2V1ZG8tY2xhc3Nlc1xuY29uc3QgUFNFVURPX0NMQVNTRVMgPSBbXG4gICdhY3RpdmUnLFxuICAnYW55LWxpbmsnLFxuICAnYmxhbmsnLFxuICAnY2hlY2tlZCcsXG4gICdjdXJyZW50JyxcbiAgJ2RlZmF1bHQnLFxuICAnZGVmaW5lZCcsXG4gICdkaXInLCAvLyBkaXIoKVxuICAnZGlzYWJsZWQnLFxuICAnZHJvcCcsXG4gICdlbXB0eScsXG4gICdlbmFibGVkJyxcbiAgJ2ZpcnN0JyxcbiAgJ2ZpcnN0LWNoaWxkJyxcbiAgJ2ZpcnN0LW9mLXR5cGUnLFxuICAnZnVsbHNjcmVlbicsXG4gICdmdXR1cmUnLFxuICAnZm9jdXMnLFxuICAnZm9jdXMtdmlzaWJsZScsXG4gICdmb2N1cy13aXRoaW4nLFxuICAnaGFzJywgLy8gaGFzKClcbiAgJ2hvc3QnLCAvLyBob3N0IG9yIGhvc3QoKVxuICAnaG9zdC1jb250ZXh0JywgLy8gaG9zdC1jb250ZXh0KClcbiAgJ2hvdmVyJyxcbiAgJ2luZGV0ZXJtaW5hdGUnLFxuICAnaW4tcmFuZ2UnLFxuICAnaW52YWxpZCcsXG4gICdpcycsIC8vIGlzKClcbiAgJ2xhbmcnLCAvLyBsYW5nKClcbiAgJ2xhc3QtY2hpbGQnLFxuICAnbGFzdC1vZi10eXBlJyxcbiAgJ2xlZnQnLFxuICAnbGluaycsXG4gICdsb2NhbC1saW5rJyxcbiAgJ25vdCcsIC8vIG5vdCgpXG4gICdudGgtY2hpbGQnLCAvLyBudGgtY2hpbGQoKVxuICAnbnRoLWNvbCcsIC8vIG50aC1jb2woKVxuICAnbnRoLWxhc3QtY2hpbGQnLCAvLyBudGgtbGFzdC1jaGlsZCgpXG4gICdudGgtbGFzdC1jb2wnLCAvLyBudGgtbGFzdC1jb2woKVxuICAnbnRoLWxhc3Qtb2YtdHlwZScsIC8vbnRoLWxhc3Qtb2YtdHlwZSgpXG4gICdudGgtb2YtdHlwZScsIC8vbnRoLW9mLXR5cGUoKVxuICAnb25seS1jaGlsZCcsXG4gICdvbmx5LW9mLXR5cGUnLFxuICAnb3B0aW9uYWwnLFxuICAnb3V0LW9mLXJhbmdlJyxcbiAgJ3Bhc3QnLFxuICAncGxhY2Vob2xkZXItc2hvd24nLFxuICAncmVhZC1vbmx5JyxcbiAgJ3JlYWQtd3JpdGUnLFxuICAncmVxdWlyZWQnLFxuICAncmlnaHQnLFxuICAncm9vdCcsXG4gICdzY29wZScsXG4gICd0YXJnZXQnLFxuICAndGFyZ2V0LXdpdGhpbicsXG4gICd1c2VyLWludmFsaWQnLFxuICAndmFsaWQnLFxuICAndmlzaXRlZCcsXG4gICd3aGVyZScgLy8gd2hlcmUoKVxuXTtcblxuLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQ1NTL1BzZXVkby1lbGVtZW50c1xuY29uc3QgUFNFVURPX0VMRU1FTlRTID0gW1xuICAnYWZ0ZXInLFxuICAnYmFja2Ryb3AnLFxuICAnYmVmb3JlJyxcbiAgJ2N1ZScsXG4gICdjdWUtcmVnaW9uJyxcbiAgJ2ZpcnN0LWxldHRlcicsXG4gICdmaXJzdC1saW5lJyxcbiAgJ2dyYW1tYXItZXJyb3InLFxuICAnbWFya2VyJyxcbiAgJ3BhcnQnLFxuICAncGxhY2Vob2xkZXInLFxuICAnc2VsZWN0aW9uJyxcbiAgJ3Nsb3R0ZWQnLFxuICAnc3BlbGxpbmctZXJyb3InXG5dO1xuXG5jb25zdCBBVFRSSUJVVEVTID0gW1xuICAnYWxpZ24tY29udGVudCcsXG4gICdhbGlnbi1pdGVtcycsXG4gICdhbGlnbi1zZWxmJyxcbiAgJ2FuaW1hdGlvbicsXG4gICdhbmltYXRpb24tZGVsYXknLFxuICAnYW5pbWF0aW9uLWRpcmVjdGlvbicsXG4gICdhbmltYXRpb24tZHVyYXRpb24nLFxuICAnYW5pbWF0aW9uLWZpbGwtbW9kZScsXG4gICdhbmltYXRpb24taXRlcmF0aW9uLWNvdW50JyxcbiAgJ2FuaW1hdGlvbi1uYW1lJyxcbiAgJ2FuaW1hdGlvbi1wbGF5LXN0YXRlJyxcbiAgJ2FuaW1hdGlvbi10aW1pbmctZnVuY3Rpb24nLFxuICAnYXV0bycsXG4gICdiYWNrZmFjZS12aXNpYmlsaXR5JyxcbiAgJ2JhY2tncm91bmQnLFxuICAnYmFja2dyb3VuZC1hdHRhY2htZW50JyxcbiAgJ2JhY2tncm91bmQtY2xpcCcsXG4gICdiYWNrZ3JvdW5kLWNvbG9yJyxcbiAgJ2JhY2tncm91bmQtaW1hZ2UnLFxuICAnYmFja2dyb3VuZC1vcmlnaW4nLFxuICAnYmFja2dyb3VuZC1wb3NpdGlvbicsXG4gICdiYWNrZ3JvdW5kLXJlcGVhdCcsXG4gICdiYWNrZ3JvdW5kLXNpemUnLFxuICAnYm9yZGVyJyxcbiAgJ2JvcmRlci1ib3R0b20nLFxuICAnYm9yZGVyLWJvdHRvbS1jb2xvcicsXG4gICdib3JkZXItYm90dG9tLWxlZnQtcmFkaXVzJyxcbiAgJ2JvcmRlci1ib3R0b20tcmlnaHQtcmFkaXVzJyxcbiAgJ2JvcmRlci1ib3R0b20tc3R5bGUnLFxuICAnYm9yZGVyLWJvdHRvbS13aWR0aCcsXG4gICdib3JkZXItY29sbGFwc2UnLFxuICAnYm9yZGVyLWNvbG9yJyxcbiAgJ2JvcmRlci1pbWFnZScsXG4gICdib3JkZXItaW1hZ2Utb3V0c2V0JyxcbiAgJ2JvcmRlci1pbWFnZS1yZXBlYXQnLFxuICAnYm9yZGVyLWltYWdlLXNsaWNlJyxcbiAgJ2JvcmRlci1pbWFnZS1zb3VyY2UnLFxuICAnYm9yZGVyLWltYWdlLXdpZHRoJyxcbiAgJ2JvcmRlci1sZWZ0JyxcbiAgJ2JvcmRlci1sZWZ0LWNvbG9yJyxcbiAgJ2JvcmRlci1sZWZ0LXN0eWxlJyxcbiAgJ2JvcmRlci1sZWZ0LXdpZHRoJyxcbiAgJ2JvcmRlci1yYWRpdXMnLFxuICAnYm9yZGVyLXJpZ2h0JyxcbiAgJ2JvcmRlci1yaWdodC1jb2xvcicsXG4gICdib3JkZXItcmlnaHQtc3R5bGUnLFxuICAnYm9yZGVyLXJpZ2h0LXdpZHRoJyxcbiAgJ2JvcmRlci1zcGFjaW5nJyxcbiAgJ2JvcmRlci1zdHlsZScsXG4gICdib3JkZXItdG9wJyxcbiAgJ2JvcmRlci10b3AtY29sb3InLFxuICAnYm9yZGVyLXRvcC1sZWZ0LXJhZGl1cycsXG4gICdib3JkZXItdG9wLXJpZ2h0LXJhZGl1cycsXG4gICdib3JkZXItdG9wLXN0eWxlJyxcbiAgJ2JvcmRlci10b3Atd2lkdGgnLFxuICAnYm9yZGVyLXdpZHRoJyxcbiAgJ2JvdHRvbScsXG4gICdib3gtZGVjb3JhdGlvbi1icmVhaycsXG4gICdib3gtc2hhZG93JyxcbiAgJ2JveC1zaXppbmcnLFxuICAnYnJlYWstYWZ0ZXInLFxuICAnYnJlYWstYmVmb3JlJyxcbiAgJ2JyZWFrLWluc2lkZScsXG4gICdjYXB0aW9uLXNpZGUnLFxuICAnY2xlYXInLFxuICAnY2xpcCcsXG4gICdjbGlwLXBhdGgnLFxuICAnY29sb3InLFxuICAnY29sdW1uLWNvdW50JyxcbiAgJ2NvbHVtbi1maWxsJyxcbiAgJ2NvbHVtbi1nYXAnLFxuICAnY29sdW1uLXJ1bGUnLFxuICAnY29sdW1uLXJ1bGUtY29sb3InLFxuICAnY29sdW1uLXJ1bGUtc3R5bGUnLFxuICAnY29sdW1uLXJ1bGUtd2lkdGgnLFxuICAnY29sdW1uLXNwYW4nLFxuICAnY29sdW1uLXdpZHRoJyxcbiAgJ2NvbHVtbnMnLFxuICAnY29udGVudCcsXG4gICdjb3VudGVyLWluY3JlbWVudCcsXG4gICdjb3VudGVyLXJlc2V0JyxcbiAgJ2N1cnNvcicsXG4gICdkaXJlY3Rpb24nLFxuICAnZGlzcGxheScsXG4gICdlbXB0eS1jZWxscycsXG4gICdmaWx0ZXInLFxuICAnZmxleCcsXG4gICdmbGV4LWJhc2lzJyxcbiAgJ2ZsZXgtZGlyZWN0aW9uJyxcbiAgJ2ZsZXgtZmxvdycsXG4gICdmbGV4LWdyb3cnLFxuICAnZmxleC1zaHJpbmsnLFxuICAnZmxleC13cmFwJyxcbiAgJ2Zsb2F0JyxcbiAgJ2ZvbnQnLFxuICAnZm9udC1kaXNwbGF5JyxcbiAgJ2ZvbnQtZmFtaWx5JyxcbiAgJ2ZvbnQtZmVhdHVyZS1zZXR0aW5ncycsXG4gICdmb250LWtlcm5pbmcnLFxuICAnZm9udC1sYW5ndWFnZS1vdmVycmlkZScsXG4gICdmb250LXNpemUnLFxuICAnZm9udC1zaXplLWFkanVzdCcsXG4gICdmb250LXNtb290aGluZycsXG4gICdmb250LXN0cmV0Y2gnLFxuICAnZm9udC1zdHlsZScsXG4gICdmb250LXZhcmlhbnQnLFxuICAnZm9udC12YXJpYW50LWxpZ2F0dXJlcycsXG4gICdmb250LXZhcmlhdGlvbi1zZXR0aW5ncycsXG4gICdmb250LXdlaWdodCcsXG4gICdoZWlnaHQnLFxuICAnaHlwaGVucycsXG4gICdpY29uJyxcbiAgJ2ltYWdlLW9yaWVudGF0aW9uJyxcbiAgJ2ltYWdlLXJlbmRlcmluZycsXG4gICdpbWFnZS1yZXNvbHV0aW9uJyxcbiAgJ2ltZS1tb2RlJyxcbiAgJ2luaGVyaXQnLFxuICAnaW5pdGlhbCcsXG4gICdqdXN0aWZ5LWNvbnRlbnQnLFxuICAnbGVmdCcsXG4gICdsZXR0ZXItc3BhY2luZycsXG4gICdsaW5lLWhlaWdodCcsXG4gICdsaXN0LXN0eWxlJyxcbiAgJ2xpc3Qtc3R5bGUtaW1hZ2UnLFxuICAnbGlzdC1zdHlsZS1wb3NpdGlvbicsXG4gICdsaXN0LXN0eWxlLXR5cGUnLFxuICAnbWFyZ2luJyxcbiAgJ21hcmdpbi1ib3R0b20nLFxuICAnbWFyZ2luLWxlZnQnLFxuICAnbWFyZ2luLXJpZ2h0JyxcbiAgJ21hcmdpbi10b3AnLFxuICAnbWFya3MnLFxuICAnbWFzaycsXG4gICdtYXgtaGVpZ2h0JyxcbiAgJ21heC13aWR0aCcsXG4gICdtaW4taGVpZ2h0JyxcbiAgJ21pbi13aWR0aCcsXG4gICduYXYtZG93bicsXG4gICduYXYtaW5kZXgnLFxuICAnbmF2LWxlZnQnLFxuICAnbmF2LXJpZ2h0JyxcbiAgJ25hdi11cCcsXG4gICdub25lJyxcbiAgJ25vcm1hbCcsXG4gICdvYmplY3QtZml0JyxcbiAgJ29iamVjdC1wb3NpdGlvbicsXG4gICdvcGFjaXR5JyxcbiAgJ29yZGVyJyxcbiAgJ29ycGhhbnMnLFxuICAnb3V0bGluZScsXG4gICdvdXRsaW5lLWNvbG9yJyxcbiAgJ291dGxpbmUtb2Zmc2V0JyxcbiAgJ291dGxpbmUtc3R5bGUnLFxuICAnb3V0bGluZS13aWR0aCcsXG4gICdvdmVyZmxvdycsXG4gICdvdmVyZmxvdy13cmFwJyxcbiAgJ292ZXJmbG93LXgnLFxuICAnb3ZlcmZsb3cteScsXG4gICdwYWRkaW5nJyxcbiAgJ3BhZGRpbmctYm90dG9tJyxcbiAgJ3BhZGRpbmctbGVmdCcsXG4gICdwYWRkaW5nLXJpZ2h0JyxcbiAgJ3BhZGRpbmctdG9wJyxcbiAgJ3BhZ2UtYnJlYWstYWZ0ZXInLFxuICAncGFnZS1icmVhay1iZWZvcmUnLFxuICAncGFnZS1icmVhay1pbnNpZGUnLFxuICAncGVyc3BlY3RpdmUnLFxuICAncGVyc3BlY3RpdmUtb3JpZ2luJyxcbiAgJ3BvaW50ZXItZXZlbnRzJyxcbiAgJ3Bvc2l0aW9uJyxcbiAgJ3F1b3RlcycsXG4gICdyZXNpemUnLFxuICAncmlnaHQnLFxuICAnc3JjJywgLy8gQGZvbnQtZmFjZVxuICAndGFiLXNpemUnLFxuICAndGFibGUtbGF5b3V0JyxcbiAgJ3RleHQtYWxpZ24nLFxuICAndGV4dC1hbGlnbi1sYXN0JyxcbiAgJ3RleHQtZGVjb3JhdGlvbicsXG4gICd0ZXh0LWRlY29yYXRpb24tY29sb3InLFxuICAndGV4dC1kZWNvcmF0aW9uLWxpbmUnLFxuICAndGV4dC1kZWNvcmF0aW9uLXN0eWxlJyxcbiAgJ3RleHQtaW5kZW50JyxcbiAgJ3RleHQtb3ZlcmZsb3cnLFxuICAndGV4dC1yZW5kZXJpbmcnLFxuICAndGV4dC1zaGFkb3cnLFxuICAndGV4dC10cmFuc2Zvcm0nLFxuICAndGV4dC11bmRlcmxpbmUtcG9zaXRpb24nLFxuICAndG9wJyxcbiAgJ3RyYW5zZm9ybScsXG4gICd0cmFuc2Zvcm0tb3JpZ2luJyxcbiAgJ3RyYW5zZm9ybS1zdHlsZScsXG4gICd0cmFuc2l0aW9uJyxcbiAgJ3RyYW5zaXRpb24tZGVsYXknLFxuICAndHJhbnNpdGlvbi1kdXJhdGlvbicsXG4gICd0cmFuc2l0aW9uLXByb3BlcnR5JyxcbiAgJ3RyYW5zaXRpb24tdGltaW5nLWZ1bmN0aW9uJyxcbiAgJ3VuaWNvZGUtYmlkaScsXG4gICd2ZXJ0aWNhbC1hbGlnbicsXG4gICd2aXNpYmlsaXR5JyxcbiAgJ3doaXRlLXNwYWNlJyxcbiAgJ3dpZG93cycsXG4gICd3aWR0aCcsXG4gICd3b3JkLWJyZWFrJyxcbiAgJ3dvcmQtc3BhY2luZycsXG4gICd3b3JkLXdyYXAnLFxuICAnei1pbmRleCdcbiAgLy8gcmV2ZXJzZSBtYWtlcyBzdXJlIGxvbmdlciBhdHRyaWJ1dGVzIGBmb250LXdlaWdodGAgYXJlIG1hdGNoZWQgZnVsbHlcbiAgLy8gaW5zdGVhZCBvZiBnZXR0aW5nIGZhbHNlIHBvc2l0aXZlcyBvbiBzYXkgYGZvbnRgXG5dLnJldmVyc2UoKTtcblxuLypcbkxhbmd1YWdlOiBTQ1NTXG5EZXNjcmlwdGlvbjogU2NzcyBpcyBhbiBleHRlbnNpb24gb2YgdGhlIHN5bnRheCBvZiBDU1MuXG5BdXRob3I6IEt1cnQgRW1jaCA8a3VydEBrdXJ0ZW1jaC5jb20+XG5XZWJzaXRlOiBodHRwczovL3Nhc3MtbGFuZy5jb21cbkNhdGVnb3J5OiBjb21tb24sIGNzcywgd2ViXG4qL1xuXG4vKiogQHR5cGUgTGFuZ3VhZ2VGbiAqL1xuZnVuY3Rpb24gc2NzcyhobGpzKSB7XG4gIGNvbnN0IG1vZGVzID0gTU9ERVMoaGxqcyk7XG4gIGNvbnN0IFBTRVVET19FTEVNRU5UUyQxID0gUFNFVURPX0VMRU1FTlRTO1xuICBjb25zdCBQU0VVRE9fQ0xBU1NFUyQxID0gUFNFVURPX0NMQVNTRVM7XG5cbiAgY29uc3QgQVRfSURFTlRJRklFUiA9ICdAW2Etei1dKyc7IC8vIEBmb250LWZhY2VcbiAgY29uc3QgQVRfTU9ESUZJRVJTID0gXCJhbmQgb3Igbm90IG9ubHlcIjtcbiAgY29uc3QgSURFTlRfUkUgPSAnW2EtekEtWi1dW2EtekEtWjAtOV8tXSonO1xuICBjb25zdCBWQVJJQUJMRSA9IHtcbiAgICBjbGFzc05hbWU6ICd2YXJpYWJsZScsXG4gICAgYmVnaW46ICcoXFxcXCQnICsgSURFTlRfUkUgKyAnKVxcXFxiJ1xuICB9O1xuXG4gIHJldHVybiB7XG4gICAgbmFtZTogJ1NDU1MnLFxuICAgIGNhc2VfaW5zZW5zaXRpdmU6IHRydWUsXG4gICAgaWxsZWdhbDogJ1s9L3xcXCddJyxcbiAgICBjb250YWluczogW1xuICAgICAgaGxqcy5DX0xJTkVfQ09NTUVOVF9NT0RFLFxuICAgICAgaGxqcy5DX0JMT0NLX0NPTU1FTlRfTU9ERSxcbiAgICAgIHtcbiAgICAgICAgY2xhc3NOYW1lOiAnc2VsZWN0b3ItaWQnLFxuICAgICAgICBiZWdpbjogJyNbQS1aYS16MC05Xy1dKycsXG4gICAgICAgIHJlbGV2YW5jZTogMFxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgY2xhc3NOYW1lOiAnc2VsZWN0b3ItY2xhc3MnLFxuICAgICAgICBiZWdpbjogJ1xcXFwuW0EtWmEtejAtOV8tXSsnLFxuICAgICAgICByZWxldmFuY2U6IDBcbiAgICAgIH0sXG4gICAgICBtb2Rlcy5BVFRSSUJVVEVfU0VMRUNUT1JfTU9ERSxcbiAgICAgIHtcbiAgICAgICAgY2xhc3NOYW1lOiAnc2VsZWN0b3ItdGFnJyxcbiAgICAgICAgYmVnaW46ICdcXFxcYignICsgVEFHUy5qb2luKCd8JykgKyAnKVxcXFxiJyxcbiAgICAgICAgLy8gd2FzIHRoZXJlLCBiZWZvcmUsIGJ1dCB3aHk/XG4gICAgICAgIHJlbGV2YW5jZTogMFxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgY2xhc3NOYW1lOiAnc2VsZWN0b3ItcHNldWRvJyxcbiAgICAgICAgYmVnaW46ICc6KCcgKyBQU0VVRE9fQ0xBU1NFUyQxLmpvaW4oJ3wnKSArICcpJ1xuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgY2xhc3NOYW1lOiAnc2VsZWN0b3ItcHNldWRvJyxcbiAgICAgICAgYmVnaW46ICc6OignICsgUFNFVURPX0VMRU1FTlRTJDEuam9pbignfCcpICsgJyknXG4gICAgICB9LFxuICAgICAgVkFSSUFCTEUsXG4gICAgICB7IC8vIHBzZXVkby1zZWxlY3RvciBwYXJhbXNcbiAgICAgICAgYmVnaW46IC9cXCgvLFxuICAgICAgICBlbmQ6IC9cXCkvLFxuICAgICAgICBjb250YWluczogWyBtb2Rlcy5DU1NfTlVNQkVSX01PREUgXVxuICAgICAgfSxcbiAgICAgIG1vZGVzLkNTU19WQVJJQUJMRSxcbiAgICAgIHtcbiAgICAgICAgY2xhc3NOYW1lOiAnYXR0cmlidXRlJyxcbiAgICAgICAgYmVnaW46ICdcXFxcYignICsgQVRUUklCVVRFUy5qb2luKCd8JykgKyAnKVxcXFxiJ1xuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgYmVnaW46ICdcXFxcYih3aGl0ZXNwYWNlfHdhaXR8dy1yZXNpemV8dmlzaWJsZXx2ZXJ0aWNhbC10ZXh0fHZlcnRpY2FsLWlkZW9ncmFwaGljfHVwcGVyY2FzZXx1cHBlci1yb21hbnx1cHBlci1hbHBoYXx1bmRlcmxpbmV8dHJhbnNwYXJlbnR8dG9wfHRoaW58dGhpY2t8dGV4dHx0ZXh0LXRvcHx0ZXh0LWJvdHRvbXx0Yi1ybHx0YWJsZS1oZWFkZXItZ3JvdXB8dGFibGUtZm9vdGVyLWdyb3VwfHN3LXJlc2l6ZXxzdXBlcnxzdHJpY3R8c3RhdGljfHNxdWFyZXxzb2xpZHxzbWFsbC1jYXBzfHNlcGFyYXRlfHNlLXJlc2l6ZXxzY3JvbGx8cy1yZXNpemV8cnRsfHJvdy1yZXNpemV8cmlkZ2V8cmlnaHR8cmVwZWF0fHJlcGVhdC15fHJlcGVhdC14fHJlbGF0aXZlfHByb2dyZXNzfHBvaW50ZXJ8b3ZlcmxpbmV8b3V0c2lkZXxvdXRzZXR8b2JsaXF1ZXxub3dyYXB8bm90LWFsbG93ZWR8bm9ybWFsfG5vbmV8bnctcmVzaXplfG5vLXJlcGVhdHxuby1kcm9wfG5ld3NwYXBlcnxuZS1yZXNpemV8bi1yZXNpemV8bW92ZXxtaWRkbGV8bWVkaXVtfGx0cnxsci10Ynxsb3dlcmNhc2V8bG93ZXItcm9tYW58bG93ZXItYWxwaGF8bG9vc2V8bGlzdC1pdGVtfGxpbmV8bGluZS10aHJvdWdofGxpbmUtZWRnZXxsaWdodGVyfGxlZnR8a2VlcC1hbGx8anVzdGlmeXxpdGFsaWN8aW50ZXItd29yZHxpbnRlci1pZGVvZ3JhcGh8aW5zaWRlfGluc2V0fGlubGluZXxpbmxpbmUtYmxvY2t8aW5oZXJpdHxpbmFjdGl2ZXxpZGVvZ3JhcGgtc3BhY2V8aWRlb2dyYXBoLXBhcmVudGhlc2lzfGlkZW9ncmFwaC1udW1lcmljfGlkZW9ncmFwaC1hbHBoYXxob3Jpem9udGFsfGhpZGRlbnxoZWxwfGhhbmR8Z3Jvb3ZlfGZpeGVkfGVsbGlwc2lzfGUtcmVzaXplfGRvdWJsZXxkb3R0ZWR8ZGlzdHJpYnV0ZXxkaXN0cmlidXRlLXNwYWNlfGRpc3RyaWJ1dGUtbGV0dGVyfGRpc3RyaWJ1dGUtYWxsLWxpbmVzfGRpc2N8ZGlzYWJsZWR8ZGVmYXVsdHxkZWNpbWFsfGRhc2hlZHxjcm9zc2hhaXJ8Y29sbGFwc2V8Y29sLXJlc2l6ZXxjaXJjbGV8Y2hhcnxjZW50ZXJ8Y2FwaXRhbGl6ZXxicmVhay13b3JkfGJyZWFrLWFsbHxib3R0b218Ym90aHxib2xkZXJ8Ym9sZHxibG9ja3xiaWRpLW92ZXJyaWRlfGJlbG93fGJhc2VsaW5lfGF1dG98YWx3YXlzfGFsbC1zY3JvbGx8YWJzb2x1dGV8dGFibGV8dGFibGUtY2VsbClcXFxcYidcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGJlZ2luOiAnOicsXG4gICAgICAgIGVuZDogJzsnLFxuICAgICAgICBjb250YWluczogW1xuICAgICAgICAgIFZBUklBQkxFLFxuICAgICAgICAgIG1vZGVzLkhFWENPTE9SLFxuICAgICAgICAgIG1vZGVzLkNTU19OVU1CRVJfTU9ERSxcbiAgICAgICAgICBobGpzLlFVT1RFX1NUUklOR19NT0RFLFxuICAgICAgICAgIGhsanMuQVBPU19TVFJJTkdfTU9ERSxcbiAgICAgICAgICBtb2Rlcy5JTVBPUlRBTlRcbiAgICAgICAgXVxuICAgICAgfSxcbiAgICAgIC8vIG1hdGNoaW5nIHRoZXNlIGhlcmUgYWxsb3dzIHVzIHRvIHRyZWF0IHRoZW0gbW9yZSBsaWtlIHJlZ3VsYXIgQ1NTXG4gICAgICAvLyBydWxlcyBzbyBldmVyeXRoaW5nIGJldHdlZW4gdGhlIHt9IGdldHMgcmVndWxhciBydWxlIGhpZ2hsaWdodGluZyxcbiAgICAgIC8vIHdoaWNoIGlzIHdoYXQgd2Ugd2FudCBmb3IgcGFnZSBhbmQgZm9udC1mYWNlXG4gICAgICB7XG4gICAgICAgIGJlZ2luOiAnQChwYWdlfGZvbnQtZmFjZSknLFxuICAgICAgICBrZXl3b3Jkczoge1xuICAgICAgICAgICRwYXR0ZXJuOiBBVF9JREVOVElGSUVSLFxuICAgICAgICAgIGtleXdvcmQ6ICdAcGFnZSBAZm9udC1mYWNlJ1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBiZWdpbjogJ0AnLFxuICAgICAgICBlbmQ6ICdbeztdJyxcbiAgICAgICAgcmV0dXJuQmVnaW46IHRydWUsXG4gICAgICAgIGtleXdvcmRzOiB7XG4gICAgICAgICAgJHBhdHRlcm46IC9bYS16LV0rLyxcbiAgICAgICAgICBrZXl3b3JkOiBBVF9NT0RJRklFUlMsXG4gICAgICAgICAgYXR0cmlidXRlOiBNRURJQV9GRUFUVVJFUy5qb2luKFwiIFwiKVxuICAgICAgICB9LFxuICAgICAgICBjb250YWluczogW1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIGJlZ2luOiBBVF9JREVOVElGSUVSLFxuICAgICAgICAgICAgY2xhc3NOYW1lOiBcImtleXdvcmRcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAge1xuICAgICAgICAgICAgYmVnaW46IC9bYS16LV0rKD89OikvLFxuICAgICAgICAgICAgY2xhc3NOYW1lOiBcImF0dHJpYnV0ZVwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBWQVJJQUJMRSxcbiAgICAgICAgICBobGpzLlFVT1RFX1NUUklOR19NT0RFLFxuICAgICAgICAgIGhsanMuQVBPU19TVFJJTkdfTU9ERSxcbiAgICAgICAgICBtb2Rlcy5IRVhDT0xPUixcbiAgICAgICAgICBtb2Rlcy5DU1NfTlVNQkVSX01PREVcbiAgICAgICAgXVxuICAgICAgfVxuICAgIF1cbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgc2NzcztcbiIsIi8qXG5MYW5ndWFnZTogU2hlbGwgU2Vzc2lvblxuUmVxdWlyZXM6IGJhc2guanNcbkF1dGhvcjogVFNVWVVTQVRPIEtpdHN1bmUgPG1ha2UuanVzdC5vbkBnbWFpbC5jb20+XG5DYXRlZ29yeTogY29tbW9uXG5BdWRpdDogMjAyMFxuKi9cblxuLyoqIEB0eXBlIExhbmd1YWdlRm4gKi9cbmZ1bmN0aW9uIHNoZWxsKGhsanMpIHtcbiAgcmV0dXJuIHtcbiAgICBuYW1lOiAnU2hlbGwgU2Vzc2lvbicsXG4gICAgYWxpYXNlczogWyAnY29uc29sZScsICdzaGVsbHNlc3Npb24nIF0sXG4gICAgY29udGFpbnM6IFtcbiAgICAgIHtcbiAgICAgICAgY2xhc3NOYW1lOiAnbWV0YScsXG4gICAgICAgIC8vIFdlIGNhbm5vdCBhZGQgXFxzIChzcGFjZXMpIGluIHRoZSByZWd1bGFyIGV4cHJlc3Npb24gb3RoZXJ3aXNlIGl0IHdpbGwgYmUgdG9vIGJyb2FkIGFuZCBwcm9kdWNlIHVuZXhwZWN0ZWQgcmVzdWx0LlxuICAgICAgICAvLyBGb3IgaW5zdGFuY2UsIGluIHRoZSBmb2xsb3dpbmcgZXhhbXBsZSwgaXQgd291bGQgbWF0Y2ggXCJlY2hvIC9wYXRoL3RvL2hvbWUgPlwiIGFzIGEgcHJvbXB0OlxuICAgICAgICAvLyBlY2hvIC9wYXRoL3RvL2hvbWUgPiB0LmV4ZVxuICAgICAgICBiZWdpbjogL15cXHN7MCwzfVsvflxcd1xcZFtcXF0oKUAtXSpbPiUkI11bIF0/LyxcbiAgICAgICAgc3RhcnRzOiB7XG4gICAgICAgICAgZW5kOiAvW15cXFxcXSg/PVxccyokKS8sXG4gICAgICAgICAgc3ViTGFuZ3VhZ2U6ICdiYXNoJ1xuICAgICAgICB9XG4gICAgICB9XG4gICAgXVxuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBzaGVsbDtcbiIsIi8qXG5MYW5ndWFnZTogUGxhaW4gdGV4dFxuQXV0aG9yOiBFZ29yIFJvZ292IChlLnJvZ292QHBvc3RncmVzcHJvLnJ1KVxuRGVzY3JpcHRpb246IFBsYWluIHRleHQgd2l0aG91dCBhbnkgaGlnaGxpZ2h0aW5nLlxuQ2F0ZWdvcnk6IGNvbW1vblxuKi9cblxuZnVuY3Rpb24gcGxhaW50ZXh0KGhsanMpIHtcbiAgcmV0dXJuIHtcbiAgICBuYW1lOiAnUGxhaW4gdGV4dCcsXG4gICAgYWxpYXNlczogW1xuICAgICAgJ3RleHQnLFxuICAgICAgJ3R4dCdcbiAgICBdLFxuICAgIGRpc2FibGVBdXRvZGV0ZWN0OiB0cnVlXG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IHBsYWludGV4dDtcbiIsImltcG9ydCBtYXJrZWQgZnJvbSAnbWFya2VkJztcclxuaW1wb3J0IGhpZ2hsaWdodCBmcm9tICdoaWdobGlnaHQuanMvbGliL2NvcmUnO1xyXG5pbXBvcnQgamF2YXNjcmlwdCBmcm9tICdoaWdobGlnaHQuanMvbGliL2xhbmd1YWdlcy9qYXZhc2NyaXB0JztcclxuaW1wb3J0IHNjc3MgZnJvbSAnaGlnaGxpZ2h0LmpzL2xpYi9sYW5ndWFnZXMvc2Nzcyc7XHJcbmltcG9ydCBzaGVsbCBmcm9tICdoaWdobGlnaHQuanMvbGliL2xhbmd1YWdlcy9zaGVsbCc7XHJcbmltcG9ydCBwbGFpbnRleHQgZnJvbSAnaGlnaGxpZ2h0LmpzL2xpYi9sYW5ndWFnZXMvcGxhaW50ZXh0JztcclxuXHJcbmhpZ2hsaWdodC5yZWdpc3Rlckxhbmd1YWdlKCdqYXZhc2NyaXB0JywgamF2YXNjcmlwdCk7XHJcbmhpZ2hsaWdodC5yZWdpc3Rlckxhbmd1YWdlKCdzY3NzJywgc2Nzcyk7XHJcbmhpZ2hsaWdodC5yZWdpc3Rlckxhbmd1YWdlKCdzaGVsbCcsIHNoZWxsKTtcclxuaGlnaGxpZ2h0LnJlZ2lzdGVyTGFuZ3VhZ2UoJ3BsYWludGV4dCcsIHBsYWludGV4dCk7XHJcblxyXG5tYXJrZWQuc2V0T3B0aW9ucyh7XHJcbiAgICBoaWdobGlnaHQ6IGZ1bmN0aW9uKGNvZGUsIGxhbmcpIHtcclxuICAgICAgICBjb25zdCBsYW5ndWFnZSA9IGhpZ2hsaWdodC5nZXRMYW5ndWFnZShsYW5nKSA/IGxhbmcgOiAncGxhaW50ZXh0JztcclxuICAgICAgICByZXR1cm4gaGlnaGxpZ2h0LmhpZ2hsaWdodChjb2RlLCB7IGxhbmd1YWdlIH0pLnZhbHVlO1xyXG4gICAgfSxcclxuICAgIGxhbmdQcmVmaXg6ICdobGpzIGxhbmd1YWdlLSdcclxufSk7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBtYXJrZWQ7IiwiaW1wb3J0IFBhZ2UgZnJvbSAnQC9jb21wb25lbnRzL1BhZ2UnO1xyXG5pbXBvcnQgbWFya2Rvd24gZnJvbSAnQC91dGlscy9tYXJrZG93bic7XHJcblxyXG5pbXBvcnQgcmVhZG1lIGZyb20gJy4uLy4uLy4uLy4uL1JFQURNRS5tZCc7XHJcblxyXG5pbXBvcnQgJy4vaW5kZXguc2Nzcyc7XHJcblxyXG5jb25zdCBodG1sID0gbWFya2Rvd24ocmVhZG1lKTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIEhvbWVQYWdlKCkge1xyXG4gICAgcmV0dXJuIChcclxuICAgICAgICA8UGFnZSBpZD1cImhvbWVcIj5cclxuICAgICAgICAgICAgPGFydGljbGVcclxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZT1cIm1hcmtkb3duXCJcclxuICAgICAgICAgICAgICAgIGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MPXt7IF9faHRtbDogaHRtbCB9fVxyXG4gICAgICAgICAgICAvPlxyXG4gICAgICAgIDwvUGFnZT5cclxuICAgICk7XHJcbn0iLCJpbXBvcnQgeyB1c2VTdGF0ZSB9IGZyb20gJ3JlYWN0JztcclxuaW1wb3J0IHtcclxuICAgIEljb25CdXR0b25cclxufSBmcm9tICdtZGMtcmVhY3QnO1xyXG5cclxuaW1wb3J0IFBhZ2UgZnJvbSAnQC9jb21wb25lbnRzL1BhZ2UnO1xyXG5pbXBvcnQgU2VjdGlvbiBmcm9tICdAL2NvbXBvbmVudHMvU2VjdGlvbic7XHJcbmltcG9ydCBDb2RlIGZyb20gJ0AvY29tcG9uZW50cy9Db2RlJztcclxuXHJcbmNvbnN0IGlkID0gJ2ljb24tYnV0dG9uJztcclxuY29uc3QgdGl0bGUgPSAnSWNvbiBCdXR0b24nO1xyXG5jb25zdCBkZXNjcmlwdGlvbiA9ICdJY29uIGJ1dHRvbnMgYWxsb3cgdXNlcnMgdG8gdGFrZSBhY3Rpb25zLCBhbmQgbWFrZSBjaG9pY2VzLCB3aXRoIGEgc2luZ2xlIHRhcC4nO1xyXG5jb25zdCBsaW5rcyA9IHtcclxuICAgIGRvY3M6ICdodHRwczovL2dpdGh1Yi5jb20vbWF0ZXJpYWwtY29tcG9uZW50cy9tYXRlcmlhbC1jb21wb25lbnRzLXdlYi90cmVlL21hc3Rlci9wYWNrYWdlcy9tZGMtaWNvbi1idXR0b24nLFxyXG4gICAgZ3VpZGU6ICdodHRwczovL21hdGVyaWFsLmlvL2NvbXBvbmVudHMvYnV0dG9ucydcclxufTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIEljb25CdXR0b25QYWdlKCkge1xyXG4gICAgY29uc3QgW2lzT24sIHNldE9uXSA9IHVzZVN0YXRlKHRydWUpO1xyXG5cclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgPFBhZ2UgaWQ9e2lkfSB0aXRsZT17dGl0bGV9IGRlc2NyaXB0aW9uPXtkZXNjcmlwdGlvbn0gbGlua3M9e2xpbmtzfT5cclxuICAgICAgICAgICAgPFNlY3Rpb24gdGl0bGU9XCJCYXNpYyBpY29uIGJ1dHRvblwiPlxyXG4gICAgICAgICAgICAgICAgPENvZGU+XHJcbiAgICAgICAgICAgICAgICAgICAgPEljb25CdXR0b25cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWNvbj1cInN0YXJcIlxyXG4gICAgICAgICAgICAgICAgICAgIC8+XHJcbiAgICAgICAgICAgICAgICA8L0NvZGU+XHJcbiAgICAgICAgICAgIDwvU2VjdGlvbj5cclxuXHJcbiAgICAgICAgICAgIDxTZWN0aW9uIHRpdGxlPVwiVG9nZ2xpbmcgaWNvbiBidXR0b25cIj5cclxuICAgICAgICAgICAgICAgIDxDb2RlPlxyXG4gICAgICAgICAgICAgICAgICAgIDxJY29uQnV0dG9uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGljb249e2lzT24gPyAnZmF2b3JpdGUnIDogJ2Zhdm9yaXRlX2JvcmRlcid9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2xpY2s9eygpID0+IHNldE9uKHYgPT4gIXYpfVxyXG4gICAgICAgICAgICAgICAgICAgIC8+XHJcbiAgICAgICAgICAgICAgICA8L0NvZGU+XHJcbiAgICAgICAgICAgIDwvU2VjdGlvbj5cclxuICAgICAgICA8L1BhZ2U+XHJcbiAgICApO1xyXG59IiwiaW1wb3J0IHtcclxuICAgIEltYWdlTGlzdFxyXG59IGZyb20gJ21kYy1yZWFjdCc7XHJcblxyXG5jb25zdCBpZCA9ICdpbWFnZS1saXN0JztcclxuY29uc3QgdGl0bGUgPSAnSW1hZ2UgTGlzdCc7XHJcbmNvbnN0IGRlc2NyaXB0aW9uID0gJ0ltYWdlIGxpc3RzIGRpc3BsYXkgYSBjb2xsZWN0aW9uIG9mIGltYWdlcyBpbiBhbiBvcmdhbml6ZWQgZ3JpZC4nO1xyXG5jb25zdCBsaW5rcyA9IHtcclxuICAgIGRvY3M6ICdodHRwczovL2dpdGh1Yi5jb20vbWF0ZXJpYWwtY29tcG9uZW50cy9tYXRlcmlhbC1jb21wb25lbnRzLXdlYi90cmVlL21hc3Rlci9wYWNrYWdlcy9tZGMtaW1hZ2UtbGlzdCcsXHJcbiAgICBndWlkZTogJ2h0dHBzOi8vbWF0ZXJpYWwuaW8vY29tcG9uZW50cy9pbWFnZS1saXN0cydcclxufTtcclxuXHJcbmltcG9ydCBQYWdlIGZyb20gJ0AvY29tcG9uZW50cy9QYWdlJztcclxuaW1wb3J0IFNlY3Rpb24gZnJvbSAnQC9jb21wb25lbnRzL1NlY3Rpb24nO1xyXG5pbXBvcnQgQ29kZSBmcm9tICdAL2NvbXBvbmVudHMvQ29kZSc7XHJcblxyXG5pbXBvcnQgJy4vaW5kZXguc2Nzcyc7XHJcblxyXG5jb25zdCBzdGFuZGFyZEl0ZW1zID0gbmV3IEFycmF5KDE1KS5maWxsKDEpLm1hcCgoKSA9PiAoe1xyXG4gICAgaW1hZ2VTcmM6ICdodHRwczovL3BsYWNlaW1nLmNvbS8zNjAvMzYwL2FueScsXHJcbiAgICBsYWJlbDogJ1RleHQgTGFiZWwnXHJcbn0pKTtcclxuXHJcbmNvbnN0IG1hc29ucnlJdGVtcyA9IG5ldyBBcnJheSgxNSkuZmlsbCgxKS5tYXAoKCkgPT4gKHtcclxuICAgIGltYWdlU3JjOiBgaHR0cHM6Ly9wbGFjZWltZy5jb20vJHtNYXRoLnJhbmRvbSgpID4gMC41ID8gJzQ4MC8zNjAnIDogJzM2MC80ODAnfS9hbnlgLFxyXG4gICAgbGFiZWw6ICdUZXh0IExhYmVsJ1xyXG59KSk7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBJbWFnZUxpc3RQYWdlKCkge1xyXG4gICAgcmV0dXJuIChcclxuICAgICAgICA8UGFnZSBpZD17aWR9IHRpdGxlPXt0aXRsZX0gZGVzY3JpcHRpb249e2Rlc2NyaXB0aW9ufSBsaW5rcz17bGlua3N9PlxyXG4gICAgICAgICAgICA8U2VjdGlvbiBpZD1cInN0YW5kYXJkLWltYWdlLWxpc3RcIiB0aXRsZT1cIlN0YW5kYXJkIEltYWdlIExpc3RcIj5cclxuICAgICAgICAgICAgICAgIDxDb2RlPlxyXG4gICAgICAgICAgICAgICAgICAgIDxJbWFnZUxpc3Q+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHtzdGFuZGFyZEl0ZW1zLm1hcCgoaXRlbSwgaW5kZXgpID0+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8SW1hZ2VMaXN0Lkl0ZW0ga2V5PXtpbmRleH0gey4uLml0ZW19IC8+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICl9XHJcbiAgICAgICAgICAgICAgICAgICAgPC9JbWFnZUxpc3Q+XHJcbiAgICAgICAgICAgICAgICA8L0NvZGU+XHJcbiAgICAgICAgICAgIDwvU2VjdGlvbj5cclxuXHJcbiAgICAgICAgICAgIDxTZWN0aW9uIGlkPVwic3RhbmRhcmQtaW1hZ2UtbGlzdFwiIHRpdGxlPVwiU3RhbmRhcmQgSW1hZ2UgTGlzdCB3aXRoIFRleHQgUHJvdGVjdGlvblwiPlxyXG4gICAgICAgICAgICAgICAgPENvZGU+XHJcbiAgICAgICAgICAgICAgICAgICAgPEltYWdlTGlzdCB3aXRoVGV4dFByb3RlY3Rpb24+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHtzdGFuZGFyZEl0ZW1zLm1hcCgoaXRlbSwgaW5kZXgpID0+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8SW1hZ2VMaXN0Lkl0ZW0ga2V5PXtpbmRleH0gey4uLml0ZW19IC8+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICl9XHJcbiAgICAgICAgICAgICAgICAgICAgPC9JbWFnZUxpc3Q+XHJcbiAgICAgICAgICAgICAgICA8L0NvZGU+XHJcbiAgICAgICAgICAgIDwvU2VjdGlvbj5cclxuXHJcbiAgICAgICAgICAgIDxTZWN0aW9uIGlkPVwibWFzb25yeS1pbWFnZS1saXN0XCIgdGl0bGU9XCJNYXNvbnJ5IEltYWdlIExpc1wiPlxyXG4gICAgICAgICAgICAgICAgPENvZGU+XHJcbiAgICAgICAgICAgICAgICAgICAgPEltYWdlTGlzdCBtYXNvbnJ5PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB7bWFzb25yeUl0ZW1zLm1hcCgoaXRlbSwgaW5kZXgpID0+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8SW1hZ2VMaXN0Lkl0ZW0ga2V5PXtpbmRleH0gey4uLml0ZW19IC8+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICl9XHJcbiAgICAgICAgICAgICAgICAgICAgPC9JbWFnZUxpc3Q+XHJcbiAgICAgICAgICAgICAgICA8L0NvZGU+XHJcbiAgICAgICAgICAgIDwvU2VjdGlvbj5cclxuXHJcbiAgICAgICAgICAgIDxTZWN0aW9uIGlkPVwibWFzb25yeS1pbWFnZS1saXN0XCIgdGl0bGU9XCJNYXNvbnJ5IEltYWdlIExpc3Qgd2l0aCBUZXh0IFByb3RlY3Rpb25cIj5cclxuICAgICAgICAgICAgICAgIDxDb2RlPlxyXG4gICAgICAgICAgICAgICAgICAgIDxJbWFnZUxpc3QgbWFzb25yeSB3aXRoVGV4dFByb3RlY3Rpb24+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHttYXNvbnJ5SXRlbXMubWFwKChpdGVtLCBpbmRleCkgPT5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxJbWFnZUxpc3QuSXRlbSBrZXk9e2luZGV4fSB7Li4uaXRlbX0gLz5cclxuICAgICAgICAgICAgICAgICAgICAgICAgKX1cclxuICAgICAgICAgICAgICAgICAgICA8L0ltYWdlTGlzdD5cclxuICAgICAgICAgICAgICAgIDwvQ29kZT5cclxuICAgICAgICAgICAgPC9TZWN0aW9uPlxyXG4gICAgICAgIDwvUGFnZT5cclxuICAgICk7XHJcbn0iLCJpbXBvcnQge1xyXG4gICAgTGF5b3V0R3JpZFxyXG59IGZyb20gJ21kYy1yZWFjdCc7XHJcblxyXG5pbXBvcnQgUGFnZSBmcm9tICdAL2NvbXBvbmVudHMvUGFnZSc7XHJcbmltcG9ydCBTZWN0aW9uIGZyb20gJ0AvY29tcG9uZW50cy9TZWN0aW9uJztcclxuaW1wb3J0IENvZGUgZnJvbSAnQC9jb21wb25lbnRzL0NvZGUnO1xyXG5cclxuaW1wb3J0ICcuL2luZGV4LnNjc3MnO1xyXG5cclxuY29uc3QgaWQgPSAnbGF5b3V0LWdyaWQnO1xyXG5jb25zdCB0aXRsZSA9ICdMYXlvdXQgR3JpZCc7XHJcbmNvbnN0IGRlc2NyaXB0aW9uID0gJ01hdGVyaWFsIGRlc2lnbuKAmXMgcmVzcG9uc2l2ZSBVSSBpcyBiYXNlZCBvbiBhIDEyLWNvbHVtbiBncmlkIGxheW91dC4nO1xyXG5jb25zdCBsaW5rcyA9IHtcclxuICAgIGRvY3M6ICdodHRwczovL2dpdGh1Yi5jb20vbWF0ZXJpYWwtY29tcG9uZW50cy9tYXRlcmlhbC1jb21wb25lbnRzLXdlYi90cmVlL21hc3Rlci9wYWNrYWdlcy9tZGMtbGF5b3V0LWdyaWQnLFxyXG4gICAgZ3VpZGU6ICdodHRwczovL21hdGVyaWFsLmlvL2Rlc2lnbi9sYXlvdXQvcmVzcG9uc2l2ZS1sYXlvdXQtZ3JpZC5odG1sJ1xyXG59O1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gTGF5b3V0R3JpZFBhZ2UoKSB7XHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAgIDxQYWdlIGlkPXtpZH0gdGl0bGU9e3RpdGxlfSBkZXNjcmlwdGlvbj17ZGVzY3JpcHRpb259IGxpbmtzPXtsaW5rc30+XHJcbiAgICAgICAgICAgIDxTZWN0aW9uIHRpdGxlPVwiQmFzaWMgZ3JpZFwiPlxyXG4gICAgICAgICAgICAgICAgPENvZGU+XHJcbiAgICAgICAgICAgICAgICAgICAgPExheW91dEdyaWQ+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxMYXlvdXRHcmlkLkNlbGwgc3Bhbj1cIjZcIiAvPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8TGF5b3V0R3JpZC5DZWxsIHNwYW49XCIzXCIgLz5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPExheW91dEdyaWQuQ2VsbCBzcGFuPVwiMlwiIC8+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxMYXlvdXRHcmlkLkNlbGwgc3Bhbj1cIjFcIiAvPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8TGF5b3V0R3JpZC5DZWxsIHNwYW49XCIzXCIgLz5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPExheW91dEdyaWQuQ2VsbCBzcGFuPVwiMVwiIC8+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxMYXlvdXRHcmlkLkNlbGwgc3Bhbj1cIjhcIiAvPlxyXG4gICAgICAgICAgICAgICAgICAgIDwvTGF5b3V0R3JpZD5cclxuICAgICAgICAgICAgICAgIDwvQ29kZT5cclxuICAgICAgICAgICAgPC9TZWN0aW9uPlxyXG5cclxuICAgICAgICAgICAgPFNlY3Rpb24gdGl0bGU9XCJOZXN0ZWQgZ3JpZFwiPlxyXG4gICAgICAgICAgICAgICAgPENvZGU+XHJcbiAgICAgICAgICAgICAgICAgICAgPExheW91dEdyaWQ+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxMYXlvdXRHcmlkLkNlbGwgZ3JpZD5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxMYXlvdXRHcmlkLkNlbGwgLz5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxMYXlvdXRHcmlkLkNlbGwgLz5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxMYXlvdXRHcmlkLkNlbGwgLz5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPC9MYXlvdXRHcmlkLkNlbGw+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxMYXlvdXRHcmlkLkNlbGwgLz5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPExheW91dEdyaWQuQ2VsbCAvPlxyXG4gICAgICAgICAgICAgICAgICAgIDwvTGF5b3V0R3JpZD5cclxuICAgICAgICAgICAgICAgIDwvQ29kZT5cclxuICAgICAgICAgICAgPC9TZWN0aW9uPlxyXG4gICAgICAgIDwvUGFnZT5cclxuICAgICk7XHJcbn0iLCJpbXBvcnQgeyB1c2VTdGF0ZSB9IGZyb20gJ3JlYWN0JztcclxuaW1wb3J0IHtcclxuICAgIEJ1dHRvbixcclxuICAgIExpbmVhclByb2dyZXNzXHJcbn0gZnJvbSAnbWRjLXJlYWN0JztcclxuXHJcbmltcG9ydCBQYWdlIGZyb20gJ0AvY29tcG9uZW50cy9QYWdlJztcclxuaW1wb3J0IFNlY3Rpb24gZnJvbSAnQC9jb21wb25lbnRzL1NlY3Rpb24nO1xyXG5pbXBvcnQgQ29kZSBmcm9tICdAL2NvbXBvbmVudHMvQ29kZSc7XHJcblxyXG5jb25zdCBpZCA9ICdsaW5lYXItcHJvZ3Jlc3MnO1xyXG5jb25zdCB0aXRsZSA9ICdMaW5lYXIgUHJvZ3Jlc3MnO1xyXG5jb25zdCBkZXNjcmlwdGlvbiA9ICdQcm9ncmVzcyBpbmRpY2F0b3JzIGRpc3BsYXkgdGhlIGxlbmd0aCBvZiBhIHByb2Nlc3Mgb3IgZXhwcmVzcyBhbiB1bnNwZWNpZmllZCB3YWl0IHRpbWUuJztcclxuY29uc3QgbGlua3MgPSB7XHJcbiAgICBkb2NzOiAnJyxcclxuICAgIGd1aWRlOiAnJ1xyXG59O1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gTGluZWFyUHJvZ3Jlc3NQYWdlKCkge1xyXG4gICAgY29uc3QgW2lzQ2xvc2VkLCBzZXRDbG9zZWRdID0gdXNlU3RhdGUodHJ1ZSk7XHJcblxyXG4gICAgcmV0dXJuIChcclxuICAgICAgICA8UGFnZSBpZD17aWR9IHRpdGxlPXt0aXRsZX0gZGVzY3JpcHRpb249e2Rlc2NyaXB0aW9ufSBsaW5rcz17bGlua3N9PlxyXG4gICAgICAgICAgICA8U2VjdGlvbiB0aXRsZT1cIkJhc2ljIGxpbmVhciBwcm9ncmVzc1wiPlxyXG4gICAgICAgICAgICAgICAgPENvZGU+XHJcbiAgICAgICAgICAgICAgICAgICAgPExpbmVhclByb2dyZXNzIHZhbHVlPVwiNDJcIiAvPlxyXG4gICAgICAgICAgICAgICAgPC9Db2RlPlxyXG4gICAgICAgICAgICA8L1NlY3Rpb24+XHJcblxyXG4gICAgICAgICAgICA8U2VjdGlvbiB0aXRsZT1cIkxpbmVhciBwcm9ncmVzcyB3aXRoIGEgYnVmZmVyXCI+XHJcbiAgICAgICAgICAgICAgICA8Q29kZT5cclxuICAgICAgICAgICAgICAgICAgICA8TGluZWFyUHJvZ3Jlc3MgdmFsdWU9XCI0MlwiIGJ1ZmZlcj1cIjg0XCIgLz5cclxuICAgICAgICAgICAgICAgIDwvQ29kZT5cclxuICAgICAgICAgICAgPC9TZWN0aW9uPlxyXG5cclxuICAgICAgICAgICAgPFNlY3Rpb24gdGl0bGU9XCJJbmRldGVybWluYXRlIGxpbmVhciBwcm9ncmVzc1wiPlxyXG4gICAgICAgICAgICAgICAgPENvZGU+XHJcbiAgICAgICAgICAgICAgICAgICAgPExpbmVhclByb2dyZXNzIGluZGV0ZXJtaW5hdGUgLz5cclxuICAgICAgICAgICAgICAgIDwvQ29kZT5cclxuICAgICAgICAgICAgPC9TZWN0aW9uPlxyXG5cclxuICAgICAgICAgICAgPFNlY3Rpb24gdGl0bGU9XCJDbG9zZWQgbGluZWFyIHByb2dyZXNzXCI+XHJcbiAgICAgICAgICAgICAgICA8Q29kZVxyXG4gICAgICAgICAgICAgICAgICAgIHNldHVwPXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgPEJ1dHRvbiBvbkNsaWNrPXsoKSA9PiBzZXRDbG9zZWQodiA9PiAhdil9PlRvZ2dsZTwvQnV0dG9uPlxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgID5cclxuICAgICAgICAgICAgICAgICAgICA8TGluZWFyUHJvZ3Jlc3MgY2xvc2VkPXtpc0Nsb3NlZH0gdmFsdWU9XCI0MlwiIC8+XHJcbiAgICAgICAgICAgICAgICA8L0NvZGU+XHJcbiAgICAgICAgICAgIDwvU2VjdGlvbj5cclxuICAgICAgICA8L1BhZ2U+XHJcbiAgICApO1xyXG59IiwiaW1wb3J0IHtcclxuICAgIENoZWNrYm94LFxyXG4gICAgSWNvbixcclxuICAgIExpc3QsIExpc3RJdGVtLFxyXG4gICAgUmFkaW8sXHJcbiAgICBTd2l0Y2hcclxufSBmcm9tICdtZGMtcmVhY3QnO1xyXG5cclxuaW1wb3J0IFBhZ2UgZnJvbSAnQC9jb21wb25lbnRzL1BhZ2UnO1xyXG5pbXBvcnQgU2VjdGlvbiBmcm9tICdAL2NvbXBvbmVudHMvU2VjdGlvbic7XHJcbmltcG9ydCBDb2RlIGZyb20gJ0AvY29tcG9uZW50cy9Db2RlJztcclxuXHJcbmNvbnN0IGlkID0gJ2xpc3QnO1xyXG5jb25zdCB0aXRsZSA9ICdMaXN0JztcclxuY29uc3QgZGVzY3JpcHRpb24gPSAnTGlzdHMgcHJlc2VudCBtdWx0aXBsZSBsaW5lIGl0ZW1zIHZlcnRpY2FsbHkgYXMgYSBzaW5nbGUgY29udGludW91cyBlbGVtZW50Lic7XHJcbmNvbnN0IGxpbmtzID0ge1xyXG4gICAgZG9jczogJ2h0dHBzOi8vZ2l0aHViLmNvbS9tYXRlcmlhbC1jb21wb25lbnRzL21hdGVyaWFsLWNvbXBvbmVudHMtd2ViL3RyZWUvbWFzdGVyL3BhY2thZ2VzL21kYy1saXN0JyxcclxuICAgIGd1aWRlOiAnaHR0cHM6Ly9tYXRlcmlhbC5pby9jb21wb25lbnRzL2xpc3RzJ1xyXG59O1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gTGlzdFBhZ2UoKSB7XHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAgIDxQYWdlIGlkPXtpZH0gdGl0bGU9e3RpdGxlfSBkZXNjcmlwdGlvbj17ZGVzY3JpcHRpb259IGxpbmtzPXtsaW5rc30+XHJcbiAgICAgICAgICAgIDxTZWN0aW9uIHRpdGxlPVwiU2luZ2xlLWxpbmUgbGlzdFwiPlxyXG4gICAgICAgICAgICAgICAgPENvZGU+XHJcbiAgICAgICAgICAgICAgICAgICAgPExpc3Q+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxMaXN0SXRlbVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dD1cIkl0ZW0gMVwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8+XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8TGlzdEl0ZW1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ9XCJJdGVtIDJcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvPlxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPExpc3RJdGVtXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0PVwiSXRlbSAzXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgLz5cclxuICAgICAgICAgICAgICAgICAgICA8L0xpc3Q+XHJcbiAgICAgICAgICAgICAgICA8L0NvZGU+XHJcbiAgICAgICAgICAgIDwvU2VjdGlvbj5cclxuXHJcbiAgICAgICAgICAgIDxTZWN0aW9uIHRpdGxlPVwiVHdvLWxpbmUgbGlzdFwiPlxyXG4gICAgICAgICAgICAgICAgPENvZGU+XHJcbiAgICAgICAgICAgICAgICAgICAgPExpc3Q+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxMaXN0SXRlbVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJpbWFyeVRleHQ9XCJJdGVtIDFcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2Vjb25kYXJ5VGV4dD1cIlNlY29uZGFyeSB0ZXh0XCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgLz5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxMaXN0SXRlbVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJpbWFyeVRleHQ9XCJJdGVtIDJcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2Vjb25kYXJ5VGV4dD1cIlNlY29uZGFyeSB0ZXh0XCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgLz5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxMaXN0SXRlbVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJpbWFyeVRleHQ9XCJJdGVtIDNcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2Vjb25kYXJ5VGV4dD1cIlNlY29uZGFyeSB0ZXh0XCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgLz5cclxuICAgICAgICAgICAgICAgICAgICA8L0xpc3Q+XHJcbiAgICAgICAgICAgICAgICA8L0NvZGU+XHJcblxyXG4gICAgICAgICAgICAgICAgPENvZGU+XHJcbiAgICAgICAgICAgICAgICAgICAgPExpc3Q+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxMaXN0SXRlbVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3ZlcmxpbmVUZXh0PVwiT3ZlcmxpbmVcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJpbWFyeVRleHQ9XCJJdGVtIDFcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvPlxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPExpc3RJdGVtXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdmVybGluZVRleHQ9XCJPdmVybGluZVwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmltYXJ5VGV4dD1cIkl0ZW0gMlwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8+XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8TGlzdEl0ZW1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG92ZXJsaW5lVGV4dD1cIk92ZXJsaW5lXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByaW1hcnlUZXh0PVwiSXRlbSAzXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgLz5cclxuICAgICAgICAgICAgICAgICAgICA8L0xpc3Q+XHJcbiAgICAgICAgICAgICAgICA8L0NvZGU+XHJcbiAgICAgICAgICAgIDwvU2VjdGlvbj5cclxuXHJcbiAgICAgICAgICAgIDxTZWN0aW9uIHRpdGxlPVwiVGhyZWUtbGluZSBsaXN0XCI+XHJcbiAgICAgICAgICAgICAgICA8Q29kZT5cclxuICAgICAgICAgICAgICAgICAgICA8TGlzdD5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPExpc3RJdGVtXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdmVybGluZVRleHQ9XCJPdmVybGluZVwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmltYXJ5VGV4dD1cIkl0ZW0gMVwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWNvbmRhcnlUZXh0PVwiU2Vjb25kYXJ5IHRleHRcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvPlxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPExpc3RJdGVtXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdmVybGluZVRleHQ9XCJPdmVybGluZVwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmltYXJ5VGV4dD1cIkl0ZW0gMlwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWNvbmRhcnlUZXh0PVwiU2Vjb25kYXJ5IHRleHRcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvPlxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPExpc3RJdGVtXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdmVybGluZVRleHQ9XCJPdmVybGluZVwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmltYXJ5VGV4dD1cIkl0ZW0gM1wiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWNvbmRhcnlUZXh0PVwiU2Vjb25kYXJ5IHRleHRcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvPlxyXG4gICAgICAgICAgICAgICAgICAgIDwvTGlzdD5cclxuICAgICAgICAgICAgICAgIDwvQ29kZT5cclxuICAgICAgICAgICAgPC9TZWN0aW9uPlxyXG5cclxuICAgICAgICAgICAgPFNlY3Rpb24gdGl0bGU9XCJMaXN0IHdpdGggaWNvbnNcIj5cclxuICAgICAgICAgICAgICAgIDxDb2RlPlxyXG4gICAgICAgICAgICAgICAgICAgIDxMaXN0PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8TGlzdEl0ZW1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGljb249XCJzdGFyXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ9XCJJdGVtIDFcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvPlxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPExpc3RJdGVtXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpY29uPVwic3RhclwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0PVwiSXRlbSAyXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgLz5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxMaXN0SXRlbVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWNvbj1cInN0YXJcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dD1cIkl0ZW0gM1wiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8+XHJcbiAgICAgICAgICAgICAgICAgICAgPC9MaXN0PlxyXG4gICAgICAgICAgICAgICAgPC9Db2RlPlxyXG4gICAgICAgICAgICA8L1NlY3Rpb24+XHJcblxyXG4gICAgICAgICAgICA8U2VjdGlvbiB0aXRsZT1cIkxpc3Qgd2l0aCBpbWFnZXNcIj5cclxuICAgICAgICAgICAgICAgIDxDb2RlPlxyXG4gICAgICAgICAgICAgICAgICAgIDxMaXN0PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8TGlzdEl0ZW1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGltYWdlPXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8aW1nIHNyYz1cImh0dHBzOi8vcGxhY2VpbWcuY29tLzU2LzU2L2FueVwiIC8+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0PVwiSXRlbSAxXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgLz5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxMaXN0SXRlbVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW1hZ2U9e1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxpbWcgc3JjPVwiaHR0cHM6Ly9wbGFjZWltZy5jb20vNTYvNTYvYW55XCIgLz5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ9XCJJdGVtIDJcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvPlxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPExpc3RJdGVtXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbWFnZT17XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGltZyBzcmM9XCJodHRwczovL3BsYWNlaW1nLmNvbS81Ni81Ni9hbnlcIiAvPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dD1cIkl0ZW0gM1wiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8+XHJcbiAgICAgICAgICAgICAgICAgICAgPC9MaXN0PlxyXG4gICAgICAgICAgICAgICAgPC9Db2RlPlxyXG4gICAgICAgICAgICA8L1NlY3Rpb24+XHJcblxyXG4gICAgICAgICAgICA8U2VjdGlvbiB0aXRsZT1cIkxpc3Qgd2l0aCB0aHVtYm5haWxzXCI+XHJcbiAgICAgICAgICAgICAgICA8Q29kZT5cclxuICAgICAgICAgICAgICAgICAgICA8TGlzdD5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPExpc3RJdGVtXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHVtYm5haWw9e1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxpbWcgc3JjPVwiaHR0cHM6Ly9wbGFjZWltZy5jb20vNDAvNDAvcGVvcGxlXCIgLz5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ9XCJJdGVtIDFcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvPlxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPExpc3RJdGVtXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHVtYm5haWw9e1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxpbWcgc3JjPVwiaHR0cHM6Ly9wbGFjZWltZy5jb20vNDAvNDAvcGVvcGxlXCIgLz5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ9XCJJdGVtIDJcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvPlxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPExpc3RJdGVtXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHVtYm5haWw9e1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxpbWcgc3JjPVwiaHR0cHM6Ly9wbGFjZWltZy5jb20vNDAvNDAvcGVvcGxlXCIgLz5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ9XCJJdGVtIDNcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvPlxyXG4gICAgICAgICAgICAgICAgICAgIDwvTGlzdD5cclxuICAgICAgICAgICAgICAgIDwvQ29kZT5cclxuICAgICAgICAgICAgPC9TZWN0aW9uPlxyXG5cclxuICAgICAgICAgICAgPFNlY3Rpb24gdGl0bGU9XCJMaXN0IHdpdGggdmlkZW9zXCI+XHJcbiAgICAgICAgICAgICAgICA8Q29kZT5cclxuICAgICAgICAgICAgICAgICAgICA8TGlzdD5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPExpc3RJdGVtXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2aWRlbz17XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGltZyBzcmM9XCJodHRwczovL3BsYWNlaW1nLmNvbS8xMDAvNTYvcGVvcGxlXCIgLz5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ9XCJJdGVtIDFcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvPlxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPExpc3RJdGVtXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2aWRlbz17XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGltZyBzcmM9XCJodHRwczovL3BsYWNlaW1nLmNvbS8xMDAvNTYvcGVvcGxlXCIgLz5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ9XCJJdGVtIDJcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvPlxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPExpc3RJdGVtXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2aWRlbz17XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGltZyBzcmM9XCJodHRwczovL3BsYWNlaW1nLmNvbS8xMDAvNTYvcGVvcGxlXCIgLz5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ9XCJJdGVtIDNcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvPlxyXG4gICAgICAgICAgICAgICAgICAgIDwvTGlzdD5cclxuICAgICAgICAgICAgICAgIDwvQ29kZT5cclxuICAgICAgICAgICAgPC9TZWN0aW9uPlxyXG5cclxuICAgICAgICAgICAgPFNlY3Rpb24gdGl0bGU9XCJMaXN0IHdpdGggY2hlY2tib3hlc1wiPlxyXG4gICAgICAgICAgICAgICAgPENvZGU+XHJcbiAgICAgICAgICAgICAgICAgICAgPExpc3Q+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxMaXN0SXRlbVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGVhZGluZ0NoZWNrYm94PXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8Q2hlY2tib3ggZGVmYXVsdENoZWNrZWQ9e2ZhbHNlfSAvPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dD1cIkl0ZW0gMVwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8+XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8TGlzdEl0ZW1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxlYWRpbmdDaGVja2JveD17XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPENoZWNrYm94IGRlZmF1bHRDaGVja2VkPXtmYWxzZX0gLz5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ9XCJJdGVtIDJcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvPlxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPExpc3RJdGVtXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZWFkaW5nQ2hlY2tib3g9e1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxDaGVja2JveCBkZWZhdWx0Q2hlY2tlZD17ZmFsc2V9IC8+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0PVwiSXRlbSAzXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgLz5cclxuICAgICAgICAgICAgICAgICAgICA8L0xpc3Q+XHJcbiAgICAgICAgICAgICAgICA8L0NvZGU+XHJcbiAgICAgICAgICAgIDwvU2VjdGlvbj5cclxuXHJcbiAgICAgICAgICAgIDxTZWN0aW9uIHRpdGxlPVwiTGlzdCB3aXRoIHJhZGlvc1wiPlxyXG4gICAgICAgICAgICAgICAgPENvZGU+XHJcbiAgICAgICAgICAgICAgICAgICAgPExpc3Q+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxMaXN0SXRlbVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGVhZGluZ1JhZGlvPXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8UmFkaW8gLz5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ9XCJJdGVtIDFcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvPlxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPExpc3RJdGVtXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZWFkaW5nUmFkaW89e1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxSYWRpbyBjaGVja2VkIC8+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0PVwiSXRlbSAyXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgLz5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxMaXN0SXRlbVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGVhZGluZ1JhZGlvPXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8UmFkaW8gLz5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ9XCJJdGVtIDNcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvPlxyXG4gICAgICAgICAgICAgICAgICAgIDwvTGlzdD5cclxuICAgICAgICAgICAgICAgIDwvQ29kZT5cclxuICAgICAgICAgICAgPC9TZWN0aW9uPlxyXG5cclxuICAgICAgICAgICAgPFNlY3Rpb24gdGl0bGU9XCJMaXN0IHdpdGggc3dpdGNoZXNcIj5cclxuICAgICAgICAgICAgICAgIDxDb2RlPlxyXG4gICAgICAgICAgICAgICAgICAgIDxMaXN0PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8TGlzdEl0ZW1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxlYWRpbmdTd2l0Y2g9e1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxTd2l0Y2ggLz5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ9XCJJdGVtIDFcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvPlxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPExpc3RJdGVtXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZWFkaW5nU3dpdGNoPXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8U3dpdGNoIGNoZWNrZWQgLz5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ9XCJJdGVtIDJcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvPlxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPExpc3RJdGVtXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZWFkaW5nU3dpdGNoPXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8U3dpdGNoIC8+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0PVwiSXRlbSAzXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgLz5cclxuICAgICAgICAgICAgICAgICAgICA8L0xpc3Q+XHJcbiAgICAgICAgICAgICAgICA8L0NvZGU+XHJcbiAgICAgICAgICAgIDwvU2VjdGlvbj5cclxuXHJcbiAgICAgICAgICAgIDxTZWN0aW9uIHRpdGxlPVwiTGlzdCB3aXRoIHRyYWlsaW5nIGljb25zXCI+XHJcbiAgICAgICAgICAgICAgICA8Q29kZT5cclxuICAgICAgICAgICAgICAgICAgICA8TGlzdD5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPExpc3RJdGVtXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0PVwiSXRlbSAxXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYWlsaW5nSWNvbj1cImluZm9cIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvPlxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPExpc3RJdGVtXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0PVwiSXRlbSAyXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYWlsaW5nSWNvbj1cImluZm9cIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvPlxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPExpc3RJdGVtXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0PVwiSXRlbSAzXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYWlsaW5nSWNvbj1cImluZm9cIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvPlxyXG4gICAgICAgICAgICAgICAgICAgIDwvTGlzdD5cclxuICAgICAgICAgICAgICAgIDwvQ29kZT5cclxuICAgICAgICAgICAgPC9TZWN0aW9uPlxyXG5cclxuICAgICAgICAgICAgPFNlY3Rpb24gdGl0bGU9XCJMaXN0IHdpdGggdHJhaWxpbmcgbWV0YVwiPlxyXG4gICAgICAgICAgICAgICAgPENvZGU+XHJcbiAgICAgICAgICAgICAgICAgICAgPExpc3Q+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxMaXN0SXRlbVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dD1cIkl0ZW0gMVwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXRhPVwiTWV0YVwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8+XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8TGlzdEl0ZW1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ9XCJJdGVtIDJcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWV0YT1cIk1ldGFcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvPlxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPExpc3RJdGVtXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0PVwiSXRlbSAzXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1ldGE9XCJNZXRhXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgLz5cclxuICAgICAgICAgICAgICAgICAgICA8L0xpc3Q+XHJcbiAgICAgICAgICAgICAgICA8L0NvZGU+XHJcbiAgICAgICAgICAgIDwvU2VjdGlvbj5cclxuXHJcbiAgICAgICAgICAgIDxTZWN0aW9uIHRpdGxlPVwiTGlzdCB3aXRoIHRyYWlsaW5nIGNoZWNrYm94ZXNcIj5cclxuICAgICAgICAgICAgICAgIDxDb2RlPlxyXG4gICAgICAgICAgICAgICAgICAgIDxMaXN0PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8TGlzdEl0ZW1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ9XCJJdGVtIDFcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhaWxpbmdDaGVja2JveD17XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPENoZWNrYm94IC8+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8+XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8TGlzdEl0ZW1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ9XCJJdGVtIDJcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhaWxpbmdDaGVja2JveD17XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPENoZWNrYm94IGNoZWNrZWQgLz5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgLz5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxMaXN0SXRlbVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dD1cIkl0ZW0gM1wiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFpbGluZ0NoZWNrYm94PXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8Q2hlY2tib3ggLz5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgLz5cclxuICAgICAgICAgICAgICAgICAgICA8L0xpc3Q+XHJcbiAgICAgICAgICAgICAgICA8L0NvZGU+XHJcbiAgICAgICAgICAgIDwvU2VjdGlvbj5cclxuXHJcbiAgICAgICAgICAgIDxTZWN0aW9uIHRpdGxlPVwiTGlzdCB3aXRoIHRyYWlsaW5nIHJhZGlvc1wiPlxyXG4gICAgICAgICAgICAgICAgPENvZGU+XHJcbiAgICAgICAgICAgICAgICAgICAgPExpc3Q+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxMaXN0SXRlbVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dD1cIkl0ZW0gMVwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFpbGluZ1JhZGlvPXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8UmFkaW8gLz5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgLz5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxMaXN0SXRlbVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dD1cIkl0ZW0gMlwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFpbGluZ1JhZGlvPXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8UmFkaW8gY2hlY2tlZCAvPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvPlxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPExpc3RJdGVtXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0PVwiSXRlbSAzXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYWlsaW5nUmFkaW89e1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxSYWRpbyAvPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvPlxyXG4gICAgICAgICAgICAgICAgICAgIDwvTGlzdD5cclxuICAgICAgICAgICAgICAgIDwvQ29kZT5cclxuICAgICAgICAgICAgPC9TZWN0aW9uPlxyXG5cclxuICAgICAgICAgICAgPFNlY3Rpb24gdGl0bGU9XCJMaXN0IHdpdGggdHJhaWxpbmcgc3dpdGNoZXNcIj5cclxuICAgICAgICAgICAgICAgIDxDb2RlPlxyXG4gICAgICAgICAgICAgICAgICAgIDxMaXN0PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8TGlzdEl0ZW1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ9XCJJdGVtIDFcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhaWxpbmdTd2l0Y2g9e1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxTd2l0Y2ggLz5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgLz5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxMaXN0SXRlbVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dD1cIkl0ZW0gMlwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFpbGluZ1N3aXRjaD17XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPFN3aXRjaCBzZWxlY3RlZCAvPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvPlxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPExpc3RJdGVtXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0PVwiSXRlbSAzXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYWlsaW5nU3dpdGNoPXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8U3dpdGNoIC8+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8+XHJcbiAgICAgICAgICAgICAgICAgICAgPC9MaXN0PlxyXG4gICAgICAgICAgICAgICAgPC9Db2RlPlxyXG4gICAgICAgICAgICA8L1NlY3Rpb24+XHJcbiAgICAgICAgPC9QYWdlPlxyXG4gICAgKTtcclxufSIsImltcG9ydCB7IHVzZUNhbGxiYWNrLCB1c2VTdGF0ZSB9IGZyb20gJ3JlYWN0JztcclxuaW1wb3J0IHtcclxuICAgIEZvcm1GaWVsZCxcclxuICAgIEJ1dHRvbixcclxuICAgIExheW91dEdyaWQsXHJcbiAgICBNZW51LFxyXG4gICAgUmFkaW8sXHJcbiAgICBUeXBvZ3JhcGh5XHJcbn0gZnJvbSAnbWRjLXJlYWN0JztcclxuXHJcbmltcG9ydCBQYWdlIGZyb20gJ0AvY29tcG9uZW50cy9QYWdlJztcclxuaW1wb3J0IFNlY3Rpb24gZnJvbSAnQC9jb21wb25lbnRzL1NlY3Rpb24nO1xyXG5pbXBvcnQgQ29kZSBmcm9tICdAL2NvbXBvbmVudHMvQ29kZSc7XHJcblxyXG5pbXBvcnQgJy4vaW5kZXguc2Nzcyc7XHJcblxyXG5jb25zdCBpZCA9ICdtZW51JztcclxuY29uc3QgdGl0bGUgPSAnTWVudSc7XHJcbmNvbnN0IGRlc2NyaXB0aW9uID0gJ01lbnVzIGRpc3BsYXkgYSBsaXN0IG9mIGNob2ljZXMgb24gdGVtcG9yYXJ5IHN1cmZhY2VzLic7XHJcbmNvbnN0IGxpbmtzID0ge1xyXG4gICAgZG9jczogJ2h0dHBzOi8vZ2l0aHViLmNvbS9tYXRlcmlhbC1jb21wb25lbnRzL21hdGVyaWFsLWNvbXBvbmVudHMtd2ViL3RyZWUvbWFzdGVyL3BhY2thZ2VzL21kYy1tZW51JyxcclxuICAgIGd1aWRlOiAnaHR0cHM6Ly9tYXRlcmlhbC5pby9jb21wb25lbnRzL21lbnVzJ1xyXG59O1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gTWVudVBhZ2UoKSB7XHJcbiAgICBjb25zdCBbaXNCYXNpY09wZW4sIHNldEJhc2ljT3Blbl0gPSB1c2VTdGF0ZShmYWxzZSk7XHJcbiAgICBjb25zdCBbaXNRdWlja09wZW4sIHNldFF1aWNrT3Blbl0gPSB1c2VTdGF0ZShmYWxzZSk7XHJcbiAgICBjb25zdCBbaXNQZXJzaXN0ZW50T3Blbiwgc2V0UGVyc2lzdGVudE9wZW5dID0gdXNlU3RhdGUoZmFsc2UpO1xyXG4gICAgY29uc3QgW2lzQW5jaG9yZWRPcGVuLCBzZXRBbmNob3JlZE9wZW5dID0gdXNlU3RhdGUoZmFsc2UpO1xyXG4gICAgY29uc3QgW2FuY2hvclBvc2l0aW9uLCBzZXRBbmNob3JQb3NpdGlvbl0gPSB1c2VTdGF0ZShNZW51Lk9yaWdpbi5UT1BfTEVGVCk7XHJcbiAgICBjb25zdCBbYW5jaG9yT3JpZ2luLCBzZXRBbmNob3JPcmlnaW5dID0gdXNlU3RhdGUoTWVudS5PcmlnaW4uVE9QX0xFRlQpO1xyXG4gICAgY29uc3QgW3RyYW5zZm9ybU9yaWdpbiwgc2V0VHJhbnNmb3JtT3JpZ2luXSA9IHVzZVN0YXRlKE1lbnUuT3JpZ2luLlRPUF9MRUZUKTtcclxuXHJcbiAgICBjb25zdCBoYW5kbGVBbmNob3JQb3NpdGlvbkNoYW5nZSA9IHVzZUNhbGxiYWNrKChldmVudCwgdmFsdWUpID0+IHtcclxuICAgICAgICBzZXRBbmNob3JQb3NpdGlvbih2YWx1ZSk7XHJcbiAgICB9LCBbXSk7XHJcblxyXG4gICAgY29uc3QgaGFuZGxlQW5jaG9yT3JpZ2luQ2hhbmdlID0gdXNlQ2FsbGJhY2soKGV2ZW50LCB2YWx1ZSkgPT4ge1xyXG4gICAgICAgIHNldEFuY2hvck9yaWdpbih2YWx1ZSk7XHJcbiAgICB9LCBbXSk7XHJcblxyXG4gICAgY29uc3QgaGFuZGxlVHJhbnNmb3JtT3JpZ2luQ2hhbmdlID0gdXNlQ2FsbGJhY2soKGV2ZW50LCB2YWx1ZSkgPT4ge1xyXG4gICAgICAgIHNldFRyYW5zZm9ybU9yaWdpbih2YWx1ZSk7XHJcbiAgICB9LCBbXSk7XHJcblxyXG4gICAgcmV0dXJuIChcclxuICAgICAgICA8UGFnZSBpZD17aWR9IHRpdGxlPXt0aXRsZX0gZGVzY3JpcHRpb249e2Rlc2NyaXB0aW9ufSBsaW5rcz17bGlua3N9PlxyXG4gICAgICAgICAgICA8U2VjdGlvbiB0aXRsZT1cIkJhc2ljIG1lbnVcIj5cclxuICAgICAgICAgICAgICAgIDxDb2RlPlxyXG4gICAgICAgICAgICAgICAgICAgIDxNZW51XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFuY2hvcj17XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8QnV0dG9uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWw9XCJPcGVuXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRsaW5lZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2xpY2s9eygpID0+IHNldEJhc2ljT3Blbih0cnVlKX1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgb3Blbj17aXNCYXNpY09wZW59XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vZGFsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2xvc2U9eygpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldEJhc2ljT3BlbihmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH19XHJcbiAgICAgICAgICAgICAgICAgICAgPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8TWVudS5JdGVtXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0PVwiRm9vXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgLz5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxNZW51Lkl0ZW1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ9XCJCYXJcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvPlxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPE1lbnUuSXRlbVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dD1cIkJhelwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8+XHJcbiAgICAgICAgICAgICAgICAgICAgPC9NZW51PlxyXG4gICAgICAgICAgICAgICAgPC9Db2RlPlxyXG4gICAgICAgICAgICA8L1NlY3Rpb24+XHJcblxyXG4gICAgICAgICAgICA8U2VjdGlvbiB0aXRsZT1cIlF1aWNrIG1lbnVcIj5cclxuICAgICAgICAgICAgICAgIDxDb2RlPlxyXG4gICAgICAgICAgICAgICAgICAgIDxNZW51XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFuY2hvcj17XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8QnV0dG9uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWw9XCJPcGVuXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRsaW5lZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2xpY2s9eygpID0+IHNldFF1aWNrT3Blbih0cnVlKX1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgb3Blbj17aXNRdWlja09wZW59XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHF1aWNrXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2xvc2U9eygpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldFF1aWNrT3BlbihmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH19XHJcbiAgICAgICAgICAgICAgICAgICAgPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8TWVudS5JdGVtXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0PVwiRm9vXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgLz5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxNZW51Lkl0ZW1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ9XCJCYXJcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvPlxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPE1lbnUuSXRlbVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dD1cIkJhelwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8+XHJcbiAgICAgICAgICAgICAgICAgICAgPC9NZW51PlxyXG4gICAgICAgICAgICAgICAgPC9Db2RlPlxyXG4gICAgICAgICAgICA8L1NlY3Rpb24+XHJcblxyXG4gICAgICAgICAgICA8U2VjdGlvbiB0aXRsZT1cIlBlcnNpc3RlbnQgbWVudVwiPlxyXG4gICAgICAgICAgICAgICAgPENvZGU+XHJcbiAgICAgICAgICAgICAgICAgICAgPE1lbnVcclxuICAgICAgICAgICAgICAgICAgICAgICAgYW5jaG9yPXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxCdXR0b25cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYWJlbD1cIk9wZW5cIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dGxpbmVkXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb25DbGljaz17KCkgPT4gc2V0UGVyc2lzdGVudE9wZW4odiA9PiAhdil9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wZW49e2lzUGVyc2lzdGVudE9wZW59XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBlcnNpc3RlbnRcclxuICAgICAgICAgICAgICAgICAgICA+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxNZW51Lkl0ZW1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ9XCJGb29cIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb25DbGljaz17KCkgPT4gc2V0UGVyc2lzdGVudE9wZW4oZmFsc2UpfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvPlxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPE1lbnUuSXRlbVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dD1cIkJhclwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbkNsaWNrPXsoKSA9PiBzZXRQZXJzaXN0ZW50T3BlbihmYWxzZSl9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8+XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8TWVudS5JdGVtXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0PVwiQmF6XCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2xpY2s9eygpID0+IHNldFBlcnNpc3RlbnRPcGVuKGZhbHNlKX1cclxuICAgICAgICAgICAgICAgICAgICAgICAgLz5cclxuICAgICAgICAgICAgICAgICAgICA8L01lbnU+XHJcbiAgICAgICAgICAgICAgICA8L0NvZGU+XHJcbiAgICAgICAgICAgIDwvU2VjdGlvbj5cclxuXHJcbiAgICAgICAgICAgIDxTZWN0aW9uIGlkPVwibWVudS1vcmlnaW5cIiBjbGFzc05hbWU9e2BvcmlnaW4tLSR7YW5jaG9yUG9zaXRpb24ucmVwbGFjZSgnICcsICctJyl9YH0gdGl0bGU9XCJNZW51IG9yaWdpblwiPlxyXG4gICAgICAgICAgICAgICAgPExheW91dEdyaWQ+XHJcbiAgICAgICAgICAgICAgICAgICAgPExheW91dEdyaWQuQ2VsbD5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPGZpZWxkc2V0PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPFR5cG9ncmFwaHkgZWxlbWVudD1cImxlZ2VuZFwiIHR5cGU9XCJjYXB0aW9uXCIgbm9NYXJnaW4+QW5jaG9yIHBvc2l0aW9uPC9UeXBvZ3JhcGh5PlxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxGb3JtRmllbGQgbGFiZWw9XCJUb3AgbGVmdFwiPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxSYWRpb1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZT17TWVudS5PcmlnaW4uVE9QX0xFRlR9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoZWNrZWQ9e2FuY2hvclBvc2l0aW9uID09PSBNZW51Lk9yaWdpbi5UT1BfTEVGVH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb25DaGFuZ2U9e2hhbmRsZUFuY2hvclBvc2l0aW9uQ2hhbmdlfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L0Zvcm1GaWVsZD5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8Rm9ybUZpZWxkIGxhYmVsPVwiVG9wIHJpZ2h0XCI+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPFJhZGlvXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlPXtNZW51Lk9yaWdpbi5UT1BfUklHSFR9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoZWNrZWQ9e2FuY2hvclBvc2l0aW9uID09PSBNZW51Lk9yaWdpbi5UT1BfUklHSFR9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2hhbmdlPXtoYW5kbGVBbmNob3JQb3NpdGlvbkNoYW5nZX1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9Gb3JtRmllbGQ+XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPEZvcm1GaWVsZCBsYWJlbD1cIkJvdHRvbSBsZWZ0XCI+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPFJhZGlvXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlPXtNZW51Lk9yaWdpbi5CT1RUT01fTEVGVH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hlY2tlZD17YW5jaG9yUG9zaXRpb24gPT09IE1lbnUuT3JpZ2luLkJPVFRPTV9MRUZUfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbkNoYW5nZT17aGFuZGxlQW5jaG9yUG9zaXRpb25DaGFuZ2V9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLz5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvRm9ybUZpZWxkPlxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxGb3JtRmllbGQgbGFiZWw9XCJCb3R0b20gcmlnaHRcIj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8UmFkaW9cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU9e01lbnUuT3JpZ2luLkJPVFRPTV9SSUdIVH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hlY2tlZD17YW5jaG9yUG9zaXRpb24gPT09IE1lbnUuT3JpZ2luLkJPVFRPTV9SSUdIVH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb25DaGFuZ2U9e2hhbmRsZUFuY2hvclBvc2l0aW9uQ2hhbmdlfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L0Zvcm1GaWVsZD5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPC9maWVsZHNldD5cclxuICAgICAgICAgICAgICAgICAgICA8L0xheW91dEdyaWQuQ2VsbD5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgPExheW91dEdyaWQuQ2VsbD5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPGZpZWxkc2V0PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPFR5cG9ncmFwaHkgZWxlbWVudD1cImxlZ2VuZFwiIHR5cGU9XCJjYXB0aW9uXCIgbm9NYXJnaW4+QW5jaG9yIG9yaWdpbjwvVHlwb2dyYXBoeT5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8Rm9ybUZpZWxkIGxhYmVsPVwiVG9wIGxlZnRcIj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8UmFkaW9cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU9e01lbnUuT3JpZ2luLlRPUF9MRUZUfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGVja2VkPXthbmNob3JPcmlnaW4gPT09IE1lbnUuT3JpZ2luLlRPUF9MRUZUfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbkNoYW5nZT17aGFuZGxlQW5jaG9yT3JpZ2luQ2hhbmdlfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L0Zvcm1GaWVsZD5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8Rm9ybUZpZWxkIGxhYmVsPVwiVG9wIHJpZ2h0XCI+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPFJhZGlvXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlPXtNZW51Lk9yaWdpbi5UT1BfUklHSFR9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoZWNrZWQ9e2FuY2hvck9yaWdpbiA9PT0gTWVudS5PcmlnaW4uVE9QX1JJR0hUfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbkNoYW5nZT17aGFuZGxlQW5jaG9yT3JpZ2luQ2hhbmdlfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L0Zvcm1GaWVsZD5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8Rm9ybUZpZWxkIGxhYmVsPVwiQm90dG9tIGxlZnRcIj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8UmFkaW9cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU9e01lbnUuT3JpZ2luLkJPVFRPTV9MRUZUfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGVja2VkPXthbmNob3JPcmlnaW4gPT09IE1lbnUuT3JpZ2luLkJPVFRPTV9MRUZUfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbkNoYW5nZT17aGFuZGxlQW5jaG9yT3JpZ2luQ2hhbmdlfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L0Zvcm1GaWVsZD5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8Rm9ybUZpZWxkIGxhYmVsPVwiQm90dG9tIHJpZ2h0XCI+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPFJhZGlvXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlPXtNZW51Lk9yaWdpbi5CT1RUT01fUklHSFR9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoZWNrZWQ9e2FuY2hvck9yaWdpbiA9PT0gTWVudS5PcmlnaW4uQk9UVE9NX1JJR0hUfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbkNoYW5nZT17aGFuZGxlQW5jaG9yT3JpZ2luQ2hhbmdlfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L0Zvcm1GaWVsZD5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPC9maWVsZHNldD5cclxuICAgICAgICAgICAgICAgICAgICA8L0xheW91dEdyaWQuQ2VsbD5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgPExheW91dEdyaWQuQ2VsbD5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPGZpZWxkc2V0PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPFR5cG9ncmFwaHkgZWxlbWVudD1cImxlZ2VuZFwiIHR5cGU9XCJjYXB0aW9uXCIgbm9NYXJnaW4+VHJhbnNmb3JtIG9yaWdpbjwvVHlwb2dyYXBoeT5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8Rm9ybUZpZWxkIGxhYmVsPVwiVG9wIGxlZnRcIj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8UmFkaW9cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU9e01lbnUuT3JpZ2luLlRPUF9MRUZUfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGVja2VkPXt0cmFuc2Zvcm1PcmlnaW4gPT09IE1lbnUuT3JpZ2luLlRPUF9MRUZUfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbkNoYW5nZT17aGFuZGxlVHJhbnNmb3JtT3JpZ2luQ2hhbmdlfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L0Zvcm1GaWVsZD5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8Rm9ybUZpZWxkIGxhYmVsPVwiVG9wIHJpZ2h0XCI+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPFJhZGlvXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlPXtNZW51Lk9yaWdpbi5UT1BfUklHSFR9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoZWNrZWQ9e3RyYW5zZm9ybU9yaWdpbiA9PT0gTWVudS5PcmlnaW4uVE9QX1JJR0hUfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbkNoYW5nZT17aGFuZGxlVHJhbnNmb3JtT3JpZ2luQ2hhbmdlfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L0Zvcm1GaWVsZD5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8Rm9ybUZpZWxkIGxhYmVsPVwiQm90dG9tIGxlZnRcIj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8UmFkaW9cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU9e01lbnUuT3JpZ2luLkJPVFRPTV9MRUZUfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGVja2VkPXt0cmFuc2Zvcm1PcmlnaW4gPT09IE1lbnUuT3JpZ2luLkJPVFRPTV9MRUZUfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbkNoYW5nZT17aGFuZGxlVHJhbnNmb3JtT3JpZ2luQ2hhbmdlfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L0Zvcm1GaWVsZD5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8Rm9ybUZpZWxkIGxhYmVsPVwiQm90dG9tIHJpZ2h0XCI+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPFJhZGlvXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlPXtNZW51Lk9yaWdpbi5CT1RUT01fUklHSFR9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoZWNrZWQ9e3RyYW5zZm9ybU9yaWdpbiA9PT0gTWVudS5PcmlnaW4uQk9UVE9NX1JJR0hUfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbkNoYW5nZT17aGFuZGxlVHJhbnNmb3JtT3JpZ2luQ2hhbmdlfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L0Zvcm1GaWVsZD5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPC9maWVsZHNldD5cclxuICAgICAgICAgICAgICAgICAgICA8L0xheW91dEdyaWQuQ2VsbD5cclxuICAgICAgICAgICAgICAgIDwvTGF5b3V0R3JpZD5cclxuXHJcbiAgICAgICAgICAgICAgICA8Q29kZT5cclxuICAgICAgICAgICAgICAgICAgICA8TWVudVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBhbmNob3I9e1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPEJ1dHRvblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsPXtpc1BlcnNpc3RlbnRPcGVuID8gJ0Nsb3NlJyA6ICdPcGVuJ31cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRsaW5lZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2xpY2s9eygpID0+IHNldEFuY2hvcmVkT3Blbih2ID0+ICF2KX1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgYW5jaG9yT3JpZ2luPXthbmNob3JPcmlnaW59XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybU9yaWdpbj17dHJhbnNmb3JtT3JpZ2lufVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBvcGVuPXtpc0FuY2hvcmVkT3Blbn1cclxuICAgICAgICAgICAgICAgICAgICAgICAgb25DbG9zZT17KCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0QW5jaG9yZWRPcGVuKGZhbHNlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfX1cclxuICAgICAgICAgICAgICAgICAgICA+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxNZW51Lkl0ZW1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ9XCJGb29cIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvPlxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPE1lbnUuSXRlbVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dD1cIkJhclwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8+XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8TWVudS5JdGVtXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0PVwiQmF6XCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgLz5cclxuICAgICAgICAgICAgICAgICAgICA8L01lbnU+XHJcbiAgICAgICAgICAgICAgICA8L0NvZGU+XHJcbiAgICAgICAgICAgIDwvU2VjdGlvbj5cclxuICAgICAgICA8L1BhZ2U+XHJcbiAgICApO1xyXG59IiwiaW1wb3J0IHsgdXNlQ2FsbGJhY2ssIHVzZVN0YXRlIH0gZnJvbSAncmVhY3QnO1xyXG5pbXBvcnQge1xyXG4gICAgRm9ybUZpZWxkLFxyXG4gICAgUmFkaW9cclxufSBmcm9tICdtZGMtcmVhY3QnO1xyXG5cclxuaW1wb3J0IFBhZ2UgZnJvbSAnQC9jb21wb25lbnRzL1BhZ2UnO1xyXG5pbXBvcnQgU2VjdGlvbiBmcm9tICdAL2NvbXBvbmVudHMvU2VjdGlvbic7XHJcbmltcG9ydCBDb2RlIGZyb20gJ0AvY29tcG9uZW50cy9Db2RlJztcclxuXHJcbmNvbnN0IGlkID0gJ3JhZGlvJztcclxuY29uc3QgdGl0bGUgPSAnUmFkaW8nO1xyXG5jb25zdCBkZXNjcmlwdGlvbiA9ICdSYWRpbyBidXR0b25zIGFsbG93IHVzZXJzIHRvIHNlbGVjdCBvbmUgb3B0aW9uIGZyb20gYSBzZXQuJztcclxuY29uc3QgbGlua3MgPSB7XHJcbiAgICBkb2NzOiAnaHR0cHM6Ly9naXRodWIuY29tL21hdGVyaWFsLWNvbXBvbmVudHMvbWF0ZXJpYWwtY29tcG9uZW50cy13ZWIvdHJlZS9tYXN0ZXIvcGFja2FnZXMvbWRjLXJhZGlvJyxcclxuICAgIGd1aWRlOiAnaHR0cHM6Ly9tYXRlcmlhbC5pby9jb21wb25lbnRzL3JhZGlvLWJ1dHRvbnMnXHJcbn07XHJcblxyXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBSYWRpb1BhZ2UoKSB7XHJcbiAgICBjb25zdCBbdmFsdWUxLCBzZXRWYWx1ZTFdID0gdXNlU3RhdGUoJ3llcycpO1xyXG4gICAgY29uc3QgW3ZhbHVlMiwgc2V0VmFsdWUyXSA9IHVzZVN0YXRlKCd5ZXMnKTtcclxuXHJcbiAgICBjb25zdCBoYW5kbGVDaGFuZ2UxID0gdXNlQ2FsbGJhY2soKGV2ZW50LCB2YWx1ZSkgPT4ge1xyXG4gICAgICAgIHNldFZhbHVlMSh2YWx1ZSk7XHJcbiAgICB9LCBbXSk7XHJcblxyXG4gICAgY29uc3QgaGFuZGxlQ2hhbmdlMiA9IHVzZUNhbGxiYWNrKChldmVudCwgdmFsdWUpID0+IHtcclxuICAgICAgICBzZXRWYWx1ZTIodmFsdWUpO1xyXG4gICAgfSwgW10pO1xyXG5cclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgPFBhZ2UgaWQ9e2lkfSB0aXRsZT17dGl0bGV9IGRlc2NyaXB0aW9uPXtkZXNjcmlwdGlvbn0gbGlua3M9e2xpbmtzfT5cclxuICAgICAgICAgICAgPFNlY3Rpb24gdGl0bGU9XCJCYXNpYyByYWRpb1wiPlxyXG4gICAgICAgICAgICAgICAgPENvZGU+XHJcbiAgICAgICAgICAgICAgICAgICAgPEZvcm1GaWVsZCBsYWJlbD1cIlllc1wiPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8UmFkaW9cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU9XCJhbnN3ZXIxXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlPVwieWVzXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoZWNrZWQ9e3ZhbHVlMSA9PT0gJ3llcyd9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbkNoYW5nZT17aGFuZGxlQ2hhbmdlMX1cclxuICAgICAgICAgICAgICAgICAgICAgICAgLz5cclxuICAgICAgICAgICAgICAgICAgICA8L0Zvcm1GaWVsZD5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgPEZvcm1GaWVsZCBsYWJlbD1cIk5vXCI+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxSYWRpb1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZT1cImFuc3dlcjFcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU9XCJub1wiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGVja2VkPXt2YWx1ZTEgPT09ICdubyd9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbkNoYW5nZT17aGFuZGxlQ2hhbmdlMX1cclxuICAgICAgICAgICAgICAgICAgICAgICAgLz5cclxuICAgICAgICAgICAgICAgICAgICA8L0Zvcm1GaWVsZD5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgPEZvcm1GaWVsZCBsYWJlbD1cIk1heWJlXCI+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxSYWRpb1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZT1cImFuc3dlcjFcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU9XCJtYXliZVwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGVja2VkPXt2YWx1ZTEgPT09ICdtYXliZSd9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbkNoYW5nZT17aGFuZGxlQ2hhbmdlMX1cclxuICAgICAgICAgICAgICAgICAgICAgICAgLz5cclxuICAgICAgICAgICAgICAgICAgICA8L0Zvcm1GaWVsZD5cclxuICAgICAgICAgICAgICAgIDwvQ29kZT5cclxuICAgICAgICAgICAgPC9TZWN0aW9uPlxyXG5cclxuICAgICAgICAgICAgPFNlY3Rpb24gdGl0bGU9XCJEaXNhYmxlZCByYWRpb1wiPlxyXG4gICAgICAgICAgICAgICAgPENvZGU+XHJcbiAgICAgICAgICAgICAgICAgICAgPEZvcm1GaWVsZCBsYWJlbD1cIlllc1wiPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8UmFkaW9cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU9XCJhbnN3ZXIyXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlPVwieWVzXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoZWNrZWQ9e3ZhbHVlMiA9PT0gJ3llcyd9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbkNoYW5nZT17aGFuZGxlQ2hhbmdlMn1cclxuICAgICAgICAgICAgICAgICAgICAgICAgLz5cclxuICAgICAgICAgICAgICAgICAgICA8L0Zvcm1GaWVsZD5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgPEZvcm1GaWVsZCBsYWJlbD1cIk5vXCI+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxSYWRpb1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZT1cImFuc3dlcjJcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU9XCJub1wiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGVja2VkPXt2YWx1ZTIgPT09ICdubyd9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbkNoYW5nZT17aGFuZGxlQ2hhbmdlMn1cclxuICAgICAgICAgICAgICAgICAgICAgICAgLz5cclxuICAgICAgICAgICAgICAgICAgICA8L0Zvcm1GaWVsZD5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgPEZvcm1GaWVsZCBsYWJlbD1cIk1heWJlXCI+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxSYWRpb1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZT1cImFuc3dlcjJcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU9XCJtYXliZVwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGVja2VkPXt2YWx1ZTIgPT09ICdtYXliZSd9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXNhYmxlZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb25DaGFuZ2U9e2hhbmRsZUNoYW5nZTJ9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8+XHJcbiAgICAgICAgICAgICAgICAgICAgPC9Gb3JtRmllbGQ+XHJcbiAgICAgICAgICAgICAgICA8L0NvZGU+XHJcbiAgICAgICAgICAgIDwvU2VjdGlvbj5cclxuICAgICAgICA8L1BhZ2U+XHJcbiAgICApO1xyXG59IiwiaW1wb3J0IHtcclxuICAgIEVsZXZhdGlvbixcclxuICAgIFJpcHBsZVN1cmZhY2VcclxufSBmcm9tICdtZGMtcmVhY3QnO1xyXG5cclxuaW1wb3J0IFBhZ2UgZnJvbSAnQC9jb21wb25lbnRzL1BhZ2UnO1xyXG5pbXBvcnQgU2VjdGlvbiBmcm9tICdAL2NvbXBvbmVudHMvU2VjdGlvbic7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBSYWRpb1BhZ2UoKSB7XHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAgIDxQYWdlIHRpdGxlPVwiUmlwcGxlXCI+XHJcbiAgICAgICAgICAgIDxTZWN0aW9uIHRpdGxlPVwiQmFzaWMgcmlwcGxlXCI+XHJcbiAgICAgICAgICAgICAgICA8RWxldmF0aW9uIHo9XCI1XCI+XHJcbiAgICAgICAgICAgICAgICAgICAgPFJpcHBsZVN1cmZhY2Ugc3R5bGU9e3sgaGVpZ2h0OiAnMTAwcHgnIH19IC8+XHJcbiAgICAgICAgICAgICAgICA8L0VsZXZhdGlvbj5cclxuICAgICAgICAgICAgPC9TZWN0aW9uPlxyXG4gICAgICAgIDwvUGFnZT5cclxuICAgICk7XHJcbn0iLCJpbXBvcnQgeyB1c2VTdGF0ZSB9IGZyb20gJ3JlYWN0JztcclxuaW1wb3J0IHtcclxuICAgIFNlZ21lbnRlZEJ1dHRvblxyXG59IGZyb20gJ21kYy1yZWFjdCc7XHJcblxyXG5pbXBvcnQgUGFnZSBmcm9tICdAL2NvbXBvbmVudHMvUGFnZSc7XHJcbmltcG9ydCBTZWN0aW9uIGZyb20gJ0AvY29tcG9uZW50cy9TZWN0aW9uJztcclxuaW1wb3J0IENvZGUgZnJvbSAnQC9jb21wb25lbnRzL0NvZGUnO1xyXG5cclxuY29uc3QgaWQgPSAnc2VnbWVudGVkLWJ1dHRvbic7XHJcbmNvbnN0IHRpdGxlID0gJ1NlZ21lbnRlZCBCdXR0b24nO1xyXG5jb25zdCBkZXNjcmlwdGlvbiA9ICdTZWdtZW50ZWQgYnV0dG9ucyBhbGxvdyB1c2VycyB0byB0b2dnbGUgdGhlIHNlbGVjdGVkIHN0YXRlcyBvZiBncm91cGVkIGJ1dHRvbnMuJztcclxuY29uc3QgbGlua3MgPSB7XHJcbiAgICBkb2NzOiAnaHR0cHM6Ly9naXRodWIuY29tL21hdGVyaWFsLWNvbXBvbmVudHMvbWF0ZXJpYWwtY29tcG9uZW50cy13ZWIvdHJlZS9tYXN0ZXIvcGFja2FnZXMvbWRjLXNlZ21lbnRlZC1idXR0b24nLFxyXG4gICAgZ3VpZGU6ICdodHRwczovL21hdGVyaWFsLmlvL2NvbXBvbmVudHMvYnV0dG9ucyN0b2dnbGUtYnV0dG9uJ1xyXG59O1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gU2VnbWVudGVkQnV0dG9uUGFnZSgpIHtcclxuICAgIGNvbnN0IFt2YWx1ZTEsIHNldFZhbHVlMV0gPSB1c2VTdGF0ZSgnc3RhcicpO1xyXG4gICAgY29uc3QgW3ZhbHVlMiwgc2V0VmFsdWUyXSA9IHVzZVN0YXRlKCdzdGFyJyk7XHJcbiAgICBjb25zdCBbdmFsdWUzLCBzZXRWYWx1ZTNdID0gdXNlU3RhdGUoJ3N0YXInKTtcclxuXHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAgIDxQYWdlIGlkPXtpZH0gdGl0bGU9e3RpdGxlfSBkZXNjcmlwdGlvbj17ZGVzY3JpcHRpb259IGxpbmtzPXtsaW5rc30+XHJcbiAgICAgICAgICAgIDxTZWN0aW9uIHRpdGxlPVwiVGV4dFwiPlxyXG4gICAgICAgICAgICAgICAgPENvZGU+XHJcbiAgICAgICAgICAgICAgICAgICAgPFNlZ21lbnRlZEJ1dHRvbiB2YWx1ZT17dmFsdWUxfSBvbkNoYW5nZT17c2V0VmFsdWUxfT5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPFNlZ21lbnRlZEJ1dHRvbi5TZWdtZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZT1cInN0YXJcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWw9XCJzdGFyXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgLz5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxTZWdtZW50ZWRCdXR0b24uU2VnbWVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU9XCJmYXZvcml0ZVwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYWJlbD1cImZhdm9yaXRlXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgLz5cclxuICAgICAgICAgICAgICAgICAgICA8L1NlZ21lbnRlZEJ1dHRvbj5cclxuICAgICAgICAgICAgICAgIDwvQ29kZT5cclxuICAgICAgICAgICAgPC9TZWN0aW9uPlxyXG5cclxuICAgICAgICAgICAgPFNlY3Rpb24gdGl0bGU9XCJJY29uc1wiPlxyXG4gICAgICAgICAgICAgICAgPENvZGU+XHJcbiAgICAgICAgICAgICAgICAgICAgPFNlZ21lbnRlZEJ1dHRvbiB2YWx1ZT17dmFsdWUyfSBvbkNoYW5nZT17c2V0VmFsdWUyfT5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPFNlZ21lbnRlZEJ1dHRvbi5TZWdtZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZT1cInN0YXJcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWNvbj1cInN0YXJcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvPlxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPFNlZ21lbnRlZEJ1dHRvbi5TZWdtZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZT1cImZhdm9yaXRlXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGljb249XCJmYXZvcml0ZVwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8+XHJcbiAgICAgICAgICAgICAgICAgICAgPC9TZWdtZW50ZWRCdXR0b24+XHJcbiAgICAgICAgICAgICAgICA8L0NvZGU+XHJcbiAgICAgICAgICAgIDwvU2VjdGlvbj5cclxuXHJcbiAgICAgICAgICAgIDxTZWN0aW9uIHRpdGxlPVwiVGV4dCB3aXRoIEljb25zXCI+XHJcbiAgICAgICAgICAgICAgICA8Q29kZT5cclxuICAgICAgICAgICAgICAgICAgICA8U2VnbWVudGVkQnV0dG9uIHZhbHVlPXt2YWx1ZTN9IG9uQ2hhbmdlPXtzZXRWYWx1ZTN9PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8U2VnbWVudGVkQnV0dG9uLlNlZ21lbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlPVwic3RhclwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpY29uPVwic3RhclwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYWJlbD1cInN0YXJcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvPlxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPFNlZ21lbnRlZEJ1dHRvbi5TZWdtZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZT1cImZhdm9yaXRlXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGljb249XCJmYXZvcml0ZVwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYWJlbD1cImZhdm9yaXRlXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgLz5cclxuICAgICAgICAgICAgICAgICAgICA8L1NlZ21lbnRlZEJ1dHRvbj5cclxuICAgICAgICAgICAgICAgIDwvQ29kZT5cclxuICAgICAgICAgICAgPC9TZWN0aW9uPlxyXG4gICAgICAgIDwvUGFnZT5cclxuICAgICk7XHJcbn0iLCJpbXBvcnQgeyB1c2VTdGF0ZSB9IGZyb20gJ3JlYWN0JztcclxuaW1wb3J0IHtcclxuICAgIFNlbGVjdFxyXG59IGZyb20gJ21kYy1yZWFjdCc7XHJcblxyXG5pbXBvcnQgUGFnZSBmcm9tICdAL2NvbXBvbmVudHMvUGFnZSc7XHJcbmltcG9ydCBTZWN0aW9uIGZyb20gJ0AvY29tcG9uZW50cy9TZWN0aW9uJztcclxuaW1wb3J0IENvZGUgZnJvbSAnQC9jb21wb25lbnRzL0NvZGUnO1xyXG5cclxuY29uc3QgaWQgPSAnc2VsZWN0JztcclxuY29uc3QgdGl0bGUgPSAnU2VsZWN0JztcclxuY29uc3QgZGVzY3JpcHRpb24gPSAnU2VnbWVudGVkIGJ1dHRvbnMgYWxsb3cgdXNlcnMgdG8gdG9nZ2xlIHRoZSBzZWxlY3RlZCBzdGF0ZXMgb2YgZ3JvdXBlZCBidXR0b25zLic7XHJcbmNvbnN0IGxpbmtzID0ge1xyXG4gICAgZG9jczogJ2h0dHBzOi8vZ2l0aHViLmNvbS9tYXRlcmlhbC1jb21wb25lbnRzL21hdGVyaWFsLWNvbXBvbmVudHMtd2ViL3RyZWUvbWFzdGVyL3BhY2thZ2VzL21kYy1zZWxlY3QnXHJcbn07XHJcblxyXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBTZWxlY3RQYWdlKCkge1xyXG4gICAgY29uc3QgW2ZpbGxlZCwgc2V0RmlsbGVkXSA9IHVzZVN0YXRlKCk7XHJcbiAgICBjb25zdCBbb3V0bGluZWQsIHNldE91dGxpbmVkXSA9IHVzZVN0YXRlKCk7XHJcbiAgICBjb25zdCBbcHJlc2VsZWN0ZWQsIHNldFByZXNlbGVjdGVkXSA9IHVzZVN0YXRlKCdmb28nKTtcclxuICAgIGNvbnN0IFttdWx0aXBsZSwgc2V0TXVsdGlwbGVdID0gdXNlU3RhdGUoW10pO1xyXG4gICAgY29uc3QgW2ljb24sIHNldEljb25dID0gdXNlU3RhdGUoKTtcclxuXHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAgIDxQYWdlIGlkPXtpZH0gdGl0bGU9e3RpdGxlfSBkZXNjcmlwdGlvbj17ZGVzY3JpcHRpb259IGxpbmtzPXtsaW5rc30+XHJcbiAgICAgICAgICAgIDxTZWN0aW9uIHRpdGxlPVwiRmlsbGVkIHNlbGVjdFwiPlxyXG4gICAgICAgICAgICAgICAgPENvZGU+XHJcbiAgICAgICAgICAgICAgICAgICAgPFNlbGVjdFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBsYWJlbD1cIkNob29zZVwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlPXtmaWxsZWR9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbGxlZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBvbkNoYW5nZT17KGV2ZW50LCB2YWx1ZSkgPT4gc2V0RmlsbGVkKHZhbHVlKX1cclxuICAgICAgICAgICAgICAgICAgICA+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxTZWxlY3QuT3B0aW9uIHZhbHVlPVwiZm9vXCIgdGV4dD1cIkZvb1wiIC8+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxTZWxlY3QuT3B0aW9uIHZhbHVlPVwiYmFyXCIgdGV4dD1cIkJhclwiIC8+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxTZWxlY3QuT3B0aW9uIHZhbHVlPVwiYmF6XCIgdGV4dD1cIkJhelwiIC8+XHJcbiAgICAgICAgICAgICAgICAgICAgPC9TZWxlY3Q+XHJcbiAgICAgICAgICAgICAgICA8L0NvZGU+XHJcbiAgICAgICAgICAgIDwvU2VjdGlvbj5cclxuXHJcbiAgICAgICAgICAgIDxTZWN0aW9uIHRpdGxlPVwiT3V0bGluZWQgc2VsZWN0XCI+XHJcbiAgICAgICAgICAgICAgICA8Q29kZT5cclxuICAgICAgICAgICAgICAgICAgICA8U2VsZWN0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsPVwiQ2hvb3NlXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU9e291dGxpbmVkfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRsaW5lZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBvbkNoYW5nZT17KGV2ZW50LCB2YWx1ZSkgPT4gc2V0T3V0bGluZWQodmFsdWUpfVxyXG4gICAgICAgICAgICAgICAgICAgID5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPFNlbGVjdC5PcHRpb24gdmFsdWU9XCJmb29cIiB0ZXh0PVwiRm9vXCIgLz5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPFNlbGVjdC5PcHRpb24gdmFsdWU9XCJiYXJcIiB0ZXh0PVwiQmFyXCIgLz5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPFNlbGVjdC5PcHRpb24gdmFsdWU9XCJiYXpcIiB0ZXh0PVwiQmF6XCIgLz5cclxuICAgICAgICAgICAgICAgICAgICA8L1NlbGVjdD5cclxuICAgICAgICAgICAgICAgIDwvQ29kZT5cclxuICAgICAgICAgICAgPC9TZWN0aW9uPlxyXG5cclxuICAgICAgICAgICAgPFNlY3Rpb24gdGl0bGU9XCJQcmVzZWxlY3RlZCBzZWxlY3RcIj5cclxuICAgICAgICAgICAgICAgIDxDb2RlPlxyXG4gICAgICAgICAgICAgICAgICAgIDxTZWxlY3RcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWw9XCJDaG9vc2VcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZT17cHJlc2VsZWN0ZWR9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbGxlZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBvbkNoYW5nZT17KGV2ZW50LCB2YWx1ZSkgPT4gc2V0UHJlc2VsZWN0ZWQodmFsdWUpfVxyXG4gICAgICAgICAgICAgICAgICAgID5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPFNlbGVjdC5PcHRpb24gdmFsdWU9XCJmb29cIiB0ZXh0PVwiRm9vXCIgLz5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPFNlbGVjdC5PcHRpb24gdmFsdWU9XCJiYXJcIiB0ZXh0PVwiQmFyXCIgLz5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPFNlbGVjdC5PcHRpb24gdmFsdWU9XCJiYXpcIiB0ZXh0PVwiQmF6XCIgLz5cclxuICAgICAgICAgICAgICAgICAgICA8L1NlbGVjdD5cclxuICAgICAgICAgICAgICAgIDwvQ29kZT5cclxuICAgICAgICAgICAgPC9TZWN0aW9uPlxyXG5cclxuICAgICAgICAgICAgPFNlY3Rpb24gdGl0bGU9XCJNdWx0aXBsZSBzZWxlY3RcIj5cclxuICAgICAgICAgICAgICAgIDxDb2RlPlxyXG4gICAgICAgICAgICAgICAgICAgIDxTZWxlY3RcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWw9XCJDaG9vc2VcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZT17bXVsdGlwbGV9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbGxlZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBvbkNoYW5nZT17KGV2ZW50LCB2YWx1ZSkgPT4gc2V0TXVsdGlwbGUodmFsdWUpfVxyXG4gICAgICAgICAgICAgICAgICAgID5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPFNlbGVjdC5PcHRpb24gdmFsdWU9XCJmb29cIiB0ZXh0PVwiRm9vXCIgLz5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPFNlbGVjdC5PcHRpb24gdmFsdWU9XCJiYXJcIiB0ZXh0PVwiQmFyXCIgLz5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPFNlbGVjdC5PcHRpb24gdmFsdWU9XCJiYXpcIiB0ZXh0PVwiQmF6XCIgLz5cclxuICAgICAgICAgICAgICAgICAgICA8L1NlbGVjdD5cclxuICAgICAgICAgICAgICAgIDwvQ29kZT5cclxuICAgICAgICAgICAgPC9TZWN0aW9uPlxyXG5cclxuICAgICAgICAgICAgPFNlY3Rpb24gdGl0bGU9XCJTZWxlY3Qgd2l0aCBhbiBpY29uXCI+XHJcbiAgICAgICAgICAgICAgICA8Q29kZT5cclxuICAgICAgICAgICAgICAgICAgICA8U2VsZWN0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsPVwiQ2hvb3NlXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU9e2ljb259XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGljb249XCJzdGFyXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgZmlsbGVkXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2hhbmdlPXsoZXZlbnQsIHZhbHVlKSA9PiBzZXRJY29uKHZhbHVlKX1cclxuICAgICAgICAgICAgICAgICAgICA+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxTZWxlY3QuT3B0aW9uIHZhbHVlPVwiZm9vXCIgdGV4dD1cIkZvb1wiIC8+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxTZWxlY3QuT3B0aW9uIHZhbHVlPVwiYmFyXCIgdGV4dD1cIkJhclwiIC8+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxTZWxlY3QuT3B0aW9uIHZhbHVlPVwiYmF6XCIgdGV4dD1cIkJhelwiIC8+XHJcbiAgICAgICAgICAgICAgICAgICAgPC9TZWxlY3Q+XHJcbiAgICAgICAgICAgICAgICA8L0NvZGU+XHJcbiAgICAgICAgICAgIDwvU2VjdGlvbj5cclxuICAgICAgICA8L1BhZ2U+XHJcbiAgICApO1xyXG59IiwiaW1wb3J0IHsgdXNlU3RhdGUgfSBmcm9tICdyZWFjdCc7XHJcbmltcG9ydCB7XHJcbiAgICBCdXR0b24sXHJcbiAgICBTaWRlU2hlZXRcclxufSBmcm9tICdtZGMtcmVhY3QnO1xyXG5cclxuaW1wb3J0IFBhZ2UgZnJvbSAnQC9jb21wb25lbnRzL1BhZ2UnO1xyXG5pbXBvcnQgU2VjdGlvbiBmcm9tICdAL2NvbXBvbmVudHMvU2VjdGlvbic7XHJcbmltcG9ydCBDb2RlIGZyb20gJ0AvY29tcG9uZW50cy9Db2RlJztcclxuXHJcbmNvbnN0IGlkID0gJ3NpZGUtc2hlZXQnO1xyXG5jb25zdCB0aXRsZSA9ICdTaWRlIFNoZWV0JztcclxuY29uc3QgZGVzY3JpcHRpb24gPSAnU2lkZSBzaGVldHMgYXJlIHN1cmZhY2VzIGNvbnRhaW5pbmcgc3VwcGxlbWVudGFyeSBjb250ZW50IHRoYXQgYXJlIGFuY2hvcmVkIHRvIHRoZSBsZWZ0IG9yIHJpZ2h0IGVkZ2Ugb2YgdGhlIHNjcmVlbi4nO1xyXG5jb25zdCBsaW5rcyA9IHtcclxuICAgIGd1aWRlOiAnaHR0cHM6Ly9tYXRlcmlhbC5pby9jb21wb25lbnRzL3NoZWV0cy1zaWRlJ1xyXG59O1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gU2lkZVNoZWV0UGFnZSgpIHtcclxuICAgIGNvbnN0IFtpc0Rpc21pc3NpYmxlT3Blbiwgc2V0RGlzbWlzc2libGVPcGVuXSA9IHVzZVN0YXRlKGZhbHNlKTtcclxuICAgIGNvbnN0IFtpc01vZGFsT3Blbiwgc2V0TW9kYWxPcGVuXSA9IHVzZVN0YXRlKGZhbHNlKTtcclxuXHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAgIDxQYWdlIGlkPXtpZH0gdGl0bGU9e3RpdGxlfSBkZXNjcmlwdGlvbj17ZGVzY3JpcHRpb259IGxpbmtzPXtsaW5rc30+XHJcbiAgICAgICAgICAgIDxTZWN0aW9uIHRpdGxlPVwiQmFzaWMgc2lkZSBzaGVldFwiPlxyXG4gICAgICAgICAgICAgICAgPENvZGU+XHJcbiAgICAgICAgICAgICAgICAgICAgPFNpZGVTaGVldCB0aXRsZT1cIlRpdGxlXCI+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIENvbnRlbnRcclxuICAgICAgICAgICAgICAgICAgICA8L1NpZGVTaGVldD5cclxuICAgICAgICAgICAgICAgIDwvQ29kZT5cclxuICAgICAgICAgICAgPC9TZWN0aW9uPlxyXG5cclxuICAgICAgICAgICAgPFNlY3Rpb24gdGl0bGU9XCJEaXNtaXNzaWJsZSBzaWRlIHNoZWV0XCI+XHJcbiAgICAgICAgICAgICAgICA8Q29kZVxyXG4gICAgICAgICAgICAgICAgICAgIHNldHVwPXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgPEJ1dHRvblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWw9XCJUb2dnbGVcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0bGluZWRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2xpY2s9eygpID0+IHNldERpc21pc3NpYmxlT3Blbih2ID0+ICF2KX1cclxuICAgICAgICAgICAgICAgICAgICAgICAgLz5cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICA+XHJcbiAgICAgICAgICAgICAgICAgICAgPFNpZGVTaGVldFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aXRsZT1cIlRpdGxlXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2xvc2VJY29uPVwiY2xvc2VcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBvcGVuPXtpc0Rpc21pc3NpYmxlT3Blbn1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZGlzbWlzc2libGVcclxuICAgICAgICAgICAgICAgICAgICAgICAgb25DbG9zZT17KCkgPT4gc2V0RGlzbWlzc2libGVPcGVuKGZhbHNlKX1cclxuICAgICAgICAgICAgICAgICAgICA+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIENvbnRlbnRcclxuICAgICAgICAgICAgICAgICAgICA8L1NpZGVTaGVldD5cclxuICAgICAgICAgICAgICAgIDwvQ29kZT5cclxuICAgICAgICAgICAgPC9TZWN0aW9uPlxyXG5cclxuICAgICAgICAgICAgPFNlY3Rpb24gdGl0bGU9XCJNb2RhbCBzaWRlIHNoZWV0XCI+XHJcbiAgICAgICAgICAgICAgICA8Q29kZVxyXG4gICAgICAgICAgICAgICAgICAgIHNldHVwPXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgPEJ1dHRvblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWw9XCJPcGVuXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dGxpbmVkXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbkNsaWNrPXsoKSA9PiBzZXRNb2RhbE9wZW4odHJ1ZSl9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8+XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgPlxyXG4gICAgICAgICAgICAgICAgICAgIDxTaWRlU2hlZXRcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGU9XCJUaXRsZVwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsb3NlSWNvbj1cImNsb3NlXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgb3Blbj17aXNNb2RhbE9wZW59XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vZGFsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2xvc2U9eygpID0+IHNldE1vZGFsT3BlbihmYWxzZSl9XHJcbiAgICAgICAgICAgICAgICAgICAgPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBDb250ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgPC9TaWRlU2hlZXQ+XHJcbiAgICAgICAgICAgICAgICA8L0NvZGU+XHJcbiAgICAgICAgICAgIDwvU2VjdGlvbj5cclxuICAgICAgICA8L1BhZ2U+XHJcbiAgICApO1xyXG59IiwiaW1wb3J0IHsgdXNlU3RhdGUgfSBmcm9tICdyZWFjdCc7XHJcbmltcG9ydCB7XHJcbiAgICBTbGlkZXJcclxufSBmcm9tICdtZGMtcmVhY3QnO1xyXG5cclxuaW1wb3J0IFBhZ2UgZnJvbSAnQC9jb21wb25lbnRzL1BhZ2UnO1xyXG5pbXBvcnQgU2VjdGlvbiBmcm9tICdAL2NvbXBvbmVudHMvU2VjdGlvbic7XHJcbmltcG9ydCBDb2RlIGZyb20gJ0AvY29tcG9uZW50cy9Db2RlJztcclxuXHJcbmNvbnN0IGlkID0gJ3NsaWRlcic7XHJcbmNvbnN0IHRpdGxlID0gJ1NsaWRlcic7XHJcbmNvbnN0IGRlc2NyaXB0aW9uID0gJ1NsaWRlcnMgYWxsb3cgdXNlcnMgdG8gbWFrZSBzZWxlY3Rpb25zIGZyb20gYSByYW5nZSBvZiB2YWx1ZXMuJztcclxuY29uc3QgbGlua3MgPSB7XHJcbiAgICBkb2NzOiAnaHR0cHM6Ly9naXRodWIuY29tL21hdGVyaWFsLWNvbXBvbmVudHMvbWF0ZXJpYWwtY29tcG9uZW50cy13ZWIvdHJlZS9tYXN0ZXIvcGFja2FnZXMvbWRjLXNsaWRlcicsXHJcbiAgICBndWlkZTogJ2h0dHBzOi8vbWF0ZXJpYWwuaW8vY29tcG9uZW50cy9zbGlkZXJzJ1xyXG59O1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gU2xpZGVyUGFnZSgpIHtcclxuICAgIGNvbnN0IFt2YWx1ZTEsIHNldFZhbHVlMV0gPSB1c2VTdGF0ZSg1MCk7XHJcbiAgICBjb25zdCBbdmFsdWUyLCBzZXRWYWx1ZTJdID0gdXNlU3RhdGUoNTApO1xyXG4gICAgY29uc3QgW3ZhbHVlMywgc2V0VmFsdWUzXSA9IHVzZVN0YXRlKDUwKTtcclxuXHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAgIDxQYWdlIGlkPXtpZH0gdGl0bGU9e3RpdGxlfSBkZXNjcmlwdGlvbj17ZGVzY3JpcHRpb259IGxpbmtzPXtsaW5rc30+XHJcbiAgICAgICAgICAgIDxTZWN0aW9uIHRpdGxlPVwiQ29udGludW91cyBzbGlkZXJcIj5cclxuICAgICAgICAgICAgICAgIDxDb2RlPlxyXG4gICAgICAgICAgICAgICAgICAgIDxTbGlkZXJcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU9e3ZhbHVlMX1cclxuICAgICAgICAgICAgICAgICAgICAgICAgb25DaGFuZ2U9e3NldFZhbHVlMX1cclxuICAgICAgICAgICAgICAgICAgICAvPlxyXG4gICAgICAgICAgICAgICAgPC9Db2RlPlxyXG4gICAgICAgICAgICA8L1NlY3Rpb24+XHJcblxyXG4gICAgICAgICAgICA8U2VjdGlvbiB0aXRsZT1cIkRpc2NyZXRlIHNsaWRlclwiPlxyXG4gICAgICAgICAgICAgICAgPENvZGU+XHJcbiAgICAgICAgICAgICAgICAgICAgPFNsaWRlclxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZT17dmFsdWUyfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGVwPVwiMTBcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBkaXNjcmV0ZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBvbkNoYW5nZT17c2V0VmFsdWUyfVxyXG4gICAgICAgICAgICAgICAgICAgIC8+XHJcbiAgICAgICAgICAgICAgICA8L0NvZGU+XHJcbiAgICAgICAgICAgIDwvU2VjdGlvbj5cclxuXHJcbiAgICAgICAgICAgIDxTZWN0aW9uIHRpdGxlPVwiRGlzY3JldGUgc2xpZGVyIHdpdGggdGljayBtYXJrc1wiPlxyXG4gICAgICAgICAgICAgICAgPENvZGU+XHJcbiAgICAgICAgICAgICAgICAgICAgPFNsaWRlclxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZT17dmFsdWUzfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGVwPVwiMTBcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBkaXNjcmV0ZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aWNrTWFya3NcclxuICAgICAgICAgICAgICAgICAgICAgICAgb25DaGFuZ2U9e3NldFZhbHVlM31cclxuICAgICAgICAgICAgICAgICAgICAvPlxyXG4gICAgICAgICAgICAgICAgPC9Db2RlPlxyXG4gICAgICAgICAgICA8L1NlY3Rpb24+XHJcblxyXG4gICAgICAgICAgICA8U2VjdGlvbiB0aXRsZT1cIkRpc2FibGVkIHNsaWRlclwiPlxyXG4gICAgICAgICAgICAgICAgPENvZGU+XHJcbiAgICAgICAgICAgICAgICAgICAgPFNsaWRlclxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZT17NDJ9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpc2FibGVkXHJcbiAgICAgICAgICAgICAgICAgICAgLz5cclxuICAgICAgICAgICAgICAgIDwvQ29kZT5cclxuICAgICAgICAgICAgPC9TZWN0aW9uPlxyXG4gICAgICAgIDwvUGFnZT5cclxuICAgICk7XHJcbn0iLCJpbXBvcnQgeyB1c2VTdGF0ZSB9IGZyb20gJ3JlYWN0JztcclxuaW1wb3J0IHtcclxuICAgIEJ1dHRvbixcclxuICAgIExheW91dCxcclxuICAgIFNlZ21lbnRlZEJ1dHRvbixcclxuICAgIFNuYWNrYmFyLFxyXG4gICAgVGV4dEZpZWxkXHJcbn0gZnJvbSAnbWRjLXJlYWN0JztcclxuXHJcbmltcG9ydCBQYWdlIGZyb20gJ0AvY29tcG9uZW50cy9QYWdlJztcclxuaW1wb3J0IFNlY3Rpb24gZnJvbSAnQC9jb21wb25lbnRzL1NlY3Rpb24nO1xyXG5pbXBvcnQgQ29kZSBmcm9tICdAL2NvbXBvbmVudHMvQ29kZSc7XHJcblxyXG5jb25zdCBpZCA9ICdzbmFja2Jhcic7XHJcbmNvbnN0IHRpdGxlID0gJ1NuYWNrYmFyJztcclxuY29uc3QgZGVzY3JpcHRpb24gPSAnU25hY2tiYXJzIHByb3ZpZGUgYnJpZWYgbWVzc2FnZXMgYWJvdXQgYXBwIHByb2Nlc3NlcyBhdCB0aGUgYm90dG9tIG9mIHRoZSBzY3JlZW4uJztcclxuY29uc3QgbGlua3MgPSB7XHJcbiAgICBkb2NzOiAnaHR0cHM6Ly9naXRodWIuY29tL21hdGVyaWFsLWNvbXBvbmVudHMvbWF0ZXJpYWwtY29tcG9uZW50cy13ZWIvdHJlZS9tYXN0ZXIvcGFja2FnZXMvbWRjLXNuYWNrYmFyJyxcclxuICAgIGd1aWRlOiAnaHR0cHM6Ly9tYXRlcmlhbC5pby9jb21wb25lbnRzL3NuYWNrYmFycydcclxufTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIFNuYWNrYmFyUGFnZSgpIHtcclxuICAgIGNvbnN0IFtpc09wZW4sIHNldE9wZW5dID0gdXNlU3RhdGUoZmFsc2UpO1xyXG4gICAgY29uc3QgW3RpbWVvdXQsIHNldFRpbWVvdXRdID0gdXNlU3RhdGUoNTAwMCk7XHJcbiAgICBjb25zdCBbaGFzQWN0aW9uLCBzZXRIYXNBY3Rpb25dID0gdXNlU3RhdGUoZmFsc2UpO1xyXG4gICAgY29uc3QgW2lzTGVhZGluZywgc2V0TGVhZGluZ10gPSB1c2VTdGF0ZShmYWxzZSk7XHJcbiAgICBjb25zdCBbaXNTdGFja2VkLCBzZXRTdGFja2VkXSA9IHVzZVN0YXRlKGZhbHNlKTtcclxuXHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAgIDxQYWdlIGlkPXtpZH0gdGl0bGU9e3RpdGxlfSBkZXNjcmlwdGlvbj17ZGVzY3JpcHRpb259IGxpbmtzPXtsaW5rc30+XHJcbiAgICAgICAgICAgIDxTZWN0aW9uIHRpdGxlPVwiRGVtb1wiPlxyXG4gICAgICAgICAgICAgICAgPExheW91dCByb3c+XHJcbiAgICAgICAgICAgICAgICAgICAgPGZpZWxkc2V0PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8bGVnZW5kPkVsZW1lbnRzPC9sZWdlbmQ+XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8U2VnbWVudGVkQnV0dG9uPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPFNlZ21lbnRlZEJ1dHRvbi5TZWdtZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWw9XCJBY3Rpb25cIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdGVkPXtoYXNBY3Rpb259XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb25DbGljaz17KCkgPT4gc2V0SGFzQWN0aW9uKHYgPT4gIXYpfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLz5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPC9TZWdtZW50ZWRCdXR0b24+XHJcbiAgICAgICAgICAgICAgICAgICAgPC9maWVsZHNldD5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgPGZpZWxkc2V0PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8bGVnZW5kPlZhcmlhbnRzPC9sZWdlbmQ+XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8U2VnbWVudGVkQnV0dG9uPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPFNlZ21lbnRlZEJ1dHRvbi5TZWdtZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWw9XCJMZWFkaW5nXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3RlZD17aXNMZWFkaW5nfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2xpY2s9eygpID0+IHNldExlYWRpbmcodiA9PiAhdil9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvPlxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxTZWdtZW50ZWRCdXR0b24uU2VnbWVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsPVwiU3RhY2tlZFwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0ZWQ9e2lzU3RhY2tlZH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbkNsaWNrPXsoKSA9PiBzZXRTdGFja2VkKHYgPT4gIXYpfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLz5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPC9TZWdtZW50ZWRCdXR0b24+XHJcbiAgICAgICAgICAgICAgICAgICAgPC9maWVsZHNldD5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgPFRleHRGaWVsZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBsYWJlbD1cIlRpbWVvdXRcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZT17dGltZW91dH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgc3VmZml4PVwibXNcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRsaW5lZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBvbkNoYW5nZT17KF8sIHZhbHVlKSA9PiBzZXRUaW1lb3V0KHZhbHVlKX1cclxuICAgICAgICAgICAgICAgICAgICAvPlxyXG4gICAgICAgICAgICAgICAgPC9MYXlvdXQ+XHJcblxyXG4gICAgICAgICAgICAgICAgPENvZGVcclxuICAgICAgICAgICAgICAgICAgICBzZXR1cD17XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxCdXR0b25cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsPVwiU2hvd1wiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRsaW5lZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb25DbGljaz17KCkgPT4gc2V0T3Blbih0cnVlKX1cclxuICAgICAgICAgICAgICAgICAgICAgICAgLz5cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICA+XHJcbiAgICAgICAgICAgICAgICAgICAgPFNuYWNrYmFyXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wZW49e2lzT3Blbn1cclxuICAgICAgICAgICAgICAgICAgICAgICAgdGltZW91dD17dGltZW91dH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWw9XCJNZXNzYWdlXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgYWN0aW9uPXtoYXNBY3Rpb24gP1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPEJ1dHRvbj5BY3Rpb248L0J1dHRvbj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVuZGVmaW5lZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlYWRpbmc9e2lzTGVhZGluZyB8fCB1bmRlZmluZWR9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YWNrZWQ9e2lzU3RhY2tlZCB8fCB1bmRlZmluZWR9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2xvc2U9eygpID0+IHNldE9wZW4odW5kZWZpbmVkKX1cclxuICAgICAgICAgICAgICAgICAgICAvPlxyXG4gICAgICAgICAgICAgICAgPC9Db2RlPlxyXG4gICAgICAgICAgICA8L1NlY3Rpb24+XHJcbiAgICAgICAgPC9QYWdlPlxyXG4gICAgKTtcclxufSIsImltcG9ydCB7IHVzZVN0YXRlIH0gZnJvbSAncmVhY3QnO1xyXG5pbXBvcnQge1xyXG4gICAgU3dpdGNoXHJcbn0gZnJvbSAnbWRjLXJlYWN0JztcclxuXHJcbmltcG9ydCBQYWdlIGZyb20gJ0AvY29tcG9uZW50cy9QYWdlJztcclxuaW1wb3J0IFNlY3Rpb24gZnJvbSAnQC9jb21wb25lbnRzL1NlY3Rpb24nO1xyXG5pbXBvcnQgQ29kZSBmcm9tICdAL2NvbXBvbmVudHMvQ29kZSc7XHJcblxyXG5jb25zdCBpZCA9ICdzd2l0Y2gnO1xyXG5jb25zdCB0aXRsZSA9ICdTd2l0Y2gnO1xyXG5jb25zdCBkZXNjcmlwdGlvbiA9ICdTd2l0Y2hlcyB0b2dnbGUgdGhlIHN0YXRlIG9mIGEgc2luZ2xlIGl0ZW0gb24gb3Igb2ZmLic7XHJcbmNvbnN0IGxpbmtzID0ge1xyXG4gICAgZG9jczogJ2h0dHBzOi8vZ2l0aHViLmNvbS9tYXRlcmlhbC1jb21wb25lbnRzL21hdGVyaWFsLWNvbXBvbmVudHMtd2ViL3RyZWUvbWFzdGVyL3BhY2thZ2VzL21kYy1zd2l0Y2gnLFxyXG4gICAgZ3VpZGU6ICdodHRwczovL21hdGVyaWFsLmlvL2NvbXBvbmVudHMvc3dpdGNoZXMnXHJcbn07XHJcblxyXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBTd2l0Y2hQYWdlKCkge1xyXG4gICAgY29uc3QgW2lzU2VsZWN0ZWQsIHNldFNlbGVjdGVkXSA9IHVzZVN0YXRlKGZhbHNlKTtcclxuXHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAgIDxQYWdlIGlkPXtpZH0gdGl0bGU9e3RpdGxlfSBkZXNjcmlwdGlvbj17ZGVzY3JpcHRpb259IGxpbmtzPXtsaW5rc30+XHJcbiAgICAgICAgICAgIDxTZWN0aW9uIHRpdGxlPVwiQmFzaWMgc3dpdGNoXCI+XHJcbiAgICAgICAgICAgICAgICA8Q29kZT5cclxuICAgICAgICAgICAgICAgICAgICA8U3dpdGNoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdGVkPXtpc1NlbGVjdGVkfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBvbkNoYW5nZT17KCkgPT4gc2V0U2VsZWN0ZWQodiA9PiAhdil9XHJcbiAgICAgICAgICAgICAgICAgICAgLz5cclxuICAgICAgICAgICAgICAgIDwvQ29kZT5cclxuICAgICAgICAgICAgPC9TZWN0aW9uPlxyXG5cclxuICAgICAgICAgICAgPFNlY3Rpb24gdGl0bGU9XCJEaXNhYmxlZCBzd2l0Y2hcIj5cclxuICAgICAgICAgICAgICAgIDxDb2RlPlxyXG4gICAgICAgICAgICAgICAgICAgIDxTd2l0Y2ggZGlzYWJsZWQgLz5cclxuICAgICAgICAgICAgICAgIDwvQ29kZT5cclxuICAgICAgICAgICAgPC9TZWN0aW9uPlxyXG4gICAgICAgIDwvUGFnZT5cclxuICAgICk7XHJcbn0iLCJpbXBvcnQgeyB1c2VTdGF0ZSB9IGZyb20gJ3JlYWN0JztcclxuaW1wb3J0IHtcclxuICAgIFRhYkJhciwgVGFiXHJcbn0gZnJvbSAnbWRjLXJlYWN0JztcclxuXHJcbmltcG9ydCBQYWdlIGZyb20gJ0AvY29tcG9uZW50cy9QYWdlJztcclxuaW1wb3J0IFNlY3Rpb24gZnJvbSAnQC9jb21wb25lbnRzL1NlY3Rpb24nO1xyXG5pbXBvcnQgQ29kZSBmcm9tICdAL2NvbXBvbmVudHMvQ29kZSc7XHJcblxyXG5jb25zdCBpZCA9ICd0YWJzJztcclxuY29uc3QgdGl0bGUgPSAnVGFicyc7XHJcbmNvbnN0IGRlc2NyaXB0aW9uID0gJ1RhYnMgb3JnYW5pemUgY29udGVudCBhY3Jvc3MgZGlmZmVyZW50IHNjcmVlbnMsIGRhdGEgc2V0cywgYW5kIG90aGVyIGludGVyYWN0aW9ucy4nO1xyXG5jb25zdCBsaW5rcyA9IHtcclxuICAgIGRvY3M6ICdodHRwczovL2dpdGh1Yi5jb20vbWF0ZXJpYWwtY29tcG9uZW50cy9tYXRlcmlhbC1jb21wb25lbnRzLXdlYi90cmVlL21hc3Rlci9wYWNrYWdlcy9tZGMtdGFiLWJhcicsXHJcbiAgICBndWlkZTogJ2h0dHBzOi8vbWF0ZXJpYWwuaW8vY29tcG9uZW50cy90YWJzJ1xyXG59O1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gU3dpdGNoUGFnZSgpIHtcclxuICAgIGNvbnN0IFtiYXNpYywgc2V0QmFzaWNdID0gdXNlU3RhdGUoMCk7XHJcbiAgICBjb25zdCBbbWluV2lkdGgsIHNldE1pbldpZHRoXSA9IHVzZVN0YXRlKDApO1xyXG4gICAgY29uc3QgW21pbldpZHRoSW5kaWNhdG9yLCBzZXRNaW5XaWR0aEluZGljYXRvcl0gPSB1c2VTdGF0ZSgwKTtcclxuICAgIGNvbnN0IFttaW5XaWR0aFdpdGhNaW5XaWR0aEluZGljYXRvciwgc2V0TWluV2lkdGhXaXRoTWluV2lkdGhJbmRpY2F0b3JdID0gdXNlU3RhdGUoMCk7XHJcbiAgICBjb25zdCBbZmFkZSwgc2V0RmFkZV0gPSB1c2VTdGF0ZSgwKTtcclxuICAgIGNvbnN0IFtpY29ucywgc2V0SWNvbnNdID0gdXNlU3RhdGUoMCk7XHJcbiAgICBjb25zdCBbc3RhY2tlZEljb25zLCBzZXRTdGFja2VkSWNvbnNdID0gdXNlU3RhdGUoMCk7XHJcbiAgICBjb25zdCBbb25seUljb25zLCBzZXRPbmx5SWNvbnNdID0gdXNlU3RhdGUoMCk7XHJcbiAgICBjb25zdCBbaWNvbkluZGljYXRvciwgc2V0SWNvbkluZGljYXRvcl0gPSB1c2VTdGF0ZSgwKTtcclxuICAgIGNvbnN0IFtzY3JvbGwsIHNldFNjcm9sbF0gPSB1c2VTdGF0ZSgwKTtcclxuXHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAgIDxQYWdlIGlkPXtpZH0gdGl0bGU9e3RpdGxlfSBkZXNjcmlwdGlvbj17ZGVzY3JpcHRpb259IGxpbmtzPXtsaW5rc30+XHJcbiAgICAgICAgICAgIDxTZWN0aW9uIHRpdGxlPVwiQmFzaWMgdGFic1wiPlxyXG4gICAgICAgICAgICAgICAgPENvZGU+XHJcbiAgICAgICAgICAgICAgICAgICAgPFRhYkJhclxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZT17YmFzaWN9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2hhbmdlPXt2YWx1ZSA9PiBzZXRCYXNpYyh2YWx1ZSl9XHJcbiAgICAgICAgICAgICAgICAgICAgPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8VGFiIGxhYmVsPVwiVGFiIDFcIiAvPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8VGFiIGxhYmVsPVwiVGFiIDJcIiAvPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8VGFiIGxhYmVsPVwiVGFiIDNcIiAvPlxyXG4gICAgICAgICAgICAgICAgICAgIDwvVGFiQmFyPlxyXG4gICAgICAgICAgICAgICAgPC9Db2RlPlxyXG4gICAgICAgICAgICA8L1NlY3Rpb24+XHJcblxyXG4gICAgICAgICAgICA8U2VjdGlvbiB0aXRsZT1cIk1pbiB3aWR0aCB0YWJzXCI+XHJcbiAgICAgICAgICAgICAgICA8Q29kZT5cclxuICAgICAgICAgICAgICAgICAgICA8VGFiQmFyXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlPXttaW5XaWR0aH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgbWluV2lkdGhcclxuICAgICAgICAgICAgICAgICAgICAgICAgb25DaGFuZ2U9e3ZhbHVlID0+IHNldE1pbldpZHRoKHZhbHVlKX1cclxuICAgICAgICAgICAgICAgICAgICA+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxUYWIgbGFiZWw9XCJUYWIgMVwiIC8+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxUYWIgbGFiZWw9XCJUYWIgMlwiIC8+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxUYWIgbGFiZWw9XCJUYWIgM1wiIC8+XHJcbiAgICAgICAgICAgICAgICAgICAgPC9UYWJCYXI+XHJcbiAgICAgICAgICAgICAgICA8L0NvZGU+XHJcbiAgICAgICAgICAgIDwvU2VjdGlvbj5cclxuXHJcbiAgICAgICAgICAgIDxTZWN0aW9uIHRpdGxlPVwiVGFicyB3aXRoIG1pbiB3aWR0aCBpbmRpY2F0b3JcIj5cclxuICAgICAgICAgICAgICAgIDxDb2RlPlxyXG4gICAgICAgICAgICAgICAgICAgIDxUYWJCYXJcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU9e21pbldpZHRoSW5kaWNhdG9yfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBtaW5XaWR0aEluZGljYXRvclxyXG4gICAgICAgICAgICAgICAgICAgICAgICBvbkNoYW5nZT17dmFsdWUgPT4gc2V0TWluV2lkdGhJbmRpY2F0b3IodmFsdWUpfVxyXG4gICAgICAgICAgICAgICAgICAgID5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPFRhYiBsYWJlbD1cIlRhYiAxXCIgLz5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPFRhYiBsYWJlbD1cIlRhYiAyXCIgLz5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPFRhYiBsYWJlbD1cIlRhYiAzXCIgLz5cclxuICAgICAgICAgICAgICAgICAgICA8L1RhYkJhcj5cclxuICAgICAgICAgICAgICAgIDwvQ29kZT5cclxuICAgICAgICAgICAgPC9TZWN0aW9uPlxyXG5cclxuICAgICAgICAgICAgPFNlY3Rpb24gdGl0bGU9XCJNaW4gd2lkdGggdGFicyB3aXRoIG1pbiB3aWR0aCBpbmRpY2F0b3JcIj5cclxuICAgICAgICAgICAgICAgIDxDb2RlPlxyXG4gICAgICAgICAgICAgICAgICAgIDxUYWJCYXJcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU9e21pbldpZHRoV2l0aE1pbldpZHRoSW5kaWNhdG9yfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBtaW5XaWR0aFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBtaW5XaWR0aEluZGljYXRvclxyXG4gICAgICAgICAgICAgICAgICAgICAgICBvbkNoYW5nZT17dmFsdWUgPT4gc2V0TWluV2lkdGhXaXRoTWluV2lkdGhJbmRpY2F0b3IodmFsdWUpfVxyXG4gICAgICAgICAgICAgICAgICAgID5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPFRhYiBsYWJlbD1cIlRhYiAxXCIgLz5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPFRhYiBsYWJlbD1cIlRhYiAyXCIgLz5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPFRhYiBsYWJlbD1cIlRhYiAzXCIgLz5cclxuICAgICAgICAgICAgICAgICAgICA8L1RhYkJhcj5cclxuICAgICAgICAgICAgICAgIDwvQ29kZT5cclxuICAgICAgICAgICAgPC9TZWN0aW9uPlxyXG5cclxuICAgICAgICAgICAgPFNlY3Rpb24gdGl0bGU9XCJUYWJzIHdpdGggZmFkaW5nIGluZGljYXRvclwiPlxyXG4gICAgICAgICAgICAgICAgPENvZGU+XHJcbiAgICAgICAgICAgICAgICAgICAgPFRhYkJhclxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZT17ZmFkZX1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZmFkZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBvbkNoYW5nZT17dmFsdWUgPT4gc2V0RmFkZSh2YWx1ZSl9XHJcbiAgICAgICAgICAgICAgICAgICAgPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8VGFiIGxhYmVsPVwiVGFiIDFcIiAvPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8VGFiIGxhYmVsPVwiVGFiIDJcIiAvPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8VGFiIGxhYmVsPVwiVGFiIDNcIiAvPlxyXG4gICAgICAgICAgICAgICAgICAgIDwvVGFiQmFyPlxyXG4gICAgICAgICAgICAgICAgPC9Db2RlPlxyXG4gICAgICAgICAgICA8L1NlY3Rpb24+XHJcblxyXG4gICAgICAgICAgICA8U2VjdGlvbiB0aXRsZT1cIlRhYnMgd2l0aCBpY29uc1wiPlxyXG4gICAgICAgICAgICAgICAgPENvZGU+XHJcbiAgICAgICAgICAgICAgICAgICAgPFRhYkJhclxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZT17aWNvbnN9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2hhbmdlPXt2YWx1ZSA9PiBzZXRJY29ucyh2YWx1ZSl9XHJcbiAgICAgICAgICAgICAgICAgICAgPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8VGFiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpY29uPVwic3RhclwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYWJlbD1cIlRhYiAxXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgLz5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxUYWJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGljb249XCJmYXZvcml0ZVwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYWJlbD1cIlRhYiAyXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgLz5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxUYWJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGljb249XCJzZXR0aW5nc1wiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYWJlbD1cIlRhYiAzXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgLz5cclxuICAgICAgICAgICAgICAgICAgICA8L1RhYkJhcj5cclxuICAgICAgICAgICAgICAgIDwvQ29kZT5cclxuICAgICAgICAgICAgPC9TZWN0aW9uPlxyXG5cclxuICAgICAgICAgICAgPFNlY3Rpb24gdGl0bGU9XCJUYWJzIHdpdGggc3RhY2tlZCBpY29uc1wiPlxyXG4gICAgICAgICAgICAgICAgPENvZGU+XHJcbiAgICAgICAgICAgICAgICAgICAgPFRhYkJhclxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZT17c3RhY2tlZEljb25zfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFja2VkXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2hhbmdlPXt2YWx1ZSA9PiBzZXRTdGFja2VkSWNvbnModmFsdWUpfVxyXG4gICAgICAgICAgICAgICAgICAgID5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPFRhYlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWNvbj1cInN0YXJcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWw9XCJUYWIgMVwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8+XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8VGFiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpY29uPVwiZmF2b3JpdGVcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWw9XCJUYWIgMlwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8+XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8VGFiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpY29uPVwic2V0dGluZ3NcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWw9XCJUYWIgM1wiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8+XHJcbiAgICAgICAgICAgICAgICAgICAgPC9UYWJCYXI+XHJcbiAgICAgICAgICAgICAgICA8L0NvZGU+XHJcbiAgICAgICAgICAgIDwvU2VjdGlvbj5cclxuXHJcbiAgICAgICAgICAgIDxTZWN0aW9uIHRpdGxlPVwiVGFicyB3aXRoIGljb25zIG9ubHlcIj5cclxuICAgICAgICAgICAgICAgIDxDb2RlPlxyXG4gICAgICAgICAgICAgICAgICAgIDxUYWJCYXJcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU9e29ubHlJY29uc31cclxuICAgICAgICAgICAgICAgICAgICAgICAgaW5kaWNhdG9ySWNvbj1cInN0YXJcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBvbkNoYW5nZT17dmFsdWUgPT4gc2V0T25seUljb25zKHZhbHVlKX1cclxuICAgICAgICAgICAgICAgICAgICA+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxUYWJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGljb249XCJzdGFyXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgLz5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxUYWJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGljb249XCJmYXZvcml0ZVwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8+XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8VGFiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpY29uPVwic2V0dGluZ3NcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvPlxyXG4gICAgICAgICAgICAgICAgICAgIDwvVGFiQmFyPlxyXG4gICAgICAgICAgICAgICAgPC9Db2RlPlxyXG4gICAgICAgICAgICA8L1NlY3Rpb24+XHJcblxyXG4gICAgICAgICAgICA8U2VjdGlvbiB0aXRsZT1cIlRhYnMgd2l0aCBpY29uIGluZGljYXRvclwiPlxyXG4gICAgICAgICAgICAgICAgPENvZGU+XHJcbiAgICAgICAgICAgICAgICAgICAgPFRhYkJhclxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZT17aWNvbkluZGljYXRvcn1cclxuICAgICAgICAgICAgICAgICAgICAgICAgb25DaGFuZ2U9e3ZhbHVlID0+IHNldEljb25JbmRpY2F0b3IodmFsdWUpfVxyXG4gICAgICAgICAgICAgICAgICAgID5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPFRhYiBsYWJlbD1cIlRhYiAxXCIgLz5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPFRhYiBsYWJlbD1cIlRhYiAyXCIgLz5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPFRhYiBsYWJlbD1cIlRhYiAzXCIgLz5cclxuICAgICAgICAgICAgICAgICAgICA8L1RhYkJhcj5cclxuICAgICAgICAgICAgICAgIDwvQ29kZT5cclxuICAgICAgICAgICAgPC9TZWN0aW9uPlxyXG5cclxuICAgICAgICAgICAgPFNlY3Rpb24gdGl0bGU9XCJTY3JvbGxpbmcgdGFic1wiPlxyXG4gICAgICAgICAgICAgICAgPENvZGU+XHJcbiAgICAgICAgICAgICAgICAgICAgPFRhYkJhclxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZT17c2Nyb2xsfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBvbkNoYW5nZT17dmFsdWUgPT4gc2V0U2Nyb2xsKHZhbHVlKX1cclxuICAgICAgICAgICAgICAgICAgICA+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxUYWIgbGFiZWw9XCJUYWIgMVwiIC8+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxUYWIgbGFiZWw9XCJUYWIgMlwiIC8+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxUYWIgbGFiZWw9XCJUYWIgM1wiIC8+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxUYWIgbGFiZWw9XCJUYWIgNFwiIC8+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxUYWIgbGFiZWw9XCJUYWIgNVwiIC8+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxUYWIgbGFiZWw9XCJUYWIgNlwiIC8+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxUYWIgbGFiZWw9XCJUYWIgN1wiIC8+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxUYWIgbGFiZWw9XCJUYWIgOFwiIC8+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxUYWIgbGFiZWw9XCJUYWIgOVwiIC8+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxUYWIgbGFiZWw9XCJUYWIgMTBcIiAvPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8VGFiIGxhYmVsPVwiVGFiIDExXCIgLz5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPFRhYiBsYWJlbD1cIlRhYiAxMlwiIC8+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxUYWIgbGFiZWw9XCJUYWIgMTNcIiAvPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8VGFiIGxhYmVsPVwiVGFiIDE0XCIgLz5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPFRhYiBsYWJlbD1cIlRhYiAxNVwiIC8+XHJcbiAgICAgICAgICAgICAgICAgICAgPC9UYWJCYXI+XHJcbiAgICAgICAgICAgICAgICA8L0NvZGU+XHJcbiAgICAgICAgICAgIDwvU2VjdGlvbj5cclxuICAgICAgICA8L1BhZ2U+XHJcbiAgICApO1xyXG59IiwiaW1wb3J0IHsgdXNlU3RhdGUgfSBmcm9tICdyZWFjdCc7XHJcbmltcG9ydCB7XHJcbiAgICBUYWJCYXIsIFRhYixcclxuICAgIFRleHRGaWVsZFxyXG59IGZyb20gJ21kYy1yZWFjdCc7XHJcblxyXG5pbXBvcnQgUGFnZSBmcm9tICdAL2NvbXBvbmVudHMvUGFnZSc7XHJcbmltcG9ydCBTZWN0aW9uIGZyb20gJ0AvY29tcG9uZW50cy9TZWN0aW9uJztcclxuaW1wb3J0IENvZGUgZnJvbSAnQC9jb21wb25lbnRzL0NvZGUnO1xyXG5cclxuY29uc3QgaWQgPSAndGV4dC1maWVsZCc7XHJcbmNvbnN0IHRpdGxlID0gJ1RleHQgRmllbGQnO1xyXG5jb25zdCBkZXNjcmlwdGlvbiA9ICdUZXh0IGZpZWxkcyBsZXQgdXNlcnMgZW50ZXIgYW5kIGVkaXQgdGV4dC4nO1xyXG5jb25zdCBsaW5rcyA9IHtcclxuICAgIGRvY3M6ICdodHRwczovL2dpdGh1Yi5jb20vbWF0ZXJpYWwtY29tcG9uZW50cy9tYXRlcmlhbC1jb21wb25lbnRzLXdlYi90cmVlL21hc3Rlci9wYWNrYWdlcy9tZGMtdGV4dGZpZWxkJyxcclxuICAgIGd1aWRlOiAnaHR0cHM6Ly9tYXRlcmlhbC5pby9jb21wb25lbnRzL3RleHQtZmllbGRzJ1xyXG59O1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gVHlwb2dyYXBoeVBhZ2UoKSB7XHJcbiAgICBjb25zdCBbdHlwZSwgc2V0VHlwZV0gPSB1c2VTdGF0ZSgnZmlsbGVkJyk7XHJcblxyXG4gICAgY29uc3QgaXNGaWxsZWQgPSB0eXBlID09PSAnZmlsbGVkJyB8fCB1bmRlZmluZWQ7XHJcbiAgICBjb25zdCBpc091dGxpbmVkID0gdHlwZSA9PT0gJ291dGxpbmVkJyB8fCB1bmRlZmluZWQ7XHJcblxyXG4gICAgcmV0dXJuIChcclxuICAgICAgICA8UGFnZSBpZD17aWR9IHRpdGxlPXt0aXRsZX0gZGVzY3JpcHRpb249e2Rlc2NyaXB0aW9ufSBsaW5rcz17bGlua3N9PlxyXG4gICAgICAgICAgICA8VGFiQmFyIHZhbHVlPXt0eXBlfSBvbkNoYW5nZT17c2V0VHlwZX0gbWluV2lkdGg+XHJcbiAgICAgICAgICAgICAgICA8VGFiXHJcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU9XCJmaWxsZWRcIlxyXG4gICAgICAgICAgICAgICAgICAgIGxhYmVsPVwiRmlsbGVkXCJcclxuICAgICAgICAgICAgICAgIC8+XHJcblxyXG4gICAgICAgICAgICAgICAgPFRhYlxyXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlPVwib3V0bGluZWRcIlxyXG4gICAgICAgICAgICAgICAgICAgIGxhYmVsPVwiT3V0bGluZWRcIlxyXG4gICAgICAgICAgICAgICAgLz5cclxuICAgICAgICAgICAgPC9UYWJCYXI+XHJcblxyXG4gICAgICAgICAgICA8U2VjdGlvbiB0aXRsZT1cIkJhc2ljIHRleHQgZmllbGRcIj5cclxuICAgICAgICAgICAgICAgIDxDb2RlPlxyXG4gICAgICAgICAgICAgICAgICAgIDxUZXh0RmllbGRcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdFZhbHVlPVwiXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgZmlsbGVkPXtpc0ZpbGxlZH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgb3V0bGluZWQ9e2lzT3V0bGluZWR9XHJcbiAgICAgICAgICAgICAgICAgICAgLz5cclxuICAgICAgICAgICAgICAgIDwvQ29kZT5cclxuICAgICAgICAgICAgPC9TZWN0aW9uPlxyXG5cclxuICAgICAgICAgICAgPFNlY3Rpb24gdGl0bGU9XCJUZXh0IGZpZWxkIHdpdGggYSBsYWJlbFwiPlxyXG4gICAgICAgICAgICAgICAgPENvZGU+XHJcbiAgICAgICAgICAgICAgICAgICAgPFRleHRGaWVsZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0VmFsdWU9XCJcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBsYWJlbD1cIkxhYmVsXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgZmlsbGVkPXtpc0ZpbGxlZH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgb3V0bGluZWQ9e2lzT3V0bGluZWR9XHJcbiAgICAgICAgICAgICAgICAgICAgLz5cclxuICAgICAgICAgICAgICAgIDwvQ29kZT5cclxuICAgICAgICAgICAgPC9TZWN0aW9uPlxyXG5cclxuICAgICAgICAgICAgPFNlY3Rpb24gdGl0bGU9XCJUZXh0YXJlYVwiPlxyXG4gICAgICAgICAgICAgICAgPENvZGU+XHJcbiAgICAgICAgICAgICAgICAgICAgPFRleHRGaWVsZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0VmFsdWU9XCJcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBsYWJlbD1cIkxhYmVsXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dGFyZWFcclxuICAgICAgICAgICAgICAgICAgICAgICAgZmlsbGVkPXtpc0ZpbGxlZH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgb3V0bGluZWQ9e2lzT3V0bGluZWR9XHJcbiAgICAgICAgICAgICAgICAgICAgLz5cclxuICAgICAgICAgICAgICAgIDwvQ29kZT5cclxuICAgICAgICAgICAgPC9TZWN0aW9uPlxyXG5cclxuICAgICAgICAgICAgPFNlY3Rpb24gdGl0bGU9XCJBdXRvcmVzaXphYmxlIHRleHRhcmVhXCI+XHJcbiAgICAgICAgICAgICAgICA8Q29kZT5cclxuICAgICAgICAgICAgICAgICAgICA8VGV4dEZpZWxkXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHRWYWx1ZT1cIlwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsPVwiTGFiZWxcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0YXJlYVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBhdXRvUmVzaXplXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbGxlZD17aXNGaWxsZWR9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dGxpbmVkPXtpc091dGxpbmVkfVxyXG4gICAgICAgICAgICAgICAgICAgIC8+XHJcbiAgICAgICAgICAgICAgICA8L0NvZGU+XHJcbiAgICAgICAgICAgIDwvU2VjdGlvbj5cclxuXHJcbiAgICAgICAgICAgIDxTZWN0aW9uIHRpdGxlPVwiUHJlLWZpbGxlZCB0ZXh0IGZpZWxkXCI+XHJcbiAgICAgICAgICAgICAgICA8Q29kZT5cclxuICAgICAgICAgICAgICAgICAgICA8VGV4dEZpZWxkXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHRWYWx1ZT1cIlNvbWUgdGV4dFwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsPVwiTGFiZWxcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmaWxsZWQ9e2lzRmlsbGVkfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRsaW5lZD17aXNPdXRsaW5lZH1cclxuICAgICAgICAgICAgICAgICAgICAvPlxyXG4gICAgICAgICAgICAgICAgPC9Db2RlPlxyXG4gICAgICAgICAgICA8L1NlY3Rpb24+XHJcblxyXG4gICAgICAgICAgICA8U2VjdGlvbiB0aXRsZT1cIldpdGggaGVscGVyIHRleHRcIj5cclxuICAgICAgICAgICAgICAgIDxDb2RlPlxyXG4gICAgICAgICAgICAgICAgICAgIDxUZXh0RmllbGRcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdFZhbHVlPVwiXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgaGVscGVyVGV4dD1cIkhlbHBlciB0ZXh0XCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgZmlsbGVkPXtpc0ZpbGxlZH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgb3V0bGluZWQ9e2lzT3V0bGluZWR9XHJcbiAgICAgICAgICAgICAgICAgICAgLz5cclxuICAgICAgICAgICAgICAgIDwvQ29kZT5cclxuICAgICAgICAgICAgPC9TZWN0aW9uPlxyXG5cclxuICAgICAgICAgICAgPFNlY3Rpb24gdGl0bGU9XCJXaXRoIHBlcnNpc3RlbnQgaGVscGVyIHRleHRcIj5cclxuICAgICAgICAgICAgICAgIDxDb2RlPlxyXG4gICAgICAgICAgICAgICAgICAgIDxUZXh0RmllbGRcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdFZhbHVlPVwiXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgcGVyc2lzdGVudEhlbHBlclRleHQ9XCJIZWxwZXIgdGV4dFwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbGxlZD17aXNGaWxsZWR9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dGxpbmVkPXtpc091dGxpbmVkfVxyXG4gICAgICAgICAgICAgICAgICAgIC8+XHJcbiAgICAgICAgICAgICAgICA8L0NvZGU+XHJcbiAgICAgICAgICAgIDwvU2VjdGlvbj5cclxuXHJcbiAgICAgICAgICAgIDxTZWN0aW9uIHRpdGxlPVwiVGV4dCBmaWVsZCB3aXRoIHZhbGlkYXRpb24gbWVzc2FnZVwiPlxyXG4gICAgICAgICAgICAgICAgPENvZGU+XHJcbiAgICAgICAgICAgICAgICAgICAgPFRleHRGaWVsZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0VmFsdWU9XCJcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBsYWJlbD1cIkxhYmVsXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWlyZWRcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGlvbk1lc3NhZ2U9XCJWYWxpZGF0aW9uIG1lc3NhZ2VcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmaWxsZWQ9e2lzRmlsbGVkfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRsaW5lZD17aXNPdXRsaW5lZH1cclxuICAgICAgICAgICAgICAgICAgICAvPlxyXG4gICAgICAgICAgICAgICAgPC9Db2RlPlxyXG4gICAgICAgICAgICA8L1NlY3Rpb24+XHJcblxyXG4gICAgICAgICAgICA8U2VjdGlvbiB0aXRsZT1cIlRleHQgZmllbGQgd2l0aCBhIGNoYXJhY3RlciBjb3VudGVyXCI+XHJcbiAgICAgICAgICAgICAgICA8Q29kZT5cclxuICAgICAgICAgICAgICAgICAgICA8VGV4dEZpZWxkXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHRWYWx1ZT1cIlwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsPVwiTGFiZWxcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXhMZW5ndGg9ezEwfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmaWxsZWQ9e2lzRmlsbGVkfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRsaW5lZD17aXNPdXRsaW5lZH1cclxuICAgICAgICAgICAgICAgICAgICAvPlxyXG4gICAgICAgICAgICAgICAgPC9Db2RlPlxyXG4gICAgICAgICAgICA8L1NlY3Rpb24+XHJcblxyXG4gICAgICAgICAgICA8U2VjdGlvbiB0aXRsZT1cIlRleHQgZmllbGQgd2l0aCBhbiBpbnRlcm5hbCBjaGFyYWN0ZXIgY291bnRlclwiPlxyXG4gICAgICAgICAgICAgICAgPENvZGU+XHJcbiAgICAgICAgICAgICAgICAgICAgPFRleHRGaWVsZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0VmFsdWU9XCJcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBsYWJlbD1cIkxhYmVsXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWF4TGVuZ3RoPXsxMjB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbGxlZD17aXNGaWxsZWR9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dGxpbmVkPXtpc091dGxpbmVkfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0YXJlYVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbnRlcm5hbENvdW50ZXJcclxuICAgICAgICAgICAgICAgICAgICAvPlxyXG4gICAgICAgICAgICAgICAgPC9Db2RlPlxyXG4gICAgICAgICAgICA8L1NlY3Rpb24+XHJcblxyXG4gICAgICAgICAgICA8U2VjdGlvbiB0aXRsZT1cIlRleHQgZmllbGQgd2l0aCBhIHByZWZpeFwiPlxyXG4gICAgICAgICAgICAgICAgPENvZGU+XHJcbiAgICAgICAgICAgICAgICAgICAgPFRleHRGaWVsZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0VmFsdWU9XCJcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBsYWJlbD1cIkxhYmVsXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgcHJlZml4PVwiQFwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbGxlZD17aXNGaWxsZWR9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dGxpbmVkPXtpc091dGxpbmVkfVxyXG4gICAgICAgICAgICAgICAgICAgIC8+XHJcbiAgICAgICAgICAgICAgICA8L0NvZGU+XHJcbiAgICAgICAgICAgIDwvU2VjdGlvbj5cclxuXHJcbiAgICAgICAgICAgIDxTZWN0aW9uIHRpdGxlPVwiVGV4dCBmaWVsZCB3aXRoIGEgc3VmZml4XCI+XHJcbiAgICAgICAgICAgICAgICA8Q29kZT5cclxuICAgICAgICAgICAgICAgICAgICA8VGV4dEZpZWxkXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHRWYWx1ZT1cIlwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsPVwiTGFiZWxcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdWZmaXg9XCIkXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgZmlsbGVkPXtpc0ZpbGxlZH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgb3V0bGluZWQ9e2lzT3V0bGluZWR9XHJcbiAgICAgICAgICAgICAgICAgICAgLz5cclxuICAgICAgICAgICAgICAgIDwvQ29kZT5cclxuICAgICAgICAgICAgPC9TZWN0aW9uPlxyXG5cclxuICAgICAgICAgICAgPFNlY3Rpb24gdGl0bGU9XCJUZXh0IGZpZWxkIHdpdGggYSBsZWFkaW5nIGljb25cIj5cclxuICAgICAgICAgICAgICAgIDxDb2RlPlxyXG4gICAgICAgICAgICAgICAgICAgIDxUZXh0RmllbGRcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdFZhbHVlPVwiXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGVhZGluZ0ljb249XCJzdGFyXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgZmlsbGVkPXtpc0ZpbGxlZH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgb3V0bGluZWQ9e2lzT3V0bGluZWR9XHJcbiAgICAgICAgICAgICAgICAgICAgLz5cclxuICAgICAgICAgICAgICAgIDwvQ29kZT5cclxuICAgICAgICAgICAgPC9TZWN0aW9uPlxyXG5cclxuICAgICAgICAgICAgPFNlY3Rpb24gdGl0bGU9XCJUZXh0IGZpZWxkIHdpdGggYSB0cmFpbGluZyBpY29uXCI+XHJcbiAgICAgICAgICAgICAgICA8Q29kZT5cclxuICAgICAgICAgICAgICAgICAgICA8VGV4dEZpZWxkXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHRWYWx1ZT1cIlwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYWlsaW5nSWNvbj1cImVkaXRcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmaWxsZWQ9e2lzRmlsbGVkfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRsaW5lZD17aXNPdXRsaW5lZH1cclxuICAgICAgICAgICAgICAgICAgICAvPlxyXG4gICAgICAgICAgICAgICAgPC9Db2RlPlxyXG4gICAgICAgICAgICA8L1NlY3Rpb24+XHJcbiAgICAgICAgPC9QYWdlPlxyXG4gICAgKTtcclxufSIsImltcG9ydCB7XHJcbiAgICBJY29uQnV0dG9uLFxyXG4gICAgVG9vbHRpcCwgUmljaFRvb2x0aXBcclxufSBmcm9tICdtZGMtcmVhY3QnO1xyXG5cclxuaW1wb3J0IFBhZ2UgZnJvbSAnQC9jb21wb25lbnRzL1BhZ2UnO1xyXG5pbXBvcnQgU2VjdGlvbiBmcm9tICdAL2NvbXBvbmVudHMvU2VjdGlvbic7XHJcbmltcG9ydCBDb2RlIGZyb20gJ0AvY29tcG9uZW50cy9Db2RlJztcclxuXHJcbmNvbnN0IGlkID0gJ3Rvb2x0aXAnO1xyXG5jb25zdCB0aXRsZSA9ICdUb29sdGlwJztcclxuY29uc3QgZGVzY3JpcHRpb24gPSAnVG9vbHRpcHMgZGlzcGxheSBpbmZvcm1hdGl2ZSB0ZXh0IHdoZW4gdXNlcnMgaG92ZXIgb3ZlciwgZm9jdXMgb24sIG9yIHRhcCBhbiBlbGVtZW50Lic7XHJcbmNvbnN0IGxpbmtzID0ge1xyXG4gICAgZG9jczogJ2h0dHBzOi8vZ2l0aHViLmNvbS9tYXRlcmlhbC1jb21wb25lbnRzL21hdGVyaWFsLWNvbXBvbmVudHMtd2ViL3RyZWUvbWFzdGVyL3BhY2thZ2VzL21kYy10b29sdGlwJyxcclxuICAgIGd1aWRlOiAnaHR0cHM6Ly9tYXRlcmlhbC5pby9jb21wb25lbnRzL3Rvb2x0aXBzJ1xyXG59O1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gVG9vbHRpcFBhZ2UoKSB7XHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAgIDxQYWdlIGlkPXtpZH0gdGl0bGU9e3RpdGxlfSBkZXNjcmlwdGlvbj17ZGVzY3JpcHRpb259IGxpbmtzPXtsaW5rc30+XHJcbiAgICAgICAgICAgIDxTZWN0aW9uIHRpdGxlPVwiQmFzaWMgdG9vbHRpcFwiPlxyXG4gICAgICAgICAgICAgICAgPENvZGU+XHJcbiAgICAgICAgICAgICAgICAgICAgPFRvb2x0aXAgbGFiZWw9XCJTdGFyXCI+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxJY29uQnV0dG9uIGljb249XCJzdGFyXCIgLz5cclxuICAgICAgICAgICAgICAgICAgICA8L1Rvb2x0aXA+XHJcbiAgICAgICAgICAgICAgICA8L0NvZGU+XHJcbiAgICAgICAgICAgIDwvU2VjdGlvbj5cclxuXHJcbiAgICAgICAgICAgIDxTZWN0aW9uIHRpdGxlPVwiTXVsdGlsaW5lIHRvb2x0aXBcIj5cclxuICAgICAgICAgICAgICAgIDxDb2RlPlxyXG4gICAgICAgICAgICAgICAgICAgIDxUb29sdGlwIGxhYmVsPVwiVGhpcyBpcyBhIHN0YXIgaWNvbiBidXR0b24sIHlvdSBzaG91bGQgY2xpY2sgb24gaXRcIj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPEljb25CdXR0b24gaWNvbj1cInN0YXJcIiAvPlxyXG4gICAgICAgICAgICAgICAgICAgIDwvVG9vbHRpcD5cclxuICAgICAgICAgICAgICAgIDwvQ29kZT5cclxuICAgICAgICAgICAgPC9TZWN0aW9uPlxyXG5cclxuICAgICAgICAgICAgPFNlY3Rpb24gdGl0bGU9XCJSaWNoIHRvb2x0aXBcIj5cclxuICAgICAgICAgICAgICAgIDxDb2RlPlxyXG4gICAgICAgICAgICAgICAgICAgIDxSaWNoVG9vbHRpcFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aXRsZT1cIlRpdGxlXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudD1cIkRlZmF1bHQgcmljaCB0b29sdGlwcyBhcmUgc2hvd24gd2hlbiB1c2VycyBob3ZlciBvdmVyIG9yIGZvY3VzIG9uIHRoZWlyIGFuY2hvciBlbGVtZW50LiBUaGV5IHJlbWFpbiBzaG93biB3aGVuIHVzZXJzIGZvY3VzL2hvdmVyIG92ZXIgdGhlIGNvbnRlbnRzIG9mIHRoZSByaWNoIHRvb2x0aXAsIGJ1dCBiZWNvbWVzIGhpZGRlbiBpZiB0aGUgdXNlcnMgZm9jdXMvaG92ZXIgb3V0c2lkZSBvZiB0aGUgYW5jaG9yIGVsZW1lbnQgb3IgdGhlIHRvb2x0aXAgY29udGVudHMuIElmIHRoZSB1c2VyIGNsaWNrcyB3aXRoaW4gdGhlIGNvbnRlbnRzIG9mIHRoZSB0b29sdGlwLCB0aGUgdG9vbHRpcCB3aWxsIGFsc28gYmUgaGlkZGVuLlwiXHJcbiAgICAgICAgICAgICAgICAgICAgPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8SWNvbkJ1dHRvbiBpY29uPVwic3RhclwiIC8+XHJcbiAgICAgICAgICAgICAgICAgICAgPC9SaWNoVG9vbHRpcD5cclxuICAgICAgICAgICAgICAgIDwvQ29kZT5cclxuICAgICAgICAgICAgPC9TZWN0aW9uPlxyXG4gICAgICAgIDwvUGFnZT5cclxuICAgICk7XHJcbn0iLCJpbXBvcnQgeyB1c2VTdGF0ZSB9IGZyb20gJ3JlYWN0JztcclxuaW1wb3J0IHtcclxuICAgIEljb25CdXR0b24sXHJcbiAgICBUb3BBcHBCYXJcclxufSBmcm9tICdtZGMtcmVhY3QnO1xyXG5cclxuaW1wb3J0IFBhZ2UgZnJvbSAnQC9jb21wb25lbnRzL1BhZ2UnO1xyXG5pbXBvcnQgU2VjdGlvbiBmcm9tICdAL2NvbXBvbmVudHMvU2VjdGlvbic7XHJcbmltcG9ydCBDb2RlIGZyb20gJ0AvY29tcG9uZW50cy9Db2RlJztcclxuXHJcbmltcG9ydCAnLi9pbmRleC5zY3NzJztcclxuXHJcbmNvbnN0IGlkID0gJ3RvcC1hcHAtYmFyJztcclxuY29uc3QgdGl0bGUgPSAnVG9wIEFwcCBCYXInO1xyXG5jb25zdCBkZXNjcmlwdGlvbiA9ICdUaGUgdG9wIGFwcCBiYXIgZGlzcGxheXMgaW5mb3JtYXRpb24gYW5kIGFjdGlvbnMgcmVsYXRpbmcgdG8gdGhlIGN1cnJlbnQgc2NyZWVuLic7XHJcbmNvbnN0IGxpbmtzID0ge1xyXG4gICAgZG9jczogJ2h0dHBzOi8vZ2l0aHViLmNvbS9tYXRlcmlhbC1jb21wb25lbnRzL21hdGVyaWFsLWNvbXBvbmVudHMtd2ViL3RyZWUvbWFzdGVyL3BhY2thZ2VzL21kYy10b3AtYXBwLWJhcicsXHJcbiAgICBndWlkZTogJ2h0dHBzOi8vbWF0ZXJpYWwuaW8vY29tcG9uZW50cy9hcHAtYmFycy10b3AnXHJcbn07XHJcblxyXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBUb3BBcHBCYXJQYWdlKCkge1xyXG4gICAgY29uc3QgW2lzQ29sbGFwc2VkLCBzZXRDb2xsYXBzZWRdID0gdXNlU3RhdGUoZmFsc2UpO1xyXG5cclxuICAgIGNvbnN0IGFjdGlvbkl0ZW1zID0gW1xyXG4gICAgICAgIDxJY29uQnV0dG9uIGtleT1cImFkZFwiIGljb249XCJhZGRcIiAvPixcclxuICAgICAgICA8SWNvbkJ1dHRvbiBrZXk9XCJlZGl0XCIgaWNvbj1cImVkaXRcIiAvPixcclxuICAgICAgICA8SWNvbkJ1dHRvbiBrZXk9XCJkZWxldGVcIiBpY29uPVwiZGVsZXRlXCIgLz5cclxuICAgIF07XHJcblxyXG4gICAgcmV0dXJuIChcclxuICAgICAgICA8UGFnZSBpZD17aWR9IHRpdGxlPXt0aXRsZX0gZGVzY3JpcHRpb249e2Rlc2NyaXB0aW9ufSBsaW5rcz17bGlua3N9PlxyXG4gICAgICAgICAgICA8U2VjdGlvbj5cclxuICAgICAgICAgICAgICAgIDxDb2RlPlxyXG4gICAgICAgICAgICAgICAgICAgIDxUb3BBcHBCYXJcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGU9XCJCYXNpY1wiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hdmlnYXRpb25JY29uPVwibWVudVwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjdGlvbkl0ZW1zPXthY3Rpb25JdGVtc31cclxuICAgICAgICAgICAgICAgICAgICAvPlxyXG4gICAgICAgICAgICAgICAgPC9Db2RlPlxyXG4gICAgICAgICAgICA8L1NlY3Rpb24+XHJcblxyXG4gICAgICAgICAgICA8U2VjdGlvbj5cclxuICAgICAgICAgICAgICAgIDxDb2RlPlxyXG4gICAgICAgICAgICAgICAgICAgIDxUb3BBcHBCYXJcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGU9XCJEZW5zZVwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hdmlnYXRpb25JY29uPVwibWVudVwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjdGlvbkl0ZW1zPXthY3Rpb25JdGVtc31cclxuICAgICAgICAgICAgICAgICAgICAgICAgZGVuc2VcclxuICAgICAgICAgICAgICAgICAgICAvPlxyXG4gICAgICAgICAgICAgICAgPC9Db2RlPlxyXG4gICAgICAgICAgICA8L1NlY3Rpb24+XHJcblxyXG4gICAgICAgICAgICA8U2VjdGlvbj5cclxuICAgICAgICAgICAgICAgIDxDb2RlPlxyXG4gICAgICAgICAgICAgICAgICAgIDxUb3BBcHBCYXJcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGU9XCJQcm9taW5lbnRcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBuYXZpZ2F0aW9uSWNvbj1cIm1lbnVcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBhY3Rpb25JdGVtcz17YWN0aW9uSXRlbXN9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb21pbmVudFxyXG4gICAgICAgICAgICAgICAgICAgIC8+XHJcbiAgICAgICAgICAgICAgICA8L0NvZGU+XHJcbiAgICAgICAgICAgIDwvU2VjdGlvbj5cclxuXHJcbiAgICAgICAgICAgIDxTZWN0aW9uPlxyXG4gICAgICAgICAgICAgICAgPENvZGU+XHJcbiAgICAgICAgICAgICAgICAgICAgPFRvcEFwcEJhclxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aXRsZT1cIlNob3J0XCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmF2aWdhdGlvbkljb249XCJtZW51XCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2hvcnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29sbGFwc2VkPXtpc0NvbGxhcHNlZH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgb25OYXZpZ2F0aW9uSWNvbkNsaWNrPXsoKSA9PiBzZXRDb2xsYXBzZWQodiA9PiAhdil9XHJcbiAgICAgICAgICAgICAgICAgICAgLz5cclxuICAgICAgICAgICAgICAgIDwvQ29kZT5cclxuICAgICAgICAgICAgPC9TZWN0aW9uPlxyXG4gICAgICAgIDwvUGFnZT5cclxuICAgICk7XHJcbn0iLCJpbXBvcnQge1xyXG4gICAgVHlwb2dyYXBoeVxyXG59IGZyb20gJ21kYy1yZWFjdCc7XHJcblxyXG5pbXBvcnQgUGFnZSBmcm9tICdAL2NvbXBvbmVudHMvUGFnZSc7XHJcbmltcG9ydCBTZWN0aW9uIGZyb20gJ0AvY29tcG9uZW50cy9TZWN0aW9uJztcclxuaW1wb3J0IENvZGUgZnJvbSAnQC9jb21wb25lbnRzL0NvZGUnO1xyXG5cclxuY29uc3QgaWQgPSAndHlwb2dyYXBoeSc7XHJcbmNvbnN0IHRpdGxlID0gJ1R5cG9ncmFwaHknO1xyXG5jb25zdCBkZXNjcmlwdGlvbiA9ICdUeXBvZ3JhcGh5IGV4cHJlc3NlcyBoaWVyYXJjaHkgYW5kIGJyYW5kIHByZXNlbmNlLic7XHJcbmNvbnN0IGxpbmtzID0ge1xyXG4gICAgZG9jczogJ2h0dHBzOi8vZ2l0aHViLmNvbS9tYXRlcmlhbC1jb21wb25lbnRzL21hdGVyaWFsLWNvbXBvbmVudHMtd2ViL3RyZWUvbWFzdGVyL3BhY2thZ2VzL21kYy10eXBvZ3JhcGh5JyxcclxuICAgIGd1aWRlOiAnaHR0cHM6Ly9tYXRlcmlhbC5pby9kZXNpZ24vdHlwb2dyYXBoeSdcclxufTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIFR5cG9ncmFwaHlQYWdlKCkge1xyXG4gICAgcmV0dXJuIChcclxuICAgICAgICA8UGFnZSBpZD17aWR9IHRpdGxlPXt0aXRsZX0gZGVzY3JpcHRpb249e2Rlc2NyaXB0aW9ufSBsaW5rcz17bGlua3N9PlxyXG4gICAgICAgICAgICA8U2VjdGlvbj5cclxuICAgICAgICAgICAgICAgIDxDb2RlPlxyXG4gICAgICAgICAgICAgICAgICAgIDxUeXBvZ3JhcGh5IHR5cGU9XCJoZWFkbGluZTFcIiBub01hcmdpbj5IZWFkbGluZSAxPC9UeXBvZ3JhcGh5PlxyXG4gICAgICAgICAgICAgICAgPC9Db2RlPlxyXG4gICAgICAgICAgICA8L1NlY3Rpb24+XHJcblxyXG4gICAgICAgICAgICA8U2VjdGlvbj5cclxuICAgICAgICAgICAgICAgIDxDb2RlPlxyXG4gICAgICAgICAgICAgICAgICAgIDxUeXBvZ3JhcGh5IHR5cGU9XCJoZWFkbGluZTJcIiBub01hcmdpbj5IZWFkbGluZSAyPC9UeXBvZ3JhcGh5PlxyXG4gICAgICAgICAgICAgICAgPC9Db2RlPlxyXG4gICAgICAgICAgICA8L1NlY3Rpb24+XHJcblxyXG4gICAgICAgICAgICA8U2VjdGlvbj5cclxuICAgICAgICAgICAgICAgIDxDb2RlPlxyXG4gICAgICAgICAgICAgICAgICAgIDxUeXBvZ3JhcGh5IHR5cGU9XCJoZWFkbGluZTNcIiBub01hcmdpbj5IZWFkbGluZSAzPC9UeXBvZ3JhcGh5PlxyXG4gICAgICAgICAgICAgICAgPC9Db2RlPlxyXG4gICAgICAgICAgICA8L1NlY3Rpb24+XHJcblxyXG4gICAgICAgICAgICA8U2VjdGlvbj5cclxuICAgICAgICAgICAgICAgIDxDb2RlPlxyXG4gICAgICAgICAgICAgICAgICAgIDxUeXBvZ3JhcGh5IHR5cGU9XCJoZWFkbGluZTRcIiBub01hcmdpbj5IZWFkbGluZSA0PC9UeXBvZ3JhcGh5PlxyXG4gICAgICAgICAgICAgICAgPC9Db2RlPlxyXG4gICAgICAgICAgICA8L1NlY3Rpb24+XHJcblxyXG4gICAgICAgICAgICA8U2VjdGlvbj5cclxuICAgICAgICAgICAgICAgIDxDb2RlPlxyXG4gICAgICAgICAgICAgICAgICAgIDxUeXBvZ3JhcGh5IHR5cGU9XCJoZWFkbGluZTVcIiBub01hcmdpbj5IZWFkbGluZSA1PC9UeXBvZ3JhcGh5PlxyXG4gICAgICAgICAgICAgICAgPC9Db2RlPlxyXG4gICAgICAgICAgICA8L1NlY3Rpb24+XHJcblxyXG4gICAgICAgICAgICA8U2VjdGlvbj5cclxuICAgICAgICAgICAgICAgIDxDb2RlPlxyXG4gICAgICAgICAgICAgICAgICAgIDxUeXBvZ3JhcGh5IHR5cGU9XCJoZWFkbGluZTZcIiBub01hcmdpbj5IZWFkbGluZSA2PC9UeXBvZ3JhcGh5PlxyXG4gICAgICAgICAgICAgICAgPC9Db2RlPlxyXG4gICAgICAgICAgICA8L1NlY3Rpb24+XHJcblxyXG4gICAgICAgICAgICA8U2VjdGlvbj5cclxuICAgICAgICAgICAgICAgIDxDb2RlPlxyXG4gICAgICAgICAgICAgICAgICAgIDxUeXBvZ3JhcGh5IHR5cGU9XCJzdWJ0aXRsZTFcIiBub01hcmdpbj5TdWJ0aXRsZSAxPC9UeXBvZ3JhcGh5PlxyXG4gICAgICAgICAgICAgICAgPC9Db2RlPlxyXG4gICAgICAgICAgICA8L1NlY3Rpb24+XHJcblxyXG4gICAgICAgICAgICA8U2VjdGlvbj5cclxuICAgICAgICAgICAgICAgIDxDb2RlPlxyXG4gICAgICAgICAgICAgICAgICAgIDxUeXBvZ3JhcGh5IHR5cGU9XCJzdWJ0aXRsZTJcIiBub01hcmdpbj5TdWJ0aXRsZSAyPC9UeXBvZ3JhcGh5PlxyXG4gICAgICAgICAgICAgICAgPC9Db2RlPlxyXG4gICAgICAgICAgICA8L1NlY3Rpb24+XHJcblxyXG4gICAgICAgICAgICA8U2VjdGlvbj5cclxuICAgICAgICAgICAgICAgIDxDb2RlPlxyXG4gICAgICAgICAgICAgICAgICAgIDxUeXBvZ3JhcGh5IHR5cGU9XCJib2R5MVwiIG5vTWFyZ2luPkJvZHkgMTwvVHlwb2dyYXBoeT5cclxuICAgICAgICAgICAgICAgIDwvQ29kZT5cclxuICAgICAgICAgICAgPC9TZWN0aW9uPlxyXG5cclxuICAgICAgICAgICAgPFNlY3Rpb24+XHJcbiAgICAgICAgICAgICAgICA8Q29kZT5cclxuICAgICAgICAgICAgICAgICAgICA8VHlwb2dyYXBoeSB0eXBlPVwiYm9keTJcIiBub01hcmdpbj5Cb2R5IDI8L1R5cG9ncmFwaHk+XHJcbiAgICAgICAgICAgICAgICA8L0NvZGU+XHJcbiAgICAgICAgICAgIDwvU2VjdGlvbj5cclxuXHJcbiAgICAgICAgICAgIDxTZWN0aW9uPlxyXG4gICAgICAgICAgICAgICAgPENvZGU+XHJcbiAgICAgICAgICAgICAgICAgICAgPFR5cG9ncmFwaHkgdHlwZT1cImNhcHRpb25cIj5DYXB0aW9uPC9UeXBvZ3JhcGh5PlxyXG4gICAgICAgICAgICAgICAgPC9Db2RlPlxyXG4gICAgICAgICAgICA8L1NlY3Rpb24+XHJcblxyXG4gICAgICAgICAgICA8U2VjdGlvbj5cclxuICAgICAgICAgICAgICAgIDxDb2RlPlxyXG4gICAgICAgICAgICAgICAgICAgIDxUeXBvZ3JhcGh5IHR5cGU9XCJidXR0b25cIj5CdXR0b248L1R5cG9ncmFwaHk+XHJcbiAgICAgICAgICAgICAgICA8L0NvZGU+XHJcbiAgICAgICAgICAgIDwvU2VjdGlvbj5cclxuXHJcbiAgICAgICAgICAgIDxTZWN0aW9uPlxyXG4gICAgICAgICAgICAgICAgPENvZGU+XHJcbiAgICAgICAgICAgICAgICAgICAgPFR5cG9ncmFwaHkgdHlwZT1cIm92ZXJsaW5lXCI+T3ZlcmxpbmU8L1R5cG9ncmFwaHk+XHJcbiAgICAgICAgICAgICAgICA8L0NvZGU+XHJcbiAgICAgICAgICAgIDwvU2VjdGlvbj5cclxuICAgICAgICA8L1BhZ2U+XHJcbiAgICApO1xyXG59IiwiaW1wb3J0IEF2YXRhciBmcm9tICcuL0F2YXRhcic7XHJcbmltcG9ydCBCYWRnZSBmcm9tICcuL0JhZGdlJztcclxuaW1wb3J0IEJhbm5lciBmcm9tICcuL0Jhbm5lcic7XHJcbmltcG9ydCBCdXR0b24gZnJvbSAnLi9CdXR0b24nO1xyXG5pbXBvcnQgQ2FyZCBmcm9tICcuL0NhcmQnO1xyXG5pbXBvcnQgQ2hlY2tib3ggZnJvbSAnLi9DaGVja2JveCc7XHJcbmltcG9ydCBDaGlwcyBmcm9tICcuL0NoaXBzJztcclxuaW1wb3J0IENpcmN1bGFyUHJvZ3Jlc3MgZnJvbSAnLi9DaXJjdWxhclByb2dyZXNzJztcclxuaW1wb3J0IERhdGFUYWJsZSBmcm9tICcuL0RhdGFUYWJsZSc7XHJcbmltcG9ydCBEaWFsb2cgZnJvbSAnLi9EaWFsb2cnO1xyXG5pbXBvcnQgRHJhd2VyIGZyb20gJy4vRHJhd2VyJztcclxuaW1wb3J0IEVsZXZhdGlvbiBmcm9tICcuL0VsZXZhdGlvbic7XHJcbmltcG9ydCBGQUIgZnJvbSAnLi9GQUInO1xyXG5pbXBvcnQgRm9ybUZpZWxkIGZyb20gJy4vRm9ybUZpZWxkJztcclxuaW1wb3J0IEhvbWUgZnJvbSAnLi9Ib21lJztcclxuaW1wb3J0IEljb25CdXR0b24gZnJvbSAnLi9JY29uQnV0dG9uJztcclxuaW1wb3J0IEltYWdlTGlzdCBmcm9tICcuL0ltYWdlTGlzdCc7XHJcbmltcG9ydCBMYXlvdXRHcmlkIGZyb20gJy4vTGF5b3V0R3JpZCc7XHJcbmltcG9ydCBMaW5lYXJQcm9ncmVzcyBmcm9tICcuL0xpbmVhclByb2dyZXNzJztcclxuaW1wb3J0IExpc3QgZnJvbSAnLi9MaXN0JztcclxuaW1wb3J0IE1lbnUgZnJvbSAnLi9NZW51JztcclxuaW1wb3J0IFJhZGlvIGZyb20gJy4vUmFkaW8nO1xyXG5pbXBvcnQgUmlwcGxlIGZyb20gJy4vUmlwcGxlJztcclxuaW1wb3J0IFNlZ21lbnRlZEJ1dHRvbiBmcm9tICcuL1NlZ21lbnRlZEJ1dHRvbic7XHJcbmltcG9ydCBTZWxlY3QgZnJvbSAnLi9TZWxlY3QnO1xyXG5pbXBvcnQgU2lkZVNoZWV0IGZyb20gJy4vU2lkZVNoZWV0JztcclxuaW1wb3J0IFNsaWRlciBmcm9tICcuL1NsaWRlcic7XHJcbmltcG9ydCBTbmFja2JhciBmcm9tICcuL1NuYWNrYmFyJztcclxuaW1wb3J0IFN3aXRjaCBmcm9tICcuL1N3aXRjaCc7XHJcbmltcG9ydCBUYWJzIGZyb20gJy4vVGFicyc7XHJcbmltcG9ydCBUZXh0RmllbGQgZnJvbSAnLi9UZXh0RmllbGQnO1xyXG5pbXBvcnQgVG9vbHRpcCBmcm9tICcuL1Rvb2x0aXAnO1xyXG5pbXBvcnQgVG9wQXBwQmFyIGZyb20gJy4vVG9wQXBwQmFyJztcclxuaW1wb3J0IFR5cG9ncmFwaHkgZnJvbSAnLi9UeXBvZ3JhcGh5JztcclxuXHJcbmV4cG9ydCB7XHJcbiAgICBBdmF0YXIsXHJcbiAgICBCYWRnZSxcclxuICAgIEJhbm5lcixcclxuICAgIEJ1dHRvbixcclxuICAgIENhcmQsXHJcbiAgICBDaGVja2JveCxcclxuICAgIENoaXBzLFxyXG4gICAgQ2lyY3VsYXJQcm9ncmVzcyxcclxuICAgIERhdGFUYWJsZSxcclxuICAgIERpYWxvZyxcclxuICAgIERyYXdlcixcclxuICAgIEVsZXZhdGlvbixcclxuICAgIEZBQixcclxuICAgIEZvcm1GaWVsZCxcclxuICAgIEhvbWUsXHJcbiAgICBJY29uQnV0dG9uLFxyXG4gICAgSW1hZ2VMaXN0LFxyXG4gICAgTGF5b3V0R3JpZCxcclxuICAgIExpbmVhclByb2dyZXNzLFxyXG4gICAgTGlzdCxcclxuICAgIE1lbnUsXHJcbiAgICBSYWRpbyxcclxuICAgIFJpcHBsZSxcclxuICAgIFNlZ21lbnRlZEJ1dHRvbixcclxuICAgIFNlbGVjdCxcclxuICAgIFNpZGVTaGVldCxcclxuICAgIFNsaWRlcixcclxuICAgIFNuYWNrYmFyLFxyXG4gICAgU3dpdGNoLFxyXG4gICAgVGFicyxcclxuICAgIFRleHRGaWVsZCxcclxuICAgIFRvb2x0aXAsXHJcbiAgICBUb3BBcHBCYXIsXHJcbiAgICBUeXBvZ3JhcGh5XHJcbn07IiwiaW1wb3J0IHtcclxuICAgIEF2YXRhcixcclxuICAgIEJhZGdlLFxyXG4gICAgQmFubmVyLFxyXG4gICAgQnV0dG9uLFxyXG4gICAgQ2FyZCxcclxuICAgIENoZWNrYm94LFxyXG4gICAgQ2hpcHMsXHJcbiAgICBDaXJjdWxhclByb2dyZXNzLFxyXG4gICAgRGF0YVRhYmxlLFxyXG4gICAgRGlhbG9nLFxyXG4gICAgRHJhd2VyLFxyXG4gICAgRWxldmF0aW9uLFxyXG4gICAgRkFCLFxyXG4gICAgRm9ybUZpZWxkLFxyXG4gICAgSWNvbkJ1dHRvbixcclxuICAgIEltYWdlTGlzdCxcclxuICAgIExheW91dEdyaWQsXHJcbiAgICBMaW5lYXJQcm9ncmVzcyxcclxuICAgIExpc3QsXHJcbiAgICBNZW51LFxyXG4gICAgUmFkaW8sXHJcbiAgICBSaXBwbGUsXHJcbiAgICBTZWdtZW50ZWRCdXR0b24sXHJcbiAgICBTZWxlY3QsXHJcbiAgICBTaWRlU2hlZXQsXHJcbiAgICBTbGlkZXIsXHJcbiAgICBTbmFja2JhcixcclxuICAgIFN3aXRjaCxcclxuICAgIFRhYnMsXHJcbiAgICBUZXh0RmllbGQsXHJcbiAgICBUb29sdGlwLFxyXG4gICAgVG9wQXBwQmFyLFxyXG4gICAgVHlwb2dyYXBoeVxyXG59IGZyb20gJy4vcGFnZXMnO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgW1xyXG4gICAgeyB0aXRsZTogJ0F2YXRhcicsIHVybDogJy9hdmF0YXInLCBjb21wb25lbnQ6IEF2YXRhciB9LFxyXG4gICAgeyB0aXRsZTogJ0JhZGdlJywgdXJsOiAnL2JhZGdlJywgY29tcG9uZW50OiBCYWRnZSB9LFxyXG4gICAgeyB0aXRsZTogJ0Jhbm5lcicsIHVybDogJy9iYW5uZXInLCBjb21wb25lbnQ6IEJhbm5lciwgaW1hZ2VVcmw6ICdodHRwczovL2xoMy5nb29nbGV1c2VyY29udGVudC5jb20vdE9aZFdiZld0SWM1R0hUV3NXMERhcWo1STZsQ0NyVU44LVl1RVZqU244N0pOTjZ4NlBFamZtbmUtZ3BCbzRqSEJJNGdxTG1pMGtMVnB1YkY0MVpUMm1NOGdsa0x6bzJpV2dLXy1qWT13NzYwLWgzODAnIH0sXHJcbiAgICB7IHRpdGxlOiAnQnV0dG9uJywgdXJsOiAnL2J1dHRvbicsIGNvbXBvbmVudDogQnV0dG9uLCBpbWFnZVVybDogJ2h0dHBzOi8vbGgzLmdvb2dsZXVzZXJjb250ZW50LmNvbS9HSFJ6LTVTMDB1N1drUkdsOGlVbThlem9SNmVvQjJOSnp0dS10ckp2M3JhTUR2cFNBQ2VRNU8wS09vQUc3U1JISk5ETV9tVDA0SGVpMU53alROLVpzSUZtc19ic1E0enhSeXhkUVE9dzc2MC1oMzgwJyB9LFxyXG4gICAgeyB0aXRsZTogJ0NhcmQnLCB1cmw6ICcvY2FyZCcsIGNvbXBvbmVudDogQ2FyZCwgaW1hZ2VVcmw6ICdodHRwczovL2xoMy5nb29nbGV1c2VyY29udGVudC5jb20vRnlFM3FqR3d3bm9lTWdpeU91SXhkeFRRUU05Q3IwZnROYWtPWE9BOGNwMTM3cktOMDlCRkhyYUVSbTFOUFVGQlRHeFZnY2hrZGw2VUFCYzExWmNKRE1MNHVpNDY2VzJCRkl4YzlRPXc3NjAtaDM4MCcgfSxcclxuICAgIHsgdGl0bGU6ICdDaGVja2JveCcsIHVybDogJy9jaGVja2JveCcsIGNvbXBvbmVudDogQ2hlY2tib3ggfSxcclxuICAgIHsgdGl0bGU6ICdDaGlwcycsIHVybDogJy9jaGlwcycsIGNvbXBvbmVudDogQ2hpcHMgfSxcclxuICAgIHsgdGl0bGU6ICdDaXJjdWxhciBQcm9ncmVzcycsIHVybDogJy9jaXJjdWxhci1wcm9ncmVzcycsIGNvbXBvbmVudDogQ2lyY3VsYXJQcm9ncmVzcyB9LFxyXG4gICAgeyB0aXRsZTogJ0RhdGFUYWJsZScsIHVybDogJy9kYXRhLXRhYmxlJywgY29tcG9uZW50OiBEYXRhVGFibGUgfSxcclxuICAgIHsgdGl0bGU6ICdEaWFsb2cnLCB1cmw6ICcvZGlhbG9nJywgY29tcG9uZW50OiBEaWFsb2cgfSxcclxuICAgIHsgdGl0bGU6ICdEcmF3ZXInLCB1cmw6ICcvZHJhd2VyJywgY29tcG9uZW50OiBEcmF3ZXIgfSxcclxuICAgIHsgdGl0bGU6ICdFbGV2YXRpb24nLCB1cmw6ICcvZWxldmF0aW9uJywgY29tcG9uZW50OiBFbGV2YXRpb24gfSxcclxuICAgIHsgdGl0bGU6ICdGQUInLCB1cmw6ICcvZmFiJywgY29tcG9uZW50OiBGQUIsIGltYWdlVXJsOiAnaHR0cHM6Ly9saDMuZ29vZ2xldXNlcmNvbnRlbnQuY29tL1Q4ZGxZemFhVTJTVjg2eDZscU5NamxIY3JGZEt2ODVRTVcxVW5KU2hHd2tsUlF5dVVxWklrbE9qbkV1cXJaekYxaDg0b2hyenoySVRhamJUOUlkbGpvZk5GbVA1Y3NFcTZHN1c9dzc2MC1oMzgwJyB9LFxyXG4gICAgeyB0aXRsZTogJ0Zvcm0gRmllbGQnLCB1cmw6ICcvZm9ybS1maWVsZCcsIGNvbXBvbmVudDogRm9ybUZpZWxkIH0sXHJcbiAgICB7IHRpdGxlOiAnSWNvbiBCdXR0b24nLCB1cmw6ICcvaWNvbi1idXR0b24nLCBjb21wb25lbnQ6IEljb25CdXR0b24gfSxcclxuICAgIHsgdGl0bGU6ICdJbWFnZSBMaXN0JywgdXJsOiAnL2ltYWdlLWxpc3QnLCBjb21wb25lbnQ6IEltYWdlTGlzdCB9LFxyXG4gICAgeyB0aXRsZTogJ0xheW91dCBHcmlkJywgdXJsOiAnL2xheW91dC1ncmlkJywgY29tcG9uZW50OiBMYXlvdXRHcmlkIH0sXHJcbiAgICB7IHRpdGxlOiAnTGluZWFyIFByb2dyZXNzJywgdXJsOiAnL2xpbmVhci1wcm9ncmVzcycsIGNvbXBvbmVudDogTGluZWFyUHJvZ3Jlc3MgfSxcclxuICAgIHsgdGl0bGU6ICdMaXN0JywgdXJsOiAnL2xpc3QnLCBjb21wb25lbnQ6IExpc3QgfSxcclxuICAgIHsgdGl0bGU6ICdNZW51JywgdXJsOiAnL21lbnUnLCBjb21wb25lbnQ6IE1lbnUgfSxcclxuICAgIHsgdGl0bGU6ICdSYWRpbycsIHVybDogJy9yYWRpbycsIGNvbXBvbmVudDogUmFkaW8gfSxcclxuICAgIHsgdGl0bGU6ICdSaXBwbGUnLCB1cmw6ICcvcmlwcGxlJywgY29tcG9uZW50OiBSaXBwbGUgfSxcclxuICAgIHsgdGl0bGU6ICdTZWdtZW50ZWQgQnV0dG9uJywgdXJsOiAnL3NlZ21lbnRlZC1idXR0b24nLCBjb21wb25lbnQ6IFNlZ21lbnRlZEJ1dHRvbiwgaW1hZ2VVcmw6ICcnIH0sXHJcbiAgICB7IHRpdGxlOiAnU2VsZWN0JywgdXJsOiAnL3NlbGVjdCcsIGNvbXBvbmVudDogU2VsZWN0LCBpbWFnZVVybDogJycgfSxcclxuICAgIHsgdGl0bGU6ICdTaWRlIFNoZWV0JywgdXJsOiAnL3NpZGUtc2hlZXQnLCBjb21wb25lbnQ6IFNpZGVTaGVldCwgaW1hZ2VVcmw6ICcnIH0sXHJcbiAgICB7IHRpdGxlOiAnU2xpZGVyJywgdXJsOiAnL3NsaWRlcicsIGNvbXBvbmVudDogU2xpZGVyLCBpbWFnZVVybDogJ2h0dHBzOi8vbGgzLmdvb2dsZXVzZXJjb250ZW50LmNvbS93Nm5OZUxjanBYeXBvMlU2X2d2dW5VZXNnVE5PQXF6RXpiNVp6eHhUNEF5R0hfTV9MX0VIcnliZzlzSk5nNzhCREh5ZUNQSVFDZTNIazJzVGdsVTBFUWU3Y09Cc3FVTUZpY3ExbGc9dzc2MC1oMzgwJyB9LFxyXG4gICAgeyB0aXRsZTogJ1NuYWNrYmFyJywgdXJsOiAnL3NuYWNrYmFyJywgY29tcG9uZW50OiBTbmFja2JhciwgaW1hZ2VVcmw6ICdodHRwczovL2xoMy5nb29nbGV1c2VyY29udGVudC5jb20vZkdnWlBET3N6VEQtMlJlQUM4NWw1b3A3d0NFM3V2blB0YTEzQWliMmJTbHpOOExYb05ZbERHNmZZNURZMXFLcWJMVGJHR2x4OVZnYWhVRGRqRGdkanE4c0pOcW9JWTQtR1B4S1JBPXc3NjAtaDM4MCcgfSxcclxuICAgIHsgdGl0bGU6ICdTd2l0Y2gnLCB1cmw6ICcvc3dpdGNoJywgY29tcG9uZW50OiBTd2l0Y2ggfSxcclxuICAgIHsgdGl0bGU6ICdUYWJzJywgdXJsOiAnL3RhYnMnLCBjb21wb25lbnQ6IFRhYnMsIGltYWdlVXJsOiAnaHR0cHM6Ly9saDMuZ29vZ2xldXNlcmNvbnRlbnQuY29tL0FZRnAyVm1Nbjluc2x4MThNNkVzOUM1N1M3cDN6a2lRVkxsM1BIdk11LU9wYnZLMUZsTEpOMk1IZkZOWmZtZk1DazFkckN3ODRGS2ViejVTVEo3UU42OUlIaEg5V0YxS2tsaXI9dzc2MC1oMzgwJyB9LFxyXG4gICAgeyB0aXRsZTogJ1RleHQgRmllbGQnLCB1cmw6ICcvdGV4dC1maWVsZCcsIGNvbXBvbmVudDogVGV4dEZpZWxkLCBpbWFnZVVybDogJ2h0dHBzOi8vbGgzLmdvb2dsZXVzZXJjb250ZW50LmNvbS9MeGJfalpmWGtBU1oxREN6Tmh5UzNJRzdtSXNQaEJWbWFYMjBIbjdYbndwU19Qbzl3UUlDLTVyRXdVc1lsYjVUa2dNanFJNDUtajF3NGk0V000d1NsQS1iMHFLdG1KNjloVjBqPXc3NjAtaDM4MCcgfSxcclxuICAgIHsgdGl0bGU6ICdUb29sdGlwJywgdXJsOiAnL3Rvb2x0aXAnLCBjb21wb25lbnQ6IFRvb2x0aXAsIGltYWdlVXJsOiAnaHR0cHM6Ly9saDMuZ29vZ2xldXNlcmNvbnRlbnQuY29tL0FzbTFLSFBzVUQtR0REZ2xjSXR6dmwyTEtXc3lyTXpLTXJXREE1c2lIYUY3UEF2bmduaVM1N1BNWlRIRnNESGtIc2pUOWRQV0M1dEVwUkJHN2k1c3laN3NiUmlScEw5b0U4NEY9dzc2MC1oMzgwJyB9LFxyXG4gICAgeyB0aXRsZTogJ1RvcCBBcHAgQmFyJywgdXJsOiAnL3RvcC1hcHAtYmFyJywgY29tcG9uZW50OiBUb3BBcHBCYXIsIGltYWdlVXJsOiAnaHR0cHM6Ly9saDMuZ29vZ2xldXNlcmNvbnRlbnQuY29tL2VvdDk2YS1xakFyMFF5cEtLZi02cVNKR1FRcVcwODYtR1YydnYwRDlGMzU4LVZGaUpTV2lmZzYtcTM4dmJJX0pzeENQbmJKTnpqQ0gxMk9GRFhKQnpTY0IzaF9fSFhMd0tXa2pZQT13NzYwLWgzODAnIH0sXHJcbiAgICB7IHRpdGxlOiAnVHlwb2dyYXBoeScsIHVybDogJy90eXBvZ3JhcGh5JywgY29tcG9uZW50OiBUeXBvZ3JhcGh5IH0sXHJcbl07IiwiaW1wb3J0IHsgUm91dGUsIExpbmssIE5hdkxpbmssIFN3aXRjaCB9IGZyb20gJ3JlYWN0LXJvdXRlci1kb20nO1xyXG5pbXBvcnQge1xyXG4gICAgRHJhd2VyLFxyXG4gICAgSWNvbkJ1dHRvbixcclxuICAgIExpc3QsXHJcbiAgICBUb3BBcHBCYXJcclxufSBmcm9tICdtZGMtcmVhY3QnO1xyXG5cclxuaW1wb3J0IHJvdXRlcyBmcm9tICcuL3JvdXRlcyc7XHJcbmltcG9ydCB7IEhvbWUgfSBmcm9tICcuL3BhZ2VzJztcclxuXHJcbmltcG9ydCAnLi9BcHAuc2Nzcyc7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBBcHAoKSB7XHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiYXBwXCI+XHJcbiAgICAgICAgICAgIDxUb3BBcHBCYXJcclxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZT1cImFwcC10b3AtYmFyXCJcclxuICAgICAgICAgICAgICAgIG5hdmlnYXRpb25JY29uPXtcclxuICAgICAgICAgICAgICAgICAgICA8SWNvbkJ1dHRvblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpY29uPXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxMaW5rIHRvPVwiL1wiPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxpbWcgc3JjPVwiaHR0cHM6Ly9tYXRlcmlhbC1jb21wb25lbnRzLmdpdGh1Yi5pby9tYXRlcmlhbC1jb21wb25lbnRzLXdlYi1jYXRhbG9nL3N0YXRpYy9tZWRpYS9pY19jb21wb25lbnRfMjRweF93aGl0ZS5zdmdcIiBhbHQ9XCJcIiAvPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9MaW5rPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgLz5cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRpdGxlPVwiTURDIFJlYWN0XCJcclxuICAgICAgICAgICAgICAgIGFjdGlvbkl0ZW1zPXtbXHJcbiAgICAgICAgICAgICAgICAgICAgPEljb25CdXR0b25cclxuICAgICAgICAgICAgICAgICAgICAgICAga2V5PVwiY29kZVwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnQ9XCJhXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgaHJlZj1cImh0dHBzOi8vZ2l0aHViLmNvbS9vbGVncG9seWFrb3YvbWRjLXJlYWN0XCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0PVwiX2JsYW5rXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWNvbj1cImNvZGVcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aXRsZT1cIkNvZGVcIlxyXG4gICAgICAgICAgICAgICAgICAgIC8+LFxyXG4gICAgICAgICAgICAgICAgICAgIDxJY29uQnV0dG9uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleT1cImlzc3Vlc1wiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnQ9XCJhXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgaHJlZj1cImh0dHBzOi8vZ2l0aHViLmNvbS9vbGVncG9seWFrb3YvbWRjLXJlYWN0L2lzc3Vlc1wiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldD1cIl9ibGFua1wiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGljb249XCJidWdfcmVwb3J0XCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGU9XCJJc3N1ZXNcIlxyXG4gICAgICAgICAgICAgICAgICAgIC8+LFxyXG4gICAgICAgICAgICAgICAgICAgIDxJY29uQnV0dG9uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleT1cImRpc2N1c3Npb25zXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudD1cImFcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBocmVmPVwiaHR0cHM6Ly9naXRodWIuY29tL29sZWdwb2x5YWtvdi9tZGMtcmVhY3QvZGlzY3Vzc2lvbnNcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXQ9XCJfYmxhbmtcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpY29uPVwiZm9ydW1cIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aXRsZT1cIkRpc2N1c3Npb25zXCJcclxuICAgICAgICAgICAgICAgICAgICAvPlxyXG4gICAgICAgICAgICAgICAgXX1cclxuICAgICAgICAgICAgLz5cclxuXHJcbiAgICAgICAgICAgIDxEcmF3ZXIgY2xhc3NOYW1lPVwiYXBwLWRyYXdlclwiIGRpc21pc3NpYmxlIG9wZW4+XHJcbiAgICAgICAgICAgICAgICA8RHJhd2VyLkNvbnRlbnQ+XHJcbiAgICAgICAgICAgICAgICAgICAgPExpc3QgZWxlbWVudD1cIm5hdlwiPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB7cm91dGVzLm1hcChyb3V0ZSA9PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPExpc3QuSXRlbVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleT17cm91dGUudXJsfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudD17TmF2TGlua31cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0bz17cm91dGUudXJsfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByaW1hcnlUZXh0PXtyb3V0ZS50aXRsZX1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhY3RpdmVDbGFzc05hbWU9XCJtZGMtbGlzdC1pdGVtLS1hY3RpdmF0ZWRcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLz5cclxuICAgICAgICAgICAgICAgICAgICAgICAgKX1cclxuICAgICAgICAgICAgICAgICAgICA8L0xpc3Q+XHJcbiAgICAgICAgICAgICAgICA8L0RyYXdlci5Db250ZW50PlxyXG4gICAgICAgICAgICA8L0RyYXdlcj5cclxuXHJcbiAgICAgICAgICAgIDxtYWluIGNsYXNzTmFtZT1cImFwcC1jb250ZW50IG1kYy1kcmF3ZXItYXBwLWNvbnRlbnRcIj5cclxuICAgICAgICAgICAgICAgIDxTd2l0Y2g+XHJcbiAgICAgICAgICAgICAgICAgICAgPFJvdXRlIGV4YWN0IHBhdGg9XCIvXCIgY29tcG9uZW50PXtIb21lfSAvPlxyXG5cclxuICAgICAgICAgICAgICAgICAgICB7cm91dGVzLm1hcChyb3V0ZSA9PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8Um91dGVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleT17cm91dGUudXJsfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGF0aD17cm91dGUudXJsfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhhY3Q9e3JvdXRlLmV4YWN0fVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50PXtyb3V0ZS5jb21wb25lbnR9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8+XHJcbiAgICAgICAgICAgICAgICAgICAgKX1cclxuICAgICAgICAgICAgICAgIDwvU3dpdGNoPlxyXG4gICAgICAgICAgICA8L21haW4+XHJcbiAgICAgICAgPC9kaXY+XHJcbiAgICApO1xyXG59IiwiaW1wb3J0IHsgQnJvd3NlclJvdXRlciBhcyBSb3V0ZXIgfSBmcm9tICdyZWFjdC1yb3V0ZXItZG9tJztcclxuaW1wb3J0IHsgcmVuZGVyIH0gZnJvbSAncmVhY3QtZG9tJztcclxuXHJcbmltcG9ydCBBcHAgZnJvbSAnLi9BcHAnO1xyXG5cclxuaW1wb3J0ICcuL2luZGV4LnNjc3MnO1xyXG5cclxucmVuZGVyKFxyXG4gICAgPFJvdXRlciBiYXNlbmFtZT1cIm1kYy1yZWFjdFwiPlxyXG4gICAgICAgIDxBcHAgLz5cclxuICAgIDwvUm91dGVyPixcclxuICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyNyb290JylcclxuKTsiXSwibmFtZXMiOlsiaXNWYWxpZEVsZW1lbnQiLCJmb3J3YXJkUmVmIiwiY2xvbmVFbGVtZW50IiwiY3JlYXRlRWxlbWVudCIsImNsYXNzbmFtZXMiLCJjcmVhdGVDb21wb25lbnQiLCJmbiIsImRpc3BsYXlOYW1lIiwicHJvcFR5cGVzIiwiZGVmYXVsdFByb3BzIiwiQ29tcG9uZW50IiwibGVuZ3RoIiwiQ2xvbmUiLCJyZWYiLCJjb21wb25lbnQiLCJmYWxsYmFjayIsImNsYXNzTmFtZSIsImNoaWxkcmVuIiwicHJvcHMiLCJpc0VsZW1lbnQiLCJjbG9uZSIsImNyZWF0ZSIsImNzc0NsYXNzZXMiLCJST09UIiwiTUFURVJJQUxfSUNPTlMiLCJMSUdIVCIsIkRBUksiLCJJTkFDVElWRSIsIlByb3BUeXBlcyIsIkljb24iLCJzaXplIiwibGlnaHQiLCJkYXJrIiwiaW5hY3RpdmUiLCJlbGVtZW50IiwiRWxlbWVudCIsImNsYXNzTmFtZXMiLCJzdHJpbmciLCJib29sIiwiZGVmYXVsdCIsIlNNQUxMIiwiTUVESVVNIiwiTEFSR0UiLCJJTUFHRSIsIklDT04iLCJURVhUIiwiQXZhdGFyIiwic3JjIiwiaWNvbiIsInRleHQiLCJhbHQiLCJub2RlIiwib25lT2YiLCJJTlNFVCIsIlRSQU5TUEFSRU5UIiwiQmFkZ2UiLCJ2YWx1ZSIsImluc2V0IiwidHJhbnNwYXJlbnQiLCJvbmVPZlR5cGUiLCJudW1iZXIiLCJpc1JlcXVpcmVkIiwibnVtYmVycyIsIkJBTk5FUl9BTklNQVRJT05fQ0xPU0VfVElNRV9NUyIsIkJBTk5FUl9BTklNQVRJT05fT1BFTl9USU1FX01TIiwiRklYRUQiLCJDRU5URVJFRCIsIk1PQklMRV9TVEFDS0VEIiwiQVBQRUFSSU5HIiwiQVBQRUFSRUQiLCJPUEVOSU5HIiwiT1BFTiIsIkNMT1NJTkciLCJDT05URU5UIiwiR1JBUEhJQ19URVhUX1dSQVBQRVIiLCJHUkFQSElDIiwiQUNUSU9OUyIsIlBSSU1BUllfQUNUSU9OIiwiU0VDT05EQVJZX0FDVElPTiIsInVzZVJlZiIsInVzZUNhbGxiYWNrIiwidXNlSW1wZXJhdGl2ZUhhbmRsZSIsIkNTU1RyYW5zaXRpb24iLCJCYW5uZXIiLCJncmFwaGljIiwiYWN0aW9uIiwicHJpbWFyeUFjdGlvbiIsInNlY29uZGFyeUFjdGlvbiIsIm9wZW4iLCJmaXhlZCIsImNlbnRlcmVkIiwibW9iaWxlU3RhY2tlZCIsInJvb3RSZWYiLCJjb250ZW50UmVmIiwiY3VycmVudCIsImhhbmRsZUVudGVyaW5nIiwiaXNBcHBlYXJpbmciLCJzdHlsZSIsImhlaWdodCIsIm9mZnNldEhlaWdodCIsImhhbmRsZUV4aXRpbmciLCJjb250ZW50IiwiYXBwZWFyIiwiZW50ZXIiLCJleGl0IiwiYXBwZWFyRG9uZSIsImVudGVyQWN0aXZlIiwiZW50ZXJEb25lIiwiUkFJU0VEIiwiVU5FTEVWQVRFRCIsIk9VVExJTkVEIiwiVE9VQ0giLCJJQ09OX0xFQURJTkciLCJJQ09OX1RSQUlMSU5HIiwiUklQUExFIiwiTEFCRUwiLCJUT1VDSF9FTEVNRU5UIiwiQnV0dG9uIiwibGFiZWwiLCJsZWFkaW5nSWNvbiIsInRyYWlsaW5nSWNvbiIsInJhaXNlZCIsInVuZWxldmF0ZWQiLCJvdXRsaW5lZCIsInRvdWNoIiwiQm9vbGVhbiIsIlRJVExFIiwiU1VCVElUTEUiLCJPVkVSTElORSIsIkFDVElPTlNfRlVMTF9CTEVFRCIsIkFDVElPTl9CVVRUT05TIiwiQUNUSU9OX0lDT05TIiwiQUNUSU9OIiwiQUNUSU9OX0JVVFRPTiIsIkFDVElPTl9JQ09OIiwiSEVBREVSIiwiSEVBREVSX0dSQVBISUMiLCJIRUFERVJfQ09OVEVOVCIsIkhFQURFUl9BQ1RJT05TIiwiTUVESUEiLCJNRURJQV9TUVVBUkUiLCJNRURJQV9XSURFIiwiTUVESUFfQ09OVEVOVCIsIlNFQ1RJT04iLCJTRUNUSU9OX1BSSU1BUlkiLCJTRUNUSU9OX1NFQ09OREFSWSIsIkNhcmQiLCJDYXJkQWN0aW9uIiwiYnV0dG9uIiwiQ2FyZEFjdGlvbnMiLCJmdWxsQmxlZWQiLCJDYXJkQWN0aW9uQnV0dG9ucyIsIkNhcmRBY3Rpb25JY29ucyIsIkNoaWxkcmVuIiwiQ2FyZEhlYWRlciIsInRpdGxlIiwic3VidGl0bGUiLCJvdmVybGluZSIsImFjdGlvbnMiLCJtYXAiLCJhcnJheU9mIiwiQ2FyZE1lZGlhIiwiaW1hZ2VVcmwiLCJzcXVhcmUiLCJ3aWRlIiwiYmFja2dyb3VuZEltYWdlIiwidW5kZWZpbmVkIiwiQ2FyZFByaW1hcnlBY3Rpb24iLCJDYXJkU2VjdGlvbiIsInByaW1hcnkiLCJzZWNvbmRhcnkiLCJBY3Rpb24iLCJBY3Rpb25zIiwiQWN0aW9uQnV0dG9ucyIsIkFjdGlvbkljb25zIiwiSGVhZGVyIiwiTWVkaWEiLCJQcmltYXJ5QWN0aW9uIiwiU2VjdGlvbiIsIlNFTEVDVEVEIiwiRElTQUJMRUQiLCJBTklNX0NIRUNLRURfSU5ERVRFUk1JTkFURSIsIkFOSU1fQ0hFQ0tFRF9VTkNIRUNLRUQiLCJBTklNX0lOREVURVJNSU5BVEVfQ0hFQ0tFRCIsIkFOSU1fSU5ERVRFUk1JTkFURV9VTkNIRUNLRUQiLCJBTklNX1VOQ0hFQ0tFRF9DSEVDS0VEIiwiQU5JTV9VTkNIRUNLRURfSU5ERVRFUk1JTkFURSIsIk5BVElWRV9DT05UUk9MIiwiQkFDS0dST1VORCIsIkNIRUNLTUFSSyIsIkNIRUNLTUFSS19QQVRIIiwiTUlYRURNQVJLIiwidXNlRWZmZWN0IiwiQ2hlY2tib3giLCJjaGVja2VkIiwiaW5kZXRlcm1pbmF0ZSIsImRpc2FibGVkIiwib25DaGFuZ2UiLCJGdW5jdGlvbiIsInByb3RvdHlwZSIsImlucHV0UmVmIiwiaGFuZGxlQ2hhbmdlIiwiZXZlbnQiLCJ0YXJnZXQiLCJmdW5jIiwiU0VMRUNUSU5HX0FOSU1BVElPTl9NUyIsIkRFU0VMRUNUSU5HX0FOSU1BVElPTl9NUyIsImNoaXBTZXRDc3NDbGFzc2VzIiwiT1ZFUkZMT1ciLCJDSElQUyIsImNoaXBDc3NDbGFzc2VzIiwiRklMVEVSIiwiU0VMRUNUQUJMRSIsIlNFTEVDVElORyIsIlNFTEVDVElOR19XSVRIX1BSSU1BUllfSUNPTiIsIkRFU0VMRUNUSU5HIiwiREVTRUxFQ1RJTkdfV0lUSF9QUklNQVJZX0lDT04iLCJFTlRFUiIsIkVYSVQiLCJISURERU4iLCJXSVRIX1BSSU1BUllfR1JBUEhJQyIsIldJVEhfUFJJTUFSWV9JQ09OIiwiV0lUSF9UUkFJTElOR19BQ1RJT04iLCJXSVRIX0FWQVRBUiIsIkNFTEwiLCJQUklNQVJZX0NFTEwiLCJUUkFJTElOR19DRUxMIiwiVFJBSUxJTkdfQUNUSU9OIiwiUFJFU0VOVEFUSU9OQUxfQUNUSU9OIiwiQUNUSU9OX1RPVUNIIiwiUFJJTUFSWV9SSVBQTEUiLCJUUkFJTElOR19SSVBQTEUiLCJQUklNQVJZX0lDT04iLCJUUkFJTElOR19JQ09OIiwiVEVYVF9MQUJFTCIsIkNIRUNLTUFSS19TVkciLCJDaGlwUHJpbWFyeUFjdGlvbiIsInByZXNlbnRhdGlvbmFsIiwic2VsZWN0YWJsZSIsInNlbGVjdGVkIiwiaXNCdXR0b24iLCJDaGlwVHJhaWxpbmdBY3Rpb24iLCJDaGlwIiwicHJpbWFyeUljb24iLCJmaWx0ZXIiLCJ3aXRoQXZhdGFyIiwid2l0aFByaW1hcnlHcmFwaGljIiwid2l0aFByaW1hcnlJY29uIiwid2l0aFRyYWlsaW5nQWN0aW9uIiwic2VsZWN0aW5nQ2xhc3MiLCJkZXNlbGVjdGluZ0NsYXNzIiwiZXhpdEFjdGl2ZSIsImFueSIsIm9uQ2xpY2siLCJpc1VuZGVmaW5lZCIsImlzTnVsbCIsImlzQm9vbGVhbiIsImlzTnVtYmVyIiwiaXNTdHJpbmciLCJpc0FycmF5IiwiQXJyYXkiLCJpc09iamVjdCIsIkNoaXBTZXQiLCJjaGlwcyIsImlucHV0IiwiY2hvaWNlIiwib3ZlcmZsb3ciLCJjaGlwIiwiaGFuZGxlQ2xpY2siLCJjaGlwVmFsdWUiLCJjdXJyZW50VGFyZ2V0IiwiZGF0YXNldCIsIm5ld1ZhbHVlIiwiaW5jbHVkZXMiLCJ2IiwiY29uY2F0Iiwib25DbGlja0NhcHR1cmUiLCJzdHJpbmdzIiwiWE1MTlMiLCJzaXplUHJvcHMiLCJsYXJnZSIsInZpZXdCb3giLCJyYWRpdXMiLCJzdHJva2VXaWR0aCIsImdhcFBhdGNoU3Ryb2tlV2lkdGgiLCJzdHJva2VEYXNoYXJyYXkiLCJpbmRldGVybWluYXRlU3Ryb2tlRGFzaG9mZnNldCIsIm1lZGl1bSIsInNtYWxsIiwiSU5ERVRFUk1JTkFURSIsIkNMT1NFRCIsIkRFVEVSTUlOQVRFX0NPTlRBSU5FUiIsIkRFVEVSTUlOQVRFX0NJUkNMRV9HUkFQSElDIiwiREVURVJNSU5BVEVfVFJBQ0siLCJERVRFUk1JTkFURV9DSVJDTEUiLCJJTkRFVEVSTUlOQVRFX0NPTlRBSU5FUiIsIklOREVURVJNSU5BVEVfQ0lSQ0xFX0dSQVBISUMiLCJTUElOTkVSX0xBWUVSIiwiQ09MT1IiLCJDSVJDTEVfQ0xJUFBFUiIsIkNJUkNMRV9MRUZUIiwiQ0lSQ0xFX1JJR0hUIiwiR0FQX1BBVENIIiwiU2l6ZSIsIkNpcmN1bGFyUHJvZ3Jlc3MiLCJjbG9zZWQiLCJjb2xvcmZ1bCIsInByb2dyZXNzIiwiTnVtYmVyIiwiY3giLCJjeSIsInN0cm9rZURhc2hvZmZzZXQiLCJNYXRoIiwiUEkiLCJuIiwiUFJPR1JFU1NfQ09MT1IiLCJJY29uQnV0dG9uIiwiQU5JTUFUSU9OX1JFQURZIiwiQ0xPU0VEX0FOSU1BVElPTl9PRkYiLCJCVUZGRVIiLCJCVUZGRVJfQkFSIiwiQlVGRkVSX0RPVFMiLCJCQVIiLCJQUklNQVJZX0JBUiIsIlNFQ09OREFSWV9CQVIiLCJCQVJfSU5ORVIiLCJMaW5lYXJQcm9ncmVzcyIsImJ1ZmZlciIsInByaW1hcnlCYXJTdHlsZSIsInRyYW5zZm9ybSIsImJ1ZmZlclN0eWxlIiwiZmxleEJhc2lzIiwiU1RJQ0tZX0hFQURFUiIsIklOX1BST0dSRVNTIiwiVEFCTEVfQ09OVEFJTkVSIiwiVEFCTEUiLCJIRUFERVJfUk9XIiwiSEVBREVSX1JPV19DSEVDS0JPWCIsIkhFQURFUl9DRUxMIiwiSEVBREVSX0NFTExfQ0hFQ0tCT1giLCJIRUFERVJfQ0VMTF9OVU1FUklDIiwiSEVBREVSX0NFTExfV0lUSF9TT1JUIiwiSEVBREVSX0NFTExfU09SVEVEIiwiSEVBREVSX0NFTExfU09SVEVEX0RFU0MiLCJIRUFERVJfQ0VMTF9XUkFQUEVSIiwiSEVBREVSX0NFTExfTEFCRUwiLCJST1ciLCJST1dfQ0hFQ0tCT1giLCJST1dfU0VMRUNURUQiLCJDRUxMX0NIRUNLQk9YIiwiQ0VMTF9OVU1FUklDIiwiUEFHSU5BVElPTiIsIlBBR0lOQVRJT05fVFJBSUxJTkciLCJQQUdJTkFUSU9OX1JPV1NfUEVSX1BBR0UiLCJQQUdJTkFUSU9OX1JPV1NfUEVSX1BBR0VfTEFCRUwiLCJQQUdJTkFUSU9OX1JPV1NfUEVSX1BBR0VfU0VMRUNUIiwiUEFHSU5BVElPTl9OQVZJR0FUSU9OIiwiUEFHSU5BVElPTl9UT1RBTCIsIlBBR0lOQVRJT05fQlVUVE9OIiwiU09SVF9JQ09OX0JVVFRPTiIsIlNPUlRfU1RBVFVTX0xBQkVMIiwiUFJPR1JFU1NfSU5ESUNBVE9SIiwiU0NSSU0iLCJGT09URVIiLCJMSU5FQVJfUFJPR1JFU1MiLCJEYXRhVGFibGVQcm9ncmVzc0luZGljYXRvciIsIkZMT0FUIiwiUkVRVUlSRUQiLCJGbG9hdGluZ0xhYmVsIiwiZmxvYXQiLCJyZXF1aXJlZCIsIkFDVElWRSIsIkRFQUNUSVZBVElORyIsIkxpbmVSaXBwbGUiLCJhY3RpdmUiLCJ0cmFuc2Zvcm1PcmlnaW4iLCJOT1RDSF9TSVpFX0ZBQ1RPUiIsIk5PVENIRUQiLCJVUEdSQURFRCIsIk5PX0xBQkVMIiwiTEVBRElORyIsIk5PVENIIiwiVFJBSUxJTkciLCJ1c2VMYXlvdXRFZmZlY3QiLCJOb3RjaGVkT3V0bGluZSIsIm5vdGNoZWQiLCJub3RjaFJlZiIsIndpZHRoIiwiY2xpZW50V2lkdGgiLCJUUkFOU0lUSU9OX09QRU5fRFVSQVRJT04iLCJUUkFOU0lUSU9OX0NMT1NFX0RVUkFUSU9OIiwiTUFSR0lOX1RPX0VER0UiLCJBTkNIT1JfVE9fTUVOVV9TVVJGQUNFX1dJRFRIX1JBVElPIiwiVE9VQ0hfRVZFTlRfV0FJVF9NUyIsIlNVUkZBQ0UiLCJTVVJGQUNFX0FOQ0hPUiIsIlNVUkZBQ0VfRklYRUQiLCJTVVJGQUNFX09QRU4iLCJTVVJGQUNFX0FOSU1BVElOR19PUEVOIiwiU1VSRkFDRV9BTklNQVRJTkdfQ0xPU0VEIiwiU1VSRkFDRV9CRUxPV19BTkNIT1IiLCJJVEVNIiwiSVRFTV9TRUxFQ1RFRCIsIlNFTEVDVElPTl9HUk9VUCIsIlNFTEVDVElPTl9HUk9VUF9JQ09OIiwiT3JpZ2luIiwiVE9QX0xFRlQiLCJUT1BfQ0VOVEVSIiwiVE9QX1JJR0hUIiwiQ0VOVEVSX0xFRlQiLCJDRU5URVIiLCJDRU5URVJfUklHSFQiLCJCT1RUT01fTEVGVCIsIkJPVFRPTV9DRU5URVIiLCJCT1RUT01fUklHSFQiLCJ1c2VTdGF0ZSIsInVzZUNyZWF0ZWQiLCJjcmVhdGVkIiwic2V0Q3JlYXRlZCIsInVzZU1vdW50ZWQiLCJ1c2VVcGRhdGVkIiwiZGVwcyIsIm1vdW50ZWQiLCJzZXRNb3VudGVkIiwidXNlVXBkYXRlZFN5bmMiLCJ1c2VVbm1vdW50ZWQiLCJsaXN0Q3NzQ2xhc3NlcyIsImxpc3RJdGVtQ3NzQ2xhc3NlcyIsIkFDVElWQVRFRCIsIk5PTl9JTlRFUkFDVElWRSIsIk9ORV9MSU5FIiwiVFdPX0xJTkVTIiwiVEhSRUVfTElORVMiLCJMRUFESU5HX0lDT04iLCJMRUFESU5HX0lNQUdFIiwiTEVBRElOR19USFVNQk5BSUwiLCJMRUFESU5HX1ZJREVPIiwiTEVBRElOR19DSEVDS0JPWCIsIkxFQURJTkdfUkFESU8iLCJMRUFESU5HX1NXSVRDSCIsIlRSQUlMSU5HX01FVEEiLCJUUkFJTElOR19DSEVDS0JPWCIsIlRSQUlMSU5HX1JBRElPIiwiVFJBSUxJTkdfU1dJVENIIiwiU1RBUlQiLCJFTkQiLCJPVkVSTElORV9URVhUIiwiUFJJTUFSWV9URVhUIiwiU0VDT05EQVJZX1RFWFQiLCJsaXN0R3JvdXBDc3NDbGFzc2VzIiwiU1VCSEVBREVSIiwibGlzdERpdmlkZXJDc3NDbGFzc2VzIiwiTEVBRElOR19URVhUIiwiTEVBRElOR19BVkFUQVIiLCJMaXN0SXRlbUNvbnRlbnQiLCJvdmVybGluZVRleHQiLCJwcmltYXJ5VGV4dCIsInNlY29uZGFyeVRleHQiLCJMaXN0SXRlbUVuZCIsIkxpc3RJdGVtU3RhcnQiLCJMaXN0SXRlbSIsInN0YXJ0IiwiZW5kIiwiaW1hZ2UiLCJ0aHVtYm5haWwiLCJ2aWRlbyIsImxlYWRpbmdJbWFnZSIsImxlYWRpbmdUaHVtYm5haWwiLCJsZWFkaW5nVmlkZW8iLCJsZWFkaW5nQ2hlY2tib3giLCJsZWFkaW5nUmFkaW8iLCJsZWFkaW5nU3dpdGNoIiwibWV0YSIsInRyYWlsaW5nTWV0YSIsInRyYWlsaW5nQ2hlY2tib3giLCJ0cmFpbGluZ1JhZGlvIiwidHJhaWxpbmdTd2l0Y2giLCJhY3RpdmF0ZWQiLCJub25JbnRlcmFjdGl2ZSIsIndpdGhMZWFkaW5nSWNvbiIsIndpdGhMZWFkaW5nSW1hZ2UiLCJ3aXRoTGVhZGluZ1RodW1ibmFpbCIsIndpdGhMZWFkaW5nVmlkZW8iLCJ3aXRoTGVhZGluZ0NoZWNrYm94Iiwid2l0aExlYWRpbmdSYWRpbyIsIndpdGhMZWFkaW5nU3dpdGNoIiwid2l0aFRyYWlsaW5nTWV0YSIsIndpdGhUcmFpbGluZ0ljb24iLCJ3aXRoVHJhaWxpbmdDaGVja2JveCIsIndpdGhUcmFpbGluZ1JhZGlvIiwid2l0aFRyYWlsaW5nU3dpdGNoIiwibGluZXMiLCJoYXNTdGFydCIsImhhc0NvbnRlbnQiLCJoYXNFbmQiLCJMaXN0IiwiaXRlbXMiLCJpdGVtIiwiYXJyYXkiLCJMaXN0RGl2aWRlciIsIndpdGhMZWFkaW5nVGV4dCIsIndpdGhMZWFkaW5nQXZhdGFyIiwiTGlzdEdyb3VwIiwiTGlzdEdyb3VwU3ViaGVhZGVyIiwiSXRlbSIsIkRpdmlkZXIiLCJHcm91cCIsIlN1YmhlYWRlciIsIkNvbnRlbnQiLCJFbmQiLCJTdGFydCIsIk1lbnVJdGVtIiwiY3JlYXRlUG9ydGFsIiwiTW9kYWwiLCJkb2N1bWVudCIsInJvb3QiLCJhY3RpdmVFbGVtZW50IiwiY2xhc3NMaXN0IiwiYWRkIiwiYm9keSIsImFwcGVuZENoaWxkIiwiZmlyc3RDaGlsZCIsImZvY3VzIiwicmVtb3ZlQ2hpbGQiLCJMYXllciIsIm1vZGFsIiwiZGVmYXVsdFZhbHVlcyIsInRvcCIsImJvdHRvbSIsImNlbnRlciIsImxlZnQiLCJyaWdodCIsImdldEFuY2hvck9yaWdpbiIsImFuY2hvck9yaWdpbiIsIk9iamVjdCIsImFzc2lnbiIsImtleXMiLCJzcGxpdCIsInZhbHVlcyIsInJlZHVjZSIsInJlc3VsdCIsImtleSIsIk1lbnVTdXJmYWNlIiwiYW5jaG9yIiwiX2FuY2hvclJlZiIsImFuY2hvclJlZiIsIl9hbmNob3JPcmlnaW4iLCJfdHJhbnNmb3JtT3JpZ2luIiwicXVpY2siLCJwZXJzaXN0ZW50IiwiZnVsbFdpZHRoIiwib25DbG9zZSIsIm9uS2V5RG93biIsImhhbmRsZUJvZHlDbGljayIsImFkZEV2ZW50TGlzdGVuZXIiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiY2xpZW50SGVpZ2h0IiwiYW5jaG9yQ2xpZW50UmVjdCIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsImFuY2hvckRpbWVuc2lvbnMiLCJvZmZzZXRUb3AiLCJvZmZzZXRMZWZ0Iiwib2Zmc2V0V2lkdGgiLCJtYXhXaWR0aCIsInBvc2l0aW9uIiwic2Nyb2xsWSIsIndpbmRvdyIsInNjcm9sbFgiLCJib3R0b21PdmVyZmxvdyIsImlubmVySGVpZ2h0IiwidG9wT3ZlcmZsb3ciLCJyaWdodE92ZXJmbG93IiwiaW5uZXJXaWR0aCIsImFicyIsImxlZnRPdmVyZmxvdyIsImhhbmRsZUtleURvd24iLCJzdG9wUHJvcGFnYXRpb24iLCJpc0JlbG93QW5jaG9yIiwib2JqZWN0IiwiTWVudSIsImxpc3RQcm9wcyIsImxpc3RSZWYiLCJmb2N1c2VkQ2hpbGRJbmRleCIsInNldEZvY3VzZWRDaGlsZEluZGV4IiwidG9BcnJheSIsImZpbmRJbmRleCIsImkiLCJwcmV2ZW50RGVmYXVsdCIsImluZGV4IiwibmV4dEluZGV4IiwiTWVudUFuY2hvciIsIndyYXAiLCJNZW51U2VsZWN0aW9uR3JvdXAiLCJNZW51U2VsZWN0aW9uR3JvdXBJY29uIiwiTWVudU9yaWdpbiIsIkFuY2hvciIsIlN1cmZhY2UiLCJTZWxlY3Rpb25Hcm91cCIsIlNlbGVjdGlvbkdyb3VwSWNvbiIsIkZJTExFRCIsIkZPQ1VTRUQiLCJJTlZBTElEIiwiV0lUSF9MRUFESU5HX0lDT04iLCJTRUxFQ1RFRF9URVhUIiwiU0VMRUNURURfVEVYVF9DT05UQUlORVIiLCJEUk9QRE9XTl9JQ09OIiwiRFJPUERPV05fSUNPTl9HUkFQSElDIiwiRFJPUERPV05fSUNPTl9JTkFDVElWRSIsIkRST1BET1dOX0lDT05fQUNUSVZFIiwiTUVOVSIsIk1FTlVfSU5WQUxJRCIsIkFOQ0hPUiIsIkhFTFBFUl9URVhUIiwiVkFMSURBVElPTl9NRVNTQUdFIiwiVkFMSURBVElPTl9NRVNTQUdFX1BFUlNJU1RFTlQiLCJEcm9wZG93bkljb24iLCJTZWxlY3RPcHRpb24iLCJjaGVja2JveCIsIkhlbHBlclRleHQiLCJ2YWxpZGF0aW9uIiwiU2VsZWN0IiwibmFtZSIsIm9wdGlvbnMiLCJoZWxwZXJUZXh0IiwiZmlsbGVkIiwibXVsdGlwbGUiLCJtZW51UHJvcHMiLCJoZWxwZXJUZXh0UHJvcHMiLCJvcHRpb24iLCJtZW51UmVmIiwic2V0QWN0aXZhdGVkIiwiZm9jdXNlZCIsInNldEZvY3VzZWQiLCJ0b3VjaGVkIiwic2V0VG91Y2hlZCIsInNlbGVjdGVkVGV4dCIsInNldFNlbGVjdGVkVGV4dCIsImludGVyYWN0aW9uQ29vcmRzIiwic2V0SW50ZXJhY3Rpb25Db29yZHMiLCJzZWxlY3RlZE9wdGlvbnMiLCJqb2luIiwic2VsZWN0ZWRPcHRpb24iLCJmaW5kIiwiaGFuZGxlQW5jaG9yQ2xpY2siLCJ0YXJnZXRDbGllbnRSZWN0IiwieCIsImNsaWVudFgiLCJ5IiwiY2xpZW50WSIsImhhbmRsZU9wdGlvbkludGVyYWN0aW9uIiwidHlwZSIsIlNldCIsImhhcyIsImhhbmRsZU1lbnVDbG9zZSIsInBhdGgiLCJoYXNWYWx1ZSIsImZvY3VzZWRPckhhc1ZhbHVlIiwiaXNJbnZhbGlkIiwib3B0aW9uVmFsdWUiLCJPcHRpb24iLCJEYXRhVGFibGVQYWdpbmF0aW9uIiwidG90YWxDb3VudCIsImN1cnJlbnRQYWdlIiwicm93c1BlclBhZ2UiLCJvbkZpcnN0UGFnZSIsIm9uUHJldlBhZ2UiLCJvbk5leHRQYWdlIiwib25MYXN0UGFnZSIsIkRhdGFUYWJsZSIsInN0aWNreUhlYWRlciIsImluUHJvZ3Jlc3MiLCJwYWdpbmF0aW9uIiwiRGF0YVRhYmxlQ2VsbCIsIm51bWVyaWMiLCJzY29wZSIsIkRhdGFUYWJsZUNvbnRlbnQiLCJEYXRhVGFibGVGb290ZXIiLCJEYXRhVGFibGVIZWFkZXIiLCJEYXRhVGFibGVIZWFkZXJDZWxsIiwic29ydCIsInNvcnRJY29uQnV0dG9uIiwib25Tb3J0Iiwicm9sZSIsImhhbmRsZVNvcnRJY29uQ2xpY2siLCJ3aXRoU29ydCIsIkRhdGFUYWJsZUhlYWRlclJvdyIsIkRhdGFUYWJsZVJvdyIsIkNlbGwiLCJGb290ZXIiLCJIZWFkZXJDZWxsIiwiSGVhZGVyUm93IiwiUGFnaW5hdGlvbiIsIlJvdyIsIkRJQUxPR19BTklNQVRJT05fT1BFTl9USU1FX01TIiwiRElBTE9HX0FOSU1BVElPTl9DTE9TRV9USU1FX01TIiwiREVGQVVMVF9BQ1RJT05TX0hFSUdIVCIsIkNMT1NFIiwiQ09OVEFJTkVSIiwiQlVUVE9OIiwiRlVMTFNDUkVFTiIsIlNDUk9MTEFCTEUiLCJTVEFDS0VEIiwiU0NST0xMX0RJVklERVJfSEVBREVSIiwiU0NST0xMX0RJVklERVJfRk9PVEVSIiwiU0NST0xMX0xPQ0siLCJEaWFsb2dIZWFkZXIiLCJjbG9zZUljb24iLCJmdWxsc2NyZWVuIiwiRGlhbG9nQ29udGVudCIsIkRpYWxvZ0FjdGlvbnMiLCJEaWFsb2ciLCJzdGFja2VkIiwiYXV0b1N0YWNrQnV0dG9ucyIsImFjdGlvbnNSZWYiLCJoYW5kbGVEb2N1bWVudEtleURvd24iLCJrZXlDb2RlIiwiY29udGVudEVsZW1lbnQiLCJzaG91bGRTY3JvbGwiLCJzY3JvbGxIZWlnaHQiLCJhY3Rpb25zRWxlbWVudCIsImhhbmRsZVNjcm9sbCIsImlzU2Nyb2xsQXRUb3AiLCJzY3JvbGxUb3AiLCJpc1Njcm9sbEF0Qm90dG9tIiwiY2VpbCIsInRvZ2dsZSIsInJlbW92ZSIsImhhbmRsZUVudGVyIiwiaGFuZGxlRXhpdGVkIiwiaGFuZGxlU2NyaW1DbGljayIsImFwcGVhckFjdGl2ZSIsImNvbmZpcm1hdGlvbiIsIkFOSU1BVElPTl9FTlRFUl9USU1FX01TIiwiQU5JTUFUSU9OX0VYSVRfVElNRV9NUyIsIkRJU01JU1NJQkxFIiwiTU9EQUwiLCJBTklNQVRFIiwiQVBQX0NPTlRFTlQiLCJEcmF3ZXIiLCJkaXNtaXNzaWJsZSIsImFwcENvbnRlbnRTZWxlY3RvciIsImFwcENvbnRlbnRFbGVtZW50IiwicXVlcnlTZWxlY3RvciIsIm5leHRFbGVtZW50U2libGluZyIsIkRyYXdlckhlYWRlciIsIkRyYXdlckNvbnRlbnQiLCJaIiwiVFJBTlNJVElPTiIsIkVsZXZhdGlvbiIsInoiLCJ0cmFuc2l0aW9uIiwiTUlOSSIsIkVYVEVOREVEIiwiRVhJVEVEIiwiRkFCIiwibWluaSIsImV4aXRlZCIsIkFMSUdOX0VORCIsIk5PV1JBUCIsIlNQQUNFX0JFVFdFRU4iLCJGb3JtRmllbGQiLCJhbGlnbkVuZCIsIm5vd3JhcCIsInNwYWNlQmV0d2VlbiIsImlkIiwiSU1BR0VfTElTVCIsIklNQUdFX0xJU1RfTUFTT05SWSIsIklNQUdFX0xJU1RfV0lUSF9URVhUX1BST1RFQ1RJT04iLCJJTUFHRV9MSVNUX0lURU0iLCJJTUFHRV9MSVNUX0lNQUdFX0FTUEVDVF9DT05UQUlORVIiLCJJTUFHRV9MSVNUX0lNQUdFIiwiSU1BR0VfTElTVF9TVVBQT1JUSU5HIiwiSU1BR0VfTElTVF9MQUJFTCIsIkltYWdlTGlzdEl0ZW0iLCJpbWFnZVNyYyIsImZpeGVkQXNwZWN0IiwiSW1hZ2VMaXN0IiwibWFzb25yeSIsIndpdGhUZXh0UHJvdGVjdGlvbiIsImNoaWxkIiwiQ09MVU1OIiwiRElSRUNUSU9OIiwiV1JBUCIsIldSQVBfUkVWRVJTRSIsIkFMSUdOX0lURU1TIiwiQUxJR05fU0VMRiIsIkpVU1RJRllfQ09OVEVOVCIsIkxheW91dCIsInJvdyIsImNvbHVtbiIsImRpcmVjdGlvbiIsImFsaWduSXRlbXMiLCJhbGlnblNlbGYiLCJqdXN0aWZ5Q29udGVudCIsIkFMSUdOIiwiRklYRURfQ09MVU1OX1dJRFRIIiwiSU5ORVIiLCJDRUxMX1NQQU4iLCJDRUxMX09SREVSIiwiQ0VMTF9BTElHTiIsIkxheW91dEdyaWQiLCJhbGlnbiIsImZpeGVkQ29sdW1uV2lkdGgiLCJMYXlvdXRHcmlkQ2VsbCIsInNwYW4iLCJkZXNrdG9wIiwidGFibGV0IiwibW9iaWxlIiwib3JkZXIiLCJncmlkIiwiT1VURVJfQ0lSQ0xFIiwiSU5ORVJfQ0lSQ0xFIiwiUmFkaW8iLCJNRENSaXBwbGUiLCJSaXBwbGUiLCJ1bmJvdW5kZWQiLCJyaXBwbGVSZWYiLCJwYXJlbnROb2RlIiwiZGVzdHJveSIsIlVOQk9VTkRFRCIsIkJHX0ZPQ1VTRUQiLCJGR19BQ1RJVkFUSU9OIiwiRkdfREVBQ1RJVkFUSU9OIiwiU1VSRkFDRV9QUklNQVJZIiwiU1VSRkFDRV9BQ0NFTlQiLCJWQVJfRkdfU0NBTEUiLCJWQVJfRkdfU0laRSIsIlZBUl9GR19UUkFOU0xBVEVfRU5EIiwiVkFSX0ZHX1RSQU5TTEFURV9TVEFSVCIsIlZBUl9MRUZUIiwiVkFSX1RPUCIsIkRFQUNUSVZBVElPTl9USU1FT1VUX01TIiwiRkdfREVBQ1RJVkFUSU9OX01TIiwiSU5JVElBTF9PUklHSU5fU0NBTEUiLCJQQURESU5HIiwiVEFQX0RFTEFZX01TIiwidXNlUmlwcGxlIiwiUmlwcGxlU3VyZmFjZSIsImFjY2VudCIsIlNJTkdMRV9TRUxFQ1QiLCJTRUdNRU5UIiwiU0VHTUVOVF9TRUxFQ1RFRCIsIlNlZ21lbnRlZEJ1dHRvblNlZ21lbnQiLCJyaXBwbGUiLCJTZWdtZW50ZWRCdXR0b24iLCJzZWdtZW50cyIsInNpbmdsZVNlbGVjdCIsInNlZ21lbnQiLCJzZWdtZW50VmFsdWUiLCJhcmlhUHJvcCIsIlNlZ21lbnQiLCJDTE9TRV9CVVRUT04iLCJTaWRlU2hlZXRIZWFkZXIiLCJTaWRlU2hlZXRDb250ZW50IiwiU2lkZVNoZWV0IiwiU2lkZVNoZWV0QXBwQ29udGVudCIsIkFwcENvbnRlbnQiLCJLZXkiLCJBUlJPV19MRUZUIiwiQVJST1dfVVAiLCJBUlJPV19SSUdIVCIsIkFSUk9XX0RPV04iLCJIT01FIiwiUEFHRV9VUCIsIlBBR0VfRE9XTiIsIktleUNvZGUiLCJnZXRFdmVudEtleSIsImdldFBhZ2VYIiwidGFyZ2V0VG91Y2hlcyIsInBhZ2VYIiwiZ2V0UGFnZVkiLCJwYWdlWSIsIlRIVU1CX1dJRFRIIiwiUkFOR0UiLCJESVNDUkVURSIsIklOUFVUIiwiVFJBQ0siLCJUUkFDS19JTkFDVElWRSIsIlRSQUNLX0FDVElWRSIsIlRSQUNLX0FDVElWRV9GSUxMIiwiVElDS19NQVJLUyIsIlRJQ0tfTUFSS19BQ1RJVkUiLCJUSUNLX01BUktfSU5BQ1RJVkUiLCJUSFVNQiIsIlRIVU1CX1RPUCIsIlRIVU1CX0ZPQ1VTRUQiLCJUSFVNQl9XSVRIX0lORElDQVRPUiIsIlRIVU1CX0tOT0IiLCJWQUxVRV9JTkRJQ0FUT1JfQ09OVEFJTkVSIiwiVkFMVUVfSU5ESUNBVE9SIiwiVkFMVUVfSU5ESUNBVE9SX1RFWFQiLCJnZXRWYWx1ZUZvckV2ZW50S2V5IiwiZXZlbnRLZXkiLCJtaW4iLCJtYXgiLCJzdGVwIiwiZGVsdGEiLCJOYU4iLCJJbnB1dCIsInJvdW5kIiwiVGlja01hcmtzIiwiZnJvbSIsIl8iLCJ0aWNrVmFsdWUiLCJUcmFjayIsImRpc2NyZXRlIiwidGlja01hcmtzIiwiVGh1bWIiLCJvblN0YXJ0SW50ZXJhY3Rpb24iLCJvbkVuZEludGVyYWN0aW9uIiwiaGFuZGxlRm9jdXMiLCJoYW5kbGVCbHVyIiwiU2xpZGVyIiwidHJhY2tSZWYiLCJzZXRBY3RpdmUiLCJoYW5kbGVNb3ZlIiwiaGFuZGxlVXAiLCJ1cGRhdGVWYWx1ZSIsInRyYWNrQ2xpZW50UmVjdCIsIm9mZnNldFgiLCJwZXJjZW50IiwiaXNOYU4iLCJoYW5kbGVSb290SW50ZXJhY3Rpb24iLCJoYW5kbGVUaHVtYlN0YXJ0SW50ZXJhY3Rpb24iLCJoYW5kbGVUaHVtYkVuZEludGVyYWN0aW9uIiwiREVGQVVMVF9BVVRPX0RJU01JU1NfVElNRU9VVF9NUyIsIkFOSU1BVElPTl9PUEVOX1RJTUVfTVMiLCJBTklNQVRJT05fQ0xPU0VfVElNRV9NUyIsIkRJU01JU1MiLCJTbmFja2JhciIsImRpc21pc3NJY29uIiwibGVhZGluZyIsInRpbWVvdXQiLCJjbG9zZU9uRXNjYXBlIiwidGltZW91dFJlZiIsInNldFRpbWVvdXQiLCJjbGVhclRpbWVvdXQiLCJVTlNFTEVDVEVEIiwiSEFORExFX1RSQUNLIiwiSEFORExFIiwiU0hBRE9XIiwiRUxFVkFUSU9OX09WRVJMQVkiLCJJQ09OUyIsIklDT05fT04iLCJJQ09OX09GRiIsIlN3aXRjaCIsInRhYkNsYXNzTmFtZXMiLCJNSU5fV0lEVEgiLCJiYXJDc3NDbGFzc2VzIiwic2Nyb2xsZXJDc3NDbGFzc2VzIiwiQU5JTUFUSU5HIiwiU0NST0xMX0FSRUEiLCJTQ1JPTExfQVJFQV9TQ1JPTEwiLCJTQ1JPTExfQ09OVEVOVCIsImluZGljYXRvckNzc0NsYXNzZXMiLCJGQURFIiwiTk9fVFJBTlNJVElPTiIsIkNPTlRFTlRfSUNPTiIsIkNPTlRFTlRfVU5ERVJMSU5FIiwiQWxpZ24iLCJjcmVhdGVDb250ZXh0IiwidXNlQ29udGV4dCIsIlRhYkNvbnRleHQiLCJUYWJJbmRpY2F0b3IiLCJmYWRlIiwidW5kZXJsaW5lIiwicHJldmlvdXNUYWIiLCJhY3RpdmVJbmRpY2F0b3IiLCJwcmV2aW91c0luZGljYXRvciIsInByZXZpb3VzSW5kaWNhdG9yQ2xpZW50UmVjdCIsImFjdGl2ZUluZGljYXRvckNsaWVudFJlY3QiLCJ4UG9zaXRpb24iLCJ3aWR0aERlbHRhIiwicm9vdENsYXNzTmFtZXMiLCJjb250ZW50Q2xhc3NOYW1lcyIsIlRhYiIsImluZGljYXRvckljb24iLCJtaW5XaWR0aCIsIm1pbldpZHRoSW5kaWNhdG9yIiwib25BY3RpdmF0ZSIsIlRhYlNjcm9sbGVyIiwiYWN0aXZlVGFiIiwic2Nyb2xsQXJlYVJlZiIsInNjcm9sbENvbnRlbnRSZWYiLCJzY3JvbGxBcmVhV2lkdGgiLCJzY3JvbGxDb250ZW50V2lkdGgiLCJ0YWJXaWR0aCIsInRhYkhhbGZXaWR0aCIsInNjcm9sbExlZnQiLCJvZmZzZXRMZWZ0RGVsdGEiLCJvZmZzZXRSaWdodCIsIm9mZnNldFJpZ2h0RGVsdGEiLCJzY3JvbGxCeSIsImJlaGF2aW9yIiwiVGFiQmFyIiwidGFicyIsImljb25JbmRpY2F0b3IiLCJ1bmRlcmxpbmVJbmRpY2F0b3IiLCJ0YWIiLCJhY3RpdmVUYWJSZWYiLCJwcmV2aW91c1RhYlJlZiIsImhhbmRsZVRhYkNsaWNrIiwidGFiVmFsdWUiLCJCT1VOREVEX0FOQ0hPUl9HQVAiLCJVTkJPVU5ERURfQU5DSE9SX0dBUCIsIk1JTl9WSUVXUE9SVF9UT09MVElQX1RIUkVTSE9MRCIsIkVOVEVSX0RVUkFUSU9OX01TIiwiRVhJVF9EVVJBVElPTl9NUyIsIkhJREVfREVMQVlfTVMiLCJTSE9XX0RFTEFZX01TIiwiTUlOX0hFSUdIVCIsIk1BWF9XSURUSCIsIkNBUkVUX0lOREVOVEFUSU9OIiwiQU5JTUFUSU9OX1NDQUxFIiwiUklDSCIsIk1VTFRJTElORSIsIlNIT1dJTkciLCJTSE9XSU5HX1RSQU5TSVRJT04iLCJTSE9XTiIsIkhJREUiLCJISURFX1RSQU5TSVRJT04iLCJTVVJGQUNFX0FOSU1BVElPTiIsIkNPTlRFTlRfTElOSyIsIkNBUkVUX1RPUCIsIkNBUkVUX0JPVFRPTSIsIlRvb2x0aXAiLCJ0b29sdGlwUmVmIiwidGFyZ2V0UmVmIiwiaGFuZGxlTW91c2VFbnRlciIsImhhbmRsZU1vdXNlTGVhdmUiLCJ0b29sdGlwUmVjdCIsInRhcmdldFJlY3QiLCJvdmVyZmxvd0JvdHRvbSIsIm92ZXJmbG93UmlnaHQiLCJSaWNoVG9vbHRpcCIsImhhbmRsZVRhcmdldE1vdXNlRW50ZXIiLCJoYW5kbGVUYXJnZXRNb3VzZUxlYXZlIiwiaGFuZGxlVG9vbHRpcE1vdXNlRW50ZXIiLCJoYW5kbGVUb29sdGlwTW91c2VMZWF2ZSIsImV4aXREb25lIiwiVEVYVEFSRUEiLCJMQUJFTF9GTE9BVElORyIsIkVORF9BTElHTkVEIiwiV0lUSF9UUkFJTElOR19JQ09OIiwiV0lUSF9JTlRFUk5BTF9DT1VOVEVSIiwiQUZGSVgiLCJBRkZJWF9QUkVGSVgiLCJBRkZJWF9TVUZGSVgiLCJSRVNJWkVSIiwiSEVMUEVSX0xJTkUiLCJIRUxQRVJfVEVYVF9QRVJTSVNURU5UIiwiSEVMUEVSX1RFWFRfVkFMSURBVElPTiIsIkNIQVJBQ1RFUl9DT1VOVEVSIiwiQ2hhcmFjdGVyQ291bnRlciIsIm1heFZhbHVlIiwidGV4dGFyZWEiLCJhdXRvUmVzaXplIiwic2V0SGVpZ2h0IiwiUmVzaXplciIsIlRleHRGaWVsZCIsImRlZmF1bHRWYWx1ZSIsInByZWZpeCIsInN1ZmZpeCIsInBlcnNpc3RlbnRIZWxwZXJUZXh0IiwidmFsaWRhdGlvbk1lc3NhZ2UiLCJlbmRBbGlnbmVkIiwiaW50ZXJuYWxDb3VudGVyIiwidmFsaWQiLCJzZXRWYWxpZCIsImNvdW50Iiwic2V0Q291bnQiLCJoYW5kbGVJbnRlcmFjdGlvbiIsImhhbmRsZUlucHV0Rm9jdXMiLCJoYW5kbGVJbnB1dEJsdXIiLCJoYW5kbGVJbnB1dENoYW5nZSIsImlzVmFsaWQiLCJ2YWxpZGl0eSIsImhhc0hlbHBlckxpbmUiLCJtYXhMZW5ndGgiLCJvdXRsaW5lIiwiZGVuc2UiLCJERUJPVU5DRV9USFJPVFRMRV9SRVNJWkVfVElNRV9NUyIsIk1BWF9UT1BfQVBQX0JBUl9IRUlHSFQiLCJTVElDS1kiLCJTVElDS1lfSElEREVOIiwiU1RJQ0tZX1NIT1dOIiwiRklYRURfU0NST0xMRUQiLCJGSVhFRF9BREpVU1QiLCJQUk9NSU5FTlQiLCJQUk9NSU5FTlRfRklYRURfQURKVVNUIiwiREVOU0UiLCJERU5TRV9GSVhFRF9BREpVU1QiLCJERU5TRV9QUk9NSU5FTlRfRklYRURfQURKVVNUIiwiU0hPUlQiLCJTSE9SVF9DT0xMQVBTRUQiLCJTSE9SVF9GSVhFRF9BREpVU1QiLCJTRUNUSU9OX0FMSUdOX1NUQVJUIiwiU0VDVElPTl9BTElHTl9DRU5URVIiLCJTRUNUSU9OX0FMSUdOX0VORCIsIk5BVklHQVRJT05fSUNPTiIsIkFDVElPTl9JVEVNIiwiVG9wQXBwQmFyUm93IiwiVG9wQXBwQmFyU2VjdGlvbiIsIlRvcEFwcEJhciIsIm5hdmlnYXRpb25JY29uIiwiYWN0aW9uSXRlbXMiLCJzdGlja3kiLCJwcm9taW5lbnQiLCJzaG9ydCIsImNvbGxhcHNlZCIsIm9uTmF2aWdhdGlvbkljb25DbGljayIsInNjcm9sbGVkIiwic2V0U2Nyb2xsZWQiLCJoaWRkZW4iLCJzZXRIaWRkZW4iLCJsYXN0U2Nyb2xsUG9zaXRpb24iLCJzY3JvbGxWYWx1ZSIsInBhZ2VZT2Zmc2V0IiwiY3VycmVudFNjcm9sbFBvc2l0aW9uIiwiZGlmZiIsInNob3VsZEhpZGUiLCJUb3BBcHBCYXJBY3Rpb25JdGVtIiwiVG9wQXBwQmFyRml4ZWRBZGp1c3QiLCJUb3BBcHBCYXJOYXZpZ2F0aW9uSWNvbiIsIlRvcEFwcEJhclRpdGxlIiwiQWN0aW9uSXRlbSIsIkZpeGVkQWRqdXN0IiwiTmF2aWdhdGlvbkljb24iLCJUaXRsZSIsImVsZW1lbnRzQnlUeXBlIiwiaGVhZGxpbmUxIiwiaGVhZGxpbmUyIiwiaGVhZGxpbmUzIiwiaGVhZGxpbmU0IiwiaGVhZGxpbmU1IiwiaGVhZGxpbmU2Iiwic3VidGl0bGUxIiwic3VidGl0bGUyIiwiYm9keTEiLCJib2R5MiIsImNhcHRpb24iLCJESVNQTEFZIiwiTk9fTUFSR0lOIiwiTk9fV1JBUCIsIlR5cG9ncmFwaHkiLCJkaXNwbGF5Iiwibm9NYXJnaW4iLCJub1dyYXAiLCJQYWdlIiwiZGVzY3JpcHRpb24iLCJsaW5rcyIsImd1aWRlIiwiZG9jcyIsIkNvZGUiLCJzZXR1cCIsImlzQ29kZU9wZW4iLCJzZXRDb2RlT3BlbiIsInByaW50Q29tcG9uZW50IiwiZGVwdGgiLCJyZXBsYWNlIiwiZW50cmllcyIsImluZGVudCIsInJlcGVhdCIsImlzRW1wdHkiLCJwcmludFByb3BzIiwiZW5kc1dpdGgiLCJwcmludFByb3AiLCJwcmludFZhbHVlIiwiQXZhdGFyUGFnZSIsInNldFNpemUiLCJzZXRDb250ZW50IiwiQmFkZ2VQYWdlIiwiaXNPcGVuMSIsInNldE9wZW4xIiwiaXNPcGVuMiIsInNldE9wZW4yIiwiaXNPcGVuMyIsInNldE9wZW4zIiwiaXNPcGVuNCIsInNldE9wZW40IiwiQnV0dG9uUGFnZSIsInNldFR5cGUiLCJzZXRMZWFkaW5nSWNvbiIsInNldFRyYWlsaW5nSWNvbiIsIkNhcmRQYWdlIiwiQ2hlY2tib3hQYWdlIiwiaXNDaGVja2VkIiwic2V0Q2hlY2tlZCIsIkNoaXBzUGFnZSIsImNob2ljZUNoaXAiLCJzZXRDaG9pY2VDaGlwcyIsImZpbHRlckNoaXBzIiwic2V0RmlsdGVyQ2hpcHMiLCJDaXJjdWxhclByb2dyZXNzUGFnZSIsImlzQ2xvc2VkIiwic2V0Q2xvc2VkIiwidGFibGUiLCJEYXRhVGFibGVQYWdlIiwiZGF0YSIsInNldERhdGEiLCJzZXRTb3J0IiwiaGFuZGxlU29ydCIsInNsaWNlIiwiYSIsImIiLCJEaWFsb2dQYWdlIiwiaXNCYXNpY09wZW4iLCJzZXRCYXNpY09wZW4iLCJpc0NvbmZpcm1hdGlvbk9wZW4iLCJzZXRDb25maXJtYXRpb25PcGVuIiwiaXNTdGFja2luZ09wZW4iLCJzZXRTdGFja2luZ09wZW4iLCJpc1Njcm9sbGFibGVPcGVuIiwic2V0U2Nyb2xsYWJsZU9wZW4iLCJpc0Z1bGxzY3JlZW5PcGVuIiwic2V0RnVsbHNjcmVlbk9wZW4iLCJEcmF3ZXJQYWdlIiwiaXNEaXNtaXNzaWJsZU9wZW4iLCJzZXREaXNtaXNzaWJsZU9wZW4iLCJpc01vZGFsT3BlbiIsInNldE1vZGFsT3BlbiIsIkVsZXZhdGlvblBhZ2UiLCJzZXRaIiwiRkFCUGFnZSIsImlzRXhpdGVkIiwic2V0RXhpdGVkIiwiRm9ybUZpZWxkUGFnZSIsIm1hcmtlZCIsImhpZ2hsaWdodCIsImphdmFzY3JpcHQiLCJzY3NzIiwic2hlbGwiLCJwbGFpbnRleHQiLCJyZWdpc3Rlckxhbmd1YWdlIiwic2V0T3B0aW9ucyIsImNvZGUiLCJsYW5nIiwibGFuZ3VhZ2UiLCJnZXRMYW5ndWFnZSIsImxhbmdQcmVmaXgiLCJtYXJrZG93biIsInJlYWRtZSIsImh0bWwiLCJIb21lUGFnZSIsIl9faHRtbCIsIkljb25CdXR0b25QYWdlIiwiaXNPbiIsInNldE9uIiwic3RhbmRhcmRJdGVtcyIsImZpbGwiLCJtYXNvbnJ5SXRlbXMiLCJyYW5kb20iLCJJbWFnZUxpc3RQYWdlIiwiTGF5b3V0R3JpZFBhZ2UiLCJMaW5lYXJQcm9ncmVzc1BhZ2UiLCJMaXN0UGFnZSIsIk1lbnVQYWdlIiwiaXNRdWlja09wZW4iLCJzZXRRdWlja09wZW4iLCJpc1BlcnNpc3RlbnRPcGVuIiwic2V0UGVyc2lzdGVudE9wZW4iLCJpc0FuY2hvcmVkT3BlbiIsInNldEFuY2hvcmVkT3BlbiIsImFuY2hvclBvc2l0aW9uIiwic2V0QW5jaG9yUG9zaXRpb24iLCJzZXRBbmNob3JPcmlnaW4iLCJzZXRUcmFuc2Zvcm1PcmlnaW4iLCJoYW5kbGVBbmNob3JQb3NpdGlvbkNoYW5nZSIsImhhbmRsZUFuY2hvck9yaWdpbkNoYW5nZSIsImhhbmRsZVRyYW5zZm9ybU9yaWdpbkNoYW5nZSIsIlJhZGlvUGFnZSIsInZhbHVlMSIsInNldFZhbHVlMSIsInZhbHVlMiIsInNldFZhbHVlMiIsImhhbmRsZUNoYW5nZTEiLCJoYW5kbGVDaGFuZ2UyIiwiU2VnbWVudGVkQnV0dG9uUGFnZSIsInZhbHVlMyIsInNldFZhbHVlMyIsIlNlbGVjdFBhZ2UiLCJzZXRGaWxsZWQiLCJzZXRPdXRsaW5lZCIsInByZXNlbGVjdGVkIiwic2V0UHJlc2VsZWN0ZWQiLCJzZXRNdWx0aXBsZSIsInNldEljb24iLCJTaWRlU2hlZXRQYWdlIiwiU2xpZGVyUGFnZSIsIlNuYWNrYmFyUGFnZSIsImlzT3BlbiIsInNldE9wZW4iLCJoYXNBY3Rpb24iLCJzZXRIYXNBY3Rpb24iLCJpc0xlYWRpbmciLCJzZXRMZWFkaW5nIiwiaXNTdGFja2VkIiwic2V0U3RhY2tlZCIsIlN3aXRjaFBhZ2UiLCJpc1NlbGVjdGVkIiwic2V0U2VsZWN0ZWQiLCJiYXNpYyIsInNldEJhc2ljIiwic2V0TWluV2lkdGgiLCJzZXRNaW5XaWR0aEluZGljYXRvciIsIm1pbldpZHRoV2l0aE1pbldpZHRoSW5kaWNhdG9yIiwic2V0TWluV2lkdGhXaXRoTWluV2lkdGhJbmRpY2F0b3IiLCJzZXRGYWRlIiwiaWNvbnMiLCJzZXRJY29ucyIsInN0YWNrZWRJY29ucyIsInNldFN0YWNrZWRJY29ucyIsIm9ubHlJY29ucyIsInNldE9ubHlJY29ucyIsInNldEljb25JbmRpY2F0b3IiLCJzY3JvbGwiLCJzZXRTY3JvbGwiLCJUeXBvZ3JhcGh5UGFnZSIsImlzRmlsbGVkIiwiaXNPdXRsaW5lZCIsIlRvb2x0aXBQYWdlIiwiVG9wQXBwQmFyUGFnZSIsImlzQ29sbGFwc2VkIiwic2V0Q29sbGFwc2VkIiwiQ2hpcHMiLCJIb21lIiwiVGFicyIsInVybCIsIlJvdXRlIiwiTGluayIsIk5hdkxpbmsiLCJyb3V0ZXMiLCJBcHAiLCJyb3V0ZSIsImV4YWN0IiwiQnJvd3NlclJvdXRlciIsIlJvdXRlciIsInJlbmRlciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///934\n')},184:(module,exports)=>{eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!\n  Copyright (c) 2018 Jed Watson.\n  Licensed under the MIT License (MIT), see\n  http://jedwatson.github.io/classnames\n*/\n/* global define */\n\n(function () {\n\t'use strict';\n\n\tvar hasOwn = {}.hasOwnProperty;\n\n\tfunction classNames() {\n\t\tvar classes = [];\n\n\t\tfor (var i = 0; i < arguments.length; i++) {\n\t\t\tvar arg = arguments[i];\n\t\t\tif (!arg) continue;\n\n\t\t\tvar argType = typeof arg;\n\n\t\t\tif (argType === 'string' || argType === 'number') {\n\t\t\t\tclasses.push(arg);\n\t\t\t} else if (Array.isArray(arg)) {\n\t\t\t\tif (arg.length) {\n\t\t\t\t\tvar inner = classNames.apply(null, arg);\n\t\t\t\t\tif (inner) {\n\t\t\t\t\t\tclasses.push(inner);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (argType === 'object') {\n\t\t\t\tif (arg.toString === Object.prototype.toString) {\n\t\t\t\t\tfor (var key in arg) {\n\t\t\t\t\t\tif (hasOwn.call(arg, key) && arg[key]) {\n\t\t\t\t\t\t\tclasses.push(key);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tclasses.push(arg.toString());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn classes.join(' ');\n\t}\n\n\tif ( true && module.exports) {\n\t\tclassNames.default = classNames;\n\t\tmodule.exports = classNames;\n\t} else if (true) {\n\t\t// register as 'classnames', consistent with npm package name\n\t\t!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function () {\n\t\t\treturn classNames;\n\t\t}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t} else {}\n}());\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTg0LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGdCQUFnQjs7QUFFaEI7QUFDQTs7QUFFQSxrQkFBa0Isc0JBQXNCO0FBQ3hDO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsS0FBSyxLQUE2QjtBQUNsQztBQUNBO0FBQ0EsR0FBRyxTQUFTLElBQTRFO0FBQ3hGO0FBQ0EsRUFBRSxpQ0FBcUIsRUFBRSxtQ0FBRTtBQUMzQjtBQUNBLEdBQUc7QUFBQSxrR0FBQztBQUNKLEdBQUcsS0FBSyxFQUVOO0FBQ0YsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL21kYy1yZWFjdC8uL25vZGVfbW9kdWxlcy9jbGFzc25hbWVzL2luZGV4LmpzPzRkMjYiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gIENvcHlyaWdodCAoYykgMjAxOCBKZWQgV2F0c29uLlxuICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UgKE1JVCksIHNlZVxuICBodHRwOi8vamVkd2F0c29uLmdpdGh1Yi5pby9jbGFzc25hbWVzXG4qL1xuLyogZ2xvYmFsIGRlZmluZSAqL1xuXG4oZnVuY3Rpb24gKCkge1xuXHQndXNlIHN0cmljdCc7XG5cblx0dmFyIGhhc093biA9IHt9Lmhhc093blByb3BlcnR5O1xuXG5cdGZ1bmN0aW9uIGNsYXNzTmFtZXMoKSB7XG5cdFx0dmFyIGNsYXNzZXMgPSBbXTtcblxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgYXJnID0gYXJndW1lbnRzW2ldO1xuXHRcdFx0aWYgKCFhcmcpIGNvbnRpbnVlO1xuXG5cdFx0XHR2YXIgYXJnVHlwZSA9IHR5cGVvZiBhcmc7XG5cblx0XHRcdGlmIChhcmdUeXBlID09PSAnc3RyaW5nJyB8fCBhcmdUeXBlID09PSAnbnVtYmVyJykge1xuXHRcdFx0XHRjbGFzc2VzLnB1c2goYXJnKTtcblx0XHRcdH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShhcmcpKSB7XG5cdFx0XHRcdGlmIChhcmcubGVuZ3RoKSB7XG5cdFx0XHRcdFx0dmFyIGlubmVyID0gY2xhc3NOYW1lcy5hcHBseShudWxsLCBhcmcpO1xuXHRcdFx0XHRcdGlmIChpbm5lcikge1xuXHRcdFx0XHRcdFx0Y2xhc3Nlcy5wdXNoKGlubmVyKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSBpZiAoYXJnVHlwZSA9PT0gJ29iamVjdCcpIHtcblx0XHRcdFx0aWYgKGFyZy50b1N0cmluZyA9PT0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZykge1xuXHRcdFx0XHRcdGZvciAodmFyIGtleSBpbiBhcmcpIHtcblx0XHRcdFx0XHRcdGlmIChoYXNPd24uY2FsbChhcmcsIGtleSkgJiYgYXJnW2tleV0pIHtcblx0XHRcdFx0XHRcdFx0Y2xhc3Nlcy5wdXNoKGtleSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGNsYXNzZXMucHVzaChhcmcudG9TdHJpbmcoKSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gY2xhc3Nlcy5qb2luKCcgJyk7XG5cdH1cblxuXHRpZiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgbW9kdWxlLmV4cG9ydHMpIHtcblx0XHRjbGFzc05hbWVzLmRlZmF1bHQgPSBjbGFzc05hbWVzO1xuXHRcdG1vZHVsZS5leHBvcnRzID0gY2xhc3NOYW1lcztcblx0fSBlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBkZWZpbmUuYW1kID09PSAnb2JqZWN0JyAmJiBkZWZpbmUuYW1kKSB7XG5cdFx0Ly8gcmVnaXN0ZXIgYXMgJ2NsYXNzbmFtZXMnLCBjb25zaXN0ZW50IHdpdGggbnBtIHBhY2thZ2UgbmFtZVxuXHRcdGRlZmluZSgnY2xhc3NuYW1lcycsIFtdLCBmdW5jdGlvbiAoKSB7XG5cdFx0XHRyZXR1cm4gY2xhc3NOYW1lcztcblx0XHR9KTtcblx0fSBlbHNlIHtcblx0XHR3aW5kb3cuY2xhc3NOYW1lcyA9IGNsYXNzTmFtZXM7XG5cdH1cbn0oKSk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///184\n")},679:(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("\n\nvar reactIs = __webpack_require__(864);\n\n/**\n * Copyright 2015, Yahoo! Inc.\n * Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.\n */\nvar REACT_STATICS = {\n  childContextTypes: true,\n  contextType: true,\n  contextTypes: true,\n  defaultProps: true,\n  displayName: true,\n  getDefaultProps: true,\n  getDerivedStateFromError: true,\n  getDerivedStateFromProps: true,\n  mixins: true,\n  propTypes: true,\n  type: true\n};\nvar KNOWN_STATICS = {\n  name: true,\n  length: true,\n  prototype: true,\n  caller: true,\n  callee: true,\n  arguments: true,\n  arity: true\n};\nvar FORWARD_REF_STATICS = {\n  '$$typeof': true,\n  render: true,\n  defaultProps: true,\n  displayName: true,\n  propTypes: true\n};\nvar MEMO_STATICS = {\n  '$$typeof': true,\n  compare: true,\n  defaultProps: true,\n  displayName: true,\n  propTypes: true,\n  type: true\n};\nvar TYPE_STATICS = {};\nTYPE_STATICS[reactIs.ForwardRef] = FORWARD_REF_STATICS;\nTYPE_STATICS[reactIs.Memo] = MEMO_STATICS;\n\nfunction getStatics(component) {\n  // React v16.11 and below\n  if (reactIs.isMemo(component)) {\n    return MEMO_STATICS;\n  } // React v16.12 and above\n\n\n  return TYPE_STATICS[component['$$typeof']] || REACT_STATICS;\n}\n\nvar defineProperty = Object.defineProperty;\nvar getOwnPropertyNames = Object.getOwnPropertyNames;\nvar getOwnPropertySymbols = Object.getOwnPropertySymbols;\nvar getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\nvar getPrototypeOf = Object.getPrototypeOf;\nvar objectPrototype = Object.prototype;\nfunction hoistNonReactStatics(targetComponent, sourceComponent, blacklist) {\n  if (typeof sourceComponent !== 'string') {\n    // don't hoist over string (html) components\n    if (objectPrototype) {\n      var inheritedComponent = getPrototypeOf(sourceComponent);\n\n      if (inheritedComponent && inheritedComponent !== objectPrototype) {\n        hoistNonReactStatics(targetComponent, inheritedComponent, blacklist);\n      }\n    }\n\n    var keys = getOwnPropertyNames(sourceComponent);\n\n    if (getOwnPropertySymbols) {\n      keys = keys.concat(getOwnPropertySymbols(sourceComponent));\n    }\n\n    var targetStatics = getStatics(targetComponent);\n    var sourceStatics = getStatics(sourceComponent);\n\n    for (var i = 0; i < keys.length; ++i) {\n      var key = keys[i];\n\n      if (!KNOWN_STATICS[key] && !(blacklist && blacklist[key]) && !(sourceStatics && sourceStatics[key]) && !(targetStatics && targetStatics[key])) {\n        var descriptor = getOwnPropertyDescriptor(sourceComponent, key);\n\n        try {\n          // Avoid failures from read-only properties\n          defineProperty(targetComponent, key, descriptor);\n        } catch (e) {}\n      }\n    }\n  }\n\n  return targetComponent;\n}\n\nmodule.exports = hoistNonReactStatics;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjc5LmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLGNBQWMsbUJBQU8sQ0FBQyxHQUFVOztBQUVoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLG9CQUFvQixpQkFBaUI7QUFDckM7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9ub2RlX21vZHVsZXMvaG9pc3Qtbm9uLXJlYWN0LXN0YXRpY3MvZGlzdC9ob2lzdC1ub24tcmVhY3Qtc3RhdGljcy5janMuanM/ZGE2YSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbnZhciByZWFjdElzID0gcmVxdWlyZSgncmVhY3QtaXMnKTtcblxuLyoqXG4gKiBDb3B5cmlnaHQgMjAxNSwgWWFob28hIEluYy5cbiAqIENvcHlyaWdodHMgbGljZW5zZWQgdW5kZXIgdGhlIE5ldyBCU0QgTGljZW5zZS4gU2VlIHRoZSBhY2NvbXBhbnlpbmcgTElDRU5TRSBmaWxlIGZvciB0ZXJtcy5cbiAqL1xudmFyIFJFQUNUX1NUQVRJQ1MgPSB7XG4gIGNoaWxkQ29udGV4dFR5cGVzOiB0cnVlLFxuICBjb250ZXh0VHlwZTogdHJ1ZSxcbiAgY29udGV4dFR5cGVzOiB0cnVlLFxuICBkZWZhdWx0UHJvcHM6IHRydWUsXG4gIGRpc3BsYXlOYW1lOiB0cnVlLFxuICBnZXREZWZhdWx0UHJvcHM6IHRydWUsXG4gIGdldERlcml2ZWRTdGF0ZUZyb21FcnJvcjogdHJ1ZSxcbiAgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzOiB0cnVlLFxuICBtaXhpbnM6IHRydWUsXG4gIHByb3BUeXBlczogdHJ1ZSxcbiAgdHlwZTogdHJ1ZVxufTtcbnZhciBLTk9XTl9TVEFUSUNTID0ge1xuICBuYW1lOiB0cnVlLFxuICBsZW5ndGg6IHRydWUsXG4gIHByb3RvdHlwZTogdHJ1ZSxcbiAgY2FsbGVyOiB0cnVlLFxuICBjYWxsZWU6IHRydWUsXG4gIGFyZ3VtZW50czogdHJ1ZSxcbiAgYXJpdHk6IHRydWVcbn07XG52YXIgRk9SV0FSRF9SRUZfU1RBVElDUyA9IHtcbiAgJyQkdHlwZW9mJzogdHJ1ZSxcbiAgcmVuZGVyOiB0cnVlLFxuICBkZWZhdWx0UHJvcHM6IHRydWUsXG4gIGRpc3BsYXlOYW1lOiB0cnVlLFxuICBwcm9wVHlwZXM6IHRydWVcbn07XG52YXIgTUVNT19TVEFUSUNTID0ge1xuICAnJCR0eXBlb2YnOiB0cnVlLFxuICBjb21wYXJlOiB0cnVlLFxuICBkZWZhdWx0UHJvcHM6IHRydWUsXG4gIGRpc3BsYXlOYW1lOiB0cnVlLFxuICBwcm9wVHlwZXM6IHRydWUsXG4gIHR5cGU6IHRydWVcbn07XG52YXIgVFlQRV9TVEFUSUNTID0ge307XG5UWVBFX1NUQVRJQ1NbcmVhY3RJcy5Gb3J3YXJkUmVmXSA9IEZPUldBUkRfUkVGX1NUQVRJQ1M7XG5UWVBFX1NUQVRJQ1NbcmVhY3RJcy5NZW1vXSA9IE1FTU9fU1RBVElDUztcblxuZnVuY3Rpb24gZ2V0U3RhdGljcyhjb21wb25lbnQpIHtcbiAgLy8gUmVhY3QgdjE2LjExIGFuZCBiZWxvd1xuICBpZiAocmVhY3RJcy5pc01lbW8oY29tcG9uZW50KSkge1xuICAgIHJldHVybiBNRU1PX1NUQVRJQ1M7XG4gIH0gLy8gUmVhY3QgdjE2LjEyIGFuZCBhYm92ZVxuXG5cbiAgcmV0dXJuIFRZUEVfU1RBVElDU1tjb21wb25lbnRbJyQkdHlwZW9mJ11dIHx8IFJFQUNUX1NUQVRJQ1M7XG59XG5cbnZhciBkZWZpbmVQcm9wZXJ0eSA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBnZXRPd25Qcm9wZXJ0eU5hbWVzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXM7XG52YXIgZ2V0T3duUHJvcGVydHlTeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scztcbnZhciBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xudmFyIGdldFByb3RvdHlwZU9mID0gT2JqZWN0LmdldFByb3RvdHlwZU9mO1xudmFyIG9iamVjdFByb3RvdHlwZSA9IE9iamVjdC5wcm90b3R5cGU7XG5mdW5jdGlvbiBob2lzdE5vblJlYWN0U3RhdGljcyh0YXJnZXRDb21wb25lbnQsIHNvdXJjZUNvbXBvbmVudCwgYmxhY2tsaXN0KSB7XG4gIGlmICh0eXBlb2Ygc291cmNlQ29tcG9uZW50ICE9PSAnc3RyaW5nJykge1xuICAgIC8vIGRvbid0IGhvaXN0IG92ZXIgc3RyaW5nIChodG1sKSBjb21wb25lbnRzXG4gICAgaWYgKG9iamVjdFByb3RvdHlwZSkge1xuICAgICAgdmFyIGluaGVyaXRlZENvbXBvbmVudCA9IGdldFByb3RvdHlwZU9mKHNvdXJjZUNvbXBvbmVudCk7XG5cbiAgICAgIGlmIChpbmhlcml0ZWRDb21wb25lbnQgJiYgaW5oZXJpdGVkQ29tcG9uZW50ICE9PSBvYmplY3RQcm90b3R5cGUpIHtcbiAgICAgICAgaG9pc3ROb25SZWFjdFN0YXRpY3ModGFyZ2V0Q29tcG9uZW50LCBpbmhlcml0ZWRDb21wb25lbnQsIGJsYWNrbGlzdCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGtleXMgPSBnZXRPd25Qcm9wZXJ0eU5hbWVzKHNvdXJjZUNvbXBvbmVudCk7XG5cbiAgICBpZiAoZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gICAgICBrZXlzID0ga2V5cy5jb25jYXQoZ2V0T3duUHJvcGVydHlTeW1ib2xzKHNvdXJjZUNvbXBvbmVudCkpO1xuICAgIH1cblxuICAgIHZhciB0YXJnZXRTdGF0aWNzID0gZ2V0U3RhdGljcyh0YXJnZXRDb21wb25lbnQpO1xuICAgIHZhciBzb3VyY2VTdGF0aWNzID0gZ2V0U3RhdGljcyhzb3VyY2VDb21wb25lbnQpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKSB7XG4gICAgICB2YXIga2V5ID0ga2V5c1tpXTtcblxuICAgICAgaWYgKCFLTk9XTl9TVEFUSUNTW2tleV0gJiYgIShibGFja2xpc3QgJiYgYmxhY2tsaXN0W2tleV0pICYmICEoc291cmNlU3RhdGljcyAmJiBzb3VyY2VTdGF0aWNzW2tleV0pICYmICEodGFyZ2V0U3RhdGljcyAmJiB0YXJnZXRTdGF0aWNzW2tleV0pKSB7XG4gICAgICAgIHZhciBkZXNjcmlwdG9yID0gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZUNvbXBvbmVudCwga2V5KTtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgIC8vIEF2b2lkIGZhaWx1cmVzIGZyb20gcmVhZC1vbmx5IHByb3BlcnRpZXNcbiAgICAgICAgICBkZWZpbmVQcm9wZXJ0eSh0YXJnZXRDb21wb25lbnQsIGtleSwgZGVzY3JpcHRvcik7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRhcmdldENvbXBvbmVudDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBob2lzdE5vblJlYWN0U3RhdGljcztcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///679\n")},826:module=>{eval("module.exports = Array.isArray || function (arr) {\n  return Object.prototype.toString.call(arr) == '[object Array]';\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODI2LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL21kYy1yZWFjdC8uL25vZGVfbW9kdWxlcy9pc2FycmF5L2luZGV4LmpzP2UzZGIiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uIChhcnIpIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChhcnIpID09ICdbb2JqZWN0IEFycmF5XSc7XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///826\n")},84:function(module){eval("/**\n * marked - a markdown parser\n * Copyright (c) 2011-2021, Christopher Jeffrey. (MIT Licensed)\n * https://github.com/markedjs/marked\n */\n\n/**\n * DO NOT EDIT THIS FILE\n * The code in this file is generated from files in ./src/\n */\n\n(function (global, factory) {\n   true ? module.exports = factory() :\n  0;\n})(this, (function () { 'use strict';\n\n  function _defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  function _createClass(Constructor, protoProps, staticProps) {\n    if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) _defineProperties(Constructor, staticProps);\n    return Constructor;\n  }\n\n  function _unsupportedIterableToArray(o, minLen) {\n    if (!o) return;\n    if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n    var n = Object.prototype.toString.call(o).slice(8, -1);\n    if (n === \"Object\" && o.constructor) n = o.constructor.name;\n    if (n === \"Map\" || n === \"Set\") return Array.from(o);\n    if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n  }\n\n  function _arrayLikeToArray(arr, len) {\n    if (len == null || len > arr.length) len = arr.length;\n\n    for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n\n    return arr2;\n  }\n\n  function _createForOfIteratorHelperLoose(o, allowArrayLike) {\n    var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"];\n    if (it) return (it = it.call(o)).next.bind(it);\n\n    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n      return function () {\n        if (i >= o.length) return {\n          done: true\n        };\n        return {\n          done: false,\n          value: o[i++]\n        };\n      };\n    }\n\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n\n  var defaults$5 = {exports: {}};\n\n  function getDefaults$1() {\n    return {\n      baseUrl: null,\n      breaks: false,\n      extensions: null,\n      gfm: true,\n      headerIds: true,\n      headerPrefix: '',\n      highlight: null,\n      langPrefix: 'language-',\n      mangle: true,\n      pedantic: false,\n      renderer: null,\n      sanitize: false,\n      sanitizer: null,\n      silent: false,\n      smartLists: false,\n      smartypants: false,\n      tokenizer: null,\n      walkTokens: null,\n      xhtml: false\n    };\n  }\n\n  function changeDefaults$1(newDefaults) {\n    defaults$5.exports.defaults = newDefaults;\n  }\n\n  defaults$5.exports = {\n    defaults: getDefaults$1(),\n    getDefaults: getDefaults$1,\n    changeDefaults: changeDefaults$1\n  };\n\n  /**\n   * Helpers\n   */\n  var escapeTest = /[&<>\"']/;\n  var escapeReplace = /[&<>\"']/g;\n  var escapeTestNoEncode = /[<>\"']|&(?!#?\\w+;)/;\n  var escapeReplaceNoEncode = /[<>\"']|&(?!#?\\w+;)/g;\n  var escapeReplacements = {\n    '&': '&amp;',\n    '<': '&lt;',\n    '>': '&gt;',\n    '\"': '&quot;',\n    \"'\": '&#39;'\n  };\n\n  var getEscapeReplacement = function getEscapeReplacement(ch) {\n    return escapeReplacements[ch];\n  };\n\n  function escape$2(html, encode) {\n    if (encode) {\n      if (escapeTest.test(html)) {\n        return html.replace(escapeReplace, getEscapeReplacement);\n      }\n    } else {\n      if (escapeTestNoEncode.test(html)) {\n        return html.replace(escapeReplaceNoEncode, getEscapeReplacement);\n      }\n    }\n\n    return html;\n  }\n\n  var unescapeTest = /&(#(?:\\d+)|(?:#x[0-9A-Fa-f]+)|(?:\\w+));?/ig;\n\n  function unescape$1(html) {\n    // explicitly match decimal, hex, and named HTML entities\n    return html.replace(unescapeTest, function (_, n) {\n      n = n.toLowerCase();\n      if (n === 'colon') return ':';\n\n      if (n.charAt(0) === '#') {\n        return n.charAt(1) === 'x' ? String.fromCharCode(parseInt(n.substring(2), 16)) : String.fromCharCode(+n.substring(1));\n      }\n\n      return '';\n    });\n  }\n\n  var caret = /(^|[^\\[])\\^/g;\n\n  function edit$1(regex, opt) {\n    regex = regex.source || regex;\n    opt = opt || '';\n    var obj = {\n      replace: function replace(name, val) {\n        val = val.source || val;\n        val = val.replace(caret, '$1');\n        regex = regex.replace(name, val);\n        return obj;\n      },\n      getRegex: function getRegex() {\n        return new RegExp(regex, opt);\n      }\n    };\n    return obj;\n  }\n\n  var nonWordAndColonTest = /[^\\w:]/g;\n  var originIndependentUrl = /^$|^[a-z][a-z0-9+.-]*:|^[?#]/i;\n\n  function cleanUrl$1(sanitize, base, href) {\n    if (sanitize) {\n      var prot;\n\n      try {\n        prot = decodeURIComponent(unescape$1(href)).replace(nonWordAndColonTest, '').toLowerCase();\n      } catch (e) {\n        return null;\n      }\n\n      if (prot.indexOf('javascript:') === 0 || prot.indexOf('vbscript:') === 0 || prot.indexOf('data:') === 0) {\n        return null;\n      }\n    }\n\n    if (base && !originIndependentUrl.test(href)) {\n      href = resolveUrl(base, href);\n    }\n\n    try {\n      href = encodeURI(href).replace(/%25/g, '%');\n    } catch (e) {\n      return null;\n    }\n\n    return href;\n  }\n\n  var baseUrls = {};\n  var justDomain = /^[^:]+:\\/*[^/]*$/;\n  var protocol = /^([^:]+:)[\\s\\S]*$/;\n  var domain = /^([^:]+:\\/*[^/]*)[\\s\\S]*$/;\n\n  function resolveUrl(base, href) {\n    if (!baseUrls[' ' + base]) {\n      // we can ignore everything in base after the last slash of its path component,\n      // but we might need to add _that_\n      // https://tools.ietf.org/html/rfc3986#section-3\n      if (justDomain.test(base)) {\n        baseUrls[' ' + base] = base + '/';\n      } else {\n        baseUrls[' ' + base] = rtrim$1(base, '/', true);\n      }\n    }\n\n    base = baseUrls[' ' + base];\n    var relativeBase = base.indexOf(':') === -1;\n\n    if (href.substring(0, 2) === '//') {\n      if (relativeBase) {\n        return href;\n      }\n\n      return base.replace(protocol, '$1') + href;\n    } else if (href.charAt(0) === '/') {\n      if (relativeBase) {\n        return href;\n      }\n\n      return base.replace(domain, '$1') + href;\n    } else {\n      return base + href;\n    }\n  }\n\n  var noopTest$1 = {\n    exec: function noopTest() {}\n  };\n\n  function merge$2(obj) {\n    var i = 1,\n        target,\n        key;\n\n    for (; i < arguments.length; i++) {\n      target = arguments[i];\n\n      for (key in target) {\n        if (Object.prototype.hasOwnProperty.call(target, key)) {\n          obj[key] = target[key];\n        }\n      }\n    }\n\n    return obj;\n  }\n\n  function splitCells$1(tableRow, count) {\n    // ensure that every cell-delimiting pipe has a space\n    // before it to distinguish it from an escaped pipe\n    var row = tableRow.replace(/\\|/g, function (match, offset, str) {\n      var escaped = false,\n          curr = offset;\n\n      while (--curr >= 0 && str[curr] === '\\\\') {\n        escaped = !escaped;\n      }\n\n      if (escaped) {\n        // odd number of slashes means | is escaped\n        // so we leave it alone\n        return '|';\n      } else {\n        // add space before unescaped |\n        return ' |';\n      }\n    }),\n        cells = row.split(/ \\|/);\n    var i = 0; // First/last cell in a row cannot be empty if it has no leading/trailing pipe\n\n    if (!cells[0].trim()) {\n      cells.shift();\n    }\n\n    if (!cells[cells.length - 1].trim()) {\n      cells.pop();\n    }\n\n    if (cells.length > count) {\n      cells.splice(count);\n    } else {\n      while (cells.length < count) {\n        cells.push('');\n      }\n    }\n\n    for (; i < cells.length; i++) {\n      // leading or trailing whitespace is ignored per the gfm spec\n      cells[i] = cells[i].trim().replace(/\\\\\\|/g, '|');\n    }\n\n    return cells;\n  } // Remove trailing 'c's. Equivalent to str.replace(/c*$/, '').\n  // /c*$/ is vulnerable to REDOS.\n  // invert: Remove suffix of non-c chars instead. Default falsey.\n\n\n  function rtrim$1(str, c, invert) {\n    var l = str.length;\n\n    if (l === 0) {\n      return '';\n    } // Length of suffix matching the invert condition.\n\n\n    var suffLen = 0; // Step left until we fail to match the invert condition.\n\n    while (suffLen < l) {\n      var currChar = str.charAt(l - suffLen - 1);\n\n      if (currChar === c && !invert) {\n        suffLen++;\n      } else if (currChar !== c && invert) {\n        suffLen++;\n      } else {\n        break;\n      }\n    }\n\n    return str.substr(0, l - suffLen);\n  }\n\n  function findClosingBracket$1(str, b) {\n    if (str.indexOf(b[1]) === -1) {\n      return -1;\n    }\n\n    var l = str.length;\n    var level = 0,\n        i = 0;\n\n    for (; i < l; i++) {\n      if (str[i] === '\\\\') {\n        i++;\n      } else if (str[i] === b[0]) {\n        level++;\n      } else if (str[i] === b[1]) {\n        level--;\n\n        if (level < 0) {\n          return i;\n        }\n      }\n    }\n\n    return -1;\n  }\n\n  function checkSanitizeDeprecation$1(opt) {\n    if (opt && opt.sanitize && !opt.silent) {\n      console.warn('marked(): sanitize and sanitizer parameters are deprecated since version 0.7.0, should not be used and will be removed in the future. Read more here: https://marked.js.org/#/USING_ADVANCED.md#options');\n    }\n  } // copied from https://stackoverflow.com/a/5450113/806777\n\n\n  function repeatString$1(pattern, count) {\n    if (count < 1) {\n      return '';\n    }\n\n    var result = '';\n\n    while (count > 1) {\n      if (count & 1) {\n        result += pattern;\n      }\n\n      count >>= 1;\n      pattern += pattern;\n    }\n\n    return result + pattern;\n  }\n\n  var helpers = {\n    escape: escape$2,\n    unescape: unescape$1,\n    edit: edit$1,\n    cleanUrl: cleanUrl$1,\n    resolveUrl: resolveUrl,\n    noopTest: noopTest$1,\n    merge: merge$2,\n    splitCells: splitCells$1,\n    rtrim: rtrim$1,\n    findClosingBracket: findClosingBracket$1,\n    checkSanitizeDeprecation: checkSanitizeDeprecation$1,\n    repeatString: repeatString$1\n  };\n\n  var defaults$4 = defaults$5.exports.defaults;\n  var rtrim = helpers.rtrim,\n      splitCells = helpers.splitCells,\n      _escape = helpers.escape,\n      findClosingBracket = helpers.findClosingBracket;\n\n  function outputLink(cap, link, raw, lexer) {\n    var href = link.href;\n    var title = link.title ? _escape(link.title) : null;\n    var text = cap[1].replace(/\\\\([\\[\\]])/g, '$1');\n\n    if (cap[0].charAt(0) !== '!') {\n      lexer.state.inLink = true;\n      var token = {\n        type: 'link',\n        raw: raw,\n        href: href,\n        title: title,\n        text: text,\n        tokens: lexer.inlineTokens(text, [])\n      };\n      lexer.state.inLink = false;\n      return token;\n    } else {\n      return {\n        type: 'image',\n        raw: raw,\n        href: href,\n        title: title,\n        text: _escape(text)\n      };\n    }\n  }\n\n  function indentCodeCompensation(raw, text) {\n    var matchIndentToCode = raw.match(/^(\\s+)(?:```)/);\n\n    if (matchIndentToCode === null) {\n      return text;\n    }\n\n    var indentToCode = matchIndentToCode[1];\n    return text.split('\\n').map(function (node) {\n      var matchIndentInNode = node.match(/^\\s+/);\n\n      if (matchIndentInNode === null) {\n        return node;\n      }\n\n      var indentInNode = matchIndentInNode[0];\n\n      if (indentInNode.length >= indentToCode.length) {\n        return node.slice(indentToCode.length);\n      }\n\n      return node;\n    }).join('\\n');\n  }\n  /**\n   * Tokenizer\n   */\n\n\n  var Tokenizer_1 = /*#__PURE__*/function () {\n    function Tokenizer(options) {\n      this.options = options || defaults$4;\n    }\n\n    var _proto = Tokenizer.prototype;\n\n    _proto.space = function space(src) {\n      var cap = this.rules.block.newline.exec(src);\n\n      if (cap) {\n        if (cap[0].length > 1) {\n          return {\n            type: 'space',\n            raw: cap[0]\n          };\n        }\n\n        return {\n          raw: '\\n'\n        };\n      }\n    };\n\n    _proto.code = function code(src) {\n      var cap = this.rules.block.code.exec(src);\n\n      if (cap) {\n        var text = cap[0].replace(/^ {1,4}/gm, '');\n        return {\n          type: 'code',\n          raw: cap[0],\n          codeBlockStyle: 'indented',\n          text: !this.options.pedantic ? rtrim(text, '\\n') : text\n        };\n      }\n    };\n\n    _proto.fences = function fences(src) {\n      var cap = this.rules.block.fences.exec(src);\n\n      if (cap) {\n        var raw = cap[0];\n        var text = indentCodeCompensation(raw, cap[3] || '');\n        return {\n          type: 'code',\n          raw: raw,\n          lang: cap[2] ? cap[2].trim() : cap[2],\n          text: text\n        };\n      }\n    };\n\n    _proto.heading = function heading(src) {\n      var cap = this.rules.block.heading.exec(src);\n\n      if (cap) {\n        var text = cap[2].trim(); // remove trailing #s\n\n        if (/#$/.test(text)) {\n          var trimmed = rtrim(text, '#');\n\n          if (this.options.pedantic) {\n            text = trimmed.trim();\n          } else if (!trimmed || / $/.test(trimmed)) {\n            // CommonMark requires space before trailing #s\n            text = trimmed.trim();\n          }\n        }\n\n        var token = {\n          type: 'heading',\n          raw: cap[0],\n          depth: cap[1].length,\n          text: text,\n          tokens: []\n        };\n        this.lexer.inline(token.text, token.tokens);\n        return token;\n      }\n    };\n\n    _proto.hr = function hr(src) {\n      var cap = this.rules.block.hr.exec(src);\n\n      if (cap) {\n        return {\n          type: 'hr',\n          raw: cap[0]\n        };\n      }\n    };\n\n    _proto.blockquote = function blockquote(src) {\n      var cap = this.rules.block.blockquote.exec(src);\n\n      if (cap) {\n        var text = cap[0].replace(/^ *> ?/gm, '');\n        return {\n          type: 'blockquote',\n          raw: cap[0],\n          tokens: this.lexer.blockTokens(text, []),\n          text: text\n        };\n      }\n    };\n\n    _proto.list = function list(src) {\n      var cap = this.rules.block.list.exec(src);\n\n      if (cap) {\n        var raw, istask, ischecked, indent, i, blankLine, endsWithBlankLine, line, lines, itemContents;\n        var bull = cap[1].trim();\n        var isordered = bull.length > 1;\n        var list = {\n          type: 'list',\n          raw: '',\n          ordered: isordered,\n          start: isordered ? +bull.slice(0, -1) : '',\n          loose: false,\n          items: []\n        };\n        bull = isordered ? \"\\\\d{1,9}\\\\\" + bull.slice(-1) : \"\\\\\" + bull;\n\n        if (this.options.pedantic) {\n          bull = isordered ? bull : '[*+-]';\n        } // Get next list item\n\n\n        var itemRegex = new RegExp(\"^( {0,3}\" + bull + \")((?: [^\\\\n]*| *)(?:\\\\n[^\\\\n]*)*(?:\\\\n|$))\"); // Get each top-level item\n\n        while (src) {\n          if (this.rules.block.hr.test(src)) {\n            // End list if we encounter an HR (possibly move into itemRegex?)\n            break;\n          }\n\n          if (!(cap = itemRegex.exec(src))) {\n            break;\n          }\n\n          lines = cap[2].split('\\n');\n\n          if (this.options.pedantic) {\n            indent = 2;\n            itemContents = lines[0].trimLeft();\n          } else {\n            indent = cap[2].search(/[^ ]/); // Find first non-space char\n\n            indent = cap[1].length + (indent > 4 ? 1 : indent); // intented code blocks after 4 spaces; indent is always 1\n\n            itemContents = lines[0].slice(indent - cap[1].length);\n          }\n\n          blankLine = false;\n          raw = cap[0];\n\n          if (!lines[0] && /^ *$/.test(lines[1])) {\n            // items begin with at most one blank line\n            raw = cap[1] + lines.slice(0, 2).join('\\n') + '\\n';\n            list.loose = true;\n            lines = [];\n          }\n\n          var nextBulletRegex = new RegExp(\"^ {0,\" + Math.min(3, indent - 1) + \"}(?:[*+-]|\\\\d{1,9}[.)])\");\n\n          for (i = 1; i < lines.length; i++) {\n            line = lines[i];\n\n            if (this.options.pedantic) {\n              // Re-align to follow commonmark nesting rules\n              line = line.replace(/^ {1,4}(?=( {4})*[^ ])/g, '  ');\n            } // End list item if found start of new bullet\n\n\n            if (nextBulletRegex.test(line)) {\n              raw = cap[1] + lines.slice(0, i).join('\\n') + '\\n';\n              break;\n            } // Until we encounter a blank line, item contents do not need indentation\n\n\n            if (!blankLine) {\n              if (!line.trim()) {\n                // Check if current line is empty\n                blankLine = true;\n              } // Dedent if possible\n\n\n              if (line.search(/[^ ]/) >= indent) {\n                itemContents += '\\n' + line.slice(indent);\n              } else {\n                itemContents += '\\n' + line;\n              }\n\n              continue;\n            } // Dedent this line\n\n\n            if (line.search(/[^ ]/) >= indent || !line.trim()) {\n              itemContents += '\\n' + line.slice(indent);\n              continue;\n            } else {\n              // Line was not properly indented; end of this item\n              raw = cap[1] + lines.slice(0, i).join('\\n') + '\\n';\n              break;\n            }\n          }\n\n          if (!list.loose) {\n            // If the previous item ended with a blank line, the list is loose\n            if (endsWithBlankLine) {\n              list.loose = true;\n            } else if (/\\n *\\n *$/.test(raw)) {\n              endsWithBlankLine = true;\n            }\n          } // Check for task list items\n\n\n          if (this.options.gfm) {\n            istask = /^\\[[ xX]\\] /.exec(itemContents);\n\n            if (istask) {\n              ischecked = istask[0] !== '[ ] ';\n              itemContents = itemContents.replace(/^\\[[ xX]\\] +/, '');\n            }\n          }\n\n          list.items.push({\n            type: 'list_item',\n            raw: raw,\n            task: !!istask,\n            checked: ischecked,\n            loose: false,\n            text: itemContents\n          });\n          list.raw += raw;\n          src = src.slice(raw.length);\n        } // Do not consume newlines at end of final item. Alternatively, make itemRegex *start* with any newlines to simplify/speed up endsWithBlankLine logic\n\n\n        list.items[list.items.length - 1].raw = raw.trimRight();\n        list.items[list.items.length - 1].text = itemContents.trimRight();\n        list.raw = list.raw.trimRight();\n        var l = list.items.length; // Item child tokens handled here at end because we needed to have the final item to trim it first\n\n        for (i = 0; i < l; i++) {\n          this.lexer.state.top = false;\n          list.items[i].tokens = this.lexer.blockTokens(list.items[i].text, []);\n\n          if (list.items[i].tokens.some(function (t) {\n            return t.type === 'space';\n          })) {\n            list.loose = true;\n            list.items[i].loose = true;\n          }\n        }\n\n        return list;\n      }\n    };\n\n    _proto.html = function html(src) {\n      var cap = this.rules.block.html.exec(src);\n\n      if (cap) {\n        var token = {\n          type: 'html',\n          raw: cap[0],\n          pre: !this.options.sanitizer && (cap[1] === 'pre' || cap[1] === 'script' || cap[1] === 'style'),\n          text: cap[0]\n        };\n\n        if (this.options.sanitize) {\n          token.type = 'paragraph';\n          token.text = this.options.sanitizer ? this.options.sanitizer(cap[0]) : _escape(cap[0]);\n          token.tokens = [];\n          this.lexer.inline(token.text, token.tokens);\n        }\n\n        return token;\n      }\n    };\n\n    _proto.def = function def(src) {\n      var cap = this.rules.block.def.exec(src);\n\n      if (cap) {\n        if (cap[3]) cap[3] = cap[3].substring(1, cap[3].length - 1);\n        var tag = cap[1].toLowerCase().replace(/\\s+/g, ' ');\n        return {\n          type: 'def',\n          tag: tag,\n          raw: cap[0],\n          href: cap[2],\n          title: cap[3]\n        };\n      }\n    };\n\n    _proto.table = function table(src) {\n      var cap = this.rules.block.table.exec(src);\n\n      if (cap) {\n        var item = {\n          type: 'table',\n          header: splitCells(cap[1]).map(function (c) {\n            return {\n              text: c\n            };\n          }),\n          align: cap[2].replace(/^ *|\\| *$/g, '').split(/ *\\| */),\n          rows: cap[3] ? cap[3].replace(/\\n$/, '').split('\\n') : []\n        };\n\n        if (item.header.length === item.align.length) {\n          item.raw = cap[0];\n          var l = item.align.length;\n          var i, j, k, row;\n\n          for (i = 0; i < l; i++) {\n            if (/^ *-+: *$/.test(item.align[i])) {\n              item.align[i] = 'right';\n            } else if (/^ *:-+: *$/.test(item.align[i])) {\n              item.align[i] = 'center';\n            } else if (/^ *:-+ *$/.test(item.align[i])) {\n              item.align[i] = 'left';\n            } else {\n              item.align[i] = null;\n            }\n          }\n\n          l = item.rows.length;\n\n          for (i = 0; i < l; i++) {\n            item.rows[i] = splitCells(item.rows[i], item.header.length).map(function (c) {\n              return {\n                text: c\n              };\n            });\n          } // parse child tokens inside headers and cells\n          // header child tokens\n\n\n          l = item.header.length;\n\n          for (j = 0; j < l; j++) {\n            item.header[j].tokens = [];\n            this.lexer.inlineTokens(item.header[j].text, item.header[j].tokens);\n          } // cell child tokens\n\n\n          l = item.rows.length;\n\n          for (j = 0; j < l; j++) {\n            row = item.rows[j];\n\n            for (k = 0; k < row.length; k++) {\n              row[k].tokens = [];\n              this.lexer.inlineTokens(row[k].text, row[k].tokens);\n            }\n          }\n\n          return item;\n        }\n      }\n    };\n\n    _proto.lheading = function lheading(src) {\n      var cap = this.rules.block.lheading.exec(src);\n\n      if (cap) {\n        var token = {\n          type: 'heading',\n          raw: cap[0],\n          depth: cap[2].charAt(0) === '=' ? 1 : 2,\n          text: cap[1],\n          tokens: []\n        };\n        this.lexer.inline(token.text, token.tokens);\n        return token;\n      }\n    };\n\n    _proto.paragraph = function paragraph(src) {\n      var cap = this.rules.block.paragraph.exec(src);\n\n      if (cap) {\n        var token = {\n          type: 'paragraph',\n          raw: cap[0],\n          text: cap[1].charAt(cap[1].length - 1) === '\\n' ? cap[1].slice(0, -1) : cap[1],\n          tokens: []\n        };\n        this.lexer.inline(token.text, token.tokens);\n        return token;\n      }\n    };\n\n    _proto.text = function text(src) {\n      var cap = this.rules.block.text.exec(src);\n\n      if (cap) {\n        var token = {\n          type: 'text',\n          raw: cap[0],\n          text: cap[0],\n          tokens: []\n        };\n        this.lexer.inline(token.text, token.tokens);\n        return token;\n      }\n    };\n\n    _proto.escape = function escape(src) {\n      var cap = this.rules.inline.escape.exec(src);\n\n      if (cap) {\n        return {\n          type: 'escape',\n          raw: cap[0],\n          text: _escape(cap[1])\n        };\n      }\n    };\n\n    _proto.tag = function tag(src) {\n      var cap = this.rules.inline.tag.exec(src);\n\n      if (cap) {\n        if (!this.lexer.state.inLink && /^<a /i.test(cap[0])) {\n          this.lexer.state.inLink = true;\n        } else if (this.lexer.state.inLink && /^<\\/a>/i.test(cap[0])) {\n          this.lexer.state.inLink = false;\n        }\n\n        if (!this.lexer.state.inRawBlock && /^<(pre|code|kbd|script)(\\s|>)/i.test(cap[0])) {\n          this.lexer.state.inRawBlock = true;\n        } else if (this.lexer.state.inRawBlock && /^<\\/(pre|code|kbd|script)(\\s|>)/i.test(cap[0])) {\n          this.lexer.state.inRawBlock = false;\n        }\n\n        return {\n          type: this.options.sanitize ? 'text' : 'html',\n          raw: cap[0],\n          inLink: this.lexer.state.inLink,\n          inRawBlock: this.lexer.state.inRawBlock,\n          text: this.options.sanitize ? this.options.sanitizer ? this.options.sanitizer(cap[0]) : _escape(cap[0]) : cap[0]\n        };\n      }\n    };\n\n    _proto.link = function link(src) {\n      var cap = this.rules.inline.link.exec(src);\n\n      if (cap) {\n        var trimmedUrl = cap[2].trim();\n\n        if (!this.options.pedantic && /^</.test(trimmedUrl)) {\n          // commonmark requires matching angle brackets\n          if (!/>$/.test(trimmedUrl)) {\n            return;\n          } // ending angle bracket cannot be escaped\n\n\n          var rtrimSlash = rtrim(trimmedUrl.slice(0, -1), '\\\\');\n\n          if ((trimmedUrl.length - rtrimSlash.length) % 2 === 0) {\n            return;\n          }\n        } else {\n          // find closing parenthesis\n          var lastParenIndex = findClosingBracket(cap[2], '()');\n\n          if (lastParenIndex > -1) {\n            var start = cap[0].indexOf('!') === 0 ? 5 : 4;\n            var linkLen = start + cap[1].length + lastParenIndex;\n            cap[2] = cap[2].substring(0, lastParenIndex);\n            cap[0] = cap[0].substring(0, linkLen).trim();\n            cap[3] = '';\n          }\n        }\n\n        var href = cap[2];\n        var title = '';\n\n        if (this.options.pedantic) {\n          // split pedantic href and title\n          var link = /^([^'\"]*[^\\s])\\s+(['\"])(.*)\\2/.exec(href);\n\n          if (link) {\n            href = link[1];\n            title = link[3];\n          }\n        } else {\n          title = cap[3] ? cap[3].slice(1, -1) : '';\n        }\n\n        href = href.trim();\n\n        if (/^</.test(href)) {\n          if (this.options.pedantic && !/>$/.test(trimmedUrl)) {\n            // pedantic allows starting angle bracket without ending angle bracket\n            href = href.slice(1);\n          } else {\n            href = href.slice(1, -1);\n          }\n        }\n\n        return outputLink(cap, {\n          href: href ? href.replace(this.rules.inline._escapes, '$1') : href,\n          title: title ? title.replace(this.rules.inline._escapes, '$1') : title\n        }, cap[0], this.lexer);\n      }\n    };\n\n    _proto.reflink = function reflink(src, links) {\n      var cap;\n\n      if ((cap = this.rules.inline.reflink.exec(src)) || (cap = this.rules.inline.nolink.exec(src))) {\n        var link = (cap[2] || cap[1]).replace(/\\s+/g, ' ');\n        link = links[link.toLowerCase()];\n\n        if (!link || !link.href) {\n          var text = cap[0].charAt(0);\n          return {\n            type: 'text',\n            raw: text,\n            text: text\n          };\n        }\n\n        return outputLink(cap, link, cap[0], this.lexer);\n      }\n    };\n\n    _proto.emStrong = function emStrong(src, maskedSrc, prevChar) {\n      if (prevChar === void 0) {\n        prevChar = '';\n      }\n\n      var match = this.rules.inline.emStrong.lDelim.exec(src);\n      if (!match) return; // _ can't be between two alphanumerics. \\p{L}\\p{N} includes non-english alphabet/numbers as well\n\n      if (match[3] && prevChar.match(/(?:[0-9A-Za-z\\xAA\\xB2\\xB3\\xB5\\xB9\\xBA\\xBC-\\xBE\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0370-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u037F\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u048A-\\u052F\\u0531-\\u0556\\u0559\\u0560-\\u0588\\u05D0-\\u05EA\\u05EF-\\u05F2\\u0620-\\u064A\\u0660-\\u0669\\u066E\\u066F\\u0671-\\u06D3\\u06D5\\u06E5\\u06E6\\u06EE-\\u06FC\\u06FF\\u0710\\u0712-\\u072F\\u074D-\\u07A5\\u07B1\\u07C0-\\u07EA\\u07F4\\u07F5\\u07FA\\u0800-\\u0815\\u081A\\u0824\\u0828\\u0840-\\u0858\\u0860-\\u086A\\u08A0-\\u08B4\\u08B6-\\u08C7\\u0904-\\u0939\\u093D\\u0950\\u0958-\\u0961\\u0966-\\u096F\\u0971-\\u0980\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BD\\u09CE\\u09DC\\u09DD\\u09DF-\\u09E1\\u09E6-\\u09F1\\u09F4-\\u09F9\\u09FC\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A59-\\u0A5C\\u0A5E\\u0A66-\\u0A6F\\u0A72-\\u0A74\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABD\\u0AD0\\u0AE0\\u0AE1\\u0AE6-\\u0AEF\\u0AF9\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3D\\u0B5C\\u0B5D\\u0B5F-\\u0B61\\u0B66-\\u0B6F\\u0B71-\\u0B77\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BD0\\u0BE6-\\u0BF2\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C39\\u0C3D\\u0C58-\\u0C5A\\u0C60\\u0C61\\u0C66-\\u0C6F\\u0C78-\\u0C7E\\u0C80\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBD\\u0CDE\\u0CE0\\u0CE1\\u0CE6-\\u0CEF\\u0CF1\\u0CF2\\u0D04-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D\\u0D4E\\u0D54-\\u0D56\\u0D58-\\u0D61\\u0D66-\\u0D78\\u0D7A-\\u0D7F\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0DE6-\\u0DEF\\u0E01-\\u0E30\\u0E32\\u0E33\\u0E40-\\u0E46\\u0E50-\\u0E59\\u0E81\\u0E82\\u0E84\\u0E86-\\u0E8A\\u0E8C-\\u0EA3\\u0EA5\\u0EA7-\\u0EB0\\u0EB2\\u0EB3\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0ED0-\\u0ED9\\u0EDC-\\u0EDF\\u0F00\\u0F20-\\u0F33\\u0F40-\\u0F47\\u0F49-\\u0F6C\\u0F88-\\u0F8C\\u1000-\\u102A\\u103F-\\u1049\\u1050-\\u1055\\u105A-\\u105D\\u1061\\u1065\\u1066\\u106E-\\u1070\\u1075-\\u1081\\u108E\\u1090-\\u1099\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u1369-\\u137C\\u1380-\\u138F\\u13A0-\\u13F5\\u13F8-\\u13FD\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16EE-\\u16F8\\u1700-\\u170C\\u170E-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176C\\u176E-\\u1770\\u1780-\\u17B3\\u17D7\\u17DC\\u17E0-\\u17E9\\u17F0-\\u17F9\\u1810-\\u1819\\u1820-\\u1878\\u1880-\\u1884\\u1887-\\u18A8\\u18AA\\u18B0-\\u18F5\\u1900-\\u191E\\u1946-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19B0-\\u19C9\\u19D0-\\u19DA\\u1A00-\\u1A16\\u1A20-\\u1A54\\u1A80-\\u1A89\\u1A90-\\u1A99\\u1AA7\\u1B05-\\u1B33\\u1B45-\\u1B4B\\u1B50-\\u1B59\\u1B83-\\u1BA0\\u1BAE-\\u1BE5\\u1C00-\\u1C23\\u1C40-\\u1C49\\u1C4D-\\u1C7D\\u1C80-\\u1C88\\u1C90-\\u1CBA\\u1CBD-\\u1CBF\\u1CE9-\\u1CEC\\u1CEE-\\u1CF3\\u1CF5\\u1CF6\\u1CFA\\u1D00-\\u1DBF\\u1E00-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u2070\\u2071\\u2074-\\u2079\\u207F-\\u2089\\u2090-\\u209C\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2119-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u212D\\u212F-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2150-\\u2189\\u2460-\\u249B\\u24EA-\\u24FF\\u2776-\\u2793\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2CE4\\u2CEB-\\u2CEE\\u2CF2\\u2CF3\\u2CFD\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D80-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u2E2F\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303C\\u3041-\\u3096\\u309D-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312F\\u3131-\\u318E\\u3192-\\u3195\\u31A0-\\u31BF\\u31F0-\\u31FF\\u3220-\\u3229\\u3248-\\u324F\\u3251-\\u325F\\u3280-\\u3289\\u32B1-\\u32BF\\u3400-\\u4DBF\\u4E00-\\u9FFC\\uA000-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA62B\\uA640-\\uA66E\\uA67F-\\uA69D\\uA6A0-\\uA6EF\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA7BF\\uA7C2-\\uA7CA\\uA7F5-\\uA801\\uA803-\\uA805\\uA807-\\uA80A\\uA80C-\\uA822\\uA830-\\uA835\\uA840-\\uA873\\uA882-\\uA8B3\\uA8D0-\\uA8D9\\uA8F2-\\uA8F7\\uA8FB\\uA8FD\\uA8FE\\uA900-\\uA925\\uA930-\\uA946\\uA960-\\uA97C\\uA984-\\uA9B2\\uA9CF-\\uA9D9\\uA9E0-\\uA9E4\\uA9E6-\\uA9FE\\uAA00-\\uAA28\\uAA40-\\uAA42\\uAA44-\\uAA4B\\uAA50-\\uAA59\\uAA60-\\uAA76\\uAA7A\\uAA7E-\\uAAAF\\uAAB1\\uAAB5\\uAAB6\\uAAB9-\\uAABD\\uAAC0\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEA\\uAAF2-\\uAAF4\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uAB30-\\uAB5A\\uAB5C-\\uAB69\\uAB70-\\uABE2\\uABF0-\\uABF9\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D\\uFB1F-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF10-\\uFF19\\uFF21-\\uFF3A\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]|\\uD800[\\uDC00-\\uDC0B\\uDC0D-\\uDC26\\uDC28-\\uDC3A\\uDC3C\\uDC3D\\uDC3F-\\uDC4D\\uDC50-\\uDC5D\\uDC80-\\uDCFA\\uDD07-\\uDD33\\uDD40-\\uDD78\\uDD8A\\uDD8B\\uDE80-\\uDE9C\\uDEA0-\\uDED0\\uDEE1-\\uDEFB\\uDF00-\\uDF23\\uDF2D-\\uDF4A\\uDF50-\\uDF75\\uDF80-\\uDF9D\\uDFA0-\\uDFC3\\uDFC8-\\uDFCF\\uDFD1-\\uDFD5]|\\uD801[\\uDC00-\\uDC9D\\uDCA0-\\uDCA9\\uDCB0-\\uDCD3\\uDCD8-\\uDCFB\\uDD00-\\uDD27\\uDD30-\\uDD63\\uDE00-\\uDF36\\uDF40-\\uDF55\\uDF60-\\uDF67]|\\uD802[\\uDC00-\\uDC05\\uDC08\\uDC0A-\\uDC35\\uDC37\\uDC38\\uDC3C\\uDC3F-\\uDC55\\uDC58-\\uDC76\\uDC79-\\uDC9E\\uDCA7-\\uDCAF\\uDCE0-\\uDCF2\\uDCF4\\uDCF5\\uDCFB-\\uDD1B\\uDD20-\\uDD39\\uDD80-\\uDDB7\\uDDBC-\\uDDCF\\uDDD2-\\uDE00\\uDE10-\\uDE13\\uDE15-\\uDE17\\uDE19-\\uDE35\\uDE40-\\uDE48\\uDE60-\\uDE7E\\uDE80-\\uDE9F\\uDEC0-\\uDEC7\\uDEC9-\\uDEE4\\uDEEB-\\uDEEF\\uDF00-\\uDF35\\uDF40-\\uDF55\\uDF58-\\uDF72\\uDF78-\\uDF91\\uDFA9-\\uDFAF]|\\uD803[\\uDC00-\\uDC48\\uDC80-\\uDCB2\\uDCC0-\\uDCF2\\uDCFA-\\uDD23\\uDD30-\\uDD39\\uDE60-\\uDE7E\\uDE80-\\uDEA9\\uDEB0\\uDEB1\\uDF00-\\uDF27\\uDF30-\\uDF45\\uDF51-\\uDF54\\uDFB0-\\uDFCB\\uDFE0-\\uDFF6]|\\uD804[\\uDC03-\\uDC37\\uDC52-\\uDC6F\\uDC83-\\uDCAF\\uDCD0-\\uDCE8\\uDCF0-\\uDCF9\\uDD03-\\uDD26\\uDD36-\\uDD3F\\uDD44\\uDD47\\uDD50-\\uDD72\\uDD76\\uDD83-\\uDDB2\\uDDC1-\\uDDC4\\uDDD0-\\uDDDA\\uDDDC\\uDDE1-\\uDDF4\\uDE00-\\uDE11\\uDE13-\\uDE2B\\uDE80-\\uDE86\\uDE88\\uDE8A-\\uDE8D\\uDE8F-\\uDE9D\\uDE9F-\\uDEA8\\uDEB0-\\uDEDE\\uDEF0-\\uDEF9\\uDF05-\\uDF0C\\uDF0F\\uDF10\\uDF13-\\uDF28\\uDF2A-\\uDF30\\uDF32\\uDF33\\uDF35-\\uDF39\\uDF3D\\uDF50\\uDF5D-\\uDF61]|\\uD805[\\uDC00-\\uDC34\\uDC47-\\uDC4A\\uDC50-\\uDC59\\uDC5F-\\uDC61\\uDC80-\\uDCAF\\uDCC4\\uDCC5\\uDCC7\\uDCD0-\\uDCD9\\uDD80-\\uDDAE\\uDDD8-\\uDDDB\\uDE00-\\uDE2F\\uDE44\\uDE50-\\uDE59\\uDE80-\\uDEAA\\uDEB8\\uDEC0-\\uDEC9\\uDF00-\\uDF1A\\uDF30-\\uDF3B]|\\uD806[\\uDC00-\\uDC2B\\uDCA0-\\uDCF2\\uDCFF-\\uDD06\\uDD09\\uDD0C-\\uDD13\\uDD15\\uDD16\\uDD18-\\uDD2F\\uDD3F\\uDD41\\uDD50-\\uDD59\\uDDA0-\\uDDA7\\uDDAA-\\uDDD0\\uDDE1\\uDDE3\\uDE00\\uDE0B-\\uDE32\\uDE3A\\uDE50\\uDE5C-\\uDE89\\uDE9D\\uDEC0-\\uDEF8]|\\uD807[\\uDC00-\\uDC08\\uDC0A-\\uDC2E\\uDC40\\uDC50-\\uDC6C\\uDC72-\\uDC8F\\uDD00-\\uDD06\\uDD08\\uDD09\\uDD0B-\\uDD30\\uDD46\\uDD50-\\uDD59\\uDD60-\\uDD65\\uDD67\\uDD68\\uDD6A-\\uDD89\\uDD98\\uDDA0-\\uDDA9\\uDEE0-\\uDEF2\\uDFB0\\uDFC0-\\uDFD4]|\\uD808[\\uDC00-\\uDF99]|\\uD809[\\uDC00-\\uDC6E\\uDC80-\\uDD43]|[\\uD80C\\uD81C-\\uD820\\uD822\\uD840-\\uD868\\uD86A-\\uD86C\\uD86F-\\uD872\\uD874-\\uD879\\uD880-\\uD883][\\uDC00-\\uDFFF]|\\uD80D[\\uDC00-\\uDC2E]|\\uD811[\\uDC00-\\uDE46]|\\uD81A[\\uDC00-\\uDE38\\uDE40-\\uDE5E\\uDE60-\\uDE69\\uDED0-\\uDEED\\uDF00-\\uDF2F\\uDF40-\\uDF43\\uDF50-\\uDF59\\uDF5B-\\uDF61\\uDF63-\\uDF77\\uDF7D-\\uDF8F]|\\uD81B[\\uDE40-\\uDE96\\uDF00-\\uDF4A\\uDF50\\uDF93-\\uDF9F\\uDFE0\\uDFE1\\uDFE3]|\\uD821[\\uDC00-\\uDFF7]|\\uD823[\\uDC00-\\uDCD5\\uDD00-\\uDD08]|\\uD82C[\\uDC00-\\uDD1E\\uDD50-\\uDD52\\uDD64-\\uDD67\\uDD70-\\uDEFB]|\\uD82F[\\uDC00-\\uDC6A\\uDC70-\\uDC7C\\uDC80-\\uDC88\\uDC90-\\uDC99]|\\uD834[\\uDEE0-\\uDEF3\\uDF60-\\uDF78]|\\uD835[\\uDC00-\\uDC54\\uDC56-\\uDC9C\\uDC9E\\uDC9F\\uDCA2\\uDCA5\\uDCA6\\uDCA9-\\uDCAC\\uDCAE-\\uDCB9\\uDCBB\\uDCBD-\\uDCC3\\uDCC5-\\uDD05\\uDD07-\\uDD0A\\uDD0D-\\uDD14\\uDD16-\\uDD1C\\uDD1E-\\uDD39\\uDD3B-\\uDD3E\\uDD40-\\uDD44\\uDD46\\uDD4A-\\uDD50\\uDD52-\\uDEA5\\uDEA8-\\uDEC0\\uDEC2-\\uDEDA\\uDEDC-\\uDEFA\\uDEFC-\\uDF14\\uDF16-\\uDF34\\uDF36-\\uDF4E\\uDF50-\\uDF6E\\uDF70-\\uDF88\\uDF8A-\\uDFA8\\uDFAA-\\uDFC2\\uDFC4-\\uDFCB\\uDFCE-\\uDFFF]|\\uD838[\\uDD00-\\uDD2C\\uDD37-\\uDD3D\\uDD40-\\uDD49\\uDD4E\\uDEC0-\\uDEEB\\uDEF0-\\uDEF9]|\\uD83A[\\uDC00-\\uDCC4\\uDCC7-\\uDCCF\\uDD00-\\uDD43\\uDD4B\\uDD50-\\uDD59]|\\uD83B[\\uDC71-\\uDCAB\\uDCAD-\\uDCAF\\uDCB1-\\uDCB4\\uDD01-\\uDD2D\\uDD2F-\\uDD3D\\uDE00-\\uDE03\\uDE05-\\uDE1F\\uDE21\\uDE22\\uDE24\\uDE27\\uDE29-\\uDE32\\uDE34-\\uDE37\\uDE39\\uDE3B\\uDE42\\uDE47\\uDE49\\uDE4B\\uDE4D-\\uDE4F\\uDE51\\uDE52\\uDE54\\uDE57\\uDE59\\uDE5B\\uDE5D\\uDE5F\\uDE61\\uDE62\\uDE64\\uDE67-\\uDE6A\\uDE6C-\\uDE72\\uDE74-\\uDE77\\uDE79-\\uDE7C\\uDE7E\\uDE80-\\uDE89\\uDE8B-\\uDE9B\\uDEA1-\\uDEA3\\uDEA5-\\uDEA9\\uDEAB-\\uDEBB]|\\uD83C[\\uDD00-\\uDD0C]|\\uD83E[\\uDFF0-\\uDFF9]|\\uD869[\\uDC00-\\uDEDD\\uDF00-\\uDFFF]|\\uD86D[\\uDC00-\\uDF34\\uDF40-\\uDFFF]|\\uD86E[\\uDC00-\\uDC1D\\uDC20-\\uDFFF]|\\uD873[\\uDC00-\\uDEA1\\uDEB0-\\uDFFF]|\\uD87A[\\uDC00-\\uDFE0]|\\uD87E[\\uDC00-\\uDE1D]|\\uD884[\\uDC00-\\uDF4A])/)) return;\n      var nextChar = match[1] || match[2] || '';\n\n      if (!nextChar || nextChar && (prevChar === '' || this.rules.inline.punctuation.exec(prevChar))) {\n        var lLength = match[0].length - 1;\n        var rDelim,\n            rLength,\n            delimTotal = lLength,\n            midDelimTotal = 0;\n        var endReg = match[0][0] === '*' ? this.rules.inline.emStrong.rDelimAst : this.rules.inline.emStrong.rDelimUnd;\n        endReg.lastIndex = 0; // Clip maskedSrc to same section of string as src (move to lexer?)\n\n        maskedSrc = maskedSrc.slice(-1 * src.length + lLength);\n\n        while ((match = endReg.exec(maskedSrc)) != null) {\n          rDelim = match[1] || match[2] || match[3] || match[4] || match[5] || match[6];\n          if (!rDelim) continue; // skip single * in __abc*abc__\n\n          rLength = rDelim.length;\n\n          if (match[3] || match[4]) {\n            // found another Left Delim\n            delimTotal += rLength;\n            continue;\n          } else if (match[5] || match[6]) {\n            // either Left or Right Delim\n            if (lLength % 3 && !((lLength + rLength) % 3)) {\n              midDelimTotal += rLength;\n              continue; // CommonMark Emphasis Rules 9-10\n            }\n          }\n\n          delimTotal -= rLength;\n          if (delimTotal > 0) continue; // Haven't found enough closing delimiters\n          // Remove extra characters. *a*** -> *a*\n\n          rLength = Math.min(rLength, rLength + delimTotal + midDelimTotal); // Create `em` if smallest delimiter has odd char count. *a***\n\n          if (Math.min(lLength, rLength) % 2) {\n            var _text = src.slice(1, lLength + match.index + rLength);\n\n            return {\n              type: 'em',\n              raw: src.slice(0, lLength + match.index + rLength + 1),\n              text: _text,\n              tokens: this.lexer.inlineTokens(_text, [])\n            };\n          } // Create 'strong' if smallest delimiter has even char count. **a***\n\n\n          var text = src.slice(2, lLength + match.index + rLength - 1);\n          return {\n            type: 'strong',\n            raw: src.slice(0, lLength + match.index + rLength + 1),\n            text: text,\n            tokens: this.lexer.inlineTokens(text, [])\n          };\n        }\n      }\n    };\n\n    _proto.codespan = function codespan(src) {\n      var cap = this.rules.inline.code.exec(src);\n\n      if (cap) {\n        var text = cap[2].replace(/\\n/g, ' ');\n        var hasNonSpaceChars = /[^ ]/.test(text);\n        var hasSpaceCharsOnBothEnds = /^ /.test(text) && / $/.test(text);\n\n        if (hasNonSpaceChars && hasSpaceCharsOnBothEnds) {\n          text = text.substring(1, text.length - 1);\n        }\n\n        text = _escape(text, true);\n        return {\n          type: 'codespan',\n          raw: cap[0],\n          text: text\n        };\n      }\n    };\n\n    _proto.br = function br(src) {\n      var cap = this.rules.inline.br.exec(src);\n\n      if (cap) {\n        return {\n          type: 'br',\n          raw: cap[0]\n        };\n      }\n    };\n\n    _proto.del = function del(src) {\n      var cap = this.rules.inline.del.exec(src);\n\n      if (cap) {\n        return {\n          type: 'del',\n          raw: cap[0],\n          text: cap[2],\n          tokens: this.lexer.inlineTokens(cap[2], [])\n        };\n      }\n    };\n\n    _proto.autolink = function autolink(src, mangle) {\n      var cap = this.rules.inline.autolink.exec(src);\n\n      if (cap) {\n        var text, href;\n\n        if (cap[2] === '@') {\n          text = _escape(this.options.mangle ? mangle(cap[1]) : cap[1]);\n          href = 'mailto:' + text;\n        } else {\n          text = _escape(cap[1]);\n          href = text;\n        }\n\n        return {\n          type: 'link',\n          raw: cap[0],\n          text: text,\n          href: href,\n          tokens: [{\n            type: 'text',\n            raw: text,\n            text: text\n          }]\n        };\n      }\n    };\n\n    _proto.url = function url(src, mangle) {\n      var cap;\n\n      if (cap = this.rules.inline.url.exec(src)) {\n        var text, href;\n\n        if (cap[2] === '@') {\n          text = _escape(this.options.mangle ? mangle(cap[0]) : cap[0]);\n          href = 'mailto:' + text;\n        } else {\n          // do extended autolink path validation\n          var prevCapZero;\n\n          do {\n            prevCapZero = cap[0];\n            cap[0] = this.rules.inline._backpedal.exec(cap[0])[0];\n          } while (prevCapZero !== cap[0]);\n\n          text = _escape(cap[0]);\n\n          if (cap[1] === 'www.') {\n            href = 'http://' + text;\n          } else {\n            href = text;\n          }\n        }\n\n        return {\n          type: 'link',\n          raw: cap[0],\n          text: text,\n          href: href,\n          tokens: [{\n            type: 'text',\n            raw: text,\n            text: text\n          }]\n        };\n      }\n    };\n\n    _proto.inlineText = function inlineText(src, smartypants) {\n      var cap = this.rules.inline.text.exec(src);\n\n      if (cap) {\n        var text;\n\n        if (this.lexer.state.inRawBlock) {\n          text = this.options.sanitize ? this.options.sanitizer ? this.options.sanitizer(cap[0]) : _escape(cap[0]) : cap[0];\n        } else {\n          text = _escape(this.options.smartypants ? smartypants(cap[0]) : cap[0]);\n        }\n\n        return {\n          type: 'text',\n          raw: cap[0],\n          text: text\n        };\n      }\n    };\n\n    return Tokenizer;\n  }();\n\n  var noopTest = helpers.noopTest,\n      edit = helpers.edit,\n      merge$1 = helpers.merge;\n  /**\n   * Block-Level Grammar\n   */\n\n  var block$1 = {\n    newline: /^(?: *(?:\\n|$))+/,\n    code: /^( {4}[^\\n]+(?:\\n(?: *(?:\\n|$))*)?)+/,\n    fences: /^ {0,3}(`{3,}(?=[^`\\n]*\\n)|~{3,})([^\\n]*)\\n(?:|([\\s\\S]*?)\\n)(?: {0,3}\\1[~`]* *(?=\\n|$)|$)/,\n    hr: /^ {0,3}((?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|$)/,\n    heading: /^ {0,3}(#{1,6})(?=\\s|$)(.*)(?:\\n+|$)/,\n    blockquote: /^( {0,3}> ?(paragraph|[^\\n]*)(?:\\n|$))+/,\n    list: /^( {0,3}bull)( [^\\n]+?)?(?:\\n|$)/,\n    html: '^ {0,3}(?:' // optional indentation\n    + '<(script|pre|style|textarea)[\\\\s>][\\\\s\\\\S]*?(?:</\\\\1>[^\\\\n]*\\\\n+|$)' // (1)\n    + '|comment[^\\\\n]*(\\\\n+|$)' // (2)\n    + '|<\\\\?[\\\\s\\\\S]*?(?:\\\\?>\\\\n*|$)' // (3)\n    + '|<![A-Z][\\\\s\\\\S]*?(?:>\\\\n*|$)' // (4)\n    + '|<!\\\\[CDATA\\\\[[\\\\s\\\\S]*?(?:\\\\]\\\\]>\\\\n*|$)' // (5)\n    + '|</?(tag)(?: +|\\\\n|/?>)[\\\\s\\\\S]*?(?:(?:\\\\n *)+\\\\n|$)' // (6)\n    + '|<(?!script|pre|style|textarea)([a-z][\\\\w-]*)(?:attribute)*? */?>(?=[ \\\\t]*(?:\\\\n|$))[\\\\s\\\\S]*?(?:(?:\\\\n *)+\\\\n|$)' // (7) open tag\n    + '|</(?!script|pre|style|textarea)[a-z][\\\\w-]*\\\\s*>(?=[ \\\\t]*(?:\\\\n|$))[\\\\s\\\\S]*?(?:(?:\\\\n *)+\\\\n|$)' // (7) closing tag\n    + ')',\n    def: /^ {0,3}\\[(label)\\]: *\\n? *<?([^\\s>]+)>?(?:(?: +\\n? *| *\\n *)(title))? *(?:\\n+|$)/,\n    table: noopTest,\n    lheading: /^([^\\n]+)\\n {0,3}(=+|-+) *(?:\\n+|$)/,\n    // regex template, placeholders will be replaced according to different paragraph\n    // interruption rules of commonmark and the original markdown spec:\n    _paragraph: /^([^\\n]+(?:\\n(?!hr|heading|lheading|blockquote|fences|list|html| +\\n)[^\\n]+)*)/,\n    text: /^[^\\n]+/\n  };\n  block$1._label = /(?!\\s*\\])(?:\\\\[\\[\\]]|[^\\[\\]])+/;\n  block$1._title = /(?:\"(?:\\\\\"?|[^\"\\\\])*\"|'[^'\\n]*(?:\\n[^'\\n]+)*\\n?'|\\([^()]*\\))/;\n  block$1.def = edit(block$1.def).replace('label', block$1._label).replace('title', block$1._title).getRegex();\n  block$1.bullet = /(?:[*+-]|\\d{1,9}[.)])/;\n  block$1.listItemStart = edit(/^( *)(bull) */).replace('bull', block$1.bullet).getRegex();\n  block$1.list = edit(block$1.list).replace(/bull/g, block$1.bullet).replace('hr', '\\\\n+(?=\\\\1?(?:(?:- *){3,}|(?:_ *){3,}|(?:\\\\* *){3,})(?:\\\\n+|$))').replace('def', '\\\\n+(?=' + block$1.def.source + ')').getRegex();\n  block$1._tag = 'address|article|aside|base|basefont|blockquote|body|caption' + '|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption' + '|figure|footer|form|frame|frameset|h[1-6]|head|header|hr|html|iframe' + '|legend|li|link|main|menu|menuitem|meta|nav|noframes|ol|optgroup|option' + '|p|param|section|source|summary|table|tbody|td|tfoot|th|thead|title|tr' + '|track|ul';\n  block$1._comment = /\x3c!--(?!-?>)[\\s\\S]*?(?:--\x3e|$)/;\n  block$1.html = edit(block$1.html, 'i').replace('comment', block$1._comment).replace('tag', block$1._tag).replace('attribute', / +[a-zA-Z:_][\\w.:-]*(?: *= *\"[^\"\\n]*\"| *= *'[^'\\n]*'| *= *[^\\s\"'=<>`]+)?/).getRegex();\n  block$1.paragraph = edit(block$1._paragraph).replace('hr', block$1.hr).replace('heading', ' {0,3}#{1,6} ').replace('|lheading', '') // setex headings don't interrupt commonmark paragraphs\n  .replace('blockquote', ' {0,3}>').replace('fences', ' {0,3}(?:`{3,}(?=[^`\\\\n]*\\\\n)|~{3,})[^\\\\n]*\\\\n').replace('list', ' {0,3}(?:[*+-]|1[.)]) ') // only lists starting from 1 can interrupt\n  .replace('html', '</?(?:tag)(?: +|\\\\n|/?>)|<(?:script|pre|style|textarea|!--)').replace('tag', block$1._tag) // pars can be interrupted by type (6) html blocks\n  .getRegex();\n  block$1.blockquote = edit(block$1.blockquote).replace('paragraph', block$1.paragraph).getRegex();\n  /**\n   * Normal Block Grammar\n   */\n\n  block$1.normal = merge$1({}, block$1);\n  /**\n   * GFM Block Grammar\n   */\n\n  block$1.gfm = merge$1({}, block$1.normal, {\n    table: '^ *([^\\\\n ].*\\\\|.*)\\\\n' // Header\n    + ' {0,3}(?:\\\\| *)?(:?-+:? *(?:\\\\| *:?-+:? *)*)(?:\\\\| *)?' // Align\n    + '(?:\\\\n((?:(?! *\\\\n|hr|heading|blockquote|code|fences|list|html).*(?:\\\\n|$))*)\\\\n*|$)' // Cells\n\n  });\n  block$1.gfm.table = edit(block$1.gfm.table).replace('hr', block$1.hr).replace('heading', ' {0,3}#{1,6} ').replace('blockquote', ' {0,3}>').replace('code', ' {4}[^\\\\n]').replace('fences', ' {0,3}(?:`{3,}(?=[^`\\\\n]*\\\\n)|~{3,})[^\\\\n]*\\\\n').replace('list', ' {0,3}(?:[*+-]|1[.)]) ') // only lists starting from 1 can interrupt\n  .replace('html', '</?(?:tag)(?: +|\\\\n|/?>)|<(?:script|pre|style|textarea|!--)').replace('tag', block$1._tag) // tables can be interrupted by type (6) html blocks\n  .getRegex();\n  /**\n   * Pedantic grammar (original John Gruber's loose markdown specification)\n   */\n\n  block$1.pedantic = merge$1({}, block$1.normal, {\n    html: edit('^ *(?:comment *(?:\\\\n|\\\\s*$)' + '|<(tag)[\\\\s\\\\S]+?</\\\\1> *(?:\\\\n{2,}|\\\\s*$)' // closed tag\n    + '|<tag(?:\"[^\"]*\"|\\'[^\\']*\\'|\\\\s[^\\'\"/>\\\\s]*)*?/?> *(?:\\\\n{2,}|\\\\s*$))').replace('comment', block$1._comment).replace(/tag/g, '(?!(?:' + 'a|em|strong|small|s|cite|q|dfn|abbr|data|time|code|var|samp|kbd|sub' + '|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo|span|br|wbr|ins|del|img)' + '\\\\b)\\\\w+(?!:|[^\\\\w\\\\s@]*@)\\\\b').getRegex(),\n    def: /^ *\\[([^\\]]+)\\]: *<?([^\\s>]+)>?(?: +([\"(][^\\n]+[\")]))? *(?:\\n+|$)/,\n    heading: /^(#{1,6})(.*)(?:\\n+|$)/,\n    fences: noopTest,\n    // fences not supported\n    paragraph: edit(block$1.normal._paragraph).replace('hr', block$1.hr).replace('heading', ' *#{1,6} *[^\\n]').replace('lheading', block$1.lheading).replace('blockquote', ' {0,3}>').replace('|fences', '').replace('|list', '').replace('|html', '').getRegex()\n  });\n  /**\n   * Inline-Level Grammar\n   */\n\n  var inline$1 = {\n    escape: /^\\\\([!\"#$%&'()*+,\\-./:;<=>?@\\[\\]\\\\^_`{|}~])/,\n    autolink: /^<(scheme:[^\\s\\x00-\\x1f<>]*|email)>/,\n    url: noopTest,\n    tag: '^comment' + '|^</[a-zA-Z][\\\\w:-]*\\\\s*>' // self-closing tag\n    + '|^<[a-zA-Z][\\\\w-]*(?:attribute)*?\\\\s*/?>' // open tag\n    + '|^<\\\\?[\\\\s\\\\S]*?\\\\?>' // processing instruction, e.g. <?php ?>\n    + '|^<![a-zA-Z]+\\\\s[\\\\s\\\\S]*?>' // declaration, e.g. <!DOCTYPE html>\n    + '|^<!\\\\[CDATA\\\\[[\\\\s\\\\S]*?\\\\]\\\\]>',\n    // CDATA section\n    link: /^!?\\[(label)\\]\\(\\s*(href)(?:\\s+(title))?\\s*\\)/,\n    reflink: /^!?\\[(label)\\]\\[(?!\\s*\\])((?:\\\\[\\[\\]]?|[^\\[\\]\\\\])+)\\]/,\n    nolink: /^!?\\[(?!\\s*\\])((?:\\[[^\\[\\]]*\\]|\\\\[\\[\\]]|[^\\[\\]])*)\\](?:\\[\\])?/,\n    reflinkSearch: 'reflink|nolink(?!\\\\()',\n    emStrong: {\n      lDelim: /^(?:\\*+(?:([punct_])|[^\\s*]))|^_+(?:([punct*])|([^\\s_]))/,\n      //        (1) and (2) can only be a Right Delimiter. (3) and (4) can only be Left.  (5) and (6) can be either Left or Right.\n      //        () Skip orphan delim inside strong    (1) #***                (2) a***#, a***                   (3) #***a, ***a                 (4) ***#              (5) #***#                 (6) a***a\n      rDelimAst: /^[^_*]*?\\_\\_[^_*]*?\\*[^_*]*?(?=\\_\\_)|[punct_](\\*+)(?=[\\s]|$)|[^punct*_\\s](\\*+)(?=[punct_\\s]|$)|[punct_\\s](\\*+)(?=[^punct*_\\s])|[\\s](\\*+)(?=[punct_])|[punct_](\\*+)(?=[punct_])|[^punct*_\\s](\\*+)(?=[^punct*_\\s])/,\n      rDelimUnd: /^[^_*]*?\\*\\*[^_*]*?\\_[^_*]*?(?=\\*\\*)|[punct*](\\_+)(?=[\\s]|$)|[^punct*_\\s](\\_+)(?=[punct*\\s]|$)|[punct*\\s](\\_+)(?=[^punct*_\\s])|[\\s](\\_+)(?=[punct*])|[punct*](\\_+)(?=[punct*])/ // ^- Not allowed for _\n\n    },\n    code: /^(`+)([^`]|[^`][\\s\\S]*?[^`])\\1(?!`)/,\n    br: /^( {2,}|\\\\)\\n(?!\\s*$)/,\n    del: noopTest,\n    text: /^(`+|[^`])(?:(?= {2,}\\n)|[\\s\\S]*?(?:(?=[\\\\<!\\[`*_]|\\b_|$)|[^ ](?= {2,}\\n)))/,\n    punctuation: /^([\\spunctuation])/\n  }; // list of punctuation marks from CommonMark spec\n  // without * and _ to handle the different emphasis markers * and _\n\n  inline$1._punctuation = '!\"#$%&\\'()+\\\\-.,/:;<=>?@\\\\[\\\\]`^{|}~';\n  inline$1.punctuation = edit(inline$1.punctuation).replace(/punctuation/g, inline$1._punctuation).getRegex(); // sequences em should skip over [title](link), `code`, <html>\n\n  inline$1.blockSkip = /\\[[^\\]]*?\\]\\([^\\)]*?\\)|`[^`]*?`|<[^>]*?>/g;\n  inline$1.escapedEmSt = /\\\\\\*|\\\\_/g;\n  inline$1._comment = edit(block$1._comment).replace('(?:--\x3e|$)', '--\x3e').getRegex();\n  inline$1.emStrong.lDelim = edit(inline$1.emStrong.lDelim).replace(/punct/g, inline$1._punctuation).getRegex();\n  inline$1.emStrong.rDelimAst = edit(inline$1.emStrong.rDelimAst, 'g').replace(/punct/g, inline$1._punctuation).getRegex();\n  inline$1.emStrong.rDelimUnd = edit(inline$1.emStrong.rDelimUnd, 'g').replace(/punct/g, inline$1._punctuation).getRegex();\n  inline$1._escapes = /\\\\([!\"#$%&'()*+,\\-./:;<=>?@\\[\\]\\\\^_`{|}~])/g;\n  inline$1._scheme = /[a-zA-Z][a-zA-Z0-9+.-]{1,31}/;\n  inline$1._email = /[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+(@)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(?![-_])/;\n  inline$1.autolink = edit(inline$1.autolink).replace('scheme', inline$1._scheme).replace('email', inline$1._email).getRegex();\n  inline$1._attribute = /\\s+[a-zA-Z:_][\\w.:-]*(?:\\s*=\\s*\"[^\"]*\"|\\s*=\\s*'[^']*'|\\s*=\\s*[^\\s\"'=<>`]+)?/;\n  inline$1.tag = edit(inline$1.tag).replace('comment', inline$1._comment).replace('attribute', inline$1._attribute).getRegex();\n  inline$1._label = /(?:\\[(?:\\\\.|[^\\[\\]\\\\])*\\]|\\\\.|`[^`]*`|[^\\[\\]\\\\`])*?/;\n  inline$1._href = /<(?:\\\\.|[^\\n<>\\\\])+>|[^\\s\\x00-\\x1f]*/;\n  inline$1._title = /\"(?:\\\\\"?|[^\"\\\\])*\"|'(?:\\\\'?|[^'\\\\])*'|\\((?:\\\\\\)?|[^)\\\\])*\\)/;\n  inline$1.link = edit(inline$1.link).replace('label', inline$1._label).replace('href', inline$1._href).replace('title', inline$1._title).getRegex();\n  inline$1.reflink = edit(inline$1.reflink).replace('label', inline$1._label).getRegex();\n  inline$1.reflinkSearch = edit(inline$1.reflinkSearch, 'g').replace('reflink', inline$1.reflink).replace('nolink', inline$1.nolink).getRegex();\n  /**\n   * Normal Inline Grammar\n   */\n\n  inline$1.normal = merge$1({}, inline$1);\n  /**\n   * Pedantic Inline Grammar\n   */\n\n  inline$1.pedantic = merge$1({}, inline$1.normal, {\n    strong: {\n      start: /^__|\\*\\*/,\n      middle: /^__(?=\\S)([\\s\\S]*?\\S)__(?!_)|^\\*\\*(?=\\S)([\\s\\S]*?\\S)\\*\\*(?!\\*)/,\n      endAst: /\\*\\*(?!\\*)/g,\n      endUnd: /__(?!_)/g\n    },\n    em: {\n      start: /^_|\\*/,\n      middle: /^()\\*(?=\\S)([\\s\\S]*?\\S)\\*(?!\\*)|^_(?=\\S)([\\s\\S]*?\\S)_(?!_)/,\n      endAst: /\\*(?!\\*)/g,\n      endUnd: /_(?!_)/g\n    },\n    link: edit(/^!?\\[(label)\\]\\((.*?)\\)/).replace('label', inline$1._label).getRegex(),\n    reflink: edit(/^!?\\[(label)\\]\\s*\\[([^\\]]*)\\]/).replace('label', inline$1._label).getRegex()\n  });\n  /**\n   * GFM Inline Grammar\n   */\n\n  inline$1.gfm = merge$1({}, inline$1.normal, {\n    escape: edit(inline$1.escape).replace('])', '~|])').getRegex(),\n    _extended_email: /[A-Za-z0-9._+-]+(@)[a-zA-Z0-9-_]+(?:\\.[a-zA-Z0-9-_]*[a-zA-Z0-9])+(?![-_])/,\n    url: /^((?:ftp|https?):\\/\\/|www\\.)(?:[a-zA-Z0-9\\-]+\\.?)+[^\\s<]*|^email/,\n    _backpedal: /(?:[^?!.,:;*_~()&]+|\\([^)]*\\)|&(?![a-zA-Z0-9]+;$)|[?!.,:;*_~)]+(?!$))+/,\n    del: /^(~~?)(?=[^\\s~])([\\s\\S]*?[^\\s~])\\1(?=[^~]|$)/,\n    text: /^([`~]+|[^`~])(?:(?= {2,}\\n)|(?=[a-zA-Z0-9.!#$%&'*+\\/=?_`{\\|}~-]+@)|[\\s\\S]*?(?:(?=[\\\\<!\\[`*~_]|\\b_|https?:\\/\\/|ftp:\\/\\/|www\\.|$)|[^ ](?= {2,}\\n)|[^a-zA-Z0-9.!#$%&'*+\\/=?_`{\\|}~-](?=[a-zA-Z0-9.!#$%&'*+\\/=?_`{\\|}~-]+@)))/\n  });\n  inline$1.gfm.url = edit(inline$1.gfm.url, 'i').replace('email', inline$1.gfm._extended_email).getRegex();\n  /**\n   * GFM + Line Breaks Inline Grammar\n   */\n\n  inline$1.breaks = merge$1({}, inline$1.gfm, {\n    br: edit(inline$1.br).replace('{2,}', '*').getRegex(),\n    text: edit(inline$1.gfm.text).replace('\\\\b_', '\\\\b_| {2,}\\\\n').replace(/\\{2,\\}/g, '*').getRegex()\n  });\n  var rules = {\n    block: block$1,\n    inline: inline$1\n  };\n\n  var Tokenizer$1 = Tokenizer_1;\n  var defaults$3 = defaults$5.exports.defaults;\n  var block = rules.block,\n      inline = rules.inline;\n  var repeatString = helpers.repeatString;\n  /**\n   * smartypants text replacement\n   */\n\n  function smartypants(text) {\n    return text // em-dashes\n    .replace(/---/g, \"\\u2014\") // en-dashes\n    .replace(/--/g, \"\\u2013\") // opening singles\n    .replace(/(^|[-\\u2014/(\\[{\"\\s])'/g, \"$1\\u2018\") // closing singles & apostrophes\n    .replace(/'/g, \"\\u2019\") // opening doubles\n    .replace(/(^|[-\\u2014/(\\[{\\u2018\\s])\"/g, \"$1\\u201C\") // closing doubles\n    .replace(/\"/g, \"\\u201D\") // ellipses\n    .replace(/\\.{3}/g, \"\\u2026\");\n  }\n  /**\n   * mangle email addresses\n   */\n\n\n  function mangle(text) {\n    var out = '',\n        i,\n        ch;\n    var l = text.length;\n\n    for (i = 0; i < l; i++) {\n      ch = text.charCodeAt(i);\n\n      if (Math.random() > 0.5) {\n        ch = 'x' + ch.toString(16);\n      }\n\n      out += '&#' + ch + ';';\n    }\n\n    return out;\n  }\n  /**\n   * Block Lexer\n   */\n\n\n  var Lexer_1 = /*#__PURE__*/function () {\n    function Lexer(options) {\n      this.tokens = [];\n      this.tokens.links = Object.create(null);\n      this.options = options || defaults$3;\n      this.options.tokenizer = this.options.tokenizer || new Tokenizer$1();\n      this.tokenizer = this.options.tokenizer;\n      this.tokenizer.options = this.options;\n      this.tokenizer.lexer = this;\n      this.inlineQueue = [];\n      this.state = {\n        inLink: false,\n        inRawBlock: false,\n        top: true\n      };\n      var rules = {\n        block: block.normal,\n        inline: inline.normal\n      };\n\n      if (this.options.pedantic) {\n        rules.block = block.pedantic;\n        rules.inline = inline.pedantic;\n      } else if (this.options.gfm) {\n        rules.block = block.gfm;\n\n        if (this.options.breaks) {\n          rules.inline = inline.breaks;\n        } else {\n          rules.inline = inline.gfm;\n        }\n      }\n\n      this.tokenizer.rules = rules;\n    }\n    /**\n     * Expose Rules\n     */\n\n\n    /**\n     * Static Lex Method\n     */\n    Lexer.lex = function lex(src, options) {\n      var lexer = new Lexer(options);\n      return lexer.lex(src);\n    }\n    /**\n     * Static Lex Inline Method\n     */\n    ;\n\n    Lexer.lexInline = function lexInline(src, options) {\n      var lexer = new Lexer(options);\n      return lexer.inlineTokens(src);\n    }\n    /**\n     * Preprocessing\n     */\n    ;\n\n    var _proto = Lexer.prototype;\n\n    _proto.lex = function lex(src) {\n      src = src.replace(/\\r\\n|\\r/g, '\\n').replace(/\\t/g, '    ');\n      this.blockTokens(src, this.tokens);\n      var next;\n\n      while (next = this.inlineQueue.shift()) {\n        this.inlineTokens(next.src, next.tokens);\n      }\n\n      return this.tokens;\n    }\n    /**\n     * Lexing\n     */\n    ;\n\n    _proto.blockTokens = function blockTokens(src, tokens) {\n      var _this = this;\n\n      if (tokens === void 0) {\n        tokens = [];\n      }\n\n      if (this.options.pedantic) {\n        src = src.replace(/^ +$/gm, '');\n      }\n\n      var token, lastToken, cutSrc, lastParagraphClipped;\n\n      while (src) {\n        if (this.options.extensions && this.options.extensions.block && this.options.extensions.block.some(function (extTokenizer) {\n          if (token = extTokenizer.call({\n            lexer: _this\n          }, src, tokens)) {\n            src = src.substring(token.raw.length);\n            tokens.push(token);\n            return true;\n          }\n\n          return false;\n        })) {\n          continue;\n        } // newline\n\n\n        if (token = this.tokenizer.space(src)) {\n          src = src.substring(token.raw.length);\n\n          if (token.type) {\n            tokens.push(token);\n          }\n\n          continue;\n        } // code\n\n\n        if (token = this.tokenizer.code(src)) {\n          src = src.substring(token.raw.length);\n          lastToken = tokens[tokens.length - 1]; // An indented code block cannot interrupt a paragraph.\n\n          if (lastToken && (lastToken.type === 'paragraph' || lastToken.type === 'text')) {\n            lastToken.raw += '\\n' + token.raw;\n            lastToken.text += '\\n' + token.text;\n            this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;\n          } else {\n            tokens.push(token);\n          }\n\n          continue;\n        } // fences\n\n\n        if (token = this.tokenizer.fences(src)) {\n          src = src.substring(token.raw.length);\n          tokens.push(token);\n          continue;\n        } // heading\n\n\n        if (token = this.tokenizer.heading(src)) {\n          src = src.substring(token.raw.length);\n          tokens.push(token);\n          continue;\n        } // hr\n\n\n        if (token = this.tokenizer.hr(src)) {\n          src = src.substring(token.raw.length);\n          tokens.push(token);\n          continue;\n        } // blockquote\n\n\n        if (token = this.tokenizer.blockquote(src)) {\n          src = src.substring(token.raw.length);\n          tokens.push(token);\n          continue;\n        } // list\n\n\n        if (token = this.tokenizer.list(src)) {\n          src = src.substring(token.raw.length);\n          tokens.push(token);\n          continue;\n        } // html\n\n\n        if (token = this.tokenizer.html(src)) {\n          src = src.substring(token.raw.length);\n          tokens.push(token);\n          continue;\n        } // def\n\n\n        if (token = this.tokenizer.def(src)) {\n          src = src.substring(token.raw.length);\n          lastToken = tokens[tokens.length - 1];\n\n          if (lastToken && (lastToken.type === 'paragraph' || lastToken.type === 'text')) {\n            lastToken.raw += '\\n' + token.raw;\n            lastToken.text += '\\n' + token.raw;\n            this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;\n          } else if (!this.tokens.links[token.tag]) {\n            this.tokens.links[token.tag] = {\n              href: token.href,\n              title: token.title\n            };\n          }\n\n          continue;\n        } // table (gfm)\n\n\n        if (token = this.tokenizer.table(src)) {\n          src = src.substring(token.raw.length);\n          tokens.push(token);\n          continue;\n        } // lheading\n\n\n        if (token = this.tokenizer.lheading(src)) {\n          src = src.substring(token.raw.length);\n          tokens.push(token);\n          continue;\n        } // top-level paragraph\n        // prevent paragraph consuming extensions by clipping 'src' to extension start\n\n\n        cutSrc = src;\n\n        if (this.options.extensions && this.options.extensions.startBlock) {\n          (function () {\n            var startIndex = Infinity;\n            var tempSrc = src.slice(1);\n            var tempStart = void 0;\n\n            _this.options.extensions.startBlock.forEach(function (getStartIndex) {\n              tempStart = getStartIndex.call({\n                lexer: this\n              }, tempSrc);\n\n              if (typeof tempStart === 'number' && tempStart >= 0) {\n                startIndex = Math.min(startIndex, tempStart);\n              }\n            });\n\n            if (startIndex < Infinity && startIndex >= 0) {\n              cutSrc = src.substring(0, startIndex + 1);\n            }\n          })();\n        }\n\n        if (this.state.top && (token = this.tokenizer.paragraph(cutSrc))) {\n          lastToken = tokens[tokens.length - 1];\n\n          if (lastParagraphClipped && lastToken.type === 'paragraph') {\n            lastToken.raw += '\\n' + token.raw;\n            lastToken.text += '\\n' + token.text;\n            this.inlineQueue.pop();\n            this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;\n          } else {\n            tokens.push(token);\n          }\n\n          lastParagraphClipped = cutSrc.length !== src.length;\n          src = src.substring(token.raw.length);\n          continue;\n        } // text\n\n\n        if (token = this.tokenizer.text(src)) {\n          src = src.substring(token.raw.length);\n          lastToken = tokens[tokens.length - 1];\n\n          if (lastToken && lastToken.type === 'text') {\n            lastToken.raw += '\\n' + token.raw;\n            lastToken.text += '\\n' + token.text;\n            this.inlineQueue.pop();\n            this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;\n          } else {\n            tokens.push(token);\n          }\n\n          continue;\n        }\n\n        if (src) {\n          var errMsg = 'Infinite loop on byte: ' + src.charCodeAt(0);\n\n          if (this.options.silent) {\n            console.error(errMsg);\n            break;\n          } else {\n            throw new Error(errMsg);\n          }\n        }\n      }\n\n      this.state.top = true;\n      return tokens;\n    };\n\n    _proto.inline = function inline(src, tokens) {\n      this.inlineQueue.push({\n        src: src,\n        tokens: tokens\n      });\n    }\n    /**\n     * Lexing/Compiling\n     */\n    ;\n\n    _proto.inlineTokens = function inlineTokens(src, tokens) {\n      var _this2 = this;\n\n      if (tokens === void 0) {\n        tokens = [];\n      }\n\n      var token, lastToken, cutSrc; // String with links masked to avoid interference with em and strong\n\n      var maskedSrc = src;\n      var match;\n      var keepPrevChar, prevChar; // Mask out reflinks\n\n      if (this.tokens.links) {\n        var links = Object.keys(this.tokens.links);\n\n        if (links.length > 0) {\n          while ((match = this.tokenizer.rules.inline.reflinkSearch.exec(maskedSrc)) != null) {\n            if (links.includes(match[0].slice(match[0].lastIndexOf('[') + 1, -1))) {\n              maskedSrc = maskedSrc.slice(0, match.index) + '[' + repeatString('a', match[0].length - 2) + ']' + maskedSrc.slice(this.tokenizer.rules.inline.reflinkSearch.lastIndex);\n            }\n          }\n        }\n      } // Mask out other blocks\n\n\n      while ((match = this.tokenizer.rules.inline.blockSkip.exec(maskedSrc)) != null) {\n        maskedSrc = maskedSrc.slice(0, match.index) + '[' + repeatString('a', match[0].length - 2) + ']' + maskedSrc.slice(this.tokenizer.rules.inline.blockSkip.lastIndex);\n      } // Mask out escaped em & strong delimiters\n\n\n      while ((match = this.tokenizer.rules.inline.escapedEmSt.exec(maskedSrc)) != null) {\n        maskedSrc = maskedSrc.slice(0, match.index) + '++' + maskedSrc.slice(this.tokenizer.rules.inline.escapedEmSt.lastIndex);\n      }\n\n      while (src) {\n        if (!keepPrevChar) {\n          prevChar = '';\n        }\n\n        keepPrevChar = false; // extensions\n\n        if (this.options.extensions && this.options.extensions.inline && this.options.extensions.inline.some(function (extTokenizer) {\n          if (token = extTokenizer.call({\n            lexer: _this2\n          }, src, tokens)) {\n            src = src.substring(token.raw.length);\n            tokens.push(token);\n            return true;\n          }\n\n          return false;\n        })) {\n          continue;\n        } // escape\n\n\n        if (token = this.tokenizer.escape(src)) {\n          src = src.substring(token.raw.length);\n          tokens.push(token);\n          continue;\n        } // tag\n\n\n        if (token = this.tokenizer.tag(src)) {\n          src = src.substring(token.raw.length);\n          lastToken = tokens[tokens.length - 1];\n\n          if (lastToken && token.type === 'text' && lastToken.type === 'text') {\n            lastToken.raw += token.raw;\n            lastToken.text += token.text;\n          } else {\n            tokens.push(token);\n          }\n\n          continue;\n        } // link\n\n\n        if (token = this.tokenizer.link(src)) {\n          src = src.substring(token.raw.length);\n          tokens.push(token);\n          continue;\n        } // reflink, nolink\n\n\n        if (token = this.tokenizer.reflink(src, this.tokens.links)) {\n          src = src.substring(token.raw.length);\n          lastToken = tokens[tokens.length - 1];\n\n          if (lastToken && token.type === 'text' && lastToken.type === 'text') {\n            lastToken.raw += token.raw;\n            lastToken.text += token.text;\n          } else {\n            tokens.push(token);\n          }\n\n          continue;\n        } // em & strong\n\n\n        if (token = this.tokenizer.emStrong(src, maskedSrc, prevChar)) {\n          src = src.substring(token.raw.length);\n          tokens.push(token);\n          continue;\n        } // code\n\n\n        if (token = this.tokenizer.codespan(src)) {\n          src = src.substring(token.raw.length);\n          tokens.push(token);\n          continue;\n        } // br\n\n\n        if (token = this.tokenizer.br(src)) {\n          src = src.substring(token.raw.length);\n          tokens.push(token);\n          continue;\n        } // del (gfm)\n\n\n        if (token = this.tokenizer.del(src)) {\n          src = src.substring(token.raw.length);\n          tokens.push(token);\n          continue;\n        } // autolink\n\n\n        if (token = this.tokenizer.autolink(src, mangle)) {\n          src = src.substring(token.raw.length);\n          tokens.push(token);\n          continue;\n        } // url (gfm)\n\n\n        if (!this.state.inLink && (token = this.tokenizer.url(src, mangle))) {\n          src = src.substring(token.raw.length);\n          tokens.push(token);\n          continue;\n        } // text\n        // prevent inlineText consuming extensions by clipping 'src' to extension start\n\n\n        cutSrc = src;\n\n        if (this.options.extensions && this.options.extensions.startInline) {\n          (function () {\n            var startIndex = Infinity;\n            var tempSrc = src.slice(1);\n            var tempStart = void 0;\n\n            _this2.options.extensions.startInline.forEach(function (getStartIndex) {\n              tempStart = getStartIndex.call({\n                lexer: this\n              }, tempSrc);\n\n              if (typeof tempStart === 'number' && tempStart >= 0) {\n                startIndex = Math.min(startIndex, tempStart);\n              }\n            });\n\n            if (startIndex < Infinity && startIndex >= 0) {\n              cutSrc = src.substring(0, startIndex + 1);\n            }\n          })();\n        }\n\n        if (token = this.tokenizer.inlineText(cutSrc, smartypants)) {\n          src = src.substring(token.raw.length);\n\n          if (token.raw.slice(-1) !== '_') {\n            // Track prevChar before string of ____ started\n            prevChar = token.raw.slice(-1);\n          }\n\n          keepPrevChar = true;\n          lastToken = tokens[tokens.length - 1];\n\n          if (lastToken && lastToken.type === 'text') {\n            lastToken.raw += token.raw;\n            lastToken.text += token.text;\n          } else {\n            tokens.push(token);\n          }\n\n          continue;\n        }\n\n        if (src) {\n          var errMsg = 'Infinite loop on byte: ' + src.charCodeAt(0);\n\n          if (this.options.silent) {\n            console.error(errMsg);\n            break;\n          } else {\n            throw new Error(errMsg);\n          }\n        }\n      }\n\n      return tokens;\n    };\n\n    _createClass(Lexer, null, [{\n      key: \"rules\",\n      get: function get() {\n        return {\n          block: block,\n          inline: inline\n        };\n      }\n    }]);\n\n    return Lexer;\n  }();\n\n  var defaults$2 = defaults$5.exports.defaults;\n  var cleanUrl = helpers.cleanUrl,\n      escape$1 = helpers.escape;\n  /**\n   * Renderer\n   */\n\n  var Renderer_1 = /*#__PURE__*/function () {\n    function Renderer(options) {\n      this.options = options || defaults$2;\n    }\n\n    var _proto = Renderer.prototype;\n\n    _proto.code = function code(_code, infostring, escaped) {\n      var lang = (infostring || '').match(/\\S*/)[0];\n\n      if (this.options.highlight) {\n        var out = this.options.highlight(_code, lang);\n\n        if (out != null && out !== _code) {\n          escaped = true;\n          _code = out;\n        }\n      }\n\n      _code = _code.replace(/\\n$/, '') + '\\n';\n\n      if (!lang) {\n        return '<pre><code>' + (escaped ? _code : escape$1(_code, true)) + '</code></pre>\\n';\n      }\n\n      return '<pre><code class=\"' + this.options.langPrefix + escape$1(lang, true) + '\">' + (escaped ? _code : escape$1(_code, true)) + '</code></pre>\\n';\n    };\n\n    _proto.blockquote = function blockquote(quote) {\n      return '<blockquote>\\n' + quote + '</blockquote>\\n';\n    };\n\n    _proto.html = function html(_html) {\n      return _html;\n    };\n\n    _proto.heading = function heading(text, level, raw, slugger) {\n      if (this.options.headerIds) {\n        return '<h' + level + ' id=\"' + this.options.headerPrefix + slugger.slug(raw) + '\">' + text + '</h' + level + '>\\n';\n      } // ignore IDs\n\n\n      return '<h' + level + '>' + text + '</h' + level + '>\\n';\n    };\n\n    _proto.hr = function hr() {\n      return this.options.xhtml ? '<hr/>\\n' : '<hr>\\n';\n    };\n\n    _proto.list = function list(body, ordered, start) {\n      var type = ordered ? 'ol' : 'ul',\n          startatt = ordered && start !== 1 ? ' start=\"' + start + '\"' : '';\n      return '<' + type + startatt + '>\\n' + body + '</' + type + '>\\n';\n    };\n\n    _proto.listitem = function listitem(text) {\n      return '<li>' + text + '</li>\\n';\n    };\n\n    _proto.checkbox = function checkbox(checked) {\n      return '<input ' + (checked ? 'checked=\"\" ' : '') + 'disabled=\"\" type=\"checkbox\"' + (this.options.xhtml ? ' /' : '') + '> ';\n    };\n\n    _proto.paragraph = function paragraph(text) {\n      return '<p>' + text + '</p>\\n';\n    };\n\n    _proto.table = function table(header, body) {\n      if (body) body = '<tbody>' + body + '</tbody>';\n      return '<table>\\n' + '<thead>\\n' + header + '</thead>\\n' + body + '</table>\\n';\n    };\n\n    _proto.tablerow = function tablerow(content) {\n      return '<tr>\\n' + content + '</tr>\\n';\n    };\n\n    _proto.tablecell = function tablecell(content, flags) {\n      var type = flags.header ? 'th' : 'td';\n      var tag = flags.align ? '<' + type + ' align=\"' + flags.align + '\">' : '<' + type + '>';\n      return tag + content + '</' + type + '>\\n';\n    } // span level renderer\n    ;\n\n    _proto.strong = function strong(text) {\n      return '<strong>' + text + '</strong>';\n    };\n\n    _proto.em = function em(text) {\n      return '<em>' + text + '</em>';\n    };\n\n    _proto.codespan = function codespan(text) {\n      return '<code>' + text + '</code>';\n    };\n\n    _proto.br = function br() {\n      return this.options.xhtml ? '<br/>' : '<br>';\n    };\n\n    _proto.del = function del(text) {\n      return '<del>' + text + '</del>';\n    };\n\n    _proto.link = function link(href, title, text) {\n      href = cleanUrl(this.options.sanitize, this.options.baseUrl, href);\n\n      if (href === null) {\n        return text;\n      }\n\n      var out = '<a href=\"' + escape$1(href) + '\"';\n\n      if (title) {\n        out += ' title=\"' + title + '\"';\n      }\n\n      out += '>' + text + '</a>';\n      return out;\n    };\n\n    _proto.image = function image(href, title, text) {\n      href = cleanUrl(this.options.sanitize, this.options.baseUrl, href);\n\n      if (href === null) {\n        return text;\n      }\n\n      var out = '<img src=\"' + href + '\" alt=\"' + text + '\"';\n\n      if (title) {\n        out += ' title=\"' + title + '\"';\n      }\n\n      out += this.options.xhtml ? '/>' : '>';\n      return out;\n    };\n\n    _proto.text = function text(_text) {\n      return _text;\n    };\n\n    return Renderer;\n  }();\n\n  /**\n   * TextRenderer\n   * returns only the textual part of the token\n   */\n\n  var TextRenderer_1 = /*#__PURE__*/function () {\n    function TextRenderer() {}\n\n    var _proto = TextRenderer.prototype;\n\n    // no need for block level renderers\n    _proto.strong = function strong(text) {\n      return text;\n    };\n\n    _proto.em = function em(text) {\n      return text;\n    };\n\n    _proto.codespan = function codespan(text) {\n      return text;\n    };\n\n    _proto.del = function del(text) {\n      return text;\n    };\n\n    _proto.html = function html(text) {\n      return text;\n    };\n\n    _proto.text = function text(_text) {\n      return _text;\n    };\n\n    _proto.link = function link(href, title, text) {\n      return '' + text;\n    };\n\n    _proto.image = function image(href, title, text) {\n      return '' + text;\n    };\n\n    _proto.br = function br() {\n      return '';\n    };\n\n    return TextRenderer;\n  }();\n\n  /**\n   * Slugger generates header id\n   */\n\n  var Slugger_1 = /*#__PURE__*/function () {\n    function Slugger() {\n      this.seen = {};\n    }\n\n    var _proto = Slugger.prototype;\n\n    _proto.serialize = function serialize(value) {\n      return value.toLowerCase().trim() // remove html tags\n      .replace(/<[!\\/a-z].*?>/ig, '') // remove unwanted chars\n      .replace(/[\\u2000-\\u206F\\u2E00-\\u2E7F\\\\'!\"#$%&()*+,./:;<=>?@[\\]^`{|}~]/g, '').replace(/\\s/g, '-');\n    }\n    /**\n     * Finds the next safe (unique) slug to use\n     */\n    ;\n\n    _proto.getNextSafeSlug = function getNextSafeSlug(originalSlug, isDryRun) {\n      var slug = originalSlug;\n      var occurenceAccumulator = 0;\n\n      if (this.seen.hasOwnProperty(slug)) {\n        occurenceAccumulator = this.seen[originalSlug];\n\n        do {\n          occurenceAccumulator++;\n          slug = originalSlug + '-' + occurenceAccumulator;\n        } while (this.seen.hasOwnProperty(slug));\n      }\n\n      if (!isDryRun) {\n        this.seen[originalSlug] = occurenceAccumulator;\n        this.seen[slug] = 0;\n      }\n\n      return slug;\n    }\n    /**\n     * Convert string to unique id\n     * @param {object} options\n     * @param {boolean} options.dryrun Generates the next unique slug without updating the internal accumulator.\n     */\n    ;\n\n    _proto.slug = function slug(value, options) {\n      if (options === void 0) {\n        options = {};\n      }\n\n      var slug = this.serialize(value);\n      return this.getNextSafeSlug(slug, options.dryrun);\n    };\n\n    return Slugger;\n  }();\n\n  var Renderer$1 = Renderer_1;\n  var TextRenderer$1 = TextRenderer_1;\n  var Slugger$1 = Slugger_1;\n  var defaults$1 = defaults$5.exports.defaults;\n  var unescape = helpers.unescape;\n  /**\n   * Parsing & Compiling\n   */\n\n  var Parser_1 = /*#__PURE__*/function () {\n    function Parser(options) {\n      this.options = options || defaults$1;\n      this.options.renderer = this.options.renderer || new Renderer$1();\n      this.renderer = this.options.renderer;\n      this.renderer.options = this.options;\n      this.textRenderer = new TextRenderer$1();\n      this.slugger = new Slugger$1();\n    }\n    /**\n     * Static Parse Method\n     */\n\n\n    Parser.parse = function parse(tokens, options) {\n      var parser = new Parser(options);\n      return parser.parse(tokens);\n    }\n    /**\n     * Static Parse Inline Method\n     */\n    ;\n\n    Parser.parseInline = function parseInline(tokens, options) {\n      var parser = new Parser(options);\n      return parser.parseInline(tokens);\n    }\n    /**\n     * Parse Loop\n     */\n    ;\n\n    var _proto = Parser.prototype;\n\n    _proto.parse = function parse(tokens, top) {\n      if (top === void 0) {\n        top = true;\n      }\n\n      var out = '',\n          i,\n          j,\n          k,\n          l2,\n          l3,\n          row,\n          cell,\n          header,\n          body,\n          token,\n          ordered,\n          start,\n          loose,\n          itemBody,\n          item,\n          checked,\n          task,\n          checkbox,\n          ret;\n      var l = tokens.length;\n\n      for (i = 0; i < l; i++) {\n        token = tokens[i]; // Run any renderer extensions\n\n        if (this.options.extensions && this.options.extensions.renderers && this.options.extensions.renderers[token.type]) {\n          ret = this.options.extensions.renderers[token.type].call({\n            parser: this\n          }, token);\n\n          if (ret !== false || !['space', 'hr', 'heading', 'code', 'table', 'blockquote', 'list', 'html', 'paragraph', 'text'].includes(token.type)) {\n            out += ret || '';\n            continue;\n          }\n        }\n\n        switch (token.type) {\n          case 'space':\n            {\n              continue;\n            }\n\n          case 'hr':\n            {\n              out += this.renderer.hr();\n              continue;\n            }\n\n          case 'heading':\n            {\n              out += this.renderer.heading(this.parseInline(token.tokens), token.depth, unescape(this.parseInline(token.tokens, this.textRenderer)), this.slugger);\n              continue;\n            }\n\n          case 'code':\n            {\n              out += this.renderer.code(token.text, token.lang, token.escaped);\n              continue;\n            }\n\n          case 'table':\n            {\n              header = ''; // header\n\n              cell = '';\n              l2 = token.header.length;\n\n              for (j = 0; j < l2; j++) {\n                cell += this.renderer.tablecell(this.parseInline(token.header[j].tokens), {\n                  header: true,\n                  align: token.align[j]\n                });\n              }\n\n              header += this.renderer.tablerow(cell);\n              body = '';\n              l2 = token.rows.length;\n\n              for (j = 0; j < l2; j++) {\n                row = token.rows[j];\n                cell = '';\n                l3 = row.length;\n\n                for (k = 0; k < l3; k++) {\n                  cell += this.renderer.tablecell(this.parseInline(row[k].tokens), {\n                    header: false,\n                    align: token.align[k]\n                  });\n                }\n\n                body += this.renderer.tablerow(cell);\n              }\n\n              out += this.renderer.table(header, body);\n              continue;\n            }\n\n          case 'blockquote':\n            {\n              body = this.parse(token.tokens);\n              out += this.renderer.blockquote(body);\n              continue;\n            }\n\n          case 'list':\n            {\n              ordered = token.ordered;\n              start = token.start;\n              loose = token.loose;\n              l2 = token.items.length;\n              body = '';\n\n              for (j = 0; j < l2; j++) {\n                item = token.items[j];\n                checked = item.checked;\n                task = item.task;\n                itemBody = '';\n\n                if (item.task) {\n                  checkbox = this.renderer.checkbox(checked);\n\n                  if (loose) {\n                    if (item.tokens.length > 0 && item.tokens[0].type === 'paragraph') {\n                      item.tokens[0].text = checkbox + ' ' + item.tokens[0].text;\n\n                      if (item.tokens[0].tokens && item.tokens[0].tokens.length > 0 && item.tokens[0].tokens[0].type === 'text') {\n                        item.tokens[0].tokens[0].text = checkbox + ' ' + item.tokens[0].tokens[0].text;\n                      }\n                    } else {\n                      item.tokens.unshift({\n                        type: 'text',\n                        text: checkbox\n                      });\n                    }\n                  } else {\n                    itemBody += checkbox;\n                  }\n                }\n\n                itemBody += this.parse(item.tokens, loose);\n                body += this.renderer.listitem(itemBody, task, checked);\n              }\n\n              out += this.renderer.list(body, ordered, start);\n              continue;\n            }\n\n          case 'html':\n            {\n              // TODO parse inline content if parameter markdown=1\n              out += this.renderer.html(token.text);\n              continue;\n            }\n\n          case 'paragraph':\n            {\n              out += this.renderer.paragraph(this.parseInline(token.tokens));\n              continue;\n            }\n\n          case 'text':\n            {\n              body = token.tokens ? this.parseInline(token.tokens) : token.text;\n\n              while (i + 1 < l && tokens[i + 1].type === 'text') {\n                token = tokens[++i];\n                body += '\\n' + (token.tokens ? this.parseInline(token.tokens) : token.text);\n              }\n\n              out += top ? this.renderer.paragraph(body) : body;\n              continue;\n            }\n\n          default:\n            {\n              var errMsg = 'Token with \"' + token.type + '\" type was not found.';\n\n              if (this.options.silent) {\n                console.error(errMsg);\n                return;\n              } else {\n                throw new Error(errMsg);\n              }\n            }\n        }\n      }\n\n      return out;\n    }\n    /**\n     * Parse Inline Tokens\n     */\n    ;\n\n    _proto.parseInline = function parseInline(tokens, renderer) {\n      renderer = renderer || this.renderer;\n      var out = '',\n          i,\n          token,\n          ret;\n      var l = tokens.length;\n\n      for (i = 0; i < l; i++) {\n        token = tokens[i]; // Run any renderer extensions\n\n        if (this.options.extensions && this.options.extensions.renderers && this.options.extensions.renderers[token.type]) {\n          ret = this.options.extensions.renderers[token.type].call({\n            parser: this\n          }, token);\n\n          if (ret !== false || !['escape', 'html', 'link', 'image', 'strong', 'em', 'codespan', 'br', 'del', 'text'].includes(token.type)) {\n            out += ret || '';\n            continue;\n          }\n        }\n\n        switch (token.type) {\n          case 'escape':\n            {\n              out += renderer.text(token.text);\n              break;\n            }\n\n          case 'html':\n            {\n              out += renderer.html(token.text);\n              break;\n            }\n\n          case 'link':\n            {\n              out += renderer.link(token.href, token.title, this.parseInline(token.tokens, renderer));\n              break;\n            }\n\n          case 'image':\n            {\n              out += renderer.image(token.href, token.title, token.text);\n              break;\n            }\n\n          case 'strong':\n            {\n              out += renderer.strong(this.parseInline(token.tokens, renderer));\n              break;\n            }\n\n          case 'em':\n            {\n              out += renderer.em(this.parseInline(token.tokens, renderer));\n              break;\n            }\n\n          case 'codespan':\n            {\n              out += renderer.codespan(token.text);\n              break;\n            }\n\n          case 'br':\n            {\n              out += renderer.br();\n              break;\n            }\n\n          case 'del':\n            {\n              out += renderer.del(this.parseInline(token.tokens, renderer));\n              break;\n            }\n\n          case 'text':\n            {\n              out += renderer.text(token.text);\n              break;\n            }\n\n          default:\n            {\n              var errMsg = 'Token with \"' + token.type + '\" type was not found.';\n\n              if (this.options.silent) {\n                console.error(errMsg);\n                return;\n              } else {\n                throw new Error(errMsg);\n              }\n            }\n        }\n      }\n\n      return out;\n    };\n\n    return Parser;\n  }();\n\n  var Lexer = Lexer_1;\n  var Parser = Parser_1;\n  var Tokenizer = Tokenizer_1;\n  var Renderer = Renderer_1;\n  var TextRenderer = TextRenderer_1;\n  var Slugger = Slugger_1;\n  var merge = helpers.merge,\n      checkSanitizeDeprecation = helpers.checkSanitizeDeprecation,\n      escape = helpers.escape;\n  var getDefaults = defaults$5.exports.getDefaults,\n      changeDefaults = defaults$5.exports.changeDefaults,\n      defaults = defaults$5.exports.defaults;\n  /**\n   * Marked\n   */\n\n  function marked(src, opt, callback) {\n    // throw error in case of non string input\n    if (typeof src === 'undefined' || src === null) {\n      throw new Error('marked(): input parameter is undefined or null');\n    }\n\n    if (typeof src !== 'string') {\n      throw new Error('marked(): input parameter is of type ' + Object.prototype.toString.call(src) + ', string expected');\n    }\n\n    if (typeof opt === 'function') {\n      callback = opt;\n      opt = null;\n    }\n\n    opt = merge({}, marked.defaults, opt || {});\n    checkSanitizeDeprecation(opt);\n\n    if (callback) {\n      var highlight = opt.highlight;\n      var tokens;\n\n      try {\n        tokens = Lexer.lex(src, opt);\n      } catch (e) {\n        return callback(e);\n      }\n\n      var done = function done(err) {\n        var out;\n\n        if (!err) {\n          try {\n            if (opt.walkTokens) {\n              marked.walkTokens(tokens, opt.walkTokens);\n            }\n\n            out = Parser.parse(tokens, opt);\n          } catch (e) {\n            err = e;\n          }\n        }\n\n        opt.highlight = highlight;\n        return err ? callback(err) : callback(null, out);\n      };\n\n      if (!highlight || highlight.length < 3) {\n        return done();\n      }\n\n      delete opt.highlight;\n      if (!tokens.length) return done();\n      var pending = 0;\n      marked.walkTokens(tokens, function (token) {\n        if (token.type === 'code') {\n          pending++;\n          setTimeout(function () {\n            highlight(token.text, token.lang, function (err, code) {\n              if (err) {\n                return done(err);\n              }\n\n              if (code != null && code !== token.text) {\n                token.text = code;\n                token.escaped = true;\n              }\n\n              pending--;\n\n              if (pending === 0) {\n                done();\n              }\n            });\n          }, 0);\n        }\n      });\n\n      if (pending === 0) {\n        done();\n      }\n\n      return;\n    }\n\n    try {\n      var _tokens = Lexer.lex(src, opt);\n\n      if (opt.walkTokens) {\n        marked.walkTokens(_tokens, opt.walkTokens);\n      }\n\n      return Parser.parse(_tokens, opt);\n    } catch (e) {\n      e.message += '\\nPlease report this to https://github.com/markedjs/marked.';\n\n      if (opt.silent) {\n        return '<p>An error occurred:</p><pre>' + escape(e.message + '', true) + '</pre>';\n      }\n\n      throw e;\n    }\n  }\n  /**\n   * Options\n   */\n\n\n  marked.options = marked.setOptions = function (opt) {\n    merge(marked.defaults, opt);\n    changeDefaults(marked.defaults);\n    return marked;\n  };\n\n  marked.getDefaults = getDefaults;\n  marked.defaults = defaults;\n  /**\n   * Use Extension\n   */\n\n  marked.use = function () {\n    var _this = this;\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    var opts = merge.apply(void 0, [{}].concat(args));\n    var extensions = marked.defaults.extensions || {\n      renderers: {},\n      childTokens: {}\n    };\n    var hasExtensions;\n    args.forEach(function (pack) {\n      // ==-- Parse \"addon\" extensions --== //\n      if (pack.extensions) {\n        hasExtensions = true;\n        pack.extensions.forEach(function (ext) {\n          if (!ext.name) {\n            throw new Error('extension name required');\n          }\n\n          if (ext.renderer) {\n            // Renderer extensions\n            var prevRenderer = extensions.renderers ? extensions.renderers[ext.name] : null;\n\n            if (prevRenderer) {\n              // Replace extension with func to run new extension but fall back if false\n              extensions.renderers[ext.name] = function () {\n                for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n                  args[_key2] = arguments[_key2];\n                }\n\n                var ret = ext.renderer.apply(this, args);\n\n                if (ret === false) {\n                  ret = prevRenderer.apply(this, args);\n                }\n\n                return ret;\n              };\n            } else {\n              extensions.renderers[ext.name] = ext.renderer;\n            }\n          }\n\n          if (ext.tokenizer) {\n            // Tokenizer Extensions\n            if (!ext.level || ext.level !== 'block' && ext.level !== 'inline') {\n              throw new Error(\"extension level must be 'block' or 'inline'\");\n            }\n\n            if (extensions[ext.level]) {\n              extensions[ext.level].unshift(ext.tokenizer);\n            } else {\n              extensions[ext.level] = [ext.tokenizer];\n            }\n\n            if (ext.start) {\n              // Function to check for start of token\n              if (ext.level === 'block') {\n                if (extensions.startBlock) {\n                  extensions.startBlock.push(ext.start);\n                } else {\n                  extensions.startBlock = [ext.start];\n                }\n              } else if (ext.level === 'inline') {\n                if (extensions.startInline) {\n                  extensions.startInline.push(ext.start);\n                } else {\n                  extensions.startInline = [ext.start];\n                }\n              }\n            }\n          }\n\n          if (ext.childTokens) {\n            // Child tokens to be visited by walkTokens\n            extensions.childTokens[ext.name] = ext.childTokens;\n          }\n        });\n      } // ==-- Parse \"overwrite\" extensions --== //\n\n\n      if (pack.renderer) {\n        (function () {\n          var renderer = marked.defaults.renderer || new Renderer();\n\n          var _loop = function _loop(prop) {\n            var prevRenderer = renderer[prop]; // Replace renderer with func to run extension, but fall back if false\n\n            renderer[prop] = function () {\n              for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n                args[_key3] = arguments[_key3];\n              }\n\n              var ret = pack.renderer[prop].apply(renderer, args);\n\n              if (ret === false) {\n                ret = prevRenderer.apply(renderer, args);\n              }\n\n              return ret;\n            };\n          };\n\n          for (var prop in pack.renderer) {\n            _loop(prop);\n          }\n\n          opts.renderer = renderer;\n        })();\n      }\n\n      if (pack.tokenizer) {\n        (function () {\n          var tokenizer = marked.defaults.tokenizer || new Tokenizer();\n\n          var _loop2 = function _loop2(prop) {\n            var prevTokenizer = tokenizer[prop]; // Replace tokenizer with func to run extension, but fall back if false\n\n            tokenizer[prop] = function () {\n              for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n                args[_key4] = arguments[_key4];\n              }\n\n              var ret = pack.tokenizer[prop].apply(tokenizer, args);\n\n              if (ret === false) {\n                ret = prevTokenizer.apply(tokenizer, args);\n              }\n\n              return ret;\n            };\n          };\n\n          for (var prop in pack.tokenizer) {\n            _loop2(prop);\n          }\n\n          opts.tokenizer = tokenizer;\n        })();\n      } // ==-- Parse WalkTokens extensions --== //\n\n\n      if (pack.walkTokens) {\n        var walkTokens = marked.defaults.walkTokens;\n\n        opts.walkTokens = function (token) {\n          pack.walkTokens.call(_this, token);\n\n          if (walkTokens) {\n            walkTokens(token);\n          }\n        };\n      }\n\n      if (hasExtensions) {\n        opts.extensions = extensions;\n      }\n\n      marked.setOptions(opts);\n    });\n  };\n  /**\n   * Run callback for every token\n   */\n\n\n  marked.walkTokens = function (tokens, callback) {\n    var _loop3 = function _loop3() {\n      var token = _step.value;\n      callback(token);\n\n      switch (token.type) {\n        case 'table':\n          {\n            for (var _iterator2 = _createForOfIteratorHelperLoose(token.header), _step2; !(_step2 = _iterator2()).done;) {\n              var cell = _step2.value;\n              marked.walkTokens(cell.tokens, callback);\n            }\n\n            for (var _iterator3 = _createForOfIteratorHelperLoose(token.rows), _step3; !(_step3 = _iterator3()).done;) {\n              var row = _step3.value;\n\n              for (var _iterator4 = _createForOfIteratorHelperLoose(row), _step4; !(_step4 = _iterator4()).done;) {\n                var _cell = _step4.value;\n                marked.walkTokens(_cell.tokens, callback);\n              }\n            }\n\n            break;\n          }\n\n        case 'list':\n          {\n            marked.walkTokens(token.items, callback);\n            break;\n          }\n\n        default:\n          {\n            if (marked.defaults.extensions && marked.defaults.extensions.childTokens && marked.defaults.extensions.childTokens[token.type]) {\n              // Walk any extensions\n              marked.defaults.extensions.childTokens[token.type].forEach(function (childTokens) {\n                marked.walkTokens(token[childTokens], callback);\n              });\n            } else if (token.tokens) {\n              marked.walkTokens(token.tokens, callback);\n            }\n          }\n      }\n    };\n\n    for (var _iterator = _createForOfIteratorHelperLoose(tokens), _step; !(_step = _iterator()).done;) {\n      _loop3();\n    }\n  };\n  /**\n   * Parse Inline\n   */\n\n\n  marked.parseInline = function (src, opt) {\n    // throw error in case of non string input\n    if (typeof src === 'undefined' || src === null) {\n      throw new Error('marked.parseInline(): input parameter is undefined or null');\n    }\n\n    if (typeof src !== 'string') {\n      throw new Error('marked.parseInline(): input parameter is of type ' + Object.prototype.toString.call(src) + ', string expected');\n    }\n\n    opt = merge({}, marked.defaults, opt || {});\n    checkSanitizeDeprecation(opt);\n\n    try {\n      var tokens = Lexer.lexInline(src, opt);\n\n      if (opt.walkTokens) {\n        marked.walkTokens(tokens, opt.walkTokens);\n      }\n\n      return Parser.parseInline(tokens, opt);\n    } catch (e) {\n      e.message += '\\nPlease report this to https://github.com/markedjs/marked.';\n\n      if (opt.silent) {\n        return '<p>An error occurred:</p><pre>' + escape(e.message + '', true) + '</pre>';\n      }\n\n      throw e;\n    }\n  };\n  /**\n   * Expose\n   */\n\n\n  marked.Parser = Parser;\n  marked.parser = Parser.parse;\n  marked.Renderer = Renderer;\n  marked.TextRenderer = TextRenderer;\n  marked.Lexer = Lexer;\n  marked.lexer = Lexer.lex;\n  marked.Tokenizer = Tokenizer;\n  marked.Slugger = Slugger;\n  marked.parse = marked;\n  var marked_1 = marked;\n\n  return marked_1;\n\n}));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esc0NBQXNDLElBQUk7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGtDQUFrQzs7QUFFbEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLElBQUk7O0FBRXBDO0FBQ0E7QUFDQSxVQUFVOzs7QUFHVix3Q0FBd0MsSUFBSSwwREFBMEQ7O0FBRXRHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWiw0Q0FBNEM7O0FBRTVDLGdFQUFnRSx3Q0FBd0M7O0FBRXhHO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsK0NBQStDLGtDQUFrQyxhQUFhLElBQUk7O0FBRWxHLHNCQUFzQixrQkFBa0I7QUFDeEM7O0FBRUE7QUFDQTtBQUNBLHNDQUFzQyxJQUFJLE1BQU0sRUFBRTtBQUNsRCxjQUFjOzs7QUFHZDtBQUNBO0FBQ0E7QUFDQSxjQUFjOzs7QUFHZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjs7O0FBR2hCO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTs7QUFFQTtBQUNBLGNBQWM7OztBQUdkO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZCxpREFBaUQ7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLFlBQVk7OztBQUdaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsVUFBVTs7O0FBR1Y7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DOztBQUVuQyxvQkFBb0IsT0FBTztBQUMzQjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxzQkFBc0IsT0FBTztBQUM3QjtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0EsY0FBYztBQUNkO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxzQkFBc0IsT0FBTztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixZQUFZO0FBQ1o7OztBQUdBOztBQUVBLHNCQUFzQixPQUFPO0FBQzdCO0FBQ0E7QUFDQSxZQUFZOzs7QUFHWjs7QUFFQSxzQkFBc0IsT0FBTztBQUM3Qjs7QUFFQSx3QkFBd0IsZ0JBQWdCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZOzs7QUFHWjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMEJBQTBCLDRDQUE0QyxFQUFFLEdBQUcsR0FBRzs7QUFFOUU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4Qjs7QUFFOUI7O0FBRUE7QUFDQTtBQUNBLGlDQUFpQzs7QUFFakM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7O0FBRUE7QUFDQSx3Q0FBd0M7QUFDeEM7O0FBRUEsNkVBQTZFOztBQUU3RTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7OztBQUdaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZOztBQUVaOztBQUVBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLEVBQUU7QUFDakIsZ0JBQWdCLElBQUksR0FBRyxHQUFHLGdCQUFnQixHQUFHLGlDQUFpQyxJQUFJO0FBQ2xGLFlBQVksSUFBSSxTQUFTLEdBQUcsU0FBUyxHQUFHLFVBQVUsR0FBRztBQUNyRCxpQkFBaUIsSUFBSSxHQUFHLElBQUk7QUFDNUIscUJBQXFCLElBQUk7QUFDekIsZUFBZSxJQUFJO0FBQ25CLGNBQWMsSUFBSTtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLElBQUk7QUFDakI7QUFDQSw0QkFBNEIsSUFBSTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLElBQUk7QUFDcEM7QUFDQSwwR0FBMEcsR0FBRyxTQUFTLEdBQUcsV0FBVyxHQUFHO0FBQ3ZJO0FBQ0E7QUFDQTtBQUNBLCtGQUErRixJQUFJLEVBQUUsS0FBSztBQUMxRyw0QkFBNEIsSUFBSSx5QkFBeUIsSUFBSSxLQUFLLEdBQUcsa0JBQWtCLEdBQUcsaUNBQWlDLElBQUk7QUFDL0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7O0FBRUEsMEJBQTBCO0FBQzFCO0FBQ0EsU0FBUyxJQUFJO0FBQ2I7O0FBRUEsR0FBRztBQUNILDhGQUE4RixJQUFJLEVBQUUsS0FBSyw0QkFBNEIsSUFBSSx1QkFBdUIsRUFBRSw4QkFBOEIsSUFBSSxLQUFLLEdBQUcsa0JBQWtCLEdBQUcsaUNBQWlDLElBQUk7QUFDdFE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwrQkFBK0I7QUFDL0IsaUZBQWlGLEdBQUc7QUFDcEYsZ0VBQWdFLEdBQUc7QUFDbkU7QUFDQSxrQkFBa0IsSUFBSTtBQUN0QjtBQUNBO0FBQ0EsaUdBQWlHLEtBQUssd0VBQXdFLElBQUk7QUFDbEwsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9DQUFvQyxlQUFlLEVBQUU7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7QUFDTDtBQUNBLGFBQWEsR0FBRztBQUNoQjtBQUNBLDZCQUE2QixHQUFHLDhDQUE4QyxHQUFHO0FBQ2pGO0FBQ0EsS0FBSztBQUNMOztBQUVBLDhDQUE4QyxjQUFjLEVBQUU7QUFDOUQsK0dBQStHOztBQUUvRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsZUFBZSxFQUFFO0FBQzlELDZDQUE2QyxLQUFLO0FBQ2xELCtDQUErQyxFQUFFLGtDQUFrQyxLQUFLLDZDQUE2QyxLQUFLO0FBQzFJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBOztBQUVBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUEsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixvQ0FBb0MsVUFBVTtBQUMxRTtBQUNBLGlDQUFpQyxHQUFHLGlDQUFpQyxHQUFHLDZFQUE2RSxHQUFHLCtCQUErQixHQUFHLGdDQUFnQyxHQUFHO0FBQzdOLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw4QkFBOEI7QUFDOUIsb0NBQW9DLEdBQUc7QUFDdkMsMERBQTBELEdBQUcsaUJBQWlCLElBQUk7QUFDbEYsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQSxpQkFBaUIsRUFBRTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxnQkFBZ0IsT0FBTztBQUN2Qjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsMkJBQTJCO0FBQzNCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxVQUFVOzs7QUFHVjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFVBQVU7OztBQUdWO0FBQ0E7QUFDQSxpREFBaUQ7O0FBRWpEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQSxVQUFVOzs7QUFHVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7OztBQUdWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTs7O0FBR1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVOzs7QUFHVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7OztBQUdWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTs7O0FBR1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVOzs7QUFHVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFVBQVU7OztBQUdWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTs7O0FBR1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZTs7QUFFZjtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVOzs7QUFHVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsb0NBQW9DOztBQUVwQztBQUNBO0FBQ0Esa0NBQWtDOztBQUVsQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTs7O0FBR1I7QUFDQTtBQUNBLFFBQVE7OztBQUdSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw4QkFBOEI7O0FBRTlCO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFVBQVU7OztBQUdWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTs7O0FBR1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0EsVUFBVTs7O0FBR1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVOzs7QUFHVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQSxVQUFVOzs7QUFHVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7OztBQUdWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTs7O0FBR1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVOzs7QUFHVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7OztBQUdWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTs7O0FBR1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZTs7QUFFZjtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFROzs7QUFHUjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RCxXQUFXLEVBQUU7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVM7QUFDVCxRQUFROzs7QUFHUjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHlGQUF5Riw4QkFBOEI7QUFDdkg7QUFDQTtBQUNBOztBQUVBLHVGQUF1Riw4QkFBOEI7QUFDckg7O0FBRUEsa0ZBQWtGLDhCQUE4QjtBQUNoSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHlFQUF5RSw0QkFBNEI7QUFDckc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0IsNEJBQTRCO0FBQzlDOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBTTtBQUNOOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9ub2RlX21vZHVsZXMvbWFya2VkL2xpYi9tYXJrZWQuanM/MGU1NCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIG1hcmtlZCAtIGEgbWFya2Rvd24gcGFyc2VyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTEtMjAyMSwgQ2hyaXN0b3BoZXIgSmVmZnJleS4gKE1JVCBMaWNlbnNlZClcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9tYXJrZWRqcy9tYXJrZWRcbiAqL1xuXG4vKipcbiAqIERPIE5PVCBFRElUIFRISVMgRklMRVxuICogVGhlIGNvZGUgaW4gdGhpcyBmaWxlIGlzIGdlbmVyYXRlZCBmcm9tIGZpbGVzIGluIC4vc3JjL1xuICovXG5cbihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG4gIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpIDpcbiAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKGZhY3RvcnkpIDpcbiAgKGdsb2JhbCA9IHR5cGVvZiBnbG9iYWxUaGlzICE9PSAndW5kZWZpbmVkJyA/IGdsb2JhbFRoaXMgOiBnbG9iYWwgfHwgc2VsZiwgZ2xvYmFsLm1hcmtlZCA9IGZhY3RvcnkoKSk7XG59KSh0aGlzLCAoZnVuY3Rpb24gKCkgeyAndXNlIHN0cmljdCc7XG5cbiAgZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07XG4gICAgICBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7XG4gICAgICBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7XG4gICAgICBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHtcbiAgICBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTtcbiAgICBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7XG4gICAgcmV0dXJuIENvbnN0cnVjdG9yO1xuICB9XG5cbiAgZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8sIG1pbkxlbikge1xuICAgIGlmICghbykgcmV0dXJuO1xuICAgIGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7XG4gICAgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpO1xuICAgIGlmIChuID09PSBcIk9iamVjdFwiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7XG4gICAgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIEFycmF5LmZyb20obyk7XG4gICAgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pO1xuICB9XG5cbiAgZnVuY3Rpb24gX2FycmF5TGlrZVRvQXJyYXkoYXJyLCBsZW4pIHtcbiAgICBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDtcblxuICAgIGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKykgYXJyMltpXSA9IGFycltpXTtcblxuICAgIHJldHVybiBhcnIyO1xuICB9XG5cbiAgZnVuY3Rpb24gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXJMb29zZShvLCBhbGxvd0FycmF5TGlrZSkge1xuICAgIHZhciBpdCA9IHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdIHx8IG9bXCJAQGl0ZXJhdG9yXCJdO1xuICAgIGlmIChpdCkgcmV0dXJuIChpdCA9IGl0LmNhbGwobykpLm5leHQuYmluZChpdCk7XG5cbiAgICBpZiAoQXJyYXkuaXNBcnJheShvKSB8fCAoaXQgPSBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobykpIHx8IGFsbG93QXJyYXlMaWtlICYmIG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09PSBcIm51bWJlclwiKSB7XG4gICAgICBpZiAoaXQpIG8gPSBpdDtcbiAgICAgIHZhciBpID0gMDtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChpID49IG8ubGVuZ3RoKSByZXR1cm4ge1xuICAgICAgICAgIGRvbmU6IHRydWVcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBkb25lOiBmYWxzZSxcbiAgICAgICAgICB2YWx1ZTogb1tpKytdXG4gICAgICAgIH07XG4gICAgICB9O1xuICAgIH1cblxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gaXRlcmF0ZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTtcbiAgfVxuXG4gIHZhciBkZWZhdWx0cyQ1ID0ge2V4cG9ydHM6IHt9fTtcblxuICBmdW5jdGlvbiBnZXREZWZhdWx0cyQxKCkge1xuICAgIHJldHVybiB7XG4gICAgICBiYXNlVXJsOiBudWxsLFxuICAgICAgYnJlYWtzOiBmYWxzZSxcbiAgICAgIGV4dGVuc2lvbnM6IG51bGwsXG4gICAgICBnZm06IHRydWUsXG4gICAgICBoZWFkZXJJZHM6IHRydWUsXG4gICAgICBoZWFkZXJQcmVmaXg6ICcnLFxuICAgICAgaGlnaGxpZ2h0OiBudWxsLFxuICAgICAgbGFuZ1ByZWZpeDogJ2xhbmd1YWdlLScsXG4gICAgICBtYW5nbGU6IHRydWUsXG4gICAgICBwZWRhbnRpYzogZmFsc2UsXG4gICAgICByZW5kZXJlcjogbnVsbCxcbiAgICAgIHNhbml0aXplOiBmYWxzZSxcbiAgICAgIHNhbml0aXplcjogbnVsbCxcbiAgICAgIHNpbGVudDogZmFsc2UsXG4gICAgICBzbWFydExpc3RzOiBmYWxzZSxcbiAgICAgIHNtYXJ0eXBhbnRzOiBmYWxzZSxcbiAgICAgIHRva2VuaXplcjogbnVsbCxcbiAgICAgIHdhbGtUb2tlbnM6IG51bGwsXG4gICAgICB4aHRtbDogZmFsc2VcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gY2hhbmdlRGVmYXVsdHMkMShuZXdEZWZhdWx0cykge1xuICAgIGRlZmF1bHRzJDUuZXhwb3J0cy5kZWZhdWx0cyA9IG5ld0RlZmF1bHRzO1xuICB9XG5cbiAgZGVmYXVsdHMkNS5leHBvcnRzID0ge1xuICAgIGRlZmF1bHRzOiBnZXREZWZhdWx0cyQxKCksXG4gICAgZ2V0RGVmYXVsdHM6IGdldERlZmF1bHRzJDEsXG4gICAgY2hhbmdlRGVmYXVsdHM6IGNoYW5nZURlZmF1bHRzJDFcbiAgfTtcblxuICAvKipcbiAgICogSGVscGVyc1xuICAgKi9cbiAgdmFyIGVzY2FwZVRlc3QgPSAvWyY8PlwiJ10vO1xuICB2YXIgZXNjYXBlUmVwbGFjZSA9IC9bJjw+XCInXS9nO1xuICB2YXIgZXNjYXBlVGVzdE5vRW5jb2RlID0gL1s8PlwiJ118Jig/ISM/XFx3KzspLztcbiAgdmFyIGVzY2FwZVJlcGxhY2VOb0VuY29kZSA9IC9bPD5cIiddfCYoPyEjP1xcdys7KS9nO1xuICB2YXIgZXNjYXBlUmVwbGFjZW1lbnRzID0ge1xuICAgICcmJzogJyZhbXA7JyxcbiAgICAnPCc6ICcmbHQ7JyxcbiAgICAnPic6ICcmZ3Q7JyxcbiAgICAnXCInOiAnJnF1b3Q7JyxcbiAgICBcIidcIjogJyYjMzk7J1xuICB9O1xuXG4gIHZhciBnZXRFc2NhcGVSZXBsYWNlbWVudCA9IGZ1bmN0aW9uIGdldEVzY2FwZVJlcGxhY2VtZW50KGNoKSB7XG4gICAgcmV0dXJuIGVzY2FwZVJlcGxhY2VtZW50c1tjaF07XG4gIH07XG5cbiAgZnVuY3Rpb24gZXNjYXBlJDIoaHRtbCwgZW5jb2RlKSB7XG4gICAgaWYgKGVuY29kZSkge1xuICAgICAgaWYgKGVzY2FwZVRlc3QudGVzdChodG1sKSkge1xuICAgICAgICByZXR1cm4gaHRtbC5yZXBsYWNlKGVzY2FwZVJlcGxhY2UsIGdldEVzY2FwZVJlcGxhY2VtZW50KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGVzY2FwZVRlc3ROb0VuY29kZS50ZXN0KGh0bWwpKSB7XG4gICAgICAgIHJldHVybiBodG1sLnJlcGxhY2UoZXNjYXBlUmVwbGFjZU5vRW5jb2RlLCBnZXRFc2NhcGVSZXBsYWNlbWVudCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGh0bWw7XG4gIH1cblxuICB2YXIgdW5lc2NhcGVUZXN0ID0gLyYoIyg/OlxcZCspfCg/OiN4WzAtOUEtRmEtZl0rKXwoPzpcXHcrKSk7Py9pZztcblxuICBmdW5jdGlvbiB1bmVzY2FwZSQxKGh0bWwpIHtcbiAgICAvLyBleHBsaWNpdGx5IG1hdGNoIGRlY2ltYWwsIGhleCwgYW5kIG5hbWVkIEhUTUwgZW50aXRpZXNcbiAgICByZXR1cm4gaHRtbC5yZXBsYWNlKHVuZXNjYXBlVGVzdCwgZnVuY3Rpb24gKF8sIG4pIHtcbiAgICAgIG4gPSBuLnRvTG93ZXJDYXNlKCk7XG4gICAgICBpZiAobiA9PT0gJ2NvbG9uJykgcmV0dXJuICc6JztcblxuICAgICAgaWYgKG4uY2hhckF0KDApID09PSAnIycpIHtcbiAgICAgICAgcmV0dXJuIG4uY2hhckF0KDEpID09PSAneCcgPyBTdHJpbmcuZnJvbUNoYXJDb2RlKHBhcnNlSW50KG4uc3Vic3RyaW5nKDIpLCAxNikpIDogU3RyaW5nLmZyb21DaGFyQ29kZSgrbi5zdWJzdHJpbmcoMSkpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gJyc7XG4gICAgfSk7XG4gIH1cblxuICB2YXIgY2FyZXQgPSAvKF58W15cXFtdKVxcXi9nO1xuXG4gIGZ1bmN0aW9uIGVkaXQkMShyZWdleCwgb3B0KSB7XG4gICAgcmVnZXggPSByZWdleC5zb3VyY2UgfHwgcmVnZXg7XG4gICAgb3B0ID0gb3B0IHx8ICcnO1xuICAgIHZhciBvYmogPSB7XG4gICAgICByZXBsYWNlOiBmdW5jdGlvbiByZXBsYWNlKG5hbWUsIHZhbCkge1xuICAgICAgICB2YWwgPSB2YWwuc291cmNlIHx8IHZhbDtcbiAgICAgICAgdmFsID0gdmFsLnJlcGxhY2UoY2FyZXQsICckMScpO1xuICAgICAgICByZWdleCA9IHJlZ2V4LnJlcGxhY2UobmFtZSwgdmFsKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgIH0sXG4gICAgICBnZXRSZWdleDogZnVuY3Rpb24gZ2V0UmVnZXgoKSB7XG4gICAgICAgIHJldHVybiBuZXcgUmVnRXhwKHJlZ2V4LCBvcHQpO1xuICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIG9iajtcbiAgfVxuXG4gIHZhciBub25Xb3JkQW5kQ29sb25UZXN0ID0gL1teXFx3Ol0vZztcbiAgdmFyIG9yaWdpbkluZGVwZW5kZW50VXJsID0gL14kfF5bYS16XVthLXowLTkrLi1dKjp8Xls/I10vaTtcblxuICBmdW5jdGlvbiBjbGVhblVybCQxKHNhbml0aXplLCBiYXNlLCBocmVmKSB7XG4gICAgaWYgKHNhbml0aXplKSB7XG4gICAgICB2YXIgcHJvdDtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgcHJvdCA9IGRlY29kZVVSSUNvbXBvbmVudCh1bmVzY2FwZSQxKGhyZWYpKS5yZXBsYWNlKG5vbldvcmRBbmRDb2xvblRlc3QsICcnKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgaWYgKHByb3QuaW5kZXhPZignamF2YXNjcmlwdDonKSA9PT0gMCB8fCBwcm90LmluZGV4T2YoJ3Zic2NyaXB0OicpID09PSAwIHx8IHByb3QuaW5kZXhPZignZGF0YTonKSA9PT0gMCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoYmFzZSAmJiAhb3JpZ2luSW5kZXBlbmRlbnRVcmwudGVzdChocmVmKSkge1xuICAgICAgaHJlZiA9IHJlc29sdmVVcmwoYmFzZSwgaHJlZik7XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIGhyZWYgPSBlbmNvZGVVUkkoaHJlZikucmVwbGFjZSgvJTI1L2csICclJyk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIGhyZWY7XG4gIH1cblxuICB2YXIgYmFzZVVybHMgPSB7fTtcbiAgdmFyIGp1c3REb21haW4gPSAvXlteOl0rOlxcLypbXi9dKiQvO1xuICB2YXIgcHJvdG9jb2wgPSAvXihbXjpdKzopW1xcc1xcU10qJC87XG4gIHZhciBkb21haW4gPSAvXihbXjpdKzpcXC8qW14vXSopW1xcc1xcU10qJC87XG5cbiAgZnVuY3Rpb24gcmVzb2x2ZVVybChiYXNlLCBocmVmKSB7XG4gICAgaWYgKCFiYXNlVXJsc1snICcgKyBiYXNlXSkge1xuICAgICAgLy8gd2UgY2FuIGlnbm9yZSBldmVyeXRoaW5nIGluIGJhc2UgYWZ0ZXIgdGhlIGxhc3Qgc2xhc2ggb2YgaXRzIHBhdGggY29tcG9uZW50LFxuICAgICAgLy8gYnV0IHdlIG1pZ2h0IG5lZWQgdG8gYWRkIF90aGF0X1xuICAgICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzM5ODYjc2VjdGlvbi0zXG4gICAgICBpZiAoanVzdERvbWFpbi50ZXN0KGJhc2UpKSB7XG4gICAgICAgIGJhc2VVcmxzWycgJyArIGJhc2VdID0gYmFzZSArICcvJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJhc2VVcmxzWycgJyArIGJhc2VdID0gcnRyaW0kMShiYXNlLCAnLycsIHRydWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGJhc2UgPSBiYXNlVXJsc1snICcgKyBiYXNlXTtcbiAgICB2YXIgcmVsYXRpdmVCYXNlID0gYmFzZS5pbmRleE9mKCc6JykgPT09IC0xO1xuXG4gICAgaWYgKGhyZWYuc3Vic3RyaW5nKDAsIDIpID09PSAnLy8nKSB7XG4gICAgICBpZiAocmVsYXRpdmVCYXNlKSB7XG4gICAgICAgIHJldHVybiBocmVmO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gYmFzZS5yZXBsYWNlKHByb3RvY29sLCAnJDEnKSArIGhyZWY7XG4gICAgfSBlbHNlIGlmIChocmVmLmNoYXJBdCgwKSA9PT0gJy8nKSB7XG4gICAgICBpZiAocmVsYXRpdmVCYXNlKSB7XG4gICAgICAgIHJldHVybiBocmVmO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gYmFzZS5yZXBsYWNlKGRvbWFpbiwgJyQxJykgKyBocmVmO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gYmFzZSArIGhyZWY7XG4gICAgfVxuICB9XG5cbiAgdmFyIG5vb3BUZXN0JDEgPSB7XG4gICAgZXhlYzogZnVuY3Rpb24gbm9vcFRlc3QoKSB7fVxuICB9O1xuXG4gIGZ1bmN0aW9uIG1lcmdlJDIob2JqKSB7XG4gICAgdmFyIGkgPSAxLFxuICAgICAgICB0YXJnZXQsXG4gICAgICAgIGtleTtcblxuICAgIGZvciAoOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0YXJnZXQgPSBhcmd1bWVudHNbaV07XG5cbiAgICAgIGZvciAoa2V5IGluIHRhcmdldCkge1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRhcmdldCwga2V5KSkge1xuICAgICAgICAgIG9ialtrZXldID0gdGFyZ2V0W2tleV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gb2JqO1xuICB9XG5cbiAgZnVuY3Rpb24gc3BsaXRDZWxscyQxKHRhYmxlUm93LCBjb3VudCkge1xuICAgIC8vIGVuc3VyZSB0aGF0IGV2ZXJ5IGNlbGwtZGVsaW1pdGluZyBwaXBlIGhhcyBhIHNwYWNlXG4gICAgLy8gYmVmb3JlIGl0IHRvIGRpc3Rpbmd1aXNoIGl0IGZyb20gYW4gZXNjYXBlZCBwaXBlXG4gICAgdmFyIHJvdyA9IHRhYmxlUm93LnJlcGxhY2UoL1xcfC9nLCBmdW5jdGlvbiAobWF0Y2gsIG9mZnNldCwgc3RyKSB7XG4gICAgICB2YXIgZXNjYXBlZCA9IGZhbHNlLFxuICAgICAgICAgIGN1cnIgPSBvZmZzZXQ7XG5cbiAgICAgIHdoaWxlICgtLWN1cnIgPj0gMCAmJiBzdHJbY3Vycl0gPT09ICdcXFxcJykge1xuICAgICAgICBlc2NhcGVkID0gIWVzY2FwZWQ7XG4gICAgICB9XG5cbiAgICAgIGlmIChlc2NhcGVkKSB7XG4gICAgICAgIC8vIG9kZCBudW1iZXIgb2Ygc2xhc2hlcyBtZWFucyB8IGlzIGVzY2FwZWRcbiAgICAgICAgLy8gc28gd2UgbGVhdmUgaXQgYWxvbmVcbiAgICAgICAgcmV0dXJuICd8JztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGFkZCBzcGFjZSBiZWZvcmUgdW5lc2NhcGVkIHxcbiAgICAgICAgcmV0dXJuICcgfCc7XG4gICAgICB9XG4gICAgfSksXG4gICAgICAgIGNlbGxzID0gcm93LnNwbGl0KC8gXFx8Lyk7XG4gICAgdmFyIGkgPSAwOyAvLyBGaXJzdC9sYXN0IGNlbGwgaW4gYSByb3cgY2Fubm90IGJlIGVtcHR5IGlmIGl0IGhhcyBubyBsZWFkaW5nL3RyYWlsaW5nIHBpcGVcblxuICAgIGlmICghY2VsbHNbMF0udHJpbSgpKSB7XG4gICAgICBjZWxscy5zaGlmdCgpO1xuICAgIH1cblxuICAgIGlmICghY2VsbHNbY2VsbHMubGVuZ3RoIC0gMV0udHJpbSgpKSB7XG4gICAgICBjZWxscy5wb3AoKTtcbiAgICB9XG5cbiAgICBpZiAoY2VsbHMubGVuZ3RoID4gY291bnQpIHtcbiAgICAgIGNlbGxzLnNwbGljZShjb3VudCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHdoaWxlIChjZWxscy5sZW5ndGggPCBjb3VudCkge1xuICAgICAgICBjZWxscy5wdXNoKCcnKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKDsgaSA8IGNlbGxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAvLyBsZWFkaW5nIG9yIHRyYWlsaW5nIHdoaXRlc3BhY2UgaXMgaWdub3JlZCBwZXIgdGhlIGdmbSBzcGVjXG4gICAgICBjZWxsc1tpXSA9IGNlbGxzW2ldLnRyaW0oKS5yZXBsYWNlKC9cXFxcXFx8L2csICd8Jyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNlbGxzO1xuICB9IC8vIFJlbW92ZSB0cmFpbGluZyAnYydzLiBFcXVpdmFsZW50IHRvIHN0ci5yZXBsYWNlKC9jKiQvLCAnJykuXG4gIC8vIC9jKiQvIGlzIHZ1bG5lcmFibGUgdG8gUkVET1MuXG4gIC8vIGludmVydDogUmVtb3ZlIHN1ZmZpeCBvZiBub24tYyBjaGFycyBpbnN0ZWFkLiBEZWZhdWx0IGZhbHNleS5cblxuXG4gIGZ1bmN0aW9uIHJ0cmltJDEoc3RyLCBjLCBpbnZlcnQpIHtcbiAgICB2YXIgbCA9IHN0ci5sZW5ndGg7XG5cbiAgICBpZiAobCA9PT0gMCkge1xuICAgICAgcmV0dXJuICcnO1xuICAgIH0gLy8gTGVuZ3RoIG9mIHN1ZmZpeCBtYXRjaGluZyB0aGUgaW52ZXJ0IGNvbmRpdGlvbi5cblxuXG4gICAgdmFyIHN1ZmZMZW4gPSAwOyAvLyBTdGVwIGxlZnQgdW50aWwgd2UgZmFpbCB0byBtYXRjaCB0aGUgaW52ZXJ0IGNvbmRpdGlvbi5cblxuICAgIHdoaWxlIChzdWZmTGVuIDwgbCkge1xuICAgICAgdmFyIGN1cnJDaGFyID0gc3RyLmNoYXJBdChsIC0gc3VmZkxlbiAtIDEpO1xuXG4gICAgICBpZiAoY3VyckNoYXIgPT09IGMgJiYgIWludmVydCkge1xuICAgICAgICBzdWZmTGVuKys7XG4gICAgICB9IGVsc2UgaWYgKGN1cnJDaGFyICE9PSBjICYmIGludmVydCkge1xuICAgICAgICBzdWZmTGVuKys7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gc3RyLnN1YnN0cigwLCBsIC0gc3VmZkxlbik7XG4gIH1cblxuICBmdW5jdGlvbiBmaW5kQ2xvc2luZ0JyYWNrZXQkMShzdHIsIGIpIHtcbiAgICBpZiAoc3RyLmluZGV4T2YoYlsxXSkgPT09IC0xKSB7XG4gICAgICByZXR1cm4gLTE7XG4gICAgfVxuXG4gICAgdmFyIGwgPSBzdHIubGVuZ3RoO1xuICAgIHZhciBsZXZlbCA9IDAsXG4gICAgICAgIGkgPSAwO1xuXG4gICAgZm9yICg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGlmIChzdHJbaV0gPT09ICdcXFxcJykge1xuICAgICAgICBpKys7XG4gICAgICB9IGVsc2UgaWYgKHN0cltpXSA9PT0gYlswXSkge1xuICAgICAgICBsZXZlbCsrO1xuICAgICAgfSBlbHNlIGlmIChzdHJbaV0gPT09IGJbMV0pIHtcbiAgICAgICAgbGV2ZWwtLTtcblxuICAgICAgICBpZiAobGV2ZWwgPCAwKSB7XG4gICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gLTE7XG4gIH1cblxuICBmdW5jdGlvbiBjaGVja1Nhbml0aXplRGVwcmVjYXRpb24kMShvcHQpIHtcbiAgICBpZiAob3B0ICYmIG9wdC5zYW5pdGl6ZSAmJiAhb3B0LnNpbGVudCkge1xuICAgICAgY29uc29sZS53YXJuKCdtYXJrZWQoKTogc2FuaXRpemUgYW5kIHNhbml0aXplciBwYXJhbWV0ZXJzIGFyZSBkZXByZWNhdGVkIHNpbmNlIHZlcnNpb24gMC43LjAsIHNob3VsZCBub3QgYmUgdXNlZCBhbmQgd2lsbCBiZSByZW1vdmVkIGluIHRoZSBmdXR1cmUuIFJlYWQgbW9yZSBoZXJlOiBodHRwczovL21hcmtlZC5qcy5vcmcvIy9VU0lOR19BRFZBTkNFRC5tZCNvcHRpb25zJyk7XG4gICAgfVxuICB9IC8vIGNvcGllZCBmcm9tIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS81NDUwMTEzLzgwNjc3N1xuXG5cbiAgZnVuY3Rpb24gcmVwZWF0U3RyaW5nJDEocGF0dGVybiwgY291bnQpIHtcbiAgICBpZiAoY291bnQgPCAxKSB7XG4gICAgICByZXR1cm4gJyc7XG4gICAgfVxuXG4gICAgdmFyIHJlc3VsdCA9ICcnO1xuXG4gICAgd2hpbGUgKGNvdW50ID4gMSkge1xuICAgICAgaWYgKGNvdW50ICYgMSkge1xuICAgICAgICByZXN1bHQgKz0gcGF0dGVybjtcbiAgICAgIH1cblxuICAgICAgY291bnQgPj49IDE7XG4gICAgICBwYXR0ZXJuICs9IHBhdHRlcm47XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdCArIHBhdHRlcm47XG4gIH1cblxuICB2YXIgaGVscGVycyA9IHtcbiAgICBlc2NhcGU6IGVzY2FwZSQyLFxuICAgIHVuZXNjYXBlOiB1bmVzY2FwZSQxLFxuICAgIGVkaXQ6IGVkaXQkMSxcbiAgICBjbGVhblVybDogY2xlYW5VcmwkMSxcbiAgICByZXNvbHZlVXJsOiByZXNvbHZlVXJsLFxuICAgIG5vb3BUZXN0OiBub29wVGVzdCQxLFxuICAgIG1lcmdlOiBtZXJnZSQyLFxuICAgIHNwbGl0Q2VsbHM6IHNwbGl0Q2VsbHMkMSxcbiAgICBydHJpbTogcnRyaW0kMSxcbiAgICBmaW5kQ2xvc2luZ0JyYWNrZXQ6IGZpbmRDbG9zaW5nQnJhY2tldCQxLFxuICAgIGNoZWNrU2FuaXRpemVEZXByZWNhdGlvbjogY2hlY2tTYW5pdGl6ZURlcHJlY2F0aW9uJDEsXG4gICAgcmVwZWF0U3RyaW5nOiByZXBlYXRTdHJpbmckMVxuICB9O1xuXG4gIHZhciBkZWZhdWx0cyQ0ID0gZGVmYXVsdHMkNS5leHBvcnRzLmRlZmF1bHRzO1xuICB2YXIgcnRyaW0gPSBoZWxwZXJzLnJ0cmltLFxuICAgICAgc3BsaXRDZWxscyA9IGhlbHBlcnMuc3BsaXRDZWxscyxcbiAgICAgIF9lc2NhcGUgPSBoZWxwZXJzLmVzY2FwZSxcbiAgICAgIGZpbmRDbG9zaW5nQnJhY2tldCA9IGhlbHBlcnMuZmluZENsb3NpbmdCcmFja2V0O1xuXG4gIGZ1bmN0aW9uIG91dHB1dExpbmsoY2FwLCBsaW5rLCByYXcsIGxleGVyKSB7XG4gICAgdmFyIGhyZWYgPSBsaW5rLmhyZWY7XG4gICAgdmFyIHRpdGxlID0gbGluay50aXRsZSA/IF9lc2NhcGUobGluay50aXRsZSkgOiBudWxsO1xuICAgIHZhciB0ZXh0ID0gY2FwWzFdLnJlcGxhY2UoL1xcXFwoW1xcW1xcXV0pL2csICckMScpO1xuXG4gICAgaWYgKGNhcFswXS5jaGFyQXQoMCkgIT09ICchJykge1xuICAgICAgbGV4ZXIuc3RhdGUuaW5MaW5rID0gdHJ1ZTtcbiAgICAgIHZhciB0b2tlbiA9IHtcbiAgICAgICAgdHlwZTogJ2xpbmsnLFxuICAgICAgICByYXc6IHJhdyxcbiAgICAgICAgaHJlZjogaHJlZixcbiAgICAgICAgdGl0bGU6IHRpdGxlLFxuICAgICAgICB0ZXh0OiB0ZXh0LFxuICAgICAgICB0b2tlbnM6IGxleGVyLmlubGluZVRva2Vucyh0ZXh0LCBbXSlcbiAgICAgIH07XG4gICAgICBsZXhlci5zdGF0ZS5pbkxpbmsgPSBmYWxzZTtcbiAgICAgIHJldHVybiB0b2tlbjtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogJ2ltYWdlJyxcbiAgICAgICAgcmF3OiByYXcsXG4gICAgICAgIGhyZWY6IGhyZWYsXG4gICAgICAgIHRpdGxlOiB0aXRsZSxcbiAgICAgICAgdGV4dDogX2VzY2FwZSh0ZXh0KVxuICAgICAgfTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpbmRlbnRDb2RlQ29tcGVuc2F0aW9uKHJhdywgdGV4dCkge1xuICAgIHZhciBtYXRjaEluZGVudFRvQ29kZSA9IHJhdy5tYXRjaCgvXihcXHMrKSg/OmBgYCkvKTtcblxuICAgIGlmIChtYXRjaEluZGVudFRvQ29kZSA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHRleHQ7XG4gICAgfVxuXG4gICAgdmFyIGluZGVudFRvQ29kZSA9IG1hdGNoSW5kZW50VG9Db2RlWzFdO1xuICAgIHJldHVybiB0ZXh0LnNwbGl0KCdcXG4nKS5tYXAoZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgIHZhciBtYXRjaEluZGVudEluTm9kZSA9IG5vZGUubWF0Y2goL15cXHMrLyk7XG5cbiAgICAgIGlmIChtYXRjaEluZGVudEluTm9kZSA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgIH1cblxuICAgICAgdmFyIGluZGVudEluTm9kZSA9IG1hdGNoSW5kZW50SW5Ob2RlWzBdO1xuXG4gICAgICBpZiAoaW5kZW50SW5Ob2RlLmxlbmd0aCA+PSBpbmRlbnRUb0NvZGUubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBub2RlLnNsaWNlKGluZGVudFRvQ29kZS5sZW5ndGgpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbm9kZTtcbiAgICB9KS5qb2luKCdcXG4nKTtcbiAgfVxuICAvKipcbiAgICogVG9rZW5pemVyXG4gICAqL1xuXG5cbiAgdmFyIFRva2VuaXplcl8xID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBUb2tlbml6ZXIob3B0aW9ucykge1xuICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucyB8fCBkZWZhdWx0cyQ0O1xuICAgIH1cblxuICAgIHZhciBfcHJvdG8gPSBUb2tlbml6ZXIucHJvdG90eXBlO1xuXG4gICAgX3Byb3RvLnNwYWNlID0gZnVuY3Rpb24gc3BhY2Uoc3JjKSB7XG4gICAgICB2YXIgY2FwID0gdGhpcy5ydWxlcy5ibG9jay5uZXdsaW5lLmV4ZWMoc3JjKTtcblxuICAgICAgaWYgKGNhcCkge1xuICAgICAgICBpZiAoY2FwWzBdLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogJ3NwYWNlJyxcbiAgICAgICAgICAgIHJhdzogY2FwWzBdXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgcmF3OiAnXFxuJ1xuICAgICAgICB9O1xuICAgICAgfVxuICAgIH07XG5cbiAgICBfcHJvdG8uY29kZSA9IGZ1bmN0aW9uIGNvZGUoc3JjKSB7XG4gICAgICB2YXIgY2FwID0gdGhpcy5ydWxlcy5ibG9jay5jb2RlLmV4ZWMoc3JjKTtcblxuICAgICAgaWYgKGNhcCkge1xuICAgICAgICB2YXIgdGV4dCA9IGNhcFswXS5yZXBsYWNlKC9eIHsxLDR9L2dtLCAnJyk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdHlwZTogJ2NvZGUnLFxuICAgICAgICAgIHJhdzogY2FwWzBdLFxuICAgICAgICAgIGNvZGVCbG9ja1N0eWxlOiAnaW5kZW50ZWQnLFxuICAgICAgICAgIHRleHQ6ICF0aGlzLm9wdGlvbnMucGVkYW50aWMgPyBydHJpbSh0ZXh0LCAnXFxuJykgOiB0ZXh0XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfTtcblxuICAgIF9wcm90by5mZW5jZXMgPSBmdW5jdGlvbiBmZW5jZXMoc3JjKSB7XG4gICAgICB2YXIgY2FwID0gdGhpcy5ydWxlcy5ibG9jay5mZW5jZXMuZXhlYyhzcmMpO1xuXG4gICAgICBpZiAoY2FwKSB7XG4gICAgICAgIHZhciByYXcgPSBjYXBbMF07XG4gICAgICAgIHZhciB0ZXh0ID0gaW5kZW50Q29kZUNvbXBlbnNhdGlvbihyYXcsIGNhcFszXSB8fCAnJyk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdHlwZTogJ2NvZGUnLFxuICAgICAgICAgIHJhdzogcmF3LFxuICAgICAgICAgIGxhbmc6IGNhcFsyXSA/IGNhcFsyXS50cmltKCkgOiBjYXBbMl0sXG4gICAgICAgICAgdGV4dDogdGV4dFxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH07XG5cbiAgICBfcHJvdG8uaGVhZGluZyA9IGZ1bmN0aW9uIGhlYWRpbmcoc3JjKSB7XG4gICAgICB2YXIgY2FwID0gdGhpcy5ydWxlcy5ibG9jay5oZWFkaW5nLmV4ZWMoc3JjKTtcblxuICAgICAgaWYgKGNhcCkge1xuICAgICAgICB2YXIgdGV4dCA9IGNhcFsyXS50cmltKCk7IC8vIHJlbW92ZSB0cmFpbGluZyAjc1xuXG4gICAgICAgIGlmICgvIyQvLnRlc3QodGV4dCkpIHtcbiAgICAgICAgICB2YXIgdHJpbW1lZCA9IHJ0cmltKHRleHQsICcjJyk7XG5cbiAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLnBlZGFudGljKSB7XG4gICAgICAgICAgICB0ZXh0ID0gdHJpbW1lZC50cmltKCk7XG4gICAgICAgICAgfSBlbHNlIGlmICghdHJpbW1lZCB8fCAvICQvLnRlc3QodHJpbW1lZCkpIHtcbiAgICAgICAgICAgIC8vIENvbW1vbk1hcmsgcmVxdWlyZXMgc3BhY2UgYmVmb3JlIHRyYWlsaW5nICNzXG4gICAgICAgICAgICB0ZXh0ID0gdHJpbW1lZC50cmltKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHRva2VuID0ge1xuICAgICAgICAgIHR5cGU6ICdoZWFkaW5nJyxcbiAgICAgICAgICByYXc6IGNhcFswXSxcbiAgICAgICAgICBkZXB0aDogY2FwWzFdLmxlbmd0aCxcbiAgICAgICAgICB0ZXh0OiB0ZXh0LFxuICAgICAgICAgIHRva2VuczogW11cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5sZXhlci5pbmxpbmUodG9rZW4udGV4dCwgdG9rZW4udG9rZW5zKTtcbiAgICAgICAgcmV0dXJuIHRva2VuO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBfcHJvdG8uaHIgPSBmdW5jdGlvbiBocihzcmMpIHtcbiAgICAgIHZhciBjYXAgPSB0aGlzLnJ1bGVzLmJsb2NrLmhyLmV4ZWMoc3JjKTtcblxuICAgICAgaWYgKGNhcCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHR5cGU6ICdocicsXG4gICAgICAgICAgcmF3OiBjYXBbMF1cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgX3Byb3RvLmJsb2NrcXVvdGUgPSBmdW5jdGlvbiBibG9ja3F1b3RlKHNyYykge1xuICAgICAgdmFyIGNhcCA9IHRoaXMucnVsZXMuYmxvY2suYmxvY2txdW90ZS5leGVjKHNyYyk7XG5cbiAgICAgIGlmIChjYXApIHtcbiAgICAgICAgdmFyIHRleHQgPSBjYXBbMF0ucmVwbGFjZSgvXiAqPiA/L2dtLCAnJyk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdHlwZTogJ2Jsb2NrcXVvdGUnLFxuICAgICAgICAgIHJhdzogY2FwWzBdLFxuICAgICAgICAgIHRva2VuczogdGhpcy5sZXhlci5ibG9ja1Rva2Vucyh0ZXh0LCBbXSksXG4gICAgICAgICAgdGV4dDogdGV4dFxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH07XG5cbiAgICBfcHJvdG8ubGlzdCA9IGZ1bmN0aW9uIGxpc3Qoc3JjKSB7XG4gICAgICB2YXIgY2FwID0gdGhpcy5ydWxlcy5ibG9jay5saXN0LmV4ZWMoc3JjKTtcblxuICAgICAgaWYgKGNhcCkge1xuICAgICAgICB2YXIgcmF3LCBpc3Rhc2ssIGlzY2hlY2tlZCwgaW5kZW50LCBpLCBibGFua0xpbmUsIGVuZHNXaXRoQmxhbmtMaW5lLCBsaW5lLCBsaW5lcywgaXRlbUNvbnRlbnRzO1xuICAgICAgICB2YXIgYnVsbCA9IGNhcFsxXS50cmltKCk7XG4gICAgICAgIHZhciBpc29yZGVyZWQgPSBidWxsLmxlbmd0aCA+IDE7XG4gICAgICAgIHZhciBsaXN0ID0ge1xuICAgICAgICAgIHR5cGU6ICdsaXN0JyxcbiAgICAgICAgICByYXc6ICcnLFxuICAgICAgICAgIG9yZGVyZWQ6IGlzb3JkZXJlZCxcbiAgICAgICAgICBzdGFydDogaXNvcmRlcmVkID8gK2J1bGwuc2xpY2UoMCwgLTEpIDogJycsXG4gICAgICAgICAgbG9vc2U6IGZhbHNlLFxuICAgICAgICAgIGl0ZW1zOiBbXVxuICAgICAgICB9O1xuICAgICAgICBidWxsID0gaXNvcmRlcmVkID8gXCJcXFxcZHsxLDl9XFxcXFwiICsgYnVsbC5zbGljZSgtMSkgOiBcIlxcXFxcIiArIGJ1bGw7XG5cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5wZWRhbnRpYykge1xuICAgICAgICAgIGJ1bGwgPSBpc29yZGVyZWQgPyBidWxsIDogJ1sqKy1dJztcbiAgICAgICAgfSAvLyBHZXQgbmV4dCBsaXN0IGl0ZW1cblxuXG4gICAgICAgIHZhciBpdGVtUmVnZXggPSBuZXcgUmVnRXhwKFwiXiggezAsM31cIiArIGJ1bGwgKyBcIikoKD86IFteXFxcXG5dKnwgKikoPzpcXFxcblteXFxcXG5dKikqKD86XFxcXG58JCkpXCIpOyAvLyBHZXQgZWFjaCB0b3AtbGV2ZWwgaXRlbVxuXG4gICAgICAgIHdoaWxlIChzcmMpIHtcbiAgICAgICAgICBpZiAodGhpcy5ydWxlcy5ibG9jay5oci50ZXN0KHNyYykpIHtcbiAgICAgICAgICAgIC8vIEVuZCBsaXN0IGlmIHdlIGVuY291bnRlciBhbiBIUiAocG9zc2libHkgbW92ZSBpbnRvIGl0ZW1SZWdleD8pXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoIShjYXAgPSBpdGVtUmVnZXguZXhlYyhzcmMpKSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbGluZXMgPSBjYXBbMl0uc3BsaXQoJ1xcbicpO1xuXG4gICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5wZWRhbnRpYykge1xuICAgICAgICAgICAgaW5kZW50ID0gMjtcbiAgICAgICAgICAgIGl0ZW1Db250ZW50cyA9IGxpbmVzWzBdLnRyaW1MZWZ0KCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGluZGVudCA9IGNhcFsyXS5zZWFyY2goL1teIF0vKTsgLy8gRmluZCBmaXJzdCBub24tc3BhY2UgY2hhclxuXG4gICAgICAgICAgICBpbmRlbnQgPSBjYXBbMV0ubGVuZ3RoICsgKGluZGVudCA+IDQgPyAxIDogaW5kZW50KTsgLy8gaW50ZW50ZWQgY29kZSBibG9ja3MgYWZ0ZXIgNCBzcGFjZXM7IGluZGVudCBpcyBhbHdheXMgMVxuXG4gICAgICAgICAgICBpdGVtQ29udGVudHMgPSBsaW5lc1swXS5zbGljZShpbmRlbnQgLSBjYXBbMV0ubGVuZ3RoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBibGFua0xpbmUgPSBmYWxzZTtcbiAgICAgICAgICByYXcgPSBjYXBbMF07XG5cbiAgICAgICAgICBpZiAoIWxpbmVzWzBdICYmIC9eICokLy50ZXN0KGxpbmVzWzFdKSkge1xuICAgICAgICAgICAgLy8gaXRlbXMgYmVnaW4gd2l0aCBhdCBtb3N0IG9uZSBibGFuayBsaW5lXG4gICAgICAgICAgICByYXcgPSBjYXBbMV0gKyBsaW5lcy5zbGljZSgwLCAyKS5qb2luKCdcXG4nKSArICdcXG4nO1xuICAgICAgICAgICAgbGlzdC5sb29zZSA9IHRydWU7XG4gICAgICAgICAgICBsaW5lcyA9IFtdO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBuZXh0QnVsbGV0UmVnZXggPSBuZXcgUmVnRXhwKFwiXiB7MCxcIiArIE1hdGgubWluKDMsIGluZGVudCAtIDEpICsgXCJ9KD86WyorLV18XFxcXGR7MSw5fVsuKV0pXCIpO1xuXG4gICAgICAgICAgZm9yIChpID0gMTsgaSA8IGxpbmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsaW5lID0gbGluZXNbaV07XG5cbiAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMucGVkYW50aWMpIHtcbiAgICAgICAgICAgICAgLy8gUmUtYWxpZ24gdG8gZm9sbG93IGNvbW1vbm1hcmsgbmVzdGluZyBydWxlc1xuICAgICAgICAgICAgICBsaW5lID0gbGluZS5yZXBsYWNlKC9eIHsxLDR9KD89KCB7NH0pKlteIF0pL2csICcgICcpO1xuICAgICAgICAgICAgfSAvLyBFbmQgbGlzdCBpdGVtIGlmIGZvdW5kIHN0YXJ0IG9mIG5ldyBidWxsZXRcblxuXG4gICAgICAgICAgICBpZiAobmV4dEJ1bGxldFJlZ2V4LnRlc3QobGluZSkpIHtcbiAgICAgICAgICAgICAgcmF3ID0gY2FwWzFdICsgbGluZXMuc2xpY2UoMCwgaSkuam9pbignXFxuJykgKyAnXFxuJztcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9IC8vIFVudGlsIHdlIGVuY291bnRlciBhIGJsYW5rIGxpbmUsIGl0ZW0gY29udGVudHMgZG8gbm90IG5lZWQgaW5kZW50YXRpb25cblxuXG4gICAgICAgICAgICBpZiAoIWJsYW5rTGluZSkge1xuICAgICAgICAgICAgICBpZiAoIWxpbmUudHJpbSgpKSB7XG4gICAgICAgICAgICAgICAgLy8gQ2hlY2sgaWYgY3VycmVudCBsaW5lIGlzIGVtcHR5XG4gICAgICAgICAgICAgICAgYmxhbmtMaW5lID0gdHJ1ZTtcbiAgICAgICAgICAgICAgfSAvLyBEZWRlbnQgaWYgcG9zc2libGVcblxuXG4gICAgICAgICAgICAgIGlmIChsaW5lLnNlYXJjaCgvW14gXS8pID49IGluZGVudCkge1xuICAgICAgICAgICAgICAgIGl0ZW1Db250ZW50cyArPSAnXFxuJyArIGxpbmUuc2xpY2UoaW5kZW50KTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpdGVtQ29udGVudHMgKz0gJ1xcbicgKyBsaW5lO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9IC8vIERlZGVudCB0aGlzIGxpbmVcblxuXG4gICAgICAgICAgICBpZiAobGluZS5zZWFyY2goL1teIF0vKSA+PSBpbmRlbnQgfHwgIWxpbmUudHJpbSgpKSB7XG4gICAgICAgICAgICAgIGl0ZW1Db250ZW50cyArPSAnXFxuJyArIGxpbmUuc2xpY2UoaW5kZW50KTtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyBMaW5lIHdhcyBub3QgcHJvcGVybHkgaW5kZW50ZWQ7IGVuZCBvZiB0aGlzIGl0ZW1cbiAgICAgICAgICAgICAgcmF3ID0gY2FwWzFdICsgbGluZXMuc2xpY2UoMCwgaSkuam9pbignXFxuJykgKyAnXFxuJztcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKCFsaXN0Lmxvb3NlKSB7XG4gICAgICAgICAgICAvLyBJZiB0aGUgcHJldmlvdXMgaXRlbSBlbmRlZCB3aXRoIGEgYmxhbmsgbGluZSwgdGhlIGxpc3QgaXMgbG9vc2VcbiAgICAgICAgICAgIGlmIChlbmRzV2l0aEJsYW5rTGluZSkge1xuICAgICAgICAgICAgICBsaXN0Lmxvb3NlID0gdHJ1ZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoL1xcbiAqXFxuICokLy50ZXN0KHJhdykpIHtcbiAgICAgICAgICAgICAgZW5kc1dpdGhCbGFua0xpbmUgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gLy8gQ2hlY2sgZm9yIHRhc2sgbGlzdCBpdGVtc1xuXG5cbiAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLmdmbSkge1xuICAgICAgICAgICAgaXN0YXNrID0gL15cXFtbIHhYXVxcXSAvLmV4ZWMoaXRlbUNvbnRlbnRzKTtcblxuICAgICAgICAgICAgaWYgKGlzdGFzaykge1xuICAgICAgICAgICAgICBpc2NoZWNrZWQgPSBpc3Rhc2tbMF0gIT09ICdbIF0gJztcbiAgICAgICAgICAgICAgaXRlbUNvbnRlbnRzID0gaXRlbUNvbnRlbnRzLnJlcGxhY2UoL15cXFtbIHhYXVxcXSArLywgJycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGxpc3QuaXRlbXMucHVzaCh7XG4gICAgICAgICAgICB0eXBlOiAnbGlzdF9pdGVtJyxcbiAgICAgICAgICAgIHJhdzogcmF3LFxuICAgICAgICAgICAgdGFzazogISFpc3Rhc2ssXG4gICAgICAgICAgICBjaGVja2VkOiBpc2NoZWNrZWQsXG4gICAgICAgICAgICBsb29zZTogZmFsc2UsXG4gICAgICAgICAgICB0ZXh0OiBpdGVtQ29udGVudHNcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBsaXN0LnJhdyArPSByYXc7XG4gICAgICAgICAgc3JjID0gc3JjLnNsaWNlKHJhdy5sZW5ndGgpO1xuICAgICAgICB9IC8vIERvIG5vdCBjb25zdW1lIG5ld2xpbmVzIGF0IGVuZCBvZiBmaW5hbCBpdGVtLiBBbHRlcm5hdGl2ZWx5LCBtYWtlIGl0ZW1SZWdleCAqc3RhcnQqIHdpdGggYW55IG5ld2xpbmVzIHRvIHNpbXBsaWZ5L3NwZWVkIHVwIGVuZHNXaXRoQmxhbmtMaW5lIGxvZ2ljXG5cblxuICAgICAgICBsaXN0Lml0ZW1zW2xpc3QuaXRlbXMubGVuZ3RoIC0gMV0ucmF3ID0gcmF3LnRyaW1SaWdodCgpO1xuICAgICAgICBsaXN0Lml0ZW1zW2xpc3QuaXRlbXMubGVuZ3RoIC0gMV0udGV4dCA9IGl0ZW1Db250ZW50cy50cmltUmlnaHQoKTtcbiAgICAgICAgbGlzdC5yYXcgPSBsaXN0LnJhdy50cmltUmlnaHQoKTtcbiAgICAgICAgdmFyIGwgPSBsaXN0Lml0ZW1zLmxlbmd0aDsgLy8gSXRlbSBjaGlsZCB0b2tlbnMgaGFuZGxlZCBoZXJlIGF0IGVuZCBiZWNhdXNlIHdlIG5lZWRlZCB0byBoYXZlIHRoZSBmaW5hbCBpdGVtIHRvIHRyaW0gaXQgZmlyc3RcblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgdGhpcy5sZXhlci5zdGF0ZS50b3AgPSBmYWxzZTtcbiAgICAgICAgICBsaXN0Lml0ZW1zW2ldLnRva2VucyA9IHRoaXMubGV4ZXIuYmxvY2tUb2tlbnMobGlzdC5pdGVtc1tpXS50ZXh0LCBbXSk7XG5cbiAgICAgICAgICBpZiAobGlzdC5pdGVtc1tpXS50b2tlbnMuc29tZShmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgcmV0dXJuIHQudHlwZSA9PT0gJ3NwYWNlJztcbiAgICAgICAgICB9KSkge1xuICAgICAgICAgICAgbGlzdC5sb29zZSA9IHRydWU7XG4gICAgICAgICAgICBsaXN0Lml0ZW1zW2ldLmxvb3NlID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbGlzdDtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgX3Byb3RvLmh0bWwgPSBmdW5jdGlvbiBodG1sKHNyYykge1xuICAgICAgdmFyIGNhcCA9IHRoaXMucnVsZXMuYmxvY2suaHRtbC5leGVjKHNyYyk7XG5cbiAgICAgIGlmIChjYXApIHtcbiAgICAgICAgdmFyIHRva2VuID0ge1xuICAgICAgICAgIHR5cGU6ICdodG1sJyxcbiAgICAgICAgICByYXc6IGNhcFswXSxcbiAgICAgICAgICBwcmU6ICF0aGlzLm9wdGlvbnMuc2FuaXRpemVyICYmIChjYXBbMV0gPT09ICdwcmUnIHx8IGNhcFsxXSA9PT0gJ3NjcmlwdCcgfHwgY2FwWzFdID09PSAnc3R5bGUnKSxcbiAgICAgICAgICB0ZXh0OiBjYXBbMF1cbiAgICAgICAgfTtcblxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnNhbml0aXplKSB7XG4gICAgICAgICAgdG9rZW4udHlwZSA9ICdwYXJhZ3JhcGgnO1xuICAgICAgICAgIHRva2VuLnRleHQgPSB0aGlzLm9wdGlvbnMuc2FuaXRpemVyID8gdGhpcy5vcHRpb25zLnNhbml0aXplcihjYXBbMF0pIDogX2VzY2FwZShjYXBbMF0pO1xuICAgICAgICAgIHRva2VuLnRva2VucyA9IFtdO1xuICAgICAgICAgIHRoaXMubGV4ZXIuaW5saW5lKHRva2VuLnRleHQsIHRva2VuLnRva2Vucyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdG9rZW47XG4gICAgICB9XG4gICAgfTtcblxuICAgIF9wcm90by5kZWYgPSBmdW5jdGlvbiBkZWYoc3JjKSB7XG4gICAgICB2YXIgY2FwID0gdGhpcy5ydWxlcy5ibG9jay5kZWYuZXhlYyhzcmMpO1xuXG4gICAgICBpZiAoY2FwKSB7XG4gICAgICAgIGlmIChjYXBbM10pIGNhcFszXSA9IGNhcFszXS5zdWJzdHJpbmcoMSwgY2FwWzNdLmxlbmd0aCAtIDEpO1xuICAgICAgICB2YXIgdGFnID0gY2FwWzFdLnRvTG93ZXJDYXNlKCkucmVwbGFjZSgvXFxzKy9nLCAnICcpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHR5cGU6ICdkZWYnLFxuICAgICAgICAgIHRhZzogdGFnLFxuICAgICAgICAgIHJhdzogY2FwWzBdLFxuICAgICAgICAgIGhyZWY6IGNhcFsyXSxcbiAgICAgICAgICB0aXRsZTogY2FwWzNdXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfTtcblxuICAgIF9wcm90by50YWJsZSA9IGZ1bmN0aW9uIHRhYmxlKHNyYykge1xuICAgICAgdmFyIGNhcCA9IHRoaXMucnVsZXMuYmxvY2sudGFibGUuZXhlYyhzcmMpO1xuXG4gICAgICBpZiAoY2FwKSB7XG4gICAgICAgIHZhciBpdGVtID0ge1xuICAgICAgICAgIHR5cGU6ICd0YWJsZScsXG4gICAgICAgICAgaGVhZGVyOiBzcGxpdENlbGxzKGNhcFsxXSkubWFwKGZ1bmN0aW9uIChjKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICB0ZXh0OiBjXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH0pLFxuICAgICAgICAgIGFsaWduOiBjYXBbMl0ucmVwbGFjZSgvXiAqfFxcfCAqJC9nLCAnJykuc3BsaXQoLyAqXFx8ICovKSxcbiAgICAgICAgICByb3dzOiBjYXBbM10gPyBjYXBbM10ucmVwbGFjZSgvXFxuJC8sICcnKS5zcGxpdCgnXFxuJykgOiBbXVxuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChpdGVtLmhlYWRlci5sZW5ndGggPT09IGl0ZW0uYWxpZ24ubGVuZ3RoKSB7XG4gICAgICAgICAgaXRlbS5yYXcgPSBjYXBbMF07XG4gICAgICAgICAgdmFyIGwgPSBpdGVtLmFsaWduLmxlbmd0aDtcbiAgICAgICAgICB2YXIgaSwgaiwgaywgcm93O1xuXG4gICAgICAgICAgZm9yIChpID0gMDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgaWYgKC9eICotKzogKiQvLnRlc3QoaXRlbS5hbGlnbltpXSkpIHtcbiAgICAgICAgICAgICAgaXRlbS5hbGlnbltpXSA9ICdyaWdodCc7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKC9eICo6LSs6ICokLy50ZXN0KGl0ZW0uYWxpZ25baV0pKSB7XG4gICAgICAgICAgICAgIGl0ZW0uYWxpZ25baV0gPSAnY2VudGVyJztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoL14gKjotKyAqJC8udGVzdChpdGVtLmFsaWduW2ldKSkge1xuICAgICAgICAgICAgICBpdGVtLmFsaWduW2ldID0gJ2xlZnQnO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgaXRlbS5hbGlnbltpXSA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbCA9IGl0ZW0ucm93cy5sZW5ndGg7XG5cbiAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICBpdGVtLnJvd3NbaV0gPSBzcGxpdENlbGxzKGl0ZW0ucm93c1tpXSwgaXRlbS5oZWFkZXIubGVuZ3RoKS5tYXAoZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0ZXh0OiBjXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IC8vIHBhcnNlIGNoaWxkIHRva2VucyBpbnNpZGUgaGVhZGVycyBhbmQgY2VsbHNcbiAgICAgICAgICAvLyBoZWFkZXIgY2hpbGQgdG9rZW5zXG5cblxuICAgICAgICAgIGwgPSBpdGVtLmhlYWRlci5sZW5ndGg7XG5cbiAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgbDsgaisrKSB7XG4gICAgICAgICAgICBpdGVtLmhlYWRlcltqXS50b2tlbnMgPSBbXTtcbiAgICAgICAgICAgIHRoaXMubGV4ZXIuaW5saW5lVG9rZW5zKGl0ZW0uaGVhZGVyW2pdLnRleHQsIGl0ZW0uaGVhZGVyW2pdLnRva2Vucyk7XG4gICAgICAgICAgfSAvLyBjZWxsIGNoaWxkIHRva2Vuc1xuXG5cbiAgICAgICAgICBsID0gaXRlbS5yb3dzLmxlbmd0aDtcblxuICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBsOyBqKyspIHtcbiAgICAgICAgICAgIHJvdyA9IGl0ZW0ucm93c1tqXTtcblxuICAgICAgICAgICAgZm9yIChrID0gMDsgayA8IHJvdy5sZW5ndGg7IGsrKykge1xuICAgICAgICAgICAgICByb3dba10udG9rZW5zID0gW107XG4gICAgICAgICAgICAgIHRoaXMubGV4ZXIuaW5saW5lVG9rZW5zKHJvd1trXS50ZXh0LCByb3dba10udG9rZW5zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gaXRlbTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICBfcHJvdG8ubGhlYWRpbmcgPSBmdW5jdGlvbiBsaGVhZGluZyhzcmMpIHtcbiAgICAgIHZhciBjYXAgPSB0aGlzLnJ1bGVzLmJsb2NrLmxoZWFkaW5nLmV4ZWMoc3JjKTtcblxuICAgICAgaWYgKGNhcCkge1xuICAgICAgICB2YXIgdG9rZW4gPSB7XG4gICAgICAgICAgdHlwZTogJ2hlYWRpbmcnLFxuICAgICAgICAgIHJhdzogY2FwWzBdLFxuICAgICAgICAgIGRlcHRoOiBjYXBbMl0uY2hhckF0KDApID09PSAnPScgPyAxIDogMixcbiAgICAgICAgICB0ZXh0OiBjYXBbMV0sXG4gICAgICAgICAgdG9rZW5zOiBbXVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmxleGVyLmlubGluZSh0b2tlbi50ZXh0LCB0b2tlbi50b2tlbnMpO1xuICAgICAgICByZXR1cm4gdG9rZW47XG4gICAgICB9XG4gICAgfTtcblxuICAgIF9wcm90by5wYXJhZ3JhcGggPSBmdW5jdGlvbiBwYXJhZ3JhcGgoc3JjKSB7XG4gICAgICB2YXIgY2FwID0gdGhpcy5ydWxlcy5ibG9jay5wYXJhZ3JhcGguZXhlYyhzcmMpO1xuXG4gICAgICBpZiAoY2FwKSB7XG4gICAgICAgIHZhciB0b2tlbiA9IHtcbiAgICAgICAgICB0eXBlOiAncGFyYWdyYXBoJyxcbiAgICAgICAgICByYXc6IGNhcFswXSxcbiAgICAgICAgICB0ZXh0OiBjYXBbMV0uY2hhckF0KGNhcFsxXS5sZW5ndGggLSAxKSA9PT0gJ1xcbicgPyBjYXBbMV0uc2xpY2UoMCwgLTEpIDogY2FwWzFdLFxuICAgICAgICAgIHRva2VuczogW11cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5sZXhlci5pbmxpbmUodG9rZW4udGV4dCwgdG9rZW4udG9rZW5zKTtcbiAgICAgICAgcmV0dXJuIHRva2VuO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBfcHJvdG8udGV4dCA9IGZ1bmN0aW9uIHRleHQoc3JjKSB7XG4gICAgICB2YXIgY2FwID0gdGhpcy5ydWxlcy5ibG9jay50ZXh0LmV4ZWMoc3JjKTtcblxuICAgICAgaWYgKGNhcCkge1xuICAgICAgICB2YXIgdG9rZW4gPSB7XG4gICAgICAgICAgdHlwZTogJ3RleHQnLFxuICAgICAgICAgIHJhdzogY2FwWzBdLFxuICAgICAgICAgIHRleHQ6IGNhcFswXSxcbiAgICAgICAgICB0b2tlbnM6IFtdXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMubGV4ZXIuaW5saW5lKHRva2VuLnRleHQsIHRva2VuLnRva2Vucyk7XG4gICAgICAgIHJldHVybiB0b2tlbjtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgX3Byb3RvLmVzY2FwZSA9IGZ1bmN0aW9uIGVzY2FwZShzcmMpIHtcbiAgICAgIHZhciBjYXAgPSB0aGlzLnJ1bGVzLmlubGluZS5lc2NhcGUuZXhlYyhzcmMpO1xuXG4gICAgICBpZiAoY2FwKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdHlwZTogJ2VzY2FwZScsXG4gICAgICAgICAgcmF3OiBjYXBbMF0sXG4gICAgICAgICAgdGV4dDogX2VzY2FwZShjYXBbMV0pXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfTtcblxuICAgIF9wcm90by50YWcgPSBmdW5jdGlvbiB0YWcoc3JjKSB7XG4gICAgICB2YXIgY2FwID0gdGhpcy5ydWxlcy5pbmxpbmUudGFnLmV4ZWMoc3JjKTtcblxuICAgICAgaWYgKGNhcCkge1xuICAgICAgICBpZiAoIXRoaXMubGV4ZXIuc3RhdGUuaW5MaW5rICYmIC9ePGEgL2kudGVzdChjYXBbMF0pKSB7XG4gICAgICAgICAgdGhpcy5sZXhlci5zdGF0ZS5pbkxpbmsgPSB0cnVlO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMubGV4ZXIuc3RhdGUuaW5MaW5rICYmIC9ePFxcL2E+L2kudGVzdChjYXBbMF0pKSB7XG4gICAgICAgICAgdGhpcy5sZXhlci5zdGF0ZS5pbkxpbmsgPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdGhpcy5sZXhlci5zdGF0ZS5pblJhd0Jsb2NrICYmIC9ePChwcmV8Y29kZXxrYmR8c2NyaXB0KShcXHN8PikvaS50ZXN0KGNhcFswXSkpIHtcbiAgICAgICAgICB0aGlzLmxleGVyLnN0YXRlLmluUmF3QmxvY2sgPSB0cnVlO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMubGV4ZXIuc3RhdGUuaW5SYXdCbG9jayAmJiAvXjxcXC8ocHJlfGNvZGV8a2JkfHNjcmlwdCkoXFxzfD4pL2kudGVzdChjYXBbMF0pKSB7XG4gICAgICAgICAgdGhpcy5sZXhlci5zdGF0ZS5pblJhd0Jsb2NrID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHR5cGU6IHRoaXMub3B0aW9ucy5zYW5pdGl6ZSA/ICd0ZXh0JyA6ICdodG1sJyxcbiAgICAgICAgICByYXc6IGNhcFswXSxcbiAgICAgICAgICBpbkxpbms6IHRoaXMubGV4ZXIuc3RhdGUuaW5MaW5rLFxuICAgICAgICAgIGluUmF3QmxvY2s6IHRoaXMubGV4ZXIuc3RhdGUuaW5SYXdCbG9jayxcbiAgICAgICAgICB0ZXh0OiB0aGlzLm9wdGlvbnMuc2FuaXRpemUgPyB0aGlzLm9wdGlvbnMuc2FuaXRpemVyID8gdGhpcy5vcHRpb25zLnNhbml0aXplcihjYXBbMF0pIDogX2VzY2FwZShjYXBbMF0pIDogY2FwWzBdXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfTtcblxuICAgIF9wcm90by5saW5rID0gZnVuY3Rpb24gbGluayhzcmMpIHtcbiAgICAgIHZhciBjYXAgPSB0aGlzLnJ1bGVzLmlubGluZS5saW5rLmV4ZWMoc3JjKTtcblxuICAgICAgaWYgKGNhcCkge1xuICAgICAgICB2YXIgdHJpbW1lZFVybCA9IGNhcFsyXS50cmltKCk7XG5cbiAgICAgICAgaWYgKCF0aGlzLm9wdGlvbnMucGVkYW50aWMgJiYgL148Ly50ZXN0KHRyaW1tZWRVcmwpKSB7XG4gICAgICAgICAgLy8gY29tbW9ubWFyayByZXF1aXJlcyBtYXRjaGluZyBhbmdsZSBicmFja2V0c1xuICAgICAgICAgIGlmICghLz4kLy50ZXN0KHRyaW1tZWRVcmwpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfSAvLyBlbmRpbmcgYW5nbGUgYnJhY2tldCBjYW5ub3QgYmUgZXNjYXBlZFxuXG5cbiAgICAgICAgICB2YXIgcnRyaW1TbGFzaCA9IHJ0cmltKHRyaW1tZWRVcmwuc2xpY2UoMCwgLTEpLCAnXFxcXCcpO1xuXG4gICAgICAgICAgaWYgKCh0cmltbWVkVXJsLmxlbmd0aCAtIHJ0cmltU2xhc2gubGVuZ3RoKSAlIDIgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gZmluZCBjbG9zaW5nIHBhcmVudGhlc2lzXG4gICAgICAgICAgdmFyIGxhc3RQYXJlbkluZGV4ID0gZmluZENsb3NpbmdCcmFja2V0KGNhcFsyXSwgJygpJyk7XG5cbiAgICAgICAgICBpZiAobGFzdFBhcmVuSW5kZXggPiAtMSkge1xuICAgICAgICAgICAgdmFyIHN0YXJ0ID0gY2FwWzBdLmluZGV4T2YoJyEnKSA9PT0gMCA/IDUgOiA0O1xuICAgICAgICAgICAgdmFyIGxpbmtMZW4gPSBzdGFydCArIGNhcFsxXS5sZW5ndGggKyBsYXN0UGFyZW5JbmRleDtcbiAgICAgICAgICAgIGNhcFsyXSA9IGNhcFsyXS5zdWJzdHJpbmcoMCwgbGFzdFBhcmVuSW5kZXgpO1xuICAgICAgICAgICAgY2FwWzBdID0gY2FwWzBdLnN1YnN0cmluZygwLCBsaW5rTGVuKS50cmltKCk7XG4gICAgICAgICAgICBjYXBbM10gPSAnJztcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaHJlZiA9IGNhcFsyXTtcbiAgICAgICAgdmFyIHRpdGxlID0gJyc7XG5cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5wZWRhbnRpYykge1xuICAgICAgICAgIC8vIHNwbGl0IHBlZGFudGljIGhyZWYgYW5kIHRpdGxlXG4gICAgICAgICAgdmFyIGxpbmsgPSAvXihbXidcIl0qW15cXHNdKVxccysoWydcIl0pKC4qKVxcMi8uZXhlYyhocmVmKTtcblxuICAgICAgICAgIGlmIChsaW5rKSB7XG4gICAgICAgICAgICBocmVmID0gbGlua1sxXTtcbiAgICAgICAgICAgIHRpdGxlID0gbGlua1szXTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGl0bGUgPSBjYXBbM10gPyBjYXBbM10uc2xpY2UoMSwgLTEpIDogJyc7XG4gICAgICAgIH1cblxuICAgICAgICBocmVmID0gaHJlZi50cmltKCk7XG5cbiAgICAgICAgaWYgKC9ePC8udGVzdChocmVmKSkge1xuICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMucGVkYW50aWMgJiYgIS8+JC8udGVzdCh0cmltbWVkVXJsKSkge1xuICAgICAgICAgICAgLy8gcGVkYW50aWMgYWxsb3dzIHN0YXJ0aW5nIGFuZ2xlIGJyYWNrZXQgd2l0aG91dCBlbmRpbmcgYW5nbGUgYnJhY2tldFxuICAgICAgICAgICAgaHJlZiA9IGhyZWYuc2xpY2UoMSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGhyZWYgPSBocmVmLnNsaWNlKDEsIC0xKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gb3V0cHV0TGluayhjYXAsIHtcbiAgICAgICAgICBocmVmOiBocmVmID8gaHJlZi5yZXBsYWNlKHRoaXMucnVsZXMuaW5saW5lLl9lc2NhcGVzLCAnJDEnKSA6IGhyZWYsXG4gICAgICAgICAgdGl0bGU6IHRpdGxlID8gdGl0bGUucmVwbGFjZSh0aGlzLnJ1bGVzLmlubGluZS5fZXNjYXBlcywgJyQxJykgOiB0aXRsZVxuICAgICAgICB9LCBjYXBbMF0sIHRoaXMubGV4ZXIpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBfcHJvdG8ucmVmbGluayA9IGZ1bmN0aW9uIHJlZmxpbmsoc3JjLCBsaW5rcykge1xuICAgICAgdmFyIGNhcDtcblxuICAgICAgaWYgKChjYXAgPSB0aGlzLnJ1bGVzLmlubGluZS5yZWZsaW5rLmV4ZWMoc3JjKSkgfHwgKGNhcCA9IHRoaXMucnVsZXMuaW5saW5lLm5vbGluay5leGVjKHNyYykpKSB7XG4gICAgICAgIHZhciBsaW5rID0gKGNhcFsyXSB8fCBjYXBbMV0pLnJlcGxhY2UoL1xccysvZywgJyAnKTtcbiAgICAgICAgbGluayA9IGxpbmtzW2xpbmsudG9Mb3dlckNhc2UoKV07XG5cbiAgICAgICAgaWYgKCFsaW5rIHx8ICFsaW5rLmhyZWYpIHtcbiAgICAgICAgICB2YXIgdGV4dCA9IGNhcFswXS5jaGFyQXQoMCk7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6ICd0ZXh0JyxcbiAgICAgICAgICAgIHJhdzogdGV4dCxcbiAgICAgICAgICAgIHRleHQ6IHRleHRcbiAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG91dHB1dExpbmsoY2FwLCBsaW5rLCBjYXBbMF0sIHRoaXMubGV4ZXIpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBfcHJvdG8uZW1TdHJvbmcgPSBmdW5jdGlvbiBlbVN0cm9uZyhzcmMsIG1hc2tlZFNyYywgcHJldkNoYXIpIHtcbiAgICAgIGlmIChwcmV2Q2hhciA9PT0gdm9pZCAwKSB7XG4gICAgICAgIHByZXZDaGFyID0gJyc7XG4gICAgICB9XG5cbiAgICAgIHZhciBtYXRjaCA9IHRoaXMucnVsZXMuaW5saW5lLmVtU3Ryb25nLmxEZWxpbS5leGVjKHNyYyk7XG4gICAgICBpZiAoIW1hdGNoKSByZXR1cm47IC8vIF8gY2FuJ3QgYmUgYmV0d2VlbiB0d28gYWxwaGFudW1lcmljcy4gXFxwe0x9XFxwe059IGluY2x1ZGVzIG5vbi1lbmdsaXNoIGFscGhhYmV0L251bWJlcnMgYXMgd2VsbFxuXG4gICAgICBpZiAobWF0Y2hbM10gJiYgcHJldkNoYXIubWF0Y2goLyg/OlswLTlBLVphLXpcXHhBQVxceEIyXFx4QjNcXHhCNVxceEI5XFx4QkFcXHhCQy1cXHhCRVxceEMwLVxceEQ2XFx4RDgtXFx4RjZcXHhGOC1cXHUwMkMxXFx1MDJDNi1cXHUwMkQxXFx1MDJFMC1cXHUwMkU0XFx1MDJFQ1xcdTAyRUVcXHUwMzcwLVxcdTAzNzRcXHUwMzc2XFx1MDM3N1xcdTAzN0EtXFx1MDM3RFxcdTAzN0ZcXHUwMzg2XFx1MDM4OC1cXHUwMzhBXFx1MDM4Q1xcdTAzOEUtXFx1MDNBMVxcdTAzQTMtXFx1MDNGNVxcdTAzRjctXFx1MDQ4MVxcdTA0OEEtXFx1MDUyRlxcdTA1MzEtXFx1MDU1NlxcdTA1NTlcXHUwNTYwLVxcdTA1ODhcXHUwNUQwLVxcdTA1RUFcXHUwNUVGLVxcdTA1RjJcXHUwNjIwLVxcdTA2NEFcXHUwNjYwLVxcdTA2NjlcXHUwNjZFXFx1MDY2RlxcdTA2NzEtXFx1MDZEM1xcdTA2RDVcXHUwNkU1XFx1MDZFNlxcdTA2RUUtXFx1MDZGQ1xcdTA2RkZcXHUwNzEwXFx1MDcxMi1cXHUwNzJGXFx1MDc0RC1cXHUwN0E1XFx1MDdCMVxcdTA3QzAtXFx1MDdFQVxcdTA3RjRcXHUwN0Y1XFx1MDdGQVxcdTA4MDAtXFx1MDgxNVxcdTA4MUFcXHUwODI0XFx1MDgyOFxcdTA4NDAtXFx1MDg1OFxcdTA4NjAtXFx1MDg2QVxcdTA4QTAtXFx1MDhCNFxcdTA4QjYtXFx1MDhDN1xcdTA5MDQtXFx1MDkzOVxcdTA5M0RcXHUwOTUwXFx1MDk1OC1cXHUwOTYxXFx1MDk2Ni1cXHUwOTZGXFx1MDk3MS1cXHUwOTgwXFx1MDk4NS1cXHUwOThDXFx1MDk4RlxcdTA5OTBcXHUwOTkzLVxcdTA5QThcXHUwOUFBLVxcdTA5QjBcXHUwOUIyXFx1MDlCNi1cXHUwOUI5XFx1MDlCRFxcdTA5Q0VcXHUwOURDXFx1MDlERFxcdTA5REYtXFx1MDlFMVxcdTA5RTYtXFx1MDlGMVxcdTA5RjQtXFx1MDlGOVxcdTA5RkNcXHUwQTA1LVxcdTBBMEFcXHUwQTBGXFx1MEExMFxcdTBBMTMtXFx1MEEyOFxcdTBBMkEtXFx1MEEzMFxcdTBBMzJcXHUwQTMzXFx1MEEzNVxcdTBBMzZcXHUwQTM4XFx1MEEzOVxcdTBBNTktXFx1MEE1Q1xcdTBBNUVcXHUwQTY2LVxcdTBBNkZcXHUwQTcyLVxcdTBBNzRcXHUwQTg1LVxcdTBBOERcXHUwQThGLVxcdTBBOTFcXHUwQTkzLVxcdTBBQThcXHUwQUFBLVxcdTBBQjBcXHUwQUIyXFx1MEFCM1xcdTBBQjUtXFx1MEFCOVxcdTBBQkRcXHUwQUQwXFx1MEFFMFxcdTBBRTFcXHUwQUU2LVxcdTBBRUZcXHUwQUY5XFx1MEIwNS1cXHUwQjBDXFx1MEIwRlxcdTBCMTBcXHUwQjEzLVxcdTBCMjhcXHUwQjJBLVxcdTBCMzBcXHUwQjMyXFx1MEIzM1xcdTBCMzUtXFx1MEIzOVxcdTBCM0RcXHUwQjVDXFx1MEI1RFxcdTBCNUYtXFx1MEI2MVxcdTBCNjYtXFx1MEI2RlxcdTBCNzEtXFx1MEI3N1xcdTBCODNcXHUwQjg1LVxcdTBCOEFcXHUwQjhFLVxcdTBCOTBcXHUwQjkyLVxcdTBCOTVcXHUwQjk5XFx1MEI5QVxcdTBCOUNcXHUwQjlFXFx1MEI5RlxcdTBCQTNcXHUwQkE0XFx1MEJBOC1cXHUwQkFBXFx1MEJBRS1cXHUwQkI5XFx1MEJEMFxcdTBCRTYtXFx1MEJGMlxcdTBDMDUtXFx1MEMwQ1xcdTBDMEUtXFx1MEMxMFxcdTBDMTItXFx1MEMyOFxcdTBDMkEtXFx1MEMzOVxcdTBDM0RcXHUwQzU4LVxcdTBDNUFcXHUwQzYwXFx1MEM2MVxcdTBDNjYtXFx1MEM2RlxcdTBDNzgtXFx1MEM3RVxcdTBDODBcXHUwQzg1LVxcdTBDOENcXHUwQzhFLVxcdTBDOTBcXHUwQzkyLVxcdTBDQThcXHUwQ0FBLVxcdTBDQjNcXHUwQ0I1LVxcdTBDQjlcXHUwQ0JEXFx1MENERVxcdTBDRTBcXHUwQ0UxXFx1MENFNi1cXHUwQ0VGXFx1MENGMVxcdTBDRjJcXHUwRDA0LVxcdTBEMENcXHUwRDBFLVxcdTBEMTBcXHUwRDEyLVxcdTBEM0FcXHUwRDNEXFx1MEQ0RVxcdTBENTQtXFx1MEQ1NlxcdTBENTgtXFx1MEQ2MVxcdTBENjYtXFx1MEQ3OFxcdTBEN0EtXFx1MEQ3RlxcdTBEODUtXFx1MEQ5NlxcdTBEOUEtXFx1MERCMVxcdTBEQjMtXFx1MERCQlxcdTBEQkRcXHUwREMwLVxcdTBEQzZcXHUwREU2LVxcdTBERUZcXHUwRTAxLVxcdTBFMzBcXHUwRTMyXFx1MEUzM1xcdTBFNDAtXFx1MEU0NlxcdTBFNTAtXFx1MEU1OVxcdTBFODFcXHUwRTgyXFx1MEU4NFxcdTBFODYtXFx1MEU4QVxcdTBFOEMtXFx1MEVBM1xcdTBFQTVcXHUwRUE3LVxcdTBFQjBcXHUwRUIyXFx1MEVCM1xcdTBFQkRcXHUwRUMwLVxcdTBFQzRcXHUwRUM2XFx1MEVEMC1cXHUwRUQ5XFx1MEVEQy1cXHUwRURGXFx1MEYwMFxcdTBGMjAtXFx1MEYzM1xcdTBGNDAtXFx1MEY0N1xcdTBGNDktXFx1MEY2Q1xcdTBGODgtXFx1MEY4Q1xcdTEwMDAtXFx1MTAyQVxcdTEwM0YtXFx1MTA0OVxcdTEwNTAtXFx1MTA1NVxcdTEwNUEtXFx1MTA1RFxcdTEwNjFcXHUxMDY1XFx1MTA2NlxcdTEwNkUtXFx1MTA3MFxcdTEwNzUtXFx1MTA4MVxcdTEwOEVcXHUxMDkwLVxcdTEwOTlcXHUxMEEwLVxcdTEwQzVcXHUxMEM3XFx1MTBDRFxcdTEwRDAtXFx1MTBGQVxcdTEwRkMtXFx1MTI0OFxcdTEyNEEtXFx1MTI0RFxcdTEyNTAtXFx1MTI1NlxcdTEyNThcXHUxMjVBLVxcdTEyNURcXHUxMjYwLVxcdTEyODhcXHUxMjhBLVxcdTEyOERcXHUxMjkwLVxcdTEyQjBcXHUxMkIyLVxcdTEyQjVcXHUxMkI4LVxcdTEyQkVcXHUxMkMwXFx1MTJDMi1cXHUxMkM1XFx1MTJDOC1cXHUxMkQ2XFx1MTJEOC1cXHUxMzEwXFx1MTMxMi1cXHUxMzE1XFx1MTMxOC1cXHUxMzVBXFx1MTM2OS1cXHUxMzdDXFx1MTM4MC1cXHUxMzhGXFx1MTNBMC1cXHUxM0Y1XFx1MTNGOC1cXHUxM0ZEXFx1MTQwMS1cXHUxNjZDXFx1MTY2Ri1cXHUxNjdGXFx1MTY4MS1cXHUxNjlBXFx1MTZBMC1cXHUxNkVBXFx1MTZFRS1cXHUxNkY4XFx1MTcwMC1cXHUxNzBDXFx1MTcwRS1cXHUxNzExXFx1MTcyMC1cXHUxNzMxXFx1MTc0MC1cXHUxNzUxXFx1MTc2MC1cXHUxNzZDXFx1MTc2RS1cXHUxNzcwXFx1MTc4MC1cXHUxN0IzXFx1MTdEN1xcdTE3RENcXHUxN0UwLVxcdTE3RTlcXHUxN0YwLVxcdTE3RjlcXHUxODEwLVxcdTE4MTlcXHUxODIwLVxcdTE4NzhcXHUxODgwLVxcdTE4ODRcXHUxODg3LVxcdTE4QThcXHUxOEFBXFx1MThCMC1cXHUxOEY1XFx1MTkwMC1cXHUxOTFFXFx1MTk0Ni1cXHUxOTZEXFx1MTk3MC1cXHUxOTc0XFx1MTk4MC1cXHUxOUFCXFx1MTlCMC1cXHUxOUM5XFx1MTlEMC1cXHUxOURBXFx1MUEwMC1cXHUxQTE2XFx1MUEyMC1cXHUxQTU0XFx1MUE4MC1cXHUxQTg5XFx1MUE5MC1cXHUxQTk5XFx1MUFBN1xcdTFCMDUtXFx1MUIzM1xcdTFCNDUtXFx1MUI0QlxcdTFCNTAtXFx1MUI1OVxcdTFCODMtXFx1MUJBMFxcdTFCQUUtXFx1MUJFNVxcdTFDMDAtXFx1MUMyM1xcdTFDNDAtXFx1MUM0OVxcdTFDNEQtXFx1MUM3RFxcdTFDODAtXFx1MUM4OFxcdTFDOTAtXFx1MUNCQVxcdTFDQkQtXFx1MUNCRlxcdTFDRTktXFx1MUNFQ1xcdTFDRUUtXFx1MUNGM1xcdTFDRjVcXHUxQ0Y2XFx1MUNGQVxcdTFEMDAtXFx1MURCRlxcdTFFMDAtXFx1MUYxNVxcdTFGMTgtXFx1MUYxRFxcdTFGMjAtXFx1MUY0NVxcdTFGNDgtXFx1MUY0RFxcdTFGNTAtXFx1MUY1N1xcdTFGNTlcXHUxRjVCXFx1MUY1RFxcdTFGNUYtXFx1MUY3RFxcdTFGODAtXFx1MUZCNFxcdTFGQjYtXFx1MUZCQ1xcdTFGQkVcXHUxRkMyLVxcdTFGQzRcXHUxRkM2LVxcdTFGQ0NcXHUxRkQwLVxcdTFGRDNcXHUxRkQ2LVxcdTFGREJcXHUxRkUwLVxcdTFGRUNcXHUxRkYyLVxcdTFGRjRcXHUxRkY2LVxcdTFGRkNcXHUyMDcwXFx1MjA3MVxcdTIwNzQtXFx1MjA3OVxcdTIwN0YtXFx1MjA4OVxcdTIwOTAtXFx1MjA5Q1xcdTIxMDJcXHUyMTA3XFx1MjEwQS1cXHUyMTEzXFx1MjExNVxcdTIxMTktXFx1MjExRFxcdTIxMjRcXHUyMTI2XFx1MjEyOFxcdTIxMkEtXFx1MjEyRFxcdTIxMkYtXFx1MjEzOVxcdTIxM0MtXFx1MjEzRlxcdTIxNDUtXFx1MjE0OVxcdTIxNEVcXHUyMTUwLVxcdTIxODlcXHUyNDYwLVxcdTI0OUJcXHUyNEVBLVxcdTI0RkZcXHUyNzc2LVxcdTI3OTNcXHUyQzAwLVxcdTJDMkVcXHUyQzMwLVxcdTJDNUVcXHUyQzYwLVxcdTJDRTRcXHUyQ0VCLVxcdTJDRUVcXHUyQ0YyXFx1MkNGM1xcdTJDRkRcXHUyRDAwLVxcdTJEMjVcXHUyRDI3XFx1MkQyRFxcdTJEMzAtXFx1MkQ2N1xcdTJENkZcXHUyRDgwLVxcdTJEOTZcXHUyREEwLVxcdTJEQTZcXHUyREE4LVxcdTJEQUVcXHUyREIwLVxcdTJEQjZcXHUyREI4LVxcdTJEQkVcXHUyREMwLVxcdTJEQzZcXHUyREM4LVxcdTJEQ0VcXHUyREQwLVxcdTJERDZcXHUyREQ4LVxcdTJEREVcXHUyRTJGXFx1MzAwNS1cXHUzMDA3XFx1MzAyMS1cXHUzMDI5XFx1MzAzMS1cXHUzMDM1XFx1MzAzOC1cXHUzMDNDXFx1MzA0MS1cXHUzMDk2XFx1MzA5RC1cXHUzMDlGXFx1MzBBMS1cXHUzMEZBXFx1MzBGQy1cXHUzMEZGXFx1MzEwNS1cXHUzMTJGXFx1MzEzMS1cXHUzMThFXFx1MzE5Mi1cXHUzMTk1XFx1MzFBMC1cXHUzMUJGXFx1MzFGMC1cXHUzMUZGXFx1MzIyMC1cXHUzMjI5XFx1MzI0OC1cXHUzMjRGXFx1MzI1MS1cXHUzMjVGXFx1MzI4MC1cXHUzMjg5XFx1MzJCMS1cXHUzMkJGXFx1MzQwMC1cXHU0REJGXFx1NEUwMC1cXHU5RkZDXFx1QTAwMC1cXHVBNDhDXFx1QTREMC1cXHVBNEZEXFx1QTUwMC1cXHVBNjBDXFx1QTYxMC1cXHVBNjJCXFx1QTY0MC1cXHVBNjZFXFx1QTY3Ri1cXHVBNjlEXFx1QTZBMC1cXHVBNkVGXFx1QTcxNy1cXHVBNzFGXFx1QTcyMi1cXHVBNzg4XFx1QTc4Qi1cXHVBN0JGXFx1QTdDMi1cXHVBN0NBXFx1QTdGNS1cXHVBODAxXFx1QTgwMy1cXHVBODA1XFx1QTgwNy1cXHVBODBBXFx1QTgwQy1cXHVBODIyXFx1QTgzMC1cXHVBODM1XFx1QTg0MC1cXHVBODczXFx1QTg4Mi1cXHVBOEIzXFx1QThEMC1cXHVBOEQ5XFx1QThGMi1cXHVBOEY3XFx1QThGQlxcdUE4RkRcXHVBOEZFXFx1QTkwMC1cXHVBOTI1XFx1QTkzMC1cXHVBOTQ2XFx1QTk2MC1cXHVBOTdDXFx1QTk4NC1cXHVBOUIyXFx1QTlDRi1cXHVBOUQ5XFx1QTlFMC1cXHVBOUU0XFx1QTlFNi1cXHVBOUZFXFx1QUEwMC1cXHVBQTI4XFx1QUE0MC1cXHVBQTQyXFx1QUE0NC1cXHVBQTRCXFx1QUE1MC1cXHVBQTU5XFx1QUE2MC1cXHVBQTc2XFx1QUE3QVxcdUFBN0UtXFx1QUFBRlxcdUFBQjFcXHVBQUI1XFx1QUFCNlxcdUFBQjktXFx1QUFCRFxcdUFBQzBcXHVBQUMyXFx1QUFEQi1cXHVBQUREXFx1QUFFMC1cXHVBQUVBXFx1QUFGMi1cXHVBQUY0XFx1QUIwMS1cXHVBQjA2XFx1QUIwOS1cXHVBQjBFXFx1QUIxMS1cXHVBQjE2XFx1QUIyMC1cXHVBQjI2XFx1QUIyOC1cXHVBQjJFXFx1QUIzMC1cXHVBQjVBXFx1QUI1Qy1cXHVBQjY5XFx1QUI3MC1cXHVBQkUyXFx1QUJGMC1cXHVBQkY5XFx1QUMwMC1cXHVEN0EzXFx1RDdCMC1cXHVEN0M2XFx1RDdDQi1cXHVEN0ZCXFx1RjkwMC1cXHVGQTZEXFx1RkE3MC1cXHVGQUQ5XFx1RkIwMC1cXHVGQjA2XFx1RkIxMy1cXHVGQjE3XFx1RkIxRFxcdUZCMUYtXFx1RkIyOFxcdUZCMkEtXFx1RkIzNlxcdUZCMzgtXFx1RkIzQ1xcdUZCM0VcXHVGQjQwXFx1RkI0MVxcdUZCNDNcXHVGQjQ0XFx1RkI0Ni1cXHVGQkIxXFx1RkJEMy1cXHVGRDNEXFx1RkQ1MC1cXHVGRDhGXFx1RkQ5Mi1cXHVGREM3XFx1RkRGMC1cXHVGREZCXFx1RkU3MC1cXHVGRTc0XFx1RkU3Ni1cXHVGRUZDXFx1RkYxMC1cXHVGRjE5XFx1RkYyMS1cXHVGRjNBXFx1RkY0MS1cXHVGRjVBXFx1RkY2Ni1cXHVGRkJFXFx1RkZDMi1cXHVGRkM3XFx1RkZDQS1cXHVGRkNGXFx1RkZEMi1cXHVGRkQ3XFx1RkZEQS1cXHVGRkRDXXxcXHVEODAwW1xcdURDMDAtXFx1REMwQlxcdURDMEQtXFx1REMyNlxcdURDMjgtXFx1REMzQVxcdURDM0NcXHVEQzNEXFx1REMzRi1cXHVEQzREXFx1REM1MC1cXHVEQzVEXFx1REM4MC1cXHVEQ0ZBXFx1REQwNy1cXHVERDMzXFx1REQ0MC1cXHVERDc4XFx1REQ4QVxcdUREOEJcXHVERTgwLVxcdURFOUNcXHVERUEwLVxcdURFRDBcXHVERUUxLVxcdURFRkJcXHVERjAwLVxcdURGMjNcXHVERjJELVxcdURGNEFcXHVERjUwLVxcdURGNzVcXHVERjgwLVxcdURGOURcXHVERkEwLVxcdURGQzNcXHVERkM4LVxcdURGQ0ZcXHVERkQxLVxcdURGRDVdfFxcdUQ4MDFbXFx1REMwMC1cXHVEQzlEXFx1RENBMC1cXHVEQ0E5XFx1RENCMC1cXHVEQ0QzXFx1RENEOC1cXHVEQ0ZCXFx1REQwMC1cXHVERDI3XFx1REQzMC1cXHVERDYzXFx1REUwMC1cXHVERjM2XFx1REY0MC1cXHVERjU1XFx1REY2MC1cXHVERjY3XXxcXHVEODAyW1xcdURDMDAtXFx1REMwNVxcdURDMDhcXHVEQzBBLVxcdURDMzVcXHVEQzM3XFx1REMzOFxcdURDM0NcXHVEQzNGLVxcdURDNTVcXHVEQzU4LVxcdURDNzZcXHVEQzc5LVxcdURDOUVcXHVEQ0E3LVxcdURDQUZcXHVEQ0UwLVxcdURDRjJcXHVEQ0Y0XFx1RENGNVxcdURDRkItXFx1REQxQlxcdUREMjAtXFx1REQzOVxcdUREODAtXFx1RERCN1xcdUREQkMtXFx1RERDRlxcdURERDItXFx1REUwMFxcdURFMTAtXFx1REUxM1xcdURFMTUtXFx1REUxN1xcdURFMTktXFx1REUzNVxcdURFNDAtXFx1REU0OFxcdURFNjAtXFx1REU3RVxcdURFODAtXFx1REU5RlxcdURFQzAtXFx1REVDN1xcdURFQzktXFx1REVFNFxcdURFRUItXFx1REVFRlxcdURGMDAtXFx1REYzNVxcdURGNDAtXFx1REY1NVxcdURGNTgtXFx1REY3MlxcdURGNzgtXFx1REY5MVxcdURGQTktXFx1REZBRl18XFx1RDgwM1tcXHVEQzAwLVxcdURDNDhcXHVEQzgwLVxcdURDQjJcXHVEQ0MwLVxcdURDRjJcXHVEQ0ZBLVxcdUREMjNcXHVERDMwLVxcdUREMzlcXHVERTYwLVxcdURFN0VcXHVERTgwLVxcdURFQTlcXHVERUIwXFx1REVCMVxcdURGMDAtXFx1REYyN1xcdURGMzAtXFx1REY0NVxcdURGNTEtXFx1REY1NFxcdURGQjAtXFx1REZDQlxcdURGRTAtXFx1REZGNl18XFx1RDgwNFtcXHVEQzAzLVxcdURDMzdcXHVEQzUyLVxcdURDNkZcXHVEQzgzLVxcdURDQUZcXHVEQ0QwLVxcdURDRThcXHVEQ0YwLVxcdURDRjlcXHVERDAzLVxcdUREMjZcXHVERDM2LVxcdUREM0ZcXHVERDQ0XFx1REQ0N1xcdURENTAtXFx1REQ3MlxcdURENzZcXHVERDgzLVxcdUREQjJcXHVEREMxLVxcdUREQzRcXHVEREQwLVxcdUREREFcXHVERERDXFx1RERFMS1cXHVEREY0XFx1REUwMC1cXHVERTExXFx1REUxMy1cXHVERTJCXFx1REU4MC1cXHVERTg2XFx1REU4OFxcdURFOEEtXFx1REU4RFxcdURFOEYtXFx1REU5RFxcdURFOUYtXFx1REVBOFxcdURFQjAtXFx1REVERVxcdURFRjAtXFx1REVGOVxcdURGMDUtXFx1REYwQ1xcdURGMEZcXHVERjEwXFx1REYxMy1cXHVERjI4XFx1REYyQS1cXHVERjMwXFx1REYzMlxcdURGMzNcXHVERjM1LVxcdURGMzlcXHVERjNEXFx1REY1MFxcdURGNUQtXFx1REY2MV18XFx1RDgwNVtcXHVEQzAwLVxcdURDMzRcXHVEQzQ3LVxcdURDNEFcXHVEQzUwLVxcdURDNTlcXHVEQzVGLVxcdURDNjFcXHVEQzgwLVxcdURDQUZcXHVEQ0M0XFx1RENDNVxcdURDQzdcXHVEQ0QwLVxcdURDRDlcXHVERDgwLVxcdUREQUVcXHVEREQ4LVxcdUREREJcXHVERTAwLVxcdURFMkZcXHVERTQ0XFx1REU1MC1cXHVERTU5XFx1REU4MC1cXHVERUFBXFx1REVCOFxcdURFQzAtXFx1REVDOVxcdURGMDAtXFx1REYxQVxcdURGMzAtXFx1REYzQl18XFx1RDgwNltcXHVEQzAwLVxcdURDMkJcXHVEQ0EwLVxcdURDRjJcXHVEQ0ZGLVxcdUREMDZcXHVERDA5XFx1REQwQy1cXHVERDEzXFx1REQxNVxcdUREMTZcXHVERDE4LVxcdUREMkZcXHVERDNGXFx1REQ0MVxcdURENTAtXFx1REQ1OVxcdUREQTAtXFx1RERBN1xcdUREQUEtXFx1REREMFxcdURERTFcXHVEREUzXFx1REUwMFxcdURFMEItXFx1REUzMlxcdURFM0FcXHVERTUwXFx1REU1Qy1cXHVERTg5XFx1REU5RFxcdURFQzAtXFx1REVGOF18XFx1RDgwN1tcXHVEQzAwLVxcdURDMDhcXHVEQzBBLVxcdURDMkVcXHVEQzQwXFx1REM1MC1cXHVEQzZDXFx1REM3Mi1cXHVEQzhGXFx1REQwMC1cXHVERDA2XFx1REQwOFxcdUREMDlcXHVERDBCLVxcdUREMzBcXHVERDQ2XFx1REQ1MC1cXHVERDU5XFx1REQ2MC1cXHVERDY1XFx1REQ2N1xcdURENjhcXHVERDZBLVxcdUREODlcXHVERDk4XFx1RERBMC1cXHVEREE5XFx1REVFMC1cXHVERUYyXFx1REZCMFxcdURGQzAtXFx1REZENF18XFx1RDgwOFtcXHVEQzAwLVxcdURGOTldfFxcdUQ4MDlbXFx1REMwMC1cXHVEQzZFXFx1REM4MC1cXHVERDQzXXxbXFx1RDgwQ1xcdUQ4MUMtXFx1RDgyMFxcdUQ4MjJcXHVEODQwLVxcdUQ4NjhcXHVEODZBLVxcdUQ4NkNcXHVEODZGLVxcdUQ4NzJcXHVEODc0LVxcdUQ4NzlcXHVEODgwLVxcdUQ4ODNdW1xcdURDMDAtXFx1REZGRl18XFx1RDgwRFtcXHVEQzAwLVxcdURDMkVdfFxcdUQ4MTFbXFx1REMwMC1cXHVERTQ2XXxcXHVEODFBW1xcdURDMDAtXFx1REUzOFxcdURFNDAtXFx1REU1RVxcdURFNjAtXFx1REU2OVxcdURFRDAtXFx1REVFRFxcdURGMDAtXFx1REYyRlxcdURGNDAtXFx1REY0M1xcdURGNTAtXFx1REY1OVxcdURGNUItXFx1REY2MVxcdURGNjMtXFx1REY3N1xcdURGN0QtXFx1REY4Rl18XFx1RDgxQltcXHVERTQwLVxcdURFOTZcXHVERjAwLVxcdURGNEFcXHVERjUwXFx1REY5My1cXHVERjlGXFx1REZFMFxcdURGRTFcXHVERkUzXXxcXHVEODIxW1xcdURDMDAtXFx1REZGN118XFx1RDgyM1tcXHVEQzAwLVxcdURDRDVcXHVERDAwLVxcdUREMDhdfFxcdUQ4MkNbXFx1REMwMC1cXHVERDFFXFx1REQ1MC1cXHVERDUyXFx1REQ2NC1cXHVERDY3XFx1REQ3MC1cXHVERUZCXXxcXHVEODJGW1xcdURDMDAtXFx1REM2QVxcdURDNzAtXFx1REM3Q1xcdURDODAtXFx1REM4OFxcdURDOTAtXFx1REM5OV18XFx1RDgzNFtcXHVERUUwLVxcdURFRjNcXHVERjYwLVxcdURGNzhdfFxcdUQ4MzVbXFx1REMwMC1cXHVEQzU0XFx1REM1Ni1cXHVEQzlDXFx1REM5RVxcdURDOUZcXHVEQ0EyXFx1RENBNVxcdURDQTZcXHVEQ0E5LVxcdURDQUNcXHVEQ0FFLVxcdURDQjlcXHVEQ0JCXFx1RENCRC1cXHVEQ0MzXFx1RENDNS1cXHVERDA1XFx1REQwNy1cXHVERDBBXFx1REQwRC1cXHVERDE0XFx1REQxNi1cXHVERDFDXFx1REQxRS1cXHVERDM5XFx1REQzQi1cXHVERDNFXFx1REQ0MC1cXHVERDQ0XFx1REQ0NlxcdURENEEtXFx1REQ1MFxcdURENTItXFx1REVBNVxcdURFQTgtXFx1REVDMFxcdURFQzItXFx1REVEQVxcdURFREMtXFx1REVGQVxcdURFRkMtXFx1REYxNFxcdURGMTYtXFx1REYzNFxcdURGMzYtXFx1REY0RVxcdURGNTAtXFx1REY2RVxcdURGNzAtXFx1REY4OFxcdURGOEEtXFx1REZBOFxcdURGQUEtXFx1REZDMlxcdURGQzQtXFx1REZDQlxcdURGQ0UtXFx1REZGRl18XFx1RDgzOFtcXHVERDAwLVxcdUREMkNcXHVERDM3LVxcdUREM0RcXHVERDQwLVxcdURENDlcXHVERDRFXFx1REVDMC1cXHVERUVCXFx1REVGMC1cXHVERUY5XXxcXHVEODNBW1xcdURDMDAtXFx1RENDNFxcdURDQzctXFx1RENDRlxcdUREMDAtXFx1REQ0M1xcdURENEJcXHVERDUwLVxcdURENTldfFxcdUQ4M0JbXFx1REM3MS1cXHVEQ0FCXFx1RENBRC1cXHVEQ0FGXFx1RENCMS1cXHVEQ0I0XFx1REQwMS1cXHVERDJEXFx1REQyRi1cXHVERDNEXFx1REUwMC1cXHVERTAzXFx1REUwNS1cXHVERTFGXFx1REUyMVxcdURFMjJcXHVERTI0XFx1REUyN1xcdURFMjktXFx1REUzMlxcdURFMzQtXFx1REUzN1xcdURFMzlcXHVERTNCXFx1REU0MlxcdURFNDdcXHVERTQ5XFx1REU0QlxcdURFNEQtXFx1REU0RlxcdURFNTFcXHVERTUyXFx1REU1NFxcdURFNTdcXHVERTU5XFx1REU1QlxcdURFNURcXHVERTVGXFx1REU2MVxcdURFNjJcXHVERTY0XFx1REU2Ny1cXHVERTZBXFx1REU2Qy1cXHVERTcyXFx1REU3NC1cXHVERTc3XFx1REU3OS1cXHVERTdDXFx1REU3RVxcdURFODAtXFx1REU4OVxcdURFOEItXFx1REU5QlxcdURFQTEtXFx1REVBM1xcdURFQTUtXFx1REVBOVxcdURFQUItXFx1REVCQl18XFx1RDgzQ1tcXHVERDAwLVxcdUREMENdfFxcdUQ4M0VbXFx1REZGMC1cXHVERkY5XXxcXHVEODY5W1xcdURDMDAtXFx1REVERFxcdURGMDAtXFx1REZGRl18XFx1RDg2RFtcXHVEQzAwLVxcdURGMzRcXHVERjQwLVxcdURGRkZdfFxcdUQ4NkVbXFx1REMwMC1cXHVEQzFEXFx1REMyMC1cXHVERkZGXXxcXHVEODczW1xcdURDMDAtXFx1REVBMVxcdURFQjAtXFx1REZGRl18XFx1RDg3QVtcXHVEQzAwLVxcdURGRTBdfFxcdUQ4N0VbXFx1REMwMC1cXHVERTFEXXxcXHVEODg0W1xcdURDMDAtXFx1REY0QV0pLykpIHJldHVybjtcbiAgICAgIHZhciBuZXh0Q2hhciA9IG1hdGNoWzFdIHx8IG1hdGNoWzJdIHx8ICcnO1xuXG4gICAgICBpZiAoIW5leHRDaGFyIHx8IG5leHRDaGFyICYmIChwcmV2Q2hhciA9PT0gJycgfHwgdGhpcy5ydWxlcy5pbmxpbmUucHVuY3R1YXRpb24uZXhlYyhwcmV2Q2hhcikpKSB7XG4gICAgICAgIHZhciBsTGVuZ3RoID0gbWF0Y2hbMF0ubGVuZ3RoIC0gMTtcbiAgICAgICAgdmFyIHJEZWxpbSxcbiAgICAgICAgICAgIHJMZW5ndGgsXG4gICAgICAgICAgICBkZWxpbVRvdGFsID0gbExlbmd0aCxcbiAgICAgICAgICAgIG1pZERlbGltVG90YWwgPSAwO1xuICAgICAgICB2YXIgZW5kUmVnID0gbWF0Y2hbMF1bMF0gPT09ICcqJyA/IHRoaXMucnVsZXMuaW5saW5lLmVtU3Ryb25nLnJEZWxpbUFzdCA6IHRoaXMucnVsZXMuaW5saW5lLmVtU3Ryb25nLnJEZWxpbVVuZDtcbiAgICAgICAgZW5kUmVnLmxhc3RJbmRleCA9IDA7IC8vIENsaXAgbWFza2VkU3JjIHRvIHNhbWUgc2VjdGlvbiBvZiBzdHJpbmcgYXMgc3JjIChtb3ZlIHRvIGxleGVyPylcblxuICAgICAgICBtYXNrZWRTcmMgPSBtYXNrZWRTcmMuc2xpY2UoLTEgKiBzcmMubGVuZ3RoICsgbExlbmd0aCk7XG5cbiAgICAgICAgd2hpbGUgKChtYXRjaCA9IGVuZFJlZy5leGVjKG1hc2tlZFNyYykpICE9IG51bGwpIHtcbiAgICAgICAgICByRGVsaW0gPSBtYXRjaFsxXSB8fCBtYXRjaFsyXSB8fCBtYXRjaFszXSB8fCBtYXRjaFs0XSB8fCBtYXRjaFs1XSB8fCBtYXRjaFs2XTtcbiAgICAgICAgICBpZiAoIXJEZWxpbSkgY29udGludWU7IC8vIHNraXAgc2luZ2xlICogaW4gX19hYmMqYWJjX19cblxuICAgICAgICAgIHJMZW5ndGggPSByRGVsaW0ubGVuZ3RoO1xuXG4gICAgICAgICAgaWYgKG1hdGNoWzNdIHx8IG1hdGNoWzRdKSB7XG4gICAgICAgICAgICAvLyBmb3VuZCBhbm90aGVyIExlZnQgRGVsaW1cbiAgICAgICAgICAgIGRlbGltVG90YWwgKz0gckxlbmd0aDtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH0gZWxzZSBpZiAobWF0Y2hbNV0gfHwgbWF0Y2hbNl0pIHtcbiAgICAgICAgICAgIC8vIGVpdGhlciBMZWZ0IG9yIFJpZ2h0IERlbGltXG4gICAgICAgICAgICBpZiAobExlbmd0aCAlIDMgJiYgISgobExlbmd0aCArIHJMZW5ndGgpICUgMykpIHtcbiAgICAgICAgICAgICAgbWlkRGVsaW1Ub3RhbCArPSByTGVuZ3RoO1xuICAgICAgICAgICAgICBjb250aW51ZTsgLy8gQ29tbW9uTWFyayBFbXBoYXNpcyBSdWxlcyA5LTEwXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZGVsaW1Ub3RhbCAtPSByTGVuZ3RoO1xuICAgICAgICAgIGlmIChkZWxpbVRvdGFsID4gMCkgY29udGludWU7IC8vIEhhdmVuJ3QgZm91bmQgZW5vdWdoIGNsb3NpbmcgZGVsaW1pdGVyc1xuICAgICAgICAgIC8vIFJlbW92ZSBleHRyYSBjaGFyYWN0ZXJzLiAqYSoqKiAtPiAqYSpcblxuICAgICAgICAgIHJMZW5ndGggPSBNYXRoLm1pbihyTGVuZ3RoLCByTGVuZ3RoICsgZGVsaW1Ub3RhbCArIG1pZERlbGltVG90YWwpOyAvLyBDcmVhdGUgYGVtYCBpZiBzbWFsbGVzdCBkZWxpbWl0ZXIgaGFzIG9kZCBjaGFyIGNvdW50LiAqYSoqKlxuXG4gICAgICAgICAgaWYgKE1hdGgubWluKGxMZW5ndGgsIHJMZW5ndGgpICUgMikge1xuICAgICAgICAgICAgdmFyIF90ZXh0ID0gc3JjLnNsaWNlKDEsIGxMZW5ndGggKyBtYXRjaC5pbmRleCArIHJMZW5ndGgpO1xuXG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICB0eXBlOiAnZW0nLFxuICAgICAgICAgICAgICByYXc6IHNyYy5zbGljZSgwLCBsTGVuZ3RoICsgbWF0Y2guaW5kZXggKyByTGVuZ3RoICsgMSksXG4gICAgICAgICAgICAgIHRleHQ6IF90ZXh0LFxuICAgICAgICAgICAgICB0b2tlbnM6IHRoaXMubGV4ZXIuaW5saW5lVG9rZW5zKF90ZXh0LCBbXSlcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfSAvLyBDcmVhdGUgJ3N0cm9uZycgaWYgc21hbGxlc3QgZGVsaW1pdGVyIGhhcyBldmVuIGNoYXIgY291bnQuICoqYSoqKlxuXG5cbiAgICAgICAgICB2YXIgdGV4dCA9IHNyYy5zbGljZSgyLCBsTGVuZ3RoICsgbWF0Y2guaW5kZXggKyByTGVuZ3RoIC0gMSk7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6ICdzdHJvbmcnLFxuICAgICAgICAgICAgcmF3OiBzcmMuc2xpY2UoMCwgbExlbmd0aCArIG1hdGNoLmluZGV4ICsgckxlbmd0aCArIDEpLFxuICAgICAgICAgICAgdGV4dDogdGV4dCxcbiAgICAgICAgICAgIHRva2VuczogdGhpcy5sZXhlci5pbmxpbmVUb2tlbnModGV4dCwgW10pXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICBfcHJvdG8uY29kZXNwYW4gPSBmdW5jdGlvbiBjb2Rlc3BhbihzcmMpIHtcbiAgICAgIHZhciBjYXAgPSB0aGlzLnJ1bGVzLmlubGluZS5jb2RlLmV4ZWMoc3JjKTtcblxuICAgICAgaWYgKGNhcCkge1xuICAgICAgICB2YXIgdGV4dCA9IGNhcFsyXS5yZXBsYWNlKC9cXG4vZywgJyAnKTtcbiAgICAgICAgdmFyIGhhc05vblNwYWNlQ2hhcnMgPSAvW14gXS8udGVzdCh0ZXh0KTtcbiAgICAgICAgdmFyIGhhc1NwYWNlQ2hhcnNPbkJvdGhFbmRzID0gL14gLy50ZXN0KHRleHQpICYmIC8gJC8udGVzdCh0ZXh0KTtcblxuICAgICAgICBpZiAoaGFzTm9uU3BhY2VDaGFycyAmJiBoYXNTcGFjZUNoYXJzT25Cb3RoRW5kcykge1xuICAgICAgICAgIHRleHQgPSB0ZXh0LnN1YnN0cmluZygxLCB0ZXh0Lmxlbmd0aCAtIDEpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGV4dCA9IF9lc2NhcGUodGV4dCwgdHJ1ZSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdHlwZTogJ2NvZGVzcGFuJyxcbiAgICAgICAgICByYXc6IGNhcFswXSxcbiAgICAgICAgICB0ZXh0OiB0ZXh0XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfTtcblxuICAgIF9wcm90by5iciA9IGZ1bmN0aW9uIGJyKHNyYykge1xuICAgICAgdmFyIGNhcCA9IHRoaXMucnVsZXMuaW5saW5lLmJyLmV4ZWMoc3JjKTtcblxuICAgICAgaWYgKGNhcCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHR5cGU6ICdicicsXG4gICAgICAgICAgcmF3OiBjYXBbMF1cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgX3Byb3RvLmRlbCA9IGZ1bmN0aW9uIGRlbChzcmMpIHtcbiAgICAgIHZhciBjYXAgPSB0aGlzLnJ1bGVzLmlubGluZS5kZWwuZXhlYyhzcmMpO1xuXG4gICAgICBpZiAoY2FwKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdHlwZTogJ2RlbCcsXG4gICAgICAgICAgcmF3OiBjYXBbMF0sXG4gICAgICAgICAgdGV4dDogY2FwWzJdLFxuICAgICAgICAgIHRva2VuczogdGhpcy5sZXhlci5pbmxpbmVUb2tlbnMoY2FwWzJdLCBbXSlcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgX3Byb3RvLmF1dG9saW5rID0gZnVuY3Rpb24gYXV0b2xpbmsoc3JjLCBtYW5nbGUpIHtcbiAgICAgIHZhciBjYXAgPSB0aGlzLnJ1bGVzLmlubGluZS5hdXRvbGluay5leGVjKHNyYyk7XG5cbiAgICAgIGlmIChjYXApIHtcbiAgICAgICAgdmFyIHRleHQsIGhyZWY7XG5cbiAgICAgICAgaWYgKGNhcFsyXSA9PT0gJ0AnKSB7XG4gICAgICAgICAgdGV4dCA9IF9lc2NhcGUodGhpcy5vcHRpb25zLm1hbmdsZSA/IG1hbmdsZShjYXBbMV0pIDogY2FwWzFdKTtcbiAgICAgICAgICBocmVmID0gJ21haWx0bzonICsgdGV4dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0ZXh0ID0gX2VzY2FwZShjYXBbMV0pO1xuICAgICAgICAgIGhyZWYgPSB0ZXh0O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0eXBlOiAnbGluaycsXG4gICAgICAgICAgcmF3OiBjYXBbMF0sXG4gICAgICAgICAgdGV4dDogdGV4dCxcbiAgICAgICAgICBocmVmOiBocmVmLFxuICAgICAgICAgIHRva2VuczogW3tcbiAgICAgICAgICAgIHR5cGU6ICd0ZXh0JyxcbiAgICAgICAgICAgIHJhdzogdGV4dCxcbiAgICAgICAgICAgIHRleHQ6IHRleHRcbiAgICAgICAgICB9XVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH07XG5cbiAgICBfcHJvdG8udXJsID0gZnVuY3Rpb24gdXJsKHNyYywgbWFuZ2xlKSB7XG4gICAgICB2YXIgY2FwO1xuXG4gICAgICBpZiAoY2FwID0gdGhpcy5ydWxlcy5pbmxpbmUudXJsLmV4ZWMoc3JjKSkge1xuICAgICAgICB2YXIgdGV4dCwgaHJlZjtcblxuICAgICAgICBpZiAoY2FwWzJdID09PSAnQCcpIHtcbiAgICAgICAgICB0ZXh0ID0gX2VzY2FwZSh0aGlzLm9wdGlvbnMubWFuZ2xlID8gbWFuZ2xlKGNhcFswXSkgOiBjYXBbMF0pO1xuICAgICAgICAgIGhyZWYgPSAnbWFpbHRvOicgKyB0ZXh0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIGRvIGV4dGVuZGVkIGF1dG9saW5rIHBhdGggdmFsaWRhdGlvblxuICAgICAgICAgIHZhciBwcmV2Q2FwWmVybztcblxuICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgIHByZXZDYXBaZXJvID0gY2FwWzBdO1xuICAgICAgICAgICAgY2FwWzBdID0gdGhpcy5ydWxlcy5pbmxpbmUuX2JhY2twZWRhbC5leGVjKGNhcFswXSlbMF07XG4gICAgICAgICAgfSB3aGlsZSAocHJldkNhcFplcm8gIT09IGNhcFswXSk7XG5cbiAgICAgICAgICB0ZXh0ID0gX2VzY2FwZShjYXBbMF0pO1xuXG4gICAgICAgICAgaWYgKGNhcFsxXSA9PT0gJ3d3dy4nKSB7XG4gICAgICAgICAgICBocmVmID0gJ2h0dHA6Ly8nICsgdGV4dDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaHJlZiA9IHRleHQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0eXBlOiAnbGluaycsXG4gICAgICAgICAgcmF3OiBjYXBbMF0sXG4gICAgICAgICAgdGV4dDogdGV4dCxcbiAgICAgICAgICBocmVmOiBocmVmLFxuICAgICAgICAgIHRva2VuczogW3tcbiAgICAgICAgICAgIHR5cGU6ICd0ZXh0JyxcbiAgICAgICAgICAgIHJhdzogdGV4dCxcbiAgICAgICAgICAgIHRleHQ6IHRleHRcbiAgICAgICAgICB9XVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH07XG5cbiAgICBfcHJvdG8uaW5saW5lVGV4dCA9IGZ1bmN0aW9uIGlubGluZVRleHQoc3JjLCBzbWFydHlwYW50cykge1xuICAgICAgdmFyIGNhcCA9IHRoaXMucnVsZXMuaW5saW5lLnRleHQuZXhlYyhzcmMpO1xuXG4gICAgICBpZiAoY2FwKSB7XG4gICAgICAgIHZhciB0ZXh0O1xuXG4gICAgICAgIGlmICh0aGlzLmxleGVyLnN0YXRlLmluUmF3QmxvY2spIHtcbiAgICAgICAgICB0ZXh0ID0gdGhpcy5vcHRpb25zLnNhbml0aXplID8gdGhpcy5vcHRpb25zLnNhbml0aXplciA/IHRoaXMub3B0aW9ucy5zYW5pdGl6ZXIoY2FwWzBdKSA6IF9lc2NhcGUoY2FwWzBdKSA6IGNhcFswXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0ZXh0ID0gX2VzY2FwZSh0aGlzLm9wdGlvbnMuc21hcnR5cGFudHMgPyBzbWFydHlwYW50cyhjYXBbMF0pIDogY2FwWzBdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdHlwZTogJ3RleHQnLFxuICAgICAgICAgIHJhdzogY2FwWzBdLFxuICAgICAgICAgIHRleHQ6IHRleHRcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgcmV0dXJuIFRva2VuaXplcjtcbiAgfSgpO1xuXG4gIHZhciBub29wVGVzdCA9IGhlbHBlcnMubm9vcFRlc3QsXG4gICAgICBlZGl0ID0gaGVscGVycy5lZGl0LFxuICAgICAgbWVyZ2UkMSA9IGhlbHBlcnMubWVyZ2U7XG4gIC8qKlxuICAgKiBCbG9jay1MZXZlbCBHcmFtbWFyXG4gICAqL1xuXG4gIHZhciBibG9jayQxID0ge1xuICAgIG5ld2xpbmU6IC9eKD86ICooPzpcXG58JCkpKy8sXG4gICAgY29kZTogL14oIHs0fVteXFxuXSsoPzpcXG4oPzogKig/OlxcbnwkKSkqKT8pKy8sXG4gICAgZmVuY2VzOiAvXiB7MCwzfShgezMsfSg/PVteYFxcbl0qXFxuKXx+ezMsfSkoW15cXG5dKilcXG4oPzp8KFtcXHNcXFNdKj8pXFxuKSg/OiB7MCwzfVxcMVt+YF0qICooPz1cXG58JCl8JCkvLFxuICAgIGhyOiAvXiB7MCwzfSgoPzotICopezMsfXwoPzpfICopezMsfXwoPzpcXCogKil7Myx9KSg/Olxcbit8JCkvLFxuICAgIGhlYWRpbmc6IC9eIHswLDN9KCN7MSw2fSkoPz1cXHN8JCkoLiopKD86XFxuK3wkKS8sXG4gICAgYmxvY2txdW90ZTogL14oIHswLDN9PiA/KHBhcmFncmFwaHxbXlxcbl0qKSg/OlxcbnwkKSkrLyxcbiAgICBsaXN0OiAvXiggezAsM31idWxsKSggW15cXG5dKz8pPyg/OlxcbnwkKS8sXG4gICAgaHRtbDogJ14gezAsM30oPzonIC8vIG9wdGlvbmFsIGluZGVudGF0aW9uXG4gICAgKyAnPChzY3JpcHR8cHJlfHN0eWxlfHRleHRhcmVhKVtcXFxccz5dW1xcXFxzXFxcXFNdKj8oPzo8L1xcXFwxPlteXFxcXG5dKlxcXFxuK3wkKScgLy8gKDEpXG4gICAgKyAnfGNvbW1lbnRbXlxcXFxuXSooXFxcXG4rfCQpJyAvLyAoMilcbiAgICArICd8PFxcXFw/W1xcXFxzXFxcXFNdKj8oPzpcXFxcPz5cXFxcbip8JCknIC8vICgzKVxuICAgICsgJ3w8IVtBLVpdW1xcXFxzXFxcXFNdKj8oPzo+XFxcXG4qfCQpJyAvLyAoNClcbiAgICArICd8PCFcXFxcW0NEQVRBXFxcXFtbXFxcXHNcXFxcU10qPyg/OlxcXFxdXFxcXF0+XFxcXG4qfCQpJyAvLyAoNSlcbiAgICArICd8PC8/KHRhZykoPzogK3xcXFxcbnwvPz4pW1xcXFxzXFxcXFNdKj8oPzooPzpcXFxcbiAqKStcXFxcbnwkKScgLy8gKDYpXG4gICAgKyAnfDwoPyFzY3JpcHR8cHJlfHN0eWxlfHRleHRhcmVhKShbYS16XVtcXFxcdy1dKikoPzphdHRyaWJ1dGUpKj8gKi8/Pig/PVsgXFxcXHRdKig/OlxcXFxufCQpKVtcXFxcc1xcXFxTXSo/KD86KD86XFxcXG4gKikrXFxcXG58JCknIC8vICg3KSBvcGVuIHRhZ1xuICAgICsgJ3w8Lyg/IXNjcmlwdHxwcmV8c3R5bGV8dGV4dGFyZWEpW2Etel1bXFxcXHctXSpcXFxccyo+KD89WyBcXFxcdF0qKD86XFxcXG58JCkpW1xcXFxzXFxcXFNdKj8oPzooPzpcXFxcbiAqKStcXFxcbnwkKScgLy8gKDcpIGNsb3NpbmcgdGFnXG4gICAgKyAnKScsXG4gICAgZGVmOiAvXiB7MCwzfVxcWyhsYWJlbClcXF06ICpcXG4/ICo8PyhbXlxccz5dKyk+Pyg/Oig/OiArXFxuPyAqfCAqXFxuICopKHRpdGxlKSk/ICooPzpcXG4rfCQpLyxcbiAgICB0YWJsZTogbm9vcFRlc3QsXG4gICAgbGhlYWRpbmc6IC9eKFteXFxuXSspXFxuIHswLDN9KD0rfC0rKSAqKD86XFxuK3wkKS8sXG4gICAgLy8gcmVnZXggdGVtcGxhdGUsIHBsYWNlaG9sZGVycyB3aWxsIGJlIHJlcGxhY2VkIGFjY29yZGluZyB0byBkaWZmZXJlbnQgcGFyYWdyYXBoXG4gICAgLy8gaW50ZXJydXB0aW9uIHJ1bGVzIG9mIGNvbW1vbm1hcmsgYW5kIHRoZSBvcmlnaW5hbCBtYXJrZG93biBzcGVjOlxuICAgIF9wYXJhZ3JhcGg6IC9eKFteXFxuXSsoPzpcXG4oPyFocnxoZWFkaW5nfGxoZWFkaW5nfGJsb2NrcXVvdGV8ZmVuY2VzfGxpc3R8aHRtbHwgK1xcbilbXlxcbl0rKSopLyxcbiAgICB0ZXh0OiAvXlteXFxuXSsvXG4gIH07XG4gIGJsb2NrJDEuX2xhYmVsID0gLyg/IVxccypcXF0pKD86XFxcXFtcXFtcXF1dfFteXFxbXFxdXSkrLztcbiAgYmxvY2skMS5fdGl0bGUgPSAvKD86XCIoPzpcXFxcXCI/fFteXCJcXFxcXSkqXCJ8J1teJ1xcbl0qKD86XFxuW14nXFxuXSspKlxcbj8nfFxcKFteKCldKlxcKSkvO1xuICBibG9jayQxLmRlZiA9IGVkaXQoYmxvY2skMS5kZWYpLnJlcGxhY2UoJ2xhYmVsJywgYmxvY2skMS5fbGFiZWwpLnJlcGxhY2UoJ3RpdGxlJywgYmxvY2skMS5fdGl0bGUpLmdldFJlZ2V4KCk7XG4gIGJsb2NrJDEuYnVsbGV0ID0gLyg/OlsqKy1dfFxcZHsxLDl9Wy4pXSkvO1xuICBibG9jayQxLmxpc3RJdGVtU3RhcnQgPSBlZGl0KC9eKCAqKShidWxsKSAqLykucmVwbGFjZSgnYnVsbCcsIGJsb2NrJDEuYnVsbGV0KS5nZXRSZWdleCgpO1xuICBibG9jayQxLmxpc3QgPSBlZGl0KGJsb2NrJDEubGlzdCkucmVwbGFjZSgvYnVsbC9nLCBibG9jayQxLmJ1bGxldCkucmVwbGFjZSgnaHInLCAnXFxcXG4rKD89XFxcXDE/KD86KD86LSAqKXszLH18KD86XyAqKXszLH18KD86XFxcXCogKil7Myx9KSg/OlxcXFxuK3wkKSknKS5yZXBsYWNlKCdkZWYnLCAnXFxcXG4rKD89JyArIGJsb2NrJDEuZGVmLnNvdXJjZSArICcpJykuZ2V0UmVnZXgoKTtcbiAgYmxvY2skMS5fdGFnID0gJ2FkZHJlc3N8YXJ0aWNsZXxhc2lkZXxiYXNlfGJhc2Vmb250fGJsb2NrcXVvdGV8Ym9keXxjYXB0aW9uJyArICd8Y2VudGVyfGNvbHxjb2xncm91cHxkZHxkZXRhaWxzfGRpYWxvZ3xkaXJ8ZGl2fGRsfGR0fGZpZWxkc2V0fGZpZ2NhcHRpb24nICsgJ3xmaWd1cmV8Zm9vdGVyfGZvcm18ZnJhbWV8ZnJhbWVzZXR8aFsxLTZdfGhlYWR8aGVhZGVyfGhyfGh0bWx8aWZyYW1lJyArICd8bGVnZW5kfGxpfGxpbmt8bWFpbnxtZW51fG1lbnVpdGVtfG1ldGF8bmF2fG5vZnJhbWVzfG9sfG9wdGdyb3VwfG9wdGlvbicgKyAnfHB8cGFyYW18c2VjdGlvbnxzb3VyY2V8c3VtbWFyeXx0YWJsZXx0Ym9keXx0ZHx0Zm9vdHx0aHx0aGVhZHx0aXRsZXx0cicgKyAnfHRyYWNrfHVsJztcbiAgYmxvY2skMS5fY29tbWVudCA9IC88IS0tKD8hLT8+KVtcXHNcXFNdKj8oPzotLT58JCkvO1xuICBibG9jayQxLmh0bWwgPSBlZGl0KGJsb2NrJDEuaHRtbCwgJ2knKS5yZXBsYWNlKCdjb21tZW50JywgYmxvY2skMS5fY29tbWVudCkucmVwbGFjZSgndGFnJywgYmxvY2skMS5fdGFnKS5yZXBsYWNlKCdhdHRyaWJ1dGUnLCAvICtbYS16QS1aOl9dW1xcdy46LV0qKD86ICo9ICpcIlteXCJcXG5dKlwifCAqPSAqJ1teJ1xcbl0qJ3wgKj0gKlteXFxzXCInPTw+YF0rKT8vKS5nZXRSZWdleCgpO1xuICBibG9jayQxLnBhcmFncmFwaCA9IGVkaXQoYmxvY2skMS5fcGFyYWdyYXBoKS5yZXBsYWNlKCdocicsIGJsb2NrJDEuaHIpLnJlcGxhY2UoJ2hlYWRpbmcnLCAnIHswLDN9I3sxLDZ9ICcpLnJlcGxhY2UoJ3xsaGVhZGluZycsICcnKSAvLyBzZXRleCBoZWFkaW5ncyBkb24ndCBpbnRlcnJ1cHQgY29tbW9ubWFyayBwYXJhZ3JhcGhzXG4gIC5yZXBsYWNlKCdibG9ja3F1b3RlJywgJyB7MCwzfT4nKS5yZXBsYWNlKCdmZW5jZXMnLCAnIHswLDN9KD86YHszLH0oPz1bXmBcXFxcbl0qXFxcXG4pfH57Myx9KVteXFxcXG5dKlxcXFxuJykucmVwbGFjZSgnbGlzdCcsICcgezAsM30oPzpbKistXXwxWy4pXSkgJykgLy8gb25seSBsaXN0cyBzdGFydGluZyBmcm9tIDEgY2FuIGludGVycnVwdFxuICAucmVwbGFjZSgnaHRtbCcsICc8Lz8oPzp0YWcpKD86ICt8XFxcXG58Lz8+KXw8KD86c2NyaXB0fHByZXxzdHlsZXx0ZXh0YXJlYXwhLS0pJykucmVwbGFjZSgndGFnJywgYmxvY2skMS5fdGFnKSAvLyBwYXJzIGNhbiBiZSBpbnRlcnJ1cHRlZCBieSB0eXBlICg2KSBodG1sIGJsb2Nrc1xuICAuZ2V0UmVnZXgoKTtcbiAgYmxvY2skMS5ibG9ja3F1b3RlID0gZWRpdChibG9jayQxLmJsb2NrcXVvdGUpLnJlcGxhY2UoJ3BhcmFncmFwaCcsIGJsb2NrJDEucGFyYWdyYXBoKS5nZXRSZWdleCgpO1xuICAvKipcbiAgICogTm9ybWFsIEJsb2NrIEdyYW1tYXJcbiAgICovXG5cbiAgYmxvY2skMS5ub3JtYWwgPSBtZXJnZSQxKHt9LCBibG9jayQxKTtcbiAgLyoqXG4gICAqIEdGTSBCbG9jayBHcmFtbWFyXG4gICAqL1xuXG4gIGJsb2NrJDEuZ2ZtID0gbWVyZ2UkMSh7fSwgYmxvY2skMS5ub3JtYWwsIHtcbiAgICB0YWJsZTogJ14gKihbXlxcXFxuIF0uKlxcXFx8LiopXFxcXG4nIC8vIEhlYWRlclxuICAgICsgJyB7MCwzfSg/OlxcXFx8ICopPyg6Py0rOj8gKig/OlxcXFx8ICo6Py0rOj8gKikqKSg/OlxcXFx8ICopPycgLy8gQWxpZ25cbiAgICArICcoPzpcXFxcbigoPzooPyEgKlxcXFxufGhyfGhlYWRpbmd8YmxvY2txdW90ZXxjb2RlfGZlbmNlc3xsaXN0fGh0bWwpLiooPzpcXFxcbnwkKSkqKVxcXFxuKnwkKScgLy8gQ2VsbHNcblxuICB9KTtcbiAgYmxvY2skMS5nZm0udGFibGUgPSBlZGl0KGJsb2NrJDEuZ2ZtLnRhYmxlKS5yZXBsYWNlKCdocicsIGJsb2NrJDEuaHIpLnJlcGxhY2UoJ2hlYWRpbmcnLCAnIHswLDN9I3sxLDZ9ICcpLnJlcGxhY2UoJ2Jsb2NrcXVvdGUnLCAnIHswLDN9PicpLnJlcGxhY2UoJ2NvZGUnLCAnIHs0fVteXFxcXG5dJykucmVwbGFjZSgnZmVuY2VzJywgJyB7MCwzfSg/OmB7Myx9KD89W15gXFxcXG5dKlxcXFxuKXx+ezMsfSlbXlxcXFxuXSpcXFxcbicpLnJlcGxhY2UoJ2xpc3QnLCAnIHswLDN9KD86WyorLV18MVsuKV0pICcpIC8vIG9ubHkgbGlzdHMgc3RhcnRpbmcgZnJvbSAxIGNhbiBpbnRlcnJ1cHRcbiAgLnJlcGxhY2UoJ2h0bWwnLCAnPC8/KD86dGFnKSg/OiArfFxcXFxufC8/Pil8PCg/OnNjcmlwdHxwcmV8c3R5bGV8dGV4dGFyZWF8IS0tKScpLnJlcGxhY2UoJ3RhZycsIGJsb2NrJDEuX3RhZykgLy8gdGFibGVzIGNhbiBiZSBpbnRlcnJ1cHRlZCBieSB0eXBlICg2KSBodG1sIGJsb2Nrc1xuICAuZ2V0UmVnZXgoKTtcbiAgLyoqXG4gICAqIFBlZGFudGljIGdyYW1tYXIgKG9yaWdpbmFsIEpvaG4gR3J1YmVyJ3MgbG9vc2UgbWFya2Rvd24gc3BlY2lmaWNhdGlvbilcbiAgICovXG5cbiAgYmxvY2skMS5wZWRhbnRpYyA9IG1lcmdlJDEoe30sIGJsb2NrJDEubm9ybWFsLCB7XG4gICAgaHRtbDogZWRpdCgnXiAqKD86Y29tbWVudCAqKD86XFxcXG58XFxcXHMqJCknICsgJ3w8KHRhZylbXFxcXHNcXFxcU10rPzwvXFxcXDE+ICooPzpcXFxcbnsyLH18XFxcXHMqJCknIC8vIGNsb3NlZCB0YWdcbiAgICArICd8PHRhZyg/OlwiW15cIl0qXCJ8XFwnW15cXCddKlxcJ3xcXFxcc1teXFwnXCIvPlxcXFxzXSopKj8vPz4gKig/OlxcXFxuezIsfXxcXFxccyokKSknKS5yZXBsYWNlKCdjb21tZW50JywgYmxvY2skMS5fY29tbWVudCkucmVwbGFjZSgvdGFnL2csICcoPyEoPzonICsgJ2F8ZW18c3Ryb25nfHNtYWxsfHN8Y2l0ZXxxfGRmbnxhYmJyfGRhdGF8dGltZXxjb2RlfHZhcnxzYW1wfGtiZHxzdWInICsgJ3xzdXB8aXxifHV8bWFya3xydWJ5fHJ0fHJwfGJkaXxiZG98c3Bhbnxicnx3YnJ8aW5zfGRlbHxpbWcpJyArICdcXFxcYilcXFxcdysoPyE6fFteXFxcXHdcXFxcc0BdKkApXFxcXGInKS5nZXRSZWdleCgpLFxuICAgIGRlZjogL14gKlxcWyhbXlxcXV0rKVxcXTogKjw/KFteXFxzPl0rKT4/KD86ICsoW1wiKF1bXlxcbl0rW1wiKV0pKT8gKig/Olxcbit8JCkvLFxuICAgIGhlYWRpbmc6IC9eKCN7MSw2fSkoLiopKD86XFxuK3wkKS8sXG4gICAgZmVuY2VzOiBub29wVGVzdCxcbiAgICAvLyBmZW5jZXMgbm90IHN1cHBvcnRlZFxuICAgIHBhcmFncmFwaDogZWRpdChibG9jayQxLm5vcm1hbC5fcGFyYWdyYXBoKS5yZXBsYWNlKCdocicsIGJsb2NrJDEuaHIpLnJlcGxhY2UoJ2hlYWRpbmcnLCAnICojezEsNn0gKlteXFxuXScpLnJlcGxhY2UoJ2xoZWFkaW5nJywgYmxvY2skMS5saGVhZGluZykucmVwbGFjZSgnYmxvY2txdW90ZScsICcgezAsM30+JykucmVwbGFjZSgnfGZlbmNlcycsICcnKS5yZXBsYWNlKCd8bGlzdCcsICcnKS5yZXBsYWNlKCd8aHRtbCcsICcnKS5nZXRSZWdleCgpXG4gIH0pO1xuICAvKipcbiAgICogSW5saW5lLUxldmVsIEdyYW1tYXJcbiAgICovXG5cbiAgdmFyIGlubGluZSQxID0ge1xuICAgIGVzY2FwZTogL15cXFxcKFshXCIjJCUmJygpKissXFwtLi86Ozw9Pj9AXFxbXFxdXFxcXF5fYHt8fX5dKS8sXG4gICAgYXV0b2xpbms6IC9ePChzY2hlbWU6W15cXHNcXHgwMC1cXHgxZjw+XSp8ZW1haWwpPi8sXG4gICAgdXJsOiBub29wVGVzdCxcbiAgICB0YWc6ICdeY29tbWVudCcgKyAnfF48L1thLXpBLVpdW1xcXFx3Oi1dKlxcXFxzKj4nIC8vIHNlbGYtY2xvc2luZyB0YWdcbiAgICArICd8XjxbYS16QS1aXVtcXFxcdy1dKig/OmF0dHJpYnV0ZSkqP1xcXFxzKi8/PicgLy8gb3BlbiB0YWdcbiAgICArICd8XjxcXFxcP1tcXFxcc1xcXFxTXSo/XFxcXD8+JyAvLyBwcm9jZXNzaW5nIGluc3RydWN0aW9uLCBlLmcuIDw/cGhwID8+XG4gICAgKyAnfF48IVthLXpBLVpdK1xcXFxzW1xcXFxzXFxcXFNdKj8+JyAvLyBkZWNsYXJhdGlvbiwgZS5nLiA8IURPQ1RZUEUgaHRtbD5cbiAgICArICd8XjwhXFxcXFtDREFUQVxcXFxbW1xcXFxzXFxcXFNdKj9cXFxcXVxcXFxdPicsXG4gICAgLy8gQ0RBVEEgc2VjdGlvblxuICAgIGxpbms6IC9eIT9cXFsobGFiZWwpXFxdXFwoXFxzKihocmVmKSg/OlxccysodGl0bGUpKT9cXHMqXFwpLyxcbiAgICByZWZsaW5rOiAvXiE/XFxbKGxhYmVsKVxcXVxcWyg/IVxccypcXF0pKCg/OlxcXFxbXFxbXFxdXT98W15cXFtcXF1cXFxcXSkrKVxcXS8sXG4gICAgbm9saW5rOiAvXiE/XFxbKD8hXFxzKlxcXSkoKD86XFxbW15cXFtcXF1dKlxcXXxcXFxcW1xcW1xcXV18W15cXFtcXF1dKSopXFxdKD86XFxbXFxdKT8vLFxuICAgIHJlZmxpbmtTZWFyY2g6ICdyZWZsaW5rfG5vbGluayg/IVxcXFwoKScsXG4gICAgZW1TdHJvbmc6IHtcbiAgICAgIGxEZWxpbTogL14oPzpcXCorKD86KFtwdW5jdF9dKXxbXlxccypdKSl8Xl8rKD86KFtwdW5jdCpdKXwoW15cXHNfXSkpLyxcbiAgICAgIC8vICAgICAgICAoMSkgYW5kICgyKSBjYW4gb25seSBiZSBhIFJpZ2h0IERlbGltaXRlci4gKDMpIGFuZCAoNCkgY2FuIG9ubHkgYmUgTGVmdC4gICg1KSBhbmQgKDYpIGNhbiBiZSBlaXRoZXIgTGVmdCBvciBSaWdodC5cbiAgICAgIC8vICAgICAgICAoKSBTa2lwIG9ycGhhbiBkZWxpbSBpbnNpZGUgc3Ryb25nICAgICgxKSAjKioqICAgICAgICAgICAgICAgICgyKSBhKioqIywgYSoqKiAgICAgICAgICAgICAgICAgICAoMykgIyoqKmEsICoqKmEgICAgICAgICAgICAgICAgICg0KSAqKiojICAgICAgICAgICAgICAoNSkgIyoqKiMgICAgICAgICAgICAgICAgICg2KSBhKioqYVxuICAgICAgckRlbGltQXN0OiAvXlteXypdKj9cXF9cXF9bXl8qXSo/XFwqW15fKl0qPyg/PVxcX1xcXyl8W3B1bmN0X10oXFwqKykoPz1bXFxzXXwkKXxbXnB1bmN0Kl9cXHNdKFxcKispKD89W3B1bmN0X1xcc118JCl8W3B1bmN0X1xcc10oXFwqKykoPz1bXnB1bmN0Kl9cXHNdKXxbXFxzXShcXCorKSg/PVtwdW5jdF9dKXxbcHVuY3RfXShcXCorKSg/PVtwdW5jdF9dKXxbXnB1bmN0Kl9cXHNdKFxcKispKD89W15wdW5jdCpfXFxzXSkvLFxuICAgICAgckRlbGltVW5kOiAvXlteXypdKj9cXCpcXCpbXl8qXSo/XFxfW15fKl0qPyg/PVxcKlxcKil8W3B1bmN0Kl0oXFxfKykoPz1bXFxzXXwkKXxbXnB1bmN0Kl9cXHNdKFxcXyspKD89W3B1bmN0Klxcc118JCl8W3B1bmN0Klxcc10oXFxfKykoPz1bXnB1bmN0Kl9cXHNdKXxbXFxzXShcXF8rKSg/PVtwdW5jdCpdKXxbcHVuY3QqXShcXF8rKSg/PVtwdW5jdCpdKS8gLy8gXi0gTm90IGFsbG93ZWQgZm9yIF9cblxuICAgIH0sXG4gICAgY29kZTogL14oYCspKFteYF18W15gXVtcXHNcXFNdKj9bXmBdKVxcMSg/IWApLyxcbiAgICBicjogL14oIHsyLH18XFxcXClcXG4oPyFcXHMqJCkvLFxuICAgIGRlbDogbm9vcFRlc3QsXG4gICAgdGV4dDogL14oYCt8W15gXSkoPzooPz0gezIsfVxcbil8W1xcc1xcU10qPyg/Oig/PVtcXFxcPCFcXFtgKl9dfFxcYl98JCl8W14gXSg/PSB7Mix9XFxuKSkpLyxcbiAgICBwdW5jdHVhdGlvbjogL14oW1xcc3B1bmN0dWF0aW9uXSkvXG4gIH07IC8vIGxpc3Qgb2YgcHVuY3R1YXRpb24gbWFya3MgZnJvbSBDb21tb25NYXJrIHNwZWNcbiAgLy8gd2l0aG91dCAqIGFuZCBfIHRvIGhhbmRsZSB0aGUgZGlmZmVyZW50IGVtcGhhc2lzIG1hcmtlcnMgKiBhbmQgX1xuXG4gIGlubGluZSQxLl9wdW5jdHVhdGlvbiA9ICchXCIjJCUmXFwnKCkrXFxcXC0uLC86Ozw9Pj9AXFxcXFtcXFxcXWBee3x9fic7XG4gIGlubGluZSQxLnB1bmN0dWF0aW9uID0gZWRpdChpbmxpbmUkMS5wdW5jdHVhdGlvbikucmVwbGFjZSgvcHVuY3R1YXRpb24vZywgaW5saW5lJDEuX3B1bmN0dWF0aW9uKS5nZXRSZWdleCgpOyAvLyBzZXF1ZW5jZXMgZW0gc2hvdWxkIHNraXAgb3ZlciBbdGl0bGVdKGxpbmspLCBgY29kZWAsIDxodG1sPlxuXG4gIGlubGluZSQxLmJsb2NrU2tpcCA9IC9cXFtbXlxcXV0qP1xcXVxcKFteXFwpXSo/XFwpfGBbXmBdKj9gfDxbXj5dKj8+L2c7XG4gIGlubGluZSQxLmVzY2FwZWRFbVN0ID0gL1xcXFxcXCp8XFxcXF8vZztcbiAgaW5saW5lJDEuX2NvbW1lbnQgPSBlZGl0KGJsb2NrJDEuX2NvbW1lbnQpLnJlcGxhY2UoJyg/Oi0tPnwkKScsICctLT4nKS5nZXRSZWdleCgpO1xuICBpbmxpbmUkMS5lbVN0cm9uZy5sRGVsaW0gPSBlZGl0KGlubGluZSQxLmVtU3Ryb25nLmxEZWxpbSkucmVwbGFjZSgvcHVuY3QvZywgaW5saW5lJDEuX3B1bmN0dWF0aW9uKS5nZXRSZWdleCgpO1xuICBpbmxpbmUkMS5lbVN0cm9uZy5yRGVsaW1Bc3QgPSBlZGl0KGlubGluZSQxLmVtU3Ryb25nLnJEZWxpbUFzdCwgJ2cnKS5yZXBsYWNlKC9wdW5jdC9nLCBpbmxpbmUkMS5fcHVuY3R1YXRpb24pLmdldFJlZ2V4KCk7XG4gIGlubGluZSQxLmVtU3Ryb25nLnJEZWxpbVVuZCA9IGVkaXQoaW5saW5lJDEuZW1TdHJvbmcuckRlbGltVW5kLCAnZycpLnJlcGxhY2UoL3B1bmN0L2csIGlubGluZSQxLl9wdW5jdHVhdGlvbikuZ2V0UmVnZXgoKTtcbiAgaW5saW5lJDEuX2VzY2FwZXMgPSAvXFxcXChbIVwiIyQlJicoKSorLFxcLS4vOjs8PT4/QFxcW1xcXVxcXFxeX2B7fH1+XSkvZztcbiAgaW5saW5lJDEuX3NjaGVtZSA9IC9bYS16QS1aXVthLXpBLVowLTkrLi1dezEsMzF9LztcbiAgaW5saW5lJDEuX2VtYWlsID0gL1thLXpBLVowLTkuISMkJSYnKisvPT9eX2B7fH1+LV0rKEApW2EtekEtWjAtOV0oPzpbYS16QS1aMC05LV17MCw2MX1bYS16QS1aMC05XSk/KD86XFwuW2EtekEtWjAtOV0oPzpbYS16QS1aMC05LV17MCw2MX1bYS16QS1aMC05XSk/KSsoPyFbLV9dKS87XG4gIGlubGluZSQxLmF1dG9saW5rID0gZWRpdChpbmxpbmUkMS5hdXRvbGluaykucmVwbGFjZSgnc2NoZW1lJywgaW5saW5lJDEuX3NjaGVtZSkucmVwbGFjZSgnZW1haWwnLCBpbmxpbmUkMS5fZW1haWwpLmdldFJlZ2V4KCk7XG4gIGlubGluZSQxLl9hdHRyaWJ1dGUgPSAvXFxzK1thLXpBLVo6X11bXFx3LjotXSooPzpcXHMqPVxccypcIlteXCJdKlwifFxccyo9XFxzKidbXiddKid8XFxzKj1cXHMqW15cXHNcIic9PD5gXSspPy87XG4gIGlubGluZSQxLnRhZyA9IGVkaXQoaW5saW5lJDEudGFnKS5yZXBsYWNlKCdjb21tZW50JywgaW5saW5lJDEuX2NvbW1lbnQpLnJlcGxhY2UoJ2F0dHJpYnV0ZScsIGlubGluZSQxLl9hdHRyaWJ1dGUpLmdldFJlZ2V4KCk7XG4gIGlubGluZSQxLl9sYWJlbCA9IC8oPzpcXFsoPzpcXFxcLnxbXlxcW1xcXVxcXFxdKSpcXF18XFxcXC58YFteYF0qYHxbXlxcW1xcXVxcXFxgXSkqPy87XG4gIGlubGluZSQxLl9ocmVmID0gLzwoPzpcXFxcLnxbXlxcbjw+XFxcXF0pKz58W15cXHNcXHgwMC1cXHgxZl0qLztcbiAgaW5saW5lJDEuX3RpdGxlID0gL1wiKD86XFxcXFwiP3xbXlwiXFxcXF0pKlwifCcoPzpcXFxcJz98W14nXFxcXF0pKid8XFwoKD86XFxcXFxcKT98W14pXFxcXF0pKlxcKS87XG4gIGlubGluZSQxLmxpbmsgPSBlZGl0KGlubGluZSQxLmxpbmspLnJlcGxhY2UoJ2xhYmVsJywgaW5saW5lJDEuX2xhYmVsKS5yZXBsYWNlKCdocmVmJywgaW5saW5lJDEuX2hyZWYpLnJlcGxhY2UoJ3RpdGxlJywgaW5saW5lJDEuX3RpdGxlKS5nZXRSZWdleCgpO1xuICBpbmxpbmUkMS5yZWZsaW5rID0gZWRpdChpbmxpbmUkMS5yZWZsaW5rKS5yZXBsYWNlKCdsYWJlbCcsIGlubGluZSQxLl9sYWJlbCkuZ2V0UmVnZXgoKTtcbiAgaW5saW5lJDEucmVmbGlua1NlYXJjaCA9IGVkaXQoaW5saW5lJDEucmVmbGlua1NlYXJjaCwgJ2cnKS5yZXBsYWNlKCdyZWZsaW5rJywgaW5saW5lJDEucmVmbGluaykucmVwbGFjZSgnbm9saW5rJywgaW5saW5lJDEubm9saW5rKS5nZXRSZWdleCgpO1xuICAvKipcbiAgICogTm9ybWFsIElubGluZSBHcmFtbWFyXG4gICAqL1xuXG4gIGlubGluZSQxLm5vcm1hbCA9IG1lcmdlJDEoe30sIGlubGluZSQxKTtcbiAgLyoqXG4gICAqIFBlZGFudGljIElubGluZSBHcmFtbWFyXG4gICAqL1xuXG4gIGlubGluZSQxLnBlZGFudGljID0gbWVyZ2UkMSh7fSwgaW5saW5lJDEubm9ybWFsLCB7XG4gICAgc3Ryb25nOiB7XG4gICAgICBzdGFydDogL15fX3xcXCpcXCovLFxuICAgICAgbWlkZGxlOiAvXl9fKD89XFxTKShbXFxzXFxTXSo/XFxTKV9fKD8hXyl8XlxcKlxcKig/PVxcUykoW1xcc1xcU10qP1xcUylcXCpcXCooPyFcXCopLyxcbiAgICAgIGVuZEFzdDogL1xcKlxcKig/IVxcKikvZyxcbiAgICAgIGVuZFVuZDogL19fKD8hXykvZ1xuICAgIH0sXG4gICAgZW06IHtcbiAgICAgIHN0YXJ0OiAvXl98XFwqLyxcbiAgICAgIG1pZGRsZTogL14oKVxcKig/PVxcUykoW1xcc1xcU10qP1xcUylcXCooPyFcXCopfF5fKD89XFxTKShbXFxzXFxTXSo/XFxTKV8oPyFfKS8sXG4gICAgICBlbmRBc3Q6IC9cXCooPyFcXCopL2csXG4gICAgICBlbmRVbmQ6IC9fKD8hXykvZ1xuICAgIH0sXG4gICAgbGluazogZWRpdCgvXiE/XFxbKGxhYmVsKVxcXVxcKCguKj8pXFwpLykucmVwbGFjZSgnbGFiZWwnLCBpbmxpbmUkMS5fbGFiZWwpLmdldFJlZ2V4KCksXG4gICAgcmVmbGluazogZWRpdCgvXiE/XFxbKGxhYmVsKVxcXVxccypcXFsoW15cXF1dKilcXF0vKS5yZXBsYWNlKCdsYWJlbCcsIGlubGluZSQxLl9sYWJlbCkuZ2V0UmVnZXgoKVxuICB9KTtcbiAgLyoqXG4gICAqIEdGTSBJbmxpbmUgR3JhbW1hclxuICAgKi9cblxuICBpbmxpbmUkMS5nZm0gPSBtZXJnZSQxKHt9LCBpbmxpbmUkMS5ub3JtYWwsIHtcbiAgICBlc2NhcGU6IGVkaXQoaW5saW5lJDEuZXNjYXBlKS5yZXBsYWNlKCddKScsICd+fF0pJykuZ2V0UmVnZXgoKSxcbiAgICBfZXh0ZW5kZWRfZW1haWw6IC9bQS1aYS16MC05Ll8rLV0rKEApW2EtekEtWjAtOS1fXSsoPzpcXC5bYS16QS1aMC05LV9dKlthLXpBLVowLTldKSsoPyFbLV9dKS8sXG4gICAgdXJsOiAvXigoPzpmdHB8aHR0cHM/KTpcXC9cXC98d3d3XFwuKSg/OlthLXpBLVowLTlcXC1dK1xcLj8pK1teXFxzPF0qfF5lbWFpbC8sXG4gICAgX2JhY2twZWRhbDogLyg/OltePyEuLDo7Kl9+KCkmXSt8XFwoW14pXSpcXCl8Jig/IVthLXpBLVowLTldKzskKXxbPyEuLDo7Kl9+KV0rKD8hJCkpKy8sXG4gICAgZGVsOiAvXih+fj8pKD89W15cXHN+XSkoW1xcc1xcU10qP1teXFxzfl0pXFwxKD89W15+XXwkKS8sXG4gICAgdGV4dDogL14oW2B+XSt8W15gfl0pKD86KD89IHsyLH1cXG4pfCg/PVthLXpBLVowLTkuISMkJSYnKitcXC89P19ge1xcfH1+LV0rQCl8W1xcc1xcU10qPyg/Oig/PVtcXFxcPCFcXFtgKn5fXXxcXGJffGh0dHBzPzpcXC9cXC98ZnRwOlxcL1xcL3x3d3dcXC58JCl8W14gXSg/PSB7Mix9XFxuKXxbXmEtekEtWjAtOS4hIyQlJicqK1xcLz0/X2B7XFx8fX4tXSg/PVthLXpBLVowLTkuISMkJSYnKitcXC89P19ge1xcfH1+LV0rQCkpKS9cbiAgfSk7XG4gIGlubGluZSQxLmdmbS51cmwgPSBlZGl0KGlubGluZSQxLmdmbS51cmwsICdpJykucmVwbGFjZSgnZW1haWwnLCBpbmxpbmUkMS5nZm0uX2V4dGVuZGVkX2VtYWlsKS5nZXRSZWdleCgpO1xuICAvKipcbiAgICogR0ZNICsgTGluZSBCcmVha3MgSW5saW5lIEdyYW1tYXJcbiAgICovXG5cbiAgaW5saW5lJDEuYnJlYWtzID0gbWVyZ2UkMSh7fSwgaW5saW5lJDEuZ2ZtLCB7XG4gICAgYnI6IGVkaXQoaW5saW5lJDEuYnIpLnJlcGxhY2UoJ3syLH0nLCAnKicpLmdldFJlZ2V4KCksXG4gICAgdGV4dDogZWRpdChpbmxpbmUkMS5nZm0udGV4dCkucmVwbGFjZSgnXFxcXGJfJywgJ1xcXFxiX3wgezIsfVxcXFxuJykucmVwbGFjZSgvXFx7MixcXH0vZywgJyonKS5nZXRSZWdleCgpXG4gIH0pO1xuICB2YXIgcnVsZXMgPSB7XG4gICAgYmxvY2s6IGJsb2NrJDEsXG4gICAgaW5saW5lOiBpbmxpbmUkMVxuICB9O1xuXG4gIHZhciBUb2tlbml6ZXIkMSA9IFRva2VuaXplcl8xO1xuICB2YXIgZGVmYXVsdHMkMyA9IGRlZmF1bHRzJDUuZXhwb3J0cy5kZWZhdWx0cztcbiAgdmFyIGJsb2NrID0gcnVsZXMuYmxvY2ssXG4gICAgICBpbmxpbmUgPSBydWxlcy5pbmxpbmU7XG4gIHZhciByZXBlYXRTdHJpbmcgPSBoZWxwZXJzLnJlcGVhdFN0cmluZztcbiAgLyoqXG4gICAqIHNtYXJ0eXBhbnRzIHRleHQgcmVwbGFjZW1lbnRcbiAgICovXG5cbiAgZnVuY3Rpb24gc21hcnR5cGFudHModGV4dCkge1xuICAgIHJldHVybiB0ZXh0IC8vIGVtLWRhc2hlc1xuICAgIC5yZXBsYWNlKC8tLS0vZywgXCJcXHUyMDE0XCIpIC8vIGVuLWRhc2hlc1xuICAgIC5yZXBsYWNlKC8tLS9nLCBcIlxcdTIwMTNcIikgLy8gb3BlbmluZyBzaW5nbGVzXG4gICAgLnJlcGxhY2UoLyhefFstXFx1MjAxNC8oXFxbe1wiXFxzXSknL2csIFwiJDFcXHUyMDE4XCIpIC8vIGNsb3Npbmcgc2luZ2xlcyAmIGFwb3N0cm9waGVzXG4gICAgLnJlcGxhY2UoLycvZywgXCJcXHUyMDE5XCIpIC8vIG9wZW5pbmcgZG91Ymxlc1xuICAgIC5yZXBsYWNlKC8oXnxbLVxcdTIwMTQvKFxcW3tcXHUyMDE4XFxzXSlcIi9nLCBcIiQxXFx1MjAxQ1wiKSAvLyBjbG9zaW5nIGRvdWJsZXNcbiAgICAucmVwbGFjZSgvXCIvZywgXCJcXHUyMDFEXCIpIC8vIGVsbGlwc2VzXG4gICAgLnJlcGxhY2UoL1xcLnszfS9nLCBcIlxcdTIwMjZcIik7XG4gIH1cbiAgLyoqXG4gICAqIG1hbmdsZSBlbWFpbCBhZGRyZXNzZXNcbiAgICovXG5cblxuICBmdW5jdGlvbiBtYW5nbGUodGV4dCkge1xuICAgIHZhciBvdXQgPSAnJyxcbiAgICAgICAgaSxcbiAgICAgICAgY2g7XG4gICAgdmFyIGwgPSB0ZXh0Lmxlbmd0aDtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBsOyBpKyspIHtcbiAgICAgIGNoID0gdGV4dC5jaGFyQ29kZUF0KGkpO1xuXG4gICAgICBpZiAoTWF0aC5yYW5kb20oKSA+IDAuNSkge1xuICAgICAgICBjaCA9ICd4JyArIGNoLnRvU3RyaW5nKDE2KTtcbiAgICAgIH1cblxuICAgICAgb3V0ICs9ICcmIycgKyBjaCArICc7JztcbiAgICB9XG5cbiAgICByZXR1cm4gb3V0O1xuICB9XG4gIC8qKlxuICAgKiBCbG9jayBMZXhlclxuICAgKi9cblxuXG4gIHZhciBMZXhlcl8xID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBMZXhlcihvcHRpb25zKSB7XG4gICAgICB0aGlzLnRva2VucyA9IFtdO1xuICAgICAgdGhpcy50b2tlbnMubGlua3MgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucyB8fCBkZWZhdWx0cyQzO1xuICAgICAgdGhpcy5vcHRpb25zLnRva2VuaXplciA9IHRoaXMub3B0aW9ucy50b2tlbml6ZXIgfHwgbmV3IFRva2VuaXplciQxKCk7XG4gICAgICB0aGlzLnRva2VuaXplciA9IHRoaXMub3B0aW9ucy50b2tlbml6ZXI7XG4gICAgICB0aGlzLnRva2VuaXplci5vcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgICAgdGhpcy50b2tlbml6ZXIubGV4ZXIgPSB0aGlzO1xuICAgICAgdGhpcy5pbmxpbmVRdWV1ZSA9IFtdO1xuICAgICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgICAgaW5MaW5rOiBmYWxzZSxcbiAgICAgICAgaW5SYXdCbG9jazogZmFsc2UsXG4gICAgICAgIHRvcDogdHJ1ZVxuICAgICAgfTtcbiAgICAgIHZhciBydWxlcyA9IHtcbiAgICAgICAgYmxvY2s6IGJsb2NrLm5vcm1hbCxcbiAgICAgICAgaW5saW5lOiBpbmxpbmUubm9ybWFsXG4gICAgICB9O1xuXG4gICAgICBpZiAodGhpcy5vcHRpb25zLnBlZGFudGljKSB7XG4gICAgICAgIHJ1bGVzLmJsb2NrID0gYmxvY2sucGVkYW50aWM7XG4gICAgICAgIHJ1bGVzLmlubGluZSA9IGlubGluZS5wZWRhbnRpYztcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5vcHRpb25zLmdmbSkge1xuICAgICAgICBydWxlcy5ibG9jayA9IGJsb2NrLmdmbTtcblxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmJyZWFrcykge1xuICAgICAgICAgIHJ1bGVzLmlubGluZSA9IGlubGluZS5icmVha3M7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcnVsZXMuaW5saW5lID0gaW5saW5lLmdmbTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0aGlzLnRva2VuaXplci5ydWxlcyA9IHJ1bGVzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFeHBvc2UgUnVsZXNcbiAgICAgKi9cblxuXG4gICAgLyoqXG4gICAgICogU3RhdGljIExleCBNZXRob2RcbiAgICAgKi9cbiAgICBMZXhlci5sZXggPSBmdW5jdGlvbiBsZXgoc3JjLCBvcHRpb25zKSB7XG4gICAgICB2YXIgbGV4ZXIgPSBuZXcgTGV4ZXIob3B0aW9ucyk7XG4gICAgICByZXR1cm4gbGV4ZXIubGV4KHNyYyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN0YXRpYyBMZXggSW5saW5lIE1ldGhvZFxuICAgICAqL1xuICAgIDtcblxuICAgIExleGVyLmxleElubGluZSA9IGZ1bmN0aW9uIGxleElubGluZShzcmMsIG9wdGlvbnMpIHtcbiAgICAgIHZhciBsZXhlciA9IG5ldyBMZXhlcihvcHRpb25zKTtcbiAgICAgIHJldHVybiBsZXhlci5pbmxpbmVUb2tlbnMoc3JjKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUHJlcHJvY2Vzc2luZ1xuICAgICAqL1xuICAgIDtcblxuICAgIHZhciBfcHJvdG8gPSBMZXhlci5wcm90b3R5cGU7XG5cbiAgICBfcHJvdG8ubGV4ID0gZnVuY3Rpb24gbGV4KHNyYykge1xuICAgICAgc3JjID0gc3JjLnJlcGxhY2UoL1xcclxcbnxcXHIvZywgJ1xcbicpLnJlcGxhY2UoL1xcdC9nLCAnICAgICcpO1xuICAgICAgdGhpcy5ibG9ja1Rva2VucyhzcmMsIHRoaXMudG9rZW5zKTtcbiAgICAgIHZhciBuZXh0O1xuXG4gICAgICB3aGlsZSAobmV4dCA9IHRoaXMuaW5saW5lUXVldWUuc2hpZnQoKSkge1xuICAgICAgICB0aGlzLmlubGluZVRva2VucyhuZXh0LnNyYywgbmV4dC50b2tlbnMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy50b2tlbnM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExleGluZ1xuICAgICAqL1xuICAgIDtcblxuICAgIF9wcm90by5ibG9ja1Rva2VucyA9IGZ1bmN0aW9uIGJsb2NrVG9rZW5zKHNyYywgdG9rZW5zKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICBpZiAodG9rZW5zID09PSB2b2lkIDApIHtcbiAgICAgICAgdG9rZW5zID0gW107XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMucGVkYW50aWMpIHtcbiAgICAgICAgc3JjID0gc3JjLnJlcGxhY2UoL14gKyQvZ20sICcnKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHRva2VuLCBsYXN0VG9rZW4sIGN1dFNyYywgbGFzdFBhcmFncmFwaENsaXBwZWQ7XG5cbiAgICAgIHdoaWxlIChzcmMpIHtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5leHRlbnNpb25zICYmIHRoaXMub3B0aW9ucy5leHRlbnNpb25zLmJsb2NrICYmIHRoaXMub3B0aW9ucy5leHRlbnNpb25zLmJsb2NrLnNvbWUoZnVuY3Rpb24gKGV4dFRva2VuaXplcikge1xuICAgICAgICAgIGlmICh0b2tlbiA9IGV4dFRva2VuaXplci5jYWxsKHtcbiAgICAgICAgICAgIGxleGVyOiBfdGhpc1xuICAgICAgICAgIH0sIHNyYywgdG9rZW5zKSkge1xuICAgICAgICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyh0b2tlbi5yYXcubGVuZ3RoKTtcbiAgICAgICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSkpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfSAvLyBuZXdsaW5lXG5cblxuICAgICAgICBpZiAodG9rZW4gPSB0aGlzLnRva2VuaXplci5zcGFjZShzcmMpKSB7XG4gICAgICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyh0b2tlbi5yYXcubGVuZ3RoKTtcblxuICAgICAgICAgIGlmICh0b2tlbi50eXBlKSB7XG4gICAgICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH0gLy8gY29kZVxuXG5cbiAgICAgICAgaWYgKHRva2VuID0gdGhpcy50b2tlbml6ZXIuY29kZShzcmMpKSB7XG4gICAgICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyh0b2tlbi5yYXcubGVuZ3RoKTtcbiAgICAgICAgICBsYXN0VG9rZW4gPSB0b2tlbnNbdG9rZW5zLmxlbmd0aCAtIDFdOyAvLyBBbiBpbmRlbnRlZCBjb2RlIGJsb2NrIGNhbm5vdCBpbnRlcnJ1cHQgYSBwYXJhZ3JhcGguXG5cbiAgICAgICAgICBpZiAobGFzdFRva2VuICYmIChsYXN0VG9rZW4udHlwZSA9PT0gJ3BhcmFncmFwaCcgfHwgbGFzdFRva2VuLnR5cGUgPT09ICd0ZXh0JykpIHtcbiAgICAgICAgICAgIGxhc3RUb2tlbi5yYXcgKz0gJ1xcbicgKyB0b2tlbi5yYXc7XG4gICAgICAgICAgICBsYXN0VG9rZW4udGV4dCArPSAnXFxuJyArIHRva2VuLnRleHQ7XG4gICAgICAgICAgICB0aGlzLmlubGluZVF1ZXVlW3RoaXMuaW5saW5lUXVldWUubGVuZ3RoIC0gMV0uc3JjID0gbGFzdFRva2VuLnRleHQ7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfSAvLyBmZW5jZXNcblxuXG4gICAgICAgIGlmICh0b2tlbiA9IHRoaXMudG9rZW5pemVyLmZlbmNlcyhzcmMpKSB7XG4gICAgICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyh0b2tlbi5yYXcubGVuZ3RoKTtcbiAgICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH0gLy8gaGVhZGluZ1xuXG5cbiAgICAgICAgaWYgKHRva2VuID0gdGhpcy50b2tlbml6ZXIuaGVhZGluZyhzcmMpKSB7XG4gICAgICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyh0b2tlbi5yYXcubGVuZ3RoKTtcbiAgICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH0gLy8gaHJcblxuXG4gICAgICAgIGlmICh0b2tlbiA9IHRoaXMudG9rZW5pemVyLmhyKHNyYykpIHtcbiAgICAgICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKHRva2VuLnJhdy5sZW5ndGgpO1xuICAgICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfSAvLyBibG9ja3F1b3RlXG5cblxuICAgICAgICBpZiAodG9rZW4gPSB0aGlzLnRva2VuaXplci5ibG9ja3F1b3RlKHNyYykpIHtcbiAgICAgICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKHRva2VuLnJhdy5sZW5ndGgpO1xuICAgICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfSAvLyBsaXN0XG5cblxuICAgICAgICBpZiAodG9rZW4gPSB0aGlzLnRva2VuaXplci5saXN0KHNyYykpIHtcbiAgICAgICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKHRva2VuLnJhdy5sZW5ndGgpO1xuICAgICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfSAvLyBodG1sXG5cblxuICAgICAgICBpZiAodG9rZW4gPSB0aGlzLnRva2VuaXplci5odG1sKHNyYykpIHtcbiAgICAgICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKHRva2VuLnJhdy5sZW5ndGgpO1xuICAgICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfSAvLyBkZWZcblxuXG4gICAgICAgIGlmICh0b2tlbiA9IHRoaXMudG9rZW5pemVyLmRlZihzcmMpKSB7XG4gICAgICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyh0b2tlbi5yYXcubGVuZ3RoKTtcbiAgICAgICAgICBsYXN0VG9rZW4gPSB0b2tlbnNbdG9rZW5zLmxlbmd0aCAtIDFdO1xuXG4gICAgICAgICAgaWYgKGxhc3RUb2tlbiAmJiAobGFzdFRva2VuLnR5cGUgPT09ICdwYXJhZ3JhcGgnIHx8IGxhc3RUb2tlbi50eXBlID09PSAndGV4dCcpKSB7XG4gICAgICAgICAgICBsYXN0VG9rZW4ucmF3ICs9ICdcXG4nICsgdG9rZW4ucmF3O1xuICAgICAgICAgICAgbGFzdFRva2VuLnRleHQgKz0gJ1xcbicgKyB0b2tlbi5yYXc7XG4gICAgICAgICAgICB0aGlzLmlubGluZVF1ZXVlW3RoaXMuaW5saW5lUXVldWUubGVuZ3RoIC0gMV0uc3JjID0gbGFzdFRva2VuLnRleHQ7XG4gICAgICAgICAgfSBlbHNlIGlmICghdGhpcy50b2tlbnMubGlua3NbdG9rZW4udGFnXSkge1xuICAgICAgICAgICAgdGhpcy50b2tlbnMubGlua3NbdG9rZW4udGFnXSA9IHtcbiAgICAgICAgICAgICAgaHJlZjogdG9rZW4uaHJlZixcbiAgICAgICAgICAgICAgdGl0bGU6IHRva2VuLnRpdGxlXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9IC8vIHRhYmxlIChnZm0pXG5cblxuICAgICAgICBpZiAodG9rZW4gPSB0aGlzLnRva2VuaXplci50YWJsZShzcmMpKSB7XG4gICAgICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyh0b2tlbi5yYXcubGVuZ3RoKTtcbiAgICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH0gLy8gbGhlYWRpbmdcblxuXG4gICAgICAgIGlmICh0b2tlbiA9IHRoaXMudG9rZW5pemVyLmxoZWFkaW5nKHNyYykpIHtcbiAgICAgICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKHRva2VuLnJhdy5sZW5ndGgpO1xuICAgICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfSAvLyB0b3AtbGV2ZWwgcGFyYWdyYXBoXG4gICAgICAgIC8vIHByZXZlbnQgcGFyYWdyYXBoIGNvbnN1bWluZyBleHRlbnNpb25zIGJ5IGNsaXBwaW5nICdzcmMnIHRvIGV4dGVuc2lvbiBzdGFydFxuXG5cbiAgICAgICAgY3V0U3JjID0gc3JjO1xuXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuZXh0ZW5zaW9ucyAmJiB0aGlzLm9wdGlvbnMuZXh0ZW5zaW9ucy5zdGFydEJsb2NrKSB7XG4gICAgICAgICAgKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBzdGFydEluZGV4ID0gSW5maW5pdHk7XG4gICAgICAgICAgICB2YXIgdGVtcFNyYyA9IHNyYy5zbGljZSgxKTtcbiAgICAgICAgICAgIHZhciB0ZW1wU3RhcnQgPSB2b2lkIDA7XG5cbiAgICAgICAgICAgIF90aGlzLm9wdGlvbnMuZXh0ZW5zaW9ucy5zdGFydEJsb2NrLmZvckVhY2goZnVuY3Rpb24gKGdldFN0YXJ0SW5kZXgpIHtcbiAgICAgICAgICAgICAgdGVtcFN0YXJ0ID0gZ2V0U3RhcnRJbmRleC5jYWxsKHtcbiAgICAgICAgICAgICAgICBsZXhlcjogdGhpc1xuICAgICAgICAgICAgICB9LCB0ZW1wU3JjKTtcblxuICAgICAgICAgICAgICBpZiAodHlwZW9mIHRlbXBTdGFydCA9PT0gJ251bWJlcicgJiYgdGVtcFN0YXJ0ID49IDApIHtcbiAgICAgICAgICAgICAgICBzdGFydEluZGV4ID0gTWF0aC5taW4oc3RhcnRJbmRleCwgdGVtcFN0YXJ0KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGlmIChzdGFydEluZGV4IDwgSW5maW5pdHkgJiYgc3RhcnRJbmRleCA+PSAwKSB7XG4gICAgICAgICAgICAgIGN1dFNyYyA9IHNyYy5zdWJzdHJpbmcoMCwgc3RhcnRJbmRleCArIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5zdGF0ZS50b3AgJiYgKHRva2VuID0gdGhpcy50b2tlbml6ZXIucGFyYWdyYXBoKGN1dFNyYykpKSB7XG4gICAgICAgICAgbGFzdFRva2VuID0gdG9rZW5zW3Rva2Vucy5sZW5ndGggLSAxXTtcblxuICAgICAgICAgIGlmIChsYXN0UGFyYWdyYXBoQ2xpcHBlZCAmJiBsYXN0VG9rZW4udHlwZSA9PT0gJ3BhcmFncmFwaCcpIHtcbiAgICAgICAgICAgIGxhc3RUb2tlbi5yYXcgKz0gJ1xcbicgKyB0b2tlbi5yYXc7XG4gICAgICAgICAgICBsYXN0VG9rZW4udGV4dCArPSAnXFxuJyArIHRva2VuLnRleHQ7XG4gICAgICAgICAgICB0aGlzLmlubGluZVF1ZXVlLnBvcCgpO1xuICAgICAgICAgICAgdGhpcy5pbmxpbmVRdWV1ZVt0aGlzLmlubGluZVF1ZXVlLmxlbmd0aCAtIDFdLnNyYyA9IGxhc3RUb2tlbi50ZXh0O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbGFzdFBhcmFncmFwaENsaXBwZWQgPSBjdXRTcmMubGVuZ3RoICE9PSBzcmMubGVuZ3RoO1xuICAgICAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcodG9rZW4ucmF3Lmxlbmd0aCk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH0gLy8gdGV4dFxuXG5cbiAgICAgICAgaWYgKHRva2VuID0gdGhpcy50b2tlbml6ZXIudGV4dChzcmMpKSB7XG4gICAgICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyh0b2tlbi5yYXcubGVuZ3RoKTtcbiAgICAgICAgICBsYXN0VG9rZW4gPSB0b2tlbnNbdG9rZW5zLmxlbmd0aCAtIDFdO1xuXG4gICAgICAgICAgaWYgKGxhc3RUb2tlbiAmJiBsYXN0VG9rZW4udHlwZSA9PT0gJ3RleHQnKSB7XG4gICAgICAgICAgICBsYXN0VG9rZW4ucmF3ICs9ICdcXG4nICsgdG9rZW4ucmF3O1xuICAgICAgICAgICAgbGFzdFRva2VuLnRleHQgKz0gJ1xcbicgKyB0b2tlbi50ZXh0O1xuICAgICAgICAgICAgdGhpcy5pbmxpbmVRdWV1ZS5wb3AoKTtcbiAgICAgICAgICAgIHRoaXMuaW5saW5lUXVldWVbdGhpcy5pbmxpbmVRdWV1ZS5sZW5ndGggLSAxXS5zcmMgPSBsYXN0VG9rZW4udGV4dDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNyYykge1xuICAgICAgICAgIHZhciBlcnJNc2cgPSAnSW5maW5pdGUgbG9vcCBvbiBieXRlOiAnICsgc3JjLmNoYXJDb2RlQXQoMCk7XG5cbiAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLnNpbGVudCkge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihlcnJNc2cpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJNc2cpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0aGlzLnN0YXRlLnRvcCA9IHRydWU7XG4gICAgICByZXR1cm4gdG9rZW5zO1xuICAgIH07XG5cbiAgICBfcHJvdG8uaW5saW5lID0gZnVuY3Rpb24gaW5saW5lKHNyYywgdG9rZW5zKSB7XG4gICAgICB0aGlzLmlubGluZVF1ZXVlLnB1c2goe1xuICAgICAgICBzcmM6IHNyYyxcbiAgICAgICAgdG9rZW5zOiB0b2tlbnNcbiAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBMZXhpbmcvQ29tcGlsaW5nXG4gICAgICovXG4gICAgO1xuXG4gICAgX3Byb3RvLmlubGluZVRva2VucyA9IGZ1bmN0aW9uIGlubGluZVRva2VucyhzcmMsIHRva2Vucykge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIGlmICh0b2tlbnMgPT09IHZvaWQgMCkge1xuICAgICAgICB0b2tlbnMgPSBbXTtcbiAgICAgIH1cblxuICAgICAgdmFyIHRva2VuLCBsYXN0VG9rZW4sIGN1dFNyYzsgLy8gU3RyaW5nIHdpdGggbGlua3MgbWFza2VkIHRvIGF2b2lkIGludGVyZmVyZW5jZSB3aXRoIGVtIGFuZCBzdHJvbmdcblxuICAgICAgdmFyIG1hc2tlZFNyYyA9IHNyYztcbiAgICAgIHZhciBtYXRjaDtcbiAgICAgIHZhciBrZWVwUHJldkNoYXIsIHByZXZDaGFyOyAvLyBNYXNrIG91dCByZWZsaW5rc1xuXG4gICAgICBpZiAodGhpcy50b2tlbnMubGlua3MpIHtcbiAgICAgICAgdmFyIGxpbmtzID0gT2JqZWN0LmtleXModGhpcy50b2tlbnMubGlua3MpO1xuXG4gICAgICAgIGlmIChsaW5rcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgd2hpbGUgKChtYXRjaCA9IHRoaXMudG9rZW5pemVyLnJ1bGVzLmlubGluZS5yZWZsaW5rU2VhcmNoLmV4ZWMobWFza2VkU3JjKSkgIT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKGxpbmtzLmluY2x1ZGVzKG1hdGNoWzBdLnNsaWNlKG1hdGNoWzBdLmxhc3RJbmRleE9mKCdbJykgKyAxLCAtMSkpKSB7XG4gICAgICAgICAgICAgIG1hc2tlZFNyYyA9IG1hc2tlZFNyYy5zbGljZSgwLCBtYXRjaC5pbmRleCkgKyAnWycgKyByZXBlYXRTdHJpbmcoJ2EnLCBtYXRjaFswXS5sZW5ndGggLSAyKSArICddJyArIG1hc2tlZFNyYy5zbGljZSh0aGlzLnRva2VuaXplci5ydWxlcy5pbmxpbmUucmVmbGlua1NlYXJjaC5sYXN0SW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSAvLyBNYXNrIG91dCBvdGhlciBibG9ja3NcblxuXG4gICAgICB3aGlsZSAoKG1hdGNoID0gdGhpcy50b2tlbml6ZXIucnVsZXMuaW5saW5lLmJsb2NrU2tpcC5leGVjKG1hc2tlZFNyYykpICE9IG51bGwpIHtcbiAgICAgICAgbWFza2VkU3JjID0gbWFza2VkU3JjLnNsaWNlKDAsIG1hdGNoLmluZGV4KSArICdbJyArIHJlcGVhdFN0cmluZygnYScsIG1hdGNoWzBdLmxlbmd0aCAtIDIpICsgJ10nICsgbWFza2VkU3JjLnNsaWNlKHRoaXMudG9rZW5pemVyLnJ1bGVzLmlubGluZS5ibG9ja1NraXAubGFzdEluZGV4KTtcbiAgICAgIH0gLy8gTWFzayBvdXQgZXNjYXBlZCBlbSAmIHN0cm9uZyBkZWxpbWl0ZXJzXG5cblxuICAgICAgd2hpbGUgKChtYXRjaCA9IHRoaXMudG9rZW5pemVyLnJ1bGVzLmlubGluZS5lc2NhcGVkRW1TdC5leGVjKG1hc2tlZFNyYykpICE9IG51bGwpIHtcbiAgICAgICAgbWFza2VkU3JjID0gbWFza2VkU3JjLnNsaWNlKDAsIG1hdGNoLmluZGV4KSArICcrKycgKyBtYXNrZWRTcmMuc2xpY2UodGhpcy50b2tlbml6ZXIucnVsZXMuaW5saW5lLmVzY2FwZWRFbVN0Lmxhc3RJbmRleCk7XG4gICAgICB9XG5cbiAgICAgIHdoaWxlIChzcmMpIHtcbiAgICAgICAgaWYgKCFrZWVwUHJldkNoYXIpIHtcbiAgICAgICAgICBwcmV2Q2hhciA9ICcnO1xuICAgICAgICB9XG5cbiAgICAgICAga2VlcFByZXZDaGFyID0gZmFsc2U7IC8vIGV4dGVuc2lvbnNcblxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmV4dGVuc2lvbnMgJiYgdGhpcy5vcHRpb25zLmV4dGVuc2lvbnMuaW5saW5lICYmIHRoaXMub3B0aW9ucy5leHRlbnNpb25zLmlubGluZS5zb21lKGZ1bmN0aW9uIChleHRUb2tlbml6ZXIpIHtcbiAgICAgICAgICBpZiAodG9rZW4gPSBleHRUb2tlbml6ZXIuY2FsbCh7XG4gICAgICAgICAgICBsZXhlcjogX3RoaXMyXG4gICAgICAgICAgfSwgc3JjLCB0b2tlbnMpKSB7XG4gICAgICAgICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKHRva2VuLnJhdy5sZW5ndGgpO1xuICAgICAgICAgICAgdG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9KSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9IC8vIGVzY2FwZVxuXG5cbiAgICAgICAgaWYgKHRva2VuID0gdGhpcy50b2tlbml6ZXIuZXNjYXBlKHNyYykpIHtcbiAgICAgICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKHRva2VuLnJhdy5sZW5ndGgpO1xuICAgICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfSAvLyB0YWdcblxuXG4gICAgICAgIGlmICh0b2tlbiA9IHRoaXMudG9rZW5pemVyLnRhZyhzcmMpKSB7XG4gICAgICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyh0b2tlbi5yYXcubGVuZ3RoKTtcbiAgICAgICAgICBsYXN0VG9rZW4gPSB0b2tlbnNbdG9rZW5zLmxlbmd0aCAtIDFdO1xuXG4gICAgICAgICAgaWYgKGxhc3RUb2tlbiAmJiB0b2tlbi50eXBlID09PSAndGV4dCcgJiYgbGFzdFRva2VuLnR5cGUgPT09ICd0ZXh0Jykge1xuICAgICAgICAgICAgbGFzdFRva2VuLnJhdyArPSB0b2tlbi5yYXc7XG4gICAgICAgICAgICBsYXN0VG9rZW4udGV4dCArPSB0b2tlbi50ZXh0O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH0gLy8gbGlua1xuXG5cbiAgICAgICAgaWYgKHRva2VuID0gdGhpcy50b2tlbml6ZXIubGluayhzcmMpKSB7XG4gICAgICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyh0b2tlbi5yYXcubGVuZ3RoKTtcbiAgICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH0gLy8gcmVmbGluaywgbm9saW5rXG5cblxuICAgICAgICBpZiAodG9rZW4gPSB0aGlzLnRva2VuaXplci5yZWZsaW5rKHNyYywgdGhpcy50b2tlbnMubGlua3MpKSB7XG4gICAgICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyh0b2tlbi5yYXcubGVuZ3RoKTtcbiAgICAgICAgICBsYXN0VG9rZW4gPSB0b2tlbnNbdG9rZW5zLmxlbmd0aCAtIDFdO1xuXG4gICAgICAgICAgaWYgKGxhc3RUb2tlbiAmJiB0b2tlbi50eXBlID09PSAndGV4dCcgJiYgbGFzdFRva2VuLnR5cGUgPT09ICd0ZXh0Jykge1xuICAgICAgICAgICAgbGFzdFRva2VuLnJhdyArPSB0b2tlbi5yYXc7XG4gICAgICAgICAgICBsYXN0VG9rZW4udGV4dCArPSB0b2tlbi50ZXh0O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH0gLy8gZW0gJiBzdHJvbmdcblxuXG4gICAgICAgIGlmICh0b2tlbiA9IHRoaXMudG9rZW5pemVyLmVtU3Ryb25nKHNyYywgbWFza2VkU3JjLCBwcmV2Q2hhcikpIHtcbiAgICAgICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKHRva2VuLnJhdy5sZW5ndGgpO1xuICAgICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfSAvLyBjb2RlXG5cblxuICAgICAgICBpZiAodG9rZW4gPSB0aGlzLnRva2VuaXplci5jb2Rlc3BhbihzcmMpKSB7XG4gICAgICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyh0b2tlbi5yYXcubGVuZ3RoKTtcbiAgICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH0gLy8gYnJcblxuXG4gICAgICAgIGlmICh0b2tlbiA9IHRoaXMudG9rZW5pemVyLmJyKHNyYykpIHtcbiAgICAgICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKHRva2VuLnJhdy5sZW5ndGgpO1xuICAgICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfSAvLyBkZWwgKGdmbSlcblxuXG4gICAgICAgIGlmICh0b2tlbiA9IHRoaXMudG9rZW5pemVyLmRlbChzcmMpKSB7XG4gICAgICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyh0b2tlbi5yYXcubGVuZ3RoKTtcbiAgICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH0gLy8gYXV0b2xpbmtcblxuXG4gICAgICAgIGlmICh0b2tlbiA9IHRoaXMudG9rZW5pemVyLmF1dG9saW5rKHNyYywgbWFuZ2xlKSkge1xuICAgICAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcodG9rZW4ucmF3Lmxlbmd0aCk7XG4gICAgICAgICAgdG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9IC8vIHVybCAoZ2ZtKVxuXG5cbiAgICAgICAgaWYgKCF0aGlzLnN0YXRlLmluTGluayAmJiAodG9rZW4gPSB0aGlzLnRva2VuaXplci51cmwoc3JjLCBtYW5nbGUpKSkge1xuICAgICAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcodG9rZW4ucmF3Lmxlbmd0aCk7XG4gICAgICAgICAgdG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9IC8vIHRleHRcbiAgICAgICAgLy8gcHJldmVudCBpbmxpbmVUZXh0IGNvbnN1bWluZyBleHRlbnNpb25zIGJ5IGNsaXBwaW5nICdzcmMnIHRvIGV4dGVuc2lvbiBzdGFydFxuXG5cbiAgICAgICAgY3V0U3JjID0gc3JjO1xuXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuZXh0ZW5zaW9ucyAmJiB0aGlzLm9wdGlvbnMuZXh0ZW5zaW9ucy5zdGFydElubGluZSkge1xuICAgICAgICAgIChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgc3RhcnRJbmRleCA9IEluZmluaXR5O1xuICAgICAgICAgICAgdmFyIHRlbXBTcmMgPSBzcmMuc2xpY2UoMSk7XG4gICAgICAgICAgICB2YXIgdGVtcFN0YXJ0ID0gdm9pZCAwO1xuXG4gICAgICAgICAgICBfdGhpczIub3B0aW9ucy5leHRlbnNpb25zLnN0YXJ0SW5saW5lLmZvckVhY2goZnVuY3Rpb24gKGdldFN0YXJ0SW5kZXgpIHtcbiAgICAgICAgICAgICAgdGVtcFN0YXJ0ID0gZ2V0U3RhcnRJbmRleC5jYWxsKHtcbiAgICAgICAgICAgICAgICBsZXhlcjogdGhpc1xuICAgICAgICAgICAgICB9LCB0ZW1wU3JjKTtcblxuICAgICAgICAgICAgICBpZiAodHlwZW9mIHRlbXBTdGFydCA9PT0gJ251bWJlcicgJiYgdGVtcFN0YXJ0ID49IDApIHtcbiAgICAgICAgICAgICAgICBzdGFydEluZGV4ID0gTWF0aC5taW4oc3RhcnRJbmRleCwgdGVtcFN0YXJ0KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGlmIChzdGFydEluZGV4IDwgSW5maW5pdHkgJiYgc3RhcnRJbmRleCA+PSAwKSB7XG4gICAgICAgICAgICAgIGN1dFNyYyA9IHNyYy5zdWJzdHJpbmcoMCwgc3RhcnRJbmRleCArIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodG9rZW4gPSB0aGlzLnRva2VuaXplci5pbmxpbmVUZXh0KGN1dFNyYywgc21hcnR5cGFudHMpKSB7XG4gICAgICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyh0b2tlbi5yYXcubGVuZ3RoKTtcblxuICAgICAgICAgIGlmICh0b2tlbi5yYXcuc2xpY2UoLTEpICE9PSAnXycpIHtcbiAgICAgICAgICAgIC8vIFRyYWNrIHByZXZDaGFyIGJlZm9yZSBzdHJpbmcgb2YgX19fXyBzdGFydGVkXG4gICAgICAgICAgICBwcmV2Q2hhciA9IHRva2VuLnJhdy5zbGljZSgtMSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAga2VlcFByZXZDaGFyID0gdHJ1ZTtcbiAgICAgICAgICBsYXN0VG9rZW4gPSB0b2tlbnNbdG9rZW5zLmxlbmd0aCAtIDFdO1xuXG4gICAgICAgICAgaWYgKGxhc3RUb2tlbiAmJiBsYXN0VG9rZW4udHlwZSA9PT0gJ3RleHQnKSB7XG4gICAgICAgICAgICBsYXN0VG9rZW4ucmF3ICs9IHRva2VuLnJhdztcbiAgICAgICAgICAgIGxhc3RUb2tlbi50ZXh0ICs9IHRva2VuLnRleHQ7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzcmMpIHtcbiAgICAgICAgICB2YXIgZXJyTXNnID0gJ0luZmluaXRlIGxvb3Agb24gYnl0ZTogJyArIHNyYy5jaGFyQ29kZUF0KDApO1xuXG4gICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5zaWxlbnQpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyTXNnKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyTXNnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRva2VucztcbiAgICB9O1xuXG4gICAgX2NyZWF0ZUNsYXNzKExleGVyLCBudWxsLCBbe1xuICAgICAga2V5OiBcInJ1bGVzXCIsXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBibG9jazogYmxvY2ssXG4gICAgICAgICAgaW5saW5lOiBpbmxpbmVcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XSk7XG5cbiAgICByZXR1cm4gTGV4ZXI7XG4gIH0oKTtcblxuICB2YXIgZGVmYXVsdHMkMiA9IGRlZmF1bHRzJDUuZXhwb3J0cy5kZWZhdWx0cztcbiAgdmFyIGNsZWFuVXJsID0gaGVscGVycy5jbGVhblVybCxcbiAgICAgIGVzY2FwZSQxID0gaGVscGVycy5lc2NhcGU7XG4gIC8qKlxuICAgKiBSZW5kZXJlclxuICAgKi9cblxuICB2YXIgUmVuZGVyZXJfMSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUmVuZGVyZXIob3B0aW9ucykge1xuICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucyB8fCBkZWZhdWx0cyQyO1xuICAgIH1cblxuICAgIHZhciBfcHJvdG8gPSBSZW5kZXJlci5wcm90b3R5cGU7XG5cbiAgICBfcHJvdG8uY29kZSA9IGZ1bmN0aW9uIGNvZGUoX2NvZGUsIGluZm9zdHJpbmcsIGVzY2FwZWQpIHtcbiAgICAgIHZhciBsYW5nID0gKGluZm9zdHJpbmcgfHwgJycpLm1hdGNoKC9cXFMqLylbMF07XG5cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuaGlnaGxpZ2h0KSB7XG4gICAgICAgIHZhciBvdXQgPSB0aGlzLm9wdGlvbnMuaGlnaGxpZ2h0KF9jb2RlLCBsYW5nKTtcblxuICAgICAgICBpZiAob3V0ICE9IG51bGwgJiYgb3V0ICE9PSBfY29kZSkge1xuICAgICAgICAgIGVzY2FwZWQgPSB0cnVlO1xuICAgICAgICAgIF9jb2RlID0gb3V0O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIF9jb2RlID0gX2NvZGUucmVwbGFjZSgvXFxuJC8sICcnKSArICdcXG4nO1xuXG4gICAgICBpZiAoIWxhbmcpIHtcbiAgICAgICAgcmV0dXJuICc8cHJlPjxjb2RlPicgKyAoZXNjYXBlZCA/IF9jb2RlIDogZXNjYXBlJDEoX2NvZGUsIHRydWUpKSArICc8L2NvZGU+PC9wcmU+XFxuJztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuICc8cHJlPjxjb2RlIGNsYXNzPVwiJyArIHRoaXMub3B0aW9ucy5sYW5nUHJlZml4ICsgZXNjYXBlJDEobGFuZywgdHJ1ZSkgKyAnXCI+JyArIChlc2NhcGVkID8gX2NvZGUgOiBlc2NhcGUkMShfY29kZSwgdHJ1ZSkpICsgJzwvY29kZT48L3ByZT5cXG4nO1xuICAgIH07XG5cbiAgICBfcHJvdG8uYmxvY2txdW90ZSA9IGZ1bmN0aW9uIGJsb2NrcXVvdGUocXVvdGUpIHtcbiAgICAgIHJldHVybiAnPGJsb2NrcXVvdGU+XFxuJyArIHF1b3RlICsgJzwvYmxvY2txdW90ZT5cXG4nO1xuICAgIH07XG5cbiAgICBfcHJvdG8uaHRtbCA9IGZ1bmN0aW9uIGh0bWwoX2h0bWwpIHtcbiAgICAgIHJldHVybiBfaHRtbDtcbiAgICB9O1xuXG4gICAgX3Byb3RvLmhlYWRpbmcgPSBmdW5jdGlvbiBoZWFkaW5nKHRleHQsIGxldmVsLCByYXcsIHNsdWdnZXIpIHtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuaGVhZGVySWRzKSB7XG4gICAgICAgIHJldHVybiAnPGgnICsgbGV2ZWwgKyAnIGlkPVwiJyArIHRoaXMub3B0aW9ucy5oZWFkZXJQcmVmaXggKyBzbHVnZ2VyLnNsdWcocmF3KSArICdcIj4nICsgdGV4dCArICc8L2gnICsgbGV2ZWwgKyAnPlxcbic7XG4gICAgICB9IC8vIGlnbm9yZSBJRHNcblxuXG4gICAgICByZXR1cm4gJzxoJyArIGxldmVsICsgJz4nICsgdGV4dCArICc8L2gnICsgbGV2ZWwgKyAnPlxcbic7XG4gICAgfTtcblxuICAgIF9wcm90by5ociA9IGZ1bmN0aW9uIGhyKCkge1xuICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy54aHRtbCA/ICc8aHIvPlxcbicgOiAnPGhyPlxcbic7XG4gICAgfTtcblxuICAgIF9wcm90by5saXN0ID0gZnVuY3Rpb24gbGlzdChib2R5LCBvcmRlcmVkLCBzdGFydCkge1xuICAgICAgdmFyIHR5cGUgPSBvcmRlcmVkID8gJ29sJyA6ICd1bCcsXG4gICAgICAgICAgc3RhcnRhdHQgPSBvcmRlcmVkICYmIHN0YXJ0ICE9PSAxID8gJyBzdGFydD1cIicgKyBzdGFydCArICdcIicgOiAnJztcbiAgICAgIHJldHVybiAnPCcgKyB0eXBlICsgc3RhcnRhdHQgKyAnPlxcbicgKyBib2R5ICsgJzwvJyArIHR5cGUgKyAnPlxcbic7XG4gICAgfTtcblxuICAgIF9wcm90by5saXN0aXRlbSA9IGZ1bmN0aW9uIGxpc3RpdGVtKHRleHQpIHtcbiAgICAgIHJldHVybiAnPGxpPicgKyB0ZXh0ICsgJzwvbGk+XFxuJztcbiAgICB9O1xuXG4gICAgX3Byb3RvLmNoZWNrYm94ID0gZnVuY3Rpb24gY2hlY2tib3goY2hlY2tlZCkge1xuICAgICAgcmV0dXJuICc8aW5wdXQgJyArIChjaGVja2VkID8gJ2NoZWNrZWQ9XCJcIiAnIDogJycpICsgJ2Rpc2FibGVkPVwiXCIgdHlwZT1cImNoZWNrYm94XCInICsgKHRoaXMub3B0aW9ucy54aHRtbCA/ICcgLycgOiAnJykgKyAnPiAnO1xuICAgIH07XG5cbiAgICBfcHJvdG8ucGFyYWdyYXBoID0gZnVuY3Rpb24gcGFyYWdyYXBoKHRleHQpIHtcbiAgICAgIHJldHVybiAnPHA+JyArIHRleHQgKyAnPC9wPlxcbic7XG4gICAgfTtcblxuICAgIF9wcm90by50YWJsZSA9IGZ1bmN0aW9uIHRhYmxlKGhlYWRlciwgYm9keSkge1xuICAgICAgaWYgKGJvZHkpIGJvZHkgPSAnPHRib2R5PicgKyBib2R5ICsgJzwvdGJvZHk+JztcbiAgICAgIHJldHVybiAnPHRhYmxlPlxcbicgKyAnPHRoZWFkPlxcbicgKyBoZWFkZXIgKyAnPC90aGVhZD5cXG4nICsgYm9keSArICc8L3RhYmxlPlxcbic7XG4gICAgfTtcblxuICAgIF9wcm90by50YWJsZXJvdyA9IGZ1bmN0aW9uIHRhYmxlcm93KGNvbnRlbnQpIHtcbiAgICAgIHJldHVybiAnPHRyPlxcbicgKyBjb250ZW50ICsgJzwvdHI+XFxuJztcbiAgICB9O1xuXG4gICAgX3Byb3RvLnRhYmxlY2VsbCA9IGZ1bmN0aW9uIHRhYmxlY2VsbChjb250ZW50LCBmbGFncykge1xuICAgICAgdmFyIHR5cGUgPSBmbGFncy5oZWFkZXIgPyAndGgnIDogJ3RkJztcbiAgICAgIHZhciB0YWcgPSBmbGFncy5hbGlnbiA/ICc8JyArIHR5cGUgKyAnIGFsaWduPVwiJyArIGZsYWdzLmFsaWduICsgJ1wiPicgOiAnPCcgKyB0eXBlICsgJz4nO1xuICAgICAgcmV0dXJuIHRhZyArIGNvbnRlbnQgKyAnPC8nICsgdHlwZSArICc+XFxuJztcbiAgICB9IC8vIHNwYW4gbGV2ZWwgcmVuZGVyZXJcbiAgICA7XG5cbiAgICBfcHJvdG8uc3Ryb25nID0gZnVuY3Rpb24gc3Ryb25nKHRleHQpIHtcbiAgICAgIHJldHVybiAnPHN0cm9uZz4nICsgdGV4dCArICc8L3N0cm9uZz4nO1xuICAgIH07XG5cbiAgICBfcHJvdG8uZW0gPSBmdW5jdGlvbiBlbSh0ZXh0KSB7XG4gICAgICByZXR1cm4gJzxlbT4nICsgdGV4dCArICc8L2VtPic7XG4gICAgfTtcblxuICAgIF9wcm90by5jb2Rlc3BhbiA9IGZ1bmN0aW9uIGNvZGVzcGFuKHRleHQpIHtcbiAgICAgIHJldHVybiAnPGNvZGU+JyArIHRleHQgKyAnPC9jb2RlPic7XG4gICAgfTtcblxuICAgIF9wcm90by5iciA9IGZ1bmN0aW9uIGJyKCkge1xuICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy54aHRtbCA/ICc8YnIvPicgOiAnPGJyPic7XG4gICAgfTtcblxuICAgIF9wcm90by5kZWwgPSBmdW5jdGlvbiBkZWwodGV4dCkge1xuICAgICAgcmV0dXJuICc8ZGVsPicgKyB0ZXh0ICsgJzwvZGVsPic7XG4gICAgfTtcblxuICAgIF9wcm90by5saW5rID0gZnVuY3Rpb24gbGluayhocmVmLCB0aXRsZSwgdGV4dCkge1xuICAgICAgaHJlZiA9IGNsZWFuVXJsKHRoaXMub3B0aW9ucy5zYW5pdGl6ZSwgdGhpcy5vcHRpb25zLmJhc2VVcmwsIGhyZWYpO1xuXG4gICAgICBpZiAoaHJlZiA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gdGV4dDtcbiAgICAgIH1cblxuICAgICAgdmFyIG91dCA9ICc8YSBocmVmPVwiJyArIGVzY2FwZSQxKGhyZWYpICsgJ1wiJztcblxuICAgICAgaWYgKHRpdGxlKSB7XG4gICAgICAgIG91dCArPSAnIHRpdGxlPVwiJyArIHRpdGxlICsgJ1wiJztcbiAgICAgIH1cblxuICAgICAgb3V0ICs9ICc+JyArIHRleHQgKyAnPC9hPic7XG4gICAgICByZXR1cm4gb3V0O1xuICAgIH07XG5cbiAgICBfcHJvdG8uaW1hZ2UgPSBmdW5jdGlvbiBpbWFnZShocmVmLCB0aXRsZSwgdGV4dCkge1xuICAgICAgaHJlZiA9IGNsZWFuVXJsKHRoaXMub3B0aW9ucy5zYW5pdGl6ZSwgdGhpcy5vcHRpb25zLmJhc2VVcmwsIGhyZWYpO1xuXG4gICAgICBpZiAoaHJlZiA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gdGV4dDtcbiAgICAgIH1cblxuICAgICAgdmFyIG91dCA9ICc8aW1nIHNyYz1cIicgKyBocmVmICsgJ1wiIGFsdD1cIicgKyB0ZXh0ICsgJ1wiJztcblxuICAgICAgaWYgKHRpdGxlKSB7XG4gICAgICAgIG91dCArPSAnIHRpdGxlPVwiJyArIHRpdGxlICsgJ1wiJztcbiAgICAgIH1cblxuICAgICAgb3V0ICs9IHRoaXMub3B0aW9ucy54aHRtbCA/ICcvPicgOiAnPic7XG4gICAgICByZXR1cm4gb3V0O1xuICAgIH07XG5cbiAgICBfcHJvdG8udGV4dCA9IGZ1bmN0aW9uIHRleHQoX3RleHQpIHtcbiAgICAgIHJldHVybiBfdGV4dDtcbiAgICB9O1xuXG4gICAgcmV0dXJuIFJlbmRlcmVyO1xuICB9KCk7XG5cbiAgLyoqXG4gICAqIFRleHRSZW5kZXJlclxuICAgKiByZXR1cm5zIG9ubHkgdGhlIHRleHR1YWwgcGFydCBvZiB0aGUgdG9rZW5cbiAgICovXG5cbiAgdmFyIFRleHRSZW5kZXJlcl8xID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBUZXh0UmVuZGVyZXIoKSB7fVxuXG4gICAgdmFyIF9wcm90byA9IFRleHRSZW5kZXJlci5wcm90b3R5cGU7XG5cbiAgICAvLyBubyBuZWVkIGZvciBibG9jayBsZXZlbCByZW5kZXJlcnNcbiAgICBfcHJvdG8uc3Ryb25nID0gZnVuY3Rpb24gc3Ryb25nKHRleHQpIHtcbiAgICAgIHJldHVybiB0ZXh0O1xuICAgIH07XG5cbiAgICBfcHJvdG8uZW0gPSBmdW5jdGlvbiBlbSh0ZXh0KSB7XG4gICAgICByZXR1cm4gdGV4dDtcbiAgICB9O1xuXG4gICAgX3Byb3RvLmNvZGVzcGFuID0gZnVuY3Rpb24gY29kZXNwYW4odGV4dCkge1xuICAgICAgcmV0dXJuIHRleHQ7XG4gICAgfTtcblxuICAgIF9wcm90by5kZWwgPSBmdW5jdGlvbiBkZWwodGV4dCkge1xuICAgICAgcmV0dXJuIHRleHQ7XG4gICAgfTtcblxuICAgIF9wcm90by5odG1sID0gZnVuY3Rpb24gaHRtbCh0ZXh0KSB7XG4gICAgICByZXR1cm4gdGV4dDtcbiAgICB9O1xuXG4gICAgX3Byb3RvLnRleHQgPSBmdW5jdGlvbiB0ZXh0KF90ZXh0KSB7XG4gICAgICByZXR1cm4gX3RleHQ7XG4gICAgfTtcblxuICAgIF9wcm90by5saW5rID0gZnVuY3Rpb24gbGluayhocmVmLCB0aXRsZSwgdGV4dCkge1xuICAgICAgcmV0dXJuICcnICsgdGV4dDtcbiAgICB9O1xuXG4gICAgX3Byb3RvLmltYWdlID0gZnVuY3Rpb24gaW1hZ2UoaHJlZiwgdGl0bGUsIHRleHQpIHtcbiAgICAgIHJldHVybiAnJyArIHRleHQ7XG4gICAgfTtcblxuICAgIF9wcm90by5iciA9IGZ1bmN0aW9uIGJyKCkge1xuICAgICAgcmV0dXJuICcnO1xuICAgIH07XG5cbiAgICByZXR1cm4gVGV4dFJlbmRlcmVyO1xuICB9KCk7XG5cbiAgLyoqXG4gICAqIFNsdWdnZXIgZ2VuZXJhdGVzIGhlYWRlciBpZFxuICAgKi9cblxuICB2YXIgU2x1Z2dlcl8xID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTbHVnZ2VyKCkge1xuICAgICAgdGhpcy5zZWVuID0ge307XG4gICAgfVxuXG4gICAgdmFyIF9wcm90byA9IFNsdWdnZXIucHJvdG90eXBlO1xuXG4gICAgX3Byb3RvLnNlcmlhbGl6ZSA9IGZ1bmN0aW9uIHNlcmlhbGl6ZSh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlLnRvTG93ZXJDYXNlKCkudHJpbSgpIC8vIHJlbW92ZSBodG1sIHRhZ3NcbiAgICAgIC5yZXBsYWNlKC88WyFcXC9hLXpdLio/Pi9pZywgJycpIC8vIHJlbW92ZSB1bndhbnRlZCBjaGFyc1xuICAgICAgLnJlcGxhY2UoL1tcXHUyMDAwLVxcdTIwNkZcXHUyRTAwLVxcdTJFN0ZcXFxcJyFcIiMkJSYoKSorLC4vOjs8PT4/QFtcXF1eYHt8fX5dL2csICcnKS5yZXBsYWNlKC9cXHMvZywgJy0nKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRmluZHMgdGhlIG5leHQgc2FmZSAodW5pcXVlKSBzbHVnIHRvIHVzZVxuICAgICAqL1xuICAgIDtcblxuICAgIF9wcm90by5nZXROZXh0U2FmZVNsdWcgPSBmdW5jdGlvbiBnZXROZXh0U2FmZVNsdWcob3JpZ2luYWxTbHVnLCBpc0RyeVJ1bikge1xuICAgICAgdmFyIHNsdWcgPSBvcmlnaW5hbFNsdWc7XG4gICAgICB2YXIgb2NjdXJlbmNlQWNjdW11bGF0b3IgPSAwO1xuXG4gICAgICBpZiAodGhpcy5zZWVuLmhhc093blByb3BlcnR5KHNsdWcpKSB7XG4gICAgICAgIG9jY3VyZW5jZUFjY3VtdWxhdG9yID0gdGhpcy5zZWVuW29yaWdpbmFsU2x1Z107XG5cbiAgICAgICAgZG8ge1xuICAgICAgICAgIG9jY3VyZW5jZUFjY3VtdWxhdG9yKys7XG4gICAgICAgICAgc2x1ZyA9IG9yaWdpbmFsU2x1ZyArICctJyArIG9jY3VyZW5jZUFjY3VtdWxhdG9yO1xuICAgICAgICB9IHdoaWxlICh0aGlzLnNlZW4uaGFzT3duUHJvcGVydHkoc2x1ZykpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWlzRHJ5UnVuKSB7XG4gICAgICAgIHRoaXMuc2VlbltvcmlnaW5hbFNsdWddID0gb2NjdXJlbmNlQWNjdW11bGF0b3I7XG4gICAgICAgIHRoaXMuc2VlbltzbHVnXSA9IDA7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzbHVnO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0IHN0cmluZyB0byB1bmlxdWUgaWRcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gb3B0aW9ucy5kcnlydW4gR2VuZXJhdGVzIHRoZSBuZXh0IHVuaXF1ZSBzbHVnIHdpdGhvdXQgdXBkYXRpbmcgdGhlIGludGVybmFsIGFjY3VtdWxhdG9yLlxuICAgICAqL1xuICAgIDtcblxuICAgIF9wcm90by5zbHVnID0gZnVuY3Rpb24gc2x1Zyh2YWx1ZSwgb3B0aW9ucykge1xuICAgICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgICAgICBvcHRpb25zID0ge307XG4gICAgICB9XG5cbiAgICAgIHZhciBzbHVnID0gdGhpcy5zZXJpYWxpemUodmFsdWUpO1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0TmV4dFNhZmVTbHVnKHNsdWcsIG9wdGlvbnMuZHJ5cnVuKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIFNsdWdnZXI7XG4gIH0oKTtcblxuICB2YXIgUmVuZGVyZXIkMSA9IFJlbmRlcmVyXzE7XG4gIHZhciBUZXh0UmVuZGVyZXIkMSA9IFRleHRSZW5kZXJlcl8xO1xuICB2YXIgU2x1Z2dlciQxID0gU2x1Z2dlcl8xO1xuICB2YXIgZGVmYXVsdHMkMSA9IGRlZmF1bHRzJDUuZXhwb3J0cy5kZWZhdWx0cztcbiAgdmFyIHVuZXNjYXBlID0gaGVscGVycy51bmVzY2FwZTtcbiAgLyoqXG4gICAqIFBhcnNpbmcgJiBDb21waWxpbmdcbiAgICovXG5cbiAgdmFyIFBhcnNlcl8xID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBQYXJzZXIob3B0aW9ucykge1xuICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucyB8fCBkZWZhdWx0cyQxO1xuICAgICAgdGhpcy5vcHRpb25zLnJlbmRlcmVyID0gdGhpcy5vcHRpb25zLnJlbmRlcmVyIHx8IG5ldyBSZW5kZXJlciQxKCk7XG4gICAgICB0aGlzLnJlbmRlcmVyID0gdGhpcy5vcHRpb25zLnJlbmRlcmVyO1xuICAgICAgdGhpcy5yZW5kZXJlci5vcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgICAgdGhpcy50ZXh0UmVuZGVyZXIgPSBuZXcgVGV4dFJlbmRlcmVyJDEoKTtcbiAgICAgIHRoaXMuc2x1Z2dlciA9IG5ldyBTbHVnZ2VyJDEoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3RhdGljIFBhcnNlIE1ldGhvZFxuICAgICAqL1xuXG5cbiAgICBQYXJzZXIucGFyc2UgPSBmdW5jdGlvbiBwYXJzZSh0b2tlbnMsIG9wdGlvbnMpIHtcbiAgICAgIHZhciBwYXJzZXIgPSBuZXcgUGFyc2VyKG9wdGlvbnMpO1xuICAgICAgcmV0dXJuIHBhcnNlci5wYXJzZSh0b2tlbnMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdGF0aWMgUGFyc2UgSW5saW5lIE1ldGhvZFxuICAgICAqL1xuICAgIDtcblxuICAgIFBhcnNlci5wYXJzZUlubGluZSA9IGZ1bmN0aW9uIHBhcnNlSW5saW5lKHRva2Vucywgb3B0aW9ucykge1xuICAgICAgdmFyIHBhcnNlciA9IG5ldyBQYXJzZXIob3B0aW9ucyk7XG4gICAgICByZXR1cm4gcGFyc2VyLnBhcnNlSW5saW5lKHRva2Vucyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBhcnNlIExvb3BcbiAgICAgKi9cbiAgICA7XG5cbiAgICB2YXIgX3Byb3RvID0gUGFyc2VyLnByb3RvdHlwZTtcblxuICAgIF9wcm90by5wYXJzZSA9IGZ1bmN0aW9uIHBhcnNlKHRva2VucywgdG9wKSB7XG4gICAgICBpZiAodG9wID09PSB2b2lkIDApIHtcbiAgICAgICAgdG9wID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgdmFyIG91dCA9ICcnLFxuICAgICAgICAgIGksXG4gICAgICAgICAgaixcbiAgICAgICAgICBrLFxuICAgICAgICAgIGwyLFxuICAgICAgICAgIGwzLFxuICAgICAgICAgIHJvdyxcbiAgICAgICAgICBjZWxsLFxuICAgICAgICAgIGhlYWRlcixcbiAgICAgICAgICBib2R5LFxuICAgICAgICAgIHRva2VuLFxuICAgICAgICAgIG9yZGVyZWQsXG4gICAgICAgICAgc3RhcnQsXG4gICAgICAgICAgbG9vc2UsXG4gICAgICAgICAgaXRlbUJvZHksXG4gICAgICAgICAgaXRlbSxcbiAgICAgICAgICBjaGVja2VkLFxuICAgICAgICAgIHRhc2ssXG4gICAgICAgICAgY2hlY2tib3gsXG4gICAgICAgICAgcmV0O1xuICAgICAgdmFyIGwgPSB0b2tlbnMubGVuZ3RoO1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIHRva2VuID0gdG9rZW5zW2ldOyAvLyBSdW4gYW55IHJlbmRlcmVyIGV4dGVuc2lvbnNcblxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmV4dGVuc2lvbnMgJiYgdGhpcy5vcHRpb25zLmV4dGVuc2lvbnMucmVuZGVyZXJzICYmIHRoaXMub3B0aW9ucy5leHRlbnNpb25zLnJlbmRlcmVyc1t0b2tlbi50eXBlXSkge1xuICAgICAgICAgIHJldCA9IHRoaXMub3B0aW9ucy5leHRlbnNpb25zLnJlbmRlcmVyc1t0b2tlbi50eXBlXS5jYWxsKHtcbiAgICAgICAgICAgIHBhcnNlcjogdGhpc1xuICAgICAgICAgIH0sIHRva2VuKTtcblxuICAgICAgICAgIGlmIChyZXQgIT09IGZhbHNlIHx8ICFbJ3NwYWNlJywgJ2hyJywgJ2hlYWRpbmcnLCAnY29kZScsICd0YWJsZScsICdibG9ja3F1b3RlJywgJ2xpc3QnLCAnaHRtbCcsICdwYXJhZ3JhcGgnLCAndGV4dCddLmluY2x1ZGVzKHRva2VuLnR5cGUpKSB7XG4gICAgICAgICAgICBvdXQgKz0gcmV0IHx8ICcnO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgc3dpdGNoICh0b2tlbi50eXBlKSB7XG4gICAgICAgICAgY2FzZSAnc3BhY2UnOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIGNhc2UgJ2hyJzpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgb3V0ICs9IHRoaXMucmVuZGVyZXIuaHIoKTtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICBjYXNlICdoZWFkaW5nJzpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgb3V0ICs9IHRoaXMucmVuZGVyZXIuaGVhZGluZyh0aGlzLnBhcnNlSW5saW5lKHRva2VuLnRva2VucyksIHRva2VuLmRlcHRoLCB1bmVzY2FwZSh0aGlzLnBhcnNlSW5saW5lKHRva2VuLnRva2VucywgdGhpcy50ZXh0UmVuZGVyZXIpKSwgdGhpcy5zbHVnZ2VyKTtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICBjYXNlICdjb2RlJzpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgb3V0ICs9IHRoaXMucmVuZGVyZXIuY29kZSh0b2tlbi50ZXh0LCB0b2tlbi5sYW5nLCB0b2tlbi5lc2NhcGVkKTtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICBjYXNlICd0YWJsZSc6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGhlYWRlciA9ICcnOyAvLyBoZWFkZXJcblxuICAgICAgICAgICAgICBjZWxsID0gJyc7XG4gICAgICAgICAgICAgIGwyID0gdG9rZW4uaGVhZGVyLmxlbmd0aDtcblxuICAgICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgbDI7IGorKykge1xuICAgICAgICAgICAgICAgIGNlbGwgKz0gdGhpcy5yZW5kZXJlci50YWJsZWNlbGwodGhpcy5wYXJzZUlubGluZSh0b2tlbi5oZWFkZXJbal0udG9rZW5zKSwge1xuICAgICAgICAgICAgICAgICAgaGVhZGVyOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgYWxpZ246IHRva2VuLmFsaWduW2pdXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBoZWFkZXIgKz0gdGhpcy5yZW5kZXJlci50YWJsZXJvdyhjZWxsKTtcbiAgICAgICAgICAgICAgYm9keSA9ICcnO1xuICAgICAgICAgICAgICBsMiA9IHRva2VuLnJvd3MubGVuZ3RoO1xuXG4gICAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBsMjsgaisrKSB7XG4gICAgICAgICAgICAgICAgcm93ID0gdG9rZW4ucm93c1tqXTtcbiAgICAgICAgICAgICAgICBjZWxsID0gJyc7XG4gICAgICAgICAgICAgICAgbDMgPSByb3cubGVuZ3RoO1xuXG4gICAgICAgICAgICAgICAgZm9yIChrID0gMDsgayA8IGwzOyBrKyspIHtcbiAgICAgICAgICAgICAgICAgIGNlbGwgKz0gdGhpcy5yZW5kZXJlci50YWJsZWNlbGwodGhpcy5wYXJzZUlubGluZShyb3dba10udG9rZW5zKSwge1xuICAgICAgICAgICAgICAgICAgICBoZWFkZXI6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBhbGlnbjogdG9rZW4uYWxpZ25ba11cbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGJvZHkgKz0gdGhpcy5yZW5kZXJlci50YWJsZXJvdyhjZWxsKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIG91dCArPSB0aGlzLnJlbmRlcmVyLnRhYmxlKGhlYWRlciwgYm9keSk7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgY2FzZSAnYmxvY2txdW90ZSc6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGJvZHkgPSB0aGlzLnBhcnNlKHRva2VuLnRva2Vucyk7XG4gICAgICAgICAgICAgIG91dCArPSB0aGlzLnJlbmRlcmVyLmJsb2NrcXVvdGUoYm9keSk7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgY2FzZSAnbGlzdCc6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIG9yZGVyZWQgPSB0b2tlbi5vcmRlcmVkO1xuICAgICAgICAgICAgICBzdGFydCA9IHRva2VuLnN0YXJ0O1xuICAgICAgICAgICAgICBsb29zZSA9IHRva2VuLmxvb3NlO1xuICAgICAgICAgICAgICBsMiA9IHRva2VuLml0ZW1zLmxlbmd0aDtcbiAgICAgICAgICAgICAgYm9keSA9ICcnO1xuXG4gICAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBsMjsgaisrKSB7XG4gICAgICAgICAgICAgICAgaXRlbSA9IHRva2VuLml0ZW1zW2pdO1xuICAgICAgICAgICAgICAgIGNoZWNrZWQgPSBpdGVtLmNoZWNrZWQ7XG4gICAgICAgICAgICAgICAgdGFzayA9IGl0ZW0udGFzaztcbiAgICAgICAgICAgICAgICBpdGVtQm9keSA9ICcnO1xuXG4gICAgICAgICAgICAgICAgaWYgKGl0ZW0udGFzaykge1xuICAgICAgICAgICAgICAgICAgY2hlY2tib3ggPSB0aGlzLnJlbmRlcmVyLmNoZWNrYm94KGNoZWNrZWQpO1xuXG4gICAgICAgICAgICAgICAgICBpZiAobG9vc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGl0ZW0udG9rZW5zLmxlbmd0aCA+IDAgJiYgaXRlbS50b2tlbnNbMF0udHlwZSA9PT0gJ3BhcmFncmFwaCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICBpdGVtLnRva2Vuc1swXS50ZXh0ID0gY2hlY2tib3ggKyAnICcgKyBpdGVtLnRva2Vuc1swXS50ZXh0O1xuXG4gICAgICAgICAgICAgICAgICAgICAgaWYgKGl0ZW0udG9rZW5zWzBdLnRva2VucyAmJiBpdGVtLnRva2Vuc1swXS50b2tlbnMubGVuZ3RoID4gMCAmJiBpdGVtLnRva2Vuc1swXS50b2tlbnNbMF0udHlwZSA9PT0gJ3RleHQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpdGVtLnRva2Vuc1swXS50b2tlbnNbMF0udGV4dCA9IGNoZWNrYm94ICsgJyAnICsgaXRlbS50b2tlbnNbMF0udG9rZW5zWzBdLnRleHQ7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgIGl0ZW0udG9rZW5zLnVuc2hpZnQoe1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3RleHQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dDogY2hlY2tib3hcbiAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaXRlbUJvZHkgKz0gY2hlY2tib3g7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaXRlbUJvZHkgKz0gdGhpcy5wYXJzZShpdGVtLnRva2VucywgbG9vc2UpO1xuICAgICAgICAgICAgICAgIGJvZHkgKz0gdGhpcy5yZW5kZXJlci5saXN0aXRlbShpdGVtQm9keSwgdGFzaywgY2hlY2tlZCk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBvdXQgKz0gdGhpcy5yZW5kZXJlci5saXN0KGJvZHksIG9yZGVyZWQsIHN0YXJ0KTtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICBjYXNlICdodG1sJzpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgLy8gVE9ETyBwYXJzZSBpbmxpbmUgY29udGVudCBpZiBwYXJhbWV0ZXIgbWFya2Rvd249MVxuICAgICAgICAgICAgICBvdXQgKz0gdGhpcy5yZW5kZXJlci5odG1sKHRva2VuLnRleHQpO1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIGNhc2UgJ3BhcmFncmFwaCc6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIG91dCArPSB0aGlzLnJlbmRlcmVyLnBhcmFncmFwaCh0aGlzLnBhcnNlSW5saW5lKHRva2VuLnRva2VucykpO1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIGNhc2UgJ3RleHQnOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBib2R5ID0gdG9rZW4udG9rZW5zID8gdGhpcy5wYXJzZUlubGluZSh0b2tlbi50b2tlbnMpIDogdG9rZW4udGV4dDtcblxuICAgICAgICAgICAgICB3aGlsZSAoaSArIDEgPCBsICYmIHRva2Vuc1tpICsgMV0udHlwZSA9PT0gJ3RleHQnKSB7XG4gICAgICAgICAgICAgICAgdG9rZW4gPSB0b2tlbnNbKytpXTtcbiAgICAgICAgICAgICAgICBib2R5ICs9ICdcXG4nICsgKHRva2VuLnRva2VucyA/IHRoaXMucGFyc2VJbmxpbmUodG9rZW4udG9rZW5zKSA6IHRva2VuLnRleHQpO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgb3V0ICs9IHRvcCA/IHRoaXMucmVuZGVyZXIucGFyYWdyYXBoKGJvZHkpIDogYm9keTtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICB2YXIgZXJyTXNnID0gJ1Rva2VuIHdpdGggXCInICsgdG9rZW4udHlwZSArICdcIiB0eXBlIHdhcyBub3QgZm91bmQuJztcblxuICAgICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLnNpbGVudCkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyTXNnKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVyck1zZyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gb3V0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQYXJzZSBJbmxpbmUgVG9rZW5zXG4gICAgICovXG4gICAgO1xuXG4gICAgX3Byb3RvLnBhcnNlSW5saW5lID0gZnVuY3Rpb24gcGFyc2VJbmxpbmUodG9rZW5zLCByZW5kZXJlcikge1xuICAgICAgcmVuZGVyZXIgPSByZW5kZXJlciB8fCB0aGlzLnJlbmRlcmVyO1xuICAgICAgdmFyIG91dCA9ICcnLFxuICAgICAgICAgIGksXG4gICAgICAgICAgdG9rZW4sXG4gICAgICAgICAgcmV0O1xuICAgICAgdmFyIGwgPSB0b2tlbnMubGVuZ3RoO1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIHRva2VuID0gdG9rZW5zW2ldOyAvLyBSdW4gYW55IHJlbmRlcmVyIGV4dGVuc2lvbnNcblxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmV4dGVuc2lvbnMgJiYgdGhpcy5vcHRpb25zLmV4dGVuc2lvbnMucmVuZGVyZXJzICYmIHRoaXMub3B0aW9ucy5leHRlbnNpb25zLnJlbmRlcmVyc1t0b2tlbi50eXBlXSkge1xuICAgICAgICAgIHJldCA9IHRoaXMub3B0aW9ucy5leHRlbnNpb25zLnJlbmRlcmVyc1t0b2tlbi50eXBlXS5jYWxsKHtcbiAgICAgICAgICAgIHBhcnNlcjogdGhpc1xuICAgICAgICAgIH0sIHRva2VuKTtcblxuICAgICAgICAgIGlmIChyZXQgIT09IGZhbHNlIHx8ICFbJ2VzY2FwZScsICdodG1sJywgJ2xpbmsnLCAnaW1hZ2UnLCAnc3Ryb25nJywgJ2VtJywgJ2NvZGVzcGFuJywgJ2JyJywgJ2RlbCcsICd0ZXh0J10uaW5jbHVkZXModG9rZW4udHlwZSkpIHtcbiAgICAgICAgICAgIG91dCArPSByZXQgfHwgJyc7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBzd2l0Y2ggKHRva2VuLnR5cGUpIHtcbiAgICAgICAgICBjYXNlICdlc2NhcGUnOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBvdXQgKz0gcmVuZGVyZXIudGV4dCh0b2tlbi50ZXh0KTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICBjYXNlICdodG1sJzpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgb3V0ICs9IHJlbmRlcmVyLmh0bWwodG9rZW4udGV4dCk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgY2FzZSAnbGluayc6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIG91dCArPSByZW5kZXJlci5saW5rKHRva2VuLmhyZWYsIHRva2VuLnRpdGxlLCB0aGlzLnBhcnNlSW5saW5lKHRva2VuLnRva2VucywgcmVuZGVyZXIpKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICBjYXNlICdpbWFnZSc6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIG91dCArPSByZW5kZXJlci5pbWFnZSh0b2tlbi5ocmVmLCB0b2tlbi50aXRsZSwgdG9rZW4udGV4dCk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgY2FzZSAnc3Ryb25nJzpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgb3V0ICs9IHJlbmRlcmVyLnN0cm9uZyh0aGlzLnBhcnNlSW5saW5lKHRva2VuLnRva2VucywgcmVuZGVyZXIpKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICBjYXNlICdlbSc6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIG91dCArPSByZW5kZXJlci5lbSh0aGlzLnBhcnNlSW5saW5lKHRva2VuLnRva2VucywgcmVuZGVyZXIpKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICBjYXNlICdjb2Rlc3Bhbic6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIG91dCArPSByZW5kZXJlci5jb2Rlc3Bhbih0b2tlbi50ZXh0KTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICBjYXNlICdicic6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIG91dCArPSByZW5kZXJlci5icigpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIGNhc2UgJ2RlbCc6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIG91dCArPSByZW5kZXJlci5kZWwodGhpcy5wYXJzZUlubGluZSh0b2tlbi50b2tlbnMsIHJlbmRlcmVyKSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgY2FzZSAndGV4dCc6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIG91dCArPSByZW5kZXJlci50ZXh0KHRva2VuLnRleHQpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHZhciBlcnJNc2cgPSAnVG9rZW4gd2l0aCBcIicgKyB0b2tlbi50eXBlICsgJ1wiIHR5cGUgd2FzIG5vdCBmb3VuZC4nO1xuXG4gICAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuc2lsZW50KSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihlcnJNc2cpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyTXNnKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBvdXQ7XG4gICAgfTtcblxuICAgIHJldHVybiBQYXJzZXI7XG4gIH0oKTtcblxuICB2YXIgTGV4ZXIgPSBMZXhlcl8xO1xuICB2YXIgUGFyc2VyID0gUGFyc2VyXzE7XG4gIHZhciBUb2tlbml6ZXIgPSBUb2tlbml6ZXJfMTtcbiAgdmFyIFJlbmRlcmVyID0gUmVuZGVyZXJfMTtcbiAgdmFyIFRleHRSZW5kZXJlciA9IFRleHRSZW5kZXJlcl8xO1xuICB2YXIgU2x1Z2dlciA9IFNsdWdnZXJfMTtcbiAgdmFyIG1lcmdlID0gaGVscGVycy5tZXJnZSxcbiAgICAgIGNoZWNrU2FuaXRpemVEZXByZWNhdGlvbiA9IGhlbHBlcnMuY2hlY2tTYW5pdGl6ZURlcHJlY2F0aW9uLFxuICAgICAgZXNjYXBlID0gaGVscGVycy5lc2NhcGU7XG4gIHZhciBnZXREZWZhdWx0cyA9IGRlZmF1bHRzJDUuZXhwb3J0cy5nZXREZWZhdWx0cyxcbiAgICAgIGNoYW5nZURlZmF1bHRzID0gZGVmYXVsdHMkNS5leHBvcnRzLmNoYW5nZURlZmF1bHRzLFxuICAgICAgZGVmYXVsdHMgPSBkZWZhdWx0cyQ1LmV4cG9ydHMuZGVmYXVsdHM7XG4gIC8qKlxuICAgKiBNYXJrZWRcbiAgICovXG5cbiAgZnVuY3Rpb24gbWFya2VkKHNyYywgb3B0LCBjYWxsYmFjaykge1xuICAgIC8vIHRocm93IGVycm9yIGluIGNhc2Ugb2Ygbm9uIHN0cmluZyBpbnB1dFxuICAgIGlmICh0eXBlb2Ygc3JjID09PSAndW5kZWZpbmVkJyB8fCBzcmMgPT09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignbWFya2VkKCk6IGlucHV0IHBhcmFtZXRlciBpcyB1bmRlZmluZWQgb3IgbnVsbCcpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2Ygc3JjICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdtYXJrZWQoKTogaW5wdXQgcGFyYW1ldGVyIGlzIG9mIHR5cGUgJyArIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChzcmMpICsgJywgc3RyaW5nIGV4cGVjdGVkJyk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBvcHQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNhbGxiYWNrID0gb3B0O1xuICAgICAgb3B0ID0gbnVsbDtcbiAgICB9XG5cbiAgICBvcHQgPSBtZXJnZSh7fSwgbWFya2VkLmRlZmF1bHRzLCBvcHQgfHwge30pO1xuICAgIGNoZWNrU2FuaXRpemVEZXByZWNhdGlvbihvcHQpO1xuXG4gICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICB2YXIgaGlnaGxpZ2h0ID0gb3B0LmhpZ2hsaWdodDtcbiAgICAgIHZhciB0b2tlbnM7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHRva2VucyA9IExleGVyLmxleChzcmMsIG9wdCk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjayhlKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGRvbmUgPSBmdW5jdGlvbiBkb25lKGVycikge1xuICAgICAgICB2YXIgb3V0O1xuXG4gICAgICAgIGlmICghZXJyKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmIChvcHQud2Fsa1Rva2Vucykge1xuICAgICAgICAgICAgICBtYXJrZWQud2Fsa1Rva2Vucyh0b2tlbnMsIG9wdC53YWxrVG9rZW5zKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgb3V0ID0gUGFyc2VyLnBhcnNlKHRva2Vucywgb3B0KTtcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBlcnIgPSBlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIG9wdC5oaWdobGlnaHQgPSBoaWdobGlnaHQ7XG4gICAgICAgIHJldHVybiBlcnIgPyBjYWxsYmFjayhlcnIpIDogY2FsbGJhY2sobnVsbCwgb3V0KTtcbiAgICAgIH07XG5cbiAgICAgIGlmICghaGlnaGxpZ2h0IHx8IGhpZ2hsaWdodC5sZW5ndGggPCAzKSB7XG4gICAgICAgIHJldHVybiBkb25lKCk7XG4gICAgICB9XG5cbiAgICAgIGRlbGV0ZSBvcHQuaGlnaGxpZ2h0O1xuICAgICAgaWYgKCF0b2tlbnMubGVuZ3RoKSByZXR1cm4gZG9uZSgpO1xuICAgICAgdmFyIHBlbmRpbmcgPSAwO1xuICAgICAgbWFya2VkLndhbGtUb2tlbnModG9rZW5zLCBmdW5jdGlvbiAodG9rZW4pIHtcbiAgICAgICAgaWYgKHRva2VuLnR5cGUgPT09ICdjb2RlJykge1xuICAgICAgICAgIHBlbmRpbmcrKztcbiAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGhpZ2hsaWdodCh0b2tlbi50ZXh0LCB0b2tlbi5sYW5nLCBmdW5jdGlvbiAoZXJyLCBjb2RlKSB7XG4gICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZG9uZShlcnIpO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaWYgKGNvZGUgIT0gbnVsbCAmJiBjb2RlICE9PSB0b2tlbi50ZXh0KSB7XG4gICAgICAgICAgICAgICAgdG9rZW4udGV4dCA9IGNvZGU7XG4gICAgICAgICAgICAgICAgdG9rZW4uZXNjYXBlZCA9IHRydWU7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBwZW5kaW5nLS07XG5cbiAgICAgICAgICAgICAgaWYgKHBlbmRpbmcgPT09IDApIHtcbiAgICAgICAgICAgICAgICBkb25lKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0sIDApO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgaWYgKHBlbmRpbmcgPT09IDApIHtcbiAgICAgICAgZG9uZSgpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIHZhciBfdG9rZW5zID0gTGV4ZXIubGV4KHNyYywgb3B0KTtcblxuICAgICAgaWYgKG9wdC53YWxrVG9rZW5zKSB7XG4gICAgICAgIG1hcmtlZC53YWxrVG9rZW5zKF90b2tlbnMsIG9wdC53YWxrVG9rZW5zKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIFBhcnNlci5wYXJzZShfdG9rZW5zLCBvcHQpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGUubWVzc2FnZSArPSAnXFxuUGxlYXNlIHJlcG9ydCB0aGlzIHRvIGh0dHBzOi8vZ2l0aHViLmNvbS9tYXJrZWRqcy9tYXJrZWQuJztcblxuICAgICAgaWYgKG9wdC5zaWxlbnQpIHtcbiAgICAgICAgcmV0dXJuICc8cD5BbiBlcnJvciBvY2N1cnJlZDo8L3A+PHByZT4nICsgZXNjYXBlKGUubWVzc2FnZSArICcnLCB0cnVlKSArICc8L3ByZT4nO1xuICAgICAgfVxuXG4gICAgICB0aHJvdyBlO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogT3B0aW9uc1xuICAgKi9cblxuXG4gIG1hcmtlZC5vcHRpb25zID0gbWFya2VkLnNldE9wdGlvbnMgPSBmdW5jdGlvbiAob3B0KSB7XG4gICAgbWVyZ2UobWFya2VkLmRlZmF1bHRzLCBvcHQpO1xuICAgIGNoYW5nZURlZmF1bHRzKG1hcmtlZC5kZWZhdWx0cyk7XG4gICAgcmV0dXJuIG1hcmtlZDtcbiAgfTtcblxuICBtYXJrZWQuZ2V0RGVmYXVsdHMgPSBnZXREZWZhdWx0cztcbiAgbWFya2VkLmRlZmF1bHRzID0gZGVmYXVsdHM7XG4gIC8qKlxuICAgKiBVc2UgRXh0ZW5zaW9uXG4gICAqL1xuXG4gIG1hcmtlZC51c2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICB2YXIgb3B0cyA9IG1lcmdlLmFwcGx5KHZvaWQgMCwgW3t9XS5jb25jYXQoYXJncykpO1xuICAgIHZhciBleHRlbnNpb25zID0gbWFya2VkLmRlZmF1bHRzLmV4dGVuc2lvbnMgfHwge1xuICAgICAgcmVuZGVyZXJzOiB7fSxcbiAgICAgIGNoaWxkVG9rZW5zOiB7fVxuICAgIH07XG4gICAgdmFyIGhhc0V4dGVuc2lvbnM7XG4gICAgYXJncy5mb3JFYWNoKGZ1bmN0aW9uIChwYWNrKSB7XG4gICAgICAvLyA9PS0tIFBhcnNlIFwiYWRkb25cIiBleHRlbnNpb25zIC0tPT0gLy9cbiAgICAgIGlmIChwYWNrLmV4dGVuc2lvbnMpIHtcbiAgICAgICAgaGFzRXh0ZW5zaW9ucyA9IHRydWU7XG4gICAgICAgIHBhY2suZXh0ZW5zaW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChleHQpIHtcbiAgICAgICAgICBpZiAoIWV4dC5uYW1lKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2V4dGVuc2lvbiBuYW1lIHJlcXVpcmVkJyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGV4dC5yZW5kZXJlcikge1xuICAgICAgICAgICAgLy8gUmVuZGVyZXIgZXh0ZW5zaW9uc1xuICAgICAgICAgICAgdmFyIHByZXZSZW5kZXJlciA9IGV4dGVuc2lvbnMucmVuZGVyZXJzID8gZXh0ZW5zaW9ucy5yZW5kZXJlcnNbZXh0Lm5hbWVdIDogbnVsbDtcblxuICAgICAgICAgICAgaWYgKHByZXZSZW5kZXJlcikge1xuICAgICAgICAgICAgICAvLyBSZXBsYWNlIGV4dGVuc2lvbiB3aXRoIGZ1bmMgdG8gcnVuIG5ldyBleHRlbnNpb24gYnV0IGZhbGwgYmFjayBpZiBmYWxzZVxuICAgICAgICAgICAgICBleHRlbnNpb25zLnJlbmRlcmVyc1tleHQubmFtZV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4yKSwgX2tleTIgPSAwOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgICAgICAgICAgICAgICBhcmdzW19rZXkyXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIHJldCA9IGV4dC5yZW5kZXJlci5hcHBseSh0aGlzLCBhcmdzKTtcblxuICAgICAgICAgICAgICAgIGlmIChyZXQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICByZXQgPSBwcmV2UmVuZGVyZXIuYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGV4dGVuc2lvbnMucmVuZGVyZXJzW2V4dC5uYW1lXSA9IGV4dC5yZW5kZXJlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoZXh0LnRva2VuaXplcikge1xuICAgICAgICAgICAgLy8gVG9rZW5pemVyIEV4dGVuc2lvbnNcbiAgICAgICAgICAgIGlmICghZXh0LmxldmVsIHx8IGV4dC5sZXZlbCAhPT0gJ2Jsb2NrJyAmJiBleHQubGV2ZWwgIT09ICdpbmxpbmUnKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImV4dGVuc2lvbiBsZXZlbCBtdXN0IGJlICdibG9jaycgb3IgJ2lubGluZSdcIik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChleHRlbnNpb25zW2V4dC5sZXZlbF0pIHtcbiAgICAgICAgICAgICAgZXh0ZW5zaW9uc1tleHQubGV2ZWxdLnVuc2hpZnQoZXh0LnRva2VuaXplcik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBleHRlbnNpb25zW2V4dC5sZXZlbF0gPSBbZXh0LnRva2VuaXplcl07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChleHQuc3RhcnQpIHtcbiAgICAgICAgICAgICAgLy8gRnVuY3Rpb24gdG8gY2hlY2sgZm9yIHN0YXJ0IG9mIHRva2VuXG4gICAgICAgICAgICAgIGlmIChleHQubGV2ZWwgPT09ICdibG9jaycpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXh0ZW5zaW9ucy5zdGFydEJsb2NrKSB7XG4gICAgICAgICAgICAgICAgICBleHRlbnNpb25zLnN0YXJ0QmxvY2sucHVzaChleHQuc3RhcnQpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBleHRlbnNpb25zLnN0YXJ0QmxvY2sgPSBbZXh0LnN0YXJ0XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoZXh0LmxldmVsID09PSAnaW5saW5lJykge1xuICAgICAgICAgICAgICAgIGlmIChleHRlbnNpb25zLnN0YXJ0SW5saW5lKSB7XG4gICAgICAgICAgICAgICAgICBleHRlbnNpb25zLnN0YXJ0SW5saW5lLnB1c2goZXh0LnN0YXJ0KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgZXh0ZW5zaW9ucy5zdGFydElubGluZSA9IFtleHQuc3RhcnRdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChleHQuY2hpbGRUb2tlbnMpIHtcbiAgICAgICAgICAgIC8vIENoaWxkIHRva2VucyB0byBiZSB2aXNpdGVkIGJ5IHdhbGtUb2tlbnNcbiAgICAgICAgICAgIGV4dGVuc2lvbnMuY2hpbGRUb2tlbnNbZXh0Lm5hbWVdID0gZXh0LmNoaWxkVG9rZW5zO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9IC8vID09LS0gUGFyc2UgXCJvdmVyd3JpdGVcIiBleHRlbnNpb25zIC0tPT0gLy9cblxuXG4gICAgICBpZiAocGFjay5yZW5kZXJlcikge1xuICAgICAgICAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciByZW5kZXJlciA9IG1hcmtlZC5kZWZhdWx0cy5yZW5kZXJlciB8fCBuZXcgUmVuZGVyZXIoKTtcblxuICAgICAgICAgIHZhciBfbG9vcCA9IGZ1bmN0aW9uIF9sb29wKHByb3ApIHtcbiAgICAgICAgICAgIHZhciBwcmV2UmVuZGVyZXIgPSByZW5kZXJlcltwcm9wXTsgLy8gUmVwbGFjZSByZW5kZXJlciB3aXRoIGZ1bmMgdG8gcnVuIGV4dGVuc2lvbiwgYnV0IGZhbGwgYmFjayBpZiBmYWxzZVxuXG4gICAgICAgICAgICByZW5kZXJlcltwcm9wXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgZm9yICh2YXIgX2xlbjMgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4zKSwgX2tleTMgPSAwOyBfa2V5MyA8IF9sZW4zOyBfa2V5MysrKSB7XG4gICAgICAgICAgICAgICAgYXJnc1tfa2V5M10gPSBhcmd1bWVudHNbX2tleTNdO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgdmFyIHJldCA9IHBhY2sucmVuZGVyZXJbcHJvcF0uYXBwbHkocmVuZGVyZXIsIGFyZ3MpO1xuXG4gICAgICAgICAgICAgIGlmIChyZXQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgcmV0ID0gcHJldlJlbmRlcmVyLmFwcGx5KHJlbmRlcmVyLCBhcmdzKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH07XG5cbiAgICAgICAgICBmb3IgKHZhciBwcm9wIGluIHBhY2sucmVuZGVyZXIpIHtcbiAgICAgICAgICAgIF9sb29wKHByb3ApO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIG9wdHMucmVuZGVyZXIgPSByZW5kZXJlcjtcbiAgICAgICAgfSkoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHBhY2sudG9rZW5pemVyKSB7XG4gICAgICAgIChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyIHRva2VuaXplciA9IG1hcmtlZC5kZWZhdWx0cy50b2tlbml6ZXIgfHwgbmV3IFRva2VuaXplcigpO1xuXG4gICAgICAgICAgdmFyIF9sb29wMiA9IGZ1bmN0aW9uIF9sb29wMihwcm9wKSB7XG4gICAgICAgICAgICB2YXIgcHJldlRva2VuaXplciA9IHRva2VuaXplcltwcm9wXTsgLy8gUmVwbGFjZSB0b2tlbml6ZXIgd2l0aCBmdW5jIHRvIHJ1biBleHRlbnNpb24sIGJ1dCBmYWxsIGJhY2sgaWYgZmFsc2VcblxuICAgICAgICAgICAgdG9rZW5pemVyW3Byb3BdID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICBmb3IgKHZhciBfbGVuNCA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjQpLCBfa2V5NCA9IDA7IF9rZXk0IDwgX2xlbjQ7IF9rZXk0KyspIHtcbiAgICAgICAgICAgICAgICBhcmdzW19rZXk0XSA9IGFyZ3VtZW50c1tfa2V5NF07XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICB2YXIgcmV0ID0gcGFjay50b2tlbml6ZXJbcHJvcF0uYXBwbHkodG9rZW5pemVyLCBhcmdzKTtcblxuICAgICAgICAgICAgICBpZiAocmV0ID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIHJldCA9IHByZXZUb2tlbml6ZXIuYXBwbHkodG9rZW5pemVyLCBhcmdzKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH07XG5cbiAgICAgICAgICBmb3IgKHZhciBwcm9wIGluIHBhY2sudG9rZW5pemVyKSB7XG4gICAgICAgICAgICBfbG9vcDIocHJvcCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgb3B0cy50b2tlbml6ZXIgPSB0b2tlbml6ZXI7XG4gICAgICAgIH0pKCk7XG4gICAgICB9IC8vID09LS0gUGFyc2UgV2Fsa1Rva2VucyBleHRlbnNpb25zIC0tPT0gLy9cblxuXG4gICAgICBpZiAocGFjay53YWxrVG9rZW5zKSB7XG4gICAgICAgIHZhciB3YWxrVG9rZW5zID0gbWFya2VkLmRlZmF1bHRzLndhbGtUb2tlbnM7XG5cbiAgICAgICAgb3B0cy53YWxrVG9rZW5zID0gZnVuY3Rpb24gKHRva2VuKSB7XG4gICAgICAgICAgcGFjay53YWxrVG9rZW5zLmNhbGwoX3RoaXMsIHRva2VuKTtcblxuICAgICAgICAgIGlmICh3YWxrVG9rZW5zKSB7XG4gICAgICAgICAgICB3YWxrVG9rZW5zKHRva2VuKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIGlmIChoYXNFeHRlbnNpb25zKSB7XG4gICAgICAgIG9wdHMuZXh0ZW5zaW9ucyA9IGV4dGVuc2lvbnM7XG4gICAgICB9XG5cbiAgICAgIG1hcmtlZC5zZXRPcHRpb25zKG9wdHMpO1xuICAgIH0pO1xuICB9O1xuICAvKipcbiAgICogUnVuIGNhbGxiYWNrIGZvciBldmVyeSB0b2tlblxuICAgKi9cblxuXG4gIG1hcmtlZC53YWxrVG9rZW5zID0gZnVuY3Rpb24gKHRva2VucywgY2FsbGJhY2spIHtcbiAgICB2YXIgX2xvb3AzID0gZnVuY3Rpb24gX2xvb3AzKCkge1xuICAgICAgdmFyIHRva2VuID0gX3N0ZXAudmFsdWU7XG4gICAgICBjYWxsYmFjayh0b2tlbik7XG5cbiAgICAgIHN3aXRjaCAodG9rZW4udHlwZSkge1xuICAgICAgICBjYXNlICd0YWJsZSc6XG4gICAgICAgICAge1xuICAgICAgICAgICAgZm9yICh2YXIgX2l0ZXJhdG9yMiA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyTG9vc2UodG9rZW4uaGVhZGVyKSwgX3N0ZXAyOyAhKF9zdGVwMiA9IF9pdGVyYXRvcjIoKSkuZG9uZTspIHtcbiAgICAgICAgICAgICAgdmFyIGNlbGwgPSBfc3RlcDIudmFsdWU7XG4gICAgICAgICAgICAgIG1hcmtlZC53YWxrVG9rZW5zKGNlbGwudG9rZW5zLCBjYWxsYmFjayk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvciAodmFyIF9pdGVyYXRvcjMgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlckxvb3NlKHRva2VuLnJvd3MpLCBfc3RlcDM7ICEoX3N0ZXAzID0gX2l0ZXJhdG9yMygpKS5kb25lOykge1xuICAgICAgICAgICAgICB2YXIgcm93ID0gX3N0ZXAzLnZhbHVlO1xuXG4gICAgICAgICAgICAgIGZvciAodmFyIF9pdGVyYXRvcjQgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlckxvb3NlKHJvdyksIF9zdGVwNDsgIShfc3RlcDQgPSBfaXRlcmF0b3I0KCkpLmRvbmU7KSB7XG4gICAgICAgICAgICAgICAgdmFyIF9jZWxsID0gX3N0ZXA0LnZhbHVlO1xuICAgICAgICAgICAgICAgIG1hcmtlZC53YWxrVG9rZW5zKF9jZWxsLnRva2VucywgY2FsbGJhY2spO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlICdsaXN0JzpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBtYXJrZWQud2Fsa1Rva2Vucyh0b2tlbi5pdGVtcywgY2FsbGJhY2spO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAge1xuICAgICAgICAgICAgaWYgKG1hcmtlZC5kZWZhdWx0cy5leHRlbnNpb25zICYmIG1hcmtlZC5kZWZhdWx0cy5leHRlbnNpb25zLmNoaWxkVG9rZW5zICYmIG1hcmtlZC5kZWZhdWx0cy5leHRlbnNpb25zLmNoaWxkVG9rZW5zW3Rva2VuLnR5cGVdKSB7XG4gICAgICAgICAgICAgIC8vIFdhbGsgYW55IGV4dGVuc2lvbnNcbiAgICAgICAgICAgICAgbWFya2VkLmRlZmF1bHRzLmV4dGVuc2lvbnMuY2hpbGRUb2tlbnNbdG9rZW4udHlwZV0uZm9yRWFjaChmdW5jdGlvbiAoY2hpbGRUb2tlbnMpIHtcbiAgICAgICAgICAgICAgICBtYXJrZWQud2Fsa1Rva2Vucyh0b2tlbltjaGlsZFRva2Vuc10sIGNhbGxiYWNrKTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRva2VuLnRva2Vucykge1xuICAgICAgICAgICAgICBtYXJrZWQud2Fsa1Rva2Vucyh0b2tlbi50b2tlbnMsIGNhbGxiYWNrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIGZvciAodmFyIF9pdGVyYXRvciA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyTG9vc2UodG9rZW5zKSwgX3N0ZXA7ICEoX3N0ZXAgPSBfaXRlcmF0b3IoKSkuZG9uZTspIHtcbiAgICAgIF9sb29wMygpO1xuICAgIH1cbiAgfTtcbiAgLyoqXG4gICAqIFBhcnNlIElubGluZVxuICAgKi9cblxuXG4gIG1hcmtlZC5wYXJzZUlubGluZSA9IGZ1bmN0aW9uIChzcmMsIG9wdCkge1xuICAgIC8vIHRocm93IGVycm9yIGluIGNhc2Ugb2Ygbm9uIHN0cmluZyBpbnB1dFxuICAgIGlmICh0eXBlb2Ygc3JjID09PSAndW5kZWZpbmVkJyB8fCBzcmMgPT09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignbWFya2VkLnBhcnNlSW5saW5lKCk6IGlucHV0IHBhcmFtZXRlciBpcyB1bmRlZmluZWQgb3IgbnVsbCcpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2Ygc3JjICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdtYXJrZWQucGFyc2VJbmxpbmUoKTogaW5wdXQgcGFyYW1ldGVyIGlzIG9mIHR5cGUgJyArIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChzcmMpICsgJywgc3RyaW5nIGV4cGVjdGVkJyk7XG4gICAgfVxuXG4gICAgb3B0ID0gbWVyZ2Uoe30sIG1hcmtlZC5kZWZhdWx0cywgb3B0IHx8IHt9KTtcbiAgICBjaGVja1Nhbml0aXplRGVwcmVjYXRpb24ob3B0KTtcblxuICAgIHRyeSB7XG4gICAgICB2YXIgdG9rZW5zID0gTGV4ZXIubGV4SW5saW5lKHNyYywgb3B0KTtcblxuICAgICAgaWYgKG9wdC53YWxrVG9rZW5zKSB7XG4gICAgICAgIG1hcmtlZC53YWxrVG9rZW5zKHRva2Vucywgb3B0LndhbGtUb2tlbnMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gUGFyc2VyLnBhcnNlSW5saW5lKHRva2Vucywgb3B0KTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBlLm1lc3NhZ2UgKz0gJ1xcblBsZWFzZSByZXBvcnQgdGhpcyB0byBodHRwczovL2dpdGh1Yi5jb20vbWFya2VkanMvbWFya2VkLic7XG5cbiAgICAgIGlmIChvcHQuc2lsZW50KSB7XG4gICAgICAgIHJldHVybiAnPHA+QW4gZXJyb3Igb2NjdXJyZWQ6PC9wPjxwcmU+JyArIGVzY2FwZShlLm1lc3NhZ2UgKyAnJywgdHJ1ZSkgKyAnPC9wcmU+JztcbiAgICAgIH1cblxuICAgICAgdGhyb3cgZTtcbiAgICB9XG4gIH07XG4gIC8qKlxuICAgKiBFeHBvc2VcbiAgICovXG5cblxuICBtYXJrZWQuUGFyc2VyID0gUGFyc2VyO1xuICBtYXJrZWQucGFyc2VyID0gUGFyc2VyLnBhcnNlO1xuICBtYXJrZWQuUmVuZGVyZXIgPSBSZW5kZXJlcjtcbiAgbWFya2VkLlRleHRSZW5kZXJlciA9IFRleHRSZW5kZXJlcjtcbiAgbWFya2VkLkxleGVyID0gTGV4ZXI7XG4gIG1hcmtlZC5sZXhlciA9IExleGVyLmxleDtcbiAgbWFya2VkLlRva2VuaXplciA9IFRva2VuaXplcjtcbiAgbWFya2VkLlNsdWdnZXIgPSBTbHVnZ2VyO1xuICBtYXJrZWQucGFyc2UgPSBtYXJrZWQ7XG4gIHZhciBtYXJrZWRfMSA9IG1hcmtlZDtcblxuICByZXR1cm4gbWFya2VkXzE7XG5cbn0pKTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///84\n")},418:module=>{"use strict";eval("/*\nobject-assign\n(c) Sindre Sorhus\n@license MIT\n*/\n\n\n/* eslint-disable no-unused-vars */\nvar getOwnPropertySymbols = Object.getOwnPropertySymbols;\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\nvar propIsEnumerable = Object.prototype.propertyIsEnumerable;\n\nfunction toObject(val) {\n\tif (val === null || val === undefined) {\n\t\tthrow new TypeError('Object.assign cannot be called with null or undefined');\n\t}\n\n\treturn Object(val);\n}\n\nfunction shouldUseNative() {\n\ttry {\n\t\tif (!Object.assign) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Detect buggy property enumeration order in older V8 versions.\n\n\t\t// https://bugs.chromium.org/p/v8/issues/detail?id=4118\n\t\tvar test1 = new String('abc');  // eslint-disable-line no-new-wrappers\n\t\ttest1[5] = 'de';\n\t\tif (Object.getOwnPropertyNames(test1)[0] === '5') {\n\t\t\treturn false;\n\t\t}\n\n\t\t// https://bugs.chromium.org/p/v8/issues/detail?id=3056\n\t\tvar test2 = {};\n\t\tfor (var i = 0; i < 10; i++) {\n\t\t\ttest2['_' + String.fromCharCode(i)] = i;\n\t\t}\n\t\tvar order2 = Object.getOwnPropertyNames(test2).map(function (n) {\n\t\t\treturn test2[n];\n\t\t});\n\t\tif (order2.join('') !== '0123456789') {\n\t\t\treturn false;\n\t\t}\n\n\t\t// https://bugs.chromium.org/p/v8/issues/detail?id=3056\n\t\tvar test3 = {};\n\t\t'abcdefghijklmnopqrst'.split('').forEach(function (letter) {\n\t\t\ttest3[letter] = letter;\n\t\t});\n\t\tif (Object.keys(Object.assign({}, test3)).join('') !==\n\t\t\t\t'abcdefghijklmnopqrst') {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t} catch (err) {\n\t\t// We don't expect any of the above to throw, but better to be safe.\n\t\treturn false;\n\t}\n}\n\nmodule.exports = shouldUseNative() ? Object.assign : function (target, source) {\n\tvar from;\n\tvar to = toObject(target);\n\tvar symbols;\n\n\tfor (var s = 1; s < arguments.length; s++) {\n\t\tfrom = Object(arguments[s]);\n\n\t\tfor (var key in from) {\n\t\t\tif (hasOwnProperty.call(from, key)) {\n\t\t\t\tto[key] = from[key];\n\t\t\t}\n\t\t}\n\n\t\tif (getOwnPropertySymbols) {\n\t\t\tsymbols = getOwnPropertySymbols(from);\n\t\t\tfor (var i = 0; i < symbols.length; i++) {\n\t\t\t\tif (propIsEnumerable.call(from, symbols[i])) {\n\t\t\t\t\tto[symbols[i]] = from[symbols[i]];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn to;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDE4LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQixRQUFRO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlCQUFpQixzQkFBc0I7QUFDdkM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUJBQW1CLG9CQUFvQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL21kYy1yZWFjdC8uL25vZGVfbW9kdWxlcy9vYmplY3QtYXNzaWduL2luZGV4LmpzPzMyMGMiXSwic291cmNlc0NvbnRlbnQiOlsiLypcbm9iamVjdC1hc3NpZ25cbihjKSBTaW5kcmUgU29yaHVzXG5AbGljZW5zZSBNSVRcbiovXG5cbid1c2Ugc3RyaWN0Jztcbi8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC12YXJzICovXG52YXIgZ2V0T3duUHJvcGVydHlTeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scztcbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgcHJvcElzRW51bWVyYWJsZSA9IE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGU7XG5cbmZ1bmN0aW9uIHRvT2JqZWN0KHZhbCkge1xuXHRpZiAodmFsID09PSBudWxsIHx8IHZhbCA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignT2JqZWN0LmFzc2lnbiBjYW5ub3QgYmUgY2FsbGVkIHdpdGggbnVsbCBvciB1bmRlZmluZWQnKTtcblx0fVxuXG5cdHJldHVybiBPYmplY3QodmFsKTtcbn1cblxuZnVuY3Rpb24gc2hvdWxkVXNlTmF0aXZlKCkge1xuXHR0cnkge1xuXHRcdGlmICghT2JqZWN0LmFzc2lnbikge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdC8vIERldGVjdCBidWdneSBwcm9wZXJ0eSBlbnVtZXJhdGlvbiBvcmRlciBpbiBvbGRlciBWOCB2ZXJzaW9ucy5cblxuXHRcdC8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTQxMThcblx0XHR2YXIgdGVzdDEgPSBuZXcgU3RyaW5nKCdhYmMnKTsgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmV3LXdyYXBwZXJzXG5cdFx0dGVzdDFbNV0gPSAnZGUnO1xuXHRcdGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0ZXN0MSlbMF0gPT09ICc1Jykge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdC8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTMwNTZcblx0XHR2YXIgdGVzdDIgPSB7fTtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IDEwOyBpKyspIHtcblx0XHRcdHRlc3QyWydfJyArIFN0cmluZy5mcm9tQ2hhckNvZGUoaSldID0gaTtcblx0XHR9XG5cdFx0dmFyIG9yZGVyMiA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRlc3QyKS5tYXAoZnVuY3Rpb24gKG4pIHtcblx0XHRcdHJldHVybiB0ZXN0MltuXTtcblx0XHR9KTtcblx0XHRpZiAob3JkZXIyLmpvaW4oJycpICE9PSAnMDEyMzQ1Njc4OScpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHQvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD0zMDU2XG5cdFx0dmFyIHRlc3QzID0ge307XG5cdFx0J2FiY2RlZmdoaWprbG1ub3BxcnN0Jy5zcGxpdCgnJykuZm9yRWFjaChmdW5jdGlvbiAobGV0dGVyKSB7XG5cdFx0XHR0ZXN0M1tsZXR0ZXJdID0gbGV0dGVyO1xuXHRcdH0pO1xuXHRcdGlmIChPYmplY3Qua2V5cyhPYmplY3QuYXNzaWduKHt9LCB0ZXN0MykpLmpvaW4oJycpICE9PVxuXHRcdFx0XHQnYWJjZGVmZ2hpamtsbW5vcHFyc3QnKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRydWU7XG5cdH0gY2F0Y2ggKGVycikge1xuXHRcdC8vIFdlIGRvbid0IGV4cGVjdCBhbnkgb2YgdGhlIGFib3ZlIHRvIHRocm93LCBidXQgYmV0dGVyIHRvIGJlIHNhZmUuXG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc2hvdWxkVXNlTmF0aXZlKCkgPyBPYmplY3QuYXNzaWduIDogZnVuY3Rpb24gKHRhcmdldCwgc291cmNlKSB7XG5cdHZhciBmcm9tO1xuXHR2YXIgdG8gPSB0b09iamVjdCh0YXJnZXQpO1xuXHR2YXIgc3ltYm9scztcblxuXHRmb3IgKHZhciBzID0gMTsgcyA8IGFyZ3VtZW50cy5sZW5ndGg7IHMrKykge1xuXHRcdGZyb20gPSBPYmplY3QoYXJndW1lbnRzW3NdKTtcblxuXHRcdGZvciAodmFyIGtleSBpbiBmcm9tKSB7XG5cdFx0XHRpZiAoaGFzT3duUHJvcGVydHkuY2FsbChmcm9tLCBrZXkpKSB7XG5cdFx0XHRcdHRvW2tleV0gPSBmcm9tW2tleV07XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKGdldE93blByb3BlcnR5U3ltYm9scykge1xuXHRcdFx0c3ltYm9scyA9IGdldE93blByb3BlcnR5U3ltYm9scyhmcm9tKTtcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgc3ltYm9scy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRpZiAocHJvcElzRW51bWVyYWJsZS5jYWxsKGZyb20sIHN5bWJvbHNbaV0pKSB7XG5cdFx0XHRcdFx0dG9bc3ltYm9sc1tpXV0gPSBmcm9tW3N5bWJvbHNbaV1dO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIHRvO1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///418\n")},779:(module,__unused_webpack_exports,__webpack_require__)=>{eval("var isarray = __webpack_require__(826)\n\n/**\n * Expose `pathToRegexp`.\n */\nmodule.exports = pathToRegexp\nmodule.exports.parse = parse\nmodule.exports.compile = compile\nmodule.exports.tokensToFunction = tokensToFunction\nmodule.exports.tokensToRegExp = tokensToRegExp\n\n/**\n * The main path matching regexp utility.\n *\n * @type {RegExp}\n */\nvar PATH_REGEXP = new RegExp([\n  // Match escaped characters that would otherwise appear in future matches.\n  // This allows the user to escape special characters that won't transform.\n  '(\\\\\\\\.)',\n  // Match Express-style parameters and un-named parameters with a prefix\n  // and optional suffixes. Matches appear as:\n  //\n  // \"/:test(\\\\d+)?\" => [\"/\", \"test\", \"\\d+\", undefined, \"?\", undefined]\n  // \"/route(\\\\d+)\"  => [undefined, undefined, undefined, \"\\d+\", undefined, undefined]\n  // \"/*\"            => [\"/\", undefined, undefined, undefined, undefined, \"*\"]\n  '([\\\\/.])?(?:(?:\\\\:(\\\\w+)(?:\\\\(((?:\\\\\\\\.|[^\\\\\\\\()])+)\\\\))?|\\\\(((?:\\\\\\\\.|[^\\\\\\\\()])+)\\\\))([+*?])?|(\\\\*))'\n].join('|'), 'g')\n\n/**\n * Parse a string for the raw tokens.\n *\n * @param  {string}  str\n * @param  {Object=} options\n * @return {!Array}\n */\nfunction parse (str, options) {\n  var tokens = []\n  var key = 0\n  var index = 0\n  var path = ''\n  var defaultDelimiter = options && options.delimiter || '/'\n  var res\n\n  while ((res = PATH_REGEXP.exec(str)) != null) {\n    var m = res[0]\n    var escaped = res[1]\n    var offset = res.index\n    path += str.slice(index, offset)\n    index = offset + m.length\n\n    // Ignore already escaped sequences.\n    if (escaped) {\n      path += escaped[1]\n      continue\n    }\n\n    var next = str[index]\n    var prefix = res[2]\n    var name = res[3]\n    var capture = res[4]\n    var group = res[5]\n    var modifier = res[6]\n    var asterisk = res[7]\n\n    // Push the current path onto the tokens.\n    if (path) {\n      tokens.push(path)\n      path = ''\n    }\n\n    var partial = prefix != null && next != null && next !== prefix\n    var repeat = modifier === '+' || modifier === '*'\n    var optional = modifier === '?' || modifier === '*'\n    var delimiter = res[2] || defaultDelimiter\n    var pattern = capture || group\n\n    tokens.push({\n      name: name || key++,\n      prefix: prefix || '',\n      delimiter: delimiter,\n      optional: optional,\n      repeat: repeat,\n      partial: partial,\n      asterisk: !!asterisk,\n      pattern: pattern ? escapeGroup(pattern) : (asterisk ? '.*' : '[^' + escapeString(delimiter) + ']+?')\n    })\n  }\n\n  // Match any characters still remaining.\n  if (index < str.length) {\n    path += str.substr(index)\n  }\n\n  // If the path exists, push it onto the end.\n  if (path) {\n    tokens.push(path)\n  }\n\n  return tokens\n}\n\n/**\n * Compile a string to a template function for the path.\n *\n * @param  {string}             str\n * @param  {Object=}            options\n * @return {!function(Object=, Object=)}\n */\nfunction compile (str, options) {\n  return tokensToFunction(parse(str, options), options)\n}\n\n/**\n * Prettier encoding of URI path segments.\n *\n * @param  {string}\n * @return {string}\n */\nfunction encodeURIComponentPretty (str) {\n  return encodeURI(str).replace(/[\\/?#]/g, function (c) {\n    return '%' + c.charCodeAt(0).toString(16).toUpperCase()\n  })\n}\n\n/**\n * Encode the asterisk parameter. Similar to `pretty`, but allows slashes.\n *\n * @param  {string}\n * @return {string}\n */\nfunction encodeAsterisk (str) {\n  return encodeURI(str).replace(/[?#]/g, function (c) {\n    return '%' + c.charCodeAt(0).toString(16).toUpperCase()\n  })\n}\n\n/**\n * Expose a method for transforming tokens into the path function.\n */\nfunction tokensToFunction (tokens, options) {\n  // Compile all the tokens into regexps.\n  var matches = new Array(tokens.length)\n\n  // Compile all the patterns before compilation.\n  for (var i = 0; i < tokens.length; i++) {\n    if (typeof tokens[i] === 'object') {\n      matches[i] = new RegExp('^(?:' + tokens[i].pattern + ')$', flags(options))\n    }\n  }\n\n  return function (obj, opts) {\n    var path = ''\n    var data = obj || {}\n    var options = opts || {}\n    var encode = options.pretty ? encodeURIComponentPretty : encodeURIComponent\n\n    for (var i = 0; i < tokens.length; i++) {\n      var token = tokens[i]\n\n      if (typeof token === 'string') {\n        path += token\n\n        continue\n      }\n\n      var value = data[token.name]\n      var segment\n\n      if (value == null) {\n        if (token.optional) {\n          // Prepend partial segment prefixes.\n          if (token.partial) {\n            path += token.prefix\n          }\n\n          continue\n        } else {\n          throw new TypeError('Expected \"' + token.name + '\" to be defined')\n        }\n      }\n\n      if (isarray(value)) {\n        if (!token.repeat) {\n          throw new TypeError('Expected \"' + token.name + '\" to not repeat, but received `' + JSON.stringify(value) + '`')\n        }\n\n        if (value.length === 0) {\n          if (token.optional) {\n            continue\n          } else {\n            throw new TypeError('Expected \"' + token.name + '\" to not be empty')\n          }\n        }\n\n        for (var j = 0; j < value.length; j++) {\n          segment = encode(value[j])\n\n          if (!matches[i].test(segment)) {\n            throw new TypeError('Expected all \"' + token.name + '\" to match \"' + token.pattern + '\", but received `' + JSON.stringify(segment) + '`')\n          }\n\n          path += (j === 0 ? token.prefix : token.delimiter) + segment\n        }\n\n        continue\n      }\n\n      segment = token.asterisk ? encodeAsterisk(value) : encode(value)\n\n      if (!matches[i].test(segment)) {\n        throw new TypeError('Expected \"' + token.name + '\" to match \"' + token.pattern + '\", but received \"' + segment + '\"')\n      }\n\n      path += token.prefix + segment\n    }\n\n    return path\n  }\n}\n\n/**\n * Escape a regular expression string.\n *\n * @param  {string} str\n * @return {string}\n */\nfunction escapeString (str) {\n  return str.replace(/([.+*?=^!:${}()[\\]|\\/\\\\])/g, '\\\\$1')\n}\n\n/**\n * Escape the capturing group by escaping special characters and meaning.\n *\n * @param  {string} group\n * @return {string}\n */\nfunction escapeGroup (group) {\n  return group.replace(/([=!:$\\/()])/g, '\\\\$1')\n}\n\n/**\n * Attach the keys as a property of the regexp.\n *\n * @param  {!RegExp} re\n * @param  {Array}   keys\n * @return {!RegExp}\n */\nfunction attachKeys (re, keys) {\n  re.keys = keys\n  return re\n}\n\n/**\n * Get the flags for a regexp from the options.\n *\n * @param  {Object} options\n * @return {string}\n */\nfunction flags (options) {\n  return options && options.sensitive ? '' : 'i'\n}\n\n/**\n * Pull out keys from a regexp.\n *\n * @param  {!RegExp} path\n * @param  {!Array}  keys\n * @return {!RegExp}\n */\nfunction regexpToRegexp (path, keys) {\n  // Use a negative lookahead to match only capturing groups.\n  var groups = path.source.match(/\\((?!\\?)/g)\n\n  if (groups) {\n    for (var i = 0; i < groups.length; i++) {\n      keys.push({\n        name: i,\n        prefix: null,\n        delimiter: null,\n        optional: false,\n        repeat: false,\n        partial: false,\n        asterisk: false,\n        pattern: null\n      })\n    }\n  }\n\n  return attachKeys(path, keys)\n}\n\n/**\n * Transform an array into a regexp.\n *\n * @param  {!Array}  path\n * @param  {Array}   keys\n * @param  {!Object} options\n * @return {!RegExp}\n */\nfunction arrayToRegexp (path, keys, options) {\n  var parts = []\n\n  for (var i = 0; i < path.length; i++) {\n    parts.push(pathToRegexp(path[i], keys, options).source)\n  }\n\n  var regexp = new RegExp('(?:' + parts.join('|') + ')', flags(options))\n\n  return attachKeys(regexp, keys)\n}\n\n/**\n * Create a path regexp from string input.\n *\n * @param  {string}  path\n * @param  {!Array}  keys\n * @param  {!Object} options\n * @return {!RegExp}\n */\nfunction stringToRegexp (path, keys, options) {\n  return tokensToRegExp(parse(path, options), keys, options)\n}\n\n/**\n * Expose a function for taking tokens and returning a RegExp.\n *\n * @param  {!Array}          tokens\n * @param  {(Array|Object)=} keys\n * @param  {Object=}         options\n * @return {!RegExp}\n */\nfunction tokensToRegExp (tokens, keys, options) {\n  if (!isarray(keys)) {\n    options = /** @type {!Object} */ (keys || options)\n    keys = []\n  }\n\n  options = options || {}\n\n  var strict = options.strict\n  var end = options.end !== false\n  var route = ''\n\n  // Iterate over the tokens and create our regexp string.\n  for (var i = 0; i < tokens.length; i++) {\n    var token = tokens[i]\n\n    if (typeof token === 'string') {\n      route += escapeString(token)\n    } else {\n      var prefix = escapeString(token.prefix)\n      var capture = '(?:' + token.pattern + ')'\n\n      keys.push(token)\n\n      if (token.repeat) {\n        capture += '(?:' + prefix + capture + ')*'\n      }\n\n      if (token.optional) {\n        if (!token.partial) {\n          capture = '(?:' + prefix + '(' + capture + '))?'\n        } else {\n          capture = prefix + '(' + capture + ')?'\n        }\n      } else {\n        capture = prefix + '(' + capture + ')'\n      }\n\n      route += capture\n    }\n  }\n\n  var delimiter = escapeString(options.delimiter || '/')\n  var endsWithDelimiter = route.slice(-delimiter.length) === delimiter\n\n  // In non-strict mode we allow a slash at the end of match. If the path to\n  // match already ends with a slash, we remove it for consistency. The slash\n  // is valid at the end of a path match, not in the middle. This is important\n  // in non-ending mode, where \"/test/\" shouldn't match \"/test//route\".\n  if (!strict) {\n    route = (endsWithDelimiter ? route.slice(0, -delimiter.length) : route) + '(?:' + delimiter + '(?=$))?'\n  }\n\n  if (end) {\n    route += '$'\n  } else {\n    // In non-ending mode, we need the capturing groups to match as much as\n    // possible by using a positive lookahead to the end or next path segment.\n    route += strict && endsWithDelimiter ? '' : '(?=' + delimiter + '|$)'\n  }\n\n  return attachKeys(new RegExp('^' + route, flags(options)), keys)\n}\n\n/**\n * Normalize the given path string, returning a regular expression.\n *\n * An empty array can be passed in for the keys, which will hold the\n * placeholder key descriptions. For example, using `/user/:id`, `keys` will\n * contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.\n *\n * @param  {(string|RegExp|Array)} path\n * @param  {(Array|Object)=}       keys\n * @param  {Object=}               options\n * @return {!RegExp}\n */\nfunction pathToRegexp (path, keys, options) {\n  if (!isarray(keys)) {\n    options = /** @type {!Object} */ (keys || options)\n    keys = []\n  }\n\n  options = options || {}\n\n  if (path instanceof RegExp) {\n    return regexpToRegexp(path, /** @type {!Array} */ (keys))\n  }\n\n  if (isarray(path)) {\n    return arrayToRegexp(/** @type {!Array} */ (path), /** @type {!Array} */ (keys), options)\n  }\n\n  return stringToRegexp(/** @type {string} */ (path), /** @type {!Array} */ (keys), options)\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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O0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWSxTQUFTO0FBQ3JCLFlBQVksU0FBUztBQUNyQixZQUFZLFNBQVM7QUFDckIsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVksaUJBQWlCO0FBQzdCLFlBQVksaUJBQWlCO0FBQzdCLFlBQVksaUJBQWlCO0FBQzdCLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsU0FBUztBQUNsQztBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQixtQkFBbUI7QUFDckM7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSw0REFBNEQ7QUFDM0U7QUFDQSxZQUFZLHVCQUF1QjtBQUNuQyxZQUFZLHVCQUF1QjtBQUNuQyxZQUFZLHVCQUF1QjtBQUNuQyxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLFNBQVM7QUFDbEM7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLDJDQUEyQyxRQUFRO0FBQ25EOztBQUVBO0FBQ0Esb0NBQW9DLFFBQVEsc0JBQXNCLFFBQVE7QUFDMUU7O0FBRUEsbUNBQW1DLFFBQVEsc0JBQXNCLFFBQVE7QUFDekUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9ub2RlX21vZHVsZXMvcGF0aC10by1yZWdleHAvaW5kZXguanM/YmQxMSJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgaXNhcnJheSA9IHJlcXVpcmUoJ2lzYXJyYXknKVxuXG4vKipcbiAqIEV4cG9zZSBgcGF0aFRvUmVnZXhwYC5cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBwYXRoVG9SZWdleHBcbm1vZHVsZS5leHBvcnRzLnBhcnNlID0gcGFyc2Vcbm1vZHVsZS5leHBvcnRzLmNvbXBpbGUgPSBjb21waWxlXG5tb2R1bGUuZXhwb3J0cy50b2tlbnNUb0Z1bmN0aW9uID0gdG9rZW5zVG9GdW5jdGlvblxubW9kdWxlLmV4cG9ydHMudG9rZW5zVG9SZWdFeHAgPSB0b2tlbnNUb1JlZ0V4cFxuXG4vKipcbiAqIFRoZSBtYWluIHBhdGggbWF0Y2hpbmcgcmVnZXhwIHV0aWxpdHkuXG4gKlxuICogQHR5cGUge1JlZ0V4cH1cbiAqL1xudmFyIFBBVEhfUkVHRVhQID0gbmV3IFJlZ0V4cChbXG4gIC8vIE1hdGNoIGVzY2FwZWQgY2hhcmFjdGVycyB0aGF0IHdvdWxkIG90aGVyd2lzZSBhcHBlYXIgaW4gZnV0dXJlIG1hdGNoZXMuXG4gIC8vIFRoaXMgYWxsb3dzIHRoZSB1c2VyIHRvIGVzY2FwZSBzcGVjaWFsIGNoYXJhY3RlcnMgdGhhdCB3b24ndCB0cmFuc2Zvcm0uXG4gICcoXFxcXFxcXFwuKScsXG4gIC8vIE1hdGNoIEV4cHJlc3Mtc3R5bGUgcGFyYW1ldGVycyBhbmQgdW4tbmFtZWQgcGFyYW1ldGVycyB3aXRoIGEgcHJlZml4XG4gIC8vIGFuZCBvcHRpb25hbCBzdWZmaXhlcy4gTWF0Y2hlcyBhcHBlYXIgYXM6XG4gIC8vXG4gIC8vIFwiLzp0ZXN0KFxcXFxkKyk/XCIgPT4gW1wiL1wiLCBcInRlc3RcIiwgXCJcXGQrXCIsIHVuZGVmaW5lZCwgXCI/XCIsIHVuZGVmaW5lZF1cbiAgLy8gXCIvcm91dGUoXFxcXGQrKVwiICA9PiBbdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgXCJcXGQrXCIsIHVuZGVmaW5lZCwgdW5kZWZpbmVkXVxuICAvLyBcIi8qXCIgICAgICAgICAgICA9PiBbXCIvXCIsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgXCIqXCJdXG4gICcoW1xcXFwvLl0pPyg/Oig/OlxcXFw6KFxcXFx3KykoPzpcXFxcKCgoPzpcXFxcXFxcXC58W15cXFxcXFxcXCgpXSkrKVxcXFwpKT98XFxcXCgoKD86XFxcXFxcXFwufFteXFxcXFxcXFwoKV0pKylcXFxcKSkoWysqP10pP3woXFxcXCopKSdcbl0uam9pbignfCcpLCAnZycpXG5cbi8qKlxuICogUGFyc2UgYSBzdHJpbmcgZm9yIHRoZSByYXcgdG9rZW5zLlxuICpcbiAqIEBwYXJhbSAge3N0cmluZ30gIHN0clxuICogQHBhcmFtICB7T2JqZWN0PX0gb3B0aW9uc1xuICogQHJldHVybiB7IUFycmF5fVxuICovXG5mdW5jdGlvbiBwYXJzZSAoc3RyLCBvcHRpb25zKSB7XG4gIHZhciB0b2tlbnMgPSBbXVxuICB2YXIga2V5ID0gMFxuICB2YXIgaW5kZXggPSAwXG4gIHZhciBwYXRoID0gJydcbiAgdmFyIGRlZmF1bHREZWxpbWl0ZXIgPSBvcHRpb25zICYmIG9wdGlvbnMuZGVsaW1pdGVyIHx8ICcvJ1xuICB2YXIgcmVzXG5cbiAgd2hpbGUgKChyZXMgPSBQQVRIX1JFR0VYUC5leGVjKHN0cikpICE9IG51bGwpIHtcbiAgICB2YXIgbSA9IHJlc1swXVxuICAgIHZhciBlc2NhcGVkID0gcmVzWzFdXG4gICAgdmFyIG9mZnNldCA9IHJlcy5pbmRleFxuICAgIHBhdGggKz0gc3RyLnNsaWNlKGluZGV4LCBvZmZzZXQpXG4gICAgaW5kZXggPSBvZmZzZXQgKyBtLmxlbmd0aFxuXG4gICAgLy8gSWdub3JlIGFscmVhZHkgZXNjYXBlZCBzZXF1ZW5jZXMuXG4gICAgaWYgKGVzY2FwZWQpIHtcbiAgICAgIHBhdGggKz0gZXNjYXBlZFsxXVxuICAgICAgY29udGludWVcbiAgICB9XG5cbiAgICB2YXIgbmV4dCA9IHN0cltpbmRleF1cbiAgICB2YXIgcHJlZml4ID0gcmVzWzJdXG4gICAgdmFyIG5hbWUgPSByZXNbM11cbiAgICB2YXIgY2FwdHVyZSA9IHJlc1s0XVxuICAgIHZhciBncm91cCA9IHJlc1s1XVxuICAgIHZhciBtb2RpZmllciA9IHJlc1s2XVxuICAgIHZhciBhc3RlcmlzayA9IHJlc1s3XVxuXG4gICAgLy8gUHVzaCB0aGUgY3VycmVudCBwYXRoIG9udG8gdGhlIHRva2Vucy5cbiAgICBpZiAocGF0aCkge1xuICAgICAgdG9rZW5zLnB1c2gocGF0aClcbiAgICAgIHBhdGggPSAnJ1xuICAgIH1cblxuICAgIHZhciBwYXJ0aWFsID0gcHJlZml4ICE9IG51bGwgJiYgbmV4dCAhPSBudWxsICYmIG5leHQgIT09IHByZWZpeFxuICAgIHZhciByZXBlYXQgPSBtb2RpZmllciA9PT0gJysnIHx8IG1vZGlmaWVyID09PSAnKidcbiAgICB2YXIgb3B0aW9uYWwgPSBtb2RpZmllciA9PT0gJz8nIHx8IG1vZGlmaWVyID09PSAnKidcbiAgICB2YXIgZGVsaW1pdGVyID0gcmVzWzJdIHx8IGRlZmF1bHREZWxpbWl0ZXJcbiAgICB2YXIgcGF0dGVybiA9IGNhcHR1cmUgfHwgZ3JvdXBcblxuICAgIHRva2Vucy5wdXNoKHtcbiAgICAgIG5hbWU6IG5hbWUgfHwga2V5KyssXG4gICAgICBwcmVmaXg6IHByZWZpeCB8fCAnJyxcbiAgICAgIGRlbGltaXRlcjogZGVsaW1pdGVyLFxuICAgICAgb3B0aW9uYWw6IG9wdGlvbmFsLFxuICAgICAgcmVwZWF0OiByZXBlYXQsXG4gICAgICBwYXJ0aWFsOiBwYXJ0aWFsLFxuICAgICAgYXN0ZXJpc2s6ICEhYXN0ZXJpc2ssXG4gICAgICBwYXR0ZXJuOiBwYXR0ZXJuID8gZXNjYXBlR3JvdXAocGF0dGVybikgOiAoYXN0ZXJpc2sgPyAnLionIDogJ1teJyArIGVzY2FwZVN0cmluZyhkZWxpbWl0ZXIpICsgJ10rPycpXG4gICAgfSlcbiAgfVxuXG4gIC8vIE1hdGNoIGFueSBjaGFyYWN0ZXJzIHN0aWxsIHJlbWFpbmluZy5cbiAgaWYgKGluZGV4IDwgc3RyLmxlbmd0aCkge1xuICAgIHBhdGggKz0gc3RyLnN1YnN0cihpbmRleClcbiAgfVxuXG4gIC8vIElmIHRoZSBwYXRoIGV4aXN0cywgcHVzaCBpdCBvbnRvIHRoZSBlbmQuXG4gIGlmIChwYXRoKSB7XG4gICAgdG9rZW5zLnB1c2gocGF0aClcbiAgfVxuXG4gIHJldHVybiB0b2tlbnNcbn1cblxuLyoqXG4gKiBDb21waWxlIGEgc3RyaW5nIHRvIGEgdGVtcGxhdGUgZnVuY3Rpb24gZm9yIHRoZSBwYXRoLlxuICpcbiAqIEBwYXJhbSAge3N0cmluZ30gICAgICAgICAgICAgc3RyXG4gKiBAcGFyYW0gIHtPYmplY3Q9fSAgICAgICAgICAgIG9wdGlvbnNcbiAqIEByZXR1cm4geyFmdW5jdGlvbihPYmplY3Q9LCBPYmplY3Q9KX1cbiAqL1xuZnVuY3Rpb24gY29tcGlsZSAoc3RyLCBvcHRpb25zKSB7XG4gIHJldHVybiB0b2tlbnNUb0Z1bmN0aW9uKHBhcnNlKHN0ciwgb3B0aW9ucyksIG9wdGlvbnMpXG59XG5cbi8qKlxuICogUHJldHRpZXIgZW5jb2Rpbmcgb2YgVVJJIHBhdGggc2VnbWVudHMuXG4gKlxuICogQHBhcmFtICB7c3RyaW5nfVxuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBlbmNvZGVVUklDb21wb25lbnRQcmV0dHkgKHN0cikge1xuICByZXR1cm4gZW5jb2RlVVJJKHN0cikucmVwbGFjZSgvW1xcLz8jXS9nLCBmdW5jdGlvbiAoYykge1xuICAgIHJldHVybiAnJScgKyBjLmNoYXJDb2RlQXQoMCkudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKClcbiAgfSlcbn1cblxuLyoqXG4gKiBFbmNvZGUgdGhlIGFzdGVyaXNrIHBhcmFtZXRlci4gU2ltaWxhciB0byBgcHJldHR5YCwgYnV0IGFsbG93cyBzbGFzaGVzLlxuICpcbiAqIEBwYXJhbSAge3N0cmluZ31cbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gZW5jb2RlQXN0ZXJpc2sgKHN0cikge1xuICByZXR1cm4gZW5jb2RlVVJJKHN0cikucmVwbGFjZSgvWz8jXS9nLCBmdW5jdGlvbiAoYykge1xuICAgIHJldHVybiAnJScgKyBjLmNoYXJDb2RlQXQoMCkudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKClcbiAgfSlcbn1cblxuLyoqXG4gKiBFeHBvc2UgYSBtZXRob2QgZm9yIHRyYW5zZm9ybWluZyB0b2tlbnMgaW50byB0aGUgcGF0aCBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gdG9rZW5zVG9GdW5jdGlvbiAodG9rZW5zLCBvcHRpb25zKSB7XG4gIC8vIENvbXBpbGUgYWxsIHRoZSB0b2tlbnMgaW50byByZWdleHBzLlxuICB2YXIgbWF0Y2hlcyA9IG5ldyBBcnJheSh0b2tlbnMubGVuZ3RoKVxuXG4gIC8vIENvbXBpbGUgYWxsIHRoZSBwYXR0ZXJucyBiZWZvcmUgY29tcGlsYXRpb24uXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdG9rZW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKHR5cGVvZiB0b2tlbnNbaV0gPT09ICdvYmplY3QnKSB7XG4gICAgICBtYXRjaGVzW2ldID0gbmV3IFJlZ0V4cCgnXig/OicgKyB0b2tlbnNbaV0ucGF0dGVybiArICcpJCcsIGZsYWdzKG9wdGlvbnMpKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiAob2JqLCBvcHRzKSB7XG4gICAgdmFyIHBhdGggPSAnJ1xuICAgIHZhciBkYXRhID0gb2JqIHx8IHt9XG4gICAgdmFyIG9wdGlvbnMgPSBvcHRzIHx8IHt9XG4gICAgdmFyIGVuY29kZSA9IG9wdGlvbnMucHJldHR5ID8gZW5jb2RlVVJJQ29tcG9uZW50UHJldHR5IDogZW5jb2RlVVJJQ29tcG9uZW50XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRva2Vucy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHRva2VuID0gdG9rZW5zW2ldXG5cbiAgICAgIGlmICh0eXBlb2YgdG9rZW4gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHBhdGggKz0gdG9rZW5cblxuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICB2YXIgdmFsdWUgPSBkYXRhW3Rva2VuLm5hbWVdXG4gICAgICB2YXIgc2VnbWVudFxuXG4gICAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgICBpZiAodG9rZW4ub3B0aW9uYWwpIHtcbiAgICAgICAgICAvLyBQcmVwZW5kIHBhcnRpYWwgc2VnbWVudCBwcmVmaXhlcy5cbiAgICAgICAgICBpZiAodG9rZW4ucGFydGlhbCkge1xuICAgICAgICAgICAgcGF0aCArPSB0b2tlbi5wcmVmaXhcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0V4cGVjdGVkIFwiJyArIHRva2VuLm5hbWUgKyAnXCIgdG8gYmUgZGVmaW5lZCcpXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGlzYXJyYXkodmFsdWUpKSB7XG4gICAgICAgIGlmICghdG9rZW4ucmVwZWF0KSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgXCInICsgdG9rZW4ubmFtZSArICdcIiB0byBub3QgcmVwZWF0LCBidXQgcmVjZWl2ZWQgYCcgKyBKU09OLnN0cmluZ2lmeSh2YWx1ZSkgKyAnYCcpXG4gICAgICAgIH1cblxuICAgICAgICBpZiAodmFsdWUubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgaWYgKHRva2VuLm9wdGlvbmFsKSB7XG4gICAgICAgICAgICBjb250aW51ZVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdFeHBlY3RlZCBcIicgKyB0b2tlbi5uYW1lICsgJ1wiIHRvIG5vdCBiZSBlbXB0eScpXG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB2YWx1ZS5sZW5ndGg7IGorKykge1xuICAgICAgICAgIHNlZ21lbnQgPSBlbmNvZGUodmFsdWVbal0pXG5cbiAgICAgICAgICBpZiAoIW1hdGNoZXNbaV0udGVzdChzZWdtZW50KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgYWxsIFwiJyArIHRva2VuLm5hbWUgKyAnXCIgdG8gbWF0Y2ggXCInICsgdG9rZW4ucGF0dGVybiArICdcIiwgYnV0IHJlY2VpdmVkIGAnICsgSlNPTi5zdHJpbmdpZnkoc2VnbWVudCkgKyAnYCcpXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcGF0aCArPSAoaiA9PT0gMCA/IHRva2VuLnByZWZpeCA6IHRva2VuLmRlbGltaXRlcikgKyBzZWdtZW50XG4gICAgICAgIH1cblxuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICBzZWdtZW50ID0gdG9rZW4uYXN0ZXJpc2sgPyBlbmNvZGVBc3Rlcmlzayh2YWx1ZSkgOiBlbmNvZGUodmFsdWUpXG5cbiAgICAgIGlmICghbWF0Y2hlc1tpXS50ZXN0KHNlZ21lbnQpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0V4cGVjdGVkIFwiJyArIHRva2VuLm5hbWUgKyAnXCIgdG8gbWF0Y2ggXCInICsgdG9rZW4ucGF0dGVybiArICdcIiwgYnV0IHJlY2VpdmVkIFwiJyArIHNlZ21lbnQgKyAnXCInKVxuICAgICAgfVxuXG4gICAgICBwYXRoICs9IHRva2VuLnByZWZpeCArIHNlZ21lbnRcbiAgICB9XG5cbiAgICByZXR1cm4gcGF0aFxuICB9XG59XG5cbi8qKlxuICogRXNjYXBlIGEgcmVndWxhciBleHByZXNzaW9uIHN0cmluZy5cbiAqXG4gKiBAcGFyYW0gIHtzdHJpbmd9IHN0clxuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBlc2NhcGVTdHJpbmcgKHN0cikge1xuICByZXR1cm4gc3RyLnJlcGxhY2UoLyhbLisqPz1eIToke30oKVtcXF18XFwvXFxcXF0pL2csICdcXFxcJDEnKVxufVxuXG4vKipcbiAqIEVzY2FwZSB0aGUgY2FwdHVyaW5nIGdyb3VwIGJ5IGVzY2FwaW5nIHNwZWNpYWwgY2hhcmFjdGVycyBhbmQgbWVhbmluZy5cbiAqXG4gKiBAcGFyYW0gIHtzdHJpbmd9IGdyb3VwXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGVzY2FwZUdyb3VwIChncm91cCkge1xuICByZXR1cm4gZ3JvdXAucmVwbGFjZSgvKFs9ITokXFwvKCldKS9nLCAnXFxcXCQxJylcbn1cblxuLyoqXG4gKiBBdHRhY2ggdGhlIGtleXMgYXMgYSBwcm9wZXJ0eSBvZiB0aGUgcmVnZXhwLlxuICpcbiAqIEBwYXJhbSAgeyFSZWdFeHB9IHJlXG4gKiBAcGFyYW0gIHtBcnJheX0gICBrZXlzXG4gKiBAcmV0dXJuIHshUmVnRXhwfVxuICovXG5mdW5jdGlvbiBhdHRhY2hLZXlzIChyZSwga2V5cykge1xuICByZS5rZXlzID0ga2V5c1xuICByZXR1cm4gcmVcbn1cblxuLyoqXG4gKiBHZXQgdGhlIGZsYWdzIGZvciBhIHJlZ2V4cCBmcm9tIHRoZSBvcHRpb25zLlxuICpcbiAqIEBwYXJhbSAge09iamVjdH0gb3B0aW9uc1xuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBmbGFncyAob3B0aW9ucykge1xuICByZXR1cm4gb3B0aW9ucyAmJiBvcHRpb25zLnNlbnNpdGl2ZSA/ICcnIDogJ2knXG59XG5cbi8qKlxuICogUHVsbCBvdXQga2V5cyBmcm9tIGEgcmVnZXhwLlxuICpcbiAqIEBwYXJhbSAgeyFSZWdFeHB9IHBhdGhcbiAqIEBwYXJhbSAgeyFBcnJheX0gIGtleXNcbiAqIEByZXR1cm4geyFSZWdFeHB9XG4gKi9cbmZ1bmN0aW9uIHJlZ2V4cFRvUmVnZXhwIChwYXRoLCBrZXlzKSB7XG4gIC8vIFVzZSBhIG5lZ2F0aXZlIGxvb2thaGVhZCB0byBtYXRjaCBvbmx5IGNhcHR1cmluZyBncm91cHMuXG4gIHZhciBncm91cHMgPSBwYXRoLnNvdXJjZS5tYXRjaCgvXFwoKD8hXFw/KS9nKVxuXG4gIGlmIChncm91cHMpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGdyb3Vwcy5sZW5ndGg7IGkrKykge1xuICAgICAga2V5cy5wdXNoKHtcbiAgICAgICAgbmFtZTogaSxcbiAgICAgICAgcHJlZml4OiBudWxsLFxuICAgICAgICBkZWxpbWl0ZXI6IG51bGwsXG4gICAgICAgIG9wdGlvbmFsOiBmYWxzZSxcbiAgICAgICAgcmVwZWF0OiBmYWxzZSxcbiAgICAgICAgcGFydGlhbDogZmFsc2UsXG4gICAgICAgIGFzdGVyaXNrOiBmYWxzZSxcbiAgICAgICAgcGF0dGVybjogbnVsbFxuICAgICAgfSlcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYXR0YWNoS2V5cyhwYXRoLCBrZXlzKVxufVxuXG4vKipcbiAqIFRyYW5zZm9ybSBhbiBhcnJheSBpbnRvIGEgcmVnZXhwLlxuICpcbiAqIEBwYXJhbSAgeyFBcnJheX0gIHBhdGhcbiAqIEBwYXJhbSAge0FycmF5fSAgIGtleXNcbiAqIEBwYXJhbSAgeyFPYmplY3R9IG9wdGlvbnNcbiAqIEByZXR1cm4geyFSZWdFeHB9XG4gKi9cbmZ1bmN0aW9uIGFycmF5VG9SZWdleHAgKHBhdGgsIGtleXMsIG9wdGlvbnMpIHtcbiAgdmFyIHBhcnRzID0gW11cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHBhdGgubGVuZ3RoOyBpKyspIHtcbiAgICBwYXJ0cy5wdXNoKHBhdGhUb1JlZ2V4cChwYXRoW2ldLCBrZXlzLCBvcHRpb25zKS5zb3VyY2UpXG4gIH1cblxuICB2YXIgcmVnZXhwID0gbmV3IFJlZ0V4cCgnKD86JyArIHBhcnRzLmpvaW4oJ3wnKSArICcpJywgZmxhZ3Mob3B0aW9ucykpXG5cbiAgcmV0dXJuIGF0dGFjaEtleXMocmVnZXhwLCBrZXlzKVxufVxuXG4vKipcbiAqIENyZWF0ZSBhIHBhdGggcmVnZXhwIGZyb20gc3RyaW5nIGlucHV0LlxuICpcbiAqIEBwYXJhbSAge3N0cmluZ30gIHBhdGhcbiAqIEBwYXJhbSAgeyFBcnJheX0gIGtleXNcbiAqIEBwYXJhbSAgeyFPYmplY3R9IG9wdGlvbnNcbiAqIEByZXR1cm4geyFSZWdFeHB9XG4gKi9cbmZ1bmN0aW9uIHN0cmluZ1RvUmVnZXhwIChwYXRoLCBrZXlzLCBvcHRpb25zKSB7XG4gIHJldHVybiB0b2tlbnNUb1JlZ0V4cChwYXJzZShwYXRoLCBvcHRpb25zKSwga2V5cywgb3B0aW9ucylcbn1cblxuLyoqXG4gKiBFeHBvc2UgYSBmdW5jdGlvbiBmb3IgdGFraW5nIHRva2VucyBhbmQgcmV0dXJuaW5nIGEgUmVnRXhwLlxuICpcbiAqIEBwYXJhbSAgeyFBcnJheX0gICAgICAgICAgdG9rZW5zXG4gKiBAcGFyYW0gIHsoQXJyYXl8T2JqZWN0KT19IGtleXNcbiAqIEBwYXJhbSAge09iamVjdD19ICAgICAgICAgb3B0aW9uc1xuICogQHJldHVybiB7IVJlZ0V4cH1cbiAqL1xuZnVuY3Rpb24gdG9rZW5zVG9SZWdFeHAgKHRva2Vucywga2V5cywgb3B0aW9ucykge1xuICBpZiAoIWlzYXJyYXkoa2V5cykpIHtcbiAgICBvcHRpb25zID0gLyoqIEB0eXBlIHshT2JqZWN0fSAqLyAoa2V5cyB8fCBvcHRpb25zKVxuICAgIGtleXMgPSBbXVxuICB9XG5cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge31cblxuICB2YXIgc3RyaWN0ID0gb3B0aW9ucy5zdHJpY3RcbiAgdmFyIGVuZCA9IG9wdGlvbnMuZW5kICE9PSBmYWxzZVxuICB2YXIgcm91dGUgPSAnJ1xuXG4gIC8vIEl0ZXJhdGUgb3ZlciB0aGUgdG9rZW5zIGFuZCBjcmVhdGUgb3VyIHJlZ2V4cCBzdHJpbmcuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdG9rZW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHRva2VuID0gdG9rZW5zW2ldXG5cbiAgICBpZiAodHlwZW9mIHRva2VuID09PSAnc3RyaW5nJykge1xuICAgICAgcm91dGUgKz0gZXNjYXBlU3RyaW5nKHRva2VuKVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgcHJlZml4ID0gZXNjYXBlU3RyaW5nKHRva2VuLnByZWZpeClcbiAgICAgIHZhciBjYXB0dXJlID0gJyg/OicgKyB0b2tlbi5wYXR0ZXJuICsgJyknXG5cbiAgICAgIGtleXMucHVzaCh0b2tlbilcblxuICAgICAgaWYgKHRva2VuLnJlcGVhdCkge1xuICAgICAgICBjYXB0dXJlICs9ICcoPzonICsgcHJlZml4ICsgY2FwdHVyZSArICcpKidcbiAgICAgIH1cblxuICAgICAgaWYgKHRva2VuLm9wdGlvbmFsKSB7XG4gICAgICAgIGlmICghdG9rZW4ucGFydGlhbCkge1xuICAgICAgICAgIGNhcHR1cmUgPSAnKD86JyArIHByZWZpeCArICcoJyArIGNhcHR1cmUgKyAnKSk/J1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNhcHR1cmUgPSBwcmVmaXggKyAnKCcgKyBjYXB0dXJlICsgJyk/J1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjYXB0dXJlID0gcHJlZml4ICsgJygnICsgY2FwdHVyZSArICcpJ1xuICAgICAgfVxuXG4gICAgICByb3V0ZSArPSBjYXB0dXJlXG4gICAgfVxuICB9XG5cbiAgdmFyIGRlbGltaXRlciA9IGVzY2FwZVN0cmluZyhvcHRpb25zLmRlbGltaXRlciB8fCAnLycpXG4gIHZhciBlbmRzV2l0aERlbGltaXRlciA9IHJvdXRlLnNsaWNlKC1kZWxpbWl0ZXIubGVuZ3RoKSA9PT0gZGVsaW1pdGVyXG5cbiAgLy8gSW4gbm9uLXN0cmljdCBtb2RlIHdlIGFsbG93IGEgc2xhc2ggYXQgdGhlIGVuZCBvZiBtYXRjaC4gSWYgdGhlIHBhdGggdG9cbiAgLy8gbWF0Y2ggYWxyZWFkeSBlbmRzIHdpdGggYSBzbGFzaCwgd2UgcmVtb3ZlIGl0IGZvciBjb25zaXN0ZW5jeS4gVGhlIHNsYXNoXG4gIC8vIGlzIHZhbGlkIGF0IHRoZSBlbmQgb2YgYSBwYXRoIG1hdGNoLCBub3QgaW4gdGhlIG1pZGRsZS4gVGhpcyBpcyBpbXBvcnRhbnRcbiAgLy8gaW4gbm9uLWVuZGluZyBtb2RlLCB3aGVyZSBcIi90ZXN0L1wiIHNob3VsZG4ndCBtYXRjaCBcIi90ZXN0Ly9yb3V0ZVwiLlxuICBpZiAoIXN0cmljdCkge1xuICAgIHJvdXRlID0gKGVuZHNXaXRoRGVsaW1pdGVyID8gcm91dGUuc2xpY2UoMCwgLWRlbGltaXRlci5sZW5ndGgpIDogcm91dGUpICsgJyg/OicgKyBkZWxpbWl0ZXIgKyAnKD89JCkpPydcbiAgfVxuXG4gIGlmIChlbmQpIHtcbiAgICByb3V0ZSArPSAnJCdcbiAgfSBlbHNlIHtcbiAgICAvLyBJbiBub24tZW5kaW5nIG1vZGUsIHdlIG5lZWQgdGhlIGNhcHR1cmluZyBncm91cHMgdG8gbWF0Y2ggYXMgbXVjaCBhc1xuICAgIC8vIHBvc3NpYmxlIGJ5IHVzaW5nIGEgcG9zaXRpdmUgbG9va2FoZWFkIHRvIHRoZSBlbmQgb3IgbmV4dCBwYXRoIHNlZ21lbnQuXG4gICAgcm91dGUgKz0gc3RyaWN0ICYmIGVuZHNXaXRoRGVsaW1pdGVyID8gJycgOiAnKD89JyArIGRlbGltaXRlciArICd8JCknXG4gIH1cblxuICByZXR1cm4gYXR0YWNoS2V5cyhuZXcgUmVnRXhwKCdeJyArIHJvdXRlLCBmbGFncyhvcHRpb25zKSksIGtleXMpXG59XG5cbi8qKlxuICogTm9ybWFsaXplIHRoZSBnaXZlbiBwYXRoIHN0cmluZywgcmV0dXJuaW5nIGEgcmVndWxhciBleHByZXNzaW9uLlxuICpcbiAqIEFuIGVtcHR5IGFycmF5IGNhbiBiZSBwYXNzZWQgaW4gZm9yIHRoZSBrZXlzLCB3aGljaCB3aWxsIGhvbGQgdGhlXG4gKiBwbGFjZWhvbGRlciBrZXkgZGVzY3JpcHRpb25zLiBGb3IgZXhhbXBsZSwgdXNpbmcgYC91c2VyLzppZGAsIGBrZXlzYCB3aWxsXG4gKiBjb250YWluIGBbeyBuYW1lOiAnaWQnLCBkZWxpbWl0ZXI6ICcvJywgb3B0aW9uYWw6IGZhbHNlLCByZXBlYXQ6IGZhbHNlIH1dYC5cbiAqXG4gKiBAcGFyYW0gIHsoc3RyaW5nfFJlZ0V4cHxBcnJheSl9IHBhdGhcbiAqIEBwYXJhbSAgeyhBcnJheXxPYmplY3QpPX0gICAgICAga2V5c1xuICogQHBhcmFtICB7T2JqZWN0PX0gICAgICAgICAgICAgICBvcHRpb25zXG4gKiBAcmV0dXJuIHshUmVnRXhwfVxuICovXG5mdW5jdGlvbiBwYXRoVG9SZWdleHAgKHBhdGgsIGtleXMsIG9wdGlvbnMpIHtcbiAgaWYgKCFpc2FycmF5KGtleXMpKSB7XG4gICAgb3B0aW9ucyA9IC8qKiBAdHlwZSB7IU9iamVjdH0gKi8gKGtleXMgfHwgb3B0aW9ucylcbiAgICBrZXlzID0gW11cbiAgfVxuXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9XG5cbiAgaWYgKHBhdGggaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICByZXR1cm4gcmVnZXhwVG9SZWdleHAocGF0aCwgLyoqIEB0eXBlIHshQXJyYXl9ICovIChrZXlzKSlcbiAgfVxuXG4gIGlmIChpc2FycmF5KHBhdGgpKSB7XG4gICAgcmV0dXJuIGFycmF5VG9SZWdleHAoLyoqIEB0eXBlIHshQXJyYXl9ICovIChwYXRoKSwgLyoqIEB0eXBlIHshQXJyYXl9ICovIChrZXlzKSwgb3B0aW9ucylcbiAgfVxuXG4gIHJldHVybiBzdHJpbmdUb1JlZ2V4cCgvKiogQHR5cGUge3N0cmluZ30gKi8gKHBhdGgpLCAvKiogQHR5cGUgeyFBcnJheX0gKi8gKGtleXMpLCBvcHRpb25zKVxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///779\n")},703:(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n\nvar ReactPropTypesSecret = __webpack_require__(414);\n\nfunction emptyFunction() {}\nfunction emptyFunctionWithReset() {}\nemptyFunctionWithReset.resetWarningCache = emptyFunction;\n\nmodule.exports = function() {\n  function shim(props, propName, componentName, location, propFullName, secret) {\n    if (secret === ReactPropTypesSecret) {\n      // It is still safe when called from React.\n      return;\n    }\n    var err = new Error(\n      'Calling PropTypes validators directly is not supported by the `prop-types` package. ' +\n      'Use PropTypes.checkPropTypes() to call them. ' +\n      'Read more at http://fb.me/use-check-prop-types'\n    );\n    err.name = 'Invariant Violation';\n    throw err;\n  };\n  shim.isRequired = shim;\n  function getShim() {\n    return shim;\n  };\n  // Important!\n  // Keep this list in sync with production version in `./factoryWithTypeCheckers.js`.\n  var ReactPropTypes = {\n    array: shim,\n    bool: shim,\n    func: shim,\n    number: shim,\n    object: shim,\n    string: shim,\n    symbol: shim,\n\n    any: shim,\n    arrayOf: getShim,\n    element: shim,\n    elementType: shim,\n    instanceOf: getShim,\n    node: shim,\n    objectOf: getShim,\n    oneOf: getShim,\n    oneOfType: getShim,\n    shape: getShim,\n    exact: getShim,\n\n    checkPropTypes: emptyFunctionWithReset,\n    resetWarningCache: emptyFunction\n  };\n\n  ReactPropTypes.PropTypes = ReactPropTypes;\n\n  return ReactPropTypes;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzAzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFYTs7QUFFYiwyQkFBMkIsbUJBQU8sQ0FBQyxHQUE0Qjs7QUFFL0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9ub2RlX21vZHVsZXMvcHJvcC10eXBlcy9mYWN0b3J5V2l0aFRocm93aW5nU2hpbXMuanM/ZDdhMCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0UHJvcFR5cGVzU2VjcmV0ID0gcmVxdWlyZSgnLi9saWIvUmVhY3RQcm9wVHlwZXNTZWNyZXQnKTtcblxuZnVuY3Rpb24gZW1wdHlGdW5jdGlvbigpIHt9XG5mdW5jdGlvbiBlbXB0eUZ1bmN0aW9uV2l0aFJlc2V0KCkge31cbmVtcHR5RnVuY3Rpb25XaXRoUmVzZXQucmVzZXRXYXJuaW5nQ2FjaGUgPSBlbXB0eUZ1bmN0aW9uO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKCkge1xuICBmdW5jdGlvbiBzaGltKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSwgc2VjcmV0KSB7XG4gICAgaWYgKHNlY3JldCA9PT0gUmVhY3RQcm9wVHlwZXNTZWNyZXQpIHtcbiAgICAgIC8vIEl0IGlzIHN0aWxsIHNhZmUgd2hlbiBjYWxsZWQgZnJvbSBSZWFjdC5cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIGVyciA9IG5ldyBFcnJvcihcbiAgICAgICdDYWxsaW5nIFByb3BUeXBlcyB2YWxpZGF0b3JzIGRpcmVjdGx5IGlzIG5vdCBzdXBwb3J0ZWQgYnkgdGhlIGBwcm9wLXR5cGVzYCBwYWNrYWdlLiAnICtcbiAgICAgICdVc2UgUHJvcFR5cGVzLmNoZWNrUHJvcFR5cGVzKCkgdG8gY2FsbCB0aGVtLiAnICtcbiAgICAgICdSZWFkIG1vcmUgYXQgaHR0cDovL2ZiLm1lL3VzZS1jaGVjay1wcm9wLXR5cGVzJ1xuICAgICk7XG4gICAgZXJyLm5hbWUgPSAnSW52YXJpYW50IFZpb2xhdGlvbic7XG4gICAgdGhyb3cgZXJyO1xuICB9O1xuICBzaGltLmlzUmVxdWlyZWQgPSBzaGltO1xuICBmdW5jdGlvbiBnZXRTaGltKCkge1xuICAgIHJldHVybiBzaGltO1xuICB9O1xuICAvLyBJbXBvcnRhbnQhXG4gIC8vIEtlZXAgdGhpcyBsaXN0IGluIHN5bmMgd2l0aCBwcm9kdWN0aW9uIHZlcnNpb24gaW4gYC4vZmFjdG9yeVdpdGhUeXBlQ2hlY2tlcnMuanNgLlxuICB2YXIgUmVhY3RQcm9wVHlwZXMgPSB7XG4gICAgYXJyYXk6IHNoaW0sXG4gICAgYm9vbDogc2hpbSxcbiAgICBmdW5jOiBzaGltLFxuICAgIG51bWJlcjogc2hpbSxcbiAgICBvYmplY3Q6IHNoaW0sXG4gICAgc3RyaW5nOiBzaGltLFxuICAgIHN5bWJvbDogc2hpbSxcblxuICAgIGFueTogc2hpbSxcbiAgICBhcnJheU9mOiBnZXRTaGltLFxuICAgIGVsZW1lbnQ6IHNoaW0sXG4gICAgZWxlbWVudFR5cGU6IHNoaW0sXG4gICAgaW5zdGFuY2VPZjogZ2V0U2hpbSxcbiAgICBub2RlOiBzaGltLFxuICAgIG9iamVjdE9mOiBnZXRTaGltLFxuICAgIG9uZU9mOiBnZXRTaGltLFxuICAgIG9uZU9mVHlwZTogZ2V0U2hpbSxcbiAgICBzaGFwZTogZ2V0U2hpbSxcbiAgICBleGFjdDogZ2V0U2hpbSxcblxuICAgIGNoZWNrUHJvcFR5cGVzOiBlbXB0eUZ1bmN0aW9uV2l0aFJlc2V0LFxuICAgIHJlc2V0V2FybmluZ0NhY2hlOiBlbXB0eUZ1bmN0aW9uXG4gIH07XG5cbiAgUmVhY3RQcm9wVHlwZXMuUHJvcFR5cGVzID0gUmVhY3RQcm9wVHlwZXM7XG5cbiAgcmV0dXJuIFJlYWN0UHJvcFR5cGVzO1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///703\n")},697:(module,__unused_webpack_exports,__webpack_require__)=>{eval("/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nif (false) { var throwOnDirectAccess, ReactIs; } else {\n  // By explicitly using `prop-types` you are opting into new production behavior.\n  // http://fb.me/prop-types-in-prod\n  module.exports = __webpack_require__(703)();\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjk3LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxJQUFJLEtBQXFDLEVBQUUscUNBTzFDLENBQUM7QUFDRjtBQUNBO0FBQ0EsbUJBQW1CLG1CQUFPLENBQUMsR0FBNEI7QUFDdkQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9ub2RlX21vZHVsZXMvcHJvcC10eXBlcy9pbmRleC5qcz9kN2JjIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgdmFyIFJlYWN0SXMgPSByZXF1aXJlKCdyZWFjdC1pcycpO1xuXG4gIC8vIEJ5IGV4cGxpY2l0bHkgdXNpbmcgYHByb3AtdHlwZXNgIHlvdSBhcmUgb3B0aW5nIGludG8gbmV3IGRldmVsb3BtZW50IGJlaGF2aW9yLlxuICAvLyBodHRwOi8vZmIubWUvcHJvcC10eXBlcy1pbi1wcm9kXG4gIHZhciB0aHJvd09uRGlyZWN0QWNjZXNzID0gdHJ1ZTtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2ZhY3RvcnlXaXRoVHlwZUNoZWNrZXJzJykoUmVhY3RJcy5pc0VsZW1lbnQsIHRocm93T25EaXJlY3RBY2Nlc3MpO1xufSBlbHNlIHtcbiAgLy8gQnkgZXhwbGljaXRseSB1c2luZyBgcHJvcC10eXBlc2AgeW91IGFyZSBvcHRpbmcgaW50byBuZXcgcHJvZHVjdGlvbiBiZWhhdmlvci5cbiAgLy8gaHR0cDovL2ZiLm1lL3Byb3AtdHlwZXMtaW4tcHJvZFxuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vZmFjdG9yeVdpdGhUaHJvd2luZ1NoaW1zJykoKTtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///697\n")},414:module=>{"use strict";eval("/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n\nvar ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';\n\nmodule.exports = ReactPropTypesSecret;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDE0LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFYTs7QUFFYjs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL21kYy1yZWFjdC8uL25vZGVfbW9kdWxlcy9wcm9wLXR5cGVzL2xpYi9SZWFjdFByb3BUeXBlc1NlY3JldC5qcz81OWIwIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3RQcm9wVHlwZXNTZWNyZXQgPSAnU0VDUkVUX0RPX05PVF9QQVNTX1RISVNfT1JfWU9VX1dJTExfQkVfRklSRUQnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0UHJvcFR5cGVzU2VjcmV0O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///414\n")},448:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('/** @license React v17.0.2\n * react-dom.production.min.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n/*\n Modernizr 3.0.0pre (Custom Build) | MIT\n*/\nvar aa=__webpack_require__(294),m=__webpack_require__(418),r=__webpack_require__(840);function y(a){for(var b="https://reactjs.org/docs/error-decoder.html?invariant="+a,c=1;c<arguments.length;c++)b+="&args[]="+encodeURIComponent(arguments[c]);return"Minified React error #"+a+"; visit "+b+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}if(!aa)throw Error(y(227));var ba=new Set,ca={};function da(a,b){ea(a,b);ea(a+"Capture",b)}\nfunction ea(a,b){ca[a]=b;for(a=0;a<b.length;a++)ba.add(b[a])}\nvar fa=!("undefined"===typeof window||"undefined"===typeof window.document||"undefined"===typeof window.document.createElement),ha=/^[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$/,ia=Object.prototype.hasOwnProperty,\nja={},ka={};function la(a){if(ia.call(ka,a))return!0;if(ia.call(ja,a))return!1;if(ha.test(a))return ka[a]=!0;ja[a]=!0;return!1}function ma(a,b,c,d){if(null!==c&&0===c.type)return!1;switch(typeof b){case "function":case "symbol":return!0;case "boolean":if(d)return!1;if(null!==c)return!c.acceptsBooleans;a=a.toLowerCase().slice(0,5);return"data-"!==a&&"aria-"!==a;default:return!1}}\nfunction na(a,b,c,d){if(null===b||"undefined"===typeof b||ma(a,b,c,d))return!0;if(d)return!1;if(null!==c)switch(c.type){case 3:return!b;case 4:return!1===b;case 5:return isNaN(b);case 6:return isNaN(b)||1>b}return!1}function B(a,b,c,d,e,f,g){this.acceptsBooleans=2===b||3===b||4===b;this.attributeName=d;this.attributeNamespace=e;this.mustUseProperty=c;this.propertyName=a;this.type=b;this.sanitizeURL=f;this.removeEmptyString=g}var D={};\n"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(a){D[a]=new B(a,0,!1,a,null,!1,!1)});[["acceptCharset","accept-charset"],["className","class"],["htmlFor","for"],["httpEquiv","http-equiv"]].forEach(function(a){var b=a[0];D[b]=new B(b,1,!1,a[1],null,!1,!1)});["contentEditable","draggable","spellCheck","value"].forEach(function(a){D[a]=new B(a,2,!1,a.toLowerCase(),null,!1,!1)});\n["autoReverse","externalResourcesRequired","focusable","preserveAlpha"].forEach(function(a){D[a]=new B(a,2,!1,a,null,!1,!1)});"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(a){D[a]=new B(a,3,!1,a.toLowerCase(),null,!1,!1)});\n["checked","multiple","muted","selected"].forEach(function(a){D[a]=new B(a,3,!0,a,null,!1,!1)});["capture","download"].forEach(function(a){D[a]=new B(a,4,!1,a,null,!1,!1)});["cols","rows","size","span"].forEach(function(a){D[a]=new B(a,6,!1,a,null,!1,!1)});["rowSpan","start"].forEach(function(a){D[a]=new B(a,5,!1,a.toLowerCase(),null,!1,!1)});var oa=/[\\-:]([a-z])/g;function pa(a){return a[1].toUpperCase()}\n"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(a){var b=a.replace(oa,\npa);D[b]=new B(b,1,!1,a,null,!1,!1)});"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(a){var b=a.replace(oa,pa);D[b]=new B(b,1,!1,a,"http://www.w3.org/1999/xlink",!1,!1)});["xml:base","xml:lang","xml:space"].forEach(function(a){var b=a.replace(oa,pa);D[b]=new B(b,1,!1,a,"http://www.w3.org/XML/1998/namespace",!1,!1)});["tabIndex","crossOrigin"].forEach(function(a){D[a]=new B(a,1,!1,a.toLowerCase(),null,!1,!1)});\nD.xlinkHref=new B("xlinkHref",1,!1,"xlink:href","http://www.w3.org/1999/xlink",!0,!1);["src","href","action","formAction"].forEach(function(a){D[a]=new B(a,1,!1,a.toLowerCase(),null,!0,!0)});\nfunction qa(a,b,c,d){var e=D.hasOwnProperty(b)?D[b]:null;var f=null!==e?0===e.type:d?!1:!(2<b.length)||"o"!==b[0]&&"O"!==b[0]||"n"!==b[1]&&"N"!==b[1]?!1:!0;f||(na(b,c,e,d)&&(c=null),d||null===e?la(b)&&(null===c?a.removeAttribute(b):a.setAttribute(b,""+c)):e.mustUseProperty?a[e.propertyName]=null===c?3===e.type?!1:"":c:(b=e.attributeName,d=e.attributeNamespace,null===c?a.removeAttribute(b):(e=e.type,c=3===e||4===e&&!0===c?"":""+c,d?a.setAttributeNS(d,b,c):a.setAttribute(b,c))))}\nvar ra=aa.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,sa=60103,ta=60106,ua=60107,wa=60108,xa=60114,ya=60109,za=60110,Aa=60112,Ba=60113,Ca=60120,Da=60115,Ea=60116,Fa=60121,Ga=60128,Ha=60129,Ia=60130,Ja=60131;\nif("function"===typeof Symbol&&Symbol.for){var E=Symbol.for;sa=E("react.element");ta=E("react.portal");ua=E("react.fragment");wa=E("react.strict_mode");xa=E("react.profiler");ya=E("react.provider");za=E("react.context");Aa=E("react.forward_ref");Ba=E("react.suspense");Ca=E("react.suspense_list");Da=E("react.memo");Ea=E("react.lazy");Fa=E("react.block");E("react.scope");Ga=E("react.opaque.id");Ha=E("react.debug_trace_mode");Ia=E("react.offscreen");Ja=E("react.legacy_hidden")}\nvar Ka="function"===typeof Symbol&&Symbol.iterator;function La(a){if(null===a||"object"!==typeof a)return null;a=Ka&&a[Ka]||a["@@iterator"];return"function"===typeof a?a:null}var Ma;function Na(a){if(void 0===Ma)try{throw Error();}catch(c){var b=c.stack.trim().match(/\\n( *(at )?)/);Ma=b&&b[1]||""}return"\\n"+Ma+a}var Oa=!1;\nfunction Pa(a,b){if(!a||Oa)return"";Oa=!0;var c=Error.prepareStackTrace;Error.prepareStackTrace=void 0;try{if(b)if(b=function(){throw Error();},Object.defineProperty(b.prototype,"props",{set:function(){throw Error();}}),"object"===typeof Reflect&&Reflect.construct){try{Reflect.construct(b,[])}catch(k){var d=k}Reflect.construct(a,[],b)}else{try{b.call()}catch(k){d=k}a.call(b.prototype)}else{try{throw Error();}catch(k){d=k}a()}}catch(k){if(k&&d&&"string"===typeof k.stack){for(var e=k.stack.split("\\n"),\nf=d.stack.split("\\n"),g=e.length-1,h=f.length-1;1<=g&&0<=h&&e[g]!==f[h];)h--;for(;1<=g&&0<=h;g--,h--)if(e[g]!==f[h]){if(1!==g||1!==h){do if(g--,h--,0>h||e[g]!==f[h])return"\\n"+e[g].replace(" at new "," at ");while(1<=g&&0<=h)}break}}}finally{Oa=!1,Error.prepareStackTrace=c}return(a=a?a.displayName||a.name:"")?Na(a):""}\nfunction Qa(a){switch(a.tag){case 5:return Na(a.type);case 16:return Na("Lazy");case 13:return Na("Suspense");case 19:return Na("SuspenseList");case 0:case 2:case 15:return a=Pa(a.type,!1),a;case 11:return a=Pa(a.type.render,!1),a;case 22:return a=Pa(a.type._render,!1),a;case 1:return a=Pa(a.type,!0),a;default:return""}}\nfunction Ra(a){if(null==a)return null;if("function"===typeof a)return a.displayName||a.name||null;if("string"===typeof a)return a;switch(a){case ua:return"Fragment";case ta:return"Portal";case xa:return"Profiler";case wa:return"StrictMode";case Ba:return"Suspense";case Ca:return"SuspenseList"}if("object"===typeof a)switch(a.$$typeof){case za:return(a.displayName||"Context")+".Consumer";case ya:return(a._context.displayName||"Context")+".Provider";case Aa:var b=a.render;b=b.displayName||b.name||"";\nreturn a.displayName||(""!==b?"ForwardRef("+b+")":"ForwardRef");case Da:return Ra(a.type);case Fa:return Ra(a._render);case Ea:b=a._payload;a=a._init;try{return Ra(a(b))}catch(c){}}return null}function Sa(a){switch(typeof a){case "boolean":case "number":case "object":case "string":case "undefined":return a;default:return""}}function Ta(a){var b=a.type;return(a=a.nodeName)&&"input"===a.toLowerCase()&&("checkbox"===b||"radio"===b)}\nfunction Ua(a){var b=Ta(a)?"checked":"value",c=Object.getOwnPropertyDescriptor(a.constructor.prototype,b),d=""+a[b];if(!a.hasOwnProperty(b)&&"undefined"!==typeof c&&"function"===typeof c.get&&"function"===typeof c.set){var e=c.get,f=c.set;Object.defineProperty(a,b,{configurable:!0,get:function(){return e.call(this)},set:function(a){d=""+a;f.call(this,a)}});Object.defineProperty(a,b,{enumerable:c.enumerable});return{getValue:function(){return d},setValue:function(a){d=""+a},stopTracking:function(){a._valueTracker=\nnull;delete a[b]}}}}function Va(a){a._valueTracker||(a._valueTracker=Ua(a))}function Wa(a){if(!a)return!1;var b=a._valueTracker;if(!b)return!0;var c=b.getValue();var d="";a&&(d=Ta(a)?a.checked?"true":"false":a.value);a=d;return a!==c?(b.setValue(a),!0):!1}function Xa(a){a=a||("undefined"!==typeof document?document:void 0);if("undefined"===typeof a)return null;try{return a.activeElement||a.body}catch(b){return a.body}}\nfunction Ya(a,b){var c=b.checked;return m({},b,{defaultChecked:void 0,defaultValue:void 0,value:void 0,checked:null!=c?c:a._wrapperState.initialChecked})}function Za(a,b){var c=null==b.defaultValue?"":b.defaultValue,d=null!=b.checked?b.checked:b.defaultChecked;c=Sa(null!=b.value?b.value:c);a._wrapperState={initialChecked:d,initialValue:c,controlled:"checkbox"===b.type||"radio"===b.type?null!=b.checked:null!=b.value}}function $a(a,b){b=b.checked;null!=b&&qa(a,"checked",b,!1)}\nfunction ab(a,b){$a(a,b);var c=Sa(b.value),d=b.type;if(null!=c)if("number"===d){if(0===c&&""===a.value||a.value!=c)a.value=""+c}else a.value!==""+c&&(a.value=""+c);else if("submit"===d||"reset"===d){a.removeAttribute("value");return}b.hasOwnProperty("value")?bb(a,b.type,c):b.hasOwnProperty("defaultValue")&&bb(a,b.type,Sa(b.defaultValue));null==b.checked&&null!=b.defaultChecked&&(a.defaultChecked=!!b.defaultChecked)}\nfunction cb(a,b,c){if(b.hasOwnProperty("value")||b.hasOwnProperty("defaultValue")){var d=b.type;if(!("submit"!==d&&"reset"!==d||void 0!==b.value&&null!==b.value))return;b=""+a._wrapperState.initialValue;c||b===a.value||(a.value=b);a.defaultValue=b}c=a.name;""!==c&&(a.name="");a.defaultChecked=!!a._wrapperState.initialChecked;""!==c&&(a.name=c)}\nfunction bb(a,b,c){if("number"!==b||Xa(a.ownerDocument)!==a)null==c?a.defaultValue=""+a._wrapperState.initialValue:a.defaultValue!==""+c&&(a.defaultValue=""+c)}function db(a){var b="";aa.Children.forEach(a,function(a){null!=a&&(b+=a)});return b}function eb(a,b){a=m({children:void 0},b);if(b=db(b.children))a.children=b;return a}\nfunction fb(a,b,c,d){a=a.options;if(b){b={};for(var e=0;e<c.length;e++)b["$"+c[e]]=!0;for(c=0;c<a.length;c++)e=b.hasOwnProperty("$"+a[c].value),a[c].selected!==e&&(a[c].selected=e),e&&d&&(a[c].defaultSelected=!0)}else{c=""+Sa(c);b=null;for(e=0;e<a.length;e++){if(a[e].value===c){a[e].selected=!0;d&&(a[e].defaultSelected=!0);return}null!==b||a[e].disabled||(b=a[e])}null!==b&&(b.selected=!0)}}\nfunction gb(a,b){if(null!=b.dangerouslySetInnerHTML)throw Error(y(91));return m({},b,{value:void 0,defaultValue:void 0,children:""+a._wrapperState.initialValue})}function hb(a,b){var c=b.value;if(null==c){c=b.children;b=b.defaultValue;if(null!=c){if(null!=b)throw Error(y(92));if(Array.isArray(c)){if(!(1>=c.length))throw Error(y(93));c=c[0]}b=c}null==b&&(b="");c=b}a._wrapperState={initialValue:Sa(c)}}\nfunction ib(a,b){var c=Sa(b.value),d=Sa(b.defaultValue);null!=c&&(c=""+c,c!==a.value&&(a.value=c),null==b.defaultValue&&a.defaultValue!==c&&(a.defaultValue=c));null!=d&&(a.defaultValue=""+d)}function jb(a){var b=a.textContent;b===a._wrapperState.initialValue&&""!==b&&null!==b&&(a.value=b)}var kb={html:"http://www.w3.org/1999/xhtml",mathml:"http://www.w3.org/1998/Math/MathML",svg:"http://www.w3.org/2000/svg"};\nfunction lb(a){switch(a){case "svg":return"http://www.w3.org/2000/svg";case "math":return"http://www.w3.org/1998/Math/MathML";default:return"http://www.w3.org/1999/xhtml"}}function mb(a,b){return null==a||"http://www.w3.org/1999/xhtml"===a?lb(b):"http://www.w3.org/2000/svg"===a&&"foreignObject"===b?"http://www.w3.org/1999/xhtml":a}\nvar nb,ob=function(a){return"undefined"!==typeof MSApp&&MSApp.execUnsafeLocalFunction?function(b,c,d,e){MSApp.execUnsafeLocalFunction(function(){return a(b,c,d,e)})}:a}(function(a,b){if(a.namespaceURI!==kb.svg||"innerHTML"in a)a.innerHTML=b;else{nb=nb||document.createElement("div");nb.innerHTML="<svg>"+b.valueOf().toString()+"</svg>";for(b=nb.firstChild;a.firstChild;)a.removeChild(a.firstChild);for(;b.firstChild;)a.appendChild(b.firstChild)}});\nfunction pb(a,b){if(b){var c=a.firstChild;if(c&&c===a.lastChild&&3===c.nodeType){c.nodeValue=b;return}}a.textContent=b}\nvar qb={animationIterationCount:!0,borderImageOutset:!0,borderImageSlice:!0,borderImageWidth:!0,boxFlex:!0,boxFlexGroup:!0,boxOrdinalGroup:!0,columnCount:!0,columns:!0,flex:!0,flexGrow:!0,flexPositive:!0,flexShrink:!0,flexNegative:!0,flexOrder:!0,gridArea:!0,gridRow:!0,gridRowEnd:!0,gridRowSpan:!0,gridRowStart:!0,gridColumn:!0,gridColumnEnd:!0,gridColumnSpan:!0,gridColumnStart:!0,fontWeight:!0,lineClamp:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,tabSize:!0,widows:!0,zIndex:!0,zoom:!0,fillOpacity:!0,\nfloodOpacity:!0,stopOpacity:!0,strokeDasharray:!0,strokeDashoffset:!0,strokeMiterlimit:!0,strokeOpacity:!0,strokeWidth:!0},rb=["Webkit","ms","Moz","O"];Object.keys(qb).forEach(function(a){rb.forEach(function(b){b=b+a.charAt(0).toUpperCase()+a.substring(1);qb[b]=qb[a]})});function sb(a,b,c){return null==b||"boolean"===typeof b||""===b?"":c||"number"!==typeof b||0===b||qb.hasOwnProperty(a)&&qb[a]?(""+b).trim():b+"px"}\nfunction tb(a,b){a=a.style;for(var c in b)if(b.hasOwnProperty(c)){var d=0===c.indexOf("--"),e=sb(c,b[c],d);"float"===c&&(c="cssFloat");d?a.setProperty(c,e):a[c]=e}}var ub=m({menuitem:!0},{area:!0,base:!0,br:!0,col:!0,embed:!0,hr:!0,img:!0,input:!0,keygen:!0,link:!0,meta:!0,param:!0,source:!0,track:!0,wbr:!0});\nfunction vb(a,b){if(b){if(ub[a]&&(null!=b.children||null!=b.dangerouslySetInnerHTML))throw Error(y(137,a));if(null!=b.dangerouslySetInnerHTML){if(null!=b.children)throw Error(y(60));if(!("object"===typeof b.dangerouslySetInnerHTML&&"__html"in b.dangerouslySetInnerHTML))throw Error(y(61));}if(null!=b.style&&"object"!==typeof b.style)throw Error(y(62));}}\nfunction wb(a,b){if(-1===a.indexOf("-"))return"string"===typeof b.is;switch(a){case "annotation-xml":case "color-profile":case "font-face":case "font-face-src":case "font-face-uri":case "font-face-format":case "font-face-name":case "missing-glyph":return!1;default:return!0}}function xb(a){a=a.target||a.srcElement||window;a.correspondingUseElement&&(a=a.correspondingUseElement);return 3===a.nodeType?a.parentNode:a}var yb=null,zb=null,Ab=null;\nfunction Bb(a){if(a=Cb(a)){if("function"!==typeof yb)throw Error(y(280));var b=a.stateNode;b&&(b=Db(b),yb(a.stateNode,a.type,b))}}function Eb(a){zb?Ab?Ab.push(a):Ab=[a]:zb=a}function Fb(){if(zb){var a=zb,b=Ab;Ab=zb=null;Bb(a);if(b)for(a=0;a<b.length;a++)Bb(b[a])}}function Gb(a,b){return a(b)}function Hb(a,b,c,d,e){return a(b,c,d,e)}function Ib(){}var Jb=Gb,Kb=!1,Lb=!1;function Mb(){if(null!==zb||null!==Ab)Ib(),Fb()}\nfunction Nb(a,b,c){if(Lb)return a(b,c);Lb=!0;try{return Jb(a,b,c)}finally{Lb=!1,Mb()}}\nfunction Ob(a,b){var c=a.stateNode;if(null===c)return null;var d=Db(c);if(null===d)return null;c=d[b];a:switch(b){case "onClick":case "onClickCapture":case "onDoubleClick":case "onDoubleClickCapture":case "onMouseDown":case "onMouseDownCapture":case "onMouseMove":case "onMouseMoveCapture":case "onMouseUp":case "onMouseUpCapture":case "onMouseEnter":(d=!d.disabled)||(a=a.type,d=!("button"===a||"input"===a||"select"===a||"textarea"===a));a=!d;break a;default:a=!1}if(a)return null;if(c&&"function"!==\ntypeof c)throw Error(y(231,b,typeof c));return c}var Pb=!1;if(fa)try{var Qb={};Object.defineProperty(Qb,"passive",{get:function(){Pb=!0}});window.addEventListener("test",Qb,Qb);window.removeEventListener("test",Qb,Qb)}catch(a){Pb=!1}function Rb(a,b,c,d,e,f,g,h,k){var l=Array.prototype.slice.call(arguments,3);try{b.apply(c,l)}catch(n){this.onError(n)}}var Sb=!1,Tb=null,Ub=!1,Vb=null,Wb={onError:function(a){Sb=!0;Tb=a}};function Xb(a,b,c,d,e,f,g,h,k){Sb=!1;Tb=null;Rb.apply(Wb,arguments)}\nfunction Yb(a,b,c,d,e,f,g,h,k){Xb.apply(this,arguments);if(Sb){if(Sb){var l=Tb;Sb=!1;Tb=null}else throw Error(y(198));Ub||(Ub=!0,Vb=l)}}function Zb(a){var b=a,c=a;if(a.alternate)for(;b.return;)b=b.return;else{a=b;do b=a,0!==(b.flags&1026)&&(c=b.return),a=b.return;while(a)}return 3===b.tag?c:null}function $b(a){if(13===a.tag){var b=a.memoizedState;null===b&&(a=a.alternate,null!==a&&(b=a.memoizedState));if(null!==b)return b.dehydrated}return null}function ac(a){if(Zb(a)!==a)throw Error(y(188));}\nfunction bc(a){var b=a.alternate;if(!b){b=Zb(a);if(null===b)throw Error(y(188));return b!==a?null:a}for(var c=a,d=b;;){var e=c.return;if(null===e)break;var f=e.alternate;if(null===f){d=e.return;if(null!==d){c=d;continue}break}if(e.child===f.child){for(f=e.child;f;){if(f===c)return ac(e),a;if(f===d)return ac(e),b;f=f.sibling}throw Error(y(188));}if(c.return!==d.return)c=e,d=f;else{for(var g=!1,h=e.child;h;){if(h===c){g=!0;c=e;d=f;break}if(h===d){g=!0;d=e;c=f;break}h=h.sibling}if(!g){for(h=f.child;h;){if(h===\nc){g=!0;c=f;d=e;break}if(h===d){g=!0;d=f;c=e;break}h=h.sibling}if(!g)throw Error(y(189));}}if(c.alternate!==d)throw Error(y(190));}if(3!==c.tag)throw Error(y(188));return c.stateNode.current===c?a:b}function cc(a){a=bc(a);if(!a)return null;for(var b=a;;){if(5===b.tag||6===b.tag)return b;if(b.child)b.child.return=b,b=b.child;else{if(b===a)break;for(;!b.sibling;){if(!b.return||b.return===a)return null;b=b.return}b.sibling.return=b.return;b=b.sibling}}return null}\nfunction dc(a,b){for(var c=a.alternate;null!==b;){if(b===a||b===c)return!0;b=b.return}return!1}var ec,fc,gc,hc,ic=!1,jc=[],kc=null,lc=null,mc=null,nc=new Map,oc=new Map,pc=[],qc="mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");\nfunction rc(a,b,c,d,e){return{blockedOn:a,domEventName:b,eventSystemFlags:c|16,nativeEvent:e,targetContainers:[d]}}function sc(a,b){switch(a){case "focusin":case "focusout":kc=null;break;case "dragenter":case "dragleave":lc=null;break;case "mouseover":case "mouseout":mc=null;break;case "pointerover":case "pointerout":nc.delete(b.pointerId);break;case "gotpointercapture":case "lostpointercapture":oc.delete(b.pointerId)}}\nfunction tc(a,b,c,d,e,f){if(null===a||a.nativeEvent!==f)return a=rc(b,c,d,e,f),null!==b&&(b=Cb(b),null!==b&&fc(b)),a;a.eventSystemFlags|=d;b=a.targetContainers;null!==e&&-1===b.indexOf(e)&&b.push(e);return a}\nfunction uc(a,b,c,d,e){switch(b){case "focusin":return kc=tc(kc,a,b,c,d,e),!0;case "dragenter":return lc=tc(lc,a,b,c,d,e),!0;case "mouseover":return mc=tc(mc,a,b,c,d,e),!0;case "pointerover":var f=e.pointerId;nc.set(f,tc(nc.get(f)||null,a,b,c,d,e));return!0;case "gotpointercapture":return f=e.pointerId,oc.set(f,tc(oc.get(f)||null,a,b,c,d,e)),!0}return!1}\nfunction vc(a){var b=wc(a.target);if(null!==b){var c=Zb(b);if(null!==c)if(b=c.tag,13===b){if(b=$b(c),null!==b){a.blockedOn=b;hc(a.lanePriority,function(){r.unstable_runWithPriority(a.priority,function(){gc(c)})});return}}else if(3===b&&c.stateNode.hydrate){a.blockedOn=3===c.tag?c.stateNode.containerInfo:null;return}}a.blockedOn=null}\nfunction xc(a){if(null!==a.blockedOn)return!1;for(var b=a.targetContainers;0<b.length;){var c=yc(a.domEventName,a.eventSystemFlags,b[0],a.nativeEvent);if(null!==c)return b=Cb(c),null!==b&&fc(b),a.blockedOn=c,!1;b.shift()}return!0}function zc(a,b,c){xc(a)&&c.delete(b)}\nfunction Ac(){for(ic=!1;0<jc.length;){var a=jc[0];if(null!==a.blockedOn){a=Cb(a.blockedOn);null!==a&&ec(a);break}for(var b=a.targetContainers;0<b.length;){var c=yc(a.domEventName,a.eventSystemFlags,b[0],a.nativeEvent);if(null!==c){a.blockedOn=c;break}b.shift()}null===a.blockedOn&&jc.shift()}null!==kc&&xc(kc)&&(kc=null);null!==lc&&xc(lc)&&(lc=null);null!==mc&&xc(mc)&&(mc=null);nc.forEach(zc);oc.forEach(zc)}\nfunction Bc(a,b){a.blockedOn===b&&(a.blockedOn=null,ic||(ic=!0,r.unstable_scheduleCallback(r.unstable_NormalPriority,Ac)))}\nfunction Cc(a){function b(b){return Bc(b,a)}if(0<jc.length){Bc(jc[0],a);for(var c=1;c<jc.length;c++){var d=jc[c];d.blockedOn===a&&(d.blockedOn=null)}}null!==kc&&Bc(kc,a);null!==lc&&Bc(lc,a);null!==mc&&Bc(mc,a);nc.forEach(b);oc.forEach(b);for(c=0;c<pc.length;c++)d=pc[c],d.blockedOn===a&&(d.blockedOn=null);for(;0<pc.length&&(c=pc[0],null===c.blockedOn);)vc(c),null===c.blockedOn&&pc.shift()}\nfunction Dc(a,b){var c={};c[a.toLowerCase()]=b.toLowerCase();c["Webkit"+a]="webkit"+b;c["Moz"+a]="moz"+b;return c}var Ec={animationend:Dc("Animation","AnimationEnd"),animationiteration:Dc("Animation","AnimationIteration"),animationstart:Dc("Animation","AnimationStart"),transitionend:Dc("Transition","TransitionEnd")},Fc={},Gc={};\nfa&&(Gc=document.createElement("div").style,"AnimationEvent"in window||(delete Ec.animationend.animation,delete Ec.animationiteration.animation,delete Ec.animationstart.animation),"TransitionEvent"in window||delete Ec.transitionend.transition);function Hc(a){if(Fc[a])return Fc[a];if(!Ec[a])return a;var b=Ec[a],c;for(c in b)if(b.hasOwnProperty(c)&&c in Gc)return Fc[a]=b[c];return a}\nvar Ic=Hc("animationend"),Jc=Hc("animationiteration"),Kc=Hc("animationstart"),Lc=Hc("transitionend"),Mc=new Map,Nc=new Map,Oc=["abort","abort",Ic,"animationEnd",Jc,"animationIteration",Kc,"animationStart","canplay","canPlay","canplaythrough","canPlayThrough","durationchange","durationChange","emptied","emptied","encrypted","encrypted","ended","ended","error","error","gotpointercapture","gotPointerCapture","load","load","loadeddata","loadedData","loadedmetadata","loadedMetadata","loadstart","loadStart",\n"lostpointercapture","lostPointerCapture","playing","playing","progress","progress","seeking","seeking","stalled","stalled","suspend","suspend","timeupdate","timeUpdate",Lc,"transitionEnd","waiting","waiting"];function Pc(a,b){for(var c=0;c<a.length;c+=2){var d=a[c],e=a[c+1];e="on"+(e[0].toUpperCase()+e.slice(1));Nc.set(d,b);Mc.set(d,e);da(e,[d])}}var Qc=r.unstable_now;Qc();var F=8;\nfunction Rc(a){if(0!==(1&a))return F=15,1;if(0!==(2&a))return F=14,2;if(0!==(4&a))return F=13,4;var b=24&a;if(0!==b)return F=12,b;if(0!==(a&32))return F=11,32;b=192&a;if(0!==b)return F=10,b;if(0!==(a&256))return F=9,256;b=3584&a;if(0!==b)return F=8,b;if(0!==(a&4096))return F=7,4096;b=4186112&a;if(0!==b)return F=6,b;b=62914560&a;if(0!==b)return F=5,b;if(a&67108864)return F=4,67108864;if(0!==(a&134217728))return F=3,134217728;b=805306368&a;if(0!==b)return F=2,b;if(0!==(1073741824&a))return F=1,1073741824;\nF=8;return a}function Sc(a){switch(a){case 99:return 15;case 98:return 10;case 97:case 96:return 8;case 95:return 2;default:return 0}}function Tc(a){switch(a){case 15:case 14:return 99;case 13:case 12:case 11:case 10:return 98;case 9:case 8:case 7:case 6:case 4:case 5:return 97;case 3:case 2:case 1:return 95;case 0:return 90;default:throw Error(y(358,a));}}\nfunction Uc(a,b){var c=a.pendingLanes;if(0===c)return F=0;var d=0,e=0,f=a.expiredLanes,g=a.suspendedLanes,h=a.pingedLanes;if(0!==f)d=f,e=F=15;else if(f=c&134217727,0!==f){var k=f&~g;0!==k?(d=Rc(k),e=F):(h&=f,0!==h&&(d=Rc(h),e=F))}else f=c&~g,0!==f?(d=Rc(f),e=F):0!==h&&(d=Rc(h),e=F);if(0===d)return 0;d=31-Vc(d);d=c&((0>d?0:1<<d)<<1)-1;if(0!==b&&b!==d&&0===(b&g)){Rc(b);if(e<=F)return b;F=e}b=a.entangledLanes;if(0!==b)for(a=a.entanglements,b&=d;0<b;)c=31-Vc(b),e=1<<c,d|=a[c],b&=~e;return d}\nfunction Wc(a){a=a.pendingLanes&-1073741825;return 0!==a?a:a&1073741824?1073741824:0}function Xc(a,b){switch(a){case 15:return 1;case 14:return 2;case 12:return a=Yc(24&~b),0===a?Xc(10,b):a;case 10:return a=Yc(192&~b),0===a?Xc(8,b):a;case 8:return a=Yc(3584&~b),0===a&&(a=Yc(4186112&~b),0===a&&(a=512)),a;case 2:return b=Yc(805306368&~b),0===b&&(b=268435456),b}throw Error(y(358,a));}function Yc(a){return a&-a}function Zc(a){for(var b=[],c=0;31>c;c++)b.push(a);return b}\nfunction $c(a,b,c){a.pendingLanes|=b;var d=b-1;a.suspendedLanes&=d;a.pingedLanes&=d;a=a.eventTimes;b=31-Vc(b);a[b]=c}var Vc=Math.clz32?Math.clz32:ad,bd=Math.log,cd=Math.LN2;function ad(a){return 0===a?32:31-(bd(a)/cd|0)|0}var dd=r.unstable_UserBlockingPriority,ed=r.unstable_runWithPriority,fd=!0;function gd(a,b,c,d){Kb||Ib();var e=hd,f=Kb;Kb=!0;try{Hb(e,a,b,c,d)}finally{(Kb=f)||Mb()}}function id(a,b,c,d){ed(dd,hd.bind(null,a,b,c,d))}\nfunction hd(a,b,c,d){if(fd){var e;if((e=0===(b&4))&&0<jc.length&&-1<qc.indexOf(a))a=rc(null,a,b,c,d),jc.push(a);else{var f=yc(a,b,c,d);if(null===f)e&&sc(a,d);else{if(e){if(-1<qc.indexOf(a)){a=rc(f,a,b,c,d);jc.push(a);return}if(uc(f,a,b,c,d))return;sc(a,d)}jd(a,b,d,null,c)}}}}\nfunction yc(a,b,c,d){var e=xb(d);e=wc(e);if(null!==e){var f=Zb(e);if(null===f)e=null;else{var g=f.tag;if(13===g){e=$b(f);if(null!==e)return e;e=null}else if(3===g){if(f.stateNode.hydrate)return 3===f.tag?f.stateNode.containerInfo:null;e=null}else f!==e&&(e=null)}}jd(a,b,d,e,c);return null}var kd=null,ld=null,md=null;\nfunction nd(){if(md)return md;var a,b=ld,c=b.length,d,e="value"in kd?kd.value:kd.textContent,f=e.length;for(a=0;a<c&&b[a]===e[a];a++);var g=c-a;for(d=1;d<=g&&b[c-d]===e[f-d];d++);return md=e.slice(a,1<d?1-d:void 0)}function od(a){var b=a.keyCode;"charCode"in a?(a=a.charCode,0===a&&13===b&&(a=13)):a=b;10===a&&(a=13);return 32<=a||13===a?a:0}function pd(){return!0}function qd(){return!1}\nfunction rd(a){function b(b,d,e,f,g){this._reactName=b;this._targetInst=e;this.type=d;this.nativeEvent=f;this.target=g;this.currentTarget=null;for(var c in a)a.hasOwnProperty(c)&&(b=a[c],this[c]=b?b(f):f[c]);this.isDefaultPrevented=(null!=f.defaultPrevented?f.defaultPrevented:!1===f.returnValue)?pd:qd;this.isPropagationStopped=qd;return this}m(b.prototype,{preventDefault:function(){this.defaultPrevented=!0;var a=this.nativeEvent;a&&(a.preventDefault?a.preventDefault():"unknown"!==typeof a.returnValue&&\n(a.returnValue=!1),this.isDefaultPrevented=pd)},stopPropagation:function(){var a=this.nativeEvent;a&&(a.stopPropagation?a.stopPropagation():"unknown"!==typeof a.cancelBubble&&(a.cancelBubble=!0),this.isPropagationStopped=pd)},persist:function(){},isPersistent:pd});return b}\nvar sd={eventPhase:0,bubbles:0,cancelable:0,timeStamp:function(a){return a.timeStamp||Date.now()},defaultPrevented:0,isTrusted:0},td=rd(sd),ud=m({},sd,{view:0,detail:0}),vd=rd(ud),wd,xd,yd,Ad=m({},ud,{screenX:0,screenY:0,clientX:0,clientY:0,pageX:0,pageY:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,getModifierState:zd,button:0,buttons:0,relatedTarget:function(a){return void 0===a.relatedTarget?a.fromElement===a.srcElement?a.toElement:a.fromElement:a.relatedTarget},movementX:function(a){if("movementX"in\na)return a.movementX;a!==yd&&(yd&&"mousemove"===a.type?(wd=a.screenX-yd.screenX,xd=a.screenY-yd.screenY):xd=wd=0,yd=a);return wd},movementY:function(a){return"movementY"in a?a.movementY:xd}}),Bd=rd(Ad),Cd=m({},Ad,{dataTransfer:0}),Dd=rd(Cd),Ed=m({},ud,{relatedTarget:0}),Fd=rd(Ed),Gd=m({},sd,{animationName:0,elapsedTime:0,pseudoElement:0}),Hd=rd(Gd),Id=m({},sd,{clipboardData:function(a){return"clipboardData"in a?a.clipboardData:window.clipboardData}}),Jd=rd(Id),Kd=m({},sd,{data:0}),Ld=rd(Kd),Md={Esc:"Escape",\nSpacebar:" ",Left:"ArrowLeft",Up:"ArrowUp",Right:"ArrowRight",Down:"ArrowDown",Del:"Delete",Win:"OS",Menu:"ContextMenu",Apps:"ContextMenu",Scroll:"ScrollLock",MozPrintableKey:"Unidentified"},Nd={8:"Backspace",9:"Tab",12:"Clear",13:"Enter",16:"Shift",17:"Control",18:"Alt",19:"Pause",20:"CapsLock",27:"Escape",32:" ",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"ArrowLeft",38:"ArrowUp",39:"ArrowRight",40:"ArrowDown",45:"Insert",46:"Delete",112:"F1",113:"F2",114:"F3",115:"F4",116:"F5",117:"F6",118:"F7",\n119:"F8",120:"F9",121:"F10",122:"F11",123:"F12",144:"NumLock",145:"ScrollLock",224:"Meta"},Od={Alt:"altKey",Control:"ctrlKey",Meta:"metaKey",Shift:"shiftKey"};function Pd(a){var b=this.nativeEvent;return b.getModifierState?b.getModifierState(a):(a=Od[a])?!!b[a]:!1}function zd(){return Pd}\nvar Qd=m({},ud,{key:function(a){if(a.key){var b=Md[a.key]||a.key;if("Unidentified"!==b)return b}return"keypress"===a.type?(a=od(a),13===a?"Enter":String.fromCharCode(a)):"keydown"===a.type||"keyup"===a.type?Nd[a.keyCode]||"Unidentified":""},code:0,location:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,repeat:0,locale:0,getModifierState:zd,charCode:function(a){return"keypress"===a.type?od(a):0},keyCode:function(a){return"keydown"===a.type||"keyup"===a.type?a.keyCode:0},which:function(a){return"keypress"===\na.type?od(a):"keydown"===a.type||"keyup"===a.type?a.keyCode:0}}),Rd=rd(Qd),Sd=m({},Ad,{pointerId:0,width:0,height:0,pressure:0,tangentialPressure:0,tiltX:0,tiltY:0,twist:0,pointerType:0,isPrimary:0}),Td=rd(Sd),Ud=m({},ud,{touches:0,targetTouches:0,changedTouches:0,altKey:0,metaKey:0,ctrlKey:0,shiftKey:0,getModifierState:zd}),Vd=rd(Ud),Wd=m({},sd,{propertyName:0,elapsedTime:0,pseudoElement:0}),Xd=rd(Wd),Yd=m({},Ad,{deltaX:function(a){return"deltaX"in a?a.deltaX:"wheelDeltaX"in a?-a.wheelDeltaX:0},\ndeltaY:function(a){return"deltaY"in a?a.deltaY:"wheelDeltaY"in a?-a.wheelDeltaY:"wheelDelta"in a?-a.wheelDelta:0},deltaZ:0,deltaMode:0}),Zd=rd(Yd),$d=[9,13,27,32],ae=fa&&"CompositionEvent"in window,be=null;fa&&"documentMode"in document&&(be=document.documentMode);var ce=fa&&"TextEvent"in window&&!be,de=fa&&(!ae||be&&8<be&&11>=be),ee=String.fromCharCode(32),fe=!1;\nfunction ge(a,b){switch(a){case "keyup":return-1!==$d.indexOf(b.keyCode);case "keydown":return 229!==b.keyCode;case "keypress":case "mousedown":case "focusout":return!0;default:return!1}}function he(a){a=a.detail;return"object"===typeof a&&"data"in a?a.data:null}var ie=!1;function je(a,b){switch(a){case "compositionend":return he(b);case "keypress":if(32!==b.which)return null;fe=!0;return ee;case "textInput":return a=b.data,a===ee&&fe?null:a;default:return null}}\nfunction ke(a,b){if(ie)return"compositionend"===a||!ae&&ge(a,b)?(a=nd(),md=ld=kd=null,ie=!1,a):null;switch(a){case "paste":return null;case "keypress":if(!(b.ctrlKey||b.altKey||b.metaKey)||b.ctrlKey&&b.altKey){if(b.char&&1<b.char.length)return b.char;if(b.which)return String.fromCharCode(b.which)}return null;case "compositionend":return de&&"ko"!==b.locale?null:b.data;default:return null}}\nvar le={color:!0,date:!0,datetime:!0,"datetime-local":!0,email:!0,month:!0,number:!0,password:!0,range:!0,search:!0,tel:!0,text:!0,time:!0,url:!0,week:!0};function me(a){var b=a&&a.nodeName&&a.nodeName.toLowerCase();return"input"===b?!!le[a.type]:"textarea"===b?!0:!1}function ne(a,b,c,d){Eb(d);b=oe(b,"onChange");0<b.length&&(c=new td("onChange","change",null,c,d),a.push({event:c,listeners:b}))}var pe=null,qe=null;function re(a){se(a,0)}function te(a){var b=ue(a);if(Wa(b))return a}\nfunction ve(a,b){if("change"===a)return b}var we=!1;if(fa){var xe;if(fa){var ye="oninput"in document;if(!ye){var ze=document.createElement("div");ze.setAttribute("oninput","return;");ye="function"===typeof ze.oninput}xe=ye}else xe=!1;we=xe&&(!document.documentMode||9<document.documentMode)}function Ae(){pe&&(pe.detachEvent("onpropertychange",Be),qe=pe=null)}function Be(a){if("value"===a.propertyName&&te(qe)){var b=[];ne(b,qe,a,xb(a));a=re;if(Kb)a(b);else{Kb=!0;try{Gb(a,b)}finally{Kb=!1,Mb()}}}}\nfunction Ce(a,b,c){"focusin"===a?(Ae(),pe=b,qe=c,pe.attachEvent("onpropertychange",Be)):"focusout"===a&&Ae()}function De(a){if("selectionchange"===a||"keyup"===a||"keydown"===a)return te(qe)}function Ee(a,b){if("click"===a)return te(b)}function Fe(a,b){if("input"===a||"change"===a)return te(b)}function Ge(a,b){return a===b&&(0!==a||1/a===1/b)||a!==a&&b!==b}var He="function"===typeof Object.is?Object.is:Ge,Ie=Object.prototype.hasOwnProperty;\nfunction Je(a,b){if(He(a,b))return!0;if("object"!==typeof a||null===a||"object"!==typeof b||null===b)return!1;var c=Object.keys(a),d=Object.keys(b);if(c.length!==d.length)return!1;for(d=0;d<c.length;d++)if(!Ie.call(b,c[d])||!He(a[c[d]],b[c[d]]))return!1;return!0}function Ke(a){for(;a&&a.firstChild;)a=a.firstChild;return a}\nfunction Le(a,b){var c=Ke(a);a=0;for(var d;c;){if(3===c.nodeType){d=a+c.textContent.length;if(a<=b&&d>=b)return{node:c,offset:b-a};a=d}a:{for(;c;){if(c.nextSibling){c=c.nextSibling;break a}c=c.parentNode}c=void 0}c=Ke(c)}}function Me(a,b){return a&&b?a===b?!0:a&&3===a.nodeType?!1:b&&3===b.nodeType?Me(a,b.parentNode):"contains"in a?a.contains(b):a.compareDocumentPosition?!!(a.compareDocumentPosition(b)&16):!1:!1}\nfunction Ne(){for(var a=window,b=Xa();b instanceof a.HTMLIFrameElement;){try{var c="string"===typeof b.contentWindow.location.href}catch(d){c=!1}if(c)a=b.contentWindow;else break;b=Xa(a.document)}return b}function Oe(a){var b=a&&a.nodeName&&a.nodeName.toLowerCase();return b&&("input"===b&&("text"===a.type||"search"===a.type||"tel"===a.type||"url"===a.type||"password"===a.type)||"textarea"===b||"true"===a.contentEditable)}\nvar Pe=fa&&"documentMode"in document&&11>=document.documentMode,Qe=null,Re=null,Se=null,Te=!1;\nfunction Ue(a,b,c){var d=c.window===c?c.document:9===c.nodeType?c:c.ownerDocument;Te||null==Qe||Qe!==Xa(d)||(d=Qe,"selectionStart"in d&&Oe(d)?d={start:d.selectionStart,end:d.selectionEnd}:(d=(d.ownerDocument&&d.ownerDocument.defaultView||window).getSelection(),d={anchorNode:d.anchorNode,anchorOffset:d.anchorOffset,focusNode:d.focusNode,focusOffset:d.focusOffset}),Se&&Je(Se,d)||(Se=d,d=oe(Re,"onSelect"),0<d.length&&(b=new td("onSelect","select",null,b,c),a.push({event:b,listeners:d}),b.target=Qe)))}\nPc("cancel cancel click click close close contextmenu contextMenu copy copy cut cut auxclick auxClick dblclick doubleClick dragend dragEnd dragstart dragStart drop drop focusin focus focusout blur input input invalid invalid keydown keyDown keypress keyPress keyup keyUp mousedown mouseDown mouseup mouseUp paste paste pause pause play play pointercancel pointerCancel pointerdown pointerDown pointerup pointerUp ratechange rateChange reset reset seeked seeked submit submit touchcancel touchCancel touchend touchEnd touchstart touchStart volumechange volumeChange".split(" "),\n0);Pc("drag drag dragenter dragEnter dragexit dragExit dragleave dragLeave dragover dragOver mousemove mouseMove mouseout mouseOut mouseover mouseOver pointermove pointerMove pointerout pointerOut pointerover pointerOver scroll scroll toggle toggle touchmove touchMove wheel wheel".split(" "),1);Pc(Oc,2);for(var Ve="change selectionchange textInput compositionstart compositionend compositionupdate".split(" "),We=0;We<Ve.length;We++)Nc.set(Ve[We],0);ea("onMouseEnter",["mouseout","mouseover"]);\nea("onMouseLeave",["mouseout","mouseover"]);ea("onPointerEnter",["pointerout","pointerover"]);ea("onPointerLeave",["pointerout","pointerover"]);da("onChange","change click focusin focusout input keydown keyup selectionchange".split(" "));da("onSelect","focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" "));da("onBeforeInput",["compositionend","keypress","textInput","paste"]);da("onCompositionEnd","compositionend focusout keydown keypress keyup mousedown".split(" "));\nda("onCompositionStart","compositionstart focusout keydown keypress keyup mousedown".split(" "));da("onCompositionUpdate","compositionupdate focusout keydown keypress keyup mousedown".split(" "));var Xe="abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),Ye=new Set("cancel close invalid load scroll toggle".split(" ").concat(Xe));\nfunction Ze(a,b,c){var d=a.type||"unknown-event";a.currentTarget=c;Yb(d,b,void 0,a);a.currentTarget=null}\nfunction se(a,b){b=0!==(b&4);for(var c=0;c<a.length;c++){var d=a[c],e=d.event;d=d.listeners;a:{var f=void 0;if(b)for(var g=d.length-1;0<=g;g--){var h=d[g],k=h.instance,l=h.currentTarget;h=h.listener;if(k!==f&&e.isPropagationStopped())break a;Ze(e,h,l);f=k}else for(g=0;g<d.length;g++){h=d[g];k=h.instance;l=h.currentTarget;h=h.listener;if(k!==f&&e.isPropagationStopped())break a;Ze(e,h,l);f=k}}}if(Ub)throw a=Vb,Ub=!1,Vb=null,a;}\nfunction G(a,b){var c=$e(b),d=a+"__bubble";c.has(d)||(af(b,a,2,!1),c.add(d))}var bf="_reactListening"+Math.random().toString(36).slice(2);function cf(a){a[bf]||(a[bf]=!0,ba.forEach(function(b){Ye.has(b)||df(b,!1,a,null);df(b,!0,a,null)}))}\nfunction df(a,b,c,d){var e=4<arguments.length&&void 0!==arguments[4]?arguments[4]:0,f=c;"selectionchange"===a&&9!==c.nodeType&&(f=c.ownerDocument);if(null!==d&&!b&&Ye.has(a)){if("scroll"!==a)return;e|=2;f=d}var g=$e(f),h=a+"__"+(b?"capture":"bubble");g.has(h)||(b&&(e|=4),af(f,a,e,b),g.add(h))}\nfunction af(a,b,c,d){var e=Nc.get(b);switch(void 0===e?2:e){case 0:e=gd;break;case 1:e=id;break;default:e=hd}c=e.bind(null,b,c,a);e=void 0;!Pb||"touchstart"!==b&&"touchmove"!==b&&"wheel"!==b||(e=!0);d?void 0!==e?a.addEventListener(b,c,{capture:!0,passive:e}):a.addEventListener(b,c,!0):void 0!==e?a.addEventListener(b,c,{passive:e}):a.addEventListener(b,c,!1)}\nfunction jd(a,b,c,d,e){var f=d;if(0===(b&1)&&0===(b&2)&&null!==d)a:for(;;){if(null===d)return;var g=d.tag;if(3===g||4===g){var h=d.stateNode.containerInfo;if(h===e||8===h.nodeType&&h.parentNode===e)break;if(4===g)for(g=d.return;null!==g;){var k=g.tag;if(3===k||4===k)if(k=g.stateNode.containerInfo,k===e||8===k.nodeType&&k.parentNode===e)return;g=g.return}for(;null!==h;){g=wc(h);if(null===g)return;k=g.tag;if(5===k||6===k){d=f=g;continue a}h=h.parentNode}}d=d.return}Nb(function(){var d=f,e=xb(c),g=[];\na:{var h=Mc.get(a);if(void 0!==h){var k=td,x=a;switch(a){case "keypress":if(0===od(c))break a;case "keydown":case "keyup":k=Rd;break;case "focusin":x="focus";k=Fd;break;case "focusout":x="blur";k=Fd;break;case "beforeblur":case "afterblur":k=Fd;break;case "click":if(2===c.button)break a;case "auxclick":case "dblclick":case "mousedown":case "mousemove":case "mouseup":case "mouseout":case "mouseover":case "contextmenu":k=Bd;break;case "drag":case "dragend":case "dragenter":case "dragexit":case "dragleave":case "dragover":case "dragstart":case "drop":k=\nDd;break;case "touchcancel":case "touchend":case "touchmove":case "touchstart":k=Vd;break;case Ic:case Jc:case Kc:k=Hd;break;case Lc:k=Xd;break;case "scroll":k=vd;break;case "wheel":k=Zd;break;case "copy":case "cut":case "paste":k=Jd;break;case "gotpointercapture":case "lostpointercapture":case "pointercancel":case "pointerdown":case "pointermove":case "pointerout":case "pointerover":case "pointerup":k=Td}var w=0!==(b&4),z=!w&&"scroll"===a,u=w?null!==h?h+"Capture":null:h;w=[];for(var t=d,q;null!==\nt;){q=t;var v=q.stateNode;5===q.tag&&null!==v&&(q=v,null!==u&&(v=Ob(t,u),null!=v&&w.push(ef(t,v,q))));if(z)break;t=t.return}0<w.length&&(h=new k(h,x,null,c,e),g.push({event:h,listeners:w}))}}if(0===(b&7)){a:{h="mouseover"===a||"pointerover"===a;k="mouseout"===a||"pointerout"===a;if(h&&0===(b&16)&&(x=c.relatedTarget||c.fromElement)&&(wc(x)||x[ff]))break a;if(k||h){h=e.window===e?e:(h=e.ownerDocument)?h.defaultView||h.parentWindow:window;if(k){if(x=c.relatedTarget||c.toElement,k=d,x=x?wc(x):null,null!==\nx&&(z=Zb(x),x!==z||5!==x.tag&&6!==x.tag))x=null}else k=null,x=d;if(k!==x){w=Bd;v="onMouseLeave";u="onMouseEnter";t="mouse";if("pointerout"===a||"pointerover"===a)w=Td,v="onPointerLeave",u="onPointerEnter",t="pointer";z=null==k?h:ue(k);q=null==x?h:ue(x);h=new w(v,t+"leave",k,c,e);h.target=z;h.relatedTarget=q;v=null;wc(e)===d&&(w=new w(u,t+"enter",x,c,e),w.target=q,w.relatedTarget=z,v=w);z=v;if(k&&x)b:{w=k;u=x;t=0;for(q=w;q;q=gf(q))t++;q=0;for(v=u;v;v=gf(v))q++;for(;0<t-q;)w=gf(w),t--;for(;0<q-t;)u=\ngf(u),q--;for(;t--;){if(w===u||null!==u&&w===u.alternate)break b;w=gf(w);u=gf(u)}w=null}else w=null;null!==k&&hf(g,h,k,w,!1);null!==x&&null!==z&&hf(g,z,x,w,!0)}}}a:{h=d?ue(d):window;k=h.nodeName&&h.nodeName.toLowerCase();if("select"===k||"input"===k&&"file"===h.type)var J=ve;else if(me(h))if(we)J=Fe;else{J=De;var K=Ce}else(k=h.nodeName)&&"input"===k.toLowerCase()&&("checkbox"===h.type||"radio"===h.type)&&(J=Ee);if(J&&(J=J(a,d))){ne(g,J,c,e);break a}K&&K(a,h,d);"focusout"===a&&(K=h._wrapperState)&&\nK.controlled&&"number"===h.type&&bb(h,"number",h.value)}K=d?ue(d):window;switch(a){case "focusin":if(me(K)||"true"===K.contentEditable)Qe=K,Re=d,Se=null;break;case "focusout":Se=Re=Qe=null;break;case "mousedown":Te=!0;break;case "contextmenu":case "mouseup":case "dragend":Te=!1;Ue(g,c,e);break;case "selectionchange":if(Pe)break;case "keydown":case "keyup":Ue(g,c,e)}var Q;if(ae)b:{switch(a){case "compositionstart":var L="onCompositionStart";break b;case "compositionend":L="onCompositionEnd";break b;\ncase "compositionupdate":L="onCompositionUpdate";break b}L=void 0}else ie?ge(a,c)&&(L="onCompositionEnd"):"keydown"===a&&229===c.keyCode&&(L="onCompositionStart");L&&(de&&"ko"!==c.locale&&(ie||"onCompositionStart"!==L?"onCompositionEnd"===L&&ie&&(Q=nd()):(kd=e,ld="value"in kd?kd.value:kd.textContent,ie=!0)),K=oe(d,L),0<K.length&&(L=new Ld(L,a,null,c,e),g.push({event:L,listeners:K}),Q?L.data=Q:(Q=he(c),null!==Q&&(L.data=Q))));if(Q=ce?je(a,c):ke(a,c))d=oe(d,"onBeforeInput"),0<d.length&&(e=new Ld("onBeforeInput",\n"beforeinput",null,c,e),g.push({event:e,listeners:d}),e.data=Q)}se(g,b)})}function ef(a,b,c){return{instance:a,listener:b,currentTarget:c}}function oe(a,b){for(var c=b+"Capture",d=[];null!==a;){var e=a,f=e.stateNode;5===e.tag&&null!==f&&(e=f,f=Ob(a,c),null!=f&&d.unshift(ef(a,f,e)),f=Ob(a,b),null!=f&&d.push(ef(a,f,e)));a=a.return}return d}function gf(a){if(null===a)return null;do a=a.return;while(a&&5!==a.tag);return a?a:null}\nfunction hf(a,b,c,d,e){for(var f=b._reactName,g=[];null!==c&&c!==d;){var h=c,k=h.alternate,l=h.stateNode;if(null!==k&&k===d)break;5===h.tag&&null!==l&&(h=l,e?(k=Ob(c,f),null!=k&&g.unshift(ef(c,k,h))):e||(k=Ob(c,f),null!=k&&g.push(ef(c,k,h))));c=c.return}0!==g.length&&a.push({event:b,listeners:g})}function jf(){}var kf=null,lf=null;function mf(a,b){switch(a){case "button":case "input":case "select":case "textarea":return!!b.autoFocus}return!1}\nfunction nf(a,b){return"textarea"===a||"option"===a||"noscript"===a||"string"===typeof b.children||"number"===typeof b.children||"object"===typeof b.dangerouslySetInnerHTML&&null!==b.dangerouslySetInnerHTML&&null!=b.dangerouslySetInnerHTML.__html}var of="function"===typeof setTimeout?setTimeout:void 0,pf="function"===typeof clearTimeout?clearTimeout:void 0;function qf(a){1===a.nodeType?a.textContent="":9===a.nodeType&&(a=a.body,null!=a&&(a.textContent=""))}\nfunction rf(a){for(;null!=a;a=a.nextSibling){var b=a.nodeType;if(1===b||3===b)break}return a}function sf(a){a=a.previousSibling;for(var b=0;a;){if(8===a.nodeType){var c=a.data;if("$"===c||"$!"===c||"$?"===c){if(0===b)return a;b--}else"/$"===c&&b++}a=a.previousSibling}return null}var tf=0;function uf(a){return{$$typeof:Ga,toString:a,valueOf:a}}var vf=Math.random().toString(36).slice(2),wf="__reactFiber$"+vf,xf="__reactProps$"+vf,ff="__reactContainer$"+vf,yf="__reactEvents$"+vf;\nfunction wc(a){var b=a[wf];if(b)return b;for(var c=a.parentNode;c;){if(b=c[ff]||c[wf]){c=b.alternate;if(null!==b.child||null!==c&&null!==c.child)for(a=sf(a);null!==a;){if(c=a[wf])return c;a=sf(a)}return b}a=c;c=a.parentNode}return null}function Cb(a){a=a[wf]||a[ff];return!a||5!==a.tag&&6!==a.tag&&13!==a.tag&&3!==a.tag?null:a}function ue(a){if(5===a.tag||6===a.tag)return a.stateNode;throw Error(y(33));}function Db(a){return a[xf]||null}\nfunction $e(a){var b=a[yf];void 0===b&&(b=a[yf]=new Set);return b}var zf=[],Af=-1;function Bf(a){return{current:a}}function H(a){0>Af||(a.current=zf[Af],zf[Af]=null,Af--)}function I(a,b){Af++;zf[Af]=a.current;a.current=b}var Cf={},M=Bf(Cf),N=Bf(!1),Df=Cf;\nfunction Ef(a,b){var c=a.type.contextTypes;if(!c)return Cf;var d=a.stateNode;if(d&&d.__reactInternalMemoizedUnmaskedChildContext===b)return d.__reactInternalMemoizedMaskedChildContext;var e={},f;for(f in c)e[f]=b[f];d&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=b,a.__reactInternalMemoizedMaskedChildContext=e);return e}function Ff(a){a=a.childContextTypes;return null!==a&&void 0!==a}function Gf(){H(N);H(M)}function Hf(a,b,c){if(M.current!==Cf)throw Error(y(168));I(M,b);I(N,c)}\nfunction If(a,b,c){var d=a.stateNode;a=b.childContextTypes;if("function"!==typeof d.getChildContext)return c;d=d.getChildContext();for(var e in d)if(!(e in a))throw Error(y(108,Ra(b)||"Unknown",e));return m({},c,d)}function Jf(a){a=(a=a.stateNode)&&a.__reactInternalMemoizedMergedChildContext||Cf;Df=M.current;I(M,a);I(N,N.current);return!0}function Kf(a,b,c){var d=a.stateNode;if(!d)throw Error(y(169));c?(a=If(a,b,Df),d.__reactInternalMemoizedMergedChildContext=a,H(N),H(M),I(M,a)):H(N);I(N,c)}\nvar Lf=null,Mf=null,Nf=r.unstable_runWithPriority,Of=r.unstable_scheduleCallback,Pf=r.unstable_cancelCallback,Qf=r.unstable_shouldYield,Rf=r.unstable_requestPaint,Sf=r.unstable_now,Tf=r.unstable_getCurrentPriorityLevel,Uf=r.unstable_ImmediatePriority,Vf=r.unstable_UserBlockingPriority,Wf=r.unstable_NormalPriority,Xf=r.unstable_LowPriority,Yf=r.unstable_IdlePriority,Zf={},$f=void 0!==Rf?Rf:function(){},ag=null,bg=null,cg=!1,dg=Sf(),O=1E4>dg?Sf:function(){return Sf()-dg};\nfunction eg(){switch(Tf()){case Uf:return 99;case Vf:return 98;case Wf:return 97;case Xf:return 96;case Yf:return 95;default:throw Error(y(332));}}function fg(a){switch(a){case 99:return Uf;case 98:return Vf;case 97:return Wf;case 96:return Xf;case 95:return Yf;default:throw Error(y(332));}}function gg(a,b){a=fg(a);return Nf(a,b)}function hg(a,b,c){a=fg(a);return Of(a,b,c)}function ig(){if(null!==bg){var a=bg;bg=null;Pf(a)}jg()}\nfunction jg(){if(!cg&&null!==ag){cg=!0;var a=0;try{var b=ag;gg(99,function(){for(;a<b.length;a++){var c=b[a];do c=c(!0);while(null!==c)}});ag=null}catch(c){throw null!==ag&&(ag=ag.slice(a+1)),Of(Uf,ig),c;}finally{cg=!1}}}var kg=ra.ReactCurrentBatchConfig;function lg(a,b){if(a&&a.defaultProps){b=m({},b);a=a.defaultProps;for(var c in a)void 0===b[c]&&(b[c]=a[c]);return b}return b}var mg=Bf(null),ng=null,og=null,pg=null;function qg(){pg=og=ng=null}\nfunction rg(a){var b=mg.current;H(mg);a.type._context._currentValue=b}function sg(a,b){for(;null!==a;){var c=a.alternate;if((a.childLanes&b)===b)if(null===c||(c.childLanes&b)===b)break;else c.childLanes|=b;else a.childLanes|=b,null!==c&&(c.childLanes|=b);a=a.return}}function tg(a,b){ng=a;pg=og=null;a=a.dependencies;null!==a&&null!==a.firstContext&&(0!==(a.lanes&b)&&(ug=!0),a.firstContext=null)}\nfunction vg(a,b){if(pg!==a&&!1!==b&&0!==b){if("number"!==typeof b||1073741823===b)pg=a,b=1073741823;b={context:a,observedBits:b,next:null};if(null===og){if(null===ng)throw Error(y(308));og=b;ng.dependencies={lanes:0,firstContext:b,responders:null}}else og=og.next=b}return a._currentValue}var wg=!1;function xg(a){a.updateQueue={baseState:a.memoizedState,firstBaseUpdate:null,lastBaseUpdate:null,shared:{pending:null},effects:null}}\nfunction yg(a,b){a=a.updateQueue;b.updateQueue===a&&(b.updateQueue={baseState:a.baseState,firstBaseUpdate:a.firstBaseUpdate,lastBaseUpdate:a.lastBaseUpdate,shared:a.shared,effects:a.effects})}function zg(a,b){return{eventTime:a,lane:b,tag:0,payload:null,callback:null,next:null}}function Ag(a,b){a=a.updateQueue;if(null!==a){a=a.shared;var c=a.pending;null===c?b.next=b:(b.next=c.next,c.next=b);a.pending=b}}\nfunction Bg(a,b){var c=a.updateQueue,d=a.alternate;if(null!==d&&(d=d.updateQueue,c===d)){var e=null,f=null;c=c.firstBaseUpdate;if(null!==c){do{var g={eventTime:c.eventTime,lane:c.lane,tag:c.tag,payload:c.payload,callback:c.callback,next:null};null===f?e=f=g:f=f.next=g;c=c.next}while(null!==c);null===f?e=f=b:f=f.next=b}else e=f=b;c={baseState:d.baseState,firstBaseUpdate:e,lastBaseUpdate:f,shared:d.shared,effects:d.effects};a.updateQueue=c;return}a=c.lastBaseUpdate;null===a?c.firstBaseUpdate=b:a.next=\nb;c.lastBaseUpdate=b}\nfunction Cg(a,b,c,d){var e=a.updateQueue;wg=!1;var f=e.firstBaseUpdate,g=e.lastBaseUpdate,h=e.shared.pending;if(null!==h){e.shared.pending=null;var k=h,l=k.next;k.next=null;null===g?f=l:g.next=l;g=k;var n=a.alternate;if(null!==n){n=n.updateQueue;var A=n.lastBaseUpdate;A!==g&&(null===A?n.firstBaseUpdate=l:A.next=l,n.lastBaseUpdate=k)}}if(null!==f){A=e.baseState;g=0;n=l=k=null;do{h=f.lane;var p=f.eventTime;if((d&h)===h){null!==n&&(n=n.next={eventTime:p,lane:0,tag:f.tag,payload:f.payload,callback:f.callback,\nnext:null});a:{var C=a,x=f;h=b;p=c;switch(x.tag){case 1:C=x.payload;if("function"===typeof C){A=C.call(p,A,h);break a}A=C;break a;case 3:C.flags=C.flags&-4097|64;case 0:C=x.payload;h="function"===typeof C?C.call(p,A,h):C;if(null===h||void 0===h)break a;A=m({},A,h);break a;case 2:wg=!0}}null!==f.callback&&(a.flags|=32,h=e.effects,null===h?e.effects=[f]:h.push(f))}else p={eventTime:p,lane:h,tag:f.tag,payload:f.payload,callback:f.callback,next:null},null===n?(l=n=p,k=A):n=n.next=p,g|=h;f=f.next;if(null===\nf)if(h=e.shared.pending,null===h)break;else f=h.next,h.next=null,e.lastBaseUpdate=h,e.shared.pending=null}while(1);null===n&&(k=A);e.baseState=k;e.firstBaseUpdate=l;e.lastBaseUpdate=n;Dg|=g;a.lanes=g;a.memoizedState=A}}function Eg(a,b,c){a=b.effects;b.effects=null;if(null!==a)for(b=0;b<a.length;b++){var d=a[b],e=d.callback;if(null!==e){d.callback=null;d=c;if("function"!==typeof e)throw Error(y(191,e));e.call(d)}}}var Fg=(new aa.Component).refs;\nfunction Gg(a,b,c,d){b=a.memoizedState;c=c(d,b);c=null===c||void 0===c?b:m({},b,c);a.memoizedState=c;0===a.lanes&&(a.updateQueue.baseState=c)}\nvar Kg={isMounted:function(a){return(a=a._reactInternals)?Zb(a)===a:!1},enqueueSetState:function(a,b,c){a=a._reactInternals;var d=Hg(),e=Ig(a),f=zg(d,e);f.payload=b;void 0!==c&&null!==c&&(f.callback=c);Ag(a,f);Jg(a,e,d)},enqueueReplaceState:function(a,b,c){a=a._reactInternals;var d=Hg(),e=Ig(a),f=zg(d,e);f.tag=1;f.payload=b;void 0!==c&&null!==c&&(f.callback=c);Ag(a,f);Jg(a,e,d)},enqueueForceUpdate:function(a,b){a=a._reactInternals;var c=Hg(),d=Ig(a),e=zg(c,d);e.tag=2;void 0!==b&&null!==b&&(e.callback=\nb);Ag(a,e);Jg(a,d,c)}};function Lg(a,b,c,d,e,f,g){a=a.stateNode;return"function"===typeof a.shouldComponentUpdate?a.shouldComponentUpdate(d,f,g):b.prototype&&b.prototype.isPureReactComponent?!Je(c,d)||!Je(e,f):!0}\nfunction Mg(a,b,c){var d=!1,e=Cf;var f=b.contextType;"object"===typeof f&&null!==f?f=vg(f):(e=Ff(b)?Df:M.current,d=b.contextTypes,f=(d=null!==d&&void 0!==d)?Ef(a,e):Cf);b=new b(c,f);a.memoizedState=null!==b.state&&void 0!==b.state?b.state:null;b.updater=Kg;a.stateNode=b;b._reactInternals=a;d&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=e,a.__reactInternalMemoizedMaskedChildContext=f);return b}\nfunction Ng(a,b,c,d){a=b.state;"function"===typeof b.componentWillReceiveProps&&b.componentWillReceiveProps(c,d);"function"===typeof b.UNSAFE_componentWillReceiveProps&&b.UNSAFE_componentWillReceiveProps(c,d);b.state!==a&&Kg.enqueueReplaceState(b,b.state,null)}\nfunction Og(a,b,c,d){var e=a.stateNode;e.props=c;e.state=a.memoizedState;e.refs=Fg;xg(a);var f=b.contextType;"object"===typeof f&&null!==f?e.context=vg(f):(f=Ff(b)?Df:M.current,e.context=Ef(a,f));Cg(a,c,e,d);e.state=a.memoizedState;f=b.getDerivedStateFromProps;"function"===typeof f&&(Gg(a,b,f,c),e.state=a.memoizedState);"function"===typeof b.getDerivedStateFromProps||"function"===typeof e.getSnapshotBeforeUpdate||"function"!==typeof e.UNSAFE_componentWillMount&&"function"!==typeof e.componentWillMount||\n(b=e.state,"function"===typeof e.componentWillMount&&e.componentWillMount(),"function"===typeof e.UNSAFE_componentWillMount&&e.UNSAFE_componentWillMount(),b!==e.state&&Kg.enqueueReplaceState(e,e.state,null),Cg(a,c,e,d),e.state=a.memoizedState);"function"===typeof e.componentDidMount&&(a.flags|=4)}var Pg=Array.isArray;\nfunction Qg(a,b,c){a=c.ref;if(null!==a&&"function"!==typeof a&&"object"!==typeof a){if(c._owner){c=c._owner;if(c){if(1!==c.tag)throw Error(y(309));var d=c.stateNode}if(!d)throw Error(y(147,a));var e=""+a;if(null!==b&&null!==b.ref&&"function"===typeof b.ref&&b.ref._stringRef===e)return b.ref;b=function(a){var b=d.refs;b===Fg&&(b=d.refs={});null===a?delete b[e]:b[e]=a};b._stringRef=e;return b}if("string"!==typeof a)throw Error(y(284));if(!c._owner)throw Error(y(290,a));}return a}\nfunction Rg(a,b){if("textarea"!==a.type)throw Error(y(31,"[object Object]"===Object.prototype.toString.call(b)?"object with keys {"+Object.keys(b).join(", ")+"}":b));}\nfunction Sg(a){function b(b,c){if(a){var d=b.lastEffect;null!==d?(d.nextEffect=c,b.lastEffect=c):b.firstEffect=b.lastEffect=c;c.nextEffect=null;c.flags=8}}function c(c,d){if(!a)return null;for(;null!==d;)b(c,d),d=d.sibling;return null}function d(a,b){for(a=new Map;null!==b;)null!==b.key?a.set(b.key,b):a.set(b.index,b),b=b.sibling;return a}function e(a,b){a=Tg(a,b);a.index=0;a.sibling=null;return a}function f(b,c,d){b.index=d;if(!a)return c;d=b.alternate;if(null!==d)return d=d.index,d<c?(b.flags=2,\nc):d;b.flags=2;return c}function g(b){a&&null===b.alternate&&(b.flags=2);return b}function h(a,b,c,d){if(null===b||6!==b.tag)return b=Ug(c,a.mode,d),b.return=a,b;b=e(b,c);b.return=a;return b}function k(a,b,c,d){if(null!==b&&b.elementType===c.type)return d=e(b,c.props),d.ref=Qg(a,b,c),d.return=a,d;d=Vg(c.type,c.key,c.props,null,a.mode,d);d.ref=Qg(a,b,c);d.return=a;return d}function l(a,b,c,d){if(null===b||4!==b.tag||b.stateNode.containerInfo!==c.containerInfo||b.stateNode.implementation!==c.implementation)return b=\nWg(c,a.mode,d),b.return=a,b;b=e(b,c.children||[]);b.return=a;return b}function n(a,b,c,d,f){if(null===b||7!==b.tag)return b=Xg(c,a.mode,d,f),b.return=a,b;b=e(b,c);b.return=a;return b}function A(a,b,c){if("string"===typeof b||"number"===typeof b)return b=Ug(""+b,a.mode,c),b.return=a,b;if("object"===typeof b&&null!==b){switch(b.$$typeof){case sa:return c=Vg(b.type,b.key,b.props,null,a.mode,c),c.ref=Qg(a,null,b),c.return=a,c;case ta:return b=Wg(b,a.mode,c),b.return=a,b}if(Pg(b)||La(b))return b=Xg(b,\na.mode,c,null),b.return=a,b;Rg(a,b)}return null}function p(a,b,c,d){var e=null!==b?b.key:null;if("string"===typeof c||"number"===typeof c)return null!==e?null:h(a,b,""+c,d);if("object"===typeof c&&null!==c){switch(c.$$typeof){case sa:return c.key===e?c.type===ua?n(a,b,c.props.children,d,e):k(a,b,c,d):null;case ta:return c.key===e?l(a,b,c,d):null}if(Pg(c)||La(c))return null!==e?null:n(a,b,c,d,null);Rg(a,c)}return null}function C(a,b,c,d,e){if("string"===typeof d||"number"===typeof d)return a=a.get(c)||\nnull,h(b,a,""+d,e);if("object"===typeof d&&null!==d){switch(d.$$typeof){case sa:return a=a.get(null===d.key?c:d.key)||null,d.type===ua?n(b,a,d.props.children,e,d.key):k(b,a,d,e);case ta:return a=a.get(null===d.key?c:d.key)||null,l(b,a,d,e)}if(Pg(d)||La(d))return a=a.get(c)||null,n(b,a,d,e,null);Rg(b,d)}return null}function x(e,g,h,k){for(var l=null,t=null,u=g,z=g=0,q=null;null!==u&&z<h.length;z++){u.index>z?(q=u,u=null):q=u.sibling;var n=p(e,u,h[z],k);if(null===n){null===u&&(u=q);break}a&&u&&null===\nn.alternate&&b(e,u);g=f(n,g,z);null===t?l=n:t.sibling=n;t=n;u=q}if(z===h.length)return c(e,u),l;if(null===u){for(;z<h.length;z++)u=A(e,h[z],k),null!==u&&(g=f(u,g,z),null===t?l=u:t.sibling=u,t=u);return l}for(u=d(e,u);z<h.length;z++)q=C(u,e,z,h[z],k),null!==q&&(a&&null!==q.alternate&&u.delete(null===q.key?z:q.key),g=f(q,g,z),null===t?l=q:t.sibling=q,t=q);a&&u.forEach(function(a){return b(e,a)});return l}function w(e,g,h,k){var l=La(h);if("function"!==typeof l)throw Error(y(150));h=l.call(h);if(null==\nh)throw Error(y(151));for(var t=l=null,u=g,z=g=0,q=null,n=h.next();null!==u&&!n.done;z++,n=h.next()){u.index>z?(q=u,u=null):q=u.sibling;var w=p(e,u,n.value,k);if(null===w){null===u&&(u=q);break}a&&u&&null===w.alternate&&b(e,u);g=f(w,g,z);null===t?l=w:t.sibling=w;t=w;u=q}if(n.done)return c(e,u),l;if(null===u){for(;!n.done;z++,n=h.next())n=A(e,n.value,k),null!==n&&(g=f(n,g,z),null===t?l=n:t.sibling=n,t=n);return l}for(u=d(e,u);!n.done;z++,n=h.next())n=C(u,e,z,n.value,k),null!==n&&(a&&null!==n.alternate&&\nu.delete(null===n.key?z:n.key),g=f(n,g,z),null===t?l=n:t.sibling=n,t=n);a&&u.forEach(function(a){return b(e,a)});return l}return function(a,d,f,h){var k="object"===typeof f&&null!==f&&f.type===ua&&null===f.key;k&&(f=f.props.children);var l="object"===typeof f&&null!==f;if(l)switch(f.$$typeof){case sa:a:{l=f.key;for(k=d;null!==k;){if(k.key===l){switch(k.tag){case 7:if(f.type===ua){c(a,k.sibling);d=e(k,f.props.children);d.return=a;a=d;break a}break;default:if(k.elementType===f.type){c(a,k.sibling);\nd=e(k,f.props);d.ref=Qg(a,k,f);d.return=a;a=d;break a}}c(a,k);break}else b(a,k);k=k.sibling}f.type===ua?(d=Xg(f.props.children,a.mode,h,f.key),d.return=a,a=d):(h=Vg(f.type,f.key,f.props,null,a.mode,h),h.ref=Qg(a,d,f),h.return=a,a=h)}return g(a);case ta:a:{for(k=f.key;null!==d;){if(d.key===k)if(4===d.tag&&d.stateNode.containerInfo===f.containerInfo&&d.stateNode.implementation===f.implementation){c(a,d.sibling);d=e(d,f.children||[]);d.return=a;a=d;break a}else{c(a,d);break}else b(a,d);d=d.sibling}d=\nWg(f,a.mode,h);d.return=a;a=d}return g(a)}if("string"===typeof f||"number"===typeof f)return f=""+f,null!==d&&6===d.tag?(c(a,d.sibling),d=e(d,f),d.return=a,a=d):(c(a,d),d=Ug(f,a.mode,h),d.return=a,a=d),g(a);if(Pg(f))return x(a,d,f,h);if(La(f))return w(a,d,f,h);l&&Rg(a,f);if("undefined"===typeof f&&!k)switch(a.tag){case 1:case 22:case 0:case 11:case 15:throw Error(y(152,Ra(a.type)||"Component"));}return c(a,d)}}var Yg=Sg(!0),Zg=Sg(!1),$g={},ah=Bf($g),bh=Bf($g),ch=Bf($g);\nfunction dh(a){if(a===$g)throw Error(y(174));return a}function eh(a,b){I(ch,b);I(bh,a);I(ah,$g);a=b.nodeType;switch(a){case 9:case 11:b=(b=b.documentElement)?b.namespaceURI:mb(null,"");break;default:a=8===a?b.parentNode:b,b=a.namespaceURI||null,a=a.tagName,b=mb(b,a)}H(ah);I(ah,b)}function fh(){H(ah);H(bh);H(ch)}function gh(a){dh(ch.current);var b=dh(ah.current);var c=mb(b,a.type);b!==c&&(I(bh,a),I(ah,c))}function hh(a){bh.current===a&&(H(ah),H(bh))}var P=Bf(0);\nfunction ih(a){for(var b=a;null!==b;){if(13===b.tag){var c=b.memoizedState;if(null!==c&&(c=c.dehydrated,null===c||"$?"===c.data||"$!"===c.data))return b}else if(19===b.tag&&void 0!==b.memoizedProps.revealOrder){if(0!==(b.flags&64))return b}else if(null!==b.child){b.child.return=b;b=b.child;continue}if(b===a)break;for(;null===b.sibling;){if(null===b.return||b.return===a)return null;b=b.return}b.sibling.return=b.return;b=b.sibling}return null}var jh=null,kh=null,lh=!1;\nfunction mh(a,b){var c=nh(5,null,null,0);c.elementType="DELETED";c.type="DELETED";c.stateNode=b;c.return=a;c.flags=8;null!==a.lastEffect?(a.lastEffect.nextEffect=c,a.lastEffect=c):a.firstEffect=a.lastEffect=c}function oh(a,b){switch(a.tag){case 5:var c=a.type;b=1!==b.nodeType||c.toLowerCase()!==b.nodeName.toLowerCase()?null:b;return null!==b?(a.stateNode=b,!0):!1;case 6:return b=""===a.pendingProps||3!==b.nodeType?null:b,null!==b?(a.stateNode=b,!0):!1;case 13:return!1;default:return!1}}\nfunction ph(a){if(lh){var b=kh;if(b){var c=b;if(!oh(a,b)){b=rf(c.nextSibling);if(!b||!oh(a,b)){a.flags=a.flags&-1025|2;lh=!1;jh=a;return}mh(jh,c)}jh=a;kh=rf(b.firstChild)}else a.flags=a.flags&-1025|2,lh=!1,jh=a}}function qh(a){for(a=a.return;null!==a&&5!==a.tag&&3!==a.tag&&13!==a.tag;)a=a.return;jh=a}\nfunction rh(a){if(a!==jh)return!1;if(!lh)return qh(a),lh=!0,!1;var b=a.type;if(5!==a.tag||"head"!==b&&"body"!==b&&!nf(b,a.memoizedProps))for(b=kh;b;)mh(a,b),b=rf(b.nextSibling);qh(a);if(13===a.tag){a=a.memoizedState;a=null!==a?a.dehydrated:null;if(!a)throw Error(y(317));a:{a=a.nextSibling;for(b=0;a;){if(8===a.nodeType){var c=a.data;if("/$"===c){if(0===b){kh=rf(a.nextSibling);break a}b--}else"$"!==c&&"$!"!==c&&"$?"!==c||b++}a=a.nextSibling}kh=null}}else kh=jh?rf(a.stateNode.nextSibling):null;return!0}\nfunction sh(){kh=jh=null;lh=!1}var th=[];function uh(){for(var a=0;a<th.length;a++)th[a]._workInProgressVersionPrimary=null;th.length=0}var vh=ra.ReactCurrentDispatcher,wh=ra.ReactCurrentBatchConfig,xh=0,R=null,S=null,T=null,yh=!1,zh=!1;function Ah(){throw Error(y(321));}function Bh(a,b){if(null===b)return!1;for(var c=0;c<b.length&&c<a.length;c++)if(!He(a[c],b[c]))return!1;return!0}\nfunction Ch(a,b,c,d,e,f){xh=f;R=b;b.memoizedState=null;b.updateQueue=null;b.lanes=0;vh.current=null===a||null===a.memoizedState?Dh:Eh;a=c(d,e);if(zh){f=0;do{zh=!1;if(!(25>f))throw Error(y(301));f+=1;T=S=null;b.updateQueue=null;vh.current=Fh;a=c(d,e)}while(zh)}vh.current=Gh;b=null!==S&&null!==S.next;xh=0;T=S=R=null;yh=!1;if(b)throw Error(y(300));return a}function Hh(){var a={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};null===T?R.memoizedState=T=a:T=T.next=a;return T}\nfunction Ih(){if(null===S){var a=R.alternate;a=null!==a?a.memoizedState:null}else a=S.next;var b=null===T?R.memoizedState:T.next;if(null!==b)T=b,S=a;else{if(null===a)throw Error(y(310));S=a;a={memoizedState:S.memoizedState,baseState:S.baseState,baseQueue:S.baseQueue,queue:S.queue,next:null};null===T?R.memoizedState=T=a:T=T.next=a}return T}function Jh(a,b){return"function"===typeof b?b(a):b}\nfunction Kh(a){var b=Ih(),c=b.queue;if(null===c)throw Error(y(311));c.lastRenderedReducer=a;var d=S,e=d.baseQueue,f=c.pending;if(null!==f){if(null!==e){var g=e.next;e.next=f.next;f.next=g}d.baseQueue=e=f;c.pending=null}if(null!==e){e=e.next;d=d.baseState;var h=g=f=null,k=e;do{var l=k.lane;if((xh&l)===l)null!==h&&(h=h.next={lane:0,action:k.action,eagerReducer:k.eagerReducer,eagerState:k.eagerState,next:null}),d=k.eagerReducer===a?k.eagerState:a(d,k.action);else{var n={lane:l,action:k.action,eagerReducer:k.eagerReducer,\neagerState:k.eagerState,next:null};null===h?(g=h=n,f=d):h=h.next=n;R.lanes|=l;Dg|=l}k=k.next}while(null!==k&&k!==e);null===h?f=d:h.next=g;He(d,b.memoizedState)||(ug=!0);b.memoizedState=d;b.baseState=f;b.baseQueue=h;c.lastRenderedState=d}return[b.memoizedState,c.dispatch]}\nfunction Lh(a){var b=Ih(),c=b.queue;if(null===c)throw Error(y(311));c.lastRenderedReducer=a;var d=c.dispatch,e=c.pending,f=b.memoizedState;if(null!==e){c.pending=null;var g=e=e.next;do f=a(f,g.action),g=g.next;while(g!==e);He(f,b.memoizedState)||(ug=!0);b.memoizedState=f;null===b.baseQueue&&(b.baseState=f);c.lastRenderedState=f}return[f,d]}\nfunction Mh(a,b,c){var d=b._getVersion;d=d(b._source);var e=b._workInProgressVersionPrimary;if(null!==e)a=e===d;else if(a=a.mutableReadLanes,a=(xh&a)===a)b._workInProgressVersionPrimary=d,th.push(b);if(a)return c(b._source);th.push(b);throw Error(y(350));}\nfunction Nh(a,b,c,d){var e=U;if(null===e)throw Error(y(349));var f=b._getVersion,g=f(b._source),h=vh.current,k=h.useState(function(){return Mh(e,b,c)}),l=k[1],n=k[0];k=T;var A=a.memoizedState,p=A.refs,C=p.getSnapshot,x=A.source;A=A.subscribe;var w=R;a.memoizedState={refs:p,source:b,subscribe:d};h.useEffect(function(){p.getSnapshot=c;p.setSnapshot=l;var a=f(b._source);if(!He(g,a)){a=c(b._source);He(n,a)||(l(a),a=Ig(w),e.mutableReadLanes|=a&e.pendingLanes);a=e.mutableReadLanes;e.entangledLanes|=a;for(var d=\ne.entanglements,h=a;0<h;){var k=31-Vc(h),v=1<<k;d[k]|=a;h&=~v}}},[c,b,d]);h.useEffect(function(){return d(b._source,function(){var a=p.getSnapshot,c=p.setSnapshot;try{c(a(b._source));var d=Ig(w);e.mutableReadLanes|=d&e.pendingLanes}catch(q){c(function(){throw q;})}})},[b,d]);He(C,c)&&He(x,b)&&He(A,d)||(a={pending:null,dispatch:null,lastRenderedReducer:Jh,lastRenderedState:n},a.dispatch=l=Oh.bind(null,R,a),k.queue=a,k.baseQueue=null,n=Mh(e,b,c),k.memoizedState=k.baseState=n);return n}\nfunction Ph(a,b,c){var d=Ih();return Nh(d,a,b,c)}function Qh(a){var b=Hh();"function"===typeof a&&(a=a());b.memoizedState=b.baseState=a;a=b.queue={pending:null,dispatch:null,lastRenderedReducer:Jh,lastRenderedState:a};a=a.dispatch=Oh.bind(null,R,a);return[b.memoizedState,a]}\nfunction Rh(a,b,c,d){a={tag:a,create:b,destroy:c,deps:d,next:null};b=R.updateQueue;null===b?(b={lastEffect:null},R.updateQueue=b,b.lastEffect=a.next=a):(c=b.lastEffect,null===c?b.lastEffect=a.next=a:(d=c.next,c.next=a,a.next=d,b.lastEffect=a));return a}function Sh(a){var b=Hh();a={current:a};return b.memoizedState=a}function Th(){return Ih().memoizedState}function Uh(a,b,c,d){var e=Hh();R.flags|=a;e.memoizedState=Rh(1|b,c,void 0,void 0===d?null:d)}\nfunction Vh(a,b,c,d){var e=Ih();d=void 0===d?null:d;var f=void 0;if(null!==S){var g=S.memoizedState;f=g.destroy;if(null!==d&&Bh(d,g.deps)){Rh(b,c,f,d);return}}R.flags|=a;e.memoizedState=Rh(1|b,c,f,d)}function Wh(a,b){return Uh(516,4,a,b)}function Xh(a,b){return Vh(516,4,a,b)}function Yh(a,b){return Vh(4,2,a,b)}function Zh(a,b){if("function"===typeof b)return a=a(),b(a),function(){b(null)};if(null!==b&&void 0!==b)return a=a(),b.current=a,function(){b.current=null}}\nfunction $h(a,b,c){c=null!==c&&void 0!==c?c.concat([a]):null;return Vh(4,2,Zh.bind(null,b,a),c)}function ai(){}function bi(a,b){var c=Ih();b=void 0===b?null:b;var d=c.memoizedState;if(null!==d&&null!==b&&Bh(b,d[1]))return d[0];c.memoizedState=[a,b];return a}function ci(a,b){var c=Ih();b=void 0===b?null:b;var d=c.memoizedState;if(null!==d&&null!==b&&Bh(b,d[1]))return d[0];a=a();c.memoizedState=[a,b];return a}\nfunction di(a,b){var c=eg();gg(98>c?98:c,function(){a(!0)});gg(97<c?97:c,function(){var c=wh.transition;wh.transition=1;try{a(!1),b()}finally{wh.transition=c}})}\nfunction Oh(a,b,c){var d=Hg(),e=Ig(a),f={lane:e,action:c,eagerReducer:null,eagerState:null,next:null},g=b.pending;null===g?f.next=f:(f.next=g.next,g.next=f);b.pending=f;g=a.alternate;if(a===R||null!==g&&g===R)zh=yh=!0;else{if(0===a.lanes&&(null===g||0===g.lanes)&&(g=b.lastRenderedReducer,null!==g))try{var h=b.lastRenderedState,k=g(h,c);f.eagerReducer=g;f.eagerState=k;if(He(k,h))return}catch(l){}finally{}Jg(a,e,d)}}\nvar Gh={readContext:vg,useCallback:Ah,useContext:Ah,useEffect:Ah,useImperativeHandle:Ah,useLayoutEffect:Ah,useMemo:Ah,useReducer:Ah,useRef:Ah,useState:Ah,useDebugValue:Ah,useDeferredValue:Ah,useTransition:Ah,useMutableSource:Ah,useOpaqueIdentifier:Ah,unstable_isNewReconciler:!1},Dh={readContext:vg,useCallback:function(a,b){Hh().memoizedState=[a,void 0===b?null:b];return a},useContext:vg,useEffect:Wh,useImperativeHandle:function(a,b,c){c=null!==c&&void 0!==c?c.concat([a]):null;return Uh(4,2,Zh.bind(null,\nb,a),c)},useLayoutEffect:function(a,b){return Uh(4,2,a,b)},useMemo:function(a,b){var c=Hh();b=void 0===b?null:b;a=a();c.memoizedState=[a,b];return a},useReducer:function(a,b,c){var d=Hh();b=void 0!==c?c(b):b;d.memoizedState=d.baseState=b;a=d.queue={pending:null,dispatch:null,lastRenderedReducer:a,lastRenderedState:b};a=a.dispatch=Oh.bind(null,R,a);return[d.memoizedState,a]},useRef:Sh,useState:Qh,useDebugValue:ai,useDeferredValue:function(a){var b=Qh(a),c=b[0],d=b[1];Wh(function(){var b=wh.transition;\nwh.transition=1;try{d(a)}finally{wh.transition=b}},[a]);return c},useTransition:function(){var a=Qh(!1),b=a[0];a=di.bind(null,a[1]);Sh(a);return[a,b]},useMutableSource:function(a,b,c){var d=Hh();d.memoizedState={refs:{getSnapshot:b,setSnapshot:null},source:a,subscribe:c};return Nh(d,a,b,c)},useOpaqueIdentifier:function(){if(lh){var a=!1,b=uf(function(){a||(a=!0,c("r:"+(tf++).toString(36)));throw Error(y(355));}),c=Qh(b)[1];0===(R.mode&2)&&(R.flags|=516,Rh(5,function(){c("r:"+(tf++).toString(36))},\nvoid 0,null));return b}b="r:"+(tf++).toString(36);Qh(b);return b},unstable_isNewReconciler:!1},Eh={readContext:vg,useCallback:bi,useContext:vg,useEffect:Xh,useImperativeHandle:$h,useLayoutEffect:Yh,useMemo:ci,useReducer:Kh,useRef:Th,useState:function(){return Kh(Jh)},useDebugValue:ai,useDeferredValue:function(a){var b=Kh(Jh),c=b[0],d=b[1];Xh(function(){var b=wh.transition;wh.transition=1;try{d(a)}finally{wh.transition=b}},[a]);return c},useTransition:function(){var a=Kh(Jh)[0];return[Th().current,\na]},useMutableSource:Ph,useOpaqueIdentifier:function(){return Kh(Jh)[0]},unstable_isNewReconciler:!1},Fh={readContext:vg,useCallback:bi,useContext:vg,useEffect:Xh,useImperativeHandle:$h,useLayoutEffect:Yh,useMemo:ci,useReducer:Lh,useRef:Th,useState:function(){return Lh(Jh)},useDebugValue:ai,useDeferredValue:function(a){var b=Lh(Jh),c=b[0],d=b[1];Xh(function(){var b=wh.transition;wh.transition=1;try{d(a)}finally{wh.transition=b}},[a]);return c},useTransition:function(){var a=Lh(Jh)[0];return[Th().current,\na]},useMutableSource:Ph,useOpaqueIdentifier:function(){return Lh(Jh)[0]},unstable_isNewReconciler:!1},ei=ra.ReactCurrentOwner,ug=!1;function fi(a,b,c,d){b.child=null===a?Zg(b,null,c,d):Yg(b,a.child,c,d)}function gi(a,b,c,d,e){c=c.render;var f=b.ref;tg(b,e);d=Ch(a,b,c,d,f,e);if(null!==a&&!ug)return b.updateQueue=a.updateQueue,b.flags&=-517,a.lanes&=~e,hi(a,b,e);b.flags|=1;fi(a,b,d,e);return b.child}\nfunction ii(a,b,c,d,e,f){if(null===a){var g=c.type;if("function"===typeof g&&!ji(g)&&void 0===g.defaultProps&&null===c.compare&&void 0===c.defaultProps)return b.tag=15,b.type=g,ki(a,b,g,d,e,f);a=Vg(c.type,null,d,b,b.mode,f);a.ref=b.ref;a.return=b;return b.child=a}g=a.child;if(0===(e&f)&&(e=g.memoizedProps,c=c.compare,c=null!==c?c:Je,c(e,d)&&a.ref===b.ref))return hi(a,b,f);b.flags|=1;a=Tg(g,d);a.ref=b.ref;a.return=b;return b.child=a}\nfunction ki(a,b,c,d,e,f){if(null!==a&&Je(a.memoizedProps,d)&&a.ref===b.ref)if(ug=!1,0!==(f&e))0!==(a.flags&16384)&&(ug=!0);else return b.lanes=a.lanes,hi(a,b,f);return li(a,b,c,d,f)}\nfunction mi(a,b,c){var d=b.pendingProps,e=d.children,f=null!==a?a.memoizedState:null;if("hidden"===d.mode||"unstable-defer-without-hiding"===d.mode)if(0===(b.mode&4))b.memoizedState={baseLanes:0},ni(b,c);else if(0!==(c&1073741824))b.memoizedState={baseLanes:0},ni(b,null!==f?f.baseLanes:c);else return a=null!==f?f.baseLanes|c:c,b.lanes=b.childLanes=1073741824,b.memoizedState={baseLanes:a},ni(b,a),null;else null!==f?(d=f.baseLanes|c,b.memoizedState=null):d=c,ni(b,d);fi(a,b,e,c);return b.child}\nfunction oi(a,b){var c=b.ref;if(null===a&&null!==c||null!==a&&a.ref!==c)b.flags|=128}function li(a,b,c,d,e){var f=Ff(c)?Df:M.current;f=Ef(b,f);tg(b,e);c=Ch(a,b,c,d,f,e);if(null!==a&&!ug)return b.updateQueue=a.updateQueue,b.flags&=-517,a.lanes&=~e,hi(a,b,e);b.flags|=1;fi(a,b,c,e);return b.child}\nfunction pi(a,b,c,d,e){if(Ff(c)){var f=!0;Jf(b)}else f=!1;tg(b,e);if(null===b.stateNode)null!==a&&(a.alternate=null,b.alternate=null,b.flags|=2),Mg(b,c,d),Og(b,c,d,e),d=!0;else if(null===a){var g=b.stateNode,h=b.memoizedProps;g.props=h;var k=g.context,l=c.contextType;"object"===typeof l&&null!==l?l=vg(l):(l=Ff(c)?Df:M.current,l=Ef(b,l));var n=c.getDerivedStateFromProps,A="function"===typeof n||"function"===typeof g.getSnapshotBeforeUpdate;A||"function"!==typeof g.UNSAFE_componentWillReceiveProps&&\n"function"!==typeof g.componentWillReceiveProps||(h!==d||k!==l)&&Ng(b,g,d,l);wg=!1;var p=b.memoizedState;g.state=p;Cg(b,d,g,e);k=b.memoizedState;h!==d||p!==k||N.current||wg?("function"===typeof n&&(Gg(b,c,n,d),k=b.memoizedState),(h=wg||Lg(b,c,h,d,p,k,l))?(A||"function"!==typeof g.UNSAFE_componentWillMount&&"function"!==typeof g.componentWillMount||("function"===typeof g.componentWillMount&&g.componentWillMount(),"function"===typeof g.UNSAFE_componentWillMount&&g.UNSAFE_componentWillMount()),"function"===\ntypeof g.componentDidMount&&(b.flags|=4)):("function"===typeof g.componentDidMount&&(b.flags|=4),b.memoizedProps=d,b.memoizedState=k),g.props=d,g.state=k,g.context=l,d=h):("function"===typeof g.componentDidMount&&(b.flags|=4),d=!1)}else{g=b.stateNode;yg(a,b);h=b.memoizedProps;l=b.type===b.elementType?h:lg(b.type,h);g.props=l;A=b.pendingProps;p=g.context;k=c.contextType;"object"===typeof k&&null!==k?k=vg(k):(k=Ff(c)?Df:M.current,k=Ef(b,k));var C=c.getDerivedStateFromProps;(n="function"===typeof C||\n"function"===typeof g.getSnapshotBeforeUpdate)||"function"!==typeof g.UNSAFE_componentWillReceiveProps&&"function"!==typeof g.componentWillReceiveProps||(h!==A||p!==k)&&Ng(b,g,d,k);wg=!1;p=b.memoizedState;g.state=p;Cg(b,d,g,e);var x=b.memoizedState;h!==A||p!==x||N.current||wg?("function"===typeof C&&(Gg(b,c,C,d),x=b.memoizedState),(l=wg||Lg(b,c,l,d,p,x,k))?(n||"function"!==typeof g.UNSAFE_componentWillUpdate&&"function"!==typeof g.componentWillUpdate||("function"===typeof g.componentWillUpdate&&g.componentWillUpdate(d,\nx,k),"function"===typeof g.UNSAFE_componentWillUpdate&&g.UNSAFE_componentWillUpdate(d,x,k)),"function"===typeof g.componentDidUpdate&&(b.flags|=4),"function"===typeof g.getSnapshotBeforeUpdate&&(b.flags|=256)):("function"!==typeof g.componentDidUpdate||h===a.memoizedProps&&p===a.memoizedState||(b.flags|=4),"function"!==typeof g.getSnapshotBeforeUpdate||h===a.memoizedProps&&p===a.memoizedState||(b.flags|=256),b.memoizedProps=d,b.memoizedState=x),g.props=d,g.state=x,g.context=k,d=l):("function"!==typeof g.componentDidUpdate||\nh===a.memoizedProps&&p===a.memoizedState||(b.flags|=4),"function"!==typeof g.getSnapshotBeforeUpdate||h===a.memoizedProps&&p===a.memoizedState||(b.flags|=256),d=!1)}return qi(a,b,c,d,f,e)}\nfunction qi(a,b,c,d,e,f){oi(a,b);var g=0!==(b.flags&64);if(!d&&!g)return e&&Kf(b,c,!1),hi(a,b,f);d=b.stateNode;ei.current=b;var h=g&&"function"!==typeof c.getDerivedStateFromError?null:d.render();b.flags|=1;null!==a&&g?(b.child=Yg(b,a.child,null,f),b.child=Yg(b,null,h,f)):fi(a,b,h,f);b.memoizedState=d.state;e&&Kf(b,c,!0);return b.child}function ri(a){var b=a.stateNode;b.pendingContext?Hf(a,b.pendingContext,b.pendingContext!==b.context):b.context&&Hf(a,b.context,!1);eh(a,b.containerInfo)}\nvar si={dehydrated:null,retryLane:0};\nfunction ti(a,b,c){var d=b.pendingProps,e=P.current,f=!1,g;(g=0!==(b.flags&64))||(g=null!==a&&null===a.memoizedState?!1:0!==(e&2));g?(f=!0,b.flags&=-65):null!==a&&null===a.memoizedState||void 0===d.fallback||!0===d.unstable_avoidThisFallback||(e|=1);I(P,e&1);if(null===a){void 0!==d.fallback&&ph(b);a=d.children;e=d.fallback;if(f)return a=ui(b,a,e,c),b.child.memoizedState={baseLanes:c},b.memoizedState=si,a;if("number"===typeof d.unstable_expectedLoadTime)return a=ui(b,a,e,c),b.child.memoizedState={baseLanes:c},\nb.memoizedState=si,b.lanes=33554432,a;c=vi({mode:"visible",children:a},b.mode,c,null);c.return=b;return b.child=c}if(null!==a.memoizedState){if(f)return d=wi(a,b,d.children,d.fallback,c),f=b.child,e=a.child.memoizedState,f.memoizedState=null===e?{baseLanes:c}:{baseLanes:e.baseLanes|c},f.childLanes=a.childLanes&~c,b.memoizedState=si,d;c=xi(a,b,d.children,c);b.memoizedState=null;return c}if(f)return d=wi(a,b,d.children,d.fallback,c),f=b.child,e=a.child.memoizedState,f.memoizedState=null===e?{baseLanes:c}:\n{baseLanes:e.baseLanes|c},f.childLanes=a.childLanes&~c,b.memoizedState=si,d;c=xi(a,b,d.children,c);b.memoizedState=null;return c}function ui(a,b,c,d){var e=a.mode,f=a.child;b={mode:"hidden",children:b};0===(e&2)&&null!==f?(f.childLanes=0,f.pendingProps=b):f=vi(b,e,0,null);c=Xg(c,e,d,null);f.return=a;c.return=a;f.sibling=c;a.child=f;return c}\nfunction xi(a,b,c,d){var e=a.child;a=e.sibling;c=Tg(e,{mode:"visible",children:c});0===(b.mode&2)&&(c.lanes=d);c.return=b;c.sibling=null;null!==a&&(a.nextEffect=null,a.flags=8,b.firstEffect=b.lastEffect=a);return b.child=c}\nfunction wi(a,b,c,d,e){var f=b.mode,g=a.child;a=g.sibling;var h={mode:"hidden",children:c};0===(f&2)&&b.child!==g?(c=b.child,c.childLanes=0,c.pendingProps=h,g=c.lastEffect,null!==g?(b.firstEffect=c.firstEffect,b.lastEffect=g,g.nextEffect=null):b.firstEffect=b.lastEffect=null):c=Tg(g,h);null!==a?d=Tg(a,d):(d=Xg(d,f,e,null),d.flags|=2);d.return=b;c.return=b;c.sibling=d;b.child=c;return d}function yi(a,b){a.lanes|=b;var c=a.alternate;null!==c&&(c.lanes|=b);sg(a.return,b)}\nfunction zi(a,b,c,d,e,f){var g=a.memoizedState;null===g?a.memoizedState={isBackwards:b,rendering:null,renderingStartTime:0,last:d,tail:c,tailMode:e,lastEffect:f}:(g.isBackwards=b,g.rendering=null,g.renderingStartTime=0,g.last=d,g.tail=c,g.tailMode=e,g.lastEffect=f)}\nfunction Ai(a,b,c){var d=b.pendingProps,e=d.revealOrder,f=d.tail;fi(a,b,d.children,c);d=P.current;if(0!==(d&2))d=d&1|2,b.flags|=64;else{if(null!==a&&0!==(a.flags&64))a:for(a=b.child;null!==a;){if(13===a.tag)null!==a.memoizedState&&yi(a,c);else if(19===a.tag)yi(a,c);else if(null!==a.child){a.child.return=a;a=a.child;continue}if(a===b)break a;for(;null===a.sibling;){if(null===a.return||a.return===b)break a;a=a.return}a.sibling.return=a.return;a=a.sibling}d&=1}I(P,d);if(0===(b.mode&2))b.memoizedState=\nnull;else switch(e){case "forwards":c=b.child;for(e=null;null!==c;)a=c.alternate,null!==a&&null===ih(a)&&(e=c),c=c.sibling;c=e;null===c?(e=b.child,b.child=null):(e=c.sibling,c.sibling=null);zi(b,!1,e,c,f,b.lastEffect);break;case "backwards":c=null;e=b.child;for(b.child=null;null!==e;){a=e.alternate;if(null!==a&&null===ih(a)){b.child=e;break}a=e.sibling;e.sibling=c;c=e;e=a}zi(b,!0,c,null,f,b.lastEffect);break;case "together":zi(b,!1,null,null,void 0,b.lastEffect);break;default:b.memoizedState=null}return b.child}\nfunction hi(a,b,c){null!==a&&(b.dependencies=a.dependencies);Dg|=b.lanes;if(0!==(c&b.childLanes)){if(null!==a&&b.child!==a.child)throw Error(y(153));if(null!==b.child){a=b.child;c=Tg(a,a.pendingProps);b.child=c;for(c.return=b;null!==a.sibling;)a=a.sibling,c=c.sibling=Tg(a,a.pendingProps),c.return=b;c.sibling=null}return b.child}return null}var Bi,Ci,Di,Ei;\nBi=function(a,b){for(var c=b.child;null!==c;){if(5===c.tag||6===c.tag)a.appendChild(c.stateNode);else if(4!==c.tag&&null!==c.child){c.child.return=c;c=c.child;continue}if(c===b)break;for(;null===c.sibling;){if(null===c.return||c.return===b)return;c=c.return}c.sibling.return=c.return;c=c.sibling}};Ci=function(){};\nDi=function(a,b,c,d){var e=a.memoizedProps;if(e!==d){a=b.stateNode;dh(ah.current);var f=null;switch(c){case "input":e=Ya(a,e);d=Ya(a,d);f=[];break;case "option":e=eb(a,e);d=eb(a,d);f=[];break;case "select":e=m({},e,{value:void 0});d=m({},d,{value:void 0});f=[];break;case "textarea":e=gb(a,e);d=gb(a,d);f=[];break;default:"function"!==typeof e.onClick&&"function"===typeof d.onClick&&(a.onclick=jf)}vb(c,d);var g;c=null;for(l in e)if(!d.hasOwnProperty(l)&&e.hasOwnProperty(l)&&null!=e[l])if("style"===\nl){var h=e[l];for(g in h)h.hasOwnProperty(g)&&(c||(c={}),c[g]="")}else"dangerouslySetInnerHTML"!==l&&"children"!==l&&"suppressContentEditableWarning"!==l&&"suppressHydrationWarning"!==l&&"autoFocus"!==l&&(ca.hasOwnProperty(l)?f||(f=[]):(f=f||[]).push(l,null));for(l in d){var k=d[l];h=null!=e?e[l]:void 0;if(d.hasOwnProperty(l)&&k!==h&&(null!=k||null!=h))if("style"===l)if(h){for(g in h)!h.hasOwnProperty(g)||k&&k.hasOwnProperty(g)||(c||(c={}),c[g]="");for(g in k)k.hasOwnProperty(g)&&h[g]!==k[g]&&(c||\n(c={}),c[g]=k[g])}else c||(f||(f=[]),f.push(l,c)),c=k;else"dangerouslySetInnerHTML"===l?(k=k?k.__html:void 0,h=h?h.__html:void 0,null!=k&&h!==k&&(f=f||[]).push(l,k)):"children"===l?"string"!==typeof k&&"number"!==typeof k||(f=f||[]).push(l,""+k):"suppressContentEditableWarning"!==l&&"suppressHydrationWarning"!==l&&(ca.hasOwnProperty(l)?(null!=k&&"onScroll"===l&&G("scroll",a),f||h===k||(f=[])):"object"===typeof k&&null!==k&&k.$$typeof===Ga?k.toString():(f=f||[]).push(l,k))}c&&(f=f||[]).push("style",\nc);var l=f;if(b.updateQueue=l)b.flags|=4}};Ei=function(a,b,c,d){c!==d&&(b.flags|=4)};function Fi(a,b){if(!lh)switch(a.tailMode){case "hidden":b=a.tail;for(var c=null;null!==b;)null!==b.alternate&&(c=b),b=b.sibling;null===c?a.tail=null:c.sibling=null;break;case "collapsed":c=a.tail;for(var d=null;null!==c;)null!==c.alternate&&(d=c),c=c.sibling;null===d?b||null===a.tail?a.tail=null:a.tail.sibling=null:d.sibling=null}}\nfunction Gi(a,b,c){var d=b.pendingProps;switch(b.tag){case 2:case 16:case 15:case 0:case 11:case 7:case 8:case 12:case 9:case 14:return null;case 1:return Ff(b.type)&&Gf(),null;case 3:fh();H(N);H(M);uh();d=b.stateNode;d.pendingContext&&(d.context=d.pendingContext,d.pendingContext=null);if(null===a||null===a.child)rh(b)?b.flags|=4:d.hydrate||(b.flags|=256);Ci(b);return null;case 5:hh(b);var e=dh(ch.current);c=b.type;if(null!==a&&null!=b.stateNode)Di(a,b,c,d,e),a.ref!==b.ref&&(b.flags|=128);else{if(!d){if(null===\nb.stateNode)throw Error(y(166));return null}a=dh(ah.current);if(rh(b)){d=b.stateNode;c=b.type;var f=b.memoizedProps;d[wf]=b;d[xf]=f;switch(c){case "dialog":G("cancel",d);G("close",d);break;case "iframe":case "object":case "embed":G("load",d);break;case "video":case "audio":for(a=0;a<Xe.length;a++)G(Xe[a],d);break;case "source":G("error",d);break;case "img":case "image":case "link":G("error",d);G("load",d);break;case "details":G("toggle",d);break;case "input":Za(d,f);G("invalid",d);break;case "select":d._wrapperState=\n{wasMultiple:!!f.multiple};G("invalid",d);break;case "textarea":hb(d,f),G("invalid",d)}vb(c,f);a=null;for(var g in f)f.hasOwnProperty(g)&&(e=f[g],"children"===g?"string"===typeof e?d.textContent!==e&&(a=["children",e]):"number"===typeof e&&d.textContent!==""+e&&(a=["children",""+e]):ca.hasOwnProperty(g)&&null!=e&&"onScroll"===g&&G("scroll",d));switch(c){case "input":Va(d);cb(d,f,!0);break;case "textarea":Va(d);jb(d);break;case "select":case "option":break;default:"function"===typeof f.onClick&&(d.onclick=\njf)}d=a;b.updateQueue=d;null!==d&&(b.flags|=4)}else{g=9===e.nodeType?e:e.ownerDocument;a===kb.html&&(a=lb(c));a===kb.html?"script"===c?(a=g.createElement("div"),a.innerHTML="<script>\\x3c/script>",a=a.removeChild(a.firstChild)):"string"===typeof d.is?a=g.createElement(c,{is:d.is}):(a=g.createElement(c),"select"===c&&(g=a,d.multiple?g.multiple=!0:d.size&&(g.size=d.size))):a=g.createElementNS(a,c);a[wf]=b;a[xf]=d;Bi(a,b,!1,!1);b.stateNode=a;g=wb(c,d);switch(c){case "dialog":G("cancel",a);G("close",a);\ne=d;break;case "iframe":case "object":case "embed":G("load",a);e=d;break;case "video":case "audio":for(e=0;e<Xe.length;e++)G(Xe[e],a);e=d;break;case "source":G("error",a);e=d;break;case "img":case "image":case "link":G("error",a);G("load",a);e=d;break;case "details":G("toggle",a);e=d;break;case "input":Za(a,d);e=Ya(a,d);G("invalid",a);break;case "option":e=eb(a,d);break;case "select":a._wrapperState={wasMultiple:!!d.multiple};e=m({},d,{value:void 0});G("invalid",a);break;case "textarea":hb(a,d);e=\ngb(a,d);G("invalid",a);break;default:e=d}vb(c,e);var h=e;for(f in h)if(h.hasOwnProperty(f)){var k=h[f];"style"===f?tb(a,k):"dangerouslySetInnerHTML"===f?(k=k?k.__html:void 0,null!=k&&ob(a,k)):"children"===f?"string"===typeof k?("textarea"!==c||""!==k)&&pb(a,k):"number"===typeof k&&pb(a,""+k):"suppressContentEditableWarning"!==f&&"suppressHydrationWarning"!==f&&"autoFocus"!==f&&(ca.hasOwnProperty(f)?null!=k&&"onScroll"===f&&G("scroll",a):null!=k&&qa(a,f,k,g))}switch(c){case "input":Va(a);cb(a,d,!1);\nbreak;case "textarea":Va(a);jb(a);break;case "option":null!=d.value&&a.setAttribute("value",""+Sa(d.value));break;case "select":a.multiple=!!d.multiple;f=d.value;null!=f?fb(a,!!d.multiple,f,!1):null!=d.defaultValue&&fb(a,!!d.multiple,d.defaultValue,!0);break;default:"function"===typeof e.onClick&&(a.onclick=jf)}mf(c,d)&&(b.flags|=4)}null!==b.ref&&(b.flags|=128)}return null;case 6:if(a&&null!=b.stateNode)Ei(a,b,a.memoizedProps,d);else{if("string"!==typeof d&&null===b.stateNode)throw Error(y(166));\nc=dh(ch.current);dh(ah.current);rh(b)?(d=b.stateNode,c=b.memoizedProps,d[wf]=b,d.nodeValue!==c&&(b.flags|=4)):(d=(9===c.nodeType?c:c.ownerDocument).createTextNode(d),d[wf]=b,b.stateNode=d)}return null;case 13:H(P);d=b.memoizedState;if(0!==(b.flags&64))return b.lanes=c,b;d=null!==d;c=!1;null===a?void 0!==b.memoizedProps.fallback&&rh(b):c=null!==a.memoizedState;if(d&&!c&&0!==(b.mode&2))if(null===a&&!0!==b.memoizedProps.unstable_avoidThisFallback||0!==(P.current&1))0===V&&(V=3);else{if(0===V||3===V)V=\n4;null===U||0===(Dg&134217727)&&0===(Hi&134217727)||Ii(U,W)}if(d||c)b.flags|=4;return null;case 4:return fh(),Ci(b),null===a&&cf(b.stateNode.containerInfo),null;case 10:return rg(b),null;case 17:return Ff(b.type)&&Gf(),null;case 19:H(P);d=b.memoizedState;if(null===d)return null;f=0!==(b.flags&64);g=d.rendering;if(null===g)if(f)Fi(d,!1);else{if(0!==V||null!==a&&0!==(a.flags&64))for(a=b.child;null!==a;){g=ih(a);if(null!==g){b.flags|=64;Fi(d,!1);f=g.updateQueue;null!==f&&(b.updateQueue=f,b.flags|=4);\nnull===d.lastEffect&&(b.firstEffect=null);b.lastEffect=d.lastEffect;d=c;for(c=b.child;null!==c;)f=c,a=d,f.flags&=2,f.nextEffect=null,f.firstEffect=null,f.lastEffect=null,g=f.alternate,null===g?(f.childLanes=0,f.lanes=a,f.child=null,f.memoizedProps=null,f.memoizedState=null,f.updateQueue=null,f.dependencies=null,f.stateNode=null):(f.childLanes=g.childLanes,f.lanes=g.lanes,f.child=g.child,f.memoizedProps=g.memoizedProps,f.memoizedState=g.memoizedState,f.updateQueue=g.updateQueue,f.type=g.type,a=g.dependencies,\nf.dependencies=null===a?null:{lanes:a.lanes,firstContext:a.firstContext}),c=c.sibling;I(P,P.current&1|2);return b.child}a=a.sibling}null!==d.tail&&O()>Ji&&(b.flags|=64,f=!0,Fi(d,!1),b.lanes=33554432)}else{if(!f)if(a=ih(g),null!==a){if(b.flags|=64,f=!0,c=a.updateQueue,null!==c&&(b.updateQueue=c,b.flags|=4),Fi(d,!0),null===d.tail&&"hidden"===d.tailMode&&!g.alternate&&!lh)return b=b.lastEffect=d.lastEffect,null!==b&&(b.nextEffect=null),null}else 2*O()-d.renderingStartTime>Ji&&1073741824!==c&&(b.flags|=\n64,f=!0,Fi(d,!1),b.lanes=33554432);d.isBackwards?(g.sibling=b.child,b.child=g):(c=d.last,null!==c?c.sibling=g:b.child=g,d.last=g)}return null!==d.tail?(c=d.tail,d.rendering=c,d.tail=c.sibling,d.lastEffect=b.lastEffect,d.renderingStartTime=O(),c.sibling=null,b=P.current,I(P,f?b&1|2:b&1),c):null;case 23:case 24:return Ki(),null!==a&&null!==a.memoizedState!==(null!==b.memoizedState)&&"unstable-defer-without-hiding"!==d.mode&&(b.flags|=4),null}throw Error(y(156,b.tag));}\nfunction Li(a){switch(a.tag){case 1:Ff(a.type)&&Gf();var b=a.flags;return b&4096?(a.flags=b&-4097|64,a):null;case 3:fh();H(N);H(M);uh();b=a.flags;if(0!==(b&64))throw Error(y(285));a.flags=b&-4097|64;return a;case 5:return hh(a),null;case 13:return H(P),b=a.flags,b&4096?(a.flags=b&-4097|64,a):null;case 19:return H(P),null;case 4:return fh(),null;case 10:return rg(a),null;case 23:case 24:return Ki(),null;default:return null}}\nfunction Mi(a,b){try{var c="",d=b;do c+=Qa(d),d=d.return;while(d);var e=c}catch(f){e="\\nError generating stack: "+f.message+"\\n"+f.stack}return{value:a,source:b,stack:e}}function Ni(a,b){try{console.error(b.value)}catch(c){setTimeout(function(){throw c;})}}var Oi="function"===typeof WeakMap?WeakMap:Map;function Pi(a,b,c){c=zg(-1,c);c.tag=3;c.payload={element:null};var d=b.value;c.callback=function(){Qi||(Qi=!0,Ri=d);Ni(a,b)};return c}\nfunction Si(a,b,c){c=zg(-1,c);c.tag=3;var d=a.type.getDerivedStateFromError;if("function"===typeof d){var e=b.value;c.payload=function(){Ni(a,b);return d(e)}}var f=a.stateNode;null!==f&&"function"===typeof f.componentDidCatch&&(c.callback=function(){"function"!==typeof d&&(null===Ti?Ti=new Set([this]):Ti.add(this),Ni(a,b));var c=b.stack;this.componentDidCatch(b.value,{componentStack:null!==c?c:""})});return c}var Ui="function"===typeof WeakSet?WeakSet:Set;\nfunction Vi(a){var b=a.ref;if(null!==b)if("function"===typeof b)try{b(null)}catch(c){Wi(a,c)}else b.current=null}function Xi(a,b){switch(b.tag){case 0:case 11:case 15:case 22:return;case 1:if(b.flags&256&&null!==a){var c=a.memoizedProps,d=a.memoizedState;a=b.stateNode;b=a.getSnapshotBeforeUpdate(b.elementType===b.type?c:lg(b.type,c),d);a.__reactInternalSnapshotBeforeUpdate=b}return;case 3:b.flags&256&&qf(b.stateNode.containerInfo);return;case 5:case 6:case 4:case 17:return}throw Error(y(163));}\nfunction Yi(a,b,c){switch(c.tag){case 0:case 11:case 15:case 22:b=c.updateQueue;b=null!==b?b.lastEffect:null;if(null!==b){a=b=b.next;do{if(3===(a.tag&3)){var d=a.create;a.destroy=d()}a=a.next}while(a!==b)}b=c.updateQueue;b=null!==b?b.lastEffect:null;if(null!==b){a=b=b.next;do{var e=a;d=e.next;e=e.tag;0!==(e&4)&&0!==(e&1)&&(Zi(c,a),$i(c,a));a=d}while(a!==b)}return;case 1:a=c.stateNode;c.flags&4&&(null===b?a.componentDidMount():(d=c.elementType===c.type?b.memoizedProps:lg(c.type,b.memoizedProps),a.componentDidUpdate(d,\nb.memoizedState,a.__reactInternalSnapshotBeforeUpdate)));b=c.updateQueue;null!==b&&Eg(c,b,a);return;case 3:b=c.updateQueue;if(null!==b){a=null;if(null!==c.child)switch(c.child.tag){case 5:a=c.child.stateNode;break;case 1:a=c.child.stateNode}Eg(c,b,a)}return;case 5:a=c.stateNode;null===b&&c.flags&4&&mf(c.type,c.memoizedProps)&&a.focus();return;case 6:return;case 4:return;case 12:return;case 13:null===c.memoizedState&&(c=c.alternate,null!==c&&(c=c.memoizedState,null!==c&&(c=c.dehydrated,null!==c&&Cc(c))));\nreturn;case 19:case 17:case 20:case 21:case 23:case 24:return}throw Error(y(163));}\nfunction aj(a,b){for(var c=a;;){if(5===c.tag){var d=c.stateNode;if(b)d=d.style,"function"===typeof d.setProperty?d.setProperty("display","none","important"):d.display="none";else{d=c.stateNode;var e=c.memoizedProps.style;e=void 0!==e&&null!==e&&e.hasOwnProperty("display")?e.display:null;d.style.display=sb("display",e)}}else if(6===c.tag)c.stateNode.nodeValue=b?"":c.memoizedProps;else if((23!==c.tag&&24!==c.tag||null===c.memoizedState||c===a)&&null!==c.child){c.child.return=c;c=c.child;continue}if(c===\na)break;for(;null===c.sibling;){if(null===c.return||c.return===a)return;c=c.return}c.sibling.return=c.return;c=c.sibling}}\nfunction bj(a,b){if(Mf&&"function"===typeof Mf.onCommitFiberUnmount)try{Mf.onCommitFiberUnmount(Lf,b)}catch(f){}switch(b.tag){case 0:case 11:case 14:case 15:case 22:a=b.updateQueue;if(null!==a&&(a=a.lastEffect,null!==a)){var c=a=a.next;do{var d=c,e=d.destroy;d=d.tag;if(void 0!==e)if(0!==(d&4))Zi(b,c);else{d=b;try{e()}catch(f){Wi(d,f)}}c=c.next}while(c!==a)}break;case 1:Vi(b);a=b.stateNode;if("function"===typeof a.componentWillUnmount)try{a.props=b.memoizedProps,a.state=b.memoizedState,a.componentWillUnmount()}catch(f){Wi(b,\nf)}break;case 5:Vi(b);break;case 4:cj(a,b)}}function dj(a){a.alternate=null;a.child=null;a.dependencies=null;a.firstEffect=null;a.lastEffect=null;a.memoizedProps=null;a.memoizedState=null;a.pendingProps=null;a.return=null;a.updateQueue=null}function ej(a){return 5===a.tag||3===a.tag||4===a.tag}\nfunction fj(a){a:{for(var b=a.return;null!==b;){if(ej(b))break a;b=b.return}throw Error(y(160));}var c=b;b=c.stateNode;switch(c.tag){case 5:var d=!1;break;case 3:b=b.containerInfo;d=!0;break;case 4:b=b.containerInfo;d=!0;break;default:throw Error(y(161));}c.flags&16&&(pb(b,""),c.flags&=-17);a:b:for(c=a;;){for(;null===c.sibling;){if(null===c.return||ej(c.return)){c=null;break a}c=c.return}c.sibling.return=c.return;for(c=c.sibling;5!==c.tag&&6!==c.tag&&18!==c.tag;){if(c.flags&2)continue b;if(null===\nc.child||4===c.tag)continue b;else c.child.return=c,c=c.child}if(!(c.flags&2)){c=c.stateNode;break a}}d?gj(a,c,b):hj(a,c,b)}\nfunction gj(a,b,c){var d=a.tag,e=5===d||6===d;if(e)a=e?a.stateNode:a.stateNode.instance,b?8===c.nodeType?c.parentNode.insertBefore(a,b):c.insertBefore(a,b):(8===c.nodeType?(b=c.parentNode,b.insertBefore(a,c)):(b=c,b.appendChild(a)),c=c._reactRootContainer,null!==c&&void 0!==c||null!==b.onclick||(b.onclick=jf));else if(4!==d&&(a=a.child,null!==a))for(gj(a,b,c),a=a.sibling;null!==a;)gj(a,b,c),a=a.sibling}\nfunction hj(a,b,c){var d=a.tag,e=5===d||6===d;if(e)a=e?a.stateNode:a.stateNode.instance,b?c.insertBefore(a,b):c.appendChild(a);else if(4!==d&&(a=a.child,null!==a))for(hj(a,b,c),a=a.sibling;null!==a;)hj(a,b,c),a=a.sibling}\nfunction cj(a,b){for(var c=b,d=!1,e,f;;){if(!d){d=c.return;a:for(;;){if(null===d)throw Error(y(160));e=d.stateNode;switch(d.tag){case 5:f=!1;break a;case 3:e=e.containerInfo;f=!0;break a;case 4:e=e.containerInfo;f=!0;break a}d=d.return}d=!0}if(5===c.tag||6===c.tag){a:for(var g=a,h=c,k=h;;)if(bj(g,k),null!==k.child&&4!==k.tag)k.child.return=k,k=k.child;else{if(k===h)break a;for(;null===k.sibling;){if(null===k.return||k.return===h)break a;k=k.return}k.sibling.return=k.return;k=k.sibling}f?(g=e,h=c.stateNode,\n8===g.nodeType?g.parentNode.removeChild(h):g.removeChild(h)):e.removeChild(c.stateNode)}else if(4===c.tag){if(null!==c.child){e=c.stateNode.containerInfo;f=!0;c.child.return=c;c=c.child;continue}}else if(bj(a,c),null!==c.child){c.child.return=c;c=c.child;continue}if(c===b)break;for(;null===c.sibling;){if(null===c.return||c.return===b)return;c=c.return;4===c.tag&&(d=!1)}c.sibling.return=c.return;c=c.sibling}}\nfunction ij(a,b){switch(b.tag){case 0:case 11:case 14:case 15:case 22:var c=b.updateQueue;c=null!==c?c.lastEffect:null;if(null!==c){var d=c=c.next;do 3===(d.tag&3)&&(a=d.destroy,d.destroy=void 0,void 0!==a&&a()),d=d.next;while(d!==c)}return;case 1:return;case 5:c=b.stateNode;if(null!=c){d=b.memoizedProps;var e=null!==a?a.memoizedProps:d;a=b.type;var f=b.updateQueue;b.updateQueue=null;if(null!==f){c[xf]=d;"input"===a&&"radio"===d.type&&null!=d.name&&$a(c,d);wb(a,e);b=wb(a,d);for(e=0;e<f.length;e+=\n2){var g=f[e],h=f[e+1];"style"===g?tb(c,h):"dangerouslySetInnerHTML"===g?ob(c,h):"children"===g?pb(c,h):qa(c,g,h,b)}switch(a){case "input":ab(c,d);break;case "textarea":ib(c,d);break;case "select":a=c._wrapperState.wasMultiple,c._wrapperState.wasMultiple=!!d.multiple,f=d.value,null!=f?fb(c,!!d.multiple,f,!1):a!==!!d.multiple&&(null!=d.defaultValue?fb(c,!!d.multiple,d.defaultValue,!0):fb(c,!!d.multiple,d.multiple?[]:"",!1))}}}return;case 6:if(null===b.stateNode)throw Error(y(162));b.stateNode.nodeValue=\nb.memoizedProps;return;case 3:c=b.stateNode;c.hydrate&&(c.hydrate=!1,Cc(c.containerInfo));return;case 12:return;case 13:null!==b.memoizedState&&(jj=O(),aj(b.child,!0));kj(b);return;case 19:kj(b);return;case 17:return;case 23:case 24:aj(b,null!==b.memoizedState);return}throw Error(y(163));}function kj(a){var b=a.updateQueue;if(null!==b){a.updateQueue=null;var c=a.stateNode;null===c&&(c=a.stateNode=new Ui);b.forEach(function(b){var d=lj.bind(null,a,b);c.has(b)||(c.add(b),b.then(d,d))})}}\nfunction mj(a,b){return null!==a&&(a=a.memoizedState,null===a||null!==a.dehydrated)?(b=b.memoizedState,null!==b&&null===b.dehydrated):!1}var nj=Math.ceil,oj=ra.ReactCurrentDispatcher,pj=ra.ReactCurrentOwner,X=0,U=null,Y=null,W=0,qj=0,rj=Bf(0),V=0,sj=null,tj=0,Dg=0,Hi=0,uj=0,vj=null,jj=0,Ji=Infinity;function wj(){Ji=O()+500}var Z=null,Qi=!1,Ri=null,Ti=null,xj=!1,yj=null,zj=90,Aj=[],Bj=[],Cj=null,Dj=0,Ej=null,Fj=-1,Gj=0,Hj=0,Ij=null,Jj=!1;function Hg(){return 0!==(X&48)?O():-1!==Fj?Fj:Fj=O()}\nfunction Ig(a){a=a.mode;if(0===(a&2))return 1;if(0===(a&4))return 99===eg()?1:2;0===Gj&&(Gj=tj);if(0!==kg.transition){0!==Hj&&(Hj=null!==vj?vj.pendingLanes:0);a=Gj;var b=4186112&~Hj;b&=-b;0===b&&(a=4186112&~a,b=a&-a,0===b&&(b=8192));return b}a=eg();0!==(X&4)&&98===a?a=Xc(12,Gj):(a=Sc(a),a=Xc(a,Gj));return a}\nfunction Jg(a,b,c){if(50<Dj)throw Dj=0,Ej=null,Error(y(185));a=Kj(a,b);if(null===a)return null;$c(a,b,c);a===U&&(Hi|=b,4===V&&Ii(a,W));var d=eg();1===b?0!==(X&8)&&0===(X&48)?Lj(a):(Mj(a,c),0===X&&(wj(),ig())):(0===(X&4)||98!==d&&99!==d||(null===Cj?Cj=new Set([a]):Cj.add(a)),Mj(a,c));vj=a}function Kj(a,b){a.lanes|=b;var c=a.alternate;null!==c&&(c.lanes|=b);c=a;for(a=a.return;null!==a;)a.childLanes|=b,c=a.alternate,null!==c&&(c.childLanes|=b),c=a,a=a.return;return 3===c.tag?c.stateNode:null}\nfunction Mj(a,b){for(var c=a.callbackNode,d=a.suspendedLanes,e=a.pingedLanes,f=a.expirationTimes,g=a.pendingLanes;0<g;){var h=31-Vc(g),k=1<<h,l=f[h];if(-1===l){if(0===(k&d)||0!==(k&e)){l=b;Rc(k);var n=F;f[h]=10<=n?l+250:6<=n?l+5E3:-1}}else l<=b&&(a.expiredLanes|=k);g&=~k}d=Uc(a,a===U?W:0);b=F;if(0===d)null!==c&&(c!==Zf&&Pf(c),a.callbackNode=null,a.callbackPriority=0);else{if(null!==c){if(a.callbackPriority===b)return;c!==Zf&&Pf(c)}15===b?(c=Lj.bind(null,a),null===ag?(ag=[c],bg=Of(Uf,jg)):ag.push(c),\nc=Zf):14===b?c=hg(99,Lj.bind(null,a)):(c=Tc(b),c=hg(c,Nj.bind(null,a)));a.callbackPriority=b;a.callbackNode=c}}\nfunction Nj(a){Fj=-1;Hj=Gj=0;if(0!==(X&48))throw Error(y(327));var b=a.callbackNode;if(Oj()&&a.callbackNode!==b)return null;var c=Uc(a,a===U?W:0);if(0===c)return null;var d=c;var e=X;X|=16;var f=Pj();if(U!==a||W!==d)wj(),Qj(a,d);do try{Rj();break}catch(h){Sj(a,h)}while(1);qg();oj.current=f;X=e;null!==Y?d=0:(U=null,W=0,d=V);if(0!==(tj&Hi))Qj(a,0);else if(0!==d){2===d&&(X|=64,a.hydrate&&(a.hydrate=!1,qf(a.containerInfo)),c=Wc(a),0!==c&&(d=Tj(a,c)));if(1===d)throw b=sj,Qj(a,0),Ii(a,c),Mj(a,O()),b;a.finishedWork=\na.current.alternate;a.finishedLanes=c;switch(d){case 0:case 1:throw Error(y(345));case 2:Uj(a);break;case 3:Ii(a,c);if((c&62914560)===c&&(d=jj+500-O(),10<d)){if(0!==Uc(a,0))break;e=a.suspendedLanes;if((e&c)!==c){Hg();a.pingedLanes|=a.suspendedLanes&e;break}a.timeoutHandle=of(Uj.bind(null,a),d);break}Uj(a);break;case 4:Ii(a,c);if((c&4186112)===c)break;d=a.eventTimes;for(e=-1;0<c;){var g=31-Vc(c);f=1<<g;g=d[g];g>e&&(e=g);c&=~f}c=e;c=O()-c;c=(120>c?120:480>c?480:1080>c?1080:1920>c?1920:3E3>c?3E3:4320>\nc?4320:1960*nj(c/1960))-c;if(10<c){a.timeoutHandle=of(Uj.bind(null,a),c);break}Uj(a);break;case 5:Uj(a);break;default:throw Error(y(329));}}Mj(a,O());return a.callbackNode===b?Nj.bind(null,a):null}function Ii(a,b){b&=~uj;b&=~Hi;a.suspendedLanes|=b;a.pingedLanes&=~b;for(a=a.expirationTimes;0<b;){var c=31-Vc(b),d=1<<c;a[c]=-1;b&=~d}}\nfunction Lj(a){if(0!==(X&48))throw Error(y(327));Oj();if(a===U&&0!==(a.expiredLanes&W)){var b=W;var c=Tj(a,b);0!==(tj&Hi)&&(b=Uc(a,b),c=Tj(a,b))}else b=Uc(a,0),c=Tj(a,b);0!==a.tag&&2===c&&(X|=64,a.hydrate&&(a.hydrate=!1,qf(a.containerInfo)),b=Wc(a),0!==b&&(c=Tj(a,b)));if(1===c)throw c=sj,Qj(a,0),Ii(a,b),Mj(a,O()),c;a.finishedWork=a.current.alternate;a.finishedLanes=b;Uj(a);Mj(a,O());return null}\nfunction Vj(){if(null!==Cj){var a=Cj;Cj=null;a.forEach(function(a){a.expiredLanes|=24&a.pendingLanes;Mj(a,O())})}ig()}function Wj(a,b){var c=X;X|=1;try{return a(b)}finally{X=c,0===X&&(wj(),ig())}}function Xj(a,b){var c=X;X&=-2;X|=8;try{return a(b)}finally{X=c,0===X&&(wj(),ig())}}function ni(a,b){I(rj,qj);qj|=b;tj|=b}function Ki(){qj=rj.current;H(rj)}\nfunction Qj(a,b){a.finishedWork=null;a.finishedLanes=0;var c=a.timeoutHandle;-1!==c&&(a.timeoutHandle=-1,pf(c));if(null!==Y)for(c=Y.return;null!==c;){var d=c;switch(d.tag){case 1:d=d.type.childContextTypes;null!==d&&void 0!==d&&Gf();break;case 3:fh();H(N);H(M);uh();break;case 5:hh(d);break;case 4:fh();break;case 13:H(P);break;case 19:H(P);break;case 10:rg(d);break;case 23:case 24:Ki()}c=c.return}U=a;Y=Tg(a.current,null);W=qj=tj=b;V=0;sj=null;uj=Hi=Dg=0}\nfunction Sj(a,b){do{var c=Y;try{qg();vh.current=Gh;if(yh){for(var d=R.memoizedState;null!==d;){var e=d.queue;null!==e&&(e.pending=null);d=d.next}yh=!1}xh=0;T=S=R=null;zh=!1;pj.current=null;if(null===c||null===c.return){V=1;sj=b;Y=null;break}a:{var f=a,g=c.return,h=c,k=b;b=W;h.flags|=2048;h.firstEffect=h.lastEffect=null;if(null!==k&&"object"===typeof k&&"function"===typeof k.then){var l=k;if(0===(h.mode&2)){var n=h.alternate;n?(h.updateQueue=n.updateQueue,h.memoizedState=n.memoizedState,h.lanes=n.lanes):\n(h.updateQueue=null,h.memoizedState=null)}var A=0!==(P.current&1),p=g;do{var C;if(C=13===p.tag){var x=p.memoizedState;if(null!==x)C=null!==x.dehydrated?!0:!1;else{var w=p.memoizedProps;C=void 0===w.fallback?!1:!0!==w.unstable_avoidThisFallback?!0:A?!1:!0}}if(C){var z=p.updateQueue;if(null===z){var u=new Set;u.add(l);p.updateQueue=u}else z.add(l);if(0===(p.mode&2)){p.flags|=64;h.flags|=16384;h.flags&=-2981;if(1===h.tag)if(null===h.alternate)h.tag=17;else{var t=zg(-1,1);t.tag=2;Ag(h,t)}h.lanes|=1;break a}k=\nvoid 0;h=b;var q=f.pingCache;null===q?(q=f.pingCache=new Oi,k=new Set,q.set(l,k)):(k=q.get(l),void 0===k&&(k=new Set,q.set(l,k)));if(!k.has(h)){k.add(h);var v=Yj.bind(null,f,l,h);l.then(v,v)}p.flags|=4096;p.lanes=b;break a}p=p.return}while(null!==p);k=Error((Ra(h.type)||"A React component")+" suspended while rendering, but no fallback UI was specified.\\n\\nAdd a <Suspense fallback=...> component higher in the tree to provide a loading indicator or placeholder to display.")}5!==V&&(V=2);k=Mi(k,h);p=\ng;do{switch(p.tag){case 3:f=k;p.flags|=4096;b&=-b;p.lanes|=b;var J=Pi(p,f,b);Bg(p,J);break a;case 1:f=k;var K=p.type,Q=p.stateNode;if(0===(p.flags&64)&&("function"===typeof K.getDerivedStateFromError||null!==Q&&"function"===typeof Q.componentDidCatch&&(null===Ti||!Ti.has(Q)))){p.flags|=4096;b&=-b;p.lanes|=b;var L=Si(p,f,b);Bg(p,L);break a}}p=p.return}while(null!==p)}Zj(c)}catch(va){b=va;Y===c&&null!==c&&(Y=c=c.return);continue}break}while(1)}\nfunction Pj(){var a=oj.current;oj.current=Gh;return null===a?Gh:a}function Tj(a,b){var c=X;X|=16;var d=Pj();U===a&&W===b||Qj(a,b);do try{ak();break}catch(e){Sj(a,e)}while(1);qg();X=c;oj.current=d;if(null!==Y)throw Error(y(261));U=null;W=0;return V}function ak(){for(;null!==Y;)bk(Y)}function Rj(){for(;null!==Y&&!Qf();)bk(Y)}function bk(a){var b=ck(a.alternate,a,qj);a.memoizedProps=a.pendingProps;null===b?Zj(a):Y=b;pj.current=null}\nfunction Zj(a){var b=a;do{var c=b.alternate;a=b.return;if(0===(b.flags&2048)){c=Gi(c,b,qj);if(null!==c){Y=c;return}c=b;if(24!==c.tag&&23!==c.tag||null===c.memoizedState||0!==(qj&1073741824)||0===(c.mode&4)){for(var d=0,e=c.child;null!==e;)d|=e.lanes|e.childLanes,e=e.sibling;c.childLanes=d}null!==a&&0===(a.flags&2048)&&(null===a.firstEffect&&(a.firstEffect=b.firstEffect),null!==b.lastEffect&&(null!==a.lastEffect&&(a.lastEffect.nextEffect=b.firstEffect),a.lastEffect=b.lastEffect),1<b.flags&&(null!==\na.lastEffect?a.lastEffect.nextEffect=b:a.firstEffect=b,a.lastEffect=b))}else{c=Li(b);if(null!==c){c.flags&=2047;Y=c;return}null!==a&&(a.firstEffect=a.lastEffect=null,a.flags|=2048)}b=b.sibling;if(null!==b){Y=b;return}Y=b=a}while(null!==b);0===V&&(V=5)}function Uj(a){var b=eg();gg(99,dk.bind(null,a,b));return null}\nfunction dk(a,b){do Oj();while(null!==yj);if(0!==(X&48))throw Error(y(327));var c=a.finishedWork;if(null===c)return null;a.finishedWork=null;a.finishedLanes=0;if(c===a.current)throw Error(y(177));a.callbackNode=null;var d=c.lanes|c.childLanes,e=d,f=a.pendingLanes&~e;a.pendingLanes=e;a.suspendedLanes=0;a.pingedLanes=0;a.expiredLanes&=e;a.mutableReadLanes&=e;a.entangledLanes&=e;e=a.entanglements;for(var g=a.eventTimes,h=a.expirationTimes;0<f;){var k=31-Vc(f),l=1<<k;e[k]=0;g[k]=-1;h[k]=-1;f&=~l}null!==\nCj&&0===(d&24)&&Cj.has(a)&&Cj.delete(a);a===U&&(Y=U=null,W=0);1<c.flags?null!==c.lastEffect?(c.lastEffect.nextEffect=c,d=c.firstEffect):d=c:d=c.firstEffect;if(null!==d){e=X;X|=32;pj.current=null;kf=fd;g=Ne();if(Oe(g)){if("selectionStart"in g)h={start:g.selectionStart,end:g.selectionEnd};else a:if(h=(h=g.ownerDocument)&&h.defaultView||window,(l=h.getSelection&&h.getSelection())&&0!==l.rangeCount){h=l.anchorNode;f=l.anchorOffset;k=l.focusNode;l=l.focusOffset;try{h.nodeType,k.nodeType}catch(va){h=null;\nbreak a}var n=0,A=-1,p=-1,C=0,x=0,w=g,z=null;b:for(;;){for(var u;;){w!==h||0!==f&&3!==w.nodeType||(A=n+f);w!==k||0!==l&&3!==w.nodeType||(p=n+l);3===w.nodeType&&(n+=w.nodeValue.length);if(null===(u=w.firstChild))break;z=w;w=u}for(;;){if(w===g)break b;z===h&&++C===f&&(A=n);z===k&&++x===l&&(p=n);if(null!==(u=w.nextSibling))break;w=z;z=w.parentNode}w=u}h=-1===A||-1===p?null:{start:A,end:p}}else h=null;h=h||{start:0,end:0}}else h=null;lf={focusedElem:g,selectionRange:h};fd=!1;Ij=null;Jj=!1;Z=d;do try{ek()}catch(va){if(null===\nZ)throw Error(y(330));Wi(Z,va);Z=Z.nextEffect}while(null!==Z);Ij=null;Z=d;do try{for(g=a;null!==Z;){var t=Z.flags;t&16&&pb(Z.stateNode,"");if(t&128){var q=Z.alternate;if(null!==q){var v=q.ref;null!==v&&("function"===typeof v?v(null):v.current=null)}}switch(t&1038){case 2:fj(Z);Z.flags&=-3;break;case 6:fj(Z);Z.flags&=-3;ij(Z.alternate,Z);break;case 1024:Z.flags&=-1025;break;case 1028:Z.flags&=-1025;ij(Z.alternate,Z);break;case 4:ij(Z.alternate,Z);break;case 8:h=Z;cj(g,h);var J=h.alternate;dj(h);null!==\nJ&&dj(J)}Z=Z.nextEffect}}catch(va){if(null===Z)throw Error(y(330));Wi(Z,va);Z=Z.nextEffect}while(null!==Z);v=lf;q=Ne();t=v.focusedElem;g=v.selectionRange;if(q!==t&&t&&t.ownerDocument&&Me(t.ownerDocument.documentElement,t)){null!==g&&Oe(t)&&(q=g.start,v=g.end,void 0===v&&(v=q),"selectionStart"in t?(t.selectionStart=q,t.selectionEnd=Math.min(v,t.value.length)):(v=(q=t.ownerDocument||document)&&q.defaultView||window,v.getSelection&&(v=v.getSelection(),h=t.textContent.length,J=Math.min(g.start,h),g=void 0===\ng.end?J:Math.min(g.end,h),!v.extend&&J>g&&(h=g,g=J,J=h),h=Le(t,J),f=Le(t,g),h&&f&&(1!==v.rangeCount||v.anchorNode!==h.node||v.anchorOffset!==h.offset||v.focusNode!==f.node||v.focusOffset!==f.offset)&&(q=q.createRange(),q.setStart(h.node,h.offset),v.removeAllRanges(),J>g?(v.addRange(q),v.extend(f.node,f.offset)):(q.setEnd(f.node,f.offset),v.addRange(q))))));q=[];for(v=t;v=v.parentNode;)1===v.nodeType&&q.push({element:v,left:v.scrollLeft,top:v.scrollTop});"function"===typeof t.focus&&t.focus();for(t=\n0;t<q.length;t++)v=q[t],v.element.scrollLeft=v.left,v.element.scrollTop=v.top}fd=!!kf;lf=kf=null;a.current=c;Z=d;do try{for(t=a;null!==Z;){var K=Z.flags;K&36&&Yi(t,Z.alternate,Z);if(K&128){q=void 0;var Q=Z.ref;if(null!==Q){var L=Z.stateNode;switch(Z.tag){case 5:q=L;break;default:q=L}"function"===typeof Q?Q(q):Q.current=q}}Z=Z.nextEffect}}catch(va){if(null===Z)throw Error(y(330));Wi(Z,va);Z=Z.nextEffect}while(null!==Z);Z=null;$f();X=e}else a.current=c;if(xj)xj=!1,yj=a,zj=b;else for(Z=d;null!==Z;)b=\nZ.nextEffect,Z.nextEffect=null,Z.flags&8&&(K=Z,K.sibling=null,K.stateNode=null),Z=b;d=a.pendingLanes;0===d&&(Ti=null);1===d?a===Ej?Dj++:(Dj=0,Ej=a):Dj=0;c=c.stateNode;if(Mf&&"function"===typeof Mf.onCommitFiberRoot)try{Mf.onCommitFiberRoot(Lf,c,void 0,64===(c.current.flags&64))}catch(va){}Mj(a,O());if(Qi)throw Qi=!1,a=Ri,Ri=null,a;if(0!==(X&8))return null;ig();return null}\nfunction ek(){for(;null!==Z;){var a=Z.alternate;Jj||null===Ij||(0!==(Z.flags&8)?dc(Z,Ij)&&(Jj=!0):13===Z.tag&&mj(a,Z)&&dc(Z,Ij)&&(Jj=!0));var b=Z.flags;0!==(b&256)&&Xi(a,Z);0===(b&512)||xj||(xj=!0,hg(97,function(){Oj();return null}));Z=Z.nextEffect}}function Oj(){if(90!==zj){var a=97<zj?97:zj;zj=90;return gg(a,fk)}return!1}function $i(a,b){Aj.push(b,a);xj||(xj=!0,hg(97,function(){Oj();return null}))}function Zi(a,b){Bj.push(b,a);xj||(xj=!0,hg(97,function(){Oj();return null}))}\nfunction fk(){if(null===yj)return!1;var a=yj;yj=null;if(0!==(X&48))throw Error(y(331));var b=X;X|=32;var c=Bj;Bj=[];for(var d=0;d<c.length;d+=2){var e=c[d],f=c[d+1],g=e.destroy;e.destroy=void 0;if("function"===typeof g)try{g()}catch(k){if(null===f)throw Error(y(330));Wi(f,k)}}c=Aj;Aj=[];for(d=0;d<c.length;d+=2){e=c[d];f=c[d+1];try{var h=e.create;e.destroy=h()}catch(k){if(null===f)throw Error(y(330));Wi(f,k)}}for(h=a.current.firstEffect;null!==h;)a=h.nextEffect,h.nextEffect=null,h.flags&8&&(h.sibling=\nnull,h.stateNode=null),h=a;X=b;ig();return!0}function gk(a,b,c){b=Mi(c,b);b=Pi(a,b,1);Ag(a,b);b=Hg();a=Kj(a,1);null!==a&&($c(a,1,b),Mj(a,b))}\nfunction Wi(a,b){if(3===a.tag)gk(a,a,b);else for(var c=a.return;null!==c;){if(3===c.tag){gk(c,a,b);break}else if(1===c.tag){var d=c.stateNode;if("function"===typeof c.type.getDerivedStateFromError||"function"===typeof d.componentDidCatch&&(null===Ti||!Ti.has(d))){a=Mi(b,a);var e=Si(c,a,1);Ag(c,e);e=Hg();c=Kj(c,1);if(null!==c)$c(c,1,e),Mj(c,e);else if("function"===typeof d.componentDidCatch&&(null===Ti||!Ti.has(d)))try{d.componentDidCatch(b,a)}catch(f){}break}}c=c.return}}\nfunction Yj(a,b,c){var d=a.pingCache;null!==d&&d.delete(b);b=Hg();a.pingedLanes|=a.suspendedLanes&c;U===a&&(W&c)===c&&(4===V||3===V&&(W&62914560)===W&&500>O()-jj?Qj(a,0):uj|=c);Mj(a,b)}function lj(a,b){var c=a.stateNode;null!==c&&c.delete(b);b=0;0===b&&(b=a.mode,0===(b&2)?b=1:0===(b&4)?b=99===eg()?1:2:(0===Gj&&(Gj=tj),b=Yc(62914560&~Gj),0===b&&(b=4194304)));c=Hg();a=Kj(a,b);null!==a&&($c(a,b,c),Mj(a,c))}var ck;\nck=function(a,b,c){var d=b.lanes;if(null!==a)if(a.memoizedProps!==b.pendingProps||N.current)ug=!0;else if(0!==(c&d))ug=0!==(a.flags&16384)?!0:!1;else{ug=!1;switch(b.tag){case 3:ri(b);sh();break;case 5:gh(b);break;case 1:Ff(b.type)&&Jf(b);break;case 4:eh(b,b.stateNode.containerInfo);break;case 10:d=b.memoizedProps.value;var e=b.type._context;I(mg,e._currentValue);e._currentValue=d;break;case 13:if(null!==b.memoizedState){if(0!==(c&b.child.childLanes))return ti(a,b,c);I(P,P.current&1);b=hi(a,b,c);return null!==\nb?b.sibling:null}I(P,P.current&1);break;case 19:d=0!==(c&b.childLanes);if(0!==(a.flags&64)){if(d)return Ai(a,b,c);b.flags|=64}e=b.memoizedState;null!==e&&(e.rendering=null,e.tail=null,e.lastEffect=null);I(P,P.current);if(d)break;else return null;case 23:case 24:return b.lanes=0,mi(a,b,c)}return hi(a,b,c)}else ug=!1;b.lanes=0;switch(b.tag){case 2:d=b.type;null!==a&&(a.alternate=null,b.alternate=null,b.flags|=2);a=b.pendingProps;e=Ef(b,M.current);tg(b,c);e=Ch(null,b,d,a,e,c);b.flags|=1;if("object"===\ntypeof e&&null!==e&&"function"===typeof e.render&&void 0===e.$$typeof){b.tag=1;b.memoizedState=null;b.updateQueue=null;if(Ff(d)){var f=!0;Jf(b)}else f=!1;b.memoizedState=null!==e.state&&void 0!==e.state?e.state:null;xg(b);var g=d.getDerivedStateFromProps;"function"===typeof g&&Gg(b,d,g,a);e.updater=Kg;b.stateNode=e;e._reactInternals=b;Og(b,d,a,c);b=qi(null,b,d,!0,f,c)}else b.tag=0,fi(null,b,e,c),b=b.child;return b;case 16:e=b.elementType;a:{null!==a&&(a.alternate=null,b.alternate=null,b.flags|=2);\na=b.pendingProps;f=e._init;e=f(e._payload);b.type=e;f=b.tag=hk(e);a=lg(e,a);switch(f){case 0:b=li(null,b,e,a,c);break a;case 1:b=pi(null,b,e,a,c);break a;case 11:b=gi(null,b,e,a,c);break a;case 14:b=ii(null,b,e,lg(e.type,a),d,c);break a}throw Error(y(306,e,""));}return b;case 0:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:lg(d,e),li(a,b,d,e,c);case 1:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:lg(d,e),pi(a,b,d,e,c);case 3:ri(b);d=b.updateQueue;if(null===a||null===d)throw Error(y(282));\nd=b.pendingProps;e=b.memoizedState;e=null!==e?e.element:null;yg(a,b);Cg(b,d,null,c);d=b.memoizedState.element;if(d===e)sh(),b=hi(a,b,c);else{e=b.stateNode;if(f=e.hydrate)kh=rf(b.stateNode.containerInfo.firstChild),jh=b,f=lh=!0;if(f){a=e.mutableSourceEagerHydrationData;if(null!=a)for(e=0;e<a.length;e+=2)f=a[e],f._workInProgressVersionPrimary=a[e+1],th.push(f);c=Zg(b,null,d,c);for(b.child=c;c;)c.flags=c.flags&-3|1024,c=c.sibling}else fi(a,b,d,c),sh();b=b.child}return b;case 5:return gh(b),null===a&&\nph(b),d=b.type,e=b.pendingProps,f=null!==a?a.memoizedProps:null,g=e.children,nf(d,e)?g=null:null!==f&&nf(d,f)&&(b.flags|=16),oi(a,b),fi(a,b,g,c),b.child;case 6:return null===a&&ph(b),null;case 13:return ti(a,b,c);case 4:return eh(b,b.stateNode.containerInfo),d=b.pendingProps,null===a?b.child=Yg(b,null,d,c):fi(a,b,d,c),b.child;case 11:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:lg(d,e),gi(a,b,d,e,c);case 7:return fi(a,b,b.pendingProps,c),b.child;case 8:return fi(a,b,b.pendingProps.children,\nc),b.child;case 12:return fi(a,b,b.pendingProps.children,c),b.child;case 10:a:{d=b.type._context;e=b.pendingProps;g=b.memoizedProps;f=e.value;var h=b.type._context;I(mg,h._currentValue);h._currentValue=f;if(null!==g)if(h=g.value,f=He(h,f)?0:("function"===typeof d._calculateChangedBits?d._calculateChangedBits(h,f):1073741823)|0,0===f){if(g.children===e.children&&!N.current){b=hi(a,b,c);break a}}else for(h=b.child,null!==h&&(h.return=b);null!==h;){var k=h.dependencies;if(null!==k){g=h.child;for(var l=\nk.firstContext;null!==l;){if(l.context===d&&0!==(l.observedBits&f)){1===h.tag&&(l=zg(-1,c&-c),l.tag=2,Ag(h,l));h.lanes|=c;l=h.alternate;null!==l&&(l.lanes|=c);sg(h.return,c);k.lanes|=c;break}l=l.next}}else g=10===h.tag?h.type===b.type?null:h.child:h.child;if(null!==g)g.return=h;else for(g=h;null!==g;){if(g===b){g=null;break}h=g.sibling;if(null!==h){h.return=g.return;g=h;break}g=g.return}h=g}fi(a,b,e.children,c);b=b.child}return b;case 9:return e=b.type,f=b.pendingProps,d=f.children,tg(b,c),e=vg(e,\nf.unstable_observedBits),d=d(e),b.flags|=1,fi(a,b,d,c),b.child;case 14:return e=b.type,f=lg(e,b.pendingProps),f=lg(e.type,f),ii(a,b,e,f,d,c);case 15:return ki(a,b,b.type,b.pendingProps,d,c);case 17:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:lg(d,e),null!==a&&(a.alternate=null,b.alternate=null,b.flags|=2),b.tag=1,Ff(d)?(a=!0,Jf(b)):a=!1,tg(b,c),Mg(b,d,e),Og(b,d,e,c),qi(null,b,d,!0,a,c);case 19:return Ai(a,b,c);case 23:return mi(a,b,c);case 24:return mi(a,b,c)}throw Error(y(156,b.tag));\n};function ik(a,b,c,d){this.tag=a;this.key=c;this.sibling=this.child=this.return=this.stateNode=this.type=this.elementType=null;this.index=0;this.ref=null;this.pendingProps=b;this.dependencies=this.memoizedState=this.updateQueue=this.memoizedProps=null;this.mode=d;this.flags=0;this.lastEffect=this.firstEffect=this.nextEffect=null;this.childLanes=this.lanes=0;this.alternate=null}function nh(a,b,c,d){return new ik(a,b,c,d)}function ji(a){a=a.prototype;return!(!a||!a.isReactComponent)}\nfunction hk(a){if("function"===typeof a)return ji(a)?1:0;if(void 0!==a&&null!==a){a=a.$$typeof;if(a===Aa)return 11;if(a===Da)return 14}return 2}\nfunction Tg(a,b){var c=a.alternate;null===c?(c=nh(a.tag,b,a.key,a.mode),c.elementType=a.elementType,c.type=a.type,c.stateNode=a.stateNode,c.alternate=a,a.alternate=c):(c.pendingProps=b,c.type=a.type,c.flags=0,c.nextEffect=null,c.firstEffect=null,c.lastEffect=null);c.childLanes=a.childLanes;c.lanes=a.lanes;c.child=a.child;c.memoizedProps=a.memoizedProps;c.memoizedState=a.memoizedState;c.updateQueue=a.updateQueue;b=a.dependencies;c.dependencies=null===b?null:{lanes:b.lanes,firstContext:b.firstContext};\nc.sibling=a.sibling;c.index=a.index;c.ref=a.ref;return c}\nfunction Vg(a,b,c,d,e,f){var g=2;d=a;if("function"===typeof a)ji(a)&&(g=1);else if("string"===typeof a)g=5;else a:switch(a){case ua:return Xg(c.children,e,f,b);case Ha:g=8;e|=16;break;case wa:g=8;e|=1;break;case xa:return a=nh(12,c,b,e|8),a.elementType=xa,a.type=xa,a.lanes=f,a;case Ba:return a=nh(13,c,b,e),a.type=Ba,a.elementType=Ba,a.lanes=f,a;case Ca:return a=nh(19,c,b,e),a.elementType=Ca,a.lanes=f,a;case Ia:return vi(c,e,f,b);case Ja:return a=nh(24,c,b,e),a.elementType=Ja,a.lanes=f,a;default:if("object"===\ntypeof a&&null!==a)switch(a.$$typeof){case ya:g=10;break a;case za:g=9;break a;case Aa:g=11;break a;case Da:g=14;break a;case Ea:g=16;d=null;break a;case Fa:g=22;break a}throw Error(y(130,null==a?a:typeof a,""));}b=nh(g,c,b,e);b.elementType=a;b.type=d;b.lanes=f;return b}function Xg(a,b,c,d){a=nh(7,a,d,b);a.lanes=c;return a}function vi(a,b,c,d){a=nh(23,a,d,b);a.elementType=Ia;a.lanes=c;return a}function Ug(a,b,c){a=nh(6,a,null,b);a.lanes=c;return a}\nfunction Wg(a,b,c){b=nh(4,null!==a.children?a.children:[],a.key,b);b.lanes=c;b.stateNode={containerInfo:a.containerInfo,pendingChildren:null,implementation:a.implementation};return b}\nfunction jk(a,b,c){this.tag=b;this.containerInfo=a;this.finishedWork=this.pingCache=this.current=this.pendingChildren=null;this.timeoutHandle=-1;this.pendingContext=this.context=null;this.hydrate=c;this.callbackNode=null;this.callbackPriority=0;this.eventTimes=Zc(0);this.expirationTimes=Zc(-1);this.entangledLanes=this.finishedLanes=this.mutableReadLanes=this.expiredLanes=this.pingedLanes=this.suspendedLanes=this.pendingLanes=0;this.entanglements=Zc(0);this.mutableSourceEagerHydrationData=null}\nfunction kk(a,b,c){var d=3<arguments.length&&void 0!==arguments[3]?arguments[3]:null;return{$$typeof:ta,key:null==d?null:""+d,children:a,containerInfo:b,implementation:c}}\nfunction lk(a,b,c,d){var e=b.current,f=Hg(),g=Ig(e);a:if(c){c=c._reactInternals;b:{if(Zb(c)!==c||1!==c.tag)throw Error(y(170));var h=c;do{switch(h.tag){case 3:h=h.stateNode.context;break b;case 1:if(Ff(h.type)){h=h.stateNode.__reactInternalMemoizedMergedChildContext;break b}}h=h.return}while(null!==h);throw Error(y(171));}if(1===c.tag){var k=c.type;if(Ff(k)){c=If(c,k,h);break a}}c=h}else c=Cf;null===b.context?b.context=c:b.pendingContext=c;b=zg(f,g);b.payload={element:a};d=void 0===d?null:d;null!==\nd&&(b.callback=d);Ag(e,b);Jg(e,g,f);return g}function mk(a){a=a.current;if(!a.child)return null;switch(a.child.tag){case 5:return a.child.stateNode;default:return a.child.stateNode}}function nk(a,b){a=a.memoizedState;if(null!==a&&null!==a.dehydrated){var c=a.retryLane;a.retryLane=0!==c&&c<b?c:b}}function ok(a,b){nk(a,b);(a=a.alternate)&&nk(a,b)}function pk(){return null}\nfunction qk(a,b,c){var d=null!=c&&null!=c.hydrationOptions&&c.hydrationOptions.mutableSources||null;c=new jk(a,b,null!=c&&!0===c.hydrate);b=nh(3,null,null,2===b?7:1===b?3:0);c.current=b;b.stateNode=c;xg(b);a[ff]=c.current;cf(8===a.nodeType?a.parentNode:a);if(d)for(a=0;a<d.length;a++){b=d[a];var e=b._getVersion;e=e(b._source);null==c.mutableSourceEagerHydrationData?c.mutableSourceEagerHydrationData=[b,e]:c.mutableSourceEagerHydrationData.push(b,e)}this._internalRoot=c}\nqk.prototype.render=function(a){lk(a,this._internalRoot,null,null)};qk.prototype.unmount=function(){var a=this._internalRoot,b=a.containerInfo;lk(null,a,null,function(){b[ff]=null})};function rk(a){return!(!a||1!==a.nodeType&&9!==a.nodeType&&11!==a.nodeType&&(8!==a.nodeType||" react-mount-point-unstable "!==a.nodeValue))}\nfunction sk(a,b){b||(b=a?9===a.nodeType?a.documentElement:a.firstChild:null,b=!(!b||1!==b.nodeType||!b.hasAttribute("data-reactroot")));if(!b)for(var c;c=a.lastChild;)a.removeChild(c);return new qk(a,0,b?{hydrate:!0}:void 0)}\nfunction tk(a,b,c,d,e){var f=c._reactRootContainer;if(f){var g=f._internalRoot;if("function"===typeof e){var h=e;e=function(){var a=mk(g);h.call(a)}}lk(b,g,a,e)}else{f=c._reactRootContainer=sk(c,d);g=f._internalRoot;if("function"===typeof e){var k=e;e=function(){var a=mk(g);k.call(a)}}Xj(function(){lk(b,g,a,e)})}return mk(g)}ec=function(a){if(13===a.tag){var b=Hg();Jg(a,4,b);ok(a,4)}};fc=function(a){if(13===a.tag){var b=Hg();Jg(a,67108864,b);ok(a,67108864)}};\ngc=function(a){if(13===a.tag){var b=Hg(),c=Ig(a);Jg(a,c,b);ok(a,c)}};hc=function(a,b){return b()};\nyb=function(a,b,c){switch(b){case "input":ab(a,c);b=c.name;if("radio"===c.type&&null!=b){for(c=a;c.parentNode;)c=c.parentNode;c=c.querySelectorAll("input[name="+JSON.stringify(""+b)+\'][type="radio"]\');for(b=0;b<c.length;b++){var d=c[b];if(d!==a&&d.form===a.form){var e=Db(d);if(!e)throw Error(y(90));Wa(d);ab(d,e)}}}break;case "textarea":ib(a,c);break;case "select":b=c.value,null!=b&&fb(a,!!c.multiple,b,!1)}};Gb=Wj;\nHb=function(a,b,c,d,e){var f=X;X|=4;try{return gg(98,a.bind(null,b,c,d,e))}finally{X=f,0===X&&(wj(),ig())}};Ib=function(){0===(X&49)&&(Vj(),Oj())};Jb=function(a,b){var c=X;X|=2;try{return a(b)}finally{X=c,0===X&&(wj(),ig())}};function uk(a,b){var c=2<arguments.length&&void 0!==arguments[2]?arguments[2]:null;if(!rk(b))throw Error(y(200));return kk(a,b,null,c)}var vk={Events:[Cb,ue,Db,Eb,Fb,Oj,{current:!1}]},wk={findFiberByHostInstance:wc,bundleType:0,version:"17.0.2",rendererPackageName:"react-dom"};\nvar xk={bundleType:wk.bundleType,version:wk.version,rendererPackageName:wk.rendererPackageName,rendererConfig:wk.rendererConfig,overrideHookState:null,overrideHookStateDeletePath:null,overrideHookStateRenamePath:null,overrideProps:null,overridePropsDeletePath:null,overridePropsRenamePath:null,setSuspenseHandler:null,scheduleUpdate:null,currentDispatcherRef:ra.ReactCurrentDispatcher,findHostInstanceByFiber:function(a){a=cc(a);return null===a?null:a.stateNode},findFiberByHostInstance:wk.findFiberByHostInstance||\npk,findHostInstancesForRefresh:null,scheduleRefresh:null,scheduleRoot:null,setRefreshHandler:null,getCurrentFiber:null};if("undefined"!==typeof __REACT_DEVTOOLS_GLOBAL_HOOK__){var yk=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(!yk.isDisabled&&yk.supportsFiber)try{Lf=yk.inject(xk),Mf=yk}catch(a){}}exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=vk;exports.createPortal=uk;\nexports.findDOMNode=function(a){if(null==a)return null;if(1===a.nodeType)return a;var b=a._reactInternals;if(void 0===b){if("function"===typeof a.render)throw Error(y(188));throw Error(y(268,Object.keys(a)));}a=cc(b);a=null===a?null:a.stateNode;return a};exports.flushSync=function(a,b){var c=X;if(0!==(c&48))return a(b);X|=1;try{if(a)return gg(99,a.bind(null,b))}finally{X=c,ig()}};exports.hydrate=function(a,b,c){if(!rk(b))throw Error(y(200));return tk(null,a,b,!0,c)};\nexports.render=function(a,b,c){if(!rk(b))throw Error(y(200));return tk(null,a,b,!1,c)};exports.unmountComponentAtNode=function(a){if(!rk(a))throw Error(y(40));return a._reactRootContainer?(Xj(function(){tk(null,null,a,!1,function(){a._reactRootContainer=null;a[ff]=null})}),!0):!1};exports.unstable_batchedUpdates=Wj;exports.unstable_createPortal=function(a,b){return uk(a,b,2<arguments.length&&void 0!==arguments[2]?arguments[2]:null)};\nexports.unstable_renderSubtreeIntoContainer=function(a,b,c,d){if(!rk(c))throw Error(y(200));if(null==a||void 0===a._reactInternals)throw Error(y(38));return tk(a,b,c,!1,d)};exports.version="17.0.2";\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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cy9yZWFjdC1kb20vY2pzL3JlYWN0LWRvbS5wcm9kdWN0aW9uLm1pbi5qcz9jYTVkIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKiBAbGljZW5zZSBSZWFjdCB2MTcuMC4yXG4gKiByZWFjdC1kb20ucHJvZHVjdGlvbi5taW4uanNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuLypcbiBNb2Rlcm5penIgMy4wLjBwcmUgKEN1c3RvbSBCdWlsZCkgfCBNSVRcbiovXG4ndXNlIHN0cmljdCc7dmFyIGFhPXJlcXVpcmUoXCJyZWFjdFwiKSxtPXJlcXVpcmUoXCJvYmplY3QtYXNzaWduXCIpLHI9cmVxdWlyZShcInNjaGVkdWxlclwiKTtmdW5jdGlvbiB5KGEpe2Zvcih2YXIgYj1cImh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9lcnJvci1kZWNvZGVyLmh0bWw/aW52YXJpYW50PVwiK2EsYz0xO2M8YXJndW1lbnRzLmxlbmd0aDtjKyspYis9XCImYXJnc1tdPVwiK2VuY29kZVVSSUNvbXBvbmVudChhcmd1bWVudHNbY10pO3JldHVyblwiTWluaWZpZWQgUmVhY3QgZXJyb3IgI1wiK2ErXCI7IHZpc2l0IFwiK2IrXCIgZm9yIHRoZSBmdWxsIG1lc3NhZ2Ugb3IgdXNlIHRoZSBub24tbWluaWZpZWQgZGV2IGVudmlyb25tZW50IGZvciBmdWxsIGVycm9ycyBhbmQgYWRkaXRpb25hbCBoZWxwZnVsIHdhcm5pbmdzLlwifWlmKCFhYSl0aHJvdyBFcnJvcih5KDIyNykpO3ZhciBiYT1uZXcgU2V0LGNhPXt9O2Z1bmN0aW9uIGRhKGEsYil7ZWEoYSxiKTtlYShhK1wiQ2FwdHVyZVwiLGIpfVxuZnVuY3Rpb24gZWEoYSxiKXtjYVthXT1iO2ZvcihhPTA7YTxiLmxlbmd0aDthKyspYmEuYWRkKGJbYV0pfVxudmFyIGZhPSEoXCJ1bmRlZmluZWRcIj09PXR5cGVvZiB3aW5kb3d8fFwidW5kZWZpbmVkXCI9PT10eXBlb2Ygd2luZG93LmRvY3VtZW50fHxcInVuZGVmaW5lZFwiPT09dHlwZW9mIHdpbmRvdy5kb2N1bWVudC5jcmVhdGVFbGVtZW50KSxoYT0vXls6QS1aX2EtelxcdTAwQzAtXFx1MDBENlxcdTAwRDgtXFx1MDBGNlxcdTAwRjgtXFx1MDJGRlxcdTAzNzAtXFx1MDM3RFxcdTAzN0YtXFx1MUZGRlxcdTIwMEMtXFx1MjAwRFxcdTIwNzAtXFx1MjE4RlxcdTJDMDAtXFx1MkZFRlxcdTMwMDEtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZGRF1bOkEtWl9hLXpcXHUwMEMwLVxcdTAwRDZcXHUwMEQ4LVxcdTAwRjZcXHUwMEY4LVxcdTAyRkZcXHUwMzcwLVxcdTAzN0RcXHUwMzdGLVxcdTFGRkZcXHUyMDBDLVxcdTIwMERcXHUyMDcwLVxcdTIxOEZcXHUyQzAwLVxcdTJGRUZcXHUzMDAxLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRkRcXC0uMC05XFx1MDBCN1xcdTAzMDAtXFx1MDM2RlxcdTIwM0YtXFx1MjA0MF0qJC8saWE9T2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSxcbmphPXt9LGthPXt9O2Z1bmN0aW9uIGxhKGEpe2lmKGlhLmNhbGwoa2EsYSkpcmV0dXJuITA7aWYoaWEuY2FsbChqYSxhKSlyZXR1cm4hMTtpZihoYS50ZXN0KGEpKXJldHVybiBrYVthXT0hMDtqYVthXT0hMDtyZXR1cm4hMX1mdW5jdGlvbiBtYShhLGIsYyxkKXtpZihudWxsIT09YyYmMD09PWMudHlwZSlyZXR1cm4hMTtzd2l0Y2godHlwZW9mIGIpe2Nhc2UgXCJmdW5jdGlvblwiOmNhc2UgXCJzeW1ib2xcIjpyZXR1cm4hMDtjYXNlIFwiYm9vbGVhblwiOmlmKGQpcmV0dXJuITE7aWYobnVsbCE9PWMpcmV0dXJuIWMuYWNjZXB0c0Jvb2xlYW5zO2E9YS50b0xvd2VyQ2FzZSgpLnNsaWNlKDAsNSk7cmV0dXJuXCJkYXRhLVwiIT09YSYmXCJhcmlhLVwiIT09YTtkZWZhdWx0OnJldHVybiExfX1cbmZ1bmN0aW9uIG5hKGEsYixjLGQpe2lmKG51bGw9PT1ifHxcInVuZGVmaW5lZFwiPT09dHlwZW9mIGJ8fG1hKGEsYixjLGQpKXJldHVybiEwO2lmKGQpcmV0dXJuITE7aWYobnVsbCE9PWMpc3dpdGNoKGMudHlwZSl7Y2FzZSAzOnJldHVybiFiO2Nhc2UgNDpyZXR1cm4hMT09PWI7Y2FzZSA1OnJldHVybiBpc05hTihiKTtjYXNlIDY6cmV0dXJuIGlzTmFOKGIpfHwxPmJ9cmV0dXJuITF9ZnVuY3Rpb24gQihhLGIsYyxkLGUsZixnKXt0aGlzLmFjY2VwdHNCb29sZWFucz0yPT09Ynx8Mz09PWJ8fDQ9PT1iO3RoaXMuYXR0cmlidXRlTmFtZT1kO3RoaXMuYXR0cmlidXRlTmFtZXNwYWNlPWU7dGhpcy5tdXN0VXNlUHJvcGVydHk9Yzt0aGlzLnByb3BlcnR5TmFtZT1hO3RoaXMudHlwZT1iO3RoaXMuc2FuaXRpemVVUkw9Zjt0aGlzLnJlbW92ZUVtcHR5U3RyaW5nPWd9dmFyIEQ9e307XG5cImNoaWxkcmVuIGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MIGRlZmF1bHRWYWx1ZSBkZWZhdWx0Q2hlY2tlZCBpbm5lckhUTUwgc3VwcHJlc3NDb250ZW50RWRpdGFibGVXYXJuaW5nIHN1cHByZXNzSHlkcmF0aW9uV2FybmluZyBzdHlsZVwiLnNwbGl0KFwiIFwiKS5mb3JFYWNoKGZ1bmN0aW9uKGEpe0RbYV09bmV3IEIoYSwwLCExLGEsbnVsbCwhMSwhMSl9KTtbW1wiYWNjZXB0Q2hhcnNldFwiLFwiYWNjZXB0LWNoYXJzZXRcIl0sW1wiY2xhc3NOYW1lXCIsXCJjbGFzc1wiXSxbXCJodG1sRm9yXCIsXCJmb3JcIl0sW1wiaHR0cEVxdWl2XCIsXCJodHRwLWVxdWl2XCJdXS5mb3JFYWNoKGZ1bmN0aW9uKGEpe3ZhciBiPWFbMF07RFtiXT1uZXcgQihiLDEsITEsYVsxXSxudWxsLCExLCExKX0pO1tcImNvbnRlbnRFZGl0YWJsZVwiLFwiZHJhZ2dhYmxlXCIsXCJzcGVsbENoZWNrXCIsXCJ2YWx1ZVwiXS5mb3JFYWNoKGZ1bmN0aW9uKGEpe0RbYV09bmV3IEIoYSwyLCExLGEudG9Mb3dlckNhc2UoKSxudWxsLCExLCExKX0pO1xuW1wiYXV0b1JldmVyc2VcIixcImV4dGVybmFsUmVzb3VyY2VzUmVxdWlyZWRcIixcImZvY3VzYWJsZVwiLFwicHJlc2VydmVBbHBoYVwiXS5mb3JFYWNoKGZ1bmN0aW9uKGEpe0RbYV09bmV3IEIoYSwyLCExLGEsbnVsbCwhMSwhMSl9KTtcImFsbG93RnVsbFNjcmVlbiBhc3luYyBhdXRvRm9jdXMgYXV0b1BsYXkgY29udHJvbHMgZGVmYXVsdCBkZWZlciBkaXNhYmxlZCBkaXNhYmxlUGljdHVyZUluUGljdHVyZSBkaXNhYmxlUmVtb3RlUGxheWJhY2sgZm9ybU5vVmFsaWRhdGUgaGlkZGVuIGxvb3Agbm9Nb2R1bGUgbm9WYWxpZGF0ZSBvcGVuIHBsYXlzSW5saW5lIHJlYWRPbmx5IHJlcXVpcmVkIHJldmVyc2VkIHNjb3BlZCBzZWFtbGVzcyBpdGVtU2NvcGVcIi5zcGxpdChcIiBcIikuZm9yRWFjaChmdW5jdGlvbihhKXtEW2FdPW5ldyBCKGEsMywhMSxhLnRvTG93ZXJDYXNlKCksbnVsbCwhMSwhMSl9KTtcbltcImNoZWNrZWRcIixcIm11bHRpcGxlXCIsXCJtdXRlZFwiLFwic2VsZWN0ZWRcIl0uZm9yRWFjaChmdW5jdGlvbihhKXtEW2FdPW5ldyBCKGEsMywhMCxhLG51bGwsITEsITEpfSk7W1wiY2FwdHVyZVwiLFwiZG93bmxvYWRcIl0uZm9yRWFjaChmdW5jdGlvbihhKXtEW2FdPW5ldyBCKGEsNCwhMSxhLG51bGwsITEsITEpfSk7W1wiY29sc1wiLFwicm93c1wiLFwic2l6ZVwiLFwic3BhblwiXS5mb3JFYWNoKGZ1bmN0aW9uKGEpe0RbYV09bmV3IEIoYSw2LCExLGEsbnVsbCwhMSwhMSl9KTtbXCJyb3dTcGFuXCIsXCJzdGFydFwiXS5mb3JFYWNoKGZ1bmN0aW9uKGEpe0RbYV09bmV3IEIoYSw1LCExLGEudG9Mb3dlckNhc2UoKSxudWxsLCExLCExKX0pO3ZhciBvYT0vW1xcLTpdKFthLXpdKS9nO2Z1bmN0aW9uIHBhKGEpe3JldHVybiBhWzFdLnRvVXBwZXJDYXNlKCl9XG5cImFjY2VudC1oZWlnaHQgYWxpZ25tZW50LWJhc2VsaW5lIGFyYWJpYy1mb3JtIGJhc2VsaW5lLXNoaWZ0IGNhcC1oZWlnaHQgY2xpcC1wYXRoIGNsaXAtcnVsZSBjb2xvci1pbnRlcnBvbGF0aW9uIGNvbG9yLWludGVycG9sYXRpb24tZmlsdGVycyBjb2xvci1wcm9maWxlIGNvbG9yLXJlbmRlcmluZyBkb21pbmFudC1iYXNlbGluZSBlbmFibGUtYmFja2dyb3VuZCBmaWxsLW9wYWNpdHkgZmlsbC1ydWxlIGZsb29kLWNvbG9yIGZsb29kLW9wYWNpdHkgZm9udC1mYW1pbHkgZm9udC1zaXplIGZvbnQtc2l6ZS1hZGp1c3QgZm9udC1zdHJldGNoIGZvbnQtc3R5bGUgZm9udC12YXJpYW50IGZvbnQtd2VpZ2h0IGdseXBoLW5hbWUgZ2x5cGgtb3JpZW50YXRpb24taG9yaXpvbnRhbCBnbHlwaC1vcmllbnRhdGlvbi12ZXJ0aWNhbCBob3Jpei1hZHYteCBob3Jpei1vcmlnaW4teCBpbWFnZS1yZW5kZXJpbmcgbGV0dGVyLXNwYWNpbmcgbGlnaHRpbmctY29sb3IgbWFya2VyLWVuZCBtYXJrZXItbWlkIG1hcmtlci1zdGFydCBvdmVybGluZS1wb3NpdGlvbiBvdmVybGluZS10aGlja25lc3MgcGFpbnQtb3JkZXIgcGFub3NlLTEgcG9pbnRlci1ldmVudHMgcmVuZGVyaW5nLWludGVudCBzaGFwZS1yZW5kZXJpbmcgc3RvcC1jb2xvciBzdG9wLW9wYWNpdHkgc3RyaWtldGhyb3VnaC1wb3NpdGlvbiBzdHJpa2V0aHJvdWdoLXRoaWNrbmVzcyBzdHJva2UtZGFzaGFycmF5IHN0cm9rZS1kYXNob2Zmc2V0IHN0cm9rZS1saW5lY2FwIHN0cm9rZS1saW5lam9pbiBzdHJva2UtbWl0ZXJsaW1pdCBzdHJva2Utb3BhY2l0eSBzdHJva2Utd2lkdGggdGV4dC1hbmNob3IgdGV4dC1kZWNvcmF0aW9uIHRleHQtcmVuZGVyaW5nIHVuZGVybGluZS1wb3NpdGlvbiB1bmRlcmxpbmUtdGhpY2tuZXNzIHVuaWNvZGUtYmlkaSB1bmljb2RlLXJhbmdlIHVuaXRzLXBlci1lbSB2LWFscGhhYmV0aWMgdi1oYW5naW5nIHYtaWRlb2dyYXBoaWMgdi1tYXRoZW1hdGljYWwgdmVjdG9yLWVmZmVjdCB2ZXJ0LWFkdi15IHZlcnQtb3JpZ2luLXggdmVydC1vcmlnaW4teSB3b3JkLXNwYWNpbmcgd3JpdGluZy1tb2RlIHhtbG5zOnhsaW5rIHgtaGVpZ2h0XCIuc3BsaXQoXCIgXCIpLmZvckVhY2goZnVuY3Rpb24oYSl7dmFyIGI9YS5yZXBsYWNlKG9hLFxucGEpO0RbYl09bmV3IEIoYiwxLCExLGEsbnVsbCwhMSwhMSl9KTtcInhsaW5rOmFjdHVhdGUgeGxpbms6YXJjcm9sZSB4bGluazpyb2xlIHhsaW5rOnNob3cgeGxpbms6dGl0bGUgeGxpbms6dHlwZVwiLnNwbGl0KFwiIFwiKS5mb3JFYWNoKGZ1bmN0aW9uKGEpe3ZhciBiPWEucmVwbGFjZShvYSxwYSk7RFtiXT1uZXcgQihiLDEsITEsYSxcImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmtcIiwhMSwhMSl9KTtbXCJ4bWw6YmFzZVwiLFwieG1sOmxhbmdcIixcInhtbDpzcGFjZVwiXS5mb3JFYWNoKGZ1bmN0aW9uKGEpe3ZhciBiPWEucmVwbGFjZShvYSxwYSk7RFtiXT1uZXcgQihiLDEsITEsYSxcImh0dHA6Ly93d3cudzMub3JnL1hNTC8xOTk4L25hbWVzcGFjZVwiLCExLCExKX0pO1tcInRhYkluZGV4XCIsXCJjcm9zc09yaWdpblwiXS5mb3JFYWNoKGZ1bmN0aW9uKGEpe0RbYV09bmV3IEIoYSwxLCExLGEudG9Mb3dlckNhc2UoKSxudWxsLCExLCExKX0pO1xuRC54bGlua0hyZWY9bmV3IEIoXCJ4bGlua0hyZWZcIiwxLCExLFwieGxpbms6aHJlZlwiLFwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGlua1wiLCEwLCExKTtbXCJzcmNcIixcImhyZWZcIixcImFjdGlvblwiLFwiZm9ybUFjdGlvblwiXS5mb3JFYWNoKGZ1bmN0aW9uKGEpe0RbYV09bmV3IEIoYSwxLCExLGEudG9Mb3dlckNhc2UoKSxudWxsLCEwLCEwKX0pO1xuZnVuY3Rpb24gcWEoYSxiLGMsZCl7dmFyIGU9RC5oYXNPd25Qcm9wZXJ0eShiKT9EW2JdOm51bGw7dmFyIGY9bnVsbCE9PWU/MD09PWUudHlwZTpkPyExOiEoMjxiLmxlbmd0aCl8fFwib1wiIT09YlswXSYmXCJPXCIhPT1iWzBdfHxcIm5cIiE9PWJbMV0mJlwiTlwiIT09YlsxXT8hMTohMDtmfHwobmEoYixjLGUsZCkmJihjPW51bGwpLGR8fG51bGw9PT1lP2xhKGIpJiYobnVsbD09PWM/YS5yZW1vdmVBdHRyaWJ1dGUoYik6YS5zZXRBdHRyaWJ1dGUoYixcIlwiK2MpKTplLm11c3RVc2VQcm9wZXJ0eT9hW2UucHJvcGVydHlOYW1lXT1udWxsPT09Yz8zPT09ZS50eXBlPyExOlwiXCI6YzooYj1lLmF0dHJpYnV0ZU5hbWUsZD1lLmF0dHJpYnV0ZU5hbWVzcGFjZSxudWxsPT09Yz9hLnJlbW92ZUF0dHJpYnV0ZShiKTooZT1lLnR5cGUsYz0zPT09ZXx8ND09PWUmJiEwPT09Yz9cIlwiOlwiXCIrYyxkP2Euc2V0QXR0cmlidXRlTlMoZCxiLGMpOmEuc2V0QXR0cmlidXRlKGIsYykpKSl9XG52YXIgcmE9YWEuX19TRUNSRVRfSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfWU9VX1dJTExfQkVfRklSRUQsc2E9NjAxMDMsdGE9NjAxMDYsdWE9NjAxMDcsd2E9NjAxMDgseGE9NjAxMTQseWE9NjAxMDksemE9NjAxMTAsQWE9NjAxMTIsQmE9NjAxMTMsQ2E9NjAxMjAsRGE9NjAxMTUsRWE9NjAxMTYsRmE9NjAxMjEsR2E9NjAxMjgsSGE9NjAxMjksSWE9NjAxMzAsSmE9NjAxMzE7XG5pZihcImZ1bmN0aW9uXCI9PT10eXBlb2YgU3ltYm9sJiZTeW1ib2wuZm9yKXt2YXIgRT1TeW1ib2wuZm9yO3NhPUUoXCJyZWFjdC5lbGVtZW50XCIpO3RhPUUoXCJyZWFjdC5wb3J0YWxcIik7dWE9RShcInJlYWN0LmZyYWdtZW50XCIpO3dhPUUoXCJyZWFjdC5zdHJpY3RfbW9kZVwiKTt4YT1FKFwicmVhY3QucHJvZmlsZXJcIik7eWE9RShcInJlYWN0LnByb3ZpZGVyXCIpO3phPUUoXCJyZWFjdC5jb250ZXh0XCIpO0FhPUUoXCJyZWFjdC5mb3J3YXJkX3JlZlwiKTtCYT1FKFwicmVhY3Quc3VzcGVuc2VcIik7Q2E9RShcInJlYWN0LnN1c3BlbnNlX2xpc3RcIik7RGE9RShcInJlYWN0Lm1lbW9cIik7RWE9RShcInJlYWN0LmxhenlcIik7RmE9RShcInJlYWN0LmJsb2NrXCIpO0UoXCJyZWFjdC5zY29wZVwiKTtHYT1FKFwicmVhY3Qub3BhcXVlLmlkXCIpO0hhPUUoXCJyZWFjdC5kZWJ1Z190cmFjZV9tb2RlXCIpO0lhPUUoXCJyZWFjdC5vZmZzY3JlZW5cIik7SmE9RShcInJlYWN0LmxlZ2FjeV9oaWRkZW5cIil9XG52YXIgS2E9XCJmdW5jdGlvblwiPT09dHlwZW9mIFN5bWJvbCYmU3ltYm9sLml0ZXJhdG9yO2Z1bmN0aW9uIExhKGEpe2lmKG51bGw9PT1hfHxcIm9iamVjdFwiIT09dHlwZW9mIGEpcmV0dXJuIG51bGw7YT1LYSYmYVtLYV18fGFbXCJAQGl0ZXJhdG9yXCJdO3JldHVyblwiZnVuY3Rpb25cIj09PXR5cGVvZiBhP2E6bnVsbH12YXIgTWE7ZnVuY3Rpb24gTmEoYSl7aWYodm9pZCAwPT09TWEpdHJ5e3Rocm93IEVycm9yKCk7fWNhdGNoKGMpe3ZhciBiPWMuc3RhY2sudHJpbSgpLm1hdGNoKC9cXG4oICooYXQgKT8pLyk7TWE9YiYmYlsxXXx8XCJcIn1yZXR1cm5cIlxcblwiK01hK2F9dmFyIE9hPSExO1xuZnVuY3Rpb24gUGEoYSxiKXtpZighYXx8T2EpcmV0dXJuXCJcIjtPYT0hMDt2YXIgYz1FcnJvci5wcmVwYXJlU3RhY2tUcmFjZTtFcnJvci5wcmVwYXJlU3RhY2tUcmFjZT12b2lkIDA7dHJ5e2lmKGIpaWYoYj1mdW5jdGlvbigpe3Rocm93IEVycm9yKCk7fSxPYmplY3QuZGVmaW5lUHJvcGVydHkoYi5wcm90b3R5cGUsXCJwcm9wc1wiLHtzZXQ6ZnVuY3Rpb24oKXt0aHJvdyBFcnJvcigpO319KSxcIm9iamVjdFwiPT09dHlwZW9mIFJlZmxlY3QmJlJlZmxlY3QuY29uc3RydWN0KXt0cnl7UmVmbGVjdC5jb25zdHJ1Y3QoYixbXSl9Y2F0Y2goayl7dmFyIGQ9a31SZWZsZWN0LmNvbnN0cnVjdChhLFtdLGIpfWVsc2V7dHJ5e2IuY2FsbCgpfWNhdGNoKGspe2Q9a31hLmNhbGwoYi5wcm90b3R5cGUpfWVsc2V7dHJ5e3Rocm93IEVycm9yKCk7fWNhdGNoKGspe2Q9a31hKCl9fWNhdGNoKGspe2lmKGsmJmQmJlwic3RyaW5nXCI9PT10eXBlb2Ygay5zdGFjayl7Zm9yKHZhciBlPWsuc3RhY2suc3BsaXQoXCJcXG5cIiksXG5mPWQuc3RhY2suc3BsaXQoXCJcXG5cIiksZz1lLmxlbmd0aC0xLGg9Zi5sZW5ndGgtMTsxPD1nJiYwPD1oJiZlW2ddIT09ZltoXTspaC0tO2Zvcig7MTw9ZyYmMDw9aDtnLS0saC0tKWlmKGVbZ10hPT1mW2hdKXtpZigxIT09Z3x8MSE9PWgpe2RvIGlmKGctLSxoLS0sMD5ofHxlW2ddIT09ZltoXSlyZXR1cm5cIlxcblwiK2VbZ10ucmVwbGFjZShcIiBhdCBuZXcgXCIsXCIgYXQgXCIpO3doaWxlKDE8PWcmJjA8PWgpfWJyZWFrfX19ZmluYWxseXtPYT0hMSxFcnJvci5wcmVwYXJlU3RhY2tUcmFjZT1jfXJldHVybihhPWE/YS5kaXNwbGF5TmFtZXx8YS5uYW1lOlwiXCIpP05hKGEpOlwiXCJ9XG5mdW5jdGlvbiBRYShhKXtzd2l0Y2goYS50YWcpe2Nhc2UgNTpyZXR1cm4gTmEoYS50eXBlKTtjYXNlIDE2OnJldHVybiBOYShcIkxhenlcIik7Y2FzZSAxMzpyZXR1cm4gTmEoXCJTdXNwZW5zZVwiKTtjYXNlIDE5OnJldHVybiBOYShcIlN1c3BlbnNlTGlzdFwiKTtjYXNlIDA6Y2FzZSAyOmNhc2UgMTU6cmV0dXJuIGE9UGEoYS50eXBlLCExKSxhO2Nhc2UgMTE6cmV0dXJuIGE9UGEoYS50eXBlLnJlbmRlciwhMSksYTtjYXNlIDIyOnJldHVybiBhPVBhKGEudHlwZS5fcmVuZGVyLCExKSxhO2Nhc2UgMTpyZXR1cm4gYT1QYShhLnR5cGUsITApLGE7ZGVmYXVsdDpyZXR1cm5cIlwifX1cbmZ1bmN0aW9uIFJhKGEpe2lmKG51bGw9PWEpcmV0dXJuIG51bGw7aWYoXCJmdW5jdGlvblwiPT09dHlwZW9mIGEpcmV0dXJuIGEuZGlzcGxheU5hbWV8fGEubmFtZXx8bnVsbDtpZihcInN0cmluZ1wiPT09dHlwZW9mIGEpcmV0dXJuIGE7c3dpdGNoKGEpe2Nhc2UgdWE6cmV0dXJuXCJGcmFnbWVudFwiO2Nhc2UgdGE6cmV0dXJuXCJQb3J0YWxcIjtjYXNlIHhhOnJldHVyblwiUHJvZmlsZXJcIjtjYXNlIHdhOnJldHVyblwiU3RyaWN0TW9kZVwiO2Nhc2UgQmE6cmV0dXJuXCJTdXNwZW5zZVwiO2Nhc2UgQ2E6cmV0dXJuXCJTdXNwZW5zZUxpc3RcIn1pZihcIm9iamVjdFwiPT09dHlwZW9mIGEpc3dpdGNoKGEuJCR0eXBlb2Ype2Nhc2UgemE6cmV0dXJuKGEuZGlzcGxheU5hbWV8fFwiQ29udGV4dFwiKStcIi5Db25zdW1lclwiO2Nhc2UgeWE6cmV0dXJuKGEuX2NvbnRleHQuZGlzcGxheU5hbWV8fFwiQ29udGV4dFwiKStcIi5Qcm92aWRlclwiO2Nhc2UgQWE6dmFyIGI9YS5yZW5kZXI7Yj1iLmRpc3BsYXlOYW1lfHxiLm5hbWV8fFwiXCI7XG5yZXR1cm4gYS5kaXNwbGF5TmFtZXx8KFwiXCIhPT1iP1wiRm9yd2FyZFJlZihcIitiK1wiKVwiOlwiRm9yd2FyZFJlZlwiKTtjYXNlIERhOnJldHVybiBSYShhLnR5cGUpO2Nhc2UgRmE6cmV0dXJuIFJhKGEuX3JlbmRlcik7Y2FzZSBFYTpiPWEuX3BheWxvYWQ7YT1hLl9pbml0O3RyeXtyZXR1cm4gUmEoYShiKSl9Y2F0Y2goYyl7fX1yZXR1cm4gbnVsbH1mdW5jdGlvbiBTYShhKXtzd2l0Y2godHlwZW9mIGEpe2Nhc2UgXCJib29sZWFuXCI6Y2FzZSBcIm51bWJlclwiOmNhc2UgXCJvYmplY3RcIjpjYXNlIFwic3RyaW5nXCI6Y2FzZSBcInVuZGVmaW5lZFwiOnJldHVybiBhO2RlZmF1bHQ6cmV0dXJuXCJcIn19ZnVuY3Rpb24gVGEoYSl7dmFyIGI9YS50eXBlO3JldHVybihhPWEubm9kZU5hbWUpJiZcImlucHV0XCI9PT1hLnRvTG93ZXJDYXNlKCkmJihcImNoZWNrYm94XCI9PT1ifHxcInJhZGlvXCI9PT1iKX1cbmZ1bmN0aW9uIFVhKGEpe3ZhciBiPVRhKGEpP1wiY2hlY2tlZFwiOlwidmFsdWVcIixjPU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoYS5jb25zdHJ1Y3Rvci5wcm90b3R5cGUsYiksZD1cIlwiK2FbYl07aWYoIWEuaGFzT3duUHJvcGVydHkoYikmJlwidW5kZWZpbmVkXCIhPT10eXBlb2YgYyYmXCJmdW5jdGlvblwiPT09dHlwZW9mIGMuZ2V0JiZcImZ1bmN0aW9uXCI9PT10eXBlb2YgYy5zZXQpe3ZhciBlPWMuZ2V0LGY9Yy5zZXQ7T2JqZWN0LmRlZmluZVByb3BlcnR5KGEsYix7Y29uZmlndXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiBlLmNhbGwodGhpcyl9LHNldDpmdW5jdGlvbihhKXtkPVwiXCIrYTtmLmNhbGwodGhpcyxhKX19KTtPYmplY3QuZGVmaW5lUHJvcGVydHkoYSxiLHtlbnVtZXJhYmxlOmMuZW51bWVyYWJsZX0pO3JldHVybntnZXRWYWx1ZTpmdW5jdGlvbigpe3JldHVybiBkfSxzZXRWYWx1ZTpmdW5jdGlvbihhKXtkPVwiXCIrYX0sc3RvcFRyYWNraW5nOmZ1bmN0aW9uKCl7YS5fdmFsdWVUcmFja2VyPVxubnVsbDtkZWxldGUgYVtiXX19fX1mdW5jdGlvbiBWYShhKXthLl92YWx1ZVRyYWNrZXJ8fChhLl92YWx1ZVRyYWNrZXI9VWEoYSkpfWZ1bmN0aW9uIFdhKGEpe2lmKCFhKXJldHVybiExO3ZhciBiPWEuX3ZhbHVlVHJhY2tlcjtpZighYilyZXR1cm4hMDt2YXIgYz1iLmdldFZhbHVlKCk7dmFyIGQ9XCJcIjthJiYoZD1UYShhKT9hLmNoZWNrZWQ/XCJ0cnVlXCI6XCJmYWxzZVwiOmEudmFsdWUpO2E9ZDtyZXR1cm4gYSE9PWM/KGIuc2V0VmFsdWUoYSksITApOiExfWZ1bmN0aW9uIFhhKGEpe2E9YXx8KFwidW5kZWZpbmVkXCIhPT10eXBlb2YgZG9jdW1lbnQ/ZG9jdW1lbnQ6dm9pZCAwKTtpZihcInVuZGVmaW5lZFwiPT09dHlwZW9mIGEpcmV0dXJuIG51bGw7dHJ5e3JldHVybiBhLmFjdGl2ZUVsZW1lbnR8fGEuYm9keX1jYXRjaChiKXtyZXR1cm4gYS5ib2R5fX1cbmZ1bmN0aW9uIFlhKGEsYil7dmFyIGM9Yi5jaGVja2VkO3JldHVybiBtKHt9LGIse2RlZmF1bHRDaGVja2VkOnZvaWQgMCxkZWZhdWx0VmFsdWU6dm9pZCAwLHZhbHVlOnZvaWQgMCxjaGVja2VkOm51bGwhPWM/YzphLl93cmFwcGVyU3RhdGUuaW5pdGlhbENoZWNrZWR9KX1mdW5jdGlvbiBaYShhLGIpe3ZhciBjPW51bGw9PWIuZGVmYXVsdFZhbHVlP1wiXCI6Yi5kZWZhdWx0VmFsdWUsZD1udWxsIT1iLmNoZWNrZWQ/Yi5jaGVja2VkOmIuZGVmYXVsdENoZWNrZWQ7Yz1TYShudWxsIT1iLnZhbHVlP2IudmFsdWU6Yyk7YS5fd3JhcHBlclN0YXRlPXtpbml0aWFsQ2hlY2tlZDpkLGluaXRpYWxWYWx1ZTpjLGNvbnRyb2xsZWQ6XCJjaGVja2JveFwiPT09Yi50eXBlfHxcInJhZGlvXCI9PT1iLnR5cGU/bnVsbCE9Yi5jaGVja2VkOm51bGwhPWIudmFsdWV9fWZ1bmN0aW9uICRhKGEsYil7Yj1iLmNoZWNrZWQ7bnVsbCE9YiYmcWEoYSxcImNoZWNrZWRcIixiLCExKX1cbmZ1bmN0aW9uIGFiKGEsYil7JGEoYSxiKTt2YXIgYz1TYShiLnZhbHVlKSxkPWIudHlwZTtpZihudWxsIT1jKWlmKFwibnVtYmVyXCI9PT1kKXtpZigwPT09YyYmXCJcIj09PWEudmFsdWV8fGEudmFsdWUhPWMpYS52YWx1ZT1cIlwiK2N9ZWxzZSBhLnZhbHVlIT09XCJcIitjJiYoYS52YWx1ZT1cIlwiK2MpO2Vsc2UgaWYoXCJzdWJtaXRcIj09PWR8fFwicmVzZXRcIj09PWQpe2EucmVtb3ZlQXR0cmlidXRlKFwidmFsdWVcIik7cmV0dXJufWIuaGFzT3duUHJvcGVydHkoXCJ2YWx1ZVwiKT9iYihhLGIudHlwZSxjKTpiLmhhc093blByb3BlcnR5KFwiZGVmYXVsdFZhbHVlXCIpJiZiYihhLGIudHlwZSxTYShiLmRlZmF1bHRWYWx1ZSkpO251bGw9PWIuY2hlY2tlZCYmbnVsbCE9Yi5kZWZhdWx0Q2hlY2tlZCYmKGEuZGVmYXVsdENoZWNrZWQ9ISFiLmRlZmF1bHRDaGVja2VkKX1cbmZ1bmN0aW9uIGNiKGEsYixjKXtpZihiLmhhc093blByb3BlcnR5KFwidmFsdWVcIil8fGIuaGFzT3duUHJvcGVydHkoXCJkZWZhdWx0VmFsdWVcIikpe3ZhciBkPWIudHlwZTtpZighKFwic3VibWl0XCIhPT1kJiZcInJlc2V0XCIhPT1kfHx2b2lkIDAhPT1iLnZhbHVlJiZudWxsIT09Yi52YWx1ZSkpcmV0dXJuO2I9XCJcIithLl93cmFwcGVyU3RhdGUuaW5pdGlhbFZhbHVlO2N8fGI9PT1hLnZhbHVlfHwoYS52YWx1ZT1iKTthLmRlZmF1bHRWYWx1ZT1ifWM9YS5uYW1lO1wiXCIhPT1jJiYoYS5uYW1lPVwiXCIpO2EuZGVmYXVsdENoZWNrZWQ9ISFhLl93cmFwcGVyU3RhdGUuaW5pdGlhbENoZWNrZWQ7XCJcIiE9PWMmJihhLm5hbWU9Yyl9XG5mdW5jdGlvbiBiYihhLGIsYyl7aWYoXCJudW1iZXJcIiE9PWJ8fFhhKGEub3duZXJEb2N1bWVudCkhPT1hKW51bGw9PWM/YS5kZWZhdWx0VmFsdWU9XCJcIithLl93cmFwcGVyU3RhdGUuaW5pdGlhbFZhbHVlOmEuZGVmYXVsdFZhbHVlIT09XCJcIitjJiYoYS5kZWZhdWx0VmFsdWU9XCJcIitjKX1mdW5jdGlvbiBkYihhKXt2YXIgYj1cIlwiO2FhLkNoaWxkcmVuLmZvckVhY2goYSxmdW5jdGlvbihhKXtudWxsIT1hJiYoYis9YSl9KTtyZXR1cm4gYn1mdW5jdGlvbiBlYihhLGIpe2E9bSh7Y2hpbGRyZW46dm9pZCAwfSxiKTtpZihiPWRiKGIuY2hpbGRyZW4pKWEuY2hpbGRyZW49YjtyZXR1cm4gYX1cbmZ1bmN0aW9uIGZiKGEsYixjLGQpe2E9YS5vcHRpb25zO2lmKGIpe2I9e307Zm9yKHZhciBlPTA7ZTxjLmxlbmd0aDtlKyspYltcIiRcIitjW2VdXT0hMDtmb3IoYz0wO2M8YS5sZW5ndGg7YysrKWU9Yi5oYXNPd25Qcm9wZXJ0eShcIiRcIithW2NdLnZhbHVlKSxhW2NdLnNlbGVjdGVkIT09ZSYmKGFbY10uc2VsZWN0ZWQ9ZSksZSYmZCYmKGFbY10uZGVmYXVsdFNlbGVjdGVkPSEwKX1lbHNle2M9XCJcIitTYShjKTtiPW51bGw7Zm9yKGU9MDtlPGEubGVuZ3RoO2UrKyl7aWYoYVtlXS52YWx1ZT09PWMpe2FbZV0uc2VsZWN0ZWQ9ITA7ZCYmKGFbZV0uZGVmYXVsdFNlbGVjdGVkPSEwKTtyZXR1cm59bnVsbCE9PWJ8fGFbZV0uZGlzYWJsZWR8fChiPWFbZV0pfW51bGwhPT1iJiYoYi5zZWxlY3RlZD0hMCl9fVxuZnVuY3Rpb24gZ2IoYSxiKXtpZihudWxsIT1iLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MKXRocm93IEVycm9yKHkoOTEpKTtyZXR1cm4gbSh7fSxiLHt2YWx1ZTp2b2lkIDAsZGVmYXVsdFZhbHVlOnZvaWQgMCxjaGlsZHJlbjpcIlwiK2EuX3dyYXBwZXJTdGF0ZS5pbml0aWFsVmFsdWV9KX1mdW5jdGlvbiBoYihhLGIpe3ZhciBjPWIudmFsdWU7aWYobnVsbD09Yyl7Yz1iLmNoaWxkcmVuO2I9Yi5kZWZhdWx0VmFsdWU7aWYobnVsbCE9Yyl7aWYobnVsbCE9Yil0aHJvdyBFcnJvcih5KDkyKSk7aWYoQXJyYXkuaXNBcnJheShjKSl7aWYoISgxPj1jLmxlbmd0aCkpdGhyb3cgRXJyb3IoeSg5MykpO2M9Y1swXX1iPWN9bnVsbD09YiYmKGI9XCJcIik7Yz1ifWEuX3dyYXBwZXJTdGF0ZT17aW5pdGlhbFZhbHVlOlNhKGMpfX1cbmZ1bmN0aW9uIGliKGEsYil7dmFyIGM9U2EoYi52YWx1ZSksZD1TYShiLmRlZmF1bHRWYWx1ZSk7bnVsbCE9YyYmKGM9XCJcIitjLGMhPT1hLnZhbHVlJiYoYS52YWx1ZT1jKSxudWxsPT1iLmRlZmF1bHRWYWx1ZSYmYS5kZWZhdWx0VmFsdWUhPT1jJiYoYS5kZWZhdWx0VmFsdWU9YykpO251bGwhPWQmJihhLmRlZmF1bHRWYWx1ZT1cIlwiK2QpfWZ1bmN0aW9uIGpiKGEpe3ZhciBiPWEudGV4dENvbnRlbnQ7Yj09PWEuX3dyYXBwZXJTdGF0ZS5pbml0aWFsVmFsdWUmJlwiXCIhPT1iJiZudWxsIT09YiYmKGEudmFsdWU9Yil9dmFyIGtiPXtodG1sOlwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbFwiLG1hdGhtbDpcImh0dHA6Ly93d3cudzMub3JnLzE5OTgvTWF0aC9NYXRoTUxcIixzdmc6XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wifTtcbmZ1bmN0aW9uIGxiKGEpe3N3aXRjaChhKXtjYXNlIFwic3ZnXCI6cmV0dXJuXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiO2Nhc2UgXCJtYXRoXCI6cmV0dXJuXCJodHRwOi8vd3d3LnczLm9yZy8xOTk4L01hdGgvTWF0aE1MXCI7ZGVmYXVsdDpyZXR1cm5cImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWxcIn19ZnVuY3Rpb24gbWIoYSxiKXtyZXR1cm4gbnVsbD09YXx8XCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sXCI9PT1hP2xiKGIpOlwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIj09PWEmJlwiZm9yZWlnbk9iamVjdFwiPT09Yj9cImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWxcIjphfVxudmFyIG5iLG9iPWZ1bmN0aW9uKGEpe3JldHVyblwidW5kZWZpbmVkXCIhPT10eXBlb2YgTVNBcHAmJk1TQXBwLmV4ZWNVbnNhZmVMb2NhbEZ1bmN0aW9uP2Z1bmN0aW9uKGIsYyxkLGUpe01TQXBwLmV4ZWNVbnNhZmVMb2NhbEZ1bmN0aW9uKGZ1bmN0aW9uKCl7cmV0dXJuIGEoYixjLGQsZSl9KX06YX0oZnVuY3Rpb24oYSxiKXtpZihhLm5hbWVzcGFjZVVSSSE9PWtiLnN2Z3x8XCJpbm5lckhUTUxcImluIGEpYS5pbm5lckhUTUw9YjtlbHNle25iPW5ifHxkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO25iLmlubmVySFRNTD1cIjxzdmc+XCIrYi52YWx1ZU9mKCkudG9TdHJpbmcoKStcIjwvc3ZnPlwiO2ZvcihiPW5iLmZpcnN0Q2hpbGQ7YS5maXJzdENoaWxkOylhLnJlbW92ZUNoaWxkKGEuZmlyc3RDaGlsZCk7Zm9yKDtiLmZpcnN0Q2hpbGQ7KWEuYXBwZW5kQ2hpbGQoYi5maXJzdENoaWxkKX19KTtcbmZ1bmN0aW9uIHBiKGEsYil7aWYoYil7dmFyIGM9YS5maXJzdENoaWxkO2lmKGMmJmM9PT1hLmxhc3RDaGlsZCYmMz09PWMubm9kZVR5cGUpe2Mubm9kZVZhbHVlPWI7cmV0dXJufX1hLnRleHRDb250ZW50PWJ9XG52YXIgcWI9e2FuaW1hdGlvbkl0ZXJhdGlvbkNvdW50OiEwLGJvcmRlckltYWdlT3V0c2V0OiEwLGJvcmRlckltYWdlU2xpY2U6ITAsYm9yZGVySW1hZ2VXaWR0aDohMCxib3hGbGV4OiEwLGJveEZsZXhHcm91cDohMCxib3hPcmRpbmFsR3JvdXA6ITAsY29sdW1uQ291bnQ6ITAsY29sdW1uczohMCxmbGV4OiEwLGZsZXhHcm93OiEwLGZsZXhQb3NpdGl2ZTohMCxmbGV4U2hyaW5rOiEwLGZsZXhOZWdhdGl2ZTohMCxmbGV4T3JkZXI6ITAsZ3JpZEFyZWE6ITAsZ3JpZFJvdzohMCxncmlkUm93RW5kOiEwLGdyaWRSb3dTcGFuOiEwLGdyaWRSb3dTdGFydDohMCxncmlkQ29sdW1uOiEwLGdyaWRDb2x1bW5FbmQ6ITAsZ3JpZENvbHVtblNwYW46ITAsZ3JpZENvbHVtblN0YXJ0OiEwLGZvbnRXZWlnaHQ6ITAsbGluZUNsYW1wOiEwLGxpbmVIZWlnaHQ6ITAsb3BhY2l0eTohMCxvcmRlcjohMCxvcnBoYW5zOiEwLHRhYlNpemU6ITAsd2lkb3dzOiEwLHpJbmRleDohMCx6b29tOiEwLGZpbGxPcGFjaXR5OiEwLFxuZmxvb2RPcGFjaXR5OiEwLHN0b3BPcGFjaXR5OiEwLHN0cm9rZURhc2hhcnJheTohMCxzdHJva2VEYXNob2Zmc2V0OiEwLHN0cm9rZU1pdGVybGltaXQ6ITAsc3Ryb2tlT3BhY2l0eTohMCxzdHJva2VXaWR0aDohMH0scmI9W1wiV2Via2l0XCIsXCJtc1wiLFwiTW96XCIsXCJPXCJdO09iamVjdC5rZXlzKHFiKS5mb3JFYWNoKGZ1bmN0aW9uKGEpe3JiLmZvckVhY2goZnVuY3Rpb24oYil7Yj1iK2EuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkrYS5zdWJzdHJpbmcoMSk7cWJbYl09cWJbYV19KX0pO2Z1bmN0aW9uIHNiKGEsYixjKXtyZXR1cm4gbnVsbD09Ynx8XCJib29sZWFuXCI9PT10eXBlb2YgYnx8XCJcIj09PWI/XCJcIjpjfHxcIm51bWJlclwiIT09dHlwZW9mIGJ8fDA9PT1ifHxxYi5oYXNPd25Qcm9wZXJ0eShhKSYmcWJbYV0/KFwiXCIrYikudHJpbSgpOmIrXCJweFwifVxuZnVuY3Rpb24gdGIoYSxiKXthPWEuc3R5bGU7Zm9yKHZhciBjIGluIGIpaWYoYi5oYXNPd25Qcm9wZXJ0eShjKSl7dmFyIGQ9MD09PWMuaW5kZXhPZihcIi0tXCIpLGU9c2IoYyxiW2NdLGQpO1wiZmxvYXRcIj09PWMmJihjPVwiY3NzRmxvYXRcIik7ZD9hLnNldFByb3BlcnR5KGMsZSk6YVtjXT1lfX12YXIgdWI9bSh7bWVudWl0ZW06ITB9LHthcmVhOiEwLGJhc2U6ITAsYnI6ITAsY29sOiEwLGVtYmVkOiEwLGhyOiEwLGltZzohMCxpbnB1dDohMCxrZXlnZW46ITAsbGluazohMCxtZXRhOiEwLHBhcmFtOiEwLHNvdXJjZTohMCx0cmFjazohMCx3YnI6ITB9KTtcbmZ1bmN0aW9uIHZiKGEsYil7aWYoYil7aWYodWJbYV0mJihudWxsIT1iLmNoaWxkcmVufHxudWxsIT1iLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MKSl0aHJvdyBFcnJvcih5KDEzNyxhKSk7aWYobnVsbCE9Yi5kYW5nZXJvdXNseVNldElubmVySFRNTCl7aWYobnVsbCE9Yi5jaGlsZHJlbil0aHJvdyBFcnJvcih5KDYwKSk7aWYoIShcIm9iamVjdFwiPT09dHlwZW9mIGIuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwmJlwiX19odG1sXCJpbiBiLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MKSl0aHJvdyBFcnJvcih5KDYxKSk7fWlmKG51bGwhPWIuc3R5bGUmJlwib2JqZWN0XCIhPT10eXBlb2YgYi5zdHlsZSl0aHJvdyBFcnJvcih5KDYyKSk7fX1cbmZ1bmN0aW9uIHdiKGEsYil7aWYoLTE9PT1hLmluZGV4T2YoXCItXCIpKXJldHVyblwic3RyaW5nXCI9PT10eXBlb2YgYi5pcztzd2l0Y2goYSl7Y2FzZSBcImFubm90YXRpb24teG1sXCI6Y2FzZSBcImNvbG9yLXByb2ZpbGVcIjpjYXNlIFwiZm9udC1mYWNlXCI6Y2FzZSBcImZvbnQtZmFjZS1zcmNcIjpjYXNlIFwiZm9udC1mYWNlLXVyaVwiOmNhc2UgXCJmb250LWZhY2UtZm9ybWF0XCI6Y2FzZSBcImZvbnQtZmFjZS1uYW1lXCI6Y2FzZSBcIm1pc3NpbmctZ2x5cGhcIjpyZXR1cm4hMTtkZWZhdWx0OnJldHVybiEwfX1mdW5jdGlvbiB4YihhKXthPWEudGFyZ2V0fHxhLnNyY0VsZW1lbnR8fHdpbmRvdzthLmNvcnJlc3BvbmRpbmdVc2VFbGVtZW50JiYoYT1hLmNvcnJlc3BvbmRpbmdVc2VFbGVtZW50KTtyZXR1cm4gMz09PWEubm9kZVR5cGU/YS5wYXJlbnROb2RlOmF9dmFyIHliPW51bGwsemI9bnVsbCxBYj1udWxsO1xuZnVuY3Rpb24gQmIoYSl7aWYoYT1DYihhKSl7aWYoXCJmdW5jdGlvblwiIT09dHlwZW9mIHliKXRocm93IEVycm9yKHkoMjgwKSk7dmFyIGI9YS5zdGF0ZU5vZGU7YiYmKGI9RGIoYikseWIoYS5zdGF0ZU5vZGUsYS50eXBlLGIpKX19ZnVuY3Rpb24gRWIoYSl7emI/QWI/QWIucHVzaChhKTpBYj1bYV06emI9YX1mdW5jdGlvbiBGYigpe2lmKHpiKXt2YXIgYT16YixiPUFiO0FiPXpiPW51bGw7QmIoYSk7aWYoYilmb3IoYT0wO2E8Yi5sZW5ndGg7YSsrKUJiKGJbYV0pfX1mdW5jdGlvbiBHYihhLGIpe3JldHVybiBhKGIpfWZ1bmN0aW9uIEhiKGEsYixjLGQsZSl7cmV0dXJuIGEoYixjLGQsZSl9ZnVuY3Rpb24gSWIoKXt9dmFyIEpiPUdiLEtiPSExLExiPSExO2Z1bmN0aW9uIE1iKCl7aWYobnVsbCE9PXpifHxudWxsIT09QWIpSWIoKSxGYigpfVxuZnVuY3Rpb24gTmIoYSxiLGMpe2lmKExiKXJldHVybiBhKGIsYyk7TGI9ITA7dHJ5e3JldHVybiBKYihhLGIsYyl9ZmluYWxseXtMYj0hMSxNYigpfX1cbmZ1bmN0aW9uIE9iKGEsYil7dmFyIGM9YS5zdGF0ZU5vZGU7aWYobnVsbD09PWMpcmV0dXJuIG51bGw7dmFyIGQ9RGIoYyk7aWYobnVsbD09PWQpcmV0dXJuIG51bGw7Yz1kW2JdO2E6c3dpdGNoKGIpe2Nhc2UgXCJvbkNsaWNrXCI6Y2FzZSBcIm9uQ2xpY2tDYXB0dXJlXCI6Y2FzZSBcIm9uRG91YmxlQ2xpY2tcIjpjYXNlIFwib25Eb3VibGVDbGlja0NhcHR1cmVcIjpjYXNlIFwib25Nb3VzZURvd25cIjpjYXNlIFwib25Nb3VzZURvd25DYXB0dXJlXCI6Y2FzZSBcIm9uTW91c2VNb3ZlXCI6Y2FzZSBcIm9uTW91c2VNb3ZlQ2FwdHVyZVwiOmNhc2UgXCJvbk1vdXNlVXBcIjpjYXNlIFwib25Nb3VzZVVwQ2FwdHVyZVwiOmNhc2UgXCJvbk1vdXNlRW50ZXJcIjooZD0hZC5kaXNhYmxlZCl8fChhPWEudHlwZSxkPSEoXCJidXR0b25cIj09PWF8fFwiaW5wdXRcIj09PWF8fFwic2VsZWN0XCI9PT1hfHxcInRleHRhcmVhXCI9PT1hKSk7YT0hZDticmVhayBhO2RlZmF1bHQ6YT0hMX1pZihhKXJldHVybiBudWxsO2lmKGMmJlwiZnVuY3Rpb25cIiE9PVxudHlwZW9mIGMpdGhyb3cgRXJyb3IoeSgyMzEsYix0eXBlb2YgYykpO3JldHVybiBjfXZhciBQYj0hMTtpZihmYSl0cnl7dmFyIFFiPXt9O09iamVjdC5kZWZpbmVQcm9wZXJ0eShRYixcInBhc3NpdmVcIix7Z2V0OmZ1bmN0aW9uKCl7UGI9ITB9fSk7d2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJ0ZXN0XCIsUWIsUWIpO3dpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwidGVzdFwiLFFiLFFiKX1jYXRjaChhKXtQYj0hMX1mdW5jdGlvbiBSYihhLGIsYyxkLGUsZixnLGgsayl7dmFyIGw9QXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLDMpO3RyeXtiLmFwcGx5KGMsbCl9Y2F0Y2gobil7dGhpcy5vbkVycm9yKG4pfX12YXIgU2I9ITEsVGI9bnVsbCxVYj0hMSxWYj1udWxsLFdiPXtvbkVycm9yOmZ1bmN0aW9uKGEpe1NiPSEwO1RiPWF9fTtmdW5jdGlvbiBYYihhLGIsYyxkLGUsZixnLGgsayl7U2I9ITE7VGI9bnVsbDtSYi5hcHBseShXYixhcmd1bWVudHMpfVxuZnVuY3Rpb24gWWIoYSxiLGMsZCxlLGYsZyxoLGspe1hiLmFwcGx5KHRoaXMsYXJndW1lbnRzKTtpZihTYil7aWYoU2Ipe3ZhciBsPVRiO1NiPSExO1RiPW51bGx9ZWxzZSB0aHJvdyBFcnJvcih5KDE5OCkpO1VifHwoVWI9ITAsVmI9bCl9fWZ1bmN0aW9uIFpiKGEpe3ZhciBiPWEsYz1hO2lmKGEuYWx0ZXJuYXRlKWZvcig7Yi5yZXR1cm47KWI9Yi5yZXR1cm47ZWxzZXthPWI7ZG8gYj1hLDAhPT0oYi5mbGFncyYxMDI2KSYmKGM9Yi5yZXR1cm4pLGE9Yi5yZXR1cm47d2hpbGUoYSl9cmV0dXJuIDM9PT1iLnRhZz9jOm51bGx9ZnVuY3Rpb24gJGIoYSl7aWYoMTM9PT1hLnRhZyl7dmFyIGI9YS5tZW1vaXplZFN0YXRlO251bGw9PT1iJiYoYT1hLmFsdGVybmF0ZSxudWxsIT09YSYmKGI9YS5tZW1vaXplZFN0YXRlKSk7aWYobnVsbCE9PWIpcmV0dXJuIGIuZGVoeWRyYXRlZH1yZXR1cm4gbnVsbH1mdW5jdGlvbiBhYyhhKXtpZihaYihhKSE9PWEpdGhyb3cgRXJyb3IoeSgxODgpKTt9XG5mdW5jdGlvbiBiYyhhKXt2YXIgYj1hLmFsdGVybmF0ZTtpZighYil7Yj1aYihhKTtpZihudWxsPT09Yil0aHJvdyBFcnJvcih5KDE4OCkpO3JldHVybiBiIT09YT9udWxsOmF9Zm9yKHZhciBjPWEsZD1iOzspe3ZhciBlPWMucmV0dXJuO2lmKG51bGw9PT1lKWJyZWFrO3ZhciBmPWUuYWx0ZXJuYXRlO2lmKG51bGw9PT1mKXtkPWUucmV0dXJuO2lmKG51bGwhPT1kKXtjPWQ7Y29udGludWV9YnJlYWt9aWYoZS5jaGlsZD09PWYuY2hpbGQpe2ZvcihmPWUuY2hpbGQ7Zjspe2lmKGY9PT1jKXJldHVybiBhYyhlKSxhO2lmKGY9PT1kKXJldHVybiBhYyhlKSxiO2Y9Zi5zaWJsaW5nfXRocm93IEVycm9yKHkoMTg4KSk7fWlmKGMucmV0dXJuIT09ZC5yZXR1cm4pYz1lLGQ9ZjtlbHNle2Zvcih2YXIgZz0hMSxoPWUuY2hpbGQ7aDspe2lmKGg9PT1jKXtnPSEwO2M9ZTtkPWY7YnJlYWt9aWYoaD09PWQpe2c9ITA7ZD1lO2M9ZjticmVha31oPWguc2libGluZ31pZighZyl7Zm9yKGg9Zi5jaGlsZDtoOyl7aWYoaD09PVxuYyl7Zz0hMDtjPWY7ZD1lO2JyZWFrfWlmKGg9PT1kKXtnPSEwO2Q9ZjtjPWU7YnJlYWt9aD1oLnNpYmxpbmd9aWYoIWcpdGhyb3cgRXJyb3IoeSgxODkpKTt9fWlmKGMuYWx0ZXJuYXRlIT09ZCl0aHJvdyBFcnJvcih5KDE5MCkpO31pZigzIT09Yy50YWcpdGhyb3cgRXJyb3IoeSgxODgpKTtyZXR1cm4gYy5zdGF0ZU5vZGUuY3VycmVudD09PWM/YTpifWZ1bmN0aW9uIGNjKGEpe2E9YmMoYSk7aWYoIWEpcmV0dXJuIG51bGw7Zm9yKHZhciBiPWE7Oyl7aWYoNT09PWIudGFnfHw2PT09Yi50YWcpcmV0dXJuIGI7aWYoYi5jaGlsZCliLmNoaWxkLnJldHVybj1iLGI9Yi5jaGlsZDtlbHNle2lmKGI9PT1hKWJyZWFrO2Zvcig7IWIuc2libGluZzspe2lmKCFiLnJldHVybnx8Yi5yZXR1cm49PT1hKXJldHVybiBudWxsO2I9Yi5yZXR1cm59Yi5zaWJsaW5nLnJldHVybj1iLnJldHVybjtiPWIuc2libGluZ319cmV0dXJuIG51bGx9XG5mdW5jdGlvbiBkYyhhLGIpe2Zvcih2YXIgYz1hLmFsdGVybmF0ZTtudWxsIT09Yjspe2lmKGI9PT1hfHxiPT09YylyZXR1cm4hMDtiPWIucmV0dXJufXJldHVybiExfXZhciBlYyxmYyxnYyxoYyxpYz0hMSxqYz1bXSxrYz1udWxsLGxjPW51bGwsbWM9bnVsbCxuYz1uZXcgTWFwLG9jPW5ldyBNYXAscGM9W10scWM9XCJtb3VzZWRvd24gbW91c2V1cCB0b3VjaGNhbmNlbCB0b3VjaGVuZCB0b3VjaHN0YXJ0IGF1eGNsaWNrIGRibGNsaWNrIHBvaW50ZXJjYW5jZWwgcG9pbnRlcmRvd24gcG9pbnRlcnVwIGRyYWdlbmQgZHJhZ3N0YXJ0IGRyb3AgY29tcG9zaXRpb25lbmQgY29tcG9zaXRpb25zdGFydCBrZXlkb3duIGtleXByZXNzIGtleXVwIGlucHV0IHRleHRJbnB1dCBjb3B5IGN1dCBwYXN0ZSBjbGljayBjaGFuZ2UgY29udGV4dG1lbnUgcmVzZXQgc3VibWl0XCIuc3BsaXQoXCIgXCIpO1xuZnVuY3Rpb24gcmMoYSxiLGMsZCxlKXtyZXR1cm57YmxvY2tlZE9uOmEsZG9tRXZlbnROYW1lOmIsZXZlbnRTeXN0ZW1GbGFnczpjfDE2LG5hdGl2ZUV2ZW50OmUsdGFyZ2V0Q29udGFpbmVyczpbZF19fWZ1bmN0aW9uIHNjKGEsYil7c3dpdGNoKGEpe2Nhc2UgXCJmb2N1c2luXCI6Y2FzZSBcImZvY3Vzb3V0XCI6a2M9bnVsbDticmVhaztjYXNlIFwiZHJhZ2VudGVyXCI6Y2FzZSBcImRyYWdsZWF2ZVwiOmxjPW51bGw7YnJlYWs7Y2FzZSBcIm1vdXNlb3ZlclwiOmNhc2UgXCJtb3VzZW91dFwiOm1jPW51bGw7YnJlYWs7Y2FzZSBcInBvaW50ZXJvdmVyXCI6Y2FzZSBcInBvaW50ZXJvdXRcIjpuYy5kZWxldGUoYi5wb2ludGVySWQpO2JyZWFrO2Nhc2UgXCJnb3Rwb2ludGVyY2FwdHVyZVwiOmNhc2UgXCJsb3N0cG9pbnRlcmNhcHR1cmVcIjpvYy5kZWxldGUoYi5wb2ludGVySWQpfX1cbmZ1bmN0aW9uIHRjKGEsYixjLGQsZSxmKXtpZihudWxsPT09YXx8YS5uYXRpdmVFdmVudCE9PWYpcmV0dXJuIGE9cmMoYixjLGQsZSxmKSxudWxsIT09YiYmKGI9Q2IoYiksbnVsbCE9PWImJmZjKGIpKSxhO2EuZXZlbnRTeXN0ZW1GbGFnc3w9ZDtiPWEudGFyZ2V0Q29udGFpbmVycztudWxsIT09ZSYmLTE9PT1iLmluZGV4T2YoZSkmJmIucHVzaChlKTtyZXR1cm4gYX1cbmZ1bmN0aW9uIHVjKGEsYixjLGQsZSl7c3dpdGNoKGIpe2Nhc2UgXCJmb2N1c2luXCI6cmV0dXJuIGtjPXRjKGtjLGEsYixjLGQsZSksITA7Y2FzZSBcImRyYWdlbnRlclwiOnJldHVybiBsYz10YyhsYyxhLGIsYyxkLGUpLCEwO2Nhc2UgXCJtb3VzZW92ZXJcIjpyZXR1cm4gbWM9dGMobWMsYSxiLGMsZCxlKSwhMDtjYXNlIFwicG9pbnRlcm92ZXJcIjp2YXIgZj1lLnBvaW50ZXJJZDtuYy5zZXQoZix0YyhuYy5nZXQoZil8fG51bGwsYSxiLGMsZCxlKSk7cmV0dXJuITA7Y2FzZSBcImdvdHBvaW50ZXJjYXB0dXJlXCI6cmV0dXJuIGY9ZS5wb2ludGVySWQsb2Muc2V0KGYsdGMob2MuZ2V0KGYpfHxudWxsLGEsYixjLGQsZSkpLCEwfXJldHVybiExfVxuZnVuY3Rpb24gdmMoYSl7dmFyIGI9d2MoYS50YXJnZXQpO2lmKG51bGwhPT1iKXt2YXIgYz1aYihiKTtpZihudWxsIT09YylpZihiPWMudGFnLDEzPT09Yil7aWYoYj0kYihjKSxudWxsIT09Yil7YS5ibG9ja2VkT249YjtoYyhhLmxhbmVQcmlvcml0eSxmdW5jdGlvbigpe3IudW5zdGFibGVfcnVuV2l0aFByaW9yaXR5KGEucHJpb3JpdHksZnVuY3Rpb24oKXtnYyhjKX0pfSk7cmV0dXJufX1lbHNlIGlmKDM9PT1iJiZjLnN0YXRlTm9kZS5oeWRyYXRlKXthLmJsb2NrZWRPbj0zPT09Yy50YWc/Yy5zdGF0ZU5vZGUuY29udGFpbmVySW5mbzpudWxsO3JldHVybn19YS5ibG9ja2VkT249bnVsbH1cbmZ1bmN0aW9uIHhjKGEpe2lmKG51bGwhPT1hLmJsb2NrZWRPbilyZXR1cm4hMTtmb3IodmFyIGI9YS50YXJnZXRDb250YWluZXJzOzA8Yi5sZW5ndGg7KXt2YXIgYz15YyhhLmRvbUV2ZW50TmFtZSxhLmV2ZW50U3lzdGVtRmxhZ3MsYlswXSxhLm5hdGl2ZUV2ZW50KTtpZihudWxsIT09YylyZXR1cm4gYj1DYihjKSxudWxsIT09YiYmZmMoYiksYS5ibG9ja2VkT249YywhMTtiLnNoaWZ0KCl9cmV0dXJuITB9ZnVuY3Rpb24gemMoYSxiLGMpe3hjKGEpJiZjLmRlbGV0ZShiKX1cbmZ1bmN0aW9uIEFjKCl7Zm9yKGljPSExOzA8amMubGVuZ3RoOyl7dmFyIGE9amNbMF07aWYobnVsbCE9PWEuYmxvY2tlZE9uKXthPUNiKGEuYmxvY2tlZE9uKTtudWxsIT09YSYmZWMoYSk7YnJlYWt9Zm9yKHZhciBiPWEudGFyZ2V0Q29udGFpbmVyczswPGIubGVuZ3RoOyl7dmFyIGM9eWMoYS5kb21FdmVudE5hbWUsYS5ldmVudFN5c3RlbUZsYWdzLGJbMF0sYS5uYXRpdmVFdmVudCk7aWYobnVsbCE9PWMpe2EuYmxvY2tlZE9uPWM7YnJlYWt9Yi5zaGlmdCgpfW51bGw9PT1hLmJsb2NrZWRPbiYmamMuc2hpZnQoKX1udWxsIT09a2MmJnhjKGtjKSYmKGtjPW51bGwpO251bGwhPT1sYyYmeGMobGMpJiYobGM9bnVsbCk7bnVsbCE9PW1jJiZ4YyhtYykmJihtYz1udWxsKTtuYy5mb3JFYWNoKHpjKTtvYy5mb3JFYWNoKHpjKX1cbmZ1bmN0aW9uIEJjKGEsYil7YS5ibG9ja2VkT249PT1iJiYoYS5ibG9ja2VkT249bnVsbCxpY3x8KGljPSEwLHIudW5zdGFibGVfc2NoZWR1bGVDYWxsYmFjayhyLnVuc3RhYmxlX05vcm1hbFByaW9yaXR5LEFjKSkpfVxuZnVuY3Rpb24gQ2MoYSl7ZnVuY3Rpb24gYihiKXtyZXR1cm4gQmMoYixhKX1pZigwPGpjLmxlbmd0aCl7QmMoamNbMF0sYSk7Zm9yKHZhciBjPTE7YzxqYy5sZW5ndGg7YysrKXt2YXIgZD1qY1tjXTtkLmJsb2NrZWRPbj09PWEmJihkLmJsb2NrZWRPbj1udWxsKX19bnVsbCE9PWtjJiZCYyhrYyxhKTtudWxsIT09bGMmJkJjKGxjLGEpO251bGwhPT1tYyYmQmMobWMsYSk7bmMuZm9yRWFjaChiKTtvYy5mb3JFYWNoKGIpO2ZvcihjPTA7YzxwYy5sZW5ndGg7YysrKWQ9cGNbY10sZC5ibG9ja2VkT249PT1hJiYoZC5ibG9ja2VkT249bnVsbCk7Zm9yKDswPHBjLmxlbmd0aCYmKGM9cGNbMF0sbnVsbD09PWMuYmxvY2tlZE9uKTspdmMoYyksbnVsbD09PWMuYmxvY2tlZE9uJiZwYy5zaGlmdCgpfVxuZnVuY3Rpb24gRGMoYSxiKXt2YXIgYz17fTtjW2EudG9Mb3dlckNhc2UoKV09Yi50b0xvd2VyQ2FzZSgpO2NbXCJXZWJraXRcIithXT1cIndlYmtpdFwiK2I7Y1tcIk1velwiK2FdPVwibW96XCIrYjtyZXR1cm4gY312YXIgRWM9e2FuaW1hdGlvbmVuZDpEYyhcIkFuaW1hdGlvblwiLFwiQW5pbWF0aW9uRW5kXCIpLGFuaW1hdGlvbml0ZXJhdGlvbjpEYyhcIkFuaW1hdGlvblwiLFwiQW5pbWF0aW9uSXRlcmF0aW9uXCIpLGFuaW1hdGlvbnN0YXJ0OkRjKFwiQW5pbWF0aW9uXCIsXCJBbmltYXRpb25TdGFydFwiKSx0cmFuc2l0aW9uZW5kOkRjKFwiVHJhbnNpdGlvblwiLFwiVHJhbnNpdGlvbkVuZFwiKX0sRmM9e30sR2M9e307XG5mYSYmKEdjPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIikuc3R5bGUsXCJBbmltYXRpb25FdmVudFwiaW4gd2luZG93fHwoZGVsZXRlIEVjLmFuaW1hdGlvbmVuZC5hbmltYXRpb24sZGVsZXRlIEVjLmFuaW1hdGlvbml0ZXJhdGlvbi5hbmltYXRpb24sZGVsZXRlIEVjLmFuaW1hdGlvbnN0YXJ0LmFuaW1hdGlvbiksXCJUcmFuc2l0aW9uRXZlbnRcImluIHdpbmRvd3x8ZGVsZXRlIEVjLnRyYW5zaXRpb25lbmQudHJhbnNpdGlvbik7ZnVuY3Rpb24gSGMoYSl7aWYoRmNbYV0pcmV0dXJuIEZjW2FdO2lmKCFFY1thXSlyZXR1cm4gYTt2YXIgYj1FY1thXSxjO2ZvcihjIGluIGIpaWYoYi5oYXNPd25Qcm9wZXJ0eShjKSYmYyBpbiBHYylyZXR1cm4gRmNbYV09YltjXTtyZXR1cm4gYX1cbnZhciBJYz1IYyhcImFuaW1hdGlvbmVuZFwiKSxKYz1IYyhcImFuaW1hdGlvbml0ZXJhdGlvblwiKSxLYz1IYyhcImFuaW1hdGlvbnN0YXJ0XCIpLExjPUhjKFwidHJhbnNpdGlvbmVuZFwiKSxNYz1uZXcgTWFwLE5jPW5ldyBNYXAsT2M9W1wiYWJvcnRcIixcImFib3J0XCIsSWMsXCJhbmltYXRpb25FbmRcIixKYyxcImFuaW1hdGlvbkl0ZXJhdGlvblwiLEtjLFwiYW5pbWF0aW9uU3RhcnRcIixcImNhbnBsYXlcIixcImNhblBsYXlcIixcImNhbnBsYXl0aHJvdWdoXCIsXCJjYW5QbGF5VGhyb3VnaFwiLFwiZHVyYXRpb25jaGFuZ2VcIixcImR1cmF0aW9uQ2hhbmdlXCIsXCJlbXB0aWVkXCIsXCJlbXB0aWVkXCIsXCJlbmNyeXB0ZWRcIixcImVuY3J5cHRlZFwiLFwiZW5kZWRcIixcImVuZGVkXCIsXCJlcnJvclwiLFwiZXJyb3JcIixcImdvdHBvaW50ZXJjYXB0dXJlXCIsXCJnb3RQb2ludGVyQ2FwdHVyZVwiLFwibG9hZFwiLFwibG9hZFwiLFwibG9hZGVkZGF0YVwiLFwibG9hZGVkRGF0YVwiLFwibG9hZGVkbWV0YWRhdGFcIixcImxvYWRlZE1ldGFkYXRhXCIsXCJsb2Fkc3RhcnRcIixcImxvYWRTdGFydFwiLFxuXCJsb3N0cG9pbnRlcmNhcHR1cmVcIixcImxvc3RQb2ludGVyQ2FwdHVyZVwiLFwicGxheWluZ1wiLFwicGxheWluZ1wiLFwicHJvZ3Jlc3NcIixcInByb2dyZXNzXCIsXCJzZWVraW5nXCIsXCJzZWVraW5nXCIsXCJzdGFsbGVkXCIsXCJzdGFsbGVkXCIsXCJzdXNwZW5kXCIsXCJzdXNwZW5kXCIsXCJ0aW1ldXBkYXRlXCIsXCJ0aW1lVXBkYXRlXCIsTGMsXCJ0cmFuc2l0aW9uRW5kXCIsXCJ3YWl0aW5nXCIsXCJ3YWl0aW5nXCJdO2Z1bmN0aW9uIFBjKGEsYil7Zm9yKHZhciBjPTA7YzxhLmxlbmd0aDtjKz0yKXt2YXIgZD1hW2NdLGU9YVtjKzFdO2U9XCJvblwiKyhlWzBdLnRvVXBwZXJDYXNlKCkrZS5zbGljZSgxKSk7TmMuc2V0KGQsYik7TWMuc2V0KGQsZSk7ZGEoZSxbZF0pfX12YXIgUWM9ci51bnN0YWJsZV9ub3c7UWMoKTt2YXIgRj04O1xuZnVuY3Rpb24gUmMoYSl7aWYoMCE9PSgxJmEpKXJldHVybiBGPTE1LDE7aWYoMCE9PSgyJmEpKXJldHVybiBGPTE0LDI7aWYoMCE9PSg0JmEpKXJldHVybiBGPTEzLDQ7dmFyIGI9MjQmYTtpZigwIT09YilyZXR1cm4gRj0xMixiO2lmKDAhPT0oYSYzMikpcmV0dXJuIEY9MTEsMzI7Yj0xOTImYTtpZigwIT09YilyZXR1cm4gRj0xMCxiO2lmKDAhPT0oYSYyNTYpKXJldHVybiBGPTksMjU2O2I9MzU4NCZhO2lmKDAhPT1iKXJldHVybiBGPTgsYjtpZigwIT09KGEmNDA5NikpcmV0dXJuIEY9Nyw0MDk2O2I9NDE4NjExMiZhO2lmKDAhPT1iKXJldHVybiBGPTYsYjtiPTYyOTE0NTYwJmE7aWYoMCE9PWIpcmV0dXJuIEY9NSxiO2lmKGEmNjcxMDg4NjQpcmV0dXJuIEY9NCw2NzEwODg2NDtpZigwIT09KGEmMTM0MjE3NzI4KSlyZXR1cm4gRj0zLDEzNDIxNzcyODtiPTgwNTMwNjM2OCZhO2lmKDAhPT1iKXJldHVybiBGPTIsYjtpZigwIT09KDEwNzM3NDE4MjQmYSkpcmV0dXJuIEY9MSwxMDczNzQxODI0O1xuRj04O3JldHVybiBhfWZ1bmN0aW9uIFNjKGEpe3N3aXRjaChhKXtjYXNlIDk5OnJldHVybiAxNTtjYXNlIDk4OnJldHVybiAxMDtjYXNlIDk3OmNhc2UgOTY6cmV0dXJuIDg7Y2FzZSA5NTpyZXR1cm4gMjtkZWZhdWx0OnJldHVybiAwfX1mdW5jdGlvbiBUYyhhKXtzd2l0Y2goYSl7Y2FzZSAxNTpjYXNlIDE0OnJldHVybiA5OTtjYXNlIDEzOmNhc2UgMTI6Y2FzZSAxMTpjYXNlIDEwOnJldHVybiA5ODtjYXNlIDk6Y2FzZSA4OmNhc2UgNzpjYXNlIDY6Y2FzZSA0OmNhc2UgNTpyZXR1cm4gOTc7Y2FzZSAzOmNhc2UgMjpjYXNlIDE6cmV0dXJuIDk1O2Nhc2UgMDpyZXR1cm4gOTA7ZGVmYXVsdDp0aHJvdyBFcnJvcih5KDM1OCxhKSk7fX1cbmZ1bmN0aW9uIFVjKGEsYil7dmFyIGM9YS5wZW5kaW5nTGFuZXM7aWYoMD09PWMpcmV0dXJuIEY9MDt2YXIgZD0wLGU9MCxmPWEuZXhwaXJlZExhbmVzLGc9YS5zdXNwZW5kZWRMYW5lcyxoPWEucGluZ2VkTGFuZXM7aWYoMCE9PWYpZD1mLGU9Rj0xNTtlbHNlIGlmKGY9YyYxMzQyMTc3MjcsMCE9PWYpe3ZhciBrPWYmfmc7MCE9PWs/KGQ9UmMoayksZT1GKTooaCY9ZiwwIT09aCYmKGQ9UmMoaCksZT1GKSl9ZWxzZSBmPWMmfmcsMCE9PWY/KGQ9UmMoZiksZT1GKTowIT09aCYmKGQ9UmMoaCksZT1GKTtpZigwPT09ZClyZXR1cm4gMDtkPTMxLVZjKGQpO2Q9YyYoKDA+ZD8wOjE8PGQpPDwxKS0xO2lmKDAhPT1iJiZiIT09ZCYmMD09PShiJmcpKXtSYyhiKTtpZihlPD1GKXJldHVybiBiO0Y9ZX1iPWEuZW50YW5nbGVkTGFuZXM7aWYoMCE9PWIpZm9yKGE9YS5lbnRhbmdsZW1lbnRzLGImPWQ7MDxiOyljPTMxLVZjKGIpLGU9MTw8YyxkfD1hW2NdLGImPX5lO3JldHVybiBkfVxuZnVuY3Rpb24gV2MoYSl7YT1hLnBlbmRpbmdMYW5lcyYtMTA3Mzc0MTgyNTtyZXR1cm4gMCE9PWE/YTphJjEwNzM3NDE4MjQ/MTA3Mzc0MTgyNDowfWZ1bmN0aW9uIFhjKGEsYil7c3dpdGNoKGEpe2Nhc2UgMTU6cmV0dXJuIDE7Y2FzZSAxNDpyZXR1cm4gMjtjYXNlIDEyOnJldHVybiBhPVljKDI0Jn5iKSwwPT09YT9YYygxMCxiKTphO2Nhc2UgMTA6cmV0dXJuIGE9WWMoMTkyJn5iKSwwPT09YT9YYyg4LGIpOmE7Y2FzZSA4OnJldHVybiBhPVljKDM1ODQmfmIpLDA9PT1hJiYoYT1ZYyg0MTg2MTEyJn5iKSwwPT09YSYmKGE9NTEyKSksYTtjYXNlIDI6cmV0dXJuIGI9WWMoODA1MzA2MzY4Jn5iKSwwPT09YiYmKGI9MjY4NDM1NDU2KSxifXRocm93IEVycm9yKHkoMzU4LGEpKTt9ZnVuY3Rpb24gWWMoYSl7cmV0dXJuIGEmLWF9ZnVuY3Rpb24gWmMoYSl7Zm9yKHZhciBiPVtdLGM9MDszMT5jO2MrKyliLnB1c2goYSk7cmV0dXJuIGJ9XG5mdW5jdGlvbiAkYyhhLGIsYyl7YS5wZW5kaW5nTGFuZXN8PWI7dmFyIGQ9Yi0xO2Euc3VzcGVuZGVkTGFuZXMmPWQ7YS5waW5nZWRMYW5lcyY9ZDthPWEuZXZlbnRUaW1lcztiPTMxLVZjKGIpO2FbYl09Y312YXIgVmM9TWF0aC5jbHozMj9NYXRoLmNsejMyOmFkLGJkPU1hdGgubG9nLGNkPU1hdGguTE4yO2Z1bmN0aW9uIGFkKGEpe3JldHVybiAwPT09YT8zMjozMS0oYmQoYSkvY2R8MCl8MH12YXIgZGQ9ci51bnN0YWJsZV9Vc2VyQmxvY2tpbmdQcmlvcml0eSxlZD1yLnVuc3RhYmxlX3J1bldpdGhQcmlvcml0eSxmZD0hMDtmdW5jdGlvbiBnZChhLGIsYyxkKXtLYnx8SWIoKTt2YXIgZT1oZCxmPUtiO0tiPSEwO3RyeXtIYihlLGEsYixjLGQpfWZpbmFsbHl7KEtiPWYpfHxNYigpfX1mdW5jdGlvbiBpZChhLGIsYyxkKXtlZChkZCxoZC5iaW5kKG51bGwsYSxiLGMsZCkpfVxuZnVuY3Rpb24gaGQoYSxiLGMsZCl7aWYoZmQpe3ZhciBlO2lmKChlPTA9PT0oYiY0KSkmJjA8amMubGVuZ3RoJiYtMTxxYy5pbmRleE9mKGEpKWE9cmMobnVsbCxhLGIsYyxkKSxqYy5wdXNoKGEpO2Vsc2V7dmFyIGY9eWMoYSxiLGMsZCk7aWYobnVsbD09PWYpZSYmc2MoYSxkKTtlbHNle2lmKGUpe2lmKC0xPHFjLmluZGV4T2YoYSkpe2E9cmMoZixhLGIsYyxkKTtqYy5wdXNoKGEpO3JldHVybn1pZih1YyhmLGEsYixjLGQpKXJldHVybjtzYyhhLGQpfWpkKGEsYixkLG51bGwsYyl9fX19XG5mdW5jdGlvbiB5YyhhLGIsYyxkKXt2YXIgZT14YihkKTtlPXdjKGUpO2lmKG51bGwhPT1lKXt2YXIgZj1aYihlKTtpZihudWxsPT09ZillPW51bGw7ZWxzZXt2YXIgZz1mLnRhZztpZigxMz09PWcpe2U9JGIoZik7aWYobnVsbCE9PWUpcmV0dXJuIGU7ZT1udWxsfWVsc2UgaWYoMz09PWcpe2lmKGYuc3RhdGVOb2RlLmh5ZHJhdGUpcmV0dXJuIDM9PT1mLnRhZz9mLnN0YXRlTm9kZS5jb250YWluZXJJbmZvOm51bGw7ZT1udWxsfWVsc2UgZiE9PWUmJihlPW51bGwpfX1qZChhLGIsZCxlLGMpO3JldHVybiBudWxsfXZhciBrZD1udWxsLGxkPW51bGwsbWQ9bnVsbDtcbmZ1bmN0aW9uIG5kKCl7aWYobWQpcmV0dXJuIG1kO3ZhciBhLGI9bGQsYz1iLmxlbmd0aCxkLGU9XCJ2YWx1ZVwiaW4ga2Q/a2QudmFsdWU6a2QudGV4dENvbnRlbnQsZj1lLmxlbmd0aDtmb3IoYT0wO2E8YyYmYlthXT09PWVbYV07YSsrKTt2YXIgZz1jLWE7Zm9yKGQ9MTtkPD1nJiZiW2MtZF09PT1lW2YtZF07ZCsrKTtyZXR1cm4gbWQ9ZS5zbGljZShhLDE8ZD8xLWQ6dm9pZCAwKX1mdW5jdGlvbiBvZChhKXt2YXIgYj1hLmtleUNvZGU7XCJjaGFyQ29kZVwiaW4gYT8oYT1hLmNoYXJDb2RlLDA9PT1hJiYxMz09PWImJihhPTEzKSk6YT1iOzEwPT09YSYmKGE9MTMpO3JldHVybiAzMjw9YXx8MTM9PT1hP2E6MH1mdW5jdGlvbiBwZCgpe3JldHVybiEwfWZ1bmN0aW9uIHFkKCl7cmV0dXJuITF9XG5mdW5jdGlvbiByZChhKXtmdW5jdGlvbiBiKGIsZCxlLGYsZyl7dGhpcy5fcmVhY3ROYW1lPWI7dGhpcy5fdGFyZ2V0SW5zdD1lO3RoaXMudHlwZT1kO3RoaXMubmF0aXZlRXZlbnQ9Zjt0aGlzLnRhcmdldD1nO3RoaXMuY3VycmVudFRhcmdldD1udWxsO2Zvcih2YXIgYyBpbiBhKWEuaGFzT3duUHJvcGVydHkoYykmJihiPWFbY10sdGhpc1tjXT1iP2IoZik6ZltjXSk7dGhpcy5pc0RlZmF1bHRQcmV2ZW50ZWQ9KG51bGwhPWYuZGVmYXVsdFByZXZlbnRlZD9mLmRlZmF1bHRQcmV2ZW50ZWQ6ITE9PT1mLnJldHVyblZhbHVlKT9wZDpxZDt0aGlzLmlzUHJvcGFnYXRpb25TdG9wcGVkPXFkO3JldHVybiB0aGlzfW0oYi5wcm90b3R5cGUse3ByZXZlbnREZWZhdWx0OmZ1bmN0aW9uKCl7dGhpcy5kZWZhdWx0UHJldmVudGVkPSEwO3ZhciBhPXRoaXMubmF0aXZlRXZlbnQ7YSYmKGEucHJldmVudERlZmF1bHQ/YS5wcmV2ZW50RGVmYXVsdCgpOlwidW5rbm93blwiIT09dHlwZW9mIGEucmV0dXJuVmFsdWUmJlxuKGEucmV0dXJuVmFsdWU9ITEpLHRoaXMuaXNEZWZhdWx0UHJldmVudGVkPXBkKX0sc3RvcFByb3BhZ2F0aW9uOmZ1bmN0aW9uKCl7dmFyIGE9dGhpcy5uYXRpdmVFdmVudDthJiYoYS5zdG9wUHJvcGFnYXRpb24/YS5zdG9wUHJvcGFnYXRpb24oKTpcInVua25vd25cIiE9PXR5cGVvZiBhLmNhbmNlbEJ1YmJsZSYmKGEuY2FuY2VsQnViYmxlPSEwKSx0aGlzLmlzUHJvcGFnYXRpb25TdG9wcGVkPXBkKX0scGVyc2lzdDpmdW5jdGlvbigpe30saXNQZXJzaXN0ZW50OnBkfSk7cmV0dXJuIGJ9XG52YXIgc2Q9e2V2ZW50UGhhc2U6MCxidWJibGVzOjAsY2FuY2VsYWJsZTowLHRpbWVTdGFtcDpmdW5jdGlvbihhKXtyZXR1cm4gYS50aW1lU3RhbXB8fERhdGUubm93KCl9LGRlZmF1bHRQcmV2ZW50ZWQ6MCxpc1RydXN0ZWQ6MH0sdGQ9cmQoc2QpLHVkPW0oe30sc2Qse3ZpZXc6MCxkZXRhaWw6MH0pLHZkPXJkKHVkKSx3ZCx4ZCx5ZCxBZD1tKHt9LHVkLHtzY3JlZW5YOjAsc2NyZWVuWTowLGNsaWVudFg6MCxjbGllbnRZOjAscGFnZVg6MCxwYWdlWTowLGN0cmxLZXk6MCxzaGlmdEtleTowLGFsdEtleTowLG1ldGFLZXk6MCxnZXRNb2RpZmllclN0YXRlOnpkLGJ1dHRvbjowLGJ1dHRvbnM6MCxyZWxhdGVkVGFyZ2V0OmZ1bmN0aW9uKGEpe3JldHVybiB2b2lkIDA9PT1hLnJlbGF0ZWRUYXJnZXQ/YS5mcm9tRWxlbWVudD09PWEuc3JjRWxlbWVudD9hLnRvRWxlbWVudDphLmZyb21FbGVtZW50OmEucmVsYXRlZFRhcmdldH0sbW92ZW1lbnRYOmZ1bmN0aW9uKGEpe2lmKFwibW92ZW1lbnRYXCJpblxuYSlyZXR1cm4gYS5tb3ZlbWVudFg7YSE9PXlkJiYoeWQmJlwibW91c2Vtb3ZlXCI9PT1hLnR5cGU/KHdkPWEuc2NyZWVuWC15ZC5zY3JlZW5YLHhkPWEuc2NyZWVuWS15ZC5zY3JlZW5ZKTp4ZD13ZD0wLHlkPWEpO3JldHVybiB3ZH0sbW92ZW1lbnRZOmZ1bmN0aW9uKGEpe3JldHVyblwibW92ZW1lbnRZXCJpbiBhP2EubW92ZW1lbnRZOnhkfX0pLEJkPXJkKEFkKSxDZD1tKHt9LEFkLHtkYXRhVHJhbnNmZXI6MH0pLERkPXJkKENkKSxFZD1tKHt9LHVkLHtyZWxhdGVkVGFyZ2V0OjB9KSxGZD1yZChFZCksR2Q9bSh7fSxzZCx7YW5pbWF0aW9uTmFtZTowLGVsYXBzZWRUaW1lOjAscHNldWRvRWxlbWVudDowfSksSGQ9cmQoR2QpLElkPW0oe30sc2Qse2NsaXBib2FyZERhdGE6ZnVuY3Rpb24oYSl7cmV0dXJuXCJjbGlwYm9hcmREYXRhXCJpbiBhP2EuY2xpcGJvYXJkRGF0YTp3aW5kb3cuY2xpcGJvYXJkRGF0YX19KSxKZD1yZChJZCksS2Q9bSh7fSxzZCx7ZGF0YTowfSksTGQ9cmQoS2QpLE1kPXtFc2M6XCJFc2NhcGVcIixcblNwYWNlYmFyOlwiIFwiLExlZnQ6XCJBcnJvd0xlZnRcIixVcDpcIkFycm93VXBcIixSaWdodDpcIkFycm93UmlnaHRcIixEb3duOlwiQXJyb3dEb3duXCIsRGVsOlwiRGVsZXRlXCIsV2luOlwiT1NcIixNZW51OlwiQ29udGV4dE1lbnVcIixBcHBzOlwiQ29udGV4dE1lbnVcIixTY3JvbGw6XCJTY3JvbGxMb2NrXCIsTW96UHJpbnRhYmxlS2V5OlwiVW5pZGVudGlmaWVkXCJ9LE5kPXs4OlwiQmFja3NwYWNlXCIsOTpcIlRhYlwiLDEyOlwiQ2xlYXJcIiwxMzpcIkVudGVyXCIsMTY6XCJTaGlmdFwiLDE3OlwiQ29udHJvbFwiLDE4OlwiQWx0XCIsMTk6XCJQYXVzZVwiLDIwOlwiQ2Fwc0xvY2tcIiwyNzpcIkVzY2FwZVwiLDMyOlwiIFwiLDMzOlwiUGFnZVVwXCIsMzQ6XCJQYWdlRG93blwiLDM1OlwiRW5kXCIsMzY6XCJIb21lXCIsMzc6XCJBcnJvd0xlZnRcIiwzODpcIkFycm93VXBcIiwzOTpcIkFycm93UmlnaHRcIiw0MDpcIkFycm93RG93blwiLDQ1OlwiSW5zZXJ0XCIsNDY6XCJEZWxldGVcIiwxMTI6XCJGMVwiLDExMzpcIkYyXCIsMTE0OlwiRjNcIiwxMTU6XCJGNFwiLDExNjpcIkY1XCIsMTE3OlwiRjZcIiwxMTg6XCJGN1wiLFxuMTE5OlwiRjhcIiwxMjA6XCJGOVwiLDEyMTpcIkYxMFwiLDEyMjpcIkYxMVwiLDEyMzpcIkYxMlwiLDE0NDpcIk51bUxvY2tcIiwxNDU6XCJTY3JvbGxMb2NrXCIsMjI0OlwiTWV0YVwifSxPZD17QWx0OlwiYWx0S2V5XCIsQ29udHJvbDpcImN0cmxLZXlcIixNZXRhOlwibWV0YUtleVwiLFNoaWZ0Olwic2hpZnRLZXlcIn07ZnVuY3Rpb24gUGQoYSl7dmFyIGI9dGhpcy5uYXRpdmVFdmVudDtyZXR1cm4gYi5nZXRNb2RpZmllclN0YXRlP2IuZ2V0TW9kaWZpZXJTdGF0ZShhKTooYT1PZFthXSk/ISFiW2FdOiExfWZ1bmN0aW9uIHpkKCl7cmV0dXJuIFBkfVxudmFyIFFkPW0oe30sdWQse2tleTpmdW5jdGlvbihhKXtpZihhLmtleSl7dmFyIGI9TWRbYS5rZXldfHxhLmtleTtpZihcIlVuaWRlbnRpZmllZFwiIT09YilyZXR1cm4gYn1yZXR1cm5cImtleXByZXNzXCI9PT1hLnR5cGU/KGE9b2QoYSksMTM9PT1hP1wiRW50ZXJcIjpTdHJpbmcuZnJvbUNoYXJDb2RlKGEpKTpcImtleWRvd25cIj09PWEudHlwZXx8XCJrZXl1cFwiPT09YS50eXBlP05kW2Eua2V5Q29kZV18fFwiVW5pZGVudGlmaWVkXCI6XCJcIn0sY29kZTowLGxvY2F0aW9uOjAsY3RybEtleTowLHNoaWZ0S2V5OjAsYWx0S2V5OjAsbWV0YUtleTowLHJlcGVhdDowLGxvY2FsZTowLGdldE1vZGlmaWVyU3RhdGU6emQsY2hhckNvZGU6ZnVuY3Rpb24oYSl7cmV0dXJuXCJrZXlwcmVzc1wiPT09YS50eXBlP29kKGEpOjB9LGtleUNvZGU6ZnVuY3Rpb24oYSl7cmV0dXJuXCJrZXlkb3duXCI9PT1hLnR5cGV8fFwia2V5dXBcIj09PWEudHlwZT9hLmtleUNvZGU6MH0sd2hpY2g6ZnVuY3Rpb24oYSl7cmV0dXJuXCJrZXlwcmVzc1wiPT09XG5hLnR5cGU/b2QoYSk6XCJrZXlkb3duXCI9PT1hLnR5cGV8fFwia2V5dXBcIj09PWEudHlwZT9hLmtleUNvZGU6MH19KSxSZD1yZChRZCksU2Q9bSh7fSxBZCx7cG9pbnRlcklkOjAsd2lkdGg6MCxoZWlnaHQ6MCxwcmVzc3VyZTowLHRhbmdlbnRpYWxQcmVzc3VyZTowLHRpbHRYOjAsdGlsdFk6MCx0d2lzdDowLHBvaW50ZXJUeXBlOjAsaXNQcmltYXJ5OjB9KSxUZD1yZChTZCksVWQ9bSh7fSx1ZCx7dG91Y2hlczowLHRhcmdldFRvdWNoZXM6MCxjaGFuZ2VkVG91Y2hlczowLGFsdEtleTowLG1ldGFLZXk6MCxjdHJsS2V5OjAsc2hpZnRLZXk6MCxnZXRNb2RpZmllclN0YXRlOnpkfSksVmQ9cmQoVWQpLFdkPW0oe30sc2Qse3Byb3BlcnR5TmFtZTowLGVsYXBzZWRUaW1lOjAscHNldWRvRWxlbWVudDowfSksWGQ9cmQoV2QpLFlkPW0oe30sQWQse2RlbHRhWDpmdW5jdGlvbihhKXtyZXR1cm5cImRlbHRhWFwiaW4gYT9hLmRlbHRhWDpcIndoZWVsRGVsdGFYXCJpbiBhPy1hLndoZWVsRGVsdGFYOjB9LFxuZGVsdGFZOmZ1bmN0aW9uKGEpe3JldHVyblwiZGVsdGFZXCJpbiBhP2EuZGVsdGFZOlwid2hlZWxEZWx0YVlcImluIGE/LWEud2hlZWxEZWx0YVk6XCJ3aGVlbERlbHRhXCJpbiBhPy1hLndoZWVsRGVsdGE6MH0sZGVsdGFaOjAsZGVsdGFNb2RlOjB9KSxaZD1yZChZZCksJGQ9WzksMTMsMjcsMzJdLGFlPWZhJiZcIkNvbXBvc2l0aW9uRXZlbnRcImluIHdpbmRvdyxiZT1udWxsO2ZhJiZcImRvY3VtZW50TW9kZVwiaW4gZG9jdW1lbnQmJihiZT1kb2N1bWVudC5kb2N1bWVudE1vZGUpO3ZhciBjZT1mYSYmXCJUZXh0RXZlbnRcImluIHdpbmRvdyYmIWJlLGRlPWZhJiYoIWFlfHxiZSYmODxiZSYmMTE+PWJlKSxlZT1TdHJpbmcuZnJvbUNoYXJDb2RlKDMyKSxmZT0hMTtcbmZ1bmN0aW9uIGdlKGEsYil7c3dpdGNoKGEpe2Nhc2UgXCJrZXl1cFwiOnJldHVybi0xIT09JGQuaW5kZXhPZihiLmtleUNvZGUpO2Nhc2UgXCJrZXlkb3duXCI6cmV0dXJuIDIyOSE9PWIua2V5Q29kZTtjYXNlIFwia2V5cHJlc3NcIjpjYXNlIFwibW91c2Vkb3duXCI6Y2FzZSBcImZvY3Vzb3V0XCI6cmV0dXJuITA7ZGVmYXVsdDpyZXR1cm4hMX19ZnVuY3Rpb24gaGUoYSl7YT1hLmRldGFpbDtyZXR1cm5cIm9iamVjdFwiPT09dHlwZW9mIGEmJlwiZGF0YVwiaW4gYT9hLmRhdGE6bnVsbH12YXIgaWU9ITE7ZnVuY3Rpb24gamUoYSxiKXtzd2l0Y2goYSl7Y2FzZSBcImNvbXBvc2l0aW9uZW5kXCI6cmV0dXJuIGhlKGIpO2Nhc2UgXCJrZXlwcmVzc1wiOmlmKDMyIT09Yi53aGljaClyZXR1cm4gbnVsbDtmZT0hMDtyZXR1cm4gZWU7Y2FzZSBcInRleHRJbnB1dFwiOnJldHVybiBhPWIuZGF0YSxhPT09ZWUmJmZlP251bGw6YTtkZWZhdWx0OnJldHVybiBudWxsfX1cbmZ1bmN0aW9uIGtlKGEsYil7aWYoaWUpcmV0dXJuXCJjb21wb3NpdGlvbmVuZFwiPT09YXx8IWFlJiZnZShhLGIpPyhhPW5kKCksbWQ9bGQ9a2Q9bnVsbCxpZT0hMSxhKTpudWxsO3N3aXRjaChhKXtjYXNlIFwicGFzdGVcIjpyZXR1cm4gbnVsbDtjYXNlIFwia2V5cHJlc3NcIjppZighKGIuY3RybEtleXx8Yi5hbHRLZXl8fGIubWV0YUtleSl8fGIuY3RybEtleSYmYi5hbHRLZXkpe2lmKGIuY2hhciYmMTxiLmNoYXIubGVuZ3RoKXJldHVybiBiLmNoYXI7aWYoYi53aGljaClyZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShiLndoaWNoKX1yZXR1cm4gbnVsbDtjYXNlIFwiY29tcG9zaXRpb25lbmRcIjpyZXR1cm4gZGUmJlwia29cIiE9PWIubG9jYWxlP251bGw6Yi5kYXRhO2RlZmF1bHQ6cmV0dXJuIG51bGx9fVxudmFyIGxlPXtjb2xvcjohMCxkYXRlOiEwLGRhdGV0aW1lOiEwLFwiZGF0ZXRpbWUtbG9jYWxcIjohMCxlbWFpbDohMCxtb250aDohMCxudW1iZXI6ITAscGFzc3dvcmQ6ITAscmFuZ2U6ITAsc2VhcmNoOiEwLHRlbDohMCx0ZXh0OiEwLHRpbWU6ITAsdXJsOiEwLHdlZWs6ITB9O2Z1bmN0aW9uIG1lKGEpe3ZhciBiPWEmJmEubm9kZU5hbWUmJmEubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtyZXR1cm5cImlucHV0XCI9PT1iPyEhbGVbYS50eXBlXTpcInRleHRhcmVhXCI9PT1iPyEwOiExfWZ1bmN0aW9uIG5lKGEsYixjLGQpe0ViKGQpO2I9b2UoYixcIm9uQ2hhbmdlXCIpOzA8Yi5sZW5ndGgmJihjPW5ldyB0ZChcIm9uQ2hhbmdlXCIsXCJjaGFuZ2VcIixudWxsLGMsZCksYS5wdXNoKHtldmVudDpjLGxpc3RlbmVyczpifSkpfXZhciBwZT1udWxsLHFlPW51bGw7ZnVuY3Rpb24gcmUoYSl7c2UoYSwwKX1mdW5jdGlvbiB0ZShhKXt2YXIgYj11ZShhKTtpZihXYShiKSlyZXR1cm4gYX1cbmZ1bmN0aW9uIHZlKGEsYil7aWYoXCJjaGFuZ2VcIj09PWEpcmV0dXJuIGJ9dmFyIHdlPSExO2lmKGZhKXt2YXIgeGU7aWYoZmEpe3ZhciB5ZT1cIm9uaW5wdXRcImluIGRvY3VtZW50O2lmKCF5ZSl7dmFyIHplPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7emUuc2V0QXR0cmlidXRlKFwib25pbnB1dFwiLFwicmV0dXJuO1wiKTt5ZT1cImZ1bmN0aW9uXCI9PT10eXBlb2YgemUub25pbnB1dH14ZT15ZX1lbHNlIHhlPSExO3dlPXhlJiYoIWRvY3VtZW50LmRvY3VtZW50TW9kZXx8OTxkb2N1bWVudC5kb2N1bWVudE1vZGUpfWZ1bmN0aW9uIEFlKCl7cGUmJihwZS5kZXRhY2hFdmVudChcIm9ucHJvcGVydHljaGFuZ2VcIixCZSkscWU9cGU9bnVsbCl9ZnVuY3Rpb24gQmUoYSl7aWYoXCJ2YWx1ZVwiPT09YS5wcm9wZXJ0eU5hbWUmJnRlKHFlKSl7dmFyIGI9W107bmUoYixxZSxhLHhiKGEpKTthPXJlO2lmKEtiKWEoYik7ZWxzZXtLYj0hMDt0cnl7R2IoYSxiKX1maW5hbGx5e0tiPSExLE1iKCl9fX19XG5mdW5jdGlvbiBDZShhLGIsYyl7XCJmb2N1c2luXCI9PT1hPyhBZSgpLHBlPWIscWU9YyxwZS5hdHRhY2hFdmVudChcIm9ucHJvcGVydHljaGFuZ2VcIixCZSkpOlwiZm9jdXNvdXRcIj09PWEmJkFlKCl9ZnVuY3Rpb24gRGUoYSl7aWYoXCJzZWxlY3Rpb25jaGFuZ2VcIj09PWF8fFwia2V5dXBcIj09PWF8fFwia2V5ZG93blwiPT09YSlyZXR1cm4gdGUocWUpfWZ1bmN0aW9uIEVlKGEsYil7aWYoXCJjbGlja1wiPT09YSlyZXR1cm4gdGUoYil9ZnVuY3Rpb24gRmUoYSxiKXtpZihcImlucHV0XCI9PT1hfHxcImNoYW5nZVwiPT09YSlyZXR1cm4gdGUoYil9ZnVuY3Rpb24gR2UoYSxiKXtyZXR1cm4gYT09PWImJigwIT09YXx8MS9hPT09MS9iKXx8YSE9PWEmJmIhPT1ifXZhciBIZT1cImZ1bmN0aW9uXCI9PT10eXBlb2YgT2JqZWN0LmlzP09iamVjdC5pczpHZSxJZT1PYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuZnVuY3Rpb24gSmUoYSxiKXtpZihIZShhLGIpKXJldHVybiEwO2lmKFwib2JqZWN0XCIhPT10eXBlb2YgYXx8bnVsbD09PWF8fFwib2JqZWN0XCIhPT10eXBlb2YgYnx8bnVsbD09PWIpcmV0dXJuITE7dmFyIGM9T2JqZWN0LmtleXMoYSksZD1PYmplY3Qua2V5cyhiKTtpZihjLmxlbmd0aCE9PWQubGVuZ3RoKXJldHVybiExO2ZvcihkPTA7ZDxjLmxlbmd0aDtkKyspaWYoIUllLmNhbGwoYixjW2RdKXx8IUhlKGFbY1tkXV0sYltjW2RdXSkpcmV0dXJuITE7cmV0dXJuITB9ZnVuY3Rpb24gS2UoYSl7Zm9yKDthJiZhLmZpcnN0Q2hpbGQ7KWE9YS5maXJzdENoaWxkO3JldHVybiBhfVxuZnVuY3Rpb24gTGUoYSxiKXt2YXIgYz1LZShhKTthPTA7Zm9yKHZhciBkO2M7KXtpZigzPT09Yy5ub2RlVHlwZSl7ZD1hK2MudGV4dENvbnRlbnQubGVuZ3RoO2lmKGE8PWImJmQ+PWIpcmV0dXJue25vZGU6YyxvZmZzZXQ6Yi1hfTthPWR9YTp7Zm9yKDtjOyl7aWYoYy5uZXh0U2libGluZyl7Yz1jLm5leHRTaWJsaW5nO2JyZWFrIGF9Yz1jLnBhcmVudE5vZGV9Yz12b2lkIDB9Yz1LZShjKX19ZnVuY3Rpb24gTWUoYSxiKXtyZXR1cm4gYSYmYj9hPT09Yj8hMDphJiYzPT09YS5ub2RlVHlwZT8hMTpiJiYzPT09Yi5ub2RlVHlwZT9NZShhLGIucGFyZW50Tm9kZSk6XCJjb250YWluc1wiaW4gYT9hLmNvbnRhaW5zKGIpOmEuY29tcGFyZURvY3VtZW50UG9zaXRpb24/ISEoYS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbihiKSYxNik6ITE6ITF9XG5mdW5jdGlvbiBOZSgpe2Zvcih2YXIgYT13aW5kb3csYj1YYSgpO2IgaW5zdGFuY2VvZiBhLkhUTUxJRnJhbWVFbGVtZW50Oyl7dHJ5e3ZhciBjPVwic3RyaW5nXCI9PT10eXBlb2YgYi5jb250ZW50V2luZG93LmxvY2F0aW9uLmhyZWZ9Y2F0Y2goZCl7Yz0hMX1pZihjKWE9Yi5jb250ZW50V2luZG93O2Vsc2UgYnJlYWs7Yj1YYShhLmRvY3VtZW50KX1yZXR1cm4gYn1mdW5jdGlvbiBPZShhKXt2YXIgYj1hJiZhLm5vZGVOYW1lJiZhLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7cmV0dXJuIGImJihcImlucHV0XCI9PT1iJiYoXCJ0ZXh0XCI9PT1hLnR5cGV8fFwic2VhcmNoXCI9PT1hLnR5cGV8fFwidGVsXCI9PT1hLnR5cGV8fFwidXJsXCI9PT1hLnR5cGV8fFwicGFzc3dvcmRcIj09PWEudHlwZSl8fFwidGV4dGFyZWFcIj09PWJ8fFwidHJ1ZVwiPT09YS5jb250ZW50RWRpdGFibGUpfVxudmFyIFBlPWZhJiZcImRvY3VtZW50TW9kZVwiaW4gZG9jdW1lbnQmJjExPj1kb2N1bWVudC5kb2N1bWVudE1vZGUsUWU9bnVsbCxSZT1udWxsLFNlPW51bGwsVGU9ITE7XG5mdW5jdGlvbiBVZShhLGIsYyl7dmFyIGQ9Yy53aW5kb3c9PT1jP2MuZG9jdW1lbnQ6OT09PWMubm9kZVR5cGU/YzpjLm93bmVyRG9jdW1lbnQ7VGV8fG51bGw9PVFlfHxRZSE9PVhhKGQpfHwoZD1RZSxcInNlbGVjdGlvblN0YXJ0XCJpbiBkJiZPZShkKT9kPXtzdGFydDpkLnNlbGVjdGlvblN0YXJ0LGVuZDpkLnNlbGVjdGlvbkVuZH06KGQ9KGQub3duZXJEb2N1bWVudCYmZC5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3fHx3aW5kb3cpLmdldFNlbGVjdGlvbigpLGQ9e2FuY2hvck5vZGU6ZC5hbmNob3JOb2RlLGFuY2hvck9mZnNldDpkLmFuY2hvck9mZnNldCxmb2N1c05vZGU6ZC5mb2N1c05vZGUsZm9jdXNPZmZzZXQ6ZC5mb2N1c09mZnNldH0pLFNlJiZKZShTZSxkKXx8KFNlPWQsZD1vZShSZSxcIm9uU2VsZWN0XCIpLDA8ZC5sZW5ndGgmJihiPW5ldyB0ZChcIm9uU2VsZWN0XCIsXCJzZWxlY3RcIixudWxsLGIsYyksYS5wdXNoKHtldmVudDpiLGxpc3RlbmVyczpkfSksYi50YXJnZXQ9UWUpKSl9XG5QYyhcImNhbmNlbCBjYW5jZWwgY2xpY2sgY2xpY2sgY2xvc2UgY2xvc2UgY29udGV4dG1lbnUgY29udGV4dE1lbnUgY29weSBjb3B5IGN1dCBjdXQgYXV4Y2xpY2sgYXV4Q2xpY2sgZGJsY2xpY2sgZG91YmxlQ2xpY2sgZHJhZ2VuZCBkcmFnRW5kIGRyYWdzdGFydCBkcmFnU3RhcnQgZHJvcCBkcm9wIGZvY3VzaW4gZm9jdXMgZm9jdXNvdXQgYmx1ciBpbnB1dCBpbnB1dCBpbnZhbGlkIGludmFsaWQga2V5ZG93biBrZXlEb3duIGtleXByZXNzIGtleVByZXNzIGtleXVwIGtleVVwIG1vdXNlZG93biBtb3VzZURvd24gbW91c2V1cCBtb3VzZVVwIHBhc3RlIHBhc3RlIHBhdXNlIHBhdXNlIHBsYXkgcGxheSBwb2ludGVyY2FuY2VsIHBvaW50ZXJDYW5jZWwgcG9pbnRlcmRvd24gcG9pbnRlckRvd24gcG9pbnRlcnVwIHBvaW50ZXJVcCByYXRlY2hhbmdlIHJhdGVDaGFuZ2UgcmVzZXQgcmVzZXQgc2Vla2VkIHNlZWtlZCBzdWJtaXQgc3VibWl0IHRvdWNoY2FuY2VsIHRvdWNoQ2FuY2VsIHRvdWNoZW5kIHRvdWNoRW5kIHRvdWNoc3RhcnQgdG91Y2hTdGFydCB2b2x1bWVjaGFuZ2Ugdm9sdW1lQ2hhbmdlXCIuc3BsaXQoXCIgXCIpLFxuMCk7UGMoXCJkcmFnIGRyYWcgZHJhZ2VudGVyIGRyYWdFbnRlciBkcmFnZXhpdCBkcmFnRXhpdCBkcmFnbGVhdmUgZHJhZ0xlYXZlIGRyYWdvdmVyIGRyYWdPdmVyIG1vdXNlbW92ZSBtb3VzZU1vdmUgbW91c2VvdXQgbW91c2VPdXQgbW91c2VvdmVyIG1vdXNlT3ZlciBwb2ludGVybW92ZSBwb2ludGVyTW92ZSBwb2ludGVyb3V0IHBvaW50ZXJPdXQgcG9pbnRlcm92ZXIgcG9pbnRlck92ZXIgc2Nyb2xsIHNjcm9sbCB0b2dnbGUgdG9nZ2xlIHRvdWNobW92ZSB0b3VjaE1vdmUgd2hlZWwgd2hlZWxcIi5zcGxpdChcIiBcIiksMSk7UGMoT2MsMik7Zm9yKHZhciBWZT1cImNoYW5nZSBzZWxlY3Rpb25jaGFuZ2UgdGV4dElucHV0IGNvbXBvc2l0aW9uc3RhcnQgY29tcG9zaXRpb25lbmQgY29tcG9zaXRpb251cGRhdGVcIi5zcGxpdChcIiBcIiksV2U9MDtXZTxWZS5sZW5ndGg7V2UrKylOYy5zZXQoVmVbV2VdLDApO2VhKFwib25Nb3VzZUVudGVyXCIsW1wibW91c2VvdXRcIixcIm1vdXNlb3ZlclwiXSk7XG5lYShcIm9uTW91c2VMZWF2ZVwiLFtcIm1vdXNlb3V0XCIsXCJtb3VzZW92ZXJcIl0pO2VhKFwib25Qb2ludGVyRW50ZXJcIixbXCJwb2ludGVyb3V0XCIsXCJwb2ludGVyb3ZlclwiXSk7ZWEoXCJvblBvaW50ZXJMZWF2ZVwiLFtcInBvaW50ZXJvdXRcIixcInBvaW50ZXJvdmVyXCJdKTtkYShcIm9uQ2hhbmdlXCIsXCJjaGFuZ2UgY2xpY2sgZm9jdXNpbiBmb2N1c291dCBpbnB1dCBrZXlkb3duIGtleXVwIHNlbGVjdGlvbmNoYW5nZVwiLnNwbGl0KFwiIFwiKSk7ZGEoXCJvblNlbGVjdFwiLFwiZm9jdXNvdXQgY29udGV4dG1lbnUgZHJhZ2VuZCBmb2N1c2luIGtleWRvd24ga2V5dXAgbW91c2Vkb3duIG1vdXNldXAgc2VsZWN0aW9uY2hhbmdlXCIuc3BsaXQoXCIgXCIpKTtkYShcIm9uQmVmb3JlSW5wdXRcIixbXCJjb21wb3NpdGlvbmVuZFwiLFwia2V5cHJlc3NcIixcInRleHRJbnB1dFwiLFwicGFzdGVcIl0pO2RhKFwib25Db21wb3NpdGlvbkVuZFwiLFwiY29tcG9zaXRpb25lbmQgZm9jdXNvdXQga2V5ZG93biBrZXlwcmVzcyBrZXl1cCBtb3VzZWRvd25cIi5zcGxpdChcIiBcIikpO1xuZGEoXCJvbkNvbXBvc2l0aW9uU3RhcnRcIixcImNvbXBvc2l0aW9uc3RhcnQgZm9jdXNvdXQga2V5ZG93biBrZXlwcmVzcyBrZXl1cCBtb3VzZWRvd25cIi5zcGxpdChcIiBcIikpO2RhKFwib25Db21wb3NpdGlvblVwZGF0ZVwiLFwiY29tcG9zaXRpb251cGRhdGUgZm9jdXNvdXQga2V5ZG93biBrZXlwcmVzcyBrZXl1cCBtb3VzZWRvd25cIi5zcGxpdChcIiBcIikpO3ZhciBYZT1cImFib3J0IGNhbnBsYXkgY2FucGxheXRocm91Z2ggZHVyYXRpb25jaGFuZ2UgZW1wdGllZCBlbmNyeXB0ZWQgZW5kZWQgZXJyb3IgbG9hZGVkZGF0YSBsb2FkZWRtZXRhZGF0YSBsb2Fkc3RhcnQgcGF1c2UgcGxheSBwbGF5aW5nIHByb2dyZXNzIHJhdGVjaGFuZ2Ugc2Vla2VkIHNlZWtpbmcgc3RhbGxlZCBzdXNwZW5kIHRpbWV1cGRhdGUgdm9sdW1lY2hhbmdlIHdhaXRpbmdcIi5zcGxpdChcIiBcIiksWWU9bmV3IFNldChcImNhbmNlbCBjbG9zZSBpbnZhbGlkIGxvYWQgc2Nyb2xsIHRvZ2dsZVwiLnNwbGl0KFwiIFwiKS5jb25jYXQoWGUpKTtcbmZ1bmN0aW9uIFplKGEsYixjKXt2YXIgZD1hLnR5cGV8fFwidW5rbm93bi1ldmVudFwiO2EuY3VycmVudFRhcmdldD1jO1liKGQsYix2b2lkIDAsYSk7YS5jdXJyZW50VGFyZ2V0PW51bGx9XG5mdW5jdGlvbiBzZShhLGIpe2I9MCE9PShiJjQpO2Zvcih2YXIgYz0wO2M8YS5sZW5ndGg7YysrKXt2YXIgZD1hW2NdLGU9ZC5ldmVudDtkPWQubGlzdGVuZXJzO2E6e3ZhciBmPXZvaWQgMDtpZihiKWZvcih2YXIgZz1kLmxlbmd0aC0xOzA8PWc7Zy0tKXt2YXIgaD1kW2ddLGs9aC5pbnN0YW5jZSxsPWguY3VycmVudFRhcmdldDtoPWgubGlzdGVuZXI7aWYoayE9PWYmJmUuaXNQcm9wYWdhdGlvblN0b3BwZWQoKSlicmVhayBhO1plKGUsaCxsKTtmPWt9ZWxzZSBmb3IoZz0wO2c8ZC5sZW5ndGg7ZysrKXtoPWRbZ107az1oLmluc3RhbmNlO2w9aC5jdXJyZW50VGFyZ2V0O2g9aC5saXN0ZW5lcjtpZihrIT09ZiYmZS5pc1Byb3BhZ2F0aW9uU3RvcHBlZCgpKWJyZWFrIGE7WmUoZSxoLGwpO2Y9a319fWlmKFViKXRocm93IGE9VmIsVWI9ITEsVmI9bnVsbCxhO31cbmZ1bmN0aW9uIEcoYSxiKXt2YXIgYz0kZShiKSxkPWErXCJfX2J1YmJsZVwiO2MuaGFzKGQpfHwoYWYoYixhLDIsITEpLGMuYWRkKGQpKX12YXIgYmY9XCJfcmVhY3RMaXN0ZW5pbmdcIitNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zbGljZSgyKTtmdW5jdGlvbiBjZihhKXthW2JmXXx8KGFbYmZdPSEwLGJhLmZvckVhY2goZnVuY3Rpb24oYil7WWUuaGFzKGIpfHxkZihiLCExLGEsbnVsbCk7ZGYoYiwhMCxhLG51bGwpfSkpfVxuZnVuY3Rpb24gZGYoYSxiLGMsZCl7dmFyIGU9NDxhcmd1bWVudHMubGVuZ3RoJiZ2b2lkIDAhPT1hcmd1bWVudHNbNF0/YXJndW1lbnRzWzRdOjAsZj1jO1wic2VsZWN0aW9uY2hhbmdlXCI9PT1hJiY5IT09Yy5ub2RlVHlwZSYmKGY9Yy5vd25lckRvY3VtZW50KTtpZihudWxsIT09ZCYmIWImJlllLmhhcyhhKSl7aWYoXCJzY3JvbGxcIiE9PWEpcmV0dXJuO2V8PTI7Zj1kfXZhciBnPSRlKGYpLGg9YStcIl9fXCIrKGI/XCJjYXB0dXJlXCI6XCJidWJibGVcIik7Zy5oYXMoaCl8fChiJiYoZXw9NCksYWYoZixhLGUsYiksZy5hZGQoaCkpfVxuZnVuY3Rpb24gYWYoYSxiLGMsZCl7dmFyIGU9TmMuZ2V0KGIpO3N3aXRjaCh2b2lkIDA9PT1lPzI6ZSl7Y2FzZSAwOmU9Z2Q7YnJlYWs7Y2FzZSAxOmU9aWQ7YnJlYWs7ZGVmYXVsdDplPWhkfWM9ZS5iaW5kKG51bGwsYixjLGEpO2U9dm9pZCAwOyFQYnx8XCJ0b3VjaHN0YXJ0XCIhPT1iJiZcInRvdWNobW92ZVwiIT09YiYmXCJ3aGVlbFwiIT09Ynx8KGU9ITApO2Q/dm9pZCAwIT09ZT9hLmFkZEV2ZW50TGlzdGVuZXIoYixjLHtjYXB0dXJlOiEwLHBhc3NpdmU6ZX0pOmEuYWRkRXZlbnRMaXN0ZW5lcihiLGMsITApOnZvaWQgMCE9PWU/YS5hZGRFdmVudExpc3RlbmVyKGIsYyx7cGFzc2l2ZTplfSk6YS5hZGRFdmVudExpc3RlbmVyKGIsYywhMSl9XG5mdW5jdGlvbiBqZChhLGIsYyxkLGUpe3ZhciBmPWQ7aWYoMD09PShiJjEpJiYwPT09KGImMikmJm51bGwhPT1kKWE6Zm9yKDs7KXtpZihudWxsPT09ZClyZXR1cm47dmFyIGc9ZC50YWc7aWYoMz09PWd8fDQ9PT1nKXt2YXIgaD1kLnN0YXRlTm9kZS5jb250YWluZXJJbmZvO2lmKGg9PT1lfHw4PT09aC5ub2RlVHlwZSYmaC5wYXJlbnROb2RlPT09ZSlicmVhaztpZig0PT09Zylmb3IoZz1kLnJldHVybjtudWxsIT09Zzspe3ZhciBrPWcudGFnO2lmKDM9PT1rfHw0PT09aylpZihrPWcuc3RhdGVOb2RlLmNvbnRhaW5lckluZm8saz09PWV8fDg9PT1rLm5vZGVUeXBlJiZrLnBhcmVudE5vZGU9PT1lKXJldHVybjtnPWcucmV0dXJufWZvcig7bnVsbCE9PWg7KXtnPXdjKGgpO2lmKG51bGw9PT1nKXJldHVybjtrPWcudGFnO2lmKDU9PT1rfHw2PT09ayl7ZD1mPWc7Y29udGludWUgYX1oPWgucGFyZW50Tm9kZX19ZD1kLnJldHVybn1OYihmdW5jdGlvbigpe3ZhciBkPWYsZT14YihjKSxnPVtdO1xuYTp7dmFyIGg9TWMuZ2V0KGEpO2lmKHZvaWQgMCE9PWgpe3ZhciBrPXRkLHg9YTtzd2l0Y2goYSl7Y2FzZSBcImtleXByZXNzXCI6aWYoMD09PW9kKGMpKWJyZWFrIGE7Y2FzZSBcImtleWRvd25cIjpjYXNlIFwia2V5dXBcIjprPVJkO2JyZWFrO2Nhc2UgXCJmb2N1c2luXCI6eD1cImZvY3VzXCI7az1GZDticmVhaztjYXNlIFwiZm9jdXNvdXRcIjp4PVwiYmx1clwiO2s9RmQ7YnJlYWs7Y2FzZSBcImJlZm9yZWJsdXJcIjpjYXNlIFwiYWZ0ZXJibHVyXCI6az1GZDticmVhaztjYXNlIFwiY2xpY2tcIjppZigyPT09Yy5idXR0b24pYnJlYWsgYTtjYXNlIFwiYXV4Y2xpY2tcIjpjYXNlIFwiZGJsY2xpY2tcIjpjYXNlIFwibW91c2Vkb3duXCI6Y2FzZSBcIm1vdXNlbW92ZVwiOmNhc2UgXCJtb3VzZXVwXCI6Y2FzZSBcIm1vdXNlb3V0XCI6Y2FzZSBcIm1vdXNlb3ZlclwiOmNhc2UgXCJjb250ZXh0bWVudVwiOms9QmQ7YnJlYWs7Y2FzZSBcImRyYWdcIjpjYXNlIFwiZHJhZ2VuZFwiOmNhc2UgXCJkcmFnZW50ZXJcIjpjYXNlIFwiZHJhZ2V4aXRcIjpjYXNlIFwiZHJhZ2xlYXZlXCI6Y2FzZSBcImRyYWdvdmVyXCI6Y2FzZSBcImRyYWdzdGFydFwiOmNhc2UgXCJkcm9wXCI6az1cbkRkO2JyZWFrO2Nhc2UgXCJ0b3VjaGNhbmNlbFwiOmNhc2UgXCJ0b3VjaGVuZFwiOmNhc2UgXCJ0b3VjaG1vdmVcIjpjYXNlIFwidG91Y2hzdGFydFwiOms9VmQ7YnJlYWs7Y2FzZSBJYzpjYXNlIEpjOmNhc2UgS2M6az1IZDticmVhaztjYXNlIExjOms9WGQ7YnJlYWs7Y2FzZSBcInNjcm9sbFwiOms9dmQ7YnJlYWs7Y2FzZSBcIndoZWVsXCI6az1aZDticmVhaztjYXNlIFwiY29weVwiOmNhc2UgXCJjdXRcIjpjYXNlIFwicGFzdGVcIjprPUpkO2JyZWFrO2Nhc2UgXCJnb3Rwb2ludGVyY2FwdHVyZVwiOmNhc2UgXCJsb3N0cG9pbnRlcmNhcHR1cmVcIjpjYXNlIFwicG9pbnRlcmNhbmNlbFwiOmNhc2UgXCJwb2ludGVyZG93blwiOmNhc2UgXCJwb2ludGVybW92ZVwiOmNhc2UgXCJwb2ludGVyb3V0XCI6Y2FzZSBcInBvaW50ZXJvdmVyXCI6Y2FzZSBcInBvaW50ZXJ1cFwiOms9VGR9dmFyIHc9MCE9PShiJjQpLHo9IXcmJlwic2Nyb2xsXCI9PT1hLHU9dz9udWxsIT09aD9oK1wiQ2FwdHVyZVwiOm51bGw6aDt3PVtdO2Zvcih2YXIgdD1kLHE7bnVsbCE9PVxudDspe3E9dDt2YXIgdj1xLnN0YXRlTm9kZTs1PT09cS50YWcmJm51bGwhPT12JiYocT12LG51bGwhPT11JiYodj1PYih0LHUpLG51bGwhPXYmJncucHVzaChlZih0LHYscSkpKSk7aWYoeilicmVhazt0PXQucmV0dXJufTA8dy5sZW5ndGgmJihoPW5ldyBrKGgseCxudWxsLGMsZSksZy5wdXNoKHtldmVudDpoLGxpc3RlbmVyczp3fSkpfX1pZigwPT09KGImNykpe2E6e2g9XCJtb3VzZW92ZXJcIj09PWF8fFwicG9pbnRlcm92ZXJcIj09PWE7az1cIm1vdXNlb3V0XCI9PT1hfHxcInBvaW50ZXJvdXRcIj09PWE7aWYoaCYmMD09PShiJjE2KSYmKHg9Yy5yZWxhdGVkVGFyZ2V0fHxjLmZyb21FbGVtZW50KSYmKHdjKHgpfHx4W2ZmXSkpYnJlYWsgYTtpZihrfHxoKXtoPWUud2luZG93PT09ZT9lOihoPWUub3duZXJEb2N1bWVudCk/aC5kZWZhdWx0Vmlld3x8aC5wYXJlbnRXaW5kb3c6d2luZG93O2lmKGspe2lmKHg9Yy5yZWxhdGVkVGFyZ2V0fHxjLnRvRWxlbWVudCxrPWQseD14P3djKHgpOm51bGwsbnVsbCE9PVxueCYmKHo9WmIoeCkseCE9PXp8fDUhPT14LnRhZyYmNiE9PXgudGFnKSl4PW51bGx9ZWxzZSBrPW51bGwseD1kO2lmKGshPT14KXt3PUJkO3Y9XCJvbk1vdXNlTGVhdmVcIjt1PVwib25Nb3VzZUVudGVyXCI7dD1cIm1vdXNlXCI7aWYoXCJwb2ludGVyb3V0XCI9PT1hfHxcInBvaW50ZXJvdmVyXCI9PT1hKXc9VGQsdj1cIm9uUG9pbnRlckxlYXZlXCIsdT1cIm9uUG9pbnRlckVudGVyXCIsdD1cInBvaW50ZXJcIjt6PW51bGw9PWs/aDp1ZShrKTtxPW51bGw9PXg/aDp1ZSh4KTtoPW5ldyB3KHYsdCtcImxlYXZlXCIsayxjLGUpO2gudGFyZ2V0PXo7aC5yZWxhdGVkVGFyZ2V0PXE7dj1udWxsO3djKGUpPT09ZCYmKHc9bmV3IHcodSx0K1wiZW50ZXJcIix4LGMsZSksdy50YXJnZXQ9cSx3LnJlbGF0ZWRUYXJnZXQ9eix2PXcpO3o9djtpZihrJiZ4KWI6e3c9azt1PXg7dD0wO2ZvcihxPXc7cTtxPWdmKHEpKXQrKztxPTA7Zm9yKHY9dTt2O3Y9Z2YodikpcSsrO2Zvcig7MDx0LXE7KXc9Z2YodyksdC0tO2Zvcig7MDxxLXQ7KXU9XG5nZih1KSxxLS07Zm9yKDt0LS07KXtpZih3PT09dXx8bnVsbCE9PXUmJnc9PT11LmFsdGVybmF0ZSlicmVhayBiO3c9Z2Yodyk7dT1nZih1KX13PW51bGx9ZWxzZSB3PW51bGw7bnVsbCE9PWsmJmhmKGcsaCxrLHcsITEpO251bGwhPT14JiZudWxsIT09eiYmaGYoZyx6LHgsdywhMCl9fX1hOntoPWQ/dWUoZCk6d2luZG93O2s9aC5ub2RlTmFtZSYmaC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO2lmKFwic2VsZWN0XCI9PT1rfHxcImlucHV0XCI9PT1rJiZcImZpbGVcIj09PWgudHlwZSl2YXIgSj12ZTtlbHNlIGlmKG1lKGgpKWlmKHdlKUo9RmU7ZWxzZXtKPURlO3ZhciBLPUNlfWVsc2Uoaz1oLm5vZGVOYW1lKSYmXCJpbnB1dFwiPT09ay50b0xvd2VyQ2FzZSgpJiYoXCJjaGVja2JveFwiPT09aC50eXBlfHxcInJhZGlvXCI9PT1oLnR5cGUpJiYoSj1FZSk7aWYoSiYmKEo9SihhLGQpKSl7bmUoZyxKLGMsZSk7YnJlYWsgYX1LJiZLKGEsaCxkKTtcImZvY3Vzb3V0XCI9PT1hJiYoSz1oLl93cmFwcGVyU3RhdGUpJiZcbksuY29udHJvbGxlZCYmXCJudW1iZXJcIj09PWgudHlwZSYmYmIoaCxcIm51bWJlclwiLGgudmFsdWUpfUs9ZD91ZShkKTp3aW5kb3c7c3dpdGNoKGEpe2Nhc2UgXCJmb2N1c2luXCI6aWYobWUoSyl8fFwidHJ1ZVwiPT09Sy5jb250ZW50RWRpdGFibGUpUWU9SyxSZT1kLFNlPW51bGw7YnJlYWs7Y2FzZSBcImZvY3Vzb3V0XCI6U2U9UmU9UWU9bnVsbDticmVhaztjYXNlIFwibW91c2Vkb3duXCI6VGU9ITA7YnJlYWs7Y2FzZSBcImNvbnRleHRtZW51XCI6Y2FzZSBcIm1vdXNldXBcIjpjYXNlIFwiZHJhZ2VuZFwiOlRlPSExO1VlKGcsYyxlKTticmVhaztjYXNlIFwic2VsZWN0aW9uY2hhbmdlXCI6aWYoUGUpYnJlYWs7Y2FzZSBcImtleWRvd25cIjpjYXNlIFwia2V5dXBcIjpVZShnLGMsZSl9dmFyIFE7aWYoYWUpYjp7c3dpdGNoKGEpe2Nhc2UgXCJjb21wb3NpdGlvbnN0YXJ0XCI6dmFyIEw9XCJvbkNvbXBvc2l0aW9uU3RhcnRcIjticmVhayBiO2Nhc2UgXCJjb21wb3NpdGlvbmVuZFwiOkw9XCJvbkNvbXBvc2l0aW9uRW5kXCI7YnJlYWsgYjtcbmNhc2UgXCJjb21wb3NpdGlvbnVwZGF0ZVwiOkw9XCJvbkNvbXBvc2l0aW9uVXBkYXRlXCI7YnJlYWsgYn1MPXZvaWQgMH1lbHNlIGllP2dlKGEsYykmJihMPVwib25Db21wb3NpdGlvbkVuZFwiKTpcImtleWRvd25cIj09PWEmJjIyOT09PWMua2V5Q29kZSYmKEw9XCJvbkNvbXBvc2l0aW9uU3RhcnRcIik7TCYmKGRlJiZcImtvXCIhPT1jLmxvY2FsZSYmKGllfHxcIm9uQ29tcG9zaXRpb25TdGFydFwiIT09TD9cIm9uQ29tcG9zaXRpb25FbmRcIj09PUwmJmllJiYoUT1uZCgpKTooa2Q9ZSxsZD1cInZhbHVlXCJpbiBrZD9rZC52YWx1ZTprZC50ZXh0Q29udGVudCxpZT0hMCkpLEs9b2UoZCxMKSwwPEsubGVuZ3RoJiYoTD1uZXcgTGQoTCxhLG51bGwsYyxlKSxnLnB1c2goe2V2ZW50OkwsbGlzdGVuZXJzOkt9KSxRP0wuZGF0YT1ROihRPWhlKGMpLG51bGwhPT1RJiYoTC5kYXRhPVEpKSkpO2lmKFE9Y2U/amUoYSxjKTprZShhLGMpKWQ9b2UoZCxcIm9uQmVmb3JlSW5wdXRcIiksMDxkLmxlbmd0aCYmKGU9bmV3IExkKFwib25CZWZvcmVJbnB1dFwiLFxuXCJiZWZvcmVpbnB1dFwiLG51bGwsYyxlKSxnLnB1c2goe2V2ZW50OmUsbGlzdGVuZXJzOmR9KSxlLmRhdGE9USl9c2UoZyxiKX0pfWZ1bmN0aW9uIGVmKGEsYixjKXtyZXR1cm57aW5zdGFuY2U6YSxsaXN0ZW5lcjpiLGN1cnJlbnRUYXJnZXQ6Y319ZnVuY3Rpb24gb2UoYSxiKXtmb3IodmFyIGM9YitcIkNhcHR1cmVcIixkPVtdO251bGwhPT1hOyl7dmFyIGU9YSxmPWUuc3RhdGVOb2RlOzU9PT1lLnRhZyYmbnVsbCE9PWYmJihlPWYsZj1PYihhLGMpLG51bGwhPWYmJmQudW5zaGlmdChlZihhLGYsZSkpLGY9T2IoYSxiKSxudWxsIT1mJiZkLnB1c2goZWYoYSxmLGUpKSk7YT1hLnJldHVybn1yZXR1cm4gZH1mdW5jdGlvbiBnZihhKXtpZihudWxsPT09YSlyZXR1cm4gbnVsbDtkbyBhPWEucmV0dXJuO3doaWxlKGEmJjUhPT1hLnRhZyk7cmV0dXJuIGE/YTpudWxsfVxuZnVuY3Rpb24gaGYoYSxiLGMsZCxlKXtmb3IodmFyIGY9Yi5fcmVhY3ROYW1lLGc9W107bnVsbCE9PWMmJmMhPT1kOyl7dmFyIGg9YyxrPWguYWx0ZXJuYXRlLGw9aC5zdGF0ZU5vZGU7aWYobnVsbCE9PWsmJms9PT1kKWJyZWFrOzU9PT1oLnRhZyYmbnVsbCE9PWwmJihoPWwsZT8oaz1PYihjLGYpLG51bGwhPWsmJmcudW5zaGlmdChlZihjLGssaCkpKTplfHwoaz1PYihjLGYpLG51bGwhPWsmJmcucHVzaChlZihjLGssaCkpKSk7Yz1jLnJldHVybn0wIT09Zy5sZW5ndGgmJmEucHVzaCh7ZXZlbnQ6YixsaXN0ZW5lcnM6Z30pfWZ1bmN0aW9uIGpmKCl7fXZhciBrZj1udWxsLGxmPW51bGw7ZnVuY3Rpb24gbWYoYSxiKXtzd2l0Y2goYSl7Y2FzZSBcImJ1dHRvblwiOmNhc2UgXCJpbnB1dFwiOmNhc2UgXCJzZWxlY3RcIjpjYXNlIFwidGV4dGFyZWFcIjpyZXR1cm4hIWIuYXV0b0ZvY3VzfXJldHVybiExfVxuZnVuY3Rpb24gbmYoYSxiKXtyZXR1cm5cInRleHRhcmVhXCI9PT1hfHxcIm9wdGlvblwiPT09YXx8XCJub3NjcmlwdFwiPT09YXx8XCJzdHJpbmdcIj09PXR5cGVvZiBiLmNoaWxkcmVufHxcIm51bWJlclwiPT09dHlwZW9mIGIuY2hpbGRyZW58fFwib2JqZWN0XCI9PT10eXBlb2YgYi5kYW5nZXJvdXNseVNldElubmVySFRNTCYmbnVsbCE9PWIuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwmJm51bGwhPWIuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwuX19odG1sfXZhciBvZj1cImZ1bmN0aW9uXCI9PT10eXBlb2Ygc2V0VGltZW91dD9zZXRUaW1lb3V0OnZvaWQgMCxwZj1cImZ1bmN0aW9uXCI9PT10eXBlb2YgY2xlYXJUaW1lb3V0P2NsZWFyVGltZW91dDp2b2lkIDA7ZnVuY3Rpb24gcWYoYSl7MT09PWEubm9kZVR5cGU/YS50ZXh0Q29udGVudD1cIlwiOjk9PT1hLm5vZGVUeXBlJiYoYT1hLmJvZHksbnVsbCE9YSYmKGEudGV4dENvbnRlbnQ9XCJcIikpfVxuZnVuY3Rpb24gcmYoYSl7Zm9yKDtudWxsIT1hO2E9YS5uZXh0U2libGluZyl7dmFyIGI9YS5ub2RlVHlwZTtpZigxPT09Ynx8Mz09PWIpYnJlYWt9cmV0dXJuIGF9ZnVuY3Rpb24gc2YoYSl7YT1hLnByZXZpb3VzU2libGluZztmb3IodmFyIGI9MDthOyl7aWYoOD09PWEubm9kZVR5cGUpe3ZhciBjPWEuZGF0YTtpZihcIiRcIj09PWN8fFwiJCFcIj09PWN8fFwiJD9cIj09PWMpe2lmKDA9PT1iKXJldHVybiBhO2ItLX1lbHNlXCIvJFwiPT09YyYmYisrfWE9YS5wcmV2aW91c1NpYmxpbmd9cmV0dXJuIG51bGx9dmFyIHRmPTA7ZnVuY3Rpb24gdWYoYSl7cmV0dXJueyQkdHlwZW9mOkdhLHRvU3RyaW5nOmEsdmFsdWVPZjphfX12YXIgdmY9TWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc2xpY2UoMiksd2Y9XCJfX3JlYWN0RmliZXIkXCIrdmYseGY9XCJfX3JlYWN0UHJvcHMkXCIrdmYsZmY9XCJfX3JlYWN0Q29udGFpbmVyJFwiK3ZmLHlmPVwiX19yZWFjdEV2ZW50cyRcIit2ZjtcbmZ1bmN0aW9uIHdjKGEpe3ZhciBiPWFbd2ZdO2lmKGIpcmV0dXJuIGI7Zm9yKHZhciBjPWEucGFyZW50Tm9kZTtjOyl7aWYoYj1jW2ZmXXx8Y1t3Zl0pe2M9Yi5hbHRlcm5hdGU7aWYobnVsbCE9PWIuY2hpbGR8fG51bGwhPT1jJiZudWxsIT09Yy5jaGlsZClmb3IoYT1zZihhKTtudWxsIT09YTspe2lmKGM9YVt3Zl0pcmV0dXJuIGM7YT1zZihhKX1yZXR1cm4gYn1hPWM7Yz1hLnBhcmVudE5vZGV9cmV0dXJuIG51bGx9ZnVuY3Rpb24gQ2IoYSl7YT1hW3dmXXx8YVtmZl07cmV0dXJuIWF8fDUhPT1hLnRhZyYmNiE9PWEudGFnJiYxMyE9PWEudGFnJiYzIT09YS50YWc/bnVsbDphfWZ1bmN0aW9uIHVlKGEpe2lmKDU9PT1hLnRhZ3x8Nj09PWEudGFnKXJldHVybiBhLnN0YXRlTm9kZTt0aHJvdyBFcnJvcih5KDMzKSk7fWZ1bmN0aW9uIERiKGEpe3JldHVybiBhW3hmXXx8bnVsbH1cbmZ1bmN0aW9uICRlKGEpe3ZhciBiPWFbeWZdO3ZvaWQgMD09PWImJihiPWFbeWZdPW5ldyBTZXQpO3JldHVybiBifXZhciB6Zj1bXSxBZj0tMTtmdW5jdGlvbiBCZihhKXtyZXR1cm57Y3VycmVudDphfX1mdW5jdGlvbiBIKGEpezA+QWZ8fChhLmN1cnJlbnQ9emZbQWZdLHpmW0FmXT1udWxsLEFmLS0pfWZ1bmN0aW9uIEkoYSxiKXtBZisrO3pmW0FmXT1hLmN1cnJlbnQ7YS5jdXJyZW50PWJ9dmFyIENmPXt9LE09QmYoQ2YpLE49QmYoITEpLERmPUNmO1xuZnVuY3Rpb24gRWYoYSxiKXt2YXIgYz1hLnR5cGUuY29udGV4dFR5cGVzO2lmKCFjKXJldHVybiBDZjt2YXIgZD1hLnN0YXRlTm9kZTtpZihkJiZkLl9fcmVhY3RJbnRlcm5hbE1lbW9pemVkVW5tYXNrZWRDaGlsZENvbnRleHQ9PT1iKXJldHVybiBkLl9fcmVhY3RJbnRlcm5hbE1lbW9pemVkTWFza2VkQ2hpbGRDb250ZXh0O3ZhciBlPXt9LGY7Zm9yKGYgaW4gYyllW2ZdPWJbZl07ZCYmKGE9YS5zdGF0ZU5vZGUsYS5fX3JlYWN0SW50ZXJuYWxNZW1vaXplZFVubWFza2VkQ2hpbGRDb250ZXh0PWIsYS5fX3JlYWN0SW50ZXJuYWxNZW1vaXplZE1hc2tlZENoaWxkQ29udGV4dD1lKTtyZXR1cm4gZX1mdW5jdGlvbiBGZihhKXthPWEuY2hpbGRDb250ZXh0VHlwZXM7cmV0dXJuIG51bGwhPT1hJiZ2b2lkIDAhPT1hfWZ1bmN0aW9uIEdmKCl7SChOKTtIKE0pfWZ1bmN0aW9uIEhmKGEsYixjKXtpZihNLmN1cnJlbnQhPT1DZil0aHJvdyBFcnJvcih5KDE2OCkpO0koTSxiKTtJKE4sYyl9XG5mdW5jdGlvbiBJZihhLGIsYyl7dmFyIGQ9YS5zdGF0ZU5vZGU7YT1iLmNoaWxkQ29udGV4dFR5cGVzO2lmKFwiZnVuY3Rpb25cIiE9PXR5cGVvZiBkLmdldENoaWxkQ29udGV4dClyZXR1cm4gYztkPWQuZ2V0Q2hpbGRDb250ZXh0KCk7Zm9yKHZhciBlIGluIGQpaWYoIShlIGluIGEpKXRocm93IEVycm9yKHkoMTA4LFJhKGIpfHxcIlVua25vd25cIixlKSk7cmV0dXJuIG0oe30sYyxkKX1mdW5jdGlvbiBKZihhKXthPShhPWEuc3RhdGVOb2RlKSYmYS5fX3JlYWN0SW50ZXJuYWxNZW1vaXplZE1lcmdlZENoaWxkQ29udGV4dHx8Q2Y7RGY9TS5jdXJyZW50O0koTSxhKTtJKE4sTi5jdXJyZW50KTtyZXR1cm4hMH1mdW5jdGlvbiBLZihhLGIsYyl7dmFyIGQ9YS5zdGF0ZU5vZGU7aWYoIWQpdGhyb3cgRXJyb3IoeSgxNjkpKTtjPyhhPUlmKGEsYixEZiksZC5fX3JlYWN0SW50ZXJuYWxNZW1vaXplZE1lcmdlZENoaWxkQ29udGV4dD1hLEgoTiksSChNKSxJKE0sYSkpOkgoTik7SShOLGMpfVxudmFyIExmPW51bGwsTWY9bnVsbCxOZj1yLnVuc3RhYmxlX3J1bldpdGhQcmlvcml0eSxPZj1yLnVuc3RhYmxlX3NjaGVkdWxlQ2FsbGJhY2ssUGY9ci51bnN0YWJsZV9jYW5jZWxDYWxsYmFjayxRZj1yLnVuc3RhYmxlX3Nob3VsZFlpZWxkLFJmPXIudW5zdGFibGVfcmVxdWVzdFBhaW50LFNmPXIudW5zdGFibGVfbm93LFRmPXIudW5zdGFibGVfZ2V0Q3VycmVudFByaW9yaXR5TGV2ZWwsVWY9ci51bnN0YWJsZV9JbW1lZGlhdGVQcmlvcml0eSxWZj1yLnVuc3RhYmxlX1VzZXJCbG9ja2luZ1ByaW9yaXR5LFdmPXIudW5zdGFibGVfTm9ybWFsUHJpb3JpdHksWGY9ci51bnN0YWJsZV9Mb3dQcmlvcml0eSxZZj1yLnVuc3RhYmxlX0lkbGVQcmlvcml0eSxaZj17fSwkZj12b2lkIDAhPT1SZj9SZjpmdW5jdGlvbigpe30sYWc9bnVsbCxiZz1udWxsLGNnPSExLGRnPVNmKCksTz0xRTQ+ZGc/U2Y6ZnVuY3Rpb24oKXtyZXR1cm4gU2YoKS1kZ307XG5mdW5jdGlvbiBlZygpe3N3aXRjaChUZigpKXtjYXNlIFVmOnJldHVybiA5OTtjYXNlIFZmOnJldHVybiA5ODtjYXNlIFdmOnJldHVybiA5NztjYXNlIFhmOnJldHVybiA5NjtjYXNlIFlmOnJldHVybiA5NTtkZWZhdWx0OnRocm93IEVycm9yKHkoMzMyKSk7fX1mdW5jdGlvbiBmZyhhKXtzd2l0Y2goYSl7Y2FzZSA5OTpyZXR1cm4gVWY7Y2FzZSA5ODpyZXR1cm4gVmY7Y2FzZSA5NzpyZXR1cm4gV2Y7Y2FzZSA5NjpyZXR1cm4gWGY7Y2FzZSA5NTpyZXR1cm4gWWY7ZGVmYXVsdDp0aHJvdyBFcnJvcih5KDMzMikpO319ZnVuY3Rpb24gZ2coYSxiKXthPWZnKGEpO3JldHVybiBOZihhLGIpfWZ1bmN0aW9uIGhnKGEsYixjKXthPWZnKGEpO3JldHVybiBPZihhLGIsYyl9ZnVuY3Rpb24gaWcoKXtpZihudWxsIT09Ymcpe3ZhciBhPWJnO2JnPW51bGw7UGYoYSl9amcoKX1cbmZ1bmN0aW9uIGpnKCl7aWYoIWNnJiZudWxsIT09YWcpe2NnPSEwO3ZhciBhPTA7dHJ5e3ZhciBiPWFnO2dnKDk5LGZ1bmN0aW9uKCl7Zm9yKDthPGIubGVuZ3RoO2ErKyl7dmFyIGM9YlthXTtkbyBjPWMoITApO3doaWxlKG51bGwhPT1jKX19KTthZz1udWxsfWNhdGNoKGMpe3Rocm93IG51bGwhPT1hZyYmKGFnPWFnLnNsaWNlKGErMSkpLE9mKFVmLGlnKSxjO31maW5hbGx5e2NnPSExfX19dmFyIGtnPXJhLlJlYWN0Q3VycmVudEJhdGNoQ29uZmlnO2Z1bmN0aW9uIGxnKGEsYil7aWYoYSYmYS5kZWZhdWx0UHJvcHMpe2I9bSh7fSxiKTthPWEuZGVmYXVsdFByb3BzO2Zvcih2YXIgYyBpbiBhKXZvaWQgMD09PWJbY10mJihiW2NdPWFbY10pO3JldHVybiBifXJldHVybiBifXZhciBtZz1CZihudWxsKSxuZz1udWxsLG9nPW51bGwscGc9bnVsbDtmdW5jdGlvbiBxZygpe3BnPW9nPW5nPW51bGx9XG5mdW5jdGlvbiByZyhhKXt2YXIgYj1tZy5jdXJyZW50O0gobWcpO2EudHlwZS5fY29udGV4dC5fY3VycmVudFZhbHVlPWJ9ZnVuY3Rpb24gc2coYSxiKXtmb3IoO251bGwhPT1hOyl7dmFyIGM9YS5hbHRlcm5hdGU7aWYoKGEuY2hpbGRMYW5lcyZiKT09PWIpaWYobnVsbD09PWN8fChjLmNoaWxkTGFuZXMmYik9PT1iKWJyZWFrO2Vsc2UgYy5jaGlsZExhbmVzfD1iO2Vsc2UgYS5jaGlsZExhbmVzfD1iLG51bGwhPT1jJiYoYy5jaGlsZExhbmVzfD1iKTthPWEucmV0dXJufX1mdW5jdGlvbiB0ZyhhLGIpe25nPWE7cGc9b2c9bnVsbDthPWEuZGVwZW5kZW5jaWVzO251bGwhPT1hJiZudWxsIT09YS5maXJzdENvbnRleHQmJigwIT09KGEubGFuZXMmYikmJih1Zz0hMCksYS5maXJzdENvbnRleHQ9bnVsbCl9XG5mdW5jdGlvbiB2ZyhhLGIpe2lmKHBnIT09YSYmITEhPT1iJiYwIT09Yil7aWYoXCJudW1iZXJcIiE9PXR5cGVvZiBifHwxMDczNzQxODIzPT09YilwZz1hLGI9MTA3Mzc0MTgyMztiPXtjb250ZXh0OmEsb2JzZXJ2ZWRCaXRzOmIsbmV4dDpudWxsfTtpZihudWxsPT09b2cpe2lmKG51bGw9PT1uZyl0aHJvdyBFcnJvcih5KDMwOCkpO29nPWI7bmcuZGVwZW5kZW5jaWVzPXtsYW5lczowLGZpcnN0Q29udGV4dDpiLHJlc3BvbmRlcnM6bnVsbH19ZWxzZSBvZz1vZy5uZXh0PWJ9cmV0dXJuIGEuX2N1cnJlbnRWYWx1ZX12YXIgd2c9ITE7ZnVuY3Rpb24geGcoYSl7YS51cGRhdGVRdWV1ZT17YmFzZVN0YXRlOmEubWVtb2l6ZWRTdGF0ZSxmaXJzdEJhc2VVcGRhdGU6bnVsbCxsYXN0QmFzZVVwZGF0ZTpudWxsLHNoYXJlZDp7cGVuZGluZzpudWxsfSxlZmZlY3RzOm51bGx9fVxuZnVuY3Rpb24geWcoYSxiKXthPWEudXBkYXRlUXVldWU7Yi51cGRhdGVRdWV1ZT09PWEmJihiLnVwZGF0ZVF1ZXVlPXtiYXNlU3RhdGU6YS5iYXNlU3RhdGUsZmlyc3RCYXNlVXBkYXRlOmEuZmlyc3RCYXNlVXBkYXRlLGxhc3RCYXNlVXBkYXRlOmEubGFzdEJhc2VVcGRhdGUsc2hhcmVkOmEuc2hhcmVkLGVmZmVjdHM6YS5lZmZlY3RzfSl9ZnVuY3Rpb24gemcoYSxiKXtyZXR1cm57ZXZlbnRUaW1lOmEsbGFuZTpiLHRhZzowLHBheWxvYWQ6bnVsbCxjYWxsYmFjazpudWxsLG5leHQ6bnVsbH19ZnVuY3Rpb24gQWcoYSxiKXthPWEudXBkYXRlUXVldWU7aWYobnVsbCE9PWEpe2E9YS5zaGFyZWQ7dmFyIGM9YS5wZW5kaW5nO251bGw9PT1jP2IubmV4dD1iOihiLm5leHQ9Yy5uZXh0LGMubmV4dD1iKTthLnBlbmRpbmc9Yn19XG5mdW5jdGlvbiBCZyhhLGIpe3ZhciBjPWEudXBkYXRlUXVldWUsZD1hLmFsdGVybmF0ZTtpZihudWxsIT09ZCYmKGQ9ZC51cGRhdGVRdWV1ZSxjPT09ZCkpe3ZhciBlPW51bGwsZj1udWxsO2M9Yy5maXJzdEJhc2VVcGRhdGU7aWYobnVsbCE9PWMpe2Rve3ZhciBnPXtldmVudFRpbWU6Yy5ldmVudFRpbWUsbGFuZTpjLmxhbmUsdGFnOmMudGFnLHBheWxvYWQ6Yy5wYXlsb2FkLGNhbGxiYWNrOmMuY2FsbGJhY2ssbmV4dDpudWxsfTtudWxsPT09Zj9lPWY9ZzpmPWYubmV4dD1nO2M9Yy5uZXh0fXdoaWxlKG51bGwhPT1jKTtudWxsPT09Zj9lPWY9YjpmPWYubmV4dD1ifWVsc2UgZT1mPWI7Yz17YmFzZVN0YXRlOmQuYmFzZVN0YXRlLGZpcnN0QmFzZVVwZGF0ZTplLGxhc3RCYXNlVXBkYXRlOmYsc2hhcmVkOmQuc2hhcmVkLGVmZmVjdHM6ZC5lZmZlY3RzfTthLnVwZGF0ZVF1ZXVlPWM7cmV0dXJufWE9Yy5sYXN0QmFzZVVwZGF0ZTtudWxsPT09YT9jLmZpcnN0QmFzZVVwZGF0ZT1iOmEubmV4dD1cbmI7Yy5sYXN0QmFzZVVwZGF0ZT1ifVxuZnVuY3Rpb24gQ2coYSxiLGMsZCl7dmFyIGU9YS51cGRhdGVRdWV1ZTt3Zz0hMTt2YXIgZj1lLmZpcnN0QmFzZVVwZGF0ZSxnPWUubGFzdEJhc2VVcGRhdGUsaD1lLnNoYXJlZC5wZW5kaW5nO2lmKG51bGwhPT1oKXtlLnNoYXJlZC5wZW5kaW5nPW51bGw7dmFyIGs9aCxsPWsubmV4dDtrLm5leHQ9bnVsbDtudWxsPT09Zz9mPWw6Zy5uZXh0PWw7Zz1rO3ZhciBuPWEuYWx0ZXJuYXRlO2lmKG51bGwhPT1uKXtuPW4udXBkYXRlUXVldWU7dmFyIEE9bi5sYXN0QmFzZVVwZGF0ZTtBIT09ZyYmKG51bGw9PT1BP24uZmlyc3RCYXNlVXBkYXRlPWw6QS5uZXh0PWwsbi5sYXN0QmFzZVVwZGF0ZT1rKX19aWYobnVsbCE9PWYpe0E9ZS5iYXNlU3RhdGU7Zz0wO249bD1rPW51bGw7ZG97aD1mLmxhbmU7dmFyIHA9Zi5ldmVudFRpbWU7aWYoKGQmaCk9PT1oKXtudWxsIT09biYmKG49bi5uZXh0PXtldmVudFRpbWU6cCxsYW5lOjAsdGFnOmYudGFnLHBheWxvYWQ6Zi5wYXlsb2FkLGNhbGxiYWNrOmYuY2FsbGJhY2ssXG5uZXh0Om51bGx9KTthOnt2YXIgQz1hLHg9ZjtoPWI7cD1jO3N3aXRjaCh4LnRhZyl7Y2FzZSAxOkM9eC5wYXlsb2FkO2lmKFwiZnVuY3Rpb25cIj09PXR5cGVvZiBDKXtBPUMuY2FsbChwLEEsaCk7YnJlYWsgYX1BPUM7YnJlYWsgYTtjYXNlIDM6Qy5mbGFncz1DLmZsYWdzJi00MDk3fDY0O2Nhc2UgMDpDPXgucGF5bG9hZDtoPVwiZnVuY3Rpb25cIj09PXR5cGVvZiBDP0MuY2FsbChwLEEsaCk6QztpZihudWxsPT09aHx8dm9pZCAwPT09aClicmVhayBhO0E9bSh7fSxBLGgpO2JyZWFrIGE7Y2FzZSAyOndnPSEwfX1udWxsIT09Zi5jYWxsYmFjayYmKGEuZmxhZ3N8PTMyLGg9ZS5lZmZlY3RzLG51bGw9PT1oP2UuZWZmZWN0cz1bZl06aC5wdXNoKGYpKX1lbHNlIHA9e2V2ZW50VGltZTpwLGxhbmU6aCx0YWc6Zi50YWcscGF5bG9hZDpmLnBheWxvYWQsY2FsbGJhY2s6Zi5jYWxsYmFjayxuZXh0Om51bGx9LG51bGw9PT1uPyhsPW49cCxrPUEpOm49bi5uZXh0PXAsZ3w9aDtmPWYubmV4dDtpZihudWxsPT09XG5mKWlmKGg9ZS5zaGFyZWQucGVuZGluZyxudWxsPT09aClicmVhaztlbHNlIGY9aC5uZXh0LGgubmV4dD1udWxsLGUubGFzdEJhc2VVcGRhdGU9aCxlLnNoYXJlZC5wZW5kaW5nPW51bGx9d2hpbGUoMSk7bnVsbD09PW4mJihrPUEpO2UuYmFzZVN0YXRlPWs7ZS5maXJzdEJhc2VVcGRhdGU9bDtlLmxhc3RCYXNlVXBkYXRlPW47RGd8PWc7YS5sYW5lcz1nO2EubWVtb2l6ZWRTdGF0ZT1BfX1mdW5jdGlvbiBFZyhhLGIsYyl7YT1iLmVmZmVjdHM7Yi5lZmZlY3RzPW51bGw7aWYobnVsbCE9PWEpZm9yKGI9MDtiPGEubGVuZ3RoO2IrKyl7dmFyIGQ9YVtiXSxlPWQuY2FsbGJhY2s7aWYobnVsbCE9PWUpe2QuY2FsbGJhY2s9bnVsbDtkPWM7aWYoXCJmdW5jdGlvblwiIT09dHlwZW9mIGUpdGhyb3cgRXJyb3IoeSgxOTEsZSkpO2UuY2FsbChkKX19fXZhciBGZz0obmV3IGFhLkNvbXBvbmVudCkucmVmcztcbmZ1bmN0aW9uIEdnKGEsYixjLGQpe2I9YS5tZW1vaXplZFN0YXRlO2M9YyhkLGIpO2M9bnVsbD09PWN8fHZvaWQgMD09PWM/YjptKHt9LGIsYyk7YS5tZW1vaXplZFN0YXRlPWM7MD09PWEubGFuZXMmJihhLnVwZGF0ZVF1ZXVlLmJhc2VTdGF0ZT1jKX1cbnZhciBLZz17aXNNb3VudGVkOmZ1bmN0aW9uKGEpe3JldHVybihhPWEuX3JlYWN0SW50ZXJuYWxzKT9aYihhKT09PWE6ITF9LGVucXVldWVTZXRTdGF0ZTpmdW5jdGlvbihhLGIsYyl7YT1hLl9yZWFjdEludGVybmFsczt2YXIgZD1IZygpLGU9SWcoYSksZj16ZyhkLGUpO2YucGF5bG9hZD1iO3ZvaWQgMCE9PWMmJm51bGwhPT1jJiYoZi5jYWxsYmFjaz1jKTtBZyhhLGYpO0pnKGEsZSxkKX0sZW5xdWV1ZVJlcGxhY2VTdGF0ZTpmdW5jdGlvbihhLGIsYyl7YT1hLl9yZWFjdEludGVybmFsczt2YXIgZD1IZygpLGU9SWcoYSksZj16ZyhkLGUpO2YudGFnPTE7Zi5wYXlsb2FkPWI7dm9pZCAwIT09YyYmbnVsbCE9PWMmJihmLmNhbGxiYWNrPWMpO0FnKGEsZik7SmcoYSxlLGQpfSxlbnF1ZXVlRm9yY2VVcGRhdGU6ZnVuY3Rpb24oYSxiKXthPWEuX3JlYWN0SW50ZXJuYWxzO3ZhciBjPUhnKCksZD1JZyhhKSxlPXpnKGMsZCk7ZS50YWc9Mjt2b2lkIDAhPT1iJiZudWxsIT09YiYmKGUuY2FsbGJhY2s9XG5iKTtBZyhhLGUpO0pnKGEsZCxjKX19O2Z1bmN0aW9uIExnKGEsYixjLGQsZSxmLGcpe2E9YS5zdGF0ZU5vZGU7cmV0dXJuXCJmdW5jdGlvblwiPT09dHlwZW9mIGEuc2hvdWxkQ29tcG9uZW50VXBkYXRlP2Euc2hvdWxkQ29tcG9uZW50VXBkYXRlKGQsZixnKTpiLnByb3RvdHlwZSYmYi5wcm90b3R5cGUuaXNQdXJlUmVhY3RDb21wb25lbnQ/IUplKGMsZCl8fCFKZShlLGYpOiEwfVxuZnVuY3Rpb24gTWcoYSxiLGMpe3ZhciBkPSExLGU9Q2Y7dmFyIGY9Yi5jb250ZXh0VHlwZTtcIm9iamVjdFwiPT09dHlwZW9mIGYmJm51bGwhPT1mP2Y9dmcoZik6KGU9RmYoYik/RGY6TS5jdXJyZW50LGQ9Yi5jb250ZXh0VHlwZXMsZj0oZD1udWxsIT09ZCYmdm9pZCAwIT09ZCk/RWYoYSxlKTpDZik7Yj1uZXcgYihjLGYpO2EubWVtb2l6ZWRTdGF0ZT1udWxsIT09Yi5zdGF0ZSYmdm9pZCAwIT09Yi5zdGF0ZT9iLnN0YXRlOm51bGw7Yi51cGRhdGVyPUtnO2Euc3RhdGVOb2RlPWI7Yi5fcmVhY3RJbnRlcm5hbHM9YTtkJiYoYT1hLnN0YXRlTm9kZSxhLl9fcmVhY3RJbnRlcm5hbE1lbW9pemVkVW5tYXNrZWRDaGlsZENvbnRleHQ9ZSxhLl9fcmVhY3RJbnRlcm5hbE1lbW9pemVkTWFza2VkQ2hpbGRDb250ZXh0PWYpO3JldHVybiBifVxuZnVuY3Rpb24gTmcoYSxiLGMsZCl7YT1iLnN0YXRlO1wiZnVuY3Rpb25cIj09PXR5cGVvZiBiLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMmJmIuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhjLGQpO1wiZnVuY3Rpb25cIj09PXR5cGVvZiBiLlVOU0FGRV9jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzJiZiLlVOU0FGRV9jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKGMsZCk7Yi5zdGF0ZSE9PWEmJktnLmVucXVldWVSZXBsYWNlU3RhdGUoYixiLnN0YXRlLG51bGwpfVxuZnVuY3Rpb24gT2coYSxiLGMsZCl7dmFyIGU9YS5zdGF0ZU5vZGU7ZS5wcm9wcz1jO2Uuc3RhdGU9YS5tZW1vaXplZFN0YXRlO2UucmVmcz1GZzt4ZyhhKTt2YXIgZj1iLmNvbnRleHRUeXBlO1wib2JqZWN0XCI9PT10eXBlb2YgZiYmbnVsbCE9PWY/ZS5jb250ZXh0PXZnKGYpOihmPUZmKGIpP0RmOk0uY3VycmVudCxlLmNvbnRleHQ9RWYoYSxmKSk7Q2coYSxjLGUsZCk7ZS5zdGF0ZT1hLm1lbW9pemVkU3RhdGU7Zj1iLmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcztcImZ1bmN0aW9uXCI9PT10eXBlb2YgZiYmKEdnKGEsYixmLGMpLGUuc3RhdGU9YS5tZW1vaXplZFN0YXRlKTtcImZ1bmN0aW9uXCI9PT10eXBlb2YgYi5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHN8fFwiZnVuY3Rpb25cIj09PXR5cGVvZiBlLmdldFNuYXBzaG90QmVmb3JlVXBkYXRlfHxcImZ1bmN0aW9uXCIhPT10eXBlb2YgZS5VTlNBRkVfY29tcG9uZW50V2lsbE1vdW50JiZcImZ1bmN0aW9uXCIhPT10eXBlb2YgZS5jb21wb25lbnRXaWxsTW91bnR8fFxuKGI9ZS5zdGF0ZSxcImZ1bmN0aW9uXCI9PT10eXBlb2YgZS5jb21wb25lbnRXaWxsTW91bnQmJmUuY29tcG9uZW50V2lsbE1vdW50KCksXCJmdW5jdGlvblwiPT09dHlwZW9mIGUuVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudCYmZS5VTlNBRkVfY29tcG9uZW50V2lsbE1vdW50KCksYiE9PWUuc3RhdGUmJktnLmVucXVldWVSZXBsYWNlU3RhdGUoZSxlLnN0YXRlLG51bGwpLENnKGEsYyxlLGQpLGUuc3RhdGU9YS5tZW1vaXplZFN0YXRlKTtcImZ1bmN0aW9uXCI9PT10eXBlb2YgZS5jb21wb25lbnREaWRNb3VudCYmKGEuZmxhZ3N8PTQpfXZhciBQZz1BcnJheS5pc0FycmF5O1xuZnVuY3Rpb24gUWcoYSxiLGMpe2E9Yy5yZWY7aWYobnVsbCE9PWEmJlwiZnVuY3Rpb25cIiE9PXR5cGVvZiBhJiZcIm9iamVjdFwiIT09dHlwZW9mIGEpe2lmKGMuX293bmVyKXtjPWMuX293bmVyO2lmKGMpe2lmKDEhPT1jLnRhZyl0aHJvdyBFcnJvcih5KDMwOSkpO3ZhciBkPWMuc3RhdGVOb2RlfWlmKCFkKXRocm93IEVycm9yKHkoMTQ3LGEpKTt2YXIgZT1cIlwiK2E7aWYobnVsbCE9PWImJm51bGwhPT1iLnJlZiYmXCJmdW5jdGlvblwiPT09dHlwZW9mIGIucmVmJiZiLnJlZi5fc3RyaW5nUmVmPT09ZSlyZXR1cm4gYi5yZWY7Yj1mdW5jdGlvbihhKXt2YXIgYj1kLnJlZnM7Yj09PUZnJiYoYj1kLnJlZnM9e30pO251bGw9PT1hP2RlbGV0ZSBiW2VdOmJbZV09YX07Yi5fc3RyaW5nUmVmPWU7cmV0dXJuIGJ9aWYoXCJzdHJpbmdcIiE9PXR5cGVvZiBhKXRocm93IEVycm9yKHkoMjg0KSk7aWYoIWMuX293bmVyKXRocm93IEVycm9yKHkoMjkwLGEpKTt9cmV0dXJuIGF9XG5mdW5jdGlvbiBSZyhhLGIpe2lmKFwidGV4dGFyZWFcIiE9PWEudHlwZSl0aHJvdyBFcnJvcih5KDMxLFwiW29iamVjdCBPYmplY3RdXCI9PT1PYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoYik/XCJvYmplY3Qgd2l0aCBrZXlzIHtcIitPYmplY3Qua2V5cyhiKS5qb2luKFwiLCBcIikrXCJ9XCI6YikpO31cbmZ1bmN0aW9uIFNnKGEpe2Z1bmN0aW9uIGIoYixjKXtpZihhKXt2YXIgZD1iLmxhc3RFZmZlY3Q7bnVsbCE9PWQ/KGQubmV4dEVmZmVjdD1jLGIubGFzdEVmZmVjdD1jKTpiLmZpcnN0RWZmZWN0PWIubGFzdEVmZmVjdD1jO2MubmV4dEVmZmVjdD1udWxsO2MuZmxhZ3M9OH19ZnVuY3Rpb24gYyhjLGQpe2lmKCFhKXJldHVybiBudWxsO2Zvcig7bnVsbCE9PWQ7KWIoYyxkKSxkPWQuc2libGluZztyZXR1cm4gbnVsbH1mdW5jdGlvbiBkKGEsYil7Zm9yKGE9bmV3IE1hcDtudWxsIT09YjspbnVsbCE9PWIua2V5P2Euc2V0KGIua2V5LGIpOmEuc2V0KGIuaW5kZXgsYiksYj1iLnNpYmxpbmc7cmV0dXJuIGF9ZnVuY3Rpb24gZShhLGIpe2E9VGcoYSxiKTthLmluZGV4PTA7YS5zaWJsaW5nPW51bGw7cmV0dXJuIGF9ZnVuY3Rpb24gZihiLGMsZCl7Yi5pbmRleD1kO2lmKCFhKXJldHVybiBjO2Q9Yi5hbHRlcm5hdGU7aWYobnVsbCE9PWQpcmV0dXJuIGQ9ZC5pbmRleCxkPGM/KGIuZmxhZ3M9MixcbmMpOmQ7Yi5mbGFncz0yO3JldHVybiBjfWZ1bmN0aW9uIGcoYil7YSYmbnVsbD09PWIuYWx0ZXJuYXRlJiYoYi5mbGFncz0yKTtyZXR1cm4gYn1mdW5jdGlvbiBoKGEsYixjLGQpe2lmKG51bGw9PT1ifHw2IT09Yi50YWcpcmV0dXJuIGI9VWcoYyxhLm1vZGUsZCksYi5yZXR1cm49YSxiO2I9ZShiLGMpO2IucmV0dXJuPWE7cmV0dXJuIGJ9ZnVuY3Rpb24gayhhLGIsYyxkKXtpZihudWxsIT09YiYmYi5lbGVtZW50VHlwZT09PWMudHlwZSlyZXR1cm4gZD1lKGIsYy5wcm9wcyksZC5yZWY9UWcoYSxiLGMpLGQucmV0dXJuPWEsZDtkPVZnKGMudHlwZSxjLmtleSxjLnByb3BzLG51bGwsYS5tb2RlLGQpO2QucmVmPVFnKGEsYixjKTtkLnJldHVybj1hO3JldHVybiBkfWZ1bmN0aW9uIGwoYSxiLGMsZCl7aWYobnVsbD09PWJ8fDQhPT1iLnRhZ3x8Yi5zdGF0ZU5vZGUuY29udGFpbmVySW5mbyE9PWMuY29udGFpbmVySW5mb3x8Yi5zdGF0ZU5vZGUuaW1wbGVtZW50YXRpb24hPT1jLmltcGxlbWVudGF0aW9uKXJldHVybiBiPVxuV2coYyxhLm1vZGUsZCksYi5yZXR1cm49YSxiO2I9ZShiLGMuY2hpbGRyZW58fFtdKTtiLnJldHVybj1hO3JldHVybiBifWZ1bmN0aW9uIG4oYSxiLGMsZCxmKXtpZihudWxsPT09Ynx8NyE9PWIudGFnKXJldHVybiBiPVhnKGMsYS5tb2RlLGQsZiksYi5yZXR1cm49YSxiO2I9ZShiLGMpO2IucmV0dXJuPWE7cmV0dXJuIGJ9ZnVuY3Rpb24gQShhLGIsYyl7aWYoXCJzdHJpbmdcIj09PXR5cGVvZiBifHxcIm51bWJlclwiPT09dHlwZW9mIGIpcmV0dXJuIGI9VWcoXCJcIitiLGEubW9kZSxjKSxiLnJldHVybj1hLGI7aWYoXCJvYmplY3RcIj09PXR5cGVvZiBiJiZudWxsIT09Yil7c3dpdGNoKGIuJCR0eXBlb2Ype2Nhc2Ugc2E6cmV0dXJuIGM9VmcoYi50eXBlLGIua2V5LGIucHJvcHMsbnVsbCxhLm1vZGUsYyksYy5yZWY9UWcoYSxudWxsLGIpLGMucmV0dXJuPWEsYztjYXNlIHRhOnJldHVybiBiPVdnKGIsYS5tb2RlLGMpLGIucmV0dXJuPWEsYn1pZihQZyhiKXx8TGEoYikpcmV0dXJuIGI9WGcoYixcbmEubW9kZSxjLG51bGwpLGIucmV0dXJuPWEsYjtSZyhhLGIpfXJldHVybiBudWxsfWZ1bmN0aW9uIHAoYSxiLGMsZCl7dmFyIGU9bnVsbCE9PWI/Yi5rZXk6bnVsbDtpZihcInN0cmluZ1wiPT09dHlwZW9mIGN8fFwibnVtYmVyXCI9PT10eXBlb2YgYylyZXR1cm4gbnVsbCE9PWU/bnVsbDpoKGEsYixcIlwiK2MsZCk7aWYoXCJvYmplY3RcIj09PXR5cGVvZiBjJiZudWxsIT09Yyl7c3dpdGNoKGMuJCR0eXBlb2Ype2Nhc2Ugc2E6cmV0dXJuIGMua2V5PT09ZT9jLnR5cGU9PT11YT9uKGEsYixjLnByb3BzLmNoaWxkcmVuLGQsZSk6ayhhLGIsYyxkKTpudWxsO2Nhc2UgdGE6cmV0dXJuIGMua2V5PT09ZT9sKGEsYixjLGQpOm51bGx9aWYoUGcoYyl8fExhKGMpKXJldHVybiBudWxsIT09ZT9udWxsOm4oYSxiLGMsZCxudWxsKTtSZyhhLGMpfXJldHVybiBudWxsfWZ1bmN0aW9uIEMoYSxiLGMsZCxlKXtpZihcInN0cmluZ1wiPT09dHlwZW9mIGR8fFwibnVtYmVyXCI9PT10eXBlb2YgZClyZXR1cm4gYT1hLmdldChjKXx8XG5udWxsLGgoYixhLFwiXCIrZCxlKTtpZihcIm9iamVjdFwiPT09dHlwZW9mIGQmJm51bGwhPT1kKXtzd2l0Y2goZC4kJHR5cGVvZil7Y2FzZSBzYTpyZXR1cm4gYT1hLmdldChudWxsPT09ZC5rZXk/YzpkLmtleSl8fG51bGwsZC50eXBlPT09dWE/bihiLGEsZC5wcm9wcy5jaGlsZHJlbixlLGQua2V5KTprKGIsYSxkLGUpO2Nhc2UgdGE6cmV0dXJuIGE9YS5nZXQobnVsbD09PWQua2V5P2M6ZC5rZXkpfHxudWxsLGwoYixhLGQsZSl9aWYoUGcoZCl8fExhKGQpKXJldHVybiBhPWEuZ2V0KGMpfHxudWxsLG4oYixhLGQsZSxudWxsKTtSZyhiLGQpfXJldHVybiBudWxsfWZ1bmN0aW9uIHgoZSxnLGgsayl7Zm9yKHZhciBsPW51bGwsdD1udWxsLHU9Zyx6PWc9MCxxPW51bGw7bnVsbCE9PXUmJno8aC5sZW5ndGg7eisrKXt1LmluZGV4Pno/KHE9dSx1PW51bGwpOnE9dS5zaWJsaW5nO3ZhciBuPXAoZSx1LGhbel0sayk7aWYobnVsbD09PW4pe251bGw9PT11JiYodT1xKTticmVha31hJiZ1JiZudWxsPT09XG5uLmFsdGVybmF0ZSYmYihlLHUpO2c9ZihuLGcseik7bnVsbD09PXQ/bD1uOnQuc2libGluZz1uO3Q9bjt1PXF9aWYoej09PWgubGVuZ3RoKXJldHVybiBjKGUsdSksbDtpZihudWxsPT09dSl7Zm9yKDt6PGgubGVuZ3RoO3orKyl1PUEoZSxoW3pdLGspLG51bGwhPT11JiYoZz1mKHUsZyx6KSxudWxsPT09dD9sPXU6dC5zaWJsaW5nPXUsdD11KTtyZXR1cm4gbH1mb3IodT1kKGUsdSk7ejxoLmxlbmd0aDt6KyspcT1DKHUsZSx6LGhbel0sayksbnVsbCE9PXEmJihhJiZudWxsIT09cS5hbHRlcm5hdGUmJnUuZGVsZXRlKG51bGw9PT1xLmtleT96OnEua2V5KSxnPWYocSxnLHopLG51bGw9PT10P2w9cTp0LnNpYmxpbmc9cSx0PXEpO2EmJnUuZm9yRWFjaChmdW5jdGlvbihhKXtyZXR1cm4gYihlLGEpfSk7cmV0dXJuIGx9ZnVuY3Rpb24gdyhlLGcsaCxrKXt2YXIgbD1MYShoKTtpZihcImZ1bmN0aW9uXCIhPT10eXBlb2YgbCl0aHJvdyBFcnJvcih5KDE1MCkpO2g9bC5jYWxsKGgpO2lmKG51bGw9PVxuaCl0aHJvdyBFcnJvcih5KDE1MSkpO2Zvcih2YXIgdD1sPW51bGwsdT1nLHo9Zz0wLHE9bnVsbCxuPWgubmV4dCgpO251bGwhPT11JiYhbi5kb25lO3orKyxuPWgubmV4dCgpKXt1LmluZGV4Pno/KHE9dSx1PW51bGwpOnE9dS5zaWJsaW5nO3ZhciB3PXAoZSx1LG4udmFsdWUsayk7aWYobnVsbD09PXcpe251bGw9PT11JiYodT1xKTticmVha31hJiZ1JiZudWxsPT09dy5hbHRlcm5hdGUmJmIoZSx1KTtnPWYodyxnLHopO251bGw9PT10P2w9dzp0LnNpYmxpbmc9dzt0PXc7dT1xfWlmKG4uZG9uZSlyZXR1cm4gYyhlLHUpLGw7aWYobnVsbD09PXUpe2Zvcig7IW4uZG9uZTt6Kyssbj1oLm5leHQoKSluPUEoZSxuLnZhbHVlLGspLG51bGwhPT1uJiYoZz1mKG4sZyx6KSxudWxsPT09dD9sPW46dC5zaWJsaW5nPW4sdD1uKTtyZXR1cm4gbH1mb3IodT1kKGUsdSk7IW4uZG9uZTt6Kyssbj1oLm5leHQoKSluPUModSxlLHosbi52YWx1ZSxrKSxudWxsIT09biYmKGEmJm51bGwhPT1uLmFsdGVybmF0ZSYmXG51LmRlbGV0ZShudWxsPT09bi5rZXk/ejpuLmtleSksZz1mKG4sZyx6KSxudWxsPT09dD9sPW46dC5zaWJsaW5nPW4sdD1uKTthJiZ1LmZvckVhY2goZnVuY3Rpb24oYSl7cmV0dXJuIGIoZSxhKX0pO3JldHVybiBsfXJldHVybiBmdW5jdGlvbihhLGQsZixoKXt2YXIgaz1cIm9iamVjdFwiPT09dHlwZW9mIGYmJm51bGwhPT1mJiZmLnR5cGU9PT11YSYmbnVsbD09PWYua2V5O2smJihmPWYucHJvcHMuY2hpbGRyZW4pO3ZhciBsPVwib2JqZWN0XCI9PT10eXBlb2YgZiYmbnVsbCE9PWY7aWYobClzd2l0Y2goZi4kJHR5cGVvZil7Y2FzZSBzYTphOntsPWYua2V5O2ZvcihrPWQ7bnVsbCE9PWs7KXtpZihrLmtleT09PWwpe3N3aXRjaChrLnRhZyl7Y2FzZSA3OmlmKGYudHlwZT09PXVhKXtjKGEsay5zaWJsaW5nKTtkPWUoayxmLnByb3BzLmNoaWxkcmVuKTtkLnJldHVybj1hO2E9ZDticmVhayBhfWJyZWFrO2RlZmF1bHQ6aWYoay5lbGVtZW50VHlwZT09PWYudHlwZSl7YyhhLGsuc2libGluZyk7XG5kPWUoayxmLnByb3BzKTtkLnJlZj1RZyhhLGssZik7ZC5yZXR1cm49YTthPWQ7YnJlYWsgYX19YyhhLGspO2JyZWFrfWVsc2UgYihhLGspO2s9ay5zaWJsaW5nfWYudHlwZT09PXVhPyhkPVhnKGYucHJvcHMuY2hpbGRyZW4sYS5tb2RlLGgsZi5rZXkpLGQucmV0dXJuPWEsYT1kKTooaD1WZyhmLnR5cGUsZi5rZXksZi5wcm9wcyxudWxsLGEubW9kZSxoKSxoLnJlZj1RZyhhLGQsZiksaC5yZXR1cm49YSxhPWgpfXJldHVybiBnKGEpO2Nhc2UgdGE6YTp7Zm9yKGs9Zi5rZXk7bnVsbCE9PWQ7KXtpZihkLmtleT09PWspaWYoND09PWQudGFnJiZkLnN0YXRlTm9kZS5jb250YWluZXJJbmZvPT09Zi5jb250YWluZXJJbmZvJiZkLnN0YXRlTm9kZS5pbXBsZW1lbnRhdGlvbj09PWYuaW1wbGVtZW50YXRpb24pe2MoYSxkLnNpYmxpbmcpO2Q9ZShkLGYuY2hpbGRyZW58fFtdKTtkLnJldHVybj1hO2E9ZDticmVhayBhfWVsc2V7YyhhLGQpO2JyZWFrfWVsc2UgYihhLGQpO2Q9ZC5zaWJsaW5nfWQ9XG5XZyhmLGEubW9kZSxoKTtkLnJldHVybj1hO2E9ZH1yZXR1cm4gZyhhKX1pZihcInN0cmluZ1wiPT09dHlwZW9mIGZ8fFwibnVtYmVyXCI9PT10eXBlb2YgZilyZXR1cm4gZj1cIlwiK2YsbnVsbCE9PWQmJjY9PT1kLnRhZz8oYyhhLGQuc2libGluZyksZD1lKGQsZiksZC5yZXR1cm49YSxhPWQpOihjKGEsZCksZD1VZyhmLGEubW9kZSxoKSxkLnJldHVybj1hLGE9ZCksZyhhKTtpZihQZyhmKSlyZXR1cm4geChhLGQsZixoKTtpZihMYShmKSlyZXR1cm4gdyhhLGQsZixoKTtsJiZSZyhhLGYpO2lmKFwidW5kZWZpbmVkXCI9PT10eXBlb2YgZiYmIWspc3dpdGNoKGEudGFnKXtjYXNlIDE6Y2FzZSAyMjpjYXNlIDA6Y2FzZSAxMTpjYXNlIDE1OnRocm93IEVycm9yKHkoMTUyLFJhKGEudHlwZSl8fFwiQ29tcG9uZW50XCIpKTt9cmV0dXJuIGMoYSxkKX19dmFyIFlnPVNnKCEwKSxaZz1TZyghMSksJGc9e30sYWg9QmYoJGcpLGJoPUJmKCRnKSxjaD1CZigkZyk7XG5mdW5jdGlvbiBkaChhKXtpZihhPT09JGcpdGhyb3cgRXJyb3IoeSgxNzQpKTtyZXR1cm4gYX1mdW5jdGlvbiBlaChhLGIpe0koY2gsYik7SShiaCxhKTtJKGFoLCRnKTthPWIubm9kZVR5cGU7c3dpdGNoKGEpe2Nhc2UgOTpjYXNlIDExOmI9KGI9Yi5kb2N1bWVudEVsZW1lbnQpP2IubmFtZXNwYWNlVVJJOm1iKG51bGwsXCJcIik7YnJlYWs7ZGVmYXVsdDphPTg9PT1hP2IucGFyZW50Tm9kZTpiLGI9YS5uYW1lc3BhY2VVUkl8fG51bGwsYT1hLnRhZ05hbWUsYj1tYihiLGEpfUgoYWgpO0koYWgsYil9ZnVuY3Rpb24gZmgoKXtIKGFoKTtIKGJoKTtIKGNoKX1mdW5jdGlvbiBnaChhKXtkaChjaC5jdXJyZW50KTt2YXIgYj1kaChhaC5jdXJyZW50KTt2YXIgYz1tYihiLGEudHlwZSk7YiE9PWMmJihJKGJoLGEpLEkoYWgsYykpfWZ1bmN0aW9uIGhoKGEpe2JoLmN1cnJlbnQ9PT1hJiYoSChhaCksSChiaCkpfXZhciBQPUJmKDApO1xuZnVuY3Rpb24gaWgoYSl7Zm9yKHZhciBiPWE7bnVsbCE9PWI7KXtpZigxMz09PWIudGFnKXt2YXIgYz1iLm1lbW9pemVkU3RhdGU7aWYobnVsbCE9PWMmJihjPWMuZGVoeWRyYXRlZCxudWxsPT09Y3x8XCIkP1wiPT09Yy5kYXRhfHxcIiQhXCI9PT1jLmRhdGEpKXJldHVybiBifWVsc2UgaWYoMTk9PT1iLnRhZyYmdm9pZCAwIT09Yi5tZW1vaXplZFByb3BzLnJldmVhbE9yZGVyKXtpZigwIT09KGIuZmxhZ3MmNjQpKXJldHVybiBifWVsc2UgaWYobnVsbCE9PWIuY2hpbGQpe2IuY2hpbGQucmV0dXJuPWI7Yj1iLmNoaWxkO2NvbnRpbnVlfWlmKGI9PT1hKWJyZWFrO2Zvcig7bnVsbD09PWIuc2libGluZzspe2lmKG51bGw9PT1iLnJldHVybnx8Yi5yZXR1cm49PT1hKXJldHVybiBudWxsO2I9Yi5yZXR1cm59Yi5zaWJsaW5nLnJldHVybj1iLnJldHVybjtiPWIuc2libGluZ31yZXR1cm4gbnVsbH12YXIgamg9bnVsbCxraD1udWxsLGxoPSExO1xuZnVuY3Rpb24gbWgoYSxiKXt2YXIgYz1uaCg1LG51bGwsbnVsbCwwKTtjLmVsZW1lbnRUeXBlPVwiREVMRVRFRFwiO2MudHlwZT1cIkRFTEVURURcIjtjLnN0YXRlTm9kZT1iO2MucmV0dXJuPWE7Yy5mbGFncz04O251bGwhPT1hLmxhc3RFZmZlY3Q/KGEubGFzdEVmZmVjdC5uZXh0RWZmZWN0PWMsYS5sYXN0RWZmZWN0PWMpOmEuZmlyc3RFZmZlY3Q9YS5sYXN0RWZmZWN0PWN9ZnVuY3Rpb24gb2goYSxiKXtzd2l0Y2goYS50YWcpe2Nhc2UgNTp2YXIgYz1hLnR5cGU7Yj0xIT09Yi5ub2RlVHlwZXx8Yy50b0xvd2VyQ2FzZSgpIT09Yi5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpP251bGw6YjtyZXR1cm4gbnVsbCE9PWI/KGEuc3RhdGVOb2RlPWIsITApOiExO2Nhc2UgNjpyZXR1cm4gYj1cIlwiPT09YS5wZW5kaW5nUHJvcHN8fDMhPT1iLm5vZGVUeXBlP251bGw6YixudWxsIT09Yj8oYS5zdGF0ZU5vZGU9YiwhMCk6ITE7Y2FzZSAxMzpyZXR1cm4hMTtkZWZhdWx0OnJldHVybiExfX1cbmZ1bmN0aW9uIHBoKGEpe2lmKGxoKXt2YXIgYj1raDtpZihiKXt2YXIgYz1iO2lmKCFvaChhLGIpKXtiPXJmKGMubmV4dFNpYmxpbmcpO2lmKCFifHwhb2goYSxiKSl7YS5mbGFncz1hLmZsYWdzJi0xMDI1fDI7bGg9ITE7amg9YTtyZXR1cm59bWgoamgsYyl9amg9YTtraD1yZihiLmZpcnN0Q2hpbGQpfWVsc2UgYS5mbGFncz1hLmZsYWdzJi0xMDI1fDIsbGg9ITEsamg9YX19ZnVuY3Rpb24gcWgoYSl7Zm9yKGE9YS5yZXR1cm47bnVsbCE9PWEmJjUhPT1hLnRhZyYmMyE9PWEudGFnJiYxMyE9PWEudGFnOylhPWEucmV0dXJuO2poPWF9XG5mdW5jdGlvbiByaChhKXtpZihhIT09amgpcmV0dXJuITE7aWYoIWxoKXJldHVybiBxaChhKSxsaD0hMCwhMTt2YXIgYj1hLnR5cGU7aWYoNSE9PWEudGFnfHxcImhlYWRcIiE9PWImJlwiYm9keVwiIT09YiYmIW5mKGIsYS5tZW1vaXplZFByb3BzKSlmb3IoYj1raDtiOyltaChhLGIpLGI9cmYoYi5uZXh0U2libGluZyk7cWgoYSk7aWYoMTM9PT1hLnRhZyl7YT1hLm1lbW9pemVkU3RhdGU7YT1udWxsIT09YT9hLmRlaHlkcmF0ZWQ6bnVsbDtpZighYSl0aHJvdyBFcnJvcih5KDMxNykpO2E6e2E9YS5uZXh0U2libGluZztmb3IoYj0wO2E7KXtpZig4PT09YS5ub2RlVHlwZSl7dmFyIGM9YS5kYXRhO2lmKFwiLyRcIj09PWMpe2lmKDA9PT1iKXtraD1yZihhLm5leHRTaWJsaW5nKTticmVhayBhfWItLX1lbHNlXCIkXCIhPT1jJiZcIiQhXCIhPT1jJiZcIiQ/XCIhPT1jfHxiKyt9YT1hLm5leHRTaWJsaW5nfWtoPW51bGx9fWVsc2Uga2g9amg/cmYoYS5zdGF0ZU5vZGUubmV4dFNpYmxpbmcpOm51bGw7cmV0dXJuITB9XG5mdW5jdGlvbiBzaCgpe2toPWpoPW51bGw7bGg9ITF9dmFyIHRoPVtdO2Z1bmN0aW9uIHVoKCl7Zm9yKHZhciBhPTA7YTx0aC5sZW5ndGg7YSsrKXRoW2FdLl93b3JrSW5Qcm9ncmVzc1ZlcnNpb25QcmltYXJ5PW51bGw7dGgubGVuZ3RoPTB9dmFyIHZoPXJhLlJlYWN0Q3VycmVudERpc3BhdGNoZXIsd2g9cmEuUmVhY3RDdXJyZW50QmF0Y2hDb25maWcseGg9MCxSPW51bGwsUz1udWxsLFQ9bnVsbCx5aD0hMSx6aD0hMTtmdW5jdGlvbiBBaCgpe3Rocm93IEVycm9yKHkoMzIxKSk7fWZ1bmN0aW9uIEJoKGEsYil7aWYobnVsbD09PWIpcmV0dXJuITE7Zm9yKHZhciBjPTA7YzxiLmxlbmd0aCYmYzxhLmxlbmd0aDtjKyspaWYoIUhlKGFbY10sYltjXSkpcmV0dXJuITE7cmV0dXJuITB9XG5mdW5jdGlvbiBDaChhLGIsYyxkLGUsZil7eGg9ZjtSPWI7Yi5tZW1vaXplZFN0YXRlPW51bGw7Yi51cGRhdGVRdWV1ZT1udWxsO2IubGFuZXM9MDt2aC5jdXJyZW50PW51bGw9PT1hfHxudWxsPT09YS5tZW1vaXplZFN0YXRlP0RoOkVoO2E9YyhkLGUpO2lmKHpoKXtmPTA7ZG97emg9ITE7aWYoISgyNT5mKSl0aHJvdyBFcnJvcih5KDMwMSkpO2YrPTE7VD1TPW51bGw7Yi51cGRhdGVRdWV1ZT1udWxsO3ZoLmN1cnJlbnQ9Rmg7YT1jKGQsZSl9d2hpbGUoemgpfXZoLmN1cnJlbnQ9R2g7Yj1udWxsIT09UyYmbnVsbCE9PVMubmV4dDt4aD0wO1Q9Uz1SPW51bGw7eWg9ITE7aWYoYil0aHJvdyBFcnJvcih5KDMwMCkpO3JldHVybiBhfWZ1bmN0aW9uIEhoKCl7dmFyIGE9e21lbW9pemVkU3RhdGU6bnVsbCxiYXNlU3RhdGU6bnVsbCxiYXNlUXVldWU6bnVsbCxxdWV1ZTpudWxsLG5leHQ6bnVsbH07bnVsbD09PVQ/Ui5tZW1vaXplZFN0YXRlPVQ9YTpUPVQubmV4dD1hO3JldHVybiBUfVxuZnVuY3Rpb24gSWgoKXtpZihudWxsPT09Uyl7dmFyIGE9Ui5hbHRlcm5hdGU7YT1udWxsIT09YT9hLm1lbW9pemVkU3RhdGU6bnVsbH1lbHNlIGE9Uy5uZXh0O3ZhciBiPW51bGw9PT1UP1IubWVtb2l6ZWRTdGF0ZTpULm5leHQ7aWYobnVsbCE9PWIpVD1iLFM9YTtlbHNle2lmKG51bGw9PT1hKXRocm93IEVycm9yKHkoMzEwKSk7Uz1hO2E9e21lbW9pemVkU3RhdGU6Uy5tZW1vaXplZFN0YXRlLGJhc2VTdGF0ZTpTLmJhc2VTdGF0ZSxiYXNlUXVldWU6Uy5iYXNlUXVldWUscXVldWU6Uy5xdWV1ZSxuZXh0Om51bGx9O251bGw9PT1UP1IubWVtb2l6ZWRTdGF0ZT1UPWE6VD1ULm5leHQ9YX1yZXR1cm4gVH1mdW5jdGlvbiBKaChhLGIpe3JldHVyblwiZnVuY3Rpb25cIj09PXR5cGVvZiBiP2IoYSk6Yn1cbmZ1bmN0aW9uIEtoKGEpe3ZhciBiPUloKCksYz1iLnF1ZXVlO2lmKG51bGw9PT1jKXRocm93IEVycm9yKHkoMzExKSk7Yy5sYXN0UmVuZGVyZWRSZWR1Y2VyPWE7dmFyIGQ9UyxlPWQuYmFzZVF1ZXVlLGY9Yy5wZW5kaW5nO2lmKG51bGwhPT1mKXtpZihudWxsIT09ZSl7dmFyIGc9ZS5uZXh0O2UubmV4dD1mLm5leHQ7Zi5uZXh0PWd9ZC5iYXNlUXVldWU9ZT1mO2MucGVuZGluZz1udWxsfWlmKG51bGwhPT1lKXtlPWUubmV4dDtkPWQuYmFzZVN0YXRlO3ZhciBoPWc9Zj1udWxsLGs9ZTtkb3t2YXIgbD1rLmxhbmU7aWYoKHhoJmwpPT09bCludWxsIT09aCYmKGg9aC5uZXh0PXtsYW5lOjAsYWN0aW9uOmsuYWN0aW9uLGVhZ2VyUmVkdWNlcjprLmVhZ2VyUmVkdWNlcixlYWdlclN0YXRlOmsuZWFnZXJTdGF0ZSxuZXh0Om51bGx9KSxkPWsuZWFnZXJSZWR1Y2VyPT09YT9rLmVhZ2VyU3RhdGU6YShkLGsuYWN0aW9uKTtlbHNle3ZhciBuPXtsYW5lOmwsYWN0aW9uOmsuYWN0aW9uLGVhZ2VyUmVkdWNlcjprLmVhZ2VyUmVkdWNlcixcbmVhZ2VyU3RhdGU6ay5lYWdlclN0YXRlLG5leHQ6bnVsbH07bnVsbD09PWg/KGc9aD1uLGY9ZCk6aD1oLm5leHQ9bjtSLmxhbmVzfD1sO0RnfD1sfWs9ay5uZXh0fXdoaWxlKG51bGwhPT1rJiZrIT09ZSk7bnVsbD09PWg/Zj1kOmgubmV4dD1nO0hlKGQsYi5tZW1vaXplZFN0YXRlKXx8KHVnPSEwKTtiLm1lbW9pemVkU3RhdGU9ZDtiLmJhc2VTdGF0ZT1mO2IuYmFzZVF1ZXVlPWg7Yy5sYXN0UmVuZGVyZWRTdGF0ZT1kfXJldHVybltiLm1lbW9pemVkU3RhdGUsYy5kaXNwYXRjaF19XG5mdW5jdGlvbiBMaChhKXt2YXIgYj1JaCgpLGM9Yi5xdWV1ZTtpZihudWxsPT09Yyl0aHJvdyBFcnJvcih5KDMxMSkpO2MubGFzdFJlbmRlcmVkUmVkdWNlcj1hO3ZhciBkPWMuZGlzcGF0Y2gsZT1jLnBlbmRpbmcsZj1iLm1lbW9pemVkU3RhdGU7aWYobnVsbCE9PWUpe2MucGVuZGluZz1udWxsO3ZhciBnPWU9ZS5uZXh0O2RvIGY9YShmLGcuYWN0aW9uKSxnPWcubmV4dDt3aGlsZShnIT09ZSk7SGUoZixiLm1lbW9pemVkU3RhdGUpfHwodWc9ITApO2IubWVtb2l6ZWRTdGF0ZT1mO251bGw9PT1iLmJhc2VRdWV1ZSYmKGIuYmFzZVN0YXRlPWYpO2MubGFzdFJlbmRlcmVkU3RhdGU9Zn1yZXR1cm5bZixkXX1cbmZ1bmN0aW9uIE1oKGEsYixjKXt2YXIgZD1iLl9nZXRWZXJzaW9uO2Q9ZChiLl9zb3VyY2UpO3ZhciBlPWIuX3dvcmtJblByb2dyZXNzVmVyc2lvblByaW1hcnk7aWYobnVsbCE9PWUpYT1lPT09ZDtlbHNlIGlmKGE9YS5tdXRhYmxlUmVhZExhbmVzLGE9KHhoJmEpPT09YSliLl93b3JrSW5Qcm9ncmVzc1ZlcnNpb25QcmltYXJ5PWQsdGgucHVzaChiKTtpZihhKXJldHVybiBjKGIuX3NvdXJjZSk7dGgucHVzaChiKTt0aHJvdyBFcnJvcih5KDM1MCkpO31cbmZ1bmN0aW9uIE5oKGEsYixjLGQpe3ZhciBlPVU7aWYobnVsbD09PWUpdGhyb3cgRXJyb3IoeSgzNDkpKTt2YXIgZj1iLl9nZXRWZXJzaW9uLGc9ZihiLl9zb3VyY2UpLGg9dmguY3VycmVudCxrPWgudXNlU3RhdGUoZnVuY3Rpb24oKXtyZXR1cm4gTWgoZSxiLGMpfSksbD1rWzFdLG49a1swXTtrPVQ7dmFyIEE9YS5tZW1vaXplZFN0YXRlLHA9QS5yZWZzLEM9cC5nZXRTbmFwc2hvdCx4PUEuc291cmNlO0E9QS5zdWJzY3JpYmU7dmFyIHc9UjthLm1lbW9pemVkU3RhdGU9e3JlZnM6cCxzb3VyY2U6YixzdWJzY3JpYmU6ZH07aC51c2VFZmZlY3QoZnVuY3Rpb24oKXtwLmdldFNuYXBzaG90PWM7cC5zZXRTbmFwc2hvdD1sO3ZhciBhPWYoYi5fc291cmNlKTtpZighSGUoZyxhKSl7YT1jKGIuX3NvdXJjZSk7SGUobixhKXx8KGwoYSksYT1JZyh3KSxlLm11dGFibGVSZWFkTGFuZXN8PWEmZS5wZW5kaW5nTGFuZXMpO2E9ZS5tdXRhYmxlUmVhZExhbmVzO2UuZW50YW5nbGVkTGFuZXN8PWE7Zm9yKHZhciBkPVxuZS5lbnRhbmdsZW1lbnRzLGg9YTswPGg7KXt2YXIgaz0zMS1WYyhoKSx2PTE8PGs7ZFtrXXw9YTtoJj1+dn19fSxbYyxiLGRdKTtoLnVzZUVmZmVjdChmdW5jdGlvbigpe3JldHVybiBkKGIuX3NvdXJjZSxmdW5jdGlvbigpe3ZhciBhPXAuZ2V0U25hcHNob3QsYz1wLnNldFNuYXBzaG90O3RyeXtjKGEoYi5fc291cmNlKSk7dmFyIGQ9SWcodyk7ZS5tdXRhYmxlUmVhZExhbmVzfD1kJmUucGVuZGluZ0xhbmVzfWNhdGNoKHEpe2MoZnVuY3Rpb24oKXt0aHJvdyBxO30pfX0pfSxbYixkXSk7SGUoQyxjKSYmSGUoeCxiKSYmSGUoQSxkKXx8KGE9e3BlbmRpbmc6bnVsbCxkaXNwYXRjaDpudWxsLGxhc3RSZW5kZXJlZFJlZHVjZXI6SmgsbGFzdFJlbmRlcmVkU3RhdGU6bn0sYS5kaXNwYXRjaD1sPU9oLmJpbmQobnVsbCxSLGEpLGsucXVldWU9YSxrLmJhc2VRdWV1ZT1udWxsLG49TWgoZSxiLGMpLGsubWVtb2l6ZWRTdGF0ZT1rLmJhc2VTdGF0ZT1uKTtyZXR1cm4gbn1cbmZ1bmN0aW9uIFBoKGEsYixjKXt2YXIgZD1JaCgpO3JldHVybiBOaChkLGEsYixjKX1mdW5jdGlvbiBRaChhKXt2YXIgYj1IaCgpO1wiZnVuY3Rpb25cIj09PXR5cGVvZiBhJiYoYT1hKCkpO2IubWVtb2l6ZWRTdGF0ZT1iLmJhc2VTdGF0ZT1hO2E9Yi5xdWV1ZT17cGVuZGluZzpudWxsLGRpc3BhdGNoOm51bGwsbGFzdFJlbmRlcmVkUmVkdWNlcjpKaCxsYXN0UmVuZGVyZWRTdGF0ZTphfTthPWEuZGlzcGF0Y2g9T2guYmluZChudWxsLFIsYSk7cmV0dXJuW2IubWVtb2l6ZWRTdGF0ZSxhXX1cbmZ1bmN0aW9uIFJoKGEsYixjLGQpe2E9e3RhZzphLGNyZWF0ZTpiLGRlc3Ryb3k6YyxkZXBzOmQsbmV4dDpudWxsfTtiPVIudXBkYXRlUXVldWU7bnVsbD09PWI/KGI9e2xhc3RFZmZlY3Q6bnVsbH0sUi51cGRhdGVRdWV1ZT1iLGIubGFzdEVmZmVjdD1hLm5leHQ9YSk6KGM9Yi5sYXN0RWZmZWN0LG51bGw9PT1jP2IubGFzdEVmZmVjdD1hLm5leHQ9YTooZD1jLm5leHQsYy5uZXh0PWEsYS5uZXh0PWQsYi5sYXN0RWZmZWN0PWEpKTtyZXR1cm4gYX1mdW5jdGlvbiBTaChhKXt2YXIgYj1IaCgpO2E9e2N1cnJlbnQ6YX07cmV0dXJuIGIubWVtb2l6ZWRTdGF0ZT1hfWZ1bmN0aW9uIFRoKCl7cmV0dXJuIEloKCkubWVtb2l6ZWRTdGF0ZX1mdW5jdGlvbiBVaChhLGIsYyxkKXt2YXIgZT1IaCgpO1IuZmxhZ3N8PWE7ZS5tZW1vaXplZFN0YXRlPVJoKDF8YixjLHZvaWQgMCx2b2lkIDA9PT1kP251bGw6ZCl9XG5mdW5jdGlvbiBWaChhLGIsYyxkKXt2YXIgZT1JaCgpO2Q9dm9pZCAwPT09ZD9udWxsOmQ7dmFyIGY9dm9pZCAwO2lmKG51bGwhPT1TKXt2YXIgZz1TLm1lbW9pemVkU3RhdGU7Zj1nLmRlc3Ryb3k7aWYobnVsbCE9PWQmJkJoKGQsZy5kZXBzKSl7UmgoYixjLGYsZCk7cmV0dXJufX1SLmZsYWdzfD1hO2UubWVtb2l6ZWRTdGF0ZT1SaCgxfGIsYyxmLGQpfWZ1bmN0aW9uIFdoKGEsYil7cmV0dXJuIFVoKDUxNiw0LGEsYil9ZnVuY3Rpb24gWGgoYSxiKXtyZXR1cm4gVmgoNTE2LDQsYSxiKX1mdW5jdGlvbiBZaChhLGIpe3JldHVybiBWaCg0LDIsYSxiKX1mdW5jdGlvbiBaaChhLGIpe2lmKFwiZnVuY3Rpb25cIj09PXR5cGVvZiBiKXJldHVybiBhPWEoKSxiKGEpLGZ1bmN0aW9uKCl7YihudWxsKX07aWYobnVsbCE9PWImJnZvaWQgMCE9PWIpcmV0dXJuIGE9YSgpLGIuY3VycmVudD1hLGZ1bmN0aW9uKCl7Yi5jdXJyZW50PW51bGx9fVxuZnVuY3Rpb24gJGgoYSxiLGMpe2M9bnVsbCE9PWMmJnZvaWQgMCE9PWM/Yy5jb25jYXQoW2FdKTpudWxsO3JldHVybiBWaCg0LDIsWmguYmluZChudWxsLGIsYSksYyl9ZnVuY3Rpb24gYWkoKXt9ZnVuY3Rpb24gYmkoYSxiKXt2YXIgYz1JaCgpO2I9dm9pZCAwPT09Yj9udWxsOmI7dmFyIGQ9Yy5tZW1vaXplZFN0YXRlO2lmKG51bGwhPT1kJiZudWxsIT09YiYmQmgoYixkWzFdKSlyZXR1cm4gZFswXTtjLm1lbW9pemVkU3RhdGU9W2EsYl07cmV0dXJuIGF9ZnVuY3Rpb24gY2koYSxiKXt2YXIgYz1JaCgpO2I9dm9pZCAwPT09Yj9udWxsOmI7dmFyIGQ9Yy5tZW1vaXplZFN0YXRlO2lmKG51bGwhPT1kJiZudWxsIT09YiYmQmgoYixkWzFdKSlyZXR1cm4gZFswXTthPWEoKTtjLm1lbW9pemVkU3RhdGU9W2EsYl07cmV0dXJuIGF9XG5mdW5jdGlvbiBkaShhLGIpe3ZhciBjPWVnKCk7Z2coOTg+Yz85ODpjLGZ1bmN0aW9uKCl7YSghMCl9KTtnZyg5NzxjPzk3OmMsZnVuY3Rpb24oKXt2YXIgYz13aC50cmFuc2l0aW9uO3doLnRyYW5zaXRpb249MTt0cnl7YSghMSksYigpfWZpbmFsbHl7d2gudHJhbnNpdGlvbj1jfX0pfVxuZnVuY3Rpb24gT2goYSxiLGMpe3ZhciBkPUhnKCksZT1JZyhhKSxmPXtsYW5lOmUsYWN0aW9uOmMsZWFnZXJSZWR1Y2VyOm51bGwsZWFnZXJTdGF0ZTpudWxsLG5leHQ6bnVsbH0sZz1iLnBlbmRpbmc7bnVsbD09PWc/Zi5uZXh0PWY6KGYubmV4dD1nLm5leHQsZy5uZXh0PWYpO2IucGVuZGluZz1mO2c9YS5hbHRlcm5hdGU7aWYoYT09PVJ8fG51bGwhPT1nJiZnPT09Uil6aD15aD0hMDtlbHNle2lmKDA9PT1hLmxhbmVzJiYobnVsbD09PWd8fDA9PT1nLmxhbmVzKSYmKGc9Yi5sYXN0UmVuZGVyZWRSZWR1Y2VyLG51bGwhPT1nKSl0cnl7dmFyIGg9Yi5sYXN0UmVuZGVyZWRTdGF0ZSxrPWcoaCxjKTtmLmVhZ2VyUmVkdWNlcj1nO2YuZWFnZXJTdGF0ZT1rO2lmKEhlKGssaCkpcmV0dXJufWNhdGNoKGwpe31maW5hbGx5e31KZyhhLGUsZCl9fVxudmFyIEdoPXtyZWFkQ29udGV4dDp2Zyx1c2VDYWxsYmFjazpBaCx1c2VDb250ZXh0OkFoLHVzZUVmZmVjdDpBaCx1c2VJbXBlcmF0aXZlSGFuZGxlOkFoLHVzZUxheW91dEVmZmVjdDpBaCx1c2VNZW1vOkFoLHVzZVJlZHVjZXI6QWgsdXNlUmVmOkFoLHVzZVN0YXRlOkFoLHVzZURlYnVnVmFsdWU6QWgsdXNlRGVmZXJyZWRWYWx1ZTpBaCx1c2VUcmFuc2l0aW9uOkFoLHVzZU11dGFibGVTb3VyY2U6QWgsdXNlT3BhcXVlSWRlbnRpZmllcjpBaCx1bnN0YWJsZV9pc05ld1JlY29uY2lsZXI6ITF9LERoPXtyZWFkQ29udGV4dDp2Zyx1c2VDYWxsYmFjazpmdW5jdGlvbihhLGIpe0hoKCkubWVtb2l6ZWRTdGF0ZT1bYSx2b2lkIDA9PT1iP251bGw6Yl07cmV0dXJuIGF9LHVzZUNvbnRleHQ6dmcsdXNlRWZmZWN0OldoLHVzZUltcGVyYXRpdmVIYW5kbGU6ZnVuY3Rpb24oYSxiLGMpe2M9bnVsbCE9PWMmJnZvaWQgMCE9PWM/Yy5jb25jYXQoW2FdKTpudWxsO3JldHVybiBVaCg0LDIsWmguYmluZChudWxsLFxuYixhKSxjKX0sdXNlTGF5b3V0RWZmZWN0OmZ1bmN0aW9uKGEsYil7cmV0dXJuIFVoKDQsMixhLGIpfSx1c2VNZW1vOmZ1bmN0aW9uKGEsYil7dmFyIGM9SGgoKTtiPXZvaWQgMD09PWI/bnVsbDpiO2E9YSgpO2MubWVtb2l6ZWRTdGF0ZT1bYSxiXTtyZXR1cm4gYX0sdXNlUmVkdWNlcjpmdW5jdGlvbihhLGIsYyl7dmFyIGQ9SGgoKTtiPXZvaWQgMCE9PWM/YyhiKTpiO2QubWVtb2l6ZWRTdGF0ZT1kLmJhc2VTdGF0ZT1iO2E9ZC5xdWV1ZT17cGVuZGluZzpudWxsLGRpc3BhdGNoOm51bGwsbGFzdFJlbmRlcmVkUmVkdWNlcjphLGxhc3RSZW5kZXJlZFN0YXRlOmJ9O2E9YS5kaXNwYXRjaD1PaC5iaW5kKG51bGwsUixhKTtyZXR1cm5bZC5tZW1vaXplZFN0YXRlLGFdfSx1c2VSZWY6U2gsdXNlU3RhdGU6UWgsdXNlRGVidWdWYWx1ZTphaSx1c2VEZWZlcnJlZFZhbHVlOmZ1bmN0aW9uKGEpe3ZhciBiPVFoKGEpLGM9YlswXSxkPWJbMV07V2goZnVuY3Rpb24oKXt2YXIgYj13aC50cmFuc2l0aW9uO1xud2gudHJhbnNpdGlvbj0xO3RyeXtkKGEpfWZpbmFsbHl7d2gudHJhbnNpdGlvbj1ifX0sW2FdKTtyZXR1cm4gY30sdXNlVHJhbnNpdGlvbjpmdW5jdGlvbigpe3ZhciBhPVFoKCExKSxiPWFbMF07YT1kaS5iaW5kKG51bGwsYVsxXSk7U2goYSk7cmV0dXJuW2EsYl19LHVzZU11dGFibGVTb3VyY2U6ZnVuY3Rpb24oYSxiLGMpe3ZhciBkPUhoKCk7ZC5tZW1vaXplZFN0YXRlPXtyZWZzOntnZXRTbmFwc2hvdDpiLHNldFNuYXBzaG90Om51bGx9LHNvdXJjZTphLHN1YnNjcmliZTpjfTtyZXR1cm4gTmgoZCxhLGIsYyl9LHVzZU9wYXF1ZUlkZW50aWZpZXI6ZnVuY3Rpb24oKXtpZihsaCl7dmFyIGE9ITEsYj11ZihmdW5jdGlvbigpe2F8fChhPSEwLGMoXCJyOlwiKyh0ZisrKS50b1N0cmluZygzNikpKTt0aHJvdyBFcnJvcih5KDM1NSkpO30pLGM9UWgoYilbMV07MD09PShSLm1vZGUmMikmJihSLmZsYWdzfD01MTYsUmgoNSxmdW5jdGlvbigpe2MoXCJyOlwiKyh0ZisrKS50b1N0cmluZygzNikpfSxcbnZvaWQgMCxudWxsKSk7cmV0dXJuIGJ9Yj1cInI6XCIrKHRmKyspLnRvU3RyaW5nKDM2KTtRaChiKTtyZXR1cm4gYn0sdW5zdGFibGVfaXNOZXdSZWNvbmNpbGVyOiExfSxFaD17cmVhZENvbnRleHQ6dmcsdXNlQ2FsbGJhY2s6YmksdXNlQ29udGV4dDp2Zyx1c2VFZmZlY3Q6WGgsdXNlSW1wZXJhdGl2ZUhhbmRsZTokaCx1c2VMYXlvdXRFZmZlY3Q6WWgsdXNlTWVtbzpjaSx1c2VSZWR1Y2VyOktoLHVzZVJlZjpUaCx1c2VTdGF0ZTpmdW5jdGlvbigpe3JldHVybiBLaChKaCl9LHVzZURlYnVnVmFsdWU6YWksdXNlRGVmZXJyZWRWYWx1ZTpmdW5jdGlvbihhKXt2YXIgYj1LaChKaCksYz1iWzBdLGQ9YlsxXTtYaChmdW5jdGlvbigpe3ZhciBiPXdoLnRyYW5zaXRpb247d2gudHJhbnNpdGlvbj0xO3RyeXtkKGEpfWZpbmFsbHl7d2gudHJhbnNpdGlvbj1ifX0sW2FdKTtyZXR1cm4gY30sdXNlVHJhbnNpdGlvbjpmdW5jdGlvbigpe3ZhciBhPUtoKEpoKVswXTtyZXR1cm5bVGgoKS5jdXJyZW50LFxuYV19LHVzZU11dGFibGVTb3VyY2U6UGgsdXNlT3BhcXVlSWRlbnRpZmllcjpmdW5jdGlvbigpe3JldHVybiBLaChKaClbMF19LHVuc3RhYmxlX2lzTmV3UmVjb25jaWxlcjohMX0sRmg9e3JlYWRDb250ZXh0OnZnLHVzZUNhbGxiYWNrOmJpLHVzZUNvbnRleHQ6dmcsdXNlRWZmZWN0OlhoLHVzZUltcGVyYXRpdmVIYW5kbGU6JGgsdXNlTGF5b3V0RWZmZWN0OlloLHVzZU1lbW86Y2ksdXNlUmVkdWNlcjpMaCx1c2VSZWY6VGgsdXNlU3RhdGU6ZnVuY3Rpb24oKXtyZXR1cm4gTGgoSmgpfSx1c2VEZWJ1Z1ZhbHVlOmFpLHVzZURlZmVycmVkVmFsdWU6ZnVuY3Rpb24oYSl7dmFyIGI9TGgoSmgpLGM9YlswXSxkPWJbMV07WGgoZnVuY3Rpb24oKXt2YXIgYj13aC50cmFuc2l0aW9uO3doLnRyYW5zaXRpb249MTt0cnl7ZChhKX1maW5hbGx5e3doLnRyYW5zaXRpb249Yn19LFthXSk7cmV0dXJuIGN9LHVzZVRyYW5zaXRpb246ZnVuY3Rpb24oKXt2YXIgYT1MaChKaClbMF07cmV0dXJuW1RoKCkuY3VycmVudCxcbmFdfSx1c2VNdXRhYmxlU291cmNlOlBoLHVzZU9wYXF1ZUlkZW50aWZpZXI6ZnVuY3Rpb24oKXtyZXR1cm4gTGgoSmgpWzBdfSx1bnN0YWJsZV9pc05ld1JlY29uY2lsZXI6ITF9LGVpPXJhLlJlYWN0Q3VycmVudE93bmVyLHVnPSExO2Z1bmN0aW9uIGZpKGEsYixjLGQpe2IuY2hpbGQ9bnVsbD09PWE/WmcoYixudWxsLGMsZCk6WWcoYixhLmNoaWxkLGMsZCl9ZnVuY3Rpb24gZ2koYSxiLGMsZCxlKXtjPWMucmVuZGVyO3ZhciBmPWIucmVmO3RnKGIsZSk7ZD1DaChhLGIsYyxkLGYsZSk7aWYobnVsbCE9PWEmJiF1ZylyZXR1cm4gYi51cGRhdGVRdWV1ZT1hLnVwZGF0ZVF1ZXVlLGIuZmxhZ3MmPS01MTcsYS5sYW5lcyY9fmUsaGkoYSxiLGUpO2IuZmxhZ3N8PTE7ZmkoYSxiLGQsZSk7cmV0dXJuIGIuY2hpbGR9XG5mdW5jdGlvbiBpaShhLGIsYyxkLGUsZil7aWYobnVsbD09PWEpe3ZhciBnPWMudHlwZTtpZihcImZ1bmN0aW9uXCI9PT10eXBlb2YgZyYmIWppKGcpJiZ2b2lkIDA9PT1nLmRlZmF1bHRQcm9wcyYmbnVsbD09PWMuY29tcGFyZSYmdm9pZCAwPT09Yy5kZWZhdWx0UHJvcHMpcmV0dXJuIGIudGFnPTE1LGIudHlwZT1nLGtpKGEsYixnLGQsZSxmKTthPVZnKGMudHlwZSxudWxsLGQsYixiLm1vZGUsZik7YS5yZWY9Yi5yZWY7YS5yZXR1cm49YjtyZXR1cm4gYi5jaGlsZD1hfWc9YS5jaGlsZDtpZigwPT09KGUmZikmJihlPWcubWVtb2l6ZWRQcm9wcyxjPWMuY29tcGFyZSxjPW51bGwhPT1jP2M6SmUsYyhlLGQpJiZhLnJlZj09PWIucmVmKSlyZXR1cm4gaGkoYSxiLGYpO2IuZmxhZ3N8PTE7YT1UZyhnLGQpO2EucmVmPWIucmVmO2EucmV0dXJuPWI7cmV0dXJuIGIuY2hpbGQ9YX1cbmZ1bmN0aW9uIGtpKGEsYixjLGQsZSxmKXtpZihudWxsIT09YSYmSmUoYS5tZW1vaXplZFByb3BzLGQpJiZhLnJlZj09PWIucmVmKWlmKHVnPSExLDAhPT0oZiZlKSkwIT09KGEuZmxhZ3MmMTYzODQpJiYodWc9ITApO2Vsc2UgcmV0dXJuIGIubGFuZXM9YS5sYW5lcyxoaShhLGIsZik7cmV0dXJuIGxpKGEsYixjLGQsZil9XG5mdW5jdGlvbiBtaShhLGIsYyl7dmFyIGQ9Yi5wZW5kaW5nUHJvcHMsZT1kLmNoaWxkcmVuLGY9bnVsbCE9PWE/YS5tZW1vaXplZFN0YXRlOm51bGw7aWYoXCJoaWRkZW5cIj09PWQubW9kZXx8XCJ1bnN0YWJsZS1kZWZlci13aXRob3V0LWhpZGluZ1wiPT09ZC5tb2RlKWlmKDA9PT0oYi5tb2RlJjQpKWIubWVtb2l6ZWRTdGF0ZT17YmFzZUxhbmVzOjB9LG5pKGIsYyk7ZWxzZSBpZigwIT09KGMmMTA3Mzc0MTgyNCkpYi5tZW1vaXplZFN0YXRlPXtiYXNlTGFuZXM6MH0sbmkoYixudWxsIT09Zj9mLmJhc2VMYW5lczpjKTtlbHNlIHJldHVybiBhPW51bGwhPT1mP2YuYmFzZUxhbmVzfGM6YyxiLmxhbmVzPWIuY2hpbGRMYW5lcz0xMDczNzQxODI0LGIubWVtb2l6ZWRTdGF0ZT17YmFzZUxhbmVzOmF9LG5pKGIsYSksbnVsbDtlbHNlIG51bGwhPT1mPyhkPWYuYmFzZUxhbmVzfGMsYi5tZW1vaXplZFN0YXRlPW51bGwpOmQ9YyxuaShiLGQpO2ZpKGEsYixlLGMpO3JldHVybiBiLmNoaWxkfVxuZnVuY3Rpb24gb2koYSxiKXt2YXIgYz1iLnJlZjtpZihudWxsPT09YSYmbnVsbCE9PWN8fG51bGwhPT1hJiZhLnJlZiE9PWMpYi5mbGFnc3w9MTI4fWZ1bmN0aW9uIGxpKGEsYixjLGQsZSl7dmFyIGY9RmYoYyk/RGY6TS5jdXJyZW50O2Y9RWYoYixmKTt0ZyhiLGUpO2M9Q2goYSxiLGMsZCxmLGUpO2lmKG51bGwhPT1hJiYhdWcpcmV0dXJuIGIudXBkYXRlUXVldWU9YS51cGRhdGVRdWV1ZSxiLmZsYWdzJj0tNTE3LGEubGFuZXMmPX5lLGhpKGEsYixlKTtiLmZsYWdzfD0xO2ZpKGEsYixjLGUpO3JldHVybiBiLmNoaWxkfVxuZnVuY3Rpb24gcGkoYSxiLGMsZCxlKXtpZihGZihjKSl7dmFyIGY9ITA7SmYoYil9ZWxzZSBmPSExO3RnKGIsZSk7aWYobnVsbD09PWIuc3RhdGVOb2RlKW51bGwhPT1hJiYoYS5hbHRlcm5hdGU9bnVsbCxiLmFsdGVybmF0ZT1udWxsLGIuZmxhZ3N8PTIpLE1nKGIsYyxkKSxPZyhiLGMsZCxlKSxkPSEwO2Vsc2UgaWYobnVsbD09PWEpe3ZhciBnPWIuc3RhdGVOb2RlLGg9Yi5tZW1vaXplZFByb3BzO2cucHJvcHM9aDt2YXIgaz1nLmNvbnRleHQsbD1jLmNvbnRleHRUeXBlO1wib2JqZWN0XCI9PT10eXBlb2YgbCYmbnVsbCE9PWw/bD12ZyhsKToobD1GZihjKT9EZjpNLmN1cnJlbnQsbD1FZihiLGwpKTt2YXIgbj1jLmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyxBPVwiZnVuY3Rpb25cIj09PXR5cGVvZiBufHxcImZ1bmN0aW9uXCI9PT10eXBlb2YgZy5nZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZTtBfHxcImZ1bmN0aW9uXCIhPT10eXBlb2YgZy5VTlNBRkVfY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyYmXG5cImZ1bmN0aW9uXCIhPT10eXBlb2YgZy5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzfHwoaCE9PWR8fGshPT1sKSYmTmcoYixnLGQsbCk7d2c9ITE7dmFyIHA9Yi5tZW1vaXplZFN0YXRlO2cuc3RhdGU9cDtDZyhiLGQsZyxlKTtrPWIubWVtb2l6ZWRTdGF0ZTtoIT09ZHx8cCE9PWt8fE4uY3VycmVudHx8d2c/KFwiZnVuY3Rpb25cIj09PXR5cGVvZiBuJiYoR2coYixjLG4sZCksaz1iLm1lbW9pemVkU3RhdGUpLChoPXdnfHxMZyhiLGMsaCxkLHAsayxsKSk/KEF8fFwiZnVuY3Rpb25cIiE9PXR5cGVvZiBnLlVOU0FGRV9jb21wb25lbnRXaWxsTW91bnQmJlwiZnVuY3Rpb25cIiE9PXR5cGVvZiBnLmNvbXBvbmVudFdpbGxNb3VudHx8KFwiZnVuY3Rpb25cIj09PXR5cGVvZiBnLmNvbXBvbmVudFdpbGxNb3VudCYmZy5jb21wb25lbnRXaWxsTW91bnQoKSxcImZ1bmN0aW9uXCI9PT10eXBlb2YgZy5VTlNBRkVfY29tcG9uZW50V2lsbE1vdW50JiZnLlVOU0FGRV9jb21wb25lbnRXaWxsTW91bnQoKSksXCJmdW5jdGlvblwiPT09XG50eXBlb2YgZy5jb21wb25lbnREaWRNb3VudCYmKGIuZmxhZ3N8PTQpKTooXCJmdW5jdGlvblwiPT09dHlwZW9mIGcuY29tcG9uZW50RGlkTW91bnQmJihiLmZsYWdzfD00KSxiLm1lbW9pemVkUHJvcHM9ZCxiLm1lbW9pemVkU3RhdGU9ayksZy5wcm9wcz1kLGcuc3RhdGU9ayxnLmNvbnRleHQ9bCxkPWgpOihcImZ1bmN0aW9uXCI9PT10eXBlb2YgZy5jb21wb25lbnREaWRNb3VudCYmKGIuZmxhZ3N8PTQpLGQ9ITEpfWVsc2V7Zz1iLnN0YXRlTm9kZTt5ZyhhLGIpO2g9Yi5tZW1vaXplZFByb3BzO2w9Yi50eXBlPT09Yi5lbGVtZW50VHlwZT9oOmxnKGIudHlwZSxoKTtnLnByb3BzPWw7QT1iLnBlbmRpbmdQcm9wcztwPWcuY29udGV4dDtrPWMuY29udGV4dFR5cGU7XCJvYmplY3RcIj09PXR5cGVvZiBrJiZudWxsIT09az9rPXZnKGspOihrPUZmKGMpP0RmOk0uY3VycmVudCxrPUVmKGIsaykpO3ZhciBDPWMuZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzOyhuPVwiZnVuY3Rpb25cIj09PXR5cGVvZiBDfHxcblwiZnVuY3Rpb25cIj09PXR5cGVvZiBnLmdldFNuYXBzaG90QmVmb3JlVXBkYXRlKXx8XCJmdW5jdGlvblwiIT09dHlwZW9mIGcuVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMmJlwiZnVuY3Rpb25cIiE9PXR5cGVvZiBnLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHN8fChoIT09QXx8cCE9PWspJiZOZyhiLGcsZCxrKTt3Zz0hMTtwPWIubWVtb2l6ZWRTdGF0ZTtnLnN0YXRlPXA7Q2coYixkLGcsZSk7dmFyIHg9Yi5tZW1vaXplZFN0YXRlO2ghPT1BfHxwIT09eHx8Ti5jdXJyZW50fHx3Zz8oXCJmdW5jdGlvblwiPT09dHlwZW9mIEMmJihHZyhiLGMsQyxkKSx4PWIubWVtb2l6ZWRTdGF0ZSksKGw9d2d8fExnKGIsYyxsLGQscCx4LGspKT8obnx8XCJmdW5jdGlvblwiIT09dHlwZW9mIGcuVU5TQUZFX2NvbXBvbmVudFdpbGxVcGRhdGUmJlwiZnVuY3Rpb25cIiE9PXR5cGVvZiBnLmNvbXBvbmVudFdpbGxVcGRhdGV8fChcImZ1bmN0aW9uXCI9PT10eXBlb2YgZy5jb21wb25lbnRXaWxsVXBkYXRlJiZnLmNvbXBvbmVudFdpbGxVcGRhdGUoZCxcbngsayksXCJmdW5jdGlvblwiPT09dHlwZW9mIGcuVU5TQUZFX2NvbXBvbmVudFdpbGxVcGRhdGUmJmcuVU5TQUZFX2NvbXBvbmVudFdpbGxVcGRhdGUoZCx4LGspKSxcImZ1bmN0aW9uXCI9PT10eXBlb2YgZy5jb21wb25lbnREaWRVcGRhdGUmJihiLmZsYWdzfD00KSxcImZ1bmN0aW9uXCI9PT10eXBlb2YgZy5nZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSYmKGIuZmxhZ3N8PTI1NikpOihcImZ1bmN0aW9uXCIhPT10eXBlb2YgZy5jb21wb25lbnREaWRVcGRhdGV8fGg9PT1hLm1lbW9pemVkUHJvcHMmJnA9PT1hLm1lbW9pemVkU3RhdGV8fChiLmZsYWdzfD00KSxcImZ1bmN0aW9uXCIhPT10eXBlb2YgZy5nZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZXx8aD09PWEubWVtb2l6ZWRQcm9wcyYmcD09PWEubWVtb2l6ZWRTdGF0ZXx8KGIuZmxhZ3N8PTI1NiksYi5tZW1vaXplZFByb3BzPWQsYi5tZW1vaXplZFN0YXRlPXgpLGcucHJvcHM9ZCxnLnN0YXRlPXgsZy5jb250ZXh0PWssZD1sKTooXCJmdW5jdGlvblwiIT09dHlwZW9mIGcuY29tcG9uZW50RGlkVXBkYXRlfHxcbmg9PT1hLm1lbW9pemVkUHJvcHMmJnA9PT1hLm1lbW9pemVkU3RhdGV8fChiLmZsYWdzfD00KSxcImZ1bmN0aW9uXCIhPT10eXBlb2YgZy5nZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZXx8aD09PWEubWVtb2l6ZWRQcm9wcyYmcD09PWEubWVtb2l6ZWRTdGF0ZXx8KGIuZmxhZ3N8PTI1NiksZD0hMSl9cmV0dXJuIHFpKGEsYixjLGQsZixlKX1cbmZ1bmN0aW9uIHFpKGEsYixjLGQsZSxmKXtvaShhLGIpO3ZhciBnPTAhPT0oYi5mbGFncyY2NCk7aWYoIWQmJiFnKXJldHVybiBlJiZLZihiLGMsITEpLGhpKGEsYixmKTtkPWIuc3RhdGVOb2RlO2VpLmN1cnJlbnQ9Yjt2YXIgaD1nJiZcImZ1bmN0aW9uXCIhPT10eXBlb2YgYy5nZXREZXJpdmVkU3RhdGVGcm9tRXJyb3I/bnVsbDpkLnJlbmRlcigpO2IuZmxhZ3N8PTE7bnVsbCE9PWEmJmc/KGIuY2hpbGQ9WWcoYixhLmNoaWxkLG51bGwsZiksYi5jaGlsZD1ZZyhiLG51bGwsaCxmKSk6ZmkoYSxiLGgsZik7Yi5tZW1vaXplZFN0YXRlPWQuc3RhdGU7ZSYmS2YoYixjLCEwKTtyZXR1cm4gYi5jaGlsZH1mdW5jdGlvbiByaShhKXt2YXIgYj1hLnN0YXRlTm9kZTtiLnBlbmRpbmdDb250ZXh0P0hmKGEsYi5wZW5kaW5nQ29udGV4dCxiLnBlbmRpbmdDb250ZXh0IT09Yi5jb250ZXh0KTpiLmNvbnRleHQmJkhmKGEsYi5jb250ZXh0LCExKTtlaChhLGIuY29udGFpbmVySW5mbyl9XG52YXIgc2k9e2RlaHlkcmF0ZWQ6bnVsbCxyZXRyeUxhbmU6MH07XG5mdW5jdGlvbiB0aShhLGIsYyl7dmFyIGQ9Yi5wZW5kaW5nUHJvcHMsZT1QLmN1cnJlbnQsZj0hMSxnOyhnPTAhPT0oYi5mbGFncyY2NCkpfHwoZz1udWxsIT09YSYmbnVsbD09PWEubWVtb2l6ZWRTdGF0ZT8hMTowIT09KGUmMikpO2c/KGY9ITAsYi5mbGFncyY9LTY1KTpudWxsIT09YSYmbnVsbD09PWEubWVtb2l6ZWRTdGF0ZXx8dm9pZCAwPT09ZC5mYWxsYmFja3x8ITA9PT1kLnVuc3RhYmxlX2F2b2lkVGhpc0ZhbGxiYWNrfHwoZXw9MSk7SShQLGUmMSk7aWYobnVsbD09PWEpe3ZvaWQgMCE9PWQuZmFsbGJhY2smJnBoKGIpO2E9ZC5jaGlsZHJlbjtlPWQuZmFsbGJhY2s7aWYoZilyZXR1cm4gYT11aShiLGEsZSxjKSxiLmNoaWxkLm1lbW9pemVkU3RhdGU9e2Jhc2VMYW5lczpjfSxiLm1lbW9pemVkU3RhdGU9c2ksYTtpZihcIm51bWJlclwiPT09dHlwZW9mIGQudW5zdGFibGVfZXhwZWN0ZWRMb2FkVGltZSlyZXR1cm4gYT11aShiLGEsZSxjKSxiLmNoaWxkLm1lbW9pemVkU3RhdGU9e2Jhc2VMYW5lczpjfSxcbmIubWVtb2l6ZWRTdGF0ZT1zaSxiLmxhbmVzPTMzNTU0NDMyLGE7Yz12aSh7bW9kZTpcInZpc2libGVcIixjaGlsZHJlbjphfSxiLm1vZGUsYyxudWxsKTtjLnJldHVybj1iO3JldHVybiBiLmNoaWxkPWN9aWYobnVsbCE9PWEubWVtb2l6ZWRTdGF0ZSl7aWYoZilyZXR1cm4gZD13aShhLGIsZC5jaGlsZHJlbixkLmZhbGxiYWNrLGMpLGY9Yi5jaGlsZCxlPWEuY2hpbGQubWVtb2l6ZWRTdGF0ZSxmLm1lbW9pemVkU3RhdGU9bnVsbD09PWU/e2Jhc2VMYW5lczpjfTp7YmFzZUxhbmVzOmUuYmFzZUxhbmVzfGN9LGYuY2hpbGRMYW5lcz1hLmNoaWxkTGFuZXMmfmMsYi5tZW1vaXplZFN0YXRlPXNpLGQ7Yz14aShhLGIsZC5jaGlsZHJlbixjKTtiLm1lbW9pemVkU3RhdGU9bnVsbDtyZXR1cm4gY31pZihmKXJldHVybiBkPXdpKGEsYixkLmNoaWxkcmVuLGQuZmFsbGJhY2ssYyksZj1iLmNoaWxkLGU9YS5jaGlsZC5tZW1vaXplZFN0YXRlLGYubWVtb2l6ZWRTdGF0ZT1udWxsPT09ZT97YmFzZUxhbmVzOmN9Olxue2Jhc2VMYW5lczplLmJhc2VMYW5lc3xjfSxmLmNoaWxkTGFuZXM9YS5jaGlsZExhbmVzJn5jLGIubWVtb2l6ZWRTdGF0ZT1zaSxkO2M9eGkoYSxiLGQuY2hpbGRyZW4sYyk7Yi5tZW1vaXplZFN0YXRlPW51bGw7cmV0dXJuIGN9ZnVuY3Rpb24gdWkoYSxiLGMsZCl7dmFyIGU9YS5tb2RlLGY9YS5jaGlsZDtiPXttb2RlOlwiaGlkZGVuXCIsY2hpbGRyZW46Yn07MD09PShlJjIpJiZudWxsIT09Zj8oZi5jaGlsZExhbmVzPTAsZi5wZW5kaW5nUHJvcHM9Yik6Zj12aShiLGUsMCxudWxsKTtjPVhnKGMsZSxkLG51bGwpO2YucmV0dXJuPWE7Yy5yZXR1cm49YTtmLnNpYmxpbmc9YzthLmNoaWxkPWY7cmV0dXJuIGN9XG5mdW5jdGlvbiB4aShhLGIsYyxkKXt2YXIgZT1hLmNoaWxkO2E9ZS5zaWJsaW5nO2M9VGcoZSx7bW9kZTpcInZpc2libGVcIixjaGlsZHJlbjpjfSk7MD09PShiLm1vZGUmMikmJihjLmxhbmVzPWQpO2MucmV0dXJuPWI7Yy5zaWJsaW5nPW51bGw7bnVsbCE9PWEmJihhLm5leHRFZmZlY3Q9bnVsbCxhLmZsYWdzPTgsYi5maXJzdEVmZmVjdD1iLmxhc3RFZmZlY3Q9YSk7cmV0dXJuIGIuY2hpbGQ9Y31cbmZ1bmN0aW9uIHdpKGEsYixjLGQsZSl7dmFyIGY9Yi5tb2RlLGc9YS5jaGlsZDthPWcuc2libGluZzt2YXIgaD17bW9kZTpcImhpZGRlblwiLGNoaWxkcmVuOmN9OzA9PT0oZiYyKSYmYi5jaGlsZCE9PWc/KGM9Yi5jaGlsZCxjLmNoaWxkTGFuZXM9MCxjLnBlbmRpbmdQcm9wcz1oLGc9Yy5sYXN0RWZmZWN0LG51bGwhPT1nPyhiLmZpcnN0RWZmZWN0PWMuZmlyc3RFZmZlY3QsYi5sYXN0RWZmZWN0PWcsZy5uZXh0RWZmZWN0PW51bGwpOmIuZmlyc3RFZmZlY3Q9Yi5sYXN0RWZmZWN0PW51bGwpOmM9VGcoZyxoKTtudWxsIT09YT9kPVRnKGEsZCk6KGQ9WGcoZCxmLGUsbnVsbCksZC5mbGFnc3w9Mik7ZC5yZXR1cm49YjtjLnJldHVybj1iO2Muc2libGluZz1kO2IuY2hpbGQ9YztyZXR1cm4gZH1mdW5jdGlvbiB5aShhLGIpe2EubGFuZXN8PWI7dmFyIGM9YS5hbHRlcm5hdGU7bnVsbCE9PWMmJihjLmxhbmVzfD1iKTtzZyhhLnJldHVybixiKX1cbmZ1bmN0aW9uIHppKGEsYixjLGQsZSxmKXt2YXIgZz1hLm1lbW9pemVkU3RhdGU7bnVsbD09PWc/YS5tZW1vaXplZFN0YXRlPXtpc0JhY2t3YXJkczpiLHJlbmRlcmluZzpudWxsLHJlbmRlcmluZ1N0YXJ0VGltZTowLGxhc3Q6ZCx0YWlsOmMsdGFpbE1vZGU6ZSxsYXN0RWZmZWN0OmZ9OihnLmlzQmFja3dhcmRzPWIsZy5yZW5kZXJpbmc9bnVsbCxnLnJlbmRlcmluZ1N0YXJ0VGltZT0wLGcubGFzdD1kLGcudGFpbD1jLGcudGFpbE1vZGU9ZSxnLmxhc3RFZmZlY3Q9Zil9XG5mdW5jdGlvbiBBaShhLGIsYyl7dmFyIGQ9Yi5wZW5kaW5nUHJvcHMsZT1kLnJldmVhbE9yZGVyLGY9ZC50YWlsO2ZpKGEsYixkLmNoaWxkcmVuLGMpO2Q9UC5jdXJyZW50O2lmKDAhPT0oZCYyKSlkPWQmMXwyLGIuZmxhZ3N8PTY0O2Vsc2V7aWYobnVsbCE9PWEmJjAhPT0oYS5mbGFncyY2NCkpYTpmb3IoYT1iLmNoaWxkO251bGwhPT1hOyl7aWYoMTM9PT1hLnRhZyludWxsIT09YS5tZW1vaXplZFN0YXRlJiZ5aShhLGMpO2Vsc2UgaWYoMTk9PT1hLnRhZyl5aShhLGMpO2Vsc2UgaWYobnVsbCE9PWEuY2hpbGQpe2EuY2hpbGQucmV0dXJuPWE7YT1hLmNoaWxkO2NvbnRpbnVlfWlmKGE9PT1iKWJyZWFrIGE7Zm9yKDtudWxsPT09YS5zaWJsaW5nOyl7aWYobnVsbD09PWEucmV0dXJufHxhLnJldHVybj09PWIpYnJlYWsgYTthPWEucmV0dXJufWEuc2libGluZy5yZXR1cm49YS5yZXR1cm47YT1hLnNpYmxpbmd9ZCY9MX1JKFAsZCk7aWYoMD09PShiLm1vZGUmMikpYi5tZW1vaXplZFN0YXRlPVxubnVsbDtlbHNlIHN3aXRjaChlKXtjYXNlIFwiZm9yd2FyZHNcIjpjPWIuY2hpbGQ7Zm9yKGU9bnVsbDtudWxsIT09YzspYT1jLmFsdGVybmF0ZSxudWxsIT09YSYmbnVsbD09PWloKGEpJiYoZT1jKSxjPWMuc2libGluZztjPWU7bnVsbD09PWM/KGU9Yi5jaGlsZCxiLmNoaWxkPW51bGwpOihlPWMuc2libGluZyxjLnNpYmxpbmc9bnVsbCk7emkoYiwhMSxlLGMsZixiLmxhc3RFZmZlY3QpO2JyZWFrO2Nhc2UgXCJiYWNrd2FyZHNcIjpjPW51bGw7ZT1iLmNoaWxkO2ZvcihiLmNoaWxkPW51bGw7bnVsbCE9PWU7KXthPWUuYWx0ZXJuYXRlO2lmKG51bGwhPT1hJiZudWxsPT09aWgoYSkpe2IuY2hpbGQ9ZTticmVha31hPWUuc2libGluZztlLnNpYmxpbmc9YztjPWU7ZT1hfXppKGIsITAsYyxudWxsLGYsYi5sYXN0RWZmZWN0KTticmVhaztjYXNlIFwidG9nZXRoZXJcIjp6aShiLCExLG51bGwsbnVsbCx2b2lkIDAsYi5sYXN0RWZmZWN0KTticmVhaztkZWZhdWx0OmIubWVtb2l6ZWRTdGF0ZT1udWxsfXJldHVybiBiLmNoaWxkfVxuZnVuY3Rpb24gaGkoYSxiLGMpe251bGwhPT1hJiYoYi5kZXBlbmRlbmNpZXM9YS5kZXBlbmRlbmNpZXMpO0RnfD1iLmxhbmVzO2lmKDAhPT0oYyZiLmNoaWxkTGFuZXMpKXtpZihudWxsIT09YSYmYi5jaGlsZCE9PWEuY2hpbGQpdGhyb3cgRXJyb3IoeSgxNTMpKTtpZihudWxsIT09Yi5jaGlsZCl7YT1iLmNoaWxkO2M9VGcoYSxhLnBlbmRpbmdQcm9wcyk7Yi5jaGlsZD1jO2ZvcihjLnJldHVybj1iO251bGwhPT1hLnNpYmxpbmc7KWE9YS5zaWJsaW5nLGM9Yy5zaWJsaW5nPVRnKGEsYS5wZW5kaW5nUHJvcHMpLGMucmV0dXJuPWI7Yy5zaWJsaW5nPW51bGx9cmV0dXJuIGIuY2hpbGR9cmV0dXJuIG51bGx9dmFyIEJpLENpLERpLEVpO1xuQmk9ZnVuY3Rpb24oYSxiKXtmb3IodmFyIGM9Yi5jaGlsZDtudWxsIT09Yzspe2lmKDU9PT1jLnRhZ3x8Nj09PWMudGFnKWEuYXBwZW5kQ2hpbGQoYy5zdGF0ZU5vZGUpO2Vsc2UgaWYoNCE9PWMudGFnJiZudWxsIT09Yy5jaGlsZCl7Yy5jaGlsZC5yZXR1cm49YztjPWMuY2hpbGQ7Y29udGludWV9aWYoYz09PWIpYnJlYWs7Zm9yKDtudWxsPT09Yy5zaWJsaW5nOyl7aWYobnVsbD09PWMucmV0dXJufHxjLnJldHVybj09PWIpcmV0dXJuO2M9Yy5yZXR1cm59Yy5zaWJsaW5nLnJldHVybj1jLnJldHVybjtjPWMuc2libGluZ319O0NpPWZ1bmN0aW9uKCl7fTtcbkRpPWZ1bmN0aW9uKGEsYixjLGQpe3ZhciBlPWEubWVtb2l6ZWRQcm9wcztpZihlIT09ZCl7YT1iLnN0YXRlTm9kZTtkaChhaC5jdXJyZW50KTt2YXIgZj1udWxsO3N3aXRjaChjKXtjYXNlIFwiaW5wdXRcIjplPVlhKGEsZSk7ZD1ZYShhLGQpO2Y9W107YnJlYWs7Y2FzZSBcIm9wdGlvblwiOmU9ZWIoYSxlKTtkPWViKGEsZCk7Zj1bXTticmVhaztjYXNlIFwic2VsZWN0XCI6ZT1tKHt9LGUse3ZhbHVlOnZvaWQgMH0pO2Q9bSh7fSxkLHt2YWx1ZTp2b2lkIDB9KTtmPVtdO2JyZWFrO2Nhc2UgXCJ0ZXh0YXJlYVwiOmU9Z2IoYSxlKTtkPWdiKGEsZCk7Zj1bXTticmVhaztkZWZhdWx0OlwiZnVuY3Rpb25cIiE9PXR5cGVvZiBlLm9uQ2xpY2smJlwiZnVuY3Rpb25cIj09PXR5cGVvZiBkLm9uQ2xpY2smJihhLm9uY2xpY2s9amYpfXZiKGMsZCk7dmFyIGc7Yz1udWxsO2ZvcihsIGluIGUpaWYoIWQuaGFzT3duUHJvcGVydHkobCkmJmUuaGFzT3duUHJvcGVydHkobCkmJm51bGwhPWVbbF0paWYoXCJzdHlsZVwiPT09XG5sKXt2YXIgaD1lW2xdO2ZvcihnIGluIGgpaC5oYXNPd25Qcm9wZXJ0eShnKSYmKGN8fChjPXt9KSxjW2ddPVwiXCIpfWVsc2VcImRhbmdlcm91c2x5U2V0SW5uZXJIVE1MXCIhPT1sJiZcImNoaWxkcmVuXCIhPT1sJiZcInN1cHByZXNzQ29udGVudEVkaXRhYmxlV2FybmluZ1wiIT09bCYmXCJzdXBwcmVzc0h5ZHJhdGlvbldhcm5pbmdcIiE9PWwmJlwiYXV0b0ZvY3VzXCIhPT1sJiYoY2EuaGFzT3duUHJvcGVydHkobCk/Znx8KGY9W10pOihmPWZ8fFtdKS5wdXNoKGwsbnVsbCkpO2ZvcihsIGluIGQpe3ZhciBrPWRbbF07aD1udWxsIT1lP2VbbF06dm9pZCAwO2lmKGQuaGFzT3duUHJvcGVydHkobCkmJmshPT1oJiYobnVsbCE9a3x8bnVsbCE9aCkpaWYoXCJzdHlsZVwiPT09bClpZihoKXtmb3IoZyBpbiBoKSFoLmhhc093blByb3BlcnR5KGcpfHxrJiZrLmhhc093blByb3BlcnR5KGcpfHwoY3x8KGM9e30pLGNbZ109XCJcIik7Zm9yKGcgaW4gaylrLmhhc093blByb3BlcnR5KGcpJiZoW2ddIT09a1tnXSYmKGN8fFxuKGM9e30pLGNbZ109a1tnXSl9ZWxzZSBjfHwoZnx8KGY9W10pLGYucHVzaChsLGMpKSxjPWs7ZWxzZVwiZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxcIj09PWw/KGs9az9rLl9faHRtbDp2b2lkIDAsaD1oP2guX19odG1sOnZvaWQgMCxudWxsIT1rJiZoIT09ayYmKGY9Znx8W10pLnB1c2gobCxrKSk6XCJjaGlsZHJlblwiPT09bD9cInN0cmluZ1wiIT09dHlwZW9mIGsmJlwibnVtYmVyXCIhPT10eXBlb2Yga3x8KGY9Znx8W10pLnB1c2gobCxcIlwiK2spOlwic3VwcHJlc3NDb250ZW50RWRpdGFibGVXYXJuaW5nXCIhPT1sJiZcInN1cHByZXNzSHlkcmF0aW9uV2FybmluZ1wiIT09bCYmKGNhLmhhc093blByb3BlcnR5KGwpPyhudWxsIT1rJiZcIm9uU2Nyb2xsXCI9PT1sJiZHKFwic2Nyb2xsXCIsYSksZnx8aD09PWt8fChmPVtdKSk6XCJvYmplY3RcIj09PXR5cGVvZiBrJiZudWxsIT09ayYmay4kJHR5cGVvZj09PUdhP2sudG9TdHJpbmcoKTooZj1mfHxbXSkucHVzaChsLGspKX1jJiYoZj1mfHxbXSkucHVzaChcInN0eWxlXCIsXG5jKTt2YXIgbD1mO2lmKGIudXBkYXRlUXVldWU9bCliLmZsYWdzfD00fX07RWk9ZnVuY3Rpb24oYSxiLGMsZCl7YyE9PWQmJihiLmZsYWdzfD00KX07ZnVuY3Rpb24gRmkoYSxiKXtpZighbGgpc3dpdGNoKGEudGFpbE1vZGUpe2Nhc2UgXCJoaWRkZW5cIjpiPWEudGFpbDtmb3IodmFyIGM9bnVsbDtudWxsIT09YjspbnVsbCE9PWIuYWx0ZXJuYXRlJiYoYz1iKSxiPWIuc2libGluZztudWxsPT09Yz9hLnRhaWw9bnVsbDpjLnNpYmxpbmc9bnVsbDticmVhaztjYXNlIFwiY29sbGFwc2VkXCI6Yz1hLnRhaWw7Zm9yKHZhciBkPW51bGw7bnVsbCE9PWM7KW51bGwhPT1jLmFsdGVybmF0ZSYmKGQ9YyksYz1jLnNpYmxpbmc7bnVsbD09PWQ/Ynx8bnVsbD09PWEudGFpbD9hLnRhaWw9bnVsbDphLnRhaWwuc2libGluZz1udWxsOmQuc2libGluZz1udWxsfX1cbmZ1bmN0aW9uIEdpKGEsYixjKXt2YXIgZD1iLnBlbmRpbmdQcm9wcztzd2l0Y2goYi50YWcpe2Nhc2UgMjpjYXNlIDE2OmNhc2UgMTU6Y2FzZSAwOmNhc2UgMTE6Y2FzZSA3OmNhc2UgODpjYXNlIDEyOmNhc2UgOTpjYXNlIDE0OnJldHVybiBudWxsO2Nhc2UgMTpyZXR1cm4gRmYoYi50eXBlKSYmR2YoKSxudWxsO2Nhc2UgMzpmaCgpO0goTik7SChNKTt1aCgpO2Q9Yi5zdGF0ZU5vZGU7ZC5wZW5kaW5nQ29udGV4dCYmKGQuY29udGV4dD1kLnBlbmRpbmdDb250ZXh0LGQucGVuZGluZ0NvbnRleHQ9bnVsbCk7aWYobnVsbD09PWF8fG51bGw9PT1hLmNoaWxkKXJoKGIpP2IuZmxhZ3N8PTQ6ZC5oeWRyYXRlfHwoYi5mbGFnc3w9MjU2KTtDaShiKTtyZXR1cm4gbnVsbDtjYXNlIDU6aGgoYik7dmFyIGU9ZGgoY2guY3VycmVudCk7Yz1iLnR5cGU7aWYobnVsbCE9PWEmJm51bGwhPWIuc3RhdGVOb2RlKURpKGEsYixjLGQsZSksYS5yZWYhPT1iLnJlZiYmKGIuZmxhZ3N8PTEyOCk7ZWxzZXtpZighZCl7aWYobnVsbD09PVxuYi5zdGF0ZU5vZGUpdGhyb3cgRXJyb3IoeSgxNjYpKTtyZXR1cm4gbnVsbH1hPWRoKGFoLmN1cnJlbnQpO2lmKHJoKGIpKXtkPWIuc3RhdGVOb2RlO2M9Yi50eXBlO3ZhciBmPWIubWVtb2l6ZWRQcm9wcztkW3dmXT1iO2RbeGZdPWY7c3dpdGNoKGMpe2Nhc2UgXCJkaWFsb2dcIjpHKFwiY2FuY2VsXCIsZCk7RyhcImNsb3NlXCIsZCk7YnJlYWs7Y2FzZSBcImlmcmFtZVwiOmNhc2UgXCJvYmplY3RcIjpjYXNlIFwiZW1iZWRcIjpHKFwibG9hZFwiLGQpO2JyZWFrO2Nhc2UgXCJ2aWRlb1wiOmNhc2UgXCJhdWRpb1wiOmZvcihhPTA7YTxYZS5sZW5ndGg7YSsrKUcoWGVbYV0sZCk7YnJlYWs7Y2FzZSBcInNvdXJjZVwiOkcoXCJlcnJvclwiLGQpO2JyZWFrO2Nhc2UgXCJpbWdcIjpjYXNlIFwiaW1hZ2VcIjpjYXNlIFwibGlua1wiOkcoXCJlcnJvclwiLGQpO0coXCJsb2FkXCIsZCk7YnJlYWs7Y2FzZSBcImRldGFpbHNcIjpHKFwidG9nZ2xlXCIsZCk7YnJlYWs7Y2FzZSBcImlucHV0XCI6WmEoZCxmKTtHKFwiaW52YWxpZFwiLGQpO2JyZWFrO2Nhc2UgXCJzZWxlY3RcIjpkLl93cmFwcGVyU3RhdGU9XG57d2FzTXVsdGlwbGU6ISFmLm11bHRpcGxlfTtHKFwiaW52YWxpZFwiLGQpO2JyZWFrO2Nhc2UgXCJ0ZXh0YXJlYVwiOmhiKGQsZiksRyhcImludmFsaWRcIixkKX12YihjLGYpO2E9bnVsbDtmb3IodmFyIGcgaW4gZilmLmhhc093blByb3BlcnR5KGcpJiYoZT1mW2ddLFwiY2hpbGRyZW5cIj09PWc/XCJzdHJpbmdcIj09PXR5cGVvZiBlP2QudGV4dENvbnRlbnQhPT1lJiYoYT1bXCJjaGlsZHJlblwiLGVdKTpcIm51bWJlclwiPT09dHlwZW9mIGUmJmQudGV4dENvbnRlbnQhPT1cIlwiK2UmJihhPVtcImNoaWxkcmVuXCIsXCJcIitlXSk6Y2EuaGFzT3duUHJvcGVydHkoZykmJm51bGwhPWUmJlwib25TY3JvbGxcIj09PWcmJkcoXCJzY3JvbGxcIixkKSk7c3dpdGNoKGMpe2Nhc2UgXCJpbnB1dFwiOlZhKGQpO2NiKGQsZiwhMCk7YnJlYWs7Y2FzZSBcInRleHRhcmVhXCI6VmEoZCk7amIoZCk7YnJlYWs7Y2FzZSBcInNlbGVjdFwiOmNhc2UgXCJvcHRpb25cIjpicmVhaztkZWZhdWx0OlwiZnVuY3Rpb25cIj09PXR5cGVvZiBmLm9uQ2xpY2smJihkLm9uY2xpY2s9XG5qZil9ZD1hO2IudXBkYXRlUXVldWU9ZDtudWxsIT09ZCYmKGIuZmxhZ3N8PTQpfWVsc2V7Zz05PT09ZS5ub2RlVHlwZT9lOmUub3duZXJEb2N1bWVudDthPT09a2IuaHRtbCYmKGE9bGIoYykpO2E9PT1rYi5odG1sP1wic2NyaXB0XCI9PT1jPyhhPWcuY3JlYXRlRWxlbWVudChcImRpdlwiKSxhLmlubmVySFRNTD1cIjxzY3JpcHQ+XFx4M2Mvc2NyaXB0PlwiLGE9YS5yZW1vdmVDaGlsZChhLmZpcnN0Q2hpbGQpKTpcInN0cmluZ1wiPT09dHlwZW9mIGQuaXM/YT1nLmNyZWF0ZUVsZW1lbnQoYyx7aXM6ZC5pc30pOihhPWcuY3JlYXRlRWxlbWVudChjKSxcInNlbGVjdFwiPT09YyYmKGc9YSxkLm11bHRpcGxlP2cubXVsdGlwbGU9ITA6ZC5zaXplJiYoZy5zaXplPWQuc2l6ZSkpKTphPWcuY3JlYXRlRWxlbWVudE5TKGEsYyk7YVt3Zl09YjthW3hmXT1kO0JpKGEsYiwhMSwhMSk7Yi5zdGF0ZU5vZGU9YTtnPXdiKGMsZCk7c3dpdGNoKGMpe2Nhc2UgXCJkaWFsb2dcIjpHKFwiY2FuY2VsXCIsYSk7RyhcImNsb3NlXCIsYSk7XG5lPWQ7YnJlYWs7Y2FzZSBcImlmcmFtZVwiOmNhc2UgXCJvYmplY3RcIjpjYXNlIFwiZW1iZWRcIjpHKFwibG9hZFwiLGEpO2U9ZDticmVhaztjYXNlIFwidmlkZW9cIjpjYXNlIFwiYXVkaW9cIjpmb3IoZT0wO2U8WGUubGVuZ3RoO2UrKylHKFhlW2VdLGEpO2U9ZDticmVhaztjYXNlIFwic291cmNlXCI6RyhcImVycm9yXCIsYSk7ZT1kO2JyZWFrO2Nhc2UgXCJpbWdcIjpjYXNlIFwiaW1hZ2VcIjpjYXNlIFwibGlua1wiOkcoXCJlcnJvclwiLGEpO0coXCJsb2FkXCIsYSk7ZT1kO2JyZWFrO2Nhc2UgXCJkZXRhaWxzXCI6RyhcInRvZ2dsZVwiLGEpO2U9ZDticmVhaztjYXNlIFwiaW5wdXRcIjpaYShhLGQpO2U9WWEoYSxkKTtHKFwiaW52YWxpZFwiLGEpO2JyZWFrO2Nhc2UgXCJvcHRpb25cIjplPWViKGEsZCk7YnJlYWs7Y2FzZSBcInNlbGVjdFwiOmEuX3dyYXBwZXJTdGF0ZT17d2FzTXVsdGlwbGU6ISFkLm11bHRpcGxlfTtlPW0oe30sZCx7dmFsdWU6dm9pZCAwfSk7RyhcImludmFsaWRcIixhKTticmVhaztjYXNlIFwidGV4dGFyZWFcIjpoYihhLGQpO2U9XG5nYihhLGQpO0coXCJpbnZhbGlkXCIsYSk7YnJlYWs7ZGVmYXVsdDplPWR9dmIoYyxlKTt2YXIgaD1lO2ZvcihmIGluIGgpaWYoaC5oYXNPd25Qcm9wZXJ0eShmKSl7dmFyIGs9aFtmXTtcInN0eWxlXCI9PT1mP3RiKGEsayk6XCJkYW5nZXJvdXNseVNldElubmVySFRNTFwiPT09Zj8oaz1rP2suX19odG1sOnZvaWQgMCxudWxsIT1rJiZvYihhLGspKTpcImNoaWxkcmVuXCI9PT1mP1wic3RyaW5nXCI9PT10eXBlb2Ygaz8oXCJ0ZXh0YXJlYVwiIT09Y3x8XCJcIiE9PWspJiZwYihhLGspOlwibnVtYmVyXCI9PT10eXBlb2YgayYmcGIoYSxcIlwiK2spOlwic3VwcHJlc3NDb250ZW50RWRpdGFibGVXYXJuaW5nXCIhPT1mJiZcInN1cHByZXNzSHlkcmF0aW9uV2FybmluZ1wiIT09ZiYmXCJhdXRvRm9jdXNcIiE9PWYmJihjYS5oYXNPd25Qcm9wZXJ0eShmKT9udWxsIT1rJiZcIm9uU2Nyb2xsXCI9PT1mJiZHKFwic2Nyb2xsXCIsYSk6bnVsbCE9ayYmcWEoYSxmLGssZykpfXN3aXRjaChjKXtjYXNlIFwiaW5wdXRcIjpWYShhKTtjYihhLGQsITEpO1xuYnJlYWs7Y2FzZSBcInRleHRhcmVhXCI6VmEoYSk7amIoYSk7YnJlYWs7Y2FzZSBcIm9wdGlvblwiOm51bGwhPWQudmFsdWUmJmEuc2V0QXR0cmlidXRlKFwidmFsdWVcIixcIlwiK1NhKGQudmFsdWUpKTticmVhaztjYXNlIFwic2VsZWN0XCI6YS5tdWx0aXBsZT0hIWQubXVsdGlwbGU7Zj1kLnZhbHVlO251bGwhPWY/ZmIoYSwhIWQubXVsdGlwbGUsZiwhMSk6bnVsbCE9ZC5kZWZhdWx0VmFsdWUmJmZiKGEsISFkLm11bHRpcGxlLGQuZGVmYXVsdFZhbHVlLCEwKTticmVhaztkZWZhdWx0OlwiZnVuY3Rpb25cIj09PXR5cGVvZiBlLm9uQ2xpY2smJihhLm9uY2xpY2s9amYpfW1mKGMsZCkmJihiLmZsYWdzfD00KX1udWxsIT09Yi5yZWYmJihiLmZsYWdzfD0xMjgpfXJldHVybiBudWxsO2Nhc2UgNjppZihhJiZudWxsIT1iLnN0YXRlTm9kZSlFaShhLGIsYS5tZW1vaXplZFByb3BzLGQpO2Vsc2V7aWYoXCJzdHJpbmdcIiE9PXR5cGVvZiBkJiZudWxsPT09Yi5zdGF0ZU5vZGUpdGhyb3cgRXJyb3IoeSgxNjYpKTtcbmM9ZGgoY2guY3VycmVudCk7ZGgoYWguY3VycmVudCk7cmgoYik/KGQ9Yi5zdGF0ZU5vZGUsYz1iLm1lbW9pemVkUHJvcHMsZFt3Zl09YixkLm5vZGVWYWx1ZSE9PWMmJihiLmZsYWdzfD00KSk6KGQ9KDk9PT1jLm5vZGVUeXBlP2M6Yy5vd25lckRvY3VtZW50KS5jcmVhdGVUZXh0Tm9kZShkKSxkW3dmXT1iLGIuc3RhdGVOb2RlPWQpfXJldHVybiBudWxsO2Nhc2UgMTM6SChQKTtkPWIubWVtb2l6ZWRTdGF0ZTtpZigwIT09KGIuZmxhZ3MmNjQpKXJldHVybiBiLmxhbmVzPWMsYjtkPW51bGwhPT1kO2M9ITE7bnVsbD09PWE/dm9pZCAwIT09Yi5tZW1vaXplZFByb3BzLmZhbGxiYWNrJiZyaChiKTpjPW51bGwhPT1hLm1lbW9pemVkU3RhdGU7aWYoZCYmIWMmJjAhPT0oYi5tb2RlJjIpKWlmKG51bGw9PT1hJiYhMCE9PWIubWVtb2l6ZWRQcm9wcy51bnN0YWJsZV9hdm9pZFRoaXNGYWxsYmFja3x8MCE9PShQLmN1cnJlbnQmMSkpMD09PVYmJihWPTMpO2Vsc2V7aWYoMD09PVZ8fDM9PT1WKVY9XG40O251bGw9PT1VfHwwPT09KERnJjEzNDIxNzcyNykmJjA9PT0oSGkmMTM0MjE3NzI3KXx8SWkoVSxXKX1pZihkfHxjKWIuZmxhZ3N8PTQ7cmV0dXJuIG51bGw7Y2FzZSA0OnJldHVybiBmaCgpLENpKGIpLG51bGw9PT1hJiZjZihiLnN0YXRlTm9kZS5jb250YWluZXJJbmZvKSxudWxsO2Nhc2UgMTA6cmV0dXJuIHJnKGIpLG51bGw7Y2FzZSAxNzpyZXR1cm4gRmYoYi50eXBlKSYmR2YoKSxudWxsO2Nhc2UgMTk6SChQKTtkPWIubWVtb2l6ZWRTdGF0ZTtpZihudWxsPT09ZClyZXR1cm4gbnVsbDtmPTAhPT0oYi5mbGFncyY2NCk7Zz1kLnJlbmRlcmluZztpZihudWxsPT09ZylpZihmKUZpKGQsITEpO2Vsc2V7aWYoMCE9PVZ8fG51bGwhPT1hJiYwIT09KGEuZmxhZ3MmNjQpKWZvcihhPWIuY2hpbGQ7bnVsbCE9PWE7KXtnPWloKGEpO2lmKG51bGwhPT1nKXtiLmZsYWdzfD02NDtGaShkLCExKTtmPWcudXBkYXRlUXVldWU7bnVsbCE9PWYmJihiLnVwZGF0ZVF1ZXVlPWYsYi5mbGFnc3w9NCk7XG5udWxsPT09ZC5sYXN0RWZmZWN0JiYoYi5maXJzdEVmZmVjdD1udWxsKTtiLmxhc3RFZmZlY3Q9ZC5sYXN0RWZmZWN0O2Q9Yztmb3IoYz1iLmNoaWxkO251bGwhPT1jOylmPWMsYT1kLGYuZmxhZ3MmPTIsZi5uZXh0RWZmZWN0PW51bGwsZi5maXJzdEVmZmVjdD1udWxsLGYubGFzdEVmZmVjdD1udWxsLGc9Zi5hbHRlcm5hdGUsbnVsbD09PWc/KGYuY2hpbGRMYW5lcz0wLGYubGFuZXM9YSxmLmNoaWxkPW51bGwsZi5tZW1vaXplZFByb3BzPW51bGwsZi5tZW1vaXplZFN0YXRlPW51bGwsZi51cGRhdGVRdWV1ZT1udWxsLGYuZGVwZW5kZW5jaWVzPW51bGwsZi5zdGF0ZU5vZGU9bnVsbCk6KGYuY2hpbGRMYW5lcz1nLmNoaWxkTGFuZXMsZi5sYW5lcz1nLmxhbmVzLGYuY2hpbGQ9Zy5jaGlsZCxmLm1lbW9pemVkUHJvcHM9Zy5tZW1vaXplZFByb3BzLGYubWVtb2l6ZWRTdGF0ZT1nLm1lbW9pemVkU3RhdGUsZi51cGRhdGVRdWV1ZT1nLnVwZGF0ZVF1ZXVlLGYudHlwZT1nLnR5cGUsYT1nLmRlcGVuZGVuY2llcyxcbmYuZGVwZW5kZW5jaWVzPW51bGw9PT1hP251bGw6e2xhbmVzOmEubGFuZXMsZmlyc3RDb250ZXh0OmEuZmlyc3RDb250ZXh0fSksYz1jLnNpYmxpbmc7SShQLFAuY3VycmVudCYxfDIpO3JldHVybiBiLmNoaWxkfWE9YS5zaWJsaW5nfW51bGwhPT1kLnRhaWwmJk8oKT5KaSYmKGIuZmxhZ3N8PTY0LGY9ITAsRmkoZCwhMSksYi5sYW5lcz0zMzU1NDQzMil9ZWxzZXtpZighZilpZihhPWloKGcpLG51bGwhPT1hKXtpZihiLmZsYWdzfD02NCxmPSEwLGM9YS51cGRhdGVRdWV1ZSxudWxsIT09YyYmKGIudXBkYXRlUXVldWU9YyxiLmZsYWdzfD00KSxGaShkLCEwKSxudWxsPT09ZC50YWlsJiZcImhpZGRlblwiPT09ZC50YWlsTW9kZSYmIWcuYWx0ZXJuYXRlJiYhbGgpcmV0dXJuIGI9Yi5sYXN0RWZmZWN0PWQubGFzdEVmZmVjdCxudWxsIT09YiYmKGIubmV4dEVmZmVjdD1udWxsKSxudWxsfWVsc2UgMipPKCktZC5yZW5kZXJpbmdTdGFydFRpbWU+SmkmJjEwNzM3NDE4MjQhPT1jJiYoYi5mbGFnc3w9XG42NCxmPSEwLEZpKGQsITEpLGIubGFuZXM9MzM1NTQ0MzIpO2QuaXNCYWNrd2FyZHM/KGcuc2libGluZz1iLmNoaWxkLGIuY2hpbGQ9Zyk6KGM9ZC5sYXN0LG51bGwhPT1jP2Muc2libGluZz1nOmIuY2hpbGQ9ZyxkLmxhc3Q9Zyl9cmV0dXJuIG51bGwhPT1kLnRhaWw/KGM9ZC50YWlsLGQucmVuZGVyaW5nPWMsZC50YWlsPWMuc2libGluZyxkLmxhc3RFZmZlY3Q9Yi5sYXN0RWZmZWN0LGQucmVuZGVyaW5nU3RhcnRUaW1lPU8oKSxjLnNpYmxpbmc9bnVsbCxiPVAuY3VycmVudCxJKFAsZj9iJjF8MjpiJjEpLGMpOm51bGw7Y2FzZSAyMzpjYXNlIDI0OnJldHVybiBLaSgpLG51bGwhPT1hJiZudWxsIT09YS5tZW1vaXplZFN0YXRlIT09KG51bGwhPT1iLm1lbW9pemVkU3RhdGUpJiZcInVuc3RhYmxlLWRlZmVyLXdpdGhvdXQtaGlkaW5nXCIhPT1kLm1vZGUmJihiLmZsYWdzfD00KSxudWxsfXRocm93IEVycm9yKHkoMTU2LGIudGFnKSk7fVxuZnVuY3Rpb24gTGkoYSl7c3dpdGNoKGEudGFnKXtjYXNlIDE6RmYoYS50eXBlKSYmR2YoKTt2YXIgYj1hLmZsYWdzO3JldHVybiBiJjQwOTY/KGEuZmxhZ3M9YiYtNDA5N3w2NCxhKTpudWxsO2Nhc2UgMzpmaCgpO0goTik7SChNKTt1aCgpO2I9YS5mbGFncztpZigwIT09KGImNjQpKXRocm93IEVycm9yKHkoMjg1KSk7YS5mbGFncz1iJi00MDk3fDY0O3JldHVybiBhO2Nhc2UgNTpyZXR1cm4gaGgoYSksbnVsbDtjYXNlIDEzOnJldHVybiBIKFApLGI9YS5mbGFncyxiJjQwOTY/KGEuZmxhZ3M9YiYtNDA5N3w2NCxhKTpudWxsO2Nhc2UgMTk6cmV0dXJuIEgoUCksbnVsbDtjYXNlIDQ6cmV0dXJuIGZoKCksbnVsbDtjYXNlIDEwOnJldHVybiByZyhhKSxudWxsO2Nhc2UgMjM6Y2FzZSAyNDpyZXR1cm4gS2koKSxudWxsO2RlZmF1bHQ6cmV0dXJuIG51bGx9fVxuZnVuY3Rpb24gTWkoYSxiKXt0cnl7dmFyIGM9XCJcIixkPWI7ZG8gYys9UWEoZCksZD1kLnJldHVybjt3aGlsZShkKTt2YXIgZT1jfWNhdGNoKGYpe2U9XCJcXG5FcnJvciBnZW5lcmF0aW5nIHN0YWNrOiBcIitmLm1lc3NhZ2UrXCJcXG5cIitmLnN0YWNrfXJldHVybnt2YWx1ZTphLHNvdXJjZTpiLHN0YWNrOmV9fWZ1bmN0aW9uIE5pKGEsYil7dHJ5e2NvbnNvbGUuZXJyb3IoYi52YWx1ZSl9Y2F0Y2goYyl7c2V0VGltZW91dChmdW5jdGlvbigpe3Rocm93IGM7fSl9fXZhciBPaT1cImZ1bmN0aW9uXCI9PT10eXBlb2YgV2Vha01hcD9XZWFrTWFwOk1hcDtmdW5jdGlvbiBQaShhLGIsYyl7Yz16ZygtMSxjKTtjLnRhZz0zO2MucGF5bG9hZD17ZWxlbWVudDpudWxsfTt2YXIgZD1iLnZhbHVlO2MuY2FsbGJhY2s9ZnVuY3Rpb24oKXtRaXx8KFFpPSEwLFJpPWQpO05pKGEsYil9O3JldHVybiBjfVxuZnVuY3Rpb24gU2koYSxiLGMpe2M9emcoLTEsYyk7Yy50YWc9Mzt2YXIgZD1hLnR5cGUuZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yO2lmKFwiZnVuY3Rpb25cIj09PXR5cGVvZiBkKXt2YXIgZT1iLnZhbHVlO2MucGF5bG9hZD1mdW5jdGlvbigpe05pKGEsYik7cmV0dXJuIGQoZSl9fXZhciBmPWEuc3RhdGVOb2RlO251bGwhPT1mJiZcImZ1bmN0aW9uXCI9PT10eXBlb2YgZi5jb21wb25lbnREaWRDYXRjaCYmKGMuY2FsbGJhY2s9ZnVuY3Rpb24oKXtcImZ1bmN0aW9uXCIhPT10eXBlb2YgZCYmKG51bGw9PT1UaT9UaT1uZXcgU2V0KFt0aGlzXSk6VGkuYWRkKHRoaXMpLE5pKGEsYikpO3ZhciBjPWIuc3RhY2s7dGhpcy5jb21wb25lbnREaWRDYXRjaChiLnZhbHVlLHtjb21wb25lbnRTdGFjazpudWxsIT09Yz9jOlwiXCJ9KX0pO3JldHVybiBjfXZhciBVaT1cImZ1bmN0aW9uXCI9PT10eXBlb2YgV2Vha1NldD9XZWFrU2V0OlNldDtcbmZ1bmN0aW9uIFZpKGEpe3ZhciBiPWEucmVmO2lmKG51bGwhPT1iKWlmKFwiZnVuY3Rpb25cIj09PXR5cGVvZiBiKXRyeXtiKG51bGwpfWNhdGNoKGMpe1dpKGEsYyl9ZWxzZSBiLmN1cnJlbnQ9bnVsbH1mdW5jdGlvbiBYaShhLGIpe3N3aXRjaChiLnRhZyl7Y2FzZSAwOmNhc2UgMTE6Y2FzZSAxNTpjYXNlIDIyOnJldHVybjtjYXNlIDE6aWYoYi5mbGFncyYyNTYmJm51bGwhPT1hKXt2YXIgYz1hLm1lbW9pemVkUHJvcHMsZD1hLm1lbW9pemVkU3RhdGU7YT1iLnN0YXRlTm9kZTtiPWEuZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUoYi5lbGVtZW50VHlwZT09PWIudHlwZT9jOmxnKGIudHlwZSxjKSxkKTthLl9fcmVhY3RJbnRlcm5hbFNuYXBzaG90QmVmb3JlVXBkYXRlPWJ9cmV0dXJuO2Nhc2UgMzpiLmZsYWdzJjI1NiYmcWYoYi5zdGF0ZU5vZGUuY29udGFpbmVySW5mbyk7cmV0dXJuO2Nhc2UgNTpjYXNlIDY6Y2FzZSA0OmNhc2UgMTc6cmV0dXJufXRocm93IEVycm9yKHkoMTYzKSk7fVxuZnVuY3Rpb24gWWkoYSxiLGMpe3N3aXRjaChjLnRhZyl7Y2FzZSAwOmNhc2UgMTE6Y2FzZSAxNTpjYXNlIDIyOmI9Yy51cGRhdGVRdWV1ZTtiPW51bGwhPT1iP2IubGFzdEVmZmVjdDpudWxsO2lmKG51bGwhPT1iKXthPWI9Yi5uZXh0O2Rve2lmKDM9PT0oYS50YWcmMykpe3ZhciBkPWEuY3JlYXRlO2EuZGVzdHJveT1kKCl9YT1hLm5leHR9d2hpbGUoYSE9PWIpfWI9Yy51cGRhdGVRdWV1ZTtiPW51bGwhPT1iP2IubGFzdEVmZmVjdDpudWxsO2lmKG51bGwhPT1iKXthPWI9Yi5uZXh0O2Rve3ZhciBlPWE7ZD1lLm5leHQ7ZT1lLnRhZzswIT09KGUmNCkmJjAhPT0oZSYxKSYmKFppKGMsYSksJGkoYyxhKSk7YT1kfXdoaWxlKGEhPT1iKX1yZXR1cm47Y2FzZSAxOmE9Yy5zdGF0ZU5vZGU7Yy5mbGFncyY0JiYobnVsbD09PWI/YS5jb21wb25lbnREaWRNb3VudCgpOihkPWMuZWxlbWVudFR5cGU9PT1jLnR5cGU/Yi5tZW1vaXplZFByb3BzOmxnKGMudHlwZSxiLm1lbW9pemVkUHJvcHMpLGEuY29tcG9uZW50RGlkVXBkYXRlKGQsXG5iLm1lbW9pemVkU3RhdGUsYS5fX3JlYWN0SW50ZXJuYWxTbmFwc2hvdEJlZm9yZVVwZGF0ZSkpKTtiPWMudXBkYXRlUXVldWU7bnVsbCE9PWImJkVnKGMsYixhKTtyZXR1cm47Y2FzZSAzOmI9Yy51cGRhdGVRdWV1ZTtpZihudWxsIT09Yil7YT1udWxsO2lmKG51bGwhPT1jLmNoaWxkKXN3aXRjaChjLmNoaWxkLnRhZyl7Y2FzZSA1OmE9Yy5jaGlsZC5zdGF0ZU5vZGU7YnJlYWs7Y2FzZSAxOmE9Yy5jaGlsZC5zdGF0ZU5vZGV9RWcoYyxiLGEpfXJldHVybjtjYXNlIDU6YT1jLnN0YXRlTm9kZTtudWxsPT09YiYmYy5mbGFncyY0JiZtZihjLnR5cGUsYy5tZW1vaXplZFByb3BzKSYmYS5mb2N1cygpO3JldHVybjtjYXNlIDY6cmV0dXJuO2Nhc2UgNDpyZXR1cm47Y2FzZSAxMjpyZXR1cm47Y2FzZSAxMzpudWxsPT09Yy5tZW1vaXplZFN0YXRlJiYoYz1jLmFsdGVybmF0ZSxudWxsIT09YyYmKGM9Yy5tZW1vaXplZFN0YXRlLG51bGwhPT1jJiYoYz1jLmRlaHlkcmF0ZWQsbnVsbCE9PWMmJkNjKGMpKSkpO1xucmV0dXJuO2Nhc2UgMTk6Y2FzZSAxNzpjYXNlIDIwOmNhc2UgMjE6Y2FzZSAyMzpjYXNlIDI0OnJldHVybn10aHJvdyBFcnJvcih5KDE2MykpO31cbmZ1bmN0aW9uIGFqKGEsYil7Zm9yKHZhciBjPWE7Oyl7aWYoNT09PWMudGFnKXt2YXIgZD1jLnN0YXRlTm9kZTtpZihiKWQ9ZC5zdHlsZSxcImZ1bmN0aW9uXCI9PT10eXBlb2YgZC5zZXRQcm9wZXJ0eT9kLnNldFByb3BlcnR5KFwiZGlzcGxheVwiLFwibm9uZVwiLFwiaW1wb3J0YW50XCIpOmQuZGlzcGxheT1cIm5vbmVcIjtlbHNle2Q9Yy5zdGF0ZU5vZGU7dmFyIGU9Yy5tZW1vaXplZFByb3BzLnN0eWxlO2U9dm9pZCAwIT09ZSYmbnVsbCE9PWUmJmUuaGFzT3duUHJvcGVydHkoXCJkaXNwbGF5XCIpP2UuZGlzcGxheTpudWxsO2Quc3R5bGUuZGlzcGxheT1zYihcImRpc3BsYXlcIixlKX19ZWxzZSBpZig2PT09Yy50YWcpYy5zdGF0ZU5vZGUubm9kZVZhbHVlPWI/XCJcIjpjLm1lbW9pemVkUHJvcHM7ZWxzZSBpZigoMjMhPT1jLnRhZyYmMjQhPT1jLnRhZ3x8bnVsbD09PWMubWVtb2l6ZWRTdGF0ZXx8Yz09PWEpJiZudWxsIT09Yy5jaGlsZCl7Yy5jaGlsZC5yZXR1cm49YztjPWMuY2hpbGQ7Y29udGludWV9aWYoYz09PVxuYSlicmVhaztmb3IoO251bGw9PT1jLnNpYmxpbmc7KXtpZihudWxsPT09Yy5yZXR1cm58fGMucmV0dXJuPT09YSlyZXR1cm47Yz1jLnJldHVybn1jLnNpYmxpbmcucmV0dXJuPWMucmV0dXJuO2M9Yy5zaWJsaW5nfX1cbmZ1bmN0aW9uIGJqKGEsYil7aWYoTWYmJlwiZnVuY3Rpb25cIj09PXR5cGVvZiBNZi5vbkNvbW1pdEZpYmVyVW5tb3VudCl0cnl7TWYub25Db21taXRGaWJlclVubW91bnQoTGYsYil9Y2F0Y2goZil7fXN3aXRjaChiLnRhZyl7Y2FzZSAwOmNhc2UgMTE6Y2FzZSAxNDpjYXNlIDE1OmNhc2UgMjI6YT1iLnVwZGF0ZVF1ZXVlO2lmKG51bGwhPT1hJiYoYT1hLmxhc3RFZmZlY3QsbnVsbCE9PWEpKXt2YXIgYz1hPWEubmV4dDtkb3t2YXIgZD1jLGU9ZC5kZXN0cm95O2Q9ZC50YWc7aWYodm9pZCAwIT09ZSlpZigwIT09KGQmNCkpWmkoYixjKTtlbHNle2Q9Yjt0cnl7ZSgpfWNhdGNoKGYpe1dpKGQsZil9fWM9Yy5uZXh0fXdoaWxlKGMhPT1hKX1icmVhaztjYXNlIDE6VmkoYik7YT1iLnN0YXRlTm9kZTtpZihcImZ1bmN0aW9uXCI9PT10eXBlb2YgYS5jb21wb25lbnRXaWxsVW5tb3VudCl0cnl7YS5wcm9wcz1iLm1lbW9pemVkUHJvcHMsYS5zdGF0ZT1iLm1lbW9pemVkU3RhdGUsYS5jb21wb25lbnRXaWxsVW5tb3VudCgpfWNhdGNoKGYpe1dpKGIsXG5mKX1icmVhaztjYXNlIDU6VmkoYik7YnJlYWs7Y2FzZSA0OmNqKGEsYil9fWZ1bmN0aW9uIGRqKGEpe2EuYWx0ZXJuYXRlPW51bGw7YS5jaGlsZD1udWxsO2EuZGVwZW5kZW5jaWVzPW51bGw7YS5maXJzdEVmZmVjdD1udWxsO2EubGFzdEVmZmVjdD1udWxsO2EubWVtb2l6ZWRQcm9wcz1udWxsO2EubWVtb2l6ZWRTdGF0ZT1udWxsO2EucGVuZGluZ1Byb3BzPW51bGw7YS5yZXR1cm49bnVsbDthLnVwZGF0ZVF1ZXVlPW51bGx9ZnVuY3Rpb24gZWooYSl7cmV0dXJuIDU9PT1hLnRhZ3x8Mz09PWEudGFnfHw0PT09YS50YWd9XG5mdW5jdGlvbiBmaihhKXthOntmb3IodmFyIGI9YS5yZXR1cm47bnVsbCE9PWI7KXtpZihlaihiKSlicmVhayBhO2I9Yi5yZXR1cm59dGhyb3cgRXJyb3IoeSgxNjApKTt9dmFyIGM9YjtiPWMuc3RhdGVOb2RlO3N3aXRjaChjLnRhZyl7Y2FzZSA1OnZhciBkPSExO2JyZWFrO2Nhc2UgMzpiPWIuY29udGFpbmVySW5mbztkPSEwO2JyZWFrO2Nhc2UgNDpiPWIuY29udGFpbmVySW5mbztkPSEwO2JyZWFrO2RlZmF1bHQ6dGhyb3cgRXJyb3IoeSgxNjEpKTt9Yy5mbGFncyYxNiYmKHBiKGIsXCJcIiksYy5mbGFncyY9LTE3KTthOmI6Zm9yKGM9YTs7KXtmb3IoO251bGw9PT1jLnNpYmxpbmc7KXtpZihudWxsPT09Yy5yZXR1cm58fGVqKGMucmV0dXJuKSl7Yz1udWxsO2JyZWFrIGF9Yz1jLnJldHVybn1jLnNpYmxpbmcucmV0dXJuPWMucmV0dXJuO2ZvcihjPWMuc2libGluZzs1IT09Yy50YWcmJjYhPT1jLnRhZyYmMTghPT1jLnRhZzspe2lmKGMuZmxhZ3MmMiljb250aW51ZSBiO2lmKG51bGw9PT1cbmMuY2hpbGR8fDQ9PT1jLnRhZyljb250aW51ZSBiO2Vsc2UgYy5jaGlsZC5yZXR1cm49YyxjPWMuY2hpbGR9aWYoIShjLmZsYWdzJjIpKXtjPWMuc3RhdGVOb2RlO2JyZWFrIGF9fWQ/Z2ooYSxjLGIpOmhqKGEsYyxiKX1cbmZ1bmN0aW9uIGdqKGEsYixjKXt2YXIgZD1hLnRhZyxlPTU9PT1kfHw2PT09ZDtpZihlKWE9ZT9hLnN0YXRlTm9kZTphLnN0YXRlTm9kZS5pbnN0YW5jZSxiPzg9PT1jLm5vZGVUeXBlP2MucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoYSxiKTpjLmluc2VydEJlZm9yZShhLGIpOig4PT09Yy5ub2RlVHlwZT8oYj1jLnBhcmVudE5vZGUsYi5pbnNlcnRCZWZvcmUoYSxjKSk6KGI9YyxiLmFwcGVuZENoaWxkKGEpKSxjPWMuX3JlYWN0Um9vdENvbnRhaW5lcixudWxsIT09YyYmdm9pZCAwIT09Y3x8bnVsbCE9PWIub25jbGlja3x8KGIub25jbGljaz1qZikpO2Vsc2UgaWYoNCE9PWQmJihhPWEuY2hpbGQsbnVsbCE9PWEpKWZvcihnaihhLGIsYyksYT1hLnNpYmxpbmc7bnVsbCE9PWE7KWdqKGEsYixjKSxhPWEuc2libGluZ31cbmZ1bmN0aW9uIGhqKGEsYixjKXt2YXIgZD1hLnRhZyxlPTU9PT1kfHw2PT09ZDtpZihlKWE9ZT9hLnN0YXRlTm9kZTphLnN0YXRlTm9kZS5pbnN0YW5jZSxiP2MuaW5zZXJ0QmVmb3JlKGEsYik6Yy5hcHBlbmRDaGlsZChhKTtlbHNlIGlmKDQhPT1kJiYoYT1hLmNoaWxkLG51bGwhPT1hKSlmb3IoaGooYSxiLGMpLGE9YS5zaWJsaW5nO251bGwhPT1hOyloaihhLGIsYyksYT1hLnNpYmxpbmd9XG5mdW5jdGlvbiBjaihhLGIpe2Zvcih2YXIgYz1iLGQ9ITEsZSxmOzspe2lmKCFkKXtkPWMucmV0dXJuO2E6Zm9yKDs7KXtpZihudWxsPT09ZCl0aHJvdyBFcnJvcih5KDE2MCkpO2U9ZC5zdGF0ZU5vZGU7c3dpdGNoKGQudGFnKXtjYXNlIDU6Zj0hMTticmVhayBhO2Nhc2UgMzplPWUuY29udGFpbmVySW5mbztmPSEwO2JyZWFrIGE7Y2FzZSA0OmU9ZS5jb250YWluZXJJbmZvO2Y9ITA7YnJlYWsgYX1kPWQucmV0dXJufWQ9ITB9aWYoNT09PWMudGFnfHw2PT09Yy50YWcpe2E6Zm9yKHZhciBnPWEsaD1jLGs9aDs7KWlmKGJqKGcsayksbnVsbCE9PWsuY2hpbGQmJjQhPT1rLnRhZylrLmNoaWxkLnJldHVybj1rLGs9ay5jaGlsZDtlbHNle2lmKGs9PT1oKWJyZWFrIGE7Zm9yKDtudWxsPT09ay5zaWJsaW5nOyl7aWYobnVsbD09PWsucmV0dXJufHxrLnJldHVybj09PWgpYnJlYWsgYTtrPWsucmV0dXJufWsuc2libGluZy5yZXR1cm49ay5yZXR1cm47az1rLnNpYmxpbmd9Zj8oZz1lLGg9Yy5zdGF0ZU5vZGUsXG44PT09Zy5ub2RlVHlwZT9nLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoaCk6Zy5yZW1vdmVDaGlsZChoKSk6ZS5yZW1vdmVDaGlsZChjLnN0YXRlTm9kZSl9ZWxzZSBpZig0PT09Yy50YWcpe2lmKG51bGwhPT1jLmNoaWxkKXtlPWMuc3RhdGVOb2RlLmNvbnRhaW5lckluZm87Zj0hMDtjLmNoaWxkLnJldHVybj1jO2M9Yy5jaGlsZDtjb250aW51ZX19ZWxzZSBpZihiaihhLGMpLG51bGwhPT1jLmNoaWxkKXtjLmNoaWxkLnJldHVybj1jO2M9Yy5jaGlsZDtjb250aW51ZX1pZihjPT09YilicmVhaztmb3IoO251bGw9PT1jLnNpYmxpbmc7KXtpZihudWxsPT09Yy5yZXR1cm58fGMucmV0dXJuPT09YilyZXR1cm47Yz1jLnJldHVybjs0PT09Yy50YWcmJihkPSExKX1jLnNpYmxpbmcucmV0dXJuPWMucmV0dXJuO2M9Yy5zaWJsaW5nfX1cbmZ1bmN0aW9uIGlqKGEsYil7c3dpdGNoKGIudGFnKXtjYXNlIDA6Y2FzZSAxMTpjYXNlIDE0OmNhc2UgMTU6Y2FzZSAyMjp2YXIgYz1iLnVwZGF0ZVF1ZXVlO2M9bnVsbCE9PWM/Yy5sYXN0RWZmZWN0Om51bGw7aWYobnVsbCE9PWMpe3ZhciBkPWM9Yy5uZXh0O2RvIDM9PT0oZC50YWcmMykmJihhPWQuZGVzdHJveSxkLmRlc3Ryb3k9dm9pZCAwLHZvaWQgMCE9PWEmJmEoKSksZD1kLm5leHQ7d2hpbGUoZCE9PWMpfXJldHVybjtjYXNlIDE6cmV0dXJuO2Nhc2UgNTpjPWIuc3RhdGVOb2RlO2lmKG51bGwhPWMpe2Q9Yi5tZW1vaXplZFByb3BzO3ZhciBlPW51bGwhPT1hP2EubWVtb2l6ZWRQcm9wczpkO2E9Yi50eXBlO3ZhciBmPWIudXBkYXRlUXVldWU7Yi51cGRhdGVRdWV1ZT1udWxsO2lmKG51bGwhPT1mKXtjW3hmXT1kO1wiaW5wdXRcIj09PWEmJlwicmFkaW9cIj09PWQudHlwZSYmbnVsbCE9ZC5uYW1lJiYkYShjLGQpO3diKGEsZSk7Yj13YihhLGQpO2ZvcihlPTA7ZTxmLmxlbmd0aDtlKz1cbjIpe3ZhciBnPWZbZV0saD1mW2UrMV07XCJzdHlsZVwiPT09Zz90YihjLGgpOlwiZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxcIj09PWc/b2IoYyxoKTpcImNoaWxkcmVuXCI9PT1nP3BiKGMsaCk6cWEoYyxnLGgsYil9c3dpdGNoKGEpe2Nhc2UgXCJpbnB1dFwiOmFiKGMsZCk7YnJlYWs7Y2FzZSBcInRleHRhcmVhXCI6aWIoYyxkKTticmVhaztjYXNlIFwic2VsZWN0XCI6YT1jLl93cmFwcGVyU3RhdGUud2FzTXVsdGlwbGUsYy5fd3JhcHBlclN0YXRlLndhc011bHRpcGxlPSEhZC5tdWx0aXBsZSxmPWQudmFsdWUsbnVsbCE9Zj9mYihjLCEhZC5tdWx0aXBsZSxmLCExKTphIT09ISFkLm11bHRpcGxlJiYobnVsbCE9ZC5kZWZhdWx0VmFsdWU/ZmIoYywhIWQubXVsdGlwbGUsZC5kZWZhdWx0VmFsdWUsITApOmZiKGMsISFkLm11bHRpcGxlLGQubXVsdGlwbGU/W106XCJcIiwhMSkpfX19cmV0dXJuO2Nhc2UgNjppZihudWxsPT09Yi5zdGF0ZU5vZGUpdGhyb3cgRXJyb3IoeSgxNjIpKTtiLnN0YXRlTm9kZS5ub2RlVmFsdWU9XG5iLm1lbW9pemVkUHJvcHM7cmV0dXJuO2Nhc2UgMzpjPWIuc3RhdGVOb2RlO2MuaHlkcmF0ZSYmKGMuaHlkcmF0ZT0hMSxDYyhjLmNvbnRhaW5lckluZm8pKTtyZXR1cm47Y2FzZSAxMjpyZXR1cm47Y2FzZSAxMzpudWxsIT09Yi5tZW1vaXplZFN0YXRlJiYoamo9TygpLGFqKGIuY2hpbGQsITApKTtraihiKTtyZXR1cm47Y2FzZSAxOTpraihiKTtyZXR1cm47Y2FzZSAxNzpyZXR1cm47Y2FzZSAyMzpjYXNlIDI0OmFqKGIsbnVsbCE9PWIubWVtb2l6ZWRTdGF0ZSk7cmV0dXJufXRocm93IEVycm9yKHkoMTYzKSk7fWZ1bmN0aW9uIGtqKGEpe3ZhciBiPWEudXBkYXRlUXVldWU7aWYobnVsbCE9PWIpe2EudXBkYXRlUXVldWU9bnVsbDt2YXIgYz1hLnN0YXRlTm9kZTtudWxsPT09YyYmKGM9YS5zdGF0ZU5vZGU9bmV3IFVpKTtiLmZvckVhY2goZnVuY3Rpb24oYil7dmFyIGQ9bGouYmluZChudWxsLGEsYik7Yy5oYXMoYil8fChjLmFkZChiKSxiLnRoZW4oZCxkKSl9KX19XG5mdW5jdGlvbiBtaihhLGIpe3JldHVybiBudWxsIT09YSYmKGE9YS5tZW1vaXplZFN0YXRlLG51bGw9PT1hfHxudWxsIT09YS5kZWh5ZHJhdGVkKT8oYj1iLm1lbW9pemVkU3RhdGUsbnVsbCE9PWImJm51bGw9PT1iLmRlaHlkcmF0ZWQpOiExfXZhciBuaj1NYXRoLmNlaWwsb2o9cmEuUmVhY3RDdXJyZW50RGlzcGF0Y2hlcixwaj1yYS5SZWFjdEN1cnJlbnRPd25lcixYPTAsVT1udWxsLFk9bnVsbCxXPTAscWo9MCxyaj1CZigwKSxWPTAsc2o9bnVsbCx0aj0wLERnPTAsSGk9MCx1aj0wLHZqPW51bGwsamo9MCxKaT1JbmZpbml0eTtmdW5jdGlvbiB3aigpe0ppPU8oKSs1MDB9dmFyIFo9bnVsbCxRaT0hMSxSaT1udWxsLFRpPW51bGwseGo9ITEseWo9bnVsbCx6aj05MCxBaj1bXSxCaj1bXSxDaj1udWxsLERqPTAsRWo9bnVsbCxGaj0tMSxHaj0wLEhqPTAsSWo9bnVsbCxKaj0hMTtmdW5jdGlvbiBIZygpe3JldHVybiAwIT09KFgmNDgpP08oKTotMSE9PUZqP0ZqOkZqPU8oKX1cbmZ1bmN0aW9uIElnKGEpe2E9YS5tb2RlO2lmKDA9PT0oYSYyKSlyZXR1cm4gMTtpZigwPT09KGEmNCkpcmV0dXJuIDk5PT09ZWcoKT8xOjI7MD09PUdqJiYoR2o9dGopO2lmKDAhPT1rZy50cmFuc2l0aW9uKXswIT09SGomJihIaj1udWxsIT09dmo/dmoucGVuZGluZ0xhbmVzOjApO2E9R2o7dmFyIGI9NDE4NjExMiZ+SGo7YiY9LWI7MD09PWImJihhPTQxODYxMTImfmEsYj1hJi1hLDA9PT1iJiYoYj04MTkyKSk7cmV0dXJuIGJ9YT1lZygpOzAhPT0oWCY0KSYmOTg9PT1hP2E9WGMoMTIsR2opOihhPVNjKGEpLGE9WGMoYSxHaikpO3JldHVybiBhfVxuZnVuY3Rpb24gSmcoYSxiLGMpe2lmKDUwPERqKXRocm93IERqPTAsRWo9bnVsbCxFcnJvcih5KDE4NSkpO2E9S2ooYSxiKTtpZihudWxsPT09YSlyZXR1cm4gbnVsbDskYyhhLGIsYyk7YT09PVUmJihIaXw9Yiw0PT09ViYmSWkoYSxXKSk7dmFyIGQ9ZWcoKTsxPT09Yj8wIT09KFgmOCkmJjA9PT0oWCY0OCk/TGooYSk6KE1qKGEsYyksMD09PVgmJih3aigpLGlnKCkpKTooMD09PShYJjQpfHw5OCE9PWQmJjk5IT09ZHx8KG51bGw9PT1Daj9Daj1uZXcgU2V0KFthXSk6Q2ouYWRkKGEpKSxNaihhLGMpKTt2aj1hfWZ1bmN0aW9uIEtqKGEsYil7YS5sYW5lc3w9Yjt2YXIgYz1hLmFsdGVybmF0ZTtudWxsIT09YyYmKGMubGFuZXN8PWIpO2M9YTtmb3IoYT1hLnJldHVybjtudWxsIT09YTspYS5jaGlsZExhbmVzfD1iLGM9YS5hbHRlcm5hdGUsbnVsbCE9PWMmJihjLmNoaWxkTGFuZXN8PWIpLGM9YSxhPWEucmV0dXJuO3JldHVybiAzPT09Yy50YWc/Yy5zdGF0ZU5vZGU6bnVsbH1cbmZ1bmN0aW9uIE1qKGEsYil7Zm9yKHZhciBjPWEuY2FsbGJhY2tOb2RlLGQ9YS5zdXNwZW5kZWRMYW5lcyxlPWEucGluZ2VkTGFuZXMsZj1hLmV4cGlyYXRpb25UaW1lcyxnPWEucGVuZGluZ0xhbmVzOzA8Zzspe3ZhciBoPTMxLVZjKGcpLGs9MTw8aCxsPWZbaF07aWYoLTE9PT1sKXtpZigwPT09KGsmZCl8fDAhPT0oayZlKSl7bD1iO1JjKGspO3ZhciBuPUY7ZltoXT0xMDw9bj9sKzI1MDo2PD1uP2wrNUUzOi0xfX1lbHNlIGw8PWImJihhLmV4cGlyZWRMYW5lc3w9ayk7ZyY9fmt9ZD1VYyhhLGE9PT1VP1c6MCk7Yj1GO2lmKDA9PT1kKW51bGwhPT1jJiYoYyE9PVpmJiZQZihjKSxhLmNhbGxiYWNrTm9kZT1udWxsLGEuY2FsbGJhY2tQcmlvcml0eT0wKTtlbHNle2lmKG51bGwhPT1jKXtpZihhLmNhbGxiYWNrUHJpb3JpdHk9PT1iKXJldHVybjtjIT09WmYmJlBmKGMpfTE1PT09Yj8oYz1Mai5iaW5kKG51bGwsYSksbnVsbD09PWFnPyhhZz1bY10sYmc9T2YoVWYsamcpKTphZy5wdXNoKGMpLFxuYz1aZik6MTQ9PT1iP2M9aGcoOTksTGouYmluZChudWxsLGEpKTooYz1UYyhiKSxjPWhnKGMsTmouYmluZChudWxsLGEpKSk7YS5jYWxsYmFja1ByaW9yaXR5PWI7YS5jYWxsYmFja05vZGU9Y319XG5mdW5jdGlvbiBOaihhKXtGaj0tMTtIaj1Haj0wO2lmKDAhPT0oWCY0OCkpdGhyb3cgRXJyb3IoeSgzMjcpKTt2YXIgYj1hLmNhbGxiYWNrTm9kZTtpZihPaigpJiZhLmNhbGxiYWNrTm9kZSE9PWIpcmV0dXJuIG51bGw7dmFyIGM9VWMoYSxhPT09VT9XOjApO2lmKDA9PT1jKXJldHVybiBudWxsO3ZhciBkPWM7dmFyIGU9WDtYfD0xNjt2YXIgZj1QaigpO2lmKFUhPT1hfHxXIT09ZCl3aigpLFFqKGEsZCk7ZG8gdHJ5e1JqKCk7YnJlYWt9Y2F0Y2goaCl7U2ooYSxoKX13aGlsZSgxKTtxZygpO29qLmN1cnJlbnQ9ZjtYPWU7bnVsbCE9PVk/ZD0wOihVPW51bGwsVz0wLGQ9Vik7aWYoMCE9PSh0aiZIaSkpUWooYSwwKTtlbHNlIGlmKDAhPT1kKXsyPT09ZCYmKFh8PTY0LGEuaHlkcmF0ZSYmKGEuaHlkcmF0ZT0hMSxxZihhLmNvbnRhaW5lckluZm8pKSxjPVdjKGEpLDAhPT1jJiYoZD1UaihhLGMpKSk7aWYoMT09PWQpdGhyb3cgYj1zaixRaihhLDApLElpKGEsYyksTWooYSxPKCkpLGI7YS5maW5pc2hlZFdvcms9XG5hLmN1cnJlbnQuYWx0ZXJuYXRlO2EuZmluaXNoZWRMYW5lcz1jO3N3aXRjaChkKXtjYXNlIDA6Y2FzZSAxOnRocm93IEVycm9yKHkoMzQ1KSk7Y2FzZSAyOlVqKGEpO2JyZWFrO2Nhc2UgMzpJaShhLGMpO2lmKChjJjYyOTE0NTYwKT09PWMmJihkPWpqKzUwMC1PKCksMTA8ZCkpe2lmKDAhPT1VYyhhLDApKWJyZWFrO2U9YS5zdXNwZW5kZWRMYW5lcztpZigoZSZjKSE9PWMpe0hnKCk7YS5waW5nZWRMYW5lc3w9YS5zdXNwZW5kZWRMYW5lcyZlO2JyZWFrfWEudGltZW91dEhhbmRsZT1vZihVai5iaW5kKG51bGwsYSksZCk7YnJlYWt9VWooYSk7YnJlYWs7Y2FzZSA0OklpKGEsYyk7aWYoKGMmNDE4NjExMik9PT1jKWJyZWFrO2Q9YS5ldmVudFRpbWVzO2ZvcihlPS0xOzA8Yzspe3ZhciBnPTMxLVZjKGMpO2Y9MTw8ZztnPWRbZ107Zz5lJiYoZT1nKTtjJj1+Zn1jPWU7Yz1PKCktYztjPSgxMjA+Yz8xMjA6NDgwPmM/NDgwOjEwODA+Yz8xMDgwOjE5MjA+Yz8xOTIwOjNFMz5jPzNFMzo0MzIwPlxuYz80MzIwOjE5NjAqbmooYy8xOTYwKSktYztpZigxMDxjKXthLnRpbWVvdXRIYW5kbGU9b2YoVWouYmluZChudWxsLGEpLGMpO2JyZWFrfVVqKGEpO2JyZWFrO2Nhc2UgNTpVaihhKTticmVhaztkZWZhdWx0OnRocm93IEVycm9yKHkoMzI5KSk7fX1NaihhLE8oKSk7cmV0dXJuIGEuY2FsbGJhY2tOb2RlPT09Yj9Oai5iaW5kKG51bGwsYSk6bnVsbH1mdW5jdGlvbiBJaShhLGIpe2ImPX51ajtiJj1+SGk7YS5zdXNwZW5kZWRMYW5lc3w9YjthLnBpbmdlZExhbmVzJj1+Yjtmb3IoYT1hLmV4cGlyYXRpb25UaW1lczswPGI7KXt2YXIgYz0zMS1WYyhiKSxkPTE8PGM7YVtjXT0tMTtiJj1+ZH19XG5mdW5jdGlvbiBMaihhKXtpZigwIT09KFgmNDgpKXRocm93IEVycm9yKHkoMzI3KSk7T2ooKTtpZihhPT09VSYmMCE9PShhLmV4cGlyZWRMYW5lcyZXKSl7dmFyIGI9Vzt2YXIgYz1UaihhLGIpOzAhPT0odGomSGkpJiYoYj1VYyhhLGIpLGM9VGooYSxiKSl9ZWxzZSBiPVVjKGEsMCksYz1UaihhLGIpOzAhPT1hLnRhZyYmMj09PWMmJihYfD02NCxhLmh5ZHJhdGUmJihhLmh5ZHJhdGU9ITEscWYoYS5jb250YWluZXJJbmZvKSksYj1XYyhhKSwwIT09YiYmKGM9VGooYSxiKSkpO2lmKDE9PT1jKXRocm93IGM9c2osUWooYSwwKSxJaShhLGIpLE1qKGEsTygpKSxjO2EuZmluaXNoZWRXb3JrPWEuY3VycmVudC5hbHRlcm5hdGU7YS5maW5pc2hlZExhbmVzPWI7VWooYSk7TWooYSxPKCkpO3JldHVybiBudWxsfVxuZnVuY3Rpb24gVmooKXtpZihudWxsIT09Q2ope3ZhciBhPUNqO0NqPW51bGw7YS5mb3JFYWNoKGZ1bmN0aW9uKGEpe2EuZXhwaXJlZExhbmVzfD0yNCZhLnBlbmRpbmdMYW5lcztNaihhLE8oKSl9KX1pZygpfWZ1bmN0aW9uIFdqKGEsYil7dmFyIGM9WDtYfD0xO3RyeXtyZXR1cm4gYShiKX1maW5hbGx5e1g9YywwPT09WCYmKHdqKCksaWcoKSl9fWZ1bmN0aW9uIFhqKGEsYil7dmFyIGM9WDtYJj0tMjtYfD04O3RyeXtyZXR1cm4gYShiKX1maW5hbGx5e1g9YywwPT09WCYmKHdqKCksaWcoKSl9fWZ1bmN0aW9uIG5pKGEsYil7SShyaixxaik7cWp8PWI7dGp8PWJ9ZnVuY3Rpb24gS2koKXtxaj1yai5jdXJyZW50O0gocmopfVxuZnVuY3Rpb24gUWooYSxiKXthLmZpbmlzaGVkV29yaz1udWxsO2EuZmluaXNoZWRMYW5lcz0wO3ZhciBjPWEudGltZW91dEhhbmRsZTstMSE9PWMmJihhLnRpbWVvdXRIYW5kbGU9LTEscGYoYykpO2lmKG51bGwhPT1ZKWZvcihjPVkucmV0dXJuO251bGwhPT1jOyl7dmFyIGQ9Yztzd2l0Y2goZC50YWcpe2Nhc2UgMTpkPWQudHlwZS5jaGlsZENvbnRleHRUeXBlcztudWxsIT09ZCYmdm9pZCAwIT09ZCYmR2YoKTticmVhaztjYXNlIDM6ZmgoKTtIKE4pO0goTSk7dWgoKTticmVhaztjYXNlIDU6aGgoZCk7YnJlYWs7Y2FzZSA0OmZoKCk7YnJlYWs7Y2FzZSAxMzpIKFApO2JyZWFrO2Nhc2UgMTk6SChQKTticmVhaztjYXNlIDEwOnJnKGQpO2JyZWFrO2Nhc2UgMjM6Y2FzZSAyNDpLaSgpfWM9Yy5yZXR1cm59VT1hO1k9VGcoYS5jdXJyZW50LG51bGwpO1c9cWo9dGo9YjtWPTA7c2o9bnVsbDt1aj1IaT1EZz0wfVxuZnVuY3Rpb24gU2ooYSxiKXtkb3t2YXIgYz1ZO3RyeXtxZygpO3ZoLmN1cnJlbnQ9R2g7aWYoeWgpe2Zvcih2YXIgZD1SLm1lbW9pemVkU3RhdGU7bnVsbCE9PWQ7KXt2YXIgZT1kLnF1ZXVlO251bGwhPT1lJiYoZS5wZW5kaW5nPW51bGwpO2Q9ZC5uZXh0fXloPSExfXhoPTA7VD1TPVI9bnVsbDt6aD0hMTtwai5jdXJyZW50PW51bGw7aWYobnVsbD09PWN8fG51bGw9PT1jLnJldHVybil7Vj0xO3NqPWI7WT1udWxsO2JyZWFrfWE6e3ZhciBmPWEsZz1jLnJldHVybixoPWMsaz1iO2I9VztoLmZsYWdzfD0yMDQ4O2guZmlyc3RFZmZlY3Q9aC5sYXN0RWZmZWN0PW51bGw7aWYobnVsbCE9PWsmJlwib2JqZWN0XCI9PT10eXBlb2YgayYmXCJmdW5jdGlvblwiPT09dHlwZW9mIGsudGhlbil7dmFyIGw9aztpZigwPT09KGgubW9kZSYyKSl7dmFyIG49aC5hbHRlcm5hdGU7bj8oaC51cGRhdGVRdWV1ZT1uLnVwZGF0ZVF1ZXVlLGgubWVtb2l6ZWRTdGF0ZT1uLm1lbW9pemVkU3RhdGUsaC5sYW5lcz1uLmxhbmVzKTpcbihoLnVwZGF0ZVF1ZXVlPW51bGwsaC5tZW1vaXplZFN0YXRlPW51bGwpfXZhciBBPTAhPT0oUC5jdXJyZW50JjEpLHA9Zztkb3t2YXIgQztpZihDPTEzPT09cC50YWcpe3ZhciB4PXAubWVtb2l6ZWRTdGF0ZTtpZihudWxsIT09eClDPW51bGwhPT14LmRlaHlkcmF0ZWQ/ITA6ITE7ZWxzZXt2YXIgdz1wLm1lbW9pemVkUHJvcHM7Qz12b2lkIDA9PT13LmZhbGxiYWNrPyExOiEwIT09dy51bnN0YWJsZV9hdm9pZFRoaXNGYWxsYmFjaz8hMDpBPyExOiEwfX1pZihDKXt2YXIgej1wLnVwZGF0ZVF1ZXVlO2lmKG51bGw9PT16KXt2YXIgdT1uZXcgU2V0O3UuYWRkKGwpO3AudXBkYXRlUXVldWU9dX1lbHNlIHouYWRkKGwpO2lmKDA9PT0ocC5tb2RlJjIpKXtwLmZsYWdzfD02NDtoLmZsYWdzfD0xNjM4NDtoLmZsYWdzJj0tMjk4MTtpZigxPT09aC50YWcpaWYobnVsbD09PWguYWx0ZXJuYXRlKWgudGFnPTE3O2Vsc2V7dmFyIHQ9emcoLTEsMSk7dC50YWc9MjtBZyhoLHQpfWgubGFuZXN8PTE7YnJlYWsgYX1rPVxudm9pZCAwO2g9Yjt2YXIgcT1mLnBpbmdDYWNoZTtudWxsPT09cT8ocT1mLnBpbmdDYWNoZT1uZXcgT2ksaz1uZXcgU2V0LHEuc2V0KGwsaykpOihrPXEuZ2V0KGwpLHZvaWQgMD09PWsmJihrPW5ldyBTZXQscS5zZXQobCxrKSkpO2lmKCFrLmhhcyhoKSl7ay5hZGQoaCk7dmFyIHY9WWouYmluZChudWxsLGYsbCxoKTtsLnRoZW4odix2KX1wLmZsYWdzfD00MDk2O3AubGFuZXM9YjticmVhayBhfXA9cC5yZXR1cm59d2hpbGUobnVsbCE9PXApO2s9RXJyb3IoKFJhKGgudHlwZSl8fFwiQSBSZWFjdCBjb21wb25lbnRcIikrXCIgc3VzcGVuZGVkIHdoaWxlIHJlbmRlcmluZywgYnV0IG5vIGZhbGxiYWNrIFVJIHdhcyBzcGVjaWZpZWQuXFxuXFxuQWRkIGEgPFN1c3BlbnNlIGZhbGxiYWNrPS4uLj4gY29tcG9uZW50IGhpZ2hlciBpbiB0aGUgdHJlZSB0byBwcm92aWRlIGEgbG9hZGluZyBpbmRpY2F0b3Igb3IgcGxhY2Vob2xkZXIgdG8gZGlzcGxheS5cIil9NSE9PVYmJihWPTIpO2s9TWkoayxoKTtwPVxuZztkb3tzd2l0Y2gocC50YWcpe2Nhc2UgMzpmPWs7cC5mbGFnc3w9NDA5NjtiJj0tYjtwLmxhbmVzfD1iO3ZhciBKPVBpKHAsZixiKTtCZyhwLEopO2JyZWFrIGE7Y2FzZSAxOmY9azt2YXIgSz1wLnR5cGUsUT1wLnN0YXRlTm9kZTtpZigwPT09KHAuZmxhZ3MmNjQpJiYoXCJmdW5jdGlvblwiPT09dHlwZW9mIEsuZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yfHxudWxsIT09USYmXCJmdW5jdGlvblwiPT09dHlwZW9mIFEuY29tcG9uZW50RGlkQ2F0Y2gmJihudWxsPT09VGl8fCFUaS5oYXMoUSkpKSl7cC5mbGFnc3w9NDA5NjtiJj0tYjtwLmxhbmVzfD1iO3ZhciBMPVNpKHAsZixiKTtCZyhwLEwpO2JyZWFrIGF9fXA9cC5yZXR1cm59d2hpbGUobnVsbCE9PXApfVpqKGMpfWNhdGNoKHZhKXtiPXZhO1k9PT1jJiZudWxsIT09YyYmKFk9Yz1jLnJldHVybik7Y29udGludWV9YnJlYWt9d2hpbGUoMSl9XG5mdW5jdGlvbiBQaigpe3ZhciBhPW9qLmN1cnJlbnQ7b2ouY3VycmVudD1HaDtyZXR1cm4gbnVsbD09PWE/R2g6YX1mdW5jdGlvbiBUaihhLGIpe3ZhciBjPVg7WHw9MTY7dmFyIGQ9UGooKTtVPT09YSYmVz09PWJ8fFFqKGEsYik7ZG8gdHJ5e2FrKCk7YnJlYWt9Y2F0Y2goZSl7U2ooYSxlKX13aGlsZSgxKTtxZygpO1g9Yztvai5jdXJyZW50PWQ7aWYobnVsbCE9PVkpdGhyb3cgRXJyb3IoeSgyNjEpKTtVPW51bGw7Vz0wO3JldHVybiBWfWZ1bmN0aW9uIGFrKCl7Zm9yKDtudWxsIT09WTspYmsoWSl9ZnVuY3Rpb24gUmooKXtmb3IoO251bGwhPT1ZJiYhUWYoKTspYmsoWSl9ZnVuY3Rpb24gYmsoYSl7dmFyIGI9Y2soYS5hbHRlcm5hdGUsYSxxaik7YS5tZW1vaXplZFByb3BzPWEucGVuZGluZ1Byb3BzO251bGw9PT1iP1pqKGEpOlk9Yjtwai5jdXJyZW50PW51bGx9XG5mdW5jdGlvbiBaaihhKXt2YXIgYj1hO2Rve3ZhciBjPWIuYWx0ZXJuYXRlO2E9Yi5yZXR1cm47aWYoMD09PShiLmZsYWdzJjIwNDgpKXtjPUdpKGMsYixxaik7aWYobnVsbCE9PWMpe1k9YztyZXR1cm59Yz1iO2lmKDI0IT09Yy50YWcmJjIzIT09Yy50YWd8fG51bGw9PT1jLm1lbW9pemVkU3RhdGV8fDAhPT0ocWomMTA3Mzc0MTgyNCl8fDA9PT0oYy5tb2RlJjQpKXtmb3IodmFyIGQ9MCxlPWMuY2hpbGQ7bnVsbCE9PWU7KWR8PWUubGFuZXN8ZS5jaGlsZExhbmVzLGU9ZS5zaWJsaW5nO2MuY2hpbGRMYW5lcz1kfW51bGwhPT1hJiYwPT09KGEuZmxhZ3MmMjA0OCkmJihudWxsPT09YS5maXJzdEVmZmVjdCYmKGEuZmlyc3RFZmZlY3Q9Yi5maXJzdEVmZmVjdCksbnVsbCE9PWIubGFzdEVmZmVjdCYmKG51bGwhPT1hLmxhc3RFZmZlY3QmJihhLmxhc3RFZmZlY3QubmV4dEVmZmVjdD1iLmZpcnN0RWZmZWN0KSxhLmxhc3RFZmZlY3Q9Yi5sYXN0RWZmZWN0KSwxPGIuZmxhZ3MmJihudWxsIT09XG5hLmxhc3RFZmZlY3Q/YS5sYXN0RWZmZWN0Lm5leHRFZmZlY3Q9YjphLmZpcnN0RWZmZWN0PWIsYS5sYXN0RWZmZWN0PWIpKX1lbHNle2M9TGkoYik7aWYobnVsbCE9PWMpe2MuZmxhZ3MmPTIwNDc7WT1jO3JldHVybn1udWxsIT09YSYmKGEuZmlyc3RFZmZlY3Q9YS5sYXN0RWZmZWN0PW51bGwsYS5mbGFnc3w9MjA0OCl9Yj1iLnNpYmxpbmc7aWYobnVsbCE9PWIpe1k9YjtyZXR1cm59WT1iPWF9d2hpbGUobnVsbCE9PWIpOzA9PT1WJiYoVj01KX1mdW5jdGlvbiBVaihhKXt2YXIgYj1lZygpO2dnKDk5LGRrLmJpbmQobnVsbCxhLGIpKTtyZXR1cm4gbnVsbH1cbmZ1bmN0aW9uIGRrKGEsYil7ZG8gT2ooKTt3aGlsZShudWxsIT09eWopO2lmKDAhPT0oWCY0OCkpdGhyb3cgRXJyb3IoeSgzMjcpKTt2YXIgYz1hLmZpbmlzaGVkV29yaztpZihudWxsPT09YylyZXR1cm4gbnVsbDthLmZpbmlzaGVkV29yaz1udWxsO2EuZmluaXNoZWRMYW5lcz0wO2lmKGM9PT1hLmN1cnJlbnQpdGhyb3cgRXJyb3IoeSgxNzcpKTthLmNhbGxiYWNrTm9kZT1udWxsO3ZhciBkPWMubGFuZXN8Yy5jaGlsZExhbmVzLGU9ZCxmPWEucGVuZGluZ0xhbmVzJn5lO2EucGVuZGluZ0xhbmVzPWU7YS5zdXNwZW5kZWRMYW5lcz0wO2EucGluZ2VkTGFuZXM9MDthLmV4cGlyZWRMYW5lcyY9ZTthLm11dGFibGVSZWFkTGFuZXMmPWU7YS5lbnRhbmdsZWRMYW5lcyY9ZTtlPWEuZW50YW5nbGVtZW50cztmb3IodmFyIGc9YS5ldmVudFRpbWVzLGg9YS5leHBpcmF0aW9uVGltZXM7MDxmOyl7dmFyIGs9MzEtVmMoZiksbD0xPDxrO2Vba109MDtnW2tdPS0xO2hba109LTE7ZiY9fmx9bnVsbCE9PVxuQ2omJjA9PT0oZCYyNCkmJkNqLmhhcyhhKSYmQ2ouZGVsZXRlKGEpO2E9PT1VJiYoWT1VPW51bGwsVz0wKTsxPGMuZmxhZ3M/bnVsbCE9PWMubGFzdEVmZmVjdD8oYy5sYXN0RWZmZWN0Lm5leHRFZmZlY3Q9YyxkPWMuZmlyc3RFZmZlY3QpOmQ9YzpkPWMuZmlyc3RFZmZlY3Q7aWYobnVsbCE9PWQpe2U9WDtYfD0zMjtwai5jdXJyZW50PW51bGw7a2Y9ZmQ7Zz1OZSgpO2lmKE9lKGcpKXtpZihcInNlbGVjdGlvblN0YXJ0XCJpbiBnKWg9e3N0YXJ0Omcuc2VsZWN0aW9uU3RhcnQsZW5kOmcuc2VsZWN0aW9uRW5kfTtlbHNlIGE6aWYoaD0oaD1nLm93bmVyRG9jdW1lbnQpJiZoLmRlZmF1bHRWaWV3fHx3aW5kb3csKGw9aC5nZXRTZWxlY3Rpb24mJmguZ2V0U2VsZWN0aW9uKCkpJiYwIT09bC5yYW5nZUNvdW50KXtoPWwuYW5jaG9yTm9kZTtmPWwuYW5jaG9yT2Zmc2V0O2s9bC5mb2N1c05vZGU7bD1sLmZvY3VzT2Zmc2V0O3RyeXtoLm5vZGVUeXBlLGsubm9kZVR5cGV9Y2F0Y2godmEpe2g9bnVsbDtcbmJyZWFrIGF9dmFyIG49MCxBPS0xLHA9LTEsQz0wLHg9MCx3PWcsej1udWxsO2I6Zm9yKDs7KXtmb3IodmFyIHU7Oyl7dyE9PWh8fDAhPT1mJiYzIT09dy5ub2RlVHlwZXx8KEE9bitmKTt3IT09a3x8MCE9PWwmJjMhPT13Lm5vZGVUeXBlfHwocD1uK2wpOzM9PT13Lm5vZGVUeXBlJiYobis9dy5ub2RlVmFsdWUubGVuZ3RoKTtpZihudWxsPT09KHU9dy5maXJzdENoaWxkKSlicmVhazt6PXc7dz11fWZvcig7Oyl7aWYodz09PWcpYnJlYWsgYjt6PT09aCYmKytDPT09ZiYmKEE9bik7ej09PWsmJisreD09PWwmJihwPW4pO2lmKG51bGwhPT0odT13Lm5leHRTaWJsaW5nKSlicmVhazt3PXo7ej13LnBhcmVudE5vZGV9dz11fWg9LTE9PT1BfHwtMT09PXA/bnVsbDp7c3RhcnQ6QSxlbmQ6cH19ZWxzZSBoPW51bGw7aD1ofHx7c3RhcnQ6MCxlbmQ6MH19ZWxzZSBoPW51bGw7bGY9e2ZvY3VzZWRFbGVtOmcsc2VsZWN0aW9uUmFuZ2U6aH07ZmQ9ITE7SWo9bnVsbDtKaj0hMTtaPWQ7ZG8gdHJ5e2VrKCl9Y2F0Y2godmEpe2lmKG51bGw9PT1cblopdGhyb3cgRXJyb3IoeSgzMzApKTtXaShaLHZhKTtaPVoubmV4dEVmZmVjdH13aGlsZShudWxsIT09Wik7SWo9bnVsbDtaPWQ7ZG8gdHJ5e2ZvcihnPWE7bnVsbCE9PVo7KXt2YXIgdD1aLmZsYWdzO3QmMTYmJnBiKFouc3RhdGVOb2RlLFwiXCIpO2lmKHQmMTI4KXt2YXIgcT1aLmFsdGVybmF0ZTtpZihudWxsIT09cSl7dmFyIHY9cS5yZWY7bnVsbCE9PXYmJihcImZ1bmN0aW9uXCI9PT10eXBlb2Ygdj92KG51bGwpOnYuY3VycmVudD1udWxsKX19c3dpdGNoKHQmMTAzOCl7Y2FzZSAyOmZqKFopO1ouZmxhZ3MmPS0zO2JyZWFrO2Nhc2UgNjpmaihaKTtaLmZsYWdzJj0tMztpaihaLmFsdGVybmF0ZSxaKTticmVhaztjYXNlIDEwMjQ6Wi5mbGFncyY9LTEwMjU7YnJlYWs7Y2FzZSAxMDI4OlouZmxhZ3MmPS0xMDI1O2lqKFouYWx0ZXJuYXRlLFopO2JyZWFrO2Nhc2UgNDppaihaLmFsdGVybmF0ZSxaKTticmVhaztjYXNlIDg6aD1aO2NqKGcsaCk7dmFyIEo9aC5hbHRlcm5hdGU7ZGooaCk7bnVsbCE9PVxuSiYmZGooSil9Wj1aLm5leHRFZmZlY3R9fWNhdGNoKHZhKXtpZihudWxsPT09Wil0aHJvdyBFcnJvcih5KDMzMCkpO1dpKFosdmEpO1o9Wi5uZXh0RWZmZWN0fXdoaWxlKG51bGwhPT1aKTt2PWxmO3E9TmUoKTt0PXYuZm9jdXNlZEVsZW07Zz12LnNlbGVjdGlvblJhbmdlO2lmKHEhPT10JiZ0JiZ0Lm93bmVyRG9jdW1lbnQmJk1lKHQub3duZXJEb2N1bWVudC5kb2N1bWVudEVsZW1lbnQsdCkpe251bGwhPT1nJiZPZSh0KSYmKHE9Zy5zdGFydCx2PWcuZW5kLHZvaWQgMD09PXYmJih2PXEpLFwic2VsZWN0aW9uU3RhcnRcImluIHQ/KHQuc2VsZWN0aW9uU3RhcnQ9cSx0LnNlbGVjdGlvbkVuZD1NYXRoLm1pbih2LHQudmFsdWUubGVuZ3RoKSk6KHY9KHE9dC5vd25lckRvY3VtZW50fHxkb2N1bWVudCkmJnEuZGVmYXVsdFZpZXd8fHdpbmRvdyx2LmdldFNlbGVjdGlvbiYmKHY9di5nZXRTZWxlY3Rpb24oKSxoPXQudGV4dENvbnRlbnQubGVuZ3RoLEo9TWF0aC5taW4oZy5zdGFydCxoKSxnPXZvaWQgMD09PVxuZy5lbmQ/SjpNYXRoLm1pbihnLmVuZCxoKSwhdi5leHRlbmQmJko+ZyYmKGg9ZyxnPUosSj1oKSxoPUxlKHQsSiksZj1MZSh0LGcpLGgmJmYmJigxIT09di5yYW5nZUNvdW50fHx2LmFuY2hvck5vZGUhPT1oLm5vZGV8fHYuYW5jaG9yT2Zmc2V0IT09aC5vZmZzZXR8fHYuZm9jdXNOb2RlIT09Zi5ub2RlfHx2LmZvY3VzT2Zmc2V0IT09Zi5vZmZzZXQpJiYocT1xLmNyZWF0ZVJhbmdlKCkscS5zZXRTdGFydChoLm5vZGUsaC5vZmZzZXQpLHYucmVtb3ZlQWxsUmFuZ2VzKCksSj5nPyh2LmFkZFJhbmdlKHEpLHYuZXh0ZW5kKGYubm9kZSxmLm9mZnNldCkpOihxLnNldEVuZChmLm5vZGUsZi5vZmZzZXQpLHYuYWRkUmFuZ2UocSkpKSkpKTtxPVtdO2Zvcih2PXQ7dj12LnBhcmVudE5vZGU7KTE9PT12Lm5vZGVUeXBlJiZxLnB1c2goe2VsZW1lbnQ6dixsZWZ0OnYuc2Nyb2xsTGVmdCx0b3A6di5zY3JvbGxUb3B9KTtcImZ1bmN0aW9uXCI9PT10eXBlb2YgdC5mb2N1cyYmdC5mb2N1cygpO2Zvcih0PVxuMDt0PHEubGVuZ3RoO3QrKyl2PXFbdF0sdi5lbGVtZW50LnNjcm9sbExlZnQ9di5sZWZ0LHYuZWxlbWVudC5zY3JvbGxUb3A9di50b3B9ZmQ9ISFrZjtsZj1rZj1udWxsO2EuY3VycmVudD1jO1o9ZDtkbyB0cnl7Zm9yKHQ9YTtudWxsIT09Wjspe3ZhciBLPVouZmxhZ3M7SyYzNiYmWWkodCxaLmFsdGVybmF0ZSxaKTtpZihLJjEyOCl7cT12b2lkIDA7dmFyIFE9Wi5yZWY7aWYobnVsbCE9PVEpe3ZhciBMPVouc3RhdGVOb2RlO3N3aXRjaChaLnRhZyl7Y2FzZSA1OnE9TDticmVhaztkZWZhdWx0OnE9TH1cImZ1bmN0aW9uXCI9PT10eXBlb2YgUT9RKHEpOlEuY3VycmVudD1xfX1aPVoubmV4dEVmZmVjdH19Y2F0Y2godmEpe2lmKG51bGw9PT1aKXRocm93IEVycm9yKHkoMzMwKSk7V2koWix2YSk7Wj1aLm5leHRFZmZlY3R9d2hpbGUobnVsbCE9PVopO1o9bnVsbDskZigpO1g9ZX1lbHNlIGEuY3VycmVudD1jO2lmKHhqKXhqPSExLHlqPWEsemo9YjtlbHNlIGZvcihaPWQ7bnVsbCE9PVo7KWI9XG5aLm5leHRFZmZlY3QsWi5uZXh0RWZmZWN0PW51bGwsWi5mbGFncyY4JiYoSz1aLEsuc2libGluZz1udWxsLEsuc3RhdGVOb2RlPW51bGwpLFo9YjtkPWEucGVuZGluZ0xhbmVzOzA9PT1kJiYoVGk9bnVsbCk7MT09PWQ/YT09PUVqP0RqKys6KERqPTAsRWo9YSk6RGo9MDtjPWMuc3RhdGVOb2RlO2lmKE1mJiZcImZ1bmN0aW9uXCI9PT10eXBlb2YgTWYub25Db21taXRGaWJlclJvb3QpdHJ5e01mLm9uQ29tbWl0RmliZXJSb290KExmLGMsdm9pZCAwLDY0PT09KGMuY3VycmVudC5mbGFncyY2NCkpfWNhdGNoKHZhKXt9TWooYSxPKCkpO2lmKFFpKXRocm93IFFpPSExLGE9UmksUmk9bnVsbCxhO2lmKDAhPT0oWCY4KSlyZXR1cm4gbnVsbDtpZygpO3JldHVybiBudWxsfVxuZnVuY3Rpb24gZWsoKXtmb3IoO251bGwhPT1aOyl7dmFyIGE9Wi5hbHRlcm5hdGU7Smp8fG51bGw9PT1Janx8KDAhPT0oWi5mbGFncyY4KT9kYyhaLElqKSYmKEpqPSEwKToxMz09PVoudGFnJiZtaihhLFopJiZkYyhaLElqKSYmKEpqPSEwKSk7dmFyIGI9Wi5mbGFnczswIT09KGImMjU2KSYmWGkoYSxaKTswPT09KGImNTEyKXx8eGp8fCh4aj0hMCxoZyg5NyxmdW5jdGlvbigpe09qKCk7cmV0dXJuIG51bGx9KSk7Wj1aLm5leHRFZmZlY3R9fWZ1bmN0aW9uIE9qKCl7aWYoOTAhPT16ail7dmFyIGE9OTc8emo/OTc6emo7emo9OTA7cmV0dXJuIGdnKGEsZmspfXJldHVybiExfWZ1bmN0aW9uICRpKGEsYil7QWoucHVzaChiLGEpO3hqfHwoeGo9ITAsaGcoOTcsZnVuY3Rpb24oKXtPaigpO3JldHVybiBudWxsfSkpfWZ1bmN0aW9uIFppKGEsYil7QmoucHVzaChiLGEpO3hqfHwoeGo9ITAsaGcoOTcsZnVuY3Rpb24oKXtPaigpO3JldHVybiBudWxsfSkpfVxuZnVuY3Rpb24gZmsoKXtpZihudWxsPT09eWopcmV0dXJuITE7dmFyIGE9eWo7eWo9bnVsbDtpZigwIT09KFgmNDgpKXRocm93IEVycm9yKHkoMzMxKSk7dmFyIGI9WDtYfD0zMjt2YXIgYz1CajtCaj1bXTtmb3IodmFyIGQ9MDtkPGMubGVuZ3RoO2QrPTIpe3ZhciBlPWNbZF0sZj1jW2QrMV0sZz1lLmRlc3Ryb3k7ZS5kZXN0cm95PXZvaWQgMDtpZihcImZ1bmN0aW9uXCI9PT10eXBlb2YgZyl0cnl7ZygpfWNhdGNoKGspe2lmKG51bGw9PT1mKXRocm93IEVycm9yKHkoMzMwKSk7V2koZixrKX19Yz1BajtBaj1bXTtmb3IoZD0wO2Q8Yy5sZW5ndGg7ZCs9Mil7ZT1jW2RdO2Y9Y1tkKzFdO3RyeXt2YXIgaD1lLmNyZWF0ZTtlLmRlc3Ryb3k9aCgpfWNhdGNoKGspe2lmKG51bGw9PT1mKXRocm93IEVycm9yKHkoMzMwKSk7V2koZixrKX19Zm9yKGg9YS5jdXJyZW50LmZpcnN0RWZmZWN0O251bGwhPT1oOylhPWgubmV4dEVmZmVjdCxoLm5leHRFZmZlY3Q9bnVsbCxoLmZsYWdzJjgmJihoLnNpYmxpbmc9XG5udWxsLGguc3RhdGVOb2RlPW51bGwpLGg9YTtYPWI7aWcoKTtyZXR1cm4hMH1mdW5jdGlvbiBnayhhLGIsYyl7Yj1NaShjLGIpO2I9UGkoYSxiLDEpO0FnKGEsYik7Yj1IZygpO2E9S2ooYSwxKTtudWxsIT09YSYmKCRjKGEsMSxiKSxNaihhLGIpKX1cbmZ1bmN0aW9uIFdpKGEsYil7aWYoMz09PWEudGFnKWdrKGEsYSxiKTtlbHNlIGZvcih2YXIgYz1hLnJldHVybjtudWxsIT09Yzspe2lmKDM9PT1jLnRhZyl7Z2soYyxhLGIpO2JyZWFrfWVsc2UgaWYoMT09PWMudGFnKXt2YXIgZD1jLnN0YXRlTm9kZTtpZihcImZ1bmN0aW9uXCI9PT10eXBlb2YgYy50eXBlLmdldERlcml2ZWRTdGF0ZUZyb21FcnJvcnx8XCJmdW5jdGlvblwiPT09dHlwZW9mIGQuY29tcG9uZW50RGlkQ2F0Y2gmJihudWxsPT09VGl8fCFUaS5oYXMoZCkpKXthPU1pKGIsYSk7dmFyIGU9U2koYyxhLDEpO0FnKGMsZSk7ZT1IZygpO2M9S2ooYywxKTtpZihudWxsIT09YykkYyhjLDEsZSksTWooYyxlKTtlbHNlIGlmKFwiZnVuY3Rpb25cIj09PXR5cGVvZiBkLmNvbXBvbmVudERpZENhdGNoJiYobnVsbD09PVRpfHwhVGkuaGFzKGQpKSl0cnl7ZC5jb21wb25lbnREaWRDYXRjaChiLGEpfWNhdGNoKGYpe31icmVha319Yz1jLnJldHVybn19XG5mdW5jdGlvbiBZaihhLGIsYyl7dmFyIGQ9YS5waW5nQ2FjaGU7bnVsbCE9PWQmJmQuZGVsZXRlKGIpO2I9SGcoKTthLnBpbmdlZExhbmVzfD1hLnN1c3BlbmRlZExhbmVzJmM7VT09PWEmJihXJmMpPT09YyYmKDQ9PT1WfHwzPT09ViYmKFcmNjI5MTQ1NjApPT09VyYmNTAwPk8oKS1qaj9RaihhLDApOnVqfD1jKTtNaihhLGIpfWZ1bmN0aW9uIGxqKGEsYil7dmFyIGM9YS5zdGF0ZU5vZGU7bnVsbCE9PWMmJmMuZGVsZXRlKGIpO2I9MDswPT09YiYmKGI9YS5tb2RlLDA9PT0oYiYyKT9iPTE6MD09PShiJjQpP2I9OTk9PT1lZygpPzE6MjooMD09PUdqJiYoR2o9dGopLGI9WWMoNjI5MTQ1NjAmfkdqKSwwPT09YiYmKGI9NDE5NDMwNCkpKTtjPUhnKCk7YT1LaihhLGIpO251bGwhPT1hJiYoJGMoYSxiLGMpLE1qKGEsYykpfXZhciBjaztcbmNrPWZ1bmN0aW9uKGEsYixjKXt2YXIgZD1iLmxhbmVzO2lmKG51bGwhPT1hKWlmKGEubWVtb2l6ZWRQcm9wcyE9PWIucGVuZGluZ1Byb3BzfHxOLmN1cnJlbnQpdWc9ITA7ZWxzZSBpZigwIT09KGMmZCkpdWc9MCE9PShhLmZsYWdzJjE2Mzg0KT8hMDohMTtlbHNle3VnPSExO3N3aXRjaChiLnRhZyl7Y2FzZSAzOnJpKGIpO3NoKCk7YnJlYWs7Y2FzZSA1OmdoKGIpO2JyZWFrO2Nhc2UgMTpGZihiLnR5cGUpJiZKZihiKTticmVhaztjYXNlIDQ6ZWgoYixiLnN0YXRlTm9kZS5jb250YWluZXJJbmZvKTticmVhaztjYXNlIDEwOmQ9Yi5tZW1vaXplZFByb3BzLnZhbHVlO3ZhciBlPWIudHlwZS5fY29udGV4dDtJKG1nLGUuX2N1cnJlbnRWYWx1ZSk7ZS5fY3VycmVudFZhbHVlPWQ7YnJlYWs7Y2FzZSAxMzppZihudWxsIT09Yi5tZW1vaXplZFN0YXRlKXtpZigwIT09KGMmYi5jaGlsZC5jaGlsZExhbmVzKSlyZXR1cm4gdGkoYSxiLGMpO0koUCxQLmN1cnJlbnQmMSk7Yj1oaShhLGIsYyk7cmV0dXJuIG51bGwhPT1cbmI/Yi5zaWJsaW5nOm51bGx9SShQLFAuY3VycmVudCYxKTticmVhaztjYXNlIDE5OmQ9MCE9PShjJmIuY2hpbGRMYW5lcyk7aWYoMCE9PShhLmZsYWdzJjY0KSl7aWYoZClyZXR1cm4gQWkoYSxiLGMpO2IuZmxhZ3N8PTY0fWU9Yi5tZW1vaXplZFN0YXRlO251bGwhPT1lJiYoZS5yZW5kZXJpbmc9bnVsbCxlLnRhaWw9bnVsbCxlLmxhc3RFZmZlY3Q9bnVsbCk7SShQLFAuY3VycmVudCk7aWYoZClicmVhaztlbHNlIHJldHVybiBudWxsO2Nhc2UgMjM6Y2FzZSAyNDpyZXR1cm4gYi5sYW5lcz0wLG1pKGEsYixjKX1yZXR1cm4gaGkoYSxiLGMpfWVsc2UgdWc9ITE7Yi5sYW5lcz0wO3N3aXRjaChiLnRhZyl7Y2FzZSAyOmQ9Yi50eXBlO251bGwhPT1hJiYoYS5hbHRlcm5hdGU9bnVsbCxiLmFsdGVybmF0ZT1udWxsLGIuZmxhZ3N8PTIpO2E9Yi5wZW5kaW5nUHJvcHM7ZT1FZihiLE0uY3VycmVudCk7dGcoYixjKTtlPUNoKG51bGwsYixkLGEsZSxjKTtiLmZsYWdzfD0xO2lmKFwib2JqZWN0XCI9PT1cbnR5cGVvZiBlJiZudWxsIT09ZSYmXCJmdW5jdGlvblwiPT09dHlwZW9mIGUucmVuZGVyJiZ2b2lkIDA9PT1lLiQkdHlwZW9mKXtiLnRhZz0xO2IubWVtb2l6ZWRTdGF0ZT1udWxsO2IudXBkYXRlUXVldWU9bnVsbDtpZihGZihkKSl7dmFyIGY9ITA7SmYoYil9ZWxzZSBmPSExO2IubWVtb2l6ZWRTdGF0ZT1udWxsIT09ZS5zdGF0ZSYmdm9pZCAwIT09ZS5zdGF0ZT9lLnN0YXRlOm51bGw7eGcoYik7dmFyIGc9ZC5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHM7XCJmdW5jdGlvblwiPT09dHlwZW9mIGcmJkdnKGIsZCxnLGEpO2UudXBkYXRlcj1LZztiLnN0YXRlTm9kZT1lO2UuX3JlYWN0SW50ZXJuYWxzPWI7T2coYixkLGEsYyk7Yj1xaShudWxsLGIsZCwhMCxmLGMpfWVsc2UgYi50YWc9MCxmaShudWxsLGIsZSxjKSxiPWIuY2hpbGQ7cmV0dXJuIGI7Y2FzZSAxNjplPWIuZWxlbWVudFR5cGU7YTp7bnVsbCE9PWEmJihhLmFsdGVybmF0ZT1udWxsLGIuYWx0ZXJuYXRlPW51bGwsYi5mbGFnc3w9Mik7XG5hPWIucGVuZGluZ1Byb3BzO2Y9ZS5faW5pdDtlPWYoZS5fcGF5bG9hZCk7Yi50eXBlPWU7Zj1iLnRhZz1oayhlKTthPWxnKGUsYSk7c3dpdGNoKGYpe2Nhc2UgMDpiPWxpKG51bGwsYixlLGEsYyk7YnJlYWsgYTtjYXNlIDE6Yj1waShudWxsLGIsZSxhLGMpO2JyZWFrIGE7Y2FzZSAxMTpiPWdpKG51bGwsYixlLGEsYyk7YnJlYWsgYTtjYXNlIDE0OmI9aWkobnVsbCxiLGUsbGcoZS50eXBlLGEpLGQsYyk7YnJlYWsgYX10aHJvdyBFcnJvcih5KDMwNixlLFwiXCIpKTt9cmV0dXJuIGI7Y2FzZSAwOnJldHVybiBkPWIudHlwZSxlPWIucGVuZGluZ1Byb3BzLGU9Yi5lbGVtZW50VHlwZT09PWQ/ZTpsZyhkLGUpLGxpKGEsYixkLGUsYyk7Y2FzZSAxOnJldHVybiBkPWIudHlwZSxlPWIucGVuZGluZ1Byb3BzLGU9Yi5lbGVtZW50VHlwZT09PWQ/ZTpsZyhkLGUpLHBpKGEsYixkLGUsYyk7Y2FzZSAzOnJpKGIpO2Q9Yi51cGRhdGVRdWV1ZTtpZihudWxsPT09YXx8bnVsbD09PWQpdGhyb3cgRXJyb3IoeSgyODIpKTtcbmQ9Yi5wZW5kaW5nUHJvcHM7ZT1iLm1lbW9pemVkU3RhdGU7ZT1udWxsIT09ZT9lLmVsZW1lbnQ6bnVsbDt5ZyhhLGIpO0NnKGIsZCxudWxsLGMpO2Q9Yi5tZW1vaXplZFN0YXRlLmVsZW1lbnQ7aWYoZD09PWUpc2goKSxiPWhpKGEsYixjKTtlbHNle2U9Yi5zdGF0ZU5vZGU7aWYoZj1lLmh5ZHJhdGUpa2g9cmYoYi5zdGF0ZU5vZGUuY29udGFpbmVySW5mby5maXJzdENoaWxkKSxqaD1iLGY9bGg9ITA7aWYoZil7YT1lLm11dGFibGVTb3VyY2VFYWdlckh5ZHJhdGlvbkRhdGE7aWYobnVsbCE9YSlmb3IoZT0wO2U8YS5sZW5ndGg7ZSs9MilmPWFbZV0sZi5fd29ya0luUHJvZ3Jlc3NWZXJzaW9uUHJpbWFyeT1hW2UrMV0sdGgucHVzaChmKTtjPVpnKGIsbnVsbCxkLGMpO2ZvcihiLmNoaWxkPWM7YzspYy5mbGFncz1jLmZsYWdzJi0zfDEwMjQsYz1jLnNpYmxpbmd9ZWxzZSBmaShhLGIsZCxjKSxzaCgpO2I9Yi5jaGlsZH1yZXR1cm4gYjtjYXNlIDU6cmV0dXJuIGdoKGIpLG51bGw9PT1hJiZcbnBoKGIpLGQ9Yi50eXBlLGU9Yi5wZW5kaW5nUHJvcHMsZj1udWxsIT09YT9hLm1lbW9pemVkUHJvcHM6bnVsbCxnPWUuY2hpbGRyZW4sbmYoZCxlKT9nPW51bGw6bnVsbCE9PWYmJm5mKGQsZikmJihiLmZsYWdzfD0xNiksb2koYSxiKSxmaShhLGIsZyxjKSxiLmNoaWxkO2Nhc2UgNjpyZXR1cm4gbnVsbD09PWEmJnBoKGIpLG51bGw7Y2FzZSAxMzpyZXR1cm4gdGkoYSxiLGMpO2Nhc2UgNDpyZXR1cm4gZWgoYixiLnN0YXRlTm9kZS5jb250YWluZXJJbmZvKSxkPWIucGVuZGluZ1Byb3BzLG51bGw9PT1hP2IuY2hpbGQ9WWcoYixudWxsLGQsYyk6ZmkoYSxiLGQsYyksYi5jaGlsZDtjYXNlIDExOnJldHVybiBkPWIudHlwZSxlPWIucGVuZGluZ1Byb3BzLGU9Yi5lbGVtZW50VHlwZT09PWQ/ZTpsZyhkLGUpLGdpKGEsYixkLGUsYyk7Y2FzZSA3OnJldHVybiBmaShhLGIsYi5wZW5kaW5nUHJvcHMsYyksYi5jaGlsZDtjYXNlIDg6cmV0dXJuIGZpKGEsYixiLnBlbmRpbmdQcm9wcy5jaGlsZHJlbixcbmMpLGIuY2hpbGQ7Y2FzZSAxMjpyZXR1cm4gZmkoYSxiLGIucGVuZGluZ1Byb3BzLmNoaWxkcmVuLGMpLGIuY2hpbGQ7Y2FzZSAxMDphOntkPWIudHlwZS5fY29udGV4dDtlPWIucGVuZGluZ1Byb3BzO2c9Yi5tZW1vaXplZFByb3BzO2Y9ZS52YWx1ZTt2YXIgaD1iLnR5cGUuX2NvbnRleHQ7SShtZyxoLl9jdXJyZW50VmFsdWUpO2guX2N1cnJlbnRWYWx1ZT1mO2lmKG51bGwhPT1nKWlmKGg9Zy52YWx1ZSxmPUhlKGgsZik/MDooXCJmdW5jdGlvblwiPT09dHlwZW9mIGQuX2NhbGN1bGF0ZUNoYW5nZWRCaXRzP2QuX2NhbGN1bGF0ZUNoYW5nZWRCaXRzKGgsZik6MTA3Mzc0MTgyMyl8MCwwPT09Zil7aWYoZy5jaGlsZHJlbj09PWUuY2hpbGRyZW4mJiFOLmN1cnJlbnQpe2I9aGkoYSxiLGMpO2JyZWFrIGF9fWVsc2UgZm9yKGg9Yi5jaGlsZCxudWxsIT09aCYmKGgucmV0dXJuPWIpO251bGwhPT1oOyl7dmFyIGs9aC5kZXBlbmRlbmNpZXM7aWYobnVsbCE9PWspe2c9aC5jaGlsZDtmb3IodmFyIGw9XG5rLmZpcnN0Q29udGV4dDtudWxsIT09bDspe2lmKGwuY29udGV4dD09PWQmJjAhPT0obC5vYnNlcnZlZEJpdHMmZikpezE9PT1oLnRhZyYmKGw9emcoLTEsYyYtYyksbC50YWc9MixBZyhoLGwpKTtoLmxhbmVzfD1jO2w9aC5hbHRlcm5hdGU7bnVsbCE9PWwmJihsLmxhbmVzfD1jKTtzZyhoLnJldHVybixjKTtrLmxhbmVzfD1jO2JyZWFrfWw9bC5uZXh0fX1lbHNlIGc9MTA9PT1oLnRhZz9oLnR5cGU9PT1iLnR5cGU/bnVsbDpoLmNoaWxkOmguY2hpbGQ7aWYobnVsbCE9PWcpZy5yZXR1cm49aDtlbHNlIGZvcihnPWg7bnVsbCE9PWc7KXtpZihnPT09Yil7Zz1udWxsO2JyZWFrfWg9Zy5zaWJsaW5nO2lmKG51bGwhPT1oKXtoLnJldHVybj1nLnJldHVybjtnPWg7YnJlYWt9Zz1nLnJldHVybn1oPWd9ZmkoYSxiLGUuY2hpbGRyZW4sYyk7Yj1iLmNoaWxkfXJldHVybiBiO2Nhc2UgOTpyZXR1cm4gZT1iLnR5cGUsZj1iLnBlbmRpbmdQcm9wcyxkPWYuY2hpbGRyZW4sdGcoYixjKSxlPXZnKGUsXG5mLnVuc3RhYmxlX29ic2VydmVkQml0cyksZD1kKGUpLGIuZmxhZ3N8PTEsZmkoYSxiLGQsYyksYi5jaGlsZDtjYXNlIDE0OnJldHVybiBlPWIudHlwZSxmPWxnKGUsYi5wZW5kaW5nUHJvcHMpLGY9bGcoZS50eXBlLGYpLGlpKGEsYixlLGYsZCxjKTtjYXNlIDE1OnJldHVybiBraShhLGIsYi50eXBlLGIucGVuZGluZ1Byb3BzLGQsYyk7Y2FzZSAxNzpyZXR1cm4gZD1iLnR5cGUsZT1iLnBlbmRpbmdQcm9wcyxlPWIuZWxlbWVudFR5cGU9PT1kP2U6bGcoZCxlKSxudWxsIT09YSYmKGEuYWx0ZXJuYXRlPW51bGwsYi5hbHRlcm5hdGU9bnVsbCxiLmZsYWdzfD0yKSxiLnRhZz0xLEZmKGQpPyhhPSEwLEpmKGIpKTphPSExLHRnKGIsYyksTWcoYixkLGUpLE9nKGIsZCxlLGMpLHFpKG51bGwsYixkLCEwLGEsYyk7Y2FzZSAxOTpyZXR1cm4gQWkoYSxiLGMpO2Nhc2UgMjM6cmV0dXJuIG1pKGEsYixjKTtjYXNlIDI0OnJldHVybiBtaShhLGIsYyl9dGhyb3cgRXJyb3IoeSgxNTYsYi50YWcpKTtcbn07ZnVuY3Rpb24gaWsoYSxiLGMsZCl7dGhpcy50YWc9YTt0aGlzLmtleT1jO3RoaXMuc2libGluZz10aGlzLmNoaWxkPXRoaXMucmV0dXJuPXRoaXMuc3RhdGVOb2RlPXRoaXMudHlwZT10aGlzLmVsZW1lbnRUeXBlPW51bGw7dGhpcy5pbmRleD0wO3RoaXMucmVmPW51bGw7dGhpcy5wZW5kaW5nUHJvcHM9Yjt0aGlzLmRlcGVuZGVuY2llcz10aGlzLm1lbW9pemVkU3RhdGU9dGhpcy51cGRhdGVRdWV1ZT10aGlzLm1lbW9pemVkUHJvcHM9bnVsbDt0aGlzLm1vZGU9ZDt0aGlzLmZsYWdzPTA7dGhpcy5sYXN0RWZmZWN0PXRoaXMuZmlyc3RFZmZlY3Q9dGhpcy5uZXh0RWZmZWN0PW51bGw7dGhpcy5jaGlsZExhbmVzPXRoaXMubGFuZXM9MDt0aGlzLmFsdGVybmF0ZT1udWxsfWZ1bmN0aW9uIG5oKGEsYixjLGQpe3JldHVybiBuZXcgaWsoYSxiLGMsZCl9ZnVuY3Rpb24gamkoYSl7YT1hLnByb3RvdHlwZTtyZXR1cm4hKCFhfHwhYS5pc1JlYWN0Q29tcG9uZW50KX1cbmZ1bmN0aW9uIGhrKGEpe2lmKFwiZnVuY3Rpb25cIj09PXR5cGVvZiBhKXJldHVybiBqaShhKT8xOjA7aWYodm9pZCAwIT09YSYmbnVsbCE9PWEpe2E9YS4kJHR5cGVvZjtpZihhPT09QWEpcmV0dXJuIDExO2lmKGE9PT1EYSlyZXR1cm4gMTR9cmV0dXJuIDJ9XG5mdW5jdGlvbiBUZyhhLGIpe3ZhciBjPWEuYWx0ZXJuYXRlO251bGw9PT1jPyhjPW5oKGEudGFnLGIsYS5rZXksYS5tb2RlKSxjLmVsZW1lbnRUeXBlPWEuZWxlbWVudFR5cGUsYy50eXBlPWEudHlwZSxjLnN0YXRlTm9kZT1hLnN0YXRlTm9kZSxjLmFsdGVybmF0ZT1hLGEuYWx0ZXJuYXRlPWMpOihjLnBlbmRpbmdQcm9wcz1iLGMudHlwZT1hLnR5cGUsYy5mbGFncz0wLGMubmV4dEVmZmVjdD1udWxsLGMuZmlyc3RFZmZlY3Q9bnVsbCxjLmxhc3RFZmZlY3Q9bnVsbCk7Yy5jaGlsZExhbmVzPWEuY2hpbGRMYW5lcztjLmxhbmVzPWEubGFuZXM7Yy5jaGlsZD1hLmNoaWxkO2MubWVtb2l6ZWRQcm9wcz1hLm1lbW9pemVkUHJvcHM7Yy5tZW1vaXplZFN0YXRlPWEubWVtb2l6ZWRTdGF0ZTtjLnVwZGF0ZVF1ZXVlPWEudXBkYXRlUXVldWU7Yj1hLmRlcGVuZGVuY2llcztjLmRlcGVuZGVuY2llcz1udWxsPT09Yj9udWxsOntsYW5lczpiLmxhbmVzLGZpcnN0Q29udGV4dDpiLmZpcnN0Q29udGV4dH07XG5jLnNpYmxpbmc9YS5zaWJsaW5nO2MuaW5kZXg9YS5pbmRleDtjLnJlZj1hLnJlZjtyZXR1cm4gY31cbmZ1bmN0aW9uIFZnKGEsYixjLGQsZSxmKXt2YXIgZz0yO2Q9YTtpZihcImZ1bmN0aW9uXCI9PT10eXBlb2YgYSlqaShhKSYmKGc9MSk7ZWxzZSBpZihcInN0cmluZ1wiPT09dHlwZW9mIGEpZz01O2Vsc2UgYTpzd2l0Y2goYSl7Y2FzZSB1YTpyZXR1cm4gWGcoYy5jaGlsZHJlbixlLGYsYik7Y2FzZSBIYTpnPTg7ZXw9MTY7YnJlYWs7Y2FzZSB3YTpnPTg7ZXw9MTticmVhaztjYXNlIHhhOnJldHVybiBhPW5oKDEyLGMsYixlfDgpLGEuZWxlbWVudFR5cGU9eGEsYS50eXBlPXhhLGEubGFuZXM9ZixhO2Nhc2UgQmE6cmV0dXJuIGE9bmgoMTMsYyxiLGUpLGEudHlwZT1CYSxhLmVsZW1lbnRUeXBlPUJhLGEubGFuZXM9ZixhO2Nhc2UgQ2E6cmV0dXJuIGE9bmgoMTksYyxiLGUpLGEuZWxlbWVudFR5cGU9Q2EsYS5sYW5lcz1mLGE7Y2FzZSBJYTpyZXR1cm4gdmkoYyxlLGYsYik7Y2FzZSBKYTpyZXR1cm4gYT1uaCgyNCxjLGIsZSksYS5lbGVtZW50VHlwZT1KYSxhLmxhbmVzPWYsYTtkZWZhdWx0OmlmKFwib2JqZWN0XCI9PT1cbnR5cGVvZiBhJiZudWxsIT09YSlzd2l0Y2goYS4kJHR5cGVvZil7Y2FzZSB5YTpnPTEwO2JyZWFrIGE7Y2FzZSB6YTpnPTk7YnJlYWsgYTtjYXNlIEFhOmc9MTE7YnJlYWsgYTtjYXNlIERhOmc9MTQ7YnJlYWsgYTtjYXNlIEVhOmc9MTY7ZD1udWxsO2JyZWFrIGE7Y2FzZSBGYTpnPTIyO2JyZWFrIGF9dGhyb3cgRXJyb3IoeSgxMzAsbnVsbD09YT9hOnR5cGVvZiBhLFwiXCIpKTt9Yj1uaChnLGMsYixlKTtiLmVsZW1lbnRUeXBlPWE7Yi50eXBlPWQ7Yi5sYW5lcz1mO3JldHVybiBifWZ1bmN0aW9uIFhnKGEsYixjLGQpe2E9bmgoNyxhLGQsYik7YS5sYW5lcz1jO3JldHVybiBhfWZ1bmN0aW9uIHZpKGEsYixjLGQpe2E9bmgoMjMsYSxkLGIpO2EuZWxlbWVudFR5cGU9SWE7YS5sYW5lcz1jO3JldHVybiBhfWZ1bmN0aW9uIFVnKGEsYixjKXthPW5oKDYsYSxudWxsLGIpO2EubGFuZXM9YztyZXR1cm4gYX1cbmZ1bmN0aW9uIFdnKGEsYixjKXtiPW5oKDQsbnVsbCE9PWEuY2hpbGRyZW4/YS5jaGlsZHJlbjpbXSxhLmtleSxiKTtiLmxhbmVzPWM7Yi5zdGF0ZU5vZGU9e2NvbnRhaW5lckluZm86YS5jb250YWluZXJJbmZvLHBlbmRpbmdDaGlsZHJlbjpudWxsLGltcGxlbWVudGF0aW9uOmEuaW1wbGVtZW50YXRpb259O3JldHVybiBifVxuZnVuY3Rpb24gamsoYSxiLGMpe3RoaXMudGFnPWI7dGhpcy5jb250YWluZXJJbmZvPWE7dGhpcy5maW5pc2hlZFdvcms9dGhpcy5waW5nQ2FjaGU9dGhpcy5jdXJyZW50PXRoaXMucGVuZGluZ0NoaWxkcmVuPW51bGw7dGhpcy50aW1lb3V0SGFuZGxlPS0xO3RoaXMucGVuZGluZ0NvbnRleHQ9dGhpcy5jb250ZXh0PW51bGw7dGhpcy5oeWRyYXRlPWM7dGhpcy5jYWxsYmFja05vZGU9bnVsbDt0aGlzLmNhbGxiYWNrUHJpb3JpdHk9MDt0aGlzLmV2ZW50VGltZXM9WmMoMCk7dGhpcy5leHBpcmF0aW9uVGltZXM9WmMoLTEpO3RoaXMuZW50YW5nbGVkTGFuZXM9dGhpcy5maW5pc2hlZExhbmVzPXRoaXMubXV0YWJsZVJlYWRMYW5lcz10aGlzLmV4cGlyZWRMYW5lcz10aGlzLnBpbmdlZExhbmVzPXRoaXMuc3VzcGVuZGVkTGFuZXM9dGhpcy5wZW5kaW5nTGFuZXM9MDt0aGlzLmVudGFuZ2xlbWVudHM9WmMoMCk7dGhpcy5tdXRhYmxlU291cmNlRWFnZXJIeWRyYXRpb25EYXRhPW51bGx9XG5mdW5jdGlvbiBrayhhLGIsYyl7dmFyIGQ9Mzxhcmd1bWVudHMubGVuZ3RoJiZ2b2lkIDAhPT1hcmd1bWVudHNbM10/YXJndW1lbnRzWzNdOm51bGw7cmV0dXJueyQkdHlwZW9mOnRhLGtleTpudWxsPT1kP251bGw6XCJcIitkLGNoaWxkcmVuOmEsY29udGFpbmVySW5mbzpiLGltcGxlbWVudGF0aW9uOmN9fVxuZnVuY3Rpb24gbGsoYSxiLGMsZCl7dmFyIGU9Yi5jdXJyZW50LGY9SGcoKSxnPUlnKGUpO2E6aWYoYyl7Yz1jLl9yZWFjdEludGVybmFscztiOntpZihaYihjKSE9PWN8fDEhPT1jLnRhZyl0aHJvdyBFcnJvcih5KDE3MCkpO3ZhciBoPWM7ZG97c3dpdGNoKGgudGFnKXtjYXNlIDM6aD1oLnN0YXRlTm9kZS5jb250ZXh0O2JyZWFrIGI7Y2FzZSAxOmlmKEZmKGgudHlwZSkpe2g9aC5zdGF0ZU5vZGUuX19yZWFjdEludGVybmFsTWVtb2l6ZWRNZXJnZWRDaGlsZENvbnRleHQ7YnJlYWsgYn19aD1oLnJldHVybn13aGlsZShudWxsIT09aCk7dGhyb3cgRXJyb3IoeSgxNzEpKTt9aWYoMT09PWMudGFnKXt2YXIgaz1jLnR5cGU7aWYoRmYoaykpe2M9SWYoYyxrLGgpO2JyZWFrIGF9fWM9aH1lbHNlIGM9Q2Y7bnVsbD09PWIuY29udGV4dD9iLmNvbnRleHQ9YzpiLnBlbmRpbmdDb250ZXh0PWM7Yj16ZyhmLGcpO2IucGF5bG9hZD17ZWxlbWVudDphfTtkPXZvaWQgMD09PWQ/bnVsbDpkO251bGwhPT1cbmQmJihiLmNhbGxiYWNrPWQpO0FnKGUsYik7SmcoZSxnLGYpO3JldHVybiBnfWZ1bmN0aW9uIG1rKGEpe2E9YS5jdXJyZW50O2lmKCFhLmNoaWxkKXJldHVybiBudWxsO3N3aXRjaChhLmNoaWxkLnRhZyl7Y2FzZSA1OnJldHVybiBhLmNoaWxkLnN0YXRlTm9kZTtkZWZhdWx0OnJldHVybiBhLmNoaWxkLnN0YXRlTm9kZX19ZnVuY3Rpb24gbmsoYSxiKXthPWEubWVtb2l6ZWRTdGF0ZTtpZihudWxsIT09YSYmbnVsbCE9PWEuZGVoeWRyYXRlZCl7dmFyIGM9YS5yZXRyeUxhbmU7YS5yZXRyeUxhbmU9MCE9PWMmJmM8Yj9jOmJ9fWZ1bmN0aW9uIG9rKGEsYil7bmsoYSxiKTsoYT1hLmFsdGVybmF0ZSkmJm5rKGEsYil9ZnVuY3Rpb24gcGsoKXtyZXR1cm4gbnVsbH1cbmZ1bmN0aW9uIHFrKGEsYixjKXt2YXIgZD1udWxsIT1jJiZudWxsIT1jLmh5ZHJhdGlvbk9wdGlvbnMmJmMuaHlkcmF0aW9uT3B0aW9ucy5tdXRhYmxlU291cmNlc3x8bnVsbDtjPW5ldyBqayhhLGIsbnVsbCE9YyYmITA9PT1jLmh5ZHJhdGUpO2I9bmgoMyxudWxsLG51bGwsMj09PWI/NzoxPT09Yj8zOjApO2MuY3VycmVudD1iO2Iuc3RhdGVOb2RlPWM7eGcoYik7YVtmZl09Yy5jdXJyZW50O2NmKDg9PT1hLm5vZGVUeXBlP2EucGFyZW50Tm9kZTphKTtpZihkKWZvcihhPTA7YTxkLmxlbmd0aDthKyspe2I9ZFthXTt2YXIgZT1iLl9nZXRWZXJzaW9uO2U9ZShiLl9zb3VyY2UpO251bGw9PWMubXV0YWJsZVNvdXJjZUVhZ2VySHlkcmF0aW9uRGF0YT9jLm11dGFibGVTb3VyY2VFYWdlckh5ZHJhdGlvbkRhdGE9W2IsZV06Yy5tdXRhYmxlU291cmNlRWFnZXJIeWRyYXRpb25EYXRhLnB1c2goYixlKX10aGlzLl9pbnRlcm5hbFJvb3Q9Y31cbnFrLnByb3RvdHlwZS5yZW5kZXI9ZnVuY3Rpb24oYSl7bGsoYSx0aGlzLl9pbnRlcm5hbFJvb3QsbnVsbCxudWxsKX07cWsucHJvdG90eXBlLnVubW91bnQ9ZnVuY3Rpb24oKXt2YXIgYT10aGlzLl9pbnRlcm5hbFJvb3QsYj1hLmNvbnRhaW5lckluZm87bGsobnVsbCxhLG51bGwsZnVuY3Rpb24oKXtiW2ZmXT1udWxsfSl9O2Z1bmN0aW9uIHJrKGEpe3JldHVybiEoIWF8fDEhPT1hLm5vZGVUeXBlJiY5IT09YS5ub2RlVHlwZSYmMTEhPT1hLm5vZGVUeXBlJiYoOCE9PWEubm9kZVR5cGV8fFwiIHJlYWN0LW1vdW50LXBvaW50LXVuc3RhYmxlIFwiIT09YS5ub2RlVmFsdWUpKX1cbmZ1bmN0aW9uIHNrKGEsYil7Ynx8KGI9YT85PT09YS5ub2RlVHlwZT9hLmRvY3VtZW50RWxlbWVudDphLmZpcnN0Q2hpbGQ6bnVsbCxiPSEoIWJ8fDEhPT1iLm5vZGVUeXBlfHwhYi5oYXNBdHRyaWJ1dGUoXCJkYXRhLXJlYWN0cm9vdFwiKSkpO2lmKCFiKWZvcih2YXIgYztjPWEubGFzdENoaWxkOylhLnJlbW92ZUNoaWxkKGMpO3JldHVybiBuZXcgcWsoYSwwLGI/e2h5ZHJhdGU6ITB9OnZvaWQgMCl9XG5mdW5jdGlvbiB0ayhhLGIsYyxkLGUpe3ZhciBmPWMuX3JlYWN0Um9vdENvbnRhaW5lcjtpZihmKXt2YXIgZz1mLl9pbnRlcm5hbFJvb3Q7aWYoXCJmdW5jdGlvblwiPT09dHlwZW9mIGUpe3ZhciBoPWU7ZT1mdW5jdGlvbigpe3ZhciBhPW1rKGcpO2guY2FsbChhKX19bGsoYixnLGEsZSl9ZWxzZXtmPWMuX3JlYWN0Um9vdENvbnRhaW5lcj1zayhjLGQpO2c9Zi5faW50ZXJuYWxSb290O2lmKFwiZnVuY3Rpb25cIj09PXR5cGVvZiBlKXt2YXIgaz1lO2U9ZnVuY3Rpb24oKXt2YXIgYT1tayhnKTtrLmNhbGwoYSl9fVhqKGZ1bmN0aW9uKCl7bGsoYixnLGEsZSl9KX1yZXR1cm4gbWsoZyl9ZWM9ZnVuY3Rpb24oYSl7aWYoMTM9PT1hLnRhZyl7dmFyIGI9SGcoKTtKZyhhLDQsYik7b2soYSw0KX19O2ZjPWZ1bmN0aW9uKGEpe2lmKDEzPT09YS50YWcpe3ZhciBiPUhnKCk7SmcoYSw2NzEwODg2NCxiKTtvayhhLDY3MTA4ODY0KX19O1xuZ2M9ZnVuY3Rpb24oYSl7aWYoMTM9PT1hLnRhZyl7dmFyIGI9SGcoKSxjPUlnKGEpO0pnKGEsYyxiKTtvayhhLGMpfX07aGM9ZnVuY3Rpb24oYSxiKXtyZXR1cm4gYigpfTtcbnliPWZ1bmN0aW9uKGEsYixjKXtzd2l0Y2goYil7Y2FzZSBcImlucHV0XCI6YWIoYSxjKTtiPWMubmFtZTtpZihcInJhZGlvXCI9PT1jLnR5cGUmJm51bGwhPWIpe2ZvcihjPWE7Yy5wYXJlbnROb2RlOyljPWMucGFyZW50Tm9kZTtjPWMucXVlcnlTZWxlY3RvckFsbChcImlucHV0W25hbWU9XCIrSlNPTi5zdHJpbmdpZnkoXCJcIitiKSsnXVt0eXBlPVwicmFkaW9cIl0nKTtmb3IoYj0wO2I8Yy5sZW5ndGg7YisrKXt2YXIgZD1jW2JdO2lmKGQhPT1hJiZkLmZvcm09PT1hLmZvcm0pe3ZhciBlPURiKGQpO2lmKCFlKXRocm93IEVycm9yKHkoOTApKTtXYShkKTthYihkLGUpfX19YnJlYWs7Y2FzZSBcInRleHRhcmVhXCI6aWIoYSxjKTticmVhaztjYXNlIFwic2VsZWN0XCI6Yj1jLnZhbHVlLG51bGwhPWImJmZiKGEsISFjLm11bHRpcGxlLGIsITEpfX07R2I9V2o7XG5IYj1mdW5jdGlvbihhLGIsYyxkLGUpe3ZhciBmPVg7WHw9NDt0cnl7cmV0dXJuIGdnKDk4LGEuYmluZChudWxsLGIsYyxkLGUpKX1maW5hbGx5e1g9ZiwwPT09WCYmKHdqKCksaWcoKSl9fTtJYj1mdW5jdGlvbigpezA9PT0oWCY0OSkmJihWaigpLE9qKCkpfTtKYj1mdW5jdGlvbihhLGIpe3ZhciBjPVg7WHw9Mjt0cnl7cmV0dXJuIGEoYil9ZmluYWxseXtYPWMsMD09PVgmJih3aigpLGlnKCkpfX07ZnVuY3Rpb24gdWsoYSxiKXt2YXIgYz0yPGFyZ3VtZW50cy5sZW5ndGgmJnZvaWQgMCE9PWFyZ3VtZW50c1syXT9hcmd1bWVudHNbMl06bnVsbDtpZighcmsoYikpdGhyb3cgRXJyb3IoeSgyMDApKTtyZXR1cm4ga2soYSxiLG51bGwsYyl9dmFyIHZrPXtFdmVudHM6W0NiLHVlLERiLEViLEZiLE9qLHtjdXJyZW50OiExfV19LHdrPXtmaW5kRmliZXJCeUhvc3RJbnN0YW5jZTp3YyxidW5kbGVUeXBlOjAsdmVyc2lvbjpcIjE3LjAuMlwiLHJlbmRlcmVyUGFja2FnZU5hbWU6XCJyZWFjdC1kb21cIn07XG52YXIgeGs9e2J1bmRsZVR5cGU6d2suYnVuZGxlVHlwZSx2ZXJzaW9uOndrLnZlcnNpb24scmVuZGVyZXJQYWNrYWdlTmFtZTp3ay5yZW5kZXJlclBhY2thZ2VOYW1lLHJlbmRlcmVyQ29uZmlnOndrLnJlbmRlcmVyQ29uZmlnLG92ZXJyaWRlSG9va1N0YXRlOm51bGwsb3ZlcnJpZGVIb29rU3RhdGVEZWxldGVQYXRoOm51bGwsb3ZlcnJpZGVIb29rU3RhdGVSZW5hbWVQYXRoOm51bGwsb3ZlcnJpZGVQcm9wczpudWxsLG92ZXJyaWRlUHJvcHNEZWxldGVQYXRoOm51bGwsb3ZlcnJpZGVQcm9wc1JlbmFtZVBhdGg6bnVsbCxzZXRTdXNwZW5zZUhhbmRsZXI6bnVsbCxzY2hlZHVsZVVwZGF0ZTpudWxsLGN1cnJlbnREaXNwYXRjaGVyUmVmOnJhLlJlYWN0Q3VycmVudERpc3BhdGNoZXIsZmluZEhvc3RJbnN0YW5jZUJ5RmliZXI6ZnVuY3Rpb24oYSl7YT1jYyhhKTtyZXR1cm4gbnVsbD09PWE/bnVsbDphLnN0YXRlTm9kZX0sZmluZEZpYmVyQnlIb3N0SW5zdGFuY2U6d2suZmluZEZpYmVyQnlIb3N0SW5zdGFuY2V8fFxucGssZmluZEhvc3RJbnN0YW5jZXNGb3JSZWZyZXNoOm51bGwsc2NoZWR1bGVSZWZyZXNoOm51bGwsc2NoZWR1bGVSb290Om51bGwsc2V0UmVmcmVzaEhhbmRsZXI6bnVsbCxnZXRDdXJyZW50RmliZXI6bnVsbH07aWYoXCJ1bmRlZmluZWRcIiE9PXR5cGVvZiBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18pe3ZhciB5az1fX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX187aWYoIXlrLmlzRGlzYWJsZWQmJnlrLnN1cHBvcnRzRmliZXIpdHJ5e0xmPXlrLmluamVjdCh4ayksTWY9eWt9Y2F0Y2goYSl7fX1leHBvcnRzLl9fU0VDUkVUX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0ZJUkVEPXZrO2V4cG9ydHMuY3JlYXRlUG9ydGFsPXVrO1xuZXhwb3J0cy5maW5kRE9NTm9kZT1mdW5jdGlvbihhKXtpZihudWxsPT1hKXJldHVybiBudWxsO2lmKDE9PT1hLm5vZGVUeXBlKXJldHVybiBhO3ZhciBiPWEuX3JlYWN0SW50ZXJuYWxzO2lmKHZvaWQgMD09PWIpe2lmKFwiZnVuY3Rpb25cIj09PXR5cGVvZiBhLnJlbmRlcil0aHJvdyBFcnJvcih5KDE4OCkpO3Rocm93IEVycm9yKHkoMjY4LE9iamVjdC5rZXlzKGEpKSk7fWE9Y2MoYik7YT1udWxsPT09YT9udWxsOmEuc3RhdGVOb2RlO3JldHVybiBhfTtleHBvcnRzLmZsdXNoU3luYz1mdW5jdGlvbihhLGIpe3ZhciBjPVg7aWYoMCE9PShjJjQ4KSlyZXR1cm4gYShiKTtYfD0xO3RyeXtpZihhKXJldHVybiBnZyg5OSxhLmJpbmQobnVsbCxiKSl9ZmluYWxseXtYPWMsaWcoKX19O2V4cG9ydHMuaHlkcmF0ZT1mdW5jdGlvbihhLGIsYyl7aWYoIXJrKGIpKXRocm93IEVycm9yKHkoMjAwKSk7cmV0dXJuIHRrKG51bGwsYSxiLCEwLGMpfTtcbmV4cG9ydHMucmVuZGVyPWZ1bmN0aW9uKGEsYixjKXtpZighcmsoYikpdGhyb3cgRXJyb3IoeSgyMDApKTtyZXR1cm4gdGsobnVsbCxhLGIsITEsYyl9O2V4cG9ydHMudW5tb3VudENvbXBvbmVudEF0Tm9kZT1mdW5jdGlvbihhKXtpZighcmsoYSkpdGhyb3cgRXJyb3IoeSg0MCkpO3JldHVybiBhLl9yZWFjdFJvb3RDb250YWluZXI/KFhqKGZ1bmN0aW9uKCl7dGsobnVsbCxudWxsLGEsITEsZnVuY3Rpb24oKXthLl9yZWFjdFJvb3RDb250YWluZXI9bnVsbDthW2ZmXT1udWxsfSl9KSwhMCk6ITF9O2V4cG9ydHMudW5zdGFibGVfYmF0Y2hlZFVwZGF0ZXM9V2o7ZXhwb3J0cy51bnN0YWJsZV9jcmVhdGVQb3J0YWw9ZnVuY3Rpb24oYSxiKXtyZXR1cm4gdWsoYSxiLDI8YXJndW1lbnRzLmxlbmd0aCYmdm9pZCAwIT09YXJndW1lbnRzWzJdP2FyZ3VtZW50c1syXTpudWxsKX07XG5leHBvcnRzLnVuc3RhYmxlX3JlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyPWZ1bmN0aW9uKGEsYixjLGQpe2lmKCFyayhjKSl0aHJvdyBFcnJvcih5KDIwMCkpO2lmKG51bGw9PWF8fHZvaWQgMD09PWEuX3JlYWN0SW50ZXJuYWxzKXRocm93IEVycm9yKHkoMzgpKTtyZXR1cm4gdGsoYSxiLGMsITEsZCl9O2V4cG9ydHMudmVyc2lvbj1cIjE3LjAuMlwiO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///448\n')},935:(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("\n\nfunction checkDCE() {\n  /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */\n  if (\n    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === 'undefined' ||\n    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== 'function'\n  ) {\n    return;\n  }\n  if (false) {}\n  try {\n    // Verify that the code above has been dead code eliminated (DCE'd).\n    __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);\n  } catch (err) {\n    // DevTools shouldn't crash React, no matter what.\n    // We should still report in case we break this code.\n    console.error(err);\n  }\n}\n\nif (true) {\n  // DCE check should happen before ReactDOM bundle executes so that\n  // DevTools can report bad minification during injection.\n  checkDCE();\n  module.exports = __webpack_require__(448);\n} else {}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTM1LmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLEtBQXFDLEVBQUUsRUFTMUM7QUFDSDtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxJQUFJLElBQXFDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBLEVBQUUseUNBQTZEO0FBQy9ELEVBQUUsS0FBSyxFQUVOIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbWRjLXJlYWN0Ly4vbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9pbmRleC5qcz84YmM4Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gY2hlY2tEQ0UoKSB7XG4gIC8qIGdsb2JhbCBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18gKi9cbiAgaWYgKFxuICAgIHR5cGVvZiBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18gPT09ICd1bmRlZmluZWQnIHx8XG4gICAgdHlwZW9mIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXy5jaGVja0RDRSAhPT0gJ2Z1bmN0aW9uJ1xuICApIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAvLyBUaGlzIGJyYW5jaCBpcyB1bnJlYWNoYWJsZSBiZWNhdXNlIHRoaXMgZnVuY3Rpb24gaXMgb25seSBjYWxsZWRcbiAgICAvLyBpbiBwcm9kdWN0aW9uLCBidXQgdGhlIGNvbmRpdGlvbiBpcyB0cnVlIG9ubHkgaW4gZGV2ZWxvcG1lbnQuXG4gICAgLy8gVGhlcmVmb3JlIGlmIHRoZSBicmFuY2ggaXMgc3RpbGwgaGVyZSwgZGVhZCBjb2RlIGVsaW1pbmF0aW9uIHdhc24ndFxuICAgIC8vIHByb3Blcmx5IGFwcGxpZWQuXG4gICAgLy8gRG9uJ3QgY2hhbmdlIHRoZSBtZXNzYWdlLiBSZWFjdCBEZXZUb29scyByZWxpZXMgb24gaXQuIEFsc28gbWFrZSBzdXJlXG4gICAgLy8gdGhpcyBtZXNzYWdlIGRvZXNuJ3Qgb2NjdXIgZWxzZXdoZXJlIGluIHRoaXMgZnVuY3Rpb24sIG9yIGl0IHdpbGwgY2F1c2VcbiAgICAvLyBhIGZhbHNlIHBvc2l0aXZlLlxuICAgIHRocm93IG5ldyBFcnJvcignXl9eJyk7XG4gIH1cbiAgdHJ5IHtcbiAgICAvLyBWZXJpZnkgdGhhdCB0aGUgY29kZSBhYm92ZSBoYXMgYmVlbiBkZWFkIGNvZGUgZWxpbWluYXRlZCAoRENFJ2QpLlxuICAgIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXy5jaGVja0RDRShjaGVja0RDRSk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIC8vIERldlRvb2xzIHNob3VsZG4ndCBjcmFzaCBSZWFjdCwgbm8gbWF0dGVyIHdoYXQuXG4gICAgLy8gV2Ugc2hvdWxkIHN0aWxsIHJlcG9ydCBpbiBjYXNlIHdlIGJyZWFrIHRoaXMgY29kZS5cbiAgICBjb25zb2xlLmVycm9yKGVycik7XG4gIH1cbn1cblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcbiAgLy8gRENFIGNoZWNrIHNob3VsZCBoYXBwZW4gYmVmb3JlIFJlYWN0RE9NIGJ1bmRsZSBleGVjdXRlcyBzbyB0aGF0XG4gIC8vIERldlRvb2xzIGNhbiByZXBvcnQgYmFkIG1pbmlmaWNhdGlvbiBkdXJpbmcgaW5qZWN0aW9uLlxuICBjaGVja0RDRSgpO1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3JlYWN0LWRvbS5wcm9kdWN0aW9uLm1pbi5qcycpO1xufSBlbHNlIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9yZWFjdC1kb20uZGV2ZWxvcG1lbnQuanMnKTtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///935\n")},921:(__unused_webpack_module,exports)=>{"use strict";eval('/** @license React v16.13.1\n * react-is.production.min.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nvar b="function"===typeof Symbol&&Symbol.for,c=b?Symbol.for("react.element"):60103,d=b?Symbol.for("react.portal"):60106,e=b?Symbol.for("react.fragment"):60107,f=b?Symbol.for("react.strict_mode"):60108,g=b?Symbol.for("react.profiler"):60114,h=b?Symbol.for("react.provider"):60109,k=b?Symbol.for("react.context"):60110,l=b?Symbol.for("react.async_mode"):60111,m=b?Symbol.for("react.concurrent_mode"):60111,n=b?Symbol.for("react.forward_ref"):60112,p=b?Symbol.for("react.suspense"):60113,q=b?\nSymbol.for("react.suspense_list"):60120,r=b?Symbol.for("react.memo"):60115,t=b?Symbol.for("react.lazy"):60116,v=b?Symbol.for("react.block"):60121,w=b?Symbol.for("react.fundamental"):60117,x=b?Symbol.for("react.responder"):60118,y=b?Symbol.for("react.scope"):60119;\nfunction z(a){if("object"===typeof a&&null!==a){var u=a.$$typeof;switch(u){case c:switch(a=a.type,a){case l:case m:case e:case g:case f:case p:return a;default:switch(a=a&&a.$$typeof,a){case k:case n:case t:case r:case h:return a;default:return u}}case d:return u}}}function A(a){return z(a)===m}exports.AsyncMode=l;exports.ConcurrentMode=m;exports.ContextConsumer=k;exports.ContextProvider=h;exports.Element=c;exports.ForwardRef=n;exports.Fragment=e;exports.Lazy=t;exports.Memo=r;exports.Portal=d;\nexports.Profiler=g;exports.StrictMode=f;exports.Suspense=p;exports.isAsyncMode=function(a){return A(a)||z(a)===l};exports.isConcurrentMode=A;exports.isContextConsumer=function(a){return z(a)===k};exports.isContextProvider=function(a){return z(a)===h};exports.isElement=function(a){return"object"===typeof a&&null!==a&&a.$$typeof===c};exports.isForwardRef=function(a){return z(a)===n};exports.isFragment=function(a){return z(a)===e};exports.isLazy=function(a){return z(a)===t};\nexports.isMemo=function(a){return z(a)===r};exports.isPortal=function(a){return z(a)===d};exports.isProfiler=function(a){return z(a)===g};exports.isStrictMode=function(a){return z(a)===f};exports.isSuspense=function(a){return z(a)===p};\nexports.isValidElementType=function(a){return"string"===typeof a||"function"===typeof a||a===e||a===m||a===g||a===f||a===p||a===q||"object"===typeof a&&null!==a&&(a.$$typeof===t||a.$$typeof===r||a.$$typeof===h||a.$$typeof===k||a.$$typeof===n||a.$$typeof===w||a.$$typeof===x||a.$$typeof===y||a.$$typeof===v)};exports.typeOf=z;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTIxLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWE7QUFDYjtBQUNBLGNBQWMsa0NBQWtDLGlCQUFpQixVQUFVLDBCQUEwQixtREFBbUQsa0NBQWtDLDRDQUE0QyxrQkFBa0Isa0JBQWtCLGNBQWMsZ0JBQWdCLGlCQUFpQixHQUFHLHNCQUFzQixHQUFHLHVCQUF1QixHQUFHLHVCQUF1QixHQUFHLGVBQWUsR0FBRyxrQkFBa0IsR0FBRyxnQkFBZ0IsR0FBRyxZQUFZLEdBQUcsWUFBWSxHQUFHLGNBQWM7QUFDL2UsZ0JBQWdCLEdBQUcsa0JBQWtCLEdBQUcsZ0JBQWdCLEdBQUcsbUJBQW1CLGFBQWEsdUJBQXVCLHdCQUF3QixHQUFHLHlCQUF5QixhQUFhLGlCQUFpQix5QkFBeUIsYUFBYSxpQkFBaUIsaUJBQWlCLGFBQWEscURBQXFELG9CQUFvQixhQUFhLGlCQUFpQixrQkFBa0IsYUFBYSxpQkFBaUIsY0FBYyxhQUFhO0FBQzNjLGNBQWMsYUFBYSxpQkFBaUIsZ0JBQWdCLGFBQWEsaUJBQWlCLGtCQUFrQixhQUFhLGlCQUFpQixvQkFBb0IsYUFBYSxpQkFBaUIsa0JBQWtCLGFBQWE7QUFDM04sMEJBQTBCLGFBQWEsNlFBQTZRLGNBQWMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9ub2RlX21vZHVsZXMvcmVhY3QtaXMvY2pzL3JlYWN0LWlzLnByb2R1Y3Rpb24ubWluLmpzP2E5M2QiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqIEBsaWNlbnNlIFJlYWN0IHYxNi4xMy4xXG4gKiByZWFjdC1pcy5wcm9kdWN0aW9uLm1pbi5qc1xuICpcbiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbid1c2Ugc3RyaWN0Jzt2YXIgYj1cImZ1bmN0aW9uXCI9PT10eXBlb2YgU3ltYm9sJiZTeW1ib2wuZm9yLGM9Yj9TeW1ib2wuZm9yKFwicmVhY3QuZWxlbWVudFwiKTo2MDEwMyxkPWI/U3ltYm9sLmZvcihcInJlYWN0LnBvcnRhbFwiKTo2MDEwNixlPWI/U3ltYm9sLmZvcihcInJlYWN0LmZyYWdtZW50XCIpOjYwMTA3LGY9Yj9TeW1ib2wuZm9yKFwicmVhY3Quc3RyaWN0X21vZGVcIik6NjAxMDgsZz1iP1N5bWJvbC5mb3IoXCJyZWFjdC5wcm9maWxlclwiKTo2MDExNCxoPWI/U3ltYm9sLmZvcihcInJlYWN0LnByb3ZpZGVyXCIpOjYwMTA5LGs9Yj9TeW1ib2wuZm9yKFwicmVhY3QuY29udGV4dFwiKTo2MDExMCxsPWI/U3ltYm9sLmZvcihcInJlYWN0LmFzeW5jX21vZGVcIik6NjAxMTEsbT1iP1N5bWJvbC5mb3IoXCJyZWFjdC5jb25jdXJyZW50X21vZGVcIik6NjAxMTEsbj1iP1N5bWJvbC5mb3IoXCJyZWFjdC5mb3J3YXJkX3JlZlwiKTo2MDExMixwPWI/U3ltYm9sLmZvcihcInJlYWN0LnN1c3BlbnNlXCIpOjYwMTEzLHE9Yj9cblN5bWJvbC5mb3IoXCJyZWFjdC5zdXNwZW5zZV9saXN0XCIpOjYwMTIwLHI9Yj9TeW1ib2wuZm9yKFwicmVhY3QubWVtb1wiKTo2MDExNSx0PWI/U3ltYm9sLmZvcihcInJlYWN0LmxhenlcIik6NjAxMTYsdj1iP1N5bWJvbC5mb3IoXCJyZWFjdC5ibG9ja1wiKTo2MDEyMSx3PWI/U3ltYm9sLmZvcihcInJlYWN0LmZ1bmRhbWVudGFsXCIpOjYwMTE3LHg9Yj9TeW1ib2wuZm9yKFwicmVhY3QucmVzcG9uZGVyXCIpOjYwMTE4LHk9Yj9TeW1ib2wuZm9yKFwicmVhY3Quc2NvcGVcIik6NjAxMTk7XG5mdW5jdGlvbiB6KGEpe2lmKFwib2JqZWN0XCI9PT10eXBlb2YgYSYmbnVsbCE9PWEpe3ZhciB1PWEuJCR0eXBlb2Y7c3dpdGNoKHUpe2Nhc2UgYzpzd2l0Y2goYT1hLnR5cGUsYSl7Y2FzZSBsOmNhc2UgbTpjYXNlIGU6Y2FzZSBnOmNhc2UgZjpjYXNlIHA6cmV0dXJuIGE7ZGVmYXVsdDpzd2l0Y2goYT1hJiZhLiQkdHlwZW9mLGEpe2Nhc2UgazpjYXNlIG46Y2FzZSB0OmNhc2UgcjpjYXNlIGg6cmV0dXJuIGE7ZGVmYXVsdDpyZXR1cm4gdX19Y2FzZSBkOnJldHVybiB1fX19ZnVuY3Rpb24gQShhKXtyZXR1cm4geihhKT09PW19ZXhwb3J0cy5Bc3luY01vZGU9bDtleHBvcnRzLkNvbmN1cnJlbnRNb2RlPW07ZXhwb3J0cy5Db250ZXh0Q29uc3VtZXI9aztleHBvcnRzLkNvbnRleHRQcm92aWRlcj1oO2V4cG9ydHMuRWxlbWVudD1jO2V4cG9ydHMuRm9yd2FyZFJlZj1uO2V4cG9ydHMuRnJhZ21lbnQ9ZTtleHBvcnRzLkxhenk9dDtleHBvcnRzLk1lbW89cjtleHBvcnRzLlBvcnRhbD1kO1xuZXhwb3J0cy5Qcm9maWxlcj1nO2V4cG9ydHMuU3RyaWN0TW9kZT1mO2V4cG9ydHMuU3VzcGVuc2U9cDtleHBvcnRzLmlzQXN5bmNNb2RlPWZ1bmN0aW9uKGEpe3JldHVybiBBKGEpfHx6KGEpPT09bH07ZXhwb3J0cy5pc0NvbmN1cnJlbnRNb2RlPUE7ZXhwb3J0cy5pc0NvbnRleHRDb25zdW1lcj1mdW5jdGlvbihhKXtyZXR1cm4geihhKT09PWt9O2V4cG9ydHMuaXNDb250ZXh0UHJvdmlkZXI9ZnVuY3Rpb24oYSl7cmV0dXJuIHooYSk9PT1ofTtleHBvcnRzLmlzRWxlbWVudD1mdW5jdGlvbihhKXtyZXR1cm5cIm9iamVjdFwiPT09dHlwZW9mIGEmJm51bGwhPT1hJiZhLiQkdHlwZW9mPT09Y307ZXhwb3J0cy5pc0ZvcndhcmRSZWY9ZnVuY3Rpb24oYSl7cmV0dXJuIHooYSk9PT1ufTtleHBvcnRzLmlzRnJhZ21lbnQ9ZnVuY3Rpb24oYSl7cmV0dXJuIHooYSk9PT1lfTtleHBvcnRzLmlzTGF6eT1mdW5jdGlvbihhKXtyZXR1cm4geihhKT09PXR9O1xuZXhwb3J0cy5pc01lbW89ZnVuY3Rpb24oYSl7cmV0dXJuIHooYSk9PT1yfTtleHBvcnRzLmlzUG9ydGFsPWZ1bmN0aW9uKGEpe3JldHVybiB6KGEpPT09ZH07ZXhwb3J0cy5pc1Byb2ZpbGVyPWZ1bmN0aW9uKGEpe3JldHVybiB6KGEpPT09Z307ZXhwb3J0cy5pc1N0cmljdE1vZGU9ZnVuY3Rpb24oYSl7cmV0dXJuIHooYSk9PT1mfTtleHBvcnRzLmlzU3VzcGVuc2U9ZnVuY3Rpb24oYSl7cmV0dXJuIHooYSk9PT1wfTtcbmV4cG9ydHMuaXNWYWxpZEVsZW1lbnRUeXBlPWZ1bmN0aW9uKGEpe3JldHVyblwic3RyaW5nXCI9PT10eXBlb2YgYXx8XCJmdW5jdGlvblwiPT09dHlwZW9mIGF8fGE9PT1lfHxhPT09bXx8YT09PWd8fGE9PT1mfHxhPT09cHx8YT09PXF8fFwib2JqZWN0XCI9PT10eXBlb2YgYSYmbnVsbCE9PWEmJihhLiQkdHlwZW9mPT09dHx8YS4kJHR5cGVvZj09PXJ8fGEuJCR0eXBlb2Y9PT1ofHxhLiQkdHlwZW9mPT09a3x8YS4kJHR5cGVvZj09PW58fGEuJCR0eXBlb2Y9PT13fHxhLiQkdHlwZW9mPT09eHx8YS4kJHR5cGVvZj09PXl8fGEuJCR0eXBlb2Y9PT12KX07ZXhwb3J0cy50eXBlT2Y9ejtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///921\n')},864:(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("\n\nif (true) {\n  module.exports = __webpack_require__(921);\n} else {}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODY0LmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLElBQUksSUFBcUM7QUFDekMsRUFBRSx5Q0FBNEQ7QUFDOUQsRUFBRSxLQUFLLEVBRU4iLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9ub2RlX21vZHVsZXMvcmVhY3QtaXMvaW5kZXguanM/NGNlYyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtaXMucHJvZHVjdGlvbi5taW4uanMnKTtcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtaXMuZGV2ZWxvcG1lbnQuanMnKTtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///864\n")},251:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('/** @license React v17.0.2\n * react-jsx-runtime.production.min.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n__webpack_require__(418);var f=__webpack_require__(294),g=60103;exports.Fragment=60107;if("function"===typeof Symbol&&Symbol.for){var h=Symbol.for;g=h("react.element");exports.Fragment=h("react.fragment")}var m=f.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner,n=Object.prototype.hasOwnProperty,p={key:!0,ref:!0,__self:!0,__source:!0};\nfunction q(c,a,k){var b,d={},e=null,l=null;void 0!==k&&(e=""+k);void 0!==a.key&&(e=""+a.key);void 0!==a.ref&&(l=a.ref);for(b in a)n.call(a,b)&&!p.hasOwnProperty(b)&&(d[b]=a[b]);if(c&&c.defaultProps)for(b in a=c.defaultProps,a)void 0===d[b]&&(d[b]=a[b]);return{$$typeof:g,type:c,key:e,ref:l,props:d,_owner:m.current}}exports.jsx=q;exports.jsxs=q;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjUxLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDYSxtQkFBTyxDQUFDLEdBQWUsRUFBRSxNQUFNLG1CQUFPLENBQUMsR0FBTyxVQUFVLGdCQUFnQixPQUFPLDJDQUEyQyxpQkFBaUIscUJBQXFCLGdCQUFnQixxQkFBcUIsa0hBQWtIO0FBQ3BVLGtCQUFrQixVQUFVLGVBQWUscUJBQXFCLDZCQUE2QiwwQkFBMEIsMERBQTBELDRFQUE0RSxPQUFPLHdEQUF3RCxXQUFXLEdBQUcsWUFBWSIsInNvdXJjZXMiOlsid2VicGFjazovL21kYy1yZWFjdC8uL25vZGVfbW9kdWxlcy9yZWFjdC9janMvcmVhY3QtanN4LXJ1bnRpbWUucHJvZHVjdGlvbi5taW4uanM/ZDMxZCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiogQGxpY2Vuc2UgUmVhY3QgdjE3LjAuMlxuICogcmVhY3QtanN4LXJ1bnRpbWUucHJvZHVjdGlvbi5taW4uanNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuJ3VzZSBzdHJpY3QnO3JlcXVpcmUoXCJvYmplY3QtYXNzaWduXCIpO3ZhciBmPXJlcXVpcmUoXCJyZWFjdFwiKSxnPTYwMTAzO2V4cG9ydHMuRnJhZ21lbnQ9NjAxMDc7aWYoXCJmdW5jdGlvblwiPT09dHlwZW9mIFN5bWJvbCYmU3ltYm9sLmZvcil7dmFyIGg9U3ltYm9sLmZvcjtnPWgoXCJyZWFjdC5lbGVtZW50XCIpO2V4cG9ydHMuRnJhZ21lbnQ9aChcInJlYWN0LmZyYWdtZW50XCIpfXZhciBtPWYuX19TRUNSRVRfSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfWU9VX1dJTExfQkVfRklSRUQuUmVhY3RDdXJyZW50T3duZXIsbj1PYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LHA9e2tleTohMCxyZWY6ITAsX19zZWxmOiEwLF9fc291cmNlOiEwfTtcbmZ1bmN0aW9uIHEoYyxhLGspe3ZhciBiLGQ9e30sZT1udWxsLGw9bnVsbDt2b2lkIDAhPT1rJiYoZT1cIlwiK2spO3ZvaWQgMCE9PWEua2V5JiYoZT1cIlwiK2Eua2V5KTt2b2lkIDAhPT1hLnJlZiYmKGw9YS5yZWYpO2ZvcihiIGluIGEpbi5jYWxsKGEsYikmJiFwLmhhc093blByb3BlcnR5KGIpJiYoZFtiXT1hW2JdKTtpZihjJiZjLmRlZmF1bHRQcm9wcylmb3IoYiBpbiBhPWMuZGVmYXVsdFByb3BzLGEpdm9pZCAwPT09ZFtiXSYmKGRbYl09YVtiXSk7cmV0dXJueyQkdHlwZW9mOmcsdHlwZTpjLGtleTplLHJlZjpsLHByb3BzOmQsX293bmVyOm0uY3VycmVudH19ZXhwb3J0cy5qc3g9cTtleHBvcnRzLmpzeHM9cTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///251\n')},408:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('/** @license React v17.0.2\n * react.production.min.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nvar l=__webpack_require__(418),n=60103,p=60106;exports.Fragment=60107;exports.StrictMode=60108;exports.Profiler=60114;var q=60109,r=60110,t=60112;exports.Suspense=60113;var u=60115,v=60116;\nif("function"===typeof Symbol&&Symbol.for){var w=Symbol.for;n=w("react.element");p=w("react.portal");exports.Fragment=w("react.fragment");exports.StrictMode=w("react.strict_mode");exports.Profiler=w("react.profiler");q=w("react.provider");r=w("react.context");t=w("react.forward_ref");exports.Suspense=w("react.suspense");u=w("react.memo");v=w("react.lazy")}var x="function"===typeof Symbol&&Symbol.iterator;\nfunction y(a){if(null===a||"object"!==typeof a)return null;a=x&&a[x]||a["@@iterator"];return"function"===typeof a?a:null}function z(a){for(var b="https://reactjs.org/docs/error-decoder.html?invariant="+a,c=1;c<arguments.length;c++)b+="&args[]="+encodeURIComponent(arguments[c]);return"Minified React error #"+a+"; visit "+b+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}\nvar A={isMounted:function(){return!1},enqueueForceUpdate:function(){},enqueueReplaceState:function(){},enqueueSetState:function(){}},B={};function C(a,b,c){this.props=a;this.context=b;this.refs=B;this.updater=c||A}C.prototype.isReactComponent={};C.prototype.setState=function(a,b){if("object"!==typeof a&&"function"!==typeof a&&null!=a)throw Error(z(85));this.updater.enqueueSetState(this,a,b,"setState")};C.prototype.forceUpdate=function(a){this.updater.enqueueForceUpdate(this,a,"forceUpdate")};\nfunction D(){}D.prototype=C.prototype;function E(a,b,c){this.props=a;this.context=b;this.refs=B;this.updater=c||A}var F=E.prototype=new D;F.constructor=E;l(F,C.prototype);F.isPureReactComponent=!0;var G={current:null},H=Object.prototype.hasOwnProperty,I={key:!0,ref:!0,__self:!0,__source:!0};\nfunction J(a,b,c){var e,d={},k=null,h=null;if(null!=b)for(e in void 0!==b.ref&&(h=b.ref),void 0!==b.key&&(k=""+b.key),b)H.call(b,e)&&!I.hasOwnProperty(e)&&(d[e]=b[e]);var g=arguments.length-2;if(1===g)d.children=c;else if(1<g){for(var f=Array(g),m=0;m<g;m++)f[m]=arguments[m+2];d.children=f}if(a&&a.defaultProps)for(e in g=a.defaultProps,g)void 0===d[e]&&(d[e]=g[e]);return{$$typeof:n,type:a,key:k,ref:h,props:d,_owner:G.current}}\nfunction K(a,b){return{$$typeof:n,type:a.type,key:b,ref:a.ref,props:a.props,_owner:a._owner}}function L(a){return"object"===typeof a&&null!==a&&a.$$typeof===n}function escape(a){var b={"=":"=0",":":"=2"};return"$"+a.replace(/[=:]/g,function(a){return b[a]})}var M=/\\/+/g;function N(a,b){return"object"===typeof a&&null!==a&&null!=a.key?escape(""+a.key):b.toString(36)}\nfunction O(a,b,c,e,d){var k=typeof a;if("undefined"===k||"boolean"===k)a=null;var h=!1;if(null===a)h=!0;else switch(k){case "string":case "number":h=!0;break;case "object":switch(a.$$typeof){case n:case p:h=!0}}if(h)return h=a,d=d(h),a=""===e?"."+N(h,0):e,Array.isArray(d)?(c="",null!=a&&(c=a.replace(M,"$&/")+"/"),O(d,b,c,"",function(a){return a})):null!=d&&(L(d)&&(d=K(d,c+(!d.key||h&&h.key===d.key?"":(""+d.key).replace(M,"$&/")+"/")+a)),b.push(d)),1;h=0;e=""===e?".":e+":";if(Array.isArray(a))for(var g=\n0;g<a.length;g++){k=a[g];var f=e+N(k,g);h+=O(k,b,c,f,d)}else if(f=y(a),"function"===typeof f)for(a=f.call(a),g=0;!(k=a.next()).done;)k=k.value,f=e+N(k,g++),h+=O(k,b,c,f,d);else if("object"===k)throw b=""+a,Error(z(31,"[object Object]"===b?"object with keys {"+Object.keys(a).join(", ")+"}":b));return h}function P(a,b,c){if(null==a)return a;var e=[],d=0;O(a,e,"","",function(a){return b.call(c,a,d++)});return e}\nfunction Q(a){if(-1===a._status){var b=a._result;b=b();a._status=0;a._result=b;b.then(function(b){0===a._status&&(b=b.default,a._status=1,a._result=b)},function(b){0===a._status&&(a._status=2,a._result=b)})}if(1===a._status)return a._result;throw a._result;}var R={current:null};function S(){var a=R.current;if(null===a)throw Error(z(321));return a}var T={ReactCurrentDispatcher:R,ReactCurrentBatchConfig:{transition:0},ReactCurrentOwner:G,IsSomeRendererActing:{current:!1},assign:l};\nexports.Children={map:P,forEach:function(a,b,c){P(a,function(){b.apply(this,arguments)},c)},count:function(a){var b=0;P(a,function(){b++});return b},toArray:function(a){return P(a,function(a){return a})||[]},only:function(a){if(!L(a))throw Error(z(143));return a}};exports.Component=C;exports.PureComponent=E;exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=T;\nexports.cloneElement=function(a,b,c){if(null===a||void 0===a)throw Error(z(267,a));var e=l({},a.props),d=a.key,k=a.ref,h=a._owner;if(null!=b){void 0!==b.ref&&(k=b.ref,h=G.current);void 0!==b.key&&(d=""+b.key);if(a.type&&a.type.defaultProps)var g=a.type.defaultProps;for(f in b)H.call(b,f)&&!I.hasOwnProperty(f)&&(e[f]=void 0===b[f]&&void 0!==g?g[f]:b[f])}var f=arguments.length-2;if(1===f)e.children=c;else if(1<f){g=Array(f);for(var m=0;m<f;m++)g[m]=arguments[m+2];e.children=g}return{$$typeof:n,type:a.type,\nkey:d,ref:k,props:e,_owner:h}};exports.createContext=function(a,b){void 0===b&&(b=null);a={$$typeof:r,_calculateChangedBits:b,_currentValue:a,_currentValue2:a,_threadCount:0,Provider:null,Consumer:null};a.Provider={$$typeof:q,_context:a};return a.Consumer=a};exports.createElement=J;exports.createFactory=function(a){var b=J.bind(null,a);b.type=a;return b};exports.createRef=function(){return{current:null}};exports.forwardRef=function(a){return{$$typeof:t,render:a}};exports.isValidElement=L;\nexports.lazy=function(a){return{$$typeof:v,_payload:{_status:-1,_result:a},_init:Q}};exports.memo=function(a,b){return{$$typeof:u,type:a,compare:void 0===b?null:b}};exports.useCallback=function(a,b){return S().useCallback(a,b)};exports.useContext=function(a,b){return S().useContext(a,b)};exports.useDebugValue=function(){};exports.useEffect=function(a,b){return S().useEffect(a,b)};exports.useImperativeHandle=function(a,b,c){return S().useImperativeHandle(a,b,c)};\nexports.useLayoutEffect=function(a,b){return S().useLayoutEffect(a,b)};exports.useMemo=function(a,b){return S().useMemo(a,b)};exports.useReducer=function(a,b,c){return S().useReducer(a,b,c)};exports.useRef=function(a){return S().useRef(a)};exports.useState=function(a){return S().useState(a)};exports.version="17.0.2";\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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Ly9tZGMtcmVhY3QvLi9ub2RlX21vZHVsZXMvcmVhY3QvY2pzL3JlYWN0LnByb2R1Y3Rpb24ubWluLmpzP2JlMjQiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqIEBsaWNlbnNlIFJlYWN0IHYxNy4wLjJcbiAqIHJlYWN0LnByb2R1Y3Rpb24ubWluLmpzXG4gKlxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cbid1c2Ugc3RyaWN0Jzt2YXIgbD1yZXF1aXJlKFwib2JqZWN0LWFzc2lnblwiKSxuPTYwMTAzLHA9NjAxMDY7ZXhwb3J0cy5GcmFnbWVudD02MDEwNztleHBvcnRzLlN0cmljdE1vZGU9NjAxMDg7ZXhwb3J0cy5Qcm9maWxlcj02MDExNDt2YXIgcT02MDEwOSxyPTYwMTEwLHQ9NjAxMTI7ZXhwb3J0cy5TdXNwZW5zZT02MDExMzt2YXIgdT02MDExNSx2PTYwMTE2O1xuaWYoXCJmdW5jdGlvblwiPT09dHlwZW9mIFN5bWJvbCYmU3ltYm9sLmZvcil7dmFyIHc9U3ltYm9sLmZvcjtuPXcoXCJyZWFjdC5lbGVtZW50XCIpO3A9dyhcInJlYWN0LnBvcnRhbFwiKTtleHBvcnRzLkZyYWdtZW50PXcoXCJyZWFjdC5mcmFnbWVudFwiKTtleHBvcnRzLlN0cmljdE1vZGU9dyhcInJlYWN0LnN0cmljdF9tb2RlXCIpO2V4cG9ydHMuUHJvZmlsZXI9dyhcInJlYWN0LnByb2ZpbGVyXCIpO3E9dyhcInJlYWN0LnByb3ZpZGVyXCIpO3I9dyhcInJlYWN0LmNvbnRleHRcIik7dD13KFwicmVhY3QuZm9yd2FyZF9yZWZcIik7ZXhwb3J0cy5TdXNwZW5zZT13KFwicmVhY3Quc3VzcGVuc2VcIik7dT13KFwicmVhY3QubWVtb1wiKTt2PXcoXCJyZWFjdC5sYXp5XCIpfXZhciB4PVwiZnVuY3Rpb25cIj09PXR5cGVvZiBTeW1ib2wmJlN5bWJvbC5pdGVyYXRvcjtcbmZ1bmN0aW9uIHkoYSl7aWYobnVsbD09PWF8fFwib2JqZWN0XCIhPT10eXBlb2YgYSlyZXR1cm4gbnVsbDthPXgmJmFbeF18fGFbXCJAQGl0ZXJhdG9yXCJdO3JldHVyblwiZnVuY3Rpb25cIj09PXR5cGVvZiBhP2E6bnVsbH1mdW5jdGlvbiB6KGEpe2Zvcih2YXIgYj1cImh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9lcnJvci1kZWNvZGVyLmh0bWw/aW52YXJpYW50PVwiK2EsYz0xO2M8YXJndW1lbnRzLmxlbmd0aDtjKyspYis9XCImYXJnc1tdPVwiK2VuY29kZVVSSUNvbXBvbmVudChhcmd1bWVudHNbY10pO3JldHVyblwiTWluaWZpZWQgUmVhY3QgZXJyb3IgI1wiK2ErXCI7IHZpc2l0IFwiK2IrXCIgZm9yIHRoZSBmdWxsIG1lc3NhZ2Ugb3IgdXNlIHRoZSBub24tbWluaWZpZWQgZGV2IGVudmlyb25tZW50IGZvciBmdWxsIGVycm9ycyBhbmQgYWRkaXRpb25hbCBoZWxwZnVsIHdhcm5pbmdzLlwifVxudmFyIEE9e2lzTW91bnRlZDpmdW5jdGlvbigpe3JldHVybiExfSxlbnF1ZXVlRm9yY2VVcGRhdGU6ZnVuY3Rpb24oKXt9LGVucXVldWVSZXBsYWNlU3RhdGU6ZnVuY3Rpb24oKXt9LGVucXVldWVTZXRTdGF0ZTpmdW5jdGlvbigpe319LEI9e307ZnVuY3Rpb24gQyhhLGIsYyl7dGhpcy5wcm9wcz1hO3RoaXMuY29udGV4dD1iO3RoaXMucmVmcz1CO3RoaXMudXBkYXRlcj1jfHxBfUMucHJvdG90eXBlLmlzUmVhY3RDb21wb25lbnQ9e307Qy5wcm90b3R5cGUuc2V0U3RhdGU9ZnVuY3Rpb24oYSxiKXtpZihcIm9iamVjdFwiIT09dHlwZW9mIGEmJlwiZnVuY3Rpb25cIiE9PXR5cGVvZiBhJiZudWxsIT1hKXRocm93IEVycm9yKHooODUpKTt0aGlzLnVwZGF0ZXIuZW5xdWV1ZVNldFN0YXRlKHRoaXMsYSxiLFwic2V0U3RhdGVcIil9O0MucHJvdG90eXBlLmZvcmNlVXBkYXRlPWZ1bmN0aW9uKGEpe3RoaXMudXBkYXRlci5lbnF1ZXVlRm9yY2VVcGRhdGUodGhpcyxhLFwiZm9yY2VVcGRhdGVcIil9O1xuZnVuY3Rpb24gRCgpe31ELnByb3RvdHlwZT1DLnByb3RvdHlwZTtmdW5jdGlvbiBFKGEsYixjKXt0aGlzLnByb3BzPWE7dGhpcy5jb250ZXh0PWI7dGhpcy5yZWZzPUI7dGhpcy51cGRhdGVyPWN8fEF9dmFyIEY9RS5wcm90b3R5cGU9bmV3IEQ7Ri5jb25zdHJ1Y3Rvcj1FO2woRixDLnByb3RvdHlwZSk7Ri5pc1B1cmVSZWFjdENvbXBvbmVudD0hMDt2YXIgRz17Y3VycmVudDpudWxsfSxIPU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHksST17a2V5OiEwLHJlZjohMCxfX3NlbGY6ITAsX19zb3VyY2U6ITB9O1xuZnVuY3Rpb24gSihhLGIsYyl7dmFyIGUsZD17fSxrPW51bGwsaD1udWxsO2lmKG51bGwhPWIpZm9yKGUgaW4gdm9pZCAwIT09Yi5yZWYmJihoPWIucmVmKSx2b2lkIDAhPT1iLmtleSYmKGs9XCJcIitiLmtleSksYilILmNhbGwoYixlKSYmIUkuaGFzT3duUHJvcGVydHkoZSkmJihkW2VdPWJbZV0pO3ZhciBnPWFyZ3VtZW50cy5sZW5ndGgtMjtpZigxPT09ZylkLmNoaWxkcmVuPWM7ZWxzZSBpZigxPGcpe2Zvcih2YXIgZj1BcnJheShnKSxtPTA7bTxnO20rKylmW21dPWFyZ3VtZW50c1ttKzJdO2QuY2hpbGRyZW49Zn1pZihhJiZhLmRlZmF1bHRQcm9wcylmb3IoZSBpbiBnPWEuZGVmYXVsdFByb3BzLGcpdm9pZCAwPT09ZFtlXSYmKGRbZV09Z1tlXSk7cmV0dXJueyQkdHlwZW9mOm4sdHlwZTphLGtleTprLHJlZjpoLHByb3BzOmQsX293bmVyOkcuY3VycmVudH19XG5mdW5jdGlvbiBLKGEsYil7cmV0dXJueyQkdHlwZW9mOm4sdHlwZTphLnR5cGUsa2V5OmIscmVmOmEucmVmLHByb3BzOmEucHJvcHMsX293bmVyOmEuX293bmVyfX1mdW5jdGlvbiBMKGEpe3JldHVyblwib2JqZWN0XCI9PT10eXBlb2YgYSYmbnVsbCE9PWEmJmEuJCR0eXBlb2Y9PT1ufWZ1bmN0aW9uIGVzY2FwZShhKXt2YXIgYj17XCI9XCI6XCI9MFwiLFwiOlwiOlwiPTJcIn07cmV0dXJuXCIkXCIrYS5yZXBsYWNlKC9bPTpdL2csZnVuY3Rpb24oYSl7cmV0dXJuIGJbYV19KX12YXIgTT0vXFwvKy9nO2Z1bmN0aW9uIE4oYSxiKXtyZXR1cm5cIm9iamVjdFwiPT09dHlwZW9mIGEmJm51bGwhPT1hJiZudWxsIT1hLmtleT9lc2NhcGUoXCJcIithLmtleSk6Yi50b1N0cmluZygzNil9XG5mdW5jdGlvbiBPKGEsYixjLGUsZCl7dmFyIGs9dHlwZW9mIGE7aWYoXCJ1bmRlZmluZWRcIj09PWt8fFwiYm9vbGVhblwiPT09aylhPW51bGw7dmFyIGg9ITE7aWYobnVsbD09PWEpaD0hMDtlbHNlIHN3aXRjaChrKXtjYXNlIFwic3RyaW5nXCI6Y2FzZSBcIm51bWJlclwiOmg9ITA7YnJlYWs7Y2FzZSBcIm9iamVjdFwiOnN3aXRjaChhLiQkdHlwZW9mKXtjYXNlIG46Y2FzZSBwOmg9ITB9fWlmKGgpcmV0dXJuIGg9YSxkPWQoaCksYT1cIlwiPT09ZT9cIi5cIitOKGgsMCk6ZSxBcnJheS5pc0FycmF5KGQpPyhjPVwiXCIsbnVsbCE9YSYmKGM9YS5yZXBsYWNlKE0sXCIkJi9cIikrXCIvXCIpLE8oZCxiLGMsXCJcIixmdW5jdGlvbihhKXtyZXR1cm4gYX0pKTpudWxsIT1kJiYoTChkKSYmKGQ9SyhkLGMrKCFkLmtleXx8aCYmaC5rZXk9PT1kLmtleT9cIlwiOihcIlwiK2Qua2V5KS5yZXBsYWNlKE0sXCIkJi9cIikrXCIvXCIpK2EpKSxiLnB1c2goZCkpLDE7aD0wO2U9XCJcIj09PWU/XCIuXCI6ZStcIjpcIjtpZihBcnJheS5pc0FycmF5KGEpKWZvcih2YXIgZz1cbjA7ZzxhLmxlbmd0aDtnKyspe2s9YVtnXTt2YXIgZj1lK04oayxnKTtoKz1PKGssYixjLGYsZCl9ZWxzZSBpZihmPXkoYSksXCJmdW5jdGlvblwiPT09dHlwZW9mIGYpZm9yKGE9Zi5jYWxsKGEpLGc9MDshKGs9YS5uZXh0KCkpLmRvbmU7KWs9ay52YWx1ZSxmPWUrTihrLGcrKyksaCs9TyhrLGIsYyxmLGQpO2Vsc2UgaWYoXCJvYmplY3RcIj09PWspdGhyb3cgYj1cIlwiK2EsRXJyb3IoeigzMSxcIltvYmplY3QgT2JqZWN0XVwiPT09Yj9cIm9iamVjdCB3aXRoIGtleXMge1wiK09iamVjdC5rZXlzKGEpLmpvaW4oXCIsIFwiKStcIn1cIjpiKSk7cmV0dXJuIGh9ZnVuY3Rpb24gUChhLGIsYyl7aWYobnVsbD09YSlyZXR1cm4gYTt2YXIgZT1bXSxkPTA7TyhhLGUsXCJcIixcIlwiLGZ1bmN0aW9uKGEpe3JldHVybiBiLmNhbGwoYyxhLGQrKyl9KTtyZXR1cm4gZX1cbmZ1bmN0aW9uIFEoYSl7aWYoLTE9PT1hLl9zdGF0dXMpe3ZhciBiPWEuX3Jlc3VsdDtiPWIoKTthLl9zdGF0dXM9MDthLl9yZXN1bHQ9YjtiLnRoZW4oZnVuY3Rpb24oYil7MD09PWEuX3N0YXR1cyYmKGI9Yi5kZWZhdWx0LGEuX3N0YXR1cz0xLGEuX3Jlc3VsdD1iKX0sZnVuY3Rpb24oYil7MD09PWEuX3N0YXR1cyYmKGEuX3N0YXR1cz0yLGEuX3Jlc3VsdD1iKX0pfWlmKDE9PT1hLl9zdGF0dXMpcmV0dXJuIGEuX3Jlc3VsdDt0aHJvdyBhLl9yZXN1bHQ7fXZhciBSPXtjdXJyZW50Om51bGx9O2Z1bmN0aW9uIFMoKXt2YXIgYT1SLmN1cnJlbnQ7aWYobnVsbD09PWEpdGhyb3cgRXJyb3IoeigzMjEpKTtyZXR1cm4gYX12YXIgVD17UmVhY3RDdXJyZW50RGlzcGF0Y2hlcjpSLFJlYWN0Q3VycmVudEJhdGNoQ29uZmlnOnt0cmFuc2l0aW9uOjB9LFJlYWN0Q3VycmVudE93bmVyOkcsSXNTb21lUmVuZGVyZXJBY3Rpbmc6e2N1cnJlbnQ6ITF9LGFzc2lnbjpsfTtcbmV4cG9ydHMuQ2hpbGRyZW49e21hcDpQLGZvckVhY2g6ZnVuY3Rpb24oYSxiLGMpe1AoYSxmdW5jdGlvbigpe2IuYXBwbHkodGhpcyxhcmd1bWVudHMpfSxjKX0sY291bnQ6ZnVuY3Rpb24oYSl7dmFyIGI9MDtQKGEsZnVuY3Rpb24oKXtiKyt9KTtyZXR1cm4gYn0sdG9BcnJheTpmdW5jdGlvbihhKXtyZXR1cm4gUChhLGZ1bmN0aW9uKGEpe3JldHVybiBhfSl8fFtdfSxvbmx5OmZ1bmN0aW9uKGEpe2lmKCFMKGEpKXRocm93IEVycm9yKHooMTQzKSk7cmV0dXJuIGF9fTtleHBvcnRzLkNvbXBvbmVudD1DO2V4cG9ydHMuUHVyZUNvbXBvbmVudD1FO2V4cG9ydHMuX19TRUNSRVRfSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfWU9VX1dJTExfQkVfRklSRUQ9VDtcbmV4cG9ydHMuY2xvbmVFbGVtZW50PWZ1bmN0aW9uKGEsYixjKXtpZihudWxsPT09YXx8dm9pZCAwPT09YSl0aHJvdyBFcnJvcih6KDI2NyxhKSk7dmFyIGU9bCh7fSxhLnByb3BzKSxkPWEua2V5LGs9YS5yZWYsaD1hLl9vd25lcjtpZihudWxsIT1iKXt2b2lkIDAhPT1iLnJlZiYmKGs9Yi5yZWYsaD1HLmN1cnJlbnQpO3ZvaWQgMCE9PWIua2V5JiYoZD1cIlwiK2Iua2V5KTtpZihhLnR5cGUmJmEudHlwZS5kZWZhdWx0UHJvcHMpdmFyIGc9YS50eXBlLmRlZmF1bHRQcm9wcztmb3IoZiBpbiBiKUguY2FsbChiLGYpJiYhSS5oYXNPd25Qcm9wZXJ0eShmKSYmKGVbZl09dm9pZCAwPT09YltmXSYmdm9pZCAwIT09Zz9nW2ZdOmJbZl0pfXZhciBmPWFyZ3VtZW50cy5sZW5ndGgtMjtpZigxPT09ZillLmNoaWxkcmVuPWM7ZWxzZSBpZigxPGYpe2c9QXJyYXkoZik7Zm9yKHZhciBtPTA7bTxmO20rKylnW21dPWFyZ3VtZW50c1ttKzJdO2UuY2hpbGRyZW49Z31yZXR1cm57JCR0eXBlb2Y6bix0eXBlOmEudHlwZSxcbmtleTpkLHJlZjprLHByb3BzOmUsX293bmVyOmh9fTtleHBvcnRzLmNyZWF0ZUNvbnRleHQ9ZnVuY3Rpb24oYSxiKXt2b2lkIDA9PT1iJiYoYj1udWxsKTthPXskJHR5cGVvZjpyLF9jYWxjdWxhdGVDaGFuZ2VkQml0czpiLF9jdXJyZW50VmFsdWU6YSxfY3VycmVudFZhbHVlMjphLF90aHJlYWRDb3VudDowLFByb3ZpZGVyOm51bGwsQ29uc3VtZXI6bnVsbH07YS5Qcm92aWRlcj17JCR0eXBlb2Y6cSxfY29udGV4dDphfTtyZXR1cm4gYS5Db25zdW1lcj1hfTtleHBvcnRzLmNyZWF0ZUVsZW1lbnQ9SjtleHBvcnRzLmNyZWF0ZUZhY3Rvcnk9ZnVuY3Rpb24oYSl7dmFyIGI9Si5iaW5kKG51bGwsYSk7Yi50eXBlPWE7cmV0dXJuIGJ9O2V4cG9ydHMuY3JlYXRlUmVmPWZ1bmN0aW9uKCl7cmV0dXJue2N1cnJlbnQ6bnVsbH19O2V4cG9ydHMuZm9yd2FyZFJlZj1mdW5jdGlvbihhKXtyZXR1cm57JCR0eXBlb2Y6dCxyZW5kZXI6YX19O2V4cG9ydHMuaXNWYWxpZEVsZW1lbnQ9TDtcbmV4cG9ydHMubGF6eT1mdW5jdGlvbihhKXtyZXR1cm57JCR0eXBlb2Y6dixfcGF5bG9hZDp7X3N0YXR1czotMSxfcmVzdWx0OmF9LF9pbml0OlF9fTtleHBvcnRzLm1lbW89ZnVuY3Rpb24oYSxiKXtyZXR1cm57JCR0eXBlb2Y6dSx0eXBlOmEsY29tcGFyZTp2b2lkIDA9PT1iP251bGw6Yn19O2V4cG9ydHMudXNlQ2FsbGJhY2s9ZnVuY3Rpb24oYSxiKXtyZXR1cm4gUygpLnVzZUNhbGxiYWNrKGEsYil9O2V4cG9ydHMudXNlQ29udGV4dD1mdW5jdGlvbihhLGIpe3JldHVybiBTKCkudXNlQ29udGV4dChhLGIpfTtleHBvcnRzLnVzZURlYnVnVmFsdWU9ZnVuY3Rpb24oKXt9O2V4cG9ydHMudXNlRWZmZWN0PWZ1bmN0aW9uKGEsYil7cmV0dXJuIFMoKS51c2VFZmZlY3QoYSxiKX07ZXhwb3J0cy51c2VJbXBlcmF0aXZlSGFuZGxlPWZ1bmN0aW9uKGEsYixjKXtyZXR1cm4gUygpLnVzZUltcGVyYXRpdmVIYW5kbGUoYSxiLGMpfTtcbmV4cG9ydHMudXNlTGF5b3V0RWZmZWN0PWZ1bmN0aW9uKGEsYil7cmV0dXJuIFMoKS51c2VMYXlvdXRFZmZlY3QoYSxiKX07ZXhwb3J0cy51c2VNZW1vPWZ1bmN0aW9uKGEsYil7cmV0dXJuIFMoKS51c2VNZW1vKGEsYil9O2V4cG9ydHMudXNlUmVkdWNlcj1mdW5jdGlvbihhLGIsYyl7cmV0dXJuIFMoKS51c2VSZWR1Y2VyKGEsYixjKX07ZXhwb3J0cy51c2VSZWY9ZnVuY3Rpb24oYSl7cmV0dXJuIFMoKS51c2VSZWYoYSl9O2V4cG9ydHMudXNlU3RhdGU9ZnVuY3Rpb24oYSl7cmV0dXJuIFMoKS51c2VTdGF0ZShhKX07ZXhwb3J0cy52ZXJzaW9uPVwiMTcuMC4yXCI7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///408\n')},294:(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("\n\nif (true) {\n  module.exports = __webpack_require__(408);\n} else {}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjk0LmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLElBQUksSUFBcUM7QUFDekMsRUFBRSx5Q0FBeUQ7QUFDM0QsRUFBRSxLQUFLLEVBRU4iLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9ub2RlX21vZHVsZXMvcmVhY3QvaW5kZXguanM/YWI1YiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QucHJvZHVjdGlvbi5taW4uanMnKTtcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QuZGV2ZWxvcG1lbnQuanMnKTtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///294\n")},893:(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("\n\nif (true) {\n  module.exports = __webpack_require__(251);\n} else {}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODkzLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLElBQUksSUFBcUM7QUFDekMsRUFBRSx5Q0FBcUU7QUFDdkUsRUFBRSxLQUFLLEVBRU4iLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9ub2RlX21vZHVsZXMvcmVhY3QvanN4LXJ1bnRpbWUuanM/OWNhNSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtanN4LXJ1bnRpbWUucHJvZHVjdGlvbi5taW4uanMnKTtcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtanN4LXJ1bnRpbWUuZGV2ZWxvcG1lbnQuanMnKTtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///893\n")},53:(__unused_webpack_module,exports)=>{"use strict";eval('/** @license React v0.20.2\n * scheduler.production.min.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nvar f,g,h,k;if("object"===typeof performance&&"function"===typeof performance.now){var l=performance;exports.unstable_now=function(){return l.now()}}else{var p=Date,q=p.now();exports.unstable_now=function(){return p.now()-q}}\nif("undefined"===typeof window||"function"!==typeof MessageChannel){var t=null,u=null,w=function(){if(null!==t)try{var a=exports.unstable_now();t(!0,a);t=null}catch(b){throw setTimeout(w,0),b;}};f=function(a){null!==t?setTimeout(f,0,a):(t=a,setTimeout(w,0))};g=function(a,b){u=setTimeout(a,b)};h=function(){clearTimeout(u)};exports.unstable_shouldYield=function(){return!1};k=exports.unstable_forceFrameRate=function(){}}else{var x=window.setTimeout,y=window.clearTimeout;if("undefined"!==typeof console){var z=\nwindow.cancelAnimationFrame;"function"!==typeof window.requestAnimationFrame&&console.error("This browser doesn\'t support requestAnimationFrame. Make sure that you load a polyfill in older browsers. https://reactjs.org/link/react-polyfills");"function"!==typeof z&&console.error("This browser doesn\'t support cancelAnimationFrame. Make sure that you load a polyfill in older browsers. https://reactjs.org/link/react-polyfills")}var A=!1,B=null,C=-1,D=5,E=0;exports.unstable_shouldYield=function(){return exports.unstable_now()>=\nE};k=function(){};exports.unstable_forceFrameRate=function(a){0>a||125<a?console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"):D=0<a?Math.floor(1E3/a):5};var F=new MessageChannel,G=F.port2;F.port1.onmessage=function(){if(null!==B){var a=exports.unstable_now();E=a+D;try{B(!0,a)?G.postMessage(null):(A=!1,B=null)}catch(b){throw G.postMessage(null),b;}}else A=!1};f=function(a){B=a;A||(A=!0,G.postMessage(null))};g=function(a,b){C=\nx(function(){a(exports.unstable_now())},b)};h=function(){y(C);C=-1}}function H(a,b){var c=a.length;a.push(b);a:for(;;){var d=c-1>>>1,e=a[d];if(void 0!==e&&0<I(e,b))a[d]=b,a[c]=e,c=d;else break a}}function J(a){a=a[0];return void 0===a?null:a}\nfunction K(a){var b=a[0];if(void 0!==b){var c=a.pop();if(c!==b){a[0]=c;a:for(var d=0,e=a.length;d<e;){var m=2*(d+1)-1,n=a[m],v=m+1,r=a[v];if(void 0!==n&&0>I(n,c))void 0!==r&&0>I(r,n)?(a[d]=r,a[v]=c,d=v):(a[d]=n,a[m]=c,d=m);else if(void 0!==r&&0>I(r,c))a[d]=r,a[v]=c,d=v;else break a}}return b}return null}function I(a,b){var c=a.sortIndex-b.sortIndex;return 0!==c?c:a.id-b.id}var L=[],M=[],N=1,O=null,P=3,Q=!1,R=!1,S=!1;\nfunction T(a){for(var b=J(M);null!==b;){if(null===b.callback)K(M);else if(b.startTime<=a)K(M),b.sortIndex=b.expirationTime,H(L,b);else break;b=J(M)}}function U(a){S=!1;T(a);if(!R)if(null!==J(L))R=!0,f(V);else{var b=J(M);null!==b&&g(U,b.startTime-a)}}\nfunction V(a,b){R=!1;S&&(S=!1,h());Q=!0;var c=P;try{T(b);for(O=J(L);null!==O&&(!(O.expirationTime>b)||a&&!exports.unstable_shouldYield());){var d=O.callback;if("function"===typeof d){O.callback=null;P=O.priorityLevel;var e=d(O.expirationTime<=b);b=exports.unstable_now();"function"===typeof e?O.callback=e:O===J(L)&&K(L);T(b)}else K(L);O=J(L)}if(null!==O)var m=!0;else{var n=J(M);null!==n&&g(U,n.startTime-b);m=!1}return m}finally{O=null,P=c,Q=!1}}var W=k;exports.unstable_IdlePriority=5;\nexports.unstable_ImmediatePriority=1;exports.unstable_LowPriority=4;exports.unstable_NormalPriority=3;exports.unstable_Profiling=null;exports.unstable_UserBlockingPriority=2;exports.unstable_cancelCallback=function(a){a.callback=null};exports.unstable_continueExecution=function(){R||Q||(R=!0,f(V))};exports.unstable_getCurrentPriorityLevel=function(){return P};exports.unstable_getFirstCallbackNode=function(){return J(L)};\nexports.unstable_next=function(a){switch(P){case 1:case 2:case 3:var b=3;break;default:b=P}var c=P;P=b;try{return a()}finally{P=c}};exports.unstable_pauseExecution=function(){};exports.unstable_requestPaint=W;exports.unstable_runWithPriority=function(a,b){switch(a){case 1:case 2:case 3:case 4:case 5:break;default:a=3}var c=P;P=a;try{return b()}finally{P=c}};\nexports.unstable_scheduleCallback=function(a,b,c){var d=exports.unstable_now();"object"===typeof c&&null!==c?(c=c.delay,c="number"===typeof c&&0<c?d+c:d):c=d;switch(a){case 1:var e=-1;break;case 2:e=250;break;case 5:e=1073741823;break;case 4:e=1E4;break;default:e=5E3}e=c+e;a={id:N++,callback:b,priorityLevel:a,startTime:c,expirationTime:e,sortIndex:-1};c>d?(a.sortIndex=c,H(M,a),null===J(L)&&a===J(M)&&(S?h():S=!0,g(U,c-d))):(a.sortIndex=e,H(L,a),R||Q||(R=!0,f(V)));return a};\nexports.unstable_wrapCallback=function(a){var b=P;return function(){var c=P;P=b;try{return a.apply(this,arguments)}finally{P=c}}};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNhLFlBQVksdUVBQXVFLGtCQUFrQixvQkFBb0IsWUFBWSxnQkFBZ0IsS0FBSyxxQkFBcUIsb0JBQW9CLFlBQVk7QUFDNU4sb0VBQW9FLCtCQUErQixnQkFBZ0IsNkJBQTZCLFFBQVEsT0FBTyxTQUFTLDJCQUEyQixjQUFjLGtEQUFrRCxnQkFBZ0IsbUJBQW1CLGFBQWEsaUJBQWlCLDRCQUE0QixZQUFZLFVBQVUsRUFBRSwrQkFBK0IsY0FBYyxLQUFLLDhDQUE4QyxpQ0FBaUM7QUFDemYsNEJBQTRCLHNOQUFzTiwwTEFBMEwsNkJBQTZCLDRCQUE0QixZQUFZO0FBQ2pmLEdBQUcsZUFBZSwrQkFBK0IsYUFBYSx1S0FBdUssbUNBQW1DLDZCQUE2QixhQUFhLDZCQUE2QixNQUFNLElBQUksMENBQTBDLFNBQVMsOEJBQThCLFdBQVcsY0FBYyxJQUFJLCtCQUErQixnQkFBZ0I7QUFDdGYsYUFBYSwwQkFBMEIsS0FBSyxhQUFhLEtBQUssTUFBTSxnQkFBZ0IsZUFBZSxVQUFVLFFBQVEsRUFBRSxxQkFBcUIsMENBQTBDLGNBQWMsY0FBYyxPQUFPO0FBQ3pOLGNBQWMsV0FBVyxlQUFlLGNBQWMsVUFBVSxPQUFPLHlCQUF5QixJQUFJLEVBQUUsb0NBQW9DLHFGQUFxRiwrQ0FBK0MsY0FBYyxTQUFTLFlBQVksZ0JBQWdCLDhCQUE4Qix5QkFBeUI7QUFDeFgsY0FBYyxlQUFlLFNBQVMsRUFBRSwwQkFBMEIsZ0VBQWdFLFdBQVcsUUFBUSxjQUFjLEtBQUssS0FBSywrQkFBK0IsS0FBSyxXQUFXO0FBQzVOLGdCQUFnQixLQUFLLGNBQWMsS0FBSyxRQUFRLElBQUksS0FBSyxXQUFXLHNFQUFzRSxFQUFFLGlCQUFpQiwwQkFBMEIsZ0JBQWdCLGtCQUFrQiw2QkFBNkIseUJBQXlCLGtEQUFrRCxLQUFLLFVBQVUsT0FBTyxxQkFBcUIsS0FBSyxXQUFXLDZCQUE2QixLQUFLLFNBQVMsUUFBUSxpQkFBaUIsUUFBUSw2QkFBNkI7QUFDcmUsa0NBQWtDLEdBQUcsNEJBQTRCLEdBQUcsK0JBQStCLEdBQUcsMEJBQTBCLE1BQU0scUNBQXFDLEdBQUcsK0JBQStCLGFBQWEsaUJBQWlCLGtDQUFrQyxZQUFZLG1CQUFtQix3Q0FBd0MsWUFBWSxVQUFVLHFDQUFxQyxZQUFZO0FBQzNaLHFCQUFxQixhQUFhLFVBQVUsNkJBQTZCLE1BQU0sWUFBWSxRQUFRLElBQUksSUFBSSxXQUFXLFFBQVEsTUFBTSwrQkFBK0IsY0FBYyw2QkFBNkIsR0FBRyxnQ0FBZ0MsZUFBZSxVQUFVLHlDQUF5QyxZQUFZLFFBQVEsSUFBSSxJQUFJLFdBQVcsUUFBUTtBQUNsVyxpQ0FBaUMsaUJBQWlCLDZCQUE2QiwrRUFBK0UsVUFBVSxnQkFBZ0IsTUFBTSxhQUFhLE1BQU0sb0JBQW9CLE1BQU0sYUFBYSxNQUFNLGNBQWMsTUFBTSxHQUFHLDZFQUE2RSxpSEFBaUg7QUFDbmQsNkJBQTZCLGFBQWEsUUFBUSxrQkFBa0IsUUFBUSxJQUFJLElBQUksK0JBQStCLFFBQVEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9ub2RlX21vZHVsZXMvc2NoZWR1bGVyL2Nqcy9zY2hlZHVsZXIucHJvZHVjdGlvbi5taW4uanM/ZmIwNyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiogQGxpY2Vuc2UgUmVhY3QgdjAuMjAuMlxuICogc2NoZWR1bGVyLnByb2R1Y3Rpb24ubWluLmpzXG4gKlxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cbid1c2Ugc3RyaWN0Jzt2YXIgZixnLGgsaztpZihcIm9iamVjdFwiPT09dHlwZW9mIHBlcmZvcm1hbmNlJiZcImZ1bmN0aW9uXCI9PT10eXBlb2YgcGVyZm9ybWFuY2Uubm93KXt2YXIgbD1wZXJmb3JtYW5jZTtleHBvcnRzLnVuc3RhYmxlX25vdz1mdW5jdGlvbigpe3JldHVybiBsLm5vdygpfX1lbHNle3ZhciBwPURhdGUscT1wLm5vdygpO2V4cG9ydHMudW5zdGFibGVfbm93PWZ1bmN0aW9uKCl7cmV0dXJuIHAubm93KCktcX19XG5pZihcInVuZGVmaW5lZFwiPT09dHlwZW9mIHdpbmRvd3x8XCJmdW5jdGlvblwiIT09dHlwZW9mIE1lc3NhZ2VDaGFubmVsKXt2YXIgdD1udWxsLHU9bnVsbCx3PWZ1bmN0aW9uKCl7aWYobnVsbCE9PXQpdHJ5e3ZhciBhPWV4cG9ydHMudW5zdGFibGVfbm93KCk7dCghMCxhKTt0PW51bGx9Y2F0Y2goYil7dGhyb3cgc2V0VGltZW91dCh3LDApLGI7fX07Zj1mdW5jdGlvbihhKXtudWxsIT09dD9zZXRUaW1lb3V0KGYsMCxhKToodD1hLHNldFRpbWVvdXQodywwKSl9O2c9ZnVuY3Rpb24oYSxiKXt1PXNldFRpbWVvdXQoYSxiKX07aD1mdW5jdGlvbigpe2NsZWFyVGltZW91dCh1KX07ZXhwb3J0cy51bnN0YWJsZV9zaG91bGRZaWVsZD1mdW5jdGlvbigpe3JldHVybiExfTtrPWV4cG9ydHMudW5zdGFibGVfZm9yY2VGcmFtZVJhdGU9ZnVuY3Rpb24oKXt9fWVsc2V7dmFyIHg9d2luZG93LnNldFRpbWVvdXQseT13aW5kb3cuY2xlYXJUaW1lb3V0O2lmKFwidW5kZWZpbmVkXCIhPT10eXBlb2YgY29uc29sZSl7dmFyIHo9XG53aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWU7XCJmdW5jdGlvblwiIT09dHlwZW9mIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUmJmNvbnNvbGUuZXJyb3IoXCJUaGlzIGJyb3dzZXIgZG9lc24ndCBzdXBwb3J0IHJlcXVlc3RBbmltYXRpb25GcmFtZS4gTWFrZSBzdXJlIHRoYXQgeW91IGxvYWQgYSBwb2x5ZmlsbCBpbiBvbGRlciBicm93c2Vycy4gaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3JlYWN0LXBvbHlmaWxsc1wiKTtcImZ1bmN0aW9uXCIhPT10eXBlb2YgeiYmY29uc29sZS5lcnJvcihcIlRoaXMgYnJvd3NlciBkb2Vzbid0IHN1cHBvcnQgY2FuY2VsQW5pbWF0aW9uRnJhbWUuIE1ha2Ugc3VyZSB0aGF0IHlvdSBsb2FkIGEgcG9seWZpbGwgaW4gb2xkZXIgYnJvd3NlcnMuIGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9yZWFjdC1wb2x5ZmlsbHNcIil9dmFyIEE9ITEsQj1udWxsLEM9LTEsRD01LEU9MDtleHBvcnRzLnVuc3RhYmxlX3Nob3VsZFlpZWxkPWZ1bmN0aW9uKCl7cmV0dXJuIGV4cG9ydHMudW5zdGFibGVfbm93KCk+PVxuRX07az1mdW5jdGlvbigpe307ZXhwb3J0cy51bnN0YWJsZV9mb3JjZUZyYW1lUmF0ZT1mdW5jdGlvbihhKXswPmF8fDEyNTxhP2NvbnNvbGUuZXJyb3IoXCJmb3JjZUZyYW1lUmF0ZSB0YWtlcyBhIHBvc2l0aXZlIGludCBiZXR3ZWVuIDAgYW5kIDEyNSwgZm9yY2luZyBmcmFtZSByYXRlcyBoaWdoZXIgdGhhbiAxMjUgZnBzIGlzIG5vdCBzdXBwb3J0ZWRcIik6RD0wPGE/TWF0aC5mbG9vcigxRTMvYSk6NX07dmFyIEY9bmV3IE1lc3NhZ2VDaGFubmVsLEc9Ri5wb3J0MjtGLnBvcnQxLm9ubWVzc2FnZT1mdW5jdGlvbigpe2lmKG51bGwhPT1CKXt2YXIgYT1leHBvcnRzLnVuc3RhYmxlX25vdygpO0U9YStEO3RyeXtCKCEwLGEpP0cucG9zdE1lc3NhZ2UobnVsbCk6KEE9ITEsQj1udWxsKX1jYXRjaChiKXt0aHJvdyBHLnBvc3RNZXNzYWdlKG51bGwpLGI7fX1lbHNlIEE9ITF9O2Y9ZnVuY3Rpb24oYSl7Qj1hO0F8fChBPSEwLEcucG9zdE1lc3NhZ2UobnVsbCkpfTtnPWZ1bmN0aW9uKGEsYil7Qz1cbngoZnVuY3Rpb24oKXthKGV4cG9ydHMudW5zdGFibGVfbm93KCkpfSxiKX07aD1mdW5jdGlvbigpe3koQyk7Qz0tMX19ZnVuY3Rpb24gSChhLGIpe3ZhciBjPWEubGVuZ3RoO2EucHVzaChiKTthOmZvcig7Oyl7dmFyIGQ9Yy0xPj4+MSxlPWFbZF07aWYodm9pZCAwIT09ZSYmMDxJKGUsYikpYVtkXT1iLGFbY109ZSxjPWQ7ZWxzZSBicmVhayBhfX1mdW5jdGlvbiBKKGEpe2E9YVswXTtyZXR1cm4gdm9pZCAwPT09YT9udWxsOmF9XG5mdW5jdGlvbiBLKGEpe3ZhciBiPWFbMF07aWYodm9pZCAwIT09Yil7dmFyIGM9YS5wb3AoKTtpZihjIT09Yil7YVswXT1jO2E6Zm9yKHZhciBkPTAsZT1hLmxlbmd0aDtkPGU7KXt2YXIgbT0yKihkKzEpLTEsbj1hW21dLHY9bSsxLHI9YVt2XTtpZih2b2lkIDAhPT1uJiYwPkkobixjKSl2b2lkIDAhPT1yJiYwPkkocixuKT8oYVtkXT1yLGFbdl09YyxkPXYpOihhW2RdPW4sYVttXT1jLGQ9bSk7ZWxzZSBpZih2b2lkIDAhPT1yJiYwPkkocixjKSlhW2RdPXIsYVt2XT1jLGQ9djtlbHNlIGJyZWFrIGF9fXJldHVybiBifXJldHVybiBudWxsfWZ1bmN0aW9uIEkoYSxiKXt2YXIgYz1hLnNvcnRJbmRleC1iLnNvcnRJbmRleDtyZXR1cm4gMCE9PWM/YzphLmlkLWIuaWR9dmFyIEw9W10sTT1bXSxOPTEsTz1udWxsLFA9MyxRPSExLFI9ITEsUz0hMTtcbmZ1bmN0aW9uIFQoYSl7Zm9yKHZhciBiPUooTSk7bnVsbCE9PWI7KXtpZihudWxsPT09Yi5jYWxsYmFjaylLKE0pO2Vsc2UgaWYoYi5zdGFydFRpbWU8PWEpSyhNKSxiLnNvcnRJbmRleD1iLmV4cGlyYXRpb25UaW1lLEgoTCxiKTtlbHNlIGJyZWFrO2I9SihNKX19ZnVuY3Rpb24gVShhKXtTPSExO1QoYSk7aWYoIVIpaWYobnVsbCE9PUooTCkpUj0hMCxmKFYpO2Vsc2V7dmFyIGI9SihNKTtudWxsIT09YiYmZyhVLGIuc3RhcnRUaW1lLWEpfX1cbmZ1bmN0aW9uIFYoYSxiKXtSPSExO1MmJihTPSExLGgoKSk7UT0hMDt2YXIgYz1QO3RyeXtUKGIpO2ZvcihPPUooTCk7bnVsbCE9PU8mJighKE8uZXhwaXJhdGlvblRpbWU+Yil8fGEmJiFleHBvcnRzLnVuc3RhYmxlX3Nob3VsZFlpZWxkKCkpOyl7dmFyIGQ9Ty5jYWxsYmFjaztpZihcImZ1bmN0aW9uXCI9PT10eXBlb2YgZCl7Ty5jYWxsYmFjaz1udWxsO1A9Ty5wcmlvcml0eUxldmVsO3ZhciBlPWQoTy5leHBpcmF0aW9uVGltZTw9Yik7Yj1leHBvcnRzLnVuc3RhYmxlX25vdygpO1wiZnVuY3Rpb25cIj09PXR5cGVvZiBlP08uY2FsbGJhY2s9ZTpPPT09SihMKSYmSyhMKTtUKGIpfWVsc2UgSyhMKTtPPUooTCl9aWYobnVsbCE9PU8pdmFyIG09ITA7ZWxzZXt2YXIgbj1KKE0pO251bGwhPT1uJiZnKFUsbi5zdGFydFRpbWUtYik7bT0hMX1yZXR1cm4gbX1maW5hbGx5e089bnVsbCxQPWMsUT0hMX19dmFyIFc9aztleHBvcnRzLnVuc3RhYmxlX0lkbGVQcmlvcml0eT01O1xuZXhwb3J0cy51bnN0YWJsZV9JbW1lZGlhdGVQcmlvcml0eT0xO2V4cG9ydHMudW5zdGFibGVfTG93UHJpb3JpdHk9NDtleHBvcnRzLnVuc3RhYmxlX05vcm1hbFByaW9yaXR5PTM7ZXhwb3J0cy51bnN0YWJsZV9Qcm9maWxpbmc9bnVsbDtleHBvcnRzLnVuc3RhYmxlX1VzZXJCbG9ja2luZ1ByaW9yaXR5PTI7ZXhwb3J0cy51bnN0YWJsZV9jYW5jZWxDYWxsYmFjaz1mdW5jdGlvbihhKXthLmNhbGxiYWNrPW51bGx9O2V4cG9ydHMudW5zdGFibGVfY29udGludWVFeGVjdXRpb249ZnVuY3Rpb24oKXtSfHxRfHwoUj0hMCxmKFYpKX07ZXhwb3J0cy51bnN0YWJsZV9nZXRDdXJyZW50UHJpb3JpdHlMZXZlbD1mdW5jdGlvbigpe3JldHVybiBQfTtleHBvcnRzLnVuc3RhYmxlX2dldEZpcnN0Q2FsbGJhY2tOb2RlPWZ1bmN0aW9uKCl7cmV0dXJuIEooTCl9O1xuZXhwb3J0cy51bnN0YWJsZV9uZXh0PWZ1bmN0aW9uKGEpe3N3aXRjaChQKXtjYXNlIDE6Y2FzZSAyOmNhc2UgMzp2YXIgYj0zO2JyZWFrO2RlZmF1bHQ6Yj1QfXZhciBjPVA7UD1iO3RyeXtyZXR1cm4gYSgpfWZpbmFsbHl7UD1jfX07ZXhwb3J0cy51bnN0YWJsZV9wYXVzZUV4ZWN1dGlvbj1mdW5jdGlvbigpe307ZXhwb3J0cy51bnN0YWJsZV9yZXF1ZXN0UGFpbnQ9VztleHBvcnRzLnVuc3RhYmxlX3J1bldpdGhQcmlvcml0eT1mdW5jdGlvbihhLGIpe3N3aXRjaChhKXtjYXNlIDE6Y2FzZSAyOmNhc2UgMzpjYXNlIDQ6Y2FzZSA1OmJyZWFrO2RlZmF1bHQ6YT0zfXZhciBjPVA7UD1hO3RyeXtyZXR1cm4gYigpfWZpbmFsbHl7UD1jfX07XG5leHBvcnRzLnVuc3RhYmxlX3NjaGVkdWxlQ2FsbGJhY2s9ZnVuY3Rpb24oYSxiLGMpe3ZhciBkPWV4cG9ydHMudW5zdGFibGVfbm93KCk7XCJvYmplY3RcIj09PXR5cGVvZiBjJiZudWxsIT09Yz8oYz1jLmRlbGF5LGM9XCJudW1iZXJcIj09PXR5cGVvZiBjJiYwPGM/ZCtjOmQpOmM9ZDtzd2l0Y2goYSl7Y2FzZSAxOnZhciBlPS0xO2JyZWFrO2Nhc2UgMjplPTI1MDticmVhaztjYXNlIDU6ZT0xMDczNzQxODIzO2JyZWFrO2Nhc2UgNDplPTFFNDticmVhaztkZWZhdWx0OmU9NUUzfWU9YytlO2E9e2lkOk4rKyxjYWxsYmFjazpiLHByaW9yaXR5TGV2ZWw6YSxzdGFydFRpbWU6YyxleHBpcmF0aW9uVGltZTplLHNvcnRJbmRleDotMX07Yz5kPyhhLnNvcnRJbmRleD1jLEgoTSxhKSxudWxsPT09SihMKSYmYT09PUooTSkmJihTP2goKTpTPSEwLGcoVSxjLWQpKSk6KGEuc29ydEluZGV4PWUsSChMLGEpLFJ8fFF8fChSPSEwLGYoVikpKTtyZXR1cm4gYX07XG5leHBvcnRzLnVuc3RhYmxlX3dyYXBDYWxsYmFjaz1mdW5jdGlvbihhKXt2YXIgYj1QO3JldHVybiBmdW5jdGlvbigpe3ZhciBjPVA7UD1iO3RyeXtyZXR1cm4gYS5hcHBseSh0aGlzLGFyZ3VtZW50cyl9ZmluYWxseXtQPWN9fX07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///53\n')},840:(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("\n\nif (true) {\n  module.exports = __webpack_require__(53);\n} else {}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODQwLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLElBQUksSUFBcUM7QUFDekMsRUFBRSx3Q0FBNkQ7QUFDL0QsRUFBRSxLQUFLLEVBRU4iLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9ub2RlX21vZHVsZXMvc2NoZWR1bGVyL2luZGV4LmpzPzQwMjkiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJykge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3NjaGVkdWxlci5wcm9kdWN0aW9uLm1pbi5qcycpO1xufSBlbHNlIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9zY2hlZHVsZXIuZGV2ZWxvcG1lbnQuanMnKTtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///840\n")},996:e=>{"use strict";e.exports="# MDC React\r\n\r\n[Material Components Web](https://github.com/material-components/material-components-web) implemented in React.\r\n\r\n## Setup\r\n\r\nInstall the library using npm:\r\n\r\n```sh\r\nnpm i mdc-pug\r\n```\r\n\r\nIf you plan on using the Sass files, you'll also need to install `sass`:\r\n\r\n```sh\r\nnpm i -D sass\r\n```\r\n\r\n> **NOTE**: MDC React (as well as MDC Web) uses the new [Sass Module System](https://sass-lang.com/blog/the-module-system-is-launched). Unfortunately at this time the `node-sass` implementation does not support it. Please use the `sass` library.\r\n\r\n## Usage\r\n\r\n### JS\r\n\r\nTo use the components just import what you need from the library:\r\n\r\n```jsx\r\nimport { Button } from 'mdc-react';\r\n\r\nconst App = () => {\r\n    return (\r\n        <div>\r\n            <Button>Click me!</Button>\r\n        </div>\r\n    );\r\n};\r\n```\r\n\r\nAlternatively you can import only the components you need:\r\n\r\n```jsx\r\nimport Button from 'mdc-react/button';\r\nimport Typography from 'mdc-react/typography';\r\n\r\nconst App = () => {\r\n    return (\r\n        <div>\r\n            <Typography>Hello world!</Typography>\r\n            <Button>Click me!</Button>\r\n        </div>\r\n    );\r\n};\r\n```\r\n\r\n### Sass\r\n\r\nYou can use all the styles:\r\n\r\n```scss\r\n@use 'path-to-node_modules/mdc-react';\r\n```\r\n\r\nor only the ones you need:\r\n\r\n```scss\r\n@use 'path-to-node_modules/mdc-react/src/button';\r\n@use 'path-to-node_modules/mdc-react/src/typography';\r\n```"},390:module=>{eval("var deepFreezeEs6 = {exports: {}};\n\nfunction deepFreeze(obj) {\n    if (obj instanceof Map) {\n        obj.clear = obj.delete = obj.set = function () {\n            throw new Error('map is read-only');\n        };\n    } else if (obj instanceof Set) {\n        obj.add = obj.clear = obj.delete = function () {\n            throw new Error('set is read-only');\n        };\n    }\n\n    // Freeze self\n    Object.freeze(obj);\n\n    Object.getOwnPropertyNames(obj).forEach(function (name) {\n        var prop = obj[name];\n\n        // Freeze prop if it is an object\n        if (typeof prop == 'object' && !Object.isFrozen(prop)) {\n            deepFreeze(prop);\n        }\n    });\n\n    return obj;\n}\n\ndeepFreezeEs6.exports = deepFreeze;\ndeepFreezeEs6.exports.default = deepFreeze;\n\nvar deepFreeze$1 = deepFreezeEs6.exports;\n\n/** @typedef {import('highlight.js').CallbackResponse} CallbackResponse */\n/** @typedef {import('highlight.js').CompiledMode} CompiledMode */\n/** @implements CallbackResponse */\n\nclass Response {\n  /**\n   * @param {CompiledMode} mode\n   */\n  constructor(mode) {\n    // eslint-disable-next-line no-undefined\n    if (mode.data === undefined) mode.data = {};\n\n    this.data = mode.data;\n    this.isMatchIgnored = false;\n  }\n\n  ignoreMatch() {\n    this.isMatchIgnored = true;\n  }\n}\n\n/**\n * @param {string} value\n * @returns {string}\n */\nfunction escapeHTML(value) {\n  return value\n    .replace(/&/g, '&amp;')\n    .replace(/</g, '&lt;')\n    .replace(/>/g, '&gt;')\n    .replace(/\"/g, '&quot;')\n    .replace(/'/g, '&#x27;');\n}\n\n/**\n * performs a shallow merge of multiple objects into one\n *\n * @template T\n * @param {T} original\n * @param {Record<string,any>[]} objects\n * @returns {T} a single new object\n */\nfunction inherit$1(original, ...objects) {\n  /** @type Record<string,any> */\n  const result = Object.create(null);\n\n  for (const key in original) {\n    result[key] = original[key];\n  }\n  objects.forEach(function(obj) {\n    for (const key in obj) {\n      result[key] = obj[key];\n    }\n  });\n  return /** @type {T} */ (result);\n}\n\n/**\n * @typedef {object} Renderer\n * @property {(text: string) => void} addText\n * @property {(node: Node) => void} openNode\n * @property {(node: Node) => void} closeNode\n * @property {() => string} value\n */\n\n/** @typedef {{kind?: string, sublanguage?: boolean}} Node */\n/** @typedef {{walk: (r: Renderer) => void}} Tree */\n/** */\n\nconst SPAN_CLOSE = '</span>';\n\n/**\n * Determines if a node needs to be wrapped in <span>\n *\n * @param {Node} node */\nconst emitsWrappingTags = (node) => {\n  return !!node.kind;\n};\n\n/**\n *\n * @param {string} name\n * @param {{prefix:string}} options\n */\nconst expandScopeName = (name, { prefix }) => {\n  if (name.includes(\".\")) {\n    const pieces = name.split(\".\");\n    return [\n      `${prefix}${pieces.shift()}`,\n      ...(pieces.map((x, i) => `${x}${\"_\".repeat(i + 1)}`))\n    ].join(\" \");\n  }\n  return `${prefix}${name}`;\n};\n\n/** @type {Renderer} */\nclass HTMLRenderer {\n  /**\n   * Creates a new HTMLRenderer\n   *\n   * @param {Tree} parseTree - the parse tree (must support `walk` API)\n   * @param {{classPrefix: string}} options\n   */\n  constructor(parseTree, options) {\n    this.buffer = \"\";\n    this.classPrefix = options.classPrefix;\n    parseTree.walk(this);\n  }\n\n  /**\n   * Adds texts to the output stream\n   *\n   * @param {string} text */\n  addText(text) {\n    this.buffer += escapeHTML(text);\n  }\n\n  /**\n   * Adds a node open to the output stream (if needed)\n   *\n   * @param {Node} node */\n  openNode(node) {\n    if (!emitsWrappingTags(node)) return;\n\n    let scope = node.kind;\n    if (node.sublanguage) {\n      scope = `language-${scope}`;\n    } else {\n      scope = expandScopeName(scope, { prefix: this.classPrefix });\n    }\n    this.span(scope);\n  }\n\n  /**\n   * Adds a node close to the output stream (if needed)\n   *\n   * @param {Node} node */\n  closeNode(node) {\n    if (!emitsWrappingTags(node)) return;\n\n    this.buffer += SPAN_CLOSE;\n  }\n\n  /**\n   * returns the accumulated buffer\n  */\n  value() {\n    return this.buffer;\n  }\n\n  // helpers\n\n  /**\n   * Builds a span element\n   *\n   * @param {string} className */\n  span(className) {\n    this.buffer += `<span class=\"${className}\">`;\n  }\n}\n\n/** @typedef {{kind?: string, sublanguage?: boolean, children: Node[]} | string} Node */\n/** @typedef {{kind?: string, sublanguage?: boolean, children: Node[]} } DataNode */\n/** @typedef {import('highlight.js').Emitter} Emitter */\n/**  */\n\nclass TokenTree {\n  constructor() {\n    /** @type DataNode */\n    this.rootNode = { children: [] };\n    this.stack = [this.rootNode];\n  }\n\n  get top() {\n    return this.stack[this.stack.length - 1];\n  }\n\n  get root() { return this.rootNode; }\n\n  /** @param {Node} node */\n  add(node) {\n    this.top.children.push(node);\n  }\n\n  /** @param {string} kind */\n  openNode(kind) {\n    /** @type Node */\n    const node = { kind, children: [] };\n    this.add(node);\n    this.stack.push(node);\n  }\n\n  closeNode() {\n    if (this.stack.length > 1) {\n      return this.stack.pop();\n    }\n    // eslint-disable-next-line no-undefined\n    return undefined;\n  }\n\n  closeAllNodes() {\n    while (this.closeNode());\n  }\n\n  toJSON() {\n    return JSON.stringify(this.rootNode, null, 4);\n  }\n\n  /**\n   * @typedef { import(\"./html_renderer\").Renderer } Renderer\n   * @param {Renderer} builder\n   */\n  walk(builder) {\n    // this does not\n    return this.constructor._walk(builder, this.rootNode);\n    // this works\n    // return TokenTree._walk(builder, this.rootNode);\n  }\n\n  /**\n   * @param {Renderer} builder\n   * @param {Node} node\n   */\n  static _walk(builder, node) {\n    if (typeof node === \"string\") {\n      builder.addText(node);\n    } else if (node.children) {\n      builder.openNode(node);\n      node.children.forEach((child) => this._walk(builder, child));\n      builder.closeNode(node);\n    }\n    return builder;\n  }\n\n  /**\n   * @param {Node} node\n   */\n  static _collapse(node) {\n    if (typeof node === \"string\") return;\n    if (!node.children) return;\n\n    if (node.children.every(el => typeof el === \"string\")) {\n      // node.text = node.children.join(\"\");\n      // delete node.children;\n      node.children = [node.children.join(\"\")];\n    } else {\n      node.children.forEach((child) => {\n        TokenTree._collapse(child);\n      });\n    }\n  }\n}\n\n/**\n  Currently this is all private API, but this is the minimal API necessary\n  that an Emitter must implement to fully support the parser.\n\n  Minimal interface:\n\n  - addKeyword(text, kind)\n  - addText(text)\n  - addSublanguage(emitter, subLanguageName)\n  - finalize()\n  - openNode(kind)\n  - closeNode()\n  - closeAllNodes()\n  - toHTML()\n\n*/\n\n/**\n * @implements {Emitter}\n */\nclass TokenTreeEmitter extends TokenTree {\n  /**\n   * @param {*} options\n   */\n  constructor(options) {\n    super();\n    this.options = options;\n  }\n\n  /**\n   * @param {string} text\n   * @param {string} kind\n   */\n  addKeyword(text, kind) {\n    if (text === \"\") { return; }\n\n    this.openNode(kind);\n    this.addText(text);\n    this.closeNode();\n  }\n\n  /**\n   * @param {string} text\n   */\n  addText(text) {\n    if (text === \"\") { return; }\n\n    this.add(text);\n  }\n\n  /**\n   * @param {Emitter & {root: DataNode}} emitter\n   * @param {string} name\n   */\n  addSublanguage(emitter, name) {\n    /** @type DataNode */\n    const node = emitter.root;\n    node.kind = name;\n    node.sublanguage = true;\n    this.add(node);\n  }\n\n  toHTML() {\n    const renderer = new HTMLRenderer(this, this.options);\n    return renderer.value();\n  }\n\n  finalize() {\n    return true;\n  }\n}\n\n/**\n * @param {string} value\n * @returns {RegExp}\n * */\n\n/**\n * @param {RegExp | string } re\n * @returns {string}\n */\nfunction source(re) {\n  if (!re) return null;\n  if (typeof re === \"string\") return re;\n\n  return re.source;\n}\n\n/**\n * @param {RegExp | string } re\n * @returns {string}\n */\nfunction lookahead(re) {\n  return concat('(?=', re, ')');\n}\n\n/**\n * @param {...(RegExp | string) } args\n * @returns {string}\n */\nfunction concat(...args) {\n  const joined = args.map((x) => source(x)).join(\"\");\n  return joined;\n}\n\nfunction stripOptionsFromArgs(args) {\n  const opts = args[args.length - 1];\n\n  if (typeof opts === 'object' && opts.constructor === Object) {\n    args.splice(args.length - 1, 1);\n    return opts;\n  } else {\n    return {};\n  }\n}\n\n/**\n * Any of the passed expresssions may match\n *\n * Creates a huge this | this | that | that match\n * @param {(RegExp | string)[] } args\n * @returns {string}\n */\nfunction either(...args) {\n  const opts = stripOptionsFromArgs(args);\n  const joined = '(' +\n    (opts.capture ? \"\" : \"?:\") +\n    args.map((x) => source(x)).join(\"|\") + \")\";\n  return joined;\n}\n\n/**\n * @param {RegExp} re\n * @returns {number}\n */\nfunction countMatchGroups(re) {\n  return (new RegExp(re.toString() + '|')).exec('').length - 1;\n}\n\n/**\n * Does lexeme start with a regular expression match at the beginning\n * @param {RegExp} re\n * @param {string} lexeme\n */\nfunction startsWith(re, lexeme) {\n  const match = re && re.exec(lexeme);\n  return match && match.index === 0;\n}\n\n// BACKREF_RE matches an open parenthesis or backreference. To avoid\n// an incorrect parse, it additionally matches the following:\n// - [...] elements, where the meaning of parentheses and escapes change\n// - other escape sequences, so we do not misparse escape sequences as\n//   interesting elements\n// - non-matching or lookahead parentheses, which do not capture. These\n//   follow the '(' with a '?'.\nconst BACKREF_RE = /\\[(?:[^\\\\\\]]|\\\\.)*\\]|\\(\\??|\\\\([1-9][0-9]*)|\\\\./;\n\n// **INTERNAL** Not intended for outside usage\n// join logically computes regexps.join(separator), but fixes the\n// backreferences so they continue to match.\n// it also places each individual regular expression into it's own\n// match group, keeping track of the sequencing of those match groups\n// is currently an exercise for the caller. :-)\n/**\n * @param {(string | RegExp)[]} regexps\n * @param {{joinWith: string}} opts\n * @returns {string}\n */\nfunction _rewriteBackreferences(regexps, { joinWith }) {\n  let numCaptures = 0;\n\n  return regexps.map((regex) => {\n    numCaptures += 1;\n    const offset = numCaptures;\n    let re = source(regex);\n    let out = '';\n\n    while (re.length > 0) {\n      const match = BACKREF_RE.exec(re);\n      if (!match) {\n        out += re;\n        break;\n      }\n      out += re.substring(0, match.index);\n      re = re.substring(match.index + match[0].length);\n      if (match[0][0] === '\\\\' && match[1]) {\n        // Adjust the backreference.\n        out += '\\\\' + String(Number(match[1]) + offset);\n      } else {\n        out += match[0];\n        if (match[0] === '(') {\n          numCaptures++;\n        }\n      }\n    }\n    return out;\n  }).map(re => `(${re})`).join(joinWith);\n}\n\n/** @typedef {import('highlight.js').Mode} Mode */\n/** @typedef {import('highlight.js').ModeCallback} ModeCallback */\n\n// Common regexps\nconst MATCH_NOTHING_RE = /\\b\\B/;\nconst IDENT_RE = '[a-zA-Z]\\\\w*';\nconst UNDERSCORE_IDENT_RE = '[a-zA-Z_]\\\\w*';\nconst NUMBER_RE = '\\\\b\\\\d+(\\\\.\\\\d+)?';\nconst C_NUMBER_RE = '(-?)(\\\\b0[xX][a-fA-F0-9]+|(\\\\b\\\\d+(\\\\.\\\\d*)?|\\\\.\\\\d+)([eE][-+]?\\\\d+)?)'; // 0x..., 0..., decimal, float\nconst BINARY_NUMBER_RE = '\\\\b(0b[01]+)'; // 0b...\nconst RE_STARTERS_RE = '!|!=|!==|%|%=|&|&&|&=|\\\\*|\\\\*=|\\\\+|\\\\+=|,|-|-=|/=|/|:|;|<<|<<=|<=|<|===|==|=|>>>=|>>=|>=|>>>|>>|>|\\\\?|\\\\[|\\\\{|\\\\(|\\\\^|\\\\^=|\\\\||\\\\|=|\\\\|\\\\||~';\n\n/**\n* @param { Partial<Mode> & {binary?: string | RegExp} } opts\n*/\nconst SHEBANG = (opts = {}) => {\n  const beginShebang = /^#![ ]*\\//;\n  if (opts.binary) {\n    opts.begin = concat(\n      beginShebang,\n      /.*\\b/,\n      opts.binary,\n      /\\b.*/);\n  }\n  return inherit$1({\n    scope: 'meta',\n    begin: beginShebang,\n    end: /$/,\n    relevance: 0,\n    /** @type {ModeCallback} */\n    \"on:begin\": (m, resp) => {\n      if (m.index !== 0) resp.ignoreMatch();\n    }\n  }, opts);\n};\n\n// Common modes\nconst BACKSLASH_ESCAPE = {\n  begin: '\\\\\\\\[\\\\s\\\\S]', relevance: 0\n};\nconst APOS_STRING_MODE = {\n  scope: 'string',\n  begin: '\\'',\n  end: '\\'',\n  illegal: '\\\\n',\n  contains: [BACKSLASH_ESCAPE]\n};\nconst QUOTE_STRING_MODE = {\n  scope: 'string',\n  begin: '\"',\n  end: '\"',\n  illegal: '\\\\n',\n  contains: [BACKSLASH_ESCAPE]\n};\nconst PHRASAL_WORDS_MODE = {\n  begin: /\\b(a|an|the|are|I'm|isn't|don't|doesn't|won't|but|just|should|pretty|simply|enough|gonna|going|wtf|so|such|will|you|your|they|like|more)\\b/\n};\n/**\n * Creates a comment mode\n *\n * @param {string | RegExp} begin\n * @param {string | RegExp} end\n * @param {Mode | {}} [modeOptions]\n * @returns {Partial<Mode>}\n */\nconst COMMENT = function(begin, end, modeOptions = {}) {\n  const mode = inherit$1(\n    {\n      scope: 'comment',\n      begin,\n      end,\n      contains: []\n    },\n    modeOptions\n  );\n  mode.contains.push({\n    scope: 'doctag',\n    // hack to avoid the space from being included. the space is necessary to\n    // match here to prevent the plain text rule below from gobbling up doctags\n    begin: '[ ]*(?=(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):)',\n    end: /(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):/,\n    excludeBegin: true,\n    relevance: 0\n  });\n  const ENGLISH_WORD = either(\n    // list of common 1 and 2 letter words in English\n    \"I\",\n    \"a\",\n    \"is\",\n    \"so\",\n    \"us\",\n    \"to\",\n    \"at\",\n    \"if\",\n    \"in\",\n    \"it\",\n    \"on\",\n    // note: this is not an exhaustive list of contractions, just popular ones\n    /[A-Za-z]+['](d|ve|re|ll|t|s|n)/, // contractions - can't we'd they're let's, etc\n    /[A-Za-z]+[-][a-z]+/, // `no-way`, etc.\n    /[A-Za-z][a-z]{2,}/ // allow capitalized words at beginning of sentences\n  );\n  // looking like plain text, more likely to be a comment\n  mode.contains.push(\n    {\n      // TODO: how to include \", (, ) without breaking grammars that use these for\n      // comment delimiters?\n      // begin: /[ ]+([()\"]?([A-Za-z'-]{3,}|is|a|I|so|us|[tT][oO]|at|if|in|it|on)[.]?[()\":]?([.][ ]|[ ]|\\))){3}/\n      // ---\n\n      // this tries to find sequences of 3 english words in a row (without any\n      // \"programming\" type syntax) this gives us a strong signal that we've\n      // TRULY found a comment - vs perhaps scanning with the wrong language.\n      // It's possible to find something that LOOKS like the start of the\n      // comment - but then if there is no readable text - good chance it is a\n      // false match and not a comment.\n      //\n      // for a visual example please see:\n      // https://github.com/highlightjs/highlight.js/issues/2827\n\n      begin: concat(\n        /[ ]+/, // necessary to prevent us gobbling up doctags like /* @author Bob Mcgill */\n        '(',\n        ENGLISH_WORD,\n        /[.]?[:]?([.][ ]|[ ])/,\n        '){3}') // look for 3 words in a row\n    }\n  );\n  return mode;\n};\nconst C_LINE_COMMENT_MODE = COMMENT('//', '$');\nconst C_BLOCK_COMMENT_MODE = COMMENT('/\\\\*', '\\\\*/');\nconst HASH_COMMENT_MODE = COMMENT('#', '$');\nconst NUMBER_MODE = {\n  scope: 'number',\n  begin: NUMBER_RE,\n  relevance: 0\n};\nconst C_NUMBER_MODE = {\n  scope: 'number',\n  begin: C_NUMBER_RE,\n  relevance: 0\n};\nconst BINARY_NUMBER_MODE = {\n  scope: 'number',\n  begin: BINARY_NUMBER_RE,\n  relevance: 0\n};\nconst REGEXP_MODE = {\n  // this outer rule makes sure we actually have a WHOLE regex and not simply\n  // an expression such as:\n  //\n  //     3 / something\n  //\n  // (which will then blow up when regex's `illegal` sees the newline)\n  begin: /(?=\\/[^/\\n]*\\/)/,\n  contains: [{\n    scope: 'regexp',\n    begin: /\\//,\n    end: /\\/[gimuy]*/,\n    illegal: /\\n/,\n    contains: [\n      BACKSLASH_ESCAPE,\n      {\n        begin: /\\[/,\n        end: /\\]/,\n        relevance: 0,\n        contains: [BACKSLASH_ESCAPE]\n      }\n    ]\n  }]\n};\nconst TITLE_MODE = {\n  scope: 'title',\n  begin: IDENT_RE,\n  relevance: 0\n};\nconst UNDERSCORE_TITLE_MODE = {\n  scope: 'title',\n  begin: UNDERSCORE_IDENT_RE,\n  relevance: 0\n};\nconst METHOD_GUARD = {\n  // excludes method names from keyword processing\n  begin: '\\\\.\\\\s*' + UNDERSCORE_IDENT_RE,\n  relevance: 0\n};\n\n/**\n * Adds end same as begin mechanics to a mode\n *\n * Your mode must include at least a single () match group as that first match\n * group is what is used for comparison\n * @param {Partial<Mode>} mode\n */\nconst END_SAME_AS_BEGIN = function(mode) {\n  return Object.assign(mode,\n    {\n      /** @type {ModeCallback} */\n      'on:begin': (m, resp) => { resp.data._beginMatch = m[1]; },\n      /** @type {ModeCallback} */\n      'on:end': (m, resp) => { if (resp.data._beginMatch !== m[1]) resp.ignoreMatch(); }\n    });\n};\n\nvar MODES = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    MATCH_NOTHING_RE: MATCH_NOTHING_RE,\n    IDENT_RE: IDENT_RE,\n    UNDERSCORE_IDENT_RE: UNDERSCORE_IDENT_RE,\n    NUMBER_RE: NUMBER_RE,\n    C_NUMBER_RE: C_NUMBER_RE,\n    BINARY_NUMBER_RE: BINARY_NUMBER_RE,\n    RE_STARTERS_RE: RE_STARTERS_RE,\n    SHEBANG: SHEBANG,\n    BACKSLASH_ESCAPE: BACKSLASH_ESCAPE,\n    APOS_STRING_MODE: APOS_STRING_MODE,\n    QUOTE_STRING_MODE: QUOTE_STRING_MODE,\n    PHRASAL_WORDS_MODE: PHRASAL_WORDS_MODE,\n    COMMENT: COMMENT,\n    C_LINE_COMMENT_MODE: C_LINE_COMMENT_MODE,\n    C_BLOCK_COMMENT_MODE: C_BLOCK_COMMENT_MODE,\n    HASH_COMMENT_MODE: HASH_COMMENT_MODE,\n    NUMBER_MODE: NUMBER_MODE,\n    C_NUMBER_MODE: C_NUMBER_MODE,\n    BINARY_NUMBER_MODE: BINARY_NUMBER_MODE,\n    REGEXP_MODE: REGEXP_MODE,\n    TITLE_MODE: TITLE_MODE,\n    UNDERSCORE_TITLE_MODE: UNDERSCORE_TITLE_MODE,\n    METHOD_GUARD: METHOD_GUARD,\n    END_SAME_AS_BEGIN: END_SAME_AS_BEGIN\n});\n\n/**\n@typedef {import('highlight.js').CallbackResponse} CallbackResponse\n@typedef {import('highlight.js').CompilerExt} CompilerExt\n*/\n\n// Grammar extensions / plugins\n// See: https://github.com/highlightjs/highlight.js/issues/2833\n\n// Grammar extensions allow \"syntactic sugar\" to be added to the grammar modes\n// without requiring any underlying changes to the compiler internals.\n\n// `compileMatch` being the perfect small example of now allowing a grammar\n// author to write `match` when they desire to match a single expression rather\n// than being forced to use `begin`.  The extension then just moves `match` into\n// `begin` when it runs.  Ie, no features have been added, but we've just made\n// the experience of writing (and reading grammars) a little bit nicer.\n\n// ------\n\n// TODO: We need negative look-behind support to do this properly\n/**\n * Skip a match if it has a preceding dot\n *\n * This is used for `beginKeywords` to prevent matching expressions such as\n * `bob.keyword.do()`. The mode compiler automatically wires this up as a\n * special _internal_ 'on:begin' callback for modes with `beginKeywords`\n * @param {RegExpMatchArray} match\n * @param {CallbackResponse} response\n */\nfunction skipIfHasPrecedingDot(match, response) {\n  const before = match.input[match.index - 1];\n  if (before === \".\") {\n    response.ignoreMatch();\n  }\n}\n\n/**\n *\n * @type {CompilerExt}\n */\nfunction scopeClassName(mode, _parent) {\n  // eslint-disable-next-line no-undefined\n  if (mode.className !== undefined) {\n    mode.scope = mode.className;\n    delete mode.className;\n  }\n}\n\n/**\n * `beginKeywords` syntactic sugar\n * @type {CompilerExt}\n */\nfunction beginKeywords(mode, parent) {\n  if (!parent) return;\n  if (!mode.beginKeywords) return;\n\n  // for languages with keywords that include non-word characters checking for\n  // a word boundary is not sufficient, so instead we check for a word boundary\n  // or whitespace - this does no harm in any case since our keyword engine\n  // doesn't allow spaces in keywords anyways and we still check for the boundary\n  // first\n  mode.begin = '\\\\b(' + mode.beginKeywords.split(' ').join('|') + ')(?!\\\\.)(?=\\\\b|\\\\s)';\n  mode.__beforeBegin = skipIfHasPrecedingDot;\n  mode.keywords = mode.keywords || mode.beginKeywords;\n  delete mode.beginKeywords;\n\n  // prevents double relevance, the keywords themselves provide\n  // relevance, the mode doesn't need to double it\n  // eslint-disable-next-line no-undefined\n  if (mode.relevance === undefined) mode.relevance = 0;\n}\n\n/**\n * Allow `illegal` to contain an array of illegal values\n * @type {CompilerExt}\n */\nfunction compileIllegal(mode, _parent) {\n  if (!Array.isArray(mode.illegal)) return;\n\n  mode.illegal = either(...mode.illegal);\n}\n\n/**\n * `match` to match a single expression for readability\n * @type {CompilerExt}\n */\nfunction compileMatch(mode, _parent) {\n  if (!mode.match) return;\n  if (mode.begin || mode.end) throw new Error(\"begin & end are not supported with match\");\n\n  mode.begin = mode.match;\n  delete mode.match;\n}\n\n/**\n * provides the default 1 relevance to all modes\n * @type {CompilerExt}\n */\nfunction compileRelevance(mode, _parent) {\n  // eslint-disable-next-line no-undefined\n  if (mode.relevance === undefined) mode.relevance = 1;\n}\n\n// allow beforeMatch to act as a \"qualifier\" for the match\n// the full match begin must be [beforeMatch][begin]\nconst beforeMatchExt = (mode, parent) => {\n  if (!mode.beforeMatch) return;\n  // starts conflicts with endsParent which we need to make sure the child\n  // rule is not matched multiple times\n  if (mode.starts) throw new Error(\"beforeMatch cannot be used with starts\");\n\n  const originalMode = Object.assign({}, mode);\n  Object.keys(mode).forEach((key) => { delete mode[key]; });\n\n  mode.keywords = originalMode.keywords;\n  mode.begin = concat(originalMode.beforeMatch, lookahead(originalMode.begin));\n  mode.starts = {\n    relevance: 0,\n    contains: [\n      Object.assign(originalMode, { endsParent: true })\n    ]\n  };\n  mode.relevance = 0;\n\n  delete originalMode.beforeMatch;\n};\n\n// keywords that should have no default relevance value\nconst COMMON_KEYWORDS = [\n  'of',\n  'and',\n  'for',\n  'in',\n  'not',\n  'or',\n  'if',\n  'then',\n  'parent', // common variable name\n  'list', // common variable name\n  'value' // common variable name\n];\n\nconst DEFAULT_KEYWORD_SCOPE = \"keyword\";\n\n/**\n * Given raw keywords from a language definition, compile them.\n *\n * @param {string | Record<string,string|string[]> | Array<string>} rawKeywords\n * @param {boolean} caseInsensitive\n */\nfunction compileKeywords(rawKeywords, caseInsensitive, scopeName = DEFAULT_KEYWORD_SCOPE) {\n  /** @type KeywordDict */\n  const compiledKeywords = Object.create(null);\n\n  // input can be a string of keywords, an array of keywords, or a object with\n  // named keys representing scopeName (which can then point to a string or array)\n  if (typeof rawKeywords === 'string') {\n    compileList(scopeName, rawKeywords.split(\" \"));\n  } else if (Array.isArray(rawKeywords)) {\n    compileList(scopeName, rawKeywords);\n  } else {\n    Object.keys(rawKeywords).forEach(function(scopeName) {\n      // collapse all our objects back into the parent object\n      Object.assign(\n        compiledKeywords,\n        compileKeywords(rawKeywords[scopeName], caseInsensitive, scopeName)\n      );\n    });\n  }\n  return compiledKeywords;\n\n  // ---\n\n  /**\n   * Compiles an individual list of keywords\n   *\n   * Ex: \"for if when while|5\"\n   *\n   * @param {string} scopeName\n   * @param {Array<string>} keywordList\n   */\n  function compileList(scopeName, keywordList) {\n    if (caseInsensitive) {\n      keywordList = keywordList.map(x => x.toLowerCase());\n    }\n    keywordList.forEach(function(keyword) {\n      const pair = keyword.split('|');\n      compiledKeywords[pair[0]] = [scopeName, scoreForKeyword(pair[0], pair[1])];\n    });\n  }\n}\n\n/**\n * Returns the proper score for a given keyword\n *\n * Also takes into account comment keywords, which will be scored 0 UNLESS\n * another score has been manually assigned.\n * @param {string} keyword\n * @param {string} [providedScore]\n */\nfunction scoreForKeyword(keyword, providedScore) {\n  // manual scores always win over common keywords\n  // so you can force a score of 1 if you really insist\n  if (providedScore) {\n    return Number(providedScore);\n  }\n\n  return commonKeyword(keyword) ? 0 : 1;\n}\n\n/**\n * Determines if a given keyword is common or not\n *\n * @param {string} keyword */\nfunction commonKeyword(keyword) {\n  return COMMON_KEYWORDS.includes(keyword.toLowerCase());\n}\n\n/*\n\nFor the reasoning behind this please see:\nhttps://github.com/highlightjs/highlight.js/issues/2880#issuecomment-747275419\n\n*/\n\n/**\n * @type {Record<string, boolean>}\n */\nconst seenDeprecations = {};\n\n/**\n * @param {string} message\n */\nconst error = (message) => {\n  console.error(message);\n};\n\n/**\n * @param {string} message\n * @param {any} args\n */\nconst warn = (message, ...args) => {\n  console.log(`WARN: ${message}`, ...args);\n};\n\n/**\n * @param {string} version\n * @param {string} message\n */\nconst deprecated = (version, message) => {\n  if (seenDeprecations[`${version}/${message}`]) return;\n\n  console.log(`Deprecated as of ${version}. ${message}`);\n  seenDeprecations[`${version}/${message}`] = true;\n};\n\n/* eslint-disable no-throw-literal */\n\n/**\n@typedef {import('highlight.js').CompiledMode} CompiledMode\n*/\n\nconst MultiClassError = new Error();\n\n/**\n * Renumbers labeled scope names to account for additional inner match\n * groups that otherwise would break everything.\n *\n * Lets say we 3 match scopes:\n *\n *   { 1 => ..., 2 => ..., 3 => ... }\n *\n * So what we need is a clean match like this:\n *\n *   (a)(b)(c) => [ \"a\", \"b\", \"c\" ]\n *\n * But this falls apart with inner match groups:\n *\n * (a)(((b)))(c) => [\"a\", \"b\", \"b\", \"b\", \"c\" ]\n *\n * Our scopes are now \"out of alignment\" and we're repeating `b` 3 times.\n * What needs to happen is the numbers are remapped:\n *\n *   { 1 => ..., 2 => ..., 5 => ... }\n *\n * We also need to know that the ONLY groups that should be output\n * are 1, 2, and 5.  This function handles this behavior.\n *\n * @param {CompiledMode} mode\n * @param {Array<RegExp>} regexes\n * @param {{key: \"beginScope\"|\"endScope\"}} opts\n */\nfunction remapScopeNames(mode, regexes, { key }) {\n  let offset = 0;\n  const scopeNames = mode[key];\n  /** @type Record<number,boolean> */\n  const emit = {};\n  /** @type Record<number,string> */\n  const positions = {};\n\n  for (let i = 1; i <= regexes.length; i++) {\n    positions[i + offset] = scopeNames[i];\n    emit[i + offset] = true;\n    offset += countMatchGroups(regexes[i - 1]);\n  }\n  // we use _emit to keep track of which match groups are \"top-level\" to avoid double\n  // output from inside match groups\n  mode[key] = positions;\n  mode[key]._emit = emit;\n  mode[key]._multi = true;\n}\n\n/**\n * @param {CompiledMode} mode\n */\nfunction beginMultiClass(mode) {\n  if (!Array.isArray(mode.begin)) return;\n\n  if (mode.skip || mode.excludeBegin || mode.returnBegin) {\n    error(\"skip, excludeBegin, returnBegin not compatible with beginScope: {}\");\n    throw MultiClassError;\n  }\n\n  if (typeof mode.beginScope !== \"object\" || mode.beginScope === null) {\n    error(\"beginScope must be object\");\n    throw MultiClassError;\n  }\n\n  remapScopeNames(mode, mode.begin, {key: \"beginScope\"});\n  mode.begin = _rewriteBackreferences(mode.begin, { joinWith: \"\" });\n}\n\n/**\n * @param {CompiledMode} mode\n */\nfunction endMultiClass(mode) {\n  if (!Array.isArray(mode.end)) return;\n\n  if (mode.skip || mode.excludeEnd || mode.returnEnd) {\n    error(\"skip, excludeEnd, returnEnd not compatible with endScope: {}\");\n    throw MultiClassError;\n  }\n\n  if (typeof mode.endScope !== \"object\" || mode.endScope === null) {\n    error(\"endScope must be object\");\n    throw MultiClassError;\n  }\n\n  remapScopeNames(mode, mode.end, {key: \"endScope\"});\n  mode.end = _rewriteBackreferences(mode.end, { joinWith: \"\" });\n}\n\n/**\n * this exists only to allow `scope: {}` to be used beside `match:`\n * Otherwise `beginScope` would necessary and that would look weird\n\n  {\n    match: [ /def/, /\\w+/ ]\n    scope: { 1: \"keyword\" , 2: \"title\" }\n  }\n\n * @param {CompiledMode} mode\n */\nfunction scopeSugar(mode) {\n  if (mode.scope && typeof mode.scope === \"object\" && mode.scope !== null) {\n    mode.beginScope = mode.scope;\n    delete mode.scope;\n  }\n}\n\n/**\n * @param {CompiledMode} mode\n */\nfunction MultiClass(mode) {\n  scopeSugar(mode);\n\n  if (typeof mode.beginScope === \"string\") {\n    mode.beginScope = { _wrap: mode.beginScope };\n  }\n  if (typeof mode.endScope === \"string\") {\n    mode.endScope = { _wrap: mode.endScope };\n  }\n\n  beginMultiClass(mode);\n  endMultiClass(mode);\n}\n\n/**\n@typedef {import('highlight.js').Mode} Mode\n@typedef {import('highlight.js').CompiledMode} CompiledMode\n@typedef {import('highlight.js').Language} Language\n@typedef {import('highlight.js').HLJSPlugin} HLJSPlugin\n@typedef {import('highlight.js').CompiledLanguage} CompiledLanguage\n*/\n\n// compilation\n\n/**\n * Compiles a language definition result\n *\n * Given the raw result of a language definition (Language), compiles this so\n * that it is ready for highlighting code.\n * @param {Language} language\n * @returns {CompiledLanguage}\n */\nfunction compileLanguage(language) {\n  /**\n   * Builds a regex with the case sensitivity of the current language\n   *\n   * @param {RegExp | string} value\n   * @param {boolean} [global]\n   */\n  function langRe(value, global) {\n    return new RegExp(\n      source(value),\n      'm' + (language.case_insensitive ? 'i' : '') + (global ? 'g' : '')\n    );\n  }\n\n  /**\n    Stores multiple regular expressions and allows you to quickly search for\n    them all in a string simultaneously - returning the first match.  It does\n    this by creating a huge (a|b|c) regex - each individual item wrapped with ()\n    and joined by `|` - using match groups to track position.  When a match is\n    found checking which position in the array has content allows us to figure\n    out which of the original regexes / match groups triggered the match.\n\n    The match object itself (the result of `Regex.exec`) is returned but also\n    enhanced by merging in any meta-data that was registered with the regex.\n    This is how we keep track of which mode matched, and what type of rule\n    (`illegal`, `begin`, end, etc).\n  */\n  class MultiRegex {\n    constructor() {\n      this.matchIndexes = {};\n      // @ts-ignore\n      this.regexes = [];\n      this.matchAt = 1;\n      this.position = 0;\n    }\n\n    // @ts-ignore\n    addRule(re, opts) {\n      opts.position = this.position++;\n      // @ts-ignore\n      this.matchIndexes[this.matchAt] = opts;\n      this.regexes.push([opts, re]);\n      this.matchAt += countMatchGroups(re) + 1;\n    }\n\n    compile() {\n      if (this.regexes.length === 0) {\n        // avoids the need to check length every time exec is called\n        // @ts-ignore\n        this.exec = () => null;\n      }\n      const terminators = this.regexes.map(el => el[1]);\n      this.matcherRe = langRe(_rewriteBackreferences(terminators, { joinWith: '|' }), true);\n      this.lastIndex = 0;\n    }\n\n    /** @param {string} s */\n    exec(s) {\n      this.matcherRe.lastIndex = this.lastIndex;\n      const match = this.matcherRe.exec(s);\n      if (!match) { return null; }\n\n      // eslint-disable-next-line no-undefined\n      const i = match.findIndex((el, i) => i > 0 && el !== undefined);\n      // @ts-ignore\n      const matchData = this.matchIndexes[i];\n      // trim off any earlier non-relevant match groups (ie, the other regex\n      // match groups that make up the multi-matcher)\n      match.splice(0, i);\n\n      return Object.assign(match, matchData);\n    }\n  }\n\n  /*\n    Created to solve the key deficiently with MultiRegex - there is no way to\n    test for multiple matches at a single location.  Why would we need to do\n    that?  In the future a more dynamic engine will allow certain matches to be\n    ignored.  An example: if we matched say the 3rd regex in a large group but\n    decided to ignore it - we'd need to started testing again at the 4th\n    regex... but MultiRegex itself gives us no real way to do that.\n\n    So what this class creates MultiRegexs on the fly for whatever search\n    position they are needed.\n\n    NOTE: These additional MultiRegex objects are created dynamically.  For most\n    grammars most of the time we will never actually need anything more than the\n    first MultiRegex - so this shouldn't have too much overhead.\n\n    Say this is our search group, and we match regex3, but wish to ignore it.\n\n      regex1 | regex2 | regex3 | regex4 | regex5    ' ie, startAt = 0\n\n    What we need is a new MultiRegex that only includes the remaining\n    possibilities:\n\n      regex4 | regex5                               ' ie, startAt = 3\n\n    This class wraps all that complexity up in a simple API... `startAt` decides\n    where in the array of expressions to start doing the matching. It\n    auto-increments, so if a match is found at position 2, then startAt will be\n    set to 3.  If the end is reached startAt will return to 0.\n\n    MOST of the time the parser will be setting startAt manually to 0.\n  */\n  class ResumableMultiRegex {\n    constructor() {\n      // @ts-ignore\n      this.rules = [];\n      // @ts-ignore\n      this.multiRegexes = [];\n      this.count = 0;\n\n      this.lastIndex = 0;\n      this.regexIndex = 0;\n    }\n\n    // @ts-ignore\n    getMatcher(index) {\n      if (this.multiRegexes[index]) return this.multiRegexes[index];\n\n      const matcher = new MultiRegex();\n      this.rules.slice(index).forEach(([re, opts]) => matcher.addRule(re, opts));\n      matcher.compile();\n      this.multiRegexes[index] = matcher;\n      return matcher;\n    }\n\n    resumingScanAtSamePosition() {\n      return this.regexIndex !== 0;\n    }\n\n    considerAll() {\n      this.regexIndex = 0;\n    }\n\n    // @ts-ignore\n    addRule(re, opts) {\n      this.rules.push([re, opts]);\n      if (opts.type === \"begin\") this.count++;\n    }\n\n    /** @param {string} s */\n    exec(s) {\n      const m = this.getMatcher(this.regexIndex);\n      m.lastIndex = this.lastIndex;\n      let result = m.exec(s);\n\n      // The following is because we have no easy way to say \"resume scanning at the\n      // existing position but also skip the current rule ONLY\". What happens is\n      // all prior rules are also skipped which can result in matching the wrong\n      // thing. Example of matching \"booger\":\n\n      // our matcher is [string, \"booger\", number]\n      //\n      // ....booger....\n\n      // if \"booger\" is ignored then we'd really need a regex to scan from the\n      // SAME position for only: [string, number] but ignoring \"booger\" (if it\n      // was the first match), a simple resume would scan ahead who knows how\n      // far looking only for \"number\", ignoring potential string matches (or\n      // future \"booger\" matches that might be valid.)\n\n      // So what we do: We execute two matchers, one resuming at the same\n      // position, but the second full matcher starting at the position after:\n\n      //     /--- resume first regex match here (for [number])\n      //     |/---- full match here for [string, \"booger\", number]\n      //     vv\n      // ....booger....\n\n      // Which ever results in a match first is then used. So this 3-4 step\n      // process essentially allows us to say \"match at this position, excluding\n      // a prior rule that was ignored\".\n      //\n      // 1. Match \"booger\" first, ignore. Also proves that [string] does non match.\n      // 2. Resume matching for [number]\n      // 3. Match at index + 1 for [string, \"booger\", number]\n      // 4. If #2 and #3 result in matches, which came first?\n      if (this.resumingScanAtSamePosition()) {\n        if (result && result.index === this.lastIndex) ; else { // use the second matcher result\n          const m2 = this.getMatcher(0);\n          m2.lastIndex = this.lastIndex + 1;\n          result = m2.exec(s);\n        }\n      }\n\n      if (result) {\n        this.regexIndex += result.position + 1;\n        if (this.regexIndex === this.count) {\n          // wrap-around to considering all matches again\n          this.considerAll();\n        }\n      }\n\n      return result;\n    }\n  }\n\n  /**\n   * Given a mode, builds a huge ResumableMultiRegex that can be used to walk\n   * the content and find matches.\n   *\n   * @param {CompiledMode} mode\n   * @returns {ResumableMultiRegex}\n   */\n  function buildModeRegex(mode) {\n    const mm = new ResumableMultiRegex();\n\n    mode.contains.forEach(term => mm.addRule(term.begin, { rule: term, type: \"begin\" }));\n\n    if (mode.terminatorEnd) {\n      mm.addRule(mode.terminatorEnd, { type: \"end\" });\n    }\n    if (mode.illegal) {\n      mm.addRule(mode.illegal, { type: \"illegal\" });\n    }\n\n    return mm;\n  }\n\n  /** skip vs abort vs ignore\n   *\n   * @skip   - The mode is still entered and exited normally (and contains rules apply),\n   *           but all content is held and added to the parent buffer rather than being\n   *           output when the mode ends.  Mostly used with `sublanguage` to build up\n   *           a single large buffer than can be parsed by sublanguage.\n   *\n   *             - The mode begin ands ends normally.\n   *             - Content matched is added to the parent mode buffer.\n   *             - The parser cursor is moved forward normally.\n   *\n   * @abort  - A hack placeholder until we have ignore.  Aborts the mode (as if it\n   *           never matched) but DOES NOT continue to match subsequent `contains`\n   *           modes.  Abort is bad/suboptimal because it can result in modes\n   *           farther down not getting applied because an earlier rule eats the\n   *           content but then aborts.\n   *\n   *             - The mode does not begin.\n   *             - Content matched by `begin` is added to the mode buffer.\n   *             - The parser cursor is moved forward accordingly.\n   *\n   * @ignore - Ignores the mode (as if it never matched) and continues to match any\n   *           subsequent `contains` modes.  Ignore isn't technically possible with\n   *           the current parser implementation.\n   *\n   *             - The mode does not begin.\n   *             - Content matched by `begin` is ignored.\n   *             - The parser cursor is not moved forward.\n   */\n\n  /**\n   * Compiles an individual mode\n   *\n   * This can raise an error if the mode contains certain detectable known logic\n   * issues.\n   * @param {Mode} mode\n   * @param {CompiledMode | null} [parent]\n   * @returns {CompiledMode | never}\n   */\n  function compileMode(mode, parent) {\n    const cmode = /** @type CompiledMode */ (mode);\n    if (mode.isCompiled) return cmode;\n\n    [\n      scopeClassName,\n      // do this early so compiler extensions generally don't have to worry about\n      // the distinction between match/begin\n      compileMatch,\n      MultiClass,\n      beforeMatchExt\n    ].forEach(ext => ext(mode, parent));\n\n    language.compilerExtensions.forEach(ext => ext(mode, parent));\n\n    // __beforeBegin is considered private API, internal use only\n    mode.__beforeBegin = null;\n\n    [\n      beginKeywords,\n      // do this later so compiler extensions that come earlier have access to the\n      // raw array if they wanted to perhaps manipulate it, etc.\n      compileIllegal,\n      // default to 1 relevance if not specified\n      compileRelevance\n    ].forEach(ext => ext(mode, parent));\n\n    mode.isCompiled = true;\n\n    let keywordPattern = null;\n    if (typeof mode.keywords === \"object\" && mode.keywords.$pattern) {\n      // we need a copy because keywords might be compiled multiple times\n      // so we can't go deleting $pattern from the original on the first\n      // pass\n      mode.keywords = Object.assign({}, mode.keywords);\n      keywordPattern = mode.keywords.$pattern;\n      delete mode.keywords.$pattern;\n    }\n    keywordPattern = keywordPattern || /\\w+/;\n\n    if (mode.keywords) {\n      mode.keywords = compileKeywords(mode.keywords, language.case_insensitive);\n    }\n\n    cmode.keywordPatternRe = langRe(keywordPattern, true);\n\n    if (parent) {\n      if (!mode.begin) mode.begin = /\\B|\\b/;\n      cmode.beginRe = langRe(mode.begin);\n      if (!mode.end && !mode.endsWithParent) mode.end = /\\B|\\b/;\n      if (mode.end) cmode.endRe = langRe(mode.end);\n      cmode.terminatorEnd = source(mode.end) || '';\n      if (mode.endsWithParent && parent.terminatorEnd) {\n        cmode.terminatorEnd += (mode.end ? '|' : '') + parent.terminatorEnd;\n      }\n    }\n    if (mode.illegal) cmode.illegalRe = langRe(/** @type {RegExp | string} */ (mode.illegal));\n    if (!mode.contains) mode.contains = [];\n\n    mode.contains = [].concat(...mode.contains.map(function(c) {\n      return expandOrCloneMode(c === 'self' ? mode : c);\n    }));\n    mode.contains.forEach(function(c) { compileMode(/** @type Mode */ (c), cmode); });\n\n    if (mode.starts) {\n      compileMode(mode.starts, parent);\n    }\n\n    cmode.matcher = buildModeRegex(cmode);\n    return cmode;\n  }\n\n  if (!language.compilerExtensions) language.compilerExtensions = [];\n\n  // self is not valid at the top-level\n  if (language.contains && language.contains.includes('self')) {\n    throw new Error(\"ERR: contains `self` is not supported at the top-level of a language.  See documentation.\");\n  }\n\n  // we need a null object, which inherit will guarantee\n  language.classNameAliases = inherit$1(language.classNameAliases || {});\n\n  return compileMode(/** @type Mode */ (language));\n}\n\n/**\n * Determines if a mode has a dependency on it's parent or not\n *\n * If a mode does have a parent dependency then often we need to clone it if\n * it's used in multiple places so that each copy points to the correct parent,\n * where-as modes without a parent can often safely be re-used at the bottom of\n * a mode chain.\n *\n * @param {Mode | null} mode\n * @returns {boolean} - is there a dependency on the parent?\n * */\nfunction dependencyOnParent(mode) {\n  if (!mode) return false;\n\n  return mode.endsWithParent || dependencyOnParent(mode.starts);\n}\n\n/**\n * Expands a mode or clones it if necessary\n *\n * This is necessary for modes with parental dependenceis (see notes on\n * `dependencyOnParent`) and for nodes that have `variants` - which must then be\n * exploded into their own individual modes at compile time.\n *\n * @param {Mode} mode\n * @returns {Mode | Mode[]}\n * */\nfunction expandOrCloneMode(mode) {\n  if (mode.variants && !mode.cachedVariants) {\n    mode.cachedVariants = mode.variants.map(function(variant) {\n      return inherit$1(mode, { variants: null }, variant);\n    });\n  }\n\n  // EXPAND\n  // if we have variants then essentially \"replace\" the mode with the variants\n  // this happens in compileMode, where this function is called from\n  if (mode.cachedVariants) {\n    return mode.cachedVariants;\n  }\n\n  // CLONE\n  // if we have dependencies on parents then we need a unique\n  // instance of ourselves, so we can be reused with many\n  // different parents without issue\n  if (dependencyOnParent(mode)) {\n    return inherit$1(mode, { starts: mode.starts ? inherit$1(mode.starts) : null });\n  }\n\n  if (Object.isFrozen(mode)) {\n    return inherit$1(mode);\n  }\n\n  // no special dependency issues, just return ourselves\n  return mode;\n}\n\nvar version = \"11.2.0\";\n\n/*\nSyntax highlighting with language autodetection.\nhttps://highlightjs.org/\n*/\n\n/**\n@typedef {import('highlight.js').Mode} Mode\n@typedef {import('highlight.js').CompiledMode} CompiledMode\n@typedef {import('highlight.js').Language} Language\n@typedef {import('highlight.js').HLJSApi} HLJSApi\n@typedef {import('highlight.js').HLJSPlugin} HLJSPlugin\n@typedef {import('highlight.js').PluginEvent} PluginEvent\n@typedef {import('highlight.js').HLJSOptions} HLJSOptions\n@typedef {import('highlight.js').LanguageFn} LanguageFn\n@typedef {import('highlight.js').HighlightedHTMLElement} HighlightedHTMLElement\n@typedef {import('highlight.js').BeforeHighlightContext} BeforeHighlightContext\n@typedef {import('highlight.js/private').MatchType} MatchType\n@typedef {import('highlight.js/private').KeywordData} KeywordData\n@typedef {import('highlight.js/private').EnhancedMatch} EnhancedMatch\n@typedef {import('highlight.js/private').AnnotatedError} AnnotatedError\n@typedef {import('highlight.js').AutoHighlightResult} AutoHighlightResult\n@typedef {import('highlight.js').HighlightOptions} HighlightOptions\n@typedef {import('highlight.js').HighlightResult} HighlightResult\n*/\n\n\nconst escape = escapeHTML;\nconst inherit = inherit$1;\nconst NO_MATCH = Symbol(\"nomatch\");\nconst MAX_KEYWORD_HITS = 7;\n\n/**\n * @param {any} hljs - object that is extended (legacy)\n * @returns {HLJSApi}\n */\nconst HLJS = function(hljs) {\n  // Global internal variables used within the highlight.js library.\n  /** @type {Record<string, Language>} */\n  const languages = Object.create(null);\n  /** @type {Record<string, string>} */\n  const aliases = Object.create(null);\n  /** @type {HLJSPlugin[]} */\n  const plugins = [];\n\n  // safe/production mode - swallows more errors, tries to keep running\n  // even if a single syntax or parse hits a fatal error\n  let SAFE_MODE = true;\n  const LANGUAGE_NOT_FOUND = \"Could not find the language '{}', did you forget to load/include a language module?\";\n  /** @type {Language} */\n  const PLAINTEXT_LANGUAGE = { disableAutodetect: true, name: 'Plain text', contains: [] };\n\n  // Global options used when within external APIs. This is modified when\n  // calling the `hljs.configure` function.\n  /** @type HLJSOptions */\n  let options = {\n    ignoreUnescapedHTML: false,\n    noHighlightRe: /^(no-?highlight)$/i,\n    languageDetectRe: /\\blang(?:uage)?-([\\w-]+)\\b/i,\n    classPrefix: 'hljs-',\n    cssSelector: 'pre code',\n    languages: null,\n    // beta configuration options, subject to change, welcome to discuss\n    // https://github.com/highlightjs/highlight.js/issues/1086\n    __emitter: TokenTreeEmitter\n  };\n\n  /* Utility functions */\n\n  /**\n   * Tests a language name to see if highlighting should be skipped\n   * @param {string} languageName\n   */\n  function shouldNotHighlight(languageName) {\n    return options.noHighlightRe.test(languageName);\n  }\n\n  /**\n   * @param {HighlightedHTMLElement} block - the HTML element to determine language for\n   */\n  function blockLanguage(block) {\n    let classes = block.className + ' ';\n\n    classes += block.parentNode ? block.parentNode.className : '';\n\n    // language-* takes precedence over non-prefixed class names.\n    const match = options.languageDetectRe.exec(classes);\n    if (match) {\n      const language = getLanguage(match[1]);\n      if (!language) {\n        warn(LANGUAGE_NOT_FOUND.replace(\"{}\", match[1]));\n        warn(\"Falling back to no-highlight mode for this block.\", block);\n      }\n      return language ? match[1] : 'no-highlight';\n    }\n\n    return classes\n      .split(/\\s+/)\n      .find((_class) => shouldNotHighlight(_class) || getLanguage(_class));\n  }\n\n  /**\n   * Core highlighting function.\n   *\n   * OLD API\n   * highlight(lang, code, ignoreIllegals, continuation)\n   *\n   * NEW API\n   * highlight(code, {lang, ignoreIllegals})\n   *\n   * @param {string} codeOrLanguageName - the language to use for highlighting\n   * @param {string | HighlightOptions} optionsOrCode - the code to highlight\n   * @param {boolean} [ignoreIllegals] - whether to ignore illegal matches, default is to bail\n   *\n   * @returns {HighlightResult} Result - an object that represents the result\n   * @property {string} language - the language name\n   * @property {number} relevance - the relevance score\n   * @property {string} value - the highlighted HTML code\n   * @property {string} code - the original raw code\n   * @property {CompiledMode} top - top of the current mode stack\n   * @property {boolean} illegal - indicates whether any illegal matches were found\n  */\n  function highlight(codeOrLanguageName, optionsOrCode, ignoreIllegals) {\n    let code = \"\";\n    let languageName = \"\";\n    if (typeof optionsOrCode === \"object\") {\n      code = codeOrLanguageName;\n      ignoreIllegals = optionsOrCode.ignoreIllegals;\n      languageName = optionsOrCode.language;\n    } else {\n      // old API\n      deprecated(\"10.7.0\", \"highlight(lang, code, ...args) has been deprecated.\");\n      deprecated(\"10.7.0\", \"Please use highlight(code, options) instead.\\nhttps://github.com/highlightjs/highlight.js/issues/2277\");\n      languageName = codeOrLanguageName;\n      code = optionsOrCode;\n    }\n\n    // https://github.com/highlightjs/highlight.js/issues/3149\n    // eslint-disable-next-line no-undefined\n    if (ignoreIllegals === undefined) { ignoreIllegals = true; }\n\n    /** @type {BeforeHighlightContext} */\n    const context = {\n      code,\n      language: languageName\n    };\n    // the plugin can change the desired language or the code to be highlighted\n    // just be changing the object it was passed\n    fire(\"before:highlight\", context);\n\n    // a before plugin can usurp the result completely by providing it's own\n    // in which case we don't even need to call highlight\n    const result = context.result\n      ? context.result\n      : _highlight(context.language, context.code, ignoreIllegals);\n\n    result.code = context.code;\n    // the plugin can change anything in result to suite it\n    fire(\"after:highlight\", result);\n\n    return result;\n  }\n\n  /**\n   * private highlight that's used internally and does not fire callbacks\n   *\n   * @param {string} languageName - the language to use for highlighting\n   * @param {string} codeToHighlight - the code to highlight\n   * @param {boolean?} [ignoreIllegals] - whether to ignore illegal matches, default is to bail\n   * @param {CompiledMode?} [continuation] - current continuation mode, if any\n   * @returns {HighlightResult} - result of the highlight operation\n  */\n  function _highlight(languageName, codeToHighlight, ignoreIllegals, continuation) {\n    const keywordHits = Object.create(null);\n\n    /**\n     * Return keyword data if a match is a keyword\n     * @param {CompiledMode} mode - current mode\n     * @param {string} matchText - the textual match\n     * @returns {KeywordData | false}\n     */\n    function keywordData(mode, matchText) {\n      return mode.keywords[matchText];\n    }\n\n    function processKeywords() {\n      if (!top.keywords) {\n        emitter.addText(modeBuffer);\n        return;\n      }\n\n      let lastIndex = 0;\n      top.keywordPatternRe.lastIndex = 0;\n      let match = top.keywordPatternRe.exec(modeBuffer);\n      let buf = \"\";\n\n      while (match) {\n        buf += modeBuffer.substring(lastIndex, match.index);\n        const word = language.case_insensitive ? match[0].toLowerCase() : match[0];\n        const data = keywordData(top, word);\n        if (data) {\n          const [kind, keywordRelevance] = data;\n          emitter.addText(buf);\n          buf = \"\";\n\n          keywordHits[word] = (keywordHits[word] || 0) + 1;\n          if (keywordHits[word] <= MAX_KEYWORD_HITS) relevance += keywordRelevance;\n          if (kind.startsWith(\"_\")) {\n            // _ implied for relevance only, do not highlight\n            // by applying a class name\n            buf += match[0];\n          } else {\n            const cssClass = language.classNameAliases[kind] || kind;\n            emitter.addKeyword(match[0], cssClass);\n          }\n        } else {\n          buf += match[0];\n        }\n        lastIndex = top.keywordPatternRe.lastIndex;\n        match = top.keywordPatternRe.exec(modeBuffer);\n      }\n      buf += modeBuffer.substr(lastIndex);\n      emitter.addText(buf);\n    }\n\n    function processSubLanguage() {\n      if (modeBuffer === \"\") return;\n      /** @type HighlightResult */\n      let result = null;\n\n      if (typeof top.subLanguage === 'string') {\n        if (!languages[top.subLanguage]) {\n          emitter.addText(modeBuffer);\n          return;\n        }\n        result = _highlight(top.subLanguage, modeBuffer, true, continuations[top.subLanguage]);\n        continuations[top.subLanguage] = /** @type {CompiledMode} */ (result._top);\n      } else {\n        result = highlightAuto(modeBuffer, top.subLanguage.length ? top.subLanguage : null);\n      }\n\n      // Counting embedded language score towards the host language may be disabled\n      // with zeroing the containing mode relevance. Use case in point is Markdown that\n      // allows XML everywhere and makes every XML snippet to have a much larger Markdown\n      // score.\n      if (top.relevance > 0) {\n        relevance += result.relevance;\n      }\n      emitter.addSublanguage(result._emitter, result.language);\n    }\n\n    function processBuffer() {\n      if (top.subLanguage != null) {\n        processSubLanguage();\n      } else {\n        processKeywords();\n      }\n      modeBuffer = '';\n    }\n\n    /**\n     * @param {CompiledMode} mode\n     * @param {RegExpMatchArray} match\n     */\n    function emitMultiClass(scope, match) {\n      let i = 1;\n      // eslint-disable-next-line no-undefined\n      while (match[i] !== undefined) {\n        if (!scope._emit[i]) { i++; continue; }\n        const klass = language.classNameAliases[scope[i]] || scope[i];\n        const text = match[i];\n        if (klass) {\n          emitter.addKeyword(text, klass);\n        } else {\n          modeBuffer = text;\n          processKeywords();\n          modeBuffer = \"\";\n        }\n        i++;\n      }\n    }\n\n    /**\n     * @param {CompiledMode} mode - new mode to start\n     * @param {RegExpMatchArray} match\n     */\n    function startNewMode(mode, match) {\n      if (mode.scope && typeof mode.scope === \"string\") {\n        emitter.openNode(language.classNameAliases[mode.scope] || mode.scope);\n      }\n      if (mode.beginScope) {\n        // beginScope just wraps the begin match itself in a scope\n        if (mode.beginScope._wrap) {\n          emitter.addKeyword(modeBuffer, language.classNameAliases[mode.beginScope._wrap] || mode.beginScope._wrap);\n          modeBuffer = \"\";\n        } else if (mode.beginScope._multi) {\n          // at this point modeBuffer should just be the match\n          emitMultiClass(mode.beginScope, match);\n          modeBuffer = \"\";\n        }\n      }\n\n      top = Object.create(mode, { parent: { value: top } });\n      return top;\n    }\n\n    /**\n     * @param {CompiledMode } mode - the mode to potentially end\n     * @param {RegExpMatchArray} match - the latest match\n     * @param {string} matchPlusRemainder - match plus remainder of content\n     * @returns {CompiledMode | void} - the next mode, or if void continue on in current mode\n     */\n    function endOfMode(mode, match, matchPlusRemainder) {\n      let matched = startsWith(mode.endRe, matchPlusRemainder);\n\n      if (matched) {\n        if (mode[\"on:end\"]) {\n          const resp = new Response(mode);\n          mode[\"on:end\"](match, resp);\n          if (resp.isMatchIgnored) matched = false;\n        }\n\n        if (matched) {\n          while (mode.endsParent && mode.parent) {\n            mode = mode.parent;\n          }\n          return mode;\n        }\n      }\n      // even if on:end fires an `ignore` it's still possible\n      // that we might trigger the end node because of a parent mode\n      if (mode.endsWithParent) {\n        return endOfMode(mode.parent, match, matchPlusRemainder);\n      }\n    }\n\n    /**\n     * Handle matching but then ignoring a sequence of text\n     *\n     * @param {string} lexeme - string containing full match text\n     */\n    function doIgnore(lexeme) {\n      if (top.matcher.regexIndex === 0) {\n        // no more regexes to potentially match here, so we move the cursor forward one\n        // space\n        modeBuffer += lexeme[0];\n        return 1;\n      } else {\n        // no need to move the cursor, we still have additional regexes to try and\n        // match at this very spot\n        resumeScanAtSamePosition = true;\n        return 0;\n      }\n    }\n\n    /**\n     * Handle the start of a new potential mode match\n     *\n     * @param {EnhancedMatch} match - the current match\n     * @returns {number} how far to advance the parse cursor\n     */\n    function doBeginMatch(match) {\n      const lexeme = match[0];\n      const newMode = match.rule;\n\n      const resp = new Response(newMode);\n      // first internal before callbacks, then the public ones\n      const beforeCallbacks = [newMode.__beforeBegin, newMode[\"on:begin\"]];\n      for (const cb of beforeCallbacks) {\n        if (!cb) continue;\n        cb(match, resp);\n        if (resp.isMatchIgnored) return doIgnore(lexeme);\n      }\n\n      if (newMode.skip) {\n        modeBuffer += lexeme;\n      } else {\n        if (newMode.excludeBegin) {\n          modeBuffer += lexeme;\n        }\n        processBuffer();\n        if (!newMode.returnBegin && !newMode.excludeBegin) {\n          modeBuffer = lexeme;\n        }\n      }\n      startNewMode(newMode, match);\n      return newMode.returnBegin ? 0 : lexeme.length;\n    }\n\n    /**\n     * Handle the potential end of mode\n     *\n     * @param {RegExpMatchArray} match - the current match\n     */\n    function doEndMatch(match) {\n      const lexeme = match[0];\n      const matchPlusRemainder = codeToHighlight.substr(match.index);\n\n      const endMode = endOfMode(top, match, matchPlusRemainder);\n      if (!endMode) { return NO_MATCH; }\n\n      const origin = top;\n      if (top.endScope && top.endScope._wrap) {\n        processBuffer();\n        emitter.addKeyword(lexeme, top.endScope._wrap);\n      } else if (top.endScope && top.endScope._multi) {\n        processBuffer();\n        emitMultiClass(top.endScope, match);\n      } else if (origin.skip) {\n        modeBuffer += lexeme;\n      } else {\n        if (!(origin.returnEnd || origin.excludeEnd)) {\n          modeBuffer += lexeme;\n        }\n        processBuffer();\n        if (origin.excludeEnd) {\n          modeBuffer = lexeme;\n        }\n      }\n      do {\n        if (top.scope) {\n          emitter.closeNode();\n        }\n        if (!top.skip && !top.subLanguage) {\n          relevance += top.relevance;\n        }\n        top = top.parent;\n      } while (top !== endMode.parent);\n      if (endMode.starts) {\n        startNewMode(endMode.starts, match);\n      }\n      return origin.returnEnd ? 0 : lexeme.length;\n    }\n\n    function processContinuations() {\n      const list = [];\n      for (let current = top; current !== language; current = current.parent) {\n        if (current.scope) {\n          list.unshift(current.scope);\n        }\n      }\n      list.forEach(item => emitter.openNode(item));\n    }\n\n    /** @type {{type?: MatchType, index?: number, rule?: Mode}}} */\n    let lastMatch = {};\n\n    /**\n     *  Process an individual match\n     *\n     * @param {string} textBeforeMatch - text preceding the match (since the last match)\n     * @param {EnhancedMatch} [match] - the match itself\n     */\n    function processLexeme(textBeforeMatch, match) {\n      const lexeme = match && match[0];\n\n      // add non-matched text to the current mode buffer\n      modeBuffer += textBeforeMatch;\n\n      if (lexeme == null) {\n        processBuffer();\n        return 0;\n      }\n\n      // we've found a 0 width match and we're stuck, so we need to advance\n      // this happens when we have badly behaved rules that have optional matchers to the degree that\n      // sometimes they can end up matching nothing at all\n      // Ref: https://github.com/highlightjs/highlight.js/issues/2140\n      if (lastMatch.type === \"begin\" && match.type === \"end\" && lastMatch.index === match.index && lexeme === \"\") {\n        // spit the \"skipped\" character that our regex choked on back into the output sequence\n        modeBuffer += codeToHighlight.slice(match.index, match.index + 1);\n        if (!SAFE_MODE) {\n          /** @type {AnnotatedError} */\n          const err = new Error(`0 width match regex (${languageName})`);\n          err.languageName = languageName;\n          err.badRule = lastMatch.rule;\n          throw err;\n        }\n        return 1;\n      }\n      lastMatch = match;\n\n      if (match.type === \"begin\") {\n        return doBeginMatch(match);\n      } else if (match.type === \"illegal\" && !ignoreIllegals) {\n        // illegal match, we do not continue processing\n        /** @type {AnnotatedError} */\n        const err = new Error('Illegal lexeme \"' + lexeme + '\" for mode \"' + (top.scope || '<unnamed>') + '\"');\n        err.mode = top;\n        throw err;\n      } else if (match.type === \"end\") {\n        const processed = doEndMatch(match);\n        if (processed !== NO_MATCH) {\n          return processed;\n        }\n      }\n\n      // edge case for when illegal matches $ (end of line) which is technically\n      // a 0 width match but not a begin/end match so it's not caught by the\n      // first handler (when ignoreIllegals is true)\n      if (match.type === \"illegal\" && lexeme === \"\") {\n        // advance so we aren't stuck in an infinite loop\n        return 1;\n      }\n\n      // infinite loops are BAD, this is a last ditch catch all. if we have a\n      // decent number of iterations yet our index (cursor position in our\n      // parsing) still 3x behind our index then something is very wrong\n      // so we bail\n      if (iterations > 100000 && iterations > match.index * 3) {\n        const err = new Error('potential infinite loop, way more iterations than matches');\n        throw err;\n      }\n\n      /*\n      Why might be find ourselves here?  An potential end match that was\n      triggered but could not be completed.  IE, `doEndMatch` returned NO_MATCH.\n      (this could be because a callback requests the match be ignored, etc)\n\n      This causes no real harm other than stopping a few times too many.\n      */\n\n      modeBuffer += lexeme;\n      return lexeme.length;\n    }\n\n    const language = getLanguage(languageName);\n    if (!language) {\n      error(LANGUAGE_NOT_FOUND.replace(\"{}\", languageName));\n      throw new Error('Unknown language: \"' + languageName + '\"');\n    }\n\n    const md = compileLanguage(language);\n    let result = '';\n    /** @type {CompiledMode} */\n    let top = continuation || md;\n    /** @type Record<string,CompiledMode> */\n    const continuations = {}; // keep continuations for sub-languages\n    const emitter = new options.__emitter(options);\n    processContinuations();\n    let modeBuffer = '';\n    let relevance = 0;\n    let index = 0;\n    let iterations = 0;\n    let resumeScanAtSamePosition = false;\n\n    try {\n      top.matcher.considerAll();\n\n      for (;;) {\n        iterations++;\n        if (resumeScanAtSamePosition) {\n          // only regexes not matched previously will now be\n          // considered for a potential match\n          resumeScanAtSamePosition = false;\n        } else {\n          top.matcher.considerAll();\n        }\n        top.matcher.lastIndex = index;\n\n        const match = top.matcher.exec(codeToHighlight);\n        // console.log(\"match\", match[0], match.rule && match.rule.begin)\n\n        if (!match) break;\n\n        const beforeMatch = codeToHighlight.substring(index, match.index);\n        const processedCount = processLexeme(beforeMatch, match);\n        index = match.index + processedCount;\n      }\n      processLexeme(codeToHighlight.substr(index));\n      emitter.closeAllNodes();\n      emitter.finalize();\n      result = emitter.toHTML();\n\n      return {\n        language: languageName,\n        value: result,\n        relevance: relevance,\n        illegal: false,\n        _emitter: emitter,\n        _top: top\n      };\n    } catch (err) {\n      if (err.message && err.message.includes('Illegal')) {\n        return {\n          language: languageName,\n          value: escape(codeToHighlight),\n          illegal: true,\n          relevance: 0,\n          _illegalBy: {\n            message: err.message,\n            index: index,\n            context: codeToHighlight.slice(index - 100, index + 100),\n            mode: err.mode,\n            resultSoFar: result\n          },\n          _emitter: emitter\n        };\n      } else if (SAFE_MODE) {\n        return {\n          language: languageName,\n          value: escape(codeToHighlight),\n          illegal: false,\n          relevance: 0,\n          errorRaised: err,\n          _emitter: emitter,\n          _top: top\n        };\n      } else {\n        throw err;\n      }\n    }\n  }\n\n  /**\n   * returns a valid highlight result, without actually doing any actual work,\n   * auto highlight starts with this and it's possible for small snippets that\n   * auto-detection may not find a better match\n   * @param {string} code\n   * @returns {HighlightResult}\n   */\n  function justTextHighlightResult(code) {\n    const result = {\n      value: escape(code),\n      illegal: false,\n      relevance: 0,\n      _top: PLAINTEXT_LANGUAGE,\n      _emitter: new options.__emitter(options)\n    };\n    result._emitter.addText(code);\n    return result;\n  }\n\n  /**\n  Highlighting with language detection. Accepts a string with the code to\n  highlight. Returns an object with the following properties:\n\n  - language (detected language)\n  - relevance (int)\n  - value (an HTML string with highlighting markup)\n  - secondBest (object with the same structure for second-best heuristically\n    detected language, may be absent)\n\n    @param {string} code\n    @param {Array<string>} [languageSubset]\n    @returns {AutoHighlightResult}\n  */\n  function highlightAuto(code, languageSubset) {\n    languageSubset = languageSubset || options.languages || Object.keys(languages);\n    const plaintext = justTextHighlightResult(code);\n\n    const results = languageSubset.filter(getLanguage).filter(autoDetection).map(name =>\n      _highlight(name, code, false)\n    );\n    results.unshift(plaintext); // plaintext is always an option\n\n    const sorted = results.sort((a, b) => {\n      // sort base on relevance\n      if (a.relevance !== b.relevance) return b.relevance - a.relevance;\n\n      // always award the tie to the base language\n      // ie if C++ and Arduino are tied, it's more likely to be C++\n      if (a.language && b.language) {\n        if (getLanguage(a.language).supersetOf === b.language) {\n          return 1;\n        } else if (getLanguage(b.language).supersetOf === a.language) {\n          return -1;\n        }\n      }\n\n      // otherwise say they are equal, which has the effect of sorting on\n      // relevance while preserving the original ordering - which is how ties\n      // have historically been settled, ie the language that comes first always\n      // wins in the case of a tie\n      return 0;\n    });\n\n    const [best, secondBest] = sorted;\n\n    /** @type {AutoHighlightResult} */\n    const result = best;\n    result.secondBest = secondBest;\n\n    return result;\n  }\n\n  /**\n   * Builds new class name for block given the language name\n   *\n   * @param {HTMLElement} element\n   * @param {string} [currentLang]\n   * @param {string} [resultLang]\n   */\n  function updateClassName(element, currentLang, resultLang) {\n    const language = (currentLang && aliases[currentLang]) || resultLang;\n\n    element.classList.add(\"hljs\");\n    element.classList.add(`language-${language}`);\n  }\n\n  /**\n   * Applies highlighting to a DOM node containing code.\n   *\n   * @param {HighlightedHTMLElement} element - the HTML element to highlight\n  */\n  function highlightElement(element) {\n    /** @type HTMLElement */\n    let node = null;\n    const language = blockLanguage(element);\n\n    if (shouldNotHighlight(language)) return;\n\n    fire(\"before:highlightElement\",\n      { el: element, language: language });\n\n    // we should be all text, no child nodes\n    if (!options.ignoreUnescapedHTML && element.children.length > 0) {\n      console.warn(\"One of your code blocks includes unescaped HTML. This is a potentially serious security risk.\");\n      console.warn(\"https://github.com/highlightjs/highlight.js/issues/2886\");\n      console.warn(element);\n    }\n\n    node = element;\n    const text = node.textContent;\n    const result = language ? highlight(text, { language, ignoreIllegals: true }) : highlightAuto(text);\n\n    element.innerHTML = result.value;\n    updateClassName(element, language, result.language);\n    element.result = {\n      language: result.language,\n      // TODO: remove with version 11.0\n      re: result.relevance,\n      relevance: result.relevance\n    };\n    if (result.secondBest) {\n      element.secondBest = {\n        language: result.secondBest.language,\n        relevance: result.secondBest.relevance\n      };\n    }\n\n    fire(\"after:highlightElement\", { el: element, result, text });\n  }\n\n  /**\n   * Updates highlight.js global options with the passed options\n   *\n   * @param {Partial<HLJSOptions>} userOptions\n   */\n  function configure(userOptions) {\n    options = inherit(options, userOptions);\n  }\n\n  // TODO: remove v12, deprecated\n  const initHighlighting = () => {\n    highlightAll();\n    deprecated(\"10.6.0\", \"initHighlighting() deprecated.  Use highlightAll() now.\");\n  };\n\n  // TODO: remove v12, deprecated\n  function initHighlightingOnLoad() {\n    highlightAll();\n    deprecated(\"10.6.0\", \"initHighlightingOnLoad() deprecated.  Use highlightAll() now.\");\n  }\n\n  let wantsHighlight = false;\n\n  /**\n   * auto-highlights all pre>code elements on the page\n   */\n  function highlightAll() {\n    // if we are called too early in the loading process\n    if (document.readyState === \"loading\") {\n      wantsHighlight = true;\n      return;\n    }\n\n    const blocks = document.querySelectorAll(options.cssSelector);\n    blocks.forEach(highlightElement);\n  }\n\n  function boot() {\n    // if a highlight was requested before DOM was loaded, do now\n    if (wantsHighlight) highlightAll();\n  }\n\n  // make sure we are in the browser environment\n  if (typeof window !== 'undefined' && window.addEventListener) {\n    window.addEventListener('DOMContentLoaded', boot, false);\n  }\n\n  /**\n   * Register a language grammar module\n   *\n   * @param {string} languageName\n   * @param {LanguageFn} languageDefinition\n   */\n  function registerLanguage(languageName, languageDefinition) {\n    let lang = null;\n    try {\n      lang = languageDefinition(hljs);\n    } catch (error$1) {\n      error(\"Language definition for '{}' could not be registered.\".replace(\"{}\", languageName));\n      // hard or soft error\n      if (!SAFE_MODE) { throw error$1; } else { error(error$1); }\n      // languages that have serious errors are replaced with essentially a\n      // \"plaintext\" stand-in so that the code blocks will still get normal\n      // css classes applied to them - and one bad language won't break the\n      // entire highlighter\n      lang = PLAINTEXT_LANGUAGE;\n    }\n    // give it a temporary name if it doesn't have one in the meta-data\n    if (!lang.name) lang.name = languageName;\n    languages[languageName] = lang;\n    lang.rawDefinition = languageDefinition.bind(null, hljs);\n\n    if (lang.aliases) {\n      registerAliases(lang.aliases, { languageName });\n    }\n  }\n\n  /**\n   * Remove a language grammar module\n   *\n   * @param {string} languageName\n   */\n  function unregisterLanguage(languageName) {\n    delete languages[languageName];\n    for (const alias of Object.keys(aliases)) {\n      if (aliases[alias] === languageName) {\n        delete aliases[alias];\n      }\n    }\n  }\n\n  /**\n   * @returns {string[]} List of language internal names\n   */\n  function listLanguages() {\n    return Object.keys(languages);\n  }\n\n  /**\n   * @param {string} name - name of the language to retrieve\n   * @returns {Language | undefined}\n   */\n  function getLanguage(name) {\n    name = (name || '').toLowerCase();\n    return languages[name] || languages[aliases[name]];\n  }\n\n  /**\n   *\n   * @param {string|string[]} aliasList - single alias or list of aliases\n   * @param {{languageName: string}} opts\n   */\n  function registerAliases(aliasList, { languageName }) {\n    if (typeof aliasList === 'string') {\n      aliasList = [aliasList];\n    }\n    aliasList.forEach(alias => { aliases[alias.toLowerCase()] = languageName; });\n  }\n\n  /**\n   * Determines if a given language has auto-detection enabled\n   * @param {string} name - name of the language\n   */\n  function autoDetection(name) {\n    const lang = getLanguage(name);\n    return lang && !lang.disableAutodetect;\n  }\n\n  /**\n   * Upgrades the old highlightBlock plugins to the new\n   * highlightElement API\n   * @param {HLJSPlugin} plugin\n   */\n  function upgradePluginAPI(plugin) {\n    // TODO: remove with v12\n    if (plugin[\"before:highlightBlock\"] && !plugin[\"before:highlightElement\"]) {\n      plugin[\"before:highlightElement\"] = (data) => {\n        plugin[\"before:highlightBlock\"](\n          Object.assign({ block: data.el }, data)\n        );\n      };\n    }\n    if (plugin[\"after:highlightBlock\"] && !plugin[\"after:highlightElement\"]) {\n      plugin[\"after:highlightElement\"] = (data) => {\n        plugin[\"after:highlightBlock\"](\n          Object.assign({ block: data.el }, data)\n        );\n      };\n    }\n  }\n\n  /**\n   * @param {HLJSPlugin} plugin\n   */\n  function addPlugin(plugin) {\n    upgradePluginAPI(plugin);\n    plugins.push(plugin);\n  }\n\n  /**\n   *\n   * @param {PluginEvent} event\n   * @param {any} args\n   */\n  function fire(event, args) {\n    const cb = event;\n    plugins.forEach(function(plugin) {\n      if (plugin[cb]) {\n        plugin[cb](args);\n      }\n    });\n  }\n\n  /**\n   * DEPRECATED\n   * @param {HighlightedHTMLElement} el\n   */\n  function deprecateHighlightBlock(el) {\n    deprecated(\"10.7.0\", \"highlightBlock will be removed entirely in v12.0\");\n    deprecated(\"10.7.0\", \"Please use highlightElement now.\");\n\n    return highlightElement(el);\n  }\n\n  /* Interface definition */\n  Object.assign(hljs, {\n    highlight,\n    highlightAuto,\n    highlightAll,\n    highlightElement,\n    // TODO: Remove with v12 API\n    highlightBlock: deprecateHighlightBlock,\n    configure,\n    initHighlighting,\n    initHighlightingOnLoad,\n    registerLanguage,\n    unregisterLanguage,\n    listLanguages,\n    getLanguage,\n    registerAliases,\n    autoDetection,\n    inherit,\n    addPlugin\n  });\n\n  hljs.debugMode = function() { SAFE_MODE = false; };\n  hljs.safeMode = function() { SAFE_MODE = true; };\n  hljs.versionString = version;\n\n  for (const key in MODES) {\n    // @ts-ignore\n    if (typeof MODES[key] === \"object\") {\n      // @ts-ignore\n      deepFreeze$1(MODES[key]);\n    }\n  }\n\n  // merge all the modes/regexes into our main object\n  Object.assign(hljs, MODES);\n\n  return hljs;\n};\n\n// export an \"instance\" of the highlighter\nvar highlight = HLJS({});\n\nmodule.exports = highlight;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFlBQVk7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGdCQUFnQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsZ0JBQWdCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSxZQUFZO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsYUFBYTtBQUMxQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBLGFBQWEsd0JBQXdCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVILGdDQUFnQztBQUNoQywrQkFBK0I7QUFDL0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsdUJBQXVCOztBQUV2QiIsInNvdXJjZXMiOlsid2VicGFjazovL21kYy1yZWFjdC8uL25vZGVfbW9kdWxlcy9oaWdobGlnaHQuanMvbGliL2NvcmUuanM/YzQyYSJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgZGVlcEZyZWV6ZUVzNiA9IHtleHBvcnRzOiB7fX07XG5cbmZ1bmN0aW9uIGRlZXBGcmVlemUob2JqKSB7XG4gICAgaWYgKG9iaiBpbnN0YW5jZW9mIE1hcCkge1xuICAgICAgICBvYmouY2xlYXIgPSBvYmouZGVsZXRlID0gb2JqLnNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignbWFwIGlzIHJlYWQtb25seScpO1xuICAgICAgICB9O1xuICAgIH0gZWxzZSBpZiAob2JqIGluc3RhbmNlb2YgU2V0KSB7XG4gICAgICAgIG9iai5hZGQgPSBvYmouY2xlYXIgPSBvYmouZGVsZXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzZXQgaXMgcmVhZC1vbmx5Jyk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gRnJlZXplIHNlbGZcbiAgICBPYmplY3QuZnJlZXplKG9iaik7XG5cbiAgICBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhvYmopLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgdmFyIHByb3AgPSBvYmpbbmFtZV07XG5cbiAgICAgICAgLy8gRnJlZXplIHByb3AgaWYgaXQgaXMgYW4gb2JqZWN0XG4gICAgICAgIGlmICh0eXBlb2YgcHJvcCA9PSAnb2JqZWN0JyAmJiAhT2JqZWN0LmlzRnJvemVuKHByb3ApKSB7XG4gICAgICAgICAgICBkZWVwRnJlZXplKHByb3ApO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gb2JqO1xufVxuXG5kZWVwRnJlZXplRXM2LmV4cG9ydHMgPSBkZWVwRnJlZXplO1xuZGVlcEZyZWV6ZUVzNi5leHBvcnRzLmRlZmF1bHQgPSBkZWVwRnJlZXplO1xuXG52YXIgZGVlcEZyZWV6ZSQxID0gZGVlcEZyZWV6ZUVzNi5leHBvcnRzO1xuXG4vKiogQHR5cGVkZWYge2ltcG9ydCgnaGlnaGxpZ2h0LmpzJykuQ2FsbGJhY2tSZXNwb25zZX0gQ2FsbGJhY2tSZXNwb25zZSAqL1xuLyoqIEB0eXBlZGVmIHtpbXBvcnQoJ2hpZ2hsaWdodC5qcycpLkNvbXBpbGVkTW9kZX0gQ29tcGlsZWRNb2RlICovXG4vKiogQGltcGxlbWVudHMgQ2FsbGJhY2tSZXNwb25zZSAqL1xuXG5jbGFzcyBSZXNwb25zZSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge0NvbXBpbGVkTW9kZX0gbW9kZVxuICAgKi9cbiAgY29uc3RydWN0b3IobW9kZSkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlZmluZWRcbiAgICBpZiAobW9kZS5kYXRhID09PSB1bmRlZmluZWQpIG1vZGUuZGF0YSA9IHt9O1xuXG4gICAgdGhpcy5kYXRhID0gbW9kZS5kYXRhO1xuICAgIHRoaXMuaXNNYXRjaElnbm9yZWQgPSBmYWxzZTtcbiAgfVxuXG4gIGlnbm9yZU1hdGNoKCkge1xuICAgIHRoaXMuaXNNYXRjaElnbm9yZWQgPSB0cnVlO1xuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBlc2NhcGVIVE1MKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZVxuICAgIC5yZXBsYWNlKC8mL2csICcmYW1wOycpXG4gICAgLnJlcGxhY2UoLzwvZywgJyZsdDsnKVxuICAgIC5yZXBsYWNlKC8+L2csICcmZ3Q7JylcbiAgICAucmVwbGFjZSgvXCIvZywgJyZxdW90OycpXG4gICAgLnJlcGxhY2UoLycvZywgJyYjeDI3OycpO1xufVxuXG4vKipcbiAqIHBlcmZvcm1zIGEgc2hhbGxvdyBtZXJnZSBvZiBtdWx0aXBsZSBvYmplY3RzIGludG8gb25lXG4gKlxuICogQHRlbXBsYXRlIFRcbiAqIEBwYXJhbSB7VH0gb3JpZ2luYWxcbiAqIEBwYXJhbSB7UmVjb3JkPHN0cmluZyxhbnk+W119IG9iamVjdHNcbiAqIEByZXR1cm5zIHtUfSBhIHNpbmdsZSBuZXcgb2JqZWN0XG4gKi9cbmZ1bmN0aW9uIGluaGVyaXQkMShvcmlnaW5hbCwgLi4ub2JqZWN0cykge1xuICAvKiogQHR5cGUgUmVjb3JkPHN0cmluZyxhbnk+ICovXG4gIGNvbnN0IHJlc3VsdCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbiAgZm9yIChjb25zdCBrZXkgaW4gb3JpZ2luYWwpIHtcbiAgICByZXN1bHRba2V5XSA9IG9yaWdpbmFsW2tleV07XG4gIH1cbiAgb2JqZWN0cy5mb3JFYWNoKGZ1bmN0aW9uKG9iaikge1xuICAgIGZvciAoY29uc3Qga2V5IGluIG9iaikge1xuICAgICAgcmVzdWx0W2tleV0gPSBvYmpba2V5XTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gLyoqIEB0eXBlIHtUfSAqLyAocmVzdWx0KTtcbn1cblxuLyoqXG4gKiBAdHlwZWRlZiB7b2JqZWN0fSBSZW5kZXJlclxuICogQHByb3BlcnR5IHsodGV4dDogc3RyaW5nKSA9PiB2b2lkfSBhZGRUZXh0XG4gKiBAcHJvcGVydHkgeyhub2RlOiBOb2RlKSA9PiB2b2lkfSBvcGVuTm9kZVxuICogQHByb3BlcnR5IHsobm9kZTogTm9kZSkgPT4gdm9pZH0gY2xvc2VOb2RlXG4gKiBAcHJvcGVydHkgeygpID0+IHN0cmluZ30gdmFsdWVcbiAqL1xuXG4vKiogQHR5cGVkZWYge3traW5kPzogc3RyaW5nLCBzdWJsYW5ndWFnZT86IGJvb2xlYW59fSBOb2RlICovXG4vKiogQHR5cGVkZWYge3t3YWxrOiAocjogUmVuZGVyZXIpID0+IHZvaWR9fSBUcmVlICovXG4vKiogKi9cblxuY29uc3QgU1BBTl9DTE9TRSA9ICc8L3NwYW4+JztcblxuLyoqXG4gKiBEZXRlcm1pbmVzIGlmIGEgbm9kZSBuZWVkcyB0byBiZSB3cmFwcGVkIGluIDxzcGFuPlxuICpcbiAqIEBwYXJhbSB7Tm9kZX0gbm9kZSAqL1xuY29uc3QgZW1pdHNXcmFwcGluZ1RhZ3MgPSAobm9kZSkgPT4ge1xuICByZXR1cm4gISFub2RlLmtpbmQ7XG59O1xuXG4vKipcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICogQHBhcmFtIHt7cHJlZml4OnN0cmluZ319IG9wdGlvbnNcbiAqL1xuY29uc3QgZXhwYW5kU2NvcGVOYW1lID0gKG5hbWUsIHsgcHJlZml4IH0pID0+IHtcbiAgaWYgKG5hbWUuaW5jbHVkZXMoXCIuXCIpKSB7XG4gICAgY29uc3QgcGllY2VzID0gbmFtZS5zcGxpdChcIi5cIik7XG4gICAgcmV0dXJuIFtcbiAgICAgIGAke3ByZWZpeH0ke3BpZWNlcy5zaGlmdCgpfWAsXG4gICAgICAuLi4ocGllY2VzLm1hcCgoeCwgaSkgPT4gYCR7eH0ke1wiX1wiLnJlcGVhdChpICsgMSl9YCkpXG4gICAgXS5qb2luKFwiIFwiKTtcbiAgfVxuICByZXR1cm4gYCR7cHJlZml4fSR7bmFtZX1gO1xufTtcblxuLyoqIEB0eXBlIHtSZW5kZXJlcn0gKi9cbmNsYXNzIEhUTUxSZW5kZXJlciB7XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IEhUTUxSZW5kZXJlclxuICAgKlxuICAgKiBAcGFyYW0ge1RyZWV9IHBhcnNlVHJlZSAtIHRoZSBwYXJzZSB0cmVlIChtdXN0IHN1cHBvcnQgYHdhbGtgIEFQSSlcbiAgICogQHBhcmFtIHt7Y2xhc3NQcmVmaXg6IHN0cmluZ319IG9wdGlvbnNcbiAgICovXG4gIGNvbnN0cnVjdG9yKHBhcnNlVHJlZSwgb3B0aW9ucykge1xuICAgIHRoaXMuYnVmZmVyID0gXCJcIjtcbiAgICB0aGlzLmNsYXNzUHJlZml4ID0gb3B0aW9ucy5jbGFzc1ByZWZpeDtcbiAgICBwYXJzZVRyZWUud2Fsayh0aGlzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIHRleHRzIHRvIHRoZSBvdXRwdXQgc3RyZWFtXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0ICovXG4gIGFkZFRleHQodGV4dCkge1xuICAgIHRoaXMuYnVmZmVyICs9IGVzY2FwZUhUTUwodGV4dCk7XG4gIH1cblxuICAvKipcbiAgICogQWRkcyBhIG5vZGUgb3BlbiB0byB0aGUgb3V0cHV0IHN0cmVhbSAoaWYgbmVlZGVkKVxuICAgKlxuICAgKiBAcGFyYW0ge05vZGV9IG5vZGUgKi9cbiAgb3Blbk5vZGUobm9kZSkge1xuICAgIGlmICghZW1pdHNXcmFwcGluZ1RhZ3Mobm9kZSkpIHJldHVybjtcblxuICAgIGxldCBzY29wZSA9IG5vZGUua2luZDtcbiAgICBpZiAobm9kZS5zdWJsYW5ndWFnZSkge1xuICAgICAgc2NvcGUgPSBgbGFuZ3VhZ2UtJHtzY29wZX1gO1xuICAgIH0gZWxzZSB7XG4gICAgICBzY29wZSA9IGV4cGFuZFNjb3BlTmFtZShzY29wZSwgeyBwcmVmaXg6IHRoaXMuY2xhc3NQcmVmaXggfSk7XG4gICAgfVxuICAgIHRoaXMuc3BhbihzY29wZSk7XG4gIH1cblxuICAvKipcbiAgICogQWRkcyBhIG5vZGUgY2xvc2UgdG8gdGhlIG91dHB1dCBzdHJlYW0gKGlmIG5lZWRlZClcbiAgICpcbiAgICogQHBhcmFtIHtOb2RlfSBub2RlICovXG4gIGNsb3NlTm9kZShub2RlKSB7XG4gICAgaWYgKCFlbWl0c1dyYXBwaW5nVGFncyhub2RlKSkgcmV0dXJuO1xuXG4gICAgdGhpcy5idWZmZXIgKz0gU1BBTl9DTE9TRTtcbiAgfVxuXG4gIC8qKlxuICAgKiByZXR1cm5zIHRoZSBhY2N1bXVsYXRlZCBidWZmZXJcbiAgKi9cbiAgdmFsdWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuYnVmZmVyO1xuICB9XG5cbiAgLy8gaGVscGVyc1xuXG4gIC8qKlxuICAgKiBCdWlsZHMgYSBzcGFuIGVsZW1lbnRcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNsYXNzTmFtZSAqL1xuICBzcGFuKGNsYXNzTmFtZSkge1xuICAgIHRoaXMuYnVmZmVyICs9IGA8c3BhbiBjbGFzcz1cIiR7Y2xhc3NOYW1lfVwiPmA7XG4gIH1cbn1cblxuLyoqIEB0eXBlZGVmIHt7a2luZD86IHN0cmluZywgc3VibGFuZ3VhZ2U/OiBib29sZWFuLCBjaGlsZHJlbjogTm9kZVtdfSB8IHN0cmluZ30gTm9kZSAqL1xuLyoqIEB0eXBlZGVmIHt7a2luZD86IHN0cmluZywgc3VibGFuZ3VhZ2U/OiBib29sZWFuLCBjaGlsZHJlbjogTm9kZVtdfSB9IERhdGFOb2RlICovXG4vKiogQHR5cGVkZWYge2ltcG9ydCgnaGlnaGxpZ2h0LmpzJykuRW1pdHRlcn0gRW1pdHRlciAqL1xuLyoqICAqL1xuXG5jbGFzcyBUb2tlblRyZWUge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICAvKiogQHR5cGUgRGF0YU5vZGUgKi9cbiAgICB0aGlzLnJvb3ROb2RlID0geyBjaGlsZHJlbjogW10gfTtcbiAgICB0aGlzLnN0YWNrID0gW3RoaXMucm9vdE5vZGVdO1xuICB9XG5cbiAgZ2V0IHRvcCgpIHtcbiAgICByZXR1cm4gdGhpcy5zdGFja1t0aGlzLnN0YWNrLmxlbmd0aCAtIDFdO1xuICB9XG5cbiAgZ2V0IHJvb3QoKSB7IHJldHVybiB0aGlzLnJvb3ROb2RlOyB9XG5cbiAgLyoqIEBwYXJhbSB7Tm9kZX0gbm9kZSAqL1xuICBhZGQobm9kZSkge1xuICAgIHRoaXMudG9wLmNoaWxkcmVuLnB1c2gobm9kZSk7XG4gIH1cblxuICAvKiogQHBhcmFtIHtzdHJpbmd9IGtpbmQgKi9cbiAgb3Blbk5vZGUoa2luZCkge1xuICAgIC8qKiBAdHlwZSBOb2RlICovXG4gICAgY29uc3Qgbm9kZSA9IHsga2luZCwgY2hpbGRyZW46IFtdIH07XG4gICAgdGhpcy5hZGQobm9kZSk7XG4gICAgdGhpcy5zdGFjay5wdXNoKG5vZGUpO1xuICB9XG5cbiAgY2xvc2VOb2RlKCkge1xuICAgIGlmICh0aGlzLnN0YWNrLmxlbmd0aCA+IDEpIHtcbiAgICAgIHJldHVybiB0aGlzLnN0YWNrLnBvcCgpO1xuICAgIH1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5kZWZpbmVkXG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuXG4gIGNsb3NlQWxsTm9kZXMoKSB7XG4gICAgd2hpbGUgKHRoaXMuY2xvc2VOb2RlKCkpO1xuICB9XG5cbiAgdG9KU09OKCkge1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh0aGlzLnJvb3ROb2RlLCBudWxsLCA0KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAdHlwZWRlZiB7IGltcG9ydChcIi4vaHRtbF9yZW5kZXJlclwiKS5SZW5kZXJlciB9IFJlbmRlcmVyXG4gICAqIEBwYXJhbSB7UmVuZGVyZXJ9IGJ1aWxkZXJcbiAgICovXG4gIHdhbGsoYnVpbGRlcikge1xuICAgIC8vIHRoaXMgZG9lcyBub3RcbiAgICByZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci5fd2FsayhidWlsZGVyLCB0aGlzLnJvb3ROb2RlKTtcbiAgICAvLyB0aGlzIHdvcmtzXG4gICAgLy8gcmV0dXJuIFRva2VuVHJlZS5fd2FsayhidWlsZGVyLCB0aGlzLnJvb3ROb2RlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1JlbmRlcmVyfSBidWlsZGVyXG4gICAqIEBwYXJhbSB7Tm9kZX0gbm9kZVxuICAgKi9cbiAgc3RhdGljIF93YWxrKGJ1aWxkZXIsIG5vZGUpIHtcbiAgICBpZiAodHlwZW9mIG5vZGUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIGJ1aWxkZXIuYWRkVGV4dChub2RlKTtcbiAgICB9IGVsc2UgaWYgKG5vZGUuY2hpbGRyZW4pIHtcbiAgICAgIGJ1aWxkZXIub3Blbk5vZGUobm9kZSk7XG4gICAgICBub2RlLmNoaWxkcmVuLmZvckVhY2goKGNoaWxkKSA9PiB0aGlzLl93YWxrKGJ1aWxkZXIsIGNoaWxkKSk7XG4gICAgICBidWlsZGVyLmNsb3NlTm9kZShub2RlKTtcbiAgICB9XG4gICAgcmV0dXJuIGJ1aWxkZXI7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtOb2RlfSBub2RlXG4gICAqL1xuICBzdGF0aWMgX2NvbGxhcHNlKG5vZGUpIHtcbiAgICBpZiAodHlwZW9mIG5vZGUgPT09IFwic3RyaW5nXCIpIHJldHVybjtcbiAgICBpZiAoIW5vZGUuY2hpbGRyZW4pIHJldHVybjtcblxuICAgIGlmIChub2RlLmNoaWxkcmVuLmV2ZXJ5KGVsID0+IHR5cGVvZiBlbCA9PT0gXCJzdHJpbmdcIikpIHtcbiAgICAgIC8vIG5vZGUudGV4dCA9IG5vZGUuY2hpbGRyZW4uam9pbihcIlwiKTtcbiAgICAgIC8vIGRlbGV0ZSBub2RlLmNoaWxkcmVuO1xuICAgICAgbm9kZS5jaGlsZHJlbiA9IFtub2RlLmNoaWxkcmVuLmpvaW4oXCJcIildO1xuICAgIH0gZWxzZSB7XG4gICAgICBub2RlLmNoaWxkcmVuLmZvckVhY2goKGNoaWxkKSA9PiB7XG4gICAgICAgIFRva2VuVHJlZS5fY29sbGFwc2UoY2hpbGQpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICBDdXJyZW50bHkgdGhpcyBpcyBhbGwgcHJpdmF0ZSBBUEksIGJ1dCB0aGlzIGlzIHRoZSBtaW5pbWFsIEFQSSBuZWNlc3NhcnlcbiAgdGhhdCBhbiBFbWl0dGVyIG11c3QgaW1wbGVtZW50IHRvIGZ1bGx5IHN1cHBvcnQgdGhlIHBhcnNlci5cblxuICBNaW5pbWFsIGludGVyZmFjZTpcblxuICAtIGFkZEtleXdvcmQodGV4dCwga2luZClcbiAgLSBhZGRUZXh0KHRleHQpXG4gIC0gYWRkU3VibGFuZ3VhZ2UoZW1pdHRlciwgc3ViTGFuZ3VhZ2VOYW1lKVxuICAtIGZpbmFsaXplKClcbiAgLSBvcGVuTm9kZShraW5kKVxuICAtIGNsb3NlTm9kZSgpXG4gIC0gY2xvc2VBbGxOb2RlcygpXG4gIC0gdG9IVE1MKClcblxuKi9cblxuLyoqXG4gKiBAaW1wbGVtZW50cyB7RW1pdHRlcn1cbiAqL1xuY2xhc3MgVG9rZW5UcmVlRW1pdHRlciBleHRlbmRzIFRva2VuVHJlZSB7XG4gIC8qKlxuICAgKiBAcGFyYW0geyp9IG9wdGlvbnNcbiAgICovXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRleHRcbiAgICogQHBhcmFtIHtzdHJpbmd9IGtpbmRcbiAgICovXG4gIGFkZEtleXdvcmQodGV4dCwga2luZCkge1xuICAgIGlmICh0ZXh0ID09PSBcIlwiKSB7IHJldHVybjsgfVxuXG4gICAgdGhpcy5vcGVuTm9kZShraW5kKTtcbiAgICB0aGlzLmFkZFRleHQodGV4dCk7XG4gICAgdGhpcy5jbG9zZU5vZGUoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dFxuICAgKi9cbiAgYWRkVGV4dCh0ZXh0KSB7XG4gICAgaWYgKHRleHQgPT09IFwiXCIpIHsgcmV0dXJuOyB9XG5cbiAgICB0aGlzLmFkZCh0ZXh0KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0VtaXR0ZXIgJiB7cm9vdDogRGF0YU5vZGV9fSBlbWl0dGVyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAqL1xuICBhZGRTdWJsYW5ndWFnZShlbWl0dGVyLCBuYW1lKSB7XG4gICAgLyoqIEB0eXBlIERhdGFOb2RlICovXG4gICAgY29uc3Qgbm9kZSA9IGVtaXR0ZXIucm9vdDtcbiAgICBub2RlLmtpbmQgPSBuYW1lO1xuICAgIG5vZGUuc3VibGFuZ3VhZ2UgPSB0cnVlO1xuICAgIHRoaXMuYWRkKG5vZGUpO1xuICB9XG5cbiAgdG9IVE1MKCkge1xuICAgIGNvbnN0IHJlbmRlcmVyID0gbmV3IEhUTUxSZW5kZXJlcih0aGlzLCB0aGlzLm9wdGlvbnMpO1xuICAgIHJldHVybiByZW5kZXJlci52YWx1ZSgpO1xuICB9XG5cbiAgZmluYWxpemUoKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVcbiAqIEByZXR1cm5zIHtSZWdFeHB9XG4gKiAqL1xuXG4vKipcbiAqIEBwYXJhbSB7UmVnRXhwIHwgc3RyaW5nIH0gcmVcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIHNvdXJjZShyZSkge1xuICBpZiAoIXJlKSByZXR1cm4gbnVsbDtcbiAgaWYgKHR5cGVvZiByZSA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIHJlO1xuXG4gIHJldHVybiByZS5zb3VyY2U7XG59XG5cbi8qKlxuICogQHBhcmFtIHtSZWdFeHAgfCBzdHJpbmcgfSByZVxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gbG9va2FoZWFkKHJlKSB7XG4gIHJldHVybiBjb25jYXQoJyg/PScsIHJlLCAnKScpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7Li4uKFJlZ0V4cCB8IHN0cmluZykgfSBhcmdzXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBjb25jYXQoLi4uYXJncykge1xuICBjb25zdCBqb2luZWQgPSBhcmdzLm1hcCgoeCkgPT4gc291cmNlKHgpKS5qb2luKFwiXCIpO1xuICByZXR1cm4gam9pbmVkO1xufVxuXG5mdW5jdGlvbiBzdHJpcE9wdGlvbnNGcm9tQXJncyhhcmdzKSB7XG4gIGNvbnN0IG9wdHMgPSBhcmdzW2FyZ3MubGVuZ3RoIC0gMV07XG5cbiAgaWYgKHR5cGVvZiBvcHRzID09PSAnb2JqZWN0JyAmJiBvcHRzLmNvbnN0cnVjdG9yID09PSBPYmplY3QpIHtcbiAgICBhcmdzLnNwbGljZShhcmdzLmxlbmd0aCAtIDEsIDEpO1xuICAgIHJldHVybiBvcHRzO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB7fTtcbiAgfVxufVxuXG4vKipcbiAqIEFueSBvZiB0aGUgcGFzc2VkIGV4cHJlc3NzaW9ucyBtYXkgbWF0Y2hcbiAqXG4gKiBDcmVhdGVzIGEgaHVnZSB0aGlzIHwgdGhpcyB8IHRoYXQgfCB0aGF0IG1hdGNoXG4gKiBAcGFyYW0geyhSZWdFeHAgfCBzdHJpbmcpW10gfSBhcmdzXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBlaXRoZXIoLi4uYXJncykge1xuICBjb25zdCBvcHRzID0gc3RyaXBPcHRpb25zRnJvbUFyZ3MoYXJncyk7XG4gIGNvbnN0IGpvaW5lZCA9ICcoJyArXG4gICAgKG9wdHMuY2FwdHVyZSA/IFwiXCIgOiBcIj86XCIpICtcbiAgICBhcmdzLm1hcCgoeCkgPT4gc291cmNlKHgpKS5qb2luKFwifFwiKSArIFwiKVwiO1xuICByZXR1cm4gam9pbmVkO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7UmVnRXhwfSByZVxuICogQHJldHVybnMge251bWJlcn1cbiAqL1xuZnVuY3Rpb24gY291bnRNYXRjaEdyb3VwcyhyZSkge1xuICByZXR1cm4gKG5ldyBSZWdFeHAocmUudG9TdHJpbmcoKSArICd8JykpLmV4ZWMoJycpLmxlbmd0aCAtIDE7XG59XG5cbi8qKlxuICogRG9lcyBsZXhlbWUgc3RhcnQgd2l0aCBhIHJlZ3VsYXIgZXhwcmVzc2lvbiBtYXRjaCBhdCB0aGUgYmVnaW5uaW5nXG4gKiBAcGFyYW0ge1JlZ0V4cH0gcmVcbiAqIEBwYXJhbSB7c3RyaW5nfSBsZXhlbWVcbiAqL1xuZnVuY3Rpb24gc3RhcnRzV2l0aChyZSwgbGV4ZW1lKSB7XG4gIGNvbnN0IG1hdGNoID0gcmUgJiYgcmUuZXhlYyhsZXhlbWUpO1xuICByZXR1cm4gbWF0Y2ggJiYgbWF0Y2guaW5kZXggPT09IDA7XG59XG5cbi8vIEJBQ0tSRUZfUkUgbWF0Y2hlcyBhbiBvcGVuIHBhcmVudGhlc2lzIG9yIGJhY2tyZWZlcmVuY2UuIFRvIGF2b2lkXG4vLyBhbiBpbmNvcnJlY3QgcGFyc2UsIGl0IGFkZGl0aW9uYWxseSBtYXRjaGVzIHRoZSBmb2xsb3dpbmc6XG4vLyAtIFsuLi5dIGVsZW1lbnRzLCB3aGVyZSB0aGUgbWVhbmluZyBvZiBwYXJlbnRoZXNlcyBhbmQgZXNjYXBlcyBjaGFuZ2Vcbi8vIC0gb3RoZXIgZXNjYXBlIHNlcXVlbmNlcywgc28gd2UgZG8gbm90IG1pc3BhcnNlIGVzY2FwZSBzZXF1ZW5jZXMgYXNcbi8vICAgaW50ZXJlc3RpbmcgZWxlbWVudHNcbi8vIC0gbm9uLW1hdGNoaW5nIG9yIGxvb2thaGVhZCBwYXJlbnRoZXNlcywgd2hpY2ggZG8gbm90IGNhcHR1cmUuIFRoZXNlXG4vLyAgIGZvbGxvdyB0aGUgJygnIHdpdGggYSAnPycuXG5jb25zdCBCQUNLUkVGX1JFID0gL1xcWyg/OlteXFxcXFxcXV18XFxcXC4pKlxcXXxcXChcXD8/fFxcXFwoWzEtOV1bMC05XSopfFxcXFwuLztcblxuLy8gKipJTlRFUk5BTCoqIE5vdCBpbnRlbmRlZCBmb3Igb3V0c2lkZSB1c2FnZVxuLy8gam9pbiBsb2dpY2FsbHkgY29tcHV0ZXMgcmVnZXhwcy5qb2luKHNlcGFyYXRvciksIGJ1dCBmaXhlcyB0aGVcbi8vIGJhY2tyZWZlcmVuY2VzIHNvIHRoZXkgY29udGludWUgdG8gbWF0Y2guXG4vLyBpdCBhbHNvIHBsYWNlcyBlYWNoIGluZGl2aWR1YWwgcmVndWxhciBleHByZXNzaW9uIGludG8gaXQncyBvd25cbi8vIG1hdGNoIGdyb3VwLCBrZWVwaW5nIHRyYWNrIG9mIHRoZSBzZXF1ZW5jaW5nIG9mIHRob3NlIG1hdGNoIGdyb3Vwc1xuLy8gaXMgY3VycmVudGx5IGFuIGV4ZXJjaXNlIGZvciB0aGUgY2FsbGVyLiA6LSlcbi8qKlxuICogQHBhcmFtIHsoc3RyaW5nIHwgUmVnRXhwKVtdfSByZWdleHBzXG4gKiBAcGFyYW0ge3tqb2luV2l0aDogc3RyaW5nfX0gb3B0c1xuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gX3Jld3JpdGVCYWNrcmVmZXJlbmNlcyhyZWdleHBzLCB7IGpvaW5XaXRoIH0pIHtcbiAgbGV0IG51bUNhcHR1cmVzID0gMDtcblxuICByZXR1cm4gcmVnZXhwcy5tYXAoKHJlZ2V4KSA9PiB7XG4gICAgbnVtQ2FwdHVyZXMgKz0gMTtcbiAgICBjb25zdCBvZmZzZXQgPSBudW1DYXB0dXJlcztcbiAgICBsZXQgcmUgPSBzb3VyY2UocmVnZXgpO1xuICAgIGxldCBvdXQgPSAnJztcblxuICAgIHdoaWxlIChyZS5sZW5ndGggPiAwKSB7XG4gICAgICBjb25zdCBtYXRjaCA9IEJBQ0tSRUZfUkUuZXhlYyhyZSk7XG4gICAgICBpZiAoIW1hdGNoKSB7XG4gICAgICAgIG91dCArPSByZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBvdXQgKz0gcmUuc3Vic3RyaW5nKDAsIG1hdGNoLmluZGV4KTtcbiAgICAgIHJlID0gcmUuc3Vic3RyaW5nKG1hdGNoLmluZGV4ICsgbWF0Y2hbMF0ubGVuZ3RoKTtcbiAgICAgIGlmIChtYXRjaFswXVswXSA9PT0gJ1xcXFwnICYmIG1hdGNoWzFdKSB7XG4gICAgICAgIC8vIEFkanVzdCB0aGUgYmFja3JlZmVyZW5jZS5cbiAgICAgICAgb3V0ICs9ICdcXFxcJyArIFN0cmluZyhOdW1iZXIobWF0Y2hbMV0pICsgb2Zmc2V0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG91dCArPSBtYXRjaFswXTtcbiAgICAgICAgaWYgKG1hdGNoWzBdID09PSAnKCcpIHtcbiAgICAgICAgICBudW1DYXB0dXJlcysrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvdXQ7XG4gIH0pLm1hcChyZSA9PiBgKCR7cmV9KWApLmpvaW4oam9pbldpdGgpO1xufVxuXG4vKiogQHR5cGVkZWYge2ltcG9ydCgnaGlnaGxpZ2h0LmpzJykuTW9kZX0gTW9kZSAqL1xuLyoqIEB0eXBlZGVmIHtpbXBvcnQoJ2hpZ2hsaWdodC5qcycpLk1vZGVDYWxsYmFja30gTW9kZUNhbGxiYWNrICovXG5cbi8vIENvbW1vbiByZWdleHBzXG5jb25zdCBNQVRDSF9OT1RISU5HX1JFID0gL1xcYlxcQi87XG5jb25zdCBJREVOVF9SRSA9ICdbYS16QS1aXVxcXFx3Kic7XG5jb25zdCBVTkRFUlNDT1JFX0lERU5UX1JFID0gJ1thLXpBLVpfXVxcXFx3Kic7XG5jb25zdCBOVU1CRVJfUkUgPSAnXFxcXGJcXFxcZCsoXFxcXC5cXFxcZCspPyc7XG5jb25zdCBDX05VTUJFUl9SRSA9ICcoLT8pKFxcXFxiMFt4WF1bYS1mQS1GMC05XSt8KFxcXFxiXFxcXGQrKFxcXFwuXFxcXGQqKT98XFxcXC5cXFxcZCspKFtlRV1bLStdP1xcXFxkKyk/KSc7IC8vIDB4Li4uLCAwLi4uLCBkZWNpbWFsLCBmbG9hdFxuY29uc3QgQklOQVJZX05VTUJFUl9SRSA9ICdcXFxcYigwYlswMV0rKSc7IC8vIDBiLi4uXG5jb25zdCBSRV9TVEFSVEVSU19SRSA9ICchfCE9fCE9PXwlfCU9fCZ8JiZ8Jj18XFxcXCp8XFxcXCo9fFxcXFwrfFxcXFwrPXwsfC18LT18Lz18L3w6fDt8PDx8PDw9fDw9fDx8PT09fD09fD18Pj4+PXw+Pj18Pj18Pj4+fD4+fD58XFxcXD98XFxcXFt8XFxcXHt8XFxcXCh8XFxcXF58XFxcXF49fFxcXFx8fFxcXFx8PXxcXFxcfFxcXFx8fH4nO1xuXG4vKipcbiogQHBhcmFtIHsgUGFydGlhbDxNb2RlPiAmIHtiaW5hcnk/OiBzdHJpbmcgfCBSZWdFeHB9IH0gb3B0c1xuKi9cbmNvbnN0IFNIRUJBTkcgPSAob3B0cyA9IHt9KSA9PiB7XG4gIGNvbnN0IGJlZ2luU2hlYmFuZyA9IC9eIyFbIF0qXFwvLztcbiAgaWYgKG9wdHMuYmluYXJ5KSB7XG4gICAgb3B0cy5iZWdpbiA9IGNvbmNhdChcbiAgICAgIGJlZ2luU2hlYmFuZyxcbiAgICAgIC8uKlxcYi8sXG4gICAgICBvcHRzLmJpbmFyeSxcbiAgICAgIC9cXGIuKi8pO1xuICB9XG4gIHJldHVybiBpbmhlcml0JDEoe1xuICAgIHNjb3BlOiAnbWV0YScsXG4gICAgYmVnaW46IGJlZ2luU2hlYmFuZyxcbiAgICBlbmQ6IC8kLyxcbiAgICByZWxldmFuY2U6IDAsXG4gICAgLyoqIEB0eXBlIHtNb2RlQ2FsbGJhY2t9ICovXG4gICAgXCJvbjpiZWdpblwiOiAobSwgcmVzcCkgPT4ge1xuICAgICAgaWYgKG0uaW5kZXggIT09IDApIHJlc3AuaWdub3JlTWF0Y2goKTtcbiAgICB9XG4gIH0sIG9wdHMpO1xufTtcblxuLy8gQ29tbW9uIG1vZGVzXG5jb25zdCBCQUNLU0xBU0hfRVNDQVBFID0ge1xuICBiZWdpbjogJ1xcXFxcXFxcW1xcXFxzXFxcXFNdJywgcmVsZXZhbmNlOiAwXG59O1xuY29uc3QgQVBPU19TVFJJTkdfTU9ERSA9IHtcbiAgc2NvcGU6ICdzdHJpbmcnLFxuICBiZWdpbjogJ1xcJycsXG4gIGVuZDogJ1xcJycsXG4gIGlsbGVnYWw6ICdcXFxcbicsXG4gIGNvbnRhaW5zOiBbQkFDS1NMQVNIX0VTQ0FQRV1cbn07XG5jb25zdCBRVU9URV9TVFJJTkdfTU9ERSA9IHtcbiAgc2NvcGU6ICdzdHJpbmcnLFxuICBiZWdpbjogJ1wiJyxcbiAgZW5kOiAnXCInLFxuICBpbGxlZ2FsOiAnXFxcXG4nLFxuICBjb250YWluczogW0JBQ0tTTEFTSF9FU0NBUEVdXG59O1xuY29uc3QgUEhSQVNBTF9XT1JEU19NT0RFID0ge1xuICBiZWdpbjogL1xcYihhfGFufHRoZXxhcmV8SSdtfGlzbid0fGRvbid0fGRvZXNuJ3R8d29uJ3R8YnV0fGp1c3R8c2hvdWxkfHByZXR0eXxzaW1wbHl8ZW5vdWdofGdvbm5hfGdvaW5nfHd0Znxzb3xzdWNofHdpbGx8eW91fHlvdXJ8dGhleXxsaWtlfG1vcmUpXFxiL1xufTtcbi8qKlxuICogQ3JlYXRlcyBhIGNvbW1lbnQgbW9kZVxuICpcbiAqIEBwYXJhbSB7c3RyaW5nIHwgUmVnRXhwfSBiZWdpblxuICogQHBhcmFtIHtzdHJpbmcgfCBSZWdFeHB9IGVuZFxuICogQHBhcmFtIHtNb2RlIHwge319IFttb2RlT3B0aW9uc11cbiAqIEByZXR1cm5zIHtQYXJ0aWFsPE1vZGU+fVxuICovXG5jb25zdCBDT01NRU5UID0gZnVuY3Rpb24oYmVnaW4sIGVuZCwgbW9kZU9wdGlvbnMgPSB7fSkge1xuICBjb25zdCBtb2RlID0gaW5oZXJpdCQxKFxuICAgIHtcbiAgICAgIHNjb3BlOiAnY29tbWVudCcsXG4gICAgICBiZWdpbixcbiAgICAgIGVuZCxcbiAgICAgIGNvbnRhaW5zOiBbXVxuICAgIH0sXG4gICAgbW9kZU9wdGlvbnNcbiAgKTtcbiAgbW9kZS5jb250YWlucy5wdXNoKHtcbiAgICBzY29wZTogJ2RvY3RhZycsXG4gICAgLy8gaGFjayB0byBhdm9pZCB0aGUgc3BhY2UgZnJvbSBiZWluZyBpbmNsdWRlZC4gdGhlIHNwYWNlIGlzIG5lY2Vzc2FyeSB0b1xuICAgIC8vIG1hdGNoIGhlcmUgdG8gcHJldmVudCB0aGUgcGxhaW4gdGV4dCBydWxlIGJlbG93IGZyb20gZ29iYmxpbmcgdXAgZG9jdGFnc1xuICAgIGJlZ2luOiAnWyBdKig/PShUT0RPfEZJWE1FfE5PVEV8QlVHfE9QVElNSVpFfEhBQ0t8WFhYKTopJyxcbiAgICBlbmQ6IC8oVE9ET3xGSVhNRXxOT1RFfEJVR3xPUFRJTUlaRXxIQUNLfFhYWCk6LyxcbiAgICBleGNsdWRlQmVnaW46IHRydWUsXG4gICAgcmVsZXZhbmNlOiAwXG4gIH0pO1xuICBjb25zdCBFTkdMSVNIX1dPUkQgPSBlaXRoZXIoXG4gICAgLy8gbGlzdCBvZiBjb21tb24gMSBhbmQgMiBsZXR0ZXIgd29yZHMgaW4gRW5nbGlzaFxuICAgIFwiSVwiLFxuICAgIFwiYVwiLFxuICAgIFwiaXNcIixcbiAgICBcInNvXCIsXG4gICAgXCJ1c1wiLFxuICAgIFwidG9cIixcbiAgICBcImF0XCIsXG4gICAgXCJpZlwiLFxuICAgIFwiaW5cIixcbiAgICBcIml0XCIsXG4gICAgXCJvblwiLFxuICAgIC8vIG5vdGU6IHRoaXMgaXMgbm90IGFuIGV4aGF1c3RpdmUgbGlzdCBvZiBjb250cmFjdGlvbnMsIGp1c3QgcG9wdWxhciBvbmVzXG4gICAgL1tBLVphLXpdK1snXShkfHZlfHJlfGxsfHR8c3xuKS8sIC8vIGNvbnRyYWN0aW9ucyAtIGNhbid0IHdlJ2QgdGhleSdyZSBsZXQncywgZXRjXG4gICAgL1tBLVphLXpdK1stXVthLXpdKy8sIC8vIGBuby13YXlgLCBldGMuXG4gICAgL1tBLVphLXpdW2Etel17Mix9LyAvLyBhbGxvdyBjYXBpdGFsaXplZCB3b3JkcyBhdCBiZWdpbm5pbmcgb2Ygc2VudGVuY2VzXG4gICk7XG4gIC8vIGxvb2tpbmcgbGlrZSBwbGFpbiB0ZXh0LCBtb3JlIGxpa2VseSB0byBiZSBhIGNvbW1lbnRcbiAgbW9kZS5jb250YWlucy5wdXNoKFxuICAgIHtcbiAgICAgIC8vIFRPRE86IGhvdyB0byBpbmNsdWRlIFwiLCAoLCApIHdpdGhvdXQgYnJlYWtpbmcgZ3JhbW1hcnMgdGhhdCB1c2UgdGhlc2UgZm9yXG4gICAgICAvLyBjb21tZW50IGRlbGltaXRlcnM/XG4gICAgICAvLyBiZWdpbjogL1sgXSsoWygpXCJdPyhbQS1aYS16Jy1dezMsfXxpc3xhfEl8c298dXN8W3RUXVtvT118YXR8aWZ8aW58aXR8b24pWy5dP1soKVwiOl0/KFsuXVsgXXxbIF18XFwpKSl7M30vXG4gICAgICAvLyAtLS1cblxuICAgICAgLy8gdGhpcyB0cmllcyB0byBmaW5kIHNlcXVlbmNlcyBvZiAzIGVuZ2xpc2ggd29yZHMgaW4gYSByb3cgKHdpdGhvdXQgYW55XG4gICAgICAvLyBcInByb2dyYW1taW5nXCIgdHlwZSBzeW50YXgpIHRoaXMgZ2l2ZXMgdXMgYSBzdHJvbmcgc2lnbmFsIHRoYXQgd2UndmVcbiAgICAgIC8vIFRSVUxZIGZvdW5kIGEgY29tbWVudCAtIHZzIHBlcmhhcHMgc2Nhbm5pbmcgd2l0aCB0aGUgd3JvbmcgbGFuZ3VhZ2UuXG4gICAgICAvLyBJdCdzIHBvc3NpYmxlIHRvIGZpbmQgc29tZXRoaW5nIHRoYXQgTE9PS1MgbGlrZSB0aGUgc3RhcnQgb2YgdGhlXG4gICAgICAvLyBjb21tZW50IC0gYnV0IHRoZW4gaWYgdGhlcmUgaXMgbm8gcmVhZGFibGUgdGV4dCAtIGdvb2QgY2hhbmNlIGl0IGlzIGFcbiAgICAgIC8vIGZhbHNlIG1hdGNoIGFuZCBub3QgYSBjb21tZW50LlxuICAgICAgLy9cbiAgICAgIC8vIGZvciBhIHZpc3VhbCBleGFtcGxlIHBsZWFzZSBzZWU6XG4gICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vaGlnaGxpZ2h0anMvaGlnaGxpZ2h0LmpzL2lzc3Vlcy8yODI3XG5cbiAgICAgIGJlZ2luOiBjb25jYXQoXG4gICAgICAgIC9bIF0rLywgLy8gbmVjZXNzYXJ5IHRvIHByZXZlbnQgdXMgZ29iYmxpbmcgdXAgZG9jdGFncyBsaWtlIC8qIEBhdXRob3IgQm9iIE1jZ2lsbCAqL1xuICAgICAgICAnKCcsXG4gICAgICAgIEVOR0xJU0hfV09SRCxcbiAgICAgICAgL1suXT9bOl0/KFsuXVsgXXxbIF0pLyxcbiAgICAgICAgJyl7M30nKSAvLyBsb29rIGZvciAzIHdvcmRzIGluIGEgcm93XG4gICAgfVxuICApO1xuICByZXR1cm4gbW9kZTtcbn07XG5jb25zdCBDX0xJTkVfQ09NTUVOVF9NT0RFID0gQ09NTUVOVCgnLy8nLCAnJCcpO1xuY29uc3QgQ19CTE9DS19DT01NRU5UX01PREUgPSBDT01NRU5UKCcvXFxcXConLCAnXFxcXCovJyk7XG5jb25zdCBIQVNIX0NPTU1FTlRfTU9ERSA9IENPTU1FTlQoJyMnLCAnJCcpO1xuY29uc3QgTlVNQkVSX01PREUgPSB7XG4gIHNjb3BlOiAnbnVtYmVyJyxcbiAgYmVnaW46IE5VTUJFUl9SRSxcbiAgcmVsZXZhbmNlOiAwXG59O1xuY29uc3QgQ19OVU1CRVJfTU9ERSA9IHtcbiAgc2NvcGU6ICdudW1iZXInLFxuICBiZWdpbjogQ19OVU1CRVJfUkUsXG4gIHJlbGV2YW5jZTogMFxufTtcbmNvbnN0IEJJTkFSWV9OVU1CRVJfTU9ERSA9IHtcbiAgc2NvcGU6ICdudW1iZXInLFxuICBiZWdpbjogQklOQVJZX05VTUJFUl9SRSxcbiAgcmVsZXZhbmNlOiAwXG59O1xuY29uc3QgUkVHRVhQX01PREUgPSB7XG4gIC8vIHRoaXMgb3V0ZXIgcnVsZSBtYWtlcyBzdXJlIHdlIGFjdHVhbGx5IGhhdmUgYSBXSE9MRSByZWdleCBhbmQgbm90IHNpbXBseVxuICAvLyBhbiBleHByZXNzaW9uIHN1Y2ggYXM6XG4gIC8vXG4gIC8vICAgICAzIC8gc29tZXRoaW5nXG4gIC8vXG4gIC8vICh3aGljaCB3aWxsIHRoZW4gYmxvdyB1cCB3aGVuIHJlZ2V4J3MgYGlsbGVnYWxgIHNlZXMgdGhlIG5ld2xpbmUpXG4gIGJlZ2luOiAvKD89XFwvW14vXFxuXSpcXC8pLyxcbiAgY29udGFpbnM6IFt7XG4gICAgc2NvcGU6ICdyZWdleHAnLFxuICAgIGJlZ2luOiAvXFwvLyxcbiAgICBlbmQ6IC9cXC9bZ2ltdXldKi8sXG4gICAgaWxsZWdhbDogL1xcbi8sXG4gICAgY29udGFpbnM6IFtcbiAgICAgIEJBQ0tTTEFTSF9FU0NBUEUsXG4gICAgICB7XG4gICAgICAgIGJlZ2luOiAvXFxbLyxcbiAgICAgICAgZW5kOiAvXFxdLyxcbiAgICAgICAgcmVsZXZhbmNlOiAwLFxuICAgICAgICBjb250YWluczogW0JBQ0tTTEFTSF9FU0NBUEVdXG4gICAgICB9XG4gICAgXVxuICB9XVxufTtcbmNvbnN0IFRJVExFX01PREUgPSB7XG4gIHNjb3BlOiAndGl0bGUnLFxuICBiZWdpbjogSURFTlRfUkUsXG4gIHJlbGV2YW5jZTogMFxufTtcbmNvbnN0IFVOREVSU0NPUkVfVElUTEVfTU9ERSA9IHtcbiAgc2NvcGU6ICd0aXRsZScsXG4gIGJlZ2luOiBVTkRFUlNDT1JFX0lERU5UX1JFLFxuICByZWxldmFuY2U6IDBcbn07XG5jb25zdCBNRVRIT0RfR1VBUkQgPSB7XG4gIC8vIGV4Y2x1ZGVzIG1ldGhvZCBuYW1lcyBmcm9tIGtleXdvcmQgcHJvY2Vzc2luZ1xuICBiZWdpbjogJ1xcXFwuXFxcXHMqJyArIFVOREVSU0NPUkVfSURFTlRfUkUsXG4gIHJlbGV2YW5jZTogMFxufTtcblxuLyoqXG4gKiBBZGRzIGVuZCBzYW1lIGFzIGJlZ2luIG1lY2hhbmljcyB0byBhIG1vZGVcbiAqXG4gKiBZb3VyIG1vZGUgbXVzdCBpbmNsdWRlIGF0IGxlYXN0IGEgc2luZ2xlICgpIG1hdGNoIGdyb3VwIGFzIHRoYXQgZmlyc3QgbWF0Y2hcbiAqIGdyb3VwIGlzIHdoYXQgaXMgdXNlZCBmb3IgY29tcGFyaXNvblxuICogQHBhcmFtIHtQYXJ0aWFsPE1vZGU+fSBtb2RlXG4gKi9cbmNvbnN0IEVORF9TQU1FX0FTX0JFR0lOID0gZnVuY3Rpb24obW9kZSkge1xuICByZXR1cm4gT2JqZWN0LmFzc2lnbihtb2RlLFxuICAgIHtcbiAgICAgIC8qKiBAdHlwZSB7TW9kZUNhbGxiYWNrfSAqL1xuICAgICAgJ29uOmJlZ2luJzogKG0sIHJlc3ApID0+IHsgcmVzcC5kYXRhLl9iZWdpbk1hdGNoID0gbVsxXTsgfSxcbiAgICAgIC8qKiBAdHlwZSB7TW9kZUNhbGxiYWNrfSAqL1xuICAgICAgJ29uOmVuZCc6IChtLCByZXNwKSA9PiB7IGlmIChyZXNwLmRhdGEuX2JlZ2luTWF0Y2ggIT09IG1bMV0pIHJlc3AuaWdub3JlTWF0Y2goKTsgfVxuICAgIH0pO1xufTtcblxudmFyIE1PREVTID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuICAgIF9fcHJvdG9fXzogbnVsbCxcbiAgICBNQVRDSF9OT1RISU5HX1JFOiBNQVRDSF9OT1RISU5HX1JFLFxuICAgIElERU5UX1JFOiBJREVOVF9SRSxcbiAgICBVTkRFUlNDT1JFX0lERU5UX1JFOiBVTkRFUlNDT1JFX0lERU5UX1JFLFxuICAgIE5VTUJFUl9SRTogTlVNQkVSX1JFLFxuICAgIENfTlVNQkVSX1JFOiBDX05VTUJFUl9SRSxcbiAgICBCSU5BUllfTlVNQkVSX1JFOiBCSU5BUllfTlVNQkVSX1JFLFxuICAgIFJFX1NUQVJURVJTX1JFOiBSRV9TVEFSVEVSU19SRSxcbiAgICBTSEVCQU5HOiBTSEVCQU5HLFxuICAgIEJBQ0tTTEFTSF9FU0NBUEU6IEJBQ0tTTEFTSF9FU0NBUEUsXG4gICAgQVBPU19TVFJJTkdfTU9ERTogQVBPU19TVFJJTkdfTU9ERSxcbiAgICBRVU9URV9TVFJJTkdfTU9ERTogUVVPVEVfU1RSSU5HX01PREUsXG4gICAgUEhSQVNBTF9XT1JEU19NT0RFOiBQSFJBU0FMX1dPUkRTX01PREUsXG4gICAgQ09NTUVOVDogQ09NTUVOVCxcbiAgICBDX0xJTkVfQ09NTUVOVF9NT0RFOiBDX0xJTkVfQ09NTUVOVF9NT0RFLFxuICAgIENfQkxPQ0tfQ09NTUVOVF9NT0RFOiBDX0JMT0NLX0NPTU1FTlRfTU9ERSxcbiAgICBIQVNIX0NPTU1FTlRfTU9ERTogSEFTSF9DT01NRU5UX01PREUsXG4gICAgTlVNQkVSX01PREU6IE5VTUJFUl9NT0RFLFxuICAgIENfTlVNQkVSX01PREU6IENfTlVNQkVSX01PREUsXG4gICAgQklOQVJZX05VTUJFUl9NT0RFOiBCSU5BUllfTlVNQkVSX01PREUsXG4gICAgUkVHRVhQX01PREU6IFJFR0VYUF9NT0RFLFxuICAgIFRJVExFX01PREU6IFRJVExFX01PREUsXG4gICAgVU5ERVJTQ09SRV9USVRMRV9NT0RFOiBVTkRFUlNDT1JFX1RJVExFX01PREUsXG4gICAgTUVUSE9EX0dVQVJEOiBNRVRIT0RfR1VBUkQsXG4gICAgRU5EX1NBTUVfQVNfQkVHSU46IEVORF9TQU1FX0FTX0JFR0lOXG59KTtcblxuLyoqXG5AdHlwZWRlZiB7aW1wb3J0KCdoaWdobGlnaHQuanMnKS5DYWxsYmFja1Jlc3BvbnNlfSBDYWxsYmFja1Jlc3BvbnNlXG5AdHlwZWRlZiB7aW1wb3J0KCdoaWdobGlnaHQuanMnKS5Db21waWxlckV4dH0gQ29tcGlsZXJFeHRcbiovXG5cbi8vIEdyYW1tYXIgZXh0ZW5zaW9ucyAvIHBsdWdpbnNcbi8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2hpZ2hsaWdodGpzL2hpZ2hsaWdodC5qcy9pc3N1ZXMvMjgzM1xuXG4vLyBHcmFtbWFyIGV4dGVuc2lvbnMgYWxsb3cgXCJzeW50YWN0aWMgc3VnYXJcIiB0byBiZSBhZGRlZCB0byB0aGUgZ3JhbW1hciBtb2Rlc1xuLy8gd2l0aG91dCByZXF1aXJpbmcgYW55IHVuZGVybHlpbmcgY2hhbmdlcyB0byB0aGUgY29tcGlsZXIgaW50ZXJuYWxzLlxuXG4vLyBgY29tcGlsZU1hdGNoYCBiZWluZyB0aGUgcGVyZmVjdCBzbWFsbCBleGFtcGxlIG9mIG5vdyBhbGxvd2luZyBhIGdyYW1tYXJcbi8vIGF1dGhvciB0byB3cml0ZSBgbWF0Y2hgIHdoZW4gdGhleSBkZXNpcmUgdG8gbWF0Y2ggYSBzaW5nbGUgZXhwcmVzc2lvbiByYXRoZXJcbi8vIHRoYW4gYmVpbmcgZm9yY2VkIHRvIHVzZSBgYmVnaW5gLiAgVGhlIGV4dGVuc2lvbiB0aGVuIGp1c3QgbW92ZXMgYG1hdGNoYCBpbnRvXG4vLyBgYmVnaW5gIHdoZW4gaXQgcnVucy4gIEllLCBubyBmZWF0dXJlcyBoYXZlIGJlZW4gYWRkZWQsIGJ1dCB3ZSd2ZSBqdXN0IG1hZGVcbi8vIHRoZSBleHBlcmllbmNlIG9mIHdyaXRpbmcgKGFuZCByZWFkaW5nIGdyYW1tYXJzKSBhIGxpdHRsZSBiaXQgbmljZXIuXG5cbi8vIC0tLS0tLVxuXG4vLyBUT0RPOiBXZSBuZWVkIG5lZ2F0aXZlIGxvb2stYmVoaW5kIHN1cHBvcnQgdG8gZG8gdGhpcyBwcm9wZXJseVxuLyoqXG4gKiBTa2lwIGEgbWF0Y2ggaWYgaXQgaGFzIGEgcHJlY2VkaW5nIGRvdFxuICpcbiAqIFRoaXMgaXMgdXNlZCBmb3IgYGJlZ2luS2V5d29yZHNgIHRvIHByZXZlbnQgbWF0Y2hpbmcgZXhwcmVzc2lvbnMgc3VjaCBhc1xuICogYGJvYi5rZXl3b3JkLmRvKClgLiBUaGUgbW9kZSBjb21waWxlciBhdXRvbWF0aWNhbGx5IHdpcmVzIHRoaXMgdXAgYXMgYVxuICogc3BlY2lhbCBfaW50ZXJuYWxfICdvbjpiZWdpbicgY2FsbGJhY2sgZm9yIG1vZGVzIHdpdGggYGJlZ2luS2V5d29yZHNgXG4gKiBAcGFyYW0ge1JlZ0V4cE1hdGNoQXJyYXl9IG1hdGNoXG4gKiBAcGFyYW0ge0NhbGxiYWNrUmVzcG9uc2V9IHJlc3BvbnNlXG4gKi9cbmZ1bmN0aW9uIHNraXBJZkhhc1ByZWNlZGluZ0RvdChtYXRjaCwgcmVzcG9uc2UpIHtcbiAgY29uc3QgYmVmb3JlID0gbWF0Y2guaW5wdXRbbWF0Y2guaW5kZXggLSAxXTtcbiAgaWYgKGJlZm9yZSA9PT0gXCIuXCIpIHtcbiAgICByZXNwb25zZS5pZ25vcmVNYXRjaCgpO1xuICB9XG59XG5cbi8qKlxuICpcbiAqIEB0eXBlIHtDb21waWxlckV4dH1cbiAqL1xuZnVuY3Rpb24gc2NvcGVDbGFzc05hbWUobW9kZSwgX3BhcmVudCkge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5kZWZpbmVkXG4gIGlmIChtb2RlLmNsYXNzTmFtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgbW9kZS5zY29wZSA9IG1vZGUuY2xhc3NOYW1lO1xuICAgIGRlbGV0ZSBtb2RlLmNsYXNzTmFtZTtcbiAgfVxufVxuXG4vKipcbiAqIGBiZWdpbktleXdvcmRzYCBzeW50YWN0aWMgc3VnYXJcbiAqIEB0eXBlIHtDb21waWxlckV4dH1cbiAqL1xuZnVuY3Rpb24gYmVnaW5LZXl3b3Jkcyhtb2RlLCBwYXJlbnQpIHtcbiAgaWYgKCFwYXJlbnQpIHJldHVybjtcbiAgaWYgKCFtb2RlLmJlZ2luS2V5d29yZHMpIHJldHVybjtcblxuICAvLyBmb3IgbGFuZ3VhZ2VzIHdpdGgga2V5d29yZHMgdGhhdCBpbmNsdWRlIG5vbi13b3JkIGNoYXJhY3RlcnMgY2hlY2tpbmcgZm9yXG4gIC8vIGEgd29yZCBib3VuZGFyeSBpcyBub3Qgc3VmZmljaWVudCwgc28gaW5zdGVhZCB3ZSBjaGVjayBmb3IgYSB3b3JkIGJvdW5kYXJ5XG4gIC8vIG9yIHdoaXRlc3BhY2UgLSB0aGlzIGRvZXMgbm8gaGFybSBpbiBhbnkgY2FzZSBzaW5jZSBvdXIga2V5d29yZCBlbmdpbmVcbiAgLy8gZG9lc24ndCBhbGxvdyBzcGFjZXMgaW4ga2V5d29yZHMgYW55d2F5cyBhbmQgd2Ugc3RpbGwgY2hlY2sgZm9yIHRoZSBib3VuZGFyeVxuICAvLyBmaXJzdFxuICBtb2RlLmJlZ2luID0gJ1xcXFxiKCcgKyBtb2RlLmJlZ2luS2V5d29yZHMuc3BsaXQoJyAnKS5qb2luKCd8JykgKyAnKSg/IVxcXFwuKSg/PVxcXFxifFxcXFxzKSc7XG4gIG1vZGUuX19iZWZvcmVCZWdpbiA9IHNraXBJZkhhc1ByZWNlZGluZ0RvdDtcbiAgbW9kZS5rZXl3b3JkcyA9IG1vZGUua2V5d29yZHMgfHwgbW9kZS5iZWdpbktleXdvcmRzO1xuICBkZWxldGUgbW9kZS5iZWdpbktleXdvcmRzO1xuXG4gIC8vIHByZXZlbnRzIGRvdWJsZSByZWxldmFuY2UsIHRoZSBrZXl3b3JkcyB0aGVtc2VsdmVzIHByb3ZpZGVcbiAgLy8gcmVsZXZhbmNlLCB0aGUgbW9kZSBkb2Vzbid0IG5lZWQgdG8gZG91YmxlIGl0XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlZmluZWRcbiAgaWYgKG1vZGUucmVsZXZhbmNlID09PSB1bmRlZmluZWQpIG1vZGUucmVsZXZhbmNlID0gMDtcbn1cblxuLyoqXG4gKiBBbGxvdyBgaWxsZWdhbGAgdG8gY29udGFpbiBhbiBhcnJheSBvZiBpbGxlZ2FsIHZhbHVlc1xuICogQHR5cGUge0NvbXBpbGVyRXh0fVxuICovXG5mdW5jdGlvbiBjb21waWxlSWxsZWdhbChtb2RlLCBfcGFyZW50KSB7XG4gIGlmICghQXJyYXkuaXNBcnJheShtb2RlLmlsbGVnYWwpKSByZXR1cm47XG5cbiAgbW9kZS5pbGxlZ2FsID0gZWl0aGVyKC4uLm1vZGUuaWxsZWdhbCk7XG59XG5cbi8qKlxuICogYG1hdGNoYCB0byBtYXRjaCBhIHNpbmdsZSBleHByZXNzaW9uIGZvciByZWFkYWJpbGl0eVxuICogQHR5cGUge0NvbXBpbGVyRXh0fVxuICovXG5mdW5jdGlvbiBjb21waWxlTWF0Y2gobW9kZSwgX3BhcmVudCkge1xuICBpZiAoIW1vZGUubWF0Y2gpIHJldHVybjtcbiAgaWYgKG1vZGUuYmVnaW4gfHwgbW9kZS5lbmQpIHRocm93IG5ldyBFcnJvcihcImJlZ2luICYgZW5kIGFyZSBub3Qgc3VwcG9ydGVkIHdpdGggbWF0Y2hcIik7XG5cbiAgbW9kZS5iZWdpbiA9IG1vZGUubWF0Y2g7XG4gIGRlbGV0ZSBtb2RlLm1hdGNoO1xufVxuXG4vKipcbiAqIHByb3ZpZGVzIHRoZSBkZWZhdWx0IDEgcmVsZXZhbmNlIHRvIGFsbCBtb2Rlc1xuICogQHR5cGUge0NvbXBpbGVyRXh0fVxuICovXG5mdW5jdGlvbiBjb21waWxlUmVsZXZhbmNlKG1vZGUsIF9wYXJlbnQpIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVmaW5lZFxuICBpZiAobW9kZS5yZWxldmFuY2UgPT09IHVuZGVmaW5lZCkgbW9kZS5yZWxldmFuY2UgPSAxO1xufVxuXG4vLyBhbGxvdyBiZWZvcmVNYXRjaCB0byBhY3QgYXMgYSBcInF1YWxpZmllclwiIGZvciB0aGUgbWF0Y2hcbi8vIHRoZSBmdWxsIG1hdGNoIGJlZ2luIG11c3QgYmUgW2JlZm9yZU1hdGNoXVtiZWdpbl1cbmNvbnN0IGJlZm9yZU1hdGNoRXh0ID0gKG1vZGUsIHBhcmVudCkgPT4ge1xuICBpZiAoIW1vZGUuYmVmb3JlTWF0Y2gpIHJldHVybjtcbiAgLy8gc3RhcnRzIGNvbmZsaWN0cyB3aXRoIGVuZHNQYXJlbnQgd2hpY2ggd2UgbmVlZCB0byBtYWtlIHN1cmUgdGhlIGNoaWxkXG4gIC8vIHJ1bGUgaXMgbm90IG1hdGNoZWQgbXVsdGlwbGUgdGltZXNcbiAgaWYgKG1vZGUuc3RhcnRzKSB0aHJvdyBuZXcgRXJyb3IoXCJiZWZvcmVNYXRjaCBjYW5ub3QgYmUgdXNlZCB3aXRoIHN0YXJ0c1wiKTtcblxuICBjb25zdCBvcmlnaW5hbE1vZGUgPSBPYmplY3QuYXNzaWduKHt9LCBtb2RlKTtcbiAgT2JqZWN0LmtleXMobW9kZSkuZm9yRWFjaCgoa2V5KSA9PiB7IGRlbGV0ZSBtb2RlW2tleV07IH0pO1xuXG4gIG1vZGUua2V5d29yZHMgPSBvcmlnaW5hbE1vZGUua2V5d29yZHM7XG4gIG1vZGUuYmVnaW4gPSBjb25jYXQob3JpZ2luYWxNb2RlLmJlZm9yZU1hdGNoLCBsb29rYWhlYWQob3JpZ2luYWxNb2RlLmJlZ2luKSk7XG4gIG1vZGUuc3RhcnRzID0ge1xuICAgIHJlbGV2YW5jZTogMCxcbiAgICBjb250YWluczogW1xuICAgICAgT2JqZWN0LmFzc2lnbihvcmlnaW5hbE1vZGUsIHsgZW5kc1BhcmVudDogdHJ1ZSB9KVxuICAgIF1cbiAgfTtcbiAgbW9kZS5yZWxldmFuY2UgPSAwO1xuXG4gIGRlbGV0ZSBvcmlnaW5hbE1vZGUuYmVmb3JlTWF0Y2g7XG59O1xuXG4vLyBrZXl3b3JkcyB0aGF0IHNob3VsZCBoYXZlIG5vIGRlZmF1bHQgcmVsZXZhbmNlIHZhbHVlXG5jb25zdCBDT01NT05fS0VZV09SRFMgPSBbXG4gICdvZicsXG4gICdhbmQnLFxuICAnZm9yJyxcbiAgJ2luJyxcbiAgJ25vdCcsXG4gICdvcicsXG4gICdpZicsXG4gICd0aGVuJyxcbiAgJ3BhcmVudCcsIC8vIGNvbW1vbiB2YXJpYWJsZSBuYW1lXG4gICdsaXN0JywgLy8gY29tbW9uIHZhcmlhYmxlIG5hbWVcbiAgJ3ZhbHVlJyAvLyBjb21tb24gdmFyaWFibGUgbmFtZVxuXTtcblxuY29uc3QgREVGQVVMVF9LRVlXT1JEX1NDT1BFID0gXCJrZXl3b3JkXCI7XG5cbi8qKlxuICogR2l2ZW4gcmF3IGtleXdvcmRzIGZyb20gYSBsYW5ndWFnZSBkZWZpbml0aW9uLCBjb21waWxlIHRoZW0uXG4gKlxuICogQHBhcmFtIHtzdHJpbmcgfCBSZWNvcmQ8c3RyaW5nLHN0cmluZ3xzdHJpbmdbXT4gfCBBcnJheTxzdHJpbmc+fSByYXdLZXl3b3Jkc1xuICogQHBhcmFtIHtib29sZWFufSBjYXNlSW5zZW5zaXRpdmVcbiAqL1xuZnVuY3Rpb24gY29tcGlsZUtleXdvcmRzKHJhd0tleXdvcmRzLCBjYXNlSW5zZW5zaXRpdmUsIHNjb3BlTmFtZSA9IERFRkFVTFRfS0VZV09SRF9TQ09QRSkge1xuICAvKiogQHR5cGUgS2V5d29yZERpY3QgKi9cbiAgY29uc3QgY29tcGlsZWRLZXl3b3JkcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbiAgLy8gaW5wdXQgY2FuIGJlIGEgc3RyaW5nIG9mIGtleXdvcmRzLCBhbiBhcnJheSBvZiBrZXl3b3Jkcywgb3IgYSBvYmplY3Qgd2l0aFxuICAvLyBuYW1lZCBrZXlzIHJlcHJlc2VudGluZyBzY29wZU5hbWUgKHdoaWNoIGNhbiB0aGVuIHBvaW50IHRvIGEgc3RyaW5nIG9yIGFycmF5KVxuICBpZiAodHlwZW9mIHJhd0tleXdvcmRzID09PSAnc3RyaW5nJykge1xuICAgIGNvbXBpbGVMaXN0KHNjb3BlTmFtZSwgcmF3S2V5d29yZHMuc3BsaXQoXCIgXCIpKTtcbiAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHJhd0tleXdvcmRzKSkge1xuICAgIGNvbXBpbGVMaXN0KHNjb3BlTmFtZSwgcmF3S2V5d29yZHMpO1xuICB9IGVsc2Uge1xuICAgIE9iamVjdC5rZXlzKHJhd0tleXdvcmRzKS5mb3JFYWNoKGZ1bmN0aW9uKHNjb3BlTmFtZSkge1xuICAgICAgLy8gY29sbGFwc2UgYWxsIG91ciBvYmplY3RzIGJhY2sgaW50byB0aGUgcGFyZW50IG9iamVjdFxuICAgICAgT2JqZWN0LmFzc2lnbihcbiAgICAgICAgY29tcGlsZWRLZXl3b3JkcyxcbiAgICAgICAgY29tcGlsZUtleXdvcmRzKHJhd0tleXdvcmRzW3Njb3BlTmFtZV0sIGNhc2VJbnNlbnNpdGl2ZSwgc2NvcGVOYW1lKVxuICAgICAgKTtcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gY29tcGlsZWRLZXl3b3JkcztcblxuICAvLyAtLS1cblxuICAvKipcbiAgICogQ29tcGlsZXMgYW4gaW5kaXZpZHVhbCBsaXN0IG9mIGtleXdvcmRzXG4gICAqXG4gICAqIEV4OiBcImZvciBpZiB3aGVuIHdoaWxlfDVcIlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gc2NvcGVOYW1lXG4gICAqIEBwYXJhbSB7QXJyYXk8c3RyaW5nPn0ga2V5d29yZExpc3RcbiAgICovXG4gIGZ1bmN0aW9uIGNvbXBpbGVMaXN0KHNjb3BlTmFtZSwga2V5d29yZExpc3QpIHtcbiAgICBpZiAoY2FzZUluc2Vuc2l0aXZlKSB7XG4gICAgICBrZXl3b3JkTGlzdCA9IGtleXdvcmRMaXN0Lm1hcCh4ID0+IHgudG9Mb3dlckNhc2UoKSk7XG4gICAgfVxuICAgIGtleXdvcmRMaXN0LmZvckVhY2goZnVuY3Rpb24oa2V5d29yZCkge1xuICAgICAgY29uc3QgcGFpciA9IGtleXdvcmQuc3BsaXQoJ3wnKTtcbiAgICAgIGNvbXBpbGVkS2V5d29yZHNbcGFpclswXV0gPSBbc2NvcGVOYW1lLCBzY29yZUZvcktleXdvcmQocGFpclswXSwgcGFpclsxXSldO1xuICAgIH0pO1xuICB9XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgcHJvcGVyIHNjb3JlIGZvciBhIGdpdmVuIGtleXdvcmRcbiAqXG4gKiBBbHNvIHRha2VzIGludG8gYWNjb3VudCBjb21tZW50IGtleXdvcmRzLCB3aGljaCB3aWxsIGJlIHNjb3JlZCAwIFVOTEVTU1xuICogYW5vdGhlciBzY29yZSBoYXMgYmVlbiBtYW51YWxseSBhc3NpZ25lZC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXl3b3JkXG4gKiBAcGFyYW0ge3N0cmluZ30gW3Byb3ZpZGVkU2NvcmVdXG4gKi9cbmZ1bmN0aW9uIHNjb3JlRm9yS2V5d29yZChrZXl3b3JkLCBwcm92aWRlZFNjb3JlKSB7XG4gIC8vIG1hbnVhbCBzY29yZXMgYWx3YXlzIHdpbiBvdmVyIGNvbW1vbiBrZXl3b3Jkc1xuICAvLyBzbyB5b3UgY2FuIGZvcmNlIGEgc2NvcmUgb2YgMSBpZiB5b3UgcmVhbGx5IGluc2lzdFxuICBpZiAocHJvdmlkZWRTY29yZSkge1xuICAgIHJldHVybiBOdW1iZXIocHJvdmlkZWRTY29yZSk7XG4gIH1cblxuICByZXR1cm4gY29tbW9uS2V5d29yZChrZXl3b3JkKSA/IDAgOiAxO1xufVxuXG4vKipcbiAqIERldGVybWluZXMgaWYgYSBnaXZlbiBrZXl3b3JkIGlzIGNvbW1vbiBvciBub3RcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5d29yZCAqL1xuZnVuY3Rpb24gY29tbW9uS2V5d29yZChrZXl3b3JkKSB7XG4gIHJldHVybiBDT01NT05fS0VZV09SRFMuaW5jbHVkZXMoa2V5d29yZC50b0xvd2VyQ2FzZSgpKTtcbn1cblxuLypcblxuRm9yIHRoZSByZWFzb25pbmcgYmVoaW5kIHRoaXMgcGxlYXNlIHNlZTpcbmh0dHBzOi8vZ2l0aHViLmNvbS9oaWdobGlnaHRqcy9oaWdobGlnaHQuanMvaXNzdWVzLzI4ODAjaXNzdWVjb21tZW50LTc0NzI3NTQxOVxuXG4qL1xuXG4vKipcbiAqIEB0eXBlIHtSZWNvcmQ8c3RyaW5nLCBib29sZWFuPn1cbiAqL1xuY29uc3Qgc2VlbkRlcHJlY2F0aW9ucyA9IHt9O1xuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBtZXNzYWdlXG4gKi9cbmNvbnN0IGVycm9yID0gKG1lc3NhZ2UpID0+IHtcbiAgY29uc29sZS5lcnJvcihtZXNzYWdlKTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IG1lc3NhZ2VcbiAqIEBwYXJhbSB7YW55fSBhcmdzXG4gKi9cbmNvbnN0IHdhcm4gPSAobWVzc2FnZSwgLi4uYXJncykgPT4ge1xuICBjb25zb2xlLmxvZyhgV0FSTjogJHttZXNzYWdlfWAsIC4uLmFyZ3MpO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gdmVyc2lvblxuICogQHBhcmFtIHtzdHJpbmd9IG1lc3NhZ2VcbiAqL1xuY29uc3QgZGVwcmVjYXRlZCA9ICh2ZXJzaW9uLCBtZXNzYWdlKSA9PiB7XG4gIGlmIChzZWVuRGVwcmVjYXRpb25zW2Ake3ZlcnNpb259LyR7bWVzc2FnZX1gXSkgcmV0dXJuO1xuXG4gIGNvbnNvbGUubG9nKGBEZXByZWNhdGVkIGFzIG9mICR7dmVyc2lvbn0uICR7bWVzc2FnZX1gKTtcbiAgc2VlbkRlcHJlY2F0aW9uc1tgJHt2ZXJzaW9ufS8ke21lc3NhZ2V9YF0gPSB0cnVlO1xufTtcblxuLyogZXNsaW50LWRpc2FibGUgbm8tdGhyb3ctbGl0ZXJhbCAqL1xuXG4vKipcbkB0eXBlZGVmIHtpbXBvcnQoJ2hpZ2hsaWdodC5qcycpLkNvbXBpbGVkTW9kZX0gQ29tcGlsZWRNb2RlXG4qL1xuXG5jb25zdCBNdWx0aUNsYXNzRXJyb3IgPSBuZXcgRXJyb3IoKTtcblxuLyoqXG4gKiBSZW51bWJlcnMgbGFiZWxlZCBzY29wZSBuYW1lcyB0byBhY2NvdW50IGZvciBhZGRpdGlvbmFsIGlubmVyIG1hdGNoXG4gKiBncm91cHMgdGhhdCBvdGhlcndpc2Ugd291bGQgYnJlYWsgZXZlcnl0aGluZy5cbiAqXG4gKiBMZXRzIHNheSB3ZSAzIG1hdGNoIHNjb3BlczpcbiAqXG4gKiAgIHsgMSA9PiAuLi4sIDIgPT4gLi4uLCAzID0+IC4uLiB9XG4gKlxuICogU28gd2hhdCB3ZSBuZWVkIGlzIGEgY2xlYW4gbWF0Y2ggbGlrZSB0aGlzOlxuICpcbiAqICAgKGEpKGIpKGMpID0+IFsgXCJhXCIsIFwiYlwiLCBcImNcIiBdXG4gKlxuICogQnV0IHRoaXMgZmFsbHMgYXBhcnQgd2l0aCBpbm5lciBtYXRjaCBncm91cHM6XG4gKlxuICogKGEpKCgoYikpKShjKSA9PiBbXCJhXCIsIFwiYlwiLCBcImJcIiwgXCJiXCIsIFwiY1wiIF1cbiAqXG4gKiBPdXIgc2NvcGVzIGFyZSBub3cgXCJvdXQgb2YgYWxpZ25tZW50XCIgYW5kIHdlJ3JlIHJlcGVhdGluZyBgYmAgMyB0aW1lcy5cbiAqIFdoYXQgbmVlZHMgdG8gaGFwcGVuIGlzIHRoZSBudW1iZXJzIGFyZSByZW1hcHBlZDpcbiAqXG4gKiAgIHsgMSA9PiAuLi4sIDIgPT4gLi4uLCA1ID0+IC4uLiB9XG4gKlxuICogV2UgYWxzbyBuZWVkIHRvIGtub3cgdGhhdCB0aGUgT05MWSBncm91cHMgdGhhdCBzaG91bGQgYmUgb3V0cHV0XG4gKiBhcmUgMSwgMiwgYW5kIDUuICBUaGlzIGZ1bmN0aW9uIGhhbmRsZXMgdGhpcyBiZWhhdmlvci5cbiAqXG4gKiBAcGFyYW0ge0NvbXBpbGVkTW9kZX0gbW9kZVxuICogQHBhcmFtIHtBcnJheTxSZWdFeHA+fSByZWdleGVzXG4gKiBAcGFyYW0ge3trZXk6IFwiYmVnaW5TY29wZVwifFwiZW5kU2NvcGVcIn19IG9wdHNcbiAqL1xuZnVuY3Rpb24gcmVtYXBTY29wZU5hbWVzKG1vZGUsIHJlZ2V4ZXMsIHsga2V5IH0pIHtcbiAgbGV0IG9mZnNldCA9IDA7XG4gIGNvbnN0IHNjb3BlTmFtZXMgPSBtb2RlW2tleV07XG4gIC8qKiBAdHlwZSBSZWNvcmQ8bnVtYmVyLGJvb2xlYW4+ICovXG4gIGNvbnN0IGVtaXQgPSB7fTtcbiAgLyoqIEB0eXBlIFJlY29yZDxudW1iZXIsc3RyaW5nPiAqL1xuICBjb25zdCBwb3NpdGlvbnMgPSB7fTtcblxuICBmb3IgKGxldCBpID0gMTsgaSA8PSByZWdleGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgcG9zaXRpb25zW2kgKyBvZmZzZXRdID0gc2NvcGVOYW1lc1tpXTtcbiAgICBlbWl0W2kgKyBvZmZzZXRdID0gdHJ1ZTtcbiAgICBvZmZzZXQgKz0gY291bnRNYXRjaEdyb3VwcyhyZWdleGVzW2kgLSAxXSk7XG4gIH1cbiAgLy8gd2UgdXNlIF9lbWl0IHRvIGtlZXAgdHJhY2sgb2Ygd2hpY2ggbWF0Y2ggZ3JvdXBzIGFyZSBcInRvcC1sZXZlbFwiIHRvIGF2b2lkIGRvdWJsZVxuICAvLyBvdXRwdXQgZnJvbSBpbnNpZGUgbWF0Y2ggZ3JvdXBzXG4gIG1vZGVba2V5XSA9IHBvc2l0aW9ucztcbiAgbW9kZVtrZXldLl9lbWl0ID0gZW1pdDtcbiAgbW9kZVtrZXldLl9tdWx0aSA9IHRydWU7XG59XG5cbi8qKlxuICogQHBhcmFtIHtDb21waWxlZE1vZGV9IG1vZGVcbiAqL1xuZnVuY3Rpb24gYmVnaW5NdWx0aUNsYXNzKG1vZGUpIHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KG1vZGUuYmVnaW4pKSByZXR1cm47XG5cbiAgaWYgKG1vZGUuc2tpcCB8fCBtb2RlLmV4Y2x1ZGVCZWdpbiB8fCBtb2RlLnJldHVybkJlZ2luKSB7XG4gICAgZXJyb3IoXCJza2lwLCBleGNsdWRlQmVnaW4sIHJldHVybkJlZ2luIG5vdCBjb21wYXRpYmxlIHdpdGggYmVnaW5TY29wZToge31cIik7XG4gICAgdGhyb3cgTXVsdGlDbGFzc0Vycm9yO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBtb2RlLmJlZ2luU2NvcGUgIT09IFwib2JqZWN0XCIgfHwgbW9kZS5iZWdpblNjb3BlID09PSBudWxsKSB7XG4gICAgZXJyb3IoXCJiZWdpblNjb3BlIG11c3QgYmUgb2JqZWN0XCIpO1xuICAgIHRocm93IE11bHRpQ2xhc3NFcnJvcjtcbiAgfVxuXG4gIHJlbWFwU2NvcGVOYW1lcyhtb2RlLCBtb2RlLmJlZ2luLCB7a2V5OiBcImJlZ2luU2NvcGVcIn0pO1xuICBtb2RlLmJlZ2luID0gX3Jld3JpdGVCYWNrcmVmZXJlbmNlcyhtb2RlLmJlZ2luLCB7IGpvaW5XaXRoOiBcIlwiIH0pO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7Q29tcGlsZWRNb2RlfSBtb2RlXG4gKi9cbmZ1bmN0aW9uIGVuZE11bHRpQ2xhc3MobW9kZSkge1xuICBpZiAoIUFycmF5LmlzQXJyYXkobW9kZS5lbmQpKSByZXR1cm47XG5cbiAgaWYgKG1vZGUuc2tpcCB8fCBtb2RlLmV4Y2x1ZGVFbmQgfHwgbW9kZS5yZXR1cm5FbmQpIHtcbiAgICBlcnJvcihcInNraXAsIGV4Y2x1ZGVFbmQsIHJldHVybkVuZCBub3QgY29tcGF0aWJsZSB3aXRoIGVuZFNjb3BlOiB7fVwiKTtcbiAgICB0aHJvdyBNdWx0aUNsYXNzRXJyb3I7XG4gIH1cblxuICBpZiAodHlwZW9mIG1vZGUuZW5kU2NvcGUgIT09IFwib2JqZWN0XCIgfHwgbW9kZS5lbmRTY29wZSA9PT0gbnVsbCkge1xuICAgIGVycm9yKFwiZW5kU2NvcGUgbXVzdCBiZSBvYmplY3RcIik7XG4gICAgdGhyb3cgTXVsdGlDbGFzc0Vycm9yO1xuICB9XG5cbiAgcmVtYXBTY29wZU5hbWVzKG1vZGUsIG1vZGUuZW5kLCB7a2V5OiBcImVuZFNjb3BlXCJ9KTtcbiAgbW9kZS5lbmQgPSBfcmV3cml0ZUJhY2tyZWZlcmVuY2VzKG1vZGUuZW5kLCB7IGpvaW5XaXRoOiBcIlwiIH0pO1xufVxuXG4vKipcbiAqIHRoaXMgZXhpc3RzIG9ubHkgdG8gYWxsb3cgYHNjb3BlOiB7fWAgdG8gYmUgdXNlZCBiZXNpZGUgYG1hdGNoOmBcbiAqIE90aGVyd2lzZSBgYmVnaW5TY29wZWAgd291bGQgbmVjZXNzYXJ5IGFuZCB0aGF0IHdvdWxkIGxvb2sgd2VpcmRcblxuICB7XG4gICAgbWF0Y2g6IFsgL2RlZi8sIC9cXHcrLyBdXG4gICAgc2NvcGU6IHsgMTogXCJrZXl3b3JkXCIgLCAyOiBcInRpdGxlXCIgfVxuICB9XG5cbiAqIEBwYXJhbSB7Q29tcGlsZWRNb2RlfSBtb2RlXG4gKi9cbmZ1bmN0aW9uIHNjb3BlU3VnYXIobW9kZSkge1xuICBpZiAobW9kZS5zY29wZSAmJiB0eXBlb2YgbW9kZS5zY29wZSA9PT0gXCJvYmplY3RcIiAmJiBtb2RlLnNjb3BlICE9PSBudWxsKSB7XG4gICAgbW9kZS5iZWdpblNjb3BlID0gbW9kZS5zY29wZTtcbiAgICBkZWxldGUgbW9kZS5zY29wZTtcbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7Q29tcGlsZWRNb2RlfSBtb2RlXG4gKi9cbmZ1bmN0aW9uIE11bHRpQ2xhc3MobW9kZSkge1xuICBzY29wZVN1Z2FyKG1vZGUpO1xuXG4gIGlmICh0eXBlb2YgbW9kZS5iZWdpblNjb3BlID09PSBcInN0cmluZ1wiKSB7XG4gICAgbW9kZS5iZWdpblNjb3BlID0geyBfd3JhcDogbW9kZS5iZWdpblNjb3BlIH07XG4gIH1cbiAgaWYgKHR5cGVvZiBtb2RlLmVuZFNjb3BlID09PSBcInN0cmluZ1wiKSB7XG4gICAgbW9kZS5lbmRTY29wZSA9IHsgX3dyYXA6IG1vZGUuZW5kU2NvcGUgfTtcbiAgfVxuXG4gIGJlZ2luTXVsdGlDbGFzcyhtb2RlKTtcbiAgZW5kTXVsdGlDbGFzcyhtb2RlKTtcbn1cblxuLyoqXG5AdHlwZWRlZiB7aW1wb3J0KCdoaWdobGlnaHQuanMnKS5Nb2RlfSBNb2RlXG5AdHlwZWRlZiB7aW1wb3J0KCdoaWdobGlnaHQuanMnKS5Db21waWxlZE1vZGV9IENvbXBpbGVkTW9kZVxuQHR5cGVkZWYge2ltcG9ydCgnaGlnaGxpZ2h0LmpzJykuTGFuZ3VhZ2V9IExhbmd1YWdlXG5AdHlwZWRlZiB7aW1wb3J0KCdoaWdobGlnaHQuanMnKS5ITEpTUGx1Z2lufSBITEpTUGx1Z2luXG5AdHlwZWRlZiB7aW1wb3J0KCdoaWdobGlnaHQuanMnKS5Db21waWxlZExhbmd1YWdlfSBDb21waWxlZExhbmd1YWdlXG4qL1xuXG4vLyBjb21waWxhdGlvblxuXG4vKipcbiAqIENvbXBpbGVzIGEgbGFuZ3VhZ2UgZGVmaW5pdGlvbiByZXN1bHRcbiAqXG4gKiBHaXZlbiB0aGUgcmF3IHJlc3VsdCBvZiBhIGxhbmd1YWdlIGRlZmluaXRpb24gKExhbmd1YWdlKSwgY29tcGlsZXMgdGhpcyBzb1xuICogdGhhdCBpdCBpcyByZWFkeSBmb3IgaGlnaGxpZ2h0aW5nIGNvZGUuXG4gKiBAcGFyYW0ge0xhbmd1YWdlfSBsYW5ndWFnZVxuICogQHJldHVybnMge0NvbXBpbGVkTGFuZ3VhZ2V9XG4gKi9cbmZ1bmN0aW9uIGNvbXBpbGVMYW5ndWFnZShsYW5ndWFnZSkge1xuICAvKipcbiAgICogQnVpbGRzIGEgcmVnZXggd2l0aCB0aGUgY2FzZSBzZW5zaXRpdml0eSBvZiB0aGUgY3VycmVudCBsYW5ndWFnZVxuICAgKlxuICAgKiBAcGFyYW0ge1JlZ0V4cCB8IHN0cmluZ30gdmFsdWVcbiAgICogQHBhcmFtIHtib29sZWFufSBbZ2xvYmFsXVxuICAgKi9cbiAgZnVuY3Rpb24gbGFuZ1JlKHZhbHVlLCBnbG9iYWwpIHtcbiAgICByZXR1cm4gbmV3IFJlZ0V4cChcbiAgICAgIHNvdXJjZSh2YWx1ZSksXG4gICAgICAnbScgKyAobGFuZ3VhZ2UuY2FzZV9pbnNlbnNpdGl2ZSA/ICdpJyA6ICcnKSArIChnbG9iYWwgPyAnZycgOiAnJylcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAgU3RvcmVzIG11bHRpcGxlIHJlZ3VsYXIgZXhwcmVzc2lvbnMgYW5kIGFsbG93cyB5b3UgdG8gcXVpY2tseSBzZWFyY2ggZm9yXG4gICAgdGhlbSBhbGwgaW4gYSBzdHJpbmcgc2ltdWx0YW5lb3VzbHkgLSByZXR1cm5pbmcgdGhlIGZpcnN0IG1hdGNoLiAgSXQgZG9lc1xuICAgIHRoaXMgYnkgY3JlYXRpbmcgYSBodWdlIChhfGJ8YykgcmVnZXggLSBlYWNoIGluZGl2aWR1YWwgaXRlbSB3cmFwcGVkIHdpdGggKClcbiAgICBhbmQgam9pbmVkIGJ5IGB8YCAtIHVzaW5nIG1hdGNoIGdyb3VwcyB0byB0cmFjayBwb3NpdGlvbi4gIFdoZW4gYSBtYXRjaCBpc1xuICAgIGZvdW5kIGNoZWNraW5nIHdoaWNoIHBvc2l0aW9uIGluIHRoZSBhcnJheSBoYXMgY29udGVudCBhbGxvd3MgdXMgdG8gZmlndXJlXG4gICAgb3V0IHdoaWNoIG9mIHRoZSBvcmlnaW5hbCByZWdleGVzIC8gbWF0Y2ggZ3JvdXBzIHRyaWdnZXJlZCB0aGUgbWF0Y2guXG5cbiAgICBUaGUgbWF0Y2ggb2JqZWN0IGl0c2VsZiAodGhlIHJlc3VsdCBvZiBgUmVnZXguZXhlY2ApIGlzIHJldHVybmVkIGJ1dCBhbHNvXG4gICAgZW5oYW5jZWQgYnkgbWVyZ2luZyBpbiBhbnkgbWV0YS1kYXRhIHRoYXQgd2FzIHJlZ2lzdGVyZWQgd2l0aCB0aGUgcmVnZXguXG4gICAgVGhpcyBpcyBob3cgd2Uga2VlcCB0cmFjayBvZiB3aGljaCBtb2RlIG1hdGNoZWQsIGFuZCB3aGF0IHR5cGUgb2YgcnVsZVxuICAgIChgaWxsZWdhbGAsIGBiZWdpbmAsIGVuZCwgZXRjKS5cbiAgKi9cbiAgY2xhc3MgTXVsdGlSZWdleCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICB0aGlzLm1hdGNoSW5kZXhlcyA9IHt9O1xuICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgdGhpcy5yZWdleGVzID0gW107XG4gICAgICB0aGlzLm1hdGNoQXQgPSAxO1xuICAgICAgdGhpcy5wb3NpdGlvbiA9IDA7XG4gICAgfVxuXG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIGFkZFJ1bGUocmUsIG9wdHMpIHtcbiAgICAgIG9wdHMucG9zaXRpb24gPSB0aGlzLnBvc2l0aW9uKys7XG4gICAgICAvLyBAdHMtaWdub3JlXG4gICAgICB0aGlzLm1hdGNoSW5kZXhlc1t0aGlzLm1hdGNoQXRdID0gb3B0cztcbiAgICAgIHRoaXMucmVnZXhlcy5wdXNoKFtvcHRzLCByZV0pO1xuICAgICAgdGhpcy5tYXRjaEF0ICs9IGNvdW50TWF0Y2hHcm91cHMocmUpICsgMTtcbiAgICB9XG5cbiAgICBjb21waWxlKCkge1xuICAgICAgaWYgKHRoaXMucmVnZXhlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgLy8gYXZvaWRzIHRoZSBuZWVkIHRvIGNoZWNrIGxlbmd0aCBldmVyeSB0aW1lIGV4ZWMgaXMgY2FsbGVkXG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgdGhpcy5leGVjID0gKCkgPT4gbnVsbDtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHRlcm1pbmF0b3JzID0gdGhpcy5yZWdleGVzLm1hcChlbCA9PiBlbFsxXSk7XG4gICAgICB0aGlzLm1hdGNoZXJSZSA9IGxhbmdSZShfcmV3cml0ZUJhY2tyZWZlcmVuY2VzKHRlcm1pbmF0b3JzLCB7IGpvaW5XaXRoOiAnfCcgfSksIHRydWUpO1xuICAgICAgdGhpcy5sYXN0SW5kZXggPSAwO1xuICAgIH1cblxuICAgIC8qKiBAcGFyYW0ge3N0cmluZ30gcyAqL1xuICAgIGV4ZWMocykge1xuICAgICAgdGhpcy5tYXRjaGVyUmUubGFzdEluZGV4ID0gdGhpcy5sYXN0SW5kZXg7XG4gICAgICBjb25zdCBtYXRjaCA9IHRoaXMubWF0Y2hlclJlLmV4ZWMocyk7XG4gICAgICBpZiAoIW1hdGNoKSB7IHJldHVybiBudWxsOyB9XG5cbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlZmluZWRcbiAgICAgIGNvbnN0IGkgPSBtYXRjaC5maW5kSW5kZXgoKGVsLCBpKSA9PiBpID4gMCAmJiBlbCAhPT0gdW5kZWZpbmVkKTtcbiAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgIGNvbnN0IG1hdGNoRGF0YSA9IHRoaXMubWF0Y2hJbmRleGVzW2ldO1xuICAgICAgLy8gdHJpbSBvZmYgYW55IGVhcmxpZXIgbm9uLXJlbGV2YW50IG1hdGNoIGdyb3VwcyAoaWUsIHRoZSBvdGhlciByZWdleFxuICAgICAgLy8gbWF0Y2ggZ3JvdXBzIHRoYXQgbWFrZSB1cCB0aGUgbXVsdGktbWF0Y2hlcilcbiAgICAgIG1hdGNoLnNwbGljZSgwLCBpKTtcblxuICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24obWF0Y2gsIG1hdGNoRGF0YSk7XG4gICAgfVxuICB9XG5cbiAgLypcbiAgICBDcmVhdGVkIHRvIHNvbHZlIHRoZSBrZXkgZGVmaWNpZW50bHkgd2l0aCBNdWx0aVJlZ2V4IC0gdGhlcmUgaXMgbm8gd2F5IHRvXG4gICAgdGVzdCBmb3IgbXVsdGlwbGUgbWF0Y2hlcyBhdCBhIHNpbmdsZSBsb2NhdGlvbi4gIFdoeSB3b3VsZCB3ZSBuZWVkIHRvIGRvXG4gICAgdGhhdD8gIEluIHRoZSBmdXR1cmUgYSBtb3JlIGR5bmFtaWMgZW5naW5lIHdpbGwgYWxsb3cgY2VydGFpbiBtYXRjaGVzIHRvIGJlXG4gICAgaWdub3JlZC4gIEFuIGV4YW1wbGU6IGlmIHdlIG1hdGNoZWQgc2F5IHRoZSAzcmQgcmVnZXggaW4gYSBsYXJnZSBncm91cCBidXRcbiAgICBkZWNpZGVkIHRvIGlnbm9yZSBpdCAtIHdlJ2QgbmVlZCB0byBzdGFydGVkIHRlc3RpbmcgYWdhaW4gYXQgdGhlIDR0aFxuICAgIHJlZ2V4Li4uIGJ1dCBNdWx0aVJlZ2V4IGl0c2VsZiBnaXZlcyB1cyBubyByZWFsIHdheSB0byBkbyB0aGF0LlxuXG4gICAgU28gd2hhdCB0aGlzIGNsYXNzIGNyZWF0ZXMgTXVsdGlSZWdleHMgb24gdGhlIGZseSBmb3Igd2hhdGV2ZXIgc2VhcmNoXG4gICAgcG9zaXRpb24gdGhleSBhcmUgbmVlZGVkLlxuXG4gICAgTk9URTogVGhlc2UgYWRkaXRpb25hbCBNdWx0aVJlZ2V4IG9iamVjdHMgYXJlIGNyZWF0ZWQgZHluYW1pY2FsbHkuICBGb3IgbW9zdFxuICAgIGdyYW1tYXJzIG1vc3Qgb2YgdGhlIHRpbWUgd2Ugd2lsbCBuZXZlciBhY3R1YWxseSBuZWVkIGFueXRoaW5nIG1vcmUgdGhhbiB0aGVcbiAgICBmaXJzdCBNdWx0aVJlZ2V4IC0gc28gdGhpcyBzaG91bGRuJ3QgaGF2ZSB0b28gbXVjaCBvdmVyaGVhZC5cblxuICAgIFNheSB0aGlzIGlzIG91ciBzZWFyY2ggZ3JvdXAsIGFuZCB3ZSBtYXRjaCByZWdleDMsIGJ1dCB3aXNoIHRvIGlnbm9yZSBpdC5cblxuICAgICAgcmVnZXgxIHwgcmVnZXgyIHwgcmVnZXgzIHwgcmVnZXg0IHwgcmVnZXg1ICAgICcgaWUsIHN0YXJ0QXQgPSAwXG5cbiAgICBXaGF0IHdlIG5lZWQgaXMgYSBuZXcgTXVsdGlSZWdleCB0aGF0IG9ubHkgaW5jbHVkZXMgdGhlIHJlbWFpbmluZ1xuICAgIHBvc3NpYmlsaXRpZXM6XG5cbiAgICAgIHJlZ2V4NCB8IHJlZ2V4NSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnIGllLCBzdGFydEF0ID0gM1xuXG4gICAgVGhpcyBjbGFzcyB3cmFwcyBhbGwgdGhhdCBjb21wbGV4aXR5IHVwIGluIGEgc2ltcGxlIEFQSS4uLiBgc3RhcnRBdGAgZGVjaWRlc1xuICAgIHdoZXJlIGluIHRoZSBhcnJheSBvZiBleHByZXNzaW9ucyB0byBzdGFydCBkb2luZyB0aGUgbWF0Y2hpbmcuIEl0XG4gICAgYXV0by1pbmNyZW1lbnRzLCBzbyBpZiBhIG1hdGNoIGlzIGZvdW5kIGF0IHBvc2l0aW9uIDIsIHRoZW4gc3RhcnRBdCB3aWxsIGJlXG4gICAgc2V0IHRvIDMuICBJZiB0aGUgZW5kIGlzIHJlYWNoZWQgc3RhcnRBdCB3aWxsIHJldHVybiB0byAwLlxuXG4gICAgTU9TVCBvZiB0aGUgdGltZSB0aGUgcGFyc2VyIHdpbGwgYmUgc2V0dGluZyBzdGFydEF0IG1hbnVhbGx5IHRvIDAuXG4gICovXG4gIGNsYXNzIFJlc3VtYWJsZU11bHRpUmVnZXgge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgdGhpcy5ydWxlcyA9IFtdO1xuICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgdGhpcy5tdWx0aVJlZ2V4ZXMgPSBbXTtcbiAgICAgIHRoaXMuY291bnQgPSAwO1xuXG4gICAgICB0aGlzLmxhc3RJbmRleCA9IDA7XG4gICAgICB0aGlzLnJlZ2V4SW5kZXggPSAwO1xuICAgIH1cblxuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBnZXRNYXRjaGVyKGluZGV4KSB7XG4gICAgICBpZiAodGhpcy5tdWx0aVJlZ2V4ZXNbaW5kZXhdKSByZXR1cm4gdGhpcy5tdWx0aVJlZ2V4ZXNbaW5kZXhdO1xuXG4gICAgICBjb25zdCBtYXRjaGVyID0gbmV3IE11bHRpUmVnZXgoKTtcbiAgICAgIHRoaXMucnVsZXMuc2xpY2UoaW5kZXgpLmZvckVhY2goKFtyZSwgb3B0c10pID0+IG1hdGNoZXIuYWRkUnVsZShyZSwgb3B0cykpO1xuICAgICAgbWF0Y2hlci5jb21waWxlKCk7XG4gICAgICB0aGlzLm11bHRpUmVnZXhlc1tpbmRleF0gPSBtYXRjaGVyO1xuICAgICAgcmV0dXJuIG1hdGNoZXI7XG4gICAgfVxuXG4gICAgcmVzdW1pbmdTY2FuQXRTYW1lUG9zaXRpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5yZWdleEluZGV4ICE9PSAwO1xuICAgIH1cblxuICAgIGNvbnNpZGVyQWxsKCkge1xuICAgICAgdGhpcy5yZWdleEluZGV4ID0gMDtcbiAgICB9XG5cbiAgICAvLyBAdHMtaWdub3JlXG4gICAgYWRkUnVsZShyZSwgb3B0cykge1xuICAgICAgdGhpcy5ydWxlcy5wdXNoKFtyZSwgb3B0c10pO1xuICAgICAgaWYgKG9wdHMudHlwZSA9PT0gXCJiZWdpblwiKSB0aGlzLmNvdW50Kys7XG4gICAgfVxuXG4gICAgLyoqIEBwYXJhbSB7c3RyaW5nfSBzICovXG4gICAgZXhlYyhzKSB7XG4gICAgICBjb25zdCBtID0gdGhpcy5nZXRNYXRjaGVyKHRoaXMucmVnZXhJbmRleCk7XG4gICAgICBtLmxhc3RJbmRleCA9IHRoaXMubGFzdEluZGV4O1xuICAgICAgbGV0IHJlc3VsdCA9IG0uZXhlYyhzKTtcblxuICAgICAgLy8gVGhlIGZvbGxvd2luZyBpcyBiZWNhdXNlIHdlIGhhdmUgbm8gZWFzeSB3YXkgdG8gc2F5IFwicmVzdW1lIHNjYW5uaW5nIGF0IHRoZVxuICAgICAgLy8gZXhpc3RpbmcgcG9zaXRpb24gYnV0IGFsc28gc2tpcCB0aGUgY3VycmVudCBydWxlIE9OTFlcIi4gV2hhdCBoYXBwZW5zIGlzXG4gICAgICAvLyBhbGwgcHJpb3IgcnVsZXMgYXJlIGFsc28gc2tpcHBlZCB3aGljaCBjYW4gcmVzdWx0IGluIG1hdGNoaW5nIHRoZSB3cm9uZ1xuICAgICAgLy8gdGhpbmcuIEV4YW1wbGUgb2YgbWF0Y2hpbmcgXCJib29nZXJcIjpcblxuICAgICAgLy8gb3VyIG1hdGNoZXIgaXMgW3N0cmluZywgXCJib29nZXJcIiwgbnVtYmVyXVxuICAgICAgLy9cbiAgICAgIC8vIC4uLi5ib29nZXIuLi4uXG5cbiAgICAgIC8vIGlmIFwiYm9vZ2VyXCIgaXMgaWdub3JlZCB0aGVuIHdlJ2QgcmVhbGx5IG5lZWQgYSByZWdleCB0byBzY2FuIGZyb20gdGhlXG4gICAgICAvLyBTQU1FIHBvc2l0aW9uIGZvciBvbmx5OiBbc3RyaW5nLCBudW1iZXJdIGJ1dCBpZ25vcmluZyBcImJvb2dlclwiIChpZiBpdFxuICAgICAgLy8gd2FzIHRoZSBmaXJzdCBtYXRjaCksIGEgc2ltcGxlIHJlc3VtZSB3b3VsZCBzY2FuIGFoZWFkIHdobyBrbm93cyBob3dcbiAgICAgIC8vIGZhciBsb29raW5nIG9ubHkgZm9yIFwibnVtYmVyXCIsIGlnbm9yaW5nIHBvdGVudGlhbCBzdHJpbmcgbWF0Y2hlcyAob3JcbiAgICAgIC8vIGZ1dHVyZSBcImJvb2dlclwiIG1hdGNoZXMgdGhhdCBtaWdodCBiZSB2YWxpZC4pXG5cbiAgICAgIC8vIFNvIHdoYXQgd2UgZG86IFdlIGV4ZWN1dGUgdHdvIG1hdGNoZXJzLCBvbmUgcmVzdW1pbmcgYXQgdGhlIHNhbWVcbiAgICAgIC8vIHBvc2l0aW9uLCBidXQgdGhlIHNlY29uZCBmdWxsIG1hdGNoZXIgc3RhcnRpbmcgYXQgdGhlIHBvc2l0aW9uIGFmdGVyOlxuXG4gICAgICAvLyAgICAgLy0tLSByZXN1bWUgZmlyc3QgcmVnZXggbWF0Y2ggaGVyZSAoZm9yIFtudW1iZXJdKVxuICAgICAgLy8gICAgIHwvLS0tLSBmdWxsIG1hdGNoIGhlcmUgZm9yIFtzdHJpbmcsIFwiYm9vZ2VyXCIsIG51bWJlcl1cbiAgICAgIC8vICAgICB2dlxuICAgICAgLy8gLi4uLmJvb2dlci4uLi5cblxuICAgICAgLy8gV2hpY2ggZXZlciByZXN1bHRzIGluIGEgbWF0Y2ggZmlyc3QgaXMgdGhlbiB1c2VkLiBTbyB0aGlzIDMtNCBzdGVwXG4gICAgICAvLyBwcm9jZXNzIGVzc2VudGlhbGx5IGFsbG93cyB1cyB0byBzYXkgXCJtYXRjaCBhdCB0aGlzIHBvc2l0aW9uLCBleGNsdWRpbmdcbiAgICAgIC8vIGEgcHJpb3IgcnVsZSB0aGF0IHdhcyBpZ25vcmVkXCIuXG4gICAgICAvL1xuICAgICAgLy8gMS4gTWF0Y2ggXCJib29nZXJcIiBmaXJzdCwgaWdub3JlLiBBbHNvIHByb3ZlcyB0aGF0IFtzdHJpbmddIGRvZXMgbm9uIG1hdGNoLlxuICAgICAgLy8gMi4gUmVzdW1lIG1hdGNoaW5nIGZvciBbbnVtYmVyXVxuICAgICAgLy8gMy4gTWF0Y2ggYXQgaW5kZXggKyAxIGZvciBbc3RyaW5nLCBcImJvb2dlclwiLCBudW1iZXJdXG4gICAgICAvLyA0LiBJZiAjMiBhbmQgIzMgcmVzdWx0IGluIG1hdGNoZXMsIHdoaWNoIGNhbWUgZmlyc3Q/XG4gICAgICBpZiAodGhpcy5yZXN1bWluZ1NjYW5BdFNhbWVQb3NpdGlvbigpKSB7XG4gICAgICAgIGlmIChyZXN1bHQgJiYgcmVzdWx0LmluZGV4ID09PSB0aGlzLmxhc3RJbmRleCkgOyBlbHNlIHsgLy8gdXNlIHRoZSBzZWNvbmQgbWF0Y2hlciByZXN1bHRcbiAgICAgICAgICBjb25zdCBtMiA9IHRoaXMuZ2V0TWF0Y2hlcigwKTtcbiAgICAgICAgICBtMi5sYXN0SW5kZXggPSB0aGlzLmxhc3RJbmRleCArIDE7XG4gICAgICAgICAgcmVzdWx0ID0gbTIuZXhlYyhzKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgIHRoaXMucmVnZXhJbmRleCArPSByZXN1bHQucG9zaXRpb24gKyAxO1xuICAgICAgICBpZiAodGhpcy5yZWdleEluZGV4ID09PSB0aGlzLmNvdW50KSB7XG4gICAgICAgICAgLy8gd3JhcC1hcm91bmQgdG8gY29uc2lkZXJpbmcgYWxsIG1hdGNoZXMgYWdhaW5cbiAgICAgICAgICB0aGlzLmNvbnNpZGVyQWxsKCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogR2l2ZW4gYSBtb2RlLCBidWlsZHMgYSBodWdlIFJlc3VtYWJsZU11bHRpUmVnZXggdGhhdCBjYW4gYmUgdXNlZCB0byB3YWxrXG4gICAqIHRoZSBjb250ZW50IGFuZCBmaW5kIG1hdGNoZXMuXG4gICAqXG4gICAqIEBwYXJhbSB7Q29tcGlsZWRNb2RlfSBtb2RlXG4gICAqIEByZXR1cm5zIHtSZXN1bWFibGVNdWx0aVJlZ2V4fVxuICAgKi9cbiAgZnVuY3Rpb24gYnVpbGRNb2RlUmVnZXgobW9kZSkge1xuICAgIGNvbnN0IG1tID0gbmV3IFJlc3VtYWJsZU11bHRpUmVnZXgoKTtcblxuICAgIG1vZGUuY29udGFpbnMuZm9yRWFjaCh0ZXJtID0+IG1tLmFkZFJ1bGUodGVybS5iZWdpbiwgeyBydWxlOiB0ZXJtLCB0eXBlOiBcImJlZ2luXCIgfSkpO1xuXG4gICAgaWYgKG1vZGUudGVybWluYXRvckVuZCkge1xuICAgICAgbW0uYWRkUnVsZShtb2RlLnRlcm1pbmF0b3JFbmQsIHsgdHlwZTogXCJlbmRcIiB9KTtcbiAgICB9XG4gICAgaWYgKG1vZGUuaWxsZWdhbCkge1xuICAgICAgbW0uYWRkUnVsZShtb2RlLmlsbGVnYWwsIHsgdHlwZTogXCJpbGxlZ2FsXCIgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG1tO1xuICB9XG5cbiAgLyoqIHNraXAgdnMgYWJvcnQgdnMgaWdub3JlXG4gICAqXG4gICAqIEBza2lwICAgLSBUaGUgbW9kZSBpcyBzdGlsbCBlbnRlcmVkIGFuZCBleGl0ZWQgbm9ybWFsbHkgKGFuZCBjb250YWlucyBydWxlcyBhcHBseSksXG4gICAqICAgICAgICAgICBidXQgYWxsIGNvbnRlbnQgaXMgaGVsZCBhbmQgYWRkZWQgdG8gdGhlIHBhcmVudCBidWZmZXIgcmF0aGVyIHRoYW4gYmVpbmdcbiAgICogICAgICAgICAgIG91dHB1dCB3aGVuIHRoZSBtb2RlIGVuZHMuICBNb3N0bHkgdXNlZCB3aXRoIGBzdWJsYW5ndWFnZWAgdG8gYnVpbGQgdXBcbiAgICogICAgICAgICAgIGEgc2luZ2xlIGxhcmdlIGJ1ZmZlciB0aGFuIGNhbiBiZSBwYXJzZWQgYnkgc3VibGFuZ3VhZ2UuXG4gICAqXG4gICAqICAgICAgICAgICAgIC0gVGhlIG1vZGUgYmVnaW4gYW5kcyBlbmRzIG5vcm1hbGx5LlxuICAgKiAgICAgICAgICAgICAtIENvbnRlbnQgbWF0Y2hlZCBpcyBhZGRlZCB0byB0aGUgcGFyZW50IG1vZGUgYnVmZmVyLlxuICAgKiAgICAgICAgICAgICAtIFRoZSBwYXJzZXIgY3Vyc29yIGlzIG1vdmVkIGZvcndhcmQgbm9ybWFsbHkuXG4gICAqXG4gICAqIEBhYm9ydCAgLSBBIGhhY2sgcGxhY2Vob2xkZXIgdW50aWwgd2UgaGF2ZSBpZ25vcmUuICBBYm9ydHMgdGhlIG1vZGUgKGFzIGlmIGl0XG4gICAqICAgICAgICAgICBuZXZlciBtYXRjaGVkKSBidXQgRE9FUyBOT1QgY29udGludWUgdG8gbWF0Y2ggc3Vic2VxdWVudCBgY29udGFpbnNgXG4gICAqICAgICAgICAgICBtb2Rlcy4gIEFib3J0IGlzIGJhZC9zdWJvcHRpbWFsIGJlY2F1c2UgaXQgY2FuIHJlc3VsdCBpbiBtb2Rlc1xuICAgKiAgICAgICAgICAgZmFydGhlciBkb3duIG5vdCBnZXR0aW5nIGFwcGxpZWQgYmVjYXVzZSBhbiBlYXJsaWVyIHJ1bGUgZWF0cyB0aGVcbiAgICogICAgICAgICAgIGNvbnRlbnQgYnV0IHRoZW4gYWJvcnRzLlxuICAgKlxuICAgKiAgICAgICAgICAgICAtIFRoZSBtb2RlIGRvZXMgbm90IGJlZ2luLlxuICAgKiAgICAgICAgICAgICAtIENvbnRlbnQgbWF0Y2hlZCBieSBgYmVnaW5gIGlzIGFkZGVkIHRvIHRoZSBtb2RlIGJ1ZmZlci5cbiAgICogICAgICAgICAgICAgLSBUaGUgcGFyc2VyIGN1cnNvciBpcyBtb3ZlZCBmb3J3YXJkIGFjY29yZGluZ2x5LlxuICAgKlxuICAgKiBAaWdub3JlIC0gSWdub3JlcyB0aGUgbW9kZSAoYXMgaWYgaXQgbmV2ZXIgbWF0Y2hlZCkgYW5kIGNvbnRpbnVlcyB0byBtYXRjaCBhbnlcbiAgICogICAgICAgICAgIHN1YnNlcXVlbnQgYGNvbnRhaW5zYCBtb2Rlcy4gIElnbm9yZSBpc24ndCB0ZWNobmljYWxseSBwb3NzaWJsZSB3aXRoXG4gICAqICAgICAgICAgICB0aGUgY3VycmVudCBwYXJzZXIgaW1wbGVtZW50YXRpb24uXG4gICAqXG4gICAqICAgICAgICAgICAgIC0gVGhlIG1vZGUgZG9lcyBub3QgYmVnaW4uXG4gICAqICAgICAgICAgICAgIC0gQ29udGVudCBtYXRjaGVkIGJ5IGBiZWdpbmAgaXMgaWdub3JlZC5cbiAgICogICAgICAgICAgICAgLSBUaGUgcGFyc2VyIGN1cnNvciBpcyBub3QgbW92ZWQgZm9yd2FyZC5cbiAgICovXG5cbiAgLyoqXG4gICAqIENvbXBpbGVzIGFuIGluZGl2aWR1YWwgbW9kZVxuICAgKlxuICAgKiBUaGlzIGNhbiByYWlzZSBhbiBlcnJvciBpZiB0aGUgbW9kZSBjb250YWlucyBjZXJ0YWluIGRldGVjdGFibGUga25vd24gbG9naWNcbiAgICogaXNzdWVzLlxuICAgKiBAcGFyYW0ge01vZGV9IG1vZGVcbiAgICogQHBhcmFtIHtDb21waWxlZE1vZGUgfCBudWxsfSBbcGFyZW50XVxuICAgKiBAcmV0dXJucyB7Q29tcGlsZWRNb2RlIHwgbmV2ZXJ9XG4gICAqL1xuICBmdW5jdGlvbiBjb21waWxlTW9kZShtb2RlLCBwYXJlbnQpIHtcbiAgICBjb25zdCBjbW9kZSA9IC8qKiBAdHlwZSBDb21waWxlZE1vZGUgKi8gKG1vZGUpO1xuICAgIGlmIChtb2RlLmlzQ29tcGlsZWQpIHJldHVybiBjbW9kZTtcblxuICAgIFtcbiAgICAgIHNjb3BlQ2xhc3NOYW1lLFxuICAgICAgLy8gZG8gdGhpcyBlYXJseSBzbyBjb21waWxlciBleHRlbnNpb25zIGdlbmVyYWxseSBkb24ndCBoYXZlIHRvIHdvcnJ5IGFib3V0XG4gICAgICAvLyB0aGUgZGlzdGluY3Rpb24gYmV0d2VlbiBtYXRjaC9iZWdpblxuICAgICAgY29tcGlsZU1hdGNoLFxuICAgICAgTXVsdGlDbGFzcyxcbiAgICAgIGJlZm9yZU1hdGNoRXh0XG4gICAgXS5mb3JFYWNoKGV4dCA9PiBleHQobW9kZSwgcGFyZW50KSk7XG5cbiAgICBsYW5ndWFnZS5jb21waWxlckV4dGVuc2lvbnMuZm9yRWFjaChleHQgPT4gZXh0KG1vZGUsIHBhcmVudCkpO1xuXG4gICAgLy8gX19iZWZvcmVCZWdpbiBpcyBjb25zaWRlcmVkIHByaXZhdGUgQVBJLCBpbnRlcm5hbCB1c2Ugb25seVxuICAgIG1vZGUuX19iZWZvcmVCZWdpbiA9IG51bGw7XG5cbiAgICBbXG4gICAgICBiZWdpbktleXdvcmRzLFxuICAgICAgLy8gZG8gdGhpcyBsYXRlciBzbyBjb21waWxlciBleHRlbnNpb25zIHRoYXQgY29tZSBlYXJsaWVyIGhhdmUgYWNjZXNzIHRvIHRoZVxuICAgICAgLy8gcmF3IGFycmF5IGlmIHRoZXkgd2FudGVkIHRvIHBlcmhhcHMgbWFuaXB1bGF0ZSBpdCwgZXRjLlxuICAgICAgY29tcGlsZUlsbGVnYWwsXG4gICAgICAvLyBkZWZhdWx0IHRvIDEgcmVsZXZhbmNlIGlmIG5vdCBzcGVjaWZpZWRcbiAgICAgIGNvbXBpbGVSZWxldmFuY2VcbiAgICBdLmZvckVhY2goZXh0ID0+IGV4dChtb2RlLCBwYXJlbnQpKTtcblxuICAgIG1vZGUuaXNDb21waWxlZCA9IHRydWU7XG5cbiAgICBsZXQga2V5d29yZFBhdHRlcm4gPSBudWxsO1xuICAgIGlmICh0eXBlb2YgbW9kZS5rZXl3b3JkcyA9PT0gXCJvYmplY3RcIiAmJiBtb2RlLmtleXdvcmRzLiRwYXR0ZXJuKSB7XG4gICAgICAvLyB3ZSBuZWVkIGEgY29weSBiZWNhdXNlIGtleXdvcmRzIG1pZ2h0IGJlIGNvbXBpbGVkIG11bHRpcGxlIHRpbWVzXG4gICAgICAvLyBzbyB3ZSBjYW4ndCBnbyBkZWxldGluZyAkcGF0dGVybiBmcm9tIHRoZSBvcmlnaW5hbCBvbiB0aGUgZmlyc3RcbiAgICAgIC8vIHBhc3NcbiAgICAgIG1vZGUua2V5d29yZHMgPSBPYmplY3QuYXNzaWduKHt9LCBtb2RlLmtleXdvcmRzKTtcbiAgICAgIGtleXdvcmRQYXR0ZXJuID0gbW9kZS5rZXl3b3Jkcy4kcGF0dGVybjtcbiAgICAgIGRlbGV0ZSBtb2RlLmtleXdvcmRzLiRwYXR0ZXJuO1xuICAgIH1cbiAgICBrZXl3b3JkUGF0dGVybiA9IGtleXdvcmRQYXR0ZXJuIHx8IC9cXHcrLztcblxuICAgIGlmIChtb2RlLmtleXdvcmRzKSB7XG4gICAgICBtb2RlLmtleXdvcmRzID0gY29tcGlsZUtleXdvcmRzKG1vZGUua2V5d29yZHMsIGxhbmd1YWdlLmNhc2VfaW5zZW5zaXRpdmUpO1xuICAgIH1cblxuICAgIGNtb2RlLmtleXdvcmRQYXR0ZXJuUmUgPSBsYW5nUmUoa2V5d29yZFBhdHRlcm4sIHRydWUpO1xuXG4gICAgaWYgKHBhcmVudCkge1xuICAgICAgaWYgKCFtb2RlLmJlZ2luKSBtb2RlLmJlZ2luID0gL1xcQnxcXGIvO1xuICAgICAgY21vZGUuYmVnaW5SZSA9IGxhbmdSZShtb2RlLmJlZ2luKTtcbiAgICAgIGlmICghbW9kZS5lbmQgJiYgIW1vZGUuZW5kc1dpdGhQYXJlbnQpIG1vZGUuZW5kID0gL1xcQnxcXGIvO1xuICAgICAgaWYgKG1vZGUuZW5kKSBjbW9kZS5lbmRSZSA9IGxhbmdSZShtb2RlLmVuZCk7XG4gICAgICBjbW9kZS50ZXJtaW5hdG9yRW5kID0gc291cmNlKG1vZGUuZW5kKSB8fCAnJztcbiAgICAgIGlmIChtb2RlLmVuZHNXaXRoUGFyZW50ICYmIHBhcmVudC50ZXJtaW5hdG9yRW5kKSB7XG4gICAgICAgIGNtb2RlLnRlcm1pbmF0b3JFbmQgKz0gKG1vZGUuZW5kID8gJ3wnIDogJycpICsgcGFyZW50LnRlcm1pbmF0b3JFbmQ7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChtb2RlLmlsbGVnYWwpIGNtb2RlLmlsbGVnYWxSZSA9IGxhbmdSZSgvKiogQHR5cGUge1JlZ0V4cCB8IHN0cmluZ30gKi8gKG1vZGUuaWxsZWdhbCkpO1xuICAgIGlmICghbW9kZS5jb250YWlucykgbW9kZS5jb250YWlucyA9IFtdO1xuXG4gICAgbW9kZS5jb250YWlucyA9IFtdLmNvbmNhdCguLi5tb2RlLmNvbnRhaW5zLm1hcChmdW5jdGlvbihjKSB7XG4gICAgICByZXR1cm4gZXhwYW5kT3JDbG9uZU1vZGUoYyA9PT0gJ3NlbGYnID8gbW9kZSA6IGMpO1xuICAgIH0pKTtcbiAgICBtb2RlLmNvbnRhaW5zLmZvckVhY2goZnVuY3Rpb24oYykgeyBjb21waWxlTW9kZSgvKiogQHR5cGUgTW9kZSAqLyAoYyksIGNtb2RlKTsgfSk7XG5cbiAgICBpZiAobW9kZS5zdGFydHMpIHtcbiAgICAgIGNvbXBpbGVNb2RlKG1vZGUuc3RhcnRzLCBwYXJlbnQpO1xuICAgIH1cblxuICAgIGNtb2RlLm1hdGNoZXIgPSBidWlsZE1vZGVSZWdleChjbW9kZSk7XG4gICAgcmV0dXJuIGNtb2RlO1xuICB9XG5cbiAgaWYgKCFsYW5ndWFnZS5jb21waWxlckV4dGVuc2lvbnMpIGxhbmd1YWdlLmNvbXBpbGVyRXh0ZW5zaW9ucyA9IFtdO1xuXG4gIC8vIHNlbGYgaXMgbm90IHZhbGlkIGF0IHRoZSB0b3AtbGV2ZWxcbiAgaWYgKGxhbmd1YWdlLmNvbnRhaW5zICYmIGxhbmd1YWdlLmNvbnRhaW5zLmluY2x1ZGVzKCdzZWxmJykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJFUlI6IGNvbnRhaW5zIGBzZWxmYCBpcyBub3Qgc3VwcG9ydGVkIGF0IHRoZSB0b3AtbGV2ZWwgb2YgYSBsYW5ndWFnZS4gIFNlZSBkb2N1bWVudGF0aW9uLlwiKTtcbiAgfVxuXG4gIC8vIHdlIG5lZWQgYSBudWxsIG9iamVjdCwgd2hpY2ggaW5oZXJpdCB3aWxsIGd1YXJhbnRlZVxuICBsYW5ndWFnZS5jbGFzc05hbWVBbGlhc2VzID0gaW5oZXJpdCQxKGxhbmd1YWdlLmNsYXNzTmFtZUFsaWFzZXMgfHwge30pO1xuXG4gIHJldHVybiBjb21waWxlTW9kZSgvKiogQHR5cGUgTW9kZSAqLyAobGFuZ3VhZ2UpKTtcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmVzIGlmIGEgbW9kZSBoYXMgYSBkZXBlbmRlbmN5IG9uIGl0J3MgcGFyZW50IG9yIG5vdFxuICpcbiAqIElmIGEgbW9kZSBkb2VzIGhhdmUgYSBwYXJlbnQgZGVwZW5kZW5jeSB0aGVuIG9mdGVuIHdlIG5lZWQgdG8gY2xvbmUgaXQgaWZcbiAqIGl0J3MgdXNlZCBpbiBtdWx0aXBsZSBwbGFjZXMgc28gdGhhdCBlYWNoIGNvcHkgcG9pbnRzIHRvIHRoZSBjb3JyZWN0IHBhcmVudCxcbiAqIHdoZXJlLWFzIG1vZGVzIHdpdGhvdXQgYSBwYXJlbnQgY2FuIG9mdGVuIHNhZmVseSBiZSByZS11c2VkIGF0IHRoZSBib3R0b20gb2ZcbiAqIGEgbW9kZSBjaGFpbi5cbiAqXG4gKiBAcGFyYW0ge01vZGUgfCBudWxsfSBtb2RlXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gLSBpcyB0aGVyZSBhIGRlcGVuZGVuY3kgb24gdGhlIHBhcmVudD9cbiAqICovXG5mdW5jdGlvbiBkZXBlbmRlbmN5T25QYXJlbnQobW9kZSkge1xuICBpZiAoIW1vZGUpIHJldHVybiBmYWxzZTtcblxuICByZXR1cm4gbW9kZS5lbmRzV2l0aFBhcmVudCB8fCBkZXBlbmRlbmN5T25QYXJlbnQobW9kZS5zdGFydHMpO1xufVxuXG4vKipcbiAqIEV4cGFuZHMgYSBtb2RlIG9yIGNsb25lcyBpdCBpZiBuZWNlc3NhcnlcbiAqXG4gKiBUaGlzIGlzIG5lY2Vzc2FyeSBmb3IgbW9kZXMgd2l0aCBwYXJlbnRhbCBkZXBlbmRlbmNlaXMgKHNlZSBub3RlcyBvblxuICogYGRlcGVuZGVuY3lPblBhcmVudGApIGFuZCBmb3Igbm9kZXMgdGhhdCBoYXZlIGB2YXJpYW50c2AgLSB3aGljaCBtdXN0IHRoZW4gYmVcbiAqIGV4cGxvZGVkIGludG8gdGhlaXIgb3duIGluZGl2aWR1YWwgbW9kZXMgYXQgY29tcGlsZSB0aW1lLlxuICpcbiAqIEBwYXJhbSB7TW9kZX0gbW9kZVxuICogQHJldHVybnMge01vZGUgfCBNb2RlW119XG4gKiAqL1xuZnVuY3Rpb24gZXhwYW5kT3JDbG9uZU1vZGUobW9kZSkge1xuICBpZiAobW9kZS52YXJpYW50cyAmJiAhbW9kZS5jYWNoZWRWYXJpYW50cykge1xuICAgIG1vZGUuY2FjaGVkVmFyaWFudHMgPSBtb2RlLnZhcmlhbnRzLm1hcChmdW5jdGlvbih2YXJpYW50KSB7XG4gICAgICByZXR1cm4gaW5oZXJpdCQxKG1vZGUsIHsgdmFyaWFudHM6IG51bGwgfSwgdmFyaWFudCk7XG4gICAgfSk7XG4gIH1cblxuICAvLyBFWFBBTkRcbiAgLy8gaWYgd2UgaGF2ZSB2YXJpYW50cyB0aGVuIGVzc2VudGlhbGx5IFwicmVwbGFjZVwiIHRoZSBtb2RlIHdpdGggdGhlIHZhcmlhbnRzXG4gIC8vIHRoaXMgaGFwcGVucyBpbiBjb21waWxlTW9kZSwgd2hlcmUgdGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQgZnJvbVxuICBpZiAobW9kZS5jYWNoZWRWYXJpYW50cykge1xuICAgIHJldHVybiBtb2RlLmNhY2hlZFZhcmlhbnRzO1xuICB9XG5cbiAgLy8gQ0xPTkVcbiAgLy8gaWYgd2UgaGF2ZSBkZXBlbmRlbmNpZXMgb24gcGFyZW50cyB0aGVuIHdlIG5lZWQgYSB1bmlxdWVcbiAgLy8gaW5zdGFuY2Ugb2Ygb3Vyc2VsdmVzLCBzbyB3ZSBjYW4gYmUgcmV1c2VkIHdpdGggbWFueVxuICAvLyBkaWZmZXJlbnQgcGFyZW50cyB3aXRob3V0IGlzc3VlXG4gIGlmIChkZXBlbmRlbmN5T25QYXJlbnQobW9kZSkpIHtcbiAgICByZXR1cm4gaW5oZXJpdCQxKG1vZGUsIHsgc3RhcnRzOiBtb2RlLnN0YXJ0cyA/IGluaGVyaXQkMShtb2RlLnN0YXJ0cykgOiBudWxsIH0pO1xuICB9XG5cbiAgaWYgKE9iamVjdC5pc0Zyb3plbihtb2RlKSkge1xuICAgIHJldHVybiBpbmhlcml0JDEobW9kZSk7XG4gIH1cblxuICAvLyBubyBzcGVjaWFsIGRlcGVuZGVuY3kgaXNzdWVzLCBqdXN0IHJldHVybiBvdXJzZWx2ZXNcbiAgcmV0dXJuIG1vZGU7XG59XG5cbnZhciB2ZXJzaW9uID0gXCIxMS4yLjBcIjtcblxuLypcblN5bnRheCBoaWdobGlnaHRpbmcgd2l0aCBsYW5ndWFnZSBhdXRvZGV0ZWN0aW9uLlxuaHR0cHM6Ly9oaWdobGlnaHRqcy5vcmcvXG4qL1xuXG4vKipcbkB0eXBlZGVmIHtpbXBvcnQoJ2hpZ2hsaWdodC5qcycpLk1vZGV9IE1vZGVcbkB0eXBlZGVmIHtpbXBvcnQoJ2hpZ2hsaWdodC5qcycpLkNvbXBpbGVkTW9kZX0gQ29tcGlsZWRNb2RlXG5AdHlwZWRlZiB7aW1wb3J0KCdoaWdobGlnaHQuanMnKS5MYW5ndWFnZX0gTGFuZ3VhZ2VcbkB0eXBlZGVmIHtpbXBvcnQoJ2hpZ2hsaWdodC5qcycpLkhMSlNBcGl9IEhMSlNBcGlcbkB0eXBlZGVmIHtpbXBvcnQoJ2hpZ2hsaWdodC5qcycpLkhMSlNQbHVnaW59IEhMSlNQbHVnaW5cbkB0eXBlZGVmIHtpbXBvcnQoJ2hpZ2hsaWdodC5qcycpLlBsdWdpbkV2ZW50fSBQbHVnaW5FdmVudFxuQHR5cGVkZWYge2ltcG9ydCgnaGlnaGxpZ2h0LmpzJykuSExKU09wdGlvbnN9IEhMSlNPcHRpb25zXG5AdHlwZWRlZiB7aW1wb3J0KCdoaWdobGlnaHQuanMnKS5MYW5ndWFnZUZufSBMYW5ndWFnZUZuXG5AdHlwZWRlZiB7aW1wb3J0KCdoaWdobGlnaHQuanMnKS5IaWdobGlnaHRlZEhUTUxFbGVtZW50fSBIaWdobGlnaHRlZEhUTUxFbGVtZW50XG5AdHlwZWRlZiB7aW1wb3J0KCdoaWdobGlnaHQuanMnKS5CZWZvcmVIaWdobGlnaHRDb250ZXh0fSBCZWZvcmVIaWdobGlnaHRDb250ZXh0XG5AdHlwZWRlZiB7aW1wb3J0KCdoaWdobGlnaHQuanMvcHJpdmF0ZScpLk1hdGNoVHlwZX0gTWF0Y2hUeXBlXG5AdHlwZWRlZiB7aW1wb3J0KCdoaWdobGlnaHQuanMvcHJpdmF0ZScpLktleXdvcmREYXRhfSBLZXl3b3JkRGF0YVxuQHR5cGVkZWYge2ltcG9ydCgnaGlnaGxpZ2h0LmpzL3ByaXZhdGUnKS5FbmhhbmNlZE1hdGNofSBFbmhhbmNlZE1hdGNoXG5AdHlwZWRlZiB7aW1wb3J0KCdoaWdobGlnaHQuanMvcHJpdmF0ZScpLkFubm90YXRlZEVycm9yfSBBbm5vdGF0ZWRFcnJvclxuQHR5cGVkZWYge2ltcG9ydCgnaGlnaGxpZ2h0LmpzJykuQXV0b0hpZ2hsaWdodFJlc3VsdH0gQXV0b0hpZ2hsaWdodFJlc3VsdFxuQHR5cGVkZWYge2ltcG9ydCgnaGlnaGxpZ2h0LmpzJykuSGlnaGxpZ2h0T3B0aW9uc30gSGlnaGxpZ2h0T3B0aW9uc1xuQHR5cGVkZWYge2ltcG9ydCgnaGlnaGxpZ2h0LmpzJykuSGlnaGxpZ2h0UmVzdWx0fSBIaWdobGlnaHRSZXN1bHRcbiovXG5cblxuY29uc3QgZXNjYXBlID0gZXNjYXBlSFRNTDtcbmNvbnN0IGluaGVyaXQgPSBpbmhlcml0JDE7XG5jb25zdCBOT19NQVRDSCA9IFN5bWJvbChcIm5vbWF0Y2hcIik7XG5jb25zdCBNQVhfS0VZV09SRF9ISVRTID0gNztcblxuLyoqXG4gKiBAcGFyYW0ge2FueX0gaGxqcyAtIG9iamVjdCB0aGF0IGlzIGV4dGVuZGVkIChsZWdhY3kpXG4gKiBAcmV0dXJucyB7SExKU0FwaX1cbiAqL1xuY29uc3QgSExKUyA9IGZ1bmN0aW9uKGhsanMpIHtcbiAgLy8gR2xvYmFsIGludGVybmFsIHZhcmlhYmxlcyB1c2VkIHdpdGhpbiB0aGUgaGlnaGxpZ2h0LmpzIGxpYnJhcnkuXG4gIC8qKiBAdHlwZSB7UmVjb3JkPHN0cmluZywgTGFuZ3VhZ2U+fSAqL1xuICBjb25zdCBsYW5ndWFnZXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAvKiogQHR5cGUge1JlY29yZDxzdHJpbmcsIHN0cmluZz59ICovXG4gIGNvbnN0IGFsaWFzZXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAvKiogQHR5cGUge0hMSlNQbHVnaW5bXX0gKi9cbiAgY29uc3QgcGx1Z2lucyA9IFtdO1xuXG4gIC8vIHNhZmUvcHJvZHVjdGlvbiBtb2RlIC0gc3dhbGxvd3MgbW9yZSBlcnJvcnMsIHRyaWVzIHRvIGtlZXAgcnVubmluZ1xuICAvLyBldmVuIGlmIGEgc2luZ2xlIHN5bnRheCBvciBwYXJzZSBoaXRzIGEgZmF0YWwgZXJyb3JcbiAgbGV0IFNBRkVfTU9ERSA9IHRydWU7XG4gIGNvbnN0IExBTkdVQUdFX05PVF9GT1VORCA9IFwiQ291bGQgbm90IGZpbmQgdGhlIGxhbmd1YWdlICd7fScsIGRpZCB5b3UgZm9yZ2V0IHRvIGxvYWQvaW5jbHVkZSBhIGxhbmd1YWdlIG1vZHVsZT9cIjtcbiAgLyoqIEB0eXBlIHtMYW5ndWFnZX0gKi9cbiAgY29uc3QgUExBSU5URVhUX0xBTkdVQUdFID0geyBkaXNhYmxlQXV0b2RldGVjdDogdHJ1ZSwgbmFtZTogJ1BsYWluIHRleHQnLCBjb250YWluczogW10gfTtcblxuICAvLyBHbG9iYWwgb3B0aW9ucyB1c2VkIHdoZW4gd2l0aGluIGV4dGVybmFsIEFQSXMuIFRoaXMgaXMgbW9kaWZpZWQgd2hlblxuICAvLyBjYWxsaW5nIHRoZSBgaGxqcy5jb25maWd1cmVgIGZ1bmN0aW9uLlxuICAvKiogQHR5cGUgSExKU09wdGlvbnMgKi9cbiAgbGV0IG9wdGlvbnMgPSB7XG4gICAgaWdub3JlVW5lc2NhcGVkSFRNTDogZmFsc2UsXG4gICAgbm9IaWdobGlnaHRSZTogL14obm8tP2hpZ2hsaWdodCkkL2ksXG4gICAgbGFuZ3VhZ2VEZXRlY3RSZTogL1xcYmxhbmcoPzp1YWdlKT8tKFtcXHctXSspXFxiL2ksXG4gICAgY2xhc3NQcmVmaXg6ICdobGpzLScsXG4gICAgY3NzU2VsZWN0b3I6ICdwcmUgY29kZScsXG4gICAgbGFuZ3VhZ2VzOiBudWxsLFxuICAgIC8vIGJldGEgY29uZmlndXJhdGlvbiBvcHRpb25zLCBzdWJqZWN0IHRvIGNoYW5nZSwgd2VsY29tZSB0byBkaXNjdXNzXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2hpZ2hsaWdodGpzL2hpZ2hsaWdodC5qcy9pc3N1ZXMvMTA4NlxuICAgIF9fZW1pdHRlcjogVG9rZW5UcmVlRW1pdHRlclxuICB9O1xuXG4gIC8qIFV0aWxpdHkgZnVuY3Rpb25zICovXG5cbiAgLyoqXG4gICAqIFRlc3RzIGEgbGFuZ3VhZ2UgbmFtZSB0byBzZWUgaWYgaGlnaGxpZ2h0aW5nIHNob3VsZCBiZSBza2lwcGVkXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBsYW5ndWFnZU5hbWVcbiAgICovXG4gIGZ1bmN0aW9uIHNob3VsZE5vdEhpZ2hsaWdodChsYW5ndWFnZU5hbWUpIHtcbiAgICByZXR1cm4gb3B0aW9ucy5ub0hpZ2hsaWdodFJlLnRlc3QobGFuZ3VhZ2VOYW1lKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0hpZ2hsaWdodGVkSFRNTEVsZW1lbnR9IGJsb2NrIC0gdGhlIEhUTUwgZWxlbWVudCB0byBkZXRlcm1pbmUgbGFuZ3VhZ2UgZm9yXG4gICAqL1xuICBmdW5jdGlvbiBibG9ja0xhbmd1YWdlKGJsb2NrKSB7XG4gICAgbGV0IGNsYXNzZXMgPSBibG9jay5jbGFzc05hbWUgKyAnICc7XG5cbiAgICBjbGFzc2VzICs9IGJsb2NrLnBhcmVudE5vZGUgPyBibG9jay5wYXJlbnROb2RlLmNsYXNzTmFtZSA6ICcnO1xuXG4gICAgLy8gbGFuZ3VhZ2UtKiB0YWtlcyBwcmVjZWRlbmNlIG92ZXIgbm9uLXByZWZpeGVkIGNsYXNzIG5hbWVzLlxuICAgIGNvbnN0IG1hdGNoID0gb3B0aW9ucy5sYW5ndWFnZURldGVjdFJlLmV4ZWMoY2xhc3Nlcyk7XG4gICAgaWYgKG1hdGNoKSB7XG4gICAgICBjb25zdCBsYW5ndWFnZSA9IGdldExhbmd1YWdlKG1hdGNoWzFdKTtcbiAgICAgIGlmICghbGFuZ3VhZ2UpIHtcbiAgICAgICAgd2FybihMQU5HVUFHRV9OT1RfRk9VTkQucmVwbGFjZShcInt9XCIsIG1hdGNoWzFdKSk7XG4gICAgICAgIHdhcm4oXCJGYWxsaW5nIGJhY2sgdG8gbm8taGlnaGxpZ2h0IG1vZGUgZm9yIHRoaXMgYmxvY2suXCIsIGJsb2NrKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBsYW5ndWFnZSA/IG1hdGNoWzFdIDogJ25vLWhpZ2hsaWdodCc7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNsYXNzZXNcbiAgICAgIC5zcGxpdCgvXFxzKy8pXG4gICAgICAuZmluZCgoX2NsYXNzKSA9PiBzaG91bGROb3RIaWdobGlnaHQoX2NsYXNzKSB8fCBnZXRMYW5ndWFnZShfY2xhc3MpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb3JlIGhpZ2hsaWdodGluZyBmdW5jdGlvbi5cbiAgICpcbiAgICogT0xEIEFQSVxuICAgKiBoaWdobGlnaHQobGFuZywgY29kZSwgaWdub3JlSWxsZWdhbHMsIGNvbnRpbnVhdGlvbilcbiAgICpcbiAgICogTkVXIEFQSVxuICAgKiBoaWdobGlnaHQoY29kZSwge2xhbmcsIGlnbm9yZUlsbGVnYWxzfSlcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNvZGVPckxhbmd1YWdlTmFtZSAtIHRoZSBsYW5ndWFnZSB0byB1c2UgZm9yIGhpZ2hsaWdodGluZ1xuICAgKiBAcGFyYW0ge3N0cmluZyB8IEhpZ2hsaWdodE9wdGlvbnN9IG9wdGlvbnNPckNvZGUgLSB0aGUgY29kZSB0byBoaWdobGlnaHRcbiAgICogQHBhcmFtIHtib29sZWFufSBbaWdub3JlSWxsZWdhbHNdIC0gd2hldGhlciB0byBpZ25vcmUgaWxsZWdhbCBtYXRjaGVzLCBkZWZhdWx0IGlzIHRvIGJhaWxcbiAgICpcbiAgICogQHJldHVybnMge0hpZ2hsaWdodFJlc3VsdH0gUmVzdWx0IC0gYW4gb2JqZWN0IHRoYXQgcmVwcmVzZW50cyB0aGUgcmVzdWx0XG4gICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBsYW5ndWFnZSAtIHRoZSBsYW5ndWFnZSBuYW1lXG4gICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSByZWxldmFuY2UgLSB0aGUgcmVsZXZhbmNlIHNjb3JlXG4gICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSB2YWx1ZSAtIHRoZSBoaWdobGlnaHRlZCBIVE1MIGNvZGVcbiAgICogQHByb3BlcnR5IHtzdHJpbmd9IGNvZGUgLSB0aGUgb3JpZ2luYWwgcmF3IGNvZGVcbiAgICogQHByb3BlcnR5IHtDb21waWxlZE1vZGV9IHRvcCAtIHRvcCBvZiB0aGUgY3VycmVudCBtb2RlIHN0YWNrXG4gICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gaWxsZWdhbCAtIGluZGljYXRlcyB3aGV0aGVyIGFueSBpbGxlZ2FsIG1hdGNoZXMgd2VyZSBmb3VuZFxuICAqL1xuICBmdW5jdGlvbiBoaWdobGlnaHQoY29kZU9yTGFuZ3VhZ2VOYW1lLCBvcHRpb25zT3JDb2RlLCBpZ25vcmVJbGxlZ2Fscykge1xuICAgIGxldCBjb2RlID0gXCJcIjtcbiAgICBsZXQgbGFuZ3VhZ2VOYW1lID0gXCJcIjtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnNPckNvZGUgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgIGNvZGUgPSBjb2RlT3JMYW5ndWFnZU5hbWU7XG4gICAgICBpZ25vcmVJbGxlZ2FscyA9IG9wdGlvbnNPckNvZGUuaWdub3JlSWxsZWdhbHM7XG4gICAgICBsYW5ndWFnZU5hbWUgPSBvcHRpb25zT3JDb2RlLmxhbmd1YWdlO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBvbGQgQVBJXG4gICAgICBkZXByZWNhdGVkKFwiMTAuNy4wXCIsIFwiaGlnaGxpZ2h0KGxhbmcsIGNvZGUsIC4uLmFyZ3MpIGhhcyBiZWVuIGRlcHJlY2F0ZWQuXCIpO1xuICAgICAgZGVwcmVjYXRlZChcIjEwLjcuMFwiLCBcIlBsZWFzZSB1c2UgaGlnaGxpZ2h0KGNvZGUsIG9wdGlvbnMpIGluc3RlYWQuXFxuaHR0cHM6Ly9naXRodWIuY29tL2hpZ2hsaWdodGpzL2hpZ2hsaWdodC5qcy9pc3N1ZXMvMjI3N1wiKTtcbiAgICAgIGxhbmd1YWdlTmFtZSA9IGNvZGVPckxhbmd1YWdlTmFtZTtcbiAgICAgIGNvZGUgPSBvcHRpb25zT3JDb2RlO1xuICAgIH1cblxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9oaWdobGlnaHRqcy9oaWdobGlnaHQuanMvaXNzdWVzLzMxNDlcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5kZWZpbmVkXG4gICAgaWYgKGlnbm9yZUlsbGVnYWxzID09PSB1bmRlZmluZWQpIHsgaWdub3JlSWxsZWdhbHMgPSB0cnVlOyB9XG5cbiAgICAvKiogQHR5cGUge0JlZm9yZUhpZ2hsaWdodENvbnRleHR9ICovXG4gICAgY29uc3QgY29udGV4dCA9IHtcbiAgICAgIGNvZGUsXG4gICAgICBsYW5ndWFnZTogbGFuZ3VhZ2VOYW1lXG4gICAgfTtcbiAgICAvLyB0aGUgcGx1Z2luIGNhbiBjaGFuZ2UgdGhlIGRlc2lyZWQgbGFuZ3VhZ2Ugb3IgdGhlIGNvZGUgdG8gYmUgaGlnaGxpZ2h0ZWRcbiAgICAvLyBqdXN0IGJlIGNoYW5naW5nIHRoZSBvYmplY3QgaXQgd2FzIHBhc3NlZFxuICAgIGZpcmUoXCJiZWZvcmU6aGlnaGxpZ2h0XCIsIGNvbnRleHQpO1xuXG4gICAgLy8gYSBiZWZvcmUgcGx1Z2luIGNhbiB1c3VycCB0aGUgcmVzdWx0IGNvbXBsZXRlbHkgYnkgcHJvdmlkaW5nIGl0J3Mgb3duXG4gICAgLy8gaW4gd2hpY2ggY2FzZSB3ZSBkb24ndCBldmVuIG5lZWQgdG8gY2FsbCBoaWdobGlnaHRcbiAgICBjb25zdCByZXN1bHQgPSBjb250ZXh0LnJlc3VsdFxuICAgICAgPyBjb250ZXh0LnJlc3VsdFxuICAgICAgOiBfaGlnaGxpZ2h0KGNvbnRleHQubGFuZ3VhZ2UsIGNvbnRleHQuY29kZSwgaWdub3JlSWxsZWdhbHMpO1xuXG4gICAgcmVzdWx0LmNvZGUgPSBjb250ZXh0LmNvZGU7XG4gICAgLy8gdGhlIHBsdWdpbiBjYW4gY2hhbmdlIGFueXRoaW5nIGluIHJlc3VsdCB0byBzdWl0ZSBpdFxuICAgIGZpcmUoXCJhZnRlcjpoaWdobGlnaHRcIiwgcmVzdWx0KTtcblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogcHJpdmF0ZSBoaWdobGlnaHQgdGhhdCdzIHVzZWQgaW50ZXJuYWxseSBhbmQgZG9lcyBub3QgZmlyZSBjYWxsYmFja3NcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGxhbmd1YWdlTmFtZSAtIHRoZSBsYW5ndWFnZSB0byB1c2UgZm9yIGhpZ2hsaWdodGluZ1xuICAgKiBAcGFyYW0ge3N0cmluZ30gY29kZVRvSGlnaGxpZ2h0IC0gdGhlIGNvZGUgdG8gaGlnaGxpZ2h0XG4gICAqIEBwYXJhbSB7Ym9vbGVhbj99IFtpZ25vcmVJbGxlZ2Fsc10gLSB3aGV0aGVyIHRvIGlnbm9yZSBpbGxlZ2FsIG1hdGNoZXMsIGRlZmF1bHQgaXMgdG8gYmFpbFxuICAgKiBAcGFyYW0ge0NvbXBpbGVkTW9kZT99IFtjb250aW51YXRpb25dIC0gY3VycmVudCBjb250aW51YXRpb24gbW9kZSwgaWYgYW55XG4gICAqIEByZXR1cm5zIHtIaWdobGlnaHRSZXN1bHR9IC0gcmVzdWx0IG9mIHRoZSBoaWdobGlnaHQgb3BlcmF0aW9uXG4gICovXG4gIGZ1bmN0aW9uIF9oaWdobGlnaHQobGFuZ3VhZ2VOYW1lLCBjb2RlVG9IaWdobGlnaHQsIGlnbm9yZUlsbGVnYWxzLCBjb250aW51YXRpb24pIHtcbiAgICBjb25zdCBrZXl3b3JkSGl0cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4ga2V5d29yZCBkYXRhIGlmIGEgbWF0Y2ggaXMgYSBrZXl3b3JkXG4gICAgICogQHBhcmFtIHtDb21waWxlZE1vZGV9IG1vZGUgLSBjdXJyZW50IG1vZGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbWF0Y2hUZXh0IC0gdGhlIHRleHR1YWwgbWF0Y2hcbiAgICAgKiBAcmV0dXJucyB7S2V5d29yZERhdGEgfCBmYWxzZX1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBrZXl3b3JkRGF0YShtb2RlLCBtYXRjaFRleHQpIHtcbiAgICAgIHJldHVybiBtb2RlLmtleXdvcmRzW21hdGNoVGV4dF07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcHJvY2Vzc0tleXdvcmRzKCkge1xuICAgICAgaWYgKCF0b3Aua2V5d29yZHMpIHtcbiAgICAgICAgZW1pdHRlci5hZGRUZXh0KG1vZGVCdWZmZXIpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGxldCBsYXN0SW5kZXggPSAwO1xuICAgICAgdG9wLmtleXdvcmRQYXR0ZXJuUmUubGFzdEluZGV4ID0gMDtcbiAgICAgIGxldCBtYXRjaCA9IHRvcC5rZXl3b3JkUGF0dGVyblJlLmV4ZWMobW9kZUJ1ZmZlcik7XG4gICAgICBsZXQgYnVmID0gXCJcIjtcblxuICAgICAgd2hpbGUgKG1hdGNoKSB7XG4gICAgICAgIGJ1ZiArPSBtb2RlQnVmZmVyLnN1YnN0cmluZyhsYXN0SW5kZXgsIG1hdGNoLmluZGV4KTtcbiAgICAgICAgY29uc3Qgd29yZCA9IGxhbmd1YWdlLmNhc2VfaW5zZW5zaXRpdmUgPyBtYXRjaFswXS50b0xvd2VyQ2FzZSgpIDogbWF0Y2hbMF07XG4gICAgICAgIGNvbnN0IGRhdGEgPSBrZXl3b3JkRGF0YSh0b3AsIHdvcmQpO1xuICAgICAgICBpZiAoZGF0YSkge1xuICAgICAgICAgIGNvbnN0IFtraW5kLCBrZXl3b3JkUmVsZXZhbmNlXSA9IGRhdGE7XG4gICAgICAgICAgZW1pdHRlci5hZGRUZXh0KGJ1Zik7XG4gICAgICAgICAgYnVmID0gXCJcIjtcblxuICAgICAgICAgIGtleXdvcmRIaXRzW3dvcmRdID0gKGtleXdvcmRIaXRzW3dvcmRdIHx8IDApICsgMTtcbiAgICAgICAgICBpZiAoa2V5d29yZEhpdHNbd29yZF0gPD0gTUFYX0tFWVdPUkRfSElUUykgcmVsZXZhbmNlICs9IGtleXdvcmRSZWxldmFuY2U7XG4gICAgICAgICAgaWYgKGtpbmQuc3RhcnRzV2l0aChcIl9cIikpIHtcbiAgICAgICAgICAgIC8vIF8gaW1wbGllZCBmb3IgcmVsZXZhbmNlIG9ubHksIGRvIG5vdCBoaWdobGlnaHRcbiAgICAgICAgICAgIC8vIGJ5IGFwcGx5aW5nIGEgY2xhc3MgbmFtZVxuICAgICAgICAgICAgYnVmICs9IG1hdGNoWzBdO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBjc3NDbGFzcyA9IGxhbmd1YWdlLmNsYXNzTmFtZUFsaWFzZXNba2luZF0gfHwga2luZDtcbiAgICAgICAgICAgIGVtaXR0ZXIuYWRkS2V5d29yZChtYXRjaFswXSwgY3NzQ2xhc3MpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBidWYgKz0gbWF0Y2hbMF07XG4gICAgICAgIH1cbiAgICAgICAgbGFzdEluZGV4ID0gdG9wLmtleXdvcmRQYXR0ZXJuUmUubGFzdEluZGV4O1xuICAgICAgICBtYXRjaCA9IHRvcC5rZXl3b3JkUGF0dGVyblJlLmV4ZWMobW9kZUJ1ZmZlcik7XG4gICAgICB9XG4gICAgICBidWYgKz0gbW9kZUJ1ZmZlci5zdWJzdHIobGFzdEluZGV4KTtcbiAgICAgIGVtaXR0ZXIuYWRkVGV4dChidWYpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHByb2Nlc3NTdWJMYW5ndWFnZSgpIHtcbiAgICAgIGlmIChtb2RlQnVmZmVyID09PSBcIlwiKSByZXR1cm47XG4gICAgICAvKiogQHR5cGUgSGlnaGxpZ2h0UmVzdWx0ICovXG4gICAgICBsZXQgcmVzdWx0ID0gbnVsbDtcblxuICAgICAgaWYgKHR5cGVvZiB0b3Auc3ViTGFuZ3VhZ2UgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGlmICghbGFuZ3VhZ2VzW3RvcC5zdWJMYW5ndWFnZV0pIHtcbiAgICAgICAgICBlbWl0dGVyLmFkZFRleHQobW9kZUJ1ZmZlcik7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdCA9IF9oaWdobGlnaHQodG9wLnN1Ykxhbmd1YWdlLCBtb2RlQnVmZmVyLCB0cnVlLCBjb250aW51YXRpb25zW3RvcC5zdWJMYW5ndWFnZV0pO1xuICAgICAgICBjb250aW51YXRpb25zW3RvcC5zdWJMYW5ndWFnZV0gPSAvKiogQHR5cGUge0NvbXBpbGVkTW9kZX0gKi8gKHJlc3VsdC5fdG9wKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdCA9IGhpZ2hsaWdodEF1dG8obW9kZUJ1ZmZlciwgdG9wLnN1Ykxhbmd1YWdlLmxlbmd0aCA/IHRvcC5zdWJMYW5ndWFnZSA6IG51bGwpO1xuICAgICAgfVxuXG4gICAgICAvLyBDb3VudGluZyBlbWJlZGRlZCBsYW5ndWFnZSBzY29yZSB0b3dhcmRzIHRoZSBob3N0IGxhbmd1YWdlIG1heSBiZSBkaXNhYmxlZFxuICAgICAgLy8gd2l0aCB6ZXJvaW5nIHRoZSBjb250YWluaW5nIG1vZGUgcmVsZXZhbmNlLiBVc2UgY2FzZSBpbiBwb2ludCBpcyBNYXJrZG93biB0aGF0XG4gICAgICAvLyBhbGxvd3MgWE1MIGV2ZXJ5d2hlcmUgYW5kIG1ha2VzIGV2ZXJ5IFhNTCBzbmlwcGV0IHRvIGhhdmUgYSBtdWNoIGxhcmdlciBNYXJrZG93blxuICAgICAgLy8gc2NvcmUuXG4gICAgICBpZiAodG9wLnJlbGV2YW5jZSA+IDApIHtcbiAgICAgICAgcmVsZXZhbmNlICs9IHJlc3VsdC5yZWxldmFuY2U7XG4gICAgICB9XG4gICAgICBlbWl0dGVyLmFkZFN1Ymxhbmd1YWdlKHJlc3VsdC5fZW1pdHRlciwgcmVzdWx0Lmxhbmd1YWdlKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwcm9jZXNzQnVmZmVyKCkge1xuICAgICAgaWYgKHRvcC5zdWJMYW5ndWFnZSAhPSBudWxsKSB7XG4gICAgICAgIHByb2Nlc3NTdWJMYW5ndWFnZSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHJvY2Vzc0tleXdvcmRzKCk7XG4gICAgICB9XG4gICAgICBtb2RlQnVmZmVyID0gJyc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtDb21waWxlZE1vZGV9IG1vZGVcbiAgICAgKiBAcGFyYW0ge1JlZ0V4cE1hdGNoQXJyYXl9IG1hdGNoXG4gICAgICovXG4gICAgZnVuY3Rpb24gZW1pdE11bHRpQ2xhc3Moc2NvcGUsIG1hdGNoKSB7XG4gICAgICBsZXQgaSA9IDE7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5kZWZpbmVkXG4gICAgICB3aGlsZSAobWF0Y2hbaV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAoIXNjb3BlLl9lbWl0W2ldKSB7IGkrKzsgY29udGludWU7IH1cbiAgICAgICAgY29uc3Qga2xhc3MgPSBsYW5ndWFnZS5jbGFzc05hbWVBbGlhc2VzW3Njb3BlW2ldXSB8fCBzY29wZVtpXTtcbiAgICAgICAgY29uc3QgdGV4dCA9IG1hdGNoW2ldO1xuICAgICAgICBpZiAoa2xhc3MpIHtcbiAgICAgICAgICBlbWl0dGVyLmFkZEtleXdvcmQodGV4dCwga2xhc3MpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG1vZGVCdWZmZXIgPSB0ZXh0O1xuICAgICAgICAgIHByb2Nlc3NLZXl3b3JkcygpO1xuICAgICAgICAgIG1vZGVCdWZmZXIgPSBcIlwiO1xuICAgICAgICB9XG4gICAgICAgIGkrKztcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0NvbXBpbGVkTW9kZX0gbW9kZSAtIG5ldyBtb2RlIHRvIHN0YXJ0XG4gICAgICogQHBhcmFtIHtSZWdFeHBNYXRjaEFycmF5fSBtYXRjaFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHN0YXJ0TmV3TW9kZShtb2RlLCBtYXRjaCkge1xuICAgICAgaWYgKG1vZGUuc2NvcGUgJiYgdHlwZW9mIG1vZGUuc2NvcGUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgZW1pdHRlci5vcGVuTm9kZShsYW5ndWFnZS5jbGFzc05hbWVBbGlhc2VzW21vZGUuc2NvcGVdIHx8IG1vZGUuc2NvcGUpO1xuICAgICAgfVxuICAgICAgaWYgKG1vZGUuYmVnaW5TY29wZSkge1xuICAgICAgICAvLyBiZWdpblNjb3BlIGp1c3Qgd3JhcHMgdGhlIGJlZ2luIG1hdGNoIGl0c2VsZiBpbiBhIHNjb3BlXG4gICAgICAgIGlmIChtb2RlLmJlZ2luU2NvcGUuX3dyYXApIHtcbiAgICAgICAgICBlbWl0dGVyLmFkZEtleXdvcmQobW9kZUJ1ZmZlciwgbGFuZ3VhZ2UuY2xhc3NOYW1lQWxpYXNlc1ttb2RlLmJlZ2luU2NvcGUuX3dyYXBdIHx8IG1vZGUuYmVnaW5TY29wZS5fd3JhcCk7XG4gICAgICAgICAgbW9kZUJ1ZmZlciA9IFwiXCI7XG4gICAgICAgIH0gZWxzZSBpZiAobW9kZS5iZWdpblNjb3BlLl9tdWx0aSkge1xuICAgICAgICAgIC8vIGF0IHRoaXMgcG9pbnQgbW9kZUJ1ZmZlciBzaG91bGQganVzdCBiZSB0aGUgbWF0Y2hcbiAgICAgICAgICBlbWl0TXVsdGlDbGFzcyhtb2RlLmJlZ2luU2NvcGUsIG1hdGNoKTtcbiAgICAgICAgICBtb2RlQnVmZmVyID0gXCJcIjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0b3AgPSBPYmplY3QuY3JlYXRlKG1vZGUsIHsgcGFyZW50OiB7IHZhbHVlOiB0b3AgfSB9KTtcbiAgICAgIHJldHVybiB0b3A7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtDb21waWxlZE1vZGUgfSBtb2RlIC0gdGhlIG1vZGUgdG8gcG90ZW50aWFsbHkgZW5kXG4gICAgICogQHBhcmFtIHtSZWdFeHBNYXRjaEFycmF5fSBtYXRjaCAtIHRoZSBsYXRlc3QgbWF0Y2hcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbWF0Y2hQbHVzUmVtYWluZGVyIC0gbWF0Y2ggcGx1cyByZW1haW5kZXIgb2YgY29udGVudFxuICAgICAqIEByZXR1cm5zIHtDb21waWxlZE1vZGUgfCB2b2lkfSAtIHRoZSBuZXh0IG1vZGUsIG9yIGlmIHZvaWQgY29udGludWUgb24gaW4gY3VycmVudCBtb2RlXG4gICAgICovXG4gICAgZnVuY3Rpb24gZW5kT2ZNb2RlKG1vZGUsIG1hdGNoLCBtYXRjaFBsdXNSZW1haW5kZXIpIHtcbiAgICAgIGxldCBtYXRjaGVkID0gc3RhcnRzV2l0aChtb2RlLmVuZFJlLCBtYXRjaFBsdXNSZW1haW5kZXIpO1xuXG4gICAgICBpZiAobWF0Y2hlZCkge1xuICAgICAgICBpZiAobW9kZVtcIm9uOmVuZFwiXSkge1xuICAgICAgICAgIGNvbnN0IHJlc3AgPSBuZXcgUmVzcG9uc2UobW9kZSk7XG4gICAgICAgICAgbW9kZVtcIm9uOmVuZFwiXShtYXRjaCwgcmVzcCk7XG4gICAgICAgICAgaWYgKHJlc3AuaXNNYXRjaElnbm9yZWQpIG1hdGNoZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtYXRjaGVkKSB7XG4gICAgICAgICAgd2hpbGUgKG1vZGUuZW5kc1BhcmVudCAmJiBtb2RlLnBhcmVudCkge1xuICAgICAgICAgICAgbW9kZSA9IG1vZGUucGFyZW50O1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbW9kZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gZXZlbiBpZiBvbjplbmQgZmlyZXMgYW4gYGlnbm9yZWAgaXQncyBzdGlsbCBwb3NzaWJsZVxuICAgICAgLy8gdGhhdCB3ZSBtaWdodCB0cmlnZ2VyIHRoZSBlbmQgbm9kZSBiZWNhdXNlIG9mIGEgcGFyZW50IG1vZGVcbiAgICAgIGlmIChtb2RlLmVuZHNXaXRoUGFyZW50KSB7XG4gICAgICAgIHJldHVybiBlbmRPZk1vZGUobW9kZS5wYXJlbnQsIG1hdGNoLCBtYXRjaFBsdXNSZW1haW5kZXIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEhhbmRsZSBtYXRjaGluZyBidXQgdGhlbiBpZ25vcmluZyBhIHNlcXVlbmNlIG9mIHRleHRcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBsZXhlbWUgLSBzdHJpbmcgY29udGFpbmluZyBmdWxsIG1hdGNoIHRleHRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBkb0lnbm9yZShsZXhlbWUpIHtcbiAgICAgIGlmICh0b3AubWF0Y2hlci5yZWdleEluZGV4ID09PSAwKSB7XG4gICAgICAgIC8vIG5vIG1vcmUgcmVnZXhlcyB0byBwb3RlbnRpYWxseSBtYXRjaCBoZXJlLCBzbyB3ZSBtb3ZlIHRoZSBjdXJzb3IgZm9yd2FyZCBvbmVcbiAgICAgICAgLy8gc3BhY2VcbiAgICAgICAgbW9kZUJ1ZmZlciArPSBsZXhlbWVbMF07XG4gICAgICAgIHJldHVybiAxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gbm8gbmVlZCB0byBtb3ZlIHRoZSBjdXJzb3IsIHdlIHN0aWxsIGhhdmUgYWRkaXRpb25hbCByZWdleGVzIHRvIHRyeSBhbmRcbiAgICAgICAgLy8gbWF0Y2ggYXQgdGhpcyB2ZXJ5IHNwb3RcbiAgICAgICAgcmVzdW1lU2NhbkF0U2FtZVBvc2l0aW9uID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSGFuZGxlIHRoZSBzdGFydCBvZiBhIG5ldyBwb3RlbnRpYWwgbW9kZSBtYXRjaFxuICAgICAqXG4gICAgICogQHBhcmFtIHtFbmhhbmNlZE1hdGNofSBtYXRjaCAtIHRoZSBjdXJyZW50IG1hdGNoXG4gICAgICogQHJldHVybnMge251bWJlcn0gaG93IGZhciB0byBhZHZhbmNlIHRoZSBwYXJzZSBjdXJzb3JcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBkb0JlZ2luTWF0Y2gobWF0Y2gpIHtcbiAgICAgIGNvbnN0IGxleGVtZSA9IG1hdGNoWzBdO1xuICAgICAgY29uc3QgbmV3TW9kZSA9IG1hdGNoLnJ1bGU7XG5cbiAgICAgIGNvbnN0IHJlc3AgPSBuZXcgUmVzcG9uc2UobmV3TW9kZSk7XG4gICAgICAvLyBmaXJzdCBpbnRlcm5hbCBiZWZvcmUgY2FsbGJhY2tzLCB0aGVuIHRoZSBwdWJsaWMgb25lc1xuICAgICAgY29uc3QgYmVmb3JlQ2FsbGJhY2tzID0gW25ld01vZGUuX19iZWZvcmVCZWdpbiwgbmV3TW9kZVtcIm9uOmJlZ2luXCJdXTtcbiAgICAgIGZvciAoY29uc3QgY2Igb2YgYmVmb3JlQ2FsbGJhY2tzKSB7XG4gICAgICAgIGlmICghY2IpIGNvbnRpbnVlO1xuICAgICAgICBjYihtYXRjaCwgcmVzcCk7XG4gICAgICAgIGlmIChyZXNwLmlzTWF0Y2hJZ25vcmVkKSByZXR1cm4gZG9JZ25vcmUobGV4ZW1lKTtcbiAgICAgIH1cblxuICAgICAgaWYgKG5ld01vZGUuc2tpcCkge1xuICAgICAgICBtb2RlQnVmZmVyICs9IGxleGVtZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChuZXdNb2RlLmV4Y2x1ZGVCZWdpbikge1xuICAgICAgICAgIG1vZGVCdWZmZXIgKz0gbGV4ZW1lO1xuICAgICAgICB9XG4gICAgICAgIHByb2Nlc3NCdWZmZXIoKTtcbiAgICAgICAgaWYgKCFuZXdNb2RlLnJldHVybkJlZ2luICYmICFuZXdNb2RlLmV4Y2x1ZGVCZWdpbikge1xuICAgICAgICAgIG1vZGVCdWZmZXIgPSBsZXhlbWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHN0YXJ0TmV3TW9kZShuZXdNb2RlLCBtYXRjaCk7XG4gICAgICByZXR1cm4gbmV3TW9kZS5yZXR1cm5CZWdpbiA/IDAgOiBsZXhlbWUubGVuZ3RoO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEhhbmRsZSB0aGUgcG90ZW50aWFsIGVuZCBvZiBtb2RlXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1JlZ0V4cE1hdGNoQXJyYXl9IG1hdGNoIC0gdGhlIGN1cnJlbnQgbWF0Y2hcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBkb0VuZE1hdGNoKG1hdGNoKSB7XG4gICAgICBjb25zdCBsZXhlbWUgPSBtYXRjaFswXTtcbiAgICAgIGNvbnN0IG1hdGNoUGx1c1JlbWFpbmRlciA9IGNvZGVUb0hpZ2hsaWdodC5zdWJzdHIobWF0Y2guaW5kZXgpO1xuXG4gICAgICBjb25zdCBlbmRNb2RlID0gZW5kT2ZNb2RlKHRvcCwgbWF0Y2gsIG1hdGNoUGx1c1JlbWFpbmRlcik7XG4gICAgICBpZiAoIWVuZE1vZGUpIHsgcmV0dXJuIE5PX01BVENIOyB9XG5cbiAgICAgIGNvbnN0IG9yaWdpbiA9IHRvcDtcbiAgICAgIGlmICh0b3AuZW5kU2NvcGUgJiYgdG9wLmVuZFNjb3BlLl93cmFwKSB7XG4gICAgICAgIHByb2Nlc3NCdWZmZXIoKTtcbiAgICAgICAgZW1pdHRlci5hZGRLZXl3b3JkKGxleGVtZSwgdG9wLmVuZFNjb3BlLl93cmFwKTtcbiAgICAgIH0gZWxzZSBpZiAodG9wLmVuZFNjb3BlICYmIHRvcC5lbmRTY29wZS5fbXVsdGkpIHtcbiAgICAgICAgcHJvY2Vzc0J1ZmZlcigpO1xuICAgICAgICBlbWl0TXVsdGlDbGFzcyh0b3AuZW5kU2NvcGUsIG1hdGNoKTtcbiAgICAgIH0gZWxzZSBpZiAob3JpZ2luLnNraXApIHtcbiAgICAgICAgbW9kZUJ1ZmZlciArPSBsZXhlbWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoIShvcmlnaW4ucmV0dXJuRW5kIHx8IG9yaWdpbi5leGNsdWRlRW5kKSkge1xuICAgICAgICAgIG1vZGVCdWZmZXIgKz0gbGV4ZW1lO1xuICAgICAgICB9XG4gICAgICAgIHByb2Nlc3NCdWZmZXIoKTtcbiAgICAgICAgaWYgKG9yaWdpbi5leGNsdWRlRW5kKSB7XG4gICAgICAgICAgbW9kZUJ1ZmZlciA9IGxleGVtZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZG8ge1xuICAgICAgICBpZiAodG9wLnNjb3BlKSB7XG4gICAgICAgICAgZW1pdHRlci5jbG9zZU5vZGUoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRvcC5za2lwICYmICF0b3Auc3ViTGFuZ3VhZ2UpIHtcbiAgICAgICAgICByZWxldmFuY2UgKz0gdG9wLnJlbGV2YW5jZTtcbiAgICAgICAgfVxuICAgICAgICB0b3AgPSB0b3AucGFyZW50O1xuICAgICAgfSB3aGlsZSAodG9wICE9PSBlbmRNb2RlLnBhcmVudCk7XG4gICAgICBpZiAoZW5kTW9kZS5zdGFydHMpIHtcbiAgICAgICAgc3RhcnROZXdNb2RlKGVuZE1vZGUuc3RhcnRzLCBtYXRjaCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gb3JpZ2luLnJldHVybkVuZCA/IDAgOiBsZXhlbWUubGVuZ3RoO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHByb2Nlc3NDb250aW51YXRpb25zKCkge1xuICAgICAgY29uc3QgbGlzdCA9IFtdO1xuICAgICAgZm9yIChsZXQgY3VycmVudCA9IHRvcDsgY3VycmVudCAhPT0gbGFuZ3VhZ2U7IGN1cnJlbnQgPSBjdXJyZW50LnBhcmVudCkge1xuICAgICAgICBpZiAoY3VycmVudC5zY29wZSkge1xuICAgICAgICAgIGxpc3QudW5zaGlmdChjdXJyZW50LnNjb3BlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgbGlzdC5mb3JFYWNoKGl0ZW0gPT4gZW1pdHRlci5vcGVuTm9kZShpdGVtKSk7XG4gICAgfVxuXG4gICAgLyoqIEB0eXBlIHt7dHlwZT86IE1hdGNoVHlwZSwgaW5kZXg/OiBudW1iZXIsIHJ1bGU/OiBNb2RlfX19ICovXG4gICAgbGV0IGxhc3RNYXRjaCA9IHt9O1xuXG4gICAgLyoqXG4gICAgICogIFByb2Nlc3MgYW4gaW5kaXZpZHVhbCBtYXRjaFxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRleHRCZWZvcmVNYXRjaCAtIHRleHQgcHJlY2VkaW5nIHRoZSBtYXRjaCAoc2luY2UgdGhlIGxhc3QgbWF0Y2gpXG4gICAgICogQHBhcmFtIHtFbmhhbmNlZE1hdGNofSBbbWF0Y2hdIC0gdGhlIG1hdGNoIGl0c2VsZlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHByb2Nlc3NMZXhlbWUodGV4dEJlZm9yZU1hdGNoLCBtYXRjaCkge1xuICAgICAgY29uc3QgbGV4ZW1lID0gbWF0Y2ggJiYgbWF0Y2hbMF07XG5cbiAgICAgIC8vIGFkZCBub24tbWF0Y2hlZCB0ZXh0IHRvIHRoZSBjdXJyZW50IG1vZGUgYnVmZmVyXG4gICAgICBtb2RlQnVmZmVyICs9IHRleHRCZWZvcmVNYXRjaDtcblxuICAgICAgaWYgKGxleGVtZSA9PSBudWxsKSB7XG4gICAgICAgIHByb2Nlc3NCdWZmZXIoKTtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9XG5cbiAgICAgIC8vIHdlJ3ZlIGZvdW5kIGEgMCB3aWR0aCBtYXRjaCBhbmQgd2UncmUgc3R1Y2ssIHNvIHdlIG5lZWQgdG8gYWR2YW5jZVxuICAgICAgLy8gdGhpcyBoYXBwZW5zIHdoZW4gd2UgaGF2ZSBiYWRseSBiZWhhdmVkIHJ1bGVzIHRoYXQgaGF2ZSBvcHRpb25hbCBtYXRjaGVycyB0byB0aGUgZGVncmVlIHRoYXRcbiAgICAgIC8vIHNvbWV0aW1lcyB0aGV5IGNhbiBlbmQgdXAgbWF0Y2hpbmcgbm90aGluZyBhdCBhbGxcbiAgICAgIC8vIFJlZjogaHR0cHM6Ly9naXRodWIuY29tL2hpZ2hsaWdodGpzL2hpZ2hsaWdodC5qcy9pc3N1ZXMvMjE0MFxuICAgICAgaWYgKGxhc3RNYXRjaC50eXBlID09PSBcImJlZ2luXCIgJiYgbWF0Y2gudHlwZSA9PT0gXCJlbmRcIiAmJiBsYXN0TWF0Y2guaW5kZXggPT09IG1hdGNoLmluZGV4ICYmIGxleGVtZSA9PT0gXCJcIikge1xuICAgICAgICAvLyBzcGl0IHRoZSBcInNraXBwZWRcIiBjaGFyYWN0ZXIgdGhhdCBvdXIgcmVnZXggY2hva2VkIG9uIGJhY2sgaW50byB0aGUgb3V0cHV0IHNlcXVlbmNlXG4gICAgICAgIG1vZGVCdWZmZXIgKz0gY29kZVRvSGlnaGxpZ2h0LnNsaWNlKG1hdGNoLmluZGV4LCBtYXRjaC5pbmRleCArIDEpO1xuICAgICAgICBpZiAoIVNBRkVfTU9ERSkge1xuICAgICAgICAgIC8qKiBAdHlwZSB7QW5ub3RhdGVkRXJyb3J9ICovXG4gICAgICAgICAgY29uc3QgZXJyID0gbmV3IEVycm9yKGAwIHdpZHRoIG1hdGNoIHJlZ2V4ICgke2xhbmd1YWdlTmFtZX0pYCk7XG4gICAgICAgICAgZXJyLmxhbmd1YWdlTmFtZSA9IGxhbmd1YWdlTmFtZTtcbiAgICAgICAgICBlcnIuYmFkUnVsZSA9IGxhc3RNYXRjaC5ydWxlO1xuICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gMTtcbiAgICAgIH1cbiAgICAgIGxhc3RNYXRjaCA9IG1hdGNoO1xuXG4gICAgICBpZiAobWF0Y2gudHlwZSA9PT0gXCJiZWdpblwiKSB7XG4gICAgICAgIHJldHVybiBkb0JlZ2luTWF0Y2gobWF0Y2gpO1xuICAgICAgfSBlbHNlIGlmIChtYXRjaC50eXBlID09PSBcImlsbGVnYWxcIiAmJiAhaWdub3JlSWxsZWdhbHMpIHtcbiAgICAgICAgLy8gaWxsZWdhbCBtYXRjaCwgd2UgZG8gbm90IGNvbnRpbnVlIHByb2Nlc3NpbmdcbiAgICAgICAgLyoqIEB0eXBlIHtBbm5vdGF0ZWRFcnJvcn0gKi9cbiAgICAgICAgY29uc3QgZXJyID0gbmV3IEVycm9yKCdJbGxlZ2FsIGxleGVtZSBcIicgKyBsZXhlbWUgKyAnXCIgZm9yIG1vZGUgXCInICsgKHRvcC5zY29wZSB8fCAnPHVubmFtZWQ+JykgKyAnXCInKTtcbiAgICAgICAgZXJyLm1vZGUgPSB0b3A7XG4gICAgICAgIHRocm93IGVycjtcbiAgICAgIH0gZWxzZSBpZiAobWF0Y2gudHlwZSA9PT0gXCJlbmRcIikge1xuICAgICAgICBjb25zdCBwcm9jZXNzZWQgPSBkb0VuZE1hdGNoKG1hdGNoKTtcbiAgICAgICAgaWYgKHByb2Nlc3NlZCAhPT0gTk9fTUFUQ0gpIHtcbiAgICAgICAgICByZXR1cm4gcHJvY2Vzc2VkO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIGVkZ2UgY2FzZSBmb3Igd2hlbiBpbGxlZ2FsIG1hdGNoZXMgJCAoZW5kIG9mIGxpbmUpIHdoaWNoIGlzIHRlY2huaWNhbGx5XG4gICAgICAvLyBhIDAgd2lkdGggbWF0Y2ggYnV0IG5vdCBhIGJlZ2luL2VuZCBtYXRjaCBzbyBpdCdzIG5vdCBjYXVnaHQgYnkgdGhlXG4gICAgICAvLyBmaXJzdCBoYW5kbGVyICh3aGVuIGlnbm9yZUlsbGVnYWxzIGlzIHRydWUpXG4gICAgICBpZiAobWF0Y2gudHlwZSA9PT0gXCJpbGxlZ2FsXCIgJiYgbGV4ZW1lID09PSBcIlwiKSB7XG4gICAgICAgIC8vIGFkdmFuY2Ugc28gd2UgYXJlbid0IHN0dWNrIGluIGFuIGluZmluaXRlIGxvb3BcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgICB9XG5cbiAgICAgIC8vIGluZmluaXRlIGxvb3BzIGFyZSBCQUQsIHRoaXMgaXMgYSBsYXN0IGRpdGNoIGNhdGNoIGFsbC4gaWYgd2UgaGF2ZSBhXG4gICAgICAvLyBkZWNlbnQgbnVtYmVyIG9mIGl0ZXJhdGlvbnMgeWV0IG91ciBpbmRleCAoY3Vyc29yIHBvc2l0aW9uIGluIG91clxuICAgICAgLy8gcGFyc2luZykgc3RpbGwgM3ggYmVoaW5kIG91ciBpbmRleCB0aGVuIHNvbWV0aGluZyBpcyB2ZXJ5IHdyb25nXG4gICAgICAvLyBzbyB3ZSBiYWlsXG4gICAgICBpZiAoaXRlcmF0aW9ucyA+IDEwMDAwMCAmJiBpdGVyYXRpb25zID4gbWF0Y2guaW5kZXggKiAzKSB7XG4gICAgICAgIGNvbnN0IGVyciA9IG5ldyBFcnJvcigncG90ZW50aWFsIGluZmluaXRlIGxvb3AsIHdheSBtb3JlIGl0ZXJhdGlvbnMgdGhhbiBtYXRjaGVzJyk7XG4gICAgICAgIHRocm93IGVycjtcbiAgICAgIH1cblxuICAgICAgLypcbiAgICAgIFdoeSBtaWdodCBiZSBmaW5kIG91cnNlbHZlcyBoZXJlPyAgQW4gcG90ZW50aWFsIGVuZCBtYXRjaCB0aGF0IHdhc1xuICAgICAgdHJpZ2dlcmVkIGJ1dCBjb3VsZCBub3QgYmUgY29tcGxldGVkLiAgSUUsIGBkb0VuZE1hdGNoYCByZXR1cm5lZCBOT19NQVRDSC5cbiAgICAgICh0aGlzIGNvdWxkIGJlIGJlY2F1c2UgYSBjYWxsYmFjayByZXF1ZXN0cyB0aGUgbWF0Y2ggYmUgaWdub3JlZCwgZXRjKVxuXG4gICAgICBUaGlzIGNhdXNlcyBubyByZWFsIGhhcm0gb3RoZXIgdGhhbiBzdG9wcGluZyBhIGZldyB0aW1lcyB0b28gbWFueS5cbiAgICAgICovXG5cbiAgICAgIG1vZGVCdWZmZXIgKz0gbGV4ZW1lO1xuICAgICAgcmV0dXJuIGxleGVtZS5sZW5ndGg7XG4gICAgfVxuXG4gICAgY29uc3QgbGFuZ3VhZ2UgPSBnZXRMYW5ndWFnZShsYW5ndWFnZU5hbWUpO1xuICAgIGlmICghbGFuZ3VhZ2UpIHtcbiAgICAgIGVycm9yKExBTkdVQUdFX05PVF9GT1VORC5yZXBsYWNlKFwie31cIiwgbGFuZ3VhZ2VOYW1lKSk7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gbGFuZ3VhZ2U6IFwiJyArIGxhbmd1YWdlTmFtZSArICdcIicpO1xuICAgIH1cblxuICAgIGNvbnN0IG1kID0gY29tcGlsZUxhbmd1YWdlKGxhbmd1YWdlKTtcbiAgICBsZXQgcmVzdWx0ID0gJyc7XG4gICAgLyoqIEB0eXBlIHtDb21waWxlZE1vZGV9ICovXG4gICAgbGV0IHRvcCA9IGNvbnRpbnVhdGlvbiB8fCBtZDtcbiAgICAvKiogQHR5cGUgUmVjb3JkPHN0cmluZyxDb21waWxlZE1vZGU+ICovXG4gICAgY29uc3QgY29udGludWF0aW9ucyA9IHt9OyAvLyBrZWVwIGNvbnRpbnVhdGlvbnMgZm9yIHN1Yi1sYW5ndWFnZXNcbiAgICBjb25zdCBlbWl0dGVyID0gbmV3IG9wdGlvbnMuX19lbWl0dGVyKG9wdGlvbnMpO1xuICAgIHByb2Nlc3NDb250aW51YXRpb25zKCk7XG4gICAgbGV0IG1vZGVCdWZmZXIgPSAnJztcbiAgICBsZXQgcmVsZXZhbmNlID0gMDtcbiAgICBsZXQgaW5kZXggPSAwO1xuICAgIGxldCBpdGVyYXRpb25zID0gMDtcbiAgICBsZXQgcmVzdW1lU2NhbkF0U2FtZVBvc2l0aW9uID0gZmFsc2U7XG5cbiAgICB0cnkge1xuICAgICAgdG9wLm1hdGNoZXIuY29uc2lkZXJBbGwoKTtcblxuICAgICAgZm9yICg7Oykge1xuICAgICAgICBpdGVyYXRpb25zKys7XG4gICAgICAgIGlmIChyZXN1bWVTY2FuQXRTYW1lUG9zaXRpb24pIHtcbiAgICAgICAgICAvLyBvbmx5IHJlZ2V4ZXMgbm90IG1hdGNoZWQgcHJldmlvdXNseSB3aWxsIG5vdyBiZVxuICAgICAgICAgIC8vIGNvbnNpZGVyZWQgZm9yIGEgcG90ZW50aWFsIG1hdGNoXG4gICAgICAgICAgcmVzdW1lU2NhbkF0U2FtZVBvc2l0aW9uID0gZmFsc2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdG9wLm1hdGNoZXIuY29uc2lkZXJBbGwoKTtcbiAgICAgICAgfVxuICAgICAgICB0b3AubWF0Y2hlci5sYXN0SW5kZXggPSBpbmRleDtcblxuICAgICAgICBjb25zdCBtYXRjaCA9IHRvcC5tYXRjaGVyLmV4ZWMoY29kZVRvSGlnaGxpZ2h0KTtcbiAgICAgICAgLy8gY29uc29sZS5sb2coXCJtYXRjaFwiLCBtYXRjaFswXSwgbWF0Y2gucnVsZSAmJiBtYXRjaC5ydWxlLmJlZ2luKVxuXG4gICAgICAgIGlmICghbWF0Y2gpIGJyZWFrO1xuXG4gICAgICAgIGNvbnN0IGJlZm9yZU1hdGNoID0gY29kZVRvSGlnaGxpZ2h0LnN1YnN0cmluZyhpbmRleCwgbWF0Y2guaW5kZXgpO1xuICAgICAgICBjb25zdCBwcm9jZXNzZWRDb3VudCA9IHByb2Nlc3NMZXhlbWUoYmVmb3JlTWF0Y2gsIG1hdGNoKTtcbiAgICAgICAgaW5kZXggPSBtYXRjaC5pbmRleCArIHByb2Nlc3NlZENvdW50O1xuICAgICAgfVxuICAgICAgcHJvY2Vzc0xleGVtZShjb2RlVG9IaWdobGlnaHQuc3Vic3RyKGluZGV4KSk7XG4gICAgICBlbWl0dGVyLmNsb3NlQWxsTm9kZXMoKTtcbiAgICAgIGVtaXR0ZXIuZmluYWxpemUoKTtcbiAgICAgIHJlc3VsdCA9IGVtaXR0ZXIudG9IVE1MKCk7XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGxhbmd1YWdlOiBsYW5ndWFnZU5hbWUsXG4gICAgICAgIHZhbHVlOiByZXN1bHQsXG4gICAgICAgIHJlbGV2YW5jZTogcmVsZXZhbmNlLFxuICAgICAgICBpbGxlZ2FsOiBmYWxzZSxcbiAgICAgICAgX2VtaXR0ZXI6IGVtaXR0ZXIsXG4gICAgICAgIF90b3A6IHRvcFxuICAgICAgfTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGlmIChlcnIubWVzc2FnZSAmJiBlcnIubWVzc2FnZS5pbmNsdWRlcygnSWxsZWdhbCcpKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbGFuZ3VhZ2U6IGxhbmd1YWdlTmFtZSxcbiAgICAgICAgICB2YWx1ZTogZXNjYXBlKGNvZGVUb0hpZ2hsaWdodCksXG4gICAgICAgICAgaWxsZWdhbDogdHJ1ZSxcbiAgICAgICAgICByZWxldmFuY2U6IDAsXG4gICAgICAgICAgX2lsbGVnYWxCeToge1xuICAgICAgICAgICAgbWVzc2FnZTogZXJyLm1lc3NhZ2UsXG4gICAgICAgICAgICBpbmRleDogaW5kZXgsXG4gICAgICAgICAgICBjb250ZXh0OiBjb2RlVG9IaWdobGlnaHQuc2xpY2UoaW5kZXggLSAxMDAsIGluZGV4ICsgMTAwKSxcbiAgICAgICAgICAgIG1vZGU6IGVyci5tb2RlLFxuICAgICAgICAgICAgcmVzdWx0U29GYXI6IHJlc3VsdFxuICAgICAgICAgIH0sXG4gICAgICAgICAgX2VtaXR0ZXI6IGVtaXR0ZXJcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSBpZiAoU0FGRV9NT0RFKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbGFuZ3VhZ2U6IGxhbmd1YWdlTmFtZSxcbiAgICAgICAgICB2YWx1ZTogZXNjYXBlKGNvZGVUb0hpZ2hsaWdodCksXG4gICAgICAgICAgaWxsZWdhbDogZmFsc2UsXG4gICAgICAgICAgcmVsZXZhbmNlOiAwLFxuICAgICAgICAgIGVycm9yUmFpc2VkOiBlcnIsXG4gICAgICAgICAgX2VtaXR0ZXI6IGVtaXR0ZXIsXG4gICAgICAgICAgX3RvcDogdG9wXG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBlcnI7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIHJldHVybnMgYSB2YWxpZCBoaWdobGlnaHQgcmVzdWx0LCB3aXRob3V0IGFjdHVhbGx5IGRvaW5nIGFueSBhY3R1YWwgd29yayxcbiAgICogYXV0byBoaWdobGlnaHQgc3RhcnRzIHdpdGggdGhpcyBhbmQgaXQncyBwb3NzaWJsZSBmb3Igc21hbGwgc25pcHBldHMgdGhhdFxuICAgKiBhdXRvLWRldGVjdGlvbiBtYXkgbm90IGZpbmQgYSBiZXR0ZXIgbWF0Y2hcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNvZGVcbiAgICogQHJldHVybnMge0hpZ2hsaWdodFJlc3VsdH1cbiAgICovXG4gIGZ1bmN0aW9uIGp1c3RUZXh0SGlnaGxpZ2h0UmVzdWx0KGNvZGUpIHtcbiAgICBjb25zdCByZXN1bHQgPSB7XG4gICAgICB2YWx1ZTogZXNjYXBlKGNvZGUpLFxuICAgICAgaWxsZWdhbDogZmFsc2UsXG4gICAgICByZWxldmFuY2U6IDAsXG4gICAgICBfdG9wOiBQTEFJTlRFWFRfTEFOR1VBR0UsXG4gICAgICBfZW1pdHRlcjogbmV3IG9wdGlvbnMuX19lbWl0dGVyKG9wdGlvbnMpXG4gICAgfTtcbiAgICByZXN1bHQuX2VtaXR0ZXIuYWRkVGV4dChjb2RlKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gIEhpZ2hsaWdodGluZyB3aXRoIGxhbmd1YWdlIGRldGVjdGlvbi4gQWNjZXB0cyBhIHN0cmluZyB3aXRoIHRoZSBjb2RlIHRvXG4gIGhpZ2hsaWdodC4gUmV0dXJucyBhbiBvYmplY3Qgd2l0aCB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG5cbiAgLSBsYW5ndWFnZSAoZGV0ZWN0ZWQgbGFuZ3VhZ2UpXG4gIC0gcmVsZXZhbmNlIChpbnQpXG4gIC0gdmFsdWUgKGFuIEhUTUwgc3RyaW5nIHdpdGggaGlnaGxpZ2h0aW5nIG1hcmt1cClcbiAgLSBzZWNvbmRCZXN0IChvYmplY3Qgd2l0aCB0aGUgc2FtZSBzdHJ1Y3R1cmUgZm9yIHNlY29uZC1iZXN0IGhldXJpc3RpY2FsbHlcbiAgICBkZXRlY3RlZCBsYW5ndWFnZSwgbWF5IGJlIGFic2VudClcblxuICAgIEBwYXJhbSB7c3RyaW5nfSBjb2RlXG4gICAgQHBhcmFtIHtBcnJheTxzdHJpbmc+fSBbbGFuZ3VhZ2VTdWJzZXRdXG4gICAgQHJldHVybnMge0F1dG9IaWdobGlnaHRSZXN1bHR9XG4gICovXG4gIGZ1bmN0aW9uIGhpZ2hsaWdodEF1dG8oY29kZSwgbGFuZ3VhZ2VTdWJzZXQpIHtcbiAgICBsYW5ndWFnZVN1YnNldCA9IGxhbmd1YWdlU3Vic2V0IHx8IG9wdGlvbnMubGFuZ3VhZ2VzIHx8IE9iamVjdC5rZXlzKGxhbmd1YWdlcyk7XG4gICAgY29uc3QgcGxhaW50ZXh0ID0ganVzdFRleHRIaWdobGlnaHRSZXN1bHQoY29kZSk7XG5cbiAgICBjb25zdCByZXN1bHRzID0gbGFuZ3VhZ2VTdWJzZXQuZmlsdGVyKGdldExhbmd1YWdlKS5maWx0ZXIoYXV0b0RldGVjdGlvbikubWFwKG5hbWUgPT5cbiAgICAgIF9oaWdobGlnaHQobmFtZSwgY29kZSwgZmFsc2UpXG4gICAgKTtcbiAgICByZXN1bHRzLnVuc2hpZnQocGxhaW50ZXh0KTsgLy8gcGxhaW50ZXh0IGlzIGFsd2F5cyBhbiBvcHRpb25cblxuICAgIGNvbnN0IHNvcnRlZCA9IHJlc3VsdHMuc29ydCgoYSwgYikgPT4ge1xuICAgICAgLy8gc29ydCBiYXNlIG9uIHJlbGV2YW5jZVxuICAgICAgaWYgKGEucmVsZXZhbmNlICE9PSBiLnJlbGV2YW5jZSkgcmV0dXJuIGIucmVsZXZhbmNlIC0gYS5yZWxldmFuY2U7XG5cbiAgICAgIC8vIGFsd2F5cyBhd2FyZCB0aGUgdGllIHRvIHRoZSBiYXNlIGxhbmd1YWdlXG4gICAgICAvLyBpZSBpZiBDKysgYW5kIEFyZHVpbm8gYXJlIHRpZWQsIGl0J3MgbW9yZSBsaWtlbHkgdG8gYmUgQysrXG4gICAgICBpZiAoYS5sYW5ndWFnZSAmJiBiLmxhbmd1YWdlKSB7XG4gICAgICAgIGlmIChnZXRMYW5ndWFnZShhLmxhbmd1YWdlKS5zdXBlcnNldE9mID09PSBiLmxhbmd1YWdlKSB7XG4gICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH0gZWxzZSBpZiAoZ2V0TGFuZ3VhZ2UoYi5sYW5ndWFnZSkuc3VwZXJzZXRPZiA9PT0gYS5sYW5ndWFnZSkge1xuICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBvdGhlcndpc2Ugc2F5IHRoZXkgYXJlIGVxdWFsLCB3aGljaCBoYXMgdGhlIGVmZmVjdCBvZiBzb3J0aW5nIG9uXG4gICAgICAvLyByZWxldmFuY2Ugd2hpbGUgcHJlc2VydmluZyB0aGUgb3JpZ2luYWwgb3JkZXJpbmcgLSB3aGljaCBpcyBob3cgdGllc1xuICAgICAgLy8gaGF2ZSBoaXN0b3JpY2FsbHkgYmVlbiBzZXR0bGVkLCBpZSB0aGUgbGFuZ3VhZ2UgdGhhdCBjb21lcyBmaXJzdCBhbHdheXNcbiAgICAgIC8vIHdpbnMgaW4gdGhlIGNhc2Ugb2YgYSB0aWVcbiAgICAgIHJldHVybiAwO1xuICAgIH0pO1xuXG4gICAgY29uc3QgW2Jlc3QsIHNlY29uZEJlc3RdID0gc29ydGVkO1xuXG4gICAgLyoqIEB0eXBlIHtBdXRvSGlnaGxpZ2h0UmVzdWx0fSAqL1xuICAgIGNvbnN0IHJlc3VsdCA9IGJlc3Q7XG4gICAgcmVzdWx0LnNlY29uZEJlc3QgPSBzZWNvbmRCZXN0O1xuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBCdWlsZHMgbmV3IGNsYXNzIG5hbWUgZm9yIGJsb2NrIGdpdmVuIHRoZSBsYW5ndWFnZSBuYW1lXG4gICAqXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnRcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtjdXJyZW50TGFuZ11cbiAgICogQHBhcmFtIHtzdHJpbmd9IFtyZXN1bHRMYW5nXVxuICAgKi9cbiAgZnVuY3Rpb24gdXBkYXRlQ2xhc3NOYW1lKGVsZW1lbnQsIGN1cnJlbnRMYW5nLCByZXN1bHRMYW5nKSB7XG4gICAgY29uc3QgbGFuZ3VhZ2UgPSAoY3VycmVudExhbmcgJiYgYWxpYXNlc1tjdXJyZW50TGFuZ10pIHx8IHJlc3VsdExhbmc7XG5cbiAgICBlbGVtZW50LmNsYXNzTGlzdC5hZGQoXCJobGpzXCIpO1xuICAgIGVsZW1lbnQuY2xhc3NMaXN0LmFkZChgbGFuZ3VhZ2UtJHtsYW5ndWFnZX1gKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBcHBsaWVzIGhpZ2hsaWdodGluZyB0byBhIERPTSBub2RlIGNvbnRhaW5pbmcgY29kZS5cbiAgICpcbiAgICogQHBhcmFtIHtIaWdobGlnaHRlZEhUTUxFbGVtZW50fSBlbGVtZW50IC0gdGhlIEhUTUwgZWxlbWVudCB0byBoaWdobGlnaHRcbiAgKi9cbiAgZnVuY3Rpb24gaGlnaGxpZ2h0RWxlbWVudChlbGVtZW50KSB7XG4gICAgLyoqIEB0eXBlIEhUTUxFbGVtZW50ICovXG4gICAgbGV0IG5vZGUgPSBudWxsO1xuICAgIGNvbnN0IGxhbmd1YWdlID0gYmxvY2tMYW5ndWFnZShlbGVtZW50KTtcblxuICAgIGlmIChzaG91bGROb3RIaWdobGlnaHQobGFuZ3VhZ2UpKSByZXR1cm47XG5cbiAgICBmaXJlKFwiYmVmb3JlOmhpZ2hsaWdodEVsZW1lbnRcIixcbiAgICAgIHsgZWw6IGVsZW1lbnQsIGxhbmd1YWdlOiBsYW5ndWFnZSB9KTtcblxuICAgIC8vIHdlIHNob3VsZCBiZSBhbGwgdGV4dCwgbm8gY2hpbGQgbm9kZXNcbiAgICBpZiAoIW9wdGlvbnMuaWdub3JlVW5lc2NhcGVkSFRNTCAmJiBlbGVtZW50LmNoaWxkcmVuLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnNvbGUud2FybihcIk9uZSBvZiB5b3VyIGNvZGUgYmxvY2tzIGluY2x1ZGVzIHVuZXNjYXBlZCBIVE1MLiBUaGlzIGlzIGEgcG90ZW50aWFsbHkgc2VyaW91cyBzZWN1cml0eSByaXNrLlwiKTtcbiAgICAgIGNvbnNvbGUud2FybihcImh0dHBzOi8vZ2l0aHViLmNvbS9oaWdobGlnaHRqcy9oaWdobGlnaHQuanMvaXNzdWVzLzI4ODZcIik7XG4gICAgICBjb25zb2xlLndhcm4oZWxlbWVudCk7XG4gICAgfVxuXG4gICAgbm9kZSA9IGVsZW1lbnQ7XG4gICAgY29uc3QgdGV4dCA9IG5vZGUudGV4dENvbnRlbnQ7XG4gICAgY29uc3QgcmVzdWx0ID0gbGFuZ3VhZ2UgPyBoaWdobGlnaHQodGV4dCwgeyBsYW5ndWFnZSwgaWdub3JlSWxsZWdhbHM6IHRydWUgfSkgOiBoaWdobGlnaHRBdXRvKHRleHQpO1xuXG4gICAgZWxlbWVudC5pbm5lckhUTUwgPSByZXN1bHQudmFsdWU7XG4gICAgdXBkYXRlQ2xhc3NOYW1lKGVsZW1lbnQsIGxhbmd1YWdlLCByZXN1bHQubGFuZ3VhZ2UpO1xuICAgIGVsZW1lbnQucmVzdWx0ID0ge1xuICAgICAgbGFuZ3VhZ2U6IHJlc3VsdC5sYW5ndWFnZSxcbiAgICAgIC8vIFRPRE86IHJlbW92ZSB3aXRoIHZlcnNpb24gMTEuMFxuICAgICAgcmU6IHJlc3VsdC5yZWxldmFuY2UsXG4gICAgICByZWxldmFuY2U6IHJlc3VsdC5yZWxldmFuY2VcbiAgICB9O1xuICAgIGlmIChyZXN1bHQuc2Vjb25kQmVzdCkge1xuICAgICAgZWxlbWVudC5zZWNvbmRCZXN0ID0ge1xuICAgICAgICBsYW5ndWFnZTogcmVzdWx0LnNlY29uZEJlc3QubGFuZ3VhZ2UsXG4gICAgICAgIHJlbGV2YW5jZTogcmVzdWx0LnNlY29uZEJlc3QucmVsZXZhbmNlXG4gICAgICB9O1xuICAgIH1cblxuICAgIGZpcmUoXCJhZnRlcjpoaWdobGlnaHRFbGVtZW50XCIsIHsgZWw6IGVsZW1lbnQsIHJlc3VsdCwgdGV4dCB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGVzIGhpZ2hsaWdodC5qcyBnbG9iYWwgb3B0aW9ucyB3aXRoIHRoZSBwYXNzZWQgb3B0aW9uc1xuICAgKlxuICAgKiBAcGFyYW0ge1BhcnRpYWw8SExKU09wdGlvbnM+fSB1c2VyT3B0aW9uc1xuICAgKi9cbiAgZnVuY3Rpb24gY29uZmlndXJlKHVzZXJPcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IGluaGVyaXQob3B0aW9ucywgdXNlck9wdGlvbnMpO1xuICB9XG5cbiAgLy8gVE9ETzogcmVtb3ZlIHYxMiwgZGVwcmVjYXRlZFxuICBjb25zdCBpbml0SGlnaGxpZ2h0aW5nID0gKCkgPT4ge1xuICAgIGhpZ2hsaWdodEFsbCgpO1xuICAgIGRlcHJlY2F0ZWQoXCIxMC42LjBcIiwgXCJpbml0SGlnaGxpZ2h0aW5nKCkgZGVwcmVjYXRlZC4gIFVzZSBoaWdobGlnaHRBbGwoKSBub3cuXCIpO1xuICB9O1xuXG4gIC8vIFRPRE86IHJlbW92ZSB2MTIsIGRlcHJlY2F0ZWRcbiAgZnVuY3Rpb24gaW5pdEhpZ2hsaWdodGluZ09uTG9hZCgpIHtcbiAgICBoaWdobGlnaHRBbGwoKTtcbiAgICBkZXByZWNhdGVkKFwiMTAuNi4wXCIsIFwiaW5pdEhpZ2hsaWdodGluZ09uTG9hZCgpIGRlcHJlY2F0ZWQuICBVc2UgaGlnaGxpZ2h0QWxsKCkgbm93LlwiKTtcbiAgfVxuXG4gIGxldCB3YW50c0hpZ2hsaWdodCA9IGZhbHNlO1xuXG4gIC8qKlxuICAgKiBhdXRvLWhpZ2hsaWdodHMgYWxsIHByZT5jb2RlIGVsZW1lbnRzIG9uIHRoZSBwYWdlXG4gICAqL1xuICBmdW5jdGlvbiBoaWdobGlnaHRBbGwoKSB7XG4gICAgLy8gaWYgd2UgYXJlIGNhbGxlZCB0b28gZWFybHkgaW4gdGhlIGxvYWRpbmcgcHJvY2Vzc1xuICAgIGlmIChkb2N1bWVudC5yZWFkeVN0YXRlID09PSBcImxvYWRpbmdcIikge1xuICAgICAgd2FudHNIaWdobGlnaHQgPSB0cnVlO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGJsb2NrcyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwob3B0aW9ucy5jc3NTZWxlY3Rvcik7XG4gICAgYmxvY2tzLmZvckVhY2goaGlnaGxpZ2h0RWxlbWVudCk7XG4gIH1cblxuICBmdW5jdGlvbiBib290KCkge1xuICAgIC8vIGlmIGEgaGlnaGxpZ2h0IHdhcyByZXF1ZXN0ZWQgYmVmb3JlIERPTSB3YXMgbG9hZGVkLCBkbyBub3dcbiAgICBpZiAod2FudHNIaWdobGlnaHQpIGhpZ2hsaWdodEFsbCgpO1xuICB9XG5cbiAgLy8gbWFrZSBzdXJlIHdlIGFyZSBpbiB0aGUgYnJvd3NlciBlbnZpcm9ubWVudFxuICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignRE9NQ29udGVudExvYWRlZCcsIGJvb3QsIGZhbHNlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWdpc3RlciBhIGxhbmd1YWdlIGdyYW1tYXIgbW9kdWxlXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBsYW5ndWFnZU5hbWVcbiAgICogQHBhcmFtIHtMYW5ndWFnZUZufSBsYW5ndWFnZURlZmluaXRpb25cbiAgICovXG4gIGZ1bmN0aW9uIHJlZ2lzdGVyTGFuZ3VhZ2UobGFuZ3VhZ2VOYW1lLCBsYW5ndWFnZURlZmluaXRpb24pIHtcbiAgICBsZXQgbGFuZyA9IG51bGw7XG4gICAgdHJ5IHtcbiAgICAgIGxhbmcgPSBsYW5ndWFnZURlZmluaXRpb24oaGxqcyk7XG4gICAgfSBjYXRjaCAoZXJyb3IkMSkge1xuICAgICAgZXJyb3IoXCJMYW5ndWFnZSBkZWZpbml0aW9uIGZvciAne30nIGNvdWxkIG5vdCBiZSByZWdpc3RlcmVkLlwiLnJlcGxhY2UoXCJ7fVwiLCBsYW5ndWFnZU5hbWUpKTtcbiAgICAgIC8vIGhhcmQgb3Igc29mdCBlcnJvclxuICAgICAgaWYgKCFTQUZFX01PREUpIHsgdGhyb3cgZXJyb3IkMTsgfSBlbHNlIHsgZXJyb3IoZXJyb3IkMSk7IH1cbiAgICAgIC8vIGxhbmd1YWdlcyB0aGF0IGhhdmUgc2VyaW91cyBlcnJvcnMgYXJlIHJlcGxhY2VkIHdpdGggZXNzZW50aWFsbHkgYVxuICAgICAgLy8gXCJwbGFpbnRleHRcIiBzdGFuZC1pbiBzbyB0aGF0IHRoZSBjb2RlIGJsb2NrcyB3aWxsIHN0aWxsIGdldCBub3JtYWxcbiAgICAgIC8vIGNzcyBjbGFzc2VzIGFwcGxpZWQgdG8gdGhlbSAtIGFuZCBvbmUgYmFkIGxhbmd1YWdlIHdvbid0IGJyZWFrIHRoZVxuICAgICAgLy8gZW50aXJlIGhpZ2hsaWdodGVyXG4gICAgICBsYW5nID0gUExBSU5URVhUX0xBTkdVQUdFO1xuICAgIH1cbiAgICAvLyBnaXZlIGl0IGEgdGVtcG9yYXJ5IG5hbWUgaWYgaXQgZG9lc24ndCBoYXZlIG9uZSBpbiB0aGUgbWV0YS1kYXRhXG4gICAgaWYgKCFsYW5nLm5hbWUpIGxhbmcubmFtZSA9IGxhbmd1YWdlTmFtZTtcbiAgICBsYW5ndWFnZXNbbGFuZ3VhZ2VOYW1lXSA9IGxhbmc7XG4gICAgbGFuZy5yYXdEZWZpbml0aW9uID0gbGFuZ3VhZ2VEZWZpbml0aW9uLmJpbmQobnVsbCwgaGxqcyk7XG5cbiAgICBpZiAobGFuZy5hbGlhc2VzKSB7XG4gICAgICByZWdpc3RlckFsaWFzZXMobGFuZy5hbGlhc2VzLCB7IGxhbmd1YWdlTmFtZSB9KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlIGEgbGFuZ3VhZ2UgZ3JhbW1hciBtb2R1bGVcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGxhbmd1YWdlTmFtZVxuICAgKi9cbiAgZnVuY3Rpb24gdW5yZWdpc3Rlckxhbmd1YWdlKGxhbmd1YWdlTmFtZSkge1xuICAgIGRlbGV0ZSBsYW5ndWFnZXNbbGFuZ3VhZ2VOYW1lXTtcbiAgICBmb3IgKGNvbnN0IGFsaWFzIG9mIE9iamVjdC5rZXlzKGFsaWFzZXMpKSB7XG4gICAgICBpZiAoYWxpYXNlc1thbGlhc10gPT09IGxhbmd1YWdlTmFtZSkge1xuICAgICAgICBkZWxldGUgYWxpYXNlc1thbGlhc107XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm5zIHtzdHJpbmdbXX0gTGlzdCBvZiBsYW5ndWFnZSBpbnRlcm5hbCBuYW1lc1xuICAgKi9cbiAgZnVuY3Rpb24gbGlzdExhbmd1YWdlcygpIHtcbiAgICByZXR1cm4gT2JqZWN0LmtleXMobGFuZ3VhZ2VzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSAtIG5hbWUgb2YgdGhlIGxhbmd1YWdlIHRvIHJldHJpZXZlXG4gICAqIEByZXR1cm5zIHtMYW5ndWFnZSB8IHVuZGVmaW5lZH1cbiAgICovXG4gIGZ1bmN0aW9uIGdldExhbmd1YWdlKG5hbWUpIHtcbiAgICBuYW1lID0gKG5hbWUgfHwgJycpLnRvTG93ZXJDYXNlKCk7XG4gICAgcmV0dXJuIGxhbmd1YWdlc1tuYW1lXSB8fCBsYW5ndWFnZXNbYWxpYXNlc1tuYW1lXV07XG4gIH1cblxuICAvKipcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd8c3RyaW5nW119IGFsaWFzTGlzdCAtIHNpbmdsZSBhbGlhcyBvciBsaXN0IG9mIGFsaWFzZXNcbiAgICogQHBhcmFtIHt7bGFuZ3VhZ2VOYW1lOiBzdHJpbmd9fSBvcHRzXG4gICAqL1xuICBmdW5jdGlvbiByZWdpc3RlckFsaWFzZXMoYWxpYXNMaXN0LCB7IGxhbmd1YWdlTmFtZSB9KSB7XG4gICAgaWYgKHR5cGVvZiBhbGlhc0xpc3QgPT09ICdzdHJpbmcnKSB7XG4gICAgICBhbGlhc0xpc3QgPSBbYWxpYXNMaXN0XTtcbiAgICB9XG4gICAgYWxpYXNMaXN0LmZvckVhY2goYWxpYXMgPT4geyBhbGlhc2VzW2FsaWFzLnRvTG93ZXJDYXNlKCldID0gbGFuZ3VhZ2VOYW1lOyB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXRlcm1pbmVzIGlmIGEgZ2l2ZW4gbGFuZ3VhZ2UgaGFzIGF1dG8tZGV0ZWN0aW9uIGVuYWJsZWRcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgLSBuYW1lIG9mIHRoZSBsYW5ndWFnZVxuICAgKi9cbiAgZnVuY3Rpb24gYXV0b0RldGVjdGlvbihuYW1lKSB7XG4gICAgY29uc3QgbGFuZyA9IGdldExhbmd1YWdlKG5hbWUpO1xuICAgIHJldHVybiBsYW5nICYmICFsYW5nLmRpc2FibGVBdXRvZGV0ZWN0O1xuICB9XG5cbiAgLyoqXG4gICAqIFVwZ3JhZGVzIHRoZSBvbGQgaGlnaGxpZ2h0QmxvY2sgcGx1Z2lucyB0byB0aGUgbmV3XG4gICAqIGhpZ2hsaWdodEVsZW1lbnQgQVBJXG4gICAqIEBwYXJhbSB7SExKU1BsdWdpbn0gcGx1Z2luXG4gICAqL1xuICBmdW5jdGlvbiB1cGdyYWRlUGx1Z2luQVBJKHBsdWdpbikge1xuICAgIC8vIFRPRE86IHJlbW92ZSB3aXRoIHYxMlxuICAgIGlmIChwbHVnaW5bXCJiZWZvcmU6aGlnaGxpZ2h0QmxvY2tcIl0gJiYgIXBsdWdpbltcImJlZm9yZTpoaWdobGlnaHRFbGVtZW50XCJdKSB7XG4gICAgICBwbHVnaW5bXCJiZWZvcmU6aGlnaGxpZ2h0RWxlbWVudFwiXSA9IChkYXRhKSA9PiB7XG4gICAgICAgIHBsdWdpbltcImJlZm9yZTpoaWdobGlnaHRCbG9ja1wiXShcbiAgICAgICAgICBPYmplY3QuYXNzaWduKHsgYmxvY2s6IGRhdGEuZWwgfSwgZGF0YSlcbiAgICAgICAgKTtcbiAgICAgIH07XG4gICAgfVxuICAgIGlmIChwbHVnaW5bXCJhZnRlcjpoaWdobGlnaHRCbG9ja1wiXSAmJiAhcGx1Z2luW1wiYWZ0ZXI6aGlnaGxpZ2h0RWxlbWVudFwiXSkge1xuICAgICAgcGx1Z2luW1wiYWZ0ZXI6aGlnaGxpZ2h0RWxlbWVudFwiXSA9IChkYXRhKSA9PiB7XG4gICAgICAgIHBsdWdpbltcImFmdGVyOmhpZ2hsaWdodEJsb2NrXCJdKFxuICAgICAgICAgIE9iamVjdC5hc3NpZ24oeyBibG9jazogZGF0YS5lbCB9LCBkYXRhKVxuICAgICAgICApO1xuICAgICAgfTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtITEpTUGx1Z2lufSBwbHVnaW5cbiAgICovXG4gIGZ1bmN0aW9uIGFkZFBsdWdpbihwbHVnaW4pIHtcbiAgICB1cGdyYWRlUGx1Z2luQVBJKHBsdWdpbik7XG4gICAgcGx1Z2lucy5wdXNoKHBsdWdpbik7XG4gIH1cblxuICAvKipcbiAgICpcbiAgICogQHBhcmFtIHtQbHVnaW5FdmVudH0gZXZlbnRcbiAgICogQHBhcmFtIHthbnl9IGFyZ3NcbiAgICovXG4gIGZ1bmN0aW9uIGZpcmUoZXZlbnQsIGFyZ3MpIHtcbiAgICBjb25zdCBjYiA9IGV2ZW50O1xuICAgIHBsdWdpbnMuZm9yRWFjaChmdW5jdGlvbihwbHVnaW4pIHtcbiAgICAgIGlmIChwbHVnaW5bY2JdKSB7XG4gICAgICAgIHBsdWdpbltjYl0oYXJncyk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogREVQUkVDQVRFRFxuICAgKiBAcGFyYW0ge0hpZ2hsaWdodGVkSFRNTEVsZW1lbnR9IGVsXG4gICAqL1xuICBmdW5jdGlvbiBkZXByZWNhdGVIaWdobGlnaHRCbG9jayhlbCkge1xuICAgIGRlcHJlY2F0ZWQoXCIxMC43LjBcIiwgXCJoaWdobGlnaHRCbG9jayB3aWxsIGJlIHJlbW92ZWQgZW50aXJlbHkgaW4gdjEyLjBcIik7XG4gICAgZGVwcmVjYXRlZChcIjEwLjcuMFwiLCBcIlBsZWFzZSB1c2UgaGlnaGxpZ2h0RWxlbWVudCBub3cuXCIpO1xuXG4gICAgcmV0dXJuIGhpZ2hsaWdodEVsZW1lbnQoZWwpO1xuICB9XG5cbiAgLyogSW50ZXJmYWNlIGRlZmluaXRpb24gKi9cbiAgT2JqZWN0LmFzc2lnbihobGpzLCB7XG4gICAgaGlnaGxpZ2h0LFxuICAgIGhpZ2hsaWdodEF1dG8sXG4gICAgaGlnaGxpZ2h0QWxsLFxuICAgIGhpZ2hsaWdodEVsZW1lbnQsXG4gICAgLy8gVE9ETzogUmVtb3ZlIHdpdGggdjEyIEFQSVxuICAgIGhpZ2hsaWdodEJsb2NrOiBkZXByZWNhdGVIaWdobGlnaHRCbG9jayxcbiAgICBjb25maWd1cmUsXG4gICAgaW5pdEhpZ2hsaWdodGluZyxcbiAgICBpbml0SGlnaGxpZ2h0aW5nT25Mb2FkLFxuICAgIHJlZ2lzdGVyTGFuZ3VhZ2UsXG4gICAgdW5yZWdpc3Rlckxhbmd1YWdlLFxuICAgIGxpc3RMYW5ndWFnZXMsXG4gICAgZ2V0TGFuZ3VhZ2UsXG4gICAgcmVnaXN0ZXJBbGlhc2VzLFxuICAgIGF1dG9EZXRlY3Rpb24sXG4gICAgaW5oZXJpdCxcbiAgICBhZGRQbHVnaW5cbiAgfSk7XG5cbiAgaGxqcy5kZWJ1Z01vZGUgPSBmdW5jdGlvbigpIHsgU0FGRV9NT0RFID0gZmFsc2U7IH07XG4gIGhsanMuc2FmZU1vZGUgPSBmdW5jdGlvbigpIHsgU0FGRV9NT0RFID0gdHJ1ZTsgfTtcbiAgaGxqcy52ZXJzaW9uU3RyaW5nID0gdmVyc2lvbjtcblxuICBmb3IgKGNvbnN0IGtleSBpbiBNT0RFUykge1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBpZiAodHlwZW9mIE1PREVTW2tleV0gPT09IFwib2JqZWN0XCIpIHtcbiAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgIGRlZXBGcmVlemUkMShNT0RFU1trZXldKTtcbiAgICB9XG4gIH1cblxuICAvLyBtZXJnZSBhbGwgdGhlIG1vZGVzL3JlZ2V4ZXMgaW50byBvdXIgbWFpbiBvYmplY3RcbiAgT2JqZWN0LmFzc2lnbihobGpzLCBNT0RFUyk7XG5cbiAgcmV0dXJuIGhsanM7XG59O1xuXG4vLyBleHBvcnQgYW4gXCJpbnN0YW5jZVwiIG9mIHRoZSBoaWdobGlnaHRlclxudmFyIGhpZ2hsaWdodCA9IEhMSlMoe30pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGhpZ2hsaWdodDtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///390\n")}},__webpack_module_cache__={};function __webpack_require__(e){var n=__webpack_module_cache__[e];if(void 0!==n)return n.exports;var t=__webpack_module_cache__[e]={exports:{}};return __webpack_modules__[e].call(t.exports,t,t.exports,__webpack_require__),t.exports}__webpack_require__.n=e=>{var n=e&&e.__esModule?()=>e.default:()=>e;return __webpack_require__.d(n,{a:n}),n},__webpack_require__.d=(e,n)=>{for(var t in n)__webpack_require__.o(n,t)&&!__webpack_require__.o(e,t)&&Object.defineProperty(e,t,{enumerable:!0,get:n[t]})},__webpack_require__.g=function(){if("object"==typeof globalThis)return globalThis;try{return this||new Function("return this")()}catch(e){if("object"==typeof window)return window}}(),__webpack_require__.o=(e,n)=>Object.prototype.hasOwnProperty.call(e,n);var __webpack_exports__=__webpack_require__(934)})();