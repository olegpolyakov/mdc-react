(()=>{var __webpack_modules__={937:(__unused_webpack_module,__unused_webpack___webpack_exports__,__webpack_require__)=>{"use strict";eval('\n;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}\n;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/inheritsLoose.js\n\nfunction _inheritsLoose(subClass, superClass) {\n  subClass.prototype = Object.create(superClass.prototype);\n  subClass.prototype.constructor = subClass;\n  _setPrototypeOf(subClass, superClass);\n}\n// EXTERNAL MODULE: ./node_modules/react/index.js\nvar react = __webpack_require__(294);\n// EXTERNAL MODULE: ./node_modules/prop-types/index.js\nvar prop_types = __webpack_require__(697);\nvar prop_types_default = /*#__PURE__*/__webpack_require__.n(prop_types);\n;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/extends.js\nfunction extends_extends() {\n  extends_extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return extends_extends.apply(this, arguments);\n}\n;// CONCATENATED MODULE: ./node_modules/resolve-pathname/esm/resolve-pathname.js\nfunction isAbsolute(pathname) {\n  return pathname.charAt(0) === \'/\';\n}\n\n// About 1.5x faster than the two-arg version of Array#splice()\nfunction spliceOne(list, index) {\n  for (var i = index, k = i + 1, n = list.length; k < n; i += 1, k += 1) {\n    list[i] = list[k];\n  }\n\n  list.pop();\n}\n\n// This implementation is based heavily on node\'s url.parse\nfunction resolvePathname(to, from) {\n  if (from === undefined) from = \'\';\n\n  var toParts = (to && to.split(\'/\')) || [];\n  var fromParts = (from && from.split(\'/\')) || [];\n\n  var isToAbs = to && isAbsolute(to);\n  var isFromAbs = from && isAbsolute(from);\n  var mustEndAbs = isToAbs || isFromAbs;\n\n  if (to && isAbsolute(to)) {\n    // to is absolute\n    fromParts = toParts;\n  } else if (toParts.length) {\n    // to is relative, drop the filename\n    fromParts.pop();\n    fromParts = fromParts.concat(toParts);\n  }\n\n  if (!fromParts.length) return \'/\';\n\n  var hasTrailingSlash;\n  if (fromParts.length) {\n    var last = fromParts[fromParts.length - 1];\n    hasTrailingSlash = last === \'.\' || last === \'..\' || last === \'\';\n  } else {\n    hasTrailingSlash = false;\n  }\n\n  var up = 0;\n  for (var i = fromParts.length; i >= 0; i--) {\n    var part = fromParts[i];\n\n    if (part === \'.\') {\n      spliceOne(fromParts, i);\n    } else if (part === \'..\') {\n      spliceOne(fromParts, i);\n      up++;\n    } else if (up) {\n      spliceOne(fromParts, i);\n      up--;\n    }\n  }\n\n  if (!mustEndAbs) for (; up--; up) fromParts.unshift(\'..\');\n\n  if (\n    mustEndAbs &&\n    fromParts[0] !== \'\' &&\n    (!fromParts[0] || !isAbsolute(fromParts[0]))\n  )\n    fromParts.unshift(\'\');\n\n  var result = fromParts.join(\'/\');\n\n  if (hasTrailingSlash && result.substr(-1) !== \'/\') result += \'/\';\n\n  return result;\n}\n\n/* harmony default export */ const resolve_pathname = (resolvePathname);\n\n;// CONCATENATED MODULE: ./node_modules/tiny-invariant/dist/tiny-invariant.esm.js\nvar isProduction = "production" === \'production\';\nvar prefix = \'Invariant failed\';\nfunction tiny_invariant_esm_invariant(condition, message) {\n    if (condition) {\n        return;\n    }\n    if (isProduction) {\n        throw new Error(prefix);\n    }\n    throw new Error(prefix + ": " + (message || \'\'));\n}\n\n/* harmony default export */ const tiny_invariant_esm = (tiny_invariant_esm_invariant);\n\n;// CONCATENATED MODULE: ./node_modules/history/esm/history.js\n\n\n\n\n\n\nfunction addLeadingSlash(path) {\n  return path.charAt(0) === \'/\' ? path : \'/\' + path;\n}\nfunction stripLeadingSlash(path) {\n  return path.charAt(0) === \'/\' ? path.substr(1) : path;\n}\nfunction hasBasename(path, prefix) {\n  return path.toLowerCase().indexOf(prefix.toLowerCase()) === 0 && \'/?#\'.indexOf(path.charAt(prefix.length)) !== -1;\n}\nfunction stripBasename(path, prefix) {\n  return hasBasename(path, prefix) ? path.substr(prefix.length) : path;\n}\nfunction stripTrailingSlash(path) {\n  return path.charAt(path.length - 1) === \'/\' ? path.slice(0, -1) : path;\n}\nfunction parsePath(path) {\n  var pathname = path || \'/\';\n  var search = \'\';\n  var hash = \'\';\n  var hashIndex = pathname.indexOf(\'#\');\n\n  if (hashIndex !== -1) {\n    hash = pathname.substr(hashIndex);\n    pathname = pathname.substr(0, hashIndex);\n  }\n\n  var searchIndex = pathname.indexOf(\'?\');\n\n  if (searchIndex !== -1) {\n    search = pathname.substr(searchIndex);\n    pathname = pathname.substr(0, searchIndex);\n  }\n\n  return {\n    pathname: pathname,\n    search: search === \'?\' ? \'\' : search,\n    hash: hash === \'#\' ? \'\' : hash\n  };\n}\nfunction createPath(location) {\n  var pathname = location.pathname,\n      search = location.search,\n      hash = location.hash;\n  var path = pathname || \'/\';\n  if (search && search !== \'?\') path += search.charAt(0) === \'?\' ? search : "?" + search;\n  if (hash && hash !== \'#\') path += hash.charAt(0) === \'#\' ? hash : "#" + hash;\n  return path;\n}\n\nfunction history_createLocation(path, state, key, currentLocation) {\n  var location;\n\n  if (typeof path === \'string\') {\n    // Two-arg form: push(path, state)\n    location = parsePath(path);\n    location.state = state;\n  } else {\n    // One-arg form: push(location)\n    location = extends_extends({}, path);\n    if (location.pathname === undefined) location.pathname = \'\';\n\n    if (location.search) {\n      if (location.search.charAt(0) !== \'?\') location.search = \'?\' + location.search;\n    } else {\n      location.search = \'\';\n    }\n\n    if (location.hash) {\n      if (location.hash.charAt(0) !== \'#\') location.hash = \'#\' + location.hash;\n    } else {\n      location.hash = \'\';\n    }\n\n    if (state !== undefined && location.state === undefined) location.state = state;\n  }\n\n  try {\n    location.pathname = decodeURI(location.pathname);\n  } catch (e) {\n    if (e instanceof URIError) {\n      throw new URIError(\'Pathname "\' + location.pathname + \'" could not be decoded. \' + \'This is likely caused by an invalid percent-encoding.\');\n    } else {\n      throw e;\n    }\n  }\n\n  if (key) location.key = key;\n\n  if (currentLocation) {\n    // Resolve incomplete/relative pathname relative to current location.\n    if (!location.pathname) {\n      location.pathname = currentLocation.pathname;\n    } else if (location.pathname.charAt(0) !== \'/\') {\n      location.pathname = resolve_pathname(location.pathname, currentLocation.pathname);\n    }\n  } else {\n    // When there is no prior location and pathname is empty, set it to /\n    if (!location.pathname) {\n      location.pathname = \'/\';\n    }\n  }\n\n  return location;\n}\nfunction history_locationsAreEqual(a, b) {\n  return a.pathname === b.pathname && a.search === b.search && a.hash === b.hash && a.key === b.key && valueEqual(a.state, b.state);\n}\n\nfunction createTransitionManager() {\n  var prompt = null;\n\n  function setPrompt(nextPrompt) {\n     false ? 0 : void 0;\n    prompt = nextPrompt;\n    return function () {\n      if (prompt === nextPrompt) prompt = null;\n    };\n  }\n\n  function confirmTransitionTo(location, action, getUserConfirmation, callback) {\n    // TODO: If another transition starts while we\'re still confirming\n    // the previous one, we may end up in a weird state. Figure out the\n    // best way to handle this.\n    if (prompt != null) {\n      var result = typeof prompt === \'function\' ? prompt(location, action) : prompt;\n\n      if (typeof result === \'string\') {\n        if (typeof getUserConfirmation === \'function\') {\n          getUserConfirmation(result, callback);\n        } else {\n           false ? 0 : void 0;\n          callback(true);\n        }\n      } else {\n        // Return false from a transition hook to cancel the transition.\n        callback(result !== false);\n      }\n    } else {\n      callback(true);\n    }\n  }\n\n  var listeners = [];\n\n  function appendListener(fn) {\n    var isActive = true;\n\n    function listener() {\n      if (isActive) fn.apply(void 0, arguments);\n    }\n\n    listeners.push(listener);\n    return function () {\n      isActive = false;\n      listeners = listeners.filter(function (item) {\n        return item !== listener;\n      });\n    };\n  }\n\n  function notifyListeners() {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    listeners.forEach(function (listener) {\n      return listener.apply(void 0, args);\n    });\n  }\n\n  return {\n    setPrompt: setPrompt,\n    confirmTransitionTo: confirmTransitionTo,\n    appendListener: appendListener,\n    notifyListeners: notifyListeners\n  };\n}\n\nvar canUseDOM = !!(typeof window !== \'undefined\' && window.document && window.document.createElement);\nfunction getConfirmation(message, callback) {\n  callback(window.confirm(message)); // eslint-disable-line no-alert\n}\n/**\n * Returns true if the HTML5 history API is supported. Taken from Modernizr.\n *\n * https://github.com/Modernizr/Modernizr/blob/master/LICENSE\n * https://github.com/Modernizr/Modernizr/blob/master/feature-detects/history.js\n * changed to avoid false negatives for Windows Phones: https://github.com/reactjs/react-router/issues/586\n */\n\nfunction supportsHistory() {\n  var ua = window.navigator.userAgent;\n  if ((ua.indexOf(\'Android 2.\') !== -1 || ua.indexOf(\'Android 4.0\') !== -1) && ua.indexOf(\'Mobile Safari\') !== -1 && ua.indexOf(\'Chrome\') === -1 && ua.indexOf(\'Windows Phone\') === -1) return false;\n  return window.history && \'pushState\' in window.history;\n}\n/**\n * Returns true if browser fires popstate on hash change.\n * IE10 and IE11 do not.\n */\n\nfunction supportsPopStateOnHashChange() {\n  return window.navigator.userAgent.indexOf(\'Trident\') === -1;\n}\n/**\n * Returns false if using go(n) with hash history causes a full page reload.\n */\n\nfunction supportsGoWithoutReloadUsingHash() {\n  return window.navigator.userAgent.indexOf(\'Firefox\') === -1;\n}\n/**\n * Returns true if a given popstate event is an extraneous WebKit event.\n * Accounts for the fact that Chrome on iOS fires real popstate events\n * containing undefined state when pressing the back button.\n */\n\nfunction isExtraneousPopstateEvent(event) {\n  return event.state === undefined && navigator.userAgent.indexOf(\'CriOS\') === -1;\n}\n\nvar PopStateEvent = \'popstate\';\nvar HashChangeEvent = \'hashchange\';\n\nfunction getHistoryState() {\n  try {\n    return window.history.state || {};\n  } catch (e) {\n    // IE 11 sometimes throws when accessing window.history.state\n    // See https://github.com/ReactTraining/history/pull/289\n    return {};\n  }\n}\n/**\n * Creates a history object that uses the HTML5 history API including\n * pushState, replaceState, and the popstate event.\n */\n\n\nfunction createBrowserHistory(props) {\n  if (props === void 0) {\n    props = {};\n  }\n\n  !canUseDOM ?  false ? 0 : tiny_invariant_esm(false) : void 0;\n  var globalHistory = window.history;\n  var canUseHistory = supportsHistory();\n  var needsHashChangeListener = !supportsPopStateOnHashChange();\n  var _props = props,\n      _props$forceRefresh = _props.forceRefresh,\n      forceRefresh = _props$forceRefresh === void 0 ? false : _props$forceRefresh,\n      _props$getUserConfirm = _props.getUserConfirmation,\n      getUserConfirmation = _props$getUserConfirm === void 0 ? getConfirmation : _props$getUserConfirm,\n      _props$keyLength = _props.keyLength,\n      keyLength = _props$keyLength === void 0 ? 6 : _props$keyLength;\n  var basename = props.basename ? stripTrailingSlash(addLeadingSlash(props.basename)) : \'\';\n\n  function getDOMLocation(historyState) {\n    var _ref = historyState || {},\n        key = _ref.key,\n        state = _ref.state;\n\n    var _window$location = window.location,\n        pathname = _window$location.pathname,\n        search = _window$location.search,\n        hash = _window$location.hash;\n    var path = pathname + search + hash;\n     false ? 0 : void 0;\n    if (basename) path = stripBasename(path, basename);\n    return history_createLocation(path, state, key);\n  }\n\n  function createKey() {\n    return Math.random().toString(36).substr(2, keyLength);\n  }\n\n  var transitionManager = createTransitionManager();\n\n  function setState(nextState) {\n    extends_extends(history, nextState);\n\n    history.length = globalHistory.length;\n    transitionManager.notifyListeners(history.location, history.action);\n  }\n\n  function handlePopState(event) {\n    // Ignore extraneous popstate events in WebKit.\n    if (isExtraneousPopstateEvent(event)) return;\n    handlePop(getDOMLocation(event.state));\n  }\n\n  function handleHashChange() {\n    handlePop(getDOMLocation(getHistoryState()));\n  }\n\n  var forceNextPop = false;\n\n  function handlePop(location) {\n    if (forceNextPop) {\n      forceNextPop = false;\n      setState();\n    } else {\n      var action = \'POP\';\n      transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {\n        if (ok) {\n          setState({\n            action: action,\n            location: location\n          });\n        } else {\n          revertPop(location);\n        }\n      });\n    }\n  }\n\n  function revertPop(fromLocation) {\n    var toLocation = history.location; // TODO: We could probably make this more reliable by\n    // keeping a list of keys we\'ve seen in sessionStorage.\n    // Instead, we just default to 0 for keys we don\'t know.\n\n    var toIndex = allKeys.indexOf(toLocation.key);\n    if (toIndex === -1) toIndex = 0;\n    var fromIndex = allKeys.indexOf(fromLocation.key);\n    if (fromIndex === -1) fromIndex = 0;\n    var delta = toIndex - fromIndex;\n\n    if (delta) {\n      forceNextPop = true;\n      go(delta);\n    }\n  }\n\n  var initialLocation = getDOMLocation(getHistoryState());\n  var allKeys = [initialLocation.key]; // Public interface\n\n  function createHref(location) {\n    return basename + createPath(location);\n  }\n\n  function push(path, state) {\n     false ? 0 : void 0;\n    var action = \'PUSH\';\n    var location = history_createLocation(path, state, createKey(), history.location);\n    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {\n      if (!ok) return;\n      var href = createHref(location);\n      var key = location.key,\n          state = location.state;\n\n      if (canUseHistory) {\n        globalHistory.pushState({\n          key: key,\n          state: state\n        }, null, href);\n\n        if (forceRefresh) {\n          window.location.href = href;\n        } else {\n          var prevIndex = allKeys.indexOf(history.location.key);\n          var nextKeys = allKeys.slice(0, prevIndex + 1);\n          nextKeys.push(location.key);\n          allKeys = nextKeys;\n          setState({\n            action: action,\n            location: location\n          });\n        }\n      } else {\n         false ? 0 : void 0;\n        window.location.href = href;\n      }\n    });\n  }\n\n  function replace(path, state) {\n     false ? 0 : void 0;\n    var action = \'REPLACE\';\n    var location = history_createLocation(path, state, createKey(), history.location);\n    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {\n      if (!ok) return;\n      var href = createHref(location);\n      var key = location.key,\n          state = location.state;\n\n      if (canUseHistory) {\n        globalHistory.replaceState({\n          key: key,\n          state: state\n        }, null, href);\n\n        if (forceRefresh) {\n          window.location.replace(href);\n        } else {\n          var prevIndex = allKeys.indexOf(history.location.key);\n          if (prevIndex !== -1) allKeys[prevIndex] = location.key;\n          setState({\n            action: action,\n            location: location\n          });\n        }\n      } else {\n         false ? 0 : void 0;\n        window.location.replace(href);\n      }\n    });\n  }\n\n  function go(n) {\n    globalHistory.go(n);\n  }\n\n  function goBack() {\n    go(-1);\n  }\n\n  function goForward() {\n    go(1);\n  }\n\n  var listenerCount = 0;\n\n  function checkDOMListeners(delta) {\n    listenerCount += delta;\n\n    if (listenerCount === 1 && delta === 1) {\n      window.addEventListener(PopStateEvent, handlePopState);\n      if (needsHashChangeListener) window.addEventListener(HashChangeEvent, handleHashChange);\n    } else if (listenerCount === 0) {\n      window.removeEventListener(PopStateEvent, handlePopState);\n      if (needsHashChangeListener) window.removeEventListener(HashChangeEvent, handleHashChange);\n    }\n  }\n\n  var isBlocked = false;\n\n  function block(prompt) {\n    if (prompt === void 0) {\n      prompt = false;\n    }\n\n    var unblock = transitionManager.setPrompt(prompt);\n\n    if (!isBlocked) {\n      checkDOMListeners(1);\n      isBlocked = true;\n    }\n\n    return function () {\n      if (isBlocked) {\n        isBlocked = false;\n        checkDOMListeners(-1);\n      }\n\n      return unblock();\n    };\n  }\n\n  function listen(listener) {\n    var unlisten = transitionManager.appendListener(listener);\n    checkDOMListeners(1);\n    return function () {\n      checkDOMListeners(-1);\n      unlisten();\n    };\n  }\n\n  var history = {\n    length: globalHistory.length,\n    action: \'POP\',\n    location: initialLocation,\n    createHref: createHref,\n    push: push,\n    replace: replace,\n    go: go,\n    goBack: goBack,\n    goForward: goForward,\n    block: block,\n    listen: listen\n  };\n  return history;\n}\n\nvar HashChangeEvent$1 = \'hashchange\';\nvar HashPathCoders = {\n  hashbang: {\n    encodePath: function encodePath(path) {\n      return path.charAt(0) === \'!\' ? path : \'!/\' + stripLeadingSlash(path);\n    },\n    decodePath: function decodePath(path) {\n      return path.charAt(0) === \'!\' ? path.substr(1) : path;\n    }\n  },\n  noslash: {\n    encodePath: stripLeadingSlash,\n    decodePath: addLeadingSlash\n  },\n  slash: {\n    encodePath: addLeadingSlash,\n    decodePath: addLeadingSlash\n  }\n};\n\nfunction stripHash(url) {\n  var hashIndex = url.indexOf(\'#\');\n  return hashIndex === -1 ? url : url.slice(0, hashIndex);\n}\n\nfunction getHashPath() {\n  // We can\'t use window.location.hash here because it\'s not\n  // consistent across browsers - Firefox will pre-decode it!\n  var href = window.location.href;\n  var hashIndex = href.indexOf(\'#\');\n  return hashIndex === -1 ? \'\' : href.substring(hashIndex + 1);\n}\n\nfunction pushHashPath(path) {\n  window.location.hash = path;\n}\n\nfunction replaceHashPath(path) {\n  window.location.replace(stripHash(window.location.href) + \'#\' + path);\n}\n\nfunction createHashHistory(props) {\n  if (props === void 0) {\n    props = {};\n  }\n\n  !canUseDOM ?  false ? 0 : tiny_invariant_esm(false) : void 0;\n  var globalHistory = window.history;\n  var canGoWithoutReload = supportsGoWithoutReloadUsingHash();\n  var _props = props,\n      _props$getUserConfirm = _props.getUserConfirmation,\n      getUserConfirmation = _props$getUserConfirm === void 0 ? getConfirmation : _props$getUserConfirm,\n      _props$hashType = _props.hashType,\n      hashType = _props$hashType === void 0 ? \'slash\' : _props$hashType;\n  var basename = props.basename ? stripTrailingSlash(addLeadingSlash(props.basename)) : \'\';\n  var _HashPathCoders$hashT = HashPathCoders[hashType],\n      encodePath = _HashPathCoders$hashT.encodePath,\n      decodePath = _HashPathCoders$hashT.decodePath;\n\n  function getDOMLocation() {\n    var path = decodePath(getHashPath());\n     false ? 0 : void 0;\n    if (basename) path = stripBasename(path, basename);\n    return history_createLocation(path);\n  }\n\n  var transitionManager = createTransitionManager();\n\n  function setState(nextState) {\n    extends_extends(history, nextState);\n\n    history.length = globalHistory.length;\n    transitionManager.notifyListeners(history.location, history.action);\n  }\n\n  var forceNextPop = false;\n  var ignorePath = null;\n\n  function locationsAreEqual$$1(a, b) {\n    return a.pathname === b.pathname && a.search === b.search && a.hash === b.hash;\n  }\n\n  function handleHashChange() {\n    var path = getHashPath();\n    var encodedPath = encodePath(path);\n\n    if (path !== encodedPath) {\n      // Ensure we always have a properly-encoded hash.\n      replaceHashPath(encodedPath);\n    } else {\n      var location = getDOMLocation();\n      var prevLocation = history.location;\n      if (!forceNextPop && locationsAreEqual$$1(prevLocation, location)) return; // A hashchange doesn\'t always == location change.\n\n      if (ignorePath === createPath(location)) return; // Ignore this change; we already setState in push/replace.\n\n      ignorePath = null;\n      handlePop(location);\n    }\n  }\n\n  function handlePop(location) {\n    if (forceNextPop) {\n      forceNextPop = false;\n      setState();\n    } else {\n      var action = \'POP\';\n      transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {\n        if (ok) {\n          setState({\n            action: action,\n            location: location\n          });\n        } else {\n          revertPop(location);\n        }\n      });\n    }\n  }\n\n  function revertPop(fromLocation) {\n    var toLocation = history.location; // TODO: We could probably make this more reliable by\n    // keeping a list of paths we\'ve seen in sessionStorage.\n    // Instead, we just default to 0 for paths we don\'t know.\n\n    var toIndex = allPaths.lastIndexOf(createPath(toLocation));\n    if (toIndex === -1) toIndex = 0;\n    var fromIndex = allPaths.lastIndexOf(createPath(fromLocation));\n    if (fromIndex === -1) fromIndex = 0;\n    var delta = toIndex - fromIndex;\n\n    if (delta) {\n      forceNextPop = true;\n      go(delta);\n    }\n  } // Ensure the hash is encoded properly before doing anything else.\n\n\n  var path = getHashPath();\n  var encodedPath = encodePath(path);\n  if (path !== encodedPath) replaceHashPath(encodedPath);\n  var initialLocation = getDOMLocation();\n  var allPaths = [createPath(initialLocation)]; // Public interface\n\n  function createHref(location) {\n    var baseTag = document.querySelector(\'base\');\n    var href = \'\';\n\n    if (baseTag && baseTag.getAttribute(\'href\')) {\n      href = stripHash(window.location.href);\n    }\n\n    return href + \'#\' + encodePath(basename + createPath(location));\n  }\n\n  function push(path, state) {\n     false ? 0 : void 0;\n    var action = \'PUSH\';\n    var location = history_createLocation(path, undefined, undefined, history.location);\n    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {\n      if (!ok) return;\n      var path = createPath(location);\n      var encodedPath = encodePath(basename + path);\n      var hashChanged = getHashPath() !== encodedPath;\n\n      if (hashChanged) {\n        // We cannot tell if a hashchange was caused by a PUSH, so we\'d\n        // rather setState here and ignore the hashchange. The caveat here\n        // is that other hash histories in the page will consider it a POP.\n        ignorePath = path;\n        pushHashPath(encodedPath);\n        var prevIndex = allPaths.lastIndexOf(createPath(history.location));\n        var nextPaths = allPaths.slice(0, prevIndex + 1);\n        nextPaths.push(path);\n        allPaths = nextPaths;\n        setState({\n          action: action,\n          location: location\n        });\n      } else {\n         false ? 0 : void 0;\n        setState();\n      }\n    });\n  }\n\n  function replace(path, state) {\n     false ? 0 : void 0;\n    var action = \'REPLACE\';\n    var location = history_createLocation(path, undefined, undefined, history.location);\n    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {\n      if (!ok) return;\n      var path = createPath(location);\n      var encodedPath = encodePath(basename + path);\n      var hashChanged = getHashPath() !== encodedPath;\n\n      if (hashChanged) {\n        // We cannot tell if a hashchange was caused by a REPLACE, so we\'d\n        // rather setState here and ignore the hashchange. The caveat here\n        // is that other hash histories in the page will consider it a POP.\n        ignorePath = path;\n        replaceHashPath(encodedPath);\n      }\n\n      var prevIndex = allPaths.indexOf(createPath(history.location));\n      if (prevIndex !== -1) allPaths[prevIndex] = path;\n      setState({\n        action: action,\n        location: location\n      });\n    });\n  }\n\n  function go(n) {\n     false ? 0 : void 0;\n    globalHistory.go(n);\n  }\n\n  function goBack() {\n    go(-1);\n  }\n\n  function goForward() {\n    go(1);\n  }\n\n  var listenerCount = 0;\n\n  function checkDOMListeners(delta) {\n    listenerCount += delta;\n\n    if (listenerCount === 1 && delta === 1) {\n      window.addEventListener(HashChangeEvent$1, handleHashChange);\n    } else if (listenerCount === 0) {\n      window.removeEventListener(HashChangeEvent$1, handleHashChange);\n    }\n  }\n\n  var isBlocked = false;\n\n  function block(prompt) {\n    if (prompt === void 0) {\n      prompt = false;\n    }\n\n    var unblock = transitionManager.setPrompt(prompt);\n\n    if (!isBlocked) {\n      checkDOMListeners(1);\n      isBlocked = true;\n    }\n\n    return function () {\n      if (isBlocked) {\n        isBlocked = false;\n        checkDOMListeners(-1);\n      }\n\n      return unblock();\n    };\n  }\n\n  function listen(listener) {\n    var unlisten = transitionManager.appendListener(listener);\n    checkDOMListeners(1);\n    return function () {\n      checkDOMListeners(-1);\n      unlisten();\n    };\n  }\n\n  var history = {\n    length: globalHistory.length,\n    action: \'POP\',\n    location: initialLocation,\n    createHref: createHref,\n    push: push,\n    replace: replace,\n    go: go,\n    goBack: goBack,\n    goForward: goForward,\n    block: block,\n    listen: listen\n  };\n  return history;\n}\n\nfunction clamp(n, lowerBound, upperBound) {\n  return Math.min(Math.max(n, lowerBound), upperBound);\n}\n/**\n * Creates a history object that stores locations in memory.\n */\n\n\nfunction createMemoryHistory(props) {\n  if (props === void 0) {\n    props = {};\n  }\n\n  var _props = props,\n      getUserConfirmation = _props.getUserConfirmation,\n      _props$initialEntries = _props.initialEntries,\n      initialEntries = _props$initialEntries === void 0 ? [\'/\'] : _props$initialEntries,\n      _props$initialIndex = _props.initialIndex,\n      initialIndex = _props$initialIndex === void 0 ? 0 : _props$initialIndex,\n      _props$keyLength = _props.keyLength,\n      keyLength = _props$keyLength === void 0 ? 6 : _props$keyLength;\n  var transitionManager = createTransitionManager();\n\n  function setState(nextState) {\n    extends_extends(history, nextState);\n\n    history.length = history.entries.length;\n    transitionManager.notifyListeners(history.location, history.action);\n  }\n\n  function createKey() {\n    return Math.random().toString(36).substr(2, keyLength);\n  }\n\n  var index = clamp(initialIndex, 0, initialEntries.length - 1);\n  var entries = initialEntries.map(function (entry) {\n    return typeof entry === \'string\' ? history_createLocation(entry, undefined, createKey()) : history_createLocation(entry, undefined, entry.key || createKey());\n  }); // Public interface\n\n  var createHref = createPath;\n\n  function push(path, state) {\n     false ? 0 : void 0;\n    var action = \'PUSH\';\n    var location = history_createLocation(path, state, createKey(), history.location);\n    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {\n      if (!ok) return;\n      var prevIndex = history.index;\n      var nextIndex = prevIndex + 1;\n      var nextEntries = history.entries.slice(0);\n\n      if (nextEntries.length > nextIndex) {\n        nextEntries.splice(nextIndex, nextEntries.length - nextIndex, location);\n      } else {\n        nextEntries.push(location);\n      }\n\n      setState({\n        action: action,\n        location: location,\n        index: nextIndex,\n        entries: nextEntries\n      });\n    });\n  }\n\n  function replace(path, state) {\n     false ? 0 : void 0;\n    var action = \'REPLACE\';\n    var location = history_createLocation(path, state, createKey(), history.location);\n    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {\n      if (!ok) return;\n      history.entries[history.index] = location;\n      setState({\n        action: action,\n        location: location\n      });\n    });\n  }\n\n  function go(n) {\n    var nextIndex = clamp(history.index + n, 0, history.entries.length - 1);\n    var action = \'POP\';\n    var location = history.entries[nextIndex];\n    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {\n      if (ok) {\n        setState({\n          action: action,\n          location: location,\n          index: nextIndex\n        });\n      } else {\n        // Mimic the behavior of DOM histories by\n        // causing a render after a cancelled POP.\n        setState();\n      }\n    });\n  }\n\n  function goBack() {\n    go(-1);\n  }\n\n  function goForward() {\n    go(1);\n  }\n\n  function canGo(n) {\n    var nextIndex = history.index + n;\n    return nextIndex >= 0 && nextIndex < history.entries.length;\n  }\n\n  function block(prompt) {\n    if (prompt === void 0) {\n      prompt = false;\n    }\n\n    return transitionManager.setPrompt(prompt);\n  }\n\n  function listen(listener) {\n    return transitionManager.appendListener(listener);\n  }\n\n  var history = {\n    length: entries.length,\n    action: \'POP\',\n    location: entries[index],\n    index: index,\n    entries: entries,\n    createHref: createHref,\n    push: push,\n    replace: replace,\n    go: go,\n    goBack: goBack,\n    goForward: goForward,\n    canGo: canGo,\n    block: block,\n    listen: listen\n  };\n  return history;\n}\n\n\n\n;// CONCATENATED MODULE: ./node_modules/mini-create-react-context/dist/esm/index.js\n\n\n\n\n\nvar MAX_SIGNED_31_BIT_INT = 1073741823;\nvar commonjsGlobal = typeof globalThis !== \'undefined\' ? globalThis : typeof window !== \'undefined\' ? window : typeof __webpack_require__.g !== \'undefined\' ? __webpack_require__.g : {};\n\nfunction getUniqueId() {\n  var key = \'__global_unique_id__\';\n  return commonjsGlobal[key] = (commonjsGlobal[key] || 0) + 1;\n}\n\nfunction objectIs(x, y) {\n  if (x === y) {\n    return x !== 0 || 1 / x === 1 / y;\n  } else {\n    return x !== x && y !== y;\n  }\n}\n\nfunction createEventEmitter(value) {\n  var handlers = [];\n  return {\n    on: function on(handler) {\n      handlers.push(handler);\n    },\n    off: function off(handler) {\n      handlers = handlers.filter(function (h) {\n        return h !== handler;\n      });\n    },\n    get: function get() {\n      return value;\n    },\n    set: function set(newValue, changedBits) {\n      value = newValue;\n      handlers.forEach(function (handler) {\n        return handler(value, changedBits);\n      });\n    }\n  };\n}\n\nfunction onlyChild(children) {\n  return Array.isArray(children) ? children[0] : children;\n}\n\nfunction createReactContext(defaultValue, calculateChangedBits) {\n  var _Provider$childContex, _Consumer$contextType;\n\n  var contextProp = \'__create-react-context-\' + getUniqueId() + \'__\';\n\n  var Provider = /*#__PURE__*/function (_Component) {\n    _inheritsLoose(Provider, _Component);\n\n    function Provider() {\n      var _this;\n\n      _this = _Component.apply(this, arguments) || this;\n      _this.emitter = createEventEmitter(_this.props.value);\n      return _this;\n    }\n\n    var _proto = Provider.prototype;\n\n    _proto.getChildContext = function getChildContext() {\n      var _ref;\n\n      return _ref = {}, _ref[contextProp] = this.emitter, _ref;\n    };\n\n    _proto.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {\n      if (this.props.value !== nextProps.value) {\n        var oldValue = this.props.value;\n        var newValue = nextProps.value;\n        var changedBits;\n\n        if (objectIs(oldValue, newValue)) {\n          changedBits = 0;\n        } else {\n          changedBits = typeof calculateChangedBits === \'function\' ? calculateChangedBits(oldValue, newValue) : MAX_SIGNED_31_BIT_INT;\n\n          if (false) {}\n\n          changedBits |= 0;\n\n          if (changedBits !== 0) {\n            this.emitter.set(nextProps.value, changedBits);\n          }\n        }\n      }\n    };\n\n    _proto.render = function render() {\n      return this.props.children;\n    };\n\n    return Provider;\n  }(react.Component);\n\n  Provider.childContextTypes = (_Provider$childContex = {}, _Provider$childContex[contextProp] = (prop_types_default()).object.isRequired, _Provider$childContex);\n\n  var Consumer = /*#__PURE__*/function (_Component2) {\n    _inheritsLoose(Consumer, _Component2);\n\n    function Consumer() {\n      var _this2;\n\n      _this2 = _Component2.apply(this, arguments) || this;\n      _this2.state = {\n        value: _this2.getValue()\n      };\n\n      _this2.onUpdate = function (newValue, changedBits) {\n        var observedBits = _this2.observedBits | 0;\n\n        if ((observedBits & changedBits) !== 0) {\n          _this2.setState({\n            value: _this2.getValue()\n          });\n        }\n      };\n\n      return _this2;\n    }\n\n    var _proto2 = Consumer.prototype;\n\n    _proto2.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {\n      var observedBits = nextProps.observedBits;\n      this.observedBits = observedBits === undefined || observedBits === null ? MAX_SIGNED_31_BIT_INT : observedBits;\n    };\n\n    _proto2.componentDidMount = function componentDidMount() {\n      if (this.context[contextProp]) {\n        this.context[contextProp].on(this.onUpdate);\n      }\n\n      var observedBits = this.props.observedBits;\n      this.observedBits = observedBits === undefined || observedBits === null ? MAX_SIGNED_31_BIT_INT : observedBits;\n    };\n\n    _proto2.componentWillUnmount = function componentWillUnmount() {\n      if (this.context[contextProp]) {\n        this.context[contextProp].off(this.onUpdate);\n      }\n    };\n\n    _proto2.getValue = function getValue() {\n      if (this.context[contextProp]) {\n        return this.context[contextProp].get();\n      } else {\n        return defaultValue;\n      }\n    };\n\n    _proto2.render = function render() {\n      return onlyChild(this.props.children)(this.state.value);\n    };\n\n    return Consumer;\n  }(react.Component);\n\n  Consumer.contextTypes = (_Consumer$contextType = {}, _Consumer$contextType[contextProp] = (prop_types_default()).object, _Consumer$contextType);\n  return {\n    Provider: Provider,\n    Consumer: Consumer\n  };\n}\n\nvar index = react.createContext || createReactContext;\n\n/* harmony default export */ const esm = (index);\n\n// EXTERNAL MODULE: ./node_modules/path-to-regexp/index.js\nvar path_to_regexp = __webpack_require__(779);\nvar path_to_regexp_default = /*#__PURE__*/__webpack_require__.n(path_to_regexp);\n// EXTERNAL MODULE: ./node_modules/react-is/index.js\nvar react_is = __webpack_require__(864);\n;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/objectWithoutPropertiesLoose.js\nfunction objectWithoutPropertiesLoose_objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}\n// EXTERNAL MODULE: ./node_modules/hoist-non-react-statics/dist/hoist-non-react-statics.cjs.js\nvar hoist_non_react_statics_cjs = __webpack_require__(679);\n;// CONCATENATED MODULE: ./node_modules/react-router/esm/react-router.js\n\n\n\n\n\n\n\n\n\n\n\n\n\n// TODO: Replace with React.createContext once we can assume React 16+\n\nvar createNamedContext = function createNamedContext(name) {\n  var context = esm();\n  context.displayName = name;\n  return context;\n};\n\nvar historyContext = /*#__PURE__*/createNamedContext("Router-History");\n\nvar context = /*#__PURE__*/createNamedContext("Router");\n\n/**\n * The public API for putting history on context.\n */\n\nvar Router = /*#__PURE__*/function (_React$Component) {\n  _inheritsLoose(Router, _React$Component);\n\n  Router.computeRootMatch = function computeRootMatch(pathname) {\n    return {\n      path: "/",\n      url: "/",\n      params: {},\n      isExact: pathname === "/"\n    };\n  };\n\n  function Router(props) {\n    var _this;\n\n    _this = _React$Component.call(this, props) || this;\n    _this.state = {\n      location: props.history.location\n    }; // This is a bit of a hack. We have to start listening for location\n    // changes here in the constructor in case there are any <Redirect>s\n    // on the initial render. If there are, they will replace/push when\n    // they mount and since cDM fires in children before parents, we may\n    // get a new location before the <Router> is mounted.\n\n    _this._isMounted = false;\n    _this._pendingLocation = null;\n\n    if (!props.staticContext) {\n      _this.unlisten = props.history.listen(function (location) {\n        if (_this._isMounted) {\n          _this.setState({\n            location: location\n          });\n        } else {\n          _this._pendingLocation = location;\n        }\n      });\n    }\n\n    return _this;\n  }\n\n  var _proto = Router.prototype;\n\n  _proto.componentDidMount = function componentDidMount() {\n    this._isMounted = true;\n\n    if (this._pendingLocation) {\n      this.setState({\n        location: this._pendingLocation\n      });\n    }\n  };\n\n  _proto.componentWillUnmount = function componentWillUnmount() {\n    if (this.unlisten) {\n      this.unlisten();\n      this._isMounted = false;\n      this._pendingLocation = null;\n    }\n  };\n\n  _proto.render = function render() {\n    return /*#__PURE__*/react.createElement(context.Provider, {\n      value: {\n        history: this.props.history,\n        location: this.state.location,\n        match: Router.computeRootMatch(this.state.location.pathname),\n        staticContext: this.props.staticContext\n      }\n    }, /*#__PURE__*/react.createElement(historyContext.Provider, {\n      children: this.props.children || null,\n      value: this.props.history\n    }));\n  };\n\n  return Router;\n}(react.Component);\n\nif (false) {}\n\n/**\n * The public API for a <Router> that stores location in memory.\n */\n\nvar MemoryRouter = /*#__PURE__*/function (_React$Component) {\n  _inheritsLoose(MemoryRouter, _React$Component);\n\n  function MemoryRouter() {\n    var _this;\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;\n    _this.history = createMemoryHistory(_this.props);\n    return _this;\n  }\n\n  var _proto = MemoryRouter.prototype;\n\n  _proto.render = function render() {\n    return /*#__PURE__*/react.createElement(Router, {\n      history: this.history,\n      children: this.props.children\n    });\n  };\n\n  return MemoryRouter;\n}(react.Component);\n\nif (false) {}\n\nvar Lifecycle = /*#__PURE__*/function (_React$Component) {\n  _inheritsLoose(Lifecycle, _React$Component);\n\n  function Lifecycle() {\n    return _React$Component.apply(this, arguments) || this;\n  }\n\n  var _proto = Lifecycle.prototype;\n\n  _proto.componentDidMount = function componentDidMount() {\n    if (this.props.onMount) this.props.onMount.call(this, this);\n  };\n\n  _proto.componentDidUpdate = function componentDidUpdate(prevProps) {\n    if (this.props.onUpdate) this.props.onUpdate.call(this, this, prevProps);\n  };\n\n  _proto.componentWillUnmount = function componentWillUnmount() {\n    if (this.props.onUnmount) this.props.onUnmount.call(this, this);\n  };\n\n  _proto.render = function render() {\n    return null;\n  };\n\n  return Lifecycle;\n}(react.Component);\n\n/**\n * The public API for prompting the user before navigating away from a screen.\n */\n\nfunction Prompt(_ref) {\n  var message = _ref.message,\n      _ref$when = _ref.when,\n      when = _ref$when === void 0 ? true : _ref$when;\n  return /*#__PURE__*/React.createElement(context.Consumer, null, function (context) {\n    !context ?  false ? 0 : invariant(false) : void 0;\n    if (!when || context.staticContext) return null;\n    var method = context.history.block;\n    return /*#__PURE__*/React.createElement(Lifecycle, {\n      onMount: function onMount(self) {\n        self.release = method(message);\n      },\n      onUpdate: function onUpdate(self, prevProps) {\n        if (prevProps.message !== message) {\n          self.release();\n          self.release = method(message);\n        }\n      },\n      onUnmount: function onUnmount(self) {\n        self.release();\n      },\n      message: message\n    });\n  });\n}\n\nif (false) { var messageType; }\n\nvar cache = {};\nvar cacheLimit = 10000;\nvar cacheCount = 0;\n\nfunction compilePath(path) {\n  if (cache[path]) return cache[path];\n  var generator = pathToRegexp.compile(path);\n\n  if (cacheCount < cacheLimit) {\n    cache[path] = generator;\n    cacheCount++;\n  }\n\n  return generator;\n}\n/**\n * Public API for generating a URL pathname from a path and parameters.\n */\n\n\nfunction generatePath(path, params) {\n  if (path === void 0) {\n    path = "/";\n  }\n\n  if (params === void 0) {\n    params = {};\n  }\n\n  return path === "/" ? path : compilePath(path)(params, {\n    pretty: true\n  });\n}\n\n/**\n * The public API for navigating programmatically with a component.\n */\n\nfunction Redirect(_ref) {\n  var computedMatch = _ref.computedMatch,\n      to = _ref.to,\n      _ref$push = _ref.push,\n      push = _ref$push === void 0 ? false : _ref$push;\n  return /*#__PURE__*/React.createElement(context.Consumer, null, function (context) {\n    !context ?  false ? 0 : invariant(false) : void 0;\n    var history = context.history,\n        staticContext = context.staticContext;\n    var method = push ? history.push : history.replace;\n    var location = createLocation(computedMatch ? typeof to === "string" ? generatePath(to, computedMatch.params) : _extends({}, to, {\n      pathname: generatePath(to.pathname, computedMatch.params)\n    }) : to); // When rendering in a static context,\n    // set the new location immediately.\n\n    if (staticContext) {\n      method(location);\n      return null;\n    }\n\n    return /*#__PURE__*/React.createElement(Lifecycle, {\n      onMount: function onMount() {\n        method(location);\n      },\n      onUpdate: function onUpdate(self, prevProps) {\n        var prevLocation = createLocation(prevProps.to);\n\n        if (!locationsAreEqual(prevLocation, _extends({}, location, {\n          key: prevLocation.key\n        }))) {\n          method(location);\n        }\n      },\n      to: to\n    });\n  });\n}\n\nif (false) {}\n\nvar cache$1 = {};\nvar cacheLimit$1 = 10000;\nvar cacheCount$1 = 0;\n\nfunction compilePath$1(path, options) {\n  var cacheKey = "" + options.end + options.strict + options.sensitive;\n  var pathCache = cache$1[cacheKey] || (cache$1[cacheKey] = {});\n  if (pathCache[path]) return pathCache[path];\n  var keys = [];\n  var regexp = path_to_regexp_default()(path, keys, options);\n  var result = {\n    regexp: regexp,\n    keys: keys\n  };\n\n  if (cacheCount$1 < cacheLimit$1) {\n    pathCache[path] = result;\n    cacheCount$1++;\n  }\n\n  return result;\n}\n/**\n * Public API for matching a URL pathname to a path.\n */\n\n\nfunction matchPath(pathname, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  if (typeof options === "string" || Array.isArray(options)) {\n    options = {\n      path: options\n    };\n  }\n\n  var _options = options,\n      path = _options.path,\n      _options$exact = _options.exact,\n      exact = _options$exact === void 0 ? false : _options$exact,\n      _options$strict = _options.strict,\n      strict = _options$strict === void 0 ? false : _options$strict,\n      _options$sensitive = _options.sensitive,\n      sensitive = _options$sensitive === void 0 ? false : _options$sensitive;\n  var paths = [].concat(path);\n  return paths.reduce(function (matched, path) {\n    if (!path && path !== "") return null;\n    if (matched) return matched;\n\n    var _compilePath = compilePath$1(path, {\n      end: exact,\n      strict: strict,\n      sensitive: sensitive\n    }),\n        regexp = _compilePath.regexp,\n        keys = _compilePath.keys;\n\n    var match = regexp.exec(pathname);\n    if (!match) return null;\n    var url = match[0],\n        values = match.slice(1);\n    var isExact = pathname === url;\n    if (exact && !isExact) return null;\n    return {\n      path: path,\n      // the path used to match\n      url: path === "/" && url === "" ? "/" : url,\n      // the matched portion of the URL\n      isExact: isExact,\n      // whether or not we matched exactly\n      params: keys.reduce(function (memo, key, index) {\n        memo[key.name] = values[index];\n        return memo;\n      }, {})\n    };\n  }, null);\n}\n\nfunction isEmptyChildren(children) {\n  return react.Children.count(children) === 0;\n}\n\nfunction evalChildrenDev(children, props, path) {\n  var value = children(props);\n   false ? 0 : void 0;\n  return value || null;\n}\n/**\n * The public API for matching a single path and rendering.\n */\n\n\nvar Route = /*#__PURE__*/function (_React$Component) {\n  _inheritsLoose(Route, _React$Component);\n\n  function Route() {\n    return _React$Component.apply(this, arguments) || this;\n  }\n\n  var _proto = Route.prototype;\n\n  _proto.render = function render() {\n    var _this = this;\n\n    return /*#__PURE__*/react.createElement(context.Consumer, null, function (context$1) {\n      !context$1 ?  false ? 0 : tiny_invariant_esm(false) : void 0;\n      var location = _this.props.location || context$1.location;\n      var match = _this.props.computedMatch ? _this.props.computedMatch // <Switch> already computed the match for us\n      : _this.props.path ? matchPath(location.pathname, _this.props) : context$1.match;\n\n      var props = extends_extends({}, context$1, {\n        location: location,\n        match: match\n      });\n\n      var _this$props = _this.props,\n          children = _this$props.children,\n          component = _this$props.component,\n          render = _this$props.render; // Preact uses an empty array as children by\n      // default, so use null if that\'s the case.\n\n      if (Array.isArray(children) && isEmptyChildren(children)) {\n        children = null;\n      }\n\n      return /*#__PURE__*/react.createElement(context.Provider, {\n        value: props\n      }, props.match ? children ? typeof children === "function" ?  false ? 0 : children(props) : children : component ? /*#__PURE__*/react.createElement(component, props) : render ? render(props) : null : typeof children === "function" ?  false ? 0 : children(props) : null);\n    });\n  };\n\n  return Route;\n}(react.Component);\n\nif (false) {}\n\nfunction react_router_addLeadingSlash(path) {\n  return path.charAt(0) === "/" ? path : "/" + path;\n}\n\nfunction addBasename(basename, location) {\n  if (!basename) return location;\n  return extends_extends({}, location, {\n    pathname: react_router_addLeadingSlash(basename) + location.pathname\n  });\n}\n\nfunction react_router_stripBasename(basename, location) {\n  if (!basename) return location;\n  var base = react_router_addLeadingSlash(basename);\n  if (location.pathname.indexOf(base) !== 0) return location;\n  return extends_extends({}, location, {\n    pathname: location.pathname.substr(base.length)\n  });\n}\n\nfunction createURL(location) {\n  return typeof location === "string" ? location : createPath(location);\n}\n\nfunction staticHandler(methodName) {\n  return function () {\n      false ? 0 : tiny_invariant_esm(false) ;\n  };\n}\n\nfunction noop() {}\n/**\n * The public top-level API for a "static" <Router>, so-called because it\n * can\'t actually change the current location. Instead, it just records\n * location changes in a context object. Useful mainly in testing and\n * server-rendering scenarios.\n */\n\n\nvar StaticRouter = /*#__PURE__*/function (_React$Component) {\n  _inheritsLoose(StaticRouter, _React$Component);\n\n  function StaticRouter() {\n    var _this;\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;\n\n    _this.handlePush = function (location) {\n      return _this.navigateTo(location, "PUSH");\n    };\n\n    _this.handleReplace = function (location) {\n      return _this.navigateTo(location, "REPLACE");\n    };\n\n    _this.handleListen = function () {\n      return noop;\n    };\n\n    _this.handleBlock = function () {\n      return noop;\n    };\n\n    return _this;\n  }\n\n  var _proto = StaticRouter.prototype;\n\n  _proto.navigateTo = function navigateTo(location, action) {\n    var _this$props = this.props,\n        _this$props$basename = _this$props.basename,\n        basename = _this$props$basename === void 0 ? "" : _this$props$basename,\n        _this$props$context = _this$props.context,\n        context = _this$props$context === void 0 ? {} : _this$props$context;\n    context.action = action;\n    context.location = addBasename(basename, history_createLocation(location));\n    context.url = createURL(context.location);\n  };\n\n  _proto.render = function render() {\n    var _this$props2 = this.props,\n        _this$props2$basename = _this$props2.basename,\n        basename = _this$props2$basename === void 0 ? "" : _this$props2$basename,\n        _this$props2$context = _this$props2.context,\n        context = _this$props2$context === void 0 ? {} : _this$props2$context,\n        _this$props2$location = _this$props2.location,\n        location = _this$props2$location === void 0 ? "/" : _this$props2$location,\n        rest = objectWithoutPropertiesLoose_objectWithoutPropertiesLoose(_this$props2, ["basename", "context", "location"]);\n\n    var history = {\n      createHref: function createHref(path) {\n        return react_router_addLeadingSlash(basename + createURL(path));\n      },\n      action: "POP",\n      location: react_router_stripBasename(basename, history_createLocation(location)),\n      push: this.handlePush,\n      replace: this.handleReplace,\n      go: staticHandler("go"),\n      goBack: staticHandler("goBack"),\n      goForward: staticHandler("goForward"),\n      listen: this.handleListen,\n      block: this.handleBlock\n    };\n    return /*#__PURE__*/react.createElement(Router, extends_extends({}, rest, {\n      history: history,\n      staticContext: context\n    }));\n  };\n\n  return StaticRouter;\n}(react.Component);\n\nif (false) {}\n\n/**\n * The public API for rendering the first <Route> that matches.\n */\n\nvar Switch = /*#__PURE__*/function (_React$Component) {\n  _inheritsLoose(Switch, _React$Component);\n\n  function Switch() {\n    return _React$Component.apply(this, arguments) || this;\n  }\n\n  var _proto = Switch.prototype;\n\n  _proto.render = function render() {\n    var _this = this;\n\n    return /*#__PURE__*/react.createElement(context.Consumer, null, function (context) {\n      !context ?  false ? 0 : tiny_invariant_esm(false) : void 0;\n      var location = _this.props.location || context.location;\n      var element, match; // We use React.Children.forEach instead of React.Children.toArray().find()\n      // here because toArray adds keys to all child elements and we do not want\n      // to trigger an unmount/remount for two <Route>s that render the same\n      // component at different URLs.\n\n      react.Children.forEach(_this.props.children, function (child) {\n        if (match == null && /*#__PURE__*/react.isValidElement(child)) {\n          element = child;\n          var path = child.props.path || child.props.from;\n          match = path ? matchPath(location.pathname, extends_extends({}, child.props, {\n            path: path\n          })) : context.match;\n        }\n      });\n      return match ? /*#__PURE__*/react.cloneElement(element, {\n        location: location,\n        computedMatch: match\n      }) : null;\n    });\n  };\n\n  return Switch;\n}(react.Component);\n\nif (false) {}\n\n/**\n * A public higher-order component to access the imperative API\n */\n\nfunction withRouter(Component) {\n  var displayName = "withRouter(" + (Component.displayName || Component.name) + ")";\n\n  var C = function C(props) {\n    var wrappedComponentRef = props.wrappedComponentRef,\n        remainingProps = _objectWithoutPropertiesLoose(props, ["wrappedComponentRef"]);\n\n    return /*#__PURE__*/React.createElement(context.Consumer, null, function (context) {\n      !context ?  false ? 0 : invariant(false) : void 0;\n      return /*#__PURE__*/React.createElement(Component, _extends({}, remainingProps, context, {\n        ref: wrappedComponentRef\n      }));\n    });\n  };\n\n  C.displayName = displayName;\n  C.WrappedComponent = Component;\n\n  if (false) {}\n\n  return hoistStatics(C, Component);\n}\n\nvar useContext = react.useContext;\nfunction useHistory() {\n  if (false) {}\n\n  return useContext(historyContext);\n}\nfunction useLocation() {\n  if (false) {}\n\n  return useContext(context).location;\n}\nfunction useParams() {\n  if (false) {}\n\n  var match = useContext(context).match;\n  return match ? match.params : {};\n}\nfunction useRouteMatch(path) {\n  if (false) {}\n\n  var location = useLocation();\n  var match = useContext(context).match;\n  return path ? matchPath(location.pathname, path) : match;\n}\n\nif (false) { var secondaryBuildName, initialBuildName, buildNames, key, global; }\n\n\n//# sourceMappingURL=react-router.js.map\n\n;// CONCATENATED MODULE: ./node_modules/react-router-dom/esm/react-router-dom.js\n\n\n\n\n\n\n\n\n\n\n\n/**\n * The public API for a <Router> that uses HTML5 history.\n */\n\nvar BrowserRouter = /*#__PURE__*/function (_React$Component) {\n  _inheritsLoose(BrowserRouter, _React$Component);\n\n  function BrowserRouter() {\n    var _this;\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;\n    _this.history = createBrowserHistory(_this.props);\n    return _this;\n  }\n\n  var _proto = BrowserRouter.prototype;\n\n  _proto.render = function render() {\n    return /*#__PURE__*/react.createElement(Router, {\n      history: this.history,\n      children: this.props.children\n    });\n  };\n\n  return BrowserRouter;\n}(react.Component);\n\nif (false) {}\n\n/**\n * The public API for a <Router> that uses window.location.hash.\n */\n\nvar HashRouter = /*#__PURE__*/function (_React$Component) {\n  _inheritsLoose(HashRouter, _React$Component);\n\n  function HashRouter() {\n    var _this;\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;\n    _this.history = createHashHistory(_this.props);\n    return _this;\n  }\n\n  var _proto = HashRouter.prototype;\n\n  _proto.render = function render() {\n    return /*#__PURE__*/react.createElement(Router, {\n      history: this.history,\n      children: this.props.children\n    });\n  };\n\n  return HashRouter;\n}(react.Component);\n\nif (false) {}\n\nvar resolveToLocation = function resolveToLocation(to, currentLocation) {\n  return typeof to === "function" ? to(currentLocation) : to;\n};\nvar normalizeToLocation = function normalizeToLocation(to, currentLocation) {\n  return typeof to === "string" ? history_createLocation(to, null, null, currentLocation) : to;\n};\n\nvar forwardRefShim = function forwardRefShim(C) {\n  return C;\n};\n\nvar react_router_dom_forwardRef = react.forwardRef;\n\nif (typeof react_router_dom_forwardRef === "undefined") {\n  react_router_dom_forwardRef = forwardRefShim;\n}\n\nfunction isModifiedEvent(event) {\n  return !!(event.metaKey || event.altKey || event.ctrlKey || event.shiftKey);\n}\n\nvar LinkAnchor = react_router_dom_forwardRef(function (_ref, forwardedRef) {\n  var innerRef = _ref.innerRef,\n      navigate = _ref.navigate,\n      _onClick = _ref.onClick,\n      rest = objectWithoutPropertiesLoose_objectWithoutPropertiesLoose(_ref, ["innerRef", "navigate", "onClick"]);\n\n  var target = rest.target;\n\n  var props = extends_extends({}, rest, {\n    onClick: function onClick(event) {\n      try {\n        if (_onClick) _onClick(event);\n      } catch (ex) {\n        event.preventDefault();\n        throw ex;\n      }\n\n      if (!event.defaultPrevented && // onClick prevented default\n      event.button === 0 && ( // ignore everything but left clicks\n      !target || target === "_self") && // let browser handle "target=_blank" etc.\n      !isModifiedEvent(event) // ignore clicks with modifier keys\n      ) {\n          event.preventDefault();\n          navigate();\n        }\n    }\n  }); // React 15 compat\n\n\n  if (forwardRefShim !== react_router_dom_forwardRef) {\n    props.ref = forwardedRef || innerRef;\n  } else {\n    props.ref = innerRef;\n  }\n  /* eslint-disable-next-line jsx-a11y/anchor-has-content */\n\n\n  return /*#__PURE__*/react.createElement("a", props);\n});\n\nif (false) {}\n/**\n * The public API for rendering a history-aware <a>.\n */\n\n\nvar Link = react_router_dom_forwardRef(function (_ref2, forwardedRef) {\n  var _ref2$component = _ref2.component,\n      component = _ref2$component === void 0 ? LinkAnchor : _ref2$component,\n      replace = _ref2.replace,\n      to = _ref2.to,\n      innerRef = _ref2.innerRef,\n      rest = objectWithoutPropertiesLoose_objectWithoutPropertiesLoose(_ref2, ["component", "replace", "to", "innerRef"]);\n\n  return /*#__PURE__*/react.createElement(context.Consumer, null, function (context) {\n    !context ?  false ? 0 : tiny_invariant_esm(false) : void 0;\n    var history = context.history;\n    var location = normalizeToLocation(resolveToLocation(to, context.location), context.location);\n    var href = location ? history.createHref(location) : "";\n\n    var props = extends_extends({}, rest, {\n      href: href,\n      navigate: function navigate() {\n        var location = resolveToLocation(to, context.location);\n        var isDuplicateNavigation = createPath(context.location) === createPath(normalizeToLocation(location));\n        var method = replace || isDuplicateNavigation ? history.replace : history.push;\n        method(location);\n      }\n    }); // React 15 compat\n\n\n    if (forwardRefShim !== react_router_dom_forwardRef) {\n      props.ref = forwardedRef || innerRef;\n    } else {\n      props.innerRef = innerRef;\n    }\n\n    return /*#__PURE__*/react.createElement(component, props);\n  });\n});\n\nif (false) { var refType, toType; }\n\nvar forwardRefShim$1 = function forwardRefShim(C) {\n  return C;\n};\n\nvar forwardRef$1 = react.forwardRef;\n\nif (typeof forwardRef$1 === "undefined") {\n  forwardRef$1 = forwardRefShim$1;\n}\n\nfunction joinClassnames() {\n  for (var _len = arguments.length, classnames = new Array(_len), _key = 0; _key < _len; _key++) {\n    classnames[_key] = arguments[_key];\n  }\n\n  return classnames.filter(function (i) {\n    return i;\n  }).join(" ");\n}\n/**\n * A <Link> wrapper that knows if it\'s "active" or not.\n */\n\n\nvar NavLink = forwardRef$1(function (_ref, forwardedRef) {\n  var _ref$ariaCurrent = _ref["aria-current"],\n      ariaCurrent = _ref$ariaCurrent === void 0 ? "page" : _ref$ariaCurrent,\n      _ref$activeClassName = _ref.activeClassName,\n      activeClassName = _ref$activeClassName === void 0 ? "active" : _ref$activeClassName,\n      activeStyle = _ref.activeStyle,\n      classNameProp = _ref.className,\n      exact = _ref.exact,\n      isActiveProp = _ref.isActive,\n      locationProp = _ref.location,\n      sensitive = _ref.sensitive,\n      strict = _ref.strict,\n      styleProp = _ref.style,\n      to = _ref.to,\n      innerRef = _ref.innerRef,\n      rest = objectWithoutPropertiesLoose_objectWithoutPropertiesLoose(_ref, ["aria-current", "activeClassName", "activeStyle", "className", "exact", "isActive", "location", "sensitive", "strict", "style", "to", "innerRef"]);\n\n  return /*#__PURE__*/react.createElement(context.Consumer, null, function (context) {\n    !context ?  false ? 0 : tiny_invariant_esm(false) : void 0;\n    var currentLocation = locationProp || context.location;\n    var toLocation = normalizeToLocation(resolveToLocation(to, currentLocation), currentLocation);\n    var path = toLocation.pathname; // Regex taken from: https://github.com/pillarjs/path-to-regexp/blob/master/index.js#L202\n\n    var escapedPath = path && path.replace(/([.+*?=^!:${}()[\\]|/\\\\])/g, "\\\\$1");\n    var match = escapedPath ? matchPath(currentLocation.pathname, {\n      path: escapedPath,\n      exact: exact,\n      sensitive: sensitive,\n      strict: strict\n    }) : null;\n    var isActive = !!(isActiveProp ? isActiveProp(match, currentLocation) : match);\n    var className = typeof classNameProp === "function" ? classNameProp(isActive) : classNameProp;\n    var style = typeof styleProp === "function" ? styleProp(isActive) : styleProp;\n\n    if (isActive) {\n      className = joinClassnames(className, activeClassName);\n      style = extends_extends({}, style, activeStyle);\n    }\n\n    var props = extends_extends({\n      "aria-current": isActive && ariaCurrent || null,\n      className: className,\n      style: style,\n      to: toLocation\n    }, rest); // React 15 compat\n\n\n    if (forwardRefShim$1 !== forwardRef$1) {\n      props.ref = forwardedRef || innerRef;\n    } else {\n      props.innerRef = innerRef;\n    }\n\n    return /*#__PURE__*/react.createElement(Link, props);\n  });\n});\n\nif (false) { var ariaCurrentType; }\n\n\n//# sourceMappingURL=react-router-dom.js.map\n\n// EXTERNAL MODULE: ./node_modules/react-dom/index.js\nvar react_dom = __webpack_require__(935);\n// EXTERNAL MODULE: ./node_modules/classnames/index.js\nvar classnames = __webpack_require__(184);\nvar classnames_default = /*#__PURE__*/__webpack_require__.n(classnames);\n;// CONCATENATED MODULE: ./src/component.js\nvar _excluded = ["component", "fallback", "className", "children"];\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = component_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction component_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\nfunction createComponent(_ref, fn) {\n  var displayName = _ref.displayName,\n      propTypes = _ref.propTypes,\n      defaultProps = _ref.defaultProps;\n  var Component = fn.length > 1 ? /*#__PURE__*/forwardRef(fn) : fn;\n  Component.displayName = displayName;\n  Component.propTypes = propTypes;\n  Component.defaultProps = defaultProps;\n  return Component;\n}\nvar Clone = /*#__PURE__*/(0,react.forwardRef)(function Clone(_ref2, ref) {\n  var component = _ref2.component,\n      fallback = _ref2.fallback,\n      className = _ref2.className,\n      _ref2$children = _ref2.children,\n      children = _ref2$children === void 0 ? component : _ref2$children,\n      props = _objectWithoutProperties(_ref2, _excluded);\n\n  if ( /*#__PURE__*/(0,react.isValidElement)(component)) {\n    return /*#__PURE__*/(0,react.cloneElement)(component, _objectSpread({\n      ref: ref,\n      className: classnames_default()(className, component.props.className)\n    }, props));\n  } else if ( /*#__PURE__*/(0,react.isValidElement)(fallback)) {\n    return /*#__PURE__*/(0,react.cloneElement)(fallback, _objectSpread({\n      ref: ref,\n      className: classnames_default()(className, fallback.props.className)\n    }, props));\n  } else if (fallback) {\n    return /*#__PURE__*/(0,react.createElement)(fallback, _objectSpread({\n      ref: ref,\n      className: className\n    }, props), children);\n  } else {\n    return children;\n  }\n});\n\n;// CONCATENATED MODULE: ./src/icon/constants.js\nvar cssClasses = {\n  ROOT: \'mdc-icon\',\n  MATERIAL_ICONS: \'material-icons\',\n  LIGHT: \'mdc-icon--light\',\n  DARK: \'mdc-icon--dark\',\n  INACTIVE: \'mdc-icon--inactive\'\n};\n// EXTERNAL MODULE: ./node_modules/react/jsx-runtime.js\nvar jsx_runtime = __webpack_require__(893);\n;// CONCATENATED MODULE: ./src/icon/Icon.jsx\nvar Icon_excluded = ["size", "light", "dark", "inactive", "element", "component", "className"];\n\nfunction Icon_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction Icon_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { Icon_ownKeys(Object(source), true).forEach(function (key) { Icon_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { Icon_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction Icon_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction Icon_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = Icon_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction Icon_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\n\nvar Icon = /*#__PURE__*/(0,react.forwardRef)(function (_ref, ref) {\n  var _classnames;\n\n  var size = _ref.size,\n      _ref$light = _ref.light,\n      light = _ref$light === void 0 ? false : _ref$light,\n      _ref$dark = _ref.dark,\n      dark = _ref$dark === void 0 ? false : _ref$dark,\n      _ref$inactive = _ref.inactive,\n      inactive = _ref$inactive === void 0 ? false : _ref$inactive,\n      _ref$element = _ref.element,\n      element = _ref$element === void 0 ? \'i\' : _ref$element,\n      _ref$component = _ref.component,\n      Element = _ref$component === void 0 ? element : _ref$component,\n      className = _ref.className,\n      props = Icon_objectWithoutProperties(_ref, Icon_excluded);\n\n  var classNames = classnames_default()(cssClasses.ROOT, cssClasses.MATERIAL_ICONS, (_classnames = {}, Icon_defineProperty(_classnames, "".concat(cssClasses.ROOT, "--").concat(size), size), Icon_defineProperty(_classnames, cssClasses.LIGHT, light), Icon_defineProperty(_classnames, cssClasses.DARK, dark), Icon_defineProperty(_classnames, cssClasses.INACTIVE, inactive), _classnames), className);\n  return /*#__PURE__*/(0,jsx_runtime.jsx)(Element, Icon_objectSpread({\n    ref: ref,\n    className: classNames\n  }, props));\n});\nIcon.displayName = \'MDCIcon\';\nIcon.propTypes = {\n  size: (prop_types_default()).string,\n  dark: (prop_types_default()).bool,\n  light: (prop_types_default()).bool,\n  inactive: (prop_types_default()).bool\n};\n/* harmony default export */ const icon_Icon = (Icon);\n;// CONCATENATED MODULE: ./src/icon/index.js\n\n;// CONCATENATED MODULE: ./src/avatar/constants.js\nvar constants_cssClasses = {\n  ROOT: \'mdc-avatar\',\n  SMALL: \'mdc-avatar--small\',\n  MEDIUM: \'mdc-avatar--medium\',\n  LARGE: \'mdc-avatar--large\',\n  IMAGE: \'mdc-avatar__image\',\n  ICON: \'mdc-avatar__icon\',\n  TEXT: \'mdc-avatar__text\'\n};\n;// CONCATENATED MODULE: ./src/avatar/Avatar.jsx\nvar Avatar_excluded = ["image", "icon", "text", "size", "element", "component", "className", "children"];\n\nfunction Avatar_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction Avatar_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { Avatar_ownKeys(Object(source), true).forEach(function (key) { Avatar_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { Avatar_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction Avatar_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction Avatar_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = Avatar_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction Avatar_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\n\n\n\n\nvar Avatar = /*#__PURE__*/(0,react.forwardRef)(function (_ref, ref) {\n  var image = _ref.image,\n      icon = _ref.icon,\n      text = _ref.text,\n      size = _ref.size,\n      _ref$element = _ref.element,\n      element = _ref$element === void 0 ? \'span\' : _ref$element,\n      _ref$component = _ref.component,\n      Element = _ref$component === void 0 ? element : _ref$component,\n      className = _ref.className,\n      _ref$children = _ref.children,\n      children = _ref$children === void 0 ? text : _ref$children,\n      props = Avatar_objectWithoutProperties(_ref, Avatar_excluded);\n\n  var classNames = classnames_default()(constants_cssClasses.ROOT, Avatar_defineProperty({}, "".concat(constants_cssClasses.ROOT, "--").concat(size), size), className);\n  return /*#__PURE__*/(0,jsx_runtime.jsxs)(Element, Avatar_objectSpread(Avatar_objectSpread({\n    ref: ref,\n    className: classNames\n  }, props), {}, {\n    children: [image && /*#__PURE__*/(0,jsx_runtime.jsx)("img", {\n      className: constants_cssClasses.IMAGE,\n      src: (image === null || image === void 0 ? void 0 : image.src) || image,\n      alt: (image === null || image === void 0 ? void 0 : image.alt) || \'\'\n    }), icon && /*#__PURE__*/(0,jsx_runtime.jsx)(Clone, {\n      component: icon,\n      fallback: icon_Icon,\n      className: constants_cssClasses.ICON\n    }), children && /*#__PURE__*/(0,jsx_runtime.jsx)(Clone, {\n      component: children,\n      fallback: "span",\n      className: constants_cssClasses.TEXT\n    })]\n  }));\n});\nAvatar.displayName = \'MDCAvatar\';\nAvatar.propTypes = {\n  src: (prop_types_default()).string,\n  icon: (prop_types_default()).node,\n  text: (prop_types_default()).node,\n  size: prop_types_default().oneOf([\'small\', \'medium\', \'large\'])\n};\n/* harmony default export */ const avatar_Avatar = (Avatar);\n;// CONCATENATED MODULE: ./src/avatar/index.js\n\n;// CONCATENATED MODULE: ./src/badge/constants.js\nvar badge_constants_cssClasses = {\n  ROOT: \'mdc-badge\',\n  INSET: \'mdc-badge--inset\',\n  TRANSPARENT: \'mdc-badge--transparent\'\n};\n;// CONCATENATED MODULE: ./src/badge/Badge.jsx\nvar Badge_excluded = ["value", "inset", "transparent", "element", "className"];\n\nfunction Badge_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction Badge_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { Badge_ownKeys(Object(source), true).forEach(function (key) { Badge_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { Badge_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction Badge_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction Badge_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = Badge_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction Badge_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\n\nvar Badge = /*#__PURE__*/(0,react.forwardRef)(function (_ref, ref) {\n  var _classnames;\n\n  var value = _ref.value,\n      _ref$inset = _ref.inset,\n      inset = _ref$inset === void 0 ? false : _ref$inset,\n      _ref$transparent = _ref.transparent,\n      transparent = _ref$transparent === void 0 ? false : _ref$transparent,\n      _ref$element = _ref.element,\n      Element = _ref$element === void 0 ? \'span\' : _ref$element,\n      className = _ref.className,\n      props = Badge_objectWithoutProperties(_ref, Badge_excluded);\n\n  var classNames = classnames_default()(badge_constants_cssClasses.ROOT, (_classnames = {}, Badge_defineProperty(_classnames, badge_constants_cssClasses.INSET, inset), Badge_defineProperty(_classnames, badge_constants_cssClasses.TRANSPARENT, transparent), _classnames), className);\n  return /*#__PURE__*/(0,jsx_runtime.jsx)(Element, Badge_objectSpread({\n    ref: ref,\n    className: classNames,\n    "data-badge": value\n  }, props));\n});\nBadge.displayName = \'MDCBadge\';\nBadge.propTypes = {\n  value: prop_types_default().oneOfType([(prop_types_default()).number, (prop_types_default()).string]).isRequired,\n  inset: (prop_types_default()).bool,\n  transparent: (prop_types_default()).bool\n};\n/* harmony default export */ const badge_Badge = (Badge);\n;// CONCATENATED MODULE: ./src/badge/index.js\n\n;// CONCATENATED MODULE: ./node_modules/dom-helpers/esm/hasClass.js\n/**\n * Checks if a given element has a CSS class.\n * \n * @param element the element\n * @param className the CSS class name\n */\nfunction hasClass(element, className) {\n  if (element.classList) return !!className && element.classList.contains(className);\n  return (" " + (element.className.baseVal || element.className) + " ").indexOf(" " + className + " ") !== -1;\n}\n;// CONCATENATED MODULE: ./node_modules/dom-helpers/esm/addClass.js\n\n/**\n * Adds a CSS class to a given element.\n * \n * @param element the element\n * @param className the CSS class name\n */\n\nfunction addClass_addClass(element, className) {\n  if (element.classList) element.classList.add(className);else if (!hasClass(element, className)) if (typeof element.className === \'string\') element.className = element.className + " " + className;else element.setAttribute(\'class\', (element.className && element.className.baseVal || \'\') + " " + className);\n}\n;// CONCATENATED MODULE: ./node_modules/dom-helpers/esm/removeClass.js\nfunction replaceClassName(origClass, classToRemove) {\n  return origClass.replace(new RegExp("(^|\\\\s)" + classToRemove + "(?:\\\\s|$)", \'g\'), \'$1\').replace(/\\s+/g, \' \').replace(/^\\s*|\\s*$/g, \'\');\n}\n/**\n * Removes a CSS class from a given element.\n * \n * @param element the element\n * @param className the CSS class name\n */\n\n\nfunction removeClass_removeClass(element, className) {\n  if (element.classList) {\n    element.classList.remove(className);\n  } else if (typeof element.className === \'string\') {\n    element.className = replaceClassName(element.className, className);\n  } else {\n    element.setAttribute(\'class\', replaceClassName(element.className && element.className.baseVal || \'\', className));\n  }\n}\n;// CONCATENATED MODULE: ./node_modules/react-transition-group/esm/config.js\n/* harmony default export */ const config = ({\n  disabled: false\n});\n;// CONCATENATED MODULE: ./node_modules/react-transition-group/esm/TransitionGroupContext.js\n\n/* harmony default export */ const TransitionGroupContext = (react.createContext(null));\n;// CONCATENATED MODULE: ./node_modules/react-transition-group/esm/Transition.js\n\n\n\n\n\n\n\n\nvar UNMOUNTED = \'unmounted\';\nvar EXITED = \'exited\';\nvar ENTERING = \'entering\';\nvar ENTERED = \'entered\';\nvar EXITING = \'exiting\';\n/**\n * The Transition component lets you describe a transition from one component\n * state to another _over time_ with a simple declarative API. Most commonly\n * it\'s used to animate the mounting and unmounting of a component, but can also\n * be used to describe in-place transition states as well.\n *\n * ---\n *\n * **Note**: `Transition` is a platform-agnostic base component. If you\'re using\n * transitions in CSS, you\'ll probably want to use\n * [`CSSTransition`](https://reactcommunity.org/react-transition-group/css-transition)\n * instead. It inherits all the features of `Transition`, but contains\n * additional features necessary to play nice with CSS transitions (hence the\n * name of the component).\n *\n * ---\n *\n * By default the `Transition` component does not alter the behavior of the\n * component it renders, it only tracks "enter" and "exit" states for the\n * components. It\'s up to you to give meaning and effect to those states. For\n * example we can add styles to a component when it enters or exits:\n *\n * ```jsx\n * import { Transition } from \'react-transition-group\';\n *\n * const duration = 300;\n *\n * const defaultStyle = {\n *   transition: `opacity ${duration}ms ease-in-out`,\n *   opacity: 0,\n * }\n *\n * const transitionStyles = {\n *   entering: { opacity: 1 },\n *   entered:  { opacity: 1 },\n *   exiting:  { opacity: 0 },\n *   exited:  { opacity: 0 },\n * };\n *\n * const Fade = ({ in: inProp }) => (\n *   <Transition in={inProp} timeout={duration}>\n *     {state => (\n *       <div style={{\n *         ...defaultStyle,\n *         ...transitionStyles[state]\n *       }}>\n *         I\'m a fade Transition!\n *       </div>\n *     )}\n *   </Transition>\n * );\n * ```\n *\n * There are 4 main states a Transition can be in:\n *  - `\'entering\'`\n *  - `\'entered\'`\n *  - `\'exiting\'`\n *  - `\'exited\'`\n *\n * Transition state is toggled via the `in` prop. When `true` the component\n * begins the "Enter" stage. During this stage, the component will shift from\n * its current transition state, to `\'entering\'` for the duration of the\n * transition and then to the `\'entered\'` stage once it\'s complete. Let\'s take\n * the following example (we\'ll use the\n * [useState](https://reactjs.org/docs/hooks-reference.html#usestate) hook):\n *\n * ```jsx\n * function App() {\n *   const [inProp, setInProp] = useState(false);\n *   return (\n *     <div>\n *       <Transition in={inProp} timeout={500}>\n *         {state => (\n *           // ...\n *         )}\n *       </Transition>\n *       <button onClick={() => setInProp(true)}>\n *         Click to Enter\n *       </button>\n *     </div>\n *   );\n * }\n * ```\n *\n * When the button is clicked the component will shift to the `\'entering\'` state\n * and stay there for 500ms (the value of `timeout`) before it finally switches\n * to `\'entered\'`.\n *\n * When `in` is `false` the same thing happens except the state moves from\n * `\'exiting\'` to `\'exited\'`.\n */\n\nvar Transition = /*#__PURE__*/function (_React$Component) {\n  _inheritsLoose(Transition, _React$Component);\n\n  function Transition(props, context) {\n    var _this;\n\n    _this = _React$Component.call(this, props, context) || this;\n    var parentGroup = context; // In the context of a TransitionGroup all enters are really appears\n\n    var appear = parentGroup && !parentGroup.isMounting ? props.enter : props.appear;\n    var initialStatus;\n    _this.appearStatus = null;\n\n    if (props.in) {\n      if (appear) {\n        initialStatus = EXITED;\n        _this.appearStatus = ENTERING;\n      } else {\n        initialStatus = ENTERED;\n      }\n    } else {\n      if (props.unmountOnExit || props.mountOnEnter) {\n        initialStatus = UNMOUNTED;\n      } else {\n        initialStatus = EXITED;\n      }\n    }\n\n    _this.state = {\n      status: initialStatus\n    };\n    _this.nextCallback = null;\n    return _this;\n  }\n\n  Transition.getDerivedStateFromProps = function getDerivedStateFromProps(_ref, prevState) {\n    var nextIn = _ref.in;\n\n    if (nextIn && prevState.status === UNMOUNTED) {\n      return {\n        status: EXITED\n      };\n    }\n\n    return null;\n  } // getSnapshotBeforeUpdate(prevProps) {\n  //   let nextStatus = null\n  //   if (prevProps !== this.props) {\n  //     const { status } = this.state\n  //     if (this.props.in) {\n  //       if (status !== ENTERING && status !== ENTERED) {\n  //         nextStatus = ENTERING\n  //       }\n  //     } else {\n  //       if (status === ENTERING || status === ENTERED) {\n  //         nextStatus = EXITING\n  //       }\n  //     }\n  //   }\n  //   return { nextStatus }\n  // }\n  ;\n\n  var _proto = Transition.prototype;\n\n  _proto.componentDidMount = function componentDidMount() {\n    this.updateStatus(true, this.appearStatus);\n  };\n\n  _proto.componentDidUpdate = function componentDidUpdate(prevProps) {\n    var nextStatus = null;\n\n    if (prevProps !== this.props) {\n      var status = this.state.status;\n\n      if (this.props.in) {\n        if (status !== ENTERING && status !== ENTERED) {\n          nextStatus = ENTERING;\n        }\n      } else {\n        if (status === ENTERING || status === ENTERED) {\n          nextStatus = EXITING;\n        }\n      }\n    }\n\n    this.updateStatus(false, nextStatus);\n  };\n\n  _proto.componentWillUnmount = function componentWillUnmount() {\n    this.cancelNextCallback();\n  };\n\n  _proto.getTimeouts = function getTimeouts() {\n    var timeout = this.props.timeout;\n    var exit, enter, appear;\n    exit = enter = appear = timeout;\n\n    if (timeout != null && typeof timeout !== \'number\') {\n      exit = timeout.exit;\n      enter = timeout.enter; // TODO: remove fallback for next major\n\n      appear = timeout.appear !== undefined ? timeout.appear : enter;\n    }\n\n    return {\n      exit: exit,\n      enter: enter,\n      appear: appear\n    };\n  };\n\n  _proto.updateStatus = function updateStatus(mounting, nextStatus) {\n    if (mounting === void 0) {\n      mounting = false;\n    }\n\n    if (nextStatus !== null) {\n      // nextStatus will always be ENTERING or EXITING.\n      this.cancelNextCallback();\n\n      if (nextStatus === ENTERING) {\n        this.performEnter(mounting);\n      } else {\n        this.performExit();\n      }\n    } else if (this.props.unmountOnExit && this.state.status === EXITED) {\n      this.setState({\n        status: UNMOUNTED\n      });\n    }\n  };\n\n  _proto.performEnter = function performEnter(mounting) {\n    var _this2 = this;\n\n    var enter = this.props.enter;\n    var appearing = this.context ? this.context.isMounting : mounting;\n\n    var _ref2 = this.props.nodeRef ? [appearing] : [react_dom.findDOMNode(this), appearing],\n        maybeNode = _ref2[0],\n        maybeAppearing = _ref2[1];\n\n    var timeouts = this.getTimeouts();\n    var enterTimeout = appearing ? timeouts.appear : timeouts.enter; // no enter animation skip right to ENTERED\n    // if we are mounting and running this it means appear _must_ be set\n\n    if (!mounting && !enter || config.disabled) {\n      this.safeSetState({\n        status: ENTERED\n      }, function () {\n        _this2.props.onEntered(maybeNode);\n      });\n      return;\n    }\n\n    this.props.onEnter(maybeNode, maybeAppearing);\n    this.safeSetState({\n      status: ENTERING\n    }, function () {\n      _this2.props.onEntering(maybeNode, maybeAppearing);\n\n      _this2.onTransitionEnd(enterTimeout, function () {\n        _this2.safeSetState({\n          status: ENTERED\n        }, function () {\n          _this2.props.onEntered(maybeNode, maybeAppearing);\n        });\n      });\n    });\n  };\n\n  _proto.performExit = function performExit() {\n    var _this3 = this;\n\n    var exit = this.props.exit;\n    var timeouts = this.getTimeouts();\n    var maybeNode = this.props.nodeRef ? undefined : react_dom.findDOMNode(this); // no exit animation skip right to EXITED\n\n    if (!exit || config.disabled) {\n      this.safeSetState({\n        status: EXITED\n      }, function () {\n        _this3.props.onExited(maybeNode);\n      });\n      return;\n    }\n\n    this.props.onExit(maybeNode);\n    this.safeSetState({\n      status: EXITING\n    }, function () {\n      _this3.props.onExiting(maybeNode);\n\n      _this3.onTransitionEnd(timeouts.exit, function () {\n        _this3.safeSetState({\n          status: EXITED\n        }, function () {\n          _this3.props.onExited(maybeNode);\n        });\n      });\n    });\n  };\n\n  _proto.cancelNextCallback = function cancelNextCallback() {\n    if (this.nextCallback !== null) {\n      this.nextCallback.cancel();\n      this.nextCallback = null;\n    }\n  };\n\n  _proto.safeSetState = function safeSetState(nextState, callback) {\n    // This shouldn\'t be necessary, but there are weird race conditions with\n    // setState callbacks and unmounting in testing, so always make sure that\n    // we can cancel any pending setState callbacks after we unmount.\n    callback = this.setNextCallback(callback);\n    this.setState(nextState, callback);\n  };\n\n  _proto.setNextCallback = function setNextCallback(callback) {\n    var _this4 = this;\n\n    var active = true;\n\n    this.nextCallback = function (event) {\n      if (active) {\n        active = false;\n        _this4.nextCallback = null;\n        callback(event);\n      }\n    };\n\n    this.nextCallback.cancel = function () {\n      active = false;\n    };\n\n    return this.nextCallback;\n  };\n\n  _proto.onTransitionEnd = function onTransitionEnd(timeout, handler) {\n    this.setNextCallback(handler);\n    var node = this.props.nodeRef ? this.props.nodeRef.current : react_dom.findDOMNode(this);\n    var doesNotHaveTimeoutOrListener = timeout == null && !this.props.addEndListener;\n\n    if (!node || doesNotHaveTimeoutOrListener) {\n      setTimeout(this.nextCallback, 0);\n      return;\n    }\n\n    if (this.props.addEndListener) {\n      var _ref3 = this.props.nodeRef ? [this.nextCallback] : [node, this.nextCallback],\n          maybeNode = _ref3[0],\n          maybeNextCallback = _ref3[1];\n\n      this.props.addEndListener(maybeNode, maybeNextCallback);\n    }\n\n    if (timeout != null) {\n      setTimeout(this.nextCallback, timeout);\n    }\n  };\n\n  _proto.render = function render() {\n    var status = this.state.status;\n\n    if (status === UNMOUNTED) {\n      return null;\n    }\n\n    var _this$props = this.props,\n        children = _this$props.children,\n        _in = _this$props.in,\n        _mountOnEnter = _this$props.mountOnEnter,\n        _unmountOnExit = _this$props.unmountOnExit,\n        _appear = _this$props.appear,\n        _enter = _this$props.enter,\n        _exit = _this$props.exit,\n        _timeout = _this$props.timeout,\n        _addEndListener = _this$props.addEndListener,\n        _onEnter = _this$props.onEnter,\n        _onEntering = _this$props.onEntering,\n        _onEntered = _this$props.onEntered,\n        _onExit = _this$props.onExit,\n        _onExiting = _this$props.onExiting,\n        _onExited = _this$props.onExited,\n        _nodeRef = _this$props.nodeRef,\n        childProps = objectWithoutPropertiesLoose_objectWithoutPropertiesLoose(_this$props, ["children", "in", "mountOnEnter", "unmountOnExit", "appear", "enter", "exit", "timeout", "addEndListener", "onEnter", "onEntering", "onEntered", "onExit", "onExiting", "onExited", "nodeRef"]);\n\n    return (\n      /*#__PURE__*/\n      // allows for nested Transitions\n      react.createElement(TransitionGroupContext.Provider, {\n        value: null\n      }, typeof children === \'function\' ? children(status, childProps) : react.cloneElement(react.Children.only(children), childProps))\n    );\n  };\n\n  return Transition;\n}(react.Component);\n\nTransition.contextType = TransitionGroupContext;\nTransition.propTypes =  false ? 0 : {}; // Name the function so it is clearer in the documentation\n\nfunction Transition_noop() {}\n\nTransition.defaultProps = {\n  in: false,\n  mountOnEnter: false,\n  unmountOnExit: false,\n  appear: false,\n  enter: true,\n  exit: true,\n  onEnter: Transition_noop,\n  onEntering: Transition_noop,\n  onEntered: Transition_noop,\n  onExit: Transition_noop,\n  onExiting: Transition_noop,\n  onExited: Transition_noop\n};\nTransition.UNMOUNTED = UNMOUNTED;\nTransition.EXITED = EXITED;\nTransition.ENTERING = ENTERING;\nTransition.ENTERED = ENTERED;\nTransition.EXITING = EXITING;\n/* harmony default export */ const esm_Transition = (Transition);\n;// CONCATENATED MODULE: ./node_modules/react-transition-group/esm/CSSTransition.js\n\n\n\n\n\n\n\n\n\n\nvar _addClass = function addClass(node, classes) {\n  return node && classes && classes.split(\' \').forEach(function (c) {\n    return addClass_addClass(node, c);\n  });\n};\n\nvar removeClass = function removeClass(node, classes) {\n  return node && classes && classes.split(\' \').forEach(function (c) {\n    return removeClass_removeClass(node, c);\n  });\n};\n/**\n * A transition component inspired by the excellent\n * [ng-animate](https://docs.angularjs.org/api/ngAnimate) library, you should\n * use it if you\'re using CSS transitions or animations. It\'s built upon the\n * [`Transition`](https://reactcommunity.org/react-transition-group/transition)\n * component, so it inherits all of its props.\n *\n * `CSSTransition` applies a pair of class names during the `appear`, `enter`,\n * and `exit` states of the transition. The first class is applied and then a\n * second `*-active` class in order to activate the CSS transition. After the\n * transition, matching `*-done` class names are applied to persist the\n * transition state.\n *\n * ```jsx\n * function App() {\n *   const [inProp, setInProp] = useState(false);\n *   return (\n *     <div>\n *       <CSSTransition in={inProp} timeout={200} classNames="my-node">\n *         <div>\n *           {"I\'ll receive my-node-* classes"}\n *         </div>\n *       </CSSTransition>\n *       <button type="button" onClick={() => setInProp(true)}>\n *         Click to Enter\n *       </button>\n *     </div>\n *   );\n * }\n * ```\n *\n * When the `in` prop is set to `true`, the child component will first receive\n * the class `example-enter`, then the `example-enter-active` will be added in\n * the next tick. `CSSTransition` [forces a\n * reflow](https://github.com/reactjs/react-transition-group/blob/5007303e729a74be66a21c3e2205e4916821524b/src/CSSTransition.js#L208-L215)\n * between before adding the `example-enter-active`. This is an important trick\n * because it allows us to transition between `example-enter` and\n * `example-enter-active` even though they were added immediately one after\n * another. Most notably, this is what makes it possible for us to animate\n * _appearance_.\n *\n * ```css\n * .my-node-enter {\n *   opacity: 0;\n * }\n * .my-node-enter-active {\n *   opacity: 1;\n *   transition: opacity 200ms;\n * }\n * .my-node-exit {\n *   opacity: 1;\n * }\n * .my-node-exit-active {\n *   opacity: 0;\n *   transition: opacity 200ms;\n * }\n * ```\n *\n * `*-active` classes represent which styles you want to animate **to**, so it\'s\n * important to add `transition` declaration only to them, otherwise transitions\n * might not behave as intended! This might not be obvious when the transitions\n * are symmetrical, i.e. when `*-enter-active` is the same as `*-exit`, like in\n * the example above (minus `transition`), but it becomes apparent in more\n * complex transitions.\n *\n * **Note**: If you\'re using the\n * [`appear`](http://reactcommunity.org/react-transition-group/transition#Transition-prop-appear)\n * prop, make sure to define styles for `.appear-*` classes as well.\n */\n\n\nvar CSSTransition = /*#__PURE__*/function (_React$Component) {\n  _inheritsLoose(CSSTransition, _React$Component);\n\n  function CSSTransition() {\n    var _this;\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;\n    _this.appliedClasses = {\n      appear: {},\n      enter: {},\n      exit: {}\n    };\n\n    _this.onEnter = function (maybeNode, maybeAppearing) {\n      var _this$resolveArgument = _this.resolveArguments(maybeNode, maybeAppearing),\n          node = _this$resolveArgument[0],\n          appearing = _this$resolveArgument[1];\n\n      _this.removeClasses(node, \'exit\');\n\n      _this.addClass(node, appearing ? \'appear\' : \'enter\', \'base\');\n\n      if (_this.props.onEnter) {\n        _this.props.onEnter(maybeNode, maybeAppearing);\n      }\n    };\n\n    _this.onEntering = function (maybeNode, maybeAppearing) {\n      var _this$resolveArgument2 = _this.resolveArguments(maybeNode, maybeAppearing),\n          node = _this$resolveArgument2[0],\n          appearing = _this$resolveArgument2[1];\n\n      var type = appearing ? \'appear\' : \'enter\';\n\n      _this.addClass(node, type, \'active\');\n\n      if (_this.props.onEntering) {\n        _this.props.onEntering(maybeNode, maybeAppearing);\n      }\n    };\n\n    _this.onEntered = function (maybeNode, maybeAppearing) {\n      var _this$resolveArgument3 = _this.resolveArguments(maybeNode, maybeAppearing),\n          node = _this$resolveArgument3[0],\n          appearing = _this$resolveArgument3[1];\n\n      var type = appearing ? \'appear\' : \'enter\';\n\n      _this.removeClasses(node, type);\n\n      _this.addClass(node, type, \'done\');\n\n      if (_this.props.onEntered) {\n        _this.props.onEntered(maybeNode, maybeAppearing);\n      }\n    };\n\n    _this.onExit = function (maybeNode) {\n      var _this$resolveArgument4 = _this.resolveArguments(maybeNode),\n          node = _this$resolveArgument4[0];\n\n      _this.removeClasses(node, \'appear\');\n\n      _this.removeClasses(node, \'enter\');\n\n      _this.addClass(node, \'exit\', \'base\');\n\n      if (_this.props.onExit) {\n        _this.props.onExit(maybeNode);\n      }\n    };\n\n    _this.onExiting = function (maybeNode) {\n      var _this$resolveArgument5 = _this.resolveArguments(maybeNode),\n          node = _this$resolveArgument5[0];\n\n      _this.addClass(node, \'exit\', \'active\');\n\n      if (_this.props.onExiting) {\n        _this.props.onExiting(maybeNode);\n      }\n    };\n\n    _this.onExited = function (maybeNode) {\n      var _this$resolveArgument6 = _this.resolveArguments(maybeNode),\n          node = _this$resolveArgument6[0];\n\n      _this.removeClasses(node, \'exit\');\n\n      _this.addClass(node, \'exit\', \'done\');\n\n      if (_this.props.onExited) {\n        _this.props.onExited(maybeNode);\n      }\n    };\n\n    _this.resolveArguments = function (maybeNode, maybeAppearing) {\n      return _this.props.nodeRef ? [_this.props.nodeRef.current, maybeNode] // here `maybeNode` is actually `appearing`\n      : [maybeNode, maybeAppearing];\n    };\n\n    _this.getClassNames = function (type) {\n      var classNames = _this.props.classNames;\n      var isStringClassNames = typeof classNames === \'string\';\n      var prefix = isStringClassNames && classNames ? classNames + "-" : \'\';\n      var baseClassName = isStringClassNames ? "" + prefix + type : classNames[type];\n      var activeClassName = isStringClassNames ? baseClassName + "-active" : classNames[type + "Active"];\n      var doneClassName = isStringClassNames ? baseClassName + "-done" : classNames[type + "Done"];\n      return {\n        baseClassName: baseClassName,\n        activeClassName: activeClassName,\n        doneClassName: doneClassName\n      };\n    };\n\n    return _this;\n  }\n\n  var _proto = CSSTransition.prototype;\n\n  _proto.addClass = function addClass(node, type, phase) {\n    var className = this.getClassNames(type)[phase + "ClassName"];\n\n    var _this$getClassNames = this.getClassNames(\'enter\'),\n        doneClassName = _this$getClassNames.doneClassName;\n\n    if (type === \'appear\' && phase === \'done\' && doneClassName) {\n      className += " " + doneClassName;\n    } // This is to force a repaint,\n    // which is necessary in order to transition styles when adding a class name.\n\n\n    if (phase === \'active\') {\n      /* eslint-disable no-unused-expressions */\n      node && node.scrollTop;\n    }\n\n    if (className) {\n      this.appliedClasses[type][phase] = className;\n\n      _addClass(node, className);\n    }\n  };\n\n  _proto.removeClasses = function removeClasses(node, type) {\n    var _this$appliedClasses$ = this.appliedClasses[type],\n        baseClassName = _this$appliedClasses$.base,\n        activeClassName = _this$appliedClasses$.active,\n        doneClassName = _this$appliedClasses$.done;\n    this.appliedClasses[type] = {};\n\n    if (baseClassName) {\n      removeClass(node, baseClassName);\n    }\n\n    if (activeClassName) {\n      removeClass(node, activeClassName);\n    }\n\n    if (doneClassName) {\n      removeClass(node, doneClassName);\n    }\n  };\n\n  _proto.render = function render() {\n    var _this$props = this.props,\n        _ = _this$props.classNames,\n        props = objectWithoutPropertiesLoose_objectWithoutPropertiesLoose(_this$props, ["classNames"]);\n\n    return /*#__PURE__*/react.createElement(esm_Transition, extends_extends({}, props, {\n      onEnter: this.onEnter,\n      onEntered: this.onEntered,\n      onEntering: this.onEntering,\n      onExit: this.onExit,\n      onExiting: this.onExiting,\n      onExited: this.onExited\n    }));\n  };\n\n  return CSSTransition;\n}(react.Component);\n\nCSSTransition.defaultProps = {\n  classNames: \'\'\n};\nCSSTransition.propTypes =  false ? 0 : {};\n/* harmony default export */ const esm_CSSTransition = (CSSTransition);\n;// CONCATENATED MODULE: ./src/banner/constants.js\nvar numbers = {\n  BANNER_ANIMATION_CLOSE_TIME_MS: 250,\n  BANNER_ANIMATION_OPEN_TIME_MS: 300\n};\nvar banner_constants_cssClasses = {\n  ROOT: \'mdc-banner\',\n  FIXED: \'mdc-banner--fixed\',\n  CENTERED: \'mdc-banner--centered\',\n  MOBILE_STACKED: \'mdc-banner--mobile-stacked\',\n  APPEARING: \'mdc-banner--appearing\',\n  APPEARED: \'mdc-banner--appeared\',\n  OPENING: \'mdc-banner--opening\',\n  OPEN: \'mdc-banner--open\',\n  CLOSING: \'mdc-banner--closing\',\n  CONTENT: \'mdc-banner__content\',\n  GRAPHIC_TEXT_WRAPPER: \'mdc-banner__graphic-text-wrapper\',\n  GRAPHIC: \'mdc-banner__graphic\',\n  ICON: \'mdc-banner__icon\',\n  TEXT: \'mdc-banner__text\',\n  ACTIONS: \'mdc-banner__actions\',\n  PRIMARY_ACTION: \'mdc-banner__primary-action\',\n  SECONDARY_ACTION: \'mdc-banner__secondary-action\'\n};\n;// CONCATENATED MODULE: ./src/banner/Banner.jsx\nvar Banner_excluded = ["text", "icon", "graphic", "action", "primaryAction", "secondaryAction", "open", "centered", "fixed", "mobileStacked", "element", "component", "className", "children"];\n\nfunction Banner_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction Banner_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { Banner_ownKeys(Object(source), true).forEach(function (key) { Banner_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { Banner_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction Banner_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction Banner_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = Banner_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction Banner_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\n\n\n\n\n\nvar Banner = /*#__PURE__*/(0,react.forwardRef)(function (_ref, ref) {\n  var _classnames;\n\n  var text = _ref.text,\n      icon = _ref.icon,\n      _ref$graphic = _ref.graphic,\n      graphic = _ref$graphic === void 0 ? icon : _ref$graphic,\n      action = _ref.action,\n      _ref$primaryAction = _ref.primaryAction,\n      primaryAction = _ref$primaryAction === void 0 ? action : _ref$primaryAction,\n      secondaryAction = _ref.secondaryAction,\n      _ref$open = _ref.open,\n      open = _ref$open === void 0 ? false : _ref$open,\n      _ref$centered = _ref.centered,\n      centered = _ref$centered === void 0 ? false : _ref$centered,\n      _ref$fixed = _ref.fixed,\n      fixed = _ref$fixed === void 0 ? false : _ref$fixed,\n      _ref$mobileStacked = _ref.mobileStacked,\n      mobileStacked = _ref$mobileStacked === void 0 ? false : _ref$mobileStacked,\n      _ref$element = _ref.element,\n      element = _ref$element === void 0 ? \'div\' : _ref$element,\n      _ref$component = _ref.component,\n      Element = _ref$component === void 0 ? element : _ref$component,\n      className = _ref.className,\n      _ref$children = _ref.children,\n      children = _ref$children === void 0 ? text : _ref$children,\n      props = Banner_objectWithoutProperties(_ref, Banner_excluded);\n\n  var rootRef = (0,react.useRef)();\n  var contentRef = (0,react.useRef)();\n  (0,react.useImperativeHandle)(ref, function () {\n    return rootRef.current;\n  });\n  var handleEntering = (0,react.useCallback)(function (node, isAppearing) {\n    if (!isAppearing) {\n      node.style.height = "".concat(contentRef.current.offsetHeight, "px");\n    }\n  }, []);\n  var handleExiting = (0,react.useCallback)(function (node) {\n    node.style.height = \'0px\';\n  }, []);\n  var classNames = classnames_default()(banner_constants_cssClasses.ROOT, (_classnames = {}, Banner_defineProperty(_classnames, banner_constants_cssClasses.FIXED, fixed), Banner_defineProperty(_classnames, banner_constants_cssClasses.CENTERED, centered), Banner_defineProperty(_classnames, banner_constants_cssClasses.MOBILE_STACKED, mobileStacked), _classnames), className);\n\n  var content = /*#__PURE__*/(0,jsx_runtime.jsxs)("div", {\n    ref: contentRef,\n    className: banner_constants_cssClasses.CONTENT,\n    role: "status",\n    children: [/*#__PURE__*/(0,jsx_runtime.jsxs)("div", {\n      className: banner_constants_cssClasses.GRAPHIC_TEXT_WRAPPER,\n      children: [graphic && /*#__PURE__*/(0,jsx_runtime.jsx)("div", {\n        className: banner_constants_cssClasses.GRAPHIC,\n        children: /*#__PURE__*/(0,jsx_runtime.jsx)(Clone, {\n          component: graphic,\n          fallback: icon_Icon,\n          className: banner_constants_cssClasses.ICON\n        })\n      }), /*#__PURE__*/(0,jsx_runtime.jsx)(Clone, {\n        component: children,\n        fallback: "div",\n        className: banner_constants_cssClasses.TEXT\n      })]\n    }), primaryAction && /*#__PURE__*/(0,jsx_runtime.jsxs)("div", {\n      className: banner_constants_cssClasses.ACTIONS,\n      children: [secondaryAction && /*#__PURE__*/(0,jsx_runtime.jsx)(Clone, {\n        component: secondaryAction,\n        className: banner_constants_cssClasses.SECONDARY_ACTION\n      }), /*#__PURE__*/(0,jsx_runtime.jsx)(Clone, {\n        component: primaryAction,\n        className: banner_constants_cssClasses.PRIMARY_ACTION\n      })]\n    })]\n  });\n\n  return /*#__PURE__*/(0,jsx_runtime.jsx)(esm_CSSTransition, {\n    "in": open,\n    appear: open,\n    timeout: {\n      appear: 0,\n      enter: numbers.BANNER_ANIMATION_OPEN_TIME_MS,\n      exit: numbers.BANNER_ANIMATION_CLOSE_TIME_MS\n    },\n    classNames: {\n      appear: banner_constants_cssClasses.APPEARING,\n      appearDone: banner_constants_cssClasses.APPEARED,\n      enter: banner_constants_cssClasses.OPENING,\n      enterActive: banner_constants_cssClasses.OPEN,\n      enterDone: banner_constants_cssClasses.OPEN,\n      exit: banner_constants_cssClasses.CLOSING\n    },\n    mountOnEnter: true,\n    unmountOnExit: true,\n    onEntering: handleEntering,\n    onExiting: handleExiting,\n    children: /*#__PURE__*/(0,jsx_runtime.jsx)(Element, Banner_objectSpread(Banner_objectSpread({\n      ref: rootRef,\n      className: classNames,\n      role: "banner"\n    }, props), {}, {\n      children: content\n    }))\n  });\n});\nBanner.displayName = \'MDCBanner\';\nBanner.propTypes = {\n  text: (prop_types_default()).node.isRequired,\n  icon: (prop_types_default()).node,\n  graphic: (prop_types_default()).element,\n  action: (prop_types_default()).element,\n  primaryAction: (prop_types_default()).element,\n  secondaryAction: (prop_types_default()).element,\n  open: (prop_types_default()).bool,\n  appear: (prop_types_default()).bool,\n  fixed: (prop_types_default()).bool,\n  centered: (prop_types_default()).bool,\n  mobileStacked: (prop_types_default()).bool\n};\n/* harmony default export */ const banner_Banner = (Banner);\n;// CONCATENATED MODULE: ./src/banner/index.js\n\n;// CONCATENATED MODULE: ./src/button/constants.js\nvar button_constants_cssClasses = {\n  ROOT: \'mdc-button\',\n  RAISED: \'mdc-button--raised\',\n  UNELEVATED: \'mdc-button--unelevated\',\n  OUTLINED: \'mdc-button--outlined\',\n  TOUCH: \'mdc-button--touch\',\n  ICON_LEADING: \'mdc-button--icon-leading\',\n  ICON_TRAILING: \'mdc-button--icon-trailing\',\n  RIPPLE: \'mdc-button__ripple\',\n  ICON: \'mdc-button__icon\',\n  LABEL: \'mdc-button__label\',\n  TOUCH_ELEMENT: \'mdc-button__touch\'\n};\n;// CONCATENATED MODULE: ./src/button/Button.jsx\nvar Button_excluded = ["label", "icon", "leadingIcon", "trailingIcon", "raised", "unelevated", "outlined", "touch", "element", "component", "className", "children"];\n\nfunction Button_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction Button_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { Button_ownKeys(Object(source), true).forEach(function (key) { Button_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { Button_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction Button_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction Button_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = Button_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction Button_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\n\n\n\n\nvar Button = /*#__PURE__*/(0,react.forwardRef)(function (_ref, ref) {\n  var _classnames;\n\n  var label = _ref.label,\n      icon = _ref.icon,\n      _ref$leadingIcon = _ref.leadingIcon,\n      leadingIcon = _ref$leadingIcon === void 0 ? icon : _ref$leadingIcon,\n      trailingIcon = _ref.trailingIcon,\n      _ref$raised = _ref.raised,\n      raised = _ref$raised === void 0 ? false : _ref$raised,\n      _ref$unelevated = _ref.unelevated,\n      unelevated = _ref$unelevated === void 0 ? false : _ref$unelevated,\n      _ref$outlined = _ref.outlined,\n      outlined = _ref$outlined === void 0 ? false : _ref$outlined,\n      _ref$touch = _ref.touch,\n      touch = _ref$touch === void 0 ? false : _ref$touch,\n      _ref$element = _ref.element,\n      element = _ref$element === void 0 ? \'button\' : _ref$element,\n      _ref$component = _ref.component,\n      Element = _ref$component === void 0 ? element : _ref$component,\n      className = _ref.className,\n      _ref$children = _ref.children,\n      children = _ref$children === void 0 ? label : _ref$children,\n      props = Button_objectWithoutProperties(_ref, Button_excluded);\n\n  var classNames = classnames_default()(button_constants_cssClasses.ROOT, (_classnames = {}, Button_defineProperty(_classnames, button_constants_cssClasses.RAISED, raised), Button_defineProperty(_classnames, button_constants_cssClasses.UNELEVATED, unelevated), Button_defineProperty(_classnames, button_constants_cssClasses.OUTLINED, outlined), Button_defineProperty(_classnames, button_constants_cssClasses.TOUCH, touch), Button_defineProperty(_classnames, button_constants_cssClasses.ICON_LEADING, Boolean(leadingIcon)), Button_defineProperty(_classnames, button_constants_cssClasses.ICON_TRAILING, Boolean(trailingIcon)), _classnames), className);\n  return /*#__PURE__*/(0,jsx_runtime.jsxs)(Element, Button_objectSpread(Button_objectSpread({\n    ref: ref,\n    className: classNames\n  }, props), {}, {\n    children: [/*#__PURE__*/(0,jsx_runtime.jsx)("span", {\n      className: button_constants_cssClasses.RIPPLE\n    }), touch && /*#__PURE__*/(0,jsx_runtime.jsx)("span", {\n      className: button_constants_cssClasses.TOUCH_ELEMENT\n    }), leadingIcon && /*#__PURE__*/(0,jsx_runtime.jsx)(Clone, {\n      component: leadingIcon,\n      fallback: icon_Icon,\n      className: button_constants_cssClasses.ICON,\n      "aria-hidden": "true"\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)("span", {\n      className: button_constants_cssClasses.LABEL,\n      children: children\n    }), trailingIcon && /*#__PURE__*/(0,jsx_runtime.jsx)(Clone, {\n      component: trailingIcon,\n      fallback: icon_Icon,\n      className: button_constants_cssClasses.ICON,\n      "aria-hidden": "true"\n    })]\n  }));\n});\nButton.displayName = \'MDCButton\';\nButton.propTypes = {\n  label: (prop_types_default()).node,\n  icon: (prop_types_default()).node,\n  leadingIcon: (prop_types_default()).node,\n  trailingIcon: (prop_types_default()).node,\n  raised: (prop_types_default()).bool,\n  unelevated: (prop_types_default()).bool,\n  outlined: (prop_types_default()).bool,\n  touch: (prop_types_default()).bool\n};\n/* harmony default export */ const button_Button = (Button);\n;// CONCATENATED MODULE: ./src/button/index.js\n\n;// CONCATENATED MODULE: ./src/card/constants.js\nvar card_constants_cssClasses = {\n  ROOT: \'mdc-card\',\n  OUTLINED: \'mdc-card--outlined\',\n  TITLE: \'mdc-card__title\',\n  SUBTITLE: \'mdc-card__subtitle\',\n  OVERLINE: \'mdc-card__overline\',\n  ACTIONS: \'mdc-card__actions\',\n  ACTIONS_FULL_BLEED: \'mdc-card__actions--full-bleed\',\n  ACTION_BUTTONS: \'mdc-card__action-buttons\',\n  ACTION_ICONS: \'mdc-card__action-icons\',\n  ACTION: \'mdc-card__action\',\n  ACTION_BUTTON: \'mdc-card__action--button\',\n  ACTION_ICON: \'mdc-card__action--icon\',\n  CONTENT: \'mdc-card__content\',\n  HEADER: \'mdc-card__header\',\n  HEADER_GRAPHIC: \'mdc-card__header__graphic\',\n  HEADER_CONTENT: \'mdc-card__header__content\',\n  HEADER_ACTIONS: \'mdc-card__header__actions\',\n  MEDIA: \'mdc-card__media\',\n  MEDIA_SQUARE: \'mdc-card__media--square\',\n  MEDIA_WIDE: \'mdc-card__media--16-9\',\n  MEDIA_CONTENT: \'mdc-card__media-content\',\n  PRIMARY_ACTION: \'mdc-card__primary-action\',\n  SECTION: \'mdc-card__section\',\n  SECTION_PRIMARY: \'mdc-card__section--primary\',\n  SECTION_SECONDARY: \'mdc-card__section--secondary\',\n  RIPPLE: \'mdc-card__ripple\'\n};\n;// CONCATENATED MODULE: ./src/card/Card.jsx\nvar Card_excluded = ["outlined", "element", "component", "className"];\n\nfunction Card_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction Card_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { Card_ownKeys(Object(source), true).forEach(function (key) { Card_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { Card_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction Card_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction Card_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = Card_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction Card_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\n\nvar Card = /*#__PURE__*/(0,react.forwardRef)(function (_ref, ref) {\n  var _ref$outlined = _ref.outlined,\n      outlined = _ref$outlined === void 0 ? false : _ref$outlined,\n      _ref$element = _ref.element,\n      element = _ref$element === void 0 ? \'div\' : _ref$element,\n      _ref$component = _ref.component,\n      Element = _ref$component === void 0 ? element : _ref$component,\n      className = _ref.className,\n      props = Card_objectWithoutProperties(_ref, Card_excluded);\n\n  var classNames = classnames_default()(card_constants_cssClasses.ROOT, Card_defineProperty({}, card_constants_cssClasses.OUTLINED, outlined), className);\n  return /*#__PURE__*/(0,jsx_runtime.jsx)(Element, Card_objectSpread({\n    ref: ref,\n    className: classNames\n  }, props));\n});\nCard.displayName = \'MDCCard\';\nCard.propTypes = {\n  outlined: (prop_types_default()).bool\n};\n/* harmony default export */ const card_Card = (Card);\n;// CONCATENATED MODULE: ./src/card/CardAction.jsx\nvar CardAction_excluded = ["button", "icon", "component", "className", "children"];\n\nfunction CardAction_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction CardAction_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { CardAction_ownKeys(Object(source), true).forEach(function (key) { CardAction_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { CardAction_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction CardAction_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction CardAction_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = CardAction_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction CardAction_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\n\nfunction CardAction(_ref) {\n  var _classnames;\n\n  var _ref$button = _ref.button,\n      button = _ref$button === void 0 ? false : _ref$button,\n      _ref$icon = _ref.icon,\n      icon = _ref$icon === void 0 ? false : _ref$icon,\n      component = _ref.component,\n      className = _ref.className,\n      _ref$children = _ref.children,\n      children = _ref$children === void 0 ? component : _ref$children,\n      props = CardAction_objectWithoutProperties(_ref, CardAction_excluded);\n\n  var classNames = classnames_default()(card_constants_cssClasses.ACTION, (_classnames = {}, CardAction_defineProperty(_classnames, card_constants_cssClasses.ACTION_BUTTON, button), CardAction_defineProperty(_classnames, card_constants_cssClasses.ACTION_ICON, icon), _classnames), className);\n  return /*#__PURE__*/(0,jsx_runtime.jsx)(Clone, CardAction_objectSpread({\n    component: children,\n    className: classNames\n  }, props));\n}\nCardAction.displayName = \'MDCCardAction\';\nCardAction.propTypes = {\n  button: (prop_types_default()).bool,\n  icon: (prop_types_default()).bool\n};\n;// CONCATENATED MODULE: ./src/card/CardActions.jsx\nvar CardActions_excluded = ["fullBleed", "element", "className"];\n\nfunction CardActions_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction CardActions_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { CardActions_ownKeys(Object(source), true).forEach(function (key) { CardActions_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { CardActions_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction CardActions_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction CardActions_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = CardActions_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction CardActions_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\n\nvar CardActions = /*#__PURE__*/(0,react.forwardRef)(function (_ref, ref) {\n  var _ref$fullBleed = _ref.fullBleed,\n      fullBleed = _ref$fullBleed === void 0 ? false : _ref$fullBleed,\n      _ref$element = _ref.element,\n      Element = _ref$element === void 0 ? \'div\' : _ref$element,\n      className = _ref.className,\n      props = CardActions_objectWithoutProperties(_ref, CardActions_excluded);\n\n  var classNames = classnames_default()(card_constants_cssClasses.ACTIONS, CardActions_defineProperty({}, card_constants_cssClasses.ACTIONS_FULL_BLEED, fullBleed), className);\n  return /*#__PURE__*/(0,jsx_runtime.jsx)(Element, CardActions_objectSpread({\n    ref: ref,\n    className: classNames\n  }, props));\n});\nCardActions.displayName = \'MDCCardActions\';\nCardActions.propTypes = {\n  fullBleed: (prop_types_default()).bool\n};\n/* harmony default export */ const card_CardActions = (CardActions);\n;// CONCATENATED MODULE: ./src/card/CardActionButtons.jsx\nvar CardActionButtons_excluded = ["element", "component", "className", "children"];\n\nfunction CardActionButtons_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction CardActionButtons_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { CardActionButtons_ownKeys(Object(source), true).forEach(function (key) { CardActionButtons_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { CardActionButtons_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction CardActionButtons_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction CardActionButtons_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = CardActionButtons_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction CardActionButtons_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\n\nvar CardActionButtons = /*#__PURE__*/(0,react.forwardRef)(function (_ref, ref) {\n  var _ref$element = _ref.element,\n      element = _ref$element === void 0 ? \'div\' : _ref$element,\n      _ref$component = _ref.component,\n      Element = _ref$component === void 0 ? element : _ref$component,\n      className = _ref.className,\n      children = _ref.children,\n      props = CardActionButtons_objectWithoutProperties(_ref, CardActionButtons_excluded);\n\n  var classNames = classnames_default()(card_constants_cssClasses.ACTION_BUTTONS, className);\n  return /*#__PURE__*/(0,jsx_runtime.jsx)(Element, CardActionButtons_objectSpread(CardActionButtons_objectSpread({\n    ref: ref,\n    className: classNames\n  }, props), {}, {\n    children: /*#__PURE__*/(0,jsx_runtime.jsx)(Clone, {\n      component: children,\n      className: "".concat(card_constants_cssClasses.ACTION, " ").concat(card_constants_cssClasses.ACTION_BUTTON)\n    })\n  }));\n});\nCardActionButtons.displayName = \'MDCCardActionButtons\';\n/* harmony default export */ const card_CardActionButtons = (CardActionButtons);\n;// CONCATENATED MODULE: ./src/card/CardActionIcons.jsx\nvar CardActionIcons_excluded = ["element", "component", "className", "children"];\n\nfunction CardActionIcons_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction CardActionIcons_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { CardActionIcons_ownKeys(Object(source), true).forEach(function (key) { CardActionIcons_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { CardActionIcons_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction CardActionIcons_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction CardActionIcons_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = CardActionIcons_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction CardActionIcons_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\n\nvar CardActionIcons = /*#__PURE__*/(0,react.forwardRef)(function (_ref, ref) {\n  var _ref$element = _ref.element,\n      element = _ref$element === void 0 ? \'div\' : _ref$element,\n      _ref$component = _ref.component,\n      Element = _ref$component === void 0 ? element : _ref$component,\n      className = _ref.className,\n      children = _ref.children,\n      props = CardActionIcons_objectWithoutProperties(_ref, CardActionIcons_excluded);\n\n  var classNames = classnames_default()(card_constants_cssClasses.ACTION_ICONS, className);\n  return /*#__PURE__*/(0,jsx_runtime.jsx)(Element, CardActionIcons_objectSpread(CardActionIcons_objectSpread({\n    ref: ref,\n    className: classNames\n  }, props), {}, {\n    children: /*#__PURE__*/(0,jsx_runtime.jsx)(Clone, {\n      component: children,\n      className: "".concat(card_constants_cssClasses.ACTION, " ").concat(card_constants_cssClasses.ACTION_ICON)\n    })\n  }));\n});\nCardActionIcons.displayName = \'MDCCardActionIcons\';\n/* harmony default export */ const card_CardActionIcons = (CardActionIcons);\n;// CONCATENATED MODULE: ./src/card/CardHeader.jsx\nvar CardHeader_excluded = ["title", "subtitle", "overline", "graphic", "actions", "element", "component", "className", "children"];\n\nfunction CardHeader_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction CardHeader_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { CardHeader_ownKeys(Object(source), true).forEach(function (key) { CardHeader_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { CardHeader_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction CardHeader_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction CardHeader_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = CardHeader_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction CardHeader_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\n\n\n\nvar CardHeader = /*#__PURE__*/(0,react.forwardRef)(function (_ref, ref) {\n  var title = _ref.title,\n      subtitle = _ref.subtitle,\n      overline = _ref.overline,\n      graphic = _ref.graphic,\n      actions = _ref.actions,\n      _ref$element = _ref.element,\n      element = _ref$element === void 0 ? \'div\' : _ref$element,\n      _ref$component = _ref.component,\n      Element = _ref$component === void 0 ? element : _ref$component,\n      className = _ref.className,\n      children = _ref.children,\n      props = CardHeader_objectWithoutProperties(_ref, CardHeader_excluded);\n\n  var classNames = classnames_default()(card_constants_cssClasses.HEADER, className);\n  return /*#__PURE__*/(0,jsx_runtime.jsxs)(Element, CardHeader_objectSpread(CardHeader_objectSpread({\n    ref: ref,\n    className: classNames\n  }, props), {}, {\n    children: [graphic && /*#__PURE__*/(0,jsx_runtime.jsx)(Clone, {\n      component: graphic,\n      className: card_constants_cssClasses.HEADER_GRAPHIC\n    }), /*#__PURE__*/(0,jsx_runtime.jsxs)("div", {\n      className: card_constants_cssClasses.HEADER_CONTENT,\n      children: [overline && /*#__PURE__*/(0,jsx_runtime.jsx)(Clone, {\n        component: overline,\n        fallback: "span",\n        className: card_constants_cssClasses.OVERLINE\n      }), title && /*#__PURE__*/(0,jsx_runtime.jsx)(Clone, {\n        component: title,\n        fallback: "h2",\n        className: card_constants_cssClasses.TITLE\n      }), subtitle && /*#__PURE__*/(0,jsx_runtime.jsx)(Clone, {\n        component: subtitle,\n        fallback: "h3",\n        className: card_constants_cssClasses.SUBTITLE\n      }), children]\n    }), actions && /*#__PURE__*/(0,jsx_runtime.jsx)("div", {\n      className: card_constants_cssClasses.HEADER_ACTIONS,\n      children: react.Children.map(actions, function (action) {\n        return /*#__PURE__*/(0,jsx_runtime.jsx)(Clone, {\n          component: action,\n          className: card_constants_cssClasses.ACTION\n        });\n      })\n    })]\n  }));\n});\nCardHeader.displayName = \'MDCCardHeader\';\nCardHeader.propTypes = {\n  title: (prop_types_default()).node,\n  subtitle: (prop_types_default()).node,\n  overline: (prop_types_default()).node,\n  graphic: (prop_types_default()).element,\n  actions: prop_types_default().oneOfType([(prop_types_default()).element, prop_types_default().arrayOf((prop_types_default()).element)])\n};\n/* harmony default export */ const card_CardHeader = (CardHeader);\n;// CONCATENATED MODULE: ./src/card/CardMedia.jsx\nvar CardMedia_excluded = ["imageUrl", "content", "square", "wide", "element", "component", "className", "children"];\n\nfunction CardMedia_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction CardMedia_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { CardMedia_ownKeys(Object(source), true).forEach(function (key) { CardMedia_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { CardMedia_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction CardMedia_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction CardMedia_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = CardMedia_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction CardMedia_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\n\nvar CardMedia = /*#__PURE__*/(0,react.forwardRef)(function (_ref, ref) {\n  var _classnames;\n\n  var imageUrl = _ref.imageUrl,\n      content = _ref.content,\n      _ref$square = _ref.square,\n      square = _ref$square === void 0 ? false : _ref$square,\n      _ref$wide = _ref.wide,\n      wide = _ref$wide === void 0 ? false : _ref$wide,\n      _ref$element = _ref.element,\n      element = _ref$element === void 0 ? \'div\' : _ref$element,\n      _ref$component = _ref.component,\n      Element = _ref$component === void 0 ? element : _ref$component,\n      className = _ref.className,\n      _ref$children = _ref.children,\n      children = _ref$children === void 0 ? content : _ref$children,\n      props = CardMedia_objectWithoutProperties(_ref, CardMedia_excluded);\n\n  var classNames = classnames_default()(card_constants_cssClasses.MEDIA, (_classnames = {}, CardMedia_defineProperty(_classnames, card_constants_cssClasses.MEDIA_SQUARE, square), CardMedia_defineProperty(_classnames, card_constants_cssClasses.MEDIA_WIDE, wide), _classnames), className);\n  var style = imageUrl ? {\n    backgroundImage: "url(".concat(imageUrl, ")")\n  } : undefined;\n  return /*#__PURE__*/(0,jsx_runtime.jsx)(Element, CardMedia_objectSpread(CardMedia_objectSpread({\n    ref: ref,\n    className: classNames,\n    style: style\n  }, props), {}, {\n    children: children && /*#__PURE__*/(0,jsx_runtime.jsx)("div", {\n      className: card_constants_cssClasses.MEDIA_CONTENT,\n      children: children\n    })\n  }));\n});\nCardMedia.displayName = \'MDCCardMedia\';\nCardMedia.propTypes = {\n  imageUrl: (prop_types_default()).string,\n  content: (prop_types_default()).node,\n  square: (prop_types_default()).bool,\n  wide: (prop_types_default()).bool\n};\n/* harmony default export */ const card_CardMedia = (CardMedia);\n;// CONCATENATED MODULE: ./src/card/CardPrimaryAction.jsx\nvar CardPrimaryAction_excluded = ["element", "component", "className", "children"];\n\nfunction CardPrimaryAction_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction CardPrimaryAction_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { CardPrimaryAction_ownKeys(Object(source), true).forEach(function (key) { CardPrimaryAction_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { CardPrimaryAction_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction CardPrimaryAction_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction CardPrimaryAction_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = CardPrimaryAction_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction CardPrimaryAction_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\n\nvar CardPrimaryAction = /*#__PURE__*/(0,react.forwardRef)(function (_ref, ref) {\n  var _ref$element = _ref.element,\n      element = _ref$element === void 0 ? \'div\' : _ref$element,\n      _ref$component = _ref.component,\n      Element = _ref$component === void 0 ? element : _ref$component,\n      className = _ref.className,\n      children = _ref.children,\n      props = CardPrimaryAction_objectWithoutProperties(_ref, CardPrimaryAction_excluded);\n\n  var classNames = classnames_default()(card_constants_cssClasses.PRIMARY_ACTION, className);\n  return /*#__PURE__*/(0,jsx_runtime.jsxs)(Element, CardPrimaryAction_objectSpread(CardPrimaryAction_objectSpread({\n    ref: ref,\n    className: classNames,\n    tabIndex: "0"\n  }, props), {}, {\n    children: [children, /*#__PURE__*/(0,jsx_runtime.jsx)("div", {\n      className: card_constants_cssClasses.RIPPLE\n    })]\n  }));\n});\nCardPrimaryAction.displayName = \'MDCCardPrimaryAction\';\n/* harmony default export */ const card_CardPrimaryAction = (CardPrimaryAction);\n;// CONCATENATED MODULE: ./src/card/CardSection.jsx\nvar CardSection_excluded = ["primary", "secondary", "element", "component", "className"];\n\nfunction CardSection_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction CardSection_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { CardSection_ownKeys(Object(source), true).forEach(function (key) { CardSection_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { CardSection_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction CardSection_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction CardSection_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = CardSection_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction CardSection_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\n\nvar CardSection = /*#__PURE__*/(0,react.forwardRef)(function (_ref, ref) {\n  var _classnames;\n\n  var _ref$primary = _ref.primary,\n      primary = _ref$primary === void 0 ? false : _ref$primary,\n      _ref$secondary = _ref.secondary,\n      secondary = _ref$secondary === void 0 ? false : _ref$secondary,\n      _ref$element = _ref.element,\n      element = _ref$element === void 0 ? \'div\' : _ref$element,\n      _ref$component = _ref.component,\n      Element = _ref$component === void 0 ? element : _ref$component,\n      className = _ref.className,\n      props = CardSection_objectWithoutProperties(_ref, CardSection_excluded);\n\n  var classNames = classnames_default()(card_constants_cssClasses.SECTION, (_classnames = {}, CardSection_defineProperty(_classnames, card_constants_cssClasses.SECTION_PRIMARY, primary), CardSection_defineProperty(_classnames, card_constants_cssClasses.SECTION_SECONDARY, secondary), _classnames), className);\n  return /*#__PURE__*/(0,jsx_runtime.jsx)(Element, CardSection_objectSpread({\n    ref: ref,\n    className: classNames\n  }, props));\n});\nCardSection.displayName = \'MDCCardSection\';\nCardSection.propTypes = {\n  primary: (prop_types_default()).bool,\n  secondary: (prop_types_default()).bool\n};\n/* harmony default export */ const card_CardSection = (CardSection);\n;// CONCATENATED MODULE: ./src/card/index.js\n\n\n\n\n\n\n\n\n\ncard_Card.Action = CardAction;\ncard_Card.Actions = card_CardActions;\ncard_Card.ActionButtons = card_CardActionButtons;\ncard_Card.ActionIcons = card_CardActionIcons;\ncard_Card.Header = card_CardHeader;\ncard_Card.Media = card_CardMedia;\ncard_Card.PrimaryAction = card_CardPrimaryAction;\ncard_Card.Section = card_CardSection;\n\n;// CONCATENATED MODULE: ./src/checkbox/constants.js\nvar checkbox_constants_cssClasses = {\n  ROOT: \'mdc-checkbox\',\n  SELECTED: \'mdc-checkbox--selected\',\n  TOUCH: \'mdc-checkbox--touch\',\n  DISABLED: \'mdc-checkbox--disabled\',\n  ANIM_CHECKED_INDETERMINATE: \'mdc-checkbox--anim-checked-indeterminate\',\n  ANIM_CHECKED_UNCHECKED: \'mdc-checkbox--anim-checked-unchecked\',\n  ANIM_INDETERMINATE_CHECKED: \'mdc-checkbox--anim-indeterminate-checked\',\n  ANIM_INDETERMINATE_UNCHECKED: \'mdc-checkbox--anim-indeterminate-unchecked\',\n  ANIM_UNCHECKED_CHECKED: \'mdc-checkbox--anim-unchecked-checked\',\n  ANIM_UNCHECKED_INDETERMINATE: \'mdc-checkbox--anim-unchecked-indeterminate\',\n  NATIVE_CONTROL: \'mdc-checkbox__native-control\',\n  BACKGROUND: \'mdc-checkbox__background\',\n  CHECKMARK: \'mdc-checkbox__checkmark\',\n  CHECKMARK_PATH: \'mdc-checkbox__checkmark-path\',\n  MIXEDMARK: \'mdc-checkbox__mixedmark\',\n  RIPPLE: \'mdc-checkbox__ripple\'\n};\n;// CONCATENATED MODULE: ./src/checkbox/Checkbox.jsx\nvar Checkbox_excluded = ["checked", "indeterminate", "disabled", "touch", "onChange", "className"];\n\nfunction Checkbox_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction Checkbox_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { Checkbox_ownKeys(Object(source), true).forEach(function (key) { Checkbox_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { Checkbox_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction Checkbox_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction Checkbox_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = Checkbox_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction Checkbox_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\n\n\nvar Checkbox = /*#__PURE__*/(0,react.forwardRef)(function (_ref, ref) {\n  var _classnames;\n\n  var checked = _ref.checked,\n      indeterminate = _ref.indeterminate,\n      _ref$disabled = _ref.disabled,\n      disabled = _ref$disabled === void 0 ? false : _ref$disabled,\n      _ref$touch = _ref.touch,\n      touch = _ref$touch === void 0 ? false : _ref$touch,\n      _ref$onChange = _ref.onChange,\n      onChange = _ref$onChange === void 0 ? Function.prototype : _ref$onChange,\n      className = _ref.className,\n      props = Checkbox_objectWithoutProperties(_ref, Checkbox_excluded);\n\n  var inputRef = (0,react.useRef)();\n  (0,react.useEffect)(function () {\n    inputRef.current.indeterminate = indeterminate;\n  }, [indeterminate]);\n  var handleChange = (0,react.useCallback)(function (event) {\n    onChange(event, event.target.checked, event.target);\n  }, [onChange]);\n  var classNames = classnames_default()(checkbox_constants_cssClasses.ROOT, (_classnames = {}, Checkbox_defineProperty(_classnames, checkbox_constants_cssClasses.SELECTED, checked), Checkbox_defineProperty(_classnames, checkbox_constants_cssClasses.DISABLED, disabled), Checkbox_defineProperty(_classnames, checkbox_constants_cssClasses.TOUCH, touch), _classnames), className);\n  return /*#__PURE__*/(0,jsx_runtime.jsxs)("div", {\n    ref: ref,\n    className: classNames,\n    children: [/*#__PURE__*/(0,jsx_runtime.jsx)("input", Checkbox_objectSpread({\n      ref: inputRef,\n      className: checkbox_constants_cssClasses.NATIVE_CONTROL,\n      type: "checkbox",\n      checked: checked,\n      disabled: disabled,\n      onChange: handleChange\n    }, props)), /*#__PURE__*/(0,jsx_runtime.jsxs)("div", {\n      className: checkbox_constants_cssClasses.BACKGROUND,\n      children: [/*#__PURE__*/(0,jsx_runtime.jsx)("svg", {\n        className: checkbox_constants_cssClasses.CHECKMARK,\n        viewBox: "0 0 24 24",\n        children: /*#__PURE__*/(0,jsx_runtime.jsx)("path", {\n          className: checkbox_constants_cssClasses.CHECKMARK_PATH,\n          fill: "none",\n          d: "M1.73,12.91 8.1,19.28 22.79,4.59"\n        })\n      }), /*#__PURE__*/(0,jsx_runtime.jsx)("div", {\n        className: checkbox_constants_cssClasses.MIXEDMARK\n      })]\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)("div", {\n      className: checkbox_constants_cssClasses.RIPPLE\n    })]\n  });\n});\nCheckbox.displayName = \'MDCCheckbox\';\nCheckbox.propTypes = {\n  checked: (prop_types_default()).bool,\n  indeterminate: (prop_types_default()).bool,\n  disabled: (prop_types_default()).bool,\n  touch: (prop_types_default()).bool,\n  onChange: (prop_types_default()).func\n};\n/* harmony default export */ const checkbox_Checkbox = (Checkbox);\n;// CONCATENATED MODULE: ./src/checkbox/index.js\n\n;// CONCATENATED MODULE: ./src/chips/constants.js\nvar constants_numbers = {\n  SELECTING_ANIMATION_MS: 150,\n  DESELECTING_ANIMATION_MS: 100\n};\nvar chipSetCssClasses = {\n  ROOT: \'mdc-evolution-chip-set\',\n  OVERFLOW: \'mdc-evolution-chip-set--overflow\',\n  CHIPS: \'mdc-evolution-chip-set__chips\'\n};\nvar chipCssClasses = {\n  ROOT: \'mdc-evolution-chip\',\n  FILTER: \'mdc-evolution-chip--filter\',\n  SELECTABLE: \'mdc-evolution-chip--selectable\',\n  SELECTED: \'mdc-evolution-chip--selected\',\n  SELECTING: \'mdc-evolution-chip--selecting\',\n  SELECTING_WITH_PRIMARY_ICON: \'mdc-evolution-chip--selecting-with-primary-icon\',\n  DESELECTING: \'mdc-evolution-chip--deselecting\',\n  DESELECTING_WITH_PRIMARY_ICON: \'mdc-evolution-chip--deselecting-with-primary-icon\',\n  OUTLINED: \'mdc-evolution-chip--outlined\',\n  ENTER: \'mdc-evolution-chip--enter\',\n  EXIT: \'mdc-evolution-chip--exit\',\n  HIDDEN: \'mdc-evolution-chip--hidden\',\n  DISABLED: \'mdc-evolution-chip--disabled\',\n  TOUCH: \'mdc-evolution-chip--touch\',\n  WITH_PRIMARY_GRAPHIC: \'mdc-evolution-chip--with-primary-graphic\',\n  WITH_PRIMARY_ICON: \'mdc-evolution-chip--with-primary-icon\',\n  WITH_TRAILING_ACTION: \'mdc-evolution-chip--with-trailing-action\',\n  WITH_AVATAR: \'mdc-evolution-chip--with-avatar\',\n  CELL: \'mdc-evolution-chip__cell\',\n  PRIMARY_CELL: \'mdc-evolution-chip__cell--primary\',\n  TRAILING_CELL: \'mdc-evolution-chip__cell--trailing\',\n  ACTION: \'mdc-evolution-chip__action\',\n  PRIMARY_ACTION: \'mdc-evolution-chip__action--primary\',\n  TRAILING_ACTION: \'mdc-evolution-chip__action--trailing\',\n  PRESENTATIONAL_ACTION: \'mdc-evolution-chip__action--presentational\',\n  ACTION_TOUCH: \'mdc-evolution-chip__action-touch\',\n  RIPPLE: \'mdc-evolution-chip__ripple\',\n  PRIMARY_RIPPLE: \'mdc-evolution-chip__ripple--primary\',\n  TRAILING_RIPPLE: \'mdc-evolution-chip__ripple--trailing\',\n  GRAPHIC: \'mdc-evolution-chip__graphic\',\n  ICON: \'mdc-evolution-chip__icon\',\n  PRIMARY_ICON: \'mdc-evolution-chip__icon--primary\',\n  TRAILING_ICON: \'mdc-evolution-chip__icon--trailing\',\n  TEXT_LABEL: \'mdc-evolution-chip__text-label\',\n  CHECKMARK: \'mdc-evolution-chip__checkmark\',\n  CHECKMARK_SVG: \'mdc-evolution-chip__checkmark-svg\',\n  CHECKMARK_PATH: \'mdc-evolution-chip__checkmark-path\'\n};\n;// CONCATENATED MODULE: ./src/chips/ChipPrimaryAction.jsx\nvar ChipPrimaryAction_excluded = ["text", "graphic", "icon", "presentational", "selectable", "selected", "disabled", "element", "component", "children"];\n\nfunction ChipPrimaryAction_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction ChipPrimaryAction_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ChipPrimaryAction_ownKeys(Object(source), true).forEach(function (key) { ChipPrimaryAction_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ChipPrimaryAction_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction ChipPrimaryAction_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction ChipPrimaryAction_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = ChipPrimaryAction_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction ChipPrimaryAction_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\n\n\nfunction ChipPrimaryAction(_ref) {\n  var text = _ref.text,\n      graphic = _ref.graphic,\n      icon = _ref.icon,\n      _ref$presentational = _ref.presentational,\n      presentational = _ref$presentational === void 0 ? false : _ref$presentational,\n      _ref$selectable = _ref.selectable,\n      selectable = _ref$selectable === void 0 ? false : _ref$selectable,\n      _ref$selected = _ref.selected,\n      selected = _ref$selected === void 0 ? false : _ref$selected,\n      _ref$disabled = _ref.disabled,\n      disabled = _ref$disabled === void 0 ? false : _ref$disabled,\n      _ref$element = _ref.element,\n      element = _ref$element === void 0 ? \'button\' : _ref$element,\n      _ref$component = _ref.component,\n      Element = _ref$component === void 0 ? element : _ref$component,\n      _ref$children = _ref.children,\n      children = _ref$children === void 0 ? text : _ref$children,\n      props = ChipPrimaryAction_objectWithoutProperties(_ref, ChipPrimaryAction_excluded);\n\n  var isButton = Element === \'button\';\n  var classNames = classnames_default()(chipCssClasses.ACTION, chipCssClasses.PRIMARY_ACTION, ChipPrimaryAction_defineProperty({}, chipCssClasses.PRESENTATIONAL_ACTION, presentational));\n  return /*#__PURE__*/(0,jsx_runtime.jsxs)(Element, ChipPrimaryAction_objectSpread(ChipPrimaryAction_objectSpread({\n    className: classNames,\n    type: isButton ? \'button\' : undefined,\n    disabled: isButton && disabled,\n    tabIndex: disabled ? \'-1\' : \'0\',\n    role: !isButton ? \'option\' : undefined,\n    "aria-selected": !isButton ? selected : undefined,\n    "aria-disabled": !isButton ? disabled : undefined\n  }, props), {}, {\n    children: [/*#__PURE__*/(0,jsx_runtime.jsx)("span", {\n      className: "".concat(chipCssClasses.RIPPLE, " ").concat(chipCssClasses.PRIMARY_RIPPLE)\n    }), (graphic || icon || selectable) && /*#__PURE__*/(0,jsx_runtime.jsxs)("span", {\n      className: chipCssClasses.GRAPHIC,\n      children: [graphic, icon && /*#__PURE__*/(0,jsx_runtime.jsx)(Clone, {\n        component: icon,\n        fallback: icon_Icon,\n        className: "".concat(chipCssClasses.ICON, " ").concat(chipCssClasses.PRIMARY_ICON)\n      }), selectable && /*#__PURE__*/(0,jsx_runtime.jsx)("span", {\n        className: chipCssClasses.CHECKMARK,\n        children: /*#__PURE__*/(0,jsx_runtime.jsx)("svg", {\n          className: chipCssClasses.CHECKMARK_SVG,\n          viewBox: "-2 -3 30 30",\n          children: /*#__PURE__*/(0,jsx_runtime.jsx)("path", {\n            className: chipCssClasses.CHECKMARK_PATH,\n            fill: "none",\n            stroke: "black",\n            d: "M1.73,12.91 8.1,19.28 22.79,4.59"\n          })\n        })\n      })]\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)("span", {\n      className: chipCssClasses.TEXT_LABEL,\n      children: children\n    })]\n  }));\n}\n;// CONCATENATED MODULE: ./src/chips/ChipTrailingAction.jsx\nvar ChipTrailingAction_excluded = ["icon", "presentational"];\n\nfunction ChipTrailingAction_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction ChipTrailingAction_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ChipTrailingAction_ownKeys(Object(source), true).forEach(function (key) { ChipTrailingAction_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ChipTrailingAction_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction ChipTrailingAction_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction ChipTrailingAction_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = ChipTrailingAction_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction ChipTrailingAction_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\n\n\nfunction ChipTrailingAction(_ref) {\n  var icon = _ref.icon,\n      _ref$presentational = _ref.presentational,\n      presentational = _ref$presentational === void 0 ? false : _ref$presentational,\n      props = ChipTrailingAction_objectWithoutProperties(_ref, ChipTrailingAction_excluded);\n\n  var classNames = classnames_default()(chipCssClasses.ACTION, chipCssClasses.TRAILING_ACTION, ChipTrailingAction_defineProperty({}, chipCssClasses.PRESENTATIONAL_ACTION, presentational));\n  return /*#__PURE__*/(0,jsx_runtime.jsxs)("button", ChipTrailingAction_objectSpread(ChipTrailingAction_objectSpread({\n    className: classNames,\n    type: "button",\n    tabIndex: "-1",\n    "aria-hidden": "true"\n  }, props), {}, {\n    children: [/*#__PURE__*/(0,jsx_runtime.jsx)("span", {\n      className: "".concat(chipCssClasses.RIPPLE, " ").concat(chipCssClasses.TRAILING_RIPPLE)\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Clone, {\n      component: icon,\n      fallback: icon_Icon,\n      className: "".concat(chipCssClasses.ICON, " ").concat(chipCssClasses.TRAILING_ICON)\n    })]\n  }));\n}\n;// CONCATENATED MODULE: ./src/chips/Chip.jsx\nvar Chip_excluded = ["value", "text", "icon", "avatar", "graphic", "primaryIcon", "trailingIcon", "selectable", "filter", "selected", "outlined", "disabled", "touch", "withAvatar", "element", "component", "className"];\n\nfunction Chip_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction Chip_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { Chip_ownKeys(Object(source), true).forEach(function (key) { Chip_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { Chip_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction Chip_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction Chip_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = Chip_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction Chip_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\n\n\n\n\n\n\nvar Chip = /*#__PURE__*/(0,react.forwardRef)(function (_ref, ref) {\n  var _classnames;\n\n  var value = _ref.value,\n      text = _ref.text,\n      icon = _ref.icon,\n      avatar = _ref.avatar,\n      _ref$graphic = _ref.graphic,\n      graphic = _ref$graphic === void 0 ? avatar : _ref$graphic,\n      _ref$primaryIcon = _ref.primaryIcon,\n      primaryIcon = _ref$primaryIcon === void 0 ? icon : _ref$primaryIcon,\n      trailingIcon = _ref.trailingIcon,\n      _ref$selectable = _ref.selectable,\n      selectable = _ref$selectable === void 0 ? false : _ref$selectable,\n      _ref$filter = _ref.filter,\n      filter = _ref$filter === void 0 ? false : _ref$filter,\n      _ref$selected = _ref.selected,\n      selected = _ref$selected === void 0 ? false : _ref$selected,\n      _ref$outlined = _ref.outlined,\n      outlined = _ref$outlined === void 0 ? false : _ref$outlined,\n      _ref$disabled = _ref.disabled,\n      disabled = _ref$disabled === void 0 ? false : _ref$disabled,\n      _ref$touch = _ref.touch,\n      touch = _ref$touch === void 0 ? false : _ref$touch,\n      _ref$withAvatar = _ref.withAvatar,\n      withAvatar = _ref$withAvatar === void 0 ? Boolean(avatar) : _ref$withAvatar,\n      _ref$element = _ref.element,\n      element = _ref$element === void 0 ? \'span\' : _ref$element,\n      _ref$component = _ref.component,\n      Element = _ref$component === void 0 ? element : _ref$component,\n      className = _ref.className,\n      props = Chip_objectWithoutProperties(_ref, Chip_excluded);\n\n  var withPrimaryGraphic = selectable || Boolean(graphic) || Boolean(primaryIcon);\n  var withPrimaryIcon = Boolean(primaryIcon);\n  var withTrailingAction = Boolean(trailingIcon);\n  var classNames = classnames_default()(chipCssClasses.ROOT, (_classnames = {}, Chip_defineProperty(_classnames, chipCssClasses.SELECTABLE, selectable), Chip_defineProperty(_classnames, chipCssClasses.FILTER, filter), Chip_defineProperty(_classnames, chipCssClasses.OUTLINED, outlined), Chip_defineProperty(_classnames, chipCssClasses.DISABLED, disabled), Chip_defineProperty(_classnames, chipCssClasses.TOUCH, touch), Chip_defineProperty(_classnames, chipCssClasses.WITH_PRIMARY_GRAPHIC, withPrimaryGraphic), Chip_defineProperty(_classnames, chipCssClasses.WITH_PRIMARY_ICON, withPrimaryIcon), Chip_defineProperty(_classnames, chipCssClasses.WITH_TRAILING_ACTION, withTrailingAction), Chip_defineProperty(_classnames, chipCssClasses.WITH_AVATAR, withAvatar), _classnames), className);\n  var selectingClass = withPrimaryIcon ? chipCssClasses.SELECTING_WITH_PRIMARY_ICON : chipCssClasses.SELECTING;\n  var deselectingClass = withPrimaryIcon ? chipCssClasses.DESELECTING_WITH_PRIMARY_ICON : chipCssClasses.DESELECTING;\n  return /*#__PURE__*/(0,jsx_runtime.jsx)(esm_CSSTransition, {\n    "in": selected,\n    appear: true,\n    timeout: {\n      enter: constants_numbers.SELECTING_ANIMATION_MS,\n      exit: constants_numbers.DESELECTING_ANIMATION_MS\n    },\n    classNames: {\n      enter: selectingClass,\n      enterActive: "".concat(chipCssClasses.SELECTED, " ").concat(selectingClass),\n      enterDone: chipCssClasses.SELECTED,\n      exit: deselectingClass,\n      exitActive: deselectingClass\n    },\n    children: /*#__PURE__*/(0,jsx_runtime.jsx)(Element, Chip_objectSpread(Chip_objectSpread({\n      ref: ref,\n      className: classNames,\n      "data-value": value,\n      role: selectable ? \'presentation\' : \'row\'\n    }, props), {}, {\n      children: selectable ? /*#__PURE__*/(0,jsx_runtime.jsx)(ChipPrimaryAction, {\n        element: "span",\n        text: text,\n        graphic: graphic,\n        icon: primaryIcon,\n        selectable: selectable,\n        selected: selected,\n        disabled: disabled\n      }) : /*#__PURE__*/(0,jsx_runtime.jsxs)(jsx_runtime.Fragment, {\n        children: [/*#__PURE__*/(0,jsx_runtime.jsx)("span", {\n          className: "".concat(chipCssClasses.CELL, " ").concat(chipCssClasses.PRIMARY_CELL),\n          role: "gridcell",\n          children: /*#__PURE__*/(0,jsx_runtime.jsx)(ChipPrimaryAction, {\n            text: text,\n            graphic: graphic,\n            icon: primaryIcon,\n            disabled: disabled\n          })\n        }), trailingIcon && /*#__PURE__*/(0,jsx_runtime.jsx)("span", {\n          className: "".concat(chipCssClasses.CELL, " ").concat(chipCssClasses.TRAILING_CELL),\n          role: "gridcell",\n          children: /*#__PURE__*/(0,jsx_runtime.jsx)(ChipTrailingAction, {\n            icon: trailingIcon,\n            disabled: disabled\n          })\n        })]\n      })\n    }))\n  });\n});\nChip.displayName = \'MDCChip\';\nChip.propTypes = {\n  value: (prop_types_default()).any,\n  text: (prop_types_default()).node,\n  leadingIcon: (prop_types_default()).node,\n  trailingIcon: (prop_types_default()).node,\n  selected: (prop_types_default()).bool,\n  outlined: (prop_types_default()).bool,\n  onClick: (prop_types_default()).func\n};\n/* harmony default export */ const chips_Chip = (Chip);\n;// CONCATENATED MODULE: ./src/types.js\nfunction _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }\n\nfunction isUndefined(value) {\n  return value === undefined;\n}\nfunction isNull(value) {\n  return value === null;\n}\nfunction isBoolean(value) {\n  return typeof value === \'boolean\';\n}\nfunction isNumber(value) {\n  return typeof value === \'number\';\n}\nfunction isString(value) {\n  return typeof value === \'string\';\n}\nfunction isArray(value) {\n  return Array.isArray(value);\n}\nfunction isObject(value) {\n  return _typeof(value) === \'object\' && !isNull(value) && !isArray(value);\n}\n;// CONCATENATED MODULE: ./src/chips/ChipSet.jsx\nvar ChipSet_excluded = ["value", "chips", "input", "choice", "filter", "overflow", "onChange", "element", "component", "className", "children"];\n\nfunction ChipSet_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction ChipSet_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ChipSet_ownKeys(Object(source), true).forEach(function (key) { ChipSet_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ChipSet_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction ChipSet_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction ChipSet_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = ChipSet_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction ChipSet_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\n\n\n\n\nvar ChipSet = /*#__PURE__*/(0,react.forwardRef)(function (_ref, ref) {\n  var value = _ref.value,\n      chips = _ref.chips,\n      _ref$input = _ref.input,\n      input = _ref$input === void 0 ? false : _ref$input,\n      _ref$choice = _ref.choice,\n      choice = _ref$choice === void 0 ? !input && !isUndefined(value) && !isArray(value) : _ref$choice,\n      _ref$filter = _ref.filter,\n      filter = _ref$filter === void 0 ? !input && !isUndefined(value) && isArray(value) : _ref$filter,\n      _ref$overflow = _ref.overflow,\n      overflow = _ref$overflow === void 0 ? false : _ref$overflow,\n      _ref$onChange = _ref.onChange,\n      onChange = _ref$onChange === void 0 ? Function.prototype : _ref$onChange,\n      _ref$element = _ref.element,\n      element = _ref$element === void 0 ? \'div\' : _ref$element,\n      _ref$component = _ref.component,\n      Element = _ref$component === void 0 ? element : _ref$component,\n      className = _ref.className,\n      _ref$children = _ref.children,\n      children = _ref$children === void 0 ? chips === null || chips === void 0 ? void 0 : chips.map(function (chip) {\n    return (0,react.createElement)(chips_Chip, chip);\n  }) : _ref$children,\n      props = ChipSet_objectWithoutProperties(_ref, ChipSet_excluded);\n\n  var handleClick = (0,react.useCallback)(function (event) {\n    var chipValue = event.currentTarget.dataset.value;\n    var newValue = choice ? chipValue : value.includes(chipValue) ? value.filter(function (v) {\n      return v !== chipValue;\n    }) : value.concat(chipValue);\n    onChange(newValue);\n  }, [value, choice, onChange]);\n  var classNames = classnames_default()(chipSetCssClasses.ROOT, ChipSet_defineProperty({}, chipSetCssClasses.OVERFLOW, overflow), className);\n  return /*#__PURE__*/(0,jsx_runtime.jsx)(Element, ChipSet_objectSpread(ChipSet_objectSpread({\n    ref: ref,\n    className: classNames,\n    role: filter ? \'listbox\' : \'grid\'\n  }, props), {}, {\n    children: /*#__PURE__*/(0,jsx_runtime.jsx)("div", {\n      className: chipSetCssClasses.CHIPS,\n      role: "presentation",\n      children: isUndefined(value) ? children : react.Children.map(children, function (chip) {\n        var chipValue = chip.props.value;\n        return (0,react.cloneElement)(chip, {\n          selectable: true,\n          selected: choice ? value === chipValue : value.includes(chipValue),\n          onClickCapture: choice || filter ? handleClick : undefined\n        });\n      })\n    })\n  }));\n});\nChipSet.displayName = \'MDCChipSet\';\nChipSet.propTypes = {\n  value: (prop_types_default()).any,\n  input: (prop_types_default()).bool,\n  choice: (prop_types_default()).bool,\n  filter: (prop_types_default()).bool,\n  overflow: (prop_types_default()).bool,\n  onChange: (prop_types_default()).func\n};\n/* harmony default export */ const chips_ChipSet = (ChipSet);\n;// CONCATENATED MODULE: ./src/chips/index.js\n\n\n;// CONCATENATED MODULE: ./src/circular-progress/constants.js\nvar strings = {\n  XMLNS: \'http://www.w3.org/2000/svg\'\n};\nvar sizeProps = {\n  large: {\n    viewBox: 48,\n    radius: 18,\n    strokeWidth: 4,\n    gapPatchStrokeWidth: 3.2,\n    strokeDasharray: 113.097,\n    indeterminateStrokeDashoffset: 56.549\n  },\n  medium: {\n    viewBox: 32,\n    radius: 12.5,\n    strokeWidth: 3,\n    gapPatchStrokeWidth: 2.4,\n    strokeDasharray: 78.54,\n    indeterminateStrokeDashoffset: 39.27\n  },\n  small: {\n    viewBox: 24,\n    radius: 8.75,\n    strokeWidth: 2.5,\n    gapPatchStrokeWidth: 2,\n    strokeDasharray: 54.978,\n    indeterminateStrokeDashoffset: 27.489\n  }\n};\nvar circular_progress_constants_cssClasses = {\n  ROOT: \'mdc-circular-progress\',\n  SMALL: \'mdc-circular-progress--small\',\n  MEDIUM: \'mdc-circular-progress--medium\',\n  LARGE: \'mdc-circular-progress--large\',\n  INDETERMINATE: \'mdc-circular-progress--indeterminate\',\n  CLOSED: \'mdc-circular-progress--closed\',\n  DETERMINATE_CONTAINER: \'mdc-circular-progress__determinate-container\',\n  DETERMINATE_CIRCLE_GRAPHIC: \'mdc-circular-progress__determinate-circle-graphic\',\n  DETERMINATE_TRACK: \'mdc-circular-progress__determinate-track\',\n  DETERMINATE_CIRCLE: \'mdc-circular-progress__determinate-circle\',\n  INDETERMINATE_CONTAINER: \'mdc-circular-progress__indeterminate-container\',\n  INDETERMINATE_CIRCLE_GRAPHIC: \'mdc-circular-progress__indeterminate-circle-graphic\',\n  SPINNER_LAYER: \'mdc-circular-progress__spinner-layer\',\n  COLOR: \'mdc-circular-progress__color\',\n  CIRCLE_CLIPPER: \'mdc-circular-progress__circle-clipper\',\n  CIRCLE_LEFT: \'mdc-circular-progress__circle-left\',\n  CIRCLE_RIGHT: \'mdc-circular-progress__circle-right\',\n  GAP_PATCH: \'mdc-circular-progress__gap-patch\'\n};\nvar Size = {\n  LARGE: \'large\',\n  MEDIUM: \'medium\',\n  SMALL: \'small\'\n};\n;// CONCATENATED MODULE: ./src/circular-progress/CircularProgress.jsx\nvar CircularProgress_excluded = ["value", "size", "indeterminate", "closed", "colorful", "className"];\n\nfunction CircularProgress_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction CircularProgress_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { CircularProgress_ownKeys(Object(source), true).forEach(function (key) { CircularProgress_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { CircularProgress_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction CircularProgress_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction CircularProgress_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = CircularProgress_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction CircularProgress_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\n\n\nvar CircularProgress = /*#__PURE__*/(0,react.forwardRef)(function (_ref, ref) {\n  var _classnames;\n\n  var _ref$value = _ref.value,\n      value = _ref$value === void 0 ? 0 : _ref$value,\n      _ref$size = _ref.size,\n      size = _ref$size === void 0 ? Size.MEDIUM : _ref$size,\n      _ref$indeterminate = _ref.indeterminate,\n      indeterminate = _ref$indeterminate === void 0 ? false : _ref$indeterminate,\n      _ref$closed = _ref.closed,\n      closed = _ref$closed === void 0 ? false : _ref$closed,\n      _ref$colorful = _ref.colorful,\n      colorful = _ref$colorful === void 0 ? false : _ref$colorful,\n      className = _ref.className,\n      props = CircularProgress_objectWithoutProperties(_ref, CircularProgress_excluded);\n\n  var classNames = classnames_default()(circular_progress_constants_cssClasses.ROOT, (_classnames = {}, CircularProgress_defineProperty(_classnames, "".concat(circular_progress_constants_cssClasses.ROOT, "--").concat(size), size), CircularProgress_defineProperty(_classnames, circular_progress_constants_cssClasses.INDETERMINATE, indeterminate), CircularProgress_defineProperty(_classnames, circular_progress_constants_cssClasses.CLOSED, closed), _classnames), className);\n  var _sizeProps$size = sizeProps[size],\n      viewBox = _sizeProps$size.viewBox,\n      radius = _sizeProps$size.radius,\n      strokeDasharray = _sizeProps$size.strokeDasharray,\n      strokeWidth = _sizeProps$size.strokeWidth,\n      gapPatchStrokeWidth = _sizeProps$size.gapPatchStrokeWidth,\n      indeterminateStrokeDashoffset = _sizeProps$size.indeterminateStrokeDashoffset;\n  var progress = value > 1 ? value / 100 : Number(value);\n  var cx = viewBox / 2,\n      cy = viewBox / 2;\n  var strokeDashoffset = 2 * Math.PI * radius * (1 - progress);\n  return /*#__PURE__*/(0,jsx_runtime.jsxs)("div", CircularProgress_objectSpread(CircularProgress_objectSpread({\n    ref: ref,\n    className: classNames,\n    role: "progressbar",\n    "aria-valuemin": 0,\n    "aria-valuemax": 1,\n    "aria-valuenow": progress\n  }, props), {}, {\n    children: [!indeterminate && /*#__PURE__*/(0,jsx_runtime.jsx)("div", {\n      className: circular_progress_constants_cssClasses.DETERMINATE_CONTAINER,\n      children: /*#__PURE__*/(0,jsx_runtime.jsxs)("svg", {\n        className: circular_progress_constants_cssClasses.DETERMINATE_CIRCLE_GRAPHIC,\n        viewBox: "0 0 ".concat(viewBox, " ").concat(viewBox),\n        xmlns: strings.XMLNS,\n        children: [/*#__PURE__*/(0,jsx_runtime.jsx)("circle", {\n          className: circular_progress_constants_cssClasses.DETERMINATE_TRACK,\n          cx: cx,\n          cy: cy,\n          r: radius,\n          strokeWidth: strokeWidth\n        }), /*#__PURE__*/(0,jsx_runtime.jsx)("circle", {\n          className: circular_progress_constants_cssClasses.DETERMINATE_CIRCLE,\n          cx: cx,\n          cy: cy,\n          r: radius,\n          strokeWidth: strokeWidth,\n          strokeDasharray: strokeDasharray,\n          strokeDashoffset: strokeDashoffset\n        })]\n      })\n    }), indeterminate && /*#__PURE__*/(0,jsx_runtime.jsx)("div", {\n      className: circular_progress_constants_cssClasses.INDETERMINATE_CONTAINER,\n      children: (colorful ? [1, 2, 3, 4] : [0]).map(function (n) {\n        return /*#__PURE__*/(0,jsx_runtime.jsxs)("div", {\n          className: classnames_default()(circular_progress_constants_cssClasses.SPINNER_LAYER, CircularProgress_defineProperty({}, "".concat(circular_progress_constants_cssClasses.PROGRESS_COLOR, "-").concat(n), n)),\n          children: [/*#__PURE__*/(0,jsx_runtime.jsx)("div", {\n            className: "".concat(circular_progress_constants_cssClasses.CIRCLE_CLIPPER, " ").concat(circular_progress_constants_cssClasses.CIRCLE_LEFT),\n            children: /*#__PURE__*/(0,jsx_runtime.jsx)("svg", {\n              className: circular_progress_constants_cssClasses.INDETERMINATE_CIRCLE_GRAPHIC,\n              viewBox: "0 0 ".concat(viewBox, " ").concat(viewBox),\n              xmlns: strings.XMLNS,\n              children: /*#__PURE__*/(0,jsx_runtime.jsx)("circle", {\n                cx: cx,\n                cy: cy,\n                r: radius,\n                strokeWidth: strokeWidth,\n                strokeDasharray: strokeDasharray,\n                strokeDashoffset: indeterminateStrokeDashoffset\n              })\n            })\n          }), /*#__PURE__*/(0,jsx_runtime.jsx)("div", {\n            className: circular_progress_constants_cssClasses.GAP_PATCH,\n            children: /*#__PURE__*/(0,jsx_runtime.jsx)("svg", {\n              className: circular_progress_constants_cssClasses.INDETERMINATE_CIRCLE_GRAPHIC,\n              viewBox: "0 0 ".concat(viewBox, " ").concat(viewBox),\n              xmlns: strings.XMLNS,\n              children: /*#__PURE__*/(0,jsx_runtime.jsx)("circle", {\n                cx: cx,\n                cy: cy,\n                r: radius,\n                strokeWidth: gapPatchStrokeWidth,\n                strokeDasharray: strokeDasharray,\n                strokeDashoffset: indeterminateStrokeDashoffset\n              })\n            })\n          }), /*#__PURE__*/(0,jsx_runtime.jsx)("div", {\n            className: "".concat(circular_progress_constants_cssClasses.CIRCLE_CLIPPER, " ").concat(circular_progress_constants_cssClasses.CIRCLE_RIGHT),\n            children: /*#__PURE__*/(0,jsx_runtime.jsx)("svg", {\n              className: circular_progress_constants_cssClasses.INDETERMINATE_CIRCLE_GRAPHIC,\n              viewBox: "0 0 ".concat(viewBox, " ").concat(viewBox),\n              xmlns: strings.XMLNS,\n              children: /*#__PURE__*/(0,jsx_runtime.jsx)("circle", {\n                cx: cx,\n                cy: cy,\n                r: radius,\n                strokeWidth: strokeWidth,\n                strokeDasharray: strokeDasharray,\n                strokeDashoffset: indeterminateStrokeDashoffset\n              })\n            })\n          })]\n        }, n);\n      })\n    })]\n  }));\n});\nCircularProgress.displayName = \'MDCCircularProgress\';\nCircularProgress.propTypes = {\n  value: prop_types_default().oneOfType([(prop_types_default()).number, (prop_types_default()).string]),\n  size: prop_types_default().oneOf([strings.SMALL, strings.MEDIUM, strings.LARGE]),\n  indeterminate: (prop_types_default()).bool,\n  closed: (prop_types_default()).bool,\n  colorful: (prop_types_default()).bool\n};\nCircularProgress.Size = Size;\n/* harmony default export */ const circular_progress_CircularProgress = (CircularProgress);\n;// CONCATENATED MODULE: ./src/circular-progress/index.js\n\n;// CONCATENATED MODULE: ./src/icon-button/constants.js\nvar icon_button_constants_cssClasses = {\n  ROOT: \'mdc-icon-button\',\n  TOUCH: \'mdc-icon-button--touch\',\n  MATERIAL_ICONS: \'material-icons\',\n  ICON: \'mdc-icon-button__icon\',\n  RIPPLE: \'mdc-icon-button__ripple\',\n  TOUCH_ELEMENT: \'mdc-icon-button__touch\'\n};\n;// CONCATENATED MODULE: ./src/icon-button/IconButton.jsx\nvar IconButton_excluded = ["icon", "touch", "element", "component", "className", "children"];\n\nfunction IconButton_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction IconButton_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { IconButton_ownKeys(Object(source), true).forEach(function (key) { IconButton_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { IconButton_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction IconButton_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction IconButton_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = IconButton_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction IconButton_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\n\n\n\nvar IconButton = /*#__PURE__*/(0,react.forwardRef)(function (_ref, ref) {\n  var _classnames;\n\n  var icon = _ref.icon,\n      _ref$touch = _ref.touch,\n      touch = _ref$touch === void 0 ? false : _ref$touch,\n      _ref$element = _ref.element,\n      element = _ref$element === void 0 ? \'button\' : _ref$element,\n      _ref$component = _ref.component,\n      Element = _ref$component === void 0 ? element : _ref$component,\n      className = _ref.className,\n      _ref$children = _ref.children,\n      children = _ref$children === void 0 ? icon : _ref$children,\n      props = IconButton_objectWithoutProperties(_ref, IconButton_excluded);\n\n  var classNames = classnames_default()(icon_button_constants_cssClasses.ROOT, (_classnames = {}, IconButton_defineProperty(_classnames, icon_button_constants_cssClasses.MATERIAL_ICONS, typeof children === \'string\'), IconButton_defineProperty(_classnames, icon_button_constants_cssClasses.TOUCH, touch), _classnames), className);\n  return /*#__PURE__*/(0,jsx_runtime.jsxs)(Element, IconButton_objectSpread(IconButton_objectSpread({\n    ref: ref,\n    className: classNames\n  }, props), {}, {\n    children: [/*#__PURE__*/(0,jsx_runtime.jsx)("div", {\n      className: icon_button_constants_cssClasses.RIPPLE\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Clone, {\n      component: children,\n      className: icon_button_constants_cssClasses.ICON\n    }), touch && /*#__PURE__*/(0,jsx_runtime.jsx)("div", {\n      className: icon_button_constants_cssClasses.TOUCH_ELEMENT\n    })]\n  }));\n});\nIconButton.displayName = \'MDCIconButton\';\nIconButton.propTypes = {\n  icon: (prop_types_default()).node\n};\n/* harmony default export */ const icon_button_IconButton = (IconButton);\n;// CONCATENATED MODULE: ./src/icon-button/index.js\n\n;// CONCATENATED MODULE: ./src/linear-progress/constants.js\nvar linear_progress_constants_cssClasses = {\n  ROOT: \'mdc-linear-progress\',\n  INDETERMINATE: \'mdc-linear-progress--indeterminate\',\n  ANIMATION_READY: \'mdc-linear-progress--animation-ready\',\n  CLOSED: \'mdc-linear-progress--closed\',\n  CLOSED_ANIMATION_OFF: \'mdc-linear-progress--closed-animation-off\',\n  BUFFER: \'mdc-linear-progress__buffer\',\n  BUFFER_BAR: \'mdc-linear-progress__buffer-bar\',\n  BUFFER_DOTS: \'mdc-linear-progress__buffer-dots\',\n  BAR: \'mdc-linear-progress__bar\',\n  PRIMARY_BAR: \'mdc-linear-progress__primary-bar\',\n  SECONDARY_BAR: \'mdc-linear-progress__secondary-bar\',\n  BAR_INNER: \'mdc-linear-progress__bar-inner\'\n};\n;// CONCATENATED MODULE: ./src/linear-progress/LinearProgress.jsx\nvar LinearProgress_excluded = ["value", "buffer", "indeterminate", "closed", "className"];\n\nfunction LinearProgress_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction LinearProgress_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { LinearProgress_ownKeys(Object(source), true).forEach(function (key) { LinearProgress_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { LinearProgress_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction LinearProgress_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction LinearProgress_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = LinearProgress_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction LinearProgress_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\n\n\nvar LinearProgress = /*#__PURE__*/(0,react.forwardRef)(function (_ref, ref) {\n  var _classnames;\n\n  var _ref$value = _ref.value,\n      value = _ref$value === void 0 ? 0 : _ref$value,\n      _ref$buffer = _ref.buffer,\n      buffer = _ref$buffer === void 0 ? 0 : _ref$buffer,\n      _ref$indeterminate = _ref.indeterminate,\n      indeterminate = _ref$indeterminate === void 0 ? false : _ref$indeterminate,\n      _ref$closed = _ref.closed,\n      closed = _ref$closed === void 0 ? false : _ref$closed,\n      className = _ref.className,\n      props = LinearProgress_objectWithoutProperties(_ref, LinearProgress_excluded);\n\n  var classNames = classnames_default()(linear_progress_constants_cssClasses.ROOT, (_classnames = {}, LinearProgress_defineProperty(_classnames, linear_progress_constants_cssClasses.INDETERMINATE, indeterminate), LinearProgress_defineProperty(_classnames, linear_progress_constants_cssClasses.ANIMATION_READY, indeterminate), LinearProgress_defineProperty(_classnames, linear_progress_constants_cssClasses.CLOSED, closed), _classnames), className);\n  var primaryBarStyle = {\n    transform: "scaleX(".concat(indeterminate ? 1 : value > 1 ? value * 0.01 : value, ")")\n  };\n  var bufferStyle = {\n    flexBasis: buffer ? "".concat(indeterminate ? 1 : buffer < 1 ? buffer * 100 : buffer, "%") : undefined\n  };\n  return /*#__PURE__*/(0,jsx_runtime.jsxs)("div", LinearProgress_objectSpread(LinearProgress_objectSpread({\n    ref: ref,\n    className: classNames,\n    role: "progressbar",\n    "aria-valuemin": "0",\n    "aria-valuemax": "1",\n    "aria-valuenow": value > 1 ? value * 0.01 : value\n  }, props), {}, {\n    children: [/*#__PURE__*/(0,jsx_runtime.jsxs)("div", {\n      className: linear_progress_constants_cssClasses.BUFFER,\n      children: [/*#__PURE__*/(0,jsx_runtime.jsx)("div", {\n        className: linear_progress_constants_cssClasses.BUFFER_BAR,\n        style: bufferStyle\n      }), /*#__PURE__*/(0,jsx_runtime.jsx)("div", {\n        className: linear_progress_constants_cssClasses.BUFFER_DOTS\n      })]\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)("div", {\n      className: "".concat(linear_progress_constants_cssClasses.BAR, " ").concat(linear_progress_constants_cssClasses.PRIMARY_BAR),\n      style: primaryBarStyle,\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)("span", {\n        className: linear_progress_constants_cssClasses.BAR_INNER\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)("div", {\n      className: "".concat(linear_progress_constants_cssClasses.BAR, " ").concat(linear_progress_constants_cssClasses.SECONDARY_BAR),\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)("span", {\n        className: linear_progress_constants_cssClasses.BAR_INNER\n      })\n    })]\n  }));\n});\nLinearProgress.displayName = \'MDCLinearProgress\';\nLinearProgress.propTypes = {\n  value: prop_types_default().oneOfType([(prop_types_default()).number, (prop_types_default()).string]),\n  buffer: prop_types_default().oneOfType([(prop_types_default()).number, (prop_types_default()).string]),\n  indeterminate: (prop_types_default()).bool,\n  closed: (prop_types_default()).bool\n};\n/* harmony default export */ const linear_progress_LinearProgress = (LinearProgress);\n;// CONCATENATED MODULE: ./src/linear-progress/index.js\n\n;// CONCATENATED MODULE: ./src/data-table/constants.js\nvar data_table_constants_cssClasses = {\n  ROOT: \'mdc-data-table\',\n  STICKY_HEADER: \'mdc-data-table--sticky-header\',\n  IN_PROGRESS: \'mdc-data-table--in-progress\',\n  TABLE_CONTAINER: \'mdc-data-table__table-container\',\n  TABLE: \'mdc-data-table__table\',\n  HEADER: \'mdc-data-table__header\',\n  HEADER_ROW: \'mdc-data-table__header-row\',\n  HEADER_ROW_CHECKBOX: \'mdc-data-table__header-row-checkbox\',\n  HEADER_CELL: \'mdc-data-table__header-cell\',\n  HEADER_CELL_CHECKBOX: \'mdc-data-table__header-cell--checkbox\',\n  HEADER_CELL_NUMERIC: \'mdc-data-table__header-cell--numeric\',\n  HEADER_CELL_WITH_SORT: \'mdc-data-table__header-cell--with-sort\',\n  HEADER_CELL_SORTED: \'mdc-data-table__header-cell--sorted\',\n  HEADER_CELL_SORTED_DESC: \'mdc-data-table__header-cell--sorted-descending\',\n  HEADER_CELL_WRAPPER: \'mdc-data-table__header-cell-wrapper\',\n  HEADER_CELL_LABEL: \'mdc-data-table__header-cell-label\',\n  CONTENT: \'mdc-data-table__content\',\n  ROW: \'mdc-data-table__row\',\n  ROW_CHECKBOX: \'mdc-data-table__row-checkbox\',\n  ROW_SELECTED: \'mdc-data-table__row--selected\',\n  CELL: \'mdc-data-table__cell\',\n  CELL_CHECKBOX: \'mdc-data-table__cell--checkbox\',\n  CELL_NUMERIC: \'mdc-data-table__cell--numeric\',\n  PAGINATION: \'mdc-data-table__pagination\',\n  PAGINATION_TRAILING: \'mdc-data-table__pagination-trailing\',\n  PAGINATION_ROWS_PER_PAGE: \'mdc-data-table__pagination-rows-per-page\',\n  PAGINATION_ROWS_PER_PAGE_LABEL: \'mdc-data-table__pagination-rows-per-page-label\',\n  PAGINATION_ROWS_PER_PAGE_SELECT: \'mdc-data-table__pagination-rows-per-page-select\',\n  PAGINATION_NAVIGATION: \'mdc-data-table__pagination-navigation\',\n  PAGINATION_TOTAL: \'mdc-data-table__pagination-total\',\n  PAGINATION_BUTTON: \'mdc-data-table__pagination-button\',\n  SORT_ICON_BUTTON: \'mdc-data-table__sort-icon-button\',\n  SORT_STATUS_LABEL: \'mdc-data-table__sort-status-label\',\n  PROGRESS_INDICATOR: \'mdc-data-table__progress-indicator\',\n  SCRIM: \'mdc-data-table__scrim\',\n  FOOTER: \'mdc-data-table__footer\',\n  LINEAR_PROGRESS: \'mdc-data-table__linear-progress\'\n};\n;// CONCATENATED MODULE: ./src/data-table/DataTableProgressIndicator.jsx\nfunction DataTableProgressIndicator_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction DataTableProgressIndicator_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { DataTableProgressIndicator_ownKeys(Object(source), true).forEach(function (key) { DataTableProgressIndicator_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { DataTableProgressIndicator_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction DataTableProgressIndicator_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n\n\n\n\n\nvar DataTableProgressIndicator = /*#__PURE__*/(0,react.forwardRef)(function (props, ref) {\n  return /*#__PURE__*/(0,jsx_runtime.jsxs)("div", DataTableProgressIndicator_objectSpread(DataTableProgressIndicator_objectSpread({\n    ref: ref,\n    className: data_table_constants_cssClasses.PROGRESS_INDICATOR\n  }, props), {}, {\n    children: [/*#__PURE__*/(0,jsx_runtime.jsx)("div", {\n      className: data_table_constants_cssClasses.SCRIM\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(linear_progress_LinearProgress, {\n      className: data_table_constants_cssClasses.LINEAR_PROGRESS,\n      indeterminate: true\n    })]\n  }));\n});\nDataTableProgressIndicator.displayName = \'MDCDataTableProgressIndicator\';\n/* harmony default export */ const data_table_DataTableProgressIndicator = (DataTableProgressIndicator);\n;// CONCATENATED MODULE: ./src/floating-label/constants.js\nvar floating_label_constants_cssClasses = {\n  ROOT: \'mdc-floating-label\',\n  FLOAT: \'mdc-floating-label--float-above\',\n  REQUIRED: \'mdc-floating-label--required\'\n};\n;// CONCATENATED MODULE: ./src/floating-label/FloatingLabel.jsx\nvar FloatingLabel_excluded = ["label", "float", "required", "className", "children"];\n\nfunction FloatingLabel_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction FloatingLabel_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { FloatingLabel_ownKeys(Object(source), true).forEach(function (key) { FloatingLabel_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { FloatingLabel_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction FloatingLabel_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction FloatingLabel_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = FloatingLabel_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction FloatingLabel_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\n\nvar FloatingLabel = /*#__PURE__*/(0,react.forwardRef)(function (_ref, ref) {\n  var _classnames;\n\n  var label = _ref.label,\n      _ref$float = _ref["float"],\n      _float = _ref$float === void 0 ? false : _ref$float,\n      _ref$required = _ref.required,\n      required = _ref$required === void 0 ? false : _ref$required,\n      className = _ref.className,\n      _ref$children = _ref.children,\n      children = _ref$children === void 0 ? label : _ref$children,\n      props = FloatingLabel_objectWithoutProperties(_ref, FloatingLabel_excluded);\n\n  var classNames = classnames_default()(floating_label_constants_cssClasses.ROOT, (_classnames = {}, FloatingLabel_defineProperty(_classnames, floating_label_constants_cssClasses.FLOAT, _float), FloatingLabel_defineProperty(_classnames, floating_label_constants_cssClasses.REQUIRED, required), _classnames), className);\n  return /*#__PURE__*/(0,jsx_runtime.jsx)("span", FloatingLabel_objectSpread(FloatingLabel_objectSpread({\n    ref: ref,\n    className: classNames\n  }, props), {}, {\n    children: children\n  }));\n});\nFloatingLabel.displayName = \'MDCFloatingLabel\';\nFloatingLabel.propTypes = {\n  label: (prop_types_default()).string,\n  "float": (prop_types_default()).bool,\n  required: (prop_types_default()).bool\n};\n/* harmony default export */ const floating_label_FloatingLabel = (FloatingLabel);\n;// CONCATENATED MODULE: ./src/floating-label/index.js\n\n;// CONCATENATED MODULE: ./src/line-ripple/constants.js\nvar line_ripple_constants_cssClasses = {\n  ROOT: \'mdc-line-ripple\',\n  ACTIVE: \'mdc-line-ripple--active\',\n  DEACTIVATING: \'mdc-line-ripple--deactivating\'\n};\n;// CONCATENATED MODULE: ./src/line-ripple/LineRipple.jsx\nvar LineRipple_excluded = ["active", "transformOrigin"];\n\nfunction LineRipple_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction LineRipple_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { LineRipple_ownKeys(Object(source), true).forEach(function (key) { LineRipple_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { LineRipple_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction LineRipple_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction LineRipple_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = LineRipple_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction LineRipple_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\n\nvar LineRipple = /*#__PURE__*/(0,react.forwardRef)(function (_ref, ref) {\n  var _ref$active = _ref.active,\n      active = _ref$active === void 0 ? false : _ref$active,\n      transformOrigin = _ref.transformOrigin,\n      props = LineRipple_objectWithoutProperties(_ref, LineRipple_excluded);\n\n  var style = transformOrigin && {\n    transformOrigin: "".concat(transformOrigin, "px")\n  };\n  var classNames = classnames_default()(line_ripple_constants_cssClasses.ROOT, LineRipple_defineProperty({}, line_ripple_constants_cssClasses.ACTIVE, active));\n  return /*#__PURE__*/(0,jsx_runtime.jsx)("span", LineRipple_objectSpread({\n    ref: ref,\n    style: style,\n    className: classNames\n  }, props));\n});\nLineRipple.displayName = \'MDCLineRipple\';\nLineRipple.propTypes = {\n  active: (prop_types_default()).bool\n};\n/* harmony default export */ const line_ripple_LineRipple = (LineRipple);\n;// CONCATENATED MODULE: ./src/line-ripple/index.js\n\n;// CONCATENATED MODULE: ./src/constants.js\nvar Key = {\n  ARROW_LEFT: \'ArrowLeft\',\n  ARROW_UP: \'ArrowUp\',\n  ARROW_RIGHT: \'ArrowRight\',\n  ARROW_DOWN: \'ArrowDown\',\n  HOME: \'Home\',\n  END: \'End\',\n  PAGE_UP: \'PageUp\',\n  PAGE_DOWN: \'PageDown\'\n};\nvar KeyCode = {\n  PAGE_UP: 33,\n  PAGE_DOWN: 34,\n  END: 35,\n  HOME: 36,\n  ARROW_LEFT: 37,\n  ARROW_UP: 38,\n  ARROW_RIGHT: 39,\n  ARROW_DOWN: 40\n};\n;// CONCATENATED MODULE: ./src/utils.js\n\nfunction getClientWidth(element) {\n  if (element.offsetParent !== null) {\n    return element.clientWidth;\n  }\n\n  var clone = element.cloneNode(true);\n  clone.style.setProperty(\'position\', \'absolute\');\n  clone.style.setProperty(\'transform\', \'translate(-9999px, -9999px)\');\n  document.documentElement.appendChild(clone);\n  var clientWidth = clone.clientWidth;\n  document.documentElement.removeChild(clone);\n  return clientWidth;\n}\nfunction getEventKey(event) {\n  switch (event.key || event.keyCode) {\n    case Key.ARROW_LEFT:\n    case KeyCode.ARROW_LEFT:\n      return Key.ARROW_LEFT;\n\n    case Key.ARROW_UP:\n    case KeyCode.ARROW_UP:\n      return Key.ARROW_UP;\n\n    case Key.ARROW_RIGHT:\n    case KeyCode.ARROW_RIGHT:\n      return Key.ARROW_RIGHT;\n\n    case Key.ARROW_DOWN:\n    case KeyCode.ARROW_DOWN:\n      return Key.ARROW_DOWN;\n\n    case Key.HOME:\n    case KeyCode.HOME:\n      return Key.HOME;\n\n    case Key.END:\n    case KeyCode.END:\n      return Key.END;\n\n    case Key.PAGE_UP:\n    case KeyCode.PAGE_UP:\n      return Key.PAGE_UP;\n\n    case Key.PAGE_DOWN:\n    case KeyCode.PAGE_DOWN:\n      return Key.PAGE_DOWN;\n\n    default:\n      return undefined;\n  }\n}\nfunction getPageX(event) {\n  var _event$targetTouches;\n\n  if (((_event$targetTouches = event.targetTouches) === null || _event$targetTouches === void 0 ? void 0 : _event$targetTouches.length) > 0) {\n    return event.targetTouches[0].pageX;\n  }\n\n  return event.pageX;\n}\nfunction getPageY(event) {\n  var _event$targetTouches2;\n\n  if (((_event$targetTouches2 = event.targetTouches) === null || _event$targetTouches2 === void 0 ? void 0 : _event$targetTouches2.length) > 0) {\n    return event.targetTouches[0].pageY;\n  }\n\n  return event.pageY;\n}\n;// CONCATENATED MODULE: ./src/notched-outline/constants.js\nvar notched_outline_constants_numbers = {\n  NOTCH_SIZE_FACTOR: 0.75,\n  NOTCH_PADDING_RIGHT: 8\n};\nvar notched_outline_constants_cssClasses = {\n  ROOT: \'mdc-notched-outline\',\n  NOTCHED: \'mdc-notched-outline--notched\',\n  UPGRADED: \'mdc-notched-outline--upgraded\',\n  NO_LABEL: \'mdc-notched-outline--no-label\',\n  LEADING: \'mdc-notched-outline__leading\',\n  NOTCH: \'mdc-notched-outline__notch\',\n  TRAILING: \'mdc-notched-outline__trailing\'\n};\n;// CONCATENATED MODULE: ./src/notched-outline/NotchedOutline.jsx\nvar NotchedOutline_excluded = ["notched", "className", "children"];\n\nfunction NotchedOutline_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction NotchedOutline_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { NotchedOutline_ownKeys(Object(source), true).forEach(function (key) { NotchedOutline_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { NotchedOutline_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction NotchedOutline_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction NotchedOutline_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = NotchedOutline_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction NotchedOutline_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\n\n\n\nvar NotchedOutline = /*#__PURE__*/(0,react.forwardRef)(function (_ref, ref) {\n  var _classnames;\n\n  var _ref$notched = _ref.notched,\n      notched = _ref$notched === void 0 ? false : _ref$notched,\n      className = _ref.className,\n      children = _ref.children,\n      props = NotchedOutline_objectWithoutProperties(_ref, NotchedOutline_excluded);\n\n  var notchRef = (0,react.useRef)();\n  (0,react.useLayoutEffect)(function () {\n    var notch = notchRef.current;\n    var floatingLabel = notch === null || notch === void 0 ? void 0 : notch.firstChild;\n    if (!notch || !floatingLabel) return;\n    var width = getClientWidth(floatingLabel);\n\n    if (notched) {\n      notchRef.current.style.width = "".concat(width * notched_outline_constants_numbers.NOTCH_SIZE_FACTOR + notched_outline_constants_numbers.NOTCH_PADDING_RIGHT, "px");\n    } else {\n      notchRef.current.style.width = \'auto\';\n    }\n  }, [notched]);\n  var classNames = classnames_default()(notched_outline_constants_cssClasses.ROOT, notched_outline_constants_cssClasses.UPGRADED, (_classnames = {}, NotchedOutline_defineProperty(_classnames, notched_outline_constants_cssClasses.NOTCHED, notched), NotchedOutline_defineProperty(_classnames, notched_outline_constants_cssClasses.NO_LABEL, !children), _classnames), className);\n  return /*#__PURE__*/(0,jsx_runtime.jsxs)("span", NotchedOutline_objectSpread(NotchedOutline_objectSpread({\n    ref: ref,\n    className: classNames\n  }, props), {}, {\n    children: [/*#__PURE__*/(0,jsx_runtime.jsx)("span", {\n      className: notched_outline_constants_cssClasses.LEADING\n    }), children && /*#__PURE__*/(0,jsx_runtime.jsx)("span", {\n      ref: notchRef,\n      className: notched_outline_constants_cssClasses.NOTCH,\n      children: children\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)("span", {\n      className: notched_outline_constants_cssClasses.TRAILING\n    })]\n  }));\n});\nNotchedOutline.displayName = \'MDCNotchedOutline\';\nNotchedOutline.propTypes = {\n  notched: (prop_types_default()).bool\n};\n/* harmony default export */ const notched_outline_NotchedOutline = (NotchedOutline);\n;// CONCATENATED MODULE: ./src/notched-outline/index.js\n\n;// CONCATENATED MODULE: ./src/menu/constants.js\nvar menu_constants_numbers = {\n  TRANSITION_OPEN_DURATION: 120,\n  TRANSITION_CLOSE_DURATION: 75,\n  MARGIN_TO_EDGE: 32,\n  ANCHOR_TO_MENU_SURFACE_WIDTH_RATIO: 0.67,\n  TOUCH_EVENT_WAIT_MS: 30\n};\nvar menu_constants_cssClasses = {\n  ROOT: \'mdc-menu\',\n  SURFACE: \'mdc-menu-surface\',\n  SURFACE_ANCHOR: \'mdc-menu-surface--anchor\',\n  SURFACE_FIXED: \'mdc-menu-surface--fixed\',\n  SURFACE_OPEN: \'mdc-menu-surface--open\',\n  SURFACE_ANIMATING_OPEN: \'mdc-menu-surface--animating-open\',\n  SURFACE_ANIMATING_CLOSED: \'mdc-menu-surface--animating-closed\',\n  SURFACE_BELOW_ANCHOR: \'mdc-menu-surface--is-open-below\',\n  ITEM: \'mdc-menu-item\',\n  ITEM_SELECTED: \'mdc-menu-item--selected\',\n  SELECTION_GROUP: \'mdc-menu__selection-group\',\n  SELECTION_GROUP_ICON: \'mdc-menu__selection-group-icon\'\n};\nvar Origin = {\n  TOP_LEFT: \'top left\',\n  TOP_CENTER: \'top center\',\n  TOP_RIGHT: \'top right\',\n  CENTER_LEFT: \'center left\',\n  CENTER: \'center center\',\n  CENTER_RIGHT: \'center right\',\n  BOTTOM_LEFT: \'bottom left\',\n  BOTTOM_CENTER: \'bottom center\',\n  BOTTOM_RIGHT: \'bottom right\'\n};\n;// CONCATENATED MODULE: ./src/hooks.js\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\n\nfunction useCreated(fn) {\n  var _useState = useState(false),\n      _useState2 = _slicedToArray(_useState, 2),\n      created = _useState2[0],\n      setCreated = _useState2[1];\n\n  if (created) return;\n  fn();\n  setCreated(true);\n}\nfunction useMounted(fn) {\n  (0,react.useEffect)(function () {\n    return fn();\n  }, []);\n}\nfunction useUpdated(fn, deps) {\n  var _useState3 = (0,react.useState)(false),\n      _useState4 = _slicedToArray(_useState3, 2),\n      mounted = _useState4[0],\n      setMounted = _useState4[1];\n\n  (0,react.useEffect)(function () {\n    if (!mounted) return setMounted(true);\n    return fn();\n  }, deps);\n}\nfunction useUpdatedSync(fn, deps) {\n  var _useState5 = (0,react.useState)(false),\n      _useState6 = _slicedToArray(_useState5, 2),\n      mounted = _useState6[0],\n      setMounted = _useState6[1];\n\n  (0,react.useLayoutEffect)(function () {\n    if (!mounted) return setMounted(true);\n    return fn();\n  }, deps);\n}\nfunction useUnmounted(fn) {\n  (0,react.useEffect)(function () {\n    return function () {\n      return fn();\n    };\n  }, []);\n}\n;// CONCATENATED MODULE: ./src/list/constants.js\nvar listCssClasses = {\n  ROOT: \'mdc-list\'\n};\nvar listItemCssClasses = {\n  ROOT: \'mdc-list-item\',\n  ACTIVATED: \'mdc-list-item--activated\',\n  SELECTED: \'mdc-list-item--selected\',\n  DISABLED: \'mdc-list-item--disabled\',\n  NON_INTERACTIVE: \'mdc-list-item--non-interactive\',\n  ONE_LINE: \'mdc-list-item--with-one-line\',\n  TWO_LINES: \'mdc-list-item--with-two-lines\',\n  THREE_LINES: \'mdc-list-item--with-three-lines\',\n  OVERLINE: \'mdc-list-item--with-overline\',\n  LEADING_ICON: \'mdc-list-item--with-leading-icon\',\n  LEADING_IMAGE: \'mdc-list-item--with-leading-image\',\n  LEADING_AVATAR: \'mdc-list-item--with-leading-avatar\',\n  LEADING_THUMBNAIL: \'mdc-list-item--with-leading-thumbnail\',\n  LEADING_VIDEO: \'mdc-list-item--with-leading-video\',\n  LEADING_CHECKBOX: \'mdc-list-item--with-leading-checkbox\',\n  LEADING_RADIO: \'mdc-list-item--with-leading-radio\',\n  LEADING_SWITCH: \'mdc-list-item--with-leading-switch\',\n  TRAILING_ICON: \'mdc-list-item--with-trailing-icon\',\n  TRAILING_META: \'mdc-list-item--with-trailing-meta\',\n  TRAILING_CHECKBOX: \'mdc-list-item--with-trailing-checkbox\',\n  TRAILING_RADIO: \'mdc-list-item--with-trailing-radio\',\n  TRAILING_SWITCH: \'mdc-list-item--with-trailing-switch\',\n  START: \'mdc-list-item__start\',\n  CONTENT: \'mdc-list-item__content\',\n  END: \'mdc-list-item__end\',\n  OVERLINE_TEXT: \'mdc-list-item__overline-text\',\n  PRIMARY_TEXT: \'mdc-list-item__primary-text\',\n  SECONDARY_TEXT: \'mdc-list-item__secondary-text\',\n  RIPPLE: \'mdc-list-item__ripple\'\n};\nvar listGroupCssClasses = {\n  ROOT: \'mdc-list-group\',\n  SUBHEADER: \'mdc-list-group__subheader\'\n};\nvar listDividerCssClasses = {\n  ROOT: \'mdc-list-divider\',\n  LEADING_TEXT: \'mdc-list-divider--with-leading-text\',\n  LEADING_ICON: \'mdc-list-divider--with-leading-icon\',\n  LEADING_IMAGE: \'mdc-list-divider--with-leading-image\',\n  LEADING_VIDEO: \'mdc-list-divider--with-leading-video\',\n  LEADING_THUMBNAIL: \'mdc-list-divider--with-leading-thumbnail\',\n  LEADING_AVATAR: \'mdc-list-divider--with-leading-avatar\',\n  LEADING_CHECKBOX: \'mdc-list-divider--with-leading-checkbox\',\n  LEADING_SWITCH: \'mdc-list-divider--with-leading-switch\',\n  LEADING_RADIO: \'mdc-list-divider--with-leading-radio\'\n};\n;// CONCATENATED MODULE: ./src/list/ListItemContent.jsx\nvar ListItemContent_excluded = ["overline", "primary", "secondary", "overlineText", "primaryText", "secondaryText", "element", "component", "className", "children"];\n\nfunction ListItemContent_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction ListItemContent_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ListItemContent_ownKeys(Object(source), true).forEach(function (key) { ListItemContent_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ListItemContent_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction ListItemContent_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction ListItemContent_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = ListItemContent_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction ListItemContent_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\n\n\n\nvar ListItemContent = /*#__PURE__*/(0,react.forwardRef)(function (_ref, ref) {\n  var overline = _ref.overline,\n      primary = _ref.primary,\n      secondary = _ref.secondary,\n      _ref$overlineText = _ref.overlineText,\n      overlineText = _ref$overlineText === void 0 ? overline : _ref$overlineText,\n      _ref$primaryText = _ref.primaryText,\n      primaryText = _ref$primaryText === void 0 ? primary : _ref$primaryText,\n      _ref$secondaryText = _ref.secondaryText,\n      secondaryText = _ref$secondaryText === void 0 ? secondary : _ref$secondaryText,\n      _ref$element = _ref.element,\n      element = _ref$element === void 0 ? \'span\' : _ref$element,\n      _ref$component = _ref.component,\n      Element = _ref$component === void 0 ? element : _ref$component,\n      className = _ref.className,\n      children = _ref.children,\n      props = ListItemContent_objectWithoutProperties(_ref, ListItemContent_excluded);\n\n  var classNames = classnames_default()(listItemCssClasses.CONTENT, className);\n  return /*#__PURE__*/(0,jsx_runtime.jsxs)(Element, ListItemContent_objectSpread(ListItemContent_objectSpread({\n    ref: ref,\n    className: classNames\n  }, props), {}, {\n    children: [overlineText && /*#__PURE__*/(0,jsx_runtime.jsx)(Clone, {\n      component: overlineText,\n      fallback: "span",\n      className: listItemCssClasses.OVERLINE_TEXT\n    }), primaryText && /*#__PURE__*/(0,jsx_runtime.jsx)(Clone, {\n      component: primaryText,\n      fallback: "span",\n      className: listItemCssClasses.PRIMARY_TEXT\n    }), secondaryText && /*#__PURE__*/(0,jsx_runtime.jsx)(Clone, {\n      component: secondaryText,\n      fallback: "span",\n      className: listItemCssClasses.SECONDARY_TEXT\n    }), children]\n  }));\n});\nListItemContent.displayName = \'MDCListItemContent\';\nListItemContent.propTypes = {\n  overlineText: (prop_types_default()).node,\n  primaryText: (prop_types_default()).node,\n  secondaryText: (prop_types_default()).node\n};\n/* harmony default export */ const list_ListItemContent = (ListItemContent);\n;// CONCATENATED MODULE: ./src/list/ListItemEnd.jsx\nvar ListItemEnd_excluded = ["element", "component", "className"];\n\nfunction ListItemEnd_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction ListItemEnd_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ListItemEnd_ownKeys(Object(source), true).forEach(function (key) { ListItemEnd_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ListItemEnd_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction ListItemEnd_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction ListItemEnd_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = ListItemEnd_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction ListItemEnd_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\nvar ListItemEnd = /*#__PURE__*/(0,react.forwardRef)(function (_ref, ref) {\n  var _ref$element = _ref.element,\n      element = _ref$element === void 0 ? \'span\' : _ref$element,\n      _ref$component = _ref.component,\n      Element = _ref$component === void 0 ? element : _ref$component,\n      className = _ref.className,\n      props = ListItemEnd_objectWithoutProperties(_ref, ListItemEnd_excluded);\n\n  var classNames = classnames_default()(listItemCssClasses.END, className);\n  return /*#__PURE__*/(0,jsx_runtime.jsx)(Element, ListItemEnd_objectSpread({\n    ref: ref,\n    className: classNames\n  }, props));\n});\nListItemEnd.displayName = \'MDCListItemEnd\';\n/* harmony default export */ const list_ListItemEnd = (ListItemEnd);\n;// CONCATENATED MODULE: ./src/list/ListItemStart.jsx\nvar ListItemStart_excluded = ["element", "component", "className"];\n\nfunction ListItemStart_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction ListItemStart_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ListItemStart_ownKeys(Object(source), true).forEach(function (key) { ListItemStart_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ListItemStart_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction ListItemStart_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction ListItemStart_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = ListItemStart_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction ListItemStart_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\nvar ListItemStart = /*#__PURE__*/(0,react.forwardRef)(function (_ref, ref) {\n  var _ref$element = _ref.element,\n      element = _ref$element === void 0 ? \'span\' : _ref$element,\n      _ref$component = _ref.component,\n      Element = _ref$component === void 0 ? element : _ref$component,\n      className = _ref.className,\n      props = ListItemStart_objectWithoutProperties(_ref, ListItemStart_excluded);\n\n  var classNames = classnames_default()(listItemCssClasses.START, className);\n  return /*#__PURE__*/(0,jsx_runtime.jsx)(Element, ListItemStart_objectSpread({\n    ref: ref,\n    className: classNames\n  }, props));\n});\nListItemStart.displayName = \'MDCListItemStart\';\n/* harmony default export */ const list_ListItemStart = (ListItemStart);\n;// CONCATENATED MODULE: ./src/list/ListItem.jsx\nvar ListItem_excluded = ["start", "content", "end", "text", "overlineText", "primaryText", "secondaryText", "icon", "image", "avatar", "thumbnail", "video", "leadingIcon", "leadingImage", "leadingAvatar", "leadingThumbnail", "leadingVideo", "leadingCheckbox", "leadingRadio", "leadingSwitch", "meta", "trailingMeta", "trailingIcon", "trailingCheckbox", "trailingRadio", "trailingSwitch", "activated", "selected", "disabled", "nonInteractive", "oneLine", "twoLines", "threeLines", "withLeadingIcon", "withLeadingImage", "withLeadingAvatar", "withLeadingThumbnail", "withLeadingVideo", "withLeadingCheckbox", "withLeadingRadio", "withLeadingSwitch", "withTrailingMeta", "withTrailingIcon", "withTrailingCheckbox", "withTrailingRadio", "withTrailingSwitch", "element", "component", "className", "children"];\n\nfunction ListItem_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction ListItem_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ListItem_ownKeys(Object(source), true).forEach(function (key) { ListItem_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ListItem_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction ListItem_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction ListItem_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = ListItem_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction ListItem_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\n\n\n\n\n\n\n\nvar ListItem = /*#__PURE__*/(0,react.forwardRef)(function (_ref, ref) {\n  var _classnames;\n\n  var start = _ref.start,\n      content = _ref.content,\n      end = _ref.end,\n      text = _ref.text,\n      overlineText = _ref.overlineText,\n      _ref$primaryText = _ref.primaryText,\n      primaryText = _ref$primaryText === void 0 ? text : _ref$primaryText,\n      secondaryText = _ref.secondaryText,\n      icon = _ref.icon,\n      image = _ref.image,\n      avatar = _ref.avatar,\n      thumbnail = _ref.thumbnail,\n      video = _ref.video,\n      _ref$leadingIcon = _ref.leadingIcon,\n      leadingIcon = _ref$leadingIcon === void 0 ? icon : _ref$leadingIcon,\n      _ref$leadingImage = _ref.leadingImage,\n      leadingImage = _ref$leadingImage === void 0 ? image : _ref$leadingImage,\n      _ref$leadingAvatar = _ref.leadingAvatar,\n      leadingAvatar = _ref$leadingAvatar === void 0 ? avatar : _ref$leadingAvatar,\n      _ref$leadingThumbnail = _ref.leadingThumbnail,\n      leadingThumbnail = _ref$leadingThumbnail === void 0 ? thumbnail : _ref$leadingThumbnail,\n      _ref$leadingVideo = _ref.leadingVideo,\n      leadingVideo = _ref$leadingVideo === void 0 ? video : _ref$leadingVideo,\n      leadingCheckbox = _ref.leadingCheckbox,\n      leadingRadio = _ref.leadingRadio,\n      leadingSwitch = _ref.leadingSwitch,\n      meta = _ref.meta,\n      _ref$trailingMeta = _ref.trailingMeta,\n      trailingMeta = _ref$trailingMeta === void 0 ? meta : _ref$trailingMeta,\n      trailingIcon = _ref.trailingIcon,\n      trailingCheckbox = _ref.trailingCheckbox,\n      trailingRadio = _ref.trailingRadio,\n      trailingSwitch = _ref.trailingSwitch,\n      _ref$activated = _ref.activated,\n      activated = _ref$activated === void 0 ? false : _ref$activated,\n      _ref$selected = _ref.selected,\n      selected = _ref$selected === void 0 ? false : _ref$selected,\n      _ref$disabled = _ref.disabled,\n      disabled = _ref$disabled === void 0 ? false : _ref$disabled,\n      _ref$nonInteractive = _ref.nonInteractive,\n      nonInteractive = _ref$nonInteractive === void 0 ? false : _ref$nonInteractive,\n      _ref$oneLine = _ref.oneLine,\n      oneLine = _ref$oneLine === void 0 ? false : _ref$oneLine,\n      _ref$twoLines = _ref.twoLines,\n      twoLines = _ref$twoLines === void 0 ? false : _ref$twoLines,\n      _ref$threeLines = _ref.threeLines,\n      threeLines = _ref$threeLines === void 0 ? false : _ref$threeLines,\n      _ref$withLeadingIcon = _ref.withLeadingIcon,\n      withLeadingIcon = _ref$withLeadingIcon === void 0 ? Boolean(leadingIcon) : _ref$withLeadingIcon,\n      _ref$withLeadingImage = _ref.withLeadingImage,\n      withLeadingImage = _ref$withLeadingImage === void 0 ? Boolean(leadingImage) : _ref$withLeadingImage,\n      _ref$withLeadingAvata = _ref.withLeadingAvatar,\n      withLeadingAvatar = _ref$withLeadingAvata === void 0 ? Boolean(leadingAvatar) : _ref$withLeadingAvata,\n      _ref$withLeadingThumb = _ref.withLeadingThumbnail,\n      withLeadingThumbnail = _ref$withLeadingThumb === void 0 ? Boolean(leadingThumbnail) : _ref$withLeadingThumb,\n      _ref$withLeadingVideo = _ref.withLeadingVideo,\n      withLeadingVideo = _ref$withLeadingVideo === void 0 ? Boolean(leadingVideo) : _ref$withLeadingVideo,\n      _ref$withLeadingCheck = _ref.withLeadingCheckbox,\n      withLeadingCheckbox = _ref$withLeadingCheck === void 0 ? Boolean(leadingCheckbox) : _ref$withLeadingCheck,\n      _ref$withLeadingRadio = _ref.withLeadingRadio,\n      withLeadingRadio = _ref$withLeadingRadio === void 0 ? Boolean(leadingRadio) : _ref$withLeadingRadio,\n      _ref$withLeadingSwitc = _ref.withLeadingSwitch,\n      withLeadingSwitch = _ref$withLeadingSwitc === void 0 ? Boolean(leadingSwitch) : _ref$withLeadingSwitc,\n      _ref$withTrailingMeta = _ref.withTrailingMeta,\n      withTrailingMeta = _ref$withTrailingMeta === void 0 ? Boolean(trailingMeta) : _ref$withTrailingMeta,\n      _ref$withTrailingIcon = _ref.withTrailingIcon,\n      withTrailingIcon = _ref$withTrailingIcon === void 0 ? Boolean(trailingIcon) : _ref$withTrailingIcon,\n      _ref$withTrailingChec = _ref.withTrailingCheckbox,\n      withTrailingCheckbox = _ref$withTrailingChec === void 0 ? Boolean(trailingCheckbox) : _ref$withTrailingChec,\n      _ref$withTrailingRadi = _ref.withTrailingRadio,\n      withTrailingRadio = _ref$withTrailingRadi === void 0 ? Boolean(trailingRadio) : _ref$withTrailingRadi,\n      _ref$withTrailingSwit = _ref.withTrailingSwitch,\n      withTrailingSwitch = _ref$withTrailingSwit === void 0 ? Boolean(trailingSwitch) : _ref$withTrailingSwit,\n      _ref$element = _ref.element,\n      element = _ref$element === void 0 ? \'li\' : _ref$element,\n      _ref$component = _ref.component,\n      Element = _ref$component === void 0 ? element : _ref$component,\n      className = _ref.className,\n      children = _ref.children,\n      props = ListItem_objectWithoutProperties(_ref, ListItem_excluded);\n\n  var lines = Boolean(overlineText) + Boolean(primaryText) + Boolean(secondaryText);\n  var hasStart = Boolean(start || leadingIcon || leadingImage || leadingAvatar || leadingThumbnail || leadingVideo || leadingCheckbox || leadingRadio || leadingSwitch);\n  var hasContent = Boolean(content || overlineText || primaryText || secondaryText);\n  var hasEnd = Boolean(end || trailingMeta || trailingIcon || trailingCheckbox || trailingRadio || trailingSwitch);\n  var classNames = classnames_default()(listItemCssClasses.ROOT, (_classnames = {}, ListItem_defineProperty(_classnames, listItemCssClasses.ACTIVATED, activated), ListItem_defineProperty(_classnames, listItemCssClasses.SELECTED, selected), ListItem_defineProperty(_classnames, listItemCssClasses.DISABLED, disabled), ListItem_defineProperty(_classnames, listItemCssClasses.ONE_LINE, oneLine || lines === 1), ListItem_defineProperty(_classnames, listItemCssClasses.TWO_LINES, twoLines || lines === 2), ListItem_defineProperty(_classnames, listItemCssClasses.THREE_LINES, threeLines || lines === 3), ListItem_defineProperty(_classnames, listItemCssClasses.NON_INTERACTIVE, nonInteractive), ListItem_defineProperty(_classnames, listItemCssClasses.OVERLINE, overlineText), ListItem_defineProperty(_classnames, listItemCssClasses.LEADING_ICON, withLeadingIcon), ListItem_defineProperty(_classnames, listItemCssClasses.LEADING_IMAGE, withLeadingImage), ListItem_defineProperty(_classnames, listItemCssClasses.LEADING_AVATAR, withLeadingAvatar), ListItem_defineProperty(_classnames, listItemCssClasses.LEADING_THUMBNAIL, withLeadingThumbnail), ListItem_defineProperty(_classnames, listItemCssClasses.LEADING_VIDEO, withLeadingVideo), ListItem_defineProperty(_classnames, listItemCssClasses.LEADING_CHECKBOX, withLeadingCheckbox), ListItem_defineProperty(_classnames, listItemCssClasses.LEADING_RADIO, withLeadingRadio), ListItem_defineProperty(_classnames, listItemCssClasses.LEADING_SWITCH, withLeadingSwitch), ListItem_defineProperty(_classnames, listItemCssClasses.TRAILING_ICON, withTrailingIcon), ListItem_defineProperty(_classnames, listItemCssClasses.TRAILING_META, withTrailingMeta), ListItem_defineProperty(_classnames, listItemCssClasses.TRAILING_CHECKBOX, withTrailingCheckbox), ListItem_defineProperty(_classnames, listItemCssClasses.TRAILING_RADIO, withTrailingRadio), ListItem_defineProperty(_classnames, listItemCssClasses.TRAILING_SWITCH, withTrailingSwitch), _classnames), className);\n  return /*#__PURE__*/(0,jsx_runtime.jsxs)(Element, ListItem_objectSpread(ListItem_objectSpread({\n    ref: ref,\n    className: classNames\n  }, props), {}, {\n    children: [/*#__PURE__*/(0,jsx_runtime.jsx)("span", {\n      className: listItemCssClasses.RIPPLE\n    }), hasStart && /*#__PURE__*/(0,jsx_runtime.jsxs)(list_ListItemStart, {\n      children: [start, leadingIcon && /*#__PURE__*/(0,jsx_runtime.jsx)(Clone, {\n        component: leadingIcon,\n        fallback: icon_Icon\n      }), leadingImage, leadingAvatar, leadingThumbnail, leadingVideo, leadingCheckbox, leadingRadio, leadingSwitch]\n    }), hasContent && /*#__PURE__*/(0,jsx_runtime.jsx)(list_ListItemContent, {\n      overlineText: overlineText,\n      primaryText: primaryText,\n      secondaryText: secondaryText,\n      children: content\n    }), hasEnd && /*#__PURE__*/(0,jsx_runtime.jsxs)(list_ListItemEnd, {\n      children: [end, trailingMeta, trailingIcon && /*#__PURE__*/(0,jsx_runtime.jsx)(Clone, {\n        component: trailingIcon,\n        fallback: icon_Icon\n      }), trailingCheckbox, trailingRadio, trailingSwitch]\n    }), children]\n  }));\n});\nListItem.displayName = \'MDCListItem\';\nListItem.propTypes = {\n  start: (prop_types_default()).node,\n  content: (prop_types_default()).node,\n  end: (prop_types_default()).node,\n  text: (prop_types_default()).node,\n  overlineText: (prop_types_default()).node,\n  primaryText: (prop_types_default()).node,\n  secondaryText: (prop_types_default()).node,\n  icon: (prop_types_default()).node,\n  image: (prop_types_default()).element,\n  thumbnail: (prop_types_default()).element,\n  video: (prop_types_default()).element,\n  leadingIcon: (prop_types_default()).node,\n  leadingImage: (prop_types_default()).element,\n  leadingThumbnail: (prop_types_default()).element,\n  leadingVideo: (prop_types_default()).element,\n  leadingCheckbox: (prop_types_default()).element,\n  leadingRadio: (prop_types_default()).element,\n  leadingSwitch: (prop_types_default()).element,\n  meta: (prop_types_default()).node,\n  trailingMeta: (prop_types_default()).node,\n  trailingIcon: (prop_types_default()).node,\n  trailingCheckbox: (prop_types_default()).element,\n  trailingRadio: (prop_types_default()).element,\n  trailingSwitch: (prop_types_default()).element,\n  activated: (prop_types_default()).bool,\n  selected: (prop_types_default()).bool,\n  disabled: (prop_types_default()).bool,\n  nonInteractive: (prop_types_default()).bool,\n  withLeadingIcon: (prop_types_default()).bool,\n  withLeadingImage: (prop_types_default()).bool,\n  withLeadingThumbnail: (prop_types_default()).bool,\n  withLeadingVideo: (prop_types_default()).bool,\n  withLeadingCheckbox: (prop_types_default()).bool,\n  withLeadingRadio: (prop_types_default()).bool,\n  withLeadingSwitch: (prop_types_default()).bool,\n  withTrailingMeta: (prop_types_default()).bool,\n  withTrailingIcon: (prop_types_default()).bool,\n  withTrailingCheckbox: (prop_types_default()).bool,\n  withTrailingRadio: (prop_types_default()).bool,\n  withTrailingSwitch: (prop_types_default()).bool\n};\n/* harmony default export */ const list_ListItem = (ListItem);\n;// CONCATENATED MODULE: ./src/list/List.jsx\nvar List_excluded = ["items", "element", "className", "children"];\n\nfunction List_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction List_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { List_ownKeys(Object(source), true).forEach(function (key) { List_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { List_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction List_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction List_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = List_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction List_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\n\n\n\nvar List = /*#__PURE__*/(0,react.forwardRef)(function (_ref, ref) {\n  var items = _ref.items,\n      _ref$element = _ref.element,\n      Element = _ref$element === void 0 ? \'ul\' : _ref$element,\n      className = _ref.className,\n      _ref$children = _ref.children,\n      children = _ref$children === void 0 ? items === null || items === void 0 ? void 0 : items.map(function (item) {\n    return (0,react.createElement)(list_ListItem, item);\n  }) : _ref$children,\n      props = List_objectWithoutProperties(_ref, List_excluded);\n\n  var classNames = classnames_default()(listCssClasses.ROOT, className);\n  return /*#__PURE__*/(0,jsx_runtime.jsx)(Element, List_objectSpread(List_objectSpread({\n    ref: ref,\n    className: classNames\n  }, props), {}, {\n    children: children\n  }));\n});\nList.displayName = \'MDCList\';\nlist_ListItem.propTypes = {\n  items: (prop_types_default()).array\n};\n/* harmony default export */ const list_List = (List);\n;// CONCATENATED MODULE: ./src/list/ListDivider.jsx\nvar ListDivider_excluded = ["withLeadingText", "withLeadingIcon", "withLeadingImage", "withLeadingThumbnail", "withLeadingVideo", "withLeadingCheckbox", "withLeadingRadio", "withLeadingSwitch", "element", "className"];\n\nfunction ListDivider_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction ListDivider_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ListDivider_ownKeys(Object(source), true).forEach(function (key) { ListDivider_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ListDivider_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction ListDivider_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction ListDivider_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = ListDivider_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction ListDivider_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\n\nvar ListDivider = /*#__PURE__*/(0,react.forwardRef)(function (_ref, ref) {\n  var _classnames;\n\n  var _ref$withLeadingText = _ref.withLeadingText,\n      withLeadingText = _ref$withLeadingText === void 0 ? false : _ref$withLeadingText,\n      _ref$withLeadingIcon = _ref.withLeadingIcon,\n      withLeadingIcon = _ref$withLeadingIcon === void 0 ? false : _ref$withLeadingIcon,\n      _ref$withLeadingImage = _ref.withLeadingImage,\n      withLeadingImage = _ref$withLeadingImage === void 0 ? false : _ref$withLeadingImage,\n      _ref$withLeadingThumb = _ref.withLeadingThumbnail,\n      withLeadingThumbnail = _ref$withLeadingThumb === void 0 ? false : _ref$withLeadingThumb,\n      _ref$withLeadingVideo = _ref.withLeadingVideo,\n      withLeadingVideo = _ref$withLeadingVideo === void 0 ? false : _ref$withLeadingVideo,\n      _ref$withLeadingCheck = _ref.withLeadingCheckbox,\n      withLeadingCheckbox = _ref$withLeadingCheck === void 0 ? false : _ref$withLeadingCheck,\n      _ref$withLeadingRadio = _ref.withLeadingRadio,\n      withLeadingRadio = _ref$withLeadingRadio === void 0 ? false : _ref$withLeadingRadio,\n      _ref$withLeadingSwitc = _ref.withLeadingSwitch,\n      withLeadingSwitch = _ref$withLeadingSwitc === void 0 ? false : _ref$withLeadingSwitc,\n      _ref$element = _ref.element,\n      Element = _ref$element === void 0 ? \'li\' : _ref$element,\n      className = _ref.className,\n      props = ListDivider_objectWithoutProperties(_ref, ListDivider_excluded);\n\n  var classNames = classnames_default()(listDividerCssClasses.ROOT, (_classnames = {}, ListDivider_defineProperty(_classnames, listDividerCssClasses.LEADING_TEXT, withLeadingText), ListDivider_defineProperty(_classnames, listDividerCssClasses.LEADING_ICON, withLeadingIcon), ListDivider_defineProperty(_classnames, listDividerCssClasses.LEADING_IMAGE, withLeadingImage), ListDivider_defineProperty(_classnames, listDividerCssClasses.LEADING_THUMBNAIL, withLeadingThumbnail), ListDivider_defineProperty(_classnames, listDividerCssClasses.LEADING_VIDEO, withLeadingVideo), ListDivider_defineProperty(_classnames, listDividerCssClasses.LEADING_CHECKBOX, withLeadingCheckbox), ListDivider_defineProperty(_classnames, listDividerCssClasses.LEADING_RADIO, withLeadingRadio), ListDivider_defineProperty(_classnames, listDividerCssClasses.LEADING_SWITCH, withLeadingSwitch), _classnames), className);\n  return /*#__PURE__*/(0,jsx_runtime.jsx)(Element, ListDivider_objectSpread({\n    ref: ref,\n    className: classNames,\n    role: Element === \'li\' ? \'separator\' : undefined\n  }, props));\n});\nListDivider.displayName = \'MDCListDivider\';\nListDivider.propTypes = {\n  withLeadingText: (prop_types_default()).bool,\n  withLeadingIcon: (prop_types_default()).bool,\n  withLeadingImage: (prop_types_default()).bool,\n  withLeadingThumbnail: (prop_types_default()).bool,\n  withLeadingVideo: (prop_types_default()).bool,\n  withLeadingAvatar: (prop_types_default()).bool,\n  withLeadingCheckbox: (prop_types_default()).bool,\n  withLeadingSwitch: (prop_types_default()).bool,\n  withLeadingRadio: (prop_types_default()).bool\n};\n/* harmony default export */ const list_ListDivider = (ListDivider);\n;// CONCATENATED MODULE: ./src/list/ListGroup.jsx\nvar ListGroup_excluded = ["element", "className"];\n\nfunction ListGroup_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction ListGroup_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ListGroup_ownKeys(Object(source), true).forEach(function (key) { ListGroup_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ListGroup_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction ListGroup_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction ListGroup_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = ListGroup_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction ListGroup_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\nvar ListGroup = /*#__PURE__*/(0,react.forwardRef)(function (_ref, ref) {\n  var _ref$element = _ref.element,\n      Element = _ref$element === void 0 ? \'div\' : _ref$element,\n      className = _ref.className,\n      props = ListGroup_objectWithoutProperties(_ref, ListGroup_excluded);\n\n  var classNames = classnames_default()(listGroupCssClasses.ROOT, className);\n  return /*#__PURE__*/(0,jsx_runtime.jsx)(Element, ListGroup_objectSpread({\n    ref: ref,\n    className: classNames\n  }, props));\n});\nListGroup.displayName = \'MDCListGroup\';\n/* harmony default export */ const list_ListGroup = (ListGroup);\n;// CONCATENATED MODULE: ./src/list/ListGroupSubheader.jsx\nvar ListGroupSubheader_excluded = ["title", "element", "className", "children"];\n\nfunction ListGroupSubheader_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction ListGroupSubheader_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ListGroupSubheader_ownKeys(Object(source), true).forEach(function (key) { ListGroupSubheader_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ListGroupSubheader_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction ListGroupSubheader_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction ListGroupSubheader_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = ListGroupSubheader_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction ListGroupSubheader_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\n\nvar ListGroupSubheader = /*#__PURE__*/(0,react.forwardRef)(function (_ref, ref) {\n  var title = _ref.title,\n      _ref$element = _ref.element,\n      Element = _ref$element === void 0 ? \'h3\' : _ref$element,\n      className = _ref.className,\n      _ref$children = _ref.children,\n      children = _ref$children === void 0 ? title : _ref$children,\n      props = ListGroupSubheader_objectWithoutProperties(_ref, ListGroupSubheader_excluded);\n\n  var classNames = classnames_default()(listGroupCssClasses.SUBHEADER, className);\n  return /*#__PURE__*/(0,jsx_runtime.jsx)(Element, ListGroupSubheader_objectSpread(ListGroupSubheader_objectSpread({\n    ref: ref,\n    className: classNames\n  }, props), {}, {\n    children: children\n  }));\n});\nListGroupSubheader.displayName = \'MDCListGroupSubheader\';\nListGroupSubheader.propTypes = {\n  title: (prop_types_default()).string\n};\n/* harmony default export */ const list_ListGroupSubheader = (ListGroupSubheader);\n;// CONCATENATED MODULE: ./src/list/index.js\n\n\n\n\n\n\n\n\nlist_List.Item = list_ListItem;\nlist_List.Divider = list_ListDivider;\nlist_List.Group = list_ListGroup;\nlist_ListGroup.Subheader = list_ListGroupSubheader;\nlist_ListItem.Content = list_ListItemContent;\nlist_ListItem.End = list_ListItemEnd;\nlist_ListItem.Start = list_ListItemStart;\n\n;// CONCATENATED MODULE: ./src/menu/MenuItem.jsx\nvar MenuItem_excluded = ["selected", "disabled", "className"];\n\nfunction MenuItem_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction MenuItem_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { MenuItem_ownKeys(Object(source), true).forEach(function (key) { MenuItem_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { MenuItem_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction MenuItem_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction MenuItem_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = MenuItem_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction MenuItem_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\n\nvar MenuItem = /*#__PURE__*/(0,react.forwardRef)(function (_ref, ref) {\n  var _ref$selected = _ref.selected,\n      selected = _ref$selected === void 0 ? false : _ref$selected,\n      _ref$disabled = _ref.disabled,\n      disabled = _ref$disabled === void 0 ? false : _ref$disabled,\n      className = _ref.className,\n      props = MenuItem_objectWithoutProperties(_ref, MenuItem_excluded);\n\n  var classNames = classnames_default()(menu_constants_cssClasses.ITEM, MenuItem_defineProperty({}, menu_constants_cssClasses.ITEM_SELECTED, selected), className);\n  return /*#__PURE__*/(0,jsx_runtime.jsx)(list_ListItem, MenuItem_objectSpread({\n    ref: ref,\n    role: "menuitem",\n    className: classNames,\n    selected: selected,\n    disabled: disabled,\n    "data-disabled": disabled || undefined,\n    tabIndex: disabled ? \'-1\' : undefined\n  }, props));\n});\nMenuItem.displayName = \'MDCMenuItem\';\nMenuItem.propTypes = MenuItem_objectSpread({}, list_ListItem.propTypes);\n/* harmony default export */ const menu_MenuItem = (MenuItem);\n;// CONCATENATED MODULE: ./src/modal/constants.js\nvar modal_constants_cssClasses = {\n  ROOT: \'mdc-modal\',\n  FIXED: \'mdc-modal--fixed\'\n};\n;// CONCATENATED MODULE: ./src/modal/Modal.jsx\n\n\n\n\nfunction Modal(_ref) {\n  var _ref$fixed = _ref.fixed,\n      fixed = _ref$fixed === void 0 ? false : _ref$fixed,\n      _ref$element = _ref.element,\n      element = _ref$element === void 0 ? \'div\' : _ref$element,\n      children = _ref.children;\n  var rootRef = (0,react.useRef)(document.createElement(element));\n  (0,react.useEffect)(function () {\n    var root = rootRef.current;\n    var activeElement = document.activeElement;\n    root.className = modal_constants_cssClasses.ROOT;\n\n    if (fixed) {\n      root.classList.add(modal_constants_cssClasses.FIXED);\n    }\n\n    document.body.appendChild(root);\n    root.firstChild.focus();\n    return function () {\n      activeElement.focus();\n      document.body.removeChild(root);\n    };\n  }, [fixed]);\n  return /*#__PURE__*/(0,react_dom.createPortal)(children, rootRef.current);\n}\nModal.displayName = \'MDCModal\';\nModal.propTypes = {\n  fixed: (prop_types_default()).bool,\n  element: (prop_types_default()).string,\n  children: (prop_types_default()).node.isRequired\n};\n;// CONCATENATED MODULE: ./src/modal/index.js\n\n;// CONCATENATED MODULE: ./src/layer/Layer.jsx\nvar Layer_excluded = ["modal", "fixed", "children"];\n\nfunction Layer_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction Layer_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { Layer_ownKeys(Object(source), true).forEach(function (key) { Layer_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { Layer_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction Layer_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction Layer_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = Layer_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction Layer_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\nfunction Layer(_ref) {\n  var _ref$modal = _ref.modal,\n      modal = _ref$modal === void 0 ? false : _ref$modal,\n      _ref$fixed = _ref.fixed,\n      fixed = _ref$fixed === void 0 ? false : _ref$fixed,\n      children = _ref.children,\n      props = Layer_objectWithoutProperties(_ref, Layer_excluded);\n\n  return /*#__PURE__*/(0,jsx_runtime.jsx)(esm_CSSTransition, Layer_objectSpread(Layer_objectSpread({}, props), {}, {\n    children: modal ? /*#__PURE__*/(0,jsx_runtime.jsx)(Modal, {\n      fixed: fixed,\n      children: children\n    }) : children\n  }));\n}\nLayer.displayName = \'MDCLayer\';\nLayer.propTypes = {\n  modal: (prop_types_default()).bool,\n  fixed: (prop_types_default()).bool\n};\n;// CONCATENATED MODULE: ./src/layer/index.js\n\n;// CONCATENATED MODULE: ./src/menu/utils.js\nfunction utils_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { utils_typeof = function _typeof(obj) { return typeof obj; }; } else { utils_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return utils_typeof(obj); }\n\nvar defaultValues = {\n  top: false,\n  bottom: false,\n  center: false,\n  left: false,\n  right: false\n};\nfunction getAnchorOrigin() {\n  var anchorOrigin = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \'\';\n\n  if (utils_typeof(anchorOrigin) === \'object\') {\n    return Object.assign({}, defaultValues, anchorOrigin);\n  }\n\n  var keys = anchorOrigin.split(\' \');\n  var values = keys.reduce(function (result, key) {\n    result[key] = true;\n    return result;\n  }, {});\n  return Object.assign({}, defaultValues, values);\n}\n;// CONCATENATED MODULE: ./src/menu/MenuSurface.jsx\nvar MenuSurface_excluded = ["anchor", "anchorRef", "anchorOrigin", "transformOrigin", "open", "modal", "quick", "fixed", "persistent", "fullWidth", "onClose", "onKeyDown", "className"];\n\nfunction MenuSurface_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction MenuSurface_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { MenuSurface_ownKeys(Object(source), true).forEach(function (key) { MenuSurface_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { MenuSurface_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction MenuSurface_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction MenuSurface_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = MenuSurface_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction MenuSurface_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\n\n\n\n\n\n\n\nvar MenuSurface = /*#__PURE__*/(0,react.forwardRef)(function (_ref, ref) {\n  var _classnames;\n\n  var anchor = _ref.anchor,\n      _anchorRef = _ref.anchorRef,\n      _ref$anchorOrigin = _ref.anchorOrigin,\n      _anchorOrigin = _ref$anchorOrigin === void 0 ? Origin.TOP_LEFT : _ref$anchorOrigin,\n      _ref$transformOrigin = _ref.transformOrigin,\n      _transformOrigin = _ref$transformOrigin === void 0 ? _anchorOrigin : _ref$transformOrigin,\n      _ref$open = _ref.open,\n      open = _ref$open === void 0 ? false : _ref$open,\n      _ref$modal = _ref.modal,\n      modal = _ref$modal === void 0 ? false : _ref$modal,\n      _ref$quick = _ref.quick,\n      quick = _ref$quick === void 0 ? false : _ref$quick,\n      _ref$fixed = _ref.fixed,\n      fixed = _ref$fixed === void 0 ? false : _ref$fixed,\n      _ref$persistent = _ref.persistent,\n      persistent = _ref$persistent === void 0 ? false : _ref$persistent,\n      _ref$fullWidth = _ref.fullWidth,\n      fullWidth = _ref$fullWidth === void 0 ? false : _ref$fullWidth,\n      _ref$onClose = _ref.onClose,\n      onClose = _ref$onClose === void 0 ? Function.prototype : _ref$onClose,\n      _ref$onKeyDown = _ref.onKeyDown,\n      onKeyDown = _ref$onKeyDown === void 0 ? Function.prototype : _ref$onKeyDown,\n      className = _ref.className,\n      props = MenuSurface_objectWithoutProperties(_ref, MenuSurface_excluded);\n\n  var rootRef = (0,react.useRef)();\n  var anchorRef = (0,react.useRef)(_anchorRef === null || _anchorRef === void 0 ? void 0 : _anchorRef.current);\n  (0,react.useImperativeHandle)(ref, function () {\n    return rootRef.current;\n  });\n  (0,react.useEffect)(function () {\n    if (!_anchorRef) return;\n    anchorRef.current = _anchorRef.current;\n  }, [_anchorRef]);\n  useUpdated(function () {\n    if (!open || persistent) return;\n\n    function handleBodyClick(event) {\n      onClose(event);\n    }\n\n    document.body.addEventListener(\'click\', handleBodyClick, true);\n    return function () {\n      document.body.removeEventListener(\'click\', handleBodyClick, true);\n    };\n  }, [open, persistent, onClose]);\n  useUpdated(function () {\n    if (!open || !rootRef.current || !anchorRef.current) return;\n    var anchor = anchorRef.current;\n    var _rootRef$current = rootRef.current,\n        width = _rootRef$current.clientWidth,\n        height = _rootRef$current.clientHeight;\n    var anchorClientRect = anchor.getBoundingClientRect();\n    var anchorDimensions = modal ? anchorClientRect : {\n      top: anchor.offsetTop,\n      left: anchor.offsetLeft,\n      bottom: anchor.offsetTop + anchor.offsetHeight,\n      right: anchor.offsetLeft + anchor.offsetWidth,\n      width: anchor.offsetWidth,\n      height: anchor.offsetHeight\n    };\n    var style = {\n      top: anchorDimensions.top,\n      left: anchorDimensions.left,\n      width: fullWidth ? \'100%\' : undefined,\n      maxWidth: fullWidth ? "".concat(anchorDimensions.width, "px") : undefined,\n      position: fixed ? \'fixed\' : \'absolute\',\n      transformOrigin: _transformOrigin\n    };\n    var scrollY = modal && !fixed ? window.scrollY : 0;\n    var scrollX = modal && !fixed ? window.scrollX : 0;\n    var anchorOrigin = getAnchorOrigin(_anchorOrigin);\n    var transformOrigin = getAnchorOrigin(_transformOrigin);\n\n    if (anchorOrigin.top) {\n      style.top = anchorDimensions.top;\n    } else if (anchorOrigin.bottom) {\n      style.top = anchorDimensions.bottom;\n    }\n\n    if (anchorOrigin.left) {\n      style.left = anchorDimensions.left;\n    } else if (anchorOrigin.right) {\n      style.left = anchorDimensions.right;\n    }\n\n    if (transformOrigin.top) {\n      var top = scrollY + style.top;\n      var bottomOverflow = scrollY + (anchorOrigin.bottom ? anchorClientRect.bottom : anchorClientRect.top) + height - window.innerHeight;\n      style.top = bottomOverflow > 0 ? top - bottomOverflow : top;\n    } else if (transformOrigin.bottom) {\n      var _top = scrollY + style.top - height;\n\n      var topOverflow = scrollY + (anchorOrigin.bottom ? anchorClientRect.bottom : anchorClientRect.top) - height;\n      style.top = topOverflow > 0 ? _top : 0;\n    }\n\n    if (transformOrigin.left) {\n      var left = style.left;\n      var rightOverflow = scrollX + window.innerWidth - (anchorOrigin.left ? anchorClientRect.left : anchorClientRect.right) + width;\n      style.left = rightOverflow > 0 ? left : left - Math.abs(rightOverflow);\n    } else if (transformOrigin.right) {\n      var _left = style.left - width;\n\n      var leftOverflow = scrollX + (anchorOrigin.right ? anchorClientRect.right : anchorClientRect.left) - width;\n      style.left = leftOverflow > 0 ? _left : 0;\n    }\n\n    rootRef.current.style.top = "".concat(style.top, "px");\n    rootRef.current.style.left = "".concat(style.left, "px");\n    rootRef.current.style.position = style.position;\n    rootRef.current.style.width = style.width;\n    rootRef.current.style.maxWidth = style.maxWidth;\n    rootRef.current.style.transformOrigin = style.transformOrigin;\n  }, [open, modal, fixed, _anchorOrigin, _transformOrigin]);\n  var handleKeyDown = (0,react.useCallback)(function (event) {\n    if (event.key === \'Escape\' && !persistent) {\n      event.stopPropagation();\n      onClose(event);\n    }\n\n    onKeyDown(event);\n  }, [persistent, onKeyDown, onClose]);\n\n  var isBelowAnchor = _anchorOrigin.includes(\'bottom\') && _transformOrigin.includes(\'top\');\n\n  var classNames = classnames_default()(menu_constants_cssClasses.SURFACE, (_classnames = {}, MenuSurface_defineProperty(_classnames, menu_constants_cssClasses.SURFACE_FIXED, fixed), MenuSurface_defineProperty(_classnames, menu_constants_cssClasses.SURFACE_BELOW_ANCHOR, isBelowAnchor), _classnames), className);\n  return /*#__PURE__*/(0,jsx_runtime.jsxs)(jsx_runtime.Fragment, {\n    children: [anchor && (0,react.cloneElement)(anchor, {\n      ref: anchorRef\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Layer, {\n      "in": open,\n      modal: modal,\n      timeout: quick ? 0 : {\n        enter: menu_constants_numbers.TRANSITION_OPEN_DURATION,\n        exit: menu_constants_numbers.TRANSITION_CLOSE_DURATION\n      },\n      classNames: quick ? {\n        enterDone: menu_constants_cssClasses.SURFACE_OPEN\n      } : {\n        enter: menu_constants_cssClasses.SURFACE_ANIMATING_OPEN,\n        enterActive: menu_constants_cssClasses.SURFACE_ANIMATING_OPEN,\n        enterDone: menu_constants_cssClasses.SURFACE_OPEN,\n        exit: menu_constants_cssClasses.SURFACE_OPEN,\n        exitActive: menu_constants_cssClasses.SURFACE_ANIMATING_CLOSED\n      },\n      mountOnEnter: true,\n      unmountOnExit: true,\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)("div", MenuSurface_objectSpread({\n        ref: rootRef,\n        className: classNames,\n        onKeyDown: handleKeyDown\n      }, props))\n    })]\n  });\n});\nMenuSurface.displayName = \'MDCMenuSurface\';\nMenuSurface.propTypes = {\n  anchor: (prop_types_default()).element,\n  anchorRef: (prop_types_default()).object,\n  anchorOrigin: prop_types_default().oneOf(Object.values(Origin)),\n  open: (prop_types_default()).bool,\n  modal: (prop_types_default()).bool,\n  quick: (prop_types_default()).bool,\n  fixed: (prop_types_default()).bool,\n  persistent: (prop_types_default()).bool,\n  fullWidth: (prop_types_default()).bool,\n  onClose: (prop_types_default()).func\n};\n/* harmony default export */ const menu_MenuSurface = (MenuSurface);\n;// CONCATENATED MODULE: ./src/menu/Menu.jsx\nvar Menu_excluded = ["open", "items", "listProps", "children", "className"];\n\nfunction Menu_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction Menu_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { Menu_ownKeys(Object(source), true).forEach(function (key) { Menu_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { Menu_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction Menu_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction Menu_slicedToArray(arr, i) { return Menu_arrayWithHoles(arr) || Menu_iterableToArrayLimit(arr, i) || Menu_unsupportedIterableToArray(arr, i) || Menu_nonIterableRest(); }\n\nfunction Menu_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction Menu_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return Menu_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return Menu_arrayLikeToArray(o, minLen); }\n\nfunction Menu_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction Menu_iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction Menu_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction Menu_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = Menu_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction Menu_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\n\n\n\n\n\n\nvar Menu = /*#__PURE__*/(0,react.forwardRef)(function (_ref, ref) {\n  var open = _ref.open,\n      items = _ref.items,\n      _ref$listProps = _ref.listProps,\n      listProps = _ref$listProps === void 0 ? {} : _ref$listProps,\n      _ref$children = _ref.children,\n      children = _ref$children === void 0 ? items === null || items === void 0 ? void 0 : items.map(function (item) {\n    return (0,react.createElement)(menu_MenuItem, item);\n  }) : _ref$children,\n      className = _ref.className,\n      props = Menu_objectWithoutProperties(_ref, Menu_excluded);\n\n  var listRef = (0,react.useRef)();\n\n  var _useState = (0,react.useState)(0),\n      _useState2 = Menu_slicedToArray(_useState, 2),\n      focusedChildIndex = _useState2[0],\n      setFocusedChildIndex = _useState2[1];\n\n  (0,react.useEffect)(function () {\n    if (open) {\n      setFocusedChildIndex(react.Children.toArray(children).findIndex(function (i) {\n        return i.props.selected;\n      }));\n    }\n  }, [open, children]);\n  useUpdated(function () {\n    if (open) {\n      var _listRef$current$chil;\n\n      (_listRef$current$chil = listRef.current.children[focusedChildIndex]) === null || _listRef$current$chil === void 0 ? void 0 : _listRef$current$chil.focus();\n    }\n  }, [focusedChildIndex, open]);\n  var handleKeyDown = (0,react.useCallback)(function (event) {\n    event.preventDefault();\n\n    if (event.key === \'ArrowDown\') {\n      setFocusedChildIndex(function (index) {\n        var nextIndex = index + 1;\n        return nextIndex < listRef.current.children.length ? nextIndex : index;\n      });\n    } else if (event.key === \'ArrowUp\') {\n      setFocusedChildIndex(function (index) {\n        var nextIndex = index - 1;\n        return nextIndex >= 0 ? nextIndex : index;\n      });\n    }\n  }, []);\n  var classNames = classnames_default()(menu_constants_cssClasses.ROOT, className);\n  return /*#__PURE__*/(0,jsx_runtime.jsx)(menu_MenuSurface, Menu_objectSpread(Menu_objectSpread({\n    ref: ref,\n    open: open,\n    className: classNames,\n    onKeyDown: handleKeyDown\n  }, props), {}, {\n    children: /*#__PURE__*/(0,jsx_runtime.jsx)(list_List, Menu_objectSpread(Menu_objectSpread({\n      ref: listRef,\n      role: "menu",\n      "aria-hidden": "true",\n      "aria-orientation": "vertical",\n      tabIndex: open ? 0 : -1\n    }, listProps), {}, {\n      children: react.Children.map(children, function (item, index) {\n        return /*#__PURE__*/(0,jsx_runtime.jsx)(Clone, {\n          component: item,\n          tabIndex: index === focusedChildIndex ? 0 : -1\n        });\n      })\n    }))\n  }));\n});\nMenu.displayName = \'MDCMenu\';\nMenu.propTypes = Menu_objectSpread(Menu_objectSpread({}, menu_MenuSurface.propTypes), {}, {\n  listProps: (prop_types_default()).object\n});\n/* harmony default export */ const menu_Menu = (Menu);\n;// CONCATENATED MODULE: ./src/menu/MenuAnchor.jsx\nvar MenuAnchor_excluded = ["wrap", "element", "className", "children"];\n\nfunction MenuAnchor_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction MenuAnchor_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { MenuAnchor_ownKeys(Object(source), true).forEach(function (key) { MenuAnchor_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { MenuAnchor_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction MenuAnchor_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction MenuAnchor_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = MenuAnchor_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction MenuAnchor_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\nvar MenuAnchor = /*#__PURE__*/(0,react.forwardRef)(function (_ref, ref) {\n  var _ref$wrap = _ref.wrap,\n      wrap = _ref$wrap === void 0 ? true : _ref$wrap,\n      _ref$element = _ref.element,\n      element = _ref$element === void 0 ? \'div\' : _ref$element,\n      className = _ref.className,\n      children = _ref.children,\n      props = MenuAnchor_objectWithoutProperties(_ref, MenuAnchor_excluded);\n\n  return wrap ? (0,react.createElement)(element, MenuAnchor_objectSpread({\n    ref: ref,\n    className: classnames_default()(menu_constants_cssClasses.SURFACE_ANCHOR, className)\n  }, props), children) : (0,react.cloneElement)(children, MenuAnchor_objectSpread({\n    ref: ref,\n    className: classnames_default()(children.props.className, menu_constants_cssClasses.SURFACE_ANCHOR)\n  }, props));\n});\nMenuAnchor.displayName = \'MDCMenuAnchor\';\n/* harmony default export */ const menu_MenuAnchor = (MenuAnchor);\n;// CONCATENATED MODULE: ./src/menu/MenuSelectionGroup.jsx\nvar MenuSelectionGroup_excluded = ["element"];\n\nfunction MenuSelectionGroup_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction MenuSelectionGroup_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { MenuSelectionGroup_ownKeys(Object(source), true).forEach(function (key) { MenuSelectionGroup_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { MenuSelectionGroup_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction MenuSelectionGroup_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction MenuSelectionGroup_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = MenuSelectionGroup_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction MenuSelectionGroup_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\nvar MenuSelectionGroup = /*#__PURE__*/(0,react.forwardRef)(function (_ref, ref) {\n  var _ref$element = _ref.element,\n      Element = _ref$element === void 0 ? \'ul\' : _ref$element,\n      props = MenuSelectionGroup_objectWithoutProperties(_ref, MenuSelectionGroup_excluded);\n\n  return /*#__PURE__*/(0,jsx_runtime.jsx)("li", {\n    ref: ref,\n    children: /*#__PURE__*/(0,jsx_runtime.jsx)(Element, MenuSelectionGroup_objectSpread({\n      className: "mdc-menu__selection-group"\n    }, props))\n  });\n});\nMenuSelectionGroup.displayName = \'MDCMenuSelectionGroup\';\n/* harmony default export */ const menu_MenuSelectionGroup = (MenuSelectionGroup);\n;// CONCATENATED MODULE: ./src/menu/MenuSelectionGroupIcon.jsx\nfunction MenuSelectionGroupIcon_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction MenuSelectionGroupIcon_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { MenuSelectionGroupIcon_ownKeys(Object(source), true).forEach(function (key) { MenuSelectionGroupIcon_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { MenuSelectionGroupIcon_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction MenuSelectionGroupIcon_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n\n\nfunction MenuSelectionGroupIcon(props) {\n  return /*#__PURE__*/(0,jsx_runtime.jsx)(icon_Icon, MenuSelectionGroupIcon_objectSpread({\n    className: "mdc-menu__selection-group-icon"\n  }, props));\n}\nMenuSelectionGroupIcon.displayName = \'MDCMenuSelectionGroupIcon\';\n;// CONCATENATED MODULE: ./src/menu/index.js\n\n\n\n\n\n\n\nmenu_Menu.Anchor = menu_MenuAnchor;\nmenu_Menu.Item = menu_MenuItem;\nmenu_Menu.Origin = Origin;\nmenu_Menu.Surface = menu_MenuSurface;\nmenu_Menu.SelectionGroup = menu_MenuSelectionGroup;\nmenu_Menu.SelectionGroupIcon = MenuSelectionGroupIcon;\n\n;// CONCATENATED MODULE: ./src/select/constants.js\nvar select_constants_cssClasses = {\n  ROOT: \'mdc-select\',\n  FILLED: \'mdc-select--filled\',\n  OUTLINED: \'mdc-select--outlined\',\n  ACTIVATED: \'mdc-select--activated\',\n  DISABLED: \'mdc-select--disabled\',\n  FOCUSED: \'mdc-select--focused\',\n  REQUIRED: \'mdc-select--required\',\n  INVALID: \'mdc-select--invalid\',\n  NO_LABEL: \'mdc-select--no-label\',\n  WITH_LEADING_ICON: \'mdc-select--with-leading-icon\',\n  SELECTED_TEXT: \'mdc-select__selected-text\',\n  SELECTED_TEXT_CONTAINER: \'mdc-select__selected-text-container\',\n  DROPDOWN_ICON: \'mdc-select__dropdown-icon\',\n  DROPDOWN_ICON_GRAPHIC: \'mdc-select__dropdown-icon-graphic\',\n  DROPDOWN_ICON_INACTIVE: \'mdc-select__dropdown-icon-inactive\',\n  DROPDOWN_ICON_ACTIVE: \'mdc-select__dropdown-icon-active\',\n  ICON: \'mdc-select__icon\',\n  MENU: \'mdc-select__menu\',\n  MENU_INVALID: \'mdc-select__menu--invalid\',\n  RIPPLE: \'mdc-select__ripple\',\n  ANCHOR: \'mdc-select__anchor\',\n  HELPER_TEXT: \'mdc-select-helper-text\',\n  VALIDATION_MESSAGE: \'mdc-select-helper-text--validation-msg\',\n  VALIDATION_MESSAGE_PERSISTENT: \'mdc-select-helper-text--validation-msg-persistent\'\n};\n;// CONCATENATED MODULE: ./src/select/DropdownIcon.jsx\n\n\n\n\nvar DropdownIcon = function DropdownIcon() {\n  return /*#__PURE__*/(0,jsx_runtime.jsx)("span", {\n    className: select_constants_cssClasses.DROPDOWN_ICON,\n    children: /*#__PURE__*/(0,jsx_runtime.jsxs)("svg", {\n      className: select_constants_cssClasses.DROPDOWN_ICON_GRAPHIC,\n      viewBox: "7 10 10 5",\n      focusable: "false",\n      children: [/*#__PURE__*/(0,jsx_runtime.jsx)("polygon", {\n        className: select_constants_cssClasses.DROPDOWN_ICON_INACTIVE,\n        stroke: "none",\n        fillRule: "evenodd",\n        points: "7 10 12 15 17 10"\n      }), /*#__PURE__*/(0,jsx_runtime.jsx)("polygon", {\n        className: select_constants_cssClasses.DROPDOWN_ICON_ACTIVE,\n        stroke: "none",\n        fillRule: "evenodd",\n        points: "7 15 12 10 17 15"\n      })]\n    })\n  });\n};\n\n/* harmony default export */ const select_DropdownIcon = (DropdownIcon);\n;// CONCATENATED MODULE: ./src/select/SelectOption.jsx\nvar SelectOption_excluded = ["selected", "checkbox", "onClick"];\n\nfunction SelectOption_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction SelectOption_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { SelectOption_ownKeys(Object(source), true).forEach(function (key) { SelectOption_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { SelectOption_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction SelectOption_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction SelectOption_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = SelectOption_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction SelectOption_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\nvar SelectOption = /*#__PURE__*/(0,react.forwardRef)(function (_ref, ref) {\n  var selected = _ref.selected,\n      _ref$checkbox = _ref.checkbox,\n      checkbox = _ref$checkbox === void 0 ? false : _ref$checkbox,\n      onClick = _ref.onClick,\n      props = SelectOption_objectWithoutProperties(_ref, SelectOption_excluded);\n\n  return /*#__PURE__*/(0,jsx_runtime.jsx)(menu_MenuItem, SelectOption_objectSpread({\n    ref: ref,\n    start: checkbox && /*#__PURE__*/(0,jsx_runtime.jsx)(checkbox_Checkbox, {\n      checked: selected\n    }),\n    selected: selected,\n    withLeadingCheckbox: checkbox,\n    onClick: onClick\n  }, props));\n});\nSelectOption.displayName = \'MDCSelectOption\';\n/* harmony default export */ const select_SelectOption = (SelectOption);\n;// CONCATENATED MODULE: ./src/select/HelperText.jsx\nvar HelperText_excluded = ["validation", "persistent", "element"];\n\nfunction HelperText_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction HelperText_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { HelperText_ownKeys(Object(source), true).forEach(function (key) { HelperText_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { HelperText_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction HelperText_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction HelperText_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = HelperText_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction HelperText_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\n\nvar HelperText = function HelperText(_ref) {\n  var _classnames;\n\n  var _ref$validation = _ref.validation,\n      validation = _ref$validation === void 0 ? false : _ref$validation,\n      _ref$persistent = _ref.persistent,\n      persistent = _ref$persistent === void 0 ? false : _ref$persistent,\n      _ref$element = _ref.element,\n      Element = _ref$element === void 0 ? \'p\' : _ref$element,\n      props = HelperText_objectWithoutProperties(_ref, HelperText_excluded);\n\n  var classNames = classnames_default()(select_constants_cssClasses.HELPER_TEXT, (_classnames = {}, HelperText_defineProperty(_classnames, select_constants_cssClasses.VALIDATION_MESSAGE, validation), HelperText_defineProperty(_classnames, select_constants_cssClasses.VALIDATION_MESSAGE_PERSISTENT, persistent), _classnames));\n  return /*#__PURE__*/(0,jsx_runtime.jsx)(Element, HelperText_objectSpread({\n    className: classNames\n  }, props));\n};\n\nHelperText.displayName = \'MDCSelectHelperText\';\nHelperText.propTypes = {\n  persistent: (prop_types_default()).bool,\n  validation: (prop_types_default()).bool\n};\n/* harmony default export */ const select_HelperText = (HelperText);\n;// CONCATENATED MODULE: ./src/select/Select.jsx\nvar Select_excluded = ["name", "value", "options", "label", "icon", "leadingIcon", "helperText", "filled", "outlined", "multiple", "disabled", "required", "onChange", "menuProps", "listProps", "helperTextProps", "className", "children"];\n\nfunction Select_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction Select_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { Select_ownKeys(Object(source), true).forEach(function (key) { Select_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { Select_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction Select_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || Select_unsupportedIterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return Select_arrayLikeToArray(arr); }\n\nfunction Select_slicedToArray(arr, i) { return Select_arrayWithHoles(arr) || Select_iterableToArrayLimit(arr, i) || Select_unsupportedIterableToArray(arr, i) || Select_nonIterableRest(); }\n\nfunction Select_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction Select_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return Select_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return Select_arrayLikeToArray(o, minLen); }\n\nfunction Select_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction Select_iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction Select_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction Select_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = Select_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction Select_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nvar Select = /*#__PURE__*/(0,react.forwardRef)(function (_ref, ref) {\n  var _classnames;\n\n  var name = _ref.name,\n      value = _ref.value,\n      options = _ref.options,\n      label = _ref.label,\n      icon = _ref.icon,\n      _ref$leadingIcon = _ref.leadingIcon,\n      leadingIcon = _ref$leadingIcon === void 0 ? icon : _ref$leadingIcon,\n      helperText = _ref.helperText,\n      _ref$filled = _ref.filled,\n      filled = _ref$filled === void 0 ? false : _ref$filled,\n      _ref$outlined = _ref.outlined,\n      outlined = _ref$outlined === void 0 ? false : _ref$outlined,\n      _ref$multiple = _ref.multiple,\n      multiple = _ref$multiple === void 0 ? isArray(value) : _ref$multiple,\n      _ref$disabled = _ref.disabled,\n      disabled = _ref$disabled === void 0 ? false : _ref$disabled,\n      _ref$required = _ref.required,\n      required = _ref$required === void 0 ? false : _ref$required,\n      _ref$onChange = _ref.onChange,\n      onChange = _ref$onChange === void 0 ? Function.prototype : _ref$onChange,\n      _ref$menuProps = _ref.menuProps,\n      menuProps = _ref$menuProps === void 0 ? {} : _ref$menuProps,\n      _ref$listProps = _ref.listProps,\n      listProps = _ref$listProps === void 0 ? {} : _ref$listProps,\n      _ref$helperTextProps = _ref.helperTextProps,\n      helperTextProps = _ref$helperTextProps === void 0 ? {} : _ref$helperTextProps,\n      className = _ref.className,\n      _ref$children = _ref.children,\n      children = _ref$children === void 0 ? options === null || options === void 0 ? void 0 : options.map(function (option) {\n    return (0,react.createElement)(select_SelectOption, option);\n  }) : _ref$children,\n      props = Select_objectWithoutProperties(_ref, Select_excluded);\n\n  var anchorRef = (0,react.useRef)();\n  var inputRef = (0,react.useRef)();\n  var menuRef = (0,react.useRef)();\n\n  var _useState = (0,react.useState)(false),\n      _useState2 = Select_slicedToArray(_useState, 2),\n      activated = _useState2[0],\n      setActivated = _useState2[1];\n\n  var _useState3 = (0,react.useState)(false),\n      _useState4 = Select_slicedToArray(_useState3, 2),\n      focused = _useState4[0],\n      setFocused = _useState4[1];\n\n  var _useState5 = (0,react.useState)(false),\n      _useState6 = Select_slicedToArray(_useState5, 2),\n      touched = _useState6[0],\n      setTouched = _useState6[1];\n\n  var _useState7 = (0,react.useState)(),\n      _useState8 = Select_slicedToArray(_useState7, 2),\n      selectedText = _useState8[0],\n      setSelectedText = _useState8[1];\n\n  var _useState9 = (0,react.useState)(),\n      _useState10 = Select_slicedToArray(_useState9, 2),\n      interactionCoords = _useState10[0],\n      setInteractionCoords = _useState10[1];\n\n  (0,react.useEffect)(function () {\n    if (multiple) {\n      var selectedOptions = react.Children.toArray(children).map(function (option) {\n        return option.props;\n      }).filter(function (option) {\n        return value.includes(option.value);\n      });\n\n      var _selectedText = selectedOptions.map(function (option) {\n        return option.text || option.children;\n      }).join(\', \');\n\n      setSelectedText(_selectedText);\n    } else {\n      var selectedOption = react.Children.toArray(children).map(function (option) {\n        return option.props;\n      }).find(function (option) {\n        return option.value === value;\n      });\n\n      if (selectedOption) {\n        setSelectedText(selectedOption.text || selectedOption.children);\n      }\n    }\n  }, [value, multiple, children]);\n  var handleAnchorClick = (0,react.useCallback)(function (event) {\n    if (activated) {\n      setActivated(false);\n      setFocused(false);\n    } else {\n      var targetClientRect = event.target.getBoundingClientRect();\n      setInteractionCoords({\n        x: event.clientX - targetClientRect.left,\n        y: event.clientY - targetClientRect.top\n      });\n      setActivated(true);\n      setFocused(true);\n    }\n  }, [activated]);\n  var handleOptionInteraction = (0,react.useCallback)(function (event) {\n    if (event.type === \'keydown\' && event.key !== \' \' && event.key !== \'Enter\') return;\n    var option = event.currentTarget.dataset;\n    if (option.disabled) return;\n\n    if (multiple) {\n      var values = new Set(value);\n      values.has(option.value) ? values["delete"](option.value) : values.add(option.value);\n      event.target = {\n        name: name,\n        value: _toConsumableArray(values)\n      };\n      onChange(event, _toConsumableArray(values));\n    } else {\n      event.target = {\n        name: name,\n        value: option.value\n      };\n      onChange(event, option.value);\n      setActivated(false);\n      setFocused(false);\n    }\n  }, [value, name, multiple, onChange]);\n  var handleMenuClose = (0,react.useCallback)(function (event) {\n    if (event.type === \'click\' && event.target === anchorRef.current) return;\n    if (multiple && event.type === \'click\' && event.path.includes(menuRef.current)) return;\n    setActivated(false);\n    setFocused(false);\n    setTouched(true);\n  }, [multiple]);\n  var handleKeyDown = (0,react.useCallback)(function (event) {\n    if (event.key === \' \' || event.key === \'Enter\' || event.key === \'ArrowDown\' || event.key === \'ArrowUp\') {\n      event.preventDefault();\n      event.stopPropagation();\n      setActivated(true);\n    }\n  }, []);\n  var hasValue = isArray(value) ? value.length > 0 : Boolean(value);\n  var focusedOrHasValue = focused || hasValue;\n  var isInvalid = touched && required && !hasValue;\n  var classNames = classnames_default()(select_constants_cssClasses.ROOT, (_classnames = {}, Select_defineProperty(_classnames, select_constants_cssClasses.FILLED, filled), Select_defineProperty(_classnames, select_constants_cssClasses.OUTLINED, outlined), Select_defineProperty(_classnames, select_constants_cssClasses.ACTIVATED, activated), Select_defineProperty(_classnames, select_constants_cssClasses.DISABLED, disabled), Select_defineProperty(_classnames, select_constants_cssClasses.FOCUSED, focused), Select_defineProperty(_classnames, select_constants_cssClasses.REQUIRED, required), Select_defineProperty(_classnames, select_constants_cssClasses.INVALID, isInvalid), Select_defineProperty(_classnames, select_constants_cssClasses.NO_LABEL, !label), Select_defineProperty(_classnames, select_constants_cssClasses.WITH_LEADING_ICON, leadingIcon), _classnames), className);\n  return /*#__PURE__*/(0,jsx_runtime.jsxs)(jsx_runtime.Fragment, {\n    children: [/*#__PURE__*/(0,jsx_runtime.jsxs)("div", {\n      ref: ref,\n      className: classNames,\n      children: [name && /*#__PURE__*/(0,jsx_runtime.jsx)("input", Select_objectSpread({\n        ref: inputRef,\n        type: "hidden",\n        name: name,\n        value: value,\n        required: required,\n        disabled: disabled\n      }, props)), /*#__PURE__*/(0,jsx_runtime.jsxs)("div", {\n        ref: anchorRef,\n        className: select_constants_cssClasses.ANCHOR,\n        "aria-required": required || undefined,\n        tabIndex: !disabled ? 0 : undefined,\n        onKeyDown: handleKeyDown,\n        onClick: handleAnchorClick,\n        children: [filled && /*#__PURE__*/(0,jsx_runtime.jsx)("div", {\n          className: select_constants_cssClasses.RIPPLE\n        }), filled && label && /*#__PURE__*/(0,jsx_runtime.jsx)(floating_label_FloatingLabel, {\n          label: label,\n          "float": focusedOrHasValue\n        }), outlined && /*#__PURE__*/(0,jsx_runtime.jsx)(notched_outline_NotchedOutline, {\n          notched: focusedOrHasValue,\n          children: label && /*#__PURE__*/(0,jsx_runtime.jsx)(floating_label_FloatingLabel, {\n            label: label,\n            "float": focusedOrHasValue\n          })\n        }), leadingIcon && /*#__PURE__*/(0,jsx_runtime.jsx)(Clone, {\n          component: leadingIcon,\n          fallback: icon_Icon,\n          className: select_constants_cssClasses.ICON,\n          tabIndex: "0",\n          role: "button"\n        }), /*#__PURE__*/(0,jsx_runtime.jsx)("span", {\n          className: select_constants_cssClasses.SELECTED_TEXT_CONTAINER,\n          children: /*#__PURE__*/(0,jsx_runtime.jsx)("span", {\n            className: select_constants_cssClasses.SELECTED_TEXT,\n            children: selectedText\n          })\n        }), /*#__PURE__*/(0,jsx_runtime.jsx)(select_DropdownIcon, {}), filled && /*#__PURE__*/(0,jsx_runtime.jsx)(line_ripple_LineRipple, {\n          active: focused,\n          transformOrigin: interactionCoords === null || interactionCoords === void 0 ? void 0 : interactionCoords.x\n        })]\n      }), /*#__PURE__*/(0,jsx_runtime.jsx)(menu_Menu, Select_objectSpread(Select_objectSpread({\n        ref: menuRef,\n        anchorRef: anchorRef,\n        className: select_constants_cssClasses.MENU,\n        open: activated,\n        anchorOrigin: Origin.BOTTOM_CENTER,\n        transformOrigin: Origin.TOP_CENTER,\n        fullWidth: true,\n        listProps: listProps,\n        onClose: handleMenuClose\n      }, menuProps), {}, {\n        children: react.Children.map(children, function (option) {\n          var optionValue = option.props.value;\n          return (0,react.cloneElement)(option, {\n            value: undefined,\n            \'data-value\': optionValue,\n            selected: !isUndefined(value) && (multiple ? value.includes(optionValue) : optionValue === value),\n            checkbox: multiple,\n            onClick: handleOptionInteraction,\n            onKeyDown: handleOptionInteraction\n          });\n        })\n      }))]\n    }), helperText && /*#__PURE__*/(0,jsx_runtime.jsx)(select_HelperText, Select_objectSpread(Select_objectSpread({}, helperTextProps), {}, {\n      children: helperText\n    }))]\n  });\n});\nSelect.displayName = \'MDCSelect\';\nSelect.propTypes = {\n  value: (prop_types_default()).any,\n  options: prop_types_default().arrayOf((prop_types_default()).object),\n  label: (prop_types_default()).string,\n  leadingIcon: (prop_types_default()).element,\n  helperText: (prop_types_default()).string,\n  filled: (prop_types_default()).bool,\n  outlined: (prop_types_default()).bool,\n  multiple: (prop_types_default()).bool,\n  disabled: (prop_types_default()).bool,\n  required: (prop_types_default()).bool,\n  children: prop_types_default().oneOfType([(prop_types_default()).element, prop_types_default().arrayOf((prop_types_default()).element)]),\n  menuProps: (prop_types_default()).object,\n  helperTextProps: (prop_types_default()).object,\n  onChange: (prop_types_default()).func\n};\n/* harmony default export */ const select_Select = (Select);\n;// CONCATENATED MODULE: ./src/select/index.js\n\n\nselect_Select.Option = select_SelectOption;\n\n;// CONCATENATED MODULE: ./src/data-table/DataTablePagination.jsx\nvar DataTablePagination_excluded = ["totalCount", "currentPage", "rowsPerPage", "onFirstPage", "onPrevPage", "onNextPage", "onLastPage", "className"];\n\nfunction DataTablePagination_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction DataTablePagination_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { DataTablePagination_ownKeys(Object(source), true).forEach(function (key) { DataTablePagination_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { DataTablePagination_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction DataTablePagination_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction DataTablePagination_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = DataTablePagination_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction DataTablePagination_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\n\n\n\nvar DataTablePagination = /*#__PURE__*/(0,react.forwardRef)(function (_ref, ref) {\n  var totalCount = _ref.totalCount,\n      _ref$currentPage = _ref.currentPage,\n      currentPage = _ref$currentPage === void 0 ? 1 : _ref$currentPage,\n      _ref$rowsPerPage = _ref.rowsPerPage,\n      rowsPerPage = _ref$rowsPerPage === void 0 ? 10 : _ref$rowsPerPage,\n      _ref$onFirstPage = _ref.onFirstPage,\n      onFirstPage = _ref$onFirstPage === void 0 ? Function.prototype : _ref$onFirstPage,\n      _ref$onPrevPage = _ref.onPrevPage,\n      onPrevPage = _ref$onPrevPage === void 0 ? Function.prototype : _ref$onPrevPage,\n      _ref$onNextPage = _ref.onNextPage,\n      onNextPage = _ref$onNextPage === void 0 ? Function.prototype : _ref$onNextPage,\n      _ref$onLastPage = _ref.onLastPage,\n      onLastPage = _ref$onLastPage === void 0 ? Function.prototype : _ref$onLastPage,\n      className = _ref.className,\n      props = DataTablePagination_objectWithoutProperties(_ref, DataTablePagination_excluded);\n\n  var classNames = classnames_default()(data_table_constants_cssClasses.PAGINATION, className);\n  return /*#__PURE__*/(0,jsx_runtime.jsx)("div", DataTablePagination_objectSpread(DataTablePagination_objectSpread({\n    ref: ref,\n    className: classNames\n  }, props), {}, {\n    children: /*#__PURE__*/(0,jsx_runtime.jsxs)("div", {\n      className: data_table_constants_cssClasses.PAGINATION_TRAILING,\n      children: [/*#__PURE__*/(0,jsx_runtime.jsxs)("div", {\n        className: data_table_constants_cssClasses.PAGINATION_ROWS_PER_PAGE,\n        children: [/*#__PURE__*/(0,jsx_runtime.jsx)("div", {\n          className: data_table_constants_cssClasses.PAGINATION_ROWS_PER_PAGE_LABEL,\n          children: "\\u0420\\u044F\\u0434\\u043E\\u0432 \\u043D\\u0430 \\u0441\\u0442\\u0440."\n        }), /*#__PURE__*/(0,jsx_runtime.jsx)(select_Select, {\n          className: data_table_constants_cssClasses.PAGINATION_ROWS_PER_PAGE_SELECT,\n          options: [10, 25, 50, 100].map(function (value) {\n            return {\n              key: value,\n              text: value //selected: value === rowsPerPage\n\n            };\n          })\n        })]\n      }), /*#__PURE__*/(0,jsx_runtime.jsxs)("div", {\n        className: data_table_constants_cssClasses.PAGINATION_NAVIGATION,\n        children: [/*#__PURE__*/(0,jsx_runtime.jsxs)("div", {\n          className: data_table_constants_cssClasses.PAGINATION_TOTAL,\n          children: [currentPage, "\\u2011", rowsPerPage, " \\u0438\\u0437 ", totalCount]\n        }), /*#__PURE__*/(0,jsx_runtime.jsx)(icon_button_IconButton, {\n          className: data_table_constants_cssClasses.PAGINATION_BUTTON,\n          icon: "first_page",\n          onClick: onFirstPage\n        }), /*#__PURE__*/(0,jsx_runtime.jsx)(icon_button_IconButton, {\n          className: data_table_constants_cssClasses.PAGINATION_BUTTON,\n          icon: "chevron_left",\n          onClick: onPrevPage\n        }), /*#__PURE__*/(0,jsx_runtime.jsx)(icon_button_IconButton, {\n          className: data_table_constants_cssClasses.PAGINATION_BUTTON,\n          icon: "chevron_right",\n          onClick: onNextPage\n        }), /*#__PURE__*/(0,jsx_runtime.jsx)(icon_button_IconButton, {\n          className: data_table_constants_cssClasses.PAGINATION_BUTTON,\n          icon: "last_page",\n          onClick: onLastPage\n        })]\n      })]\n    })\n  }));\n});\nDataTablePagination.displayName = \'MDCDataTablePagination\';\n/* harmony default export */ const data_table_DataTablePagination = (DataTablePagination);\n;// CONCATENATED MODULE: ./src/data-table/DataTable.jsx\nvar DataTable_excluded = ["stickyHeader", "inProgress", "pagination", "className", "children"];\n\nfunction DataTable_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction DataTable_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { DataTable_ownKeys(Object(source), true).forEach(function (key) { DataTable_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { DataTable_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction DataTable_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction DataTable_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = DataTable_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction DataTable_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\n\n\n\n\nvar DataTable = /*#__PURE__*/(0,react.forwardRef)(function (_ref, ref) {\n  var _classnames;\n\n  var _ref$stickyHeader = _ref.stickyHeader,\n      stickyHeader = _ref$stickyHeader === void 0 ? false : _ref$stickyHeader,\n      _ref$inProgress = _ref.inProgress,\n      inProgress = _ref$inProgress === void 0 ? false : _ref$inProgress,\n      pagination = _ref.pagination,\n      className = _ref.className,\n      children = _ref.children,\n      props = DataTable_objectWithoutProperties(_ref, DataTable_excluded);\n\n  var classNames = classnames_default()(data_table_constants_cssClasses.ROOT, (_classnames = {}, DataTable_defineProperty(_classnames, data_table_constants_cssClasses.STICKY_HEADER, stickyHeader), DataTable_defineProperty(_classnames, data_table_constants_cssClasses.IN_PROGRESS, inProgress), _classnames), className);\n  return /*#__PURE__*/(0,jsx_runtime.jsxs)("div", DataTable_objectSpread(DataTable_objectSpread({\n    ref: ref,\n    className: classNames\n  }, props), {}, {\n    children: [/*#__PURE__*/(0,jsx_runtime.jsx)("div", {\n      className: data_table_constants_cssClasses.TABLE_CONTAINER,\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)("table", {\n        className: data_table_constants_cssClasses.TABLE,\n        children: children\n      })\n    }), inProgress && /*#__PURE__*/(0,jsx_runtime.jsx)(data_table_DataTableProgressIndicator, {}), pagination && /*#__PURE__*/(0,jsx_runtime.jsx)(data_table_DataTablePagination, DataTable_objectSpread({}, pagination))]\n  }));\n});\nDataTable.displayName = \'MDCDataTable\';\nDataTable.propTypes = {\n  stickyHeader: (prop_types_default()).bool,\n  inProgress: (prop_types_default()).bool\n};\n/* harmony default export */ const data_table_DataTable = (DataTable);\n;// CONCATENATED MODULE: ./src/data-table/DataTableCell.jsx\nvar DataTableCell_excluded = ["checkbox", "numeric", "element", "scope", "className", "children"];\n\nfunction DataTableCell_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction DataTableCell_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { DataTableCell_ownKeys(Object(source), true).forEach(function (key) { DataTableCell_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { DataTableCell_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction DataTableCell_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction DataTableCell_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = DataTableCell_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction DataTableCell_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\n\n\nvar DataTableCell = /*#__PURE__*/(0,react.forwardRef)(function (_ref, ref) {\n  var _classnames;\n\n  var _ref$checkbox = _ref.checkbox,\n      checkbox = _ref$checkbox === void 0 ? false : _ref$checkbox,\n      _ref$numeric = _ref.numeric,\n      numeric = _ref$numeric === void 0 ? false : _ref$numeric,\n      _ref$element = _ref.element,\n      Element = _ref$element === void 0 ? \'td\' : _ref$element,\n      scope = _ref.scope,\n      className = _ref.className,\n      children = _ref.children,\n      props = DataTableCell_objectWithoutProperties(_ref, DataTableCell_excluded);\n\n  var classNames = classnames_default()(data_table_constants_cssClasses.CELL, (_classnames = {}, DataTableCell_defineProperty(_classnames, data_table_constants_cssClasses.CELL_CHECKBOX, checkbox), DataTableCell_defineProperty(_classnames, data_table_constants_cssClasses.CELL_NUMERIC, numeric), _classnames), className);\n  return /*#__PURE__*/(0,jsx_runtime.jsx)(Element, DataTableCell_objectSpread(DataTableCell_objectSpread({\n    ref: ref,\n    className: classNames,\n    scope: scope\n  }, props), {}, {\n    children: checkbox ? /*#__PURE__*/(0,jsx_runtime.jsx)(Clone, {\n      component: children,\n      className: data_table_constants_cssClasses.ROW_CHECKBOX\n    }) : children\n  }));\n});\nDataTableCell.displayName = \'MDCDataTableCell\';\nDataTableCell.propTypes = {\n  checkbox: (prop_types_default()).bool,\n  numeric: (prop_types_default()).bool\n};\n/* harmony default export */ const data_table_DataTableCell = (DataTableCell);\n;// CONCATENATED MODULE: ./src/data-table/DataTableContent.jsx\nvar DataTableContent_excluded = ["className"];\n\nfunction DataTableContent_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction DataTableContent_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { DataTableContent_ownKeys(Object(source), true).forEach(function (key) { DataTableContent_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { DataTableContent_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction DataTableContent_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction DataTableContent_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = DataTableContent_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction DataTableContent_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\nvar DataTableContent = /*#__PURE__*/(0,react.forwardRef)(function (_ref, ref) {\n  var className = _ref.className,\n      props = DataTableContent_objectWithoutProperties(_ref, DataTableContent_excluded);\n\n  var classNames = classnames_default()(data_table_constants_cssClasses.CONTENT, className);\n  return /*#__PURE__*/(0,jsx_runtime.jsx)("tbody", DataTableContent_objectSpread({\n    ref: ref,\n    className: classNames\n  }, props));\n});\nDataTableContent.displayName = \'MDCDataTableContent\';\n/* harmony default export */ const data_table_DataTableContent = (DataTableContent);\n;// CONCATENATED MODULE: ./src/data-table/DataTableFooter.jsx\nvar DataTableFooter_excluded = ["className"];\n\nfunction DataTableFooter_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction DataTableFooter_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { DataTableFooter_ownKeys(Object(source), true).forEach(function (key) { DataTableFooter_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { DataTableFooter_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction DataTableFooter_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction DataTableFooter_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = DataTableFooter_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction DataTableFooter_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\nvar DataTableFooter = /*#__PURE__*/(0,react.forwardRef)(function (_ref, ref) {\n  var className = _ref.className,\n      props = DataTableFooter_objectWithoutProperties(_ref, DataTableFooter_excluded);\n\n  var classNames = classnames_default()(data_table_constants_cssClasses.FOOTER, className);\n  return /*#__PURE__*/(0,jsx_runtime.jsx)("tfoot", DataTableFooter_objectSpread({\n    ref: ref,\n    className: classNames\n  }, props));\n});\nDataTableFooter.displayName = \'MDCDataTableFooter\';\n/* harmony default export */ const data_table_DataTableFooter = (DataTableFooter);\n;// CONCATENATED MODULE: ./src/data-table/DataTableHeader.jsx\nvar DataTableHeader_excluded = ["className"];\n\nfunction DataTableHeader_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction DataTableHeader_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { DataTableHeader_ownKeys(Object(source), true).forEach(function (key) { DataTableHeader_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { DataTableHeader_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction DataTableHeader_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction DataTableHeader_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = DataTableHeader_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction DataTableHeader_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\nvar DataTableHeader = /*#__PURE__*/(0,react.forwardRef)(function (_ref, ref) {\n  var className = _ref.className,\n      props = DataTableHeader_objectWithoutProperties(_ref, DataTableHeader_excluded);\n\n  var classNames = classnames_default()(data_table_constants_cssClasses.HEADER, className);\n  return /*#__PURE__*/(0,jsx_runtime.jsx)("thead", DataTableHeader_objectSpread({\n    ref: ref,\n    className: classNames\n  }, props));\n});\nDataTableHeader.displayName = \'MDCDataTableHeader\';\n/* harmony default export */ const data_table_DataTableHeader = (DataTableHeader);\n;// CONCATENATED MODULE: ./src/data-table/DataTableHeaderCell.jsx\nvar DataTableHeaderCell_excluded = ["value", "label", "checkbox", "numeric", "sort", "sortIconButton", "onSort", "element", "role", "scope", "className", "children"];\n\nfunction DataTableHeaderCell_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction DataTableHeaderCell_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { DataTableHeaderCell_ownKeys(Object(source), true).forEach(function (key) { DataTableHeaderCell_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { DataTableHeaderCell_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction DataTableHeaderCell_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction DataTableHeaderCell_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = DataTableHeaderCell_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction DataTableHeaderCell_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\n\n\n\n\nvar DataTableHeaderCell = /*#__PURE__*/(0,react.forwardRef)(function (_ref, ref) {\n  var _classnames;\n\n  var value = _ref.value,\n      label = _ref.label,\n      _ref$checkbox = _ref.checkbox,\n      checkbox = _ref$checkbox === void 0 ? false : _ref$checkbox,\n      _ref$numeric = _ref.numeric,\n      numeric = _ref$numeric === void 0 ? false : _ref$numeric,\n      sort = _ref.sort,\n      _ref$sortIconButton = _ref.sortIconButton,\n      sortIconButton = _ref$sortIconButton === void 0 ? \'arrow_upward\' : _ref$sortIconButton,\n      _ref$onSort = _ref.onSort,\n      onSort = _ref$onSort === void 0 ? Function.prototype : _ref$onSort,\n      _ref$element = _ref.element,\n      Element = _ref$element === void 0 ? \'th\' : _ref$element,\n      _ref$role = _ref.role,\n      role = _ref$role === void 0 ? \'columnheader\' : _ref$role,\n      _ref$scope = _ref.scope,\n      scope = _ref$scope === void 0 ? \'col\' : _ref$scope,\n      className = _ref.className,\n      _ref$children = _ref.children,\n      children = _ref$children === void 0 ? label : _ref$children,\n      props = DataTableHeaderCell_objectWithoutProperties(_ref, DataTableHeaderCell_excluded);\n\n  var handleSortIconClick = (0,react.useCallback)(function () {\n    onSort({\n      label: label,\n      value: value\n    });\n  }, [label, value, onSort]);\n  var withSort = typeof sort === \'number\';\n  var classNames = classnames_default()(data_table_constants_cssClasses.HEADER_CELL, (_classnames = {}, DataTableHeaderCell_defineProperty(_classnames, data_table_constants_cssClasses.HEADER_CELL_CHECKBOX, checkbox), DataTableHeaderCell_defineProperty(_classnames, data_table_constants_cssClasses.HEADER_CELL_NUMERIC, numeric), DataTableHeaderCell_defineProperty(_classnames, data_table_constants_cssClasses.HEADER_CELL_WITH_SORT, withSort), DataTableHeaderCell_defineProperty(_classnames, data_table_constants_cssClasses.HEADER_CELL_SORTED, sort === 1 || sort === -1), DataTableHeaderCell_defineProperty(_classnames, data_table_constants_cssClasses.HEADER_CELL_SORTED_DESC, sort === -1), _classnames), className);\n  return /*#__PURE__*/(0,jsx_runtime.jsx)(Element, DataTableHeaderCell_objectSpread(DataTableHeaderCell_objectSpread({\n    ref: ref,\n    className: classNames,\n    role: role,\n    scope: scope\n  }, props), {}, {\n    children: withSort ? /*#__PURE__*/(0,jsx_runtime.jsxs)("div", {\n      className: data_table_constants_cssClasses.HEADER_CELL_WRAPPER,\n      children: [/*#__PURE__*/(0,jsx_runtime.jsx)("div", {\n        className: data_table_constants_cssClasses.HEADER_CELL_LABEL,\n        children: children\n      }), /*#__PURE__*/(0,jsx_runtime.jsx)(Clone, {\n        component: sortIconButton,\n        fallback: icon_button_IconButton,\n        className: data_table_constants_cssClasses.SORT_ICON_BUTTON,\n        onClick: handleSortIconClick\n      }), /*#__PURE__*/(0,jsx_runtime.jsx)("div", {\n        className: data_table_constants_cssClasses.SORT_STATUS_LABEL,\n        "aria-hidden": "true"\n      })]\n    }) : checkbox ? /*#__PURE__*/(0,jsx_runtime.jsx)(Clone, {\n      component: children,\n      className: data_table_constants_cssClasses.HEADER_ROW_CHECKBOX\n    }) : children\n  }));\n});\nDataTableHeaderCell.displayName = \'MDCDataTableHeaderCell\';\nDataTableHeaderCell.propTypes = {\n  value: (prop_types_default()).any,\n  label: (prop_types_default()).string,\n  numeric: (prop_types_default()).bool,\n  checkbox: (prop_types_default()).bool,\n  sort: prop_types_default().oneOf([-1, 0, 1]),\n  sortIconButton: (prop_types_default()).node,\n  onSort: (prop_types_default()).func\n};\n/* harmony default export */ const data_table_DataTableHeaderCell = (DataTableHeaderCell);\n;// CONCATENATED MODULE: ./src/data-table/DataTableHeaderRow.jsx\nvar DataTableHeaderRow_excluded = ["className"];\n\nfunction DataTableHeaderRow_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction DataTableHeaderRow_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { DataTableHeaderRow_ownKeys(Object(source), true).forEach(function (key) { DataTableHeaderRow_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { DataTableHeaderRow_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction DataTableHeaderRow_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction DataTableHeaderRow_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = DataTableHeaderRow_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction DataTableHeaderRow_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\nvar DataTableHeaderRow = /*#__PURE__*/(0,react.forwardRef)(function (_ref, ref) {\n  var className = _ref.className,\n      props = DataTableHeaderRow_objectWithoutProperties(_ref, DataTableHeaderRow_excluded);\n\n  var classNames = classnames_default()(data_table_constants_cssClasses.HEADER_ROW, className);\n  return /*#__PURE__*/(0,jsx_runtime.jsx)("tr", DataTableHeaderRow_objectSpread({\n    ref: ref,\n    className: classNames\n  }, props));\n});\nDataTableHeaderRow.displayName = \'MDCDataTableHeaderRow\';\n/* harmony default export */ const data_table_DataTableHeaderRow = (DataTableHeaderRow);\n;// CONCATENATED MODULE: ./src/data-table/DataTableRow.jsx\nvar DataTableRow_excluded = ["selected", "className"];\n\nfunction DataTableRow_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction DataTableRow_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { DataTableRow_ownKeys(Object(source), true).forEach(function (key) { DataTableRow_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { DataTableRow_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction DataTableRow_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction DataTableRow_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = DataTableRow_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction DataTableRow_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\n\nvar DataTableRow = /*#__PURE__*/(0,react.forwardRef)(function (_ref, ref) {\n  var _ref$selected = _ref.selected,\n      selected = _ref$selected === void 0 ? false : _ref$selected,\n      className = _ref.className,\n      props = DataTableRow_objectWithoutProperties(_ref, DataTableRow_excluded);\n\n  var classNames = classnames_default()(data_table_constants_cssClasses.ROW, DataTableRow_defineProperty({}, data_table_constants_cssClasses.ROW_SELECTED, selected), className);\n  return /*#__PURE__*/(0,jsx_runtime.jsx)("tr", DataTableRow_objectSpread({\n    ref: ref,\n    className: classNames\n  }, props));\n});\nDataTableRow.displayName = \'MDCDataTableRow\';\nDataTableRow.propTypes = {\n  selected: (prop_types_default()).bool\n};\n/* harmony default export */ const data_table_DataTableRow = (DataTableRow);\n;// CONCATENATED MODULE: ./src/data-table/index.js\n\n\n\n\n\n\n\n\n\ndata_table_DataTable.Cell = data_table_DataTableCell;\ndata_table_DataTable.Content = data_table_DataTableContent;\ndata_table_DataTable.Footer = data_table_DataTableFooter;\ndata_table_DataTable.Header = data_table_DataTableHeader;\ndata_table_DataTable.HeaderCell = data_table_DataTableHeaderCell;\ndata_table_DataTable.HeaderRow = data_table_DataTableHeaderRow;\ndata_table_DataTable.Pagination = data_table_DataTablePagination;\ndata_table_DataTable.Row = data_table_DataTableRow;\n\n;// CONCATENATED MODULE: ./src/dialog/constants.js\nvar dialog_constants_numbers = {\n  DIALOG_ANIMATION_OPEN_TIME_MS: 150,\n  DIALOG_ANIMATION_CLOSE_TIME_MS: 75,\n  DEFAULT_ACTIONS_HEIGHT: 52\n};\nvar dialog_constants_cssClasses = {\n  ROOT: \'mdc-dialog\',\n  HEADER: \'mdc-dialog__header\',\n  TITLE: \'mdc-dialog__title\',\n  CLOSE: \'mdc-dialog__close\',\n  CONTENT: \'mdc-dialog__content\',\n  CONTAINER: \'mdc-dialog__container\',\n  ACTIONS: \'mdc-dialog__actions\',\n  BUTTON: \'mdc-dialog__button\',\n  SURFACE: \'mdc-dialog__surface\',\n  SCRIM: \'mdc-dialog__scrim\',\n  OPEN: \'mdc-dialog--open\',\n  OPENING: \'mdc-dialog--opening\',\n  CLOSING: \'mdc-dialog--closing\',\n  FULLSCREEN: \'mdc-dialog--fullscreen\',\n  SCROLLABLE: \'mdc-dialog--scrollable\',\n  STACKED: \'mdc-dialog--stacked\',\n  SCROLL_DIVIDER_HEADER: \'mdc-dialog-scroll-divider-header\',\n  SCROLL_DIVIDER_FOOTER: \'mdc-dialog-scroll-divider-footer\',\n  SCROLL_LOCK: \'mdc-dialog-scroll-lock\'\n};\n;// CONCATENATED MODULE: ./src/dialog/DialogHeader.jsx\nvar DialogHeader_excluded = ["title", "closeIcon", "fullscreen", "onClose", "children"];\n\nfunction DialogHeader_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction DialogHeader_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { DialogHeader_ownKeys(Object(source), true).forEach(function (key) { DialogHeader_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { DialogHeader_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction DialogHeader_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction DialogHeader_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = DialogHeader_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction DialogHeader_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\n\n\nvar DialogHeader = /*#__PURE__*/(0,react.forwardRef)(function (_ref, ref) {\n  var title = _ref.title,\n      closeIcon = _ref.closeIcon,\n      fullscreen = _ref.fullscreen,\n      onClose = _ref.onClose,\n      children = _ref.children,\n      props = DialogHeader_objectWithoutProperties(_ref, DialogHeader_excluded);\n\n  return /*#__PURE__*/(0,jsx_runtime.jsxs)("div", DialogHeader_objectSpread(DialogHeader_objectSpread({\n    ref: ref,\n    className: dialog_constants_cssClasses.HEADER\n  }, props), {}, {\n    children: [/*#__PURE__*/(0,jsx_runtime.jsx)(Clone, {\n      component: title,\n      fallback: "h2",\n      className: dialog_constants_cssClasses.TITLE\n    }), (fullscreen || closeIcon) && /*#__PURE__*/(0,jsx_runtime.jsx)(Clone, {\n      component: closeIcon,\n      fallback: /*#__PURE__*/(0,jsx_runtime.jsx)(icon_button_IconButton, {\n        icon: "close"\n      }),\n      className: dialog_constants_cssClasses.CLOSE,\n      onClick: onClose\n    }), children]\n  }));\n});\nDialogHeader.displayName = \'MDCDialogHeader\';\n/* harmony default export */ const dialog_DialogHeader = (DialogHeader);\n;// CONCATENATED MODULE: ./src/dialog/DialogContent.jsx\nfunction DialogContent_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction DialogContent_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { DialogContent_ownKeys(Object(source), true).forEach(function (key) { DialogContent_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { DialogContent_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction DialogContent_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n\n\n\nvar DialogContent = /*#__PURE__*/(0,react.forwardRef)(function (props, ref) {\n  return /*#__PURE__*/(0,jsx_runtime.jsx)("div", DialogContent_objectSpread({\n    ref: ref,\n    className: dialog_constants_cssClasses.CONTENT\n  }, props));\n});\nDialogContent.displayName = \'MDCDialogContent\';\n/* harmony default export */ const dialog_DialogContent = (DialogContent);\n;// CONCATENATED MODULE: ./src/dialog/DialogActions.jsx\n\n\n\n\nvar DialogActions = /*#__PURE__*/(0,react.forwardRef)(function (_ref, ref) {\n  var children = _ref.children;\n  return /*#__PURE__*/(0,jsx_runtime.jsx)("div", {\n    ref: ref,\n    className: dialog_constants_cssClasses.ACTIONS,\n    children: /*#__PURE__*/(0,jsx_runtime.jsx)(Clone, {\n      component: children,\n      className: dialog_constants_cssClasses.BUTTON\n    })\n  });\n});\nDialogActions.displayName = \'MDCDialogActions\';\n/* harmony default export */ const dialog_DialogActions = (DialogActions);\n;// CONCATENATED MODULE: ./src/dialog/Dialog.jsx\nvar Dialog_excluded = ["title", "content", "actions", "closeIcon", "open", "appear", "persistent", "fullscreen", "stacked", "autoStackButtons", "onClose", "element", "className", "children"];\n\nfunction Dialog_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction Dialog_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { Dialog_ownKeys(Object(source), true).forEach(function (key) { Dialog_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { Dialog_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction Dialog_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction Dialog_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = Dialog_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction Dialog_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\n\n\n\n\n\n\n\nvar Dialog = /*#__PURE__*/(0,react.forwardRef)(function (_ref, ref) {\n  var _classnames;\n\n  var title = _ref.title,\n      content = _ref.content,\n      actions = _ref.actions,\n      closeIcon = _ref.closeIcon,\n      _ref$open = _ref.open,\n      open = _ref$open === void 0 ? false : _ref$open,\n      _ref$appear = _ref.appear,\n      appear = _ref$appear === void 0 ? false : _ref$appear,\n      _ref$persistent = _ref.persistent,\n      persistent = _ref$persistent === void 0 ? false : _ref$persistent,\n      _ref$fullscreen = _ref.fullscreen,\n      fullscreen = _ref$fullscreen === void 0 ? false : _ref$fullscreen,\n      _ref$stacked = _ref.stacked,\n      stacked = _ref$stacked === void 0 ? false : _ref$stacked,\n      _ref$autoStackButtons = _ref.autoStackButtons,\n      autoStackButtons = _ref$autoStackButtons === void 0 ? false : _ref$autoStackButtons,\n      _ref$onClose = _ref.onClose,\n      onClose = _ref$onClose === void 0 ? Function.prototype : _ref$onClose,\n      _ref$element = _ref.element,\n      Element = _ref$element === void 0 ? \'div\' : _ref$element,\n      className = _ref.className,\n      _ref$children = _ref.children,\n      children = _ref$children === void 0 ? content : _ref$children,\n      props = Dialog_objectWithoutProperties(_ref, Dialog_excluded);\n\n  var rootRef = (0,react.useRef)();\n  var contentRef = (0,react.useRef)();\n  var actionsRef = (0,react.useRef)();\n  (0,react.useImperativeHandle)(ref, function () {\n    return rootRef.current;\n  });\n  useUpdated(function () {\n    if (persistent) return;\n\n    function handleDocumentKeyDown(event) {\n      if (event.key === \'Escape\' || event.keyCode === 27) {\n        event.stopPropagation();\n        onClose();\n      }\n    }\n\n    if (open) {\n      document.addEventListener(\'keydown\', handleDocumentKeyDown);\n    } else {\n      document.removeEventListener(\'keydown\', handleDocumentKeyDown);\n    }\n\n    return function () {\n      return document.removeEventListener(\'keydown\', handleDocumentKeyDown);\n    };\n  }, [open, persistent, onClose]);\n  useUpdated(function () {\n    if (!contentRef.current || !open) return;\n    var contentElement = contentRef.current;\n    var shouldScroll = contentElement.scrollHeight > contentElement.offsetHeight;\n\n    if (shouldScroll) {\n      rootRef.current.classList.add(dialog_constants_cssClasses.SCROLLABLE);\n    }\n  }, [open]);\n  useUpdated(function () {\n    if (!actionsRef.current || !open || !autoStackButtons) return;\n    var actionsElement = actionsRef.current;\n\n    if (actionsElement.clientHeight > dialog_constants_numbers.DEFAULT_ACTIONS_HEIGHT) {\n      rootRef.current.classList.add(dialog_constants_cssClasses.STACKED);\n    }\n  }, [open, autoStackButtons]);\n  useUpdated(function () {\n    if (!contentRef.current || !fullscreen) return;\n    var contentElement = contentRef.current;\n\n    function handleScroll() {\n      var isScrollAtTop = contentElement.scrollTop === 0;\n      var isScrollAtBottom = Math.ceil(contentElement.scrollHeight - contentElement.scrollTop) === contentElement.clientHeight;\n      rootRef.current.classList.toggle(dialog_constants_cssClasses.SCROLL_DIVIDER_HEADER, !isScrollAtTop);\n      rootRef.current.classList.toggle(dialog_constants_cssClasses.SCROLL_DIVIDER_FOOTER, !isScrollAtBottom);\n    }\n\n    contentElement.addEventListener(\'scroll\', handleScroll);\n\n    if (open) {\n      handleScroll();\n    }\n\n    return function () {\n      return contentElement.removeEventListener(\'scroll\', handleScroll);\n    };\n  }, [open, fullscreen]);\n  useUnmounted(function () {\n    document.body.classList.remove(dialog_constants_cssClasses.SCROLL_LOCK);\n  });\n  var handleEnter = (0,react.useCallback)(function () {\n    document.body.classList.add(dialog_constants_cssClasses.SCROLL_LOCK);\n  }, []);\n  var handleExited = (0,react.useCallback)(function () {\n    document.body.classList.remove(dialog_constants_cssClasses.SCROLL_LOCK);\n  }, []);\n  var handleScrimClick = (0,react.useCallback)(function () {\n    if (persistent) return;\n    onClose();\n  }, [persistent, onClose]);\n  var classNames = classnames_default()(dialog_constants_cssClasses.ROOT, (_classnames = {}, Dialog_defineProperty(_classnames, dialog_constants_cssClasses.FULLSCREEN, fullscreen), Dialog_defineProperty(_classnames, dialog_constants_cssClasses.STACKED, stacked), _classnames), className);\n  return /*#__PURE__*/(0,jsx_runtime.jsx)(Layer, {\n    modal: true,\n    "in": open,\n    appear: appear,\n    timeout: {\n      enter: dialog_constants_numbers.DIALOG_ANIMATION_OPEN_TIME_MS,\n      exit: dialog_constants_numbers.DIALOG_ANIMATION_CLOSE_TIME_MS\n    },\n    classNames: {\n      appear: dialog_constants_cssClasses.OPENING,\n      appearActive: dialog_constants_cssClasses.OPEN,\n      enter: dialog_constants_cssClasses.OPENING,\n      enterActive: dialog_constants_cssClasses.OPEN,\n      enterDone: dialog_constants_cssClasses.OPEN,\n      exit: dialog_constants_cssClasses.CLOSING\n    },\n    mountOnEnter: true,\n    unmountOnExit: true,\n    onEnter: handleEnter,\n    onExited: handleExited,\n    children: /*#__PURE__*/(0,jsx_runtime.jsxs)(Element, Dialog_objectSpread(Dialog_objectSpread({\n      ref: rootRef,\n      className: classNames\n    }, props), {}, {\n      children: [/*#__PURE__*/(0,jsx_runtime.jsx)("div", {\n        className: dialog_constants_cssClasses.CONTAINER,\n        children: /*#__PURE__*/(0,jsx_runtime.jsxs)("div", {\n          className: dialog_constants_cssClasses.SURFACE,\n          role: "alertdialog",\n          "aria-modal": "true",\n          children: [title && /*#__PURE__*/(0,jsx_runtime.jsx)(dialog_DialogHeader, {\n            title: title,\n            closeIcon: closeIcon,\n            fullscreen: fullscreen,\n            onClose: onClose\n          }), children && /*#__PURE__*/(0,jsx_runtime.jsx)(dialog_DialogContent, {\n            ref: contentRef,\n            children: children\n          }), actions && /*#__PURE__*/(0,jsx_runtime.jsx)(dialog_DialogActions, {\n            ref: actionsRef,\n            children: actions\n          })]\n        })\n      }), /*#__PURE__*/(0,jsx_runtime.jsx)("div", {\n        className: dialog_constants_cssClasses.SCRIM,\n        onClick: handleScrimClick\n      })]\n    }))\n  });\n});\nDialog.displayName = \'MDCDialog\';\nDialog.propTypes = {\n  title: (prop_types_default()).node,\n  closeIcon: (prop_types_default()).node,\n  content: (prop_types_default()).node,\n  actions: prop_types_default().oneOfType([(prop_types_default()).node, prop_types_default().arrayOf((prop_types_default()).node)]),\n  open: (prop_types_default()).bool,\n  appear: (prop_types_default()).bool,\n  confirmation: (prop_types_default()).bool,\n  persistent: (prop_types_default()).bool,\n  stacked: (prop_types_default()).bool,\n  fullscreen: (prop_types_default()).bool,\n  autoStackButtons: (prop_types_default()).bool,\n  onClose: (prop_types_default()).func\n};\n/* harmony default export */ const dialog_Dialog = (Dialog);\n;// CONCATENATED MODULE: ./src/dialog/index.js\n\n\n\n\ndialog_Dialog.Header = dialog_DialogHeader;\ndialog_Dialog.Content = dialog_DialogContent;\ndialog_Dialog.Actions = dialog_DialogActions;\n\n;// CONCATENATED MODULE: ./src/drawer/constants.js\nvar drawer_constants_numbers = {\n  ANIMATION_ENTER_TIME_MS: 250,\n  ANIMATION_EXIT_TIME_MS: 200\n};\nvar drawer_constants_cssClasses = {\n  ROOT: \'mdc-drawer\',\n  DISMISSIBLE: \'mdc-drawer--dismissible\',\n  MODAL: \'mdc-drawer--modal\',\n  OPEN: \'mdc-drawer--open\',\n  ANIMATE: \'mdc-drawer--animate\',\n  OPENING: \'mdc-drawer--opening\',\n  CLOSING: \'mdc-drawer--closing\',\n  CONTENT: \'mdc-drawer__content\',\n  HEADER: \'mdc-drawer__header\',\n  TITLE: \'mdc-drawer__title\',\n  SUBTITLE: \'mdc-drawer__subtitle\',\n  GRAPHIC: \'mdc-drawer__graphic\',\n  APP_CONTENT: \'mdc-drawer-app-content\',\n  SCRIM: \'mdc-drawer-scrim\'\n};\n;// CONCATENATED MODULE: ./src/drawer/Drawer.jsx\nvar Drawer_excluded = ["open", "appear", "dismissible", "modal", "appContentSelector", "onClose", "element", "component", "className", "children"];\n\nfunction Drawer_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction Drawer_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { Drawer_ownKeys(Object(source), true).forEach(function (key) { Drawer_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { Drawer_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction Drawer_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction Drawer_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = Drawer_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction Drawer_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\n\n\n\n\nvar Drawer = /*#__PURE__*/(0,react.forwardRef)(function (_ref, ref) {\n  var _classnames;\n\n  var _ref$open = _ref.open,\n      open = _ref$open === void 0 ? false : _ref$open,\n      _ref$appear = _ref.appear,\n      appear = _ref$appear === void 0 ? true : _ref$appear,\n      _ref$dismissible = _ref.dismissible,\n      dismissible = _ref$dismissible === void 0 ? false : _ref$dismissible,\n      _ref$modal = _ref.modal,\n      modal = _ref$modal === void 0 ? false : _ref$modal,\n      appContentSelector = _ref.appContentSelector,\n      _ref$onClose = _ref.onClose,\n      onClose = _ref$onClose === void 0 ? Function.prototype : _ref$onClose,\n      _ref$element = _ref.element,\n      element = _ref$element === void 0 ? \'aside\' : _ref$element,\n      _ref$component = _ref.component,\n      Element = _ref$component === void 0 ? element : _ref$component,\n      className = _ref.className,\n      children = _ref.children,\n      props = Drawer_objectWithoutProperties(_ref, Drawer_excluded);\n\n  var rootRef = (0,react.useRef)();\n  (0,react.useImperativeHandle)(ref, function () {\n    return rootRef.current;\n  });\n  (0,react.useEffect)(function () {\n    var _rootRef$current;\n\n    if (!dismissible) return;\n    var appContentElement = appContentSelector ? document.querySelector(appContentSelector) : (_rootRef$current = rootRef.current) === null || _rootRef$current === void 0 ? void 0 : _rootRef$current.nextElementSibling;\n    appContentElement === null || appContentElement === void 0 ? void 0 : appContentElement.classList.add(drawer_constants_cssClasses.APP_CONTENT);\n    return function () {\n      appContentElement === null || appContentElement === void 0 ? void 0 : appContentElement.classList.remove(drawer_constants_cssClasses.APP_CONTENT);\n    };\n  }, [dismissible, appContentSelector]);\n  (0,react.useEffect)(function () {\n    if (!modal) return;\n\n    function handleDocumentKeyDown(event) {\n      if (event.key && event.key === \'Escape\' || event.keyCode === 27) {\n        onClose();\n      }\n    }\n\n    document.addEventListener(\'keydown\', handleDocumentKeyDown);\n    return function () {\n      return document.removeEventListener(\'keydown\', handleDocumentKeyDown);\n    };\n  }, [modal, onClose]);\n  var classNames = classnames_default()(drawer_constants_cssClasses.ROOT, (_classnames = {}, Drawer_defineProperty(_classnames, drawer_constants_cssClasses.DISMISSIBLE, dismissible), Drawer_defineProperty(_classnames, drawer_constants_cssClasses.MODAL, modal), _classnames), className);\n  return /*#__PURE__*/(0,jsx_runtime.jsx)(Layer, {\n    modal: modal,\n    fixed: modal,\n    "in": open,\n    appear: appear,\n    timeout: {\n      enter: drawer_constants_numbers.ANIMATION_ENTER_TIME_MS,\n      exit: drawer_constants_numbers.ANIMATION_EXIT_TIME_MS\n    },\n    classNames: {\n      appear: drawer_constants_cssClasses.OPEN,\n      enter: "".concat(drawer_constants_cssClasses.OPEN, " ").concat(drawer_constants_cssClasses.ANIMATE),\n      enterActive: "".concat(drawer_constants_cssClasses.OPEN, " ").concat(drawer_constants_cssClasses.OPENING),\n      enterDone: drawer_constants_cssClasses.OPEN,\n      exit: "".concat(drawer_constants_cssClasses.OPEN, " ").concat(drawer_constants_cssClasses.CLOSING),\n      exitActive: drawer_constants_cssClasses.CLOSING\n    },\n    mountOnEnter: modal,\n    unmountOnExit: modal,\n    children: /*#__PURE__*/(0,jsx_runtime.jsxs)(jsx_runtime.Fragment, {\n      children: [/*#__PURE__*/(0,jsx_runtime.jsx)(Element, Drawer_objectSpread(Drawer_objectSpread({\n        ref: rootRef,\n        className: classNames\n      }, props), {}, {\n        children: children\n      })), modal && /*#__PURE__*/(0,jsx_runtime.jsx)("div", {\n        className: drawer_constants_cssClasses.SCRIM,\n        onClick: onClose\n      })]\n    })\n  });\n});\nDrawer.displayName = \'MDCDrawer\';\nDrawer.propTypes = {\n  open: (prop_types_default()).bool,\n  appear: (prop_types_default()).bool,\n  dismissible: (prop_types_default()).bool,\n  modal: (prop_types_default()).bool,\n  appContentSelector: (prop_types_default()).string,\n  onClose: (prop_types_default()).func\n};\n/* harmony default export */ const drawer_Drawer = (Drawer);\n;// CONCATENATED MODULE: ./src/drawer/DrawerHeader.jsx\nvar DrawerHeader_excluded = ["title", "subtitle", "graphic", "element", "children"];\n\nfunction DrawerHeader_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction DrawerHeader_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { DrawerHeader_ownKeys(Object(source), true).forEach(function (key) { DrawerHeader_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { DrawerHeader_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction DrawerHeader_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction DrawerHeader_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = DrawerHeader_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction DrawerHeader_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\n\n\nvar DrawerHeader = /*#__PURE__*/(0,react.forwardRef)(function (_ref, ref) {\n  var title = _ref.title,\n      subtitle = _ref.subtitle,\n      graphic = _ref.graphic,\n      _ref$element = _ref.element,\n      Element = _ref$element === void 0 ? \'header\' : _ref$element,\n      children = _ref.children,\n      props = DrawerHeader_objectWithoutProperties(_ref, DrawerHeader_excluded);\n\n  return /*#__PURE__*/(0,jsx_runtime.jsxs)(Element, DrawerHeader_objectSpread(DrawerHeader_objectSpread({\n    ref: ref,\n    className: drawer_constants_cssClasses.HEADER\n  }, props), {}, {\n    children: [graphic && /*#__PURE__*/(0,jsx_runtime.jsx)(Clone, {\n      component: graphic,\n      className: drawer_constants_cssClasses.GRAPHIC\n    }), title && /*#__PURE__*/(0,jsx_runtime.jsx)(Clone, {\n      component: title,\n      fallback: "h3",\n      className: drawer_constants_cssClasses.TITLE\n    }), subtitle && /*#__PURE__*/(0,jsx_runtime.jsx)(Clone, {\n      component: subtitle,\n      fallback: "h6",\n      className: drawer_constants_cssClasses.SUBTITLE\n    }), children]\n  }));\n});\nDrawerHeader.displayName = \'MDCDrawerHeader\';\nDrawerHeader.propTypes = {\n  title: (prop_types_default()).node,\n  subtitle: (prop_types_default()).node,\n  graphic: (prop_types_default()).element\n};\n/* harmony default export */ const drawer_DrawerHeader = (DrawerHeader);\n;// CONCATENATED MODULE: ./src/drawer/DrawerContent.jsx\nvar DrawerContent_excluded = ["element"];\n\nfunction DrawerContent_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction DrawerContent_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { DrawerContent_ownKeys(Object(source), true).forEach(function (key) { DrawerContent_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { DrawerContent_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction DrawerContent_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction DrawerContent_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = DrawerContent_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction DrawerContent_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\nvar DrawerContent = /*#__PURE__*/(0,react.forwardRef)(function (_ref, ref) {\n  var _ref$element = _ref.element,\n      Element = _ref$element === void 0 ? \'div\' : _ref$element,\n      props = DrawerContent_objectWithoutProperties(_ref, DrawerContent_excluded);\n\n  return /*#__PURE__*/(0,jsx_runtime.jsx)(Element, DrawerContent_objectSpread({\n    ref: ref,\n    className: drawer_constants_cssClasses.CONTENT\n  }, props));\n});\nDrawerContent.displayName = \'MDCDrawerContent\';\n/* harmony default export */ const drawer_DrawerContent = (DrawerContent);\n;// CONCATENATED MODULE: ./src/drawer/index.js\n\n\n\ndrawer_Drawer.Header = drawer_DrawerHeader;\ndrawer_Drawer.Content = drawer_DrawerContent;\n\n;// CONCATENATED MODULE: ./src/elevation/constants.js\nvar elevation_constants_cssClasses = {\n  ROOT: \'mdc-elevation\',\n  Z: \'mdc-elevation--z\',\n  TRANSITION: \'mdc-elevation-transition\'\n};\n;// CONCATENATED MODULE: ./src/elevation/Elevation.jsx\nvar Elevation_excluded = ["z", "transition", "element", "component", "className"];\n\nfunction Elevation_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction Elevation_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { Elevation_ownKeys(Object(source), true).forEach(function (key) { Elevation_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { Elevation_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction Elevation_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction Elevation_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = Elevation_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction Elevation_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\nvar Elevation = /*#__PURE__*/(0,react.forwardRef)(function (_ref, ref) {\n  var _classnames;\n\n  var _ref$z = _ref.z,\n      z = _ref$z === void 0 ? 0 : _ref$z,\n      _ref$transition = _ref.transition,\n      transition = _ref$transition === void 0 ? false : _ref$transition,\n      _ref$element = _ref.element,\n      element = _ref$element === void 0 ? \'div\' : _ref$element,\n      _ref$component = _ref.component,\n      Element = _ref$component === void 0 ? element : _ref$component,\n      className = _ref.className,\n      props = Elevation_objectWithoutProperties(_ref, Elevation_excluded);\n\n  var classNames = classnames_default()(elevation_constants_cssClasses.ROOT, (_classnames = {}, Elevation_defineProperty(_classnames, "".concat(elevation_constants_cssClasses.Z).concat(z), z), Elevation_defineProperty(_classnames, elevation_constants_cssClasses.TRANSITION, transition), _classnames), className);\n  return /*#__PURE__*/(0,jsx_runtime.jsx)(Element, Elevation_objectSpread({\n    ref: ref,\n    className: classNames\n  }, props));\n});\nElevation.displayName = \'MDCElevation\';\n/* harmony default export */ const elevation_Elevation = (Elevation);\n;// CONCATENATED MODULE: ./src/elevation/index.js\n\n;// CONCATENATED MODULE: ./src/fab/constants.js\nvar fab_constants_cssClasses = {\n  ROOT: \'mdc-fab\',\n  MINI: \'mdc-fab--mini\',\n  EXTENDED: \'mdc-fab--extended\',\n  EXITED: \'mdc-fab--exited\',\n  ICON: \'mdc-fab__icon\',\n  LABEL: \'mdc-fab__label\',\n  RIPPLE: \'mdc-fab__ripple\'\n};\n;// CONCATENATED MODULE: ./src/fab/FAB.jsx\nvar FAB_excluded = ["icon", "label", "leadingIcon", "trailingIcon", "mini", "exited", "element", "component", "className", "children"];\n\nfunction FAB_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction FAB_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { FAB_ownKeys(Object(source), true).forEach(function (key) { FAB_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { FAB_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction FAB_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction FAB_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = FAB_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction FAB_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\n\n\n\n\nvar FAB = /*#__PURE__*/(0,react.forwardRef)(function (_ref, ref) {\n  var _classnames;\n\n  var icon = _ref.icon,\n      label = _ref.label,\n      _ref$leadingIcon = _ref.leadingIcon,\n      leadingIcon = _ref$leadingIcon === void 0 ? icon : _ref$leadingIcon,\n      trailingIcon = _ref.trailingIcon,\n      _ref$mini = _ref.mini,\n      mini = _ref$mini === void 0 ? false : _ref$mini,\n      _ref$exited = _ref.exited,\n      exited = _ref$exited === void 0 ? false : _ref$exited,\n      _ref$element = _ref.element,\n      element = _ref$element === void 0 ? \'button\' : _ref$element,\n      _ref$component = _ref.component,\n      Element = _ref$component === void 0 ? element : _ref$component,\n      className = _ref.className,\n      _ref$children = _ref.children,\n      children = _ref$children === void 0 ? label : _ref$children,\n      props = FAB_objectWithoutProperties(_ref, FAB_excluded);\n\n  var classNames = classnames_default()(fab_constants_cssClasses.ROOT, (_classnames = {}, FAB_defineProperty(_classnames, fab_constants_cssClasses.MINI, mini), FAB_defineProperty(_classnames, fab_constants_cssClasses.EXTENDED, label), FAB_defineProperty(_classnames, fab_constants_cssClasses.EXITED, exited), _classnames), className);\n  return /*#__PURE__*/(0,jsx_runtime.jsxs)(Element, FAB_objectSpread(FAB_objectSpread({\n    ref: ref,\n    className: classNames\n  }, props), {}, {\n    children: [/*#__PURE__*/(0,jsx_runtime.jsx)("div", {\n      className: fab_constants_cssClasses.RIPPLE\n    }), leadingIcon && /*#__PURE__*/(0,jsx_runtime.jsx)(Clone, {\n      component: leadingIcon,\n      fallback: icon_Icon,\n      className: fab_constants_cssClasses.ICON\n    }), children && /*#__PURE__*/(0,jsx_runtime.jsx)("span", {\n      className: fab_constants_cssClasses.LABEL,\n      children: children\n    }), trailingIcon && /*#__PURE__*/(0,jsx_runtime.jsx)(Clone, {\n      component: trailingIcon,\n      fallback: icon_Icon,\n      className: fab_constants_cssClasses.ICON\n    })]\n  }));\n});\nFAB.displayName = \'MDCFAB\';\nFAB.propTypes = {\n  icon: (prop_types_default()).node,\n  label: (prop_types_default()).node,\n  leadingIcon: (prop_types_default()).node,\n  trailingIcon: (prop_types_default()).node,\n  mini: (prop_types_default()).bool,\n  exited: (prop_types_default()).bool\n};\n/* harmony default export */ const fab_FAB = (FAB);\n;// CONCATENATED MODULE: ./src/fab/index.js\n\n;// CONCATENATED MODULE: ./src/form-field/constants.js\nvar form_field_constants_cssClasses = {\n  ROOT: \'mdc-form-field\',\n  ALIGN_END: \'mdc-form-field--align-end\',\n  NOWRAP: \'mdc-form-field--nowrap\',\n  SPACE_BETWEEN: \'mdc-form-field--space-between\'\n};\n;// CONCATENATED MODULE: ./src/form-field/FormField.jsx\nvar FormField_excluded = ["label", "alignEnd", "nowrap", "spaceBetween", "element", "className", "children"];\n\nfunction FormField_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction FormField_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { FormField_ownKeys(Object(source), true).forEach(function (key) { FormField_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { FormField_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction FormField_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction FormField_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = FormField_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction FormField_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\n\n\nvar FormField = /*#__PURE__*/(0,react.forwardRef)(function (_ref, ref) {\n  var _classnames;\n\n  var label = _ref.label,\n      _ref$alignEnd = _ref.alignEnd,\n      alignEnd = _ref$alignEnd === void 0 ? false : _ref$alignEnd,\n      _ref$nowrap = _ref.nowrap,\n      nowrap = _ref$nowrap === void 0 ? false : _ref$nowrap,\n      _ref$spaceBetween = _ref.spaceBetween,\n      spaceBetween = _ref$spaceBetween === void 0 ? false : _ref$spaceBetween,\n      _ref$element = _ref.element,\n      Element = _ref$element === void 0 ? \'div\' : _ref$element,\n      className = _ref.className,\n      children = _ref.children,\n      props = FormField_objectWithoutProperties(_ref, FormField_excluded);\n\n  var classNames = classnames_default()(form_field_constants_cssClasses.ROOT, (_classnames = {}, FormField_defineProperty(_classnames, form_field_constants_cssClasses.ALIGN_END, alignEnd), FormField_defineProperty(_classnames, form_field_constants_cssClasses.NOWRAP, nowrap), FormField_defineProperty(_classnames, form_field_constants_cssClasses.SPACE_BETWEEN, spaceBetween), _classnames), className);\n  return /*#__PURE__*/(0,jsx_runtime.jsxs)(Element, FormField_objectSpread(FormField_objectSpread({\n    ref: ref,\n    className: classNames\n  }, props), {}, {\n    children: [children, label && /*#__PURE__*/(0,jsx_runtime.jsx)("label", {\n      htmlFor: children.props.id,\n      children: label\n    })]\n  }));\n});\nFormField.displayName = \'MDCFormField\';\nFormField.propTypes = {\n  label: (prop_types_default()).node,\n  alignEnd: (prop_types_default()).bool,\n  nowrap: (prop_types_default()).bool,\n  spaceBetween: (prop_types_default()).bool,\n  children: (prop_types_default()).any.isRequired\n};\n/* harmony default export */ const form_field_FormField = (FormField);\n;// CONCATENATED MODULE: ./src/form-field/index.js\n\n;// CONCATENATED MODULE: ./src/image-list/constants.js\nvar image_list_constants_cssClasses = {\n  IMAGE_LIST: \'mdc-image-list\',\n  IMAGE_LIST_MASONRY: \'mdc-image-list--masonry\',\n  IMAGE_LIST_WITH_TEXT_PROTECTION: \'mdc-image-list--with-text-protection\',\n  IMAGE_LIST_ITEM: \'mdc-image-list__item\',\n  IMAGE_LIST_IMAGE_ASPECT_CONTAINER: \'mdc-image-list__image-aspect-container\',\n  IMAGE_LIST_IMAGE: \'mdc-image-list__image\',\n  IMAGE_LIST_SUPPORTING: \'mdc-image-list__supporting\',\n  IMAGE_LIST_LABEL: \'mdc-image-list__label\'\n};\n;// CONCATENATED MODULE: ./src/image-list/ImageListItem.jsx\nvar ImageListItem_excluded = ["imageSrc", "label", "fixedAspect", "element", "className"];\n\nfunction ImageListItem_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction ImageListItem_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ImageListItem_ownKeys(Object(source), true).forEach(function (key) { ImageListItem_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ImageListItem_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction ImageListItem_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction ImageListItem_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = ImageListItem_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction ImageListItem_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\n\n\nvar ImageListItem = /*#__PURE__*/(0,react.forwardRef)(function (_ref, ref) {\n  var imageSrc = _ref.imageSrc,\n      label = _ref.label,\n      _ref$fixedAspect = _ref.fixedAspect,\n      fixedAspect = _ref$fixedAspect === void 0 ? true : _ref$fixedAspect,\n      _ref$element = _ref.element,\n      Element = _ref$element === void 0 ? \'li\' : _ref$element,\n      className = _ref.className,\n      props = ImageListItem_objectWithoutProperties(_ref, ImageListItem_excluded);\n\n  var classNames = classnames_default()(image_list_constants_cssClasses.IMAGE_LIST_ITEM, className);\n  return /*#__PURE__*/(0,jsx_runtime.jsxs)(Element, ImageListItem_objectSpread(ImageListItem_objectSpread({\n    ref: ref,\n    className: classNames\n  }, props), {}, {\n    children: [fixedAspect ? /*#__PURE__*/(0,jsx_runtime.jsx)("div", {\n      className: image_list_constants_cssClasses.IMAGE_LIST_IMAGE_ASPECT_CONTAINER,\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)("img", {\n        className: image_list_constants_cssClasses.IMAGE_LIST_IMAGE,\n        src: imageSrc,\n        alt: label\n      })\n    }) : /*#__PURE__*/(0,jsx_runtime.jsx)("img", {\n      className: image_list_constants_cssClasses.IMAGE_LIST_IMAGE,\n      src: imageSrc,\n      alt: label\n    }), label && /*#__PURE__*/(0,jsx_runtime.jsx)("div", {\n      className: image_list_constants_cssClasses.IMAGE_LIST_SUPPORTING,\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)("span", {\n        className: image_list_constants_cssClasses.IMAGE_LIST_LABEL,\n        children: label\n      })\n    })]\n  }));\n});\nImageListItem.displayName = \'MDCImageListItem\';\nImageListItem.propTypes = {\n  imageSrc: (prop_types_default()).string,\n  label: (prop_types_default()).node,\n  fixedAspect: (prop_types_default()).bool\n};\n/* harmony default export */ const image_list_ImageListItem = (ImageListItem);\n;// CONCATENATED MODULE: ./src/image-list/ImageList.jsx\nvar ImageList_excluded = ["items", "masonry", "withTextProtection", "element", "className", "children"];\n\nfunction ImageList_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction ImageList_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ImageList_ownKeys(Object(source), true).forEach(function (key) { ImageList_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ImageList_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction ImageList_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction ImageList_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = ImageList_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction ImageList_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\n\n\n\nvar ImageList = /*#__PURE__*/(0,react.forwardRef)(function (_ref, ref) {\n  var _classnames;\n\n  var items = _ref.items,\n      _ref$masonry = _ref.masonry,\n      masonry = _ref$masonry === void 0 ? false : _ref$masonry,\n      _ref$withTextProtecti = _ref.withTextProtection,\n      withTextProtection = _ref$withTextProtecti === void 0 ? false : _ref$withTextProtecti,\n      _ref$element = _ref.element,\n      Element = _ref$element === void 0 ? \'ul\' : _ref$element,\n      className = _ref.className,\n      _ref$children = _ref.children,\n      children = _ref$children === void 0 ? items === null || items === void 0 ? void 0 : items.map(function (item) {\n    return (0,react.createElement)(image_list_ImageListItem, item);\n  }) : _ref$children,\n      props = ImageList_objectWithoutProperties(_ref, ImageList_excluded);\n\n  var classNames = classnames_default()(image_list_constants_cssClasses.IMAGE_LIST, (_classnames = {}, ImageList_defineProperty(_classnames, image_list_constants_cssClasses.IMAGE_LIST_MASONRY, masonry), ImageList_defineProperty(_classnames, image_list_constants_cssClasses.IMAGE_LIST_WITH_TEXT_PROTECTION, withTextProtection), _classnames), className);\n  return /*#__PURE__*/(0,jsx_runtime.jsx)(Element, ImageList_objectSpread(ImageList_objectSpread({\n    ref: ref,\n    className: classNames\n  }, props), {}, {\n    children: react.Children.map(children, function (child) {\n      return (0,react.cloneElement)(child, {\n        fixedAspect: masonry ? false : undefined\n      });\n    })\n  }));\n});\nImageList.displayName = \'MDCImageList\';\nImageList.propTypes = {\n  items: (prop_types_default()).array,\n  masonry: (prop_types_default()).bool,\n  withTextProtection: (prop_types_default()).bool\n};\n/* harmony default export */ const image_list_ImageList = (ImageList);\n;// CONCATENATED MODULE: ./src/image-list/index.js\n\n\nimage_list_ImageList.Item = image_list_ImageListItem;\n\n;// CONCATENATED MODULE: ./src/layout/constants.js\nvar layout_constants_cssClasses = {\n  ROOT: \'mdc-layout\',\n  ROW: \'mdc-layout--row\',\n  COLUMN: \'mdc-layout--column\',\n  DIRECTION: \'mdc-layout--direction\',\n  WRAP: \'mdc-layout--wrap\',\n  WRAP_REVERSE: \'mdc-layout--wrap-reverse\',\n  ALIGN_ITEMS: \'mdc-layout--align-items\',\n  ALIGN_SELF: \'mdc-layout--align-self\',\n  JUSTIFY_CONTENT: \'mdc-layout--justify-content\'\n};\n;// CONCATENATED MODULE: ./src/layout/Layout.jsx\nvar Layout_excluded = ["row", "column", "direction", "wrap", "alignItems", "alignSelf", "justifyContent", "element", "component", "className"];\n\nfunction Layout_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction Layout_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { Layout_ownKeys(Object(source), true).forEach(function (key) { Layout_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { Layout_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction Layout_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction Layout_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = Layout_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction Layout_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\n\nvar Layout = /*#__PURE__*/(0,react.forwardRef)(function (_ref, ref) {\n  var _classnames;\n\n  var row = _ref.row,\n      column = _ref.column,\n      direction = _ref.direction,\n      wrap = _ref.wrap,\n      alignItems = _ref.alignItems,\n      alignSelf = _ref.alignSelf,\n      justifyContent = _ref.justifyContent,\n      _ref$element = _ref.element,\n      element = _ref$element === void 0 ? \'div\' : _ref$element,\n      _ref$component = _ref.component,\n      Element = _ref$component === void 0 ? element : _ref$component,\n      className = _ref.className,\n      props = Layout_objectWithoutProperties(_ref, Layout_excluded);\n\n  var classNames = classnames_default()(layout_constants_cssClasses.ROOT, (_classnames = {}, Layout_defineProperty(_classnames, layout_constants_cssClasses.ROW, row), Layout_defineProperty(_classnames, layout_constants_cssClasses.COLUMN, column), Layout_defineProperty(_classnames, "".concat(layout_constants_cssClasses.DIRECTION, "--").concat(direction), direction), Layout_defineProperty(_classnames, "".concat(layout_constants_cssClasses.ALIGN_ITEMS, "--").concat(alignItems), alignItems), Layout_defineProperty(_classnames, "".concat(layout_constants_cssClasses.ALIGN_SELF, "--").concat(alignSelf), alignSelf), Layout_defineProperty(_classnames, "".concat(layout_constants_cssClasses.JUSTIFY_CONTENT, "--").concat(justifyContent), justifyContent), Layout_defineProperty(_classnames, layout_constants_cssClasses.WRAP, wrap === true), Layout_defineProperty(_classnames, layout_constants_cssClasses.WRAP_REVERSE, wrap === \'reverse\'), _classnames), className);\n  return /*#__PURE__*/(0,jsx_runtime.jsx)(Element, Layout_objectSpread({\n    ref: ref,\n    className: classNames\n  }, props));\n});\nLayout.displayName = \'MDCLayout\';\nLayout.propTypes = {\n  row: (prop_types_default()).bool,\n  column: (prop_types_default()).bool,\n  direction: prop_types_default().oneOf([\'row\', \'column\']),\n  wrap: prop_types_default().oneOfType([(prop_types_default()).bool, (prop_types_default()).string]),\n  alignItems: prop_types_default().oneOf([\'start\', \'center\', \'end\']),\n  alignSelf: prop_types_default().oneOf([\'start\', \'center\', \'end\']),\n  justifyContent: prop_types_default().oneOf([\'start\', \'center\', \'end\', \'around\', \'between\'])\n};\n/* harmony default export */ const layout_Layout = (Layout);\n;// CONCATENATED MODULE: ./src/layout/index.js\n\n;// CONCATENATED MODULE: ./src/layout-grid/constants.js\nvar layout_grid_constants_cssClasses = {\n  ROOT: \'mdc-layout-grid\',\n  ALIGN: \'mdc-layout-grid--align\',\n  FIXED_COLUMN_WIDTH: \'mdc-layout-grid--fixed-column-width\',\n  INNER: \'mdc-layout-grid__inner\',\n  CELL: \'mdc-layout-grid__cell\',\n  CELL_SPAN: \'mdc-layout-grid__cell--span\',\n  CELL_ORDER: \'mdc-layout-grid__cell--order\',\n  CELL_ALIGN: \'mdc-layout-grid__cell--align\'\n};\n;// CONCATENATED MODULE: ./src/layout-grid/LayoutGrid.jsx\nvar LayoutGrid_excluded = ["align", "fixedColumnWidth", "element", "component", "className", "children"];\n\nfunction LayoutGrid_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction LayoutGrid_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { LayoutGrid_ownKeys(Object(source), true).forEach(function (key) { LayoutGrid_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { LayoutGrid_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction LayoutGrid_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction LayoutGrid_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = LayoutGrid_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction LayoutGrid_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\n\nvar LayoutGrid = /*#__PURE__*/(0,react.forwardRef)(function (_ref, ref) {\n  var _classnames;\n\n  var align = _ref.align,\n      _ref$fixedColumnWidth = _ref.fixedColumnWidth,\n      fixedColumnWidth = _ref$fixedColumnWidth === void 0 ? false : _ref$fixedColumnWidth,\n      _ref$element = _ref.element,\n      element = _ref$element === void 0 ? \'div\' : _ref$element,\n      _ref$component = _ref.component,\n      component = _ref$component === void 0 ? element : _ref$component,\n      className = _ref.className,\n      children = _ref.children,\n      props = LayoutGrid_objectWithoutProperties(_ref, LayoutGrid_excluded);\n\n  var Element = component;\n  var classNames = classnames_default()(layout_grid_constants_cssClasses.ROOT, (_classnames = {}, LayoutGrid_defineProperty(_classnames, "".concat(layout_grid_constants_cssClasses.ALIGN, "-").concat(align), align), LayoutGrid_defineProperty(_classnames, layout_grid_constants_cssClasses.FIXED_COLUMN_WIDTH, fixedColumnWidth), _classnames), className);\n  return /*#__PURE__*/(0,jsx_runtime.jsx)(Element, LayoutGrid_objectSpread(LayoutGrid_objectSpread({\n    ref: ref,\n    className: classNames\n  }, props), {}, {\n    children: /*#__PURE__*/(0,jsx_runtime.jsx)("div", {\n      className: layout_grid_constants_cssClasses.INNER,\n      children: children\n    })\n  }));\n});\nLayoutGrid.displayName = \'MDCLayoutGrid\';\nLayoutGrid.propTypes = {\n  align: prop_types_default().oneOf([\'left\', \'right\']),\n  fixedColumnWidth: (prop_types_default()).bool\n};\n/* harmony default export */ const layout_grid_LayoutGrid = (LayoutGrid);\n;// CONCATENATED MODULE: ./src/layout-grid/LayoutGridCell.jsx\nvar LayoutGridCell_excluded = ["span", "desktop", "tablet", "mobile", "order", "align", "grid", "element", "component", "className", "children"];\n\nfunction LayoutGridCell_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction LayoutGridCell_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { LayoutGridCell_ownKeys(Object(source), true).forEach(function (key) { LayoutGridCell_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { LayoutGridCell_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction LayoutGridCell_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction LayoutGridCell_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = LayoutGridCell_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction LayoutGridCell_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\n\nvar LayoutGridCell = /*#__PURE__*/(0,react.forwardRef)(function (_ref, ref) {\n  var _classnames;\n\n  var span = _ref.span,\n      desktop = _ref.desktop,\n      tablet = _ref.tablet,\n      mobile = _ref.mobile,\n      order = _ref.order,\n      align = _ref.align,\n      _ref$grid = _ref.grid,\n      grid = _ref$grid === void 0 ? false : _ref$grid,\n      _ref$element = _ref.element,\n      element = _ref$element === void 0 ? \'div\' : _ref$element,\n      _ref$component = _ref.component,\n      component = _ref$component === void 0 ? element : _ref$component,\n      className = _ref.className,\n      children = _ref.children,\n      props = LayoutGridCell_objectWithoutProperties(_ref, LayoutGridCell_excluded);\n\n  var Element = component;\n  var classNames = classnames_default()(layout_grid_constants_cssClasses.CELL, (_classnames = {}, LayoutGridCell_defineProperty(_classnames, "".concat(layout_grid_constants_cssClasses.CELL_SPAN, "-").concat(span), span), LayoutGridCell_defineProperty(_classnames, "".concat(layout_grid_constants_cssClasses.CELL_SPAN, "-").concat(desktop, "-desktop"), desktop), LayoutGridCell_defineProperty(_classnames, "".concat(layout_grid_constants_cssClasses.CELL_SPAN, "-").concat(tablet, "-tablet"), tablet), LayoutGridCell_defineProperty(_classnames, "".concat(layout_grid_constants_cssClasses.CELL_SPAN, "-").concat(mobile, "-mobile"), mobile), LayoutGridCell_defineProperty(_classnames, "".concat(layout_grid_constants_cssClasses.CELL_ORDER, "-").concat(order), order), LayoutGridCell_defineProperty(_classnames, "".concat(layout_grid_constants_cssClasses.CELL_ALIGN, "-").concat(align), align), _classnames), className);\n  return /*#__PURE__*/(0,jsx_runtime.jsx)(Element, LayoutGridCell_objectSpread(LayoutGridCell_objectSpread({\n    ref: ref,\n    className: classNames\n  }, props), {}, {\n    children: grid ? /*#__PURE__*/(0,jsx_runtime.jsx)("div", {\n      className: layout_grid_constants_cssClasses.INNER,\n      children: children\n    }) : children\n  }));\n});\nLayoutGridCell.displayName = \'MDCLayoutGridCell\';\nLayoutGridCell.propTypes = {\n  span: prop_types_default().oneOfType([(prop_types_default()).number, (prop_types_default()).string]),\n  desktop: (prop_types_default()).number,\n  tablet: (prop_types_default()).number,\n  mobile: (prop_types_default()).number,\n  order: (prop_types_default()).number,\n  align: prop_types_default().oneOf([\'top\', \'middle\', \'bottom\']),\n  grid: (prop_types_default()).bool\n};\n/* harmony default export */ const layout_grid_LayoutGridCell = (LayoutGridCell);\n;// CONCATENATED MODULE: ./src/layout-grid/index.js\n\n\nlayout_grid_LayoutGrid.Cell = layout_grid_LayoutGridCell;\n\n;// CONCATENATED MODULE: ./src/radio/constants.js\nvar radio_constants_cssClasses = {\n  ROOT: \'mdc-radio\',\n  DISABLED: \'mdc-radio--disabled\',\n  TOUCH: \'mdc-radio--touch\',\n  NATIVE_CONTROL: \'mdc-radio__native-control\',\n  BACKGROUND: \'mdc-radio__background\',\n  OUTER_CIRCLE: \'mdc-radio__outer-circle\',\n  INNER_CIRCLE: \'mdc-radio__inner-circle\',\n  RIPPLE: \'mdc-radio__ripple\'\n};\n;// CONCATENATED MODULE: ./src/radio/Radio.jsx\nvar Radio_excluded = ["value", "checked", "disabled", "touch", "onChange", "className"];\n\nfunction Radio_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction Radio_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { Radio_ownKeys(Object(source), true).forEach(function (key) { Radio_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { Radio_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction Radio_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction Radio_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = Radio_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction Radio_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\n\n\nvar Radio = /*#__PURE__*/(0,react.forwardRef)(function (_ref, ref) {\n  var _classnames;\n\n  var value = _ref.value,\n      checked = _ref.checked,\n      _ref$disabled = _ref.disabled,\n      disabled = _ref$disabled === void 0 ? false : _ref$disabled,\n      _ref$touch = _ref.touch,\n      touch = _ref$touch === void 0 ? false : _ref$touch,\n      _ref$onChange = _ref.onChange,\n      onChange = _ref$onChange === void 0 ? Function.prototype : _ref$onChange,\n      className = _ref.className,\n      props = Radio_objectWithoutProperties(_ref, Radio_excluded);\n\n  var inputRef = (0,react.useRef)();\n  var handleChange = (0,react.useCallback)(function (event) {\n    onChange(event, event.target.value, event.target);\n  }, [onChange]);\n  var classNames = classnames_default()(radio_constants_cssClasses.ROOT, (_classnames = {}, Radio_defineProperty(_classnames, radio_constants_cssClasses.DISABLED, disabled), Radio_defineProperty(_classnames, radio_constants_cssClasses.TOUCH, touch), _classnames), className);\n  return /*#__PURE__*/(0,jsx_runtime.jsxs)("div", {\n    ref: ref,\n    className: classNames,\n    children: [/*#__PURE__*/(0,jsx_runtime.jsx)("input", Radio_objectSpread({\n      ref: inputRef,\n      className: radio_constants_cssClasses.NATIVE_CONTROL,\n      type: "radio",\n      value: value,\n      checked: checked,\n      disabled: disabled,\n      onChange: handleChange\n    }, props)), /*#__PURE__*/(0,jsx_runtime.jsxs)("div", {\n      className: radio_constants_cssClasses.BACKGROUND,\n      children: [/*#__PURE__*/(0,jsx_runtime.jsx)("div", {\n        className: radio_constants_cssClasses.OUTER_CIRCLE\n      }), /*#__PURE__*/(0,jsx_runtime.jsx)("div", {\n        className: radio_constants_cssClasses.INNER_CIRCLE\n      })]\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)("div", {\n      className: radio_constants_cssClasses.RIPPLE\n    })]\n  });\n});\nRadio.displayName = \'MDCRadio\';\nRadio.propTypes = {\n  value: (prop_types_default()).any,\n  checked: (prop_types_default()).bool,\n  disabled: (prop_types_default()).bool,\n  touch: (prop_types_default()).bool,\n  onChange: (prop_types_default()).func\n};\n/* harmony default export */ const radio_Radio = (Radio);\n;// CONCATENATED MODULE: ./src/radio/index.js\n\n;// CONCATENATED MODULE: ./node_modules/tslib/tslib.es6.js\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nfunction __extends(d, b) {\r\n    if (typeof b !== "function" && b !== null)\r\n        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nvar __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nfunction __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === "function")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nfunction __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nfunction __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nfunction __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nfunction __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nfunction __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError("Generator is already executing.");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nvar __createBinding = Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n});\r\n\r\nfunction __exportStar(m, o) {\r\n    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);\r\n}\r\n\r\nfunction __values(o) {\r\n    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === "number") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");\r\n}\r\n\r\nfunction __read(o, n) {\r\n    var m = typeof Symbol === "function" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i["return"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nfunction __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nfunction __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n}\r\n\r\nfunction __spreadArray(to, from, pack) {\r\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\r\n        if (ar || !(i in from)) {\r\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\r\n            ar[i] = from[i];\r\n        }\r\n    }\r\n    return to.concat(ar || Array.prototype.slice.call(from));\r\n}\r\n\r\nfunction __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nfunction __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume("next", value); }\r\n    function reject(value) { resume("throw", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nfunction __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nfunction __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nfunction __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nvar __setModuleDefault = Object.create ? (function(o, v) {\r\n    Object.defineProperty(o, "default", { enumerable: true, value: v });\r\n}) : function(o, v) {\r\n    o["default"] = v;\r\n};\r\n\r\nfunction __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\r\n    __setModuleDefault(result, mod);\r\n    return result;\r\n}\r\n\r\nfunction __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nfunction __classPrivateFieldGet(receiver, state, kind, f) {\r\n    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");\r\n    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");\r\n    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);\r\n}\r\n\r\nfunction __classPrivateFieldSet(receiver, state, value, kind, f) {\r\n    if (kind === "m") throw new TypeError("Private method is not writable");\r\n    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");\r\n    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");\r\n    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\r\n}\r\n\n;// CONCATENATED MODULE: ./node_modules/@material/base/foundation.js\n/**\n * @license\n * Copyright 2016 Google Inc.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the "Software"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\nvar MDCFoundation = /** @class */ (function () {\n    function MDCFoundation(adapter) {\n        if (adapter === void 0) { adapter = {}; }\n        this.adapter = adapter;\n    }\n    Object.defineProperty(MDCFoundation, "cssClasses", {\n        get: function () {\n            // Classes extending MDCFoundation should implement this method to return an object which exports every\n            // CSS class the foundation class needs as a property. e.g. {ACTIVE: \'mdc-component--active\'}\n            return {};\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(MDCFoundation, "strings", {\n        get: function () {\n            // Classes extending MDCFoundation should implement this method to return an object which exports all\n            // semantic strings as constants. e.g. {ARIA_ROLE: \'tablist\'}\n            return {};\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(MDCFoundation, "numbers", {\n        get: function () {\n            // Classes extending MDCFoundation should implement this method to return an object which exports all\n            // of its semantic numbers as constants. e.g. {ANIMATION_DELAY_MS: 350}\n            return {};\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(MDCFoundation, "defaultAdapter", {\n        get: function () {\n            // Classes extending MDCFoundation may choose to implement this getter in order to provide a convenient\n            // way of viewing the necessary methods of an adapter. In the future, this could also be used for adapter\n            // validation.\n            return {};\n        },\n        enumerable: false,\n        configurable: true\n    });\n    MDCFoundation.prototype.init = function () {\n        // Subclasses should override this method to perform initialization routines (registering events, etc.)\n    };\n    MDCFoundation.prototype.destroy = function () {\n        // Subclasses should override this method to perform de-initialization routines (de-registering events, etc.)\n    };\n    return MDCFoundation;\n}());\n\n// tslint:disable-next-line:no-default-export Needed for backward compatibility with MDC Web v0.44.0 and earlier.\n/* harmony default export */ const foundation = ((/* unused pure expression or super */ null && (MDCFoundation)));\n//# sourceMappingURL=foundation.js.map\n;// CONCATENATED MODULE: ./node_modules/@material/base/component.js\n/**\n * @license\n * Copyright 2016 Google Inc.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the "Software"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\n\n\nvar MDCComponent = /** @class */ (function () {\n    function MDCComponent(root, foundation) {\n        var args = [];\n        for (var _i = 2; _i < arguments.length; _i++) {\n            args[_i - 2] = arguments[_i];\n        }\n        this.root = root;\n        this.initialize.apply(this, __spreadArray([], __read(args)));\n        // Note that we initialize foundation here and not within the constructor\'s\n        // default param so that this.root is defined and can be used within the\n        // foundation class.\n        this.foundation =\n            foundation === undefined ? this.getDefaultFoundation() : foundation;\n        this.foundation.init();\n        this.initialSyncWithDOM();\n    }\n    MDCComponent.attachTo = function (root) {\n        // Subclasses which extend MDCBase should provide an attachTo() method that takes a root element and\n        // returns an instantiated component with its root set to that element. Also note that in the cases of\n        // subclasses, an explicit foundation class will not have to be passed in; it will simply be initialized\n        // from getDefaultFoundation().\n        return new MDCComponent(root, new MDCFoundation({}));\n    };\n    /* istanbul ignore next: method param only exists for typing purposes; it does not need to be unit tested */\n    MDCComponent.prototype.initialize = function () {\n        var _args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            _args[_i] = arguments[_i];\n        }\n        // Subclasses can override this to do any additional setup work that would be considered part of a\n        // "constructor". Essentially, it is a hook into the parent constructor before the foundation is\n        // initialized. Any additional arguments besides root and foundation will be passed in here.\n    };\n    MDCComponent.prototype.getDefaultFoundation = function () {\n        // Subclasses must override this method to return a properly configured foundation class for the\n        // component.\n        throw new Error(\'Subclasses must override getDefaultFoundation to return a properly configured \' +\n            \'foundation class\');\n    };\n    MDCComponent.prototype.initialSyncWithDOM = function () {\n        // Subclasses should override this method if they need to perform work to synchronize with a host DOM\n        // object. An example of this would be a form control wrapper that needs to synchronize its internal state\n        // to some property or attribute of the host DOM. Please note: this is *not* the place to perform DOM\n        // reads/writes that would cause layout / paint, as this is called synchronously from within the constructor.\n    };\n    MDCComponent.prototype.destroy = function () {\n        // Subclasses may implement this method to release any resources / deregister any listeners they have\n        // attached. An example of this might be deregistering a resize event from the window object.\n        this.foundation.destroy();\n    };\n    MDCComponent.prototype.listen = function (evtType, handler, options) {\n        this.root.addEventListener(evtType, handler, options);\n    };\n    MDCComponent.prototype.unlisten = function (evtType, handler, options) {\n        this.root.removeEventListener(evtType, handler, options);\n    };\n    /**\n     * Fires a cross-browser-compatible custom event from the component root of the given type, with the given data.\n     */\n    MDCComponent.prototype.emit = function (evtType, evtData, shouldBubble) {\n        if (shouldBubble === void 0) { shouldBubble = false; }\n        var evt;\n        if (typeof CustomEvent === \'function\') {\n            evt = new CustomEvent(evtType, {\n                bubbles: shouldBubble,\n                detail: evtData,\n            });\n        }\n        else {\n            evt = document.createEvent(\'CustomEvent\');\n            evt.initCustomEvent(evtType, shouldBubble, false, evtData);\n        }\n        this.root.dispatchEvent(evt);\n    };\n    return MDCComponent;\n}());\n\n// tslint:disable-next-line:no-default-export Needed for backward compatibility with MDC Web v0.44.0 and earlier.\n/* harmony default export */ const component = ((/* unused pure expression or super */ null && (MDCComponent)));\n//# sourceMappingURL=component.js.map\n;// CONCATENATED MODULE: ./node_modules/@material/dom/events.js\n/**\n * @license\n * Copyright 2019 Google Inc.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the "Software"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\n/**\n * Determine whether the current browser supports passive event listeners, and\n * if so, use them.\n */\nfunction applyPassive(globalObj) {\n    if (globalObj === void 0) { globalObj = window; }\n    return supportsPassiveOption(globalObj) ?\n        { passive: true } :\n        false;\n}\nfunction supportsPassiveOption(globalObj) {\n    if (globalObj === void 0) { globalObj = window; }\n    // See\n    // https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener\n    var passiveSupported = false;\n    try {\n        var options = {\n            // This function will be called when the browser\n            // attempts to access the passive property.\n            get passive() {\n                passiveSupported = true;\n                return false;\n            }\n        };\n        var handler = function () { };\n        globalObj.document.addEventListener(\'test\', handler, options);\n        globalObj.document.removeEventListener(\'test\', handler, options);\n    }\n    catch (err) {\n        passiveSupported = false;\n    }\n    return passiveSupported;\n}\n//# sourceMappingURL=events.js.map\n;// CONCATENATED MODULE: ./node_modules/@material/dom/ponyfill.js\n/**\n * @license\n * Copyright 2018 Google Inc.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the "Software"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\n/**\n * @fileoverview A "ponyfill" is a polyfill that doesn\'t modify the global prototype chain.\n * This makes ponyfills safer than traditional polyfills, especially for libraries like MDC.\n */\nfunction closest(element, selector) {\n    if (element.closest) {\n        return element.closest(selector);\n    }\n    var el = element;\n    while (el) {\n        if (matches(el, selector)) {\n            return el;\n        }\n        el = el.parentElement;\n    }\n    return null;\n}\nfunction matches(element, selector) {\n    var nativeMatches = element.matches\n        || element.webkitMatchesSelector\n        || element.msMatchesSelector;\n    return nativeMatches.call(element, selector);\n}\n/**\n * Used to compute the estimated scroll width of elements. When an element is\n * hidden due to display: none; being applied to a parent element, the width is\n * returned as 0. However, the element will have a true width once no longer\n * inside a display: none context. This method computes an estimated width when\n * the element is hidden or returns the true width when the element is visble.\n * @param {Element} element the element whose width to estimate\n */\nfunction estimateScrollWidth(element) {\n    // Check the offsetParent. If the element inherits display: none from any\n    // parent, the offsetParent property will be null (see\n    // https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/offsetParent).\n    // This check ensures we only clone the node when necessary.\n    var htmlEl = element;\n    if (htmlEl.offsetParent !== null) {\n        return htmlEl.scrollWidth;\n    }\n    var clone = htmlEl.cloneNode(true);\n    clone.style.setProperty(\'position\', \'absolute\');\n    clone.style.setProperty(\'transform\', \'translate(-9999px, -9999px)\');\n    document.documentElement.appendChild(clone);\n    var scrollWidth = clone.scrollWidth;\n    document.documentElement.removeChild(clone);\n    return scrollWidth;\n}\n//# sourceMappingURL=ponyfill.js.map\n;// CONCATENATED MODULE: ./node_modules/@material/ripple/constants.js\n/**\n * @license\n * Copyright 2016 Google Inc.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the "Software"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\nvar ripple_constants_cssClasses = {\n    // Ripple is a special case where the "root" component is really a "mixin" of sorts,\n    // given that it\'s an \'upgrade\' to an existing component. That being said it is the root\n    // CSS class that all other CSS classes derive from.\n    BG_FOCUSED: \'mdc-ripple-upgraded--background-focused\',\n    FG_ACTIVATION: \'mdc-ripple-upgraded--foreground-activation\',\n    FG_DEACTIVATION: \'mdc-ripple-upgraded--foreground-deactivation\',\n    ROOT: \'mdc-ripple-upgraded\',\n    UNBOUNDED: \'mdc-ripple-upgraded--unbounded\',\n};\nvar constants_strings = {\n    VAR_FG_SCALE: \'--mdc-ripple-fg-scale\',\n    VAR_FG_SIZE: \'--mdc-ripple-fg-size\',\n    VAR_FG_TRANSLATE_END: \'--mdc-ripple-fg-translate-end\',\n    VAR_FG_TRANSLATE_START: \'--mdc-ripple-fg-translate-start\',\n    VAR_LEFT: \'--mdc-ripple-left\',\n    VAR_TOP: \'--mdc-ripple-top\',\n};\nvar ripple_constants_numbers = {\n    DEACTIVATION_TIMEOUT_MS: 225,\n    FG_DEACTIVATION_MS: 150,\n    INITIAL_ORIGIN_SCALE: 0.6,\n    PADDING: 10,\n    TAP_DELAY_MS: 300, // Delay between touch and simulated mouse events on touch devices\n};\n//# sourceMappingURL=constants.js.map\n;// CONCATENATED MODULE: ./node_modules/@material/ripple/util.js\n/**\n * Stores result from supportsCssVariables to avoid redundant processing to\n * detect CSS custom variable support.\n */\nvar supportsCssVariables_;\nfunction supportsCssVariables(windowObj, forceRefresh) {\n    if (forceRefresh === void 0) { forceRefresh = false; }\n    var CSS = windowObj.CSS;\n    var supportsCssVars = supportsCssVariables_;\n    if (typeof supportsCssVariables_ === \'boolean\' && !forceRefresh) {\n        return supportsCssVariables_;\n    }\n    var supportsFunctionPresent = CSS && typeof CSS.supports === \'function\';\n    if (!supportsFunctionPresent) {\n        return false;\n    }\n    var explicitlySupportsCssVars = CSS.supports(\'--css-vars\', \'yes\');\n    // See: https://bugs.webkit.org/show_bug.cgi?id=154669\n    // See: README section on Safari\n    var weAreFeatureDetectingSafari10plus = (CSS.supports(\'(--css-vars: yes)\') &&\n        CSS.supports(\'color\', \'#00000000\'));\n    supportsCssVars =\n        explicitlySupportsCssVars || weAreFeatureDetectingSafari10plus;\n    if (!forceRefresh) {\n        supportsCssVariables_ = supportsCssVars;\n    }\n    return supportsCssVars;\n}\nfunction getNormalizedEventCoords(evt, pageOffset, clientRect) {\n    if (!evt) {\n        return { x: 0, y: 0 };\n    }\n    var x = pageOffset.x, y = pageOffset.y;\n    var documentX = x + clientRect.left;\n    var documentY = y + clientRect.top;\n    var normalizedX;\n    var normalizedY;\n    // Determine touch point relative to the ripple container.\n    if (evt.type === \'touchstart\') {\n        var touchEvent = evt;\n        normalizedX = touchEvent.changedTouches[0].pageX - documentX;\n        normalizedY = touchEvent.changedTouches[0].pageY - documentY;\n    }\n    else {\n        var mouseEvent = evt;\n        normalizedX = mouseEvent.pageX - documentX;\n        normalizedY = mouseEvent.pageY - documentY;\n    }\n    return { x: normalizedX, y: normalizedY };\n}\n//# sourceMappingURL=util.js.map\n;// CONCATENATED MODULE: ./node_modules/@material/ripple/foundation.js\n/**\n * @license\n * Copyright 2016 Google Inc.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the "Software"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\n\n\n\n\n// Activation events registered on the root element of each instance for activation\nvar ACTIVATION_EVENT_TYPES = [\n    \'touchstart\', \'pointerdown\', \'mousedown\', \'keydown\',\n];\n// Deactivation events registered on documentElement when a pointer-related down event occurs\nvar POINTER_DEACTIVATION_EVENT_TYPES = [\n    \'touchend\', \'pointerup\', \'mouseup\', \'contextmenu\',\n];\n// simultaneous nested activations\nvar activatedTargets = [];\nvar MDCRippleFoundation = /** @class */ (function (_super) {\n    __extends(MDCRippleFoundation, _super);\n    function MDCRippleFoundation(adapter) {\n        var _this = _super.call(this, __assign(__assign({}, MDCRippleFoundation.defaultAdapter), adapter)) || this;\n        _this.activationAnimationHasEnded = false;\n        _this.activationTimer = 0;\n        _this.fgDeactivationRemovalTimer = 0;\n        _this.fgScale = \'0\';\n        _this.frame = { width: 0, height: 0 };\n        _this.initialSize = 0;\n        _this.layoutFrame = 0;\n        _this.maxRadius = 0;\n        _this.unboundedCoords = { left: 0, top: 0 };\n        _this.activationState = _this.defaultActivationState();\n        _this.activationTimerCallback = function () {\n            _this.activationAnimationHasEnded = true;\n            _this.runDeactivationUXLogicIfReady();\n        };\n        _this.activateHandler = function (e) {\n            _this.activateImpl(e);\n        };\n        _this.deactivateHandler = function () {\n            _this.deactivateImpl();\n        };\n        _this.focusHandler = function () {\n            _this.handleFocus();\n        };\n        _this.blurHandler = function () {\n            _this.handleBlur();\n        };\n        _this.resizeHandler = function () {\n            _this.layout();\n        };\n        return _this;\n    }\n    Object.defineProperty(MDCRippleFoundation, "cssClasses", {\n        get: function () {\n            return ripple_constants_cssClasses;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(MDCRippleFoundation, "strings", {\n        get: function () {\n            return constants_strings;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(MDCRippleFoundation, "numbers", {\n        get: function () {\n            return ripple_constants_numbers;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(MDCRippleFoundation, "defaultAdapter", {\n        get: function () {\n            return {\n                addClass: function () { return undefined; },\n                browserSupportsCssVars: function () { return true; },\n                computeBoundingRect: function () {\n                    return ({ top: 0, right: 0, bottom: 0, left: 0, width: 0, height: 0 });\n                },\n                containsEventTarget: function () { return true; },\n                deregisterDocumentInteractionHandler: function () { return undefined; },\n                deregisterInteractionHandler: function () { return undefined; },\n                deregisterResizeHandler: function () { return undefined; },\n                getWindowPageOffset: function () { return ({ x: 0, y: 0 }); },\n                isSurfaceActive: function () { return true; },\n                isSurfaceDisabled: function () { return true; },\n                isUnbounded: function () { return true; },\n                registerDocumentInteractionHandler: function () { return undefined; },\n                registerInteractionHandler: function () { return undefined; },\n                registerResizeHandler: function () { return undefined; },\n                removeClass: function () { return undefined; },\n                updateCssVariable: function () { return undefined; },\n            };\n        },\n        enumerable: false,\n        configurable: true\n    });\n    MDCRippleFoundation.prototype.init = function () {\n        var _this = this;\n        var supportsPressRipple = this.supportsPressRipple();\n        this.registerRootHandlers(supportsPressRipple);\n        if (supportsPressRipple) {\n            var _a = MDCRippleFoundation.cssClasses, ROOT_1 = _a.ROOT, UNBOUNDED_1 = _a.UNBOUNDED;\n            requestAnimationFrame(function () {\n                _this.adapter.addClass(ROOT_1);\n                if (_this.adapter.isUnbounded()) {\n                    _this.adapter.addClass(UNBOUNDED_1);\n                    // Unbounded ripples need layout logic applied immediately to set coordinates for both shade and ripple\n                    _this.layoutInternal();\n                }\n            });\n        }\n    };\n    MDCRippleFoundation.prototype.destroy = function () {\n        var _this = this;\n        if (this.supportsPressRipple()) {\n            if (this.activationTimer) {\n                clearTimeout(this.activationTimer);\n                this.activationTimer = 0;\n                this.adapter.removeClass(MDCRippleFoundation.cssClasses.FG_ACTIVATION);\n            }\n            if (this.fgDeactivationRemovalTimer) {\n                clearTimeout(this.fgDeactivationRemovalTimer);\n                this.fgDeactivationRemovalTimer = 0;\n                this.adapter.removeClass(MDCRippleFoundation.cssClasses.FG_DEACTIVATION);\n            }\n            var _a = MDCRippleFoundation.cssClasses, ROOT_2 = _a.ROOT, UNBOUNDED_2 = _a.UNBOUNDED;\n            requestAnimationFrame(function () {\n                _this.adapter.removeClass(ROOT_2);\n                _this.adapter.removeClass(UNBOUNDED_2);\n                _this.removeCssVars();\n            });\n        }\n        this.deregisterRootHandlers();\n        this.deregisterDeactivationHandlers();\n    };\n    /**\n     * @param evt Optional event containing position information.\n     */\n    MDCRippleFoundation.prototype.activate = function (evt) {\n        this.activateImpl(evt);\n    };\n    MDCRippleFoundation.prototype.deactivate = function () {\n        this.deactivateImpl();\n    };\n    MDCRippleFoundation.prototype.layout = function () {\n        var _this = this;\n        if (this.layoutFrame) {\n            cancelAnimationFrame(this.layoutFrame);\n        }\n        this.layoutFrame = requestAnimationFrame(function () {\n            _this.layoutInternal();\n            _this.layoutFrame = 0;\n        });\n    };\n    MDCRippleFoundation.prototype.setUnbounded = function (unbounded) {\n        var UNBOUNDED = MDCRippleFoundation.cssClasses.UNBOUNDED;\n        if (unbounded) {\n            this.adapter.addClass(UNBOUNDED);\n        }\n        else {\n            this.adapter.removeClass(UNBOUNDED);\n        }\n    };\n    MDCRippleFoundation.prototype.handleFocus = function () {\n        var _this = this;\n        requestAnimationFrame(function () { return _this.adapter.addClass(MDCRippleFoundation.cssClasses.BG_FOCUSED); });\n    };\n    MDCRippleFoundation.prototype.handleBlur = function () {\n        var _this = this;\n        requestAnimationFrame(function () { return _this.adapter.removeClass(MDCRippleFoundation.cssClasses.BG_FOCUSED); });\n    };\n    /**\n     * We compute this property so that we are not querying information about the client\n     * until the point in time where the foundation requests it. This prevents scenarios where\n     * client-side feature-detection may happen too early, such as when components are rendered on the server\n     * and then initialized at mount time on the client.\n     */\n    MDCRippleFoundation.prototype.supportsPressRipple = function () {\n        return this.adapter.browserSupportsCssVars();\n    };\n    MDCRippleFoundation.prototype.defaultActivationState = function () {\n        return {\n            activationEvent: undefined,\n            hasDeactivationUXRun: false,\n            isActivated: false,\n            isProgrammatic: false,\n            wasActivatedByPointer: false,\n            wasElementMadeActive: false,\n        };\n    };\n    /**\n     * supportsPressRipple Passed from init to save a redundant function call\n     */\n    MDCRippleFoundation.prototype.registerRootHandlers = function (supportsPressRipple) {\n        var e_1, _a;\n        if (supportsPressRipple) {\n            try {\n                for (var ACTIVATION_EVENT_TYPES_1 = __values(ACTIVATION_EVENT_TYPES), ACTIVATION_EVENT_TYPES_1_1 = ACTIVATION_EVENT_TYPES_1.next(); !ACTIVATION_EVENT_TYPES_1_1.done; ACTIVATION_EVENT_TYPES_1_1 = ACTIVATION_EVENT_TYPES_1.next()) {\n                    var evtType = ACTIVATION_EVENT_TYPES_1_1.value;\n                    this.adapter.registerInteractionHandler(evtType, this.activateHandler);\n                }\n            }\n            catch (e_1_1) { e_1 = { error: e_1_1 }; }\n            finally {\n                try {\n                    if (ACTIVATION_EVENT_TYPES_1_1 && !ACTIVATION_EVENT_TYPES_1_1.done && (_a = ACTIVATION_EVENT_TYPES_1.return)) _a.call(ACTIVATION_EVENT_TYPES_1);\n                }\n                finally { if (e_1) throw e_1.error; }\n            }\n            if (this.adapter.isUnbounded()) {\n                this.adapter.registerResizeHandler(this.resizeHandler);\n            }\n        }\n        this.adapter.registerInteractionHandler(\'focus\', this.focusHandler);\n        this.adapter.registerInteractionHandler(\'blur\', this.blurHandler);\n    };\n    MDCRippleFoundation.prototype.registerDeactivationHandlers = function (evt) {\n        var e_2, _a;\n        if (evt.type === \'keydown\') {\n            this.adapter.registerInteractionHandler(\'keyup\', this.deactivateHandler);\n        }\n        else {\n            try {\n                for (var POINTER_DEACTIVATION_EVENT_TYPES_1 = __values(POINTER_DEACTIVATION_EVENT_TYPES), POINTER_DEACTIVATION_EVENT_TYPES_1_1 = POINTER_DEACTIVATION_EVENT_TYPES_1.next(); !POINTER_DEACTIVATION_EVENT_TYPES_1_1.done; POINTER_DEACTIVATION_EVENT_TYPES_1_1 = POINTER_DEACTIVATION_EVENT_TYPES_1.next()) {\n                    var evtType = POINTER_DEACTIVATION_EVENT_TYPES_1_1.value;\n                    this.adapter.registerDocumentInteractionHandler(evtType, this.deactivateHandler);\n                }\n            }\n            catch (e_2_1) { e_2 = { error: e_2_1 }; }\n            finally {\n                try {\n                    if (POINTER_DEACTIVATION_EVENT_TYPES_1_1 && !POINTER_DEACTIVATION_EVENT_TYPES_1_1.done && (_a = POINTER_DEACTIVATION_EVENT_TYPES_1.return)) _a.call(POINTER_DEACTIVATION_EVENT_TYPES_1);\n                }\n                finally { if (e_2) throw e_2.error; }\n            }\n        }\n    };\n    MDCRippleFoundation.prototype.deregisterRootHandlers = function () {\n        var e_3, _a;\n        try {\n            for (var ACTIVATION_EVENT_TYPES_2 = __values(ACTIVATION_EVENT_TYPES), ACTIVATION_EVENT_TYPES_2_1 = ACTIVATION_EVENT_TYPES_2.next(); !ACTIVATION_EVENT_TYPES_2_1.done; ACTIVATION_EVENT_TYPES_2_1 = ACTIVATION_EVENT_TYPES_2.next()) {\n                var evtType = ACTIVATION_EVENT_TYPES_2_1.value;\n                this.adapter.deregisterInteractionHandler(evtType, this.activateHandler);\n            }\n        }\n        catch (e_3_1) { e_3 = { error: e_3_1 }; }\n        finally {\n            try {\n                if (ACTIVATION_EVENT_TYPES_2_1 && !ACTIVATION_EVENT_TYPES_2_1.done && (_a = ACTIVATION_EVENT_TYPES_2.return)) _a.call(ACTIVATION_EVENT_TYPES_2);\n            }\n            finally { if (e_3) throw e_3.error; }\n        }\n        this.adapter.deregisterInteractionHandler(\'focus\', this.focusHandler);\n        this.adapter.deregisterInteractionHandler(\'blur\', this.blurHandler);\n        if (this.adapter.isUnbounded()) {\n            this.adapter.deregisterResizeHandler(this.resizeHandler);\n        }\n    };\n    MDCRippleFoundation.prototype.deregisterDeactivationHandlers = function () {\n        var e_4, _a;\n        this.adapter.deregisterInteractionHandler(\'keyup\', this.deactivateHandler);\n        try {\n            for (var POINTER_DEACTIVATION_EVENT_TYPES_2 = __values(POINTER_DEACTIVATION_EVENT_TYPES), POINTER_DEACTIVATION_EVENT_TYPES_2_1 = POINTER_DEACTIVATION_EVENT_TYPES_2.next(); !POINTER_DEACTIVATION_EVENT_TYPES_2_1.done; POINTER_DEACTIVATION_EVENT_TYPES_2_1 = POINTER_DEACTIVATION_EVENT_TYPES_2.next()) {\n                var evtType = POINTER_DEACTIVATION_EVENT_TYPES_2_1.value;\n                this.adapter.deregisterDocumentInteractionHandler(evtType, this.deactivateHandler);\n            }\n        }\n        catch (e_4_1) { e_4 = { error: e_4_1 }; }\n        finally {\n            try {\n                if (POINTER_DEACTIVATION_EVENT_TYPES_2_1 && !POINTER_DEACTIVATION_EVENT_TYPES_2_1.done && (_a = POINTER_DEACTIVATION_EVENT_TYPES_2.return)) _a.call(POINTER_DEACTIVATION_EVENT_TYPES_2);\n            }\n            finally { if (e_4) throw e_4.error; }\n        }\n    };\n    MDCRippleFoundation.prototype.removeCssVars = function () {\n        var _this = this;\n        var rippleStrings = MDCRippleFoundation.strings;\n        var keys = Object.keys(rippleStrings);\n        keys.forEach(function (key) {\n            if (key.indexOf(\'VAR_\') === 0) {\n                _this.adapter.updateCssVariable(rippleStrings[key], null);\n            }\n        });\n    };\n    MDCRippleFoundation.prototype.activateImpl = function (evt) {\n        var _this = this;\n        if (this.adapter.isSurfaceDisabled()) {\n            return;\n        }\n        var activationState = this.activationState;\n        if (activationState.isActivated) {\n            return;\n        }\n        // Avoid reacting to follow-on events fired by touch device after an already-processed user interaction\n        var previousActivationEvent = this.previousActivationEvent;\n        var isSameInteraction = previousActivationEvent && evt !== undefined && previousActivationEvent.type !== evt.type;\n        if (isSameInteraction) {\n            return;\n        }\n        activationState.isActivated = true;\n        activationState.isProgrammatic = evt === undefined;\n        activationState.activationEvent = evt;\n        activationState.wasActivatedByPointer = activationState.isProgrammatic ? false : evt !== undefined && (evt.type === \'mousedown\' || evt.type === \'touchstart\' || evt.type === \'pointerdown\');\n        var hasActivatedChild = evt !== undefined &&\n            activatedTargets.length > 0 &&\n            activatedTargets.some(function (target) { return _this.adapter.containsEventTarget(target); });\n        if (hasActivatedChild) {\n            // Immediately reset activation state, while preserving logic that prevents touch follow-on events\n            this.resetActivationState();\n            return;\n        }\n        if (evt !== undefined) {\n            activatedTargets.push(evt.target);\n            this.registerDeactivationHandlers(evt);\n        }\n        activationState.wasElementMadeActive = this.checkElementMadeActive(evt);\n        if (activationState.wasElementMadeActive) {\n            this.animateActivation();\n        }\n        requestAnimationFrame(function () {\n            // Reset array on next frame after the current event has had a chance to bubble to prevent ancestor ripples\n            activatedTargets = [];\n            if (!activationState.wasElementMadeActive\n                && evt !== undefined\n                && (evt.key === \' \' || evt.keyCode === 32)) {\n                // If space was pressed, try again within an rAF call to detect :active, because different UAs report\n                // active states inconsistently when they\'re called within event handling code:\n                // - https://bugs.chromium.org/p/chromium/issues/detail?id=635971\n                // - https://bugzilla.mozilla.org/show_bug.cgi?id=1293741\n                // We try first outside rAF to support Edge, which does not exhibit this problem, but will crash if a CSS\n                // variable is set within a rAF callback for a submit button interaction (#2241).\n                activationState.wasElementMadeActive = _this.checkElementMadeActive(evt);\n                if (activationState.wasElementMadeActive) {\n                    _this.animateActivation();\n                }\n            }\n            if (!activationState.wasElementMadeActive) {\n                // Reset activation state immediately if element was not made active.\n                _this.activationState = _this.defaultActivationState();\n            }\n        });\n    };\n    MDCRippleFoundation.prototype.checkElementMadeActive = function (evt) {\n        return (evt !== undefined && evt.type === \'keydown\') ?\n            this.adapter.isSurfaceActive() :\n            true;\n    };\n    MDCRippleFoundation.prototype.animateActivation = function () {\n        var _this = this;\n        var _a = MDCRippleFoundation.strings, VAR_FG_TRANSLATE_START = _a.VAR_FG_TRANSLATE_START, VAR_FG_TRANSLATE_END = _a.VAR_FG_TRANSLATE_END;\n        var _b = MDCRippleFoundation.cssClasses, FG_DEACTIVATION = _b.FG_DEACTIVATION, FG_ACTIVATION = _b.FG_ACTIVATION;\n        var DEACTIVATION_TIMEOUT_MS = MDCRippleFoundation.numbers.DEACTIVATION_TIMEOUT_MS;\n        this.layoutInternal();\n        var translateStart = \'\';\n        var translateEnd = \'\';\n        if (!this.adapter.isUnbounded()) {\n            var _c = this.getFgTranslationCoordinates(), startPoint = _c.startPoint, endPoint = _c.endPoint;\n            translateStart = startPoint.x + "px, " + startPoint.y + "px";\n            translateEnd = endPoint.x + "px, " + endPoint.y + "px";\n        }\n        this.adapter.updateCssVariable(VAR_FG_TRANSLATE_START, translateStart);\n        this.adapter.updateCssVariable(VAR_FG_TRANSLATE_END, translateEnd);\n        // Cancel any ongoing activation/deactivation animations\n        clearTimeout(this.activationTimer);\n        clearTimeout(this.fgDeactivationRemovalTimer);\n        this.rmBoundedActivationClasses();\n        this.adapter.removeClass(FG_DEACTIVATION);\n        // Force layout in order to re-trigger the animation.\n        this.adapter.computeBoundingRect();\n        this.adapter.addClass(FG_ACTIVATION);\n        this.activationTimer = setTimeout(function () {\n            _this.activationTimerCallback();\n        }, DEACTIVATION_TIMEOUT_MS);\n    };\n    MDCRippleFoundation.prototype.getFgTranslationCoordinates = function () {\n        var _a = this.activationState, activationEvent = _a.activationEvent, wasActivatedByPointer = _a.wasActivatedByPointer;\n        var startPoint;\n        if (wasActivatedByPointer) {\n            startPoint = getNormalizedEventCoords(activationEvent, this.adapter.getWindowPageOffset(), this.adapter.computeBoundingRect());\n        }\n        else {\n            startPoint = {\n                x: this.frame.width / 2,\n                y: this.frame.height / 2,\n            };\n        }\n        // Center the element around the start point.\n        startPoint = {\n            x: startPoint.x - (this.initialSize / 2),\n            y: startPoint.y - (this.initialSize / 2),\n        };\n        var endPoint = {\n            x: (this.frame.width / 2) - (this.initialSize / 2),\n            y: (this.frame.height / 2) - (this.initialSize / 2),\n        };\n        return { startPoint: startPoint, endPoint: endPoint };\n    };\n    MDCRippleFoundation.prototype.runDeactivationUXLogicIfReady = function () {\n        var _this = this;\n        // This method is called both when a pointing device is released, and when the activation animation ends.\n        // The deactivation animation should only run after both of those occur.\n        var FG_DEACTIVATION = MDCRippleFoundation.cssClasses.FG_DEACTIVATION;\n        var _a = this.activationState, hasDeactivationUXRun = _a.hasDeactivationUXRun, isActivated = _a.isActivated;\n        var activationHasEnded = hasDeactivationUXRun || !isActivated;\n        if (activationHasEnded && this.activationAnimationHasEnded) {\n            this.rmBoundedActivationClasses();\n            this.adapter.addClass(FG_DEACTIVATION);\n            this.fgDeactivationRemovalTimer = setTimeout(function () {\n                _this.adapter.removeClass(FG_DEACTIVATION);\n            }, ripple_constants_numbers.FG_DEACTIVATION_MS);\n        }\n    };\n    MDCRippleFoundation.prototype.rmBoundedActivationClasses = function () {\n        var FG_ACTIVATION = MDCRippleFoundation.cssClasses.FG_ACTIVATION;\n        this.adapter.removeClass(FG_ACTIVATION);\n        this.activationAnimationHasEnded = false;\n        this.adapter.computeBoundingRect();\n    };\n    MDCRippleFoundation.prototype.resetActivationState = function () {\n        var _this = this;\n        this.previousActivationEvent = this.activationState.activationEvent;\n        this.activationState = this.defaultActivationState();\n        // Touch devices may fire additional events for the same interaction within a short time.\n        // Store the previous event until it\'s safe to assume that subsequent events are for new interactions.\n        setTimeout(function () { return _this.previousActivationEvent = undefined; }, MDCRippleFoundation.numbers.TAP_DELAY_MS);\n    };\n    MDCRippleFoundation.prototype.deactivateImpl = function () {\n        var _this = this;\n        var activationState = this.activationState;\n        // This can happen in scenarios such as when you have a keyup event that blurs the element.\n        if (!activationState.isActivated) {\n            return;\n        }\n        var state = __assign({}, activationState);\n        if (activationState.isProgrammatic) {\n            requestAnimationFrame(function () {\n                _this.animateDeactivation(state);\n            });\n            this.resetActivationState();\n        }\n        else {\n            this.deregisterDeactivationHandlers();\n            requestAnimationFrame(function () {\n                _this.activationState.hasDeactivationUXRun = true;\n                _this.animateDeactivation(state);\n                _this.resetActivationState();\n            });\n        }\n    };\n    MDCRippleFoundation.prototype.animateDeactivation = function (_a) {\n        var wasActivatedByPointer = _a.wasActivatedByPointer, wasElementMadeActive = _a.wasElementMadeActive;\n        if (wasActivatedByPointer || wasElementMadeActive) {\n            this.runDeactivationUXLogicIfReady();\n        }\n    };\n    MDCRippleFoundation.prototype.layoutInternal = function () {\n        var _this = this;\n        this.frame = this.adapter.computeBoundingRect();\n        var maxDim = Math.max(this.frame.height, this.frame.width);\n        // Surface diameter is treated differently for unbounded vs. bounded ripples.\n        // Unbounded ripple diameter is calculated smaller since the surface is expected to already be padded appropriately\n        // to extend the hitbox, and the ripple is expected to meet the edges of the padded hitbox (which is typically\n        // square). Bounded ripples, on the other hand, are fully expected to expand beyond the surface\'s longest diameter\n        // (calculated based on the diagonal plus a constant padding), and are clipped at the surface\'s border via\n        // `overflow: hidden`.\n        var getBoundedRadius = function () {\n            var hypotenuse = Math.sqrt(Math.pow(_this.frame.width, 2) + Math.pow(_this.frame.height, 2));\n            return hypotenuse + MDCRippleFoundation.numbers.PADDING;\n        };\n        this.maxRadius = this.adapter.isUnbounded() ? maxDim : getBoundedRadius();\n        // Ripple is sized as a fraction of the largest dimension of the surface, then scales up using a CSS scale transform\n        var initialSize = Math.floor(maxDim * MDCRippleFoundation.numbers.INITIAL_ORIGIN_SCALE);\n        // Unbounded ripple size should always be even number to equally center align.\n        if (this.adapter.isUnbounded() && initialSize % 2 !== 0) {\n            this.initialSize = initialSize - 1;\n        }\n        else {\n            this.initialSize = initialSize;\n        }\n        this.fgScale = "" + this.maxRadius / this.initialSize;\n        this.updateLayoutCssVars();\n    };\n    MDCRippleFoundation.prototype.updateLayoutCssVars = function () {\n        var _a = MDCRippleFoundation.strings, VAR_FG_SIZE = _a.VAR_FG_SIZE, VAR_LEFT = _a.VAR_LEFT, VAR_TOP = _a.VAR_TOP, VAR_FG_SCALE = _a.VAR_FG_SCALE;\n        this.adapter.updateCssVariable(VAR_FG_SIZE, this.initialSize + "px");\n        this.adapter.updateCssVariable(VAR_FG_SCALE, this.fgScale);\n        if (this.adapter.isUnbounded()) {\n            this.unboundedCoords = {\n                left: Math.round((this.frame.width / 2) - (this.initialSize / 2)),\n                top: Math.round((this.frame.height / 2) - (this.initialSize / 2)),\n            };\n            this.adapter.updateCssVariable(VAR_LEFT, this.unboundedCoords.left + "px");\n            this.adapter.updateCssVariable(VAR_TOP, this.unboundedCoords.top + "px");\n        }\n    };\n    return MDCRippleFoundation;\n}(MDCFoundation));\n\n// tslint:disable-next-line:no-default-export Needed for backward compatibility with MDC Web v0.44.0 and earlier.\n/* harmony default export */ const ripple_foundation = ((/* unused pure expression or super */ null && (MDCRippleFoundation)));\n//# sourceMappingURL=foundation.js.map\n;// CONCATENATED MODULE: ./node_modules/@material/ripple/component.js\n/**\n * @license\n * Copyright 2016 Google Inc.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the "Software"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\n\n\n\n\n\n\nvar MDCRipple = /** @class */ (function (_super) {\n    __extends(MDCRipple, _super);\n    function MDCRipple() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.disabled = false;\n        return _this;\n    }\n    MDCRipple.attachTo = function (root, opts) {\n        if (opts === void 0) { opts = {\n            isUnbounded: undefined\n        }; }\n        var ripple = new MDCRipple(root);\n        // Only override unbounded behavior if option is explicitly specified\n        if (opts.isUnbounded !== undefined) {\n            ripple.unbounded = opts.isUnbounded;\n        }\n        return ripple;\n    };\n    MDCRipple.createAdapter = function (instance) {\n        return {\n            addClass: function (className) { return instance.root.classList.add(className); },\n            browserSupportsCssVars: function () { return supportsCssVariables(window); },\n            computeBoundingRect: function () { return instance.root.getBoundingClientRect(); },\n            containsEventTarget: function (target) { return instance.root.contains(target); },\n            deregisterDocumentInteractionHandler: function (evtType, handler) {\n                return document.documentElement.removeEventListener(evtType, handler, applyPassive());\n            },\n            deregisterInteractionHandler: function (evtType, handler) {\n                return instance.root\n                    .removeEventListener(evtType, handler, applyPassive());\n            },\n            deregisterResizeHandler: function (handler) {\n                return window.removeEventListener(\'resize\', handler);\n            },\n            getWindowPageOffset: function () {\n                return ({ x: window.pageXOffset, y: window.pageYOffset });\n            },\n            isSurfaceActive: function () { return matches(instance.root, \':active\'); },\n            isSurfaceDisabled: function () { return Boolean(instance.disabled); },\n            isUnbounded: function () { return Boolean(instance.unbounded); },\n            registerDocumentInteractionHandler: function (evtType, handler) {\n                return document.documentElement.addEventListener(evtType, handler, applyPassive());\n            },\n            registerInteractionHandler: function (evtType, handler) {\n                return instance.root\n                    .addEventListener(evtType, handler, applyPassive());\n            },\n            registerResizeHandler: function (handler) {\n                return window.addEventListener(\'resize\', handler);\n            },\n            removeClass: function (className) { return instance.root.classList.remove(className); },\n            updateCssVariable: function (varName, value) {\n                return instance.root.style.setProperty(varName, value);\n            },\n        };\n    };\n    Object.defineProperty(MDCRipple.prototype, "unbounded", {\n        get: function () {\n            return Boolean(this.isUnbounded);\n        },\n        set: function (unbounded) {\n            this.isUnbounded = Boolean(unbounded);\n            this.setUnbounded();\n        },\n        enumerable: false,\n        configurable: true\n    });\n    MDCRipple.prototype.activate = function () {\n        this.foundation.activate();\n    };\n    MDCRipple.prototype.deactivate = function () {\n        this.foundation.deactivate();\n    };\n    MDCRipple.prototype.layout = function () {\n        this.foundation.layout();\n    };\n    MDCRipple.prototype.getDefaultFoundation = function () {\n        return new MDCRippleFoundation(MDCRipple.createAdapter(this));\n    };\n    MDCRipple.prototype.initialSyncWithDOM = function () {\n        var root = this.root;\n        this.isUnbounded = \'mdcRippleIsUnbounded\' in root.dataset;\n    };\n    /**\n     * Closure Compiler throws an access control error when directly accessing a\n     * protected or private property inside a getter/setter, like unbounded above.\n     * By accessing the protected property inside a method, we solve that problem.\n     * That\'s why this function exists.\n     */\n    MDCRipple.prototype.setUnbounded = function () {\n        this.foundation.setUnbounded(Boolean(this.isUnbounded));\n    };\n    return MDCRipple;\n}(MDCComponent));\n\n//# sourceMappingURL=component.js.map\n;// CONCATENATED MODULE: ./src/ripple/Ripple.jsx\nvar Ripple_excluded = ["unbounded", "disabled", "className", "element"];\n\nfunction Ripple_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction Ripple_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { Ripple_ownKeys(Object(source), true).forEach(function (key) { Ripple_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { Ripple_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction Ripple_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction Ripple_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = Ripple_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction Ripple_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\nfunction Ripple(_ref) {\n  var _ref$unbounded = _ref.unbounded,\n      unbounded = _ref$unbounded === void 0 ? false : _ref$unbounded,\n      _ref$disabled = _ref.disabled,\n      disabled = _ref$disabled === void 0 ? false : _ref$disabled,\n      className = _ref.className,\n      _ref$element = _ref.element,\n      Element = _ref$element === void 0 ? \'span\' : _ref$element,\n      props = Ripple_objectWithoutProperties(_ref, Ripple_excluded);\n\n  var rootRef = (0,react.useRef)();\n  var rippleRef = (0,react.useRef)();\n  (0,react.useEffect)(function () {\n    if (disabled) return;\n\n    if (!rippleRef.current) {\n      rippleRef.current = new MDCRipple(rootRef.current.parentNode);\n    }\n\n    rippleRef.current.unbounded = unbounded;\n    return function () {\n      return rippleRef.current.destroy();\n    };\n  }, [disabled, unbounded]);\n  var classNames = classnames_default()(className);\n  return /*#__PURE__*/(0,jsx_runtime.jsx)(Element, Ripple_objectSpread({\n    ref: rootRef,\n    className: classNames\n  }, props));\n}\nRipple.displayName = \'MDCRipple\';\n;// CONCATENATED MODULE: ./src/ripple/constants.js\nvar src_ripple_constants_cssClasses = {\n  ROOT: \'mdc-ripple-upgraded\',\n  UNBOUNDED: \'mdc-ripple-upgraded--unbounded\',\n  BG_FOCUSED: \'mdc-ripple-upgraded--background-focused\',\n  FG_ACTIVATION: \'mdc-ripple-upgraded--foreground-activation\',\n  FG_DEACTIVATION: \'mdc-ripple-upgraded--foreground-deactivation\',\n  SURFACE: \'mdc-ripple-surface\',\n  SURFACE_PRIMARY: \'mdc-ripple-surface--primary\',\n  SURFACE_ACCENT: \'mdc-ripple-surface--accent\'\n};\nvar ripple_constants_strings = {\n  VAR_FG_SCALE: \'--mdc-ripple-fg-scale\',\n  VAR_FG_SIZE: \'--mdc-ripple-fg-size\',\n  VAR_FG_TRANSLATE_END: \'--mdc-ripple-fg-translate-end\',\n  VAR_FG_TRANSLATE_START: \'--mdc-ripple-fg-translate-start\',\n  VAR_LEFT: \'--mdc-ripple-left\',\n  VAR_TOP: \'--mdc-ripple-top\'\n};\nvar src_ripple_constants_numbers = {\n  DEACTIVATION_TIMEOUT_MS: 225,\n  // Corresponds to $mdc-ripple-translate-duration (i.e. activation animation duration)\n  FG_DEACTIVATION_MS: 150,\n  // Corresponds to $mdc-ripple-fade-out-duration (i.e. deactivation animation duration)\n  INITIAL_ORIGIN_SCALE: 0.6,\n  PADDING: 10,\n  TAP_DELAY_MS: 300 // Delay between touch and simulated mouse events on touch devices\n\n};\n;// CONCATENATED MODULE: ./src/ripple/hooks.js\n\n\nfunction useRipple(rootRef) {\n  var unbounded = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  var rippleRef = (0,react.useRef)();\n  (0,react.useEffect)(function () {\n    if (!rippleRef.current) {\n      rippleRef.current = new MDCRipple(rootRef.current);\n    }\n\n    rippleRef.current.unbounded = unbounded;\n    return function () {\n      return rippleRef.current.destroy();\n    };\n  }, [rootRef, unbounded]);\n  return rippleRef.current;\n}\n;// CONCATENATED MODULE: ./src/ripple/RippleSurface.jsx\nvar RippleSurface_excluded = ["primary", "accent", "className", "element"];\n\nfunction RippleSurface_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction RippleSurface_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { RippleSurface_ownKeys(Object(source), true).forEach(function (key) { RippleSurface_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { RippleSurface_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction RippleSurface_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction RippleSurface_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = RippleSurface_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction RippleSurface_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\n\n\nvar RippleSurface = /*#__PURE__*/(0,react.forwardRef)(function (_ref, ref) {\n  var _classnames;\n\n  var primary = _ref.primary,\n      accent = _ref.accent,\n      className = _ref.className,\n      _ref$element = _ref.element,\n      Element = _ref$element === void 0 ? \'div\' : _ref$element,\n      props = RippleSurface_objectWithoutProperties(_ref, RippleSurface_excluded);\n\n  var rootRef = (0,react.useRef)();\n  (0,react.useImperativeHandle)(ref, function () {\n    return rootRef.current;\n  });\n  useRipple(rootRef);\n  var classNames = classnames_default()(src_ripple_constants_cssClasses.SURFACE, (_classnames = {}, RippleSurface_defineProperty(_classnames, src_ripple_constants_cssClasses.SURFACE_PRIMARY, primary), RippleSurface_defineProperty(_classnames, src_ripple_constants_cssClasses.SURFACE_ACCENT, accent), _classnames), className);\n  return /*#__PURE__*/(0,jsx_runtime.jsx)(Element, RippleSurface_objectSpread({\n    ref: rootRef,\n    className: classNames\n  }, props));\n});\nRippleSurface.displayName = \'MDCRippleSurface\';\nRippleSurface.propTypes = {\n  primary: (prop_types_default()).bool,\n  accent: (prop_types_default()).bool\n};\n/* harmony default export */ const ripple_RippleSurface = (RippleSurface);\n;// CONCATENATED MODULE: ./src/ripple/index.js\n\n\n;// CONCATENATED MODULE: ./src/segmented-button/constants.js\nvar segmented_button_constants_cssClasses = {\n  ROOT: \'mdc-segmented-button\',\n  SINGLE_SELECT: \'mdc-segmented-button--single-select\',\n  SEGMENT: \'mdc-segmented-button__segment\',\n  SEGMENT_SELECTED: \'mdc-segmented-button__segment--selected\',\n  ICON: \'mdc-segmented-button__icon\',\n  LABEL: \'mdc-segmented-button__label\',\n  RIPPLE: \'mdc-segmented-button__ripple\',\n  TOUCH: \'mdc-segmented-button--touch\',\n  TOUCH_ELEMENT: \'mdc-segmented-button__touch\'\n};\n;// CONCATENATED MODULE: ./src/segmented-button/SegmentedButtonSegment.jsx\nvar SegmentedButtonSegment_excluded = ["label", "icon", "selected", "touch", "ripple", "element", "component", "className", "children"];\n\nfunction SegmentedButtonSegment_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction SegmentedButtonSegment_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { SegmentedButtonSegment_ownKeys(Object(source), true).forEach(function (key) { SegmentedButtonSegment_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { SegmentedButtonSegment_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction SegmentedButtonSegment_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction SegmentedButtonSegment_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = SegmentedButtonSegment_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction SegmentedButtonSegment_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\n\n\n\n\nvar SegmentedButtonSegment = /*#__PURE__*/(0,react.forwardRef)(function (_ref, ref) {\n  var _classnames;\n\n  var label = _ref.label,\n      icon = _ref.icon,\n      selected = _ref.selected,\n      touch = _ref.touch,\n      ripple = _ref.ripple,\n      _ref$element = _ref.element,\n      element = _ref$element === void 0 ? \'button\' : _ref$element,\n      _ref$component = _ref.component,\n      Element = _ref$component === void 0 ? element : _ref$component,\n      className = _ref.className,\n      _ref$children = _ref.children,\n      children = _ref$children === void 0 ? label : _ref$children,\n      props = SegmentedButtonSegment_objectWithoutProperties(_ref, SegmentedButtonSegment_excluded);\n\n  var classNames = classnames_default()(segmented_button_constants_cssClasses.SEGMENT, (_classnames = {}, SegmentedButtonSegment_defineProperty(_classnames, segmented_button_constants_cssClasses.SEGMENT_SELECTED, selected), SegmentedButtonSegment_defineProperty(_classnames, segmented_button_constants_cssClasses.TOUCH, touch), _classnames), className);\n  return /*#__PURE__*/(0,jsx_runtime.jsxs)(Element, SegmentedButtonSegment_objectSpread(SegmentedButtonSegment_objectSpread({\n    ref: ref,\n    className: classNames\n  }, props), {}, {\n    children: [ripple && /*#__PURE__*/(0,jsx_runtime.jsx)("div", {\n      className: segmented_button_constants_cssClasses.RIPPLE\n    }), touch && /*#__PURE__*/(0,jsx_runtime.jsx)("div", {\n      className: segmented_button_constants_cssClasses.TOUCH_ELEMENT\n    }), icon && /*#__PURE__*/(0,jsx_runtime.jsx)(Clone, {\n      component: icon,\n      fallback: icon_Icon,\n      className: segmented_button_constants_cssClasses.ICON\n    }), children && /*#__PURE__*/(0,jsx_runtime.jsx)("span", {\n      className: segmented_button_constants_cssClasses.LABEL,\n      children: children\n    })]\n  }));\n});\nSegmentedButtonSegment.displayName = \'MDCSegmentedButtonSegment\';\nSegmentedButtonSegment.propTypes = {\n  label: (prop_types_default()).string,\n  icon: (prop_types_default()).node,\n  selected: (prop_types_default()).bool,\n  ripple: (prop_types_default()).bool\n};\n/* harmony default export */ const segmented_button_SegmentedButtonSegment = (SegmentedButtonSegment);\n;// CONCATENATED MODULE: ./src/segmented-button/SegmentedButton.jsx\nvar SegmentedButton_excluded = ["value", "segments", "singleSelect", "ripple", "touch", "onChange", "element", "component", "className", "children"];\n\nfunction SegmentedButton_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction SegmentedButton_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { SegmentedButton_ownKeys(Object(source), true).forEach(function (key) { SegmentedButton_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { SegmentedButton_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction SegmentedButton_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction SegmentedButton_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = SegmentedButton_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction SegmentedButton_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\n\n\n\n\nvar SegmentedButton = /*#__PURE__*/(0,react.forwardRef)(function (_ref, ref) {\n  var value = _ref.value,\n      segments = _ref.segments,\n      _ref$singleSelect = _ref.singleSelect,\n      singleSelect = _ref$singleSelect === void 0 ? !isUndefined(value) && !isArray(value) : _ref$singleSelect,\n      _ref$ripple = _ref.ripple,\n      ripple = _ref$ripple === void 0 ? true : _ref$ripple,\n      _ref$touch = _ref.touch,\n      touch = _ref$touch === void 0 ? false : _ref$touch,\n      _ref$onChange = _ref.onChange,\n      onChange = _ref$onChange === void 0 ? Function.prototype : _ref$onChange,\n      _ref$element = _ref.element,\n      element = _ref$element === void 0 ? \'div\' : _ref$element,\n      _ref$component = _ref.component,\n      Element = _ref$component === void 0 ? element : _ref$component,\n      className = _ref.className,\n      _ref$children = _ref.children,\n      children = _ref$children === void 0 ? segments === null || segments === void 0 ? void 0 : segments.map(function (segment) {\n    return (0,react.createElement)(segmented_button_SegmentedButtonSegment, segment);\n  }) : _ref$children,\n      props = SegmentedButton_objectWithoutProperties(_ref, SegmentedButton_excluded);\n\n  var handleClick = (0,react.useCallback)(function (event) {\n    var segmentValue = event.currentTarget.value;\n    var newValue = singleSelect ? segmentValue : value.includes(segmentValue) ? value.filter(function (v) {\n      return v !== segmentValue;\n    }) : value.concat(segmentValue);\n    onChange(newValue);\n  }, [value, singleSelect, onChange]);\n  var classNames = classnames_default()(segmented_button_constants_cssClasses.ROOT, SegmentedButton_defineProperty({}, segmented_button_constants_cssClasses.SINGLE_SELECT, singleSelect), className);\n  return /*#__PURE__*/(0,jsx_runtime.jsx)(Element, SegmentedButton_objectSpread(SegmentedButton_objectSpread({\n    ref: ref,\n    className: classNames,\n    role: singleSelect ? \'radiogroup\' : \'group\'\n  }, props), {}, {\n    children: isUndefined(value) ? children : react.Children.map(children, function (segment) {\n      var _clone;\n\n      var ariaProp = singleSelect ? \'aria-checked\' : \'aria-pressed\';\n      var selected = singleSelect ? value === segment.props.value : value.includes(segment.props.value);\n      return (0,react.cloneElement)(segment, (_clone = {\n        ripple: ripple,\n        touch: touch,\n        selected: selected,\n        role: singleSelect ? \'radio\' : undefined\n      }, SegmentedButton_defineProperty(_clone, ariaProp, selected), SegmentedButton_defineProperty(_clone, "onClickCapture", handleClick), _clone));\n    })\n  }));\n});\nSegmentedButton.displayName = \'MDCSegmentedButton\';\nSegmentedButton.propTypes = {\n  value: (prop_types_default()).any,\n  segments: prop_types_default().arrayOf(prop_types_default().oneOfType([(prop_types_default()).object, (prop_types_default()).element])),\n  singleSelect: (prop_types_default()).bool,\n  ripple: (prop_types_default()).bool,\n  touch: (prop_types_default()).bool,\n  onChange: (prop_types_default()).func\n};\n/* harmony default export */ const segmented_button_SegmentedButton = (SegmentedButton);\n;// CONCATENATED MODULE: ./src/segmented-button/index.js\n\n\nsegmented_button_SegmentedButton.Segment = segmented_button_SegmentedButtonSegment;\n\n;// CONCATENATED MODULE: ./src/side-sheet/constants.js\nvar side_sheet_constants_numbers = {\n  ANIMATION_ENTER_TIME_MS: 250,\n  ANIMATION_EXIT_TIME_MS: 200\n};\nvar side_sheet_constants_cssClasses = {\n  ROOT: \'mdc-side-sheet\',\n  DISMISSIBLE: \'mdc-side-sheet--dismissible\',\n  MODAL: \'mdc-side-sheet--modal\',\n  OPEN: \'mdc-side-sheet--open\',\n  ANIMATE: \'mdc-side-sheet--animate\',\n  OPENING: \'mdc-side-sheet--opening\',\n  CLOSING: \'mdc-side-sheet--closing\',\n  CONTENT: \'mdc-side-sheet__content\',\n  HEADER: \'mdc-side-sheet__header\',\n  TITLE: \'mdc-side-sheet__title\',\n  CLOSE_BUTTON: \'mdc-side-sheet__close-button\',\n  APP_CONTENT: \'mdc-side-sheet-app-content\',\n  SCRIM: \'mdc-side-sheet-scrim\'\n};\n;// CONCATENATED MODULE: ./src/side-sheet/SideSheetHeader.jsx\nvar SideSheetHeader_excluded = ["title", "closeIcon", "onClose", "element"];\n\nfunction SideSheetHeader_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction SideSheetHeader_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { SideSheetHeader_ownKeys(Object(source), true).forEach(function (key) { SideSheetHeader_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { SideSheetHeader_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction SideSheetHeader_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction SideSheetHeader_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = SideSheetHeader_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction SideSheetHeader_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\n\n\nvar SideSheetHeader = /*#__PURE__*/(0,react.forwardRef)(function (_ref, ref) {\n  var title = _ref.title,\n      closeIcon = _ref.closeIcon,\n      onClose = _ref.onClose,\n      _ref$element = _ref.element,\n      Element = _ref$element === void 0 ? \'header\' : _ref$element,\n      props = SideSheetHeader_objectWithoutProperties(_ref, SideSheetHeader_excluded);\n\n  return /*#__PURE__*/(0,jsx_runtime.jsxs)(Element, SideSheetHeader_objectSpread(SideSheetHeader_objectSpread({\n    ref: ref,\n    className: side_sheet_constants_cssClasses.HEADER\n  }, props), {}, {\n    children: [title && /*#__PURE__*/(0,jsx_runtime.jsx)(Clone, {\n      component: title,\n      fallback: "h3",\n      className: side_sheet_constants_cssClasses.TITLE\n    }), closeIcon && /*#__PURE__*/(0,jsx_runtime.jsx)(Clone, {\n      component: closeIcon,\n      fallback: icon_button_IconButton,\n      className: side_sheet_constants_cssClasses.CLOSE_BUTTON,\n      onClick: onClose\n    })]\n  }));\n});\nSideSheetHeader.displayName = \'MDCSideSheetHeader\';\n/* harmony default export */ const side_sheet_SideSheetHeader = (SideSheetHeader);\n;// CONCATENATED MODULE: ./src/side-sheet/SideSheetContent.jsx\nvar SideSheetContent_excluded = ["element"];\n\nfunction SideSheetContent_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction SideSheetContent_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { SideSheetContent_ownKeys(Object(source), true).forEach(function (key) { SideSheetContent_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { SideSheetContent_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction SideSheetContent_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction SideSheetContent_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = SideSheetContent_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction SideSheetContent_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\nvar SideSheetContent = /*#__PURE__*/(0,react.forwardRef)(function (_ref, ref) {\n  var _ref$element = _ref.element,\n      Element = _ref$element === void 0 ? \'div\' : _ref$element,\n      props = SideSheetContent_objectWithoutProperties(_ref, SideSheetContent_excluded);\n\n  return /*#__PURE__*/(0,jsx_runtime.jsx)(Element, SideSheetContent_objectSpread({\n    ref: ref,\n    className: side_sheet_constants_cssClasses.CONTENT\n  }, props));\n});\nSideSheetContent.displayName = \'MDCSideSheetContent\';\n/* harmony default export */ const side_sheet_SideSheetContent = (SideSheetContent);\n;// CONCATENATED MODULE: ./src/side-sheet/SideSheet.jsx\nvar SideSheet_excluded = ["title", "content", "open", "appear", "dismissible", "modal", "closeIcon", "appContentSelector", "onClose", "element", "component", "className", "children"];\n\nfunction SideSheet_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction SideSheet_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { SideSheet_ownKeys(Object(source), true).forEach(function (key) { SideSheet_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { SideSheet_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction SideSheet_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction SideSheet_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = SideSheet_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction SideSheet_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\n\n\n\n\n\n\nvar SideSheet = /*#__PURE__*/(0,react.forwardRef)(function (_ref, ref) {\n  var _classnames;\n\n  var title = _ref.title,\n      content = _ref.content,\n      _ref$open = _ref.open,\n      open = _ref$open === void 0 ? false : _ref$open,\n      _ref$appear = _ref.appear,\n      appear = _ref$appear === void 0 ? false : _ref$appear,\n      _ref$dismissible = _ref.dismissible,\n      dismissible = _ref$dismissible === void 0 ? false : _ref$dismissible,\n      _ref$modal = _ref.modal,\n      modal = _ref$modal === void 0 ? false : _ref$modal,\n      _ref$closeIcon = _ref.closeIcon,\n      closeIcon = _ref$closeIcon === void 0 ? dismissible && \'close\' : _ref$closeIcon,\n      appContentSelector = _ref.appContentSelector,\n      _ref$onClose = _ref.onClose,\n      onClose = _ref$onClose === void 0 ? Function.prototype : _ref$onClose,\n      _ref$element = _ref.element,\n      element = _ref$element === void 0 ? \'aside\' : _ref$element,\n      _ref$component = _ref.component,\n      Element = _ref$component === void 0 ? element : _ref$component,\n      className = _ref.className,\n      children = _ref.children,\n      props = SideSheet_objectWithoutProperties(_ref, SideSheet_excluded);\n\n  var rootRef = (0,react.useRef)();\n  (0,react.useImperativeHandle)(ref, function () {\n    return rootRef.current;\n  });\n  (0,react.useEffect)(function () {\n    if (!dismissible) return;\n    var appContentElement = appContentSelector ? document.querySelector(appContentSelector) : rootRef.current.nextElementSibling;\n    appContentElement === null || appContentElement === void 0 ? void 0 : appContentElement.classList.add(side_sheet_constants_cssClasses.APP_CONTENT);\n    return function () {\n      appContentElement === null || appContentElement === void 0 ? void 0 : appContentElement.classList.remove(side_sheet_constants_cssClasses.APP_CONTENT);\n    };\n  }, [dismissible, appContentSelector]);\n  (0,react.useEffect)(function () {\n    if (!modal) return;\n\n    function handleDocumentKeyDown(event) {\n      if (event.key && event.key === \'Escape\' || event.keyCode === 27) {\n        onClose();\n      }\n    }\n\n    document.addEventListener(\'keydown\', handleDocumentKeyDown);\n    return function () {\n      return document.removeEventListener(\'keydown\', handleDocumentKeyDown);\n    };\n  }, [modal, onClose]);\n  var classNames = classnames_default()(side_sheet_constants_cssClasses.ROOT, (_classnames = {}, SideSheet_defineProperty(_classnames, side_sheet_constants_cssClasses.DISMISSIBLE, dismissible), SideSheet_defineProperty(_classnames, side_sheet_constants_cssClasses.MODAL, modal), _classnames), className);\n  return /*#__PURE__*/(0,jsx_runtime.jsx)(Layer, {\n    "in": open,\n    appear: appear,\n    modal: modal,\n    fixed: modal,\n    timeout: {\n      enter: side_sheet_constants_numbers.ANIMATION_ENTER_TIME_MS,\n      exit: side_sheet_constants_numbers.ANIMATION_EXIT_TIME_MS\n    },\n    classNames: {\n      appear: side_sheet_constants_cssClasses.OPEN,\n      enter: "".concat(side_sheet_constants_cssClasses.OPEN, " ").concat(side_sheet_constants_cssClasses.ANIMATE),\n      enterActive: "".concat(side_sheet_constants_cssClasses.OPEN, " ").concat(side_sheet_constants_cssClasses.OPENING),\n      enterDone: side_sheet_constants_cssClasses.OPEN,\n      exit: "".concat(side_sheet_constants_cssClasses.OPEN, " ").concat(side_sheet_constants_cssClasses.CLOSING),\n      exitActive: side_sheet_constants_cssClasses.CLOSING\n    },\n    mountOnEnter: modal,\n    unmountOnExit: modal,\n    children: /*#__PURE__*/(0,jsx_runtime.jsxs)(jsx_runtime.Fragment, {\n      children: [/*#__PURE__*/(0,jsx_runtime.jsxs)(Element, SideSheet_objectSpread(SideSheet_objectSpread({\n        ref: rootRef,\n        className: classNames\n      }, props), {}, {\n        children: [(title || dismissible) && /*#__PURE__*/(0,jsx_runtime.jsx)(side_sheet_SideSheetHeader, {\n          title: title,\n          onClose: onClose,\n          closeIcon: closeIcon\n        }), content && /*#__PURE__*/(0,jsx_runtime.jsx)(side_sheet_SideSheetContent, {\n          children: content\n        }), children]\n      })), modal && /*#__PURE__*/(0,jsx_runtime.jsx)("div", {\n        className: side_sheet_constants_cssClasses.SCRIM,\n        onClick: onClose\n      })]\n    })\n  });\n});\nSideSheet.displayName = \'MDCSideSheet\';\nSideSheet.propTypes = {\n  title: (prop_types_default()).string,\n  content: (prop_types_default()).node,\n  closeIcon: (prop_types_default()).node,\n  open: (prop_types_default()).bool,\n  appear: (prop_types_default()).bool,\n  dismissible: (prop_types_default()).bool,\n  modal: (prop_types_default()).bool,\n  appContentSelector: (prop_types_default()).string,\n  onClose: (prop_types_default()).func\n};\n/* harmony default export */ const side_sheet_SideSheet = (SideSheet);\n;// CONCATENATED MODULE: ./src/side-sheet/SideSheetAppContent.jsx\nvar SideSheetAppContent_excluded = ["element", "className"];\n\nfunction SideSheetAppContent_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction SideSheetAppContent_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { SideSheetAppContent_ownKeys(Object(source), true).forEach(function (key) { SideSheetAppContent_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { SideSheetAppContent_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction SideSheetAppContent_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction SideSheetAppContent_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = SideSheetAppContent_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction SideSheetAppContent_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\nvar SideSheetAppContent = /*#__PURE__*/(0,react.forwardRef)(function (_ref, ref) {\n  var _ref$element = _ref.element,\n      Element = _ref$element === void 0 ? \'div\' : _ref$element,\n      className = _ref.className,\n      props = SideSheetAppContent_objectWithoutProperties(_ref, SideSheetAppContent_excluded);\n\n  var classNames = classnames_default()(side_sheet_constants_cssClasses.APP_CONTENT, className);\n  return /*#__PURE__*/(0,jsx_runtime.jsx)(Element, SideSheetAppContent_objectSpread({\n    ref: ref,\n    className: classNames\n  }, props));\n});\nSideSheetAppContent.displayName = \'MDCSideSheetAppContent\';\n/* harmony default export */ const side_sheet_SideSheetAppContent = (SideSheetAppContent);\n;// CONCATENATED MODULE: ./src/side-sheet/index.js\n\n\n\n\nside_sheet_SideSheet.Header = side_sheet_SideSheetHeader;\nside_sheet_SideSheet.Content = side_sheet_SideSheetContent;\nside_sheet_SideSheet.AppContent = side_sheet_SideSheetAppContent;\n\n;// CONCATENATED MODULE: ./src/slider/constants.js\nvar slider_constants_numbers = {\n  THUMB_WIDTH: 48\n};\nvar slider_constants_cssClasses = {\n  ROOT: \'mdc-slider\',\n  RANGE: \'mdc-slider--range\',\n  DISCRETE: \'mdc-slider--discrete\',\n  DISABLED: \'mdc-slider--disabled\',\n  INPUT: \'mdc-slider__input\',\n  TRACK: \'mdc-slider__track\',\n  TRACK_INACTIVE: \'mdc-slider__track--inactive\',\n  TRACK_ACTIVE: \'mdc-slider__track--active\',\n  TRACK_ACTIVE_FILL: \'mdc-slider__track--active_fill\',\n  TICK_MARKS: \'mdc-slider__tick-marks\',\n  TICK_MARK_ACTIVE: \'mdc-slider__tick-mark--active\',\n  TICK_MARK_INACTIVE: \'mdc-slider__tick-mark--inactive\',\n  THUMB: \'mdc-slider__thumb\',\n  THUMB_TOP: \'mdc-slider__thumb--top\',\n  THUMB_FOCUSED: \'mdc-slider__thumb--focused\',\n  THUMB_WITH_INDICATOR: \'mdc-slider__thumb--with-indicator\',\n  THUMB_KNOB: \'mdc-slider__thumb-knob\',\n  VALUE_INDICATOR_CONTAINER: \'mdc-slider__value-indicator-container\',\n  VALUE_INDICATOR: \'mdc-slider__value-indicator\',\n  VALUE_INDICATOR_TEXT: \'mdc-slider__value-indicator-text\'\n};\n;// CONCATENATED MODULE: ./src/slider/utils.js\n\nfunction getValueForEventKey(eventKey, value, min, max, step) {\n  var delta = Number(step) || (max - min) / 100;\n\n  switch (eventKey) {\n    case Key.ARROW_LEFT:\n    case Key.ARROW_DOWN:\n      return value - delta;\n\n    case Key.ARROW_RIGHT:\n    case Key.ARROW_UP:\n      return value + delta;\n\n    case Key.HOME:\n      return min;\n\n    case Key.END:\n      return max;\n\n    default:\n      return NaN;\n  }\n}\n;// CONCATENATED MODULE: ./src/slider/Input.jsx\nvar Input_excluded = ["value"];\n\nfunction Input_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction Input_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { Input_ownKeys(Object(source), true).forEach(function (key) { Input_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { Input_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction Input_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction Input_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = Input_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction Input_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\nvar Input = /*#__PURE__*/(0,react.forwardRef)(function (_ref, ref) {\n  var value = _ref.value,\n      props = Input_objectWithoutProperties(_ref, Input_excluded);\n\n  return /*#__PURE__*/(0,jsx_runtime.jsx)("input", Input_objectSpread({\n    ref: ref,\n    className: slider_constants_cssClasses.INPUT,\n    type: "range",\n    value: Math.round(value),\n    onChange: Function.prototype\n  }, props));\n});\nInput.displayName = \'MDCSliderInput\';\n/* harmony default export */ const slider_Input = (Input);\n;// CONCATENATED MODULE: ./src/slider/TickMarks.jsx\nfunction TickMarks_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n\n\n\n\nvar TickMarks = function TickMarks(_ref) {\n  var value = _ref.value,\n      max = _ref.max,\n      _ref$step = _ref.step,\n      step = _ref$step === void 0 ? 1 : _ref$step;\n  return /*#__PURE__*/(0,jsx_runtime.jsx)("div", {\n    className: slider_constants_cssClasses.TICK_MARKS,\n    children: Array.from(new Array(max / step + 1)).map(function (_, i) {\n      return i * step;\n    }).map(function (tickValue, index) {\n      var _classnames;\n\n      return /*#__PURE__*/(0,jsx_runtime.jsx)("div", {\n        className: classnames_default()((_classnames = {}, TickMarks_defineProperty(_classnames, slider_constants_cssClasses.TICK_MARK_ACTIVE, tickValue <= value), TickMarks_defineProperty(_classnames, slider_constants_cssClasses.TICK_MARK_INACTIVE, tickValue > value), _classnames))\n      }, index);\n    })\n  });\n};\n\nTickMarks.displayName = \'MDCSliderTickMarks\';\n/* harmony default export */ const slider_TickMarks = (TickMarks);\n;// CONCATENATED MODULE: ./src/slider/Track.jsx\n\n\n\n\n\nvar Track = /*#__PURE__*/(0,react.forwardRef)(function (_ref, ref) {\n  var value = _ref.value,\n      min = _ref.min,\n      max = _ref.max,\n      step = _ref.step,\n      discrete = _ref.discrete,\n      tickMarks = _ref.tickMarks;\n  var style = {\n    transform: "scaleX(".concat((value - min) / (max - min), ")")\n  };\n  return /*#__PURE__*/(0,jsx_runtime.jsxs)("div", {\n    ref: ref,\n    className: slider_constants_cssClasses.TRACK,\n    children: [/*#__PURE__*/(0,jsx_runtime.jsx)("div", {\n      className: slider_constants_cssClasses.TRACK_INACTIVE\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)("div", {\n      className: slider_constants_cssClasses.TRACK_ACTIVE,\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)("div", {\n        className: slider_constants_cssClasses.TRACK_ACTIVE_FILL,\n        style: style\n      })\n    }), discrete && tickMarks && /*#__PURE__*/(0,jsx_runtime.jsx)(slider_TickMarks, {\n      value: value,\n      max: max,\n      step: step\n    })]\n  });\n});\nTrack.displayName = \'MDCSliderTrack\';\n/* harmony default export */ const slider_Track = (Track);\n;// CONCATENATED MODULE: ./src/slider/Thumb.jsx\nvar Thumb_excluded = ["value", "min", "max", "discrete", "disabled", "onStartInteraction", "onEndInteraction"];\n\nfunction Thumb_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction Thumb_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { Thumb_ownKeys(Object(source), true).forEach(function (key) { Thumb_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { Thumb_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction Thumb_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction Thumb_slicedToArray(arr, i) { return Thumb_arrayWithHoles(arr) || Thumb_iterableToArrayLimit(arr, i) || Thumb_unsupportedIterableToArray(arr, i) || Thumb_nonIterableRest(); }\n\nfunction Thumb_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction Thumb_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return Thumb_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return Thumb_arrayLikeToArray(o, minLen); }\n\nfunction Thumb_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction Thumb_iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction Thumb_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction Thumb_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = Thumb_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction Thumb_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\n\nvar Thumb = /*#__PURE__*/(0,react.forwardRef)(function (_ref, ref) {\n  var _classnames;\n\n  var value = _ref.value,\n      min = _ref.min,\n      max = _ref.max,\n      discrete = _ref.discrete,\n      disabled = _ref.disabled,\n      onStartInteraction = _ref.onStartInteraction,\n      onEndInteraction = _ref.onEndInteraction,\n      props = Thumb_objectWithoutProperties(_ref, Thumb_excluded);\n\n  var _useState = (0,react.useState)(false),\n      _useState2 = Thumb_slicedToArray(_useState, 2),\n      focused = _useState2[0],\n      setFocused = _useState2[1];\n\n  var handleFocus = (0,react.useCallback)(function () {\n    setFocused(true);\n  }, []);\n  var handleBlur = (0,react.useCallback)(function () {\n    setFocused(false);\n  }, []);\n  var classNames = classnames_default()(slider_constants_cssClasses.THUMB, (_classnames = {}, Thumb_defineProperty(_classnames, slider_constants_cssClasses.THUMB_FOCUSED, focused), Thumb_defineProperty(_classnames, slider_constants_cssClasses.THUMB_WITH_INDICATOR, discrete && focused), _classnames));\n  var style = {\n    left: "calc(".concat((value - min) / (max - min) * 100, "% - ").concat(slider_constants_numbers.THUMB_WIDTH * 0.5, "px)")\n  };\n  return /*#__PURE__*/(0,jsx_runtime.jsxs)("div", Thumb_objectSpread(Thumb_objectSpread({\n    ref: ref,\n    className: classNames,\n    role: "slider",\n    tabIndex: disabled ? \'-1\' : \'0\',\n    "aria-valuemin": "0",\n    "aria-valuemax": "100",\n    "aria-valuenow": "50",\n    "aria-disabled": disabled || undefined,\n    style: style,\n    onFocus: handleFocus,\n    onBlur: handleBlur,\n    onMouseDown: onStartInteraction,\n    onMouseUp: onEndInteraction,\n    onTouchStart: onStartInteraction,\n    onTouchEnd: onEndInteraction\n  }, props), {}, {\n    children: [discrete && /*#__PURE__*/(0,jsx_runtime.jsx)("div", {\n      className: slider_constants_cssClasses.VALUE_INDICATOR_CONTAINER,\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)("div", {\n        className: slider_constants_cssClasses.VALUE_INDICATOR,\n        children: /*#__PURE__*/(0,jsx_runtime.jsx)("span", {\n          className: slider_constants_cssClasses.VALUE_INDICATOR_TEXT,\n          children: value\n        })\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)("div", {\n      className: slider_constants_cssClasses.THUMB_KNOB\n    })]\n  }));\n});\nThumb.displayName = \'MDCSliderThumb\';\n/* harmony default export */ const slider_Thumb = (Thumb);\n;// CONCATENATED MODULE: ./src/slider/Slider.jsx\nvar Slider_excluded = ["name", "value", "min", "max", "step", "discrete", "disabled", "tickMarks", "onChange", "className"];\n\nfunction Slider_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction Slider_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { Slider_ownKeys(Object(source), true).forEach(function (key) { Slider_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { Slider_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction Slider_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction Slider_slicedToArray(arr, i) { return Slider_arrayWithHoles(arr) || Slider_iterableToArrayLimit(arr, i) || Slider_unsupportedIterableToArray(arr, i) || Slider_nonIterableRest(); }\n\nfunction Slider_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction Slider_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return Slider_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return Slider_arrayLikeToArray(o, minLen); }\n\nfunction Slider_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction Slider_iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction Slider_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction Slider_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = Slider_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction Slider_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\n\n\n\n\n\n\n\n\nvar Slider = /*#__PURE__*/(0,react.forwardRef)(function (_ref, ref) {\n  var _classnames;\n\n  var name = _ref.name,\n      _ref$value = _ref.value,\n      value = _ref$value === void 0 ? 0 : _ref$value,\n      _ref$min = _ref.min,\n      min = _ref$min === void 0 ? 0 : _ref$min,\n      _ref$max = _ref.max,\n      max = _ref$max === void 0 ? 100 : _ref$max,\n      step = _ref.step,\n      _ref$discrete = _ref.discrete,\n      discrete = _ref$discrete === void 0 ? false : _ref$discrete,\n      _ref$disabled = _ref.disabled,\n      disabled = _ref$disabled === void 0 ? false : _ref$disabled,\n      _ref$tickMarks = _ref.tickMarks,\n      tickMarks = _ref$tickMarks === void 0 ? false : _ref$tickMarks,\n      _ref$onChange = _ref.onChange,\n      onChange = _ref$onChange === void 0 ? Function.prototype : _ref$onChange,\n      className = _ref.className,\n      props = Slider_objectWithoutProperties(_ref, Slider_excluded);\n\n  var inputRef = (0,react.useRef)();\n  var trackRef = (0,react.useRef)();\n\n  var _useState = (0,react.useState)(false),\n      _useState2 = Slider_slicedToArray(_useState, 2),\n      active = _useState2[0],\n      setActive = _useState2[1];\n\n  useUpdated(function () {\n    if (disabled) return;\n\n    if (active) {\n      document.body.addEventListener(\'mousemove\', handleMove);\n      document.body.addEventListener(\'touchmove\', handleMove);\n      document.body.addEventListener(\'mouseup\', handleUp);\n      document.body.addEventListener(\'touchend\', handleUp);\n    } else {\n      document.body.removeEventListener(\'mousemove\', handleMove);\n      document.body.removeEventListener(\'touchmove\', handleMove);\n      document.body.removeEventListener(\'mouseup\', handleUp);\n      document.body.removeEventListener(\'touchend\', handleUp);\n    }\n\n    return function () {\n      document.body.removeEventListener(\'mousemove\', handleMove);\n      document.body.removeEventListener(\'touchmove\', handleMove);\n      document.body.removeEventListener(\'mouseup\', handleUp);\n      document.body.removeEventListener(\'touchend\', handleUp);\n    };\n  }, [active]);\n  var updateValue = (0,react.useCallback)(function (newValue) {\n    if (newValue < min) {\n      newValue = Number(min);\n    } else if (newValue > max) {\n      newValue = Number(max);\n    }\n\n    if (step) {\n      newValue = Math.round(newValue / step) * step;\n    }\n\n    onChange(newValue);\n  }, [min, max, step, onChange]);\n  var handleMove = (0,react.useCallback)(function (event) {\n    var trackClientRect = trackRef.current.getBoundingClientRect();\n    var pageX = getPageX(event);\n    var offsetX = pageX - trackClientRect.left;\n    var percent = offsetX / trackClientRect.width;\n    var value = Number(min) + percent * (max - min);\n    updateValue(value);\n  }, [min, max, updateValue]);\n  var handleKeyDown = (0,react.useCallback)(function (event) {\n    event.preventDefault();\n    var value = Number(inputRef.current.value);\n    var eventKey = getEventKey(event);\n    var newValue = getValueForEventKey(eventKey, value, min, max, step);\n    if (isNaN(newValue)) return;\n    updateValue(newValue);\n  }, [min, max, step, updateValue]);\n  var handleRootInteraction = (0,react.useCallback)(function (event) {\n    handleMove(event);\n  }, [handleMove]);\n  var handleUp = (0,react.useCallback)(function () {\n    setActive(false);\n  }, []);\n  var handleThumbStartInteraction = (0,react.useCallback)(function () {\n    setActive(true);\n  }, []);\n  var handleThumbEndInteraction = (0,react.useCallback)(function () {\n    setActive(false);\n  }, []);\n  var classNames = classnames_default()(slider_constants_cssClasses.ROOT, (_classnames = {}, Slider_defineProperty(_classnames, slider_constants_cssClasses.DISCRETE, discrete), Slider_defineProperty(_classnames, slider_constants_cssClasses.DISABLED, disabled), _classnames), className);\n  return /*#__PURE__*/(0,jsx_runtime.jsxs)("div", Slider_objectSpread(Slider_objectSpread({\n    ref: ref,\n    className: classNames,\n    onMouseDown: handleRootInteraction,\n    onTouchStart: handleRootInteraction\n  }, props), {}, {\n    children: [/*#__PURE__*/(0,jsx_runtime.jsx)(slider_Input, {\n      ref: inputRef,\n      name: name,\n      value: value,\n      min: min,\n      max: max,\n      step: step,\n      disabled: disabled\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(slider_Track, {\n      ref: trackRef,\n      value: value,\n      min: min,\n      max: max,\n      step: step,\n      discrete: discrete,\n      tickMarks: tickMarks\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(slider_Thumb, {\n      value: value,\n      min: min,\n      max: max,\n      discrete: discrete,\n      onStartInteraction: handleThumbStartInteraction,\n      onEndInteraction: handleThumbEndInteraction,\n      onKeyDown: handleKeyDown\n    })]\n  }));\n});\nSlider.displayName = \'MDCSlider\';\nSlider.propTypes = {\n  value: prop_types_default().oneOfType([(prop_types_default()).number, (prop_types_default()).string]),\n  min: prop_types_default().oneOfType([(prop_types_default()).number, (prop_types_default()).string]),\n  max: prop_types_default().oneOfType([(prop_types_default()).number, (prop_types_default()).string]),\n  step: prop_types_default().oneOfType([(prop_types_default()).number, (prop_types_default()).string]),\n  discrete: (prop_types_default()).bool,\n  disabled: (prop_types_default()).bool,\n  tickMarks: (prop_types_default()).bool,\n  onChange: (prop_types_default()).func\n};\n/* harmony default export */ const slider_Slider = (Slider);\n;// CONCATENATED MODULE: ./src/slider/index.js\n\n;// CONCATENATED MODULE: ./src/snackbar/constants.js\nvar snackbar_constants_numbers = {\n  DEFAULT_AUTO_DISMISS_TIMEOUT_MS: 5000,\n  ANIMATION_OPEN_TIME_MS: 150,\n  ANIMATION_CLOSE_TIME_MS: 75\n};\nvar snackbar_constants_cssClasses = {\n  ROOT: \'mdc-snackbar\',\n  LEADING: \'mdc-snackbar--leading\',\n  STACKED: \'mdc-snackbar--stacked\',\n  OPENING: \'mdc-snackbar--opening\',\n  OPEN: \'mdc-snackbar--open\',\n  CLOSING: \'mdc-snackbar--closing\',\n  SURFACE: \'mdc-snackbar__surface\',\n  LABEL: \'mdc-snackbar__label\',\n  ACTIONS: \'mdc-snackbar__actions\',\n  ACTION: \'mdc-snackbar__action\',\n  DISMISS: \'mdc-snackbar__dismiss\'\n};\n;// CONCATENATED MODULE: ./src/snackbar/Snackbar.jsx\nvar Snackbar_excluded = ["label", "action", "dismissIcon", "open", "appear", "leading", "stacked", "dismissible", "timeout", "closeOnEscape", "onClose", "element", "className", "children"];\n\nfunction Snackbar_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction Snackbar_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { Snackbar_ownKeys(Object(source), true).forEach(function (key) { Snackbar_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { Snackbar_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction Snackbar_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction Snackbar_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = Snackbar_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction Snackbar_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\n\n\n\n\n\n\nvar Snackbar = /*#__PURE__*/(0,react.forwardRef)(function (_ref, ref) {\n  var _classnames;\n\n  var label = _ref.label,\n      action = _ref.action,\n      _ref$dismissIcon = _ref.dismissIcon,\n      dismissIcon = _ref$dismissIcon === void 0 ? \'close\' : _ref$dismissIcon,\n      _ref$open = _ref.open,\n      open = _ref$open === void 0 ? false : _ref$open,\n      _ref$appear = _ref.appear,\n      appear = _ref$appear === void 0 ? false : _ref$appear,\n      _ref$leading = _ref.leading,\n      leading = _ref$leading === void 0 ? false : _ref$leading,\n      _ref$stacked = _ref.stacked,\n      stacked = _ref$stacked === void 0 ? false : _ref$stacked,\n      _ref$dismissible = _ref.dismissible,\n      dismissible = _ref$dismissible === void 0 ? true : _ref$dismissible,\n      _ref$timeout = _ref.timeout,\n      timeout = _ref$timeout === void 0 ? snackbar_constants_numbers.DEFAULT_AUTO_DISMISS_TIMEOUT_MS : _ref$timeout,\n      _ref$closeOnEscape = _ref.closeOnEscape,\n      closeOnEscape = _ref$closeOnEscape === void 0 ? true : _ref$closeOnEscape,\n      _ref$onClose = _ref.onClose,\n      onClose = _ref$onClose === void 0 ? Function.prototype : _ref$onClose,\n      _ref$element = _ref.element,\n      Element = _ref$element === void 0 ? \'div\' : _ref$element,\n      className = _ref.className,\n      _ref$children = _ref.children,\n      children = _ref$children === void 0 ? label : _ref$children,\n      props = Snackbar_objectWithoutProperties(_ref, Snackbar_excluded);\n\n  var timeoutRef = (0,react.useRef)();\n  useUpdated(function () {\n    if (open) {\n      timeoutRef.current = setTimeout(function () {\n        timeoutRef.current = null;\n        onClose();\n      }, timeout);\n    } else {\n      if (timeoutRef.current) {\n        clearTimeout(timeoutRef.current);\n        timeoutRef.current = null;\n      }\n    }\n\n    return function () {\n      return clearTimeout(timeoutRef.current);\n    };\n  }, [open]);\n  var handleKeyDown = (0,react.useCallback)(function (event) {\n    if (closeOnEscape && event.key === \'Escape\' || event.keyCode === 27) {\n      onClose();\n    }\n  }, [closeOnEscape, onClose]);\n  var classNames = classnames_default()(snackbar_constants_cssClasses.ROOT, (_classnames = {}, Snackbar_defineProperty(_classnames, snackbar_constants_cssClasses.LEADING, leading), Snackbar_defineProperty(_classnames, snackbar_constants_cssClasses.STACKED, stacked), _classnames), className);\n  return /*#__PURE__*/(0,jsx_runtime.jsx)(Layer, {\n    modal: true,\n    "in": open,\n    appear: appear,\n    timeout: {\n      enter: snackbar_constants_numbers.ANIMATION_OPEN_TIME_MS,\n      exit: snackbar_constants_numbers.ANIMATION_CLOSE_TIME_MS\n    },\n    classNames: {\n      appear: snackbar_constants_cssClasses.OPENING,\n      appearActive: snackbar_constants_cssClasses.OPEN,\n      enter: snackbar_constants_cssClasses.OPENING,\n      enterActive: snackbar_constants_cssClasses.OPEN,\n      enterDone: snackbar_constants_cssClasses.OPEN,\n      exit: snackbar_constants_cssClasses.CLOSING\n    },\n    mountOnEnter: true,\n    unmountOnExit: true,\n    children: /*#__PURE__*/(0,jsx_runtime.jsx)(Element, Snackbar_objectSpread(Snackbar_objectSpread({\n      ref: ref,\n      className: classNames,\n      onKeyDown: handleKeyDown\n    }, props), {}, {\n      children: /*#__PURE__*/(0,jsx_runtime.jsxs)("div", {\n        className: snackbar_constants_cssClasses.SURFACE,\n        role: "status",\n        "aria-relevant": "additions",\n        children: [/*#__PURE__*/(0,jsx_runtime.jsx)("div", {\n          className: snackbar_constants_cssClasses.LABEL,\n          "aria-atomic": "false",\n          children: children\n        }), /*#__PURE__*/(0,jsx_runtime.jsxs)("div", {\n          className: snackbar_constants_cssClasses.ACTIONS,\n          "aria-atomic": "true",\n          children: [action && /*#__PURE__*/(0,jsx_runtime.jsx)(Clone, {\n            component: action,\n            className: snackbar_constants_cssClasses.ACTION\n          }), dismissible && /*#__PURE__*/(0,jsx_runtime.jsx)(Clone, {\n            component: dismissIcon,\n            fallback: icon_button_IconButton,\n            className: snackbar_constants_cssClasses.DISMISS,\n            onClick: onClose\n          })]\n        })]\n      })\n    }))\n  });\n});\nSnackbar.displayName = \'MDCSnackbar\';\nSnackbar.propTypes = {\n  label: (prop_types_default()).string,\n  action: (prop_types_default()).element,\n  dismissIcon: (prop_types_default()).node,\n  open: (prop_types_default()).bool,\n  appear: (prop_types_default()).bool,\n  leading: (prop_types_default()).bool,\n  stacked: (prop_types_default()).bool,\n  dismissible: (prop_types_default()).bool,\n  timeout: (prop_types_default()).number,\n  closeOnEscape: (prop_types_default()).bool,\n  onClose: (prop_types_default()).func\n};\n/* harmony default export */ const snackbar_Snackbar = (Snackbar);\n;// CONCATENATED MODULE: ./src/snackbar/index.js\n\n;// CONCATENATED MODULE: ./src/switch/constants.js\nvar switch_constants_cssClasses = {\n  ROOT: \'mdc-switch\',\n  SELECTED: \'mdc-switch--selected\',\n  UNSELECTED: \'mdc-switch--unselected\',\n  TRACK: \'mdc-switch__track\',\n  HANDLE_TRACK: \'mdc-switch__handle-track\',\n  HANDLE: \'mdc-switch__handle\',\n  SHADOW: \'mdc-switch__shadow\',\n  ELEVATION_OVERLAY: \'mdc-elevation-overlay\',\n  RIPPLE: \'mdc-switch__ripple\',\n  ICONS: \'mdc-switch__icons\',\n  ICON: \'mdc-switch__icon\',\n  ICON_ON: \'mdc-switch__icon--on\',\n  ICON_OFF: \'mdc-switch__icon--off\'\n};\n;// CONCATENATED MODULE: ./src/switch/Switch.jsx\nvar Switch_excluded = ["selected", "onChange", "className"];\n\nfunction Switch_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction Switch_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { Switch_ownKeys(Object(source), true).forEach(function (key) { Switch_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { Switch_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction Switch_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction Switch_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = Switch_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction Switch_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\n\n\nvar Switch_Switch = /*#__PURE__*/(0,react.forwardRef)(function (_ref, ref) {\n  var _classnames;\n\n  var _ref$selected = _ref.selected,\n      selected = _ref$selected === void 0 ? false : _ref$selected,\n      _ref$onChange = _ref.onChange,\n      onChange = _ref$onChange === void 0 ? Function.prototype : _ref$onChange,\n      className = _ref.className,\n      props = Switch_objectWithoutProperties(_ref, Switch_excluded);\n\n  var handleClick = (0,react.useCallback)(function (event) {\n    event.stopPropagation();\n    onChange(event, !selected, event.currentTarget);\n  }, [selected, onChange]);\n  var classNames = classnames_default()(switch_constants_cssClasses.ROOT, (_classnames = {}, Switch_defineProperty(_classnames, switch_constants_cssClasses.SELECTED, selected), Switch_defineProperty(_classnames, switch_constants_cssClasses.UNSELECTED, !selected), _classnames), className);\n  return /*#__PURE__*/(0,jsx_runtime.jsxs)("button", Switch_objectSpread(Switch_objectSpread({\n    ref: ref,\n    type: "button",\n    className: classNames,\n    role: "switch",\n    "aria-checked": selected,\n    onClick: handleClick\n  }, props), {}, {\n    children: [/*#__PURE__*/(0,jsx_runtime.jsx)("div", {\n      className: switch_constants_cssClasses.TRACK\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)("div", {\n      className: switch_constants_cssClasses.HANDLE_TRACK,\n      children: /*#__PURE__*/(0,jsx_runtime.jsxs)("div", {\n        className: switch_constants_cssClasses.HANDLE,\n        children: [/*#__PURE__*/(0,jsx_runtime.jsx)("div", {\n          className: switch_constants_cssClasses.SHADOW,\n          children: /*#__PURE__*/(0,jsx_runtime.jsx)("div", {\n            className: switch_constants_cssClasses.ELEVATION_OVERLAY\n          })\n        }), /*#__PURE__*/(0,jsx_runtime.jsx)("div", {\n          className: switch_constants_cssClasses.RIPPLE\n        }), /*#__PURE__*/(0,jsx_runtime.jsxs)("div", {\n          className: switch_constants_cssClasses.ICONS,\n          children: [/*#__PURE__*/(0,jsx_runtime.jsx)("svg", {\n            className: "".concat(switch_constants_cssClasses.ICON, " ").concat(switch_constants_cssClasses.ICON_ON),\n            viewBox: "0 0 24 24",\n            children: /*#__PURE__*/(0,jsx_runtime.jsx)("path", {\n              d: "M19.69,5.23L8.96,15.96l-4.23-4.23L2.96,13.5l6,6L21.46,7L19.69,5.23z"\n            })\n          }), /*#__PURE__*/(0,jsx_runtime.jsx)("svg", {\n            className: "".concat(switch_constants_cssClasses.ICON, " ").concat(switch_constants_cssClasses.ICON_OFF),\n            viewBox: "0 0 24 24",\n            children: /*#__PURE__*/(0,jsx_runtime.jsx)("path", {\n              d: "M20 13H4v-2h16v2z"\n            })\n          })]\n        })]\n      })\n    })]\n  }));\n});\nSwitch_Switch.displayName = \'MDCSwitch\';\nSwitch_Switch.propTypes = {\n  checked: (prop_types_default()).bool,\n  disabled: (prop_types_default()).bool,\n  onChange: (prop_types_default()).func\n};\n/* harmony default export */ const switch_Switch = (Switch_Switch);\n;// CONCATENATED MODULE: ./src/switch/index.js\n\n;// CONCATENATED MODULE: ./src/tabs/constants.js\nvar tabClassNames = {\n  ROOT: \'mdc-tab\',\n  ACTIVE: \'mdc-tab--active\',\n  STACKED: \'mdc-tab--stacked\',\n  MIN_WIDTH: \'mdc-tab--min-width\',\n  CONTENT: \'mdc-tab__content\',\n  ICON: \'mdc-tab__icon\',\n  LABEL: \'mdc-tab__text-label\',\n  RIPPLE: \'mdc-tab__ripple\'\n};\nvar barCssClasses = {\n  ROOT: \'mdc-tab-bar\'\n};\nvar scrollerCssClasses = {\n  ROOT: \'mdc-tab-scroller\',\n  ALIGN: \'mdc-tab-scroller--align\',\n  ANIMATING: \'mdc-tab-scroller--animating\',\n  SCROLL_AREA: \'mdc-tab-scroller__scroll-area\',\n  SCROLL_AREA_SCROLL: \'mdc-tab-scroller__scroll-area--scroll\',\n  SCROLL_CONTENT: \'mdc-tab-scroller__scroll-content\'\n};\nvar indicatorCssClasses = {\n  ROOT: \'mdc-tab-indicator\',\n  ACTIVE: \'mdc-tab-indicator--active\',\n  FADE: \'mdc-tab-indicator--fade\',\n  NO_TRANSITION: \'mdc-tab-indicator--no-transition\',\n  CONTENT: \'mdc-tab-indicator__content\',\n  CONTENT_ICON: \'mdc-tab-indicator__content--icon material-icons\',\n  CONTENT_UNDERLINE: \'mdc-tab-indicator__content--underline\'\n};\nvar Align = {\n  START: \'start\',\n  CENTER: \'center\',\n  END: \'end\'\n};\n;// CONCATENATED MODULE: ./src/tabs/context.js\n\n/* harmony default export */ const tabs_context = (/*#__PURE__*/(0,react.createContext)({}));\n;// CONCATENATED MODULE: ./src/tabs/TabIndicator.jsx\nvar TabIndicator_excluded = ["icon", "active", "fade", "underline"];\n\nfunction TabIndicator_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction TabIndicator_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { TabIndicator_ownKeys(Object(source), true).forEach(function (key) { TabIndicator_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { TabIndicator_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction TabIndicator_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction TabIndicator_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = TabIndicator_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction TabIndicator_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\n\n\n\nvar TabIndicator = /*#__PURE__*/(0,react.forwardRef)(function (_ref, ref) {\n  var _classnames, _classnames2;\n\n  var icon = _ref.icon,\n      _ref$active = _ref.active,\n      active = _ref$active === void 0 ? false : _ref$active,\n      _ref$fade = _ref.fade,\n      fade = _ref$fade === void 0 ? false : _ref$fade,\n      _ref$underline = _ref.underline,\n      underline = _ref$underline === void 0 ? !icon : _ref$underline,\n      props = TabIndicator_objectWithoutProperties(_ref, TabIndicator_excluded);\n\n  var _useContext = (0,react.useContext)(tabs_context),\n      previousTab = _useContext.previousTab;\n\n  var rootRef = (0,react.useRef)();\n  var contentRef = (0,react.useRef)();\n  (0,react.useImperativeHandle)(ref, function () {\n    return rootRef.current;\n  });\n  useUpdatedSync(function () {\n    if (fade || !active || !previousTab) return;\n    var activeIndicator = rootRef.current;\n    var previousIndicator = previousTab.querySelector(\'.mdc-tab-indicator\');\n    var previousIndicatorClientRect = previousIndicator.getBoundingClientRect();\n    var activeIndicatorClientRect = activeIndicator.getBoundingClientRect();\n    var xPosition = previousIndicatorClientRect.left - activeIndicatorClientRect.left;\n    var widthDelta = previousIndicatorClientRect.width / activeIndicatorClientRect.width;\n    rootRef.current.classList.add(indicatorCssClasses.NO_TRANSITION);\n    contentRef.current.style.transform = "translateX(".concat(xPosition, "px) scaleX(").concat(widthDelta, ")"); // Force repaint before updating classes and transform to ensure the transform properly takes effect\n\n    contentRef.current.getBoundingClientRect();\n    rootRef.current.classList.remove(indicatorCssClasses.NO_TRANSITION);\n    contentRef.current.style.transform = \'\';\n  }, [fade, active]);\n  var rootClassNames = classnames_default()(indicatorCssClasses.ROOT, (_classnames = {}, TabIndicator_defineProperty(_classnames, indicatorCssClasses.ACTIVE, active), TabIndicator_defineProperty(_classnames, indicatorCssClasses.FADE, fade), _classnames));\n  var contentClassNames = classnames_default()(indicatorCssClasses.CONTENT, (_classnames2 = {}, TabIndicator_defineProperty(_classnames2, indicatorCssClasses.CONTENT_ICON, icon), TabIndicator_defineProperty(_classnames2, indicatorCssClasses.CONTENT_UNDERLINE, underline), _classnames2));\n  return /*#__PURE__*/(0,jsx_runtime.jsx)("span", TabIndicator_objectSpread(TabIndicator_objectSpread({\n    ref: rootRef,\n    className: rootClassNames\n  }, props), {}, {\n    children: /*#__PURE__*/(0,jsx_runtime.jsx)("span", {\n      ref: contentRef,\n      className: contentClassNames,\n      children: icon\n    })\n  }));\n});\nTabIndicator.displayName = \'MDCTabIndicator\';\nTabIndicator.propTypes = {\n  icon: (prop_types_default()).node,\n  active: (prop_types_default()).bool,\n  fade: (prop_types_default()).bool,\n  underline: (prop_types_default()).bool\n};\n/* harmony default export */ const tabs_TabIndicator = (TabIndicator);\n;// CONCATENATED MODULE: ./src/tabs/Tab.jsx\nvar Tab_excluded = ["value", "icon", "label", "indicatorIcon", "active", "stacked", "minWidth", "minWidthIndicator", "fade", "underline", "onClick", "element", "component", "className", "children"];\n\nfunction Tab_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction Tab_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { Tab_ownKeys(Object(source), true).forEach(function (key) { Tab_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { Tab_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction Tab_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction Tab_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = Tab_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction Tab_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\n\n\n\n\n\nvar Tab = /*#__PURE__*/(0,react.forwardRef)(function (_ref, ref) {\n  var _classnames;\n\n  var value = _ref.value,\n      icon = _ref.icon,\n      label = _ref.label,\n      indicatorIcon = _ref.indicatorIcon,\n      _ref$active = _ref.active,\n      active = _ref$active === void 0 ? false : _ref$active,\n      _ref$stacked = _ref.stacked,\n      stacked = _ref$stacked === void 0 ? false : _ref$stacked,\n      _ref$minWidth = _ref.minWidth,\n      minWidth = _ref$minWidth === void 0 ? false : _ref$minWidth,\n      _ref$minWidthIndicato = _ref.minWidthIndicator,\n      minWidthIndicator = _ref$minWidthIndicato === void 0 ? false : _ref$minWidthIndicato,\n      _ref$fade = _ref.fade,\n      fade = _ref$fade === void 0 ? false : _ref$fade,\n      _ref$underline = _ref.underline,\n      underline = _ref$underline === void 0 ? !indicatorIcon : _ref$underline,\n      _ref$onClick = _ref.onClick,\n      onClick = _ref$onClick === void 0 ? Function.prototype : _ref$onClick,\n      _ref$element = _ref.element,\n      element = _ref$element === void 0 ? \'button\' : _ref$element,\n      _ref$component = _ref.component,\n      Element = _ref$component === void 0 ? element : _ref$component,\n      className = _ref.className,\n      _ref$children = _ref.children,\n      children = _ref$children === void 0 ? label : _ref$children,\n      props = Tab_objectWithoutProperties(_ref, Tab_excluded);\n\n  var rootRef = (0,react.useRef)();\n  (0,react.useImperativeHandle)(ref, function () {\n    return rootRef.current;\n  });\n  var handleClick = (0,react.useCallback)(function () {\n    onClick(rootRef.current, value);\n  }, [value, onClick]);\n  var classNames = classnames_default()(tabClassNames.ROOT, (_classnames = {}, Tab_defineProperty(_classnames, tabClassNames.ACTIVE, active), Tab_defineProperty(_classnames, tabClassNames.STACKED, stacked), Tab_defineProperty(_classnames, tabClassNames.MIN_WIDTH, minWidth), _classnames), className);\n  return /*#__PURE__*/(0,jsx_runtime.jsxs)(Element, Tab_objectSpread(Tab_objectSpread({\n    ref: rootRef,\n    className: classNames,\n    "data-value": value,\n    role: "tab",\n    "aria-selected": active ? \'true\' : \'false\',\n    tabIndex: active ? 0 : -1,\n    onClick: handleClick\n  }, props), {}, {\n    children: [/*#__PURE__*/(0,jsx_runtime.jsxs)("div", {\n      className: tabClassNames.CONTENT,\n      children: [icon && /*#__PURE__*/(0,jsx_runtime.jsx)(Clone, {\n        component: icon,\n        fallback: icon_Icon,\n        className: tabClassNames.ICON\n      }), children && /*#__PURE__*/(0,jsx_runtime.jsx)("span", {\n        className: tabClassNames.LABEL,\n        children: children\n      }), minWidthIndicator && /*#__PURE__*/(0,jsx_runtime.jsx)(tabs_TabIndicator, {\n        icon: indicatorIcon,\n        active: active,\n        fade: fade,\n        underline: underline\n      })]\n    }), !minWidthIndicator && /*#__PURE__*/(0,jsx_runtime.jsx)(tabs_TabIndicator, {\n      icon: indicatorIcon,\n      active: active,\n      fade: fade,\n      underline: underline\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)("div", {\n      className: tabClassNames.RIPPLE\n    })]\n  }));\n});\nTab.displayName = \'MDCTab\';\nTab.propTypes = {\n  value: (prop_types_default()).any,\n  icon: (prop_types_default()).node,\n  label: (prop_types_default()).node,\n  indicatorIcon: (prop_types_default()).node,\n  active: (prop_types_default()).bool,\n  stacked: (prop_types_default()).bool,\n  minWidth: (prop_types_default()).bool,\n  minWidthIndicator: (prop_types_default()).bool,\n  fade: (prop_types_default()).bool,\n  underline: (prop_types_default()).bool,\n  onActivate: (prop_types_default()).func\n};\n/* harmony default export */ const tabs_Tab = (Tab);\n;// CONCATENATED MODULE: ./src/tabs/TabScroller.jsx\nvar TabScroller_excluded = ["align", "activeTab", "children"];\n\nfunction TabScroller_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction TabScroller_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { TabScroller_ownKeys(Object(source), true).forEach(function (key) { TabScroller_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { TabScroller_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction TabScroller_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction TabScroller_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = TabScroller_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction TabScroller_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\n\nvar TabScroller = /*#__PURE__*/(0,react.forwardRef)(function (_ref, ref) {\n  var align = _ref.align,\n      activeTab = _ref.activeTab,\n      children = _ref.children,\n      props = TabScroller_objectWithoutProperties(_ref, TabScroller_excluded);\n\n  var scrollAreaRef = (0,react.useRef)();\n  var scrollContentRef = (0,react.useRef)();\n  useMounted(function () {\n    var scrollAreaWidth = scrollAreaRef.current.offsetWidth;\n    var scrollContentWidth = scrollContentRef.current.offsetWidth;\n\n    if (scrollContentWidth > scrollAreaWidth) {\n      scrollAreaRef.current.classList.add(scrollerCssClasses.SCROLL_AREA_SCROLL);\n    }\n  });\n  useUpdated(function () {\n    if (!activeTab) return;\n    var scrollAreaWidth = scrollAreaRef.current.offsetWidth;\n    var tabWidth = activeTab.offsetWidth;\n    var tabHalfWidth = tabWidth * 0.5;\n    var offsetLeft = activeTab.offsetLeft - scrollAreaRef.current.scrollLeft;\n    var offsetLeftDelta = activeTab.offsetLeft - scrollAreaRef.current.scrollLeft;\n    var offsetRight = activeTab.offsetLeft + tabWidth - scrollAreaRef.current.scrollLeft;\n    var offsetRightDelta = scrollAreaWidth - offsetRight;\n\n    if (offsetRight > scrollAreaWidth || offsetRightDelta < tabHalfWidth) {\n      scrollAreaRef.current.scrollBy({\n        left: offsetRight > scrollAreaWidth ? Math.abs(offsetRightDelta) + tabHalfWidth : tabHalfWidth - offsetRightDelta,\n        behavior: \'smooth\'\n      });\n    } else if (offsetLeft < 0 || offsetLeftDelta < tabHalfWidth) {\n      scrollAreaRef.current.scrollBy({\n        left: offsetLeft < 0 ? offsetLeftDelta - tabHalfWidth : -(tabHalfWidth - offsetLeftDelta),\n        behavior: \'smooth\'\n      });\n    }\n  }, [activeTab]);\n  var classNames = classnames_default()(scrollerCssClasses.ROOT, TabScroller_defineProperty({}, "".concat(scrollerCssClasses.ALIGN, "-").concat(align), align));\n  return /*#__PURE__*/(0,jsx_runtime.jsx)("div", TabScroller_objectSpread(TabScroller_objectSpread({\n    ref: ref,\n    className: classNames\n  }, props), {}, {\n    children: /*#__PURE__*/(0,jsx_runtime.jsx)("div", {\n      ref: scrollAreaRef,\n      className: scrollerCssClasses.SCROLL_AREA,\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)("div", {\n        ref: scrollContentRef,\n        className: scrollerCssClasses.SCROLL_CONTENT,\n        children: children\n      })\n    })\n  }));\n});\nTabScroller.displayName = \'MDCTabScroller\';\n/* harmony default export */ const tabs_TabScroller = (TabScroller);\n;// CONCATENATED MODULE: ./src/tabs/TabBar.jsx\nvar TabBar_excluded = ["tabs", "value", "align", "indicatorIcon", "stacked", "minWidth", "minWidthIndicator", "fade", "iconIndicator", "underlineIndicator", "onChange", "element", "component", "className", "children"];\n\nfunction TabBar_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction TabBar_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { TabBar_ownKeys(Object(source), true).forEach(function (key) { TabBar_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { TabBar_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction TabBar_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction TabBar_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = TabBar_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction TabBar_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\n\n\n\n\n\n\nvar TabBar = /*#__PURE__*/(0,react.forwardRef)(function (_ref, ref) {\n  var tabs = _ref.tabs,\n      value = _ref.value,\n      align = _ref.align,\n      indicatorIcon = _ref.indicatorIcon,\n      _ref$stacked = _ref.stacked,\n      stacked = _ref$stacked === void 0 ? false : _ref$stacked,\n      _ref$minWidth = _ref.minWidth,\n      minWidth = _ref$minWidth === void 0 ? false : _ref$minWidth,\n      _ref$minWidthIndicato = _ref.minWidthIndicator,\n      minWidthIndicator = _ref$minWidthIndicato === void 0 ? false : _ref$minWidthIndicato,\n      _ref$fade = _ref.fade,\n      fade = _ref$fade === void 0 ? false : _ref$fade,\n      _ref$iconIndicator = _ref.iconIndicator,\n      iconIndicator = _ref$iconIndicator === void 0 ? Boolean(indicatorIcon) : _ref$iconIndicator,\n      _ref$underlineIndicat = _ref.underlineIndicator,\n      underlineIndicator = _ref$underlineIndicat === void 0 ? !iconIndicator : _ref$underlineIndicat,\n      _ref$onChange = _ref.onChange,\n      onChange = _ref$onChange === void 0 ? Function.prototype : _ref$onChange,\n      _ref$element = _ref.element,\n      element = _ref$element === void 0 ? \'div\' : _ref$element,\n      _ref$component = _ref.component,\n      Element = _ref$component === void 0 ? element : _ref$component,\n      className = _ref.className,\n      _ref$children = _ref.children,\n      children = _ref$children === void 0 ? tabs === null || tabs === void 0 ? void 0 : tabs.map(function (tab) {\n    return (0,react.createElement)(tabs_Tab, tab);\n  }) : _ref$children,\n      props = TabBar_objectWithoutProperties(_ref, TabBar_excluded);\n\n  var rootRef = (0,react.useRef)();\n  var activeTabRef = (0,react.useRef)();\n  var previousTabRef = (0,react.useRef)();\n  (0,react.useImperativeHandle)(ref, function () {\n    return rootRef.current;\n  });\n  (0,react.useEffect)(function () {\n    activeTabRef.current = rootRef.current.querySelector(".".concat(tabClassNames.ACTIVE));\n  }, []);\n  var handleTabClick = (0,react.useCallback)(function (element, value) {\n    previousTabRef.current = activeTabRef.current;\n    activeTabRef.current = element;\n    onChange(value);\n  }, [onChange]);\n  var classNames = classnames_default()(barCssClasses.ROOT, className);\n  return /*#__PURE__*/(0,jsx_runtime.jsx)(Element, TabBar_objectSpread(TabBar_objectSpread({\n    ref: rootRef,\n    className: classNames,\n    role: "tablist"\n  }, props), {}, {\n    children: !isUndefined(value) ? /*#__PURE__*/(0,jsx_runtime.jsx)(tabs_context.Provider, {\n      value: {\n        activeTab: activeTabRef.current,\n        previousTab: previousTabRef.current\n      },\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(tabs_TabScroller, {\n        align: align,\n        activeTab: activeTabRef.current,\n        children: react.Children.map(children, function (tab, index) {\n          var tabValue = isUndefined(tab.props.value) ? index : tab.props.value;\n          return (0,react.cloneElement)(tab, {\n            value: tabValue,\n            active: tabValue === value,\n            indicatorIcon: tab.props.indicatorIcon || indicatorIcon,\n            stacked: tab.props.stacked || stacked,\n            minWidth: tab.props.minWidth || minWidth,\n            minWidthIndicator: tab.props.minWidthIndicator || minWidthIndicator,\n            fade: fade,\n            underline: underlineIndicator,\n            onClick: handleTabClick\n          });\n        })\n      })\n    }) : children\n  }));\n});\nTabBar.displayName = \'MDCTabBar\';\nTabBar.propTypes = {\n  align: prop_types_default().oneOf(Object.values(Align)),\n  indicatorIcon: (prop_types_default()).node,\n  stacked: (prop_types_default()).bool,\n  minWidth: (prop_types_default()).bool,\n  fade: (prop_types_default()).bool,\n  iconIndicator: (prop_types_default()).bool,\n  underlineIndicator: (prop_types_default()).bool,\n  onChange: (prop_types_default()).func\n};\nTabBar.Align = Align;\n/* harmony default export */ const tabs_TabBar = (TabBar);\n;// CONCATENATED MODULE: ./src/tabs/index.js\n\n\n;// CONCATENATED MODULE: ./src/tooltip/constants.js\nvar tooltip_constants_numbers = {\n  BOUNDED_ANCHOR_GAP: 4,\n  UNBOUNDED_ANCHOR_GAP: 8,\n  MIN_VIEWPORT_TOOLTIP_THRESHOLD: 8,\n  ENTER_DURATION_MS: 150,\n  EXIT_DURATION_MS: 75,\n  HIDE_DELAY_MS: 600,\n  SHOW_DELAY_MS: 500,\n  MIN_HEIGHT: 24,\n  MAX_WIDTH: 200,\n  CARET_INDENTATION: 24,\n  ANIMATION_SCALE: 0.8\n};\nvar tooltip_constants_cssClasses = {\n  ROOT: \'mdc-tooltip\',\n  RICH: \'mdc-tooltip--rich\',\n  MULTILINE: \'mdc-tooltip--multiline\',\n  SHOWING: \'mdc-tooltip--showing\',\n  ACTIONS: \'mdc-tooltip--rich-actions\',\n  SHOWING_TRANSITION: \'mdc-tooltip--showing-transition\',\n  SHOWN: \'mdc-tooltip--shown\',\n  HIDE: \'mdc-tooltip--hide\',\n  HIDE_TRANSITION: \'mdc-tooltip--hide-transition\',\n  SURFACE: \'mdc-tooltip__surface\',\n  SURFACE_ANIMATION: \'mdc-tooltip__surface-animation\',\n  TITLE: \'mdc-tooltip__title\',\n  CONTENT: \'mdc-tooltip__content\',\n  CONTENT_LINK: \'mdc-tooltip__content-link\',\n  ACTION: \'mdc-tooltip__action\',\n  CARET_TOP: \'mdc-tooltip__caret-surface-top\',\n  CARET_BOTTOM: \'mdc-tooltip__caret-surface-bottom\'\n};\n;// CONCATENATED MODULE: ./src/tooltip/Tooltip.jsx\nfunction Tooltip_slicedToArray(arr, i) { return Tooltip_arrayWithHoles(arr) || Tooltip_iterableToArrayLimit(arr, i) || Tooltip_unsupportedIterableToArray(arr, i) || Tooltip_nonIterableRest(); }\n\nfunction Tooltip_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction Tooltip_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return Tooltip_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return Tooltip_arrayLikeToArray(o, minLen); }\n\nfunction Tooltip_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction Tooltip_iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction Tooltip_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\n\n\n\n\n\n\n\n\nvar Tooltip = /*#__PURE__*/(0,react.forwardRef)(function (_ref, ref) {\n  var label = _ref.label,\n      _ref$element = _ref.element,\n      Element = _ref$element === void 0 ? \'div\' : _ref$element,\n      className = _ref.className,\n      children = _ref.children;\n  var tooltipRef = (0,react.useRef)();\n  var targetRef = (0,react.useRef)(null);\n\n  var _useState = (0,react.useState)(false),\n      _useState2 = Tooltip_slicedToArray(_useState, 2),\n      active = _useState2[0],\n      setActive = _useState2[1];\n\n  (0,react.useImperativeHandle)(ref, function () {\n    return tooltipRef.current;\n  });\n  (0,react.useEffect)(function () {\n    function handleScroll() {\n      setActive(function (active) {\n        return active && !active;\n      });\n    }\n\n    document.addEventListener(\'scroll\', handleScroll);\n    return function () {\n      document.removeEventListener(\'scroll\', handleScroll);\n    };\n  }, []);\n  var handleMouseEnter = (0,react.useCallback)(function (event) {\n    targetRef.current = event.currentTarget;\n    setActive(true);\n  }, []);\n  var handleMouseLeave = (0,react.useCallback)(function () {\n    targetRef.current = null;\n    setActive(false);\n  }, []);\n  var handleEntering = (0,react.useCallback)(function () {\n    var tooltipRect = tooltipRef.current.getBoundingClientRect();\n    var targetRect = targetRef.current.getBoundingClientRect();\n    var top = targetRect.top + targetRect.height + tooltip_constants_numbers.UNBOUNDED_ANCHOR_GAP;\n    var left = targetRect.left + targetRect.width * 0.5 - tooltipRect.width * 0.5;\n    var right = left + tooltipRect.width;\n    var bottom = top + tooltipRect.height;\n    var overflowBottom = window.innerHeight - bottom;\n    var overflowRight = window.innerWidth - right;\n\n    if (tooltipRect.height > tooltip_constants_numbers.MIN_HEIGHT && tooltipRect.width >= tooltip_constants_numbers.MAX_WIDTH) {\n      tooltipRef.current.classList.add(tooltip_constants_cssClasses.MULTILINE);\n    }\n\n    if (overflowBottom < 0) {\n      tooltipRef.current.style.top = "".concat(targetRect.top - tooltipRect.height - tooltip_constants_numbers.UNBOUNDED_ANCHOR_GAP, "px");\n    } else {\n      tooltipRef.current.style.top = "".concat(top, "px");\n    }\n\n    if (overflowRight < 0) {\n      tooltipRef.current.style.left = "".concat(targetRect.right - tooltipRect.width, "px");\n    } else {\n      tooltipRef.current.style.left = "".concat(left < 0 ? targetRect.left : left, "px");\n    }\n  }, []);\n  var classNames = classnames_default()(tooltip_constants_cssClasses.ROOT, className);\n  return /*#__PURE__*/(0,jsx_runtime.jsxs)(jsx_runtime.Fragment, {\n    children: [/*#__PURE__*/(0,jsx_runtime.jsx)(Clone, {\n      component: children,\n      onMouseEnter: handleMouseEnter,\n      onMouseLeave: handleMouseLeave\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Layer, {\n      modal: true,\n      "in": active,\n      timeout: {\n        enter: tooltip_constants_numbers.SHOW_DELAY_MS,\n        exit: tooltip_constants_numbers.HIDE_DELAY_MS\n      },\n      classNames: {\n        enter: tooltip_constants_cssClasses.SHOWING_TRANSITION,\n        enterActive: "".concat(tooltip_constants_cssClasses.SHOWING_TRANSITION, " ").concat(tooltip_constants_cssClasses.SHOWING),\n        enterDone: "".concat(tooltip_constants_cssClasses.SHOWING_TRANSITION, " ").concat(tooltip_constants_cssClasses.SHOWN),\n        exit: "".concat(tooltip_constants_cssClasses.HIDE_TRANSITION, " ").concat(tooltip_constants_cssClasses.HIDE),\n        exitActive: "".concat(tooltip_constants_cssClasses.HIDE_TRANSITION, " ").concat(tooltip_constants_cssClasses.HIDE)\n      },\n      onEntering: handleEntering,\n      mountOnEnter: true,\n      unmountOnExit: true,\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(Element, {\n        ref: tooltipRef,\n        className: classNames,\n        role: "tooltip",\n        "aria-hidden": active ? undefined : \'true\',\n        children: /*#__PURE__*/(0,jsx_runtime.jsx)("div", {\n          className: "".concat(tooltip_constants_cssClasses.SURFACE, " ").concat(tooltip_constants_cssClasses.SURFACE_ANIMATION),\n          children: label\n        })\n      })\n    })]\n  });\n});\nTooltip.displayName = \'MDCTooltip\';\n/* harmony default export */ const tooltip_Tooltip = (Tooltip);\n;// CONCATENATED MODULE: ./src/tooltip/RichTooltip.jsx\nfunction RichTooltip_slicedToArray(arr, i) { return RichTooltip_arrayWithHoles(arr) || RichTooltip_iterableToArrayLimit(arr, i) || RichTooltip_unsupportedIterableToArray(arr, i) || RichTooltip_nonIterableRest(); }\n\nfunction RichTooltip_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction RichTooltip_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return RichTooltip_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return RichTooltip_arrayLikeToArray(o, minLen); }\n\nfunction RichTooltip_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction RichTooltip_iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction RichTooltip_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\n\n\n\n\n\n\n\n\nvar RichTooltip = /*#__PURE__*/(0,react.forwardRef)(function (_ref, ref) {\n  var title = _ref.title,\n      content = _ref.content,\n      actions = _ref.actions,\n      _ref$element = _ref.element,\n      Element = _ref$element === void 0 ? \'div\' : _ref$element,\n      className = _ref.className,\n      children = _ref.children;\n  var tooltipRef = (0,react.useRef)();\n  var targetRef = (0,react.useRef)();\n\n  var _useState = (0,react.useState)(false),\n      _useState2 = RichTooltip_slicedToArray(_useState, 2),\n      active = _useState2[0],\n      setActive = _useState2[1];\n\n  (0,react.useImperativeHandle)(ref, function () {\n    return tooltipRef.current;\n  });\n  (0,react.useEffect)(function () {\n    function handleScroll() {\n      setActive(function (active) {\n        return active && !active;\n      });\n    }\n\n    document.addEventListener(\'scroll\', handleScroll);\n    return function () {\n      document.removeEventListener(\'scroll\', handleScroll);\n    };\n  }, []);\n  var handleTargetMouseEnter = (0,react.useCallback)(function () {\n    setActive(true);\n  }, []);\n  var handleTargetMouseLeave = (0,react.useCallback)(function () {\n    setActive(false);\n  }, []);\n  var handleTooltipMouseEnter = (0,react.useCallback)(function () {\n    setActive(true);\n  }, []);\n  var handleTooltipMouseLeave = (0,react.useCallback)(function () {\n    setActive(false);\n  }, []);\n  var handleEntering = (0,react.useCallback)(function () {\n    var tooltipRect = tooltipRef.current.getBoundingClientRect();\n    var targetRect = targetRef.current.getBoundingClientRect();\n    var width = tooltipRef.current.firstChild.clientWidth;\n    var height = tooltipRef.current.firstChild.scrollHeight;\n    var top = targetRect.bottom + window.scrollY + tooltip_constants_numbers.UNBOUNDED_ANCHOR_GAP;\n    var left = targetRect.right + window.scrollX + tooltip_constants_numbers.UNBOUNDED_ANCHOR_GAP;\n    var right = left + width + tooltip_constants_numbers.MIN_VIEWPORT_TOOLTIP_THRESHOLD;\n    var bottom = top + height + tooltip_constants_numbers.MIN_VIEWPORT_TOOLTIP_THRESHOLD;\n    var overflowBottom = window.innerHeight - bottom;\n    var overflowRight = window.innerWidth - right;\n\n    if (overflowBottom < 0) {\n      tooltipRef.current.style.top = "".concat(top + overflowBottom, "px");\n    } else {\n      tooltipRef.current.style.top = "".concat(top, "px");\n    }\n\n    if (overflowRight < 0) {\n      tooltipRef.current.style.left = "".concat(targetRect.right - tooltipRect.width, "px");\n    } else {\n      tooltipRef.current.style.left = "".concat(left < 0 ? targetRect.left : left, "px");\n    }\n\n    tooltipRef.current.getBoundingClientRect();\n  }, []);\n  var classNames = classnames_default()(tooltip_constants_cssClasses.ROOT, tooltip_constants_cssClasses.RICH, className);\n  return /*#__PURE__*/(0,jsx_runtime.jsxs)(jsx_runtime.Fragment, {\n    children: [/*#__PURE__*/(0,jsx_runtime.jsx)(Clone, {\n      component: children,\n      ref: targetRef,\n      onMouseEnter: handleTargetMouseEnter,\n      onMouseLeave: handleTargetMouseLeave\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Layer, {\n      modal: true,\n      "in": active,\n      timeout: {\n        enter: tooltip_constants_numbers.SHOW_DELAY_MS,\n        exit: tooltip_constants_numbers.HIDE_DELAY_MS\n      },\n      classNames: {\n        enter: tooltip_constants_cssClasses.SHOWING_TRANSITION,\n        enterActive: "".concat(tooltip_constants_cssClasses.SHOWING_TRANSITION, " ").concat(tooltip_constants_cssClasses.SHOWING),\n        enterDone: "".concat(tooltip_constants_cssClasses.SHOWING_TRANSITION, " ").concat(tooltip_constants_cssClasses.SHOWN),\n        exit: tooltip_constants_cssClasses.SHOWN,\n        exitActive: "".concat(tooltip_constants_cssClasses.HIDE_TRANSITION, " ").concat(tooltip_constants_cssClasses.SHOWN),\n        exitDone: "".concat(tooltip_constants_cssClasses.HIDE_TRANSITION, " ").concat(tooltip_constants_cssClasses.HIDE)\n      },\n      mountOnEnter: true,\n      unmountOnExit: true,\n      onEntering: handleEntering,\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(Element, {\n        ref: tooltipRef,\n        className: classNames,\n        role: "tooltip",\n        "aria-hidden": active ? undefined : \'true\',\n        "aria-expanded": active ? \'true\' : undefined,\n        onMouseEnter: handleTooltipMouseEnter,\n        onMouseLeave: handleTooltipMouseLeave,\n        children: /*#__PURE__*/(0,jsx_runtime.jsxs)("div", {\n          className: "".concat(tooltip_constants_cssClasses.SURFACE, " ").concat(tooltip_constants_cssClasses.SURFACE_ANIMATION),\n          children: [title && /*#__PURE__*/(0,jsx_runtime.jsx)("h2", {\n            className: tooltip_constants_cssClasses.TITLE,\n            children: title\n          }), content && /*#__PURE__*/(0,jsx_runtime.jsx)("p", {\n            className: tooltip_constants_cssClasses.CONTENT,\n            children: content\n          }), actions && /*#__PURE__*/(0,jsx_runtime.jsx)("div", {\n            className: tooltip_constants_cssClasses.ACTIONS,\n            children: react.Children.map(actions, function (action) {\n              return /*#__PURE__*/(0,jsx_runtime.jsx)(Clone, {\n                component: action,\n                "aria-label": "action"\n              });\n            })\n          })]\n        })\n      })\n    })]\n  });\n});\nRichTooltip.displayName = \'MDCRichTooltip\';\n/* harmony default export */ const tooltip_RichTooltip = (RichTooltip);\n;// CONCATENATED MODULE: ./src/tooltip/index.js\n\n\n;// CONCATENATED MODULE: ./src/text-field/constants.js\nvar text_field_constants_cssClasses = {\n  ROOT: \'mdc-text-field\',\n  FILLED: \'mdc-text-field--filled\',\n  OUTLINED: \'mdc-text-field--outlined\',\n  TEXTAREA: \'mdc-text-field--textarea\',\n  DISABLED: \'mdc-text-field--disabled\',\n  FOCUSED: \'mdc-text-field--focused\',\n  INVALID: \'mdc-text-field--invalid\',\n  LABEL_FLOATING: \'mdc-text-field--label-floating\',\n  NO_LABEL: \'mdc-text-field--no-label\',\n  END_ALIGNED: \'mdc-text-field--end-aligned\',\n  WITH_LEADING_ICON: \'mdc-text-field--with-leading-icon\',\n  WITH_TRAILING_ICON: \'mdc-text-field--with-trailing-icon\',\n  WITH_INTERNAL_COUNTER: \'mdc-text-field--with-internal-counter\',\n  ICON: \'mdc-text-field__icon\',\n  ICON_LEADING: \'mdc-text-field__icon--leading\',\n  ICON_TRAILING: \'mdc-text-field__icon--trailing\',\n  INPUT: \'mdc-text-field__input\',\n  AFFIX: \'mdc-text-field__affix\',\n  AFFIX_PREFIX: \'mdc-text-field__affix--prefix\',\n  AFFIX_SUFFIX: \'mdc-text-field__affix--suffix\',\n  RESIZER: \'mdc-text-field__resizer\',\n  RIPPLE: \'mdc-text-field__ripple\',\n  HELPER_LINE: \'mdc-text-field-helper-line\',\n  HELPER_TEXT: \'mdc-text-field-helper-text\',\n  HELPER_TEXT_PERSISTENT: \'mdc-text-field-helper-text--persistent\',\n  HELPER_TEXT_VALIDATION: \'mdc-text-field-helper-text--validation-msg\',\n  CHARACTER_COUNTER: \'mdc-text-field-character-counter\'\n};\n;// CONCATENATED MODULE: ./src/text-field/HelperText.jsx\nvar text_field_HelperText_excluded = ["persistent", "validation"];\n\nfunction text_field_HelperText_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction text_field_HelperText_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { text_field_HelperText_ownKeys(Object(source), true).forEach(function (key) { text_field_HelperText_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { text_field_HelperText_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction text_field_HelperText_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction text_field_HelperText_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = text_field_HelperText_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction text_field_HelperText_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\n\nvar HelperText_HelperText = function HelperText(_ref) {\n  var _classnames;\n\n  var _ref$persistent = _ref.persistent,\n      persistent = _ref$persistent === void 0 ? false : _ref$persistent,\n      _ref$validation = _ref.validation,\n      validation = _ref$validation === void 0 ? false : _ref$validation,\n      props = text_field_HelperText_objectWithoutProperties(_ref, text_field_HelperText_excluded);\n\n  var classNames = classnames_default()(text_field_constants_cssClasses.HELPER_TEXT, (_classnames = {}, text_field_HelperText_defineProperty(_classnames, text_field_constants_cssClasses.HELPER_TEXT_PERSISTENT, persistent), text_field_HelperText_defineProperty(_classnames, text_field_constants_cssClasses.HELPER_TEXT_VALIDATION, validation), _classnames));\n  return /*#__PURE__*/(0,jsx_runtime.jsx)("div", text_field_HelperText_objectSpread({\n    className: classNames\n  }, props));\n};\n\nHelperText_HelperText.displayName = \'MDCTextFieldHelperText\';\nHelperText_HelperText.propTypes = {\n  persistent: (prop_types_default()).bool,\n  validation: (prop_types_default()).bool\n};\n/* harmony default export */ const text_field_HelperText = (HelperText_HelperText);\n;// CONCATENATED MODULE: ./src/text-field/CharacterCounter.jsx\nvar CharacterCounter_excluded = ["value", "maxValue"];\n\nfunction CharacterCounter_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction CharacterCounter_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { CharacterCounter_ownKeys(Object(source), true).forEach(function (key) { CharacterCounter_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { CharacterCounter_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction CharacterCounter_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction CharacterCounter_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = CharacterCounter_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction CharacterCounter_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\nfunction CharacterCounter(_ref) {\n  var _ref$value = _ref.value,\n      value = _ref$value === void 0 ? 0 : _ref$value,\n      maxValue = _ref.maxValue,\n      props = CharacterCounter_objectWithoutProperties(_ref, CharacterCounter_excluded);\n\n  return /*#__PURE__*/(0,jsx_runtime.jsx)("div", CharacterCounter_objectSpread(CharacterCounter_objectSpread({\n    className: "mdc-text-field-character-counter"\n  }, props), {}, {\n    children: value + (maxValue ? " / ".concat(maxValue) : \'\')\n  }));\n}\nCharacterCounter.displayName = \'MDCTextFieldCharacterCounter\';\nCharacterCounter.propTypes = {\n  value: (prop_types_default()).number,\n  maxValue: (prop_types_default()).number\n};\n;// CONCATENATED MODULE: ./src/text-field/Input.jsx\nvar text_field_Input_excluded = ["textarea", "autoResize", "element"];\n\nfunction text_field_Input_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction text_field_Input_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { text_field_Input_ownKeys(Object(source), true).forEach(function (key) { text_field_Input_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { text_field_Input_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction text_field_Input_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction text_field_Input_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = text_field_Input_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction text_field_Input_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\nvar Input_Input = /*#__PURE__*/(0,react.forwardRef)(function (_ref, ref) {\n  var textarea = _ref.textarea,\n      autoResize = _ref.autoResize,\n      _ref$element = _ref.element,\n      Element = _ref$element === void 0 ? textarea ? \'textarea\' : \'input\' : _ref$element,\n      props = text_field_Input_objectWithoutProperties(_ref, text_field_Input_excluded);\n\n  (0,react.useLayoutEffect)(function () {\n    if (!autoResize) return;\n    var element = ref.current;\n\n    function setHeight() {\n      element.style.height = \'1rem\';\n      element.style.height = "".concat(element.scrollHeight, "px");\n    }\n\n    setHeight();\n    element.addEventListener(\'input\', setHeight);\n    return function () {\n      return element.removeEventListener(\'input\', setHeight);\n    };\n  }, [autoResize, ref]);\n  return /*#__PURE__*/(0,jsx_runtime.jsx)(Element, text_field_Input_objectSpread({\n    ref: ref,\n    className: text_field_constants_cssClasses.INPUT\n  }, props));\n});\nInput_Input.displayName = \'MDCTextFieldInput\';\n/* harmony default export */ const text_field_Input = (Input_Input);\n;// CONCATENATED MODULE: ./src/text-field/Resizer.jsx\nvar Resizer_excluded = ["textarea", "autoResize", "children"];\n\nfunction Resizer_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction Resizer_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { Resizer_ownKeys(Object(source), true).forEach(function (key) { Resizer_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { Resizer_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction Resizer_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction Resizer_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = Resizer_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction Resizer_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\nvar Resizer = function Resizer(_ref) {\n  var textarea = _ref.textarea,\n      autoResize = _ref.autoResize,\n      children = _ref.children,\n      props = Resizer_objectWithoutProperties(_ref, Resizer_excluded);\n\n  return textarea && !autoResize ? /*#__PURE__*/(0,jsx_runtime.jsx)("span", Resizer_objectSpread(Resizer_objectSpread({\n    className: text_field_constants_cssClasses.RESIZER\n  }, props), {}, {\n    children: children\n  })) : children;\n};\n\nResizer.displayName = \'MDCTextFieldResizer\';\n/* harmony default export */ const text_field_Resizer = (Resizer);\n;// CONCATENATED MODULE: ./src/text-field/TextField.jsx\nvar TextField_excluded = ["value", "defaultValue", "label", "leadingIcon", "trailingIcon", "prefix", "suffix", "persistentHelperText", "helperText", "validationMessage", "filled", "outlined", "fullWidth", "disabled", "textarea", "endAligned", "autoResize", "characterCounter", "internalCharacterCounter", "className", "element", "onChange"];\n\nfunction TextField_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction TextField_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { TextField_ownKeys(Object(source), true).forEach(function (key) { TextField_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { TextField_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction TextField_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction TextField_slicedToArray(arr, i) { return TextField_arrayWithHoles(arr) || TextField_iterableToArrayLimit(arr, i) || TextField_unsupportedIterableToArray(arr, i) || TextField_nonIterableRest(); }\n\nfunction TextField_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction TextField_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return TextField_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return TextField_arrayLikeToArray(o, minLen); }\n\nfunction TextField_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction TextField_iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction TextField_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction TextField_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = TextField_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction TextField_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nvar TextField = /*#__PURE__*/(0,react.forwardRef)(function (_ref, ref) {\n  var _inputRef$current2, _classnames, _inputRef$current3;\n\n  var value = _ref.value,\n      defaultValue = _ref.defaultValue,\n      label = _ref.label,\n      leadingIcon = _ref.leadingIcon,\n      trailingIcon = _ref.trailingIcon,\n      prefix = _ref.prefix,\n      suffix = _ref.suffix,\n      persistentHelperText = _ref.persistentHelperText,\n      _ref$helperText = _ref.helperText,\n      helperText = _ref$helperText === void 0 ? persistentHelperText : _ref$helperText,\n      validationMessage = _ref.validationMessage,\n      _ref$filled = _ref.filled,\n      filled = _ref$filled === void 0 ? false : _ref$filled,\n      _ref$outlined = _ref.outlined,\n      outlined = _ref$outlined === void 0 ? false : _ref$outlined,\n      _ref$fullWidth = _ref.fullWidth,\n      fullWidth = _ref$fullWidth === void 0 ? false : _ref$fullWidth,\n      _ref$disabled = _ref.disabled,\n      disabled = _ref$disabled === void 0 ? false : _ref$disabled,\n      _ref$textarea = _ref.textarea,\n      textarea = _ref$textarea === void 0 ? false : _ref$textarea,\n      _ref$endAligned = _ref.endAligned,\n      endAligned = _ref$endAligned === void 0 ? false : _ref$endAligned,\n      _ref$autoResize = _ref.autoResize,\n      autoResize = _ref$autoResize === void 0 ? false : _ref$autoResize,\n      _ref$characterCounter = _ref.characterCounter,\n      characterCounter = _ref$characterCounter === void 0 ? false : _ref$characterCounter,\n      _ref$internalCharacte = _ref.internalCharacterCounter,\n      internalCharacterCounter = _ref$internalCharacte === void 0 ? characterCounter === \'internal\' : _ref$internalCharacte,\n      className = _ref.className,\n      _ref$element = _ref.element,\n      Element = _ref$element === void 0 ? \'label\' : _ref$element,\n      _ref$onChange = _ref.onChange,\n      onChange = _ref$onChange === void 0 ? Function.prototype : _ref$onChange,\n      props = TextField_objectWithoutProperties(_ref, TextField_excluded);\n\n  var inputRef = (0,react.useRef)();\n\n  var _useState = (0,react.useState)(false),\n      _useState2 = TextField_slicedToArray(_useState, 2),\n      focused = _useState2[0],\n      setFocused = _useState2[1];\n\n  var _useState3 = (0,react.useState)(false),\n      _useState4 = TextField_slicedToArray(_useState3, 2),\n      touched = _useState4[0],\n      setTouched = _useState4[1];\n\n  var _useState5 = (0,react.useState)(true),\n      _useState6 = TextField_slicedToArray(_useState5, 2),\n      valid = _useState6[0],\n      setValid = _useState6[1];\n\n  var _useState7 = (0,react.useState)(),\n      _useState8 = TextField_slicedToArray(_useState7, 2),\n      interactionCoords = _useState8[0],\n      setInteractionCoords = _useState8[1];\n\n  var _useState9 = (0,react.useState)((value === null || value === void 0 ? void 0 : value.length) || (defaultValue === null || defaultValue === void 0 ? void 0 : defaultValue.value) || 0),\n      _useState10 = TextField_slicedToArray(_useState9, 2),\n      count = _useState10[0],\n      setCount = _useState10[1];\n\n  var handleInteraction = (0,react.useCallback)(function (event) {\n    var targetClientRect = event.target.getBoundingClientRect();\n    setInteractionCoords({\n      x: event.clientX - targetClientRect.left,\n      y: event.clientY - targetClientRect.top\n    });\n  }, []);\n  var handleInputFocus = (0,react.useCallback)(function () {\n    setFocused(true);\n    setTouched(true);\n  }, []);\n  var handleInputBlur = (0,react.useCallback)(function () {\n    setFocused(false);\n    setInteractionCoords();\n  }, []);\n  var handleInputChange = (0,react.useCallback)(function (event) {\n    var _inputRef$current;\n\n    var value = inputRef.current.value;\n    var isValid = (_inputRef$current = inputRef.current) === null || _inputRef$current === void 0 ? void 0 : _inputRef$current.validity.valid;\n    setCount(value.length);\n    setValid(isValid);\n    onChange(event, value);\n  }, [onChange]);\n  var focusedOrHasValue = focused || value !== undefined && value !== null && value !== \'\' || defaultValue !== undefined && defaultValue !== null && defaultValue !== \'\' || Boolean((_inputRef$current2 = inputRef.current) === null || _inputRef$current2 === void 0 ? void 0 : _inputRef$current2.value);\n  var hasHelperLine = helperText || validationMessage || characterCounter;\n  var classNames = classnames_default()(text_field_constants_cssClasses.ROOT, (_classnames = {}, TextField_defineProperty(_classnames, text_field_constants_cssClasses.FILLED, filled && !fullWidth), TextField_defineProperty(_classnames, text_field_constants_cssClasses.OUTLINED, outlined && !fullWidth), TextField_defineProperty(_classnames, text_field_constants_cssClasses.TEXTAREA, textarea), TextField_defineProperty(_classnames, text_field_constants_cssClasses.DISABLED, disabled), TextField_defineProperty(_classnames, text_field_constants_cssClasses.FOCUSED, focused), TextField_defineProperty(_classnames, text_field_constants_cssClasses.INVALID, !valid && touched), TextField_defineProperty(_classnames, text_field_constants_cssClasses.LABEL_FLOATING, focusedOrHasValue), TextField_defineProperty(_classnames, text_field_constants_cssClasses.NO_LABEL, !label), TextField_defineProperty(_classnames, text_field_constants_cssClasses.END_ALIGNED, endAligned), TextField_defineProperty(_classnames, text_field_constants_cssClasses.WITH_LEADING_ICON, leadingIcon), TextField_defineProperty(_classnames, text_field_constants_cssClasses.WITH_TRAILING_ICON, trailingIcon), TextField_defineProperty(_classnames, text_field_constants_cssClasses.WITH_INTERNAL_COUNTER, internalCharacterCounter), _classnames), className);\n  return /*#__PURE__*/(0,jsx_runtime.jsxs)(jsx_runtime.Fragment, {\n    children: [/*#__PURE__*/(0,jsx_runtime.jsxs)(Element, {\n      ref: ref,\n      className: classNames,\n      onMouseDown: handleInteraction,\n      onTouchStart: handleInteraction,\n      children: [filled && /*#__PURE__*/(0,jsx_runtime.jsx)("div", {\n        className: text_field_constants_cssClasses.RIPPLE\n      }), filled && label && /*#__PURE__*/(0,jsx_runtime.jsx)(floating_label_FloatingLabel, {\n        label: label,\n        "float": focusedOrHasValue\n      }), outlined && /*#__PURE__*/(0,jsx_runtime.jsx)(notched_outline_NotchedOutline, {\n        notched: focusedOrHasValue,\n        children: label && /*#__PURE__*/(0,jsx_runtime.jsx)(floating_label_FloatingLabel, {\n          label: label,\n          "float": focusedOrHasValue\n        })\n      }), leadingIcon && /*#__PURE__*/(0,jsx_runtime.jsx)(Clone, {\n        component: leadingIcon,\n        fallback: icon_Icon,\n        className: "".concat(text_field_constants_cssClasses.ICON, " ").concat(text_field_constants_cssClasses.ICON_LEADING),\n        tabIndex: "0",\n        role: "button"\n      }), prefix && /*#__PURE__*/(0,jsx_runtime.jsx)("span", {\n        className: "".concat(text_field_constants_cssClasses.AFFIX, " ").concat(text_field_constants_cssClasses.AFFIX_PREFIX),\n        children: prefix\n      }), /*#__PURE__*/(0,jsx_runtime.jsxs)(text_field_Resizer, {\n        textarea: textarea,\n        autoResize: autoResize,\n        children: [/*#__PURE__*/(0,jsx_runtime.jsx)(text_field_Input, TextField_objectSpread({\n          ref: inputRef,\n          value: value,\n          defaultValue: defaultValue,\n          textarea: textarea,\n          autoResize: autoResize,\n          disabled: disabled,\n          onInput: handleInputChange,\n          onFocus: handleInputFocus,\n          onBlur: handleInputBlur\n        }, props)), internalCharacterCounter && /*#__PURE__*/(0,jsx_runtime.jsx)(CharacterCounter, {\n          value: count,\n          maxValue: props.maxLength\n        })]\n      }), suffix && /*#__PURE__*/(0,jsx_runtime.jsx)("span", {\n        className: "".concat(text_field_constants_cssClasses.AFFIX, " ").concat(text_field_constants_cssClasses.AFFIX_SUFFIX),\n        children: suffix\n      }), trailingIcon && /*#__PURE__*/(0,jsx_runtime.jsx)(Clone, {\n        component: trailingIcon,\n        fallback: icon_Icon,\n        className: "".concat(text_field_constants_cssClasses.ICON, " ").concat(text_field_constants_cssClasses.ICON_TRAILING),\n        tabIndex: "0",\n        role: "button"\n      }), filled && /*#__PURE__*/(0,jsx_runtime.jsx)(line_ripple_LineRipple, {\n        active: focused,\n        transformOrigin: interactionCoords === null || interactionCoords === void 0 ? void 0 : interactionCoords.x\n      })]\n    }), hasHelperLine && /*#__PURE__*/(0,jsx_runtime.jsxs)("div", {\n      className: text_field_constants_cssClasses.HELPER_LINE,\n      children: [helperText && /*#__PURE__*/(0,jsx_runtime.jsx)(text_field_HelperText, {\n        persistent: Boolean(persistentHelperText),\n        children: helperText\n      }), validationMessage && !valid && /*#__PURE__*/(0,jsx_runtime.jsx)(text_field_HelperText, {\n        validation: true,\n        children: typeof validationMessage === \'string\' ? validationMessage : (_inputRef$current3 = inputRef.current) === null || _inputRef$current3 === void 0 ? void 0 : _inputRef$current3.validationMessage\n      }), characterCounter && !internalCharacterCounter && /*#__PURE__*/(0,jsx_runtime.jsx)(CharacterCounter, {\n        value: count,\n        maxValue: props.maxLength\n      })]\n    })]\n  });\n});\nTextField.displayName = \'MDCTextField\';\nTextField.propTypes = {\n  value: (prop_types_default()).any,\n  label: (prop_types_default()).string,\n  leadingIcon: (prop_types_default()).node,\n  trailingIcon: (prop_types_default()).node,\n  prefix: (prop_types_default()).string,\n  suffix: (prop_types_default()).string,\n  outline: (prop_types_default()).bool,\n  fullWidth: (prop_types_default()).bool,\n  textarea: (prop_types_default()).bool,\n  dense: (prop_types_default()).bool,\n  disabled: (prop_types_default()).bool,\n  helperText: (prop_types_default()).string,\n  persistentHelperText: (prop_types_default()).string,\n  validationMessage: prop_types_default().oneOfType([(prop_types_default()).bool, (prop_types_default()).string])\n};\n/* harmony default export */ const text_field_TextField = (TextField);\n;// CONCATENATED MODULE: ./src/text-field/index.js\n\n;// CONCATENATED MODULE: ./src/top-app-bar/constants.js\nvar top_app_bar_constants_numbers = {\n  DEBOUNCE_THROTTLE_RESIZE_TIME_MS: 100,\n  MAX_TOP_APP_BAR_HEIGHT: 128\n};\nvar top_app_bar_constants_cssClasses = {\n  ROOT: \'mdc-top-app-bar\',\n  STICKY: \'mdc-top-app-bar--sticky\',\n  STICKY_HIDDEN: \'mdc-top-app-bar--sticky-hidden\',\n  STICKY_SHOWN: \'mdc-top-app-bar--sticky-shown\',\n  FIXED: \'mdc-top-app-bar--fixed\',\n  FIXED_SCROLLED: \'mdc-top-app-bar--fixed-scrolled\',\n  FIXED_ADJUST: \'mdc-top-app-bar--fixed-adjust\',\n  PROMINENT: \'mdc-top-app-bar--prominent\',\n  PROMINENT_FIXED_ADJUST: \'mdc-top-app-bar--prominent-fixed-adjust\',\n  DENSE: \'mdc-top-app-bar--dense\',\n  DENSE_FIXED_ADJUST: \'mdc-top-app-bar--dense-fixed-adjust\',\n  DENSE_PROMINENT_FIXED_ADJUST: \'mdc-top-app-bar--dense-prominent-fixed-adjust\',\n  SHORT: \'mdc-top-app-bar--short\',\n  SHORT_COLLAPSED: \'mdc-top-app-bar--short-collapsed\',\n  SHORT_FIXED_ADJUST: \'mdc-top-app-bar--short-fixed-adjust\',\n  ROW: \'mdc-top-app-bar__row\',\n  SECTION: \'mdc-top-app-bar__section\',\n  SECTION_ALIGN_START: \'mdc-top-app-bar__section--align-start\',\n  SECTION_ALIGN_CENTER: \'mdc-top-app-bar__section--align-center\',\n  SECTION_ALIGN_END: \'mdc-top-app-bar__section--align-end\',\n  NAVIGATION_ICON: \'mdc-top-app-bar__navigation-icon\',\n  ACTION_ITEM: \'mdc-top-app-bar__action-item\',\n  TITLE: \'mdc-top-app-bar__title\'\n};\nvar constants_Align = {\n  START: \'start\',\n  CENTER: \'center\',\n  END: \'end\'\n};\n;// CONCATENATED MODULE: ./src/top-app-bar/TopAppBarRow.jsx\nvar TopAppBarRow_excluded = ["element", "className"];\n\nfunction TopAppBarRow_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction TopAppBarRow_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { TopAppBarRow_ownKeys(Object(source), true).forEach(function (key) { TopAppBarRow_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { TopAppBarRow_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction TopAppBarRow_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction TopAppBarRow_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = TopAppBarRow_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction TopAppBarRow_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\nvar TopAppBarRow = /*#__PURE__*/(0,react.forwardRef)(function (_ref, ref) {\n  var _ref$element = _ref.element,\n      Element = _ref$element === void 0 ? \'div\' : _ref$element,\n      className = _ref.className,\n      props = TopAppBarRow_objectWithoutProperties(_ref, TopAppBarRow_excluded);\n\n  var classNames = classnames_default()(top_app_bar_constants_cssClasses.ROW, className);\n  return /*#__PURE__*/(0,jsx_runtime.jsx)(Element, TopAppBarRow_objectSpread({\n    ref: ref,\n    className: classNames\n  }, props));\n});\nTopAppBarRow.displayName = \'MDCTopAppBarRow\';\n/* harmony default export */ const top_app_bar_TopAppBarRow = (TopAppBarRow);\n;// CONCATENATED MODULE: ./src/top-app-bar/TopAppBarSection.jsx\nvar TopAppBarSection_excluded = ["align", "element", "className"];\n\nfunction TopAppBarSection_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction TopAppBarSection_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { TopAppBarSection_ownKeys(Object(source), true).forEach(function (key) { TopAppBarSection_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { TopAppBarSection_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction TopAppBarSection_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction TopAppBarSection_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = TopAppBarSection_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction TopAppBarSection_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\n\nvar TopAppBarSection = /*#__PURE__*/(0,react.forwardRef)(function (_ref, ref) {\n  var _classnames;\n\n  var align = _ref.align,\n      _ref$element = _ref.element,\n      Element = _ref$element === void 0 ? \'section\' : _ref$element,\n      className = _ref.className,\n      props = TopAppBarSection_objectWithoutProperties(_ref, TopAppBarSection_excluded);\n\n  var classNames = classnames_default()(top_app_bar_constants_cssClasses.SECTION, (_classnames = {}, TopAppBarSection_defineProperty(_classnames, top_app_bar_constants_cssClasses.SECTION_ALIGN_START, align === constants_Align.START), TopAppBarSection_defineProperty(_classnames, top_app_bar_constants_cssClasses.SECTION_ALIGN_CENTER, align === constants_Align.CENTER), TopAppBarSection_defineProperty(_classnames, top_app_bar_constants_cssClasses.SECTION_ALIGN_END, align === constants_Align.END), _classnames), className);\n  return /*#__PURE__*/(0,jsx_runtime.jsx)(Element, TopAppBarSection_objectSpread({\n    ref: ref,\n    className: classNames\n  }, props));\n});\nTopAppBarSection.displayName = \'MDCTopAppBarSection\';\nTopAppBarSection.propTypes = {\n  align: prop_types_default().oneOf(Object.values(constants_Align))\n};\n/* harmony default export */ const top_app_bar_TopAppBarSection = (TopAppBarSection);\n;// CONCATENATED MODULE: ./src/top-app-bar/TopAppBar.jsx\nvar TopAppBar_excluded = ["title", "navigationIcon", "actionItems", "fixed", "sticky", "dense", "prominent", "short", "collapsed", "onNavigationIconClick", "element", "component", "className", "children"];\n\nfunction TopAppBar_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction TopAppBar_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { TopAppBar_ownKeys(Object(source), true).forEach(function (key) { TopAppBar_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { TopAppBar_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction TopAppBar_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction TopAppBar_slicedToArray(arr, i) { return TopAppBar_arrayWithHoles(arr) || TopAppBar_iterableToArrayLimit(arr, i) || TopAppBar_unsupportedIterableToArray(arr, i) || TopAppBar_nonIterableRest(); }\n\nfunction TopAppBar_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction TopAppBar_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return TopAppBar_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return TopAppBar_arrayLikeToArray(o, minLen); }\n\nfunction TopAppBar_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction TopAppBar_iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction TopAppBar_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction TopAppBar_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = TopAppBar_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction TopAppBar_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\n\n\n\n\n\n\nvar TopAppBar = /*#__PURE__*/(0,react.forwardRef)(function (_ref, ref) {\n  var _classnames;\n\n  var title = _ref.title,\n      navigationIcon = _ref.navigationIcon,\n      actionItems = _ref.actionItems,\n      _ref$fixed = _ref.fixed,\n      fixed = _ref$fixed === void 0 ? false : _ref$fixed,\n      _ref$sticky = _ref.sticky,\n      sticky = _ref$sticky === void 0 ? false : _ref$sticky,\n      _ref$dense = _ref.dense,\n      dense = _ref$dense === void 0 ? false : _ref$dense,\n      _ref$prominent = _ref.prominent,\n      prominent = _ref$prominent === void 0 ? false : _ref$prominent,\n      _ref$short = _ref["short"],\n      _short = _ref$short === void 0 ? false : _ref$short,\n      _ref$collapsed = _ref.collapsed,\n      collapsed = _ref$collapsed === void 0 ? false : _ref$collapsed,\n      _ref$onNavigationIcon = _ref.onNavigationIconClick,\n      onNavigationIconClick = _ref$onNavigationIcon === void 0 ? Function.prototype : _ref$onNavigationIcon,\n      _ref$element = _ref.element,\n      element = _ref$element === void 0 ? \'header\' : _ref$element,\n      _ref$component = _ref.component,\n      Element = _ref$component === void 0 ? element : _ref$component,\n      className = _ref.className,\n      children = _ref.children,\n      props = TopAppBar_objectWithoutProperties(_ref, TopAppBar_excluded);\n\n  var rootRef = (0,react.useRef)();\n\n  var _useState = (0,react.useState)(false),\n      _useState2 = TopAppBar_slicedToArray(_useState, 2),\n      scrolled = _useState2[0],\n      setScrolled = _useState2[1];\n\n  var _useState3 = (0,react.useState)(false),\n      _useState4 = TopAppBar_slicedToArray(_useState3, 2),\n      hidden = _useState4[0],\n      setHidden = _useState4[1];\n\n  (0,react.useImperativeHandle)(ref, function () {\n    return rootRef.current;\n  });\n  (0,react.useEffect)(function () {\n    var lastScrollPosition = 0;\n\n    function handleScroll() {\n      var scrollValue = window.pageYOffset;\n\n      if (fixed) {\n        setScrolled(scrollValue > 0);\n      } else if (sticky) {\n        var currentScrollPosition = Math.max(scrollValue, 0);\n        var diff = currentScrollPosition - lastScrollPosition;\n        var shouldHide = diff > 0;\n        lastScrollPosition = currentScrollPosition;\n        setHidden(shouldHide);\n      }\n    }\n\n    window.addEventListener(\'scroll\', handleScroll);\n    return function () {\n      window.removeEventListener(\'scroll\', handleScroll);\n    };\n  }, [fixed, sticky]);\n  var classNames = classnames_default()(top_app_bar_constants_cssClasses.ROOT, (_classnames = {}, TopAppBar_defineProperty(_classnames, top_app_bar_constants_cssClasses.FIXED, fixed), TopAppBar_defineProperty(_classnames, top_app_bar_constants_cssClasses.STICKY, sticky), TopAppBar_defineProperty(_classnames, top_app_bar_constants_cssClasses.DENSE, dense), TopAppBar_defineProperty(_classnames, top_app_bar_constants_cssClasses.PROMINENT, prominent), TopAppBar_defineProperty(_classnames, top_app_bar_constants_cssClasses.SHORT, _short), TopAppBar_defineProperty(_classnames, top_app_bar_constants_cssClasses.SHORT_COLLAPSED, _short && collapsed), TopAppBar_defineProperty(_classnames, top_app_bar_constants_cssClasses.FIXED_SCROLLED, fixed && scrolled), TopAppBar_defineProperty(_classnames, top_app_bar_constants_cssClasses.STICKY_HIDDEN, sticky && hidden), TopAppBar_defineProperty(_classnames, top_app_bar_constants_cssClasses.STICKY_SHOWN, sticky && !hidden), _classnames), className);\n  return /*#__PURE__*/(0,jsx_runtime.jsx)(Element, TopAppBar_objectSpread(TopAppBar_objectSpread({\n    ref: rootRef,\n    className: classNames\n  }, props), {}, {\n    children: children || /*#__PURE__*/(0,jsx_runtime.jsxs)(top_app_bar_TopAppBarRow, {\n      children: [(title || navigationIcon) && /*#__PURE__*/(0,jsx_runtime.jsxs)(top_app_bar_TopAppBarSection, {\n        align: constants_Align.START,\n        children: [navigationIcon && /*#__PURE__*/(0,jsx_runtime.jsx)(Clone, {\n          component: navigationIcon,\n          fallback: icon_button_IconButton,\n          className: top_app_bar_constants_cssClasses.NAVIGATION_ICON,\n          onClick: onNavigationIconClick\n        }), title && /*#__PURE__*/(0,jsx_runtime.jsx)(Clone, {\n          component: title,\n          fallback: "span",\n          className: top_app_bar_constants_cssClasses.TITLE\n        })]\n      }), actionItems && /*#__PURE__*/(0,jsx_runtime.jsx)(top_app_bar_TopAppBarSection, {\n        align: constants_Align.END,\n        children: react.Children.map(actionItems, function (item) {\n          return /*#__PURE__*/(0,jsx_runtime.jsx)(Clone, {\n            component: item,\n            className: top_app_bar_constants_cssClasses.ACTION_ITEM\n          });\n        })\n      })]\n    })\n  }));\n});\nTopAppBar.displayName = \'MDCTopAppBar\';\nTopAppBar.propTypes = {\n  title: (prop_types_default()).node,\n  navigationIcon: (prop_types_default()).node,\n  actionItems: prop_types_default().oneOfType([(prop_types_default()).element, prop_types_default().arrayOf((prop_types_default()).element)]),\n  fixed: (prop_types_default()).bool,\n  sticky: (prop_types_default()).bool,\n  dense: (prop_types_default()).bool,\n  prominent: (prop_types_default()).bool,\n  "short": (prop_types_default()).bool,\n  collapsed: (prop_types_default()).bool\n};\n/* harmony default export */ const top_app_bar_TopAppBar = (TopAppBar);\n;// CONCATENATED MODULE: ./src/top-app-bar/TopAppBarActionItem.jsx\nvar TopAppBarActionItem_excluded = ["element", "component", "className"];\n\nfunction TopAppBarActionItem_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction TopAppBarActionItem_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { TopAppBarActionItem_ownKeys(Object(source), true).forEach(function (key) { TopAppBarActionItem_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { TopAppBarActionItem_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction TopAppBarActionItem_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction TopAppBarActionItem_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = TopAppBarActionItem_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction TopAppBarActionItem_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\nvar TopAppBarActionItem = /*#__PURE__*/(0,react.forwardRef)(function (_ref, ref) {\n  var _ref$element = _ref.element,\n      element = _ref$element === void 0 ? \'span\' : _ref$element,\n      _ref$component = _ref.component,\n      Element = _ref$component === void 0 ? element : _ref$component,\n      className = _ref.className,\n      props = TopAppBarActionItem_objectWithoutProperties(_ref, TopAppBarActionItem_excluded);\n\n  var classNames = classnames_default()(top_app_bar_constants_cssClasses.ACTION_ITEM, className);\n  return /*#__PURE__*/(0,jsx_runtime.jsx)(Element, TopAppBarActionItem_objectSpread({\n    ref: ref,\n    className: classNames\n  }, props));\n});\nTopAppBarActionItem.displayName = \'MDCTopAppBarActionItem\';\n/* harmony default export */ const top_app_bar_TopAppBarActionItem = (TopAppBarActionItem);\n;// CONCATENATED MODULE: ./src/top-app-bar/TopAppBarFixedAdjust.jsx\nvar TopAppBarFixedAdjust_excluded = ["dense", "prominent", "short", "element", "component", "className"];\n\nfunction TopAppBarFixedAdjust_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction TopAppBarFixedAdjust_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { TopAppBarFixedAdjust_ownKeys(Object(source), true).forEach(function (key) { TopAppBarFixedAdjust_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { TopAppBarFixedAdjust_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction TopAppBarFixedAdjust_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction TopAppBarFixedAdjust_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = TopAppBarFixedAdjust_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction TopAppBarFixedAdjust_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\nvar TopAppBarFixedAdjust = /*#__PURE__*/(0,react.forwardRef)(function (_ref, ref) {\n  var _classnames;\n\n  var _ref$dense = _ref.dense,\n      dense = _ref$dense === void 0 ? false : _ref$dense,\n      _ref$prominent = _ref.prominent,\n      prominent = _ref$prominent === void 0 ? false : _ref$prominent,\n      _ref$short = _ref["short"],\n      _short = _ref$short === void 0 ? false : _ref$short,\n      _ref$element = _ref.element,\n      element = _ref$element === void 0 ? \'div\' : _ref$element,\n      _ref$component = _ref.component,\n      Element = _ref$component === void 0 ? element : _ref$component,\n      className = _ref.className,\n      props = TopAppBarFixedAdjust_objectWithoutProperties(_ref, TopAppBarFixedAdjust_excluded);\n\n  var classNames = classnames_default()(top_app_bar_constants_cssClasses.FIXED_ADJUST, (_classnames = {}, TopAppBarFixedAdjust_defineProperty(_classnames, top_app_bar_constants_cssClasses.DENSE_FIXED_ADJUST, dense), TopAppBarFixedAdjust_defineProperty(_classnames, top_app_bar_constants_cssClasses.PROMINENT_FIXED_ADJUST, prominent), TopAppBarFixedAdjust_defineProperty(_classnames, top_app_bar_constants_cssClasses.DENSE_PROMINENT_FIXED_ADJUST, dense && prominent), TopAppBarFixedAdjust_defineProperty(_classnames, top_app_bar_constants_cssClasses.SHORT_FIXED_ADJUST, _short), _classnames), className);\n  return /*#__PURE__*/(0,jsx_runtime.jsx)(Element, TopAppBarFixedAdjust_objectSpread({\n    ref: ref,\n    className: classNames\n  }, props));\n});\nTopAppBarFixedAdjust.displayName = \'MDCTopAppBarFixedAdjust\';\n/* harmony default export */ const top_app_bar_TopAppBarFixedAdjust = (TopAppBarFixedAdjust);\n;// CONCATENATED MODULE: ./src/top-app-bar/TopAppBarNavigationIcon.jsx\nvar TopAppBarNavigationIcon_excluded = ["className"];\n\nfunction TopAppBarNavigationIcon_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction TopAppBarNavigationIcon_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { TopAppBarNavigationIcon_ownKeys(Object(source), true).forEach(function (key) { TopAppBarNavigationIcon_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { TopAppBarNavigationIcon_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction TopAppBarNavigationIcon_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction TopAppBarNavigationIcon_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = TopAppBarNavigationIcon_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction TopAppBarNavigationIcon_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\n\nvar TopAppBarNavigationIcon = /*#__PURE__*/(0,react.forwardRef)(function (_ref, ref) {\n  var className = _ref.className,\n      props = TopAppBarNavigationIcon_objectWithoutProperties(_ref, TopAppBarNavigationIcon_excluded);\n\n  var classNames = classnames_default()(top_app_bar_constants_cssClasses.NAVIGATION_ICON, className);\n  return /*#__PURE__*/(0,jsx_runtime.jsx)(icon_button_IconButton, TopAppBarNavigationIcon_objectSpread({\n    ref: ref,\n    className: classNames\n  }, props));\n});\nTopAppBarNavigationIcon.displayName = \'MDCTopAppBarNavigationIcon\';\n/* harmony default export */ const top_app_bar_TopAppBarNavigationIcon = (TopAppBarNavigationIcon);\n;// CONCATENATED MODULE: ./src/top-app-bar/TopAppBarTitle.jsx\nvar TopAppBarTitle_excluded = ["element", "className"];\n\nfunction TopAppBarTitle_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction TopAppBarTitle_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { TopAppBarTitle_ownKeys(Object(source), true).forEach(function (key) { TopAppBarTitle_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { TopAppBarTitle_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction TopAppBarTitle_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction TopAppBarTitle_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = TopAppBarTitle_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction TopAppBarTitle_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\nvar TopAppBarTitle = /*#__PURE__*/(0,react.forwardRef)(function (_ref, ref) {\n  var _ref$element = _ref.element,\n      Element = _ref$element === void 0 ? \'span\' : _ref$element,\n      className = _ref.className,\n      props = TopAppBarTitle_objectWithoutProperties(_ref, TopAppBarTitle_excluded);\n\n  var classNames = classnames_default()(top_app_bar_constants_cssClasses.TITLE, className);\n  return /*#__PURE__*/(0,jsx_runtime.jsx)(Element, TopAppBarTitle_objectSpread({\n    ref: ref,\n    className: classNames\n  }, props));\n});\nTopAppBarTitle.displayName = \'MDCTopAppBarTitle\';\n/* harmony default export */ const top_app_bar_TopAppBarTitle = (TopAppBarTitle);\n;// CONCATENATED MODULE: ./src/top-app-bar/index.js\n\n\n\n\n\n\n\ntop_app_bar_TopAppBar.ActionItem = top_app_bar_TopAppBarActionItem;\ntop_app_bar_TopAppBar.FixedAdjust = top_app_bar_TopAppBarFixedAdjust;\ntop_app_bar_TopAppBar.NavigationIcon = top_app_bar_TopAppBarNavigationIcon;\ntop_app_bar_TopAppBar.Row = top_app_bar_TopAppBarRow;\ntop_app_bar_TopAppBar.Section = top_app_bar_TopAppBarSection;\ntop_app_bar_TopAppBar.Title = top_app_bar_TopAppBarTitle;\n\n;// CONCATENATED MODULE: ./src/typography/constants.js\nvar elementsByType = {\n  headline1: \'h1\',\n  headline2: \'h2\',\n  headline3: \'h3\',\n  headline4: \'h4\',\n  headline5: \'h5\',\n  headline6: \'h6\',\n  subtitle1: \'h5\',\n  subtitle2: \'h6\',\n  body1: \'p\',\n  body2: \'p\',\n  button: \'span\',\n  caption: \'span\',\n  overline: \'span\'\n};\nvar typography_constants_cssClasses = {\n  ROOT: \'mdc-typography\',\n  DISPLAY: \'mdc-typography--display\',\n  ALIGN: \'mdc-typography--align\',\n  NO_MARGIN: \'mdc-typography--no-margin\',\n  NO_WRAP: \'mdc-typography--no-wrap\'\n};\n;// CONCATENATED MODULE: ./src/typography/Typography.jsx\nvar Typography_excluded = ["type", "display", "align", "noMargin", "noWrap", "element", "component", "className"];\n\nfunction Typography_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction Typography_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { Typography_ownKeys(Object(source), true).forEach(function (key) { Typography_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { Typography_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction Typography_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction Typography_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = Typography_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction Typography_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\n\nvar Typography = /*#__PURE__*/(0,react.forwardRef)(function (_ref, ref) {\n  var _classnames;\n\n  var _ref$type = _ref.type,\n      type = _ref$type === void 0 ? \'body1\' : _ref$type,\n      display = _ref.display,\n      align = _ref.align,\n      _ref$noMargin = _ref.noMargin,\n      noMargin = _ref$noMargin === void 0 ? false : _ref$noMargin,\n      _ref$noWrap = _ref.noWrap,\n      noWrap = _ref$noWrap === void 0 ? false : _ref$noWrap,\n      _ref$element = _ref.element,\n      element = _ref$element === void 0 ? elementsByType[type] : _ref$element,\n      _ref$component = _ref.component,\n      Element = _ref$component === void 0 ? element : _ref$component,\n      className = _ref.className,\n      props = Typography_objectWithoutProperties(_ref, Typography_excluded);\n\n  var classNames = classnames_default()(typography_constants_cssClasses.ROOT, "".concat(typography_constants_cssClasses.ROOT, "--").concat(type), (_classnames = {}, Typography_defineProperty(_classnames, "".concat(typography_constants_cssClasses.DISPLAY, "-").concat(display), display), Typography_defineProperty(_classnames, "".concat(typography_constants_cssClasses.ALIGN, "-").concat(align), align), Typography_defineProperty(_classnames, typography_constants_cssClasses.NO_MARGIN, noMargin), Typography_defineProperty(_classnames, typography_constants_cssClasses.NO_WRAP, noWrap), _classnames), className);\n  return /*#__PURE__*/(0,jsx_runtime.jsx)(Element, Typography_objectSpread({\n    ref: ref,\n    className: classNames\n  }, props));\n});\nTypography.displayName = \'MDCTypography\';\nTypography.propTypes = {\n  type: prop_types_default().oneOf(Object.keys(elementsByType)),\n  display: prop_types_default().oneOf([\'block\', \'inline\', \'inline-block\']),\n  align: prop_types_default().oneOf([\'left\', \'center\', \'right\', \'justify\']),\n  noMargin: (prop_types_default()).bool,\n  noWrap: (prop_types_default()).bool\n};\n/* harmony default export */ const typography_Typography = (Typography);\n;// CONCATENATED MODULE: ./src/typography/index.js\n\n;// CONCATENATED MODULE: ./src/index.js\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n;// CONCATENATED MODULE: ./docs/src/utils/code.js\nfunction code_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { code_typeof = function _typeof(obj) { return typeof obj; }; } else { code_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return code_typeof(obj); }\n\nfunction code_slicedToArray(arr, i) { return code_arrayWithHoles(arr) || code_iterableToArrayLimit(arr, i) || code_unsupportedIterableToArray(arr, i) || code_nonIterableRest(); }\n\nfunction code_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction code_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return code_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return code_arrayLikeToArray(o, minLen); }\n\nfunction code_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction code_iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction code_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\n\nfunction jsxToHtml(root) {\n  return react.Children.toArray(root).map(function (item) {\n    return printComponent(item);\n  }).join(\'\\n\');\n}\nfunction printComponent(component) {\n  var depth = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  var type = typeof component.type === \'string\' ? component.type : component.type.displayName.replace(\'MDC\', \'\');\n  var children = component.props.children;\n  var props = Object.entries(component.props).filter(function (_ref) {\n    var _ref2 = code_slicedToArray(_ref, 2),\n        key = _ref2[0],\n        value = _ref2[1];\n\n    return key !== \'children\' && value !== undefined;\n  });\n  var indent = \'  \'.repeat(depth);\n  var result = indent + "<".concat(type);\n\n  if (!isEmpty(props)) {\n    result += " ".concat(printProps(props, depth + 1));\n  }\n\n  if (!children) {\n    result += result.endsWith(\'\\n\') ? indent + \'/>\' : \' />\';\n  } else if ( /*#__PURE__*/(0,react.isValidElement)(children)) {\n    result += ">\\n".concat(printComponent(children, depth + 1), "\\n").concat(indent, "</").concat(type, ">");\n  } else if (Array.isArray(children)) {\n    result += result.endsWith(\'\\n\') ? indent + \'>\\n\' : \'>\\n\';\n    result += children.map(function (child) {\n      return printComponent(child, depth + 1);\n    }).join(\'\\n\');\n    result += "\\n".concat(indent, "</").concat(type, ">");\n  } else {\n    result += ">".concat(children, "</").concat(type, ">");\n  }\n\n  return result;\n}\n\nfunction printProps(props, depth) {\n  var result = \'\';\n  var indent = \'  \'.repeat(depth);\n\n  if (props.length < 3) {\n    result += props.map(printProp).join(\' \');\n  } else {\n    result += "\\n".concat(indent).concat(props.map(printProp).join(\'\\n\' + indent), "\\n");\n  }\n\n  return result;\n}\n\nfunction printProp(_ref3) {\n  var _ref4 = code_slicedToArray(_ref3, 2),\n      key = _ref4[0],\n      value = _ref4[1];\n\n  if (value === true) {\n    return key;\n  } else if (typeof value === \'string\') {\n    return "".concat(key, "=\\"").concat(value, "\\"");\n  } else {\n    return "".concat(key, "={").concat(printValue(value), "}");\n  }\n}\n\nfunction printValue(value) {\n  if (typeof value === \'string\') {\n    return "\'".concat(value, "\'");\n  } else if (Array.isArray(value)) {\n    return "[".concat(value.map(function (v) {\n      return printValue(v);\n    }).join(\', \'), "]");\n  } else if ( /*#__PURE__*/(0,react.isValidElement)(value)) {\n    return printComponent(value);\n  } else if (typeof value === \'function\') {\n    return "".concat(value.name || \'[Function]\');\n  } else {\n    return value;\n  }\n}\n\nfunction isEmpty(value) {\n  if (!value) {\n    return true;\n  } else if (Array.isArray(value)) {\n    return value.length === 0;\n  } else if (code_typeof(value) === \'object\') {\n    return Object.keys(value).length === 0;\n  }\n}\n// EXTERNAL MODULE: ./node_modules/highlight.js/lib/core.js\nvar core = __webpack_require__(390);\n;// CONCATENATED MODULE: ./node_modules/highlight.js/es/core.js\n// https://nodejs.org/api/packages.html#packages_writing_dual_packages_while_avoiding_or_minimizing_hazards\n\n/* harmony default export */ const es_core = (core);\n\n;// CONCATENATED MODULE: ./node_modules/highlight.js/es/languages/javascript.js\nconst IDENT_RE = \'[A-Za-z$_][0-9A-Za-z$_]*\';\nconst KEYWORDS = [\n  "as", // for exports\n  "in",\n  "of",\n  "if",\n  "for",\n  "while",\n  "finally",\n  "var",\n  "new",\n  "function",\n  "do",\n  "return",\n  "void",\n  "else",\n  "break",\n  "catch",\n  "instanceof",\n  "with",\n  "throw",\n  "case",\n  "default",\n  "try",\n  "switch",\n  "continue",\n  "typeof",\n  "delete",\n  "let",\n  "yield",\n  "const",\n  "class",\n  // JS handles these with a special rule\n  // "get",\n  // "set",\n  "debugger",\n  "async",\n  "await",\n  "static",\n  "import",\n  "from",\n  "export",\n  "extends"\n];\nconst LITERALS = [\n  "true",\n  "false",\n  "null",\n  "undefined",\n  "NaN",\n  "Infinity"\n];\n\nconst TYPES = [\n  "Intl",\n  "DataView",\n  "Number",\n  "Math",\n  "Date",\n  "String",\n  "RegExp",\n  "Object",\n  "Function",\n  "Boolean",\n  "Error",\n  "Symbol",\n  "Set",\n  "Map",\n  "WeakSet",\n  "WeakMap",\n  "Proxy",\n  "Reflect",\n  "JSON",\n  "Promise",\n  "Float64Array",\n  "Int16Array",\n  "Int32Array",\n  "Int8Array",\n  "Uint16Array",\n  "Uint32Array",\n  "Float32Array",\n  "Array",\n  "Uint8Array",\n  "Uint8ClampedArray",\n  "ArrayBuffer",\n  "BigInt64Array",\n  "BigUint64Array",\n  "BigInt"\n];\n\nconst ERROR_TYPES = [\n  "EvalError",\n  "InternalError",\n  "RangeError",\n  "ReferenceError",\n  "SyntaxError",\n  "TypeError",\n  "URIError"\n];\n\nconst BUILT_IN_GLOBALS = [\n  "setInterval",\n  "setTimeout",\n  "clearInterval",\n  "clearTimeout",\n\n  "require",\n  "exports",\n\n  "eval",\n  "isFinite",\n  "isNaN",\n  "parseFloat",\n  "parseInt",\n  "decodeURI",\n  "decodeURIComponent",\n  "encodeURI",\n  "encodeURIComponent",\n  "escape",\n  "unescape"\n];\n\nconst BUILT_IN_VARIABLES = [\n  "arguments",\n  "this",\n  "super",\n  "console",\n  "window",\n  "document",\n  "localStorage",\n  "module",\n  "global" // Node.js\n];\n\nconst BUILT_INS = [].concat(\n  BUILT_IN_GLOBALS,\n  TYPES,\n  ERROR_TYPES\n);\n\n/**\n * @param {string} value\n * @returns {RegExp}\n * */\n\n/**\n * @param {RegExp | string } re\n * @returns {string}\n */\nfunction source(re) {\n  if (!re) return null;\n  if (typeof re === "string") return re;\n\n  return re.source;\n}\n\n/**\n * @param {RegExp | string } re\n * @returns {string}\n */\nfunction lookahead(re) {\n  return concat(\'(?=\', re, \')\');\n}\n\n/**\n * @param {...(RegExp | string) } args\n * @returns {string}\n */\nfunction concat(...args) {\n  const joined = args.map((x) => source(x)).join("");\n  return joined;\n}\n\n/*\nLanguage: JavaScript\nDescription: JavaScript (JS) is a lightweight, interpreted, or just-in-time compiled programming language with first-class functions.\nCategory: common, scripting, web\nWebsite: https://developer.mozilla.org/en-US/docs/Web/JavaScript\n*/\n\n/** @type LanguageFn */\nfunction javascript(hljs) {\n  /**\n   * Takes a string like "<Booger" and checks to see\n   * if we can find a matching "</Booger" later in the\n   * content.\n   * @param {RegExpMatchArray} match\n   * @param {{after:number}} param1\n   */\n  const hasClosingTag = (match, { after }) => {\n    const tag = "</" + match[0].slice(1);\n    const pos = match.input.indexOf(tag, after);\n    return pos !== -1;\n  };\n\n  const IDENT_RE$1 = IDENT_RE;\n  const FRAGMENT = {\n    begin: \'<>\',\n    end: \'</>\'\n  };\n  const XML_TAG = {\n    begin: /<[A-Za-z0-9\\\\._:-]+/,\n    end: /\\/[A-Za-z0-9\\\\._:-]+>|\\/>/,\n    /**\n     * @param {RegExpMatchArray} match\n     * @param {CallbackResponse} response\n     */\n    isTrulyOpeningTag: (match, response) => {\n      const afterMatchIndex = match[0].length + match.index;\n      const nextChar = match.input[afterMatchIndex];\n      // nested type?\n      // HTML should not include another raw `<` inside a tag\n      // But a type might: `<Array<Array<number>>`, etc.\n      if (nextChar === "<") {\n        response.ignoreMatch();\n        return;\n      }\n      // <something>\n      // This is now either a tag or a type.\n      if (nextChar === ">") {\n        // if we cannot find a matching closing tag, then we\n        // will ignore it\n        if (!hasClosingTag(match, { after: afterMatchIndex })) {\n          response.ignoreMatch();\n        }\n      }\n    }\n  };\n  const KEYWORDS$1 = {\n    $pattern: IDENT_RE,\n    keyword: KEYWORDS,\n    literal: LITERALS,\n    built_in: BUILT_INS,\n    "variable.language": BUILT_IN_VARIABLES\n  };\n\n  // https://tc39.es/ecma262/#sec-literals-numeric-literals\n  const decimalDigits = \'[0-9](_?[0-9])*\';\n  const frac = `\\\\.(${decimalDigits})`;\n  // DecimalIntegerLiteral, including Annex B NonOctalDecimalIntegerLiteral\n  // https://tc39.es/ecma262/#sec-additional-syntax-numeric-literals\n  const decimalInteger = `0|[1-9](_?[0-9])*|0[0-7]*[89][0-9]*`;\n  const NUMBER = {\n    className: \'number\',\n    variants: [\n      // DecimalLiteral\n      { begin: `(\\\\b(${decimalInteger})((${frac})|\\\\.)?|(${frac}))` +\n        `[eE][+-]?(${decimalDigits})\\\\b` },\n      { begin: `\\\\b(${decimalInteger})\\\\b((${frac})\\\\b|\\\\.)?|(${frac})\\\\b` },\n\n      // DecimalBigIntegerLiteral\n      { begin: `\\\\b(0|[1-9](_?[0-9])*)n\\\\b` },\n\n      // NonDecimalIntegerLiteral\n      { begin: "\\\\b0[xX][0-9a-fA-F](_?[0-9a-fA-F])*n?\\\\b" },\n      { begin: "\\\\b0[bB][0-1](_?[0-1])*n?\\\\b" },\n      { begin: "\\\\b0[oO][0-7](_?[0-7])*n?\\\\b" },\n\n      // LegacyOctalIntegerLiteral (does not include underscore separators)\n      // https://tc39.es/ecma262/#sec-additional-syntax-numeric-literals\n      { begin: "\\\\b0[0-7]+n?\\\\b" },\n    ],\n    relevance: 0\n  };\n\n  const SUBST = {\n    className: \'subst\',\n    begin: \'\\\\$\\\\{\',\n    end: \'\\\\}\',\n    keywords: KEYWORDS$1,\n    contains: [] // defined later\n  };\n  const HTML_TEMPLATE = {\n    begin: \'html`\',\n    end: \'\',\n    starts: {\n      end: \'`\',\n      returnEnd: false,\n      contains: [\n        hljs.BACKSLASH_ESCAPE,\n        SUBST\n      ],\n      subLanguage: \'xml\'\n    }\n  };\n  const CSS_TEMPLATE = {\n    begin: \'css`\',\n    end: \'\',\n    starts: {\n      end: \'`\',\n      returnEnd: false,\n      contains: [\n        hljs.BACKSLASH_ESCAPE,\n        SUBST\n      ],\n      subLanguage: \'css\'\n    }\n  };\n  const TEMPLATE_STRING = {\n    className: \'string\',\n    begin: \'`\',\n    end: \'`\',\n    contains: [\n      hljs.BACKSLASH_ESCAPE,\n      SUBST\n    ]\n  };\n  const JSDOC_COMMENT = hljs.COMMENT(\n    /\\/\\*\\*(?!\\/)/,\n    \'\\\\*/\',\n    {\n      relevance: 0,\n      contains: [\n        {\n          begin: \'(?=@[A-Za-z]+)\',\n          relevance: 0,\n          contains: [\n            {\n              className: \'doctag\',\n              begin: \'@[A-Za-z]+\'\n            },\n            {\n              className: \'type\',\n              begin: \'\\\\{\',\n              end: \'\\\\}\',\n              excludeEnd: true,\n              excludeBegin: true,\n              relevance: 0\n            },\n            {\n              className: \'variable\',\n              begin: IDENT_RE$1 + \'(?=\\\\s*(-)|$)\',\n              endsParent: true,\n              relevance: 0\n            },\n            // eat spaces (not newlines) so we can find\n            // types or variables\n            {\n              begin: /(?=[^\\n])\\s/,\n              relevance: 0\n            }\n          ]\n        }\n      ]\n    }\n  );\n  const COMMENT = {\n    className: "comment",\n    variants: [\n      JSDOC_COMMENT,\n      hljs.C_BLOCK_COMMENT_MODE,\n      hljs.C_LINE_COMMENT_MODE\n    ]\n  };\n  const SUBST_INTERNALS = [\n    hljs.APOS_STRING_MODE,\n    hljs.QUOTE_STRING_MODE,\n    HTML_TEMPLATE,\n    CSS_TEMPLATE,\n    TEMPLATE_STRING,\n    NUMBER,\n    hljs.REGEXP_MODE\n  ];\n  SUBST.contains = SUBST_INTERNALS\n    .concat({\n      // we need to pair up {} inside our subst to prevent\n      // it from ending too early by matching another }\n      begin: /\\{/,\n      end: /\\}/,\n      keywords: KEYWORDS$1,\n      contains: [\n        "self"\n      ].concat(SUBST_INTERNALS)\n    });\n  const SUBST_AND_COMMENTS = [].concat(COMMENT, SUBST.contains);\n  const PARAMS_CONTAINS = SUBST_AND_COMMENTS.concat([\n    // eat recursive parens in sub expressions\n    {\n      begin: /\\(/,\n      end: /\\)/,\n      keywords: KEYWORDS$1,\n      contains: ["self"].concat(SUBST_AND_COMMENTS)\n    }\n  ]);\n  const PARAMS = {\n    className: \'params\',\n    begin: /\\(/,\n    end: /\\)/,\n    excludeBegin: true,\n    excludeEnd: true,\n    keywords: KEYWORDS$1,\n    contains: PARAMS_CONTAINS\n  };\n\n  // ES6 classes\n  const CLASS_OR_EXTENDS = {\n    variants: [\n      {\n        match: [\n          /class/,\n          /\\s+/,\n          IDENT_RE$1\n        ],\n        scope: {\n          1: "keyword",\n          3: "title.class"\n        }\n      },\n      {\n        match: [\n          /extends/,\n          /\\s+/,\n          concat(IDENT_RE$1, "(", concat(/\\./, IDENT_RE$1), ")*")\n        ],\n        scope: {\n          1: "keyword",\n          3: "title.class.inherited"\n        }\n      }\n    ]\n  };\n\n  const CLASS_REFERENCE = {\n    relevance: 0,\n    match: /\\b[A-Z][a-z]+([A-Z][a-z]+)*/,\n    className: "title.class",\n    keywords: {\n      _: [\n        // se we still get relevance credit for JS library classes\n        ...TYPES,\n        ...ERROR_TYPES\n      ]\n    }\n  };\n\n  const USE_STRICT = {\n    label: "use_strict",\n    className: \'meta\',\n    relevance: 10,\n    begin: /^\\s*[\'"]use (strict|asm)[\'"]/\n  };\n\n  const FUNCTION_DEFINITION = {\n    variants: [\n      {\n        match: [\n          /function/,\n          /\\s+/,\n          IDENT_RE$1,\n          /(?=\\s*\\()/\n        ]\n      },\n      // anonymous function\n      {\n        match: [\n          /function/,\n          /\\s*(?=\\()/\n        ]\n      }\n    ],\n    className: {\n      1: "keyword",\n      3: "title.function"\n    },\n    label: "func.def",\n    contains: [ PARAMS ],\n    illegal: /%/\n  };\n\n  const UPPER_CASE_CONSTANT = {\n    relevance: 0,\n    match: /\\b[A-Z][A-Z_0-9]+\\b/,\n    className: "variable.constant"\n  };\n\n  function noneOf(list) {\n    return concat("(?!", list.join("|"), ")");\n  }\n\n  const FUNCTION_CALL = {\n    match: concat(\n      /\\b/,\n      noneOf([\n        ...BUILT_IN_GLOBALS,\n        "super"\n      ]),\n      IDENT_RE$1, lookahead(/\\(/)),\n    className: "title.function",\n    relevance: 0\n  };\n\n  const PROPERTY_ACCESS = {\n    begin: concat(/\\./, lookahead(\n      concat(IDENT_RE$1, /(?![0-9A-Za-z$_(])/)\n    )),\n    end: IDENT_RE$1,\n    excludeBegin: true,\n    keywords: "prototype",\n    className: "property",\n    relevance: 0\n  };\n\n  const GETTER_OR_SETTER = {\n    match: [\n      /get|set/,\n      /\\s+/,\n      IDENT_RE$1,\n      /(?=\\()/\n    ],\n    className: {\n      1: "keyword",\n      3: "title.function"\n    },\n    contains: [\n      { // eat to avoid empty params\n        begin: /\\(\\)/\n      },\n      PARAMS\n    ]\n  };\n\n  const FUNC_LEAD_IN_RE = \'(\\\\(\' +\n    \'[^()]*(\\\\(\' +\n    \'[^()]*(\\\\(\' +\n    \'[^()]*\' +\n    \'\\\\)[^()]*)*\' +\n    \'\\\\)[^()]*)*\' +\n    \'\\\\)|\' + hljs.UNDERSCORE_IDENT_RE + \')\\\\s*=>\';\n\n  const FUNCTION_VARIABLE = {\n    match: [\n      /const|var|let/, /\\s+/,\n      IDENT_RE$1, /\\s*/,\n      /=\\s*/,\n      lookahead(FUNC_LEAD_IN_RE)\n    ],\n    className: {\n      1: "keyword",\n      3: "title.function"\n    },\n    contains: [\n      PARAMS\n    ]\n  };\n\n  return {\n    name: \'Javascript\',\n    aliases: [\'js\', \'jsx\', \'mjs\', \'cjs\'],\n    keywords: KEYWORDS$1,\n    // this will be extended by TypeScript\n    exports: { PARAMS_CONTAINS },\n    illegal: /#(?![$_A-z])/,\n    contains: [\n      hljs.SHEBANG({\n        label: "shebang",\n        binary: "node",\n        relevance: 5\n      }),\n      USE_STRICT,\n      hljs.APOS_STRING_MODE,\n      hljs.QUOTE_STRING_MODE,\n      HTML_TEMPLATE,\n      CSS_TEMPLATE,\n      TEMPLATE_STRING,\n      COMMENT,\n      NUMBER,\n      CLASS_REFERENCE,\n      {\n        className: \'attr\',\n        begin: IDENT_RE$1 + lookahead(\':\'),\n        relevance: 0\n      },\n      FUNCTION_VARIABLE,\n      { // "value" container\n        begin: \'(\' + hljs.RE_STARTERS_RE + \'|\\\\b(case|return|throw)\\\\b)\\\\s*\',\n        keywords: \'return throw case\',\n        relevance: 0,\n        contains: [\n          COMMENT,\n          hljs.REGEXP_MODE,\n          {\n            className: \'function\',\n            // we have to count the parens to make sure we actually have the\n            // correct bounding ( ) before the =>.  There could be any number of\n            // sub-expressions inside also surrounded by parens.\n            begin: FUNC_LEAD_IN_RE,\n            returnBegin: true,\n            end: \'\\\\s*=>\',\n            contains: [\n              {\n                className: \'params\',\n                variants: [\n                  {\n                    begin: hljs.UNDERSCORE_IDENT_RE,\n                    relevance: 0\n                  },\n                  {\n                    className: null,\n                    begin: /\\(\\s*\\)/,\n                    skip: true\n                  },\n                  {\n                    begin: /\\(/,\n                    end: /\\)/,\n                    excludeBegin: true,\n                    excludeEnd: true,\n                    keywords: KEYWORDS$1,\n                    contains: PARAMS_CONTAINS\n                  }\n                ]\n              }\n            ]\n          },\n          { // could be a comma delimited list of params to a function call\n            begin: /,/,\n            relevance: 0\n          },\n          {\n            match: /\\s+/,\n            relevance: 0\n          },\n          { // JSX\n            variants: [\n              { begin: FRAGMENT.begin, end: FRAGMENT.end },\n              {\n                begin: XML_TAG.begin,\n                // we carefully check the opening tag to see if it truly\n                // is a tag and not a false positive\n                \'on:begin\': XML_TAG.isTrulyOpeningTag,\n                end: XML_TAG.end\n              }\n            ],\n            subLanguage: \'xml\',\n            contains: [\n              {\n                begin: XML_TAG.begin,\n                end: XML_TAG.end,\n                skip: true,\n                contains: [\'self\']\n              }\n            ]\n          }\n        ],\n      },\n      FUNCTION_DEFINITION,\n      {\n        // prevent this from getting swallowed up by function\n        // since they appear "function like"\n        beginKeywords: "while if switch catch for"\n      },\n      {\n        // we have to count the parens to make sure we actually have the correct\n        // bounding ( ).  There could be any number of sub-expressions inside\n        // also surrounded by parens.\n        begin: \'\\\\b(?!function)\' + hljs.UNDERSCORE_IDENT_RE +\n          \'\\\\(\' + // first parens\n          \'[^()]*(\\\\(\' +\n            \'[^()]*(\\\\(\' +\n              \'[^()]*\' +\n            \'\\\\)[^()]*)*\' +\n          \'\\\\)[^()]*)*\' +\n          \'\\\\)\\\\s*\\\\{\', // end parens\n        returnBegin:true,\n        label: "func.def",\n        contains: [\n          PARAMS,\n          hljs.inherit(hljs.TITLE_MODE, { begin: IDENT_RE$1, className: "title.function" })\n        ]\n      },\n      // catch ... so it won\'t trigger the property rule below\n      {\n        match: /\\.\\.\\./,\n        relevance: 0\n      },\n      PROPERTY_ACCESS,\n      // hack: prevents detection of keywords in some circumstances\n      // .keyword()\n      // $keyword = x\n      {\n        match: \'\\\\$\' + IDENT_RE$1,\n        relevance: 0\n      },\n      {\n        match: [ /\\bconstructor(?=\\s*\\()/ ],\n        className: { 1: "title.function" },\n        contains: [ PARAMS ]\n      },\n      FUNCTION_CALL,\n      UPPER_CASE_CONSTANT,\n      CLASS_OR_EXTENDS,\n      GETTER_OR_SETTER,\n      {\n        match: /\\$[(.]/ // relevance booster for a pattern common to JS libs: `$(something)` and `$.something`\n      }\n    ]\n  };\n}\n\n/* harmony default export */ const languages_javascript = (javascript);\n\n;// CONCATENATED MODULE: ./node_modules/highlight.js/es/languages/scss.js\nconst MODES = (hljs) => {\n  return {\n    IMPORTANT: {\n      scope: \'meta\',\n      begin: \'!important\'\n    },\n    HEXCOLOR: {\n      scope: \'number\',\n      begin: \'#([a-fA-F0-9]{6}|[a-fA-F0-9]{3})\'\n    },\n    ATTRIBUTE_SELECTOR_MODE: {\n      scope: \'selector-attr\',\n      begin: /\\[/,\n      end: /\\]/,\n      illegal: \'$\',\n      contains: [\n        hljs.APOS_STRING_MODE,\n        hljs.QUOTE_STRING_MODE\n      ]\n    },\n    CSS_NUMBER_MODE: {\n      scope: \'number\',\n      begin: hljs.NUMBER_RE + \'(\' +\n        \'%|em|ex|ch|rem\' +\n        \'|vw|vh|vmin|vmax\' +\n        \'|cm|mm|in|pt|pc|px\' +\n        \'|deg|grad|rad|turn\' +\n        \'|s|ms\' +\n        \'|Hz|kHz\' +\n        \'|dpi|dpcm|dppx\' +\n        \')?\',\n      relevance: 0\n    },\n    CSS_VARIABLE: {\n      className: "attr",\n      begin: /--[A-Za-z][A-Za-z0-9_-]*/\n    }\n  };\n};\n\nconst TAGS = [\n  \'a\',\n  \'abbr\',\n  \'address\',\n  \'article\',\n  \'aside\',\n  \'audio\',\n  \'b\',\n  \'blockquote\',\n  \'body\',\n  \'button\',\n  \'canvas\',\n  \'caption\',\n  \'cite\',\n  \'code\',\n  \'dd\',\n  \'del\',\n  \'details\',\n  \'dfn\',\n  \'div\',\n  \'dl\',\n  \'dt\',\n  \'em\',\n  \'fieldset\',\n  \'figcaption\',\n  \'figure\',\n  \'footer\',\n  \'form\',\n  \'h1\',\n  \'h2\',\n  \'h3\',\n  \'h4\',\n  \'h5\',\n  \'h6\',\n  \'header\',\n  \'hgroup\',\n  \'html\',\n  \'i\',\n  \'iframe\',\n  \'img\',\n  \'input\',\n  \'ins\',\n  \'kbd\',\n  \'label\',\n  \'legend\',\n  \'li\',\n  \'main\',\n  \'mark\',\n  \'menu\',\n  \'nav\',\n  \'object\',\n  \'ol\',\n  \'p\',\n  \'q\',\n  \'quote\',\n  \'samp\',\n  \'section\',\n  \'span\',\n  \'strong\',\n  \'summary\',\n  \'sup\',\n  \'table\',\n  \'tbody\',\n  \'td\',\n  \'textarea\',\n  \'tfoot\',\n  \'th\',\n  \'thead\',\n  \'time\',\n  \'tr\',\n  \'ul\',\n  \'var\',\n  \'video\'\n];\n\nconst MEDIA_FEATURES = [\n  \'any-hover\',\n  \'any-pointer\',\n  \'aspect-ratio\',\n  \'color\',\n  \'color-gamut\',\n  \'color-index\',\n  \'device-aspect-ratio\',\n  \'device-height\',\n  \'device-width\',\n  \'display-mode\',\n  \'forced-colors\',\n  \'grid\',\n  \'height\',\n  \'hover\',\n  \'inverted-colors\',\n  \'monochrome\',\n  \'orientation\',\n  \'overflow-block\',\n  \'overflow-inline\',\n  \'pointer\',\n  \'prefers-color-scheme\',\n  \'prefers-contrast\',\n  \'prefers-reduced-motion\',\n  \'prefers-reduced-transparency\',\n  \'resolution\',\n  \'scan\',\n  \'scripting\',\n  \'update\',\n  \'width\',\n  // TODO: find a better solution?\n  \'min-width\',\n  \'max-width\',\n  \'min-height\',\n  \'max-height\'\n];\n\n// https://developer.mozilla.org/en-US/docs/Web/CSS/Pseudo-classes\nconst PSEUDO_CLASSES = [\n  \'active\',\n  \'any-link\',\n  \'blank\',\n  \'checked\',\n  \'current\',\n  \'default\',\n  \'defined\',\n  \'dir\', // dir()\n  \'disabled\',\n  \'drop\',\n  \'empty\',\n  \'enabled\',\n  \'first\',\n  \'first-child\',\n  \'first-of-type\',\n  \'fullscreen\',\n  \'future\',\n  \'focus\',\n  \'focus-visible\',\n  \'focus-within\',\n  \'has\', // has()\n  \'host\', // host or host()\n  \'host-context\', // host-context()\n  \'hover\',\n  \'indeterminate\',\n  \'in-range\',\n  \'invalid\',\n  \'is\', // is()\n  \'lang\', // lang()\n  \'last-child\',\n  \'last-of-type\',\n  \'left\',\n  \'link\',\n  \'local-link\',\n  \'not\', // not()\n  \'nth-child\', // nth-child()\n  \'nth-col\', // nth-col()\n  \'nth-last-child\', // nth-last-child()\n  \'nth-last-col\', // nth-last-col()\n  \'nth-last-of-type\', //nth-last-of-type()\n  \'nth-of-type\', //nth-of-type()\n  \'only-child\',\n  \'only-of-type\',\n  \'optional\',\n  \'out-of-range\',\n  \'past\',\n  \'placeholder-shown\',\n  \'read-only\',\n  \'read-write\',\n  \'required\',\n  \'right\',\n  \'root\',\n  \'scope\',\n  \'target\',\n  \'target-within\',\n  \'user-invalid\',\n  \'valid\',\n  \'visited\',\n  \'where\' // where()\n];\n\n// https://developer.mozilla.org/en-US/docs/Web/CSS/Pseudo-elements\nconst PSEUDO_ELEMENTS = [\n  \'after\',\n  \'backdrop\',\n  \'before\',\n  \'cue\',\n  \'cue-region\',\n  \'first-letter\',\n  \'first-line\',\n  \'grammar-error\',\n  \'marker\',\n  \'part\',\n  \'placeholder\',\n  \'selection\',\n  \'slotted\',\n  \'spelling-error\'\n];\n\nconst ATTRIBUTES = [\n  \'align-content\',\n  \'align-items\',\n  \'align-self\',\n  \'animation\',\n  \'animation-delay\',\n  \'animation-direction\',\n  \'animation-duration\',\n  \'animation-fill-mode\',\n  \'animation-iteration-count\',\n  \'animation-name\',\n  \'animation-play-state\',\n  \'animation-timing-function\',\n  \'auto\',\n  \'backface-visibility\',\n  \'background\',\n  \'background-attachment\',\n  \'background-clip\',\n  \'background-color\',\n  \'background-image\',\n  \'background-origin\',\n  \'background-position\',\n  \'background-repeat\',\n  \'background-size\',\n  \'border\',\n  \'border-bottom\',\n  \'border-bottom-color\',\n  \'border-bottom-left-radius\',\n  \'border-bottom-right-radius\',\n  \'border-bottom-style\',\n  \'border-bottom-width\',\n  \'border-collapse\',\n  \'border-color\',\n  \'border-image\',\n  \'border-image-outset\',\n  \'border-image-repeat\',\n  \'border-image-slice\',\n  \'border-image-source\',\n  \'border-image-width\',\n  \'border-left\',\n  \'border-left-color\',\n  \'border-left-style\',\n  \'border-left-width\',\n  \'border-radius\',\n  \'border-right\',\n  \'border-right-color\',\n  \'border-right-style\',\n  \'border-right-width\',\n  \'border-spacing\',\n  \'border-style\',\n  \'border-top\',\n  \'border-top-color\',\n  \'border-top-left-radius\',\n  \'border-top-right-radius\',\n  \'border-top-style\',\n  \'border-top-width\',\n  \'border-width\',\n  \'bottom\',\n  \'box-decoration-break\',\n  \'box-shadow\',\n  \'box-sizing\',\n  \'break-after\',\n  \'break-before\',\n  \'break-inside\',\n  \'caption-side\',\n  \'clear\',\n  \'clip\',\n  \'clip-path\',\n  \'color\',\n  \'column-count\',\n  \'column-fill\',\n  \'column-gap\',\n  \'column-rule\',\n  \'column-rule-color\',\n  \'column-rule-style\',\n  \'column-rule-width\',\n  \'column-span\',\n  \'column-width\',\n  \'columns\',\n  \'content\',\n  \'counter-increment\',\n  \'counter-reset\',\n  \'cursor\',\n  \'direction\',\n  \'display\',\n  \'empty-cells\',\n  \'filter\',\n  \'flex\',\n  \'flex-basis\',\n  \'flex-direction\',\n  \'flex-flow\',\n  \'flex-grow\',\n  \'flex-shrink\',\n  \'flex-wrap\',\n  \'float\',\n  \'font\',\n  \'font-display\',\n  \'font-family\',\n  \'font-feature-settings\',\n  \'font-kerning\',\n  \'font-language-override\',\n  \'font-size\',\n  \'font-size-adjust\',\n  \'font-smoothing\',\n  \'font-stretch\',\n  \'font-style\',\n  \'font-variant\',\n  \'font-variant-ligatures\',\n  \'font-variation-settings\',\n  \'font-weight\',\n  \'height\',\n  \'hyphens\',\n  \'icon\',\n  \'image-orientation\',\n  \'image-rendering\',\n  \'image-resolution\',\n  \'ime-mode\',\n  \'inherit\',\n  \'initial\',\n  \'justify-content\',\n  \'left\',\n  \'letter-spacing\',\n  \'line-height\',\n  \'list-style\',\n  \'list-style-image\',\n  \'list-style-position\',\n  \'list-style-type\',\n  \'margin\',\n  \'margin-bottom\',\n  \'margin-left\',\n  \'margin-right\',\n  \'margin-top\',\n  \'marks\',\n  \'mask\',\n  \'max-height\',\n  \'max-width\',\n  \'min-height\',\n  \'min-width\',\n  \'nav-down\',\n  \'nav-index\',\n  \'nav-left\',\n  \'nav-right\',\n  \'nav-up\',\n  \'none\',\n  \'normal\',\n  \'object-fit\',\n  \'object-position\',\n  \'opacity\',\n  \'order\',\n  \'orphans\',\n  \'outline\',\n  \'outline-color\',\n  \'outline-offset\',\n  \'outline-style\',\n  \'outline-width\',\n  \'overflow\',\n  \'overflow-wrap\',\n  \'overflow-x\',\n  \'overflow-y\',\n  \'padding\',\n  \'padding-bottom\',\n  \'padding-left\',\n  \'padding-right\',\n  \'padding-top\',\n  \'page-break-after\',\n  \'page-break-before\',\n  \'page-break-inside\',\n  \'perspective\',\n  \'perspective-origin\',\n  \'pointer-events\',\n  \'position\',\n  \'quotes\',\n  \'resize\',\n  \'right\',\n  \'src\', // @font-face\n  \'tab-size\',\n  \'table-layout\',\n  \'text-align\',\n  \'text-align-last\',\n  \'text-decoration\',\n  \'text-decoration-color\',\n  \'text-decoration-line\',\n  \'text-decoration-style\',\n  \'text-indent\',\n  \'text-overflow\',\n  \'text-rendering\',\n  \'text-shadow\',\n  \'text-transform\',\n  \'text-underline-position\',\n  \'top\',\n  \'transform\',\n  \'transform-origin\',\n  \'transform-style\',\n  \'transition\',\n  \'transition-delay\',\n  \'transition-duration\',\n  \'transition-property\',\n  \'transition-timing-function\',\n  \'unicode-bidi\',\n  \'vertical-align\',\n  \'visibility\',\n  \'white-space\',\n  \'widows\',\n  \'width\',\n  \'word-break\',\n  \'word-spacing\',\n  \'word-wrap\',\n  \'z-index\'\n  // reverse makes sure longer attributes `font-weight` are matched fully\n  // instead of getting false positives on say `font`\n].reverse();\n\n/*\nLanguage: SCSS\nDescription: Scss is an extension of the syntax of CSS.\nAuthor: Kurt Emch <kurt@kurtemch.com>\nWebsite: https://sass-lang.com\nCategory: common, css, web\n*/\n\n/** @type LanguageFn */\nfunction scss(hljs) {\n  const modes = MODES(hljs);\n  const PSEUDO_ELEMENTS$1 = PSEUDO_ELEMENTS;\n  const PSEUDO_CLASSES$1 = PSEUDO_CLASSES;\n\n  const AT_IDENTIFIER = \'@[a-z-]+\'; // @font-face\n  const AT_MODIFIERS = "and or not only";\n  const IDENT_RE = \'[a-zA-Z-][a-zA-Z0-9_-]*\';\n  const VARIABLE = {\n    className: \'variable\',\n    begin: \'(\\\\$\' + IDENT_RE + \')\\\\b\'\n  };\n\n  return {\n    name: \'SCSS\',\n    case_insensitive: true,\n    illegal: \'[=/|\\\']\',\n    contains: [\n      hljs.C_LINE_COMMENT_MODE,\n      hljs.C_BLOCK_COMMENT_MODE,\n      {\n        className: \'selector-id\',\n        begin: \'#[A-Za-z0-9_-]+\',\n        relevance: 0\n      },\n      {\n        className: \'selector-class\',\n        begin: \'\\\\.[A-Za-z0-9_-]+\',\n        relevance: 0\n      },\n      modes.ATTRIBUTE_SELECTOR_MODE,\n      {\n        className: \'selector-tag\',\n        begin: \'\\\\b(\' + TAGS.join(\'|\') + \')\\\\b\',\n        // was there, before, but why?\n        relevance: 0\n      },\n      {\n        className: \'selector-pseudo\',\n        begin: \':(\' + PSEUDO_CLASSES$1.join(\'|\') + \')\'\n      },\n      {\n        className: \'selector-pseudo\',\n        begin: \'::(\' + PSEUDO_ELEMENTS$1.join(\'|\') + \')\'\n      },\n      VARIABLE,\n      { // pseudo-selector params\n        begin: /\\(/,\n        end: /\\)/,\n        contains: [ modes.CSS_NUMBER_MODE ]\n      },\n      modes.CSS_VARIABLE,\n      {\n        className: \'attribute\',\n        begin: \'\\\\b(\' + ATTRIBUTES.join(\'|\') + \')\\\\b\'\n      },\n      {\n        begin: \'\\\\b(whitespace|wait|w-resize|visible|vertical-text|vertical-ideographic|uppercase|upper-roman|upper-alpha|underline|transparent|top|thin|thick|text|text-top|text-bottom|tb-rl|table-header-group|table-footer-group|sw-resize|super|strict|static|square|solid|small-caps|separate|se-resize|scroll|s-resize|rtl|row-resize|ridge|right|repeat|repeat-y|repeat-x|relative|progress|pointer|overline|outside|outset|oblique|nowrap|not-allowed|normal|none|nw-resize|no-repeat|no-drop|newspaper|ne-resize|n-resize|move|middle|medium|ltr|lr-tb|lowercase|lower-roman|lower-alpha|loose|list-item|line|line-through|line-edge|lighter|left|keep-all|justify|italic|inter-word|inter-ideograph|inside|inset|inline|inline-block|inherit|inactive|ideograph-space|ideograph-parenthesis|ideograph-numeric|ideograph-alpha|horizontal|hidden|help|hand|groove|fixed|ellipsis|e-resize|double|dotted|distribute|distribute-space|distribute-letter|distribute-all-lines|disc|disabled|default|decimal|dashed|crosshair|collapse|col-resize|circle|char|center|capitalize|break-word|break-all|bottom|both|bolder|bold|block|bidi-override|below|baseline|auto|always|all-scroll|absolute|table|table-cell)\\\\b\'\n      },\n      {\n        begin: \':\',\n        end: \';\',\n        contains: [\n          VARIABLE,\n          modes.HEXCOLOR,\n          modes.CSS_NUMBER_MODE,\n          hljs.QUOTE_STRING_MODE,\n          hljs.APOS_STRING_MODE,\n          modes.IMPORTANT\n        ]\n      },\n      // matching these here allows us to treat them more like regular CSS\n      // rules so everything between the {} gets regular rule highlighting,\n      // which is what we want for page and font-face\n      {\n        begin: \'@(page|font-face)\',\n        keywords: {\n          $pattern: AT_IDENTIFIER,\n          keyword: \'@page @font-face\'\n        }\n      },\n      {\n        begin: \'@\',\n        end: \'[{;]\',\n        returnBegin: true,\n        keywords: {\n          $pattern: /[a-z-]+/,\n          keyword: AT_MODIFIERS,\n          attribute: MEDIA_FEATURES.join(" ")\n        },\n        contains: [\n          {\n            begin: AT_IDENTIFIER,\n            className: "keyword"\n          },\n          {\n            begin: /[a-z-]+(?=:)/,\n            className: "attribute"\n          },\n          VARIABLE,\n          hljs.QUOTE_STRING_MODE,\n          hljs.APOS_STRING_MODE,\n          modes.HEXCOLOR,\n          modes.CSS_NUMBER_MODE\n        ]\n      }\n    ]\n  };\n}\n\n/* harmony default export */ const languages_scss = (scss);\n\n;// CONCATENATED MODULE: ./node_modules/highlight.js/es/languages/shell.js\n/*\nLanguage: Shell Session\nRequires: bash.js\nAuthor: TSUYUSATO Kitsune <make.just.on@gmail.com>\nCategory: common\nAudit: 2020\n*/\n\n/** @type LanguageFn */\nfunction shell(hljs) {\n  return {\n    name: \'Shell Session\',\n    aliases: [ \'console\', \'shellsession\' ],\n    contains: [\n      {\n        className: \'meta\',\n        // We cannot add \\s (spaces) in the regular expression otherwise it will be too broad and produce unexpected result.\n        // For instance, in the following example, it would match "echo /path/to/home >" as a prompt:\n        // echo /path/to/home > t.exe\n        begin: /^\\s{0,3}[/~\\w\\d[\\]()@-]*[>%$#][ ]?/,\n        starts: {\n          end: /[^\\\\](?=\\s*$)/,\n          subLanguage: \'bash\'\n        }\n      }\n    ]\n  };\n}\n\n/* harmony default export */ const languages_shell = (shell);\n\n;// CONCATENATED MODULE: ./node_modules/highlight.js/es/languages/plaintext.js\n/*\nLanguage: Plain text\nAuthor: Egor Rogov (e.rogov@postgrespro.ru)\nDescription: Plain text without any highlighting.\nCategory: common\n*/\n\nfunction plaintext(hljs) {\n  return {\n    name: \'Plain text\',\n    aliases: [\n      \'text\',\n      \'txt\'\n    ],\n    disableAutodetect: true\n  };\n}\n\n/* harmony default export */ const languages_plaintext = (plaintext);\n\n;// CONCATENATED MODULE: ./node_modules/highlight.js/es/languages/xml.js\n/**\n * @param {string} value\n * @returns {RegExp}\n * */\n\n/**\n * @param {RegExp | string } re\n * @returns {string}\n */\nfunction xml_source(re) {\n  if (!re) return null;\n  if (typeof re === "string") return re;\n\n  return re.source;\n}\n\n/**\n * @param {RegExp | string } re\n * @returns {string}\n */\nfunction xml_lookahead(re) {\n  return xml_concat(\'(?=\', re, \')\');\n}\n\n/**\n * @param {RegExp | string } re\n * @returns {string}\n */\nfunction optional(re) {\n  return xml_concat(\'(?:\', re, \')?\');\n}\n\n/**\n * @param {...(RegExp | string) } args\n * @returns {string}\n */\nfunction xml_concat(...args) {\n  const joined = args.map((x) => xml_source(x)).join("");\n  return joined;\n}\n\nfunction stripOptionsFromArgs(args) {\n  const opts = args[args.length - 1];\n\n  if (typeof opts === \'object\' && opts.constructor === Object) {\n    args.splice(args.length - 1, 1);\n    return opts;\n  } else {\n    return {};\n  }\n}\n\n/**\n * Any of the passed expresssions may match\n *\n * Creates a huge this | this | that | that match\n * @param {(RegExp | string)[] } args\n * @returns {string}\n */\nfunction either(...args) {\n  const opts = stripOptionsFromArgs(args);\n  const joined = \'(\' +\n    (opts.capture ? "" : "?:") +\n    args.map((x) => xml_source(x)).join("|") + ")";\n  return joined;\n}\n\n/*\nLanguage: HTML, XML\nWebsite: https://www.w3.org/XML/\nCategory: common, web\nAudit: 2020\n*/\n\n/** @type LanguageFn */\nfunction xml(hljs) {\n  // Element names can contain letters, digits, hyphens, underscores, and periods\n  const TAG_NAME_RE = xml_concat(/[A-Z_]/, optional(/[A-Z0-9_.-]*:/), /[A-Z0-9_.-]*/);\n  const XML_IDENT_RE = /[A-Za-z0-9._:-]+/;\n  const XML_ENTITIES = {\n    className: \'symbol\',\n    begin: /&[a-z]+;|&#[0-9]+;|&#x[a-f0-9]+;/\n  };\n  const XML_META_KEYWORDS = {\n    begin: /\\s/,\n    contains: [\n      {\n        className: \'keyword\',\n        begin: /#?[a-z_][a-z1-9_-]+/,\n        illegal: /\\n/\n      }\n    ]\n  };\n  const XML_META_PAR_KEYWORDS = hljs.inherit(XML_META_KEYWORDS, {\n    begin: /\\(/,\n    end: /\\)/\n  });\n  const APOS_META_STRING_MODE = hljs.inherit(hljs.APOS_STRING_MODE, {\n    className: \'string\'\n  });\n  const QUOTE_META_STRING_MODE = hljs.inherit(hljs.QUOTE_STRING_MODE, {\n    className: \'string\'\n  });\n  const TAG_INTERNALS = {\n    endsWithParent: true,\n    illegal: /</,\n    relevance: 0,\n    contains: [\n      {\n        className: \'attr\',\n        begin: XML_IDENT_RE,\n        relevance: 0\n      },\n      {\n        begin: /=\\s*/,\n        relevance: 0,\n        contains: [\n          {\n            className: \'string\',\n            endsParent: true,\n            variants: [\n              {\n                begin: /"/,\n                end: /"/,\n                contains: [ XML_ENTITIES ]\n              },\n              {\n                begin: /\'/,\n                end: /\'/,\n                contains: [ XML_ENTITIES ]\n              },\n              {\n                begin: /[^\\s"\'=<>`]+/\n              }\n            ]\n          }\n        ]\n      }\n    ]\n  };\n  return {\n    name: \'HTML, XML\',\n    aliases: [\n      \'html\',\n      \'xhtml\',\n      \'rss\',\n      \'atom\',\n      \'xjb\',\n      \'xsd\',\n      \'xsl\',\n      \'plist\',\n      \'wsf\',\n      \'svg\'\n    ],\n    case_insensitive: true,\n    contains: [\n      {\n        className: \'meta\',\n        begin: /<![a-z]/,\n        end: />/,\n        relevance: 10,\n        contains: [\n          XML_META_KEYWORDS,\n          QUOTE_META_STRING_MODE,\n          APOS_META_STRING_MODE,\n          XML_META_PAR_KEYWORDS,\n          {\n            begin: /\\[/,\n            end: /\\]/,\n            contains: [\n              {\n                className: \'meta\',\n                begin: /<![a-z]/,\n                end: />/,\n                contains: [\n                  XML_META_KEYWORDS,\n                  XML_META_PAR_KEYWORDS,\n                  QUOTE_META_STRING_MODE,\n                  APOS_META_STRING_MODE\n                ]\n              }\n            ]\n          }\n        ]\n      },\n      hljs.COMMENT(\n        /\x3c!--/,\n        /--\x3e/,\n        {\n          relevance: 10\n        }\n      ),\n      {\n        begin: /<!\\[CDATA\\[/,\n        end: /\\]\\]>/,\n        relevance: 10\n      },\n      XML_ENTITIES,\n      {\n        className: \'meta\',\n        begin: /<\\?xml/,\n        end: /\\?>/,\n        relevance: 10\n      },\n      {\n        className: \'tag\',\n        /*\n        The lookahead pattern (?=...) ensures that \'begin\' only matches\n        \'<style\' as a single word, followed by a whitespace or an\n        ending bracket.\n        */\n        begin: /<style(?=\\s|>)/,\n        end: />/,\n        keywords: {\n          name: \'style\'\n        },\n        contains: [ TAG_INTERNALS ],\n        starts: {\n          end: /<\\/style>/,\n          returnEnd: true,\n          subLanguage: [\n            \'css\',\n            \'xml\'\n          ]\n        }\n      },\n      {\n        className: \'tag\',\n        // See the comment in the <style tag about the lookahead pattern\n        begin: /<script(?=\\s|>)/,\n        end: />/,\n        keywords: {\n          name: \'script\'\n        },\n        contains: [ TAG_INTERNALS ],\n        starts: {\n          end: /<\\/script>/,\n          returnEnd: true,\n          subLanguage: [\n            \'javascript\',\n            \'handlebars\',\n            \'xml\'\n          ]\n        }\n      },\n      // we need this for now for jSX\n      {\n        className: \'tag\',\n        begin: /<>|<\\/>/\n      },\n      // open tag\n      {\n        className: \'tag\',\n        begin: xml_concat(\n          /</,\n          xml_lookahead(xml_concat(\n            TAG_NAME_RE,\n            // <tag/>\n            // <tag>\n            // <tag ...\n            either(/\\/>/, />/, /\\s/)\n          ))\n        ),\n        end: /\\/?>/,\n        contains: [\n          {\n            className: \'name\',\n            begin: TAG_NAME_RE,\n            relevance: 0,\n            starts: TAG_INTERNALS\n          }\n        ]\n      },\n      // close tag\n      {\n        className: \'tag\',\n        begin: xml_concat(\n          /<\\//,\n          xml_lookahead(xml_concat(\n            TAG_NAME_RE, />/\n          ))\n        ),\n        contains: [\n          {\n            className: \'name\',\n            begin: TAG_NAME_RE,\n            relevance: 0\n          },\n          {\n            begin: />/,\n            relevance: 0,\n            endsParent: true\n          }\n        ]\n      }\n    ]\n  };\n}\n\n/* harmony default export */ const languages_xml = (xml);\n\n;// CONCATENATED MODULE: ./docs/src/utils/highlight.js\n\n\n\n\n\n\nes_core.registerLanguage(\'javascript\', languages_javascript);\nes_core.registerLanguage(\'scss\', languages_scss);\nes_core.registerLanguage(\'shell\', languages_shell);\nes_core.registerLanguage(\'plaintext\', languages_plaintext);\nes_core.registerLanguage(\'xml\', languages_xml);\nfunction highlight(code, lang) {\n  var language = es_core.getLanguage(lang) ? lang : \'plaintext\';\n  return es_core.highlight(code, {\n    language: language\n  }).value;\n}\n;// CONCATENATED MODULE: ./docs/src/components/Code/index.jsx\n\n\n\n\nfunction Code(_ref) {\n  var lang = _ref.lang,\n      children = _ref.children;\n  var html = jsxToHtml(children);\n  return /*#__PURE__*/(0,jsx_runtime.jsx)("div", {\n    className: "code",\n    children: /*#__PURE__*/(0,jsx_runtime.jsx)("pre", {\n      className: "hljs language-".concat(lang),\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)("code", {\n        dangerouslySetInnerHTML: {\n          __html: highlight(html, \'jsx\')\n        }\n      })\n    })\n  });\n}\n;// CONCATENATED MODULE: ./docs/src/components/Demo/index.jsx\nfunction Demo_slicedToArray(arr, i) { return Demo_arrayWithHoles(arr) || Demo_iterableToArrayLimit(arr, i) || Demo_unsupportedIterableToArray(arr, i) || Demo_nonIterableRest(); }\n\nfunction Demo_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction Demo_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return Demo_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return Demo_arrayLikeToArray(o, minLen); }\n\nfunction Demo_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction Demo_iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction Demo_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\n\n\n\n\n\n\n\nfunction Demo(_ref) {\n  var _ref$title = _ref.title,\n      title = _ref$title === void 0 ? \'Demo\' : _ref$title,\n      description = _ref.description,\n      setup = _ref.setup,\n      settings = _ref.settings,\n      code = _ref.code,\n      _ref$children = _ref.children,\n      children = _ref$children === void 0 ? code : _ref$children;\n\n  var _useState = (0,react.useState)(true),\n      _useState2 = Demo_slicedToArray(_useState, 2),\n      isCodeOpen = _useState2[0],\n      setCodeOpen = _useState2[1];\n\n  var _useState3 = (0,react.useState)(false),\n      _useState4 = Demo_slicedToArray(_useState3, 2),\n      isSettingsOpen = _useState4[0],\n      setSettingsOpen = _useState4[1];\n\n  var classNames = classnames_default()(\'demo\', {\n    \'demo--with-settings\': settings\n  });\n  return /*#__PURE__*/(0,jsx_runtime.jsxs)(card_Card, {\n    element: "article",\n    className: classNames,\n    outlined: true,\n    children: [/*#__PURE__*/(0,jsx_runtime.jsx)(card_Card.Header, {\n      title: title,\n      actions: [/*#__PURE__*/(0,jsx_runtime.jsx)(icon_button_IconButton, {\n        icon: isCodeOpen ? \'code_off\' : \'code\',\n        title: isCodeOpen ? \'Hide code\' : \'Show code\',\n        onClick: function onClick() {\n          return setCodeOpen(function (v) {\n            return !v;\n          });\n        }\n      }, "code"), settings ? /*#__PURE__*/(0,jsx_runtime.jsx)(icon_button_IconButton, {\n        icon: "settings",\n        title: "\\u041D\\u0430\\u0441\\u0442\\u0440\\u043E\\u0439\\u043A\\u0438",\n        onClick: function onClick() {\n          return setSettingsOpen(true);\n        }\n      }, "settings") : null]\n    }), description && /*#__PURE__*/(0,jsx_runtime.jsx)(card_Card.Section, {\n      secondary: true,\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(typography_Typography, {\n        noMargin: true,\n        children: description\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsxs)(card_Card.Section, {\n      primary: true,\n      children: [setup, children]\n    }), isCodeOpen && /*#__PURE__*/(0,jsx_runtime.jsx)(card_Card.Section, {\n      secondary: true,\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(Code, {\n        lang: "jsx",\n        children: children\n      })\n    }), settings && /*#__PURE__*/(0,jsx_runtime.jsx)(side_sheet_SideSheet, {\n      title: "Settings",\n      open: isSettingsOpen // appear\n      ,\n      closeIcon: "close",\n      onClose: function onClose() {\n        return setSettingsOpen(false);\n      },\n      dismissible: true,\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(side_sheet_SideSheet.Content, {\n        children: settings\n      })\n    })]\n  });\n}\n;// CONCATENATED MODULE: ./docs/src/components/FieldSet/index.jsx\n\n\n\nfunction FieldSet(_ref) {\n  var legend = _ref.legend,\n      children = _ref.children;\n  return /*#__PURE__*/(0,jsx_runtime.jsxs)("fieldset", {\n    children: [/*#__PURE__*/(0,jsx_runtime.jsx)("legend", {\n      children: legend\n    }), children]\n  });\n}\n;// CONCATENATED MODULE: ./docs/src/components/Page/index.jsx\nvar Page_excluded = ["id", "title", "description", "links", "children"];\n\nfunction Page_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction Page_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { Page_ownKeys(Object(source), true).forEach(function (key) { Page_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { Page_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction Page_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction Page_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = Page_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction Page_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\nfunction Page(_ref) {\n  var id = _ref.id,\n      title = _ref.title,\n      description = _ref.description,\n      links = _ref.links,\n      children = _ref.children,\n      props = Page_objectWithoutProperties(_ref, Page_excluded);\n\n  return /*#__PURE__*/(0,jsx_runtime.jsxs)("article", Page_objectSpread(Page_objectSpread({\n    id: "".concat(id, "-page"),\n    className: "page"\n  }, props), {}, {\n    children: [title && /*#__PURE__*/(0,jsx_runtime.jsxs)("header", {\n      className: "page-header",\n      children: [/*#__PURE__*/(0,jsx_runtime.jsx)(typography_Typography, {\n        className: "page-title",\n        type: "headline4",\n        noMargin: true,\n        children: title\n      }), description && /*#__PURE__*/(0,jsx_runtime.jsx)(typography_Typography, {\n        className: "page-description",\n        type: "body1",\n        noMargin: true,\n        children: description\n      }), links && /*#__PURE__*/(0,jsx_runtime.jsxs)(list_List, {\n        children: [links.guide && /*#__PURE__*/(0,jsx_runtime.jsx)(list_List.Item, {\n          children: /*#__PURE__*/(0,jsx_runtime.jsx)("a", {\n            href: links.guide,\n            target: "_blank",\n            rel: "noreferrer",\n            children: "Guide"\n          })\n        }), links.docs && /*#__PURE__*/(0,jsx_runtime.jsx)(list_List.Item, {\n          children: /*#__PURE__*/(0,jsx_runtime.jsx)("a", {\n            href: links.docs,\n            target: "_blank",\n            rel: "noreferrer",\n            children: "Docs"\n          })\n        })]\n      })]\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)("div", {\n      className: "page-content",\n      children: children\n    })]\n  }));\n}\n;// CONCATENATED MODULE: ./docs/src/pages/Avatar/index.jsx\nfunction Avatar_slicedToArray(arr, i) { return Avatar_arrayWithHoles(arr) || Avatar_iterableToArrayLimit(arr, i) || Avatar_unsupportedIterableToArray(arr, i) || Avatar_nonIterableRest(); }\n\nfunction Avatar_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction Avatar_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return Avatar_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return Avatar_arrayLikeToArray(o, minLen); }\n\nfunction Avatar_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction Avatar_iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction Avatar_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\n\n\n\n\n\n\n\n\nvar id = \'avatar\';\nvar title = \'Avatar\';\nvar description = \'Avatars are found throughout material design with uses in everything from tables to dialog menus.\';\nfunction AvatarPage() {\n  var _useState = (0,react.useState)(\'medium\'),\n      _useState2 = Avatar_slicedToArray(_useState, 2),\n      size = _useState2[0],\n      setSize = _useState2[1];\n\n  var _useState3 = (0,react.useState)(\'image\'),\n      _useState4 = Avatar_slicedToArray(_useState3, 2),\n      content = _useState4[0],\n      setContent = _useState4[1];\n\n  return /*#__PURE__*/(0,jsx_runtime.jsx)(Page, {\n    id: id,\n    title: title,\n    description: description,\n    children: /*#__PURE__*/(0,jsx_runtime.jsx)(Demo, {\n      title: "Demo",\n      settings: /*#__PURE__*/(0,jsx_runtime.jsxs)(jsx_runtime.Fragment, {\n        children: [/*#__PURE__*/(0,jsx_runtime.jsx)(FieldSet, {\n          legend: "Content",\n          children: /*#__PURE__*/(0,jsx_runtime.jsx)(segmented_button_SegmentedButton, {\n            segments: [{\n              value: \'image\',\n              label: \'Image\'\n            }, {\n              value: \'icon\',\n              label: \'Icon\'\n            }, {\n              value: \'text\',\n              label: \'Text\'\n            }],\n            value: content,\n            onChange: setContent\n          })\n        }), /*#__PURE__*/(0,jsx_runtime.jsx)(FieldSet, {\n          legend: "Size",\n          children: /*#__PURE__*/(0,jsx_runtime.jsx)(segmented_button_SegmentedButton, {\n            segments: [{\n              value: \'small\',\n              label: \'Small\'\n            }, {\n              value: \'medium\',\n              label: \'Medium\'\n            }, {\n              value: \'large\',\n              label: \'Large\'\n            }],\n            value: size,\n            onChange: setSize\n          })\n        })]\n      }),\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(avatar_Avatar, {\n        image: content === \'image\' ? \'https://placeimg.com/128/128/people\' : undefined,\n        icon: content === \'icon\' ? \'star\' : undefined,\n        text: content === \'text\' ? \'MD\' : undefined,\n        size: size\n      })\n    })\n  });\n}\n;// CONCATENATED MODULE: ./docs/src/pages/Badge/index.jsx\nfunction Badge_slicedToArray(arr, i) { return Badge_arrayWithHoles(arr) || Badge_iterableToArrayLimit(arr, i) || Badge_unsupportedIterableToArray(arr, i) || Badge_nonIterableRest(); }\n\nfunction Badge_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction Badge_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return Badge_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return Badge_arrayLikeToArray(o, minLen); }\n\nfunction Badge_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction Badge_iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction Badge_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\n\n\n\n\n\n\nvar Badge_id = \'badge\';\nvar Badge_title = \'Badge\';\nvar Badge_description = \'Badge generates a small badge to the top-right of its child(ren).\';\nvar content = {\n  avatar: /*#__PURE__*/(0,jsx_runtime.jsx)(avatar_Avatar, {\n    text: "MD"\n  }),\n  button: /*#__PURE__*/(0,jsx_runtime.jsx)(button_Button, {\n    outlined: true,\n    children: "Button"\n  }),\n  icon: /*#__PURE__*/(0,jsx_runtime.jsx)(icon_Icon, {\n    children: "star"\n  }),\n  iconButton: /*#__PURE__*/(0,jsx_runtime.jsx)(icon_button_IconButton, {\n    icon: "star"\n  }),\n  text: \'Text\'\n};\nfunction BadgePage() {\n  var _useState = (0,react.useState)(0),\n      _useState2 = Badge_slicedToArray(_useState, 2),\n      value = _useState2[0],\n      setValue = _useState2[1];\n\n  var _useState3 = (0,react.useState)(\'avatar\'),\n      _useState4 = Badge_slicedToArray(_useState3, 2),\n      type = _useState4[0],\n      setType = _useState4[1];\n\n  var _useState5 = (0,react.useState)(false),\n      _useState6 = Badge_slicedToArray(_useState5, 2),\n      inset = _useState6[0],\n      setInset = _useState6[1];\n\n  var _useState7 = (0,react.useState)(false),\n      _useState8 = Badge_slicedToArray(_useState7, 2),\n      transparent = _useState8[0],\n      setTransparent = _useState8[1];\n\n  return /*#__PURE__*/(0,jsx_runtime.jsx)(Page, {\n    id: Badge_id,\n    title: Badge_title,\n    description: Badge_description,\n    children: /*#__PURE__*/(0,jsx_runtime.jsx)(Demo, {\n      settings: [/*#__PURE__*/(0,jsx_runtime.jsx)(text_field_TextField, {\n        value: value,\n        label: "Value",\n        outlined: true,\n        onChange: function onChange(_, value) {\n          return setValue(value);\n        }\n      }, "value"), /*#__PURE__*/(0,jsx_runtime.jsx)(FieldSet, {\n        legend: "Content",\n        children: /*#__PURE__*/(0,jsx_runtime.jsx)(segmented_button_SegmentedButton, {\n          segments: [{\n            value: \'avatar\',\n            label: \'Avatar\'\n          }, {\n            value: \'button\',\n            label: \'Button\'\n          }, {\n            value: \'icon\',\n            label: \'Icon\'\n          }, {\n            value: \'iconButton\',\n            label: \'Icon Button\'\n          }, {\n            value: \'text\',\n            label: \'Text\'\n          }],\n          value: type,\n          onChange: setType\n        })\n      }, "content"), /*#__PURE__*/(0,jsx_runtime.jsx)(form_field_FormField, {\n        label: "Inset",\n        alignEnd: true,\n        spaceBetween: true,\n        children: /*#__PURE__*/(0,jsx_runtime.jsx)(switch_Switch, {\n          selected: inset,\n          onChange: function onChange() {\n            return setInset(function (v) {\n              return !v;\n            });\n          }\n        })\n      }, "inset"), /*#__PURE__*/(0,jsx_runtime.jsx)(form_field_FormField, {\n        label: "Transparent",\n        alignEnd: true,\n        spaceBetween: true,\n        children: /*#__PURE__*/(0,jsx_runtime.jsx)(switch_Switch, {\n          selected: transparent,\n          onChange: function onChange() {\n            return setTransparent(function (v) {\n              return !v;\n            });\n          }\n        })\n      }, "transparent")],\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(badge_Badge, {\n        value: value,\n        inset: inset || undefined,\n        transparent: transparent || undefined,\n        children: content[type]\n      })\n    })\n  });\n}\n;// CONCATENATED MODULE: ./docs/src/pages/Banner/index.jsx\nfunction Banner_slicedToArray(arr, i) { return Banner_arrayWithHoles(arr) || Banner_iterableToArrayLimit(arr, i) || Banner_unsupportedIterableToArray(arr, i) || Banner_nonIterableRest(); }\n\nfunction Banner_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction Banner_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return Banner_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return Banner_arrayLikeToArray(o, minLen); }\n\nfunction Banner_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction Banner_iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction Banner_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\n\n\n\n\n\n\n\n\nvar Banner_id = \'banner\';\nvar Banner_title = \'Banner\';\nvar Banner_description = \'A banner displays a prominent message and related optional actions.\';\nvar links = {\n  docs: \'https://github.com/material-components/material-components-web/tree/master/packages/mdc-banner\',\n  guide: \'https://material.io/components/banners\'\n};\nfunction Banner_BadgePage() {\n  var _useState = (0,react.useState)(false),\n      _useState2 = Banner_slicedToArray(_useState, 2),\n      open = _useState2[0],\n      setOpen = _useState2[1];\n\n  var _useState3 = (0,react.useState)(\'Lorem ipsum\'),\n      _useState4 = Banner_slicedToArray(_useState3, 2),\n      text = _useState4[0],\n      setText = _useState4[1];\n\n  var _useState5 = (0,react.useState)(false),\n      _useState6 = Banner_slicedToArray(_useState5, 2),\n      hasIcon = _useState6[0],\n      setHasIcon = _useState6[1];\n\n  var _useState7 = (0,react.useState)(\'\'),\n      _useState8 = Banner_slicedToArray(_useState7, 2),\n      icon = _useState8[0],\n      setIcon = _useState8[1];\n\n  var _useState9 = (0,react.useState)(false),\n      _useState10 = Banner_slicedToArray(_useState9, 2),\n      hasAction = _useState10[0],\n      setHasAction = _useState10[1];\n\n  var _useState11 = (0,react.useState)(\'\'),\n      _useState12 = Banner_slicedToArray(_useState11, 2),\n      action = _useState12[0],\n      setAction = _useState12[1];\n\n  var _useState13 = (0,react.useState)(false),\n      _useState14 = Banner_slicedToArray(_useState13, 2),\n      hasSecondaryAction = _useState14[0],\n      setHasSecondaryAction = _useState14[1];\n\n  var _useState15 = (0,react.useState)(\'\'),\n      _useState16 = Banner_slicedToArray(_useState15, 2),\n      secondaryAction = _useState16[0],\n      setSecondaryAction = _useState16[1];\n\n  var _useState17 = (0,react.useState)(false),\n      _useState18 = Banner_slicedToArray(_useState17, 2),\n      centered = _useState18[0],\n      setCentered = _useState18[1];\n\n  var _useState19 = (0,react.useState)(false),\n      _useState20 = Banner_slicedToArray(_useState19, 2),\n      fixed = _useState20[0],\n      setFixed = _useState20[1];\n\n  var _useState21 = (0,react.useState)(false),\n      _useState22 = Banner_slicedToArray(_useState21, 2),\n      mobileStacked = _useState22[0],\n      setMobileStacked = _useState22[1];\n\n  return /*#__PURE__*/(0,jsx_runtime.jsx)(Page, {\n    id: Banner_id,\n    title: Banner_title,\n    description: Banner_description,\n    links: links,\n    children: /*#__PURE__*/(0,jsx_runtime.jsx)(Demo, {\n      title: "Demo",\n      setup: /*#__PURE__*/(0,jsx_runtime.jsx)(top_app_bar_TopAppBar, {\n        title: "Title",\n        actionItems: /*#__PURE__*/(0,jsx_runtime.jsx)(button_Button, {\n          label: "Toggle",\n          onClick: function onClick() {\n            return setOpen(function (v) {\n              return !v;\n            });\n          }\n        })\n      }),\n      settings: /*#__PURE__*/(0,jsx_runtime.jsxs)(jsx_runtime.Fragment, {\n        children: [/*#__PURE__*/(0,jsx_runtime.jsx)(text_field_TextField, {\n          value: text,\n          label: "Text",\n          onChange: function onChange(_, value) {\n            return setText(value);\n          },\n          outlined: true\n        }), /*#__PURE__*/(0,jsx_runtime.jsx)(text_field_TextField, {\n          value: icon,\n          label: "Icon",\n          trailingIcon: /*#__PURE__*/(0,jsx_runtime.jsx)(switch_Switch, {\n            selected: hasIcon,\n            onChange: function onChange() {\n              return setHasIcon(function (v) {\n                return !v;\n              });\n            }\n          }),\n          outlined: true,\n          disabled: !hasIcon,\n          onChange: function onChange(_, value) {\n            return setIcon(value);\n          }\n        }), /*#__PURE__*/(0,jsx_runtime.jsx)(text_field_TextField, {\n          value: action,\n          label: "Action",\n          trailingIcon: /*#__PURE__*/(0,jsx_runtime.jsx)(switch_Switch, {\n            selected: hasAction,\n            onChange: function onChange() {\n              return setHasAction(function (v) {\n                return !v;\n              });\n            }\n          }),\n          disabled: !hasAction,\n          outlined: true,\n          onChange: function onChange(_, value) {\n            return setAction(value);\n          }\n        }), /*#__PURE__*/(0,jsx_runtime.jsx)(text_field_TextField, {\n          value: secondaryAction,\n          label: "Secondary action",\n          trailingIcon: /*#__PURE__*/(0,jsx_runtime.jsx)(switch_Switch, {\n            selected: hasSecondaryAction,\n            onChange: function onChange() {\n              return setHasSecondaryAction(function (v) {\n                return !v;\n              });\n            }\n          }),\n          disabled: !hasSecondaryAction,\n          outlined: true,\n          onChange: function onChange(_, value) {\n            return setSecondaryAction(value);\n          }\n        }), /*#__PURE__*/(0,jsx_runtime.jsx)(form_field_FormField, {\n          label: "Centered",\n          alignEnd: true,\n          spaceBetween: true,\n          children: /*#__PURE__*/(0,jsx_runtime.jsx)(switch_Switch, {\n            selected: centered,\n            onChange: function onChange() {\n              return setCentered(function (v) {\n                return !v;\n              });\n            }\n          })\n        }), /*#__PURE__*/(0,jsx_runtime.jsx)(form_field_FormField, {\n          label: "Fixed",\n          alignEnd: true,\n          spaceBetween: true,\n          children: /*#__PURE__*/(0,jsx_runtime.jsx)(switch_Switch, {\n            selected: fixed,\n            onChange: function onChange() {\n              return setFixed(function (v) {\n                return !v;\n              });\n            }\n          })\n        }), /*#__PURE__*/(0,jsx_runtime.jsx)(form_field_FormField, {\n          label: "Mobile stacked",\n          alignEnd: true,\n          spaceBetween: true,\n          children: /*#__PURE__*/(0,jsx_runtime.jsx)(switch_Switch, {\n            selected: mobileStacked,\n            onChange: function onChange() {\n              return setMobileStacked(function (v) {\n                return !v;\n              });\n            }\n          })\n        })]\n      }),\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(banner_Banner, {\n        text: text,\n        icon: hasIcon ? icon : undefined,\n        action: hasAction ? /*#__PURE__*/(0,jsx_runtime.jsx)(button_Button, {\n          children: action\n        }) : undefined,\n        secondaryAction: hasSecondaryAction ? /*#__PURE__*/(0,jsx_runtime.jsx)(button_Button, {\n          children: secondaryAction\n        }) : undefined,\n        open: open || undefined,\n        centered: centered || undefined,\n        fixed: fixed || undefined,\n        mobileStacked: mobileStacked || undefined\n      })\n    })\n  });\n}\n;// CONCATENATED MODULE: ./docs/src/pages/Button/index.jsx\nfunction Button_slicedToArray(arr, i) { return Button_arrayWithHoles(arr) || Button_iterableToArrayLimit(arr, i) || Button_unsupportedIterableToArray(arr, i) || Button_nonIterableRest(); }\n\nfunction Button_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction Button_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return Button_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return Button_arrayLikeToArray(o, minLen); }\n\nfunction Button_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction Button_iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction Button_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\n\n\n\n\n\n\n\n\nvar Button_id = \'button\';\nvar Button_title = \'Button\';\nvar Button_description = \'Buttons communicate an action a user can take. They are typically placed throughout your UI, in places like dialogs, forms, cards, and toolbars.\';\nvar Button_links = {\n  docs: \'https://github.com/material-components/material-components-web/tree/master/packages/mdc-button\',\n  guide: \'https://material.io/components/buttons\'\n};\nfunction ButtonPage() {\n  var _useState = (0,react.useState)(\'Button\'),\n      _useState2 = Button_slicedToArray(_useState, 2),\n      label = _useState2[0],\n      setLabel = _useState2[1];\n\n  var _useState3 = (0,react.useState)(false),\n      _useState4 = Button_slicedToArray(_useState3, 2),\n      hasLeadingIcon = _useState4[0],\n      setHasLeadingIcon = _useState4[1];\n\n  var _useState5 = (0,react.useState)(\'save\'),\n      _useState6 = Button_slicedToArray(_useState5, 2),\n      leadingIcon = _useState6[0],\n      setLeadingIcon = _useState6[1];\n\n  var _useState7 = (0,react.useState)(false),\n      _useState8 = Button_slicedToArray(_useState7, 2),\n      hasTrailingIcon = _useState8[0],\n      setHasTrailingIcon = _useState8[1];\n\n  var _useState9 = (0,react.useState)(\'close\'),\n      _useState10 = Button_slicedToArray(_useState9, 2),\n      trailingIcon = _useState10[0],\n      setTrailingIcon = _useState10[1];\n\n  var _useState11 = (0,react.useState)(\'plain\'),\n      _useState12 = Button_slicedToArray(_useState11, 2),\n      type = _useState12[0],\n      setType = _useState12[1];\n\n  return /*#__PURE__*/(0,jsx_runtime.jsx)(Page, {\n    id: Button_id,\n    title: Button_title,\n    description: Button_description,\n    links: Button_links,\n    children: /*#__PURE__*/(0,jsx_runtime.jsx)(Demo, {\n      title: "Demo",\n      settings: /*#__PURE__*/(0,jsx_runtime.jsxs)(jsx_runtime.Fragment, {\n        children: [/*#__PURE__*/(0,jsx_runtime.jsx)(text_field_TextField, {\n          value: label,\n          label: "Label",\n          outlined: true,\n          onChange: function onChange(_, value) {\n            return setLabel(value);\n          }\n        }), /*#__PURE__*/(0,jsx_runtime.jsx)(text_field_TextField, {\n          value: leadingIcon,\n          label: "Leading icon",\n          trailingIcon: /*#__PURE__*/(0,jsx_runtime.jsx)(switch_Switch, {\n            selected: hasLeadingIcon,\n            onChange: function onChange() {\n              return setHasLeadingIcon(function (v) {\n                return !v;\n              });\n            }\n          }),\n          outlined: true,\n          disabled: !hasLeadingIcon,\n          onChange: function onChange(_, value) {\n            return setLeadingIcon(value);\n          }\n        }), /*#__PURE__*/(0,jsx_runtime.jsx)(text_field_TextField, {\n          value: trailingIcon,\n          label: "Trailing icon",\n          trailingIcon: /*#__PURE__*/(0,jsx_runtime.jsx)(switch_Switch, {\n            selected: hasTrailingIcon,\n            onChange: function onChange() {\n              return setHasTrailingIcon(function (v) {\n                return !v;\n              });\n            }\n          }),\n          outlined: true,\n          disabled: !hasTrailingIcon,\n          onChange: function onChange(_, value) {\n            return setTrailingIcon(value);\n          }\n        }), /*#__PURE__*/(0,jsx_runtime.jsx)(FieldSet, {\n          legend: "Type",\n          children: /*#__PURE__*/(0,jsx_runtime.jsx)(segmented_button_SegmentedButton, {\n            segments: [{\n              value: \'plain\',\n              label: \'Plain\'\n            }, {\n              value: \'outlined\',\n              label: \'Outlined\'\n            }, {\n              value: \'unelevated\',\n              label: \'Unelevated\'\n            }, {\n              value: \'raised\',\n              label: \'Raised\'\n            }],\n            value: type,\n            onChange: setType\n          })\n        })]\n      }),\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(button_Button, {\n        leadingIcon: hasLeadingIcon ? leadingIcon : undefined,\n        trailingIcon: hasTrailingIcon ? trailingIcon : undefined,\n        outlined: type === \'outlined\' || undefined,\n        unelevated: type === \'unelevated\' || undefined,\n        raised: type === \'raised\' || undefined,\n        children: label\n      })\n    })\n  });\n}\n;// CONCATENATED MODULE: ./docs/src/pages/Card/index.jsx\nfunction Card_slicedToArray(arr, i) { return Card_arrayWithHoles(arr) || Card_iterableToArrayLimit(arr, i) || Card_unsupportedIterableToArray(arr, i) || Card_nonIterableRest(); }\n\nfunction Card_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction Card_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return Card_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return Card_arrayLikeToArray(o, minLen); }\n\nfunction Card_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction Card_iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction Card_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\n\n\n\n\n\n\n\nvar Card_id = \'card\';\nvar pageTitle = \'Card\';\nvar Card_description = \'Cards contain content and actions about a single subject.\';\nvar Card_links = {\n  docs: \'https://github.com/material-components/material-components-web/tree/master/packages/mdc-card\',\n  guide: \'https://material.io/components/cards\'\n};\n\'\';\nfunction CardPage() {\n  var _useState = (0,react.useState)(true),\n      _useState2 = Card_slicedToArray(_useState, 2),\n      hasTitle = _useState2[0],\n      setHasTitle = _useState2[1];\n\n  var _useState3 = (0,react.useState)(\'Title\'),\n      _useState4 = Card_slicedToArray(_useState3, 2),\n      title = _useState4[0],\n      setTitle = _useState4[1];\n\n  var _useState5 = (0,react.useState)(true),\n      _useState6 = Card_slicedToArray(_useState5, 2),\n      hasSubtitle = _useState6[0],\n      setHasSubtitle = _useState6[1];\n\n  var _useState7 = (0,react.useState)(\'Subtitle\'),\n      _useState8 = Card_slicedToArray(_useState7, 2),\n      subtitle = _useState8[0],\n      setSubtitle = _useState8[1];\n\n  return /*#__PURE__*/(0,jsx_runtime.jsx)(Page, {\n    id: Card_id,\n    title: pageTitle,\n    description: Card_description,\n    links: Card_links,\n    children: /*#__PURE__*/(0,jsx_runtime.jsx)(Demo, {\n      settings: /*#__PURE__*/(0,jsx_runtime.jsxs)(jsx_runtime.Fragment, {\n        children: [/*#__PURE__*/(0,jsx_runtime.jsx)(text_field_TextField, {\n          value: title,\n          label: "Title",\n          trailingIcon: /*#__PURE__*/(0,jsx_runtime.jsx)(switch_Switch, {\n            selected: hasTitle,\n            onChange: function onChange() {\n              return setHasTitle(function (v) {\n                return !v;\n              });\n            }\n          }),\n          outlined: true,\n          disabled: !hasTitle,\n          onChange: function onChange(_, value) {\n            return setTitle(value);\n          }\n        }), /*#__PURE__*/(0,jsx_runtime.jsx)(text_field_TextField, {\n          value: subtitle,\n          label: "Subtitle",\n          trailingIcon: /*#__PURE__*/(0,jsx_runtime.jsx)(switch_Switch, {\n            selected: hasSubtitle,\n            onChange: function onChange() {\n              return setHasSubtitle(function (v) {\n                return !v;\n              });\n            }\n          }),\n          outlined: true,\n          disabled: !hasSubtitle,\n          onChange: function onChange(_, value) {\n            return setSubtitle(value);\n          }\n        })]\n      }),\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(card_Card, {\n        children: /*#__PURE__*/(0,jsx_runtime.jsx)(card_Card.Header, {\n          overline: "Overline",\n          title: hasTitle ? title : undefined,\n          subtitle: hasSubtitle ? subtitle : undefined\n        })\n      })\n    })\n  });\n}\n;// CONCATENATED MODULE: ./docs/src/pages/Checkbox/index.jsx\nfunction Checkbox_slicedToArray(arr, i) { return Checkbox_arrayWithHoles(arr) || Checkbox_iterableToArrayLimit(arr, i) || Checkbox_unsupportedIterableToArray(arr, i) || Checkbox_nonIterableRest(); }\n\nfunction Checkbox_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction Checkbox_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return Checkbox_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return Checkbox_arrayLikeToArray(o, minLen); }\n\nfunction Checkbox_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction Checkbox_iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction Checkbox_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\n\n\n\n\n\nvar Checkbox_id = \'checkbox\';\nvar Checkbox_title = \'Checkbox\';\nvar Checkbox_description = \'Checkboxes allow the user to select multiple options from a set.\';\nvar Checkbox_links = {\n  docs: \'https://github.com/material-components/material-components-web/tree/master/packages/mdc-checkbox\',\n  guide: \'https://material.io/components/checkboxes\'\n};\nfunction CheckboxPage() {\n  var _useState = (0,react.useState)(false),\n      _useState2 = Checkbox_slicedToArray(_useState, 2),\n      checked = _useState2[0],\n      setChecked = _useState2[1];\n\n  var _useState3 = (0,react.useState)(false),\n      _useState4 = Checkbox_slicedToArray(_useState3, 2),\n      controlled = _useState4[0],\n      setControlled = _useState4[1];\n\n  var _useState5 = (0,react.useState)(false),\n      _useState6 = Checkbox_slicedToArray(_useState5, 2),\n      indeterminate = _useState6[0],\n      setIndeterminate = _useState6[1];\n\n  var _useState7 = (0,react.useState)(false),\n      _useState8 = Checkbox_slicedToArray(_useState7, 2),\n      disabled = _useState8[0],\n      setDisabled = _useState8[1];\n\n  return /*#__PURE__*/(0,jsx_runtime.jsx)(Page, {\n    id: Checkbox_id,\n    title: Checkbox_title,\n    description: Checkbox_description,\n    links: Checkbox_links,\n    children: /*#__PURE__*/(0,jsx_runtime.jsx)(Demo, {\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(checkbox_Checkbox, {\n        checked: checked,\n        defaultChecked: false,\n        indeterminate: indeterminate,\n        disabled: disabled,\n        onChange: function onChange() {\n          return setChecked(function (v) {\n            return !v;\n          });\n        }\n      })\n    })\n  });\n}\n;// CONCATENATED MODULE: ./docs/src/pages/Chips/index.jsx\nfunction Chips_slicedToArray(arr, i) { return Chips_arrayWithHoles(arr) || Chips_iterableToArrayLimit(arr, i) || Chips_unsupportedIterableToArray(arr, i) || Chips_nonIterableRest(); }\n\nfunction Chips_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction Chips_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return Chips_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return Chips_arrayLikeToArray(o, minLen); }\n\nfunction Chips_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction Chips_iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction Chips_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\n\n\n\n\n\n\nvar Chips_id = \'chips\';\nvar Chips_title = \'Chips\';\nvar Chips_description = \'Chips are compact elements that allow users to enter information, select a choice, filter content, or trigger an action.\';\nvar Chips_links = {\n  docs: \'https://github.com/material-components/material-components-web/tree/master/packages/mdc-chips\',\n  guide: \'https://material.io/components/chips\'\n};\nfunction ChipsPage() {\n  var _useState = (0,react.useState)(\'foo\'),\n      _useState2 = Chips_slicedToArray(_useState, 2),\n      choiceChip = _useState2[0],\n      setChoiceChips = _useState2[1];\n\n  var _useState3 = (0,react.useState)([\'foo\']),\n      _useState4 = Chips_slicedToArray(_useState3, 2),\n      filterChips = _useState4[0],\n      setFilterChips = _useState4[1];\n\n  return /*#__PURE__*/(0,jsx_runtime.jsxs)(Page, {\n    id: Chips_id,\n    title: Chips_title,\n    description: Chips_description,\n    links: Chips_links,\n    children: [/*#__PURE__*/(0,jsx_runtime.jsx)(Demo, {\n      title: "Basic chips",\n      children: /*#__PURE__*/(0,jsx_runtime.jsxs)(chips_ChipSet, {\n        children: [/*#__PURE__*/(0,jsx_runtime.jsx)(chips_Chip, {\n          text: "Foo"\n        }), /*#__PURE__*/(0,jsx_runtime.jsx)(chips_Chip, {\n          text: "Bar"\n        }), /*#__PURE__*/(0,jsx_runtime.jsx)(chips_Chip, {\n          text: "Baz"\n        })]\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Demo, {\n      title: "Chips with icons",\n      children: /*#__PURE__*/(0,jsx_runtime.jsxs)(chips_ChipSet, {\n        children: [/*#__PURE__*/(0,jsx_runtime.jsx)(chips_Chip, {\n          text: "Foo",\n          icon: "star"\n        }), /*#__PURE__*/(0,jsx_runtime.jsx)(chips_Chip, {\n          text: "Bar",\n          icon: "star"\n        }), /*#__PURE__*/(0,jsx_runtime.jsx)(chips_Chip, {\n          text: "Baz",\n          icon: "star"\n        })]\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Demo, {\n      title: "Chips with trailing icons",\n      children: /*#__PURE__*/(0,jsx_runtime.jsxs)(chips_ChipSet, {\n        children: [/*#__PURE__*/(0,jsx_runtime.jsx)(chips_Chip, {\n          text: "Foo",\n          trailingIcon: "delete"\n        }), /*#__PURE__*/(0,jsx_runtime.jsx)(chips_Chip, {\n          text: "Bar",\n          trailingIcon: "delete"\n        }), /*#__PURE__*/(0,jsx_runtime.jsx)(chips_Chip, {\n          text: "Baz",\n          trailingIcon: "delete"\n        })]\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Demo, {\n      title: "Chips with avatars",\n      children: /*#__PURE__*/(0,jsx_runtime.jsxs)(chips_ChipSet, {\n        children: [/*#__PURE__*/(0,jsx_runtime.jsx)(chips_Chip, {\n          text: "Foo",\n          avatar: /*#__PURE__*/(0,jsx_runtime.jsx)(avatar_Avatar, {\n            image: "https://placeimg.com/128/128/people",\n            small: true\n          })\n        }), /*#__PURE__*/(0,jsx_runtime.jsx)(chips_Chip, {\n          text: "Bar",\n          avatar: /*#__PURE__*/(0,jsx_runtime.jsx)(avatar_Avatar, {\n            image: "https://placeimg.com/128/128/people",\n            small: true\n          })\n        }), /*#__PURE__*/(0,jsx_runtime.jsx)(chips_Chip, {\n          text: "Baz",\n          avatar: /*#__PURE__*/(0,jsx_runtime.jsx)(avatar_Avatar, {\n            image: "https://placeimg.com/128/128/people",\n            small: true\n          })\n        })]\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Demo, {\n      title: "Choice chips",\n      children: /*#__PURE__*/(0,jsx_runtime.jsxs)(chips_ChipSet, {\n        value: choiceChip,\n        onChange: function onChange(value) {\n          return setChoiceChips(value);\n        },\n        children: [/*#__PURE__*/(0,jsx_runtime.jsx)(chips_Chip, {\n          value: "foo",\n          text: "Foo"\n        }), /*#__PURE__*/(0,jsx_runtime.jsx)(chips_Chip, {\n          value: "bar",\n          text: "Bar"\n        }), /*#__PURE__*/(0,jsx_runtime.jsx)(chips_Chip, {\n          value: "baz",\n          text: "Baz"\n        })]\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Demo, {\n      title: "Filter chips",\n      children: /*#__PURE__*/(0,jsx_runtime.jsxs)(chips_ChipSet, {\n        value: filterChips,\n        onChange: function onChange(value) {\n          return setFilterChips(value);\n        },\n        children: [/*#__PURE__*/(0,jsx_runtime.jsx)(chips_Chip, {\n          value: "foo",\n          text: "Foo"\n        }), /*#__PURE__*/(0,jsx_runtime.jsx)(chips_Chip, {\n          value: "bar",\n          text: "Bar"\n        }), /*#__PURE__*/(0,jsx_runtime.jsx)(chips_Chip, {\n          value: "baz",\n          text: "Baz"\n        })]\n      })\n    })]\n  });\n}\n;// CONCATENATED MODULE: ./docs/src/pages/CircularProgress/index.jsx\nfunction CircularProgress_slicedToArray(arr, i) { return CircularProgress_arrayWithHoles(arr) || CircularProgress_iterableToArrayLimit(arr, i) || CircularProgress_unsupportedIterableToArray(arr, i) || CircularProgress_nonIterableRest(); }\n\nfunction CircularProgress_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction CircularProgress_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return CircularProgress_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return CircularProgress_arrayLikeToArray(o, minLen); }\n\nfunction CircularProgress_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction CircularProgress_iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction CircularProgress_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\n\n\n\n\n\n\n\n\nvar CircularProgress_id = \'circular-progress\';\nvar CircularProgress_title = \'Circular Progress\';\nvar CircularProgress_description = \'Circular progress indicators display progress by animating an indicator along an invisible circular track in a clockwise direction.\';\nvar CircularProgress_links = {\n  docs: \'https://github.com/material-components/material-components-web/tree/master/packages/mdc-circular-progress\',\n  guide: \'https://material.io/components/progress-indicators#circular-progress-indicators\'\n};\nfunction CircularProgressPage() {\n  var _useState = (0,react.useState)(42),\n      _useState2 = CircularProgress_slicedToArray(_useState, 2),\n      value = _useState2[0],\n      setValue = _useState2[1];\n\n  var _useState3 = (0,react.useState)(\'medium\'),\n      _useState4 = CircularProgress_slicedToArray(_useState3, 2),\n      size = _useState4[0],\n      setSize = _useState4[1];\n\n  var _useState5 = (0,react.useState)(false),\n      _useState6 = CircularProgress_slicedToArray(_useState5, 2),\n      indeterminate = _useState6[0],\n      setIndeterminate = _useState6[1];\n\n  var _useState7 = (0,react.useState)(false),\n      _useState8 = CircularProgress_slicedToArray(_useState7, 2),\n      colorful = _useState8[0],\n      setColorful = _useState8[1];\n\n  var _useState9 = (0,react.useState)(false),\n      _useState10 = CircularProgress_slicedToArray(_useState9, 2),\n      closed = _useState10[0],\n      setClosed = _useState10[1];\n\n  return /*#__PURE__*/(0,jsx_runtime.jsx)(Page, {\n    id: CircularProgress_id,\n    title: CircularProgress_title,\n    description: CircularProgress_description,\n    links: CircularProgress_links,\n    children: /*#__PURE__*/(0,jsx_runtime.jsx)(Demo, {\n      settings: /*#__PURE__*/(0,jsx_runtime.jsxs)(jsx_runtime.Fragment, {\n        children: [/*#__PURE__*/(0,jsx_runtime.jsx)(text_field_TextField, {\n          value: value,\n          label: "Value",\n          outlined: true,\n          onChange: function onChange(_, value) {\n            return setValue(value);\n          }\n        }), /*#__PURE__*/(0,jsx_runtime.jsx)(FieldSet, {\n          legend: "Size",\n          children: /*#__PURE__*/(0,jsx_runtime.jsx)(segmented_button_SegmentedButton, {\n            segments: [{\n              value: \'small\',\n              label: \'Small\'\n            }, {\n              value: \'medium\',\n              label: \'Medium\'\n            }, {\n              value: \'large\',\n              label: \'Large\'\n            }],\n            value: size,\n            onChange: setSize\n          })\n        }), /*#__PURE__*/(0,jsx_runtime.jsx)(form_field_FormField, {\n          label: "Indeterminate",\n          alignEnd: true,\n          spaceBetween: true,\n          children: /*#__PURE__*/(0,jsx_runtime.jsx)(switch_Switch, {\n            selected: indeterminate,\n            onChange: function onChange() {\n              return setIndeterminate(function (v) {\n                return !v;\n              });\n            }\n          })\n        }), /*#__PURE__*/(0,jsx_runtime.jsx)(form_field_FormField, {\n          label: "Colorful",\n          alignEnd: true,\n          spaceBetween: true,\n          children: /*#__PURE__*/(0,jsx_runtime.jsx)(switch_Switch, {\n            selected: colorful,\n            onChange: function onChange() {\n              return setColorful(function (v) {\n                return !v;\n              });\n            }\n          })\n        }), /*#__PURE__*/(0,jsx_runtime.jsx)(form_field_FormField, {\n          label: "Closed",\n          alignEnd: true,\n          spaceBetween: true,\n          children: /*#__PURE__*/(0,jsx_runtime.jsx)(switch_Switch, {\n            selected: closed,\n            onChange: function onChange() {\n              return setClosed(function (v) {\n                return !v;\n              });\n            }\n          })\n        })]\n      }),\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(circular_progress_CircularProgress, {\n        value: indeterminate ? undefined : value,\n        size: size,\n        indeterminate: indeterminate || undefined,\n        colorful: colorful || undefined,\n        closed: closed || undefined\n      })\n    })\n  });\n}\n;// CONCATENATED MODULE: ./docs/src/pages/DataTable/index.jsx\nfunction DataTable_slicedToArray(arr, i) { return DataTable_arrayWithHoles(arr) || DataTable_iterableToArrayLimit(arr, i) || DataTable_unsupportedIterableToArray(arr, i) || DataTable_nonIterableRest(); }\n\nfunction DataTable_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction DataTable_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return DataTable_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return DataTable_arrayLikeToArray(o, minLen); }\n\nfunction DataTable_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction DataTable_iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction DataTable_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\n\n\n\n\n\n\nvar DataTable_id = \'data-table\';\nvar DataTable_title = \'Data Table\';\nvar DataTable_description = \'Data tables display sets of data across rows and columns.\';\nvar DataTable_links = {\n  docs: \'https://github.com/material-components/material-components-web/tree/master/packages/mdc-data-table\',\n  guide: \'https://material.io/components/data-tables\'\n};\nvar table = [[\'Frozen yogurt\', 24, 4.0, \'Super tasty\'], [\'Ice cream sandwich\', 37, 4.33333333333, \'I like ice cream more\'], [\'Eclair\', 24, 6.0, \'New filing flavor\']];\nfunction DataTablePage() {\n  var _useState = (0,react.useState)(table),\n      _useState2 = DataTable_slicedToArray(_useState, 2),\n      data = _useState2[0],\n      setData = _useState2[1];\n\n  var _useState3 = (0,react.useState)(0),\n      _useState4 = DataTable_slicedToArray(_useState3, 2),\n      sort = _useState4[0],\n      setSort = _useState4[1];\n\n  var handleSort = (0,react.useCallback)(function () {\n    setSort(function (sort) {\n      if (sort === -1) {\n        setData(function (data) {\n          return data.slice().sort(function (a, b) {\n            return a[1] - b[1];\n          });\n        });\n        setSort(1);\n      } else {\n        setData(function (data) {\n          return data.slice().sort(function (a, b) {\n            return b[1] - a[1];\n          });\n        });\n        setSort(-1);\n      }\n    });\n  }, []);\n  return /*#__PURE__*/(0,jsx_runtime.jsx)(Page, {\n    id: DataTable_id,\n    title: DataTable_title,\n    description: DataTable_description,\n    links: DataTable_links,\n    children: /*#__PURE__*/(0,jsx_runtime.jsx)(Demo, {\n      title: "Sortable data table",\n      children: /*#__PURE__*/(0,jsx_runtime.jsxs)(data_table_DataTable, {\n        children: [/*#__PURE__*/(0,jsx_runtime.jsx)(data_table_DataTable.Header, {\n          children: /*#__PURE__*/(0,jsx_runtime.jsxs)(data_table_DataTable.HeaderRow, {\n            children: [/*#__PURE__*/(0,jsx_runtime.jsx)(data_table_DataTable.HeaderCell, {\n              children: "Dessert"\n            }), /*#__PURE__*/(0,jsx_runtime.jsx)(data_table_DataTable.HeaderCell, {\n              numeric: true,\n              sort: sort,\n              onSort: handleSort,\n              children: "Carbs (g)"\n            }), /*#__PURE__*/(0,jsx_runtime.jsx)(data_table_DataTable.HeaderCell, {\n              numeric: true,\n              children: "Protein (g)"\n            }), /*#__PURE__*/(0,jsx_runtime.jsx)(data_table_DataTable.HeaderCell, {\n              children: "Comments"\n            })]\n          })\n        }), /*#__PURE__*/(0,jsx_runtime.jsx)(data_table_DataTable.Content, {\n          children: data.map(function (row, index) {\n            return /*#__PURE__*/(0,jsx_runtime.jsx)(data_table_DataTable.Row, {\n              children: row.map(function (value, index) {\n                return /*#__PURE__*/(0,jsx_runtime.jsx)(data_table_DataTable.Cell, {\n                  scope: index === 0 ? \'row\' : undefined,\n                  numeric: typeof value === \'number\' || undefined,\n                  children: value\n                }, index);\n              })\n            }, index);\n          })\n        })]\n      })\n    })\n  });\n}\n;// CONCATENATED MODULE: ./docs/src/pages/Dialog/index.jsx\nfunction Dialog_slicedToArray(arr, i) { return Dialog_arrayWithHoles(arr) || Dialog_iterableToArrayLimit(arr, i) || Dialog_unsupportedIterableToArray(arr, i) || Dialog_nonIterableRest(); }\n\nfunction Dialog_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction Dialog_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return Dialog_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return Dialog_arrayLikeToArray(o, minLen); }\n\nfunction Dialog_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction Dialog_iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction Dialog_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\n\n\n\n\n\n\nvar Dialog_id = \'dialog\';\nvar Dialog_title = \'Dialog\';\nvar Dialog_description = \'Dialogs inform users about a specific task and may contain critical information, require decisions, or involve multiple tasks.\';\nvar Dialog_links = {\n  docs: \'https://github.com/material-components/material-components-web/tree/master/packages/mdc-dialog\',\n  guide: \'https://material.io/components/dialogs\'\n};\nvar scrollableContent = "\\n    Lorem ipsum dolor sit amet consectetur adipisicing elit. Sunt earum quibusdam dolor hic accusamus, deserunt libero? Deleniti ratione libero, eveniet neque aliquam repellat dicta obcaecati atque, sequi voluptatem explicabo beatae!\\n\\n    Lorem ipsum dolor sit amet consectetur adipisicing elit. Veritatis animi vel cupiditate eveniet? Laudantium recusandae illo minus saepe itaque dolores fugiat, perferendis nostrum! Assumenda fugiat fuga deserunt omnis odit dicta!\\n\\n    Lorem ipsum dolor sit amet consectetur adipisicing elit. Minus accusantium a quisquam in repudiandae et ullam cum dignissimos exercitationem, blanditiis perspiciatis alias hic vel, laudantium aliquam omnis recusandae nemo animi.\\n\\n    Lorem ipsum dolor sit amet consectetur adipisicing elit. Sunt earum quibusdam dolor hic accusamus, deserunt libero? Deleniti ratione libero, eveniet neque aliquam repellat dicta obcaecati atque, sequi voluptatem explicabo beatae!\\n\\n    Lorem ipsum dolor sit amet consectetur adipisicing elit. Veritatis animi vel cupiditate eveniet? Laudantium recusandae illo minus saepe itaque dolores fugiat, perferendis nostrum! Assumenda fugiat fuga deserunt omnis odit dicta!\\n\\n    Lorem ipsum dolor sit amet consectetur adipisicing elit. Minus accusantium a quisquam in repudiandae et ullam cum dignissimos exercitationem, blanditiis perspiciatis alias hic vel, laudantium aliquam omnis recusandae nemo animi.\\n\\n    Lorem ipsum dolor sit amet consectetur adipisicing elit. Sunt earum quibusdam dolor hic accusamus, deserunt libero? Deleniti ratione libero, eveniet neque aliquam repellat dicta obcaecati atque, sequi voluptatem explicabo beatae!\\n\\n    Lorem ipsum dolor sit amet consectetur adipisicing elit. Veritatis animi vel cupiditate eveniet? Laudantium recusandae illo minus saepe itaque dolores fugiat, perferendis nostrum! Assumenda fugiat fuga deserunt omnis odit dicta!\\n\\n    Lorem ipsum dolor sit amet consectetur adipisicing elit. Minus accusantium a quisquam in repudiandae et ullam cum dignissimos exercitationem, blanditiis perspiciatis alias hic vel, laudantium aliquam omnis recusandae nemo animi.\\n\\n    Lorem ipsum dolor sit amet consectetur adipisicing elit. Sunt earum quibusdam dolor hic accusamus, deserunt libero? Deleniti ratione libero, eveniet neque aliquam repellat dicta obcaecati atque, sequi voluptatem explicabo beatae!\\n\\n    Lorem ipsum dolor sit amet consectetur adipisicing elit. Veritatis animi vel cupiditate eveniet? Laudantium recusandae illo minus saepe itaque dolores fugiat, perferendis nostrum! Assumenda fugiat fuga deserunt omnis odit dicta!\\n\\n    Lorem ipsum dolor sit amet consectetur adipisicing elit. Minus accusantium a quisquam in repudiandae et ullam cum dignissimos exercitationem, blanditiis perspiciatis alias hic vel, laudantium aliquam omnis recusandae nemo animi.\\n\\n    Lorem ipsum dolor sit amet consectetur adipisicing elit. Sunt earum quibusdam dolor hic accusamus, deserunt libero? Deleniti ratione libero, eveniet neque aliquam repellat dicta obcaecati atque, sequi voluptatem explicabo beatae!\\n\\n    Lorem ipsum dolor sit amet consectetur adipisicing elit. Veritatis animi vel cupiditate eveniet? Laudantium recusandae illo minus saepe itaque dolores fugiat, perferendis nostrum! Assumenda fugiat fuga deserunt omnis odit dicta!\\n\\n    Lorem ipsum dolor sit amet consectetur adipisicing elit. Minus accusantium a quisquam in repudiandae et ullam cum dignissimos exercitationem, blanditiis perspiciatis alias hic vel, laudantium aliquam omnis recusandae nemo animi.\\n\\n    Lorem ipsum dolor sit amet consectetur adipisicing elit. Sunt earum quibusdam dolor hic accusamus, deserunt libero? Deleniti ratione libero, eveniet neque aliquam repellat dicta obcaecati atque, sequi voluptatem explicabo beatae!\\n\\n    Lorem ipsum dolor sit amet consectetur adipisicing elit. Veritatis animi vel cupiditate eveniet? Laudantium recusandae illo minus saepe itaque dolores fugiat, perferendis nostrum! Assumenda fugiat fuga deserunt omnis odit dicta!\\n\\n    Lorem ipsum dolor sit amet consectetur adipisicing elit. Minus accusantium a quisquam in repudiandae et ullam cum dignissimos exercitationem, blanditiis perspiciatis alias hic vel, laudantium aliquam omnis recusandae nemo animi.\\n";\nfunction DialogPage() {\n  var _useState = (0,react.useState)(false),\n      _useState2 = Dialog_slicedToArray(_useState, 2),\n      isBasicOpen = _useState2[0],\n      setBasicOpen = _useState2[1];\n\n  var _useState3 = (0,react.useState)(false),\n      _useState4 = Dialog_slicedToArray(_useState3, 2),\n      isConfirmationOpen = _useState4[0],\n      setConfirmationOpen = _useState4[1];\n\n  var _useState5 = (0,react.useState)(false),\n      _useState6 = Dialog_slicedToArray(_useState5, 2),\n      isStackingOpen = _useState6[0],\n      setStackingOpen = _useState6[1];\n\n  var _useState7 = (0,react.useState)(false),\n      _useState8 = Dialog_slicedToArray(_useState7, 2),\n      isScrollableOpen = _useState8[0],\n      setScrollableOpen = _useState8[1];\n\n  var _useState9 = (0,react.useState)(false),\n      _useState10 = Dialog_slicedToArray(_useState9, 2),\n      isFullscreenOpen = _useState10[0],\n      setFullscreenOpen = _useState10[1];\n\n  return /*#__PURE__*/(0,jsx_runtime.jsxs)(Page, {\n    id: Dialog_id,\n    title: Dialog_title,\n    description: Dialog_description,\n    links: Dialog_links,\n    children: [/*#__PURE__*/(0,jsx_runtime.jsx)(Demo, {\n      title: "Basic dialog",\n      setup: /*#__PURE__*/(0,jsx_runtime.jsx)(button_Button, {\n        onClick: function onClick() {\n          return setBasicOpen(function (v) {\n            return !v;\n          });\n        },\n        children: "Open"\n      }),\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(dialog_Dialog, {\n        title: "Title",\n        content: "Content",\n        open: isBasicOpen,\n        onClose: function onClose() {\n          return setBasicOpen(function (v) {\n            return !v;\n          });\n        }\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Demo, {\n      title: "Confirmation dialog",\n      setup: /*#__PURE__*/(0,jsx_runtime.jsx)(button_Button, {\n        onClick: function onClick() {\n          return setConfirmationOpen(function (v) {\n            return !v;\n          });\n        },\n        children: "Open"\n      }),\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(dialog_Dialog, {\n        title: "Title",\n        content: "Are you sure?",\n        open: isConfirmationOpen,\n        persistent: true,\n        actions: [/*#__PURE__*/(0,jsx_runtime.jsx)(button_Button, {\n          onClick: function onClick() {\n            return setConfirmationOpen(function (v) {\n              return !v;\n            });\n          },\n          children: "Close"\n        }, "close"), /*#__PURE__*/(0,jsx_runtime.jsx)(button_Button, {\n          children: "Confirm"\n        }, "confirm")],\n        onClose: function onClose() {\n          return setConfirmationOpen(function (v) {\n            return !v;\n          });\n        }\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Demo, {\n      title: "Dialog with stacking buttons",\n      setup: /*#__PURE__*/(0,jsx_runtime.jsx)(button_Button, {\n        onClick: function onClick() {\n          return setStackingOpen(function (v) {\n            return !v;\n          });\n        },\n        children: "Open"\n      }),\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(dialog_Dialog, {\n        title: "Title",\n        content: "Content",\n        open: isStackingOpen,\n        autoStackButtons: true,\n        actions: [/*#__PURE__*/(0,jsx_runtime.jsx)(button_Button, {\n          onClick: function onClick() {\n            return setStackingOpen(function (v) {\n              return !v;\n            });\n          },\n          children: "A very very very very very long button"\n        }, "close"), /*#__PURE__*/(0,jsx_runtime.jsx)(button_Button, {\n          children: "A very very very very very long button"\n        }, "confirm")],\n        onClose: function onClose() {\n          return setStackingOpen(function (v) {\n            return !v;\n          });\n        }\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Demo, {\n      title: "Scrollable dialog",\n      setup: /*#__PURE__*/(0,jsx_runtime.jsx)(button_Button, {\n        onClick: function onClick() {\n          return setScrollableOpen(function (v) {\n            return !v;\n          });\n        },\n        children: "Open"\n      }),\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(dialog_Dialog, {\n        title: "Title",\n        open: isScrollableOpen,\n        actions: /*#__PURE__*/(0,jsx_runtime.jsx)(button_Button, {\n          onClick: function onClick() {\n            return setScrollableOpen(function (v) {\n              return !v;\n            });\n          },\n          children: "Close"\n        }),\n        onClose: function onClose() {\n          return setScrollableOpen(function (v) {\n            return !v;\n          });\n        },\n        children: scrollableContent\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Demo, {\n      title: "Fullscreen dialog",\n      setup: /*#__PURE__*/(0,jsx_runtime.jsx)(button_Button, {\n        onClick: function onClick() {\n          return setFullscreenOpen(function (v) {\n            return !v;\n          });\n        },\n        children: "Open"\n      }),\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(dialog_Dialog, {\n        title: "Fullscreen Dialog",\n        open: isFullscreenOpen,\n        fullscreen: true,\n        actions: /*#__PURE__*/(0,jsx_runtime.jsx)(button_Button, {\n          onClick: function onClick() {\n            return setFullscreenOpen(function (v) {\n              return !v;\n            });\n          },\n          children: "Close"\n        }),\n        onClose: function onClose() {\n          return setFullscreenOpen(function (v) {\n            return !v;\n          });\n        },\n        children: scrollableContent\n      })\n    })]\n  });\n}\n;// CONCATENATED MODULE: ./docs/src/components/Section/index.jsx\nvar Section_excluded = ["title", "children", "className"];\n\nfunction Section_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction Section_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { Section_ownKeys(Object(source), true).forEach(function (key) { Section_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { Section_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction Section_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction Section_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = Section_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction Section_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\n\nfunction Section(_ref) {\n  var title = _ref.title,\n      children = _ref.children,\n      className = _ref.className,\n      props = Section_objectWithoutProperties(_ref, Section_excluded);\n\n  var classNames = classnames_default()(\'section\', className);\n  return /*#__PURE__*/(0,jsx_runtime.jsxs)("section", Section_objectSpread(Section_objectSpread({\n    className: classNames\n  }, props), {}, {\n    children: [title && /*#__PURE__*/(0,jsx_runtime.jsx)(typography_Typography, {\n      className: "section-title",\n      type: "headline6",\n      children: title\n    }), children]\n  }));\n}\n;// CONCATENATED MODULE: ./docs/src/pages/Drawer/index.jsx\nfunction Drawer_slicedToArray(arr, i) { return Drawer_arrayWithHoles(arr) || Drawer_iterableToArrayLimit(arr, i) || Drawer_unsupportedIterableToArray(arr, i) || Drawer_nonIterableRest(); }\n\nfunction Drawer_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction Drawer_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return Drawer_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return Drawer_arrayLikeToArray(o, minLen); }\n\nfunction Drawer_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction Drawer_iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction Drawer_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\n\n\n\n\n\n\n\nvar Drawer_id = \'drawer\';\nvar Drawer_title = \'Drawer\';\nvar Drawer_description = \'Navigation drawers provide access to destinations in your app.\';\nvar Drawer_links = {\n  docs: \'https://github.com/material-components/material-components-web/tree/master/packages/mdc-drawer\',\n  guide: \'https://material.io/components/navigation-drawer\'\n};\nfunction DrawerPage() {\n  var _useState = (0,react.useState)(false),\n      _useState2 = Drawer_slicedToArray(_useState, 2),\n      isDismissibleOpen = _useState2[0],\n      setDismissibleOpen = _useState2[1];\n\n  var _useState3 = (0,react.useState)(false),\n      _useState4 = Drawer_slicedToArray(_useState3, 2),\n      isModalOpen = _useState4[0],\n      setModalOpen = _useState4[1];\n\n  return /*#__PURE__*/(0,jsx_runtime.jsxs)(Page, {\n    id: Drawer_id,\n    title: Drawer_title,\n    description: Drawer_description,\n    links: Drawer_links,\n    children: [/*#__PURE__*/(0,jsx_runtime.jsx)(Section, {\n      title: "Permanent drawer",\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(Code, {\n        children: /*#__PURE__*/(0,jsx_runtime.jsx)(drawer_Drawer, {\n          children: /*#__PURE__*/(0,jsx_runtime.jsx)(drawer_Drawer.Header, {\n            title: "Title"\n          })\n        })\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Section, {\n      title: "Dismissible drawer",\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(Code, {\n        setup: /*#__PURE__*/(0,jsx_runtime.jsx)(button_Button, {\n          label: "Toggle",\n          onClick: function onClick() {\n            return setDismissibleOpen(function (v) {\n              return !v;\n            });\n          }\n        }),\n        children: /*#__PURE__*/(0,jsx_runtime.jsx)(drawer_Drawer, {\n          open: isDismissibleOpen,\n          dismissible: true,\n          children: /*#__PURE__*/(0,jsx_runtime.jsx)(drawer_Drawer.Header, {\n            title: "Title"\n          })\n        })\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Section, {\n      title: "Modal drawer",\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(Code, {\n        setup: /*#__PURE__*/(0,jsx_runtime.jsx)(button_Button, {\n          label: "Toggle",\n          onClick: function onClick() {\n            return setModalOpen(function (v) {\n              return !v;\n            });\n          }\n        }),\n        children: /*#__PURE__*/(0,jsx_runtime.jsx)(drawer_Drawer, {\n          open: isModalOpen,\n          onClose: function onClose() {\n            return setModalOpen(function (v) {\n              return !v;\n            });\n          },\n          modal: true,\n          children: /*#__PURE__*/(0,jsx_runtime.jsx)(drawer_Drawer.Header, {\n            title: "Title"\n          })\n        })\n      })\n    })]\n  });\n}\n;// CONCATENATED MODULE: ./docs/src/pages/Elevation/index.jsx\nfunction Elevation_slicedToArray(arr, i) { return Elevation_arrayWithHoles(arr) || Elevation_iterableToArrayLimit(arr, i) || Elevation_unsupportedIterableToArray(arr, i) || Elevation_nonIterableRest(); }\n\nfunction Elevation_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction Elevation_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return Elevation_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return Elevation_arrayLikeToArray(o, minLen); }\n\nfunction Elevation_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction Elevation_iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction Elevation_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\n\n\n\n\n\n\n\nvar Elevation_id = \'elevation\';\nvar Elevation_title = \'Elevation\';\nvar Elevation_description = \'Elevation is the relative distance between two surfaces along the z-axis.\';\nvar Elevation_links = {\n  docs: \'https://github.com/material-components/material-components-web/tree/master/packages/mdc-elevation\',\n  guide: \'https://material.io/design/environment/elevation\'\n};\nfunction ElevationPage() {\n  var _useState = (0,react.useState)(0),\n      _useState2 = Elevation_slicedToArray(_useState, 2),\n      z = _useState2[0],\n      setZ = _useState2[1];\n\n  var handleChange = (0,react.useCallback)(function (value) {\n    setZ(value);\n  }, []);\n  return /*#__PURE__*/(0,jsx_runtime.jsx)(Page, {\n    id: Elevation_id,\n    title: Elevation_title,\n    description: Elevation_description,\n    links: Elevation_links,\n    children: /*#__PURE__*/(0,jsx_runtime.jsx)(Section, {\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(Code, {\n        setup: /*#__PURE__*/(0,jsx_runtime.jsx)(slider_Slider, {\n          value: z,\n          min: "0",\n          max: "24",\n          step: "1",\n          discrete: true,\n          tickMarks: true,\n          onChange: handleChange\n        }),\n        children: /*#__PURE__*/(0,jsx_runtime.jsx)(elevation_Elevation, {\n          z: z\n        })\n      })\n    })\n  });\n}\n;// CONCATENATED MODULE: ./docs/src/pages/FAB/index.jsx\nfunction FAB_slicedToArray(arr, i) { return FAB_arrayWithHoles(arr) || FAB_iterableToArrayLimit(arr, i) || FAB_unsupportedIterableToArray(arr, i) || FAB_nonIterableRest(); }\n\nfunction FAB_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction FAB_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return FAB_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return FAB_arrayLikeToArray(o, minLen); }\n\nfunction FAB_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction FAB_iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction FAB_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\n\n\n\n\n\n\n\nvar FAB_id = \'fab\';\nvar FAB_title = \'FAB\';\nvar FAB_description = \'A floating action button (FAB) represents the primary action of a screen.\';\nvar FAB_links = {\n  docs: \'https://github.com/material-components/material-components-web/tree/master/packages/mdc-fab\',\n  guide: \'https://material.io/components/buttons-floating-action-button\'\n};\nfunction FABPage() {\n  var _useState = (0,react.useState)(false),\n      _useState2 = FAB_slicedToArray(_useState, 2),\n      isExited = _useState2[0],\n      setExited = _useState2[1];\n\n  return /*#__PURE__*/(0,jsx_runtime.jsxs)(Page, {\n    id: FAB_id,\n    title: FAB_title,\n    description: FAB_description,\n    links: FAB_links,\n    children: [/*#__PURE__*/(0,jsx_runtime.jsx)(Section, {\n      title: "Basic FAB",\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(Code, {\n        children: /*#__PURE__*/(0,jsx_runtime.jsx)(fab_FAB, {\n          icon: "star"\n        })\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Section, {\n      title: "Mini FAB",\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(Code, {\n        children: /*#__PURE__*/(0,jsx_runtime.jsx)(fab_FAB, {\n          icon: "star",\n          mini: true\n        })\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Section, {\n      title: "Extended FAB",\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(Code, {\n        children: /*#__PURE__*/(0,jsx_runtime.jsx)(fab_FAB, {\n          icon: "star",\n          label: "Star"\n        })\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Section, {\n      title: "Extended FAB with a trailing icon",\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(Code, {\n        children: /*#__PURE__*/(0,jsx_runtime.jsx)(fab_FAB, {\n          label: "Star",\n          trailingIcon: "star"\n        })\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Section, {\n      title: "Animated FAB",\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(Code, {\n        setup: /*#__PURE__*/(0,jsx_runtime.jsx)(button_Button, {\n          label: "Toggle",\n          onClick: function onClick() {\n            return setExited(function (v) {\n              return !v;\n            });\n          }\n        }),\n        children: /*#__PURE__*/(0,jsx_runtime.jsx)(fab_FAB, {\n          icon: "star",\n          exited: isExited\n        })\n      })\n    })]\n  });\n}\n;// CONCATENATED MODULE: ./docs/src/pages/FormField/index.jsx\n\n\n\n\n\n\n\nvar FormField_id = \'form-field\';\nvar FormField_title = \'Form Field\';\nvar FormField_description = \'Form Field aligns a form field (for example, a checkbox) with its label and makes it RTL-aware.\';\nvar FormField_links = {\n  docs: \'https://github.com/material-components/material-components-web/tree/master/packages/mdc-form-field\'\n};\nfunction FormFieldPage() {\n  return /*#__PURE__*/(0,jsx_runtime.jsxs)(Page, {\n    id: FormField_id,\n    title: FormField_title,\n    description: FormField_description,\n    links: FormField_links,\n    children: [/*#__PURE__*/(0,jsx_runtime.jsx)(Section, {\n      title: "Basic form field",\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(Code, {\n        children: /*#__PURE__*/(0,jsx_runtime.jsx)(form_field_FormField, {\n          label: "Label",\n          children: /*#__PURE__*/(0,jsx_runtime.jsx)(checkbox_Checkbox, {})\n        })\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Section, {\n      title: "Form field that goes before the element",\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(Code, {\n        children: /*#__PURE__*/(0,jsx_runtime.jsx)(form_field_FormField, {\n          label: "Label",\n          alignEnd: true,\n          children: /*#__PURE__*/(0,jsx_runtime.jsx)(checkbox_Checkbox, {})\n        })\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Section, {\n      title: "No wrap form field",\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(Code, {\n        children: /*#__PURE__*/(0,jsx_runtime.jsx)(form_field_FormField, {\n          label: "Label",\n          nowrap: true,\n          children: /*#__PURE__*/(0,jsx_runtime.jsx)(checkbox_Checkbox, {})\n        })\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Section, {\n      title: "Form field with space between",\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(Code, {\n        children: /*#__PURE__*/(0,jsx_runtime.jsx)(form_field_FormField, {\n          label: "Label",\n          spaceBetween: true,\n          children: /*#__PURE__*/(0,jsx_runtime.jsx)(checkbox_Checkbox, {})\n        })\n      })\n    })]\n  });\n}\n// EXTERNAL MODULE: ./node_modules/marked/lib/marked.js\nvar marked = __webpack_require__(84);\nvar marked_default = /*#__PURE__*/__webpack_require__.n(marked);\n;// CONCATENATED MODULE: ./docs/src/utils/markdown.js\n\n\nmarked_default().setOptions({\n  highlight: highlight,\n  langPrefix: \'hljs language-\'\n});\n/* harmony default export */ const markdown = ((marked_default()));\n// EXTERNAL MODULE: ./README.md\nvar README = __webpack_require__(996);\n;// CONCATENATED MODULE: ./docs/src/pages/Home/index.jsx\n\n\n\n\n\nvar html = markdown(README);\nfunction HomePage() {\n  return /*#__PURE__*/(0,jsx_runtime.jsx)(Page, {\n    id: "home",\n    children: /*#__PURE__*/(0,jsx_runtime.jsx)("article", {\n      className: "markdown",\n      dangerouslySetInnerHTML: {\n        __html: html\n      }\n    })\n  });\n}\n;// CONCATENATED MODULE: ./docs/src/pages/IconButton/index.jsx\nfunction IconButton_slicedToArray(arr, i) { return IconButton_arrayWithHoles(arr) || IconButton_iterableToArrayLimit(arr, i) || IconButton_unsupportedIterableToArray(arr, i) || IconButton_nonIterableRest(); }\n\nfunction IconButton_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction IconButton_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return IconButton_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return IconButton_arrayLikeToArray(o, minLen); }\n\nfunction IconButton_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction IconButton_iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction IconButton_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\n\n\n\n\n\n\n\nvar IconButton_id = \'icon-button\';\nvar IconButton_title = \'Icon Button\';\nvar IconButton_description = \'Icon buttons allow users to take actions, and make choices, with a single tap.\';\nvar IconButton_links = {\n  docs: \'https://github.com/material-components/material-components-web/tree/master/packages/mdc-icon-button\',\n  guide: \'https://material.io/components/buttons\'\n};\nfunction IconButtonPage() {\n  var _useState = (0,react.useState)(true),\n      _useState2 = IconButton_slicedToArray(_useState, 2),\n      isOn = _useState2[0],\n      setOn = _useState2[1];\n\n  return /*#__PURE__*/(0,jsx_runtime.jsxs)(Page, {\n    id: IconButton_id,\n    title: IconButton_title,\n    description: IconButton_description,\n    links: IconButton_links,\n    children: [/*#__PURE__*/(0,jsx_runtime.jsx)(Section, {\n      title: "Basic icon button",\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(Code, {\n        children: /*#__PURE__*/(0,jsx_runtime.jsx)(icon_button_IconButton, {\n          icon: "star"\n        })\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Section, {\n      title: "Toggling icon button",\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(Code, {\n        children: /*#__PURE__*/(0,jsx_runtime.jsx)(icon_button_IconButton, {\n          icon: isOn ? \'favorite\' : \'favorite_border\',\n          onClick: function onClick() {\n            return setOn(function (v) {\n              return !v;\n            });\n          }\n        })\n      })\n    })]\n  });\n}\n;// CONCATENATED MODULE: ./docs/src/pages/ImageList/index.jsx\nfunction pages_ImageList_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction pages_ImageList_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { pages_ImageList_ownKeys(Object(source), true).forEach(function (key) { pages_ImageList_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { pages_ImageList_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction pages_ImageList_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n\nvar ImageList_id = \'image-list\';\nvar ImageList_title = \'Image List\';\nvar ImageList_description = \'Image lists display a collection of images in an organized grid.\';\nvar ImageList_links = {\n  docs: \'https://github.com/material-components/material-components-web/tree/master/packages/mdc-image-list\',\n  guide: \'https://material.io/components/image-lists\'\n};\n\n\n\n\n\n\nvar standardItems = new Array(15).fill(1).map(function () {\n  return {\n    imageSrc: \'https://placeimg.com/360/360/any\',\n    label: \'Text Label\'\n  };\n});\nvar masonryItems = new Array(15).fill(1).map(function () {\n  return {\n    imageSrc: "https://placeimg.com/".concat(Math.random() > 0.5 ? \'480/360\' : \'360/480\', "/any"),\n    label: \'Text Label\'\n  };\n});\nfunction ImageListPage() {\n  return /*#__PURE__*/(0,jsx_runtime.jsxs)(Page, {\n    id: ImageList_id,\n    title: ImageList_title,\n    description: ImageList_description,\n    links: ImageList_links,\n    children: [/*#__PURE__*/(0,jsx_runtime.jsx)(Section, {\n      id: "standard-image-list",\n      title: "Standard Image List",\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(Code, {\n        children: /*#__PURE__*/(0,jsx_runtime.jsx)(image_list_ImageList, {\n          children: standardItems.map(function (item, index) {\n            return /*#__PURE__*/(0,jsx_runtime.jsx)(image_list_ImageList.Item, pages_ImageList_objectSpread({}, item), index);\n          })\n        })\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Section, {\n      id: "standard-image-list",\n      title: "Standard Image List with Text Protection",\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(Code, {\n        children: /*#__PURE__*/(0,jsx_runtime.jsx)(image_list_ImageList, {\n          withTextProtection: true,\n          children: standardItems.map(function (item, index) {\n            return /*#__PURE__*/(0,jsx_runtime.jsx)(image_list_ImageList.Item, pages_ImageList_objectSpread({}, item), index);\n          })\n        })\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Section, {\n      id: "masonry-image-list",\n      title: "Masonry Image Lis",\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(Code, {\n        children: /*#__PURE__*/(0,jsx_runtime.jsx)(image_list_ImageList, {\n          masonry: true,\n          children: masonryItems.map(function (item, index) {\n            return /*#__PURE__*/(0,jsx_runtime.jsx)(image_list_ImageList.Item, pages_ImageList_objectSpread({}, item), index);\n          })\n        })\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Section, {\n      id: "masonry-image-list",\n      title: "Masonry Image List with Text Protection",\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(Code, {\n        children: /*#__PURE__*/(0,jsx_runtime.jsx)(image_list_ImageList, {\n          masonry: true,\n          withTextProtection: true,\n          children: masonryItems.map(function (item, index) {\n            return /*#__PURE__*/(0,jsx_runtime.jsx)(image_list_ImageList.Item, pages_ImageList_objectSpread({}, item), index);\n          })\n        })\n      })\n    })]\n  });\n}\n;// CONCATENATED MODULE: ./docs/src/pages/LayoutGrid/index.jsx\n\n\n\n\n\n\n\nvar LayoutGrid_id = \'layout-grid\';\nvar LayoutGrid_title = \'Layout Grid\';\nvar LayoutGrid_description = \'Material designs responsive UI is based on a 12-column grid layout.\';\nvar LayoutGrid_links = {\n  docs: \'https://github.com/material-components/material-components-web/tree/master/packages/mdc-layout-grid\',\n  guide: \'https://material.io/design/layout/responsive-layout-grid.html\'\n};\nfunction LayoutGridPage() {\n  return /*#__PURE__*/(0,jsx_runtime.jsxs)(Page, {\n    id: LayoutGrid_id,\n    title: LayoutGrid_title,\n    description: LayoutGrid_description,\n    links: LayoutGrid_links,\n    children: [/*#__PURE__*/(0,jsx_runtime.jsx)(Section, {\n      title: "Basic grid",\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(Code, {\n        children: /*#__PURE__*/(0,jsx_runtime.jsxs)(layout_grid_LayoutGrid, {\n          children: [/*#__PURE__*/(0,jsx_runtime.jsx)(layout_grid_LayoutGrid.Cell, {\n            span: "6"\n          }), /*#__PURE__*/(0,jsx_runtime.jsx)(layout_grid_LayoutGrid.Cell, {\n            span: "3"\n          }), /*#__PURE__*/(0,jsx_runtime.jsx)(layout_grid_LayoutGrid.Cell, {\n            span: "2"\n          }), /*#__PURE__*/(0,jsx_runtime.jsx)(layout_grid_LayoutGrid.Cell, {\n            span: "1"\n          }), /*#__PURE__*/(0,jsx_runtime.jsx)(layout_grid_LayoutGrid.Cell, {\n            span: "3"\n          }), /*#__PURE__*/(0,jsx_runtime.jsx)(layout_grid_LayoutGrid.Cell, {\n            span: "1"\n          }), /*#__PURE__*/(0,jsx_runtime.jsx)(layout_grid_LayoutGrid.Cell, {\n            span: "8"\n          })]\n        })\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Section, {\n      title: "Nested grid",\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(Code, {\n        children: /*#__PURE__*/(0,jsx_runtime.jsxs)(layout_grid_LayoutGrid, {\n          children: [/*#__PURE__*/(0,jsx_runtime.jsxs)(layout_grid_LayoutGrid.Cell, {\n            grid: true,\n            children: [/*#__PURE__*/(0,jsx_runtime.jsx)(layout_grid_LayoutGrid.Cell, {}), /*#__PURE__*/(0,jsx_runtime.jsx)(layout_grid_LayoutGrid.Cell, {}), /*#__PURE__*/(0,jsx_runtime.jsx)(layout_grid_LayoutGrid.Cell, {})]\n          }), /*#__PURE__*/(0,jsx_runtime.jsx)(layout_grid_LayoutGrid.Cell, {}), /*#__PURE__*/(0,jsx_runtime.jsx)(layout_grid_LayoutGrid.Cell, {})]\n        })\n      })\n    })]\n  });\n}\n;// CONCATENATED MODULE: ./docs/src/pages/LinearProgress/index.jsx\nfunction LinearProgress_slicedToArray(arr, i) { return LinearProgress_arrayWithHoles(arr) || LinearProgress_iterableToArrayLimit(arr, i) || LinearProgress_unsupportedIterableToArray(arr, i) || LinearProgress_nonIterableRest(); }\n\nfunction LinearProgress_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction LinearProgress_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return LinearProgress_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return LinearProgress_arrayLikeToArray(o, minLen); }\n\nfunction LinearProgress_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction LinearProgress_iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction LinearProgress_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\n\n\n\n\n\n\n\nvar LinearProgress_id = \'linear-progress\';\nvar LinearProgress_title = \'Linear Progress\';\nvar LinearProgress_description = \'Progress indicators display the length of a process or express an unspecified wait time.\';\nvar LinearProgress_links = {\n  docs: \'\',\n  guide: \'\'\n};\nfunction LinearProgressPage() {\n  var _useState = (0,react.useState)(true),\n      _useState2 = LinearProgress_slicedToArray(_useState, 2),\n      isClosed = _useState2[0],\n      setClosed = _useState2[1];\n\n  return /*#__PURE__*/(0,jsx_runtime.jsxs)(Page, {\n    id: LinearProgress_id,\n    title: LinearProgress_title,\n    description: LinearProgress_description,\n    links: LinearProgress_links,\n    children: [/*#__PURE__*/(0,jsx_runtime.jsx)(Section, {\n      title: "Basic linear progress",\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(Code, {\n        children: /*#__PURE__*/(0,jsx_runtime.jsx)(linear_progress_LinearProgress, {\n          value: "42"\n        })\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Section, {\n      title: "Linear progress with a buffer",\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(Code, {\n        children: /*#__PURE__*/(0,jsx_runtime.jsx)(linear_progress_LinearProgress, {\n          value: "42",\n          buffer: "84"\n        })\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Section, {\n      title: "Indeterminate linear progress",\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(Code, {\n        children: /*#__PURE__*/(0,jsx_runtime.jsx)(linear_progress_LinearProgress, {\n          indeterminate: true\n        })\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Section, {\n      title: "Closed linear progress",\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(Code, {\n        setup: /*#__PURE__*/(0,jsx_runtime.jsx)(button_Button, {\n          onClick: function onClick() {\n            return setClosed(function (v) {\n              return !v;\n            });\n          },\n          children: "Toggle"\n        }),\n        children: /*#__PURE__*/(0,jsx_runtime.jsx)(linear_progress_LinearProgress, {\n          closed: isClosed,\n          value: "42"\n        })\n      })\n    })]\n  });\n}\n;// CONCATENATED MODULE: ./docs/src/pages/List/index.jsx\n\n\n\n\n\n\nvar List_id = \'list\';\nvar List_title = \'List\';\nvar List_description = \'Lists present multiple line items vertically as a single continuous element.\';\nvar List_links = {\n  docs: \'https://github.com/material-components/material-components-web/tree/master/packages/mdc-list\',\n  guide: \'https://material.io/components/lists\'\n};\nfunction ListPage() {\n  return /*#__PURE__*/(0,jsx_runtime.jsxs)(Page, {\n    id: List_id,\n    title: List_title,\n    description: List_description,\n    links: List_links,\n    children: [/*#__PURE__*/(0,jsx_runtime.jsx)(Section, {\n      title: "Single-line list",\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(Code, {\n        children: /*#__PURE__*/(0,jsx_runtime.jsxs)(list_List, {\n          children: [/*#__PURE__*/(0,jsx_runtime.jsx)(list_ListItem, {\n            text: "Item 1"\n          }), /*#__PURE__*/(0,jsx_runtime.jsx)(list_ListItem, {\n            text: "Item 2"\n          }), /*#__PURE__*/(0,jsx_runtime.jsx)(list_ListItem, {\n            text: "Item 3"\n          })]\n        })\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsxs)(Section, {\n      title: "Two-line list",\n      children: [/*#__PURE__*/(0,jsx_runtime.jsx)(Code, {\n        children: /*#__PURE__*/(0,jsx_runtime.jsxs)(list_List, {\n          children: [/*#__PURE__*/(0,jsx_runtime.jsx)(list_ListItem, {\n            primaryText: "Item 1",\n            secondaryText: "Secondary text"\n          }), /*#__PURE__*/(0,jsx_runtime.jsx)(list_ListItem, {\n            primaryText: "Item 2",\n            secondaryText: "Secondary text"\n          }), /*#__PURE__*/(0,jsx_runtime.jsx)(list_ListItem, {\n            primaryText: "Item 3",\n            secondaryText: "Secondary text"\n          })]\n        })\n      }), /*#__PURE__*/(0,jsx_runtime.jsx)(Code, {\n        children: /*#__PURE__*/(0,jsx_runtime.jsxs)(list_List, {\n          children: [/*#__PURE__*/(0,jsx_runtime.jsx)(list_ListItem, {\n            overlineText: "Overline",\n            primaryText: "Item 1"\n          }), /*#__PURE__*/(0,jsx_runtime.jsx)(list_ListItem, {\n            overlineText: "Overline",\n            primaryText: "Item 2"\n          }), /*#__PURE__*/(0,jsx_runtime.jsx)(list_ListItem, {\n            overlineText: "Overline",\n            primaryText: "Item 3"\n          })]\n        })\n      })]\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Section, {\n      title: "Three-line list",\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(Code, {\n        children: /*#__PURE__*/(0,jsx_runtime.jsxs)(list_List, {\n          children: [/*#__PURE__*/(0,jsx_runtime.jsx)(list_ListItem, {\n            overlineText: "Overline",\n            primaryText: "Item 1",\n            secondaryText: "Secondary text"\n          }), /*#__PURE__*/(0,jsx_runtime.jsx)(list_ListItem, {\n            overlineText: "Overline",\n            primaryText: "Item 2",\n            secondaryText: "Secondary text"\n          }), /*#__PURE__*/(0,jsx_runtime.jsx)(list_ListItem, {\n            overlineText: "Overline",\n            primaryText: "Item 3",\n            secondaryText: "Secondary text"\n          })]\n        })\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Section, {\n      title: "List with icons",\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(Code, {\n        children: /*#__PURE__*/(0,jsx_runtime.jsxs)(list_List, {\n          children: [/*#__PURE__*/(0,jsx_runtime.jsx)(list_ListItem, {\n            icon: "star",\n            text: "Item 1"\n          }), /*#__PURE__*/(0,jsx_runtime.jsx)(list_ListItem, {\n            icon: "star",\n            text: "Item 2"\n          }), /*#__PURE__*/(0,jsx_runtime.jsx)(list_ListItem, {\n            icon: "star",\n            text: "Item 3"\n          })]\n        })\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Section, {\n      title: "List with images",\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(Code, {\n        children: /*#__PURE__*/(0,jsx_runtime.jsxs)(list_List, {\n          children: [/*#__PURE__*/(0,jsx_runtime.jsx)(list_ListItem, {\n            image: /*#__PURE__*/(0,jsx_runtime.jsx)("img", {\n              src: "https://placeimg.com/56/56/any"\n            }),\n            text: "Item 1"\n          }), /*#__PURE__*/(0,jsx_runtime.jsx)(list_ListItem, {\n            image: /*#__PURE__*/(0,jsx_runtime.jsx)("img", {\n              src: "https://placeimg.com/56/56/any"\n            }),\n            text: "Item 2"\n          }), /*#__PURE__*/(0,jsx_runtime.jsx)(list_ListItem, {\n            image: /*#__PURE__*/(0,jsx_runtime.jsx)("img", {\n              src: "https://placeimg.com/56/56/any"\n            }),\n            text: "Item 3"\n          })]\n        })\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Section, {\n      title: "List with thumbnails",\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(Code, {\n        children: /*#__PURE__*/(0,jsx_runtime.jsxs)(list_List, {\n          children: [/*#__PURE__*/(0,jsx_runtime.jsx)(list_ListItem, {\n            thumbnail: /*#__PURE__*/(0,jsx_runtime.jsx)("img", {\n              src: "https://placeimg.com/40/40/people"\n            }),\n            text: "Item 1"\n          }), /*#__PURE__*/(0,jsx_runtime.jsx)(list_ListItem, {\n            thumbnail: /*#__PURE__*/(0,jsx_runtime.jsx)("img", {\n              src: "https://placeimg.com/40/40/people"\n            }),\n            text: "Item 2"\n          }), /*#__PURE__*/(0,jsx_runtime.jsx)(list_ListItem, {\n            thumbnail: /*#__PURE__*/(0,jsx_runtime.jsx)("img", {\n              src: "https://placeimg.com/40/40/people"\n            }),\n            text: "Item 3"\n          })]\n        })\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Section, {\n      title: "List with videos",\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(Code, {\n        children: /*#__PURE__*/(0,jsx_runtime.jsxs)(list_List, {\n          children: [/*#__PURE__*/(0,jsx_runtime.jsx)(list_ListItem, {\n            video: /*#__PURE__*/(0,jsx_runtime.jsx)("img", {\n              src: "https://placeimg.com/100/56/people"\n            }),\n            text: "Item 1"\n          }), /*#__PURE__*/(0,jsx_runtime.jsx)(list_ListItem, {\n            video: /*#__PURE__*/(0,jsx_runtime.jsx)("img", {\n              src: "https://placeimg.com/100/56/people"\n            }),\n            text: "Item 2"\n          }), /*#__PURE__*/(0,jsx_runtime.jsx)(list_ListItem, {\n            video: /*#__PURE__*/(0,jsx_runtime.jsx)("img", {\n              src: "https://placeimg.com/100/56/people"\n            }),\n            text: "Item 3"\n          })]\n        })\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Section, {\n      title: "List with checkboxes",\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(Code, {\n        children: /*#__PURE__*/(0,jsx_runtime.jsxs)(list_List, {\n          children: [/*#__PURE__*/(0,jsx_runtime.jsx)(list_ListItem, {\n            leadingCheckbox: /*#__PURE__*/(0,jsx_runtime.jsx)(checkbox_Checkbox, {\n              defaultChecked: false\n            }),\n            text: "Item 1"\n          }), /*#__PURE__*/(0,jsx_runtime.jsx)(list_ListItem, {\n            leadingCheckbox: /*#__PURE__*/(0,jsx_runtime.jsx)(checkbox_Checkbox, {\n              defaultChecked: false\n            }),\n            text: "Item 2"\n          }), /*#__PURE__*/(0,jsx_runtime.jsx)(list_ListItem, {\n            leadingCheckbox: /*#__PURE__*/(0,jsx_runtime.jsx)(checkbox_Checkbox, {\n              defaultChecked: false\n            }),\n            text: "Item 3"\n          })]\n        })\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Section, {\n      title: "List with radios",\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(Code, {\n        children: /*#__PURE__*/(0,jsx_runtime.jsxs)(list_List, {\n          children: [/*#__PURE__*/(0,jsx_runtime.jsx)(list_ListItem, {\n            leadingRadio: /*#__PURE__*/(0,jsx_runtime.jsx)(radio_Radio, {}),\n            text: "Item 1"\n          }), /*#__PURE__*/(0,jsx_runtime.jsx)(list_ListItem, {\n            leadingRadio: /*#__PURE__*/(0,jsx_runtime.jsx)(radio_Radio, {\n              checked: true\n            }),\n            text: "Item 2"\n          }), /*#__PURE__*/(0,jsx_runtime.jsx)(list_ListItem, {\n            leadingRadio: /*#__PURE__*/(0,jsx_runtime.jsx)(radio_Radio, {}),\n            text: "Item 3"\n          })]\n        })\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Section, {\n      title: "List with switches",\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(Code, {\n        children: /*#__PURE__*/(0,jsx_runtime.jsxs)(list_List, {\n          children: [/*#__PURE__*/(0,jsx_runtime.jsx)(list_ListItem, {\n            leadingSwitch: /*#__PURE__*/(0,jsx_runtime.jsx)(switch_Switch, {}),\n            text: "Item 1"\n          }), /*#__PURE__*/(0,jsx_runtime.jsx)(list_ListItem, {\n            leadingSwitch: /*#__PURE__*/(0,jsx_runtime.jsx)(switch_Switch, {\n              checked: true\n            }),\n            text: "Item 2"\n          }), /*#__PURE__*/(0,jsx_runtime.jsx)(list_ListItem, {\n            leadingSwitch: /*#__PURE__*/(0,jsx_runtime.jsx)(switch_Switch, {}),\n            text: "Item 3"\n          })]\n        })\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Section, {\n      title: "List with trailing icons",\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(Code, {\n        children: /*#__PURE__*/(0,jsx_runtime.jsxs)(list_List, {\n          children: [/*#__PURE__*/(0,jsx_runtime.jsx)(list_ListItem, {\n            text: "Item 1",\n            trailingIcon: "info"\n          }), /*#__PURE__*/(0,jsx_runtime.jsx)(list_ListItem, {\n            text: "Item 2",\n            trailingIcon: "info"\n          }), /*#__PURE__*/(0,jsx_runtime.jsx)(list_ListItem, {\n            text: "Item 3",\n            trailingIcon: "info"\n          })]\n        })\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Section, {\n      title: "List with trailing meta",\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(Code, {\n        children: /*#__PURE__*/(0,jsx_runtime.jsxs)(list_List, {\n          children: [/*#__PURE__*/(0,jsx_runtime.jsx)(list_ListItem, {\n            text: "Item 1",\n            meta: "Meta"\n          }), /*#__PURE__*/(0,jsx_runtime.jsx)(list_ListItem, {\n            text: "Item 2",\n            meta: "Meta"\n          }), /*#__PURE__*/(0,jsx_runtime.jsx)(list_ListItem, {\n            text: "Item 3",\n            meta: "Meta"\n          })]\n        })\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Section, {\n      title: "List with trailing checkboxes",\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(Code, {\n        children: /*#__PURE__*/(0,jsx_runtime.jsxs)(list_List, {\n          children: [/*#__PURE__*/(0,jsx_runtime.jsx)(list_ListItem, {\n            text: "Item 1",\n            trailingCheckbox: /*#__PURE__*/(0,jsx_runtime.jsx)(checkbox_Checkbox, {})\n          }), /*#__PURE__*/(0,jsx_runtime.jsx)(list_ListItem, {\n            text: "Item 2",\n            trailingCheckbox: /*#__PURE__*/(0,jsx_runtime.jsx)(checkbox_Checkbox, {\n              checked: true\n            })\n          }), /*#__PURE__*/(0,jsx_runtime.jsx)(list_ListItem, {\n            text: "Item 3",\n            trailingCheckbox: /*#__PURE__*/(0,jsx_runtime.jsx)(checkbox_Checkbox, {})\n          })]\n        })\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Section, {\n      title: "List with trailing radios",\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(Code, {\n        children: /*#__PURE__*/(0,jsx_runtime.jsxs)(list_List, {\n          children: [/*#__PURE__*/(0,jsx_runtime.jsx)(list_ListItem, {\n            text: "Item 1",\n            trailingRadio: /*#__PURE__*/(0,jsx_runtime.jsx)(radio_Radio, {})\n          }), /*#__PURE__*/(0,jsx_runtime.jsx)(list_ListItem, {\n            text: "Item 2",\n            trailingRadio: /*#__PURE__*/(0,jsx_runtime.jsx)(radio_Radio, {\n              checked: true\n            })\n          }), /*#__PURE__*/(0,jsx_runtime.jsx)(list_ListItem, {\n            text: "Item 3",\n            trailingRadio: /*#__PURE__*/(0,jsx_runtime.jsx)(radio_Radio, {})\n          })]\n        })\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Section, {\n      title: "List with trailing switches",\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(Code, {\n        children: /*#__PURE__*/(0,jsx_runtime.jsxs)(list_List, {\n          children: [/*#__PURE__*/(0,jsx_runtime.jsx)(list_ListItem, {\n            text: "Item 1",\n            trailingSwitch: /*#__PURE__*/(0,jsx_runtime.jsx)(switch_Switch, {})\n          }), /*#__PURE__*/(0,jsx_runtime.jsx)(list_ListItem, {\n            text: "Item 2",\n            trailingSwitch: /*#__PURE__*/(0,jsx_runtime.jsx)(switch_Switch, {\n              selected: true\n            })\n          }), /*#__PURE__*/(0,jsx_runtime.jsx)(list_ListItem, {\n            text: "Item 3",\n            trailingSwitch: /*#__PURE__*/(0,jsx_runtime.jsx)(switch_Switch, {})\n          })]\n        })\n      })\n    })]\n  });\n}\n;// CONCATENATED MODULE: ./docs/src/pages/Menu/index.jsx\nfunction pages_Menu_slicedToArray(arr, i) { return pages_Menu_arrayWithHoles(arr) || pages_Menu_iterableToArrayLimit(arr, i) || pages_Menu_unsupportedIterableToArray(arr, i) || pages_Menu_nonIterableRest(); }\n\nfunction pages_Menu_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction pages_Menu_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return pages_Menu_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return pages_Menu_arrayLikeToArray(o, minLen); }\n\nfunction pages_Menu_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction pages_Menu_iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction pages_Menu_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\n\n\n\n\n\n\n\n\n\nvar Menu_id = \'menu\';\nvar Menu_title = \'Menu\';\nvar Menu_description = \'Menus display a list of choices on temporary surfaces.\';\nvar Menu_links = {\n  docs: \'https://github.com/material-components/material-components-web/tree/master/packages/mdc-menu\',\n  guide: \'https://material.io/components/menus\'\n};\nfunction MenuPage() {\n  var _useState = (0,react.useState)(false),\n      _useState2 = pages_Menu_slicedToArray(_useState, 2),\n      isBasicOpen = _useState2[0],\n      setBasicOpen = _useState2[1];\n\n  var _useState3 = (0,react.useState)(false),\n      _useState4 = pages_Menu_slicedToArray(_useState3, 2),\n      isQuickOpen = _useState4[0],\n      setQuickOpen = _useState4[1];\n\n  var _useState5 = (0,react.useState)(false),\n      _useState6 = pages_Menu_slicedToArray(_useState5, 2),\n      isPersistentOpen = _useState6[0],\n      setPersistentOpen = _useState6[1];\n\n  var _useState7 = (0,react.useState)(false),\n      _useState8 = pages_Menu_slicedToArray(_useState7, 2),\n      isAnchoredOpen = _useState8[0],\n      setAnchoredOpen = _useState8[1];\n\n  var _useState9 = (0,react.useState)(menu_Menu.Origin.TOP_LEFT),\n      _useState10 = pages_Menu_slicedToArray(_useState9, 2),\n      anchorPosition = _useState10[0],\n      setAnchorPosition = _useState10[1];\n\n  var _useState11 = (0,react.useState)(menu_Menu.Origin.TOP_LEFT),\n      _useState12 = pages_Menu_slicedToArray(_useState11, 2),\n      anchorOrigin = _useState12[0],\n      setAnchorOrigin = _useState12[1];\n\n  var _useState13 = (0,react.useState)(menu_Menu.Origin.TOP_LEFT),\n      _useState14 = pages_Menu_slicedToArray(_useState13, 2),\n      transformOrigin = _useState14[0],\n      setTransformOrigin = _useState14[1];\n\n  var _useState15 = (0,react.useState)(false),\n      _useState16 = pages_Menu_slicedToArray(_useState15, 2),\n      isModalOpen = _useState16[0],\n      setModalOpen = _useState16[1];\n\n  var _useState17 = (0,react.useState)(false),\n      _useState18 = pages_Menu_slicedToArray(_useState17, 2),\n      isDialogOpen = _useState18[0],\n      setDialogOpen = _useState18[1];\n\n  var handleAnchorPositionChange = (0,react.useCallback)(function (event, value) {\n    setAnchorPosition(value);\n  }, []);\n  var handleAnchorOriginChange = (0,react.useCallback)(function (event, value) {\n    setAnchorOrigin(value);\n  }, []);\n  var handleTransformOriginChange = (0,react.useCallback)(function (event, value) {\n    setTransformOrigin(value);\n  }, []);\n  return /*#__PURE__*/(0,jsx_runtime.jsxs)(Page, {\n    id: Menu_id,\n    title: Menu_title,\n    description: Menu_description,\n    links: Menu_links,\n    children: [/*#__PURE__*/(0,jsx_runtime.jsx)(Demo, {\n      title: "Basic menu",\n      children: /*#__PURE__*/(0,jsx_runtime.jsxs)(menu_Menu, {\n        anchor: /*#__PURE__*/(0,jsx_runtime.jsx)(button_Button, {\n          label: "Open",\n          outlined: true,\n          onClick: function onClick() {\n            return setBasicOpen(true);\n          }\n        }),\n        open: isBasicOpen,\n        onClose: function onClose() {\n          setBasicOpen(false);\n        },\n        children: [/*#__PURE__*/(0,jsx_runtime.jsx)(menu_Menu.Item, {\n          text: "Foo"\n        }), /*#__PURE__*/(0,jsx_runtime.jsx)(menu_Menu.Item, {\n          text: "Bar"\n        }), /*#__PURE__*/(0,jsx_runtime.jsx)(menu_Menu.Item, {\n          text: "Baz"\n        })]\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Demo, {\n      title: "Quick menu",\n      children: /*#__PURE__*/(0,jsx_runtime.jsxs)(menu_Menu, {\n        anchor: /*#__PURE__*/(0,jsx_runtime.jsx)(button_Button, {\n          label: "Open",\n          outlined: true,\n          onClick: function onClick() {\n            return setQuickOpen(true);\n          }\n        }),\n        open: isQuickOpen,\n        quick: true,\n        onClose: function onClose() {\n          setQuickOpen(false);\n        },\n        children: [/*#__PURE__*/(0,jsx_runtime.jsx)(menu_Menu.Item, {\n          text: "Foo"\n        }), /*#__PURE__*/(0,jsx_runtime.jsx)(menu_Menu.Item, {\n          text: "Bar"\n        }), /*#__PURE__*/(0,jsx_runtime.jsx)(menu_Menu.Item, {\n          text: "Baz"\n        })]\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Demo, {\n      title: "Persistent menu",\n      children: /*#__PURE__*/(0,jsx_runtime.jsxs)(menu_Menu, {\n        anchor: /*#__PURE__*/(0,jsx_runtime.jsx)(button_Button, {\n          label: "Open",\n          outlined: true,\n          onClick: function onClick() {\n            return setPersistentOpen(function (v) {\n              return !v;\n            });\n          }\n        }),\n        open: isPersistentOpen,\n        persistent: true,\n        children: [/*#__PURE__*/(0,jsx_runtime.jsx)(menu_Menu.Item, {\n          text: "Foo",\n          onClick: function onClick() {\n            return setPersistentOpen(false);\n          }\n        }), /*#__PURE__*/(0,jsx_runtime.jsx)(menu_Menu.Item, {\n          text: "Bar",\n          onClick: function onClick() {\n            return setPersistentOpen(false);\n          }\n        }), /*#__PURE__*/(0,jsx_runtime.jsx)(menu_Menu.Item, {\n          text: "Baz",\n          onClick: function onClick() {\n            return setPersistentOpen(false);\n          }\n        })]\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Demo, {\n      id: "menu-origin",\n      className: "origin--".concat(anchorPosition.replace(\' \', \'-\')),\n      title: "Menu origin",\n      settings: /*#__PURE__*/(0,jsx_runtime.jsxs)(jsx_runtime.Fragment, {\n        children: [/*#__PURE__*/(0,jsx_runtime.jsxs)(FieldSet, {\n          legend: "Anchor position",\n          children: [/*#__PURE__*/(0,jsx_runtime.jsx)(form_field_FormField, {\n            label: "Top left",\n            children: /*#__PURE__*/(0,jsx_runtime.jsx)(radio_Radio, {\n              value: menu_Menu.Origin.TOP_LEFT,\n              checked: anchorPosition === menu_Menu.Origin.TOP_LEFT,\n              onChange: handleAnchorPositionChange\n            })\n          }), /*#__PURE__*/(0,jsx_runtime.jsx)(form_field_FormField, {\n            label: "Top right",\n            children: /*#__PURE__*/(0,jsx_runtime.jsx)(radio_Radio, {\n              value: menu_Menu.Origin.TOP_RIGHT,\n              checked: anchorPosition === menu_Menu.Origin.TOP_RIGHT,\n              onChange: handleAnchorPositionChange\n            })\n          }), /*#__PURE__*/(0,jsx_runtime.jsx)(form_field_FormField, {\n            label: "Bottom left",\n            children: /*#__PURE__*/(0,jsx_runtime.jsx)(radio_Radio, {\n              value: menu_Menu.Origin.BOTTOM_LEFT,\n              checked: anchorPosition === menu_Menu.Origin.BOTTOM_LEFT,\n              onChange: handleAnchorPositionChange\n            })\n          }), /*#__PURE__*/(0,jsx_runtime.jsx)(form_field_FormField, {\n            label: "Bottom right",\n            children: /*#__PURE__*/(0,jsx_runtime.jsx)(radio_Radio, {\n              value: menu_Menu.Origin.BOTTOM_RIGHT,\n              checked: anchorPosition === menu_Menu.Origin.BOTTOM_RIGHT,\n              onChange: handleAnchorPositionChange\n            })\n          })]\n        }), /*#__PURE__*/(0,jsx_runtime.jsxs)(FieldSet, {\n          legend: "Anchor origin",\n          children: [/*#__PURE__*/(0,jsx_runtime.jsx)(form_field_FormField, {\n            label: "Top left",\n            children: /*#__PURE__*/(0,jsx_runtime.jsx)(radio_Radio, {\n              value: menu_Menu.Origin.TOP_LEFT,\n              checked: anchorOrigin === menu_Menu.Origin.TOP_LEFT,\n              onChange: handleAnchorOriginChange\n            })\n          }), /*#__PURE__*/(0,jsx_runtime.jsx)(form_field_FormField, {\n            label: "Top right",\n            children: /*#__PURE__*/(0,jsx_runtime.jsx)(radio_Radio, {\n              value: menu_Menu.Origin.TOP_RIGHT,\n              checked: anchorOrigin === menu_Menu.Origin.TOP_RIGHT,\n              onChange: handleAnchorOriginChange\n            })\n          }), /*#__PURE__*/(0,jsx_runtime.jsx)(form_field_FormField, {\n            label: "Bottom left",\n            children: /*#__PURE__*/(0,jsx_runtime.jsx)(radio_Radio, {\n              value: menu_Menu.Origin.BOTTOM_LEFT,\n              checked: anchorOrigin === menu_Menu.Origin.BOTTOM_LEFT,\n              onChange: handleAnchorOriginChange\n            })\n          }), /*#__PURE__*/(0,jsx_runtime.jsx)(form_field_FormField, {\n            label: "Bottom right",\n            children: /*#__PURE__*/(0,jsx_runtime.jsx)(radio_Radio, {\n              value: menu_Menu.Origin.BOTTOM_RIGHT,\n              checked: anchorOrigin === menu_Menu.Origin.BOTTOM_RIGHT,\n              onChange: handleAnchorOriginChange\n            })\n          })]\n        }), /*#__PURE__*/(0,jsx_runtime.jsxs)(FieldSet, {\n          legend: "Transform origin",\n          children: [/*#__PURE__*/(0,jsx_runtime.jsx)(form_field_FormField, {\n            label: "Top left",\n            children: /*#__PURE__*/(0,jsx_runtime.jsx)(radio_Radio, {\n              value: menu_Menu.Origin.TOP_LEFT,\n              checked: transformOrigin === menu_Menu.Origin.TOP_LEFT,\n              onChange: handleTransformOriginChange\n            })\n          }), /*#__PURE__*/(0,jsx_runtime.jsx)(form_field_FormField, {\n            label: "Top right",\n            children: /*#__PURE__*/(0,jsx_runtime.jsx)(radio_Radio, {\n              value: menu_Menu.Origin.TOP_RIGHT,\n              checked: transformOrigin === menu_Menu.Origin.TOP_RIGHT,\n              onChange: handleTransformOriginChange\n            })\n          }), /*#__PURE__*/(0,jsx_runtime.jsx)(form_field_FormField, {\n            label: "Bottom left",\n            children: /*#__PURE__*/(0,jsx_runtime.jsx)(radio_Radio, {\n              value: menu_Menu.Origin.BOTTOM_LEFT,\n              checked: transformOrigin === menu_Menu.Origin.BOTTOM_LEFT,\n              onChange: handleTransformOriginChange\n            })\n          }), /*#__PURE__*/(0,jsx_runtime.jsx)(form_field_FormField, {\n            label: "Bottom right",\n            children: /*#__PURE__*/(0,jsx_runtime.jsx)(radio_Radio, {\n              value: menu_Menu.Origin.BOTTOM_RIGHT,\n              checked: transformOrigin === menu_Menu.Origin.BOTTOM_RIGHT,\n              onChange: handleTransformOriginChange\n            })\n          })]\n        })]\n      }),\n      children: /*#__PURE__*/(0,jsx_runtime.jsxs)(menu_Menu, {\n        anchor: /*#__PURE__*/(0,jsx_runtime.jsx)(button_Button, {\n          label: isPersistentOpen ? \'Close\' : \'Open\',\n          outlined: true,\n          onClick: function onClick() {\n            return setAnchoredOpen(function (v) {\n              return !v;\n            });\n          }\n        }),\n        anchorOrigin: anchorOrigin,\n        transformOrigin: transformOrigin,\n        open: isAnchoredOpen,\n        onClose: function onClose() {\n          setAnchoredOpen(false);\n        },\n        children: [/*#__PURE__*/(0,jsx_runtime.jsx)(menu_Menu.Item, {\n          text: "Foo"\n        }), /*#__PURE__*/(0,jsx_runtime.jsx)(menu_Menu.Item, {\n          text: "Bar"\n        }), /*#__PURE__*/(0,jsx_runtime.jsx)(menu_Menu.Item, {\n          text: "Baz"\n        })]\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Demo, {\n      title: "Modal menu",\n      setup: /*#__PURE__*/(0,jsx_runtime.jsx)(button_Button, {\n        onClick: function onClick() {\n          return setDialogOpen(function (v) {\n            return !v;\n          });\n        },\n        children: "Open Dialog"\n      }),\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(dialog_Dialog, {\n        title: "Dialog",\n        open: isDialogOpen,\n        children: /*#__PURE__*/(0,jsx_runtime.jsxs)(menu_Menu, {\n          anchor: /*#__PURE__*/(0,jsx_runtime.jsx)(button_Button, {\n            label: isPersistentOpen ? \'Close\' : \'Open\',\n            outlined: true,\n            onClick: function onClick() {\n              return setModalOpen(function (v) {\n                return !v;\n              });\n            }\n          }),\n          open: isModalOpen,\n          modal: true,\n          onClose: function onClose() {\n            setModalOpen(false);\n          },\n          children: [/*#__PURE__*/(0,jsx_runtime.jsx)(menu_Menu.Item, {\n            text: "Foo"\n          }), /*#__PURE__*/(0,jsx_runtime.jsx)(menu_Menu.Item, {\n            text: "Bar"\n          }), /*#__PURE__*/(0,jsx_runtime.jsx)(menu_Menu.Item, {\n            text: "Baz"\n          })]\n        })\n      })\n    })]\n  });\n}\n;// CONCATENATED MODULE: ./docs/src/pages/Radio/index.jsx\nfunction Radio_slicedToArray(arr, i) { return Radio_arrayWithHoles(arr) || Radio_iterableToArrayLimit(arr, i) || Radio_unsupportedIterableToArray(arr, i) || Radio_nonIterableRest(); }\n\nfunction Radio_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction Radio_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return Radio_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return Radio_arrayLikeToArray(o, minLen); }\n\nfunction Radio_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction Radio_iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction Radio_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\n\n\n\n\n\n\n\nvar Radio_id = \'radio\';\nvar Radio_title = \'Radio\';\nvar Radio_description = \'Radio buttons allow users to select one option from a set.\';\nvar Radio_links = {\n  docs: \'https://github.com/material-components/material-components-web/tree/master/packages/mdc-radio\',\n  guide: \'https://material.io/components/radio-buttons\'\n};\nfunction RadioPage() {\n  var _useState = (0,react.useState)(\'yes\'),\n      _useState2 = Radio_slicedToArray(_useState, 2),\n      value1 = _useState2[0],\n      setValue1 = _useState2[1];\n\n  var _useState3 = (0,react.useState)(\'yes\'),\n      _useState4 = Radio_slicedToArray(_useState3, 2),\n      value2 = _useState4[0],\n      setValue2 = _useState4[1];\n\n  var handleChange1 = (0,react.useCallback)(function (event, value) {\n    setValue1(value);\n  }, []);\n  var handleChange2 = (0,react.useCallback)(function (event, value) {\n    setValue2(value);\n  }, []);\n  return /*#__PURE__*/(0,jsx_runtime.jsxs)(Page, {\n    id: Radio_id,\n    title: Radio_title,\n    description: Radio_description,\n    links: Radio_links,\n    children: [/*#__PURE__*/(0,jsx_runtime.jsx)(Section, {\n      title: "Basic radio",\n      children: /*#__PURE__*/(0,jsx_runtime.jsxs)(Code, {\n        children: [/*#__PURE__*/(0,jsx_runtime.jsx)(form_field_FormField, {\n          label: "Yes",\n          children: /*#__PURE__*/(0,jsx_runtime.jsx)(radio_Radio, {\n            name: "answer1",\n            value: "yes",\n            checked: value1 === \'yes\',\n            onChange: handleChange1\n          })\n        }), /*#__PURE__*/(0,jsx_runtime.jsx)(form_field_FormField, {\n          label: "No",\n          children: /*#__PURE__*/(0,jsx_runtime.jsx)(radio_Radio, {\n            name: "answer1",\n            value: "no",\n            checked: value1 === \'no\',\n            onChange: handleChange1\n          })\n        }), /*#__PURE__*/(0,jsx_runtime.jsx)(form_field_FormField, {\n          label: "Maybe",\n          children: /*#__PURE__*/(0,jsx_runtime.jsx)(radio_Radio, {\n            name: "answer1",\n            value: "maybe",\n            checked: value1 === \'maybe\',\n            onChange: handleChange1\n          })\n        })]\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Section, {\n      title: "Disabled radio",\n      children: /*#__PURE__*/(0,jsx_runtime.jsxs)(Code, {\n        children: [/*#__PURE__*/(0,jsx_runtime.jsx)(form_field_FormField, {\n          label: "Yes",\n          children: /*#__PURE__*/(0,jsx_runtime.jsx)(radio_Radio, {\n            name: "answer2",\n            value: "yes",\n            checked: value2 === \'yes\',\n            onChange: handleChange2\n          })\n        }), /*#__PURE__*/(0,jsx_runtime.jsx)(form_field_FormField, {\n          label: "No",\n          children: /*#__PURE__*/(0,jsx_runtime.jsx)(radio_Radio, {\n            name: "answer2",\n            value: "no",\n            checked: value2 === \'no\',\n            onChange: handleChange2\n          })\n        }), /*#__PURE__*/(0,jsx_runtime.jsx)(form_field_FormField, {\n          label: "Maybe",\n          children: /*#__PURE__*/(0,jsx_runtime.jsx)(radio_Radio, {\n            name: "answer2",\n            value: "maybe",\n            checked: value2 === \'maybe\',\n            disabled: true,\n            onChange: handleChange2\n          })\n        })]\n      })\n    })]\n  });\n}\n;// CONCATENATED MODULE: ./docs/src/pages/Ripple/index.jsx\n\n\n\n\nfunction Ripple_RadioPage() {\n  return /*#__PURE__*/(0,jsx_runtime.jsx)(Page, {\n    title: "Ripple",\n    children: /*#__PURE__*/(0,jsx_runtime.jsx)(Section, {\n      title: "Basic ripple",\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(elevation_Elevation, {\n        z: "5",\n        children: /*#__PURE__*/(0,jsx_runtime.jsx)(ripple_RippleSurface, {\n          style: {\n            height: \'100px\'\n          }\n        })\n      })\n    })\n  });\n}\n;// CONCATENATED MODULE: ./docs/src/pages/SegmentedButton/index.jsx\nfunction SegmentedButton_slicedToArray(arr, i) { return SegmentedButton_arrayWithHoles(arr) || SegmentedButton_iterableToArrayLimit(arr, i) || SegmentedButton_unsupportedIterableToArray(arr, i) || SegmentedButton_nonIterableRest(); }\n\nfunction SegmentedButton_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction SegmentedButton_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return SegmentedButton_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return SegmentedButton_arrayLikeToArray(o, minLen); }\n\nfunction SegmentedButton_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction SegmentedButton_iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction SegmentedButton_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\n\n\n\n\n\n\n\nvar SegmentedButton_id = \'segmented-button\';\nvar SegmentedButton_title = \'Segmented Button\';\nvar SegmentedButton_description = \'Segmented buttons allow users to toggle the selected states of grouped buttons.\';\nvar SegmentedButton_links = {\n  docs: \'https://github.com/material-components/material-components-web/tree/master/packages/mdc-segmented-button\',\n  guide: \'https://material.io/components/buttons#toggle-button\'\n};\nfunction SegmentedButtonPage() {\n  var _useState = (0,react.useState)(\'star\'),\n      _useState2 = SegmentedButton_slicedToArray(_useState, 2),\n      value1 = _useState2[0],\n      setValue1 = _useState2[1];\n\n  var _useState3 = (0,react.useState)(\'star\'),\n      _useState4 = SegmentedButton_slicedToArray(_useState3, 2),\n      value2 = _useState4[0],\n      setValue2 = _useState4[1];\n\n  var _useState5 = (0,react.useState)(\'star\'),\n      _useState6 = SegmentedButton_slicedToArray(_useState5, 2),\n      value3 = _useState6[0],\n      setValue3 = _useState6[1];\n\n  return /*#__PURE__*/(0,jsx_runtime.jsxs)(Page, {\n    id: SegmentedButton_id,\n    title: SegmentedButton_title,\n    description: SegmentedButton_description,\n    links: SegmentedButton_links,\n    children: [/*#__PURE__*/(0,jsx_runtime.jsx)(Section, {\n      title: "Text",\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(Code, {\n        children: /*#__PURE__*/(0,jsx_runtime.jsxs)(segmented_button_SegmentedButton, {\n          value: value1,\n          onChange: setValue1,\n          children: [/*#__PURE__*/(0,jsx_runtime.jsx)(segmented_button_SegmentedButton.Segment, {\n            value: "star",\n            label: "star"\n          }), /*#__PURE__*/(0,jsx_runtime.jsx)(segmented_button_SegmentedButton.Segment, {\n            value: "favorite",\n            label: "favorite"\n          })]\n        })\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Section, {\n      title: "Icons",\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(Code, {\n        children: /*#__PURE__*/(0,jsx_runtime.jsxs)(segmented_button_SegmentedButton, {\n          value: value2,\n          onChange: setValue2,\n          children: [/*#__PURE__*/(0,jsx_runtime.jsx)(segmented_button_SegmentedButton.Segment, {\n            value: "star",\n            icon: "star"\n          }), /*#__PURE__*/(0,jsx_runtime.jsx)(segmented_button_SegmentedButton.Segment, {\n            value: "favorite",\n            icon: "favorite"\n          })]\n        })\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Section, {\n      title: "Text with Icons",\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(Code, {\n        children: /*#__PURE__*/(0,jsx_runtime.jsxs)(segmented_button_SegmentedButton, {\n          value: value3,\n          onChange: setValue3,\n          children: [/*#__PURE__*/(0,jsx_runtime.jsx)(segmented_button_SegmentedButton.Segment, {\n            value: "star",\n            icon: "star",\n            label: "star"\n          }), /*#__PURE__*/(0,jsx_runtime.jsx)(segmented_button_SegmentedButton.Segment, {\n            value: "favorite",\n            icon: "favorite",\n            label: "favorite"\n          })]\n        })\n      })\n    })]\n  });\n}\n;// CONCATENATED MODULE: ./docs/src/pages/Select/index.jsx\nfunction pages_Select_slicedToArray(arr, i) { return pages_Select_arrayWithHoles(arr) || pages_Select_iterableToArrayLimit(arr, i) || pages_Select_unsupportedIterableToArray(arr, i) || pages_Select_nonIterableRest(); }\n\nfunction pages_Select_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction pages_Select_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return pages_Select_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return pages_Select_arrayLikeToArray(o, minLen); }\n\nfunction pages_Select_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction pages_Select_iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction pages_Select_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\n\n\n\n\n\n\nvar Select_id = \'select\';\nvar Select_title = \'Select\';\nvar Select_description = \'Segmented buttons allow users to toggle the selected states of grouped buttons.\';\nvar Select_links = {\n  docs: \'https://github.com/material-components/material-components-web/tree/master/packages/mdc-select\'\n};\nfunction SelectPage() {\n  var _useState = (0,react.useState)(),\n      _useState2 = pages_Select_slicedToArray(_useState, 2),\n      filled = _useState2[0],\n      setFilled = _useState2[1];\n\n  var _useState3 = (0,react.useState)(),\n      _useState4 = pages_Select_slicedToArray(_useState3, 2),\n      outlined = _useState4[0],\n      setOutlined = _useState4[1];\n\n  var _useState5 = (0,react.useState)(\'foo\'),\n      _useState6 = pages_Select_slicedToArray(_useState5, 2),\n      preselected = _useState6[0],\n      setPreselected = _useState6[1];\n\n  var _useState7 = (0,react.useState)([]),\n      _useState8 = pages_Select_slicedToArray(_useState7, 2),\n      multiple = _useState8[0],\n      setMultiple = _useState8[1];\n\n  var _useState9 = (0,react.useState)(),\n      _useState10 = pages_Select_slicedToArray(_useState9, 2),\n      icon = _useState10[0],\n      setIcon = _useState10[1];\n\n  return /*#__PURE__*/(0,jsx_runtime.jsxs)(Page, {\n    id: Select_id,\n    title: Select_title,\n    description: Select_description,\n    links: Select_links,\n    children: [/*#__PURE__*/(0,jsx_runtime.jsx)(Demo, {\n      title: "Filled select",\n      children: /*#__PURE__*/(0,jsx_runtime.jsxs)(select_Select, {\n        label: "Choose",\n        value: filled,\n        filled: true,\n        onChange: function onChange(event, value) {\n          return setFilled(value);\n        },\n        children: [/*#__PURE__*/(0,jsx_runtime.jsx)(select_Select.Option, {\n          value: "foo",\n          text: "Foo"\n        }), /*#__PURE__*/(0,jsx_runtime.jsx)(select_Select.Option, {\n          value: "bar",\n          text: "Bar"\n        }), /*#__PURE__*/(0,jsx_runtime.jsx)(select_Select.Option, {\n          value: "baz",\n          text: "Baz"\n        })]\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Demo, {\n      title: "Outlined select",\n      children: /*#__PURE__*/(0,jsx_runtime.jsxs)(select_Select, {\n        label: "Choose",\n        value: outlined,\n        outlined: true,\n        onChange: function onChange(event, value) {\n          return setOutlined(value);\n        },\n        children: [/*#__PURE__*/(0,jsx_runtime.jsx)(select_Select.Option, {\n          value: "foo",\n          text: "Foo"\n        }), /*#__PURE__*/(0,jsx_runtime.jsx)(select_Select.Option, {\n          value: "bar",\n          text: "Bar"\n        }), /*#__PURE__*/(0,jsx_runtime.jsx)(select_Select.Option, {\n          value: "baz",\n          text: "Baz"\n        })]\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Demo, {\n      title: "Preselected select",\n      children: /*#__PURE__*/(0,jsx_runtime.jsxs)(select_Select, {\n        label: "Choose",\n        value: preselected,\n        filled: true,\n        onChange: function onChange(event, value) {\n          return setPreselected(value);\n        },\n        children: [/*#__PURE__*/(0,jsx_runtime.jsx)(select_Select.Option, {\n          value: "foo",\n          text: "Foo"\n        }), /*#__PURE__*/(0,jsx_runtime.jsx)(select_Select.Option, {\n          value: "bar",\n          text: "Bar"\n        }), /*#__PURE__*/(0,jsx_runtime.jsx)(select_Select.Option, {\n          value: "baz",\n          text: "Baz"\n        })]\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Demo, {\n      title: "Multiple select",\n      children: /*#__PURE__*/(0,jsx_runtime.jsxs)(select_Select, {\n        label: "Choose",\n        value: multiple,\n        filled: true,\n        onChange: function onChange(event, value) {\n          return setMultiple(value);\n        },\n        children: [/*#__PURE__*/(0,jsx_runtime.jsx)(select_Select.Option, {\n          value: "foo",\n          text: "Foo"\n        }), /*#__PURE__*/(0,jsx_runtime.jsx)(select_Select.Option, {\n          value: "bar",\n          text: "Bar"\n        }), /*#__PURE__*/(0,jsx_runtime.jsx)(select_Select.Option, {\n          value: "baz",\n          text: "Baz"\n        })]\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Demo, {\n      title: "Select with an icon",\n      children: /*#__PURE__*/(0,jsx_runtime.jsxs)(select_Select, {\n        label: "Choose",\n        value: icon,\n        icon: "star",\n        filled: true,\n        onChange: function onChange(event, value) {\n          return setIcon(value);\n        },\n        children: [/*#__PURE__*/(0,jsx_runtime.jsx)(select_Select.Option, {\n          value: "foo",\n          text: "Foo"\n        }), /*#__PURE__*/(0,jsx_runtime.jsx)(select_Select.Option, {\n          value: "bar",\n          text: "Bar"\n        }), /*#__PURE__*/(0,jsx_runtime.jsx)(select_Select.Option, {\n          value: "baz",\n          text: "Baz"\n        })]\n      })\n    })]\n  });\n}\n;// CONCATENATED MODULE: ./docs/src/pages/SideSheet/index.jsx\nfunction SideSheet_slicedToArray(arr, i) { return SideSheet_arrayWithHoles(arr) || SideSheet_iterableToArrayLimit(arr, i) || SideSheet_unsupportedIterableToArray(arr, i) || SideSheet_nonIterableRest(); }\n\nfunction SideSheet_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction SideSheet_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return SideSheet_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return SideSheet_arrayLikeToArray(o, minLen); }\n\nfunction SideSheet_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction SideSheet_iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction SideSheet_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\n\n\n\n\n\n\n\nvar SideSheet_id = \'side-sheet\';\nvar SideSheet_title = \'Side Sheet\';\nvar SideSheet_description = \'Side sheets are surfaces containing supplementary content that are anchored to the left or right edge of the screen.\';\nvar SideSheet_links = {\n  guide: \'https://material.io/components/sheets-side\'\n};\nfunction SideSheetPage() {\n  var _useState = (0,react.useState)(false),\n      _useState2 = SideSheet_slicedToArray(_useState, 2),\n      isDismissibleOpen = _useState2[0],\n      setDismissibleOpen = _useState2[1];\n\n  var _useState3 = (0,react.useState)(false),\n      _useState4 = SideSheet_slicedToArray(_useState3, 2),\n      isModalOpen = _useState4[0],\n      setModalOpen = _useState4[1];\n\n  return /*#__PURE__*/(0,jsx_runtime.jsxs)(Page, {\n    id: SideSheet_id,\n    title: SideSheet_title,\n    description: SideSheet_description,\n    links: SideSheet_links,\n    children: [/*#__PURE__*/(0,jsx_runtime.jsx)(Section, {\n      title: "Basic side sheet",\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(Code, {\n        children: /*#__PURE__*/(0,jsx_runtime.jsx)(side_sheet_SideSheet, {\n          title: "Title",\n          children: "Content"\n        })\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Section, {\n      title: "Dismissible side sheet",\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(Code, {\n        setup: /*#__PURE__*/(0,jsx_runtime.jsx)(button_Button, {\n          label: "Toggle",\n          outlined: true,\n          onClick: function onClick() {\n            return setDismissibleOpen(function (v) {\n              return !v;\n            });\n          }\n        }),\n        children: /*#__PURE__*/(0,jsx_runtime.jsx)(side_sheet_SideSheet, {\n          title: "Title",\n          closeIcon: "close",\n          open: isDismissibleOpen,\n          dismissible: true,\n          onClose: function onClose() {\n            return setDismissibleOpen(false);\n          },\n          children: "Content"\n        })\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Section, {\n      title: "Modal side sheet",\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(Code, {\n        setup: /*#__PURE__*/(0,jsx_runtime.jsx)(button_Button, {\n          label: "Open",\n          outlined: true,\n          onClick: function onClick() {\n            return setModalOpen(true);\n          }\n        }),\n        children: /*#__PURE__*/(0,jsx_runtime.jsx)(side_sheet_SideSheet, {\n          title: "Title",\n          closeIcon: "close",\n          open: isModalOpen,\n          modal: true,\n          onClose: function onClose() {\n            return setModalOpen(false);\n          },\n          children: "Content"\n        })\n      })\n    })]\n  });\n}\n;// CONCATENATED MODULE: ./docs/src/pages/Slider/index.jsx\nfunction pages_Slider_slicedToArray(arr, i) { return pages_Slider_arrayWithHoles(arr) || pages_Slider_iterableToArrayLimit(arr, i) || pages_Slider_unsupportedIterableToArray(arr, i) || pages_Slider_nonIterableRest(); }\n\nfunction pages_Slider_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction pages_Slider_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return pages_Slider_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return pages_Slider_arrayLikeToArray(o, minLen); }\n\nfunction pages_Slider_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction pages_Slider_iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction pages_Slider_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\n\n\n\n\n\n\n\nvar Slider_id = \'slider\';\nvar Slider_title = \'Slider\';\nvar Slider_description = \'Sliders allow users to make selections from a range of values.\';\nvar Slider_links = {\n  docs: \'https://github.com/material-components/material-components-web/tree/master/packages/mdc-slider\',\n  guide: \'https://material.io/components/sliders\'\n};\nfunction SliderPage() {\n  var _useState = (0,react.useState)(50),\n      _useState2 = pages_Slider_slicedToArray(_useState, 2),\n      value1 = _useState2[0],\n      setValue1 = _useState2[1];\n\n  var _useState3 = (0,react.useState)(50),\n      _useState4 = pages_Slider_slicedToArray(_useState3, 2),\n      value2 = _useState4[0],\n      setValue2 = _useState4[1];\n\n  var _useState5 = (0,react.useState)(50),\n      _useState6 = pages_Slider_slicedToArray(_useState5, 2),\n      value3 = _useState6[0],\n      setValue3 = _useState6[1];\n\n  return /*#__PURE__*/(0,jsx_runtime.jsxs)(Page, {\n    id: Slider_id,\n    title: Slider_title,\n    description: Slider_description,\n    links: Slider_links,\n    children: [/*#__PURE__*/(0,jsx_runtime.jsx)(Section, {\n      title: "Continuous slider",\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(Code, {\n        children: /*#__PURE__*/(0,jsx_runtime.jsx)(slider_Slider, {\n          value: value1,\n          onChange: setValue1\n        })\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Section, {\n      title: "Discrete slider",\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(Code, {\n        children: /*#__PURE__*/(0,jsx_runtime.jsx)(slider_Slider, {\n          value: value2,\n          step: "10",\n          discrete: true,\n          onChange: setValue2\n        })\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Section, {\n      title: "Discrete slider with tick marks",\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(Code, {\n        children: /*#__PURE__*/(0,jsx_runtime.jsx)(slider_Slider, {\n          value: value3,\n          step: "10",\n          discrete: true,\n          tickMarks: true,\n          onChange: setValue3\n        })\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Section, {\n      title: "Disabled slider",\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(Code, {\n        children: /*#__PURE__*/(0,jsx_runtime.jsx)(slider_Slider, {\n          value: 42,\n          disabled: true\n        })\n      })\n    })]\n  });\n}\n;// CONCATENATED MODULE: ./docs/src/pages/Snackbar/index.jsx\nfunction Snackbar_slicedToArray(arr, i) { return Snackbar_arrayWithHoles(arr) || Snackbar_iterableToArrayLimit(arr, i) || Snackbar_unsupportedIterableToArray(arr, i) || Snackbar_nonIterableRest(); }\n\nfunction Snackbar_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction Snackbar_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return Snackbar_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return Snackbar_arrayLikeToArray(o, minLen); }\n\nfunction Snackbar_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction Snackbar_iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction Snackbar_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\n\n\n\n\n\n\n\nvar Snackbar_id = \'snackbar\';\nvar Snackbar_title = \'Snackbar\';\nvar Snackbar_description = \'Snackbars provide brief messages about app processes at the bottom of the screen.\';\nvar Snackbar_links = {\n  docs: \'https://github.com/material-components/material-components-web/tree/master/packages/mdc-snackbar\',\n  guide: \'https://material.io/components/snackbars\'\n};\nfunction SnackbarPage() {\n  var _useState = (0,react.useState)(false),\n      _useState2 = Snackbar_slicedToArray(_useState, 2),\n      isOpen = _useState2[0],\n      setOpen = _useState2[1];\n\n  var _useState3 = (0,react.useState)(5000),\n      _useState4 = Snackbar_slicedToArray(_useState3, 2),\n      timeout = _useState4[0],\n      setTimeout = _useState4[1];\n\n  var _useState5 = (0,react.useState)(false),\n      _useState6 = Snackbar_slicedToArray(_useState5, 2),\n      hasAction = _useState6[0],\n      setHasAction = _useState6[1];\n\n  var _useState7 = (0,react.useState)(false),\n      _useState8 = Snackbar_slicedToArray(_useState7, 2),\n      isLeading = _useState8[0],\n      setLeading = _useState8[1];\n\n  var _useState9 = (0,react.useState)(false),\n      _useState10 = Snackbar_slicedToArray(_useState9, 2),\n      isStacked = _useState10[0],\n      setStacked = _useState10[1];\n\n  return /*#__PURE__*/(0,jsx_runtime.jsx)(Page, {\n    id: Snackbar_id,\n    title: Snackbar_title,\n    description: Snackbar_description,\n    links: Snackbar_links,\n    children: /*#__PURE__*/(0,jsx_runtime.jsxs)(Section, {\n      title: "Demo",\n      children: [/*#__PURE__*/(0,jsx_runtime.jsxs)(layout_Layout, {\n        row: true,\n        children: [/*#__PURE__*/(0,jsx_runtime.jsxs)("fieldset", {\n          children: [/*#__PURE__*/(0,jsx_runtime.jsx)("legend", {\n            children: "Elements"\n          }), /*#__PURE__*/(0,jsx_runtime.jsx)(segmented_button_SegmentedButton, {\n            children: /*#__PURE__*/(0,jsx_runtime.jsx)(segmented_button_SegmentedButton.Segment, {\n              label: "Action",\n              selected: hasAction,\n              onClick: function onClick() {\n                return setHasAction(function (v) {\n                  return !v;\n                });\n              }\n            })\n          })]\n        }), /*#__PURE__*/(0,jsx_runtime.jsxs)("fieldset", {\n          children: [/*#__PURE__*/(0,jsx_runtime.jsx)("legend", {\n            children: "Variants"\n          }), /*#__PURE__*/(0,jsx_runtime.jsxs)(segmented_button_SegmentedButton, {\n            children: [/*#__PURE__*/(0,jsx_runtime.jsx)(segmented_button_SegmentedButton.Segment, {\n              label: "Leading",\n              selected: isLeading,\n              onClick: function onClick() {\n                return setLeading(function (v) {\n                  return !v;\n                });\n              }\n            }), /*#__PURE__*/(0,jsx_runtime.jsx)(segmented_button_SegmentedButton.Segment, {\n              label: "Stacked",\n              selected: isStacked,\n              onClick: function onClick() {\n                return setStacked(function (v) {\n                  return !v;\n                });\n              }\n            })]\n          })]\n        }), /*#__PURE__*/(0,jsx_runtime.jsx)(text_field_TextField, {\n          label: "Timeout",\n          value: timeout,\n          suffix: "ms",\n          outlined: true,\n          onChange: function onChange(_, value) {\n            return setTimeout(value);\n          }\n        })]\n      }), /*#__PURE__*/(0,jsx_runtime.jsx)(Code, {\n        setup: /*#__PURE__*/(0,jsx_runtime.jsx)(button_Button, {\n          label: "Show",\n          outlined: true,\n          onClick: function onClick() {\n            return setOpen(true);\n          }\n        }),\n        children: /*#__PURE__*/(0,jsx_runtime.jsx)(snackbar_Snackbar, {\n          open: isOpen,\n          timeout: timeout,\n          label: "Message",\n          action: hasAction ? /*#__PURE__*/(0,jsx_runtime.jsx)(button_Button, {\n            children: "Action"\n          }) : undefined,\n          leading: isLeading || undefined,\n          stacked: isStacked || undefined,\n          onClose: function onClose() {\n            return setOpen(undefined);\n          }\n        })\n      })]\n    })\n  });\n}\n;// CONCATENATED MODULE: ./docs/src/pages/Switch/index.jsx\nfunction Switch_slicedToArray(arr, i) { return Switch_arrayWithHoles(arr) || Switch_iterableToArrayLimit(arr, i) || Switch_unsupportedIterableToArray(arr, i) || Switch_nonIterableRest(); }\n\nfunction Switch_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction Switch_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return Switch_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return Switch_arrayLikeToArray(o, minLen); }\n\nfunction Switch_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction Switch_iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction Switch_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\n\n\n\n\n\n\nvar Switch_id = \'switch\';\nvar Switch_title = \'Switch\';\nvar Switch_description = \'Switches toggle the state of a single item on or off.\';\nvar Switch_links = {\n  docs: \'https://github.com/material-components/material-components-web/tree/master/packages/mdc-switch\',\n  guide: \'https://material.io/components/switches\'\n};\nfunction SwitchPage() {\n  var _useState = (0,react.useState)(false),\n      _useState2 = Switch_slicedToArray(_useState, 2),\n      isSelected = _useState2[0],\n      setSelected = _useState2[1];\n\n  return /*#__PURE__*/(0,jsx_runtime.jsxs)(Page, {\n    id: Switch_id,\n    title: Switch_title,\n    description: Switch_description,\n    links: Switch_links,\n    children: [/*#__PURE__*/(0,jsx_runtime.jsx)(Demo, {\n      title: "Basic switch",\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(switch_Switch, {\n        selected: isSelected,\n        onChange: function onChange() {\n          return setSelected(function (v) {\n            return !v;\n          });\n        }\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Demo, {\n      title: "Disabled switch",\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(switch_Switch, {\n        disabled: true\n      })\n    })]\n  });\n}\n;// CONCATENATED MODULE: ./docs/src/pages/Tabs/index.jsx\nfunction Tabs_slicedToArray(arr, i) { return Tabs_arrayWithHoles(arr) || Tabs_iterableToArrayLimit(arr, i) || Tabs_unsupportedIterableToArray(arr, i) || Tabs_nonIterableRest(); }\n\nfunction Tabs_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction Tabs_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return Tabs_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return Tabs_arrayLikeToArray(o, minLen); }\n\nfunction Tabs_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction Tabs_iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction Tabs_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\n\n\n\n\n\n\n\nvar Tabs_id = \'tabs\';\nvar Tabs_title = \'Tabs\';\nvar Tabs_description = \'Tabs organize content across different screens, data sets, and other interactions.\';\nvar Tabs_links = {\n  docs: \'https://github.com/material-components/material-components-web/tree/master/packages/mdc-tab-bar\',\n  guide: \'https://material.io/components/tabs\'\n};\nfunction Tabs_SwitchPage() {\n  var _useState = (0,react.useState)(0),\n      _useState2 = Tabs_slicedToArray(_useState, 2),\n      basic = _useState2[0],\n      setBasic = _useState2[1];\n\n  var _useState3 = (0,react.useState)(0),\n      _useState4 = Tabs_slicedToArray(_useState3, 2),\n      minWidth = _useState4[0],\n      setMinWidth = _useState4[1];\n\n  var _useState5 = (0,react.useState)(0),\n      _useState6 = Tabs_slicedToArray(_useState5, 2),\n      minWidthIndicator = _useState6[0],\n      setMinWidthIndicator = _useState6[1];\n\n  var _useState7 = (0,react.useState)(0),\n      _useState8 = Tabs_slicedToArray(_useState7, 2),\n      minWidthWithMinWidthIndicator = _useState8[0],\n      setMinWidthWithMinWidthIndicator = _useState8[1];\n\n  var _useState9 = (0,react.useState)(0),\n      _useState10 = Tabs_slicedToArray(_useState9, 2),\n      fade = _useState10[0],\n      setFade = _useState10[1];\n\n  var _useState11 = (0,react.useState)(0),\n      _useState12 = Tabs_slicedToArray(_useState11, 2),\n      icons = _useState12[0],\n      setIcons = _useState12[1];\n\n  var _useState13 = (0,react.useState)(0),\n      _useState14 = Tabs_slicedToArray(_useState13, 2),\n      stackedIcons = _useState14[0],\n      setStackedIcons = _useState14[1];\n\n  var _useState15 = (0,react.useState)(0),\n      _useState16 = Tabs_slicedToArray(_useState15, 2),\n      onlyIcons = _useState16[0],\n      setOnlyIcons = _useState16[1];\n\n  var _useState17 = (0,react.useState)(0),\n      _useState18 = Tabs_slicedToArray(_useState17, 2),\n      iconIndicator = _useState18[0],\n      setIconIndicator = _useState18[1];\n\n  var _useState19 = (0,react.useState)(0),\n      _useState20 = Tabs_slicedToArray(_useState19, 2),\n      scroll = _useState20[0],\n      setScroll = _useState20[1];\n\n  return /*#__PURE__*/(0,jsx_runtime.jsxs)(Page, {\n    id: Tabs_id,\n    title: Tabs_title,\n    description: Tabs_description,\n    links: Tabs_links,\n    children: [/*#__PURE__*/(0,jsx_runtime.jsx)(Section, {\n      title: "Basic tabs",\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(Code, {\n        children: /*#__PURE__*/(0,jsx_runtime.jsxs)(tabs_TabBar, {\n          value: basic,\n          onChange: function onChange(value) {\n            return setBasic(value);\n          },\n          children: [/*#__PURE__*/(0,jsx_runtime.jsx)(tabs_Tab, {\n            label: "Tab 1"\n          }), /*#__PURE__*/(0,jsx_runtime.jsx)(tabs_Tab, {\n            label: "Tab 2"\n          }), /*#__PURE__*/(0,jsx_runtime.jsx)(tabs_Tab, {\n            label: "Tab 3"\n          })]\n        })\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Section, {\n      title: "Min width tabs",\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(Code, {\n        children: /*#__PURE__*/(0,jsx_runtime.jsxs)(tabs_TabBar, {\n          value: minWidth,\n          minWidth: true,\n          onChange: function onChange(value) {\n            return setMinWidth(value);\n          },\n          children: [/*#__PURE__*/(0,jsx_runtime.jsx)(tabs_Tab, {\n            label: "Tab 1"\n          }), /*#__PURE__*/(0,jsx_runtime.jsx)(tabs_Tab, {\n            label: "Tab 2"\n          }), /*#__PURE__*/(0,jsx_runtime.jsx)(tabs_Tab, {\n            label: "Tab 3"\n          })]\n        })\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Section, {\n      title: "Tabs with min width indicator",\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(Code, {\n        children: /*#__PURE__*/(0,jsx_runtime.jsxs)(tabs_TabBar, {\n          value: minWidthIndicator,\n          minWidthIndicator: true,\n          onChange: function onChange(value) {\n            return setMinWidthIndicator(value);\n          },\n          children: [/*#__PURE__*/(0,jsx_runtime.jsx)(tabs_Tab, {\n            label: "Tab 1"\n          }), /*#__PURE__*/(0,jsx_runtime.jsx)(tabs_Tab, {\n            label: "Tab 2"\n          }), /*#__PURE__*/(0,jsx_runtime.jsx)(tabs_Tab, {\n            label: "Tab 3"\n          })]\n        })\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Section, {\n      title: "Min width tabs with min width indicator",\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(Code, {\n        children: /*#__PURE__*/(0,jsx_runtime.jsxs)(tabs_TabBar, {\n          value: minWidthWithMinWidthIndicator,\n          minWidth: true,\n          minWidthIndicator: true,\n          onChange: function onChange(value) {\n            return setMinWidthWithMinWidthIndicator(value);\n          },\n          children: [/*#__PURE__*/(0,jsx_runtime.jsx)(tabs_Tab, {\n            label: "Tab 1"\n          }), /*#__PURE__*/(0,jsx_runtime.jsx)(tabs_Tab, {\n            label: "Tab 2"\n          }), /*#__PURE__*/(0,jsx_runtime.jsx)(tabs_Tab, {\n            label: "Tab 3"\n          })]\n        })\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Section, {\n      title: "Tabs with fading indicator",\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(Code, {\n        children: /*#__PURE__*/(0,jsx_runtime.jsxs)(tabs_TabBar, {\n          value: fade,\n          fade: true,\n          onChange: function onChange(value) {\n            return setFade(value);\n          },\n          children: [/*#__PURE__*/(0,jsx_runtime.jsx)(tabs_Tab, {\n            label: "Tab 1"\n          }), /*#__PURE__*/(0,jsx_runtime.jsx)(tabs_Tab, {\n            label: "Tab 2"\n          }), /*#__PURE__*/(0,jsx_runtime.jsx)(tabs_Tab, {\n            label: "Tab 3"\n          })]\n        })\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Section, {\n      title: "Tabs with icons",\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(Code, {\n        children: /*#__PURE__*/(0,jsx_runtime.jsxs)(tabs_TabBar, {\n          value: icons,\n          onChange: function onChange(value) {\n            return setIcons(value);\n          },\n          children: [/*#__PURE__*/(0,jsx_runtime.jsx)(tabs_Tab, {\n            icon: "star",\n            label: "Tab 1"\n          }), /*#__PURE__*/(0,jsx_runtime.jsx)(tabs_Tab, {\n            icon: "favorite",\n            label: "Tab 2"\n          }), /*#__PURE__*/(0,jsx_runtime.jsx)(tabs_Tab, {\n            icon: "settings",\n            label: "Tab 3"\n          })]\n        })\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Section, {\n      title: "Tabs with stacked icons",\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(Code, {\n        children: /*#__PURE__*/(0,jsx_runtime.jsxs)(tabs_TabBar, {\n          value: stackedIcons,\n          stacked: true,\n          onChange: function onChange(value) {\n            return setStackedIcons(value);\n          },\n          children: [/*#__PURE__*/(0,jsx_runtime.jsx)(tabs_Tab, {\n            icon: "star",\n            label: "Tab 1"\n          }), /*#__PURE__*/(0,jsx_runtime.jsx)(tabs_Tab, {\n            icon: "favorite",\n            label: "Tab 2"\n          }), /*#__PURE__*/(0,jsx_runtime.jsx)(tabs_Tab, {\n            icon: "settings",\n            label: "Tab 3"\n          })]\n        })\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Section, {\n      title: "Tabs with icons only",\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(Code, {\n        children: /*#__PURE__*/(0,jsx_runtime.jsxs)(tabs_TabBar, {\n          value: onlyIcons,\n          indicatorIcon: "star",\n          onChange: function onChange(value) {\n            return setOnlyIcons(value);\n          },\n          children: [/*#__PURE__*/(0,jsx_runtime.jsx)(tabs_Tab, {\n            icon: "star"\n          }), /*#__PURE__*/(0,jsx_runtime.jsx)(tabs_Tab, {\n            icon: "favorite"\n          }), /*#__PURE__*/(0,jsx_runtime.jsx)(tabs_Tab, {\n            icon: "settings"\n          })]\n        })\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Section, {\n      title: "Tabs with icon indicator",\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(Code, {\n        children: /*#__PURE__*/(0,jsx_runtime.jsxs)(tabs_TabBar, {\n          value: iconIndicator,\n          onChange: function onChange(value) {\n            return setIconIndicator(value);\n          },\n          children: [/*#__PURE__*/(0,jsx_runtime.jsx)(tabs_Tab, {\n            label: "Tab 1"\n          }), /*#__PURE__*/(0,jsx_runtime.jsx)(tabs_Tab, {\n            label: "Tab 2"\n          }), /*#__PURE__*/(0,jsx_runtime.jsx)(tabs_Tab, {\n            label: "Tab 3"\n          })]\n        })\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Section, {\n      title: "Scrolling tabs",\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(Code, {\n        children: /*#__PURE__*/(0,jsx_runtime.jsxs)(tabs_TabBar, {\n          value: scroll,\n          onChange: function onChange(value) {\n            return setScroll(value);\n          },\n          children: [/*#__PURE__*/(0,jsx_runtime.jsx)(tabs_Tab, {\n            label: "Tab 1"\n          }), /*#__PURE__*/(0,jsx_runtime.jsx)(tabs_Tab, {\n            label: "Tab 2"\n          }), /*#__PURE__*/(0,jsx_runtime.jsx)(tabs_Tab, {\n            label: "Tab 3"\n          }), /*#__PURE__*/(0,jsx_runtime.jsx)(tabs_Tab, {\n            label: "Tab 4"\n          }), /*#__PURE__*/(0,jsx_runtime.jsx)(tabs_Tab, {\n            label: "Tab 5"\n          }), /*#__PURE__*/(0,jsx_runtime.jsx)(tabs_Tab, {\n            label: "Tab 6"\n          }), /*#__PURE__*/(0,jsx_runtime.jsx)(tabs_Tab, {\n            label: "Tab 7"\n          }), /*#__PURE__*/(0,jsx_runtime.jsx)(tabs_Tab, {\n            label: "Tab 8"\n          }), /*#__PURE__*/(0,jsx_runtime.jsx)(tabs_Tab, {\n            label: "Tab 9"\n          }), /*#__PURE__*/(0,jsx_runtime.jsx)(tabs_Tab, {\n            label: "Tab 10"\n          }), /*#__PURE__*/(0,jsx_runtime.jsx)(tabs_Tab, {\n            label: "Tab 11"\n          }), /*#__PURE__*/(0,jsx_runtime.jsx)(tabs_Tab, {\n            label: "Tab 12"\n          }), /*#__PURE__*/(0,jsx_runtime.jsx)(tabs_Tab, {\n            label: "Tab 13"\n          }), /*#__PURE__*/(0,jsx_runtime.jsx)(tabs_Tab, {\n            label: "Tab 14"\n          }), /*#__PURE__*/(0,jsx_runtime.jsx)(tabs_Tab, {\n            label: "Tab 15"\n          })]\n        })\n      })\n    })]\n  });\n}\n;// CONCATENATED MODULE: ./docs/src/pages/TextField/index.jsx\nfunction pages_TextField_slicedToArray(arr, i) { return pages_TextField_arrayWithHoles(arr) || pages_TextField_iterableToArrayLimit(arr, i) || pages_TextField_unsupportedIterableToArray(arr, i) || pages_TextField_nonIterableRest(); }\n\nfunction pages_TextField_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction pages_TextField_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return pages_TextField_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return pages_TextField_arrayLikeToArray(o, minLen); }\n\nfunction pages_TextField_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction pages_TextField_iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction pages_TextField_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\n\n\n\n\n\n\n\nvar TextField_id = \'text-field\';\nvar TextField_title = \'Text Field\';\nvar TextField_description = \'Text fields let users enter and edit text.\';\nvar TextField_links = {\n  docs: \'https://github.com/material-components/material-components-web/tree/master/packages/mdc-textfield\',\n  guide: \'https://material.io/components/text-fields\'\n};\nfunction TypographyPage() {\n  var _useState = (0,react.useState)(\'filled\'),\n      _useState2 = pages_TextField_slicedToArray(_useState, 2),\n      type = _useState2[0],\n      setType = _useState2[1];\n\n  var isFilled = type === \'filled\' || undefined;\n  var isOutlined = type === \'outlined\' || undefined;\n  return /*#__PURE__*/(0,jsx_runtime.jsxs)(Page, {\n    id: TextField_id,\n    title: TextField_title,\n    description: TextField_description,\n    links: TextField_links,\n    children: [/*#__PURE__*/(0,jsx_runtime.jsxs)(tabs_TabBar, {\n      value: type,\n      onChange: setType,\n      minWidth: true,\n      children: [/*#__PURE__*/(0,jsx_runtime.jsx)(tabs_Tab, {\n        value: "filled",\n        label: "Filled"\n      }), /*#__PURE__*/(0,jsx_runtime.jsx)(tabs_Tab, {\n        value: "outlined",\n        label: "Outlined"\n      })]\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Demo, {\n      title: "Basic text field",\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(text_field_TextField, {\n        defaultValue: "",\n        filled: isFilled,\n        outlined: isOutlined\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Demo, {\n      title: "Text field with a label",\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(text_field_TextField, {\n        defaultValue: "",\n        label: "Label",\n        filled: isFilled,\n        outlined: isOutlined\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Demo, {\n      title: "Textarea",\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(text_field_TextField, {\n        defaultValue: "",\n        label: "Label",\n        textarea: true,\n        filled: isFilled,\n        outlined: isOutlined\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Demo, {\n      title: "Autoresizable textarea",\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(text_field_TextField, {\n        defaultValue: "",\n        label: "Label",\n        textarea: true,\n        autoResize: true,\n        filled: isFilled,\n        outlined: isOutlined\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Demo, {\n      title: "Pre-filled text field",\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(text_field_TextField, {\n        defaultValue: "Some text",\n        label: "Label",\n        filled: isFilled,\n        outlined: isOutlined\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Demo, {\n      title: "With helper text",\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(text_field_TextField, {\n        defaultValue: "",\n        helperText: "Helper text",\n        filled: isFilled,\n        outlined: isOutlined\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Demo, {\n      title: "With persistent helper text",\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(text_field_TextField, {\n        defaultValue: "",\n        persistentHelperText: "Helper text",\n        filled: isFilled,\n        outlined: isOutlined\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Demo, {\n      title: "Text field with validation message",\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(text_field_TextField, {\n        defaultValue: "",\n        label: "Label",\n        required: true,\n        validationMessage: "Validation message",\n        filled: isFilled,\n        outlined: isOutlined\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Demo, {\n      title: "Text field with a character counter",\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(text_field_TextField, {\n        defaultValue: "",\n        label: "Label",\n        maxLength: 10,\n        characterCounter: true,\n        filled: isFilled,\n        outlined: isOutlined\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Demo, {\n      title: "Text field with an internal character counter",\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(text_field_TextField, {\n        defaultValue: "",\n        label: "Label",\n        maxLength: 120,\n        filled: isFilled,\n        outlined: isOutlined,\n        textarea: true,\n        characterCounter: "internal"\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Demo, {\n      title: "Text field with a prefix",\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(text_field_TextField, {\n        defaultValue: "",\n        label: "Label",\n        prefix: "@",\n        filled: isFilled,\n        outlined: isOutlined\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Demo, {\n      title: "Text field with a suffix",\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(text_field_TextField, {\n        defaultValue: "",\n        label: "Label",\n        suffix: "$",\n        filled: isFilled,\n        outlined: isOutlined\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Demo, {\n      title: "Text field with a leading icon",\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(text_field_TextField, {\n        defaultValue: "",\n        leadingIcon: "star",\n        filled: isFilled,\n        outlined: isOutlined\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Demo, {\n      title: "Text field with a trailing icon",\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(text_field_TextField, {\n        defaultValue: "",\n        trailingIcon: "edit",\n        filled: isFilled,\n        outlined: isOutlined\n      })\n    })]\n  });\n}\n;// CONCATENATED MODULE: ./docs/src/pages/Tooltip/index.jsx\n\n\n\n\n\n\nvar Tooltip_id = \'tooltip\';\nvar Tooltip_title = \'Tooltip\';\nvar Tooltip_description = \'Tooltips display informative text when users hover over, focus on, or tap an element.\';\nvar Tooltip_links = {\n  docs: \'https://github.com/material-components/material-components-web/tree/master/packages/mdc-tooltip\',\n  guide: \'https://material.io/components/tooltips\'\n};\nfunction TooltipPage() {\n  return /*#__PURE__*/(0,jsx_runtime.jsxs)(Page, {\n    id: Tooltip_id,\n    title: Tooltip_title,\n    description: Tooltip_description,\n    links: Tooltip_links,\n    children: [/*#__PURE__*/(0,jsx_runtime.jsx)(Section, {\n      title: "Basic tooltip",\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(Code, {\n        children: /*#__PURE__*/(0,jsx_runtime.jsx)(tooltip_Tooltip, {\n          label: "Star",\n          children: /*#__PURE__*/(0,jsx_runtime.jsx)(icon_button_IconButton, {\n            icon: "star"\n          })\n        })\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Section, {\n      title: "Multiline tooltip",\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(Code, {\n        children: /*#__PURE__*/(0,jsx_runtime.jsx)(tooltip_Tooltip, {\n          label: "This is a star icon button, you should click on it",\n          children: /*#__PURE__*/(0,jsx_runtime.jsx)(icon_button_IconButton, {\n            icon: "star"\n          })\n        })\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Section, {\n      title: "Rich tooltip",\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(Code, {\n        children: /*#__PURE__*/(0,jsx_runtime.jsx)(tooltip_RichTooltip, {\n          title: "Title",\n          content: "Default rich tooltips are shown when users hover over or focus on their anchor element. They remain shown when users focus/hover over the contents of the rich tooltip, but becomes hidden if the users focus/hover outside of the anchor element or the tooltip contents. If the user clicks within the contents of the tooltip, the tooltip will also be hidden.",\n          children: /*#__PURE__*/(0,jsx_runtime.jsx)(icon_button_IconButton, {\n            icon: "star"\n          })\n        })\n      })\n    })]\n  });\n}\n;// CONCATENATED MODULE: ./docs/src/pages/TopAppBar/index.jsx\nfunction pages_TopAppBar_slicedToArray(arr, i) { return pages_TopAppBar_arrayWithHoles(arr) || pages_TopAppBar_iterableToArrayLimit(arr, i) || pages_TopAppBar_unsupportedIterableToArray(arr, i) || pages_TopAppBar_nonIterableRest(); }\n\nfunction pages_TopAppBar_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction pages_TopAppBar_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return pages_TopAppBar_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return pages_TopAppBar_arrayLikeToArray(o, minLen); }\n\nfunction pages_TopAppBar_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction pages_TopAppBar_iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction pages_TopAppBar_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\n\n\n\n\n\n\n\n\nvar TopAppBar_id = \'top-app-bar\';\nvar TopAppBar_title = \'Top App Bar\';\nvar TopAppBar_description = \'The top app bar displays information and actions relating to the current screen.\';\nvar TopAppBar_links = {\n  docs: \'https://github.com/material-components/material-components-web/tree/master/packages/mdc-top-app-bar\',\n  guide: \'https://material.io/components/app-bars-top\'\n};\nfunction TopAppBarPage() {\n  var _useState = (0,react.useState)(false),\n      _useState2 = pages_TopAppBar_slicedToArray(_useState, 2),\n      isCollapsed = _useState2[0],\n      setCollapsed = _useState2[1];\n\n  var actionItems = [/*#__PURE__*/(0,jsx_runtime.jsx)(icon_button_IconButton, {\n    icon: "add"\n  }, "add"), /*#__PURE__*/(0,jsx_runtime.jsx)(icon_button_IconButton, {\n    icon: "edit"\n  }, "edit"), /*#__PURE__*/(0,jsx_runtime.jsx)(icon_button_IconButton, {\n    icon: "delete"\n  }, "delete")];\n  return /*#__PURE__*/(0,jsx_runtime.jsxs)(Page, {\n    id: TopAppBar_id,\n    title: TopAppBar_title,\n    description: TopAppBar_description,\n    links: TopAppBar_links,\n    children: [/*#__PURE__*/(0,jsx_runtime.jsx)(Section, {\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(Code, {\n        children: /*#__PURE__*/(0,jsx_runtime.jsx)(top_app_bar_TopAppBar, {\n          title: "Basic",\n          navigationIcon: "menu",\n          actionItems: actionItems\n        })\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Section, {\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(Code, {\n        children: /*#__PURE__*/(0,jsx_runtime.jsx)(top_app_bar_TopAppBar, {\n          title: "Dense",\n          navigationIcon: "menu",\n          actionItems: actionItems,\n          dense: true\n        })\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Section, {\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(Code, {\n        children: /*#__PURE__*/(0,jsx_runtime.jsx)(top_app_bar_TopAppBar, {\n          title: "Prominent",\n          navigationIcon: "menu",\n          actionItems: actionItems,\n          prominent: true\n        })\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Section, {\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(Code, {\n        children: /*#__PURE__*/(0,jsx_runtime.jsx)(top_app_bar_TopAppBar, {\n          title: "Short",\n          navigationIcon: "menu",\n          "short": true,\n          collapsed: isCollapsed,\n          onNavigationIconClick: function onNavigationIconClick() {\n            return setCollapsed(function (v) {\n              return !v;\n            });\n          }\n        })\n      })\n    })]\n  });\n}\n;// CONCATENATED MODULE: ./docs/src/pages/Typography/index.jsx\n\n\n\n\n\n\nvar Typography_id = \'typography\';\nvar Typography_title = \'Typography\';\nvar Typography_description = \'Typography expresses hierarchy and brand presence.\';\nvar Typography_links = {\n  docs: \'https://github.com/material-components/material-components-web/tree/master/packages/mdc-typography\',\n  guide: \'https://material.io/design/typography\'\n};\nfunction Typography_TypographyPage() {\n  return /*#__PURE__*/(0,jsx_runtime.jsxs)(Page, {\n    id: Typography_id,\n    title: Typography_title,\n    description: Typography_description,\n    links: Typography_links,\n    children: [/*#__PURE__*/(0,jsx_runtime.jsx)(Section, {\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(Code, {\n        children: /*#__PURE__*/(0,jsx_runtime.jsx)(typography_Typography, {\n          type: "headline1",\n          noMargin: true,\n          children: "Headline 1"\n        })\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Section, {\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(Code, {\n        children: /*#__PURE__*/(0,jsx_runtime.jsx)(typography_Typography, {\n          type: "headline2",\n          noMargin: true,\n          children: "Headline 2"\n        })\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Section, {\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(Code, {\n        children: /*#__PURE__*/(0,jsx_runtime.jsx)(typography_Typography, {\n          type: "headline3",\n          noMargin: true,\n          children: "Headline 3"\n        })\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Section, {\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(Code, {\n        children: /*#__PURE__*/(0,jsx_runtime.jsx)(typography_Typography, {\n          type: "headline4",\n          noMargin: true,\n          children: "Headline 4"\n        })\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Section, {\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(Code, {\n        children: /*#__PURE__*/(0,jsx_runtime.jsx)(typography_Typography, {\n          type: "headline5",\n          noMargin: true,\n          children: "Headline 5"\n        })\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Section, {\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(Code, {\n        children: /*#__PURE__*/(0,jsx_runtime.jsx)(typography_Typography, {\n          type: "headline6",\n          noMargin: true,\n          children: "Headline 6"\n        })\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Section, {\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(Code, {\n        children: /*#__PURE__*/(0,jsx_runtime.jsx)(typography_Typography, {\n          type: "subtitle1",\n          noMargin: true,\n          children: "Subtitle 1"\n        })\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Section, {\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(Code, {\n        children: /*#__PURE__*/(0,jsx_runtime.jsx)(typography_Typography, {\n          type: "subtitle2",\n          noMargin: true,\n          children: "Subtitle 2"\n        })\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Section, {\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(Code, {\n        children: /*#__PURE__*/(0,jsx_runtime.jsx)(typography_Typography, {\n          type: "body1",\n          noMargin: true,\n          children: "Body 1"\n        })\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Section, {\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(Code, {\n        children: /*#__PURE__*/(0,jsx_runtime.jsx)(typography_Typography, {\n          type: "body2",\n          noMargin: true,\n          children: "Body 2"\n        })\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Section, {\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(Code, {\n        children: /*#__PURE__*/(0,jsx_runtime.jsx)(typography_Typography, {\n          type: "caption",\n          children: "Caption"\n        })\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Section, {\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(Code, {\n        children: /*#__PURE__*/(0,jsx_runtime.jsx)(typography_Typography, {\n          type: "button",\n          children: "Button"\n        })\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Section, {\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(Code, {\n        children: /*#__PURE__*/(0,jsx_runtime.jsx)(typography_Typography, {\n          type: "overline",\n          children: "Overline"\n        })\n      })\n    })]\n  });\n}\n;// CONCATENATED MODULE: ./docs/src/pages/index.js\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n;// CONCATENATED MODULE: ./docs/src/routes.js\n\n/* harmony default export */ const routes = ([{\n  title: \'Avatar\',\n  url: \'/avatar\',\n  component: AvatarPage\n}, {\n  title: \'Badge\',\n  url: \'/badge\',\n  component: BadgePage\n}, {\n  title: \'Banner\',\n  url: \'/banner\',\n  component: Banner_BadgePage,\n  imageUrl: \'https://lh3.googleusercontent.com/tOZdWbfWtIc5GHTWsW0Daqj5I6lCCrUN8-YuEVjSn87JNN6x6PEjfmne-gpBo4jHBI4gqLmi0kLVpubF41ZT2mM8glkLzo2iWgK_-jY=w760-h380\'\n}, {\n  title: \'Button\',\n  url: \'/button\',\n  component: ButtonPage,\n  imageUrl: \'https://lh3.googleusercontent.com/GHRz-5S00u7WkRGl8iUm8ezoR6eoB2NJztu-trJv3raMDvpSACeQ5O0KOoAG7SRHJNDM_mT04Hei1NwjTN-ZsIFms_bsQ4zxRyxdQQ=w760-h380\'\n}, {\n  title: \'Card\',\n  url: \'/card\',\n  component: CardPage,\n  imageUrl: \'https://lh3.googleusercontent.com/FyE3qjGwwnoeMgiyOuIxdxTQQM9Cr0ftNakOXOA8cp137rKN09BFHraERm1NPUFBTGxVgchkdl6UABc11ZcJDML4ui466W2BFIxc9Q=w760-h380\'\n}, {\n  title: \'Checkbox\',\n  url: \'/checkbox\',\n  component: CheckboxPage\n}, {\n  title: \'Chips\',\n  url: \'/chips\',\n  component: ChipsPage\n}, {\n  title: \'Circular Progress\',\n  url: \'/circular-progress\',\n  component: CircularProgressPage\n}, {\n  title: \'DataTable\',\n  url: \'/data-table\',\n  component: DataTablePage\n}, {\n  title: \'Dialog\',\n  url: \'/dialog\',\n  component: DialogPage\n}, {\n  title: \'Drawer\',\n  url: \'/drawer\',\n  component: DrawerPage\n}, {\n  title: \'Elevation\',\n  url: \'/elevation\',\n  component: ElevationPage\n}, {\n  title: \'FAB\',\n  url: \'/fab\',\n  component: FABPage,\n  imageUrl: \'https://lh3.googleusercontent.com/T8dlYzaaU2SV86x6lqNMjlHcrFdKv85QMW1UnJShGwklRQyuUqZIklOjnEuqrZzF1h84ohrzz2ITajbT9IdljofNFmP5csEq6G7W=w760-h380\'\n}, {\n  title: \'Form Field\',\n  url: \'/form-field\',\n  component: FormFieldPage\n}, {\n  title: \'Icon Button\',\n  url: \'/icon-button\',\n  component: IconButtonPage\n}, {\n  title: \'Image List\',\n  url: \'/image-list\',\n  component: ImageListPage\n}, {\n  title: \'Layout Grid\',\n  url: \'/layout-grid\',\n  component: LayoutGridPage\n}, {\n  title: \'Linear Progress\',\n  url: \'/linear-progress\',\n  component: LinearProgressPage\n}, {\n  title: \'List\',\n  url: \'/list\',\n  component: ListPage\n}, {\n  title: \'Menu\',\n  url: \'/menu\',\n  component: MenuPage\n}, {\n  title: \'Radio\',\n  url: \'/radio\',\n  component: RadioPage\n}, {\n  title: \'Ripple\',\n  url: \'/ripple\',\n  component: Ripple_RadioPage\n}, {\n  title: \'Segmented Button\',\n  url: \'/segmented-button\',\n  component: SegmentedButtonPage,\n  imageUrl: \'\'\n}, {\n  title: \'Select\',\n  url: \'/select\',\n  component: SelectPage,\n  imageUrl: \'\'\n}, {\n  title: \'Side Sheet\',\n  url: \'/side-sheet\',\n  component: SideSheetPage,\n  imageUrl: \'\'\n}, {\n  title: \'Slider\',\n  url: \'/slider\',\n  component: SliderPage,\n  imageUrl: \'https://lh3.googleusercontent.com/w6nNeLcjpXypo2U6_gvunUesgTNOAqzEzb5ZzxxT4AyGH_M_L_EHrybg9sJNg78BDHyeCPIQCe3Hk2sTglU0EQe7cOBsqUMFicq1lg=w760-h380\'\n}, {\n  title: \'Snackbar\',\n  url: \'/snackbar\',\n  component: SnackbarPage,\n  imageUrl: \'https://lh3.googleusercontent.com/fGgZPDOszTD-2ReAC85l5op7wCE3uvnPta13Aib2bSlzN8LXoNYlDG6fY5DY1qKqbLTbGGlx9VgahUDdjDgdjq8sJNqoIY4-GPxKRA=w760-h380\'\n}, {\n  title: \'Switch\',\n  url: \'/switch\',\n  component: SwitchPage\n}, {\n  title: \'Tabs\',\n  url: \'/tabs\',\n  component: Tabs_SwitchPage,\n  imageUrl: \'https://lh3.googleusercontent.com/AYFp2VmMn9nslx18M6Es9C57S7p3zkiQVLl3PHvMu-OpbvK1FlLJN2MHfFNZfmfMCk1drCw84FKebz5STJ7QN69IHhH9WF1Kklir=w760-h380\'\n}, {\n  title: \'Text Field\',\n  url: \'/text-field\',\n  component: TypographyPage,\n  imageUrl: \'https://lh3.googleusercontent.com/Lxb_jZfXkASZ1DCzNhyS3IG7mIsPhBVmaX20Hn7XnwpS_Po9wQIC-5rEwUsYlb5TkgMjqI45-j1w4i4WM4wSlA-b0qKtmJ69hV0j=w760-h380\'\n}, {\n  title: \'Tooltip\',\n  url: \'/tooltip\',\n  component: TooltipPage,\n  imageUrl: \'https://lh3.googleusercontent.com/Asm1KHPsUD-GDDglcItzvl2LKWsyrMzKMrWDA5siHaF7PAvngniS57PMZTHFsDHkHsjT9dPWC5tEpRBG7i5syZ7sbRiRpL9oE84F=w760-h380\'\n}, {\n  title: \'Top App Bar\',\n  url: \'/top-app-bar\',\n  component: TopAppBarPage,\n  imageUrl: \'https://lh3.googleusercontent.com/eot96a-qjAr0QypKKf-6qSJGQQqW086-GV2vv0D9F358-VFiJSWifg6-q38vbI_JsxCPnbJNzjCH12OFDXJBzScB3h__HXLwKWkjYA=w760-h380\'\n}, {\n  title: \'Typography\',\n  url: \'/typography\',\n  component: Typography_TypographyPage\n}]);\n;// CONCATENATED MODULE: ./docs/src/App.jsx\n\n\n\n\n\n\n\nfunction App() {\n  return /*#__PURE__*/(0,jsx_runtime.jsxs)("div", {\n    className: "app",\n    children: [/*#__PURE__*/(0,jsx_runtime.jsx)(top_app_bar_TopAppBar, {\n      className: "app-top-bar",\n      navigationIcon: /*#__PURE__*/(0,jsx_runtime.jsx)(icon_button_IconButton, {\n        icon: /*#__PURE__*/(0,jsx_runtime.jsx)(Link, {\n          to: "/",\n          children: /*#__PURE__*/(0,jsx_runtime.jsx)("img", {\n            src: "https://material-components.github.io/material-components-web-catalog/static/media/ic_component_24px_white.svg",\n            alt: ""\n          })\n        })\n      }),\n      title: "MDC React",\n      actionItems: [/*#__PURE__*/(0,jsx_runtime.jsx)(icon_button_IconButton, {\n        element: "a",\n        href: "https://github.com/olegpolyakov/mdc-react",\n        target: "_blank",\n        icon: "code",\n        title: "Code"\n      }, "code"), /*#__PURE__*/(0,jsx_runtime.jsx)(icon_button_IconButton, {\n        element: "a",\n        href: "https://github.com/olegpolyakov/mdc-react/issues",\n        target: "_blank",\n        icon: "bug_report",\n        title: "Issues"\n      }, "issues"), /*#__PURE__*/(0,jsx_runtime.jsx)(icon_button_IconButton, {\n        element: "a",\n        href: "https://github.com/olegpolyakov/mdc-react/discussions",\n        target: "_blank",\n        icon: "forum",\n        title: "Discussions"\n      }, "discussions")]\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(drawer_Drawer, {\n      className: "app-drawer",\n      dismissible: true,\n      open: true,\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(drawer_Drawer.Content, {\n        children: /*#__PURE__*/(0,jsx_runtime.jsx)(list_List, {\n          element: "nav",\n          children: routes.map(function (route) {\n            return /*#__PURE__*/(0,jsx_runtime.jsx)(list_List.Item, {\n              component: NavLink,\n              to: route.url,\n              primaryText: route.title,\n              activeClassName: "mdc-list-item--activated"\n            }, route.url);\n          })\n        })\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)("main", {\n      className: "app-content mdc-drawer-app-content",\n      children: /*#__PURE__*/(0,jsx_runtime.jsxs)(Switch, {\n        children: [/*#__PURE__*/(0,jsx_runtime.jsx)(Route, {\n          exact: true,\n          path: "/",\n          component: HomePage\n        }), routes.map(function (route) {\n          return /*#__PURE__*/(0,jsx_runtime.jsx)(Route, {\n            path: route.url,\n            exact: route.exact,\n            component: route.component\n          }, route.url);\n        })]\n      })\n    })]\n  });\n}\n;// CONCATENATED MODULE: ./docs/src/index.js\n\n\n\n\n\nvar basename = {"WEBPACK_BUNDLE":true,"WEBPACK_BUILD":true,"production":true}.production ? \'mdc-react\' : undefined;\n(0,react_dom.render)( /*#__PURE__*/(0,jsx_runtime.jsx)(BrowserRouter, {\n  basename: basename,\n  children: /*#__PURE__*/(0,jsx_runtime.jsx)(App, {})\n}), document.querySelector(\'#root\'));//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFFVDtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsUUFBUTtBQUNSLFFBQVEsTUFBcUMsR0FBRyxDQUErRztBQUMvSjtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0EsSUFBSSxNQUFxQyxHQUFHLENBQWdQO0FBQzVSO0FBQ0EsbUJBQW1CLHNCQUFjO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLFFBQVE7QUFDUixRQUFRLE1BQXFDLEdBQUcsQ0FBa0g7QUFDbEs7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixRQUFRLFNBQVMsS0FBSztBQUNsRDtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0Esd0NBQXdDLHNCQUFzQjtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0EsRUFBRSxjQUFjOztBQUVoQjtBQUNBOztBQUVBLHdFQUF3RSxhQUFhO0FBQ3JGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQixlQUFlO0FBQ2Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixhQUFhO0FBQ2I7O0FBRUE7QUFDQSxXQUFXLGtCQUFrQjtBQUM3QixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLFdBQVcsa0JBQWtCO0FBQzdCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsdUJBQXVCO0FBQ2xDLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGtCQUFrQjtBQUMvQixjQUFjLGVBQWU7QUFDN0I7QUFDQSxrQ0FBa0MsT0FBTztBQUN6QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGtCQUFrQjtBQUNqQyxlQUFlLGtCQUFrQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyx3QkFBd0I7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxzQkFBc0IsY0FBYztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsZUFBZSxlQUFlLEtBQUssS0FBSyxXQUFXLEtBQUs7QUFDaEUscUJBQXFCLGNBQWMsT0FBTztBQUMxQyxRQUFRLGNBQWMsZUFBZSxRQUFRLEtBQUssY0FBYyxLQUFLLE9BQU87O0FBRTVFO0FBQ0EsUUFBUSxxQ0FBcUM7O0FBRTdDO0FBQ0EsUUFBUSxtREFBbUQ7QUFDM0QsUUFBUSx1Q0FBdUM7QUFDL0MsUUFBUSx1Q0FBdUM7O0FBRS9DO0FBQ0E7QUFDQSxRQUFRLDBCQUEwQjtBQUNsQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekIsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBLGdCQUFnQjtBQUNoQixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxpQkFBaUI7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFlBQVk7QUFDWjtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxZQUFZO0FBQ1o7QUFDQSxnQkFBZ0IsMENBQTBDO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxnREFBZ0Q7QUFDMUY7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLHFCQUFxQixxQkFBcUI7QUFDMUM7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMkRBQWUsVUFBVSxFQUFDOzs7QUMxckIxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSw0QkFBNEIsRUFBRSxhQUFhLEVBQUU7QUFDN0MsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxxREFBZSxJQUFJLEVBQUM7OztBQ3BqQnBCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsSUFBSTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHNEQUFlLEtBQUssRUFBQzs7O0FDN0JyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMERBQWUsU0FBUyxFQUFDOzs7QUNsQnpCO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWE7QUFDYjs7QUFFQTtBQUNBLFdBQVcsa0JBQWtCO0FBQzdCLGFBQWE7QUFDYjtBQUNBLFNBQVMsVUFBTTtBQUNmO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLFdBQVcsa0JBQWtCO0FBQzdCLGFBQWE7QUFDYjtBQUNBLFNBQVMsYUFBUztBQUNsQixTQUFTLFVBQU07QUFDZjs7QUFFQTtBQUNBLFdBQVcsa0JBQWtCO0FBQzdCLGFBQWE7QUFDYjtBQUNBO0FBQ0EsU0FBUyxVQUFNO0FBQ2Y7O0FBRUE7QUFDQSxXQUFXLHVCQUF1QjtBQUNsQyxhQUFhO0FBQ2I7QUFDQSxTQUFTLFVBQU07QUFDZixpQ0FBaUMsVUFBTTtBQUN2QztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsc0JBQXNCO0FBQ2pDLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFVBQU07QUFDMUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLFVBQU07QUFDNUI7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFVBQVUsY0FBYztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsZUFBZSxVQUFNO0FBQ3JCO0FBQ0EsVUFBVSxhQUFTLENBQUMsVUFBTTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxlQUFlLFVBQU07QUFDckI7QUFDQSxVQUFVLGFBQVMsQ0FBQyxVQUFNO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0RBQWUsR0FBRyxFQUFDOzs7QUMzU25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBMm9DLHdCQUFBLENBQXNCLFlBQXRCLEVBQW9DQyxvQkFBcEM7QUFDQUQsd0JBQUEsQ0FBc0IsTUFBdEIsRUFBOEJFLGNBQTlCO0FBQ0FGLHdCQUFBLENBQXNCLE9BQXRCLEVBQStCRyxlQUEvQjtBQUNBSCx3QkFBQSxDQUFzQixXQUF0QixFQUFtQ0ksbUJBQW5DO0FBQ0FKLHdCQUFBLENBQXNCLEtBQXRCLEVBQTZCSyxhQUE3QjtBQUVlLFNBQVNFLFNBQVQsQ0FBbUJDLElBQW5CLEVBQXlCQyxJQUF6QixFQUErQjtBQUMxQyxNQUFNQyxRQUFRLEdBQUdWLG1CQUFBLENBQWlCUyxJQUFqQixJQUF5QkEsSUFBekIsR0FBZ0MsV0FBakQ7QUFDQSxTQUFPVCxpQkFBQSxDQUFlUSxJQUFmLEVBQXFCO0FBQUVFLElBQUFBLFFBQVEsRUFBUkE7QUFBRixHQUFyQixFQUFtQ3ZtQyxLQUExQztBQUNILEM7O0FDaEJEO0FBQ0E7QUFFQTs7QUFFZSxTQUFTeW1DLElBQVQsT0FBa0M7QUFBQSxNQUFsQkgsSUFBa0IsUUFBbEJBLElBQWtCO0FBQUEsTUFBWjlvQyxRQUFZLFFBQVpBLFFBQVk7QUFDN0MsTUFBTWtwQyxJQUFJLEdBQUd6QixTQUFTLENBQUN6bkMsUUFBRCxDQUF0QjtBQUVBLHNCQUNJO0FBQUssYUFBUyxFQUFDLE1BQWY7QUFBQSwyQkFDSTtBQUFLLGVBQVMsMEJBQW1COG9DLElBQW5CLENBQWQ7QUFBQSw2QkFDSTtBQUNJLCtCQUF1QixFQUFFO0FBQUVLLFVBQUFBLE1BQU0sRUFBRVAsU0FBUyxDQUFDTSxJQUFELEVBQU8sS0FBUDtBQUFuQjtBQUQ3QjtBQURKO0FBREosSUFESjtBQVNILEM7Ozs7Ozs7Ozs7Ozs7O0FDakJEO0FBQ0E7QUFNQTtBQUVBO0FBRUE7OztBQUVlLFNBQVNFLElBQVQsT0FPWjtBQUFBLHdCQU5DemdDLEtBTUQ7QUFBQSxNQU5DQSxLQU1ELDJCQU5TLE1BTVQ7QUFBQSxNQUxDMGdDLFdBS0QsUUFMQ0EsV0FLRDtBQUFBLE1BSkNDLEtBSUQsUUFKQ0EsS0FJRDtBQUFBLE1BSENDLFFBR0QsUUFIQ0EsUUFHRDtBQUFBLE1BRkNWLElBRUQsUUFGQ0EsSUFFRDtBQUFBLDJCQURDN29DLFFBQ0Q7QUFBQSxNQURDQSxRQUNELDhCQURZNm9DLElBQ1o7O0FBQ0Msa0JBQWtDL3RCLGtCQUFRLENBQUMsSUFBRCxDQUExQztBQUFBO0FBQUEsTUFBTzB1QixVQUFQO0FBQUEsTUFBbUJDLFdBQW5COztBQUNBLG1CQUEwQzN1QixrQkFBUSxDQUFDLEtBQUQsQ0FBbEQ7QUFBQTtBQUFBLE1BQU80dUIsY0FBUDtBQUFBLE1BQXVCQyxlQUF2Qjs7QUFFQSxNQUFNeG9DLFVBQVUsR0FBR2hDLG9CQUFVLENBQUMsTUFBRCxFQUFTO0FBQ2xDLDJCQUF1Qm9xQztBQURXLEdBQVQsQ0FBN0I7QUFJQSxzQkFDSSxxQkFBQyxTQUFEO0FBQU0sV0FBTyxFQUFDLFNBQWQ7QUFBd0IsYUFBUyxFQUFFcG9DLFVBQW5DO0FBQStDLFlBQVEsTUFBdkQ7QUFBQSw0QkFDSSxvQkFBQyxnQkFBRDtBQUNJLFdBQUssRUFBRXdILEtBRFg7QUFFSSxhQUFPLEVBQUUsY0FDTCxvQkFBQyxzQkFBRDtBQUVJLFlBQUksRUFBRTZnQyxVQUFVLEdBQUcsVUFBSCxHQUFnQixNQUZwQztBQUdJLGFBQUssRUFBRUEsVUFBVSxHQUFHLFdBQUgsR0FBaUIsV0FIdEM7QUFHbUQsZUFBTyxFQUFFO0FBQUEsaUJBQU1DLFdBQVcsQ0FBQyxVQUFBdDVCLENBQUM7QUFBQSxtQkFBSSxDQUFDQSxDQUFMO0FBQUEsV0FBRixDQUFqQjtBQUFBO0FBSDVELFNBQ1EsTUFEUixDQURLLEVBTUxvNUIsUUFBUSxnQkFDSixvQkFBQyxzQkFBRDtBQUVJLFlBQUksRUFBQyxVQUZUO0FBR0ksYUFBSyxFQUFDLHdEQUhWO0FBSUksZUFBTyxFQUFFO0FBQUEsaUJBQU1JLGVBQWUsQ0FBQyxJQUFELENBQXJCO0FBQUE7QUFKYixTQUNRLFVBRFIsQ0FESSxHQU1DLElBWko7QUFGYixNQURKLEVBbUJLTixXQUFXLGlCQUNSLG9CQUFDLGlCQUFEO0FBQWMsZUFBUyxNQUF2QjtBQUFBLDZCQUNJLG9CQUFDLHFCQUFEO0FBQVksZ0JBQVEsTUFBcEI7QUFBQSxrQkFBc0JBO0FBQXRCO0FBREosTUFwQlIsZUF5QkkscUJBQUMsaUJBQUQ7QUFBYyxhQUFPLE1BQXJCO0FBQUEsaUJBQ0tDLEtBREwsRUFFS3RwQyxRQUZMO0FBQUEsTUF6QkosRUE4Qkt3cEMsVUFBVSxpQkFDUCxvQkFBQyxpQkFBRDtBQUFjLGVBQVMsTUFBdkI7QUFBQSw2QkFDSSxvQkFBQyxJQUFEO0FBQU0sWUFBSSxFQUFDLEtBQVg7QUFBQSxrQkFBa0J4cEM7QUFBbEI7QUFESixNQS9CUixFQW9DS3VwQyxRQUFRLGlCQUNMLG9CQUFDLG9CQUFEO0FBQ0ksV0FBSyxFQUFDLFVBRFY7QUFFSSxVQUFJLEVBQUVHLGNBRlYsQ0FHSTtBQUhKO0FBSUksZUFBUyxFQUFDLE9BSmQ7QUFLSSxhQUFPLEVBQUU7QUFBQSxlQUFNQyxlQUFlLENBQUMsS0FBRCxDQUFyQjtBQUFBLE9BTGI7QUFNSSxpQkFBVyxNQU5mO0FBQUEsNkJBUUksb0JBQUMsNEJBQUQ7QUFBQSxrQkFDS0o7QUFETDtBQVJKLE1BckNSO0FBQUEsSUFESjtBQXFESCxDOztBQ2pGRDs7O0FBRWUsU0FBU0ssUUFBVCxPQUF3QztBQUFBLE1BQXBCQyxNQUFvQixRQUFwQkEsTUFBb0I7QUFBQSxNQUFaN3BDLFFBQVksUUFBWkEsUUFBWTtBQUNuRCxzQkFDSTtBQUFBLDRCQUNJO0FBQUEsZ0JBQVM2cEM7QUFBVCxNQURKLEVBR0s3cEMsUUFITDtBQUFBLElBREo7QUFPSCxDOzs7Ozs7Ozs7Ozs7OztBQ1ZEO0FBRUE7OztBQUVlLFNBQVM4cEMsSUFBVCxPQVFaO0FBQUEsTUFQQ3ZaLEVBT0QsUUFQQ0EsRUFPRDtBQUFBLE1BTkM1bkIsS0FNRCxRQU5DQSxLQU1EO0FBQUEsTUFMQzBnQyxXQUtELFFBTENBLFdBS0Q7QUFBQSxNQUpDVSxLQUlELFFBSkNBLEtBSUQ7QUFBQSxNQUZDL3BDLFFBRUQsUUFGQ0EsUUFFRDtBQUFBLE1BRElDLEtBQ0o7O0FBQ0Msc0JBQ0k7QUFBUyxNQUFFLFlBQUtzd0IsRUFBTCxVQUFYO0FBQTJCLGFBQVMsRUFBQztBQUFyQyxLQUFnRHR3QixLQUFoRDtBQUFBLGVBQ0swSSxLQUFLLGlCQUNGO0FBQVEsZUFBUyxFQUFDLGFBQWxCO0FBQUEsOEJBQ0ksb0JBQUMscUJBQUQ7QUFBWSxpQkFBUyxFQUFDLFlBQXRCO0FBQW1DLFlBQUksRUFBQyxXQUF4QztBQUFvRCxnQkFBUSxNQUE1RDtBQUFBLGtCQUE4REE7QUFBOUQsUUFESixFQUdLMGdDLFdBQVcsaUJBQ1Isb0JBQUMscUJBQUQ7QUFBWSxpQkFBUyxFQUFDLGtCQUF0QjtBQUF5QyxZQUFJLEVBQUMsT0FBOUM7QUFBc0QsZ0JBQVEsTUFBOUQ7QUFBQSxrQkFBZ0VBO0FBQWhFLFFBSlIsRUFPS1UsS0FBSyxpQkFDRixxQkFBQyxTQUFEO0FBQUEsbUJBQ0tBLEtBQUssQ0FBQ0MsS0FBTixpQkFDRyxvQkFBQyxjQUFEO0FBQUEsaUNBQ0k7QUFBRyxnQkFBSSxFQUFFRCxLQUFLLENBQUNDLEtBQWY7QUFBc0Isa0JBQU0sRUFBQyxRQUE3QjtBQUFzQyxlQUFHLEVBQUMsWUFBMUM7QUFBQTtBQUFBO0FBREosVUFGUixFQU9LRCxLQUFLLENBQUNFLElBQU4saUJBQ0csb0JBQUMsY0FBRDtBQUFBLGlDQUNJO0FBQUcsZ0JBQUksRUFBRUYsS0FBSyxDQUFDRSxJQUFmO0FBQXFCLGtCQUFNLEVBQUMsUUFBNUI7QUFBcUMsZUFBRyxFQUFDLFlBQXpDO0FBQUE7QUFBQTtBQURKLFVBUlI7QUFBQSxRQVJSO0FBQUEsTUFGUixlQTJCSTtBQUFLLGVBQVMsRUFBQyxjQUFmO0FBQUEsZ0JBQ0tqcUM7QUFETCxNQTNCSjtBQUFBLEtBREo7QUFpQ0gsQzs7Ozs7Ozs7Ozs7Ozs7QUM5Q0Q7QUFDQTtBQUtBO0FBQ0E7QUFDQTs7OztBQUVBLElBQU11d0IsRUFBRSxHQUFHLFFBQVg7QUFDQSxJQUFNNW5CLEtBQUssR0FBRyxRQUFkO0FBQ0EsSUFBTTBnQyxXQUFXLEdBQUcsbUdBQXBCO0FBRWUsU0FBU2EsVUFBVCxHQUFzQjtBQUNqQyxrQkFBd0JwdkIsa0JBQVEsQ0FBQyxRQUFELENBQWhDO0FBQUE7QUFBQSxNQUFPamEsSUFBUDtBQUFBLE1BQWFzcEMsT0FBYjs7QUFDQSxtQkFBOEJydkIsa0JBQVEsQ0FBQyxPQUFELENBQXRDO0FBQUE7QUFBQSxNQUFPelYsT0FBUDtBQUFBLE1BQWdCK2tDLFVBQWhCOztBQUVBLHNCQUNJLG9CQUFDLElBQUQ7QUFDSSxNQUFFLEVBQUU3WixFQURSO0FBRUksU0FBSyxFQUFFNW5CLEtBRlg7QUFHSSxlQUFXLEVBQUUwZ0MsV0FIakI7QUFBQSwyQkFLSSxvQkFBQyxJQUFEO0FBQ0ksV0FBSyxFQUFDLE1BRFY7QUFFSSxjQUFRLGVBQ0o7QUFBQSxnQ0FDSSxvQkFBQyxRQUFEO0FBQVUsZ0JBQU0sRUFBQyxTQUFqQjtBQUFBLGlDQUNJLG9CQUFDLGdDQUFEO0FBQ0ksb0JBQVEsRUFBRSxDQUNOO0FBQUU3bUMsY0FBQUEsS0FBSyxFQUFFLE9BQVQ7QUFBa0I4RCxjQUFBQSxLQUFLLEVBQUU7QUFBekIsYUFETSxFQUVOO0FBQUU5RCxjQUFBQSxLQUFLLEVBQUUsTUFBVDtBQUFpQjhELGNBQUFBLEtBQUssRUFBRTtBQUF4QixhQUZNLEVBR047QUFBRTlELGNBQUFBLEtBQUssRUFBRSxNQUFUO0FBQWlCOEQsY0FBQUEsS0FBSyxFQUFFO0FBQXhCLGFBSE0sQ0FEZDtBQU1JLGlCQUFLLEVBQUVqQixPQU5YO0FBT0ksb0JBQVEsRUFBRStrQztBQVBkO0FBREosVUFESixlQWFJLG9CQUFDLFFBQUQ7QUFBVSxnQkFBTSxFQUFDLE1BQWpCO0FBQUEsaUNBQ0ksb0JBQUMsZ0NBQUQ7QUFDSSxvQkFBUSxFQUFFLENBQ047QUFBRTVuQyxjQUFBQSxLQUFLLEVBQUUsT0FBVDtBQUFrQjhELGNBQUFBLEtBQUssRUFBRTtBQUF6QixhQURNLEVBRU47QUFBRTlELGNBQUFBLEtBQUssRUFBRSxRQUFUO0FBQW1COEQsY0FBQUEsS0FBSyxFQUFFO0FBQTFCLGFBRk0sRUFHTjtBQUFFOUQsY0FBQUEsS0FBSyxFQUFFLE9BQVQ7QUFBa0I4RCxjQUFBQSxLQUFLLEVBQUU7QUFBekIsYUFITSxDQURkO0FBTUksaUJBQUssRUFBRXpGLElBTlg7QUFPSSxvQkFBUSxFQUFFc3BDO0FBUGQ7QUFESixVQWJKO0FBQUEsUUFIUjtBQUFBLDZCQThCSSxvQkFBQyxhQUFEO0FBQ0ksYUFBSyxFQUFFOWtDLE9BQU8sS0FBSyxPQUFaLEdBQXNCLHFDQUF0QixHQUE4RGlFLFNBRHpFO0FBRUksWUFBSSxFQUFFakUsT0FBTyxLQUFLLE1BQVosR0FBcUIsTUFBckIsR0FBOEJpRSxTQUZ4QztBQUdJLFlBQUksRUFBRWpFLE9BQU8sS0FBSyxNQUFaLEdBQXFCLElBQXJCLEdBQTRCaUUsU0FIdEM7QUFJSSxZQUFJLEVBQUV6STtBQUpWO0FBOUJKO0FBTEosSUFESjtBQTZDSCxDOzs7Ozs7Ozs7Ozs7OztBQy9ERDtBQUNBO0FBWUE7QUFDQTtBQUNBOztBQUVBLElBQU0wdkIsUUFBRSxHQUFHLE9BQVg7QUFDQSxJQUFNNW5CLFdBQUssR0FBRyxPQUFkO0FBQ0EsSUFBTTBnQyxpQkFBVyxHQUFHLG1FQUFwQjtBQUVBLElBQU1oa0MsT0FBTyxHQUFHO0FBQ1o4SSxFQUFBQSxNQUFNLGVBQUUsb0JBQUMsYUFBRDtBQUFRLFFBQUksRUFBQztBQUFiLElBREk7QUFFWi9GLEVBQUFBLE1BQU0sZUFBRSxvQkFBQyxhQUFEO0FBQVEsWUFBUSxNQUFoQjtBQUFBO0FBQUEsSUFGSTtBQUdackcsRUFBQUEsSUFBSSxlQUFFLG9CQUFDLFNBQUQ7QUFBQTtBQUFBLElBSE07QUFJWnNvQyxFQUFBQSxVQUFVLGVBQUUsb0JBQUMsc0JBQUQ7QUFBWSxRQUFJLEVBQUM7QUFBakIsSUFKQTtBQUtacm9DLEVBQUFBLElBQUksRUFBRTtBQUxNLENBQWhCO0FBUWUsU0FBU3NvQyxTQUFULEdBQXFCO0FBQ2hDLGtCQUEwQnh2QixrQkFBUSxDQUFDLENBQUQsQ0FBbEM7QUFBQTtBQUFBLE1BQU90WSxLQUFQO0FBQUEsTUFBYytuQyxRQUFkOztBQUNBLG1CQUF3Qnp2QixrQkFBUSxDQUFDLFFBQUQsQ0FBaEM7QUFBQTtBQUFBLE1BQU93TyxJQUFQO0FBQUEsTUFBYWtoQixPQUFiOztBQUNBLG1CQUEwQjF2QixrQkFBUSxDQUFDLEtBQUQsQ0FBbEM7QUFBQTtBQUFBLE1BQU9yWSxLQUFQO0FBQUEsTUFBY2dvQyxRQUFkOztBQUNBLG1CQUFzQzN2QixrQkFBUSxDQUFDLEtBQUQsQ0FBOUM7QUFBQTtBQUFBLE1BQU9wWSxXQUFQO0FBQUEsTUFBb0Jnb0MsY0FBcEI7O0FBRUEsc0JBQ0ksb0JBQUMsSUFBRDtBQUFNLE1BQUUsRUFBRW5hLFFBQVY7QUFBYyxTQUFLLEVBQUU1bkIsV0FBckI7QUFBNEIsZUFBVyxFQUFFMGdDLGlCQUF6QztBQUFBLDJCQUNJLG9CQUFDLElBQUQ7QUFDSSxjQUFRLEVBQUUsY0FDTixvQkFBQyxvQkFBRDtBQUVJLGFBQUssRUFBRTdtQyxLQUZYO0FBR0ksYUFBSyxFQUFDLE9BSFY7QUFJSSxnQkFBUSxNQUpaO0FBS0ksZ0JBQVEsRUFBRSxrQkFBQzAxQixDQUFELEVBQUkxMUIsS0FBSjtBQUFBLGlCQUFjK25DLFFBQVEsQ0FBQy9uQyxLQUFELENBQXRCO0FBQUE7QUFMZCxTQUNRLE9BRFIsQ0FETSxlQVNOLG9CQUFDLFFBQUQ7QUFBd0IsY0FBTSxFQUFDLFNBQS9CO0FBQUEsK0JBQ0ksb0JBQUMsZ0NBQUQ7QUFDSSxrQkFBUSxFQUFFLENBQ047QUFBRUEsWUFBQUEsS0FBSyxFQUFFLFFBQVQ7QUFBbUI4RCxZQUFBQSxLQUFLLEVBQUU7QUFBMUIsV0FETSxFQUVOO0FBQUU5RCxZQUFBQSxLQUFLLEVBQUUsUUFBVDtBQUFtQjhELFlBQUFBLEtBQUssRUFBRTtBQUExQixXQUZNLEVBR047QUFBRTlELFlBQUFBLEtBQUssRUFBRSxNQUFUO0FBQWlCOEQsWUFBQUEsS0FBSyxFQUFFO0FBQXhCLFdBSE0sRUFJTjtBQUFFOUQsWUFBQUEsS0FBSyxFQUFFLFlBQVQ7QUFBdUI4RCxZQUFBQSxLQUFLLEVBQUU7QUFBOUIsV0FKTSxFQUtOO0FBQUU5RCxZQUFBQSxLQUFLLEVBQUUsTUFBVDtBQUFpQjhELFlBQUFBLEtBQUssRUFBRTtBQUF4QixXQUxNLENBRGQ7QUFRSSxlQUFLLEVBQUVnakIsSUFSWDtBQVNJLGtCQUFRLEVBQUVraEI7QUFUZDtBQURKLFNBQWMsU0FBZCxDQVRNLGVBdUJOLG9CQUFDLG9CQUFEO0FBQXVCLGFBQUssRUFBQyxPQUE3QjtBQUFxQyxnQkFBUSxNQUE3QztBQUE4QyxvQkFBWSxNQUExRDtBQUFBLCtCQUNJLG9CQUFDLGFBQUQ7QUFDSSxrQkFBUSxFQUFFL25DLEtBRGQ7QUFFSSxrQkFBUSxFQUFFO0FBQUEsbUJBQU1nb0MsUUFBUSxDQUFDLFVBQUF0NkIsQ0FBQztBQUFBLHFCQUFJLENBQUNBLENBQUw7QUFBQSxhQUFGLENBQWQ7QUFBQTtBQUZkO0FBREosU0FBZSxPQUFmLENBdkJNLGVBOEJOLG9CQUFDLG9CQUFEO0FBQTZCLGFBQUssRUFBQyxhQUFuQztBQUFpRCxnQkFBUSxNQUF6RDtBQUEwRCxvQkFBWSxNQUF0RTtBQUFBLCtCQUNJLG9CQUFDLGFBQUQ7QUFDSSxrQkFBUSxFQUFFek4sV0FEZDtBQUVJLGtCQUFRLEVBQUU7QUFBQSxtQkFBTWdvQyxjQUFjLENBQUMsVUFBQXY2QixDQUFDO0FBQUEscUJBQUksQ0FBQ0EsQ0FBTDtBQUFBLGFBQUYsQ0FBcEI7QUFBQTtBQUZkO0FBREosU0FBZSxhQUFmLENBOUJNLENBRGQ7QUFBQSw2QkF1Q0ksb0JBQUMsV0FBRDtBQUNJLGFBQUssRUFBRTNOLEtBRFg7QUFFSSxhQUFLLEVBQUVDLEtBQUssSUFBSTZHLFNBRnBCO0FBR0ksbUJBQVcsRUFBRTVHLFdBQVcsSUFBSTRHLFNBSGhDO0FBQUEsa0JBS0tqRSxPQUFPLENBQUNpa0IsSUFBRDtBQUxaO0FBdkNKO0FBREosSUFESjtBQW1ESCxDOzs7Ozs7Ozs7Ozs7OztBQ3RGRDtBQUNBO0FBU0E7QUFDQTtBQUVBOzs7O0FBRUEsSUFBTWlILFNBQUUsR0FBRyxRQUFYO0FBQ0EsSUFBTTVuQixZQUFLLEdBQUcsUUFBZDtBQUNBLElBQU0wZ0Msa0JBQVcsR0FBRyxxRUFBcEI7QUFDQSxJQUFNVSxLQUFLLEdBQUc7QUFDVkUsRUFBQUEsSUFBSSxFQUFFLGdHQURJO0FBRVZELEVBQUFBLEtBQUssRUFBRTtBQUZHLENBQWQ7QUFLZSxTQUFTTSxnQkFBVCxHQUFxQjtBQUNoQyxrQkFBd0J4dkIsa0JBQVEsQ0FBQyxLQUFELENBQWhDO0FBQUE7QUFBQSxNQUFPdFcsSUFBUDtBQUFBLE1BQWFtbUMsT0FBYjs7QUFDQSxtQkFBd0I3dkIsa0JBQVEsQ0FBQyxhQUFELENBQWhDO0FBQUE7QUFBQSxNQUFPOVksSUFBUDtBQUFBLE1BQWE0b0MsT0FBYjs7QUFDQSxtQkFBOEI5dkIsa0JBQVEsQ0FBQyxLQUFELENBQXRDO0FBQUE7QUFBQSxNQUFPK3ZCLE9BQVA7QUFBQSxNQUFnQkMsVUFBaEI7O0FBQ0EsbUJBQXdCaHdCLGtCQUFRLENBQUMsRUFBRCxDQUFoQztBQUFBO0FBQUEsTUFBTy9ZLElBQVA7QUFBQSxNQUFhZ3BDLE9BQWI7O0FBQ0EsbUJBQWtDandCLGtCQUFRLENBQUMsS0FBRCxDQUExQztBQUFBO0FBQUEsTUFBT2t3QixTQUFQO0FBQUEsTUFBa0JDLFlBQWxCOztBQUNBLG9CQUE0Qm53QixrQkFBUSxDQUFDLEVBQUQsQ0FBcEM7QUFBQTtBQUFBLE1BQU96VyxNQUFQO0FBQUEsTUFBZTZtQyxTQUFmOztBQUNBLG9CQUFvRHB3QixrQkFBUSxDQUFDLEtBQUQsQ0FBNUQ7QUFBQTtBQUFBLE1BQU9xd0Isa0JBQVA7QUFBQSxNQUEyQkMscUJBQTNCOztBQUNBLG9CQUE4Q3R3QixrQkFBUSxDQUFDLEVBQUQsQ0FBdEQ7QUFBQTtBQUFBLE1BQU92VyxlQUFQO0FBQUEsTUFBd0I4bUMsa0JBQXhCOztBQUNBLG9CQUFnQ3Z3QixrQkFBUSxDQUFDLEtBQUQsQ0FBeEM7QUFBQTtBQUFBLE1BQU9yVyxRQUFQO0FBQUEsTUFBaUI2bUMsV0FBakI7O0FBQ0Esb0JBQTBCeHdCLGtCQUFRLENBQUMsS0FBRCxDQUFsQztBQUFBO0FBQUEsTUFBT3BXLEtBQVA7QUFBQSxNQUFjNm1DLFFBQWQ7O0FBQ0Esb0JBQTBDendCLGtCQUFRLENBQUMsS0FBRCxDQUFsRDtBQUFBO0FBQUEsTUFBT25XLGFBQVA7QUFBQSxNQUFzQjZtQyxnQkFBdEI7O0FBRUEsc0JBQ0ksb0JBQUMsSUFBRDtBQUFNLE1BQUUsRUFBRWpiLFNBQVY7QUFBYyxTQUFLLEVBQUU1bkIsWUFBckI7QUFBNEIsZUFBVyxFQUFFMGdDLGtCQUF6QztBQUFzRCxTQUFLLEVBQUVVLEtBQTdEO0FBQUEsMkJBQ0ksb0JBQUMsSUFBRDtBQUNJLFdBQUssRUFBQyxNQURWO0FBRUksV0FBSyxlQUNELG9CQUFDLHFCQUFEO0FBQ0ksYUFBSyxFQUFDLE9BRFY7QUFFSSxtQkFBVyxlQUNQLG9CQUFDLGFBQUQ7QUFDSSxlQUFLLEVBQUMsUUFEVjtBQUVJLGlCQUFPLEVBQUU7QUFBQSxtQkFBTVksT0FBTyxDQUFDLFVBQUF4NkIsQ0FBQztBQUFBLHFCQUFJLENBQUNBLENBQUw7QUFBQSxhQUFGLENBQWI7QUFBQTtBQUZiO0FBSFIsUUFIUjtBQWFJLGNBQVEsZUFBRTtBQUFBLGdDQUNOLG9CQUFDLG9CQUFEO0FBQ0ksZUFBSyxFQUFFbk8sSUFEWDtBQUVJLGVBQUssRUFBQyxNQUZWO0FBR0ksa0JBQVEsRUFBRSxrQkFBQ2syQixDQUFELEVBQUkxMUIsS0FBSjtBQUFBLG1CQUFjb29DLE9BQU8sQ0FBQ3BvQyxLQUFELENBQXJCO0FBQUEsV0FIZDtBQUlJLGtCQUFRO0FBSlosVUFETSxlQVFOLG9CQUFDLG9CQUFEO0FBQ0ksZUFBSyxFQUFFVCxJQURYO0FBRUksZUFBSyxFQUFDLE1BRlY7QUFHSSxzQkFBWSxlQUNSLG9CQUFDLGFBQUQ7QUFDSSxvQkFBUSxFQUFFOG9DLE9BRGQ7QUFFSSxvQkFBUSxFQUFFO0FBQUEscUJBQU1DLFVBQVUsQ0FBQyxVQUFBMzZCLENBQUM7QUFBQSx1QkFBSSxDQUFDQSxDQUFMO0FBQUEsZUFBRixDQUFoQjtBQUFBO0FBRmQsWUFKUjtBQVNJLGtCQUFRLE1BVFo7QUFVSSxrQkFBUSxFQUFFLENBQUMwNkIsT0FWZjtBQVdJLGtCQUFRLEVBQUUsa0JBQUMzUyxDQUFELEVBQUkxMUIsS0FBSjtBQUFBLG1CQUFjdW9DLE9BQU8sQ0FBQ3ZvQyxLQUFELENBQXJCO0FBQUE7QUFYZCxVQVJNLGVBc0JOLG9CQUFDLG9CQUFEO0FBQ0ksZUFBSyxFQUFFNkIsTUFEWDtBQUVJLGVBQUssRUFBQyxRQUZWO0FBR0ksc0JBQVksZUFDUixvQkFBQyxhQUFEO0FBQ0ksb0JBQVEsRUFBRTJtQyxTQURkO0FBRUksb0JBQVEsRUFBRTtBQUFBLHFCQUFNQyxZQUFZLENBQUMsVUFBQTk2QixDQUFDO0FBQUEsdUJBQUksQ0FBQ0EsQ0FBTDtBQUFBLGVBQUYsQ0FBbEI7QUFBQTtBQUZkLFlBSlI7QUFTSSxrQkFBUSxFQUFFLENBQUM2NkIsU0FUZjtBQVVJLGtCQUFRLE1BVlo7QUFXSSxrQkFBUSxFQUFFLGtCQUFDOVMsQ0FBRCxFQUFJMTFCLEtBQUo7QUFBQSxtQkFBYzBvQyxTQUFTLENBQUMxb0MsS0FBRCxDQUF2QjtBQUFBO0FBWGQsVUF0Qk0sZUFvQ04sb0JBQUMsb0JBQUQ7QUFDSSxlQUFLLEVBQUUrQixlQURYO0FBRUksZUFBSyxFQUFDLGtCQUZWO0FBR0ksc0JBQVksZUFDUixvQkFBQyxhQUFEO0FBQ0ksb0JBQVEsRUFBRTRtQyxrQkFEZDtBQUVJLG9CQUFRLEVBQUU7QUFBQSxxQkFBTUMscUJBQXFCLENBQUMsVUFBQWo3QixDQUFDO0FBQUEsdUJBQUksQ0FBQ0EsQ0FBTDtBQUFBLGVBQUYsQ0FBM0I7QUFBQTtBQUZkLFlBSlI7QUFTSSxrQkFBUSxFQUFFLENBQUNnN0Isa0JBVGY7QUFVSSxrQkFBUSxNQVZaO0FBV0ksa0JBQVEsRUFBRSxrQkFBQ2pULENBQUQsRUFBSTExQixLQUFKO0FBQUEsbUJBQWM2b0Msa0JBQWtCLENBQUM3b0MsS0FBRCxDQUFoQztBQUFBO0FBWGQsVUFwQ00sZUFrRE4sb0JBQUMsb0JBQUQ7QUFBVyxlQUFLLEVBQUMsVUFBakI7QUFBNEIsa0JBQVEsTUFBcEM7QUFBcUMsc0JBQVksTUFBakQ7QUFBQSxpQ0FDSSxvQkFBQyxhQUFEO0FBQ0ksb0JBQVEsRUFBRWlDLFFBRGQ7QUFFSSxvQkFBUSxFQUFFO0FBQUEscUJBQU02bUMsV0FBVyxDQUFDLFVBQUFuN0IsQ0FBQztBQUFBLHVCQUFJLENBQUNBLENBQUw7QUFBQSxlQUFGLENBQWpCO0FBQUE7QUFGZDtBQURKLFVBbERNLGVBeUROLG9CQUFDLG9CQUFEO0FBQVcsZUFBSyxFQUFDLE9BQWpCO0FBQXlCLGtCQUFRLE1BQWpDO0FBQWtDLHNCQUFZLE1BQTlDO0FBQUEsaUNBQ0ksb0JBQUMsYUFBRDtBQUNJLG9CQUFRLEVBQUV6TCxLQURkO0FBRUksb0JBQVEsRUFBRTtBQUFBLHFCQUFNNm1DLFFBQVEsQ0FBQyxVQUFBcDdCLENBQUM7QUFBQSx1QkFBSSxDQUFDQSxDQUFMO0FBQUEsZUFBRixDQUFkO0FBQUE7QUFGZDtBQURKLFVBekRNLGVBZ0VOLG9CQUFDLG9CQUFEO0FBQVcsZUFBSyxFQUFDLGdCQUFqQjtBQUFrQyxrQkFBUSxNQUExQztBQUEyQyxzQkFBWSxNQUF2RDtBQUFBLGlDQUNJLG9CQUFDLGFBQUQ7QUFDSSxvQkFBUSxFQUFFeEwsYUFEZDtBQUVJLG9CQUFRLEVBQUU7QUFBQSxxQkFBTTZtQyxnQkFBZ0IsQ0FBQyxVQUFBcjdCLENBQUM7QUFBQSx1QkFBSSxDQUFDQSxDQUFMO0FBQUEsZUFBRixDQUF0QjtBQUFBO0FBRmQ7QUFESixVQWhFTTtBQUFBLFFBYmQ7QUFBQSw2QkFxRkksb0JBQUMsYUFBRDtBQUNJLFlBQUksRUFBRW5PLElBRFY7QUFFSSxZQUFJLEVBQUU2b0MsT0FBTyxHQUFHOW9DLElBQUgsR0FBVXVILFNBRjNCO0FBR0ksY0FBTSxFQUFFMGhDLFNBQVMsZ0JBQ2Isb0JBQUMsYUFBRDtBQUFBLG9CQUFTM21DO0FBQVQsVUFEYSxHQUdiaUYsU0FOUjtBQVFJLHVCQUFlLEVBQUU2aEMsa0JBQWtCLGdCQUMvQixvQkFBQyxhQUFEO0FBQUEsb0JBQVM1bUM7QUFBVCxVQUQrQixHQUcvQitFLFNBWFI7QUFhSSxZQUFJLEVBQUU5RSxJQUFJLElBQUk4RSxTQWJsQjtBQWNJLGdCQUFRLEVBQUU3RSxRQUFRLElBQUk2RSxTQWQxQjtBQWVJLGFBQUssRUFBRTVFLEtBQUssSUFBSTRFLFNBZnBCO0FBZ0JJLHFCQUFhLEVBQUUzRSxhQUFhLElBQUkyRTtBQWhCcEM7QUFyRko7QUFESixJQURKO0FBNEdILEM7Ozs7Ozs7Ozs7Ozs7O0FDaEpEO0FBQ0E7QUFPQTtBQUNBO0FBQ0E7Ozs7QUFFQSxJQUFNaW5CLFNBQUUsR0FBRyxRQUFYO0FBQ0EsSUFBTTVuQixZQUFLLEdBQUcsUUFBZDtBQUNBLElBQU0wZ0Msa0JBQVcsR0FBRyxrSkFBcEI7QUFDQSxJQUFNVSxZQUFLLEdBQUc7QUFDVkUsRUFBQUEsSUFBSSxFQUFFLGdHQURJO0FBRVZELEVBQUFBLEtBQUssRUFBRTtBQUZHLENBQWQ7QUFLZSxTQUFTeUIsVUFBVCxHQUFzQjtBQUNqQyxrQkFBMEIzd0Isa0JBQVEsQ0FBQyxRQUFELENBQWxDO0FBQUE7QUFBQSxNQUFPeFUsS0FBUDtBQUFBLE1BQWNvbEMsUUFBZDs7QUFDQSxtQkFBNEM1d0Isa0JBQVEsQ0FBQyxLQUFELENBQXBEO0FBQUE7QUFBQSxNQUFPNndCLGNBQVA7QUFBQSxNQUF1QkMsaUJBQXZCOztBQUNBLG1CQUFzQzl3QixrQkFBUSxDQUFDLE1BQUQsQ0FBOUM7QUFBQTtBQUFBLE1BQU92VSxXQUFQO0FBQUEsTUFBb0JzbEMsY0FBcEI7O0FBQ0EsbUJBQThDL3dCLGtCQUFRLENBQUMsS0FBRCxDQUF0RDtBQUFBO0FBQUEsTUFBT2d4QixlQUFQO0FBQUEsTUFBd0JDLGtCQUF4Qjs7QUFDQSxtQkFBd0NqeEIsa0JBQVEsQ0FBQyxPQUFELENBQWhEO0FBQUE7QUFBQSxNQUFPdFUsWUFBUDtBQUFBLE1BQXFCd2xDLGVBQXJCOztBQUNBLG9CQUF3Qmx4QixrQkFBUSxDQUFDLE9BQUQsQ0FBaEM7QUFBQTtBQUFBLE1BQU93TyxJQUFQO0FBQUEsTUFBYWtoQixPQUFiOztBQUVBLHNCQUNJLG9CQUFDLElBQUQ7QUFBTSxNQUFFLEVBQUVqYSxTQUFWO0FBQWMsU0FBSyxFQUFFNW5CLFlBQXJCO0FBQTRCLGVBQVcsRUFBRTBnQyxrQkFBekM7QUFBc0QsU0FBSyxFQUFFVSxZQUE3RDtBQUFBLDJCQUNJLG9CQUFDLElBQUQ7QUFDSSxXQUFLLEVBQUMsTUFEVjtBQUVJLGNBQVEsZUFBRTtBQUFBLGdDQUNOLG9CQUFDLG9CQUFEO0FBQ0ksZUFBSyxFQUFFempDLEtBRFg7QUFFSSxlQUFLLEVBQUMsT0FGVjtBQUdJLGtCQUFRLE1BSFo7QUFJSSxrQkFBUSxFQUFFLGtCQUFDNHhCLENBQUQsRUFBSTExQixLQUFKO0FBQUEsbUJBQWNrcEMsUUFBUSxDQUFDbHBDLEtBQUQsQ0FBdEI7QUFBQTtBQUpkLFVBRE0sZUFRTixvQkFBQyxvQkFBRDtBQUNJLGVBQUssRUFBRStELFdBRFg7QUFFSSxlQUFLLEVBQUMsY0FGVjtBQUdJLHNCQUFZLGVBQ1Isb0JBQUMsYUFBRDtBQUNJLG9CQUFRLEVBQUVvbEMsY0FEZDtBQUVJLG9CQUFRLEVBQUU7QUFBQSxxQkFBTUMsaUJBQWlCLENBQUMsVUFBQXo3QixDQUFDO0FBQUEsdUJBQUksQ0FBQ0EsQ0FBTDtBQUFBLGVBQUYsQ0FBdkI7QUFBQTtBQUZkLFlBSlI7QUFTSSxrQkFBUSxNQVRaO0FBVUksa0JBQVEsRUFBRSxDQUFDdzdCLGNBVmY7QUFXSSxrQkFBUSxFQUFFLGtCQUFDelQsQ0FBRCxFQUFJMTFCLEtBQUo7QUFBQSxtQkFBY3FwQyxjQUFjLENBQUNycEMsS0FBRCxDQUE1QjtBQUFBO0FBWGQsVUFSTSxlQXNCTixvQkFBQyxvQkFBRDtBQUNJLGVBQUssRUFBRWdFLFlBRFg7QUFFSSxlQUFLLEVBQUMsZUFGVjtBQUdJLHNCQUFZLGVBQ1Isb0JBQUMsYUFBRDtBQUNJLG9CQUFRLEVBQUVzbEMsZUFEZDtBQUVJLG9CQUFRLEVBQUU7QUFBQSxxQkFBTUMsa0JBQWtCLENBQUMsVUFBQTU3QixDQUFDO0FBQUEsdUJBQUksQ0FBQ0EsQ0FBTDtBQUFBLGVBQUYsQ0FBeEI7QUFBQTtBQUZkLFlBSlI7QUFTSSxrQkFBUSxNQVRaO0FBVUksa0JBQVEsRUFBRSxDQUFDMjdCLGVBVmY7QUFXSSxrQkFBUSxFQUFFLGtCQUFDNVQsQ0FBRCxFQUFJMTFCLEtBQUo7QUFBQSxtQkFBY3dwQyxlQUFlLENBQUN4cEMsS0FBRCxDQUE3QjtBQUFBO0FBWGQsVUF0Qk0sZUFvQ04sb0JBQUMsUUFBRDtBQUFVLGdCQUFNLEVBQUMsTUFBakI7QUFBQSxpQ0FDSSxvQkFBQyxnQ0FBRDtBQUNJLG9CQUFRLEVBQUUsQ0FDTjtBQUFFQSxjQUFBQSxLQUFLLEVBQUUsT0FBVDtBQUFrQjhELGNBQUFBLEtBQUssRUFBRTtBQUF6QixhQURNLEVBRU47QUFBRTlELGNBQUFBLEtBQUssRUFBRSxVQUFUO0FBQXFCOEQsY0FBQUEsS0FBSyxFQUFFO0FBQTVCLGFBRk0sRUFHTjtBQUFFOUQsY0FBQUEsS0FBSyxFQUFFLFlBQVQ7QUFBdUI4RCxjQUFBQSxLQUFLLEVBQUU7QUFBOUIsYUFITSxFQUlOO0FBQUU5RCxjQUFBQSxLQUFLLEVBQUUsUUFBVDtBQUFtQjhELGNBQUFBLEtBQUssRUFBRTtBQUExQixhQUpNLENBRGQ7QUFPSSxpQkFBSyxFQUFFZ2pCLElBUFg7QUFRSSxvQkFBUSxFQUFFa2hCO0FBUmQ7QUFESixVQXBDTTtBQUFBLFFBRmQ7QUFBQSw2QkFvREksb0JBQUMsYUFBRDtBQUNJLG1CQUFXLEVBQUVtQixjQUFjLEdBQUdwbEMsV0FBSCxHQUFpQitDLFNBRGhEO0FBRUksb0JBQVksRUFBRXdpQyxlQUFlLEdBQUd0bEMsWUFBSCxHQUFrQjhDLFNBRm5EO0FBR0ksZ0JBQVEsRUFBRWdnQixJQUFJLEtBQUssVUFBVCxJQUF1QmhnQixTQUhyQztBQUlJLGtCQUFVLEVBQUVnZ0IsSUFBSSxLQUFLLFlBQVQsSUFBeUJoZ0IsU0FKekM7QUFLSSxjQUFNLEVBQUVnZ0IsSUFBSSxLQUFLLFFBQVQsSUFBcUJoZ0IsU0FMakM7QUFBQSxrQkFPS2hEO0FBUEw7QUFwREo7QUFESixJQURKO0FBa0VILEM7Ozs7Ozs7Ozs7Ozs7O0FDOUZEO0FBQ0E7QUFNQTtBQUNBOzs7O0FBRUEsSUFBTWlxQixPQUFFLEdBQUcsTUFBWDtBQUNBLElBQU0wYixTQUFTLEdBQUcsTUFBbEI7QUFDQSxJQUFNNUMsZ0JBQVcsR0FBRywyREFBcEI7QUFDQSxJQUFNVSxVQUFLLEdBQUc7QUFDVkUsRUFBQUEsSUFBSSxFQUFFLDhGQURJO0FBRVZELEVBQUFBLEtBQUssRUFBRTtBQUZHLENBQWQ7QUFHRztBQUVZLFNBQVNrQyxRQUFULEdBQW9CO0FBQy9CLGtCQUFnQ3B4QixrQkFBUSxDQUFDLElBQUQsQ0FBeEM7QUFBQTtBQUFBLE1BQU9xeEIsUUFBUDtBQUFBLE1BQWlCQyxXQUFqQjs7QUFDQSxtQkFBMEJ0eEIsa0JBQVEsQ0FBQyxPQUFELENBQWxDO0FBQUE7QUFBQSxNQUFPblMsS0FBUDtBQUFBLE1BQWMwakMsUUFBZDs7QUFDQSxtQkFBc0N2eEIsa0JBQVEsQ0FBQyxJQUFELENBQTlDO0FBQUE7QUFBQSxNQUFPd3hCLFdBQVA7QUFBQSxNQUFvQkMsY0FBcEI7O0FBQ0EsbUJBQWdDenhCLGtCQUFRLENBQUMsVUFBRCxDQUF4QztBQUFBO0FBQUEsTUFBT2xTLFFBQVA7QUFBQSxNQUFpQjRqQyxXQUFqQjs7QUFFQSxzQkFDSSxvQkFBQyxJQUFEO0FBQ0ksTUFBRSxFQUFFamMsT0FEUjtBQUVJLFNBQUssRUFBRTBiLFNBRlg7QUFHSSxlQUFXLEVBQUU1QyxnQkFIakI7QUFJSSxTQUFLLEVBQUVVLFVBSlg7QUFBQSwyQkFNSSxvQkFBQyxJQUFEO0FBQ0ksY0FBUSxlQUFFO0FBQUEsZ0NBQ04sb0JBQUMsb0JBQUQ7QUFDSSxlQUFLLEVBQUVwaEMsS0FEWDtBQUVJLGVBQUssRUFBQyxPQUZWO0FBR0ksc0JBQVksZUFDUixvQkFBQyxhQUFEO0FBQ0ksb0JBQVEsRUFBRXdqQyxRQURkO0FBRUksb0JBQVEsRUFBRTtBQUFBLHFCQUFNQyxXQUFXLENBQUMsVUFBQWo4QixDQUFDO0FBQUEsdUJBQUksQ0FBQ0EsQ0FBTDtBQUFBLGVBQUYsQ0FBakI7QUFBQTtBQUZkLFlBSlI7QUFTSSxrQkFBUSxNQVRaO0FBVUksa0JBQVEsRUFBRSxDQUFDZzhCLFFBVmY7QUFXSSxrQkFBUSxFQUFFLGtCQUFDalUsQ0FBRCxFQUFJMTFCLEtBQUo7QUFBQSxtQkFBYzZwQyxRQUFRLENBQUM3cEMsS0FBRCxDQUF0QjtBQUFBO0FBWGQsVUFETSxlQWVOLG9CQUFDLG9CQUFEO0FBQ0ksZUFBSyxFQUFFb0csUUFEWDtBQUVJLGVBQUssRUFBQyxVQUZWO0FBR0ksc0JBQVksZUFDUixvQkFBQyxhQUFEO0FBQ0ksb0JBQVEsRUFBRTBqQyxXQURkO0FBRUksb0JBQVEsRUFBRTtBQUFBLHFCQUFNQyxjQUFjLENBQUMsVUFBQXA4QixDQUFDO0FBQUEsdUJBQUksQ0FBQ0EsQ0FBTDtBQUFBLGVBQUYsQ0FBcEI7QUFBQTtBQUZkLFlBSlI7QUFTSSxrQkFBUSxNQVRaO0FBVUksa0JBQVEsRUFBRSxDQUFDbThCLFdBVmY7QUFXSSxrQkFBUSxFQUFFLGtCQUFDcFUsQ0FBRCxFQUFJMTFCLEtBQUo7QUFBQSxtQkFBY2dxQyxXQUFXLENBQUNocUMsS0FBRCxDQUF6QjtBQUFBO0FBWGQsVUFmTTtBQUFBLFFBRGQ7QUFBQSw2QkErQkksb0JBQUMsU0FBRDtBQUFBLCtCQUNJLG9CQUFDLGdCQUFEO0FBQ0ksa0JBQVEsRUFBQyxVQURiO0FBRUksZUFBSyxFQUFFMnBDLFFBQVEsR0FBR3hqQyxLQUFILEdBQVdXLFNBRjlCO0FBR0ksa0JBQVEsRUFBRWdqQyxXQUFXLEdBQUcxakMsUUFBSCxHQUFjVTtBQUh2QztBQURKO0FBL0JKO0FBTkosSUFESjtBQWdESCxDOzs7Ozs7Ozs7Ozs7OztBQ3hFRDtBQUNBO0FBRUE7QUFDQTs7QUFFQSxJQUFNaW5CLFdBQUUsR0FBRyxVQUFYO0FBQ0EsSUFBTTVuQixjQUFLLEdBQUcsVUFBZDtBQUNBLElBQU0wZ0Msb0JBQVcsR0FBRyxrRUFBcEI7QUFDQSxJQUFNVSxjQUFLLEdBQUc7QUFDVkUsRUFBQUEsSUFBSSxFQUFFLGtHQURJO0FBRVZELEVBQUFBLEtBQUssRUFBRTtBQUZHLENBQWQ7QUFLZSxTQUFTeUMsWUFBVCxHQUF3QjtBQUNuQyxrQkFBOEIzeEIsa0JBQVEsQ0FBQyxLQUFELENBQXRDO0FBQUE7QUFBQSxNQUFPNVAsT0FBUDtBQUFBLE1BQWdCd2hDLFVBQWhCOztBQUNBLG1CQUFvQzV4QixrQkFBUSxDQUFDLEtBQUQsQ0FBNUM7QUFBQTtBQUFBLE1BQU82eEIsVUFBUDtBQUFBLE1BQW1CQyxhQUFuQjs7QUFDQSxtQkFBMEM5eEIsa0JBQVEsQ0FBQyxLQUFELENBQWxEO0FBQUE7QUFBQSxNQUFPM1AsYUFBUDtBQUFBLE1BQXNCMGhDLGdCQUF0Qjs7QUFDQSxtQkFBZ0MveEIsa0JBQVEsQ0FBQyxLQUFELENBQXhDO0FBQUE7QUFBQSxNQUFPMVAsUUFBUDtBQUFBLE1BQWlCMGhDLFdBQWpCOztBQUVBLHNCQUNJLG9CQUFDLElBQUQ7QUFBTSxNQUFFLEVBQUV2YyxXQUFWO0FBQWMsU0FBSyxFQUFFNW5CLGNBQXJCO0FBQTRCLGVBQVcsRUFBRTBnQyxvQkFBekM7QUFBc0QsU0FBSyxFQUFFVSxjQUE3RDtBQUFBLDJCQUNJLG9CQUFDLElBQUQ7QUFBQSw2QkFDSSxvQkFBQyxpQkFBRDtBQUNJLGVBQU8sRUFBRTcrQixPQURiO0FBRUksc0JBQWMsRUFBRSxLQUZwQjtBQUdJLHFCQUFhLEVBQUVDLGFBSG5CO0FBSUksZ0JBQVEsRUFBRUMsUUFKZDtBQUtJLGdCQUFRLEVBQUU7QUFBQSxpQkFBTXNoQyxVQUFVLENBQUMsVUFBQXY4QixDQUFDO0FBQUEsbUJBQUksQ0FBQ0EsQ0FBTDtBQUFBLFdBQUYsQ0FBaEI7QUFBQTtBQUxkO0FBREo7QUFESixJQURKO0FBYUgsQzs7Ozs7Ozs7Ozs7Ozs7QUNqQ0Q7QUFDQTtBQUtBO0FBQ0E7OztBQUVBLElBQU1vZ0IsUUFBRSxHQUFHLE9BQVg7QUFDQSxJQUFNNW5CLFdBQUssR0FBRyxPQUFkO0FBQ0EsSUFBTTBnQyxpQkFBVyxHQUFHLDBIQUFwQjtBQUNBLElBQU1VLFdBQUssR0FBRztBQUNWRSxFQUFBQSxJQUFJLEVBQUUsK0ZBREk7QUFFVkQsRUFBQUEsS0FBSyxFQUFFO0FBRkcsQ0FBZDtBQUtlLFNBQVMrQyxTQUFULEdBQXFCO0FBQ2hDLGtCQUFxQ2p5QixrQkFBUSxDQUFDLEtBQUQsQ0FBN0M7QUFBQTtBQUFBLE1BQU9reUIsVUFBUDtBQUFBLE1BQW1CQyxjQUFuQjs7QUFDQSxtQkFBc0NueUIsa0JBQVEsQ0FBQyxDQUFDLEtBQUQsQ0FBRCxDQUE5QztBQUFBO0FBQUEsTUFBT295QixXQUFQO0FBQUEsTUFBb0JDLGNBQXBCOztBQUVBLHNCQUNJLHFCQUFDLElBQUQ7QUFBTSxNQUFFLEVBQUU1YyxRQUFWO0FBQWMsU0FBSyxFQUFFNW5CLFdBQXJCO0FBQTRCLGVBQVcsRUFBRTBnQyxpQkFBekM7QUFBc0QsU0FBSyxFQUFFVSxXQUE3RDtBQUFBLDRCQUNJLG9CQUFDLElBQUQ7QUFBTSxXQUFLLEVBQUMsYUFBWjtBQUFBLDZCQUNJLHFCQUFDLGFBQUQ7QUFBQSxnQ0FDSSxvQkFBQyxVQUFEO0FBQU0sY0FBSSxFQUFDO0FBQVgsVUFESixlQUVJLG9CQUFDLFVBQUQ7QUFBTSxjQUFJLEVBQUM7QUFBWCxVQUZKLGVBR0ksb0JBQUMsVUFBRDtBQUFNLGNBQUksRUFBQztBQUFYLFVBSEo7QUFBQTtBQURKLE1BREosZUFTSSxvQkFBQyxJQUFEO0FBQU0sV0FBSyxFQUFDLGtCQUFaO0FBQUEsNkJBQ0kscUJBQUMsYUFBRDtBQUFBLGdDQUNJLG9CQUFDLFVBQUQ7QUFBTSxjQUFJLEVBQUMsS0FBWDtBQUFpQixjQUFJLEVBQUM7QUFBdEIsVUFESixlQUVJLG9CQUFDLFVBQUQ7QUFBTSxjQUFJLEVBQUMsS0FBWDtBQUFpQixjQUFJLEVBQUM7QUFBdEIsVUFGSixlQUdJLG9CQUFDLFVBQUQ7QUFBTSxjQUFJLEVBQUMsS0FBWDtBQUFpQixjQUFJLEVBQUM7QUFBdEIsVUFISjtBQUFBO0FBREosTUFUSixlQWlCSSxvQkFBQyxJQUFEO0FBQU0sV0FBSyxFQUFDLDJCQUFaO0FBQUEsNkJBQ0kscUJBQUMsYUFBRDtBQUFBLGdDQUNJLG9CQUFDLFVBQUQ7QUFBTSxjQUFJLEVBQUMsS0FBWDtBQUFpQixzQkFBWSxFQUFDO0FBQTlCLFVBREosZUFFSSxvQkFBQyxVQUFEO0FBQU0sY0FBSSxFQUFDLEtBQVg7QUFBaUIsc0JBQVksRUFBQztBQUE5QixVQUZKLGVBR0ksb0JBQUMsVUFBRDtBQUFNLGNBQUksRUFBQyxLQUFYO0FBQWlCLHNCQUFZLEVBQUM7QUFBOUIsVUFISjtBQUFBO0FBREosTUFqQkosZUF5Qkksb0JBQUMsSUFBRDtBQUFNLFdBQUssRUFBQyxvQkFBWjtBQUFBLDZCQUNJLHFCQUFDLGFBQUQ7QUFBQSxnQ0FDSSxvQkFBQyxVQUFEO0FBQU0sY0FBSSxFQUFDLEtBQVg7QUFBaUIsZ0JBQU0sZUFBRSxvQkFBQyxhQUFEO0FBQVEsaUJBQUssRUFBQyxxQ0FBZDtBQUFvRCxpQkFBSztBQUF6RDtBQUF6QixVQURKLGVBRUksb0JBQUMsVUFBRDtBQUFNLGNBQUksRUFBQyxLQUFYO0FBQWlCLGdCQUFNLGVBQUUsb0JBQUMsYUFBRDtBQUFRLGlCQUFLLEVBQUMscUNBQWQ7QUFBb0QsaUJBQUs7QUFBekQ7QUFBekIsVUFGSixlQUdJLG9CQUFDLFVBQUQ7QUFBTSxjQUFJLEVBQUMsS0FBWDtBQUFpQixnQkFBTSxlQUFFLG9CQUFDLGFBQUQ7QUFBUSxpQkFBSyxFQUFDLHFDQUFkO0FBQW9ELGlCQUFLO0FBQXpEO0FBQXpCLFVBSEo7QUFBQTtBQURKLE1BekJKLGVBaUNJLG9CQUFDLElBQUQ7QUFBTSxXQUFLLEVBQUMsY0FBWjtBQUFBLDZCQUNJLHFCQUFDLGFBQUQ7QUFBUyxhQUFLLEVBQUVpRCxVQUFoQjtBQUE0QixnQkFBUSxFQUFFLGtCQUFBeHFDLEtBQUs7QUFBQSxpQkFBSXlxQyxjQUFjLENBQUN6cUMsS0FBRCxDQUFsQjtBQUFBLFNBQTNDO0FBQUEsZ0NBQ0ksb0JBQUMsVUFBRDtBQUFNLGVBQUssRUFBQyxLQUFaO0FBQWtCLGNBQUksRUFBQztBQUF2QixVQURKLGVBRUksb0JBQUMsVUFBRDtBQUFNLGVBQUssRUFBQyxLQUFaO0FBQWtCLGNBQUksRUFBQztBQUF2QixVQUZKLGVBR0ksb0JBQUMsVUFBRDtBQUFNLGVBQUssRUFBQyxLQUFaO0FBQWtCLGNBQUksRUFBQztBQUF2QixVQUhKO0FBQUE7QUFESixNQWpDSixlQXlDSSxvQkFBQyxJQUFEO0FBQU0sV0FBSyxFQUFDLGNBQVo7QUFBQSw2QkFDSSxxQkFBQyxhQUFEO0FBQVMsYUFBSyxFQUFFMHFDLFdBQWhCO0FBQTZCLGdCQUFRLEVBQUUsa0JBQUExcUMsS0FBSztBQUFBLGlCQUFJMnFDLGNBQWMsQ0FBQzNxQyxLQUFELENBQWxCO0FBQUEsU0FBNUM7QUFBQSxnQ0FDSSxvQkFBQyxVQUFEO0FBQU0sZUFBSyxFQUFDLEtBQVo7QUFBa0IsY0FBSSxFQUFDO0FBQXZCLFVBREosZUFFSSxvQkFBQyxVQUFEO0FBQU0sZUFBSyxFQUFDLEtBQVo7QUFBa0IsY0FBSSxFQUFDO0FBQXZCLFVBRkosZUFHSSxvQkFBQyxVQUFEO0FBQU0sZUFBSyxFQUFDLEtBQVo7QUFBa0IsY0FBSSxFQUFDO0FBQXZCLFVBSEo7QUFBQTtBQURKLE1BekNKO0FBQUEsSUFESjtBQW1ESCxDOzs7Ozs7Ozs7Ozs7OztBQ3hFRDtBQUNBO0FBU0E7QUFDQTtBQUNBOzs7O0FBRUEsSUFBTSt0QixtQkFBRSxHQUFHLG1CQUFYO0FBQ0EsSUFBTTVuQixzQkFBSyxHQUFHLG1CQUFkO0FBQ0EsSUFBTTBnQyw0QkFBVyxHQUFHLHFJQUFwQjtBQUNBLElBQU1VLHNCQUFLLEdBQUc7QUFDVkUsRUFBQUEsSUFBSSxFQUFFLDJHQURJO0FBRVZELEVBQUFBLEtBQUssRUFBRTtBQUZHLENBQWQ7QUFLZSxTQUFTb0Qsb0JBQVQsR0FBZ0M7QUFDM0Msa0JBQTBCdHlCLGtCQUFRLENBQUMsRUFBRCxDQUFsQztBQUFBO0FBQUEsTUFBT3RZLEtBQVA7QUFBQSxNQUFjK25DLFFBQWQ7O0FBQ0EsbUJBQXdCenZCLGtCQUFRLENBQUMsUUFBRCxDQUFoQztBQUFBO0FBQUEsTUFBT2phLElBQVA7QUFBQSxNQUFhc3BDLE9BQWI7O0FBQ0EsbUJBQTBDcnZCLGtCQUFRLENBQUMsS0FBRCxDQUFsRDtBQUFBO0FBQUEsTUFBTzNQLGFBQVA7QUFBQSxNQUFzQjBoQyxnQkFBdEI7O0FBQ0EsbUJBQWdDL3hCLGtCQUFRLENBQUMsS0FBRCxDQUF4QztBQUFBO0FBQUEsTUFBTzNJLFFBQVA7QUFBQSxNQUFpQms3QixXQUFqQjs7QUFDQSxtQkFBNEJ2eUIsa0JBQVEsQ0FBQyxLQUFELENBQXBDO0FBQUE7QUFBQSxNQUFPNUksTUFBUDtBQUFBLE1BQWVvN0IsU0FBZjs7QUFFQSxzQkFDSSxvQkFBQyxJQUFEO0FBQU0sTUFBRSxFQUFFL2MsbUJBQVY7QUFBYyxTQUFLLEVBQUU1bkIsc0JBQXJCO0FBQTRCLGVBQVcsRUFBRTBnQyw0QkFBekM7QUFBc0QsU0FBSyxFQUFFVSxzQkFBN0Q7QUFBQSwyQkFDSSxvQkFBQyxJQUFEO0FBQ0ksY0FBUSxlQUFFO0FBQUEsZ0NBQ04sb0JBQUMsb0JBQUQ7QUFDSSxlQUFLLEVBQUV2bkMsS0FEWDtBQUVJLGVBQUssRUFBQyxPQUZWO0FBR0ksa0JBQVEsTUFIWjtBQUlJLGtCQUFRLEVBQUUsa0JBQUMwMUIsQ0FBRCxFQUFJMTFCLEtBQUo7QUFBQSxtQkFBYytuQyxRQUFRLENBQUMvbkMsS0FBRCxDQUF0QjtBQUFBO0FBSmQsVUFETSxlQVFOLG9CQUFDLFFBQUQ7QUFBVSxnQkFBTSxFQUFDLE1BQWpCO0FBQUEsaUNBQ0ksb0JBQUMsZ0NBQUQ7QUFDSSxvQkFBUSxFQUFFLENBQ047QUFBRUEsY0FBQUEsS0FBSyxFQUFFLE9BQVQ7QUFBa0I4RCxjQUFBQSxLQUFLLEVBQUU7QUFBekIsYUFETSxFQUVOO0FBQUU5RCxjQUFBQSxLQUFLLEVBQUUsUUFBVDtBQUFtQjhELGNBQUFBLEtBQUssRUFBRTtBQUExQixhQUZNLEVBR047QUFBRTlELGNBQUFBLEtBQUssRUFBRSxPQUFUO0FBQWtCOEQsY0FBQUEsS0FBSyxFQUFFO0FBQXpCLGFBSE0sQ0FEZDtBQU1JLGlCQUFLLEVBQUV6RixJQU5YO0FBT0ksb0JBQVEsRUFBRXNwQztBQVBkO0FBREosVUFSTSxlQW9CTixvQkFBQyxvQkFBRDtBQUFXLGVBQUssRUFBQyxlQUFqQjtBQUFpQyxrQkFBUSxNQUF6QztBQUEwQyxzQkFBWSxNQUF0RDtBQUFBLGlDQUNJLG9CQUFDLGFBQUQ7QUFDSSxvQkFBUSxFQUFFaC9CLGFBRGQ7QUFFSSxvQkFBUSxFQUFFO0FBQUEscUJBQU0waEMsZ0JBQWdCLENBQUMsVUFBQTE4QixDQUFDO0FBQUEsdUJBQUksQ0FBQ0EsQ0FBTDtBQUFBLGVBQUYsQ0FBdEI7QUFBQTtBQUZkO0FBREosVUFwQk0sZUEyQk4sb0JBQUMsb0JBQUQ7QUFBVyxlQUFLLEVBQUMsVUFBakI7QUFBNEIsa0JBQVEsTUFBcEM7QUFBcUMsc0JBQVksTUFBakQ7QUFBQSxpQ0FDSSxvQkFBQyxhQUFEO0FBQ0ksb0JBQVEsRUFBRWdDLFFBRGQ7QUFFSSxvQkFBUSxFQUFFO0FBQUEscUJBQU1rN0IsV0FBVyxDQUFDLFVBQUFsOUIsQ0FBQztBQUFBLHVCQUFJLENBQUNBLENBQUw7QUFBQSxlQUFGLENBQWpCO0FBQUE7QUFGZDtBQURKLFVBM0JNLGVBa0NOLG9CQUFDLG9CQUFEO0FBQVcsZUFBSyxFQUFDLFFBQWpCO0FBQTBCLGtCQUFRLE1BQWxDO0FBQW1DLHNCQUFZLE1BQS9DO0FBQUEsaUNBQ0ksb0JBQUMsYUFBRDtBQUNJLG9CQUFRLEVBQUUrQixNQURkO0FBRUksb0JBQVEsRUFBRTtBQUFBLHFCQUFNbzdCLFNBQVMsQ0FBQyxVQUFBbjlCLENBQUM7QUFBQSx1QkFBSSxDQUFDQSxDQUFMO0FBQUEsZUFBRixDQUFmO0FBQUE7QUFGZDtBQURKLFVBbENNO0FBQUEsUUFEZDtBQUFBLDZCQTJDSSxvQkFBQyxrQ0FBRDtBQUNJLGFBQUssRUFBRWhGLGFBQWEsR0FBRzdCLFNBQUgsR0FBZTlHLEtBRHZDO0FBRUksWUFBSSxFQUFFM0IsSUFGVjtBQUdJLHFCQUFhLEVBQUVzSyxhQUFhLElBQUk3QixTQUhwQztBQUlJLGdCQUFRLEVBQUU2SSxRQUFRLElBQUk3SSxTQUoxQjtBQUtJLGNBQU0sRUFBRTRJLE1BQU0sSUFBSTVJO0FBTHRCO0FBM0NKO0FBREosSUFESjtBQXVESCxDOzs7Ozs7Ozs7Ozs7OztBQ3BGRDtBQUNBO0FBRUE7QUFDQTs7O0FBRUEsSUFBTWluQixZQUFFLEdBQUcsWUFBWDtBQUNBLElBQU01bkIsZUFBSyxHQUFHLFlBQWQ7QUFDQSxJQUFNMGdDLHFCQUFXLEdBQUcsMkRBQXBCO0FBQ0EsSUFBTVUsZUFBSyxHQUFHO0FBQ1ZFLEVBQUFBLElBQUksRUFBRSxvR0FESTtBQUVWRCxFQUFBQSxLQUFLLEVBQUU7QUFGRyxDQUFkO0FBS0EsSUFBTXVELEtBQUssR0FBRyxDQUNWLENBQUMsZUFBRCxFQUFrQixFQUFsQixFQUFzQixHQUF0QixFQUEyQixhQUEzQixDQURVLEVBRVYsQ0FBQyxvQkFBRCxFQUF1QixFQUF2QixFQUEyQixhQUEzQixFQUEwQyx1QkFBMUMsQ0FGVSxFQUdWLENBQUMsUUFBRCxFQUFXLEVBQVgsRUFBZSxHQUFmLEVBQW9CLG1CQUFwQixDQUhVLENBQWQ7QUFNZSxTQUFTQyxhQUFULEdBQXlCO0FBQ3BDLGtCQUF3QjF5QixrQkFBUSxDQUFDeXlCLEtBQUQsQ0FBaEM7QUFBQTtBQUFBLE1BQU9FLElBQVA7QUFBQSxNQUFhQyxPQUFiOztBQUNBLG1CQUF3QjV5QixrQkFBUSxDQUFDLENBQUQsQ0FBaEM7QUFBQTtBQUFBLE1BQU9xUSxJQUFQO0FBQUEsTUFBYXdpQixPQUFiOztBQUVBLE1BQU1DLFVBQVUsR0FBRzVwQyxxQkFBVyxDQUFDLFlBQU07QUFDakMycEMsSUFBQUEsT0FBTyxDQUFDLFVBQUF4aUIsSUFBSSxFQUFJO0FBQ1osVUFBSUEsSUFBSSxLQUFLLENBQUMsQ0FBZCxFQUFpQjtBQUNidWlCLFFBQUFBLE9BQU8sQ0FBQyxVQUFBRCxJQUFJO0FBQUEsaUJBQUlBLElBQUksQ0FBQ0ksS0FBTCxHQUFhMWlCLElBQWIsQ0FBa0IsVUFBQzJpQixDQUFELEVBQUlDLENBQUo7QUFBQSxtQkFBVUQsQ0FBQyxDQUFDLENBQUQsQ0FBRCxHQUFPQyxDQUFDLENBQUMsQ0FBRCxDQUFsQjtBQUFBLFdBQWxCLENBQUo7QUFBQSxTQUFMLENBQVA7QUFDQUosUUFBQUEsT0FBTyxDQUFDLENBQUQsQ0FBUDtBQUNILE9BSEQsTUFHTztBQUNIRCxRQUFBQSxPQUFPLENBQUMsVUFBQUQsSUFBSTtBQUFBLGlCQUFJQSxJQUFJLENBQUNJLEtBQUwsR0FBYTFpQixJQUFiLENBQWtCLFVBQUMyaUIsQ0FBRCxFQUFJQyxDQUFKO0FBQUEsbUJBQVVBLENBQUMsQ0FBQyxDQUFELENBQUQsR0FBT0QsQ0FBQyxDQUFDLENBQUQsQ0FBbEI7QUFBQSxXQUFsQixDQUFKO0FBQUEsU0FBTCxDQUFQO0FBQ0FILFFBQUFBLE9BQU8sQ0FBQyxDQUFDLENBQUYsQ0FBUDtBQUNIO0FBQ0osS0FSTSxDQUFQO0FBU0gsR0FWNkIsRUFVM0IsRUFWMkIsQ0FBOUI7QUFZQSxzQkFDSSxvQkFBQyxJQUFEO0FBQU0sTUFBRSxFQUFFcGQsWUFBVjtBQUFjLFNBQUssRUFBRTVuQixlQUFyQjtBQUE0QixlQUFXLEVBQUUwZ0MscUJBQXpDO0FBQXNELFNBQUssRUFBRVUsZUFBN0Q7QUFBQSwyQkFDSSxvQkFBQyxJQUFEO0FBQU0sV0FBSyxFQUFDLHFCQUFaO0FBQUEsNkJBQ0kscUJBQUMsb0JBQUQ7QUFBQSxnQ0FDSSxvQkFBQywyQkFBRDtBQUFBLGlDQUNJLHFCQUFDLDhCQUFEO0FBQUEsb0NBQ0ksb0JBQUMsK0JBQUQ7QUFBQTtBQUFBLGNBREosZUFFSSxvQkFBQywrQkFBRDtBQUFzQixxQkFBTyxNQUE3QjtBQUE4QixrQkFBSSxFQUFFNWUsSUFBcEM7QUFBMEMsb0JBQU0sRUFBRXlpQixVQUFsRDtBQUFBO0FBQUEsY0FGSixlQUdJLG9CQUFDLCtCQUFEO0FBQXNCLHFCQUFPLE1BQTdCO0FBQUE7QUFBQSxjQUhKLGVBSUksb0JBQUMsK0JBQUQ7QUFBQTtBQUFBLGNBSko7QUFBQTtBQURKLFVBREosZUFVSSxvQkFBQyw0QkFBRDtBQUFBLG9CQUNLSCxJQUFJLENBQUMxa0MsR0FBTCxDQUFTLFVBQUNncEIsR0FBRCxFQUFNdk0sS0FBTjtBQUFBLGdDQUNOLG9CQUFDLHdCQUFEO0FBQUEsd0JBQ0t1TSxHQUFHLENBQUNocEIsR0FBSixDQUFRLFVBQUN2RyxLQUFELEVBQVFnakIsS0FBUjtBQUFBLG9DQUNMLG9CQUFDLHlCQUFEO0FBQTRCLHVCQUFLLEVBQUVBLEtBQUssS0FBSyxDQUFWLEdBQWMsS0FBZCxHQUFzQmxjLFNBQXpEO0FBQW9FLHlCQUFPLEVBQUUsT0FBTzlHLEtBQVAsS0FBaUIsUUFBakIsSUFBNkI4RyxTQUExRztBQUFBLDRCQUNLOUc7QUFETCxtQkFBcUJnakIsS0FBckIsQ0FESztBQUFBLGVBQVI7QUFETCxlQUFvQkEsS0FBcEIsQ0FETTtBQUFBLFdBQVQ7QUFETCxVQVZKO0FBQUE7QUFESjtBQURKLElBREo7QUE0QkgsQzs7Ozs7Ozs7Ozs7Ozs7QUNoRUQ7QUFDQTtBQUtBO0FBQ0E7OztBQUVBLElBQU0rSyxTQUFFLEdBQUcsUUFBWDtBQUNBLElBQU01bkIsWUFBSyxHQUFHLFFBQWQ7QUFDQSxJQUFNMGdDLGtCQUFXLEdBQUcsZ0lBQXBCO0FBQ0EsSUFBTVUsWUFBSyxHQUFHO0FBQ1ZFLEVBQUFBLElBQUksRUFBRSxnR0FESTtBQUVWRCxFQUFBQSxLQUFLLEVBQUU7QUFGRyxDQUFkO0FBS0EsSUFBTWdFLGlCQUFpQixtcUlBQXZCO0FBc0NlLFNBQVNDLFVBQVQsR0FBc0I7QUFDakMsa0JBQW9DbnpCLGtCQUFRLENBQUMsS0FBRCxDQUE1QztBQUFBO0FBQUEsTUFBT296QixXQUFQO0FBQUEsTUFBb0JDLFlBQXBCOztBQUNBLG1CQUFrRHJ6QixrQkFBUSxDQUFDLEtBQUQsQ0FBMUQ7QUFBQTtBQUFBLE1BQU9zekIsa0JBQVA7QUFBQSxNQUEyQkMsbUJBQTNCOztBQUNBLG1CQUEwQ3Z6QixrQkFBUSxDQUFDLEtBQUQsQ0FBbEQ7QUFBQTtBQUFBLE1BQU93ekIsY0FBUDtBQUFBLE1BQXVCQyxlQUF2Qjs7QUFDQSxtQkFBOEN6ekIsa0JBQVEsQ0FBQyxLQUFELENBQXREO0FBQUE7QUFBQSxNQUFPMHpCLGdCQUFQO0FBQUEsTUFBeUJDLGlCQUF6Qjs7QUFDQSxtQkFBOEMzekIsa0JBQVEsQ0FBQyxLQUFELENBQXREO0FBQUE7QUFBQSxNQUFPNHpCLGdCQUFQO0FBQUEsTUFBeUJDLGlCQUF6Qjs7QUFFQSxzQkFDSSxxQkFBQyxJQUFEO0FBQU0sTUFBRSxFQUFFcGUsU0FBVjtBQUFjLFNBQUssRUFBRTVuQixZQUFyQjtBQUE0QixlQUFXLEVBQUUwZ0Msa0JBQXpDO0FBQXNELFNBQUssRUFBRVUsWUFBN0Q7QUFBQSw0QkFDSSxvQkFBQyxJQUFEO0FBQ0ksV0FBSyxFQUFDLGNBRFY7QUFFSSxXQUFLLGVBQ0Qsb0JBQUMsYUFBRDtBQUFRLGVBQU8sRUFBRTtBQUFBLGlCQUFNb0UsWUFBWSxDQUFDLFVBQUFoK0IsQ0FBQztBQUFBLG1CQUFJLENBQUNBLENBQUw7QUFBQSxXQUFGLENBQWxCO0FBQUEsU0FBakI7QUFBQTtBQUFBLFFBSFI7QUFBQSw2QkFNSSxvQkFBQyxhQUFEO0FBQ0ksYUFBSyxFQUFDLE9BRFY7QUFFSSxlQUFPLEVBQUMsU0FGWjtBQUdJLFlBQUksRUFBRSs5QixXQUhWO0FBSUksZUFBTyxFQUFFO0FBQUEsaUJBQU1DLFlBQVksQ0FBQyxVQUFBaCtCLENBQUM7QUFBQSxtQkFBSSxDQUFDQSxDQUFMO0FBQUEsV0FBRixDQUFsQjtBQUFBO0FBSmI7QUFOSixNQURKLGVBZUksb0JBQUMsSUFBRDtBQUNJLFdBQUssRUFBQyxxQkFEVjtBQUVJLFdBQUssZUFDRCxvQkFBQyxhQUFEO0FBQVEsZUFBTyxFQUFFO0FBQUEsaUJBQU1rK0IsbUJBQW1CLENBQUMsVUFBQWwrQixDQUFDO0FBQUEsbUJBQUksQ0FBQ0EsQ0FBTDtBQUFBLFdBQUYsQ0FBekI7QUFBQSxTQUFqQjtBQUFBO0FBQUEsUUFIUjtBQUFBLDZCQU1JLG9CQUFDLGFBQUQ7QUFDSSxhQUFLLEVBQUMsT0FEVjtBQUVJLGVBQU8sRUFBQyxlQUZaO0FBR0ksWUFBSSxFQUFFaStCLGtCQUhWO0FBSUksa0JBQVUsTUFKZDtBQUtJLGVBQU8sRUFBRSxjQUNMLG9CQUFDLGFBQUQ7QUFBb0IsaUJBQU8sRUFBRTtBQUFBLG1CQUFNQyxtQkFBbUIsQ0FBQyxVQUFBbCtCLENBQUM7QUFBQSxxQkFBSSxDQUFDQSxDQUFMO0FBQUEsYUFBRixDQUF6QjtBQUFBLFdBQTdCO0FBQUE7QUFBQSxXQUFZLE9BQVosQ0FESyxlQUVMLG9CQUFDLGFBQUQ7QUFBQTtBQUFBLFdBQVksU0FBWixDQUZLLENBTGI7QUFTSSxlQUFPLEVBQUU7QUFBQSxpQkFBTWsrQixtQkFBbUIsQ0FBQyxVQUFBbCtCLENBQUM7QUFBQSxtQkFBSSxDQUFDQSxDQUFMO0FBQUEsV0FBRixDQUF6QjtBQUFBO0FBVGI7QUFOSixNQWZKLGVBa0NJLG9CQUFDLElBQUQ7QUFDSSxXQUFLLEVBQUMsOEJBRFY7QUFFSSxXQUFLLGVBQ0Qsb0JBQUMsYUFBRDtBQUFRLGVBQU8sRUFBRTtBQUFBLGlCQUFNbytCLGVBQWUsQ0FBQyxVQUFBcCtCLENBQUM7QUFBQSxtQkFBSSxDQUFDQSxDQUFMO0FBQUEsV0FBRixDQUFyQjtBQUFBLFNBQWpCO0FBQUE7QUFBQSxRQUhSO0FBQUEsNkJBTUksb0JBQUMsYUFBRDtBQUNJLGFBQUssRUFBQyxPQURWO0FBRUksZUFBTyxFQUFDLFNBRlo7QUFHSSxZQUFJLEVBQUVtK0IsY0FIVjtBQUlJLHdCQUFnQixNQUpwQjtBQUtJLGVBQU8sRUFBRSxjQUNMLG9CQUFDLGFBQUQ7QUFBb0IsaUJBQU8sRUFBRTtBQUFBLG1CQUFNQyxlQUFlLENBQUMsVUFBQXArQixDQUFDO0FBQUEscUJBQUksQ0FBQ0EsQ0FBTDtBQUFBLGFBQUYsQ0FBckI7QUFBQSxXQUE3QjtBQUFBO0FBQUEsV0FBWSxPQUFaLENBREssZUFFTCxvQkFBQyxhQUFEO0FBQUE7QUFBQSxXQUFZLFNBQVosQ0FGSyxDQUxiO0FBU0ksZUFBTyxFQUFFO0FBQUEsaUJBQU1vK0IsZUFBZSxDQUFDLFVBQUFwK0IsQ0FBQztBQUFBLG1CQUFJLENBQUNBLENBQUw7QUFBQSxXQUFGLENBQXJCO0FBQUE7QUFUYjtBQU5KLE1BbENKLGVBcURJLG9CQUFDLElBQUQ7QUFDSSxXQUFLLEVBQUMsbUJBRFY7QUFFSSxXQUFLLGVBQ0Qsb0JBQUMsYUFBRDtBQUFRLGVBQU8sRUFBRTtBQUFBLGlCQUFNcytCLGlCQUFpQixDQUFDLFVBQUF0K0IsQ0FBQztBQUFBLG1CQUFJLENBQUNBLENBQUw7QUFBQSxXQUFGLENBQXZCO0FBQUEsU0FBakI7QUFBQTtBQUFBLFFBSFI7QUFBQSw2QkFNSSxvQkFBQyxhQUFEO0FBQ0ksYUFBSyxFQUFDLE9BRFY7QUFFSSxZQUFJLEVBQUVxK0IsZ0JBRlY7QUFHSSxlQUFPLGVBQ0gsb0JBQUMsYUFBRDtBQUFRLGlCQUFPLEVBQUU7QUFBQSxtQkFBTUMsaUJBQWlCLENBQUMsVUFBQXQrQixDQUFDO0FBQUEscUJBQUksQ0FBQ0EsQ0FBTDtBQUFBLGFBQUYsQ0FBdkI7QUFBQSxXQUFqQjtBQUFBO0FBQUEsVUFKUjtBQU1JLGVBQU8sRUFBRTtBQUFBLGlCQUFNcytCLGlCQUFpQixDQUFDLFVBQUF0K0IsQ0FBQztBQUFBLG1CQUFJLENBQUNBLENBQUw7QUFBQSxXQUFGLENBQXZCO0FBQUEsU0FOYjtBQUFBLGtCQVFLNjlCO0FBUkw7QUFOSixNQXJESixlQXVFSSxvQkFBQyxJQUFEO0FBQ0ksV0FBSyxFQUFDLG1CQURWO0FBRUksV0FBSyxlQUNELG9CQUFDLGFBQUQ7QUFBUSxlQUFPLEVBQUU7QUFBQSxpQkFBTVcsaUJBQWlCLENBQUMsVUFBQXgrQixDQUFDO0FBQUEsbUJBQUksQ0FBQ0EsQ0FBTDtBQUFBLFdBQUYsQ0FBdkI7QUFBQSxTQUFqQjtBQUFBO0FBQUEsUUFIUjtBQUFBLDZCQU1JLG9CQUFDLGFBQUQ7QUFDSSxhQUFLLEVBQUMsbUJBRFY7QUFFSSxZQUFJLEVBQUV1K0IsZ0JBRlY7QUFHSSxrQkFBVSxNQUhkO0FBSUksZUFBTyxlQUNILG9CQUFDLGFBQUQ7QUFBUSxpQkFBTyxFQUFFO0FBQUEsbUJBQU1DLGlCQUFpQixDQUFDLFVBQUF4K0IsQ0FBQztBQUFBLHFCQUFJLENBQUNBLENBQUw7QUFBQSxhQUFGLENBQXZCO0FBQUEsV0FBakI7QUFBQTtBQUFBLFVBTFI7QUFPSSxlQUFPLEVBQUU7QUFBQSxpQkFBTXcrQixpQkFBaUIsQ0FBQyxVQUFBeCtCLENBQUM7QUFBQSxtQkFBSSxDQUFDQSxDQUFMO0FBQUEsV0FBRixDQUF2QjtBQUFBLFNBUGI7QUFBQSxrQkFTSzY5QjtBQVRMO0FBTkosTUF2RUo7QUFBQSxJQURKO0FBNEZILEM7Ozs7Ozs7Ozs7Ozs7O0FDMUpEO0FBQ0E7QUFFQTs7O0FBRWUsU0FBUzlqQyxPQUFULE9BQTJEO0FBQUEsTUFBeEN2QixLQUF3QyxRQUF4Q0EsS0FBd0M7QUFBQSxNQUFqQzNJLFFBQWlDLFFBQWpDQSxRQUFpQztBQUFBLE1BQXZCRCxTQUF1QixRQUF2QkEsU0FBdUI7QUFBQSxNQUFURSxLQUFTOztBQUN0RSxNQUFNa0IsVUFBVSxHQUFHaEMsb0JBQVUsQ0FBQyxTQUFELEVBQVlZLFNBQVosQ0FBN0I7QUFFQSxzQkFDSTtBQUFTLGFBQVMsRUFBRW9CO0FBQXBCLEtBQW9DbEIsS0FBcEM7QUFBQSxlQUNLMEksS0FBSyxpQkFDRixvQkFBQyxxQkFBRDtBQUFZLGVBQVMsRUFBQyxlQUF0QjtBQUFzQyxVQUFJLEVBQUMsV0FBM0M7QUFBQSxnQkFBd0RBO0FBQXhELE1BRlIsRUFLSzNJLFFBTEw7QUFBQSxLQURKO0FBU0gsQzs7Ozs7Ozs7Ozs7Ozs7QUNqQkQ7QUFDQTtBQUVBO0FBQ0E7QUFDQTs7O0FBRUEsSUFBTXV3QixTQUFFLEdBQUcsUUFBWDtBQUNBLElBQU01bkIsWUFBSyxHQUFHLFFBQWQ7QUFDQSxJQUFNMGdDLGtCQUFXLEdBQUcsZ0VBQXBCO0FBQ0EsSUFBTVUsWUFBSyxHQUFHO0FBQ1ZFLEVBQUFBLElBQUksRUFBRSxnR0FESTtBQUVWRCxFQUFBQSxLQUFLLEVBQUU7QUFGRyxDQUFkO0FBS2UsU0FBUzRFLFVBQVQsR0FBc0I7QUFDakMsa0JBQWdEOXpCLGtCQUFRLENBQUMsS0FBRCxDQUF4RDtBQUFBO0FBQUEsTUFBTyt6QixpQkFBUDtBQUFBLE1BQTBCQyxrQkFBMUI7O0FBQ0EsbUJBQW9DaDBCLGtCQUFRLENBQUMsS0FBRCxDQUE1QztBQUFBO0FBQUEsTUFBT2kwQixXQUFQO0FBQUEsTUFBb0JDLFlBQXBCOztBQUVBLHNCQUNJLHFCQUFDLElBQUQ7QUFBTSxNQUFFLEVBQUV6ZSxTQUFWO0FBQWMsU0FBSyxFQUFFNW5CLFlBQXJCO0FBQTRCLGVBQVcsRUFBRTBnQyxrQkFBekM7QUFBc0QsU0FBSyxFQUFFVSxZQUE3RDtBQUFBLDRCQUNJLG9CQUFDLE9BQUQ7QUFBUyxXQUFLLEVBQUMsa0JBQWY7QUFBQSw2QkFDSSxvQkFBQyxJQUFEO0FBQUEsK0JBQ0ksb0JBQUMsYUFBRDtBQUFBLGlDQUNJLG9CQUFDLG9CQUFEO0FBQWUsaUJBQUssRUFBQztBQUFyQjtBQURKO0FBREo7QUFESixNQURKLGVBU0ksb0JBQUMsT0FBRDtBQUFTLFdBQUssRUFBQyxvQkFBZjtBQUFBLDZCQUNJLG9CQUFDLElBQUQ7QUFDSSxhQUFLLGVBQ0Qsb0JBQUMsYUFBRDtBQUNJLGVBQUssRUFBQyxRQURWO0FBRUksaUJBQU8sRUFBRTtBQUFBLG1CQUFNK0Usa0JBQWtCLENBQUMsVUFBQTMrQixDQUFDO0FBQUEscUJBQUksQ0FBQ0EsQ0FBTDtBQUFBLGFBQUYsQ0FBeEI7QUFBQTtBQUZiLFVBRlI7QUFBQSwrQkFRSSxvQkFBQyxhQUFEO0FBQ0ksY0FBSSxFQUFFMCtCLGlCQURWO0FBRUkscUJBQVcsTUFGZjtBQUFBLGlDQUlJLG9CQUFDLG9CQUFEO0FBQWUsaUJBQUssRUFBQztBQUFyQjtBQUpKO0FBUko7QUFESixNQVRKLGVBMkJJLG9CQUFDLE9BQUQ7QUFBUyxXQUFLLEVBQUMsY0FBZjtBQUFBLDZCQUNJLG9CQUFDLElBQUQ7QUFDSSxhQUFLLGVBQ0Qsb0JBQUMsYUFBRDtBQUNJLGVBQUssRUFBQyxRQURWO0FBRUksaUJBQU8sRUFBRTtBQUFBLG1CQUFNRyxZQUFZLENBQUMsVUFBQTcrQixDQUFDO0FBQUEscUJBQUksQ0FBQ0EsQ0FBTDtBQUFBLGFBQUYsQ0FBbEI7QUFBQTtBQUZiLFVBRlI7QUFBQSwrQkFRSSxvQkFBQyxhQUFEO0FBQ0ksY0FBSSxFQUFFNCtCLFdBRFY7QUFFSSxpQkFBTyxFQUFFO0FBQUEsbUJBQU1DLFlBQVksQ0FBQyxVQUFBNytCLENBQUM7QUFBQSxxQkFBSSxDQUFDQSxDQUFMO0FBQUEsYUFBRixDQUFsQjtBQUFBLFdBRmI7QUFHSSxlQUFLLE1BSFQ7QUFBQSxpQ0FLSSxvQkFBQyxvQkFBRDtBQUFlLGlCQUFLLEVBQUM7QUFBckI7QUFMSjtBQVJKO0FBREosTUEzQko7QUFBQSxJQURKO0FBZ0RILEM7Ozs7Ozs7Ozs7Ozs7O0FDbkVEO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7QUFFQSxJQUFNb2dCLFlBQUUsR0FBRyxXQUFYO0FBQ0EsSUFBTTVuQixlQUFLLEdBQUcsV0FBZDtBQUNBLElBQU0wZ0MscUJBQVcsR0FBRywyRUFBcEI7QUFDQSxJQUFNVSxlQUFLLEdBQUc7QUFDVkUsRUFBQUEsSUFBSSxFQUFFLG1HQURJO0FBRVZELEVBQUFBLEtBQUssRUFBRTtBQUZHLENBQWQ7QUFLZSxTQUFTaUYsYUFBVCxHQUF5QjtBQUNwQyxrQkFBa0JuMEIsa0JBQVEsQ0FBQyxDQUFELENBQTFCO0FBQUE7QUFBQSxNQUFPMFUsQ0FBUDtBQUFBLE1BQVUwZixJQUFWOztBQUVBLE1BQU16akMsWUFBWSxHQUFHekgscUJBQVcsQ0FBQyxVQUFBeEIsS0FBSyxFQUFJO0FBQ3RDMHNDLElBQUFBLElBQUksQ0FBQzFzQyxLQUFELENBQUo7QUFDSCxHQUYrQixFQUU3QixFQUY2QixDQUFoQztBQUlBLHNCQUNJLG9CQUFDLElBQUQ7QUFBTSxNQUFFLEVBQUUrdEIsWUFBVjtBQUFjLFNBQUssRUFBRTVuQixlQUFyQjtBQUE0QixlQUFXLEVBQUUwZ0MscUJBQXpDO0FBQXNELFNBQUssRUFBRVUsZUFBN0Q7QUFBQSwyQkFDSSxvQkFBQyxPQUFEO0FBQUEsNkJBQ0ksb0JBQUMsSUFBRDtBQUNJLGFBQUssZUFDRCxvQkFBQyxhQUFEO0FBQ0ksZUFBSyxFQUFFdmEsQ0FEWDtBQUVJLGFBQUcsRUFBQyxHQUZSO0FBR0ksYUFBRyxFQUFDLElBSFI7QUFJSSxjQUFJLEVBQUMsR0FKVDtBQUtJLGtCQUFRLE1BTFo7QUFNSSxtQkFBUyxNQU5iO0FBT0ksa0JBQVEsRUFBRS9qQjtBQVBkLFVBRlI7QUFBQSwrQkFhSSxvQkFBQyxtQkFBRDtBQUFXLFdBQUMsRUFBRStqQjtBQUFkO0FBYko7QUFESjtBQURKLElBREo7QUFxQkgsQzs7Ozs7Ozs7Ozs7Ozs7QUM3Q0Q7QUFDQTtBQUVBO0FBQ0E7QUFDQTs7O0FBRUEsSUFBTWUsTUFBRSxHQUFHLEtBQVg7QUFDQSxJQUFNNW5CLFNBQUssR0FBRyxLQUFkO0FBQ0EsSUFBTTBnQyxlQUFXLEdBQUcsMkVBQXBCO0FBQ0EsSUFBTVUsU0FBSyxHQUFHO0FBQ1ZFLEVBQUFBLElBQUksRUFBRSw2RkFESTtBQUVWRCxFQUFBQSxLQUFLLEVBQUU7QUFGRyxDQUFkO0FBS2UsU0FBU21GLE9BQVQsR0FBbUI7QUFDOUIsa0JBQThCcjBCLGtCQUFRLENBQUMsS0FBRCxDQUF0QztBQUFBO0FBQUEsTUFBT3MwQixRQUFQO0FBQUEsTUFBaUJDLFNBQWpCOztBQUVBLHNCQUNJLHFCQUFDLElBQUQ7QUFBTSxNQUFFLEVBQUU5ZSxNQUFWO0FBQWMsU0FBSyxFQUFFNW5CLFNBQXJCO0FBQTRCLGVBQVcsRUFBRTBnQyxlQUF6QztBQUFzRCxTQUFLLEVBQUVVLFNBQTdEO0FBQUEsNEJBQ0ksb0JBQUMsT0FBRDtBQUFTLFdBQUssRUFBQyxXQUFmO0FBQUEsNkJBQ0ksb0JBQUMsSUFBRDtBQUFBLCtCQUNJLG9CQUFDLE9BQUQ7QUFDSSxjQUFJLEVBQUM7QUFEVDtBQURKO0FBREosTUFESixlQVNJLG9CQUFDLE9BQUQ7QUFBUyxXQUFLLEVBQUMsVUFBZjtBQUFBLDZCQUNJLG9CQUFDLElBQUQ7QUFBQSwrQkFDSSxvQkFBQyxPQUFEO0FBQ0ksY0FBSSxFQUFDLE1BRFQ7QUFFSSxjQUFJO0FBRlI7QUFESjtBQURKLE1BVEosZUFrQkksb0JBQUMsT0FBRDtBQUFTLFdBQUssRUFBQyxjQUFmO0FBQUEsNkJBQ0ksb0JBQUMsSUFBRDtBQUFBLCtCQUNJLG9CQUFDLE9BQUQ7QUFDSSxjQUFJLEVBQUMsTUFEVDtBQUVJLGVBQUssRUFBQztBQUZWO0FBREo7QUFESixNQWxCSixlQTJCSSxvQkFBQyxPQUFEO0FBQVMsV0FBSyxFQUFDLG1DQUFmO0FBQUEsNkJBQ0ksb0JBQUMsSUFBRDtBQUFBLCtCQUNJLG9CQUFDLE9BQUQ7QUFDSSxlQUFLLEVBQUMsTUFEVjtBQUVJLHNCQUFZLEVBQUM7QUFGakI7QUFESjtBQURKLE1BM0JKLGVBb0NJLG9CQUFDLE9BQUQ7QUFBUyxXQUFLLEVBQUMsY0FBZjtBQUFBLDZCQUNJLG9CQUFDLElBQUQ7QUFDSSxhQUFLLGVBQ0Qsb0JBQUMsYUFBRDtBQUNJLGVBQUssRUFBQyxRQURWO0FBRUksaUJBQU8sRUFBRTtBQUFBLG1CQUFNc0YsU0FBUyxDQUFDLFVBQUFsL0IsQ0FBQztBQUFBLHFCQUFJLENBQUNBLENBQUw7QUFBQSxhQUFGLENBQWY7QUFBQTtBQUZiLFVBRlI7QUFBQSwrQkFRSSxvQkFBQyxPQUFEO0FBQ0ksY0FBSSxFQUFDLE1BRFQ7QUFFSSxnQkFBTSxFQUFFaS9CO0FBRlo7QUFSSjtBQURKLE1BcENKO0FBQUEsSUFESjtBQXNESCxDOztBQ3hFRDtBQUtBO0FBQ0E7QUFDQTtBQUVBOzs7QUFFQSxJQUFNN2UsWUFBRSxHQUFHLFlBQVg7QUFDQSxJQUFNNW5CLGVBQUssR0FBRyxZQUFkO0FBQ0EsSUFBTTBnQyxxQkFBVyxHQUFHLGlHQUFwQjtBQUNBLElBQU1VLGVBQUssR0FBRztBQUNWRSxFQUFBQSxJQUFJLEVBQUU7QUFESSxDQUFkO0FBSWUsU0FBU3FGLGFBQVQsR0FBeUI7QUFDcEMsc0JBQ0kscUJBQUMsSUFBRDtBQUFNLE1BQUUsRUFBRS9lLFlBQVY7QUFBYyxTQUFLLEVBQUU1bkIsZUFBckI7QUFBNEIsZUFBVyxFQUFFMGdDLHFCQUF6QztBQUFzRCxTQUFLLEVBQUVVLGVBQTdEO0FBQUEsNEJBQ0ksb0JBQUMsT0FBRDtBQUFTLFdBQUssRUFBQyxrQkFBZjtBQUFBLDZCQUNJLG9CQUFDLElBQUQ7QUFBQSwrQkFDSSxvQkFBQyxvQkFBRDtBQUFXLGVBQUssRUFBQyxPQUFqQjtBQUFBLGlDQUNJLG9CQUFDLGlCQUFEO0FBREo7QUFESjtBQURKLE1BREosZUFTSSxvQkFBQyxPQUFEO0FBQVMsV0FBSyxFQUFDLHlDQUFmO0FBQUEsNkJBQ0ksb0JBQUMsSUFBRDtBQUFBLCtCQUNJLG9CQUFDLG9CQUFEO0FBQVcsZUFBSyxFQUFDLE9BQWpCO0FBQXlCLGtCQUFRLE1BQWpDO0FBQUEsaUNBQ0ksb0JBQUMsaUJBQUQ7QUFESjtBQURKO0FBREosTUFUSixlQWlCSSxvQkFBQyxPQUFEO0FBQVMsV0FBSyxFQUFDLG9CQUFmO0FBQUEsNkJBQ0ksb0JBQUMsSUFBRDtBQUFBLCtCQUNJLG9CQUFDLG9CQUFEO0FBQVcsZUFBSyxFQUFDLE9BQWpCO0FBQXlCLGdCQUFNLE1BQS9CO0FBQUEsaUNBQ0ksb0JBQUMsaUJBQUQ7QUFESjtBQURKO0FBREosTUFqQkosZUF5Qkksb0JBQUMsT0FBRDtBQUFTLFdBQUssRUFBQywrQkFBZjtBQUFBLDZCQUNJLG9CQUFDLElBQUQ7QUFBQSwrQkFDSSxvQkFBQyxvQkFBRDtBQUFXLGVBQUssRUFBQyxPQUFqQjtBQUF5QixzQkFBWSxNQUFyQztBQUFBLGlDQUNJLG9CQUFDLGlCQUFEO0FBREo7QUFESjtBQURKLE1BekJKO0FBQUEsSUFESjtBQW1DSCxDOzs7OztBQ3RERDtBQUVBO0FBRUF3RiwyQkFBQSxDQUFrQjtBQUNkM0csRUFBQUEsU0FBUyxFQUFUQSxTQURjO0FBRWQ2RyxFQUFBQSxVQUFVLEVBQUU7QUFGRSxDQUFsQjtBQUtBLCtDQUFlRixrQkFBZixFOzs7O0FDVEE7QUFDQTtBQUVBO0FBRUE7O0FBRUEsSUFBTXJHLElBQUksR0FBR3dHLFFBQVEsQ0FBQ0MsTUFBRCxDQUFyQjtBQUVlLFNBQVNDLFFBQVQsR0FBb0I7QUFDL0Isc0JBQ0ksb0JBQUMsSUFBRDtBQUFNLE1BQUUsRUFBQyxNQUFUO0FBQUEsMkJBQ0k7QUFDSSxlQUFTLEVBQUMsVUFEZDtBQUVJLDZCQUF1QixFQUFFO0FBQUV6RyxRQUFBQSxNQUFNLEVBQUVEO0FBQVY7QUFGN0I7QUFESixJQURKO0FBUUgsQzs7Ozs7Ozs7Ozs7Ozs7QUNsQkQ7QUFDQTtBQUlBO0FBQ0E7QUFDQTs7O0FBRUEsSUFBTTNZLGFBQUUsR0FBRyxhQUFYO0FBQ0EsSUFBTTVuQixnQkFBSyxHQUFHLGFBQWQ7QUFDQSxJQUFNMGdDLHNCQUFXLEdBQUcsZ0ZBQXBCO0FBQ0EsSUFBTVUsZ0JBQUssR0FBRztBQUNWRSxFQUFBQSxJQUFJLEVBQUUscUdBREk7QUFFVkQsRUFBQUEsS0FBSyxFQUFFO0FBRkcsQ0FBZDtBQUtlLFNBQVM2RixjQUFULEdBQTBCO0FBQ3JDLGtCQUFzQi8wQixrQkFBUSxDQUFDLElBQUQsQ0FBOUI7QUFBQTtBQUFBLE1BQU9nMUIsSUFBUDtBQUFBLE1BQWFDLEtBQWI7O0FBRUEsc0JBQ0kscUJBQUMsSUFBRDtBQUFNLE1BQUUsRUFBRXhmLGFBQVY7QUFBYyxTQUFLLEVBQUU1bkIsZ0JBQXJCO0FBQTRCLGVBQVcsRUFBRTBnQyxzQkFBekM7QUFBc0QsU0FBSyxFQUFFVSxnQkFBN0Q7QUFBQSw0QkFDSSxvQkFBQyxPQUFEO0FBQVMsV0FBSyxFQUFDLG1CQUFmO0FBQUEsNkJBQ0ksb0JBQUMsSUFBRDtBQUFBLCtCQUNJLG9CQUFDLHNCQUFEO0FBQ0ksY0FBSSxFQUFDO0FBRFQ7QUFESjtBQURKLE1BREosZUFTSSxvQkFBQyxPQUFEO0FBQVMsV0FBSyxFQUFDLHNCQUFmO0FBQUEsNkJBQ0ksb0JBQUMsSUFBRDtBQUFBLCtCQUNJLG9CQUFDLHNCQUFEO0FBQ0ksY0FBSSxFQUFFK0YsSUFBSSxHQUFHLFVBQUgsR0FBZ0IsaUJBRDlCO0FBRUksaUJBQU8sRUFBRTtBQUFBLG1CQUFNQyxLQUFLLENBQUMsVUFBQTUvQixDQUFDO0FBQUEscUJBQUksQ0FBQ0EsQ0FBTDtBQUFBLGFBQUYsQ0FBWDtBQUFBO0FBRmI7QUFESjtBQURKLE1BVEo7QUFBQSxJQURKO0FBb0JILEM7Ozs7Ozs7O0FDeENEO0FBSUEsSUFBTW9nQixZQUFFLEdBQUcsWUFBWDtBQUNBLElBQU01bkIsZUFBSyxHQUFHLFlBQWQ7QUFDQSxJQUFNMGdDLHFCQUFXLEdBQUcsa0VBQXBCO0FBQ0EsSUFBTVUsZUFBSyxHQUFHO0FBQ1ZFLEVBQUFBLElBQUksRUFBRSxvR0FESTtBQUVWRCxFQUFBQSxLQUFLLEVBQUU7QUFGRyxDQUFkO0FBS0E7QUFDQTtBQUNBO0FBRUE7OztBQUVBLElBQU1nRyxhQUFhLEdBQUcsSUFBSTNnQyxLQUFKLENBQVUsRUFBVixFQUFjNGdDLElBQWQsQ0FBbUIsQ0FBbkIsRUFBc0JsbkMsR0FBdEIsQ0FBMEI7QUFBQSxTQUFPO0FBQ25Ea29CLElBQUFBLFFBQVEsRUFBRSxrQ0FEeUM7QUFFbkQzcUIsSUFBQUEsS0FBSyxFQUFFO0FBRjRDLEdBQVA7QUFBQSxDQUExQixDQUF0QjtBQUtBLElBQU00cEMsWUFBWSxHQUFHLElBQUk3Z0MsS0FBSixDQUFVLEVBQVYsRUFBYzRnQyxJQUFkLENBQW1CLENBQW5CLEVBQXNCbG5DLEdBQXRCLENBQTBCO0FBQUEsU0FBTztBQUNsRGtvQixJQUFBQSxRQUFRLGlDQUEwQnhlLElBQUksQ0FBQzA5QixNQUFMLEtBQWdCLEdBQWhCLEdBQXNCLFNBQXRCLEdBQWtDLFNBQTVELFNBRDBDO0FBRWxEN3BDLElBQUFBLEtBQUssRUFBRTtBQUYyQyxHQUFQO0FBQUEsQ0FBMUIsQ0FBckI7QUFLZSxTQUFTOHBDLGFBQVQsR0FBeUI7QUFDcEMsc0JBQ0kscUJBQUMsSUFBRDtBQUFNLE1BQUUsRUFBRTdmLFlBQVY7QUFBYyxTQUFLLEVBQUU1bkIsZUFBckI7QUFBNEIsZUFBVyxFQUFFMGdDLHFCQUF6QztBQUFzRCxTQUFLLEVBQUVVLGVBQTdEO0FBQUEsNEJBQ0ksb0JBQUMsT0FBRDtBQUFTLFFBQUUsRUFBQyxxQkFBWjtBQUFrQyxXQUFLLEVBQUMscUJBQXhDO0FBQUEsNkJBQ0ksb0JBQUMsSUFBRDtBQUFBLCtCQUNJLG9CQUFDLG9CQUFEO0FBQUEsb0JBQ0tpRyxhQUFhLENBQUNqbkMsR0FBZCxDQUFrQixVQUFDb1gsSUFBRCxFQUFPcUYsS0FBUDtBQUFBLGdDQUNmLG9CQUFDLHlCQUFELG1DQUFnQ3JGLElBQWhDLEdBQXFCcUYsS0FBckIsQ0FEZTtBQUFBLFdBQWxCO0FBREw7QUFESjtBQURKLE1BREosZUFXSSxvQkFBQyxPQUFEO0FBQVMsUUFBRSxFQUFDLHFCQUFaO0FBQWtDLFdBQUssRUFBQywwQ0FBeEM7QUFBQSw2QkFDSSxvQkFBQyxJQUFEO0FBQUEsK0JBQ0ksb0JBQUMsb0JBQUQ7QUFBVyw0QkFBa0IsTUFBN0I7QUFBQSxvQkFDS3dxQixhQUFhLENBQUNqbkMsR0FBZCxDQUFrQixVQUFDb1gsSUFBRCxFQUFPcUYsS0FBUDtBQUFBLGdDQUNmLG9CQUFDLHlCQUFELG1DQUFnQ3JGLElBQWhDLEdBQXFCcUYsS0FBckIsQ0FEZTtBQUFBLFdBQWxCO0FBREw7QUFESjtBQURKLE1BWEosZUFxQkksb0JBQUMsT0FBRDtBQUFTLFFBQUUsRUFBQyxvQkFBWjtBQUFpQyxXQUFLLEVBQUMsbUJBQXZDO0FBQUEsNkJBQ0ksb0JBQUMsSUFBRDtBQUFBLCtCQUNJLG9CQUFDLG9CQUFEO0FBQVcsaUJBQU8sTUFBbEI7QUFBQSxvQkFDSzBxQixZQUFZLENBQUNubkMsR0FBYixDQUFpQixVQUFDb1gsSUFBRCxFQUFPcUYsS0FBUDtBQUFBLGdDQUNkLG9CQUFDLHlCQUFELG1DQUFnQ3JGLElBQWhDLEdBQXFCcUYsS0FBckIsQ0FEYztBQUFBLFdBQWpCO0FBREw7QUFESjtBQURKLE1BckJKLGVBK0JJLG9CQUFDLE9BQUQ7QUFBUyxRQUFFLEVBQUMsb0JBQVo7QUFBaUMsV0FBSyxFQUFDLHlDQUF2QztBQUFBLDZCQUNJLG9CQUFDLElBQUQ7QUFBQSwrQkFDSSxvQkFBQyxvQkFBRDtBQUFXLGlCQUFPLE1BQWxCO0FBQW1CLDRCQUFrQixNQUFyQztBQUFBLG9CQUNLMHFCLFlBQVksQ0FBQ25uQyxHQUFiLENBQWlCLFVBQUNvWCxJQUFELEVBQU9xRixLQUFQO0FBQUEsZ0NBQ2Qsb0JBQUMseUJBQUQsbUNBQWdDckYsSUFBaEMsR0FBcUJxRixLQUFyQixDQURjO0FBQUEsV0FBakI7QUFETDtBQURKO0FBREosTUEvQko7QUFBQSxJQURKO0FBMkNILEM7O0FDeEVEO0FBSUE7QUFDQTtBQUNBO0FBRUE7OztBQUVBLElBQU0rSyxhQUFFLEdBQUcsYUFBWDtBQUNBLElBQU01bkIsZ0JBQUssR0FBRyxhQUFkO0FBQ0EsSUFBTTBnQyxzQkFBVyxHQUFHLHNFQUFwQjtBQUNBLElBQU1VLGdCQUFLLEdBQUc7QUFDVkUsRUFBQUEsSUFBSSxFQUFFLHFHQURJO0FBRVZELEVBQUFBLEtBQUssRUFBRTtBQUZHLENBQWQ7QUFLZSxTQUFTcUcsY0FBVCxHQUEwQjtBQUNyQyxzQkFDSSxxQkFBQyxJQUFEO0FBQU0sTUFBRSxFQUFFOWYsYUFBVjtBQUFjLFNBQUssRUFBRTVuQixnQkFBckI7QUFBNEIsZUFBVyxFQUFFMGdDLHNCQUF6QztBQUFzRCxTQUFLLEVBQUVVLGdCQUE3RDtBQUFBLDRCQUNJLG9CQUFDLE9BQUQ7QUFBUyxXQUFLLEVBQUMsWUFBZjtBQUFBLDZCQUNJLG9CQUFDLElBQUQ7QUFBQSwrQkFDSSxxQkFBQyxzQkFBRDtBQUFBLGtDQUNJLG9CQUFDLDJCQUFEO0FBQWlCLGdCQUFJLEVBQUM7QUFBdEIsWUFESixlQUVJLG9CQUFDLDJCQUFEO0FBQWlCLGdCQUFJLEVBQUM7QUFBdEIsWUFGSixlQUdJLG9CQUFDLDJCQUFEO0FBQWlCLGdCQUFJLEVBQUM7QUFBdEIsWUFISixlQUlJLG9CQUFDLDJCQUFEO0FBQWlCLGdCQUFJLEVBQUM7QUFBdEIsWUFKSixlQUtJLG9CQUFDLDJCQUFEO0FBQWlCLGdCQUFJLEVBQUM7QUFBdEIsWUFMSixlQU1JLG9CQUFDLDJCQUFEO0FBQWlCLGdCQUFJLEVBQUM7QUFBdEIsWUFOSixlQU9JLG9CQUFDLDJCQUFEO0FBQWlCLGdCQUFJLEVBQUM7QUFBdEIsWUFQSjtBQUFBO0FBREo7QUFESixNQURKLGVBZUksb0JBQUMsT0FBRDtBQUFTLFdBQUssRUFBQyxhQUFmO0FBQUEsNkJBQ0ksb0JBQUMsSUFBRDtBQUFBLCtCQUNJLHFCQUFDLHNCQUFEO0FBQUEsa0NBQ0kscUJBQUMsMkJBQUQ7QUFBaUIsZ0JBQUksTUFBckI7QUFBQSxvQ0FDSSxvQkFBQywyQkFBRCxLQURKLGVBRUksb0JBQUMsMkJBQUQsS0FGSixlQUdJLG9CQUFDLDJCQUFELEtBSEo7QUFBQSxZQURKLGVBTUksb0JBQUMsMkJBQUQsS0FOSixlQU9JLG9CQUFDLDJCQUFELEtBUEo7QUFBQTtBQURKO0FBREosTUFmSjtBQUFBLElBREo7QUErQkgsQzs7Ozs7Ozs7Ozs7Ozs7QUNsREQ7QUFDQTtBQUtBO0FBQ0E7QUFDQTs7O0FBRUEsSUFBTXhaLGlCQUFFLEdBQUcsaUJBQVg7QUFDQSxJQUFNNW5CLG9CQUFLLEdBQUcsaUJBQWQ7QUFDQSxJQUFNMGdDLDBCQUFXLEdBQUcsMEZBQXBCO0FBQ0EsSUFBTVUsb0JBQUssR0FBRztBQUNWRSxFQUFBQSxJQUFJLEVBQUUsRUFESTtBQUVWRCxFQUFBQSxLQUFLLEVBQUU7QUFGRyxDQUFkO0FBS2UsU0FBU3NHLGtCQUFULEdBQThCO0FBQ3pDLGtCQUE4QngxQixrQkFBUSxDQUFDLElBQUQsQ0FBdEM7QUFBQTtBQUFBLE1BQU95MUIsUUFBUDtBQUFBLE1BQWlCakQsU0FBakI7O0FBRUEsc0JBQ0kscUJBQUMsSUFBRDtBQUFNLE1BQUUsRUFBRS9jLGlCQUFWO0FBQWMsU0FBSyxFQUFFNW5CLG9CQUFyQjtBQUE0QixlQUFXLEVBQUUwZ0MsMEJBQXpDO0FBQXNELFNBQUssRUFBRVUsb0JBQTdEO0FBQUEsNEJBQ0ksb0JBQUMsT0FBRDtBQUFTLFdBQUssRUFBQyx1QkFBZjtBQUFBLDZCQUNJLG9CQUFDLElBQUQ7QUFBQSwrQkFDSSxvQkFBQyw4QkFBRDtBQUFnQixlQUFLLEVBQUM7QUFBdEI7QUFESjtBQURKLE1BREosZUFPSSxvQkFBQyxPQUFEO0FBQVMsV0FBSyxFQUFDLCtCQUFmO0FBQUEsNkJBQ0ksb0JBQUMsSUFBRDtBQUFBLCtCQUNJLG9CQUFDLDhCQUFEO0FBQWdCLGVBQUssRUFBQyxJQUF0QjtBQUEyQixnQkFBTSxFQUFDO0FBQWxDO0FBREo7QUFESixNQVBKLGVBYUksb0JBQUMsT0FBRDtBQUFTLFdBQUssRUFBQywrQkFBZjtBQUFBLDZCQUNJLG9CQUFDLElBQUQ7QUFBQSwrQkFDSSxvQkFBQyw4QkFBRDtBQUFnQix1QkFBYTtBQUE3QjtBQURKO0FBREosTUFiSixlQW1CSSxvQkFBQyxPQUFEO0FBQVMsV0FBSyxFQUFDLHdCQUFmO0FBQUEsNkJBQ0ksb0JBQUMsSUFBRDtBQUNJLGFBQUssZUFDRCxvQkFBQyxhQUFEO0FBQVEsaUJBQU8sRUFBRTtBQUFBLG1CQUFNdUQsU0FBUyxDQUFDLFVBQUFuOUIsQ0FBQztBQUFBLHFCQUFJLENBQUNBLENBQUw7QUFBQSxhQUFGLENBQWY7QUFBQSxXQUFqQjtBQUFBO0FBQUEsVUFGUjtBQUFBLCtCQUtJLG9CQUFDLDhCQUFEO0FBQWdCLGdCQUFNLEVBQUVvZ0MsUUFBeEI7QUFBa0MsZUFBSyxFQUFDO0FBQXhDO0FBTEo7QUFESixNQW5CSjtBQUFBLElBREo7QUErQkgsQzs7QUNwREQ7QUFRQTtBQUNBO0FBQ0E7OztBQUVBLElBQU1oZ0IsT0FBRSxHQUFHLE1BQVg7QUFDQSxJQUFNNW5CLFVBQUssR0FBRyxNQUFkO0FBQ0EsSUFBTTBnQyxnQkFBVyxHQUFHLDhFQUFwQjtBQUNBLElBQU1VLFVBQUssR0FBRztBQUNWRSxFQUFBQSxJQUFJLEVBQUUsOEZBREk7QUFFVkQsRUFBQUEsS0FBSyxFQUFFO0FBRkcsQ0FBZDtBQUtlLFNBQVN3RyxRQUFULEdBQW9CO0FBQy9CLHNCQUNJLHFCQUFDLElBQUQ7QUFBTSxNQUFFLEVBQUVqZ0IsT0FBVjtBQUFjLFNBQUssRUFBRTVuQixVQUFyQjtBQUE0QixlQUFXLEVBQUUwZ0MsZ0JBQXpDO0FBQXNELFNBQUssRUFBRVUsVUFBN0Q7QUFBQSw0QkFDSSxvQkFBQyxPQUFEO0FBQVMsV0FBSyxFQUFDLGtCQUFmO0FBQUEsNkJBQ0ksb0JBQUMsSUFBRDtBQUFBLCtCQUNJLHFCQUFDLFNBQUQ7QUFBQSxrQ0FDSSxvQkFBQyxhQUFEO0FBQ0ksZ0JBQUksRUFBQztBQURULFlBREosZUFLSSxvQkFBQyxhQUFEO0FBQ0ksZ0JBQUksRUFBQztBQURULFlBTEosZUFTSSxvQkFBQyxhQUFEO0FBQ0ksZ0JBQUksRUFBQztBQURULFlBVEo7QUFBQTtBQURKO0FBREosTUFESixlQW1CSSxxQkFBQyxPQUFEO0FBQVMsV0FBSyxFQUFDLGVBQWY7QUFBQSw4QkFDSSxvQkFBQyxJQUFEO0FBQUEsK0JBQ0kscUJBQUMsU0FBRDtBQUFBLGtDQUNJLG9CQUFDLGFBQUQ7QUFDSSx1QkFBVyxFQUFDLFFBRGhCO0FBRUkseUJBQWEsRUFBQztBQUZsQixZQURKLGVBTUksb0JBQUMsYUFBRDtBQUNJLHVCQUFXLEVBQUMsUUFEaEI7QUFFSSx5QkFBYSxFQUFDO0FBRmxCLFlBTkosZUFXSSxvQkFBQyxhQUFEO0FBQ0ksdUJBQVcsRUFBQyxRQURoQjtBQUVJLHlCQUFhLEVBQUM7QUFGbEIsWUFYSjtBQUFBO0FBREosUUFESixlQW9CSSxvQkFBQyxJQUFEO0FBQUEsK0JBQ0kscUJBQUMsU0FBRDtBQUFBLGtDQUNJLG9CQUFDLGFBQUQ7QUFDSSx3QkFBWSxFQUFDLFVBRGpCO0FBRUksdUJBQVcsRUFBQztBQUZoQixZQURKLGVBTUksb0JBQUMsYUFBRDtBQUNJLHdCQUFZLEVBQUMsVUFEakI7QUFFSSx1QkFBVyxFQUFDO0FBRmhCLFlBTkosZUFXSSxvQkFBQyxhQUFEO0FBQ0ksd0JBQVksRUFBQyxVQURqQjtBQUVJLHVCQUFXLEVBQUM7QUFGaEIsWUFYSjtBQUFBO0FBREosUUFwQko7QUFBQSxNQW5CSixlQTJESSxvQkFBQyxPQUFEO0FBQVMsV0FBSyxFQUFDLGlCQUFmO0FBQUEsNkJBQ0ksb0JBQUMsSUFBRDtBQUFBLCtCQUNJLHFCQUFDLFNBQUQ7QUFBQSxrQ0FDSSxvQkFBQyxhQUFEO0FBQ0ksd0JBQVksRUFBQyxVQURqQjtBQUVJLHVCQUFXLEVBQUMsUUFGaEI7QUFHSSx5QkFBYSxFQUFDO0FBSGxCLFlBREosZUFPSSxvQkFBQyxhQUFEO0FBQ0ksd0JBQVksRUFBQyxVQURqQjtBQUVJLHVCQUFXLEVBQUMsUUFGaEI7QUFHSSx5QkFBYSxFQUFDO0FBSGxCLFlBUEosZUFhSSxvQkFBQyxhQUFEO0FBQ0ksd0JBQVksRUFBQyxVQURqQjtBQUVJLHVCQUFXLEVBQUMsUUFGaEI7QUFHSSx5QkFBYSxFQUFDO0FBSGxCLFlBYko7QUFBQTtBQURKO0FBREosTUEzREosZUFtRkksb0JBQUMsT0FBRDtBQUFTLFdBQUssRUFBQyxpQkFBZjtBQUFBLDZCQUNJLG9CQUFDLElBQUQ7QUFBQSwrQkFDSSxxQkFBQyxTQUFEO0FBQUEsa0NBQ0ksb0JBQUMsYUFBRDtBQUNJLGdCQUFJLEVBQUMsTUFEVDtBQUVJLGdCQUFJLEVBQUM7QUFGVCxZQURKLGVBTUksb0JBQUMsYUFBRDtBQUNJLGdCQUFJLEVBQUMsTUFEVDtBQUVJLGdCQUFJLEVBQUM7QUFGVCxZQU5KLGVBV0ksb0JBQUMsYUFBRDtBQUNJLGdCQUFJLEVBQUMsTUFEVDtBQUVJLGdCQUFJLEVBQUM7QUFGVCxZQVhKO0FBQUE7QUFESjtBQURKLE1BbkZKLGVBd0dJLG9CQUFDLE9BQUQ7QUFBUyxXQUFLLEVBQUMsa0JBQWY7QUFBQSw2QkFDSSxvQkFBQyxJQUFEO0FBQUEsK0JBQ0kscUJBQUMsU0FBRDtBQUFBLGtDQUNJLG9CQUFDLGFBQUQ7QUFDSSxpQkFBSyxlQUNEO0FBQUssaUJBQUcsRUFBQztBQUFULGNBRlI7QUFJSSxnQkFBSSxFQUFDO0FBSlQsWUFESixlQVFJLG9CQUFDLGFBQUQ7QUFDSSxpQkFBSyxlQUNEO0FBQUssaUJBQUcsRUFBQztBQUFULGNBRlI7QUFJSSxnQkFBSSxFQUFDO0FBSlQsWUFSSixlQWVJLG9CQUFDLGFBQUQ7QUFDSSxpQkFBSyxlQUNEO0FBQUssaUJBQUcsRUFBQztBQUFULGNBRlI7QUFJSSxnQkFBSSxFQUFDO0FBSlQsWUFmSjtBQUFBO0FBREo7QUFESixNQXhHSixlQW1JSSxvQkFBQyxPQUFEO0FBQVMsV0FBSyxFQUFDLHNCQUFmO0FBQUEsNkJBQ0ksb0JBQUMsSUFBRDtBQUFBLCtCQUNJLHFCQUFDLFNBQUQ7QUFBQSxrQ0FDSSxvQkFBQyxhQUFEO0FBQ0kscUJBQVMsZUFDTDtBQUFLLGlCQUFHLEVBQUM7QUFBVCxjQUZSO0FBSUksZ0JBQUksRUFBQztBQUpULFlBREosZUFRSSxvQkFBQyxhQUFEO0FBQ0kscUJBQVMsZUFDTDtBQUFLLGlCQUFHLEVBQUM7QUFBVCxjQUZSO0FBSUksZ0JBQUksRUFBQztBQUpULFlBUkosZUFlSSxvQkFBQyxhQUFEO0FBQ0kscUJBQVMsZUFDTDtBQUFLLGlCQUFHLEVBQUM7QUFBVCxjQUZSO0FBSUksZ0JBQUksRUFBQztBQUpULFlBZko7QUFBQTtBQURKO0FBREosTUFuSUosZUE4Skksb0JBQUMsT0FBRDtBQUFTLFdBQUssRUFBQyxrQkFBZjtBQUFBLDZCQUNJLG9CQUFDLElBQUQ7QUFBQSwrQkFDSSxxQkFBQyxTQUFEO0FBQUEsa0NBQ0ksb0JBQUMsYUFBRDtBQUNJLGlCQUFLLGVBQ0Q7QUFBSyxpQkFBRyxFQUFDO0FBQVQsY0FGUjtBQUlJLGdCQUFJLEVBQUM7QUFKVCxZQURKLGVBUUksb0JBQUMsYUFBRDtBQUNJLGlCQUFLLGVBQ0Q7QUFBSyxpQkFBRyxFQUFDO0FBQVQsY0FGUjtBQUlJLGdCQUFJLEVBQUM7QUFKVCxZQVJKLGVBZUksb0JBQUMsYUFBRDtBQUNJLGlCQUFLLGVBQ0Q7QUFBSyxpQkFBRyxFQUFDO0FBQVQsY0FGUjtBQUlJLGdCQUFJLEVBQUM7QUFKVCxZQWZKO0FBQUE7QUFESjtBQURKLE1BOUpKLGVBeUxJLG9CQUFDLE9BQUQ7QUFBUyxXQUFLLEVBQUMsc0JBQWY7QUFBQSw2QkFDSSxvQkFBQyxJQUFEO0FBQUEsK0JBQ0kscUJBQUMsU0FBRDtBQUFBLGtDQUNJLG9CQUFDLGFBQUQ7QUFDSSwyQkFBZSxlQUNYLG9CQUFDLGlCQUFEO0FBQVUsNEJBQWMsRUFBRTtBQUExQixjQUZSO0FBSUksZ0JBQUksRUFBQztBQUpULFlBREosZUFRSSxvQkFBQyxhQUFEO0FBQ0ksMkJBQWUsZUFDWCxvQkFBQyxpQkFBRDtBQUFVLDRCQUFjLEVBQUU7QUFBMUIsY0FGUjtBQUlJLGdCQUFJLEVBQUM7QUFKVCxZQVJKLGVBZUksb0JBQUMsYUFBRDtBQUNJLDJCQUFlLGVBQ1gsb0JBQUMsaUJBQUQ7QUFBVSw0QkFBYyxFQUFFO0FBQTFCLGNBRlI7QUFJSSxnQkFBSSxFQUFDO0FBSlQsWUFmSjtBQUFBO0FBREo7QUFESixNQXpMSixlQW9OSSxvQkFBQyxPQUFEO0FBQVMsV0FBSyxFQUFDLGtCQUFmO0FBQUEsNkJBQ0ksb0JBQUMsSUFBRDtBQUFBLCtCQUNJLHFCQUFDLFNBQUQ7QUFBQSxrQ0FDSSxvQkFBQyxhQUFEO0FBQ0ksd0JBQVksZUFDUixvQkFBQyxXQUFELEtBRlI7QUFJSSxnQkFBSSxFQUFDO0FBSlQsWUFESixlQVFJLG9CQUFDLGFBQUQ7QUFDSSx3QkFBWSxlQUNSLG9CQUFDLFdBQUQ7QUFBTyxxQkFBTztBQUFkLGNBRlI7QUFJSSxnQkFBSSxFQUFDO0FBSlQsWUFSSixlQWVJLG9CQUFDLGFBQUQ7QUFDSSx3QkFBWSxlQUNSLG9CQUFDLFdBQUQsS0FGUjtBQUlJLGdCQUFJLEVBQUM7QUFKVCxZQWZKO0FBQUE7QUFESjtBQURKLE1BcE5KLGVBK09JLG9CQUFDLE9BQUQ7QUFBUyxXQUFLLEVBQUMsb0JBQWY7QUFBQSw2QkFDSSxvQkFBQyxJQUFEO0FBQUEsK0JBQ0kscUJBQUMsU0FBRDtBQUFBLGtDQUNJLG9CQUFDLGFBQUQ7QUFDSSx5QkFBYSxlQUNULG9CQUFDLGFBQUQsS0FGUjtBQUlJLGdCQUFJLEVBQUM7QUFKVCxZQURKLGVBUUksb0JBQUMsYUFBRDtBQUNJLHlCQUFhLGVBQ1Qsb0JBQUMsYUFBRDtBQUFRLHFCQUFPO0FBQWYsY0FGUjtBQUlJLGdCQUFJLEVBQUM7QUFKVCxZQVJKLGVBZUksb0JBQUMsYUFBRDtBQUNJLHlCQUFhLGVBQ1Qsb0JBQUMsYUFBRCxLQUZSO0FBSUksZ0JBQUksRUFBQztBQUpULFlBZko7QUFBQTtBQURKO0FBREosTUEvT0osZUEwUUksb0JBQUMsT0FBRDtBQUFTLFdBQUssRUFBQywwQkFBZjtBQUFBLDZCQUNJLG9CQUFDLElBQUQ7QUFBQSwrQkFDSSxxQkFBQyxTQUFEO0FBQUEsa0NBQ0ksb0JBQUMsYUFBRDtBQUNJLGdCQUFJLEVBQUMsUUFEVDtBQUVJLHdCQUFZLEVBQUM7QUFGakIsWUFESixlQU1JLG9CQUFDLGFBQUQ7QUFDSSxnQkFBSSxFQUFDLFFBRFQ7QUFFSSx3QkFBWSxFQUFDO0FBRmpCLFlBTkosZUFXSSxvQkFBQyxhQUFEO0FBQ0ksZ0JBQUksRUFBQyxRQURUO0FBRUksd0JBQVksRUFBQztBQUZqQixZQVhKO0FBQUE7QUFESjtBQURKLE1BMVFKLGVBK1JJLG9CQUFDLE9BQUQ7QUFBUyxXQUFLLEVBQUMseUJBQWY7QUFBQSw2QkFDSSxvQkFBQyxJQUFEO0FBQUEsK0JBQ0kscUJBQUMsU0FBRDtBQUFBLGtDQUNJLG9CQUFDLGFBQUQ7QUFDSSxnQkFBSSxFQUFDLFFBRFQ7QUFFSSxnQkFBSSxFQUFDO0FBRlQsWUFESixlQU1JLG9CQUFDLGFBQUQ7QUFDSSxnQkFBSSxFQUFDLFFBRFQ7QUFFSSxnQkFBSSxFQUFDO0FBRlQsWUFOSixlQVdJLG9CQUFDLGFBQUQ7QUFDSSxnQkFBSSxFQUFDLFFBRFQ7QUFFSSxnQkFBSSxFQUFDO0FBRlQsWUFYSjtBQUFBO0FBREo7QUFESixNQS9SSixlQW9USSxvQkFBQyxPQUFEO0FBQVMsV0FBSyxFQUFDLCtCQUFmO0FBQUEsNkJBQ0ksb0JBQUMsSUFBRDtBQUFBLCtCQUNJLHFCQUFDLFNBQUQ7QUFBQSxrQ0FDSSxvQkFBQyxhQUFEO0FBQ0ksZ0JBQUksRUFBQyxRQURUO0FBRUksNEJBQWdCLGVBQ1osb0JBQUMsaUJBQUQ7QUFIUixZQURKLGVBUUksb0JBQUMsYUFBRDtBQUNJLGdCQUFJLEVBQUMsUUFEVDtBQUVJLDRCQUFnQixlQUNaLG9CQUFDLGlCQUFEO0FBQVUscUJBQU87QUFBakI7QUFIUixZQVJKLGVBZUksb0JBQUMsYUFBRDtBQUNJLGdCQUFJLEVBQUMsUUFEVDtBQUVJLDRCQUFnQixlQUNaLG9CQUFDLGlCQUFEO0FBSFIsWUFmSjtBQUFBO0FBREo7QUFESixNQXBUSixlQStVSSxvQkFBQyxPQUFEO0FBQVMsV0FBSyxFQUFDLDJCQUFmO0FBQUEsNkJBQ0ksb0JBQUMsSUFBRDtBQUFBLCtCQUNJLHFCQUFDLFNBQUQ7QUFBQSxrQ0FDSSxvQkFBQyxhQUFEO0FBQ0ksZ0JBQUksRUFBQyxRQURUO0FBRUkseUJBQWEsZUFDVCxvQkFBQyxXQUFEO0FBSFIsWUFESixlQVFJLG9CQUFDLGFBQUQ7QUFDSSxnQkFBSSxFQUFDLFFBRFQ7QUFFSSx5QkFBYSxlQUNULG9CQUFDLFdBQUQ7QUFBTyxxQkFBTztBQUFkO0FBSFIsWUFSSixlQWVJLG9CQUFDLGFBQUQ7QUFDSSxnQkFBSSxFQUFDLFFBRFQ7QUFFSSx5QkFBYSxlQUNULG9CQUFDLFdBQUQ7QUFIUixZQWZKO0FBQUE7QUFESjtBQURKLE1BL1VKLGVBMFdJLG9CQUFDLE9BQUQ7QUFBUyxXQUFLLEVBQUMsNkJBQWY7QUFBQSw2QkFDSSxvQkFBQyxJQUFEO0FBQUEsK0JBQ0kscUJBQUMsU0FBRDtBQUFBLGtDQUNJLG9CQUFDLGFBQUQ7QUFDSSxnQkFBSSxFQUFDLFFBRFQ7QUFFSSwwQkFBYyxlQUNWLG9CQUFDLGFBQUQ7QUFIUixZQURKLGVBUUksb0JBQUMsYUFBRDtBQUNJLGdCQUFJLEVBQUMsUUFEVDtBQUVJLDBCQUFjLGVBQ1Ysb0JBQUMsYUFBRDtBQUFRLHNCQUFRO0FBQWhCO0FBSFIsWUFSSixlQWVJLG9CQUFDLGFBQUQ7QUFDSSxnQkFBSSxFQUFDLFFBRFQ7QUFFSSwwQkFBYyxlQUNWLG9CQUFDLGFBQUQ7QUFIUixZQWZKO0FBQUE7QUFESjtBQURKLE1BMVdKO0FBQUEsSUFESjtBQXVZSCxDOzs7Ozs7Ozs7Ozs7OztBQzVaRDtBQUNBO0FBUUE7QUFDQTtBQUNBO0FBRUE7Ozs7QUFFQSxJQUFNeFosT0FBRSxHQUFHLE1BQVg7QUFDQSxJQUFNNW5CLFVBQUssR0FBRyxNQUFkO0FBQ0EsSUFBTTBnQyxnQkFBVyxHQUFHLHdEQUFwQjtBQUNBLElBQU1VLFVBQUssR0FBRztBQUNWRSxFQUFBQSxJQUFJLEVBQUUsOEZBREk7QUFFVkQsRUFBQUEsS0FBSyxFQUFFO0FBRkcsQ0FBZDtBQUtlLFNBQVN5RyxRQUFULEdBQW9CO0FBQy9CLGtCQUFvQzMxQixrQkFBUSxDQUFDLEtBQUQsQ0FBNUM7QUFBQTtBQUFBLE1BQU9vekIsV0FBUDtBQUFBLE1BQW9CQyxZQUFwQjs7QUFDQSxtQkFBb0NyekIsa0JBQVEsQ0FBQyxLQUFELENBQTVDO0FBQUE7QUFBQSxNQUFPNDFCLFdBQVA7QUFBQSxNQUFvQkMsWUFBcEI7O0FBQ0EsbUJBQThDNzFCLGtCQUFRLENBQUMsS0FBRCxDQUF0RDtBQUFBO0FBQUEsTUFBTzgxQixnQkFBUDtBQUFBLE1BQXlCQyxpQkFBekI7O0FBQ0EsbUJBQTBDLzFCLGtCQUFRLENBQUMsS0FBRCxDQUFsRDtBQUFBO0FBQUEsTUFBT2cyQixjQUFQO0FBQUEsTUFBdUJDLGVBQXZCOztBQUNBLG1CQUE0Q2oyQixrQkFBUSxDQUFDaUsseUJBQUQsQ0FBcEQ7QUFBQTtBQUFBLE1BQU9pc0IsY0FBUDtBQUFBLE1BQXVCQyxpQkFBdkI7O0FBQ0Esb0JBQXdDbjJCLGtCQUFRLENBQUNpSyx5QkFBRCxDQUFoRDtBQUFBO0FBQUEsTUFBTzdDLFlBQVA7QUFBQSxNQUFxQmd2QixlQUFyQjs7QUFDQSxvQkFBOENwMkIsa0JBQVEsQ0FBQ2lLLHlCQUFELENBQXREO0FBQUE7QUFBQSxNQUFPdk8sZUFBUDtBQUFBLE1BQXdCMjZCLGtCQUF4Qjs7QUFDQSxvQkFBb0NyMkIsa0JBQVEsQ0FBQyxLQUFELENBQTVDO0FBQUE7QUFBQSxNQUFPaTBCLFdBQVA7QUFBQSxNQUFvQkMsWUFBcEI7O0FBQ0Esb0JBQXNDbDBCLGtCQUFRLENBQUMsS0FBRCxDQUE5QztBQUFBO0FBQUEsTUFBT3MyQixZQUFQO0FBQUEsTUFBcUJDLGFBQXJCOztBQUVBLE1BQU1DLDBCQUEwQixHQUFHdHRDLHFCQUFXLENBQUMsVUFBQzBILEtBQUQsRUFBUWxKLEtBQVIsRUFBa0I7QUFDN0R5dUMsSUFBQUEsaUJBQWlCLENBQUN6dUMsS0FBRCxDQUFqQjtBQUNILEdBRjZDLEVBRTNDLEVBRjJDLENBQTlDO0FBSUEsTUFBTSt1Qyx3QkFBd0IsR0FBR3Z0QyxxQkFBVyxDQUFDLFVBQUMwSCxLQUFELEVBQVFsSixLQUFSLEVBQWtCO0FBQzNEMHVDLElBQUFBLGVBQWUsQ0FBQzF1QyxLQUFELENBQWY7QUFDSCxHQUYyQyxFQUV6QyxFQUZ5QyxDQUE1QztBQUlBLE1BQU1ndkMsMkJBQTJCLEdBQUd4dEMscUJBQVcsQ0FBQyxVQUFDMEgsS0FBRCxFQUFRbEosS0FBUixFQUFrQjtBQUM5RDJ1QyxJQUFBQSxrQkFBa0IsQ0FBQzN1QyxLQUFELENBQWxCO0FBQ0gsR0FGOEMsRUFFNUMsRUFGNEMsQ0FBL0M7QUFJQSxzQkFDSSxxQkFBQyxJQUFEO0FBQU0sTUFBRSxFQUFFK3RCLE9BQVY7QUFBYyxTQUFLLEVBQUU1bkIsVUFBckI7QUFBNEIsZUFBVyxFQUFFMGdDLGdCQUF6QztBQUFzRCxTQUFLLEVBQUVVLFVBQTdEO0FBQUEsNEJBQ0ksb0JBQUMsSUFBRDtBQUFNLFdBQUssRUFBQyxZQUFaO0FBQUEsNkJBQ0kscUJBQUMsU0FBRDtBQUNJLGNBQU0sZUFDRixvQkFBQyxhQUFEO0FBQ0ksZUFBSyxFQUFDLE1BRFY7QUFFSSxrQkFBUSxNQUZaO0FBR0ksaUJBQU8sRUFBRTtBQUFBLG1CQUFNb0UsWUFBWSxDQUFDLElBQUQsQ0FBbEI7QUFBQTtBQUhiLFVBRlI7QUFRSSxZQUFJLEVBQUVELFdBUlY7QUFTSSxlQUFPLEVBQUUsbUJBQU07QUFDWEMsVUFBQUEsWUFBWSxDQUFDLEtBQUQsQ0FBWjtBQUNILFNBWEw7QUFBQSxnQ0FhSSxvQkFBQyxjQUFEO0FBQ0ksY0FBSSxFQUFDO0FBRFQsVUFiSixlQWlCSSxvQkFBQyxjQUFEO0FBQ0ksY0FBSSxFQUFDO0FBRFQsVUFqQkosZUFxQkksb0JBQUMsY0FBRDtBQUNJLGNBQUksRUFBQztBQURULFVBckJKO0FBQUE7QUFESixNQURKLGVBNkJJLG9CQUFDLElBQUQ7QUFBTSxXQUFLLEVBQUMsWUFBWjtBQUFBLDZCQUNJLHFCQUFDLFNBQUQ7QUFDSSxjQUFNLGVBQ0Ysb0JBQUMsYUFBRDtBQUNJLGVBQUssRUFBQyxNQURWO0FBRUksa0JBQVEsTUFGWjtBQUdJLGlCQUFPLEVBQUU7QUFBQSxtQkFBTXdDLFlBQVksQ0FBQyxJQUFELENBQWxCO0FBQUE7QUFIYixVQUZSO0FBUUksWUFBSSxFQUFFRCxXQVJWO0FBU0ksYUFBSyxNQVRUO0FBVUksZUFBTyxFQUFFLG1CQUFNO0FBQ1hDLFVBQUFBLFlBQVksQ0FBQyxLQUFELENBQVo7QUFDSCxTQVpMO0FBQUEsZ0NBY0ksb0JBQUMsY0FBRDtBQUNJLGNBQUksRUFBQztBQURULFVBZEosZUFrQkksb0JBQUMsY0FBRDtBQUNJLGNBQUksRUFBQztBQURULFVBbEJKLGVBc0JJLG9CQUFDLGNBQUQ7QUFDSSxjQUFJLEVBQUM7QUFEVCxVQXRCSjtBQUFBO0FBREosTUE3QkosZUEwREksb0JBQUMsSUFBRDtBQUFNLFdBQUssRUFBQyxpQkFBWjtBQUFBLDZCQUNJLHFCQUFDLFNBQUQ7QUFDSSxjQUFNLGVBQ0Ysb0JBQUMsYUFBRDtBQUNJLGVBQUssRUFBQyxNQURWO0FBRUksa0JBQVEsTUFGWjtBQUdJLGlCQUFPLEVBQUU7QUFBQSxtQkFBTUUsaUJBQWlCLENBQUMsVUFBQTFnQyxDQUFDO0FBQUEscUJBQUksQ0FBQ0EsQ0FBTDtBQUFBLGFBQUYsQ0FBdkI7QUFBQTtBQUhiLFVBRlI7QUFRSSxZQUFJLEVBQUV5Z0MsZ0JBUlY7QUFTSSxrQkFBVSxNQVRkO0FBQUEsZ0NBV0ksb0JBQUMsY0FBRDtBQUNJLGNBQUksRUFBQyxLQURUO0FBRUksaUJBQU8sRUFBRTtBQUFBLG1CQUFNQyxpQkFBaUIsQ0FBQyxLQUFELENBQXZCO0FBQUE7QUFGYixVQVhKLGVBZ0JJLG9CQUFDLGNBQUQ7QUFDSSxjQUFJLEVBQUMsS0FEVDtBQUVJLGlCQUFPLEVBQUU7QUFBQSxtQkFBTUEsaUJBQWlCLENBQUMsS0FBRCxDQUF2QjtBQUFBO0FBRmIsVUFoQkosZUFxQkksb0JBQUMsY0FBRDtBQUNJLGNBQUksRUFBQyxLQURUO0FBRUksaUJBQU8sRUFBRTtBQUFBLG1CQUFNQSxpQkFBaUIsQ0FBQyxLQUFELENBQXZCO0FBQUE7QUFGYixVQXJCSjtBQUFBO0FBREosTUExREosZUF1Rkksb0JBQUMsSUFBRDtBQUFNLFFBQUUsRUFBQyxhQUFUO0FBQXVCLGVBQVMsb0JBQWFHLGNBQWMsQ0FBQ3BKLE9BQWYsQ0FBdUIsR0FBdkIsRUFBNEIsR0FBNUIsQ0FBYixDQUFoQztBQUFpRixXQUFLLEVBQUMsYUFBdkY7QUFDSSxjQUFRLGVBQUU7QUFBQSxnQ0FDTixxQkFBQyxRQUFEO0FBQVUsZ0JBQU0sRUFBQyxpQkFBakI7QUFBQSxrQ0FDSSxvQkFBQyxvQkFBRDtBQUFXLGlCQUFLLEVBQUMsVUFBakI7QUFBQSxtQ0FDSSxvQkFBQyxXQUFEO0FBQ0ksbUJBQUssRUFBRTdpQix5QkFEWDtBQUVJLHFCQUFPLEVBQUVpc0IsY0FBYyxLQUFLanNCLHlCQUZoQztBQUdJLHNCQUFRLEVBQUV1c0I7QUFIZDtBQURKLFlBREosZUFTSSxvQkFBQyxvQkFBRDtBQUFXLGlCQUFLLEVBQUMsV0FBakI7QUFBQSxtQ0FDSSxvQkFBQyxXQUFEO0FBQ0ksbUJBQUssRUFBRXZzQiwwQkFEWDtBQUVJLHFCQUFPLEVBQUVpc0IsY0FBYyxLQUFLanNCLDBCQUZoQztBQUdJLHNCQUFRLEVBQUV1c0I7QUFIZDtBQURKLFlBVEosZUFpQkksb0JBQUMsb0JBQUQ7QUFBVyxpQkFBSyxFQUFDLGFBQWpCO0FBQUEsbUNBQ0ksb0JBQUMsV0FBRDtBQUNJLG1CQUFLLEVBQUV2c0IsNEJBRFg7QUFFSSxxQkFBTyxFQUFFaXNCLGNBQWMsS0FBS2pzQiw0QkFGaEM7QUFHSSxzQkFBUSxFQUFFdXNCO0FBSGQ7QUFESixZQWpCSixlQXlCSSxvQkFBQyxvQkFBRDtBQUFXLGlCQUFLLEVBQUMsY0FBakI7QUFBQSxtQ0FDSSxvQkFBQyxXQUFEO0FBQ0ksbUJBQUssRUFBRXZzQiw2QkFEWDtBQUVJLHFCQUFPLEVBQUVpc0IsY0FBYyxLQUFLanNCLDZCQUZoQztBQUdJLHNCQUFRLEVBQUV1c0I7QUFIZDtBQURKLFlBekJKO0FBQUEsVUFETSxlQW1DTixxQkFBQyxRQUFEO0FBQVUsZ0JBQU0sRUFBQyxlQUFqQjtBQUFBLGtDQUNJLG9CQUFDLG9CQUFEO0FBQVcsaUJBQUssRUFBQyxVQUFqQjtBQUFBLG1DQUNJLG9CQUFDLFdBQUQ7QUFDSSxtQkFBSyxFQUFFdnNCLHlCQURYO0FBRUkscUJBQU8sRUFBRTdDLFlBQVksS0FBSzZDLHlCQUY5QjtBQUdJLHNCQUFRLEVBQUV3c0I7QUFIZDtBQURKLFlBREosZUFTSSxvQkFBQyxvQkFBRDtBQUFXLGlCQUFLLEVBQUMsV0FBakI7QUFBQSxtQ0FDSSxvQkFBQyxXQUFEO0FBQ0ksbUJBQUssRUFBRXhzQiwwQkFEWDtBQUVJLHFCQUFPLEVBQUU3QyxZQUFZLEtBQUs2QywwQkFGOUI7QUFHSSxzQkFBUSxFQUFFd3NCO0FBSGQ7QUFESixZQVRKLGVBaUJJLG9CQUFDLG9CQUFEO0FBQVcsaUJBQUssRUFBQyxhQUFqQjtBQUFBLG1DQUNJLG9CQUFDLFdBQUQ7QUFDSSxtQkFBSyxFQUFFeHNCLDRCQURYO0FBRUkscUJBQU8sRUFBRTdDLFlBQVksS0FBSzZDLDRCQUY5QjtBQUdJLHNCQUFRLEVBQUV3c0I7QUFIZDtBQURKLFlBakJKLGVBeUJJLG9CQUFDLG9CQUFEO0FBQVcsaUJBQUssRUFBQyxjQUFqQjtBQUFBLG1DQUNJLG9CQUFDLFdBQUQ7QUFDSSxtQkFBSyxFQUFFeHNCLDZCQURYO0FBRUkscUJBQU8sRUFBRTdDLFlBQVksS0FBSzZDLDZCQUY5QjtBQUdJLHNCQUFRLEVBQUV3c0I7QUFIZDtBQURKLFlBekJKO0FBQUEsVUFuQ00sZUFxRU4scUJBQUMsUUFBRDtBQUFVLGdCQUFNLEVBQUMsa0JBQWpCO0FBQUEsa0NBQ0ksb0JBQUMsb0JBQUQ7QUFBVyxpQkFBSyxFQUFDLFVBQWpCO0FBQUEsbUNBQ0ksb0JBQUMsV0FBRDtBQUNJLG1CQUFLLEVBQUV4c0IseUJBRFg7QUFFSSxxQkFBTyxFQUFFdk8sZUFBZSxLQUFLdU8seUJBRmpDO0FBR0ksc0JBQVEsRUFBRXlzQjtBQUhkO0FBREosWUFESixlQVNJLG9CQUFDLG9CQUFEO0FBQVcsaUJBQUssRUFBQyxXQUFqQjtBQUFBLG1DQUNJLG9CQUFDLFdBQUQ7QUFDSSxtQkFBSyxFQUFFenNCLDBCQURYO0FBRUkscUJBQU8sRUFBRXZPLGVBQWUsS0FBS3VPLDBCQUZqQztBQUdJLHNCQUFRLEVBQUV5c0I7QUFIZDtBQURKLFlBVEosZUFpQkksb0JBQUMsb0JBQUQ7QUFBVyxpQkFBSyxFQUFDLGFBQWpCO0FBQUEsbUNBQ0ksb0JBQUMsV0FBRDtBQUNJLG1CQUFLLEVBQUV6c0IsNEJBRFg7QUFFSSxxQkFBTyxFQUFFdk8sZUFBZSxLQUFLdU8sNEJBRmpDO0FBR0ksc0JBQVEsRUFBRXlzQjtBQUhkO0FBREosWUFqQkosZUF5Qkksb0JBQUMsb0JBQUQ7QUFBVyxpQkFBSyxFQUFDLGNBQWpCO0FBQUEsbUNBQ0ksb0JBQUMsV0FBRDtBQUNJLG1CQUFLLEVBQUV6c0IsNkJBRFg7QUFFSSxxQkFBTyxFQUFFdk8sZUFBZSxLQUFLdU8sNkJBRmpDO0FBR0ksc0JBQVEsRUFBRXlzQjtBQUhkO0FBREosWUF6Qko7QUFBQSxVQXJFTTtBQUFBLFFBRGQ7QUFBQSw2QkF5R0kscUJBQUMsU0FBRDtBQUNJLGNBQU0sZUFDRixvQkFBQyxhQUFEO0FBQ0ksZUFBSyxFQUFFWixnQkFBZ0IsR0FBRyxPQUFILEdBQWEsTUFEeEM7QUFFSSxrQkFBUSxNQUZaO0FBR0ksaUJBQU8sRUFBRTtBQUFBLG1CQUFNRyxlQUFlLENBQUMsVUFBQTVnQyxDQUFDO0FBQUEscUJBQUksQ0FBQ0EsQ0FBTDtBQUFBLGFBQUYsQ0FBckI7QUFBQTtBQUhiLFVBRlI7QUFRSSxvQkFBWSxFQUFFK1IsWUFSbEI7QUFTSSx1QkFBZSxFQUFFMUwsZUFUckI7QUFVSSxZQUFJLEVBQUVzNkIsY0FWVjtBQVdJLGVBQU8sRUFBRSxtQkFBTTtBQUNYQyxVQUFBQSxlQUFlLENBQUMsS0FBRCxDQUFmO0FBQ0gsU0FiTDtBQUFBLGdDQWVJLG9CQUFDLGNBQUQ7QUFDSSxjQUFJLEVBQUM7QUFEVCxVQWZKLGVBbUJJLG9CQUFDLGNBQUQ7QUFDSSxjQUFJLEVBQUM7QUFEVCxVQW5CSixlQXVCSSxvQkFBQyxjQUFEO0FBQ0ksY0FBSSxFQUFDO0FBRFQsVUF2Qko7QUFBQTtBQXpHSixNQXZGSixlQTZOSSxvQkFBQyxJQUFEO0FBQ0ksV0FBSyxFQUFDLFlBRFY7QUFFSSxXQUFLLGVBQUUsb0JBQUMsYUFBRDtBQUFRLGVBQU8sRUFBRTtBQUFBLGlCQUFNTSxhQUFhLENBQUMsVUFBQWxoQyxDQUFDO0FBQUEsbUJBQUksQ0FBQ0EsQ0FBTDtBQUFBLFdBQUYsQ0FBbkI7QUFBQSxTQUFqQjtBQUFBO0FBQUEsUUFGWDtBQUFBLDZCQUlJLG9CQUFDLGFBQUQ7QUFDSSxhQUFLLEVBQUMsUUFEVjtBQUVJLFlBQUksRUFBRWloQyxZQUZWO0FBQUEsK0JBSUkscUJBQUMsU0FBRDtBQUNJLGdCQUFNLGVBQ0Ysb0JBQUMsYUFBRDtBQUNJLGlCQUFLLEVBQUVSLGdCQUFnQixHQUFHLE9BQUgsR0FBYSxNQUR4QztBQUVJLG9CQUFRLE1BRlo7QUFHSSxtQkFBTyxFQUFFO0FBQUEscUJBQU01QixZQUFZLENBQUMsVUFBQTcrQixDQUFDO0FBQUEsdUJBQUksQ0FBQ0EsQ0FBTDtBQUFBLGVBQUYsQ0FBbEI7QUFBQTtBQUhiLFlBRlI7QUFRSSxjQUFJLEVBQUU0K0IsV0FSVjtBQVNJLGVBQUssTUFUVDtBQVVJLGlCQUFPLEVBQUUsbUJBQU07QUFDWEMsWUFBQUEsWUFBWSxDQUFDLEtBQUQsQ0FBWjtBQUNILFdBWkw7QUFBQSxrQ0FjSSxvQkFBQyxjQUFEO0FBQ0ksZ0JBQUksRUFBQztBQURULFlBZEosZUFrQkksb0JBQUMsY0FBRDtBQUNJLGdCQUFJLEVBQUM7QUFEVCxZQWxCSixlQXNCSSxvQkFBQyxjQUFEO0FBQ0ksZ0JBQUksRUFBQztBQURULFlBdEJKO0FBQUE7QUFKSjtBQUpKLE1BN05KO0FBQUEsSUFESjtBQW9RSCxDOzs7Ozs7Ozs7Ozs7OztBQ2xURDtBQUNBO0FBS0E7QUFDQTtBQUNBOzs7QUFFQSxJQUFNemUsUUFBRSxHQUFHLE9BQVg7QUFDQSxJQUFNNW5CLFdBQUssR0FBRyxPQUFkO0FBQ0EsSUFBTTBnQyxpQkFBVyxHQUFHLDREQUFwQjtBQUNBLElBQU1VLFdBQUssR0FBRztBQUNWRSxFQUFBQSxJQUFJLEVBQUUsK0ZBREk7QUFFVkQsRUFBQUEsS0FBSyxFQUFFO0FBRkcsQ0FBZDtBQUtlLFNBQVN5SCxTQUFULEdBQXFCO0FBQ2hDLGtCQUE0QjMyQixrQkFBUSxDQUFDLEtBQUQsQ0FBcEM7QUFBQTtBQUFBLE1BQU80MkIsTUFBUDtBQUFBLE1BQWVDLFNBQWY7O0FBQ0EsbUJBQTRCNzJCLGtCQUFRLENBQUMsS0FBRCxDQUFwQztBQUFBO0FBQUEsTUFBTzgyQixNQUFQO0FBQUEsTUFBZUMsU0FBZjs7QUFFQSxNQUFNQyxhQUFhLEdBQUc5dEMscUJBQVcsQ0FBQyxVQUFDMEgsS0FBRCxFQUFRbEosS0FBUixFQUFrQjtBQUNoRG12QyxJQUFBQSxTQUFTLENBQUNudkMsS0FBRCxDQUFUO0FBQ0gsR0FGZ0MsRUFFOUIsRUFGOEIsQ0FBakM7QUFJQSxNQUFNdXZDLGFBQWEsR0FBRy90QyxxQkFBVyxDQUFDLFVBQUMwSCxLQUFELEVBQVFsSixLQUFSLEVBQWtCO0FBQ2hEcXZDLElBQUFBLFNBQVMsQ0FBQ3J2QyxLQUFELENBQVQ7QUFDSCxHQUZnQyxFQUU5QixFQUY4QixDQUFqQztBQUlBLHNCQUNJLHFCQUFDLElBQUQ7QUFBTSxNQUFFLEVBQUUrdEIsUUFBVjtBQUFjLFNBQUssRUFBRTVuQixXQUFyQjtBQUE0QixlQUFXLEVBQUUwZ0MsaUJBQXpDO0FBQXNELFNBQUssRUFBRVUsV0FBN0Q7QUFBQSw0QkFDSSxvQkFBQyxPQUFEO0FBQVMsV0FBSyxFQUFDLGFBQWY7QUFBQSw2QkFDSSxxQkFBQyxJQUFEO0FBQUEsZ0NBQ0ksb0JBQUMsb0JBQUQ7QUFBVyxlQUFLLEVBQUMsS0FBakI7QUFBQSxpQ0FDSSxvQkFBQyxXQUFEO0FBQ0ksZ0JBQUksRUFBQyxTQURUO0FBRUksaUJBQUssRUFBQyxLQUZWO0FBR0ksbUJBQU8sRUFBRTJILE1BQU0sS0FBSyxLQUh4QjtBQUlJLG9CQUFRLEVBQUVJO0FBSmQ7QUFESixVQURKLGVBVUksb0JBQUMsb0JBQUQ7QUFBVyxlQUFLLEVBQUMsSUFBakI7QUFBQSxpQ0FDSSxvQkFBQyxXQUFEO0FBQ0ksZ0JBQUksRUFBQyxTQURUO0FBRUksaUJBQUssRUFBQyxJQUZWO0FBR0ksbUJBQU8sRUFBRUosTUFBTSxLQUFLLElBSHhCO0FBSUksb0JBQVEsRUFBRUk7QUFKZDtBQURKLFVBVkosZUFtQkksb0JBQUMsb0JBQUQ7QUFBVyxlQUFLLEVBQUMsT0FBakI7QUFBQSxpQ0FDSSxvQkFBQyxXQUFEO0FBQ0ksZ0JBQUksRUFBQyxTQURUO0FBRUksaUJBQUssRUFBQyxPQUZWO0FBR0ksbUJBQU8sRUFBRUosTUFBTSxLQUFLLE9BSHhCO0FBSUksb0JBQVEsRUFBRUk7QUFKZDtBQURKLFVBbkJKO0FBQUE7QUFESixNQURKLGVBZ0NJLG9CQUFDLE9BQUQ7QUFBUyxXQUFLLEVBQUMsZ0JBQWY7QUFBQSw2QkFDSSxxQkFBQyxJQUFEO0FBQUEsZ0NBQ0ksb0JBQUMsb0JBQUQ7QUFBVyxlQUFLLEVBQUMsS0FBakI7QUFBQSxpQ0FDSSxvQkFBQyxXQUFEO0FBQ0ksZ0JBQUksRUFBQyxTQURUO0FBRUksaUJBQUssRUFBQyxLQUZWO0FBR0ksbUJBQU8sRUFBRUYsTUFBTSxLQUFLLEtBSHhCO0FBSUksb0JBQVEsRUFBRUc7QUFKZDtBQURKLFVBREosZUFVSSxvQkFBQyxvQkFBRDtBQUFXLGVBQUssRUFBQyxJQUFqQjtBQUFBLGlDQUNJLG9CQUFDLFdBQUQ7QUFDSSxnQkFBSSxFQUFDLFNBRFQ7QUFFSSxpQkFBSyxFQUFDLElBRlY7QUFHSSxtQkFBTyxFQUFFSCxNQUFNLEtBQUssSUFIeEI7QUFJSSxvQkFBUSxFQUFFRztBQUpkO0FBREosVUFWSixlQW1CSSxvQkFBQyxvQkFBRDtBQUFXLGVBQUssRUFBQyxPQUFqQjtBQUFBLGlDQUNJLG9CQUFDLFdBQUQ7QUFDSSxnQkFBSSxFQUFDLFNBRFQ7QUFFSSxpQkFBSyxFQUFDLE9BRlY7QUFHSSxtQkFBTyxFQUFFSCxNQUFNLEtBQUssT0FIeEI7QUFJSSxvQkFBUSxNQUpaO0FBS0ksb0JBQVEsRUFBRUc7QUFMZDtBQURKLFVBbkJKO0FBQUE7QUFESixNQWhDSjtBQUFBLElBREo7QUFrRUgsQzs7QUNoR0Q7QUFLQTtBQUNBOztBQUVlLFNBQVNOLGdCQUFULEdBQXFCO0FBQ2hDLHNCQUNJLG9CQUFDLElBQUQ7QUFBTSxTQUFLLEVBQUMsUUFBWjtBQUFBLDJCQUNJLG9CQUFDLE9BQUQ7QUFBUyxXQUFLLEVBQUMsY0FBZjtBQUFBLDZCQUNJLG9CQUFDLG1CQUFEO0FBQVcsU0FBQyxFQUFDLEdBQWI7QUFBQSwrQkFDSSxvQkFBQyxvQkFBRDtBQUFlLGVBQUssRUFBRTtBQUFFdnNDLFlBQUFBLE1BQU0sRUFBRTtBQUFWO0FBQXRCO0FBREo7QUFESjtBQURKLElBREo7QUFTSCxDOzs7Ozs7Ozs7Ozs7OztBQ2xCRDtBQUNBO0FBSUE7QUFDQTtBQUNBOzs7QUFFQSxJQUFNcXJCLGtCQUFFLEdBQUcsa0JBQVg7QUFDQSxJQUFNNW5CLHFCQUFLLEdBQUcsa0JBQWQ7QUFDQSxJQUFNMGdDLDJCQUFXLEdBQUcsaUZBQXBCO0FBQ0EsSUFBTVUscUJBQUssR0FBRztBQUNWRSxFQUFBQSxJQUFJLEVBQUUsMEdBREk7QUFFVkQsRUFBQUEsS0FBSyxFQUFFO0FBRkcsQ0FBZDtBQUtlLFNBQVNnSSxtQkFBVCxHQUErQjtBQUMxQyxrQkFBNEJsM0Isa0JBQVEsQ0FBQyxNQUFELENBQXBDO0FBQUE7QUFBQSxNQUFPNDJCLE1BQVA7QUFBQSxNQUFlQyxTQUFmOztBQUNBLG1CQUE0QjcyQixrQkFBUSxDQUFDLE1BQUQsQ0FBcEM7QUFBQTtBQUFBLE1BQU84MkIsTUFBUDtBQUFBLE1BQWVDLFNBQWY7O0FBQ0EsbUJBQTRCLzJCLGtCQUFRLENBQUMsTUFBRCxDQUFwQztBQUFBO0FBQUEsTUFBT20zQixNQUFQO0FBQUEsTUFBZUMsU0FBZjs7QUFFQSxzQkFDSSxxQkFBQyxJQUFEO0FBQU0sTUFBRSxFQUFFM2hCLGtCQUFWO0FBQWMsU0FBSyxFQUFFNW5CLHFCQUFyQjtBQUE0QixlQUFXLEVBQUUwZ0MsMkJBQXpDO0FBQXNELFNBQUssRUFBRVUscUJBQTdEO0FBQUEsNEJBQ0ksb0JBQUMsT0FBRDtBQUFTLFdBQUssRUFBQyxNQUFmO0FBQUEsNkJBQ0ksb0JBQUMsSUFBRDtBQUFBLCtCQUNJLHFCQUFDLGdDQUFEO0FBQWlCLGVBQUssRUFBRTJILE1BQXhCO0FBQWdDLGtCQUFRLEVBQUVDLFNBQTFDO0FBQUEsa0NBQ0ksb0JBQUMsd0NBQUQ7QUFDSSxpQkFBSyxFQUFDLE1BRFY7QUFFSSxpQkFBSyxFQUFDO0FBRlYsWUFESixlQU1JLG9CQUFDLHdDQUFEO0FBQ0ksaUJBQUssRUFBQyxVQURWO0FBRUksaUJBQUssRUFBQztBQUZWLFlBTko7QUFBQTtBQURKO0FBREosTUFESixlQWlCSSxvQkFBQyxPQUFEO0FBQVMsV0FBSyxFQUFDLE9BQWY7QUFBQSw2QkFDSSxvQkFBQyxJQUFEO0FBQUEsK0JBQ0kscUJBQUMsZ0NBQUQ7QUFBaUIsZUFBSyxFQUFFQyxNQUF4QjtBQUFnQyxrQkFBUSxFQUFFQyxTQUExQztBQUFBLGtDQUNJLG9CQUFDLHdDQUFEO0FBQ0ksaUJBQUssRUFBQyxNQURWO0FBRUksZ0JBQUksRUFBQztBQUZULFlBREosZUFNSSxvQkFBQyx3Q0FBRDtBQUNJLGlCQUFLLEVBQUMsVUFEVjtBQUVJLGdCQUFJLEVBQUM7QUFGVCxZQU5KO0FBQUE7QUFESjtBQURKLE1BakJKLGVBaUNJLG9CQUFDLE9BQUQ7QUFBUyxXQUFLLEVBQUMsaUJBQWY7QUFBQSw2QkFDSSxvQkFBQyxJQUFEO0FBQUEsK0JBQ0kscUJBQUMsZ0NBQUQ7QUFBaUIsZUFBSyxFQUFFSSxNQUF4QjtBQUFnQyxrQkFBUSxFQUFFQyxTQUExQztBQUFBLGtDQUNJLG9CQUFDLHdDQUFEO0FBQ0ksaUJBQUssRUFBQyxNQURWO0FBRUksZ0JBQUksRUFBQyxNQUZUO0FBR0ksaUJBQUssRUFBQztBQUhWLFlBREosZUFPSSxvQkFBQyx3Q0FBRDtBQUNJLGlCQUFLLEVBQUMsVUFEVjtBQUVJLGdCQUFJLEVBQUMsVUFGVDtBQUdJLGlCQUFLLEVBQUM7QUFIVixZQVBKO0FBQUE7QUFESjtBQURKLE1BakNKO0FBQUEsSUFESjtBQXFESCxDOzs7Ozs7Ozs7Ozs7OztBQzNFRDtBQUNBO0FBSUE7QUFDQTs7O0FBRUEsSUFBTTNoQixTQUFFLEdBQUcsUUFBWDtBQUNBLElBQU01bkIsWUFBSyxHQUFHLFFBQWQ7QUFDQSxJQUFNMGdDLGtCQUFXLEdBQUcsaUZBQXBCO0FBQ0EsSUFBTVUsWUFBSyxHQUFHO0FBQ1ZFLEVBQUFBLElBQUksRUFBRTtBQURJLENBQWQ7QUFJZSxTQUFTa0ksVUFBVCxHQUFzQjtBQUNqQyxrQkFBNEJyM0Isa0JBQVEsRUFBcEM7QUFBQTtBQUFBLE1BQU84TSxNQUFQO0FBQUEsTUFBZXdxQixTQUFmOztBQUNBLG1CQUFnQ3QzQixrQkFBUSxFQUF4QztBQUFBO0FBQUEsTUFBT25VLFFBQVA7QUFBQSxNQUFpQjByQyxXQUFqQjs7QUFDQSxtQkFBc0N2M0Isa0JBQVEsQ0FBQyxLQUFELENBQTlDO0FBQUE7QUFBQSxNQUFPdzNCLFdBQVA7QUFBQSxNQUFvQkMsY0FBcEI7O0FBQ0EsbUJBQWdDejNCLGtCQUFRLENBQUMsRUFBRCxDQUF4QztBQUFBO0FBQUEsTUFBTytNLFFBQVA7QUFBQSxNQUFpQjJxQixXQUFqQjs7QUFDQSxtQkFBd0IxM0Isa0JBQVEsRUFBaEM7QUFBQTtBQUFBLE1BQU8vWSxJQUFQO0FBQUEsTUFBYWdwQyxPQUFiOztBQUVBLHNCQUNJLHFCQUFDLElBQUQ7QUFBTSxNQUFFLEVBQUV4YSxTQUFWO0FBQWMsU0FBSyxFQUFFNW5CLFlBQXJCO0FBQTRCLGVBQVcsRUFBRTBnQyxrQkFBekM7QUFBc0QsU0FBSyxFQUFFVSxZQUE3RDtBQUFBLDRCQUNJLG9CQUFDLElBQUQ7QUFBTSxXQUFLLEVBQUMsZUFBWjtBQUFBLDZCQUNJLHFCQUFDLGFBQUQ7QUFDSSxhQUFLLEVBQUMsUUFEVjtBQUVJLGFBQUssRUFBRW5pQixNQUZYO0FBR0ksY0FBTSxNQUhWO0FBSUksZ0JBQVEsRUFBRSxrQkFBQ2xjLEtBQUQsRUFBUWxKLEtBQVI7QUFBQSxpQkFBa0I0dkMsU0FBUyxDQUFDNXZDLEtBQUQsQ0FBM0I7QUFBQSxTQUpkO0FBQUEsZ0NBTUksb0JBQUMsb0JBQUQ7QUFBZSxlQUFLLEVBQUMsS0FBckI7QUFBMkIsY0FBSSxFQUFDO0FBQWhDLFVBTkosZUFPSSxvQkFBQyxvQkFBRDtBQUFlLGVBQUssRUFBQyxLQUFyQjtBQUEyQixjQUFJLEVBQUM7QUFBaEMsVUFQSixlQVFJLG9CQUFDLG9CQUFEO0FBQWUsZUFBSyxFQUFDLEtBQXJCO0FBQTJCLGNBQUksRUFBQztBQUFoQyxVQVJKO0FBQUE7QUFESixNQURKLGVBY0ksb0JBQUMsSUFBRDtBQUFNLFdBQUssRUFBQyxpQkFBWjtBQUFBLDZCQUNJLHFCQUFDLGFBQUQ7QUFDSSxhQUFLLEVBQUMsUUFEVjtBQUVJLGFBQUssRUFBRW1FLFFBRlg7QUFHSSxnQkFBUSxNQUhaO0FBSUksZ0JBQVEsRUFBRSxrQkFBQytFLEtBQUQsRUFBUWxKLEtBQVI7QUFBQSxpQkFBa0I2dkMsV0FBVyxDQUFDN3ZDLEtBQUQsQ0FBN0I7QUFBQSxTQUpkO0FBQUEsZ0NBTUksb0JBQUMsb0JBQUQ7QUFBZSxlQUFLLEVBQUMsS0FBckI7QUFBMkIsY0FBSSxFQUFDO0FBQWhDLFVBTkosZUFPSSxvQkFBQyxvQkFBRDtBQUFlLGVBQUssRUFBQyxLQUFyQjtBQUEyQixjQUFJLEVBQUM7QUFBaEMsVUFQSixlQVFJLG9CQUFDLG9CQUFEO0FBQWUsZUFBSyxFQUFDLEtBQXJCO0FBQTJCLGNBQUksRUFBQztBQUFoQyxVQVJKO0FBQUE7QUFESixNQWRKLGVBMkJJLG9CQUFDLElBQUQ7QUFBTSxXQUFLLEVBQUMsb0JBQVo7QUFBQSw2QkFDSSxxQkFBQyxhQUFEO0FBQ0ksYUFBSyxFQUFDLFFBRFY7QUFFSSxhQUFLLEVBQUU4dkMsV0FGWDtBQUdJLGNBQU0sTUFIVjtBQUlJLGdCQUFRLEVBQUUsa0JBQUM1bUMsS0FBRCxFQUFRbEosS0FBUjtBQUFBLGlCQUFrQit2QyxjQUFjLENBQUMvdkMsS0FBRCxDQUFoQztBQUFBLFNBSmQ7QUFBQSxnQ0FNSSxvQkFBQyxvQkFBRDtBQUFlLGVBQUssRUFBQyxLQUFyQjtBQUEyQixjQUFJLEVBQUM7QUFBaEMsVUFOSixlQU9JLG9CQUFDLG9CQUFEO0FBQWUsZUFBSyxFQUFDLEtBQXJCO0FBQTJCLGNBQUksRUFBQztBQUFoQyxVQVBKLGVBUUksb0JBQUMsb0JBQUQ7QUFBZSxlQUFLLEVBQUMsS0FBckI7QUFBMkIsY0FBSSxFQUFDO0FBQWhDLFVBUko7QUFBQTtBQURKLE1BM0JKLGVBd0NJLG9CQUFDLElBQUQ7QUFBTSxXQUFLLEVBQUMsaUJBQVo7QUFBQSw2QkFDSSxxQkFBQyxhQUFEO0FBQ0ksYUFBSyxFQUFDLFFBRFY7QUFFSSxhQUFLLEVBQUVxbEIsUUFGWDtBQUdJLGNBQU0sTUFIVjtBQUlJLGdCQUFRLEVBQUUsa0JBQUNuYyxLQUFELEVBQVFsSixLQUFSO0FBQUEsaUJBQWtCZ3dDLFdBQVcsQ0FBQ2h3QyxLQUFELENBQTdCO0FBQUEsU0FKZDtBQUFBLGdDQU1JLG9CQUFDLG9CQUFEO0FBQWUsZUFBSyxFQUFDLEtBQXJCO0FBQTJCLGNBQUksRUFBQztBQUFoQyxVQU5KLGVBT0ksb0JBQUMsb0JBQUQ7QUFBZSxlQUFLLEVBQUMsS0FBckI7QUFBMkIsY0FBSSxFQUFDO0FBQWhDLFVBUEosZUFRSSxvQkFBQyxvQkFBRDtBQUFlLGVBQUssRUFBQyxLQUFyQjtBQUEyQixjQUFJLEVBQUM7QUFBaEMsVUFSSjtBQUFBO0FBREosTUF4Q0osZUFxREksb0JBQUMsSUFBRDtBQUFNLFdBQUssRUFBQyxxQkFBWjtBQUFBLDZCQUNJLHFCQUFDLGFBQUQ7QUFDSSxhQUFLLEVBQUMsUUFEVjtBQUVJLGFBQUssRUFBRVQsSUFGWDtBQUdJLFlBQUksRUFBQyxNQUhUO0FBSUksY0FBTSxNQUpWO0FBS0ksZ0JBQVEsRUFBRSxrQkFBQzJKLEtBQUQsRUFBUWxKLEtBQVI7QUFBQSxpQkFBa0J1b0MsT0FBTyxDQUFDdm9DLEtBQUQsQ0FBekI7QUFBQSxTQUxkO0FBQUEsZ0NBT0ksb0JBQUMsb0JBQUQ7QUFBZSxlQUFLLEVBQUMsS0FBckI7QUFBMkIsY0FBSSxFQUFDO0FBQWhDLFVBUEosZUFRSSxvQkFBQyxvQkFBRDtBQUFlLGVBQUssRUFBQyxLQUFyQjtBQUEyQixjQUFJLEVBQUM7QUFBaEMsVUFSSixlQVNJLG9CQUFDLG9CQUFEO0FBQWUsZUFBSyxFQUFDLEtBQXJCO0FBQTJCLGNBQUksRUFBQztBQUFoQyxVQVRKO0FBQUE7QUFESixNQXJESjtBQUFBLElBREo7QUFxRUgsQzs7Ozs7Ozs7Ozs7Ozs7QUMzRkQ7QUFDQTtBQUtBO0FBQ0E7QUFDQTs7O0FBRUEsSUFBTSt0QixZQUFFLEdBQUcsWUFBWDtBQUNBLElBQU01bkIsZUFBSyxHQUFHLFlBQWQ7QUFDQSxJQUFNMGdDLHFCQUFXLEdBQUcsc0hBQXBCO0FBQ0EsSUFBTVUsZUFBSyxHQUFHO0FBQ1ZDLEVBQUFBLEtBQUssRUFBRTtBQURHLENBQWQ7QUFJZSxTQUFTeUksYUFBVCxHQUF5QjtBQUNwQyxrQkFBZ0QzM0Isa0JBQVEsQ0FBQyxLQUFELENBQXhEO0FBQUE7QUFBQSxNQUFPK3pCLGlCQUFQO0FBQUEsTUFBMEJDLGtCQUExQjs7QUFDQSxtQkFBb0NoMEIsa0JBQVEsQ0FBQyxLQUFELENBQTVDO0FBQUE7QUFBQSxNQUFPaTBCLFdBQVA7QUFBQSxNQUFvQkMsWUFBcEI7O0FBRUEsc0JBQ0kscUJBQUMsSUFBRDtBQUFNLE1BQUUsRUFBRXplLFlBQVY7QUFBYyxTQUFLLEVBQUU1bkIsZUFBckI7QUFBNEIsZUFBVyxFQUFFMGdDLHFCQUF6QztBQUFzRCxTQUFLLEVBQUVVLGVBQTdEO0FBQUEsNEJBQ0ksb0JBQUMsT0FBRDtBQUFTLFdBQUssRUFBQyxrQkFBZjtBQUFBLDZCQUNJLG9CQUFDLElBQUQ7QUFBQSwrQkFDSSxvQkFBQyxvQkFBRDtBQUFXLGVBQUssRUFBQyxPQUFqQjtBQUFBO0FBQUE7QUFESjtBQURKLE1BREosZUFTSSxvQkFBQyxPQUFEO0FBQVMsV0FBSyxFQUFDLHdCQUFmO0FBQUEsNkJBQ0ksb0JBQUMsSUFBRDtBQUNJLGFBQUssZUFDRCxvQkFBQyxhQUFEO0FBQ0ksZUFBSyxFQUFDLFFBRFY7QUFFSSxrQkFBUSxNQUZaO0FBR0ksaUJBQU8sRUFBRTtBQUFBLG1CQUFNK0Usa0JBQWtCLENBQUMsVUFBQTMrQixDQUFDO0FBQUEscUJBQUksQ0FBQ0EsQ0FBTDtBQUFBLGFBQUYsQ0FBeEI7QUFBQTtBQUhiLFVBRlI7QUFBQSwrQkFTSSxvQkFBQyxvQkFBRDtBQUNJLGVBQUssRUFBQyxPQURWO0FBRUksbUJBQVMsRUFBQyxPQUZkO0FBR0ksY0FBSSxFQUFFMCtCLGlCQUhWO0FBSUkscUJBQVcsTUFKZjtBQUtJLGlCQUFPLEVBQUU7QUFBQSxtQkFBTUMsa0JBQWtCLENBQUMsS0FBRCxDQUF4QjtBQUFBLFdBTGI7QUFBQTtBQUFBO0FBVEo7QUFESixNQVRKLGVBK0JJLG9CQUFDLE9BQUQ7QUFBUyxXQUFLLEVBQUMsa0JBQWY7QUFBQSw2QkFDSSxvQkFBQyxJQUFEO0FBQ0ksYUFBSyxlQUNELG9CQUFDLGFBQUQ7QUFDSSxlQUFLLEVBQUMsTUFEVjtBQUVJLGtCQUFRLE1BRlo7QUFHSSxpQkFBTyxFQUFFO0FBQUEsbUJBQU1FLFlBQVksQ0FBQyxJQUFELENBQWxCO0FBQUE7QUFIYixVQUZSO0FBQUEsK0JBU0ksb0JBQUMsb0JBQUQ7QUFDSSxlQUFLLEVBQUMsT0FEVjtBQUVJLG1CQUFTLEVBQUMsT0FGZDtBQUdJLGNBQUksRUFBRUQsV0FIVjtBQUlJLGVBQUssTUFKVDtBQUtJLGlCQUFPLEVBQUU7QUFBQSxtQkFBTUMsWUFBWSxDQUFDLEtBQUQsQ0FBbEI7QUFBQSxXQUxiO0FBQUE7QUFBQTtBQVRKO0FBREosTUEvQko7QUFBQSxJQURKO0FBdURILEM7Ozs7Ozs7Ozs7Ozs7O0FDNUVEO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7OztBQUVBLElBQU16ZSxTQUFFLEdBQUcsUUFBWDtBQUNBLElBQU01bkIsWUFBSyxHQUFHLFFBQWQ7QUFDQSxJQUFNMGdDLGtCQUFXLEdBQUcsZ0VBQXBCO0FBQ0EsSUFBTVUsWUFBSyxHQUFHO0FBQ1ZFLEVBQUFBLElBQUksRUFBRSxnR0FESTtBQUVWRCxFQUFBQSxLQUFLLEVBQUU7QUFGRyxDQUFkO0FBS2UsU0FBUzBJLFVBQVQsR0FBc0I7QUFDakMsa0JBQTRCNTNCLGtCQUFRLENBQUMsRUFBRCxDQUFwQztBQUFBO0FBQUEsTUFBTzQyQixNQUFQO0FBQUEsTUFBZUMsU0FBZjs7QUFDQSxtQkFBNEI3MkIsa0JBQVEsQ0FBQyxFQUFELENBQXBDO0FBQUE7QUFBQSxNQUFPODJCLE1BQVA7QUFBQSxNQUFlQyxTQUFmOztBQUNBLG1CQUE0Qi8yQixrQkFBUSxDQUFDLEVBQUQsQ0FBcEM7QUFBQTtBQUFBLE1BQU9tM0IsTUFBUDtBQUFBLE1BQWVDLFNBQWY7O0FBRUEsc0JBQ0kscUJBQUMsSUFBRDtBQUFNLE1BQUUsRUFBRTNoQixTQUFWO0FBQWMsU0FBSyxFQUFFNW5CLFlBQXJCO0FBQTRCLGVBQVcsRUFBRTBnQyxrQkFBekM7QUFBc0QsU0FBSyxFQUFFVSxZQUE3RDtBQUFBLDRCQUNJLG9CQUFDLE9BQUQ7QUFBUyxXQUFLLEVBQUMsbUJBQWY7QUFBQSw2QkFDSSxvQkFBQyxJQUFEO0FBQUEsK0JBQ0ksb0JBQUMsYUFBRDtBQUNJLGVBQUssRUFBRTJILE1BRFg7QUFFSSxrQkFBUSxFQUFFQztBQUZkO0FBREo7QUFESixNQURKLGVBVUksb0JBQUMsT0FBRDtBQUFTLFdBQUssRUFBQyxpQkFBZjtBQUFBLDZCQUNJLG9CQUFDLElBQUQ7QUFBQSwrQkFDSSxvQkFBQyxhQUFEO0FBQ0ksZUFBSyxFQUFFQyxNQURYO0FBRUksY0FBSSxFQUFDLElBRlQ7QUFHSSxrQkFBUSxNQUhaO0FBSUksa0JBQVEsRUFBRUM7QUFKZDtBQURKO0FBREosTUFWSixlQXFCSSxvQkFBQyxPQUFEO0FBQVMsV0FBSyxFQUFDLGlDQUFmO0FBQUEsNkJBQ0ksb0JBQUMsSUFBRDtBQUFBLCtCQUNJLG9CQUFDLGFBQUQ7QUFDSSxlQUFLLEVBQUVJLE1BRFg7QUFFSSxjQUFJLEVBQUMsSUFGVDtBQUdJLGtCQUFRLE1BSFo7QUFJSSxtQkFBUyxNQUpiO0FBS0ksa0JBQVEsRUFBRUM7QUFMZDtBQURKO0FBREosTUFyQkosZUFpQ0ksb0JBQUMsT0FBRDtBQUFTLFdBQUssRUFBQyxpQkFBZjtBQUFBLDZCQUNJLG9CQUFDLElBQUQ7QUFBQSwrQkFDSSxvQkFBQyxhQUFEO0FBQ0ksZUFBSyxFQUFFLEVBRFg7QUFFSSxrQkFBUTtBQUZaO0FBREo7QUFESixNQWpDSjtBQUFBLElBREo7QUE0Q0gsQzs7Ozs7Ozs7Ozs7Ozs7QUNsRUQ7QUFDQTtBQVFBO0FBQ0E7QUFDQTs7O0FBRUEsSUFBTTNoQixXQUFFLEdBQUcsVUFBWDtBQUNBLElBQU01bkIsY0FBSyxHQUFHLFVBQWQ7QUFDQSxJQUFNMGdDLG9CQUFXLEdBQUcsbUZBQXBCO0FBQ0EsSUFBTVUsY0FBSyxHQUFHO0FBQ1ZFLEVBQUFBLElBQUksRUFBRSxrR0FESTtBQUVWRCxFQUFBQSxLQUFLLEVBQUU7QUFGRyxDQUFkO0FBS2UsU0FBUzJJLFlBQVQsR0FBd0I7QUFDbkMsa0JBQTBCNzNCLGtCQUFRLENBQUMsS0FBRCxDQUFsQztBQUFBO0FBQUEsTUFBTzgzQixNQUFQO0FBQUEsTUFBZWpJLE9BQWY7O0FBQ0EsbUJBQThCN3ZCLGtCQUFRLENBQUMsSUFBRCxDQUF0QztBQUFBO0FBQUEsTUFBT2tmLE9BQVA7QUFBQSxNQUFnQkcsVUFBaEI7O0FBQ0EsbUJBQWtDcmYsa0JBQVEsQ0FBQyxLQUFELENBQTFDO0FBQUE7QUFBQSxNQUFPa3dCLFNBQVA7QUFBQSxNQUFrQkMsWUFBbEI7O0FBQ0EsbUJBQWdDbndCLGtCQUFRLENBQUMsS0FBRCxDQUF4QztBQUFBO0FBQUEsTUFBTyszQixTQUFQO0FBQUEsTUFBa0JDLFVBQWxCOztBQUNBLG1CQUFnQ2g0QixrQkFBUSxDQUFDLEtBQUQsQ0FBeEM7QUFBQTtBQUFBLE1BQU9pNEIsU0FBUDtBQUFBLE1BQWtCQyxVQUFsQjs7QUFFQSxzQkFDSSxvQkFBQyxJQUFEO0FBQU0sTUFBRSxFQUFFemlCLFdBQVY7QUFBYyxTQUFLLEVBQUU1bkIsY0FBckI7QUFBNEIsZUFBVyxFQUFFMGdDLG9CQUF6QztBQUFzRCxTQUFLLEVBQUVVLGNBQTdEO0FBQUEsMkJBQ0kscUJBQUMsT0FBRDtBQUFTLFdBQUssRUFBQyxNQUFmO0FBQUEsOEJBQ0kscUJBQUMsYUFBRDtBQUFRLFdBQUcsTUFBWDtBQUFBLGdDQUNJO0FBQUEsa0NBQ0k7QUFBQTtBQUFBLFlBREosZUFHSSxvQkFBQyxnQ0FBRDtBQUFBLG1DQUNJLG9CQUFDLHdDQUFEO0FBQ0ksbUJBQUssRUFBQyxRQURWO0FBRUksc0JBQVEsRUFBRWlCLFNBRmQ7QUFHSSxxQkFBTyxFQUFFO0FBQUEsdUJBQU1DLFlBQVksQ0FBQyxVQUFBOTZCLENBQUM7QUFBQSx5QkFBSSxDQUFDQSxDQUFMO0FBQUEsaUJBQUYsQ0FBbEI7QUFBQTtBQUhiO0FBREosWUFISjtBQUFBLFVBREosZUFhSTtBQUFBLGtDQUNJO0FBQUE7QUFBQSxZQURKLGVBR0kscUJBQUMsZ0NBQUQ7QUFBQSxvQ0FDSSxvQkFBQyx3Q0FBRDtBQUNJLG1CQUFLLEVBQUMsU0FEVjtBQUVJLHNCQUFRLEVBQUUwaUMsU0FGZDtBQUdJLHFCQUFPLEVBQUU7QUFBQSx1QkFBTUMsVUFBVSxDQUFDLFVBQUEzaUMsQ0FBQztBQUFBLHlCQUFJLENBQUNBLENBQUw7QUFBQSxpQkFBRixDQUFoQjtBQUFBO0FBSGIsY0FESixlQU9JLG9CQUFDLHdDQUFEO0FBQ0ksbUJBQUssRUFBQyxTQURWO0FBRUksc0JBQVEsRUFBRTRpQyxTQUZkO0FBR0kscUJBQU8sRUFBRTtBQUFBLHVCQUFNQyxVQUFVLENBQUMsVUFBQTdpQyxDQUFDO0FBQUEseUJBQUksQ0FBQ0EsQ0FBTDtBQUFBLGlCQUFGLENBQWhCO0FBQUE7QUFIYixjQVBKO0FBQUEsWUFISjtBQUFBLFVBYkosZUErQkksb0JBQUMsb0JBQUQ7QUFDSSxlQUFLLEVBQUMsU0FEVjtBQUVJLGVBQUssRUFBRTZwQixPQUZYO0FBR0ksZ0JBQU0sRUFBQyxJQUhYO0FBSUksa0JBQVEsTUFKWjtBQUtJLGtCQUFRLEVBQUUsa0JBQUM5QixDQUFELEVBQUkxMUIsS0FBSjtBQUFBLG1CQUFjMjNCLFVBQVUsQ0FBQzMzQixLQUFELENBQXhCO0FBQUE7QUFMZCxVQS9CSjtBQUFBLFFBREosZUF5Q0ksb0JBQUMsSUFBRDtBQUNJLGFBQUssZUFDRCxvQkFBQyxhQUFEO0FBQ0ksZUFBSyxFQUFDLE1BRFY7QUFFSSxrQkFBUSxNQUZaO0FBR0ksaUJBQU8sRUFBRTtBQUFBLG1CQUFNbW9DLE9BQU8sQ0FBQyxJQUFELENBQWI7QUFBQTtBQUhiLFVBRlI7QUFBQSwrQkFTSSxvQkFBQyxpQkFBRDtBQUNJLGNBQUksRUFBRWlJLE1BRFY7QUFFSSxpQkFBTyxFQUFFNVksT0FGYjtBQUdJLGVBQUssRUFBQyxTQUhWO0FBSUksZ0JBQU0sRUFBRWdSLFNBQVMsZ0JBQ2Isb0JBQUMsYUFBRDtBQUFBO0FBQUEsWUFEYSxHQUdiMWhDLFNBUFI7QUFTSSxpQkFBTyxFQUFFdXBDLFNBQVMsSUFBSXZwQyxTQVQxQjtBQVVJLGlCQUFPLEVBQUV5cEMsU0FBUyxJQUFJenBDLFNBVjFCO0FBV0ksaUJBQU8sRUFBRTtBQUFBLG1CQUFNcWhDLE9BQU8sQ0FBQ3JoQyxTQUFELENBQWI7QUFBQTtBQVhiO0FBVEosUUF6Q0o7QUFBQTtBQURKLElBREo7QUFxRUgsQzs7Ozs7Ozs7Ozs7Ozs7QUNqR0Q7QUFDQTtBQUlBO0FBQ0E7OztBQUVBLElBQU1pbkIsU0FBRSxHQUFHLFFBQVg7QUFDQSxJQUFNNW5CLFlBQUssR0FBRyxRQUFkO0FBQ0EsSUFBTTBnQyxrQkFBVyxHQUFHLHVEQUFwQjtBQUNBLElBQU1VLFlBQUssR0FBRztBQUNWRSxFQUFBQSxJQUFJLEVBQUUsZ0dBREk7QUFFVkQsRUFBQUEsS0FBSyxFQUFFO0FBRkcsQ0FBZDtBQUtlLFNBQVNpSixVQUFULEdBQXNCO0FBQ2pDLGtCQUFrQ240QixrQkFBUSxDQUFDLEtBQUQsQ0FBMUM7QUFBQTtBQUFBLE1BQU9vNEIsVUFBUDtBQUFBLE1BQW1CQyxXQUFuQjs7QUFFQSxzQkFDSSxxQkFBQyxJQUFEO0FBQU0sTUFBRSxFQUFFNWlCLFNBQVY7QUFBYyxTQUFLLEVBQUU1bkIsWUFBckI7QUFBNEIsZUFBVyxFQUFFMGdDLGtCQUF6QztBQUFzRCxTQUFLLEVBQUVVLFlBQTdEO0FBQUEsNEJBQ0ksb0JBQUMsSUFBRDtBQUFNLFdBQUssRUFBQyxjQUFaO0FBQUEsNkJBQ0ksb0JBQUMsYUFBRDtBQUNJLGdCQUFRLEVBQUVtSixVQURkO0FBRUksZ0JBQVEsRUFBRTtBQUFBLGlCQUFNQyxXQUFXLENBQUMsVUFBQWhqQyxDQUFDO0FBQUEsbUJBQUksQ0FBQ0EsQ0FBTDtBQUFBLFdBQUYsQ0FBakI7QUFBQTtBQUZkO0FBREosTUFESixlQVFJLG9CQUFDLElBQUQ7QUFBTSxXQUFLLEVBQUMsaUJBQVo7QUFBQSw2QkFDSSxvQkFBQyxhQUFEO0FBQVEsZ0JBQVE7QUFBaEI7QUFESixNQVJKO0FBQUEsSUFESjtBQWNILEM7Ozs7Ozs7Ozs7Ozs7O0FDakNEO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7OztBQUVBLElBQU1vZ0IsT0FBRSxHQUFHLE1BQVg7QUFDQSxJQUFNNW5CLFVBQUssR0FBRyxNQUFkO0FBQ0EsSUFBTTBnQyxnQkFBVyxHQUFHLG9GQUFwQjtBQUNBLElBQU1VLFVBQUssR0FBRztBQUNWRSxFQUFBQSxJQUFJLEVBQUUsaUdBREk7QUFFVkQsRUFBQUEsS0FBSyxFQUFFO0FBRkcsQ0FBZDtBQUtlLFNBQVNpSixlQUFULEdBQXNCO0FBQ2pDLGtCQUEwQm40QixrQkFBUSxDQUFDLENBQUQsQ0FBbEM7QUFBQTtBQUFBLE1BQU9zNEIsS0FBUDtBQUFBLE1BQWNDLFFBQWQ7O0FBQ0EsbUJBQWdDdjRCLGtCQUFRLENBQUMsQ0FBRCxDQUF4QztBQUFBO0FBQUEsTUFBTytoQixRQUFQO0FBQUEsTUFBaUJ5VyxXQUFqQjs7QUFDQSxtQkFBa0R4NEIsa0JBQVEsQ0FBQyxDQUFELENBQTFEO0FBQUE7QUFBQSxNQUFPZ2lCLGlCQUFQO0FBQUEsTUFBMEJ5VyxvQkFBMUI7O0FBQ0EsbUJBQTBFejRCLGtCQUFRLENBQUMsQ0FBRCxDQUFsRjtBQUFBO0FBQUEsTUFBTzA0Qiw2QkFBUDtBQUFBLE1BQXNDQyxnQ0FBdEM7O0FBQ0EsbUJBQXdCMzRCLGtCQUFRLENBQUMsQ0FBRCxDQUFoQztBQUFBO0FBQUEsTUFBT2toQixJQUFQO0FBQUEsTUFBYTBYLE9BQWI7O0FBQ0Esb0JBQTBCNTRCLGtCQUFRLENBQUMsQ0FBRCxDQUFsQztBQUFBO0FBQUEsTUFBTzY0QixLQUFQO0FBQUEsTUFBY0MsUUFBZDs7QUFDQSxvQkFBd0M5NEIsa0JBQVEsQ0FBQyxDQUFELENBQWhEO0FBQUE7QUFBQSxNQUFPKzRCLFlBQVA7QUFBQSxNQUFxQkMsZUFBckI7O0FBQ0Esb0JBQWtDaDVCLGtCQUFRLENBQUMsQ0FBRCxDQUExQztBQUFBO0FBQUEsTUFBT2k1QixTQUFQO0FBQUEsTUFBa0JDLFlBQWxCOztBQUNBLG9CQUEwQ2w1QixrQkFBUSxDQUFDLENBQUQsQ0FBbEQ7QUFBQTtBQUFBLE1BQU9rakIsYUFBUDtBQUFBLE1BQXNCaVcsZ0JBQXRCOztBQUNBLG9CQUE0Qm41QixrQkFBUSxDQUFDLENBQUQsQ0FBcEM7QUFBQTtBQUFBLE1BQU9vNUIsTUFBUDtBQUFBLE1BQWVDLFNBQWY7O0FBRUEsc0JBQ0kscUJBQUMsSUFBRDtBQUFNLE1BQUUsRUFBRTVqQixPQUFWO0FBQWMsU0FBSyxFQUFFNW5CLFVBQXJCO0FBQTRCLGVBQVcsRUFBRTBnQyxnQkFBekM7QUFBc0QsU0FBSyxFQUFFVSxVQUE3RDtBQUFBLDRCQUNJLG9CQUFDLE9BQUQ7QUFBUyxXQUFLLEVBQUMsWUFBZjtBQUFBLDZCQUNJLG9CQUFDLElBQUQ7QUFBQSwrQkFDSSxxQkFBQyxXQUFEO0FBQ0ksZUFBSyxFQUFFcUosS0FEWDtBQUVJLGtCQUFRLEVBQUUsa0JBQUE1d0MsS0FBSztBQUFBLG1CQUFJNndDLFFBQVEsQ0FBQzd3QyxLQUFELENBQVo7QUFBQSxXQUZuQjtBQUFBLGtDQUlJLG9CQUFDLFFBQUQ7QUFBSyxpQkFBSyxFQUFDO0FBQVgsWUFKSixlQUtJLG9CQUFDLFFBQUQ7QUFBSyxpQkFBSyxFQUFDO0FBQVgsWUFMSixlQU1JLG9CQUFDLFFBQUQ7QUFBSyxpQkFBSyxFQUFDO0FBQVgsWUFOSjtBQUFBO0FBREo7QUFESixNQURKLGVBY0ksb0JBQUMsT0FBRDtBQUFTLFdBQUssRUFBQyxnQkFBZjtBQUFBLDZCQUNJLG9CQUFDLElBQUQ7QUFBQSwrQkFDSSxxQkFBQyxXQUFEO0FBQ0ksZUFBSyxFQUFFcTZCLFFBRFg7QUFFSSxrQkFBUSxNQUZaO0FBR0ksa0JBQVEsRUFBRSxrQkFBQXI2QixLQUFLO0FBQUEsbUJBQUk4d0MsV0FBVyxDQUFDOXdDLEtBQUQsQ0FBZjtBQUFBLFdBSG5CO0FBQUEsa0NBS0ksb0JBQUMsUUFBRDtBQUFLLGlCQUFLLEVBQUM7QUFBWCxZQUxKLGVBTUksb0JBQUMsUUFBRDtBQUFLLGlCQUFLLEVBQUM7QUFBWCxZQU5KLGVBT0ksb0JBQUMsUUFBRDtBQUFLLGlCQUFLLEVBQUM7QUFBWCxZQVBKO0FBQUE7QUFESjtBQURKLE1BZEosZUE0Qkksb0JBQUMsT0FBRDtBQUFTLFdBQUssRUFBQywrQkFBZjtBQUFBLDZCQUNJLG9CQUFDLElBQUQ7QUFBQSwrQkFDSSxxQkFBQyxXQUFEO0FBQ0ksZUFBSyxFQUFFczZCLGlCQURYO0FBRUksMkJBQWlCLE1BRnJCO0FBR0ksa0JBQVEsRUFBRSxrQkFBQXQ2QixLQUFLO0FBQUEsbUJBQUkrd0Msb0JBQW9CLENBQUMvd0MsS0FBRCxDQUF4QjtBQUFBLFdBSG5CO0FBQUEsa0NBS0ksb0JBQUMsUUFBRDtBQUFLLGlCQUFLLEVBQUM7QUFBWCxZQUxKLGVBTUksb0JBQUMsUUFBRDtBQUFLLGlCQUFLLEVBQUM7QUFBWCxZQU5KLGVBT0ksb0JBQUMsUUFBRDtBQUFLLGlCQUFLLEVBQUM7QUFBWCxZQVBKO0FBQUE7QUFESjtBQURKLE1BNUJKLGVBMENJLG9CQUFDLE9BQUQ7QUFBUyxXQUFLLEVBQUMseUNBQWY7QUFBQSw2QkFDSSxvQkFBQyxJQUFEO0FBQUEsK0JBQ0kscUJBQUMsV0FBRDtBQUNJLGVBQUssRUFBRWd4Qyw2QkFEWDtBQUVJLGtCQUFRLE1BRlo7QUFHSSwyQkFBaUIsTUFIckI7QUFJSSxrQkFBUSxFQUFFLGtCQUFBaHhDLEtBQUs7QUFBQSxtQkFBSWl4QyxnQ0FBZ0MsQ0FBQ2p4QyxLQUFELENBQXBDO0FBQUEsV0FKbkI7QUFBQSxrQ0FNSSxvQkFBQyxRQUFEO0FBQUssaUJBQUssRUFBQztBQUFYLFlBTkosZUFPSSxvQkFBQyxRQUFEO0FBQUssaUJBQUssRUFBQztBQUFYLFlBUEosZUFRSSxvQkFBQyxRQUFEO0FBQUssaUJBQUssRUFBQztBQUFYLFlBUko7QUFBQTtBQURKO0FBREosTUExQ0osZUF5REksb0JBQUMsT0FBRDtBQUFTLFdBQUssRUFBQyw0QkFBZjtBQUFBLDZCQUNJLG9CQUFDLElBQUQ7QUFBQSwrQkFDSSxxQkFBQyxXQUFEO0FBQ0ksZUFBSyxFQUFFdzVCLElBRFg7QUFFSSxjQUFJLE1BRlI7QUFHSSxrQkFBUSxFQUFFLGtCQUFBeDVCLEtBQUs7QUFBQSxtQkFBSWt4QyxPQUFPLENBQUNseEMsS0FBRCxDQUFYO0FBQUEsV0FIbkI7QUFBQSxrQ0FLSSxvQkFBQyxRQUFEO0FBQUssaUJBQUssRUFBQztBQUFYLFlBTEosZUFNSSxvQkFBQyxRQUFEO0FBQUssaUJBQUssRUFBQztBQUFYLFlBTkosZUFPSSxvQkFBQyxRQUFEO0FBQUssaUJBQUssRUFBQztBQUFYLFlBUEo7QUFBQTtBQURKO0FBREosTUF6REosZUF1RUksb0JBQUMsT0FBRDtBQUFTLFdBQUssRUFBQyxpQkFBZjtBQUFBLDZCQUNJLG9CQUFDLElBQUQ7QUFBQSwrQkFDSSxxQkFBQyxXQUFEO0FBQ0ksZUFBSyxFQUFFbXhDLEtBRFg7QUFFSSxrQkFBUSxFQUFFLGtCQUFBbnhDLEtBQUs7QUFBQSxtQkFBSW94QyxRQUFRLENBQUNweEMsS0FBRCxDQUFaO0FBQUEsV0FGbkI7QUFBQSxrQ0FJSSxvQkFBQyxRQUFEO0FBQ0ksZ0JBQUksRUFBQyxNQURUO0FBRUksaUJBQUssRUFBQztBQUZWLFlBSkosZUFTSSxvQkFBQyxRQUFEO0FBQ0ksZ0JBQUksRUFBQyxVQURUO0FBRUksaUJBQUssRUFBQztBQUZWLFlBVEosZUFjSSxvQkFBQyxRQUFEO0FBQ0ksZ0JBQUksRUFBQyxVQURUO0FBRUksaUJBQUssRUFBQztBQUZWLFlBZEo7QUFBQTtBQURKO0FBREosTUF2RUosZUErRkksb0JBQUMsT0FBRDtBQUFTLFdBQUssRUFBQyx5QkFBZjtBQUFBLDZCQUNJLG9CQUFDLElBQUQ7QUFBQSwrQkFDSSxxQkFBQyxXQUFEO0FBQ0ksZUFBSyxFQUFFcXhDLFlBRFg7QUFFSSxpQkFBTyxNQUZYO0FBR0ksa0JBQVEsRUFBRSxrQkFBQXJ4QyxLQUFLO0FBQUEsbUJBQUlzeEMsZUFBZSxDQUFDdHhDLEtBQUQsQ0FBbkI7QUFBQSxXQUhuQjtBQUFBLGtDQUtJLG9CQUFDLFFBQUQ7QUFDSSxnQkFBSSxFQUFDLE1BRFQ7QUFFSSxpQkFBSyxFQUFDO0FBRlYsWUFMSixlQVVJLG9CQUFDLFFBQUQ7QUFDSSxnQkFBSSxFQUFDLFVBRFQ7QUFFSSxpQkFBSyxFQUFDO0FBRlYsWUFWSixlQWVJLG9CQUFDLFFBQUQ7QUFDSSxnQkFBSSxFQUFDLFVBRFQ7QUFFSSxpQkFBSyxFQUFDO0FBRlYsWUFmSjtBQUFBO0FBREo7QUFESixNQS9GSixlQXdISSxvQkFBQyxPQUFEO0FBQVMsV0FBSyxFQUFDLHNCQUFmO0FBQUEsNkJBQ0ksb0JBQUMsSUFBRDtBQUFBLCtCQUNJLHFCQUFDLFdBQUQ7QUFDSSxlQUFLLEVBQUV1eEMsU0FEWDtBQUVJLHVCQUFhLEVBQUMsTUFGbEI7QUFHSSxrQkFBUSxFQUFFLGtCQUFBdnhDLEtBQUs7QUFBQSxtQkFBSXd4QyxZQUFZLENBQUN4eEMsS0FBRCxDQUFoQjtBQUFBLFdBSG5CO0FBQUEsa0NBS0ksb0JBQUMsUUFBRDtBQUNJLGdCQUFJLEVBQUM7QUFEVCxZQUxKLGVBU0ksb0JBQUMsUUFBRDtBQUNJLGdCQUFJLEVBQUM7QUFEVCxZQVRKLGVBYUksb0JBQUMsUUFBRDtBQUNJLGdCQUFJLEVBQUM7QUFEVCxZQWJKO0FBQUE7QUFESjtBQURKLE1BeEhKLGVBOElJLG9CQUFDLE9BQUQ7QUFBUyxXQUFLLEVBQUMsMEJBQWY7QUFBQSw2QkFDSSxvQkFBQyxJQUFEO0FBQUEsK0JBQ0kscUJBQUMsV0FBRDtBQUNJLGVBQUssRUFBRXc3QixhQURYO0FBRUksa0JBQVEsRUFBRSxrQkFBQXg3QixLQUFLO0FBQUEsbUJBQUl5eEMsZ0JBQWdCLENBQUN6eEMsS0FBRCxDQUFwQjtBQUFBLFdBRm5CO0FBQUEsa0NBSUksb0JBQUMsUUFBRDtBQUFLLGlCQUFLLEVBQUM7QUFBWCxZQUpKLGVBS0ksb0JBQUMsUUFBRDtBQUFLLGlCQUFLLEVBQUM7QUFBWCxZQUxKLGVBTUksb0JBQUMsUUFBRDtBQUFLLGlCQUFLLEVBQUM7QUFBWCxZQU5KO0FBQUE7QUFESjtBQURKLE1BOUlKLGVBMkpJLG9CQUFDLE9BQUQ7QUFBUyxXQUFLLEVBQUMsZ0JBQWY7QUFBQSw2QkFDSSxvQkFBQyxJQUFEO0FBQUEsK0JBQ0kscUJBQUMsV0FBRDtBQUNJLGVBQUssRUFBRTB4QyxNQURYO0FBRUksa0JBQVEsRUFBRSxrQkFBQTF4QyxLQUFLO0FBQUEsbUJBQUkyeEMsU0FBUyxDQUFDM3hDLEtBQUQsQ0FBYjtBQUFBLFdBRm5CO0FBQUEsa0NBSUksb0JBQUMsUUFBRDtBQUFLLGlCQUFLLEVBQUM7QUFBWCxZQUpKLGVBS0ksb0JBQUMsUUFBRDtBQUFLLGlCQUFLLEVBQUM7QUFBWCxZQUxKLGVBTUksb0JBQUMsUUFBRDtBQUFLLGlCQUFLLEVBQUM7QUFBWCxZQU5KLGVBT0ksb0JBQUMsUUFBRDtBQUFLLGlCQUFLLEVBQUM7QUFBWCxZQVBKLGVBUUksb0JBQUMsUUFBRDtBQUFLLGlCQUFLLEVBQUM7QUFBWCxZQVJKLGVBU0ksb0JBQUMsUUFBRDtBQUFLLGlCQUFLLEVBQUM7QUFBWCxZQVRKLGVBVUksb0JBQUMsUUFBRDtBQUFLLGlCQUFLLEVBQUM7QUFBWCxZQVZKLGVBV0ksb0JBQUMsUUFBRDtBQUFLLGlCQUFLLEVBQUM7QUFBWCxZQVhKLGVBWUksb0JBQUMsUUFBRDtBQUFLLGlCQUFLLEVBQUM7QUFBWCxZQVpKLGVBYUksb0JBQUMsUUFBRDtBQUFLLGlCQUFLLEVBQUM7QUFBWCxZQWJKLGVBY0ksb0JBQUMsUUFBRDtBQUFLLGlCQUFLLEVBQUM7QUFBWCxZQWRKLGVBZUksb0JBQUMsUUFBRDtBQUFLLGlCQUFLLEVBQUM7QUFBWCxZQWZKLGVBZ0JJLG9CQUFDLFFBQUQ7QUFBSyxpQkFBSyxFQUFDO0FBQVgsWUFoQkosZUFpQkksb0JBQUMsUUFBRDtBQUFLLGlCQUFLLEVBQUM7QUFBWCxZQWpCSixlQWtCSSxvQkFBQyxRQUFEO0FBQUssaUJBQUssRUFBQztBQUFYLFlBbEJKO0FBQUE7QUFESjtBQURKLE1BM0pKO0FBQUEsSUFESjtBQXNMSCxDOzs7Ozs7Ozs7Ozs7OztBQ25ORDtBQUNBO0FBS0E7QUFDQTtBQUNBOzs7QUFFQSxJQUFNK3RCLFlBQUUsR0FBRyxZQUFYO0FBQ0EsSUFBTTVuQixlQUFLLEdBQUcsWUFBZDtBQUNBLElBQU0wZ0MscUJBQVcsR0FBRyw0Q0FBcEI7QUFDQSxJQUFNVSxlQUFLLEdBQUc7QUFDVkUsRUFBQUEsSUFBSSxFQUFFLG1HQURJO0FBRVZELEVBQUFBLEtBQUssRUFBRTtBQUZHLENBQWQ7QUFLZSxTQUFTb0ssY0FBVCxHQUEwQjtBQUNyQyxrQkFBd0J0NUIsa0JBQVEsQ0FBQyxRQUFELENBQWhDO0FBQUE7QUFBQSxNQUFPd08sSUFBUDtBQUFBLE1BQWFraEIsT0FBYjs7QUFFQSxNQUFNNkosUUFBUSxHQUFHL3FCLElBQUksS0FBSyxRQUFULElBQXFCaGdCLFNBQXRDO0FBQ0EsTUFBTWdyQyxVQUFVLEdBQUdockIsSUFBSSxLQUFLLFVBQVQsSUFBdUJoZ0IsU0FBMUM7QUFFQSxzQkFDSSxxQkFBQyxJQUFEO0FBQU0sTUFBRSxFQUFFaW5CLFlBQVY7QUFBYyxTQUFLLEVBQUU1bkIsZUFBckI7QUFBNEIsZUFBVyxFQUFFMGdDLHFCQUF6QztBQUFzRCxTQUFLLEVBQUVVLGVBQTdEO0FBQUEsNEJBQ0kscUJBQUMsV0FBRDtBQUFRLFdBQUssRUFBRXpnQixJQUFmO0FBQXFCLGNBQVEsRUFBRWtoQixPQUEvQjtBQUF3QyxjQUFRLE1BQWhEO0FBQUEsOEJBQ0ksb0JBQUMsUUFBRDtBQUNJLGFBQUssRUFBQyxRQURWO0FBRUksYUFBSyxFQUFDO0FBRlYsUUFESixlQU1JLG9CQUFDLFFBQUQ7QUFDSSxhQUFLLEVBQUMsVUFEVjtBQUVJLGFBQUssRUFBQztBQUZWLFFBTko7QUFBQSxNQURKLGVBYUksb0JBQUMsSUFBRDtBQUFNLFdBQUssRUFBQyxrQkFBWjtBQUFBLDZCQUNJLG9CQUFDLG9CQUFEO0FBQ0ksb0JBQVksRUFBQyxFQURqQjtBQUVJLGNBQU0sRUFBRTZKLFFBRlo7QUFHSSxnQkFBUSxFQUFFQztBQUhkO0FBREosTUFiSixlQXFCSSxvQkFBQyxJQUFEO0FBQU0sV0FBSyxFQUFDLHlCQUFaO0FBQUEsNkJBQ0ksb0JBQUMsb0JBQUQ7QUFDSSxvQkFBWSxFQUFDLEVBRGpCO0FBRUksYUFBSyxFQUFDLE9BRlY7QUFHSSxjQUFNLEVBQUVELFFBSFo7QUFJSSxnQkFBUSxFQUFFQztBQUpkO0FBREosTUFyQkosZUE4Qkksb0JBQUMsSUFBRDtBQUFNLFdBQUssRUFBQyxVQUFaO0FBQUEsNkJBQ0ksb0JBQUMsb0JBQUQ7QUFDSSxvQkFBWSxFQUFDLEVBRGpCO0FBRUksYUFBSyxFQUFDLE9BRlY7QUFHSSxnQkFBUSxNQUhaO0FBSUksY0FBTSxFQUFFRCxRQUpaO0FBS0ksZ0JBQVEsRUFBRUM7QUFMZDtBQURKLE1BOUJKLGVBd0NJLG9CQUFDLElBQUQ7QUFBTSxXQUFLLEVBQUMsd0JBQVo7QUFBQSw2QkFDSSxvQkFBQyxvQkFBRDtBQUNJLG9CQUFZLEVBQUMsRUFEakI7QUFFSSxhQUFLLEVBQUMsT0FGVjtBQUdJLGdCQUFRLE1BSFo7QUFJSSxrQkFBVSxNQUpkO0FBS0ksY0FBTSxFQUFFRCxRQUxaO0FBTUksZ0JBQVEsRUFBRUM7QUFOZDtBQURKLE1BeENKLGVBbURJLG9CQUFDLElBQUQ7QUFBTSxXQUFLLEVBQUMsdUJBQVo7QUFBQSw2QkFDSSxvQkFBQyxvQkFBRDtBQUNJLG9CQUFZLEVBQUMsV0FEakI7QUFFSSxhQUFLLEVBQUMsT0FGVjtBQUdJLGNBQU0sRUFBRUQsUUFIWjtBQUlJLGdCQUFRLEVBQUVDO0FBSmQ7QUFESixNQW5ESixlQTRESSxvQkFBQyxJQUFEO0FBQU0sV0FBSyxFQUFDLGtCQUFaO0FBQUEsNkJBQ0ksb0JBQUMsb0JBQUQ7QUFDSSxvQkFBWSxFQUFDLEVBRGpCO0FBRUksa0JBQVUsRUFBQyxhQUZmO0FBR0ksY0FBTSxFQUFFRCxRQUhaO0FBSUksZ0JBQVEsRUFBRUM7QUFKZDtBQURKLE1BNURKLGVBcUVJLG9CQUFDLElBQUQ7QUFBTSxXQUFLLEVBQUMsNkJBQVo7QUFBQSw2QkFDSSxvQkFBQyxvQkFBRDtBQUNJLG9CQUFZLEVBQUMsRUFEakI7QUFFSSw0QkFBb0IsRUFBQyxhQUZ6QjtBQUdJLGNBQU0sRUFBRUQsUUFIWjtBQUlJLGdCQUFRLEVBQUVDO0FBSmQ7QUFESixNQXJFSixlQThFSSxvQkFBQyxJQUFEO0FBQU0sV0FBSyxFQUFDLG9DQUFaO0FBQUEsNkJBQ0ksb0JBQUMsb0JBQUQ7QUFDSSxvQkFBWSxFQUFDLEVBRGpCO0FBRUksYUFBSyxFQUFDLE9BRlY7QUFHSSxnQkFBUSxNQUhaO0FBSUkseUJBQWlCLEVBQUMsb0JBSnRCO0FBS0ksY0FBTSxFQUFFRCxRQUxaO0FBTUksZ0JBQVEsRUFBRUM7QUFOZDtBQURKLE1BOUVKLGVBeUZJLG9CQUFDLElBQUQ7QUFBTSxXQUFLLEVBQUMscUNBQVo7QUFBQSw2QkFDSSxvQkFBQyxvQkFBRDtBQUNJLG9CQUFZLEVBQUMsRUFEakI7QUFFSSxhQUFLLEVBQUMsT0FGVjtBQUdJLGlCQUFTLEVBQUUsRUFIZjtBQUlJLHdCQUFnQixNQUpwQjtBQUtJLGNBQU0sRUFBRUQsUUFMWjtBQU1JLGdCQUFRLEVBQUVDO0FBTmQ7QUFESixNQXpGSixlQW9HSSxvQkFBQyxJQUFEO0FBQU0sV0FBSyxFQUFDLCtDQUFaO0FBQUEsNkJBQ0ksb0JBQUMsb0JBQUQ7QUFDSSxvQkFBWSxFQUFDLEVBRGpCO0FBRUksYUFBSyxFQUFDLE9BRlY7QUFHSSxpQkFBUyxFQUFFLEdBSGY7QUFJSSxjQUFNLEVBQUVELFFBSlo7QUFLSSxnQkFBUSxFQUFFQyxVQUxkO0FBTUksZ0JBQVEsTUFOWjtBQU9JLHdCQUFnQixFQUFDO0FBUHJCO0FBREosTUFwR0osZUFnSEksb0JBQUMsSUFBRDtBQUFNLFdBQUssRUFBQywwQkFBWjtBQUFBLDZCQUNJLG9CQUFDLG9CQUFEO0FBQ0ksb0JBQVksRUFBQyxFQURqQjtBQUVJLGFBQUssRUFBQyxPQUZWO0FBR0ksY0FBTSxFQUFDLEdBSFg7QUFJSSxjQUFNLEVBQUVELFFBSlo7QUFLSSxnQkFBUSxFQUFFQztBQUxkO0FBREosTUFoSEosZUEwSEksb0JBQUMsSUFBRDtBQUFNLFdBQUssRUFBQywwQkFBWjtBQUFBLDZCQUNJLG9CQUFDLG9CQUFEO0FBQ0ksb0JBQVksRUFBQyxFQURqQjtBQUVJLGFBQUssRUFBQyxPQUZWO0FBR0ksY0FBTSxFQUFDLEdBSFg7QUFJSSxjQUFNLEVBQUVELFFBSlo7QUFLSSxnQkFBUSxFQUFFQztBQUxkO0FBREosTUExSEosZUFvSUksb0JBQUMsSUFBRDtBQUFNLFdBQUssRUFBQyxnQ0FBWjtBQUFBLDZCQUNJLG9CQUFDLG9CQUFEO0FBQ0ksb0JBQVksRUFBQyxFQURqQjtBQUVJLG1CQUFXLEVBQUMsTUFGaEI7QUFHSSxjQUFNLEVBQUVELFFBSFo7QUFJSSxnQkFBUSxFQUFFQztBQUpkO0FBREosTUFwSUosZUE2SUksb0JBQUMsSUFBRDtBQUFNLFdBQUssRUFBQyxpQ0FBWjtBQUFBLDZCQUNJLG9CQUFDLG9CQUFEO0FBQ0ksb0JBQVksRUFBQyxFQURqQjtBQUVJLG9CQUFZLEVBQUMsTUFGakI7QUFHSSxjQUFNLEVBQUVELFFBSFo7QUFJSSxnQkFBUSxFQUFFQztBQUpkO0FBREosTUE3SUo7QUFBQSxJQURKO0FBd0pILEM7O0FDaExEO0FBS0E7QUFDQTtBQUNBOzs7QUFFQSxJQUFNL2pCLFVBQUUsR0FBRyxTQUFYO0FBQ0EsSUFBTTVuQixhQUFLLEdBQUcsU0FBZDtBQUNBLElBQU0wZ0MsbUJBQVcsR0FBRyx1RkFBcEI7QUFDQSxJQUFNVSxhQUFLLEdBQUc7QUFDVkUsRUFBQUEsSUFBSSxFQUFFLGlHQURJO0FBRVZELEVBQUFBLEtBQUssRUFBRTtBQUZHLENBQWQ7QUFLZSxTQUFTdUssV0FBVCxHQUF1QjtBQUNsQyxzQkFDSSxxQkFBQyxJQUFEO0FBQU0sTUFBRSxFQUFFaGtCLFVBQVY7QUFBYyxTQUFLLEVBQUU1bkIsYUFBckI7QUFBNEIsZUFBVyxFQUFFMGdDLG1CQUF6QztBQUFzRCxTQUFLLEVBQUVVLGFBQTdEO0FBQUEsNEJBQ0ksb0JBQUMsT0FBRDtBQUFTLFdBQUssRUFBQyxlQUFmO0FBQUEsNkJBQ0ksb0JBQUMsSUFBRDtBQUFBLCtCQUNJLG9CQUFDLGVBQUQ7QUFBUyxlQUFLLEVBQUMsTUFBZjtBQUFBLGlDQUNJLG9CQUFDLHNCQUFEO0FBQVksZ0JBQUksRUFBQztBQUFqQjtBQURKO0FBREo7QUFESixNQURKLGVBU0ksb0JBQUMsT0FBRDtBQUFTLFdBQUssRUFBQyxtQkFBZjtBQUFBLDZCQUNJLG9CQUFDLElBQUQ7QUFBQSwrQkFDSSxvQkFBQyxlQUFEO0FBQVMsZUFBSyxFQUFDLG9EQUFmO0FBQUEsaUNBQ0ksb0JBQUMsc0JBQUQ7QUFBWSxnQkFBSSxFQUFDO0FBQWpCO0FBREo7QUFESjtBQURKLE1BVEosZUFpQkksb0JBQUMsT0FBRDtBQUFTLFdBQUssRUFBQyxjQUFmO0FBQUEsNkJBQ0ksb0JBQUMsSUFBRDtBQUFBLCtCQUNJLG9CQUFDLG1CQUFEO0FBQ0ksZUFBSyxFQUFDLE9BRFY7QUFFSSxpQkFBTyxFQUFDLG9XQUZaO0FBQUEsaUNBSUksb0JBQUMsc0JBQUQ7QUFBWSxnQkFBSSxFQUFDO0FBQWpCO0FBSko7QUFESjtBQURKLE1BakJKO0FBQUEsSUFESjtBQThCSCxDOzs7Ozs7Ozs7Ozs7OztBQ2hERDtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBRUE7OztBQUVBLElBQU14WixZQUFFLEdBQUcsYUFBWDtBQUNBLElBQU01bkIsZUFBSyxHQUFHLGFBQWQ7QUFDQSxJQUFNMGdDLHFCQUFXLEdBQUcsa0ZBQXBCO0FBQ0EsSUFBTVUsZUFBSyxHQUFHO0FBQ1ZFLEVBQUFBLElBQUksRUFBRSxxR0FESTtBQUVWRCxFQUFBQSxLQUFLLEVBQUU7QUFGRyxDQUFkO0FBS2UsU0FBU3dLLGFBQVQsR0FBeUI7QUFDcEMsa0JBQW9DMTVCLGtCQUFRLENBQUMsS0FBRCxDQUE1QztBQUFBO0FBQUEsTUFBTzI1QixXQUFQO0FBQUEsTUFBb0JDLFlBQXBCOztBQUVBLE1BQU01UCxXQUFXLEdBQUcsY0FDaEIsb0JBQUMsc0JBQUQ7QUFBc0IsUUFBSSxFQUFDO0FBQTNCLEtBQWdCLEtBQWhCLENBRGdCLGVBRWhCLG9CQUFDLHNCQUFEO0FBQXVCLFFBQUksRUFBQztBQUE1QixLQUFnQixNQUFoQixDQUZnQixlQUdoQixvQkFBQyxzQkFBRDtBQUF5QixRQUFJLEVBQUM7QUFBOUIsS0FBZ0IsUUFBaEIsQ0FIZ0IsQ0FBcEI7QUFNQSxzQkFDSSxxQkFBQyxJQUFEO0FBQU0sTUFBRSxFQUFFdlUsWUFBVjtBQUFjLFNBQUssRUFBRTVuQixlQUFyQjtBQUE0QixlQUFXLEVBQUUwZ0MscUJBQXpDO0FBQXNELFNBQUssRUFBRVUsZUFBN0Q7QUFBQSw0QkFDSSxvQkFBQyxPQUFEO0FBQUEsNkJBQ0ksb0JBQUMsSUFBRDtBQUFBLCtCQUNJLG9CQUFDLHFCQUFEO0FBQ0ksZUFBSyxFQUFDLE9BRFY7QUFFSSx3QkFBYyxFQUFDLE1BRm5CO0FBR0kscUJBQVcsRUFBRWpGO0FBSGpCO0FBREo7QUFESixNQURKLGVBV0ksb0JBQUMsT0FBRDtBQUFBLDZCQUNJLG9CQUFDLElBQUQ7QUFBQSwrQkFDSSxvQkFBQyxxQkFBRDtBQUNJLGVBQUssRUFBQyxPQURWO0FBRUksd0JBQWMsRUFBQyxNQUZuQjtBQUdJLHFCQUFXLEVBQUVBLFdBSGpCO0FBSUksZUFBSztBQUpUO0FBREo7QUFESixNQVhKLGVBc0JJLG9CQUFDLE9BQUQ7QUFBQSw2QkFDSSxvQkFBQyxJQUFEO0FBQUEsK0JBQ0ksb0JBQUMscUJBQUQ7QUFDSSxlQUFLLEVBQUMsV0FEVjtBQUVJLHdCQUFjLEVBQUMsTUFGbkI7QUFHSSxxQkFBVyxFQUFFQSxXQUhqQjtBQUlJLG1CQUFTO0FBSmI7QUFESjtBQURKLE1BdEJKLGVBaUNJLG9CQUFDLE9BQUQ7QUFBQSw2QkFDSSxvQkFBQyxJQUFEO0FBQUEsK0JBQ0ksb0JBQUMscUJBQUQ7QUFDSSxlQUFLLEVBQUMsT0FEVjtBQUVJLHdCQUFjLEVBQUMsTUFGbkI7QUFHSSx1QkFISjtBQUlJLG1CQUFTLEVBQUUyUCxXQUpmO0FBS0ksK0JBQXFCLEVBQUU7QUFBQSxtQkFBTUMsWUFBWSxDQUFDLFVBQUF2a0MsQ0FBQztBQUFBLHFCQUFJLENBQUNBLENBQUw7QUFBQSxhQUFGLENBQWxCO0FBQUE7QUFMM0I7QUFESjtBQURKLE1BakNKO0FBQUEsSUFESjtBQStDSCxDOztBQzVFRDtBQUlBO0FBQ0E7QUFDQTs7O0FBRUEsSUFBTW9nQixhQUFFLEdBQUcsWUFBWDtBQUNBLElBQU01bkIsZ0JBQUssR0FBRyxZQUFkO0FBQ0EsSUFBTTBnQyxzQkFBVyxHQUFHLG9EQUFwQjtBQUNBLElBQU1VLGdCQUFLLEdBQUc7QUFDVkUsRUFBQUEsSUFBSSxFQUFFLG9HQURJO0FBRVZELEVBQUFBLEtBQUssRUFBRTtBQUZHLENBQWQ7QUFLZSxTQUFTb0sseUJBQVQsR0FBMEI7QUFDckMsc0JBQ0kscUJBQUMsSUFBRDtBQUFNLE1BQUUsRUFBRTdqQixhQUFWO0FBQWMsU0FBSyxFQUFFNW5CLGdCQUFyQjtBQUE0QixlQUFXLEVBQUUwZ0Msc0JBQXpDO0FBQXNELFNBQUssRUFBRVUsZ0JBQTdEO0FBQUEsNEJBQ0ksb0JBQUMsT0FBRDtBQUFBLDZCQUNJLG9CQUFDLElBQUQ7QUFBQSwrQkFDSSxvQkFBQyxxQkFBRDtBQUFZLGNBQUksRUFBQyxXQUFqQjtBQUE2QixrQkFBUSxNQUFyQztBQUFBO0FBQUE7QUFESjtBQURKLE1BREosZUFPSSxvQkFBQyxPQUFEO0FBQUEsNkJBQ0ksb0JBQUMsSUFBRDtBQUFBLCtCQUNJLG9CQUFDLHFCQUFEO0FBQVksY0FBSSxFQUFDLFdBQWpCO0FBQTZCLGtCQUFRLE1BQXJDO0FBQUE7QUFBQTtBQURKO0FBREosTUFQSixlQWFJLG9CQUFDLE9BQUQ7QUFBQSw2QkFDSSxvQkFBQyxJQUFEO0FBQUEsK0JBQ0ksb0JBQUMscUJBQUQ7QUFBWSxjQUFJLEVBQUMsV0FBakI7QUFBNkIsa0JBQVEsTUFBckM7QUFBQTtBQUFBO0FBREo7QUFESixNQWJKLGVBbUJJLG9CQUFDLE9BQUQ7QUFBQSw2QkFDSSxvQkFBQyxJQUFEO0FBQUEsK0JBQ0ksb0JBQUMscUJBQUQ7QUFBWSxjQUFJLEVBQUMsV0FBakI7QUFBNkIsa0JBQVEsTUFBckM7QUFBQTtBQUFBO0FBREo7QUFESixNQW5CSixlQXlCSSxvQkFBQyxPQUFEO0FBQUEsNkJBQ0ksb0JBQUMsSUFBRDtBQUFBLCtCQUNJLG9CQUFDLHFCQUFEO0FBQVksY0FBSSxFQUFDLFdBQWpCO0FBQTZCLGtCQUFRLE1BQXJDO0FBQUE7QUFBQTtBQURKO0FBREosTUF6QkosZUErQkksb0JBQUMsT0FBRDtBQUFBLDZCQUNJLG9CQUFDLElBQUQ7QUFBQSwrQkFDSSxvQkFBQyxxQkFBRDtBQUFZLGNBQUksRUFBQyxXQUFqQjtBQUE2QixrQkFBUSxNQUFyQztBQUFBO0FBQUE7QUFESjtBQURKLE1BL0JKLGVBcUNJLG9CQUFDLE9BQUQ7QUFBQSw2QkFDSSxvQkFBQyxJQUFEO0FBQUEsK0JBQ0ksb0JBQUMscUJBQUQ7QUFBWSxjQUFJLEVBQUMsV0FBakI7QUFBNkIsa0JBQVEsTUFBckM7QUFBQTtBQUFBO0FBREo7QUFESixNQXJDSixlQTJDSSxvQkFBQyxPQUFEO0FBQUEsNkJBQ0ksb0JBQUMsSUFBRDtBQUFBLCtCQUNJLG9CQUFDLHFCQUFEO0FBQVksY0FBSSxFQUFDLFdBQWpCO0FBQTZCLGtCQUFRLE1BQXJDO0FBQUE7QUFBQTtBQURKO0FBREosTUEzQ0osZUFpREksb0JBQUMsT0FBRDtBQUFBLDZCQUNJLG9CQUFDLElBQUQ7QUFBQSwrQkFDSSxvQkFBQyxxQkFBRDtBQUFZLGNBQUksRUFBQyxPQUFqQjtBQUF5QixrQkFBUSxNQUFqQztBQUFBO0FBQUE7QUFESjtBQURKLE1BakRKLGVBdURJLG9CQUFDLE9BQUQ7QUFBQSw2QkFDSSxvQkFBQyxJQUFEO0FBQUEsK0JBQ0ksb0JBQUMscUJBQUQ7QUFBWSxjQUFJLEVBQUMsT0FBakI7QUFBeUIsa0JBQVEsTUFBakM7QUFBQTtBQUFBO0FBREo7QUFESixNQXZESixlQTZESSxvQkFBQyxPQUFEO0FBQUEsNkJBQ0ksb0JBQUMsSUFBRDtBQUFBLCtCQUNJLG9CQUFDLHFCQUFEO0FBQVksY0FBSSxFQUFDLFNBQWpCO0FBQUE7QUFBQTtBQURKO0FBREosTUE3REosZUFtRUksb0JBQUMsT0FBRDtBQUFBLDZCQUNJLG9CQUFDLElBQUQ7QUFBQSwrQkFDSSxvQkFBQyxxQkFBRDtBQUFZLGNBQUksRUFBQyxRQUFqQjtBQUFBO0FBQUE7QUFESjtBQURKLE1BbkVKLGVBeUVJLG9CQUFDLE9BQUQ7QUFBQSw2QkFDSSxvQkFBQyxJQUFEO0FBQUEsK0JBQ0ksb0JBQUMscUJBQUQ7QUFBWSxjQUFJLEVBQUMsVUFBakI7QUFBQTtBQUFBO0FBREo7QUFESixNQXpFSjtBQUFBLElBREo7QUFpRkgsQzs7QUNsR0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ2pDQTtBQW9DQSw2Q0FBZSxDQUNYO0FBQUVwaEMsRUFBQUEsS0FBSyxFQUFFLFFBQVQ7QUFBbUJtc0MsRUFBQUEsR0FBRyxFQUFFLFNBQXhCO0FBQW1DajFDLEVBQUFBLFNBQVMsRUFBRWdDLFVBQU1BO0FBQXBELENBRFcsRUFFWDtBQUFFOEcsRUFBQUEsS0FBSyxFQUFFLE9BQVQ7QUFBa0Jtc0MsRUFBQUEsR0FBRyxFQUFFLFFBQXZCO0FBQWlDajFDLEVBQUFBLFNBQVMsRUFBRTBDLFNBQUtBO0FBQWpELENBRlcsRUFHWDtBQUFFb0csRUFBQUEsS0FBSyxFQUFFLFFBQVQ7QUFBbUJtc0MsRUFBQUEsR0FBRyxFQUFFLFNBQXhCO0FBQW1DajFDLEVBQUFBLFNBQVMsRUFBRXNFLGdCQUE5QztBQUFzRCtFLEVBQUFBLFFBQVEsRUFBRTtBQUFoRSxDQUhXLEVBSVg7QUFBRVAsRUFBQUEsS0FBSyxFQUFFLFFBQVQ7QUFBbUJtc0MsRUFBQUEsR0FBRyxFQUFFLFNBQXhCO0FBQW1DajFDLEVBQUFBLFNBQVMsRUFBRXdHLFVBQTlDO0FBQXNENkMsRUFBQUEsUUFBUSxFQUFFO0FBQWhFLENBSlcsRUFLWDtBQUFFUCxFQUFBQSxLQUFLLEVBQUUsTUFBVDtBQUFpQm1zQyxFQUFBQSxHQUFHLEVBQUUsT0FBdEI7QUFBK0JqMUMsRUFBQUEsU0FBUyxFQUFFcUksUUFBMUM7QUFBZ0RnQixFQUFBQSxRQUFRLEVBQUU7QUFBMUQsQ0FMVyxFQU1YO0FBQUVQLEVBQUFBLEtBQUssRUFBRSxVQUFUO0FBQXFCbXNDLEVBQUFBLEdBQUcsRUFBRSxXQUExQjtBQUF1Q2oxQyxFQUFBQSxTQUFTLEVBQUVvTCxZQUFRQTtBQUExRCxDQU5XLEVBT1g7QUFBRXRDLEVBQUFBLEtBQUssRUFBRSxPQUFUO0FBQWtCbXNDLEVBQUFBLEdBQUcsRUFBRSxRQUF2QjtBQUFpQ2oxQyxFQUFBQSxTQUFTLEVBQUU4MEMsU0FBS0E7QUFBakQsQ0FQVyxFQVFYO0FBQUVoc0MsRUFBQUEsS0FBSyxFQUFFLG1CQUFUO0FBQThCbXNDLEVBQUFBLEdBQUcsRUFBRSxvQkFBbkM7QUFBeURqMUMsRUFBQUEsU0FBUyxFQUFFb1Msb0JBQWdCQTtBQUFwRixDQVJXLEVBU1g7QUFBRXRKLEVBQUFBLEtBQUssRUFBRSxXQUFUO0FBQXNCbXNDLEVBQUFBLEdBQUcsRUFBRSxhQUEzQjtBQUEwQ2oxQyxFQUFBQSxTQUFTLEVBQUUycUIsYUFBU0E7QUFBOUQsQ0FUVyxFQVVYO0FBQUU3aEIsRUFBQUEsS0FBSyxFQUFFLFFBQVQ7QUFBbUJtc0MsRUFBQUEsR0FBRyxFQUFFLFNBQXhCO0FBQW1DajFDLEVBQUFBLFNBQVMsRUFBRXF0QixVQUFNQTtBQUFwRCxDQVZXLEVBV1g7QUFBRXZrQixFQUFBQSxLQUFLLEVBQUUsUUFBVDtBQUFtQm1zQyxFQUFBQSxHQUFHLEVBQUUsU0FBeEI7QUFBbUNqMUMsRUFBQUEsU0FBUyxFQUFFZ3ZCLFVBQU1BO0FBQXBELENBWFcsRUFZWDtBQUFFbG1CLEVBQUFBLEtBQUssRUFBRSxXQUFUO0FBQXNCbXNDLEVBQUFBLEdBQUcsRUFBRSxZQUEzQjtBQUF5Q2oxQyxFQUFBQSxTQUFTLEVBQUUwdkIsYUFBU0E7QUFBN0QsQ0FaVyxFQWFYO0FBQUU1bUIsRUFBQUEsS0FBSyxFQUFFLEtBQVQ7QUFBZ0Jtc0MsRUFBQUEsR0FBRyxFQUFFLE1BQXJCO0FBQTZCajFDLEVBQUFBLFNBQVMsRUFBRWd3QixPQUF4QztBQUE2QzNtQixFQUFBQSxRQUFRLEVBQUU7QUFBdkQsQ0FiVyxFQWNYO0FBQUVQLEVBQUFBLEtBQUssRUFBRSxZQUFUO0FBQXVCbXNDLEVBQUFBLEdBQUcsRUFBRSxhQUE1QjtBQUEyQ2oxQyxFQUFBQSxTQUFTLEVBQUVzd0IsYUFBU0E7QUFBL0QsQ0FkVyxFQWVYO0FBQUV4bkIsRUFBQUEsS0FBSyxFQUFFLGFBQVQ7QUFBd0Jtc0MsRUFBQUEsR0FBRyxFQUFFLGNBQTdCO0FBQTZDajFDLEVBQUFBLFNBQVMsRUFBRWdULGNBQVVBO0FBQWxFLENBZlcsRUFnQlg7QUFBRWxLLEVBQUFBLEtBQUssRUFBRSxZQUFUO0FBQXVCbXNDLEVBQUFBLEdBQUcsRUFBRSxhQUE1QjtBQUEyQ2oxQyxFQUFBQSxTQUFTLEVBQUVzeEIsYUFBU0E7QUFBL0QsQ0FoQlcsRUFpQlg7QUFBRXhvQixFQUFBQSxLQUFLLEVBQUUsYUFBVDtBQUF3Qm1zQyxFQUFBQSxHQUFHLEVBQUUsY0FBN0I7QUFBNkNqMUMsRUFBQUEsU0FBUyxFQUFFOHlCLGNBQVVBO0FBQWxFLENBakJXLEVBa0JYO0FBQUVocUIsRUFBQUEsS0FBSyxFQUFFLGlCQUFUO0FBQTRCbXNDLEVBQUFBLEdBQUcsRUFBRSxrQkFBakM7QUFBcURqMUMsRUFBQUEsU0FBUyxFQUFFMFQsa0JBQWNBO0FBQTlFLENBbEJXLEVBbUJYO0FBQUU1SyxFQUFBQSxLQUFLLEVBQUUsTUFBVDtBQUFpQm1zQyxFQUFBQSxHQUFHLEVBQUUsT0FBdEI7QUFBK0JqMUMsRUFBQUEsU0FBUyxFQUFFb2dCLFFBQUlBO0FBQTlDLENBbkJXLEVBb0JYO0FBQUV0WCxFQUFBQSxLQUFLLEVBQUUsTUFBVDtBQUFpQm1zQyxFQUFBQSxHQUFHLEVBQUUsT0FBdEI7QUFBK0JqMUMsRUFBQUEsU0FBUyxFQUFFa2xCLFFBQUlBO0FBQTlDLENBcEJXLEVBcUJYO0FBQUVwYyxFQUFBQSxLQUFLLEVBQUUsT0FBVDtBQUFrQm1zQyxFQUFBQSxHQUFHLEVBQUUsUUFBdkI7QUFBaUNqMUMsRUFBQUEsU0FBUyxFQUFFMHpCLFNBQUtBO0FBQWpELENBckJXLEVBc0JYO0FBQUU1cUIsRUFBQUEsS0FBSyxFQUFFLFFBQVQ7QUFBbUJtc0MsRUFBQUEsR0FBRyxFQUFFLFNBQXhCO0FBQW1DajFDLEVBQUFBLFNBQVMsRUFBRTR6QixnQkFBTUE7QUFBcEQsQ0F0QlcsRUF1Qlg7QUFBRTlxQixFQUFBQSxLQUFLLEVBQUUsa0JBQVQ7QUFBNkJtc0MsRUFBQUEsR0FBRyxFQUFFLG1CQUFsQztBQUF1RGoxQyxFQUFBQSxTQUFTLEVBQUUwMUIsbUJBQWxFO0FBQW1GcnNCLEVBQUFBLFFBQVEsRUFBRTtBQUE3RixDQXZCVyxFQXdCWDtBQUFFUCxFQUFBQSxLQUFLLEVBQUUsUUFBVDtBQUFtQm1zQyxFQUFBQSxHQUFHLEVBQUUsU0FBeEI7QUFBbUNqMUMsRUFBQUEsU0FBUyxFQUFFMm5CLFVBQTlDO0FBQXNEdGUsRUFBQUEsUUFBUSxFQUFFO0FBQWhFLENBeEJXLEVBeUJYO0FBQUVQLEVBQUFBLEtBQUssRUFBRSxZQUFUO0FBQXVCbXNDLEVBQUFBLEdBQUcsRUFBRSxhQUE1QjtBQUEyQ2oxQyxFQUFBQSxTQUFTLEVBQUVvMkIsYUFBdEQ7QUFBaUUvc0IsRUFBQUEsUUFBUSxFQUFFO0FBQTNFLENBekJXLEVBMEJYO0FBQUVQLEVBQUFBLEtBQUssRUFBRSxRQUFUO0FBQW1CbXNDLEVBQUFBLEdBQUcsRUFBRSxTQUF4QjtBQUFtQ2oxQyxFQUFBQSxTQUFTLEVBQUUrNEIsVUFBOUM7QUFBc0QxdkIsRUFBQUEsUUFBUSxFQUFFO0FBQWhFLENBMUJXLEVBMkJYO0FBQUVQLEVBQUFBLEtBQUssRUFBRSxVQUFUO0FBQXFCbXNDLEVBQUFBLEdBQUcsRUFBRSxXQUExQjtBQUF1Q2oxQyxFQUFBQSxTQUFTLEVBQUVnNkIsWUFBbEQ7QUFBNEQzd0IsRUFBQUEsUUFBUSxFQUFFO0FBQXRFLENBM0JXLEVBNEJYO0FBQUVQLEVBQUFBLEtBQUssRUFBRSxRQUFUO0FBQW1CbXNDLEVBQUFBLEdBQUcsRUFBRSxTQUF4QjtBQUFtQ2oxQyxFQUFBQSxTQUFTLEVBQUVnN0IsVUFBTUE7QUFBcEQsQ0E1QlcsRUE2Qlg7QUFBRWx5QixFQUFBQSxLQUFLLEVBQUUsTUFBVDtBQUFpQm1zQyxFQUFBQSxHQUFHLEVBQUUsT0FBdEI7QUFBK0JqMUMsRUFBQUEsU0FBUyxFQUFFZzFDLGVBQTFDO0FBQWdEM3JDLEVBQUFBLFFBQVEsRUFBRTtBQUExRCxDQTdCVyxFQThCWDtBQUFFUCxFQUFBQSxLQUFLLEVBQUUsWUFBVDtBQUF1Qm1zQyxFQUFBQSxHQUFHLEVBQUUsYUFBNUI7QUFBMkNqMUMsRUFBQUEsU0FBUyxFQUFFa2lDLGNBQXREO0FBQWlFNzRCLEVBQUFBLFFBQVEsRUFBRTtBQUEzRSxDQTlCVyxFQStCWDtBQUFFUCxFQUFBQSxLQUFLLEVBQUUsU0FBVDtBQUFvQm1zQyxFQUFBQSxHQUFHLEVBQUUsVUFBekI7QUFBcUNqMUMsRUFBQUEsU0FBUyxFQUFFZ2dDLFdBQWhEO0FBQXlEMzJCLEVBQUFBLFFBQVEsRUFBRTtBQUFuRSxDQS9CVyxFQWdDWDtBQUFFUCxFQUFBQSxLQUFLLEVBQUUsYUFBVDtBQUF3Qm1zQyxFQUFBQSxHQUFHLEVBQUUsY0FBN0I7QUFBNkNqMUMsRUFBQUEsU0FBUyxFQUFFK2tDLGFBQXhEO0FBQW1FMTdCLEVBQUFBLFFBQVEsRUFBRTtBQUE3RSxDQWhDVyxFQWlDWDtBQUFFUCxFQUFBQSxLQUFLLEVBQUUsWUFBVDtBQUF1Qm1zQyxFQUFBQSxHQUFHLEVBQUUsYUFBNUI7QUFBMkNqMUMsRUFBQUEsU0FBUyxFQUFFd25DLHlCQUFVQTtBQUFoRSxDQWpDVyxDQUFmLEU7O0FDcENBO0FBQ0E7QUFPQTtBQUNBO0FBRUE7OztBQUVlLFNBQVM4TixHQUFULEdBQWU7QUFDMUIsc0JBQ0k7QUFBSyxhQUFTLEVBQUMsS0FBZjtBQUFBLDRCQUNJLG9CQUFDLHFCQUFEO0FBQ0ksZUFBUyxFQUFDLGFBRGQ7QUFFSSxvQkFBYyxlQUNWLG9CQUFDLHNCQUFEO0FBQ0ksWUFBSSxlQUNBLG9CQUFDLElBQUQ7QUFBTSxZQUFFLEVBQUMsR0FBVDtBQUFBLGlDQUNJO0FBQUssZUFBRyxFQUFDLGdIQUFUO0FBQTBILGVBQUcsRUFBQztBQUE5SDtBQURKO0FBRlIsUUFIUjtBQVdJLFdBQUssRUFBQyxXQVhWO0FBWUksaUJBQVcsRUFBRSxjQUNULG9CQUFDLHNCQUFEO0FBRUksZUFBTyxFQUFDLEdBRlo7QUFHSSxZQUFJLEVBQUMsMkNBSFQ7QUFJSSxjQUFNLEVBQUMsUUFKWDtBQUtJLFlBQUksRUFBQyxNQUxUO0FBTUksYUFBSyxFQUFDO0FBTlYsU0FDUSxNQURSLENBRFMsZUFTVCxvQkFBQyxzQkFBRDtBQUVJLGVBQU8sRUFBQyxHQUZaO0FBR0ksWUFBSSxFQUFDLGtEQUhUO0FBSUksY0FBTSxFQUFDLFFBSlg7QUFLSSxZQUFJLEVBQUMsWUFMVDtBQU1JLGFBQUssRUFBQztBQU5WLFNBQ1EsUUFEUixDQVRTLGVBaUJULG9CQUFDLHNCQUFEO0FBRUksZUFBTyxFQUFDLEdBRlo7QUFHSSxZQUFJLEVBQUMsdURBSFQ7QUFJSSxjQUFNLEVBQUMsUUFKWDtBQUtJLFlBQUksRUFBQyxPQUxUO0FBTUksYUFBSyxFQUFDO0FBTlYsU0FDUSxhQURSLENBakJTO0FBWmpCLE1BREosZUF5Q0ksb0JBQUMsYUFBRDtBQUFRLGVBQVMsRUFBQyxZQUFsQjtBQUErQixpQkFBVyxNQUExQztBQUEyQyxVQUFJLE1BQS9DO0FBQUEsNkJBQ0ksb0JBQUMscUJBQUQ7QUFBQSwrQkFDSSxvQkFBQyxTQUFEO0FBQU0saUJBQU8sRUFBQyxLQUFkO0FBQUEsb0JBQ0tELFVBQUEsQ0FBVyxVQUFBRSxLQUFLO0FBQUEsZ0NBQ2Isb0JBQUMsY0FBRDtBQUVJLHVCQUFTLEVBQUVILE9BRmY7QUFHSSxnQkFBRSxFQUFFRyxLQUFLLENBQUNOLEdBSGQ7QUFJSSx5QkFBVyxFQUFFTSxLQUFLLENBQUN6c0MsS0FKdkI7QUFLSSw2QkFBZSxFQUFDO0FBTHBCLGVBQ1N5c0MsS0FBSyxDQUFDTixHQURmLENBRGE7QUFBQSxXQUFoQjtBQURMO0FBREo7QUFESixNQXpDSixlQXlESTtBQUFNLGVBQVMsRUFBQyxvQ0FBaEI7QUFBQSw2QkFDSSxxQkFBQyxNQUFEO0FBQUEsZ0NBQ0ksb0JBQUMsS0FBRDtBQUFPLGVBQUssTUFBWjtBQUFhLGNBQUksRUFBQyxHQUFsQjtBQUFzQixtQkFBUyxFQUFFRixRQUFJQTtBQUFyQyxVQURKLEVBR0tNLFVBQUEsQ0FBVyxVQUFBRSxLQUFLO0FBQUEsOEJBQ2Isb0JBQUMsS0FBRDtBQUVJLGdCQUFJLEVBQUVBLEtBQUssQ0FBQ04sR0FGaEI7QUFHSSxpQkFBSyxFQUFFTSxLQUFLLENBQUNDLEtBSGpCO0FBSUkscUJBQVMsRUFBRUQsS0FBSyxDQUFDdjFDO0FBSnJCLGFBQ1N1MUMsS0FBSyxDQUFDTixHQURmLENBRGE7QUFBQSxTQUFoQixDQUhMO0FBQUE7QUFESixNQXpESjtBQUFBLElBREo7QUEwRUgsQzs7QUN4RkQ7QUFDQTtBQUVBO0FBRUE7O0FBRUEsSUFBTVcsUUFBUSxHQUFHQyw4REFBQSxDQUFnQkcsVUFBaEIsR0FBNkIsV0FBN0IsR0FBMkN2c0MsU0FBNUQ7QUFFQWtzQyxvQkFBTSxlQUNGLG9CQUFDLGFBQUQ7QUFBUSxVQUFRLEVBQUVDLFFBQWxCO0FBQUEseUJBQ0ksb0JBQUMsR0FBRDtBQURKLEVBREUsRUFJRmorQixRQUFRLENBQUN5WCxhQUFULENBQXVCLE9BQXZCLENBSkUsQ0FBTiIsInNvdXJjZXMiOlsid2VicGFjazovL21kYy1yZWFjdC8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9zZXRQcm90b3R5cGVPZi5qcz8wNmQwIiwid2VicGFjazovL21kYy1yZWFjdC8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9pbmhlcml0c0xvb3NlLmpzPzkzYmQiLCJ3ZWJwYWNrOi8vbWRjLXJlYWN0Ly4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2V4dGVuZHMuanM/Yzc0ZSIsIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9ub2RlX21vZHVsZXMvcmVzb2x2ZS1wYXRobmFtZS9lc20vcmVzb2x2ZS1wYXRobmFtZS5qcz85NDIxIiwid2VicGFjazovL21kYy1yZWFjdC8uL25vZGVfbW9kdWxlcy90aW55LWludmFyaWFudC9kaXN0L3RpbnktaW52YXJpYW50LmVzbS5qcz9mNTFmIiwid2VicGFjazovL21kYy1yZWFjdC8uL25vZGVfbW9kdWxlcy9oaXN0b3J5L2VzbS9oaXN0b3J5LmpzPzJlMTAiLCJ3ZWJwYWNrOi8vbWRjLXJlYWN0Ly4vbm9kZV9tb2R1bGVzL21pbmktY3JlYXRlLXJlYWN0LWNvbnRleHQvZGlzdC9lc20vaW5kZXguanM/YjQ0OCIsIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZS5qcz9hYWM0Iiwid2VicGFjazovL21kYy1yZWFjdC8uL25vZGVfbW9kdWxlcy9yZWFjdC1yb3V0ZXIvZXNtL3JlYWN0LXJvdXRlci5qcz80ZjJlIiwid2VicGFjazovL21kYy1yZWFjdC8uL25vZGVfbW9kdWxlcy9yZWFjdC1yb3V0ZXItZG9tL2VzbS9yZWFjdC1yb3V0ZXItZG9tLmpzP2U3OTIiLCJ3ZWJwYWNrOi8vbWRjLXJlYWN0Ly4vc3JjL2NvbXBvbmVudC5qcz9hMjkwIiwid2VicGFjazovL21kYy1yZWFjdC8uL3NyYy9pY29uL2NvbnN0YW50cy5qcz9iNGRlIiwid2VicGFjazovL21kYy1yZWFjdC8uL3NyYy9pY29uL0ljb24uanN4PzNiYjkiLCJ3ZWJwYWNrOi8vbWRjLXJlYWN0Ly4vc3JjL2ljb24vaW5kZXguanM/YTZhNSIsIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9zcmMvYXZhdGFyL2NvbnN0YW50cy5qcz9iZmVlIiwid2VicGFjazovL21kYy1yZWFjdC8uL3NyYy9hdmF0YXIvQXZhdGFyLmpzeD8zYjAwIiwid2VicGFjazovL21kYy1yZWFjdC8uL3NyYy9hdmF0YXIvaW5kZXguanM/ZWQ3MSIsIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9zcmMvYmFkZ2UvY29uc3RhbnRzLmpzPzRmNDkiLCJ3ZWJwYWNrOi8vbWRjLXJlYWN0Ly4vc3JjL2JhZGdlL0JhZGdlLmpzeD83NjUxIiwid2VicGFjazovL21kYy1yZWFjdC8uL3NyYy9iYWRnZS9pbmRleC5qcz9jYjBjIiwid2VicGFjazovL21kYy1yZWFjdC8uL25vZGVfbW9kdWxlcy9kb20taGVscGVycy9lc20vaGFzQ2xhc3MuanM/Mjk3NSIsIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9ub2RlX21vZHVsZXMvZG9tLWhlbHBlcnMvZXNtL2FkZENsYXNzLmpzPzc2OTMiLCJ3ZWJwYWNrOi8vbWRjLXJlYWN0Ly4vbm9kZV9tb2R1bGVzL2RvbS1oZWxwZXJzL2VzbS9yZW1vdmVDbGFzcy5qcz9kNWE5Iiwid2VicGFjazovL21kYy1yZWFjdC8uL25vZGVfbW9kdWxlcy9yZWFjdC10cmFuc2l0aW9uLWdyb3VwL2VzbS9jb25maWcuanM/MmE0MiIsIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9ub2RlX21vZHVsZXMvcmVhY3QtdHJhbnNpdGlvbi1ncm91cC9lc20vVHJhbnNpdGlvbkdyb3VwQ29udGV4dC5qcz9kMGY0Iiwid2VicGFjazovL21kYy1yZWFjdC8uL25vZGVfbW9kdWxlcy9yZWFjdC10cmFuc2l0aW9uLWdyb3VwL2VzbS9UcmFuc2l0aW9uLmpzPzc1MWIiLCJ3ZWJwYWNrOi8vbWRjLXJlYWN0Ly4vbm9kZV9tb2R1bGVzL3JlYWN0LXRyYW5zaXRpb24tZ3JvdXAvZXNtL0NTU1RyYW5zaXRpb24uanM/YTUwZiIsIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9zcmMvYmFubmVyL2NvbnN0YW50cy5qcz9kODg4Iiwid2VicGFjazovL21kYy1yZWFjdC8uL3NyYy9iYW5uZXIvQmFubmVyLmpzeD9lMjJiIiwid2VicGFjazovL21kYy1yZWFjdC8uL3NyYy9iYW5uZXIvaW5kZXguanM/YzgwYSIsIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9zcmMvYnV0dG9uL2NvbnN0YW50cy5qcz9lNTY0Iiwid2VicGFjazovL21kYy1yZWFjdC8uL3NyYy9idXR0b24vQnV0dG9uLmpzeD9iYWQ0Iiwid2VicGFjazovL21kYy1yZWFjdC8uL3NyYy9idXR0b24vaW5kZXguanM/MjA4ZiIsIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9zcmMvY2FyZC9jb25zdGFudHMuanM/ZTE3ZiIsIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9zcmMvY2FyZC9DYXJkLmpzeD80MTUyIiwid2VicGFjazovL21kYy1yZWFjdC8uL3NyYy9jYXJkL0NhcmRBY3Rpb24uanN4P2JkZmYiLCJ3ZWJwYWNrOi8vbWRjLXJlYWN0Ly4vc3JjL2NhcmQvQ2FyZEFjdGlvbnMuanN4P2NmNTQiLCJ3ZWJwYWNrOi8vbWRjLXJlYWN0Ly4vc3JjL2NhcmQvQ2FyZEFjdGlvbkJ1dHRvbnMuanN4PzJmNGUiLCJ3ZWJwYWNrOi8vbWRjLXJlYWN0Ly4vc3JjL2NhcmQvQ2FyZEFjdGlvbkljb25zLmpzeD81Y2U5Iiwid2VicGFjazovL21kYy1yZWFjdC8uL3NyYy9jYXJkL0NhcmRIZWFkZXIuanN4PzAxMGUiLCJ3ZWJwYWNrOi8vbWRjLXJlYWN0Ly4vc3JjL2NhcmQvQ2FyZE1lZGlhLmpzeD84Nzk5Iiwid2VicGFjazovL21kYy1yZWFjdC8uL3NyYy9jYXJkL0NhcmRQcmltYXJ5QWN0aW9uLmpzeD80OTA3Iiwid2VicGFjazovL21kYy1yZWFjdC8uL3NyYy9jYXJkL0NhcmRTZWN0aW9uLmpzeD9mOTk1Iiwid2VicGFjazovL21kYy1yZWFjdC8uL3NyYy9jYXJkL2luZGV4LmpzPzUyM2UiLCJ3ZWJwYWNrOi8vbWRjLXJlYWN0Ly4vc3JjL2NoZWNrYm94L2NvbnN0YW50cy5qcz9kOGMxIiwid2VicGFjazovL21kYy1yZWFjdC8uL3NyYy9jaGVja2JveC9DaGVja2JveC5qc3g/MzIxYyIsIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9zcmMvY2hlY2tib3gvaW5kZXguanM/MTBmYiIsIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9zcmMvY2hpcHMvY29uc3RhbnRzLmpzPzZmNjYiLCJ3ZWJwYWNrOi8vbWRjLXJlYWN0Ly4vc3JjL2NoaXBzL0NoaXBQcmltYXJ5QWN0aW9uLmpzeD9iMWI1Iiwid2VicGFjazovL21kYy1yZWFjdC8uL3NyYy9jaGlwcy9DaGlwVHJhaWxpbmdBY3Rpb24uanN4PzNlNzAiLCJ3ZWJwYWNrOi8vbWRjLXJlYWN0Ly4vc3JjL2NoaXBzL0NoaXAuanN4P2EzNWQiLCJ3ZWJwYWNrOi8vbWRjLXJlYWN0Ly4vc3JjL3R5cGVzLmpzPzY3OTIiLCJ3ZWJwYWNrOi8vbWRjLXJlYWN0Ly4vc3JjL2NoaXBzL0NoaXBTZXQuanN4P2YwYjUiLCJ3ZWJwYWNrOi8vbWRjLXJlYWN0Ly4vc3JjL2NoaXBzL2luZGV4LmpzP2RhNDUiLCJ3ZWJwYWNrOi8vbWRjLXJlYWN0Ly4vc3JjL2NpcmN1bGFyLXByb2dyZXNzL2NvbnN0YW50cy5qcz8xMzA5Iiwid2VicGFjazovL21kYy1yZWFjdC8uL3NyYy9jaXJjdWxhci1wcm9ncmVzcy9DaXJjdWxhclByb2dyZXNzLmpzeD8yMGFhIiwid2VicGFjazovL21kYy1yZWFjdC8uL3NyYy9jaXJjdWxhci1wcm9ncmVzcy9pbmRleC5qcz8xYjU0Iiwid2VicGFjazovL21kYy1yZWFjdC8uL3NyYy9pY29uLWJ1dHRvbi9jb25zdGFudHMuanM/MjFlNiIsIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9zcmMvaWNvbi1idXR0b24vSWNvbkJ1dHRvbi5qc3g/ODRmZiIsIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9zcmMvaWNvbi1idXR0b24vaW5kZXguanM/MTliMiIsIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9zcmMvbGluZWFyLXByb2dyZXNzL2NvbnN0YW50cy5qcz81ZTliIiwid2VicGFjazovL21kYy1yZWFjdC8uL3NyYy9saW5lYXItcHJvZ3Jlc3MvTGluZWFyUHJvZ3Jlc3MuanN4P2RhMmIiLCJ3ZWJwYWNrOi8vbWRjLXJlYWN0Ly4vc3JjL2xpbmVhci1wcm9ncmVzcy9pbmRleC5qcz9jOTQ4Iiwid2VicGFjazovL21kYy1yZWFjdC8uL3NyYy9kYXRhLXRhYmxlL2NvbnN0YW50cy5qcz9iNGM3Iiwid2VicGFjazovL21kYy1yZWFjdC8uL3NyYy9kYXRhLXRhYmxlL0RhdGFUYWJsZVByb2dyZXNzSW5kaWNhdG9yLmpzeD8xNTI5Iiwid2VicGFjazovL21kYy1yZWFjdC8uL3NyYy9mbG9hdGluZy1sYWJlbC9jb25zdGFudHMuanM/NWU0NCIsIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9zcmMvZmxvYXRpbmctbGFiZWwvRmxvYXRpbmdMYWJlbC5qc3g/NDlhNyIsIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9zcmMvZmxvYXRpbmctbGFiZWwvaW5kZXguanM/N2RiZCIsIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9zcmMvbGluZS1yaXBwbGUvY29uc3RhbnRzLmpzPzNjNzAiLCJ3ZWJwYWNrOi8vbWRjLXJlYWN0Ly4vc3JjL2xpbmUtcmlwcGxlL0xpbmVSaXBwbGUuanN4PzQ3NTIiLCJ3ZWJwYWNrOi8vbWRjLXJlYWN0Ly4vc3JjL2xpbmUtcmlwcGxlL2luZGV4LmpzPzBiYzkiLCJ3ZWJwYWNrOi8vbWRjLXJlYWN0Ly4vc3JjL2NvbnN0YW50cy5qcz81ZmIwIiwid2VicGFjazovL21kYy1yZWFjdC8uL3NyYy91dGlscy5qcz8wMjVlIiwid2VicGFjazovL21kYy1yZWFjdC8uL3NyYy9ub3RjaGVkLW91dGxpbmUvY29uc3RhbnRzLmpzP2NiOGQiLCJ3ZWJwYWNrOi8vbWRjLXJlYWN0Ly4vc3JjL25vdGNoZWQtb3V0bGluZS9Ob3RjaGVkT3V0bGluZS5qc3g/NjllOSIsIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9zcmMvbm90Y2hlZC1vdXRsaW5lL2luZGV4LmpzP2Q2N2UiLCJ3ZWJwYWNrOi8vbWRjLXJlYWN0Ly4vc3JjL21lbnUvY29uc3RhbnRzLmpzP2FjNDAiLCJ3ZWJwYWNrOi8vbWRjLXJlYWN0Ly4vc3JjL2hvb2tzLmpzP2Y3MTAiLCJ3ZWJwYWNrOi8vbWRjLXJlYWN0Ly4vc3JjL2xpc3QvY29uc3RhbnRzLmpzPzg4OGYiLCJ3ZWJwYWNrOi8vbWRjLXJlYWN0Ly4vc3JjL2xpc3QvTGlzdEl0ZW1Db250ZW50LmpzeD9jOWFiIiwid2VicGFjazovL21kYy1yZWFjdC8uL3NyYy9saXN0L0xpc3RJdGVtRW5kLmpzeD8zYjVlIiwid2VicGFjazovL21kYy1yZWFjdC8uL3NyYy9saXN0L0xpc3RJdGVtU3RhcnQuanN4PzhiY2UiLCJ3ZWJwYWNrOi8vbWRjLXJlYWN0Ly4vc3JjL2xpc3QvTGlzdEl0ZW0uanN4PzUyZDEiLCJ3ZWJwYWNrOi8vbWRjLXJlYWN0Ly4vc3JjL2xpc3QvTGlzdC5qc3g/M2ViOSIsIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9zcmMvbGlzdC9MaXN0RGl2aWRlci5qc3g/M2JiYSIsIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9zcmMvbGlzdC9MaXN0R3JvdXAuanN4P2I2ZjYiLCJ3ZWJwYWNrOi8vbWRjLXJlYWN0Ly4vc3JjL2xpc3QvTGlzdEdyb3VwU3ViaGVhZGVyLmpzeD8yOWU1Iiwid2VicGFjazovL21kYy1yZWFjdC8uL3NyYy9saXN0L2luZGV4LmpzPzUzNTQiLCJ3ZWJwYWNrOi8vbWRjLXJlYWN0Ly4vc3JjL21lbnUvTWVudUl0ZW0uanN4PzM0Y2EiLCJ3ZWJwYWNrOi8vbWRjLXJlYWN0Ly4vc3JjL21vZGFsL2NvbnN0YW50cy5qcz82ZDUzIiwid2VicGFjazovL21kYy1yZWFjdC8uL3NyYy9tb2RhbC9Nb2RhbC5qc3g/NjNmYyIsIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9zcmMvbW9kYWwvaW5kZXguanM/N2U2OCIsIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9zcmMvbGF5ZXIvTGF5ZXIuanN4PzMyNDEiLCJ3ZWJwYWNrOi8vbWRjLXJlYWN0Ly4vc3JjL2xheWVyL2luZGV4LmpzP2RjZWUiLCJ3ZWJwYWNrOi8vbWRjLXJlYWN0Ly4vc3JjL21lbnUvdXRpbHMuanM/Yjg5ZiIsIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9zcmMvbWVudS9NZW51U3VyZmFjZS5qc3g/ZjgxMiIsIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9zcmMvbWVudS9NZW51LmpzeD8wMTNhIiwid2VicGFjazovL21kYy1yZWFjdC8uL3NyYy9tZW51L01lbnVBbmNob3IuanN4PzZmMTAiLCJ3ZWJwYWNrOi8vbWRjLXJlYWN0Ly4vc3JjL21lbnUvTWVudVNlbGVjdGlvbkdyb3VwLmpzeD8wOTEwIiwid2VicGFjazovL21kYy1yZWFjdC8uL3NyYy9tZW51L01lbnVTZWxlY3Rpb25Hcm91cEljb24uanN4P2ZhNjgiLCJ3ZWJwYWNrOi8vbWRjLXJlYWN0Ly4vc3JjL21lbnUvaW5kZXguanM/OGY1NCIsIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9zcmMvc2VsZWN0L2NvbnN0YW50cy5qcz9mZWE5Iiwid2VicGFjazovL21kYy1yZWFjdC8uL3NyYy9zZWxlY3QvRHJvcGRvd25JY29uLmpzeD9iNzg1Iiwid2VicGFjazovL21kYy1yZWFjdC8uL3NyYy9zZWxlY3QvU2VsZWN0T3B0aW9uLmpzeD9hNmFjIiwid2VicGFjazovL21kYy1yZWFjdC8uL3NyYy9zZWxlY3QvSGVscGVyVGV4dC5qc3g/NmU1MiIsIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9zcmMvc2VsZWN0L1NlbGVjdC5qc3g/Y2QxNCIsIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9zcmMvc2VsZWN0L2luZGV4LmpzPzljZGQiLCJ3ZWJwYWNrOi8vbWRjLXJlYWN0Ly4vc3JjL2RhdGEtdGFibGUvRGF0YVRhYmxlUGFnaW5hdGlvbi5qc3g/MjRiYSIsIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9zcmMvZGF0YS10YWJsZS9EYXRhVGFibGUuanN4PzIzNTkiLCJ3ZWJwYWNrOi8vbWRjLXJlYWN0Ly4vc3JjL2RhdGEtdGFibGUvRGF0YVRhYmxlQ2VsbC5qc3g/ZGFlZiIsIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9zcmMvZGF0YS10YWJsZS9EYXRhVGFibGVDb250ZW50LmpzeD9iNzFmIiwid2VicGFjazovL21kYy1yZWFjdC8uL3NyYy9kYXRhLXRhYmxlL0RhdGFUYWJsZUZvb3Rlci5qc3g/ZWNlYSIsIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9zcmMvZGF0YS10YWJsZS9EYXRhVGFibGVIZWFkZXIuanN4PzEwNjQiLCJ3ZWJwYWNrOi8vbWRjLXJlYWN0Ly4vc3JjL2RhdGEtdGFibGUvRGF0YVRhYmxlSGVhZGVyQ2VsbC5qc3g/MjhkZCIsIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9zcmMvZGF0YS10YWJsZS9EYXRhVGFibGVIZWFkZXJSb3cuanN4P2EyMTAiLCJ3ZWJwYWNrOi8vbWRjLXJlYWN0Ly4vc3JjL2RhdGEtdGFibGUvRGF0YVRhYmxlUm93LmpzeD8xYTlmIiwid2VicGFjazovL21kYy1yZWFjdC8uL3NyYy9kYXRhLXRhYmxlL2luZGV4LmpzP2Q4ZTciLCJ3ZWJwYWNrOi8vbWRjLXJlYWN0Ly4vc3JjL2RpYWxvZy9jb25zdGFudHMuanM/YjQyOSIsIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9zcmMvZGlhbG9nL0RpYWxvZ0hlYWRlci5qc3g/NzIxMSIsIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9zcmMvZGlhbG9nL0RpYWxvZ0NvbnRlbnQuanN4P2ZkNTciLCJ3ZWJwYWNrOi8vbWRjLXJlYWN0Ly4vc3JjL2RpYWxvZy9EaWFsb2dBY3Rpb25zLmpzeD8xOTUyIiwid2VicGFjazovL21kYy1yZWFjdC8uL3NyYy9kaWFsb2cvRGlhbG9nLmpzeD9jMmI1Iiwid2VicGFjazovL21kYy1yZWFjdC8uL3NyYy9kaWFsb2cvaW5kZXguanM/NGQ4MyIsIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9zcmMvZHJhd2VyL2NvbnN0YW50cy5qcz85ZDY5Iiwid2VicGFjazovL21kYy1yZWFjdC8uL3NyYy9kcmF3ZXIvRHJhd2VyLmpzeD81MGFjIiwid2VicGFjazovL21kYy1yZWFjdC8uL3NyYy9kcmF3ZXIvRHJhd2VySGVhZGVyLmpzeD80YzQ4Iiwid2VicGFjazovL21kYy1yZWFjdC8uL3NyYy9kcmF3ZXIvRHJhd2VyQ29udGVudC5qc3g/YTQ2NiIsIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9zcmMvZHJhd2VyL2luZGV4LmpzPzcwODMiLCJ3ZWJwYWNrOi8vbWRjLXJlYWN0Ly4vc3JjL2VsZXZhdGlvbi9jb25zdGFudHMuanM/NjU1ZCIsIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9zcmMvZWxldmF0aW9uL0VsZXZhdGlvbi5qc3g/YzQyYiIsIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9zcmMvZWxldmF0aW9uL2luZGV4LmpzPzg4ZWEiLCJ3ZWJwYWNrOi8vbWRjLXJlYWN0Ly4vc3JjL2ZhYi9jb25zdGFudHMuanM/NDc0ZiIsIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9zcmMvZmFiL0ZBQi5qc3g/ODU3OCIsIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9zcmMvZmFiL2luZGV4LmpzP2FmNzgiLCJ3ZWJwYWNrOi8vbWRjLXJlYWN0Ly4vc3JjL2Zvcm0tZmllbGQvY29uc3RhbnRzLmpzPzlmOWYiLCJ3ZWJwYWNrOi8vbWRjLXJlYWN0Ly4vc3JjL2Zvcm0tZmllbGQvRm9ybUZpZWxkLmpzeD84NTI4Iiwid2VicGFjazovL21kYy1yZWFjdC8uL3NyYy9mb3JtLWZpZWxkL2luZGV4LmpzPzVlZDIiLCJ3ZWJwYWNrOi8vbWRjLXJlYWN0Ly4vc3JjL2ltYWdlLWxpc3QvY29uc3RhbnRzLmpzP2E3YTciLCJ3ZWJwYWNrOi8vbWRjLXJlYWN0Ly4vc3JjL2ltYWdlLWxpc3QvSW1hZ2VMaXN0SXRlbS5qc3g/MzY0NCIsIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9zcmMvaW1hZ2UtbGlzdC9JbWFnZUxpc3QuanN4P2RmMTMiLCJ3ZWJwYWNrOi8vbWRjLXJlYWN0Ly4vc3JjL2ltYWdlLWxpc3QvaW5kZXguanM/NWFiYyIsIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9zcmMvbGF5b3V0L2NvbnN0YW50cy5qcz8yN2Q1Iiwid2VicGFjazovL21kYy1yZWFjdC8uL3NyYy9sYXlvdXQvTGF5b3V0LmpzeD9iNDAxIiwid2VicGFjazovL21kYy1yZWFjdC8uL3NyYy9sYXlvdXQvaW5kZXguanM/ZjM3NiIsIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9zcmMvbGF5b3V0LWdyaWQvY29uc3RhbnRzLmpzP2E4NjEiLCJ3ZWJwYWNrOi8vbWRjLXJlYWN0Ly4vc3JjL2xheW91dC1ncmlkL0xheW91dEdyaWQuanN4P2U1YWEiLCJ3ZWJwYWNrOi8vbWRjLXJlYWN0Ly4vc3JjL2xheW91dC1ncmlkL0xheW91dEdyaWRDZWxsLmpzeD9lNjczIiwid2VicGFjazovL21kYy1yZWFjdC8uL3NyYy9sYXlvdXQtZ3JpZC9pbmRleC5qcz9kYzEyIiwid2VicGFjazovL21kYy1yZWFjdC8uL3NyYy9yYWRpby9jb25zdGFudHMuanM/NjY2NCIsIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9zcmMvcmFkaW8vUmFkaW8uanN4PzFmYWUiLCJ3ZWJwYWNrOi8vbWRjLXJlYWN0Ly4vc3JjL3JhZGlvL2luZGV4LmpzPzI3OTIiLCJ3ZWJwYWNrOi8vbWRjLXJlYWN0Ly4vbm9kZV9tb2R1bGVzL3RzbGliL3RzbGliLmVzNi5qcz85YWI0Iiwid2VicGFjazovL21kYy1yZWFjdC8uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvYmFzZS9mb3VuZGF0aW9uLmpzPzY2ODkiLCJ3ZWJwYWNrOi8vbWRjLXJlYWN0Ly4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC9iYXNlL2NvbXBvbmVudC5qcz84MTM2Iiwid2VicGFjazovL21kYy1yZWFjdC8uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvZG9tL2V2ZW50cy5qcz85MzczIiwid2VicGFjazovL21kYy1yZWFjdC8uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvZG9tL3BvbnlmaWxsLmpzP2Q4N2YiLCJ3ZWJwYWNrOi8vbWRjLXJlYWN0Ly4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC9yaXBwbGUvY29uc3RhbnRzLmpzPzY0NWUiLCJ3ZWJwYWNrOi8vbWRjLXJlYWN0Ly4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC9yaXBwbGUvdXRpbC5qcz8xZGZjIiwid2VicGFjazovL21kYy1yZWFjdC8uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvcmlwcGxlL2ZvdW5kYXRpb24uanM/NDMwMyIsIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL3JpcHBsZS9jb21wb25lbnQuanM/NDBmZiIsIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9zcmMvcmlwcGxlL1JpcHBsZS5qc3g/MWY2ZiIsIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9zcmMvcmlwcGxlL2NvbnN0YW50cy5qcz81NGIwIiwid2VicGFjazovL21kYy1yZWFjdC8uL3NyYy9yaXBwbGUvaG9va3MuanM/ODcwNCIsIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9zcmMvcmlwcGxlL1JpcHBsZVN1cmZhY2UuanN4PzBjMDgiLCJ3ZWJwYWNrOi8vbWRjLXJlYWN0Ly4vc3JjL3JpcHBsZS9pbmRleC5qcz85NDIyIiwid2VicGFjazovL21kYy1yZWFjdC8uL3NyYy9zZWdtZW50ZWQtYnV0dG9uL2NvbnN0YW50cy5qcz83MzRmIiwid2VicGFjazovL21kYy1yZWFjdC8uL3NyYy9zZWdtZW50ZWQtYnV0dG9uL1NlZ21lbnRlZEJ1dHRvblNlZ21lbnQuanN4PzE0NzgiLCJ3ZWJwYWNrOi8vbWRjLXJlYWN0Ly4vc3JjL3NlZ21lbnRlZC1idXR0b24vU2VnbWVudGVkQnV0dG9uLmpzeD81OGNmIiwid2VicGFjazovL21kYy1yZWFjdC8uL3NyYy9zZWdtZW50ZWQtYnV0dG9uL2luZGV4LmpzPzA3MzgiLCJ3ZWJwYWNrOi8vbWRjLXJlYWN0Ly4vc3JjL3NpZGUtc2hlZXQvY29uc3RhbnRzLmpzPzIxODYiLCJ3ZWJwYWNrOi8vbWRjLXJlYWN0Ly4vc3JjL3NpZGUtc2hlZXQvU2lkZVNoZWV0SGVhZGVyLmpzeD8zMGU2Iiwid2VicGFjazovL21kYy1yZWFjdC8uL3NyYy9zaWRlLXNoZWV0L1NpZGVTaGVldENvbnRlbnQuanN4PzkyMWEiLCJ3ZWJwYWNrOi8vbWRjLXJlYWN0Ly4vc3JjL3NpZGUtc2hlZXQvU2lkZVNoZWV0LmpzeD82MmM0Iiwid2VicGFjazovL21kYy1yZWFjdC8uL3NyYy9zaWRlLXNoZWV0L1NpZGVTaGVldEFwcENvbnRlbnQuanN4P2VlOTMiLCJ3ZWJwYWNrOi8vbWRjLXJlYWN0Ly4vc3JjL3NpZGUtc2hlZXQvaW5kZXguanM/NTU0YiIsIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9zcmMvc2xpZGVyL2NvbnN0YW50cy5qcz85MjM0Iiwid2VicGFjazovL21kYy1yZWFjdC8uL3NyYy9zbGlkZXIvdXRpbHMuanM/NjRmYSIsIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9zcmMvc2xpZGVyL0lucHV0LmpzeD80ZTQxIiwid2VicGFjazovL21kYy1yZWFjdC8uL3NyYy9zbGlkZXIvVGlja01hcmtzLmpzeD8zMzEzIiwid2VicGFjazovL21kYy1yZWFjdC8uL3NyYy9zbGlkZXIvVHJhY2suanN4Pzg2N2IiLCJ3ZWJwYWNrOi8vbWRjLXJlYWN0Ly4vc3JjL3NsaWRlci9UaHVtYi5qc3g/NGZiNSIsIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9zcmMvc2xpZGVyL1NsaWRlci5qc3g/MGZhMCIsIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9zcmMvc2xpZGVyL2luZGV4LmpzPzZlMTUiLCJ3ZWJwYWNrOi8vbWRjLXJlYWN0Ly4vc3JjL3NuYWNrYmFyL2NvbnN0YW50cy5qcz9hMGE0Iiwid2VicGFjazovL21kYy1yZWFjdC8uL3NyYy9zbmFja2Jhci9TbmFja2Jhci5qc3g/MmRkMCIsIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9zcmMvc25hY2tiYXIvaW5kZXguanM/ZDgwNyIsIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9zcmMvc3dpdGNoL2NvbnN0YW50cy5qcz9jMGFkIiwid2VicGFjazovL21kYy1yZWFjdC8uL3NyYy9zd2l0Y2gvU3dpdGNoLmpzeD9mMTNiIiwid2VicGFjazovL21kYy1yZWFjdC8uL3NyYy9zd2l0Y2gvaW5kZXguanM/NzdlOCIsIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9zcmMvdGFicy9jb25zdGFudHMuanM/YjRjZSIsIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9zcmMvdGFicy9jb250ZXh0LmpzPzFlNWEiLCJ3ZWJwYWNrOi8vbWRjLXJlYWN0Ly4vc3JjL3RhYnMvVGFiSW5kaWNhdG9yLmpzeD9mYWE5Iiwid2VicGFjazovL21kYy1yZWFjdC8uL3NyYy90YWJzL1RhYi5qc3g/NDVkMCIsIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9zcmMvdGFicy9UYWJTY3JvbGxlci5qc3g/ZjYwNiIsIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9zcmMvdGFicy9UYWJCYXIuanN4P2E2YTUiLCJ3ZWJwYWNrOi8vbWRjLXJlYWN0Ly4vc3JjL3RhYnMvaW5kZXguanM/ZjIzNSIsIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9zcmMvdG9vbHRpcC9jb25zdGFudHMuanM/Mzg4ZCIsIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9zcmMvdG9vbHRpcC9Ub29sdGlwLmpzeD8yNDZiIiwid2VicGFjazovL21kYy1yZWFjdC8uL3NyYy90b29sdGlwL1JpY2hUb29sdGlwLmpzeD9jMDUzIiwid2VicGFjazovL21kYy1yZWFjdC8uL3NyYy90b29sdGlwL2luZGV4LmpzPzI2OTEiLCJ3ZWJwYWNrOi8vbWRjLXJlYWN0Ly4vc3JjL3RleHQtZmllbGQvY29uc3RhbnRzLmpzPzBhMWMiLCJ3ZWJwYWNrOi8vbWRjLXJlYWN0Ly4vc3JjL3RleHQtZmllbGQvSGVscGVyVGV4dC5qc3g/YzUwNCIsIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9zcmMvdGV4dC1maWVsZC9DaGFyYWN0ZXJDb3VudGVyLmpzeD83ZjIwIiwid2VicGFjazovL21kYy1yZWFjdC8uL3NyYy90ZXh0LWZpZWxkL0lucHV0LmpzeD82ZDFkIiwid2VicGFjazovL21kYy1yZWFjdC8uL3NyYy90ZXh0LWZpZWxkL1Jlc2l6ZXIuanN4P2U1NzkiLCJ3ZWJwYWNrOi8vbWRjLXJlYWN0Ly4vc3JjL3RleHQtZmllbGQvVGV4dEZpZWxkLmpzeD9hNmQ5Iiwid2VicGFjazovL21kYy1yZWFjdC8uL3NyYy90ZXh0LWZpZWxkL2luZGV4LmpzPzVkMGYiLCJ3ZWJwYWNrOi8vbWRjLXJlYWN0Ly4vc3JjL3RvcC1hcHAtYmFyL2NvbnN0YW50cy5qcz8xN2FkIiwid2VicGFjazovL21kYy1yZWFjdC8uL3NyYy90b3AtYXBwLWJhci9Ub3BBcHBCYXJSb3cuanN4PzcxMzQiLCJ3ZWJwYWNrOi8vbWRjLXJlYWN0Ly4vc3JjL3RvcC1hcHAtYmFyL1RvcEFwcEJhclNlY3Rpb24uanN4P2Y1ZWEiLCJ3ZWJwYWNrOi8vbWRjLXJlYWN0Ly4vc3JjL3RvcC1hcHAtYmFyL1RvcEFwcEJhci5qc3g/ZWUzMyIsIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9zcmMvdG9wLWFwcC1iYXIvVG9wQXBwQmFyQWN0aW9uSXRlbS5qc3g/NTI3NiIsIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9zcmMvdG9wLWFwcC1iYXIvVG9wQXBwQmFyRml4ZWRBZGp1c3QuanN4PzViZWQiLCJ3ZWJwYWNrOi8vbWRjLXJlYWN0Ly4vc3JjL3RvcC1hcHAtYmFyL1RvcEFwcEJhck5hdmlnYXRpb25JY29uLmpzeD85ZDM2Iiwid2VicGFjazovL21kYy1yZWFjdC8uL3NyYy90b3AtYXBwLWJhci9Ub3BBcHBCYXJUaXRsZS5qc3g/NzZmYSIsIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9zcmMvdG9wLWFwcC1iYXIvaW5kZXguanM/NjI2NSIsIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9zcmMvdHlwb2dyYXBoeS9jb25zdGFudHMuanM/NTA4NSIsIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9zcmMvdHlwb2dyYXBoeS9UeXBvZ3JhcGh5LmpzeD8zNTkwIiwid2VicGFjazovL21kYy1yZWFjdC8uL3NyYy90eXBvZ3JhcGh5L2luZGV4LmpzPzYzYzQiLCJ3ZWJwYWNrOi8vbWRjLXJlYWN0Ly4vc3JjL2luZGV4LmpzP2I2MzUiLCJ3ZWJwYWNrOi8vbWRjLXJlYWN0Ly4vZG9jcy9zcmMvdXRpbHMvY29kZS5qcz83OTg2Iiwid2VicGFjazovL21kYy1yZWFjdC8uL25vZGVfbW9kdWxlcy9oaWdobGlnaHQuanMvZXMvY29yZS5qcz9iN2I4Iiwid2VicGFjazovL21kYy1yZWFjdC8uL25vZGVfbW9kdWxlcy9oaWdobGlnaHQuanMvZXMvbGFuZ3VhZ2VzL2phdmFzY3JpcHQuanM/YWM3MSIsIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9ub2RlX21vZHVsZXMvaGlnaGxpZ2h0LmpzL2VzL2xhbmd1YWdlcy9zY3NzLmpzPzM4ZjEiLCJ3ZWJwYWNrOi8vbWRjLXJlYWN0Ly4vbm9kZV9tb2R1bGVzL2hpZ2hsaWdodC5qcy9lcy9sYW5ndWFnZXMvc2hlbGwuanM/NzdiYiIsIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9ub2RlX21vZHVsZXMvaGlnaGxpZ2h0LmpzL2VzL2xhbmd1YWdlcy9wbGFpbnRleHQuanM/MGEyMSIsIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9ub2RlX21vZHVsZXMvaGlnaGxpZ2h0LmpzL2VzL2xhbmd1YWdlcy94bWwuanM/MzYzMSIsIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9kb2NzL3NyYy91dGlscy9oaWdobGlnaHQuanM/MjBkOSIsIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9kb2NzL3NyYy9jb21wb25lbnRzL0NvZGUvaW5kZXguanN4P2JkNTgiLCJ3ZWJwYWNrOi8vbWRjLXJlYWN0Ly4vZG9jcy9zcmMvY29tcG9uZW50cy9EZW1vL2luZGV4LmpzeD8xZWE1Iiwid2VicGFjazovL21kYy1yZWFjdC8uL2RvY3Mvc3JjL2NvbXBvbmVudHMvRmllbGRTZXQvaW5kZXguanN4PzFkMDUiLCJ3ZWJwYWNrOi8vbWRjLXJlYWN0Ly4vZG9jcy9zcmMvY29tcG9uZW50cy9QYWdlL2luZGV4LmpzeD8wZDI2Iiwid2VicGFjazovL21kYy1yZWFjdC8uL2RvY3Mvc3JjL3BhZ2VzL0F2YXRhci9pbmRleC5qc3g/MDJkYSIsIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9kb2NzL3NyYy9wYWdlcy9CYWRnZS9pbmRleC5qc3g/MjU3MiIsIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9kb2NzL3NyYy9wYWdlcy9CYW5uZXIvaW5kZXguanN4P2ExZjkiLCJ3ZWJwYWNrOi8vbWRjLXJlYWN0Ly4vZG9jcy9zcmMvcGFnZXMvQnV0dG9uL2luZGV4LmpzeD8wZTQ2Iiwid2VicGFjazovL21kYy1yZWFjdC8uL2RvY3Mvc3JjL3BhZ2VzL0NhcmQvaW5kZXguanN4PzhkNmYiLCJ3ZWJwYWNrOi8vbWRjLXJlYWN0Ly4vZG9jcy9zcmMvcGFnZXMvQ2hlY2tib3gvaW5kZXguanN4PzgyYzYiLCJ3ZWJwYWNrOi8vbWRjLXJlYWN0Ly4vZG9jcy9zcmMvcGFnZXMvQ2hpcHMvaW5kZXguanN4PzA1MzgiLCJ3ZWJwYWNrOi8vbWRjLXJlYWN0Ly4vZG9jcy9zcmMvcGFnZXMvQ2lyY3VsYXJQcm9ncmVzcy9pbmRleC5qc3g/Yzg4NSIsIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9kb2NzL3NyYy9wYWdlcy9EYXRhVGFibGUvaW5kZXguanN4PzU5YWQiLCJ3ZWJwYWNrOi8vbWRjLXJlYWN0Ly4vZG9jcy9zcmMvcGFnZXMvRGlhbG9nL2luZGV4LmpzeD82MDBmIiwid2VicGFjazovL21kYy1yZWFjdC8uL2RvY3Mvc3JjL2NvbXBvbmVudHMvU2VjdGlvbi9pbmRleC5qc3g/NzdkZCIsIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9kb2NzL3NyYy9wYWdlcy9EcmF3ZXIvaW5kZXguanN4P2E4NDYiLCJ3ZWJwYWNrOi8vbWRjLXJlYWN0Ly4vZG9jcy9zcmMvcGFnZXMvRWxldmF0aW9uL2luZGV4LmpzeD9iOWQ0Iiwid2VicGFjazovL21kYy1yZWFjdC8uL2RvY3Mvc3JjL3BhZ2VzL0ZBQi9pbmRleC5qc3g/NjljYyIsIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9kb2NzL3NyYy9wYWdlcy9Gb3JtRmllbGQvaW5kZXguanN4Pzk5MmMiLCJ3ZWJwYWNrOi8vbWRjLXJlYWN0Ly4vZG9jcy9zcmMvdXRpbHMvbWFya2Rvd24uanM/MmIwNiIsIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9kb2NzL3NyYy9wYWdlcy9Ib21lL2luZGV4LmpzeD9hMTA0Iiwid2VicGFjazovL21kYy1yZWFjdC8uL2RvY3Mvc3JjL3BhZ2VzL0ljb25CdXR0b24vaW5kZXguanN4P2RjZDEiLCJ3ZWJwYWNrOi8vbWRjLXJlYWN0Ly4vZG9jcy9zcmMvcGFnZXMvSW1hZ2VMaXN0L2luZGV4LmpzeD85YjAxIiwid2VicGFjazovL21kYy1yZWFjdC8uL2RvY3Mvc3JjL3BhZ2VzL0xheW91dEdyaWQvaW5kZXguanN4PzBlZjIiLCJ3ZWJwYWNrOi8vbWRjLXJlYWN0Ly4vZG9jcy9zcmMvcGFnZXMvTGluZWFyUHJvZ3Jlc3MvaW5kZXguanN4Pzc2ODQiLCJ3ZWJwYWNrOi8vbWRjLXJlYWN0Ly4vZG9jcy9zcmMvcGFnZXMvTGlzdC9pbmRleC5qc3g/ZGEzYiIsIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9kb2NzL3NyYy9wYWdlcy9NZW51L2luZGV4LmpzeD9kOWNlIiwid2VicGFjazovL21kYy1yZWFjdC8uL2RvY3Mvc3JjL3BhZ2VzL1JhZGlvL2luZGV4LmpzeD8xOTY2Iiwid2VicGFjazovL21kYy1yZWFjdC8uL2RvY3Mvc3JjL3BhZ2VzL1JpcHBsZS9pbmRleC5qc3g/YTk2MyIsIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9kb2NzL3NyYy9wYWdlcy9TZWdtZW50ZWRCdXR0b24vaW5kZXguanN4PzNkYmUiLCJ3ZWJwYWNrOi8vbWRjLXJlYWN0Ly4vZG9jcy9zcmMvcGFnZXMvU2VsZWN0L2luZGV4LmpzeD9kZmQxIiwid2VicGFjazovL21kYy1yZWFjdC8uL2RvY3Mvc3JjL3BhZ2VzL1NpZGVTaGVldC9pbmRleC5qc3g/OTM0NSIsIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9kb2NzL3NyYy9wYWdlcy9TbGlkZXIvaW5kZXguanN4P2FmODkiLCJ3ZWJwYWNrOi8vbWRjLXJlYWN0Ly4vZG9jcy9zcmMvcGFnZXMvU25hY2tiYXIvaW5kZXguanN4PzVhYjQiLCJ3ZWJwYWNrOi8vbWRjLXJlYWN0Ly4vZG9jcy9zcmMvcGFnZXMvU3dpdGNoL2luZGV4LmpzeD85Njc3Iiwid2VicGFjazovL21kYy1yZWFjdC8uL2RvY3Mvc3JjL3BhZ2VzL1RhYnMvaW5kZXguanN4P2ViZGQiLCJ3ZWJwYWNrOi8vbWRjLXJlYWN0Ly4vZG9jcy9zcmMvcGFnZXMvVGV4dEZpZWxkL2luZGV4LmpzeD9iYzFhIiwid2VicGFjazovL21kYy1yZWFjdC8uL2RvY3Mvc3JjL3BhZ2VzL1Rvb2x0aXAvaW5kZXguanN4PzliMzMiLCJ3ZWJwYWNrOi8vbWRjLXJlYWN0Ly4vZG9jcy9zcmMvcGFnZXMvVG9wQXBwQmFyL2luZGV4LmpzeD9jYjM1Iiwid2VicGFjazovL21kYy1yZWFjdC8uL2RvY3Mvc3JjL3BhZ2VzL1R5cG9ncmFwaHkvaW5kZXguanN4PzA0ODMiLCJ3ZWJwYWNrOi8vbWRjLXJlYWN0Ly4vZG9jcy9zcmMvcGFnZXMvaW5kZXguanM/ZDFhMyIsIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9kb2NzL3NyYy9yb3V0ZXMuanM/OWI0NSIsIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9kb2NzL3NyYy9BcHAuanN4Pzk1YmEiLCJ3ZWJwYWNrOi8vbWRjLXJlYWN0Ly4vZG9jcy9zcmMvaW5kZXguanM/MGI1MSJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkge1xuICBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHtcbiAgICBvLl9fcHJvdG9fXyA9IHA7XG4gICAgcmV0dXJuIG87XG4gIH07XG5cbiAgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTtcbn0iLCJpbXBvcnQgc2V0UHJvdG90eXBlT2YgZnJvbSBcIi4vc2V0UHJvdG90eXBlT2YuanNcIjtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIF9pbmhlcml0c0xvb3NlKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7XG4gIHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcy5wcm90b3R5cGUpO1xuICBzdWJDbGFzcy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBzdWJDbGFzcztcbiAgc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpO1xufSIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIF9leHRlbmRzKCkge1xuICBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkge1xuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldO1xuXG4gICAgICBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7XG4gICAgICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0YXJnZXQ7XG4gIH07XG5cbiAgcmV0dXJuIF9leHRlbmRzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59IiwiZnVuY3Rpb24gaXNBYnNvbHV0ZShwYXRobmFtZSkge1xuICByZXR1cm4gcGF0aG5hbWUuY2hhckF0KDApID09PSAnLyc7XG59XG5cbi8vIEFib3V0IDEuNXggZmFzdGVyIHRoYW4gdGhlIHR3by1hcmcgdmVyc2lvbiBvZiBBcnJheSNzcGxpY2UoKVxuZnVuY3Rpb24gc3BsaWNlT25lKGxpc3QsIGluZGV4KSB7XG4gIGZvciAodmFyIGkgPSBpbmRleCwgayA9IGkgKyAxLCBuID0gbGlzdC5sZW5ndGg7IGsgPCBuOyBpICs9IDEsIGsgKz0gMSkge1xuICAgIGxpc3RbaV0gPSBsaXN0W2tdO1xuICB9XG5cbiAgbGlzdC5wb3AoKTtcbn1cblxuLy8gVGhpcyBpbXBsZW1lbnRhdGlvbiBpcyBiYXNlZCBoZWF2aWx5IG9uIG5vZGUncyB1cmwucGFyc2VcbmZ1bmN0aW9uIHJlc29sdmVQYXRobmFtZSh0bywgZnJvbSkge1xuICBpZiAoZnJvbSA9PT0gdW5kZWZpbmVkKSBmcm9tID0gJyc7XG5cbiAgdmFyIHRvUGFydHMgPSAodG8gJiYgdG8uc3BsaXQoJy8nKSkgfHwgW107XG4gIHZhciBmcm9tUGFydHMgPSAoZnJvbSAmJiBmcm9tLnNwbGl0KCcvJykpIHx8IFtdO1xuXG4gIHZhciBpc1RvQWJzID0gdG8gJiYgaXNBYnNvbHV0ZSh0byk7XG4gIHZhciBpc0Zyb21BYnMgPSBmcm9tICYmIGlzQWJzb2x1dGUoZnJvbSk7XG4gIHZhciBtdXN0RW5kQWJzID0gaXNUb0FicyB8fCBpc0Zyb21BYnM7XG5cbiAgaWYgKHRvICYmIGlzQWJzb2x1dGUodG8pKSB7XG4gICAgLy8gdG8gaXMgYWJzb2x1dGVcbiAgICBmcm9tUGFydHMgPSB0b1BhcnRzO1xuICB9IGVsc2UgaWYgKHRvUGFydHMubGVuZ3RoKSB7XG4gICAgLy8gdG8gaXMgcmVsYXRpdmUsIGRyb3AgdGhlIGZpbGVuYW1lXG4gICAgZnJvbVBhcnRzLnBvcCgpO1xuICAgIGZyb21QYXJ0cyA9IGZyb21QYXJ0cy5jb25jYXQodG9QYXJ0cyk7XG4gIH1cblxuICBpZiAoIWZyb21QYXJ0cy5sZW5ndGgpIHJldHVybiAnLyc7XG5cbiAgdmFyIGhhc1RyYWlsaW5nU2xhc2g7XG4gIGlmIChmcm9tUGFydHMubGVuZ3RoKSB7XG4gICAgdmFyIGxhc3QgPSBmcm9tUGFydHNbZnJvbVBhcnRzLmxlbmd0aCAtIDFdO1xuICAgIGhhc1RyYWlsaW5nU2xhc2ggPSBsYXN0ID09PSAnLicgfHwgbGFzdCA9PT0gJy4uJyB8fCBsYXN0ID09PSAnJztcbiAgfSBlbHNlIHtcbiAgICBoYXNUcmFpbGluZ1NsYXNoID0gZmFsc2U7XG4gIH1cblxuICB2YXIgdXAgPSAwO1xuICBmb3IgKHZhciBpID0gZnJvbVBhcnRzLmxlbmd0aDsgaSA+PSAwOyBpLS0pIHtcbiAgICB2YXIgcGFydCA9IGZyb21QYXJ0c1tpXTtcblxuICAgIGlmIChwYXJ0ID09PSAnLicpIHtcbiAgICAgIHNwbGljZU9uZShmcm9tUGFydHMsIGkpO1xuICAgIH0gZWxzZSBpZiAocGFydCA9PT0gJy4uJykge1xuICAgICAgc3BsaWNlT25lKGZyb21QYXJ0cywgaSk7XG4gICAgICB1cCsrO1xuICAgIH0gZWxzZSBpZiAodXApIHtcbiAgICAgIHNwbGljZU9uZShmcm9tUGFydHMsIGkpO1xuICAgICAgdXAtLTtcbiAgICB9XG4gIH1cblxuICBpZiAoIW11c3RFbmRBYnMpIGZvciAoOyB1cC0tOyB1cCkgZnJvbVBhcnRzLnVuc2hpZnQoJy4uJyk7XG5cbiAgaWYgKFxuICAgIG11c3RFbmRBYnMgJiZcbiAgICBmcm9tUGFydHNbMF0gIT09ICcnICYmXG4gICAgKCFmcm9tUGFydHNbMF0gfHwgIWlzQWJzb2x1dGUoZnJvbVBhcnRzWzBdKSlcbiAgKVxuICAgIGZyb21QYXJ0cy51bnNoaWZ0KCcnKTtcblxuICB2YXIgcmVzdWx0ID0gZnJvbVBhcnRzLmpvaW4oJy8nKTtcblxuICBpZiAoaGFzVHJhaWxpbmdTbGFzaCAmJiByZXN1bHQuc3Vic3RyKC0xKSAhPT0gJy8nKSByZXN1bHQgKz0gJy8nO1xuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHJlc29sdmVQYXRobmFtZTtcbiIsInZhciBpc1Byb2R1Y3Rpb24gPSBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nO1xudmFyIHByZWZpeCA9ICdJbnZhcmlhbnQgZmFpbGVkJztcbmZ1bmN0aW9uIGludmFyaWFudChjb25kaXRpb24sIG1lc3NhZ2UpIHtcbiAgICBpZiAoY29uZGl0aW9uKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGlzUHJvZHVjdGlvbikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IocHJlZml4KTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKHByZWZpeCArIFwiOiBcIiArIChtZXNzYWdlIHx8ICcnKSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGludmFyaWFudDtcbiIsImltcG9ydCBfZXh0ZW5kcyBmcm9tICdAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9leHRlbmRzJztcbmltcG9ydCByZXNvbHZlUGF0aG5hbWUgZnJvbSAncmVzb2x2ZS1wYXRobmFtZSc7XG5pbXBvcnQgdmFsdWVFcXVhbCBmcm9tICd2YWx1ZS1lcXVhbCc7XG5pbXBvcnQgd2FybmluZyBmcm9tICd0aW55LXdhcm5pbmcnO1xuaW1wb3J0IGludmFyaWFudCBmcm9tICd0aW55LWludmFyaWFudCc7XG5cbmZ1bmN0aW9uIGFkZExlYWRpbmdTbGFzaChwYXRoKSB7XG4gIHJldHVybiBwYXRoLmNoYXJBdCgwKSA9PT0gJy8nID8gcGF0aCA6ICcvJyArIHBhdGg7XG59XG5mdW5jdGlvbiBzdHJpcExlYWRpbmdTbGFzaChwYXRoKSB7XG4gIHJldHVybiBwYXRoLmNoYXJBdCgwKSA9PT0gJy8nID8gcGF0aC5zdWJzdHIoMSkgOiBwYXRoO1xufVxuZnVuY3Rpb24gaGFzQmFzZW5hbWUocGF0aCwgcHJlZml4KSB7XG4gIHJldHVybiBwYXRoLnRvTG93ZXJDYXNlKCkuaW5kZXhPZihwcmVmaXgudG9Mb3dlckNhc2UoKSkgPT09IDAgJiYgJy8/IycuaW5kZXhPZihwYXRoLmNoYXJBdChwcmVmaXgubGVuZ3RoKSkgIT09IC0xO1xufVxuZnVuY3Rpb24gc3RyaXBCYXNlbmFtZShwYXRoLCBwcmVmaXgpIHtcbiAgcmV0dXJuIGhhc0Jhc2VuYW1lKHBhdGgsIHByZWZpeCkgPyBwYXRoLnN1YnN0cihwcmVmaXgubGVuZ3RoKSA6IHBhdGg7XG59XG5mdW5jdGlvbiBzdHJpcFRyYWlsaW5nU2xhc2gocGF0aCkge1xuICByZXR1cm4gcGF0aC5jaGFyQXQocGF0aC5sZW5ndGggLSAxKSA9PT0gJy8nID8gcGF0aC5zbGljZSgwLCAtMSkgOiBwYXRoO1xufVxuZnVuY3Rpb24gcGFyc2VQYXRoKHBhdGgpIHtcbiAgdmFyIHBhdGhuYW1lID0gcGF0aCB8fCAnLyc7XG4gIHZhciBzZWFyY2ggPSAnJztcbiAgdmFyIGhhc2ggPSAnJztcbiAgdmFyIGhhc2hJbmRleCA9IHBhdGhuYW1lLmluZGV4T2YoJyMnKTtcblxuICBpZiAoaGFzaEluZGV4ICE9PSAtMSkge1xuICAgIGhhc2ggPSBwYXRobmFtZS5zdWJzdHIoaGFzaEluZGV4KTtcbiAgICBwYXRobmFtZSA9IHBhdGhuYW1lLnN1YnN0cigwLCBoYXNoSW5kZXgpO1xuICB9XG5cbiAgdmFyIHNlYXJjaEluZGV4ID0gcGF0aG5hbWUuaW5kZXhPZignPycpO1xuXG4gIGlmIChzZWFyY2hJbmRleCAhPT0gLTEpIHtcbiAgICBzZWFyY2ggPSBwYXRobmFtZS5zdWJzdHIoc2VhcmNoSW5kZXgpO1xuICAgIHBhdGhuYW1lID0gcGF0aG5hbWUuc3Vic3RyKDAsIHNlYXJjaEluZGV4KTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgcGF0aG5hbWU6IHBhdGhuYW1lLFxuICAgIHNlYXJjaDogc2VhcmNoID09PSAnPycgPyAnJyA6IHNlYXJjaCxcbiAgICBoYXNoOiBoYXNoID09PSAnIycgPyAnJyA6IGhhc2hcbiAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVBhdGgobG9jYXRpb24pIHtcbiAgdmFyIHBhdGhuYW1lID0gbG9jYXRpb24ucGF0aG5hbWUsXG4gICAgICBzZWFyY2ggPSBsb2NhdGlvbi5zZWFyY2gsXG4gICAgICBoYXNoID0gbG9jYXRpb24uaGFzaDtcbiAgdmFyIHBhdGggPSBwYXRobmFtZSB8fCAnLyc7XG4gIGlmIChzZWFyY2ggJiYgc2VhcmNoICE9PSAnPycpIHBhdGggKz0gc2VhcmNoLmNoYXJBdCgwKSA9PT0gJz8nID8gc2VhcmNoIDogXCI/XCIgKyBzZWFyY2g7XG4gIGlmIChoYXNoICYmIGhhc2ggIT09ICcjJykgcGF0aCArPSBoYXNoLmNoYXJBdCgwKSA9PT0gJyMnID8gaGFzaCA6IFwiI1wiICsgaGFzaDtcbiAgcmV0dXJuIHBhdGg7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUxvY2F0aW9uKHBhdGgsIHN0YXRlLCBrZXksIGN1cnJlbnRMb2NhdGlvbikge1xuICB2YXIgbG9jYXRpb247XG5cbiAgaWYgKHR5cGVvZiBwYXRoID09PSAnc3RyaW5nJykge1xuICAgIC8vIFR3by1hcmcgZm9ybTogcHVzaChwYXRoLCBzdGF0ZSlcbiAgICBsb2NhdGlvbiA9IHBhcnNlUGF0aChwYXRoKTtcbiAgICBsb2NhdGlvbi5zdGF0ZSA9IHN0YXRlO1xuICB9IGVsc2Uge1xuICAgIC8vIE9uZS1hcmcgZm9ybTogcHVzaChsb2NhdGlvbilcbiAgICBsb2NhdGlvbiA9IF9leHRlbmRzKHt9LCBwYXRoKTtcbiAgICBpZiAobG9jYXRpb24ucGF0aG5hbWUgPT09IHVuZGVmaW5lZCkgbG9jYXRpb24ucGF0aG5hbWUgPSAnJztcblxuICAgIGlmIChsb2NhdGlvbi5zZWFyY2gpIHtcbiAgICAgIGlmIChsb2NhdGlvbi5zZWFyY2guY2hhckF0KDApICE9PSAnPycpIGxvY2F0aW9uLnNlYXJjaCA9ICc/JyArIGxvY2F0aW9uLnNlYXJjaDtcbiAgICB9IGVsc2Uge1xuICAgICAgbG9jYXRpb24uc2VhcmNoID0gJyc7XG4gICAgfVxuXG4gICAgaWYgKGxvY2F0aW9uLmhhc2gpIHtcbiAgICAgIGlmIChsb2NhdGlvbi5oYXNoLmNoYXJBdCgwKSAhPT0gJyMnKSBsb2NhdGlvbi5oYXNoID0gJyMnICsgbG9jYXRpb24uaGFzaDtcbiAgICB9IGVsc2Uge1xuICAgICAgbG9jYXRpb24uaGFzaCA9ICcnO1xuICAgIH1cblxuICAgIGlmIChzdGF0ZSAhPT0gdW5kZWZpbmVkICYmIGxvY2F0aW9uLnN0YXRlID09PSB1bmRlZmluZWQpIGxvY2F0aW9uLnN0YXRlID0gc3RhdGU7XG4gIH1cblxuICB0cnkge1xuICAgIGxvY2F0aW9uLnBhdGhuYW1lID0gZGVjb2RlVVJJKGxvY2F0aW9uLnBhdGhuYW1lKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGlmIChlIGluc3RhbmNlb2YgVVJJRXJyb3IpIHtcbiAgICAgIHRocm93IG5ldyBVUklFcnJvcignUGF0aG5hbWUgXCInICsgbG9jYXRpb24ucGF0aG5hbWUgKyAnXCIgY291bGQgbm90IGJlIGRlY29kZWQuICcgKyAnVGhpcyBpcyBsaWtlbHkgY2F1c2VkIGJ5IGFuIGludmFsaWQgcGVyY2VudC1lbmNvZGluZy4nKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgZTtcbiAgICB9XG4gIH1cblxuICBpZiAoa2V5KSBsb2NhdGlvbi5rZXkgPSBrZXk7XG5cbiAgaWYgKGN1cnJlbnRMb2NhdGlvbikge1xuICAgIC8vIFJlc29sdmUgaW5jb21wbGV0ZS9yZWxhdGl2ZSBwYXRobmFtZSByZWxhdGl2ZSB0byBjdXJyZW50IGxvY2F0aW9uLlxuICAgIGlmICghbG9jYXRpb24ucGF0aG5hbWUpIHtcbiAgICAgIGxvY2F0aW9uLnBhdGhuYW1lID0gY3VycmVudExvY2F0aW9uLnBhdGhuYW1lO1xuICAgIH0gZWxzZSBpZiAobG9jYXRpb24ucGF0aG5hbWUuY2hhckF0KDApICE9PSAnLycpIHtcbiAgICAgIGxvY2F0aW9uLnBhdGhuYW1lID0gcmVzb2x2ZVBhdGhuYW1lKGxvY2F0aW9uLnBhdGhuYW1lLCBjdXJyZW50TG9jYXRpb24ucGF0aG5hbWUpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBXaGVuIHRoZXJlIGlzIG5vIHByaW9yIGxvY2F0aW9uIGFuZCBwYXRobmFtZSBpcyBlbXB0eSwgc2V0IGl0IHRvIC9cbiAgICBpZiAoIWxvY2F0aW9uLnBhdGhuYW1lKSB7XG4gICAgICBsb2NhdGlvbi5wYXRobmFtZSA9ICcvJztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbG9jYXRpb247XG59XG5mdW5jdGlvbiBsb2NhdGlvbnNBcmVFcXVhbChhLCBiKSB7XG4gIHJldHVybiBhLnBhdGhuYW1lID09PSBiLnBhdGhuYW1lICYmIGEuc2VhcmNoID09PSBiLnNlYXJjaCAmJiBhLmhhc2ggPT09IGIuaGFzaCAmJiBhLmtleSA9PT0gYi5rZXkgJiYgdmFsdWVFcXVhbChhLnN0YXRlLCBiLnN0YXRlKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlVHJhbnNpdGlvbk1hbmFnZXIoKSB7XG4gIHZhciBwcm9tcHQgPSBudWxsO1xuXG4gIGZ1bmN0aW9uIHNldFByb21wdChuZXh0UHJvbXB0KSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gd2FybmluZyhwcm9tcHQgPT0gbnVsbCwgJ0EgaGlzdG9yeSBzdXBwb3J0cyBvbmx5IG9uZSBwcm9tcHQgYXQgYSB0aW1lJykgOiB2b2lkIDA7XG4gICAgcHJvbXB0ID0gbmV4dFByb21wdDtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKHByb21wdCA9PT0gbmV4dFByb21wdCkgcHJvbXB0ID0gbnVsbDtcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gY29uZmlybVRyYW5zaXRpb25Ubyhsb2NhdGlvbiwgYWN0aW9uLCBnZXRVc2VyQ29uZmlybWF0aW9uLCBjYWxsYmFjaykge1xuICAgIC8vIFRPRE86IElmIGFub3RoZXIgdHJhbnNpdGlvbiBzdGFydHMgd2hpbGUgd2UncmUgc3RpbGwgY29uZmlybWluZ1xuICAgIC8vIHRoZSBwcmV2aW91cyBvbmUsIHdlIG1heSBlbmQgdXAgaW4gYSB3ZWlyZCBzdGF0ZS4gRmlndXJlIG91dCB0aGVcbiAgICAvLyBiZXN0IHdheSB0byBoYW5kbGUgdGhpcy5cbiAgICBpZiAocHJvbXB0ICE9IG51bGwpIHtcbiAgICAgIHZhciByZXN1bHQgPSB0eXBlb2YgcHJvbXB0ID09PSAnZnVuY3Rpb24nID8gcHJvbXB0KGxvY2F0aW9uLCBhY3Rpb24pIDogcHJvbXB0O1xuXG4gICAgICBpZiAodHlwZW9mIHJlc3VsdCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBnZXRVc2VyQ29uZmlybWF0aW9uID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgZ2V0VXNlckNvbmZpcm1hdGlvbihyZXN1bHQsIGNhbGxiYWNrKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyB3YXJuaW5nKGZhbHNlLCAnQSBoaXN0b3J5IG5lZWRzIGEgZ2V0VXNlckNvbmZpcm1hdGlvbiBmdW5jdGlvbiBpbiBvcmRlciB0byB1c2UgYSBwcm9tcHQgbWVzc2FnZScpIDogdm9pZCAwO1xuICAgICAgICAgIGNhbGxiYWNrKHRydWUpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBSZXR1cm4gZmFsc2UgZnJvbSBhIHRyYW5zaXRpb24gaG9vayB0byBjYW5jZWwgdGhlIHRyYW5zaXRpb24uXG4gICAgICAgIGNhbGxiYWNrKHJlc3VsdCAhPT0gZmFsc2UpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjYWxsYmFjayh0cnVlKTtcbiAgICB9XG4gIH1cblxuICB2YXIgbGlzdGVuZXJzID0gW107XG5cbiAgZnVuY3Rpb24gYXBwZW5kTGlzdGVuZXIoZm4pIHtcbiAgICB2YXIgaXNBY3RpdmUgPSB0cnVlO1xuXG4gICAgZnVuY3Rpb24gbGlzdGVuZXIoKSB7XG4gICAgICBpZiAoaXNBY3RpdmUpIGZuLmFwcGx5KHZvaWQgMCwgYXJndW1lbnRzKTtcbiAgICB9XG5cbiAgICBsaXN0ZW5lcnMucHVzaChsaXN0ZW5lcik7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIGlzQWN0aXZlID0gZmFsc2U7XG4gICAgICBsaXN0ZW5lcnMgPSBsaXN0ZW5lcnMuZmlsdGVyKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgIHJldHVybiBpdGVtICE9PSBsaXN0ZW5lcjtcbiAgICAgIH0pO1xuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBub3RpZnlMaXN0ZW5lcnMoKSB7XG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIGxpc3RlbmVycy5mb3JFYWNoKGZ1bmN0aW9uIChsaXN0ZW5lcikge1xuICAgICAgcmV0dXJuIGxpc3RlbmVyLmFwcGx5KHZvaWQgMCwgYXJncyk7XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHNldFByb21wdDogc2V0UHJvbXB0LFxuICAgIGNvbmZpcm1UcmFuc2l0aW9uVG86IGNvbmZpcm1UcmFuc2l0aW9uVG8sXG4gICAgYXBwZW5kTGlzdGVuZXI6IGFwcGVuZExpc3RlbmVyLFxuICAgIG5vdGlmeUxpc3RlbmVyczogbm90aWZ5TGlzdGVuZXJzXG4gIH07XG59XG5cbnZhciBjYW5Vc2VET00gPSAhISh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuZG9jdW1lbnQgJiYgd2luZG93LmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQpO1xuZnVuY3Rpb24gZ2V0Q29uZmlybWF0aW9uKG1lc3NhZ2UsIGNhbGxiYWNrKSB7XG4gIGNhbGxiYWNrKHdpbmRvdy5jb25maXJtKG1lc3NhZ2UpKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1hbGVydFxufVxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIEhUTUw1IGhpc3RvcnkgQVBJIGlzIHN1cHBvcnRlZC4gVGFrZW4gZnJvbSBNb2Rlcm5penIuXG4gKlxuICogaHR0cHM6Ly9naXRodWIuY29tL01vZGVybml6ci9Nb2Rlcm5penIvYmxvYi9tYXN0ZXIvTElDRU5TRVxuICogaHR0cHM6Ly9naXRodWIuY29tL01vZGVybml6ci9Nb2Rlcm5penIvYmxvYi9tYXN0ZXIvZmVhdHVyZS1kZXRlY3RzL2hpc3RvcnkuanNcbiAqIGNoYW5nZWQgdG8gYXZvaWQgZmFsc2UgbmVnYXRpdmVzIGZvciBXaW5kb3dzIFBob25lczogaHR0cHM6Ly9naXRodWIuY29tL3JlYWN0anMvcmVhY3Qtcm91dGVyL2lzc3Vlcy81ODZcbiAqL1xuXG5mdW5jdGlvbiBzdXBwb3J0c0hpc3RvcnkoKSB7XG4gIHZhciB1YSA9IHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50O1xuICBpZiAoKHVhLmluZGV4T2YoJ0FuZHJvaWQgMi4nKSAhPT0gLTEgfHwgdWEuaW5kZXhPZignQW5kcm9pZCA0LjAnKSAhPT0gLTEpICYmIHVhLmluZGV4T2YoJ01vYmlsZSBTYWZhcmknKSAhPT0gLTEgJiYgdWEuaW5kZXhPZignQ2hyb21lJykgPT09IC0xICYmIHVhLmluZGV4T2YoJ1dpbmRvd3MgUGhvbmUnKSA9PT0gLTEpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIHdpbmRvdy5oaXN0b3J5ICYmICdwdXNoU3RhdGUnIGluIHdpbmRvdy5oaXN0b3J5O1xufVxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgYnJvd3NlciBmaXJlcyBwb3BzdGF0ZSBvbiBoYXNoIGNoYW5nZS5cbiAqIElFMTAgYW5kIElFMTEgZG8gbm90LlxuICovXG5cbmZ1bmN0aW9uIHN1cHBvcnRzUG9wU3RhdGVPbkhhc2hDaGFuZ2UoKSB7XG4gIHJldHVybiB3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKCdUcmlkZW50JykgPT09IC0xO1xufVxuLyoqXG4gKiBSZXR1cm5zIGZhbHNlIGlmIHVzaW5nIGdvKG4pIHdpdGggaGFzaCBoaXN0b3J5IGNhdXNlcyBhIGZ1bGwgcGFnZSByZWxvYWQuXG4gKi9cblxuZnVuY3Rpb24gc3VwcG9ydHNHb1dpdGhvdXRSZWxvYWRVc2luZ0hhc2goKSB7XG4gIHJldHVybiB3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKCdGaXJlZm94JykgPT09IC0xO1xufVxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgYSBnaXZlbiBwb3BzdGF0ZSBldmVudCBpcyBhbiBleHRyYW5lb3VzIFdlYktpdCBldmVudC5cbiAqIEFjY291bnRzIGZvciB0aGUgZmFjdCB0aGF0IENocm9tZSBvbiBpT1MgZmlyZXMgcmVhbCBwb3BzdGF0ZSBldmVudHNcbiAqIGNvbnRhaW5pbmcgdW5kZWZpbmVkIHN0YXRlIHdoZW4gcHJlc3NpbmcgdGhlIGJhY2sgYnV0dG9uLlxuICovXG5cbmZ1bmN0aW9uIGlzRXh0cmFuZW91c1BvcHN0YXRlRXZlbnQoZXZlbnQpIHtcbiAgcmV0dXJuIGV2ZW50LnN0YXRlID09PSB1bmRlZmluZWQgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKCdDcmlPUycpID09PSAtMTtcbn1cblxudmFyIFBvcFN0YXRlRXZlbnQgPSAncG9wc3RhdGUnO1xudmFyIEhhc2hDaGFuZ2VFdmVudCA9ICdoYXNoY2hhbmdlJztcblxuZnVuY3Rpb24gZ2V0SGlzdG9yeVN0YXRlKCkge1xuICB0cnkge1xuICAgIHJldHVybiB3aW5kb3cuaGlzdG9yeS5zdGF0ZSB8fCB7fTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIC8vIElFIDExIHNvbWV0aW1lcyB0aHJvd3Mgd2hlbiBhY2Nlc3Npbmcgd2luZG93Lmhpc3Rvcnkuc3RhdGVcbiAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL1JlYWN0VHJhaW5pbmcvaGlzdG9yeS9wdWxsLzI4OVxuICAgIHJldHVybiB7fTtcbiAgfVxufVxuLyoqXG4gKiBDcmVhdGVzIGEgaGlzdG9yeSBvYmplY3QgdGhhdCB1c2VzIHRoZSBIVE1MNSBoaXN0b3J5IEFQSSBpbmNsdWRpbmdcbiAqIHB1c2hTdGF0ZSwgcmVwbGFjZVN0YXRlLCBhbmQgdGhlIHBvcHN0YXRlIGV2ZW50LlxuICovXG5cblxuZnVuY3Rpb24gY3JlYXRlQnJvd3Nlckhpc3RvcnkocHJvcHMpIHtcbiAgaWYgKHByb3BzID09PSB2b2lkIDApIHtcbiAgICBwcm9wcyA9IHt9O1xuICB9XG5cbiAgIWNhblVzZURPTSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ0Jyb3dzZXIgaGlzdG9yeSBuZWVkcyBhIERPTScpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgdmFyIGdsb2JhbEhpc3RvcnkgPSB3aW5kb3cuaGlzdG9yeTtcbiAgdmFyIGNhblVzZUhpc3RvcnkgPSBzdXBwb3J0c0hpc3RvcnkoKTtcbiAgdmFyIG5lZWRzSGFzaENoYW5nZUxpc3RlbmVyID0gIXN1cHBvcnRzUG9wU3RhdGVPbkhhc2hDaGFuZ2UoKTtcbiAgdmFyIF9wcm9wcyA9IHByb3BzLFxuICAgICAgX3Byb3BzJGZvcmNlUmVmcmVzaCA9IF9wcm9wcy5mb3JjZVJlZnJlc2gsXG4gICAgICBmb3JjZVJlZnJlc2ggPSBfcHJvcHMkZm9yY2VSZWZyZXNoID09PSB2b2lkIDAgPyBmYWxzZSA6IF9wcm9wcyRmb3JjZVJlZnJlc2gsXG4gICAgICBfcHJvcHMkZ2V0VXNlckNvbmZpcm0gPSBfcHJvcHMuZ2V0VXNlckNvbmZpcm1hdGlvbixcbiAgICAgIGdldFVzZXJDb25maXJtYXRpb24gPSBfcHJvcHMkZ2V0VXNlckNvbmZpcm0gPT09IHZvaWQgMCA/IGdldENvbmZpcm1hdGlvbiA6IF9wcm9wcyRnZXRVc2VyQ29uZmlybSxcbiAgICAgIF9wcm9wcyRrZXlMZW5ndGggPSBfcHJvcHMua2V5TGVuZ3RoLFxuICAgICAga2V5TGVuZ3RoID0gX3Byb3BzJGtleUxlbmd0aCA9PT0gdm9pZCAwID8gNiA6IF9wcm9wcyRrZXlMZW5ndGg7XG4gIHZhciBiYXNlbmFtZSA9IHByb3BzLmJhc2VuYW1lID8gc3RyaXBUcmFpbGluZ1NsYXNoKGFkZExlYWRpbmdTbGFzaChwcm9wcy5iYXNlbmFtZSkpIDogJyc7XG5cbiAgZnVuY3Rpb24gZ2V0RE9NTG9jYXRpb24oaGlzdG9yeVN0YXRlKSB7XG4gICAgdmFyIF9yZWYgPSBoaXN0b3J5U3RhdGUgfHwge30sXG4gICAgICAgIGtleSA9IF9yZWYua2V5LFxuICAgICAgICBzdGF0ZSA9IF9yZWYuc3RhdGU7XG5cbiAgICB2YXIgX3dpbmRvdyRsb2NhdGlvbiA9IHdpbmRvdy5sb2NhdGlvbixcbiAgICAgICAgcGF0aG5hbWUgPSBfd2luZG93JGxvY2F0aW9uLnBhdGhuYW1lLFxuICAgICAgICBzZWFyY2ggPSBfd2luZG93JGxvY2F0aW9uLnNlYXJjaCxcbiAgICAgICAgaGFzaCA9IF93aW5kb3ckbG9jYXRpb24uaGFzaDtcbiAgICB2YXIgcGF0aCA9IHBhdGhuYW1lICsgc2VhcmNoICsgaGFzaDtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyB3YXJuaW5nKCFiYXNlbmFtZSB8fCBoYXNCYXNlbmFtZShwYXRoLCBiYXNlbmFtZSksICdZb3UgYXJlIGF0dGVtcHRpbmcgdG8gdXNlIGEgYmFzZW5hbWUgb24gYSBwYWdlIHdob3NlIFVSTCBwYXRoIGRvZXMgbm90IGJlZ2luICcgKyAnd2l0aCB0aGUgYmFzZW5hbWUuIEV4cGVjdGVkIHBhdGggXCInICsgcGF0aCArICdcIiB0byBiZWdpbiB3aXRoIFwiJyArIGJhc2VuYW1lICsgJ1wiLicpIDogdm9pZCAwO1xuICAgIGlmIChiYXNlbmFtZSkgcGF0aCA9IHN0cmlwQmFzZW5hbWUocGF0aCwgYmFzZW5hbWUpO1xuICAgIHJldHVybiBjcmVhdGVMb2NhdGlvbihwYXRoLCBzdGF0ZSwga2V5KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUtleSgpIHtcbiAgICByZXR1cm4gTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc3Vic3RyKDIsIGtleUxlbmd0aCk7XG4gIH1cblxuICB2YXIgdHJhbnNpdGlvbk1hbmFnZXIgPSBjcmVhdGVUcmFuc2l0aW9uTWFuYWdlcigpO1xuXG4gIGZ1bmN0aW9uIHNldFN0YXRlKG5leHRTdGF0ZSkge1xuICAgIF9leHRlbmRzKGhpc3RvcnksIG5leHRTdGF0ZSk7XG5cbiAgICBoaXN0b3J5Lmxlbmd0aCA9IGdsb2JhbEhpc3RvcnkubGVuZ3RoO1xuICAgIHRyYW5zaXRpb25NYW5hZ2VyLm5vdGlmeUxpc3RlbmVycyhoaXN0b3J5LmxvY2F0aW9uLCBoaXN0b3J5LmFjdGlvbik7XG4gIH1cblxuICBmdW5jdGlvbiBoYW5kbGVQb3BTdGF0ZShldmVudCkge1xuICAgIC8vIElnbm9yZSBleHRyYW5lb3VzIHBvcHN0YXRlIGV2ZW50cyBpbiBXZWJLaXQuXG4gICAgaWYgKGlzRXh0cmFuZW91c1BvcHN0YXRlRXZlbnQoZXZlbnQpKSByZXR1cm47XG4gICAgaGFuZGxlUG9wKGdldERPTUxvY2F0aW9uKGV2ZW50LnN0YXRlKSk7XG4gIH1cblxuICBmdW5jdGlvbiBoYW5kbGVIYXNoQ2hhbmdlKCkge1xuICAgIGhhbmRsZVBvcChnZXRET01Mb2NhdGlvbihnZXRIaXN0b3J5U3RhdGUoKSkpO1xuICB9XG5cbiAgdmFyIGZvcmNlTmV4dFBvcCA9IGZhbHNlO1xuXG4gIGZ1bmN0aW9uIGhhbmRsZVBvcChsb2NhdGlvbikge1xuICAgIGlmIChmb3JjZU5leHRQb3ApIHtcbiAgICAgIGZvcmNlTmV4dFBvcCA9IGZhbHNlO1xuICAgICAgc2V0U3RhdGUoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGFjdGlvbiA9ICdQT1AnO1xuICAgICAgdHJhbnNpdGlvbk1hbmFnZXIuY29uZmlybVRyYW5zaXRpb25Ubyhsb2NhdGlvbiwgYWN0aW9uLCBnZXRVc2VyQ29uZmlybWF0aW9uLCBmdW5jdGlvbiAob2spIHtcbiAgICAgICAgaWYgKG9rKSB7XG4gICAgICAgICAgc2V0U3RhdGUoe1xuICAgICAgICAgICAgYWN0aW9uOiBhY3Rpb24sXG4gICAgICAgICAgICBsb2NhdGlvbjogbG9jYXRpb25cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXZlcnRQb3AobG9jYXRpb24pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZXZlcnRQb3AoZnJvbUxvY2F0aW9uKSB7XG4gICAgdmFyIHRvTG9jYXRpb24gPSBoaXN0b3J5LmxvY2F0aW9uOyAvLyBUT0RPOiBXZSBjb3VsZCBwcm9iYWJseSBtYWtlIHRoaXMgbW9yZSByZWxpYWJsZSBieVxuICAgIC8vIGtlZXBpbmcgYSBsaXN0IG9mIGtleXMgd2UndmUgc2VlbiBpbiBzZXNzaW9uU3RvcmFnZS5cbiAgICAvLyBJbnN0ZWFkLCB3ZSBqdXN0IGRlZmF1bHQgdG8gMCBmb3Iga2V5cyB3ZSBkb24ndCBrbm93LlxuXG4gICAgdmFyIHRvSW5kZXggPSBhbGxLZXlzLmluZGV4T2YodG9Mb2NhdGlvbi5rZXkpO1xuICAgIGlmICh0b0luZGV4ID09PSAtMSkgdG9JbmRleCA9IDA7XG4gICAgdmFyIGZyb21JbmRleCA9IGFsbEtleXMuaW5kZXhPZihmcm9tTG9jYXRpb24ua2V5KTtcbiAgICBpZiAoZnJvbUluZGV4ID09PSAtMSkgZnJvbUluZGV4ID0gMDtcbiAgICB2YXIgZGVsdGEgPSB0b0luZGV4IC0gZnJvbUluZGV4O1xuXG4gICAgaWYgKGRlbHRhKSB7XG4gICAgICBmb3JjZU5leHRQb3AgPSB0cnVlO1xuICAgICAgZ28oZGVsdGEpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBpbml0aWFsTG9jYXRpb24gPSBnZXRET01Mb2NhdGlvbihnZXRIaXN0b3J5U3RhdGUoKSk7XG4gIHZhciBhbGxLZXlzID0gW2luaXRpYWxMb2NhdGlvbi5rZXldOyAvLyBQdWJsaWMgaW50ZXJmYWNlXG5cbiAgZnVuY3Rpb24gY3JlYXRlSHJlZihsb2NhdGlvbikge1xuICAgIHJldHVybiBiYXNlbmFtZSArIGNyZWF0ZVBhdGgobG9jYXRpb24pO1xuICB9XG5cbiAgZnVuY3Rpb24gcHVzaChwYXRoLCBzdGF0ZSkge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IHdhcm5pbmcoISh0eXBlb2YgcGF0aCA9PT0gJ29iamVjdCcgJiYgcGF0aC5zdGF0ZSAhPT0gdW5kZWZpbmVkICYmIHN0YXRlICE9PSB1bmRlZmluZWQpLCAnWW91IHNob3VsZCBhdm9pZCBwcm92aWRpbmcgYSAybmQgc3RhdGUgYXJndW1lbnQgdG8gcHVzaCB3aGVuIHRoZSAxc3QgJyArICdhcmd1bWVudCBpcyBhIGxvY2F0aW9uLWxpa2Ugb2JqZWN0IHRoYXQgYWxyZWFkeSBoYXMgc3RhdGU7IGl0IGlzIGlnbm9yZWQnKSA6IHZvaWQgMDtcbiAgICB2YXIgYWN0aW9uID0gJ1BVU0gnO1xuICAgIHZhciBsb2NhdGlvbiA9IGNyZWF0ZUxvY2F0aW9uKHBhdGgsIHN0YXRlLCBjcmVhdGVLZXkoKSwgaGlzdG9yeS5sb2NhdGlvbik7XG4gICAgdHJhbnNpdGlvbk1hbmFnZXIuY29uZmlybVRyYW5zaXRpb25Ubyhsb2NhdGlvbiwgYWN0aW9uLCBnZXRVc2VyQ29uZmlybWF0aW9uLCBmdW5jdGlvbiAob2spIHtcbiAgICAgIGlmICghb2spIHJldHVybjtcbiAgICAgIHZhciBocmVmID0gY3JlYXRlSHJlZihsb2NhdGlvbik7XG4gICAgICB2YXIga2V5ID0gbG9jYXRpb24ua2V5LFxuICAgICAgICAgIHN0YXRlID0gbG9jYXRpb24uc3RhdGU7XG5cbiAgICAgIGlmIChjYW5Vc2VIaXN0b3J5KSB7XG4gICAgICAgIGdsb2JhbEhpc3RvcnkucHVzaFN0YXRlKHtcbiAgICAgICAgICBrZXk6IGtleSxcbiAgICAgICAgICBzdGF0ZTogc3RhdGVcbiAgICAgICAgfSwgbnVsbCwgaHJlZik7XG5cbiAgICAgICAgaWYgKGZvcmNlUmVmcmVzaCkge1xuICAgICAgICAgIHdpbmRvdy5sb2NhdGlvbi5ocmVmID0gaHJlZjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgcHJldkluZGV4ID0gYWxsS2V5cy5pbmRleE9mKGhpc3RvcnkubG9jYXRpb24ua2V5KTtcbiAgICAgICAgICB2YXIgbmV4dEtleXMgPSBhbGxLZXlzLnNsaWNlKDAsIHByZXZJbmRleCArIDEpO1xuICAgICAgICAgIG5leHRLZXlzLnB1c2gobG9jYXRpb24ua2V5KTtcbiAgICAgICAgICBhbGxLZXlzID0gbmV4dEtleXM7XG4gICAgICAgICAgc2V0U3RhdGUoe1xuICAgICAgICAgICAgYWN0aW9uOiBhY3Rpb24sXG4gICAgICAgICAgICBsb2NhdGlvbjogbG9jYXRpb25cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gd2FybmluZyhzdGF0ZSA9PT0gdW5kZWZpbmVkLCAnQnJvd3NlciBoaXN0b3J5IGNhbm5vdCBwdXNoIHN0YXRlIGluIGJyb3dzZXJzIHRoYXQgZG8gbm90IHN1cHBvcnQgSFRNTDUgaGlzdG9yeScpIDogdm9pZCAwO1xuICAgICAgICB3aW5kb3cubG9jYXRpb24uaHJlZiA9IGhyZWY7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiByZXBsYWNlKHBhdGgsIHN0YXRlKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gd2FybmluZyghKHR5cGVvZiBwYXRoID09PSAnb2JqZWN0JyAmJiBwYXRoLnN0YXRlICE9PSB1bmRlZmluZWQgJiYgc3RhdGUgIT09IHVuZGVmaW5lZCksICdZb3Ugc2hvdWxkIGF2b2lkIHByb3ZpZGluZyBhIDJuZCBzdGF0ZSBhcmd1bWVudCB0byByZXBsYWNlIHdoZW4gdGhlIDFzdCAnICsgJ2FyZ3VtZW50IGlzIGEgbG9jYXRpb24tbGlrZSBvYmplY3QgdGhhdCBhbHJlYWR5IGhhcyBzdGF0ZTsgaXQgaXMgaWdub3JlZCcpIDogdm9pZCAwO1xuICAgIHZhciBhY3Rpb24gPSAnUkVQTEFDRSc7XG4gICAgdmFyIGxvY2F0aW9uID0gY3JlYXRlTG9jYXRpb24ocGF0aCwgc3RhdGUsIGNyZWF0ZUtleSgpLCBoaXN0b3J5LmxvY2F0aW9uKTtcbiAgICB0cmFuc2l0aW9uTWFuYWdlci5jb25maXJtVHJhbnNpdGlvblRvKGxvY2F0aW9uLCBhY3Rpb24sIGdldFVzZXJDb25maXJtYXRpb24sIGZ1bmN0aW9uIChvaykge1xuICAgICAgaWYgKCFvaykgcmV0dXJuO1xuICAgICAgdmFyIGhyZWYgPSBjcmVhdGVIcmVmKGxvY2F0aW9uKTtcbiAgICAgIHZhciBrZXkgPSBsb2NhdGlvbi5rZXksXG4gICAgICAgICAgc3RhdGUgPSBsb2NhdGlvbi5zdGF0ZTtcblxuICAgICAgaWYgKGNhblVzZUhpc3RvcnkpIHtcbiAgICAgICAgZ2xvYmFsSGlzdG9yeS5yZXBsYWNlU3RhdGUoe1xuICAgICAgICAgIGtleToga2V5LFxuICAgICAgICAgIHN0YXRlOiBzdGF0ZVxuICAgICAgICB9LCBudWxsLCBocmVmKTtcblxuICAgICAgICBpZiAoZm9yY2VSZWZyZXNoKSB7XG4gICAgICAgICAgd2luZG93LmxvY2F0aW9uLnJlcGxhY2UoaHJlZik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIHByZXZJbmRleCA9IGFsbEtleXMuaW5kZXhPZihoaXN0b3J5LmxvY2F0aW9uLmtleSk7XG4gICAgICAgICAgaWYgKHByZXZJbmRleCAhPT0gLTEpIGFsbEtleXNbcHJldkluZGV4XSA9IGxvY2F0aW9uLmtleTtcbiAgICAgICAgICBzZXRTdGF0ZSh7XG4gICAgICAgICAgICBhY3Rpb246IGFjdGlvbixcbiAgICAgICAgICAgIGxvY2F0aW9uOiBsb2NhdGlvblxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyB3YXJuaW5nKHN0YXRlID09PSB1bmRlZmluZWQsICdCcm93c2VyIGhpc3RvcnkgY2Fubm90IHJlcGxhY2Ugc3RhdGUgaW4gYnJvd3NlcnMgdGhhdCBkbyBub3Qgc3VwcG9ydCBIVE1MNSBoaXN0b3J5JykgOiB2b2lkIDA7XG4gICAgICAgIHdpbmRvdy5sb2NhdGlvbi5yZXBsYWNlKGhyZWYpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gZ28obikge1xuICAgIGdsb2JhbEhpc3RvcnkuZ28obik7XG4gIH1cblxuICBmdW5jdGlvbiBnb0JhY2soKSB7XG4gICAgZ28oLTEpO1xuICB9XG5cbiAgZnVuY3Rpb24gZ29Gb3J3YXJkKCkge1xuICAgIGdvKDEpO1xuICB9XG5cbiAgdmFyIGxpc3RlbmVyQ291bnQgPSAwO1xuXG4gIGZ1bmN0aW9uIGNoZWNrRE9NTGlzdGVuZXJzKGRlbHRhKSB7XG4gICAgbGlzdGVuZXJDb3VudCArPSBkZWx0YTtcblxuICAgIGlmIChsaXN0ZW5lckNvdW50ID09PSAxICYmIGRlbHRhID09PSAxKSB7XG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihQb3BTdGF0ZUV2ZW50LCBoYW5kbGVQb3BTdGF0ZSk7XG4gICAgICBpZiAobmVlZHNIYXNoQ2hhbmdlTGlzdGVuZXIpIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKEhhc2hDaGFuZ2VFdmVudCwgaGFuZGxlSGFzaENoYW5nZSk7XG4gICAgfSBlbHNlIGlmIChsaXN0ZW5lckNvdW50ID09PSAwKSB7XG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihQb3BTdGF0ZUV2ZW50LCBoYW5kbGVQb3BTdGF0ZSk7XG4gICAgICBpZiAobmVlZHNIYXNoQ2hhbmdlTGlzdGVuZXIpIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKEhhc2hDaGFuZ2VFdmVudCwgaGFuZGxlSGFzaENoYW5nZSk7XG4gICAgfVxuICB9XG5cbiAgdmFyIGlzQmxvY2tlZCA9IGZhbHNlO1xuXG4gIGZ1bmN0aW9uIGJsb2NrKHByb21wdCkge1xuICAgIGlmIChwcm9tcHQgPT09IHZvaWQgMCkge1xuICAgICAgcHJvbXB0ID0gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIHVuYmxvY2sgPSB0cmFuc2l0aW9uTWFuYWdlci5zZXRQcm9tcHQocHJvbXB0KTtcblxuICAgIGlmICghaXNCbG9ja2VkKSB7XG4gICAgICBjaGVja0RPTUxpc3RlbmVycygxKTtcbiAgICAgIGlzQmxvY2tlZCA9IHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChpc0Jsb2NrZWQpIHtcbiAgICAgICAgaXNCbG9ja2VkID0gZmFsc2U7XG4gICAgICAgIGNoZWNrRE9NTGlzdGVuZXJzKC0xKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHVuYmxvY2soKTtcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gbGlzdGVuKGxpc3RlbmVyKSB7XG4gICAgdmFyIHVubGlzdGVuID0gdHJhbnNpdGlvbk1hbmFnZXIuYXBwZW5kTGlzdGVuZXIobGlzdGVuZXIpO1xuICAgIGNoZWNrRE9NTGlzdGVuZXJzKDEpO1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICBjaGVja0RPTUxpc3RlbmVycygtMSk7XG4gICAgICB1bmxpc3RlbigpO1xuICAgIH07XG4gIH1cblxuICB2YXIgaGlzdG9yeSA9IHtcbiAgICBsZW5ndGg6IGdsb2JhbEhpc3RvcnkubGVuZ3RoLFxuICAgIGFjdGlvbjogJ1BPUCcsXG4gICAgbG9jYXRpb246IGluaXRpYWxMb2NhdGlvbixcbiAgICBjcmVhdGVIcmVmOiBjcmVhdGVIcmVmLFxuICAgIHB1c2g6IHB1c2gsXG4gICAgcmVwbGFjZTogcmVwbGFjZSxcbiAgICBnbzogZ28sXG4gICAgZ29CYWNrOiBnb0JhY2ssXG4gICAgZ29Gb3J3YXJkOiBnb0ZvcndhcmQsXG4gICAgYmxvY2s6IGJsb2NrLFxuICAgIGxpc3RlbjogbGlzdGVuXG4gIH07XG4gIHJldHVybiBoaXN0b3J5O1xufVxuXG52YXIgSGFzaENoYW5nZUV2ZW50JDEgPSAnaGFzaGNoYW5nZSc7XG52YXIgSGFzaFBhdGhDb2RlcnMgPSB7XG4gIGhhc2hiYW5nOiB7XG4gICAgZW5jb2RlUGF0aDogZnVuY3Rpb24gZW5jb2RlUGF0aChwYXRoKSB7XG4gICAgICByZXR1cm4gcGF0aC5jaGFyQXQoMCkgPT09ICchJyA/IHBhdGggOiAnIS8nICsgc3RyaXBMZWFkaW5nU2xhc2gocGF0aCk7XG4gICAgfSxcbiAgICBkZWNvZGVQYXRoOiBmdW5jdGlvbiBkZWNvZGVQYXRoKHBhdGgpIHtcbiAgICAgIHJldHVybiBwYXRoLmNoYXJBdCgwKSA9PT0gJyEnID8gcGF0aC5zdWJzdHIoMSkgOiBwYXRoO1xuICAgIH1cbiAgfSxcbiAgbm9zbGFzaDoge1xuICAgIGVuY29kZVBhdGg6IHN0cmlwTGVhZGluZ1NsYXNoLFxuICAgIGRlY29kZVBhdGg6IGFkZExlYWRpbmdTbGFzaFxuICB9LFxuICBzbGFzaDoge1xuICAgIGVuY29kZVBhdGg6IGFkZExlYWRpbmdTbGFzaCxcbiAgICBkZWNvZGVQYXRoOiBhZGRMZWFkaW5nU2xhc2hcbiAgfVxufTtcblxuZnVuY3Rpb24gc3RyaXBIYXNoKHVybCkge1xuICB2YXIgaGFzaEluZGV4ID0gdXJsLmluZGV4T2YoJyMnKTtcbiAgcmV0dXJuIGhhc2hJbmRleCA9PT0gLTEgPyB1cmwgOiB1cmwuc2xpY2UoMCwgaGFzaEluZGV4KTtcbn1cblxuZnVuY3Rpb24gZ2V0SGFzaFBhdGgoKSB7XG4gIC8vIFdlIGNhbid0IHVzZSB3aW5kb3cubG9jYXRpb24uaGFzaCBoZXJlIGJlY2F1c2UgaXQncyBub3RcbiAgLy8gY29uc2lzdGVudCBhY3Jvc3MgYnJvd3NlcnMgLSBGaXJlZm94IHdpbGwgcHJlLWRlY29kZSBpdCFcbiAgdmFyIGhyZWYgPSB3aW5kb3cubG9jYXRpb24uaHJlZjtcbiAgdmFyIGhhc2hJbmRleCA9IGhyZWYuaW5kZXhPZignIycpO1xuICByZXR1cm4gaGFzaEluZGV4ID09PSAtMSA/ICcnIDogaHJlZi5zdWJzdHJpbmcoaGFzaEluZGV4ICsgMSk7XG59XG5cbmZ1bmN0aW9uIHB1c2hIYXNoUGF0aChwYXRoKSB7XG4gIHdpbmRvdy5sb2NhdGlvbi5oYXNoID0gcGF0aDtcbn1cblxuZnVuY3Rpb24gcmVwbGFjZUhhc2hQYXRoKHBhdGgpIHtcbiAgd2luZG93LmxvY2F0aW9uLnJlcGxhY2Uoc3RyaXBIYXNoKHdpbmRvdy5sb2NhdGlvbi5ocmVmKSArICcjJyArIHBhdGgpO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVIYXNoSGlzdG9yeShwcm9wcykge1xuICBpZiAocHJvcHMgPT09IHZvaWQgMCkge1xuICAgIHByb3BzID0ge307XG4gIH1cblxuICAhY2FuVXNlRE9NID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnSGFzaCBoaXN0b3J5IG5lZWRzIGEgRE9NJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICB2YXIgZ2xvYmFsSGlzdG9yeSA9IHdpbmRvdy5oaXN0b3J5O1xuICB2YXIgY2FuR29XaXRob3V0UmVsb2FkID0gc3VwcG9ydHNHb1dpdGhvdXRSZWxvYWRVc2luZ0hhc2goKTtcbiAgdmFyIF9wcm9wcyA9IHByb3BzLFxuICAgICAgX3Byb3BzJGdldFVzZXJDb25maXJtID0gX3Byb3BzLmdldFVzZXJDb25maXJtYXRpb24sXG4gICAgICBnZXRVc2VyQ29uZmlybWF0aW9uID0gX3Byb3BzJGdldFVzZXJDb25maXJtID09PSB2b2lkIDAgPyBnZXRDb25maXJtYXRpb24gOiBfcHJvcHMkZ2V0VXNlckNvbmZpcm0sXG4gICAgICBfcHJvcHMkaGFzaFR5cGUgPSBfcHJvcHMuaGFzaFR5cGUsXG4gICAgICBoYXNoVHlwZSA9IF9wcm9wcyRoYXNoVHlwZSA9PT0gdm9pZCAwID8gJ3NsYXNoJyA6IF9wcm9wcyRoYXNoVHlwZTtcbiAgdmFyIGJhc2VuYW1lID0gcHJvcHMuYmFzZW5hbWUgPyBzdHJpcFRyYWlsaW5nU2xhc2goYWRkTGVhZGluZ1NsYXNoKHByb3BzLmJhc2VuYW1lKSkgOiAnJztcbiAgdmFyIF9IYXNoUGF0aENvZGVycyRoYXNoVCA9IEhhc2hQYXRoQ29kZXJzW2hhc2hUeXBlXSxcbiAgICAgIGVuY29kZVBhdGggPSBfSGFzaFBhdGhDb2RlcnMkaGFzaFQuZW5jb2RlUGF0aCxcbiAgICAgIGRlY29kZVBhdGggPSBfSGFzaFBhdGhDb2RlcnMkaGFzaFQuZGVjb2RlUGF0aDtcblxuICBmdW5jdGlvbiBnZXRET01Mb2NhdGlvbigpIHtcbiAgICB2YXIgcGF0aCA9IGRlY29kZVBhdGgoZ2V0SGFzaFBhdGgoKSk7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gd2FybmluZyghYmFzZW5hbWUgfHwgaGFzQmFzZW5hbWUocGF0aCwgYmFzZW5hbWUpLCAnWW91IGFyZSBhdHRlbXB0aW5nIHRvIHVzZSBhIGJhc2VuYW1lIG9uIGEgcGFnZSB3aG9zZSBVUkwgcGF0aCBkb2VzIG5vdCBiZWdpbiAnICsgJ3dpdGggdGhlIGJhc2VuYW1lLiBFeHBlY3RlZCBwYXRoIFwiJyArIHBhdGggKyAnXCIgdG8gYmVnaW4gd2l0aCBcIicgKyBiYXNlbmFtZSArICdcIi4nKSA6IHZvaWQgMDtcbiAgICBpZiAoYmFzZW5hbWUpIHBhdGggPSBzdHJpcEJhc2VuYW1lKHBhdGgsIGJhc2VuYW1lKTtcbiAgICByZXR1cm4gY3JlYXRlTG9jYXRpb24ocGF0aCk7XG4gIH1cblxuICB2YXIgdHJhbnNpdGlvbk1hbmFnZXIgPSBjcmVhdGVUcmFuc2l0aW9uTWFuYWdlcigpO1xuXG4gIGZ1bmN0aW9uIHNldFN0YXRlKG5leHRTdGF0ZSkge1xuICAgIF9leHRlbmRzKGhpc3RvcnksIG5leHRTdGF0ZSk7XG5cbiAgICBoaXN0b3J5Lmxlbmd0aCA9IGdsb2JhbEhpc3RvcnkubGVuZ3RoO1xuICAgIHRyYW5zaXRpb25NYW5hZ2VyLm5vdGlmeUxpc3RlbmVycyhoaXN0b3J5LmxvY2F0aW9uLCBoaXN0b3J5LmFjdGlvbik7XG4gIH1cblxuICB2YXIgZm9yY2VOZXh0UG9wID0gZmFsc2U7XG4gIHZhciBpZ25vcmVQYXRoID0gbnVsbDtcblxuICBmdW5jdGlvbiBsb2NhdGlvbnNBcmVFcXVhbCQkMShhLCBiKSB7XG4gICAgcmV0dXJuIGEucGF0aG5hbWUgPT09IGIucGF0aG5hbWUgJiYgYS5zZWFyY2ggPT09IGIuc2VhcmNoICYmIGEuaGFzaCA9PT0gYi5oYXNoO1xuICB9XG5cbiAgZnVuY3Rpb24gaGFuZGxlSGFzaENoYW5nZSgpIHtcbiAgICB2YXIgcGF0aCA9IGdldEhhc2hQYXRoKCk7XG4gICAgdmFyIGVuY29kZWRQYXRoID0gZW5jb2RlUGF0aChwYXRoKTtcblxuICAgIGlmIChwYXRoICE9PSBlbmNvZGVkUGF0aCkge1xuICAgICAgLy8gRW5zdXJlIHdlIGFsd2F5cyBoYXZlIGEgcHJvcGVybHktZW5jb2RlZCBoYXNoLlxuICAgICAgcmVwbGFjZUhhc2hQYXRoKGVuY29kZWRQYXRoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGxvY2F0aW9uID0gZ2V0RE9NTG9jYXRpb24oKTtcbiAgICAgIHZhciBwcmV2TG9jYXRpb24gPSBoaXN0b3J5LmxvY2F0aW9uO1xuICAgICAgaWYgKCFmb3JjZU5leHRQb3AgJiYgbG9jYXRpb25zQXJlRXF1YWwkJDEocHJldkxvY2F0aW9uLCBsb2NhdGlvbikpIHJldHVybjsgLy8gQSBoYXNoY2hhbmdlIGRvZXNuJ3QgYWx3YXlzID09IGxvY2F0aW9uIGNoYW5nZS5cblxuICAgICAgaWYgKGlnbm9yZVBhdGggPT09IGNyZWF0ZVBhdGgobG9jYXRpb24pKSByZXR1cm47IC8vIElnbm9yZSB0aGlzIGNoYW5nZTsgd2UgYWxyZWFkeSBzZXRTdGF0ZSBpbiBwdXNoL3JlcGxhY2UuXG5cbiAgICAgIGlnbm9yZVBhdGggPSBudWxsO1xuICAgICAgaGFuZGxlUG9wKGxvY2F0aW9uKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBoYW5kbGVQb3AobG9jYXRpb24pIHtcbiAgICBpZiAoZm9yY2VOZXh0UG9wKSB7XG4gICAgICBmb3JjZU5leHRQb3AgPSBmYWxzZTtcbiAgICAgIHNldFN0YXRlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBhY3Rpb24gPSAnUE9QJztcbiAgICAgIHRyYW5zaXRpb25NYW5hZ2VyLmNvbmZpcm1UcmFuc2l0aW9uVG8obG9jYXRpb24sIGFjdGlvbiwgZ2V0VXNlckNvbmZpcm1hdGlvbiwgZnVuY3Rpb24gKG9rKSB7XG4gICAgICAgIGlmIChvaykge1xuICAgICAgICAgIHNldFN0YXRlKHtcbiAgICAgICAgICAgIGFjdGlvbjogYWN0aW9uLFxuICAgICAgICAgICAgbG9jYXRpb246IGxvY2F0aW9uXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV2ZXJ0UG9wKGxvY2F0aW9uKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmV2ZXJ0UG9wKGZyb21Mb2NhdGlvbikge1xuICAgIHZhciB0b0xvY2F0aW9uID0gaGlzdG9yeS5sb2NhdGlvbjsgLy8gVE9ETzogV2UgY291bGQgcHJvYmFibHkgbWFrZSB0aGlzIG1vcmUgcmVsaWFibGUgYnlcbiAgICAvLyBrZWVwaW5nIGEgbGlzdCBvZiBwYXRocyB3ZSd2ZSBzZWVuIGluIHNlc3Npb25TdG9yYWdlLlxuICAgIC8vIEluc3RlYWQsIHdlIGp1c3QgZGVmYXVsdCB0byAwIGZvciBwYXRocyB3ZSBkb24ndCBrbm93LlxuXG4gICAgdmFyIHRvSW5kZXggPSBhbGxQYXRocy5sYXN0SW5kZXhPZihjcmVhdGVQYXRoKHRvTG9jYXRpb24pKTtcbiAgICBpZiAodG9JbmRleCA9PT0gLTEpIHRvSW5kZXggPSAwO1xuICAgIHZhciBmcm9tSW5kZXggPSBhbGxQYXRocy5sYXN0SW5kZXhPZihjcmVhdGVQYXRoKGZyb21Mb2NhdGlvbikpO1xuICAgIGlmIChmcm9tSW5kZXggPT09IC0xKSBmcm9tSW5kZXggPSAwO1xuICAgIHZhciBkZWx0YSA9IHRvSW5kZXggLSBmcm9tSW5kZXg7XG5cbiAgICBpZiAoZGVsdGEpIHtcbiAgICAgIGZvcmNlTmV4dFBvcCA9IHRydWU7XG4gICAgICBnbyhkZWx0YSk7XG4gICAgfVxuICB9IC8vIEVuc3VyZSB0aGUgaGFzaCBpcyBlbmNvZGVkIHByb3Blcmx5IGJlZm9yZSBkb2luZyBhbnl0aGluZyBlbHNlLlxuXG5cbiAgdmFyIHBhdGggPSBnZXRIYXNoUGF0aCgpO1xuICB2YXIgZW5jb2RlZFBhdGggPSBlbmNvZGVQYXRoKHBhdGgpO1xuICBpZiAocGF0aCAhPT0gZW5jb2RlZFBhdGgpIHJlcGxhY2VIYXNoUGF0aChlbmNvZGVkUGF0aCk7XG4gIHZhciBpbml0aWFsTG9jYXRpb24gPSBnZXRET01Mb2NhdGlvbigpO1xuICB2YXIgYWxsUGF0aHMgPSBbY3JlYXRlUGF0aChpbml0aWFsTG9jYXRpb24pXTsgLy8gUHVibGljIGludGVyZmFjZVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUhyZWYobG9jYXRpb24pIHtcbiAgICB2YXIgYmFzZVRhZyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ2Jhc2UnKTtcbiAgICB2YXIgaHJlZiA9ICcnO1xuXG4gICAgaWYgKGJhc2VUYWcgJiYgYmFzZVRhZy5nZXRBdHRyaWJ1dGUoJ2hyZWYnKSkge1xuICAgICAgaHJlZiA9IHN0cmlwSGFzaCh3aW5kb3cubG9jYXRpb24uaHJlZik7XG4gICAgfVxuXG4gICAgcmV0dXJuIGhyZWYgKyAnIycgKyBlbmNvZGVQYXRoKGJhc2VuYW1lICsgY3JlYXRlUGF0aChsb2NhdGlvbikpO1xuICB9XG5cbiAgZnVuY3Rpb24gcHVzaChwYXRoLCBzdGF0ZSkge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IHdhcm5pbmcoc3RhdGUgPT09IHVuZGVmaW5lZCwgJ0hhc2ggaGlzdG9yeSBjYW5ub3QgcHVzaCBzdGF0ZTsgaXQgaXMgaWdub3JlZCcpIDogdm9pZCAwO1xuICAgIHZhciBhY3Rpb24gPSAnUFVTSCc7XG4gICAgdmFyIGxvY2F0aW9uID0gY3JlYXRlTG9jYXRpb24ocGF0aCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGhpc3RvcnkubG9jYXRpb24pO1xuICAgIHRyYW5zaXRpb25NYW5hZ2VyLmNvbmZpcm1UcmFuc2l0aW9uVG8obG9jYXRpb24sIGFjdGlvbiwgZ2V0VXNlckNvbmZpcm1hdGlvbiwgZnVuY3Rpb24gKG9rKSB7XG4gICAgICBpZiAoIW9rKSByZXR1cm47XG4gICAgICB2YXIgcGF0aCA9IGNyZWF0ZVBhdGgobG9jYXRpb24pO1xuICAgICAgdmFyIGVuY29kZWRQYXRoID0gZW5jb2RlUGF0aChiYXNlbmFtZSArIHBhdGgpO1xuICAgICAgdmFyIGhhc2hDaGFuZ2VkID0gZ2V0SGFzaFBhdGgoKSAhPT0gZW5jb2RlZFBhdGg7XG5cbiAgICAgIGlmIChoYXNoQ2hhbmdlZCkge1xuICAgICAgICAvLyBXZSBjYW5ub3QgdGVsbCBpZiBhIGhhc2hjaGFuZ2Ugd2FzIGNhdXNlZCBieSBhIFBVU0gsIHNvIHdlJ2RcbiAgICAgICAgLy8gcmF0aGVyIHNldFN0YXRlIGhlcmUgYW5kIGlnbm9yZSB0aGUgaGFzaGNoYW5nZS4gVGhlIGNhdmVhdCBoZXJlXG4gICAgICAgIC8vIGlzIHRoYXQgb3RoZXIgaGFzaCBoaXN0b3JpZXMgaW4gdGhlIHBhZ2Ugd2lsbCBjb25zaWRlciBpdCBhIFBPUC5cbiAgICAgICAgaWdub3JlUGF0aCA9IHBhdGg7XG4gICAgICAgIHB1c2hIYXNoUGF0aChlbmNvZGVkUGF0aCk7XG4gICAgICAgIHZhciBwcmV2SW5kZXggPSBhbGxQYXRocy5sYXN0SW5kZXhPZihjcmVhdGVQYXRoKGhpc3RvcnkubG9jYXRpb24pKTtcbiAgICAgICAgdmFyIG5leHRQYXRocyA9IGFsbFBhdGhzLnNsaWNlKDAsIHByZXZJbmRleCArIDEpO1xuICAgICAgICBuZXh0UGF0aHMucHVzaChwYXRoKTtcbiAgICAgICAgYWxsUGF0aHMgPSBuZXh0UGF0aHM7XG4gICAgICAgIHNldFN0YXRlKHtcbiAgICAgICAgICBhY3Rpb246IGFjdGlvbixcbiAgICAgICAgICBsb2NhdGlvbjogbG9jYXRpb25cbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyB3YXJuaW5nKGZhbHNlLCAnSGFzaCBoaXN0b3J5IGNhbm5vdCBQVVNIIHRoZSBzYW1lIHBhdGg7IGEgbmV3IGVudHJ5IHdpbGwgbm90IGJlIGFkZGVkIHRvIHRoZSBoaXN0b3J5IHN0YWNrJykgOiB2b2lkIDA7XG4gICAgICAgIHNldFN0YXRlKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiByZXBsYWNlKHBhdGgsIHN0YXRlKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gd2FybmluZyhzdGF0ZSA9PT0gdW5kZWZpbmVkLCAnSGFzaCBoaXN0b3J5IGNhbm5vdCByZXBsYWNlIHN0YXRlOyBpdCBpcyBpZ25vcmVkJykgOiB2b2lkIDA7XG4gICAgdmFyIGFjdGlvbiA9ICdSRVBMQUNFJztcbiAgICB2YXIgbG9jYXRpb24gPSBjcmVhdGVMb2NhdGlvbihwYXRoLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgaGlzdG9yeS5sb2NhdGlvbik7XG4gICAgdHJhbnNpdGlvbk1hbmFnZXIuY29uZmlybVRyYW5zaXRpb25Ubyhsb2NhdGlvbiwgYWN0aW9uLCBnZXRVc2VyQ29uZmlybWF0aW9uLCBmdW5jdGlvbiAob2spIHtcbiAgICAgIGlmICghb2spIHJldHVybjtcbiAgICAgIHZhciBwYXRoID0gY3JlYXRlUGF0aChsb2NhdGlvbik7XG4gICAgICB2YXIgZW5jb2RlZFBhdGggPSBlbmNvZGVQYXRoKGJhc2VuYW1lICsgcGF0aCk7XG4gICAgICB2YXIgaGFzaENoYW5nZWQgPSBnZXRIYXNoUGF0aCgpICE9PSBlbmNvZGVkUGF0aDtcblxuICAgICAgaWYgKGhhc2hDaGFuZ2VkKSB7XG4gICAgICAgIC8vIFdlIGNhbm5vdCB0ZWxsIGlmIGEgaGFzaGNoYW5nZSB3YXMgY2F1c2VkIGJ5IGEgUkVQTEFDRSwgc28gd2UnZFxuICAgICAgICAvLyByYXRoZXIgc2V0U3RhdGUgaGVyZSBhbmQgaWdub3JlIHRoZSBoYXNoY2hhbmdlLiBUaGUgY2F2ZWF0IGhlcmVcbiAgICAgICAgLy8gaXMgdGhhdCBvdGhlciBoYXNoIGhpc3RvcmllcyBpbiB0aGUgcGFnZSB3aWxsIGNvbnNpZGVyIGl0IGEgUE9QLlxuICAgICAgICBpZ25vcmVQYXRoID0gcGF0aDtcbiAgICAgICAgcmVwbGFjZUhhc2hQYXRoKGVuY29kZWRQYXRoKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHByZXZJbmRleCA9IGFsbFBhdGhzLmluZGV4T2YoY3JlYXRlUGF0aChoaXN0b3J5LmxvY2F0aW9uKSk7XG4gICAgICBpZiAocHJldkluZGV4ICE9PSAtMSkgYWxsUGF0aHNbcHJldkluZGV4XSA9IHBhdGg7XG4gICAgICBzZXRTdGF0ZSh7XG4gICAgICAgIGFjdGlvbjogYWN0aW9uLFxuICAgICAgICBsb2NhdGlvbjogbG9jYXRpb25cbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gZ28obikge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IHdhcm5pbmcoY2FuR29XaXRob3V0UmVsb2FkLCAnSGFzaCBoaXN0b3J5IGdvKG4pIGNhdXNlcyBhIGZ1bGwgcGFnZSByZWxvYWQgaW4gdGhpcyBicm93c2VyJykgOiB2b2lkIDA7XG4gICAgZ2xvYmFsSGlzdG9yeS5nbyhuKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdvQmFjaygpIHtcbiAgICBnbygtMSk7XG4gIH1cblxuICBmdW5jdGlvbiBnb0ZvcndhcmQoKSB7XG4gICAgZ28oMSk7XG4gIH1cblxuICB2YXIgbGlzdGVuZXJDb3VudCA9IDA7XG5cbiAgZnVuY3Rpb24gY2hlY2tET01MaXN0ZW5lcnMoZGVsdGEpIHtcbiAgICBsaXN0ZW5lckNvdW50ICs9IGRlbHRhO1xuXG4gICAgaWYgKGxpc3RlbmVyQ291bnQgPT09IDEgJiYgZGVsdGEgPT09IDEpIHtcbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKEhhc2hDaGFuZ2VFdmVudCQxLCBoYW5kbGVIYXNoQ2hhbmdlKTtcbiAgICB9IGVsc2UgaWYgKGxpc3RlbmVyQ291bnQgPT09IDApIHtcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKEhhc2hDaGFuZ2VFdmVudCQxLCBoYW5kbGVIYXNoQ2hhbmdlKTtcbiAgICB9XG4gIH1cblxuICB2YXIgaXNCbG9ja2VkID0gZmFsc2U7XG5cbiAgZnVuY3Rpb24gYmxvY2socHJvbXB0KSB7XG4gICAgaWYgKHByb21wdCA9PT0gdm9pZCAwKSB7XG4gICAgICBwcm9tcHQgPSBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgdW5ibG9jayA9IHRyYW5zaXRpb25NYW5hZ2VyLnNldFByb21wdChwcm9tcHQpO1xuXG4gICAgaWYgKCFpc0Jsb2NrZWQpIHtcbiAgICAgIGNoZWNrRE9NTGlzdGVuZXJzKDEpO1xuICAgICAgaXNCbG9ja2VkID0gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKGlzQmxvY2tlZCkge1xuICAgICAgICBpc0Jsb2NrZWQgPSBmYWxzZTtcbiAgICAgICAgY2hlY2tET01MaXN0ZW5lcnMoLTEpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdW5ibG9jaygpO1xuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBsaXN0ZW4obGlzdGVuZXIpIHtcbiAgICB2YXIgdW5saXN0ZW4gPSB0cmFuc2l0aW9uTWFuYWdlci5hcHBlbmRMaXN0ZW5lcihsaXN0ZW5lcik7XG4gICAgY2hlY2tET01MaXN0ZW5lcnMoMSk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIGNoZWNrRE9NTGlzdGVuZXJzKC0xKTtcbiAgICAgIHVubGlzdGVuKCk7XG4gICAgfTtcbiAgfVxuXG4gIHZhciBoaXN0b3J5ID0ge1xuICAgIGxlbmd0aDogZ2xvYmFsSGlzdG9yeS5sZW5ndGgsXG4gICAgYWN0aW9uOiAnUE9QJyxcbiAgICBsb2NhdGlvbjogaW5pdGlhbExvY2F0aW9uLFxuICAgIGNyZWF0ZUhyZWY6IGNyZWF0ZUhyZWYsXG4gICAgcHVzaDogcHVzaCxcbiAgICByZXBsYWNlOiByZXBsYWNlLFxuICAgIGdvOiBnbyxcbiAgICBnb0JhY2s6IGdvQmFjayxcbiAgICBnb0ZvcndhcmQ6IGdvRm9yd2FyZCxcbiAgICBibG9jazogYmxvY2ssXG4gICAgbGlzdGVuOiBsaXN0ZW5cbiAgfTtcbiAgcmV0dXJuIGhpc3Rvcnk7XG59XG5cbmZ1bmN0aW9uIGNsYW1wKG4sIGxvd2VyQm91bmQsIHVwcGVyQm91bmQpIHtcbiAgcmV0dXJuIE1hdGgubWluKE1hdGgubWF4KG4sIGxvd2VyQm91bmQpLCB1cHBlckJvdW5kKTtcbn1cbi8qKlxuICogQ3JlYXRlcyBhIGhpc3Rvcnkgb2JqZWN0IHRoYXQgc3RvcmVzIGxvY2F0aW9ucyBpbiBtZW1vcnkuXG4gKi9cblxuXG5mdW5jdGlvbiBjcmVhdGVNZW1vcnlIaXN0b3J5KHByb3BzKSB7XG4gIGlmIChwcm9wcyA9PT0gdm9pZCAwKSB7XG4gICAgcHJvcHMgPSB7fTtcbiAgfVxuXG4gIHZhciBfcHJvcHMgPSBwcm9wcyxcbiAgICAgIGdldFVzZXJDb25maXJtYXRpb24gPSBfcHJvcHMuZ2V0VXNlckNvbmZpcm1hdGlvbixcbiAgICAgIF9wcm9wcyRpbml0aWFsRW50cmllcyA9IF9wcm9wcy5pbml0aWFsRW50cmllcyxcbiAgICAgIGluaXRpYWxFbnRyaWVzID0gX3Byb3BzJGluaXRpYWxFbnRyaWVzID09PSB2b2lkIDAgPyBbJy8nXSA6IF9wcm9wcyRpbml0aWFsRW50cmllcyxcbiAgICAgIF9wcm9wcyRpbml0aWFsSW5kZXggPSBfcHJvcHMuaW5pdGlhbEluZGV4LFxuICAgICAgaW5pdGlhbEluZGV4ID0gX3Byb3BzJGluaXRpYWxJbmRleCA9PT0gdm9pZCAwID8gMCA6IF9wcm9wcyRpbml0aWFsSW5kZXgsXG4gICAgICBfcHJvcHMka2V5TGVuZ3RoID0gX3Byb3BzLmtleUxlbmd0aCxcbiAgICAgIGtleUxlbmd0aCA9IF9wcm9wcyRrZXlMZW5ndGggPT09IHZvaWQgMCA/IDYgOiBfcHJvcHMka2V5TGVuZ3RoO1xuICB2YXIgdHJhbnNpdGlvbk1hbmFnZXIgPSBjcmVhdGVUcmFuc2l0aW9uTWFuYWdlcigpO1xuXG4gIGZ1bmN0aW9uIHNldFN0YXRlKG5leHRTdGF0ZSkge1xuICAgIF9leHRlbmRzKGhpc3RvcnksIG5leHRTdGF0ZSk7XG5cbiAgICBoaXN0b3J5Lmxlbmd0aCA9IGhpc3RvcnkuZW50cmllcy5sZW5ndGg7XG4gICAgdHJhbnNpdGlvbk1hbmFnZXIubm90aWZ5TGlzdGVuZXJzKGhpc3RvcnkubG9jYXRpb24sIGhpc3RvcnkuYWN0aW9uKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUtleSgpIHtcbiAgICByZXR1cm4gTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc3Vic3RyKDIsIGtleUxlbmd0aCk7XG4gIH1cblxuICB2YXIgaW5kZXggPSBjbGFtcChpbml0aWFsSW5kZXgsIDAsIGluaXRpYWxFbnRyaWVzLmxlbmd0aCAtIDEpO1xuICB2YXIgZW50cmllcyA9IGluaXRpYWxFbnRyaWVzLm1hcChmdW5jdGlvbiAoZW50cnkpIHtcbiAgICByZXR1cm4gdHlwZW9mIGVudHJ5ID09PSAnc3RyaW5nJyA/IGNyZWF0ZUxvY2F0aW9uKGVudHJ5LCB1bmRlZmluZWQsIGNyZWF0ZUtleSgpKSA6IGNyZWF0ZUxvY2F0aW9uKGVudHJ5LCB1bmRlZmluZWQsIGVudHJ5LmtleSB8fCBjcmVhdGVLZXkoKSk7XG4gIH0pOyAvLyBQdWJsaWMgaW50ZXJmYWNlXG5cbiAgdmFyIGNyZWF0ZUhyZWYgPSBjcmVhdGVQYXRoO1xuXG4gIGZ1bmN0aW9uIHB1c2gocGF0aCwgc3RhdGUpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyB3YXJuaW5nKCEodHlwZW9mIHBhdGggPT09ICdvYmplY3QnICYmIHBhdGguc3RhdGUgIT09IHVuZGVmaW5lZCAmJiBzdGF0ZSAhPT0gdW5kZWZpbmVkKSwgJ1lvdSBzaG91bGQgYXZvaWQgcHJvdmlkaW5nIGEgMm5kIHN0YXRlIGFyZ3VtZW50IHRvIHB1c2ggd2hlbiB0aGUgMXN0ICcgKyAnYXJndW1lbnQgaXMgYSBsb2NhdGlvbi1saWtlIG9iamVjdCB0aGF0IGFscmVhZHkgaGFzIHN0YXRlOyBpdCBpcyBpZ25vcmVkJykgOiB2b2lkIDA7XG4gICAgdmFyIGFjdGlvbiA9ICdQVVNIJztcbiAgICB2YXIgbG9jYXRpb24gPSBjcmVhdGVMb2NhdGlvbihwYXRoLCBzdGF0ZSwgY3JlYXRlS2V5KCksIGhpc3RvcnkubG9jYXRpb24pO1xuICAgIHRyYW5zaXRpb25NYW5hZ2VyLmNvbmZpcm1UcmFuc2l0aW9uVG8obG9jYXRpb24sIGFjdGlvbiwgZ2V0VXNlckNvbmZpcm1hdGlvbiwgZnVuY3Rpb24gKG9rKSB7XG4gICAgICBpZiAoIW9rKSByZXR1cm47XG4gICAgICB2YXIgcHJldkluZGV4ID0gaGlzdG9yeS5pbmRleDtcbiAgICAgIHZhciBuZXh0SW5kZXggPSBwcmV2SW5kZXggKyAxO1xuICAgICAgdmFyIG5leHRFbnRyaWVzID0gaGlzdG9yeS5lbnRyaWVzLnNsaWNlKDApO1xuXG4gICAgICBpZiAobmV4dEVudHJpZXMubGVuZ3RoID4gbmV4dEluZGV4KSB7XG4gICAgICAgIG5leHRFbnRyaWVzLnNwbGljZShuZXh0SW5kZXgsIG5leHRFbnRyaWVzLmxlbmd0aCAtIG5leHRJbmRleCwgbG9jYXRpb24pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbmV4dEVudHJpZXMucHVzaChsb2NhdGlvbik7XG4gICAgICB9XG5cbiAgICAgIHNldFN0YXRlKHtcbiAgICAgICAgYWN0aW9uOiBhY3Rpb24sXG4gICAgICAgIGxvY2F0aW9uOiBsb2NhdGlvbixcbiAgICAgICAgaW5kZXg6IG5leHRJbmRleCxcbiAgICAgICAgZW50cmllczogbmV4dEVudHJpZXNcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVwbGFjZShwYXRoLCBzdGF0ZSkge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IHdhcm5pbmcoISh0eXBlb2YgcGF0aCA9PT0gJ29iamVjdCcgJiYgcGF0aC5zdGF0ZSAhPT0gdW5kZWZpbmVkICYmIHN0YXRlICE9PSB1bmRlZmluZWQpLCAnWW91IHNob3VsZCBhdm9pZCBwcm92aWRpbmcgYSAybmQgc3RhdGUgYXJndW1lbnQgdG8gcmVwbGFjZSB3aGVuIHRoZSAxc3QgJyArICdhcmd1bWVudCBpcyBhIGxvY2F0aW9uLWxpa2Ugb2JqZWN0IHRoYXQgYWxyZWFkeSBoYXMgc3RhdGU7IGl0IGlzIGlnbm9yZWQnKSA6IHZvaWQgMDtcbiAgICB2YXIgYWN0aW9uID0gJ1JFUExBQ0UnO1xuICAgIHZhciBsb2NhdGlvbiA9IGNyZWF0ZUxvY2F0aW9uKHBhdGgsIHN0YXRlLCBjcmVhdGVLZXkoKSwgaGlzdG9yeS5sb2NhdGlvbik7XG4gICAgdHJhbnNpdGlvbk1hbmFnZXIuY29uZmlybVRyYW5zaXRpb25Ubyhsb2NhdGlvbiwgYWN0aW9uLCBnZXRVc2VyQ29uZmlybWF0aW9uLCBmdW5jdGlvbiAob2spIHtcbiAgICAgIGlmICghb2spIHJldHVybjtcbiAgICAgIGhpc3RvcnkuZW50cmllc1toaXN0b3J5LmluZGV4XSA9IGxvY2F0aW9uO1xuICAgICAgc2V0U3RhdGUoe1xuICAgICAgICBhY3Rpb246IGFjdGlvbixcbiAgICAgICAgbG9jYXRpb246IGxvY2F0aW9uXG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdvKG4pIHtcbiAgICB2YXIgbmV4dEluZGV4ID0gY2xhbXAoaGlzdG9yeS5pbmRleCArIG4sIDAsIGhpc3RvcnkuZW50cmllcy5sZW5ndGggLSAxKTtcbiAgICB2YXIgYWN0aW9uID0gJ1BPUCc7XG4gICAgdmFyIGxvY2F0aW9uID0gaGlzdG9yeS5lbnRyaWVzW25leHRJbmRleF07XG4gICAgdHJhbnNpdGlvbk1hbmFnZXIuY29uZmlybVRyYW5zaXRpb25Ubyhsb2NhdGlvbiwgYWN0aW9uLCBnZXRVc2VyQ29uZmlybWF0aW9uLCBmdW5jdGlvbiAob2spIHtcbiAgICAgIGlmIChvaykge1xuICAgICAgICBzZXRTdGF0ZSh7XG4gICAgICAgICAgYWN0aW9uOiBhY3Rpb24sXG4gICAgICAgICAgbG9jYXRpb246IGxvY2F0aW9uLFxuICAgICAgICAgIGluZGV4OiBuZXh0SW5kZXhcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBNaW1pYyB0aGUgYmVoYXZpb3Igb2YgRE9NIGhpc3RvcmllcyBieVxuICAgICAgICAvLyBjYXVzaW5nIGEgcmVuZGVyIGFmdGVyIGEgY2FuY2VsbGVkIFBPUC5cbiAgICAgICAgc2V0U3RhdGUoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdvQmFjaygpIHtcbiAgICBnbygtMSk7XG4gIH1cblxuICBmdW5jdGlvbiBnb0ZvcndhcmQoKSB7XG4gICAgZ28oMSk7XG4gIH1cblxuICBmdW5jdGlvbiBjYW5HbyhuKSB7XG4gICAgdmFyIG5leHRJbmRleCA9IGhpc3RvcnkuaW5kZXggKyBuO1xuICAgIHJldHVybiBuZXh0SW5kZXggPj0gMCAmJiBuZXh0SW5kZXggPCBoaXN0b3J5LmVudHJpZXMubGVuZ3RoO1xuICB9XG5cbiAgZnVuY3Rpb24gYmxvY2socHJvbXB0KSB7XG4gICAgaWYgKHByb21wdCA9PT0gdm9pZCAwKSB7XG4gICAgICBwcm9tcHQgPSBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJhbnNpdGlvbk1hbmFnZXIuc2V0UHJvbXB0KHByb21wdCk7XG4gIH1cblxuICBmdW5jdGlvbiBsaXN0ZW4obGlzdGVuZXIpIHtcbiAgICByZXR1cm4gdHJhbnNpdGlvbk1hbmFnZXIuYXBwZW5kTGlzdGVuZXIobGlzdGVuZXIpO1xuICB9XG5cbiAgdmFyIGhpc3RvcnkgPSB7XG4gICAgbGVuZ3RoOiBlbnRyaWVzLmxlbmd0aCxcbiAgICBhY3Rpb246ICdQT1AnLFxuICAgIGxvY2F0aW9uOiBlbnRyaWVzW2luZGV4XSxcbiAgICBpbmRleDogaW5kZXgsXG4gICAgZW50cmllczogZW50cmllcyxcbiAgICBjcmVhdGVIcmVmOiBjcmVhdGVIcmVmLFxuICAgIHB1c2g6IHB1c2gsXG4gICAgcmVwbGFjZTogcmVwbGFjZSxcbiAgICBnbzogZ28sXG4gICAgZ29CYWNrOiBnb0JhY2ssXG4gICAgZ29Gb3J3YXJkOiBnb0ZvcndhcmQsXG4gICAgY2FuR286IGNhbkdvLFxuICAgIGJsb2NrOiBibG9jayxcbiAgICBsaXN0ZW46IGxpc3RlblxuICB9O1xuICByZXR1cm4gaGlzdG9yeTtcbn1cblxuZXhwb3J0IHsgY3JlYXRlQnJvd3Nlckhpc3RvcnksIGNyZWF0ZUhhc2hIaXN0b3J5LCBjcmVhdGVNZW1vcnlIaXN0b3J5LCBjcmVhdGVMb2NhdGlvbiwgbG9jYXRpb25zQXJlRXF1YWwsIHBhcnNlUGF0aCwgY3JlYXRlUGF0aCB9O1xuIiwiaW1wb3J0IFJlYWN0LCB7IENvbXBvbmVudCB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCBfaW5oZXJpdHNMb29zZSBmcm9tICdAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9pbmhlcml0c0xvb3NlJztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgd2FybmluZyBmcm9tICd0aW55LXdhcm5pbmcnO1xuXG52YXIgTUFYX1NJR05FRF8zMV9CSVRfSU5UID0gMTA3Mzc0MTgyMztcbnZhciBjb21tb25qc0dsb2JhbCA9IHR5cGVvZiBnbG9iYWxUaGlzICE9PSAndW5kZWZpbmVkJyA/IGdsb2JhbFRoaXMgOiB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdyA6IHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnID8gZ2xvYmFsIDoge307XG5cbmZ1bmN0aW9uIGdldFVuaXF1ZUlkKCkge1xuICB2YXIga2V5ID0gJ19fZ2xvYmFsX3VuaXF1ZV9pZF9fJztcbiAgcmV0dXJuIGNvbW1vbmpzR2xvYmFsW2tleV0gPSAoY29tbW9uanNHbG9iYWxba2V5XSB8fCAwKSArIDE7XG59XG5cbmZ1bmN0aW9uIG9iamVjdElzKHgsIHkpIHtcbiAgaWYgKHggPT09IHkpIHtcbiAgICByZXR1cm4geCAhPT0gMCB8fCAxIC8geCA9PT0gMSAvIHk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHggIT09IHggJiYgeSAhPT0geTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVFdmVudEVtaXR0ZXIodmFsdWUpIHtcbiAgdmFyIGhhbmRsZXJzID0gW107XG4gIHJldHVybiB7XG4gICAgb246IGZ1bmN0aW9uIG9uKGhhbmRsZXIpIHtcbiAgICAgIGhhbmRsZXJzLnB1c2goaGFuZGxlcik7XG4gICAgfSxcbiAgICBvZmY6IGZ1bmN0aW9uIG9mZihoYW5kbGVyKSB7XG4gICAgICBoYW5kbGVycyA9IGhhbmRsZXJzLmZpbHRlcihmdW5jdGlvbiAoaCkge1xuICAgICAgICByZXR1cm4gaCAhPT0gaGFuZGxlcjtcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uIHNldChuZXdWYWx1ZSwgY2hhbmdlZEJpdHMpIHtcbiAgICAgIHZhbHVlID0gbmV3VmFsdWU7XG4gICAgICBoYW5kbGVycy5mb3JFYWNoKGZ1bmN0aW9uIChoYW5kbGVyKSB7XG4gICAgICAgIHJldHVybiBoYW5kbGVyKHZhbHVlLCBjaGFuZ2VkQml0cyk7XG4gICAgICB9KTtcbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIG9ubHlDaGlsZChjaGlsZHJlbikge1xuICByZXR1cm4gQXJyYXkuaXNBcnJheShjaGlsZHJlbikgPyBjaGlsZHJlblswXSA6IGNoaWxkcmVuO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVSZWFjdENvbnRleHQoZGVmYXVsdFZhbHVlLCBjYWxjdWxhdGVDaGFuZ2VkQml0cykge1xuICB2YXIgX1Byb3ZpZGVyJGNoaWxkQ29udGV4LCBfQ29uc3VtZXIkY29udGV4dFR5cGU7XG5cbiAgdmFyIGNvbnRleHRQcm9wID0gJ19fY3JlYXRlLXJlYWN0LWNvbnRleHQtJyArIGdldFVuaXF1ZUlkKCkgKyAnX18nO1xuXG4gIHZhciBQcm92aWRlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0NvbXBvbmVudCkge1xuICAgIF9pbmhlcml0c0xvb3NlKFByb3ZpZGVyLCBfQ29tcG9uZW50KTtcblxuICAgIGZ1bmN0aW9uIFByb3ZpZGVyKCkge1xuICAgICAgdmFyIF90aGlzO1xuXG4gICAgICBfdGhpcyA9IF9Db21wb25lbnQuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgX3RoaXMuZW1pdHRlciA9IGNyZWF0ZUV2ZW50RW1pdHRlcihfdGhpcy5wcm9wcy52YWx1ZSk7XG4gICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuXG4gICAgdmFyIF9wcm90byA9IFByb3ZpZGVyLnByb3RvdHlwZTtcblxuICAgIF9wcm90by5nZXRDaGlsZENvbnRleHQgPSBmdW5jdGlvbiBnZXRDaGlsZENvbnRleHQoKSB7XG4gICAgICB2YXIgX3JlZjtcblxuICAgICAgcmV0dXJuIF9yZWYgPSB7fSwgX3JlZltjb250ZXh0UHJvcF0gPSB0aGlzLmVtaXR0ZXIsIF9yZWY7XG4gICAgfTtcblxuICAgIF9wcm90by5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzID0gZnVuY3Rpb24gY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhuZXh0UHJvcHMpIHtcbiAgICAgIGlmICh0aGlzLnByb3BzLnZhbHVlICE9PSBuZXh0UHJvcHMudmFsdWUpIHtcbiAgICAgICAgdmFyIG9sZFZhbHVlID0gdGhpcy5wcm9wcy52YWx1ZTtcbiAgICAgICAgdmFyIG5ld1ZhbHVlID0gbmV4dFByb3BzLnZhbHVlO1xuICAgICAgICB2YXIgY2hhbmdlZEJpdHM7XG5cbiAgICAgICAgaWYgKG9iamVjdElzKG9sZFZhbHVlLCBuZXdWYWx1ZSkpIHtcbiAgICAgICAgICBjaGFuZ2VkQml0cyA9IDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY2hhbmdlZEJpdHMgPSB0eXBlb2YgY2FsY3VsYXRlQ2hhbmdlZEJpdHMgPT09ICdmdW5jdGlvbicgPyBjYWxjdWxhdGVDaGFuZ2VkQml0cyhvbGRWYWx1ZSwgbmV3VmFsdWUpIDogTUFYX1NJR05FRF8zMV9CSVRfSU5UO1xuXG4gICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgIHdhcm5pbmcoKGNoYW5nZWRCaXRzICYgTUFYX1NJR05FRF8zMV9CSVRfSU5UKSA9PT0gY2hhbmdlZEJpdHMsICdjYWxjdWxhdGVDaGFuZ2VkQml0czogRXhwZWN0ZWQgdGhlIHJldHVybiB2YWx1ZSB0byBiZSBhICcgKyAnMzEtYml0IGludGVnZXIuIEluc3RlYWQgcmVjZWl2ZWQ6ICcgKyBjaGFuZ2VkQml0cyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY2hhbmdlZEJpdHMgfD0gMDtcblxuICAgICAgICAgIGlmIChjaGFuZ2VkQml0cyAhPT0gMCkge1xuICAgICAgICAgICAgdGhpcy5lbWl0dGVyLnNldChuZXh0UHJvcHMudmFsdWUsIGNoYW5nZWRCaXRzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgX3Byb3RvLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICAgIHJldHVybiB0aGlzLnByb3BzLmNoaWxkcmVuO1xuICAgIH07XG5cbiAgICByZXR1cm4gUHJvdmlkZXI7XG4gIH0oQ29tcG9uZW50KTtcblxuICBQcm92aWRlci5jaGlsZENvbnRleHRUeXBlcyA9IChfUHJvdmlkZXIkY2hpbGRDb250ZXggPSB7fSwgX1Byb3ZpZGVyJGNoaWxkQ29udGV4W2NvbnRleHRQcm9wXSA9IFByb3BUeXBlcy5vYmplY3QuaXNSZXF1aXJlZCwgX1Byb3ZpZGVyJGNoaWxkQ29udGV4KTtcblxuICB2YXIgQ29uc3VtZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9Db21wb25lbnQyKSB7XG4gICAgX2luaGVyaXRzTG9vc2UoQ29uc3VtZXIsIF9Db21wb25lbnQyKTtcblxuICAgIGZ1bmN0aW9uIENvbnN1bWVyKCkge1xuICAgICAgdmFyIF90aGlzMjtcblxuICAgICAgX3RoaXMyID0gX0NvbXBvbmVudDIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgX3RoaXMyLnN0YXRlID0ge1xuICAgICAgICB2YWx1ZTogX3RoaXMyLmdldFZhbHVlKClcbiAgICAgIH07XG5cbiAgICAgIF90aGlzMi5vblVwZGF0ZSA9IGZ1bmN0aW9uIChuZXdWYWx1ZSwgY2hhbmdlZEJpdHMpIHtcbiAgICAgICAgdmFyIG9ic2VydmVkQml0cyA9IF90aGlzMi5vYnNlcnZlZEJpdHMgfCAwO1xuXG4gICAgICAgIGlmICgob2JzZXJ2ZWRCaXRzICYgY2hhbmdlZEJpdHMpICE9PSAwKSB7XG4gICAgICAgICAgX3RoaXMyLnNldFN0YXRlKHtcbiAgICAgICAgICAgIHZhbHVlOiBfdGhpczIuZ2V0VmFsdWUoKVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICByZXR1cm4gX3RoaXMyO1xuICAgIH1cblxuICAgIHZhciBfcHJvdG8yID0gQ29uc3VtZXIucHJvdG90eXBlO1xuXG4gICAgX3Byb3RvMi5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzID0gZnVuY3Rpb24gY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhuZXh0UHJvcHMpIHtcbiAgICAgIHZhciBvYnNlcnZlZEJpdHMgPSBuZXh0UHJvcHMub2JzZXJ2ZWRCaXRzO1xuICAgICAgdGhpcy5vYnNlcnZlZEJpdHMgPSBvYnNlcnZlZEJpdHMgPT09IHVuZGVmaW5lZCB8fCBvYnNlcnZlZEJpdHMgPT09IG51bGwgPyBNQVhfU0lHTkVEXzMxX0JJVF9JTlQgOiBvYnNlcnZlZEJpdHM7XG4gICAgfTtcblxuICAgIF9wcm90bzIuY29tcG9uZW50RGlkTW91bnQgPSBmdW5jdGlvbiBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICAgIGlmICh0aGlzLmNvbnRleHRbY29udGV4dFByb3BdKSB7XG4gICAgICAgIHRoaXMuY29udGV4dFtjb250ZXh0UHJvcF0ub24odGhpcy5vblVwZGF0ZSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBvYnNlcnZlZEJpdHMgPSB0aGlzLnByb3BzLm9ic2VydmVkQml0cztcbiAgICAgIHRoaXMub2JzZXJ2ZWRCaXRzID0gb2JzZXJ2ZWRCaXRzID09PSB1bmRlZmluZWQgfHwgb2JzZXJ2ZWRCaXRzID09PSBudWxsID8gTUFYX1NJR05FRF8zMV9CSVRfSU5UIDogb2JzZXJ2ZWRCaXRzO1xuICAgIH07XG5cbiAgICBfcHJvdG8yLmNvbXBvbmVudFdpbGxVbm1vdW50ID0gZnVuY3Rpb24gY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgICBpZiAodGhpcy5jb250ZXh0W2NvbnRleHRQcm9wXSkge1xuICAgICAgICB0aGlzLmNvbnRleHRbY29udGV4dFByb3BdLm9mZih0aGlzLm9uVXBkYXRlKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgX3Byb3RvMi5nZXRWYWx1ZSA9IGZ1bmN0aW9uIGdldFZhbHVlKCkge1xuICAgICAgaWYgKHRoaXMuY29udGV4dFtjb250ZXh0UHJvcF0pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29udGV4dFtjb250ZXh0UHJvcF0uZ2V0KCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZGVmYXVsdFZhbHVlO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBfcHJvdG8yLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICAgIHJldHVybiBvbmx5Q2hpbGQodGhpcy5wcm9wcy5jaGlsZHJlbikodGhpcy5zdGF0ZS52YWx1ZSk7XG4gICAgfTtcblxuICAgIHJldHVybiBDb25zdW1lcjtcbiAgfShDb21wb25lbnQpO1xuXG4gIENvbnN1bWVyLmNvbnRleHRUeXBlcyA9IChfQ29uc3VtZXIkY29udGV4dFR5cGUgPSB7fSwgX0NvbnN1bWVyJGNvbnRleHRUeXBlW2NvbnRleHRQcm9wXSA9IFByb3BUeXBlcy5vYmplY3QsIF9Db25zdW1lciRjb250ZXh0VHlwZSk7XG4gIHJldHVybiB7XG4gICAgUHJvdmlkZXI6IFByb3ZpZGVyLFxuICAgIENvbnN1bWVyOiBDb25zdW1lclxuICB9O1xufVxuXG52YXIgaW5kZXggPSBSZWFjdC5jcmVhdGVDb250ZXh0IHx8IGNyZWF0ZVJlYWN0Q29udGV4dDtcblxuZXhwb3J0IGRlZmF1bHQgaW5kZXg7XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShzb3VyY2UsIGV4Y2x1ZGVkKSB7XG4gIGlmIChzb3VyY2UgPT0gbnVsbCkgcmV0dXJuIHt9O1xuICB2YXIgdGFyZ2V0ID0ge307XG4gIHZhciBzb3VyY2VLZXlzID0gT2JqZWN0LmtleXMoc291cmNlKTtcbiAgdmFyIGtleSwgaTtcblxuICBmb3IgKGkgPSAwOyBpIDwgc291cmNlS2V5cy5sZW5ndGg7IGkrKykge1xuICAgIGtleSA9IHNvdXJjZUtleXNbaV07XG4gICAgaWYgKGV4Y2x1ZGVkLmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTtcbiAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn0iLCJpbXBvcnQgX2luaGVyaXRzTG9vc2UgZnJvbSAnQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vaW5oZXJpdHNMb29zZSc7XG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCB7IGNyZWF0ZU1lbW9yeUhpc3RvcnksIGNyZWF0ZUxvY2F0aW9uLCBsb2NhdGlvbnNBcmVFcXVhbCwgY3JlYXRlUGF0aCB9IGZyb20gJ2hpc3RvcnknO1xuaW1wb3J0IHdhcm5pbmcgZnJvbSAndGlueS13YXJuaW5nJztcbmltcG9ydCBjcmVhdGVDb250ZXh0IGZyb20gJ21pbmktY3JlYXRlLXJlYWN0LWNvbnRleHQnO1xuaW1wb3J0IGludmFyaWFudCBmcm9tICd0aW55LWludmFyaWFudCc7XG5pbXBvcnQgX2V4dGVuZHMgZnJvbSAnQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vZXh0ZW5kcyc7XG5pbXBvcnQgcGF0aFRvUmVnZXhwIGZyb20gJ3BhdGgtdG8tcmVnZXhwJztcbmltcG9ydCB7IGlzVmFsaWRFbGVtZW50VHlwZSB9IGZyb20gJ3JlYWN0LWlzJztcbmltcG9ydCBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZSBmcm9tICdAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlJztcbmltcG9ydCBob2lzdFN0YXRpY3MgZnJvbSAnaG9pc3Qtbm9uLXJlYWN0LXN0YXRpY3MnO1xuXG4vLyBUT0RPOiBSZXBsYWNlIHdpdGggUmVhY3QuY3JlYXRlQ29udGV4dCBvbmNlIHdlIGNhbiBhc3N1bWUgUmVhY3QgMTYrXG5cbnZhciBjcmVhdGVOYW1lZENvbnRleHQgPSBmdW5jdGlvbiBjcmVhdGVOYW1lZENvbnRleHQobmFtZSkge1xuICB2YXIgY29udGV4dCA9IGNyZWF0ZUNvbnRleHQoKTtcbiAgY29udGV4dC5kaXNwbGF5TmFtZSA9IG5hbWU7XG4gIHJldHVybiBjb250ZXh0O1xufTtcblxudmFyIGhpc3RvcnlDb250ZXh0ID0gLyojX19QVVJFX18qL2NyZWF0ZU5hbWVkQ29udGV4dChcIlJvdXRlci1IaXN0b3J5XCIpO1xuXG52YXIgY29udGV4dCA9IC8qI19fUFVSRV9fKi9jcmVhdGVOYW1lZENvbnRleHQoXCJSb3V0ZXJcIik7XG5cbi8qKlxuICogVGhlIHB1YmxpYyBBUEkgZm9yIHB1dHRpbmcgaGlzdG9yeSBvbiBjb250ZXh0LlxuICovXG5cbnZhciBSb3V0ZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9SZWFjdCRDb21wb25lbnQpIHtcbiAgX2luaGVyaXRzTG9vc2UoUm91dGVyLCBfUmVhY3QkQ29tcG9uZW50KTtcblxuICBSb3V0ZXIuY29tcHV0ZVJvb3RNYXRjaCA9IGZ1bmN0aW9uIGNvbXB1dGVSb290TWF0Y2gocGF0aG5hbWUpIHtcbiAgICByZXR1cm4ge1xuICAgICAgcGF0aDogXCIvXCIsXG4gICAgICB1cmw6IFwiL1wiLFxuICAgICAgcGFyYW1zOiB7fSxcbiAgICAgIGlzRXhhY3Q6IHBhdGhuYW1lID09PSBcIi9cIlxuICAgIH07XG4gIH07XG5cbiAgZnVuY3Rpb24gUm91dGVyKHByb3BzKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgX3RoaXMgPSBfUmVhY3QkQ29tcG9uZW50LmNhbGwodGhpcywgcHJvcHMpIHx8IHRoaXM7XG4gICAgX3RoaXMuc3RhdGUgPSB7XG4gICAgICBsb2NhdGlvbjogcHJvcHMuaGlzdG9yeS5sb2NhdGlvblxuICAgIH07IC8vIFRoaXMgaXMgYSBiaXQgb2YgYSBoYWNrLiBXZSBoYXZlIHRvIHN0YXJ0IGxpc3RlbmluZyBmb3IgbG9jYXRpb25cbiAgICAvLyBjaGFuZ2VzIGhlcmUgaW4gdGhlIGNvbnN0cnVjdG9yIGluIGNhc2UgdGhlcmUgYXJlIGFueSA8UmVkaXJlY3Q+c1xuICAgIC8vIG9uIHRoZSBpbml0aWFsIHJlbmRlci4gSWYgdGhlcmUgYXJlLCB0aGV5IHdpbGwgcmVwbGFjZS9wdXNoIHdoZW5cbiAgICAvLyB0aGV5IG1vdW50IGFuZCBzaW5jZSBjRE0gZmlyZXMgaW4gY2hpbGRyZW4gYmVmb3JlIHBhcmVudHMsIHdlIG1heVxuICAgIC8vIGdldCBhIG5ldyBsb2NhdGlvbiBiZWZvcmUgdGhlIDxSb3V0ZXI+IGlzIG1vdW50ZWQuXG5cbiAgICBfdGhpcy5faXNNb3VudGVkID0gZmFsc2U7XG4gICAgX3RoaXMuX3BlbmRpbmdMb2NhdGlvbiA9IG51bGw7XG5cbiAgICBpZiAoIXByb3BzLnN0YXRpY0NvbnRleHQpIHtcbiAgICAgIF90aGlzLnVubGlzdGVuID0gcHJvcHMuaGlzdG9yeS5saXN0ZW4oZnVuY3Rpb24gKGxvY2F0aW9uKSB7XG4gICAgICAgIGlmIChfdGhpcy5faXNNb3VudGVkKSB7XG4gICAgICAgICAgX3RoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgICAgbG9jYXRpb246IGxvY2F0aW9uXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgX3RoaXMuX3BlbmRpbmdMb2NhdGlvbiA9IGxvY2F0aW9uO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICB2YXIgX3Byb3RvID0gUm91dGVyLnByb3RvdHlwZTtcblxuICBfcHJvdG8uY29tcG9uZW50RGlkTW91bnQgPSBmdW5jdGlvbiBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICB0aGlzLl9pc01vdW50ZWQgPSB0cnVlO1xuXG4gICAgaWYgKHRoaXMuX3BlbmRpbmdMb2NhdGlvbikge1xuICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgIGxvY2F0aW9uOiB0aGlzLl9wZW5kaW5nTG9jYXRpb25cbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8uY29tcG9uZW50V2lsbFVubW91bnQgPSBmdW5jdGlvbiBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICBpZiAodGhpcy51bmxpc3Rlbikge1xuICAgICAgdGhpcy51bmxpc3RlbigpO1xuICAgICAgdGhpcy5faXNNb3VudGVkID0gZmFsc2U7XG4gICAgICB0aGlzLl9wZW5kaW5nTG9jYXRpb24gPSBudWxsO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8ucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChjb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgICB2YWx1ZToge1xuICAgICAgICBoaXN0b3J5OiB0aGlzLnByb3BzLmhpc3RvcnksXG4gICAgICAgIGxvY2F0aW9uOiB0aGlzLnN0YXRlLmxvY2F0aW9uLFxuICAgICAgICBtYXRjaDogUm91dGVyLmNvbXB1dGVSb290TWF0Y2godGhpcy5zdGF0ZS5sb2NhdGlvbi5wYXRobmFtZSksXG4gICAgICAgIHN0YXRpY0NvbnRleHQ6IHRoaXMucHJvcHMuc3RhdGljQ29udGV4dFxuICAgICAgfVxuICAgIH0sIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KGhpc3RvcnlDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgICBjaGlsZHJlbjogdGhpcy5wcm9wcy5jaGlsZHJlbiB8fCBudWxsLFxuICAgICAgdmFsdWU6IHRoaXMucHJvcHMuaGlzdG9yeVxuICAgIH0pKTtcbiAgfTtcblxuICByZXR1cm4gUm91dGVyO1xufShSZWFjdC5Db21wb25lbnQpO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gIFJvdXRlci5wcm9wVHlwZXMgPSB7XG4gICAgY2hpbGRyZW46IFByb3BUeXBlcy5ub2RlLFxuICAgIGhpc3Rvcnk6IFByb3BUeXBlcy5vYmplY3QuaXNSZXF1aXJlZCxcbiAgICBzdGF0aWNDb250ZXh0OiBQcm9wVHlwZXMub2JqZWN0XG4gIH07XG5cbiAgUm91dGVyLnByb3RvdHlwZS5jb21wb25lbnREaWRVcGRhdGUgPSBmdW5jdGlvbiAocHJldlByb3BzKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gd2FybmluZyhwcmV2UHJvcHMuaGlzdG9yeSA9PT0gdGhpcy5wcm9wcy5oaXN0b3J5LCBcIllvdSBjYW5ub3QgY2hhbmdlIDxSb3V0ZXIgaGlzdG9yeT5cIikgOiB2b2lkIDA7XG4gIH07XG59XG5cbi8qKlxuICogVGhlIHB1YmxpYyBBUEkgZm9yIGEgPFJvdXRlcj4gdGhhdCBzdG9yZXMgbG9jYXRpb24gaW4gbWVtb3J5LlxuICovXG5cbnZhciBNZW1vcnlSb3V0ZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9SZWFjdCRDb21wb25lbnQpIHtcbiAgX2luaGVyaXRzTG9vc2UoTWVtb3J5Um91dGVyLCBfUmVhY3QkQ29tcG9uZW50KTtcblxuICBmdW5jdGlvbiBNZW1vcnlSb3V0ZXIoKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIF90aGlzID0gX1JlYWN0JENvbXBvbmVudC5jYWxsLmFwcGx5KF9SZWFjdCRDb21wb25lbnQsIFt0aGlzXS5jb25jYXQoYXJncykpIHx8IHRoaXM7XG4gICAgX3RoaXMuaGlzdG9yeSA9IGNyZWF0ZU1lbW9yeUhpc3RvcnkoX3RoaXMucHJvcHMpO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBNZW1vcnlSb3V0ZXIucHJvdG90eXBlO1xuXG4gIF9wcm90by5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFJvdXRlciwge1xuICAgICAgaGlzdG9yeTogdGhpcy5oaXN0b3J5LFxuICAgICAgY2hpbGRyZW46IHRoaXMucHJvcHMuY2hpbGRyZW5cbiAgICB9KTtcbiAgfTtcblxuICByZXR1cm4gTWVtb3J5Um91dGVyO1xufShSZWFjdC5Db21wb25lbnQpO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gIE1lbW9yeVJvdXRlci5wcm9wVHlwZXMgPSB7XG4gICAgaW5pdGlhbEVudHJpZXM6IFByb3BUeXBlcy5hcnJheSxcbiAgICBpbml0aWFsSW5kZXg6IFByb3BUeXBlcy5udW1iZXIsXG4gICAgZ2V0VXNlckNvbmZpcm1hdGlvbjogUHJvcFR5cGVzLmZ1bmMsXG4gICAga2V5TGVuZ3RoOiBQcm9wVHlwZXMubnVtYmVyLFxuICAgIGNoaWxkcmVuOiBQcm9wVHlwZXMubm9kZVxuICB9O1xuXG4gIE1lbW9yeVJvdXRlci5wcm90b3R5cGUuY29tcG9uZW50RGlkTW91bnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gd2FybmluZyghdGhpcy5wcm9wcy5oaXN0b3J5LCBcIjxNZW1vcnlSb3V0ZXI+IGlnbm9yZXMgdGhlIGhpc3RvcnkgcHJvcC4gVG8gdXNlIGEgY3VzdG9tIGhpc3RvcnksIFwiICsgXCJ1c2UgYGltcG9ydCB7IFJvdXRlciB9YCBpbnN0ZWFkIG9mIGBpbXBvcnQgeyBNZW1vcnlSb3V0ZXIgYXMgUm91dGVyIH1gLlwiKSA6IHZvaWQgMDtcbiAgfTtcbn1cblxudmFyIExpZmVjeWNsZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX1JlYWN0JENvbXBvbmVudCkge1xuICBfaW5oZXJpdHNMb29zZShMaWZlY3ljbGUsIF9SZWFjdCRDb21wb25lbnQpO1xuXG4gIGZ1bmN0aW9uIExpZmVjeWNsZSgpIHtcbiAgICByZXR1cm4gX1JlYWN0JENvbXBvbmVudC5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gIH1cblxuICB2YXIgX3Byb3RvID0gTGlmZWN5Y2xlLnByb3RvdHlwZTtcblxuICBfcHJvdG8uY29tcG9uZW50RGlkTW91bnQgPSBmdW5jdGlvbiBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICBpZiAodGhpcy5wcm9wcy5vbk1vdW50KSB0aGlzLnByb3BzLm9uTW91bnQuY2FsbCh0aGlzLCB0aGlzKTtcbiAgfTtcblxuICBfcHJvdG8uY29tcG9uZW50RGlkVXBkYXRlID0gZnVuY3Rpb24gY29tcG9uZW50RGlkVXBkYXRlKHByZXZQcm9wcykge1xuICAgIGlmICh0aGlzLnByb3BzLm9uVXBkYXRlKSB0aGlzLnByb3BzLm9uVXBkYXRlLmNhbGwodGhpcywgdGhpcywgcHJldlByb3BzKTtcbiAgfTtcblxuICBfcHJvdG8uY29tcG9uZW50V2lsbFVubW91bnQgPSBmdW5jdGlvbiBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICBpZiAodGhpcy5wcm9wcy5vblVubW91bnQpIHRoaXMucHJvcHMub25Vbm1vdW50LmNhbGwodGhpcywgdGhpcyk7XG4gIH07XG5cbiAgX3Byb3RvLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfTtcblxuICByZXR1cm4gTGlmZWN5Y2xlO1xufShSZWFjdC5Db21wb25lbnQpO1xuXG4vKipcbiAqIFRoZSBwdWJsaWMgQVBJIGZvciBwcm9tcHRpbmcgdGhlIHVzZXIgYmVmb3JlIG5hdmlnYXRpbmcgYXdheSBmcm9tIGEgc2NyZWVuLlxuICovXG5cbmZ1bmN0aW9uIFByb21wdChfcmVmKSB7XG4gIHZhciBtZXNzYWdlID0gX3JlZi5tZXNzYWdlLFxuICAgICAgX3JlZiR3aGVuID0gX3JlZi53aGVuLFxuICAgICAgd2hlbiA9IF9yZWYkd2hlbiA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9yZWYkd2hlbjtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KGNvbnRleHQuQ29uc3VtZXIsIG51bGwsIGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgIWNvbnRleHQgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsIFwiWW91IHNob3VsZCBub3QgdXNlIDxQcm9tcHQ+IG91dHNpZGUgYSA8Um91dGVyPlwiKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gICAgaWYgKCF3aGVuIHx8IGNvbnRleHQuc3RhdGljQ29udGV4dCkgcmV0dXJuIG51bGw7XG4gICAgdmFyIG1ldGhvZCA9IGNvbnRleHQuaGlzdG9yeS5ibG9jaztcbiAgICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoTGlmZWN5Y2xlLCB7XG4gICAgICBvbk1vdW50OiBmdW5jdGlvbiBvbk1vdW50KHNlbGYpIHtcbiAgICAgICAgc2VsZi5yZWxlYXNlID0gbWV0aG9kKG1lc3NhZ2UpO1xuICAgICAgfSxcbiAgICAgIG9uVXBkYXRlOiBmdW5jdGlvbiBvblVwZGF0ZShzZWxmLCBwcmV2UHJvcHMpIHtcbiAgICAgICAgaWYgKHByZXZQcm9wcy5tZXNzYWdlICE9PSBtZXNzYWdlKSB7XG4gICAgICAgICAgc2VsZi5yZWxlYXNlKCk7XG4gICAgICAgICAgc2VsZi5yZWxlYXNlID0gbWV0aG9kKG1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgb25Vbm1vdW50OiBmdW5jdGlvbiBvblVubW91bnQoc2VsZikge1xuICAgICAgICBzZWxmLnJlbGVhc2UoKTtcbiAgICAgIH0sXG4gICAgICBtZXNzYWdlOiBtZXNzYWdlXG4gICAgfSk7XG4gIH0pO1xufVxuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gIHZhciBtZXNzYWdlVHlwZSA9IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5mdW5jLCBQcm9wVHlwZXMuc3RyaW5nXSk7XG4gIFByb21wdC5wcm9wVHlwZXMgPSB7XG4gICAgd2hlbjogUHJvcFR5cGVzLmJvb2wsXG4gICAgbWVzc2FnZTogbWVzc2FnZVR5cGUuaXNSZXF1aXJlZFxuICB9O1xufVxuXG52YXIgY2FjaGUgPSB7fTtcbnZhciBjYWNoZUxpbWl0ID0gMTAwMDA7XG52YXIgY2FjaGVDb3VudCA9IDA7XG5cbmZ1bmN0aW9uIGNvbXBpbGVQYXRoKHBhdGgpIHtcbiAgaWYgKGNhY2hlW3BhdGhdKSByZXR1cm4gY2FjaGVbcGF0aF07XG4gIHZhciBnZW5lcmF0b3IgPSBwYXRoVG9SZWdleHAuY29tcGlsZShwYXRoKTtcblxuICBpZiAoY2FjaGVDb3VudCA8IGNhY2hlTGltaXQpIHtcbiAgICBjYWNoZVtwYXRoXSA9IGdlbmVyYXRvcjtcbiAgICBjYWNoZUNvdW50Kys7XG4gIH1cblxuICByZXR1cm4gZ2VuZXJhdG9yO1xufVxuLyoqXG4gKiBQdWJsaWMgQVBJIGZvciBnZW5lcmF0aW5nIGEgVVJMIHBhdGhuYW1lIGZyb20gYSBwYXRoIGFuZCBwYXJhbWV0ZXJzLlxuICovXG5cblxuZnVuY3Rpb24gZ2VuZXJhdGVQYXRoKHBhdGgsIHBhcmFtcykge1xuICBpZiAocGF0aCA9PT0gdm9pZCAwKSB7XG4gICAgcGF0aCA9IFwiL1wiO1xuICB9XG5cbiAgaWYgKHBhcmFtcyA9PT0gdm9pZCAwKSB7XG4gICAgcGFyYW1zID0ge307XG4gIH1cblxuICByZXR1cm4gcGF0aCA9PT0gXCIvXCIgPyBwYXRoIDogY29tcGlsZVBhdGgocGF0aCkocGFyYW1zLCB7XG4gICAgcHJldHR5OiB0cnVlXG4gIH0pO1xufVxuXG4vKipcbiAqIFRoZSBwdWJsaWMgQVBJIGZvciBuYXZpZ2F0aW5nIHByb2dyYW1tYXRpY2FsbHkgd2l0aCBhIGNvbXBvbmVudC5cbiAqL1xuXG5mdW5jdGlvbiBSZWRpcmVjdChfcmVmKSB7XG4gIHZhciBjb21wdXRlZE1hdGNoID0gX3JlZi5jb21wdXRlZE1hdGNoLFxuICAgICAgdG8gPSBfcmVmLnRvLFxuICAgICAgX3JlZiRwdXNoID0gX3JlZi5wdXNoLFxuICAgICAgcHVzaCA9IF9yZWYkcHVzaCA9PT0gdm9pZCAwID8gZmFsc2UgOiBfcmVmJHB1c2g7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChjb250ZXh0LkNvbnN1bWVyLCBudWxsLCBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgICFjb250ZXh0ID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCBcIllvdSBzaG91bGQgbm90IHVzZSA8UmVkaXJlY3Q+IG91dHNpZGUgYSA8Um91dGVyPlwiKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gICAgdmFyIGhpc3RvcnkgPSBjb250ZXh0Lmhpc3RvcnksXG4gICAgICAgIHN0YXRpY0NvbnRleHQgPSBjb250ZXh0LnN0YXRpY0NvbnRleHQ7XG4gICAgdmFyIG1ldGhvZCA9IHB1c2ggPyBoaXN0b3J5LnB1c2ggOiBoaXN0b3J5LnJlcGxhY2U7XG4gICAgdmFyIGxvY2F0aW9uID0gY3JlYXRlTG9jYXRpb24oY29tcHV0ZWRNYXRjaCA/IHR5cGVvZiB0byA9PT0gXCJzdHJpbmdcIiA/IGdlbmVyYXRlUGF0aCh0bywgY29tcHV0ZWRNYXRjaC5wYXJhbXMpIDogX2V4dGVuZHMoe30sIHRvLCB7XG4gICAgICBwYXRobmFtZTogZ2VuZXJhdGVQYXRoKHRvLnBhdGhuYW1lLCBjb21wdXRlZE1hdGNoLnBhcmFtcylcbiAgICB9KSA6IHRvKTsgLy8gV2hlbiByZW5kZXJpbmcgaW4gYSBzdGF0aWMgY29udGV4dCxcbiAgICAvLyBzZXQgdGhlIG5ldyBsb2NhdGlvbiBpbW1lZGlhdGVseS5cblxuICAgIGlmIChzdGF0aWNDb250ZXh0KSB7XG4gICAgICBtZXRob2QobG9jYXRpb24pO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KExpZmVjeWNsZSwge1xuICAgICAgb25Nb3VudDogZnVuY3Rpb24gb25Nb3VudCgpIHtcbiAgICAgICAgbWV0aG9kKGxvY2F0aW9uKTtcbiAgICAgIH0sXG4gICAgICBvblVwZGF0ZTogZnVuY3Rpb24gb25VcGRhdGUoc2VsZiwgcHJldlByb3BzKSB7XG4gICAgICAgIHZhciBwcmV2TG9jYXRpb24gPSBjcmVhdGVMb2NhdGlvbihwcmV2UHJvcHMudG8pO1xuXG4gICAgICAgIGlmICghbG9jYXRpb25zQXJlRXF1YWwocHJldkxvY2F0aW9uLCBfZXh0ZW5kcyh7fSwgbG9jYXRpb24sIHtcbiAgICAgICAgICBrZXk6IHByZXZMb2NhdGlvbi5rZXlcbiAgICAgICAgfSkpKSB7XG4gICAgICAgICAgbWV0aG9kKGxvY2F0aW9uKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHRvOiB0b1xuICAgIH0pO1xuICB9KTtcbn1cblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICBSZWRpcmVjdC5wcm9wVHlwZXMgPSB7XG4gICAgcHVzaDogUHJvcFR5cGVzLmJvb2wsXG4gICAgZnJvbTogUHJvcFR5cGVzLnN0cmluZyxcbiAgICB0bzogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLnN0cmluZywgUHJvcFR5cGVzLm9iamVjdF0pLmlzUmVxdWlyZWRcbiAgfTtcbn1cblxudmFyIGNhY2hlJDEgPSB7fTtcbnZhciBjYWNoZUxpbWl0JDEgPSAxMDAwMDtcbnZhciBjYWNoZUNvdW50JDEgPSAwO1xuXG5mdW5jdGlvbiBjb21waWxlUGF0aCQxKHBhdGgsIG9wdGlvbnMpIHtcbiAgdmFyIGNhY2hlS2V5ID0gXCJcIiArIG9wdGlvbnMuZW5kICsgb3B0aW9ucy5zdHJpY3QgKyBvcHRpb25zLnNlbnNpdGl2ZTtcbiAgdmFyIHBhdGhDYWNoZSA9IGNhY2hlJDFbY2FjaGVLZXldIHx8IChjYWNoZSQxW2NhY2hlS2V5XSA9IHt9KTtcbiAgaWYgKHBhdGhDYWNoZVtwYXRoXSkgcmV0dXJuIHBhdGhDYWNoZVtwYXRoXTtcbiAgdmFyIGtleXMgPSBbXTtcbiAgdmFyIHJlZ2V4cCA9IHBhdGhUb1JlZ2V4cChwYXRoLCBrZXlzLCBvcHRpb25zKTtcbiAgdmFyIHJlc3VsdCA9IHtcbiAgICByZWdleHA6IHJlZ2V4cCxcbiAgICBrZXlzOiBrZXlzXG4gIH07XG5cbiAgaWYgKGNhY2hlQ291bnQkMSA8IGNhY2hlTGltaXQkMSkge1xuICAgIHBhdGhDYWNoZVtwYXRoXSA9IHJlc3VsdDtcbiAgICBjYWNoZUNvdW50JDErKztcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG4vKipcbiAqIFB1YmxpYyBBUEkgZm9yIG1hdGNoaW5nIGEgVVJMIHBhdGhuYW1lIHRvIGEgcGF0aC5cbiAqL1xuXG5cbmZ1bmN0aW9uIG1hdGNoUGF0aChwYXRobmFtZSwgb3B0aW9ucykge1xuICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG5cbiAgaWYgKHR5cGVvZiBvcHRpb25zID09PSBcInN0cmluZ1wiIHx8IEFycmF5LmlzQXJyYXkob3B0aW9ucykpIHtcbiAgICBvcHRpb25zID0ge1xuICAgICAgcGF0aDogb3B0aW9uc1xuICAgIH07XG4gIH1cblxuICB2YXIgX29wdGlvbnMgPSBvcHRpb25zLFxuICAgICAgcGF0aCA9IF9vcHRpb25zLnBhdGgsXG4gICAgICBfb3B0aW9ucyRleGFjdCA9IF9vcHRpb25zLmV4YWN0LFxuICAgICAgZXhhY3QgPSBfb3B0aW9ucyRleGFjdCA9PT0gdm9pZCAwID8gZmFsc2UgOiBfb3B0aW9ucyRleGFjdCxcbiAgICAgIF9vcHRpb25zJHN0cmljdCA9IF9vcHRpb25zLnN0cmljdCxcbiAgICAgIHN0cmljdCA9IF9vcHRpb25zJHN0cmljdCA9PT0gdm9pZCAwID8gZmFsc2UgOiBfb3B0aW9ucyRzdHJpY3QsXG4gICAgICBfb3B0aW9ucyRzZW5zaXRpdmUgPSBfb3B0aW9ucy5zZW5zaXRpdmUsXG4gICAgICBzZW5zaXRpdmUgPSBfb3B0aW9ucyRzZW5zaXRpdmUgPT09IHZvaWQgMCA/IGZhbHNlIDogX29wdGlvbnMkc2Vuc2l0aXZlO1xuICB2YXIgcGF0aHMgPSBbXS5jb25jYXQocGF0aCk7XG4gIHJldHVybiBwYXRocy5yZWR1Y2UoZnVuY3Rpb24gKG1hdGNoZWQsIHBhdGgpIHtcbiAgICBpZiAoIXBhdGggJiYgcGF0aCAhPT0gXCJcIikgcmV0dXJuIG51bGw7XG4gICAgaWYgKG1hdGNoZWQpIHJldHVybiBtYXRjaGVkO1xuXG4gICAgdmFyIF9jb21waWxlUGF0aCA9IGNvbXBpbGVQYXRoJDEocGF0aCwge1xuICAgICAgZW5kOiBleGFjdCxcbiAgICAgIHN0cmljdDogc3RyaWN0LFxuICAgICAgc2Vuc2l0aXZlOiBzZW5zaXRpdmVcbiAgICB9KSxcbiAgICAgICAgcmVnZXhwID0gX2NvbXBpbGVQYXRoLnJlZ2V4cCxcbiAgICAgICAga2V5cyA9IF9jb21waWxlUGF0aC5rZXlzO1xuXG4gICAgdmFyIG1hdGNoID0gcmVnZXhwLmV4ZWMocGF0aG5hbWUpO1xuICAgIGlmICghbWF0Y2gpIHJldHVybiBudWxsO1xuICAgIHZhciB1cmwgPSBtYXRjaFswXSxcbiAgICAgICAgdmFsdWVzID0gbWF0Y2guc2xpY2UoMSk7XG4gICAgdmFyIGlzRXhhY3QgPSBwYXRobmFtZSA9PT0gdXJsO1xuICAgIGlmIChleGFjdCAmJiAhaXNFeGFjdCkgcmV0dXJuIG51bGw7XG4gICAgcmV0dXJuIHtcbiAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAvLyB0aGUgcGF0aCB1c2VkIHRvIG1hdGNoXG4gICAgICB1cmw6IHBhdGggPT09IFwiL1wiICYmIHVybCA9PT0gXCJcIiA/IFwiL1wiIDogdXJsLFxuICAgICAgLy8gdGhlIG1hdGNoZWQgcG9ydGlvbiBvZiB0aGUgVVJMXG4gICAgICBpc0V4YWN0OiBpc0V4YWN0LFxuICAgICAgLy8gd2hldGhlciBvciBub3Qgd2UgbWF0Y2hlZCBleGFjdGx5XG4gICAgICBwYXJhbXM6IGtleXMucmVkdWNlKGZ1bmN0aW9uIChtZW1vLCBrZXksIGluZGV4KSB7XG4gICAgICAgIG1lbW9ba2V5Lm5hbWVdID0gdmFsdWVzW2luZGV4XTtcbiAgICAgICAgcmV0dXJuIG1lbW87XG4gICAgICB9LCB7fSlcbiAgICB9O1xuICB9LCBudWxsKTtcbn1cblxuZnVuY3Rpb24gaXNFbXB0eUNoaWxkcmVuKGNoaWxkcmVuKSB7XG4gIHJldHVybiBSZWFjdC5DaGlsZHJlbi5jb3VudChjaGlsZHJlbikgPT09IDA7XG59XG5cbmZ1bmN0aW9uIGV2YWxDaGlsZHJlbkRldihjaGlsZHJlbiwgcHJvcHMsIHBhdGgpIHtcbiAgdmFyIHZhbHVlID0gY2hpbGRyZW4ocHJvcHMpO1xuICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyB3YXJuaW5nKHZhbHVlICE9PSB1bmRlZmluZWQsIFwiWW91IHJldHVybmVkIGB1bmRlZmluZWRgIGZyb20gdGhlIGBjaGlsZHJlbmAgZnVuY3Rpb24gb2YgXCIgKyAoXCI8Um91dGVcIiArIChwYXRoID8gXCIgcGF0aD1cXFwiXCIgKyBwYXRoICsgXCJcXFwiXCIgOiBcIlwiKSArIFwiPiwgYnV0IHlvdSBcIikgKyBcInNob3VsZCBoYXZlIHJldHVybmVkIGEgUmVhY3QgZWxlbWVudCBvciBgbnVsbGBcIikgOiB2b2lkIDA7XG4gIHJldHVybiB2YWx1ZSB8fCBudWxsO1xufVxuLyoqXG4gKiBUaGUgcHVibGljIEFQSSBmb3IgbWF0Y2hpbmcgYSBzaW5nbGUgcGF0aCBhbmQgcmVuZGVyaW5nLlxuICovXG5cblxudmFyIFJvdXRlID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfUmVhY3QkQ29tcG9uZW50KSB7XG4gIF9pbmhlcml0c0xvb3NlKFJvdXRlLCBfUmVhY3QkQ29tcG9uZW50KTtcblxuICBmdW5jdGlvbiBSb3V0ZSgpIHtcbiAgICByZXR1cm4gX1JlYWN0JENvbXBvbmVudC5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gIH1cblxuICB2YXIgX3Byb3RvID0gUm91dGUucHJvdG90eXBlO1xuXG4gIF9wcm90by5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChjb250ZXh0LkNvbnN1bWVyLCBudWxsLCBmdW5jdGlvbiAoY29udGV4dCQxKSB7XG4gICAgICAhY29udGV4dCQxID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCBcIllvdSBzaG91bGQgbm90IHVzZSA8Um91dGU+IG91dHNpZGUgYSA8Um91dGVyPlwiKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gICAgICB2YXIgbG9jYXRpb24gPSBfdGhpcy5wcm9wcy5sb2NhdGlvbiB8fCBjb250ZXh0JDEubG9jYXRpb247XG4gICAgICB2YXIgbWF0Y2ggPSBfdGhpcy5wcm9wcy5jb21wdXRlZE1hdGNoID8gX3RoaXMucHJvcHMuY29tcHV0ZWRNYXRjaCAvLyA8U3dpdGNoPiBhbHJlYWR5IGNvbXB1dGVkIHRoZSBtYXRjaCBmb3IgdXNcbiAgICAgIDogX3RoaXMucHJvcHMucGF0aCA/IG1hdGNoUGF0aChsb2NhdGlvbi5wYXRobmFtZSwgX3RoaXMucHJvcHMpIDogY29udGV4dCQxLm1hdGNoO1xuXG4gICAgICB2YXIgcHJvcHMgPSBfZXh0ZW5kcyh7fSwgY29udGV4dCQxLCB7XG4gICAgICAgIGxvY2F0aW9uOiBsb2NhdGlvbixcbiAgICAgICAgbWF0Y2g6IG1hdGNoXG4gICAgICB9KTtcblxuICAgICAgdmFyIF90aGlzJHByb3BzID0gX3RoaXMucHJvcHMsXG4gICAgICAgICAgY2hpbGRyZW4gPSBfdGhpcyRwcm9wcy5jaGlsZHJlbixcbiAgICAgICAgICBjb21wb25lbnQgPSBfdGhpcyRwcm9wcy5jb21wb25lbnQsXG4gICAgICAgICAgcmVuZGVyID0gX3RoaXMkcHJvcHMucmVuZGVyOyAvLyBQcmVhY3QgdXNlcyBhbiBlbXB0eSBhcnJheSBhcyBjaGlsZHJlbiBieVxuICAgICAgLy8gZGVmYXVsdCwgc28gdXNlIG51bGwgaWYgdGhhdCdzIHRoZSBjYXNlLlxuXG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShjaGlsZHJlbikgJiYgaXNFbXB0eUNoaWxkcmVuKGNoaWxkcmVuKSkge1xuICAgICAgICBjaGlsZHJlbiA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChjb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgICAgIHZhbHVlOiBwcm9wc1xuICAgICAgfSwgcHJvcHMubWF0Y2ggPyBjaGlsZHJlbiA/IHR5cGVvZiBjaGlsZHJlbiA9PT0gXCJmdW5jdGlvblwiID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gZXZhbENoaWxkcmVuRGV2KGNoaWxkcmVuLCBwcm9wcywgX3RoaXMucHJvcHMucGF0aCkgOiBjaGlsZHJlbihwcm9wcykgOiBjaGlsZHJlbiA6IGNvbXBvbmVudCA/IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KGNvbXBvbmVudCwgcHJvcHMpIDogcmVuZGVyID8gcmVuZGVyKHByb3BzKSA6IG51bGwgOiB0eXBlb2YgY2hpbGRyZW4gPT09IFwiZnVuY3Rpb25cIiA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGV2YWxDaGlsZHJlbkRldihjaGlsZHJlbiwgcHJvcHMsIF90aGlzLnByb3BzLnBhdGgpIDogY2hpbGRyZW4ocHJvcHMpIDogbnVsbCk7XG4gICAgfSk7XG4gIH07XG5cbiAgcmV0dXJuIFJvdXRlO1xufShSZWFjdC5Db21wb25lbnQpO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gIFJvdXRlLnByb3BUeXBlcyA9IHtcbiAgICBjaGlsZHJlbjogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLmZ1bmMsIFByb3BUeXBlcy5ub2RlXSksXG4gICAgY29tcG9uZW50OiBmdW5jdGlvbiBjb21wb25lbnQocHJvcHMsIHByb3BOYW1lKSB7XG4gICAgICBpZiAocHJvcHNbcHJvcE5hbWVdICYmICFpc1ZhbGlkRWxlbWVudFR5cGUocHJvcHNbcHJvcE5hbWVdKSkge1xuICAgICAgICByZXR1cm4gbmV3IEVycm9yKFwiSW52YWxpZCBwcm9wICdjb21wb25lbnQnIHN1cHBsaWVkIHRvICdSb3V0ZSc6IHRoZSBwcm9wIGlzIG5vdCBhIHZhbGlkIFJlYWN0IGNvbXBvbmVudFwiKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGV4YWN0OiBQcm9wVHlwZXMuYm9vbCxcbiAgICBsb2NhdGlvbjogUHJvcFR5cGVzLm9iamVjdCxcbiAgICBwYXRoOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMuc3RyaW5nLCBQcm9wVHlwZXMuYXJyYXlPZihQcm9wVHlwZXMuc3RyaW5nKV0pLFxuICAgIHJlbmRlcjogUHJvcFR5cGVzLmZ1bmMsXG4gICAgc2Vuc2l0aXZlOiBQcm9wVHlwZXMuYm9vbCxcbiAgICBzdHJpY3Q6IFByb3BUeXBlcy5ib29sXG4gIH07XG5cbiAgUm91dGUucHJvdG90eXBlLmNvbXBvbmVudERpZE1vdW50ID0gZnVuY3Rpb24gKCkge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IHdhcm5pbmcoISh0aGlzLnByb3BzLmNoaWxkcmVuICYmICFpc0VtcHR5Q2hpbGRyZW4odGhpcy5wcm9wcy5jaGlsZHJlbikgJiYgdGhpcy5wcm9wcy5jb21wb25lbnQpLCBcIllvdSBzaG91bGQgbm90IHVzZSA8Um91dGUgY29tcG9uZW50PiBhbmQgPFJvdXRlIGNoaWxkcmVuPiBpbiB0aGUgc2FtZSByb3V0ZTsgPFJvdXRlIGNvbXBvbmVudD4gd2lsbCBiZSBpZ25vcmVkXCIpIDogdm9pZCAwO1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IHdhcm5pbmcoISh0aGlzLnByb3BzLmNoaWxkcmVuICYmICFpc0VtcHR5Q2hpbGRyZW4odGhpcy5wcm9wcy5jaGlsZHJlbikgJiYgdGhpcy5wcm9wcy5yZW5kZXIpLCBcIllvdSBzaG91bGQgbm90IHVzZSA8Um91dGUgcmVuZGVyPiBhbmQgPFJvdXRlIGNoaWxkcmVuPiBpbiB0aGUgc2FtZSByb3V0ZTsgPFJvdXRlIHJlbmRlcj4gd2lsbCBiZSBpZ25vcmVkXCIpIDogdm9pZCAwO1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IHdhcm5pbmcoISh0aGlzLnByb3BzLmNvbXBvbmVudCAmJiB0aGlzLnByb3BzLnJlbmRlciksIFwiWW91IHNob3VsZCBub3QgdXNlIDxSb3V0ZSBjb21wb25lbnQ+IGFuZCA8Um91dGUgcmVuZGVyPiBpbiB0aGUgc2FtZSByb3V0ZTsgPFJvdXRlIHJlbmRlcj4gd2lsbCBiZSBpZ25vcmVkXCIpIDogdm9pZCAwO1xuICB9O1xuXG4gIFJvdXRlLnByb3RvdHlwZS5jb21wb25lbnREaWRVcGRhdGUgPSBmdW5jdGlvbiAocHJldlByb3BzKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gd2FybmluZyghKHRoaXMucHJvcHMubG9jYXRpb24gJiYgIXByZXZQcm9wcy5sb2NhdGlvbiksICc8Um91dGU+IGVsZW1lbnRzIHNob3VsZCBub3QgY2hhbmdlIGZyb20gdW5jb250cm9sbGVkIHRvIGNvbnRyb2xsZWQgKG9yIHZpY2UgdmVyc2EpLiBZb3UgaW5pdGlhbGx5IHVzZWQgbm8gXCJsb2NhdGlvblwiIHByb3AgYW5kIHRoZW4gcHJvdmlkZWQgb25lIG9uIGEgc3Vic2VxdWVudCByZW5kZXIuJykgOiB2b2lkIDA7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gd2FybmluZyghKCF0aGlzLnByb3BzLmxvY2F0aW9uICYmIHByZXZQcm9wcy5sb2NhdGlvbiksICc8Um91dGU+IGVsZW1lbnRzIHNob3VsZCBub3QgY2hhbmdlIGZyb20gY29udHJvbGxlZCB0byB1bmNvbnRyb2xsZWQgKG9yIHZpY2UgdmVyc2EpLiBZb3UgcHJvdmlkZWQgYSBcImxvY2F0aW9uXCIgcHJvcCBpbml0aWFsbHkgYnV0IG9taXR0ZWQgaXQgb24gYSBzdWJzZXF1ZW50IHJlbmRlci4nKSA6IHZvaWQgMDtcbiAgfTtcbn1cblxuZnVuY3Rpb24gYWRkTGVhZGluZ1NsYXNoKHBhdGgpIHtcbiAgcmV0dXJuIHBhdGguY2hhckF0KDApID09PSBcIi9cIiA/IHBhdGggOiBcIi9cIiArIHBhdGg7XG59XG5cbmZ1bmN0aW9uIGFkZEJhc2VuYW1lKGJhc2VuYW1lLCBsb2NhdGlvbikge1xuICBpZiAoIWJhc2VuYW1lKSByZXR1cm4gbG9jYXRpb247XG4gIHJldHVybiBfZXh0ZW5kcyh7fSwgbG9jYXRpb24sIHtcbiAgICBwYXRobmFtZTogYWRkTGVhZGluZ1NsYXNoKGJhc2VuYW1lKSArIGxvY2F0aW9uLnBhdGhuYW1lXG4gIH0pO1xufVxuXG5mdW5jdGlvbiBzdHJpcEJhc2VuYW1lKGJhc2VuYW1lLCBsb2NhdGlvbikge1xuICBpZiAoIWJhc2VuYW1lKSByZXR1cm4gbG9jYXRpb247XG4gIHZhciBiYXNlID0gYWRkTGVhZGluZ1NsYXNoKGJhc2VuYW1lKTtcbiAgaWYgKGxvY2F0aW9uLnBhdGhuYW1lLmluZGV4T2YoYmFzZSkgIT09IDApIHJldHVybiBsb2NhdGlvbjtcbiAgcmV0dXJuIF9leHRlbmRzKHt9LCBsb2NhdGlvbiwge1xuICAgIHBhdGhuYW1lOiBsb2NhdGlvbi5wYXRobmFtZS5zdWJzdHIoYmFzZS5sZW5ndGgpXG4gIH0pO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVVUkwobG9jYXRpb24pIHtcbiAgcmV0dXJuIHR5cGVvZiBsb2NhdGlvbiA9PT0gXCJzdHJpbmdcIiA/IGxvY2F0aW9uIDogY3JlYXRlUGF0aChsb2NhdGlvbik7XG59XG5cbmZ1bmN0aW9uIHN0YXRpY0hhbmRsZXIobWV0aG9kTmFtZSkge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsIFwiWW91IGNhbm5vdCAlcyB3aXRoIDxTdGF0aWNSb3V0ZXI+XCIsIG1ldGhvZE5hbWUpIDogaW52YXJpYW50KGZhbHNlKSA7XG4gIH07XG59XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuLyoqXG4gKiBUaGUgcHVibGljIHRvcC1sZXZlbCBBUEkgZm9yIGEgXCJzdGF0aWNcIiA8Um91dGVyPiwgc28tY2FsbGVkIGJlY2F1c2UgaXRcbiAqIGNhbid0IGFjdHVhbGx5IGNoYW5nZSB0aGUgY3VycmVudCBsb2NhdGlvbi4gSW5zdGVhZCwgaXQganVzdCByZWNvcmRzXG4gKiBsb2NhdGlvbiBjaGFuZ2VzIGluIGEgY29udGV4dCBvYmplY3QuIFVzZWZ1bCBtYWlubHkgaW4gdGVzdGluZyBhbmRcbiAqIHNlcnZlci1yZW5kZXJpbmcgc2NlbmFyaW9zLlxuICovXG5cblxudmFyIFN0YXRpY1JvdXRlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX1JlYWN0JENvbXBvbmVudCkge1xuICBfaW5oZXJpdHNMb29zZShTdGF0aWNSb3V0ZXIsIF9SZWFjdCRDb21wb25lbnQpO1xuXG4gIGZ1bmN0aW9uIFN0YXRpY1JvdXRlcigpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgX3RoaXMgPSBfUmVhY3QkQ29tcG9uZW50LmNhbGwuYXBwbHkoX1JlYWN0JENvbXBvbmVudCwgW3RoaXNdLmNvbmNhdChhcmdzKSkgfHwgdGhpcztcblxuICAgIF90aGlzLmhhbmRsZVB1c2ggPSBmdW5jdGlvbiAobG9jYXRpb24pIHtcbiAgICAgIHJldHVybiBfdGhpcy5uYXZpZ2F0ZVRvKGxvY2F0aW9uLCBcIlBVU0hcIik7XG4gICAgfTtcblxuICAgIF90aGlzLmhhbmRsZVJlcGxhY2UgPSBmdW5jdGlvbiAobG9jYXRpb24pIHtcbiAgICAgIHJldHVybiBfdGhpcy5uYXZpZ2F0ZVRvKGxvY2F0aW9uLCBcIlJFUExBQ0VcIik7XG4gICAgfTtcblxuICAgIF90aGlzLmhhbmRsZUxpc3RlbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBub29wO1xuICAgIH07XG5cbiAgICBfdGhpcy5oYW5kbGVCbG9jayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBub29wO1xuICAgIH07XG5cbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICB2YXIgX3Byb3RvID0gU3RhdGljUm91dGVyLnByb3RvdHlwZTtcblxuICBfcHJvdG8ubmF2aWdhdGVUbyA9IGZ1bmN0aW9uIG5hdmlnYXRlVG8obG9jYXRpb24sIGFjdGlvbikge1xuICAgIHZhciBfdGhpcyRwcm9wcyA9IHRoaXMucHJvcHMsXG4gICAgICAgIF90aGlzJHByb3BzJGJhc2VuYW1lID0gX3RoaXMkcHJvcHMuYmFzZW5hbWUsXG4gICAgICAgIGJhc2VuYW1lID0gX3RoaXMkcHJvcHMkYmFzZW5hbWUgPT09IHZvaWQgMCA/IFwiXCIgOiBfdGhpcyRwcm9wcyRiYXNlbmFtZSxcbiAgICAgICAgX3RoaXMkcHJvcHMkY29udGV4dCA9IF90aGlzJHByb3BzLmNvbnRleHQsXG4gICAgICAgIGNvbnRleHQgPSBfdGhpcyRwcm9wcyRjb250ZXh0ID09PSB2b2lkIDAgPyB7fSA6IF90aGlzJHByb3BzJGNvbnRleHQ7XG4gICAgY29udGV4dC5hY3Rpb24gPSBhY3Rpb247XG4gICAgY29udGV4dC5sb2NhdGlvbiA9IGFkZEJhc2VuYW1lKGJhc2VuYW1lLCBjcmVhdGVMb2NhdGlvbihsb2NhdGlvbikpO1xuICAgIGNvbnRleHQudXJsID0gY3JlYXRlVVJMKGNvbnRleHQubG9jYXRpb24pO1xuICB9O1xuXG4gIF9wcm90by5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgdmFyIF90aGlzJHByb3BzMiA9IHRoaXMucHJvcHMsXG4gICAgICAgIF90aGlzJHByb3BzMiRiYXNlbmFtZSA9IF90aGlzJHByb3BzMi5iYXNlbmFtZSxcbiAgICAgICAgYmFzZW5hbWUgPSBfdGhpcyRwcm9wczIkYmFzZW5hbWUgPT09IHZvaWQgMCA/IFwiXCIgOiBfdGhpcyRwcm9wczIkYmFzZW5hbWUsXG4gICAgICAgIF90aGlzJHByb3BzMiRjb250ZXh0ID0gX3RoaXMkcHJvcHMyLmNvbnRleHQsXG4gICAgICAgIGNvbnRleHQgPSBfdGhpcyRwcm9wczIkY29udGV4dCA9PT0gdm9pZCAwID8ge30gOiBfdGhpcyRwcm9wczIkY29udGV4dCxcbiAgICAgICAgX3RoaXMkcHJvcHMyJGxvY2F0aW9uID0gX3RoaXMkcHJvcHMyLmxvY2F0aW9uLFxuICAgICAgICBsb2NhdGlvbiA9IF90aGlzJHByb3BzMiRsb2NhdGlvbiA9PT0gdm9pZCAwID8gXCIvXCIgOiBfdGhpcyRwcm9wczIkbG9jYXRpb24sXG4gICAgICAgIHJlc3QgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShfdGhpcyRwcm9wczIsIFtcImJhc2VuYW1lXCIsIFwiY29udGV4dFwiLCBcImxvY2F0aW9uXCJdKTtcblxuICAgIHZhciBoaXN0b3J5ID0ge1xuICAgICAgY3JlYXRlSHJlZjogZnVuY3Rpb24gY3JlYXRlSHJlZihwYXRoKSB7XG4gICAgICAgIHJldHVybiBhZGRMZWFkaW5nU2xhc2goYmFzZW5hbWUgKyBjcmVhdGVVUkwocGF0aCkpO1xuICAgICAgfSxcbiAgICAgIGFjdGlvbjogXCJQT1BcIixcbiAgICAgIGxvY2F0aW9uOiBzdHJpcEJhc2VuYW1lKGJhc2VuYW1lLCBjcmVhdGVMb2NhdGlvbihsb2NhdGlvbikpLFxuICAgICAgcHVzaDogdGhpcy5oYW5kbGVQdXNoLFxuICAgICAgcmVwbGFjZTogdGhpcy5oYW5kbGVSZXBsYWNlLFxuICAgICAgZ286IHN0YXRpY0hhbmRsZXIoXCJnb1wiKSxcbiAgICAgIGdvQmFjazogc3RhdGljSGFuZGxlcihcImdvQmFja1wiKSxcbiAgICAgIGdvRm9yd2FyZDogc3RhdGljSGFuZGxlcihcImdvRm9yd2FyZFwiKSxcbiAgICAgIGxpc3RlbjogdGhpcy5oYW5kbGVMaXN0ZW4sXG4gICAgICBibG9jazogdGhpcy5oYW5kbGVCbG9ja1xuICAgIH07XG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFJvdXRlciwgX2V4dGVuZHMoe30sIHJlc3QsIHtcbiAgICAgIGhpc3Rvcnk6IGhpc3RvcnksXG4gICAgICBzdGF0aWNDb250ZXh0OiBjb250ZXh0XG4gICAgfSkpO1xuICB9O1xuXG4gIHJldHVybiBTdGF0aWNSb3V0ZXI7XG59KFJlYWN0LkNvbXBvbmVudCk7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgU3RhdGljUm91dGVyLnByb3BUeXBlcyA9IHtcbiAgICBiYXNlbmFtZTogUHJvcFR5cGVzLnN0cmluZyxcbiAgICBjb250ZXh0OiBQcm9wVHlwZXMub2JqZWN0LFxuICAgIGxvY2F0aW9uOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMuc3RyaW5nLCBQcm9wVHlwZXMub2JqZWN0XSlcbiAgfTtcblxuICBTdGF0aWNSb3V0ZXIucHJvdG90eXBlLmNvbXBvbmVudERpZE1vdW50ID0gZnVuY3Rpb24gKCkge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IHdhcm5pbmcoIXRoaXMucHJvcHMuaGlzdG9yeSwgXCI8U3RhdGljUm91dGVyPiBpZ25vcmVzIHRoZSBoaXN0b3J5IHByb3AuIFRvIHVzZSBhIGN1c3RvbSBoaXN0b3J5LCBcIiArIFwidXNlIGBpbXBvcnQgeyBSb3V0ZXIgfWAgaW5zdGVhZCBvZiBgaW1wb3J0IHsgU3RhdGljUm91dGVyIGFzIFJvdXRlciB9YC5cIikgOiB2b2lkIDA7XG4gIH07XG59XG5cbi8qKlxuICogVGhlIHB1YmxpYyBBUEkgZm9yIHJlbmRlcmluZyB0aGUgZmlyc3QgPFJvdXRlPiB0aGF0IG1hdGNoZXMuXG4gKi9cblxudmFyIFN3aXRjaCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX1JlYWN0JENvbXBvbmVudCkge1xuICBfaW5oZXJpdHNMb29zZShTd2l0Y2gsIF9SZWFjdCRDb21wb25lbnQpO1xuXG4gIGZ1bmN0aW9uIFN3aXRjaCgpIHtcbiAgICByZXR1cm4gX1JlYWN0JENvbXBvbmVudC5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gIH1cblxuICB2YXIgX3Byb3RvID0gU3dpdGNoLnByb3RvdHlwZTtcblxuICBfcHJvdG8ucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoY29udGV4dC5Db25zdW1lciwgbnVsbCwgZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICAgICFjb250ZXh0ID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCBcIllvdSBzaG91bGQgbm90IHVzZSA8U3dpdGNoPiBvdXRzaWRlIGEgPFJvdXRlcj5cIikgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICAgICAgdmFyIGxvY2F0aW9uID0gX3RoaXMucHJvcHMubG9jYXRpb24gfHwgY29udGV4dC5sb2NhdGlvbjtcbiAgICAgIHZhciBlbGVtZW50LCBtYXRjaDsgLy8gV2UgdXNlIFJlYWN0LkNoaWxkcmVuLmZvckVhY2ggaW5zdGVhZCBvZiBSZWFjdC5DaGlsZHJlbi50b0FycmF5KCkuZmluZCgpXG4gICAgICAvLyBoZXJlIGJlY2F1c2UgdG9BcnJheSBhZGRzIGtleXMgdG8gYWxsIGNoaWxkIGVsZW1lbnRzIGFuZCB3ZSBkbyBub3Qgd2FudFxuICAgICAgLy8gdG8gdHJpZ2dlciBhbiB1bm1vdW50L3JlbW91bnQgZm9yIHR3byA8Um91dGU+cyB0aGF0IHJlbmRlciB0aGUgc2FtZVxuICAgICAgLy8gY29tcG9uZW50IGF0IGRpZmZlcmVudCBVUkxzLlxuXG4gICAgICBSZWFjdC5DaGlsZHJlbi5mb3JFYWNoKF90aGlzLnByb3BzLmNoaWxkcmVuLCBmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgaWYgKG1hdGNoID09IG51bGwgJiYgLyojX19QVVJFX18qL1JlYWN0LmlzVmFsaWRFbGVtZW50KGNoaWxkKSkge1xuICAgICAgICAgIGVsZW1lbnQgPSBjaGlsZDtcbiAgICAgICAgICB2YXIgcGF0aCA9IGNoaWxkLnByb3BzLnBhdGggfHwgY2hpbGQucHJvcHMuZnJvbTtcbiAgICAgICAgICBtYXRjaCA9IHBhdGggPyBtYXRjaFBhdGgobG9jYXRpb24ucGF0aG5hbWUsIF9leHRlbmRzKHt9LCBjaGlsZC5wcm9wcywge1xuICAgICAgICAgICAgcGF0aDogcGF0aFxuICAgICAgICAgIH0pKSA6IGNvbnRleHQubWF0Y2g7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIG1hdGNoID8gLyojX19QVVJFX18qL1JlYWN0LmNsb25lRWxlbWVudChlbGVtZW50LCB7XG4gICAgICAgIGxvY2F0aW9uOiBsb2NhdGlvbixcbiAgICAgICAgY29tcHV0ZWRNYXRjaDogbWF0Y2hcbiAgICAgIH0pIDogbnVsbDtcbiAgICB9KTtcbiAgfTtcblxuICByZXR1cm4gU3dpdGNoO1xufShSZWFjdC5Db21wb25lbnQpO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gIFN3aXRjaC5wcm9wVHlwZXMgPSB7XG4gICAgY2hpbGRyZW46IFByb3BUeXBlcy5ub2RlLFxuICAgIGxvY2F0aW9uOiBQcm9wVHlwZXMub2JqZWN0XG4gIH07XG5cbiAgU3dpdGNoLnByb3RvdHlwZS5jb21wb25lbnREaWRVcGRhdGUgPSBmdW5jdGlvbiAocHJldlByb3BzKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gd2FybmluZyghKHRoaXMucHJvcHMubG9jYXRpb24gJiYgIXByZXZQcm9wcy5sb2NhdGlvbiksICc8U3dpdGNoPiBlbGVtZW50cyBzaG91bGQgbm90IGNoYW5nZSBmcm9tIHVuY29udHJvbGxlZCB0byBjb250cm9sbGVkIChvciB2aWNlIHZlcnNhKS4gWW91IGluaXRpYWxseSB1c2VkIG5vIFwibG9jYXRpb25cIiBwcm9wIGFuZCB0aGVuIHByb3ZpZGVkIG9uZSBvbiBhIHN1YnNlcXVlbnQgcmVuZGVyLicpIDogdm9pZCAwO1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IHdhcm5pbmcoISghdGhpcy5wcm9wcy5sb2NhdGlvbiAmJiBwcmV2UHJvcHMubG9jYXRpb24pLCAnPFN3aXRjaD4gZWxlbWVudHMgc2hvdWxkIG5vdCBjaGFuZ2UgZnJvbSBjb250cm9sbGVkIHRvIHVuY29udHJvbGxlZCAob3IgdmljZSB2ZXJzYSkuIFlvdSBwcm92aWRlZCBhIFwibG9jYXRpb25cIiBwcm9wIGluaXRpYWxseSBidXQgb21pdHRlZCBpdCBvbiBhIHN1YnNlcXVlbnQgcmVuZGVyLicpIDogdm9pZCAwO1xuICB9O1xufVxuXG4vKipcbiAqIEEgcHVibGljIGhpZ2hlci1vcmRlciBjb21wb25lbnQgdG8gYWNjZXNzIHRoZSBpbXBlcmF0aXZlIEFQSVxuICovXG5cbmZ1bmN0aW9uIHdpdGhSb3V0ZXIoQ29tcG9uZW50KSB7XG4gIHZhciBkaXNwbGF5TmFtZSA9IFwid2l0aFJvdXRlcihcIiArIChDb21wb25lbnQuZGlzcGxheU5hbWUgfHwgQ29tcG9uZW50Lm5hbWUpICsgXCIpXCI7XG5cbiAgdmFyIEMgPSBmdW5jdGlvbiBDKHByb3BzKSB7XG4gICAgdmFyIHdyYXBwZWRDb21wb25lbnRSZWYgPSBwcm9wcy53cmFwcGVkQ29tcG9uZW50UmVmLFxuICAgICAgICByZW1haW5pbmdQcm9wcyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHByb3BzLCBbXCJ3cmFwcGVkQ29tcG9uZW50UmVmXCJdKTtcblxuICAgIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChjb250ZXh0LkNvbnN1bWVyLCBudWxsLCBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgICAgIWNvbnRleHQgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsIFwiWW91IHNob3VsZCBub3QgdXNlIDxcIiArIGRpc3BsYXlOYW1lICsgXCIgLz4gb3V0c2lkZSBhIDxSb3V0ZXI+XCIpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChDb21wb25lbnQsIF9leHRlbmRzKHt9LCByZW1haW5pbmdQcm9wcywgY29udGV4dCwge1xuICAgICAgICByZWY6IHdyYXBwZWRDb21wb25lbnRSZWZcbiAgICAgIH0pKTtcbiAgICB9KTtcbiAgfTtcblxuICBDLmRpc3BsYXlOYW1lID0gZGlzcGxheU5hbWU7XG4gIEMuV3JhcHBlZENvbXBvbmVudCA9IENvbXBvbmVudDtcblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgQy5wcm9wVHlwZXMgPSB7XG4gICAgICB3cmFwcGVkQ29tcG9uZW50UmVmOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMuc3RyaW5nLCBQcm9wVHlwZXMuZnVuYywgUHJvcFR5cGVzLm9iamVjdF0pXG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiBob2lzdFN0YXRpY3MoQywgQ29tcG9uZW50KTtcbn1cblxudmFyIHVzZUNvbnRleHQgPSBSZWFjdC51c2VDb250ZXh0O1xuZnVuY3Rpb24gdXNlSGlzdG9yeSgpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICEodHlwZW9mIHVzZUNvbnRleHQgPT09IFwiZnVuY3Rpb25cIikgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsIFwiWW91IG11c3QgdXNlIFJlYWN0ID49IDE2LjggaW4gb3JkZXIgdG8gdXNlIHVzZUhpc3RvcnkoKVwiKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gIH1cblxuICByZXR1cm4gdXNlQ29udGV4dChoaXN0b3J5Q29udGV4dCk7XG59XG5mdW5jdGlvbiB1c2VMb2NhdGlvbigpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICEodHlwZW9mIHVzZUNvbnRleHQgPT09IFwiZnVuY3Rpb25cIikgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsIFwiWW91IG11c3QgdXNlIFJlYWN0ID49IDE2LjggaW4gb3JkZXIgdG8gdXNlIHVzZUxvY2F0aW9uKClcIikgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICB9XG5cbiAgcmV0dXJuIHVzZUNvbnRleHQoY29udGV4dCkubG9jYXRpb247XG59XG5mdW5jdGlvbiB1c2VQYXJhbXMoKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAhKHR5cGVvZiB1c2VDb250ZXh0ID09PSBcImZ1bmN0aW9uXCIpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCBcIllvdSBtdXN0IHVzZSBSZWFjdCA+PSAxNi44IGluIG9yZGVyIHRvIHVzZSB1c2VQYXJhbXMoKVwiKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gIH1cblxuICB2YXIgbWF0Y2ggPSB1c2VDb250ZXh0KGNvbnRleHQpLm1hdGNoO1xuICByZXR1cm4gbWF0Y2ggPyBtYXRjaC5wYXJhbXMgOiB7fTtcbn1cbmZ1bmN0aW9uIHVzZVJvdXRlTWF0Y2gocGF0aCkge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgISh0eXBlb2YgdXNlQ29udGV4dCA9PT0gXCJmdW5jdGlvblwiKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgXCJZb3UgbXVzdCB1c2UgUmVhY3QgPj0gMTYuOCBpbiBvcmRlciB0byB1c2UgdXNlUm91dGVNYXRjaCgpXCIpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgfVxuXG4gIHZhciBsb2NhdGlvbiA9IHVzZUxvY2F0aW9uKCk7XG4gIHZhciBtYXRjaCA9IHVzZUNvbnRleHQoY29udGV4dCkubWF0Y2g7XG4gIHJldHVybiBwYXRoID8gbWF0Y2hQYXRoKGxvY2F0aW9uLnBhdGhuYW1lLCBwYXRoKSA6IG1hdGNoO1xufVxuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgdmFyIGdsb2JhbCA9IHdpbmRvdztcbiAgICB2YXIga2V5ID0gXCJfX3JlYWN0X3JvdXRlcl9idWlsZF9fXCI7XG4gICAgdmFyIGJ1aWxkTmFtZXMgPSB7XG4gICAgICBjanM6IFwiQ29tbW9uSlNcIixcbiAgICAgIGVzbTogXCJFUyBtb2R1bGVzXCIsXG4gICAgICB1bWQ6IFwiVU1EXCJcbiAgICB9O1xuXG4gICAgaWYgKGdsb2JhbFtrZXldICYmIGdsb2JhbFtrZXldICE9PSBcImVzbVwiKSB7XG4gICAgICB2YXIgaW5pdGlhbEJ1aWxkTmFtZSA9IGJ1aWxkTmFtZXNbZ2xvYmFsW2tleV1dO1xuICAgICAgdmFyIHNlY29uZGFyeUJ1aWxkTmFtZSA9IGJ1aWxkTmFtZXNbXCJlc21cIl07IC8vIFRPRE86IEFkZCBsaW5rIHRvIGFydGljbGUgdGhhdCBleHBsYWlucyBpbiBkZXRhaWwgaG93IHRvIGF2b2lkXG4gICAgICAvLyBsb2FkaW5nIDIgZGlmZmVyZW50IGJ1aWxkcy5cblxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiWW91IGFyZSBsb2FkaW5nIHRoZSBcIiArIHNlY29uZGFyeUJ1aWxkTmFtZSArIFwiIGJ1aWxkIG9mIFJlYWN0IFJvdXRlciBcIiArIChcIm9uIGEgcGFnZSB0aGF0IGlzIGFscmVhZHkgcnVubmluZyB0aGUgXCIgKyBpbml0aWFsQnVpbGROYW1lICsgXCIgXCIpICsgXCJidWlsZCwgc28gdGhpbmdzIHdvbid0IHdvcmsgcmlnaHQuXCIpO1xuICAgIH1cblxuICAgIGdsb2JhbFtrZXldID0gXCJlc21cIjtcbiAgfVxufVxuXG5leHBvcnQgeyBNZW1vcnlSb3V0ZXIsIFByb21wdCwgUmVkaXJlY3QsIFJvdXRlLCBSb3V0ZXIsIFN0YXRpY1JvdXRlciwgU3dpdGNoLCBoaXN0b3J5Q29udGV4dCBhcyBfX0hpc3RvcnlDb250ZXh0LCBjb250ZXh0IGFzIF9fUm91dGVyQ29udGV4dCwgZ2VuZXJhdGVQYXRoLCBtYXRjaFBhdGgsIHVzZUhpc3RvcnksIHVzZUxvY2F0aW9uLCB1c2VQYXJhbXMsIHVzZVJvdXRlTWF0Y2gsIHdpdGhSb3V0ZXIgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlYWN0LXJvdXRlci5qcy5tYXBcbiIsImltcG9ydCB7IFJvdXRlciwgX19Sb3V0ZXJDb250ZXh0LCBtYXRjaFBhdGggfSBmcm9tICdyZWFjdC1yb3V0ZXInO1xuZXhwb3J0IHsgTWVtb3J5Um91dGVyLCBQcm9tcHQsIFJlZGlyZWN0LCBSb3V0ZSwgUm91dGVyLCBTdGF0aWNSb3V0ZXIsIFN3aXRjaCwgZ2VuZXJhdGVQYXRoLCBtYXRjaFBhdGgsIHVzZUhpc3RvcnksIHVzZUxvY2F0aW9uLCB1c2VQYXJhbXMsIHVzZVJvdXRlTWF0Y2gsIHdpdGhSb3V0ZXIgfSBmcm9tICdyZWFjdC1yb3V0ZXInO1xuaW1wb3J0IF9pbmhlcml0c0xvb3NlIGZyb20gJ0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2luaGVyaXRzTG9vc2UnO1xuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IGNyZWF0ZUJyb3dzZXJIaXN0b3J5LCBjcmVhdGVIYXNoSGlzdG9yeSwgY3JlYXRlTG9jYXRpb24sIGNyZWF0ZVBhdGggfSBmcm9tICdoaXN0b3J5JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgd2FybmluZyBmcm9tICd0aW55LXdhcm5pbmcnO1xuaW1wb3J0IF9leHRlbmRzIGZyb20gJ0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2V4dGVuZHMnO1xuaW1wb3J0IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlIGZyb20gJ0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UnO1xuaW1wb3J0IGludmFyaWFudCBmcm9tICd0aW55LWludmFyaWFudCc7XG5cbi8qKlxuICogVGhlIHB1YmxpYyBBUEkgZm9yIGEgPFJvdXRlcj4gdGhhdCB1c2VzIEhUTUw1IGhpc3RvcnkuXG4gKi9cblxudmFyIEJyb3dzZXJSb3V0ZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9SZWFjdCRDb21wb25lbnQpIHtcbiAgX2luaGVyaXRzTG9vc2UoQnJvd3NlclJvdXRlciwgX1JlYWN0JENvbXBvbmVudCk7XG5cbiAgZnVuY3Rpb24gQnJvd3NlclJvdXRlcigpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgX3RoaXMgPSBfUmVhY3QkQ29tcG9uZW50LmNhbGwuYXBwbHkoX1JlYWN0JENvbXBvbmVudCwgW3RoaXNdLmNvbmNhdChhcmdzKSkgfHwgdGhpcztcbiAgICBfdGhpcy5oaXN0b3J5ID0gY3JlYXRlQnJvd3Nlckhpc3RvcnkoX3RoaXMucHJvcHMpO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBCcm93c2VyUm91dGVyLnByb3RvdHlwZTtcblxuICBfcHJvdG8ucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChSb3V0ZXIsIHtcbiAgICAgIGhpc3Rvcnk6IHRoaXMuaGlzdG9yeSxcbiAgICAgIGNoaWxkcmVuOiB0aGlzLnByb3BzLmNoaWxkcmVuXG4gICAgfSk7XG4gIH07XG5cbiAgcmV0dXJuIEJyb3dzZXJSb3V0ZXI7XG59KFJlYWN0LkNvbXBvbmVudCk7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgQnJvd3NlclJvdXRlci5wcm9wVHlwZXMgPSB7XG4gICAgYmFzZW5hbWU6IFByb3BUeXBlcy5zdHJpbmcsXG4gICAgY2hpbGRyZW46IFByb3BUeXBlcy5ub2RlLFxuICAgIGZvcmNlUmVmcmVzaDogUHJvcFR5cGVzLmJvb2wsXG4gICAgZ2V0VXNlckNvbmZpcm1hdGlvbjogUHJvcFR5cGVzLmZ1bmMsXG4gICAga2V5TGVuZ3RoOiBQcm9wVHlwZXMubnVtYmVyXG4gIH07XG5cbiAgQnJvd3NlclJvdXRlci5wcm90b3R5cGUuY29tcG9uZW50RGlkTW91bnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gd2FybmluZyghdGhpcy5wcm9wcy5oaXN0b3J5LCBcIjxCcm93c2VyUm91dGVyPiBpZ25vcmVzIHRoZSBoaXN0b3J5IHByb3AuIFRvIHVzZSBhIGN1c3RvbSBoaXN0b3J5LCBcIiArIFwidXNlIGBpbXBvcnQgeyBSb3V0ZXIgfWAgaW5zdGVhZCBvZiBgaW1wb3J0IHsgQnJvd3NlclJvdXRlciBhcyBSb3V0ZXIgfWAuXCIpIDogdm9pZCAwO1xuICB9O1xufVxuXG4vKipcbiAqIFRoZSBwdWJsaWMgQVBJIGZvciBhIDxSb3V0ZXI+IHRoYXQgdXNlcyB3aW5kb3cubG9jYXRpb24uaGFzaC5cbiAqL1xuXG52YXIgSGFzaFJvdXRlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX1JlYWN0JENvbXBvbmVudCkge1xuICBfaW5oZXJpdHNMb29zZShIYXNoUm91dGVyLCBfUmVhY3QkQ29tcG9uZW50KTtcblxuICBmdW5jdGlvbiBIYXNoUm91dGVyKCkge1xuICAgIHZhciBfdGhpcztcblxuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICBfdGhpcyA9IF9SZWFjdCRDb21wb25lbnQuY2FsbC5hcHBseShfUmVhY3QkQ29tcG9uZW50LCBbdGhpc10uY29uY2F0KGFyZ3MpKSB8fCB0aGlzO1xuICAgIF90aGlzLmhpc3RvcnkgPSBjcmVhdGVIYXNoSGlzdG9yeShfdGhpcy5wcm9wcyk7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IEhhc2hSb3V0ZXIucHJvdG90eXBlO1xuXG4gIF9wcm90by5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFJvdXRlciwge1xuICAgICAgaGlzdG9yeTogdGhpcy5oaXN0b3J5LFxuICAgICAgY2hpbGRyZW46IHRoaXMucHJvcHMuY2hpbGRyZW5cbiAgICB9KTtcbiAgfTtcblxuICByZXR1cm4gSGFzaFJvdXRlcjtcbn0oUmVhY3QuQ29tcG9uZW50KTtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICBIYXNoUm91dGVyLnByb3BUeXBlcyA9IHtcbiAgICBiYXNlbmFtZTogUHJvcFR5cGVzLnN0cmluZyxcbiAgICBjaGlsZHJlbjogUHJvcFR5cGVzLm5vZGUsXG4gICAgZ2V0VXNlckNvbmZpcm1hdGlvbjogUHJvcFR5cGVzLmZ1bmMsXG4gICAgaGFzaFR5cGU6IFByb3BUeXBlcy5vbmVPZihbXCJoYXNoYmFuZ1wiLCBcIm5vc2xhc2hcIiwgXCJzbGFzaFwiXSlcbiAgfTtcblxuICBIYXNoUm91dGVyLnByb3RvdHlwZS5jb21wb25lbnREaWRNb3VudCA9IGZ1bmN0aW9uICgpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyB3YXJuaW5nKCF0aGlzLnByb3BzLmhpc3RvcnksIFwiPEhhc2hSb3V0ZXI+IGlnbm9yZXMgdGhlIGhpc3RvcnkgcHJvcC4gVG8gdXNlIGEgY3VzdG9tIGhpc3RvcnksIFwiICsgXCJ1c2UgYGltcG9ydCB7IFJvdXRlciB9YCBpbnN0ZWFkIG9mIGBpbXBvcnQgeyBIYXNoUm91dGVyIGFzIFJvdXRlciB9YC5cIikgOiB2b2lkIDA7XG4gIH07XG59XG5cbnZhciByZXNvbHZlVG9Mb2NhdGlvbiA9IGZ1bmN0aW9uIHJlc29sdmVUb0xvY2F0aW9uKHRvLCBjdXJyZW50TG9jYXRpb24pIHtcbiAgcmV0dXJuIHR5cGVvZiB0byA9PT0gXCJmdW5jdGlvblwiID8gdG8oY3VycmVudExvY2F0aW9uKSA6IHRvO1xufTtcbnZhciBub3JtYWxpemVUb0xvY2F0aW9uID0gZnVuY3Rpb24gbm9ybWFsaXplVG9Mb2NhdGlvbih0bywgY3VycmVudExvY2F0aW9uKSB7XG4gIHJldHVybiB0eXBlb2YgdG8gPT09IFwic3RyaW5nXCIgPyBjcmVhdGVMb2NhdGlvbih0bywgbnVsbCwgbnVsbCwgY3VycmVudExvY2F0aW9uKSA6IHRvO1xufTtcblxudmFyIGZvcndhcmRSZWZTaGltID0gZnVuY3Rpb24gZm9yd2FyZFJlZlNoaW0oQykge1xuICByZXR1cm4gQztcbn07XG5cbnZhciBmb3J3YXJkUmVmID0gUmVhY3QuZm9yd2FyZFJlZjtcblxuaWYgKHR5cGVvZiBmb3J3YXJkUmVmID09PSBcInVuZGVmaW5lZFwiKSB7XG4gIGZvcndhcmRSZWYgPSBmb3J3YXJkUmVmU2hpbTtcbn1cblxuZnVuY3Rpb24gaXNNb2RpZmllZEV2ZW50KGV2ZW50KSB7XG4gIHJldHVybiAhIShldmVudC5tZXRhS2V5IHx8IGV2ZW50LmFsdEtleSB8fCBldmVudC5jdHJsS2V5IHx8IGV2ZW50LnNoaWZ0S2V5KTtcbn1cblxudmFyIExpbmtBbmNob3IgPSBmb3J3YXJkUmVmKGZ1bmN0aW9uIChfcmVmLCBmb3J3YXJkZWRSZWYpIHtcbiAgdmFyIGlubmVyUmVmID0gX3JlZi5pbm5lclJlZixcbiAgICAgIG5hdmlnYXRlID0gX3JlZi5uYXZpZ2F0ZSxcbiAgICAgIF9vbkNsaWNrID0gX3JlZi5vbkNsaWNrLFxuICAgICAgcmVzdCA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKF9yZWYsIFtcImlubmVyUmVmXCIsIFwibmF2aWdhdGVcIiwgXCJvbkNsaWNrXCJdKTtcblxuICB2YXIgdGFyZ2V0ID0gcmVzdC50YXJnZXQ7XG5cbiAgdmFyIHByb3BzID0gX2V4dGVuZHMoe30sIHJlc3QsIHtcbiAgICBvbkNsaWNrOiBmdW5jdGlvbiBvbkNsaWNrKGV2ZW50KSB7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAoX29uQ2xpY2spIF9vbkNsaWNrKGV2ZW50KTtcbiAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIHRocm93IGV4O1xuICAgICAgfVxuXG4gICAgICBpZiAoIWV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQgJiYgLy8gb25DbGljayBwcmV2ZW50ZWQgZGVmYXVsdFxuICAgICAgZXZlbnQuYnV0dG9uID09PSAwICYmICggLy8gaWdub3JlIGV2ZXJ5dGhpbmcgYnV0IGxlZnQgY2xpY2tzXG4gICAgICAhdGFyZ2V0IHx8IHRhcmdldCA9PT0gXCJfc2VsZlwiKSAmJiAvLyBsZXQgYnJvd3NlciBoYW5kbGUgXCJ0YXJnZXQ9X2JsYW5rXCIgZXRjLlxuICAgICAgIWlzTW9kaWZpZWRFdmVudChldmVudCkgLy8gaWdub3JlIGNsaWNrcyB3aXRoIG1vZGlmaWVyIGtleXNcbiAgICAgICkge1xuICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgbmF2aWdhdGUoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgfSk7IC8vIFJlYWN0IDE1IGNvbXBhdFxuXG5cbiAgaWYgKGZvcndhcmRSZWZTaGltICE9PSBmb3J3YXJkUmVmKSB7XG4gICAgcHJvcHMucmVmID0gZm9yd2FyZGVkUmVmIHx8IGlubmVyUmVmO1xuICB9IGVsc2Uge1xuICAgIHByb3BzLnJlZiA9IGlubmVyUmVmO1xuICB9XG4gIC8qIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBqc3gtYTExeS9hbmNob3ItaGFzLWNvbnRlbnQgKi9cblxuXG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcImFcIiwgcHJvcHMpO1xufSk7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgTGlua0FuY2hvci5kaXNwbGF5TmFtZSA9IFwiTGlua0FuY2hvclwiO1xufVxuLyoqXG4gKiBUaGUgcHVibGljIEFQSSBmb3IgcmVuZGVyaW5nIGEgaGlzdG9yeS1hd2FyZSA8YT4uXG4gKi9cblxuXG52YXIgTGluayA9IGZvcndhcmRSZWYoZnVuY3Rpb24gKF9yZWYyLCBmb3J3YXJkZWRSZWYpIHtcbiAgdmFyIF9yZWYyJGNvbXBvbmVudCA9IF9yZWYyLmNvbXBvbmVudCxcbiAgICAgIGNvbXBvbmVudCA9IF9yZWYyJGNvbXBvbmVudCA9PT0gdm9pZCAwID8gTGlua0FuY2hvciA6IF9yZWYyJGNvbXBvbmVudCxcbiAgICAgIHJlcGxhY2UgPSBfcmVmMi5yZXBsYWNlLFxuICAgICAgdG8gPSBfcmVmMi50byxcbiAgICAgIGlubmVyUmVmID0gX3JlZjIuaW5uZXJSZWYsXG4gICAgICByZXN0ID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UoX3JlZjIsIFtcImNvbXBvbmVudFwiLCBcInJlcGxhY2VcIiwgXCJ0b1wiLCBcImlubmVyUmVmXCJdKTtcblxuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoX19Sb3V0ZXJDb250ZXh0LkNvbnN1bWVyLCBudWxsLCBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgICFjb250ZXh0ID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCBcIllvdSBzaG91bGQgbm90IHVzZSA8TGluaz4gb3V0c2lkZSBhIDxSb3V0ZXI+XCIpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgICB2YXIgaGlzdG9yeSA9IGNvbnRleHQuaGlzdG9yeTtcbiAgICB2YXIgbG9jYXRpb24gPSBub3JtYWxpemVUb0xvY2F0aW9uKHJlc29sdmVUb0xvY2F0aW9uKHRvLCBjb250ZXh0LmxvY2F0aW9uKSwgY29udGV4dC5sb2NhdGlvbik7XG4gICAgdmFyIGhyZWYgPSBsb2NhdGlvbiA/IGhpc3RvcnkuY3JlYXRlSHJlZihsb2NhdGlvbikgOiBcIlwiO1xuXG4gICAgdmFyIHByb3BzID0gX2V4dGVuZHMoe30sIHJlc3QsIHtcbiAgICAgIGhyZWY6IGhyZWYsXG4gICAgICBuYXZpZ2F0ZTogZnVuY3Rpb24gbmF2aWdhdGUoKSB7XG4gICAgICAgIHZhciBsb2NhdGlvbiA9IHJlc29sdmVUb0xvY2F0aW9uKHRvLCBjb250ZXh0LmxvY2F0aW9uKTtcbiAgICAgICAgdmFyIGlzRHVwbGljYXRlTmF2aWdhdGlvbiA9IGNyZWF0ZVBhdGgoY29udGV4dC5sb2NhdGlvbikgPT09IGNyZWF0ZVBhdGgobm9ybWFsaXplVG9Mb2NhdGlvbihsb2NhdGlvbikpO1xuICAgICAgICB2YXIgbWV0aG9kID0gcmVwbGFjZSB8fCBpc0R1cGxpY2F0ZU5hdmlnYXRpb24gPyBoaXN0b3J5LnJlcGxhY2UgOiBoaXN0b3J5LnB1c2g7XG4gICAgICAgIG1ldGhvZChsb2NhdGlvbik7XG4gICAgICB9XG4gICAgfSk7IC8vIFJlYWN0IDE1IGNvbXBhdFxuXG5cbiAgICBpZiAoZm9yd2FyZFJlZlNoaW0gIT09IGZvcndhcmRSZWYpIHtcbiAgICAgIHByb3BzLnJlZiA9IGZvcndhcmRlZFJlZiB8fCBpbm5lclJlZjtcbiAgICB9IGVsc2Uge1xuICAgICAgcHJvcHMuaW5uZXJSZWYgPSBpbm5lclJlZjtcbiAgICB9XG5cbiAgICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoY29tcG9uZW50LCBwcm9wcyk7XG4gIH0pO1xufSk7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgdmFyIHRvVHlwZSA9IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5zdHJpbmcsIFByb3BUeXBlcy5vYmplY3QsIFByb3BUeXBlcy5mdW5jXSk7XG4gIHZhciByZWZUeXBlID0gUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLnN0cmluZywgUHJvcFR5cGVzLmZ1bmMsIFByb3BUeXBlcy5zaGFwZSh7XG4gICAgY3VycmVudDogUHJvcFR5cGVzLmFueVxuICB9KV0pO1xuICBMaW5rLmRpc3BsYXlOYW1lID0gXCJMaW5rXCI7XG4gIExpbmsucHJvcFR5cGVzID0ge1xuICAgIGlubmVyUmVmOiByZWZUeXBlLFxuICAgIG9uQ2xpY2s6IFByb3BUeXBlcy5mdW5jLFxuICAgIHJlcGxhY2U6IFByb3BUeXBlcy5ib29sLFxuICAgIHRhcmdldDogUHJvcFR5cGVzLnN0cmluZyxcbiAgICB0bzogdG9UeXBlLmlzUmVxdWlyZWRcbiAgfTtcbn1cblxudmFyIGZvcndhcmRSZWZTaGltJDEgPSBmdW5jdGlvbiBmb3J3YXJkUmVmU2hpbShDKSB7XG4gIHJldHVybiBDO1xufTtcblxudmFyIGZvcndhcmRSZWYkMSA9IFJlYWN0LmZvcndhcmRSZWY7XG5cbmlmICh0eXBlb2YgZm9yd2FyZFJlZiQxID09PSBcInVuZGVmaW5lZFwiKSB7XG4gIGZvcndhcmRSZWYkMSA9IGZvcndhcmRSZWZTaGltJDE7XG59XG5cbmZ1bmN0aW9uIGpvaW5DbGFzc25hbWVzKCkge1xuICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgY2xhc3NuYW1lcyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICBjbGFzc25hbWVzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICB9XG5cbiAgcmV0dXJuIGNsYXNzbmFtZXMuZmlsdGVyKGZ1bmN0aW9uIChpKSB7XG4gICAgcmV0dXJuIGk7XG4gIH0pLmpvaW4oXCIgXCIpO1xufVxuLyoqXG4gKiBBIDxMaW5rPiB3cmFwcGVyIHRoYXQga25vd3MgaWYgaXQncyBcImFjdGl2ZVwiIG9yIG5vdC5cbiAqL1xuXG5cbnZhciBOYXZMaW5rID0gZm9yd2FyZFJlZiQxKGZ1bmN0aW9uIChfcmVmLCBmb3J3YXJkZWRSZWYpIHtcbiAgdmFyIF9yZWYkYXJpYUN1cnJlbnQgPSBfcmVmW1wiYXJpYS1jdXJyZW50XCJdLFxuICAgICAgYXJpYUN1cnJlbnQgPSBfcmVmJGFyaWFDdXJyZW50ID09PSB2b2lkIDAgPyBcInBhZ2VcIiA6IF9yZWYkYXJpYUN1cnJlbnQsXG4gICAgICBfcmVmJGFjdGl2ZUNsYXNzTmFtZSA9IF9yZWYuYWN0aXZlQ2xhc3NOYW1lLFxuICAgICAgYWN0aXZlQ2xhc3NOYW1lID0gX3JlZiRhY3RpdmVDbGFzc05hbWUgPT09IHZvaWQgMCA/IFwiYWN0aXZlXCIgOiBfcmVmJGFjdGl2ZUNsYXNzTmFtZSxcbiAgICAgIGFjdGl2ZVN0eWxlID0gX3JlZi5hY3RpdmVTdHlsZSxcbiAgICAgIGNsYXNzTmFtZVByb3AgPSBfcmVmLmNsYXNzTmFtZSxcbiAgICAgIGV4YWN0ID0gX3JlZi5leGFjdCxcbiAgICAgIGlzQWN0aXZlUHJvcCA9IF9yZWYuaXNBY3RpdmUsXG4gICAgICBsb2NhdGlvblByb3AgPSBfcmVmLmxvY2F0aW9uLFxuICAgICAgc2Vuc2l0aXZlID0gX3JlZi5zZW5zaXRpdmUsXG4gICAgICBzdHJpY3QgPSBfcmVmLnN0cmljdCxcbiAgICAgIHN0eWxlUHJvcCA9IF9yZWYuc3R5bGUsXG4gICAgICB0byA9IF9yZWYudG8sXG4gICAgICBpbm5lclJlZiA9IF9yZWYuaW5uZXJSZWYsXG4gICAgICByZXN0ID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UoX3JlZiwgW1wiYXJpYS1jdXJyZW50XCIsIFwiYWN0aXZlQ2xhc3NOYW1lXCIsIFwiYWN0aXZlU3R5bGVcIiwgXCJjbGFzc05hbWVcIiwgXCJleGFjdFwiLCBcImlzQWN0aXZlXCIsIFwibG9jYXRpb25cIiwgXCJzZW5zaXRpdmVcIiwgXCJzdHJpY3RcIiwgXCJzdHlsZVwiLCBcInRvXCIsIFwiaW5uZXJSZWZcIl0pO1xuXG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChfX1JvdXRlckNvbnRleHQuQ29uc3VtZXIsIG51bGwsIGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgIWNvbnRleHQgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsIFwiWW91IHNob3VsZCBub3QgdXNlIDxOYXZMaW5rPiBvdXRzaWRlIGEgPFJvdXRlcj5cIikgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICAgIHZhciBjdXJyZW50TG9jYXRpb24gPSBsb2NhdGlvblByb3AgfHwgY29udGV4dC5sb2NhdGlvbjtcbiAgICB2YXIgdG9Mb2NhdGlvbiA9IG5vcm1hbGl6ZVRvTG9jYXRpb24ocmVzb2x2ZVRvTG9jYXRpb24odG8sIGN1cnJlbnRMb2NhdGlvbiksIGN1cnJlbnRMb2NhdGlvbik7XG4gICAgdmFyIHBhdGggPSB0b0xvY2F0aW9uLnBhdGhuYW1lOyAvLyBSZWdleCB0YWtlbiBmcm9tOiBodHRwczovL2dpdGh1Yi5jb20vcGlsbGFyanMvcGF0aC10by1yZWdleHAvYmxvYi9tYXN0ZXIvaW5kZXguanMjTDIwMlxuXG4gICAgdmFyIGVzY2FwZWRQYXRoID0gcGF0aCAmJiBwYXRoLnJlcGxhY2UoLyhbLisqPz1eIToke30oKVtcXF18L1xcXFxdKS9nLCBcIlxcXFwkMVwiKTtcbiAgICB2YXIgbWF0Y2ggPSBlc2NhcGVkUGF0aCA/IG1hdGNoUGF0aChjdXJyZW50TG9jYXRpb24ucGF0aG5hbWUsIHtcbiAgICAgIHBhdGg6IGVzY2FwZWRQYXRoLFxuICAgICAgZXhhY3Q6IGV4YWN0LFxuICAgICAgc2Vuc2l0aXZlOiBzZW5zaXRpdmUsXG4gICAgICBzdHJpY3Q6IHN0cmljdFxuICAgIH0pIDogbnVsbDtcbiAgICB2YXIgaXNBY3RpdmUgPSAhIShpc0FjdGl2ZVByb3AgPyBpc0FjdGl2ZVByb3AobWF0Y2gsIGN1cnJlbnRMb2NhdGlvbikgOiBtYXRjaCk7XG4gICAgdmFyIGNsYXNzTmFtZSA9IHR5cGVvZiBjbGFzc05hbWVQcm9wID09PSBcImZ1bmN0aW9uXCIgPyBjbGFzc05hbWVQcm9wKGlzQWN0aXZlKSA6IGNsYXNzTmFtZVByb3A7XG4gICAgdmFyIHN0eWxlID0gdHlwZW9mIHN0eWxlUHJvcCA9PT0gXCJmdW5jdGlvblwiID8gc3R5bGVQcm9wKGlzQWN0aXZlKSA6IHN0eWxlUHJvcDtcblxuICAgIGlmIChpc0FjdGl2ZSkge1xuICAgICAgY2xhc3NOYW1lID0gam9pbkNsYXNzbmFtZXMoY2xhc3NOYW1lLCBhY3RpdmVDbGFzc05hbWUpO1xuICAgICAgc3R5bGUgPSBfZXh0ZW5kcyh7fSwgc3R5bGUsIGFjdGl2ZVN0eWxlKTtcbiAgICB9XG5cbiAgICB2YXIgcHJvcHMgPSBfZXh0ZW5kcyh7XG4gICAgICBcImFyaWEtY3VycmVudFwiOiBpc0FjdGl2ZSAmJiBhcmlhQ3VycmVudCB8fCBudWxsLFxuICAgICAgY2xhc3NOYW1lOiBjbGFzc05hbWUsXG4gICAgICBzdHlsZTogc3R5bGUsXG4gICAgICB0bzogdG9Mb2NhdGlvblxuICAgIH0sIHJlc3QpOyAvLyBSZWFjdCAxNSBjb21wYXRcblxuXG4gICAgaWYgKGZvcndhcmRSZWZTaGltJDEgIT09IGZvcndhcmRSZWYkMSkge1xuICAgICAgcHJvcHMucmVmID0gZm9yd2FyZGVkUmVmIHx8IGlubmVyUmVmO1xuICAgIH0gZWxzZSB7XG4gICAgICBwcm9wcy5pbm5lclJlZiA9IGlubmVyUmVmO1xuICAgIH1cblxuICAgIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChMaW5rLCBwcm9wcyk7XG4gIH0pO1xufSk7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgTmF2TGluay5kaXNwbGF5TmFtZSA9IFwiTmF2TGlua1wiO1xuICB2YXIgYXJpYUN1cnJlbnRUeXBlID0gUHJvcFR5cGVzLm9uZU9mKFtcInBhZ2VcIiwgXCJzdGVwXCIsIFwibG9jYXRpb25cIiwgXCJkYXRlXCIsIFwidGltZVwiLCBcInRydWVcIiwgXCJmYWxzZVwiXSk7XG4gIE5hdkxpbmsucHJvcFR5cGVzID0gX2V4dGVuZHMoe30sIExpbmsucHJvcFR5cGVzLCB7XG4gICAgXCJhcmlhLWN1cnJlbnRcIjogYXJpYUN1cnJlbnRUeXBlLFxuICAgIGFjdGl2ZUNsYXNzTmFtZTogUHJvcFR5cGVzLnN0cmluZyxcbiAgICBhY3RpdmVTdHlsZTogUHJvcFR5cGVzLm9iamVjdCxcbiAgICBjbGFzc05hbWU6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5zdHJpbmcsIFByb3BUeXBlcy5mdW5jXSksXG4gICAgZXhhY3Q6IFByb3BUeXBlcy5ib29sLFxuICAgIGlzQWN0aXZlOiBQcm9wVHlwZXMuZnVuYyxcbiAgICBsb2NhdGlvbjogUHJvcFR5cGVzLm9iamVjdCxcbiAgICBzZW5zaXRpdmU6IFByb3BUeXBlcy5ib29sLFxuICAgIHN0cmljdDogUHJvcFR5cGVzLmJvb2wsXG4gICAgc3R5bGU6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5vYmplY3QsIFByb3BUeXBlcy5mdW5jXSlcbiAgfSk7XG59XG5cbmV4cG9ydCB7IEJyb3dzZXJSb3V0ZXIsIEhhc2hSb3V0ZXIsIExpbmssIE5hdkxpbmsgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlYWN0LXJvdXRlci1kb20uanMubWFwXG4iLCJpbXBvcnQgeyBpc1ZhbGlkRWxlbWVudCwgZm9yd2FyZFJlZiwgY2xvbmVFbGVtZW50LCBjcmVhdGVFbGVtZW50IH0gZnJvbSAncmVhY3QnO1xyXG5pbXBvcnQgY2xhc3NuYW1lcyBmcm9tICdjbGFzc25hbWVzJztcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVDb21wb25lbnQoeyBkaXNwbGF5TmFtZSwgcHJvcFR5cGVzLCBkZWZhdWx0UHJvcHMsIH0sIGZuKSB7XHJcbiAgICBjb25zdCBDb21wb25lbnQgPSBmbi5sZW5ndGggPiAxID8gZm9yd2FyZFJlZihmbikgOiBmbjtcclxuXHJcbiAgICBDb21wb25lbnQuZGlzcGxheU5hbWUgPSBkaXNwbGF5TmFtZTtcclxuICAgIENvbXBvbmVudC5wcm9wVHlwZXMgPSBwcm9wVHlwZXM7XHJcbiAgICBDb21wb25lbnQuZGVmYXVsdFByb3BzID0gZGVmYXVsdFByb3BzO1xyXG5cclxuICAgIHJldHVybiBDb21wb25lbnQ7XHJcbn1cclxuXHJcbmV4cG9ydCBjb25zdCBDbG9uZSA9IGZvcndhcmRSZWYoZnVuY3Rpb24gQ2xvbmUoe1xyXG4gICAgY29tcG9uZW50LFxyXG4gICAgZmFsbGJhY2ssXHJcblxyXG4gICAgY2xhc3NOYW1lLFxyXG4gICAgY2hpbGRyZW4gPSBjb21wb25lbnQsXHJcbiAgICAuLi5wcm9wc1xyXG59LCByZWYpIHtcclxuICAgIGlmIChpc1ZhbGlkRWxlbWVudChjb21wb25lbnQpKSB7XHJcbiAgICAgICAgcmV0dXJuIGNsb25lRWxlbWVudChjb21wb25lbnQsIHtcclxuICAgICAgICAgICAgcmVmLFxyXG4gICAgICAgICAgICBjbGFzc05hbWU6IGNsYXNzbmFtZXMoY2xhc3NOYW1lLCBjb21wb25lbnQucHJvcHMuY2xhc3NOYW1lKSxcclxuICAgICAgICAgICAgLi4ucHJvcHNcclxuICAgICAgICB9KTtcclxuICAgIH0gZWxzZSBpZiAoaXNWYWxpZEVsZW1lbnQoZmFsbGJhY2spKSB7XHJcbiAgICAgICAgcmV0dXJuIGNsb25lRWxlbWVudChmYWxsYmFjaywge1xyXG4gICAgICAgICAgICByZWYsXHJcbiAgICAgICAgICAgIGNsYXNzTmFtZTogY2xhc3NuYW1lcyhjbGFzc05hbWUsIGZhbGxiYWNrLnByb3BzLmNsYXNzTmFtZSksXHJcbiAgICAgICAgICAgIC4uLnByb3BzXHJcbiAgICAgICAgfSk7XHJcbiAgICB9IGVsc2UgaWYgKGZhbGxiYWNrKSB7XHJcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUVsZW1lbnQoZmFsbGJhY2ssIHtcclxuICAgICAgICAgICAgcmVmLFxyXG4gICAgICAgICAgICBjbGFzc05hbWUsXHJcbiAgICAgICAgICAgIC4uLnByb3BzXHJcbiAgICAgICAgfSwgY2hpbGRyZW4pO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICByZXR1cm4gY2hpbGRyZW47XHJcbiAgICB9XHJcbn0pO1xyXG5cclxuZXhwb3J0IHtcclxuICAgIGlzVmFsaWRFbGVtZW50IGFzIGlzRWxlbWVudCxcclxuICAgIGNsb25lRWxlbWVudCBhcyBjbG9uZSxcclxuICAgIGNyZWF0ZUVsZW1lbnQgYXMgY3JlYXRlXHJcbn07IiwiZXhwb3J0IGNvbnN0IGNzc0NsYXNzZXMgPSB7XHJcbiAgICBST09UOiAnbWRjLWljb24nLFxyXG4gICAgTUFURVJJQUxfSUNPTlM6ICdtYXRlcmlhbC1pY29ucycsXHJcbiAgICBMSUdIVDogJ21kYy1pY29uLS1saWdodCcsXHJcbiAgICBEQVJLOiAnbWRjLWljb24tLWRhcmsnLFxyXG4gICAgSU5BQ1RJVkU6ICdtZGMtaWNvbi0taW5hY3RpdmUnXHJcbn07IiwiaW1wb3J0IHsgZm9yd2FyZFJlZiB9IGZyb20gJ3JlYWN0JztcclxuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcclxuaW1wb3J0IGNsYXNzbmFtZXMgZnJvbSAnY2xhc3NuYW1lcyc7XHJcblxyXG5pbXBvcnQgeyBjc3NDbGFzc2VzIH0gZnJvbSAnLi9jb25zdGFudHMnO1xyXG5cclxuY29uc3QgSWNvbiA9IGZvcndhcmRSZWYoKHtcclxuICAgIHNpemUsXHJcbiAgICBsaWdodCA9IGZhbHNlLFxyXG4gICAgZGFyayA9IGZhbHNlLFxyXG4gICAgaW5hY3RpdmUgPSBmYWxzZSxcclxuXHJcbiAgICBlbGVtZW50ID0gJ2knLFxyXG4gICAgY29tcG9uZW50OiBFbGVtZW50ID0gZWxlbWVudCxcclxuICAgIGNsYXNzTmFtZSxcclxuICAgIC4uLnByb3BzXHJcbn0sIHJlZikgPT4ge1xyXG4gICAgY29uc3QgY2xhc3NOYW1lcyA9IGNsYXNzbmFtZXMoY3NzQ2xhc3Nlcy5ST09ULCBjc3NDbGFzc2VzLk1BVEVSSUFMX0lDT05TLCB7XHJcbiAgICAgICAgW2Ake2Nzc0NsYXNzZXMuUk9PVH0tLSR7c2l6ZX1gXTogc2l6ZSxcclxuICAgICAgICBbY3NzQ2xhc3Nlcy5MSUdIVF06IGxpZ2h0LFxyXG4gICAgICAgIFtjc3NDbGFzc2VzLkRBUktdOiBkYXJrLFxyXG4gICAgICAgIFtjc3NDbGFzc2VzLklOQUNUSVZFXTogaW5hY3RpdmVcclxuICAgIH0sIGNsYXNzTmFtZSk7XHJcblxyXG4gICAgcmV0dXJuIChcclxuICAgICAgICA8RWxlbWVudCByZWY9e3JlZn0gY2xhc3NOYW1lPXtjbGFzc05hbWVzfSB7Li4ucHJvcHN9IC8+XHJcbiAgICApO1xyXG59KTtcclxuXHJcbkljb24uZGlzcGxheU5hbWUgPSAnTURDSWNvbic7XHJcblxyXG5JY29uLnByb3BUeXBlcyA9IHtcclxuICAgIHNpemU6IFByb3BUeXBlcy5zdHJpbmcsXHJcbiAgICBkYXJrOiBQcm9wVHlwZXMuYm9vbCxcclxuICAgIGxpZ2h0OiBQcm9wVHlwZXMuYm9vbCxcclxuICAgIGluYWN0aXZlOiBQcm9wVHlwZXMuYm9vbFxyXG59O1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgSWNvbjsiLCJleHBvcnQgeyBkZWZhdWx0IH0gZnJvbSAnLi9JY29uJzsiLCJleHBvcnQgY29uc3QgY3NzQ2xhc3NlcyA9IHtcclxuICAgIFJPT1Q6ICdtZGMtYXZhdGFyJyxcclxuICAgIFNNQUxMOiAnbWRjLWF2YXRhci0tc21hbGwnLFxyXG4gICAgTUVESVVNOiAnbWRjLWF2YXRhci0tbWVkaXVtJyxcclxuICAgIExBUkdFOiAnbWRjLWF2YXRhci0tbGFyZ2UnLFxyXG5cclxuICAgIElNQUdFOiAnbWRjLWF2YXRhcl9faW1hZ2UnLFxyXG4gICAgSUNPTjogJ21kYy1hdmF0YXJfX2ljb24nLFxyXG4gICAgVEVYVDogJ21kYy1hdmF0YXJfX3RleHQnXHJcbn07IiwiaW1wb3J0IHsgZm9yd2FyZFJlZiB9IGZyb20gJ3JlYWN0JztcclxuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcclxuaW1wb3J0IGNsYXNzbmFtZXMgZnJvbSAnY2xhc3NuYW1lcyc7XHJcblxyXG5pbXBvcnQgeyBDbG9uZSB9IGZyb20gJy4uL2NvbXBvbmVudCc7XHJcbmltcG9ydCBJY29uIGZyb20gJy4uL2ljb24nO1xyXG5cclxuaW1wb3J0IHsgY3NzQ2xhc3NlcyB9IGZyb20gJy4vY29uc3RhbnRzJztcclxuXHJcbmNvbnN0IEF2YXRhciA9IGZvcndhcmRSZWYoKHtcclxuICAgIGltYWdlLFxyXG4gICAgaWNvbixcclxuICAgIHRleHQsXHJcbiAgICBzaXplLFxyXG5cclxuICAgIGVsZW1lbnQgPSAnc3BhbicsXHJcbiAgICBjb21wb25lbnQ6IEVsZW1lbnQgPSBlbGVtZW50LFxyXG4gICAgY2xhc3NOYW1lLFxyXG4gICAgY2hpbGRyZW4gPSB0ZXh0LFxyXG4gICAgLi4ucHJvcHNcclxufSwgcmVmKSA9PiB7XHJcbiAgICBjb25zdCBjbGFzc05hbWVzID0gY2xhc3NuYW1lcyhjc3NDbGFzc2VzLlJPT1QsIHtcclxuICAgICAgICBbYCR7Y3NzQ2xhc3Nlcy5ST09UfS0tJHtzaXplfWBdOiBzaXplXHJcbiAgICB9LCBjbGFzc05hbWUpO1xyXG5cclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgPEVsZW1lbnQgcmVmPXtyZWZ9IGNsYXNzTmFtZT17Y2xhc3NOYW1lc30gey4uLnByb3BzfT5cclxuICAgICAgICAgICAge2ltYWdlICYmXHJcbiAgICAgICAgICAgICAgICA8aW1nXHJcbiAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPXtjc3NDbGFzc2VzLklNQUdFfVxyXG4gICAgICAgICAgICAgICAgICAgIHNyYz17aW1hZ2U/LnNyYyB8fCBpbWFnZX1cclxuICAgICAgICAgICAgICAgICAgICBhbHQ9e2ltYWdlPy5hbHQgfHwgJyd9XHJcbiAgICAgICAgICAgICAgICAvPlxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB7aWNvbiAmJlxyXG4gICAgICAgICAgICAgICAgPENsb25lXHJcbiAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50PXtpY29ufVxyXG4gICAgICAgICAgICAgICAgICAgIGZhbGxiYWNrPXtJY29ufVxyXG4gICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT17Y3NzQ2xhc3Nlcy5JQ09OfVxyXG4gICAgICAgICAgICAgICAgLz5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAge2NoaWxkcmVuICYmXHJcbiAgICAgICAgICAgICAgICA8Q2xvbmVcclxuICAgICAgICAgICAgICAgICAgICBjb21wb25lbnQ9e2NoaWxkcmVufVxyXG4gICAgICAgICAgICAgICAgICAgIGZhbGxiYWNrPVwic3BhblwiXHJcbiAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPXtjc3NDbGFzc2VzLlRFWFR9XHJcbiAgICAgICAgICAgICAgICAvPlxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgPC9FbGVtZW50PlxyXG4gICAgKTtcclxufSk7XHJcblxyXG5BdmF0YXIuZGlzcGxheU5hbWUgPSAnTURDQXZhdGFyJztcclxuXHJcbkF2YXRhci5wcm9wVHlwZXMgPSB7XHJcbiAgICBzcmM6IFByb3BUeXBlcy5zdHJpbmcsXHJcbiAgICBpY29uOiBQcm9wVHlwZXMubm9kZSxcclxuICAgIHRleHQ6IFByb3BUeXBlcy5ub2RlLFxyXG4gICAgc2l6ZTogUHJvcFR5cGVzLm9uZU9mKFsnc21hbGwnLCAnbWVkaXVtJywgJ2xhcmdlJ10pXHJcbn07XHJcblxyXG5leHBvcnQgZGVmYXVsdCBBdmF0YXI7IiwiZXhwb3J0IHsgZGVmYXVsdCB9IGZyb20gJy4vQXZhdGFyJzsiLCJleHBvcnQgY29uc3QgY3NzQ2xhc3NlcyA9IHtcclxuICAgIFJPT1Q6ICdtZGMtYmFkZ2UnLFxyXG4gICAgSU5TRVQ6ICdtZGMtYmFkZ2UtLWluc2V0JyxcclxuICAgIFRSQU5TUEFSRU5UOiAnbWRjLWJhZGdlLS10cmFuc3BhcmVudCdcclxufTsiLCJpbXBvcnQgeyBmb3J3YXJkUmVmIH0gZnJvbSAncmVhY3QnO1xyXG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xyXG5pbXBvcnQgY2xhc3NuYW1lcyBmcm9tICdjbGFzc25hbWVzJztcclxuXHJcbmltcG9ydCB7IGNzc0NsYXNzZXMgfSBmcm9tICcuL2NvbnN0YW50cyc7XHJcblxyXG5jb25zdCBCYWRnZSA9IGZvcndhcmRSZWYoKHtcclxuICAgIHZhbHVlLFxyXG4gICAgaW5zZXQgPSBmYWxzZSxcclxuICAgIHRyYW5zcGFyZW50ID0gZmFsc2UsXHJcblxyXG4gICAgZWxlbWVudDogRWxlbWVudCA9ICdzcGFuJyxcclxuICAgIGNsYXNzTmFtZSxcclxuICAgIC4uLnByb3BzXHJcbn0sIHJlZikgPT4ge1xyXG4gICAgY29uc3QgY2xhc3NOYW1lcyA9IGNsYXNzbmFtZXMoY3NzQ2xhc3Nlcy5ST09ULCB7XHJcbiAgICAgICAgW2Nzc0NsYXNzZXMuSU5TRVRdOiBpbnNldCxcclxuICAgICAgICBbY3NzQ2xhc3Nlcy5UUkFOU1BBUkVOVF06IHRyYW5zcGFyZW50XHJcbiAgICB9LCBjbGFzc05hbWUpO1xyXG5cclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgPEVsZW1lbnRcclxuICAgICAgICAgICAgcmVmPXtyZWZ9XHJcbiAgICAgICAgICAgIGNsYXNzTmFtZT17Y2xhc3NOYW1lc31cclxuICAgICAgICAgICAgZGF0YS1iYWRnZT17dmFsdWV9XHJcbiAgICAgICAgICAgIHsuLi5wcm9wc31cclxuICAgICAgICAvPlxyXG4gICAgKTtcclxufSk7XHJcblxyXG5CYWRnZS5kaXNwbGF5TmFtZSA9ICdNRENCYWRnZSc7XHJcblxyXG5CYWRnZS5wcm9wVHlwZXMgPSB7XHJcbiAgICB2YWx1ZTogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLm51bWJlciwgUHJvcFR5cGVzLnN0cmluZ10pLmlzUmVxdWlyZWQsXHJcbiAgICBpbnNldDogUHJvcFR5cGVzLmJvb2wsXHJcbiAgICB0cmFuc3BhcmVudDogUHJvcFR5cGVzLmJvb2xcclxufTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IEJhZGdlOyIsImV4cG9ydCB7IGRlZmF1bHQgfSBmcm9tICcuL0JhZGdlJzsiLCIvKipcbiAqIENoZWNrcyBpZiBhIGdpdmVuIGVsZW1lbnQgaGFzIGEgQ1NTIGNsYXNzLlxuICogXG4gKiBAcGFyYW0gZWxlbWVudCB0aGUgZWxlbWVudFxuICogQHBhcmFtIGNsYXNzTmFtZSB0aGUgQ1NTIGNsYXNzIG5hbWVcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gaGFzQ2xhc3MoZWxlbWVudCwgY2xhc3NOYW1lKSB7XG4gIGlmIChlbGVtZW50LmNsYXNzTGlzdCkgcmV0dXJuICEhY2xhc3NOYW1lICYmIGVsZW1lbnQuY2xhc3NMaXN0LmNvbnRhaW5zKGNsYXNzTmFtZSk7XG4gIHJldHVybiAoXCIgXCIgKyAoZWxlbWVudC5jbGFzc05hbWUuYmFzZVZhbCB8fCBlbGVtZW50LmNsYXNzTmFtZSkgKyBcIiBcIikuaW5kZXhPZihcIiBcIiArIGNsYXNzTmFtZSArIFwiIFwiKSAhPT0gLTE7XG59IiwiaW1wb3J0IGhhc0NsYXNzIGZyb20gJy4vaGFzQ2xhc3MnO1xuLyoqXG4gKiBBZGRzIGEgQ1NTIGNsYXNzIHRvIGEgZ2l2ZW4gZWxlbWVudC5cbiAqIFxuICogQHBhcmFtIGVsZW1lbnQgdGhlIGVsZW1lbnRcbiAqIEBwYXJhbSBjbGFzc05hbWUgdGhlIENTUyBjbGFzcyBuYW1lXG4gKi9cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gYWRkQ2xhc3MoZWxlbWVudCwgY2xhc3NOYW1lKSB7XG4gIGlmIChlbGVtZW50LmNsYXNzTGlzdCkgZWxlbWVudC5jbGFzc0xpc3QuYWRkKGNsYXNzTmFtZSk7ZWxzZSBpZiAoIWhhc0NsYXNzKGVsZW1lbnQsIGNsYXNzTmFtZSkpIGlmICh0eXBlb2YgZWxlbWVudC5jbGFzc05hbWUgPT09ICdzdHJpbmcnKSBlbGVtZW50LmNsYXNzTmFtZSA9IGVsZW1lbnQuY2xhc3NOYW1lICsgXCIgXCIgKyBjbGFzc05hbWU7ZWxzZSBlbGVtZW50LnNldEF0dHJpYnV0ZSgnY2xhc3MnLCAoZWxlbWVudC5jbGFzc05hbWUgJiYgZWxlbWVudC5jbGFzc05hbWUuYmFzZVZhbCB8fCAnJykgKyBcIiBcIiArIGNsYXNzTmFtZSk7XG59IiwiZnVuY3Rpb24gcmVwbGFjZUNsYXNzTmFtZShvcmlnQ2xhc3MsIGNsYXNzVG9SZW1vdmUpIHtcbiAgcmV0dXJuIG9yaWdDbGFzcy5yZXBsYWNlKG5ldyBSZWdFeHAoXCIoXnxcXFxccylcIiArIGNsYXNzVG9SZW1vdmUgKyBcIig/OlxcXFxzfCQpXCIsICdnJyksICckMScpLnJlcGxhY2UoL1xccysvZywgJyAnKS5yZXBsYWNlKC9eXFxzKnxcXHMqJC9nLCAnJyk7XG59XG4vKipcbiAqIFJlbW92ZXMgYSBDU1MgY2xhc3MgZnJvbSBhIGdpdmVuIGVsZW1lbnQuXG4gKiBcbiAqIEBwYXJhbSBlbGVtZW50IHRoZSBlbGVtZW50XG4gKiBAcGFyYW0gY2xhc3NOYW1lIHRoZSBDU1MgY2xhc3MgbmFtZVxuICovXG5cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gcmVtb3ZlQ2xhc3MoZWxlbWVudCwgY2xhc3NOYW1lKSB7XG4gIGlmIChlbGVtZW50LmNsYXNzTGlzdCkge1xuICAgIGVsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZShjbGFzc05hbWUpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBlbGVtZW50LmNsYXNzTmFtZSA9PT0gJ3N0cmluZycpIHtcbiAgICBlbGVtZW50LmNsYXNzTmFtZSA9IHJlcGxhY2VDbGFzc05hbWUoZWxlbWVudC5jbGFzc05hbWUsIGNsYXNzTmFtZSk7XG4gIH0gZWxzZSB7XG4gICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgcmVwbGFjZUNsYXNzTmFtZShlbGVtZW50LmNsYXNzTmFtZSAmJiBlbGVtZW50LmNsYXNzTmFtZS5iYXNlVmFsIHx8ICcnLCBjbGFzc05hbWUpKTtcbiAgfVxufSIsImV4cG9ydCBkZWZhdWx0IHtcbiAgZGlzYWJsZWQ6IGZhbHNlXG59OyIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5leHBvcnQgZGVmYXVsdCBSZWFjdC5jcmVhdGVDb250ZXh0KG51bGwpOyIsImltcG9ydCBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZSBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZVwiO1xuaW1wb3J0IF9pbmhlcml0c0xvb3NlIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9pbmhlcml0c0xvb3NlXCI7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBSZWFjdERPTSBmcm9tICdyZWFjdC1kb20nO1xuaW1wb3J0IGNvbmZpZyBmcm9tICcuL2NvbmZpZyc7XG5pbXBvcnQgeyB0aW1lb3V0c1NoYXBlIH0gZnJvbSAnLi91dGlscy9Qcm9wVHlwZXMnO1xuaW1wb3J0IFRyYW5zaXRpb25Hcm91cENvbnRleHQgZnJvbSAnLi9UcmFuc2l0aW9uR3JvdXBDb250ZXh0JztcbmV4cG9ydCB2YXIgVU5NT1VOVEVEID0gJ3VubW91bnRlZCc7XG5leHBvcnQgdmFyIEVYSVRFRCA9ICdleGl0ZWQnO1xuZXhwb3J0IHZhciBFTlRFUklORyA9ICdlbnRlcmluZyc7XG5leHBvcnQgdmFyIEVOVEVSRUQgPSAnZW50ZXJlZCc7XG5leHBvcnQgdmFyIEVYSVRJTkcgPSAnZXhpdGluZyc7XG4vKipcbiAqIFRoZSBUcmFuc2l0aW9uIGNvbXBvbmVudCBsZXRzIHlvdSBkZXNjcmliZSBhIHRyYW5zaXRpb24gZnJvbSBvbmUgY29tcG9uZW50XG4gKiBzdGF0ZSB0byBhbm90aGVyIF9vdmVyIHRpbWVfIHdpdGggYSBzaW1wbGUgZGVjbGFyYXRpdmUgQVBJLiBNb3N0IGNvbW1vbmx5XG4gKiBpdCdzIHVzZWQgdG8gYW5pbWF0ZSB0aGUgbW91bnRpbmcgYW5kIHVubW91bnRpbmcgb2YgYSBjb21wb25lbnQsIGJ1dCBjYW4gYWxzb1xuICogYmUgdXNlZCB0byBkZXNjcmliZSBpbi1wbGFjZSB0cmFuc2l0aW9uIHN0YXRlcyBhcyB3ZWxsLlxuICpcbiAqIC0tLVxuICpcbiAqICoqTm90ZSoqOiBgVHJhbnNpdGlvbmAgaXMgYSBwbGF0Zm9ybS1hZ25vc3RpYyBiYXNlIGNvbXBvbmVudC4gSWYgeW91J3JlIHVzaW5nXG4gKiB0cmFuc2l0aW9ucyBpbiBDU1MsIHlvdSdsbCBwcm9iYWJseSB3YW50IHRvIHVzZVxuICogW2BDU1NUcmFuc2l0aW9uYF0oaHR0cHM6Ly9yZWFjdGNvbW11bml0eS5vcmcvcmVhY3QtdHJhbnNpdGlvbi1ncm91cC9jc3MtdHJhbnNpdGlvbilcbiAqIGluc3RlYWQuIEl0IGluaGVyaXRzIGFsbCB0aGUgZmVhdHVyZXMgb2YgYFRyYW5zaXRpb25gLCBidXQgY29udGFpbnNcbiAqIGFkZGl0aW9uYWwgZmVhdHVyZXMgbmVjZXNzYXJ5IHRvIHBsYXkgbmljZSB3aXRoIENTUyB0cmFuc2l0aW9ucyAoaGVuY2UgdGhlXG4gKiBuYW1lIG9mIHRoZSBjb21wb25lbnQpLlxuICpcbiAqIC0tLVxuICpcbiAqIEJ5IGRlZmF1bHQgdGhlIGBUcmFuc2l0aW9uYCBjb21wb25lbnQgZG9lcyBub3QgYWx0ZXIgdGhlIGJlaGF2aW9yIG9mIHRoZVxuICogY29tcG9uZW50IGl0IHJlbmRlcnMsIGl0IG9ubHkgdHJhY2tzIFwiZW50ZXJcIiBhbmQgXCJleGl0XCIgc3RhdGVzIGZvciB0aGVcbiAqIGNvbXBvbmVudHMuIEl0J3MgdXAgdG8geW91IHRvIGdpdmUgbWVhbmluZyBhbmQgZWZmZWN0IHRvIHRob3NlIHN0YXRlcy4gRm9yXG4gKiBleGFtcGxlIHdlIGNhbiBhZGQgc3R5bGVzIHRvIGEgY29tcG9uZW50IHdoZW4gaXQgZW50ZXJzIG9yIGV4aXRzOlxuICpcbiAqIGBgYGpzeFxuICogaW1wb3J0IHsgVHJhbnNpdGlvbiB9IGZyb20gJ3JlYWN0LXRyYW5zaXRpb24tZ3JvdXAnO1xuICpcbiAqIGNvbnN0IGR1cmF0aW9uID0gMzAwO1xuICpcbiAqIGNvbnN0IGRlZmF1bHRTdHlsZSA9IHtcbiAqICAgdHJhbnNpdGlvbjogYG9wYWNpdHkgJHtkdXJhdGlvbn1tcyBlYXNlLWluLW91dGAsXG4gKiAgIG9wYWNpdHk6IDAsXG4gKiB9XG4gKlxuICogY29uc3QgdHJhbnNpdGlvblN0eWxlcyA9IHtcbiAqICAgZW50ZXJpbmc6IHsgb3BhY2l0eTogMSB9LFxuICogICBlbnRlcmVkOiAgeyBvcGFjaXR5OiAxIH0sXG4gKiAgIGV4aXRpbmc6ICB7IG9wYWNpdHk6IDAgfSxcbiAqICAgZXhpdGVkOiAgeyBvcGFjaXR5OiAwIH0sXG4gKiB9O1xuICpcbiAqIGNvbnN0IEZhZGUgPSAoeyBpbjogaW5Qcm9wIH0pID0+IChcbiAqICAgPFRyYW5zaXRpb24gaW49e2luUHJvcH0gdGltZW91dD17ZHVyYXRpb259PlxuICogICAgIHtzdGF0ZSA9PiAoXG4gKiAgICAgICA8ZGl2IHN0eWxlPXt7XG4gKiAgICAgICAgIC4uLmRlZmF1bHRTdHlsZSxcbiAqICAgICAgICAgLi4udHJhbnNpdGlvblN0eWxlc1tzdGF0ZV1cbiAqICAgICAgIH19PlxuICogICAgICAgICBJJ20gYSBmYWRlIFRyYW5zaXRpb24hXG4gKiAgICAgICA8L2Rpdj5cbiAqICAgICApfVxuICogICA8L1RyYW5zaXRpb24+XG4gKiApO1xuICogYGBgXG4gKlxuICogVGhlcmUgYXJlIDQgbWFpbiBzdGF0ZXMgYSBUcmFuc2l0aW9uIGNhbiBiZSBpbjpcbiAqICAtIGAnZW50ZXJpbmcnYFxuICogIC0gYCdlbnRlcmVkJ2BcbiAqICAtIGAnZXhpdGluZydgXG4gKiAgLSBgJ2V4aXRlZCdgXG4gKlxuICogVHJhbnNpdGlvbiBzdGF0ZSBpcyB0b2dnbGVkIHZpYSB0aGUgYGluYCBwcm9wLiBXaGVuIGB0cnVlYCB0aGUgY29tcG9uZW50XG4gKiBiZWdpbnMgdGhlIFwiRW50ZXJcIiBzdGFnZS4gRHVyaW5nIHRoaXMgc3RhZ2UsIHRoZSBjb21wb25lbnQgd2lsbCBzaGlmdCBmcm9tXG4gKiBpdHMgY3VycmVudCB0cmFuc2l0aW9uIHN0YXRlLCB0byBgJ2VudGVyaW5nJ2AgZm9yIHRoZSBkdXJhdGlvbiBvZiB0aGVcbiAqIHRyYW5zaXRpb24gYW5kIHRoZW4gdG8gdGhlIGAnZW50ZXJlZCdgIHN0YWdlIG9uY2UgaXQncyBjb21wbGV0ZS4gTGV0J3MgdGFrZVxuICogdGhlIGZvbGxvd2luZyBleGFtcGxlICh3ZSdsbCB1c2UgdGhlXG4gKiBbdXNlU3RhdGVdKGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9ob29rcy1yZWZlcmVuY2UuaHRtbCN1c2VzdGF0ZSkgaG9vayk6XG4gKlxuICogYGBganN4XG4gKiBmdW5jdGlvbiBBcHAoKSB7XG4gKiAgIGNvbnN0IFtpblByb3AsIHNldEluUHJvcF0gPSB1c2VTdGF0ZShmYWxzZSk7XG4gKiAgIHJldHVybiAoXG4gKiAgICAgPGRpdj5cbiAqICAgICAgIDxUcmFuc2l0aW9uIGluPXtpblByb3B9IHRpbWVvdXQ9ezUwMH0+XG4gKiAgICAgICAgIHtzdGF0ZSA9PiAoXG4gKiAgICAgICAgICAgLy8gLi4uXG4gKiAgICAgICAgICl9XG4gKiAgICAgICA8L1RyYW5zaXRpb24+XG4gKiAgICAgICA8YnV0dG9uIG9uQ2xpY2s9eygpID0+IHNldEluUHJvcCh0cnVlKX0+XG4gKiAgICAgICAgIENsaWNrIHRvIEVudGVyXG4gKiAgICAgICA8L2J1dHRvbj5cbiAqICAgICA8L2Rpdj5cbiAqICAgKTtcbiAqIH1cbiAqIGBgYFxuICpcbiAqIFdoZW4gdGhlIGJ1dHRvbiBpcyBjbGlja2VkIHRoZSBjb21wb25lbnQgd2lsbCBzaGlmdCB0byB0aGUgYCdlbnRlcmluZydgIHN0YXRlXG4gKiBhbmQgc3RheSB0aGVyZSBmb3IgNTAwbXMgKHRoZSB2YWx1ZSBvZiBgdGltZW91dGApIGJlZm9yZSBpdCBmaW5hbGx5IHN3aXRjaGVzXG4gKiB0byBgJ2VudGVyZWQnYC5cbiAqXG4gKiBXaGVuIGBpbmAgaXMgYGZhbHNlYCB0aGUgc2FtZSB0aGluZyBoYXBwZW5zIGV4Y2VwdCB0aGUgc3RhdGUgbW92ZXMgZnJvbVxuICogYCdleGl0aW5nJ2AgdG8gYCdleGl0ZWQnYC5cbiAqL1xuXG52YXIgVHJhbnNpdGlvbiA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX1JlYWN0JENvbXBvbmVudCkge1xuICBfaW5oZXJpdHNMb29zZShUcmFuc2l0aW9uLCBfUmVhY3QkQ29tcG9uZW50KTtcblxuICBmdW5jdGlvbiBUcmFuc2l0aW9uKHByb3BzLCBjb250ZXh0KSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgX3RoaXMgPSBfUmVhY3QkQ29tcG9uZW50LmNhbGwodGhpcywgcHJvcHMsIGNvbnRleHQpIHx8IHRoaXM7XG4gICAgdmFyIHBhcmVudEdyb3VwID0gY29udGV4dDsgLy8gSW4gdGhlIGNvbnRleHQgb2YgYSBUcmFuc2l0aW9uR3JvdXAgYWxsIGVudGVycyBhcmUgcmVhbGx5IGFwcGVhcnNcblxuICAgIHZhciBhcHBlYXIgPSBwYXJlbnRHcm91cCAmJiAhcGFyZW50R3JvdXAuaXNNb3VudGluZyA/IHByb3BzLmVudGVyIDogcHJvcHMuYXBwZWFyO1xuICAgIHZhciBpbml0aWFsU3RhdHVzO1xuICAgIF90aGlzLmFwcGVhclN0YXR1cyA9IG51bGw7XG5cbiAgICBpZiAocHJvcHMuaW4pIHtcbiAgICAgIGlmIChhcHBlYXIpIHtcbiAgICAgICAgaW5pdGlhbFN0YXR1cyA9IEVYSVRFRDtcbiAgICAgICAgX3RoaXMuYXBwZWFyU3RhdHVzID0gRU5URVJJTkc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbml0aWFsU3RhdHVzID0gRU5URVJFRDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHByb3BzLnVubW91bnRPbkV4aXQgfHwgcHJvcHMubW91bnRPbkVudGVyKSB7XG4gICAgICAgIGluaXRpYWxTdGF0dXMgPSBVTk1PVU5URUQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbml0aWFsU3RhdHVzID0gRVhJVEVEO1xuICAgICAgfVxuICAgIH1cblxuICAgIF90aGlzLnN0YXRlID0ge1xuICAgICAgc3RhdHVzOiBpbml0aWFsU3RhdHVzXG4gICAgfTtcbiAgICBfdGhpcy5uZXh0Q2FsbGJhY2sgPSBudWxsO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIFRyYW5zaXRpb24uZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzID0gZnVuY3Rpb24gZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzKF9yZWYsIHByZXZTdGF0ZSkge1xuICAgIHZhciBuZXh0SW4gPSBfcmVmLmluO1xuXG4gICAgaWYgKG5leHRJbiAmJiBwcmV2U3RhdGUuc3RhdHVzID09PSBVTk1PVU5URUQpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHN0YXR1czogRVhJVEVEXG4gICAgICB9O1xuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9IC8vIGdldFNuYXBzaG90QmVmb3JlVXBkYXRlKHByZXZQcm9wcykge1xuICAvLyAgIGxldCBuZXh0U3RhdHVzID0gbnVsbFxuICAvLyAgIGlmIChwcmV2UHJvcHMgIT09IHRoaXMucHJvcHMpIHtcbiAgLy8gICAgIGNvbnN0IHsgc3RhdHVzIH0gPSB0aGlzLnN0YXRlXG4gIC8vICAgICBpZiAodGhpcy5wcm9wcy5pbikge1xuICAvLyAgICAgICBpZiAoc3RhdHVzICE9PSBFTlRFUklORyAmJiBzdGF0dXMgIT09IEVOVEVSRUQpIHtcbiAgLy8gICAgICAgICBuZXh0U3RhdHVzID0gRU5URVJJTkdcbiAgLy8gICAgICAgfVxuICAvLyAgICAgfSBlbHNlIHtcbiAgLy8gICAgICAgaWYgKHN0YXR1cyA9PT0gRU5URVJJTkcgfHwgc3RhdHVzID09PSBFTlRFUkVEKSB7XG4gIC8vICAgICAgICAgbmV4dFN0YXR1cyA9IEVYSVRJTkdcbiAgLy8gICAgICAgfVxuICAvLyAgICAgfVxuICAvLyAgIH1cbiAgLy8gICByZXR1cm4geyBuZXh0U3RhdHVzIH1cbiAgLy8gfVxuICA7XG5cbiAgdmFyIF9wcm90byA9IFRyYW5zaXRpb24ucHJvdG90eXBlO1xuXG4gIF9wcm90by5jb21wb25lbnREaWRNb3VudCA9IGZ1bmN0aW9uIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgIHRoaXMudXBkYXRlU3RhdHVzKHRydWUsIHRoaXMuYXBwZWFyU3RhdHVzKTtcbiAgfTtcblxuICBfcHJvdG8uY29tcG9uZW50RGlkVXBkYXRlID0gZnVuY3Rpb24gY29tcG9uZW50RGlkVXBkYXRlKHByZXZQcm9wcykge1xuICAgIHZhciBuZXh0U3RhdHVzID0gbnVsbDtcblxuICAgIGlmIChwcmV2UHJvcHMgIT09IHRoaXMucHJvcHMpIHtcbiAgICAgIHZhciBzdGF0dXMgPSB0aGlzLnN0YXRlLnN0YXR1cztcblxuICAgICAgaWYgKHRoaXMucHJvcHMuaW4pIHtcbiAgICAgICAgaWYgKHN0YXR1cyAhPT0gRU5URVJJTkcgJiYgc3RhdHVzICE9PSBFTlRFUkVEKSB7XG4gICAgICAgICAgbmV4dFN0YXR1cyA9IEVOVEVSSU5HO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoc3RhdHVzID09PSBFTlRFUklORyB8fCBzdGF0dXMgPT09IEVOVEVSRUQpIHtcbiAgICAgICAgICBuZXh0U3RhdHVzID0gRVhJVElORztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMudXBkYXRlU3RhdHVzKGZhbHNlLCBuZXh0U3RhdHVzKTtcbiAgfTtcblxuICBfcHJvdG8uY29tcG9uZW50V2lsbFVubW91bnQgPSBmdW5jdGlvbiBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICB0aGlzLmNhbmNlbE5leHRDYWxsYmFjaygpO1xuICB9O1xuXG4gIF9wcm90by5nZXRUaW1lb3V0cyA9IGZ1bmN0aW9uIGdldFRpbWVvdXRzKCkge1xuICAgIHZhciB0aW1lb3V0ID0gdGhpcy5wcm9wcy50aW1lb3V0O1xuICAgIHZhciBleGl0LCBlbnRlciwgYXBwZWFyO1xuICAgIGV4aXQgPSBlbnRlciA9IGFwcGVhciA9IHRpbWVvdXQ7XG5cbiAgICBpZiAodGltZW91dCAhPSBudWxsICYmIHR5cGVvZiB0aW1lb3V0ICE9PSAnbnVtYmVyJykge1xuICAgICAgZXhpdCA9IHRpbWVvdXQuZXhpdDtcbiAgICAgIGVudGVyID0gdGltZW91dC5lbnRlcjsgLy8gVE9ETzogcmVtb3ZlIGZhbGxiYWNrIGZvciBuZXh0IG1ham9yXG5cbiAgICAgIGFwcGVhciA9IHRpbWVvdXQuYXBwZWFyICE9PSB1bmRlZmluZWQgPyB0aW1lb3V0LmFwcGVhciA6IGVudGVyO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBleGl0OiBleGl0LFxuICAgICAgZW50ZXI6IGVudGVyLFxuICAgICAgYXBwZWFyOiBhcHBlYXJcbiAgICB9O1xuICB9O1xuXG4gIF9wcm90by51cGRhdGVTdGF0dXMgPSBmdW5jdGlvbiB1cGRhdGVTdGF0dXMobW91bnRpbmcsIG5leHRTdGF0dXMpIHtcbiAgICBpZiAobW91bnRpbmcgPT09IHZvaWQgMCkge1xuICAgICAgbW91bnRpbmcgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAobmV4dFN0YXR1cyAhPT0gbnVsbCkge1xuICAgICAgLy8gbmV4dFN0YXR1cyB3aWxsIGFsd2F5cyBiZSBFTlRFUklORyBvciBFWElUSU5HLlxuICAgICAgdGhpcy5jYW5jZWxOZXh0Q2FsbGJhY2soKTtcblxuICAgICAgaWYgKG5leHRTdGF0dXMgPT09IEVOVEVSSU5HKSB7XG4gICAgICAgIHRoaXMucGVyZm9ybUVudGVyKG1vdW50aW5nKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucGVyZm9ybUV4aXQoKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHRoaXMucHJvcHMudW5tb3VudE9uRXhpdCAmJiB0aGlzLnN0YXRlLnN0YXR1cyA9PT0gRVhJVEVEKSB7XG4gICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgc3RhdHVzOiBVTk1PVU5URURcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8ucGVyZm9ybUVudGVyID0gZnVuY3Rpb24gcGVyZm9ybUVudGVyKG1vdW50aW5nKSB7XG4gICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICB2YXIgZW50ZXIgPSB0aGlzLnByb3BzLmVudGVyO1xuICAgIHZhciBhcHBlYXJpbmcgPSB0aGlzLmNvbnRleHQgPyB0aGlzLmNvbnRleHQuaXNNb3VudGluZyA6IG1vdW50aW5nO1xuXG4gICAgdmFyIF9yZWYyID0gdGhpcy5wcm9wcy5ub2RlUmVmID8gW2FwcGVhcmluZ10gOiBbUmVhY3RET00uZmluZERPTU5vZGUodGhpcyksIGFwcGVhcmluZ10sXG4gICAgICAgIG1heWJlTm9kZSA9IF9yZWYyWzBdLFxuICAgICAgICBtYXliZUFwcGVhcmluZyA9IF9yZWYyWzFdO1xuXG4gICAgdmFyIHRpbWVvdXRzID0gdGhpcy5nZXRUaW1lb3V0cygpO1xuICAgIHZhciBlbnRlclRpbWVvdXQgPSBhcHBlYXJpbmcgPyB0aW1lb3V0cy5hcHBlYXIgOiB0aW1lb3V0cy5lbnRlcjsgLy8gbm8gZW50ZXIgYW5pbWF0aW9uIHNraXAgcmlnaHQgdG8gRU5URVJFRFxuICAgIC8vIGlmIHdlIGFyZSBtb3VudGluZyBhbmQgcnVubmluZyB0aGlzIGl0IG1lYW5zIGFwcGVhciBfbXVzdF8gYmUgc2V0XG5cbiAgICBpZiAoIW1vdW50aW5nICYmICFlbnRlciB8fCBjb25maWcuZGlzYWJsZWQpIHtcbiAgICAgIHRoaXMuc2FmZVNldFN0YXRlKHtcbiAgICAgICAgc3RhdHVzOiBFTlRFUkVEXG4gICAgICB9LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIF90aGlzMi5wcm9wcy5vbkVudGVyZWQobWF5YmVOb2RlKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMucHJvcHMub25FbnRlcihtYXliZU5vZGUsIG1heWJlQXBwZWFyaW5nKTtcbiAgICB0aGlzLnNhZmVTZXRTdGF0ZSh7XG4gICAgICBzdGF0dXM6IEVOVEVSSU5HXG4gICAgfSwgZnVuY3Rpb24gKCkge1xuICAgICAgX3RoaXMyLnByb3BzLm9uRW50ZXJpbmcobWF5YmVOb2RlLCBtYXliZUFwcGVhcmluZyk7XG5cbiAgICAgIF90aGlzMi5vblRyYW5zaXRpb25FbmQoZW50ZXJUaW1lb3V0LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIF90aGlzMi5zYWZlU2V0U3RhdGUoe1xuICAgICAgICAgIHN0YXR1czogRU5URVJFRFxuICAgICAgICB9LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgX3RoaXMyLnByb3BzLm9uRW50ZXJlZChtYXliZU5vZGUsIG1heWJlQXBwZWFyaW5nKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfTtcblxuICBfcHJvdG8ucGVyZm9ybUV4aXQgPSBmdW5jdGlvbiBwZXJmb3JtRXhpdCgpIHtcbiAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgIHZhciBleGl0ID0gdGhpcy5wcm9wcy5leGl0O1xuICAgIHZhciB0aW1lb3V0cyA9IHRoaXMuZ2V0VGltZW91dHMoKTtcbiAgICB2YXIgbWF5YmVOb2RlID0gdGhpcy5wcm9wcy5ub2RlUmVmID8gdW5kZWZpbmVkIDogUmVhY3RET00uZmluZERPTU5vZGUodGhpcyk7IC8vIG5vIGV4aXQgYW5pbWF0aW9uIHNraXAgcmlnaHQgdG8gRVhJVEVEXG5cbiAgICBpZiAoIWV4aXQgfHwgY29uZmlnLmRpc2FibGVkKSB7XG4gICAgICB0aGlzLnNhZmVTZXRTdGF0ZSh7XG4gICAgICAgIHN0YXR1czogRVhJVEVEXG4gICAgICB9LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIF90aGlzMy5wcm9wcy5vbkV4aXRlZChtYXliZU5vZGUpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5wcm9wcy5vbkV4aXQobWF5YmVOb2RlKTtcbiAgICB0aGlzLnNhZmVTZXRTdGF0ZSh7XG4gICAgICBzdGF0dXM6IEVYSVRJTkdcbiAgICB9LCBmdW5jdGlvbiAoKSB7XG4gICAgICBfdGhpczMucHJvcHMub25FeGl0aW5nKG1heWJlTm9kZSk7XG5cbiAgICAgIF90aGlzMy5vblRyYW5zaXRpb25FbmQodGltZW91dHMuZXhpdCwgZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpczMuc2FmZVNldFN0YXRlKHtcbiAgICAgICAgICBzdGF0dXM6IEVYSVRFRFxuICAgICAgICB9LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgX3RoaXMzLnByb3BzLm9uRXhpdGVkKG1heWJlTm9kZSk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH07XG5cbiAgX3Byb3RvLmNhbmNlbE5leHRDYWxsYmFjayA9IGZ1bmN0aW9uIGNhbmNlbE5leHRDYWxsYmFjaygpIHtcbiAgICBpZiAodGhpcy5uZXh0Q2FsbGJhY2sgIT09IG51bGwpIHtcbiAgICAgIHRoaXMubmV4dENhbGxiYWNrLmNhbmNlbCgpO1xuICAgICAgdGhpcy5uZXh0Q2FsbGJhY2sgPSBudWxsO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8uc2FmZVNldFN0YXRlID0gZnVuY3Rpb24gc2FmZVNldFN0YXRlKG5leHRTdGF0ZSwgY2FsbGJhY2spIHtcbiAgICAvLyBUaGlzIHNob3VsZG4ndCBiZSBuZWNlc3NhcnksIGJ1dCB0aGVyZSBhcmUgd2VpcmQgcmFjZSBjb25kaXRpb25zIHdpdGhcbiAgICAvLyBzZXRTdGF0ZSBjYWxsYmFja3MgYW5kIHVubW91bnRpbmcgaW4gdGVzdGluZywgc28gYWx3YXlzIG1ha2Ugc3VyZSB0aGF0XG4gICAgLy8gd2UgY2FuIGNhbmNlbCBhbnkgcGVuZGluZyBzZXRTdGF0ZSBjYWxsYmFja3MgYWZ0ZXIgd2UgdW5tb3VudC5cbiAgICBjYWxsYmFjayA9IHRoaXMuc2V0TmV4dENhbGxiYWNrKGNhbGxiYWNrKTtcbiAgICB0aGlzLnNldFN0YXRlKG5leHRTdGF0ZSwgY2FsbGJhY2spO1xuICB9O1xuXG4gIF9wcm90by5zZXROZXh0Q2FsbGJhY2sgPSBmdW5jdGlvbiBzZXROZXh0Q2FsbGJhY2soY2FsbGJhY2spIHtcbiAgICB2YXIgX3RoaXM0ID0gdGhpcztcblxuICAgIHZhciBhY3RpdmUgPSB0cnVlO1xuXG4gICAgdGhpcy5uZXh0Q2FsbGJhY2sgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgIGlmIChhY3RpdmUpIHtcbiAgICAgICAgYWN0aXZlID0gZmFsc2U7XG4gICAgICAgIF90aGlzNC5uZXh0Q2FsbGJhY2sgPSBudWxsO1xuICAgICAgICBjYWxsYmFjayhldmVudCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHRoaXMubmV4dENhbGxiYWNrLmNhbmNlbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGFjdGl2ZSA9IGZhbHNlO1xuICAgIH07XG5cbiAgICByZXR1cm4gdGhpcy5uZXh0Q2FsbGJhY2s7XG4gIH07XG5cbiAgX3Byb3RvLm9uVHJhbnNpdGlvbkVuZCA9IGZ1bmN0aW9uIG9uVHJhbnNpdGlvbkVuZCh0aW1lb3V0LCBoYW5kbGVyKSB7XG4gICAgdGhpcy5zZXROZXh0Q2FsbGJhY2soaGFuZGxlcik7XG4gICAgdmFyIG5vZGUgPSB0aGlzLnByb3BzLm5vZGVSZWYgPyB0aGlzLnByb3BzLm5vZGVSZWYuY3VycmVudCA6IFJlYWN0RE9NLmZpbmRET01Ob2RlKHRoaXMpO1xuICAgIHZhciBkb2VzTm90SGF2ZVRpbWVvdXRPckxpc3RlbmVyID0gdGltZW91dCA9PSBudWxsICYmICF0aGlzLnByb3BzLmFkZEVuZExpc3RlbmVyO1xuXG4gICAgaWYgKCFub2RlIHx8IGRvZXNOb3RIYXZlVGltZW91dE9yTGlzdGVuZXIpIHtcbiAgICAgIHNldFRpbWVvdXQodGhpcy5uZXh0Q2FsbGJhY2ssIDApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnByb3BzLmFkZEVuZExpc3RlbmVyKSB7XG4gICAgICB2YXIgX3JlZjMgPSB0aGlzLnByb3BzLm5vZGVSZWYgPyBbdGhpcy5uZXh0Q2FsbGJhY2tdIDogW25vZGUsIHRoaXMubmV4dENhbGxiYWNrXSxcbiAgICAgICAgICBtYXliZU5vZGUgPSBfcmVmM1swXSxcbiAgICAgICAgICBtYXliZU5leHRDYWxsYmFjayA9IF9yZWYzWzFdO1xuXG4gICAgICB0aGlzLnByb3BzLmFkZEVuZExpc3RlbmVyKG1heWJlTm9kZSwgbWF5YmVOZXh0Q2FsbGJhY2spO1xuICAgIH1cblxuICAgIGlmICh0aW1lb3V0ICE9IG51bGwpIHtcbiAgICAgIHNldFRpbWVvdXQodGhpcy5uZXh0Q2FsbGJhY2ssIHRpbWVvdXQpO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8ucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgIHZhciBzdGF0dXMgPSB0aGlzLnN0YXRlLnN0YXR1cztcblxuICAgIGlmIChzdGF0dXMgPT09IFVOTU9VTlRFRCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgdmFyIF90aGlzJHByb3BzID0gdGhpcy5wcm9wcyxcbiAgICAgICAgY2hpbGRyZW4gPSBfdGhpcyRwcm9wcy5jaGlsZHJlbixcbiAgICAgICAgX2luID0gX3RoaXMkcHJvcHMuaW4sXG4gICAgICAgIF9tb3VudE9uRW50ZXIgPSBfdGhpcyRwcm9wcy5tb3VudE9uRW50ZXIsXG4gICAgICAgIF91bm1vdW50T25FeGl0ID0gX3RoaXMkcHJvcHMudW5tb3VudE9uRXhpdCxcbiAgICAgICAgX2FwcGVhciA9IF90aGlzJHByb3BzLmFwcGVhcixcbiAgICAgICAgX2VudGVyID0gX3RoaXMkcHJvcHMuZW50ZXIsXG4gICAgICAgIF9leGl0ID0gX3RoaXMkcHJvcHMuZXhpdCxcbiAgICAgICAgX3RpbWVvdXQgPSBfdGhpcyRwcm9wcy50aW1lb3V0LFxuICAgICAgICBfYWRkRW5kTGlzdGVuZXIgPSBfdGhpcyRwcm9wcy5hZGRFbmRMaXN0ZW5lcixcbiAgICAgICAgX29uRW50ZXIgPSBfdGhpcyRwcm9wcy5vbkVudGVyLFxuICAgICAgICBfb25FbnRlcmluZyA9IF90aGlzJHByb3BzLm9uRW50ZXJpbmcsXG4gICAgICAgIF9vbkVudGVyZWQgPSBfdGhpcyRwcm9wcy5vbkVudGVyZWQsXG4gICAgICAgIF9vbkV4aXQgPSBfdGhpcyRwcm9wcy5vbkV4aXQsXG4gICAgICAgIF9vbkV4aXRpbmcgPSBfdGhpcyRwcm9wcy5vbkV4aXRpbmcsXG4gICAgICAgIF9vbkV4aXRlZCA9IF90aGlzJHByb3BzLm9uRXhpdGVkLFxuICAgICAgICBfbm9kZVJlZiA9IF90aGlzJHByb3BzLm5vZGVSZWYsXG4gICAgICAgIGNoaWxkUHJvcHMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShfdGhpcyRwcm9wcywgW1wiY2hpbGRyZW5cIiwgXCJpblwiLCBcIm1vdW50T25FbnRlclwiLCBcInVubW91bnRPbkV4aXRcIiwgXCJhcHBlYXJcIiwgXCJlbnRlclwiLCBcImV4aXRcIiwgXCJ0aW1lb3V0XCIsIFwiYWRkRW5kTGlzdGVuZXJcIiwgXCJvbkVudGVyXCIsIFwib25FbnRlcmluZ1wiLCBcIm9uRW50ZXJlZFwiLCBcIm9uRXhpdFwiLCBcIm9uRXhpdGluZ1wiLCBcIm9uRXhpdGVkXCIsIFwibm9kZVJlZlwiXSk7XG5cbiAgICByZXR1cm4gKFxuICAgICAgLyojX19QVVJFX18qL1xuICAgICAgLy8gYWxsb3dzIGZvciBuZXN0ZWQgVHJhbnNpdGlvbnNcbiAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoVHJhbnNpdGlvbkdyb3VwQ29udGV4dC5Qcm92aWRlciwge1xuICAgICAgICB2YWx1ZTogbnVsbFxuICAgICAgfSwgdHlwZW9mIGNoaWxkcmVuID09PSAnZnVuY3Rpb24nID8gY2hpbGRyZW4oc3RhdHVzLCBjaGlsZFByb3BzKSA6IFJlYWN0LmNsb25lRWxlbWVudChSZWFjdC5DaGlsZHJlbi5vbmx5KGNoaWxkcmVuKSwgY2hpbGRQcm9wcykpXG4gICAgKTtcbiAgfTtcblxuICByZXR1cm4gVHJhbnNpdGlvbjtcbn0oUmVhY3QuQ29tcG9uZW50KTtcblxuVHJhbnNpdGlvbi5jb250ZXh0VHlwZSA9IFRyYW5zaXRpb25Hcm91cENvbnRleHQ7XG5UcmFuc2l0aW9uLnByb3BUeXBlcyA9IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IHtcbiAgLyoqXG4gICAqIEEgUmVhY3QgcmVmZXJlbmNlIHRvIERPTSBlbGVtZW50IHRoYXQgbmVlZCB0byB0cmFuc2l0aW9uOlxuICAgKiBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvNTExMjcxMzAvNDY3MTkzMlxuICAgKlxuICAgKiAgIC0gV2hlbiBgbm9kZVJlZmAgcHJvcCBpcyB1c2VkLCBgbm9kZWAgaXMgbm90IHBhc3NlZCB0byBjYWxsYmFjayBmdW5jdGlvbnNcbiAgICogICAgICAoZS5nLiBgb25FbnRlcmApIGJlY2F1c2UgdXNlciBhbHJlYWR5IGhhcyBkaXJlY3QgYWNjZXNzIHRvIHRoZSBub2RlLlxuICAgKiAgIC0gV2hlbiBjaGFuZ2luZyBga2V5YCBwcm9wIG9mIGBUcmFuc2l0aW9uYCBpbiBhIGBUcmFuc2l0aW9uR3JvdXBgIGEgbmV3XG4gICAqICAgICBgbm9kZVJlZmAgbmVlZCB0byBiZSBwcm92aWRlZCB0byBgVHJhbnNpdGlvbmAgd2l0aCBjaGFuZ2VkIGBrZXlgIHByb3BcbiAgICogICAgIChzZWVcbiAgICogICAgIFt0ZXN0L0NTU1RyYW5zaXRpb24tdGVzdC5qc10oaHR0cHM6Ly9naXRodWIuY29tL3JlYWN0anMvcmVhY3QtdHJhbnNpdGlvbi1ncm91cC9ibG9iLzEzNDM1Zjg5N2IzYWI3MWY2ZTE5ZDcyNGYxNDU1OTZmNTkxMDU4MWMvdGVzdC9DU1NUcmFuc2l0aW9uLXRlc3QuanMjTDM2Mi1MNDM3KSkuXG4gICAqL1xuICBub2RlUmVmOiBQcm9wVHlwZXMuc2hhcGUoe1xuICAgIGN1cnJlbnQ6IHR5cGVvZiBFbGVtZW50ID09PSAndW5kZWZpbmVkJyA/IFByb3BUeXBlcy5hbnkgOiBmdW5jdGlvbiAocHJvcFZhbHVlLCBrZXksIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUsIHNlY3JldCkge1xuICAgICAgdmFyIHZhbHVlID0gcHJvcFZhbHVlW2tleV07XG4gICAgICByZXR1cm4gUHJvcFR5cGVzLmluc3RhbmNlT2YodmFsdWUgJiYgJ293bmVyRG9jdW1lbnQnIGluIHZhbHVlID8gdmFsdWUub3duZXJEb2N1bWVudC5kZWZhdWx0Vmlldy5FbGVtZW50IDogRWxlbWVudCkocHJvcFZhbHVlLCBrZXksIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUsIHNlY3JldCk7XG4gICAgfVxuICB9KSxcblxuICAvKipcbiAgICogQSBgZnVuY3Rpb25gIGNoaWxkIGNhbiBiZSB1c2VkIGluc3RlYWQgb2YgYSBSZWFjdCBlbGVtZW50LiBUaGlzIGZ1bmN0aW9uIGlzXG4gICAqIGNhbGxlZCB3aXRoIHRoZSBjdXJyZW50IHRyYW5zaXRpb24gc3RhdHVzIChgJ2VudGVyaW5nJ2AsIGAnZW50ZXJlZCdgLFxuICAgKiBgJ2V4aXRpbmcnYCwgYCdleGl0ZWQnYCksIHdoaWNoIGNhbiBiZSB1c2VkIHRvIGFwcGx5IGNvbnRleHRcbiAgICogc3BlY2lmaWMgcHJvcHMgdG8gYSBjb21wb25lbnQuXG4gICAqXG4gICAqIGBgYGpzeFxuICAgKiA8VHJhbnNpdGlvbiBpbj17dGhpcy5zdGF0ZS5pbn0gdGltZW91dD17MTUwfT5cbiAgICogICB7c3RhdGUgPT4gKFxuICAgKiAgICAgPE15Q29tcG9uZW50IGNsYXNzTmFtZT17YGZhZGUgZmFkZS0ke3N0YXRlfWB9IC8+XG4gICAqICAgKX1cbiAgICogPC9UcmFuc2l0aW9uPlxuICAgKiBgYGBcbiAgICovXG4gIGNoaWxkcmVuOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkLCBQcm9wVHlwZXMuZWxlbWVudC5pc1JlcXVpcmVkXSkuaXNSZXF1aXJlZCxcblxuICAvKipcbiAgICogU2hvdyB0aGUgY29tcG9uZW50OyB0cmlnZ2VycyB0aGUgZW50ZXIgb3IgZXhpdCBzdGF0ZXNcbiAgICovXG4gIGluOiBQcm9wVHlwZXMuYm9vbCxcblxuICAvKipcbiAgICogQnkgZGVmYXVsdCB0aGUgY2hpbGQgY29tcG9uZW50IGlzIG1vdW50ZWQgaW1tZWRpYXRlbHkgYWxvbmcgd2l0aFxuICAgKiB0aGUgcGFyZW50IGBUcmFuc2l0aW9uYCBjb21wb25lbnQuIElmIHlvdSB3YW50IHRvIFwibGF6eSBtb3VudFwiIHRoZSBjb21wb25lbnQgb24gdGhlXG4gICAqIGZpcnN0IGBpbj17dHJ1ZX1gIHlvdSBjYW4gc2V0IGBtb3VudE9uRW50ZXJgLiBBZnRlciB0aGUgZmlyc3QgZW50ZXIgdHJhbnNpdGlvbiB0aGUgY29tcG9uZW50IHdpbGwgc3RheVxuICAgKiBtb3VudGVkLCBldmVuIG9uIFwiZXhpdGVkXCIsIHVubGVzcyB5b3UgYWxzbyBzcGVjaWZ5IGB1bm1vdW50T25FeGl0YC5cbiAgICovXG4gIG1vdW50T25FbnRlcjogUHJvcFR5cGVzLmJvb2wsXG5cbiAgLyoqXG4gICAqIEJ5IGRlZmF1bHQgdGhlIGNoaWxkIGNvbXBvbmVudCBzdGF5cyBtb3VudGVkIGFmdGVyIGl0IHJlYWNoZXMgdGhlIGAnZXhpdGVkJ2Agc3RhdGUuXG4gICAqIFNldCBgdW5tb3VudE9uRXhpdGAgaWYgeW91J2QgcHJlZmVyIHRvIHVubW91bnQgdGhlIGNvbXBvbmVudCBhZnRlciBpdCBmaW5pc2hlcyBleGl0aW5nLlxuICAgKi9cbiAgdW5tb3VudE9uRXhpdDogUHJvcFR5cGVzLmJvb2wsXG5cbiAgLyoqXG4gICAqIEJ5IGRlZmF1bHQgdGhlIGNoaWxkIGNvbXBvbmVudCBkb2VzIG5vdCBwZXJmb3JtIHRoZSBlbnRlciB0cmFuc2l0aW9uIHdoZW5cbiAgICogaXQgZmlyc3QgbW91bnRzLCByZWdhcmRsZXNzIG9mIHRoZSB2YWx1ZSBvZiBgaW5gLiBJZiB5b3Ugd2FudCB0aGlzXG4gICAqIGJlaGF2aW9yLCBzZXQgYm90aCBgYXBwZWFyYCBhbmQgYGluYCB0byBgdHJ1ZWAuXG4gICAqXG4gICAqID4gKipOb3RlKio6IHRoZXJlIGFyZSBubyBzcGVjaWFsIGFwcGVhciBzdGF0ZXMgbGlrZSBgYXBwZWFyaW5nYC9gYXBwZWFyZWRgLCB0aGlzIHByb3BcbiAgICogPiBvbmx5IGFkZHMgYW4gYWRkaXRpb25hbCBlbnRlciB0cmFuc2l0aW9uLiBIb3dldmVyLCBpbiB0aGVcbiAgICogPiBgPENTU1RyYW5zaXRpb24+YCBjb21wb25lbnQgdGhhdCBmaXJzdCBlbnRlciB0cmFuc2l0aW9uIGRvZXMgcmVzdWx0IGluXG4gICAqID4gYWRkaXRpb25hbCBgLmFwcGVhci0qYCBjbGFzc2VzLCB0aGF0IHdheSB5b3UgY2FuIGNob29zZSB0byBzdHlsZSBpdFxuICAgKiA+IGRpZmZlcmVudGx5LlxuICAgKi9cbiAgYXBwZWFyOiBQcm9wVHlwZXMuYm9vbCxcblxuICAvKipcbiAgICogRW5hYmxlIG9yIGRpc2FibGUgZW50ZXIgdHJhbnNpdGlvbnMuXG4gICAqL1xuICBlbnRlcjogUHJvcFR5cGVzLmJvb2wsXG5cbiAgLyoqXG4gICAqIEVuYWJsZSBvciBkaXNhYmxlIGV4aXQgdHJhbnNpdGlvbnMuXG4gICAqL1xuICBleGl0OiBQcm9wVHlwZXMuYm9vbCxcblxuICAvKipcbiAgICogVGhlIGR1cmF0aW9uIG9mIHRoZSB0cmFuc2l0aW9uLCBpbiBtaWxsaXNlY29uZHMuXG4gICAqIFJlcXVpcmVkIHVubGVzcyBgYWRkRW5kTGlzdGVuZXJgIGlzIHByb3ZpZGVkLlxuICAgKlxuICAgKiBZb3UgbWF5IHNwZWNpZnkgYSBzaW5nbGUgdGltZW91dCBmb3IgYWxsIHRyYW5zaXRpb25zOlxuICAgKlxuICAgKiBgYGBqc3hcbiAgICogdGltZW91dD17NTAwfVxuICAgKiBgYGBcbiAgICpcbiAgICogb3IgaW5kaXZpZHVhbGx5OlxuICAgKlxuICAgKiBgYGBqc3hcbiAgICogdGltZW91dD17e1xuICAgKiAgYXBwZWFyOiA1MDAsXG4gICAqICBlbnRlcjogMzAwLFxuICAgKiAgZXhpdDogNTAwLFxuICAgKiB9fVxuICAgKiBgYGBcbiAgICpcbiAgICogLSBgYXBwZWFyYCBkZWZhdWx0cyB0byB0aGUgdmFsdWUgb2YgYGVudGVyYFxuICAgKiAtIGBlbnRlcmAgZGVmYXVsdHMgdG8gYDBgXG4gICAqIC0gYGV4aXRgIGRlZmF1bHRzIHRvIGAwYFxuICAgKlxuICAgKiBAdHlwZSB7bnVtYmVyIHwgeyBlbnRlcj86IG51bWJlciwgZXhpdD86IG51bWJlciwgYXBwZWFyPzogbnVtYmVyIH19XG4gICAqL1xuICB0aW1lb3V0OiBmdW5jdGlvbiB0aW1lb3V0KHByb3BzKSB7XG4gICAgdmFyIHB0ID0gdGltZW91dHNTaGFwZTtcbiAgICBpZiAoIXByb3BzLmFkZEVuZExpc3RlbmVyKSBwdCA9IHB0LmlzUmVxdWlyZWQ7XG5cbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICByZXR1cm4gcHQuYXBwbHkodm9pZCAwLCBbcHJvcHNdLmNvbmNhdChhcmdzKSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEFkZCBhIGN1c3RvbSB0cmFuc2l0aW9uIGVuZCB0cmlnZ2VyLiBDYWxsZWQgd2l0aCB0aGUgdHJhbnNpdGlvbmluZ1xuICAgKiBET00gbm9kZSBhbmQgYSBgZG9uZWAgY2FsbGJhY2suIEFsbG93cyBmb3IgbW9yZSBmaW5lIGdyYWluZWQgdHJhbnNpdGlvbiBlbmRcbiAgICogbG9naWMuIFRpbWVvdXRzIGFyZSBzdGlsbCB1c2VkIGFzIGEgZmFsbGJhY2sgaWYgcHJvdmlkZWQuXG4gICAqXG4gICAqICoqTm90ZSoqOiB3aGVuIGBub2RlUmVmYCBwcm9wIGlzIHBhc3NlZCwgYG5vZGVgIGlzIG5vdCBwYXNzZWQuXG4gICAqXG4gICAqIGBgYGpzeFxuICAgKiBhZGRFbmRMaXN0ZW5lcj17KG5vZGUsIGRvbmUpID0+IHtcbiAgICogICAvLyB1c2UgdGhlIGNzcyB0cmFuc2l0aW9uZW5kIGV2ZW50IHRvIG1hcmsgdGhlIGZpbmlzaCBvZiBhIHRyYW5zaXRpb25cbiAgICogICBub2RlLmFkZEV2ZW50TGlzdGVuZXIoJ3RyYW5zaXRpb25lbmQnLCBkb25lLCBmYWxzZSk7XG4gICAqIH19XG4gICAqIGBgYFxuICAgKi9cbiAgYWRkRW5kTGlzdGVuZXI6IFByb3BUeXBlcy5mdW5jLFxuXG4gIC8qKlxuICAgKiBDYWxsYmFjayBmaXJlZCBiZWZvcmUgdGhlIFwiZW50ZXJpbmdcIiBzdGF0dXMgaXMgYXBwbGllZC4gQW4gZXh0cmEgcGFyYW1ldGVyXG4gICAqIGBpc0FwcGVhcmluZ2AgaXMgc3VwcGxpZWQgdG8gaW5kaWNhdGUgaWYgdGhlIGVudGVyIHN0YWdlIGlzIG9jY3VycmluZyBvbiB0aGUgaW5pdGlhbCBtb3VudFxuICAgKlxuICAgKiAqKk5vdGUqKjogd2hlbiBgbm9kZVJlZmAgcHJvcCBpcyBwYXNzZWQsIGBub2RlYCBpcyBub3QgcGFzc2VkLlxuICAgKlxuICAgKiBAdHlwZSBGdW5jdGlvbihub2RlOiBIdG1sRWxlbWVudCwgaXNBcHBlYXJpbmc6IGJvb2wpIC0+IHZvaWRcbiAgICovXG4gIG9uRW50ZXI6IFByb3BUeXBlcy5mdW5jLFxuXG4gIC8qKlxuICAgKiBDYWxsYmFjayBmaXJlZCBhZnRlciB0aGUgXCJlbnRlcmluZ1wiIHN0YXR1cyBpcyBhcHBsaWVkLiBBbiBleHRyYSBwYXJhbWV0ZXJcbiAgICogYGlzQXBwZWFyaW5nYCBpcyBzdXBwbGllZCB0byBpbmRpY2F0ZSBpZiB0aGUgZW50ZXIgc3RhZ2UgaXMgb2NjdXJyaW5nIG9uIHRoZSBpbml0aWFsIG1vdW50XG4gICAqXG4gICAqICoqTm90ZSoqOiB3aGVuIGBub2RlUmVmYCBwcm9wIGlzIHBhc3NlZCwgYG5vZGVgIGlzIG5vdCBwYXNzZWQuXG4gICAqXG4gICAqIEB0eXBlIEZ1bmN0aW9uKG5vZGU6IEh0bWxFbGVtZW50LCBpc0FwcGVhcmluZzogYm9vbClcbiAgICovXG4gIG9uRW50ZXJpbmc6IFByb3BUeXBlcy5mdW5jLFxuXG4gIC8qKlxuICAgKiBDYWxsYmFjayBmaXJlZCBhZnRlciB0aGUgXCJlbnRlcmVkXCIgc3RhdHVzIGlzIGFwcGxpZWQuIEFuIGV4dHJhIHBhcmFtZXRlclxuICAgKiBgaXNBcHBlYXJpbmdgIGlzIHN1cHBsaWVkIHRvIGluZGljYXRlIGlmIHRoZSBlbnRlciBzdGFnZSBpcyBvY2N1cnJpbmcgb24gdGhlIGluaXRpYWwgbW91bnRcbiAgICpcbiAgICogKipOb3RlKio6IHdoZW4gYG5vZGVSZWZgIHByb3AgaXMgcGFzc2VkLCBgbm9kZWAgaXMgbm90IHBhc3NlZC5cbiAgICpcbiAgICogQHR5cGUgRnVuY3Rpb24obm9kZTogSHRtbEVsZW1lbnQsIGlzQXBwZWFyaW5nOiBib29sKSAtPiB2b2lkXG4gICAqL1xuICBvbkVudGVyZWQ6IFByb3BUeXBlcy5mdW5jLFxuXG4gIC8qKlxuICAgKiBDYWxsYmFjayBmaXJlZCBiZWZvcmUgdGhlIFwiZXhpdGluZ1wiIHN0YXR1cyBpcyBhcHBsaWVkLlxuICAgKlxuICAgKiAqKk5vdGUqKjogd2hlbiBgbm9kZVJlZmAgcHJvcCBpcyBwYXNzZWQsIGBub2RlYCBpcyBub3QgcGFzc2VkLlxuICAgKlxuICAgKiBAdHlwZSBGdW5jdGlvbihub2RlOiBIdG1sRWxlbWVudCkgLT4gdm9pZFxuICAgKi9cbiAgb25FeGl0OiBQcm9wVHlwZXMuZnVuYyxcblxuICAvKipcbiAgICogQ2FsbGJhY2sgZmlyZWQgYWZ0ZXIgdGhlIFwiZXhpdGluZ1wiIHN0YXR1cyBpcyBhcHBsaWVkLlxuICAgKlxuICAgKiAqKk5vdGUqKjogd2hlbiBgbm9kZVJlZmAgcHJvcCBpcyBwYXNzZWQsIGBub2RlYCBpcyBub3QgcGFzc2VkLlxuICAgKlxuICAgKiBAdHlwZSBGdW5jdGlvbihub2RlOiBIdG1sRWxlbWVudCkgLT4gdm9pZFxuICAgKi9cbiAgb25FeGl0aW5nOiBQcm9wVHlwZXMuZnVuYyxcblxuICAvKipcbiAgICogQ2FsbGJhY2sgZmlyZWQgYWZ0ZXIgdGhlIFwiZXhpdGVkXCIgc3RhdHVzIGlzIGFwcGxpZWQuXG4gICAqXG4gICAqICoqTm90ZSoqOiB3aGVuIGBub2RlUmVmYCBwcm9wIGlzIHBhc3NlZCwgYG5vZGVgIGlzIG5vdCBwYXNzZWRcbiAgICpcbiAgICogQHR5cGUgRnVuY3Rpb24obm9kZTogSHRtbEVsZW1lbnQpIC0+IHZvaWRcbiAgICovXG4gIG9uRXhpdGVkOiBQcm9wVHlwZXMuZnVuY1xufSA6IHt9OyAvLyBOYW1lIHRoZSBmdW5jdGlvbiBzbyBpdCBpcyBjbGVhcmVyIGluIHRoZSBkb2N1bWVudGF0aW9uXG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5UcmFuc2l0aW9uLmRlZmF1bHRQcm9wcyA9IHtcbiAgaW46IGZhbHNlLFxuICBtb3VudE9uRW50ZXI6IGZhbHNlLFxuICB1bm1vdW50T25FeGl0OiBmYWxzZSxcbiAgYXBwZWFyOiBmYWxzZSxcbiAgZW50ZXI6IHRydWUsXG4gIGV4aXQ6IHRydWUsXG4gIG9uRW50ZXI6IG5vb3AsXG4gIG9uRW50ZXJpbmc6IG5vb3AsXG4gIG9uRW50ZXJlZDogbm9vcCxcbiAgb25FeGl0OiBub29wLFxuICBvbkV4aXRpbmc6IG5vb3AsXG4gIG9uRXhpdGVkOiBub29wXG59O1xuVHJhbnNpdGlvbi5VTk1PVU5URUQgPSBVTk1PVU5URUQ7XG5UcmFuc2l0aW9uLkVYSVRFRCA9IEVYSVRFRDtcblRyYW5zaXRpb24uRU5URVJJTkcgPSBFTlRFUklORztcblRyYW5zaXRpb24uRU5URVJFRCA9IEVOVEVSRUQ7XG5UcmFuc2l0aW9uLkVYSVRJTkcgPSBFWElUSU5HO1xuZXhwb3J0IGRlZmF1bHQgVHJhbnNpdGlvbjsiLCJpbXBvcnQgX2V4dGVuZHMgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2V4dGVuZHNcIjtcbmltcG9ydCBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZSBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZVwiO1xuaW1wb3J0IF9pbmhlcml0c0xvb3NlIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9pbmhlcml0c0xvb3NlXCI7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IGFkZE9uZUNsYXNzIGZyb20gJ2RvbS1oZWxwZXJzL2FkZENsYXNzJztcbmltcG9ydCByZW1vdmVPbmVDbGFzcyBmcm9tICdkb20taGVscGVycy9yZW1vdmVDbGFzcyc7XG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IFRyYW5zaXRpb24gZnJvbSAnLi9UcmFuc2l0aW9uJztcbmltcG9ydCB7IGNsYXNzTmFtZXNTaGFwZSB9IGZyb20gJy4vdXRpbHMvUHJvcFR5cGVzJztcblxudmFyIF9hZGRDbGFzcyA9IGZ1bmN0aW9uIGFkZENsYXNzKG5vZGUsIGNsYXNzZXMpIHtcbiAgcmV0dXJuIG5vZGUgJiYgY2xhc3NlcyAmJiBjbGFzc2VzLnNwbGl0KCcgJykuZm9yRWFjaChmdW5jdGlvbiAoYykge1xuICAgIHJldHVybiBhZGRPbmVDbGFzcyhub2RlLCBjKTtcbiAgfSk7XG59O1xuXG52YXIgcmVtb3ZlQ2xhc3MgPSBmdW5jdGlvbiByZW1vdmVDbGFzcyhub2RlLCBjbGFzc2VzKSB7XG4gIHJldHVybiBub2RlICYmIGNsYXNzZXMgJiYgY2xhc3Nlcy5zcGxpdCgnICcpLmZvckVhY2goZnVuY3Rpb24gKGMpIHtcbiAgICByZXR1cm4gcmVtb3ZlT25lQ2xhc3Mobm9kZSwgYyk7XG4gIH0pO1xufTtcbi8qKlxuICogQSB0cmFuc2l0aW9uIGNvbXBvbmVudCBpbnNwaXJlZCBieSB0aGUgZXhjZWxsZW50XG4gKiBbbmctYW5pbWF0ZV0oaHR0cHM6Ly9kb2NzLmFuZ3VsYXJqcy5vcmcvYXBpL25nQW5pbWF0ZSkgbGlicmFyeSwgeW91IHNob3VsZFxuICogdXNlIGl0IGlmIHlvdSdyZSB1c2luZyBDU1MgdHJhbnNpdGlvbnMgb3IgYW5pbWF0aW9ucy4gSXQncyBidWlsdCB1cG9uIHRoZVxuICogW2BUcmFuc2l0aW9uYF0oaHR0cHM6Ly9yZWFjdGNvbW11bml0eS5vcmcvcmVhY3QtdHJhbnNpdGlvbi1ncm91cC90cmFuc2l0aW9uKVxuICogY29tcG9uZW50LCBzbyBpdCBpbmhlcml0cyBhbGwgb2YgaXRzIHByb3BzLlxuICpcbiAqIGBDU1NUcmFuc2l0aW9uYCBhcHBsaWVzIGEgcGFpciBvZiBjbGFzcyBuYW1lcyBkdXJpbmcgdGhlIGBhcHBlYXJgLCBgZW50ZXJgLFxuICogYW5kIGBleGl0YCBzdGF0ZXMgb2YgdGhlIHRyYW5zaXRpb24uIFRoZSBmaXJzdCBjbGFzcyBpcyBhcHBsaWVkIGFuZCB0aGVuIGFcbiAqIHNlY29uZCBgKi1hY3RpdmVgIGNsYXNzIGluIG9yZGVyIHRvIGFjdGl2YXRlIHRoZSBDU1MgdHJhbnNpdGlvbi4gQWZ0ZXIgdGhlXG4gKiB0cmFuc2l0aW9uLCBtYXRjaGluZyBgKi1kb25lYCBjbGFzcyBuYW1lcyBhcmUgYXBwbGllZCB0byBwZXJzaXN0IHRoZVxuICogdHJhbnNpdGlvbiBzdGF0ZS5cbiAqXG4gKiBgYGBqc3hcbiAqIGZ1bmN0aW9uIEFwcCgpIHtcbiAqICAgY29uc3QgW2luUHJvcCwgc2V0SW5Qcm9wXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAqICAgcmV0dXJuIChcbiAqICAgICA8ZGl2PlxuICogICAgICAgPENTU1RyYW5zaXRpb24gaW49e2luUHJvcH0gdGltZW91dD17MjAwfSBjbGFzc05hbWVzPVwibXktbm9kZVwiPlxuICogICAgICAgICA8ZGl2PlxuICogICAgICAgICAgIHtcIkknbGwgcmVjZWl2ZSBteS1ub2RlLSogY2xhc3Nlc1wifVxuICogICAgICAgICA8L2Rpdj5cbiAqICAgICAgIDwvQ1NTVHJhbnNpdGlvbj5cbiAqICAgICAgIDxidXR0b24gdHlwZT1cImJ1dHRvblwiIG9uQ2xpY2s9eygpID0+IHNldEluUHJvcCh0cnVlKX0+XG4gKiAgICAgICAgIENsaWNrIHRvIEVudGVyXG4gKiAgICAgICA8L2J1dHRvbj5cbiAqICAgICA8L2Rpdj5cbiAqICAgKTtcbiAqIH1cbiAqIGBgYFxuICpcbiAqIFdoZW4gdGhlIGBpbmAgcHJvcCBpcyBzZXQgdG8gYHRydWVgLCB0aGUgY2hpbGQgY29tcG9uZW50IHdpbGwgZmlyc3QgcmVjZWl2ZVxuICogdGhlIGNsYXNzIGBleGFtcGxlLWVudGVyYCwgdGhlbiB0aGUgYGV4YW1wbGUtZW50ZXItYWN0aXZlYCB3aWxsIGJlIGFkZGVkIGluXG4gKiB0aGUgbmV4dCB0aWNrLiBgQ1NTVHJhbnNpdGlvbmAgW2ZvcmNlcyBhXG4gKiByZWZsb3ddKGh0dHBzOi8vZ2l0aHViLmNvbS9yZWFjdGpzL3JlYWN0LXRyYW5zaXRpb24tZ3JvdXAvYmxvYi81MDA3MzAzZTcyOWE3NGJlNjZhMjFjM2UyMjA1ZTQ5MTY4MjE1MjRiL3NyYy9DU1NUcmFuc2l0aW9uLmpzI0wyMDgtTDIxNSlcbiAqIGJldHdlZW4gYmVmb3JlIGFkZGluZyB0aGUgYGV4YW1wbGUtZW50ZXItYWN0aXZlYC4gVGhpcyBpcyBhbiBpbXBvcnRhbnQgdHJpY2tcbiAqIGJlY2F1c2UgaXQgYWxsb3dzIHVzIHRvIHRyYW5zaXRpb24gYmV0d2VlbiBgZXhhbXBsZS1lbnRlcmAgYW5kXG4gKiBgZXhhbXBsZS1lbnRlci1hY3RpdmVgIGV2ZW4gdGhvdWdoIHRoZXkgd2VyZSBhZGRlZCBpbW1lZGlhdGVseSBvbmUgYWZ0ZXJcbiAqIGFub3RoZXIuIE1vc3Qgbm90YWJseSwgdGhpcyBpcyB3aGF0IG1ha2VzIGl0IHBvc3NpYmxlIGZvciB1cyB0byBhbmltYXRlXG4gKiBfYXBwZWFyYW5jZV8uXG4gKlxuICogYGBgY3NzXG4gKiAubXktbm9kZS1lbnRlciB7XG4gKiAgIG9wYWNpdHk6IDA7XG4gKiB9XG4gKiAubXktbm9kZS1lbnRlci1hY3RpdmUge1xuICogICBvcGFjaXR5OiAxO1xuICogICB0cmFuc2l0aW9uOiBvcGFjaXR5IDIwMG1zO1xuICogfVxuICogLm15LW5vZGUtZXhpdCB7XG4gKiAgIG9wYWNpdHk6IDE7XG4gKiB9XG4gKiAubXktbm9kZS1leGl0LWFjdGl2ZSB7XG4gKiAgIG9wYWNpdHk6IDA7XG4gKiAgIHRyYW5zaXRpb246IG9wYWNpdHkgMjAwbXM7XG4gKiB9XG4gKiBgYGBcbiAqXG4gKiBgKi1hY3RpdmVgIGNsYXNzZXMgcmVwcmVzZW50IHdoaWNoIHN0eWxlcyB5b3Ugd2FudCB0byBhbmltYXRlICoqdG8qKiwgc28gaXQnc1xuICogaW1wb3J0YW50IHRvIGFkZCBgdHJhbnNpdGlvbmAgZGVjbGFyYXRpb24gb25seSB0byB0aGVtLCBvdGhlcndpc2UgdHJhbnNpdGlvbnNcbiAqIG1pZ2h0IG5vdCBiZWhhdmUgYXMgaW50ZW5kZWQhIFRoaXMgbWlnaHQgbm90IGJlIG9idmlvdXMgd2hlbiB0aGUgdHJhbnNpdGlvbnNcbiAqIGFyZSBzeW1tZXRyaWNhbCwgaS5lLiB3aGVuIGAqLWVudGVyLWFjdGl2ZWAgaXMgdGhlIHNhbWUgYXMgYCotZXhpdGAsIGxpa2UgaW5cbiAqIHRoZSBleGFtcGxlIGFib3ZlIChtaW51cyBgdHJhbnNpdGlvbmApLCBidXQgaXQgYmVjb21lcyBhcHBhcmVudCBpbiBtb3JlXG4gKiBjb21wbGV4IHRyYW5zaXRpb25zLlxuICpcbiAqICoqTm90ZSoqOiBJZiB5b3UncmUgdXNpbmcgdGhlXG4gKiBbYGFwcGVhcmBdKGh0dHA6Ly9yZWFjdGNvbW11bml0eS5vcmcvcmVhY3QtdHJhbnNpdGlvbi1ncm91cC90cmFuc2l0aW9uI1RyYW5zaXRpb24tcHJvcC1hcHBlYXIpXG4gKiBwcm9wLCBtYWtlIHN1cmUgdG8gZGVmaW5lIHN0eWxlcyBmb3IgYC5hcHBlYXItKmAgY2xhc3NlcyBhcyB3ZWxsLlxuICovXG5cblxudmFyIENTU1RyYW5zaXRpb24gPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9SZWFjdCRDb21wb25lbnQpIHtcbiAgX2luaGVyaXRzTG9vc2UoQ1NTVHJhbnNpdGlvbiwgX1JlYWN0JENvbXBvbmVudCk7XG5cbiAgZnVuY3Rpb24gQ1NTVHJhbnNpdGlvbigpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgX3RoaXMgPSBfUmVhY3QkQ29tcG9uZW50LmNhbGwuYXBwbHkoX1JlYWN0JENvbXBvbmVudCwgW3RoaXNdLmNvbmNhdChhcmdzKSkgfHwgdGhpcztcbiAgICBfdGhpcy5hcHBsaWVkQ2xhc3NlcyA9IHtcbiAgICAgIGFwcGVhcjoge30sXG4gICAgICBlbnRlcjoge30sXG4gICAgICBleGl0OiB7fVxuICAgIH07XG5cbiAgICBfdGhpcy5vbkVudGVyID0gZnVuY3Rpb24gKG1heWJlTm9kZSwgbWF5YmVBcHBlYXJpbmcpIHtcbiAgICAgIHZhciBfdGhpcyRyZXNvbHZlQXJndW1lbnQgPSBfdGhpcy5yZXNvbHZlQXJndW1lbnRzKG1heWJlTm9kZSwgbWF5YmVBcHBlYXJpbmcpLFxuICAgICAgICAgIG5vZGUgPSBfdGhpcyRyZXNvbHZlQXJndW1lbnRbMF0sXG4gICAgICAgICAgYXBwZWFyaW5nID0gX3RoaXMkcmVzb2x2ZUFyZ3VtZW50WzFdO1xuXG4gICAgICBfdGhpcy5yZW1vdmVDbGFzc2VzKG5vZGUsICdleGl0Jyk7XG5cbiAgICAgIF90aGlzLmFkZENsYXNzKG5vZGUsIGFwcGVhcmluZyA/ICdhcHBlYXInIDogJ2VudGVyJywgJ2Jhc2UnKTtcblxuICAgICAgaWYgKF90aGlzLnByb3BzLm9uRW50ZXIpIHtcbiAgICAgICAgX3RoaXMucHJvcHMub25FbnRlcihtYXliZU5vZGUsIG1heWJlQXBwZWFyaW5nKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgX3RoaXMub25FbnRlcmluZyA9IGZ1bmN0aW9uIChtYXliZU5vZGUsIG1heWJlQXBwZWFyaW5nKSB7XG4gICAgICB2YXIgX3RoaXMkcmVzb2x2ZUFyZ3VtZW50MiA9IF90aGlzLnJlc29sdmVBcmd1bWVudHMobWF5YmVOb2RlLCBtYXliZUFwcGVhcmluZyksXG4gICAgICAgICAgbm9kZSA9IF90aGlzJHJlc29sdmVBcmd1bWVudDJbMF0sXG4gICAgICAgICAgYXBwZWFyaW5nID0gX3RoaXMkcmVzb2x2ZUFyZ3VtZW50MlsxXTtcblxuICAgICAgdmFyIHR5cGUgPSBhcHBlYXJpbmcgPyAnYXBwZWFyJyA6ICdlbnRlcic7XG5cbiAgICAgIF90aGlzLmFkZENsYXNzKG5vZGUsIHR5cGUsICdhY3RpdmUnKTtcblxuICAgICAgaWYgKF90aGlzLnByb3BzLm9uRW50ZXJpbmcpIHtcbiAgICAgICAgX3RoaXMucHJvcHMub25FbnRlcmluZyhtYXliZU5vZGUsIG1heWJlQXBwZWFyaW5nKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgX3RoaXMub25FbnRlcmVkID0gZnVuY3Rpb24gKG1heWJlTm9kZSwgbWF5YmVBcHBlYXJpbmcpIHtcbiAgICAgIHZhciBfdGhpcyRyZXNvbHZlQXJndW1lbnQzID0gX3RoaXMucmVzb2x2ZUFyZ3VtZW50cyhtYXliZU5vZGUsIG1heWJlQXBwZWFyaW5nKSxcbiAgICAgICAgICBub2RlID0gX3RoaXMkcmVzb2x2ZUFyZ3VtZW50M1swXSxcbiAgICAgICAgICBhcHBlYXJpbmcgPSBfdGhpcyRyZXNvbHZlQXJndW1lbnQzWzFdO1xuXG4gICAgICB2YXIgdHlwZSA9IGFwcGVhcmluZyA/ICdhcHBlYXInIDogJ2VudGVyJztcblxuICAgICAgX3RoaXMucmVtb3ZlQ2xhc3Nlcyhub2RlLCB0eXBlKTtcblxuICAgICAgX3RoaXMuYWRkQ2xhc3Mobm9kZSwgdHlwZSwgJ2RvbmUnKTtcblxuICAgICAgaWYgKF90aGlzLnByb3BzLm9uRW50ZXJlZCkge1xuICAgICAgICBfdGhpcy5wcm9wcy5vbkVudGVyZWQobWF5YmVOb2RlLCBtYXliZUFwcGVhcmluZyk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIF90aGlzLm9uRXhpdCA9IGZ1bmN0aW9uIChtYXliZU5vZGUpIHtcbiAgICAgIHZhciBfdGhpcyRyZXNvbHZlQXJndW1lbnQ0ID0gX3RoaXMucmVzb2x2ZUFyZ3VtZW50cyhtYXliZU5vZGUpLFxuICAgICAgICAgIG5vZGUgPSBfdGhpcyRyZXNvbHZlQXJndW1lbnQ0WzBdO1xuXG4gICAgICBfdGhpcy5yZW1vdmVDbGFzc2VzKG5vZGUsICdhcHBlYXInKTtcblxuICAgICAgX3RoaXMucmVtb3ZlQ2xhc3Nlcyhub2RlLCAnZW50ZXInKTtcblxuICAgICAgX3RoaXMuYWRkQ2xhc3Mobm9kZSwgJ2V4aXQnLCAnYmFzZScpO1xuXG4gICAgICBpZiAoX3RoaXMucHJvcHMub25FeGl0KSB7XG4gICAgICAgIF90aGlzLnByb3BzLm9uRXhpdChtYXliZU5vZGUpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBfdGhpcy5vbkV4aXRpbmcgPSBmdW5jdGlvbiAobWF5YmVOb2RlKSB7XG4gICAgICB2YXIgX3RoaXMkcmVzb2x2ZUFyZ3VtZW50NSA9IF90aGlzLnJlc29sdmVBcmd1bWVudHMobWF5YmVOb2RlKSxcbiAgICAgICAgICBub2RlID0gX3RoaXMkcmVzb2x2ZUFyZ3VtZW50NVswXTtcblxuICAgICAgX3RoaXMuYWRkQ2xhc3Mobm9kZSwgJ2V4aXQnLCAnYWN0aXZlJyk7XG5cbiAgICAgIGlmIChfdGhpcy5wcm9wcy5vbkV4aXRpbmcpIHtcbiAgICAgICAgX3RoaXMucHJvcHMub25FeGl0aW5nKG1heWJlTm9kZSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIF90aGlzLm9uRXhpdGVkID0gZnVuY3Rpb24gKG1heWJlTm9kZSkge1xuICAgICAgdmFyIF90aGlzJHJlc29sdmVBcmd1bWVudDYgPSBfdGhpcy5yZXNvbHZlQXJndW1lbnRzKG1heWJlTm9kZSksXG4gICAgICAgICAgbm9kZSA9IF90aGlzJHJlc29sdmVBcmd1bWVudDZbMF07XG5cbiAgICAgIF90aGlzLnJlbW92ZUNsYXNzZXMobm9kZSwgJ2V4aXQnKTtcblxuICAgICAgX3RoaXMuYWRkQ2xhc3Mobm9kZSwgJ2V4aXQnLCAnZG9uZScpO1xuXG4gICAgICBpZiAoX3RoaXMucHJvcHMub25FeGl0ZWQpIHtcbiAgICAgICAgX3RoaXMucHJvcHMub25FeGl0ZWQobWF5YmVOb2RlKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgX3RoaXMucmVzb2x2ZUFyZ3VtZW50cyA9IGZ1bmN0aW9uIChtYXliZU5vZGUsIG1heWJlQXBwZWFyaW5nKSB7XG4gICAgICByZXR1cm4gX3RoaXMucHJvcHMubm9kZVJlZiA/IFtfdGhpcy5wcm9wcy5ub2RlUmVmLmN1cnJlbnQsIG1heWJlTm9kZV0gLy8gaGVyZSBgbWF5YmVOb2RlYCBpcyBhY3R1YWxseSBgYXBwZWFyaW5nYFxuICAgICAgOiBbbWF5YmVOb2RlLCBtYXliZUFwcGVhcmluZ107XG4gICAgfTtcblxuICAgIF90aGlzLmdldENsYXNzTmFtZXMgPSBmdW5jdGlvbiAodHlwZSkge1xuICAgICAgdmFyIGNsYXNzTmFtZXMgPSBfdGhpcy5wcm9wcy5jbGFzc05hbWVzO1xuICAgICAgdmFyIGlzU3RyaW5nQ2xhc3NOYW1lcyA9IHR5cGVvZiBjbGFzc05hbWVzID09PSAnc3RyaW5nJztcbiAgICAgIHZhciBwcmVmaXggPSBpc1N0cmluZ0NsYXNzTmFtZXMgJiYgY2xhc3NOYW1lcyA/IGNsYXNzTmFtZXMgKyBcIi1cIiA6ICcnO1xuICAgICAgdmFyIGJhc2VDbGFzc05hbWUgPSBpc1N0cmluZ0NsYXNzTmFtZXMgPyBcIlwiICsgcHJlZml4ICsgdHlwZSA6IGNsYXNzTmFtZXNbdHlwZV07XG4gICAgICB2YXIgYWN0aXZlQ2xhc3NOYW1lID0gaXNTdHJpbmdDbGFzc05hbWVzID8gYmFzZUNsYXNzTmFtZSArIFwiLWFjdGl2ZVwiIDogY2xhc3NOYW1lc1t0eXBlICsgXCJBY3RpdmVcIl07XG4gICAgICB2YXIgZG9uZUNsYXNzTmFtZSA9IGlzU3RyaW5nQ2xhc3NOYW1lcyA/IGJhc2VDbGFzc05hbWUgKyBcIi1kb25lXCIgOiBjbGFzc05hbWVzW3R5cGUgKyBcIkRvbmVcIl07XG4gICAgICByZXR1cm4ge1xuICAgICAgICBiYXNlQ2xhc3NOYW1lOiBiYXNlQ2xhc3NOYW1lLFxuICAgICAgICBhY3RpdmVDbGFzc05hbWU6IGFjdGl2ZUNsYXNzTmFtZSxcbiAgICAgICAgZG9uZUNsYXNzTmFtZTogZG9uZUNsYXNzTmFtZVxuICAgICAgfTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IENTU1RyYW5zaXRpb24ucHJvdG90eXBlO1xuXG4gIF9wcm90by5hZGRDbGFzcyA9IGZ1bmN0aW9uIGFkZENsYXNzKG5vZGUsIHR5cGUsIHBoYXNlKSB7XG4gICAgdmFyIGNsYXNzTmFtZSA9IHRoaXMuZ2V0Q2xhc3NOYW1lcyh0eXBlKVtwaGFzZSArIFwiQ2xhc3NOYW1lXCJdO1xuXG4gICAgdmFyIF90aGlzJGdldENsYXNzTmFtZXMgPSB0aGlzLmdldENsYXNzTmFtZXMoJ2VudGVyJyksXG4gICAgICAgIGRvbmVDbGFzc05hbWUgPSBfdGhpcyRnZXRDbGFzc05hbWVzLmRvbmVDbGFzc05hbWU7XG5cbiAgICBpZiAodHlwZSA9PT0gJ2FwcGVhcicgJiYgcGhhc2UgPT09ICdkb25lJyAmJiBkb25lQ2xhc3NOYW1lKSB7XG4gICAgICBjbGFzc05hbWUgKz0gXCIgXCIgKyBkb25lQ2xhc3NOYW1lO1xuICAgIH0gLy8gVGhpcyBpcyB0byBmb3JjZSBhIHJlcGFpbnQsXG4gICAgLy8gd2hpY2ggaXMgbmVjZXNzYXJ5IGluIG9yZGVyIHRvIHRyYW5zaXRpb24gc3R5bGVzIHdoZW4gYWRkaW5nIGEgY2xhc3MgbmFtZS5cblxuXG4gICAgaWYgKHBoYXNlID09PSAnYWN0aXZlJykge1xuICAgICAgLyogZXNsaW50LWRpc2FibGUgbm8tdW51c2VkLWV4cHJlc3Npb25zICovXG4gICAgICBub2RlICYmIG5vZGUuc2Nyb2xsVG9wO1xuICAgIH1cblxuICAgIGlmIChjbGFzc05hbWUpIHtcbiAgICAgIHRoaXMuYXBwbGllZENsYXNzZXNbdHlwZV1bcGhhc2VdID0gY2xhc3NOYW1lO1xuXG4gICAgICBfYWRkQ2xhc3Mobm9kZSwgY2xhc3NOYW1lKTtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLnJlbW92ZUNsYXNzZXMgPSBmdW5jdGlvbiByZW1vdmVDbGFzc2VzKG5vZGUsIHR5cGUpIHtcbiAgICB2YXIgX3RoaXMkYXBwbGllZENsYXNzZXMkID0gdGhpcy5hcHBsaWVkQ2xhc3Nlc1t0eXBlXSxcbiAgICAgICAgYmFzZUNsYXNzTmFtZSA9IF90aGlzJGFwcGxpZWRDbGFzc2VzJC5iYXNlLFxuICAgICAgICBhY3RpdmVDbGFzc05hbWUgPSBfdGhpcyRhcHBsaWVkQ2xhc3NlcyQuYWN0aXZlLFxuICAgICAgICBkb25lQ2xhc3NOYW1lID0gX3RoaXMkYXBwbGllZENsYXNzZXMkLmRvbmU7XG4gICAgdGhpcy5hcHBsaWVkQ2xhc3Nlc1t0eXBlXSA9IHt9O1xuXG4gICAgaWYgKGJhc2VDbGFzc05hbWUpIHtcbiAgICAgIHJlbW92ZUNsYXNzKG5vZGUsIGJhc2VDbGFzc05hbWUpO1xuICAgIH1cblxuICAgIGlmIChhY3RpdmVDbGFzc05hbWUpIHtcbiAgICAgIHJlbW92ZUNsYXNzKG5vZGUsIGFjdGl2ZUNsYXNzTmFtZSk7XG4gICAgfVxuXG4gICAgaWYgKGRvbmVDbGFzc05hbWUpIHtcbiAgICAgIHJlbW92ZUNsYXNzKG5vZGUsIGRvbmVDbGFzc05hbWUpO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8ucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgIHZhciBfdGhpcyRwcm9wcyA9IHRoaXMucHJvcHMsXG4gICAgICAgIF8gPSBfdGhpcyRwcm9wcy5jbGFzc05hbWVzLFxuICAgICAgICBwcm9wcyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKF90aGlzJHByb3BzLCBbXCJjbGFzc05hbWVzXCJdKTtcblxuICAgIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChUcmFuc2l0aW9uLCBfZXh0ZW5kcyh7fSwgcHJvcHMsIHtcbiAgICAgIG9uRW50ZXI6IHRoaXMub25FbnRlcixcbiAgICAgIG9uRW50ZXJlZDogdGhpcy5vbkVudGVyZWQsXG4gICAgICBvbkVudGVyaW5nOiB0aGlzLm9uRW50ZXJpbmcsXG4gICAgICBvbkV4aXQ6IHRoaXMub25FeGl0LFxuICAgICAgb25FeGl0aW5nOiB0aGlzLm9uRXhpdGluZyxcbiAgICAgIG9uRXhpdGVkOiB0aGlzLm9uRXhpdGVkXG4gICAgfSkpO1xuICB9O1xuXG4gIHJldHVybiBDU1NUcmFuc2l0aW9uO1xufShSZWFjdC5Db21wb25lbnQpO1xuXG5DU1NUcmFuc2l0aW9uLmRlZmF1bHRQcm9wcyA9IHtcbiAgY2xhc3NOYW1lczogJydcbn07XG5DU1NUcmFuc2l0aW9uLnByb3BUeXBlcyA9IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IF9leHRlbmRzKHt9LCBUcmFuc2l0aW9uLnByb3BUeXBlcywge1xuICAvKipcbiAgICogVGhlIGFuaW1hdGlvbiBjbGFzc05hbWVzIGFwcGxpZWQgdG8gdGhlIGNvbXBvbmVudCBhcyBpdCBhcHBlYXJzLCBlbnRlcnMsXG4gICAqIGV4aXRzIG9yIGhhcyBmaW5pc2hlZCB0aGUgdHJhbnNpdGlvbi4gQSBzaW5nbGUgbmFtZSBjYW4gYmUgcHJvdmlkZWQsIHdoaWNoXG4gICAqIHdpbGwgYmUgc3VmZml4ZWQgZm9yIGVhY2ggc3RhZ2UsIGUuZy4gYGNsYXNzTmFtZXM9XCJmYWRlXCJgIGFwcGxpZXM6XG4gICAqXG4gICAqIC0gYGZhZGUtYXBwZWFyYCwgYGZhZGUtYXBwZWFyLWFjdGl2ZWAsIGBmYWRlLWFwcGVhci1kb25lYFxuICAgKiAtIGBmYWRlLWVudGVyYCwgYGZhZGUtZW50ZXItYWN0aXZlYCwgYGZhZGUtZW50ZXItZG9uZWBcbiAgICogLSBgZmFkZS1leGl0YCwgYGZhZGUtZXhpdC1hY3RpdmVgLCBgZmFkZS1leGl0LWRvbmVgXG4gICAqXG4gICAqIEEgZmV3IGRldGFpbHMgdG8gbm90ZSBhYm91dCBob3cgdGhlc2UgY2xhc3NlcyBhcmUgYXBwbGllZDpcbiAgICpcbiAgICogMS4gVGhleSBhcmUgX2pvaW5lZF8gd2l0aCB0aGUgb25lcyB0aGF0IGFyZSBhbHJlYWR5IGRlZmluZWQgb24gdGhlIGNoaWxkXG4gICAqICAgIGNvbXBvbmVudCwgc28gaWYgeW91IHdhbnQgdG8gYWRkIHNvbWUgYmFzZSBzdHlsZXMsIHlvdSBjYW4gdXNlXG4gICAqICAgIGBjbGFzc05hbWVgIHdpdGhvdXQgd29ycnlpbmcgdGhhdCBpdCB3aWxsIGJlIG92ZXJyaWRkZW4uXG4gICAqXG4gICAqIDIuIElmIHRoZSB0cmFuc2l0aW9uIGNvbXBvbmVudCBtb3VudHMgd2l0aCBgaW49e2ZhbHNlfWAsIG5vIGNsYXNzZXMgYXJlXG4gICAqICAgIGFwcGxpZWQgeWV0LiBZb3UgbWlnaHQgYmUgZXhwZWN0aW5nIGAqLWV4aXQtZG9uZWAsIGJ1dCBpZiB5b3UgdGhpbmtcbiAgICogICAgYWJvdXQgaXQsIGEgY29tcG9uZW50IGNhbm5vdCBmaW5pc2ggZXhpdGluZyBpZiBpdCBoYXNuJ3QgZW50ZXJlZCB5ZXQuXG4gICAqXG4gICAqIDIuIGBmYWRlLWFwcGVhci1kb25lYCBhbmQgYGZhZGUtZW50ZXItZG9uZWAgd2lsbCBfYm90aF8gYmUgYXBwbGllZC4gVGhpc1xuICAgKiAgICBhbGxvd3MgeW91IHRvIGRlZmluZSBkaWZmZXJlbnQgYmVoYXZpb3IgZm9yIHdoZW4gYXBwZWFyaW5nIGlzIGRvbmUgYW5kXG4gICAqICAgIHdoZW4gcmVndWxhciBlbnRlcmluZyBpcyBkb25lLCB1c2luZyBzZWxlY3RvcnMgbGlrZVxuICAgKiAgICBgLmZhZGUtZW50ZXItZG9uZTpub3QoLmZhZGUtYXBwZWFyLWRvbmUpYC4gRm9yIGV4YW1wbGUsIHlvdSBjb3VsZCBhcHBseVxuICAgKiAgICBhbiBlcGljIGVudHJhbmNlIGFuaW1hdGlvbiB3aGVuIGVsZW1lbnQgZmlyc3QgYXBwZWFycyBpbiB0aGUgRE9NIHVzaW5nXG4gICAqICAgIFtBbmltYXRlLmNzc10oaHR0cHM6Ly9kYW5lZGVuLmdpdGh1Yi5pby9hbmltYXRlLmNzcy8pLiBPdGhlcndpc2UgeW91IGNhblxuICAgKiAgICBzaW1wbHkgdXNlIGBmYWRlLWVudGVyLWRvbmVgIGZvciBkZWZpbmluZyBib3RoIGNhc2VzLlxuICAgKlxuICAgKiBFYWNoIGluZGl2aWR1YWwgY2xhc3NOYW1lcyBjYW4gYWxzbyBiZSBzcGVjaWZpZWQgaW5kZXBlbmRlbnRseSBsaWtlOlxuICAgKlxuICAgKiBgYGBqc1xuICAgKiBjbGFzc05hbWVzPXt7XG4gICAqICBhcHBlYXI6ICdteS1hcHBlYXInLFxuICAgKiAgYXBwZWFyQWN0aXZlOiAnbXktYWN0aXZlLWFwcGVhcicsXG4gICAqICBhcHBlYXJEb25lOiAnbXktZG9uZS1hcHBlYXInLFxuICAgKiAgZW50ZXI6ICdteS1lbnRlcicsXG4gICAqICBlbnRlckFjdGl2ZTogJ215LWFjdGl2ZS1lbnRlcicsXG4gICAqICBlbnRlckRvbmU6ICdteS1kb25lLWVudGVyJyxcbiAgICogIGV4aXQ6ICdteS1leGl0JyxcbiAgICogIGV4aXRBY3RpdmU6ICdteS1hY3RpdmUtZXhpdCcsXG4gICAqICBleGl0RG9uZTogJ215LWRvbmUtZXhpdCcsXG4gICAqIH19XG4gICAqIGBgYFxuICAgKlxuICAgKiBJZiB5b3Ugd2FudCB0byBzZXQgdGhlc2UgY2xhc3NlcyB1c2luZyBDU1MgTW9kdWxlczpcbiAgICpcbiAgICogYGBganNcbiAgICogaW1wb3J0IHN0eWxlcyBmcm9tICcuL3N0eWxlcy5jc3MnO1xuICAgKiBgYGBcbiAgICpcbiAgICogeW91IG1pZ2h0IHdhbnQgdG8gdXNlIGNhbWVsQ2FzZSBpbiB5b3VyIENTUyBmaWxlLCB0aGF0IHdheSBjb3VsZCBzaW1wbHlcbiAgICogc3ByZWFkIHRoZW0gaW5zdGVhZCBvZiBsaXN0aW5nIHRoZW0gb25lIGJ5IG9uZTpcbiAgICpcbiAgICogYGBganNcbiAgICogY2xhc3NOYW1lcz17eyAuLi5zdHlsZXMgfX1cbiAgICogYGBgXG4gICAqXG4gICAqIEB0eXBlIHtzdHJpbmcgfCB7XG4gICAqICBhcHBlYXI/OiBzdHJpbmcsXG4gICAqICBhcHBlYXJBY3RpdmU/OiBzdHJpbmcsXG4gICAqICBhcHBlYXJEb25lPzogc3RyaW5nLFxuICAgKiAgZW50ZXI/OiBzdHJpbmcsXG4gICAqICBlbnRlckFjdGl2ZT86IHN0cmluZyxcbiAgICogIGVudGVyRG9uZT86IHN0cmluZyxcbiAgICogIGV4aXQ/OiBzdHJpbmcsXG4gICAqICBleGl0QWN0aXZlPzogc3RyaW5nLFxuICAgKiAgZXhpdERvbmU/OiBzdHJpbmcsXG4gICAqIH19XG4gICAqL1xuICBjbGFzc05hbWVzOiBjbGFzc05hbWVzU2hhcGUsXG5cbiAgLyoqXG4gICAqIEEgYDxUcmFuc2l0aW9uPmAgY2FsbGJhY2sgZmlyZWQgaW1tZWRpYXRlbHkgYWZ0ZXIgdGhlICdlbnRlcicgb3IgJ2FwcGVhcicgY2xhc3MgaXNcbiAgICogYXBwbGllZC5cbiAgICpcbiAgICogKipOb3RlKio6IHdoZW4gYG5vZGVSZWZgIHByb3AgaXMgcGFzc2VkLCBgbm9kZWAgaXMgbm90IHBhc3NlZC5cbiAgICpcbiAgICogQHR5cGUgRnVuY3Rpb24obm9kZTogSHRtbEVsZW1lbnQsIGlzQXBwZWFyaW5nOiBib29sKVxuICAgKi9cbiAgb25FbnRlcjogUHJvcFR5cGVzLmZ1bmMsXG5cbiAgLyoqXG4gICAqIEEgYDxUcmFuc2l0aW9uPmAgY2FsbGJhY2sgZmlyZWQgaW1tZWRpYXRlbHkgYWZ0ZXIgdGhlICdlbnRlci1hY3RpdmUnIG9yXG4gICAqICdhcHBlYXItYWN0aXZlJyBjbGFzcyBpcyBhcHBsaWVkLlxuICAgKlxuICAgKiAqKk5vdGUqKjogd2hlbiBgbm9kZVJlZmAgcHJvcCBpcyBwYXNzZWQsIGBub2RlYCBpcyBub3QgcGFzc2VkLlxuICAgKlxuICAgKiBAdHlwZSBGdW5jdGlvbihub2RlOiBIdG1sRWxlbWVudCwgaXNBcHBlYXJpbmc6IGJvb2wpXG4gICAqL1xuICBvbkVudGVyaW5nOiBQcm9wVHlwZXMuZnVuYyxcblxuICAvKipcbiAgICogQSBgPFRyYW5zaXRpb24+YCBjYWxsYmFjayBmaXJlZCBpbW1lZGlhdGVseSBhZnRlciB0aGUgJ2VudGVyJyBvclxuICAgKiAnYXBwZWFyJyBjbGFzc2VzIGFyZSAqKnJlbW92ZWQqKiBhbmQgdGhlIGBkb25lYCBjbGFzcyBpcyBhZGRlZCB0byB0aGUgRE9NIG5vZGUuXG4gICAqXG4gICAqICoqTm90ZSoqOiB3aGVuIGBub2RlUmVmYCBwcm9wIGlzIHBhc3NlZCwgYG5vZGVgIGlzIG5vdCBwYXNzZWQuXG4gICAqXG4gICAqIEB0eXBlIEZ1bmN0aW9uKG5vZGU6IEh0bWxFbGVtZW50LCBpc0FwcGVhcmluZzogYm9vbClcbiAgICovXG4gIG9uRW50ZXJlZDogUHJvcFR5cGVzLmZ1bmMsXG5cbiAgLyoqXG4gICAqIEEgYDxUcmFuc2l0aW9uPmAgY2FsbGJhY2sgZmlyZWQgaW1tZWRpYXRlbHkgYWZ0ZXIgdGhlICdleGl0JyBjbGFzcyBpc1xuICAgKiBhcHBsaWVkLlxuICAgKlxuICAgKiAqKk5vdGUqKjogd2hlbiBgbm9kZVJlZmAgcHJvcCBpcyBwYXNzZWQsIGBub2RlYCBpcyBub3QgcGFzc2VkXG4gICAqXG4gICAqIEB0eXBlIEZ1bmN0aW9uKG5vZGU6IEh0bWxFbGVtZW50KVxuICAgKi9cbiAgb25FeGl0OiBQcm9wVHlwZXMuZnVuYyxcblxuICAvKipcbiAgICogQSBgPFRyYW5zaXRpb24+YCBjYWxsYmFjayBmaXJlZCBpbW1lZGlhdGVseSBhZnRlciB0aGUgJ2V4aXQtYWN0aXZlJyBpcyBhcHBsaWVkLlxuICAgKlxuICAgKiAqKk5vdGUqKjogd2hlbiBgbm9kZVJlZmAgcHJvcCBpcyBwYXNzZWQsIGBub2RlYCBpcyBub3QgcGFzc2VkXG4gICAqXG4gICAqIEB0eXBlIEZ1bmN0aW9uKG5vZGU6IEh0bWxFbGVtZW50KVxuICAgKi9cbiAgb25FeGl0aW5nOiBQcm9wVHlwZXMuZnVuYyxcblxuICAvKipcbiAgICogQSBgPFRyYW5zaXRpb24+YCBjYWxsYmFjayBmaXJlZCBpbW1lZGlhdGVseSBhZnRlciB0aGUgJ2V4aXQnIGNsYXNzZXNcbiAgICogYXJlICoqcmVtb3ZlZCoqIGFuZCB0aGUgYGV4aXQtZG9uZWAgY2xhc3MgaXMgYWRkZWQgdG8gdGhlIERPTSBub2RlLlxuICAgKlxuICAgKiAqKk5vdGUqKjogd2hlbiBgbm9kZVJlZmAgcHJvcCBpcyBwYXNzZWQsIGBub2RlYCBpcyBub3QgcGFzc2VkXG4gICAqXG4gICAqIEB0eXBlIEZ1bmN0aW9uKG5vZGU6IEh0bWxFbGVtZW50KVxuICAgKi9cbiAgb25FeGl0ZWQ6IFByb3BUeXBlcy5mdW5jXG59KSA6IHt9O1xuZXhwb3J0IGRlZmF1bHQgQ1NTVHJhbnNpdGlvbjsiLCJleHBvcnQgY29uc3QgbnVtYmVycyA9IHtcclxuICAgIEJBTk5FUl9BTklNQVRJT05fQ0xPU0VfVElNRV9NUzogMjUwLFxyXG4gICAgQkFOTkVSX0FOSU1BVElPTl9PUEVOX1RJTUVfTVM6IDMwMCxcclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCBjc3NDbGFzc2VzID0ge1xyXG4gICAgUk9PVDogJ21kYy1iYW5uZXInLFxyXG4gICAgRklYRUQ6ICdtZGMtYmFubmVyLS1maXhlZCcsXHJcbiAgICBDRU5URVJFRDogJ21kYy1iYW5uZXItLWNlbnRlcmVkJyxcclxuICAgIE1PQklMRV9TVEFDS0VEOiAnbWRjLWJhbm5lci0tbW9iaWxlLXN0YWNrZWQnLFxyXG4gICAgQVBQRUFSSU5HOiAnbWRjLWJhbm5lci0tYXBwZWFyaW5nJyxcclxuICAgIEFQUEVBUkVEOiAnbWRjLWJhbm5lci0tYXBwZWFyZWQnLFxyXG4gICAgT1BFTklORzogJ21kYy1iYW5uZXItLW9wZW5pbmcnLFxyXG4gICAgT1BFTjogJ21kYy1iYW5uZXItLW9wZW4nLFxyXG4gICAgQ0xPU0lORzogJ21kYy1iYW5uZXItLWNsb3NpbmcnLFxyXG5cclxuICAgIENPTlRFTlQ6ICdtZGMtYmFubmVyX19jb250ZW50JyxcclxuICAgIEdSQVBISUNfVEVYVF9XUkFQUEVSOiAnbWRjLWJhbm5lcl9fZ3JhcGhpYy10ZXh0LXdyYXBwZXInLFxyXG4gICAgR1JBUEhJQzogJ21kYy1iYW5uZXJfX2dyYXBoaWMnLFxyXG4gICAgSUNPTjogJ21kYy1iYW5uZXJfX2ljb24nLFxyXG4gICAgVEVYVDogJ21kYy1iYW5uZXJfX3RleHQnLFxyXG4gICAgQUNUSU9OUzogJ21kYy1iYW5uZXJfX2FjdGlvbnMnLFxyXG4gICAgUFJJTUFSWV9BQ1RJT046ICdtZGMtYmFubmVyX19wcmltYXJ5LWFjdGlvbicsXHJcbiAgICBTRUNPTkRBUllfQUNUSU9OOiAnbWRjLWJhbm5lcl9fc2Vjb25kYXJ5LWFjdGlvbidcclxufTsiLCJpbXBvcnQgeyBmb3J3YXJkUmVmLCB1c2VSZWYsIHVzZUNhbGxiYWNrLCB1c2VJbXBlcmF0aXZlSGFuZGxlIH0gZnJvbSAncmVhY3QnO1xyXG5pbXBvcnQgeyBDU1NUcmFuc2l0aW9uIH0gZnJvbSAncmVhY3QtdHJhbnNpdGlvbi1ncm91cCc7XHJcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XHJcbmltcG9ydCBjbGFzc25hbWVzIGZyb20gJ2NsYXNzbmFtZXMnO1xyXG5cclxuaW1wb3J0IHsgQ2xvbmUgfSBmcm9tICcuLi9jb21wb25lbnQnO1xyXG5pbXBvcnQgSWNvbiBmcm9tICcuLi9pY29uJztcclxuXHJcbmltcG9ydCB7IG51bWJlcnMsIGNzc0NsYXNzZXMgfSBmcm9tICcuL2NvbnN0YW50cyc7XHJcblxyXG5jb25zdCBCYW5uZXIgPSBmb3J3YXJkUmVmKCh7XHJcbiAgICB0ZXh0LFxyXG4gICAgaWNvbixcclxuICAgIGdyYXBoaWMgPSBpY29uLFxyXG4gICAgYWN0aW9uLFxyXG4gICAgcHJpbWFyeUFjdGlvbiA9IGFjdGlvbixcclxuICAgIHNlY29uZGFyeUFjdGlvbixcclxuICAgIG9wZW4gPSBmYWxzZSxcclxuICAgIGNlbnRlcmVkID0gZmFsc2UsXHJcbiAgICBmaXhlZCA9IGZhbHNlLFxyXG4gICAgbW9iaWxlU3RhY2tlZCA9IGZhbHNlLFxyXG5cclxuICAgIGVsZW1lbnQgPSAnZGl2JyxcclxuICAgIGNvbXBvbmVudDogRWxlbWVudCA9IGVsZW1lbnQsXHJcbiAgICBjbGFzc05hbWUsXHJcbiAgICBjaGlsZHJlbiA9IHRleHQsXHJcbiAgICAuLi5wcm9wc1xyXG59LCByZWYpID0+IHtcclxuICAgIGNvbnN0IHJvb3RSZWYgPSB1c2VSZWYoKTtcclxuICAgIGNvbnN0IGNvbnRlbnRSZWYgPSB1c2VSZWYoKTtcclxuXHJcbiAgICB1c2VJbXBlcmF0aXZlSGFuZGxlKHJlZiwgKCkgPT4gcm9vdFJlZi5jdXJyZW50KTtcclxuXHJcbiAgICBjb25zdCBoYW5kbGVFbnRlcmluZyA9IHVzZUNhbGxiYWNrKChub2RlLCBpc0FwcGVhcmluZykgPT4ge1xyXG4gICAgICAgIGlmICghaXNBcHBlYXJpbmcpIHtcclxuICAgICAgICAgICAgbm9kZS5zdHlsZS5oZWlnaHQgPSBgJHtjb250ZW50UmVmLmN1cnJlbnQub2Zmc2V0SGVpZ2h0fXB4YDtcclxuICAgICAgICB9XHJcbiAgICB9LCBbXSk7XHJcblxyXG4gICAgY29uc3QgaGFuZGxlRXhpdGluZyA9IHVzZUNhbGxiYWNrKG5vZGUgPT4ge1xyXG4gICAgICAgIG5vZGUuc3R5bGUuaGVpZ2h0ID0gJzBweCc7XHJcbiAgICB9LCBbXSk7XHJcblxyXG4gICAgY29uc3QgY2xhc3NOYW1lcyA9IGNsYXNzbmFtZXMoY3NzQ2xhc3Nlcy5ST09ULCB7XHJcbiAgICAgICAgW2Nzc0NsYXNzZXMuRklYRURdOiBmaXhlZCxcclxuICAgICAgICBbY3NzQ2xhc3Nlcy5DRU5URVJFRF06IGNlbnRlcmVkLFxyXG4gICAgICAgIFtjc3NDbGFzc2VzLk1PQklMRV9TVEFDS0VEXTogbW9iaWxlU3RhY2tlZFxyXG4gICAgfSwgY2xhc3NOYW1lKTtcclxuXHJcbiAgICBjb25zdCBjb250ZW50ID0gKFxyXG4gICAgICAgIDxkaXYgcmVmPXtjb250ZW50UmVmfSBjbGFzc05hbWU9e2Nzc0NsYXNzZXMuQ09OVEVOVH0gcm9sZT1cInN0YXR1c1wiPlxyXG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17Y3NzQ2xhc3Nlcy5HUkFQSElDX1RFWFRfV1JBUFBFUn0+XHJcbiAgICAgICAgICAgICAgICB7Z3JhcGhpYyAmJlxyXG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXtjc3NDbGFzc2VzLkdSQVBISUN9PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8Q2xvbmVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudD17Z3JhcGhpY31cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZhbGxiYWNrPXtJY29ufVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPXtjc3NDbGFzc2VzLklDT059XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8+XHJcbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgPENsb25lXHJcbiAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50PXtjaGlsZHJlbn1cclxuICAgICAgICAgICAgICAgICAgICBmYWxsYmFjaz1cImRpdlwiXHJcbiAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPXtjc3NDbGFzc2VzLlRFWFR9XHJcbiAgICAgICAgICAgICAgICAvPlxyXG4gICAgICAgICAgICA8L2Rpdj5cclxuXHJcbiAgICAgICAgICAgIHtwcmltYXJ5QWN0aW9uICYmXHJcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17Y3NzQ2xhc3Nlcy5BQ1RJT05TfT5cclxuICAgICAgICAgICAgICAgICAgICB7c2Vjb25kYXJ5QWN0aW9uICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxDbG9uZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50PXtzZWNvbmRhcnlBY3Rpb259XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU9e2Nzc0NsYXNzZXMuU0VDT05EQVJZX0FDVElPTn1cclxuICAgICAgICAgICAgICAgICAgICAgICAgLz5cclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIDxDbG9uZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb21wb25lbnQ9e3ByaW1hcnlBY3Rpb259XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT17Y3NzQ2xhc3Nlcy5QUklNQVJZX0FDVElPTn1cclxuICAgICAgICAgICAgICAgICAgICAvPlxyXG4gICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICA8L2Rpdj5cclxuICAgICk7XHJcblxyXG4gICAgcmV0dXJuIChcclxuICAgICAgICA8Q1NTVHJhbnNpdGlvblxyXG4gICAgICAgICAgICBpbj17b3Blbn1cclxuICAgICAgICAgICAgYXBwZWFyPXtvcGVufVxyXG4gICAgICAgICAgICB0aW1lb3V0PXt7XHJcbiAgICAgICAgICAgICAgICBhcHBlYXI6IDAsXHJcbiAgICAgICAgICAgICAgICBlbnRlcjogbnVtYmVycy5CQU5ORVJfQU5JTUFUSU9OX09QRU5fVElNRV9NUyxcclxuICAgICAgICAgICAgICAgIGV4aXQ6IG51bWJlcnMuQkFOTkVSX0FOSU1BVElPTl9DTE9TRV9USU1FX01TXHJcbiAgICAgICAgICAgIH19XHJcbiAgICAgICAgICAgIGNsYXNzTmFtZXM9e3tcclxuICAgICAgICAgICAgICAgIGFwcGVhcjogY3NzQ2xhc3Nlcy5BUFBFQVJJTkcsXHJcbiAgICAgICAgICAgICAgICBhcHBlYXJEb25lOiBjc3NDbGFzc2VzLkFQUEVBUkVELFxyXG4gICAgICAgICAgICAgICAgZW50ZXI6IGNzc0NsYXNzZXMuT1BFTklORyxcclxuICAgICAgICAgICAgICAgIGVudGVyQWN0aXZlOiBjc3NDbGFzc2VzLk9QRU4sXHJcbiAgICAgICAgICAgICAgICBlbnRlckRvbmU6IGNzc0NsYXNzZXMuT1BFTixcclxuICAgICAgICAgICAgICAgIGV4aXQ6IGNzc0NsYXNzZXMuQ0xPU0lOR1xyXG4gICAgICAgICAgICB9fVxyXG4gICAgICAgICAgICBtb3VudE9uRW50ZXJcclxuICAgICAgICAgICAgdW5tb3VudE9uRXhpdFxyXG4gICAgICAgICAgICBvbkVudGVyaW5nPXtoYW5kbGVFbnRlcmluZ31cclxuICAgICAgICAgICAgb25FeGl0aW5nPXtoYW5kbGVFeGl0aW5nfVxyXG4gICAgICAgID5cclxuICAgICAgICAgICAgPEVsZW1lbnQgcmVmPXtyb290UmVmfSBjbGFzc05hbWU9e2NsYXNzTmFtZXN9IHJvbGU9XCJiYW5uZXJcIiB7Li4ucHJvcHN9PlxyXG4gICAgICAgICAgICAgICAge2NvbnRlbnR9XHJcbiAgICAgICAgICAgIDwvRWxlbWVudD5cclxuICAgICAgICA8L0NTU1RyYW5zaXRpb24+XHJcbiAgICApO1xyXG59KTtcclxuXHJcbkJhbm5lci5kaXNwbGF5TmFtZSA9ICdNRENCYW5uZXInO1xyXG5cclxuQmFubmVyLnByb3BUeXBlcyA9IHtcclxuICAgIHRleHQ6IFByb3BUeXBlcy5ub2RlLmlzUmVxdWlyZWQsXHJcbiAgICBpY29uOiBQcm9wVHlwZXMubm9kZSxcclxuICAgIGdyYXBoaWM6IFByb3BUeXBlcy5lbGVtZW50LFxyXG4gICAgYWN0aW9uOiBQcm9wVHlwZXMuZWxlbWVudCxcclxuICAgIHByaW1hcnlBY3Rpb246IFByb3BUeXBlcy5lbGVtZW50LFxyXG4gICAgc2Vjb25kYXJ5QWN0aW9uOiBQcm9wVHlwZXMuZWxlbWVudCxcclxuICAgIG9wZW46IFByb3BUeXBlcy5ib29sLFxyXG4gICAgYXBwZWFyOiBQcm9wVHlwZXMuYm9vbCxcclxuICAgIGZpeGVkOiBQcm9wVHlwZXMuYm9vbCxcclxuICAgIGNlbnRlcmVkOiBQcm9wVHlwZXMuYm9vbCxcclxuICAgIG1vYmlsZVN0YWNrZWQ6IFByb3BUeXBlcy5ib29sXHJcbn07XHJcblxyXG5leHBvcnQgZGVmYXVsdCBCYW5uZXI7IiwiZXhwb3J0IHsgZGVmYXVsdCB9IGZyb20gJy4vQmFubmVyJzsiLCJleHBvcnQgY29uc3QgY3NzQ2xhc3NlcyA9IHtcclxuICAgIFJPT1Q6ICdtZGMtYnV0dG9uJyxcclxuICAgIFJBSVNFRDogJ21kYy1idXR0b24tLXJhaXNlZCcsXHJcbiAgICBVTkVMRVZBVEVEOiAnbWRjLWJ1dHRvbi0tdW5lbGV2YXRlZCcsXHJcbiAgICBPVVRMSU5FRDogJ21kYy1idXR0b24tLW91dGxpbmVkJyxcclxuICAgIFRPVUNIOiAnbWRjLWJ1dHRvbi0tdG91Y2gnLFxyXG4gICAgSUNPTl9MRUFESU5HOiAnbWRjLWJ1dHRvbi0taWNvbi1sZWFkaW5nJyxcclxuICAgIElDT05fVFJBSUxJTkc6ICdtZGMtYnV0dG9uLS1pY29uLXRyYWlsaW5nJyxcclxuXHJcbiAgICBSSVBQTEU6ICdtZGMtYnV0dG9uX19yaXBwbGUnLFxyXG4gICAgSUNPTjogJ21kYy1idXR0b25fX2ljb24nLFxyXG4gICAgTEFCRUw6ICdtZGMtYnV0dG9uX19sYWJlbCcsXHJcbiAgICBUT1VDSF9FTEVNRU5UOiAnbWRjLWJ1dHRvbl9fdG91Y2gnXHJcbn07IiwiaW1wb3J0IHsgZm9yd2FyZFJlZiB9IGZyb20gJ3JlYWN0JztcclxuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcclxuaW1wb3J0IGNsYXNzbmFtZXMgZnJvbSAnY2xhc3NuYW1lcyc7XHJcblxyXG5pbXBvcnQgeyBDbG9uZSB9IGZyb20gJy4uL2NvbXBvbmVudCc7XHJcbmltcG9ydCBJY29uIGZyb20gJy4uL2ljb24nO1xyXG5pbXBvcnQgeyBjc3NDbGFzc2VzIH0gZnJvbSAnLi9jb25zdGFudHMnO1xyXG5cclxuY29uc3QgQnV0dG9uID0gZm9yd2FyZFJlZigoe1xyXG4gICAgbGFiZWwsXHJcbiAgICBpY29uLFxyXG4gICAgbGVhZGluZ0ljb24gPSBpY29uLFxyXG4gICAgdHJhaWxpbmdJY29uLFxyXG4gICAgcmFpc2VkID0gZmFsc2UsXHJcbiAgICB1bmVsZXZhdGVkID0gZmFsc2UsXHJcbiAgICBvdXRsaW5lZCA9IGZhbHNlLFxyXG4gICAgdG91Y2ggPSBmYWxzZSxcclxuXHJcbiAgICBlbGVtZW50ID0gJ2J1dHRvbicsXHJcbiAgICBjb21wb25lbnQ6IEVsZW1lbnQgPSBlbGVtZW50LFxyXG4gICAgY2xhc3NOYW1lLFxyXG4gICAgY2hpbGRyZW4gPSBsYWJlbCxcclxuICAgIC4uLnByb3BzXHJcbn0sIHJlZikgPT4ge1xyXG4gICAgY29uc3QgY2xhc3NOYW1lcyA9IGNsYXNzbmFtZXMoY3NzQ2xhc3Nlcy5ST09ULCB7XHJcbiAgICAgICAgW2Nzc0NsYXNzZXMuUkFJU0VEXTogcmFpc2VkLFxyXG4gICAgICAgIFtjc3NDbGFzc2VzLlVORUxFVkFURURdOiB1bmVsZXZhdGVkLFxyXG4gICAgICAgIFtjc3NDbGFzc2VzLk9VVExJTkVEXTogb3V0bGluZWQsXHJcbiAgICAgICAgW2Nzc0NsYXNzZXMuVE9VQ0hdOiB0b3VjaCxcclxuICAgICAgICBbY3NzQ2xhc3Nlcy5JQ09OX0xFQURJTkddOiBCb29sZWFuKGxlYWRpbmdJY29uKSxcclxuICAgICAgICBbY3NzQ2xhc3Nlcy5JQ09OX1RSQUlMSU5HXTogQm9vbGVhbih0cmFpbGluZ0ljb24pXHJcbiAgICB9LCBjbGFzc05hbWUpO1xyXG5cclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgPEVsZW1lbnQgcmVmPXtyZWZ9IGNsYXNzTmFtZT17Y2xhc3NOYW1lc30gey4uLnByb3BzfT5cclxuICAgICAgICAgICAgPHNwYW4gY2xhc3NOYW1lPXtjc3NDbGFzc2VzLlJJUFBMRX0gLz5cclxuXHJcbiAgICAgICAgICAgIHt0b3VjaCAmJlxyXG4gICAgICAgICAgICAgICAgPHNwYW4gY2xhc3NOYW1lPXtjc3NDbGFzc2VzLlRPVUNIX0VMRU1FTlR9IC8+XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHtsZWFkaW5nSWNvbiAmJlxyXG4gICAgICAgICAgICAgICAgPENsb25lXHJcbiAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50PXtsZWFkaW5nSWNvbn1cclxuICAgICAgICAgICAgICAgICAgICBmYWxsYmFjaz17SWNvbn1cclxuICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU9e2Nzc0NsYXNzZXMuSUNPTn1cclxuICAgICAgICAgICAgICAgICAgICBhcmlhLWhpZGRlbj1cInRydWVcIlxyXG4gICAgICAgICAgICAgICAgLz5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgPHNwYW4gY2xhc3NOYW1lPXtjc3NDbGFzc2VzLkxBQkVMfT57Y2hpbGRyZW59PC9zcGFuPlxyXG5cclxuICAgICAgICAgICAge3RyYWlsaW5nSWNvbiAmJlxyXG4gICAgICAgICAgICAgICAgPENsb25lXHJcbiAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50PXt0cmFpbGluZ0ljb259XHJcbiAgICAgICAgICAgICAgICAgICAgZmFsbGJhY2s9e0ljb259XHJcbiAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPXtjc3NDbGFzc2VzLklDT059XHJcbiAgICAgICAgICAgICAgICAgICAgYXJpYS1oaWRkZW49XCJ0cnVlXCJcclxuICAgICAgICAgICAgICAgIC8+XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICA8L0VsZW1lbnQ+XHJcbiAgICApO1xyXG59KTtcclxuXHJcbkJ1dHRvbi5kaXNwbGF5TmFtZSA9ICdNRENCdXR0b24nO1xyXG5cclxuQnV0dG9uLnByb3BUeXBlcyA9IHtcclxuICAgIGxhYmVsOiBQcm9wVHlwZXMubm9kZSxcclxuICAgIGljb246IFByb3BUeXBlcy5ub2RlLFxyXG4gICAgbGVhZGluZ0ljb246IFByb3BUeXBlcy5ub2RlLFxyXG4gICAgdHJhaWxpbmdJY29uOiBQcm9wVHlwZXMubm9kZSxcclxuICAgIHJhaXNlZDogUHJvcFR5cGVzLmJvb2wsXHJcbiAgICB1bmVsZXZhdGVkOiBQcm9wVHlwZXMuYm9vbCxcclxuICAgIG91dGxpbmVkOiBQcm9wVHlwZXMuYm9vbCxcclxuICAgIHRvdWNoOiBQcm9wVHlwZXMuYm9vbFxyXG59O1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgQnV0dG9uOyIsImV4cG9ydCB7IGRlZmF1bHQgfSBmcm9tICcuL0J1dHRvbic7IiwiZXhwb3J0IGNvbnN0IGNzc0NsYXNzZXMgPSB7XHJcbiAgICBST09UOiAnbWRjLWNhcmQnLFxyXG4gICAgT1VUTElORUQ6ICdtZGMtY2FyZC0tb3V0bGluZWQnLFxyXG5cclxuICAgIFRJVExFOiAnbWRjLWNhcmRfX3RpdGxlJyxcclxuICAgIFNVQlRJVExFOiAnbWRjLWNhcmRfX3N1YnRpdGxlJyxcclxuICAgIE9WRVJMSU5FOiAnbWRjLWNhcmRfX292ZXJsaW5lJyxcclxuXHJcbiAgICBBQ1RJT05TOiAnbWRjLWNhcmRfX2FjdGlvbnMnLFxyXG4gICAgQUNUSU9OU19GVUxMX0JMRUVEOiAnbWRjLWNhcmRfX2FjdGlvbnMtLWZ1bGwtYmxlZWQnLFxyXG5cclxuICAgIEFDVElPTl9CVVRUT05TOiAnbWRjLWNhcmRfX2FjdGlvbi1idXR0b25zJyxcclxuICAgIEFDVElPTl9JQ09OUzogJ21kYy1jYXJkX19hY3Rpb24taWNvbnMnLFxyXG5cclxuICAgIEFDVElPTjogJ21kYy1jYXJkX19hY3Rpb24nLFxyXG4gICAgQUNUSU9OX0JVVFRPTjogJ21kYy1jYXJkX19hY3Rpb24tLWJ1dHRvbicsXHJcbiAgICBBQ1RJT05fSUNPTjogJ21kYy1jYXJkX19hY3Rpb24tLWljb24nLFxyXG5cclxuICAgIENPTlRFTlQ6ICdtZGMtY2FyZF9fY29udGVudCcsXHJcblxyXG4gICAgSEVBREVSOiAnbWRjLWNhcmRfX2hlYWRlcicsXHJcbiAgICBIRUFERVJfR1JBUEhJQzogJ21kYy1jYXJkX19oZWFkZXJfX2dyYXBoaWMnLFxyXG4gICAgSEVBREVSX0NPTlRFTlQ6ICdtZGMtY2FyZF9faGVhZGVyX19jb250ZW50JyxcclxuICAgIEhFQURFUl9BQ1RJT05TOiAnbWRjLWNhcmRfX2hlYWRlcl9fYWN0aW9ucycsXHJcblxyXG4gICAgTUVESUE6ICdtZGMtY2FyZF9fbWVkaWEnLFxyXG4gICAgTUVESUFfU1FVQVJFOiAnbWRjLWNhcmRfX21lZGlhLS1zcXVhcmUnLFxyXG4gICAgTUVESUFfV0lERTogJ21kYy1jYXJkX19tZWRpYS0tMTYtOScsXHJcbiAgICBNRURJQV9DT05URU5UOiAnbWRjLWNhcmRfX21lZGlhLWNvbnRlbnQnLFxyXG5cclxuICAgIFBSSU1BUllfQUNUSU9OOiAnbWRjLWNhcmRfX3ByaW1hcnktYWN0aW9uJyxcclxuXHJcbiAgICBTRUNUSU9OOiAnbWRjLWNhcmRfX3NlY3Rpb24nLFxyXG4gICAgU0VDVElPTl9QUklNQVJZOiAnbWRjLWNhcmRfX3NlY3Rpb24tLXByaW1hcnknLFxyXG4gICAgU0VDVElPTl9TRUNPTkRBUlk6ICdtZGMtY2FyZF9fc2VjdGlvbi0tc2Vjb25kYXJ5JyxcclxuXHJcbiAgICBSSVBQTEU6ICdtZGMtY2FyZF9fcmlwcGxlJ1xyXG59OyIsImltcG9ydCB7IGZvcndhcmRSZWYgfSBmcm9tICdyZWFjdCc7XHJcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XHJcbmltcG9ydCBjbGFzc25hbWVzIGZyb20gJ2NsYXNzbmFtZXMnO1xyXG5cclxuaW1wb3J0IHsgY3NzQ2xhc3NlcyB9IGZyb20gJy4vY29uc3RhbnRzJztcclxuXHJcbmNvbnN0IENhcmQgPSBmb3J3YXJkUmVmKCh7XHJcbiAgICBvdXRsaW5lZCA9IGZhbHNlLFxyXG5cclxuICAgIGVsZW1lbnQgPSAnZGl2JyxcclxuICAgIGNvbXBvbmVudDogRWxlbWVudCA9IGVsZW1lbnQsXHJcbiAgICBjbGFzc05hbWUsXHJcbiAgICAuLi5wcm9wc1xyXG59LCByZWYpID0+IHtcclxuICAgIGNvbnN0IGNsYXNzTmFtZXMgPSBjbGFzc25hbWVzKGNzc0NsYXNzZXMuUk9PVCwge1xyXG4gICAgICAgIFtjc3NDbGFzc2VzLk9VVExJTkVEXTogb3V0bGluZWRcclxuICAgIH0sIGNsYXNzTmFtZSk7XHJcblxyXG4gICAgcmV0dXJuIChcclxuICAgICAgICA8RWxlbWVudCByZWY9e3JlZn0gY2xhc3NOYW1lPXtjbGFzc05hbWVzfSB7Li4ucHJvcHN9IC8+XHJcbiAgICApO1xyXG59KTtcclxuXHJcbkNhcmQuZGlzcGxheU5hbWUgPSAnTURDQ2FyZCc7XHJcblxyXG5DYXJkLnByb3BUeXBlcyA9IHtcclxuICAgIG91dGxpbmVkOiBQcm9wVHlwZXMuYm9vbFxyXG59O1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgQ2FyZDsiLCJpbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xyXG5pbXBvcnQgY2xhc3NuYW1lcyBmcm9tICdjbGFzc25hbWVzJztcclxuXHJcbmltcG9ydCB7IENsb25lIH0gZnJvbSAnLi4vY29tcG9uZW50JztcclxuXHJcbmltcG9ydCB7IGNzc0NsYXNzZXMgfSBmcm9tICcuL2NvbnN0YW50cyc7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBDYXJkQWN0aW9uKHtcclxuICAgIGJ1dHRvbiA9IGZhbHNlLFxyXG4gICAgaWNvbiA9IGZhbHNlLFxyXG5cclxuICAgIGNvbXBvbmVudCxcclxuICAgIGNsYXNzTmFtZSxcclxuICAgIGNoaWxkcmVuID0gY29tcG9uZW50LFxyXG4gICAgLi4ucHJvcHNcclxufSkge1xyXG4gICAgY29uc3QgY2xhc3NOYW1lcyA9IGNsYXNzbmFtZXMoY3NzQ2xhc3Nlcy5BQ1RJT04sIHtcclxuICAgICAgICBbY3NzQ2xhc3Nlcy5BQ1RJT05fQlVUVE9OXTogYnV0dG9uLFxyXG4gICAgICAgIFtjc3NDbGFzc2VzLkFDVElPTl9JQ09OXTogaWNvblxyXG4gICAgfSwgY2xhc3NOYW1lKTtcclxuXHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAgIDxDbG9uZVxyXG4gICAgICAgICAgICBjb21wb25lbnQ9e2NoaWxkcmVufVxyXG4gICAgICAgICAgICBjbGFzc05hbWU9e2NsYXNzTmFtZXN9XHJcbiAgICAgICAgICAgIHsuLi5wcm9wc31cclxuICAgICAgICAvPlxyXG4gICAgKTtcclxufVxyXG5cclxuQ2FyZEFjdGlvbi5kaXNwbGF5TmFtZSA9ICdNRENDYXJkQWN0aW9uJztcclxuXHJcbkNhcmRBY3Rpb24ucHJvcFR5cGVzID0ge1xyXG4gICAgYnV0dG9uOiBQcm9wVHlwZXMuYm9vbCxcclxuICAgIGljb246IFByb3BUeXBlcy5ib29sXHJcbn07IiwiaW1wb3J0IHsgZm9yd2FyZFJlZiB9IGZyb20gJ3JlYWN0JztcclxuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcclxuaW1wb3J0IGNsYXNzbmFtZXMgZnJvbSAnY2xhc3NuYW1lcyc7XHJcblxyXG5pbXBvcnQgeyBjc3NDbGFzc2VzIH0gZnJvbSAnLi9jb25zdGFudHMnO1xyXG5cclxuY29uc3QgQ2FyZEFjdGlvbnMgPSBmb3J3YXJkUmVmKCh7XHJcbiAgICBmdWxsQmxlZWQgPSBmYWxzZSxcclxuXHJcbiAgICBlbGVtZW50OiBFbGVtZW50ID0gJ2RpdicsXHJcbiAgICBjbGFzc05hbWUsXHJcbiAgICAuLi5wcm9wc1xyXG59LCByZWYpID0+IHtcclxuICAgIGNvbnN0IGNsYXNzTmFtZXMgPSBjbGFzc25hbWVzKGNzc0NsYXNzZXMuQUNUSU9OUywge1xyXG4gICAgICAgIFtjc3NDbGFzc2VzLkFDVElPTlNfRlVMTF9CTEVFRF06IGZ1bGxCbGVlZFxyXG4gICAgfSwgY2xhc3NOYW1lKTtcclxuXHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAgIDxFbGVtZW50IHJlZj17cmVmfSBjbGFzc05hbWU9e2NsYXNzTmFtZXN9IHsuLi5wcm9wc30gLz5cclxuICAgICk7XHJcbn0pO1xyXG5cclxuQ2FyZEFjdGlvbnMuZGlzcGxheU5hbWUgPSAnTURDQ2FyZEFjdGlvbnMnO1xyXG5cclxuQ2FyZEFjdGlvbnMucHJvcFR5cGVzID0ge1xyXG4gICAgZnVsbEJsZWVkOiBQcm9wVHlwZXMuYm9vbFxyXG59O1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgQ2FyZEFjdGlvbnM7IiwiaW1wb3J0IHsgZm9yd2FyZFJlZiB9IGZyb20gJ3JlYWN0JztcclxuaW1wb3J0IGNsYXNzbmFtZXMgZnJvbSAnY2xhc3NuYW1lcyc7XHJcblxyXG5pbXBvcnQgeyBDbG9uZSB9IGZyb20gJy4uL2NvbXBvbmVudCc7XHJcblxyXG5pbXBvcnQgeyBjc3NDbGFzc2VzIH0gZnJvbSAnLi9jb25zdGFudHMnO1xyXG5cclxuY29uc3QgQ2FyZEFjdGlvbkJ1dHRvbnMgPSBmb3J3YXJkUmVmKCh7XHJcbiAgICBlbGVtZW50ID0gJ2RpdicsXHJcbiAgICBjb21wb25lbnQ6IEVsZW1lbnQgPSBlbGVtZW50LFxyXG4gICAgY2xhc3NOYW1lLFxyXG4gICAgY2hpbGRyZW4sXHJcbiAgICAuLi5wcm9wc1xyXG59LCByZWYpID0+IHtcclxuICAgIGNvbnN0IGNsYXNzTmFtZXMgPSBjbGFzc25hbWVzKGNzc0NsYXNzZXMuQUNUSU9OX0JVVFRPTlMsIGNsYXNzTmFtZSk7XHJcblxyXG4gICAgcmV0dXJuIChcclxuICAgICAgICA8RWxlbWVudCByZWY9e3JlZn0gY2xhc3NOYW1lPXtjbGFzc05hbWVzfSB7Li4ucHJvcHN9PlxyXG4gICAgICAgICAgICA8Q2xvbmVcclxuICAgICAgICAgICAgICAgIGNvbXBvbmVudD17Y2hpbGRyZW59XHJcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU9e2Ake2Nzc0NsYXNzZXMuQUNUSU9OfSAke2Nzc0NsYXNzZXMuQUNUSU9OX0JVVFRPTn1gfVxyXG4gICAgICAgICAgICAvPlxyXG4gICAgICAgIDwvRWxlbWVudD5cclxuICAgICk7XHJcbn0pO1xyXG5cclxuQ2FyZEFjdGlvbkJ1dHRvbnMuZGlzcGxheU5hbWUgPSAnTURDQ2FyZEFjdGlvbkJ1dHRvbnMnO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgQ2FyZEFjdGlvbkJ1dHRvbnM7IiwiaW1wb3J0IHsgZm9yd2FyZFJlZiB9IGZyb20gJ3JlYWN0JztcclxuaW1wb3J0IGNsYXNzbmFtZXMgZnJvbSAnY2xhc3NuYW1lcyc7XHJcblxyXG5pbXBvcnQgeyBDbG9uZSB9IGZyb20gJy4uL2NvbXBvbmVudCc7XHJcblxyXG5pbXBvcnQgeyBjc3NDbGFzc2VzIH0gZnJvbSAnLi9jb25zdGFudHMnO1xyXG5cclxuY29uc3QgQ2FyZEFjdGlvbkljb25zID0gZm9yd2FyZFJlZigoe1xyXG4gICAgZWxlbWVudCA9ICdkaXYnLFxyXG4gICAgY29tcG9uZW50OiBFbGVtZW50ID0gZWxlbWVudCxcclxuICAgIGNsYXNzTmFtZSxcclxuICAgIGNoaWxkcmVuLFxyXG4gICAgLi4ucHJvcHNcclxufSwgcmVmKSA9PiB7XHJcbiAgICBjb25zdCBjbGFzc05hbWVzID0gY2xhc3NuYW1lcyhjc3NDbGFzc2VzLkFDVElPTl9JQ09OUywgY2xhc3NOYW1lKTtcclxuXHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAgIDxFbGVtZW50IHJlZj17cmVmfSBjbGFzc05hbWU9e2NsYXNzTmFtZXN9IHsuLi5wcm9wc30+XHJcbiAgICAgICAgICAgIDxDbG9uZVxyXG4gICAgICAgICAgICAgICAgY29tcG9uZW50PXtjaGlsZHJlbn1cclxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZT17YCR7Y3NzQ2xhc3Nlcy5BQ1RJT059ICR7Y3NzQ2xhc3Nlcy5BQ1RJT05fSUNPTn1gfVxyXG4gICAgICAgICAgICAvPlxyXG4gICAgICAgIDwvRWxlbWVudD5cclxuICAgICk7XHJcbn0pO1xyXG5cclxuQ2FyZEFjdGlvbkljb25zLmRpc3BsYXlOYW1lID0gJ01EQ0NhcmRBY3Rpb25JY29ucyc7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBDYXJkQWN0aW9uSWNvbnM7IiwiaW1wb3J0IHsgQ2hpbGRyZW4sIGZvcndhcmRSZWYgfSBmcm9tICdyZWFjdCc7XHJcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XHJcbmltcG9ydCBjbGFzc25hbWVzIGZyb20gJ2NsYXNzbmFtZXMnO1xyXG5cclxuaW1wb3J0IHsgQ2xvbmUgfSBmcm9tICcuLi9jb21wb25lbnQnO1xyXG5cclxuaW1wb3J0IHsgY3NzQ2xhc3NlcyB9IGZyb20gJy4vY29uc3RhbnRzJztcclxuXHJcbmNvbnN0IENhcmRIZWFkZXIgPSBmb3J3YXJkUmVmKCh7XHJcbiAgICB0aXRsZSxcclxuICAgIHN1YnRpdGxlLFxyXG4gICAgb3ZlcmxpbmUsXHJcbiAgICBncmFwaGljLFxyXG4gICAgYWN0aW9ucyxcclxuXHJcbiAgICBlbGVtZW50ID0gJ2RpdicsXHJcbiAgICBjb21wb25lbnQ6IEVsZW1lbnQgPSBlbGVtZW50LFxyXG4gICAgY2xhc3NOYW1lLFxyXG4gICAgY2hpbGRyZW4sXHJcbiAgICAuLi5wcm9wc1xyXG59LCByZWYpID0+IHtcclxuICAgIGNvbnN0IGNsYXNzTmFtZXMgPSBjbGFzc25hbWVzKGNzc0NsYXNzZXMuSEVBREVSLCBjbGFzc05hbWUpO1xyXG5cclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgPEVsZW1lbnQgcmVmPXtyZWZ9IGNsYXNzTmFtZT17Y2xhc3NOYW1lc30gey4uLnByb3BzfT5cclxuICAgICAgICAgICAge2dyYXBoaWMgJiZcclxuICAgICAgICAgICAgICAgIDxDbG9uZVxyXG4gICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudD17Z3JhcGhpY31cclxuICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU9e2Nzc0NsYXNzZXMuSEVBREVSX0dSQVBISUN9XHJcbiAgICAgICAgICAgICAgICAvPlxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17Y3NzQ2xhc3Nlcy5IRUFERVJfQ09OVEVOVH0+XHJcbiAgICAgICAgICAgICAgICB7b3ZlcmxpbmUgJiZcclxuICAgICAgICAgICAgICAgICAgICA8Q2xvbmVcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50PXtvdmVybGluZX1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZmFsbGJhY2s9XCJzcGFuXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPXtjc3NDbGFzc2VzLk9WRVJMSU5FfVxyXG4gICAgICAgICAgICAgICAgICAgIC8+XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAge3RpdGxlICYmXHJcbiAgICAgICAgICAgICAgICAgICAgPENsb25lXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudD17dGl0bGV9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZhbGxiYWNrPVwiaDJcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU9e2Nzc0NsYXNzZXMuVElUTEV9XHJcbiAgICAgICAgICAgICAgICAgICAgLz5cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICB7c3VidGl0bGUgJiZcclxuICAgICAgICAgICAgICAgICAgICA8Q2xvbmVcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50PXtzdWJ0aXRsZX1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZmFsbGJhY2s9XCJoM1wiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT17Y3NzQ2xhc3Nlcy5TVUJUSVRMRX1cclxuICAgICAgICAgICAgICAgICAgICAvPlxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHtjaGlsZHJlbn1cclxuICAgICAgICAgICAgPC9kaXY+XHJcblxyXG4gICAgICAgICAgICB7YWN0aW9ucyAmJlxyXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9e2Nzc0NsYXNzZXMuSEVBREVSX0FDVElPTlN9PlxyXG4gICAgICAgICAgICAgICAgICAgIHtDaGlsZHJlbi5tYXAoYWN0aW9ucywgYWN0aW9uID0+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxDbG9uZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50PXthY3Rpb259XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU9e2Nzc0NsYXNzZXMuQUNUSU9OfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvPlxyXG4gICAgICAgICAgICAgICAgICAgICl9XHJcbiAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIDwvRWxlbWVudD5cclxuICAgICk7XHJcbn0pO1xyXG5cclxuQ2FyZEhlYWRlci5kaXNwbGF5TmFtZSA9ICdNRENDYXJkSGVhZGVyJztcclxuXHJcbkNhcmRIZWFkZXIucHJvcFR5cGVzID0ge1xyXG4gICAgdGl0bGU6IFByb3BUeXBlcy5ub2RlLFxyXG4gICAgc3VidGl0bGU6IFByb3BUeXBlcy5ub2RlLFxyXG4gICAgb3ZlcmxpbmU6IFByb3BUeXBlcy5ub2RlLFxyXG4gICAgZ3JhcGhpYzogUHJvcFR5cGVzLmVsZW1lbnQsXHJcbiAgICBhY3Rpb25zOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtcclxuICAgICAgICBQcm9wVHlwZXMuZWxlbWVudCxcclxuICAgICAgICBQcm9wVHlwZXMuYXJyYXlPZihQcm9wVHlwZXMuZWxlbWVudClcclxuICAgIF0pXHJcbn07XHJcblxyXG5leHBvcnQgZGVmYXVsdCBDYXJkSGVhZGVyOyIsImltcG9ydCB7IGZvcndhcmRSZWYgfSBmcm9tICdyZWFjdCc7XHJcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XHJcbmltcG9ydCBjbGFzc25hbWVzIGZyb20gJ2NsYXNzbmFtZXMnO1xyXG5cclxuaW1wb3J0IHsgY3NzQ2xhc3NlcyB9IGZyb20gJy4vY29uc3RhbnRzJztcclxuXHJcbmNvbnN0IENhcmRNZWRpYSA9IGZvcndhcmRSZWYoKHtcclxuICAgIGltYWdlVXJsLFxyXG4gICAgY29udGVudCxcclxuICAgIHNxdWFyZSA9IGZhbHNlLFxyXG4gICAgd2lkZSA9IGZhbHNlLFxyXG5cclxuICAgIGVsZW1lbnQgPSAnZGl2JyxcclxuICAgIGNvbXBvbmVudDogRWxlbWVudCA9IGVsZW1lbnQsXHJcbiAgICBjbGFzc05hbWUsXHJcbiAgICBjaGlsZHJlbiA9IGNvbnRlbnQsXHJcbiAgICAuLi5wcm9wc1xyXG59LCByZWYpID0+IHtcclxuICAgIGNvbnN0IGNsYXNzTmFtZXMgPSBjbGFzc25hbWVzKGNzc0NsYXNzZXMuTUVESUEsIHtcclxuICAgICAgICBbY3NzQ2xhc3Nlcy5NRURJQV9TUVVBUkVdOiBzcXVhcmUsXHJcbiAgICAgICAgW2Nzc0NsYXNzZXMuTUVESUFfV0lERV06IHdpZGUsXHJcbiAgICB9LCBjbGFzc05hbWUpO1xyXG5cclxuICAgIGNvbnN0IHN0eWxlID0gaW1hZ2VVcmwgPyB7XHJcbiAgICAgICAgYmFja2dyb3VuZEltYWdlOiBgdXJsKCR7aW1hZ2VVcmx9KWBcclxuICAgIH0gOiB1bmRlZmluZWQ7XHJcblxyXG4gICAgcmV0dXJuIChcclxuICAgICAgICA8RWxlbWVudCByZWY9e3JlZn0gY2xhc3NOYW1lPXtjbGFzc05hbWVzfSBzdHlsZT17c3R5bGV9IHsuLi5wcm9wc30+XHJcbiAgICAgICAgICAgIHtjaGlsZHJlbiAmJlxyXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9e2Nzc0NsYXNzZXMuTUVESUFfQ09OVEVOVH0+e2NoaWxkcmVufTwvZGl2PlxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgPC9FbGVtZW50PlxyXG4gICAgKTtcclxufSk7XHJcblxyXG5DYXJkTWVkaWEuZGlzcGxheU5hbWUgPSAnTURDQ2FyZE1lZGlhJztcclxuXHJcbkNhcmRNZWRpYS5wcm9wVHlwZXMgPSB7XHJcbiAgICBpbWFnZVVybDogUHJvcFR5cGVzLnN0cmluZyxcclxuICAgIGNvbnRlbnQ6IFByb3BUeXBlcy5ub2RlLFxyXG4gICAgc3F1YXJlOiBQcm9wVHlwZXMuYm9vbCxcclxuICAgIHdpZGU6IFByb3BUeXBlcy5ib29sXHJcbn07XHJcblxyXG5leHBvcnQgZGVmYXVsdCBDYXJkTWVkaWE7IiwiaW1wb3J0IHsgZm9yd2FyZFJlZiB9IGZyb20gJ3JlYWN0JztcclxuaW1wb3J0IGNsYXNzbmFtZXMgZnJvbSAnY2xhc3NuYW1lcyc7XHJcblxyXG5pbXBvcnQgeyBjc3NDbGFzc2VzIH0gZnJvbSAnLi9jb25zdGFudHMnO1xyXG5cclxuY29uc3QgQ2FyZFByaW1hcnlBY3Rpb24gPSBmb3J3YXJkUmVmKCh7XHJcbiAgICBlbGVtZW50ID0gJ2RpdicsXHJcbiAgICBjb21wb25lbnQ6IEVsZW1lbnQgPSBlbGVtZW50LFxyXG4gICAgY2xhc3NOYW1lLFxyXG4gICAgY2hpbGRyZW4sXHJcbiAgICAuLi5wcm9wc1xyXG59LCByZWYpID0+IHtcclxuICAgIGNvbnN0IGNsYXNzTmFtZXMgPSBjbGFzc25hbWVzKGNzc0NsYXNzZXMuUFJJTUFSWV9BQ1RJT04sIGNsYXNzTmFtZSk7XHJcblxyXG4gICAgcmV0dXJuIChcclxuICAgICAgICA8RWxlbWVudCByZWY9e3JlZn0gY2xhc3NOYW1lPXtjbGFzc05hbWVzfSB0YWJJbmRleD1cIjBcIiB7Li4ucHJvcHN9PlxyXG4gICAgICAgICAgICB7Y2hpbGRyZW59XHJcblxyXG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17Y3NzQ2xhc3Nlcy5SSVBQTEV9IC8+XHJcbiAgICAgICAgPC9FbGVtZW50PlxyXG4gICAgKTtcclxufSk7XHJcblxyXG5DYXJkUHJpbWFyeUFjdGlvbi5kaXNwbGF5TmFtZSA9ICdNRENDYXJkUHJpbWFyeUFjdGlvbic7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBDYXJkUHJpbWFyeUFjdGlvbjsiLCJpbXBvcnQgeyBmb3J3YXJkUmVmIH0gZnJvbSAncmVhY3QnO1xyXG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xyXG5pbXBvcnQgY2xhc3NuYW1lcyBmcm9tICdjbGFzc25hbWVzJztcclxuXHJcbmltcG9ydCB7IGNzc0NsYXNzZXMgfSBmcm9tICcuL2NvbnN0YW50cyc7XHJcblxyXG5jb25zdCBDYXJkU2VjdGlvbiA9IGZvcndhcmRSZWYoKHtcclxuICAgIHByaW1hcnkgPSBmYWxzZSxcclxuICAgIHNlY29uZGFyeSA9IGZhbHNlLFxyXG5cclxuICAgIGVsZW1lbnQgPSAnZGl2JyxcclxuICAgIGNvbXBvbmVudDogRWxlbWVudCA9IGVsZW1lbnQsXHJcbiAgICBjbGFzc05hbWUsXHJcbiAgICAuLi5wcm9wc1xyXG59LCByZWYpID0+IHtcclxuICAgIGNvbnN0IGNsYXNzTmFtZXMgPSBjbGFzc25hbWVzKGNzc0NsYXNzZXMuU0VDVElPTiwge1xyXG4gICAgICAgIFtjc3NDbGFzc2VzLlNFQ1RJT05fUFJJTUFSWV06IHByaW1hcnksXHJcbiAgICAgICAgW2Nzc0NsYXNzZXMuU0VDVElPTl9TRUNPTkRBUlldOiBzZWNvbmRhcnksXHJcbiAgICB9LCBjbGFzc05hbWUpO1xyXG5cclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgPEVsZW1lbnQgcmVmPXtyZWZ9IGNsYXNzTmFtZT17Y2xhc3NOYW1lc30gey4uLnByb3BzfSAvPlxyXG4gICAgKTtcclxufSk7XHJcblxyXG5DYXJkU2VjdGlvbi5kaXNwbGF5TmFtZSA9ICdNRENDYXJkU2VjdGlvbic7XHJcblxyXG5DYXJkU2VjdGlvbi5wcm9wVHlwZXMgPSB7XHJcbiAgICBwcmltYXJ5OiBQcm9wVHlwZXMuYm9vbCxcclxuICAgIHNlY29uZGFyeTogUHJvcFR5cGVzLmJvb2xcclxufTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IENhcmRTZWN0aW9uOyIsImltcG9ydCBDYXJkIGZyb20gJy4vQ2FyZCc7XHJcbmltcG9ydCBDYXJkQWN0aW9uIGZyb20gJy4vQ2FyZEFjdGlvbic7XHJcbmltcG9ydCBDYXJkQWN0aW9ucyBmcm9tICcuL0NhcmRBY3Rpb25zJztcclxuaW1wb3J0IENhcmRBY3Rpb25CdXR0b25zIGZyb20gJy4vQ2FyZEFjdGlvbkJ1dHRvbnMnO1xyXG5pbXBvcnQgQ2FyZEFjdGlvbkljb25zIGZyb20gJy4vQ2FyZEFjdGlvbkljb25zJztcclxuaW1wb3J0IENhcmRIZWFkZXIgZnJvbSAnLi9DYXJkSGVhZGVyJztcclxuaW1wb3J0IENhcmRNZWRpYSBmcm9tICcuL0NhcmRNZWRpYSc7XHJcbmltcG9ydCBDYXJkUHJpbWFyeUFjdGlvbiBmcm9tICcuL0NhcmRQcmltYXJ5QWN0aW9uJztcclxuaW1wb3J0IENhcmRTZWN0aW9uIGZyb20gJy4vQ2FyZFNlY3Rpb24nO1xyXG5cclxuQ2FyZC5BY3Rpb24gPSBDYXJkQWN0aW9uO1xyXG5DYXJkLkFjdGlvbnMgPSBDYXJkQWN0aW9ucztcclxuQ2FyZC5BY3Rpb25CdXR0b25zID0gQ2FyZEFjdGlvbkJ1dHRvbnM7XHJcbkNhcmQuQWN0aW9uSWNvbnMgPSBDYXJkQWN0aW9uSWNvbnM7XHJcbkNhcmQuSGVhZGVyID0gQ2FyZEhlYWRlcjtcclxuQ2FyZC5NZWRpYSA9IENhcmRNZWRpYTtcclxuQ2FyZC5QcmltYXJ5QWN0aW9uID0gQ2FyZFByaW1hcnlBY3Rpb247XHJcbkNhcmQuU2VjdGlvbiA9IENhcmRTZWN0aW9uO1xyXG5cclxuZXhwb3J0IHtcclxuICAgIENhcmQgYXMgZGVmYXVsdCxcclxuICAgIENhcmRBY3Rpb24sXHJcbiAgICBDYXJkQWN0aW9ucyxcclxuICAgIENhcmRBY3Rpb25CdXR0b25zLFxyXG4gICAgQ2FyZEFjdGlvbkljb25zLFxyXG4gICAgQ2FyZEhlYWRlcixcclxuICAgIENhcmRNZWRpYSxcclxuICAgIENhcmRQcmltYXJ5QWN0aW9uLFxyXG4gICAgQ2FyZFNlY3Rpb25cclxufTsiLCJleHBvcnQgY29uc3QgY3NzQ2xhc3NlcyA9IHtcclxuICAgIFJPT1Q6ICdtZGMtY2hlY2tib3gnLFxyXG4gICAgU0VMRUNURUQ6ICdtZGMtY2hlY2tib3gtLXNlbGVjdGVkJyxcclxuICAgIFRPVUNIOiAnbWRjLWNoZWNrYm94LS10b3VjaCcsXHJcbiAgICBESVNBQkxFRDogJ21kYy1jaGVja2JveC0tZGlzYWJsZWQnLFxyXG4gICAgQU5JTV9DSEVDS0VEX0lOREVURVJNSU5BVEU6ICdtZGMtY2hlY2tib3gtLWFuaW0tY2hlY2tlZC1pbmRldGVybWluYXRlJyxcclxuICAgIEFOSU1fQ0hFQ0tFRF9VTkNIRUNLRUQ6ICdtZGMtY2hlY2tib3gtLWFuaW0tY2hlY2tlZC11bmNoZWNrZWQnLFxyXG4gICAgQU5JTV9JTkRFVEVSTUlOQVRFX0NIRUNLRUQ6ICdtZGMtY2hlY2tib3gtLWFuaW0taW5kZXRlcm1pbmF0ZS1jaGVja2VkJyxcclxuICAgIEFOSU1fSU5ERVRFUk1JTkFURV9VTkNIRUNLRUQ6ICdtZGMtY2hlY2tib3gtLWFuaW0taW5kZXRlcm1pbmF0ZS11bmNoZWNrZWQnLFxyXG4gICAgQU5JTV9VTkNIRUNLRURfQ0hFQ0tFRDogJ21kYy1jaGVja2JveC0tYW5pbS11bmNoZWNrZWQtY2hlY2tlZCcsXHJcbiAgICBBTklNX1VOQ0hFQ0tFRF9JTkRFVEVSTUlOQVRFOiAnbWRjLWNoZWNrYm94LS1hbmltLXVuY2hlY2tlZC1pbmRldGVybWluYXRlJyxcclxuXHJcbiAgICBOQVRJVkVfQ09OVFJPTDogJ21kYy1jaGVja2JveF9fbmF0aXZlLWNvbnRyb2wnLFxyXG4gICAgQkFDS0dST1VORDogJ21kYy1jaGVja2JveF9fYmFja2dyb3VuZCcsXHJcbiAgICBDSEVDS01BUks6ICdtZGMtY2hlY2tib3hfX2NoZWNrbWFyaycsXHJcbiAgICBDSEVDS01BUktfUEFUSDogJ21kYy1jaGVja2JveF9fY2hlY2ttYXJrLXBhdGgnLFxyXG4gICAgTUlYRURNQVJLOiAnbWRjLWNoZWNrYm94X19taXhlZG1hcmsnLFxyXG4gICAgUklQUExFOiAnbWRjLWNoZWNrYm94X19yaXBwbGUnXHJcbn07IiwiaW1wb3J0IHsgZm9yd2FyZFJlZiwgdXNlUmVmLCB1c2VFZmZlY3QsIHVzZUNhbGxiYWNrIH0gZnJvbSAncmVhY3QnO1xyXG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xyXG5pbXBvcnQgY2xhc3NuYW1lcyBmcm9tICdjbGFzc25hbWVzJztcclxuXHJcbmltcG9ydCB7IGNzc0NsYXNzZXMgfSBmcm9tICcuL2NvbnN0YW50cyc7XHJcblxyXG5jb25zdCBDaGVja2JveCA9IGZvcndhcmRSZWYoKHtcclxuICAgIGNoZWNrZWQsXHJcbiAgICBpbmRldGVybWluYXRlLFxyXG4gICAgZGlzYWJsZWQgPSBmYWxzZSxcclxuICAgIHRvdWNoID0gZmFsc2UsXHJcbiAgICBvbkNoYW5nZSA9IEZ1bmN0aW9uLnByb3RvdHlwZSxcclxuXHJcbiAgICBjbGFzc05hbWUsXHJcbiAgICAuLi5wcm9wc1xyXG59LCByZWYpID0+IHtcclxuICAgIGNvbnN0IGlucHV0UmVmID0gdXNlUmVmKCk7XHJcblxyXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgICAgICBpbnB1dFJlZi5jdXJyZW50LmluZGV0ZXJtaW5hdGUgPSBpbmRldGVybWluYXRlO1xyXG4gICAgfSwgW2luZGV0ZXJtaW5hdGVdKTtcclxuXHJcbiAgICBjb25zdCBoYW5kbGVDaGFuZ2UgPSB1c2VDYWxsYmFjayhldmVudCA9PiB7XHJcbiAgICAgICAgb25DaGFuZ2UoZXZlbnQsIGV2ZW50LnRhcmdldC5jaGVja2VkLCBldmVudC50YXJnZXQpO1xyXG4gICAgfSwgW29uQ2hhbmdlXSk7XHJcblxyXG4gICAgY29uc3QgY2xhc3NOYW1lcyA9IGNsYXNzbmFtZXMoY3NzQ2xhc3Nlcy5ST09ULCB7XHJcbiAgICAgICAgW2Nzc0NsYXNzZXMuU0VMRUNURURdOiBjaGVja2VkLFxyXG4gICAgICAgIFtjc3NDbGFzc2VzLkRJU0FCTEVEXTogZGlzYWJsZWQsXHJcbiAgICAgICAgW2Nzc0NsYXNzZXMuVE9VQ0hdOiB0b3VjaFxyXG4gICAgfSwgY2xhc3NOYW1lKTtcclxuXHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAgIDxkaXYgcmVmPXtyZWZ9IGNsYXNzTmFtZT17Y2xhc3NOYW1lc30+XHJcbiAgICAgICAgICAgIDxpbnB1dFxyXG4gICAgICAgICAgICAgICAgcmVmPXtpbnB1dFJlZn1cclxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZT17Y3NzQ2xhc3Nlcy5OQVRJVkVfQ09OVFJPTH1cclxuICAgICAgICAgICAgICAgIHR5cGU9XCJjaGVja2JveFwiXHJcbiAgICAgICAgICAgICAgICBjaGVja2VkPXtjaGVja2VkfVxyXG4gICAgICAgICAgICAgICAgZGlzYWJsZWQ9e2Rpc2FibGVkfVxyXG4gICAgICAgICAgICAgICAgb25DaGFuZ2U9e2hhbmRsZUNoYW5nZX1cclxuICAgICAgICAgICAgICAgIHsuLi5wcm9wc31cclxuICAgICAgICAgICAgLz5cclxuXHJcbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXtjc3NDbGFzc2VzLkJBQ0tHUk9VTkR9PlxyXG4gICAgICAgICAgICAgICAgPHN2ZyBjbGFzc05hbWU9e2Nzc0NsYXNzZXMuQ0hFQ0tNQVJLfSB2aWV3Qm94PVwiMCAwIDI0IDI0XCI+XHJcbiAgICAgICAgICAgICAgICAgICAgPHBhdGggY2xhc3NOYW1lPXtjc3NDbGFzc2VzLkNIRUNLTUFSS19QQVRIfSBmaWxsPVwibm9uZVwiIGQ9XCJNMS43MywxMi45MSA4LjEsMTkuMjggMjIuNzksNC41OVwiIC8+XHJcbiAgICAgICAgICAgICAgICA8L3N2Zz5cclxuXHJcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17Y3NzQ2xhc3Nlcy5NSVhFRE1BUkt9IC8+XHJcbiAgICAgICAgICAgIDwvZGl2PlxyXG5cclxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9e2Nzc0NsYXNzZXMuUklQUExFfSAvPlxyXG4gICAgICAgIDwvZGl2PlxyXG4gICAgKTtcclxufSk7XHJcblxyXG5DaGVja2JveC5kaXNwbGF5TmFtZSA9ICdNRENDaGVja2JveCc7XHJcblxyXG5DaGVja2JveC5wcm9wVHlwZXMgPSB7XHJcbiAgICBjaGVja2VkOiBQcm9wVHlwZXMuYm9vbCxcclxuICAgIGluZGV0ZXJtaW5hdGU6IFByb3BUeXBlcy5ib29sLFxyXG4gICAgZGlzYWJsZWQ6IFByb3BUeXBlcy5ib29sLFxyXG4gICAgdG91Y2g6IFByb3BUeXBlcy5ib29sLFxyXG4gICAgb25DaGFuZ2U6IFByb3BUeXBlcy5mdW5jXHJcbn07XHJcblxyXG5leHBvcnQgZGVmYXVsdCBDaGVja2JveDsiLCJleHBvcnQgeyBkZWZhdWx0IH0gZnJvbSAnLi9DaGVja2JveCc7IiwiZXhwb3J0IGNvbnN0IG51bWJlcnMgPSB7XHJcbiAgICBTRUxFQ1RJTkdfQU5JTUFUSU9OX01TOiAxNTAsXHJcbiAgICBERVNFTEVDVElOR19BTklNQVRJT05fTVM6IDEwMFxyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IGNoaXBTZXRDc3NDbGFzc2VzID0ge1xyXG4gICAgUk9PVDogJ21kYy1ldm9sdXRpb24tY2hpcC1zZXQnLFxyXG4gICAgT1ZFUkZMT1c6ICdtZGMtZXZvbHV0aW9uLWNoaXAtc2V0LS1vdmVyZmxvdycsXHJcbiAgICBDSElQUzogJ21kYy1ldm9sdXRpb24tY2hpcC1zZXRfX2NoaXBzJ1xyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IGNoaXBDc3NDbGFzc2VzID0ge1xyXG4gICAgUk9PVDogJ21kYy1ldm9sdXRpb24tY2hpcCcsXHJcbiAgICBGSUxURVI6ICdtZGMtZXZvbHV0aW9uLWNoaXAtLWZpbHRlcicsXHJcbiAgICBTRUxFQ1RBQkxFOiAnbWRjLWV2b2x1dGlvbi1jaGlwLS1zZWxlY3RhYmxlJyxcclxuICAgIFNFTEVDVEVEOiAnbWRjLWV2b2x1dGlvbi1jaGlwLS1zZWxlY3RlZCcsXHJcbiAgICBTRUxFQ1RJTkc6ICdtZGMtZXZvbHV0aW9uLWNoaXAtLXNlbGVjdGluZycsXHJcbiAgICBTRUxFQ1RJTkdfV0lUSF9QUklNQVJZX0lDT046ICdtZGMtZXZvbHV0aW9uLWNoaXAtLXNlbGVjdGluZy13aXRoLXByaW1hcnktaWNvbicsXHJcbiAgICBERVNFTEVDVElORzogJ21kYy1ldm9sdXRpb24tY2hpcC0tZGVzZWxlY3RpbmcnLFxyXG4gICAgREVTRUxFQ1RJTkdfV0lUSF9QUklNQVJZX0lDT046ICdtZGMtZXZvbHV0aW9uLWNoaXAtLWRlc2VsZWN0aW5nLXdpdGgtcHJpbWFyeS1pY29uJyxcclxuICAgIE9VVExJTkVEOiAnbWRjLWV2b2x1dGlvbi1jaGlwLS1vdXRsaW5lZCcsXHJcbiAgICBFTlRFUjogJ21kYy1ldm9sdXRpb24tY2hpcC0tZW50ZXInLFxyXG4gICAgRVhJVDogJ21kYy1ldm9sdXRpb24tY2hpcC0tZXhpdCcsXHJcbiAgICBISURERU46ICdtZGMtZXZvbHV0aW9uLWNoaXAtLWhpZGRlbicsXHJcbiAgICBESVNBQkxFRDogJ21kYy1ldm9sdXRpb24tY2hpcC0tZGlzYWJsZWQnLFxyXG4gICAgVE9VQ0g6ICdtZGMtZXZvbHV0aW9uLWNoaXAtLXRvdWNoJyxcclxuICAgIFdJVEhfUFJJTUFSWV9HUkFQSElDOiAnbWRjLWV2b2x1dGlvbi1jaGlwLS13aXRoLXByaW1hcnktZ3JhcGhpYycsXHJcbiAgICBXSVRIX1BSSU1BUllfSUNPTjogJ21kYy1ldm9sdXRpb24tY2hpcC0td2l0aC1wcmltYXJ5LWljb24nLFxyXG4gICAgV0lUSF9UUkFJTElOR19BQ1RJT046ICdtZGMtZXZvbHV0aW9uLWNoaXAtLXdpdGgtdHJhaWxpbmctYWN0aW9uJyxcclxuICAgIFdJVEhfQVZBVEFSOiAnbWRjLWV2b2x1dGlvbi1jaGlwLS13aXRoLWF2YXRhcicsXHJcblxyXG4gICAgQ0VMTDogJ21kYy1ldm9sdXRpb24tY2hpcF9fY2VsbCcsXHJcbiAgICBQUklNQVJZX0NFTEw6ICdtZGMtZXZvbHV0aW9uLWNoaXBfX2NlbGwtLXByaW1hcnknLFxyXG4gICAgVFJBSUxJTkdfQ0VMTDogJ21kYy1ldm9sdXRpb24tY2hpcF9fY2VsbC0tdHJhaWxpbmcnLFxyXG5cclxuICAgIEFDVElPTjogJ21kYy1ldm9sdXRpb24tY2hpcF9fYWN0aW9uJyxcclxuICAgIFBSSU1BUllfQUNUSU9OOiAnbWRjLWV2b2x1dGlvbi1jaGlwX19hY3Rpb24tLXByaW1hcnknLFxyXG4gICAgVFJBSUxJTkdfQUNUSU9OOiAnbWRjLWV2b2x1dGlvbi1jaGlwX19hY3Rpb24tLXRyYWlsaW5nJyxcclxuICAgIFBSRVNFTlRBVElPTkFMX0FDVElPTjogJ21kYy1ldm9sdXRpb24tY2hpcF9fYWN0aW9uLS1wcmVzZW50YXRpb25hbCcsXHJcbiAgICBBQ1RJT05fVE9VQ0g6ICdtZGMtZXZvbHV0aW9uLWNoaXBfX2FjdGlvbi10b3VjaCcsXHJcblxyXG4gICAgUklQUExFOiAnbWRjLWV2b2x1dGlvbi1jaGlwX19yaXBwbGUnLFxyXG4gICAgUFJJTUFSWV9SSVBQTEU6ICdtZGMtZXZvbHV0aW9uLWNoaXBfX3JpcHBsZS0tcHJpbWFyeScsXHJcbiAgICBUUkFJTElOR19SSVBQTEU6ICdtZGMtZXZvbHV0aW9uLWNoaXBfX3JpcHBsZS0tdHJhaWxpbmcnLFxyXG5cclxuICAgIEdSQVBISUM6ICdtZGMtZXZvbHV0aW9uLWNoaXBfX2dyYXBoaWMnLFxyXG4gICAgSUNPTjogJ21kYy1ldm9sdXRpb24tY2hpcF9faWNvbicsXHJcbiAgICBQUklNQVJZX0lDT046ICdtZGMtZXZvbHV0aW9uLWNoaXBfX2ljb24tLXByaW1hcnknLFxyXG4gICAgVFJBSUxJTkdfSUNPTjogJ21kYy1ldm9sdXRpb24tY2hpcF9faWNvbi0tdHJhaWxpbmcnLFxyXG4gICAgVEVYVF9MQUJFTDogJ21kYy1ldm9sdXRpb24tY2hpcF9fdGV4dC1sYWJlbCcsXHJcbiAgICBDSEVDS01BUks6ICdtZGMtZXZvbHV0aW9uLWNoaXBfX2NoZWNrbWFyaycsXHJcbiAgICBDSEVDS01BUktfU1ZHOiAnbWRjLWV2b2x1dGlvbi1jaGlwX19jaGVja21hcmstc3ZnJyxcclxuICAgIENIRUNLTUFSS19QQVRIOiAnbWRjLWV2b2x1dGlvbi1jaGlwX19jaGVja21hcmstcGF0aCdcclxufTsiLCJpbXBvcnQgY2xhc3NuYW1lcyBmcm9tICdjbGFzc25hbWVzJztcclxuXHJcbmltcG9ydCB7IENsb25lIH0gZnJvbSAnLi4vY29tcG9uZW50JztcclxuaW1wb3J0IEljb24gZnJvbSAnLi4vaWNvbic7XHJcblxyXG5pbXBvcnQgeyBjaGlwQ3NzQ2xhc3NlcyBhcyBjc3NDbGFzc2VzIH0gZnJvbSAnLi9jb25zdGFudHMnO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gQ2hpcFByaW1hcnlBY3Rpb24oe1xyXG4gICAgdGV4dCxcclxuICAgIGdyYXBoaWMsXHJcbiAgICBpY29uLFxyXG4gICAgcHJlc2VudGF0aW9uYWwgPSBmYWxzZSxcclxuICAgIHNlbGVjdGFibGUgPSBmYWxzZSxcclxuICAgIHNlbGVjdGVkID0gZmFsc2UsXHJcbiAgICBkaXNhYmxlZCA9IGZhbHNlLFxyXG5cclxuICAgIGVsZW1lbnQgPSAnYnV0dG9uJyxcclxuICAgIGNvbXBvbmVudDogRWxlbWVudCA9IGVsZW1lbnQsXHJcbiAgICBjaGlsZHJlbiA9IHRleHQsXHJcbiAgICAuLi5wcm9wc1xyXG59KSB7XHJcbiAgICBjb25zdCBpc0J1dHRvbiA9IEVsZW1lbnQgPT09ICdidXR0b24nO1xyXG4gICAgY29uc3QgY2xhc3NOYW1lcyA9IGNsYXNzbmFtZXMoY3NzQ2xhc3Nlcy5BQ1RJT04sIGNzc0NsYXNzZXMuUFJJTUFSWV9BQ1RJT04sIHtcclxuICAgICAgICBbY3NzQ2xhc3Nlcy5QUkVTRU5UQVRJT05BTF9BQ1RJT05dOiBwcmVzZW50YXRpb25hbFxyXG4gICAgfSk7XHJcblxyXG4gICAgcmV0dXJuIChcclxuICAgICAgICA8RWxlbWVudFxyXG4gICAgICAgICAgICBjbGFzc05hbWU9e2NsYXNzTmFtZXN9XHJcbiAgICAgICAgICAgIHR5cGU9e2lzQnV0dG9uID8gJ2J1dHRvbicgOiB1bmRlZmluZWR9XHJcbiAgICAgICAgICAgIGRpc2FibGVkPXtpc0J1dHRvbiAmJiBkaXNhYmxlZH1cclxuICAgICAgICAgICAgdGFiSW5kZXg9e2Rpc2FibGVkID8gJy0xJyA6ICcwJ31cclxuICAgICAgICAgICAgcm9sZT17IWlzQnV0dG9uID8gJ29wdGlvbicgOiB1bmRlZmluZWR9XHJcbiAgICAgICAgICAgIGFyaWEtc2VsZWN0ZWQ9eyFpc0J1dHRvbiA/IHNlbGVjdGVkIDogdW5kZWZpbmVkfVxyXG4gICAgICAgICAgICBhcmlhLWRpc2FibGVkPXshaXNCdXR0b24gPyBkaXNhYmxlZCA6IHVuZGVmaW5lZH1cclxuICAgICAgICAgICAgey4uLnByb3BzfVxyXG4gICAgICAgID5cclxuICAgICAgICAgICAgPHNwYW4gY2xhc3NOYW1lPXtgJHtjc3NDbGFzc2VzLlJJUFBMRX0gJHtjc3NDbGFzc2VzLlBSSU1BUllfUklQUExFfWB9IC8+XHJcblxyXG4gICAgICAgICAgICB7KGdyYXBoaWMgfHwgaWNvbiB8fCBzZWxlY3RhYmxlKSAmJlxyXG4gICAgICAgICAgICAgICAgPHNwYW4gY2xhc3NOYW1lPXtjc3NDbGFzc2VzLkdSQVBISUN9PlxyXG4gICAgICAgICAgICAgICAgICAgIHtncmFwaGljfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICB7aWNvbiAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8Q2xvbmVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudD17aWNvbn1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZhbGxiYWNrPXtJY29ufVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPXtgJHtjc3NDbGFzc2VzLklDT059ICR7Y3NzQ2xhc3Nlcy5QUklNQVJZX0lDT059YH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgLz5cclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHtzZWxlY3RhYmxlICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT17Y3NzQ2xhc3Nlcy5DSEVDS01BUkt9PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPHN2ZyBjbGFzc05hbWU9e2Nzc0NsYXNzZXMuQ0hFQ0tNQVJLX1NWR30gdmlld0JveD1cIi0yIC0zIDMwIDMwXCI+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHBhdGhcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPXtjc3NDbGFzc2VzLkNIRUNLTUFSS19QQVRIfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWxsPVwibm9uZVwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0cm9rZT1cImJsYWNrXCIgZD1cIk0xLjczLDEyLjkxIDguMSwxOS4yOCAyMi43OSw0LjU5XCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9zdmc+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDwvc3Bhbj5cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICA8L3NwYW4+XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT17Y3NzQ2xhc3Nlcy5URVhUX0xBQkVMfT57Y2hpbGRyZW59PC9zcGFuPlxyXG4gICAgICAgIDwvRWxlbWVudD5cclxuICAgICk7XHJcbn0iLCJpbXBvcnQgY2xhc3NuYW1lcyBmcm9tICdjbGFzc25hbWVzJztcclxuXHJcbmltcG9ydCB7IENsb25lIH0gZnJvbSAnLi4vY29tcG9uZW50JztcclxuaW1wb3J0IEljb24gZnJvbSAnLi4vaWNvbic7XHJcblxyXG5pbXBvcnQgeyBjaGlwQ3NzQ2xhc3NlcyBhcyBjc3NDbGFzc2VzIH0gZnJvbSAnLi9jb25zdGFudHMnO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gQ2hpcFRyYWlsaW5nQWN0aW9uKHtcclxuICAgIGljb24sXHJcbiAgICBwcmVzZW50YXRpb25hbCA9IGZhbHNlLFxyXG4gICAgLi4ucHJvcHNcclxufSkge1xyXG4gICAgY29uc3QgY2xhc3NOYW1lcyA9IGNsYXNzbmFtZXMoY3NzQ2xhc3Nlcy5BQ1RJT04sIGNzc0NsYXNzZXMuVFJBSUxJTkdfQUNUSU9OLCB7XHJcbiAgICAgICAgW2Nzc0NsYXNzZXMuUFJFU0VOVEFUSU9OQUxfQUNUSU9OXTogcHJlc2VudGF0aW9uYWxcclxuICAgIH0pO1xyXG5cclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgPGJ1dHRvblxyXG4gICAgICAgICAgICBjbGFzc05hbWU9e2NsYXNzTmFtZXN9XHJcbiAgICAgICAgICAgIHR5cGU9XCJidXR0b25cIlxyXG4gICAgICAgICAgICB0YWJJbmRleD1cIi0xXCJcclxuICAgICAgICAgICAgYXJpYS1oaWRkZW49XCJ0cnVlXCJcclxuICAgICAgICAgICAgey4uLnByb3BzfVxyXG4gICAgICAgID5cclxuICAgICAgICAgICAgPHNwYW4gY2xhc3NOYW1lPXtgJHtjc3NDbGFzc2VzLlJJUFBMRX0gJHtjc3NDbGFzc2VzLlRSQUlMSU5HX1JJUFBMRX1gfSAvPlxyXG5cclxuICAgICAgICAgICAgPENsb25lXHJcbiAgICAgICAgICAgICAgICBjb21wb25lbnQ9e2ljb259XHJcbiAgICAgICAgICAgICAgICBmYWxsYmFjaz17SWNvbn1cclxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZT17YCR7Y3NzQ2xhc3Nlcy5JQ09OfSAke2Nzc0NsYXNzZXMuVFJBSUxJTkdfSUNPTn1gfVxyXG4gICAgICAgICAgICAvPlxyXG4gICAgICAgIDwvYnV0dG9uPlxyXG4gICAgKTtcclxufSIsImltcG9ydCB7IGZvcndhcmRSZWYgfSBmcm9tICdyZWFjdCc7XHJcbmltcG9ydCB7IENTU1RyYW5zaXRpb24gfSBmcm9tICdyZWFjdC10cmFuc2l0aW9uLWdyb3VwJztcclxuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcclxuaW1wb3J0IGNsYXNzbmFtZXMgZnJvbSAnY2xhc3NuYW1lcyc7XHJcblxyXG5pbXBvcnQgeyBudW1iZXJzLCBjaGlwQ3NzQ2xhc3NlcyBhcyBjc3NDbGFzc2VzIH0gZnJvbSAnLi9jb25zdGFudHMnO1xyXG5pbXBvcnQgQ2hpcFByaW1hcnlBY3Rpb24gZnJvbSAnLi9DaGlwUHJpbWFyeUFjdGlvbic7XHJcbmltcG9ydCBDaGlwVHJhaWxpbmdBY3Rpb24gZnJvbSAnLi9DaGlwVHJhaWxpbmdBY3Rpb24nO1xyXG5cclxuY29uc3QgQ2hpcCA9IGZvcndhcmRSZWYoKHtcclxuICAgIHZhbHVlLFxyXG4gICAgdGV4dCxcclxuICAgIGljb24sXHJcbiAgICBhdmF0YXIsXHJcbiAgICBncmFwaGljID0gYXZhdGFyLFxyXG4gICAgcHJpbWFyeUljb24gPSBpY29uLFxyXG4gICAgdHJhaWxpbmdJY29uLFxyXG4gICAgc2VsZWN0YWJsZSA9IGZhbHNlLFxyXG4gICAgZmlsdGVyID0gZmFsc2UsXHJcbiAgICBzZWxlY3RlZCA9IGZhbHNlLFxyXG4gICAgb3V0bGluZWQgPSBmYWxzZSxcclxuICAgIGRpc2FibGVkID0gZmFsc2UsXHJcbiAgICB0b3VjaCA9IGZhbHNlLFxyXG4gICAgd2l0aEF2YXRhciA9IEJvb2xlYW4oYXZhdGFyKSxcclxuXHJcbiAgICBlbGVtZW50ID0gJ3NwYW4nLFxyXG4gICAgY29tcG9uZW50OiBFbGVtZW50ID0gZWxlbWVudCxcclxuICAgIGNsYXNzTmFtZSxcclxuICAgIC4uLnByb3BzXHJcbn0sIHJlZikgPT4ge1xyXG4gICAgY29uc3Qgd2l0aFByaW1hcnlHcmFwaGljID0gc2VsZWN0YWJsZSB8fCBCb29sZWFuKGdyYXBoaWMpIHx8IEJvb2xlYW4ocHJpbWFyeUljb24pO1xyXG4gICAgY29uc3Qgd2l0aFByaW1hcnlJY29uID0gQm9vbGVhbihwcmltYXJ5SWNvbik7XHJcbiAgICBjb25zdCB3aXRoVHJhaWxpbmdBY3Rpb24gPSBCb29sZWFuKHRyYWlsaW5nSWNvbik7XHJcblxyXG4gICAgY29uc3QgY2xhc3NOYW1lcyA9IGNsYXNzbmFtZXMoY3NzQ2xhc3Nlcy5ST09ULCB7XHJcbiAgICAgICAgW2Nzc0NsYXNzZXMuU0VMRUNUQUJMRV06IHNlbGVjdGFibGUsXHJcbiAgICAgICAgW2Nzc0NsYXNzZXMuRklMVEVSXTogZmlsdGVyLFxyXG4gICAgICAgIFtjc3NDbGFzc2VzLk9VVExJTkVEXTogb3V0bGluZWQsXHJcbiAgICAgICAgW2Nzc0NsYXNzZXMuRElTQUJMRURdOiBkaXNhYmxlZCxcclxuICAgICAgICBbY3NzQ2xhc3Nlcy5UT1VDSF06IHRvdWNoLFxyXG4gICAgICAgIFtjc3NDbGFzc2VzLldJVEhfUFJJTUFSWV9HUkFQSElDXTogd2l0aFByaW1hcnlHcmFwaGljLFxyXG4gICAgICAgIFtjc3NDbGFzc2VzLldJVEhfUFJJTUFSWV9JQ09OXTogd2l0aFByaW1hcnlJY29uLFxyXG4gICAgICAgIFtjc3NDbGFzc2VzLldJVEhfVFJBSUxJTkdfQUNUSU9OXTogd2l0aFRyYWlsaW5nQWN0aW9uLFxyXG4gICAgICAgIFtjc3NDbGFzc2VzLldJVEhfQVZBVEFSXTogd2l0aEF2YXRhclxyXG4gICAgfSwgY2xhc3NOYW1lKTtcclxuXHJcbiAgICBjb25zdCBzZWxlY3RpbmdDbGFzcyA9IHdpdGhQcmltYXJ5SWNvbiA/IGNzc0NsYXNzZXMuU0VMRUNUSU5HX1dJVEhfUFJJTUFSWV9JQ09OIDogY3NzQ2xhc3Nlcy5TRUxFQ1RJTkc7XHJcbiAgICBjb25zdCBkZXNlbGVjdGluZ0NsYXNzID0gd2l0aFByaW1hcnlJY29uID8gY3NzQ2xhc3Nlcy5ERVNFTEVDVElOR19XSVRIX1BSSU1BUllfSUNPTiA6IGNzc0NsYXNzZXMuREVTRUxFQ1RJTkc7XHJcblxyXG4gICAgcmV0dXJuIChcclxuICAgICAgICA8Q1NTVHJhbnNpdGlvblxyXG4gICAgICAgICAgICBpbj17c2VsZWN0ZWR9XHJcbiAgICAgICAgICAgIGFwcGVhclxyXG4gICAgICAgICAgICB0aW1lb3V0PXt7XHJcbiAgICAgICAgICAgICAgICBlbnRlcjogbnVtYmVycy5TRUxFQ1RJTkdfQU5JTUFUSU9OX01TLFxyXG4gICAgICAgICAgICAgICAgZXhpdDogbnVtYmVycy5ERVNFTEVDVElOR19BTklNQVRJT05fTVNcclxuICAgICAgICAgICAgfX1cclxuICAgICAgICAgICAgY2xhc3NOYW1lcz17e1xyXG4gICAgICAgICAgICAgICAgZW50ZXI6IHNlbGVjdGluZ0NsYXNzLFxyXG4gICAgICAgICAgICAgICAgZW50ZXJBY3RpdmU6IGAke2Nzc0NsYXNzZXMuU0VMRUNURUR9ICR7c2VsZWN0aW5nQ2xhc3N9YCxcclxuICAgICAgICAgICAgICAgIGVudGVyRG9uZTogY3NzQ2xhc3Nlcy5TRUxFQ1RFRCxcclxuICAgICAgICAgICAgICAgIGV4aXQ6IGRlc2VsZWN0aW5nQ2xhc3MsXHJcbiAgICAgICAgICAgICAgICBleGl0QWN0aXZlOiBkZXNlbGVjdGluZ0NsYXNzXHJcbiAgICAgICAgICAgIH19XHJcbiAgICAgICAgPlxyXG4gICAgICAgICAgICA8RWxlbWVudFxyXG4gICAgICAgICAgICAgICAgcmVmPXtyZWZ9XHJcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU9e2NsYXNzTmFtZXN9XHJcbiAgICAgICAgICAgICAgICBkYXRhLXZhbHVlPXt2YWx1ZX1cclxuICAgICAgICAgICAgICAgIHJvbGU9e3NlbGVjdGFibGUgPyAncHJlc2VudGF0aW9uJyA6ICdyb3cnfVxyXG4gICAgICAgICAgICAgICAgey4uLnByb3BzfVxyXG4gICAgICAgICAgICA+XHJcbiAgICAgICAgICAgICAgICB7c2VsZWN0YWJsZSA/XHJcbiAgICAgICAgICAgICAgICAgICAgPENoaXBQcmltYXJ5QWN0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnQ9XCJzcGFuXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dD17dGV4dH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZ3JhcGhpYz17Z3JhcGhpY31cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWNvbj17cHJpbWFyeUljb259XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdGFibGU9e3NlbGVjdGFibGV9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdGVkPXtzZWxlY3RlZH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZGlzYWJsZWQ9e2Rpc2FibGVkfVxyXG4gICAgICAgICAgICAgICAgICAgIC8+XHJcbiAgICAgICAgICAgICAgICAgICAgOlxyXG4gICAgICAgICAgICAgICAgICAgIDw+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT17YCR7Y3NzQ2xhc3Nlcy5DRUxMfSAke2Nzc0NsYXNzZXMuUFJJTUFSWV9DRUxMfWB9IHJvbGU9XCJncmlkY2VsbFwiPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPENoaXBQcmltYXJ5QWN0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dD17dGV4dH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBncmFwaGljPXtncmFwaGljfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGljb249e3ByaW1hcnlJY29ufVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpc2FibGVkPXtkaXNhYmxlZH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDwvc3Bhbj5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHt0cmFpbGluZ0ljb24gJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT17YCR7Y3NzQ2xhc3Nlcy5DRUxMfSAke2Nzc0NsYXNzZXMuVFJBSUxJTkdfQ0VMTH1gfSByb2xlPVwiZ3JpZGNlbGxcIj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8Q2hpcFRyYWlsaW5nQWN0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGljb249e3RyYWlsaW5nSWNvbn1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlzYWJsZWQ9e2Rpc2FibGVkfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L3NwYW4+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICA8Lz5cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgPC9FbGVtZW50PlxyXG4gICAgICAgIDwvQ1NTVHJhbnNpdGlvbj5cclxuICAgICk7XHJcbn0pO1xyXG5cclxuQ2hpcC5kaXNwbGF5TmFtZSA9ICdNRENDaGlwJztcclxuXHJcbkNoaXAucHJvcFR5cGVzID0ge1xyXG4gICAgdmFsdWU6IFByb3BUeXBlcy5hbnksXHJcbiAgICB0ZXh0OiBQcm9wVHlwZXMubm9kZSxcclxuICAgIGxlYWRpbmdJY29uOiBQcm9wVHlwZXMubm9kZSxcclxuICAgIHRyYWlsaW5nSWNvbjogUHJvcFR5cGVzLm5vZGUsXHJcbiAgICBzZWxlY3RlZDogUHJvcFR5cGVzLmJvb2wsXHJcbiAgICBvdXRsaW5lZDogUHJvcFR5cGVzLmJvb2wsXHJcbiAgICBvbkNsaWNrOiBQcm9wVHlwZXMuZnVuY1xyXG59O1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgQ2hpcDsiLCJleHBvcnQgZnVuY3Rpb24gaXNVbmRlZmluZWQodmFsdWUpIHtcclxuICAgIHJldHVybiB2YWx1ZSA9PT0gdW5kZWZpbmVkO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gaXNOdWxsKHZhbHVlKSB7XHJcbiAgICByZXR1cm4gdmFsdWUgPT09IG51bGw7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBpc0Jvb2xlYW4odmFsdWUpIHtcclxuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJztcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGlzTnVtYmVyKHZhbHVlKSB7XHJcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJztcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGlzU3RyaW5nKHZhbHVlKSB7XHJcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJztcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGlzQXJyYXkodmFsdWUpIHtcclxuICAgIHJldHVybiBBcnJheS5pc0FycmF5KHZhbHVlKTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGlzT2JqZWN0KHZhbHVlKSB7XHJcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiAhaXNOdWxsKHZhbHVlKSAmJiAhaXNBcnJheSh2YWx1ZSk7XHJcbn0iLCJpbXBvcnQgeyBDaGlsZHJlbiwgZm9yd2FyZFJlZiwgdXNlQ2FsbGJhY2sgfSBmcm9tICdyZWFjdCc7XHJcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XHJcbmltcG9ydCBjbGFzc25hbWVzIGZyb20gJ2NsYXNzbmFtZXMnO1xyXG5cclxuaW1wb3J0IHsgaXNVbmRlZmluZWQsIGlzQXJyYXkgfSBmcm9tICcuLi90eXBlcyc7XHJcbmltcG9ydCB7IGNsb25lLCBjcmVhdGUgfSBmcm9tICcuLi9jb21wb25lbnQnO1xyXG5cclxuaW1wb3J0IHsgY2hpcFNldENzc0NsYXNzZXMgYXMgY3NzQ2xhc3NlcyB9IGZyb20gJy4vY29uc3RhbnRzJztcclxuaW1wb3J0IENoaXAgZnJvbSAnLi9DaGlwJztcclxuXHJcbmNvbnN0IENoaXBTZXQgPSBmb3J3YXJkUmVmKCh7XHJcbiAgICB2YWx1ZSxcclxuICAgIGNoaXBzLFxyXG4gICAgaW5wdXQgPSBmYWxzZSxcclxuICAgIGNob2ljZSA9ICghaW5wdXQgJiYgIWlzVW5kZWZpbmVkKHZhbHVlKSAmJiAhaXNBcnJheSh2YWx1ZSkpLFxyXG4gICAgZmlsdGVyID0gKCFpbnB1dCAmJiAhaXNVbmRlZmluZWQodmFsdWUpICYmIGlzQXJyYXkodmFsdWUpKSxcclxuICAgIG92ZXJmbG93ID0gZmFsc2UsXHJcbiAgICBvbkNoYW5nZSA9IEZ1bmN0aW9uLnByb3RvdHlwZSxcclxuXHJcbiAgICBlbGVtZW50ID0gJ2RpdicsXHJcbiAgICBjb21wb25lbnQ6IEVsZW1lbnQgPSBlbGVtZW50LFxyXG4gICAgY2xhc3NOYW1lLFxyXG4gICAgY2hpbGRyZW4gPSBjaGlwcz8ubWFwKGNoaXAgPT4gY3JlYXRlKENoaXAsIGNoaXApKSxcclxuICAgIC4uLnByb3BzXHJcbn0sIHJlZikgPT4ge1xyXG4gICAgY29uc3QgaGFuZGxlQ2xpY2sgPSB1c2VDYWxsYmFjayhldmVudCA9PiB7XHJcbiAgICAgICAgY29uc3QgY2hpcFZhbHVlID0gZXZlbnQuY3VycmVudFRhcmdldC5kYXRhc2V0LnZhbHVlO1xyXG4gICAgICAgIGNvbnN0IG5ld1ZhbHVlID0gY2hvaWNlID8gY2hpcFZhbHVlIDpcclxuICAgICAgICAgICAgKHZhbHVlLmluY2x1ZGVzKGNoaXBWYWx1ZSkgP1xyXG4gICAgICAgICAgICAgICAgdmFsdWUuZmlsdGVyKHYgPT4gdiAhPT0gY2hpcFZhbHVlKSA6XHJcbiAgICAgICAgICAgICAgICB2YWx1ZS5jb25jYXQoY2hpcFZhbHVlKVxyXG4gICAgICAgICAgICApO1xyXG5cclxuICAgICAgICBvbkNoYW5nZShuZXdWYWx1ZSk7XHJcbiAgICB9LCBbdmFsdWUsIGNob2ljZSwgb25DaGFuZ2VdKTtcclxuXHJcbiAgICBjb25zdCBjbGFzc05hbWVzID0gY2xhc3NuYW1lcyhjc3NDbGFzc2VzLlJPT1QsIHtcclxuICAgICAgICBbY3NzQ2xhc3Nlcy5PVkVSRkxPV106IG92ZXJmbG93XHJcbiAgICB9LCBjbGFzc05hbWUpO1xyXG5cclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgPEVsZW1lbnQgcmVmPXtyZWZ9IGNsYXNzTmFtZT17Y2xhc3NOYW1lc30gcm9sZT17ZmlsdGVyID8gJ2xpc3Rib3gnIDogJ2dyaWQnfSB7Li4ucHJvcHN9PlxyXG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17Y3NzQ2xhc3Nlcy5DSElQU30gcm9sZT1cInByZXNlbnRhdGlvblwiPlxyXG4gICAgICAgICAgICAgICAge2lzVW5kZWZpbmVkKHZhbHVlKSA/IGNoaWxkcmVuIDpcclxuICAgICAgICAgICAgICAgICAgICBDaGlsZHJlbi5tYXAoY2hpbGRyZW4sIGNoaXAgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjaGlwVmFsdWUgPSBjaGlwLnByb3BzLnZhbHVlO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNsb25lKGNoaXAsIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdGFibGU6IHRydWUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3RlZDogY2hvaWNlID8gdmFsdWUgPT09IGNoaXBWYWx1ZSA6IHZhbHVlLmluY2x1ZGVzKGNoaXBWYWx1ZSksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbkNsaWNrQ2FwdHVyZTogKGNob2ljZSB8fCBmaWx0ZXIpID8gaGFuZGxlQ2xpY2sgOiB1bmRlZmluZWQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgIDwvRWxlbWVudD5cclxuICAgICk7XHJcbn0pO1xyXG5cclxuQ2hpcFNldC5kaXNwbGF5TmFtZSA9ICdNRENDaGlwU2V0JztcclxuXHJcbkNoaXBTZXQucHJvcFR5cGVzID0ge1xyXG4gICAgdmFsdWU6IFByb3BUeXBlcy5hbnksXHJcbiAgICBpbnB1dDogUHJvcFR5cGVzLmJvb2wsXHJcbiAgICBjaG9pY2U6IFByb3BUeXBlcy5ib29sLFxyXG4gICAgZmlsdGVyOiBQcm9wVHlwZXMuYm9vbCxcclxuICAgIG92ZXJmbG93OiBQcm9wVHlwZXMuYm9vbCxcclxuICAgIG9uQ2hhbmdlOiBQcm9wVHlwZXMuZnVuY1xyXG59O1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgQ2hpcFNldDsiLCJleHBvcnQgeyBkZWZhdWx0IGFzIENoaXAgfSBmcm9tICcuL0NoaXAnO1xyXG5leHBvcnQgeyBkZWZhdWx0IGFzIENoaXBTZXQgfSBmcm9tICcuL0NoaXBTZXQnOyIsImV4cG9ydCBjb25zdCBzdHJpbmdzID0ge1xyXG4gICAgWE1MTlM6ICdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZycsXHJcbn07XHJcblxyXG5leHBvcnQgY29uc3Qgc2l6ZVByb3BzID0ge1xyXG4gICAgbGFyZ2U6IHtcclxuICAgICAgICB2aWV3Qm94OiA0OCxcclxuICAgICAgICByYWRpdXM6IDE4LFxyXG4gICAgICAgIHN0cm9rZVdpZHRoOiA0LFxyXG4gICAgICAgIGdhcFBhdGNoU3Ryb2tlV2lkdGg6IDMuMixcclxuICAgICAgICBzdHJva2VEYXNoYXJyYXk6IDExMy4wOTcsXHJcbiAgICAgICAgaW5kZXRlcm1pbmF0ZVN0cm9rZURhc2hvZmZzZXQ6IDU2LjU0OVxyXG4gICAgfSxcclxuICAgIG1lZGl1bToge1xyXG4gICAgICAgIHZpZXdCb3g6IDMyLFxyXG4gICAgICAgIHJhZGl1czogMTIuNSxcclxuICAgICAgICBzdHJva2VXaWR0aDogMyxcclxuICAgICAgICBnYXBQYXRjaFN0cm9rZVdpZHRoOiAyLjQsXHJcbiAgICAgICAgc3Ryb2tlRGFzaGFycmF5OiA3OC41NCxcclxuICAgICAgICBpbmRldGVybWluYXRlU3Ryb2tlRGFzaG9mZnNldDogMzkuMjdcclxuICAgIH0sXHJcbiAgICBzbWFsbDoge1xyXG4gICAgICAgIHZpZXdCb3g6IDI0LFxyXG4gICAgICAgIHJhZGl1czogOC43NSxcclxuICAgICAgICBzdHJva2VXaWR0aDogMi41LFxyXG4gICAgICAgIGdhcFBhdGNoU3Ryb2tlV2lkdGg6IDIsXHJcbiAgICAgICAgc3Ryb2tlRGFzaGFycmF5OiA1NC45NzgsXHJcbiAgICAgICAgaW5kZXRlcm1pbmF0ZVN0cm9rZURhc2hvZmZzZXQ6IDI3LjQ4OVxyXG4gICAgfVxyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IGNzc0NsYXNzZXMgPSB7XHJcbiAgICBST09UOiAnbWRjLWNpcmN1bGFyLXByb2dyZXNzJyxcclxuICAgIFNNQUxMOiAnbWRjLWNpcmN1bGFyLXByb2dyZXNzLS1zbWFsbCcsXHJcbiAgICBNRURJVU06ICdtZGMtY2lyY3VsYXItcHJvZ3Jlc3MtLW1lZGl1bScsXHJcbiAgICBMQVJHRTogJ21kYy1jaXJjdWxhci1wcm9ncmVzcy0tbGFyZ2UnLFxyXG4gICAgSU5ERVRFUk1JTkFURTogJ21kYy1jaXJjdWxhci1wcm9ncmVzcy0taW5kZXRlcm1pbmF0ZScsXHJcbiAgICBDTE9TRUQ6ICdtZGMtY2lyY3VsYXItcHJvZ3Jlc3MtLWNsb3NlZCcsXHJcblxyXG4gICAgREVURVJNSU5BVEVfQ09OVEFJTkVSOiAnbWRjLWNpcmN1bGFyLXByb2dyZXNzX19kZXRlcm1pbmF0ZS1jb250YWluZXInLFxyXG4gICAgREVURVJNSU5BVEVfQ0lSQ0xFX0dSQVBISUM6ICdtZGMtY2lyY3VsYXItcHJvZ3Jlc3NfX2RldGVybWluYXRlLWNpcmNsZS1ncmFwaGljJyxcclxuICAgIERFVEVSTUlOQVRFX1RSQUNLOiAnbWRjLWNpcmN1bGFyLXByb2dyZXNzX19kZXRlcm1pbmF0ZS10cmFjaycsXHJcbiAgICBERVRFUk1JTkFURV9DSVJDTEU6ICdtZGMtY2lyY3VsYXItcHJvZ3Jlc3NfX2RldGVybWluYXRlLWNpcmNsZScsXHJcblxyXG4gICAgSU5ERVRFUk1JTkFURV9DT05UQUlORVI6ICdtZGMtY2lyY3VsYXItcHJvZ3Jlc3NfX2luZGV0ZXJtaW5hdGUtY29udGFpbmVyJyxcclxuICAgIElOREVURVJNSU5BVEVfQ0lSQ0xFX0dSQVBISUM6ICdtZGMtY2lyY3VsYXItcHJvZ3Jlc3NfX2luZGV0ZXJtaW5hdGUtY2lyY2xlLWdyYXBoaWMnLFxyXG5cclxuICAgIFNQSU5ORVJfTEFZRVI6ICdtZGMtY2lyY3VsYXItcHJvZ3Jlc3NfX3NwaW5uZXItbGF5ZXInLFxyXG4gICAgQ09MT1I6ICdtZGMtY2lyY3VsYXItcHJvZ3Jlc3NfX2NvbG9yJyxcclxuICAgIENJUkNMRV9DTElQUEVSOiAnbWRjLWNpcmN1bGFyLXByb2dyZXNzX19jaXJjbGUtY2xpcHBlcicsXHJcbiAgICBDSVJDTEVfTEVGVDogJ21kYy1jaXJjdWxhci1wcm9ncmVzc19fY2lyY2xlLWxlZnQnLFxyXG4gICAgQ0lSQ0xFX1JJR0hUOiAnbWRjLWNpcmN1bGFyLXByb2dyZXNzX19jaXJjbGUtcmlnaHQnLFxyXG4gICAgR0FQX1BBVENIOiAnbWRjLWNpcmN1bGFyLXByb2dyZXNzX19nYXAtcGF0Y2gnXHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgU2l6ZSA9IHtcclxuICAgIExBUkdFOiAnbGFyZ2UnLFxyXG4gICAgTUVESVVNOiAnbWVkaXVtJyxcclxuICAgIFNNQUxMOiAnc21hbGwnXHJcbn07IiwiaW1wb3J0IHsgZm9yd2FyZFJlZiB9IGZyb20gJ3JlYWN0JztcclxuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcclxuaW1wb3J0IGNsYXNzbmFtZXMgZnJvbSAnY2xhc3NuYW1lcyc7XHJcblxyXG5pbXBvcnQgeyBzdHJpbmdzLCBjc3NDbGFzc2VzLCBzaXplUHJvcHMsIFNpemUgfSBmcm9tICcuL2NvbnN0YW50cyc7XHJcblxyXG5jb25zdCBDaXJjdWxhclByb2dyZXNzID0gZm9yd2FyZFJlZigoe1xyXG4gICAgdmFsdWUgPSAwLFxyXG4gICAgc2l6ZSA9IFNpemUuTUVESVVNLFxyXG4gICAgaW5kZXRlcm1pbmF0ZSA9IGZhbHNlLFxyXG4gICAgY2xvc2VkID0gZmFsc2UsXHJcbiAgICBjb2xvcmZ1bCA9IGZhbHNlLFxyXG5cclxuICAgIGNsYXNzTmFtZSxcclxuICAgIC4uLnByb3BzXHJcbn0sIHJlZikgPT4ge1xyXG4gICAgY29uc3QgY2xhc3NOYW1lcyA9IGNsYXNzbmFtZXMoY3NzQ2xhc3Nlcy5ST09ULCB7XHJcbiAgICAgICAgW2Ake2Nzc0NsYXNzZXMuUk9PVH0tLSR7c2l6ZX1gXTogc2l6ZSxcclxuICAgICAgICBbY3NzQ2xhc3Nlcy5JTkRFVEVSTUlOQVRFXTogaW5kZXRlcm1pbmF0ZSxcclxuICAgICAgICBbY3NzQ2xhc3Nlcy5DTE9TRURdOiBjbG9zZWRcclxuICAgIH0sIGNsYXNzTmFtZSk7XHJcblxyXG4gICAgY29uc3QgeyB2aWV3Qm94LCByYWRpdXMsIHN0cm9rZURhc2hhcnJheSwgc3Ryb2tlV2lkdGgsIGdhcFBhdGNoU3Ryb2tlV2lkdGgsIGluZGV0ZXJtaW5hdGVTdHJva2VEYXNob2Zmc2V0IH0gPSBzaXplUHJvcHNbc2l6ZV07XHJcbiAgICBjb25zdCBwcm9ncmVzcyA9IHZhbHVlID4gMSA/ICh2YWx1ZSAvIDEwMCkgOiBOdW1iZXIodmFsdWUpO1xyXG4gICAgY29uc3QgY3ggPSB2aWV3Qm94IC8gMiwgY3kgPSB2aWV3Qm94IC8gMjtcclxuICAgIGNvbnN0IHN0cm9rZURhc2hvZmZzZXQgPSAoMiAqIE1hdGguUEkgKiByYWRpdXMpICogKDEgLSBwcm9ncmVzcyk7XHJcblxyXG4gICAgcmV0dXJuIChcclxuICAgICAgICA8ZGl2XHJcbiAgICAgICAgICAgIHJlZj17cmVmfVxyXG4gICAgICAgICAgICBjbGFzc05hbWU9e2NsYXNzTmFtZXN9XHJcbiAgICAgICAgICAgIHJvbGU9XCJwcm9ncmVzc2JhclwiXHJcbiAgICAgICAgICAgIGFyaWEtdmFsdWVtaW49ezB9XHJcbiAgICAgICAgICAgIGFyaWEtdmFsdWVtYXg9ezF9XHJcbiAgICAgICAgICAgIGFyaWEtdmFsdWVub3c9e3Byb2dyZXNzfVxyXG4gICAgICAgICAgICB7Li4ucHJvcHN9XHJcbiAgICAgICAgPlxyXG4gICAgICAgICAgICB7IWluZGV0ZXJtaW5hdGUgJiZcclxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXtjc3NDbGFzc2VzLkRFVEVSTUlOQVRFX0NPTlRBSU5FUn0+XHJcbiAgICAgICAgICAgICAgICAgICAgPHN2ZyBjbGFzc05hbWU9e2Nzc0NsYXNzZXMuREVURVJNSU5BVEVfQ0lSQ0xFX0dSQVBISUN9IHZpZXdCb3g9e2AwIDAgJHt2aWV3Qm94fSAke3ZpZXdCb3h9YH0geG1sbnM9e3N0cmluZ3MuWE1MTlN9PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8Y2lyY2xlIGNsYXNzTmFtZT17Y3NzQ2xhc3Nlcy5ERVRFUk1JTkFURV9UUkFDS30gY3g9e2N4fSBjeT17Y3l9IHI9e3JhZGl1c30gc3Ryb2tlV2lkdGg9e3N0cm9rZVdpZHRofSAvPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8Y2lyY2xlIGNsYXNzTmFtZT17Y3NzQ2xhc3Nlcy5ERVRFUk1JTkFURV9DSVJDTEV9IGN4PXtjeH0gY3k9e2N5fSByPXtyYWRpdXN9IHN0cm9rZVdpZHRoPXtzdHJva2VXaWR0aH0gc3Ryb2tlRGFzaGFycmF5PXtzdHJva2VEYXNoYXJyYXl9IHN0cm9rZURhc2hvZmZzZXQ9e3N0cm9rZURhc2hvZmZzZXR9IC8+XHJcbiAgICAgICAgICAgICAgICAgICAgPC9zdmc+XHJcbiAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAge2luZGV0ZXJtaW5hdGUgJiZcclxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXtjc3NDbGFzc2VzLklOREVURVJNSU5BVEVfQ09OVEFJTkVSfT5cclxuICAgICAgICAgICAgICAgICAgICB7KGNvbG9yZnVsID8gWzEsIDIsIDMsIDRdIDogWzBdKS5tYXAobiA9PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGtleT17bn0gY2xhc3NOYW1lPXtjbGFzc25hbWVzKGNzc0NsYXNzZXMuU1BJTk5FUl9MQVlFUiwgeyBbYCR7Y3NzQ2xhc3Nlcy5QUk9HUkVTU19DT0xPUn0tJHtufWBdOiBuIH0pfT5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXtgJHtjc3NDbGFzc2VzLkNJUkNMRV9DTElQUEVSfSAke2Nzc0NsYXNzZXMuQ0lSQ0xFX0xFRlR9YH0+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHN2ZyBjbGFzc05hbWU9e2Nzc0NsYXNzZXMuSU5ERVRFUk1JTkFURV9DSVJDTEVfR1JBUEhJQ30gdmlld0JveD17YDAgMCAke3ZpZXdCb3h9ICR7dmlld0JveH1gfSB4bWxucz17c3RyaW5ncy5YTUxOU30+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxjaXJjbGUgY3g9e2N4fSBjeT17Y3l9IHI9e3JhZGl1c30gc3Ryb2tlV2lkdGg9e3N0cm9rZVdpZHRofSBzdHJva2VEYXNoYXJyYXk9e3N0cm9rZURhc2hhcnJheX0gc3Ryb2tlRGFzaG9mZnNldD17aW5kZXRlcm1pbmF0ZVN0cm9rZURhc2hvZmZzZXR9IC8+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9zdmc+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj48ZGl2IGNsYXNzTmFtZT17Y3NzQ2xhc3Nlcy5HQVBfUEFUQ0h9PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzdmcgY2xhc3NOYW1lPXtjc3NDbGFzc2VzLklOREVURVJNSU5BVEVfQ0lSQ0xFX0dSQVBISUN9IHZpZXdCb3g9e2AwIDAgJHt2aWV3Qm94fSAke3ZpZXdCb3h9YH0geG1sbnM9e3N0cmluZ3MuWE1MTlN9PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8Y2lyY2xlIGN4PXtjeH0gY3k9e2N5fSByPXtyYWRpdXN9IHN0cm9rZVdpZHRoPXtnYXBQYXRjaFN0cm9rZVdpZHRofSBzdHJva2VEYXNoYXJyYXk9e3N0cm9rZURhc2hhcnJheX0gc3Ryb2tlRGFzaG9mZnNldD17aW5kZXRlcm1pbmF0ZVN0cm9rZURhc2hvZmZzZXR9IC8+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9zdmc+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj48ZGl2IGNsYXNzTmFtZT17YCR7Y3NzQ2xhc3Nlcy5DSVJDTEVfQ0xJUFBFUn0gJHtjc3NDbGFzc2VzLkNJUkNMRV9SSUdIVH1gfT5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3ZnIGNsYXNzTmFtZT17Y3NzQ2xhc3Nlcy5JTkRFVEVSTUlOQVRFX0NJUkNMRV9HUkFQSElDfSB2aWV3Qm94PXtgMCAwICR7dmlld0JveH0gJHt2aWV3Qm94fWB9IHhtbG5zPXtzdHJpbmdzLlhNTE5TfT5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGNpcmNsZSBjeD17Y3h9IGN5PXtjeX0gcj17cmFkaXVzfSBzdHJva2VXaWR0aD17c3Ryb2tlV2lkdGh9IHN0cm9rZURhc2hhcnJheT17c3Ryb2tlRGFzaGFycmF5fSBzdHJva2VEYXNob2Zmc2V0PXtpbmRldGVybWluYXRlU3Ryb2tlRGFzaG9mZnNldH0gLz5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L3N2Zz5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgICAgICAgICApfVxyXG4gICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICA8L2Rpdj5cclxuICAgICk7XHJcbn0pO1xyXG5cclxuQ2lyY3VsYXJQcm9ncmVzcy5kaXNwbGF5TmFtZSA9ICdNRENDaXJjdWxhclByb2dyZXNzJztcclxuXHJcbkNpcmN1bGFyUHJvZ3Jlc3MucHJvcFR5cGVzID0ge1xyXG4gICAgdmFsdWU6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5udW1iZXIsIFByb3BUeXBlcy5zdHJpbmddKSxcclxuICAgIHNpemU6IFByb3BUeXBlcy5vbmVPZihbc3RyaW5ncy5TTUFMTCwgc3RyaW5ncy5NRURJVU0sIHN0cmluZ3MuTEFSR0VdKSxcclxuICAgIGluZGV0ZXJtaW5hdGU6IFByb3BUeXBlcy5ib29sLFxyXG4gICAgY2xvc2VkOiBQcm9wVHlwZXMuYm9vbCxcclxuICAgIGNvbG9yZnVsOiBQcm9wVHlwZXMuYm9vbFxyXG59O1xyXG5cclxuQ2lyY3VsYXJQcm9ncmVzcy5TaXplID0gU2l6ZTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IENpcmN1bGFyUHJvZ3Jlc3M7IiwiZXhwb3J0IHsgZGVmYXVsdCB9IGZyb20gJy4vQ2lyY3VsYXJQcm9ncmVzcyc7IiwiZXhwb3J0IGNvbnN0IGNzc0NsYXNzZXMgPSB7XHJcbiAgICBST09UOiAnbWRjLWljb24tYnV0dG9uJyxcclxuICAgIFRPVUNIOiAnbWRjLWljb24tYnV0dG9uLS10b3VjaCcsXHJcbiAgICBNQVRFUklBTF9JQ09OUzogJ21hdGVyaWFsLWljb25zJyxcclxuXHJcbiAgICBJQ09OOiAnbWRjLWljb24tYnV0dG9uX19pY29uJyxcclxuICAgIFJJUFBMRTogJ21kYy1pY29uLWJ1dHRvbl9fcmlwcGxlJyxcclxuICAgIFRPVUNIX0VMRU1FTlQ6ICdtZGMtaWNvbi1idXR0b25fX3RvdWNoJ1xyXG59OyIsImltcG9ydCB7IGZvcndhcmRSZWYgfSBmcm9tICdyZWFjdCc7XHJcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XHJcbmltcG9ydCBjbGFzc25hbWVzIGZyb20gJ2NsYXNzbmFtZXMnO1xyXG5cclxuaW1wb3J0IHsgQ2xvbmUgfSBmcm9tICcuLi9jb21wb25lbnQnO1xyXG5cclxuaW1wb3J0IHsgY3NzQ2xhc3NlcyB9IGZyb20gJy4vY29uc3RhbnRzJztcclxuXHJcbmNvbnN0IEljb25CdXR0b24gPSBmb3J3YXJkUmVmKCh7XHJcbiAgICBpY29uLFxyXG4gICAgdG91Y2ggPSBmYWxzZSxcclxuXHJcbiAgICBlbGVtZW50ID0gJ2J1dHRvbicsXHJcbiAgICBjb21wb25lbnQ6IEVsZW1lbnQgPSBlbGVtZW50LFxyXG4gICAgY2xhc3NOYW1lLFxyXG4gICAgY2hpbGRyZW4gPSBpY29uLFxyXG4gICAgLi4ucHJvcHNcclxufSwgcmVmKSA9PiB7XHJcbiAgICBjb25zdCBjbGFzc05hbWVzID0gY2xhc3NuYW1lcyhjc3NDbGFzc2VzLlJPT1QsIHtcclxuICAgICAgICBbY3NzQ2xhc3Nlcy5NQVRFUklBTF9JQ09OU106IHR5cGVvZiBjaGlsZHJlbiA9PT0gJ3N0cmluZycsXHJcbiAgICAgICAgW2Nzc0NsYXNzZXMuVE9VQ0hdOiB0b3VjaFxyXG4gICAgfSwgY2xhc3NOYW1lKTtcclxuXHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAgIDxFbGVtZW50IHJlZj17cmVmfSBjbGFzc05hbWU9e2NsYXNzTmFtZXN9IHsuLi5wcm9wc30+XHJcbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXtjc3NDbGFzc2VzLlJJUFBMRX0gLz5cclxuXHJcbiAgICAgICAgICAgIDxDbG9uZVxyXG4gICAgICAgICAgICAgICAgY29tcG9uZW50PXtjaGlsZHJlbn1cclxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZT17Y3NzQ2xhc3Nlcy5JQ09OfVxyXG4gICAgICAgICAgICAvPlxyXG5cclxuICAgICAgICAgICAge3RvdWNoICYmXHJcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17Y3NzQ2xhc3Nlcy5UT1VDSF9FTEVNRU5UfSAvPlxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgPC9FbGVtZW50PlxyXG4gICAgKTtcclxufSk7XHJcblxyXG5JY29uQnV0dG9uLmRpc3BsYXlOYW1lID0gJ01EQ0ljb25CdXR0b24nO1xyXG5cclxuSWNvbkJ1dHRvbi5wcm9wVHlwZXMgPSB7XHJcbiAgICBpY29uOiBQcm9wVHlwZXMubm9kZVxyXG59O1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgSWNvbkJ1dHRvbjsiLCJleHBvcnQgeyBkZWZhdWx0IH0gZnJvbSAnLi9JY29uQnV0dG9uJzsiLCJleHBvcnQgY29uc3QgY3NzQ2xhc3NlcyA9IHtcclxuICAgIFJPT1Q6ICdtZGMtbGluZWFyLXByb2dyZXNzJyxcclxuICAgIElOREVURVJNSU5BVEU6ICdtZGMtbGluZWFyLXByb2dyZXNzLS1pbmRldGVybWluYXRlJyxcclxuICAgIEFOSU1BVElPTl9SRUFEWTogJ21kYy1saW5lYXItcHJvZ3Jlc3MtLWFuaW1hdGlvbi1yZWFkeScsXHJcbiAgICBDTE9TRUQ6ICdtZGMtbGluZWFyLXByb2dyZXNzLS1jbG9zZWQnLFxyXG4gICAgQ0xPU0VEX0FOSU1BVElPTl9PRkY6ICdtZGMtbGluZWFyLXByb2dyZXNzLS1jbG9zZWQtYW5pbWF0aW9uLW9mZicsXHJcblxyXG4gICAgQlVGRkVSOiAnbWRjLWxpbmVhci1wcm9ncmVzc19fYnVmZmVyJyxcclxuICAgIEJVRkZFUl9CQVI6ICdtZGMtbGluZWFyLXByb2dyZXNzX19idWZmZXItYmFyJyxcclxuICAgIEJVRkZFUl9ET1RTOiAnbWRjLWxpbmVhci1wcm9ncmVzc19fYnVmZmVyLWRvdHMnLFxyXG5cclxuICAgIEJBUjogJ21kYy1saW5lYXItcHJvZ3Jlc3NfX2JhcicsXHJcbiAgICBQUklNQVJZX0JBUjogJ21kYy1saW5lYXItcHJvZ3Jlc3NfX3ByaW1hcnktYmFyJyxcclxuICAgIFNFQ09OREFSWV9CQVI6ICdtZGMtbGluZWFyLXByb2dyZXNzX19zZWNvbmRhcnktYmFyJyxcclxuICAgIEJBUl9JTk5FUjogJ21kYy1saW5lYXItcHJvZ3Jlc3NfX2Jhci1pbm5lcidcclxufTsiLCJpbXBvcnQgeyBmb3J3YXJkUmVmIH0gZnJvbSAncmVhY3QnO1xyXG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xyXG5pbXBvcnQgY2xhc3NuYW1lcyBmcm9tICdjbGFzc25hbWVzJztcclxuXHJcbmltcG9ydCB7IGNzc0NsYXNzZXMgfSBmcm9tICcuL2NvbnN0YW50cyc7XHJcblxyXG5jb25zdCBMaW5lYXJQcm9ncmVzcyA9IGZvcndhcmRSZWYoKHtcclxuICAgIHZhbHVlID0gMCxcclxuICAgIGJ1ZmZlciA9IDAsXHJcbiAgICBpbmRldGVybWluYXRlID0gZmFsc2UsXHJcbiAgICBjbG9zZWQgPSBmYWxzZSxcclxuXHJcbiAgICBjbGFzc05hbWUsXHJcbiAgICAuLi5wcm9wc1xyXG59LCByZWYpID0+IHtcclxuICAgIGNvbnN0IGNsYXNzTmFtZXMgPSBjbGFzc25hbWVzKGNzc0NsYXNzZXMuUk9PVCwge1xyXG4gICAgICAgIFtjc3NDbGFzc2VzLklOREVURVJNSU5BVEVdOiBpbmRldGVybWluYXRlLFxyXG4gICAgICAgIFtjc3NDbGFzc2VzLkFOSU1BVElPTl9SRUFEWV06IGluZGV0ZXJtaW5hdGUsXHJcbiAgICAgICAgW2Nzc0NsYXNzZXMuQ0xPU0VEXTogY2xvc2VkXHJcbiAgICB9LCBjbGFzc05hbWUpO1xyXG5cclxuICAgIGNvbnN0IHByaW1hcnlCYXJTdHlsZSA9IHtcclxuICAgICAgICB0cmFuc2Zvcm06IGBzY2FsZVgoJHtpbmRldGVybWluYXRlID8gMSA6ICh2YWx1ZSA+IDEgPyAodmFsdWUgKiAwLjAxKSA6IHZhbHVlKX0pYFxyXG4gICAgfTtcclxuXHJcbiAgICBjb25zdCBidWZmZXJTdHlsZSA9IHtcclxuICAgICAgICBmbGV4QmFzaXM6IGJ1ZmZlciA/IGAke2luZGV0ZXJtaW5hdGUgPyAxIDogKGJ1ZmZlciA8IDEgPyAoYnVmZmVyICogMTAwKSA6IGJ1ZmZlcil9JWAgOiB1bmRlZmluZWRcclxuICAgIH07XHJcblxyXG4gICAgcmV0dXJuIChcclxuICAgICAgICA8ZGl2XHJcbiAgICAgICAgICAgIHJlZj17cmVmfVxyXG4gICAgICAgICAgICBjbGFzc05hbWU9e2NsYXNzTmFtZXN9XHJcbiAgICAgICAgICAgIHJvbGU9XCJwcm9ncmVzc2JhclwiXHJcbiAgICAgICAgICAgIGFyaWEtdmFsdWVtaW49XCIwXCJcclxuICAgICAgICAgICAgYXJpYS12YWx1ZW1heD1cIjFcIlxyXG4gICAgICAgICAgICBhcmlhLXZhbHVlbm93PXt2YWx1ZSA+IDEgPyAodmFsdWUgKiAwLjAxKSA6IHZhbHVlfVxyXG4gICAgICAgICAgICB7Li4ucHJvcHN9XHJcbiAgICAgICAgPlxyXG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17Y3NzQ2xhc3Nlcy5CVUZGRVJ9PlxyXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9e2Nzc0NsYXNzZXMuQlVGRkVSX0JBUn0gc3R5bGU9e2J1ZmZlclN0eWxlfSAvPlxyXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9e2Nzc0NsYXNzZXMuQlVGRkVSX0RPVFN9IC8+XHJcbiAgICAgICAgICAgIDwvZGl2PlxyXG5cclxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9e2Ake2Nzc0NsYXNzZXMuQkFSfSAke2Nzc0NsYXNzZXMuUFJJTUFSWV9CQVJ9YH0gc3R5bGU9e3ByaW1hcnlCYXJTdHlsZX0+XHJcbiAgICAgICAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9e2Nzc0NsYXNzZXMuQkFSX0lOTkVSfSAvPlxyXG4gICAgICAgICAgICA8L2Rpdj5cclxuXHJcbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXtgJHtjc3NDbGFzc2VzLkJBUn0gJHtjc3NDbGFzc2VzLlNFQ09OREFSWV9CQVJ9YH0+XHJcbiAgICAgICAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9e2Nzc0NsYXNzZXMuQkFSX0lOTkVSfSAvPlxyXG4gICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICA8L2Rpdj5cclxuICAgICk7XHJcbn0pO1xyXG5cclxuTGluZWFyUHJvZ3Jlc3MuZGlzcGxheU5hbWUgPSAnTURDTGluZWFyUHJvZ3Jlc3MnO1xyXG5cclxuTGluZWFyUHJvZ3Jlc3MucHJvcFR5cGVzID0ge1xyXG4gICAgdmFsdWU6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5udW1iZXIsIFByb3BUeXBlcy5zdHJpbmddKSxcclxuICAgIGJ1ZmZlcjogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLm51bWJlciwgUHJvcFR5cGVzLnN0cmluZ10pLFxyXG4gICAgaW5kZXRlcm1pbmF0ZTogUHJvcFR5cGVzLmJvb2wsXHJcbiAgICBjbG9zZWQ6IFByb3BUeXBlcy5ib29sXHJcbn07XHJcblxyXG5leHBvcnQgZGVmYXVsdCBMaW5lYXJQcm9ncmVzczsiLCJleHBvcnQgeyBkZWZhdWx0IH0gZnJvbSAnLi9MaW5lYXJQcm9ncmVzcyc7IiwiZXhwb3J0IGNvbnN0IGNzc0NsYXNzZXMgPSB7XHJcbiAgICBST09UOiAnbWRjLWRhdGEtdGFibGUnLFxyXG4gICAgU1RJQ0tZX0hFQURFUjogJ21kYy1kYXRhLXRhYmxlLS1zdGlja3ktaGVhZGVyJyxcclxuICAgIElOX1BST0dSRVNTOiAnbWRjLWRhdGEtdGFibGUtLWluLXByb2dyZXNzJyxcclxuXHJcbiAgICBUQUJMRV9DT05UQUlORVI6ICdtZGMtZGF0YS10YWJsZV9fdGFibGUtY29udGFpbmVyJyxcclxuICAgIFRBQkxFOiAnbWRjLWRhdGEtdGFibGVfX3RhYmxlJyxcclxuXHJcbiAgICBIRUFERVI6ICdtZGMtZGF0YS10YWJsZV9faGVhZGVyJyxcclxuICAgIEhFQURFUl9ST1c6ICdtZGMtZGF0YS10YWJsZV9faGVhZGVyLXJvdycsXHJcbiAgICBIRUFERVJfUk9XX0NIRUNLQk9YOiAnbWRjLWRhdGEtdGFibGVfX2hlYWRlci1yb3ctY2hlY2tib3gnLFxyXG4gICAgSEVBREVSX0NFTEw6ICdtZGMtZGF0YS10YWJsZV9faGVhZGVyLWNlbGwnLFxyXG4gICAgSEVBREVSX0NFTExfQ0hFQ0tCT1g6ICdtZGMtZGF0YS10YWJsZV9faGVhZGVyLWNlbGwtLWNoZWNrYm94JyxcclxuICAgIEhFQURFUl9DRUxMX05VTUVSSUM6ICdtZGMtZGF0YS10YWJsZV9faGVhZGVyLWNlbGwtLW51bWVyaWMnLFxyXG4gICAgSEVBREVSX0NFTExfV0lUSF9TT1JUOiAnbWRjLWRhdGEtdGFibGVfX2hlYWRlci1jZWxsLS13aXRoLXNvcnQnLFxyXG4gICAgSEVBREVSX0NFTExfU09SVEVEOiAnbWRjLWRhdGEtdGFibGVfX2hlYWRlci1jZWxsLS1zb3J0ZWQnLFxyXG4gICAgSEVBREVSX0NFTExfU09SVEVEX0RFU0M6ICdtZGMtZGF0YS10YWJsZV9faGVhZGVyLWNlbGwtLXNvcnRlZC1kZXNjZW5kaW5nJyxcclxuICAgIEhFQURFUl9DRUxMX1dSQVBQRVI6ICdtZGMtZGF0YS10YWJsZV9faGVhZGVyLWNlbGwtd3JhcHBlcicsXHJcbiAgICBIRUFERVJfQ0VMTF9MQUJFTDogJ21kYy1kYXRhLXRhYmxlX19oZWFkZXItY2VsbC1sYWJlbCcsXHJcblxyXG4gICAgQ09OVEVOVDogJ21kYy1kYXRhLXRhYmxlX19jb250ZW50JyxcclxuXHJcbiAgICBST1c6ICdtZGMtZGF0YS10YWJsZV9fcm93JyxcclxuICAgIFJPV19DSEVDS0JPWDogJ21kYy1kYXRhLXRhYmxlX19yb3ctY2hlY2tib3gnLFxyXG4gICAgUk9XX1NFTEVDVEVEOiAnbWRjLWRhdGEtdGFibGVfX3Jvdy0tc2VsZWN0ZWQnLFxyXG5cclxuICAgIENFTEw6ICdtZGMtZGF0YS10YWJsZV9fY2VsbCcsXHJcbiAgICBDRUxMX0NIRUNLQk9YOiAnbWRjLWRhdGEtdGFibGVfX2NlbGwtLWNoZWNrYm94JyxcclxuICAgIENFTExfTlVNRVJJQzogJ21kYy1kYXRhLXRhYmxlX19jZWxsLS1udW1lcmljJyxcclxuXHJcbiAgICBQQUdJTkFUSU9OOiAnbWRjLWRhdGEtdGFibGVfX3BhZ2luYXRpb24nLFxyXG4gICAgUEFHSU5BVElPTl9UUkFJTElORzogJ21kYy1kYXRhLXRhYmxlX19wYWdpbmF0aW9uLXRyYWlsaW5nJyxcclxuICAgIFBBR0lOQVRJT05fUk9XU19QRVJfUEFHRTogJ21kYy1kYXRhLXRhYmxlX19wYWdpbmF0aW9uLXJvd3MtcGVyLXBhZ2UnLFxyXG4gICAgUEFHSU5BVElPTl9ST1dTX1BFUl9QQUdFX0xBQkVMOiAnbWRjLWRhdGEtdGFibGVfX3BhZ2luYXRpb24tcm93cy1wZXItcGFnZS1sYWJlbCcsXHJcbiAgICBQQUdJTkFUSU9OX1JPV1NfUEVSX1BBR0VfU0VMRUNUOiAnbWRjLWRhdGEtdGFibGVfX3BhZ2luYXRpb24tcm93cy1wZXItcGFnZS1zZWxlY3QnLFxyXG4gICAgUEFHSU5BVElPTl9OQVZJR0FUSU9OOiAnbWRjLWRhdGEtdGFibGVfX3BhZ2luYXRpb24tbmF2aWdhdGlvbicsXHJcbiAgICBQQUdJTkFUSU9OX1RPVEFMOiAnbWRjLWRhdGEtdGFibGVfX3BhZ2luYXRpb24tdG90YWwnLFxyXG4gICAgUEFHSU5BVElPTl9CVVRUT046ICdtZGMtZGF0YS10YWJsZV9fcGFnaW5hdGlvbi1idXR0b24nLFxyXG5cclxuICAgIFNPUlRfSUNPTl9CVVRUT046ICdtZGMtZGF0YS10YWJsZV9fc29ydC1pY29uLWJ1dHRvbicsXHJcbiAgICBTT1JUX1NUQVRVU19MQUJFTDogJ21kYy1kYXRhLXRhYmxlX19zb3J0LXN0YXR1cy1sYWJlbCcsXHJcbiAgICBQUk9HUkVTU19JTkRJQ0FUT1I6ICdtZGMtZGF0YS10YWJsZV9fcHJvZ3Jlc3MtaW5kaWNhdG9yJyxcclxuICAgIFNDUklNOiAnbWRjLWRhdGEtdGFibGVfX3NjcmltJyxcclxuICAgIEZPT1RFUjogJ21kYy1kYXRhLXRhYmxlX19mb290ZXInLFxyXG4gICAgTElORUFSX1BST0dSRVNTOiAnbWRjLWRhdGEtdGFibGVfX2xpbmVhci1wcm9ncmVzcydcclxufTsiLCJpbXBvcnQgeyBmb3J3YXJkUmVmIH0gZnJvbSAncmVhY3QnO1xyXG5cclxuaW1wb3J0IExpbmVhclByb2dyZXNzIGZyb20gJy4uL2xpbmVhci1wcm9ncmVzcyc7XHJcblxyXG5pbXBvcnQgeyBjc3NDbGFzc2VzIH0gZnJvbSAnLi9jb25zdGFudHMnO1xyXG5cclxuY29uc3QgRGF0YVRhYmxlUHJvZ3Jlc3NJbmRpY2F0b3IgPSBmb3J3YXJkUmVmKChwcm9wcywgcmVmKSA9PiB7XHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAgIDxkaXYgcmVmPXtyZWZ9IGNsYXNzTmFtZT17Y3NzQ2xhc3Nlcy5QUk9HUkVTU19JTkRJQ0FUT1J9IHsuLi5wcm9wc30+XHJcbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXtjc3NDbGFzc2VzLlNDUklNfSAvPlxyXG5cclxuICAgICAgICAgICAgPExpbmVhclByb2dyZXNzIGNsYXNzTmFtZT17Y3NzQ2xhc3Nlcy5MSU5FQVJfUFJPR1JFU1N9IGluZGV0ZXJtaW5hdGUgLz5cclxuICAgICAgICA8L2Rpdj5cclxuICAgICk7XHJcbn0pO1xyXG5cclxuRGF0YVRhYmxlUHJvZ3Jlc3NJbmRpY2F0b3IuZGlzcGxheU5hbWUgPSAnTURDRGF0YVRhYmxlUHJvZ3Jlc3NJbmRpY2F0b3InO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgRGF0YVRhYmxlUHJvZ3Jlc3NJbmRpY2F0b3I7IiwiZXhwb3J0IGNvbnN0IGNzc0NsYXNzZXMgPSB7XHJcbiAgICBST09UOiAnbWRjLWZsb2F0aW5nLWxhYmVsJyxcclxuICAgIEZMT0FUOiAnbWRjLWZsb2F0aW5nLWxhYmVsLS1mbG9hdC1hYm92ZScsXHJcbiAgICBSRVFVSVJFRDogJ21kYy1mbG9hdGluZy1sYWJlbC0tcmVxdWlyZWQnXHJcbn07IiwiaW1wb3J0IHsgZm9yd2FyZFJlZiB9IGZyb20gJ3JlYWN0JztcclxuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcclxuaW1wb3J0IGNsYXNzbmFtZXMgZnJvbSAnY2xhc3NuYW1lcyc7XHJcblxyXG5pbXBvcnQgeyBjc3NDbGFzc2VzIH0gZnJvbSAnLi9jb25zdGFudHMnO1xyXG5cclxuY29uc3QgRmxvYXRpbmdMYWJlbCA9IGZvcndhcmRSZWYoKHtcclxuICAgIGxhYmVsLFxyXG4gICAgZmxvYXQgPSBmYWxzZSxcclxuICAgIHJlcXVpcmVkID0gZmFsc2UsXHJcblxyXG4gICAgY2xhc3NOYW1lLFxyXG4gICAgY2hpbGRyZW4gPSBsYWJlbCxcclxuICAgIC4uLnByb3BzXHJcbn0sIHJlZikgPT4ge1xyXG4gICAgY29uc3QgY2xhc3NOYW1lcyA9IGNsYXNzbmFtZXMoY3NzQ2xhc3Nlcy5ST09ULCB7XHJcbiAgICAgICAgW2Nzc0NsYXNzZXMuRkxPQVRdOiBmbG9hdCxcclxuICAgICAgICBbY3NzQ2xhc3Nlcy5SRVFVSVJFRF06IHJlcXVpcmVkXHJcbiAgICB9LCBjbGFzc05hbWUpO1xyXG5cclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgPHNwYW4gcmVmPXtyZWZ9IGNsYXNzTmFtZT17Y2xhc3NOYW1lc30gey4uLnByb3BzfT5cclxuICAgICAgICAgICAge2NoaWxkcmVufVxyXG4gICAgICAgIDwvc3Bhbj5cclxuICAgICk7XHJcbn0pO1xyXG5cclxuRmxvYXRpbmdMYWJlbC5kaXNwbGF5TmFtZSA9ICdNRENGbG9hdGluZ0xhYmVsJztcclxuXHJcbkZsb2F0aW5nTGFiZWwucHJvcFR5cGVzID0ge1xyXG4gICAgbGFiZWw6IFByb3BUeXBlcy5zdHJpbmcsXHJcbiAgICBmbG9hdDogUHJvcFR5cGVzLmJvb2wsXHJcbiAgICByZXF1aXJlZDogUHJvcFR5cGVzLmJvb2xcclxufTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IEZsb2F0aW5nTGFiZWw7IiwiZXhwb3J0IHsgZGVmYXVsdCB9IGZyb20gJy4vRmxvYXRpbmdMYWJlbCc7IiwiZXhwb3J0IGNvbnN0IGNzc0NsYXNzZXMgPSB7XHJcbiAgICBST09UOiAnbWRjLWxpbmUtcmlwcGxlJyxcclxuICAgIEFDVElWRTogJ21kYy1saW5lLXJpcHBsZS0tYWN0aXZlJyxcclxuICAgIERFQUNUSVZBVElORzogJ21kYy1saW5lLXJpcHBsZS0tZGVhY3RpdmF0aW5nJ1xyXG59OyIsImltcG9ydCB7IGZvcndhcmRSZWYgfSBmcm9tICdyZWFjdCc7XHJcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XHJcbmltcG9ydCBjbGFzc25hbWVzIGZyb20gJ2NsYXNzbmFtZXMnO1xyXG5cclxuaW1wb3J0IHsgY3NzQ2xhc3NlcyB9IGZyb20gJy4vY29uc3RhbnRzJztcclxuXHJcbmNvbnN0IExpbmVSaXBwbGUgPSBmb3J3YXJkUmVmKCh7XHJcbiAgICBhY3RpdmUgPSBmYWxzZSxcclxuICAgIHRyYW5zZm9ybU9yaWdpbixcclxuXHJcbiAgICAuLi5wcm9wc1xyXG59LCByZWYpID0+IHtcclxuICAgIGNvbnN0IHN0eWxlID0gdHJhbnNmb3JtT3JpZ2luICYmIHtcclxuICAgICAgICB0cmFuc2Zvcm1PcmlnaW46IGAke3RyYW5zZm9ybU9yaWdpbn1weGBcclxuICAgIH07XHJcblxyXG4gICAgY29uc3QgY2xhc3NOYW1lcyA9IGNsYXNzbmFtZXMoY3NzQ2xhc3Nlcy5ST09ULCB7XHJcbiAgICAgICAgW2Nzc0NsYXNzZXMuQUNUSVZFXTogYWN0aXZlXHJcbiAgICB9KTtcclxuXHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAgIDxzcGFuXHJcbiAgICAgICAgICAgIHJlZj17cmVmfVxyXG4gICAgICAgICAgICBzdHlsZT17c3R5bGV9XHJcbiAgICAgICAgICAgIGNsYXNzTmFtZT17Y2xhc3NOYW1lc31cclxuICAgICAgICAgICAgey4uLnByb3BzfVxyXG4gICAgICAgIC8+XHJcbiAgICApO1xyXG59KTtcclxuXHJcbkxpbmVSaXBwbGUuZGlzcGxheU5hbWUgPSAnTURDTGluZVJpcHBsZSc7XHJcblxyXG5MaW5lUmlwcGxlLnByb3BUeXBlcyA9IHtcclxuICAgIGFjdGl2ZTogUHJvcFR5cGVzLmJvb2xcclxufTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IExpbmVSaXBwbGU7IiwiZXhwb3J0IHsgZGVmYXVsdCB9IGZyb20gJy4vTGluZVJpcHBsZSc7IiwiZXhwb3J0IGNvbnN0IEtleSA9IHtcclxuICAgIEFSUk9XX0xFRlQ6ICdBcnJvd0xlZnQnLFxyXG4gICAgQVJST1dfVVA6ICdBcnJvd1VwJyxcclxuICAgIEFSUk9XX1JJR0hUOiAnQXJyb3dSaWdodCcsXHJcbiAgICBBUlJPV19ET1dOOiAnQXJyb3dEb3duJyxcclxuICAgIEhPTUU6ICdIb21lJyxcclxuICAgIEVORDogJ0VuZCcsXHJcbiAgICBQQUdFX1VQOiAnUGFnZVVwJyxcclxuICAgIFBBR0VfRE9XTjogJ1BhZ2VEb3duJ1xyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IEtleUNvZGUgPSB7XHJcbiAgICBQQUdFX1VQOiAzMyxcclxuICAgIFBBR0VfRE9XTjogMzQsXHJcbiAgICBFTkQ6IDM1LFxyXG4gICAgSE9NRTogMzYsXHJcbiAgICBBUlJPV19MRUZUOiAzNyxcclxuICAgIEFSUk9XX1VQOiAzOCxcclxuICAgIEFSUk9XX1JJR0hUOiAzOSxcclxuICAgIEFSUk9XX0RPV046IDQwXHJcbn07IiwiaW1wb3J0IHsgS2V5LCBLZXlDb2RlIH0gZnJvbSAnLi9jb25zdGFudHMnO1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGdldENsaWVudFdpZHRoKGVsZW1lbnQpIHtcclxuICAgIGlmIChlbGVtZW50Lm9mZnNldFBhcmVudCAhPT0gbnVsbCkge1xyXG4gICAgICAgIHJldHVybiBlbGVtZW50LmNsaWVudFdpZHRoO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IGNsb25lID0gZWxlbWVudC5jbG9uZU5vZGUodHJ1ZSk7XHJcbiAgICBjbG9uZS5zdHlsZS5zZXRQcm9wZXJ0eSgncG9zaXRpb24nLCAnYWJzb2x1dGUnKTtcclxuICAgIGNsb25lLnN0eWxlLnNldFByb3BlcnR5KCd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlKC05OTk5cHgsIC05OTk5cHgpJyk7XHJcbiAgICBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuYXBwZW5kQ2hpbGQoY2xvbmUpO1xyXG4gICAgY29uc3QgY2xpZW50V2lkdGggPSBjbG9uZS5jbGllbnRXaWR0aDtcclxuICAgIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5yZW1vdmVDaGlsZChjbG9uZSk7XHJcblxyXG4gICAgcmV0dXJuIGNsaWVudFdpZHRoO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gZ2V0RXZlbnRLZXkoZXZlbnQpIHtcclxuICAgIHN3aXRjaCAoZXZlbnQua2V5IHx8IGV2ZW50LmtleUNvZGUpIHtcclxuICAgICAgICBjYXNlIEtleS5BUlJPV19MRUZUOlxyXG4gICAgICAgIGNhc2UgS2V5Q29kZS5BUlJPV19MRUZUOlxyXG4gICAgICAgICAgICByZXR1cm4gS2V5LkFSUk9XX0xFRlQ7XHJcblxyXG4gICAgICAgIGNhc2UgS2V5LkFSUk9XX1VQOlxyXG4gICAgICAgIGNhc2UgS2V5Q29kZS5BUlJPV19VUDpcclxuICAgICAgICAgICAgcmV0dXJuIEtleS5BUlJPV19VUDtcclxuXHJcbiAgICAgICAgY2FzZSBLZXkuQVJST1dfUklHSFQ6XHJcbiAgICAgICAgY2FzZSBLZXlDb2RlLkFSUk9XX1JJR0hUOlxyXG4gICAgICAgICAgICByZXR1cm4gS2V5LkFSUk9XX1JJR0hUO1xyXG5cclxuICAgICAgICBjYXNlIEtleS5BUlJPV19ET1dOOlxyXG4gICAgICAgIGNhc2UgS2V5Q29kZS5BUlJPV19ET1dOOlxyXG4gICAgICAgICAgICByZXR1cm4gS2V5LkFSUk9XX0RPV047XHJcblxyXG4gICAgICAgIGNhc2UgS2V5LkhPTUU6XHJcbiAgICAgICAgY2FzZSBLZXlDb2RlLkhPTUU6XHJcbiAgICAgICAgICAgIHJldHVybiBLZXkuSE9NRTtcclxuXHJcbiAgICAgICAgY2FzZSBLZXkuRU5EOlxyXG4gICAgICAgIGNhc2UgS2V5Q29kZS5FTkQ6XHJcbiAgICAgICAgICAgIHJldHVybiBLZXkuRU5EO1xyXG5cclxuICAgICAgICBjYXNlIEtleS5QQUdFX1VQOlxyXG4gICAgICAgIGNhc2UgS2V5Q29kZS5QQUdFX1VQOlxyXG4gICAgICAgICAgICByZXR1cm4gS2V5LlBBR0VfVVA7XHJcblxyXG4gICAgICAgIGNhc2UgS2V5LlBBR0VfRE9XTjpcclxuICAgICAgICBjYXNlIEtleUNvZGUuUEFHRV9ET1dOOlxyXG4gICAgICAgICAgICByZXR1cm4gS2V5LlBBR0VfRE9XTjtcclxuXHJcbiAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgIH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGdldFBhZ2VYKGV2ZW50KSB7XHJcbiAgICBpZiAoZXZlbnQudGFyZ2V0VG91Y2hlcz8ubGVuZ3RoID4gMCkge1xyXG4gICAgICAgIHJldHVybiBldmVudC50YXJnZXRUb3VjaGVzWzBdLnBhZ2VYO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBldmVudC5wYWdlWDtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGdldFBhZ2VZKGV2ZW50KSB7XHJcbiAgICBpZiAoZXZlbnQudGFyZ2V0VG91Y2hlcz8ubGVuZ3RoID4gMCkge1xyXG4gICAgICAgIHJldHVybiBldmVudC50YXJnZXRUb3VjaGVzWzBdLnBhZ2VZO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBldmVudC5wYWdlWTtcclxufSIsImV4cG9ydCBjb25zdCBudW1iZXJzID0ge1xyXG4gICAgTk9UQ0hfU0laRV9GQUNUT1I6IDAuNzUsXHJcbiAgICBOT1RDSF9QQURESU5HX1JJR0hUOiA4XHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgY3NzQ2xhc3NlcyA9IHtcclxuICAgIFJPT1Q6ICdtZGMtbm90Y2hlZC1vdXRsaW5lJyxcclxuICAgIE5PVENIRUQ6ICdtZGMtbm90Y2hlZC1vdXRsaW5lLS1ub3RjaGVkJyxcclxuICAgIFVQR1JBREVEOiAnbWRjLW5vdGNoZWQtb3V0bGluZS0tdXBncmFkZWQnLFxyXG4gICAgTk9fTEFCRUw6ICdtZGMtbm90Y2hlZC1vdXRsaW5lLS1uby1sYWJlbCcsXHJcblxyXG4gICAgTEVBRElORzogJ21kYy1ub3RjaGVkLW91dGxpbmVfX2xlYWRpbmcnLFxyXG4gICAgTk9UQ0g6ICdtZGMtbm90Y2hlZC1vdXRsaW5lX19ub3RjaCcsXHJcbiAgICBUUkFJTElORzogJ21kYy1ub3RjaGVkLW91dGxpbmVfX3RyYWlsaW5nJ1xyXG59OyIsImltcG9ydCB7IGZvcndhcmRSZWYsIHVzZVJlZiwgdXNlTGF5b3V0RWZmZWN0IH0gZnJvbSAncmVhY3QnO1xyXG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xyXG5pbXBvcnQgY2xhc3NuYW1lcyBmcm9tICdjbGFzc25hbWVzJztcclxuXHJcbmltcG9ydCB7IGdldENsaWVudFdpZHRoIH0gZnJvbSAnLi4vdXRpbHMnO1xyXG5cclxuaW1wb3J0IHsgbnVtYmVycywgY3NzQ2xhc3NlcyB9IGZyb20gJy4vY29uc3RhbnRzJztcclxuXHJcbmNvbnN0IE5vdGNoZWRPdXRsaW5lID0gZm9yd2FyZFJlZigoe1xyXG4gICAgbm90Y2hlZCA9IGZhbHNlLFxyXG5cclxuICAgIGNsYXNzTmFtZSxcclxuICAgIGNoaWxkcmVuLFxyXG4gICAgLi4ucHJvcHNcclxufSwgcmVmKSA9PiB7XHJcbiAgICBjb25zdCBub3RjaFJlZiA9IHVzZVJlZigpO1xyXG5cclxuICAgIHVzZUxheW91dEVmZmVjdCgoKSA9PiB7XHJcbiAgICAgICAgY29uc3Qgbm90Y2ggPSBub3RjaFJlZi5jdXJyZW50O1xyXG4gICAgICAgIGNvbnN0IGZsb2F0aW5nTGFiZWwgPSBub3RjaD8uZmlyc3RDaGlsZDtcclxuXHJcbiAgICAgICAgaWYgKCFub3RjaCB8fCAhZmxvYXRpbmdMYWJlbCkgcmV0dXJuO1xyXG5cclxuICAgICAgICBjb25zdCB3aWR0aCA9IGdldENsaWVudFdpZHRoKGZsb2F0aW5nTGFiZWwpO1xyXG5cclxuICAgICAgICBpZiAobm90Y2hlZCkge1xyXG4gICAgICAgICAgICBub3RjaFJlZi5jdXJyZW50LnN0eWxlLndpZHRoID0gYCR7d2lkdGggKiBudW1iZXJzLk5PVENIX1NJWkVfRkFDVE9SICsgbnVtYmVycy5OT1RDSF9QQURESU5HX1JJR0hUfXB4YDtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBub3RjaFJlZi5jdXJyZW50LnN0eWxlLndpZHRoID0gJ2F1dG8nO1xyXG4gICAgICAgIH1cclxuICAgIH0sIFtub3RjaGVkXSk7XHJcblxyXG4gICAgY29uc3QgY2xhc3NOYW1lcyA9IGNsYXNzbmFtZXMoY3NzQ2xhc3Nlcy5ST09ULCBjc3NDbGFzc2VzLlVQR1JBREVELCB7XHJcbiAgICAgICAgW2Nzc0NsYXNzZXMuTk9UQ0hFRF06IG5vdGNoZWQsXHJcbiAgICAgICAgW2Nzc0NsYXNzZXMuTk9fTEFCRUxdOiAhY2hpbGRyZW5cclxuICAgIH0sIGNsYXNzTmFtZSk7XHJcblxyXG4gICAgcmV0dXJuIChcclxuICAgICAgICA8c3BhbiByZWY9e3JlZn0gY2xhc3NOYW1lPXtjbGFzc05hbWVzfSB7Li4ucHJvcHN9PlxyXG4gICAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9e2Nzc0NsYXNzZXMuTEVBRElOR30gLz5cclxuXHJcbiAgICAgICAgICAgIHtjaGlsZHJlbiAmJlxyXG4gICAgICAgICAgICAgICAgPHNwYW4gcmVmPXtub3RjaFJlZn0gY2xhc3NOYW1lPXtjc3NDbGFzc2VzLk5PVENIfT5cclxuICAgICAgICAgICAgICAgICAgICB7Y2hpbGRyZW59XHJcbiAgICAgICAgICAgICAgICA8L3NwYW4+XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT17Y3NzQ2xhc3Nlcy5UUkFJTElOR30gLz5cclxuICAgICAgICA8L3NwYW4+XHJcbiAgICApO1xyXG59KTtcclxuXHJcbk5vdGNoZWRPdXRsaW5lLmRpc3BsYXlOYW1lID0gJ01EQ05vdGNoZWRPdXRsaW5lJztcclxuXHJcbk5vdGNoZWRPdXRsaW5lLnByb3BUeXBlcyA9IHtcclxuICAgIG5vdGNoZWQ6IFByb3BUeXBlcy5ib29sXHJcbn07XHJcblxyXG5leHBvcnQgZGVmYXVsdCBOb3RjaGVkT3V0bGluZTsiLCJleHBvcnQgeyBkZWZhdWx0IH0gZnJvbSAnLi9Ob3RjaGVkT3V0bGluZSc7IiwiZXhwb3J0IGNvbnN0IG51bWJlcnMgPSB7XHJcbiAgICBUUkFOU0lUSU9OX09QRU5fRFVSQVRJT046IDEyMCxcclxuICAgIFRSQU5TSVRJT05fQ0xPU0VfRFVSQVRJT046IDc1LFxyXG4gICAgTUFSR0lOX1RPX0VER0U6IDMyLFxyXG4gICAgQU5DSE9SX1RPX01FTlVfU1VSRkFDRV9XSURUSF9SQVRJTzogMC42NyxcclxuICAgIFRPVUNIX0VWRU5UX1dBSVRfTVM6IDMwXHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgY3NzQ2xhc3NlcyA9IHtcclxuICAgIFJPT1Q6ICdtZGMtbWVudScsXHJcblxyXG4gICAgU1VSRkFDRTogJ21kYy1tZW51LXN1cmZhY2UnLFxyXG4gICAgU1VSRkFDRV9BTkNIT1I6ICdtZGMtbWVudS1zdXJmYWNlLS1hbmNob3InLFxyXG4gICAgU1VSRkFDRV9GSVhFRDogJ21kYy1tZW51LXN1cmZhY2UtLWZpeGVkJyxcclxuICAgIFNVUkZBQ0VfT1BFTjogJ21kYy1tZW51LXN1cmZhY2UtLW9wZW4nLFxyXG4gICAgU1VSRkFDRV9BTklNQVRJTkdfT1BFTjogJ21kYy1tZW51LXN1cmZhY2UtLWFuaW1hdGluZy1vcGVuJyxcclxuICAgIFNVUkZBQ0VfQU5JTUFUSU5HX0NMT1NFRDogJ21kYy1tZW51LXN1cmZhY2UtLWFuaW1hdGluZy1jbG9zZWQnLFxyXG4gICAgU1VSRkFDRV9CRUxPV19BTkNIT1I6ICdtZGMtbWVudS1zdXJmYWNlLS1pcy1vcGVuLWJlbG93JyxcclxuXHJcbiAgICBJVEVNOiAnbWRjLW1lbnUtaXRlbScsXHJcbiAgICBJVEVNX1NFTEVDVEVEOiAnbWRjLW1lbnUtaXRlbS0tc2VsZWN0ZWQnLFxyXG5cclxuICAgIFNFTEVDVElPTl9HUk9VUDogJ21kYy1tZW51X19zZWxlY3Rpb24tZ3JvdXAnLFxyXG4gICAgU0VMRUNUSU9OX0dST1VQX0lDT046ICdtZGMtbWVudV9fc2VsZWN0aW9uLWdyb3VwLWljb24nXHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgT3JpZ2luID0ge1xyXG4gICAgVE9QX0xFRlQ6ICd0b3AgbGVmdCcsXHJcbiAgICBUT1BfQ0VOVEVSOiAndG9wIGNlbnRlcicsXHJcbiAgICBUT1BfUklHSFQ6ICd0b3AgcmlnaHQnLFxyXG4gICAgQ0VOVEVSX0xFRlQ6ICdjZW50ZXIgbGVmdCcsXHJcbiAgICBDRU5URVI6ICdjZW50ZXIgY2VudGVyJyxcclxuICAgIENFTlRFUl9SSUdIVDogJ2NlbnRlciByaWdodCcsXHJcbiAgICBCT1RUT01fTEVGVDogJ2JvdHRvbSBsZWZ0JyxcclxuICAgIEJPVFRPTV9DRU5URVI6ICdib3R0b20gY2VudGVyJyxcclxuICAgIEJPVFRPTV9SSUdIVDogJ2JvdHRvbSByaWdodCdcclxufTsiLCJpbXBvcnQgeyB1c2VFZmZlY3QsIHVzZUxheW91dEVmZmVjdCwgdXNlU3RhdGUgfSBmcm9tICdyZWFjdCc7XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gdXNlQ3JlYXRlZChmbikge1xyXG4gICAgY29uc3QgW2NyZWF0ZWQsIHNldENyZWF0ZWRdID0gdXNlU3RhdGUoZmFsc2UpO1xyXG5cclxuICAgIGlmIChjcmVhdGVkKSByZXR1cm47XHJcblxyXG4gICAgZm4oKTtcclxuICAgIHNldENyZWF0ZWQodHJ1ZSk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiB1c2VNb3VudGVkKGZuKSB7XHJcbiAgICB1c2VFZmZlY3QoKCkgPT4gZm4oKSwgW10pO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gdXNlVXBkYXRlZChmbiwgZGVwcykge1xyXG4gICAgY29uc3QgW21vdW50ZWQsIHNldE1vdW50ZWRdID0gdXNlU3RhdGUoZmFsc2UpO1xyXG5cclxuICAgIHVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICAgICAgaWYgKCFtb3VudGVkKSByZXR1cm4gc2V0TW91bnRlZCh0cnVlKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIGZuKCk7XHJcbiAgICB9LCBkZXBzKTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIHVzZVVwZGF0ZWRTeW5jKGZuLCBkZXBzKSB7XHJcbiAgICBjb25zdCBbbW91bnRlZCwgc2V0TW91bnRlZF0gPSB1c2VTdGF0ZShmYWxzZSk7XHJcblxyXG4gICAgdXNlTGF5b3V0RWZmZWN0KCgpID0+IHtcclxuICAgICAgICBpZiAoIW1vdW50ZWQpIHJldHVybiBzZXRNb3VudGVkKHRydWUpO1xyXG5cclxuICAgICAgICByZXR1cm4gZm4oKTtcclxuICAgIH0sIGRlcHMpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gdXNlVW5tb3VudGVkKGZuKSB7XHJcbiAgICB1c2VFZmZlY3QoKCkgPT4gKCkgPT4gZm4oKSwgW10pO1xyXG59IiwiZXhwb3J0IGNvbnN0IGxpc3RDc3NDbGFzc2VzID0ge1xyXG4gICAgUk9PVDogJ21kYy1saXN0J1xyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IGxpc3RJdGVtQ3NzQ2xhc3NlcyA9IHtcclxuICAgIFJPT1Q6ICdtZGMtbGlzdC1pdGVtJyxcclxuICAgIEFDVElWQVRFRDogJ21kYy1saXN0LWl0ZW0tLWFjdGl2YXRlZCcsXHJcbiAgICBTRUxFQ1RFRDogJ21kYy1saXN0LWl0ZW0tLXNlbGVjdGVkJyxcclxuICAgIERJU0FCTEVEOiAnbWRjLWxpc3QtaXRlbS0tZGlzYWJsZWQnLFxyXG4gICAgTk9OX0lOVEVSQUNUSVZFOiAnbWRjLWxpc3QtaXRlbS0tbm9uLWludGVyYWN0aXZlJyxcclxuXHJcbiAgICBPTkVfTElORTogJ21kYy1saXN0LWl0ZW0tLXdpdGgtb25lLWxpbmUnLFxyXG4gICAgVFdPX0xJTkVTOiAnbWRjLWxpc3QtaXRlbS0td2l0aC10d28tbGluZXMnLFxyXG4gICAgVEhSRUVfTElORVM6ICdtZGMtbGlzdC1pdGVtLS13aXRoLXRocmVlLWxpbmVzJyxcclxuICAgIE9WRVJMSU5FOiAnbWRjLWxpc3QtaXRlbS0td2l0aC1vdmVybGluZScsXHJcbiAgICBMRUFESU5HX0lDT046ICdtZGMtbGlzdC1pdGVtLS13aXRoLWxlYWRpbmctaWNvbicsXHJcbiAgICBMRUFESU5HX0lNQUdFOiAnbWRjLWxpc3QtaXRlbS0td2l0aC1sZWFkaW5nLWltYWdlJyxcclxuICAgIExFQURJTkdfQVZBVEFSOiAnbWRjLWxpc3QtaXRlbS0td2l0aC1sZWFkaW5nLWF2YXRhcicsXHJcbiAgICBMRUFESU5HX1RIVU1CTkFJTDogJ21kYy1saXN0LWl0ZW0tLXdpdGgtbGVhZGluZy10aHVtYm5haWwnLFxyXG4gICAgTEVBRElOR19WSURFTzogJ21kYy1saXN0LWl0ZW0tLXdpdGgtbGVhZGluZy12aWRlbycsXHJcbiAgICBMRUFESU5HX0NIRUNLQk9YOiAnbWRjLWxpc3QtaXRlbS0td2l0aC1sZWFkaW5nLWNoZWNrYm94JyxcclxuICAgIExFQURJTkdfUkFESU86ICdtZGMtbGlzdC1pdGVtLS13aXRoLWxlYWRpbmctcmFkaW8nLFxyXG4gICAgTEVBRElOR19TV0lUQ0g6ICdtZGMtbGlzdC1pdGVtLS13aXRoLWxlYWRpbmctc3dpdGNoJyxcclxuICAgIFRSQUlMSU5HX0lDT046ICdtZGMtbGlzdC1pdGVtLS13aXRoLXRyYWlsaW5nLWljb24nLFxyXG4gICAgVFJBSUxJTkdfTUVUQTogJ21kYy1saXN0LWl0ZW0tLXdpdGgtdHJhaWxpbmctbWV0YScsXHJcbiAgICBUUkFJTElOR19DSEVDS0JPWDogJ21kYy1saXN0LWl0ZW0tLXdpdGgtdHJhaWxpbmctY2hlY2tib3gnLFxyXG4gICAgVFJBSUxJTkdfUkFESU86ICdtZGMtbGlzdC1pdGVtLS13aXRoLXRyYWlsaW5nLXJhZGlvJyxcclxuICAgIFRSQUlMSU5HX1NXSVRDSDogJ21kYy1saXN0LWl0ZW0tLXdpdGgtdHJhaWxpbmctc3dpdGNoJyxcclxuXHJcbiAgICBTVEFSVDogJ21kYy1saXN0LWl0ZW1fX3N0YXJ0JyxcclxuICAgIENPTlRFTlQ6ICdtZGMtbGlzdC1pdGVtX19jb250ZW50JyxcclxuICAgIEVORDogJ21kYy1saXN0LWl0ZW1fX2VuZCcsXHJcblxyXG4gICAgT1ZFUkxJTkVfVEVYVDogJ21kYy1saXN0LWl0ZW1fX292ZXJsaW5lLXRleHQnLFxyXG4gICAgUFJJTUFSWV9URVhUOiAnbWRjLWxpc3QtaXRlbV9fcHJpbWFyeS10ZXh0JyxcclxuICAgIFNFQ09OREFSWV9URVhUOiAnbWRjLWxpc3QtaXRlbV9fc2Vjb25kYXJ5LXRleHQnLFxyXG5cclxuICAgIFJJUFBMRTogJ21kYy1saXN0LWl0ZW1fX3JpcHBsZSdcclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCBsaXN0R3JvdXBDc3NDbGFzc2VzID0ge1xyXG4gICAgUk9PVDogJ21kYy1saXN0LWdyb3VwJyxcclxuICAgIFNVQkhFQURFUjogJ21kYy1saXN0LWdyb3VwX19zdWJoZWFkZXInXHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgbGlzdERpdmlkZXJDc3NDbGFzc2VzID0ge1xyXG4gICAgUk9PVDogJ21kYy1saXN0LWRpdmlkZXInLFxyXG4gICAgTEVBRElOR19URVhUOiAnbWRjLWxpc3QtZGl2aWRlci0td2l0aC1sZWFkaW5nLXRleHQnLFxyXG4gICAgTEVBRElOR19JQ09OOiAnbWRjLWxpc3QtZGl2aWRlci0td2l0aC1sZWFkaW5nLWljb24nLFxyXG4gICAgTEVBRElOR19JTUFHRTogJ21kYy1saXN0LWRpdmlkZXItLXdpdGgtbGVhZGluZy1pbWFnZScsXHJcbiAgICBMRUFESU5HX1ZJREVPOiAnbWRjLWxpc3QtZGl2aWRlci0td2l0aC1sZWFkaW5nLXZpZGVvJyxcclxuICAgIExFQURJTkdfVEhVTUJOQUlMOiAnbWRjLWxpc3QtZGl2aWRlci0td2l0aC1sZWFkaW5nLXRodW1ibmFpbCcsXHJcbiAgICBMRUFESU5HX0FWQVRBUjogJ21kYy1saXN0LWRpdmlkZXItLXdpdGgtbGVhZGluZy1hdmF0YXInLFxyXG4gICAgTEVBRElOR19DSEVDS0JPWDogJ21kYy1saXN0LWRpdmlkZXItLXdpdGgtbGVhZGluZy1jaGVja2JveCcsXHJcbiAgICBMRUFESU5HX1NXSVRDSDogJ21kYy1saXN0LWRpdmlkZXItLXdpdGgtbGVhZGluZy1zd2l0Y2gnLFxyXG4gICAgTEVBRElOR19SQURJTzogJ21kYy1saXN0LWRpdmlkZXItLXdpdGgtbGVhZGluZy1yYWRpbycsXHJcbn07IiwiaW1wb3J0IHsgZm9yd2FyZFJlZiB9IGZyb20gJ3JlYWN0JztcclxuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcclxuaW1wb3J0IGNsYXNzbmFtZXMgZnJvbSAnY2xhc3NuYW1lcyc7XHJcblxyXG5pbXBvcnQgeyBDbG9uZSB9IGZyb20gJy4uL2NvbXBvbmVudCc7XHJcblxyXG5pbXBvcnQgeyBsaXN0SXRlbUNzc0NsYXNzZXMgYXMgY3NzQ2xhc3NlcyB9IGZyb20gJy4vY29uc3RhbnRzJztcclxuXHJcbmNvbnN0IExpc3RJdGVtQ29udGVudCA9IGZvcndhcmRSZWYoKHtcclxuICAgIG92ZXJsaW5lLFxyXG4gICAgcHJpbWFyeSxcclxuICAgIHNlY29uZGFyeSxcclxuICAgIG92ZXJsaW5lVGV4dCA9IG92ZXJsaW5lLFxyXG4gICAgcHJpbWFyeVRleHQgPSBwcmltYXJ5LFxyXG4gICAgc2Vjb25kYXJ5VGV4dCA9IHNlY29uZGFyeSxcclxuXHJcbiAgICBlbGVtZW50ID0gJ3NwYW4nLFxyXG4gICAgY29tcG9uZW50OiBFbGVtZW50ID0gZWxlbWVudCxcclxuICAgIGNsYXNzTmFtZSxcclxuICAgIGNoaWxkcmVuLFxyXG4gICAgLi4ucHJvcHNcclxufSwgcmVmKSA9PiB7XHJcbiAgICBjb25zdCBjbGFzc05hbWVzID0gY2xhc3NuYW1lcyhjc3NDbGFzc2VzLkNPTlRFTlQsIGNsYXNzTmFtZSk7XHJcblxyXG4gICAgcmV0dXJuIChcclxuICAgICAgICA8RWxlbWVudCByZWY9e3JlZn0gY2xhc3NOYW1lPXtjbGFzc05hbWVzfSB7Li4ucHJvcHN9PlxyXG4gICAgICAgICAgICB7b3ZlcmxpbmVUZXh0ICYmXHJcbiAgICAgICAgICAgICAgICA8Q2xvbmVcclxuICAgICAgICAgICAgICAgICAgICBjb21wb25lbnQ9e292ZXJsaW5lVGV4dH1cclxuICAgICAgICAgICAgICAgICAgICBmYWxsYmFjaz1cInNwYW5cIlxyXG4gICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT17Y3NzQ2xhc3Nlcy5PVkVSTElORV9URVhUfVxyXG4gICAgICAgICAgICAgICAgLz5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAge3ByaW1hcnlUZXh0ICYmXHJcbiAgICAgICAgICAgICAgICA8Q2xvbmVcclxuICAgICAgICAgICAgICAgICAgICBjb21wb25lbnQ9e3ByaW1hcnlUZXh0fVxyXG4gICAgICAgICAgICAgICAgICAgIGZhbGxiYWNrPVwic3BhblwiXHJcbiAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPXtjc3NDbGFzc2VzLlBSSU1BUllfVEVYVH1cclxuICAgICAgICAgICAgICAgIC8+XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHtzZWNvbmRhcnlUZXh0ICYmXHJcbiAgICAgICAgICAgICAgICA8Q2xvbmVcclxuICAgICAgICAgICAgICAgICAgICBjb21wb25lbnQ9e3NlY29uZGFyeVRleHR9XHJcbiAgICAgICAgICAgICAgICAgICAgZmFsbGJhY2s9XCJzcGFuXCJcclxuICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU9e2Nzc0NsYXNzZXMuU0VDT05EQVJZX1RFWFR9XHJcbiAgICAgICAgICAgICAgICAvPlxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB7Y2hpbGRyZW59XHJcbiAgICAgICAgPC9FbGVtZW50PlxyXG4gICAgKTtcclxufSk7XHJcblxyXG5MaXN0SXRlbUNvbnRlbnQuZGlzcGxheU5hbWUgPSAnTURDTGlzdEl0ZW1Db250ZW50JztcclxuXHJcbkxpc3RJdGVtQ29udGVudC5wcm9wVHlwZXMgPSB7XHJcbiAgICBvdmVybGluZVRleHQ6IFByb3BUeXBlcy5ub2RlLFxyXG4gICAgcHJpbWFyeVRleHQ6IFByb3BUeXBlcy5ub2RlLFxyXG4gICAgc2Vjb25kYXJ5VGV4dDogUHJvcFR5cGVzLm5vZGVcclxufTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IExpc3RJdGVtQ29udGVudDsiLCJpbXBvcnQgeyBmb3J3YXJkUmVmIH0gZnJvbSAncmVhY3QnO1xyXG5pbXBvcnQgY2xhc3NuYW1lcyBmcm9tICdjbGFzc25hbWVzJztcclxuXHJcbmltcG9ydCB7IGxpc3RJdGVtQ3NzQ2xhc3NlcyBhcyBjc3NDbGFzc2VzIH0gZnJvbSAnLi9jb25zdGFudHMnO1xyXG5cclxuY29uc3QgTGlzdEl0ZW1FbmQgPSBmb3J3YXJkUmVmKCh7XHJcbiAgICBlbGVtZW50ID0gJ3NwYW4nLFxyXG4gICAgY29tcG9uZW50OiBFbGVtZW50ID0gZWxlbWVudCxcclxuICAgIGNsYXNzTmFtZSxcclxuICAgIC4uLnByb3BzXHJcbn0sIHJlZikgPT4ge1xyXG4gICAgY29uc3QgY2xhc3NOYW1lcyA9IGNsYXNzbmFtZXMoY3NzQ2xhc3Nlcy5FTkQsIGNsYXNzTmFtZSk7XHJcblxyXG4gICAgcmV0dXJuIChcclxuICAgICAgICA8RWxlbWVudCByZWY9e3JlZn0gY2xhc3NOYW1lPXtjbGFzc05hbWVzfSB7Li4ucHJvcHN9IC8+XHJcbiAgICApO1xyXG59KTtcclxuXHJcbkxpc3RJdGVtRW5kLmRpc3BsYXlOYW1lID0gJ01EQ0xpc3RJdGVtRW5kJztcclxuXHJcbmV4cG9ydCBkZWZhdWx0IExpc3RJdGVtRW5kOyIsImltcG9ydCB7IGZvcndhcmRSZWYgfSBmcm9tICdyZWFjdCc7XHJcbmltcG9ydCBjbGFzc25hbWVzIGZyb20gJ2NsYXNzbmFtZXMnO1xyXG5cclxuaW1wb3J0IHsgbGlzdEl0ZW1Dc3NDbGFzc2VzIGFzIGNzc0NsYXNzZXMgfSBmcm9tICcuL2NvbnN0YW50cyc7XHJcblxyXG5jb25zdCBMaXN0SXRlbVN0YXJ0ID0gZm9yd2FyZFJlZigoe1xyXG4gICAgZWxlbWVudCA9ICdzcGFuJyxcclxuICAgIGNvbXBvbmVudDogRWxlbWVudCA9IGVsZW1lbnQsXHJcbiAgICBjbGFzc05hbWUsXHJcbiAgICAuLi5wcm9wc1xyXG59LCByZWYpID0+IHtcclxuICAgIGNvbnN0IGNsYXNzTmFtZXMgPSBjbGFzc25hbWVzKGNzc0NsYXNzZXMuU1RBUlQsIGNsYXNzTmFtZSk7XHJcblxyXG4gICAgcmV0dXJuIChcclxuICAgICAgICA8RWxlbWVudCByZWY9e3JlZn0gY2xhc3NOYW1lPXtjbGFzc05hbWVzfSB7Li4ucHJvcHN9IC8+XHJcbiAgICApO1xyXG59KTtcclxuXHJcbkxpc3RJdGVtU3RhcnQuZGlzcGxheU5hbWUgPSAnTURDTGlzdEl0ZW1TdGFydCc7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBMaXN0SXRlbVN0YXJ0OyIsImltcG9ydCB7IGZvcndhcmRSZWYgfSBmcm9tICdyZWFjdCc7XHJcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XHJcbmltcG9ydCBjbGFzc25hbWVzIGZyb20gJ2NsYXNzbmFtZXMnO1xyXG5cclxuaW1wb3J0IHsgQ2xvbmUgfSBmcm9tICcuLi9jb21wb25lbnQnO1xyXG5pbXBvcnQgSWNvbiBmcm9tICcuLi9pY29uJztcclxuXHJcbmltcG9ydCB7IGxpc3RJdGVtQ3NzQ2xhc3NlcyBhcyBjc3NDbGFzc2VzIH0gZnJvbSAnLi9jb25zdGFudHMnO1xyXG5pbXBvcnQgTGlzdEl0ZW1Db250ZW50IGZyb20gJy4vTGlzdEl0ZW1Db250ZW50JztcclxuaW1wb3J0IExpc3RJdGVtRW5kIGZyb20gJy4vTGlzdEl0ZW1FbmQnO1xyXG5pbXBvcnQgTGlzdEl0ZW1TdGFydCBmcm9tICcuL0xpc3RJdGVtU3RhcnQnO1xyXG5cclxuY29uc3QgTGlzdEl0ZW0gPSBmb3J3YXJkUmVmKCh7XHJcbiAgICBzdGFydCxcclxuICAgIGNvbnRlbnQsXHJcbiAgICBlbmQsXHJcbiAgICB0ZXh0LFxyXG4gICAgb3ZlcmxpbmVUZXh0LFxyXG4gICAgcHJpbWFyeVRleHQgPSB0ZXh0LFxyXG4gICAgc2Vjb25kYXJ5VGV4dCxcclxuICAgIGljb24sXHJcbiAgICBpbWFnZSxcclxuICAgIGF2YXRhcixcclxuICAgIHRodW1ibmFpbCxcclxuICAgIHZpZGVvLFxyXG4gICAgbGVhZGluZ0ljb24gPSBpY29uLFxyXG4gICAgbGVhZGluZ0ltYWdlID0gaW1hZ2UsXHJcbiAgICBsZWFkaW5nQXZhdGFyID0gYXZhdGFyLFxyXG4gICAgbGVhZGluZ1RodW1ibmFpbCA9IHRodW1ibmFpbCxcclxuICAgIGxlYWRpbmdWaWRlbyA9IHZpZGVvLFxyXG4gICAgbGVhZGluZ0NoZWNrYm94LFxyXG4gICAgbGVhZGluZ1JhZGlvLFxyXG4gICAgbGVhZGluZ1N3aXRjaCxcclxuICAgIG1ldGEsXHJcbiAgICB0cmFpbGluZ01ldGEgPSBtZXRhLFxyXG4gICAgdHJhaWxpbmdJY29uLFxyXG4gICAgdHJhaWxpbmdDaGVja2JveCxcclxuICAgIHRyYWlsaW5nUmFkaW8sXHJcbiAgICB0cmFpbGluZ1N3aXRjaCxcclxuICAgIGFjdGl2YXRlZCA9IGZhbHNlLFxyXG4gICAgc2VsZWN0ZWQgPSBmYWxzZSxcclxuICAgIGRpc2FibGVkID0gZmFsc2UsXHJcbiAgICBub25JbnRlcmFjdGl2ZSA9IGZhbHNlLFxyXG4gICAgb25lTGluZSA9IGZhbHNlLFxyXG4gICAgdHdvTGluZXMgPSBmYWxzZSxcclxuICAgIHRocmVlTGluZXMgPSBmYWxzZSxcclxuICAgIHdpdGhMZWFkaW5nSWNvbiA9IEJvb2xlYW4obGVhZGluZ0ljb24pLFxyXG4gICAgd2l0aExlYWRpbmdJbWFnZSA9IEJvb2xlYW4obGVhZGluZ0ltYWdlKSxcclxuICAgIHdpdGhMZWFkaW5nQXZhdGFyID0gQm9vbGVhbihsZWFkaW5nQXZhdGFyKSxcclxuICAgIHdpdGhMZWFkaW5nVGh1bWJuYWlsID0gQm9vbGVhbihsZWFkaW5nVGh1bWJuYWlsKSxcclxuICAgIHdpdGhMZWFkaW5nVmlkZW8gPSBCb29sZWFuKGxlYWRpbmdWaWRlbyksXHJcbiAgICB3aXRoTGVhZGluZ0NoZWNrYm94ID0gQm9vbGVhbihsZWFkaW5nQ2hlY2tib3gpLFxyXG4gICAgd2l0aExlYWRpbmdSYWRpbyA9IEJvb2xlYW4obGVhZGluZ1JhZGlvKSxcclxuICAgIHdpdGhMZWFkaW5nU3dpdGNoID0gQm9vbGVhbihsZWFkaW5nU3dpdGNoKSxcclxuICAgIHdpdGhUcmFpbGluZ01ldGEgPSBCb29sZWFuKHRyYWlsaW5nTWV0YSksXHJcbiAgICB3aXRoVHJhaWxpbmdJY29uID0gQm9vbGVhbih0cmFpbGluZ0ljb24pLFxyXG4gICAgd2l0aFRyYWlsaW5nQ2hlY2tib3ggPSBCb29sZWFuKHRyYWlsaW5nQ2hlY2tib3gpLFxyXG4gICAgd2l0aFRyYWlsaW5nUmFkaW8gPSBCb29sZWFuKHRyYWlsaW5nUmFkaW8pLFxyXG4gICAgd2l0aFRyYWlsaW5nU3dpdGNoID0gQm9vbGVhbih0cmFpbGluZ1N3aXRjaCksXHJcblxyXG4gICAgZWxlbWVudCA9ICdsaScsXHJcbiAgICBjb21wb25lbnQ6IEVsZW1lbnQgPSBlbGVtZW50LFxyXG4gICAgY2xhc3NOYW1lLFxyXG4gICAgY2hpbGRyZW4sXHJcbiAgICAuLi5wcm9wc1xyXG59LCByZWYpID0+IHtcclxuICAgIGNvbnN0IGxpbmVzID0gQm9vbGVhbihvdmVybGluZVRleHQpICsgQm9vbGVhbihwcmltYXJ5VGV4dCkgKyBCb29sZWFuKHNlY29uZGFyeVRleHQpO1xyXG4gICAgY29uc3QgaGFzU3RhcnQgPSBCb29sZWFuKFxyXG4gICAgICAgIHN0YXJ0IHx8IGxlYWRpbmdJY29uIHx8IGxlYWRpbmdJbWFnZSB8fCBsZWFkaW5nQXZhdGFyIHx8IGxlYWRpbmdUaHVtYm5haWwgfHxcclxuICAgICAgICBsZWFkaW5nVmlkZW8gfHwgbGVhZGluZ0NoZWNrYm94IHx8IGxlYWRpbmdSYWRpbyB8fCBsZWFkaW5nU3dpdGNoXHJcbiAgICApO1xyXG4gICAgY29uc3QgaGFzQ29udGVudCA9IEJvb2xlYW4oY29udGVudCB8fCBvdmVybGluZVRleHQgfHwgcHJpbWFyeVRleHQgfHwgc2Vjb25kYXJ5VGV4dCk7XHJcbiAgICBjb25zdCBoYXNFbmQgPSBCb29sZWFuKFxyXG4gICAgICAgIGVuZCB8fCB0cmFpbGluZ01ldGEgfHwgdHJhaWxpbmdJY29uIHx8XHJcbiAgICAgICAgdHJhaWxpbmdDaGVja2JveCB8fCB0cmFpbGluZ1JhZGlvIHx8IHRyYWlsaW5nU3dpdGNoXHJcbiAgICApO1xyXG5cclxuICAgIGNvbnN0IGNsYXNzTmFtZXMgPSBjbGFzc25hbWVzKGNzc0NsYXNzZXMuUk9PVCwge1xyXG4gICAgICAgIFtjc3NDbGFzc2VzLkFDVElWQVRFRF06IGFjdGl2YXRlZCxcclxuICAgICAgICBbY3NzQ2xhc3Nlcy5TRUxFQ1RFRF06IHNlbGVjdGVkLFxyXG4gICAgICAgIFtjc3NDbGFzc2VzLkRJU0FCTEVEXTogZGlzYWJsZWQsXHJcbiAgICAgICAgW2Nzc0NsYXNzZXMuT05FX0xJTkVdOiBvbmVMaW5lIHx8IGxpbmVzID09PSAxLFxyXG4gICAgICAgIFtjc3NDbGFzc2VzLlRXT19MSU5FU106IHR3b0xpbmVzIHx8IGxpbmVzID09PSAyLFxyXG4gICAgICAgIFtjc3NDbGFzc2VzLlRIUkVFX0xJTkVTXTogdGhyZWVMaW5lcyB8fCBsaW5lcyA9PT0gMyxcclxuICAgICAgICBbY3NzQ2xhc3Nlcy5OT05fSU5URVJBQ1RJVkVdOiBub25JbnRlcmFjdGl2ZSxcclxuICAgICAgICBbY3NzQ2xhc3Nlcy5PVkVSTElORV06IG92ZXJsaW5lVGV4dCxcclxuICAgICAgICBbY3NzQ2xhc3Nlcy5MRUFESU5HX0lDT05dOiB3aXRoTGVhZGluZ0ljb24sXHJcbiAgICAgICAgW2Nzc0NsYXNzZXMuTEVBRElOR19JTUFHRV06IHdpdGhMZWFkaW5nSW1hZ2UsXHJcbiAgICAgICAgW2Nzc0NsYXNzZXMuTEVBRElOR19BVkFUQVJdOiB3aXRoTGVhZGluZ0F2YXRhcixcclxuICAgICAgICBbY3NzQ2xhc3Nlcy5MRUFESU5HX1RIVU1CTkFJTF06IHdpdGhMZWFkaW5nVGh1bWJuYWlsLFxyXG4gICAgICAgIFtjc3NDbGFzc2VzLkxFQURJTkdfVklERU9dOiB3aXRoTGVhZGluZ1ZpZGVvLFxyXG4gICAgICAgIFtjc3NDbGFzc2VzLkxFQURJTkdfQ0hFQ0tCT1hdOiB3aXRoTGVhZGluZ0NoZWNrYm94LFxyXG4gICAgICAgIFtjc3NDbGFzc2VzLkxFQURJTkdfUkFESU9dOiB3aXRoTGVhZGluZ1JhZGlvLFxyXG4gICAgICAgIFtjc3NDbGFzc2VzLkxFQURJTkdfU1dJVENIXTogd2l0aExlYWRpbmdTd2l0Y2gsXHJcbiAgICAgICAgW2Nzc0NsYXNzZXMuVFJBSUxJTkdfSUNPTl06IHdpdGhUcmFpbGluZ0ljb24sXHJcbiAgICAgICAgW2Nzc0NsYXNzZXMuVFJBSUxJTkdfTUVUQV06IHdpdGhUcmFpbGluZ01ldGEsXHJcbiAgICAgICAgW2Nzc0NsYXNzZXMuVFJBSUxJTkdfQ0hFQ0tCT1hdOiB3aXRoVHJhaWxpbmdDaGVja2JveCxcclxuICAgICAgICBbY3NzQ2xhc3Nlcy5UUkFJTElOR19SQURJT106IHdpdGhUcmFpbGluZ1JhZGlvLFxyXG4gICAgICAgIFtjc3NDbGFzc2VzLlRSQUlMSU5HX1NXSVRDSF06IHdpdGhUcmFpbGluZ1N3aXRjaFxyXG4gICAgfSwgY2xhc3NOYW1lKTtcclxuXHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAgIDxFbGVtZW50IHJlZj17cmVmfSBjbGFzc05hbWU9e2NsYXNzTmFtZXN9IHsuLi5wcm9wc30+XHJcbiAgICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT17Y3NzQ2xhc3Nlcy5SSVBQTEV9IC8+XHJcblxyXG4gICAgICAgICAgICB7aGFzU3RhcnQgJiZcclxuICAgICAgICAgICAgICAgIDxMaXN0SXRlbVN0YXJ0PlxyXG4gICAgICAgICAgICAgICAgICAgIHtzdGFydH1cclxuICAgICAgICAgICAgICAgICAgICB7bGVhZGluZ0ljb24gJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgPENsb25lXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21wb25lbnQ9e2xlYWRpbmdJY29ufVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmFsbGJhY2s9e0ljb259XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8+XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHtsZWFkaW5nSW1hZ2V9XHJcbiAgICAgICAgICAgICAgICAgICAge2xlYWRpbmdBdmF0YXJ9XHJcbiAgICAgICAgICAgICAgICAgICAge2xlYWRpbmdUaHVtYm5haWx9XHJcbiAgICAgICAgICAgICAgICAgICAge2xlYWRpbmdWaWRlb31cclxuICAgICAgICAgICAgICAgICAgICB7bGVhZGluZ0NoZWNrYm94fVxyXG4gICAgICAgICAgICAgICAgICAgIHtsZWFkaW5nUmFkaW99XHJcbiAgICAgICAgICAgICAgICAgICAge2xlYWRpbmdTd2l0Y2h9XHJcbiAgICAgICAgICAgICAgICA8L0xpc3RJdGVtU3RhcnQ+XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHtoYXNDb250ZW50ICYmXHJcbiAgICAgICAgICAgICAgICA8TGlzdEl0ZW1Db250ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgb3ZlcmxpbmVUZXh0PXtvdmVybGluZVRleHR9XHJcbiAgICAgICAgICAgICAgICAgICAgcHJpbWFyeVRleHQ9e3ByaW1hcnlUZXh0fVxyXG4gICAgICAgICAgICAgICAgICAgIHNlY29uZGFyeVRleHQ9e3NlY29uZGFyeVRleHR9XHJcbiAgICAgICAgICAgICAgICA+XHJcbiAgICAgICAgICAgICAgICAgICAge2NvbnRlbnR9XHJcbiAgICAgICAgICAgICAgICA8L0xpc3RJdGVtQ29udGVudD5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAge2hhc0VuZCAmJlxyXG4gICAgICAgICAgICAgICAgPExpc3RJdGVtRW5kPlxyXG4gICAgICAgICAgICAgICAgICAgIHtlbmR9XHJcbiAgICAgICAgICAgICAgICAgICAge3RyYWlsaW5nTWV0YX1cclxuICAgICAgICAgICAgICAgICAgICB7dHJhaWxpbmdJY29uICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxDbG9uZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50PXt0cmFpbGluZ0ljb259XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmYWxsYmFjaz17SWNvbn1cclxuICAgICAgICAgICAgICAgICAgICAgICAgLz5cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAge3RyYWlsaW5nQ2hlY2tib3h9XHJcbiAgICAgICAgICAgICAgICAgICAge3RyYWlsaW5nUmFkaW99XHJcbiAgICAgICAgICAgICAgICAgICAge3RyYWlsaW5nU3dpdGNofVxyXG4gICAgICAgICAgICAgICAgPC9MaXN0SXRlbUVuZD5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAge2NoaWxkcmVufVxyXG4gICAgICAgIDwvRWxlbWVudD5cclxuICAgICk7XHJcbn0pO1xyXG5cclxuTGlzdEl0ZW0uZGlzcGxheU5hbWUgPSAnTURDTGlzdEl0ZW0nO1xyXG5cclxuTGlzdEl0ZW0ucHJvcFR5cGVzID0ge1xyXG4gICAgc3RhcnQ6IFByb3BUeXBlcy5ub2RlLFxyXG4gICAgY29udGVudDogUHJvcFR5cGVzLm5vZGUsXHJcbiAgICBlbmQ6IFByb3BUeXBlcy5ub2RlLFxyXG4gICAgdGV4dDogUHJvcFR5cGVzLm5vZGUsXHJcbiAgICBvdmVybGluZVRleHQ6IFByb3BUeXBlcy5ub2RlLFxyXG4gICAgcHJpbWFyeVRleHQ6IFByb3BUeXBlcy5ub2RlLFxyXG4gICAgc2Vjb25kYXJ5VGV4dDogUHJvcFR5cGVzLm5vZGUsXHJcbiAgICBpY29uOiBQcm9wVHlwZXMubm9kZSxcclxuICAgIGltYWdlOiBQcm9wVHlwZXMuZWxlbWVudCxcclxuICAgIHRodW1ibmFpbDogUHJvcFR5cGVzLmVsZW1lbnQsXHJcbiAgICB2aWRlbzogUHJvcFR5cGVzLmVsZW1lbnQsXHJcbiAgICBsZWFkaW5nSWNvbjogUHJvcFR5cGVzLm5vZGUsXHJcbiAgICBsZWFkaW5nSW1hZ2U6IFByb3BUeXBlcy5lbGVtZW50LFxyXG4gICAgbGVhZGluZ1RodW1ibmFpbDogUHJvcFR5cGVzLmVsZW1lbnQsXHJcbiAgICBsZWFkaW5nVmlkZW86IFByb3BUeXBlcy5lbGVtZW50LFxyXG4gICAgbGVhZGluZ0NoZWNrYm94OiBQcm9wVHlwZXMuZWxlbWVudCxcclxuICAgIGxlYWRpbmdSYWRpbzogUHJvcFR5cGVzLmVsZW1lbnQsXHJcbiAgICBsZWFkaW5nU3dpdGNoOiBQcm9wVHlwZXMuZWxlbWVudCxcclxuICAgIG1ldGE6IFByb3BUeXBlcy5ub2RlLFxyXG4gICAgdHJhaWxpbmdNZXRhOiBQcm9wVHlwZXMubm9kZSxcclxuICAgIHRyYWlsaW5nSWNvbjogUHJvcFR5cGVzLm5vZGUsXHJcbiAgICB0cmFpbGluZ0NoZWNrYm94OiBQcm9wVHlwZXMuZWxlbWVudCxcclxuICAgIHRyYWlsaW5nUmFkaW86IFByb3BUeXBlcy5lbGVtZW50LFxyXG4gICAgdHJhaWxpbmdTd2l0Y2g6IFByb3BUeXBlcy5lbGVtZW50LFxyXG4gICAgYWN0aXZhdGVkOiBQcm9wVHlwZXMuYm9vbCxcclxuICAgIHNlbGVjdGVkOiBQcm9wVHlwZXMuYm9vbCxcclxuICAgIGRpc2FibGVkOiBQcm9wVHlwZXMuYm9vbCxcclxuICAgIG5vbkludGVyYWN0aXZlOiBQcm9wVHlwZXMuYm9vbCxcclxuICAgIHdpdGhMZWFkaW5nSWNvbjogUHJvcFR5cGVzLmJvb2wsXHJcbiAgICB3aXRoTGVhZGluZ0ltYWdlOiBQcm9wVHlwZXMuYm9vbCxcclxuICAgIHdpdGhMZWFkaW5nVGh1bWJuYWlsOiBQcm9wVHlwZXMuYm9vbCxcclxuICAgIHdpdGhMZWFkaW5nVmlkZW86IFByb3BUeXBlcy5ib29sLFxyXG4gICAgd2l0aExlYWRpbmdDaGVja2JveDogUHJvcFR5cGVzLmJvb2wsXHJcbiAgICB3aXRoTGVhZGluZ1JhZGlvOiBQcm9wVHlwZXMuYm9vbCxcclxuICAgIHdpdGhMZWFkaW5nU3dpdGNoOiBQcm9wVHlwZXMuYm9vbCxcclxuICAgIHdpdGhUcmFpbGluZ01ldGE6IFByb3BUeXBlcy5ib29sLFxyXG4gICAgd2l0aFRyYWlsaW5nSWNvbjogUHJvcFR5cGVzLmJvb2wsXHJcbiAgICB3aXRoVHJhaWxpbmdDaGVja2JveDogUHJvcFR5cGVzLmJvb2wsXHJcbiAgICB3aXRoVHJhaWxpbmdSYWRpbzogUHJvcFR5cGVzLmJvb2wsXHJcbiAgICB3aXRoVHJhaWxpbmdTd2l0Y2g6IFByb3BUeXBlcy5ib29sXHJcbn07XHJcblxyXG5leHBvcnQgZGVmYXVsdCBMaXN0SXRlbTsiLCJpbXBvcnQgeyBmb3J3YXJkUmVmIH0gZnJvbSAncmVhY3QnO1xyXG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xyXG5pbXBvcnQgY2xhc3NuYW1lcyBmcm9tICdjbGFzc25hbWVzJztcclxuXHJcbmltcG9ydCB7IGNyZWF0ZSB9IGZyb20gJy4uL2NvbXBvbmVudCc7XHJcblxyXG5pbXBvcnQgeyBsaXN0Q3NzQ2xhc3NlcyBhcyBjc3NDbGFzc2VzIH0gZnJvbSAnLi9jb25zdGFudHMnO1xyXG5pbXBvcnQgTGlzdEl0ZW0gZnJvbSAnLi9MaXN0SXRlbSc7XHJcblxyXG5jb25zdCBMaXN0ID0gZm9yd2FyZFJlZigoe1xyXG4gICAgaXRlbXMsXHJcblxyXG4gICAgZWxlbWVudDogRWxlbWVudCA9ICd1bCcsXHJcbiAgICBjbGFzc05hbWUsXHJcbiAgICBjaGlsZHJlbiA9IGl0ZW1zPy5tYXAoaXRlbSA9PiBjcmVhdGUoTGlzdEl0ZW0sIGl0ZW0pKSxcclxuICAgIC4uLnByb3BzXHJcbn0sIHJlZikgPT4ge1xyXG4gICAgY29uc3QgY2xhc3NOYW1lcyA9IGNsYXNzbmFtZXMoY3NzQ2xhc3Nlcy5ST09ULCBjbGFzc05hbWUpO1xyXG5cclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgPEVsZW1lbnQgcmVmPXtyZWZ9IGNsYXNzTmFtZT17Y2xhc3NOYW1lc30gey4uLnByb3BzfT5cclxuICAgICAgICAgICAge2NoaWxkcmVufVxyXG4gICAgICAgIDwvRWxlbWVudD5cclxuICAgICk7XHJcbn0pO1xyXG5cclxuTGlzdC5kaXNwbGF5TmFtZSA9ICdNRENMaXN0JztcclxuXHJcbkxpc3RJdGVtLnByb3BUeXBlcyA9IHtcclxuICAgIGl0ZW1zOiBQcm9wVHlwZXMuYXJyYXlcclxufTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IExpc3Q7IiwiaW1wb3J0IHsgZm9yd2FyZFJlZiB9IGZyb20gJ3JlYWN0JztcclxuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcclxuaW1wb3J0IGNsYXNzbmFtZXMgZnJvbSAnY2xhc3NuYW1lcyc7XHJcblxyXG5pbXBvcnQgeyBsaXN0RGl2aWRlckNzc0NsYXNzZXMgYXMgY3NzQ2xhc3NlcyB9IGZyb20gJy4vY29uc3RhbnRzJztcclxuXHJcbmNvbnN0IExpc3REaXZpZGVyID0gZm9yd2FyZFJlZigoe1xyXG4gICAgd2l0aExlYWRpbmdUZXh0ID0gZmFsc2UsXHJcbiAgICB3aXRoTGVhZGluZ0ljb24gPSBmYWxzZSxcclxuICAgIHdpdGhMZWFkaW5nSW1hZ2UgPSBmYWxzZSxcclxuICAgIHdpdGhMZWFkaW5nVGh1bWJuYWlsID0gZmFsc2UsXHJcbiAgICB3aXRoTGVhZGluZ1ZpZGVvID0gZmFsc2UsXHJcbiAgICB3aXRoTGVhZGluZ0NoZWNrYm94ID0gZmFsc2UsXHJcbiAgICB3aXRoTGVhZGluZ1JhZGlvID0gZmFsc2UsXHJcbiAgICB3aXRoTGVhZGluZ1N3aXRjaCA9IGZhbHNlLFxyXG5cclxuICAgIGVsZW1lbnQ6IEVsZW1lbnQgPSAnbGknLFxyXG4gICAgY2xhc3NOYW1lLFxyXG4gICAgLi4ucHJvcHNcclxufSwgcmVmKSA9PiB7XHJcbiAgICBjb25zdCBjbGFzc05hbWVzID0gY2xhc3NuYW1lcyhjc3NDbGFzc2VzLlJPT1QsIHtcclxuICAgICAgICBbY3NzQ2xhc3Nlcy5MRUFESU5HX1RFWFRdOiB3aXRoTGVhZGluZ1RleHQsXHJcbiAgICAgICAgW2Nzc0NsYXNzZXMuTEVBRElOR19JQ09OXTogd2l0aExlYWRpbmdJY29uLFxyXG4gICAgICAgIFtjc3NDbGFzc2VzLkxFQURJTkdfSU1BR0VdOiB3aXRoTGVhZGluZ0ltYWdlLFxyXG4gICAgICAgIFtjc3NDbGFzc2VzLkxFQURJTkdfVEhVTUJOQUlMXTogd2l0aExlYWRpbmdUaHVtYm5haWwsXHJcbiAgICAgICAgW2Nzc0NsYXNzZXMuTEVBRElOR19WSURFT106IHdpdGhMZWFkaW5nVmlkZW8sXHJcbiAgICAgICAgW2Nzc0NsYXNzZXMuTEVBRElOR19DSEVDS0JPWF06IHdpdGhMZWFkaW5nQ2hlY2tib3gsXHJcbiAgICAgICAgW2Nzc0NsYXNzZXMuTEVBRElOR19SQURJT106IHdpdGhMZWFkaW5nUmFkaW8sXHJcbiAgICAgICAgW2Nzc0NsYXNzZXMuTEVBRElOR19TV0lUQ0hdOiB3aXRoTGVhZGluZ1N3aXRjaFxyXG4gICAgfSwgY2xhc3NOYW1lKTtcclxuXHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAgIDxFbGVtZW50XHJcbiAgICAgICAgICAgIHJlZj17cmVmfVxyXG4gICAgICAgICAgICBjbGFzc05hbWU9e2NsYXNzTmFtZXN9XHJcbiAgICAgICAgICAgIHJvbGU9e0VsZW1lbnQgPT09ICdsaScgPyAnc2VwYXJhdG9yJyA6IHVuZGVmaW5lZH1cclxuICAgICAgICAgICAgey4uLnByb3BzfVxyXG4gICAgICAgIC8+XHJcbiAgICApO1xyXG59KTtcclxuXHJcbkxpc3REaXZpZGVyLmRpc3BsYXlOYW1lID0gJ01EQ0xpc3REaXZpZGVyJztcclxuXHJcbkxpc3REaXZpZGVyLnByb3BUeXBlcyA9IHtcclxuICAgIHdpdGhMZWFkaW5nVGV4dDogUHJvcFR5cGVzLmJvb2wsXHJcbiAgICB3aXRoTGVhZGluZ0ljb246IFByb3BUeXBlcy5ib29sLFxyXG4gICAgd2l0aExlYWRpbmdJbWFnZTogUHJvcFR5cGVzLmJvb2wsXHJcbiAgICB3aXRoTGVhZGluZ1RodW1ibmFpbDogUHJvcFR5cGVzLmJvb2wsXHJcbiAgICB3aXRoTGVhZGluZ1ZpZGVvOiBQcm9wVHlwZXMuYm9vbCxcclxuICAgIHdpdGhMZWFkaW5nQXZhdGFyOiBQcm9wVHlwZXMuYm9vbCxcclxuICAgIHdpdGhMZWFkaW5nQ2hlY2tib3g6IFByb3BUeXBlcy5ib29sLFxyXG4gICAgd2l0aExlYWRpbmdTd2l0Y2g6IFByb3BUeXBlcy5ib29sLFxyXG4gICAgd2l0aExlYWRpbmdSYWRpbzogUHJvcFR5cGVzLmJvb2xcclxufTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IExpc3REaXZpZGVyOyIsImltcG9ydCB7IGZvcndhcmRSZWYgfSBmcm9tICdyZWFjdCc7XHJcbmltcG9ydCBjbGFzc25hbWVzIGZyb20gJ2NsYXNzbmFtZXMnO1xyXG5cclxuaW1wb3J0IHsgbGlzdEdyb3VwQ3NzQ2xhc3NlcyBhcyBjc3NDbGFzc2VzIH0gZnJvbSAnLi9jb25zdGFudHMnO1xyXG5cclxuY29uc3QgTGlzdEdyb3VwID0gZm9yd2FyZFJlZigoe1xyXG4gICAgZWxlbWVudDogRWxlbWVudCA9ICdkaXYnLFxyXG4gICAgY2xhc3NOYW1lLFxyXG4gICAgLi4ucHJvcHNcclxufSwgcmVmKSA9PiB7XHJcbiAgICBjb25zdCBjbGFzc05hbWVzID0gY2xhc3NuYW1lcyhjc3NDbGFzc2VzLlJPT1QsIGNsYXNzTmFtZSk7XHJcblxyXG4gICAgcmV0dXJuIChcclxuICAgICAgICA8RWxlbWVudCByZWY9e3JlZn0gY2xhc3NOYW1lPXtjbGFzc05hbWVzfSB7Li4ucHJvcHN9IC8+XHJcbiAgICApO1xyXG59KTtcclxuXHJcbkxpc3RHcm91cC5kaXNwbGF5TmFtZSA9ICdNRENMaXN0R3JvdXAnO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgTGlzdEdyb3VwOyIsImltcG9ydCB7IGZvcndhcmRSZWYgfSBmcm9tICdyZWFjdCc7XHJcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XHJcbmltcG9ydCBjbGFzc25hbWVzIGZyb20gJ2NsYXNzbmFtZXMnO1xyXG5cclxuaW1wb3J0IHsgbGlzdEdyb3VwQ3NzQ2xhc3NlcyBhcyBjc3NDbGFzc2VzIH0gZnJvbSAnLi9jb25zdGFudHMnO1xyXG5cclxuY29uc3QgTGlzdEdyb3VwU3ViaGVhZGVyID0gZm9yd2FyZFJlZigoe1xyXG4gICAgdGl0bGUsXHJcblxyXG4gICAgZWxlbWVudDogRWxlbWVudCA9ICdoMycsXHJcbiAgICBjbGFzc05hbWUsXHJcbiAgICBjaGlsZHJlbiA9IHRpdGxlLFxyXG4gICAgLi4ucHJvcHNcclxufSwgcmVmKSA9PiB7XHJcbiAgICBjb25zdCBjbGFzc05hbWVzID0gY2xhc3NuYW1lcyhjc3NDbGFzc2VzLlNVQkhFQURFUiwgY2xhc3NOYW1lKTtcclxuXHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAgIDxFbGVtZW50IHJlZj17cmVmfSBjbGFzc05hbWU9e2NsYXNzTmFtZXN9IHsuLi5wcm9wc30+e2NoaWxkcmVufTwvRWxlbWVudD5cclxuICAgICk7XHJcbn0pO1xyXG5cclxuTGlzdEdyb3VwU3ViaGVhZGVyLmRpc3BsYXlOYW1lID0gJ01EQ0xpc3RHcm91cFN1YmhlYWRlcic7XHJcblxyXG5MaXN0R3JvdXBTdWJoZWFkZXIucHJvcFR5cGVzID0ge1xyXG4gICAgdGl0bGU6IFByb3BUeXBlcy5zdHJpbmdcclxufTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IExpc3RHcm91cFN1YmhlYWRlcjsiLCJpbXBvcnQgTGlzdCBmcm9tICcuL0xpc3QnO1xyXG5pbXBvcnQgTGlzdERpdmlkZXIgZnJvbSAnLi9MaXN0RGl2aWRlcic7XHJcbmltcG9ydCBMaXN0R3JvdXAgZnJvbSAnLi9MaXN0R3JvdXAnO1xyXG5pbXBvcnQgTGlzdEdyb3VwU3ViaGVhZGVyIGZyb20gJy4vTGlzdEdyb3VwU3ViaGVhZGVyJztcclxuaW1wb3J0IExpc3RJdGVtIGZyb20gJy4vTGlzdEl0ZW0nO1xyXG5pbXBvcnQgTGlzdEl0ZW1Db250ZW50IGZyb20gJy4vTGlzdEl0ZW1Db250ZW50JztcclxuaW1wb3J0IExpc3RJdGVtRW5kIGZyb20gJy4vTGlzdEl0ZW1FbmQnO1xyXG5pbXBvcnQgTGlzdEl0ZW1TdGFydCBmcm9tICcuL0xpc3RJdGVtU3RhcnQnO1xyXG5cclxuTGlzdC5JdGVtID0gTGlzdEl0ZW07XHJcbkxpc3QuRGl2aWRlciA9IExpc3REaXZpZGVyO1xyXG5MaXN0Lkdyb3VwID0gTGlzdEdyb3VwO1xyXG5MaXN0R3JvdXAuU3ViaGVhZGVyID0gTGlzdEdyb3VwU3ViaGVhZGVyO1xyXG5MaXN0SXRlbS5Db250ZW50ID0gTGlzdEl0ZW1Db250ZW50O1xyXG5MaXN0SXRlbS5FbmQgPSBMaXN0SXRlbUVuZDtcclxuTGlzdEl0ZW0uU3RhcnQgPSBMaXN0SXRlbVN0YXJ0O1xyXG5cclxuZXhwb3J0IHtcclxuICAgIExpc3QgYXMgZGVmYXVsdCxcclxuICAgIExpc3REaXZpZGVyLFxyXG4gICAgTGlzdEdyb3VwLFxyXG4gICAgTGlzdEdyb3VwU3ViaGVhZGVyLFxyXG4gICAgTGlzdEl0ZW0sXHJcbiAgICBMaXN0SXRlbVN0YXJ0LFxyXG4gICAgTGlzdEl0ZW1FbmQsXHJcbiAgICBMaXN0SXRlbUNvbnRlbnRcclxufTsiLCJpbXBvcnQgeyBmb3J3YXJkUmVmIH0gZnJvbSAncmVhY3QnO1xyXG5pbXBvcnQgY2xhc3NuYW1lcyBmcm9tICdjbGFzc25hbWVzJztcclxuXHJcbmltcG9ydCB7IExpc3RJdGVtIH0gZnJvbSAnLi4vbGlzdCc7XHJcbmltcG9ydCB7IGNzc0NsYXNzZXMgfSBmcm9tICcuL2NvbnN0YW50cyc7XHJcblxyXG5jb25zdCBNZW51SXRlbSA9IGZvcndhcmRSZWYoKHtcclxuICAgIHNlbGVjdGVkID0gZmFsc2UsXHJcbiAgICBkaXNhYmxlZCA9IGZhbHNlLFxyXG5cclxuICAgIGNsYXNzTmFtZSxcclxuICAgIC4uLnByb3BzXHJcbn0sIHJlZikgPT4ge1xyXG4gICAgY29uc3QgY2xhc3NOYW1lcyA9IGNsYXNzbmFtZXMoY3NzQ2xhc3Nlcy5JVEVNLCB7XHJcbiAgICAgICAgW2Nzc0NsYXNzZXMuSVRFTV9TRUxFQ1RFRF06IHNlbGVjdGVkXHJcbiAgICB9LCBjbGFzc05hbWUpO1xyXG5cclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgPExpc3RJdGVtXHJcbiAgICAgICAgICAgIHJlZj17cmVmfVxyXG4gICAgICAgICAgICByb2xlPVwibWVudWl0ZW1cIlxyXG4gICAgICAgICAgICBjbGFzc05hbWU9e2NsYXNzTmFtZXN9XHJcbiAgICAgICAgICAgIHNlbGVjdGVkPXtzZWxlY3RlZH1cclxuICAgICAgICAgICAgZGlzYWJsZWQ9e2Rpc2FibGVkfVxyXG4gICAgICAgICAgICBkYXRhLWRpc2FibGVkPXtkaXNhYmxlZCB8fCB1bmRlZmluZWR9XHJcbiAgICAgICAgICAgIHRhYkluZGV4PXtkaXNhYmxlZCA/ICctMScgOiB1bmRlZmluZWR9XHJcbiAgICAgICAgICAgIHsuLi5wcm9wc31cclxuICAgICAgICAvPlxyXG4gICAgKTtcclxufSk7XHJcblxyXG5NZW51SXRlbS5kaXNwbGF5TmFtZSA9ICdNRENNZW51SXRlbSc7XHJcblxyXG5NZW51SXRlbS5wcm9wVHlwZXMgPSB7XHJcbiAgICAuLi5MaXN0SXRlbS5wcm9wVHlwZXNcclxufTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IE1lbnVJdGVtOyIsImV4cG9ydCBjb25zdCBjc3NDbGFzc2VzID0ge1xyXG4gICAgUk9PVDogJ21kYy1tb2RhbCcsXHJcbiAgICBGSVhFRDogJ21kYy1tb2RhbC0tZml4ZWQnXHJcbn07IiwiaW1wb3J0IHsgdXNlUmVmLCB1c2VFZmZlY3QgfSBmcm9tICdyZWFjdCc7XHJcbmltcG9ydCB7IGNyZWF0ZVBvcnRhbCB9IGZyb20gJ3JlYWN0LWRvbSc7XHJcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XHJcblxyXG5pbXBvcnQgeyBjc3NDbGFzc2VzIH0gZnJvbSAnLi9jb25zdGFudHMnO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gTW9kYWwoe1xyXG4gICAgZml4ZWQgPSBmYWxzZSxcclxuICAgIGVsZW1lbnQgPSAnZGl2JyxcclxuICAgIGNoaWxkcmVuXHJcbn0pIHtcclxuICAgIGNvbnN0IHJvb3RSZWYgPSB1c2VSZWYoZG9jdW1lbnQuY3JlYXRlRWxlbWVudChlbGVtZW50KSk7XHJcblxyXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgICAgICBjb25zdCByb290ID0gcm9vdFJlZi5jdXJyZW50O1xyXG4gICAgICAgIGNvbnN0IGFjdGl2ZUVsZW1lbnQgPSBkb2N1bWVudC5hY3RpdmVFbGVtZW50O1xyXG5cclxuICAgICAgICByb290LmNsYXNzTmFtZSA9IGNzc0NsYXNzZXMuUk9PVDtcclxuXHJcbiAgICAgICAgaWYgKGZpeGVkKSB7XHJcbiAgICAgICAgICAgIHJvb3QuY2xhc3NMaXN0LmFkZChjc3NDbGFzc2VzLkZJWEVEKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQocm9vdCk7XHJcbiAgICAgICAgcm9vdC5maXJzdENoaWxkLmZvY3VzKCk7XHJcblxyXG4gICAgICAgIHJldHVybiAoKSA9PiB7XHJcbiAgICAgICAgICAgIGFjdGl2ZUVsZW1lbnQuZm9jdXMoKTtcclxuICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChyb290KTtcclxuICAgICAgICB9O1xyXG4gICAgfSwgW2ZpeGVkXSk7XHJcblxyXG4gICAgcmV0dXJuIGNyZWF0ZVBvcnRhbChjaGlsZHJlbiwgcm9vdFJlZi5jdXJyZW50KTtcclxufVxyXG5cclxuTW9kYWwuZGlzcGxheU5hbWUgPSAnTURDTW9kYWwnO1xyXG5cclxuTW9kYWwucHJvcFR5cGVzID0ge1xyXG4gICAgZml4ZWQ6IFByb3BUeXBlcy5ib29sLFxyXG4gICAgZWxlbWVudDogUHJvcFR5cGVzLnN0cmluZyxcclxuICAgIGNoaWxkcmVuOiBQcm9wVHlwZXMubm9kZS5pc1JlcXVpcmVkXHJcbn07IiwiZXhwb3J0IHsgZGVmYXVsdCB9IGZyb20gJy4vTW9kYWwnOyIsImltcG9ydCB7IENTU1RyYW5zaXRpb24gfSBmcm9tICdyZWFjdC10cmFuc2l0aW9uLWdyb3VwJztcclxuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcclxuXHJcbmltcG9ydCBNb2RhbCBmcm9tICcuLi9tb2RhbCc7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBMYXllcih7XHJcbiAgICBtb2RhbCA9IGZhbHNlLFxyXG4gICAgZml4ZWQgPSBmYWxzZSxcclxuXHJcbiAgICBjaGlsZHJlbixcclxuICAgIC4uLnByb3BzXHJcbn0pIHtcclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgPENTU1RyYW5zaXRpb24gey4uLnByb3BzfT5cclxuICAgICAgICAgICAge21vZGFsID9cclxuICAgICAgICAgICAgICAgIDxNb2RhbCBmaXhlZD17Zml4ZWR9PlxyXG4gICAgICAgICAgICAgICAgICAgIHtjaGlsZHJlbn1cclxuICAgICAgICAgICAgICAgIDwvTW9kYWw+XHJcbiAgICAgICAgICAgICAgICA6XHJcbiAgICAgICAgICAgICAgICBjaGlsZHJlblxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgPC9DU1NUcmFuc2l0aW9uPlxyXG4gICAgKTtcclxufVxyXG5cclxuTGF5ZXIuZGlzcGxheU5hbWUgPSAnTURDTGF5ZXInO1xyXG5cclxuTGF5ZXIucHJvcFR5cGVzID0ge1xyXG4gICAgbW9kYWw6IFByb3BUeXBlcy5ib29sLFxyXG4gICAgZml4ZWQ6IFByb3BUeXBlcy5ib29sXHJcbn07IiwiZXhwb3J0IHsgZGVmYXVsdCB9IGZyb20gJy4vTGF5ZXInOyIsImNvbnN0IGRlZmF1bHRWYWx1ZXMgPSB7XHJcbiAgICB0b3A6IGZhbHNlLFxyXG4gICAgYm90dG9tOiBmYWxzZSxcclxuICAgIGNlbnRlcjogZmFsc2UsXHJcbiAgICBsZWZ0OiBmYWxzZSxcclxuICAgIHJpZ2h0OiBmYWxzZVxyXG59O1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGdldEFuY2hvck9yaWdpbihhbmNob3JPcmlnaW4gPSAnJykge1xyXG4gICAgaWYgKHR5cGVvZiBhbmNob3JPcmlnaW4gPT09ICdvYmplY3QnKSB7XHJcbiAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIGRlZmF1bHRWYWx1ZXMsIGFuY2hvck9yaWdpbik7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3Qga2V5cyA9IGFuY2hvck9yaWdpbi5zcGxpdCgnICcpO1xyXG5cclxuICAgIGNvbnN0IHZhbHVlcyA9IGtleXMucmVkdWNlKChyZXN1bHQsIGtleSkgPT4ge1xyXG4gICAgICAgIHJlc3VsdFtrZXldID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH0sIHt9KTtcclxuXHJcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgZGVmYXVsdFZhbHVlcywgdmFsdWVzKTtcclxufSIsImltcG9ydCB7IGZvcndhcmRSZWYsIHVzZVJlZiwgdXNlSW1wZXJhdGl2ZUhhbmRsZSwgdXNlQ2FsbGJhY2ssIHVzZUVmZmVjdCB9IGZyb20gJ3JlYWN0JztcclxuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcclxuaW1wb3J0IGNsYXNzbmFtZXMgZnJvbSAnY2xhc3NuYW1lcyc7XHJcblxyXG5pbXBvcnQgeyB1c2VVcGRhdGVkIH0gZnJvbSAnLi4vaG9va3MnO1xyXG5pbXBvcnQgeyBjbG9uZSB9IGZyb20gJy4uL2NvbXBvbmVudCc7XHJcbmltcG9ydCBMYXllciBmcm9tICcuLi9sYXllcic7XHJcblxyXG5pbXBvcnQgeyBudW1iZXJzLCBjc3NDbGFzc2VzLCBPcmlnaW4gfSBmcm9tICcuL2NvbnN0YW50cyc7XHJcbmltcG9ydCB7IGdldEFuY2hvck9yaWdpbiB9IGZyb20gJy4vdXRpbHMnO1xyXG5cclxuY29uc3QgTWVudVN1cmZhY2UgPSBmb3J3YXJkUmVmKCh7XHJcbiAgICBhbmNob3IsXHJcbiAgICBhbmNob3JSZWY6IF9hbmNob3JSZWYsXHJcbiAgICBhbmNob3JPcmlnaW46IF9hbmNob3JPcmlnaW4gPSBPcmlnaW4uVE9QX0xFRlQsXHJcbiAgICB0cmFuc2Zvcm1PcmlnaW46IF90cmFuc2Zvcm1PcmlnaW4gPSBfYW5jaG9yT3JpZ2luLFxyXG4gICAgb3BlbiA9IGZhbHNlLFxyXG4gICAgbW9kYWwgPSBmYWxzZSxcclxuICAgIHF1aWNrID0gZmFsc2UsXHJcbiAgICBmaXhlZCA9IGZhbHNlLFxyXG4gICAgcGVyc2lzdGVudCA9IGZhbHNlLFxyXG4gICAgZnVsbFdpZHRoID0gZmFsc2UsXHJcbiAgICBvbkNsb3NlID0gRnVuY3Rpb24ucHJvdG90eXBlLFxyXG4gICAgb25LZXlEb3duID0gRnVuY3Rpb24ucHJvdG90eXBlLFxyXG5cclxuICAgIGNsYXNzTmFtZSxcclxuICAgIC4uLnByb3BzXHJcbn0sIHJlZikgPT4ge1xyXG4gICAgY29uc3Qgcm9vdFJlZiA9IHVzZVJlZigpO1xyXG4gICAgY29uc3QgYW5jaG9yUmVmID0gdXNlUmVmKF9hbmNob3JSZWY/LmN1cnJlbnQpO1xyXG5cclxuICAgIHVzZUltcGVyYXRpdmVIYW5kbGUocmVmLCAoKSA9PiByb290UmVmLmN1cnJlbnQpO1xyXG5cclxuICAgIHVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICAgICAgaWYgKCFfYW5jaG9yUmVmKSByZXR1cm47XHJcblxyXG4gICAgICAgIGFuY2hvclJlZi5jdXJyZW50ID0gX2FuY2hvclJlZi5jdXJyZW50O1xyXG4gICAgfSwgW19hbmNob3JSZWZdKTtcclxuXHJcbiAgICB1c2VVcGRhdGVkKCgpID0+IHtcclxuICAgICAgICBpZiAoIW9wZW4gfHwgcGVyc2lzdGVudCkgcmV0dXJuO1xyXG5cclxuICAgICAgICBmdW5jdGlvbiBoYW5kbGVCb2R5Q2xpY2soZXZlbnQpIHtcclxuICAgICAgICAgICAgb25DbG9zZShldmVudCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBkb2N1bWVudC5ib2R5LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgaGFuZGxlQm9keUNsaWNrLCB0cnVlKTtcclxuXHJcbiAgICAgICAgcmV0dXJuICgpID0+IHtcclxuICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIGhhbmRsZUJvZHlDbGljaywgdHJ1ZSk7XHJcbiAgICAgICAgfTtcclxuICAgIH0sIFtvcGVuLCBwZXJzaXN0ZW50LCBvbkNsb3NlXSk7XHJcblxyXG4gICAgdXNlVXBkYXRlZCgoKSA9PiB7XHJcbiAgICAgICAgaWYgKCFvcGVuIHx8ICFyb290UmVmLmN1cnJlbnQgfHwgIWFuY2hvclJlZi5jdXJyZW50KSByZXR1cm47XHJcblxyXG4gICAgICAgIGNvbnN0IGFuY2hvciA9IGFuY2hvclJlZi5jdXJyZW50O1xyXG4gICAgICAgIGNvbnN0IHsgY2xpZW50V2lkdGg6IHdpZHRoLCBjbGllbnRIZWlnaHQ6IGhlaWdodCB9ID0gcm9vdFJlZi5jdXJyZW50O1xyXG4gICAgICAgIGNvbnN0IGFuY2hvckNsaWVudFJlY3QgPSBhbmNob3IuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XHJcbiAgICAgICAgY29uc3QgYW5jaG9yRGltZW5zaW9ucyA9IG1vZGFsID8gYW5jaG9yQ2xpZW50UmVjdCA6IHtcclxuICAgICAgICAgICAgdG9wOiBhbmNob3Iub2Zmc2V0VG9wLFxyXG4gICAgICAgICAgICBsZWZ0OiBhbmNob3Iub2Zmc2V0TGVmdCxcclxuICAgICAgICAgICAgYm90dG9tOiBhbmNob3Iub2Zmc2V0VG9wICsgYW5jaG9yLm9mZnNldEhlaWdodCxcclxuICAgICAgICAgICAgcmlnaHQ6IGFuY2hvci5vZmZzZXRMZWZ0ICsgYW5jaG9yLm9mZnNldFdpZHRoLFxyXG4gICAgICAgICAgICB3aWR0aDogYW5jaG9yLm9mZnNldFdpZHRoLFxyXG4gICAgICAgICAgICBoZWlnaHQ6IGFuY2hvci5vZmZzZXRIZWlnaHRcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBjb25zdCBzdHlsZSA9IHtcclxuICAgICAgICAgICAgdG9wOiBhbmNob3JEaW1lbnNpb25zLnRvcCxcclxuICAgICAgICAgICAgbGVmdDogYW5jaG9yRGltZW5zaW9ucy5sZWZ0LFxyXG4gICAgICAgICAgICB3aWR0aDogZnVsbFdpZHRoID8gJzEwMCUnIDogdW5kZWZpbmVkLFxyXG4gICAgICAgICAgICBtYXhXaWR0aDogZnVsbFdpZHRoID8gYCR7YW5jaG9yRGltZW5zaW9ucy53aWR0aH1weGAgOiB1bmRlZmluZWQsXHJcbiAgICAgICAgICAgIHBvc2l0aW9uOiBmaXhlZCA/ICdmaXhlZCcgOiAnYWJzb2x1dGUnLFxyXG4gICAgICAgICAgICB0cmFuc2Zvcm1PcmlnaW46IF90cmFuc2Zvcm1PcmlnaW5cclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBjb25zdCBzY3JvbGxZID0gKG1vZGFsICYmICFmaXhlZCkgPyB3aW5kb3cuc2Nyb2xsWSA6IDA7XHJcbiAgICAgICAgY29uc3Qgc2Nyb2xsWCA9IChtb2RhbCAmJiAhZml4ZWQpID8gd2luZG93LnNjcm9sbFggOiAwO1xyXG5cclxuICAgICAgICBjb25zdCBhbmNob3JPcmlnaW4gPSBnZXRBbmNob3JPcmlnaW4oX2FuY2hvck9yaWdpbik7XHJcbiAgICAgICAgY29uc3QgdHJhbnNmb3JtT3JpZ2luID0gZ2V0QW5jaG9yT3JpZ2luKF90cmFuc2Zvcm1PcmlnaW4pO1xyXG5cclxuICAgICAgICBpZiAoYW5jaG9yT3JpZ2luLnRvcCkge1xyXG4gICAgICAgICAgICBzdHlsZS50b3AgPSBhbmNob3JEaW1lbnNpb25zLnRvcDtcclxuICAgICAgICB9IGVsc2UgaWYgKGFuY2hvck9yaWdpbi5ib3R0b20pIHtcclxuICAgICAgICAgICAgc3R5bGUudG9wID0gYW5jaG9yRGltZW5zaW9ucy5ib3R0b207XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoYW5jaG9yT3JpZ2luLmxlZnQpIHtcclxuICAgICAgICAgICAgc3R5bGUubGVmdCA9IGFuY2hvckRpbWVuc2lvbnMubGVmdDtcclxuICAgICAgICB9IGVsc2UgaWYgKGFuY2hvck9yaWdpbi5yaWdodCkge1xyXG4gICAgICAgICAgICBzdHlsZS5sZWZ0ID0gYW5jaG9yRGltZW5zaW9ucy5yaWdodDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICh0cmFuc2Zvcm1PcmlnaW4udG9wKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHRvcCA9IHNjcm9sbFkgKyBzdHlsZS50b3A7XHJcbiAgICAgICAgICAgIGNvbnN0IGJvdHRvbU92ZXJmbG93ID0gc2Nyb2xsWSArIChhbmNob3JPcmlnaW4uYm90dG9tID8gYW5jaG9yQ2xpZW50UmVjdC5ib3R0b20gOiBhbmNob3JDbGllbnRSZWN0LnRvcCkgKyBoZWlnaHQgLSB3aW5kb3cuaW5uZXJIZWlnaHQ7XHJcblxyXG4gICAgICAgICAgICBzdHlsZS50b3AgPSBib3R0b21PdmVyZmxvdyA+IDAgPyAodG9wIC0gYm90dG9tT3ZlcmZsb3cpIDogdG9wO1xyXG4gICAgICAgIH0gZWxzZSBpZiAodHJhbnNmb3JtT3JpZ2luLmJvdHRvbSkge1xyXG4gICAgICAgICAgICBjb25zdCB0b3AgPSBzY3JvbGxZICsgc3R5bGUudG9wIC0gaGVpZ2h0O1xyXG4gICAgICAgICAgICBjb25zdCB0b3BPdmVyZmxvdyA9IHNjcm9sbFkgKyAoYW5jaG9yT3JpZ2luLmJvdHRvbSA/IGFuY2hvckNsaWVudFJlY3QuYm90dG9tIDogYW5jaG9yQ2xpZW50UmVjdC50b3ApIC0gaGVpZ2h0O1xyXG5cclxuICAgICAgICAgICAgc3R5bGUudG9wID0gdG9wT3ZlcmZsb3cgPiAwID8gdG9wIDogMDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICh0cmFuc2Zvcm1PcmlnaW4ubGVmdCkge1xyXG4gICAgICAgICAgICBjb25zdCBsZWZ0ID0gc3R5bGUubGVmdDtcclxuICAgICAgICAgICAgY29uc3QgcmlnaHRPdmVyZmxvdyA9IHNjcm9sbFggKyB3aW5kb3cuaW5uZXJXaWR0aCAtIChhbmNob3JPcmlnaW4ubGVmdCA/IGFuY2hvckNsaWVudFJlY3QubGVmdCA6IGFuY2hvckNsaWVudFJlY3QucmlnaHQpICsgd2lkdGg7XHJcblxyXG4gICAgICAgICAgICBzdHlsZS5sZWZ0ID0gcmlnaHRPdmVyZmxvdyA+IDAgPyBsZWZ0IDogbGVmdCAtIE1hdGguYWJzKHJpZ2h0T3ZlcmZsb3cpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAodHJhbnNmb3JtT3JpZ2luLnJpZ2h0KSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGxlZnQgPSBzdHlsZS5sZWZ0IC0gd2lkdGg7XHJcbiAgICAgICAgICAgIGNvbnN0IGxlZnRPdmVyZmxvdyA9IHNjcm9sbFggKyAoYW5jaG9yT3JpZ2luLnJpZ2h0ID8gYW5jaG9yQ2xpZW50UmVjdC5yaWdodCA6IGFuY2hvckNsaWVudFJlY3QubGVmdCkgLSB3aWR0aDtcclxuXHJcbiAgICAgICAgICAgIHN0eWxlLmxlZnQgPSBsZWZ0T3ZlcmZsb3cgPiAwID8gbGVmdCA6IDA7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByb290UmVmLmN1cnJlbnQuc3R5bGUudG9wID0gYCR7c3R5bGUudG9wfXB4YDtcclxuICAgICAgICByb290UmVmLmN1cnJlbnQuc3R5bGUubGVmdCA9IGAke3N0eWxlLmxlZnR9cHhgO1xyXG4gICAgICAgIHJvb3RSZWYuY3VycmVudC5zdHlsZS5wb3NpdGlvbiA9IHN0eWxlLnBvc2l0aW9uO1xyXG4gICAgICAgIHJvb3RSZWYuY3VycmVudC5zdHlsZS53aWR0aCA9IHN0eWxlLndpZHRoO1xyXG4gICAgICAgIHJvb3RSZWYuY3VycmVudC5zdHlsZS5tYXhXaWR0aCA9IHN0eWxlLm1heFdpZHRoO1xyXG4gICAgICAgIHJvb3RSZWYuY3VycmVudC5zdHlsZS50cmFuc2Zvcm1PcmlnaW4gPSBzdHlsZS50cmFuc2Zvcm1PcmlnaW47XHJcbiAgICB9LCBbb3BlbiwgbW9kYWwsIGZpeGVkLCBfYW5jaG9yT3JpZ2luLCBfdHJhbnNmb3JtT3JpZ2luXSk7XHJcblxyXG4gICAgY29uc3QgaGFuZGxlS2V5RG93biA9IHVzZUNhbGxiYWNrKGV2ZW50ID0+IHtcclxuICAgICAgICBpZiAoZXZlbnQua2V5ID09PSAnRXNjYXBlJyAmJiAhcGVyc2lzdGVudCkge1xyXG4gICAgICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcclxuICAgICAgICAgICAgb25DbG9zZShldmVudCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBvbktleURvd24oZXZlbnQpO1xyXG4gICAgfSwgW3BlcnNpc3RlbnQsIG9uS2V5RG93biwgb25DbG9zZV0pO1xyXG5cclxuICAgIGNvbnN0IGlzQmVsb3dBbmNob3IgPSAoXHJcbiAgICAgICAgX2FuY2hvck9yaWdpbi5pbmNsdWRlcygnYm90dG9tJykgJiZcclxuICAgICAgICBfdHJhbnNmb3JtT3JpZ2luLmluY2x1ZGVzKCd0b3AnKVxyXG4gICAgKTtcclxuXHJcbiAgICBjb25zdCBjbGFzc05hbWVzID0gY2xhc3NuYW1lcyhjc3NDbGFzc2VzLlNVUkZBQ0UsIHtcclxuICAgICAgICBbY3NzQ2xhc3Nlcy5TVVJGQUNFX0ZJWEVEXTogZml4ZWQsXHJcbiAgICAgICAgW2Nzc0NsYXNzZXMuU1VSRkFDRV9CRUxPV19BTkNIT1JdOiBpc0JlbG93QW5jaG9yXHJcbiAgICB9LCBjbGFzc05hbWUpO1xyXG5cclxuICAgIHJldHVybiAoPD5cclxuICAgICAgICB7YW5jaG9yICYmXHJcbiAgICAgICAgICAgIGNsb25lKGFuY2hvciwgeyByZWY6IGFuY2hvclJlZiB9KVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgPExheWVyXHJcbiAgICAgICAgICAgIGluPXtvcGVufVxyXG4gICAgICAgICAgICBtb2RhbD17bW9kYWx9XHJcbiAgICAgICAgICAgIHRpbWVvdXQ9e3F1aWNrID8gMCA6IHtcclxuICAgICAgICAgICAgICAgIGVudGVyOiBudW1iZXJzLlRSQU5TSVRJT05fT1BFTl9EVVJBVElPTixcclxuICAgICAgICAgICAgICAgIGV4aXQ6IG51bWJlcnMuVFJBTlNJVElPTl9DTE9TRV9EVVJBVElPTlxyXG4gICAgICAgICAgICB9fVxyXG4gICAgICAgICAgICBjbGFzc05hbWVzPXtxdWljayA/IHtcclxuICAgICAgICAgICAgICAgIGVudGVyRG9uZTogY3NzQ2xhc3Nlcy5TVVJGQUNFX09QRU4sXHJcbiAgICAgICAgICAgIH0gOiB7XHJcbiAgICAgICAgICAgICAgICBlbnRlcjogY3NzQ2xhc3Nlcy5TVVJGQUNFX0FOSU1BVElOR19PUEVOLFxyXG4gICAgICAgICAgICAgICAgZW50ZXJBY3RpdmU6IGNzc0NsYXNzZXMuU1VSRkFDRV9BTklNQVRJTkdfT1BFTixcclxuICAgICAgICAgICAgICAgIGVudGVyRG9uZTogY3NzQ2xhc3Nlcy5TVVJGQUNFX09QRU4sXHJcbiAgICAgICAgICAgICAgICBleGl0OiBjc3NDbGFzc2VzLlNVUkZBQ0VfT1BFTixcclxuICAgICAgICAgICAgICAgIGV4aXRBY3RpdmU6IGNzc0NsYXNzZXMuU1VSRkFDRV9BTklNQVRJTkdfQ0xPU0VEXHJcbiAgICAgICAgICAgIH19XHJcbiAgICAgICAgICAgIG1vdW50T25FbnRlclxyXG4gICAgICAgICAgICB1bm1vdW50T25FeGl0XHJcbiAgICAgICAgPlxyXG4gICAgICAgICAgICA8ZGl2XHJcbiAgICAgICAgICAgICAgICByZWY9e3Jvb3RSZWZ9XHJcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU9e2NsYXNzTmFtZXN9XHJcbiAgICAgICAgICAgICAgICBvbktleURvd249e2hhbmRsZUtleURvd259XHJcbiAgICAgICAgICAgICAgICB7Li4ucHJvcHN9XHJcbiAgICAgICAgICAgIC8+XHJcbiAgICAgICAgPC9MYXllcj5cclxuICAgIDwvPik7XHJcbn0pO1xyXG5cclxuTWVudVN1cmZhY2UuZGlzcGxheU5hbWUgPSAnTURDTWVudVN1cmZhY2UnO1xyXG5cclxuTWVudVN1cmZhY2UucHJvcFR5cGVzID0ge1xyXG4gICAgYW5jaG9yOiBQcm9wVHlwZXMuZWxlbWVudCxcclxuICAgIGFuY2hvclJlZjogUHJvcFR5cGVzLm9iamVjdCxcclxuICAgIGFuY2hvck9yaWdpbjogUHJvcFR5cGVzLm9uZU9mKE9iamVjdC52YWx1ZXMoT3JpZ2luKSksXHJcbiAgICBvcGVuOiBQcm9wVHlwZXMuYm9vbCxcclxuICAgIG1vZGFsOiBQcm9wVHlwZXMuYm9vbCxcclxuICAgIHF1aWNrOiBQcm9wVHlwZXMuYm9vbCxcclxuICAgIGZpeGVkOiBQcm9wVHlwZXMuYm9vbCxcclxuICAgIHBlcnNpc3RlbnQ6IFByb3BUeXBlcy5ib29sLFxyXG4gICAgZnVsbFdpZHRoOiBQcm9wVHlwZXMuYm9vbCxcclxuICAgIG9uQ2xvc2U6IFByb3BUeXBlcy5mdW5jXHJcbn07XHJcblxyXG5leHBvcnQgZGVmYXVsdCBNZW51U3VyZmFjZTsiLCJpbXBvcnQgeyBmb3J3YXJkUmVmLCB1c2VTdGF0ZSwgdXNlRWZmZWN0LCB1c2VDYWxsYmFjaywgdXNlUmVmLCBDaGlsZHJlbiB9IGZyb20gJ3JlYWN0JztcclxuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcclxuaW1wb3J0IGNsYXNzbmFtZXMgZnJvbSAnY2xhc3NuYW1lcyc7XHJcblxyXG5pbXBvcnQgeyB1c2VVcGRhdGVkIH0gZnJvbSAnLi4vaG9va3MnO1xyXG5pbXBvcnQgeyBDbG9uZSwgY3JlYXRlIH0gZnJvbSAnLi4vY29tcG9uZW50JztcclxuaW1wb3J0IExpc3QgZnJvbSAnLi4vbGlzdCc7XHJcblxyXG5pbXBvcnQgeyBjc3NDbGFzc2VzIH0gZnJvbSAnLi9jb25zdGFudHMnO1xyXG5pbXBvcnQgTWVudUl0ZW0gZnJvbSAnLi9NZW51SXRlbSc7XHJcbmltcG9ydCBNZW51U3VyZmFjZSBmcm9tICcuL01lbnVTdXJmYWNlJztcclxuXHJcbmNvbnN0IE1lbnUgPSBmb3J3YXJkUmVmKCh7XHJcbiAgICBvcGVuLFxyXG4gICAgaXRlbXMsXHJcbiAgICBsaXN0UHJvcHMgPSB7fSxcclxuXHJcbiAgICBjaGlsZHJlbiA9IGl0ZW1zPy5tYXAoaXRlbSA9PiBjcmVhdGUoTWVudUl0ZW0sIGl0ZW0pKSxcclxuICAgIGNsYXNzTmFtZSxcclxuICAgIC4uLnByb3BzXHJcbn0sIHJlZikgPT4ge1xyXG4gICAgY29uc3QgbGlzdFJlZiA9IHVzZVJlZigpO1xyXG5cclxuICAgIGNvbnN0IFtmb2N1c2VkQ2hpbGRJbmRleCwgc2V0Rm9jdXNlZENoaWxkSW5kZXhdID0gdXNlU3RhdGUoMCk7XHJcblxyXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgICAgICBpZiAob3Blbikge1xyXG4gICAgICAgICAgICBzZXRGb2N1c2VkQ2hpbGRJbmRleChcclxuICAgICAgICAgICAgICAgIENoaWxkcmVuLnRvQXJyYXkoY2hpbGRyZW4pLmZpbmRJbmRleChpID0+IGkucHJvcHMuc2VsZWN0ZWQpXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgfVxyXG4gICAgfSwgW29wZW4sIGNoaWxkcmVuXSk7XHJcblxyXG4gICAgdXNlVXBkYXRlZCgoKSA9PiB7XHJcbiAgICAgICAgaWYgKG9wZW4pIHtcclxuICAgICAgICAgICAgbGlzdFJlZi5jdXJyZW50LmNoaWxkcmVuW2ZvY3VzZWRDaGlsZEluZGV4XT8uZm9jdXMoKTtcclxuICAgICAgICB9XHJcbiAgICB9LCBbZm9jdXNlZENoaWxkSW5kZXgsIG9wZW5dKTtcclxuXHJcbiAgICBjb25zdCBoYW5kbGVLZXlEb3duID0gdXNlQ2FsbGJhY2soZXZlbnQgPT4ge1xyXG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XHJcblxyXG4gICAgICAgIGlmIChldmVudC5rZXkgPT09ICdBcnJvd0Rvd24nKSB7XHJcbiAgICAgICAgICAgIHNldEZvY3VzZWRDaGlsZEluZGV4KGluZGV4ID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG5leHRJbmRleCA9IGluZGV4ICsgMTtcclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV4dEluZGV4IDwgbGlzdFJlZi5jdXJyZW50LmNoaWxkcmVuLmxlbmd0aCA/IG5leHRJbmRleCA6IGluZGV4O1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9IGVsc2UgaWYgKGV2ZW50LmtleSA9PT0gJ0Fycm93VXAnKSB7XHJcbiAgICAgICAgICAgIHNldEZvY3VzZWRDaGlsZEluZGV4KGluZGV4ID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG5leHRJbmRleCA9IGluZGV4IC0gMTtcclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV4dEluZGV4ID49IDAgPyBuZXh0SW5kZXggOiBpbmRleDtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSwgW10pO1xyXG5cclxuICAgIGNvbnN0IGNsYXNzTmFtZXMgPSBjbGFzc25hbWVzKGNzc0NsYXNzZXMuUk9PVCwgY2xhc3NOYW1lKTtcclxuXHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAgIDxNZW51U3VyZmFjZVxyXG4gICAgICAgICAgICByZWY9e3JlZn1cclxuICAgICAgICAgICAgb3Blbj17b3Blbn1cclxuICAgICAgICAgICAgY2xhc3NOYW1lPXtjbGFzc05hbWVzfVxyXG4gICAgICAgICAgICBvbktleURvd249e2hhbmRsZUtleURvd259XHJcbiAgICAgICAgICAgIHsuLi5wcm9wc31cclxuICAgICAgICA+XHJcbiAgICAgICAgICAgIDxMaXN0XHJcbiAgICAgICAgICAgICAgICByZWY9e2xpc3RSZWZ9XHJcbiAgICAgICAgICAgICAgICByb2xlPVwibWVudVwiXHJcbiAgICAgICAgICAgICAgICBhcmlhLWhpZGRlbj1cInRydWVcIlxyXG4gICAgICAgICAgICAgICAgYXJpYS1vcmllbnRhdGlvbj1cInZlcnRpY2FsXCJcclxuICAgICAgICAgICAgICAgIHRhYkluZGV4PXtvcGVuID8gMCA6IC0xfVxyXG4gICAgICAgICAgICAgICAgey4uLmxpc3RQcm9wc31cclxuICAgICAgICAgICAgPlxyXG4gICAgICAgICAgICAgICAge0NoaWxkcmVuLm1hcChjaGlsZHJlbiwgKGl0ZW0sIGluZGV4KSA9PlxyXG4gICAgICAgICAgICAgICAgICAgIDxDbG9uZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb21wb25lbnQ9e2l0ZW19XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhYkluZGV4PXsoaW5kZXggPT09IGZvY3VzZWRDaGlsZEluZGV4KSA/IDAgOiAtMX1cclxuICAgICAgICAgICAgICAgICAgICAvPlxyXG4gICAgICAgICAgICAgICAgKX1cclxuICAgICAgICAgICAgPC9MaXN0PlxyXG4gICAgICAgIDwvTWVudVN1cmZhY2U+XHJcbiAgICApO1xyXG59KTtcclxuXHJcbk1lbnUuZGlzcGxheU5hbWUgPSAnTURDTWVudSc7XHJcblxyXG5NZW51LnByb3BUeXBlcyA9IHtcclxuICAgIC4uLk1lbnVTdXJmYWNlLnByb3BUeXBlcyxcclxuICAgIGxpc3RQcm9wczogUHJvcFR5cGVzLm9iamVjdFxyXG59O1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgTWVudTsiLCJpbXBvcnQgeyBmb3J3YXJkUmVmIH0gZnJvbSAncmVhY3QnO1xyXG5pbXBvcnQgY2xhc3NuYW1lcyBmcm9tICdjbGFzc25hbWVzJztcclxuXHJcbmltcG9ydCB7IGNyZWF0ZSwgY2xvbmUgfSBmcm9tICcuLi9jb21wb25lbnQnO1xyXG5pbXBvcnQgeyBjc3NDbGFzc2VzIH0gZnJvbSAnLi9jb25zdGFudHMnO1xyXG5cclxuY29uc3QgTWVudUFuY2hvciA9IGZvcndhcmRSZWYoKHtcclxuICAgIHdyYXAgPSB0cnVlLFxyXG5cclxuICAgIGVsZW1lbnQgPSAnZGl2JyxcclxuICAgIGNsYXNzTmFtZSxcclxuICAgIGNoaWxkcmVuLFxyXG4gICAgLi4ucHJvcHNcclxufSwgcmVmKSA9PiB7XHJcbiAgICByZXR1cm4gd3JhcCA/XHJcbiAgICAgICAgY3JlYXRlKGVsZW1lbnQsIHtcclxuICAgICAgICAgICAgcmVmLFxyXG4gICAgICAgICAgICBjbGFzc05hbWU6IGNsYXNzbmFtZXMoY3NzQ2xhc3Nlcy5TVVJGQUNFX0FOQ0hPUiwgY2xhc3NOYW1lKSxcclxuICAgICAgICAgICAgLi4ucHJvcHNcclxuICAgICAgICB9LCBjaGlsZHJlbilcclxuICAgICAgICA6XHJcbiAgICAgICAgY2xvbmUoY2hpbGRyZW4sIHtcclxuICAgICAgICAgICAgcmVmLFxyXG4gICAgICAgICAgICBjbGFzc05hbWU6IGNsYXNzbmFtZXMoY2hpbGRyZW4ucHJvcHMuY2xhc3NOYW1lLCBjc3NDbGFzc2VzLlNVUkZBQ0VfQU5DSE9SKSxcclxuICAgICAgICAgICAgLi4ucHJvcHNcclxuICAgICAgICB9KTtcclxufSk7XHJcblxyXG5NZW51QW5jaG9yLmRpc3BsYXlOYW1lID0gJ01EQ01lbnVBbmNob3InO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgTWVudUFuY2hvcjsiLCJpbXBvcnQgeyBmb3J3YXJkUmVmIH0gZnJvbSAncmVhY3QnO1xyXG5cclxuY29uc3QgTWVudVNlbGVjdGlvbkdyb3VwID0gZm9yd2FyZFJlZigoe1xyXG4gICAgZWxlbWVudDogRWxlbWVudCA9ICd1bCcsXHJcbiAgICAuLi5wcm9wc1xyXG59LCByZWYpID0+IHtcclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgPGxpIHJlZj17cmVmfT5cclxuICAgICAgICAgICAgPEVsZW1lbnQgY2xhc3NOYW1lPVwibWRjLW1lbnVfX3NlbGVjdGlvbi1ncm91cFwiIHsuLi5wcm9wc30gLz5cclxuICAgICAgICA8L2xpPlxyXG4gICAgKTtcclxufSk7XHJcblxyXG5NZW51U2VsZWN0aW9uR3JvdXAuZGlzcGxheU5hbWUgPSAnTURDTWVudVNlbGVjdGlvbkdyb3VwJztcclxuXHJcbmV4cG9ydCBkZWZhdWx0IE1lbnVTZWxlY3Rpb25Hcm91cDsiLCJpbXBvcnQgSWNvbiBmcm9tICcuLi9pY29uJztcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIE1lbnVTZWxlY3Rpb25Hcm91cEljb24ocHJvcHMpIHtcclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgPEljb25cclxuICAgICAgICAgICAgY2xhc3NOYW1lPVwibWRjLW1lbnVfX3NlbGVjdGlvbi1ncm91cC1pY29uXCJcclxuICAgICAgICAgICAgey4uLnByb3BzfVxyXG4gICAgICAgIC8+XHJcbiAgICApO1xyXG59XHJcblxyXG5NZW51U2VsZWN0aW9uR3JvdXBJY29uLmRpc3BsYXlOYW1lID0gJ01EQ01lbnVTZWxlY3Rpb25Hcm91cEljb24nOyIsImltcG9ydCB7IE9yaWdpbiBhcyBNZW51T3JpZ2luIH0gZnJvbSAnLi9jb25zdGFudHMnO1xyXG5pbXBvcnQgTWVudSBmcm9tICcuL01lbnUnO1xyXG5pbXBvcnQgTWVudUFuY2hvciBmcm9tICcuL01lbnVBbmNob3InO1xyXG5pbXBvcnQgTWVudUl0ZW0gZnJvbSAnLi9NZW51SXRlbSc7XHJcbmltcG9ydCBNZW51U3VyZmFjZSBmcm9tICcuL01lbnVTdXJmYWNlJztcclxuaW1wb3J0IE1lbnVTZWxlY3Rpb25Hcm91cCBmcm9tICcuL01lbnVTZWxlY3Rpb25Hcm91cCc7XHJcbmltcG9ydCBNZW51U2VsZWN0aW9uR3JvdXBJY29uIGZyb20gJy4vTWVudVNlbGVjdGlvbkdyb3VwSWNvbic7XHJcblxyXG5NZW51LkFuY2hvciA9IE1lbnVBbmNob3I7XHJcbk1lbnUuSXRlbSA9IE1lbnVJdGVtO1xyXG5NZW51Lk9yaWdpbiA9IE1lbnVPcmlnaW47XHJcbk1lbnUuU3VyZmFjZSA9IE1lbnVTdXJmYWNlO1xyXG5NZW51LlNlbGVjdGlvbkdyb3VwID0gTWVudVNlbGVjdGlvbkdyb3VwO1xyXG5NZW51LlNlbGVjdGlvbkdyb3VwSWNvbiA9IE1lbnVTZWxlY3Rpb25Hcm91cEljb247XHJcblxyXG5leHBvcnQge1xyXG4gICAgTWVudSBhcyBkZWZhdWx0LFxyXG4gICAgTWVudUFuY2hvcixcclxuICAgIE1lbnVJdGVtLFxyXG4gICAgTWVudU9yaWdpbixcclxuICAgIE1lbnVTdXJmYWNlLFxyXG4gICAgTWVudVNlbGVjdGlvbkdyb3VwLFxyXG4gICAgTWVudVNlbGVjdGlvbkdyb3VwSWNvblxyXG59OyIsImV4cG9ydCBjb25zdCBjc3NDbGFzc2VzID0ge1xyXG4gICAgUk9PVDogJ21kYy1zZWxlY3QnLFxyXG4gICAgRklMTEVEOiAnbWRjLXNlbGVjdC0tZmlsbGVkJyxcclxuICAgIE9VVExJTkVEOiAnbWRjLXNlbGVjdC0tb3V0bGluZWQnLFxyXG4gICAgQUNUSVZBVEVEOiAnbWRjLXNlbGVjdC0tYWN0aXZhdGVkJyxcclxuICAgIERJU0FCTEVEOiAnbWRjLXNlbGVjdC0tZGlzYWJsZWQnLFxyXG4gICAgRk9DVVNFRDogJ21kYy1zZWxlY3QtLWZvY3VzZWQnLFxyXG4gICAgUkVRVUlSRUQ6ICdtZGMtc2VsZWN0LS1yZXF1aXJlZCcsXHJcbiAgICBJTlZBTElEOiAnbWRjLXNlbGVjdC0taW52YWxpZCcsXHJcbiAgICBOT19MQUJFTDogJ21kYy1zZWxlY3QtLW5vLWxhYmVsJyxcclxuICAgIFdJVEhfTEVBRElOR19JQ09OOiAnbWRjLXNlbGVjdC0td2l0aC1sZWFkaW5nLWljb24nLFxyXG5cclxuICAgIFNFTEVDVEVEX1RFWFQ6ICdtZGMtc2VsZWN0X19zZWxlY3RlZC10ZXh0JyxcclxuICAgIFNFTEVDVEVEX1RFWFRfQ09OVEFJTkVSOiAnbWRjLXNlbGVjdF9fc2VsZWN0ZWQtdGV4dC1jb250YWluZXInLFxyXG5cclxuICAgIERST1BET1dOX0lDT046ICdtZGMtc2VsZWN0X19kcm9wZG93bi1pY29uJyxcclxuICAgIERST1BET1dOX0lDT05fR1JBUEhJQzogJ21kYy1zZWxlY3RfX2Ryb3Bkb3duLWljb24tZ3JhcGhpYycsXHJcbiAgICBEUk9QRE9XTl9JQ09OX0lOQUNUSVZFOiAnbWRjLXNlbGVjdF9fZHJvcGRvd24taWNvbi1pbmFjdGl2ZScsXHJcbiAgICBEUk9QRE9XTl9JQ09OX0FDVElWRTogJ21kYy1zZWxlY3RfX2Ryb3Bkb3duLWljb24tYWN0aXZlJyxcclxuXHJcbiAgICBJQ09OOiAnbWRjLXNlbGVjdF9faWNvbicsXHJcblxyXG4gICAgTUVOVTogJ21kYy1zZWxlY3RfX21lbnUnLFxyXG4gICAgTUVOVV9JTlZBTElEOiAnbWRjLXNlbGVjdF9fbWVudS0taW52YWxpZCcsXHJcblxyXG4gICAgUklQUExFOiAnbWRjLXNlbGVjdF9fcmlwcGxlJyxcclxuXHJcbiAgICBBTkNIT1I6ICdtZGMtc2VsZWN0X19hbmNob3InLFxyXG5cclxuICAgIEhFTFBFUl9URVhUOiAnbWRjLXNlbGVjdC1oZWxwZXItdGV4dCcsXHJcbiAgICBWQUxJREFUSU9OX01FU1NBR0U6ICdtZGMtc2VsZWN0LWhlbHBlci10ZXh0LS12YWxpZGF0aW9uLW1zZycsXHJcbiAgICBWQUxJREFUSU9OX01FU1NBR0VfUEVSU0lTVEVOVDogJ21kYy1zZWxlY3QtaGVscGVyLXRleHQtLXZhbGlkYXRpb24tbXNnLXBlcnNpc3RlbnQnXHJcbn07IiwiaW1wb3J0IHsgY3NzQ2xhc3NlcyB9IGZyb20gJy4vY29uc3RhbnRzJztcclxuXHJcbmNvbnN0IERyb3Bkb3duSWNvbiA9ICgpID0+IHtcclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgPHNwYW4gY2xhc3NOYW1lPXtjc3NDbGFzc2VzLkRST1BET1dOX0lDT059PlxyXG4gICAgICAgICAgICA8c3ZnXHJcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU9e2Nzc0NsYXNzZXMuRFJPUERPV05fSUNPTl9HUkFQSElDfVxyXG4gICAgICAgICAgICAgICAgdmlld0JveD1cIjcgMTAgMTAgNVwiXHJcbiAgICAgICAgICAgICAgICBmb2N1c2FibGU9XCJmYWxzZVwiXHJcbiAgICAgICAgICAgID5cclxuICAgICAgICAgICAgICAgIDxwb2x5Z29uXHJcbiAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPXtjc3NDbGFzc2VzLkRST1BET1dOX0lDT05fSU5BQ1RJVkV9XHJcbiAgICAgICAgICAgICAgICAgICAgc3Ryb2tlPVwibm9uZVwiXHJcbiAgICAgICAgICAgICAgICAgICAgZmlsbFJ1bGU9XCJldmVub2RkXCJcclxuICAgICAgICAgICAgICAgICAgICBwb2ludHM9XCI3IDEwIDEyIDE1IDE3IDEwXCJcclxuICAgICAgICAgICAgICAgIC8+XHJcblxyXG4gICAgICAgICAgICAgICAgPHBvbHlnb25cclxuICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU9e2Nzc0NsYXNzZXMuRFJPUERPV05fSUNPTl9BQ1RJVkV9XHJcbiAgICAgICAgICAgICAgICAgICAgc3Ryb2tlPVwibm9uZVwiXHJcbiAgICAgICAgICAgICAgICAgICAgZmlsbFJ1bGU9XCJldmVub2RkXCJcclxuICAgICAgICAgICAgICAgICAgICBwb2ludHM9XCI3IDE1IDEyIDEwIDE3IDE1XCJcclxuICAgICAgICAgICAgICAgIC8+XHJcbiAgICAgICAgICAgIDwvc3ZnPlxyXG4gICAgICAgIDwvc3Bhbj5cclxuICAgICk7XHJcbn07XHJcblxyXG5leHBvcnQgZGVmYXVsdCBEcm9wZG93bkljb247IiwiaW1wb3J0IHsgZm9yd2FyZFJlZiB9IGZyb20gJ3JlYWN0JztcclxuXHJcbmltcG9ydCBDaGVja2JveCBmcm9tICcuLi9jaGVja2JveCc7XHJcbmltcG9ydCB7IE1lbnVJdGVtIH0gZnJvbSAnLi4vbWVudSc7XHJcblxyXG5jb25zdCBTZWxlY3RPcHRpb24gPSBmb3J3YXJkUmVmKCh7XHJcbiAgICBzZWxlY3RlZCxcclxuICAgIGNoZWNrYm94ID0gZmFsc2UsXHJcbiAgICBvbkNsaWNrLFxyXG4gICAgLi4ucHJvcHNcclxufSwgcmVmKSA9PiB7XHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAgIDxNZW51SXRlbVxyXG4gICAgICAgICAgICByZWY9e3JlZn1cclxuICAgICAgICAgICAgc3RhcnQ9e2NoZWNrYm94ICYmIDxDaGVja2JveCBjaGVja2VkPXtzZWxlY3RlZH0gLz59XHJcbiAgICAgICAgICAgIHNlbGVjdGVkPXtzZWxlY3RlZH1cclxuICAgICAgICAgICAgd2l0aExlYWRpbmdDaGVja2JveD17Y2hlY2tib3h9XHJcbiAgICAgICAgICAgIG9uQ2xpY2s9e29uQ2xpY2t9XHJcbiAgICAgICAgICAgIHsuLi5wcm9wc31cclxuICAgICAgICAvPlxyXG4gICAgKTtcclxufSk7XHJcblxyXG5TZWxlY3RPcHRpb24uZGlzcGxheU5hbWUgPSAnTURDU2VsZWN0T3B0aW9uJztcclxuXHJcbmV4cG9ydCBkZWZhdWx0IFNlbGVjdE9wdGlvbjsiLCJpbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xyXG5pbXBvcnQgY2xhc3NuYW1lcyBmcm9tICdjbGFzc25hbWVzJztcclxuXHJcbmltcG9ydCB7IGNzc0NsYXNzZXMgfSBmcm9tICcuL2NvbnN0YW50cyc7XHJcblxyXG5jb25zdCBIZWxwZXJUZXh0ID0gKHtcclxuICAgIHZhbGlkYXRpb24gPSBmYWxzZSxcclxuICAgIHBlcnNpc3RlbnQgPSBmYWxzZSxcclxuXHJcbiAgICBlbGVtZW50OiBFbGVtZW50ID0gJ3AnLFxyXG4gICAgLi4ucHJvcHNcclxufSkgPT4ge1xyXG4gICAgY29uc3QgY2xhc3NOYW1lcyA9IGNsYXNzbmFtZXMoY3NzQ2xhc3Nlcy5IRUxQRVJfVEVYVCwge1xyXG4gICAgICAgIFtjc3NDbGFzc2VzLlZBTElEQVRJT05fTUVTU0FHRV06IHZhbGlkYXRpb24sXHJcbiAgICAgICAgW2Nzc0NsYXNzZXMuVkFMSURBVElPTl9NRVNTQUdFX1BFUlNJU1RFTlRdOiBwZXJzaXN0ZW50XHJcbiAgICB9KTtcclxuXHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAgIDxFbGVtZW50IGNsYXNzTmFtZT17Y2xhc3NOYW1lc30gey4uLnByb3BzfSAvPlxyXG4gICAgKTtcclxufTtcclxuXHJcbkhlbHBlclRleHQuZGlzcGxheU5hbWUgPSAnTURDU2VsZWN0SGVscGVyVGV4dCc7XHJcblxyXG5IZWxwZXJUZXh0LnByb3BUeXBlcyA9IHtcclxuICAgIHBlcnNpc3RlbnQ6IFByb3BUeXBlcy5ib29sLFxyXG4gICAgdmFsaWRhdGlvbjogUHJvcFR5cGVzLmJvb2xcclxufTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IEhlbHBlclRleHQ7IiwiaW1wb3J0IHsgdXNlUmVmLCB1c2VTdGF0ZSwgdXNlRWZmZWN0LCB1c2VDYWxsYmFjaywgQ2hpbGRyZW4sIGZvcndhcmRSZWYgfSBmcm9tICdyZWFjdCc7XHJcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XHJcbmltcG9ydCBjbGFzc25hbWVzIGZyb20gJ2NsYXNzbmFtZXMnO1xyXG5cclxuaW1wb3J0IHsgaXNVbmRlZmluZWQsIGlzQXJyYXkgfSBmcm9tICcuLi90eXBlcyc7XHJcbmltcG9ydCB7IENsb25lLCBjcmVhdGUsIGNsb25lIH0gZnJvbSAnLi4vY29tcG9uZW50JztcclxuaW1wb3J0IEZsb2F0aW5nTGFiZWwgZnJvbSAnLi4vZmxvYXRpbmctbGFiZWwnO1xyXG5pbXBvcnQgSWNvbiBmcm9tICcuLi9pY29uJztcclxuaW1wb3J0IExpbmVSaXBwbGUgZnJvbSAnLi4vbGluZS1yaXBwbGUnO1xyXG5pbXBvcnQgTm90Y2hlZE91dGxpbmUgZnJvbSAnLi4vbm90Y2hlZC1vdXRsaW5lJztcclxuaW1wb3J0IE1lbnUsIHsgTWVudU9yaWdpbiB9IGZyb20gJy4uL21lbnUnO1xyXG5cclxuaW1wb3J0IHsgY3NzQ2xhc3NlcyB9IGZyb20gJy4vY29uc3RhbnRzJztcclxuaW1wb3J0IERyb3Bkb3duSWNvbiBmcm9tICcuL0Ryb3Bkb3duSWNvbic7XHJcbmltcG9ydCBTZWxlY3RPcHRpb24gZnJvbSAnLi9TZWxlY3RPcHRpb24nO1xyXG5pbXBvcnQgSGVscGVyVGV4dCBmcm9tICcuL0hlbHBlclRleHQnO1xyXG5cclxuY29uc3QgU2VsZWN0ID0gZm9yd2FyZFJlZigoe1xyXG4gICAgbmFtZSxcclxuICAgIHZhbHVlLFxyXG4gICAgb3B0aW9ucyxcclxuICAgIGxhYmVsLFxyXG4gICAgaWNvbixcclxuICAgIGxlYWRpbmdJY29uID0gaWNvbixcclxuICAgIGhlbHBlclRleHQsXHJcbiAgICBmaWxsZWQgPSBmYWxzZSxcclxuICAgIG91dGxpbmVkID0gZmFsc2UsXHJcbiAgICBtdWx0aXBsZSA9IGlzQXJyYXkodmFsdWUpLFxyXG4gICAgZGlzYWJsZWQgPSBmYWxzZSxcclxuICAgIHJlcXVpcmVkID0gZmFsc2UsXHJcbiAgICBvbkNoYW5nZSA9IEZ1bmN0aW9uLnByb3RvdHlwZSxcclxuICAgIG1lbnVQcm9wcyA9IHt9LFxyXG4gICAgbGlzdFByb3BzID0ge30sXHJcbiAgICBoZWxwZXJUZXh0UHJvcHMgPSB7fSxcclxuXHJcbiAgICBjbGFzc05hbWUsXHJcbiAgICBjaGlsZHJlbiA9IG9wdGlvbnM/Lm1hcChvcHRpb24gPT4gY3JlYXRlKFNlbGVjdE9wdGlvbiwgb3B0aW9uKSksXHJcbiAgICAuLi5wcm9wc1xyXG59LCByZWYpID0+IHtcclxuICAgIGNvbnN0IGFuY2hvclJlZiA9IHVzZVJlZigpO1xyXG4gICAgY29uc3QgaW5wdXRSZWYgPSB1c2VSZWYoKTtcclxuICAgIGNvbnN0IG1lbnVSZWYgPSB1c2VSZWYoKTtcclxuXHJcbiAgICBjb25zdCBbYWN0aXZhdGVkLCBzZXRBY3RpdmF0ZWRdID0gdXNlU3RhdGUoZmFsc2UpO1xyXG4gICAgY29uc3QgW2ZvY3VzZWQsIHNldEZvY3VzZWRdID0gdXNlU3RhdGUoZmFsc2UpO1xyXG4gICAgY29uc3QgW3RvdWNoZWQsIHNldFRvdWNoZWRdID0gdXNlU3RhdGUoZmFsc2UpO1xyXG4gICAgY29uc3QgW3NlbGVjdGVkVGV4dCwgc2V0U2VsZWN0ZWRUZXh0XSA9IHVzZVN0YXRlKCk7XHJcbiAgICBjb25zdCBbaW50ZXJhY3Rpb25Db29yZHMsIHNldEludGVyYWN0aW9uQ29vcmRzXSA9IHVzZVN0YXRlKCk7XHJcblxyXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgICAgICBpZiAobXVsdGlwbGUpIHtcclxuICAgICAgICAgICAgY29uc3Qgc2VsZWN0ZWRPcHRpb25zID0gKENoaWxkcmVuLnRvQXJyYXkoY2hpbGRyZW4pLm1hcChvcHRpb24gPT4gb3B0aW9uLnByb3BzKSlcclxuICAgICAgICAgICAgICAgIC5maWx0ZXIob3B0aW9uID0+IHZhbHVlLmluY2x1ZGVzKG9wdGlvbi52YWx1ZSkpO1xyXG5cclxuICAgICAgICAgICAgY29uc3Qgc2VsZWN0ZWRUZXh0ID0gc2VsZWN0ZWRPcHRpb25zLm1hcChvcHRpb24gPT4gb3B0aW9uLnRleHQgfHwgb3B0aW9uLmNoaWxkcmVuKS5qb2luKCcsICcpO1xyXG4gICAgICAgICAgICBzZXRTZWxlY3RlZFRleHQoc2VsZWN0ZWRUZXh0KTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zdCBzZWxlY3RlZE9wdGlvbiA9IChDaGlsZHJlbi50b0FycmF5KGNoaWxkcmVuKS5tYXAob3B0aW9uID0+IG9wdGlvbi5wcm9wcykpXHJcbiAgICAgICAgICAgICAgICAuZmluZChvcHRpb24gPT4gb3B0aW9uLnZhbHVlID09PSB2YWx1ZSk7XHJcblxyXG4gICAgICAgICAgICBpZiAoc2VsZWN0ZWRPcHRpb24pIHtcclxuICAgICAgICAgICAgICAgIHNldFNlbGVjdGVkVGV4dChzZWxlY3RlZE9wdGlvbi50ZXh0IHx8IHNlbGVjdGVkT3B0aW9uLmNoaWxkcmVuKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0sIFt2YWx1ZSwgbXVsdGlwbGUsIGNoaWxkcmVuXSk7XHJcblxyXG4gICAgY29uc3QgaGFuZGxlQW5jaG9yQ2xpY2sgPSB1c2VDYWxsYmFjayhldmVudCA9PiB7XHJcbiAgICAgICAgaWYgKGFjdGl2YXRlZCkge1xyXG4gICAgICAgICAgICBzZXRBY3RpdmF0ZWQoZmFsc2UpO1xyXG4gICAgICAgICAgICBzZXRGb2N1c2VkKGZhbHNlKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zdCB0YXJnZXRDbGllbnRSZWN0ID0gZXZlbnQudGFyZ2V0LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xyXG5cclxuICAgICAgICAgICAgc2V0SW50ZXJhY3Rpb25Db29yZHMoe1xyXG4gICAgICAgICAgICAgICAgeDogZXZlbnQuY2xpZW50WCAtIHRhcmdldENsaWVudFJlY3QubGVmdCxcclxuICAgICAgICAgICAgICAgIHk6IGV2ZW50LmNsaWVudFkgLSB0YXJnZXRDbGllbnRSZWN0LnRvcFxyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIHNldEFjdGl2YXRlZCh0cnVlKTtcclxuICAgICAgICAgICAgc2V0Rm9jdXNlZCh0cnVlKTtcclxuICAgICAgICB9XHJcbiAgICB9LCBbYWN0aXZhdGVkXSk7XHJcblxyXG4gICAgY29uc3QgaGFuZGxlT3B0aW9uSW50ZXJhY3Rpb24gPSB1c2VDYWxsYmFjayhldmVudCA9PiB7XHJcbiAgICAgICAgaWYgKFxyXG4gICAgICAgICAgICBldmVudC50eXBlID09PSAna2V5ZG93bicgJiZcclxuICAgICAgICAgICAgZXZlbnQua2V5ICE9PSAnICcgJiZcclxuICAgICAgICAgICAgZXZlbnQua2V5ICE9PSAnRW50ZXInXHJcbiAgICAgICAgKSByZXR1cm47XHJcblxyXG4gICAgICAgIGNvbnN0IG9wdGlvbiA9IGV2ZW50LmN1cnJlbnRUYXJnZXQuZGF0YXNldDtcclxuXHJcbiAgICAgICAgaWYgKG9wdGlvbi5kaXNhYmxlZCkgcmV0dXJuO1xyXG5cclxuICAgICAgICBpZiAobXVsdGlwbGUpIHtcclxuICAgICAgICAgICAgY29uc3QgdmFsdWVzID0gbmV3IFNldCh2YWx1ZSk7XHJcblxyXG4gICAgICAgICAgICB2YWx1ZXMuaGFzKG9wdGlvbi52YWx1ZSkgP1xyXG4gICAgICAgICAgICAgICAgdmFsdWVzLmRlbGV0ZShvcHRpb24udmFsdWUpIDpcclxuICAgICAgICAgICAgICAgIHZhbHVlcy5hZGQob3B0aW9uLnZhbHVlKTtcclxuXHJcbiAgICAgICAgICAgIGV2ZW50LnRhcmdldCA9IHsgbmFtZSwgdmFsdWU6IFsuLi52YWx1ZXNdIH07XHJcblxyXG4gICAgICAgICAgICBvbkNoYW5nZShldmVudCwgWy4uLnZhbHVlc10pO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGV2ZW50LnRhcmdldCA9IHsgbmFtZSwgdmFsdWU6IG9wdGlvbi52YWx1ZSB9O1xyXG5cclxuICAgICAgICAgICAgb25DaGFuZ2UoZXZlbnQsIG9wdGlvbi52YWx1ZSk7XHJcblxyXG4gICAgICAgICAgICBzZXRBY3RpdmF0ZWQoZmFsc2UpO1xyXG4gICAgICAgICAgICBzZXRGb2N1c2VkKGZhbHNlKTtcclxuICAgICAgICB9XHJcbiAgICB9LCBbdmFsdWUsIG5hbWUsIG11bHRpcGxlLCBvbkNoYW5nZV0pO1xyXG5cclxuICAgIGNvbnN0IGhhbmRsZU1lbnVDbG9zZSA9IHVzZUNhbGxiYWNrKGV2ZW50ID0+IHtcclxuICAgICAgICBpZiAoZXZlbnQudHlwZSA9PT0gJ2NsaWNrJyAmJiBldmVudC50YXJnZXQgPT09IGFuY2hvclJlZi5jdXJyZW50KSByZXR1cm47XHJcbiAgICAgICAgaWYgKG11bHRpcGxlICYmIGV2ZW50LnR5cGUgPT09ICdjbGljaycgJiYgZXZlbnQucGF0aC5pbmNsdWRlcyhtZW51UmVmLmN1cnJlbnQpKSByZXR1cm47XHJcblxyXG4gICAgICAgIHNldEFjdGl2YXRlZChmYWxzZSk7XHJcbiAgICAgICAgc2V0Rm9jdXNlZChmYWxzZSk7XHJcbiAgICAgICAgc2V0VG91Y2hlZCh0cnVlKTtcclxuICAgIH0sIFttdWx0aXBsZV0pO1xyXG5cclxuICAgIGNvbnN0IGhhbmRsZUtleURvd24gPSB1c2VDYWxsYmFjayhldmVudCA9PiB7XHJcbiAgICAgICAgaWYgKFxyXG4gICAgICAgICAgICBldmVudC5rZXkgPT09ICcgJyB8fFxyXG4gICAgICAgICAgICBldmVudC5rZXkgPT09ICdFbnRlcicgfHxcclxuICAgICAgICAgICAgZXZlbnQua2V5ID09PSAnQXJyb3dEb3duJyB8fFxyXG4gICAgICAgICAgICBldmVudC5rZXkgPT09ICdBcnJvd1VwJ1xyXG4gICAgICAgICkge1xyXG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcclxuXHJcbiAgICAgICAgICAgIHNldEFjdGl2YXRlZCh0cnVlKTtcclxuICAgICAgICB9XHJcbiAgICB9LCBbXSk7XHJcblxyXG4gICAgY29uc3QgaGFzVmFsdWUgPSBpc0FycmF5KHZhbHVlKSA/IHZhbHVlLmxlbmd0aCA+IDAgOiBCb29sZWFuKHZhbHVlKTtcclxuICAgIGNvbnN0IGZvY3VzZWRPckhhc1ZhbHVlID0gZm9jdXNlZCB8fCBoYXNWYWx1ZTtcclxuICAgIGNvbnN0IGlzSW52YWxpZCA9IHRvdWNoZWQgJiYgcmVxdWlyZWQgJiYgIWhhc1ZhbHVlO1xyXG5cclxuICAgIGNvbnN0IGNsYXNzTmFtZXMgPSBjbGFzc25hbWVzKGNzc0NsYXNzZXMuUk9PVCwge1xyXG4gICAgICAgIFtjc3NDbGFzc2VzLkZJTExFRF06IGZpbGxlZCxcclxuICAgICAgICBbY3NzQ2xhc3Nlcy5PVVRMSU5FRF06IG91dGxpbmVkLFxyXG4gICAgICAgIFtjc3NDbGFzc2VzLkFDVElWQVRFRF06IGFjdGl2YXRlZCxcclxuICAgICAgICBbY3NzQ2xhc3Nlcy5ESVNBQkxFRF06IGRpc2FibGVkLFxyXG4gICAgICAgIFtjc3NDbGFzc2VzLkZPQ1VTRURdOiBmb2N1c2VkLFxyXG4gICAgICAgIFtjc3NDbGFzc2VzLlJFUVVJUkVEXTogcmVxdWlyZWQsXHJcbiAgICAgICAgW2Nzc0NsYXNzZXMuSU5WQUxJRF06IGlzSW52YWxpZCxcclxuICAgICAgICBbY3NzQ2xhc3Nlcy5OT19MQUJFTF06ICFsYWJlbCxcclxuICAgICAgICBbY3NzQ2xhc3Nlcy5XSVRIX0xFQURJTkdfSUNPTl06IGxlYWRpbmdJY29uXHJcbiAgICB9LCBjbGFzc05hbWUpO1xyXG5cclxuICAgIHJldHVybiAoPD5cclxuICAgICAgICA8ZGl2IHJlZj17cmVmfSBjbGFzc05hbWU9e2NsYXNzTmFtZXN9PlxyXG4gICAgICAgICAgICB7bmFtZSAmJlxyXG4gICAgICAgICAgICAgICAgPGlucHV0XHJcbiAgICAgICAgICAgICAgICAgICAgcmVmPXtpbnB1dFJlZn1cclxuICAgICAgICAgICAgICAgICAgICB0eXBlPVwiaGlkZGVuXCJcclxuICAgICAgICAgICAgICAgICAgICBuYW1lPXtuYW1lfVxyXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlPXt2YWx1ZX1cclxuICAgICAgICAgICAgICAgICAgICByZXF1aXJlZD17cmVxdWlyZWR9XHJcbiAgICAgICAgICAgICAgICAgICAgZGlzYWJsZWQ9e2Rpc2FibGVkfVxyXG4gICAgICAgICAgICAgICAgICAgIHsuLi5wcm9wc31cclxuICAgICAgICAgICAgICAgIC8+XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIDxkaXZcclxuICAgICAgICAgICAgICAgIHJlZj17YW5jaG9yUmVmfVxyXG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lPXtjc3NDbGFzc2VzLkFOQ0hPUn1cclxuICAgICAgICAgICAgICAgIGFyaWEtcmVxdWlyZWQ9e3JlcXVpcmVkIHx8IHVuZGVmaW5lZH1cclxuICAgICAgICAgICAgICAgIHRhYkluZGV4PXshZGlzYWJsZWQgPyAwIDogdW5kZWZpbmVkfVxyXG4gICAgICAgICAgICAgICAgb25LZXlEb3duPXtoYW5kbGVLZXlEb3dufVxyXG4gICAgICAgICAgICAgICAgb25DbGljaz17aGFuZGxlQW5jaG9yQ2xpY2t9XHJcbiAgICAgICAgICAgID5cclxuICAgICAgICAgICAgICAgIHtmaWxsZWQgJiZcclxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17Y3NzQ2xhc3Nlcy5SSVBQTEV9IC8+XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAge2ZpbGxlZCAmJiBsYWJlbCAmJlxyXG4gICAgICAgICAgICAgICAgICAgIDxGbG9hdGluZ0xhYmVsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsPXtsYWJlbH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZmxvYXQ9e2ZvY3VzZWRPckhhc1ZhbHVlfVxyXG4gICAgICAgICAgICAgICAgICAgIC8+XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAge291dGxpbmVkICYmXHJcbiAgICAgICAgICAgICAgICAgICAgPE5vdGNoZWRPdXRsaW5lIG5vdGNoZWQ9e2ZvY3VzZWRPckhhc1ZhbHVlfT5cclxuICAgICAgICAgICAgICAgICAgICAgICAge2xhYmVsICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8RmxvYXRpbmdMYWJlbFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsPXtsYWJlbH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmbG9hdD17Zm9jdXNlZE9ySGFzVmFsdWV9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgPC9Ob3RjaGVkT3V0bGluZT5cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICB7bGVhZGluZ0ljb24gJiZcclxuICAgICAgICAgICAgICAgICAgICA8Q2xvbmVcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50PXtsZWFkaW5nSWNvbn1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZmFsbGJhY2s9e0ljb259XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT17Y3NzQ2xhc3Nlcy5JQ09OfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0YWJJbmRleD1cIjBcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICByb2xlPVwiYnV0dG9uXCJcclxuICAgICAgICAgICAgICAgICAgICAvPlxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT17Y3NzQ2xhc3Nlcy5TRUxFQ1RFRF9URVhUX0NPTlRBSU5FUn0+XHJcbiAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3NOYW1lPXtjc3NDbGFzc2VzLlNFTEVDVEVEX1RFWFR9PntzZWxlY3RlZFRleHR9PC9zcGFuPlxyXG4gICAgICAgICAgICAgICAgPC9zcGFuPlxyXG5cclxuICAgICAgICAgICAgICAgIDxEcm9wZG93bkljb24gLz5cclxuXHJcbiAgICAgICAgICAgICAgICB7ZmlsbGVkICYmXHJcbiAgICAgICAgICAgICAgICAgICAgPExpbmVSaXBwbGVcclxuICAgICAgICAgICAgICAgICAgICAgICAgYWN0aXZlPXtmb2N1c2VkfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm1PcmlnaW49e2ludGVyYWN0aW9uQ29vcmRzPy54fVxyXG4gICAgICAgICAgICAgICAgICAgIC8+XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIDwvZGl2PlxyXG5cclxuICAgICAgICAgICAgPE1lbnVcclxuICAgICAgICAgICAgICAgIHJlZj17bWVudVJlZn1cclxuICAgICAgICAgICAgICAgIGFuY2hvclJlZj17YW5jaG9yUmVmfVxyXG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lPXtjc3NDbGFzc2VzLk1FTlV9XHJcbiAgICAgICAgICAgICAgICBvcGVuPXthY3RpdmF0ZWR9XHJcbiAgICAgICAgICAgICAgICBhbmNob3JPcmlnaW49e01lbnVPcmlnaW4uQk9UVE9NX0NFTlRFUn1cclxuICAgICAgICAgICAgICAgIHRyYW5zZm9ybU9yaWdpbj17TWVudU9yaWdpbi5UT1BfQ0VOVEVSfVxyXG4gICAgICAgICAgICAgICAgZnVsbFdpZHRoXHJcbiAgICAgICAgICAgICAgICBsaXN0UHJvcHM9e2xpc3RQcm9wc31cclxuICAgICAgICAgICAgICAgIG9uQ2xvc2U9e2hhbmRsZU1lbnVDbG9zZX1cclxuICAgICAgICAgICAgICAgIHsuLi5tZW51UHJvcHN9XHJcbiAgICAgICAgICAgID5cclxuICAgICAgICAgICAgICAgIHtDaGlsZHJlbi5tYXAoY2hpbGRyZW4sIG9wdGlvbiA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgb3B0aW9uVmFsdWUgPSBvcHRpb24ucHJvcHMudmFsdWU7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjbG9uZShvcHRpb24sIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHVuZGVmaW5lZCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgJ2RhdGEtdmFsdWUnOiBvcHRpb25WYWx1ZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0ZWQ6ICFpc1VuZGVmaW5lZCh2YWx1ZSkgJiYgKG11bHRpcGxlID8gdmFsdWUuaW5jbHVkZXMob3B0aW9uVmFsdWUpIDogb3B0aW9uVmFsdWUgPT09IHZhbHVlKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2hlY2tib3g6IG11bHRpcGxlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBvbkNsaWNrOiBoYW5kbGVPcHRpb25JbnRlcmFjdGlvbixcclxuICAgICAgICAgICAgICAgICAgICAgICAgb25LZXlEb3duOiBoYW5kbGVPcHRpb25JbnRlcmFjdGlvblxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfSl9XHJcbiAgICAgICAgICAgIDwvTWVudT5cclxuICAgICAgICA8L2Rpdj5cclxuXHJcbiAgICAgICAge2hlbHBlclRleHQgJiZcclxuICAgICAgICAgICAgPEhlbHBlclRleHQgey4uLmhlbHBlclRleHRQcm9wc30+e2hlbHBlclRleHR9PC9IZWxwZXJUZXh0PlxyXG4gICAgICAgIH1cclxuICAgIDwvPik7XHJcbn0pO1xyXG5cclxuU2VsZWN0LmRpc3BsYXlOYW1lID0gJ01EQ1NlbGVjdCc7XHJcblxyXG5TZWxlY3QucHJvcFR5cGVzID0ge1xyXG4gICAgdmFsdWU6IFByb3BUeXBlcy5hbnksXHJcbiAgICBvcHRpb25zOiBQcm9wVHlwZXMuYXJyYXlPZihQcm9wVHlwZXMub2JqZWN0KSxcclxuICAgIGxhYmVsOiBQcm9wVHlwZXMuc3RyaW5nLFxyXG4gICAgbGVhZGluZ0ljb246IFByb3BUeXBlcy5lbGVtZW50LFxyXG4gICAgaGVscGVyVGV4dDogUHJvcFR5cGVzLnN0cmluZyxcclxuICAgIGZpbGxlZDogUHJvcFR5cGVzLmJvb2wsXHJcbiAgICBvdXRsaW5lZDogUHJvcFR5cGVzLmJvb2wsXHJcbiAgICBtdWx0aXBsZTogUHJvcFR5cGVzLmJvb2wsXHJcbiAgICBkaXNhYmxlZDogUHJvcFR5cGVzLmJvb2wsXHJcbiAgICByZXF1aXJlZDogUHJvcFR5cGVzLmJvb2wsXHJcbiAgICBjaGlsZHJlbjogUHJvcFR5cGVzLm9uZU9mVHlwZShbXHJcbiAgICAgICAgUHJvcFR5cGVzLmVsZW1lbnQsXHJcbiAgICAgICAgUHJvcFR5cGVzLmFycmF5T2YoUHJvcFR5cGVzLmVsZW1lbnQpXHJcbiAgICBdKSxcclxuICAgIG1lbnVQcm9wczogUHJvcFR5cGVzLm9iamVjdCxcclxuICAgIGhlbHBlclRleHRQcm9wczogUHJvcFR5cGVzLm9iamVjdCxcclxuICAgIG9uQ2hhbmdlOiBQcm9wVHlwZXMuZnVuY1xyXG59O1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgU2VsZWN0OyIsImltcG9ydCBTZWxlY3QgZnJvbSAnLi9TZWxlY3QnO1xyXG5pbXBvcnQgU2VsZWN0T3B0aW9uIGZyb20gJy4vU2VsZWN0T3B0aW9uJztcclxuXHJcblNlbGVjdC5PcHRpb24gPSBTZWxlY3RPcHRpb247XHJcblxyXG5leHBvcnQge1xyXG4gICAgU2VsZWN0IGFzIGRlZmF1bHQsXHJcbiAgICBTZWxlY3RPcHRpb25cclxufTsiLCJpbXBvcnQgeyBmb3J3YXJkUmVmIH0gZnJvbSAncmVhY3QnO1xyXG5pbXBvcnQgY2xhc3NuYW1lcyBmcm9tICdjbGFzc25hbWVzJztcclxuXHJcbmltcG9ydCBJY29uQnV0dG9uIGZyb20gJy4uL2ljb24tYnV0dG9uJztcclxuaW1wb3J0IFNlbGVjdCBmcm9tICcuLi9zZWxlY3QnO1xyXG5cclxuaW1wb3J0IHsgY3NzQ2xhc3NlcyB9IGZyb20gJy4vY29uc3RhbnRzJztcclxuXHJcbmNvbnN0IERhdGFUYWJsZVBhZ2luYXRpb24gPSBmb3J3YXJkUmVmKCh7XHJcbiAgICB0b3RhbENvdW50LFxyXG4gICAgY3VycmVudFBhZ2UgPSAxLFxyXG4gICAgcm93c1BlclBhZ2UgPSAxMCxcclxuICAgIG9uRmlyc3RQYWdlID0gRnVuY3Rpb24ucHJvdG90eXBlLFxyXG4gICAgb25QcmV2UGFnZSA9IEZ1bmN0aW9uLnByb3RvdHlwZSxcclxuICAgIG9uTmV4dFBhZ2UgPSBGdW5jdGlvbi5wcm90b3R5cGUsXHJcbiAgICBvbkxhc3RQYWdlID0gRnVuY3Rpb24ucHJvdG90eXBlLFxyXG5cclxuICAgIGNsYXNzTmFtZSxcclxuICAgIC4uLnByb3BzXHJcbn0sIHJlZikgPT4ge1xyXG4gICAgY29uc3QgY2xhc3NOYW1lcyA9IGNsYXNzbmFtZXMoY3NzQ2xhc3Nlcy5QQUdJTkFUSU9OLCBjbGFzc05hbWUpO1xyXG5cclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgPGRpdiByZWY9e3JlZn0gY2xhc3NOYW1lPXtjbGFzc05hbWVzfSB7Li4ucHJvcHN9PlxyXG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17Y3NzQ2xhc3Nlcy5QQUdJTkFUSU9OX1RSQUlMSU5HfT5cclxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXtjc3NDbGFzc2VzLlBBR0lOQVRJT05fUk9XU19QRVJfUEFHRX0+XHJcbiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9e2Nzc0NsYXNzZXMuUEFHSU5BVElPTl9ST1dTX1BFUl9QQUdFX0xBQkVMfT5cclxuICAgICAgICAgICAgICAgICAgICAgICAg0KDRj9C00L7QsiDQvdCwINGB0YLRgC5cclxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgPFNlbGVjdFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU9e2Nzc0NsYXNzZXMuUEFHSU5BVElPTl9ST1dTX1BFUl9QQUdFX1NFTEVDVH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucz17XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBbMTAsIDI1LCA1MCwgMTAwXS5tYXAodmFsdWUgPT4gKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZXk6IHZhbHVlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ6IHZhbHVlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vc2VsZWN0ZWQ6IHZhbHVlID09PSByb3dzUGVyUGFnZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAvPlxyXG4gICAgICAgICAgICAgICAgPC9kaXY+XHJcblxyXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9e2Nzc0NsYXNzZXMuUEFHSU5BVElPTl9OQVZJR0FUSU9OfT5cclxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17Y3NzQ2xhc3Nlcy5QQUdJTkFUSU9OX1RPVEFMfT5cclxuICAgICAgICAgICAgICAgICAgICAgICAge2N1cnJlbnRQYWdlfeKAkXtyb3dzUGVyUGFnZX0g0LjQtyB7dG90YWxDb3VudH1cclxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgPEljb25CdXR0b25cclxuICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPXtjc3NDbGFzc2VzLlBBR0lOQVRJT05fQlVUVE9OfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpY29uPVwiZmlyc3RfcGFnZVwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2xpY2s9e29uRmlyc3RQYWdlfVxyXG4gICAgICAgICAgICAgICAgICAgIC8+XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIDxJY29uQnV0dG9uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT17Y3NzQ2xhc3Nlcy5QQUdJTkFUSU9OX0JVVFRPTn1cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWNvbj1cImNoZXZyb25fbGVmdFwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2xpY2s9e29uUHJldlBhZ2V9XHJcbiAgICAgICAgICAgICAgICAgICAgLz5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgPEljb25CdXR0b25cclxuICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPXtjc3NDbGFzc2VzLlBBR0lOQVRJT05fQlVUVE9OfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpY29uPVwiY2hldnJvbl9yaWdodFwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2xpY2s9e29uTmV4dFBhZ2V9XHJcbiAgICAgICAgICAgICAgICAgICAgLz5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgPEljb25CdXR0b25cclxuICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPXtjc3NDbGFzc2VzLlBBR0lOQVRJT05fQlVUVE9OfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpY29uPVwibGFzdF9wYWdlXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgb25DbGljaz17b25MYXN0UGFnZX1cclxuICAgICAgICAgICAgICAgICAgICAvPlxyXG4gICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgIDwvZGl2PlxyXG4gICAgKTtcclxufSk7XHJcblxyXG5EYXRhVGFibGVQYWdpbmF0aW9uLmRpc3BsYXlOYW1lID0gJ01EQ0RhdGFUYWJsZVBhZ2luYXRpb24nO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgRGF0YVRhYmxlUGFnaW5hdGlvbjsiLCJpbXBvcnQgeyBmb3J3YXJkUmVmIH0gZnJvbSAncmVhY3QnO1xyXG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xyXG5pbXBvcnQgY2xhc3NuYW1lcyBmcm9tICdjbGFzc25hbWVzJztcclxuXHJcbmltcG9ydCBEYXRhVGFibGVQcm9ncmVzc0luZGljYXRvciBmcm9tICcuL0RhdGFUYWJsZVByb2dyZXNzSW5kaWNhdG9yJztcclxuaW1wb3J0IERhdGFUYWJsZVBhZ2luYXRpb24gZnJvbSAnLi9EYXRhVGFibGVQYWdpbmF0aW9uJztcclxuaW1wb3J0IHsgY3NzQ2xhc3NlcyB9IGZyb20gJy4vY29uc3RhbnRzJztcclxuXHJcbmNvbnN0IERhdGFUYWJsZSA9IGZvcndhcmRSZWYoKHtcclxuICAgIHN0aWNreUhlYWRlciA9IGZhbHNlLFxyXG4gICAgaW5Qcm9ncmVzcyA9IGZhbHNlLFxyXG4gICAgcGFnaW5hdGlvbixcclxuXHJcbiAgICBjbGFzc05hbWUsXHJcbiAgICBjaGlsZHJlbixcclxuICAgIC4uLnByb3BzXHJcbn0sIHJlZikgPT4ge1xyXG4gICAgY29uc3QgY2xhc3NOYW1lcyA9IGNsYXNzbmFtZXMoY3NzQ2xhc3Nlcy5ST09ULCB7XHJcbiAgICAgICAgW2Nzc0NsYXNzZXMuU1RJQ0tZX0hFQURFUl06IHN0aWNreUhlYWRlcixcclxuICAgICAgICBbY3NzQ2xhc3Nlcy5JTl9QUk9HUkVTU106IGluUHJvZ3Jlc3NcclxuICAgIH0sIGNsYXNzTmFtZSk7XHJcblxyXG4gICAgcmV0dXJuIChcclxuICAgICAgICA8ZGl2IHJlZj17cmVmfSBjbGFzc05hbWU9e2NsYXNzTmFtZXN9IHsuLi5wcm9wc30+XHJcbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXtjc3NDbGFzc2VzLlRBQkxFX0NPTlRBSU5FUn0+XHJcbiAgICAgICAgICAgICAgICA8dGFibGUgY2xhc3NOYW1lPXtjc3NDbGFzc2VzLlRBQkxFfT5cclxuICAgICAgICAgICAgICAgICAgICB7Y2hpbGRyZW59XHJcbiAgICAgICAgICAgICAgICA8L3RhYmxlPlxyXG4gICAgICAgICAgICA8L2Rpdj5cclxuXHJcbiAgICAgICAgICAgIHtpblByb2dyZXNzICYmXHJcbiAgICAgICAgICAgICAgICA8RGF0YVRhYmxlUHJvZ3Jlc3NJbmRpY2F0b3IgLz5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAge3BhZ2luYXRpb24gJiZcclxuICAgICAgICAgICAgICAgIDxEYXRhVGFibGVQYWdpbmF0aW9uIHsuLi5wYWdpbmF0aW9ufSAvPlxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgPC9kaXY+XHJcbiAgICApO1xyXG59KTtcclxuXHJcbkRhdGFUYWJsZS5kaXNwbGF5TmFtZSA9ICdNRENEYXRhVGFibGUnO1xyXG5cclxuRGF0YVRhYmxlLnByb3BUeXBlcyA9IHtcclxuICAgIHN0aWNreUhlYWRlcjogUHJvcFR5cGVzLmJvb2wsXHJcbiAgICBpblByb2dyZXNzOiBQcm9wVHlwZXMuYm9vbFxyXG59O1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgRGF0YVRhYmxlOyIsImltcG9ydCB7IGZvcndhcmRSZWYgfSBmcm9tICdyZWFjdCc7XHJcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XHJcbmltcG9ydCBjbGFzc25hbWVzIGZyb20gJ2NsYXNzbmFtZXMnO1xyXG5cclxuaW1wb3J0IHsgQ2xvbmUgfSBmcm9tICcuLi9jb21wb25lbnQnO1xyXG5cclxuaW1wb3J0IHsgY3NzQ2xhc3NlcyB9IGZyb20gJy4vY29uc3RhbnRzJztcclxuXHJcbmNvbnN0IERhdGFUYWJsZUNlbGwgPSBmb3J3YXJkUmVmKCh7XHJcbiAgICBjaGVja2JveCA9IGZhbHNlLFxyXG4gICAgbnVtZXJpYyA9IGZhbHNlLFxyXG5cclxuICAgIGVsZW1lbnQ6IEVsZW1lbnQgPSAndGQnLFxyXG4gICAgc2NvcGUsXHJcbiAgICBjbGFzc05hbWUsXHJcbiAgICBjaGlsZHJlbixcclxuICAgIC4uLnByb3BzXHJcbn0sIHJlZikgPT4ge1xyXG4gICAgY29uc3QgY2xhc3NOYW1lcyA9IGNsYXNzbmFtZXMoY3NzQ2xhc3Nlcy5DRUxMLCB7XHJcbiAgICAgICAgW2Nzc0NsYXNzZXMuQ0VMTF9DSEVDS0JPWF06IGNoZWNrYm94LFxyXG4gICAgICAgIFtjc3NDbGFzc2VzLkNFTExfTlVNRVJJQ106IG51bWVyaWNcclxuICAgIH0sIGNsYXNzTmFtZSk7XHJcblxyXG4gICAgcmV0dXJuIChcclxuICAgICAgICA8RWxlbWVudCByZWY9e3JlZn0gY2xhc3NOYW1lPXtjbGFzc05hbWVzfSBzY29wZT17c2NvcGV9IHsuLi5wcm9wc30+XHJcbiAgICAgICAgICAgIHtjaGVja2JveCA/XHJcbiAgICAgICAgICAgICAgICA8Q2xvbmVcclxuICAgICAgICAgICAgICAgICAgICBjb21wb25lbnQ9e2NoaWxkcmVufVxyXG4gICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT17Y3NzQ2xhc3Nlcy5ST1dfQ0hFQ0tCT1h9XHJcbiAgICAgICAgICAgICAgICAvPlxyXG4gICAgICAgICAgICAgICAgOlxyXG4gICAgICAgICAgICAgICAgY2hpbGRyZW5cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIDwvRWxlbWVudD5cclxuICAgICk7XHJcbn0pO1xyXG5cclxuRGF0YVRhYmxlQ2VsbC5kaXNwbGF5TmFtZSA9ICdNRENEYXRhVGFibGVDZWxsJztcclxuXHJcbkRhdGFUYWJsZUNlbGwucHJvcFR5cGVzID0ge1xyXG4gICAgY2hlY2tib3g6IFByb3BUeXBlcy5ib29sLFxyXG4gICAgbnVtZXJpYzogUHJvcFR5cGVzLmJvb2xcclxufTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IERhdGFUYWJsZUNlbGw7IiwiaW1wb3J0IHsgZm9yd2FyZFJlZiB9IGZyb20gJ3JlYWN0JztcclxuaW1wb3J0IGNsYXNzbmFtZXMgZnJvbSAnY2xhc3NuYW1lcyc7XHJcblxyXG5pbXBvcnQgeyBjc3NDbGFzc2VzIH0gZnJvbSAnLi9jb25zdGFudHMnO1xyXG5cclxuY29uc3QgRGF0YVRhYmxlQ29udGVudCA9IGZvcndhcmRSZWYoKHsgY2xhc3NOYW1lLCAuLi5wcm9wcyB9LCByZWYpID0+IHtcclxuICAgIGNvbnN0IGNsYXNzTmFtZXMgPSBjbGFzc25hbWVzKGNzc0NsYXNzZXMuQ09OVEVOVCwgY2xhc3NOYW1lKTtcclxuXHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAgIDx0Ym9keSByZWY9e3JlZn0gY2xhc3NOYW1lPXtjbGFzc05hbWVzfSB7Li4ucHJvcHN9IC8+XHJcbiAgICApO1xyXG59KTtcclxuXHJcbkRhdGFUYWJsZUNvbnRlbnQuZGlzcGxheU5hbWUgPSAnTURDRGF0YVRhYmxlQ29udGVudCc7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBEYXRhVGFibGVDb250ZW50OyIsImltcG9ydCB7IGZvcndhcmRSZWYgfSBmcm9tICdyZWFjdCc7XHJcbmltcG9ydCBjbGFzc25hbWVzIGZyb20gJ2NsYXNzbmFtZXMnO1xyXG5cclxuaW1wb3J0IHsgY3NzQ2xhc3NlcyB9IGZyb20gJy4vY29uc3RhbnRzJztcclxuXHJcbmNvbnN0IERhdGFUYWJsZUZvb3RlciA9IGZvcndhcmRSZWYoKHsgY2xhc3NOYW1lLCAuLi5wcm9wcyB9LCByZWYpID0+IHtcclxuICAgIGNvbnN0IGNsYXNzTmFtZXMgPSBjbGFzc25hbWVzKGNzc0NsYXNzZXMuRk9PVEVSLCBjbGFzc05hbWUpO1xyXG5cclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgPHRmb290IHJlZj17cmVmfSBjbGFzc05hbWU9e2NsYXNzTmFtZXN9IHsuLi5wcm9wc30gLz5cclxuICAgICk7XHJcbn0pO1xyXG5cclxuRGF0YVRhYmxlRm9vdGVyLmRpc3BsYXlOYW1lID0gJ01EQ0RhdGFUYWJsZUZvb3Rlcic7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBEYXRhVGFibGVGb290ZXI7IiwiaW1wb3J0IHsgZm9yd2FyZFJlZiB9IGZyb20gJ3JlYWN0JztcclxuaW1wb3J0IGNsYXNzbmFtZXMgZnJvbSAnY2xhc3NuYW1lcyc7XHJcblxyXG5pbXBvcnQgeyBjc3NDbGFzc2VzIH0gZnJvbSAnLi9jb25zdGFudHMnO1xyXG5cclxuY29uc3QgRGF0YVRhYmxlSGVhZGVyID0gZm9yd2FyZFJlZigoeyBjbGFzc05hbWUsIC4uLnByb3BzIH0sIHJlZikgPT4ge1xyXG4gICAgY29uc3QgY2xhc3NOYW1lcyA9IGNsYXNzbmFtZXMoY3NzQ2xhc3Nlcy5IRUFERVIsIGNsYXNzTmFtZSk7XHJcblxyXG4gICAgcmV0dXJuIChcclxuICAgICAgICA8dGhlYWQgcmVmPXtyZWZ9IGNsYXNzTmFtZT17Y2xhc3NOYW1lc30gey4uLnByb3BzfSAvPlxyXG4gICAgKTtcclxufSk7XHJcblxyXG5EYXRhVGFibGVIZWFkZXIuZGlzcGxheU5hbWUgPSAnTURDRGF0YVRhYmxlSGVhZGVyJztcclxuXHJcbmV4cG9ydCBkZWZhdWx0IERhdGFUYWJsZUhlYWRlcjsiLCJpbXBvcnQgeyBmb3J3YXJkUmVmLCB1c2VDYWxsYmFjayB9IGZyb20gJ3JlYWN0JztcclxuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcclxuaW1wb3J0IGNsYXNzbmFtZXMgZnJvbSAnY2xhc3NuYW1lcyc7XHJcblxyXG5pbXBvcnQgeyBDbG9uZSB9IGZyb20gJy4uL2NvbXBvbmVudCc7XHJcbmltcG9ydCBJY29uQnV0dG9uIGZyb20gJy4uL2ljb24tYnV0dG9uJztcclxuXHJcbmltcG9ydCB7IGNzc0NsYXNzZXMgfSBmcm9tICcuL2NvbnN0YW50cyc7XHJcblxyXG5jb25zdCBEYXRhVGFibGVIZWFkZXJDZWxsID0gZm9yd2FyZFJlZigoe1xyXG4gICAgdmFsdWUsXHJcbiAgICBsYWJlbCxcclxuICAgIGNoZWNrYm94ID0gZmFsc2UsXHJcbiAgICBudW1lcmljID0gZmFsc2UsXHJcbiAgICBzb3J0LFxyXG4gICAgc29ydEljb25CdXR0b24gPSAnYXJyb3dfdXB3YXJkJyxcclxuICAgIG9uU29ydCA9IEZ1bmN0aW9uLnByb3RvdHlwZSxcclxuXHJcbiAgICBlbGVtZW50OiBFbGVtZW50ID0gJ3RoJyxcclxuICAgIHJvbGUgPSAnY29sdW1uaGVhZGVyJyxcclxuICAgIHNjb3BlID0gJ2NvbCcsXHJcbiAgICBjbGFzc05hbWUsXHJcbiAgICBjaGlsZHJlbiA9IGxhYmVsLFxyXG4gICAgLi4ucHJvcHNcclxufSwgcmVmKSA9PiB7XHJcbiAgICBjb25zdCBoYW5kbGVTb3J0SWNvbkNsaWNrID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xyXG4gICAgICAgIG9uU29ydCh7IGxhYmVsLCB2YWx1ZSB9KTtcclxuICAgIH0sIFtsYWJlbCwgdmFsdWUsIG9uU29ydF0pO1xyXG5cclxuICAgIGNvbnN0IHdpdGhTb3J0ID0gdHlwZW9mIHNvcnQgPT09ICdudW1iZXInO1xyXG5cclxuICAgIGNvbnN0IGNsYXNzTmFtZXMgPSBjbGFzc25hbWVzKGNzc0NsYXNzZXMuSEVBREVSX0NFTEwsIHtcclxuICAgICAgICBbY3NzQ2xhc3Nlcy5IRUFERVJfQ0VMTF9DSEVDS0JPWF06IGNoZWNrYm94LFxyXG4gICAgICAgIFtjc3NDbGFzc2VzLkhFQURFUl9DRUxMX05VTUVSSUNdOiBudW1lcmljLFxyXG4gICAgICAgIFtjc3NDbGFzc2VzLkhFQURFUl9DRUxMX1dJVEhfU09SVF06IHdpdGhTb3J0LFxyXG4gICAgICAgIFtjc3NDbGFzc2VzLkhFQURFUl9DRUxMX1NPUlRFRF06IHNvcnQgPT09IDEgfHwgc29ydCA9PT0gLTEsXHJcbiAgICAgICAgW2Nzc0NsYXNzZXMuSEVBREVSX0NFTExfU09SVEVEX0RFU0NdOiBzb3J0ID09PSAtMVxyXG4gICAgfSwgY2xhc3NOYW1lKTtcclxuXHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAgIDxFbGVtZW50XHJcbiAgICAgICAgICAgIHJlZj17cmVmfVxyXG4gICAgICAgICAgICBjbGFzc05hbWU9e2NsYXNzTmFtZXN9XHJcbiAgICAgICAgICAgIHJvbGU9e3JvbGV9XHJcbiAgICAgICAgICAgIHNjb3BlPXtzY29wZX1cclxuICAgICAgICAgICAgey4uLnByb3BzfVxyXG4gICAgICAgID5cclxuICAgICAgICAgICAge3dpdGhTb3J0ID9cclxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXtjc3NDbGFzc2VzLkhFQURFUl9DRUxMX1dSQVBQRVJ9PlxyXG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXtjc3NDbGFzc2VzLkhFQURFUl9DRUxMX0xBQkVMfT5cclxuICAgICAgICAgICAgICAgICAgICAgICAge2NoaWxkcmVufVxyXG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PlxyXG5cclxuICAgICAgICAgICAgICAgICAgICA8Q2xvbmVcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50PXtzb3J0SWNvbkJ1dHRvbn1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZmFsbGJhY2s9e0ljb25CdXR0b259XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT17Y3NzQ2xhc3Nlcy5TT1JUX0lDT05fQlVUVE9OfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBvbkNsaWNrPXtoYW5kbGVTb3J0SWNvbkNsaWNrfVxyXG4gICAgICAgICAgICAgICAgICAgIC8+XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXtjc3NDbGFzc2VzLlNPUlRfU1RBVFVTX0xBQkVMfSBhcmlhLWhpZGRlbj1cInRydWVcIiAvPlxyXG4gICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICAgICA6XHJcbiAgICAgICAgICAgICAgICAoY2hlY2tib3ggP1xyXG4gICAgICAgICAgICAgICAgICAgIDxDbG9uZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb21wb25lbnQ9e2NoaWxkcmVufVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU9e2Nzc0NsYXNzZXMuSEVBREVSX1JPV19DSEVDS0JPWH1cclxuICAgICAgICAgICAgICAgICAgICAvPlxyXG4gICAgICAgICAgICAgICAgICAgIDpcclxuICAgICAgICAgICAgICAgICAgICBjaGlsZHJlblxyXG4gICAgICAgICAgICAgICAgKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgPC9FbGVtZW50PlxyXG4gICAgKTtcclxufSk7XHJcblxyXG5EYXRhVGFibGVIZWFkZXJDZWxsLmRpc3BsYXlOYW1lID0gJ01EQ0RhdGFUYWJsZUhlYWRlckNlbGwnO1xyXG5cclxuRGF0YVRhYmxlSGVhZGVyQ2VsbC5wcm9wVHlwZXMgPSB7XHJcbiAgICB2YWx1ZTogUHJvcFR5cGVzLmFueSxcclxuICAgIGxhYmVsOiBQcm9wVHlwZXMuc3RyaW5nLFxyXG4gICAgbnVtZXJpYzogUHJvcFR5cGVzLmJvb2wsXHJcbiAgICBjaGVja2JveDogUHJvcFR5cGVzLmJvb2wsXHJcbiAgICBzb3J0OiBQcm9wVHlwZXMub25lT2YoWy0xLCAwLCAxXSksXHJcbiAgICBzb3J0SWNvbkJ1dHRvbjogUHJvcFR5cGVzLm5vZGUsXHJcbiAgICBvblNvcnQ6IFByb3BUeXBlcy5mdW5jXHJcbn07XHJcblxyXG5leHBvcnQgZGVmYXVsdCBEYXRhVGFibGVIZWFkZXJDZWxsOyIsImltcG9ydCB7IGZvcndhcmRSZWYgfSBmcm9tICdyZWFjdCc7XHJcbmltcG9ydCBjbGFzc25hbWVzIGZyb20gJ2NsYXNzbmFtZXMnO1xyXG5cclxuaW1wb3J0IHsgY3NzQ2xhc3NlcyB9IGZyb20gJy4vY29uc3RhbnRzJztcclxuXHJcbmNvbnN0IERhdGFUYWJsZUhlYWRlclJvdyA9IGZvcndhcmRSZWYoKHsgY2xhc3NOYW1lLCAuLi5wcm9wcyB9LCByZWYpID0+IHtcclxuICAgIGNvbnN0IGNsYXNzTmFtZXMgPSBjbGFzc25hbWVzKGNzc0NsYXNzZXMuSEVBREVSX1JPVywgY2xhc3NOYW1lKTtcclxuXHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAgIDx0ciByZWY9e3JlZn0gY2xhc3NOYW1lPXtjbGFzc05hbWVzfSB7Li4ucHJvcHN9IC8+XHJcbiAgICApO1xyXG59KTtcclxuXHJcbkRhdGFUYWJsZUhlYWRlclJvdy5kaXNwbGF5TmFtZSA9ICdNRENEYXRhVGFibGVIZWFkZXJSb3cnO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgRGF0YVRhYmxlSGVhZGVyUm93OyIsImltcG9ydCB7IGZvcndhcmRSZWYgfSBmcm9tICdyZWFjdCc7XHJcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XHJcbmltcG9ydCBjbGFzc25hbWVzIGZyb20gJ2NsYXNzbmFtZXMnO1xyXG5cclxuaW1wb3J0IHsgY3NzQ2xhc3NlcyB9IGZyb20gJy4vY29uc3RhbnRzJztcclxuXHJcbmNvbnN0IERhdGFUYWJsZVJvdyA9IGZvcndhcmRSZWYoKHtcclxuICAgIHNlbGVjdGVkID0gZmFsc2UsXHJcblxyXG4gICAgY2xhc3NOYW1lLFxyXG4gICAgLi4ucHJvcHNcclxufSwgcmVmKSA9PiB7XHJcbiAgICBjb25zdCBjbGFzc05hbWVzID0gY2xhc3NuYW1lcyhjc3NDbGFzc2VzLlJPVywge1xyXG4gICAgICAgIFtjc3NDbGFzc2VzLlJPV19TRUxFQ1RFRF06IHNlbGVjdGVkXHJcbiAgICB9LCBjbGFzc05hbWUpO1xyXG5cclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgPHRyIHJlZj17cmVmfSBjbGFzc05hbWU9e2NsYXNzTmFtZXN9IHsuLi5wcm9wc30gLz5cclxuICAgICk7XHJcbn0pO1xyXG5cclxuRGF0YVRhYmxlUm93LmRpc3BsYXlOYW1lID0gJ01EQ0RhdGFUYWJsZVJvdyc7XHJcblxyXG5EYXRhVGFibGVSb3cucHJvcFR5cGVzID0ge1xyXG4gICAgc2VsZWN0ZWQ6IFByb3BUeXBlcy5ib29sXHJcbn07XHJcblxyXG5leHBvcnQgZGVmYXVsdCBEYXRhVGFibGVSb3c7IiwiaW1wb3J0IERhdGFUYWJsZSBmcm9tICcuL0RhdGFUYWJsZSc7XHJcbmltcG9ydCBEYXRhVGFibGVDZWxsIGZyb20gJy4vRGF0YVRhYmxlQ2VsbCc7XHJcbmltcG9ydCBEYXRhVGFibGVDb250ZW50IGZyb20gJy4vRGF0YVRhYmxlQ29udGVudCc7XHJcbmltcG9ydCBEYXRhVGFibGVGb290ZXIgZnJvbSAnLi9EYXRhVGFibGVGb290ZXInO1xyXG5pbXBvcnQgRGF0YVRhYmxlSGVhZGVyIGZyb20gJy4vRGF0YVRhYmxlSGVhZGVyJztcclxuaW1wb3J0IERhdGFUYWJsZUhlYWRlckNlbGwgZnJvbSAnLi9EYXRhVGFibGVIZWFkZXJDZWxsJztcclxuaW1wb3J0IERhdGFUYWJsZUhlYWRlclJvdyBmcm9tICcuL0RhdGFUYWJsZUhlYWRlclJvdyc7XHJcbmltcG9ydCBEYXRhVGFibGVQYWdpbmF0aW9uIGZyb20gJy4vRGF0YVRhYmxlUGFnaW5hdGlvbic7XHJcbmltcG9ydCBEYXRhVGFibGVSb3cgZnJvbSAnLi9EYXRhVGFibGVSb3cnO1xyXG5cclxuRGF0YVRhYmxlLkNlbGwgPSBEYXRhVGFibGVDZWxsO1xyXG5EYXRhVGFibGUuQ29udGVudCA9IERhdGFUYWJsZUNvbnRlbnQ7XHJcbkRhdGFUYWJsZS5Gb290ZXIgPSBEYXRhVGFibGVGb290ZXI7XHJcbkRhdGFUYWJsZS5IZWFkZXIgPSBEYXRhVGFibGVIZWFkZXI7XHJcbkRhdGFUYWJsZS5IZWFkZXJDZWxsID0gRGF0YVRhYmxlSGVhZGVyQ2VsbDtcclxuRGF0YVRhYmxlLkhlYWRlclJvdyA9IERhdGFUYWJsZUhlYWRlclJvdztcclxuRGF0YVRhYmxlLlBhZ2luYXRpb24gPSBEYXRhVGFibGVQYWdpbmF0aW9uO1xyXG5EYXRhVGFibGUuUm93ID0gRGF0YVRhYmxlUm93O1xyXG5cclxuZXhwb3J0IHtcclxuICAgIERhdGFUYWJsZSBhcyBkZWZhdWx0LFxyXG4gICAgRGF0YVRhYmxlQ2VsbCxcclxuICAgIERhdGFUYWJsZUNvbnRlbnQsXHJcbiAgICBEYXRhVGFibGVGb290ZXIsXHJcbiAgICBEYXRhVGFibGVIZWFkZXIsXHJcbiAgICBEYXRhVGFibGVIZWFkZXJDZWxsLFxyXG4gICAgRGF0YVRhYmxlSGVhZGVyUm93LFxyXG4gICAgRGF0YVRhYmxlUGFnaW5hdGlvbixcclxuICAgIERhdGFUYWJsZVJvd1xyXG59OyIsImV4cG9ydCBjb25zdCBudW1iZXJzID0ge1xyXG4gICAgRElBTE9HX0FOSU1BVElPTl9PUEVOX1RJTUVfTVM6IDE1MCxcclxuICAgIERJQUxPR19BTklNQVRJT05fQ0xPU0VfVElNRV9NUzogNzUsXHJcbiAgICBERUZBVUxUX0FDVElPTlNfSEVJR0hUOiA1MlxyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IGNzc0NsYXNzZXMgPSB7XHJcbiAgICBST09UOiAnbWRjLWRpYWxvZycsXHJcbiAgICBIRUFERVI6ICdtZGMtZGlhbG9nX19oZWFkZXInLFxyXG4gICAgVElUTEU6ICdtZGMtZGlhbG9nX190aXRsZScsXHJcbiAgICBDTE9TRTogJ21kYy1kaWFsb2dfX2Nsb3NlJyxcclxuICAgIENPTlRFTlQ6ICdtZGMtZGlhbG9nX19jb250ZW50JyxcclxuICAgIENPTlRBSU5FUjogJ21kYy1kaWFsb2dfX2NvbnRhaW5lcicsXHJcbiAgICBBQ1RJT05TOiAnbWRjLWRpYWxvZ19fYWN0aW9ucycsXHJcbiAgICBCVVRUT046ICdtZGMtZGlhbG9nX19idXR0b24nLFxyXG4gICAgU1VSRkFDRTogJ21kYy1kaWFsb2dfX3N1cmZhY2UnLFxyXG4gICAgU0NSSU06ICdtZGMtZGlhbG9nX19zY3JpbScsXHJcblxyXG4gICAgT1BFTjogJ21kYy1kaWFsb2ctLW9wZW4nLFxyXG4gICAgT1BFTklORzogJ21kYy1kaWFsb2ctLW9wZW5pbmcnLFxyXG4gICAgQ0xPU0lORzogJ21kYy1kaWFsb2ctLWNsb3NpbmcnLFxyXG4gICAgRlVMTFNDUkVFTjogJ21kYy1kaWFsb2ctLWZ1bGxzY3JlZW4nLFxyXG4gICAgU0NST0xMQUJMRTogJ21kYy1kaWFsb2ctLXNjcm9sbGFibGUnLFxyXG4gICAgU1RBQ0tFRDogJ21kYy1kaWFsb2ctLXN0YWNrZWQnLFxyXG5cclxuICAgIFNDUk9MTF9ESVZJREVSX0hFQURFUjogJ21kYy1kaWFsb2ctc2Nyb2xsLWRpdmlkZXItaGVhZGVyJyxcclxuICAgIFNDUk9MTF9ESVZJREVSX0ZPT1RFUjogJ21kYy1kaWFsb2ctc2Nyb2xsLWRpdmlkZXItZm9vdGVyJyxcclxuICAgIFNDUk9MTF9MT0NLOiAnbWRjLWRpYWxvZy1zY3JvbGwtbG9jaydcclxufTsiLCJpbXBvcnQgeyBmb3J3YXJkUmVmIH0gZnJvbSAncmVhY3QnO1xyXG5cclxuaW1wb3J0IHsgQ2xvbmUgfSBmcm9tICcuLi9jb21wb25lbnQnO1xyXG5pbXBvcnQgSWNvbkJ1dHRvbiBmcm9tICcuLi9pY29uLWJ1dHRvbic7XHJcblxyXG5pbXBvcnQgeyBjc3NDbGFzc2VzIH0gZnJvbSAnLi9jb25zdGFudHMnO1xyXG5cclxuY29uc3QgRGlhbG9nSGVhZGVyID0gZm9yd2FyZFJlZigoe1xyXG4gICAgdGl0bGUsXHJcbiAgICBjbG9zZUljb24sXHJcbiAgICBmdWxsc2NyZWVuLFxyXG4gICAgb25DbG9zZSxcclxuXHJcbiAgICBjaGlsZHJlbixcclxuICAgIC4uLnByb3BzXHJcbn0sIHJlZikgPT4ge1xyXG4gICAgcmV0dXJuIChcclxuICAgICAgICA8ZGl2IHJlZj17cmVmfSBjbGFzc05hbWU9e2Nzc0NsYXNzZXMuSEVBREVSfSB7Li4ucHJvcHN9PlxyXG4gICAgICAgICAgICA8Q2xvbmVcclxuICAgICAgICAgICAgICAgIGNvbXBvbmVudD17dGl0bGV9XHJcbiAgICAgICAgICAgICAgICBmYWxsYmFjaz1cImgyXCJcclxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZT17Y3NzQ2xhc3Nlcy5USVRMRX1cclxuICAgICAgICAgICAgLz5cclxuXHJcbiAgICAgICAgICAgIHsoZnVsbHNjcmVlbiB8fCBjbG9zZUljb24pICYmXHJcbiAgICAgICAgICAgICAgICA8Q2xvbmVcclxuICAgICAgICAgICAgICAgICAgICBjb21wb25lbnQ9e2Nsb3NlSWNvbn1cclxuICAgICAgICAgICAgICAgICAgICBmYWxsYmFjaz17PEljb25CdXR0b24gaWNvbj1cImNsb3NlXCIgLz59XHJcbiAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPXtjc3NDbGFzc2VzLkNMT1NFfVxyXG4gICAgICAgICAgICAgICAgICAgIG9uQ2xpY2s9e29uQ2xvc2V9XHJcbiAgICAgICAgICAgICAgICAvPlxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB7Y2hpbGRyZW59XHJcbiAgICAgICAgPC9kaXY+XHJcbiAgICApO1xyXG59KTtcclxuXHJcbkRpYWxvZ0hlYWRlci5kaXNwbGF5TmFtZSA9ICdNRENEaWFsb2dIZWFkZXInO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgRGlhbG9nSGVhZGVyOyIsImltcG9ydCB7IGZvcndhcmRSZWYgfSBmcm9tICdyZWFjdCc7XHJcblxyXG5pbXBvcnQgeyBjc3NDbGFzc2VzIH0gZnJvbSAnLi9jb25zdGFudHMnO1xyXG5cclxuY29uc3QgRGlhbG9nQ29udGVudCA9IGZvcndhcmRSZWYoKHByb3BzLCByZWYpID0+IHtcclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgPGRpdiByZWY9e3JlZn0gY2xhc3NOYW1lPXtjc3NDbGFzc2VzLkNPTlRFTlR9IHsuLi5wcm9wc30gLz5cclxuICAgICk7XHJcbn0pO1xyXG5cclxuRGlhbG9nQ29udGVudC5kaXNwbGF5TmFtZSA9ICdNRENEaWFsb2dDb250ZW50JztcclxuXHJcbmV4cG9ydCBkZWZhdWx0IERpYWxvZ0NvbnRlbnQ7IiwiaW1wb3J0IHsgZm9yd2FyZFJlZiB9IGZyb20gJ3JlYWN0JztcclxuXHJcbmltcG9ydCB7IENsb25lIH0gZnJvbSAnLi4vY29tcG9uZW50JztcclxuXHJcbmltcG9ydCB7IGNzc0NsYXNzZXMgfSBmcm9tICcuL2NvbnN0YW50cyc7XHJcblxyXG5jb25zdCBEaWFsb2dBY3Rpb25zID0gZm9yd2FyZFJlZigoeyBjaGlsZHJlbiB9LCByZWYpID0+IHtcclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgPGRpdiByZWY9e3JlZn0gY2xhc3NOYW1lPXtjc3NDbGFzc2VzLkFDVElPTlN9PlxyXG4gICAgICAgICAgICA8Q2xvbmVcclxuICAgICAgICAgICAgICAgIGNvbXBvbmVudD17Y2hpbGRyZW59XHJcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU9e2Nzc0NsYXNzZXMuQlVUVE9OfVxyXG4gICAgICAgICAgICAvPlxyXG4gICAgICAgIDwvZGl2PlxyXG4gICAgKTtcclxufSk7XHJcblxyXG5EaWFsb2dBY3Rpb25zLmRpc3BsYXlOYW1lID0gJ01EQ0RpYWxvZ0FjdGlvbnMnO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgRGlhbG9nQWN0aW9uczsiLCJpbXBvcnQgeyBmb3J3YXJkUmVmLCB1c2VSZWYsIHVzZUNhbGxiYWNrLCB1c2VJbXBlcmF0aXZlSGFuZGxlIH0gZnJvbSAncmVhY3QnO1xyXG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xyXG5pbXBvcnQgY2xhc3NuYW1lcyBmcm9tICdjbGFzc25hbWVzJztcclxuXHJcbmltcG9ydCB7IHVzZVVwZGF0ZWQsIHVzZVVubW91bnRlZCB9IGZyb20gJy4uL2hvb2tzJztcclxuaW1wb3J0IExheWVyIGZyb20gJy4uL2xheWVyJztcclxuXHJcbmltcG9ydCB7IG51bWJlcnMsIGNzc0NsYXNzZXMgfSBmcm9tICcuL2NvbnN0YW50cyc7XHJcbmltcG9ydCBEaWFsb2dIZWFkZXIgZnJvbSAnLi9EaWFsb2dIZWFkZXInO1xyXG5pbXBvcnQgRGlhbG9nQ29udGVudCBmcm9tICcuL0RpYWxvZ0NvbnRlbnQnO1xyXG5pbXBvcnQgRGlhbG9nQWN0aW9ucyBmcm9tICcuL0RpYWxvZ0FjdGlvbnMnO1xyXG5cclxuY29uc3QgRGlhbG9nID0gZm9yd2FyZFJlZigoe1xyXG4gICAgdGl0bGUsXHJcbiAgICBjb250ZW50LFxyXG4gICAgYWN0aW9ucyxcclxuICAgIGNsb3NlSWNvbixcclxuICAgIG9wZW4gPSBmYWxzZSxcclxuICAgIGFwcGVhciA9IGZhbHNlLFxyXG4gICAgcGVyc2lzdGVudCA9IGZhbHNlLFxyXG4gICAgZnVsbHNjcmVlbiA9IGZhbHNlLFxyXG4gICAgc3RhY2tlZCA9IGZhbHNlLFxyXG4gICAgYXV0b1N0YWNrQnV0dG9ucyA9IGZhbHNlLFxyXG4gICAgb25DbG9zZSA9IEZ1bmN0aW9uLnByb3RvdHlwZSxcclxuXHJcbiAgICBlbGVtZW50OiBFbGVtZW50ID0gJ2RpdicsXHJcbiAgICBjbGFzc05hbWUsXHJcbiAgICBjaGlsZHJlbiA9IGNvbnRlbnQsXHJcbiAgICAuLi5wcm9wc1xyXG59LCByZWYpID0+IHtcclxuICAgIGNvbnN0IHJvb3RSZWYgPSB1c2VSZWYoKTtcclxuICAgIGNvbnN0IGNvbnRlbnRSZWYgPSB1c2VSZWYoKTtcclxuICAgIGNvbnN0IGFjdGlvbnNSZWYgPSB1c2VSZWYoKTtcclxuXHJcbiAgICB1c2VJbXBlcmF0aXZlSGFuZGxlKHJlZiwgKCkgPT4gcm9vdFJlZi5jdXJyZW50KTtcclxuXHJcbiAgICB1c2VVcGRhdGVkKCgpID0+IHtcclxuICAgICAgICBpZiAocGVyc2lzdGVudCkgcmV0dXJuO1xyXG5cclxuICAgICAgICBmdW5jdGlvbiBoYW5kbGVEb2N1bWVudEtleURvd24oZXZlbnQpIHtcclxuICAgICAgICAgICAgaWYgKGV2ZW50LmtleSA9PT0gJ0VzY2FwZScgfHwgZXZlbnQua2V5Q29kZSA9PT0gMjcpIHtcclxuICAgICAgICAgICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xyXG4gICAgICAgICAgICAgICAgb25DbG9zZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAob3Blbikge1xyXG4gICAgICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgaGFuZGxlRG9jdW1lbnRLZXlEb3duKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdrZXlkb3duJywgaGFuZGxlRG9jdW1lbnRLZXlEb3duKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiAoKSA9PiBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdrZXlkb3duJywgaGFuZGxlRG9jdW1lbnRLZXlEb3duKTtcclxuICAgIH0sIFtvcGVuLCBwZXJzaXN0ZW50LCBvbkNsb3NlXSk7XHJcblxyXG4gICAgdXNlVXBkYXRlZCgoKSA9PiB7XHJcbiAgICAgICAgaWYgKCFjb250ZW50UmVmLmN1cnJlbnQgfHwgIW9wZW4pIHJldHVybjtcclxuXHJcbiAgICAgICAgY29uc3QgY29udGVudEVsZW1lbnQgPSBjb250ZW50UmVmLmN1cnJlbnQ7XHJcbiAgICAgICAgY29uc3Qgc2hvdWxkU2Nyb2xsID0gY29udGVudEVsZW1lbnQuc2Nyb2xsSGVpZ2h0ID4gY29udGVudEVsZW1lbnQub2Zmc2V0SGVpZ2h0O1xyXG5cclxuICAgICAgICBpZiAoc2hvdWxkU2Nyb2xsKSB7XHJcbiAgICAgICAgICAgIHJvb3RSZWYuY3VycmVudC5jbGFzc0xpc3QuYWRkKGNzc0NsYXNzZXMuU0NST0xMQUJMRSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSwgW29wZW5dKTtcclxuXHJcbiAgICB1c2VVcGRhdGVkKCgpID0+IHtcclxuICAgICAgICBpZiAoIWFjdGlvbnNSZWYuY3VycmVudCB8fCAhb3BlbiB8fCAhYXV0b1N0YWNrQnV0dG9ucykgcmV0dXJuO1xyXG5cclxuICAgICAgICBjb25zdCBhY3Rpb25zRWxlbWVudCA9IGFjdGlvbnNSZWYuY3VycmVudDtcclxuXHJcbiAgICAgICAgaWYgKGFjdGlvbnNFbGVtZW50LmNsaWVudEhlaWdodCA+IG51bWJlcnMuREVGQVVMVF9BQ1RJT05TX0hFSUdIVCkge1xyXG4gICAgICAgICAgICByb290UmVmLmN1cnJlbnQuY2xhc3NMaXN0LmFkZChjc3NDbGFzc2VzLlNUQUNLRUQpO1xyXG4gICAgICAgIH1cclxuICAgIH0sIFtvcGVuLCBhdXRvU3RhY2tCdXR0b25zXSk7XHJcblxyXG4gICAgdXNlVXBkYXRlZCgoKSA9PiB7XHJcbiAgICAgICAgaWYgKCFjb250ZW50UmVmLmN1cnJlbnQgfHwgIWZ1bGxzY3JlZW4pIHJldHVybjtcclxuXHJcbiAgICAgICAgY29uc3QgY29udGVudEVsZW1lbnQgPSBjb250ZW50UmVmLmN1cnJlbnQ7XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIGhhbmRsZVNjcm9sbCgpIHtcclxuICAgICAgICAgICAgY29uc3QgaXNTY3JvbGxBdFRvcCA9IGNvbnRlbnRFbGVtZW50LnNjcm9sbFRvcCA9PT0gMDtcclxuICAgICAgICAgICAgY29uc3QgaXNTY3JvbGxBdEJvdHRvbSA9IE1hdGguY2VpbChjb250ZW50RWxlbWVudC5zY3JvbGxIZWlnaHQgLSBjb250ZW50RWxlbWVudC5zY3JvbGxUb3ApID09PSBjb250ZW50RWxlbWVudC5jbGllbnRIZWlnaHQ7XHJcblxyXG4gICAgICAgICAgICByb290UmVmLmN1cnJlbnQuY2xhc3NMaXN0LnRvZ2dsZShjc3NDbGFzc2VzLlNDUk9MTF9ESVZJREVSX0hFQURFUiwgIWlzU2Nyb2xsQXRUb3ApO1xyXG4gICAgICAgICAgICByb290UmVmLmN1cnJlbnQuY2xhc3NMaXN0LnRvZ2dsZShjc3NDbGFzc2VzLlNDUk9MTF9ESVZJREVSX0ZPT1RFUiwgIWlzU2Nyb2xsQXRCb3R0b20pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY29udGVudEVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgaGFuZGxlU2Nyb2xsKTtcclxuXHJcbiAgICAgICAgaWYgKG9wZW4pIHtcclxuICAgICAgICAgICAgaGFuZGxlU2Nyb2xsKCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gKCkgPT4gY29udGVudEVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgaGFuZGxlU2Nyb2xsKTtcclxuICAgIH0sIFtvcGVuLCBmdWxsc2NyZWVuXSk7XHJcblxyXG4gICAgdXNlVW5tb3VudGVkKCgpID0+IHtcclxuICAgICAgICBkb2N1bWVudC5ib2R5LmNsYXNzTGlzdC5yZW1vdmUoY3NzQ2xhc3Nlcy5TQ1JPTExfTE9DSyk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBjb25zdCBoYW5kbGVFbnRlciA9IHVzZUNhbGxiYWNrKCgpID0+IHtcclxuICAgICAgICBkb2N1bWVudC5ib2R5LmNsYXNzTGlzdC5hZGQoY3NzQ2xhc3Nlcy5TQ1JPTExfTE9DSyk7XHJcbiAgICB9LCBbXSk7XHJcblxyXG4gICAgY29uc3QgaGFuZGxlRXhpdGVkID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xyXG4gICAgICAgIGRvY3VtZW50LmJvZHkuY2xhc3NMaXN0LnJlbW92ZShjc3NDbGFzc2VzLlNDUk9MTF9MT0NLKTtcclxuICAgIH0sIFtdKTtcclxuXHJcbiAgICBjb25zdCBoYW5kbGVTY3JpbUNsaWNrID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xyXG4gICAgICAgIGlmIChwZXJzaXN0ZW50KSByZXR1cm47XHJcblxyXG4gICAgICAgIG9uQ2xvc2UoKTtcclxuICAgIH0sIFtwZXJzaXN0ZW50LCBvbkNsb3NlXSk7XHJcblxyXG4gICAgY29uc3QgY2xhc3NOYW1lcyA9IGNsYXNzbmFtZXMoY3NzQ2xhc3Nlcy5ST09ULCB7XHJcbiAgICAgICAgW2Nzc0NsYXNzZXMuRlVMTFNDUkVFTl06IGZ1bGxzY3JlZW4sXHJcbiAgICAgICAgW2Nzc0NsYXNzZXMuU1RBQ0tFRF06IHN0YWNrZWRcclxuICAgIH0sIGNsYXNzTmFtZSk7XHJcblxyXG4gICAgcmV0dXJuIChcclxuICAgICAgICA8TGF5ZXJcclxuICAgICAgICAgICAgbW9kYWxcclxuICAgICAgICAgICAgaW49e29wZW59XHJcbiAgICAgICAgICAgIGFwcGVhcj17YXBwZWFyfVxyXG4gICAgICAgICAgICB0aW1lb3V0PXt7XHJcbiAgICAgICAgICAgICAgICBlbnRlcjogbnVtYmVycy5ESUFMT0dfQU5JTUFUSU9OX09QRU5fVElNRV9NUyxcclxuICAgICAgICAgICAgICAgIGV4aXQ6IG51bWJlcnMuRElBTE9HX0FOSU1BVElPTl9DTE9TRV9USU1FX01TXHJcbiAgICAgICAgICAgIH19XHJcbiAgICAgICAgICAgIGNsYXNzTmFtZXM9e3tcclxuICAgICAgICAgICAgICAgIGFwcGVhcjogY3NzQ2xhc3Nlcy5PUEVOSU5HLFxyXG4gICAgICAgICAgICAgICAgYXBwZWFyQWN0aXZlOiBjc3NDbGFzc2VzLk9QRU4sXHJcbiAgICAgICAgICAgICAgICBlbnRlcjogY3NzQ2xhc3Nlcy5PUEVOSU5HLFxyXG4gICAgICAgICAgICAgICAgZW50ZXJBY3RpdmU6IGNzc0NsYXNzZXMuT1BFTixcclxuICAgICAgICAgICAgICAgIGVudGVyRG9uZTogY3NzQ2xhc3Nlcy5PUEVOLFxyXG4gICAgICAgICAgICAgICAgZXhpdDogY3NzQ2xhc3Nlcy5DTE9TSU5HXHJcbiAgICAgICAgICAgIH19XHJcbiAgICAgICAgICAgIG1vdW50T25FbnRlclxyXG4gICAgICAgICAgICB1bm1vdW50T25FeGl0XHJcbiAgICAgICAgICAgIG9uRW50ZXI9e2hhbmRsZUVudGVyfVxyXG4gICAgICAgICAgICBvbkV4aXRlZD17aGFuZGxlRXhpdGVkfVxyXG4gICAgICAgID5cclxuICAgICAgICAgICAgPEVsZW1lbnRcclxuICAgICAgICAgICAgICAgIHJlZj17cm9vdFJlZn1cclxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZT17Y2xhc3NOYW1lc31cclxuICAgICAgICAgICAgICAgIHsuLi5wcm9wc31cclxuICAgICAgICAgICAgPlxyXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9e2Nzc0NsYXNzZXMuQ09OVEFJTkVSfT5cclxuICAgICAgICAgICAgICAgICAgICA8ZGl2XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT17Y3NzQ2xhc3Nlcy5TVVJGQUNFfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByb2xlPVwiYWxlcnRkaWFsb2dcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBhcmlhLW1vZGFsPVwidHJ1ZVwiXHJcbiAgICAgICAgICAgICAgICAgICAgPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB7dGl0bGUgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxEaWFsb2dIZWFkZXJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aXRsZT17dGl0bGV9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xvc2VJY29uPXtjbG9zZUljb259XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnVsbHNjcmVlbj17ZnVsbHNjcmVlbn1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbkNsb3NlPXtvbkNsb3NlfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLz5cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAge2NoaWxkcmVuICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8RGlhbG9nQ29udGVudCByZWY9e2NvbnRlbnRSZWZ9PntjaGlsZHJlbn08L0RpYWxvZ0NvbnRlbnQ+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHthY3Rpb25zICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8RGlhbG9nQWN0aW9ucyByZWY9e2FjdGlvbnNSZWZ9PnthY3Rpb25zfTwvRGlhbG9nQWN0aW9ucz5cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICAgICAgPC9kaXY+XHJcblxyXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9e2Nzc0NsYXNzZXMuU0NSSU19IG9uQ2xpY2s9e2hhbmRsZVNjcmltQ2xpY2t9IC8+XHJcbiAgICAgICAgICAgIDwvRWxlbWVudD5cclxuICAgICAgICA8L0xheWVyPlxyXG4gICAgKTtcclxufSk7XHJcblxyXG5EaWFsb2cuZGlzcGxheU5hbWUgPSAnTURDRGlhbG9nJztcclxuXHJcbkRpYWxvZy5wcm9wVHlwZXMgPSB7XHJcbiAgICB0aXRsZTogUHJvcFR5cGVzLm5vZGUsXHJcbiAgICBjbG9zZUljb246IFByb3BUeXBlcy5ub2RlLFxyXG4gICAgY29udGVudDogUHJvcFR5cGVzLm5vZGUsXHJcbiAgICBhY3Rpb25zOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtcclxuICAgICAgICBQcm9wVHlwZXMubm9kZSxcclxuICAgICAgICBQcm9wVHlwZXMuYXJyYXlPZihQcm9wVHlwZXMubm9kZSlcclxuICAgIF0pLFxyXG4gICAgb3BlbjogUHJvcFR5cGVzLmJvb2wsXHJcbiAgICBhcHBlYXI6IFByb3BUeXBlcy5ib29sLFxyXG4gICAgY29uZmlybWF0aW9uOiBQcm9wVHlwZXMuYm9vbCxcclxuICAgIHBlcnNpc3RlbnQ6IFByb3BUeXBlcy5ib29sLFxyXG4gICAgc3RhY2tlZDogUHJvcFR5cGVzLmJvb2wsXHJcbiAgICBmdWxsc2NyZWVuOiBQcm9wVHlwZXMuYm9vbCxcclxuICAgIGF1dG9TdGFja0J1dHRvbnM6IFByb3BUeXBlcy5ib29sLFxyXG4gICAgb25DbG9zZTogUHJvcFR5cGVzLmZ1bmNcclxufTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IERpYWxvZzsiLCJpbXBvcnQgRGlhbG9nIGZyb20gJy4vRGlhbG9nJztcclxuaW1wb3J0IERpYWxvZ0hlYWRlciBmcm9tICcuL0RpYWxvZ0hlYWRlcic7XHJcbmltcG9ydCBEaWFsb2dDb250ZW50IGZyb20gJy4vRGlhbG9nQ29udGVudCc7XHJcbmltcG9ydCBEaWFsb2dBY3Rpb25zIGZyb20gJy4vRGlhbG9nQWN0aW9ucyc7XHJcblxyXG5EaWFsb2cuSGVhZGVyID0gRGlhbG9nSGVhZGVyO1xyXG5EaWFsb2cuQ29udGVudCA9IERpYWxvZ0NvbnRlbnQ7XHJcbkRpYWxvZy5BY3Rpb25zID0gRGlhbG9nQWN0aW9ucztcclxuXHJcbmV4cG9ydCB7XHJcbiAgICBEaWFsb2cgYXMgZGVmYXVsdCxcclxuICAgIERpYWxvZ0hlYWRlcixcclxuICAgIERpYWxvZ0NvbnRlbnQsXHJcbiAgICBEaWFsb2dBY3Rpb25zXHJcbn07IiwiZXhwb3J0IGNvbnN0IG51bWJlcnMgPSB7XHJcbiAgICBBTklNQVRJT05fRU5URVJfVElNRV9NUzogMjUwLFxyXG4gICAgQU5JTUFUSU9OX0VYSVRfVElNRV9NUzogMjAwXHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgY3NzQ2xhc3NlcyA9IHtcclxuICAgIFJPT1Q6ICdtZGMtZHJhd2VyJyxcclxuICAgIERJU01JU1NJQkxFOiAnbWRjLWRyYXdlci0tZGlzbWlzc2libGUnLFxyXG4gICAgTU9EQUw6ICdtZGMtZHJhd2VyLS1tb2RhbCcsXHJcbiAgICBPUEVOOiAnbWRjLWRyYXdlci0tb3BlbicsXHJcbiAgICBBTklNQVRFOiAnbWRjLWRyYXdlci0tYW5pbWF0ZScsXHJcbiAgICBPUEVOSU5HOiAnbWRjLWRyYXdlci0tb3BlbmluZycsXHJcbiAgICBDTE9TSU5HOiAnbWRjLWRyYXdlci0tY2xvc2luZycsXHJcblxyXG4gICAgQ09OVEVOVDogJ21kYy1kcmF3ZXJfX2NvbnRlbnQnLFxyXG4gICAgSEVBREVSOiAnbWRjLWRyYXdlcl9faGVhZGVyJyxcclxuICAgIFRJVExFOiAnbWRjLWRyYXdlcl9fdGl0bGUnLFxyXG4gICAgU1VCVElUTEU6ICdtZGMtZHJhd2VyX19zdWJ0aXRsZScsXHJcbiAgICBHUkFQSElDOiAnbWRjLWRyYXdlcl9fZ3JhcGhpYycsXHJcblxyXG4gICAgQVBQX0NPTlRFTlQ6ICdtZGMtZHJhd2VyLWFwcC1jb250ZW50JyxcclxuICAgIFNDUklNOiAnbWRjLWRyYXdlci1zY3JpbScsXHJcbn07IiwiaW1wb3J0IHsgZm9yd2FyZFJlZiwgdXNlUmVmLCB1c2VJbXBlcmF0aXZlSGFuZGxlLCB1c2VFZmZlY3QgfSBmcm9tICdyZWFjdCc7XHJcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XHJcbmltcG9ydCBjbGFzc25hbWVzIGZyb20gJ2NsYXNzbmFtZXMnO1xyXG5cclxuaW1wb3J0IExheWVyIGZyb20gJy4uL2xheWVyJztcclxuXHJcbmltcG9ydCB7IG51bWJlcnMsIGNzc0NsYXNzZXMgfSBmcm9tICcuL2NvbnN0YW50cyc7XHJcblxyXG5jb25zdCBEcmF3ZXIgPSBmb3J3YXJkUmVmKCh7XHJcbiAgICBvcGVuID0gZmFsc2UsXHJcbiAgICBhcHBlYXIgPSB0cnVlLFxyXG4gICAgZGlzbWlzc2libGUgPSBmYWxzZSxcclxuICAgIG1vZGFsID0gZmFsc2UsXHJcbiAgICBhcHBDb250ZW50U2VsZWN0b3IsXHJcbiAgICBvbkNsb3NlID0gRnVuY3Rpb24ucHJvdG90eXBlLFxyXG5cclxuICAgIGVsZW1lbnQgPSAnYXNpZGUnLFxyXG4gICAgY29tcG9uZW50OiBFbGVtZW50ID0gZWxlbWVudCxcclxuICAgIGNsYXNzTmFtZSxcclxuICAgIGNoaWxkcmVuLFxyXG4gICAgLi4ucHJvcHNcclxufSwgcmVmKSA9PiB7XHJcbiAgICBjb25zdCByb290UmVmID0gdXNlUmVmKCk7XHJcblxyXG4gICAgdXNlSW1wZXJhdGl2ZUhhbmRsZShyZWYsICgpID0+IHJvb3RSZWYuY3VycmVudCk7XHJcblxyXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgICAgICBpZiAoIWRpc21pc3NpYmxlKSByZXR1cm47XHJcblxyXG4gICAgICAgIGNvbnN0IGFwcENvbnRlbnRFbGVtZW50ID0gYXBwQ29udGVudFNlbGVjdG9yID9cclxuICAgICAgICAgICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvcihhcHBDb250ZW50U2VsZWN0b3IpIDpcclxuICAgICAgICAgICAgcm9vdFJlZi5jdXJyZW50Py5uZXh0RWxlbWVudFNpYmxpbmc7XHJcblxyXG4gICAgICAgIGFwcENvbnRlbnRFbGVtZW50Py5jbGFzc0xpc3QuYWRkKGNzc0NsYXNzZXMuQVBQX0NPTlRFTlQpO1xyXG5cclxuICAgICAgICByZXR1cm4gKCkgPT4ge1xyXG4gICAgICAgICAgICBhcHBDb250ZW50RWxlbWVudD8uY2xhc3NMaXN0LnJlbW92ZShjc3NDbGFzc2VzLkFQUF9DT05URU5UKTtcclxuICAgICAgICB9O1xyXG4gICAgfSwgW2Rpc21pc3NpYmxlLCBhcHBDb250ZW50U2VsZWN0b3JdKTtcclxuXHJcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgICAgIGlmICghbW9kYWwpIHJldHVybjtcclxuXHJcbiAgICAgICAgZnVuY3Rpb24gaGFuZGxlRG9jdW1lbnRLZXlEb3duKGV2ZW50KSB7XHJcbiAgICAgICAgICAgIGlmIChldmVudC5rZXkgJiYgZXZlbnQua2V5ID09PSAnRXNjYXBlJyB8fCBldmVudC5rZXlDb2RlID09PSAyNykge1xyXG4gICAgICAgICAgICAgICAgb25DbG9zZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgaGFuZGxlRG9jdW1lbnRLZXlEb3duKTtcclxuXHJcbiAgICAgICAgcmV0dXJuICgpID0+IGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCBoYW5kbGVEb2N1bWVudEtleURvd24pO1xyXG4gICAgfSwgW21vZGFsLCBvbkNsb3NlXSk7XHJcblxyXG4gICAgY29uc3QgY2xhc3NOYW1lcyA9IGNsYXNzbmFtZXMoY3NzQ2xhc3Nlcy5ST09ULCB7XHJcbiAgICAgICAgW2Nzc0NsYXNzZXMuRElTTUlTU0lCTEVdOiBkaXNtaXNzaWJsZSxcclxuICAgICAgICBbY3NzQ2xhc3Nlcy5NT0RBTF06IG1vZGFsXHJcbiAgICB9LCBjbGFzc05hbWUpO1xyXG5cclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgPExheWVyXHJcbiAgICAgICAgICAgIG1vZGFsPXttb2RhbH1cclxuICAgICAgICAgICAgZml4ZWQ9e21vZGFsfVxyXG4gICAgICAgICAgICBpbj17b3Blbn1cclxuICAgICAgICAgICAgYXBwZWFyPXthcHBlYXJ9XHJcbiAgICAgICAgICAgIHRpbWVvdXQ9e3tcclxuICAgICAgICAgICAgICAgIGVudGVyOiBudW1iZXJzLkFOSU1BVElPTl9FTlRFUl9USU1FX01TLFxyXG4gICAgICAgICAgICAgICAgZXhpdDogbnVtYmVycy5BTklNQVRJT05fRVhJVF9USU1FX01TXHJcbiAgICAgICAgICAgIH19XHJcbiAgICAgICAgICAgIGNsYXNzTmFtZXM9e3tcclxuICAgICAgICAgICAgICAgIGFwcGVhcjogY3NzQ2xhc3Nlcy5PUEVOLFxyXG4gICAgICAgICAgICAgICAgZW50ZXI6IGAke2Nzc0NsYXNzZXMuT1BFTn0gJHtjc3NDbGFzc2VzLkFOSU1BVEV9YCxcclxuICAgICAgICAgICAgICAgIGVudGVyQWN0aXZlOiBgJHtjc3NDbGFzc2VzLk9QRU59ICR7Y3NzQ2xhc3Nlcy5PUEVOSU5HfWAsXHJcbiAgICAgICAgICAgICAgICBlbnRlckRvbmU6IGNzc0NsYXNzZXMuT1BFTixcclxuICAgICAgICAgICAgICAgIGV4aXQ6IGAke2Nzc0NsYXNzZXMuT1BFTn0gJHtjc3NDbGFzc2VzLkNMT1NJTkd9YCxcclxuICAgICAgICAgICAgICAgIGV4aXRBY3RpdmU6IGNzc0NsYXNzZXMuQ0xPU0lOR1xyXG4gICAgICAgICAgICB9fVxyXG4gICAgICAgICAgICBtb3VudE9uRW50ZXI9e21vZGFsfVxyXG4gICAgICAgICAgICB1bm1vdW50T25FeGl0PXttb2RhbH1cclxuICAgICAgICA+XHJcbiAgICAgICAgICAgIDw+XHJcbiAgICAgICAgICAgICAgICA8RWxlbWVudFxyXG4gICAgICAgICAgICAgICAgICAgIHJlZj17cm9vdFJlZn1cclxuICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU9e2NsYXNzTmFtZXN9XHJcbiAgICAgICAgICAgICAgICAgICAgey4uLnByb3BzfVxyXG4gICAgICAgICAgICAgICAgPlxyXG4gICAgICAgICAgICAgICAgICAgIHtjaGlsZHJlbn1cclxuICAgICAgICAgICAgICAgIDwvRWxlbWVudD5cclxuXHJcbiAgICAgICAgICAgICAgICB7bW9kYWwgJiZcclxuICAgICAgICAgICAgICAgICAgICA8ZGl2XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT17Y3NzQ2xhc3Nlcy5TQ1JJTX1cclxuICAgICAgICAgICAgICAgICAgICAgICAgb25DbGljaz17b25DbG9zZX1cclxuICAgICAgICAgICAgICAgICAgICAvPlxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICA8Lz5cclxuICAgICAgICA8L0xheWVyPlxyXG4gICAgKTtcclxufSk7XHJcblxyXG5EcmF3ZXIuZGlzcGxheU5hbWUgPSAnTURDRHJhd2VyJztcclxuXHJcbkRyYXdlci5wcm9wVHlwZXMgPSB7XHJcbiAgICBvcGVuOiBQcm9wVHlwZXMuYm9vbCxcclxuICAgIGFwcGVhcjogUHJvcFR5cGVzLmJvb2wsXHJcbiAgICBkaXNtaXNzaWJsZTogUHJvcFR5cGVzLmJvb2wsXHJcbiAgICBtb2RhbDogUHJvcFR5cGVzLmJvb2wsXHJcbiAgICBhcHBDb250ZW50U2VsZWN0b3I6IFByb3BUeXBlcy5zdHJpbmcsXHJcbiAgICBvbkNsb3NlOiBQcm9wVHlwZXMuZnVuY1xyXG59O1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgRHJhd2VyOyIsImltcG9ydCB7IGZvcndhcmRSZWYgfSBmcm9tICdyZWFjdCc7XHJcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XHJcblxyXG5pbXBvcnQgeyBDbG9uZSB9IGZyb20gJy4uL2NvbXBvbmVudCc7XHJcblxyXG5pbXBvcnQgeyBjc3NDbGFzc2VzIH0gZnJvbSAnLi9jb25zdGFudHMnO1xyXG5cclxuY29uc3QgRHJhd2VySGVhZGVyID0gZm9yd2FyZFJlZigoe1xyXG4gICAgdGl0bGUsXHJcbiAgICBzdWJ0aXRsZSxcclxuICAgIGdyYXBoaWMsXHJcblxyXG4gICAgZWxlbWVudDogRWxlbWVudCA9ICdoZWFkZXInLFxyXG4gICAgY2hpbGRyZW4sXHJcbiAgICAuLi5wcm9wc1xyXG59LCByZWYpID0+IHtcclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgPEVsZW1lbnQgcmVmPXtyZWZ9IGNsYXNzTmFtZT17Y3NzQ2xhc3Nlcy5IRUFERVJ9IHsuLi5wcm9wc30+XHJcbiAgICAgICAgICAgIHtncmFwaGljICYmXHJcbiAgICAgICAgICAgICAgICA8Q2xvbmVcclxuICAgICAgICAgICAgICAgICAgICBjb21wb25lbnQ9e2dyYXBoaWN9XHJcbiAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPXtjc3NDbGFzc2VzLkdSQVBISUN9XHJcbiAgICAgICAgICAgICAgICAvPlxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB7dGl0bGUgJiZcclxuICAgICAgICAgICAgICAgIDxDbG9uZVxyXG4gICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudD17dGl0bGV9XHJcbiAgICAgICAgICAgICAgICAgICAgZmFsbGJhY2s9XCJoM1wiXHJcbiAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPXtjc3NDbGFzc2VzLlRJVExFfVxyXG4gICAgICAgICAgICAgICAgLz5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAge3N1YnRpdGxlICYmXHJcbiAgICAgICAgICAgICAgICA8Q2xvbmVcclxuICAgICAgICAgICAgICAgICAgICBjb21wb25lbnQ9e3N1YnRpdGxlfVxyXG4gICAgICAgICAgICAgICAgICAgIGZhbGxiYWNrPVwiaDZcIlxyXG4gICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT17Y3NzQ2xhc3Nlcy5TVUJUSVRMRX1cclxuICAgICAgICAgICAgICAgIC8+XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHtjaGlsZHJlbn1cclxuICAgICAgICA8L0VsZW1lbnQ+XHJcbiAgICApO1xyXG59KTtcclxuXHJcbkRyYXdlckhlYWRlci5kaXNwbGF5TmFtZSA9ICdNRENEcmF3ZXJIZWFkZXInO1xyXG5cclxuRHJhd2VySGVhZGVyLnByb3BUeXBlcyA9IHtcclxuICAgIHRpdGxlOiBQcm9wVHlwZXMubm9kZSxcclxuICAgIHN1YnRpdGxlOiBQcm9wVHlwZXMubm9kZSxcclxuICAgIGdyYXBoaWM6IFByb3BUeXBlcy5lbGVtZW50XHJcbn07XHJcblxyXG5leHBvcnQgZGVmYXVsdCBEcmF3ZXJIZWFkZXI7IiwiaW1wb3J0IHsgZm9yd2FyZFJlZiB9IGZyb20gJ3JlYWN0JztcclxuXHJcbmltcG9ydCB7IGNzc0NsYXNzZXMgfSBmcm9tICcuL2NvbnN0YW50cyc7XHJcblxyXG5jb25zdCBEcmF3ZXJDb250ZW50ID0gZm9yd2FyZFJlZigoe1xyXG4gICAgZWxlbWVudDogRWxlbWVudCA9ICdkaXYnLFxyXG4gICAgLi4ucHJvcHNcclxufSwgcmVmKSA9PiB7XHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAgIDxFbGVtZW50IHJlZj17cmVmfSBjbGFzc05hbWU9e2Nzc0NsYXNzZXMuQ09OVEVOVH0gey4uLnByb3BzfSAvPlxyXG4gICAgKTtcclxufSk7XHJcblxyXG5EcmF3ZXJDb250ZW50LmRpc3BsYXlOYW1lID0gJ01EQ0RyYXdlckNvbnRlbnQnO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgRHJhd2VyQ29udGVudDsiLCJpbXBvcnQgRHJhd2VyIGZyb20gJy4vRHJhd2VyJztcclxuaW1wb3J0IERyYXdlckhlYWRlciBmcm9tICcuL0RyYXdlckhlYWRlcic7XHJcbmltcG9ydCBEcmF3ZXJDb250ZW50IGZyb20gJy4vRHJhd2VyQ29udGVudCc7XHJcblxyXG5EcmF3ZXIuSGVhZGVyID0gRHJhd2VySGVhZGVyO1xyXG5EcmF3ZXIuQ29udGVudCA9IERyYXdlckNvbnRlbnQ7XHJcblxyXG5leHBvcnQge1xyXG4gICAgRHJhd2VyIGFzIGRlZmF1bHQsXHJcbiAgICBEcmF3ZXJIZWFkZXIsXHJcbiAgICBEcmF3ZXJDb250ZW50XHJcbn07IiwiZXhwb3J0IGNvbnN0IGNzc0NsYXNzZXMgPSB7XHJcbiAgICBST09UOiAnbWRjLWVsZXZhdGlvbicsXHJcbiAgICBaOiAnbWRjLWVsZXZhdGlvbi0teicsXHJcbiAgICBUUkFOU0lUSU9OOiAnbWRjLWVsZXZhdGlvbi10cmFuc2l0aW9uJ1xyXG59OyIsImltcG9ydCB7IGZvcndhcmRSZWYgfSBmcm9tICdyZWFjdCc7XHJcbmltcG9ydCBjbGFzc25hbWVzIGZyb20gJ2NsYXNzbmFtZXMnO1xyXG5cclxuaW1wb3J0IHsgY3NzQ2xhc3NlcyB9IGZyb20gJy4vY29uc3RhbnRzJztcclxuXHJcbmNvbnN0IEVsZXZhdGlvbiA9IGZvcndhcmRSZWYoKHtcclxuICAgIHogPSAwLFxyXG4gICAgdHJhbnNpdGlvbiA9IGZhbHNlLFxyXG5cclxuICAgIGVsZW1lbnQgPSAnZGl2JyxcclxuICAgIGNvbXBvbmVudDogRWxlbWVudCA9IGVsZW1lbnQsXHJcbiAgICBjbGFzc05hbWUsXHJcbiAgICAuLi5wcm9wc1xyXG59LCByZWYpID0+IHtcclxuICAgIGNvbnN0IGNsYXNzTmFtZXMgPSBjbGFzc25hbWVzKGNzc0NsYXNzZXMuUk9PVCwge1xyXG4gICAgICAgIFtgJHtjc3NDbGFzc2VzLlp9JHt6fWBdOiB6LFxyXG4gICAgICAgIFtjc3NDbGFzc2VzLlRSQU5TSVRJT05dOiB0cmFuc2l0aW9uXHJcbiAgICB9LCBjbGFzc05hbWUpO1xyXG5cclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgPEVsZW1lbnQgcmVmPXtyZWZ9IGNsYXNzTmFtZT17Y2xhc3NOYW1lc30gey4uLnByb3BzfSAvPlxyXG4gICAgKTtcclxufSk7XHJcblxyXG5FbGV2YXRpb24uZGlzcGxheU5hbWUgPSAnTURDRWxldmF0aW9uJztcclxuXHJcbmV4cG9ydCBkZWZhdWx0IEVsZXZhdGlvbjsiLCJleHBvcnQgeyBkZWZhdWx0IH0gZnJvbSAnLi9FbGV2YXRpb24nOyIsImV4cG9ydCBjb25zdCBjc3NDbGFzc2VzID0ge1xyXG4gICAgUk9PVDogJ21kYy1mYWInLFxyXG4gICAgTUlOSTogJ21kYy1mYWItLW1pbmknLFxyXG4gICAgRVhURU5ERUQ6ICdtZGMtZmFiLS1leHRlbmRlZCcsXHJcbiAgICBFWElURUQ6ICdtZGMtZmFiLS1leGl0ZWQnLFxyXG5cclxuICAgIElDT046ICdtZGMtZmFiX19pY29uJyxcclxuICAgIExBQkVMOiAnbWRjLWZhYl9fbGFiZWwnLFxyXG4gICAgUklQUExFOiAnbWRjLWZhYl9fcmlwcGxlJ1xyXG59OyIsImltcG9ydCB7IGZvcndhcmRSZWYgfSBmcm9tICdyZWFjdCc7XHJcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XHJcbmltcG9ydCBjbGFzc25hbWVzIGZyb20gJ2NsYXNzbmFtZXMnO1xyXG5cclxuaW1wb3J0IHsgQ2xvbmUgfSBmcm9tICcuLi9jb21wb25lbnQnO1xyXG5pbXBvcnQgSWNvbiBmcm9tICcuLi9pY29uJztcclxuXHJcbmltcG9ydCB7IGNzc0NsYXNzZXMgfSBmcm9tICcuL2NvbnN0YW50cyc7XHJcblxyXG5jb25zdCBGQUIgPSBmb3J3YXJkUmVmKCh7XHJcbiAgICBpY29uLFxyXG4gICAgbGFiZWwsXHJcbiAgICBsZWFkaW5nSWNvbiA9IGljb24sXHJcbiAgICB0cmFpbGluZ0ljb24sXHJcbiAgICBtaW5pID0gZmFsc2UsXHJcbiAgICBleGl0ZWQgPSBmYWxzZSxcclxuXHJcbiAgICBlbGVtZW50ID0gJ2J1dHRvbicsXHJcbiAgICBjb21wb25lbnQ6IEVsZW1lbnQgPSBlbGVtZW50LFxyXG4gICAgY2xhc3NOYW1lLFxyXG4gICAgY2hpbGRyZW4gPSBsYWJlbCxcclxuICAgIC4uLnByb3BzXHJcbn0sIHJlZikgPT4ge1xyXG4gICAgY29uc3QgY2xhc3NOYW1lcyA9IGNsYXNzbmFtZXMoY3NzQ2xhc3Nlcy5ST09ULCB7XHJcbiAgICAgICAgW2Nzc0NsYXNzZXMuTUlOSV06IG1pbmksXHJcbiAgICAgICAgW2Nzc0NsYXNzZXMuRVhURU5ERURdOiBsYWJlbCxcclxuICAgICAgICBbY3NzQ2xhc3Nlcy5FWElURURdOiBleGl0ZWRcclxuICAgIH0sIGNsYXNzTmFtZSk7XHJcblxyXG4gICAgcmV0dXJuIChcclxuICAgICAgICA8RWxlbWVudCByZWY9e3JlZn0gY2xhc3NOYW1lPXtjbGFzc05hbWVzfSB7Li4ucHJvcHN9PlxyXG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17Y3NzQ2xhc3Nlcy5SSVBQTEV9IC8+XHJcblxyXG4gICAgICAgICAgICB7bGVhZGluZ0ljb24gJiZcclxuICAgICAgICAgICAgICAgIDxDbG9uZVxyXG4gICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudD17bGVhZGluZ0ljb259XHJcbiAgICAgICAgICAgICAgICAgICAgZmFsbGJhY2s9e0ljb259XHJcbiAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPXtjc3NDbGFzc2VzLklDT059XHJcbiAgICAgICAgICAgICAgICAvPlxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB7Y2hpbGRyZW4gJiZcclxuICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT17Y3NzQ2xhc3Nlcy5MQUJFTH0+e2NoaWxkcmVufTwvc3Bhbj5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAge3RyYWlsaW5nSWNvbiAmJlxyXG4gICAgICAgICAgICAgICAgPENsb25lXHJcbiAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50PXt0cmFpbGluZ0ljb259XHJcbiAgICAgICAgICAgICAgICAgICAgZmFsbGJhY2s9e0ljb259XHJcbiAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPXtjc3NDbGFzc2VzLklDT059XHJcbiAgICAgICAgICAgICAgICAvPlxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgPC9FbGVtZW50PlxyXG4gICAgKTtcclxufSk7XHJcblxyXG5GQUIuZGlzcGxheU5hbWUgPSAnTURDRkFCJztcclxuXHJcbkZBQi5wcm9wVHlwZXMgPSB7XHJcbiAgICBpY29uOiBQcm9wVHlwZXMubm9kZSxcclxuICAgIGxhYmVsOiBQcm9wVHlwZXMubm9kZSxcclxuICAgIGxlYWRpbmdJY29uOiBQcm9wVHlwZXMubm9kZSxcclxuICAgIHRyYWlsaW5nSWNvbjogUHJvcFR5cGVzLm5vZGUsXHJcbiAgICBtaW5pOiBQcm9wVHlwZXMuYm9vbCxcclxuICAgIGV4aXRlZDogUHJvcFR5cGVzLmJvb2xcclxufTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IEZBQjsiLCJleHBvcnQgeyBkZWZhdWx0IH0gZnJvbSAnLi9GQUInOyIsImV4cG9ydCBjb25zdCBjc3NDbGFzc2VzID0ge1xyXG4gICAgUk9PVDogJ21kYy1mb3JtLWZpZWxkJyxcclxuICAgIEFMSUdOX0VORDogJ21kYy1mb3JtLWZpZWxkLS1hbGlnbi1lbmQnLFxyXG4gICAgTk9XUkFQOiAnbWRjLWZvcm0tZmllbGQtLW5vd3JhcCcsXHJcbiAgICBTUEFDRV9CRVRXRUVOOiAnbWRjLWZvcm0tZmllbGQtLXNwYWNlLWJldHdlZW4nXHJcbn07IiwiaW1wb3J0IHsgZm9yd2FyZFJlZiB9IGZyb20gJ3JlYWN0JztcclxuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcclxuaW1wb3J0IGNsYXNzbmFtZXMgZnJvbSAnY2xhc3NuYW1lcyc7XHJcblxyXG5pbXBvcnQgeyBjc3NDbGFzc2VzIH0gZnJvbSAnLi9jb25zdGFudHMnO1xyXG5cclxuY29uc3QgRm9ybUZpZWxkID0gZm9yd2FyZFJlZigoe1xyXG4gICAgbGFiZWwsXHJcbiAgICBhbGlnbkVuZCA9IGZhbHNlLFxyXG4gICAgbm93cmFwID0gZmFsc2UsXHJcbiAgICBzcGFjZUJldHdlZW4gPSBmYWxzZSxcclxuXHJcbiAgICBlbGVtZW50OiBFbGVtZW50ID0gJ2RpdicsXHJcbiAgICBjbGFzc05hbWUsXHJcbiAgICBjaGlsZHJlbixcclxuICAgIC4uLnByb3BzXHJcbn0sIHJlZikgPT4ge1xyXG4gICAgY29uc3QgY2xhc3NOYW1lcyA9IGNsYXNzbmFtZXMoY3NzQ2xhc3Nlcy5ST09ULCB7XHJcbiAgICAgICAgW2Nzc0NsYXNzZXMuQUxJR05fRU5EXTogYWxpZ25FbmQsXHJcbiAgICAgICAgW2Nzc0NsYXNzZXMuTk9XUkFQXTogbm93cmFwLFxyXG4gICAgICAgIFtjc3NDbGFzc2VzLlNQQUNFX0JFVFdFRU5dOiBzcGFjZUJldHdlZW5cclxuICAgIH0sIGNsYXNzTmFtZSk7XHJcblxyXG4gICAgcmV0dXJuIChcclxuICAgICAgICA8RWxlbWVudCByZWY9e3JlZn0gY2xhc3NOYW1lPXtjbGFzc05hbWVzfSB7Li4ucHJvcHN9PlxyXG4gICAgICAgICAgICB7Y2hpbGRyZW59XHJcblxyXG4gICAgICAgICAgICB7bGFiZWwgJiZcclxuICAgICAgICAgICAgICAgIDxsYWJlbCBodG1sRm9yPXtjaGlsZHJlbi5wcm9wcy5pZH0+e2xhYmVsfTwvbGFiZWw+XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICA8L0VsZW1lbnQ+XHJcbiAgICApO1xyXG59KTtcclxuXHJcbkZvcm1GaWVsZC5kaXNwbGF5TmFtZSA9ICdNRENGb3JtRmllbGQnO1xyXG5cclxuRm9ybUZpZWxkLnByb3BUeXBlcyA9IHtcclxuICAgIGxhYmVsOiBQcm9wVHlwZXMubm9kZSxcclxuICAgIGFsaWduRW5kOiBQcm9wVHlwZXMuYm9vbCxcclxuICAgIG5vd3JhcDogUHJvcFR5cGVzLmJvb2wsXHJcbiAgICBzcGFjZUJldHdlZW46IFByb3BUeXBlcy5ib29sLFxyXG4gICAgY2hpbGRyZW46IFByb3BUeXBlcy5hbnkuaXNSZXF1aXJlZFxyXG59O1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgRm9ybUZpZWxkOyIsImV4cG9ydCB7IGRlZmF1bHQgfSBmcm9tICcuL0Zvcm1GaWVsZCc7IiwiZXhwb3J0IGNvbnN0IGNzc0NsYXNzZXMgPSB7XHJcbiAgICBJTUFHRV9MSVNUOiAnbWRjLWltYWdlLWxpc3QnLFxyXG4gICAgSU1BR0VfTElTVF9NQVNPTlJZOiAnbWRjLWltYWdlLWxpc3QtLW1hc29ucnknLFxyXG4gICAgSU1BR0VfTElTVF9XSVRIX1RFWFRfUFJPVEVDVElPTjogJ21kYy1pbWFnZS1saXN0LS13aXRoLXRleHQtcHJvdGVjdGlvbicsXHJcblxyXG4gICAgSU1BR0VfTElTVF9JVEVNOiAnbWRjLWltYWdlLWxpc3RfX2l0ZW0nLFxyXG4gICAgSU1BR0VfTElTVF9JTUFHRV9BU1BFQ1RfQ09OVEFJTkVSOiAnbWRjLWltYWdlLWxpc3RfX2ltYWdlLWFzcGVjdC1jb250YWluZXInLFxyXG4gICAgSU1BR0VfTElTVF9JTUFHRTogJ21kYy1pbWFnZS1saXN0X19pbWFnZScsXHJcbiAgICBJTUFHRV9MSVNUX1NVUFBPUlRJTkc6ICdtZGMtaW1hZ2UtbGlzdF9fc3VwcG9ydGluZycsXHJcbiAgICBJTUFHRV9MSVNUX0xBQkVMOiAnbWRjLWltYWdlLWxpc3RfX2xhYmVsJ1xyXG59OyIsImltcG9ydCB7IGZvcndhcmRSZWYgfSBmcm9tICdyZWFjdCc7XHJcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XHJcbmltcG9ydCBjbGFzc25hbWVzIGZyb20gJ2NsYXNzbmFtZXMnO1xyXG5cclxuaW1wb3J0IHsgY3NzQ2xhc3NlcyB9IGZyb20gJy4vY29uc3RhbnRzJztcclxuXHJcbmNvbnN0IEltYWdlTGlzdEl0ZW0gPSBmb3J3YXJkUmVmKCh7XHJcbiAgICBpbWFnZVNyYyxcclxuICAgIGxhYmVsLFxyXG4gICAgZml4ZWRBc3BlY3QgPSB0cnVlLFxyXG5cclxuICAgIGVsZW1lbnQ6IEVsZW1lbnQgPSAnbGknLFxyXG4gICAgY2xhc3NOYW1lLFxyXG4gICAgLi4ucHJvcHNcclxufSwgcmVmKSA9PiB7XHJcbiAgICBjb25zdCBjbGFzc05hbWVzID0gY2xhc3NuYW1lcyhjc3NDbGFzc2VzLklNQUdFX0xJU1RfSVRFTSwgY2xhc3NOYW1lKTtcclxuXHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAgIDxFbGVtZW50IHJlZj17cmVmfSBjbGFzc05hbWU9e2NsYXNzTmFtZXN9IHsuLi5wcm9wc30+XHJcbiAgICAgICAgICAgIHtmaXhlZEFzcGVjdCA/XHJcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17Y3NzQ2xhc3Nlcy5JTUFHRV9MSVNUX0lNQUdFX0FTUEVDVF9DT05UQUlORVJ9PlxyXG4gICAgICAgICAgICAgICAgICAgIDxpbWcgY2xhc3NOYW1lPXtjc3NDbGFzc2VzLklNQUdFX0xJU1RfSU1BR0V9IHNyYz17aW1hZ2VTcmN9IGFsdD17bGFiZWx9IC8+XHJcbiAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgICAgIDpcclxuICAgICAgICAgICAgICAgIDxpbWcgY2xhc3NOYW1lPXtjc3NDbGFzc2VzLklNQUdFX0xJU1RfSU1BR0V9IHNyYz17aW1hZ2VTcmN9IGFsdD17bGFiZWx9IC8+XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHtsYWJlbCAmJlxyXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9e2Nzc0NsYXNzZXMuSU1BR0VfTElTVF9TVVBQT1JUSU5HfT5cclxuICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9e2Nzc0NsYXNzZXMuSU1BR0VfTElTVF9MQUJFTH0+e2xhYmVsfTwvc3Bhbj5cclxuICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgPC9FbGVtZW50PlxyXG4gICAgKTtcclxufSk7XHJcblxyXG5JbWFnZUxpc3RJdGVtLmRpc3BsYXlOYW1lID0gJ01EQ0ltYWdlTGlzdEl0ZW0nO1xyXG5cclxuSW1hZ2VMaXN0SXRlbS5wcm9wVHlwZXMgPSB7XHJcbiAgICBpbWFnZVNyYzogUHJvcFR5cGVzLnN0cmluZyxcclxuICAgIGxhYmVsOiBQcm9wVHlwZXMubm9kZSxcclxuICAgIGZpeGVkQXNwZWN0OiBQcm9wVHlwZXMuYm9vbFxyXG59O1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgSW1hZ2VMaXN0SXRlbTsiLCJpbXBvcnQgeyBDaGlsZHJlbiwgZm9yd2FyZFJlZiB9IGZyb20gJ3JlYWN0JztcclxuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcclxuaW1wb3J0IGNsYXNzbmFtZXMgZnJvbSAnY2xhc3NuYW1lcyc7XHJcblxyXG5pbXBvcnQgeyBjbG9uZSwgY3JlYXRlIH0gZnJvbSAnLi4vY29tcG9uZW50JztcclxuXHJcbmltcG9ydCB7IGNzc0NsYXNzZXMgfSBmcm9tICcuL2NvbnN0YW50cyc7XHJcbmltcG9ydCBJbWFnZUxpc3RJdGVtIGZyb20gJy4vSW1hZ2VMaXN0SXRlbSc7XHJcblxyXG5jb25zdCBJbWFnZUxpc3QgPSBmb3J3YXJkUmVmKCh7XHJcbiAgICBpdGVtcyxcclxuICAgIG1hc29ucnkgPSBmYWxzZSxcclxuICAgIHdpdGhUZXh0UHJvdGVjdGlvbiA9IGZhbHNlLFxyXG5cclxuICAgIGVsZW1lbnQ6IEVsZW1lbnQgPSAndWwnLFxyXG4gICAgY2xhc3NOYW1lLFxyXG4gICAgY2hpbGRyZW4gPSBpdGVtcz8ubWFwKGl0ZW0gPT4gY3JlYXRlKEltYWdlTGlzdEl0ZW0sIGl0ZW0pKSxcclxuICAgIC4uLnByb3BzXHJcbn0sIHJlZikgPT4ge1xyXG4gICAgY29uc3QgY2xhc3NOYW1lcyA9IGNsYXNzbmFtZXMoY3NzQ2xhc3Nlcy5JTUFHRV9MSVNULCB7XHJcbiAgICAgICAgW2Nzc0NsYXNzZXMuSU1BR0VfTElTVF9NQVNPTlJZXTogbWFzb25yeSxcclxuICAgICAgICBbY3NzQ2xhc3Nlcy5JTUFHRV9MSVNUX1dJVEhfVEVYVF9QUk9URUNUSU9OXTogd2l0aFRleHRQcm90ZWN0aW9uXHJcbiAgICB9LCBjbGFzc05hbWUpO1xyXG5cclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgPEVsZW1lbnQgcmVmPXtyZWZ9IGNsYXNzTmFtZT17Y2xhc3NOYW1lc30gey4uLnByb3BzfT5cclxuICAgICAgICAgICAge0NoaWxkcmVuLm1hcChjaGlsZHJlbiwgY2hpbGQgPT5cclxuICAgICAgICAgICAgICAgIGNsb25lKGNoaWxkLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgZml4ZWRBc3BlY3Q6IG1hc29ucnkgPyBmYWxzZSA6IHVuZGVmaW5lZFxyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgKX1cclxuICAgICAgICA8L0VsZW1lbnQ+XHJcbiAgICApO1xyXG59KTtcclxuXHJcbkltYWdlTGlzdC5kaXNwbGF5TmFtZSA9ICdNRENJbWFnZUxpc3QnO1xyXG5cclxuSW1hZ2VMaXN0LnByb3BUeXBlcyA9IHtcclxuICAgIGl0ZW1zOiBQcm9wVHlwZXMuYXJyYXksXHJcbiAgICBtYXNvbnJ5OiBQcm9wVHlwZXMuYm9vbCxcclxuICAgIHdpdGhUZXh0UHJvdGVjdGlvbjogUHJvcFR5cGVzLmJvb2xcclxufTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IEltYWdlTGlzdDsiLCJpbXBvcnQgSW1hZ2VMaXN0IGZyb20gJy4vSW1hZ2VMaXN0JztcclxuaW1wb3J0IEltYWdlTGlzdEl0ZW0gZnJvbSAnLi9JbWFnZUxpc3RJdGVtJztcclxuXHJcbkltYWdlTGlzdC5JdGVtID0gSW1hZ2VMaXN0SXRlbTtcclxuXHJcbmV4cG9ydCB7XHJcbiAgICBJbWFnZUxpc3QgYXMgZGVmYXVsdCxcclxuICAgIEltYWdlTGlzdEl0ZW1cclxufTsiLCJleHBvcnQgY29uc3QgY3NzQ2xhc3NlcyA9IHtcclxuICAgIFJPT1Q6ICdtZGMtbGF5b3V0JyxcclxuICAgIFJPVzogJ21kYy1sYXlvdXQtLXJvdycsXHJcbiAgICBDT0xVTU46ICdtZGMtbGF5b3V0LS1jb2x1bW4nLFxyXG4gICAgRElSRUNUSU9OOiAnbWRjLWxheW91dC0tZGlyZWN0aW9uJyxcclxuICAgIFdSQVA6ICdtZGMtbGF5b3V0LS13cmFwJyxcclxuICAgIFdSQVBfUkVWRVJTRTogJ21kYy1sYXlvdXQtLXdyYXAtcmV2ZXJzZScsXHJcbiAgICBBTElHTl9JVEVNUzogJ21kYy1sYXlvdXQtLWFsaWduLWl0ZW1zJyxcclxuICAgIEFMSUdOX1NFTEY6ICdtZGMtbGF5b3V0LS1hbGlnbi1zZWxmJyxcclxuICAgIEpVU1RJRllfQ09OVEVOVDogJ21kYy1sYXlvdXQtLWp1c3RpZnktY29udGVudCdcclxufTsiLCJpbXBvcnQgeyBmb3J3YXJkUmVmIH0gZnJvbSAncmVhY3QnO1xyXG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xyXG5pbXBvcnQgY2xhc3NuYW1lcyBmcm9tICdjbGFzc25hbWVzJztcclxuXHJcbmltcG9ydCB7IGNzc0NsYXNzZXMgfSBmcm9tICcuL2NvbnN0YW50cyc7XHJcblxyXG5jb25zdCBMYXlvdXQgPSBmb3J3YXJkUmVmKCh7XHJcbiAgICByb3csXHJcbiAgICBjb2x1bW4sXHJcbiAgICBkaXJlY3Rpb24sXHJcbiAgICB3cmFwLFxyXG4gICAgYWxpZ25JdGVtcyxcclxuICAgIGFsaWduU2VsZixcclxuICAgIGp1c3RpZnlDb250ZW50LFxyXG5cclxuICAgIGVsZW1lbnQgPSAnZGl2JyxcclxuICAgIGNvbXBvbmVudDogRWxlbWVudCA9IGVsZW1lbnQsXHJcbiAgICBjbGFzc05hbWUsXHJcbiAgICAuLi5wcm9wc1xyXG59LCByZWYpID0+IHtcclxuICAgIGNvbnN0IGNsYXNzTmFtZXMgPSBjbGFzc25hbWVzKGNzc0NsYXNzZXMuUk9PVCwge1xyXG4gICAgICAgIFtjc3NDbGFzc2VzLlJPV106IHJvdyxcclxuICAgICAgICBbY3NzQ2xhc3Nlcy5DT0xVTU5dOiBjb2x1bW4sXHJcbiAgICAgICAgW2Ake2Nzc0NsYXNzZXMuRElSRUNUSU9OfS0tJHtkaXJlY3Rpb259YF06IGRpcmVjdGlvbixcclxuICAgICAgICBbYCR7Y3NzQ2xhc3Nlcy5BTElHTl9JVEVNU30tLSR7YWxpZ25JdGVtc31gXTogYWxpZ25JdGVtcyxcclxuICAgICAgICBbYCR7Y3NzQ2xhc3Nlcy5BTElHTl9TRUxGfS0tJHthbGlnblNlbGZ9YF06IGFsaWduU2VsZixcclxuICAgICAgICBbYCR7Y3NzQ2xhc3Nlcy5KVVNUSUZZX0NPTlRFTlR9LS0ke2p1c3RpZnlDb250ZW50fWBdOiBqdXN0aWZ5Q29udGVudCxcclxuICAgICAgICBbY3NzQ2xhc3Nlcy5XUkFQXTogd3JhcCA9PT0gdHJ1ZSxcclxuICAgICAgICBbY3NzQ2xhc3Nlcy5XUkFQX1JFVkVSU0VdOiB3cmFwID09PSAncmV2ZXJzZSdcclxuICAgIH0sIGNsYXNzTmFtZSk7XHJcblxyXG4gICAgcmV0dXJuIChcclxuICAgICAgICA8RWxlbWVudCByZWY9e3JlZn0gY2xhc3NOYW1lPXtjbGFzc05hbWVzfSB7Li4ucHJvcHN9IC8+XHJcbiAgICApO1xyXG59KTtcclxuXHJcbkxheW91dC5kaXNwbGF5TmFtZSA9ICdNRENMYXlvdXQnO1xyXG5cclxuTGF5b3V0LnByb3BUeXBlcyA9IHtcclxuICAgIHJvdzogUHJvcFR5cGVzLmJvb2wsXHJcbiAgICBjb2x1bW46IFByb3BUeXBlcy5ib29sLFxyXG4gICAgZGlyZWN0aW9uOiBQcm9wVHlwZXMub25lT2YoWydyb3cnLCAnY29sdW1uJ10pLFxyXG4gICAgd3JhcDogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLmJvb2wsIFByb3BUeXBlcy5zdHJpbmddKSxcclxuICAgIGFsaWduSXRlbXM6IFByb3BUeXBlcy5vbmVPZihbJ3N0YXJ0JywgJ2NlbnRlcicsICdlbmQnXSksXHJcbiAgICBhbGlnblNlbGY6IFByb3BUeXBlcy5vbmVPZihbJ3N0YXJ0JywgJ2NlbnRlcicsICdlbmQnXSksXHJcbiAgICBqdXN0aWZ5Q29udGVudDogUHJvcFR5cGVzLm9uZU9mKFsnc3RhcnQnLCAnY2VudGVyJywgJ2VuZCcsICdhcm91bmQnLCAnYmV0d2VlbiddKVxyXG59O1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgTGF5b3V0OyIsImV4cG9ydCB7IGRlZmF1bHQgfSBmcm9tICcuL0xheW91dCc7IiwiZXhwb3J0IGNvbnN0IGNzc0NsYXNzZXMgPSB7XHJcbiAgICBST09UOiAnbWRjLWxheW91dC1ncmlkJyxcclxuICAgIEFMSUdOOiAnbWRjLWxheW91dC1ncmlkLS1hbGlnbicsXHJcbiAgICBGSVhFRF9DT0xVTU5fV0lEVEg6ICdtZGMtbGF5b3V0LWdyaWQtLWZpeGVkLWNvbHVtbi13aWR0aCcsXHJcblxyXG4gICAgSU5ORVI6ICdtZGMtbGF5b3V0LWdyaWRfX2lubmVyJyxcclxuXHJcbiAgICBDRUxMOiAnbWRjLWxheW91dC1ncmlkX19jZWxsJyxcclxuICAgIENFTExfU1BBTjogJ21kYy1sYXlvdXQtZ3JpZF9fY2VsbC0tc3BhbicsXHJcbiAgICBDRUxMX09SREVSOiAnbWRjLWxheW91dC1ncmlkX19jZWxsLS1vcmRlcicsXHJcbiAgICBDRUxMX0FMSUdOOiAnbWRjLWxheW91dC1ncmlkX19jZWxsLS1hbGlnbidcclxufTsiLCJpbXBvcnQgeyBmb3J3YXJkUmVmIH0gZnJvbSAncmVhY3QnO1xyXG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xyXG5pbXBvcnQgY2xhc3NuYW1lcyBmcm9tICdjbGFzc25hbWVzJztcclxuaW1wb3J0IHsgY3NzQ2xhc3NlcyB9IGZyb20gJy4vY29uc3RhbnRzJztcclxuXHJcbmNvbnN0IExheW91dEdyaWQgPSBmb3J3YXJkUmVmKCh7XHJcbiAgICBhbGlnbixcclxuICAgIGZpeGVkQ29sdW1uV2lkdGggPSBmYWxzZSxcclxuXHJcbiAgICBlbGVtZW50ID0gJ2RpdicsXHJcbiAgICBjb21wb25lbnQgPSBlbGVtZW50LFxyXG4gICAgY2xhc3NOYW1lLFxyXG4gICAgY2hpbGRyZW4sXHJcbiAgICAuLi5wcm9wc1xyXG59LCByZWYpID0+IHtcclxuICAgIGNvbnN0IEVsZW1lbnQgPSBjb21wb25lbnQ7XHJcbiAgICBjb25zdCBjbGFzc05hbWVzID0gY2xhc3NuYW1lcyhjc3NDbGFzc2VzLlJPT1QsIHtcclxuICAgICAgICBbYCR7Y3NzQ2xhc3Nlcy5BTElHTn0tJHthbGlnbn1gXTogYWxpZ24sXHJcbiAgICAgICAgW2Nzc0NsYXNzZXMuRklYRURfQ09MVU1OX1dJRFRIXTogZml4ZWRDb2x1bW5XaWR0aFxyXG4gICAgfSwgY2xhc3NOYW1lKTtcclxuXHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAgIDxFbGVtZW50IHJlZj17cmVmfSBjbGFzc05hbWU9e2NsYXNzTmFtZXN9IHsuLi5wcm9wc30+XHJcbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXtjc3NDbGFzc2VzLklOTkVSfT57Y2hpbGRyZW59PC9kaXY+XHJcbiAgICAgICAgPC9FbGVtZW50PlxyXG4gICAgKTtcclxufSk7XHJcblxyXG5MYXlvdXRHcmlkLmRpc3BsYXlOYW1lID0gJ01EQ0xheW91dEdyaWQnO1xyXG5cclxuTGF5b3V0R3JpZC5wcm9wVHlwZXMgPSB7XHJcbiAgICBhbGlnbjogUHJvcFR5cGVzLm9uZU9mKFsnbGVmdCcsICdyaWdodCddKSxcclxuICAgIGZpeGVkQ29sdW1uV2lkdGg6IFByb3BUeXBlcy5ib29sXHJcbn07XHJcblxyXG5leHBvcnQgZGVmYXVsdCBMYXlvdXRHcmlkOyIsImltcG9ydCB7IGZvcndhcmRSZWYgfSBmcm9tICdyZWFjdCc7XHJcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XHJcbmltcG9ydCBjbGFzc25hbWVzIGZyb20gJ2NsYXNzbmFtZXMnO1xyXG5pbXBvcnQgeyBjc3NDbGFzc2VzIH0gZnJvbSAnLi9jb25zdGFudHMnO1xyXG5cclxuY29uc3QgTGF5b3V0R3JpZENlbGwgPSBmb3J3YXJkUmVmKCh7XHJcbiAgICBzcGFuLFxyXG4gICAgZGVza3RvcCxcclxuICAgIHRhYmxldCxcclxuICAgIG1vYmlsZSxcclxuICAgIG9yZGVyLFxyXG4gICAgYWxpZ24sXHJcbiAgICBncmlkID0gZmFsc2UsXHJcblxyXG4gICAgZWxlbWVudCA9ICdkaXYnLFxyXG4gICAgY29tcG9uZW50ID0gZWxlbWVudCxcclxuICAgIGNsYXNzTmFtZSxcclxuICAgIGNoaWxkcmVuLFxyXG4gICAgLi4ucHJvcHNcclxufSwgcmVmKSA9PiB7XHJcbiAgICBjb25zdCBFbGVtZW50ID0gY29tcG9uZW50O1xyXG4gICAgY29uc3QgY2xhc3NOYW1lcyA9IGNsYXNzbmFtZXMoY3NzQ2xhc3Nlcy5DRUxMLCB7XHJcbiAgICAgICAgW2Ake2Nzc0NsYXNzZXMuQ0VMTF9TUEFOfS0ke3NwYW59YF06IHNwYW4sXHJcbiAgICAgICAgW2Ake2Nzc0NsYXNzZXMuQ0VMTF9TUEFOfS0ke2Rlc2t0b3B9LWRlc2t0b3BgXTogZGVza3RvcCxcclxuICAgICAgICBbYCR7Y3NzQ2xhc3Nlcy5DRUxMX1NQQU59LSR7dGFibGV0fS10YWJsZXRgXTogdGFibGV0LFxyXG4gICAgICAgIFtgJHtjc3NDbGFzc2VzLkNFTExfU1BBTn0tJHttb2JpbGV9LW1vYmlsZWBdOiBtb2JpbGUsXHJcbiAgICAgICAgW2Ake2Nzc0NsYXNzZXMuQ0VMTF9PUkRFUn0tJHtvcmRlcn1gXTogb3JkZXIsXHJcbiAgICAgICAgW2Ake2Nzc0NsYXNzZXMuQ0VMTF9BTElHTn0tJHthbGlnbn1gXTogYWxpZ25cclxuICAgIH0sIGNsYXNzTmFtZSk7XHJcblxyXG4gICAgcmV0dXJuIChcclxuICAgICAgICA8RWxlbWVudCByZWY9e3JlZn0gY2xhc3NOYW1lPXtjbGFzc05hbWVzfSB7Li4ucHJvcHN9PlxyXG4gICAgICAgICAgICB7Z3JpZCA/XHJcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17Y3NzQ2xhc3Nlcy5JTk5FUn0+XHJcbiAgICAgICAgICAgICAgICAgICAge2NoaWxkcmVufVxyXG4gICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICAgICA6XHJcbiAgICAgICAgICAgICAgICBjaGlsZHJlblxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgPC9FbGVtZW50PlxyXG4gICAgKTtcclxufSk7XHJcblxyXG5MYXlvdXRHcmlkQ2VsbC5kaXNwbGF5TmFtZSA9ICdNRENMYXlvdXRHcmlkQ2VsbCc7XHJcblxyXG5MYXlvdXRHcmlkQ2VsbC5wcm9wVHlwZXMgPSB7XHJcbiAgICBzcGFuOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMubnVtYmVyLCBQcm9wVHlwZXMuc3RyaW5nXSksXHJcbiAgICBkZXNrdG9wOiBQcm9wVHlwZXMubnVtYmVyLFxyXG4gICAgdGFibGV0OiBQcm9wVHlwZXMubnVtYmVyLFxyXG4gICAgbW9iaWxlOiBQcm9wVHlwZXMubnVtYmVyLFxyXG4gICAgb3JkZXI6IFByb3BUeXBlcy5udW1iZXIsXHJcbiAgICBhbGlnbjogUHJvcFR5cGVzLm9uZU9mKFsndG9wJywgJ21pZGRsZScsICdib3R0b20nXSksXHJcbiAgICBncmlkOiBQcm9wVHlwZXMuYm9vbFxyXG59O1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgTGF5b3V0R3JpZENlbGw7IiwiaW1wb3J0IExheW91dEdyaWQgZnJvbSAnLi9MYXlvdXRHcmlkJztcclxuaW1wb3J0IExheW91dEdyaWRDZWxsIGZyb20gJy4vTGF5b3V0R3JpZENlbGwnO1xyXG5cclxuTGF5b3V0R3JpZC5DZWxsID0gTGF5b3V0R3JpZENlbGw7XHJcblxyXG5leHBvcnQge1xyXG4gICAgTGF5b3V0R3JpZCBhcyBkZWZhdWx0LFxyXG4gICAgTGF5b3V0R3JpZENlbGxcclxufTsiLCJleHBvcnQgY29uc3QgY3NzQ2xhc3NlcyA9IHtcclxuICAgIFJPT1Q6ICdtZGMtcmFkaW8nLFxyXG4gICAgRElTQUJMRUQ6ICdtZGMtcmFkaW8tLWRpc2FibGVkJyxcclxuICAgIFRPVUNIOiAnbWRjLXJhZGlvLS10b3VjaCcsXHJcblxyXG4gICAgTkFUSVZFX0NPTlRST0w6ICdtZGMtcmFkaW9fX25hdGl2ZS1jb250cm9sJyxcclxuICAgIEJBQ0tHUk9VTkQ6ICdtZGMtcmFkaW9fX2JhY2tncm91bmQnLFxyXG4gICAgT1VURVJfQ0lSQ0xFOiAnbWRjLXJhZGlvX19vdXRlci1jaXJjbGUnLFxyXG4gICAgSU5ORVJfQ0lSQ0xFOiAnbWRjLXJhZGlvX19pbm5lci1jaXJjbGUnLFxyXG4gICAgUklQUExFOiAnbWRjLXJhZGlvX19yaXBwbGUnXHJcbn07IiwiaW1wb3J0IHsgdXNlUmVmLCB1c2VDYWxsYmFjaywgZm9yd2FyZFJlZiB9IGZyb20gJ3JlYWN0JztcclxuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcclxuaW1wb3J0IGNsYXNzbmFtZXMgZnJvbSAnY2xhc3NuYW1lcyc7XHJcblxyXG5pbXBvcnQgeyBjc3NDbGFzc2VzIH0gZnJvbSAnLi9jb25zdGFudHMnO1xyXG5cclxuY29uc3QgUmFkaW8gPSBmb3J3YXJkUmVmKCh7XHJcbiAgICB2YWx1ZSxcclxuICAgIGNoZWNrZWQsXHJcbiAgICBkaXNhYmxlZCA9IGZhbHNlLFxyXG4gICAgdG91Y2ggPSBmYWxzZSxcclxuICAgIG9uQ2hhbmdlID0gRnVuY3Rpb24ucHJvdG90eXBlLFxyXG5cclxuICAgIGNsYXNzTmFtZSxcclxuICAgIC4uLnByb3BzXHJcbn0sIHJlZikgPT4ge1xyXG4gICAgY29uc3QgaW5wdXRSZWYgPSB1c2VSZWYoKTtcclxuXHJcbiAgICBjb25zdCBoYW5kbGVDaGFuZ2UgPSB1c2VDYWxsYmFjayhldmVudCA9PiB7XHJcbiAgICAgICAgb25DaGFuZ2UoZXZlbnQsIGV2ZW50LnRhcmdldC52YWx1ZSwgZXZlbnQudGFyZ2V0KTtcclxuICAgIH0sIFtvbkNoYW5nZV0pO1xyXG5cclxuICAgIGNvbnN0IGNsYXNzTmFtZXMgPSBjbGFzc25hbWVzKGNzc0NsYXNzZXMuUk9PVCwge1xyXG4gICAgICAgIFtjc3NDbGFzc2VzLkRJU0FCTEVEXTogZGlzYWJsZWQsXHJcbiAgICAgICAgW2Nzc0NsYXNzZXMuVE9VQ0hdOiB0b3VjaFxyXG4gICAgfSwgY2xhc3NOYW1lKTtcclxuXHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAgIDxkaXYgcmVmPXtyZWZ9IGNsYXNzTmFtZT17Y2xhc3NOYW1lc30+XHJcbiAgICAgICAgICAgIDxpbnB1dFxyXG4gICAgICAgICAgICAgICAgcmVmPXtpbnB1dFJlZn1cclxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZT17Y3NzQ2xhc3Nlcy5OQVRJVkVfQ09OVFJPTH1cclxuICAgICAgICAgICAgICAgIHR5cGU9XCJyYWRpb1wiXHJcbiAgICAgICAgICAgICAgICB2YWx1ZT17dmFsdWV9XHJcbiAgICAgICAgICAgICAgICBjaGVja2VkPXtjaGVja2VkfVxyXG4gICAgICAgICAgICAgICAgZGlzYWJsZWQ9e2Rpc2FibGVkfVxyXG4gICAgICAgICAgICAgICAgb25DaGFuZ2U9e2hhbmRsZUNoYW5nZX1cclxuICAgICAgICAgICAgICAgIHsuLi5wcm9wc31cclxuICAgICAgICAgICAgLz5cclxuXHJcbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXtjc3NDbGFzc2VzLkJBQ0tHUk9VTkR9PlxyXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9e2Nzc0NsYXNzZXMuT1VURVJfQ0lSQ0xFfSAvPlxyXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9e2Nzc0NsYXNzZXMuSU5ORVJfQ0lSQ0xFfSAvPlxyXG4gICAgICAgICAgICA8L2Rpdj5cclxuXHJcbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXtjc3NDbGFzc2VzLlJJUFBMRX0gLz5cclxuICAgICAgICA8L2Rpdj5cclxuICAgICk7XHJcbn0pO1xyXG5cclxuUmFkaW8uZGlzcGxheU5hbWUgPSAnTURDUmFkaW8nO1xyXG5cclxuUmFkaW8ucHJvcFR5cGVzID0ge1xyXG4gICAgdmFsdWU6IFByb3BUeXBlcy5hbnksXHJcbiAgICBjaGVja2VkOiBQcm9wVHlwZXMuYm9vbCxcclxuICAgIGRpc2FibGVkOiBQcm9wVHlwZXMuYm9vbCxcclxuICAgIHRvdWNoOiBQcm9wVHlwZXMuYm9vbCxcclxuICAgIG9uQ2hhbmdlOiBQcm9wVHlwZXMuZnVuY1xyXG59O1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgUmFkaW87IiwiZXhwb3J0IHsgZGVmYXVsdCB9IGZyb20gJy4vUmFkaW8nOyIsIi8qISAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG5Db3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi5cclxuXHJcblBlcm1pc3Npb24gdG8gdXNlLCBjb3B5LCBtb2RpZnksIGFuZC9vciBkaXN0cmlidXRlIHRoaXMgc29mdHdhcmUgZm9yIGFueVxyXG5wdXJwb3NlIHdpdGggb3Igd2l0aG91dCBmZWUgaXMgaGVyZWJ5IGdyYW50ZWQuXHJcblxyXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiIEFORCBUSEUgQVVUSE9SIERJU0NMQUlNUyBBTEwgV0FSUkFOVElFUyBXSVRIXHJcblJFR0FSRCBUTyBUSElTIFNPRlRXQVJFIElOQ0xVRElORyBBTEwgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWVxyXG5BTkQgRklUTkVTUy4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUiBCRSBMSUFCTEUgRk9SIEFOWSBTUEVDSUFMLCBESVJFQ1QsXHJcbklORElSRUNULCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgT1IgQU5ZIERBTUFHRVMgV0hBVFNPRVZFUiBSRVNVTFRJTkcgRlJPTVxyXG5MT1NTIE9GIFVTRSwgREFUQSBPUiBQUk9GSVRTLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgTkVHTElHRU5DRSBPUlxyXG5PVEhFUiBUT1JUSU9VUyBBQ1RJT04sIEFSSVNJTkcgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgVVNFIE9SXHJcblBFUkZPUk1BTkNFIE9GIFRISVMgU09GVFdBUkUuXHJcbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXHJcbi8qIGdsb2JhbCBSZWZsZWN0LCBQcm9taXNlICovXHJcblxyXG52YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uKGQsIGIpIHtcclxuICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcclxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XHJcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIHApKSBkW3BdID0gYltwXTsgfTtcclxuICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG59O1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fZXh0ZW5kcyhkLCBiKSB7XHJcbiAgICBpZiAodHlwZW9mIGIgIT09IFwiZnVuY3Rpb25cIiAmJiBiICE9PSBudWxsKVxyXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDbGFzcyBleHRlbmRzIHZhbHVlIFwiICsgU3RyaW5nKGIpICsgXCIgaXMgbm90IGEgY29uc3RydWN0b3Igb3IgbnVsbFwiKTtcclxuICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cclxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcclxufVxyXG5cclxuZXhwb3J0IHZhciBfX2Fzc2lnbiA9IGZ1bmN0aW9uKCkge1xyXG4gICAgX19hc3NpZ24gPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uIF9fYXNzaWduKHQpIHtcclxuICAgICAgICBmb3IgKHZhciBzLCBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcclxuICAgICAgICAgICAgcyA9IGFyZ3VtZW50c1tpXTtcclxuICAgICAgICAgICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApKSB0W3BdID0gc1twXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHQ7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gX19hc3NpZ24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fcmVzdChzLCBlKSB7XHJcbiAgICB2YXIgdCA9IHt9O1xyXG4gICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApICYmIGUuaW5kZXhPZihwKSA8IDApXHJcbiAgICAgICAgdFtwXSA9IHNbcF07XHJcbiAgICBpZiAocyAhPSBudWxsICYmIHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzID09PSBcImZ1bmN0aW9uXCIpXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIHAgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHMpOyBpIDwgcC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAoZS5pbmRleE9mKHBbaV0pIDwgMCAmJiBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwocywgcFtpXSkpXHJcbiAgICAgICAgICAgICAgICB0W3BbaV1dID0gc1twW2ldXTtcclxuICAgICAgICB9XHJcbiAgICByZXR1cm4gdDtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcclxuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XHJcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xyXG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcclxuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX3BhcmFtKHBhcmFtSW5kZXgsIGRlY29yYXRvcikge1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uICh0YXJnZXQsIGtleSkgeyBkZWNvcmF0b3IodGFyZ2V0LCBrZXksIHBhcmFtSW5kZXgpOyB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX21ldGFkYXRhKG1ldGFkYXRhS2V5LCBtZXRhZGF0YVZhbHVlKSB7XHJcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEobWV0YWRhdGFLZXksIG1ldGFkYXRhVmFsdWUpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19hd2FpdGVyKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xyXG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XHJcbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XHJcbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XHJcbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cclxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XHJcbiAgICB9KTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fZ2VuZXJhdG9yKHRoaXNBcmcsIGJvZHkpIHtcclxuICAgIHZhciBfID0geyBsYWJlbDogMCwgc2VudDogZnVuY3Rpb24oKSB7IGlmICh0WzBdICYgMSkgdGhyb3cgdFsxXTsgcmV0dXJuIHRbMV07IH0sIHRyeXM6IFtdLCBvcHM6IFtdIH0sIGYsIHksIHQsIGc7XHJcbiAgICByZXR1cm4gZyA9IHsgbmV4dDogdmVyYigwKSwgXCJ0aHJvd1wiOiB2ZXJiKDEpLCBcInJldHVyblwiOiB2ZXJiKDIpIH0sIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiAoZ1tTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9KSwgZztcclxuICAgIGZ1bmN0aW9uIHZlcmIobikgeyByZXR1cm4gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHN0ZXAoW24sIHZdKTsgfTsgfVxyXG4gICAgZnVuY3Rpb24gc3RlcChvcCkge1xyXG4gICAgICAgIGlmIChmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgZXhlY3V0aW5nLlwiKTtcclxuICAgICAgICB3aGlsZSAoXykgdHJ5IHtcclxuICAgICAgICAgICAgaWYgKGYgPSAxLCB5ICYmICh0ID0gb3BbMF0gJiAyID8geVtcInJldHVyblwiXSA6IG9wWzBdID8geVtcInRocm93XCJdIHx8ICgodCA9IHlbXCJyZXR1cm5cIl0pICYmIHQuY2FsbCh5KSwgMCkgOiB5Lm5leHQpICYmICEodCA9IHQuY2FsbCh5LCBvcFsxXSkpLmRvbmUpIHJldHVybiB0O1xyXG4gICAgICAgICAgICBpZiAoeSA9IDAsIHQpIG9wID0gW29wWzBdICYgMiwgdC52YWx1ZV07XHJcbiAgICAgICAgICAgIHN3aXRjaCAob3BbMF0pIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgMDogY2FzZSAxOiB0ID0gb3A7IGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSA0OiBfLmxhYmVsKys7IHJldHVybiB7IHZhbHVlOiBvcFsxXSwgZG9uZTogZmFsc2UgfTtcclxuICAgICAgICAgICAgICAgIGNhc2UgNTogXy5sYWJlbCsrOyB5ID0gb3BbMV07IG9wID0gWzBdOyBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIGNhc2UgNzogb3AgPSBfLm9wcy5wb3AoKTsgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEodCA9IF8udHJ5cywgdCA9IHQubGVuZ3RoID4gMCAmJiB0W3QubGVuZ3RoIC0gMV0pICYmIChvcFswXSA9PT0gNiB8fCBvcFswXSA9PT0gMikpIHsgXyA9IDA7IGNvbnRpbnVlOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSAzICYmICghdCB8fCAob3BbMV0gPiB0WzBdICYmIG9wWzFdIDwgdFszXSkpKSB7IF8ubGFiZWwgPSBvcFsxXTsgYnJlYWs7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDYgJiYgXy5sYWJlbCA8IHRbMV0pIHsgXy5sYWJlbCA9IHRbMV07IHQgPSBvcDsgYnJlYWs7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAodCAmJiBfLmxhYmVsIDwgdFsyXSkgeyBfLmxhYmVsID0gdFsyXTsgXy5vcHMucHVzaChvcCk7IGJyZWFrOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRbMl0pIF8ub3BzLnBvcCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIF8udHJ5cy5wb3AoKTsgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgb3AgPSBib2R5LmNhbGwodGhpc0FyZywgXyk7XHJcbiAgICAgICAgfSBjYXRjaCAoZSkgeyBvcCA9IFs2LCBlXTsgeSA9IDA7IH0gZmluYWxseSB7IGYgPSB0ID0gMDsgfVxyXG4gICAgICAgIGlmIChvcFswXSAmIDUpIHRocm93IG9wWzFdOyByZXR1cm4geyB2YWx1ZTogb3BbMF0gPyBvcFsxXSA6IHZvaWQgMCwgZG9uZTogdHJ1ZSB9O1xyXG4gICAgfVxyXG59XHJcblxyXG5leHBvcnQgdmFyIF9fY3JlYXRlQmluZGluZyA9IE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcclxuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfSk7XHJcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XHJcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xyXG4gICAgb1trMl0gPSBtW2tdO1xyXG59KTtcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2V4cG9ydFN0YXIobSwgbykge1xyXG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAocCAhPT0gXCJkZWZhdWx0XCIgJiYgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvLCBwKSkgX19jcmVhdGVCaW5kaW5nKG8sIG0sIHApO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX192YWx1ZXMobykge1xyXG4gICAgdmFyIHMgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgU3ltYm9sLml0ZXJhdG9yLCBtID0gcyAmJiBvW3NdLCBpID0gMDtcclxuICAgIGlmIChtKSByZXR1cm4gbS5jYWxsKG8pO1xyXG4gICAgaWYgKG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09PSBcIm51bWJlclwiKSByZXR1cm4ge1xyXG4gICAgICAgIG5leHQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYgKG8gJiYgaSA+PSBvLmxlbmd0aCkgbyA9IHZvaWQgMDtcclxuICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IG8gJiYgb1tpKytdLCBkb25lOiAhbyB9O1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKHMgPyBcIk9iamVjdCBpcyBub3QgaXRlcmFibGUuXCIgOiBcIlN5bWJvbC5pdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX3JlYWQobywgbikge1xyXG4gICAgdmFyIG0gPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdO1xyXG4gICAgaWYgKCFtKSByZXR1cm4gbztcclxuICAgIHZhciBpID0gbS5jYWxsKG8pLCByLCBhciA9IFtdLCBlO1xyXG4gICAgdHJ5IHtcclxuICAgICAgICB3aGlsZSAoKG4gPT09IHZvaWQgMCB8fCBuLS0gPiAwKSAmJiAhKHIgPSBpLm5leHQoKSkuZG9uZSkgYXIucHVzaChyLnZhbHVlKTtcclxuICAgIH1cclxuICAgIGNhdGNoIChlcnJvcikgeyBlID0geyBlcnJvcjogZXJyb3IgfTsgfVxyXG4gICAgZmluYWxseSB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgaWYgKHIgJiYgIXIuZG9uZSAmJiAobSA9IGlbXCJyZXR1cm5cIl0pKSBtLmNhbGwoaSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZpbmFsbHkgeyBpZiAoZSkgdGhyb3cgZS5lcnJvcjsgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGFyO1xyXG59XHJcblxyXG4vKiogQGRlcHJlY2F0ZWQgKi9cclxuZXhwb3J0IGZ1bmN0aW9uIF9fc3ByZWFkKCkge1xyXG4gICAgZm9yICh2YXIgYXIgPSBbXSwgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspXHJcbiAgICAgICAgYXIgPSBhci5jb25jYXQoX19yZWFkKGFyZ3VtZW50c1tpXSkpO1xyXG4gICAgcmV0dXJuIGFyO1xyXG59XHJcblxyXG4vKiogQGRlcHJlY2F0ZWQgKi9cclxuZXhwb3J0IGZ1bmN0aW9uIF9fc3ByZWFkQXJyYXlzKCkge1xyXG4gICAgZm9yICh2YXIgcyA9IDAsIGkgPSAwLCBpbCA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBpbDsgaSsrKSBzICs9IGFyZ3VtZW50c1tpXS5sZW5ndGg7XHJcbiAgICBmb3IgKHZhciByID0gQXJyYXkocyksIGsgPSAwLCBpID0gMDsgaSA8IGlsOyBpKyspXHJcbiAgICAgICAgZm9yICh2YXIgYSA9IGFyZ3VtZW50c1tpXSwgaiA9IDAsIGpsID0gYS5sZW5ndGg7IGogPCBqbDsgaisrLCBrKyspXHJcbiAgICAgICAgICAgIHJba10gPSBhW2pdO1xyXG4gICAgcmV0dXJuIHI7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX3NwcmVhZEFycmF5KHRvLCBmcm9tLCBwYWNrKSB7XHJcbiAgICBpZiAocGFjayB8fCBhcmd1bWVudHMubGVuZ3RoID09PSAyKSBmb3IgKHZhciBpID0gMCwgbCA9IGZyb20ubGVuZ3RoLCBhcjsgaSA8IGw7IGkrKykge1xyXG4gICAgICAgIGlmIChhciB8fCAhKGkgaW4gZnJvbSkpIHtcclxuICAgICAgICAgICAgaWYgKCFhcikgYXIgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChmcm9tLCAwLCBpKTtcclxuICAgICAgICAgICAgYXJbaV0gPSBmcm9tW2ldO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiB0by5jb25jYXQoYXIgfHwgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZnJvbSkpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19hd2FpdCh2KSB7XHJcbiAgICByZXR1cm4gdGhpcyBpbnN0YW5jZW9mIF9fYXdhaXQgPyAodGhpcy52ID0gdiwgdGhpcykgOiBuZXcgX19hd2FpdCh2KTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fYXN5bmNHZW5lcmF0b3IodGhpc0FyZywgX2FyZ3VtZW50cywgZ2VuZXJhdG9yKSB7XHJcbiAgICBpZiAoIVN5bWJvbC5hc3luY0l0ZXJhdG9yKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3ltYm9sLmFzeW5jSXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xyXG4gICAgdmFyIGcgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSksIGksIHEgPSBbXTtcclxuICAgIHJldHVybiBpID0ge30sIHZlcmIoXCJuZXh0XCIpLCB2ZXJiKFwidGhyb3dcIiksIHZlcmIoXCJyZXR1cm5cIiksIGlbU3ltYm9sLmFzeW5jSXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSwgaTtcclxuICAgIGZ1bmN0aW9uIHZlcmIobikgeyBpZiAoZ1tuXSkgaVtuXSA9IGZ1bmN0aW9uICh2KSB7IHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAoYSwgYikgeyBxLnB1c2goW24sIHYsIGEsIGJdKSA+IDEgfHwgcmVzdW1lKG4sIHYpOyB9KTsgfTsgfVxyXG4gICAgZnVuY3Rpb24gcmVzdW1lKG4sIHYpIHsgdHJ5IHsgc3RlcChnW25dKHYpKTsgfSBjYXRjaCAoZSkgeyBzZXR0bGUocVswXVszXSwgZSk7IH0gfVxyXG4gICAgZnVuY3Rpb24gc3RlcChyKSB7IHIudmFsdWUgaW5zdGFuY2VvZiBfX2F3YWl0ID8gUHJvbWlzZS5yZXNvbHZlKHIudmFsdWUudikudGhlbihmdWxmaWxsLCByZWplY3QpIDogc2V0dGxlKHFbMF1bMl0sIHIpOyB9XHJcbiAgICBmdW5jdGlvbiBmdWxmaWxsKHZhbHVlKSB7IHJlc3VtZShcIm5leHRcIiwgdmFsdWUpOyB9XHJcbiAgICBmdW5jdGlvbiByZWplY3QodmFsdWUpIHsgcmVzdW1lKFwidGhyb3dcIiwgdmFsdWUpOyB9XHJcbiAgICBmdW5jdGlvbiBzZXR0bGUoZiwgdikgeyBpZiAoZih2KSwgcS5zaGlmdCgpLCBxLmxlbmd0aCkgcmVzdW1lKHFbMF1bMF0sIHFbMF1bMV0pOyB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2FzeW5jRGVsZWdhdG9yKG8pIHtcclxuICAgIHZhciBpLCBwO1xyXG4gICAgcmV0dXJuIGkgPSB7fSwgdmVyYihcIm5leHRcIiksIHZlcmIoXCJ0aHJvd1wiLCBmdW5jdGlvbiAoZSkgeyB0aHJvdyBlOyB9KSwgdmVyYihcInJldHVyblwiKSwgaVtTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSwgaTtcclxuICAgIGZ1bmN0aW9uIHZlcmIobiwgZikgeyBpW25dID0gb1tuXSA/IGZ1bmN0aW9uICh2KSB7IHJldHVybiAocCA9ICFwKSA/IHsgdmFsdWU6IF9fYXdhaXQob1tuXSh2KSksIGRvbmU6IG4gPT09IFwicmV0dXJuXCIgfSA6IGYgPyBmKHYpIDogdjsgfSA6IGY7IH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fYXN5bmNWYWx1ZXMobykge1xyXG4gICAgaWYgKCFTeW1ib2wuYXN5bmNJdGVyYXRvcikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN5bWJvbC5hc3luY0l0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcclxuICAgIHZhciBtID0gb1tTeW1ib2wuYXN5bmNJdGVyYXRvcl0sIGk7XHJcbiAgICByZXR1cm4gbSA/IG0uY2FsbChvKSA6IChvID0gdHlwZW9mIF9fdmFsdWVzID09PSBcImZ1bmN0aW9uXCIgPyBfX3ZhbHVlcyhvKSA6IG9bU3ltYm9sLml0ZXJhdG9yXSgpLCBpID0ge30sIHZlcmIoXCJuZXh0XCIpLCB2ZXJiKFwidGhyb3dcIiksIHZlcmIoXCJyZXR1cm5cIiksIGlbU3ltYm9sLmFzeW5jSXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSwgaSk7XHJcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgaVtuXSA9IG9bbl0gJiYgZnVuY3Rpb24gKHYpIHsgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHsgdiA9IG9bbl0odiksIHNldHRsZShyZXNvbHZlLCByZWplY3QsIHYuZG9uZSwgdi52YWx1ZSk7IH0pOyB9OyB9XHJcbiAgICBmdW5jdGlvbiBzZXR0bGUocmVzb2x2ZSwgcmVqZWN0LCBkLCB2KSB7IFByb21pc2UucmVzb2x2ZSh2KS50aGVuKGZ1bmN0aW9uKHYpIHsgcmVzb2x2ZSh7IHZhbHVlOiB2LCBkb25lOiBkIH0pOyB9LCByZWplY3QpOyB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX21ha2VUZW1wbGF0ZU9iamVjdChjb29rZWQsIHJhdykge1xyXG4gICAgaWYgKE9iamVjdC5kZWZpbmVQcm9wZXJ0eSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkoY29va2VkLCBcInJhd1wiLCB7IHZhbHVlOiByYXcgfSk7IH0gZWxzZSB7IGNvb2tlZC5yYXcgPSByYXc7IH1cclxuICAgIHJldHVybiBjb29rZWQ7XHJcbn07XHJcblxyXG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCB2KSB7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XHJcbn0pIDogZnVuY3Rpb24obywgdikge1xyXG4gICAgb1tcImRlZmF1bHRcIl0gPSB2O1xyXG59O1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9faW1wb3J0U3Rhcihtb2QpIHtcclxuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XHJcbiAgICB2YXIgcmVzdWx0ID0ge307XHJcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoayAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwgayk7XHJcbiAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9faW1wb3J0RGVmYXVsdChtb2QpIHtcclxuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgZGVmYXVsdDogbW9kIH07XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHJlY2VpdmVyLCBzdGF0ZSwga2luZCwgZikge1xyXG4gICAgaWYgKGtpbmQgPT09IFwiYVwiICYmICFmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJpdmF0ZSBhY2Nlc3NvciB3YXMgZGVmaW5lZCB3aXRob3V0IGEgZ2V0dGVyXCIpO1xyXG4gICAgaWYgKHR5cGVvZiBzdGF0ZSA9PT0gXCJmdW5jdGlvblwiID8gcmVjZWl2ZXIgIT09IHN0YXRlIHx8ICFmIDogIXN0YXRlLmhhcyhyZWNlaXZlcikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgcmVhZCBwcml2YXRlIG1lbWJlciBmcm9tIGFuIG9iamVjdCB3aG9zZSBjbGFzcyBkaWQgbm90IGRlY2xhcmUgaXRcIik7XHJcbiAgICByZXR1cm4ga2luZCA9PT0gXCJtXCIgPyBmIDoga2luZCA9PT0gXCJhXCIgPyBmLmNhbGwocmVjZWl2ZXIpIDogZiA/IGYudmFsdWUgOiBzdGF0ZS5nZXQocmVjZWl2ZXIpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19jbGFzc1ByaXZhdGVGaWVsZFNldChyZWNlaXZlciwgc3RhdGUsIHZhbHVlLCBraW5kLCBmKSB7XHJcbiAgICBpZiAoa2luZCA9PT0gXCJtXCIpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIG1ldGhvZCBpcyBub3Qgd3JpdGFibGVcIik7XHJcbiAgICBpZiAoa2luZCA9PT0gXCJhXCIgJiYgIWYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIGFjY2Vzc29yIHdhcyBkZWZpbmVkIHdpdGhvdXQgYSBzZXR0ZXJcIik7XHJcbiAgICBpZiAodHlwZW9mIHN0YXRlID09PSBcImZ1bmN0aW9uXCIgPyByZWNlaXZlciAhPT0gc3RhdGUgfHwgIWYgOiAhc3RhdGUuaGFzKHJlY2VpdmVyKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCB3cml0ZSBwcml2YXRlIG1lbWJlciB0byBhbiBvYmplY3Qgd2hvc2UgY2xhc3MgZGlkIG5vdCBkZWNsYXJlIGl0XCIpO1xyXG4gICAgcmV0dXJuIChraW5kID09PSBcImFcIiA/IGYuY2FsbChyZWNlaXZlciwgdmFsdWUpIDogZiA/IGYudmFsdWUgPSB2YWx1ZSA6IHN0YXRlLnNldChyZWNlaXZlciwgdmFsdWUpKSwgdmFsdWU7XHJcbn1cclxuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy5cbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuICogVEhFIFNPRlRXQVJFLlxuICovXG52YXIgTURDRm91bmRhdGlvbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNRENGb3VuZGF0aW9uKGFkYXB0ZXIpIHtcbiAgICAgICAgaWYgKGFkYXB0ZXIgPT09IHZvaWQgMCkgeyBhZGFwdGVyID0ge307IH1cbiAgICAgICAgdGhpcy5hZGFwdGVyID0gYWRhcHRlcjtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1EQ0ZvdW5kYXRpb24sIFwiY3NzQ2xhc3Nlc1wiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgLy8gQ2xhc3NlcyBleHRlbmRpbmcgTURDRm91bmRhdGlvbiBzaG91bGQgaW1wbGVtZW50IHRoaXMgbWV0aG9kIHRvIHJldHVybiBhbiBvYmplY3Qgd2hpY2ggZXhwb3J0cyBldmVyeVxuICAgICAgICAgICAgLy8gQ1NTIGNsYXNzIHRoZSBmb3VuZGF0aW9uIGNsYXNzIG5lZWRzIGFzIGEgcHJvcGVydHkuIGUuZy4ge0FDVElWRTogJ21kYy1jb21wb25lbnQtLWFjdGl2ZSd9XG4gICAgICAgICAgICByZXR1cm4ge307XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTURDRm91bmRhdGlvbiwgXCJzdHJpbmdzXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvLyBDbGFzc2VzIGV4dGVuZGluZyBNRENGb3VuZGF0aW9uIHNob3VsZCBpbXBsZW1lbnQgdGhpcyBtZXRob2QgdG8gcmV0dXJuIGFuIG9iamVjdCB3aGljaCBleHBvcnRzIGFsbFxuICAgICAgICAgICAgLy8gc2VtYW50aWMgc3RyaW5ncyBhcyBjb25zdGFudHMuIGUuZy4ge0FSSUFfUk9MRTogJ3RhYmxpc3QnfVxuICAgICAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1EQ0ZvdW5kYXRpb24sIFwibnVtYmVyc1wiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgLy8gQ2xhc3NlcyBleHRlbmRpbmcgTURDRm91bmRhdGlvbiBzaG91bGQgaW1wbGVtZW50IHRoaXMgbWV0aG9kIHRvIHJldHVybiBhbiBvYmplY3Qgd2hpY2ggZXhwb3J0cyBhbGxcbiAgICAgICAgICAgIC8vIG9mIGl0cyBzZW1hbnRpYyBudW1iZXJzIGFzIGNvbnN0YW50cy4gZS5nLiB7QU5JTUFUSU9OX0RFTEFZX01TOiAzNTB9XG4gICAgICAgICAgICByZXR1cm4ge307XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTURDRm91bmRhdGlvbiwgXCJkZWZhdWx0QWRhcHRlclwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgLy8gQ2xhc3NlcyBleHRlbmRpbmcgTURDRm91bmRhdGlvbiBtYXkgY2hvb3NlIHRvIGltcGxlbWVudCB0aGlzIGdldHRlciBpbiBvcmRlciB0byBwcm92aWRlIGEgY29udmVuaWVudFxuICAgICAgICAgICAgLy8gd2F5IG9mIHZpZXdpbmcgdGhlIG5lY2Vzc2FyeSBtZXRob2RzIG9mIGFuIGFkYXB0ZXIuIEluIHRoZSBmdXR1cmUsIHRoaXMgY291bGQgYWxzbyBiZSB1c2VkIGZvciBhZGFwdGVyXG4gICAgICAgICAgICAvLyB2YWxpZGF0aW9uLlxuICAgICAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgTURDRm91bmRhdGlvbi5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gU3ViY2xhc3NlcyBzaG91bGQgb3ZlcnJpZGUgdGhpcyBtZXRob2QgdG8gcGVyZm9ybSBpbml0aWFsaXphdGlvbiByb3V0aW5lcyAocmVnaXN0ZXJpbmcgZXZlbnRzLCBldGMuKVxuICAgIH07XG4gICAgTURDRm91bmRhdGlvbi5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gU3ViY2xhc3NlcyBzaG91bGQgb3ZlcnJpZGUgdGhpcyBtZXRob2QgdG8gcGVyZm9ybSBkZS1pbml0aWFsaXphdGlvbiByb3V0aW5lcyAoZGUtcmVnaXN0ZXJpbmcgZXZlbnRzLCBldGMuKVxuICAgIH07XG4gICAgcmV0dXJuIE1EQ0ZvdW5kYXRpb247XG59KCkpO1xuZXhwb3J0IHsgTURDRm91bmRhdGlvbiB9O1xuLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLWRlZmF1bHQtZXhwb3J0IE5lZWRlZCBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eSB3aXRoIE1EQyBXZWIgdjAuNDQuMCBhbmQgZWFybGllci5cbmV4cG9ydCBkZWZhdWx0IE1EQ0ZvdW5kYXRpb247XG4vLyMgc291cmNlTWFwcGluZ1VSTD1mb3VuZGF0aW9uLmpzLm1hcCIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuXG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICpcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4gKiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbiAqIFRIRSBTT0ZUV0FSRS5cbiAqL1xuaW1wb3J0IHsgX19yZWFkLCBfX3NwcmVhZEFycmF5IH0gZnJvbSBcInRzbGliXCI7XG5pbXBvcnQgeyBNRENGb3VuZGF0aW9uIH0gZnJvbSAnLi9mb3VuZGF0aW9uJztcbnZhciBNRENDb21wb25lbnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTURDQ29tcG9uZW50KHJvb3QsIGZvdW5kYXRpb24pIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAyOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIGFyZ3NbX2kgLSAyXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yb290ID0gcm9vdDtcbiAgICAgICAgdGhpcy5pbml0aWFsaXplLmFwcGx5KHRoaXMsIF9fc3ByZWFkQXJyYXkoW10sIF9fcmVhZChhcmdzKSkpO1xuICAgICAgICAvLyBOb3RlIHRoYXQgd2UgaW5pdGlhbGl6ZSBmb3VuZGF0aW9uIGhlcmUgYW5kIG5vdCB3aXRoaW4gdGhlIGNvbnN0cnVjdG9yJ3NcbiAgICAgICAgLy8gZGVmYXVsdCBwYXJhbSBzbyB0aGF0IHRoaXMucm9vdCBpcyBkZWZpbmVkIGFuZCBjYW4gYmUgdXNlZCB3aXRoaW4gdGhlXG4gICAgICAgIC8vIGZvdW5kYXRpb24gY2xhc3MuXG4gICAgICAgIHRoaXMuZm91bmRhdGlvbiA9XG4gICAgICAgICAgICBmb3VuZGF0aW9uID09PSB1bmRlZmluZWQgPyB0aGlzLmdldERlZmF1bHRGb3VuZGF0aW9uKCkgOiBmb3VuZGF0aW9uO1xuICAgICAgICB0aGlzLmZvdW5kYXRpb24uaW5pdCgpO1xuICAgICAgICB0aGlzLmluaXRpYWxTeW5jV2l0aERPTSgpO1xuICAgIH1cbiAgICBNRENDb21wb25lbnQuYXR0YWNoVG8gPSBmdW5jdGlvbiAocm9vdCkge1xuICAgICAgICAvLyBTdWJjbGFzc2VzIHdoaWNoIGV4dGVuZCBNRENCYXNlIHNob3VsZCBwcm92aWRlIGFuIGF0dGFjaFRvKCkgbWV0aG9kIHRoYXQgdGFrZXMgYSByb290IGVsZW1lbnQgYW5kXG4gICAgICAgIC8vIHJldHVybnMgYW4gaW5zdGFudGlhdGVkIGNvbXBvbmVudCB3aXRoIGl0cyByb290IHNldCB0byB0aGF0IGVsZW1lbnQuIEFsc28gbm90ZSB0aGF0IGluIHRoZSBjYXNlcyBvZlxuICAgICAgICAvLyBzdWJjbGFzc2VzLCBhbiBleHBsaWNpdCBmb3VuZGF0aW9uIGNsYXNzIHdpbGwgbm90IGhhdmUgdG8gYmUgcGFzc2VkIGluOyBpdCB3aWxsIHNpbXBseSBiZSBpbml0aWFsaXplZFxuICAgICAgICAvLyBmcm9tIGdldERlZmF1bHRGb3VuZGF0aW9uKCkuXG4gICAgICAgIHJldHVybiBuZXcgTURDQ29tcG9uZW50KHJvb3QsIG5ldyBNRENGb3VuZGF0aW9uKHt9KSk7XG4gICAgfTtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dDogbWV0aG9kIHBhcmFtIG9ubHkgZXhpc3RzIGZvciB0eXBpbmcgcHVycG9zZXM7IGl0IGRvZXMgbm90IG5lZWQgdG8gYmUgdW5pdCB0ZXN0ZWQgKi9cbiAgICBNRENDb21wb25lbnQucHJvdG90eXBlLmluaXRpYWxpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfYXJncyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgX2FyZ3NbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgfVxuICAgICAgICAvLyBTdWJjbGFzc2VzIGNhbiBvdmVycmlkZSB0aGlzIHRvIGRvIGFueSBhZGRpdGlvbmFsIHNldHVwIHdvcmsgdGhhdCB3b3VsZCBiZSBjb25zaWRlcmVkIHBhcnQgb2YgYVxuICAgICAgICAvLyBcImNvbnN0cnVjdG9yXCIuIEVzc2VudGlhbGx5LCBpdCBpcyBhIGhvb2sgaW50byB0aGUgcGFyZW50IGNvbnN0cnVjdG9yIGJlZm9yZSB0aGUgZm91bmRhdGlvbiBpc1xuICAgICAgICAvLyBpbml0aWFsaXplZC4gQW55IGFkZGl0aW9uYWwgYXJndW1lbnRzIGJlc2lkZXMgcm9vdCBhbmQgZm91bmRhdGlvbiB3aWxsIGJlIHBhc3NlZCBpbiBoZXJlLlxuICAgIH07XG4gICAgTURDQ29tcG9uZW50LnByb3RvdHlwZS5nZXREZWZhdWx0Rm91bmRhdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gU3ViY2xhc3NlcyBtdXN0IG92ZXJyaWRlIHRoaXMgbWV0aG9kIHRvIHJldHVybiBhIHByb3Blcmx5IGNvbmZpZ3VyZWQgZm91bmRhdGlvbiBjbGFzcyBmb3IgdGhlXG4gICAgICAgIC8vIGNvbXBvbmVudC5cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTdWJjbGFzc2VzIG11c3Qgb3ZlcnJpZGUgZ2V0RGVmYXVsdEZvdW5kYXRpb24gdG8gcmV0dXJuIGEgcHJvcGVybHkgY29uZmlndXJlZCAnICtcbiAgICAgICAgICAgICdmb3VuZGF0aW9uIGNsYXNzJyk7XG4gICAgfTtcbiAgICBNRENDb21wb25lbnQucHJvdG90eXBlLmluaXRpYWxTeW5jV2l0aERPTSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gU3ViY2xhc3NlcyBzaG91bGQgb3ZlcnJpZGUgdGhpcyBtZXRob2QgaWYgdGhleSBuZWVkIHRvIHBlcmZvcm0gd29yayB0byBzeW5jaHJvbml6ZSB3aXRoIGEgaG9zdCBET01cbiAgICAgICAgLy8gb2JqZWN0LiBBbiBleGFtcGxlIG9mIHRoaXMgd291bGQgYmUgYSBmb3JtIGNvbnRyb2wgd3JhcHBlciB0aGF0IG5lZWRzIHRvIHN5bmNocm9uaXplIGl0cyBpbnRlcm5hbCBzdGF0ZVxuICAgICAgICAvLyB0byBzb21lIHByb3BlcnR5IG9yIGF0dHJpYnV0ZSBvZiB0aGUgaG9zdCBET00uIFBsZWFzZSBub3RlOiB0aGlzIGlzICpub3QqIHRoZSBwbGFjZSB0byBwZXJmb3JtIERPTVxuICAgICAgICAvLyByZWFkcy93cml0ZXMgdGhhdCB3b3VsZCBjYXVzZSBsYXlvdXQgLyBwYWludCwgYXMgdGhpcyBpcyBjYWxsZWQgc3luY2hyb25vdXNseSBmcm9tIHdpdGhpbiB0aGUgY29uc3RydWN0b3IuXG4gICAgfTtcbiAgICBNRENDb21wb25lbnQucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIFN1YmNsYXNzZXMgbWF5IGltcGxlbWVudCB0aGlzIG1ldGhvZCB0byByZWxlYXNlIGFueSByZXNvdXJjZXMgLyBkZXJlZ2lzdGVyIGFueSBsaXN0ZW5lcnMgdGhleSBoYXZlXG4gICAgICAgIC8vIGF0dGFjaGVkLiBBbiBleGFtcGxlIG9mIHRoaXMgbWlnaHQgYmUgZGVyZWdpc3RlcmluZyBhIHJlc2l6ZSBldmVudCBmcm9tIHRoZSB3aW5kb3cgb2JqZWN0LlxuICAgICAgICB0aGlzLmZvdW5kYXRpb24uZGVzdHJveSgpO1xuICAgIH07XG4gICAgTURDQ29tcG9uZW50LnByb3RvdHlwZS5saXN0ZW4gPSBmdW5jdGlvbiAoZXZ0VHlwZSwgaGFuZGxlciwgb3B0aW9ucykge1xuICAgICAgICB0aGlzLnJvb3QuYWRkRXZlbnRMaXN0ZW5lcihldnRUeXBlLCBoYW5kbGVyLCBvcHRpb25zKTtcbiAgICB9O1xuICAgIE1EQ0NvbXBvbmVudC5wcm90b3R5cGUudW5saXN0ZW4gPSBmdW5jdGlvbiAoZXZ0VHlwZSwgaGFuZGxlciwgb3B0aW9ucykge1xuICAgICAgICB0aGlzLnJvb3QucmVtb3ZlRXZlbnRMaXN0ZW5lcihldnRUeXBlLCBoYW5kbGVyLCBvcHRpb25zKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEZpcmVzIGEgY3Jvc3MtYnJvd3Nlci1jb21wYXRpYmxlIGN1c3RvbSBldmVudCBmcm9tIHRoZSBjb21wb25lbnQgcm9vdCBvZiB0aGUgZ2l2ZW4gdHlwZSwgd2l0aCB0aGUgZ2l2ZW4gZGF0YS5cbiAgICAgKi9cbiAgICBNRENDb21wb25lbnQucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbiAoZXZ0VHlwZSwgZXZ0RGF0YSwgc2hvdWxkQnViYmxlKSB7XG4gICAgICAgIGlmIChzaG91bGRCdWJibGUgPT09IHZvaWQgMCkgeyBzaG91bGRCdWJibGUgPSBmYWxzZTsgfVxuICAgICAgICB2YXIgZXZ0O1xuICAgICAgICBpZiAodHlwZW9mIEN1c3RvbUV2ZW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBldnQgPSBuZXcgQ3VzdG9tRXZlbnQoZXZ0VHlwZSwge1xuICAgICAgICAgICAgICAgIGJ1YmJsZXM6IHNob3VsZEJ1YmJsZSxcbiAgICAgICAgICAgICAgICBkZXRhaWw6IGV2dERhdGEsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGV2dCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdDdXN0b21FdmVudCcpO1xuICAgICAgICAgICAgZXZ0LmluaXRDdXN0b21FdmVudChldnRUeXBlLCBzaG91bGRCdWJibGUsIGZhbHNlLCBldnREYXRhKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJvb3QuZGlzcGF0Y2hFdmVudChldnQpO1xuICAgIH07XG4gICAgcmV0dXJuIE1EQ0NvbXBvbmVudDtcbn0oKSk7XG5leHBvcnQgeyBNRENDb21wb25lbnQgfTtcbi8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpuby1kZWZhdWx0LWV4cG9ydCBOZWVkZWQgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHkgd2l0aCBNREMgV2ViIHYwLjQ0LjAgYW5kIGVhcmxpZXIuXG5leHBvcnQgZGVmYXVsdCBNRENDb21wb25lbnQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb21wb25lbnQuanMubWFwIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTkgR29vZ2xlIEluYy5cbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuICogVEhFIFNPRlRXQVJFLlxuICovXG4vKipcbiAqIERldGVybWluZSB3aGV0aGVyIHRoZSBjdXJyZW50IGJyb3dzZXIgc3VwcG9ydHMgcGFzc2l2ZSBldmVudCBsaXN0ZW5lcnMsIGFuZFxuICogaWYgc28sIHVzZSB0aGVtLlxuICovXG5leHBvcnQgZnVuY3Rpb24gYXBwbHlQYXNzaXZlKGdsb2JhbE9iaikge1xuICAgIGlmIChnbG9iYWxPYmogPT09IHZvaWQgMCkgeyBnbG9iYWxPYmogPSB3aW5kb3c7IH1cbiAgICByZXR1cm4gc3VwcG9ydHNQYXNzaXZlT3B0aW9uKGdsb2JhbE9iaikgP1xuICAgICAgICB7IHBhc3NpdmU6IHRydWUgfSA6XG4gICAgICAgIGZhbHNlO1xufVxuZnVuY3Rpb24gc3VwcG9ydHNQYXNzaXZlT3B0aW9uKGdsb2JhbE9iaikge1xuICAgIGlmIChnbG9iYWxPYmogPT09IHZvaWQgMCkgeyBnbG9iYWxPYmogPSB3aW5kb3c7IH1cbiAgICAvLyBTZWVcbiAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvRXZlbnRUYXJnZXQvYWRkRXZlbnRMaXN0ZW5lclxuICAgIHZhciBwYXNzaXZlU3VwcG9ydGVkID0gZmFsc2U7XG4gICAgdHJ5IHtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSB7XG4gICAgICAgICAgICAvLyBUaGlzIGZ1bmN0aW9uIHdpbGwgYmUgY2FsbGVkIHdoZW4gdGhlIGJyb3dzZXJcbiAgICAgICAgICAgIC8vIGF0dGVtcHRzIHRvIGFjY2VzcyB0aGUgcGFzc2l2ZSBwcm9wZXJ0eS5cbiAgICAgICAgICAgIGdldCBwYXNzaXZlKCkge1xuICAgICAgICAgICAgICAgIHBhc3NpdmVTdXBwb3J0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGhhbmRsZXIgPSBmdW5jdGlvbiAoKSB7IH07XG4gICAgICAgIGdsb2JhbE9iai5kb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCd0ZXN0JywgaGFuZGxlciwgb3B0aW9ucyk7XG4gICAgICAgIGdsb2JhbE9iai5kb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCd0ZXN0JywgaGFuZGxlciwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgcGFzc2l2ZVN1cHBvcnRlZCA9IGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gcGFzc2l2ZVN1cHBvcnRlZDtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWV2ZW50cy5qcy5tYXAiLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOCBHb29nbGUgSW5jLlxuICpcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbiAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuICogYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4gKiBUSEUgU09GVFdBUkUuXG4gKi9cbi8qKlxuICogQGZpbGVvdmVydmlldyBBIFwicG9ueWZpbGxcIiBpcyBhIHBvbHlmaWxsIHRoYXQgZG9lc24ndCBtb2RpZnkgdGhlIGdsb2JhbCBwcm90b3R5cGUgY2hhaW4uXG4gKiBUaGlzIG1ha2VzIHBvbnlmaWxscyBzYWZlciB0aGFuIHRyYWRpdGlvbmFsIHBvbHlmaWxscywgZXNwZWNpYWxseSBmb3IgbGlicmFyaWVzIGxpa2UgTURDLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY2xvc2VzdChlbGVtZW50LCBzZWxlY3Rvcikge1xuICAgIGlmIChlbGVtZW50LmNsb3Nlc3QpIHtcbiAgICAgICAgcmV0dXJuIGVsZW1lbnQuY2xvc2VzdChzZWxlY3Rvcik7XG4gICAgfVxuICAgIHZhciBlbCA9IGVsZW1lbnQ7XG4gICAgd2hpbGUgKGVsKSB7XG4gICAgICAgIGlmIChtYXRjaGVzKGVsLCBzZWxlY3RvcikpIHtcbiAgICAgICAgICAgIHJldHVybiBlbDtcbiAgICAgICAgfVxuICAgICAgICBlbCA9IGVsLnBhcmVudEVsZW1lbnQ7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuZXhwb3J0IGZ1bmN0aW9uIG1hdGNoZXMoZWxlbWVudCwgc2VsZWN0b3IpIHtcbiAgICB2YXIgbmF0aXZlTWF0Y2hlcyA9IGVsZW1lbnQubWF0Y2hlc1xuICAgICAgICB8fCBlbGVtZW50LndlYmtpdE1hdGNoZXNTZWxlY3RvclxuICAgICAgICB8fCBlbGVtZW50Lm1zTWF0Y2hlc1NlbGVjdG9yO1xuICAgIHJldHVybiBuYXRpdmVNYXRjaGVzLmNhbGwoZWxlbWVudCwgc2VsZWN0b3IpO1xufVxuLyoqXG4gKiBVc2VkIHRvIGNvbXB1dGUgdGhlIGVzdGltYXRlZCBzY3JvbGwgd2lkdGggb2YgZWxlbWVudHMuIFdoZW4gYW4gZWxlbWVudCBpc1xuICogaGlkZGVuIGR1ZSB0byBkaXNwbGF5OiBub25lOyBiZWluZyBhcHBsaWVkIHRvIGEgcGFyZW50IGVsZW1lbnQsIHRoZSB3aWR0aCBpc1xuICogcmV0dXJuZWQgYXMgMC4gSG93ZXZlciwgdGhlIGVsZW1lbnQgd2lsbCBoYXZlIGEgdHJ1ZSB3aWR0aCBvbmNlIG5vIGxvbmdlclxuICogaW5zaWRlIGEgZGlzcGxheTogbm9uZSBjb250ZXh0LiBUaGlzIG1ldGhvZCBjb21wdXRlcyBhbiBlc3RpbWF0ZWQgd2lkdGggd2hlblxuICogdGhlIGVsZW1lbnQgaXMgaGlkZGVuIG9yIHJldHVybnMgdGhlIHRydWUgd2lkdGggd2hlbiB0aGUgZWxlbWVudCBpcyB2aXNibGUuXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnQgdGhlIGVsZW1lbnQgd2hvc2Ugd2lkdGggdG8gZXN0aW1hdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVzdGltYXRlU2Nyb2xsV2lkdGgoZWxlbWVudCkge1xuICAgIC8vIENoZWNrIHRoZSBvZmZzZXRQYXJlbnQuIElmIHRoZSBlbGVtZW50IGluaGVyaXRzIGRpc3BsYXk6IG5vbmUgZnJvbSBhbnlcbiAgICAvLyBwYXJlbnQsIHRoZSBvZmZzZXRQYXJlbnQgcHJvcGVydHkgd2lsbCBiZSBudWxsIChzZWVcbiAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvSFRNTEVsZW1lbnQvb2Zmc2V0UGFyZW50KS5cbiAgICAvLyBUaGlzIGNoZWNrIGVuc3VyZXMgd2Ugb25seSBjbG9uZSB0aGUgbm9kZSB3aGVuIG5lY2Vzc2FyeS5cbiAgICB2YXIgaHRtbEVsID0gZWxlbWVudDtcbiAgICBpZiAoaHRtbEVsLm9mZnNldFBhcmVudCAhPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gaHRtbEVsLnNjcm9sbFdpZHRoO1xuICAgIH1cbiAgICB2YXIgY2xvbmUgPSBodG1sRWwuY2xvbmVOb2RlKHRydWUpO1xuICAgIGNsb25lLnN0eWxlLnNldFByb3BlcnR5KCdwb3NpdGlvbicsICdhYnNvbHV0ZScpO1xuICAgIGNsb25lLnN0eWxlLnNldFByb3BlcnR5KCd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlKC05OTk5cHgsIC05OTk5cHgpJyk7XG4gICAgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmFwcGVuZENoaWxkKGNsb25lKTtcbiAgICB2YXIgc2Nyb2xsV2lkdGggPSBjbG9uZS5zY3JvbGxXaWR0aDtcbiAgICBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQucmVtb3ZlQ2hpbGQoY2xvbmUpO1xuICAgIHJldHVybiBzY3JvbGxXaWR0aDtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBvbnlmaWxsLmpzLm1hcCIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuXG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICpcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4gKiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbiAqIFRIRSBTT0ZUV0FSRS5cbiAqL1xuZXhwb3J0IHZhciBjc3NDbGFzc2VzID0ge1xuICAgIC8vIFJpcHBsZSBpcyBhIHNwZWNpYWwgY2FzZSB3aGVyZSB0aGUgXCJyb290XCIgY29tcG9uZW50IGlzIHJlYWxseSBhIFwibWl4aW5cIiBvZiBzb3J0cyxcbiAgICAvLyBnaXZlbiB0aGF0IGl0J3MgYW4gJ3VwZ3JhZGUnIHRvIGFuIGV4aXN0aW5nIGNvbXBvbmVudC4gVGhhdCBiZWluZyBzYWlkIGl0IGlzIHRoZSByb290XG4gICAgLy8gQ1NTIGNsYXNzIHRoYXQgYWxsIG90aGVyIENTUyBjbGFzc2VzIGRlcml2ZSBmcm9tLlxuICAgIEJHX0ZPQ1VTRUQ6ICdtZGMtcmlwcGxlLXVwZ3JhZGVkLS1iYWNrZ3JvdW5kLWZvY3VzZWQnLFxuICAgIEZHX0FDVElWQVRJT046ICdtZGMtcmlwcGxlLXVwZ3JhZGVkLS1mb3JlZ3JvdW5kLWFjdGl2YXRpb24nLFxuICAgIEZHX0RFQUNUSVZBVElPTjogJ21kYy1yaXBwbGUtdXBncmFkZWQtLWZvcmVncm91bmQtZGVhY3RpdmF0aW9uJyxcbiAgICBST09UOiAnbWRjLXJpcHBsZS11cGdyYWRlZCcsXG4gICAgVU5CT1VOREVEOiAnbWRjLXJpcHBsZS11cGdyYWRlZC0tdW5ib3VuZGVkJyxcbn07XG5leHBvcnQgdmFyIHN0cmluZ3MgPSB7XG4gICAgVkFSX0ZHX1NDQUxFOiAnLS1tZGMtcmlwcGxlLWZnLXNjYWxlJyxcbiAgICBWQVJfRkdfU0laRTogJy0tbWRjLXJpcHBsZS1mZy1zaXplJyxcbiAgICBWQVJfRkdfVFJBTlNMQVRFX0VORDogJy0tbWRjLXJpcHBsZS1mZy10cmFuc2xhdGUtZW5kJyxcbiAgICBWQVJfRkdfVFJBTlNMQVRFX1NUQVJUOiAnLS1tZGMtcmlwcGxlLWZnLXRyYW5zbGF0ZS1zdGFydCcsXG4gICAgVkFSX0xFRlQ6ICctLW1kYy1yaXBwbGUtbGVmdCcsXG4gICAgVkFSX1RPUDogJy0tbWRjLXJpcHBsZS10b3AnLFxufTtcbmV4cG9ydCB2YXIgbnVtYmVycyA9IHtcbiAgICBERUFDVElWQVRJT05fVElNRU9VVF9NUzogMjI1LFxuICAgIEZHX0RFQUNUSVZBVElPTl9NUzogMTUwLFxuICAgIElOSVRJQUxfT1JJR0lOX1NDQUxFOiAwLjYsXG4gICAgUEFERElORzogMTAsXG4gICAgVEFQX0RFTEFZX01TOiAzMDAsIC8vIERlbGF5IGJldHdlZW4gdG91Y2ggYW5kIHNpbXVsYXRlZCBtb3VzZSBldmVudHMgb24gdG91Y2ggZGV2aWNlc1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbnN0YW50cy5qcy5tYXAiLCIvKipcbiAqIFN0b3JlcyByZXN1bHQgZnJvbSBzdXBwb3J0c0Nzc1ZhcmlhYmxlcyB0byBhdm9pZCByZWR1bmRhbnQgcHJvY2Vzc2luZyB0b1xuICogZGV0ZWN0IENTUyBjdXN0b20gdmFyaWFibGUgc3VwcG9ydC5cbiAqL1xudmFyIHN1cHBvcnRzQ3NzVmFyaWFibGVzXztcbmV4cG9ydCBmdW5jdGlvbiBzdXBwb3J0c0Nzc1ZhcmlhYmxlcyh3aW5kb3dPYmosIGZvcmNlUmVmcmVzaCkge1xuICAgIGlmIChmb3JjZVJlZnJlc2ggPT09IHZvaWQgMCkgeyBmb3JjZVJlZnJlc2ggPSBmYWxzZTsgfVxuICAgIHZhciBDU1MgPSB3aW5kb3dPYmouQ1NTO1xuICAgIHZhciBzdXBwb3J0c0Nzc1ZhcnMgPSBzdXBwb3J0c0Nzc1ZhcmlhYmxlc187XG4gICAgaWYgKHR5cGVvZiBzdXBwb3J0c0Nzc1ZhcmlhYmxlc18gPT09ICdib29sZWFuJyAmJiAhZm9yY2VSZWZyZXNoKSB7XG4gICAgICAgIHJldHVybiBzdXBwb3J0c0Nzc1ZhcmlhYmxlc187XG4gICAgfVxuICAgIHZhciBzdXBwb3J0c0Z1bmN0aW9uUHJlc2VudCA9IENTUyAmJiB0eXBlb2YgQ1NTLnN1cHBvcnRzID09PSAnZnVuY3Rpb24nO1xuICAgIGlmICghc3VwcG9ydHNGdW5jdGlvblByZXNlbnQpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB2YXIgZXhwbGljaXRseVN1cHBvcnRzQ3NzVmFycyA9IENTUy5zdXBwb3J0cygnLS1jc3MtdmFycycsICd5ZXMnKTtcbiAgICAvLyBTZWU6IGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0xNTQ2NjlcbiAgICAvLyBTZWU6IFJFQURNRSBzZWN0aW9uIG9uIFNhZmFyaVxuICAgIHZhciB3ZUFyZUZlYXR1cmVEZXRlY3RpbmdTYWZhcmkxMHBsdXMgPSAoQ1NTLnN1cHBvcnRzKCcoLS1jc3MtdmFyczogeWVzKScpICYmXG4gICAgICAgIENTUy5zdXBwb3J0cygnY29sb3InLCAnIzAwMDAwMDAwJykpO1xuICAgIHN1cHBvcnRzQ3NzVmFycyA9XG4gICAgICAgIGV4cGxpY2l0bHlTdXBwb3J0c0Nzc1ZhcnMgfHwgd2VBcmVGZWF0dXJlRGV0ZWN0aW5nU2FmYXJpMTBwbHVzO1xuICAgIGlmICghZm9yY2VSZWZyZXNoKSB7XG4gICAgICAgIHN1cHBvcnRzQ3NzVmFyaWFibGVzXyA9IHN1cHBvcnRzQ3NzVmFycztcbiAgICB9XG4gICAgcmV0dXJuIHN1cHBvcnRzQ3NzVmFycztcbn1cbmV4cG9ydCBmdW5jdGlvbiBnZXROb3JtYWxpemVkRXZlbnRDb29yZHMoZXZ0LCBwYWdlT2Zmc2V0LCBjbGllbnRSZWN0KSB7XG4gICAgaWYgKCFldnQpIHtcbiAgICAgICAgcmV0dXJuIHsgeDogMCwgeTogMCB9O1xuICAgIH1cbiAgICB2YXIgeCA9IHBhZ2VPZmZzZXQueCwgeSA9IHBhZ2VPZmZzZXQueTtcbiAgICB2YXIgZG9jdW1lbnRYID0geCArIGNsaWVudFJlY3QubGVmdDtcbiAgICB2YXIgZG9jdW1lbnRZID0geSArIGNsaWVudFJlY3QudG9wO1xuICAgIHZhciBub3JtYWxpemVkWDtcbiAgICB2YXIgbm9ybWFsaXplZFk7XG4gICAgLy8gRGV0ZXJtaW5lIHRvdWNoIHBvaW50IHJlbGF0aXZlIHRvIHRoZSByaXBwbGUgY29udGFpbmVyLlxuICAgIGlmIChldnQudHlwZSA9PT0gJ3RvdWNoc3RhcnQnKSB7XG4gICAgICAgIHZhciB0b3VjaEV2ZW50ID0gZXZ0O1xuICAgICAgICBub3JtYWxpemVkWCA9IHRvdWNoRXZlbnQuY2hhbmdlZFRvdWNoZXNbMF0ucGFnZVggLSBkb2N1bWVudFg7XG4gICAgICAgIG5vcm1hbGl6ZWRZID0gdG91Y2hFdmVudC5jaGFuZ2VkVG91Y2hlc1swXS5wYWdlWSAtIGRvY3VtZW50WTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHZhciBtb3VzZUV2ZW50ID0gZXZ0O1xuICAgICAgICBub3JtYWxpemVkWCA9IG1vdXNlRXZlbnQucGFnZVggLSBkb2N1bWVudFg7XG4gICAgICAgIG5vcm1hbGl6ZWRZID0gbW91c2VFdmVudC5wYWdlWSAtIGRvY3VtZW50WTtcbiAgICB9XG4gICAgcmV0dXJuIHsgeDogbm9ybWFsaXplZFgsIHk6IG5vcm1hbGl6ZWRZIH07XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD11dGlsLmpzLm1hcCIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuXG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICpcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4gKiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbiAqIFRIRSBTT0ZUV0FSRS5cbiAqL1xuaW1wb3J0IHsgX19hc3NpZ24sIF9fZXh0ZW5kcywgX192YWx1ZXMgfSBmcm9tIFwidHNsaWJcIjtcbmltcG9ydCB7IE1EQ0ZvdW5kYXRpb24gfSBmcm9tICdAbWF0ZXJpYWwvYmFzZS9mb3VuZGF0aW9uJztcbmltcG9ydCB7IGNzc0NsYXNzZXMsIG51bWJlcnMsIHN0cmluZ3MgfSBmcm9tICcuL2NvbnN0YW50cyc7XG5pbXBvcnQgeyBnZXROb3JtYWxpemVkRXZlbnRDb29yZHMgfSBmcm9tICcuL3V0aWwnO1xuLy8gQWN0aXZhdGlvbiBldmVudHMgcmVnaXN0ZXJlZCBvbiB0aGUgcm9vdCBlbGVtZW50IG9mIGVhY2ggaW5zdGFuY2UgZm9yIGFjdGl2YXRpb25cbnZhciBBQ1RJVkFUSU9OX0VWRU5UX1RZUEVTID0gW1xuICAgICd0b3VjaHN0YXJ0JywgJ3BvaW50ZXJkb3duJywgJ21vdXNlZG93bicsICdrZXlkb3duJyxcbl07XG4vLyBEZWFjdGl2YXRpb24gZXZlbnRzIHJlZ2lzdGVyZWQgb24gZG9jdW1lbnRFbGVtZW50IHdoZW4gYSBwb2ludGVyLXJlbGF0ZWQgZG93biBldmVudCBvY2N1cnNcbnZhciBQT0lOVEVSX0RFQUNUSVZBVElPTl9FVkVOVF9UWVBFUyA9IFtcbiAgICAndG91Y2hlbmQnLCAncG9pbnRlcnVwJywgJ21vdXNldXAnLCAnY29udGV4dG1lbnUnLFxuXTtcbi8vIHNpbXVsdGFuZW91cyBuZXN0ZWQgYWN0aXZhdGlvbnNcbnZhciBhY3RpdmF0ZWRUYXJnZXRzID0gW107XG52YXIgTURDUmlwcGxlRm91bmRhdGlvbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTURDUmlwcGxlRm91bmRhdGlvbiwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBNRENSaXBwbGVGb3VuZGF0aW9uKGFkYXB0ZXIpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgX19hc3NpZ24oX19hc3NpZ24oe30sIE1EQ1JpcHBsZUZvdW5kYXRpb24uZGVmYXVsdEFkYXB0ZXIpLCBhZGFwdGVyKSkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuYWN0aXZhdGlvbkFuaW1hdGlvbkhhc0VuZGVkID0gZmFsc2U7XG4gICAgICAgIF90aGlzLmFjdGl2YXRpb25UaW1lciA9IDA7XG4gICAgICAgIF90aGlzLmZnRGVhY3RpdmF0aW9uUmVtb3ZhbFRpbWVyID0gMDtcbiAgICAgICAgX3RoaXMuZmdTY2FsZSA9ICcwJztcbiAgICAgICAgX3RoaXMuZnJhbWUgPSB7IHdpZHRoOiAwLCBoZWlnaHQ6IDAgfTtcbiAgICAgICAgX3RoaXMuaW5pdGlhbFNpemUgPSAwO1xuICAgICAgICBfdGhpcy5sYXlvdXRGcmFtZSA9IDA7XG4gICAgICAgIF90aGlzLm1heFJhZGl1cyA9IDA7XG4gICAgICAgIF90aGlzLnVuYm91bmRlZENvb3JkcyA9IHsgbGVmdDogMCwgdG9wOiAwIH07XG4gICAgICAgIF90aGlzLmFjdGl2YXRpb25TdGF0ZSA9IF90aGlzLmRlZmF1bHRBY3RpdmF0aW9uU3RhdGUoKTtcbiAgICAgICAgX3RoaXMuYWN0aXZhdGlvblRpbWVyQ2FsbGJhY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpcy5hY3RpdmF0aW9uQW5pbWF0aW9uSGFzRW5kZWQgPSB0cnVlO1xuICAgICAgICAgICAgX3RoaXMucnVuRGVhY3RpdmF0aW9uVVhMb2dpY0lmUmVhZHkoKTtcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuYWN0aXZhdGVIYW5kbGVyID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIF90aGlzLmFjdGl2YXRlSW1wbChlKTtcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuZGVhY3RpdmF0ZUhhbmRsZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpcy5kZWFjdGl2YXRlSW1wbCgpO1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5mb2N1c0hhbmRsZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpcy5oYW5kbGVGb2N1cygpO1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5ibHVySGFuZGxlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzLmhhbmRsZUJsdXIoKTtcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMucmVzaXplSGFuZGxlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzLmxheW91dCgpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNRENSaXBwbGVGb3VuZGF0aW9uLCBcImNzc0NsYXNzZXNcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBjc3NDbGFzc2VzO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1EQ1JpcHBsZUZvdW5kYXRpb24sIFwic3RyaW5nc1wiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHN0cmluZ3M7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTURDUmlwcGxlRm91bmRhdGlvbiwgXCJudW1iZXJzXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVtYmVycztcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNRENSaXBwbGVGb3VuZGF0aW9uLCBcImRlZmF1bHRBZGFwdGVyXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGFkZENsYXNzOiBmdW5jdGlvbiAoKSB7IHJldHVybiB1bmRlZmluZWQ7IH0sXG4gICAgICAgICAgICAgICAgYnJvd3NlclN1cHBvcnRzQ3NzVmFyczogZnVuY3Rpb24gKCkgeyByZXR1cm4gdHJ1ZTsgfSxcbiAgICAgICAgICAgICAgICBjb21wdXRlQm91bmRpbmdSZWN0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoeyB0b3A6IDAsIHJpZ2h0OiAwLCBib3R0b206IDAsIGxlZnQ6IDAsIHdpZHRoOiAwLCBoZWlnaHQ6IDAgfSk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBjb250YWluc0V2ZW50VGFyZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0cnVlOyB9LFxuICAgICAgICAgICAgICAgIGRlcmVnaXN0ZXJEb2N1bWVudEludGVyYWN0aW9uSGFuZGxlcjogZnVuY3Rpb24gKCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9LFxuICAgICAgICAgICAgICAgIGRlcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXI6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSxcbiAgICAgICAgICAgICAgICBkZXJlZ2lzdGVyUmVzaXplSGFuZGxlcjogZnVuY3Rpb24gKCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9LFxuICAgICAgICAgICAgICAgIGdldFdpbmRvd1BhZ2VPZmZzZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuICh7IHg6IDAsIHk6IDAgfSk7IH0sXG4gICAgICAgICAgICAgICAgaXNTdXJmYWNlQWN0aXZlOiBmdW5jdGlvbiAoKSB7IHJldHVybiB0cnVlOyB9LFxuICAgICAgICAgICAgICAgIGlzU3VyZmFjZURpc2FibGVkOiBmdW5jdGlvbiAoKSB7IHJldHVybiB0cnVlOyB9LFxuICAgICAgICAgICAgICAgIGlzVW5ib3VuZGVkOiBmdW5jdGlvbiAoKSB7IHJldHVybiB0cnVlOyB9LFxuICAgICAgICAgICAgICAgIHJlZ2lzdGVyRG9jdW1lbnRJbnRlcmFjdGlvbkhhbmRsZXI6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSxcbiAgICAgICAgICAgICAgICByZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcjogZnVuY3Rpb24gKCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9LFxuICAgICAgICAgICAgICAgIHJlZ2lzdGVyUmVzaXplSGFuZGxlcjogZnVuY3Rpb24gKCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9LFxuICAgICAgICAgICAgICAgIHJlbW92ZUNsYXNzOiBmdW5jdGlvbiAoKSB7IHJldHVybiB1bmRlZmluZWQ7IH0sXG4gICAgICAgICAgICAgICAgdXBkYXRlQ3NzVmFyaWFibGU6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBNRENSaXBwbGVGb3VuZGF0aW9uLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgc3VwcG9ydHNQcmVzc1JpcHBsZSA9IHRoaXMuc3VwcG9ydHNQcmVzc1JpcHBsZSgpO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyUm9vdEhhbmRsZXJzKHN1cHBvcnRzUHJlc3NSaXBwbGUpO1xuICAgICAgICBpZiAoc3VwcG9ydHNQcmVzc1JpcHBsZSkge1xuICAgICAgICAgICAgdmFyIF9hID0gTURDUmlwcGxlRm91bmRhdGlvbi5jc3NDbGFzc2VzLCBST09UXzEgPSBfYS5ST09ULCBVTkJPVU5ERURfMSA9IF9hLlVOQk9VTkRFRDtcbiAgICAgICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuYWRhcHRlci5hZGRDbGFzcyhST09UXzEpO1xuICAgICAgICAgICAgICAgIGlmIChfdGhpcy5hZGFwdGVyLmlzVW5ib3VuZGVkKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuYWRhcHRlci5hZGRDbGFzcyhVTkJPVU5ERURfMSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIFVuYm91bmRlZCByaXBwbGVzIG5lZWQgbGF5b3V0IGxvZ2ljIGFwcGxpZWQgaW1tZWRpYXRlbHkgdG8gc2V0IGNvb3JkaW5hdGVzIGZvciBib3RoIHNoYWRlIGFuZCByaXBwbGVcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMubGF5b3V0SW50ZXJuYWwoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgTURDUmlwcGxlRm91bmRhdGlvbi5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKHRoaXMuc3VwcG9ydHNQcmVzc1JpcHBsZSgpKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5hY3RpdmF0aW9uVGltZXIpIHtcbiAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5hY3RpdmF0aW9uVGltZXIpO1xuICAgICAgICAgICAgICAgIHRoaXMuYWN0aXZhdGlvblRpbWVyID0gMDtcbiAgICAgICAgICAgICAgICB0aGlzLmFkYXB0ZXIucmVtb3ZlQ2xhc3MoTURDUmlwcGxlRm91bmRhdGlvbi5jc3NDbGFzc2VzLkZHX0FDVElWQVRJT04pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuZmdEZWFjdGl2YXRpb25SZW1vdmFsVGltZXIpIHtcbiAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5mZ0RlYWN0aXZhdGlvblJlbW92YWxUaW1lcik7XG4gICAgICAgICAgICAgICAgdGhpcy5mZ0RlYWN0aXZhdGlvblJlbW92YWxUaW1lciA9IDA7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGFwdGVyLnJlbW92ZUNsYXNzKE1EQ1JpcHBsZUZvdW5kYXRpb24uY3NzQ2xhc3Nlcy5GR19ERUFDVElWQVRJT04pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIF9hID0gTURDUmlwcGxlRm91bmRhdGlvbi5jc3NDbGFzc2VzLCBST09UXzIgPSBfYS5ST09ULCBVTkJPVU5ERURfMiA9IF9hLlVOQk9VTkRFRDtcbiAgICAgICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuYWRhcHRlci5yZW1vdmVDbGFzcyhST09UXzIpO1xuICAgICAgICAgICAgICAgIF90aGlzLmFkYXB0ZXIucmVtb3ZlQ2xhc3MoVU5CT1VOREVEXzIpO1xuICAgICAgICAgICAgICAgIF90aGlzLnJlbW92ZUNzc1ZhcnMoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZGVyZWdpc3RlclJvb3RIYW5kbGVycygpO1xuICAgICAgICB0aGlzLmRlcmVnaXN0ZXJEZWFjdGl2YXRpb25IYW5kbGVycygpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIGV2dCBPcHRpb25hbCBldmVudCBjb250YWluaW5nIHBvc2l0aW9uIGluZm9ybWF0aW9uLlxuICAgICAqL1xuICAgIE1EQ1JpcHBsZUZvdW5kYXRpb24ucHJvdG90eXBlLmFjdGl2YXRlID0gZnVuY3Rpb24gKGV2dCkge1xuICAgICAgICB0aGlzLmFjdGl2YXRlSW1wbChldnQpO1xuICAgIH07XG4gICAgTURDUmlwcGxlRm91bmRhdGlvbi5wcm90b3R5cGUuZGVhY3RpdmF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5kZWFjdGl2YXRlSW1wbCgpO1xuICAgIH07XG4gICAgTURDUmlwcGxlRm91bmRhdGlvbi5wcm90b3R5cGUubGF5b3V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAodGhpcy5sYXlvdXRGcmFtZSkge1xuICAgICAgICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUodGhpcy5sYXlvdXRGcmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5sYXlvdXRGcmFtZSA9IHJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpcy5sYXlvdXRJbnRlcm5hbCgpO1xuICAgICAgICAgICAgX3RoaXMubGF5b3V0RnJhbWUgPSAwO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIE1EQ1JpcHBsZUZvdW5kYXRpb24ucHJvdG90eXBlLnNldFVuYm91bmRlZCA9IGZ1bmN0aW9uICh1bmJvdW5kZWQpIHtcbiAgICAgICAgdmFyIFVOQk9VTkRFRCA9IE1EQ1JpcHBsZUZvdW5kYXRpb24uY3NzQ2xhc3Nlcy5VTkJPVU5ERUQ7XG4gICAgICAgIGlmICh1bmJvdW5kZWQpIHtcbiAgICAgICAgICAgIHRoaXMuYWRhcHRlci5hZGRDbGFzcyhVTkJPVU5ERUQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5hZGFwdGVyLnJlbW92ZUNsYXNzKFVOQk9VTkRFRCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE1EQ1JpcHBsZUZvdW5kYXRpb24ucHJvdG90eXBlLmhhbmRsZUZvY3VzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuYWRhcHRlci5hZGRDbGFzcyhNRENSaXBwbGVGb3VuZGF0aW9uLmNzc0NsYXNzZXMuQkdfRk9DVVNFRCk7IH0pO1xuICAgIH07XG4gICAgTURDUmlwcGxlRm91bmRhdGlvbi5wcm90b3R5cGUuaGFuZGxlQmx1ciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLmFkYXB0ZXIucmVtb3ZlQ2xhc3MoTURDUmlwcGxlRm91bmRhdGlvbi5jc3NDbGFzc2VzLkJHX0ZPQ1VTRUQpOyB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFdlIGNvbXB1dGUgdGhpcyBwcm9wZXJ0eSBzbyB0aGF0IHdlIGFyZSBub3QgcXVlcnlpbmcgaW5mb3JtYXRpb24gYWJvdXQgdGhlIGNsaWVudFxuICAgICAqIHVudGlsIHRoZSBwb2ludCBpbiB0aW1lIHdoZXJlIHRoZSBmb3VuZGF0aW9uIHJlcXVlc3RzIGl0LiBUaGlzIHByZXZlbnRzIHNjZW5hcmlvcyB3aGVyZVxuICAgICAqIGNsaWVudC1zaWRlIGZlYXR1cmUtZGV0ZWN0aW9uIG1heSBoYXBwZW4gdG9vIGVhcmx5LCBzdWNoIGFzIHdoZW4gY29tcG9uZW50cyBhcmUgcmVuZGVyZWQgb24gdGhlIHNlcnZlclxuICAgICAqIGFuZCB0aGVuIGluaXRpYWxpemVkIGF0IG1vdW50IHRpbWUgb24gdGhlIGNsaWVudC5cbiAgICAgKi9cbiAgICBNRENSaXBwbGVGb3VuZGF0aW9uLnByb3RvdHlwZS5zdXBwb3J0c1ByZXNzUmlwcGxlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hZGFwdGVyLmJyb3dzZXJTdXBwb3J0c0Nzc1ZhcnMoKTtcbiAgICB9O1xuICAgIE1EQ1JpcHBsZUZvdW5kYXRpb24ucHJvdG90eXBlLmRlZmF1bHRBY3RpdmF0aW9uU3RhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBhY3RpdmF0aW9uRXZlbnQ6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGhhc0RlYWN0aXZhdGlvblVYUnVuOiBmYWxzZSxcbiAgICAgICAgICAgIGlzQWN0aXZhdGVkOiBmYWxzZSxcbiAgICAgICAgICAgIGlzUHJvZ3JhbW1hdGljOiBmYWxzZSxcbiAgICAgICAgICAgIHdhc0FjdGl2YXRlZEJ5UG9pbnRlcjogZmFsc2UsXG4gICAgICAgICAgICB3YXNFbGVtZW50TWFkZUFjdGl2ZTogZmFsc2UsXG4gICAgICAgIH07XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBzdXBwb3J0c1ByZXNzUmlwcGxlIFBhc3NlZCBmcm9tIGluaXQgdG8gc2F2ZSBhIHJlZHVuZGFudCBmdW5jdGlvbiBjYWxsXG4gICAgICovXG4gICAgTURDUmlwcGxlRm91bmRhdGlvbi5wcm90b3R5cGUucmVnaXN0ZXJSb290SGFuZGxlcnMgPSBmdW5jdGlvbiAoc3VwcG9ydHNQcmVzc1JpcHBsZSkge1xuICAgICAgICB2YXIgZV8xLCBfYTtcbiAgICAgICAgaWYgKHN1cHBvcnRzUHJlc3NSaXBwbGUpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgQUNUSVZBVElPTl9FVkVOVF9UWVBFU18xID0gX192YWx1ZXMoQUNUSVZBVElPTl9FVkVOVF9UWVBFUyksIEFDVElWQVRJT05fRVZFTlRfVFlQRVNfMV8xID0gQUNUSVZBVElPTl9FVkVOVF9UWVBFU18xLm5leHQoKTsgIUFDVElWQVRJT05fRVZFTlRfVFlQRVNfMV8xLmRvbmU7IEFDVElWQVRJT05fRVZFTlRfVFlQRVNfMV8xID0gQUNUSVZBVElPTl9FVkVOVF9UWVBFU18xLm5leHQoKSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZXZ0VHlwZSA9IEFDVElWQVRJT05fRVZFTlRfVFlQRVNfMV8xLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFkYXB0ZXIucmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXIoZXZ0VHlwZSwgdGhpcy5hY3RpdmF0ZUhhbmRsZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlXzFfMSkgeyBlXzEgPSB7IGVycm9yOiBlXzFfMSB9OyB9XG4gICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoQUNUSVZBVElPTl9FVkVOVF9UWVBFU18xXzEgJiYgIUFDVElWQVRJT05fRVZFTlRfVFlQRVNfMV8xLmRvbmUgJiYgKF9hID0gQUNUSVZBVElPTl9FVkVOVF9UWVBFU18xLnJldHVybikpIF9hLmNhbGwoQUNUSVZBVElPTl9FVkVOVF9UWVBFU18xKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZmluYWxseSB7IGlmIChlXzEpIHRocm93IGVfMS5lcnJvcjsgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuYWRhcHRlci5pc1VuYm91bmRlZCgpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGFwdGVyLnJlZ2lzdGVyUmVzaXplSGFuZGxlcih0aGlzLnJlc2l6ZUhhbmRsZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuYWRhcHRlci5yZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcignZm9jdXMnLCB0aGlzLmZvY3VzSGFuZGxlcik7XG4gICAgICAgIHRoaXMuYWRhcHRlci5yZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcignYmx1cicsIHRoaXMuYmx1ckhhbmRsZXIpO1xuICAgIH07XG4gICAgTURDUmlwcGxlRm91bmRhdGlvbi5wcm90b3R5cGUucmVnaXN0ZXJEZWFjdGl2YXRpb25IYW5kbGVycyA9IGZ1bmN0aW9uIChldnQpIHtcbiAgICAgICAgdmFyIGVfMiwgX2E7XG4gICAgICAgIGlmIChldnQudHlwZSA9PT0gJ2tleWRvd24nKSB7XG4gICAgICAgICAgICB0aGlzLmFkYXB0ZXIucmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXIoJ2tleXVwJywgdGhpcy5kZWFjdGl2YXRlSGFuZGxlcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIFBPSU5URVJfREVBQ1RJVkFUSU9OX0VWRU5UX1RZUEVTXzEgPSBfX3ZhbHVlcyhQT0lOVEVSX0RFQUNUSVZBVElPTl9FVkVOVF9UWVBFUyksIFBPSU5URVJfREVBQ1RJVkFUSU9OX0VWRU5UX1RZUEVTXzFfMSA9IFBPSU5URVJfREVBQ1RJVkFUSU9OX0VWRU5UX1RZUEVTXzEubmV4dCgpOyAhUE9JTlRFUl9ERUFDVElWQVRJT05fRVZFTlRfVFlQRVNfMV8xLmRvbmU7IFBPSU5URVJfREVBQ1RJVkFUSU9OX0VWRU5UX1RZUEVTXzFfMSA9IFBPSU5URVJfREVBQ1RJVkFUSU9OX0VWRU5UX1RZUEVTXzEubmV4dCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBldnRUeXBlID0gUE9JTlRFUl9ERUFDVElWQVRJT05fRVZFTlRfVFlQRVNfMV8xLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFkYXB0ZXIucmVnaXN0ZXJEb2N1bWVudEludGVyYWN0aW9uSGFuZGxlcihldnRUeXBlLCB0aGlzLmRlYWN0aXZhdGVIYW5kbGVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZV8yXzEpIHsgZV8yID0geyBlcnJvcjogZV8yXzEgfTsgfVxuICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKFBPSU5URVJfREVBQ1RJVkFUSU9OX0VWRU5UX1RZUEVTXzFfMSAmJiAhUE9JTlRFUl9ERUFDVElWQVRJT05fRVZFTlRfVFlQRVNfMV8xLmRvbmUgJiYgKF9hID0gUE9JTlRFUl9ERUFDVElWQVRJT05fRVZFTlRfVFlQRVNfMS5yZXR1cm4pKSBfYS5jYWxsKFBPSU5URVJfREVBQ1RJVkFUSU9OX0VWRU5UX1RZUEVTXzEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmaW5hbGx5IHsgaWYgKGVfMikgdGhyb3cgZV8yLmVycm9yOyB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE1EQ1JpcHBsZUZvdW5kYXRpb24ucHJvdG90eXBlLmRlcmVnaXN0ZXJSb290SGFuZGxlcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBlXzMsIF9hO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZm9yICh2YXIgQUNUSVZBVElPTl9FVkVOVF9UWVBFU18yID0gX192YWx1ZXMoQUNUSVZBVElPTl9FVkVOVF9UWVBFUyksIEFDVElWQVRJT05fRVZFTlRfVFlQRVNfMl8xID0gQUNUSVZBVElPTl9FVkVOVF9UWVBFU18yLm5leHQoKTsgIUFDVElWQVRJT05fRVZFTlRfVFlQRVNfMl8xLmRvbmU7IEFDVElWQVRJT05fRVZFTlRfVFlQRVNfMl8xID0gQUNUSVZBVElPTl9FVkVOVF9UWVBFU18yLm5leHQoKSkge1xuICAgICAgICAgICAgICAgIHZhciBldnRUeXBlID0gQUNUSVZBVElPTl9FVkVOVF9UWVBFU18yXzEudmFsdWU7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGFwdGVyLmRlcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXIoZXZ0VHlwZSwgdGhpcy5hY3RpdmF0ZUhhbmRsZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlXzNfMSkgeyBlXzMgPSB7IGVycm9yOiBlXzNfMSB9OyB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpZiAoQUNUSVZBVElPTl9FVkVOVF9UWVBFU18yXzEgJiYgIUFDVElWQVRJT05fRVZFTlRfVFlQRVNfMl8xLmRvbmUgJiYgKF9hID0gQUNUSVZBVElPTl9FVkVOVF9UWVBFU18yLnJldHVybikpIF9hLmNhbGwoQUNUSVZBVElPTl9FVkVOVF9UWVBFU18yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZV8zKSB0aHJvdyBlXzMuZXJyb3I7IH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFkYXB0ZXIuZGVyZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcignZm9jdXMnLCB0aGlzLmZvY3VzSGFuZGxlcik7XG4gICAgICAgIHRoaXMuYWRhcHRlci5kZXJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyKCdibHVyJywgdGhpcy5ibHVySGFuZGxlcik7XG4gICAgICAgIGlmICh0aGlzLmFkYXB0ZXIuaXNVbmJvdW5kZWQoKSkge1xuICAgICAgICAgICAgdGhpcy5hZGFwdGVyLmRlcmVnaXN0ZXJSZXNpemVIYW5kbGVyKHRoaXMucmVzaXplSGFuZGxlcik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE1EQ1JpcHBsZUZvdW5kYXRpb24ucHJvdG90eXBlLmRlcmVnaXN0ZXJEZWFjdGl2YXRpb25IYW5kbGVycyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGVfNCwgX2E7XG4gICAgICAgIHRoaXMuYWRhcHRlci5kZXJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyKCdrZXl1cCcsIHRoaXMuZGVhY3RpdmF0ZUhhbmRsZXIpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZm9yICh2YXIgUE9JTlRFUl9ERUFDVElWQVRJT05fRVZFTlRfVFlQRVNfMiA9IF9fdmFsdWVzKFBPSU5URVJfREVBQ1RJVkFUSU9OX0VWRU5UX1RZUEVTKSwgUE9JTlRFUl9ERUFDVElWQVRJT05fRVZFTlRfVFlQRVNfMl8xID0gUE9JTlRFUl9ERUFDVElWQVRJT05fRVZFTlRfVFlQRVNfMi5uZXh0KCk7ICFQT0lOVEVSX0RFQUNUSVZBVElPTl9FVkVOVF9UWVBFU18yXzEuZG9uZTsgUE9JTlRFUl9ERUFDVElWQVRJT05fRVZFTlRfVFlQRVNfMl8xID0gUE9JTlRFUl9ERUFDVElWQVRJT05fRVZFTlRfVFlQRVNfMi5uZXh0KCkpIHtcbiAgICAgICAgICAgICAgICB2YXIgZXZ0VHlwZSA9IFBPSU5URVJfREVBQ1RJVkFUSU9OX0VWRU5UX1RZUEVTXzJfMS52YWx1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLmFkYXB0ZXIuZGVyZWdpc3RlckRvY3VtZW50SW50ZXJhY3Rpb25IYW5kbGVyKGV2dFR5cGUsIHRoaXMuZGVhY3RpdmF0ZUhhbmRsZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlXzRfMSkgeyBlXzQgPSB7IGVycm9yOiBlXzRfMSB9OyB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpZiAoUE9JTlRFUl9ERUFDVElWQVRJT05fRVZFTlRfVFlQRVNfMl8xICYmICFQT0lOVEVSX0RFQUNUSVZBVElPTl9FVkVOVF9UWVBFU18yXzEuZG9uZSAmJiAoX2EgPSBQT0lOVEVSX0RFQUNUSVZBVElPTl9FVkVOVF9UWVBFU18yLnJldHVybikpIF9hLmNhbGwoUE9JTlRFUl9ERUFDVElWQVRJT05fRVZFTlRfVFlQRVNfMik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaW5hbGx5IHsgaWYgKGVfNCkgdGhyb3cgZV80LmVycm9yOyB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE1EQ1JpcHBsZUZvdW5kYXRpb24ucHJvdG90eXBlLnJlbW92ZUNzc1ZhcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciByaXBwbGVTdHJpbmdzID0gTURDUmlwcGxlRm91bmRhdGlvbi5zdHJpbmdzO1xuICAgICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHJpcHBsZVN0cmluZ3MpO1xuICAgICAgICBrZXlzLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgaWYgKGtleS5pbmRleE9mKCdWQVJfJykgPT09IDApIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5hZGFwdGVyLnVwZGF0ZUNzc1ZhcmlhYmxlKHJpcHBsZVN0cmluZ3Nba2V5XSwgbnVsbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgTURDUmlwcGxlRm91bmRhdGlvbi5wcm90b3R5cGUuYWN0aXZhdGVJbXBsID0gZnVuY3Rpb24gKGV2dCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAodGhpcy5hZGFwdGVyLmlzU3VyZmFjZURpc2FibGVkKCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYWN0aXZhdGlvblN0YXRlID0gdGhpcy5hY3RpdmF0aW9uU3RhdGU7XG4gICAgICAgIGlmIChhY3RpdmF0aW9uU3RhdGUuaXNBY3RpdmF0ZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBBdm9pZCByZWFjdGluZyB0byBmb2xsb3ctb24gZXZlbnRzIGZpcmVkIGJ5IHRvdWNoIGRldmljZSBhZnRlciBhbiBhbHJlYWR5LXByb2Nlc3NlZCB1c2VyIGludGVyYWN0aW9uXG4gICAgICAgIHZhciBwcmV2aW91c0FjdGl2YXRpb25FdmVudCA9IHRoaXMucHJldmlvdXNBY3RpdmF0aW9uRXZlbnQ7XG4gICAgICAgIHZhciBpc1NhbWVJbnRlcmFjdGlvbiA9IHByZXZpb3VzQWN0aXZhdGlvbkV2ZW50ICYmIGV2dCAhPT0gdW5kZWZpbmVkICYmIHByZXZpb3VzQWN0aXZhdGlvbkV2ZW50LnR5cGUgIT09IGV2dC50eXBlO1xuICAgICAgICBpZiAoaXNTYW1lSW50ZXJhY3Rpb24pIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBhY3RpdmF0aW9uU3RhdGUuaXNBY3RpdmF0ZWQgPSB0cnVlO1xuICAgICAgICBhY3RpdmF0aW9uU3RhdGUuaXNQcm9ncmFtbWF0aWMgPSBldnQgPT09IHVuZGVmaW5lZDtcbiAgICAgICAgYWN0aXZhdGlvblN0YXRlLmFjdGl2YXRpb25FdmVudCA9IGV2dDtcbiAgICAgICAgYWN0aXZhdGlvblN0YXRlLndhc0FjdGl2YXRlZEJ5UG9pbnRlciA9IGFjdGl2YXRpb25TdGF0ZS5pc1Byb2dyYW1tYXRpYyA/IGZhbHNlIDogZXZ0ICE9PSB1bmRlZmluZWQgJiYgKGV2dC50eXBlID09PSAnbW91c2Vkb3duJyB8fCBldnQudHlwZSA9PT0gJ3RvdWNoc3RhcnQnIHx8IGV2dC50eXBlID09PSAncG9pbnRlcmRvd24nKTtcbiAgICAgICAgdmFyIGhhc0FjdGl2YXRlZENoaWxkID0gZXZ0ICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIGFjdGl2YXRlZFRhcmdldHMubGVuZ3RoID4gMCAmJlxuICAgICAgICAgICAgYWN0aXZhdGVkVGFyZ2V0cy5zb21lKGZ1bmN0aW9uICh0YXJnZXQpIHsgcmV0dXJuIF90aGlzLmFkYXB0ZXIuY29udGFpbnNFdmVudFRhcmdldCh0YXJnZXQpOyB9KTtcbiAgICAgICAgaWYgKGhhc0FjdGl2YXRlZENoaWxkKSB7XG4gICAgICAgICAgICAvLyBJbW1lZGlhdGVseSByZXNldCBhY3RpdmF0aW9uIHN0YXRlLCB3aGlsZSBwcmVzZXJ2aW5nIGxvZ2ljIHRoYXQgcHJldmVudHMgdG91Y2ggZm9sbG93LW9uIGV2ZW50c1xuICAgICAgICAgICAgdGhpcy5yZXNldEFjdGl2YXRpb25TdGF0ZSgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChldnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgYWN0aXZhdGVkVGFyZ2V0cy5wdXNoKGV2dC50YXJnZXQpO1xuICAgICAgICAgICAgdGhpcy5yZWdpc3RlckRlYWN0aXZhdGlvbkhhbmRsZXJzKGV2dCk7XG4gICAgICAgIH1cbiAgICAgICAgYWN0aXZhdGlvblN0YXRlLndhc0VsZW1lbnRNYWRlQWN0aXZlID0gdGhpcy5jaGVja0VsZW1lbnRNYWRlQWN0aXZlKGV2dCk7XG4gICAgICAgIGlmIChhY3RpdmF0aW9uU3RhdGUud2FzRWxlbWVudE1hZGVBY3RpdmUpIHtcbiAgICAgICAgICAgIHRoaXMuYW5pbWF0ZUFjdGl2YXRpb24oKTtcbiAgICAgICAgfVxuICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgLy8gUmVzZXQgYXJyYXkgb24gbmV4dCBmcmFtZSBhZnRlciB0aGUgY3VycmVudCBldmVudCBoYXMgaGFkIGEgY2hhbmNlIHRvIGJ1YmJsZSB0byBwcmV2ZW50IGFuY2VzdG9yIHJpcHBsZXNcbiAgICAgICAgICAgIGFjdGl2YXRlZFRhcmdldHMgPSBbXTtcbiAgICAgICAgICAgIGlmICghYWN0aXZhdGlvblN0YXRlLndhc0VsZW1lbnRNYWRlQWN0aXZlXG4gICAgICAgICAgICAgICAgJiYgZXZ0ICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICAmJiAoZXZ0LmtleSA9PT0gJyAnIHx8IGV2dC5rZXlDb2RlID09PSAzMikpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiBzcGFjZSB3YXMgcHJlc3NlZCwgdHJ5IGFnYWluIHdpdGhpbiBhbiByQUYgY2FsbCB0byBkZXRlY3QgOmFjdGl2ZSwgYmVjYXVzZSBkaWZmZXJlbnQgVUFzIHJlcG9ydFxuICAgICAgICAgICAgICAgIC8vIGFjdGl2ZSBzdGF0ZXMgaW5jb25zaXN0ZW50bHkgd2hlbiB0aGV5J3JlIGNhbGxlZCB3aXRoaW4gZXZlbnQgaGFuZGxpbmcgY29kZTpcbiAgICAgICAgICAgICAgICAvLyAtIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTYzNTk3MVxuICAgICAgICAgICAgICAgIC8vIC0gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTI5Mzc0MVxuICAgICAgICAgICAgICAgIC8vIFdlIHRyeSBmaXJzdCBvdXRzaWRlIHJBRiB0byBzdXBwb3J0IEVkZ2UsIHdoaWNoIGRvZXMgbm90IGV4aGliaXQgdGhpcyBwcm9ibGVtLCBidXQgd2lsbCBjcmFzaCBpZiBhIENTU1xuICAgICAgICAgICAgICAgIC8vIHZhcmlhYmxlIGlzIHNldCB3aXRoaW4gYSByQUYgY2FsbGJhY2sgZm9yIGEgc3VibWl0IGJ1dHRvbiBpbnRlcmFjdGlvbiAoIzIyNDEpLlxuICAgICAgICAgICAgICAgIGFjdGl2YXRpb25TdGF0ZS53YXNFbGVtZW50TWFkZUFjdGl2ZSA9IF90aGlzLmNoZWNrRWxlbWVudE1hZGVBY3RpdmUoZXZ0KTtcbiAgICAgICAgICAgICAgICBpZiAoYWN0aXZhdGlvblN0YXRlLndhc0VsZW1lbnRNYWRlQWN0aXZlKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmFuaW1hdGVBY3RpdmF0aW9uKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFhY3RpdmF0aW9uU3RhdGUud2FzRWxlbWVudE1hZGVBY3RpdmUpIHtcbiAgICAgICAgICAgICAgICAvLyBSZXNldCBhY3RpdmF0aW9uIHN0YXRlIGltbWVkaWF0ZWx5IGlmIGVsZW1lbnQgd2FzIG5vdCBtYWRlIGFjdGl2ZS5cbiAgICAgICAgICAgICAgICBfdGhpcy5hY3RpdmF0aW9uU3RhdGUgPSBfdGhpcy5kZWZhdWx0QWN0aXZhdGlvblN0YXRlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgTURDUmlwcGxlRm91bmRhdGlvbi5wcm90b3R5cGUuY2hlY2tFbGVtZW50TWFkZUFjdGl2ZSA9IGZ1bmN0aW9uIChldnQpIHtcbiAgICAgICAgcmV0dXJuIChldnQgIT09IHVuZGVmaW5lZCAmJiBldnQudHlwZSA9PT0gJ2tleWRvd24nKSA/XG4gICAgICAgICAgICB0aGlzLmFkYXB0ZXIuaXNTdXJmYWNlQWN0aXZlKCkgOlxuICAgICAgICAgICAgdHJ1ZTtcbiAgICB9O1xuICAgIE1EQ1JpcHBsZUZvdW5kYXRpb24ucHJvdG90eXBlLmFuaW1hdGVBY3RpdmF0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgX2EgPSBNRENSaXBwbGVGb3VuZGF0aW9uLnN0cmluZ3MsIFZBUl9GR19UUkFOU0xBVEVfU1RBUlQgPSBfYS5WQVJfRkdfVFJBTlNMQVRFX1NUQVJULCBWQVJfRkdfVFJBTlNMQVRFX0VORCA9IF9hLlZBUl9GR19UUkFOU0xBVEVfRU5EO1xuICAgICAgICB2YXIgX2IgPSBNRENSaXBwbGVGb3VuZGF0aW9uLmNzc0NsYXNzZXMsIEZHX0RFQUNUSVZBVElPTiA9IF9iLkZHX0RFQUNUSVZBVElPTiwgRkdfQUNUSVZBVElPTiA9IF9iLkZHX0FDVElWQVRJT047XG4gICAgICAgIHZhciBERUFDVElWQVRJT05fVElNRU9VVF9NUyA9IE1EQ1JpcHBsZUZvdW5kYXRpb24ubnVtYmVycy5ERUFDVElWQVRJT05fVElNRU9VVF9NUztcbiAgICAgICAgdGhpcy5sYXlvdXRJbnRlcm5hbCgpO1xuICAgICAgICB2YXIgdHJhbnNsYXRlU3RhcnQgPSAnJztcbiAgICAgICAgdmFyIHRyYW5zbGF0ZUVuZCA9ICcnO1xuICAgICAgICBpZiAoIXRoaXMuYWRhcHRlci5pc1VuYm91bmRlZCgpKSB7XG4gICAgICAgICAgICB2YXIgX2MgPSB0aGlzLmdldEZnVHJhbnNsYXRpb25Db29yZGluYXRlcygpLCBzdGFydFBvaW50ID0gX2Muc3RhcnRQb2ludCwgZW5kUG9pbnQgPSBfYy5lbmRQb2ludDtcbiAgICAgICAgICAgIHRyYW5zbGF0ZVN0YXJ0ID0gc3RhcnRQb2ludC54ICsgXCJweCwgXCIgKyBzdGFydFBvaW50LnkgKyBcInB4XCI7XG4gICAgICAgICAgICB0cmFuc2xhdGVFbmQgPSBlbmRQb2ludC54ICsgXCJweCwgXCIgKyBlbmRQb2ludC55ICsgXCJweFwiO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYWRhcHRlci51cGRhdGVDc3NWYXJpYWJsZShWQVJfRkdfVFJBTlNMQVRFX1NUQVJULCB0cmFuc2xhdGVTdGFydCk7XG4gICAgICAgIHRoaXMuYWRhcHRlci51cGRhdGVDc3NWYXJpYWJsZShWQVJfRkdfVFJBTlNMQVRFX0VORCwgdHJhbnNsYXRlRW5kKTtcbiAgICAgICAgLy8gQ2FuY2VsIGFueSBvbmdvaW5nIGFjdGl2YXRpb24vZGVhY3RpdmF0aW9uIGFuaW1hdGlvbnNcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuYWN0aXZhdGlvblRpbWVyKTtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuZmdEZWFjdGl2YXRpb25SZW1vdmFsVGltZXIpO1xuICAgICAgICB0aGlzLnJtQm91bmRlZEFjdGl2YXRpb25DbGFzc2VzKCk7XG4gICAgICAgIHRoaXMuYWRhcHRlci5yZW1vdmVDbGFzcyhGR19ERUFDVElWQVRJT04pO1xuICAgICAgICAvLyBGb3JjZSBsYXlvdXQgaW4gb3JkZXIgdG8gcmUtdHJpZ2dlciB0aGUgYW5pbWF0aW9uLlxuICAgICAgICB0aGlzLmFkYXB0ZXIuY29tcHV0ZUJvdW5kaW5nUmVjdCgpO1xuICAgICAgICB0aGlzLmFkYXB0ZXIuYWRkQ2xhc3MoRkdfQUNUSVZBVElPTik7XG4gICAgICAgIHRoaXMuYWN0aXZhdGlvblRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpcy5hY3RpdmF0aW9uVGltZXJDYWxsYmFjaygpO1xuICAgICAgICB9LCBERUFDVElWQVRJT05fVElNRU9VVF9NUyk7XG4gICAgfTtcbiAgICBNRENSaXBwbGVGb3VuZGF0aW9uLnByb3RvdHlwZS5nZXRGZ1RyYW5zbGF0aW9uQ29vcmRpbmF0ZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfYSA9IHRoaXMuYWN0aXZhdGlvblN0YXRlLCBhY3RpdmF0aW9uRXZlbnQgPSBfYS5hY3RpdmF0aW9uRXZlbnQsIHdhc0FjdGl2YXRlZEJ5UG9pbnRlciA9IF9hLndhc0FjdGl2YXRlZEJ5UG9pbnRlcjtcbiAgICAgICAgdmFyIHN0YXJ0UG9pbnQ7XG4gICAgICAgIGlmICh3YXNBY3RpdmF0ZWRCeVBvaW50ZXIpIHtcbiAgICAgICAgICAgIHN0YXJ0UG9pbnQgPSBnZXROb3JtYWxpemVkRXZlbnRDb29yZHMoYWN0aXZhdGlvbkV2ZW50LCB0aGlzLmFkYXB0ZXIuZ2V0V2luZG93UGFnZU9mZnNldCgpLCB0aGlzLmFkYXB0ZXIuY29tcHV0ZUJvdW5kaW5nUmVjdCgpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHN0YXJ0UG9pbnQgPSB7XG4gICAgICAgICAgICAgICAgeDogdGhpcy5mcmFtZS53aWR0aCAvIDIsXG4gICAgICAgICAgICAgICAgeTogdGhpcy5mcmFtZS5oZWlnaHQgLyAyLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICAvLyBDZW50ZXIgdGhlIGVsZW1lbnQgYXJvdW5kIHRoZSBzdGFydCBwb2ludC5cbiAgICAgICAgc3RhcnRQb2ludCA9IHtcbiAgICAgICAgICAgIHg6IHN0YXJ0UG9pbnQueCAtICh0aGlzLmluaXRpYWxTaXplIC8gMiksXG4gICAgICAgICAgICB5OiBzdGFydFBvaW50LnkgLSAodGhpcy5pbml0aWFsU2l6ZSAvIDIpLFxuICAgICAgICB9O1xuICAgICAgICB2YXIgZW5kUG9pbnQgPSB7XG4gICAgICAgICAgICB4OiAodGhpcy5mcmFtZS53aWR0aCAvIDIpIC0gKHRoaXMuaW5pdGlhbFNpemUgLyAyKSxcbiAgICAgICAgICAgIHk6ICh0aGlzLmZyYW1lLmhlaWdodCAvIDIpIC0gKHRoaXMuaW5pdGlhbFNpemUgLyAyKSxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHsgc3RhcnRQb2ludDogc3RhcnRQb2ludCwgZW5kUG9pbnQ6IGVuZFBvaW50IH07XG4gICAgfTtcbiAgICBNRENSaXBwbGVGb3VuZGF0aW9uLnByb3RvdHlwZS5ydW5EZWFjdGl2YXRpb25VWExvZ2ljSWZSZWFkeSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgLy8gVGhpcyBtZXRob2QgaXMgY2FsbGVkIGJvdGggd2hlbiBhIHBvaW50aW5nIGRldmljZSBpcyByZWxlYXNlZCwgYW5kIHdoZW4gdGhlIGFjdGl2YXRpb24gYW5pbWF0aW9uIGVuZHMuXG4gICAgICAgIC8vIFRoZSBkZWFjdGl2YXRpb24gYW5pbWF0aW9uIHNob3VsZCBvbmx5IHJ1biBhZnRlciBib3RoIG9mIHRob3NlIG9jY3VyLlxuICAgICAgICB2YXIgRkdfREVBQ1RJVkFUSU9OID0gTURDUmlwcGxlRm91bmRhdGlvbi5jc3NDbGFzc2VzLkZHX0RFQUNUSVZBVElPTjtcbiAgICAgICAgdmFyIF9hID0gdGhpcy5hY3RpdmF0aW9uU3RhdGUsIGhhc0RlYWN0aXZhdGlvblVYUnVuID0gX2EuaGFzRGVhY3RpdmF0aW9uVVhSdW4sIGlzQWN0aXZhdGVkID0gX2EuaXNBY3RpdmF0ZWQ7XG4gICAgICAgIHZhciBhY3RpdmF0aW9uSGFzRW5kZWQgPSBoYXNEZWFjdGl2YXRpb25VWFJ1biB8fCAhaXNBY3RpdmF0ZWQ7XG4gICAgICAgIGlmIChhY3RpdmF0aW9uSGFzRW5kZWQgJiYgdGhpcy5hY3RpdmF0aW9uQW5pbWF0aW9uSGFzRW5kZWQpIHtcbiAgICAgICAgICAgIHRoaXMucm1Cb3VuZGVkQWN0aXZhdGlvbkNsYXNzZXMoKTtcbiAgICAgICAgICAgIHRoaXMuYWRhcHRlci5hZGRDbGFzcyhGR19ERUFDVElWQVRJT04pO1xuICAgICAgICAgICAgdGhpcy5mZ0RlYWN0aXZhdGlvblJlbW92YWxUaW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIF90aGlzLmFkYXB0ZXIucmVtb3ZlQ2xhc3MoRkdfREVBQ1RJVkFUSU9OKTtcbiAgICAgICAgICAgIH0sIG51bWJlcnMuRkdfREVBQ1RJVkFUSU9OX01TKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgTURDUmlwcGxlRm91bmRhdGlvbi5wcm90b3R5cGUucm1Cb3VuZGVkQWN0aXZhdGlvbkNsYXNzZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBGR19BQ1RJVkFUSU9OID0gTURDUmlwcGxlRm91bmRhdGlvbi5jc3NDbGFzc2VzLkZHX0FDVElWQVRJT047XG4gICAgICAgIHRoaXMuYWRhcHRlci5yZW1vdmVDbGFzcyhGR19BQ1RJVkFUSU9OKTtcbiAgICAgICAgdGhpcy5hY3RpdmF0aW9uQW5pbWF0aW9uSGFzRW5kZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5hZGFwdGVyLmNvbXB1dGVCb3VuZGluZ1JlY3QoKTtcbiAgICB9O1xuICAgIE1EQ1JpcHBsZUZvdW5kYXRpb24ucHJvdG90eXBlLnJlc2V0QWN0aXZhdGlvblN0YXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLnByZXZpb3VzQWN0aXZhdGlvbkV2ZW50ID0gdGhpcy5hY3RpdmF0aW9uU3RhdGUuYWN0aXZhdGlvbkV2ZW50O1xuICAgICAgICB0aGlzLmFjdGl2YXRpb25TdGF0ZSA9IHRoaXMuZGVmYXVsdEFjdGl2YXRpb25TdGF0ZSgpO1xuICAgICAgICAvLyBUb3VjaCBkZXZpY2VzIG1heSBmaXJlIGFkZGl0aW9uYWwgZXZlbnRzIGZvciB0aGUgc2FtZSBpbnRlcmFjdGlvbiB3aXRoaW4gYSBzaG9ydCB0aW1lLlxuICAgICAgICAvLyBTdG9yZSB0aGUgcHJldmlvdXMgZXZlbnQgdW50aWwgaXQncyBzYWZlIHRvIGFzc3VtZSB0aGF0IHN1YnNlcXVlbnQgZXZlbnRzIGFyZSBmb3IgbmV3IGludGVyYWN0aW9ucy5cbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5wcmV2aW91c0FjdGl2YXRpb25FdmVudCA9IHVuZGVmaW5lZDsgfSwgTURDUmlwcGxlRm91bmRhdGlvbi5udW1iZXJzLlRBUF9ERUxBWV9NUyk7XG4gICAgfTtcbiAgICBNRENSaXBwbGVGb3VuZGF0aW9uLnByb3RvdHlwZS5kZWFjdGl2YXRlSW1wbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIGFjdGl2YXRpb25TdGF0ZSA9IHRoaXMuYWN0aXZhdGlvblN0YXRlO1xuICAgICAgICAvLyBUaGlzIGNhbiBoYXBwZW4gaW4gc2NlbmFyaW9zIHN1Y2ggYXMgd2hlbiB5b3UgaGF2ZSBhIGtleXVwIGV2ZW50IHRoYXQgYmx1cnMgdGhlIGVsZW1lbnQuXG4gICAgICAgIGlmICghYWN0aXZhdGlvblN0YXRlLmlzQWN0aXZhdGVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHN0YXRlID0gX19hc3NpZ24oe30sIGFjdGl2YXRpb25TdGF0ZSk7XG4gICAgICAgIGlmIChhY3RpdmF0aW9uU3RhdGUuaXNQcm9ncmFtbWF0aWMpIHtcbiAgICAgICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuYW5pbWF0ZURlYWN0aXZhdGlvbihzdGF0ZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMucmVzZXRBY3RpdmF0aW9uU3RhdGUoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZGVyZWdpc3RlckRlYWN0aXZhdGlvbkhhbmRsZXJzKCk7XG4gICAgICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIF90aGlzLmFjdGl2YXRpb25TdGF0ZS5oYXNEZWFjdGl2YXRpb25VWFJ1biA9IHRydWU7XG4gICAgICAgICAgICAgICAgX3RoaXMuYW5pbWF0ZURlYWN0aXZhdGlvbihzdGF0ZSk7XG4gICAgICAgICAgICAgICAgX3RoaXMucmVzZXRBY3RpdmF0aW9uU3RhdGUoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBNRENSaXBwbGVGb3VuZGF0aW9uLnByb3RvdHlwZS5hbmltYXRlRGVhY3RpdmF0aW9uID0gZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHZhciB3YXNBY3RpdmF0ZWRCeVBvaW50ZXIgPSBfYS53YXNBY3RpdmF0ZWRCeVBvaW50ZXIsIHdhc0VsZW1lbnRNYWRlQWN0aXZlID0gX2Eud2FzRWxlbWVudE1hZGVBY3RpdmU7XG4gICAgICAgIGlmICh3YXNBY3RpdmF0ZWRCeVBvaW50ZXIgfHwgd2FzRWxlbWVudE1hZGVBY3RpdmUpIHtcbiAgICAgICAgICAgIHRoaXMucnVuRGVhY3RpdmF0aW9uVVhMb2dpY0lmUmVhZHkoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgTURDUmlwcGxlRm91bmRhdGlvbi5wcm90b3R5cGUubGF5b3V0SW50ZXJuYWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuZnJhbWUgPSB0aGlzLmFkYXB0ZXIuY29tcHV0ZUJvdW5kaW5nUmVjdCgpO1xuICAgICAgICB2YXIgbWF4RGltID0gTWF0aC5tYXgodGhpcy5mcmFtZS5oZWlnaHQsIHRoaXMuZnJhbWUud2lkdGgpO1xuICAgICAgICAvLyBTdXJmYWNlIGRpYW1ldGVyIGlzIHRyZWF0ZWQgZGlmZmVyZW50bHkgZm9yIHVuYm91bmRlZCB2cy4gYm91bmRlZCByaXBwbGVzLlxuICAgICAgICAvLyBVbmJvdW5kZWQgcmlwcGxlIGRpYW1ldGVyIGlzIGNhbGN1bGF0ZWQgc21hbGxlciBzaW5jZSB0aGUgc3VyZmFjZSBpcyBleHBlY3RlZCB0byBhbHJlYWR5IGJlIHBhZGRlZCBhcHByb3ByaWF0ZWx5XG4gICAgICAgIC8vIHRvIGV4dGVuZCB0aGUgaGl0Ym94LCBhbmQgdGhlIHJpcHBsZSBpcyBleHBlY3RlZCB0byBtZWV0IHRoZSBlZGdlcyBvZiB0aGUgcGFkZGVkIGhpdGJveCAod2hpY2ggaXMgdHlwaWNhbGx5XG4gICAgICAgIC8vIHNxdWFyZSkuIEJvdW5kZWQgcmlwcGxlcywgb24gdGhlIG90aGVyIGhhbmQsIGFyZSBmdWxseSBleHBlY3RlZCB0byBleHBhbmQgYmV5b25kIHRoZSBzdXJmYWNlJ3MgbG9uZ2VzdCBkaWFtZXRlclxuICAgICAgICAvLyAoY2FsY3VsYXRlZCBiYXNlZCBvbiB0aGUgZGlhZ29uYWwgcGx1cyBhIGNvbnN0YW50IHBhZGRpbmcpLCBhbmQgYXJlIGNsaXBwZWQgYXQgdGhlIHN1cmZhY2UncyBib3JkZXIgdmlhXG4gICAgICAgIC8vIGBvdmVyZmxvdzogaGlkZGVuYC5cbiAgICAgICAgdmFyIGdldEJvdW5kZWRSYWRpdXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgaHlwb3RlbnVzZSA9IE1hdGguc3FydChNYXRoLnBvdyhfdGhpcy5mcmFtZS53aWR0aCwgMikgKyBNYXRoLnBvdyhfdGhpcy5mcmFtZS5oZWlnaHQsIDIpKTtcbiAgICAgICAgICAgIHJldHVybiBoeXBvdGVudXNlICsgTURDUmlwcGxlRm91bmRhdGlvbi5udW1iZXJzLlBBRERJTkc7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMubWF4UmFkaXVzID0gdGhpcy5hZGFwdGVyLmlzVW5ib3VuZGVkKCkgPyBtYXhEaW0gOiBnZXRCb3VuZGVkUmFkaXVzKCk7XG4gICAgICAgIC8vIFJpcHBsZSBpcyBzaXplZCBhcyBhIGZyYWN0aW9uIG9mIHRoZSBsYXJnZXN0IGRpbWVuc2lvbiBvZiB0aGUgc3VyZmFjZSwgdGhlbiBzY2FsZXMgdXAgdXNpbmcgYSBDU1Mgc2NhbGUgdHJhbnNmb3JtXG4gICAgICAgIHZhciBpbml0aWFsU2l6ZSA9IE1hdGguZmxvb3IobWF4RGltICogTURDUmlwcGxlRm91bmRhdGlvbi5udW1iZXJzLklOSVRJQUxfT1JJR0lOX1NDQUxFKTtcbiAgICAgICAgLy8gVW5ib3VuZGVkIHJpcHBsZSBzaXplIHNob3VsZCBhbHdheXMgYmUgZXZlbiBudW1iZXIgdG8gZXF1YWxseSBjZW50ZXIgYWxpZ24uXG4gICAgICAgIGlmICh0aGlzLmFkYXB0ZXIuaXNVbmJvdW5kZWQoKSAmJiBpbml0aWFsU2l6ZSAlIDIgIT09IDApIHtcbiAgICAgICAgICAgIHRoaXMuaW5pdGlhbFNpemUgPSBpbml0aWFsU2l6ZSAtIDE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmluaXRpYWxTaXplID0gaW5pdGlhbFNpemU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5mZ1NjYWxlID0gXCJcIiArIHRoaXMubWF4UmFkaXVzIC8gdGhpcy5pbml0aWFsU2l6ZTtcbiAgICAgICAgdGhpcy51cGRhdGVMYXlvdXRDc3NWYXJzKCk7XG4gICAgfTtcbiAgICBNRENSaXBwbGVGb3VuZGF0aW9uLnByb3RvdHlwZS51cGRhdGVMYXlvdXRDc3NWYXJzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX2EgPSBNRENSaXBwbGVGb3VuZGF0aW9uLnN0cmluZ3MsIFZBUl9GR19TSVpFID0gX2EuVkFSX0ZHX1NJWkUsIFZBUl9MRUZUID0gX2EuVkFSX0xFRlQsIFZBUl9UT1AgPSBfYS5WQVJfVE9QLCBWQVJfRkdfU0NBTEUgPSBfYS5WQVJfRkdfU0NBTEU7XG4gICAgICAgIHRoaXMuYWRhcHRlci51cGRhdGVDc3NWYXJpYWJsZShWQVJfRkdfU0laRSwgdGhpcy5pbml0aWFsU2l6ZSArIFwicHhcIik7XG4gICAgICAgIHRoaXMuYWRhcHRlci51cGRhdGVDc3NWYXJpYWJsZShWQVJfRkdfU0NBTEUsIHRoaXMuZmdTY2FsZSk7XG4gICAgICAgIGlmICh0aGlzLmFkYXB0ZXIuaXNVbmJvdW5kZWQoKSkge1xuICAgICAgICAgICAgdGhpcy51bmJvdW5kZWRDb29yZHMgPSB7XG4gICAgICAgICAgICAgICAgbGVmdDogTWF0aC5yb3VuZCgodGhpcy5mcmFtZS53aWR0aCAvIDIpIC0gKHRoaXMuaW5pdGlhbFNpemUgLyAyKSksXG4gICAgICAgICAgICAgICAgdG9wOiBNYXRoLnJvdW5kKCh0aGlzLmZyYW1lLmhlaWdodCAvIDIpIC0gKHRoaXMuaW5pdGlhbFNpemUgLyAyKSksXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGhpcy5hZGFwdGVyLnVwZGF0ZUNzc1ZhcmlhYmxlKFZBUl9MRUZULCB0aGlzLnVuYm91bmRlZENvb3Jkcy5sZWZ0ICsgXCJweFwiKTtcbiAgICAgICAgICAgIHRoaXMuYWRhcHRlci51cGRhdGVDc3NWYXJpYWJsZShWQVJfVE9QLCB0aGlzLnVuYm91bmRlZENvb3Jkcy50b3AgKyBcInB4XCIpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gTURDUmlwcGxlRm91bmRhdGlvbjtcbn0oTURDRm91bmRhdGlvbikpO1xuZXhwb3J0IHsgTURDUmlwcGxlRm91bmRhdGlvbiB9O1xuLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLWRlZmF1bHQtZXhwb3J0IE5lZWRlZCBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eSB3aXRoIE1EQyBXZWIgdjAuNDQuMCBhbmQgZWFybGllci5cbmV4cG9ydCBkZWZhdWx0IE1EQ1JpcHBsZUZvdW5kYXRpb247XG4vLyMgc291cmNlTWFwcGluZ1VSTD1mb3VuZGF0aW9uLmpzLm1hcCIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuXG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICpcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4gKiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbiAqIFRIRSBTT0ZUV0FSRS5cbiAqL1xuaW1wb3J0IHsgX19leHRlbmRzIH0gZnJvbSBcInRzbGliXCI7XG5pbXBvcnQgeyBNRENDb21wb25lbnQgfSBmcm9tICdAbWF0ZXJpYWwvYmFzZS9jb21wb25lbnQnO1xuaW1wb3J0IHsgYXBwbHlQYXNzaXZlIH0gZnJvbSAnQG1hdGVyaWFsL2RvbS9ldmVudHMnO1xuaW1wb3J0IHsgbWF0Y2hlcyB9IGZyb20gJ0BtYXRlcmlhbC9kb20vcG9ueWZpbGwnO1xuaW1wb3J0IHsgTURDUmlwcGxlRm91bmRhdGlvbiB9IGZyb20gJy4vZm91bmRhdGlvbic7XG5pbXBvcnQgKiBhcyB1dGlsIGZyb20gJy4vdXRpbCc7XG52YXIgTURDUmlwcGxlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhNRENSaXBwbGUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTURDUmlwcGxlKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuZGlzYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBNRENSaXBwbGUuYXR0YWNoVG8gPSBmdW5jdGlvbiAocm9vdCwgb3B0cykge1xuICAgICAgICBpZiAob3B0cyA9PT0gdm9pZCAwKSB7IG9wdHMgPSB7XG4gICAgICAgICAgICBpc1VuYm91bmRlZDogdW5kZWZpbmVkXG4gICAgICAgIH07IH1cbiAgICAgICAgdmFyIHJpcHBsZSA9IG5ldyBNRENSaXBwbGUocm9vdCk7XG4gICAgICAgIC8vIE9ubHkgb3ZlcnJpZGUgdW5ib3VuZGVkIGJlaGF2aW9yIGlmIG9wdGlvbiBpcyBleHBsaWNpdGx5IHNwZWNpZmllZFxuICAgICAgICBpZiAob3B0cy5pc1VuYm91bmRlZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByaXBwbGUudW5ib3VuZGVkID0gb3B0cy5pc1VuYm91bmRlZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmlwcGxlO1xuICAgIH07XG4gICAgTURDUmlwcGxlLmNyZWF0ZUFkYXB0ZXIgPSBmdW5jdGlvbiAoaW5zdGFuY2UpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGFkZENsYXNzOiBmdW5jdGlvbiAoY2xhc3NOYW1lKSB7IHJldHVybiBpbnN0YW5jZS5yb290LmNsYXNzTGlzdC5hZGQoY2xhc3NOYW1lKTsgfSxcbiAgICAgICAgICAgIGJyb3dzZXJTdXBwb3J0c0Nzc1ZhcnM6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHV0aWwuc3VwcG9ydHNDc3NWYXJpYWJsZXMod2luZG93KTsgfSxcbiAgICAgICAgICAgIGNvbXB1dGVCb3VuZGluZ1JlY3Q6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGluc3RhbmNlLnJvb3QuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7IH0sXG4gICAgICAgICAgICBjb250YWluc0V2ZW50VGFyZ2V0OiBmdW5jdGlvbiAodGFyZ2V0KSB7IHJldHVybiBpbnN0YW5jZS5yb290LmNvbnRhaW5zKHRhcmdldCk7IH0sXG4gICAgICAgICAgICBkZXJlZ2lzdGVyRG9jdW1lbnRJbnRlcmFjdGlvbkhhbmRsZXI6IGZ1bmN0aW9uIChldnRUeXBlLCBoYW5kbGVyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKGV2dFR5cGUsIGhhbmRsZXIsIGFwcGx5UGFzc2l2ZSgpKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkZXJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyOiBmdW5jdGlvbiAoZXZ0VHlwZSwgaGFuZGxlcikge1xuICAgICAgICAgICAgICAgIHJldHVybiBpbnN0YW5jZS5yb290XG4gICAgICAgICAgICAgICAgICAgIC5yZW1vdmVFdmVudExpc3RlbmVyKGV2dFR5cGUsIGhhbmRsZXIsIGFwcGx5UGFzc2l2ZSgpKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkZXJlZ2lzdGVyUmVzaXplSGFuZGxlcjogZnVuY3Rpb24gKGhhbmRsZXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIGhhbmRsZXIpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdldFdpbmRvd1BhZ2VPZmZzZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKHsgeDogd2luZG93LnBhZ2VYT2Zmc2V0LCB5OiB3aW5kb3cucGFnZVlPZmZzZXQgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaXNTdXJmYWNlQWN0aXZlOiBmdW5jdGlvbiAoKSB7IHJldHVybiBtYXRjaGVzKGluc3RhbmNlLnJvb3QsICc6YWN0aXZlJyk7IH0sXG4gICAgICAgICAgICBpc1N1cmZhY2VEaXNhYmxlZDogZnVuY3Rpb24gKCkgeyByZXR1cm4gQm9vbGVhbihpbnN0YW5jZS5kaXNhYmxlZCk7IH0sXG4gICAgICAgICAgICBpc1VuYm91bmRlZDogZnVuY3Rpb24gKCkgeyByZXR1cm4gQm9vbGVhbihpbnN0YW5jZS51bmJvdW5kZWQpOyB9LFxuICAgICAgICAgICAgcmVnaXN0ZXJEb2N1bWVudEludGVyYWN0aW9uSGFuZGxlcjogZnVuY3Rpb24gKGV2dFR5cGUsIGhhbmRsZXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoZXZ0VHlwZSwgaGFuZGxlciwgYXBwbHlQYXNzaXZlKCkpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyOiBmdW5jdGlvbiAoZXZ0VHlwZSwgaGFuZGxlcikge1xuICAgICAgICAgICAgICAgIHJldHVybiBpbnN0YW5jZS5yb290XG4gICAgICAgICAgICAgICAgICAgIC5hZGRFdmVudExpc3RlbmVyKGV2dFR5cGUsIGhhbmRsZXIsIGFwcGx5UGFzc2l2ZSgpKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICByZWdpc3RlclJlc2l6ZUhhbmRsZXI6IGZ1bmN0aW9uIChoYW5kbGVyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCBoYW5kbGVyKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICByZW1vdmVDbGFzczogZnVuY3Rpb24gKGNsYXNzTmFtZSkgeyByZXR1cm4gaW5zdGFuY2Uucm9vdC5jbGFzc0xpc3QucmVtb3ZlKGNsYXNzTmFtZSk7IH0sXG4gICAgICAgICAgICB1cGRhdGVDc3NWYXJpYWJsZTogZnVuY3Rpb24gKHZhck5hbWUsIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGluc3RhbmNlLnJvb3Quc3R5bGUuc2V0UHJvcGVydHkodmFyTmFtZSwgdmFsdWUpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNRENSaXBwbGUucHJvdG90eXBlLCBcInVuYm91bmRlZFwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIEJvb2xlYW4odGhpcy5pc1VuYm91bmRlZCk7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHVuYm91bmRlZCkge1xuICAgICAgICAgICAgdGhpcy5pc1VuYm91bmRlZCA9IEJvb2xlYW4odW5ib3VuZGVkKTtcbiAgICAgICAgICAgIHRoaXMuc2V0VW5ib3VuZGVkKCk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBNRENSaXBwbGUucHJvdG90eXBlLmFjdGl2YXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmZvdW5kYXRpb24uYWN0aXZhdGUoKTtcbiAgICB9O1xuICAgIE1EQ1JpcHBsZS5wcm90b3R5cGUuZGVhY3RpdmF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5mb3VuZGF0aW9uLmRlYWN0aXZhdGUoKTtcbiAgICB9O1xuICAgIE1EQ1JpcHBsZS5wcm90b3R5cGUubGF5b3V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmZvdW5kYXRpb24ubGF5b3V0KCk7XG4gICAgfTtcbiAgICBNRENSaXBwbGUucHJvdG90eXBlLmdldERlZmF1bHRGb3VuZGF0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gbmV3IE1EQ1JpcHBsZUZvdW5kYXRpb24oTURDUmlwcGxlLmNyZWF0ZUFkYXB0ZXIodGhpcykpO1xuICAgIH07XG4gICAgTURDUmlwcGxlLnByb3RvdHlwZS5pbml0aWFsU3luY1dpdGhET00gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciByb290ID0gdGhpcy5yb290O1xuICAgICAgICB0aGlzLmlzVW5ib3VuZGVkID0gJ21kY1JpcHBsZUlzVW5ib3VuZGVkJyBpbiByb290LmRhdGFzZXQ7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDbG9zdXJlIENvbXBpbGVyIHRocm93cyBhbiBhY2Nlc3MgY29udHJvbCBlcnJvciB3aGVuIGRpcmVjdGx5IGFjY2Vzc2luZyBhXG4gICAgICogcHJvdGVjdGVkIG9yIHByaXZhdGUgcHJvcGVydHkgaW5zaWRlIGEgZ2V0dGVyL3NldHRlciwgbGlrZSB1bmJvdW5kZWQgYWJvdmUuXG4gICAgICogQnkgYWNjZXNzaW5nIHRoZSBwcm90ZWN0ZWQgcHJvcGVydHkgaW5zaWRlIGEgbWV0aG9kLCB3ZSBzb2x2ZSB0aGF0IHByb2JsZW0uXG4gICAgICogVGhhdCdzIHdoeSB0aGlzIGZ1bmN0aW9uIGV4aXN0cy5cbiAgICAgKi9cbiAgICBNRENSaXBwbGUucHJvdG90eXBlLnNldFVuYm91bmRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5mb3VuZGF0aW9uLnNldFVuYm91bmRlZChCb29sZWFuKHRoaXMuaXNVbmJvdW5kZWQpKTtcbiAgICB9O1xuICAgIHJldHVybiBNRENSaXBwbGU7XG59KE1EQ0NvbXBvbmVudCkpO1xuZXhwb3J0IHsgTURDUmlwcGxlIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb21wb25lbnQuanMubWFwIiwiaW1wb3J0IHsgdXNlRWZmZWN0LCB1c2VSZWYgfSBmcm9tICdyZWFjdCc7XHJcbmltcG9ydCB7IE1EQ1JpcHBsZSB9IGZyb20gJ0BtYXRlcmlhbC9yaXBwbGUnO1xyXG5pbXBvcnQgY2xhc3NuYW1lcyBmcm9tICdjbGFzc25hbWVzJztcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIFJpcHBsZSh7XHJcbiAgICB1bmJvdW5kZWQgPSBmYWxzZSxcclxuICAgIGRpc2FibGVkID0gZmFsc2UsXHJcbiAgICBjbGFzc05hbWUsXHJcbiAgICBlbGVtZW50OiBFbGVtZW50ID0gJ3NwYW4nLFxyXG4gICAgLi4ucHJvcHNcclxufSkge1xyXG4gICAgY29uc3Qgcm9vdFJlZiA9IHVzZVJlZigpO1xyXG4gICAgY29uc3QgcmlwcGxlUmVmID0gdXNlUmVmKCk7XHJcblxyXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgICAgICBpZiAoZGlzYWJsZWQpIHJldHVybjtcclxuXHJcbiAgICAgICAgaWYgKCFyaXBwbGVSZWYuY3VycmVudCkge1xyXG4gICAgICAgICAgICByaXBwbGVSZWYuY3VycmVudCA9IG5ldyBNRENSaXBwbGUocm9vdFJlZi5jdXJyZW50LnBhcmVudE5vZGUpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmlwcGxlUmVmLmN1cnJlbnQudW5ib3VuZGVkID0gdW5ib3VuZGVkO1xyXG5cclxuICAgICAgICByZXR1cm4gKCkgPT4gcmlwcGxlUmVmLmN1cnJlbnQuZGVzdHJveSgpO1xyXG4gICAgfSwgW2Rpc2FibGVkLCB1bmJvdW5kZWRdKTtcclxuXHJcbiAgICBjb25zdCBjbGFzc05hbWVzID0gY2xhc3NuYW1lcyhjbGFzc05hbWUpO1xyXG5cclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgPEVsZW1lbnRcclxuICAgICAgICAgICAgcmVmPXtyb290UmVmfVxyXG4gICAgICAgICAgICBjbGFzc05hbWU9e2NsYXNzTmFtZXN9XHJcbiAgICAgICAgICAgIHsuLi5wcm9wc31cclxuICAgICAgICAvPlxyXG4gICAgKTtcclxufVxyXG5cclxuUmlwcGxlLmRpc3BsYXlOYW1lID0gJ01EQ1JpcHBsZSc7IiwiZXhwb3J0IGNvbnN0IGNzc0NsYXNzZXMgPSB7XHJcbiAgICBST09UOiAnbWRjLXJpcHBsZS11cGdyYWRlZCcsXHJcbiAgICBVTkJPVU5ERUQ6ICdtZGMtcmlwcGxlLXVwZ3JhZGVkLS11bmJvdW5kZWQnLFxyXG4gICAgQkdfRk9DVVNFRDogJ21kYy1yaXBwbGUtdXBncmFkZWQtLWJhY2tncm91bmQtZm9jdXNlZCcsXHJcbiAgICBGR19BQ1RJVkFUSU9OOiAnbWRjLXJpcHBsZS11cGdyYWRlZC0tZm9yZWdyb3VuZC1hY3RpdmF0aW9uJyxcclxuICAgIEZHX0RFQUNUSVZBVElPTjogJ21kYy1yaXBwbGUtdXBncmFkZWQtLWZvcmVncm91bmQtZGVhY3RpdmF0aW9uJyxcclxuXHJcbiAgICBTVVJGQUNFOiAnbWRjLXJpcHBsZS1zdXJmYWNlJyxcclxuICAgIFNVUkZBQ0VfUFJJTUFSWTogJ21kYy1yaXBwbGUtc3VyZmFjZS0tcHJpbWFyeScsXHJcbiAgICBTVVJGQUNFX0FDQ0VOVDogJ21kYy1yaXBwbGUtc3VyZmFjZS0tYWNjZW50J1xyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IHN0cmluZ3MgPSB7XHJcbiAgICBWQVJfRkdfU0NBTEU6ICctLW1kYy1yaXBwbGUtZmctc2NhbGUnLFxyXG4gICAgVkFSX0ZHX1NJWkU6ICctLW1kYy1yaXBwbGUtZmctc2l6ZScsXHJcbiAgICBWQVJfRkdfVFJBTlNMQVRFX0VORDogJy0tbWRjLXJpcHBsZS1mZy10cmFuc2xhdGUtZW5kJyxcclxuICAgIFZBUl9GR19UUkFOU0xBVEVfU1RBUlQ6ICctLW1kYy1yaXBwbGUtZmctdHJhbnNsYXRlLXN0YXJ0JyxcclxuICAgIFZBUl9MRUZUOiAnLS1tZGMtcmlwcGxlLWxlZnQnLFxyXG4gICAgVkFSX1RPUDogJy0tbWRjLXJpcHBsZS10b3AnLFxyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IG51bWJlcnMgPSB7XHJcbiAgICBERUFDVElWQVRJT05fVElNRU9VVF9NUzogMjI1LCAvLyBDb3JyZXNwb25kcyB0byAkbWRjLXJpcHBsZS10cmFuc2xhdGUtZHVyYXRpb24gKGkuZS4gYWN0aXZhdGlvbiBhbmltYXRpb24gZHVyYXRpb24pXHJcbiAgICBGR19ERUFDVElWQVRJT05fTVM6IDE1MCwgLy8gQ29ycmVzcG9uZHMgdG8gJG1kYy1yaXBwbGUtZmFkZS1vdXQtZHVyYXRpb24gKGkuZS4gZGVhY3RpdmF0aW9uIGFuaW1hdGlvbiBkdXJhdGlvbilcclxuICAgIElOSVRJQUxfT1JJR0lOX1NDQUxFOiAwLjYsXHJcbiAgICBQQURESU5HOiAxMCxcclxuICAgIFRBUF9ERUxBWV9NUzogMzAwLCAvLyBEZWxheSBiZXR3ZWVuIHRvdWNoIGFuZCBzaW11bGF0ZWQgbW91c2UgZXZlbnRzIG9uIHRvdWNoIGRldmljZXNcclxufTsiLCJpbXBvcnQgeyB1c2VFZmZlY3QsIHVzZVJlZiB9IGZyb20gJ3JlYWN0JztcclxuaW1wb3J0IHsgTURDUmlwcGxlIH0gZnJvbSAnQG1hdGVyaWFsL3JpcHBsZSc7XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gdXNlUmlwcGxlKHJvb3RSZWYsIHVuYm91bmRlZCA9IGZhbHNlKSB7XHJcbiAgICBjb25zdCByaXBwbGVSZWYgPSB1c2VSZWYoKTtcclxuXHJcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgICAgIGlmICghcmlwcGxlUmVmLmN1cnJlbnQpIHtcclxuICAgICAgICAgICAgcmlwcGxlUmVmLmN1cnJlbnQgPSBuZXcgTURDUmlwcGxlKHJvb3RSZWYuY3VycmVudCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByaXBwbGVSZWYuY3VycmVudC51bmJvdW5kZWQgPSB1bmJvdW5kZWQ7XHJcblxyXG4gICAgICAgIHJldHVybiAoKSA9PiByaXBwbGVSZWYuY3VycmVudC5kZXN0cm95KCk7XHJcbiAgICB9LCBbcm9vdFJlZiwgdW5ib3VuZGVkXSk7XHJcblxyXG4gICAgcmV0dXJuIHJpcHBsZVJlZi5jdXJyZW50O1xyXG59IiwiaW1wb3J0IHsgZm9yd2FyZFJlZiwgdXNlUmVmLCB1c2VJbXBlcmF0aXZlSGFuZGxlIH0gZnJvbSAncmVhY3QnO1xyXG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xyXG5pbXBvcnQgY2xhc3NuYW1lcyBmcm9tICdjbGFzc25hbWVzJztcclxuXHJcbmltcG9ydCB7IGNzc0NsYXNzZXMgfSBmcm9tICcuL2NvbnN0YW50cyc7XHJcbmltcG9ydCB7IHVzZVJpcHBsZSB9IGZyb20gJy4vaG9va3MnO1xyXG5cclxuY29uc3QgUmlwcGxlU3VyZmFjZSA9IGZvcndhcmRSZWYoKHtcclxuICAgIHByaW1hcnksXHJcbiAgICBhY2NlbnQsXHJcblxyXG4gICAgY2xhc3NOYW1lLFxyXG4gICAgZWxlbWVudDogRWxlbWVudCA9ICdkaXYnLFxyXG4gICAgLi4ucHJvcHNcclxufSwgcmVmKSA9PiB7XHJcbiAgICBjb25zdCByb290UmVmID0gdXNlUmVmKCk7XHJcblxyXG4gICAgdXNlSW1wZXJhdGl2ZUhhbmRsZShyZWYsICgpID0+IHJvb3RSZWYuY3VycmVudCk7XHJcbiAgICB1c2VSaXBwbGUocm9vdFJlZik7XHJcblxyXG4gICAgY29uc3QgY2xhc3NOYW1lcyA9IGNsYXNzbmFtZXMoY3NzQ2xhc3Nlcy5TVVJGQUNFLCB7XHJcbiAgICAgICAgW2Nzc0NsYXNzZXMuU1VSRkFDRV9QUklNQVJZXTogcHJpbWFyeSxcclxuICAgICAgICBbY3NzQ2xhc3Nlcy5TVVJGQUNFX0FDQ0VOVF06IGFjY2VudFxyXG4gICAgfSwgY2xhc3NOYW1lKTtcclxuXHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAgIDxFbGVtZW50XHJcbiAgICAgICAgICAgIHJlZj17cm9vdFJlZn1cclxuICAgICAgICAgICAgY2xhc3NOYW1lPXtjbGFzc05hbWVzfVxyXG4gICAgICAgICAgICB7Li4ucHJvcHN9XHJcbiAgICAgICAgLz5cclxuICAgICk7XHJcbn0pO1xyXG5cclxuUmlwcGxlU3VyZmFjZS5kaXNwbGF5TmFtZSA9ICdNRENSaXBwbGVTdXJmYWNlJztcclxuXHJcblJpcHBsZVN1cmZhY2UucHJvcFR5cGVzID0ge1xyXG4gICAgcHJpbWFyeTogUHJvcFR5cGVzLmJvb2wsXHJcbiAgICBhY2NlbnQ6IFByb3BUeXBlcy5ib29sXHJcbn07XHJcblxyXG5leHBvcnQgZGVmYXVsdCBSaXBwbGVTdXJmYWNlOyIsImV4cG9ydCB7IGRlZmF1bHQgYXMgUmlwcGxlIH0gZnJvbSAnLi9SaXBwbGUnO1xyXG5leHBvcnQgeyBkZWZhdWx0IGFzIFJpcHBsZVN1cmZhY2UgfSBmcm9tICcuL1JpcHBsZVN1cmZhY2UnOyIsImV4cG9ydCBjb25zdCBjc3NDbGFzc2VzID0ge1xyXG4gICAgUk9PVDogJ21kYy1zZWdtZW50ZWQtYnV0dG9uJyxcclxuICAgIFNJTkdMRV9TRUxFQ1Q6ICdtZGMtc2VnbWVudGVkLWJ1dHRvbi0tc2luZ2xlLXNlbGVjdCcsXHJcblxyXG4gICAgU0VHTUVOVDogJ21kYy1zZWdtZW50ZWQtYnV0dG9uX19zZWdtZW50JyxcclxuICAgIFNFR01FTlRfU0VMRUNURUQ6ICdtZGMtc2VnbWVudGVkLWJ1dHRvbl9fc2VnbWVudC0tc2VsZWN0ZWQnLFxyXG5cclxuICAgIElDT046ICdtZGMtc2VnbWVudGVkLWJ1dHRvbl9faWNvbicsXHJcbiAgICBMQUJFTDogJ21kYy1zZWdtZW50ZWQtYnV0dG9uX19sYWJlbCcsXHJcbiAgICBSSVBQTEU6ICdtZGMtc2VnbWVudGVkLWJ1dHRvbl9fcmlwcGxlJyxcclxuICAgIFRPVUNIOiAnbWRjLXNlZ21lbnRlZC1idXR0b24tLXRvdWNoJyxcclxuICAgIFRPVUNIX0VMRU1FTlQ6ICdtZGMtc2VnbWVudGVkLWJ1dHRvbl9fdG91Y2gnXHJcbn07IiwiaW1wb3J0IHsgZm9yd2FyZFJlZiB9IGZyb20gJ3JlYWN0JztcclxuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcclxuaW1wb3J0IGNsYXNzbmFtZXMgZnJvbSAnY2xhc3NuYW1lcyc7XHJcblxyXG5pbXBvcnQgeyBDbG9uZSB9IGZyb20gJy4uL2NvbXBvbmVudCc7XHJcbmltcG9ydCBJY29uIGZyb20gJy4uL2ljb24nO1xyXG5cclxuaW1wb3J0IHsgY3NzQ2xhc3NlcyB9IGZyb20gJy4vY29uc3RhbnRzJztcclxuXHJcbmNvbnN0IFNlZ21lbnRlZEJ1dHRvblNlZ21lbnQgPSBmb3J3YXJkUmVmKCh7XHJcbiAgICBsYWJlbCxcclxuICAgIGljb24sXHJcbiAgICBzZWxlY3RlZCxcclxuICAgIHRvdWNoLFxyXG4gICAgcmlwcGxlLFxyXG5cclxuICAgIGVsZW1lbnQgPSAnYnV0dG9uJyxcclxuICAgIGNvbXBvbmVudDogRWxlbWVudCA9IGVsZW1lbnQsXHJcbiAgICBjbGFzc05hbWUsXHJcbiAgICBjaGlsZHJlbiA9IGxhYmVsLFxyXG4gICAgLi4ucHJvcHNcclxufSwgcmVmKSA9PiB7XHJcbiAgICBjb25zdCBjbGFzc05hbWVzID0gY2xhc3NuYW1lcyhjc3NDbGFzc2VzLlNFR01FTlQsIHtcclxuICAgICAgICBbY3NzQ2xhc3Nlcy5TRUdNRU5UX1NFTEVDVEVEXTogc2VsZWN0ZWQsXHJcbiAgICAgICAgW2Nzc0NsYXNzZXMuVE9VQ0hdOiB0b3VjaFxyXG4gICAgfSwgY2xhc3NOYW1lKTtcclxuXHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAgIDxFbGVtZW50XHJcbiAgICAgICAgICAgIHJlZj17cmVmfVxyXG4gICAgICAgICAgICBjbGFzc05hbWU9e2NsYXNzTmFtZXN9XHJcbiAgICAgICAgICAgIHsuLi5wcm9wc31cclxuICAgICAgICA+XHJcbiAgICAgICAgICAgIHtyaXBwbGUgJiZcclxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXtjc3NDbGFzc2VzLlJJUFBMRX0gLz5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAge3RvdWNoICYmXHJcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17Y3NzQ2xhc3Nlcy5UT1VDSF9FTEVNRU5UfSAvPlxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB7aWNvbiAmJlxyXG4gICAgICAgICAgICAgICAgPENsb25lXHJcbiAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50PXtpY29ufVxyXG4gICAgICAgICAgICAgICAgICAgIGZhbGxiYWNrPXtJY29ufVxyXG4gICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT17Y3NzQ2xhc3Nlcy5JQ09OfVxyXG4gICAgICAgICAgICAgICAgLz5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAge2NoaWxkcmVuICYmXHJcbiAgICAgICAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9e2Nzc0NsYXNzZXMuTEFCRUx9PntjaGlsZHJlbn08L3NwYW4+XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICA8L0VsZW1lbnQ+XHJcbiAgICApO1xyXG59KTtcclxuXHJcblNlZ21lbnRlZEJ1dHRvblNlZ21lbnQuZGlzcGxheU5hbWUgPSAnTURDU2VnbWVudGVkQnV0dG9uU2VnbWVudCc7XHJcblxyXG5TZWdtZW50ZWRCdXR0b25TZWdtZW50LnByb3BUeXBlcyA9IHtcclxuICAgIGxhYmVsOiBQcm9wVHlwZXMuc3RyaW5nLFxyXG4gICAgaWNvbjogUHJvcFR5cGVzLm5vZGUsXHJcbiAgICBzZWxlY3RlZDogUHJvcFR5cGVzLmJvb2wsXHJcbiAgICByaXBwbGU6IFByb3BUeXBlcy5ib29sXHJcbn07XHJcblxyXG5leHBvcnQgZGVmYXVsdCBTZWdtZW50ZWRCdXR0b25TZWdtZW50OyIsImltcG9ydCB7IGZvcndhcmRSZWYsIENoaWxkcmVuLCB1c2VDYWxsYmFjayB9IGZyb20gJ3JlYWN0JztcclxuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcclxuaW1wb3J0IGNsYXNzbmFtZXMgZnJvbSAnY2xhc3NuYW1lcyc7XHJcblxyXG5pbXBvcnQgeyBpc1VuZGVmaW5lZCwgaXNBcnJheSB9IGZyb20gJy4uL3R5cGVzJztcclxuaW1wb3J0IHsgY3JlYXRlLCBjbG9uZSB9IGZyb20gJy4uL2NvbXBvbmVudCc7XHJcblxyXG5pbXBvcnQgeyBjc3NDbGFzc2VzIH0gZnJvbSAnLi9jb25zdGFudHMnO1xyXG5pbXBvcnQgU2VnbWVudGVkQnV0dG9uU2VnbWVudCBmcm9tICcuL1NlZ21lbnRlZEJ1dHRvblNlZ21lbnQnO1xyXG5cclxuY29uc3QgU2VnbWVudGVkQnV0dG9uID0gZm9yd2FyZFJlZigoe1xyXG4gICAgdmFsdWUsXHJcbiAgICBzZWdtZW50cyxcclxuICAgIHNpbmdsZVNlbGVjdCA9ICFpc1VuZGVmaW5lZCh2YWx1ZSkgJiYgIWlzQXJyYXkodmFsdWUpLFxyXG4gICAgcmlwcGxlID0gdHJ1ZSxcclxuICAgIHRvdWNoID0gZmFsc2UsXHJcbiAgICBvbkNoYW5nZSA9IEZ1bmN0aW9uLnByb3RvdHlwZSxcclxuXHJcbiAgICBlbGVtZW50ID0gJ2RpdicsXHJcbiAgICBjb21wb25lbnQ6IEVsZW1lbnQgPSBlbGVtZW50LFxyXG4gICAgY2xhc3NOYW1lLFxyXG4gICAgY2hpbGRyZW4gPSBzZWdtZW50cz8ubWFwKHNlZ21lbnQgPT4gY3JlYXRlKFNlZ21lbnRlZEJ1dHRvblNlZ21lbnQsIHNlZ21lbnQpKSxcclxuICAgIC4uLnByb3BzXHJcbn0sIHJlZikgPT4ge1xyXG4gICAgY29uc3QgaGFuZGxlQ2xpY2sgPSB1c2VDYWxsYmFjayhldmVudCA9PiB7XHJcbiAgICAgICAgY29uc3Qgc2VnbWVudFZhbHVlID0gZXZlbnQuY3VycmVudFRhcmdldC52YWx1ZTtcclxuICAgICAgICBjb25zdCBuZXdWYWx1ZSA9IHNpbmdsZVNlbGVjdCA/IHNlZ21lbnRWYWx1ZSA6XHJcbiAgICAgICAgICAgICh2YWx1ZS5pbmNsdWRlcyhzZWdtZW50VmFsdWUpID9cclxuICAgICAgICAgICAgICAgIHZhbHVlLmZpbHRlcih2ID0+IHYgIT09IHNlZ21lbnRWYWx1ZSkgOlxyXG4gICAgICAgICAgICAgICAgdmFsdWUuY29uY2F0KHNlZ21lbnRWYWx1ZSlcclxuICAgICAgICAgICAgKTtcclxuXHJcbiAgICAgICAgb25DaGFuZ2UobmV3VmFsdWUpO1xyXG4gICAgfSwgW3ZhbHVlLCBzaW5nbGVTZWxlY3QsIG9uQ2hhbmdlXSk7XHJcblxyXG4gICAgY29uc3QgY2xhc3NOYW1lcyA9IGNsYXNzbmFtZXMoY3NzQ2xhc3Nlcy5ST09ULCB7XHJcbiAgICAgICAgW2Nzc0NsYXNzZXMuU0lOR0xFX1NFTEVDVF06IHNpbmdsZVNlbGVjdFxyXG4gICAgfSwgY2xhc3NOYW1lKTtcclxuXHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAgIDxFbGVtZW50XHJcbiAgICAgICAgICAgIHJlZj17cmVmfVxyXG4gICAgICAgICAgICBjbGFzc05hbWU9e2NsYXNzTmFtZXN9XHJcbiAgICAgICAgICAgIHJvbGU9e3NpbmdsZVNlbGVjdCA/ICdyYWRpb2dyb3VwJyA6ICdncm91cCd9XHJcbiAgICAgICAgICAgIHsuLi5wcm9wc31cclxuICAgICAgICA+XHJcbiAgICAgICAgICAgIHtpc1VuZGVmaW5lZCh2YWx1ZSkgPyBjaGlsZHJlbiA6XHJcbiAgICAgICAgICAgICAgICBDaGlsZHJlbi5tYXAoY2hpbGRyZW4sIHNlZ21lbnQgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGFyaWFQcm9wID0gc2luZ2xlU2VsZWN0ID8gJ2FyaWEtY2hlY2tlZCcgOiAnYXJpYS1wcmVzc2VkJztcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBzZWxlY3RlZCA9IHNpbmdsZVNlbGVjdCA/XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID09PSBzZWdtZW50LnByb3BzLnZhbHVlIDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUuaW5jbHVkZXMoc2VnbWVudC5wcm9wcy52YWx1ZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjbG9uZShzZWdtZW50LCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJpcHBsZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgdG91Y2gsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdGVkLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICByb2xlOiBzaW5nbGVTZWxlY3QgPyAncmFkaW8nIDogdW5kZWZpbmVkLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBbYXJpYVByb3BdOiBzZWxlY3RlZCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgb25DbGlja0NhcHR1cmU6IGhhbmRsZUNsaWNrXHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgPC9FbGVtZW50PlxyXG4gICAgKTtcclxufSk7XHJcblxyXG5TZWdtZW50ZWRCdXR0b24uZGlzcGxheU5hbWUgPSAnTURDU2VnbWVudGVkQnV0dG9uJztcclxuXHJcblNlZ21lbnRlZEJ1dHRvbi5wcm9wVHlwZXMgPSB7XHJcbiAgICB2YWx1ZTogUHJvcFR5cGVzLmFueSxcclxuICAgIHNlZ21lbnRzOiBQcm9wVHlwZXMuYXJyYXlPZihQcm9wVHlwZXMub25lT2ZUeXBlKFtcclxuICAgICAgICBQcm9wVHlwZXMub2JqZWN0LFxyXG4gICAgICAgIFByb3BUeXBlcy5lbGVtZW50XHJcbiAgICBdKSksXHJcbiAgICBzaW5nbGVTZWxlY3Q6IFByb3BUeXBlcy5ib29sLFxyXG4gICAgcmlwcGxlOiBQcm9wVHlwZXMuYm9vbCxcclxuICAgIHRvdWNoOiBQcm9wVHlwZXMuYm9vbCxcclxuICAgIG9uQ2hhbmdlOiBQcm9wVHlwZXMuZnVuY1xyXG59O1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgU2VnbWVudGVkQnV0dG9uOyIsImltcG9ydCBTZWdtZW50ZWRCdXR0b24gZnJvbSAnLi9TZWdtZW50ZWRCdXR0b24nO1xyXG5pbXBvcnQgU2VnbWVudGVkQnV0dG9uU2VnbWVudCBmcm9tICcuL1NlZ21lbnRlZEJ1dHRvblNlZ21lbnQnO1xyXG5cclxuU2VnbWVudGVkQnV0dG9uLlNlZ21lbnQgPSBTZWdtZW50ZWRCdXR0b25TZWdtZW50O1xyXG5cclxuZXhwb3J0IHtcclxuICAgIFNlZ21lbnRlZEJ1dHRvbiBhcyBkZWZhdWx0LFxyXG4gICAgU2VnbWVudGVkQnV0dG9uU2VnbWVudFxyXG59OyIsImV4cG9ydCBjb25zdCBudW1iZXJzID0ge1xyXG4gICAgQU5JTUFUSU9OX0VOVEVSX1RJTUVfTVM6IDI1MCxcclxuICAgIEFOSU1BVElPTl9FWElUX1RJTUVfTVM6IDIwMFxyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IGNzc0NsYXNzZXMgPSB7XHJcbiAgICBST09UOiAnbWRjLXNpZGUtc2hlZXQnLFxyXG4gICAgRElTTUlTU0lCTEU6ICdtZGMtc2lkZS1zaGVldC0tZGlzbWlzc2libGUnLFxyXG4gICAgTU9EQUw6ICdtZGMtc2lkZS1zaGVldC0tbW9kYWwnLFxyXG4gICAgT1BFTjogJ21kYy1zaWRlLXNoZWV0LS1vcGVuJyxcclxuICAgIEFOSU1BVEU6ICdtZGMtc2lkZS1zaGVldC0tYW5pbWF0ZScsXHJcbiAgICBPUEVOSU5HOiAnbWRjLXNpZGUtc2hlZXQtLW9wZW5pbmcnLFxyXG4gICAgQ0xPU0lORzogJ21kYy1zaWRlLXNoZWV0LS1jbG9zaW5nJyxcclxuXHJcbiAgICBDT05URU5UOiAnbWRjLXNpZGUtc2hlZXRfX2NvbnRlbnQnLFxyXG4gICAgSEVBREVSOiAnbWRjLXNpZGUtc2hlZXRfX2hlYWRlcicsXHJcbiAgICBUSVRMRTogJ21kYy1zaWRlLXNoZWV0X190aXRsZScsXHJcbiAgICBDTE9TRV9CVVRUT046ICdtZGMtc2lkZS1zaGVldF9fY2xvc2UtYnV0dG9uJyxcclxuXHJcbiAgICBBUFBfQ09OVEVOVDogJ21kYy1zaWRlLXNoZWV0LWFwcC1jb250ZW50JyxcclxuICAgIFNDUklNOiAnbWRjLXNpZGUtc2hlZXQtc2NyaW0nLFxyXG59OyIsImltcG9ydCB7IGZvcndhcmRSZWYgfSBmcm9tICdyZWFjdCc7XHJcblxyXG5pbXBvcnQgeyBDbG9uZSB9IGZyb20gJy4uL2NvbXBvbmVudCc7XHJcbmltcG9ydCBJY29uQnV0dG9uIGZyb20gJy4uL2ljb24tYnV0dG9uJztcclxuXHJcbmltcG9ydCB7IGNzc0NsYXNzZXMgfSBmcm9tICcuL2NvbnN0YW50cyc7XHJcblxyXG5jb25zdCBTaWRlU2hlZXRIZWFkZXIgPSBmb3J3YXJkUmVmKCh7XHJcbiAgICB0aXRsZSxcclxuICAgIGNsb3NlSWNvbixcclxuICAgIG9uQ2xvc2UsXHJcblxyXG4gICAgZWxlbWVudDogRWxlbWVudCA9ICdoZWFkZXInLFxyXG4gICAgLi4ucHJvcHNcclxufSwgcmVmKSA9PiB7XHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAgIDxFbGVtZW50IHJlZj17cmVmfSBjbGFzc05hbWU9e2Nzc0NsYXNzZXMuSEVBREVSfSB7Li4ucHJvcHN9PlxyXG4gICAgICAgICAgICB7dGl0bGUgJiZcclxuICAgICAgICAgICAgICAgIDxDbG9uZVxyXG4gICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudD17dGl0bGV9XHJcbiAgICAgICAgICAgICAgICAgICAgZmFsbGJhY2s9XCJoM1wiXHJcbiAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPXtjc3NDbGFzc2VzLlRJVExFfVxyXG4gICAgICAgICAgICAgICAgLz5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAge2Nsb3NlSWNvbiAmJlxyXG4gICAgICAgICAgICAgICAgPENsb25lXHJcbiAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50PXtjbG9zZUljb259XHJcbiAgICAgICAgICAgICAgICAgICAgZmFsbGJhY2s9e0ljb25CdXR0b259XHJcbiAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPXtjc3NDbGFzc2VzLkNMT1NFX0JVVFRPTn1cclxuICAgICAgICAgICAgICAgICAgICBvbkNsaWNrPXtvbkNsb3NlfVxyXG4gICAgICAgICAgICAgICAgLz5cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIDwvRWxlbWVudD5cclxuICAgICk7XHJcbn0pO1xyXG5cclxuU2lkZVNoZWV0SGVhZGVyLmRpc3BsYXlOYW1lID0gJ01EQ1NpZGVTaGVldEhlYWRlcic7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBTaWRlU2hlZXRIZWFkZXI7IiwiaW1wb3J0IHsgZm9yd2FyZFJlZiB9IGZyb20gJ3JlYWN0JztcclxuXHJcbmltcG9ydCB7IGNzc0NsYXNzZXMgfSBmcm9tICcuL2NvbnN0YW50cyc7XHJcblxyXG5jb25zdCBTaWRlU2hlZXRDb250ZW50ID0gZm9yd2FyZFJlZigoeyBlbGVtZW50OiBFbGVtZW50ID0gJ2RpdicsIC4uLnByb3BzIH0sIHJlZikgPT4ge1xyXG4gICAgcmV0dXJuIChcclxuICAgICAgICA8RWxlbWVudCByZWY9e3JlZn0gY2xhc3NOYW1lPXtjc3NDbGFzc2VzLkNPTlRFTlR9IHsuLi5wcm9wc30gLz5cclxuICAgICk7XHJcbn0pO1xyXG5cclxuU2lkZVNoZWV0Q29udGVudC5kaXNwbGF5TmFtZSA9ICdNRENTaWRlU2hlZXRDb250ZW50JztcclxuXHJcbmV4cG9ydCBkZWZhdWx0IFNpZGVTaGVldENvbnRlbnQ7IiwiaW1wb3J0IHsgZm9yd2FyZFJlZiwgdXNlUmVmLCB1c2VJbXBlcmF0aXZlSGFuZGxlLCB1c2VFZmZlY3QgfSBmcm9tICdyZWFjdCc7XHJcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XHJcbmltcG9ydCBjbGFzc25hbWVzIGZyb20gJ2NsYXNzbmFtZXMnO1xyXG5cclxuaW1wb3J0IExheWVyIGZyb20gJy4uL2xheWVyJztcclxuXHJcbmltcG9ydCB7IG51bWJlcnMsIGNzc0NsYXNzZXMgfSBmcm9tICcuL2NvbnN0YW50cyc7XHJcbmltcG9ydCBTaWRlU2hlZXRIZWFkZXIgZnJvbSAnLi9TaWRlU2hlZXRIZWFkZXInO1xyXG5pbXBvcnQgU2lkZVNoZWV0Q29udGVudCBmcm9tICcuL1NpZGVTaGVldENvbnRlbnQnO1xyXG5cclxuY29uc3QgU2lkZVNoZWV0ID0gZm9yd2FyZFJlZigoe1xyXG4gICAgdGl0bGUsXHJcbiAgICBjb250ZW50LFxyXG4gICAgb3BlbiA9IGZhbHNlLFxyXG4gICAgYXBwZWFyID0gZmFsc2UsXHJcbiAgICBkaXNtaXNzaWJsZSA9IGZhbHNlLFxyXG4gICAgbW9kYWwgPSBmYWxzZSxcclxuICAgIGNsb3NlSWNvbiA9IGRpc21pc3NpYmxlICYmICdjbG9zZScsXHJcbiAgICBhcHBDb250ZW50U2VsZWN0b3IsXHJcbiAgICBvbkNsb3NlID0gRnVuY3Rpb24ucHJvdG90eXBlLFxyXG5cclxuICAgIGVsZW1lbnQgPSAnYXNpZGUnLFxyXG4gICAgY29tcG9uZW50OiBFbGVtZW50ID0gZWxlbWVudCxcclxuICAgIGNsYXNzTmFtZSxcclxuICAgIGNoaWxkcmVuLFxyXG4gICAgLi4ucHJvcHNcclxufSwgcmVmKSA9PiB7XHJcbiAgICBjb25zdCByb290UmVmID0gdXNlUmVmKCk7XHJcblxyXG4gICAgdXNlSW1wZXJhdGl2ZUhhbmRsZShyZWYsICgpID0+IHJvb3RSZWYuY3VycmVudCk7XHJcblxyXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgICAgICBpZiAoIWRpc21pc3NpYmxlKSByZXR1cm47XHJcblxyXG4gICAgICAgIGNvbnN0IGFwcENvbnRlbnRFbGVtZW50ID0gYXBwQ29udGVudFNlbGVjdG9yID9cclxuICAgICAgICAgICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvcihhcHBDb250ZW50U2VsZWN0b3IpIDpcclxuICAgICAgICAgICAgcm9vdFJlZi5jdXJyZW50Lm5leHRFbGVtZW50U2libGluZztcclxuXHJcbiAgICAgICAgYXBwQ29udGVudEVsZW1lbnQ/LmNsYXNzTGlzdC5hZGQoY3NzQ2xhc3Nlcy5BUFBfQ09OVEVOVCk7XHJcblxyXG4gICAgICAgIHJldHVybiAoKSA9PiB7XHJcbiAgICAgICAgICAgIGFwcENvbnRlbnRFbGVtZW50Py5jbGFzc0xpc3QucmVtb3ZlKGNzc0NsYXNzZXMuQVBQX0NPTlRFTlQpO1xyXG4gICAgICAgIH07XHJcbiAgICB9LCBbZGlzbWlzc2libGUsIGFwcENvbnRlbnRTZWxlY3Rvcl0pO1xyXG5cclxuICAgIHVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICAgICAgaWYgKCFtb2RhbCkgcmV0dXJuO1xyXG5cclxuICAgICAgICBmdW5jdGlvbiBoYW5kbGVEb2N1bWVudEtleURvd24oZXZlbnQpIHtcclxuICAgICAgICAgICAgaWYgKGV2ZW50LmtleSAmJiBldmVudC5rZXkgPT09ICdFc2NhcGUnIHx8IGV2ZW50LmtleUNvZGUgPT09IDI3KSB7XHJcbiAgICAgICAgICAgICAgICBvbkNsb3NlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCBoYW5kbGVEb2N1bWVudEtleURvd24pO1xyXG5cclxuICAgICAgICByZXR1cm4gKCkgPT4gZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIGhhbmRsZURvY3VtZW50S2V5RG93bik7XHJcbiAgICB9LCBbbW9kYWwsIG9uQ2xvc2VdKTtcclxuXHJcbiAgICBjb25zdCBjbGFzc05hbWVzID0gY2xhc3NuYW1lcyhjc3NDbGFzc2VzLlJPT1QsIHtcclxuICAgICAgICBbY3NzQ2xhc3Nlcy5ESVNNSVNTSUJMRV06IGRpc21pc3NpYmxlLFxyXG4gICAgICAgIFtjc3NDbGFzc2VzLk1PREFMXTogbW9kYWxcclxuICAgIH0sIGNsYXNzTmFtZSk7XHJcblxyXG4gICAgcmV0dXJuIChcclxuICAgICAgICA8TGF5ZXJcclxuICAgICAgICAgICAgaW49e29wZW59XHJcbiAgICAgICAgICAgIGFwcGVhcj17YXBwZWFyfVxyXG4gICAgICAgICAgICBtb2RhbD17bW9kYWx9XHJcbiAgICAgICAgICAgIGZpeGVkPXttb2RhbH1cclxuICAgICAgICAgICAgdGltZW91dD17e1xyXG4gICAgICAgICAgICAgICAgZW50ZXI6IG51bWJlcnMuQU5JTUFUSU9OX0VOVEVSX1RJTUVfTVMsXHJcbiAgICAgICAgICAgICAgICBleGl0OiBudW1iZXJzLkFOSU1BVElPTl9FWElUX1RJTUVfTVNcclxuICAgICAgICAgICAgfX1cclxuICAgICAgICAgICAgY2xhc3NOYW1lcz17e1xyXG4gICAgICAgICAgICAgICAgYXBwZWFyOiBjc3NDbGFzc2VzLk9QRU4sXHJcbiAgICAgICAgICAgICAgICBlbnRlcjogYCR7Y3NzQ2xhc3Nlcy5PUEVOfSAke2Nzc0NsYXNzZXMuQU5JTUFURX1gLFxyXG4gICAgICAgICAgICAgICAgZW50ZXJBY3RpdmU6IGAke2Nzc0NsYXNzZXMuT1BFTn0gJHtjc3NDbGFzc2VzLk9QRU5JTkd9YCxcclxuICAgICAgICAgICAgICAgIGVudGVyRG9uZTogY3NzQ2xhc3Nlcy5PUEVOLFxyXG4gICAgICAgICAgICAgICAgZXhpdDogYCR7Y3NzQ2xhc3Nlcy5PUEVOfSAke2Nzc0NsYXNzZXMuQ0xPU0lOR31gLFxyXG4gICAgICAgICAgICAgICAgZXhpdEFjdGl2ZTogY3NzQ2xhc3Nlcy5DTE9TSU5HXHJcbiAgICAgICAgICAgIH19XHJcbiAgICAgICAgICAgIG1vdW50T25FbnRlcj17bW9kYWx9XHJcbiAgICAgICAgICAgIHVubW91bnRPbkV4aXQ9e21vZGFsfVxyXG4gICAgICAgID5cclxuICAgICAgICAgICAgPD5cclxuICAgICAgICAgICAgICAgIDxFbGVtZW50XHJcbiAgICAgICAgICAgICAgICAgICAgcmVmPXtyb290UmVmfVxyXG4gICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT17Y2xhc3NOYW1lc31cclxuICAgICAgICAgICAgICAgICAgICB7Li4ucHJvcHN9XHJcbiAgICAgICAgICAgICAgICA+XHJcbiAgICAgICAgICAgICAgICAgICAgeyh0aXRsZSB8fCBkaXNtaXNzaWJsZSkgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgPFNpZGVTaGVldEhlYWRlclxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGU9e3RpdGxlfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb25DbG9zZT17b25DbG9zZX1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsb3NlSWNvbj17Y2xvc2VJY29ufVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvPlxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAge2NvbnRlbnQgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgPFNpZGVTaGVldENvbnRlbnQ+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7Y29udGVudH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgPC9TaWRlU2hlZXRDb250ZW50PlxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAge2NoaWxkcmVufVxyXG4gICAgICAgICAgICAgICAgPC9FbGVtZW50PlxyXG5cclxuICAgICAgICAgICAgICAgIHttb2RhbCAmJlxyXG4gICAgICAgICAgICAgICAgICAgIDxkaXZcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPXtjc3NDbGFzc2VzLlNDUklNfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBvbkNsaWNrPXtvbkNsb3NlfVxyXG4gICAgICAgICAgICAgICAgICAgIC8+XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIDwvPlxyXG4gICAgICAgIDwvTGF5ZXI+XHJcbiAgICApO1xyXG59KTtcclxuXHJcblNpZGVTaGVldC5kaXNwbGF5TmFtZSA9ICdNRENTaWRlU2hlZXQnO1xyXG5cclxuU2lkZVNoZWV0LnByb3BUeXBlcyA9IHtcclxuICAgIHRpdGxlOiBQcm9wVHlwZXMuc3RyaW5nLFxyXG4gICAgY29udGVudDogUHJvcFR5cGVzLm5vZGUsXHJcbiAgICBjbG9zZUljb246IFByb3BUeXBlcy5ub2RlLFxyXG4gICAgb3BlbjogUHJvcFR5cGVzLmJvb2wsXHJcbiAgICBhcHBlYXI6IFByb3BUeXBlcy5ib29sLFxyXG4gICAgZGlzbWlzc2libGU6IFByb3BUeXBlcy5ib29sLFxyXG4gICAgbW9kYWw6IFByb3BUeXBlcy5ib29sLFxyXG4gICAgYXBwQ29udGVudFNlbGVjdG9yOiBQcm9wVHlwZXMuc3RyaW5nLFxyXG4gICAgb25DbG9zZTogUHJvcFR5cGVzLmZ1bmNcclxufTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IFNpZGVTaGVldDsiLCJpbXBvcnQgeyBmb3J3YXJkUmVmIH0gZnJvbSAncmVhY3QnO1xyXG5pbXBvcnQgY2xhc3NuYW1lcyBmcm9tICdjbGFzc25hbWVzJztcclxuXHJcbmltcG9ydCB7IGNzc0NsYXNzZXMgfSBmcm9tICcuL2NvbnN0YW50cyc7XHJcblxyXG5jb25zdCBTaWRlU2hlZXRBcHBDb250ZW50ID0gZm9yd2FyZFJlZigoeyBlbGVtZW50OiBFbGVtZW50ID0gJ2RpdicsIGNsYXNzTmFtZSwgLi4ucHJvcHMgfSwgcmVmKSA9PiB7XHJcbiAgICBjb25zdCBjbGFzc05hbWVzID0gY2xhc3NuYW1lcyhjc3NDbGFzc2VzLkFQUF9DT05URU5ULCBjbGFzc05hbWUpO1xyXG5cclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgPEVsZW1lbnQgcmVmPXtyZWZ9IGNsYXNzTmFtZT17Y2xhc3NOYW1lc30gey4uLnByb3BzfSAvPlxyXG4gICAgKTtcclxufSk7XHJcblxyXG5TaWRlU2hlZXRBcHBDb250ZW50LmRpc3BsYXlOYW1lID0gJ01EQ1NpZGVTaGVldEFwcENvbnRlbnQnO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgU2lkZVNoZWV0QXBwQ29udGVudDsiLCJpbXBvcnQgU2lkZVNoZWV0IGZyb20gJy4vU2lkZVNoZWV0JztcclxuaW1wb3J0IFNpZGVTaGVldEhlYWRlciBmcm9tICcuL1NpZGVTaGVldEhlYWRlcic7XHJcbmltcG9ydCBTaWRlU2hlZXRDb250ZW50IGZyb20gJy4vU2lkZVNoZWV0Q29udGVudCc7XHJcbmltcG9ydCBTaWRlU2hlZXRBcHBDb250ZW50IGZyb20gJy4vU2lkZVNoZWV0QXBwQ29udGVudCc7XHJcblxyXG5TaWRlU2hlZXQuSGVhZGVyID0gU2lkZVNoZWV0SGVhZGVyO1xyXG5TaWRlU2hlZXQuQ29udGVudCA9IFNpZGVTaGVldENvbnRlbnQ7XHJcblNpZGVTaGVldC5BcHBDb250ZW50ID0gU2lkZVNoZWV0QXBwQ29udGVudDtcclxuXHJcbmV4cG9ydCB7XHJcbiAgICBTaWRlU2hlZXQgYXMgZGVmYXVsdCxcclxuICAgIFNpZGVTaGVldEhlYWRlcixcclxuICAgIFNpZGVTaGVldENvbnRlbnQsXHJcbiAgICBTaWRlU2hlZXRBcHBDb250ZW50XHJcbn07IiwiZXhwb3J0IGNvbnN0IG51bWJlcnMgPSB7XHJcbiAgICBUSFVNQl9XSURUSDogNDhcclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCBjc3NDbGFzc2VzID0ge1xyXG4gICAgUk9PVDogJ21kYy1zbGlkZXInLFxyXG4gICAgUkFOR0U6ICdtZGMtc2xpZGVyLS1yYW5nZScsXHJcbiAgICBESVNDUkVURTogJ21kYy1zbGlkZXItLWRpc2NyZXRlJyxcclxuICAgIERJU0FCTEVEOiAnbWRjLXNsaWRlci0tZGlzYWJsZWQnLFxyXG5cclxuICAgIElOUFVUOiAnbWRjLXNsaWRlcl9faW5wdXQnLFxyXG5cclxuICAgIFRSQUNLOiAnbWRjLXNsaWRlcl9fdHJhY2snLFxyXG4gICAgVFJBQ0tfSU5BQ1RJVkU6ICdtZGMtc2xpZGVyX190cmFjay0taW5hY3RpdmUnLFxyXG4gICAgVFJBQ0tfQUNUSVZFOiAnbWRjLXNsaWRlcl9fdHJhY2stLWFjdGl2ZScsXHJcbiAgICBUUkFDS19BQ1RJVkVfRklMTDogJ21kYy1zbGlkZXJfX3RyYWNrLS1hY3RpdmVfZmlsbCcsXHJcblxyXG4gICAgVElDS19NQVJLUzogJ21kYy1zbGlkZXJfX3RpY2stbWFya3MnLFxyXG4gICAgVElDS19NQVJLX0FDVElWRTogJ21kYy1zbGlkZXJfX3RpY2stbWFyay0tYWN0aXZlJyxcclxuICAgIFRJQ0tfTUFSS19JTkFDVElWRTogJ21kYy1zbGlkZXJfX3RpY2stbWFyay0taW5hY3RpdmUnLFxyXG5cclxuICAgIFRIVU1COiAnbWRjLXNsaWRlcl9fdGh1bWInLFxyXG4gICAgVEhVTUJfVE9QOiAnbWRjLXNsaWRlcl9fdGh1bWItLXRvcCcsXHJcbiAgICBUSFVNQl9GT0NVU0VEOiAnbWRjLXNsaWRlcl9fdGh1bWItLWZvY3VzZWQnLFxyXG4gICAgVEhVTUJfV0lUSF9JTkRJQ0FUT1I6ICdtZGMtc2xpZGVyX190aHVtYi0td2l0aC1pbmRpY2F0b3InLFxyXG4gICAgVEhVTUJfS05PQjogJ21kYy1zbGlkZXJfX3RodW1iLWtub2InLFxyXG5cclxuICAgIFZBTFVFX0lORElDQVRPUl9DT05UQUlORVI6ICdtZGMtc2xpZGVyX192YWx1ZS1pbmRpY2F0b3ItY29udGFpbmVyJyxcclxuICAgIFZBTFVFX0lORElDQVRPUjogJ21kYy1zbGlkZXJfX3ZhbHVlLWluZGljYXRvcicsXHJcbiAgICBWQUxVRV9JTkRJQ0FUT1JfVEVYVDogJ21kYy1zbGlkZXJfX3ZhbHVlLWluZGljYXRvci10ZXh0J1xyXG59OyIsImltcG9ydCB7IEtleSB9IGZyb20gJy4uL2NvbnN0YW50cyc7XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gZ2V0VmFsdWVGb3JFdmVudEtleShldmVudEtleSwgdmFsdWUsIG1pbiwgbWF4LCBzdGVwKSB7XHJcbiAgICBjb25zdCBkZWx0YSA9IE51bWJlcihzdGVwKSB8fCAobWF4IC0gbWluKSAvIDEwMDtcclxuXHJcbiAgICBzd2l0Y2ggKGV2ZW50S2V5KSB7XHJcbiAgICAgICAgY2FzZSBLZXkuQVJST1dfTEVGVDpcclxuICAgICAgICBjYXNlIEtleS5BUlJPV19ET1dOOlxyXG4gICAgICAgICAgICByZXR1cm4gdmFsdWUgLSBkZWx0YTtcclxuXHJcbiAgICAgICAgY2FzZSBLZXkuQVJST1dfUklHSFQ6XHJcbiAgICAgICAgY2FzZSBLZXkuQVJST1dfVVA6XHJcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZSArIGRlbHRhO1xyXG5cclxuICAgICAgICBjYXNlIEtleS5IT01FOlxyXG4gICAgICAgICAgICByZXR1cm4gbWluO1xyXG5cclxuICAgICAgICBjYXNlIEtleS5FTkQ6XHJcbiAgICAgICAgICAgIHJldHVybiBtYXg7XHJcblxyXG4gICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgIHJldHVybiBOYU47XHJcbiAgICB9XHJcbn0iLCJpbXBvcnQgeyBmb3J3YXJkUmVmIH0gZnJvbSAncmVhY3QnO1xyXG5cclxuaW1wb3J0IHsgY3NzQ2xhc3NlcyB9IGZyb20gJy4vY29uc3RhbnRzJztcclxuXHJcbmNvbnN0IElucHV0ID0gZm9yd2FyZFJlZigoe1xyXG4gICAgdmFsdWUsXHJcbiAgICAuLi5wcm9wc1xyXG59LCByZWYpID0+IHtcclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgPGlucHV0XHJcbiAgICAgICAgICAgIHJlZj17cmVmfVxyXG4gICAgICAgICAgICBjbGFzc05hbWU9e2Nzc0NsYXNzZXMuSU5QVVR9XHJcbiAgICAgICAgICAgIHR5cGU9XCJyYW5nZVwiXHJcbiAgICAgICAgICAgIHZhbHVlPXtNYXRoLnJvdW5kKHZhbHVlKX1cclxuICAgICAgICAgICAgb25DaGFuZ2U9e0Z1bmN0aW9uLnByb3RvdHlwZX1cclxuICAgICAgICAgICAgey4uLnByb3BzfVxyXG4gICAgICAgIC8+XHJcbiAgICApO1xyXG59KTtcclxuXHJcbklucHV0LmRpc3BsYXlOYW1lID0gJ01EQ1NsaWRlcklucHV0JztcclxuXHJcbmV4cG9ydCBkZWZhdWx0IElucHV0OyIsImltcG9ydCBjbGFzc25hbWVzIGZyb20gJ2NsYXNzbmFtZXMnO1xyXG5cclxuaW1wb3J0IHsgY3NzQ2xhc3NlcyB9IGZyb20gJy4vY29uc3RhbnRzJztcclxuXHJcbmNvbnN0IFRpY2tNYXJrcyA9ICh7XHJcbiAgICB2YWx1ZSxcclxuICAgIG1heCxcclxuICAgIHN0ZXAgPSAxXHJcbn0pID0+IHtcclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgPGRpdiBjbGFzc05hbWU9e2Nzc0NsYXNzZXMuVElDS19NQVJLU30+XHJcbiAgICAgICAgICAgIHtBcnJheS5mcm9tKG5ldyBBcnJheShtYXggLyBzdGVwICsgMSkpXHJcbiAgICAgICAgICAgICAgICAubWFwKChfLCBpKSA9PiBpICogc3RlcClcclxuICAgICAgICAgICAgICAgIC5tYXAoKHRpY2tWYWx1ZSwgaW5kZXgpID0+XHJcbiAgICAgICAgICAgICAgICAgICAgPGRpdlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBrZXk9e2luZGV4fVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU9e1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3NuYW1lcyh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW2Nzc0NsYXNzZXMuVElDS19NQVJLX0FDVElWRV06IHRpY2tWYWx1ZSA8PSB2YWx1ZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbY3NzQ2xhc3Nlcy5USUNLX01BUktfSU5BQ1RJVkVdOiB0aWNrVmFsdWUgPiB2YWx1ZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIC8+XHJcbiAgICAgICAgICAgICAgICApXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICA8L2Rpdj5cclxuICAgICk7XHJcbn07XHJcblxyXG5UaWNrTWFya3MuZGlzcGxheU5hbWUgPSAnTURDU2xpZGVyVGlja01hcmtzJztcclxuXHJcbmV4cG9ydCBkZWZhdWx0IFRpY2tNYXJrczsiLCJpbXBvcnQgeyBmb3J3YXJkUmVmIH0gZnJvbSAncmVhY3QnO1xyXG5cclxuaW1wb3J0IHsgY3NzQ2xhc3NlcyB9IGZyb20gJy4vY29uc3RhbnRzJztcclxuaW1wb3J0IFRpY2tNYXJrcyBmcm9tICcuL1RpY2tNYXJrcyc7XHJcblxyXG5jb25zdCBUcmFjayA9IGZvcndhcmRSZWYoKHtcclxuICAgIHZhbHVlLFxyXG4gICAgbWluLFxyXG4gICAgbWF4LFxyXG4gICAgc3RlcCxcclxuICAgIGRpc2NyZXRlLFxyXG4gICAgdGlja01hcmtzXHJcbn0sIHJlZikgPT4ge1xyXG4gICAgY29uc3Qgc3R5bGUgPSB7XHJcbiAgICAgICAgdHJhbnNmb3JtOiBgc2NhbGVYKCR7KHZhbHVlIC0gbWluKSAvIChtYXggLSBtaW4pfSlgXHJcbiAgICB9O1xyXG5cclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgPGRpdiByZWY9e3JlZn0gY2xhc3NOYW1lPXtjc3NDbGFzc2VzLlRSQUNLfT5cclxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9e2Nzc0NsYXNzZXMuVFJBQ0tfSU5BQ1RJVkV9IC8+XHJcblxyXG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17Y3NzQ2xhc3Nlcy5UUkFDS19BQ1RJVkV9PlxyXG4gICAgICAgICAgICAgICAgPGRpdlxyXG4gICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT17Y3NzQ2xhc3Nlcy5UUkFDS19BQ1RJVkVfRklMTH1cclxuICAgICAgICAgICAgICAgICAgICBzdHlsZT17c3R5bGV9XHJcbiAgICAgICAgICAgICAgICAvPlxyXG4gICAgICAgICAgICA8L2Rpdj5cclxuXHJcbiAgICAgICAgICAgIHtkaXNjcmV0ZSAmJiB0aWNrTWFya3MgJiZcclxuICAgICAgICAgICAgICAgIDxUaWNrTWFya3NcclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZT17dmFsdWV9XHJcbiAgICAgICAgICAgICAgICAgICAgbWF4PXttYXh9XHJcbiAgICAgICAgICAgICAgICAgICAgc3RlcD17c3RlcH1cclxuICAgICAgICAgICAgICAgIC8+XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICA8L2Rpdj5cclxuICAgICk7XHJcbn0pO1xyXG5cclxuVHJhY2suZGlzcGxheU5hbWUgPSAnTURDU2xpZGVyVHJhY2snO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgVHJhY2s7IiwiaW1wb3J0IHsgZm9yd2FyZFJlZiwgdXNlU3RhdGUsIHVzZUNhbGxiYWNrIH0gZnJvbSAncmVhY3QnO1xyXG5pbXBvcnQgY2xhc3NuYW1lcyBmcm9tICdjbGFzc25hbWVzJztcclxuXHJcbmltcG9ydCB7IG51bWJlcnMsIGNzc0NsYXNzZXMgfSBmcm9tICcuL2NvbnN0YW50cyc7XHJcblxyXG5jb25zdCBUaHVtYiA9IGZvcndhcmRSZWYoKHtcclxuICAgIHZhbHVlLFxyXG4gICAgbWluLFxyXG4gICAgbWF4LFxyXG4gICAgZGlzY3JldGUsXHJcbiAgICBkaXNhYmxlZCxcclxuICAgIG9uU3RhcnRJbnRlcmFjdGlvbixcclxuICAgIG9uRW5kSW50ZXJhY3Rpb24sXHJcbiAgICAuLi5wcm9wc1xyXG59LCByZWYpID0+IHtcclxuICAgIGNvbnN0IFtmb2N1c2VkLCBzZXRGb2N1c2VkXSA9IHVzZVN0YXRlKGZhbHNlKTtcclxuXHJcbiAgICBjb25zdCBoYW5kbGVGb2N1cyA9IHVzZUNhbGxiYWNrKCgpID0+IHtcclxuICAgICAgICBzZXRGb2N1c2VkKHRydWUpO1xyXG4gICAgfSwgW10pO1xyXG5cclxuICAgIGNvbnN0IGhhbmRsZUJsdXIgPSB1c2VDYWxsYmFjaygoKSA9PiB7XHJcbiAgICAgICAgc2V0Rm9jdXNlZChmYWxzZSk7XHJcbiAgICB9LCBbXSk7XHJcblxyXG4gICAgY29uc3QgY2xhc3NOYW1lcyA9IGNsYXNzbmFtZXMoY3NzQ2xhc3Nlcy5USFVNQiwge1xyXG4gICAgICAgIFtjc3NDbGFzc2VzLlRIVU1CX0ZPQ1VTRURdOiBmb2N1c2VkLFxyXG4gICAgICAgIFtjc3NDbGFzc2VzLlRIVU1CX1dJVEhfSU5ESUNBVE9SXTogZGlzY3JldGUgJiYgZm9jdXNlZFxyXG4gICAgfSk7XHJcblxyXG4gICAgY29uc3Qgc3R5bGUgPSB7XHJcbiAgICAgICAgbGVmdDogYGNhbGMoJHsodmFsdWUgLSBtaW4pIC8gKG1heCAtIG1pbikgKiAxMDB9JSAtICR7bnVtYmVycy5USFVNQl9XSURUSCAqIDAuNX1weClgXHJcbiAgICB9O1xyXG5cclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgPGRpdlxyXG4gICAgICAgICAgICByZWY9e3JlZn1cclxuICAgICAgICAgICAgY2xhc3NOYW1lPXtjbGFzc05hbWVzfVxyXG4gICAgICAgICAgICByb2xlPVwic2xpZGVyXCJcclxuICAgICAgICAgICAgdGFiSW5kZXg9e2Rpc2FibGVkID8gJy0xJyA6ICcwJ31cclxuICAgICAgICAgICAgYXJpYS12YWx1ZW1pbj1cIjBcIlxyXG4gICAgICAgICAgICBhcmlhLXZhbHVlbWF4PVwiMTAwXCJcclxuICAgICAgICAgICAgYXJpYS12YWx1ZW5vdz1cIjUwXCJcclxuICAgICAgICAgICAgYXJpYS1kaXNhYmxlZD17ZGlzYWJsZWQgfHwgdW5kZWZpbmVkfVxyXG4gICAgICAgICAgICBzdHlsZT17c3R5bGV9XHJcbiAgICAgICAgICAgIG9uRm9jdXM9e2hhbmRsZUZvY3VzfVxyXG4gICAgICAgICAgICBvbkJsdXI9e2hhbmRsZUJsdXJ9XHJcbiAgICAgICAgICAgIG9uTW91c2VEb3duPXtvblN0YXJ0SW50ZXJhY3Rpb259XHJcbiAgICAgICAgICAgIG9uTW91c2VVcD17b25FbmRJbnRlcmFjdGlvbn1cclxuICAgICAgICAgICAgb25Ub3VjaFN0YXJ0PXtvblN0YXJ0SW50ZXJhY3Rpb259XHJcbiAgICAgICAgICAgIG9uVG91Y2hFbmQ9e29uRW5kSW50ZXJhY3Rpb259XHJcbiAgICAgICAgICAgIHsuLi5wcm9wc31cclxuICAgICAgICA+XHJcbiAgICAgICAgICAgIHtkaXNjcmV0ZSAmJlxyXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9e2Nzc0NsYXNzZXMuVkFMVUVfSU5ESUNBVE9SX0NPTlRBSU5FUn0+XHJcbiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9e2Nzc0NsYXNzZXMuVkFMVUVfSU5ESUNBVE9SfT5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3NOYW1lPXtjc3NDbGFzc2VzLlZBTFVFX0lORElDQVRPUl9URVhUfT57dmFsdWV9PC9zcGFuPlxyXG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXtjc3NDbGFzc2VzLlRIVU1CX0tOT0J9IC8+XHJcbiAgICAgICAgPC9kaXY+XHJcbiAgICApO1xyXG59KTtcclxuXHJcblRodW1iLmRpc3BsYXlOYW1lID0gJ01EQ1NsaWRlclRodW1iJztcclxuXHJcbmV4cG9ydCBkZWZhdWx0IFRodW1iOyIsImltcG9ydCB7IGZvcndhcmRSZWYsIHVzZVJlZiwgdXNlU3RhdGUsIHVzZUNhbGxiYWNrIH0gZnJvbSAncmVhY3QnO1xyXG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xyXG5pbXBvcnQgY2xhc3NuYW1lcyBmcm9tICdjbGFzc25hbWVzJztcclxuXHJcbmltcG9ydCB7IHVzZVVwZGF0ZWQgfSBmcm9tICcuLi9ob29rcyc7XHJcbmltcG9ydCB7IGdldEV2ZW50S2V5LCBnZXRQYWdlWCB9IGZyb20gJy4uL3V0aWxzJztcclxuXHJcbmltcG9ydCB7IGNzc0NsYXNzZXMgfSBmcm9tICcuL2NvbnN0YW50cyc7XHJcbmltcG9ydCB7IGdldFZhbHVlRm9yRXZlbnRLZXkgfSBmcm9tICcuL3V0aWxzJztcclxuaW1wb3J0IElucHV0IGZyb20gJy4vSW5wdXQnO1xyXG5pbXBvcnQgVHJhY2sgZnJvbSAnLi9UcmFjayc7XHJcbmltcG9ydCBUaHVtYiBmcm9tICcuL1RodW1iJztcclxuXHJcbmNvbnN0IFNsaWRlciA9IGZvcndhcmRSZWYoKHtcclxuICAgIG5hbWUsXHJcbiAgICB2YWx1ZSA9IDAsXHJcbiAgICBtaW4gPSAwLFxyXG4gICAgbWF4ID0gMTAwLFxyXG4gICAgc3RlcCxcclxuICAgIGRpc2NyZXRlID0gZmFsc2UsXHJcbiAgICBkaXNhYmxlZCA9IGZhbHNlLFxyXG4gICAgdGlja01hcmtzID0gZmFsc2UsXHJcbiAgICBvbkNoYW5nZSA9IEZ1bmN0aW9uLnByb3RvdHlwZSxcclxuXHJcbiAgICBjbGFzc05hbWUsXHJcbiAgICAuLi5wcm9wc1xyXG59LCByZWYpID0+IHtcclxuICAgIGNvbnN0IGlucHV0UmVmID0gdXNlUmVmKCk7XHJcbiAgICBjb25zdCB0cmFja1JlZiA9IHVzZVJlZigpO1xyXG5cclxuICAgIGNvbnN0IFthY3RpdmUsIHNldEFjdGl2ZV0gPSB1c2VTdGF0ZShmYWxzZSk7XHJcblxyXG4gICAgdXNlVXBkYXRlZCgoKSA9PiB7XHJcbiAgICAgICAgaWYgKGRpc2FibGVkKSByZXR1cm47XHJcblxyXG4gICAgICAgIGlmIChhY3RpdmUpIHtcclxuICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBoYW5kbGVNb3ZlKTtcclxuICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5hZGRFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCBoYW5kbGVNb3ZlKTtcclxuICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgaGFuZGxlVXApO1xyXG4gICAgICAgICAgICBkb2N1bWVudC5ib2R5LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgaGFuZGxlVXApO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgaGFuZGxlTW92ZSk7XHJcbiAgICAgICAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgaGFuZGxlTW92ZSk7XHJcbiAgICAgICAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIGhhbmRsZVVwKTtcclxuICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIGhhbmRsZVVwKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiAoKSA9PiB7XHJcbiAgICAgICAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgaGFuZGxlTW92ZSk7XHJcbiAgICAgICAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgaGFuZGxlTW92ZSk7XHJcbiAgICAgICAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIGhhbmRsZVVwKTtcclxuICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIGhhbmRsZVVwKTtcclxuICAgICAgICB9O1xyXG4gICAgfSwgW2FjdGl2ZV0pO1xyXG5cclxuICAgIGNvbnN0IHVwZGF0ZVZhbHVlID0gdXNlQ2FsbGJhY2sobmV3VmFsdWUgPT4ge1xyXG4gICAgICAgIGlmIChuZXdWYWx1ZSA8IG1pbikge1xyXG4gICAgICAgICAgICBuZXdWYWx1ZSA9IE51bWJlcihtaW4pO1xyXG4gICAgICAgIH0gZWxzZSBpZiAobmV3VmFsdWUgPiBtYXgpIHtcclxuICAgICAgICAgICAgbmV3VmFsdWUgPSBOdW1iZXIobWF4KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChzdGVwKSB7XHJcbiAgICAgICAgICAgIG5ld1ZhbHVlID0gTWF0aC5yb3VuZChuZXdWYWx1ZSAvIHN0ZXApICogc3RlcDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIG9uQ2hhbmdlKG5ld1ZhbHVlKTtcclxuICAgIH0sIFttaW4sIG1heCwgc3RlcCwgb25DaGFuZ2VdKTtcclxuXHJcbiAgICBjb25zdCBoYW5kbGVNb3ZlID0gdXNlQ2FsbGJhY2soZXZlbnQgPT4ge1xyXG4gICAgICAgIGNvbnN0IHRyYWNrQ2xpZW50UmVjdCA9IHRyYWNrUmVmLmN1cnJlbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XHJcbiAgICAgICAgY29uc3QgcGFnZVggPSBnZXRQYWdlWChldmVudCk7XHJcbiAgICAgICAgY29uc3Qgb2Zmc2V0WCA9IHBhZ2VYIC0gdHJhY2tDbGllbnRSZWN0LmxlZnQ7XHJcbiAgICAgICAgY29uc3QgcGVyY2VudCA9IG9mZnNldFggLyB0cmFja0NsaWVudFJlY3Qud2lkdGg7XHJcbiAgICAgICAgY29uc3QgdmFsdWUgPSBOdW1iZXIobWluKSArIHBlcmNlbnQgKiAobWF4IC0gbWluKTtcclxuXHJcbiAgICAgICAgdXBkYXRlVmFsdWUodmFsdWUpO1xyXG4gICAgfSwgW21pbiwgbWF4LCB1cGRhdGVWYWx1ZV0pO1xyXG5cclxuICAgIGNvbnN0IGhhbmRsZUtleURvd24gPSB1c2VDYWxsYmFjayhldmVudCA9PiB7XHJcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcclxuXHJcbiAgICAgICAgY29uc3QgdmFsdWUgPSBOdW1iZXIoaW5wdXRSZWYuY3VycmVudC52YWx1ZSk7XHJcbiAgICAgICAgY29uc3QgZXZlbnRLZXkgPSBnZXRFdmVudEtleShldmVudCk7XHJcbiAgICAgICAgY29uc3QgbmV3VmFsdWUgPSBnZXRWYWx1ZUZvckV2ZW50S2V5KGV2ZW50S2V5LCB2YWx1ZSwgbWluLCBtYXgsIHN0ZXApO1xyXG5cclxuICAgICAgICBpZiAoaXNOYU4obmV3VmFsdWUpKSByZXR1cm47XHJcblxyXG4gICAgICAgIHVwZGF0ZVZhbHVlKG5ld1ZhbHVlKTtcclxuICAgIH0sIFttaW4sIG1heCwgc3RlcCwgdXBkYXRlVmFsdWVdKTtcclxuXHJcbiAgICBjb25zdCBoYW5kbGVSb290SW50ZXJhY3Rpb24gPSB1c2VDYWxsYmFjayhldmVudCA9PiB7XHJcbiAgICAgICAgaGFuZGxlTW92ZShldmVudCk7XHJcbiAgICB9LCBbaGFuZGxlTW92ZV0pO1xyXG5cclxuICAgIGNvbnN0IGhhbmRsZVVwID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xyXG4gICAgICAgIHNldEFjdGl2ZShmYWxzZSk7XHJcbiAgICB9LCBbXSk7XHJcblxyXG4gICAgY29uc3QgaGFuZGxlVGh1bWJTdGFydEludGVyYWN0aW9uID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xyXG4gICAgICAgIHNldEFjdGl2ZSh0cnVlKTtcclxuICAgIH0sIFtdKTtcclxuXHJcbiAgICBjb25zdCBoYW5kbGVUaHVtYkVuZEludGVyYWN0aW9uID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xyXG4gICAgICAgIHNldEFjdGl2ZShmYWxzZSk7XHJcbiAgICB9LCBbXSk7XHJcblxyXG4gICAgY29uc3QgY2xhc3NOYW1lcyA9IGNsYXNzbmFtZXMoY3NzQ2xhc3Nlcy5ST09ULCB7XHJcbiAgICAgICAgW2Nzc0NsYXNzZXMuRElTQ1JFVEVdOiBkaXNjcmV0ZSxcclxuICAgICAgICBbY3NzQ2xhc3Nlcy5ESVNBQkxFRF06IGRpc2FibGVkXHJcbiAgICB9LCBjbGFzc05hbWUpO1xyXG5cclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgPGRpdlxyXG4gICAgICAgICAgICByZWY9e3JlZn1cclxuICAgICAgICAgICAgY2xhc3NOYW1lPXtjbGFzc05hbWVzfVxyXG4gICAgICAgICAgICBvbk1vdXNlRG93bj17aGFuZGxlUm9vdEludGVyYWN0aW9ufVxyXG4gICAgICAgICAgICBvblRvdWNoU3RhcnQ9e2hhbmRsZVJvb3RJbnRlcmFjdGlvbn1cclxuICAgICAgICAgICAgey4uLnByb3BzfVxyXG4gICAgICAgID5cclxuICAgICAgICAgICAgPElucHV0XHJcbiAgICAgICAgICAgICAgICByZWY9e2lucHV0UmVmfVxyXG4gICAgICAgICAgICAgICAgbmFtZT17bmFtZX1cclxuICAgICAgICAgICAgICAgIHZhbHVlPXt2YWx1ZX1cclxuICAgICAgICAgICAgICAgIG1pbj17bWlufVxyXG4gICAgICAgICAgICAgICAgbWF4PXttYXh9XHJcbiAgICAgICAgICAgICAgICBzdGVwPXtzdGVwfVxyXG4gICAgICAgICAgICAgICAgZGlzYWJsZWQ9e2Rpc2FibGVkfVxyXG4gICAgICAgICAgICAvPlxyXG5cclxuICAgICAgICAgICAgPFRyYWNrXHJcbiAgICAgICAgICAgICAgICByZWY9e3RyYWNrUmVmfVxyXG4gICAgICAgICAgICAgICAgdmFsdWU9e3ZhbHVlfVxyXG4gICAgICAgICAgICAgICAgbWluPXttaW59XHJcbiAgICAgICAgICAgICAgICBtYXg9e21heH1cclxuICAgICAgICAgICAgICAgIHN0ZXA9e3N0ZXB9XHJcbiAgICAgICAgICAgICAgICBkaXNjcmV0ZT17ZGlzY3JldGV9XHJcbiAgICAgICAgICAgICAgICB0aWNrTWFya3M9e3RpY2tNYXJrc31cclxuICAgICAgICAgICAgLz5cclxuXHJcbiAgICAgICAgICAgIDxUaHVtYlxyXG4gICAgICAgICAgICAgICAgdmFsdWU9e3ZhbHVlfVxyXG4gICAgICAgICAgICAgICAgbWluPXttaW59XHJcbiAgICAgICAgICAgICAgICBtYXg9e21heH1cclxuICAgICAgICAgICAgICAgIGRpc2NyZXRlPXtkaXNjcmV0ZX1cclxuICAgICAgICAgICAgICAgIG9uU3RhcnRJbnRlcmFjdGlvbj17aGFuZGxlVGh1bWJTdGFydEludGVyYWN0aW9ufVxyXG4gICAgICAgICAgICAgICAgb25FbmRJbnRlcmFjdGlvbj17aGFuZGxlVGh1bWJFbmRJbnRlcmFjdGlvbn1cclxuICAgICAgICAgICAgICAgIG9uS2V5RG93bj17aGFuZGxlS2V5RG93bn1cclxuICAgICAgICAgICAgLz5cclxuICAgICAgICA8L2Rpdj5cclxuICAgICk7XHJcbn0pO1xyXG5cclxuU2xpZGVyLmRpc3BsYXlOYW1lID0gJ01EQ1NsaWRlcic7XHJcblxyXG5TbGlkZXIucHJvcFR5cGVzID0ge1xyXG4gICAgdmFsdWU6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1xyXG4gICAgICAgIFByb3BUeXBlcy5udW1iZXIsXHJcbiAgICAgICAgUHJvcFR5cGVzLnN0cmluZ1xyXG4gICAgXSksXHJcbiAgICBtaW46IFByb3BUeXBlcy5vbmVPZlR5cGUoW1xyXG4gICAgICAgIFByb3BUeXBlcy5udW1iZXIsXHJcbiAgICAgICAgUHJvcFR5cGVzLnN0cmluZ1xyXG4gICAgXSksXHJcbiAgICBtYXg6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1xyXG4gICAgICAgIFByb3BUeXBlcy5udW1iZXIsXHJcbiAgICAgICAgUHJvcFR5cGVzLnN0cmluZ1xyXG4gICAgXSksXHJcbiAgICBzdGVwOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtcclxuICAgICAgICBQcm9wVHlwZXMubnVtYmVyLFxyXG4gICAgICAgIFByb3BUeXBlcy5zdHJpbmdcclxuICAgIF0pLFxyXG4gICAgZGlzY3JldGU6IFByb3BUeXBlcy5ib29sLFxyXG4gICAgZGlzYWJsZWQ6IFByb3BUeXBlcy5ib29sLFxyXG4gICAgdGlja01hcmtzOiBQcm9wVHlwZXMuYm9vbCxcclxuICAgIG9uQ2hhbmdlOiBQcm9wVHlwZXMuZnVuY1xyXG59O1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgU2xpZGVyOyIsImV4cG9ydCB7IGRlZmF1bHQgfSBmcm9tICcuL1NsaWRlcic7IiwiZXhwb3J0IGNvbnN0IG51bWJlcnMgPSB7XHJcbiAgICBERUZBVUxUX0FVVE9fRElTTUlTU19USU1FT1VUX01TOiA1MDAwLFxyXG4gICAgQU5JTUFUSU9OX09QRU5fVElNRV9NUzogMTUwLFxyXG4gICAgQU5JTUFUSU9OX0NMT1NFX1RJTUVfTVM6IDc1XHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgY3NzQ2xhc3NlcyA9IHtcclxuICAgIFJPT1Q6ICdtZGMtc25hY2tiYXInLFxyXG4gICAgTEVBRElORzogJ21kYy1zbmFja2Jhci0tbGVhZGluZycsXHJcbiAgICBTVEFDS0VEOiAnbWRjLXNuYWNrYmFyLS1zdGFja2VkJyxcclxuICAgIE9QRU5JTkc6ICdtZGMtc25hY2tiYXItLW9wZW5pbmcnLFxyXG4gICAgT1BFTjogJ21kYy1zbmFja2Jhci0tb3BlbicsXHJcbiAgICBDTE9TSU5HOiAnbWRjLXNuYWNrYmFyLS1jbG9zaW5nJyxcclxuXHJcbiAgICBTVVJGQUNFOiAnbWRjLXNuYWNrYmFyX19zdXJmYWNlJyxcclxuICAgIExBQkVMOiAnbWRjLXNuYWNrYmFyX19sYWJlbCcsXHJcbiAgICBBQ1RJT05TOiAnbWRjLXNuYWNrYmFyX19hY3Rpb25zJyxcclxuICAgIEFDVElPTjogJ21kYy1zbmFja2Jhcl9fYWN0aW9uJyxcclxuICAgIERJU01JU1M6ICdtZGMtc25hY2tiYXJfX2Rpc21pc3MnXHJcbn07IiwiaW1wb3J0IHsgZm9yd2FyZFJlZiwgdXNlUmVmLCB1c2VDYWxsYmFjayB9IGZyb20gJ3JlYWN0JztcclxuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcclxuaW1wb3J0IGNsYXNzbmFtZXMgZnJvbSAnY2xhc3NuYW1lcyc7XHJcblxyXG5pbXBvcnQgeyB1c2VVcGRhdGVkIH0gZnJvbSAnLi4vaG9va3MnO1xyXG5pbXBvcnQgeyBDbG9uZSB9IGZyb20gJy4uL2NvbXBvbmVudCc7XHJcbmltcG9ydCBMYXllciBmcm9tICcuLi9sYXllcic7XHJcbmltcG9ydCBJY29uQnV0dG9uIGZyb20gJy4uL2ljb24tYnV0dG9uJztcclxuXHJcbmltcG9ydCB7IG51bWJlcnMsIGNzc0NsYXNzZXMgfSBmcm9tICcuL2NvbnN0YW50cyc7XHJcblxyXG5jb25zdCBTbmFja2JhciA9IGZvcndhcmRSZWYoKHtcclxuICAgIGxhYmVsLFxyXG4gICAgYWN0aW9uLFxyXG4gICAgZGlzbWlzc0ljb24gPSAnY2xvc2UnLFxyXG4gICAgb3BlbiA9IGZhbHNlLFxyXG4gICAgYXBwZWFyID0gZmFsc2UsXHJcbiAgICBsZWFkaW5nID0gZmFsc2UsXHJcbiAgICBzdGFja2VkID0gZmFsc2UsXHJcbiAgICBkaXNtaXNzaWJsZSA9IHRydWUsXHJcbiAgICB0aW1lb3V0ID0gbnVtYmVycy5ERUZBVUxUX0FVVE9fRElTTUlTU19USU1FT1VUX01TLFxyXG4gICAgY2xvc2VPbkVzY2FwZSA9IHRydWUsXHJcbiAgICBvbkNsb3NlID0gRnVuY3Rpb24ucHJvdG90eXBlLFxyXG5cclxuICAgIGVsZW1lbnQ6IEVsZW1lbnQgPSAnZGl2JyxcclxuICAgIGNsYXNzTmFtZSxcclxuICAgIGNoaWxkcmVuID0gbGFiZWwsXHJcbiAgICAuLi5wcm9wc1xyXG59LCByZWYpID0+IHtcclxuICAgIGNvbnN0IHRpbWVvdXRSZWYgPSB1c2VSZWYoKTtcclxuXHJcbiAgICB1c2VVcGRhdGVkKCgpID0+IHtcclxuICAgICAgICBpZiAob3Blbikge1xyXG4gICAgICAgICAgICB0aW1lb3V0UmVmLmN1cnJlbnQgPSBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICAgICAgICAgIHRpbWVvdXRSZWYuY3VycmVudCA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICBvbkNsb3NlKCk7XHJcbiAgICAgICAgICAgIH0sIHRpbWVvdXQpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGlmICh0aW1lb3V0UmVmLmN1cnJlbnQpIHtcclxuICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0UmVmLmN1cnJlbnQpO1xyXG4gICAgICAgICAgICAgICAgdGltZW91dFJlZi5jdXJyZW50ID0gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuICgpID0+IGNsZWFyVGltZW91dCh0aW1lb3V0UmVmLmN1cnJlbnQpO1xyXG4gICAgfSwgW29wZW5dKTtcclxuXHJcbiAgICBjb25zdCBoYW5kbGVLZXlEb3duID0gdXNlQ2FsbGJhY2soZXZlbnQgPT4ge1xyXG4gICAgICAgIGlmIChjbG9zZU9uRXNjYXBlICYmIGV2ZW50LmtleSA9PT0gJ0VzY2FwZScgfHwgZXZlbnQua2V5Q29kZSA9PT0gMjcpIHtcclxuICAgICAgICAgICAgb25DbG9zZSgpO1xyXG4gICAgICAgIH1cclxuICAgIH0sIFtjbG9zZU9uRXNjYXBlLCBvbkNsb3NlXSk7XHJcblxyXG4gICAgY29uc3QgY2xhc3NOYW1lcyA9IGNsYXNzbmFtZXMoY3NzQ2xhc3Nlcy5ST09ULCB7XHJcbiAgICAgICAgW2Nzc0NsYXNzZXMuTEVBRElOR106IGxlYWRpbmcsXHJcbiAgICAgICAgW2Nzc0NsYXNzZXMuU1RBQ0tFRF06IHN0YWNrZWRcclxuICAgIH0sIGNsYXNzTmFtZSk7XHJcblxyXG4gICAgcmV0dXJuIChcclxuICAgICAgICA8TGF5ZXJcclxuICAgICAgICAgICAgbW9kYWxcclxuICAgICAgICAgICAgaW49e29wZW59XHJcbiAgICAgICAgICAgIGFwcGVhcj17YXBwZWFyfVxyXG4gICAgICAgICAgICB0aW1lb3V0PXt7XHJcbiAgICAgICAgICAgICAgICBlbnRlcjogbnVtYmVycy5BTklNQVRJT05fT1BFTl9USU1FX01TLFxyXG4gICAgICAgICAgICAgICAgZXhpdDogbnVtYmVycy5BTklNQVRJT05fQ0xPU0VfVElNRV9NU1xyXG4gICAgICAgICAgICB9fVxyXG4gICAgICAgICAgICBjbGFzc05hbWVzPXt7XHJcbiAgICAgICAgICAgICAgICBhcHBlYXI6IGNzc0NsYXNzZXMuT1BFTklORyxcclxuICAgICAgICAgICAgICAgIGFwcGVhckFjdGl2ZTogY3NzQ2xhc3Nlcy5PUEVOLFxyXG4gICAgICAgICAgICAgICAgZW50ZXI6IGNzc0NsYXNzZXMuT1BFTklORyxcclxuICAgICAgICAgICAgICAgIGVudGVyQWN0aXZlOiBjc3NDbGFzc2VzLk9QRU4sXHJcbiAgICAgICAgICAgICAgICBlbnRlckRvbmU6IGNzc0NsYXNzZXMuT1BFTixcclxuICAgICAgICAgICAgICAgIGV4aXQ6IGNzc0NsYXNzZXMuQ0xPU0lOR1xyXG4gICAgICAgICAgICB9fVxyXG4gICAgICAgICAgICBtb3VudE9uRW50ZXJcclxuICAgICAgICAgICAgdW5tb3VudE9uRXhpdFxyXG4gICAgICAgID5cclxuICAgICAgICAgICAgPEVsZW1lbnRcclxuICAgICAgICAgICAgICAgIHJlZj17cmVmfVxyXG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lPXtjbGFzc05hbWVzfVxyXG4gICAgICAgICAgICAgICAgb25LZXlEb3duPXtoYW5kbGVLZXlEb3dufVxyXG4gICAgICAgICAgICAgICAgey4uLnByb3BzfVxyXG4gICAgICAgICAgICA+XHJcbiAgICAgICAgICAgICAgICA8ZGl2XHJcbiAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPXtjc3NDbGFzc2VzLlNVUkZBQ0V9XHJcbiAgICAgICAgICAgICAgICAgICAgcm9sZT1cInN0YXR1c1wiXHJcbiAgICAgICAgICAgICAgICAgICAgYXJpYS1yZWxldmFudD1cImFkZGl0aW9uc1wiXHJcbiAgICAgICAgICAgICAgICA+XHJcbiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9e2Nzc0NsYXNzZXMuTEFCRUx9IGFyaWEtYXRvbWljPVwiZmFsc2VcIj57Y2hpbGRyZW59PC9kaXY+XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXtjc3NDbGFzc2VzLkFDVElPTlN9IGFyaWEtYXRvbWljPVwidHJ1ZVwiPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB7YWN0aW9uICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8Q2xvbmVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21wb25lbnQ9e2FjdGlvbn1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU9e2Nzc0NsYXNzZXMuQUNUSU9OfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLz5cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAge2Rpc21pc3NpYmxlICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8Q2xvbmVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21wb25lbnQ9e2Rpc21pc3NJY29ufVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZhbGxiYWNrPXtJY29uQnV0dG9ufVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT17Y3NzQ2xhc3Nlcy5ESVNNSVNTfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2xpY2s9e29uQ2xvc2V9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgPC9FbGVtZW50PlxyXG4gICAgICAgIDwvTGF5ZXI+XHJcbiAgICApO1xyXG59KTtcclxuXHJcblNuYWNrYmFyLmRpc3BsYXlOYW1lID0gJ01EQ1NuYWNrYmFyJztcclxuXHJcblNuYWNrYmFyLnByb3BUeXBlcyA9IHtcclxuICAgIGxhYmVsOiBQcm9wVHlwZXMuc3RyaW5nLFxyXG4gICAgYWN0aW9uOiBQcm9wVHlwZXMuZWxlbWVudCxcclxuICAgIGRpc21pc3NJY29uOiBQcm9wVHlwZXMubm9kZSxcclxuICAgIG9wZW46IFByb3BUeXBlcy5ib29sLFxyXG4gICAgYXBwZWFyOiBQcm9wVHlwZXMuYm9vbCxcclxuICAgIGxlYWRpbmc6IFByb3BUeXBlcy5ib29sLFxyXG4gICAgc3RhY2tlZDogUHJvcFR5cGVzLmJvb2wsXHJcbiAgICBkaXNtaXNzaWJsZTogUHJvcFR5cGVzLmJvb2wsXHJcbiAgICB0aW1lb3V0OiBQcm9wVHlwZXMubnVtYmVyLFxyXG4gICAgY2xvc2VPbkVzY2FwZTogUHJvcFR5cGVzLmJvb2wsXHJcbiAgICBvbkNsb3NlOiBQcm9wVHlwZXMuZnVuY1xyXG59O1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgU25hY2tiYXI7IiwiZXhwb3J0IHsgZGVmYXVsdCB9IGZyb20gJy4vU25hY2tiYXInOyIsImV4cG9ydCBjb25zdCBjc3NDbGFzc2VzID0ge1xyXG4gICAgUk9PVDogJ21kYy1zd2l0Y2gnLFxyXG4gICAgU0VMRUNURUQ6ICdtZGMtc3dpdGNoLS1zZWxlY3RlZCcsXHJcbiAgICBVTlNFTEVDVEVEOiAnbWRjLXN3aXRjaC0tdW5zZWxlY3RlZCcsXHJcblxyXG4gICAgVFJBQ0s6ICdtZGMtc3dpdGNoX190cmFjaycsXHJcbiAgICBIQU5ETEVfVFJBQ0s6ICdtZGMtc3dpdGNoX19oYW5kbGUtdHJhY2snLFxyXG4gICAgSEFORExFOiAnbWRjLXN3aXRjaF9faGFuZGxlJyxcclxuICAgIFNIQURPVzogJ21kYy1zd2l0Y2hfX3NoYWRvdycsXHJcbiAgICBFTEVWQVRJT05fT1ZFUkxBWTogJ21kYy1lbGV2YXRpb24tb3ZlcmxheScsXHJcbiAgICBSSVBQTEU6ICdtZGMtc3dpdGNoX19yaXBwbGUnLFxyXG4gICAgSUNPTlM6ICdtZGMtc3dpdGNoX19pY29ucycsXHJcblxyXG4gICAgSUNPTjogJ21kYy1zd2l0Y2hfX2ljb24nLFxyXG4gICAgSUNPTl9PTjogJ21kYy1zd2l0Y2hfX2ljb24tLW9uJyxcclxuICAgIElDT05fT0ZGOiAnbWRjLXN3aXRjaF9faWNvbi0tb2ZmJ1xyXG59OyIsImltcG9ydCB7IGZvcndhcmRSZWYsIHVzZUNhbGxiYWNrIH0gZnJvbSAncmVhY3QnO1xyXG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xyXG5pbXBvcnQgY2xhc3NuYW1lcyBmcm9tICdjbGFzc25hbWVzJztcclxuXHJcbmltcG9ydCB7IGNzc0NsYXNzZXMgfSBmcm9tICcuL2NvbnN0YW50cyc7XHJcblxyXG5jb25zdCBTd2l0Y2ggPSBmb3J3YXJkUmVmKCh7XHJcbiAgICBzZWxlY3RlZCA9IGZhbHNlLFxyXG4gICAgb25DaGFuZ2UgPSBGdW5jdGlvbi5wcm90b3R5cGUsXHJcblxyXG4gICAgY2xhc3NOYW1lLFxyXG4gICAgLi4ucHJvcHNcclxufSwgcmVmKSA9PiB7XHJcblxyXG4gICAgY29uc3QgaGFuZGxlQ2xpY2sgPSB1c2VDYWxsYmFjayhldmVudCA9PiB7XHJcbiAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XHJcblxyXG4gICAgICAgIG9uQ2hhbmdlKGV2ZW50LCAhc2VsZWN0ZWQsIGV2ZW50LmN1cnJlbnRUYXJnZXQpO1xyXG4gICAgfSwgW3NlbGVjdGVkLCBvbkNoYW5nZV0pO1xyXG5cclxuICAgIGNvbnN0IGNsYXNzTmFtZXMgPSBjbGFzc25hbWVzKGNzc0NsYXNzZXMuUk9PVCwge1xyXG4gICAgICAgIFtjc3NDbGFzc2VzLlNFTEVDVEVEXTogc2VsZWN0ZWQsXHJcbiAgICAgICAgW2Nzc0NsYXNzZXMuVU5TRUxFQ1RFRF06ICFzZWxlY3RlZFxyXG4gICAgfSwgY2xhc3NOYW1lKTtcclxuXHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAgIDxidXR0b25cclxuICAgICAgICAgICAgcmVmPXtyZWZ9XHJcbiAgICAgICAgICAgIHR5cGU9XCJidXR0b25cIlxyXG4gICAgICAgICAgICBjbGFzc05hbWU9e2NsYXNzTmFtZXN9XHJcbiAgICAgICAgICAgIHJvbGU9XCJzd2l0Y2hcIlxyXG4gICAgICAgICAgICBhcmlhLWNoZWNrZWQ9e3NlbGVjdGVkfVxyXG4gICAgICAgICAgICBvbkNsaWNrPXtoYW5kbGVDbGlja31cclxuICAgICAgICAgICAgey4uLnByb3BzfVxyXG4gICAgICAgID5cclxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9e2Nzc0NsYXNzZXMuVFJBQ0t9IC8+XHJcblxyXG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17Y3NzQ2xhc3Nlcy5IQU5ETEVfVFJBQ0t9PlxyXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9e2Nzc0NsYXNzZXMuSEFORExFfT5cclxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17Y3NzQ2xhc3Nlcy5TSEFET1d9PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17Y3NzQ2xhc3Nlcy5FTEVWQVRJT05fT1ZFUkxBWX0gLz5cclxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9e2Nzc0NsYXNzZXMuUklQUExFfSAvPlxyXG5cclxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17Y3NzQ2xhc3Nlcy5JQ09OU30+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxzdmcgY2xhc3NOYW1lPXtgJHtjc3NDbGFzc2VzLklDT059ICR7Y3NzQ2xhc3Nlcy5JQ09OX09OfWB9IHZpZXdCb3g9XCIwIDAgMjQgMjRcIj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxwYXRoIGQ9XCJNMTkuNjksNS4yM0w4Ljk2LDE1Ljk2bC00LjIzLTQuMjNMMi45NiwxMy41bDYsNkwyMS40Niw3TDE5LjY5LDUuMjN6XCIgLz5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPC9zdmc+XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8c3ZnIGNsYXNzTmFtZT17YCR7Y3NzQ2xhc3Nlcy5JQ09OfSAke2Nzc0NsYXNzZXMuSUNPTl9PRkZ9YH0gdmlld0JveD1cIjAgMCAyNCAyNFwiPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPHBhdGggZD1cIk0yMCAxM0g0di0yaDE2djJ6XCIgLz5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPC9zdmc+XHJcbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgPC9idXR0b24+XHJcbiAgICApO1xyXG59KTtcclxuXHJcblN3aXRjaC5kaXNwbGF5TmFtZSA9ICdNRENTd2l0Y2gnO1xyXG5cclxuU3dpdGNoLnByb3BUeXBlcyA9IHtcclxuICAgIGNoZWNrZWQ6IFByb3BUeXBlcy5ib29sLFxyXG4gICAgZGlzYWJsZWQ6IFByb3BUeXBlcy5ib29sLFxyXG4gICAgb25DaGFuZ2U6IFByb3BUeXBlcy5mdW5jXHJcbn07XHJcblxyXG5leHBvcnQgZGVmYXVsdCBTd2l0Y2g7IiwiZXhwb3J0IHsgZGVmYXVsdCB9IGZyb20gJy4vU3dpdGNoJzsiLCJleHBvcnQgY29uc3QgdGFiQ2xhc3NOYW1lcyA9IHtcclxuICAgIFJPT1Q6ICdtZGMtdGFiJyxcclxuICAgIEFDVElWRTogJ21kYy10YWItLWFjdGl2ZScsXHJcbiAgICBTVEFDS0VEOiAnbWRjLXRhYi0tc3RhY2tlZCcsXHJcbiAgICBNSU5fV0lEVEg6ICdtZGMtdGFiLS1taW4td2lkdGgnLFxyXG5cclxuICAgIENPTlRFTlQ6ICdtZGMtdGFiX19jb250ZW50JyxcclxuICAgIElDT046ICdtZGMtdGFiX19pY29uJyxcclxuICAgIExBQkVMOiAnbWRjLXRhYl9fdGV4dC1sYWJlbCcsXHJcbiAgICBSSVBQTEU6ICdtZGMtdGFiX19yaXBwbGUnXHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgYmFyQ3NzQ2xhc3NlcyA9IHtcclxuICAgIFJPT1Q6ICdtZGMtdGFiLWJhcidcclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCBzY3JvbGxlckNzc0NsYXNzZXMgPSB7XHJcbiAgICBST09UOiAnbWRjLXRhYi1zY3JvbGxlcicsXHJcbiAgICBBTElHTjogJ21kYy10YWItc2Nyb2xsZXItLWFsaWduJyxcclxuICAgIEFOSU1BVElORzogJ21kYy10YWItc2Nyb2xsZXItLWFuaW1hdGluZycsXHJcblxyXG4gICAgU0NST0xMX0FSRUE6ICdtZGMtdGFiLXNjcm9sbGVyX19zY3JvbGwtYXJlYScsXHJcbiAgICBTQ1JPTExfQVJFQV9TQ1JPTEw6ICdtZGMtdGFiLXNjcm9sbGVyX19zY3JvbGwtYXJlYS0tc2Nyb2xsJyxcclxuICAgIFNDUk9MTF9DT05URU5UOiAnbWRjLXRhYi1zY3JvbGxlcl9fc2Nyb2xsLWNvbnRlbnQnXHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgaW5kaWNhdG9yQ3NzQ2xhc3NlcyA9IHtcclxuICAgIFJPT1Q6ICdtZGMtdGFiLWluZGljYXRvcicsXHJcbiAgICBBQ1RJVkU6ICdtZGMtdGFiLWluZGljYXRvci0tYWN0aXZlJyxcclxuICAgIEZBREU6ICdtZGMtdGFiLWluZGljYXRvci0tZmFkZScsXHJcbiAgICBOT19UUkFOU0lUSU9OOiAnbWRjLXRhYi1pbmRpY2F0b3ItLW5vLXRyYW5zaXRpb24nLFxyXG5cclxuICAgIENPTlRFTlQ6ICdtZGMtdGFiLWluZGljYXRvcl9fY29udGVudCcsXHJcbiAgICBDT05URU5UX0lDT046ICdtZGMtdGFiLWluZGljYXRvcl9fY29udGVudC0taWNvbiBtYXRlcmlhbC1pY29ucycsXHJcbiAgICBDT05URU5UX1VOREVSTElORTogJ21kYy10YWItaW5kaWNhdG9yX19jb250ZW50LS11bmRlcmxpbmUnXHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgQWxpZ24gPSB7XHJcbiAgICBTVEFSVDogJ3N0YXJ0JyxcclxuICAgIENFTlRFUjogJ2NlbnRlcicsXHJcbiAgICBFTkQ6ICdlbmQnXHJcbn07IiwiaW1wb3J0IHsgY3JlYXRlQ29udGV4dCB9IGZyb20gJ3JlYWN0JztcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNyZWF0ZUNvbnRleHQoe30pOyIsImltcG9ydCB7IGZvcndhcmRSZWYsIHVzZUNvbnRleHQsIHVzZUltcGVyYXRpdmVIYW5kbGUsIHVzZVJlZiB9IGZyb20gJ3JlYWN0JztcclxuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcclxuaW1wb3J0IGNsYXNzbmFtZXMgZnJvbSAnY2xhc3NuYW1lcyc7XHJcblxyXG5pbXBvcnQgeyB1c2VVcGRhdGVkU3luYyB9IGZyb20gJy4uL2hvb2tzJztcclxuXHJcbmltcG9ydCB7IGluZGljYXRvckNzc0NsYXNzZXMgYXMgY3NzQ2xhc3NlcyB9IGZyb20gJy4vY29uc3RhbnRzJztcclxuaW1wb3J0IFRhYkNvbnRleHQgZnJvbSAnLi9jb250ZXh0JztcclxuXHJcbmNvbnN0IFRhYkluZGljYXRvciA9IGZvcndhcmRSZWYoKHtcclxuICAgIGljb24sXHJcbiAgICBhY3RpdmUgPSBmYWxzZSxcclxuICAgIGZhZGUgPSBmYWxzZSxcclxuICAgIHVuZGVybGluZSA9ICFpY29uLFxyXG5cclxuICAgIC4uLnByb3BzXHJcbn0sIHJlZikgPT4ge1xyXG4gICAgY29uc3QgeyBwcmV2aW91c1RhYiB9ID0gdXNlQ29udGV4dChUYWJDb250ZXh0KTtcclxuXHJcbiAgICBjb25zdCByb290UmVmID0gdXNlUmVmKCk7XHJcbiAgICBjb25zdCBjb250ZW50UmVmID0gdXNlUmVmKCk7XHJcblxyXG4gICAgdXNlSW1wZXJhdGl2ZUhhbmRsZShyZWYsICgpID0+IHJvb3RSZWYuY3VycmVudCk7XHJcblxyXG4gICAgdXNlVXBkYXRlZFN5bmMoKCkgPT4ge1xyXG4gICAgICAgIGlmIChmYWRlIHx8ICFhY3RpdmUgfHwgIXByZXZpb3VzVGFiKSByZXR1cm47XHJcblxyXG4gICAgICAgIGNvbnN0IGFjdGl2ZUluZGljYXRvciA9IHJvb3RSZWYuY3VycmVudDtcclxuICAgICAgICBjb25zdCBwcmV2aW91c0luZGljYXRvciA9IHByZXZpb3VzVGFiLnF1ZXJ5U2VsZWN0b3IoJy5tZGMtdGFiLWluZGljYXRvcicpO1xyXG4gICAgICAgIGNvbnN0IHByZXZpb3VzSW5kaWNhdG9yQ2xpZW50UmVjdCA9IHByZXZpb3VzSW5kaWNhdG9yLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xyXG4gICAgICAgIGNvbnN0IGFjdGl2ZUluZGljYXRvckNsaWVudFJlY3QgPSBhY3RpdmVJbmRpY2F0b3IuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XHJcblxyXG4gICAgICAgIGNvbnN0IHhQb3NpdGlvbiA9IHByZXZpb3VzSW5kaWNhdG9yQ2xpZW50UmVjdC5sZWZ0IC0gYWN0aXZlSW5kaWNhdG9yQ2xpZW50UmVjdC5sZWZ0O1xyXG4gICAgICAgIGNvbnN0IHdpZHRoRGVsdGEgPSBwcmV2aW91c0luZGljYXRvckNsaWVudFJlY3Qud2lkdGggLyBhY3RpdmVJbmRpY2F0b3JDbGllbnRSZWN0LndpZHRoO1xyXG5cclxuICAgICAgICByb290UmVmLmN1cnJlbnQuY2xhc3NMaXN0LmFkZChjc3NDbGFzc2VzLk5PX1RSQU5TSVRJT04pO1xyXG4gICAgICAgIGNvbnRlbnRSZWYuY3VycmVudC5zdHlsZS50cmFuc2Zvcm0gPSBgdHJhbnNsYXRlWCgke3hQb3NpdGlvbn1weCkgc2NhbGVYKCR7d2lkdGhEZWx0YX0pYDtcclxuICAgICAgICAvLyBGb3JjZSByZXBhaW50IGJlZm9yZSB1cGRhdGluZyBjbGFzc2VzIGFuZCB0cmFuc2Zvcm0gdG8gZW5zdXJlIHRoZSB0cmFuc2Zvcm0gcHJvcGVybHkgdGFrZXMgZWZmZWN0XHJcbiAgICAgICAgY29udGVudFJlZi5jdXJyZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xyXG4gICAgICAgIHJvb3RSZWYuY3VycmVudC5jbGFzc0xpc3QucmVtb3ZlKGNzc0NsYXNzZXMuTk9fVFJBTlNJVElPTik7XHJcbiAgICAgICAgY29udGVudFJlZi5jdXJyZW50LnN0eWxlLnRyYW5zZm9ybSA9ICcnO1xyXG4gICAgfSwgW2ZhZGUsIGFjdGl2ZV0pO1xyXG5cclxuICAgIGNvbnN0IHJvb3RDbGFzc05hbWVzID0gY2xhc3NuYW1lcyhjc3NDbGFzc2VzLlJPT1QsIHtcclxuICAgICAgICBbY3NzQ2xhc3Nlcy5BQ1RJVkVdOiBhY3RpdmUsXHJcbiAgICAgICAgW2Nzc0NsYXNzZXMuRkFERV06IGZhZGVcclxuICAgIH0pO1xyXG5cclxuICAgIGNvbnN0IGNvbnRlbnRDbGFzc05hbWVzID0gY2xhc3NuYW1lcyhjc3NDbGFzc2VzLkNPTlRFTlQsIHtcclxuICAgICAgICBbY3NzQ2xhc3Nlcy5DT05URU5UX0lDT05dOiBpY29uLFxyXG4gICAgICAgIFtjc3NDbGFzc2VzLkNPTlRFTlRfVU5ERVJMSU5FXTogdW5kZXJsaW5lXHJcbiAgICB9KTtcclxuXHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAgIDxzcGFuIHJlZj17cm9vdFJlZn0gY2xhc3NOYW1lPXtyb290Q2xhc3NOYW1lc30gey4uLnByb3BzfT5cclxuICAgICAgICAgICAgPHNwYW5cclxuICAgICAgICAgICAgICAgIHJlZj17Y29udGVudFJlZn1cclxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZT17Y29udGVudENsYXNzTmFtZXN9XHJcbiAgICAgICAgICAgID5cclxuICAgICAgICAgICAgICAgIHtpY29ufVxyXG4gICAgICAgICAgICA8L3NwYW4+XHJcbiAgICAgICAgPC9zcGFuPlxyXG4gICAgKTtcclxufSk7XHJcblxyXG5UYWJJbmRpY2F0b3IuZGlzcGxheU5hbWUgPSAnTURDVGFiSW5kaWNhdG9yJztcclxuXHJcblRhYkluZGljYXRvci5wcm9wVHlwZXMgPSB7XHJcbiAgICBpY29uOiBQcm9wVHlwZXMubm9kZSxcclxuICAgIGFjdGl2ZTogUHJvcFR5cGVzLmJvb2wsXHJcbiAgICBmYWRlOiBQcm9wVHlwZXMuYm9vbCxcclxuICAgIHVuZGVybGluZTogUHJvcFR5cGVzLmJvb2xcclxufTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IFRhYkluZGljYXRvcjsiLCJpbXBvcnQgeyBmb3J3YXJkUmVmLCB1c2VSZWYsIHVzZUNhbGxiYWNrLCB1c2VJbXBlcmF0aXZlSGFuZGxlIH0gZnJvbSAncmVhY3QnO1xyXG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xyXG5pbXBvcnQgY2xhc3NuYW1lcyBmcm9tICdjbGFzc25hbWVzJztcclxuXHJcbmltcG9ydCB7IENsb25lIH0gZnJvbSAnLi4vY29tcG9uZW50JztcclxuaW1wb3J0IEljb24gZnJvbSAnLi4vaWNvbic7XHJcblxyXG5pbXBvcnQgeyB0YWJDbGFzc05hbWVzIGFzIGNzc0NsYXNzZXMgfSBmcm9tICcuL2NvbnN0YW50cyc7XHJcbmltcG9ydCBUYWJJbmRpY2F0b3IgZnJvbSAnLi9UYWJJbmRpY2F0b3InO1xyXG5cclxuY29uc3QgVGFiID0gZm9yd2FyZFJlZigoe1xyXG4gICAgdmFsdWUsXHJcbiAgICBpY29uLFxyXG4gICAgbGFiZWwsXHJcbiAgICBpbmRpY2F0b3JJY29uLFxyXG4gICAgYWN0aXZlID0gZmFsc2UsXHJcbiAgICBzdGFja2VkID0gZmFsc2UsXHJcbiAgICBtaW5XaWR0aCA9IGZhbHNlLFxyXG4gICAgbWluV2lkdGhJbmRpY2F0b3IgPSBmYWxzZSxcclxuICAgIGZhZGUgPSBmYWxzZSxcclxuICAgIHVuZGVybGluZSA9ICFpbmRpY2F0b3JJY29uLFxyXG4gICAgb25DbGljayA9IEZ1bmN0aW9uLnByb3RvdHlwZSxcclxuXHJcbiAgICBlbGVtZW50ID0gJ2J1dHRvbicsXHJcbiAgICBjb21wb25lbnQ6IEVsZW1lbnQgPSBlbGVtZW50LFxyXG4gICAgY2xhc3NOYW1lLFxyXG4gICAgY2hpbGRyZW4gPSBsYWJlbCxcclxuICAgIC4uLnByb3BzXHJcbn0sIHJlZikgPT4ge1xyXG4gICAgY29uc3Qgcm9vdFJlZiA9IHVzZVJlZigpO1xyXG5cclxuICAgIHVzZUltcGVyYXRpdmVIYW5kbGUocmVmLCAoKSA9PiByb290UmVmLmN1cnJlbnQpO1xyXG5cclxuICAgIGNvbnN0IGhhbmRsZUNsaWNrID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xyXG4gICAgICAgIG9uQ2xpY2socm9vdFJlZi5jdXJyZW50LCB2YWx1ZSk7XHJcbiAgICB9LCBbdmFsdWUsIG9uQ2xpY2tdKTtcclxuXHJcbiAgICBjb25zdCBjbGFzc05hbWVzID0gY2xhc3NuYW1lcyhjc3NDbGFzc2VzLlJPT1QsIHtcclxuICAgICAgICBbY3NzQ2xhc3Nlcy5BQ1RJVkVdOiBhY3RpdmUsXHJcbiAgICAgICAgW2Nzc0NsYXNzZXMuU1RBQ0tFRF06IHN0YWNrZWQsXHJcbiAgICAgICAgW2Nzc0NsYXNzZXMuTUlOX1dJRFRIXTogbWluV2lkdGhcclxuICAgIH0sIGNsYXNzTmFtZSk7XHJcblxyXG4gICAgcmV0dXJuIChcclxuICAgICAgICA8RWxlbWVudFxyXG4gICAgICAgICAgICByZWY9e3Jvb3RSZWZ9XHJcbiAgICAgICAgICAgIGNsYXNzTmFtZT17Y2xhc3NOYW1lc31cclxuICAgICAgICAgICAgZGF0YS12YWx1ZT17dmFsdWV9XHJcbiAgICAgICAgICAgIHJvbGU9XCJ0YWJcIlxyXG4gICAgICAgICAgICBhcmlhLXNlbGVjdGVkPXthY3RpdmUgPyAndHJ1ZScgOiAnZmFsc2UnfVxyXG4gICAgICAgICAgICB0YWJJbmRleD17YWN0aXZlID8gMCA6IC0xfVxyXG4gICAgICAgICAgICBvbkNsaWNrPXtoYW5kbGVDbGlja31cclxuICAgICAgICAgICAgey4uLnByb3BzfVxyXG4gICAgICAgID5cclxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9e2Nzc0NsYXNzZXMuQ09OVEVOVH0+XHJcbiAgICAgICAgICAgICAgICB7aWNvbiAmJlxyXG4gICAgICAgICAgICAgICAgICAgIDxDbG9uZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb21wb25lbnQ9e2ljb259XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZhbGxiYWNrPXtJY29ufVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU9e2Nzc0NsYXNzZXMuSUNPTn1cclxuICAgICAgICAgICAgICAgICAgICAvPlxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHtjaGlsZHJlbiAmJlxyXG4gICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT17Y3NzQ2xhc3Nlcy5MQUJFTH0+e2NoaWxkcmVufTwvc3Bhbj5cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICB7bWluV2lkdGhJbmRpY2F0b3IgJiZcclxuICAgICAgICAgICAgICAgICAgICA8VGFiSW5kaWNhdG9yXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGljb249e2luZGljYXRvckljb259XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjdGl2ZT17YWN0aXZlfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmYWRlPXtmYWRlfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB1bmRlcmxpbmU9e3VuZGVybGluZX1cclxuICAgICAgICAgICAgICAgICAgICAvPlxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICA8L2Rpdj5cclxuXHJcbiAgICAgICAgICAgIHshbWluV2lkdGhJbmRpY2F0b3IgJiZcclxuICAgICAgICAgICAgICAgIDxUYWJJbmRpY2F0b3JcclxuICAgICAgICAgICAgICAgICAgICBpY29uPXtpbmRpY2F0b3JJY29ufVxyXG4gICAgICAgICAgICAgICAgICAgIGFjdGl2ZT17YWN0aXZlfVxyXG4gICAgICAgICAgICAgICAgICAgIGZhZGU9e2ZhZGV9XHJcbiAgICAgICAgICAgICAgICAgICAgdW5kZXJsaW5lPXt1bmRlcmxpbmV9XHJcbiAgICAgICAgICAgICAgICAvPlxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17Y3NzQ2xhc3Nlcy5SSVBQTEV9IC8+XHJcbiAgICAgICAgPC9FbGVtZW50PlxyXG4gICAgKTtcclxufSk7XHJcblxyXG5UYWIuZGlzcGxheU5hbWUgPSAnTURDVGFiJztcclxuXHJcblRhYi5wcm9wVHlwZXMgPSB7XHJcbiAgICB2YWx1ZTogUHJvcFR5cGVzLmFueSxcclxuICAgIGljb246IFByb3BUeXBlcy5ub2RlLFxyXG4gICAgbGFiZWw6IFByb3BUeXBlcy5ub2RlLFxyXG4gICAgaW5kaWNhdG9ySWNvbjogUHJvcFR5cGVzLm5vZGUsXHJcbiAgICBhY3RpdmU6IFByb3BUeXBlcy5ib29sLFxyXG4gICAgc3RhY2tlZDogUHJvcFR5cGVzLmJvb2wsXHJcbiAgICBtaW5XaWR0aDogUHJvcFR5cGVzLmJvb2wsXHJcbiAgICBtaW5XaWR0aEluZGljYXRvcjogUHJvcFR5cGVzLmJvb2wsXHJcbiAgICBmYWRlOiBQcm9wVHlwZXMuYm9vbCxcclxuICAgIHVuZGVybGluZTogUHJvcFR5cGVzLmJvb2wsXHJcbiAgICBvbkFjdGl2YXRlOiBQcm9wVHlwZXMuZnVuY1xyXG59O1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgVGFiOyIsImltcG9ydCB7IGZvcndhcmRSZWYsIHVzZVJlZiB9IGZyb20gJ3JlYWN0JztcclxuaW1wb3J0IGNsYXNzbmFtZXMgZnJvbSAnY2xhc3NuYW1lcyc7XHJcblxyXG5pbXBvcnQgeyB1c2VNb3VudGVkLCB1c2VVcGRhdGVkIH0gZnJvbSAnLi4vaG9va3MnO1xyXG5cclxuaW1wb3J0IHsgc2Nyb2xsZXJDc3NDbGFzc2VzIGFzIGNzc0NsYXNzZXMgfSBmcm9tICcuL2NvbnN0YW50cyc7XHJcblxyXG5jb25zdCBUYWJTY3JvbGxlciA9IGZvcndhcmRSZWYoKHtcclxuICAgIGFsaWduLFxyXG4gICAgYWN0aXZlVGFiLFxyXG5cclxuICAgIGNoaWxkcmVuLFxyXG4gICAgLi4ucHJvcHNcclxufSwgcmVmKSA9PiB7XHJcbiAgICBjb25zdCBzY3JvbGxBcmVhUmVmID0gdXNlUmVmKCk7XHJcbiAgICBjb25zdCBzY3JvbGxDb250ZW50UmVmID0gdXNlUmVmKCk7XHJcblxyXG4gICAgdXNlTW91bnRlZCgoKSA9PiB7XHJcbiAgICAgICAgY29uc3Qgc2Nyb2xsQXJlYVdpZHRoID0gc2Nyb2xsQXJlYVJlZi5jdXJyZW50Lm9mZnNldFdpZHRoO1xyXG4gICAgICAgIGNvbnN0IHNjcm9sbENvbnRlbnRXaWR0aCA9IHNjcm9sbENvbnRlbnRSZWYuY3VycmVudC5vZmZzZXRXaWR0aDtcclxuXHJcbiAgICAgICAgaWYgKHNjcm9sbENvbnRlbnRXaWR0aCA+IHNjcm9sbEFyZWFXaWR0aCkge1xyXG4gICAgICAgICAgICBzY3JvbGxBcmVhUmVmLmN1cnJlbnQuY2xhc3NMaXN0LmFkZChjc3NDbGFzc2VzLlNDUk9MTF9BUkVBX1NDUk9MTCk7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgdXNlVXBkYXRlZCgoKSA9PiB7XHJcbiAgICAgICAgaWYgKCFhY3RpdmVUYWIpIHJldHVybjtcclxuXHJcbiAgICAgICAgY29uc3Qgc2Nyb2xsQXJlYVdpZHRoID0gc2Nyb2xsQXJlYVJlZi5jdXJyZW50Lm9mZnNldFdpZHRoO1xyXG4gICAgICAgIGNvbnN0IHRhYldpZHRoID0gYWN0aXZlVGFiLm9mZnNldFdpZHRoO1xyXG4gICAgICAgIGNvbnN0IHRhYkhhbGZXaWR0aCA9IHRhYldpZHRoICogMC41O1xyXG4gICAgICAgIGNvbnN0IG9mZnNldExlZnQgPSBhY3RpdmVUYWIub2Zmc2V0TGVmdCAtIHNjcm9sbEFyZWFSZWYuY3VycmVudC5zY3JvbGxMZWZ0O1xyXG4gICAgICAgIGNvbnN0IG9mZnNldExlZnREZWx0YSA9IGFjdGl2ZVRhYi5vZmZzZXRMZWZ0IC0gc2Nyb2xsQXJlYVJlZi5jdXJyZW50LnNjcm9sbExlZnQ7XHJcbiAgICAgICAgY29uc3Qgb2Zmc2V0UmlnaHQgPSBhY3RpdmVUYWIub2Zmc2V0TGVmdCArIHRhYldpZHRoIC0gc2Nyb2xsQXJlYVJlZi5jdXJyZW50LnNjcm9sbExlZnQ7XHJcbiAgICAgICAgY29uc3Qgb2Zmc2V0UmlnaHREZWx0YSA9IHNjcm9sbEFyZWFXaWR0aCAtIG9mZnNldFJpZ2h0O1xyXG5cclxuICAgICAgICBpZiAob2Zmc2V0UmlnaHQgPiBzY3JvbGxBcmVhV2lkdGggfHwgb2Zmc2V0UmlnaHREZWx0YSA8IHRhYkhhbGZXaWR0aCkge1xyXG4gICAgICAgICAgICBzY3JvbGxBcmVhUmVmLmN1cnJlbnQuc2Nyb2xsQnkoe1xyXG4gICAgICAgICAgICAgICAgbGVmdDogb2Zmc2V0UmlnaHQgPiBzY3JvbGxBcmVhV2lkdGggPyBNYXRoLmFicyhvZmZzZXRSaWdodERlbHRhKSArIHRhYkhhbGZXaWR0aCA6IHRhYkhhbGZXaWR0aCAtIG9mZnNldFJpZ2h0RGVsdGEsXHJcbiAgICAgICAgICAgICAgICBiZWhhdmlvcjogJ3Ntb290aCdcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSBlbHNlIGlmIChvZmZzZXRMZWZ0IDwgMCB8fCBvZmZzZXRMZWZ0RGVsdGEgPCB0YWJIYWxmV2lkdGgpIHtcclxuICAgICAgICAgICAgc2Nyb2xsQXJlYVJlZi5jdXJyZW50LnNjcm9sbEJ5KHtcclxuICAgICAgICAgICAgICAgIGxlZnQ6IG9mZnNldExlZnQgPCAwID8gb2Zmc2V0TGVmdERlbHRhIC0gdGFiSGFsZldpZHRoIDogLSh0YWJIYWxmV2lkdGggLSBvZmZzZXRMZWZ0RGVsdGEpLFxyXG4gICAgICAgICAgICAgICAgYmVoYXZpb3I6ICdzbW9vdGgnXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH0sIFthY3RpdmVUYWJdKTtcclxuXHJcbiAgICBjb25zdCBjbGFzc05hbWVzID0gY2xhc3NuYW1lcyhjc3NDbGFzc2VzLlJPT1QsIHtcclxuICAgICAgICBbYCR7Y3NzQ2xhc3Nlcy5BTElHTn0tJHthbGlnbn1gXTogYWxpZ25cclxuICAgIH0pO1xyXG5cclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgPGRpdiByZWY9e3JlZn0gY2xhc3NOYW1lPXtjbGFzc05hbWVzfSB7Li4ucHJvcHN9PlxyXG4gICAgICAgICAgICA8ZGl2IHJlZj17c2Nyb2xsQXJlYVJlZn0gY2xhc3NOYW1lPXtjc3NDbGFzc2VzLlNDUk9MTF9BUkVBfT5cclxuICAgICAgICAgICAgICAgIDxkaXYgcmVmPXtzY3JvbGxDb250ZW50UmVmfSBjbGFzc05hbWU9e2Nzc0NsYXNzZXMuU0NST0xMX0NPTlRFTlR9PlxyXG4gICAgICAgICAgICAgICAgICAgIHtjaGlsZHJlbn1cclxuICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICA8L2Rpdj5cclxuICAgICk7XHJcbn0pO1xyXG5cclxuVGFiU2Nyb2xsZXIuZGlzcGxheU5hbWUgPSAnTURDVGFiU2Nyb2xsZXInO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgVGFiU2Nyb2xsZXI7IiwiaW1wb3J0IHsgQ2hpbGRyZW4sIGZvcndhcmRSZWYsIHVzZUNhbGxiYWNrLCB1c2VFZmZlY3QsIHVzZUltcGVyYXRpdmVIYW5kbGUsIHVzZVJlZiB9IGZyb20gJ3JlYWN0JztcclxuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcclxuaW1wb3J0IGNsYXNzbmFtZXMgZnJvbSAnY2xhc3NuYW1lcyc7XHJcblxyXG5pbXBvcnQgeyBpc1VuZGVmaW5lZCB9IGZyb20gJy4uL3R5cGVzJztcclxuaW1wb3J0IHsgY3JlYXRlLCBjbG9uZSB9IGZyb20gJy4uL2NvbXBvbmVudCc7XHJcblxyXG5pbXBvcnQgeyBiYXJDc3NDbGFzc2VzIGFzIGNzc0NsYXNzZXMsIHRhYkNsYXNzTmFtZXMsIEFsaWduIH0gZnJvbSAnLi9jb25zdGFudHMnO1xyXG5pbXBvcnQgVGFiQ29udGV4dCBmcm9tICcuL2NvbnRleHQnO1xyXG5pbXBvcnQgVGFiIGZyb20gJy4vVGFiJztcclxuaW1wb3J0IFRhYlNjcm9sbGVyIGZyb20gJy4vVGFiU2Nyb2xsZXInO1xyXG5cclxuY29uc3QgVGFiQmFyID0gZm9yd2FyZFJlZigoe1xyXG4gICAgdGFicyxcclxuICAgIHZhbHVlLFxyXG4gICAgYWxpZ24sXHJcbiAgICBpbmRpY2F0b3JJY29uLFxyXG4gICAgc3RhY2tlZCA9IGZhbHNlLFxyXG4gICAgbWluV2lkdGggPSBmYWxzZSxcclxuICAgIG1pbldpZHRoSW5kaWNhdG9yID0gZmFsc2UsXHJcbiAgICBmYWRlID0gZmFsc2UsXHJcbiAgICBpY29uSW5kaWNhdG9yID0gQm9vbGVhbihpbmRpY2F0b3JJY29uKSxcclxuICAgIHVuZGVybGluZUluZGljYXRvciA9ICFpY29uSW5kaWNhdG9yLFxyXG4gICAgb25DaGFuZ2UgPSBGdW5jdGlvbi5wcm90b3R5cGUsXHJcblxyXG4gICAgZWxlbWVudCA9ICdkaXYnLFxyXG4gICAgY29tcG9uZW50OiBFbGVtZW50ID0gZWxlbWVudCxcclxuICAgIGNsYXNzTmFtZSxcclxuICAgIGNoaWxkcmVuID0gdGFicz8ubWFwKHRhYiA9PiBjcmVhdGUoVGFiLCB0YWIpKSxcclxuICAgIC4uLnByb3BzXHJcbn0sIHJlZikgPT4ge1xyXG4gICAgY29uc3Qgcm9vdFJlZiA9IHVzZVJlZigpO1xyXG4gICAgY29uc3QgYWN0aXZlVGFiUmVmID0gdXNlUmVmKCk7XHJcbiAgICBjb25zdCBwcmV2aW91c1RhYlJlZiA9IHVzZVJlZigpO1xyXG5cclxuICAgIHVzZUltcGVyYXRpdmVIYW5kbGUocmVmLCAoKSA9PiByb290UmVmLmN1cnJlbnQpO1xyXG5cclxuICAgIHVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICAgICAgYWN0aXZlVGFiUmVmLmN1cnJlbnQgPSByb290UmVmLmN1cnJlbnQucXVlcnlTZWxlY3RvcihgLiR7dGFiQ2xhc3NOYW1lcy5BQ1RJVkV9YCk7XHJcbiAgICB9LCBbXSk7XHJcblxyXG4gICAgY29uc3QgaGFuZGxlVGFiQ2xpY2sgPSB1c2VDYWxsYmFjaygoZWxlbWVudCwgdmFsdWUpID0+IHtcclxuICAgICAgICBwcmV2aW91c1RhYlJlZi5jdXJyZW50ID0gYWN0aXZlVGFiUmVmLmN1cnJlbnQ7XHJcbiAgICAgICAgYWN0aXZlVGFiUmVmLmN1cnJlbnQgPSBlbGVtZW50O1xyXG4gICAgICAgIG9uQ2hhbmdlKHZhbHVlKTtcclxuICAgIH0sIFtvbkNoYW5nZV0pO1xyXG5cclxuICAgIGNvbnN0IGNsYXNzTmFtZXMgPSBjbGFzc25hbWVzKGNzc0NsYXNzZXMuUk9PVCwgY2xhc3NOYW1lKTtcclxuXHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAgIDxFbGVtZW50XHJcbiAgICAgICAgICAgIHJlZj17cm9vdFJlZn1cclxuICAgICAgICAgICAgY2xhc3NOYW1lPXtjbGFzc05hbWVzfVxyXG4gICAgICAgICAgICByb2xlPVwidGFibGlzdFwiXHJcbiAgICAgICAgICAgIHsuLi5wcm9wc31cclxuICAgICAgICA+XHJcbiAgICAgICAgICAgIHshaXNVbmRlZmluZWQodmFsdWUpID9cclxuICAgICAgICAgICAgICAgIDxUYWJDb250ZXh0LlByb3ZpZGVyIHZhbHVlPXt7XHJcbiAgICAgICAgICAgICAgICAgICAgYWN0aXZlVGFiOiBhY3RpdmVUYWJSZWYuY3VycmVudCxcclxuICAgICAgICAgICAgICAgICAgICBwcmV2aW91c1RhYjogcHJldmlvdXNUYWJSZWYuY3VycmVudFxyXG4gICAgICAgICAgICAgICAgfX0+XHJcbiAgICAgICAgICAgICAgICAgICAgPFRhYlNjcm9sbGVyXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFsaWduPXthbGlnbn1cclxuICAgICAgICAgICAgICAgICAgICAgICAgYWN0aXZlVGFiPXthY3RpdmVUYWJSZWYuY3VycmVudH1cclxuICAgICAgICAgICAgICAgICAgICA+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHtDaGlsZHJlbi5tYXAoY2hpbGRyZW4sICh0YWIsIGluZGV4KSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0YWJWYWx1ZSA9IGlzVW5kZWZpbmVkKHRhYi5wcm9wcy52YWx1ZSkgPyBpbmRleCA6IHRhYi5wcm9wcy52YWx1ZTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2xvbmUodGFiLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHRhYlZhbHVlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFjdGl2ZTogdGFiVmFsdWUgPT09IHZhbHVlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGljYXRvckljb246IHRhYi5wcm9wcy5pbmRpY2F0b3JJY29uIHx8IGluZGljYXRvckljb24sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhY2tlZDogdGFiLnByb3BzLnN0YWNrZWQgfHwgc3RhY2tlZCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtaW5XaWR0aDogdGFiLnByb3BzLm1pbldpZHRoIHx8IG1pbldpZHRoLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1pbldpZHRoSW5kaWNhdG9yOiB0YWIucHJvcHMubWluV2lkdGhJbmRpY2F0b3IgfHwgbWluV2lkdGhJbmRpY2F0b3IsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmFkZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1bmRlcmxpbmU6IHVuZGVybGluZUluZGljYXRvcixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbkNsaWNrOiBoYW5kbGVUYWJDbGlja1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pfVxyXG4gICAgICAgICAgICAgICAgICAgIDwvVGFiU2Nyb2xsZXI+XHJcbiAgICAgICAgICAgICAgICA8L1RhYkNvbnRleHQuUHJvdmlkZXI+XHJcbiAgICAgICAgICAgICAgICA6XHJcbiAgICAgICAgICAgICAgICBjaGlsZHJlblxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgPC9FbGVtZW50PlxyXG4gICAgKTtcclxufSk7XHJcblxyXG5UYWJCYXIuZGlzcGxheU5hbWUgPSAnTURDVGFiQmFyJztcclxuXHJcblRhYkJhci5wcm9wVHlwZXMgPSB7XHJcbiAgICBhbGlnbjogUHJvcFR5cGVzLm9uZU9mKE9iamVjdC52YWx1ZXMoQWxpZ24pKSxcclxuICAgIGluZGljYXRvckljb246IFByb3BUeXBlcy5ub2RlLFxyXG4gICAgc3RhY2tlZDogUHJvcFR5cGVzLmJvb2wsXHJcbiAgICBtaW5XaWR0aDogUHJvcFR5cGVzLmJvb2wsXHJcbiAgICBmYWRlOiBQcm9wVHlwZXMuYm9vbCxcclxuICAgIGljb25JbmRpY2F0b3I6IFByb3BUeXBlcy5ib29sLFxyXG4gICAgdW5kZXJsaW5lSW5kaWNhdG9yOiBQcm9wVHlwZXMuYm9vbCxcclxuICAgIG9uQ2hhbmdlOiBQcm9wVHlwZXMuZnVuY1xyXG59O1xyXG5cclxuVGFiQmFyLkFsaWduID0gQWxpZ247XHJcblxyXG5leHBvcnQgZGVmYXVsdCBUYWJCYXI7IiwiZXhwb3J0IHsgZGVmYXVsdCBhcyBUYWIgfSBmcm9tICcuL1RhYic7XHJcbmV4cG9ydCB7IGRlZmF1bHQgYXMgVGFiQmFyIH0gZnJvbSAnLi9UYWJCYXInOyIsImV4cG9ydCBjb25zdCBudW1iZXJzID0ge1xyXG4gICAgQk9VTkRFRF9BTkNIT1JfR0FQOiA0LFxyXG4gICAgVU5CT1VOREVEX0FOQ0hPUl9HQVA6IDgsXHJcbiAgICBNSU5fVklFV1BPUlRfVE9PTFRJUF9USFJFU0hPTEQ6IDgsXHJcbiAgICBFTlRFUl9EVVJBVElPTl9NUzogMTUwLFxyXG4gICAgRVhJVF9EVVJBVElPTl9NUzogNzUsXHJcbiAgICBISURFX0RFTEFZX01TOiA2MDAsXHJcbiAgICBTSE9XX0RFTEFZX01TOiA1MDAsXHJcbiAgICBNSU5fSEVJR0hUOiAyNCxcclxuICAgIE1BWF9XSURUSDogMjAwLFxyXG4gICAgQ0FSRVRfSU5ERU5UQVRJT046IDI0LFxyXG4gICAgQU5JTUFUSU9OX1NDQUxFOiAwLjhcclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCBjc3NDbGFzc2VzID0ge1xyXG4gICAgUk9PVDogJ21kYy10b29sdGlwJyxcclxuICAgIFJJQ0g6ICdtZGMtdG9vbHRpcC0tcmljaCcsXHJcbiAgICBNVUxUSUxJTkU6ICdtZGMtdG9vbHRpcC0tbXVsdGlsaW5lJyxcclxuICAgIFNIT1dJTkc6ICdtZGMtdG9vbHRpcC0tc2hvd2luZycsXHJcbiAgICBBQ1RJT05TOiAnbWRjLXRvb2x0aXAtLXJpY2gtYWN0aW9ucycsXHJcbiAgICBTSE9XSU5HX1RSQU5TSVRJT046ICdtZGMtdG9vbHRpcC0tc2hvd2luZy10cmFuc2l0aW9uJyxcclxuICAgIFNIT1dOOiAnbWRjLXRvb2x0aXAtLXNob3duJyxcclxuICAgIEhJREU6ICdtZGMtdG9vbHRpcC0taGlkZScsXHJcbiAgICBISURFX1RSQU5TSVRJT046ICdtZGMtdG9vbHRpcC0taGlkZS10cmFuc2l0aW9uJyxcclxuXHJcbiAgICBTVVJGQUNFOiAnbWRjLXRvb2x0aXBfX3N1cmZhY2UnLFxyXG4gICAgU1VSRkFDRV9BTklNQVRJT046ICdtZGMtdG9vbHRpcF9fc3VyZmFjZS1hbmltYXRpb24nLFxyXG5cclxuICAgIFRJVExFOiAnbWRjLXRvb2x0aXBfX3RpdGxlJyxcclxuXHJcbiAgICBDT05URU5UOiAnbWRjLXRvb2x0aXBfX2NvbnRlbnQnLFxyXG4gICAgQ09OVEVOVF9MSU5LOiAnbWRjLXRvb2x0aXBfX2NvbnRlbnQtbGluaycsXHJcblxyXG4gICAgQUNUSU9OOiAnbWRjLXRvb2x0aXBfX2FjdGlvbicsXHJcblxyXG4gICAgQ0FSRVRfVE9QOiAnbWRjLXRvb2x0aXBfX2NhcmV0LXN1cmZhY2UtdG9wJyxcclxuICAgIENBUkVUX0JPVFRPTTogJ21kYy10b29sdGlwX19jYXJldC1zdXJmYWNlLWJvdHRvbSdcclxufTsiLCJpbXBvcnQgeyB1c2VSZWYsIHVzZVN0YXRlLCB1c2VFZmZlY3QsIHVzZUNhbGxiYWNrLCB1c2VJbXBlcmF0aXZlSGFuZGxlLCBmb3J3YXJkUmVmIH0gZnJvbSAncmVhY3QnO1xyXG5pbXBvcnQgY2xhc3NuYW1lcyBmcm9tICdjbGFzc25hbWVzJztcclxuXHJcbmltcG9ydCB7IENsb25lIH0gZnJvbSAnLi4vY29tcG9uZW50JztcclxuaW1wb3J0IExheWVyIGZyb20gJy4uL2xheWVyJztcclxuXHJcbmltcG9ydCB7IG51bWJlcnMsIGNzc0NsYXNzZXMgfSBmcm9tICcuL2NvbnN0YW50cyc7XHJcblxyXG5jb25zdCBUb29sdGlwID0gZm9yd2FyZFJlZigoe1xyXG4gICAgbGFiZWwsXHJcblxyXG4gICAgZWxlbWVudDogRWxlbWVudCA9ICdkaXYnLFxyXG4gICAgY2xhc3NOYW1lLFxyXG4gICAgY2hpbGRyZW5cclxufSwgcmVmKSA9PiB7XHJcbiAgICBjb25zdCB0b29sdGlwUmVmID0gdXNlUmVmKCk7XHJcbiAgICBjb25zdCB0YXJnZXRSZWYgPSB1c2VSZWYobnVsbCk7XHJcbiAgICBjb25zdCBbYWN0aXZlLCBzZXRBY3RpdmVdID0gdXNlU3RhdGUoZmFsc2UpO1xyXG5cclxuICAgIHVzZUltcGVyYXRpdmVIYW5kbGUocmVmLCAoKSA9PiB0b29sdGlwUmVmLmN1cnJlbnQpO1xyXG5cclxuICAgIHVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICAgICAgZnVuY3Rpb24gaGFuZGxlU2Nyb2xsKCkge1xyXG4gICAgICAgICAgICBzZXRBY3RpdmUoYWN0aXZlID0+IGFjdGl2ZSAmJiAhYWN0aXZlKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIGhhbmRsZVNjcm9sbCk7XHJcblxyXG4gICAgICAgIHJldHVybiAoKSA9PiB7XHJcbiAgICAgICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIGhhbmRsZVNjcm9sbCk7XHJcbiAgICAgICAgfTtcclxuICAgIH0sIFtdKTtcclxuXHJcbiAgICBjb25zdCBoYW5kbGVNb3VzZUVudGVyID0gdXNlQ2FsbGJhY2soZXZlbnQgPT4ge1xyXG4gICAgICAgIHRhcmdldFJlZi5jdXJyZW50ID0gZXZlbnQuY3VycmVudFRhcmdldDtcclxuICAgICAgICBzZXRBY3RpdmUodHJ1ZSk7XHJcbiAgICB9LCBbXSk7XHJcblxyXG4gICAgY29uc3QgaGFuZGxlTW91c2VMZWF2ZSA9IHVzZUNhbGxiYWNrKCgpID0+IHtcclxuICAgICAgICB0YXJnZXRSZWYuY3VycmVudCA9IG51bGw7XHJcbiAgICAgICAgc2V0QWN0aXZlKGZhbHNlKTtcclxuICAgIH0sIFtdKTtcclxuXHJcbiAgICBjb25zdCBoYW5kbGVFbnRlcmluZyA9IHVzZUNhbGxiYWNrKCgpID0+IHtcclxuICAgICAgICBjb25zdCB0b29sdGlwUmVjdCA9IHRvb2x0aXBSZWYuY3VycmVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcclxuICAgICAgICBjb25zdCB0YXJnZXRSZWN0ID0gdGFyZ2V0UmVmLmN1cnJlbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XHJcblxyXG4gICAgICAgIGNvbnN0IHRvcCA9ICh0YXJnZXRSZWN0LnRvcCArIHRhcmdldFJlY3QuaGVpZ2h0ICsgbnVtYmVycy5VTkJPVU5ERURfQU5DSE9SX0dBUCk7XHJcbiAgICAgICAgY29uc3QgbGVmdCA9ICh0YXJnZXRSZWN0LmxlZnQgKyB0YXJnZXRSZWN0LndpZHRoICogMC41IC0gdG9vbHRpcFJlY3Qud2lkdGggKiAwLjUpO1xyXG4gICAgICAgIGNvbnN0IHJpZ2h0ID0gbGVmdCArIHRvb2x0aXBSZWN0LndpZHRoO1xyXG4gICAgICAgIGNvbnN0IGJvdHRvbSA9IHRvcCArIHRvb2x0aXBSZWN0LmhlaWdodDtcclxuICAgICAgICBjb25zdCBvdmVyZmxvd0JvdHRvbSA9IHdpbmRvdy5pbm5lckhlaWdodCAtIGJvdHRvbTtcclxuICAgICAgICBjb25zdCBvdmVyZmxvd1JpZ2h0ID0gd2luZG93LmlubmVyV2lkdGggLSByaWdodDtcclxuXHJcbiAgICAgICAgaWYgKFxyXG4gICAgICAgICAgICB0b29sdGlwUmVjdC5oZWlnaHQgPiBudW1iZXJzLk1JTl9IRUlHSFQgJiZcclxuICAgICAgICAgICAgdG9vbHRpcFJlY3Qud2lkdGggPj0gbnVtYmVycy5NQVhfV0lEVEhcclxuICAgICAgICApIHtcclxuICAgICAgICAgICAgdG9vbHRpcFJlZi5jdXJyZW50LmNsYXNzTGlzdC5hZGQoY3NzQ2xhc3Nlcy5NVUxUSUxJTkUpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKG92ZXJmbG93Qm90dG9tIDwgMCkge1xyXG4gICAgICAgICAgICB0b29sdGlwUmVmLmN1cnJlbnQuc3R5bGUudG9wID0gYCR7dGFyZ2V0UmVjdC50b3AgLSB0b29sdGlwUmVjdC5oZWlnaHQgLSBudW1iZXJzLlVOQk9VTkRFRF9BTkNIT1JfR0FQfXB4YDtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0b29sdGlwUmVmLmN1cnJlbnQuc3R5bGUudG9wID0gYCR7dG9wfXB4YDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChvdmVyZmxvd1JpZ2h0IDwgMCkge1xyXG4gICAgICAgICAgICB0b29sdGlwUmVmLmN1cnJlbnQuc3R5bGUubGVmdCA9IGAke3RhcmdldFJlY3QucmlnaHQgLSB0b29sdGlwUmVjdC53aWR0aH1weGA7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdG9vbHRpcFJlZi5jdXJyZW50LnN0eWxlLmxlZnQgPSBgJHtsZWZ0IDwgMCA/IHRhcmdldFJlY3QubGVmdCA6IGxlZnR9cHhgO1xyXG4gICAgICAgIH1cclxuICAgIH0sIFtdKTtcclxuXHJcbiAgICBjb25zdCBjbGFzc05hbWVzID0gY2xhc3NuYW1lcyhjc3NDbGFzc2VzLlJPT1QsIGNsYXNzTmFtZSk7XHJcblxyXG4gICAgcmV0dXJuICg8PlxyXG4gICAgICAgIDxDbG9uZVxyXG4gICAgICAgICAgICBjb21wb25lbnQ9e2NoaWxkcmVufVxyXG4gICAgICAgICAgICBvbk1vdXNlRW50ZXI9e2hhbmRsZU1vdXNlRW50ZXJ9XHJcbiAgICAgICAgICAgIG9uTW91c2VMZWF2ZT17aGFuZGxlTW91c2VMZWF2ZX1cclxuICAgICAgICAvPlxyXG5cclxuICAgICAgICA8TGF5ZXJcclxuICAgICAgICAgICAgbW9kYWxcclxuICAgICAgICAgICAgaW49e2FjdGl2ZX1cclxuICAgICAgICAgICAgdGltZW91dD17e1xyXG4gICAgICAgICAgICAgICAgZW50ZXI6IG51bWJlcnMuU0hPV19ERUxBWV9NUyxcclxuICAgICAgICAgICAgICAgIGV4aXQ6IG51bWJlcnMuSElERV9ERUxBWV9NU1xyXG4gICAgICAgICAgICB9fVxyXG4gICAgICAgICAgICBjbGFzc05hbWVzPXt7XHJcbiAgICAgICAgICAgICAgICBlbnRlcjogY3NzQ2xhc3Nlcy5TSE9XSU5HX1RSQU5TSVRJT04sXHJcbiAgICAgICAgICAgICAgICBlbnRlckFjdGl2ZTogYCR7Y3NzQ2xhc3Nlcy5TSE9XSU5HX1RSQU5TSVRJT059ICR7Y3NzQ2xhc3Nlcy5TSE9XSU5HfWAsXHJcbiAgICAgICAgICAgICAgICBlbnRlckRvbmU6IGAke2Nzc0NsYXNzZXMuU0hPV0lOR19UUkFOU0lUSU9OfSAke2Nzc0NsYXNzZXMuU0hPV059YCxcclxuICAgICAgICAgICAgICAgIGV4aXQ6IGAke2Nzc0NsYXNzZXMuSElERV9UUkFOU0lUSU9OfSAke2Nzc0NsYXNzZXMuSElERX1gLFxyXG4gICAgICAgICAgICAgICAgZXhpdEFjdGl2ZTogYCR7Y3NzQ2xhc3Nlcy5ISURFX1RSQU5TSVRJT059ICR7Y3NzQ2xhc3Nlcy5ISURFfWBcclxuICAgICAgICAgICAgfX1cclxuICAgICAgICAgICAgb25FbnRlcmluZz17aGFuZGxlRW50ZXJpbmd9XHJcbiAgICAgICAgICAgIG1vdW50T25FbnRlclxyXG4gICAgICAgICAgICB1bm1vdW50T25FeGl0XHJcbiAgICAgICAgPlxyXG4gICAgICAgICAgICA8RWxlbWVudFxyXG4gICAgICAgICAgICAgICAgcmVmPXt0b29sdGlwUmVmfVxyXG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lPXtjbGFzc05hbWVzfVxyXG4gICAgICAgICAgICAgICAgcm9sZT1cInRvb2x0aXBcIlxyXG4gICAgICAgICAgICAgICAgYXJpYS1oaWRkZW49e2FjdGl2ZSA/IHVuZGVmaW5lZCA6ICd0cnVlJ31cclxuICAgICAgICAgICAgPlxyXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9e2Ake2Nzc0NsYXNzZXMuU1VSRkFDRX0gJHtjc3NDbGFzc2VzLlNVUkZBQ0VfQU5JTUFUSU9OfWB9PlxyXG4gICAgICAgICAgICAgICAgICAgIHtsYWJlbH1cclxuICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICA8L0VsZW1lbnQ+XHJcbiAgICAgICAgPC9MYXllcj5cclxuICAgIDwvPik7XHJcbn0pO1xyXG5cclxuVG9vbHRpcC5kaXNwbGF5TmFtZSA9ICdNRENUb29sdGlwJztcclxuXHJcbmV4cG9ydCBkZWZhdWx0IFRvb2x0aXA7IiwiaW1wb3J0IHsgQ2hpbGRyZW4sIGZvcndhcmRSZWYsIHVzZUNhbGxiYWNrLCB1c2VFZmZlY3QsIHVzZUltcGVyYXRpdmVIYW5kbGUsIHVzZVJlZiwgdXNlU3RhdGUgfSBmcm9tICdyZWFjdCc7XHJcbmltcG9ydCBjbGFzc25hbWVzIGZyb20gJ2NsYXNzbmFtZXMnO1xyXG5cclxuaW1wb3J0IHsgQ2xvbmUgfSBmcm9tICcuLi9jb21wb25lbnQnO1xyXG5pbXBvcnQgTGF5ZXIgZnJvbSAnLi4vbGF5ZXInO1xyXG5cclxuaW1wb3J0IHsgbnVtYmVycywgY3NzQ2xhc3NlcyB9IGZyb20gJy4vY29uc3RhbnRzJztcclxuXHJcbmNvbnN0IFJpY2hUb29sdGlwID0gZm9yd2FyZFJlZigoe1xyXG4gICAgdGl0bGUsXHJcbiAgICBjb250ZW50LFxyXG4gICAgYWN0aW9ucyxcclxuXHJcbiAgICBlbGVtZW50OiBFbGVtZW50ID0gJ2RpdicsXHJcbiAgICBjbGFzc05hbWUsXHJcbiAgICBjaGlsZHJlblxyXG59LCByZWYpID0+IHtcclxuICAgIGNvbnN0IHRvb2x0aXBSZWYgPSB1c2VSZWYoKTtcclxuICAgIGNvbnN0IHRhcmdldFJlZiA9IHVzZVJlZigpO1xyXG5cclxuICAgIGNvbnN0IFthY3RpdmUsIHNldEFjdGl2ZV0gPSB1c2VTdGF0ZShmYWxzZSk7XHJcblxyXG4gICAgdXNlSW1wZXJhdGl2ZUhhbmRsZShyZWYsICgpID0+IHRvb2x0aXBSZWYuY3VycmVudCk7XHJcblxyXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgICAgICBmdW5jdGlvbiBoYW5kbGVTY3JvbGwoKSB7XHJcbiAgICAgICAgICAgIHNldEFjdGl2ZShhY3RpdmUgPT4gYWN0aXZlICYmICFhY3RpdmUpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgaGFuZGxlU2Nyb2xsKTtcclxuXHJcbiAgICAgICAgcmV0dXJuICgpID0+IHtcclxuICAgICAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgaGFuZGxlU2Nyb2xsKTtcclxuICAgICAgICB9O1xyXG4gICAgfSwgW10pO1xyXG5cclxuICAgIGNvbnN0IGhhbmRsZVRhcmdldE1vdXNlRW50ZXIgPSB1c2VDYWxsYmFjaygoKSA9PiB7XHJcbiAgICAgICAgc2V0QWN0aXZlKHRydWUpO1xyXG4gICAgfSwgW10pO1xyXG5cclxuICAgIGNvbnN0IGhhbmRsZVRhcmdldE1vdXNlTGVhdmUgPSB1c2VDYWxsYmFjaygoKSA9PiB7XHJcbiAgICAgICAgc2V0QWN0aXZlKGZhbHNlKTtcclxuICAgIH0sIFtdKTtcclxuXHJcbiAgICBjb25zdCBoYW5kbGVUb29sdGlwTW91c2VFbnRlciA9IHVzZUNhbGxiYWNrKCgpID0+IHtcclxuICAgICAgICBzZXRBY3RpdmUodHJ1ZSk7XHJcbiAgICB9LCBbXSk7XHJcblxyXG4gICAgY29uc3QgaGFuZGxlVG9vbHRpcE1vdXNlTGVhdmUgPSB1c2VDYWxsYmFjaygoKSA9PiB7XHJcbiAgICAgICAgc2V0QWN0aXZlKGZhbHNlKTtcclxuICAgIH0sIFtdKTtcclxuXHJcbiAgICBjb25zdCBoYW5kbGVFbnRlcmluZyA9IHVzZUNhbGxiYWNrKCgpID0+IHtcclxuICAgICAgICBjb25zdCB0b29sdGlwUmVjdCA9IHRvb2x0aXBSZWYuY3VycmVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcclxuICAgICAgICBjb25zdCB0YXJnZXRSZWN0ID0gdGFyZ2V0UmVmLmN1cnJlbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XHJcblxyXG4gICAgICAgIGNvbnN0IHdpZHRoID0gdG9vbHRpcFJlZi5jdXJyZW50LmZpcnN0Q2hpbGQuY2xpZW50V2lkdGg7XHJcbiAgICAgICAgY29uc3QgaGVpZ2h0ID0gdG9vbHRpcFJlZi5jdXJyZW50LmZpcnN0Q2hpbGQuc2Nyb2xsSGVpZ2h0O1xyXG4gICAgICAgIGNvbnN0IHRvcCA9IHRhcmdldFJlY3QuYm90dG9tICsgd2luZG93LnNjcm9sbFkgKyBudW1iZXJzLlVOQk9VTkRFRF9BTkNIT1JfR0FQO1xyXG4gICAgICAgIGNvbnN0IGxlZnQgPSB0YXJnZXRSZWN0LnJpZ2h0ICsgd2luZG93LnNjcm9sbFggKyBudW1iZXJzLlVOQk9VTkRFRF9BTkNIT1JfR0FQO1xyXG4gICAgICAgIGNvbnN0IHJpZ2h0ID0gbGVmdCArIHdpZHRoICsgbnVtYmVycy5NSU5fVklFV1BPUlRfVE9PTFRJUF9USFJFU0hPTEQ7XHJcbiAgICAgICAgY29uc3QgYm90dG9tID0gdG9wICsgaGVpZ2h0ICsgbnVtYmVycy5NSU5fVklFV1BPUlRfVE9PTFRJUF9USFJFU0hPTEQ7XHJcbiAgICAgICAgY29uc3Qgb3ZlcmZsb3dCb3R0b20gPSB3aW5kb3cuaW5uZXJIZWlnaHQgLSBib3R0b207XHJcbiAgICAgICAgY29uc3Qgb3ZlcmZsb3dSaWdodCA9IHdpbmRvdy5pbm5lcldpZHRoIC0gcmlnaHQ7XHJcblxyXG4gICAgICAgIGlmIChvdmVyZmxvd0JvdHRvbSA8IDApIHtcclxuICAgICAgICAgICAgdG9vbHRpcFJlZi5jdXJyZW50LnN0eWxlLnRvcCA9IGAke3RvcCArIG92ZXJmbG93Qm90dG9tfXB4YDtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0b29sdGlwUmVmLmN1cnJlbnQuc3R5bGUudG9wID0gYCR7dG9wfXB4YDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChvdmVyZmxvd1JpZ2h0IDwgMCkge1xyXG4gICAgICAgICAgICB0b29sdGlwUmVmLmN1cnJlbnQuc3R5bGUubGVmdCA9IGAke3RhcmdldFJlY3QucmlnaHQgLSB0b29sdGlwUmVjdC53aWR0aH1weGA7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdG9vbHRpcFJlZi5jdXJyZW50LnN0eWxlLmxlZnQgPSBgJHtsZWZ0IDwgMCA/IHRhcmdldFJlY3QubGVmdCA6IGxlZnR9cHhgO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdG9vbHRpcFJlZi5jdXJyZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xyXG4gICAgfSwgW10pO1xyXG5cclxuICAgIGNvbnN0IGNsYXNzTmFtZXMgPSBjbGFzc25hbWVzKGNzc0NsYXNzZXMuUk9PVCwgY3NzQ2xhc3Nlcy5SSUNILCBjbGFzc05hbWUpO1xyXG5cclxuICAgIHJldHVybiAoPD5cclxuICAgICAgICA8Q2xvbmVcclxuICAgICAgICAgICAgY29tcG9uZW50PXtjaGlsZHJlbn1cclxuICAgICAgICAgICAgcmVmPXt0YXJnZXRSZWZ9XHJcbiAgICAgICAgICAgIG9uTW91c2VFbnRlcj17aGFuZGxlVGFyZ2V0TW91c2VFbnRlcn1cclxuICAgICAgICAgICAgb25Nb3VzZUxlYXZlPXtoYW5kbGVUYXJnZXRNb3VzZUxlYXZlfVxyXG4gICAgICAgIC8+XHJcblxyXG4gICAgICAgIDxMYXllclxyXG4gICAgICAgICAgICBtb2RhbFxyXG4gICAgICAgICAgICBpbj17YWN0aXZlfVxyXG4gICAgICAgICAgICB0aW1lb3V0PXt7XHJcbiAgICAgICAgICAgICAgICBlbnRlcjogbnVtYmVycy5TSE9XX0RFTEFZX01TLFxyXG4gICAgICAgICAgICAgICAgZXhpdDogbnVtYmVycy5ISURFX0RFTEFZX01TXHJcbiAgICAgICAgICAgIH19XHJcbiAgICAgICAgICAgIGNsYXNzTmFtZXM9e3tcclxuICAgICAgICAgICAgICAgIGVudGVyOiBjc3NDbGFzc2VzLlNIT1dJTkdfVFJBTlNJVElPTixcclxuICAgICAgICAgICAgICAgIGVudGVyQWN0aXZlOiBgJHtjc3NDbGFzc2VzLlNIT1dJTkdfVFJBTlNJVElPTn0gJHtjc3NDbGFzc2VzLlNIT1dJTkd9YCxcclxuICAgICAgICAgICAgICAgIGVudGVyRG9uZTogYCR7Y3NzQ2xhc3Nlcy5TSE9XSU5HX1RSQU5TSVRJT059ICR7Y3NzQ2xhc3Nlcy5TSE9XTn1gLFxyXG4gICAgICAgICAgICAgICAgZXhpdDogY3NzQ2xhc3Nlcy5TSE9XTixcclxuICAgICAgICAgICAgICAgIGV4aXRBY3RpdmU6IGAke2Nzc0NsYXNzZXMuSElERV9UUkFOU0lUSU9OfSAke2Nzc0NsYXNzZXMuU0hPV059YCxcclxuICAgICAgICAgICAgICAgIGV4aXREb25lOiBgJHtjc3NDbGFzc2VzLkhJREVfVFJBTlNJVElPTn0gJHtjc3NDbGFzc2VzLkhJREV9YFxyXG4gICAgICAgICAgICB9fVxyXG4gICAgICAgICAgICBtb3VudE9uRW50ZXJcclxuICAgICAgICAgICAgdW5tb3VudE9uRXhpdFxyXG4gICAgICAgICAgICBvbkVudGVyaW5nPXtoYW5kbGVFbnRlcmluZ31cclxuICAgICAgICA+XHJcbiAgICAgICAgICAgIDxFbGVtZW50XHJcbiAgICAgICAgICAgICAgICByZWY9e3Rvb2x0aXBSZWZ9XHJcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU9e2NsYXNzTmFtZXN9XHJcbiAgICAgICAgICAgICAgICByb2xlPVwidG9vbHRpcFwiXHJcbiAgICAgICAgICAgICAgICBhcmlhLWhpZGRlbj17YWN0aXZlID8gdW5kZWZpbmVkIDogJ3RydWUnfVxyXG4gICAgICAgICAgICAgICAgYXJpYS1leHBhbmRlZD17YWN0aXZlID8gJ3RydWUnIDogdW5kZWZpbmVkfVxyXG4gICAgICAgICAgICAgICAgb25Nb3VzZUVudGVyPXtoYW5kbGVUb29sdGlwTW91c2VFbnRlcn1cclxuICAgICAgICAgICAgICAgIG9uTW91c2VMZWF2ZT17aGFuZGxlVG9vbHRpcE1vdXNlTGVhdmV9XHJcbiAgICAgICAgICAgID5cclxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXtgJHtjc3NDbGFzc2VzLlNVUkZBQ0V9ICR7Y3NzQ2xhc3Nlcy5TVVJGQUNFX0FOSU1BVElPTn1gfT5cclxuICAgICAgICAgICAgICAgICAgICB7dGl0bGUgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgPGgyIGNsYXNzTmFtZT17Y3NzQ2xhc3Nlcy5USVRMRX0+e3RpdGxlfTwvaDI+XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICB7Y29udGVudCAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8cCBjbGFzc05hbWU9e2Nzc0NsYXNzZXMuQ09OVEVOVH0+e2NvbnRlbnR9PC9wPlxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAge2FjdGlvbnMgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9e2Nzc0NsYXNzZXMuQUNUSU9OU30+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7Q2hpbGRyZW4ubWFwKGFjdGlvbnMsIGFjdGlvbiA9PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxDbG9uZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21wb25lbnQ9e2FjdGlvbn1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJpYS1sYWJlbD1cImFjdGlvblwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLz5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICl9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICA8L0VsZW1lbnQ+XHJcbiAgICAgICAgPC9MYXllcj5cclxuICAgIDwvPik7XHJcbn0pO1xyXG5cclxuUmljaFRvb2x0aXAuZGlzcGxheU5hbWUgPSAnTURDUmljaFRvb2x0aXAnO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgUmljaFRvb2x0aXA7IiwiZXhwb3J0IHsgZGVmYXVsdCBhcyBUb29sdGlwIH0gZnJvbSAnLi9Ub29sdGlwJztcclxuZXhwb3J0IHsgZGVmYXVsdCBhcyBSaWNoVG9vbHRpcCB9IGZyb20gJy4vUmljaFRvb2x0aXAnOyIsImV4cG9ydCBjb25zdCBjc3NDbGFzc2VzID0ge1xyXG4gICAgUk9PVDogJ21kYy10ZXh0LWZpZWxkJyxcclxuICAgIEZJTExFRDogJ21kYy10ZXh0LWZpZWxkLS1maWxsZWQnLFxyXG4gICAgT1VUTElORUQ6ICdtZGMtdGV4dC1maWVsZC0tb3V0bGluZWQnLFxyXG4gICAgVEVYVEFSRUE6ICdtZGMtdGV4dC1maWVsZC0tdGV4dGFyZWEnLFxyXG4gICAgRElTQUJMRUQ6ICdtZGMtdGV4dC1maWVsZC0tZGlzYWJsZWQnLFxyXG4gICAgRk9DVVNFRDogJ21kYy10ZXh0LWZpZWxkLS1mb2N1c2VkJyxcclxuICAgIElOVkFMSUQ6ICdtZGMtdGV4dC1maWVsZC0taW52YWxpZCcsXHJcbiAgICBMQUJFTF9GTE9BVElORzogJ21kYy10ZXh0LWZpZWxkLS1sYWJlbC1mbG9hdGluZycsXHJcbiAgICBOT19MQUJFTDogJ21kYy10ZXh0LWZpZWxkLS1uby1sYWJlbCcsXHJcbiAgICBFTkRfQUxJR05FRDogJ21kYy10ZXh0LWZpZWxkLS1lbmQtYWxpZ25lZCcsXHJcbiAgICBXSVRIX0xFQURJTkdfSUNPTjogJ21kYy10ZXh0LWZpZWxkLS13aXRoLWxlYWRpbmctaWNvbicsXHJcbiAgICBXSVRIX1RSQUlMSU5HX0lDT046ICdtZGMtdGV4dC1maWVsZC0td2l0aC10cmFpbGluZy1pY29uJyxcclxuICAgIFdJVEhfSU5URVJOQUxfQ09VTlRFUjogJ21kYy10ZXh0LWZpZWxkLS13aXRoLWludGVybmFsLWNvdW50ZXInLFxyXG5cclxuICAgIElDT046ICdtZGMtdGV4dC1maWVsZF9faWNvbicsXHJcbiAgICBJQ09OX0xFQURJTkc6ICdtZGMtdGV4dC1maWVsZF9faWNvbi0tbGVhZGluZycsXHJcbiAgICBJQ09OX1RSQUlMSU5HOiAnbWRjLXRleHQtZmllbGRfX2ljb24tLXRyYWlsaW5nJyxcclxuXHJcbiAgICBJTlBVVDogJ21kYy10ZXh0LWZpZWxkX19pbnB1dCcsXHJcblxyXG4gICAgQUZGSVg6ICdtZGMtdGV4dC1maWVsZF9fYWZmaXgnLFxyXG4gICAgQUZGSVhfUFJFRklYOiAnbWRjLXRleHQtZmllbGRfX2FmZml4LS1wcmVmaXgnLFxyXG4gICAgQUZGSVhfU1VGRklYOiAnbWRjLXRleHQtZmllbGRfX2FmZml4LS1zdWZmaXgnLFxyXG5cclxuICAgIFJFU0laRVI6ICdtZGMtdGV4dC1maWVsZF9fcmVzaXplcicsXHJcblxyXG4gICAgUklQUExFOiAnbWRjLXRleHQtZmllbGRfX3JpcHBsZScsXHJcblxyXG4gICAgSEVMUEVSX0xJTkU6ICdtZGMtdGV4dC1maWVsZC1oZWxwZXItbGluZScsXHJcbiAgICBIRUxQRVJfVEVYVDogJ21kYy10ZXh0LWZpZWxkLWhlbHBlci10ZXh0JyxcclxuICAgIEhFTFBFUl9URVhUX1BFUlNJU1RFTlQ6ICdtZGMtdGV4dC1maWVsZC1oZWxwZXItdGV4dC0tcGVyc2lzdGVudCcsXHJcbiAgICBIRUxQRVJfVEVYVF9WQUxJREFUSU9OOiAnbWRjLXRleHQtZmllbGQtaGVscGVyLXRleHQtLXZhbGlkYXRpb24tbXNnJyxcclxuXHJcbiAgICBDSEFSQUNURVJfQ09VTlRFUjogJ21kYy10ZXh0LWZpZWxkLWNoYXJhY3Rlci1jb3VudGVyJyxcclxufTsiLCJpbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xyXG5pbXBvcnQgY2xhc3NuYW1lcyBmcm9tICdjbGFzc25hbWVzJztcclxuXHJcbmltcG9ydCB7IGNzc0NsYXNzZXMgfSBmcm9tICcuL2NvbnN0YW50cyc7XHJcblxyXG5jb25zdCBIZWxwZXJUZXh0ID0gKHtcclxuICAgIHBlcnNpc3RlbnQgPSBmYWxzZSxcclxuICAgIHZhbGlkYXRpb24gPSBmYWxzZSxcclxuXHJcbiAgICAuLi5wcm9wc1xyXG59KSA9PiB7XHJcbiAgICBjb25zdCBjbGFzc05hbWVzID0gY2xhc3NuYW1lcyhjc3NDbGFzc2VzLkhFTFBFUl9URVhULCB7XHJcbiAgICAgICAgW2Nzc0NsYXNzZXMuSEVMUEVSX1RFWFRfUEVSU0lTVEVOVF06IHBlcnNpc3RlbnQsXHJcbiAgICAgICAgW2Nzc0NsYXNzZXMuSEVMUEVSX1RFWFRfVkFMSURBVElPTl06IHZhbGlkYXRpb25cclxuICAgIH0pO1xyXG5cclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgPGRpdiBjbGFzc05hbWU9e2NsYXNzTmFtZXN9IHsuLi5wcm9wc30gLz5cclxuICAgICk7XHJcbn07XHJcblxyXG5IZWxwZXJUZXh0LmRpc3BsYXlOYW1lID0gJ01EQ1RleHRGaWVsZEhlbHBlclRleHQnO1xyXG5cclxuSGVscGVyVGV4dC5wcm9wVHlwZXMgPSB7XHJcbiAgICBwZXJzaXN0ZW50OiBQcm9wVHlwZXMuYm9vbCxcclxuICAgIHZhbGlkYXRpb246IFByb3BUeXBlcy5ib29sXHJcbn07XHJcblxyXG5leHBvcnQgZGVmYXVsdCBIZWxwZXJUZXh0OyIsImltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBDaGFyYWN0ZXJDb3VudGVyKHtcclxuICAgIHZhbHVlID0gMCxcclxuICAgIG1heFZhbHVlLFxyXG5cclxuICAgIC4uLnByb3BzXHJcbn0pIHtcclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJtZGMtdGV4dC1maWVsZC1jaGFyYWN0ZXItY291bnRlclwiIHsuLi5wcm9wc30+XHJcbiAgICAgICAgICAgIHt2YWx1ZSArIChtYXhWYWx1ZSA/IGAgLyAke21heFZhbHVlfWAgOiAnJyl9XHJcbiAgICAgICAgPC9kaXY+XHJcbiAgICApO1xyXG59XHJcblxyXG5DaGFyYWN0ZXJDb3VudGVyLmRpc3BsYXlOYW1lID0gJ01EQ1RleHRGaWVsZENoYXJhY3RlckNvdW50ZXInO1xyXG5cclxuQ2hhcmFjdGVyQ291bnRlci5wcm9wVHlwZXMgPSB7XHJcbiAgICB2YWx1ZTogUHJvcFR5cGVzLm51bWJlcixcclxuICAgIG1heFZhbHVlOiBQcm9wVHlwZXMubnVtYmVyXHJcbn07IiwiaW1wb3J0IHsgZm9yd2FyZFJlZiwgdXNlTGF5b3V0RWZmZWN0IH0gZnJvbSAncmVhY3QnO1xyXG5cclxuaW1wb3J0IHsgY3NzQ2xhc3NlcyB9IGZyb20gJy4vY29uc3RhbnRzJztcclxuXHJcbmNvbnN0IElucHV0ID0gZm9yd2FyZFJlZigoe1xyXG4gICAgdGV4dGFyZWEsXHJcbiAgICBhdXRvUmVzaXplLFxyXG4gICAgZWxlbWVudDogRWxlbWVudCA9IHRleHRhcmVhID8gJ3RleHRhcmVhJyA6ICdpbnB1dCcsXHJcbiAgICAuLi5wcm9wc1xyXG59LCByZWYpID0+IHtcclxuICAgIHVzZUxheW91dEVmZmVjdCgoKSA9PiB7XHJcbiAgICAgICAgaWYgKCFhdXRvUmVzaXplKSByZXR1cm47XHJcblxyXG4gICAgICAgIGNvbnN0IGVsZW1lbnQgPSByZWYuY3VycmVudDtcclxuXHJcbiAgICAgICAgZnVuY3Rpb24gc2V0SGVpZ2h0KCkge1xyXG4gICAgICAgICAgICBlbGVtZW50LnN0eWxlLmhlaWdodCA9ICcxcmVtJztcclxuICAgICAgICAgICAgZWxlbWVudC5zdHlsZS5oZWlnaHQgPSBgJHtlbGVtZW50LnNjcm9sbEhlaWdodH1weGA7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBzZXRIZWlnaHQoKTtcclxuXHJcbiAgICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdpbnB1dCcsIHNldEhlaWdodCk7XHJcblxyXG4gICAgICAgIHJldHVybiAoKSA9PiBlbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2lucHV0Jywgc2V0SGVpZ2h0KTtcclxuICAgIH0sIFthdXRvUmVzaXplLCByZWZdKTtcclxuXHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAgIDxFbGVtZW50XHJcbiAgICAgICAgICAgIHJlZj17cmVmfVxyXG4gICAgICAgICAgICBjbGFzc05hbWU9e2Nzc0NsYXNzZXMuSU5QVVR9XHJcbiAgICAgICAgICAgIHsuLi5wcm9wc31cclxuICAgICAgICAvPlxyXG4gICAgKTtcclxufSk7XHJcblxyXG5JbnB1dC5kaXNwbGF5TmFtZSA9ICdNRENUZXh0RmllbGRJbnB1dCc7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBJbnB1dDsiLCJpbXBvcnQgeyBjc3NDbGFzc2VzIH0gZnJvbSAnLi9jb25zdGFudHMnO1xyXG5cclxuY29uc3QgUmVzaXplciA9ICh7XHJcbiAgICB0ZXh0YXJlYSxcclxuICAgIGF1dG9SZXNpemUsXHJcbiAgICBjaGlsZHJlbixcclxuICAgIC4uLnByb3BzXHJcbn0pID0+IHtcclxuICAgIHJldHVybiAodGV4dGFyZWEgJiYgIWF1dG9SZXNpemUpID8gKFxyXG4gICAgICAgIDxzcGFuIGNsYXNzTmFtZT17Y3NzQ2xhc3Nlcy5SRVNJWkVSfSB7Li4ucHJvcHN9PlxyXG4gICAgICAgICAgICB7Y2hpbGRyZW59XHJcbiAgICAgICAgPC9zcGFuPlxyXG4gICAgKSA6IGNoaWxkcmVuO1xyXG59O1xyXG5cclxuUmVzaXplci5kaXNwbGF5TmFtZSA9ICdNRENUZXh0RmllbGRSZXNpemVyJztcclxuXHJcbmV4cG9ydCBkZWZhdWx0IFJlc2l6ZXI7IiwiaW1wb3J0IHsgZm9yd2FyZFJlZiwgdXNlUmVmLCB1c2VTdGF0ZSwgdXNlQ2FsbGJhY2sgfSBmcm9tICdyZWFjdCc7XHJcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XHJcbmltcG9ydCBjbGFzc25hbWVzIGZyb20gJ2NsYXNzbmFtZXMnO1xyXG5cclxuaW1wb3J0IHsgQ2xvbmUgfSBmcm9tICcuLi9jb21wb25lbnQnO1xyXG5pbXBvcnQgTm90Y2hlZE91dGxpbmUgZnJvbSAnLi4vbm90Y2hlZC1vdXRsaW5lJztcclxuaW1wb3J0IExpbmVSaXBwbGUgZnJvbSAnLi4vbGluZS1yaXBwbGUnO1xyXG5pbXBvcnQgRmxvYXRpbmdMYWJlbCBmcm9tICcuLi9mbG9hdGluZy1sYWJlbCc7XHJcbmltcG9ydCBJY29uIGZyb20gJy4uL2ljb24nO1xyXG5cclxuaW1wb3J0IHsgY3NzQ2xhc3NlcyB9IGZyb20gJy4vY29uc3RhbnRzJztcclxuaW1wb3J0IEhlbHBlclRleHQgZnJvbSAnLi9IZWxwZXJUZXh0JztcclxuaW1wb3J0IENoYXJhY3RlckNvdW50ZXIgZnJvbSAnLi9DaGFyYWN0ZXJDb3VudGVyJztcclxuaW1wb3J0IElucHV0IGZyb20gJy4vSW5wdXQnO1xyXG5pbXBvcnQgUmVzaXplciBmcm9tICcuL1Jlc2l6ZXInO1xyXG5cclxuY29uc3QgVGV4dEZpZWxkID0gZm9yd2FyZFJlZigoe1xyXG4gICAgdmFsdWUsXHJcbiAgICBkZWZhdWx0VmFsdWUsXHJcbiAgICBsYWJlbCxcclxuICAgIGxlYWRpbmdJY29uLFxyXG4gICAgdHJhaWxpbmdJY29uLFxyXG4gICAgcHJlZml4LFxyXG4gICAgc3VmZml4LFxyXG4gICAgcGVyc2lzdGVudEhlbHBlclRleHQsXHJcbiAgICBoZWxwZXJUZXh0ID0gcGVyc2lzdGVudEhlbHBlclRleHQsXHJcbiAgICB2YWxpZGF0aW9uTWVzc2FnZSxcclxuICAgIGZpbGxlZCA9IGZhbHNlLFxyXG4gICAgb3V0bGluZWQgPSBmYWxzZSxcclxuICAgIGZ1bGxXaWR0aCA9IGZhbHNlLFxyXG4gICAgZGlzYWJsZWQgPSBmYWxzZSxcclxuICAgIHRleHRhcmVhID0gZmFsc2UsXHJcbiAgICBlbmRBbGlnbmVkID0gZmFsc2UsXHJcbiAgICBhdXRvUmVzaXplID0gZmFsc2UsXHJcbiAgICBjaGFyYWN0ZXJDb3VudGVyID0gZmFsc2UsXHJcbiAgICBpbnRlcm5hbENoYXJhY3RlckNvdW50ZXIgPSBjaGFyYWN0ZXJDb3VudGVyID09PSAnaW50ZXJuYWwnLFxyXG5cclxuICAgIGNsYXNzTmFtZSxcclxuICAgIGVsZW1lbnQ6IEVsZW1lbnQgPSAnbGFiZWwnLFxyXG4gICAgb25DaGFuZ2UgPSBGdW5jdGlvbi5wcm90b3R5cGUsXHJcbiAgICAuLi5wcm9wc1xyXG59LCByZWYpID0+IHtcclxuICAgIGNvbnN0IGlucHV0UmVmID0gdXNlUmVmKCk7XHJcblxyXG4gICAgY29uc3QgW2ZvY3VzZWQsIHNldEZvY3VzZWRdID0gdXNlU3RhdGUoZmFsc2UpO1xyXG4gICAgY29uc3QgW3RvdWNoZWQsIHNldFRvdWNoZWRdID0gdXNlU3RhdGUoZmFsc2UpO1xyXG4gICAgY29uc3QgW3ZhbGlkLCBzZXRWYWxpZF0gPSB1c2VTdGF0ZSh0cnVlKTtcclxuICAgIGNvbnN0IFtpbnRlcmFjdGlvbkNvb3Jkcywgc2V0SW50ZXJhY3Rpb25Db29yZHNdID0gdXNlU3RhdGUoKTtcclxuICAgIGNvbnN0IFtjb3VudCwgc2V0Q291bnRdID0gdXNlU3RhdGUodmFsdWU/Lmxlbmd0aCB8fCBkZWZhdWx0VmFsdWU/LnZhbHVlIHx8IDApO1xyXG5cclxuICAgIGNvbnN0IGhhbmRsZUludGVyYWN0aW9uID0gdXNlQ2FsbGJhY2soZXZlbnQgPT4ge1xyXG4gICAgICAgIGNvbnN0IHRhcmdldENsaWVudFJlY3QgPSBldmVudC50YXJnZXQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XHJcblxyXG4gICAgICAgIHNldEludGVyYWN0aW9uQ29vcmRzKHtcclxuICAgICAgICAgICAgeDogZXZlbnQuY2xpZW50WCAtIHRhcmdldENsaWVudFJlY3QubGVmdCxcclxuICAgICAgICAgICAgeTogZXZlbnQuY2xpZW50WSAtIHRhcmdldENsaWVudFJlY3QudG9wXHJcbiAgICAgICAgfSk7XHJcbiAgICB9LCBbXSk7XHJcblxyXG4gICAgY29uc3QgaGFuZGxlSW5wdXRGb2N1cyA9IHVzZUNhbGxiYWNrKCgpID0+IHtcclxuICAgICAgICBzZXRGb2N1c2VkKHRydWUpO1xyXG4gICAgICAgIHNldFRvdWNoZWQodHJ1ZSk7XHJcbiAgICB9LCBbXSk7XHJcblxyXG4gICAgY29uc3QgaGFuZGxlSW5wdXRCbHVyID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xyXG4gICAgICAgIHNldEZvY3VzZWQoZmFsc2UpO1xyXG4gICAgICAgIHNldEludGVyYWN0aW9uQ29vcmRzKCk7XHJcbiAgICB9LCBbXSk7XHJcblxyXG4gICAgY29uc3QgaGFuZGxlSW5wdXRDaGFuZ2UgPSB1c2VDYWxsYmFjayhldmVudCA9PiB7XHJcbiAgICAgICAgY29uc3QgdmFsdWUgPSBpbnB1dFJlZi5jdXJyZW50LnZhbHVlO1xyXG4gICAgICAgIGNvbnN0IGlzVmFsaWQgPSBpbnB1dFJlZi5jdXJyZW50Py52YWxpZGl0eS52YWxpZDtcclxuXHJcbiAgICAgICAgc2V0Q291bnQodmFsdWUubGVuZ3RoKTtcclxuICAgICAgICBzZXRWYWxpZChpc1ZhbGlkKTtcclxuICAgICAgICBvbkNoYW5nZShldmVudCwgdmFsdWUpO1xyXG4gICAgfSwgW29uQ2hhbmdlXSk7XHJcblxyXG4gICAgY29uc3QgZm9jdXNlZE9ySGFzVmFsdWUgPSAoXHJcbiAgICAgICAgZm9jdXNlZCB8fFxyXG4gICAgICAgICh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHZhbHVlICE9PSBudWxsICYmIHZhbHVlICE9PSAnJykgfHxcclxuICAgICAgICAoZGVmYXVsdFZhbHVlICE9PSB1bmRlZmluZWQgJiYgZGVmYXVsdFZhbHVlICE9PSBudWxsICYmIGRlZmF1bHRWYWx1ZSAhPT0gJycpIHx8XHJcbiAgICAgICAgQm9vbGVhbihpbnB1dFJlZi5jdXJyZW50Py52YWx1ZSlcclxuICAgICk7XHJcblxyXG4gICAgY29uc3QgaGFzSGVscGVyTGluZSA9IGhlbHBlclRleHQgfHwgdmFsaWRhdGlvbk1lc3NhZ2UgfHwgY2hhcmFjdGVyQ291bnRlcjtcclxuXHJcbiAgICBjb25zdCBjbGFzc05hbWVzID0gY2xhc3NuYW1lcyhjc3NDbGFzc2VzLlJPT1QsIHtcclxuICAgICAgICBbY3NzQ2xhc3Nlcy5GSUxMRURdOiBmaWxsZWQgJiYgIWZ1bGxXaWR0aCxcclxuICAgICAgICBbY3NzQ2xhc3Nlcy5PVVRMSU5FRF06IG91dGxpbmVkICYmICFmdWxsV2lkdGgsXHJcbiAgICAgICAgW2Nzc0NsYXNzZXMuVEVYVEFSRUFdOiB0ZXh0YXJlYSxcclxuICAgICAgICBbY3NzQ2xhc3Nlcy5ESVNBQkxFRF06IGRpc2FibGVkLFxyXG4gICAgICAgIFtjc3NDbGFzc2VzLkZPQ1VTRURdOiBmb2N1c2VkLFxyXG4gICAgICAgIFtjc3NDbGFzc2VzLklOVkFMSURdOiAhdmFsaWQgJiYgdG91Y2hlZCxcclxuICAgICAgICBbY3NzQ2xhc3Nlcy5MQUJFTF9GTE9BVElOR106IGZvY3VzZWRPckhhc1ZhbHVlLFxyXG4gICAgICAgIFtjc3NDbGFzc2VzLk5PX0xBQkVMXTogIWxhYmVsLFxyXG4gICAgICAgIFtjc3NDbGFzc2VzLkVORF9BTElHTkVEXTogZW5kQWxpZ25lZCxcclxuICAgICAgICBbY3NzQ2xhc3Nlcy5XSVRIX0xFQURJTkdfSUNPTl06IGxlYWRpbmdJY29uLFxyXG4gICAgICAgIFtjc3NDbGFzc2VzLldJVEhfVFJBSUxJTkdfSUNPTl06IHRyYWlsaW5nSWNvbixcclxuICAgICAgICBbY3NzQ2xhc3Nlcy5XSVRIX0lOVEVSTkFMX0NPVU5URVJdOiBpbnRlcm5hbENoYXJhY3RlckNvdW50ZXJcclxuICAgIH0sIGNsYXNzTmFtZSk7XHJcblxyXG4gICAgcmV0dXJuICg8PlxyXG4gICAgICAgIDxFbGVtZW50XHJcbiAgICAgICAgICAgIHJlZj17cmVmfVxyXG4gICAgICAgICAgICBjbGFzc05hbWU9e2NsYXNzTmFtZXN9XHJcbiAgICAgICAgICAgIG9uTW91c2VEb3duPXtoYW5kbGVJbnRlcmFjdGlvbn1cclxuICAgICAgICAgICAgb25Ub3VjaFN0YXJ0PXtoYW5kbGVJbnRlcmFjdGlvbn1cclxuICAgICAgICA+XHJcbiAgICAgICAgICAgIHtmaWxsZWQgJiZcclxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXtjc3NDbGFzc2VzLlJJUFBMRX0gLz5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAge2ZpbGxlZCAmJiBsYWJlbCAmJlxyXG4gICAgICAgICAgICAgICAgPEZsb2F0aW5nTGFiZWxcclxuICAgICAgICAgICAgICAgICAgICBsYWJlbD17bGFiZWx9XHJcbiAgICAgICAgICAgICAgICAgICAgZmxvYXQ9e2ZvY3VzZWRPckhhc1ZhbHVlfVxyXG4gICAgICAgICAgICAgICAgLz5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAge291dGxpbmVkICYmXHJcbiAgICAgICAgICAgICAgICA8Tm90Y2hlZE91dGxpbmUgbm90Y2hlZD17Zm9jdXNlZE9ySGFzVmFsdWV9PlxyXG4gICAgICAgICAgICAgICAgICAgIHtsYWJlbCAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8RmxvYXRpbmdMYWJlbFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWw9e2xhYmVsfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmxvYXQ9e2ZvY3VzZWRPckhhc1ZhbHVlfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvPlxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIDwvTm90Y2hlZE91dGxpbmU+XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHtsZWFkaW5nSWNvbiAmJlxyXG4gICAgICAgICAgICAgICAgPENsb25lXHJcbiAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50PXtsZWFkaW5nSWNvbn1cclxuICAgICAgICAgICAgICAgICAgICBmYWxsYmFjaz17SWNvbn1cclxuICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU9e2Ake2Nzc0NsYXNzZXMuSUNPTn0gJHtjc3NDbGFzc2VzLklDT05fTEVBRElOR31gfVxyXG4gICAgICAgICAgICAgICAgICAgIHRhYkluZGV4PVwiMFwiXHJcbiAgICAgICAgICAgICAgICAgICAgcm9sZT1cImJ1dHRvblwiXHJcbiAgICAgICAgICAgICAgICAvPlxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB7cHJlZml4ICYmXHJcbiAgICAgICAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9e2Ake2Nzc0NsYXNzZXMuQUZGSVh9ICR7Y3NzQ2xhc3Nlcy5BRkZJWF9QUkVGSVh9YH0+e3ByZWZpeH08L3NwYW4+XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIDxSZXNpemVyXHJcbiAgICAgICAgICAgICAgICB0ZXh0YXJlYT17dGV4dGFyZWF9XHJcbiAgICAgICAgICAgICAgICBhdXRvUmVzaXplPXthdXRvUmVzaXplfVxyXG4gICAgICAgICAgICA+XHJcbiAgICAgICAgICAgICAgICA8SW5wdXRcclxuICAgICAgICAgICAgICAgICAgICByZWY9e2lucHV0UmVmfVxyXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlPXt2YWx1ZX1cclxuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0VmFsdWU9e2RlZmF1bHRWYWx1ZX1cclxuICAgICAgICAgICAgICAgICAgICB0ZXh0YXJlYT17dGV4dGFyZWF9XHJcbiAgICAgICAgICAgICAgICAgICAgYXV0b1Jlc2l6ZT17YXV0b1Jlc2l6ZX1cclxuICAgICAgICAgICAgICAgICAgICBkaXNhYmxlZD17ZGlzYWJsZWR9XHJcbiAgICAgICAgICAgICAgICAgICAgb25JbnB1dD17aGFuZGxlSW5wdXRDaGFuZ2V9XHJcbiAgICAgICAgICAgICAgICAgICAgb25Gb2N1cz17aGFuZGxlSW5wdXRGb2N1c31cclxuICAgICAgICAgICAgICAgICAgICBvbkJsdXI9e2hhbmRsZUlucHV0Qmx1cn1cclxuICAgICAgICAgICAgICAgICAgICB7Li4ucHJvcHN9XHJcbiAgICAgICAgICAgICAgICAvPlxyXG5cclxuICAgICAgICAgICAgICAgIHtpbnRlcm5hbENoYXJhY3RlckNvdW50ZXIgJiZcclxuICAgICAgICAgICAgICAgICAgICA8Q2hhcmFjdGVyQ291bnRlclxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZT17Y291bnR9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1heFZhbHVlPXtwcm9wcy5tYXhMZW5ndGh9XHJcbiAgICAgICAgICAgICAgICAgICAgLz5cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgPC9SZXNpemVyPlxyXG5cclxuICAgICAgICAgICAge3N1ZmZpeCAmJlxyXG4gICAgICAgICAgICAgICAgPHNwYW4gY2xhc3NOYW1lPXtgJHtjc3NDbGFzc2VzLkFGRklYfSAke2Nzc0NsYXNzZXMuQUZGSVhfU1VGRklYfWB9PntzdWZmaXh9PC9zcGFuPlxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB7dHJhaWxpbmdJY29uICYmXHJcbiAgICAgICAgICAgICAgICA8Q2xvbmVcclxuICAgICAgICAgICAgICAgICAgICBjb21wb25lbnQ9e3RyYWlsaW5nSWNvbn1cclxuICAgICAgICAgICAgICAgICAgICBmYWxsYmFjaz17SWNvbn1cclxuICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU9e2Ake2Nzc0NsYXNzZXMuSUNPTn0gJHtjc3NDbGFzc2VzLklDT05fVFJBSUxJTkd9YH1cclxuICAgICAgICAgICAgICAgICAgICB0YWJJbmRleD1cIjBcIlxyXG4gICAgICAgICAgICAgICAgICAgIHJvbGU9XCJidXR0b25cIlxyXG4gICAgICAgICAgICAgICAgLz5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAge2ZpbGxlZCAmJlxyXG4gICAgICAgICAgICAgICAgPExpbmVSaXBwbGVcclxuICAgICAgICAgICAgICAgICAgICBhY3RpdmU9e2ZvY3VzZWR9XHJcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtT3JpZ2luPXtpbnRlcmFjdGlvbkNvb3Jkcz8ueH1cclxuICAgICAgICAgICAgICAgIC8+XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICA8L0VsZW1lbnQ+XHJcblxyXG4gICAgICAgIHtoYXNIZWxwZXJMaW5lICYmXHJcbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXtjc3NDbGFzc2VzLkhFTFBFUl9MSU5FfT5cclxuICAgICAgICAgICAgICAgIHtoZWxwZXJUZXh0ICYmXHJcbiAgICAgICAgICAgICAgICAgICAgPEhlbHBlclRleHQgcGVyc2lzdGVudD17Qm9vbGVhbihwZXJzaXN0ZW50SGVscGVyVGV4dCl9PntoZWxwZXJUZXh0fTwvSGVscGVyVGV4dD5cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICB7KHZhbGlkYXRpb25NZXNzYWdlICYmICF2YWxpZCkgJiZcclxuICAgICAgICAgICAgICAgICAgICA8SGVscGVyVGV4dCB2YWxpZGF0aW9uPnt0eXBlb2YgdmFsaWRhdGlvbk1lc3NhZ2UgPT09ICdzdHJpbmcnID8gdmFsaWRhdGlvbk1lc3NhZ2UgOiBpbnB1dFJlZi5jdXJyZW50Py52YWxpZGF0aW9uTWVzc2FnZX08L0hlbHBlclRleHQ+XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgeyhjaGFyYWN0ZXJDb3VudGVyICYmICFpbnRlcm5hbENoYXJhY3RlckNvdW50ZXIpICYmXHJcbiAgICAgICAgICAgICAgICAgICAgPENoYXJhY3RlckNvdW50ZXJcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU9e2NvdW50fVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXhWYWx1ZT17cHJvcHMubWF4TGVuZ3RofVxyXG4gICAgICAgICAgICAgICAgICAgIC8+XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgIH1cclxuICAgIDwvPik7XHJcbn0pO1xyXG5cclxuVGV4dEZpZWxkLmRpc3BsYXlOYW1lID0gJ01EQ1RleHRGaWVsZCc7XHJcblxyXG5UZXh0RmllbGQucHJvcFR5cGVzID0ge1xyXG4gICAgdmFsdWU6IFByb3BUeXBlcy5hbnksXHJcbiAgICBsYWJlbDogUHJvcFR5cGVzLnN0cmluZyxcclxuICAgIGxlYWRpbmdJY29uOiBQcm9wVHlwZXMubm9kZSxcclxuICAgIHRyYWlsaW5nSWNvbjogUHJvcFR5cGVzLm5vZGUsXHJcbiAgICBwcmVmaXg6IFByb3BUeXBlcy5zdHJpbmcsXHJcbiAgICBzdWZmaXg6IFByb3BUeXBlcy5zdHJpbmcsXHJcbiAgICBvdXRsaW5lOiBQcm9wVHlwZXMuYm9vbCxcclxuICAgIGZ1bGxXaWR0aDogUHJvcFR5cGVzLmJvb2wsXHJcbiAgICB0ZXh0YXJlYTogUHJvcFR5cGVzLmJvb2wsXHJcbiAgICBkZW5zZTogUHJvcFR5cGVzLmJvb2wsXHJcbiAgICBkaXNhYmxlZDogUHJvcFR5cGVzLmJvb2wsXHJcbiAgICBoZWxwZXJUZXh0OiBQcm9wVHlwZXMuc3RyaW5nLFxyXG4gICAgcGVyc2lzdGVudEhlbHBlclRleHQ6IFByb3BUeXBlcy5zdHJpbmcsXHJcbiAgICB2YWxpZGF0aW9uTWVzc2FnZTogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLmJvb2wsIFByb3BUeXBlcy5zdHJpbmddKVxyXG59O1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgVGV4dEZpZWxkOyIsImV4cG9ydCB7IGRlZmF1bHQgfSBmcm9tICcuL1RleHRGaWVsZCc7IiwiZXhwb3J0IGNvbnN0IG51bWJlcnMgPSB7XHJcbiAgICBERUJPVU5DRV9USFJPVFRMRV9SRVNJWkVfVElNRV9NUzogMTAwLFxyXG4gICAgTUFYX1RPUF9BUFBfQkFSX0hFSUdIVDogMTI4XHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgY3NzQ2xhc3NlcyA9IHtcclxuICAgIFJPT1Q6ICdtZGMtdG9wLWFwcC1iYXInLFxyXG4gICAgU1RJQ0tZOiAnbWRjLXRvcC1hcHAtYmFyLS1zdGlja3knLFxyXG4gICAgU1RJQ0tZX0hJRERFTjogJ21kYy10b3AtYXBwLWJhci0tc3RpY2t5LWhpZGRlbicsXHJcbiAgICBTVElDS1lfU0hPV046ICdtZGMtdG9wLWFwcC1iYXItLXN0aWNreS1zaG93bicsXHJcbiAgICBGSVhFRDogJ21kYy10b3AtYXBwLWJhci0tZml4ZWQnLFxyXG4gICAgRklYRURfU0NST0xMRUQ6ICdtZGMtdG9wLWFwcC1iYXItLWZpeGVkLXNjcm9sbGVkJyxcclxuICAgIEZJWEVEX0FESlVTVDogJ21kYy10b3AtYXBwLWJhci0tZml4ZWQtYWRqdXN0JyxcclxuICAgIFBST01JTkVOVDogJ21kYy10b3AtYXBwLWJhci0tcHJvbWluZW50JyxcclxuICAgIFBST01JTkVOVF9GSVhFRF9BREpVU1Q6ICdtZGMtdG9wLWFwcC1iYXItLXByb21pbmVudC1maXhlZC1hZGp1c3QnLFxyXG4gICAgREVOU0U6ICdtZGMtdG9wLWFwcC1iYXItLWRlbnNlJyxcclxuICAgIERFTlNFX0ZJWEVEX0FESlVTVDogJ21kYy10b3AtYXBwLWJhci0tZGVuc2UtZml4ZWQtYWRqdXN0JyxcclxuICAgIERFTlNFX1BST01JTkVOVF9GSVhFRF9BREpVU1Q6ICdtZGMtdG9wLWFwcC1iYXItLWRlbnNlLXByb21pbmVudC1maXhlZC1hZGp1c3QnLFxyXG4gICAgU0hPUlQ6ICdtZGMtdG9wLWFwcC1iYXItLXNob3J0JyxcclxuICAgIFNIT1JUX0NPTExBUFNFRDogJ21kYy10b3AtYXBwLWJhci0tc2hvcnQtY29sbGFwc2VkJyxcclxuICAgIFNIT1JUX0ZJWEVEX0FESlVTVDogJ21kYy10b3AtYXBwLWJhci0tc2hvcnQtZml4ZWQtYWRqdXN0JyxcclxuXHJcbiAgICBST1c6ICdtZGMtdG9wLWFwcC1iYXJfX3JvdycsXHJcblxyXG4gICAgU0VDVElPTjogJ21kYy10b3AtYXBwLWJhcl9fc2VjdGlvbicsXHJcbiAgICBTRUNUSU9OX0FMSUdOX1NUQVJUOiAnbWRjLXRvcC1hcHAtYmFyX19zZWN0aW9uLS1hbGlnbi1zdGFydCcsXHJcbiAgICBTRUNUSU9OX0FMSUdOX0NFTlRFUjogJ21kYy10b3AtYXBwLWJhcl9fc2VjdGlvbi0tYWxpZ24tY2VudGVyJyxcclxuICAgIFNFQ1RJT05fQUxJR05fRU5EOiAnbWRjLXRvcC1hcHAtYmFyX19zZWN0aW9uLS1hbGlnbi1lbmQnLFxyXG5cclxuICAgIE5BVklHQVRJT05fSUNPTjogJ21kYy10b3AtYXBwLWJhcl9fbmF2aWdhdGlvbi1pY29uJyxcclxuXHJcbiAgICBBQ1RJT05fSVRFTTogJ21kYy10b3AtYXBwLWJhcl9fYWN0aW9uLWl0ZW0nLFxyXG5cclxuICAgIFRJVExFOiAnbWRjLXRvcC1hcHAtYmFyX190aXRsZSdcclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCBBbGlnbiA9IHtcclxuICAgIFNUQVJUOiAnc3RhcnQnLFxyXG4gICAgQ0VOVEVSOiAnY2VudGVyJyxcclxuICAgIEVORDogJ2VuZCdcclxufTsiLCJpbXBvcnQgeyBmb3J3YXJkUmVmIH0gZnJvbSAncmVhY3QnO1xyXG5pbXBvcnQgY2xhc3NuYW1lcyBmcm9tICdjbGFzc25hbWVzJztcclxuXHJcbmltcG9ydCB7IGNzc0NsYXNzZXMgfSBmcm9tICcuL2NvbnN0YW50cyc7XHJcblxyXG5jb25zdCBUb3BBcHBCYXJSb3cgPSBmb3J3YXJkUmVmKCh7XHJcbiAgICBlbGVtZW50OiBFbGVtZW50ID0gJ2RpdicsXHJcbiAgICBjbGFzc05hbWUsXHJcbiAgICAuLi5wcm9wc1xyXG59LCByZWYpID0+IHtcclxuICAgIGNvbnN0IGNsYXNzTmFtZXMgPSBjbGFzc25hbWVzKGNzc0NsYXNzZXMuUk9XLCBjbGFzc05hbWUpO1xyXG5cclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgPEVsZW1lbnQgcmVmPXtyZWZ9IGNsYXNzTmFtZT17Y2xhc3NOYW1lc30gey4uLnByb3BzfSAvPlxyXG4gICAgKTtcclxufSk7XHJcblxyXG5Ub3BBcHBCYXJSb3cuZGlzcGxheU5hbWUgPSAnTURDVG9wQXBwQmFyUm93JztcclxuXHJcbmV4cG9ydCBkZWZhdWx0IFRvcEFwcEJhclJvdzsiLCJpbXBvcnQgeyBmb3J3YXJkUmVmIH0gZnJvbSAncmVhY3QnO1xyXG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xyXG5pbXBvcnQgY2xhc3NuYW1lcyBmcm9tICdjbGFzc25hbWVzJztcclxuXHJcbmltcG9ydCB7IGNzc0NsYXNzZXMsIEFsaWduIH0gZnJvbSAnLi9jb25zdGFudHMnO1xyXG5cclxuY29uc3QgVG9wQXBwQmFyU2VjdGlvbiA9IGZvcndhcmRSZWYoKHtcclxuICAgIGFsaWduLFxyXG5cclxuICAgIGVsZW1lbnQ6IEVsZW1lbnQgPSAnc2VjdGlvbicsXHJcbiAgICBjbGFzc05hbWUsXHJcbiAgICAuLi5wcm9wc1xyXG59LCByZWYpID0+IHtcclxuICAgIGNvbnN0IGNsYXNzTmFtZXMgPSBjbGFzc25hbWVzKGNzc0NsYXNzZXMuU0VDVElPTiwge1xyXG4gICAgICAgIFtjc3NDbGFzc2VzLlNFQ1RJT05fQUxJR05fU1RBUlRdOiBhbGlnbiA9PT0gQWxpZ24uU1RBUlQsXHJcbiAgICAgICAgW2Nzc0NsYXNzZXMuU0VDVElPTl9BTElHTl9DRU5URVJdOiBhbGlnbiA9PT0gQWxpZ24uQ0VOVEVSLFxyXG4gICAgICAgIFtjc3NDbGFzc2VzLlNFQ1RJT05fQUxJR05fRU5EXTogYWxpZ24gPT09IEFsaWduLkVORFxyXG4gICAgfSwgY2xhc3NOYW1lKTtcclxuXHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAgIDxFbGVtZW50IHJlZj17cmVmfSBjbGFzc05hbWU9e2NsYXNzTmFtZXN9IHsuLi5wcm9wc30gLz5cclxuICAgICk7XHJcbn0pO1xyXG5cclxuVG9wQXBwQmFyU2VjdGlvbi5kaXNwbGF5TmFtZSA9ICdNRENUb3BBcHBCYXJTZWN0aW9uJztcclxuXHJcblRvcEFwcEJhclNlY3Rpb24ucHJvcFR5cGVzID0ge1xyXG4gICAgYWxpZ246IFByb3BUeXBlcy5vbmVPZihPYmplY3QudmFsdWVzKEFsaWduKSlcclxufTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IFRvcEFwcEJhclNlY3Rpb247IiwiaW1wb3J0IHsgZm9yd2FyZFJlZiwgdXNlUmVmLCB1c2VTdGF0ZSwgdXNlRWZmZWN0LCB1c2VJbXBlcmF0aXZlSGFuZGxlLCBDaGlsZHJlbiB9IGZyb20gJ3JlYWN0JztcclxuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcclxuaW1wb3J0IGNsYXNzbmFtZXMgZnJvbSAnY2xhc3NuYW1lcyc7XHJcblxyXG5pbXBvcnQgeyBDbG9uZSB9IGZyb20gJy4uL2NvbXBvbmVudCc7XHJcbmltcG9ydCBJY29uQnV0dG9uIGZyb20gJy4uL2ljb24tYnV0dG9uJztcclxuXHJcbmltcG9ydCB7IGNzc0NsYXNzZXMsIEFsaWduIH0gZnJvbSAnLi9jb25zdGFudHMnO1xyXG5pbXBvcnQgVG9wQXBwQmFyUm93IGZyb20gJy4vVG9wQXBwQmFyUm93JztcclxuaW1wb3J0IFRvcEFwcEJhclNlY3Rpb24gZnJvbSAnLi9Ub3BBcHBCYXJTZWN0aW9uJztcclxuXHJcbmNvbnN0IFRvcEFwcEJhciA9IGZvcndhcmRSZWYoKHtcclxuICAgIHRpdGxlLFxyXG4gICAgbmF2aWdhdGlvbkljb24sXHJcbiAgICBhY3Rpb25JdGVtcyxcclxuICAgIGZpeGVkID0gZmFsc2UsXHJcbiAgICBzdGlja3kgPSBmYWxzZSxcclxuICAgIGRlbnNlID0gZmFsc2UsXHJcbiAgICBwcm9taW5lbnQgPSBmYWxzZSxcclxuICAgIHNob3J0ID0gZmFsc2UsXHJcbiAgICBjb2xsYXBzZWQgPSBmYWxzZSxcclxuICAgIG9uTmF2aWdhdGlvbkljb25DbGljayA9IEZ1bmN0aW9uLnByb3RvdHlwZSxcclxuXHJcbiAgICBlbGVtZW50ID0gJ2hlYWRlcicsXHJcbiAgICBjb21wb25lbnQ6IEVsZW1lbnQgPSBlbGVtZW50LFxyXG4gICAgY2xhc3NOYW1lLFxyXG4gICAgY2hpbGRyZW4sXHJcbiAgICAuLi5wcm9wc1xyXG59LCByZWYpID0+IHtcclxuICAgIGNvbnN0IHJvb3RSZWYgPSB1c2VSZWYoKTtcclxuICAgIGNvbnN0IFtzY3JvbGxlZCwgc2V0U2Nyb2xsZWRdID0gdXNlU3RhdGUoZmFsc2UpO1xyXG4gICAgY29uc3QgW2hpZGRlbiwgc2V0SGlkZGVuXSA9IHVzZVN0YXRlKGZhbHNlKTtcclxuXHJcbiAgICB1c2VJbXBlcmF0aXZlSGFuZGxlKHJlZiwgKCkgPT4gcm9vdFJlZi5jdXJyZW50KTtcclxuXHJcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgICAgIGxldCBsYXN0U2Nyb2xsUG9zaXRpb24gPSAwO1xyXG5cclxuICAgICAgICBmdW5jdGlvbiBoYW5kbGVTY3JvbGwoKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHNjcm9sbFZhbHVlID0gd2luZG93LnBhZ2VZT2Zmc2V0O1xyXG5cclxuICAgICAgICAgICAgaWYgKGZpeGVkKSB7XHJcbiAgICAgICAgICAgICAgICBzZXRTY3JvbGxlZChzY3JvbGxWYWx1ZSA+IDApO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHN0aWNreSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgY3VycmVudFNjcm9sbFBvc2l0aW9uID0gTWF0aC5tYXgoc2Nyb2xsVmFsdWUsIDApO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZGlmZiA9IGN1cnJlbnRTY3JvbGxQb3NpdGlvbiAtIGxhc3RTY3JvbGxQb3NpdGlvbjtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHNob3VsZEhpZGUgPSBkaWZmID4gMDtcclxuXHJcbiAgICAgICAgICAgICAgICBsYXN0U2Nyb2xsUG9zaXRpb24gPSBjdXJyZW50U2Nyb2xsUG9zaXRpb247XHJcblxyXG4gICAgICAgICAgICAgICAgc2V0SGlkZGVuKHNob3VsZEhpZGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgaGFuZGxlU2Nyb2xsKTtcclxuXHJcbiAgICAgICAgcmV0dXJuICgpID0+IHtcclxuICAgICAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIGhhbmRsZVNjcm9sbCk7XHJcbiAgICAgICAgfTtcclxuICAgIH0sIFtmaXhlZCwgc3RpY2t5XSk7XHJcblxyXG4gICAgY29uc3QgY2xhc3NOYW1lcyA9IGNsYXNzbmFtZXMoY3NzQ2xhc3Nlcy5ST09ULCB7XHJcbiAgICAgICAgW2Nzc0NsYXNzZXMuRklYRURdOiBmaXhlZCxcclxuICAgICAgICBbY3NzQ2xhc3Nlcy5TVElDS1ldOiBzdGlja3ksXHJcbiAgICAgICAgW2Nzc0NsYXNzZXMuREVOU0VdOiBkZW5zZSxcclxuICAgICAgICBbY3NzQ2xhc3Nlcy5QUk9NSU5FTlRdOiBwcm9taW5lbnQsXHJcbiAgICAgICAgW2Nzc0NsYXNzZXMuU0hPUlRdOiBzaG9ydCxcclxuICAgICAgICBbY3NzQ2xhc3Nlcy5TSE9SVF9DT0xMQVBTRURdOiBzaG9ydCAmJiBjb2xsYXBzZWQsXHJcbiAgICAgICAgW2Nzc0NsYXNzZXMuRklYRURfU0NST0xMRURdOiBmaXhlZCAmJiBzY3JvbGxlZCxcclxuICAgICAgICBbY3NzQ2xhc3Nlcy5TVElDS1lfSElEREVOXTogc3RpY2t5ICYmIGhpZGRlbixcclxuICAgICAgICBbY3NzQ2xhc3Nlcy5TVElDS1lfU0hPV05dOiBzdGlja3kgJiYgIWhpZGRlblxyXG4gICAgfSwgY2xhc3NOYW1lKTtcclxuXHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAgIDxFbGVtZW50XHJcbiAgICAgICAgICAgIHJlZj17cm9vdFJlZn1cclxuICAgICAgICAgICAgY2xhc3NOYW1lPXtjbGFzc05hbWVzfVxyXG4gICAgICAgICAgICB7Li4ucHJvcHN9XHJcbiAgICAgICAgPlxyXG4gICAgICAgICAgICB7Y2hpbGRyZW4gfHxcclxuICAgICAgICAgICAgICAgIDxUb3BBcHBCYXJSb3c+XHJcbiAgICAgICAgICAgICAgICAgICAgeyh0aXRsZSB8fCBuYXZpZ2F0aW9uSWNvbikgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgPFRvcEFwcEJhclNlY3Rpb24gYWxpZ249e0FsaWduLlNUQVJUfT5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtuYXZpZ2F0aW9uSWNvbiAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxDbG9uZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21wb25lbnQ9e25hdmlnYXRpb25JY29ufVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmYWxsYmFjaz17SWNvbkJ1dHRvbn1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPXtjc3NDbGFzc2VzLk5BVklHQVRJT05fSUNPTn1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb25DbGljaz17b25OYXZpZ2F0aW9uSWNvbkNsaWNrfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge3RpdGxlICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPENsb25lXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudD17dGl0bGV9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZhbGxiYWNrPVwic3BhblwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT17Y3NzQ2xhc3Nlcy5USVRMRX1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8L1RvcEFwcEJhclNlY3Rpb24+XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICB7YWN0aW9uSXRlbXMgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgPFRvcEFwcEJhclNlY3Rpb24gYWxpZ249e0FsaWduLkVORH0+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7Q2hpbGRyZW4ubWFwKGFjdGlvbkl0ZW1zLCBpdGVtID0+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPENsb25lXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudD17aXRlbX1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPXtjc3NDbGFzc2VzLkFDVElPTl9JVEVNfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8L1RvcEFwcEJhclNlY3Rpb24+XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgPC9Ub3BBcHBCYXJSb3c+XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICA8L0VsZW1lbnQ+XHJcbiAgICApO1xyXG59KTtcclxuXHJcblRvcEFwcEJhci5kaXNwbGF5TmFtZSA9ICdNRENUb3BBcHBCYXInO1xyXG5cclxuVG9wQXBwQmFyLnByb3BUeXBlcyA9IHtcclxuICAgIHRpdGxlOiBQcm9wVHlwZXMubm9kZSxcclxuICAgIG5hdmlnYXRpb25JY29uOiBQcm9wVHlwZXMubm9kZSxcclxuICAgIGFjdGlvbkl0ZW1zOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtcclxuICAgICAgICBQcm9wVHlwZXMuZWxlbWVudCxcclxuICAgICAgICBQcm9wVHlwZXMuYXJyYXlPZihQcm9wVHlwZXMuZWxlbWVudCksXHJcbiAgICBdKSxcclxuICAgIGZpeGVkOiBQcm9wVHlwZXMuYm9vbCxcclxuICAgIHN0aWNreTogUHJvcFR5cGVzLmJvb2wsXHJcbiAgICBkZW5zZTogUHJvcFR5cGVzLmJvb2wsXHJcbiAgICBwcm9taW5lbnQ6IFByb3BUeXBlcy5ib29sLFxyXG4gICAgc2hvcnQ6IFByb3BUeXBlcy5ib29sLFxyXG4gICAgY29sbGFwc2VkOiBQcm9wVHlwZXMuYm9vbFxyXG59O1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgVG9wQXBwQmFyOyIsImltcG9ydCB7IGZvcndhcmRSZWYgfSBmcm9tICdyZWFjdCc7XHJcbmltcG9ydCBjbGFzc25hbWVzIGZyb20gJ2NsYXNzbmFtZXMnO1xyXG5pbXBvcnQgeyBjc3NDbGFzc2VzIH0gZnJvbSAnLi9jb25zdGFudHMnO1xyXG5cclxuY29uc3QgVG9wQXBwQmFyQWN0aW9uSXRlbSA9IGZvcndhcmRSZWYoKHtcclxuICAgIGVsZW1lbnQgPSAnc3BhbicsXHJcbiAgICBjb21wb25lbnQ6IEVsZW1lbnQgPSBlbGVtZW50LFxyXG4gICAgY2xhc3NOYW1lLFxyXG4gICAgLi4ucHJvcHNcclxufSwgcmVmKSA9PiB7XHJcbiAgICBjb25zdCBjbGFzc05hbWVzID0gY2xhc3NuYW1lcyhjc3NDbGFzc2VzLkFDVElPTl9JVEVNLCBjbGFzc05hbWUpO1xyXG5cclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgPEVsZW1lbnQgcmVmPXtyZWZ9IGNsYXNzTmFtZT17Y2xhc3NOYW1lc30gey4uLnByb3BzfSAvPlxyXG4gICAgKTtcclxufSk7XHJcblxyXG5Ub3BBcHBCYXJBY3Rpb25JdGVtLmRpc3BsYXlOYW1lID0gJ01EQ1RvcEFwcEJhckFjdGlvbkl0ZW0nO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgVG9wQXBwQmFyQWN0aW9uSXRlbTsiLCJpbXBvcnQgeyBmb3J3YXJkUmVmIH0gZnJvbSAncmVhY3QnO1xyXG5pbXBvcnQgY2xhc3NuYW1lcyBmcm9tICdjbGFzc25hbWVzJztcclxuXHJcbmltcG9ydCB7IGNzc0NsYXNzZXMgfSBmcm9tICcuL2NvbnN0YW50cyc7XHJcblxyXG5jb25zdCBUb3BBcHBCYXJGaXhlZEFkanVzdCA9IGZvcndhcmRSZWYoKHtcclxuICAgIGRlbnNlID0gZmFsc2UsXHJcbiAgICBwcm9taW5lbnQgPSBmYWxzZSxcclxuICAgIHNob3J0ID0gZmFsc2UsXHJcblxyXG4gICAgZWxlbWVudCA9ICdkaXYnLFxyXG4gICAgY29tcG9uZW50OiBFbGVtZW50ID0gZWxlbWVudCxcclxuICAgIGNsYXNzTmFtZSxcclxuICAgIC4uLnByb3BzXHJcbn0sIHJlZikgPT4ge1xyXG4gICAgY29uc3QgY2xhc3NOYW1lcyA9IGNsYXNzbmFtZXMoY3NzQ2xhc3Nlcy5GSVhFRF9BREpVU1QsIHtcclxuICAgICAgICBbY3NzQ2xhc3Nlcy5ERU5TRV9GSVhFRF9BREpVU1RdOiBkZW5zZSxcclxuICAgICAgICBbY3NzQ2xhc3Nlcy5QUk9NSU5FTlRfRklYRURfQURKVVNUXTogcHJvbWluZW50LFxyXG4gICAgICAgIFtjc3NDbGFzc2VzLkRFTlNFX1BST01JTkVOVF9GSVhFRF9BREpVU1RdOiBkZW5zZSAmJiBwcm9taW5lbnQsXHJcbiAgICAgICAgW2Nzc0NsYXNzZXMuU0hPUlRfRklYRURfQURKVVNUXTogc2hvcnRcclxuICAgIH0sIGNsYXNzTmFtZSk7XHJcblxyXG4gICAgcmV0dXJuIChcclxuICAgICAgICA8RWxlbWVudCByZWY9e3JlZn0gY2xhc3NOYW1lPXtjbGFzc05hbWVzfSB7Li4ucHJvcHN9IC8+XHJcbiAgICApO1xyXG59KTtcclxuXHJcblRvcEFwcEJhckZpeGVkQWRqdXN0LmRpc3BsYXlOYW1lID0gJ01EQ1RvcEFwcEJhckZpeGVkQWRqdXN0JztcclxuXHJcbmV4cG9ydCBkZWZhdWx0IFRvcEFwcEJhckZpeGVkQWRqdXN0OyIsImltcG9ydCB7IGZvcndhcmRSZWYgfSBmcm9tICdyZWFjdCc7XHJcbmltcG9ydCBjbGFzc25hbWVzIGZyb20gJ2NsYXNzbmFtZXMnO1xyXG5cclxuaW1wb3J0IEljb25CdXR0b24gZnJvbSAnLi4vaWNvbi1idXR0b24nO1xyXG5cclxuaW1wb3J0IHsgY3NzQ2xhc3NlcyB9IGZyb20gJy4vY29uc3RhbnRzJztcclxuXHJcbmNvbnN0IFRvcEFwcEJhck5hdmlnYXRpb25JY29uID0gZm9yd2FyZFJlZigoeyBjbGFzc05hbWUsIC4uLnByb3BzIH0sIHJlZikgPT4ge1xyXG4gICAgY29uc3QgY2xhc3NOYW1lcyA9IGNsYXNzbmFtZXMoY3NzQ2xhc3Nlcy5OQVZJR0FUSU9OX0lDT04sIGNsYXNzTmFtZSk7XHJcblxyXG4gICAgcmV0dXJuIChcclxuICAgICAgICA8SWNvbkJ1dHRvbiByZWY9e3JlZn0gY2xhc3NOYW1lPXtjbGFzc05hbWVzfSB7Li4ucHJvcHN9IC8+XHJcbiAgICApO1xyXG59KTtcclxuXHJcblRvcEFwcEJhck5hdmlnYXRpb25JY29uLmRpc3BsYXlOYW1lID0gJ01EQ1RvcEFwcEJhck5hdmlnYXRpb25JY29uJztcclxuXHJcbmV4cG9ydCBkZWZhdWx0IFRvcEFwcEJhck5hdmlnYXRpb25JY29uOyIsImltcG9ydCB7IGZvcndhcmRSZWYgfSBmcm9tICdyZWFjdCc7XHJcbmltcG9ydCBjbGFzc25hbWVzIGZyb20gJ2NsYXNzbmFtZXMnO1xyXG5cclxuaW1wb3J0IHsgY3NzQ2xhc3NlcyB9IGZyb20gJy4vY29uc3RhbnRzJztcclxuXHJcbmNvbnN0IFRvcEFwcEJhclRpdGxlID0gZm9yd2FyZFJlZigoe1xyXG4gICAgZWxlbWVudDogRWxlbWVudCA9ICdzcGFuJyxcclxuICAgIGNsYXNzTmFtZSxcclxuICAgIC4uLnByb3BzXHJcbn0sIHJlZikgPT4ge1xyXG4gICAgY29uc3QgY2xhc3NOYW1lcyA9IGNsYXNzbmFtZXMoY3NzQ2xhc3Nlcy5USVRMRSwgY2xhc3NOYW1lKTtcclxuXHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAgIDxFbGVtZW50IHJlZj17cmVmfSBjbGFzc05hbWU9e2NsYXNzTmFtZXN9IHsuLi5wcm9wc30gLz5cclxuICAgICk7XHJcbn0pO1xyXG5cclxuVG9wQXBwQmFyVGl0bGUuZGlzcGxheU5hbWUgPSAnTURDVG9wQXBwQmFyVGl0bGUnO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgVG9wQXBwQmFyVGl0bGU7IiwiaW1wb3J0IFRvcEFwcEJhciBmcm9tICcuL1RvcEFwcEJhcic7XHJcbmltcG9ydCBUb3BBcHBCYXJBY3Rpb25JdGVtIGZyb20gJy4vVG9wQXBwQmFyQWN0aW9uSXRlbSc7XHJcbmltcG9ydCBUb3BBcHBCYXJGaXhlZEFkanVzdCBmcm9tICcuL1RvcEFwcEJhckZpeGVkQWRqdXN0JztcclxuaW1wb3J0IFRvcEFwcEJhck5hdmlnYXRpb25JY29uIGZyb20gJy4vVG9wQXBwQmFyTmF2aWdhdGlvbkljb24nO1xyXG5pbXBvcnQgVG9wQXBwQmFyUm93IGZyb20gJy4vVG9wQXBwQmFyUm93JztcclxuaW1wb3J0IFRvcEFwcEJhclNlY3Rpb24gZnJvbSAnLi9Ub3BBcHBCYXJTZWN0aW9uJztcclxuaW1wb3J0IFRvcEFwcEJhclRpdGxlIGZyb20gJy4vVG9wQXBwQmFyVGl0bGUnO1xyXG5cclxuVG9wQXBwQmFyLkFjdGlvbkl0ZW0gPSBUb3BBcHBCYXJBY3Rpb25JdGVtO1xyXG5Ub3BBcHBCYXIuRml4ZWRBZGp1c3QgPSBUb3BBcHBCYXJGaXhlZEFkanVzdDtcclxuVG9wQXBwQmFyLk5hdmlnYXRpb25JY29uID0gVG9wQXBwQmFyTmF2aWdhdGlvbkljb247XHJcblRvcEFwcEJhci5Sb3cgPSBUb3BBcHBCYXJSb3c7XHJcblRvcEFwcEJhci5TZWN0aW9uID0gVG9wQXBwQmFyU2VjdGlvbjtcclxuVG9wQXBwQmFyLlRpdGxlID0gVG9wQXBwQmFyVGl0bGU7XHJcblxyXG5leHBvcnQge1xyXG4gICAgVG9wQXBwQmFyIGFzIGRlZmF1bHQsXHJcbiAgICBUb3BBcHBCYXJBY3Rpb25JdGVtLFxyXG4gICAgVG9wQXBwQmFyRml4ZWRBZGp1c3QsXHJcbiAgICBUb3BBcHBCYXJOYXZpZ2F0aW9uSWNvbixcclxuICAgIFRvcEFwcEJhclJvdyxcclxuICAgIFRvcEFwcEJhclNlY3Rpb24sXHJcbiAgICBUb3BBcHBCYXJUaXRsZVxyXG59OyIsImV4cG9ydCBjb25zdCBlbGVtZW50c0J5VHlwZSA9IHtcclxuICAgIGhlYWRsaW5lMTogJ2gxJyxcclxuICAgIGhlYWRsaW5lMjogJ2gyJyxcclxuICAgIGhlYWRsaW5lMzogJ2gzJyxcclxuICAgIGhlYWRsaW5lNDogJ2g0JyxcclxuICAgIGhlYWRsaW5lNTogJ2g1JyxcclxuICAgIGhlYWRsaW5lNjogJ2g2JyxcclxuICAgIHN1YnRpdGxlMTogJ2g1JyxcclxuICAgIHN1YnRpdGxlMjogJ2g2JyxcclxuICAgIGJvZHkxOiAncCcsXHJcbiAgICBib2R5MjogJ3AnLFxyXG4gICAgYnV0dG9uOiAnc3BhbicsXHJcbiAgICBjYXB0aW9uOiAnc3BhbicsXHJcbiAgICBvdmVybGluZTogJ3NwYW4nXHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgY3NzQ2xhc3NlcyA9IHtcclxuICAgIFJPT1Q6ICdtZGMtdHlwb2dyYXBoeScsXHJcbiAgICBESVNQTEFZOiAnbWRjLXR5cG9ncmFwaHktLWRpc3BsYXknLFxyXG4gICAgQUxJR046ICdtZGMtdHlwb2dyYXBoeS0tYWxpZ24nLFxyXG4gICAgTk9fTUFSR0lOOiAnbWRjLXR5cG9ncmFwaHktLW5vLW1hcmdpbicsXHJcbiAgICBOT19XUkFQOiAnbWRjLXR5cG9ncmFwaHktLW5vLXdyYXAnXHJcbn07IiwiaW1wb3J0IHsgZm9yd2FyZFJlZiB9IGZyb20gJ3JlYWN0JztcclxuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcclxuaW1wb3J0IGNsYXNzbmFtZXMgZnJvbSAnY2xhc3NuYW1lcyc7XHJcblxyXG5pbXBvcnQgeyBlbGVtZW50c0J5VHlwZSwgY3NzQ2xhc3NlcyB9IGZyb20gJy4vY29uc3RhbnRzJztcclxuXHJcbmNvbnN0IFR5cG9ncmFwaHkgPSBmb3J3YXJkUmVmKCh7XHJcbiAgICB0eXBlID0gJ2JvZHkxJyxcclxuICAgIGRpc3BsYXksXHJcbiAgICBhbGlnbixcclxuICAgIG5vTWFyZ2luID0gZmFsc2UsXHJcbiAgICBub1dyYXAgPSBmYWxzZSxcclxuXHJcbiAgICBlbGVtZW50ID0gZWxlbWVudHNCeVR5cGVbdHlwZV0sXHJcbiAgICBjb21wb25lbnQ6IEVsZW1lbnQgPSBlbGVtZW50LFxyXG4gICAgY2xhc3NOYW1lLFxyXG4gICAgLi4ucHJvcHNcclxufSwgcmVmKSA9PiB7XHJcbiAgICBjb25zdCBjbGFzc05hbWVzID0gY2xhc3NuYW1lcyhjc3NDbGFzc2VzLlJPT1QsIGAke2Nzc0NsYXNzZXMuUk9PVH0tLSR7dHlwZX1gLCB7XHJcbiAgICAgICAgW2Ake2Nzc0NsYXNzZXMuRElTUExBWX0tJHtkaXNwbGF5fWBdOiBkaXNwbGF5LFxyXG4gICAgICAgIFtgJHtjc3NDbGFzc2VzLkFMSUdOfS0ke2FsaWdufWBdOiBhbGlnbixcclxuICAgICAgICBbY3NzQ2xhc3Nlcy5OT19NQVJHSU5dOiBub01hcmdpbixcclxuICAgICAgICBbY3NzQ2xhc3Nlcy5OT19XUkFQXTogbm9XcmFwXHJcbiAgICB9LCBjbGFzc05hbWUpO1xyXG5cclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgPEVsZW1lbnQgcmVmPXtyZWZ9IGNsYXNzTmFtZT17Y2xhc3NOYW1lc30gey4uLnByb3BzfSAvPlxyXG4gICAgKTtcclxufSk7XHJcblxyXG5UeXBvZ3JhcGh5LmRpc3BsYXlOYW1lID0gJ01EQ1R5cG9ncmFwaHknO1xyXG5cclxuVHlwb2dyYXBoeS5wcm9wVHlwZXMgPSB7XHJcbiAgICB0eXBlOiBQcm9wVHlwZXMub25lT2YoT2JqZWN0LmtleXMoZWxlbWVudHNCeVR5cGUpKSxcclxuICAgIGRpc3BsYXk6IFByb3BUeXBlcy5vbmVPZihbJ2Jsb2NrJywgJ2lubGluZScsICdpbmxpbmUtYmxvY2snXSksXHJcbiAgICBhbGlnbjogUHJvcFR5cGVzLm9uZU9mKFsnbGVmdCcsICdjZW50ZXInLCAncmlnaHQnLCAnanVzdGlmeSddKSxcclxuICAgIG5vTWFyZ2luOiBQcm9wVHlwZXMuYm9vbCxcclxuICAgIG5vV3JhcDogUHJvcFR5cGVzLmJvb2xcclxufTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IFR5cG9ncmFwaHk7IiwiZXhwb3J0IHsgZGVmYXVsdCB9IGZyb20gJy4vVHlwb2dyYXBoeSc7IiwiZXhwb3J0IHsgZGVmYXVsdCBhcyBBdmF0YXIgfSBmcm9tICcuL2F2YXRhcic7XHJcbmV4cG9ydCB7IGRlZmF1bHQgYXMgQmFkZ2UgfSBmcm9tICcuL2JhZGdlJztcclxuZXhwb3J0IHsgZGVmYXVsdCBhcyBCYW5uZXIgfSBmcm9tICcuL2Jhbm5lcic7XHJcbmV4cG9ydCB7IGRlZmF1bHQgYXMgQnV0dG9uIH0gZnJvbSAnLi9idXR0b24nO1xyXG5leHBvcnQgeyBkZWZhdWx0IGFzIENhcmQsIENhcmRBY3Rpb24sIENhcmRBY3Rpb25zLCBDYXJkQWN0aW9uQnV0dG9ucywgQ2FyZEFjdGlvbkljb25zLCBDYXJkSGVhZGVyLCBDYXJkTWVkaWEsIENhcmRQcmltYXJ5QWN0aW9uLCBDYXJkU2VjdGlvbiB9IGZyb20gJy4vY2FyZCc7XHJcbmV4cG9ydCB7IGRlZmF1bHQgYXMgQ2hlY2tib3ggfSBmcm9tICcuL2NoZWNrYm94JztcclxuZXhwb3J0IHsgQ2hpcCwgQ2hpcFNldCB9IGZyb20gJy4vY2hpcHMnO1xyXG5leHBvcnQgeyBkZWZhdWx0IGFzIENpcmN1bGFyUHJvZ3Jlc3MgfSBmcm9tICcuL2NpcmN1bGFyLXByb2dyZXNzJztcclxuZXhwb3J0IHsgZGVmYXVsdCBhcyBJY29uIH0gZnJvbSAnLi9pY29uJztcclxuZXhwb3J0IHsgZGVmYXVsdCBhcyBJY29uQnV0dG9uIH0gZnJvbSAnLi9pY29uLWJ1dHRvbic7XHJcbmV4cG9ydCB7IGRlZmF1bHQgYXMgRGF0YVRhYmxlLCBEYXRhVGFibGVIZWFkZXIsIERhdGFUYWJsZUhlYWRlclJvdywgRGF0YVRhYmxlSGVhZGVyQ2VsbCwgRGF0YVRhYmxlQ29udGVudCwgRGF0YVRhYmxlUm93LCBEYXRhVGFibGVDZWxsLCBEYXRhVGFibGVGb290ZXIgfSBmcm9tICcuL2RhdGEtdGFibGUnO1xyXG5leHBvcnQgeyBkZWZhdWx0IGFzIERpYWxvZywgRGlhbG9nSGVhZGVyLCBEaWFsb2dDb250ZW50LCBEaWFsb2dBY3Rpb25zIH0gZnJvbSAnLi9kaWFsb2cnO1xyXG5leHBvcnQgeyBkZWZhdWx0IGFzIERyYXdlciwgRHJhd2VySGVhZGVyLCBEcmF3ZXJDb250ZW50IH0gZnJvbSAnLi9kcmF3ZXInO1xyXG5leHBvcnQgeyBkZWZhdWx0IGFzIEVsZXZhdGlvbiB9IGZyb20gJy4vZWxldmF0aW9uJztcclxuZXhwb3J0IHsgZGVmYXVsdCBhcyBGQUIgfSBmcm9tICcuL2ZhYic7XHJcbmV4cG9ydCB7IGRlZmF1bHQgYXMgRmxvYXRpbmdMYWJlbCB9IGZyb20gJy4vZmxvYXRpbmctbGFiZWwnO1xyXG5leHBvcnQgeyBkZWZhdWx0IGFzIEZvcm1GaWVsZCB9IGZyb20gJy4vZm9ybS1maWVsZCc7XHJcbmV4cG9ydCB7IGRlZmF1bHQgYXMgSW1hZ2VMaXN0LCBJbWFnZUxpc3RJdGVtIH0gZnJvbSAnLi9pbWFnZS1saXN0JztcclxuZXhwb3J0IHsgZGVmYXVsdCBhcyBMYXlvdXQgfSBmcm9tICcuL2xheW91dCc7XHJcbmV4cG9ydCB7IGRlZmF1bHQgYXMgTGF5b3V0R3JpZCwgTGF5b3V0R3JpZENlbGwgfSBmcm9tICcuL2xheW91dC1ncmlkJztcclxuZXhwb3J0IHsgZGVmYXVsdCBhcyBMaW5lYXJQcm9ncmVzcyB9IGZyb20gJy4vbGluZWFyLXByb2dyZXNzJztcclxuZXhwb3J0IHsgZGVmYXVsdCBhcyBMaW5lUmlwcGxlIH0gZnJvbSAnLi9saW5lLXJpcHBsZSc7XHJcbmV4cG9ydCB7IGRlZmF1bHQgYXMgTGlzdCwgTGlzdERpdmlkZXIsIExpc3RJdGVtLCBMaXN0SXRlbUNvbnRlbnQsIExpc3RJdGVtRW5kLCBMaXN0SXRlbVN0YXJ0LCBMaXN0R3JvdXAsIExpc3RHcm91cFN1YmhlYWRlciB9IGZyb20gJy4vbGlzdCc7XHJcbmV4cG9ydCB7IGRlZmF1bHQgYXMgTWVudSwgTWVudUFuY2hvciwgTWVudUl0ZW0sIE1lbnVPcmlnaW4sIE1lbnVTdXJmYWNlLCBNZW51U2VsZWN0aW9uR3JvdXAsIE1lbnVTZWxlY3Rpb25Hcm91cEljb24gfSBmcm9tICcuL21lbnUnO1xyXG5leHBvcnQgeyBkZWZhdWx0IGFzIE5vdGNoZWRPdXRsaW5lIH0gZnJvbSAnLi9ub3RjaGVkLW91dGxpbmUnO1xyXG5leHBvcnQgeyBkZWZhdWx0IGFzIFJhZGlvIH0gZnJvbSAnLi9yYWRpbyc7XHJcbmV4cG9ydCB7IFJpcHBsZSwgUmlwcGxlU3VyZmFjZSB9IGZyb20gJy4vcmlwcGxlJztcclxuZXhwb3J0IHsgZGVmYXVsdCBhcyBTZWdtZW50ZWRCdXR0b24sIFNlZ21lbnRlZEJ1dHRvblNlZ21lbnQgfSBmcm9tICcuL3NlZ21lbnRlZC1idXR0b24nO1xyXG5leHBvcnQgeyBkZWZhdWx0IGFzIFNpZGVTaGVldCwgU2lkZVNoZWV0SGVhZGVyLCBTaWRlU2hlZXRDb250ZW50IH0gZnJvbSAnLi9zaWRlLXNoZWV0JztcclxuZXhwb3J0IHsgZGVmYXVsdCBhcyBTZWxlY3QsIFNlbGVjdE9wdGlvbiB9IGZyb20gJy4vc2VsZWN0JztcclxuZXhwb3J0IHsgZGVmYXVsdCBhcyBTbGlkZXIgfSBmcm9tICcuL3NsaWRlcic7XHJcbmV4cG9ydCB7IGRlZmF1bHQgYXMgU25hY2tiYXIgfSBmcm9tICcuL3NuYWNrYmFyJztcclxuZXhwb3J0IHsgZGVmYXVsdCBhcyBTd2l0Y2ggfSBmcm9tICcuL3N3aXRjaCc7XHJcbmV4cG9ydCB7IFRhYiwgVGFiQmFyIH0gZnJvbSAnLi90YWJzJztcclxuZXhwb3J0IHsgVG9vbHRpcCwgUmljaFRvb2x0aXAgfSBmcm9tICcuL3Rvb2x0aXAnO1xyXG5leHBvcnQgeyBkZWZhdWx0IGFzIFRleHRGaWVsZCB9IGZyb20gJy4vdGV4dC1maWVsZCc7XHJcbmV4cG9ydCB7IGRlZmF1bHQgYXMgVG9wQXBwQmFyLCBUb3BBcHBCYXJBY3Rpb25JdGVtLCBUb3BBcHBCYXJOYXZpZ2F0aW9uSWNvbiwgVG9wQXBwQmFyUm93LCBUb3BBcHBCYXJTZWN0aW9uLCBUb3BBcHBCYXJUaXRsZSB9IGZyb20gJy4vdG9wLWFwcC1iYXInO1xyXG5leHBvcnQgeyBkZWZhdWx0IGFzIFR5cG9ncmFwaHkgfSBmcm9tICcuL3R5cG9ncmFwaHknOyIsImltcG9ydCB7IENoaWxkcmVuLCBpc1ZhbGlkRWxlbWVudCB9IGZyb20gJ3JlYWN0JztcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBqc3hUb0h0bWwocm9vdCkge1xyXG4gICAgcmV0dXJuIENoaWxkcmVuLnRvQXJyYXkocm9vdClcclxuICAgICAgICAubWFwKGl0ZW0gPT4gcHJpbnRDb21wb25lbnQoaXRlbSkpXHJcbiAgICAgICAgLmpvaW4oJ1xcbicpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gcHJpbnRDb21wb25lbnQoY29tcG9uZW50LCBkZXB0aCA9IDApIHtcclxuICAgIGNvbnN0IHR5cGUgPSB0eXBlb2YgY29tcG9uZW50LnR5cGUgPT09ICdzdHJpbmcnID8gY29tcG9uZW50LnR5cGUgOiBjb21wb25lbnQudHlwZS5kaXNwbGF5TmFtZS5yZXBsYWNlKCdNREMnLCAnJyk7XHJcbiAgICBjb25zdCBjaGlsZHJlbiA9IGNvbXBvbmVudC5wcm9wcy5jaGlsZHJlbjtcclxuICAgIGNvbnN0IHByb3BzID0gT2JqZWN0LmVudHJpZXMoY29tcG9uZW50LnByb3BzKS5maWx0ZXIoKFtrZXksIHZhbHVlXSkgPT4ga2V5ICE9PSAnY2hpbGRyZW4nICYmIHZhbHVlICE9PSB1bmRlZmluZWQpO1xyXG4gICAgY29uc3QgaW5kZW50ID0gJyAgJy5yZXBlYXQoZGVwdGgpO1xyXG5cclxuICAgIGxldCByZXN1bHQgPSBpbmRlbnQgKyBgPCR7dHlwZX1gO1xyXG5cclxuICAgIGlmICghaXNFbXB0eShwcm9wcykpIHtcclxuICAgICAgICByZXN1bHQgKz0gYCAke3ByaW50UHJvcHMocHJvcHMsIGRlcHRoICsgMSl9YDtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoIWNoaWxkcmVuKSB7XHJcbiAgICAgICAgcmVzdWx0ICs9IHJlc3VsdC5lbmRzV2l0aCgnXFxuJykgPyAoaW5kZW50ICsgJy8+JykgOiAnIC8+JztcclxuICAgIH0gZWxzZSBpZiAoaXNWYWxpZEVsZW1lbnQoY2hpbGRyZW4pKSB7XHJcbiAgICAgICAgcmVzdWx0ICs9IGA+XFxuJHtwcmludENvbXBvbmVudChjaGlsZHJlbiwgZGVwdGggKyAxKX1cXG4ke2luZGVudH08LyR7dHlwZX0+YDtcclxuICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShjaGlsZHJlbikpIHtcclxuICAgICAgICByZXN1bHQgKz0gcmVzdWx0LmVuZHNXaXRoKCdcXG4nKSA/IChpbmRlbnQgKyAnPlxcbicpIDogJz5cXG4nO1xyXG5cclxuICAgICAgICByZXN1bHQgKz0gY2hpbGRyZW4ubWFwKGNoaWxkID0+IHByaW50Q29tcG9uZW50KGNoaWxkLCBkZXB0aCArIDEpKS5qb2luKCdcXG4nKTtcclxuXHJcbiAgICAgICAgcmVzdWx0ICs9IGBcXG4ke2luZGVudH08LyR7dHlwZX0+YDtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcmVzdWx0ICs9IGA+JHtjaGlsZHJlbn08LyR7dHlwZX0+YDtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59XHJcblxyXG5mdW5jdGlvbiBwcmludFByb3BzKHByb3BzLCBkZXB0aCkge1xyXG4gICAgbGV0IHJlc3VsdCA9ICcnO1xyXG4gICAgY29uc3QgaW5kZW50ID0gJyAgJy5yZXBlYXQoZGVwdGgpO1xyXG5cclxuICAgIGlmIChwcm9wcy5sZW5ndGggPCAzKSB7XHJcbiAgICAgICAgcmVzdWx0ICs9IHByb3BzLm1hcChwcmludFByb3ApLmpvaW4oJyAnKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcmVzdWx0ICs9IGBcXG4ke2luZGVudH0ke3Byb3BzLm1hcChwcmludFByb3ApLmpvaW4oJ1xcbicgKyBpbmRlbnQpfVxcbmA7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufVxyXG5cclxuZnVuY3Rpb24gcHJpbnRQcm9wKFtrZXksIHZhbHVlXSkge1xyXG4gICAgaWYgKHZhbHVlID09PSB0cnVlKSB7XHJcbiAgICAgICAgcmV0dXJuIGtleTtcclxuICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgIHJldHVybiBgJHtrZXl9PVwiJHt2YWx1ZX1cImA7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIHJldHVybiBgJHtrZXl9PXske3ByaW50VmFsdWUodmFsdWUpfX1gO1xyXG4gICAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBwcmludFZhbHVlKHZhbHVlKSB7XHJcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgIHJldHVybiBgJyR7dmFsdWV9J2A7XHJcbiAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XHJcbiAgICAgICAgcmV0dXJuIGBbJHt2YWx1ZS5tYXAodiA9PiBwcmludFZhbHVlKHYpKS5qb2luKCcsICcpfV1gO1xyXG4gICAgfSBlbHNlIGlmIChpc1ZhbGlkRWxlbWVudCh2YWx1ZSkpIHtcclxuICAgICAgICByZXR1cm4gcHJpbnRDb21wb25lbnQodmFsdWUpO1xyXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICByZXR1cm4gYCR7dmFsdWUubmFtZSB8fCAnW0Z1bmN0aW9uXSd9YDtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBpc0VtcHR5KHZhbHVlKSB7XHJcbiAgICBpZiAoIXZhbHVlKSB7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XHJcbiAgICAgICAgcmV0dXJuIHZhbHVlLmxlbmd0aCA9PT0gMDtcclxuICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0Jykge1xyXG4gICAgICAgIHJldHVybiBPYmplY3Qua2V5cyh2YWx1ZSkubGVuZ3RoID09PSAwO1xyXG4gICAgfVxyXG59IiwiLy8gaHR0cHM6Ly9ub2RlanMub3JnL2FwaS9wYWNrYWdlcy5odG1sI3BhY2thZ2VzX3dyaXRpbmdfZHVhbF9wYWNrYWdlc193aGlsZV9hdm9pZGluZ19vcl9taW5pbWl6aW5nX2hhemFyZHNcbmltcG9ydCBobGpzIGZyb20gJy4uL2xpYi9jb3JlLmpzJztcbmV4cG9ydCBkZWZhdWx0IGhsanM7XG4iLCJjb25zdCBJREVOVF9SRSA9ICdbQS1aYS16JF9dWzAtOUEtWmEteiRfXSonO1xuY29uc3QgS0VZV09SRFMgPSBbXG4gIFwiYXNcIiwgLy8gZm9yIGV4cG9ydHNcbiAgXCJpblwiLFxuICBcIm9mXCIsXG4gIFwiaWZcIixcbiAgXCJmb3JcIixcbiAgXCJ3aGlsZVwiLFxuICBcImZpbmFsbHlcIixcbiAgXCJ2YXJcIixcbiAgXCJuZXdcIixcbiAgXCJmdW5jdGlvblwiLFxuICBcImRvXCIsXG4gIFwicmV0dXJuXCIsXG4gIFwidm9pZFwiLFxuICBcImVsc2VcIixcbiAgXCJicmVha1wiLFxuICBcImNhdGNoXCIsXG4gIFwiaW5zdGFuY2VvZlwiLFxuICBcIndpdGhcIixcbiAgXCJ0aHJvd1wiLFxuICBcImNhc2VcIixcbiAgXCJkZWZhdWx0XCIsXG4gIFwidHJ5XCIsXG4gIFwic3dpdGNoXCIsXG4gIFwiY29udGludWVcIixcbiAgXCJ0eXBlb2ZcIixcbiAgXCJkZWxldGVcIixcbiAgXCJsZXRcIixcbiAgXCJ5aWVsZFwiLFxuICBcImNvbnN0XCIsXG4gIFwiY2xhc3NcIixcbiAgLy8gSlMgaGFuZGxlcyB0aGVzZSB3aXRoIGEgc3BlY2lhbCBydWxlXG4gIC8vIFwiZ2V0XCIsXG4gIC8vIFwic2V0XCIsXG4gIFwiZGVidWdnZXJcIixcbiAgXCJhc3luY1wiLFxuICBcImF3YWl0XCIsXG4gIFwic3RhdGljXCIsXG4gIFwiaW1wb3J0XCIsXG4gIFwiZnJvbVwiLFxuICBcImV4cG9ydFwiLFxuICBcImV4dGVuZHNcIlxuXTtcbmNvbnN0IExJVEVSQUxTID0gW1xuICBcInRydWVcIixcbiAgXCJmYWxzZVwiLFxuICBcIm51bGxcIixcbiAgXCJ1bmRlZmluZWRcIixcbiAgXCJOYU5cIixcbiAgXCJJbmZpbml0eVwiXG5dO1xuXG5jb25zdCBUWVBFUyA9IFtcbiAgXCJJbnRsXCIsXG4gIFwiRGF0YVZpZXdcIixcbiAgXCJOdW1iZXJcIixcbiAgXCJNYXRoXCIsXG4gIFwiRGF0ZVwiLFxuICBcIlN0cmluZ1wiLFxuICBcIlJlZ0V4cFwiLFxuICBcIk9iamVjdFwiLFxuICBcIkZ1bmN0aW9uXCIsXG4gIFwiQm9vbGVhblwiLFxuICBcIkVycm9yXCIsXG4gIFwiU3ltYm9sXCIsXG4gIFwiU2V0XCIsXG4gIFwiTWFwXCIsXG4gIFwiV2Vha1NldFwiLFxuICBcIldlYWtNYXBcIixcbiAgXCJQcm94eVwiLFxuICBcIlJlZmxlY3RcIixcbiAgXCJKU09OXCIsXG4gIFwiUHJvbWlzZVwiLFxuICBcIkZsb2F0NjRBcnJheVwiLFxuICBcIkludDE2QXJyYXlcIixcbiAgXCJJbnQzMkFycmF5XCIsXG4gIFwiSW50OEFycmF5XCIsXG4gIFwiVWludDE2QXJyYXlcIixcbiAgXCJVaW50MzJBcnJheVwiLFxuICBcIkZsb2F0MzJBcnJheVwiLFxuICBcIkFycmF5XCIsXG4gIFwiVWludDhBcnJheVwiLFxuICBcIlVpbnQ4Q2xhbXBlZEFycmF5XCIsXG4gIFwiQXJyYXlCdWZmZXJcIixcbiAgXCJCaWdJbnQ2NEFycmF5XCIsXG4gIFwiQmlnVWludDY0QXJyYXlcIixcbiAgXCJCaWdJbnRcIlxuXTtcblxuY29uc3QgRVJST1JfVFlQRVMgPSBbXG4gIFwiRXZhbEVycm9yXCIsXG4gIFwiSW50ZXJuYWxFcnJvclwiLFxuICBcIlJhbmdlRXJyb3JcIixcbiAgXCJSZWZlcmVuY2VFcnJvclwiLFxuICBcIlN5bnRheEVycm9yXCIsXG4gIFwiVHlwZUVycm9yXCIsXG4gIFwiVVJJRXJyb3JcIlxuXTtcblxuY29uc3QgQlVJTFRfSU5fR0xPQkFMUyA9IFtcbiAgXCJzZXRJbnRlcnZhbFwiLFxuICBcInNldFRpbWVvdXRcIixcbiAgXCJjbGVhckludGVydmFsXCIsXG4gIFwiY2xlYXJUaW1lb3V0XCIsXG5cbiAgXCJyZXF1aXJlXCIsXG4gIFwiZXhwb3J0c1wiLFxuXG4gIFwiZXZhbFwiLFxuICBcImlzRmluaXRlXCIsXG4gIFwiaXNOYU5cIixcbiAgXCJwYXJzZUZsb2F0XCIsXG4gIFwicGFyc2VJbnRcIixcbiAgXCJkZWNvZGVVUklcIixcbiAgXCJkZWNvZGVVUklDb21wb25lbnRcIixcbiAgXCJlbmNvZGVVUklcIixcbiAgXCJlbmNvZGVVUklDb21wb25lbnRcIixcbiAgXCJlc2NhcGVcIixcbiAgXCJ1bmVzY2FwZVwiXG5dO1xuXG5jb25zdCBCVUlMVF9JTl9WQVJJQUJMRVMgPSBbXG4gIFwiYXJndW1lbnRzXCIsXG4gIFwidGhpc1wiLFxuICBcInN1cGVyXCIsXG4gIFwiY29uc29sZVwiLFxuICBcIndpbmRvd1wiLFxuICBcImRvY3VtZW50XCIsXG4gIFwibG9jYWxTdG9yYWdlXCIsXG4gIFwibW9kdWxlXCIsXG4gIFwiZ2xvYmFsXCIgLy8gTm9kZS5qc1xuXTtcblxuY29uc3QgQlVJTFRfSU5TID0gW10uY29uY2F0KFxuICBCVUlMVF9JTl9HTE9CQUxTLFxuICBUWVBFUyxcbiAgRVJST1JfVFlQRVNcbik7XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG4gKiBAcmV0dXJucyB7UmVnRXhwfVxuICogKi9cblxuLyoqXG4gKiBAcGFyYW0ge1JlZ0V4cCB8IHN0cmluZyB9IHJlXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBzb3VyY2UocmUpIHtcbiAgaWYgKCFyZSkgcmV0dXJuIG51bGw7XG4gIGlmICh0eXBlb2YgcmUgPT09IFwic3RyaW5nXCIpIHJldHVybiByZTtcblxuICByZXR1cm4gcmUuc291cmNlO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7UmVnRXhwIHwgc3RyaW5nIH0gcmVcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGxvb2thaGVhZChyZSkge1xuICByZXR1cm4gY29uY2F0KCcoPz0nLCByZSwgJyknKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0gey4uLihSZWdFeHAgfCBzdHJpbmcpIH0gYXJnc1xuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gY29uY2F0KC4uLmFyZ3MpIHtcbiAgY29uc3Qgam9pbmVkID0gYXJncy5tYXAoKHgpID0+IHNvdXJjZSh4KSkuam9pbihcIlwiKTtcbiAgcmV0dXJuIGpvaW5lZDtcbn1cblxuLypcbkxhbmd1YWdlOiBKYXZhU2NyaXB0XG5EZXNjcmlwdGlvbjogSmF2YVNjcmlwdCAoSlMpIGlzIGEgbGlnaHR3ZWlnaHQsIGludGVycHJldGVkLCBvciBqdXN0LWluLXRpbWUgY29tcGlsZWQgcHJvZ3JhbW1pbmcgbGFuZ3VhZ2Ugd2l0aCBmaXJzdC1jbGFzcyBmdW5jdGlvbnMuXG5DYXRlZ29yeTogY29tbW9uLCBzY3JpcHRpbmcsIHdlYlxuV2Vic2l0ZTogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdFxuKi9cblxuLyoqIEB0eXBlIExhbmd1YWdlRm4gKi9cbmZ1bmN0aW9uIGphdmFzY3JpcHQoaGxqcykge1xuICAvKipcbiAgICogVGFrZXMgYSBzdHJpbmcgbGlrZSBcIjxCb29nZXJcIiBhbmQgY2hlY2tzIHRvIHNlZVxuICAgKiBpZiB3ZSBjYW4gZmluZCBhIG1hdGNoaW5nIFwiPC9Cb29nZXJcIiBsYXRlciBpbiB0aGVcbiAgICogY29udGVudC5cbiAgICogQHBhcmFtIHtSZWdFeHBNYXRjaEFycmF5fSBtYXRjaFxuICAgKiBAcGFyYW0ge3thZnRlcjpudW1iZXJ9fSBwYXJhbTFcbiAgICovXG4gIGNvbnN0IGhhc0Nsb3NpbmdUYWcgPSAobWF0Y2gsIHsgYWZ0ZXIgfSkgPT4ge1xuICAgIGNvbnN0IHRhZyA9IFwiPC9cIiArIG1hdGNoWzBdLnNsaWNlKDEpO1xuICAgIGNvbnN0IHBvcyA9IG1hdGNoLmlucHV0LmluZGV4T2YodGFnLCBhZnRlcik7XG4gICAgcmV0dXJuIHBvcyAhPT0gLTE7XG4gIH07XG5cbiAgY29uc3QgSURFTlRfUkUkMSA9IElERU5UX1JFO1xuICBjb25zdCBGUkFHTUVOVCA9IHtcbiAgICBiZWdpbjogJzw+JyxcbiAgICBlbmQ6ICc8Lz4nXG4gIH07XG4gIGNvbnN0IFhNTF9UQUcgPSB7XG4gICAgYmVnaW46IC88W0EtWmEtejAtOVxcXFwuXzotXSsvLFxuICAgIGVuZDogL1xcL1tBLVphLXowLTlcXFxcLl86LV0rPnxcXC8+LyxcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1JlZ0V4cE1hdGNoQXJyYXl9IG1hdGNoXG4gICAgICogQHBhcmFtIHtDYWxsYmFja1Jlc3BvbnNlfSByZXNwb25zZVxuICAgICAqL1xuICAgIGlzVHJ1bHlPcGVuaW5nVGFnOiAobWF0Y2gsIHJlc3BvbnNlKSA9PiB7XG4gICAgICBjb25zdCBhZnRlck1hdGNoSW5kZXggPSBtYXRjaFswXS5sZW5ndGggKyBtYXRjaC5pbmRleDtcbiAgICAgIGNvbnN0IG5leHRDaGFyID0gbWF0Y2guaW5wdXRbYWZ0ZXJNYXRjaEluZGV4XTtcbiAgICAgIC8vIG5lc3RlZCB0eXBlP1xuICAgICAgLy8gSFRNTCBzaG91bGQgbm90IGluY2x1ZGUgYW5vdGhlciByYXcgYDxgIGluc2lkZSBhIHRhZ1xuICAgICAgLy8gQnV0IGEgdHlwZSBtaWdodDogYDxBcnJheTxBcnJheTxudW1iZXI+PmAsIGV0Yy5cbiAgICAgIGlmIChuZXh0Q2hhciA9PT0gXCI8XCIpIHtcbiAgICAgICAgcmVzcG9uc2UuaWdub3JlTWF0Y2goKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgLy8gPHNvbWV0aGluZz5cbiAgICAgIC8vIFRoaXMgaXMgbm93IGVpdGhlciBhIHRhZyBvciBhIHR5cGUuXG4gICAgICBpZiAobmV4dENoYXIgPT09IFwiPlwiKSB7XG4gICAgICAgIC8vIGlmIHdlIGNhbm5vdCBmaW5kIGEgbWF0Y2hpbmcgY2xvc2luZyB0YWcsIHRoZW4gd2VcbiAgICAgICAgLy8gd2lsbCBpZ25vcmUgaXRcbiAgICAgICAgaWYgKCFoYXNDbG9zaW5nVGFnKG1hdGNoLCB7IGFmdGVyOiBhZnRlck1hdGNoSW5kZXggfSkpIHtcbiAgICAgICAgICByZXNwb25zZS5pZ25vcmVNYXRjaCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xuICBjb25zdCBLRVlXT1JEUyQxID0ge1xuICAgICRwYXR0ZXJuOiBJREVOVF9SRSxcbiAgICBrZXl3b3JkOiBLRVlXT1JEUyxcbiAgICBsaXRlcmFsOiBMSVRFUkFMUyxcbiAgICBidWlsdF9pbjogQlVJTFRfSU5TLFxuICAgIFwidmFyaWFibGUubGFuZ3VhZ2VcIjogQlVJTFRfSU5fVkFSSUFCTEVTXG4gIH07XG5cbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1saXRlcmFscy1udW1lcmljLWxpdGVyYWxzXG4gIGNvbnN0IGRlY2ltYWxEaWdpdHMgPSAnWzAtOV0oXz9bMC05XSkqJztcbiAgY29uc3QgZnJhYyA9IGBcXFxcLigke2RlY2ltYWxEaWdpdHN9KWA7XG4gIC8vIERlY2ltYWxJbnRlZ2VyTGl0ZXJhbCwgaW5jbHVkaW5nIEFubmV4IEIgTm9uT2N0YWxEZWNpbWFsSW50ZWdlckxpdGVyYWxcbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hZGRpdGlvbmFsLXN5bnRheC1udW1lcmljLWxpdGVyYWxzXG4gIGNvbnN0IGRlY2ltYWxJbnRlZ2VyID0gYDB8WzEtOV0oXz9bMC05XSkqfDBbMC03XSpbODldWzAtOV0qYDtcbiAgY29uc3QgTlVNQkVSID0ge1xuICAgIGNsYXNzTmFtZTogJ251bWJlcicsXG4gICAgdmFyaWFudHM6IFtcbiAgICAgIC8vIERlY2ltYWxMaXRlcmFsXG4gICAgICB7IGJlZ2luOiBgKFxcXFxiKCR7ZGVjaW1hbEludGVnZXJ9KSgoJHtmcmFjfSl8XFxcXC4pP3woJHtmcmFjfSkpYCArXG4gICAgICAgIGBbZUVdWystXT8oJHtkZWNpbWFsRGlnaXRzfSlcXFxcYmAgfSxcbiAgICAgIHsgYmVnaW46IGBcXFxcYigke2RlY2ltYWxJbnRlZ2VyfSlcXFxcYigoJHtmcmFjfSlcXFxcYnxcXFxcLik/fCgke2ZyYWN9KVxcXFxiYCB9LFxuXG4gICAgICAvLyBEZWNpbWFsQmlnSW50ZWdlckxpdGVyYWxcbiAgICAgIHsgYmVnaW46IGBcXFxcYigwfFsxLTldKF8/WzAtOV0pKiluXFxcXGJgIH0sXG5cbiAgICAgIC8vIE5vbkRlY2ltYWxJbnRlZ2VyTGl0ZXJhbFxuICAgICAgeyBiZWdpbjogXCJcXFxcYjBbeFhdWzAtOWEtZkEtRl0oXz9bMC05YS1mQS1GXSkqbj9cXFxcYlwiIH0sXG4gICAgICB7IGJlZ2luOiBcIlxcXFxiMFtiQl1bMC0xXShfP1swLTFdKSpuP1xcXFxiXCIgfSxcbiAgICAgIHsgYmVnaW46IFwiXFxcXGIwW29PXVswLTddKF8/WzAtN10pKm4/XFxcXGJcIiB9LFxuXG4gICAgICAvLyBMZWdhY3lPY3RhbEludGVnZXJMaXRlcmFsIChkb2VzIG5vdCBpbmNsdWRlIHVuZGVyc2NvcmUgc2VwYXJhdG9ycylcbiAgICAgIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYWRkaXRpb25hbC1zeW50YXgtbnVtZXJpYy1saXRlcmFsc1xuICAgICAgeyBiZWdpbjogXCJcXFxcYjBbMC03XStuP1xcXFxiXCIgfSxcbiAgICBdLFxuICAgIHJlbGV2YW5jZTogMFxuICB9O1xuXG4gIGNvbnN0IFNVQlNUID0ge1xuICAgIGNsYXNzTmFtZTogJ3N1YnN0JyxcbiAgICBiZWdpbjogJ1xcXFwkXFxcXHsnLFxuICAgIGVuZDogJ1xcXFx9JyxcbiAgICBrZXl3b3JkczogS0VZV09SRFMkMSxcbiAgICBjb250YWluczogW10gLy8gZGVmaW5lZCBsYXRlclxuICB9O1xuICBjb25zdCBIVE1MX1RFTVBMQVRFID0ge1xuICAgIGJlZ2luOiAnaHRtbGAnLFxuICAgIGVuZDogJycsXG4gICAgc3RhcnRzOiB7XG4gICAgICBlbmQ6ICdgJyxcbiAgICAgIHJldHVybkVuZDogZmFsc2UsXG4gICAgICBjb250YWluczogW1xuICAgICAgICBobGpzLkJBQ0tTTEFTSF9FU0NBUEUsXG4gICAgICAgIFNVQlNUXG4gICAgICBdLFxuICAgICAgc3ViTGFuZ3VhZ2U6ICd4bWwnXG4gICAgfVxuICB9O1xuICBjb25zdCBDU1NfVEVNUExBVEUgPSB7XG4gICAgYmVnaW46ICdjc3NgJyxcbiAgICBlbmQ6ICcnLFxuICAgIHN0YXJ0czoge1xuICAgICAgZW5kOiAnYCcsXG4gICAgICByZXR1cm5FbmQ6IGZhbHNlLFxuICAgICAgY29udGFpbnM6IFtcbiAgICAgICAgaGxqcy5CQUNLU0xBU0hfRVNDQVBFLFxuICAgICAgICBTVUJTVFxuICAgICAgXSxcbiAgICAgIHN1Ykxhbmd1YWdlOiAnY3NzJ1xuICAgIH1cbiAgfTtcbiAgY29uc3QgVEVNUExBVEVfU1RSSU5HID0ge1xuICAgIGNsYXNzTmFtZTogJ3N0cmluZycsXG4gICAgYmVnaW46ICdgJyxcbiAgICBlbmQ6ICdgJyxcbiAgICBjb250YWluczogW1xuICAgICAgaGxqcy5CQUNLU0xBU0hfRVNDQVBFLFxuICAgICAgU1VCU1RcbiAgICBdXG4gIH07XG4gIGNvbnN0IEpTRE9DX0NPTU1FTlQgPSBobGpzLkNPTU1FTlQoXG4gICAgL1xcL1xcKlxcKig/IVxcLykvLFxuICAgICdcXFxcKi8nLFxuICAgIHtcbiAgICAgIHJlbGV2YW5jZTogMCxcbiAgICAgIGNvbnRhaW5zOiBbXG4gICAgICAgIHtcbiAgICAgICAgICBiZWdpbjogJyg/PUBbQS1aYS16XSspJyxcbiAgICAgICAgICByZWxldmFuY2U6IDAsXG4gICAgICAgICAgY29udGFpbnM6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgY2xhc3NOYW1lOiAnZG9jdGFnJyxcbiAgICAgICAgICAgICAgYmVnaW46ICdAW0EtWmEtel0rJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgY2xhc3NOYW1lOiAndHlwZScsXG4gICAgICAgICAgICAgIGJlZ2luOiAnXFxcXHsnLFxuICAgICAgICAgICAgICBlbmQ6ICdcXFxcfScsXG4gICAgICAgICAgICAgIGV4Y2x1ZGVFbmQ6IHRydWUsXG4gICAgICAgICAgICAgIGV4Y2x1ZGVCZWdpbjogdHJ1ZSxcbiAgICAgICAgICAgICAgcmVsZXZhbmNlOiAwXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBjbGFzc05hbWU6ICd2YXJpYWJsZScsXG4gICAgICAgICAgICAgIGJlZ2luOiBJREVOVF9SRSQxICsgJyg/PVxcXFxzKigtKXwkKScsXG4gICAgICAgICAgICAgIGVuZHNQYXJlbnQ6IHRydWUsXG4gICAgICAgICAgICAgIHJlbGV2YW5jZTogMFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIC8vIGVhdCBzcGFjZXMgKG5vdCBuZXdsaW5lcykgc28gd2UgY2FuIGZpbmRcbiAgICAgICAgICAgIC8vIHR5cGVzIG9yIHZhcmlhYmxlc1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBiZWdpbjogLyg/PVteXFxuXSlcXHMvLFxuICAgICAgICAgICAgICByZWxldmFuY2U6IDBcbiAgICAgICAgICAgIH1cbiAgICAgICAgICBdXG4gICAgICAgIH1cbiAgICAgIF1cbiAgICB9XG4gICk7XG4gIGNvbnN0IENPTU1FTlQgPSB7XG4gICAgY2xhc3NOYW1lOiBcImNvbW1lbnRcIixcbiAgICB2YXJpYW50czogW1xuICAgICAgSlNET0NfQ09NTUVOVCxcbiAgICAgIGhsanMuQ19CTE9DS19DT01NRU5UX01PREUsXG4gICAgICBobGpzLkNfTElORV9DT01NRU5UX01PREVcbiAgICBdXG4gIH07XG4gIGNvbnN0IFNVQlNUX0lOVEVSTkFMUyA9IFtcbiAgICBobGpzLkFQT1NfU1RSSU5HX01PREUsXG4gICAgaGxqcy5RVU9URV9TVFJJTkdfTU9ERSxcbiAgICBIVE1MX1RFTVBMQVRFLFxuICAgIENTU19URU1QTEFURSxcbiAgICBURU1QTEFURV9TVFJJTkcsXG4gICAgTlVNQkVSLFxuICAgIGhsanMuUkVHRVhQX01PREVcbiAgXTtcbiAgU1VCU1QuY29udGFpbnMgPSBTVUJTVF9JTlRFUk5BTFNcbiAgICAuY29uY2F0KHtcbiAgICAgIC8vIHdlIG5lZWQgdG8gcGFpciB1cCB7fSBpbnNpZGUgb3VyIHN1YnN0IHRvIHByZXZlbnRcbiAgICAgIC8vIGl0IGZyb20gZW5kaW5nIHRvbyBlYXJseSBieSBtYXRjaGluZyBhbm90aGVyIH1cbiAgICAgIGJlZ2luOiAvXFx7LyxcbiAgICAgIGVuZDogL1xcfS8sXG4gICAgICBrZXl3b3JkczogS0VZV09SRFMkMSxcbiAgICAgIGNvbnRhaW5zOiBbXG4gICAgICAgIFwic2VsZlwiXG4gICAgICBdLmNvbmNhdChTVUJTVF9JTlRFUk5BTFMpXG4gICAgfSk7XG4gIGNvbnN0IFNVQlNUX0FORF9DT01NRU5UUyA9IFtdLmNvbmNhdChDT01NRU5ULCBTVUJTVC5jb250YWlucyk7XG4gIGNvbnN0IFBBUkFNU19DT05UQUlOUyA9IFNVQlNUX0FORF9DT01NRU5UUy5jb25jYXQoW1xuICAgIC8vIGVhdCByZWN1cnNpdmUgcGFyZW5zIGluIHN1YiBleHByZXNzaW9uc1xuICAgIHtcbiAgICAgIGJlZ2luOiAvXFwoLyxcbiAgICAgIGVuZDogL1xcKS8sXG4gICAgICBrZXl3b3JkczogS0VZV09SRFMkMSxcbiAgICAgIGNvbnRhaW5zOiBbXCJzZWxmXCJdLmNvbmNhdChTVUJTVF9BTkRfQ09NTUVOVFMpXG4gICAgfVxuICBdKTtcbiAgY29uc3QgUEFSQU1TID0ge1xuICAgIGNsYXNzTmFtZTogJ3BhcmFtcycsXG4gICAgYmVnaW46IC9cXCgvLFxuICAgIGVuZDogL1xcKS8sXG4gICAgZXhjbHVkZUJlZ2luOiB0cnVlLFxuICAgIGV4Y2x1ZGVFbmQ6IHRydWUsXG4gICAga2V5d29yZHM6IEtFWVdPUkRTJDEsXG4gICAgY29udGFpbnM6IFBBUkFNU19DT05UQUlOU1xuICB9O1xuXG4gIC8vIEVTNiBjbGFzc2VzXG4gIGNvbnN0IENMQVNTX09SX0VYVEVORFMgPSB7XG4gICAgdmFyaWFudHM6IFtcbiAgICAgIHtcbiAgICAgICAgbWF0Y2g6IFtcbiAgICAgICAgICAvY2xhc3MvLFxuICAgICAgICAgIC9cXHMrLyxcbiAgICAgICAgICBJREVOVF9SRSQxXG4gICAgICAgIF0sXG4gICAgICAgIHNjb3BlOiB7XG4gICAgICAgICAgMTogXCJrZXl3b3JkXCIsXG4gICAgICAgICAgMzogXCJ0aXRsZS5jbGFzc1wiXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIG1hdGNoOiBbXG4gICAgICAgICAgL2V4dGVuZHMvLFxuICAgICAgICAgIC9cXHMrLyxcbiAgICAgICAgICBjb25jYXQoSURFTlRfUkUkMSwgXCIoXCIsIGNvbmNhdCgvXFwuLywgSURFTlRfUkUkMSksIFwiKSpcIilcbiAgICAgICAgXSxcbiAgICAgICAgc2NvcGU6IHtcbiAgICAgICAgICAxOiBcImtleXdvcmRcIixcbiAgICAgICAgICAzOiBcInRpdGxlLmNsYXNzLmluaGVyaXRlZFwiXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICBdXG4gIH07XG5cbiAgY29uc3QgQ0xBU1NfUkVGRVJFTkNFID0ge1xuICAgIHJlbGV2YW5jZTogMCxcbiAgICBtYXRjaDogL1xcYltBLVpdW2Etel0rKFtBLVpdW2Etel0rKSovLFxuICAgIGNsYXNzTmFtZTogXCJ0aXRsZS5jbGFzc1wiLFxuICAgIGtleXdvcmRzOiB7XG4gICAgICBfOiBbXG4gICAgICAgIC8vIHNlIHdlIHN0aWxsIGdldCByZWxldmFuY2UgY3JlZGl0IGZvciBKUyBsaWJyYXJ5IGNsYXNzZXNcbiAgICAgICAgLi4uVFlQRVMsXG4gICAgICAgIC4uLkVSUk9SX1RZUEVTXG4gICAgICBdXG4gICAgfVxuICB9O1xuXG4gIGNvbnN0IFVTRV9TVFJJQ1QgPSB7XG4gICAgbGFiZWw6IFwidXNlX3N0cmljdFwiLFxuICAgIGNsYXNzTmFtZTogJ21ldGEnLFxuICAgIHJlbGV2YW5jZTogMTAsXG4gICAgYmVnaW46IC9eXFxzKlsnXCJddXNlIChzdHJpY3R8YXNtKVsnXCJdL1xuICB9O1xuXG4gIGNvbnN0IEZVTkNUSU9OX0RFRklOSVRJT04gPSB7XG4gICAgdmFyaWFudHM6IFtcbiAgICAgIHtcbiAgICAgICAgbWF0Y2g6IFtcbiAgICAgICAgICAvZnVuY3Rpb24vLFxuICAgICAgICAgIC9cXHMrLyxcbiAgICAgICAgICBJREVOVF9SRSQxLFxuICAgICAgICAgIC8oPz1cXHMqXFwoKS9cbiAgICAgICAgXVxuICAgICAgfSxcbiAgICAgIC8vIGFub255bW91cyBmdW5jdGlvblxuICAgICAge1xuICAgICAgICBtYXRjaDogW1xuICAgICAgICAgIC9mdW5jdGlvbi8sXG4gICAgICAgICAgL1xccyooPz1cXCgpL1xuICAgICAgICBdXG4gICAgICB9XG4gICAgXSxcbiAgICBjbGFzc05hbWU6IHtcbiAgICAgIDE6IFwia2V5d29yZFwiLFxuICAgICAgMzogXCJ0aXRsZS5mdW5jdGlvblwiXG4gICAgfSxcbiAgICBsYWJlbDogXCJmdW5jLmRlZlwiLFxuICAgIGNvbnRhaW5zOiBbIFBBUkFNUyBdLFxuICAgIGlsbGVnYWw6IC8lL1xuICB9O1xuXG4gIGNvbnN0IFVQUEVSX0NBU0VfQ09OU1RBTlQgPSB7XG4gICAgcmVsZXZhbmNlOiAwLFxuICAgIG1hdGNoOiAvXFxiW0EtWl1bQS1aXzAtOV0rXFxiLyxcbiAgICBjbGFzc05hbWU6IFwidmFyaWFibGUuY29uc3RhbnRcIlxuICB9O1xuXG4gIGZ1bmN0aW9uIG5vbmVPZihsaXN0KSB7XG4gICAgcmV0dXJuIGNvbmNhdChcIig/IVwiLCBsaXN0LmpvaW4oXCJ8XCIpLCBcIilcIik7XG4gIH1cblxuICBjb25zdCBGVU5DVElPTl9DQUxMID0ge1xuICAgIG1hdGNoOiBjb25jYXQoXG4gICAgICAvXFxiLyxcbiAgICAgIG5vbmVPZihbXG4gICAgICAgIC4uLkJVSUxUX0lOX0dMT0JBTFMsXG4gICAgICAgIFwic3VwZXJcIlxuICAgICAgXSksXG4gICAgICBJREVOVF9SRSQxLCBsb29rYWhlYWQoL1xcKC8pKSxcbiAgICBjbGFzc05hbWU6IFwidGl0bGUuZnVuY3Rpb25cIixcbiAgICByZWxldmFuY2U6IDBcbiAgfTtcblxuICBjb25zdCBQUk9QRVJUWV9BQ0NFU1MgPSB7XG4gICAgYmVnaW46IGNvbmNhdCgvXFwuLywgbG9va2FoZWFkKFxuICAgICAgY29uY2F0KElERU5UX1JFJDEsIC8oPyFbMC05QS1aYS16JF8oXSkvKVxuICAgICkpLFxuICAgIGVuZDogSURFTlRfUkUkMSxcbiAgICBleGNsdWRlQmVnaW46IHRydWUsXG4gICAga2V5d29yZHM6IFwicHJvdG90eXBlXCIsXG4gICAgY2xhc3NOYW1lOiBcInByb3BlcnR5XCIsXG4gICAgcmVsZXZhbmNlOiAwXG4gIH07XG5cbiAgY29uc3QgR0VUVEVSX09SX1NFVFRFUiA9IHtcbiAgICBtYXRjaDogW1xuICAgICAgL2dldHxzZXQvLFxuICAgICAgL1xccysvLFxuICAgICAgSURFTlRfUkUkMSxcbiAgICAgIC8oPz1cXCgpL1xuICAgIF0sXG4gICAgY2xhc3NOYW1lOiB7XG4gICAgICAxOiBcImtleXdvcmRcIixcbiAgICAgIDM6IFwidGl0bGUuZnVuY3Rpb25cIlxuICAgIH0sXG4gICAgY29udGFpbnM6IFtcbiAgICAgIHsgLy8gZWF0IHRvIGF2b2lkIGVtcHR5IHBhcmFtc1xuICAgICAgICBiZWdpbjogL1xcKFxcKS9cbiAgICAgIH0sXG4gICAgICBQQVJBTVNcbiAgICBdXG4gIH07XG5cbiAgY29uc3QgRlVOQ19MRUFEX0lOX1JFID0gJyhcXFxcKCcgK1xuICAgICdbXigpXSooXFxcXCgnICtcbiAgICAnW14oKV0qKFxcXFwoJyArXG4gICAgJ1teKCldKicgK1xuICAgICdcXFxcKVteKCldKikqJyArXG4gICAgJ1xcXFwpW14oKV0qKSonICtcbiAgICAnXFxcXCl8JyArIGhsanMuVU5ERVJTQ09SRV9JREVOVF9SRSArICcpXFxcXHMqPT4nO1xuXG4gIGNvbnN0IEZVTkNUSU9OX1ZBUklBQkxFID0ge1xuICAgIG1hdGNoOiBbXG4gICAgICAvY29uc3R8dmFyfGxldC8sIC9cXHMrLyxcbiAgICAgIElERU5UX1JFJDEsIC9cXHMqLyxcbiAgICAgIC89XFxzKi8sXG4gICAgICBsb29rYWhlYWQoRlVOQ19MRUFEX0lOX1JFKVxuICAgIF0sXG4gICAgY2xhc3NOYW1lOiB7XG4gICAgICAxOiBcImtleXdvcmRcIixcbiAgICAgIDM6IFwidGl0bGUuZnVuY3Rpb25cIlxuICAgIH0sXG4gICAgY29udGFpbnM6IFtcbiAgICAgIFBBUkFNU1xuICAgIF1cbiAgfTtcblxuICByZXR1cm4ge1xuICAgIG5hbWU6ICdKYXZhc2NyaXB0JyxcbiAgICBhbGlhc2VzOiBbJ2pzJywgJ2pzeCcsICdtanMnLCAnY2pzJ10sXG4gICAga2V5d29yZHM6IEtFWVdPUkRTJDEsXG4gICAgLy8gdGhpcyB3aWxsIGJlIGV4dGVuZGVkIGJ5IFR5cGVTY3JpcHRcbiAgICBleHBvcnRzOiB7IFBBUkFNU19DT05UQUlOUyB9LFxuICAgIGlsbGVnYWw6IC8jKD8hWyRfQS16XSkvLFxuICAgIGNvbnRhaW5zOiBbXG4gICAgICBobGpzLlNIRUJBTkcoe1xuICAgICAgICBsYWJlbDogXCJzaGViYW5nXCIsXG4gICAgICAgIGJpbmFyeTogXCJub2RlXCIsXG4gICAgICAgIHJlbGV2YW5jZTogNVxuICAgICAgfSksXG4gICAgICBVU0VfU1RSSUNULFxuICAgICAgaGxqcy5BUE9TX1NUUklOR19NT0RFLFxuICAgICAgaGxqcy5RVU9URV9TVFJJTkdfTU9ERSxcbiAgICAgIEhUTUxfVEVNUExBVEUsXG4gICAgICBDU1NfVEVNUExBVEUsXG4gICAgICBURU1QTEFURV9TVFJJTkcsXG4gICAgICBDT01NRU5ULFxuICAgICAgTlVNQkVSLFxuICAgICAgQ0xBU1NfUkVGRVJFTkNFLFxuICAgICAge1xuICAgICAgICBjbGFzc05hbWU6ICdhdHRyJyxcbiAgICAgICAgYmVnaW46IElERU5UX1JFJDEgKyBsb29rYWhlYWQoJzonKSxcbiAgICAgICAgcmVsZXZhbmNlOiAwXG4gICAgICB9LFxuICAgICAgRlVOQ1RJT05fVkFSSUFCTEUsXG4gICAgICB7IC8vIFwidmFsdWVcIiBjb250YWluZXJcbiAgICAgICAgYmVnaW46ICcoJyArIGhsanMuUkVfU1RBUlRFUlNfUkUgKyAnfFxcXFxiKGNhc2V8cmV0dXJufHRocm93KVxcXFxiKVxcXFxzKicsXG4gICAgICAgIGtleXdvcmRzOiAncmV0dXJuIHRocm93IGNhc2UnLFxuICAgICAgICByZWxldmFuY2U6IDAsXG4gICAgICAgIGNvbnRhaW5zOiBbXG4gICAgICAgICAgQ09NTUVOVCxcbiAgICAgICAgICBobGpzLlJFR0VYUF9NT0RFLFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGNsYXNzTmFtZTogJ2Z1bmN0aW9uJyxcbiAgICAgICAgICAgIC8vIHdlIGhhdmUgdG8gY291bnQgdGhlIHBhcmVucyB0byBtYWtlIHN1cmUgd2UgYWN0dWFsbHkgaGF2ZSB0aGVcbiAgICAgICAgICAgIC8vIGNvcnJlY3QgYm91bmRpbmcgKCApIGJlZm9yZSB0aGUgPT4uICBUaGVyZSBjb3VsZCBiZSBhbnkgbnVtYmVyIG9mXG4gICAgICAgICAgICAvLyBzdWItZXhwcmVzc2lvbnMgaW5zaWRlIGFsc28gc3Vycm91bmRlZCBieSBwYXJlbnMuXG4gICAgICAgICAgICBiZWdpbjogRlVOQ19MRUFEX0lOX1JFLFxuICAgICAgICAgICAgcmV0dXJuQmVnaW46IHRydWUsXG4gICAgICAgICAgICBlbmQ6ICdcXFxccyo9PicsXG4gICAgICAgICAgICBjb250YWluczogW1xuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lOiAncGFyYW1zJyxcbiAgICAgICAgICAgICAgICB2YXJpYW50czogW1xuICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBiZWdpbjogaGxqcy5VTkRFUlNDT1JFX0lERU5UX1JFLFxuICAgICAgICAgICAgICAgICAgICByZWxldmFuY2U6IDBcbiAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgYmVnaW46IC9cXChcXHMqXFwpLyxcbiAgICAgICAgICAgICAgICAgICAgc2tpcDogdHJ1ZVxuICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgYmVnaW46IC9cXCgvLFxuICAgICAgICAgICAgICAgICAgICBlbmQ6IC9cXCkvLFxuICAgICAgICAgICAgICAgICAgICBleGNsdWRlQmVnaW46IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGV4Y2x1ZGVFbmQ6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGtleXdvcmRzOiBLRVlXT1JEUyQxLFxuICAgICAgICAgICAgICAgICAgICBjb250YWluczogUEFSQU1TX0NPTlRBSU5TXG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBdXG4gICAgICAgICAgfSxcbiAgICAgICAgICB7IC8vIGNvdWxkIGJlIGEgY29tbWEgZGVsaW1pdGVkIGxpc3Qgb2YgcGFyYW1zIHRvIGEgZnVuY3Rpb24gY2FsbFxuICAgICAgICAgICAgYmVnaW46IC8sLyxcbiAgICAgICAgICAgIHJlbGV2YW5jZTogMFxuICAgICAgICAgIH0sXG4gICAgICAgICAge1xuICAgICAgICAgICAgbWF0Y2g6IC9cXHMrLyxcbiAgICAgICAgICAgIHJlbGV2YW5jZTogMFxuICAgICAgICAgIH0sXG4gICAgICAgICAgeyAvLyBKU1hcbiAgICAgICAgICAgIHZhcmlhbnRzOiBbXG4gICAgICAgICAgICAgIHsgYmVnaW46IEZSQUdNRU5ULmJlZ2luLCBlbmQ6IEZSQUdNRU5ULmVuZCB9LFxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgYmVnaW46IFhNTF9UQUcuYmVnaW4sXG4gICAgICAgICAgICAgICAgLy8gd2UgY2FyZWZ1bGx5IGNoZWNrIHRoZSBvcGVuaW5nIHRhZyB0byBzZWUgaWYgaXQgdHJ1bHlcbiAgICAgICAgICAgICAgICAvLyBpcyBhIHRhZyBhbmQgbm90IGEgZmFsc2UgcG9zaXRpdmVcbiAgICAgICAgICAgICAgICAnb246YmVnaW4nOiBYTUxfVEFHLmlzVHJ1bHlPcGVuaW5nVGFnLFxuICAgICAgICAgICAgICAgIGVuZDogWE1MX1RBRy5lbmRcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIHN1Ykxhbmd1YWdlOiAneG1sJyxcbiAgICAgICAgICAgIGNvbnRhaW5zOiBbXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBiZWdpbjogWE1MX1RBRy5iZWdpbixcbiAgICAgICAgICAgICAgICBlbmQ6IFhNTF9UQUcuZW5kLFxuICAgICAgICAgICAgICAgIHNraXA6IHRydWUsXG4gICAgICAgICAgICAgICAgY29udGFpbnM6IFsnc2VsZiddXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF1cbiAgICAgICAgICB9XG4gICAgICAgIF0sXG4gICAgICB9LFxuICAgICAgRlVOQ1RJT05fREVGSU5JVElPTixcbiAgICAgIHtcbiAgICAgICAgLy8gcHJldmVudCB0aGlzIGZyb20gZ2V0dGluZyBzd2FsbG93ZWQgdXAgYnkgZnVuY3Rpb25cbiAgICAgICAgLy8gc2luY2UgdGhleSBhcHBlYXIgXCJmdW5jdGlvbiBsaWtlXCJcbiAgICAgICAgYmVnaW5LZXl3b3JkczogXCJ3aGlsZSBpZiBzd2l0Y2ggY2F0Y2ggZm9yXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIC8vIHdlIGhhdmUgdG8gY291bnQgdGhlIHBhcmVucyB0byBtYWtlIHN1cmUgd2UgYWN0dWFsbHkgaGF2ZSB0aGUgY29ycmVjdFxuICAgICAgICAvLyBib3VuZGluZyAoICkuICBUaGVyZSBjb3VsZCBiZSBhbnkgbnVtYmVyIG9mIHN1Yi1leHByZXNzaW9ucyBpbnNpZGVcbiAgICAgICAgLy8gYWxzbyBzdXJyb3VuZGVkIGJ5IHBhcmVucy5cbiAgICAgICAgYmVnaW46ICdcXFxcYig/IWZ1bmN0aW9uKScgKyBobGpzLlVOREVSU0NPUkVfSURFTlRfUkUgK1xuICAgICAgICAgICdcXFxcKCcgKyAvLyBmaXJzdCBwYXJlbnNcbiAgICAgICAgICAnW14oKV0qKFxcXFwoJyArXG4gICAgICAgICAgICAnW14oKV0qKFxcXFwoJyArXG4gICAgICAgICAgICAgICdbXigpXSonICtcbiAgICAgICAgICAgICdcXFxcKVteKCldKikqJyArXG4gICAgICAgICAgJ1xcXFwpW14oKV0qKSonICtcbiAgICAgICAgICAnXFxcXClcXFxccypcXFxceycsIC8vIGVuZCBwYXJlbnNcbiAgICAgICAgcmV0dXJuQmVnaW46dHJ1ZSxcbiAgICAgICAgbGFiZWw6IFwiZnVuYy5kZWZcIixcbiAgICAgICAgY29udGFpbnM6IFtcbiAgICAgICAgICBQQVJBTVMsXG4gICAgICAgICAgaGxqcy5pbmhlcml0KGhsanMuVElUTEVfTU9ERSwgeyBiZWdpbjogSURFTlRfUkUkMSwgY2xhc3NOYW1lOiBcInRpdGxlLmZ1bmN0aW9uXCIgfSlcbiAgICAgICAgXVxuICAgICAgfSxcbiAgICAgIC8vIGNhdGNoIC4uLiBzbyBpdCB3b24ndCB0cmlnZ2VyIHRoZSBwcm9wZXJ0eSBydWxlIGJlbG93XG4gICAgICB7XG4gICAgICAgIG1hdGNoOiAvXFwuXFwuXFwuLyxcbiAgICAgICAgcmVsZXZhbmNlOiAwXG4gICAgICB9LFxuICAgICAgUFJPUEVSVFlfQUNDRVNTLFxuICAgICAgLy8gaGFjazogcHJldmVudHMgZGV0ZWN0aW9uIG9mIGtleXdvcmRzIGluIHNvbWUgY2lyY3Vtc3RhbmNlc1xuICAgICAgLy8gLmtleXdvcmQoKVxuICAgICAgLy8gJGtleXdvcmQgPSB4XG4gICAgICB7XG4gICAgICAgIG1hdGNoOiAnXFxcXCQnICsgSURFTlRfUkUkMSxcbiAgICAgICAgcmVsZXZhbmNlOiAwXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBtYXRjaDogWyAvXFxiY29uc3RydWN0b3IoPz1cXHMqXFwoKS8gXSxcbiAgICAgICAgY2xhc3NOYW1lOiB7IDE6IFwidGl0bGUuZnVuY3Rpb25cIiB9LFxuICAgICAgICBjb250YWluczogWyBQQVJBTVMgXVxuICAgICAgfSxcbiAgICAgIEZVTkNUSU9OX0NBTEwsXG4gICAgICBVUFBFUl9DQVNFX0NPTlNUQU5ULFxuICAgICAgQ0xBU1NfT1JfRVhURU5EUyxcbiAgICAgIEdFVFRFUl9PUl9TRVRURVIsXG4gICAgICB7XG4gICAgICAgIG1hdGNoOiAvXFwkWyguXS8gLy8gcmVsZXZhbmNlIGJvb3N0ZXIgZm9yIGEgcGF0dGVybiBjb21tb24gdG8gSlMgbGliczogYCQoc29tZXRoaW5nKWAgYW5kIGAkLnNvbWV0aGluZ2BcbiAgICAgIH1cbiAgICBdXG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGphdmFzY3JpcHQ7XG4iLCJjb25zdCBNT0RFUyA9IChobGpzKSA9PiB7XG4gIHJldHVybiB7XG4gICAgSU1QT1JUQU5UOiB7XG4gICAgICBzY29wZTogJ21ldGEnLFxuICAgICAgYmVnaW46ICchaW1wb3J0YW50J1xuICAgIH0sXG4gICAgSEVYQ09MT1I6IHtcbiAgICAgIHNjb3BlOiAnbnVtYmVyJyxcbiAgICAgIGJlZ2luOiAnIyhbYS1mQS1GMC05XXs2fXxbYS1mQS1GMC05XXszfSknXG4gICAgfSxcbiAgICBBVFRSSUJVVEVfU0VMRUNUT1JfTU9ERToge1xuICAgICAgc2NvcGU6ICdzZWxlY3Rvci1hdHRyJyxcbiAgICAgIGJlZ2luOiAvXFxbLyxcbiAgICAgIGVuZDogL1xcXS8sXG4gICAgICBpbGxlZ2FsOiAnJCcsXG4gICAgICBjb250YWluczogW1xuICAgICAgICBobGpzLkFQT1NfU1RSSU5HX01PREUsXG4gICAgICAgIGhsanMuUVVPVEVfU1RSSU5HX01PREVcbiAgICAgIF1cbiAgICB9LFxuICAgIENTU19OVU1CRVJfTU9ERToge1xuICAgICAgc2NvcGU6ICdudW1iZXInLFxuICAgICAgYmVnaW46IGhsanMuTlVNQkVSX1JFICsgJygnICtcbiAgICAgICAgJyV8ZW18ZXh8Y2h8cmVtJyArXG4gICAgICAgICd8dnd8dmh8dm1pbnx2bWF4JyArXG4gICAgICAgICd8Y218bW18aW58cHR8cGN8cHgnICtcbiAgICAgICAgJ3xkZWd8Z3JhZHxyYWR8dHVybicgK1xuICAgICAgICAnfHN8bXMnICtcbiAgICAgICAgJ3xIenxrSHonICtcbiAgICAgICAgJ3xkcGl8ZHBjbXxkcHB4JyArXG4gICAgICAgICcpPycsXG4gICAgICByZWxldmFuY2U6IDBcbiAgICB9LFxuICAgIENTU19WQVJJQUJMRToge1xuICAgICAgY2xhc3NOYW1lOiBcImF0dHJcIixcbiAgICAgIGJlZ2luOiAvLS1bQS1aYS16XVtBLVphLXowLTlfLV0qL1xuICAgIH1cbiAgfTtcbn07XG5cbmNvbnN0IFRBR1MgPSBbXG4gICdhJyxcbiAgJ2FiYnInLFxuICAnYWRkcmVzcycsXG4gICdhcnRpY2xlJyxcbiAgJ2FzaWRlJyxcbiAgJ2F1ZGlvJyxcbiAgJ2InLFxuICAnYmxvY2txdW90ZScsXG4gICdib2R5JyxcbiAgJ2J1dHRvbicsXG4gICdjYW52YXMnLFxuICAnY2FwdGlvbicsXG4gICdjaXRlJyxcbiAgJ2NvZGUnLFxuICAnZGQnLFxuICAnZGVsJyxcbiAgJ2RldGFpbHMnLFxuICAnZGZuJyxcbiAgJ2RpdicsXG4gICdkbCcsXG4gICdkdCcsXG4gICdlbScsXG4gICdmaWVsZHNldCcsXG4gICdmaWdjYXB0aW9uJyxcbiAgJ2ZpZ3VyZScsXG4gICdmb290ZXInLFxuICAnZm9ybScsXG4gICdoMScsXG4gICdoMicsXG4gICdoMycsXG4gICdoNCcsXG4gICdoNScsXG4gICdoNicsXG4gICdoZWFkZXInLFxuICAnaGdyb3VwJyxcbiAgJ2h0bWwnLFxuICAnaScsXG4gICdpZnJhbWUnLFxuICAnaW1nJyxcbiAgJ2lucHV0JyxcbiAgJ2lucycsXG4gICdrYmQnLFxuICAnbGFiZWwnLFxuICAnbGVnZW5kJyxcbiAgJ2xpJyxcbiAgJ21haW4nLFxuICAnbWFyaycsXG4gICdtZW51JyxcbiAgJ25hdicsXG4gICdvYmplY3QnLFxuICAnb2wnLFxuICAncCcsXG4gICdxJyxcbiAgJ3F1b3RlJyxcbiAgJ3NhbXAnLFxuICAnc2VjdGlvbicsXG4gICdzcGFuJyxcbiAgJ3N0cm9uZycsXG4gICdzdW1tYXJ5JyxcbiAgJ3N1cCcsXG4gICd0YWJsZScsXG4gICd0Ym9keScsXG4gICd0ZCcsXG4gICd0ZXh0YXJlYScsXG4gICd0Zm9vdCcsXG4gICd0aCcsXG4gICd0aGVhZCcsXG4gICd0aW1lJyxcbiAgJ3RyJyxcbiAgJ3VsJyxcbiAgJ3ZhcicsXG4gICd2aWRlbydcbl07XG5cbmNvbnN0IE1FRElBX0ZFQVRVUkVTID0gW1xuICAnYW55LWhvdmVyJyxcbiAgJ2FueS1wb2ludGVyJyxcbiAgJ2FzcGVjdC1yYXRpbycsXG4gICdjb2xvcicsXG4gICdjb2xvci1nYW11dCcsXG4gICdjb2xvci1pbmRleCcsXG4gICdkZXZpY2UtYXNwZWN0LXJhdGlvJyxcbiAgJ2RldmljZS1oZWlnaHQnLFxuICAnZGV2aWNlLXdpZHRoJyxcbiAgJ2Rpc3BsYXktbW9kZScsXG4gICdmb3JjZWQtY29sb3JzJyxcbiAgJ2dyaWQnLFxuICAnaGVpZ2h0JyxcbiAgJ2hvdmVyJyxcbiAgJ2ludmVydGVkLWNvbG9ycycsXG4gICdtb25vY2hyb21lJyxcbiAgJ29yaWVudGF0aW9uJyxcbiAgJ292ZXJmbG93LWJsb2NrJyxcbiAgJ292ZXJmbG93LWlubGluZScsXG4gICdwb2ludGVyJyxcbiAgJ3ByZWZlcnMtY29sb3Itc2NoZW1lJyxcbiAgJ3ByZWZlcnMtY29udHJhc3QnLFxuICAncHJlZmVycy1yZWR1Y2VkLW1vdGlvbicsXG4gICdwcmVmZXJzLXJlZHVjZWQtdHJhbnNwYXJlbmN5JyxcbiAgJ3Jlc29sdXRpb24nLFxuICAnc2NhbicsXG4gICdzY3JpcHRpbmcnLFxuICAndXBkYXRlJyxcbiAgJ3dpZHRoJyxcbiAgLy8gVE9ETzogZmluZCBhIGJldHRlciBzb2x1dGlvbj9cbiAgJ21pbi13aWR0aCcsXG4gICdtYXgtd2lkdGgnLFxuICAnbWluLWhlaWdodCcsXG4gICdtYXgtaGVpZ2h0J1xuXTtcblxuLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQ1NTL1BzZXVkby1jbGFzc2VzXG5jb25zdCBQU0VVRE9fQ0xBU1NFUyA9IFtcbiAgJ2FjdGl2ZScsXG4gICdhbnktbGluaycsXG4gICdibGFuaycsXG4gICdjaGVja2VkJyxcbiAgJ2N1cnJlbnQnLFxuICAnZGVmYXVsdCcsXG4gICdkZWZpbmVkJyxcbiAgJ2RpcicsIC8vIGRpcigpXG4gICdkaXNhYmxlZCcsXG4gICdkcm9wJyxcbiAgJ2VtcHR5JyxcbiAgJ2VuYWJsZWQnLFxuICAnZmlyc3QnLFxuICAnZmlyc3QtY2hpbGQnLFxuICAnZmlyc3Qtb2YtdHlwZScsXG4gICdmdWxsc2NyZWVuJyxcbiAgJ2Z1dHVyZScsXG4gICdmb2N1cycsXG4gICdmb2N1cy12aXNpYmxlJyxcbiAgJ2ZvY3VzLXdpdGhpbicsXG4gICdoYXMnLCAvLyBoYXMoKVxuICAnaG9zdCcsIC8vIGhvc3Qgb3IgaG9zdCgpXG4gICdob3N0LWNvbnRleHQnLCAvLyBob3N0LWNvbnRleHQoKVxuICAnaG92ZXInLFxuICAnaW5kZXRlcm1pbmF0ZScsXG4gICdpbi1yYW5nZScsXG4gICdpbnZhbGlkJyxcbiAgJ2lzJywgLy8gaXMoKVxuICAnbGFuZycsIC8vIGxhbmcoKVxuICAnbGFzdC1jaGlsZCcsXG4gICdsYXN0LW9mLXR5cGUnLFxuICAnbGVmdCcsXG4gICdsaW5rJyxcbiAgJ2xvY2FsLWxpbmsnLFxuICAnbm90JywgLy8gbm90KClcbiAgJ250aC1jaGlsZCcsIC8vIG50aC1jaGlsZCgpXG4gICdudGgtY29sJywgLy8gbnRoLWNvbCgpXG4gICdudGgtbGFzdC1jaGlsZCcsIC8vIG50aC1sYXN0LWNoaWxkKClcbiAgJ250aC1sYXN0LWNvbCcsIC8vIG50aC1sYXN0LWNvbCgpXG4gICdudGgtbGFzdC1vZi10eXBlJywgLy9udGgtbGFzdC1vZi10eXBlKClcbiAgJ250aC1vZi10eXBlJywgLy9udGgtb2YtdHlwZSgpXG4gICdvbmx5LWNoaWxkJyxcbiAgJ29ubHktb2YtdHlwZScsXG4gICdvcHRpb25hbCcsXG4gICdvdXQtb2YtcmFuZ2UnLFxuICAncGFzdCcsXG4gICdwbGFjZWhvbGRlci1zaG93bicsXG4gICdyZWFkLW9ubHknLFxuICAncmVhZC13cml0ZScsXG4gICdyZXF1aXJlZCcsXG4gICdyaWdodCcsXG4gICdyb290JyxcbiAgJ3Njb3BlJyxcbiAgJ3RhcmdldCcsXG4gICd0YXJnZXQtd2l0aGluJyxcbiAgJ3VzZXItaW52YWxpZCcsXG4gICd2YWxpZCcsXG4gICd2aXNpdGVkJyxcbiAgJ3doZXJlJyAvLyB3aGVyZSgpXG5dO1xuXG4vLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9DU1MvUHNldWRvLWVsZW1lbnRzXG5jb25zdCBQU0VVRE9fRUxFTUVOVFMgPSBbXG4gICdhZnRlcicsXG4gICdiYWNrZHJvcCcsXG4gICdiZWZvcmUnLFxuICAnY3VlJyxcbiAgJ2N1ZS1yZWdpb24nLFxuICAnZmlyc3QtbGV0dGVyJyxcbiAgJ2ZpcnN0LWxpbmUnLFxuICAnZ3JhbW1hci1lcnJvcicsXG4gICdtYXJrZXInLFxuICAncGFydCcsXG4gICdwbGFjZWhvbGRlcicsXG4gICdzZWxlY3Rpb24nLFxuICAnc2xvdHRlZCcsXG4gICdzcGVsbGluZy1lcnJvcidcbl07XG5cbmNvbnN0IEFUVFJJQlVURVMgPSBbXG4gICdhbGlnbi1jb250ZW50JyxcbiAgJ2FsaWduLWl0ZW1zJyxcbiAgJ2FsaWduLXNlbGYnLFxuICAnYW5pbWF0aW9uJyxcbiAgJ2FuaW1hdGlvbi1kZWxheScsXG4gICdhbmltYXRpb24tZGlyZWN0aW9uJyxcbiAgJ2FuaW1hdGlvbi1kdXJhdGlvbicsXG4gICdhbmltYXRpb24tZmlsbC1tb2RlJyxcbiAgJ2FuaW1hdGlvbi1pdGVyYXRpb24tY291bnQnLFxuICAnYW5pbWF0aW9uLW5hbWUnLFxuICAnYW5pbWF0aW9uLXBsYXktc3RhdGUnLFxuICAnYW5pbWF0aW9uLXRpbWluZy1mdW5jdGlvbicsXG4gICdhdXRvJyxcbiAgJ2JhY2tmYWNlLXZpc2liaWxpdHknLFxuICAnYmFja2dyb3VuZCcsXG4gICdiYWNrZ3JvdW5kLWF0dGFjaG1lbnQnLFxuICAnYmFja2dyb3VuZC1jbGlwJyxcbiAgJ2JhY2tncm91bmQtY29sb3InLFxuICAnYmFja2dyb3VuZC1pbWFnZScsXG4gICdiYWNrZ3JvdW5kLW9yaWdpbicsXG4gICdiYWNrZ3JvdW5kLXBvc2l0aW9uJyxcbiAgJ2JhY2tncm91bmQtcmVwZWF0JyxcbiAgJ2JhY2tncm91bmQtc2l6ZScsXG4gICdib3JkZXInLFxuICAnYm9yZGVyLWJvdHRvbScsXG4gICdib3JkZXItYm90dG9tLWNvbG9yJyxcbiAgJ2JvcmRlci1ib3R0b20tbGVmdC1yYWRpdXMnLFxuICAnYm9yZGVyLWJvdHRvbS1yaWdodC1yYWRpdXMnLFxuICAnYm9yZGVyLWJvdHRvbS1zdHlsZScsXG4gICdib3JkZXItYm90dG9tLXdpZHRoJyxcbiAgJ2JvcmRlci1jb2xsYXBzZScsXG4gICdib3JkZXItY29sb3InLFxuICAnYm9yZGVyLWltYWdlJyxcbiAgJ2JvcmRlci1pbWFnZS1vdXRzZXQnLFxuICAnYm9yZGVyLWltYWdlLXJlcGVhdCcsXG4gICdib3JkZXItaW1hZ2Utc2xpY2UnLFxuICAnYm9yZGVyLWltYWdlLXNvdXJjZScsXG4gICdib3JkZXItaW1hZ2Utd2lkdGgnLFxuICAnYm9yZGVyLWxlZnQnLFxuICAnYm9yZGVyLWxlZnQtY29sb3InLFxuICAnYm9yZGVyLWxlZnQtc3R5bGUnLFxuICAnYm9yZGVyLWxlZnQtd2lkdGgnLFxuICAnYm9yZGVyLXJhZGl1cycsXG4gICdib3JkZXItcmlnaHQnLFxuICAnYm9yZGVyLXJpZ2h0LWNvbG9yJyxcbiAgJ2JvcmRlci1yaWdodC1zdHlsZScsXG4gICdib3JkZXItcmlnaHQtd2lkdGgnLFxuICAnYm9yZGVyLXNwYWNpbmcnLFxuICAnYm9yZGVyLXN0eWxlJyxcbiAgJ2JvcmRlci10b3AnLFxuICAnYm9yZGVyLXRvcC1jb2xvcicsXG4gICdib3JkZXItdG9wLWxlZnQtcmFkaXVzJyxcbiAgJ2JvcmRlci10b3AtcmlnaHQtcmFkaXVzJyxcbiAgJ2JvcmRlci10b3Atc3R5bGUnLFxuICAnYm9yZGVyLXRvcC13aWR0aCcsXG4gICdib3JkZXItd2lkdGgnLFxuICAnYm90dG9tJyxcbiAgJ2JveC1kZWNvcmF0aW9uLWJyZWFrJyxcbiAgJ2JveC1zaGFkb3cnLFxuICAnYm94LXNpemluZycsXG4gICdicmVhay1hZnRlcicsXG4gICdicmVhay1iZWZvcmUnLFxuICAnYnJlYWstaW5zaWRlJyxcbiAgJ2NhcHRpb24tc2lkZScsXG4gICdjbGVhcicsXG4gICdjbGlwJyxcbiAgJ2NsaXAtcGF0aCcsXG4gICdjb2xvcicsXG4gICdjb2x1bW4tY291bnQnLFxuICAnY29sdW1uLWZpbGwnLFxuICAnY29sdW1uLWdhcCcsXG4gICdjb2x1bW4tcnVsZScsXG4gICdjb2x1bW4tcnVsZS1jb2xvcicsXG4gICdjb2x1bW4tcnVsZS1zdHlsZScsXG4gICdjb2x1bW4tcnVsZS13aWR0aCcsXG4gICdjb2x1bW4tc3BhbicsXG4gICdjb2x1bW4td2lkdGgnLFxuICAnY29sdW1ucycsXG4gICdjb250ZW50JyxcbiAgJ2NvdW50ZXItaW5jcmVtZW50JyxcbiAgJ2NvdW50ZXItcmVzZXQnLFxuICAnY3Vyc29yJyxcbiAgJ2RpcmVjdGlvbicsXG4gICdkaXNwbGF5JyxcbiAgJ2VtcHR5LWNlbGxzJyxcbiAgJ2ZpbHRlcicsXG4gICdmbGV4JyxcbiAgJ2ZsZXgtYmFzaXMnLFxuICAnZmxleC1kaXJlY3Rpb24nLFxuICAnZmxleC1mbG93JyxcbiAgJ2ZsZXgtZ3JvdycsXG4gICdmbGV4LXNocmluaycsXG4gICdmbGV4LXdyYXAnLFxuICAnZmxvYXQnLFxuICAnZm9udCcsXG4gICdmb250LWRpc3BsYXknLFxuICAnZm9udC1mYW1pbHknLFxuICAnZm9udC1mZWF0dXJlLXNldHRpbmdzJyxcbiAgJ2ZvbnQta2VybmluZycsXG4gICdmb250LWxhbmd1YWdlLW92ZXJyaWRlJyxcbiAgJ2ZvbnQtc2l6ZScsXG4gICdmb250LXNpemUtYWRqdXN0JyxcbiAgJ2ZvbnQtc21vb3RoaW5nJyxcbiAgJ2ZvbnQtc3RyZXRjaCcsXG4gICdmb250LXN0eWxlJyxcbiAgJ2ZvbnQtdmFyaWFudCcsXG4gICdmb250LXZhcmlhbnQtbGlnYXR1cmVzJyxcbiAgJ2ZvbnQtdmFyaWF0aW9uLXNldHRpbmdzJyxcbiAgJ2ZvbnQtd2VpZ2h0JyxcbiAgJ2hlaWdodCcsXG4gICdoeXBoZW5zJyxcbiAgJ2ljb24nLFxuICAnaW1hZ2Utb3JpZW50YXRpb24nLFxuICAnaW1hZ2UtcmVuZGVyaW5nJyxcbiAgJ2ltYWdlLXJlc29sdXRpb24nLFxuICAnaW1lLW1vZGUnLFxuICAnaW5oZXJpdCcsXG4gICdpbml0aWFsJyxcbiAgJ2p1c3RpZnktY29udGVudCcsXG4gICdsZWZ0JyxcbiAgJ2xldHRlci1zcGFjaW5nJyxcbiAgJ2xpbmUtaGVpZ2h0JyxcbiAgJ2xpc3Qtc3R5bGUnLFxuICAnbGlzdC1zdHlsZS1pbWFnZScsXG4gICdsaXN0LXN0eWxlLXBvc2l0aW9uJyxcbiAgJ2xpc3Qtc3R5bGUtdHlwZScsXG4gICdtYXJnaW4nLFxuICAnbWFyZ2luLWJvdHRvbScsXG4gICdtYXJnaW4tbGVmdCcsXG4gICdtYXJnaW4tcmlnaHQnLFxuICAnbWFyZ2luLXRvcCcsXG4gICdtYXJrcycsXG4gICdtYXNrJyxcbiAgJ21heC1oZWlnaHQnLFxuICAnbWF4LXdpZHRoJyxcbiAgJ21pbi1oZWlnaHQnLFxuICAnbWluLXdpZHRoJyxcbiAgJ25hdi1kb3duJyxcbiAgJ25hdi1pbmRleCcsXG4gICduYXYtbGVmdCcsXG4gICduYXYtcmlnaHQnLFxuICAnbmF2LXVwJyxcbiAgJ25vbmUnLFxuICAnbm9ybWFsJyxcbiAgJ29iamVjdC1maXQnLFxuICAnb2JqZWN0LXBvc2l0aW9uJyxcbiAgJ29wYWNpdHknLFxuICAnb3JkZXInLFxuICAnb3JwaGFucycsXG4gICdvdXRsaW5lJyxcbiAgJ291dGxpbmUtY29sb3InLFxuICAnb3V0bGluZS1vZmZzZXQnLFxuICAnb3V0bGluZS1zdHlsZScsXG4gICdvdXRsaW5lLXdpZHRoJyxcbiAgJ292ZXJmbG93JyxcbiAgJ292ZXJmbG93LXdyYXAnLFxuICAnb3ZlcmZsb3cteCcsXG4gICdvdmVyZmxvdy15JyxcbiAgJ3BhZGRpbmcnLFxuICAncGFkZGluZy1ib3R0b20nLFxuICAncGFkZGluZy1sZWZ0JyxcbiAgJ3BhZGRpbmctcmlnaHQnLFxuICAncGFkZGluZy10b3AnLFxuICAncGFnZS1icmVhay1hZnRlcicsXG4gICdwYWdlLWJyZWFrLWJlZm9yZScsXG4gICdwYWdlLWJyZWFrLWluc2lkZScsXG4gICdwZXJzcGVjdGl2ZScsXG4gICdwZXJzcGVjdGl2ZS1vcmlnaW4nLFxuICAncG9pbnRlci1ldmVudHMnLFxuICAncG9zaXRpb24nLFxuICAncXVvdGVzJyxcbiAgJ3Jlc2l6ZScsXG4gICdyaWdodCcsXG4gICdzcmMnLCAvLyBAZm9udC1mYWNlXG4gICd0YWItc2l6ZScsXG4gICd0YWJsZS1sYXlvdXQnLFxuICAndGV4dC1hbGlnbicsXG4gICd0ZXh0LWFsaWduLWxhc3QnLFxuICAndGV4dC1kZWNvcmF0aW9uJyxcbiAgJ3RleHQtZGVjb3JhdGlvbi1jb2xvcicsXG4gICd0ZXh0LWRlY29yYXRpb24tbGluZScsXG4gICd0ZXh0LWRlY29yYXRpb24tc3R5bGUnLFxuICAndGV4dC1pbmRlbnQnLFxuICAndGV4dC1vdmVyZmxvdycsXG4gICd0ZXh0LXJlbmRlcmluZycsXG4gICd0ZXh0LXNoYWRvdycsXG4gICd0ZXh0LXRyYW5zZm9ybScsXG4gICd0ZXh0LXVuZGVybGluZS1wb3NpdGlvbicsXG4gICd0b3AnLFxuICAndHJhbnNmb3JtJyxcbiAgJ3RyYW5zZm9ybS1vcmlnaW4nLFxuICAndHJhbnNmb3JtLXN0eWxlJyxcbiAgJ3RyYW5zaXRpb24nLFxuICAndHJhbnNpdGlvbi1kZWxheScsXG4gICd0cmFuc2l0aW9uLWR1cmF0aW9uJyxcbiAgJ3RyYW5zaXRpb24tcHJvcGVydHknLFxuICAndHJhbnNpdGlvbi10aW1pbmctZnVuY3Rpb24nLFxuICAndW5pY29kZS1iaWRpJyxcbiAgJ3ZlcnRpY2FsLWFsaWduJyxcbiAgJ3Zpc2liaWxpdHknLFxuICAnd2hpdGUtc3BhY2UnLFxuICAnd2lkb3dzJyxcbiAgJ3dpZHRoJyxcbiAgJ3dvcmQtYnJlYWsnLFxuICAnd29yZC1zcGFjaW5nJyxcbiAgJ3dvcmQtd3JhcCcsXG4gICd6LWluZGV4J1xuICAvLyByZXZlcnNlIG1ha2VzIHN1cmUgbG9uZ2VyIGF0dHJpYnV0ZXMgYGZvbnQtd2VpZ2h0YCBhcmUgbWF0Y2hlZCBmdWxseVxuICAvLyBpbnN0ZWFkIG9mIGdldHRpbmcgZmFsc2UgcG9zaXRpdmVzIG9uIHNheSBgZm9udGBcbl0ucmV2ZXJzZSgpO1xuXG4vKlxuTGFuZ3VhZ2U6IFNDU1NcbkRlc2NyaXB0aW9uOiBTY3NzIGlzIGFuIGV4dGVuc2lvbiBvZiB0aGUgc3ludGF4IG9mIENTUy5cbkF1dGhvcjogS3VydCBFbWNoIDxrdXJ0QGt1cnRlbWNoLmNvbT5cbldlYnNpdGU6IGh0dHBzOi8vc2Fzcy1sYW5nLmNvbVxuQ2F0ZWdvcnk6IGNvbW1vbiwgY3NzLCB3ZWJcbiovXG5cbi8qKiBAdHlwZSBMYW5ndWFnZUZuICovXG5mdW5jdGlvbiBzY3NzKGhsanMpIHtcbiAgY29uc3QgbW9kZXMgPSBNT0RFUyhobGpzKTtcbiAgY29uc3QgUFNFVURPX0VMRU1FTlRTJDEgPSBQU0VVRE9fRUxFTUVOVFM7XG4gIGNvbnN0IFBTRVVET19DTEFTU0VTJDEgPSBQU0VVRE9fQ0xBU1NFUztcblxuICBjb25zdCBBVF9JREVOVElGSUVSID0gJ0BbYS16LV0rJzsgLy8gQGZvbnQtZmFjZVxuICBjb25zdCBBVF9NT0RJRklFUlMgPSBcImFuZCBvciBub3Qgb25seVwiO1xuICBjb25zdCBJREVOVF9SRSA9ICdbYS16QS1aLV1bYS16QS1aMC05Xy1dKic7XG4gIGNvbnN0IFZBUklBQkxFID0ge1xuICAgIGNsYXNzTmFtZTogJ3ZhcmlhYmxlJyxcbiAgICBiZWdpbjogJyhcXFxcJCcgKyBJREVOVF9SRSArICcpXFxcXGInXG4gIH07XG5cbiAgcmV0dXJuIHtcbiAgICBuYW1lOiAnU0NTUycsXG4gICAgY2FzZV9pbnNlbnNpdGl2ZTogdHJ1ZSxcbiAgICBpbGxlZ2FsOiAnWz0vfFxcJ10nLFxuICAgIGNvbnRhaW5zOiBbXG4gICAgICBobGpzLkNfTElORV9DT01NRU5UX01PREUsXG4gICAgICBobGpzLkNfQkxPQ0tfQ09NTUVOVF9NT0RFLFxuICAgICAge1xuICAgICAgICBjbGFzc05hbWU6ICdzZWxlY3Rvci1pZCcsXG4gICAgICAgIGJlZ2luOiAnI1tBLVphLXowLTlfLV0rJyxcbiAgICAgICAgcmVsZXZhbmNlOiAwXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBjbGFzc05hbWU6ICdzZWxlY3Rvci1jbGFzcycsXG4gICAgICAgIGJlZ2luOiAnXFxcXC5bQS1aYS16MC05Xy1dKycsXG4gICAgICAgIHJlbGV2YW5jZTogMFxuICAgICAgfSxcbiAgICAgIG1vZGVzLkFUVFJJQlVURV9TRUxFQ1RPUl9NT0RFLFxuICAgICAge1xuICAgICAgICBjbGFzc05hbWU6ICdzZWxlY3Rvci10YWcnLFxuICAgICAgICBiZWdpbjogJ1xcXFxiKCcgKyBUQUdTLmpvaW4oJ3wnKSArICcpXFxcXGInLFxuICAgICAgICAvLyB3YXMgdGhlcmUsIGJlZm9yZSwgYnV0IHdoeT9cbiAgICAgICAgcmVsZXZhbmNlOiAwXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBjbGFzc05hbWU6ICdzZWxlY3Rvci1wc2V1ZG8nLFxuICAgICAgICBiZWdpbjogJzooJyArIFBTRVVET19DTEFTU0VTJDEuam9pbignfCcpICsgJyknXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBjbGFzc05hbWU6ICdzZWxlY3Rvci1wc2V1ZG8nLFxuICAgICAgICBiZWdpbjogJzo6KCcgKyBQU0VVRE9fRUxFTUVOVFMkMS5qb2luKCd8JykgKyAnKSdcbiAgICAgIH0sXG4gICAgICBWQVJJQUJMRSxcbiAgICAgIHsgLy8gcHNldWRvLXNlbGVjdG9yIHBhcmFtc1xuICAgICAgICBiZWdpbjogL1xcKC8sXG4gICAgICAgIGVuZDogL1xcKS8sXG4gICAgICAgIGNvbnRhaW5zOiBbIG1vZGVzLkNTU19OVU1CRVJfTU9ERSBdXG4gICAgICB9LFxuICAgICAgbW9kZXMuQ1NTX1ZBUklBQkxFLFxuICAgICAge1xuICAgICAgICBjbGFzc05hbWU6ICdhdHRyaWJ1dGUnLFxuICAgICAgICBiZWdpbjogJ1xcXFxiKCcgKyBBVFRSSUJVVEVTLmpvaW4oJ3wnKSArICcpXFxcXGInXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBiZWdpbjogJ1xcXFxiKHdoaXRlc3BhY2V8d2FpdHx3LXJlc2l6ZXx2aXNpYmxlfHZlcnRpY2FsLXRleHR8dmVydGljYWwtaWRlb2dyYXBoaWN8dXBwZXJjYXNlfHVwcGVyLXJvbWFufHVwcGVyLWFscGhhfHVuZGVybGluZXx0cmFuc3BhcmVudHx0b3B8dGhpbnx0aGlja3x0ZXh0fHRleHQtdG9wfHRleHQtYm90dG9tfHRiLXJsfHRhYmxlLWhlYWRlci1ncm91cHx0YWJsZS1mb290ZXItZ3JvdXB8c3ctcmVzaXplfHN1cGVyfHN0cmljdHxzdGF0aWN8c3F1YXJlfHNvbGlkfHNtYWxsLWNhcHN8c2VwYXJhdGV8c2UtcmVzaXplfHNjcm9sbHxzLXJlc2l6ZXxydGx8cm93LXJlc2l6ZXxyaWRnZXxyaWdodHxyZXBlYXR8cmVwZWF0LXl8cmVwZWF0LXh8cmVsYXRpdmV8cHJvZ3Jlc3N8cG9pbnRlcnxvdmVybGluZXxvdXRzaWRlfG91dHNldHxvYmxpcXVlfG5vd3JhcHxub3QtYWxsb3dlZHxub3JtYWx8bm9uZXxudy1yZXNpemV8bm8tcmVwZWF0fG5vLWRyb3B8bmV3c3BhcGVyfG5lLXJlc2l6ZXxuLXJlc2l6ZXxtb3ZlfG1pZGRsZXxtZWRpdW18bHRyfGxyLXRifGxvd2VyY2FzZXxsb3dlci1yb21hbnxsb3dlci1hbHBoYXxsb29zZXxsaXN0LWl0ZW18bGluZXxsaW5lLXRocm91Z2h8bGluZS1lZGdlfGxpZ2h0ZXJ8bGVmdHxrZWVwLWFsbHxqdXN0aWZ5fGl0YWxpY3xpbnRlci13b3JkfGludGVyLWlkZW9ncmFwaHxpbnNpZGV8aW5zZXR8aW5saW5lfGlubGluZS1ibG9ja3xpbmhlcml0fGluYWN0aXZlfGlkZW9ncmFwaC1zcGFjZXxpZGVvZ3JhcGgtcGFyZW50aGVzaXN8aWRlb2dyYXBoLW51bWVyaWN8aWRlb2dyYXBoLWFscGhhfGhvcml6b250YWx8aGlkZGVufGhlbHB8aGFuZHxncm9vdmV8Zml4ZWR8ZWxsaXBzaXN8ZS1yZXNpemV8ZG91YmxlfGRvdHRlZHxkaXN0cmlidXRlfGRpc3RyaWJ1dGUtc3BhY2V8ZGlzdHJpYnV0ZS1sZXR0ZXJ8ZGlzdHJpYnV0ZS1hbGwtbGluZXN8ZGlzY3xkaXNhYmxlZHxkZWZhdWx0fGRlY2ltYWx8ZGFzaGVkfGNyb3NzaGFpcnxjb2xsYXBzZXxjb2wtcmVzaXplfGNpcmNsZXxjaGFyfGNlbnRlcnxjYXBpdGFsaXplfGJyZWFrLXdvcmR8YnJlYWstYWxsfGJvdHRvbXxib3RofGJvbGRlcnxib2xkfGJsb2NrfGJpZGktb3ZlcnJpZGV8YmVsb3d8YmFzZWxpbmV8YXV0b3xhbHdheXN8YWxsLXNjcm9sbHxhYnNvbHV0ZXx0YWJsZXx0YWJsZS1jZWxsKVxcXFxiJ1xuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgYmVnaW46ICc6JyxcbiAgICAgICAgZW5kOiAnOycsXG4gICAgICAgIGNvbnRhaW5zOiBbXG4gICAgICAgICAgVkFSSUFCTEUsXG4gICAgICAgICAgbW9kZXMuSEVYQ09MT1IsXG4gICAgICAgICAgbW9kZXMuQ1NTX05VTUJFUl9NT0RFLFxuICAgICAgICAgIGhsanMuUVVPVEVfU1RSSU5HX01PREUsXG4gICAgICAgICAgaGxqcy5BUE9TX1NUUklOR19NT0RFLFxuICAgICAgICAgIG1vZGVzLklNUE9SVEFOVFxuICAgICAgICBdXG4gICAgICB9LFxuICAgICAgLy8gbWF0Y2hpbmcgdGhlc2UgaGVyZSBhbGxvd3MgdXMgdG8gdHJlYXQgdGhlbSBtb3JlIGxpa2UgcmVndWxhciBDU1NcbiAgICAgIC8vIHJ1bGVzIHNvIGV2ZXJ5dGhpbmcgYmV0d2VlbiB0aGUge30gZ2V0cyByZWd1bGFyIHJ1bGUgaGlnaGxpZ2h0aW5nLFxuICAgICAgLy8gd2hpY2ggaXMgd2hhdCB3ZSB3YW50IGZvciBwYWdlIGFuZCBmb250LWZhY2VcbiAgICAgIHtcbiAgICAgICAgYmVnaW46ICdAKHBhZ2V8Zm9udC1mYWNlKScsXG4gICAgICAgIGtleXdvcmRzOiB7XG4gICAgICAgICAgJHBhdHRlcm46IEFUX0lERU5USUZJRVIsXG4gICAgICAgICAga2V5d29yZDogJ0BwYWdlIEBmb250LWZhY2UnXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGJlZ2luOiAnQCcsXG4gICAgICAgIGVuZDogJ1t7O10nLFxuICAgICAgICByZXR1cm5CZWdpbjogdHJ1ZSxcbiAgICAgICAga2V5d29yZHM6IHtcbiAgICAgICAgICAkcGF0dGVybjogL1thLXotXSsvLFxuICAgICAgICAgIGtleXdvcmQ6IEFUX01PRElGSUVSUyxcbiAgICAgICAgICBhdHRyaWJ1dGU6IE1FRElBX0ZFQVRVUkVTLmpvaW4oXCIgXCIpXG4gICAgICAgIH0sXG4gICAgICAgIGNvbnRhaW5zOiBbXG4gICAgICAgICAge1xuICAgICAgICAgICAgYmVnaW46IEFUX0lERU5USUZJRVIsXG4gICAgICAgICAgICBjbGFzc05hbWU6IFwia2V5d29yZFwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBiZWdpbjogL1thLXotXSsoPz06KS8sXG4gICAgICAgICAgICBjbGFzc05hbWU6IFwiYXR0cmlidXRlXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFZBUklBQkxFLFxuICAgICAgICAgIGhsanMuUVVPVEVfU1RSSU5HX01PREUsXG4gICAgICAgICAgaGxqcy5BUE9TX1NUUklOR19NT0RFLFxuICAgICAgICAgIG1vZGVzLkhFWENPTE9SLFxuICAgICAgICAgIG1vZGVzLkNTU19OVU1CRVJfTU9ERVxuICAgICAgICBdXG4gICAgICB9XG4gICAgXVxuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBzY3NzO1xuIiwiLypcbkxhbmd1YWdlOiBTaGVsbCBTZXNzaW9uXG5SZXF1aXJlczogYmFzaC5qc1xuQXV0aG9yOiBUU1VZVVNBVE8gS2l0c3VuZSA8bWFrZS5qdXN0Lm9uQGdtYWlsLmNvbT5cbkNhdGVnb3J5OiBjb21tb25cbkF1ZGl0OiAyMDIwXG4qL1xuXG4vKiogQHR5cGUgTGFuZ3VhZ2VGbiAqL1xuZnVuY3Rpb24gc2hlbGwoaGxqcykge1xuICByZXR1cm4ge1xuICAgIG5hbWU6ICdTaGVsbCBTZXNzaW9uJyxcbiAgICBhbGlhc2VzOiBbICdjb25zb2xlJywgJ3NoZWxsc2Vzc2lvbicgXSxcbiAgICBjb250YWluczogW1xuICAgICAge1xuICAgICAgICBjbGFzc05hbWU6ICdtZXRhJyxcbiAgICAgICAgLy8gV2UgY2Fubm90IGFkZCBcXHMgKHNwYWNlcykgaW4gdGhlIHJlZ3VsYXIgZXhwcmVzc2lvbiBvdGhlcndpc2UgaXQgd2lsbCBiZSB0b28gYnJvYWQgYW5kIHByb2R1Y2UgdW5leHBlY3RlZCByZXN1bHQuXG4gICAgICAgIC8vIEZvciBpbnN0YW5jZSwgaW4gdGhlIGZvbGxvd2luZyBleGFtcGxlLCBpdCB3b3VsZCBtYXRjaCBcImVjaG8gL3BhdGgvdG8vaG9tZSA+XCIgYXMgYSBwcm9tcHQ6XG4gICAgICAgIC8vIGVjaG8gL3BhdGgvdG8vaG9tZSA+IHQuZXhlXG4gICAgICAgIGJlZ2luOiAvXlxcc3swLDN9Wy9+XFx3XFxkW1xcXSgpQC1dKls+JSQjXVsgXT8vLFxuICAgICAgICBzdGFydHM6IHtcbiAgICAgICAgICBlbmQ6IC9bXlxcXFxdKD89XFxzKiQpLyxcbiAgICAgICAgICBzdWJMYW5ndWFnZTogJ2Jhc2gnXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICBdXG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IHNoZWxsO1xuIiwiLypcbkxhbmd1YWdlOiBQbGFpbiB0ZXh0XG5BdXRob3I6IEVnb3IgUm9nb3YgKGUucm9nb3ZAcG9zdGdyZXNwcm8ucnUpXG5EZXNjcmlwdGlvbjogUGxhaW4gdGV4dCB3aXRob3V0IGFueSBoaWdobGlnaHRpbmcuXG5DYXRlZ29yeTogY29tbW9uXG4qL1xuXG5mdW5jdGlvbiBwbGFpbnRleHQoaGxqcykge1xuICByZXR1cm4ge1xuICAgIG5hbWU6ICdQbGFpbiB0ZXh0JyxcbiAgICBhbGlhc2VzOiBbXG4gICAgICAndGV4dCcsXG4gICAgICAndHh0J1xuICAgIF0sXG4gICAgZGlzYWJsZUF1dG9kZXRlY3Q6IHRydWVcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgcGxhaW50ZXh0O1xuIiwiLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVcbiAqIEByZXR1cm5zIHtSZWdFeHB9XG4gKiAqL1xuXG4vKipcbiAqIEBwYXJhbSB7UmVnRXhwIHwgc3RyaW5nIH0gcmVcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIHNvdXJjZShyZSkge1xuICBpZiAoIXJlKSByZXR1cm4gbnVsbDtcbiAgaWYgKHR5cGVvZiByZSA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIHJlO1xuXG4gIHJldHVybiByZS5zb3VyY2U7XG59XG5cbi8qKlxuICogQHBhcmFtIHtSZWdFeHAgfCBzdHJpbmcgfSByZVxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gbG9va2FoZWFkKHJlKSB7XG4gIHJldHVybiBjb25jYXQoJyg/PScsIHJlLCAnKScpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7UmVnRXhwIHwgc3RyaW5nIH0gcmVcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIG9wdGlvbmFsKHJlKSB7XG4gIHJldHVybiBjb25jYXQoJyg/OicsIHJlLCAnKT8nKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0gey4uLihSZWdFeHAgfCBzdHJpbmcpIH0gYXJnc1xuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gY29uY2F0KC4uLmFyZ3MpIHtcbiAgY29uc3Qgam9pbmVkID0gYXJncy5tYXAoKHgpID0+IHNvdXJjZSh4KSkuam9pbihcIlwiKTtcbiAgcmV0dXJuIGpvaW5lZDtcbn1cblxuZnVuY3Rpb24gc3RyaXBPcHRpb25zRnJvbUFyZ3MoYXJncykge1xuICBjb25zdCBvcHRzID0gYXJnc1thcmdzLmxlbmd0aCAtIDFdO1xuXG4gIGlmICh0eXBlb2Ygb3B0cyA9PT0gJ29iamVjdCcgJiYgb3B0cy5jb25zdHJ1Y3RvciA9PT0gT2JqZWN0KSB7XG4gICAgYXJncy5zcGxpY2UoYXJncy5sZW5ndGggLSAxLCAxKTtcbiAgICByZXR1cm4gb3B0cztcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4ge307XG4gIH1cbn1cblxuLyoqXG4gKiBBbnkgb2YgdGhlIHBhc3NlZCBleHByZXNzc2lvbnMgbWF5IG1hdGNoXG4gKlxuICogQ3JlYXRlcyBhIGh1Z2UgdGhpcyB8IHRoaXMgfCB0aGF0IHwgdGhhdCBtYXRjaFxuICogQHBhcmFtIHsoUmVnRXhwIHwgc3RyaW5nKVtdIH0gYXJnc1xuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gZWl0aGVyKC4uLmFyZ3MpIHtcbiAgY29uc3Qgb3B0cyA9IHN0cmlwT3B0aW9uc0Zyb21BcmdzKGFyZ3MpO1xuICBjb25zdCBqb2luZWQgPSAnKCcgK1xuICAgIChvcHRzLmNhcHR1cmUgPyBcIlwiIDogXCI/OlwiKSArXG4gICAgYXJncy5tYXAoKHgpID0+IHNvdXJjZSh4KSkuam9pbihcInxcIikgKyBcIilcIjtcbiAgcmV0dXJuIGpvaW5lZDtcbn1cblxuLypcbkxhbmd1YWdlOiBIVE1MLCBYTUxcbldlYnNpdGU6IGh0dHBzOi8vd3d3LnczLm9yZy9YTUwvXG5DYXRlZ29yeTogY29tbW9uLCB3ZWJcbkF1ZGl0OiAyMDIwXG4qL1xuXG4vKiogQHR5cGUgTGFuZ3VhZ2VGbiAqL1xuZnVuY3Rpb24geG1sKGhsanMpIHtcbiAgLy8gRWxlbWVudCBuYW1lcyBjYW4gY29udGFpbiBsZXR0ZXJzLCBkaWdpdHMsIGh5cGhlbnMsIHVuZGVyc2NvcmVzLCBhbmQgcGVyaW9kc1xuICBjb25zdCBUQUdfTkFNRV9SRSA9IGNvbmNhdCgvW0EtWl9dLywgb3B0aW9uYWwoL1tBLVowLTlfLi1dKjovKSwgL1tBLVowLTlfLi1dKi8pO1xuICBjb25zdCBYTUxfSURFTlRfUkUgPSAvW0EtWmEtejAtOS5fOi1dKy87XG4gIGNvbnN0IFhNTF9FTlRJVElFUyA9IHtcbiAgICBjbGFzc05hbWU6ICdzeW1ib2wnLFxuICAgIGJlZ2luOiAvJlthLXpdKzt8JiNbMC05XSs7fCYjeFthLWYwLTldKzsvXG4gIH07XG4gIGNvbnN0IFhNTF9NRVRBX0tFWVdPUkRTID0ge1xuICAgIGJlZ2luOiAvXFxzLyxcbiAgICBjb250YWluczogW1xuICAgICAge1xuICAgICAgICBjbGFzc05hbWU6ICdrZXl3b3JkJyxcbiAgICAgICAgYmVnaW46IC8jP1thLXpfXVthLXoxLTlfLV0rLyxcbiAgICAgICAgaWxsZWdhbDogL1xcbi9cbiAgICAgIH1cbiAgICBdXG4gIH07XG4gIGNvbnN0IFhNTF9NRVRBX1BBUl9LRVlXT1JEUyA9IGhsanMuaW5oZXJpdChYTUxfTUVUQV9LRVlXT1JEUywge1xuICAgIGJlZ2luOiAvXFwoLyxcbiAgICBlbmQ6IC9cXCkvXG4gIH0pO1xuICBjb25zdCBBUE9TX01FVEFfU1RSSU5HX01PREUgPSBobGpzLmluaGVyaXQoaGxqcy5BUE9TX1NUUklOR19NT0RFLCB7XG4gICAgY2xhc3NOYW1lOiAnc3RyaW5nJ1xuICB9KTtcbiAgY29uc3QgUVVPVEVfTUVUQV9TVFJJTkdfTU9ERSA9IGhsanMuaW5oZXJpdChobGpzLlFVT1RFX1NUUklOR19NT0RFLCB7XG4gICAgY2xhc3NOYW1lOiAnc3RyaW5nJ1xuICB9KTtcbiAgY29uc3QgVEFHX0lOVEVSTkFMUyA9IHtcbiAgICBlbmRzV2l0aFBhcmVudDogdHJ1ZSxcbiAgICBpbGxlZ2FsOiAvPC8sXG4gICAgcmVsZXZhbmNlOiAwLFxuICAgIGNvbnRhaW5zOiBbXG4gICAgICB7XG4gICAgICAgIGNsYXNzTmFtZTogJ2F0dHInLFxuICAgICAgICBiZWdpbjogWE1MX0lERU5UX1JFLFxuICAgICAgICByZWxldmFuY2U6IDBcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGJlZ2luOiAvPVxccyovLFxuICAgICAgICByZWxldmFuY2U6IDAsXG4gICAgICAgIGNvbnRhaW5zOiBbXG4gICAgICAgICAge1xuICAgICAgICAgICAgY2xhc3NOYW1lOiAnc3RyaW5nJyxcbiAgICAgICAgICAgIGVuZHNQYXJlbnQ6IHRydWUsXG4gICAgICAgICAgICB2YXJpYW50czogW1xuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgYmVnaW46IC9cIi8sXG4gICAgICAgICAgICAgICAgZW5kOiAvXCIvLFxuICAgICAgICAgICAgICAgIGNvbnRhaW5zOiBbIFhNTF9FTlRJVElFUyBdXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBiZWdpbjogLycvLFxuICAgICAgICAgICAgICAgIGVuZDogLycvLFxuICAgICAgICAgICAgICAgIGNvbnRhaW5zOiBbIFhNTF9FTlRJVElFUyBdXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBiZWdpbjogL1teXFxzXCInPTw+YF0rL1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBdXG4gICAgICAgICAgfVxuICAgICAgICBdXG4gICAgICB9XG4gICAgXVxuICB9O1xuICByZXR1cm4ge1xuICAgIG5hbWU6ICdIVE1MLCBYTUwnLFxuICAgIGFsaWFzZXM6IFtcbiAgICAgICdodG1sJyxcbiAgICAgICd4aHRtbCcsXG4gICAgICAncnNzJyxcbiAgICAgICdhdG9tJyxcbiAgICAgICd4amInLFxuICAgICAgJ3hzZCcsXG4gICAgICAneHNsJyxcbiAgICAgICdwbGlzdCcsXG4gICAgICAnd3NmJyxcbiAgICAgICdzdmcnXG4gICAgXSxcbiAgICBjYXNlX2luc2Vuc2l0aXZlOiB0cnVlLFxuICAgIGNvbnRhaW5zOiBbXG4gICAgICB7XG4gICAgICAgIGNsYXNzTmFtZTogJ21ldGEnLFxuICAgICAgICBiZWdpbjogLzwhW2Etel0vLFxuICAgICAgICBlbmQ6IC8+LyxcbiAgICAgICAgcmVsZXZhbmNlOiAxMCxcbiAgICAgICAgY29udGFpbnM6IFtcbiAgICAgICAgICBYTUxfTUVUQV9LRVlXT1JEUyxcbiAgICAgICAgICBRVU9URV9NRVRBX1NUUklOR19NT0RFLFxuICAgICAgICAgIEFQT1NfTUVUQV9TVFJJTkdfTU9ERSxcbiAgICAgICAgICBYTUxfTUVUQV9QQVJfS0VZV09SRFMsXG4gICAgICAgICAge1xuICAgICAgICAgICAgYmVnaW46IC9cXFsvLFxuICAgICAgICAgICAgZW5kOiAvXFxdLyxcbiAgICAgICAgICAgIGNvbnRhaW5zOiBbXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU6ICdtZXRhJyxcbiAgICAgICAgICAgICAgICBiZWdpbjogLzwhW2Etel0vLFxuICAgICAgICAgICAgICAgIGVuZDogLz4vLFxuICAgICAgICAgICAgICAgIGNvbnRhaW5zOiBbXG4gICAgICAgICAgICAgICAgICBYTUxfTUVUQV9LRVlXT1JEUyxcbiAgICAgICAgICAgICAgICAgIFhNTF9NRVRBX1BBUl9LRVlXT1JEUyxcbiAgICAgICAgICAgICAgICAgIFFVT1RFX01FVEFfU1RSSU5HX01PREUsXG4gICAgICAgICAgICAgICAgICBBUE9TX01FVEFfU1RSSU5HX01PREVcbiAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF1cbiAgICAgICAgICB9XG4gICAgICAgIF1cbiAgICAgIH0sXG4gICAgICBobGpzLkNPTU1FTlQoXG4gICAgICAgIC88IS0tLyxcbiAgICAgICAgLy0tPi8sXG4gICAgICAgIHtcbiAgICAgICAgICByZWxldmFuY2U6IDEwXG4gICAgICAgIH1cbiAgICAgICksXG4gICAgICB7XG4gICAgICAgIGJlZ2luOiAvPCFcXFtDREFUQVxcWy8sXG4gICAgICAgIGVuZDogL1xcXVxcXT4vLFxuICAgICAgICByZWxldmFuY2U6IDEwXG4gICAgICB9LFxuICAgICAgWE1MX0VOVElUSUVTLFxuICAgICAge1xuICAgICAgICBjbGFzc05hbWU6ICdtZXRhJyxcbiAgICAgICAgYmVnaW46IC88XFw/eG1sLyxcbiAgICAgICAgZW5kOiAvXFw/Pi8sXG4gICAgICAgIHJlbGV2YW5jZTogMTBcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGNsYXNzTmFtZTogJ3RhZycsXG4gICAgICAgIC8qXG4gICAgICAgIFRoZSBsb29rYWhlYWQgcGF0dGVybiAoPz0uLi4pIGVuc3VyZXMgdGhhdCAnYmVnaW4nIG9ubHkgbWF0Y2hlc1xuICAgICAgICAnPHN0eWxlJyBhcyBhIHNpbmdsZSB3b3JkLCBmb2xsb3dlZCBieSBhIHdoaXRlc3BhY2Ugb3IgYW5cbiAgICAgICAgZW5kaW5nIGJyYWNrZXQuXG4gICAgICAgICovXG4gICAgICAgIGJlZ2luOiAvPHN0eWxlKD89XFxzfD4pLyxcbiAgICAgICAgZW5kOiAvPi8sXG4gICAgICAgIGtleXdvcmRzOiB7XG4gICAgICAgICAgbmFtZTogJ3N0eWxlJ1xuICAgICAgICB9LFxuICAgICAgICBjb250YWluczogWyBUQUdfSU5URVJOQUxTIF0sXG4gICAgICAgIHN0YXJ0czoge1xuICAgICAgICAgIGVuZDogLzxcXC9zdHlsZT4vLFxuICAgICAgICAgIHJldHVybkVuZDogdHJ1ZSxcbiAgICAgICAgICBzdWJMYW5ndWFnZTogW1xuICAgICAgICAgICAgJ2NzcycsXG4gICAgICAgICAgICAneG1sJ1xuICAgICAgICAgIF1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgY2xhc3NOYW1lOiAndGFnJyxcbiAgICAgICAgLy8gU2VlIHRoZSBjb21tZW50IGluIHRoZSA8c3R5bGUgdGFnIGFib3V0IHRoZSBsb29rYWhlYWQgcGF0dGVyblxuICAgICAgICBiZWdpbjogLzxzY3JpcHQoPz1cXHN8PikvLFxuICAgICAgICBlbmQ6IC8+LyxcbiAgICAgICAga2V5d29yZHM6IHtcbiAgICAgICAgICBuYW1lOiAnc2NyaXB0J1xuICAgICAgICB9LFxuICAgICAgICBjb250YWluczogWyBUQUdfSU5URVJOQUxTIF0sXG4gICAgICAgIHN0YXJ0czoge1xuICAgICAgICAgIGVuZDogLzxcXC9zY3JpcHQ+LyxcbiAgICAgICAgICByZXR1cm5FbmQ6IHRydWUsXG4gICAgICAgICAgc3ViTGFuZ3VhZ2U6IFtcbiAgICAgICAgICAgICdqYXZhc2NyaXB0JyxcbiAgICAgICAgICAgICdoYW5kbGViYXJzJyxcbiAgICAgICAgICAgICd4bWwnXG4gICAgICAgICAgXVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgLy8gd2UgbmVlZCB0aGlzIGZvciBub3cgZm9yIGpTWFxuICAgICAge1xuICAgICAgICBjbGFzc05hbWU6ICd0YWcnLFxuICAgICAgICBiZWdpbjogLzw+fDxcXC8+L1xuICAgICAgfSxcbiAgICAgIC8vIG9wZW4gdGFnXG4gICAgICB7XG4gICAgICAgIGNsYXNzTmFtZTogJ3RhZycsXG4gICAgICAgIGJlZ2luOiBjb25jYXQoXG4gICAgICAgICAgLzwvLFxuICAgICAgICAgIGxvb2thaGVhZChjb25jYXQoXG4gICAgICAgICAgICBUQUdfTkFNRV9SRSxcbiAgICAgICAgICAgIC8vIDx0YWcvPlxuICAgICAgICAgICAgLy8gPHRhZz5cbiAgICAgICAgICAgIC8vIDx0YWcgLi4uXG4gICAgICAgICAgICBlaXRoZXIoL1xcLz4vLCAvPi8sIC9cXHMvKVxuICAgICAgICAgICkpXG4gICAgICAgICksXG4gICAgICAgIGVuZDogL1xcLz8+LyxcbiAgICAgICAgY29udGFpbnM6IFtcbiAgICAgICAgICB7XG4gICAgICAgICAgICBjbGFzc05hbWU6ICduYW1lJyxcbiAgICAgICAgICAgIGJlZ2luOiBUQUdfTkFNRV9SRSxcbiAgICAgICAgICAgIHJlbGV2YW5jZTogMCxcbiAgICAgICAgICAgIHN0YXJ0czogVEFHX0lOVEVSTkFMU1xuICAgICAgICAgIH1cbiAgICAgICAgXVxuICAgICAgfSxcbiAgICAgIC8vIGNsb3NlIHRhZ1xuICAgICAge1xuICAgICAgICBjbGFzc05hbWU6ICd0YWcnLFxuICAgICAgICBiZWdpbjogY29uY2F0KFxuICAgICAgICAgIC88XFwvLyxcbiAgICAgICAgICBsb29rYWhlYWQoY29uY2F0KFxuICAgICAgICAgICAgVEFHX05BTUVfUkUsIC8+L1xuICAgICAgICAgICkpXG4gICAgICAgICksXG4gICAgICAgIGNvbnRhaW5zOiBbXG4gICAgICAgICAge1xuICAgICAgICAgICAgY2xhc3NOYW1lOiAnbmFtZScsXG4gICAgICAgICAgICBiZWdpbjogVEFHX05BTUVfUkUsXG4gICAgICAgICAgICByZWxldmFuY2U6IDBcbiAgICAgICAgICB9LFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGJlZ2luOiAvPi8sXG4gICAgICAgICAgICByZWxldmFuY2U6IDAsXG4gICAgICAgICAgICBlbmRzUGFyZW50OiB0cnVlXG4gICAgICAgICAgfVxuICAgICAgICBdXG4gICAgICB9XG4gICAgXVxuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCB4bWw7XG4iLCJpbXBvcnQgaGxqcyBmcm9tICdoaWdobGlnaHQuanMvbGliL2NvcmUnO1xyXG5pbXBvcnQgamF2YXNjcmlwdCBmcm9tICdoaWdobGlnaHQuanMvbGliL2xhbmd1YWdlcy9qYXZhc2NyaXB0JztcclxuaW1wb3J0IHNjc3MgZnJvbSAnaGlnaGxpZ2h0LmpzL2xpYi9sYW5ndWFnZXMvc2Nzcyc7XHJcbmltcG9ydCBzaGVsbCBmcm9tICdoaWdobGlnaHQuanMvbGliL2xhbmd1YWdlcy9zaGVsbCc7XHJcbmltcG9ydCBwbGFpbnRleHQgZnJvbSAnaGlnaGxpZ2h0LmpzL2xpYi9sYW5ndWFnZXMvcGxhaW50ZXh0JztcclxuaW1wb3J0IHhtbCBmcm9tICdoaWdobGlnaHQuanMvbGliL2xhbmd1YWdlcy94bWwnO1xyXG5cclxuaGxqcy5yZWdpc3Rlckxhbmd1YWdlKCdqYXZhc2NyaXB0JywgamF2YXNjcmlwdCk7XHJcbmhsanMucmVnaXN0ZXJMYW5ndWFnZSgnc2NzcycsIHNjc3MpO1xyXG5obGpzLnJlZ2lzdGVyTGFuZ3VhZ2UoJ3NoZWxsJywgc2hlbGwpO1xyXG5obGpzLnJlZ2lzdGVyTGFuZ3VhZ2UoJ3BsYWludGV4dCcsIHBsYWludGV4dCk7XHJcbmhsanMucmVnaXN0ZXJMYW5ndWFnZSgneG1sJywgeG1sKTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGhpZ2hsaWdodChjb2RlLCBsYW5nKSB7XHJcbiAgICBjb25zdCBsYW5ndWFnZSA9IGhsanMuZ2V0TGFuZ3VhZ2UobGFuZykgPyBsYW5nIDogJ3BsYWludGV4dCc7XHJcbiAgICByZXR1cm4gaGxqcy5oaWdobGlnaHQoY29kZSwgeyBsYW5ndWFnZSB9KS52YWx1ZTtcclxufSIsImltcG9ydCB7IGpzeFRvSHRtbCB9IGZyb20gJ0AvdXRpbHMvY29kZSc7XHJcbmltcG9ydCBoaWdobGlnaHQgZnJvbSAnQC91dGlscy9oaWdobGlnaHQnO1xyXG5cclxuaW1wb3J0ICcuL2luZGV4LnNjc3MnO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gQ29kZSh7IGxhbmcsIGNoaWxkcmVuIH0pIHtcclxuICAgIGNvbnN0IGh0bWwgPSBqc3hUb0h0bWwoY2hpbGRyZW4pO1xyXG5cclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJjb2RlXCI+XHJcbiAgICAgICAgICAgIDxwcmUgY2xhc3NOYW1lPXtgaGxqcyBsYW5ndWFnZS0ke2xhbmd9YH0+XHJcbiAgICAgICAgICAgICAgICA8Y29kZVxyXG4gICAgICAgICAgICAgICAgICAgIGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MPXt7IF9faHRtbDogaGlnaGxpZ2h0KGh0bWwsICdqc3gnKSB9fVxyXG4gICAgICAgICAgICAgICAgLz5cclxuICAgICAgICAgICAgPC9wcmU+XHJcbiAgICAgICAgPC9kaXY+XHJcbiAgICApO1xyXG59IiwiaW1wb3J0IHsgdXNlU3RhdGUgfSBmcm9tICdyZWFjdCc7XHJcbmltcG9ydCB7XHJcbiAgICBDYXJkLFxyXG4gICAgSWNvbkJ1dHRvbixcclxuICAgIFNpZGVTaGVldCxcclxuICAgIFR5cG9ncmFwaHlcclxufSBmcm9tICdtZGMtcmVhY3QnO1xyXG5pbXBvcnQgY2xhc3NuYW1lcyBmcm9tICdjbGFzc25hbWVzJztcclxuXHJcbmltcG9ydCBDb2RlIGZyb20gJ0AvY29tcG9uZW50cy9Db2RlJztcclxuXHJcbmltcG9ydCAnLi9pbmRleC5zY3NzJztcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIERlbW8oe1xyXG4gICAgdGl0bGUgPSAnRGVtbycsXHJcbiAgICBkZXNjcmlwdGlvbixcclxuICAgIHNldHVwLFxyXG4gICAgc2V0dGluZ3MsXHJcbiAgICBjb2RlLFxyXG4gICAgY2hpbGRyZW4gPSBjb2RlXHJcbn0pIHtcclxuICAgIGNvbnN0IFtpc0NvZGVPcGVuLCBzZXRDb2RlT3Blbl0gPSB1c2VTdGF0ZSh0cnVlKTtcclxuICAgIGNvbnN0IFtpc1NldHRpbmdzT3Blbiwgc2V0U2V0dGluZ3NPcGVuXSA9IHVzZVN0YXRlKGZhbHNlKTtcclxuXHJcbiAgICBjb25zdCBjbGFzc05hbWVzID0gY2xhc3NuYW1lcygnZGVtbycsIHtcclxuICAgICAgICAnZGVtby0td2l0aC1zZXR0aW5ncyc6IHNldHRpbmdzXHJcbiAgICB9KTtcclxuXHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAgIDxDYXJkIGVsZW1lbnQ9XCJhcnRpY2xlXCIgY2xhc3NOYW1lPXtjbGFzc05hbWVzfSBvdXRsaW5lZD5cclxuICAgICAgICAgICAgPENhcmQuSGVhZGVyXHJcbiAgICAgICAgICAgICAgICB0aXRsZT17dGl0bGV9XHJcbiAgICAgICAgICAgICAgICBhY3Rpb25zPXtbXHJcbiAgICAgICAgICAgICAgICAgICAgPEljb25CdXR0b25cclxuICAgICAgICAgICAgICAgICAgICAgICAga2V5PVwiY29kZVwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGljb249e2lzQ29kZU9wZW4gPyAnY29kZV9vZmYnIDogJ2NvZGUnfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aXRsZT17aXNDb2RlT3BlbiA/ICdIaWRlIGNvZGUnIDogJ1Nob3cgY29kZSd9IG9uQ2xpY2s9eygpID0+IHNldENvZGVPcGVuKHYgPT4gIXYpfVxyXG4gICAgICAgICAgICAgICAgICAgIC8+LFxyXG4gICAgICAgICAgICAgICAgICAgIHNldHRpbmdzID9cclxuICAgICAgICAgICAgICAgICAgICAgICAgPEljb25CdXR0b25cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleT1cInNldHRpbmdzXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGljb249XCJzZXR0aW5nc1wiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aXRsZT1cItCd0LDRgdGC0YDQvtC50LrQuFwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbkNsaWNrPXsoKSA9PiBzZXRTZXR0aW5nc09wZW4odHJ1ZSl9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8+IDogbnVsbFxyXG4gICAgICAgICAgICAgICAgXX1cclxuICAgICAgICAgICAgLz5cclxuXHJcbiAgICAgICAgICAgIHtkZXNjcmlwdGlvbiAmJlxyXG4gICAgICAgICAgICAgICAgPENhcmQuU2VjdGlvbiBzZWNvbmRhcnk+XHJcbiAgICAgICAgICAgICAgICAgICAgPFR5cG9ncmFwaHkgbm9NYXJnaW4+e2Rlc2NyaXB0aW9ufTwvVHlwb2dyYXBoeT5cclxuICAgICAgICAgICAgICAgIDwvQ2FyZC5TZWN0aW9uPlxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICA8Q2FyZC5TZWN0aW9uIHByaW1hcnk+XHJcbiAgICAgICAgICAgICAgICB7c2V0dXB9XHJcbiAgICAgICAgICAgICAgICB7Y2hpbGRyZW59XHJcbiAgICAgICAgICAgIDwvQ2FyZC5TZWN0aW9uPlxyXG5cclxuICAgICAgICAgICAge2lzQ29kZU9wZW4gJiZcclxuICAgICAgICAgICAgICAgIDxDYXJkLlNlY3Rpb24gc2Vjb25kYXJ5PlxyXG4gICAgICAgICAgICAgICAgICAgIDxDb2RlIGxhbmc9XCJqc3hcIj57Y2hpbGRyZW59PC9Db2RlPlxyXG4gICAgICAgICAgICAgICAgPC9DYXJkLlNlY3Rpb24+XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHtzZXR0aW5ncyAmJlxyXG4gICAgICAgICAgICAgICAgPFNpZGVTaGVldFxyXG4gICAgICAgICAgICAgICAgICAgIHRpdGxlPVwiU2V0dGluZ3NcIlxyXG4gICAgICAgICAgICAgICAgICAgIG9wZW49e2lzU2V0dGluZ3NPcGVufVxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGFwcGVhclxyXG4gICAgICAgICAgICAgICAgICAgIGNsb3NlSWNvbj1cImNsb3NlXCJcclxuICAgICAgICAgICAgICAgICAgICBvbkNsb3NlPXsoKSA9PiBzZXRTZXR0aW5nc09wZW4oZmFsc2UpfVxyXG4gICAgICAgICAgICAgICAgICAgIGRpc21pc3NpYmxlXHJcbiAgICAgICAgICAgICAgICA+XHJcbiAgICAgICAgICAgICAgICAgICAgPFNpZGVTaGVldC5Db250ZW50PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB7c2V0dGluZ3N9XHJcbiAgICAgICAgICAgICAgICAgICAgPC9TaWRlU2hlZXQuQ29udGVudD5cclxuICAgICAgICAgICAgICAgIDwvU2lkZVNoZWV0PlxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgPC9DYXJkPlxyXG4gICAgKTtcclxufSIsImltcG9ydCAnLi9pbmRleC5zY3NzJztcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIEZpZWxkU2V0KHsgbGVnZW5kLCBjaGlsZHJlbiB9KSB7XHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAgIDxmaWVsZHNldD5cclxuICAgICAgICAgICAgPGxlZ2VuZD57bGVnZW5kfTwvbGVnZW5kPlxyXG5cclxuICAgICAgICAgICAge2NoaWxkcmVufVxyXG4gICAgICAgIDwvZmllbGRzZXQ+XHJcbiAgICApO1xyXG59IiwiaW1wb3J0IHsgTGlzdCwgVHlwb2dyYXBoeSB9IGZyb20gJ21kYy1yZWFjdCc7XHJcblxyXG5pbXBvcnQgJy4vaW5kZXguc2Nzcyc7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBQYWdlKHtcclxuICAgIGlkLFxyXG4gICAgdGl0bGUsXHJcbiAgICBkZXNjcmlwdGlvbixcclxuICAgIGxpbmtzLFxyXG5cclxuICAgIGNoaWxkcmVuLFxyXG4gICAgLi4ucHJvcHNcclxufSkge1xyXG4gICAgcmV0dXJuIChcclxuICAgICAgICA8YXJ0aWNsZSBpZD17YCR7aWR9LXBhZ2VgfSBjbGFzc05hbWU9XCJwYWdlXCIgey4uLnByb3BzfT5cclxuICAgICAgICAgICAge3RpdGxlICYmXHJcbiAgICAgICAgICAgICAgICA8aGVhZGVyIGNsYXNzTmFtZT1cInBhZ2UtaGVhZGVyXCI+XHJcbiAgICAgICAgICAgICAgICAgICAgPFR5cG9ncmFwaHkgY2xhc3NOYW1lPVwicGFnZS10aXRsZVwiIHR5cGU9XCJoZWFkbGluZTRcIiBub01hcmdpbj57dGl0bGV9PC9UeXBvZ3JhcGh5PlxyXG5cclxuICAgICAgICAgICAgICAgICAgICB7ZGVzY3JpcHRpb24gJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgPFR5cG9ncmFwaHkgY2xhc3NOYW1lPVwicGFnZS1kZXNjcmlwdGlvblwiIHR5cGU9XCJib2R5MVwiIG5vTWFyZ2luPntkZXNjcmlwdGlvbn08L1R5cG9ncmFwaHk+XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICB7bGlua3MgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgPExpc3Q+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7bGlua3MuZ3VpZGUgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8TGlzdC5JdGVtPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8YSBocmVmPXtsaW5rcy5ndWlkZX0gdGFyZ2V0PVwiX2JsYW5rXCIgcmVsPVwibm9yZWZlcnJlclwiPkd1aWRlPC9hPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvTGlzdC5JdGVtPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtsaW5rcy5kb2NzICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPExpc3QuSXRlbT5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGEgaHJlZj17bGlua3MuZG9jc30gdGFyZ2V0PVwiX2JsYW5rXCIgcmVsPVwibm9yZWZlcnJlclwiPkRvY3M8L2E+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9MaXN0Lkl0ZW0+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDwvTGlzdD5cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICA8L2hlYWRlcj5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJwYWdlLWNvbnRlbnRcIj5cclxuICAgICAgICAgICAgICAgIHtjaGlsZHJlbn1cclxuICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgPC9hcnRpY2xlPlxyXG4gICAgKTtcclxufSIsImltcG9ydCB7IHVzZVN0YXRlIH0gZnJvbSAncmVhY3QnO1xyXG5pbXBvcnQge1xyXG4gICAgQXZhdGFyLFxyXG4gICAgU2VnbWVudGVkQnV0dG9uXHJcbn0gZnJvbSAnbWRjLXJlYWN0JztcclxuXHJcbmltcG9ydCBEZW1vIGZyb20gJ0AvY29tcG9uZW50cy9EZW1vJztcclxuaW1wb3J0IEZpZWxkU2V0IGZyb20gJ0AvY29tcG9uZW50cy9GaWVsZFNldCc7XHJcbmltcG9ydCBQYWdlIGZyb20gJ0AvY29tcG9uZW50cy9QYWdlJztcclxuXHJcbmNvbnN0IGlkID0gJ2F2YXRhcic7XHJcbmNvbnN0IHRpdGxlID0gJ0F2YXRhcic7XHJcbmNvbnN0IGRlc2NyaXB0aW9uID0gJ0F2YXRhcnMgYXJlIGZvdW5kIHRocm91Z2hvdXQgbWF0ZXJpYWwgZGVzaWduIHdpdGggdXNlcyBpbiBldmVyeXRoaW5nIGZyb20gdGFibGVzIHRvIGRpYWxvZyBtZW51cy4nO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gQXZhdGFyUGFnZSgpIHtcclxuICAgIGNvbnN0IFtzaXplLCBzZXRTaXplXSA9IHVzZVN0YXRlKCdtZWRpdW0nKTtcclxuICAgIGNvbnN0IFtjb250ZW50LCBzZXRDb250ZW50XSA9IHVzZVN0YXRlKCdpbWFnZScpO1xyXG5cclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgPFBhZ2VcclxuICAgICAgICAgICAgaWQ9e2lkfVxyXG4gICAgICAgICAgICB0aXRsZT17dGl0bGV9XHJcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uPXtkZXNjcmlwdGlvbn1cclxuICAgICAgICA+XHJcbiAgICAgICAgICAgIDxEZW1vXHJcbiAgICAgICAgICAgICAgICB0aXRsZT1cIkRlbW9cIlxyXG4gICAgICAgICAgICAgICAgc2V0dGluZ3M9e1xyXG4gICAgICAgICAgICAgICAgICAgIDw+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxGaWVsZFNldCBsZWdlbmQ9XCJDb250ZW50XCI+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8U2VnbWVudGVkQnV0dG9uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VnbWVudHM9e1tcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeyB2YWx1ZTogJ2ltYWdlJywgbGFiZWw6ICdJbWFnZScgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeyB2YWx1ZTogJ2ljb24nLCBsYWJlbDogJ0ljb24nIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgdmFsdWU6ICd0ZXh0JywgbGFiZWw6ICdUZXh0JyB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXX1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZT17Y29udGVudH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbkNoYW5nZT17c2V0Q29udGVudH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDwvRmllbGRTZXQ+XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8RmllbGRTZXQgbGVnZW5kPVwiU2l6ZVwiPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPFNlZ21lbnRlZEJ1dHRvblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlZ21lbnRzPXtbXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgdmFsdWU6ICdzbWFsbCcsIGxhYmVsOiAnU21hbGwnIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgdmFsdWU6ICdtZWRpdW0nLCBsYWJlbDogJ01lZGl1bScgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeyB2YWx1ZTogJ2xhcmdlJywgbGFiZWw6ICdMYXJnZScgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF19XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU9e3NpemV9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb25DaGFuZ2U9e3NldFNpemV9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8L0ZpZWxkU2V0PlxyXG4gICAgICAgICAgICAgICAgICAgIDwvPlxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICA+XHJcbiAgICAgICAgICAgICAgICA8QXZhdGFyXHJcbiAgICAgICAgICAgICAgICAgICAgaW1hZ2U9e2NvbnRlbnQgPT09ICdpbWFnZScgPyAnaHR0cHM6Ly9wbGFjZWltZy5jb20vMTI4LzEyOC9wZW9wbGUnIDogdW5kZWZpbmVkfVxyXG4gICAgICAgICAgICAgICAgICAgIGljb249e2NvbnRlbnQgPT09ICdpY29uJyA/ICdzdGFyJyA6IHVuZGVmaW5lZH1cclxuICAgICAgICAgICAgICAgICAgICB0ZXh0PXtjb250ZW50ID09PSAndGV4dCcgPyAnTUQnIDogdW5kZWZpbmVkfVxyXG4gICAgICAgICAgICAgICAgICAgIHNpemU9e3NpemV9XHJcbiAgICAgICAgICAgICAgICAvPlxyXG4gICAgICAgICAgICA8L0RlbW8+XHJcbiAgICAgICAgPC9QYWdlPlxyXG4gICAgKTtcclxufSIsImltcG9ydCB7IHVzZVN0YXRlIH0gZnJvbSAncmVhY3QnO1xyXG5pbXBvcnQge1xyXG4gICAgQXZhdGFyLFxyXG4gICAgQmFkZ2UsXHJcbiAgICBCdXR0b24sXHJcbiAgICBGb3JtRmllbGQsXHJcbiAgICBJY29uLFxyXG4gICAgSWNvbkJ1dHRvbixcclxuICAgIFNlZ21lbnRlZEJ1dHRvbixcclxuICAgIFN3aXRjaCxcclxuICAgIFRleHRGaWVsZFxyXG59IGZyb20gJ21kYy1yZWFjdCc7XHJcblxyXG5pbXBvcnQgRGVtbyBmcm9tICdAL2NvbXBvbmVudHMvRGVtbyc7XHJcbmltcG9ydCBGaWVsZFNldCBmcm9tICdAL2NvbXBvbmVudHMvRmllbGRTZXQnO1xyXG5pbXBvcnQgUGFnZSBmcm9tICdAL2NvbXBvbmVudHMvUGFnZSc7XHJcblxyXG5jb25zdCBpZCA9ICdiYWRnZSc7XHJcbmNvbnN0IHRpdGxlID0gJ0JhZGdlJztcclxuY29uc3QgZGVzY3JpcHRpb24gPSAnQmFkZ2UgZ2VuZXJhdGVzIGEgc21hbGwgYmFkZ2UgdG8gdGhlIHRvcC1yaWdodCBvZiBpdHMgY2hpbGQocmVuKS4nO1xyXG5cclxuY29uc3QgY29udGVudCA9IHtcclxuICAgIGF2YXRhcjogPEF2YXRhciB0ZXh0PVwiTURcIiAvPixcclxuICAgIGJ1dHRvbjogPEJ1dHRvbiBvdXRsaW5lZD5CdXR0b248L0J1dHRvbj4sXHJcbiAgICBpY29uOiA8SWNvbj5zdGFyPC9JY29uPixcclxuICAgIGljb25CdXR0b246IDxJY29uQnV0dG9uIGljb249XCJzdGFyXCIgLz4sXHJcbiAgICB0ZXh0OiAnVGV4dCdcclxufTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIEJhZGdlUGFnZSgpIHtcclxuICAgIGNvbnN0IFt2YWx1ZSwgc2V0VmFsdWVdID0gdXNlU3RhdGUoMCk7XHJcbiAgICBjb25zdCBbdHlwZSwgc2V0VHlwZV0gPSB1c2VTdGF0ZSgnYXZhdGFyJyk7XHJcbiAgICBjb25zdCBbaW5zZXQsIHNldEluc2V0XSA9IHVzZVN0YXRlKGZhbHNlKTtcclxuICAgIGNvbnN0IFt0cmFuc3BhcmVudCwgc2V0VHJhbnNwYXJlbnRdID0gdXNlU3RhdGUoZmFsc2UpO1xyXG5cclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgPFBhZ2UgaWQ9e2lkfSB0aXRsZT17dGl0bGV9IGRlc2NyaXB0aW9uPXtkZXNjcmlwdGlvbn0+XHJcbiAgICAgICAgICAgIDxEZW1vXHJcbiAgICAgICAgICAgICAgICBzZXR0aW5ncz17W1xyXG4gICAgICAgICAgICAgICAgICAgIDxUZXh0RmllbGRcclxuICAgICAgICAgICAgICAgICAgICAgICAga2V5PVwidmFsdWVcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZT17dmFsdWV9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsPVwiVmFsdWVcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRsaW5lZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBvbkNoYW5nZT17KF8sIHZhbHVlKSA9PiBzZXRWYWx1ZSh2YWx1ZSl9XHJcbiAgICAgICAgICAgICAgICAgICAgLz4sXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIDxGaWVsZFNldCBrZXk9XCJjb250ZW50XCIgbGVnZW5kPVwiQ29udGVudFwiPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8U2VnbWVudGVkQnV0dG9uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWdtZW50cz17W1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgdmFsdWU6ICdhdmF0YXInLCBsYWJlbDogJ0F2YXRhcicgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7IHZhbHVlOiAnYnV0dG9uJywgbGFiZWw6ICdCdXR0b24nIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeyB2YWx1ZTogJ2ljb24nLCBsYWJlbDogJ0ljb24nIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeyB2YWx1ZTogJ2ljb25CdXR0b24nLCBsYWJlbDogJ0ljb24gQnV0dG9uJyB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgdmFsdWU6ICd0ZXh0JywgbGFiZWw6ICdUZXh0JyB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBdfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU9e3R5cGV9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbkNoYW5nZT17c2V0VHlwZX1cclxuICAgICAgICAgICAgICAgICAgICAgICAgLz5cclxuICAgICAgICAgICAgICAgICAgICA8L0ZpZWxkU2V0PixcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgPEZvcm1GaWVsZCBrZXk9XCJpbnNldFwiIGxhYmVsPVwiSW5zZXRcIiBhbGlnbkVuZCBzcGFjZUJldHdlZW4+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxTd2l0Y2hcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdGVkPXtpbnNldH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2hhbmdlPXsoKSA9PiBzZXRJbnNldCh2ID0+ICF2KX1cclxuICAgICAgICAgICAgICAgICAgICAgICAgLz5cclxuICAgICAgICAgICAgICAgICAgICA8L0Zvcm1GaWVsZD4sXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIDxGb3JtRmllbGQga2V5PVwidHJhbnNwYXJlbnRcIiBsYWJlbD1cIlRyYW5zcGFyZW50XCIgYWxpZ25FbmQgc3BhY2VCZXR3ZWVuPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8U3dpdGNoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3RlZD17dHJhbnNwYXJlbnR9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbkNoYW5nZT17KCkgPT4gc2V0VHJhbnNwYXJlbnQodiA9PiAhdil9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8+XHJcbiAgICAgICAgICAgICAgICAgICAgPC9Gb3JtRmllbGQ+XHJcbiAgICAgICAgICAgICAgICBdfVxyXG4gICAgICAgICAgICA+XHJcbiAgICAgICAgICAgICAgICA8QmFkZ2VcclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZT17dmFsdWV9XHJcbiAgICAgICAgICAgICAgICAgICAgaW5zZXQ9e2luc2V0IHx8IHVuZGVmaW5lZH1cclxuICAgICAgICAgICAgICAgICAgICB0cmFuc3BhcmVudD17dHJhbnNwYXJlbnQgfHwgdW5kZWZpbmVkfVxyXG4gICAgICAgICAgICAgICAgPlxyXG4gICAgICAgICAgICAgICAgICAgIHtjb250ZW50W3R5cGVdfVxyXG4gICAgICAgICAgICAgICAgPC9CYWRnZT5cclxuICAgICAgICAgICAgPC9EZW1vPlxyXG4gICAgICAgIDwvUGFnZT5cclxuICAgICk7XHJcbn0iLCJpbXBvcnQgeyB1c2VTdGF0ZSB9IGZyb20gJ3JlYWN0JztcclxuaW1wb3J0IHtcclxuICAgIEJhbm5lcixcclxuICAgIEJ1dHRvbixcclxuICAgIEZvcm1GaWVsZCxcclxuICAgIFN3aXRjaCxcclxuICAgIFRleHRGaWVsZCxcclxuICAgIFRvcEFwcEJhclxyXG59IGZyb20gJ21kYy1yZWFjdCc7XHJcblxyXG5pbXBvcnQgRGVtbyBmcm9tICdAL2NvbXBvbmVudHMvRGVtbyc7XHJcbmltcG9ydCBQYWdlIGZyb20gJ0AvY29tcG9uZW50cy9QYWdlJztcclxuXHJcbmltcG9ydCAnLi9pbmRleC5zY3NzJztcclxuXHJcbmNvbnN0IGlkID0gJ2Jhbm5lcic7XHJcbmNvbnN0IHRpdGxlID0gJ0Jhbm5lcic7XHJcbmNvbnN0IGRlc2NyaXB0aW9uID0gJ0EgYmFubmVyIGRpc3BsYXlzIGEgcHJvbWluZW50IG1lc3NhZ2UgYW5kIHJlbGF0ZWQgb3B0aW9uYWwgYWN0aW9ucy4nO1xyXG5jb25zdCBsaW5rcyA9IHtcclxuICAgIGRvY3M6ICdodHRwczovL2dpdGh1Yi5jb20vbWF0ZXJpYWwtY29tcG9uZW50cy9tYXRlcmlhbC1jb21wb25lbnRzLXdlYi90cmVlL21hc3Rlci9wYWNrYWdlcy9tZGMtYmFubmVyJyxcclxuICAgIGd1aWRlOiAnaHR0cHM6Ly9tYXRlcmlhbC5pby9jb21wb25lbnRzL2Jhbm5lcnMnXHJcbn07XHJcblxyXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBCYWRnZVBhZ2UoKSB7XHJcbiAgICBjb25zdCBbb3Blbiwgc2V0T3Blbl0gPSB1c2VTdGF0ZShmYWxzZSk7XHJcbiAgICBjb25zdCBbdGV4dCwgc2V0VGV4dF0gPSB1c2VTdGF0ZSgnTG9yZW0gaXBzdW0nKTtcclxuICAgIGNvbnN0IFtoYXNJY29uLCBzZXRIYXNJY29uXSA9IHVzZVN0YXRlKGZhbHNlKTtcclxuICAgIGNvbnN0IFtpY29uLCBzZXRJY29uXSA9IHVzZVN0YXRlKCcnKTtcclxuICAgIGNvbnN0IFtoYXNBY3Rpb24sIHNldEhhc0FjdGlvbl0gPSB1c2VTdGF0ZShmYWxzZSk7XHJcbiAgICBjb25zdCBbYWN0aW9uLCBzZXRBY3Rpb25dID0gdXNlU3RhdGUoJycpO1xyXG4gICAgY29uc3QgW2hhc1NlY29uZGFyeUFjdGlvbiwgc2V0SGFzU2Vjb25kYXJ5QWN0aW9uXSA9IHVzZVN0YXRlKGZhbHNlKTtcclxuICAgIGNvbnN0IFtzZWNvbmRhcnlBY3Rpb24sIHNldFNlY29uZGFyeUFjdGlvbl0gPSB1c2VTdGF0ZSgnJyk7XHJcbiAgICBjb25zdCBbY2VudGVyZWQsIHNldENlbnRlcmVkXSA9IHVzZVN0YXRlKGZhbHNlKTtcclxuICAgIGNvbnN0IFtmaXhlZCwgc2V0Rml4ZWRdID0gdXNlU3RhdGUoZmFsc2UpO1xyXG4gICAgY29uc3QgW21vYmlsZVN0YWNrZWQsIHNldE1vYmlsZVN0YWNrZWRdID0gdXNlU3RhdGUoZmFsc2UpO1xyXG5cclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgPFBhZ2UgaWQ9e2lkfSB0aXRsZT17dGl0bGV9IGRlc2NyaXB0aW9uPXtkZXNjcmlwdGlvbn0gbGlua3M9e2xpbmtzfT5cclxuICAgICAgICAgICAgPERlbW9cclxuICAgICAgICAgICAgICAgIHRpdGxlPVwiRGVtb1wiXHJcbiAgICAgICAgICAgICAgICBzZXR1cD17XHJcbiAgICAgICAgICAgICAgICAgICAgPFRvcEFwcEJhclxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aXRsZT1cIlRpdGxlXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgYWN0aW9uSXRlbXM9e1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPEJ1dHRvblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsPVwiVG9nZ2xlXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbkNsaWNrPXsoKSA9PiBzZXRPcGVuKHYgPT4gIXYpfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLz5cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIC8+XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBzZXR0aW5ncz17PD5cclxuICAgICAgICAgICAgICAgICAgICA8VGV4dEZpZWxkXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlPXt0ZXh0fVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBsYWJlbD1cIlRleHRcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBvbkNoYW5nZT17KF8sIHZhbHVlKSA9PiBzZXRUZXh0KHZhbHVlKX1cclxuICAgICAgICAgICAgICAgICAgICAgICAgb3V0bGluZWRcclxuICAgICAgICAgICAgICAgICAgICAvPlxyXG5cclxuICAgICAgICAgICAgICAgICAgICA8VGV4dEZpZWxkXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlPXtpY29ufVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBsYWJlbD1cIkljb25cIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0cmFpbGluZ0ljb249e1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPFN3aXRjaFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdGVkPXtoYXNJY29ufVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2hhbmdlPXsoKSA9PiBzZXRIYXNJY29uKHYgPT4gIXYpfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLz5cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRsaW5lZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBkaXNhYmxlZD17IWhhc0ljb259XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2hhbmdlPXsoXywgdmFsdWUpID0+IHNldEljb24odmFsdWUpfVxyXG4gICAgICAgICAgICAgICAgICAgIC8+XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIDxUZXh0RmllbGRcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU9e2FjdGlvbn1cclxuICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWw9XCJBY3Rpb25cIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0cmFpbGluZ0ljb249e1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPFN3aXRjaFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdGVkPXtoYXNBY3Rpb259XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb25DaGFuZ2U9eygpID0+IHNldEhhc0FjdGlvbih2ID0+ICF2KX1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZGlzYWJsZWQ9eyFoYXNBY3Rpb259XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dGxpbmVkXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2hhbmdlPXsoXywgdmFsdWUpID0+IHNldEFjdGlvbih2YWx1ZSl9XHJcbiAgICAgICAgICAgICAgICAgICAgLz5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgPFRleHRGaWVsZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZT17c2Vjb25kYXJ5QWN0aW9ufVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBsYWJlbD1cIlNlY29uZGFyeSBhY3Rpb25cIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0cmFpbGluZ0ljb249e1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPFN3aXRjaFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdGVkPXtoYXNTZWNvbmRhcnlBY3Rpb259XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb25DaGFuZ2U9eygpID0+IHNldEhhc1NlY29uZGFyeUFjdGlvbih2ID0+ICF2KX1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZGlzYWJsZWQ9eyFoYXNTZWNvbmRhcnlBY3Rpb259XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dGxpbmVkXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2hhbmdlPXsoXywgdmFsdWUpID0+IHNldFNlY29uZGFyeUFjdGlvbih2YWx1ZSl9XHJcbiAgICAgICAgICAgICAgICAgICAgLz5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgPEZvcm1GaWVsZCBsYWJlbD1cIkNlbnRlcmVkXCIgYWxpZ25FbmQgc3BhY2VCZXR3ZWVuPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8U3dpdGNoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3RlZD17Y2VudGVyZWR9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbkNoYW5nZT17KCkgPT4gc2V0Q2VudGVyZWQodiA9PiAhdil9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8+XHJcbiAgICAgICAgICAgICAgICAgICAgPC9Gb3JtRmllbGQ+XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIDxGb3JtRmllbGQgbGFiZWw9XCJGaXhlZFwiIGFsaWduRW5kIHNwYWNlQmV0d2Vlbj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPFN3aXRjaFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0ZWQ9e2ZpeGVkfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb25DaGFuZ2U9eygpID0+IHNldEZpeGVkKHYgPT4gIXYpfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvPlxyXG4gICAgICAgICAgICAgICAgICAgIDwvRm9ybUZpZWxkPlxyXG5cclxuICAgICAgICAgICAgICAgICAgICA8Rm9ybUZpZWxkIGxhYmVsPVwiTW9iaWxlIHN0YWNrZWRcIiBhbGlnbkVuZCBzcGFjZUJldHdlZW4+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxTd2l0Y2hcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdGVkPXttb2JpbGVTdGFja2VkfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb25DaGFuZ2U9eygpID0+IHNldE1vYmlsZVN0YWNrZWQodiA9PiAhdil9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8+XHJcbiAgICAgICAgICAgICAgICAgICAgPC9Gb3JtRmllbGQ+XHJcbiAgICAgICAgICAgICAgICA8Lz59XHJcbiAgICAgICAgICAgID5cclxuICAgICAgICAgICAgICAgIDxCYW5uZXJcclxuICAgICAgICAgICAgICAgICAgICB0ZXh0PXt0ZXh0fVxyXG4gICAgICAgICAgICAgICAgICAgIGljb249e2hhc0ljb24gPyBpY29uIDogdW5kZWZpbmVkfVxyXG4gICAgICAgICAgICAgICAgICAgIGFjdGlvbj17aGFzQWN0aW9uID9cclxuICAgICAgICAgICAgICAgICAgICAgICAgPEJ1dHRvbj57YWN0aW9ufTwvQnV0dG9uPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHVuZGVmaW5lZFxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBzZWNvbmRhcnlBY3Rpb249e2hhc1NlY29uZGFyeUFjdGlvbiA/XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxCdXR0b24+e3NlY29uZGFyeUFjdGlvbn08L0J1dHRvbj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB1bmRlZmluZWRcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgb3Blbj17b3BlbiB8fCB1bmRlZmluZWR9XHJcbiAgICAgICAgICAgICAgICAgICAgY2VudGVyZWQ9e2NlbnRlcmVkIHx8IHVuZGVmaW5lZH1cclxuICAgICAgICAgICAgICAgICAgICBmaXhlZD17Zml4ZWQgfHwgdW5kZWZpbmVkfVxyXG4gICAgICAgICAgICAgICAgICAgIG1vYmlsZVN0YWNrZWQ9e21vYmlsZVN0YWNrZWQgfHwgdW5kZWZpbmVkfVxyXG4gICAgICAgICAgICAgICAgLz5cclxuICAgICAgICAgICAgPC9EZW1vPlxyXG4gICAgICAgIDwvUGFnZT5cclxuICAgICk7XHJcbn0iLCJpbXBvcnQgeyB1c2VTdGF0ZSB9IGZyb20gJ3JlYWN0JztcclxuaW1wb3J0IHtcclxuICAgIEJ1dHRvbixcclxuICAgIFNlZ21lbnRlZEJ1dHRvbixcclxuICAgIFN3aXRjaCxcclxuICAgIFRleHRGaWVsZFxyXG59IGZyb20gJ21kYy1yZWFjdCc7XHJcblxyXG5pbXBvcnQgRGVtbyBmcm9tICdAL2NvbXBvbmVudHMvRGVtbyc7XHJcbmltcG9ydCBGaWVsZFNldCBmcm9tICdAL2NvbXBvbmVudHMvRmllbGRTZXQnO1xyXG5pbXBvcnQgUGFnZSBmcm9tICdAL2NvbXBvbmVudHMvUGFnZSc7XHJcblxyXG5jb25zdCBpZCA9ICdidXR0b24nO1xyXG5jb25zdCB0aXRsZSA9ICdCdXR0b24nO1xyXG5jb25zdCBkZXNjcmlwdGlvbiA9ICdCdXR0b25zIGNvbW11bmljYXRlIGFuIGFjdGlvbiBhIHVzZXIgY2FuIHRha2UuIFRoZXkgYXJlIHR5cGljYWxseSBwbGFjZWQgdGhyb3VnaG91dCB5b3VyIFVJLCBpbiBwbGFjZXMgbGlrZSBkaWFsb2dzLCBmb3JtcywgY2FyZHMsIGFuZCB0b29sYmFycy4nO1xyXG5jb25zdCBsaW5rcyA9IHtcclxuICAgIGRvY3M6ICdodHRwczovL2dpdGh1Yi5jb20vbWF0ZXJpYWwtY29tcG9uZW50cy9tYXRlcmlhbC1jb21wb25lbnRzLXdlYi90cmVlL21hc3Rlci9wYWNrYWdlcy9tZGMtYnV0dG9uJyxcclxuICAgIGd1aWRlOiAnaHR0cHM6Ly9tYXRlcmlhbC5pby9jb21wb25lbnRzL2J1dHRvbnMnXHJcbn07XHJcblxyXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBCdXR0b25QYWdlKCkge1xyXG4gICAgY29uc3QgW2xhYmVsLCBzZXRMYWJlbF0gPSB1c2VTdGF0ZSgnQnV0dG9uJyk7XHJcbiAgICBjb25zdCBbaGFzTGVhZGluZ0ljb24sIHNldEhhc0xlYWRpbmdJY29uXSA9IHVzZVN0YXRlKGZhbHNlKTtcclxuICAgIGNvbnN0IFtsZWFkaW5nSWNvbiwgc2V0TGVhZGluZ0ljb25dID0gdXNlU3RhdGUoJ3NhdmUnKTtcclxuICAgIGNvbnN0IFtoYXNUcmFpbGluZ0ljb24sIHNldEhhc1RyYWlsaW5nSWNvbl0gPSB1c2VTdGF0ZShmYWxzZSk7XHJcbiAgICBjb25zdCBbdHJhaWxpbmdJY29uLCBzZXRUcmFpbGluZ0ljb25dID0gdXNlU3RhdGUoJ2Nsb3NlJyk7XHJcbiAgICBjb25zdCBbdHlwZSwgc2V0VHlwZV0gPSB1c2VTdGF0ZSgncGxhaW4nKTtcclxuXHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAgIDxQYWdlIGlkPXtpZH0gdGl0bGU9e3RpdGxlfSBkZXNjcmlwdGlvbj17ZGVzY3JpcHRpb259IGxpbmtzPXtsaW5rc30+XHJcbiAgICAgICAgICAgIDxEZW1vXHJcbiAgICAgICAgICAgICAgICB0aXRsZT1cIkRlbW9cIlxyXG4gICAgICAgICAgICAgICAgc2V0dGluZ3M9ezw+XHJcbiAgICAgICAgICAgICAgICAgICAgPFRleHRGaWVsZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZT17bGFiZWx9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsPVwiTGFiZWxcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRsaW5lZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBvbkNoYW5nZT17KF8sIHZhbHVlKSA9PiBzZXRMYWJlbCh2YWx1ZSl9XHJcbiAgICAgICAgICAgICAgICAgICAgLz5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgPFRleHRGaWVsZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZT17bGVhZGluZ0ljb259XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsPVwiTGVhZGluZyBpY29uXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgdHJhaWxpbmdJY29uPXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxTd2l0Y2hcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3RlZD17aGFzTGVhZGluZ0ljb259XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb25DaGFuZ2U9eygpID0+IHNldEhhc0xlYWRpbmdJY29uKHYgPT4gIXYpfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLz5cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRsaW5lZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBkaXNhYmxlZD17IWhhc0xlYWRpbmdJY29ufVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBvbkNoYW5nZT17KF8sIHZhbHVlKSA9PiBzZXRMZWFkaW5nSWNvbih2YWx1ZSl9XHJcbiAgICAgICAgICAgICAgICAgICAgLz5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgPFRleHRGaWVsZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZT17dHJhaWxpbmdJY29ufVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBsYWJlbD1cIlRyYWlsaW5nIGljb25cIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0cmFpbGluZ0ljb249e1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPFN3aXRjaFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdGVkPXtoYXNUcmFpbGluZ0ljb259XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb25DaGFuZ2U9eygpID0+IHNldEhhc1RyYWlsaW5nSWNvbih2ID0+ICF2KX1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgb3V0bGluZWRcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGlzYWJsZWQ9eyFoYXNUcmFpbGluZ0ljb259XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2hhbmdlPXsoXywgdmFsdWUpID0+IHNldFRyYWlsaW5nSWNvbih2YWx1ZSl9XHJcbiAgICAgICAgICAgICAgICAgICAgLz5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgPEZpZWxkU2V0IGxlZ2VuZD1cIlR5cGVcIj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPFNlZ21lbnRlZEJ1dHRvblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VnbWVudHM9e1tcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7IHZhbHVlOiAncGxhaW4nLCBsYWJlbDogJ1BsYWluJyB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgdmFsdWU6ICdvdXRsaW5lZCcsIGxhYmVsOiAnT3V0bGluZWQnIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeyB2YWx1ZTogJ3VuZWxldmF0ZWQnLCBsYWJlbDogJ1VuZWxldmF0ZWQnIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeyB2YWx1ZTogJ3JhaXNlZCcsIGxhYmVsOiAnUmFpc2VkJyB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBdfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU9e3R5cGV9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbkNoYW5nZT17c2V0VHlwZX1cclxuICAgICAgICAgICAgICAgICAgICAgICAgLz5cclxuICAgICAgICAgICAgICAgICAgICA8L0ZpZWxkU2V0PlxyXG4gICAgICAgICAgICAgICAgPC8+fVxyXG4gICAgICAgICAgICA+XHJcbiAgICAgICAgICAgICAgICA8QnV0dG9uXHJcbiAgICAgICAgICAgICAgICAgICAgbGVhZGluZ0ljb249e2hhc0xlYWRpbmdJY29uID8gbGVhZGluZ0ljb24gOiB1bmRlZmluZWR9XHJcbiAgICAgICAgICAgICAgICAgICAgdHJhaWxpbmdJY29uPXtoYXNUcmFpbGluZ0ljb24gPyB0cmFpbGluZ0ljb24gOiB1bmRlZmluZWR9XHJcbiAgICAgICAgICAgICAgICAgICAgb3V0bGluZWQ9e3R5cGUgPT09ICdvdXRsaW5lZCcgfHwgdW5kZWZpbmVkfVxyXG4gICAgICAgICAgICAgICAgICAgIHVuZWxldmF0ZWQ9e3R5cGUgPT09ICd1bmVsZXZhdGVkJyB8fCB1bmRlZmluZWR9XHJcbiAgICAgICAgICAgICAgICAgICAgcmFpc2VkPXt0eXBlID09PSAncmFpc2VkJyB8fCB1bmRlZmluZWR9XHJcbiAgICAgICAgICAgICAgICA+XHJcbiAgICAgICAgICAgICAgICAgICAge2xhYmVsfVxyXG4gICAgICAgICAgICAgICAgPC9CdXR0b24+XHJcbiAgICAgICAgICAgIDwvRGVtbz5cclxuICAgICAgICA8L1BhZ2U+XHJcbiAgICApO1xyXG59IiwiaW1wb3J0IHsgdXNlU3RhdGUgfSBmcm9tICdyZWFjdCc7XHJcbmltcG9ydCB7XHJcbiAgICBDYXJkLFxyXG4gICAgU3dpdGNoLFxyXG4gICAgVGV4dEZpZWxkXHJcbn0gZnJvbSAnbWRjLXJlYWN0JztcclxuXHJcbmltcG9ydCBEZW1vIGZyb20gJ0AvY29tcG9uZW50cy9EZW1vJztcclxuaW1wb3J0IFBhZ2UgZnJvbSAnQC9jb21wb25lbnRzL1BhZ2UnO1xyXG5cclxuY29uc3QgaWQgPSAnY2FyZCc7XHJcbmNvbnN0IHBhZ2VUaXRsZSA9ICdDYXJkJztcclxuY29uc3QgZGVzY3JpcHRpb24gPSAnQ2FyZHMgY29udGFpbiBjb250ZW50IGFuZCBhY3Rpb25zIGFib3V0IGEgc2luZ2xlIHN1YmplY3QuJztcclxuY29uc3QgbGlua3MgPSB7XHJcbiAgICBkb2NzOiAnaHR0cHM6Ly9naXRodWIuY29tL21hdGVyaWFsLWNvbXBvbmVudHMvbWF0ZXJpYWwtY29tcG9uZW50cy13ZWIvdHJlZS9tYXN0ZXIvcGFja2FnZXMvbWRjLWNhcmQnLFxyXG4gICAgZ3VpZGU6ICdodHRwczovL21hdGVyaWFsLmlvL2NvbXBvbmVudHMvY2FyZHMnXHJcbn07ICcnO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gQ2FyZFBhZ2UoKSB7XHJcbiAgICBjb25zdCBbaGFzVGl0bGUsIHNldEhhc1RpdGxlXSA9IHVzZVN0YXRlKHRydWUpO1xyXG4gICAgY29uc3QgW3RpdGxlLCBzZXRUaXRsZV0gPSB1c2VTdGF0ZSgnVGl0bGUnKTtcclxuICAgIGNvbnN0IFtoYXNTdWJ0aXRsZSwgc2V0SGFzU3VidGl0bGVdID0gdXNlU3RhdGUodHJ1ZSk7XHJcbiAgICBjb25zdCBbc3VidGl0bGUsIHNldFN1YnRpdGxlXSA9IHVzZVN0YXRlKCdTdWJ0aXRsZScpO1xyXG5cclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgPFBhZ2VcclxuICAgICAgICAgICAgaWQ9e2lkfVxyXG4gICAgICAgICAgICB0aXRsZT17cGFnZVRpdGxlfVxyXG4gICAgICAgICAgICBkZXNjcmlwdGlvbj17ZGVzY3JpcHRpb259XHJcbiAgICAgICAgICAgIGxpbmtzPXtsaW5rc31cclxuICAgICAgICA+XHJcbiAgICAgICAgICAgIDxEZW1vXHJcbiAgICAgICAgICAgICAgICBzZXR0aW5ncz17PD5cclxuICAgICAgICAgICAgICAgICAgICA8VGV4dEZpZWxkXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlPXt0aXRsZX1cclxuICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWw9XCJUaXRsZVwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYWlsaW5nSWNvbj17XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8U3dpdGNoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0ZWQ9e2hhc1RpdGxlfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2hhbmdlPXsoKSA9PiBzZXRIYXNUaXRsZSh2ID0+ICF2KX1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgb3V0bGluZWRcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGlzYWJsZWQ9eyFoYXNUaXRsZX1cclxuICAgICAgICAgICAgICAgICAgICAgICAgb25DaGFuZ2U9eyhfLCB2YWx1ZSkgPT4gc2V0VGl0bGUodmFsdWUpfVxyXG4gICAgICAgICAgICAgICAgICAgIC8+XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIDxUZXh0RmllbGRcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU9e3N1YnRpdGxlfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBsYWJlbD1cIlN1YnRpdGxlXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgdHJhaWxpbmdJY29uPXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxTd2l0Y2hcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3RlZD17aGFzU3VidGl0bGV9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb25DaGFuZ2U9eygpID0+IHNldEhhc1N1YnRpdGxlKHYgPT4gIXYpfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLz5cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRsaW5lZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBkaXNhYmxlZD17IWhhc1N1YnRpdGxlfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBvbkNoYW5nZT17KF8sIHZhbHVlKSA9PiBzZXRTdWJ0aXRsZSh2YWx1ZSl9XHJcbiAgICAgICAgICAgICAgICAgICAgLz5cclxuICAgICAgICAgICAgICAgIDwvPn1cclxuICAgICAgICAgICAgPlxyXG4gICAgICAgICAgICAgICAgPENhcmQ+XHJcbiAgICAgICAgICAgICAgICAgICAgPENhcmQuSGVhZGVyXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG92ZXJsaW5lPVwiT3ZlcmxpbmVcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aXRsZT17aGFzVGl0bGUgPyB0aXRsZSA6IHVuZGVmaW5lZH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgc3VidGl0bGU9e2hhc1N1YnRpdGxlID8gc3VidGl0bGUgOiB1bmRlZmluZWR9XHJcbiAgICAgICAgICAgICAgICAgICAgLz5cclxuICAgICAgICAgICAgICAgIDwvQ2FyZD5cclxuICAgICAgICAgICAgPC9EZW1vPlxyXG4gICAgICAgIDwvUGFnZSA+XHJcbiAgICApO1xyXG59IiwiaW1wb3J0IHsgdXNlU3RhdGUgfSBmcm9tICdyZWFjdCc7XHJcbmltcG9ydCB7IENoZWNrYm94IH0gZnJvbSAnbWRjLXJlYWN0JztcclxuXHJcbmltcG9ydCBEZW1vIGZyb20gJ0AvY29tcG9uZW50cy9EZW1vJztcclxuaW1wb3J0IFBhZ2UgZnJvbSAnQC9jb21wb25lbnRzL1BhZ2UnO1xyXG5cclxuY29uc3QgaWQgPSAnY2hlY2tib3gnO1xyXG5jb25zdCB0aXRsZSA9ICdDaGVja2JveCc7XHJcbmNvbnN0IGRlc2NyaXB0aW9uID0gJ0NoZWNrYm94ZXMgYWxsb3cgdGhlIHVzZXIgdG8gc2VsZWN0IG11bHRpcGxlIG9wdGlvbnMgZnJvbSBhIHNldC4nO1xyXG5jb25zdCBsaW5rcyA9IHtcclxuICAgIGRvY3M6ICdodHRwczovL2dpdGh1Yi5jb20vbWF0ZXJpYWwtY29tcG9uZW50cy9tYXRlcmlhbC1jb21wb25lbnRzLXdlYi90cmVlL21hc3Rlci9wYWNrYWdlcy9tZGMtY2hlY2tib3gnLFxyXG4gICAgZ3VpZGU6ICdodHRwczovL21hdGVyaWFsLmlvL2NvbXBvbmVudHMvY2hlY2tib3hlcydcclxufTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIENoZWNrYm94UGFnZSgpIHtcclxuICAgIGNvbnN0IFtjaGVja2VkLCBzZXRDaGVja2VkXSA9IHVzZVN0YXRlKGZhbHNlKTtcclxuICAgIGNvbnN0IFtjb250cm9sbGVkLCBzZXRDb250cm9sbGVkXSA9IHVzZVN0YXRlKGZhbHNlKTtcclxuICAgIGNvbnN0IFtpbmRldGVybWluYXRlLCBzZXRJbmRldGVybWluYXRlXSA9IHVzZVN0YXRlKGZhbHNlKTtcclxuICAgIGNvbnN0IFtkaXNhYmxlZCwgc2V0RGlzYWJsZWRdID0gdXNlU3RhdGUoZmFsc2UpO1xyXG5cclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgPFBhZ2UgaWQ9e2lkfSB0aXRsZT17dGl0bGV9IGRlc2NyaXB0aW9uPXtkZXNjcmlwdGlvbn0gbGlua3M9e2xpbmtzfT5cclxuICAgICAgICAgICAgPERlbW8+XHJcbiAgICAgICAgICAgICAgICA8Q2hlY2tib3hcclxuICAgICAgICAgICAgICAgICAgICBjaGVja2VkPXtjaGVja2VkfVxyXG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHRDaGVja2VkPXtmYWxzZX1cclxuICAgICAgICAgICAgICAgICAgICBpbmRldGVybWluYXRlPXtpbmRldGVybWluYXRlfVxyXG4gICAgICAgICAgICAgICAgICAgIGRpc2FibGVkPXtkaXNhYmxlZH1cclxuICAgICAgICAgICAgICAgICAgICBvbkNoYW5nZT17KCkgPT4gc2V0Q2hlY2tlZCh2ID0+ICF2KX1cclxuICAgICAgICAgICAgICAgIC8+XHJcbiAgICAgICAgICAgIDwvRGVtbz5cclxuICAgICAgICA8L1BhZ2U+XHJcbiAgICApO1xyXG59IiwiaW1wb3J0IHsgdXNlU3RhdGUgfSBmcm9tICdyZWFjdCc7XHJcbmltcG9ydCB7XHJcbiAgICBBdmF0YXIsXHJcbiAgICBDaGlwU2V0LCBDaGlwXHJcbn0gZnJvbSAnbWRjLXJlYWN0JztcclxuXHJcbmltcG9ydCBEZW1vIGZyb20gJ0AvY29tcG9uZW50cy9EZW1vJztcclxuaW1wb3J0IFBhZ2UgZnJvbSAnQC9jb21wb25lbnRzL1BhZ2UnO1xyXG5cclxuY29uc3QgaWQgPSAnY2hpcHMnO1xyXG5jb25zdCB0aXRsZSA9ICdDaGlwcyc7XHJcbmNvbnN0IGRlc2NyaXB0aW9uID0gJ0NoaXBzIGFyZSBjb21wYWN0IGVsZW1lbnRzIHRoYXQgYWxsb3cgdXNlcnMgdG8gZW50ZXIgaW5mb3JtYXRpb24sIHNlbGVjdCBhIGNob2ljZSwgZmlsdGVyIGNvbnRlbnQsIG9yIHRyaWdnZXIgYW4gYWN0aW9uLic7XHJcbmNvbnN0IGxpbmtzID0ge1xyXG4gICAgZG9jczogJ2h0dHBzOi8vZ2l0aHViLmNvbS9tYXRlcmlhbC1jb21wb25lbnRzL21hdGVyaWFsLWNvbXBvbmVudHMtd2ViL3RyZWUvbWFzdGVyL3BhY2thZ2VzL21kYy1jaGlwcycsXHJcbiAgICBndWlkZTogJ2h0dHBzOi8vbWF0ZXJpYWwuaW8vY29tcG9uZW50cy9jaGlwcydcclxufTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIENoaXBzUGFnZSgpIHtcclxuICAgIGNvbnN0IFtjaG9pY2VDaGlwLCBzZXRDaG9pY2VDaGlwc10gPSB1c2VTdGF0ZSgnZm9vJyk7XHJcbiAgICBjb25zdCBbZmlsdGVyQ2hpcHMsIHNldEZpbHRlckNoaXBzXSA9IHVzZVN0YXRlKFsnZm9vJ10pO1xyXG5cclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgPFBhZ2UgaWQ9e2lkfSB0aXRsZT17dGl0bGV9IGRlc2NyaXB0aW9uPXtkZXNjcmlwdGlvbn0gbGlua3M9e2xpbmtzfT5cclxuICAgICAgICAgICAgPERlbW8gdGl0bGU9XCJCYXNpYyBjaGlwc1wiPlxyXG4gICAgICAgICAgICAgICAgPENoaXBTZXQ+XHJcbiAgICAgICAgICAgICAgICAgICAgPENoaXAgdGV4dD1cIkZvb1wiIC8+XHJcbiAgICAgICAgICAgICAgICAgICAgPENoaXAgdGV4dD1cIkJhclwiIC8+XHJcbiAgICAgICAgICAgICAgICAgICAgPENoaXAgdGV4dD1cIkJhelwiIC8+XHJcbiAgICAgICAgICAgICAgICA8L0NoaXBTZXQ+XHJcbiAgICAgICAgICAgIDwvRGVtbz5cclxuXHJcbiAgICAgICAgICAgIDxEZW1vIHRpdGxlPVwiQ2hpcHMgd2l0aCBpY29uc1wiPlxyXG4gICAgICAgICAgICAgICAgPENoaXBTZXQ+XHJcbiAgICAgICAgICAgICAgICAgICAgPENoaXAgdGV4dD1cIkZvb1wiIGljb249XCJzdGFyXCIgLz5cclxuICAgICAgICAgICAgICAgICAgICA8Q2hpcCB0ZXh0PVwiQmFyXCIgaWNvbj1cInN0YXJcIiAvPlxyXG4gICAgICAgICAgICAgICAgICAgIDxDaGlwIHRleHQ9XCJCYXpcIiBpY29uPVwic3RhclwiIC8+XHJcbiAgICAgICAgICAgICAgICA8L0NoaXBTZXQ+XHJcbiAgICAgICAgICAgIDwvRGVtbz5cclxuXHJcbiAgICAgICAgICAgIDxEZW1vIHRpdGxlPVwiQ2hpcHMgd2l0aCB0cmFpbGluZyBpY29uc1wiPlxyXG4gICAgICAgICAgICAgICAgPENoaXBTZXQ+XHJcbiAgICAgICAgICAgICAgICAgICAgPENoaXAgdGV4dD1cIkZvb1wiIHRyYWlsaW5nSWNvbj1cImRlbGV0ZVwiIC8+XHJcbiAgICAgICAgICAgICAgICAgICAgPENoaXAgdGV4dD1cIkJhclwiIHRyYWlsaW5nSWNvbj1cImRlbGV0ZVwiIC8+XHJcbiAgICAgICAgICAgICAgICAgICAgPENoaXAgdGV4dD1cIkJhelwiIHRyYWlsaW5nSWNvbj1cImRlbGV0ZVwiIC8+XHJcbiAgICAgICAgICAgICAgICA8L0NoaXBTZXQ+XHJcbiAgICAgICAgICAgIDwvRGVtbz5cclxuXHJcbiAgICAgICAgICAgIDxEZW1vIHRpdGxlPVwiQ2hpcHMgd2l0aCBhdmF0YXJzXCI+XHJcbiAgICAgICAgICAgICAgICA8Q2hpcFNldD5cclxuICAgICAgICAgICAgICAgICAgICA8Q2hpcCB0ZXh0PVwiRm9vXCIgYXZhdGFyPXs8QXZhdGFyIGltYWdlPVwiaHR0cHM6Ly9wbGFjZWltZy5jb20vMTI4LzEyOC9wZW9wbGVcIiBzbWFsbCAvPn0gLz5cclxuICAgICAgICAgICAgICAgICAgICA8Q2hpcCB0ZXh0PVwiQmFyXCIgYXZhdGFyPXs8QXZhdGFyIGltYWdlPVwiaHR0cHM6Ly9wbGFjZWltZy5jb20vMTI4LzEyOC9wZW9wbGVcIiBzbWFsbCAvPn0gLz5cclxuICAgICAgICAgICAgICAgICAgICA8Q2hpcCB0ZXh0PVwiQmF6XCIgYXZhdGFyPXs8QXZhdGFyIGltYWdlPVwiaHR0cHM6Ly9wbGFjZWltZy5jb20vMTI4LzEyOC9wZW9wbGVcIiBzbWFsbCAvPn0gLz5cclxuICAgICAgICAgICAgICAgIDwvQ2hpcFNldD5cclxuICAgICAgICAgICAgPC9EZW1vPlxyXG5cclxuICAgICAgICAgICAgPERlbW8gdGl0bGU9XCJDaG9pY2UgY2hpcHNcIj5cclxuICAgICAgICAgICAgICAgIDxDaGlwU2V0IHZhbHVlPXtjaG9pY2VDaGlwfSBvbkNoYW5nZT17dmFsdWUgPT4gc2V0Q2hvaWNlQ2hpcHModmFsdWUpfT5cclxuICAgICAgICAgICAgICAgICAgICA8Q2hpcCB2YWx1ZT1cImZvb1wiIHRleHQ9XCJGb29cIiAvPlxyXG4gICAgICAgICAgICAgICAgICAgIDxDaGlwIHZhbHVlPVwiYmFyXCIgdGV4dD1cIkJhclwiIC8+XHJcbiAgICAgICAgICAgICAgICAgICAgPENoaXAgdmFsdWU9XCJiYXpcIiB0ZXh0PVwiQmF6XCIgLz5cclxuICAgICAgICAgICAgICAgIDwvQ2hpcFNldD5cclxuICAgICAgICAgICAgPC9EZW1vPlxyXG5cclxuICAgICAgICAgICAgPERlbW8gdGl0bGU9XCJGaWx0ZXIgY2hpcHNcIj5cclxuICAgICAgICAgICAgICAgIDxDaGlwU2V0IHZhbHVlPXtmaWx0ZXJDaGlwc30gb25DaGFuZ2U9e3ZhbHVlID0+IHNldEZpbHRlckNoaXBzKHZhbHVlKX0+XHJcbiAgICAgICAgICAgICAgICAgICAgPENoaXAgdmFsdWU9XCJmb29cIiB0ZXh0PVwiRm9vXCIgLz5cclxuICAgICAgICAgICAgICAgICAgICA8Q2hpcCB2YWx1ZT1cImJhclwiIHRleHQ9XCJCYXJcIiAvPlxyXG4gICAgICAgICAgICAgICAgICAgIDxDaGlwIHZhbHVlPVwiYmF6XCIgdGV4dD1cIkJhelwiIC8+XHJcbiAgICAgICAgICAgICAgICA8L0NoaXBTZXQ+XHJcbiAgICAgICAgICAgIDwvRGVtbz5cclxuICAgICAgICA8L1BhZ2U+XHJcbiAgICApO1xyXG59IiwiaW1wb3J0IHsgdXNlU3RhdGUgfSBmcm9tICdyZWFjdCc7XHJcbmltcG9ydCB7XHJcbiAgICBCdXR0b24sXHJcbiAgICBDaXJjdWxhclByb2dyZXNzLFxyXG4gICAgU2VnbWVudGVkQnV0dG9uLFxyXG4gICAgRm9ybUZpZWxkLFxyXG4gICAgU3dpdGNoLFxyXG4gICAgVGV4dEZpZWxkXHJcbn0gZnJvbSAnbWRjLXJlYWN0JztcclxuXHJcbmltcG9ydCBEZW1vIGZyb20gJ0AvY29tcG9uZW50cy9EZW1vJztcclxuaW1wb3J0IEZpZWxkU2V0IGZyb20gJ0AvY29tcG9uZW50cy9GaWVsZFNldCc7XHJcbmltcG9ydCBQYWdlIGZyb20gJ0AvY29tcG9uZW50cy9QYWdlJztcclxuXHJcbmNvbnN0IGlkID0gJ2NpcmN1bGFyLXByb2dyZXNzJztcclxuY29uc3QgdGl0bGUgPSAnQ2lyY3VsYXIgUHJvZ3Jlc3MnO1xyXG5jb25zdCBkZXNjcmlwdGlvbiA9ICdDaXJjdWxhciBwcm9ncmVzcyBpbmRpY2F0b3JzIGRpc3BsYXkgcHJvZ3Jlc3MgYnkgYW5pbWF0aW5nIGFuIGluZGljYXRvciBhbG9uZyBhbiBpbnZpc2libGUgY2lyY3VsYXIgdHJhY2sgaW4gYSBjbG9ja3dpc2UgZGlyZWN0aW9uLic7XHJcbmNvbnN0IGxpbmtzID0ge1xyXG4gICAgZG9jczogJ2h0dHBzOi8vZ2l0aHViLmNvbS9tYXRlcmlhbC1jb21wb25lbnRzL21hdGVyaWFsLWNvbXBvbmVudHMtd2ViL3RyZWUvbWFzdGVyL3BhY2thZ2VzL21kYy1jaXJjdWxhci1wcm9ncmVzcycsXHJcbiAgICBndWlkZTogJ2h0dHBzOi8vbWF0ZXJpYWwuaW8vY29tcG9uZW50cy9wcm9ncmVzcy1pbmRpY2F0b3JzI2NpcmN1bGFyLXByb2dyZXNzLWluZGljYXRvcnMnXHJcbn07XHJcblxyXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBDaXJjdWxhclByb2dyZXNzUGFnZSgpIHtcclxuICAgIGNvbnN0IFt2YWx1ZSwgc2V0VmFsdWVdID0gdXNlU3RhdGUoNDIpO1xyXG4gICAgY29uc3QgW3NpemUsIHNldFNpemVdID0gdXNlU3RhdGUoJ21lZGl1bScpO1xyXG4gICAgY29uc3QgW2luZGV0ZXJtaW5hdGUsIHNldEluZGV0ZXJtaW5hdGVdID0gdXNlU3RhdGUoZmFsc2UpO1xyXG4gICAgY29uc3QgW2NvbG9yZnVsLCBzZXRDb2xvcmZ1bF0gPSB1c2VTdGF0ZShmYWxzZSk7XHJcbiAgICBjb25zdCBbY2xvc2VkLCBzZXRDbG9zZWRdID0gdXNlU3RhdGUoZmFsc2UpO1xyXG5cclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgPFBhZ2UgaWQ9e2lkfSB0aXRsZT17dGl0bGV9IGRlc2NyaXB0aW9uPXtkZXNjcmlwdGlvbn0gbGlua3M9e2xpbmtzfT5cclxuICAgICAgICAgICAgPERlbW9cclxuICAgICAgICAgICAgICAgIHNldHRpbmdzPXs8PlxyXG4gICAgICAgICAgICAgICAgICAgIDxUZXh0RmllbGRcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU9e3ZhbHVlfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBsYWJlbD1cIlZhbHVlXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgb3V0bGluZWRcclxuICAgICAgICAgICAgICAgICAgICAgICAgb25DaGFuZ2U9eyhfLCB2YWx1ZSkgPT4gc2V0VmFsdWUodmFsdWUpfVxyXG4gICAgICAgICAgICAgICAgICAgIC8+XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIDxGaWVsZFNldCBsZWdlbmQ9XCJTaXplXCI+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxTZWdtZW50ZWRCdXR0b25cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlZ21lbnRzPXtbXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeyB2YWx1ZTogJ3NtYWxsJywgbGFiZWw6ICdTbWFsbCcgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7IHZhbHVlOiAnbWVkaXVtJywgbGFiZWw6ICdNZWRpdW0nIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeyB2YWx1ZTogJ2xhcmdlJywgbGFiZWw6ICdMYXJnZScgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXX1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlPXtzaXplfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb25DaGFuZ2U9e3NldFNpemV9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8+XHJcbiAgICAgICAgICAgICAgICAgICAgPC9GaWVsZFNldD5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgPEZvcm1GaWVsZCBsYWJlbD1cIkluZGV0ZXJtaW5hdGVcIiBhbGlnbkVuZCBzcGFjZUJldHdlZW4+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxTd2l0Y2hcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdGVkPXtpbmRldGVybWluYXRlfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb25DaGFuZ2U9eygpID0+IHNldEluZGV0ZXJtaW5hdGUodiA9PiAhdil9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8+XHJcbiAgICAgICAgICAgICAgICAgICAgPC9Gb3JtRmllbGQ+XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIDxGb3JtRmllbGQgbGFiZWw9XCJDb2xvcmZ1bFwiIGFsaWduRW5kIHNwYWNlQmV0d2Vlbj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPFN3aXRjaFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0ZWQ9e2NvbG9yZnVsfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb25DaGFuZ2U9eygpID0+IHNldENvbG9yZnVsKHYgPT4gIXYpfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvPlxyXG4gICAgICAgICAgICAgICAgICAgIDwvRm9ybUZpZWxkPlxyXG5cclxuICAgICAgICAgICAgICAgICAgICA8Rm9ybUZpZWxkIGxhYmVsPVwiQ2xvc2VkXCIgYWxpZ25FbmQgc3BhY2VCZXR3ZWVuPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8U3dpdGNoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3RlZD17Y2xvc2VkfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb25DaGFuZ2U9eygpID0+IHNldENsb3NlZCh2ID0+ICF2KX1cclxuICAgICAgICAgICAgICAgICAgICAgICAgLz5cclxuICAgICAgICAgICAgICAgICAgICA8L0Zvcm1GaWVsZD5cclxuICAgICAgICAgICAgICAgIDwvPn1cclxuICAgICAgICAgICAgPlxyXG4gICAgICAgICAgICAgICAgPENpcmN1bGFyUHJvZ3Jlc3NcclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZT17aW5kZXRlcm1pbmF0ZSA/IHVuZGVmaW5lZCA6IHZhbHVlfVxyXG4gICAgICAgICAgICAgICAgICAgIHNpemU9e3NpemV9XHJcbiAgICAgICAgICAgICAgICAgICAgaW5kZXRlcm1pbmF0ZT17aW5kZXRlcm1pbmF0ZSB8fCB1bmRlZmluZWR9XHJcbiAgICAgICAgICAgICAgICAgICAgY29sb3JmdWw9e2NvbG9yZnVsIHx8IHVuZGVmaW5lZH1cclxuICAgICAgICAgICAgICAgICAgICBjbG9zZWQ9e2Nsb3NlZCB8fCB1bmRlZmluZWR9XHJcbiAgICAgICAgICAgICAgICAvPlxyXG4gICAgICAgICAgICA8L0RlbW8+XHJcbiAgICAgICAgPC9QYWdlPlxyXG4gICAgKTtcclxufSIsImltcG9ydCB7IHVzZUNhbGxiYWNrLCB1c2VTdGF0ZSB9IGZyb20gJ3JlYWN0JztcclxuaW1wb3J0IHsgRGF0YVRhYmxlIH0gZnJvbSAnbWRjLXJlYWN0JztcclxuXHJcbmltcG9ydCBEZW1vIGZyb20gJ0AvY29tcG9uZW50cy9EZW1vJztcclxuaW1wb3J0IFBhZ2UgZnJvbSAnQC9jb21wb25lbnRzL1BhZ2UnO1xyXG5cclxuY29uc3QgaWQgPSAnZGF0YS10YWJsZSc7XHJcbmNvbnN0IHRpdGxlID0gJ0RhdGEgVGFibGUnO1xyXG5jb25zdCBkZXNjcmlwdGlvbiA9ICdEYXRhIHRhYmxlcyBkaXNwbGF5IHNldHMgb2YgZGF0YSBhY3Jvc3Mgcm93cyBhbmQgY29sdW1ucy4nO1xyXG5jb25zdCBsaW5rcyA9IHtcclxuICAgIGRvY3M6ICdodHRwczovL2dpdGh1Yi5jb20vbWF0ZXJpYWwtY29tcG9uZW50cy9tYXRlcmlhbC1jb21wb25lbnRzLXdlYi90cmVlL21hc3Rlci9wYWNrYWdlcy9tZGMtZGF0YS10YWJsZScsXHJcbiAgICBndWlkZTogJ2h0dHBzOi8vbWF0ZXJpYWwuaW8vY29tcG9uZW50cy9kYXRhLXRhYmxlcydcclxufTtcclxuXHJcbmNvbnN0IHRhYmxlID0gW1xyXG4gICAgWydGcm96ZW4geW9ndXJ0JywgMjQsIDQuMCwgJ1N1cGVyIHRhc3R5J10sXHJcbiAgICBbJ0ljZSBjcmVhbSBzYW5kd2ljaCcsIDM3LCA0LjMzMzMzMzMzMzMzLCAnSSBsaWtlIGljZSBjcmVhbSBtb3JlJ10sXHJcbiAgICBbJ0VjbGFpcicsIDI0LCA2LjAsICdOZXcgZmlsaW5nIGZsYXZvciddXHJcbl07XHJcblxyXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBEYXRhVGFibGVQYWdlKCkge1xyXG4gICAgY29uc3QgW2RhdGEsIHNldERhdGFdID0gdXNlU3RhdGUodGFibGUpO1xyXG4gICAgY29uc3QgW3NvcnQsIHNldFNvcnRdID0gdXNlU3RhdGUoMCk7XHJcblxyXG4gICAgY29uc3QgaGFuZGxlU29ydCA9IHVzZUNhbGxiYWNrKCgpID0+IHtcclxuICAgICAgICBzZXRTb3J0KHNvcnQgPT4ge1xyXG4gICAgICAgICAgICBpZiAoc29ydCA9PT0gLTEpIHtcclxuICAgICAgICAgICAgICAgIHNldERhdGEoZGF0YSA9PiBkYXRhLnNsaWNlKCkuc29ydCgoYSwgYikgPT4gYVsxXSAtIGJbMV0pKTtcclxuICAgICAgICAgICAgICAgIHNldFNvcnQoMSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBzZXREYXRhKGRhdGEgPT4gZGF0YS5zbGljZSgpLnNvcnQoKGEsIGIpID0+IGJbMV0gLSBhWzFdKSk7XHJcbiAgICAgICAgICAgICAgICBzZXRTb3J0KC0xKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfSwgW10pO1xyXG5cclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgPFBhZ2UgaWQ9e2lkfSB0aXRsZT17dGl0bGV9IGRlc2NyaXB0aW9uPXtkZXNjcmlwdGlvbn0gbGlua3M9e2xpbmtzfT5cclxuICAgICAgICAgICAgPERlbW8gdGl0bGU9XCJTb3J0YWJsZSBkYXRhIHRhYmxlXCI+XHJcbiAgICAgICAgICAgICAgICA8RGF0YVRhYmxlPlxyXG4gICAgICAgICAgICAgICAgICAgIDxEYXRhVGFibGUuSGVhZGVyPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8RGF0YVRhYmxlLkhlYWRlclJvdz5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxEYXRhVGFibGUuSGVhZGVyQ2VsbD5EZXNzZXJ0PC9EYXRhVGFibGUuSGVhZGVyQ2VsbD5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxEYXRhVGFibGUuSGVhZGVyQ2VsbCBudW1lcmljIHNvcnQ9e3NvcnR9IG9uU29ydD17aGFuZGxlU29ydH0+Q2FyYnMgKGcpPC9EYXRhVGFibGUuSGVhZGVyQ2VsbD5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxEYXRhVGFibGUuSGVhZGVyQ2VsbCBudW1lcmljPlByb3RlaW4gKGcpPC9EYXRhVGFibGUuSGVhZGVyQ2VsbD5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxEYXRhVGFibGUuSGVhZGVyQ2VsbD5Db21tZW50czwvRGF0YVRhYmxlLkhlYWRlckNlbGw+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDwvRGF0YVRhYmxlLkhlYWRlclJvdz5cclxuICAgICAgICAgICAgICAgICAgICA8L0RhdGFUYWJsZS5IZWFkZXI+XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIDxEYXRhVGFibGUuQ29udGVudD5cclxuICAgICAgICAgICAgICAgICAgICAgICAge2RhdGEubWFwKChyb3csIGluZGV4KSA9PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPERhdGFUYWJsZS5Sb3cga2V5PXtpbmRleH0+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge3Jvdy5tYXAoKHZhbHVlLCBpbmRleCkgPT5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPERhdGFUYWJsZS5DZWxsIGtleT17aW5kZXh9IHNjb3BlPXtpbmRleCA9PT0gMCA/ICdyb3cnIDogdW5kZWZpbmVkfSBudW1lcmljPXt0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInIHx8IHVuZGVmaW5lZH0+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7dmFsdWV9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvRGF0YVRhYmxlLkNlbGw+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKX1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvRGF0YVRhYmxlLlJvdz5cclxuICAgICAgICAgICAgICAgICAgICAgICAgKX1cclxuICAgICAgICAgICAgICAgICAgICA8L0RhdGFUYWJsZS5Db250ZW50PlxyXG4gICAgICAgICAgICAgICAgPC9EYXRhVGFibGU+XHJcbiAgICAgICAgICAgIDwvRGVtbz5cclxuICAgICAgICA8L1BhZ2U+XHJcbiAgICApO1xyXG59IiwiaW1wb3J0IHsgdXNlU3RhdGUgfSBmcm9tICdyZWFjdCc7XHJcbmltcG9ydCB7XHJcbiAgICBCdXR0b24sXHJcbiAgICBEaWFsb2dcclxufSBmcm9tICdtZGMtcmVhY3QnO1xyXG5cclxuaW1wb3J0IERlbW8gZnJvbSAnQC9jb21wb25lbnRzL0RlbW8nO1xyXG5pbXBvcnQgUGFnZSBmcm9tICdAL2NvbXBvbmVudHMvUGFnZSc7XHJcblxyXG5jb25zdCBpZCA9ICdkaWFsb2cnO1xyXG5jb25zdCB0aXRsZSA9ICdEaWFsb2cnO1xyXG5jb25zdCBkZXNjcmlwdGlvbiA9ICdEaWFsb2dzIGluZm9ybSB1c2VycyBhYm91dCBhIHNwZWNpZmljIHRhc2sgYW5kIG1heSBjb250YWluIGNyaXRpY2FsIGluZm9ybWF0aW9uLCByZXF1aXJlIGRlY2lzaW9ucywgb3IgaW52b2x2ZSBtdWx0aXBsZSB0YXNrcy4nO1xyXG5jb25zdCBsaW5rcyA9IHtcclxuICAgIGRvY3M6ICdodHRwczovL2dpdGh1Yi5jb20vbWF0ZXJpYWwtY29tcG9uZW50cy9tYXRlcmlhbC1jb21wb25lbnRzLXdlYi90cmVlL21hc3Rlci9wYWNrYWdlcy9tZGMtZGlhbG9nJyxcclxuICAgIGd1aWRlOiAnaHR0cHM6Ly9tYXRlcmlhbC5pby9jb21wb25lbnRzL2RpYWxvZ3MnXHJcbn07XHJcblxyXG5jb25zdCBzY3JvbGxhYmxlQ29udGVudCA9IGBcclxuICAgIExvcmVtIGlwc3VtIGRvbG9yIHNpdCBhbWV0IGNvbnNlY3RldHVyIGFkaXBpc2ljaW5nIGVsaXQuIFN1bnQgZWFydW0gcXVpYnVzZGFtIGRvbG9yIGhpYyBhY2N1c2FtdXMsIGRlc2VydW50IGxpYmVybz8gRGVsZW5pdGkgcmF0aW9uZSBsaWJlcm8sIGV2ZW5pZXQgbmVxdWUgYWxpcXVhbSByZXBlbGxhdCBkaWN0YSBvYmNhZWNhdGkgYXRxdWUsIHNlcXVpIHZvbHVwdGF0ZW0gZXhwbGljYWJvIGJlYXRhZSFcclxuXHJcbiAgICBMb3JlbSBpcHN1bSBkb2xvciBzaXQgYW1ldCBjb25zZWN0ZXR1ciBhZGlwaXNpY2luZyBlbGl0LiBWZXJpdGF0aXMgYW5pbWkgdmVsIGN1cGlkaXRhdGUgZXZlbmlldD8gTGF1ZGFudGl1bSByZWN1c2FuZGFlIGlsbG8gbWludXMgc2FlcGUgaXRhcXVlIGRvbG9yZXMgZnVnaWF0LCBwZXJmZXJlbmRpcyBub3N0cnVtISBBc3N1bWVuZGEgZnVnaWF0IGZ1Z2EgZGVzZXJ1bnQgb21uaXMgb2RpdCBkaWN0YSFcclxuXHJcbiAgICBMb3JlbSBpcHN1bSBkb2xvciBzaXQgYW1ldCBjb25zZWN0ZXR1ciBhZGlwaXNpY2luZyBlbGl0LiBNaW51cyBhY2N1c2FudGl1bSBhIHF1aXNxdWFtIGluIHJlcHVkaWFuZGFlIGV0IHVsbGFtIGN1bSBkaWduaXNzaW1vcyBleGVyY2l0YXRpb25lbSwgYmxhbmRpdGlpcyBwZXJzcGljaWF0aXMgYWxpYXMgaGljIHZlbCwgbGF1ZGFudGl1bSBhbGlxdWFtIG9tbmlzIHJlY3VzYW5kYWUgbmVtbyBhbmltaS5cclxuXHJcbiAgICBMb3JlbSBpcHN1bSBkb2xvciBzaXQgYW1ldCBjb25zZWN0ZXR1ciBhZGlwaXNpY2luZyBlbGl0LiBTdW50IGVhcnVtIHF1aWJ1c2RhbSBkb2xvciBoaWMgYWNjdXNhbXVzLCBkZXNlcnVudCBsaWJlcm8/IERlbGVuaXRpIHJhdGlvbmUgbGliZXJvLCBldmVuaWV0IG5lcXVlIGFsaXF1YW0gcmVwZWxsYXQgZGljdGEgb2JjYWVjYXRpIGF0cXVlLCBzZXF1aSB2b2x1cHRhdGVtIGV4cGxpY2FibyBiZWF0YWUhXHJcblxyXG4gICAgTG9yZW0gaXBzdW0gZG9sb3Igc2l0IGFtZXQgY29uc2VjdGV0dXIgYWRpcGlzaWNpbmcgZWxpdC4gVmVyaXRhdGlzIGFuaW1pIHZlbCBjdXBpZGl0YXRlIGV2ZW5pZXQ/IExhdWRhbnRpdW0gcmVjdXNhbmRhZSBpbGxvIG1pbnVzIHNhZXBlIGl0YXF1ZSBkb2xvcmVzIGZ1Z2lhdCwgcGVyZmVyZW5kaXMgbm9zdHJ1bSEgQXNzdW1lbmRhIGZ1Z2lhdCBmdWdhIGRlc2VydW50IG9tbmlzIG9kaXQgZGljdGEhXHJcblxyXG4gICAgTG9yZW0gaXBzdW0gZG9sb3Igc2l0IGFtZXQgY29uc2VjdGV0dXIgYWRpcGlzaWNpbmcgZWxpdC4gTWludXMgYWNjdXNhbnRpdW0gYSBxdWlzcXVhbSBpbiByZXB1ZGlhbmRhZSBldCB1bGxhbSBjdW0gZGlnbmlzc2ltb3MgZXhlcmNpdGF0aW9uZW0sIGJsYW5kaXRpaXMgcGVyc3BpY2lhdGlzIGFsaWFzIGhpYyB2ZWwsIGxhdWRhbnRpdW0gYWxpcXVhbSBvbW5pcyByZWN1c2FuZGFlIG5lbW8gYW5pbWkuXHJcblxyXG4gICAgTG9yZW0gaXBzdW0gZG9sb3Igc2l0IGFtZXQgY29uc2VjdGV0dXIgYWRpcGlzaWNpbmcgZWxpdC4gU3VudCBlYXJ1bSBxdWlidXNkYW0gZG9sb3IgaGljIGFjY3VzYW11cywgZGVzZXJ1bnQgbGliZXJvPyBEZWxlbml0aSByYXRpb25lIGxpYmVybywgZXZlbmlldCBuZXF1ZSBhbGlxdWFtIHJlcGVsbGF0IGRpY3RhIG9iY2FlY2F0aSBhdHF1ZSwgc2VxdWkgdm9sdXB0YXRlbSBleHBsaWNhYm8gYmVhdGFlIVxyXG5cclxuICAgIExvcmVtIGlwc3VtIGRvbG9yIHNpdCBhbWV0IGNvbnNlY3RldHVyIGFkaXBpc2ljaW5nIGVsaXQuIFZlcml0YXRpcyBhbmltaSB2ZWwgY3VwaWRpdGF0ZSBldmVuaWV0PyBMYXVkYW50aXVtIHJlY3VzYW5kYWUgaWxsbyBtaW51cyBzYWVwZSBpdGFxdWUgZG9sb3JlcyBmdWdpYXQsIHBlcmZlcmVuZGlzIG5vc3RydW0hIEFzc3VtZW5kYSBmdWdpYXQgZnVnYSBkZXNlcnVudCBvbW5pcyBvZGl0IGRpY3RhIVxyXG5cclxuICAgIExvcmVtIGlwc3VtIGRvbG9yIHNpdCBhbWV0IGNvbnNlY3RldHVyIGFkaXBpc2ljaW5nIGVsaXQuIE1pbnVzIGFjY3VzYW50aXVtIGEgcXVpc3F1YW0gaW4gcmVwdWRpYW5kYWUgZXQgdWxsYW0gY3VtIGRpZ25pc3NpbW9zIGV4ZXJjaXRhdGlvbmVtLCBibGFuZGl0aWlzIHBlcnNwaWNpYXRpcyBhbGlhcyBoaWMgdmVsLCBsYXVkYW50aXVtIGFsaXF1YW0gb21uaXMgcmVjdXNhbmRhZSBuZW1vIGFuaW1pLlxyXG5cclxuICAgIExvcmVtIGlwc3VtIGRvbG9yIHNpdCBhbWV0IGNvbnNlY3RldHVyIGFkaXBpc2ljaW5nIGVsaXQuIFN1bnQgZWFydW0gcXVpYnVzZGFtIGRvbG9yIGhpYyBhY2N1c2FtdXMsIGRlc2VydW50IGxpYmVybz8gRGVsZW5pdGkgcmF0aW9uZSBsaWJlcm8sIGV2ZW5pZXQgbmVxdWUgYWxpcXVhbSByZXBlbGxhdCBkaWN0YSBvYmNhZWNhdGkgYXRxdWUsIHNlcXVpIHZvbHVwdGF0ZW0gZXhwbGljYWJvIGJlYXRhZSFcclxuXHJcbiAgICBMb3JlbSBpcHN1bSBkb2xvciBzaXQgYW1ldCBjb25zZWN0ZXR1ciBhZGlwaXNpY2luZyBlbGl0LiBWZXJpdGF0aXMgYW5pbWkgdmVsIGN1cGlkaXRhdGUgZXZlbmlldD8gTGF1ZGFudGl1bSByZWN1c2FuZGFlIGlsbG8gbWludXMgc2FlcGUgaXRhcXVlIGRvbG9yZXMgZnVnaWF0LCBwZXJmZXJlbmRpcyBub3N0cnVtISBBc3N1bWVuZGEgZnVnaWF0IGZ1Z2EgZGVzZXJ1bnQgb21uaXMgb2RpdCBkaWN0YSFcclxuXHJcbiAgICBMb3JlbSBpcHN1bSBkb2xvciBzaXQgYW1ldCBjb25zZWN0ZXR1ciBhZGlwaXNpY2luZyBlbGl0LiBNaW51cyBhY2N1c2FudGl1bSBhIHF1aXNxdWFtIGluIHJlcHVkaWFuZGFlIGV0IHVsbGFtIGN1bSBkaWduaXNzaW1vcyBleGVyY2l0YXRpb25lbSwgYmxhbmRpdGlpcyBwZXJzcGljaWF0aXMgYWxpYXMgaGljIHZlbCwgbGF1ZGFudGl1bSBhbGlxdWFtIG9tbmlzIHJlY3VzYW5kYWUgbmVtbyBhbmltaS5cclxuXHJcbiAgICBMb3JlbSBpcHN1bSBkb2xvciBzaXQgYW1ldCBjb25zZWN0ZXR1ciBhZGlwaXNpY2luZyBlbGl0LiBTdW50IGVhcnVtIHF1aWJ1c2RhbSBkb2xvciBoaWMgYWNjdXNhbXVzLCBkZXNlcnVudCBsaWJlcm8/IERlbGVuaXRpIHJhdGlvbmUgbGliZXJvLCBldmVuaWV0IG5lcXVlIGFsaXF1YW0gcmVwZWxsYXQgZGljdGEgb2JjYWVjYXRpIGF0cXVlLCBzZXF1aSB2b2x1cHRhdGVtIGV4cGxpY2FibyBiZWF0YWUhXHJcblxyXG4gICAgTG9yZW0gaXBzdW0gZG9sb3Igc2l0IGFtZXQgY29uc2VjdGV0dXIgYWRpcGlzaWNpbmcgZWxpdC4gVmVyaXRhdGlzIGFuaW1pIHZlbCBjdXBpZGl0YXRlIGV2ZW5pZXQ/IExhdWRhbnRpdW0gcmVjdXNhbmRhZSBpbGxvIG1pbnVzIHNhZXBlIGl0YXF1ZSBkb2xvcmVzIGZ1Z2lhdCwgcGVyZmVyZW5kaXMgbm9zdHJ1bSEgQXNzdW1lbmRhIGZ1Z2lhdCBmdWdhIGRlc2VydW50IG9tbmlzIG9kaXQgZGljdGEhXHJcblxyXG4gICAgTG9yZW0gaXBzdW0gZG9sb3Igc2l0IGFtZXQgY29uc2VjdGV0dXIgYWRpcGlzaWNpbmcgZWxpdC4gTWludXMgYWNjdXNhbnRpdW0gYSBxdWlzcXVhbSBpbiByZXB1ZGlhbmRhZSBldCB1bGxhbSBjdW0gZGlnbmlzc2ltb3MgZXhlcmNpdGF0aW9uZW0sIGJsYW5kaXRpaXMgcGVyc3BpY2lhdGlzIGFsaWFzIGhpYyB2ZWwsIGxhdWRhbnRpdW0gYWxpcXVhbSBvbW5pcyByZWN1c2FuZGFlIG5lbW8gYW5pbWkuXHJcblxyXG4gICAgTG9yZW0gaXBzdW0gZG9sb3Igc2l0IGFtZXQgY29uc2VjdGV0dXIgYWRpcGlzaWNpbmcgZWxpdC4gU3VudCBlYXJ1bSBxdWlidXNkYW0gZG9sb3IgaGljIGFjY3VzYW11cywgZGVzZXJ1bnQgbGliZXJvPyBEZWxlbml0aSByYXRpb25lIGxpYmVybywgZXZlbmlldCBuZXF1ZSBhbGlxdWFtIHJlcGVsbGF0IGRpY3RhIG9iY2FlY2F0aSBhdHF1ZSwgc2VxdWkgdm9sdXB0YXRlbSBleHBsaWNhYm8gYmVhdGFlIVxyXG5cclxuICAgIExvcmVtIGlwc3VtIGRvbG9yIHNpdCBhbWV0IGNvbnNlY3RldHVyIGFkaXBpc2ljaW5nIGVsaXQuIFZlcml0YXRpcyBhbmltaSB2ZWwgY3VwaWRpdGF0ZSBldmVuaWV0PyBMYXVkYW50aXVtIHJlY3VzYW5kYWUgaWxsbyBtaW51cyBzYWVwZSBpdGFxdWUgZG9sb3JlcyBmdWdpYXQsIHBlcmZlcmVuZGlzIG5vc3RydW0hIEFzc3VtZW5kYSBmdWdpYXQgZnVnYSBkZXNlcnVudCBvbW5pcyBvZGl0IGRpY3RhIVxyXG5cclxuICAgIExvcmVtIGlwc3VtIGRvbG9yIHNpdCBhbWV0IGNvbnNlY3RldHVyIGFkaXBpc2ljaW5nIGVsaXQuIE1pbnVzIGFjY3VzYW50aXVtIGEgcXVpc3F1YW0gaW4gcmVwdWRpYW5kYWUgZXQgdWxsYW0gY3VtIGRpZ25pc3NpbW9zIGV4ZXJjaXRhdGlvbmVtLCBibGFuZGl0aWlzIHBlcnNwaWNpYXRpcyBhbGlhcyBoaWMgdmVsLCBsYXVkYW50aXVtIGFsaXF1YW0gb21uaXMgcmVjdXNhbmRhZSBuZW1vIGFuaW1pLlxyXG5gO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gRGlhbG9nUGFnZSgpIHtcclxuICAgIGNvbnN0IFtpc0Jhc2ljT3Blbiwgc2V0QmFzaWNPcGVuXSA9IHVzZVN0YXRlKGZhbHNlKTtcclxuICAgIGNvbnN0IFtpc0NvbmZpcm1hdGlvbk9wZW4sIHNldENvbmZpcm1hdGlvbk9wZW5dID0gdXNlU3RhdGUoZmFsc2UpO1xyXG4gICAgY29uc3QgW2lzU3RhY2tpbmdPcGVuLCBzZXRTdGFja2luZ09wZW5dID0gdXNlU3RhdGUoZmFsc2UpO1xyXG4gICAgY29uc3QgW2lzU2Nyb2xsYWJsZU9wZW4sIHNldFNjcm9sbGFibGVPcGVuXSA9IHVzZVN0YXRlKGZhbHNlKTtcclxuICAgIGNvbnN0IFtpc0Z1bGxzY3JlZW5PcGVuLCBzZXRGdWxsc2NyZWVuT3Blbl0gPSB1c2VTdGF0ZShmYWxzZSk7XHJcblxyXG4gICAgcmV0dXJuIChcclxuICAgICAgICA8UGFnZSBpZD17aWR9IHRpdGxlPXt0aXRsZX0gZGVzY3JpcHRpb249e2Rlc2NyaXB0aW9ufSBsaW5rcz17bGlua3N9PlxyXG4gICAgICAgICAgICA8RGVtb1xyXG4gICAgICAgICAgICAgICAgdGl0bGU9XCJCYXNpYyBkaWFsb2dcIlxyXG4gICAgICAgICAgICAgICAgc2V0dXA9e1xyXG4gICAgICAgICAgICAgICAgICAgIDxCdXR0b24gb25DbGljaz17KCkgPT4gc2V0QmFzaWNPcGVuKHYgPT4gIXYpfT5PcGVuPC9CdXR0b24+XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgID5cclxuICAgICAgICAgICAgICAgIDxEaWFsb2dcclxuICAgICAgICAgICAgICAgICAgICB0aXRsZT1cIlRpdGxlXCJcclxuICAgICAgICAgICAgICAgICAgICBjb250ZW50PVwiQ29udGVudFwiXHJcbiAgICAgICAgICAgICAgICAgICAgb3Blbj17aXNCYXNpY09wZW59XHJcbiAgICAgICAgICAgICAgICAgICAgb25DbG9zZT17KCkgPT4gc2V0QmFzaWNPcGVuKHYgPT4gIXYpfVxyXG4gICAgICAgICAgICAgICAgLz5cclxuICAgICAgICAgICAgPC9EZW1vPlxyXG5cclxuICAgICAgICAgICAgPERlbW9cclxuICAgICAgICAgICAgICAgIHRpdGxlPVwiQ29uZmlybWF0aW9uIGRpYWxvZ1wiXHJcbiAgICAgICAgICAgICAgICBzZXR1cD17XHJcbiAgICAgICAgICAgICAgICAgICAgPEJ1dHRvbiBvbkNsaWNrPXsoKSA9PiBzZXRDb25maXJtYXRpb25PcGVuKHYgPT4gIXYpfT5PcGVuPC9CdXR0b24+XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgID5cclxuICAgICAgICAgICAgICAgIDxEaWFsb2dcclxuICAgICAgICAgICAgICAgICAgICB0aXRsZT1cIlRpdGxlXCJcclxuICAgICAgICAgICAgICAgICAgICBjb250ZW50PVwiQXJlIHlvdSBzdXJlP1wiXHJcbiAgICAgICAgICAgICAgICAgICAgb3Blbj17aXNDb25maXJtYXRpb25PcGVufVxyXG4gICAgICAgICAgICAgICAgICAgIHBlcnNpc3RlbnRcclxuICAgICAgICAgICAgICAgICAgICBhY3Rpb25zPXtbXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxCdXR0b24ga2V5PVwiY2xvc2VcIiBvbkNsaWNrPXsoKSA9PiBzZXRDb25maXJtYXRpb25PcGVuKHYgPT4gIXYpfT5DbG9zZTwvQnV0dG9uPixcclxuICAgICAgICAgICAgICAgICAgICAgICAgPEJ1dHRvbiBrZXk9XCJjb25maXJtXCI+Q29uZmlybTwvQnV0dG9uPlxyXG4gICAgICAgICAgICAgICAgICAgIF19XHJcbiAgICAgICAgICAgICAgICAgICAgb25DbG9zZT17KCkgPT4gc2V0Q29uZmlybWF0aW9uT3Blbih2ID0+ICF2KX1cclxuICAgICAgICAgICAgICAgIC8+XHJcbiAgICAgICAgICAgIDwvRGVtbz5cclxuXHJcbiAgICAgICAgICAgIDxEZW1vXHJcbiAgICAgICAgICAgICAgICB0aXRsZT1cIkRpYWxvZyB3aXRoIHN0YWNraW5nIGJ1dHRvbnNcIlxyXG4gICAgICAgICAgICAgICAgc2V0dXA9e1xyXG4gICAgICAgICAgICAgICAgICAgIDxCdXR0b24gb25DbGljaz17KCkgPT4gc2V0U3RhY2tpbmdPcGVuKHYgPT4gIXYpfT5PcGVuPC9CdXR0b24+XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgID5cclxuICAgICAgICAgICAgICAgIDxEaWFsb2dcclxuICAgICAgICAgICAgICAgICAgICB0aXRsZT1cIlRpdGxlXCJcclxuICAgICAgICAgICAgICAgICAgICBjb250ZW50PVwiQ29udGVudFwiXHJcbiAgICAgICAgICAgICAgICAgICAgb3Blbj17aXNTdGFja2luZ09wZW59XHJcbiAgICAgICAgICAgICAgICAgICAgYXV0b1N0YWNrQnV0dG9uc1xyXG4gICAgICAgICAgICAgICAgICAgIGFjdGlvbnM9e1tcclxuICAgICAgICAgICAgICAgICAgICAgICAgPEJ1dHRvbiBrZXk9XCJjbG9zZVwiIG9uQ2xpY2s9eygpID0+IHNldFN0YWNraW5nT3Blbih2ID0+ICF2KX0+QSB2ZXJ5IHZlcnkgdmVyeSB2ZXJ5IHZlcnkgbG9uZyBidXR0b248L0J1dHRvbj4sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxCdXR0b24ga2V5PVwiY29uZmlybVwiPkEgdmVyeSB2ZXJ5IHZlcnkgdmVyeSB2ZXJ5IGxvbmcgYnV0dG9uPC9CdXR0b24+XHJcbiAgICAgICAgICAgICAgICAgICAgXX1cclxuICAgICAgICAgICAgICAgICAgICBvbkNsb3NlPXsoKSA9PiBzZXRTdGFja2luZ09wZW4odiA9PiAhdil9XHJcbiAgICAgICAgICAgICAgICAvPlxyXG4gICAgICAgICAgICA8L0RlbW8+XHJcblxyXG4gICAgICAgICAgICA8RGVtb1xyXG4gICAgICAgICAgICAgICAgdGl0bGU9XCJTY3JvbGxhYmxlIGRpYWxvZ1wiXHJcbiAgICAgICAgICAgICAgICBzZXR1cD17XHJcbiAgICAgICAgICAgICAgICAgICAgPEJ1dHRvbiBvbkNsaWNrPXsoKSA9PiBzZXRTY3JvbGxhYmxlT3Blbih2ID0+ICF2KX0+T3BlbjwvQnV0dG9uPlxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICA+XHJcbiAgICAgICAgICAgICAgICA8RGlhbG9nXHJcbiAgICAgICAgICAgICAgICAgICAgdGl0bGU9XCJUaXRsZVwiXHJcbiAgICAgICAgICAgICAgICAgICAgb3Blbj17aXNTY3JvbGxhYmxlT3Blbn1cclxuICAgICAgICAgICAgICAgICAgICBhY3Rpb25zPXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgPEJ1dHRvbiBvbkNsaWNrPXsoKSA9PiBzZXRTY3JvbGxhYmxlT3Blbih2ID0+ICF2KX0+Q2xvc2U8L0J1dHRvbj5cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgb25DbG9zZT17KCkgPT4gc2V0U2Nyb2xsYWJsZU9wZW4odiA9PiAhdil9XHJcbiAgICAgICAgICAgICAgICA+XHJcbiAgICAgICAgICAgICAgICAgICAge3Njcm9sbGFibGVDb250ZW50fVxyXG4gICAgICAgICAgICAgICAgPC9EaWFsb2c+XHJcbiAgICAgICAgICAgIDwvRGVtbz5cclxuXHJcbiAgICAgICAgICAgIDxEZW1vXHJcbiAgICAgICAgICAgICAgICB0aXRsZT1cIkZ1bGxzY3JlZW4gZGlhbG9nXCJcclxuICAgICAgICAgICAgICAgIHNldHVwPXtcclxuICAgICAgICAgICAgICAgICAgICA8QnV0dG9uIG9uQ2xpY2s9eygpID0+IHNldEZ1bGxzY3JlZW5PcGVuKHYgPT4gIXYpfT5PcGVuPC9CdXR0b24+XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgID5cclxuICAgICAgICAgICAgICAgIDxEaWFsb2dcclxuICAgICAgICAgICAgICAgICAgICB0aXRsZT1cIkZ1bGxzY3JlZW4gRGlhbG9nXCJcclxuICAgICAgICAgICAgICAgICAgICBvcGVuPXtpc0Z1bGxzY3JlZW5PcGVufVxyXG4gICAgICAgICAgICAgICAgICAgIGZ1bGxzY3JlZW5cclxuICAgICAgICAgICAgICAgICAgICBhY3Rpb25zPXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgPEJ1dHRvbiBvbkNsaWNrPXsoKSA9PiBzZXRGdWxsc2NyZWVuT3Blbih2ID0+ICF2KX0+Q2xvc2U8L0J1dHRvbj5cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgb25DbG9zZT17KCkgPT4gc2V0RnVsbHNjcmVlbk9wZW4odiA9PiAhdil9XHJcbiAgICAgICAgICAgICAgICA+XHJcbiAgICAgICAgICAgICAgICAgICAge3Njcm9sbGFibGVDb250ZW50fVxyXG4gICAgICAgICAgICAgICAgPC9EaWFsb2c+XHJcbiAgICAgICAgICAgIDwvRGVtbz5cclxuICAgICAgICA8L1BhZ2U+XHJcbiAgICApO1xyXG59IiwiaW1wb3J0IHsgVHlwb2dyYXBoeSB9IGZyb20gJ21kYy1yZWFjdCc7XHJcbmltcG9ydCBjbGFzc25hbWVzIGZyb20gJ2NsYXNzbmFtZXMnO1xyXG5cclxuaW1wb3J0ICcuL2luZGV4LnNjc3MnO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gU2VjdGlvbih7IHRpdGxlLCBjaGlsZHJlbiwgY2xhc3NOYW1lLCAuLi5wcm9wcyB9KSB7XHJcbiAgICBjb25zdCBjbGFzc05hbWVzID0gY2xhc3NuYW1lcygnc2VjdGlvbicsIGNsYXNzTmFtZSk7XHJcblxyXG4gICAgcmV0dXJuIChcclxuICAgICAgICA8c2VjdGlvbiBjbGFzc05hbWU9e2NsYXNzTmFtZXN9IHsuLi5wcm9wc30+XHJcbiAgICAgICAgICAgIHt0aXRsZSAmJlxyXG4gICAgICAgICAgICAgICAgPFR5cG9ncmFwaHkgY2xhc3NOYW1lPVwic2VjdGlvbi10aXRsZVwiIHR5cGU9XCJoZWFkbGluZTZcIj57dGl0bGV9PC9UeXBvZ3JhcGh5PlxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB7Y2hpbGRyZW59XHJcbiAgICAgICAgPC9zZWN0aW9uPlxyXG4gICAgKTtcclxufSIsImltcG9ydCB7IHVzZVN0YXRlIH0gZnJvbSAncmVhY3QnO1xyXG5pbXBvcnQgeyBCdXR0b24sIERyYXdlciB9IGZyb20gJ21kYy1yZWFjdCc7XHJcblxyXG5pbXBvcnQgUGFnZSBmcm9tICdAL2NvbXBvbmVudHMvUGFnZSc7XHJcbmltcG9ydCBTZWN0aW9uIGZyb20gJ0AvY29tcG9uZW50cy9TZWN0aW9uJztcclxuaW1wb3J0IENvZGUgZnJvbSAnQC9jb21wb25lbnRzL0NvZGUnO1xyXG5cclxuY29uc3QgaWQgPSAnZHJhd2VyJztcclxuY29uc3QgdGl0bGUgPSAnRHJhd2VyJztcclxuY29uc3QgZGVzY3JpcHRpb24gPSAnTmF2aWdhdGlvbiBkcmF3ZXJzIHByb3ZpZGUgYWNjZXNzIHRvIGRlc3RpbmF0aW9ucyBpbiB5b3VyIGFwcC4nO1xyXG5jb25zdCBsaW5rcyA9IHtcclxuICAgIGRvY3M6ICdodHRwczovL2dpdGh1Yi5jb20vbWF0ZXJpYWwtY29tcG9uZW50cy9tYXRlcmlhbC1jb21wb25lbnRzLXdlYi90cmVlL21hc3Rlci9wYWNrYWdlcy9tZGMtZHJhd2VyJyxcclxuICAgIGd1aWRlOiAnaHR0cHM6Ly9tYXRlcmlhbC5pby9jb21wb25lbnRzL25hdmlnYXRpb24tZHJhd2VyJ1xyXG59O1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gRHJhd2VyUGFnZSgpIHtcclxuICAgIGNvbnN0IFtpc0Rpc21pc3NpYmxlT3Blbiwgc2V0RGlzbWlzc2libGVPcGVuXSA9IHVzZVN0YXRlKGZhbHNlKTtcclxuICAgIGNvbnN0IFtpc01vZGFsT3Blbiwgc2V0TW9kYWxPcGVuXSA9IHVzZVN0YXRlKGZhbHNlKTtcclxuXHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAgIDxQYWdlIGlkPXtpZH0gdGl0bGU9e3RpdGxlfSBkZXNjcmlwdGlvbj17ZGVzY3JpcHRpb259IGxpbmtzPXtsaW5rc30+XHJcbiAgICAgICAgICAgIDxTZWN0aW9uIHRpdGxlPVwiUGVybWFuZW50IGRyYXdlclwiPlxyXG4gICAgICAgICAgICAgICAgPENvZGU+XHJcbiAgICAgICAgICAgICAgICAgICAgPERyYXdlcj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPERyYXdlci5IZWFkZXIgdGl0bGU9XCJUaXRsZVwiIC8+XHJcbiAgICAgICAgICAgICAgICAgICAgPC9EcmF3ZXI+XHJcbiAgICAgICAgICAgICAgICA8L0NvZGU+XHJcbiAgICAgICAgICAgIDwvU2VjdGlvbj5cclxuXHJcbiAgICAgICAgICAgIDxTZWN0aW9uIHRpdGxlPVwiRGlzbWlzc2libGUgZHJhd2VyXCI+XHJcbiAgICAgICAgICAgICAgICA8Q29kZVxyXG4gICAgICAgICAgICAgICAgICAgIHNldHVwPXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgPEJ1dHRvblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWw9XCJUb2dnbGVcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb25DbGljaz17KCkgPT4gc2V0RGlzbWlzc2libGVPcGVuKHYgPT4gIXYpfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvPlxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgID5cclxuICAgICAgICAgICAgICAgICAgICA8RHJhd2VyXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wZW49e2lzRGlzbWlzc2libGVPcGVufVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBkaXNtaXNzaWJsZVxyXG4gICAgICAgICAgICAgICAgICAgID5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPERyYXdlci5IZWFkZXIgdGl0bGU9XCJUaXRsZVwiIC8+XHJcbiAgICAgICAgICAgICAgICAgICAgPC9EcmF3ZXI+XHJcbiAgICAgICAgICAgICAgICA8L0NvZGU+XHJcbiAgICAgICAgICAgIDwvU2VjdGlvbj5cclxuXHJcbiAgICAgICAgICAgIDxTZWN0aW9uIHRpdGxlPVwiTW9kYWwgZHJhd2VyXCI+XHJcbiAgICAgICAgICAgICAgICA8Q29kZVxyXG4gICAgICAgICAgICAgICAgICAgIHNldHVwPXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgPEJ1dHRvblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWw9XCJUb2dnbGVcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb25DbGljaz17KCkgPT4gc2V0TW9kYWxPcGVuKHYgPT4gIXYpfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvPlxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgID5cclxuICAgICAgICAgICAgICAgICAgICA8RHJhd2VyXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wZW49e2lzTW9kYWxPcGVufVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBvbkNsb3NlPXsoKSA9PiBzZXRNb2RhbE9wZW4odiA9PiAhdil9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vZGFsXHJcbiAgICAgICAgICAgICAgICAgICAgPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8RHJhd2VyLkhlYWRlciB0aXRsZT1cIlRpdGxlXCIgLz5cclxuICAgICAgICAgICAgICAgICAgICA8L0RyYXdlcj5cclxuICAgICAgICAgICAgICAgIDwvQ29kZT5cclxuICAgICAgICAgICAgPC9TZWN0aW9uPlxyXG4gICAgICAgIDwvUGFnZT5cclxuICAgICk7XHJcbn0iLCJpbXBvcnQgeyBFbGV2YXRpb24sIFNsaWRlciB9IGZyb20gJ21kYy1yZWFjdCc7XHJcblxyXG5pbXBvcnQgUGFnZSBmcm9tICdAL2NvbXBvbmVudHMvUGFnZSc7XHJcbmltcG9ydCBTZWN0aW9uIGZyb20gJ0AvY29tcG9uZW50cy9TZWN0aW9uJztcclxuaW1wb3J0IENvZGUgZnJvbSAnQC9jb21wb25lbnRzL0NvZGUnO1xyXG5pbXBvcnQgeyB1c2VDYWxsYmFjaywgdXNlU3RhdGUgfSBmcm9tICdyZWFjdCc7XHJcblxyXG5pbXBvcnQgJy4vaW5kZXguc2Nzcyc7XHJcblxyXG5jb25zdCBpZCA9ICdlbGV2YXRpb24nO1xyXG5jb25zdCB0aXRsZSA9ICdFbGV2YXRpb24nO1xyXG5jb25zdCBkZXNjcmlwdGlvbiA9ICdFbGV2YXRpb24gaXMgdGhlIHJlbGF0aXZlIGRpc3RhbmNlIGJldHdlZW4gdHdvIHN1cmZhY2VzIGFsb25nIHRoZSB6LWF4aXMuJztcclxuY29uc3QgbGlua3MgPSB7XHJcbiAgICBkb2NzOiAnaHR0cHM6Ly9naXRodWIuY29tL21hdGVyaWFsLWNvbXBvbmVudHMvbWF0ZXJpYWwtY29tcG9uZW50cy13ZWIvdHJlZS9tYXN0ZXIvcGFja2FnZXMvbWRjLWVsZXZhdGlvbicsXHJcbiAgICBndWlkZTogJ2h0dHBzOi8vbWF0ZXJpYWwuaW8vZGVzaWduL2Vudmlyb25tZW50L2VsZXZhdGlvbidcclxufTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIEVsZXZhdGlvblBhZ2UoKSB7XHJcbiAgICBjb25zdCBbeiwgc2V0Wl0gPSB1c2VTdGF0ZSgwKTtcclxuXHJcbiAgICBjb25zdCBoYW5kbGVDaGFuZ2UgPSB1c2VDYWxsYmFjayh2YWx1ZSA9PiB7XHJcbiAgICAgICAgc2V0Wih2YWx1ZSk7XHJcbiAgICB9LCBbXSk7XHJcblxyXG4gICAgcmV0dXJuIChcclxuICAgICAgICA8UGFnZSBpZD17aWR9IHRpdGxlPXt0aXRsZX0gZGVzY3JpcHRpb249e2Rlc2NyaXB0aW9ufSBsaW5rcz17bGlua3N9PlxyXG4gICAgICAgICAgICA8U2VjdGlvbj5cclxuICAgICAgICAgICAgICAgIDxDb2RlXHJcbiAgICAgICAgICAgICAgICAgICAgc2V0dXA9e1xyXG4gICAgICAgICAgICAgICAgICAgICAgICA8U2xpZGVyXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZT17en1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1pbj1cIjBcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF4PVwiMjRcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RlcD1cIjFcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlzY3JldGVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpY2tNYXJrc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb25DaGFuZ2U9e2hhbmRsZUNoYW5nZX1cclxuICAgICAgICAgICAgICAgICAgICAgICAgLz5cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICA+XHJcbiAgICAgICAgICAgICAgICAgICAgPEVsZXZhdGlvbiB6PXt6fSAvPlxyXG4gICAgICAgICAgICAgICAgPC9Db2RlPlxyXG4gICAgICAgICAgICA8L1NlY3Rpb24+XHJcbiAgICAgICAgPC9QYWdlPlxyXG4gICAgKTtcclxufSIsImltcG9ydCB7IHVzZVN0YXRlIH0gZnJvbSAncmVhY3QnO1xyXG5pbXBvcnQgeyBCdXR0b24sIEZBQiB9IGZyb20gJ21kYy1yZWFjdCc7XHJcblxyXG5pbXBvcnQgUGFnZSBmcm9tICdAL2NvbXBvbmVudHMvUGFnZSc7XHJcbmltcG9ydCBTZWN0aW9uIGZyb20gJ0AvY29tcG9uZW50cy9TZWN0aW9uJztcclxuaW1wb3J0IENvZGUgZnJvbSAnQC9jb21wb25lbnRzL0NvZGUnO1xyXG5cclxuY29uc3QgaWQgPSAnZmFiJztcclxuY29uc3QgdGl0bGUgPSAnRkFCJztcclxuY29uc3QgZGVzY3JpcHRpb24gPSAnQSBmbG9hdGluZyBhY3Rpb24gYnV0dG9uIChGQUIpIHJlcHJlc2VudHMgdGhlIHByaW1hcnkgYWN0aW9uIG9mIGEgc2NyZWVuLic7XHJcbmNvbnN0IGxpbmtzID0ge1xyXG4gICAgZG9jczogJ2h0dHBzOi8vZ2l0aHViLmNvbS9tYXRlcmlhbC1jb21wb25lbnRzL21hdGVyaWFsLWNvbXBvbmVudHMtd2ViL3RyZWUvbWFzdGVyL3BhY2thZ2VzL21kYy1mYWInLFxyXG4gICAgZ3VpZGU6ICdodHRwczovL21hdGVyaWFsLmlvL2NvbXBvbmVudHMvYnV0dG9ucy1mbG9hdGluZy1hY3Rpb24tYnV0dG9uJ1xyXG59O1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gRkFCUGFnZSgpIHtcclxuICAgIGNvbnN0IFtpc0V4aXRlZCwgc2V0RXhpdGVkXSA9IHVzZVN0YXRlKGZhbHNlKTtcclxuXHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAgIDxQYWdlIGlkPXtpZH0gdGl0bGU9e3RpdGxlfSBkZXNjcmlwdGlvbj17ZGVzY3JpcHRpb259IGxpbmtzPXtsaW5rc30+XHJcbiAgICAgICAgICAgIDxTZWN0aW9uIHRpdGxlPVwiQmFzaWMgRkFCXCI+XHJcbiAgICAgICAgICAgICAgICA8Q29kZT5cclxuICAgICAgICAgICAgICAgICAgICA8RkFCXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGljb249XCJzdGFyXCJcclxuICAgICAgICAgICAgICAgICAgICAvPlxyXG4gICAgICAgICAgICAgICAgPC9Db2RlPlxyXG4gICAgICAgICAgICA8L1NlY3Rpb24+XHJcblxyXG4gICAgICAgICAgICA8U2VjdGlvbiB0aXRsZT1cIk1pbmkgRkFCXCI+XHJcbiAgICAgICAgICAgICAgICA8Q29kZT5cclxuICAgICAgICAgICAgICAgICAgICA8RkFCXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGljb249XCJzdGFyXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWluaVxyXG4gICAgICAgICAgICAgICAgICAgIC8+XHJcbiAgICAgICAgICAgICAgICA8L0NvZGU+XHJcbiAgICAgICAgICAgIDwvU2VjdGlvbj5cclxuXHJcbiAgICAgICAgICAgIDxTZWN0aW9uIHRpdGxlPVwiRXh0ZW5kZWQgRkFCXCI+XHJcbiAgICAgICAgICAgICAgICA8Q29kZT5cclxuICAgICAgICAgICAgICAgICAgICA8RkFCXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGljb249XCJzdGFyXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWw9XCJTdGFyXCJcclxuICAgICAgICAgICAgICAgICAgICAvPlxyXG4gICAgICAgICAgICAgICAgPC9Db2RlPlxyXG4gICAgICAgICAgICA8L1NlY3Rpb24+XHJcblxyXG4gICAgICAgICAgICA8U2VjdGlvbiB0aXRsZT1cIkV4dGVuZGVkIEZBQiB3aXRoIGEgdHJhaWxpbmcgaWNvblwiPlxyXG4gICAgICAgICAgICAgICAgPENvZGU+XHJcbiAgICAgICAgICAgICAgICAgICAgPEZBQlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBsYWJlbD1cIlN0YXJcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0cmFpbGluZ0ljb249XCJzdGFyXCJcclxuICAgICAgICAgICAgICAgICAgICAvPlxyXG4gICAgICAgICAgICAgICAgPC9Db2RlPlxyXG4gICAgICAgICAgICA8L1NlY3Rpb24+XHJcblxyXG4gICAgICAgICAgICA8U2VjdGlvbiB0aXRsZT1cIkFuaW1hdGVkIEZBQlwiPlxyXG4gICAgICAgICAgICAgICAgPENvZGVcclxuICAgICAgICAgICAgICAgICAgICBzZXR1cD17XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxCdXR0b25cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsPVwiVG9nZ2xlXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2xpY2s9eygpID0+IHNldEV4aXRlZCh2ID0+ICF2KX1cclxuICAgICAgICAgICAgICAgICAgICAgICAgLz5cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICA+XHJcbiAgICAgICAgICAgICAgICAgICAgPEZBQlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpY29uPVwic3RhclwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4aXRlZD17aXNFeGl0ZWR9XHJcbiAgICAgICAgICAgICAgICAgICAgLz5cclxuICAgICAgICAgICAgICAgIDwvQ29kZT5cclxuICAgICAgICAgICAgPC9TZWN0aW9uPlxyXG4gICAgICAgIDwvUGFnZT5cclxuICAgICk7XHJcbn0iLCJpbXBvcnQge1xyXG4gICAgQ2hlY2tib3gsXHJcbiAgICBGb3JtRmllbGRcclxufSBmcm9tICdtZGMtcmVhY3QnO1xyXG5cclxuaW1wb3J0IFBhZ2UgZnJvbSAnQC9jb21wb25lbnRzL1BhZ2UnO1xyXG5pbXBvcnQgU2VjdGlvbiBmcm9tICdAL2NvbXBvbmVudHMvU2VjdGlvbic7XHJcbmltcG9ydCBDb2RlIGZyb20gJ0AvY29tcG9uZW50cy9Db2RlJztcclxuXHJcbmltcG9ydCAnLi9pbmRleC5zY3NzJztcclxuXHJcbmNvbnN0IGlkID0gJ2Zvcm0tZmllbGQnO1xyXG5jb25zdCB0aXRsZSA9ICdGb3JtIEZpZWxkJztcclxuY29uc3QgZGVzY3JpcHRpb24gPSAnRm9ybSBGaWVsZCBhbGlnbnMgYSBmb3JtIGZpZWxkIChmb3IgZXhhbXBsZSwgYSBjaGVja2JveCkgd2l0aCBpdHMgbGFiZWwgYW5kIG1ha2VzIGl0IFJUTC1hd2FyZS4nO1xyXG5jb25zdCBsaW5rcyA9IHtcclxuICAgIGRvY3M6ICdodHRwczovL2dpdGh1Yi5jb20vbWF0ZXJpYWwtY29tcG9uZW50cy9tYXRlcmlhbC1jb21wb25lbnRzLXdlYi90cmVlL21hc3Rlci9wYWNrYWdlcy9tZGMtZm9ybS1maWVsZCdcclxufTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIEZvcm1GaWVsZFBhZ2UoKSB7XHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAgIDxQYWdlIGlkPXtpZH0gdGl0bGU9e3RpdGxlfSBkZXNjcmlwdGlvbj17ZGVzY3JpcHRpb259IGxpbmtzPXtsaW5rc30+XHJcbiAgICAgICAgICAgIDxTZWN0aW9uIHRpdGxlPVwiQmFzaWMgZm9ybSBmaWVsZFwiPlxyXG4gICAgICAgICAgICAgICAgPENvZGU+XHJcbiAgICAgICAgICAgICAgICAgICAgPEZvcm1GaWVsZCBsYWJlbD1cIkxhYmVsXCI+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxDaGVja2JveCAvPlxyXG4gICAgICAgICAgICAgICAgICAgIDwvRm9ybUZpZWxkPlxyXG4gICAgICAgICAgICAgICAgPC9Db2RlPlxyXG4gICAgICAgICAgICA8L1NlY3Rpb24+XHJcblxyXG4gICAgICAgICAgICA8U2VjdGlvbiB0aXRsZT1cIkZvcm0gZmllbGQgdGhhdCBnb2VzIGJlZm9yZSB0aGUgZWxlbWVudFwiPlxyXG4gICAgICAgICAgICAgICAgPENvZGU+XHJcbiAgICAgICAgICAgICAgICAgICAgPEZvcm1GaWVsZCBsYWJlbD1cIkxhYmVsXCIgYWxpZ25FbmQ+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxDaGVja2JveCAvPlxyXG4gICAgICAgICAgICAgICAgICAgIDwvRm9ybUZpZWxkPlxyXG4gICAgICAgICAgICAgICAgPC9Db2RlPlxyXG4gICAgICAgICAgICA8L1NlY3Rpb24+XHJcblxyXG4gICAgICAgICAgICA8U2VjdGlvbiB0aXRsZT1cIk5vIHdyYXAgZm9ybSBmaWVsZFwiPlxyXG4gICAgICAgICAgICAgICAgPENvZGU+XHJcbiAgICAgICAgICAgICAgICAgICAgPEZvcm1GaWVsZCBsYWJlbD1cIkxhYmVsXCIgbm93cmFwPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8Q2hlY2tib3ggLz5cclxuICAgICAgICAgICAgICAgICAgICA8L0Zvcm1GaWVsZD5cclxuICAgICAgICAgICAgICAgIDwvQ29kZT5cclxuICAgICAgICAgICAgPC9TZWN0aW9uPlxyXG5cclxuICAgICAgICAgICAgPFNlY3Rpb24gdGl0bGU9XCJGb3JtIGZpZWxkIHdpdGggc3BhY2UgYmV0d2VlblwiPlxyXG4gICAgICAgICAgICAgICAgPENvZGU+XHJcbiAgICAgICAgICAgICAgICAgICAgPEZvcm1GaWVsZCBsYWJlbD1cIkxhYmVsXCIgc3BhY2VCZXR3ZWVuPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8Q2hlY2tib3ggLz5cclxuICAgICAgICAgICAgICAgICAgICA8L0Zvcm1GaWVsZD5cclxuICAgICAgICAgICAgICAgIDwvQ29kZT5cclxuICAgICAgICAgICAgPC9TZWN0aW9uPlxyXG4gICAgICAgIDwvUGFnZT5cclxuICAgICk7XHJcbn0iLCJpbXBvcnQgbWFya2VkIGZyb20gJ21hcmtlZCc7XHJcblxyXG5pbXBvcnQgaGlnaGxpZ2h0IGZyb20gJy4vaGlnaGxpZ2h0JztcclxuXHJcbm1hcmtlZC5zZXRPcHRpb25zKHtcclxuICAgIGhpZ2hsaWdodCxcclxuICAgIGxhbmdQcmVmaXg6ICdobGpzIGxhbmd1YWdlLSdcclxufSk7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBtYXJrZWQ7IiwiaW1wb3J0IFBhZ2UgZnJvbSAnQC9jb21wb25lbnRzL1BhZ2UnO1xyXG5pbXBvcnQgbWFya2Rvd24gZnJvbSAnQC91dGlscy9tYXJrZG93bic7XHJcblxyXG5pbXBvcnQgcmVhZG1lIGZyb20gJy4uLy4uLy4uLy4uL1JFQURNRS5tZCc7XHJcblxyXG5pbXBvcnQgJy4vaW5kZXguc2Nzcyc7XHJcblxyXG5jb25zdCBodG1sID0gbWFya2Rvd24ocmVhZG1lKTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIEhvbWVQYWdlKCkge1xyXG4gICAgcmV0dXJuIChcclxuICAgICAgICA8UGFnZSBpZD1cImhvbWVcIj5cclxuICAgICAgICAgICAgPGFydGljbGVcclxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZT1cIm1hcmtkb3duXCJcclxuICAgICAgICAgICAgICAgIGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MPXt7IF9faHRtbDogaHRtbCB9fVxyXG4gICAgICAgICAgICAvPlxyXG4gICAgICAgIDwvUGFnZT5cclxuICAgICk7XHJcbn0iLCJpbXBvcnQgeyB1c2VTdGF0ZSB9IGZyb20gJ3JlYWN0JztcclxuaW1wb3J0IHtcclxuICAgIEljb25CdXR0b25cclxufSBmcm9tICdtZGMtcmVhY3QnO1xyXG5cclxuaW1wb3J0IFBhZ2UgZnJvbSAnQC9jb21wb25lbnRzL1BhZ2UnO1xyXG5pbXBvcnQgU2VjdGlvbiBmcm9tICdAL2NvbXBvbmVudHMvU2VjdGlvbic7XHJcbmltcG9ydCBDb2RlIGZyb20gJ0AvY29tcG9uZW50cy9Db2RlJztcclxuXHJcbmNvbnN0IGlkID0gJ2ljb24tYnV0dG9uJztcclxuY29uc3QgdGl0bGUgPSAnSWNvbiBCdXR0b24nO1xyXG5jb25zdCBkZXNjcmlwdGlvbiA9ICdJY29uIGJ1dHRvbnMgYWxsb3cgdXNlcnMgdG8gdGFrZSBhY3Rpb25zLCBhbmQgbWFrZSBjaG9pY2VzLCB3aXRoIGEgc2luZ2xlIHRhcC4nO1xyXG5jb25zdCBsaW5rcyA9IHtcclxuICAgIGRvY3M6ICdodHRwczovL2dpdGh1Yi5jb20vbWF0ZXJpYWwtY29tcG9uZW50cy9tYXRlcmlhbC1jb21wb25lbnRzLXdlYi90cmVlL21hc3Rlci9wYWNrYWdlcy9tZGMtaWNvbi1idXR0b24nLFxyXG4gICAgZ3VpZGU6ICdodHRwczovL21hdGVyaWFsLmlvL2NvbXBvbmVudHMvYnV0dG9ucydcclxufTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIEljb25CdXR0b25QYWdlKCkge1xyXG4gICAgY29uc3QgW2lzT24sIHNldE9uXSA9IHVzZVN0YXRlKHRydWUpO1xyXG5cclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgPFBhZ2UgaWQ9e2lkfSB0aXRsZT17dGl0bGV9IGRlc2NyaXB0aW9uPXtkZXNjcmlwdGlvbn0gbGlua3M9e2xpbmtzfT5cclxuICAgICAgICAgICAgPFNlY3Rpb24gdGl0bGU9XCJCYXNpYyBpY29uIGJ1dHRvblwiPlxyXG4gICAgICAgICAgICAgICAgPENvZGU+XHJcbiAgICAgICAgICAgICAgICAgICAgPEljb25CdXR0b25cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWNvbj1cInN0YXJcIlxyXG4gICAgICAgICAgICAgICAgICAgIC8+XHJcbiAgICAgICAgICAgICAgICA8L0NvZGU+XHJcbiAgICAgICAgICAgIDwvU2VjdGlvbj5cclxuXHJcbiAgICAgICAgICAgIDxTZWN0aW9uIHRpdGxlPVwiVG9nZ2xpbmcgaWNvbiBidXR0b25cIj5cclxuICAgICAgICAgICAgICAgIDxDb2RlPlxyXG4gICAgICAgICAgICAgICAgICAgIDxJY29uQnV0dG9uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGljb249e2lzT24gPyAnZmF2b3JpdGUnIDogJ2Zhdm9yaXRlX2JvcmRlcid9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2xpY2s9eygpID0+IHNldE9uKHYgPT4gIXYpfVxyXG4gICAgICAgICAgICAgICAgICAgIC8+XHJcbiAgICAgICAgICAgICAgICA8L0NvZGU+XHJcbiAgICAgICAgICAgIDwvU2VjdGlvbj5cclxuICAgICAgICA8L1BhZ2U+XHJcbiAgICApO1xyXG59IiwiaW1wb3J0IHtcclxuICAgIEltYWdlTGlzdFxyXG59IGZyb20gJ21kYy1yZWFjdCc7XHJcblxyXG5jb25zdCBpZCA9ICdpbWFnZS1saXN0JztcclxuY29uc3QgdGl0bGUgPSAnSW1hZ2UgTGlzdCc7XHJcbmNvbnN0IGRlc2NyaXB0aW9uID0gJ0ltYWdlIGxpc3RzIGRpc3BsYXkgYSBjb2xsZWN0aW9uIG9mIGltYWdlcyBpbiBhbiBvcmdhbml6ZWQgZ3JpZC4nO1xyXG5jb25zdCBsaW5rcyA9IHtcclxuICAgIGRvY3M6ICdodHRwczovL2dpdGh1Yi5jb20vbWF0ZXJpYWwtY29tcG9uZW50cy9tYXRlcmlhbC1jb21wb25lbnRzLXdlYi90cmVlL21hc3Rlci9wYWNrYWdlcy9tZGMtaW1hZ2UtbGlzdCcsXHJcbiAgICBndWlkZTogJ2h0dHBzOi8vbWF0ZXJpYWwuaW8vY29tcG9uZW50cy9pbWFnZS1saXN0cydcclxufTtcclxuXHJcbmltcG9ydCBQYWdlIGZyb20gJ0AvY29tcG9uZW50cy9QYWdlJztcclxuaW1wb3J0IFNlY3Rpb24gZnJvbSAnQC9jb21wb25lbnRzL1NlY3Rpb24nO1xyXG5pbXBvcnQgQ29kZSBmcm9tICdAL2NvbXBvbmVudHMvQ29kZSc7XHJcblxyXG5pbXBvcnQgJy4vaW5kZXguc2Nzcyc7XHJcblxyXG5jb25zdCBzdGFuZGFyZEl0ZW1zID0gbmV3IEFycmF5KDE1KS5maWxsKDEpLm1hcCgoKSA9PiAoe1xyXG4gICAgaW1hZ2VTcmM6ICdodHRwczovL3BsYWNlaW1nLmNvbS8zNjAvMzYwL2FueScsXHJcbiAgICBsYWJlbDogJ1RleHQgTGFiZWwnXHJcbn0pKTtcclxuXHJcbmNvbnN0IG1hc29ucnlJdGVtcyA9IG5ldyBBcnJheSgxNSkuZmlsbCgxKS5tYXAoKCkgPT4gKHtcclxuICAgIGltYWdlU3JjOiBgaHR0cHM6Ly9wbGFjZWltZy5jb20vJHtNYXRoLnJhbmRvbSgpID4gMC41ID8gJzQ4MC8zNjAnIDogJzM2MC80ODAnfS9hbnlgLFxyXG4gICAgbGFiZWw6ICdUZXh0IExhYmVsJ1xyXG59KSk7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBJbWFnZUxpc3RQYWdlKCkge1xyXG4gICAgcmV0dXJuIChcclxuICAgICAgICA8UGFnZSBpZD17aWR9IHRpdGxlPXt0aXRsZX0gZGVzY3JpcHRpb249e2Rlc2NyaXB0aW9ufSBsaW5rcz17bGlua3N9PlxyXG4gICAgICAgICAgICA8U2VjdGlvbiBpZD1cInN0YW5kYXJkLWltYWdlLWxpc3RcIiB0aXRsZT1cIlN0YW5kYXJkIEltYWdlIExpc3RcIj5cclxuICAgICAgICAgICAgICAgIDxDb2RlPlxyXG4gICAgICAgICAgICAgICAgICAgIDxJbWFnZUxpc3Q+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHtzdGFuZGFyZEl0ZW1zLm1hcCgoaXRlbSwgaW5kZXgpID0+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8SW1hZ2VMaXN0Lkl0ZW0ga2V5PXtpbmRleH0gey4uLml0ZW19IC8+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICl9XHJcbiAgICAgICAgICAgICAgICAgICAgPC9JbWFnZUxpc3Q+XHJcbiAgICAgICAgICAgICAgICA8L0NvZGU+XHJcbiAgICAgICAgICAgIDwvU2VjdGlvbj5cclxuXHJcbiAgICAgICAgICAgIDxTZWN0aW9uIGlkPVwic3RhbmRhcmQtaW1hZ2UtbGlzdFwiIHRpdGxlPVwiU3RhbmRhcmQgSW1hZ2UgTGlzdCB3aXRoIFRleHQgUHJvdGVjdGlvblwiPlxyXG4gICAgICAgICAgICAgICAgPENvZGU+XHJcbiAgICAgICAgICAgICAgICAgICAgPEltYWdlTGlzdCB3aXRoVGV4dFByb3RlY3Rpb24+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHtzdGFuZGFyZEl0ZW1zLm1hcCgoaXRlbSwgaW5kZXgpID0+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8SW1hZ2VMaXN0Lkl0ZW0ga2V5PXtpbmRleH0gey4uLml0ZW19IC8+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICl9XHJcbiAgICAgICAgICAgICAgICAgICAgPC9JbWFnZUxpc3Q+XHJcbiAgICAgICAgICAgICAgICA8L0NvZGU+XHJcbiAgICAgICAgICAgIDwvU2VjdGlvbj5cclxuXHJcbiAgICAgICAgICAgIDxTZWN0aW9uIGlkPVwibWFzb25yeS1pbWFnZS1saXN0XCIgdGl0bGU9XCJNYXNvbnJ5IEltYWdlIExpc1wiPlxyXG4gICAgICAgICAgICAgICAgPENvZGU+XHJcbiAgICAgICAgICAgICAgICAgICAgPEltYWdlTGlzdCBtYXNvbnJ5PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB7bWFzb25yeUl0ZW1zLm1hcCgoaXRlbSwgaW5kZXgpID0+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8SW1hZ2VMaXN0Lkl0ZW0ga2V5PXtpbmRleH0gey4uLml0ZW19IC8+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICl9XHJcbiAgICAgICAgICAgICAgICAgICAgPC9JbWFnZUxpc3Q+XHJcbiAgICAgICAgICAgICAgICA8L0NvZGU+XHJcbiAgICAgICAgICAgIDwvU2VjdGlvbj5cclxuXHJcbiAgICAgICAgICAgIDxTZWN0aW9uIGlkPVwibWFzb25yeS1pbWFnZS1saXN0XCIgdGl0bGU9XCJNYXNvbnJ5IEltYWdlIExpc3Qgd2l0aCBUZXh0IFByb3RlY3Rpb25cIj5cclxuICAgICAgICAgICAgICAgIDxDb2RlPlxyXG4gICAgICAgICAgICAgICAgICAgIDxJbWFnZUxpc3QgbWFzb25yeSB3aXRoVGV4dFByb3RlY3Rpb24+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHttYXNvbnJ5SXRlbXMubWFwKChpdGVtLCBpbmRleCkgPT5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxJbWFnZUxpc3QuSXRlbSBrZXk9e2luZGV4fSB7Li4uaXRlbX0gLz5cclxuICAgICAgICAgICAgICAgICAgICAgICAgKX1cclxuICAgICAgICAgICAgICAgICAgICA8L0ltYWdlTGlzdD5cclxuICAgICAgICAgICAgICAgIDwvQ29kZT5cclxuICAgICAgICAgICAgPC9TZWN0aW9uPlxyXG4gICAgICAgIDwvUGFnZT5cclxuICAgICk7XHJcbn0iLCJpbXBvcnQge1xyXG4gICAgTGF5b3V0R3JpZFxyXG59IGZyb20gJ21kYy1yZWFjdCc7XHJcblxyXG5pbXBvcnQgUGFnZSBmcm9tICdAL2NvbXBvbmVudHMvUGFnZSc7XHJcbmltcG9ydCBTZWN0aW9uIGZyb20gJ0AvY29tcG9uZW50cy9TZWN0aW9uJztcclxuaW1wb3J0IENvZGUgZnJvbSAnQC9jb21wb25lbnRzL0NvZGUnO1xyXG5cclxuaW1wb3J0ICcuL2luZGV4LnNjc3MnO1xyXG5cclxuY29uc3QgaWQgPSAnbGF5b3V0LWdyaWQnO1xyXG5jb25zdCB0aXRsZSA9ICdMYXlvdXQgR3JpZCc7XHJcbmNvbnN0IGRlc2NyaXB0aW9uID0gJ01hdGVyaWFsIGRlc2lnbuKAmXMgcmVzcG9uc2l2ZSBVSSBpcyBiYXNlZCBvbiBhIDEyLWNvbHVtbiBncmlkIGxheW91dC4nO1xyXG5jb25zdCBsaW5rcyA9IHtcclxuICAgIGRvY3M6ICdodHRwczovL2dpdGh1Yi5jb20vbWF0ZXJpYWwtY29tcG9uZW50cy9tYXRlcmlhbC1jb21wb25lbnRzLXdlYi90cmVlL21hc3Rlci9wYWNrYWdlcy9tZGMtbGF5b3V0LWdyaWQnLFxyXG4gICAgZ3VpZGU6ICdodHRwczovL21hdGVyaWFsLmlvL2Rlc2lnbi9sYXlvdXQvcmVzcG9uc2l2ZS1sYXlvdXQtZ3JpZC5odG1sJ1xyXG59O1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gTGF5b3V0R3JpZFBhZ2UoKSB7XHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAgIDxQYWdlIGlkPXtpZH0gdGl0bGU9e3RpdGxlfSBkZXNjcmlwdGlvbj17ZGVzY3JpcHRpb259IGxpbmtzPXtsaW5rc30+XHJcbiAgICAgICAgICAgIDxTZWN0aW9uIHRpdGxlPVwiQmFzaWMgZ3JpZFwiPlxyXG4gICAgICAgICAgICAgICAgPENvZGU+XHJcbiAgICAgICAgICAgICAgICAgICAgPExheW91dEdyaWQ+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxMYXlvdXRHcmlkLkNlbGwgc3Bhbj1cIjZcIiAvPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8TGF5b3V0R3JpZC5DZWxsIHNwYW49XCIzXCIgLz5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPExheW91dEdyaWQuQ2VsbCBzcGFuPVwiMlwiIC8+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxMYXlvdXRHcmlkLkNlbGwgc3Bhbj1cIjFcIiAvPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8TGF5b3V0R3JpZC5DZWxsIHNwYW49XCIzXCIgLz5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPExheW91dEdyaWQuQ2VsbCBzcGFuPVwiMVwiIC8+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxMYXlvdXRHcmlkLkNlbGwgc3Bhbj1cIjhcIiAvPlxyXG4gICAgICAgICAgICAgICAgICAgIDwvTGF5b3V0R3JpZD5cclxuICAgICAgICAgICAgICAgIDwvQ29kZT5cclxuICAgICAgICAgICAgPC9TZWN0aW9uPlxyXG5cclxuICAgICAgICAgICAgPFNlY3Rpb24gdGl0bGU9XCJOZXN0ZWQgZ3JpZFwiPlxyXG4gICAgICAgICAgICAgICAgPENvZGU+XHJcbiAgICAgICAgICAgICAgICAgICAgPExheW91dEdyaWQ+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxMYXlvdXRHcmlkLkNlbGwgZ3JpZD5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxMYXlvdXRHcmlkLkNlbGwgLz5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxMYXlvdXRHcmlkLkNlbGwgLz5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxMYXlvdXRHcmlkLkNlbGwgLz5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPC9MYXlvdXRHcmlkLkNlbGw+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxMYXlvdXRHcmlkLkNlbGwgLz5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPExheW91dEdyaWQuQ2VsbCAvPlxyXG4gICAgICAgICAgICAgICAgICAgIDwvTGF5b3V0R3JpZD5cclxuICAgICAgICAgICAgICAgIDwvQ29kZT5cclxuICAgICAgICAgICAgPC9TZWN0aW9uPlxyXG4gICAgICAgIDwvUGFnZT5cclxuICAgICk7XHJcbn0iLCJpbXBvcnQgeyB1c2VTdGF0ZSB9IGZyb20gJ3JlYWN0JztcclxuaW1wb3J0IHtcclxuICAgIEJ1dHRvbixcclxuICAgIExpbmVhclByb2dyZXNzXHJcbn0gZnJvbSAnbWRjLXJlYWN0JztcclxuXHJcbmltcG9ydCBQYWdlIGZyb20gJ0AvY29tcG9uZW50cy9QYWdlJztcclxuaW1wb3J0IFNlY3Rpb24gZnJvbSAnQC9jb21wb25lbnRzL1NlY3Rpb24nO1xyXG5pbXBvcnQgQ29kZSBmcm9tICdAL2NvbXBvbmVudHMvQ29kZSc7XHJcblxyXG5jb25zdCBpZCA9ICdsaW5lYXItcHJvZ3Jlc3MnO1xyXG5jb25zdCB0aXRsZSA9ICdMaW5lYXIgUHJvZ3Jlc3MnO1xyXG5jb25zdCBkZXNjcmlwdGlvbiA9ICdQcm9ncmVzcyBpbmRpY2F0b3JzIGRpc3BsYXkgdGhlIGxlbmd0aCBvZiBhIHByb2Nlc3Mgb3IgZXhwcmVzcyBhbiB1bnNwZWNpZmllZCB3YWl0IHRpbWUuJztcclxuY29uc3QgbGlua3MgPSB7XHJcbiAgICBkb2NzOiAnJyxcclxuICAgIGd1aWRlOiAnJ1xyXG59O1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gTGluZWFyUHJvZ3Jlc3NQYWdlKCkge1xyXG4gICAgY29uc3QgW2lzQ2xvc2VkLCBzZXRDbG9zZWRdID0gdXNlU3RhdGUodHJ1ZSk7XHJcblxyXG4gICAgcmV0dXJuIChcclxuICAgICAgICA8UGFnZSBpZD17aWR9IHRpdGxlPXt0aXRsZX0gZGVzY3JpcHRpb249e2Rlc2NyaXB0aW9ufSBsaW5rcz17bGlua3N9PlxyXG4gICAgICAgICAgICA8U2VjdGlvbiB0aXRsZT1cIkJhc2ljIGxpbmVhciBwcm9ncmVzc1wiPlxyXG4gICAgICAgICAgICAgICAgPENvZGU+XHJcbiAgICAgICAgICAgICAgICAgICAgPExpbmVhclByb2dyZXNzIHZhbHVlPVwiNDJcIiAvPlxyXG4gICAgICAgICAgICAgICAgPC9Db2RlPlxyXG4gICAgICAgICAgICA8L1NlY3Rpb24+XHJcblxyXG4gICAgICAgICAgICA8U2VjdGlvbiB0aXRsZT1cIkxpbmVhciBwcm9ncmVzcyB3aXRoIGEgYnVmZmVyXCI+XHJcbiAgICAgICAgICAgICAgICA8Q29kZT5cclxuICAgICAgICAgICAgICAgICAgICA8TGluZWFyUHJvZ3Jlc3MgdmFsdWU9XCI0MlwiIGJ1ZmZlcj1cIjg0XCIgLz5cclxuICAgICAgICAgICAgICAgIDwvQ29kZT5cclxuICAgICAgICAgICAgPC9TZWN0aW9uPlxyXG5cclxuICAgICAgICAgICAgPFNlY3Rpb24gdGl0bGU9XCJJbmRldGVybWluYXRlIGxpbmVhciBwcm9ncmVzc1wiPlxyXG4gICAgICAgICAgICAgICAgPENvZGU+XHJcbiAgICAgICAgICAgICAgICAgICAgPExpbmVhclByb2dyZXNzIGluZGV0ZXJtaW5hdGUgLz5cclxuICAgICAgICAgICAgICAgIDwvQ29kZT5cclxuICAgICAgICAgICAgPC9TZWN0aW9uPlxyXG5cclxuICAgICAgICAgICAgPFNlY3Rpb24gdGl0bGU9XCJDbG9zZWQgbGluZWFyIHByb2dyZXNzXCI+XHJcbiAgICAgICAgICAgICAgICA8Q29kZVxyXG4gICAgICAgICAgICAgICAgICAgIHNldHVwPXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgPEJ1dHRvbiBvbkNsaWNrPXsoKSA9PiBzZXRDbG9zZWQodiA9PiAhdil9PlRvZ2dsZTwvQnV0dG9uPlxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgID5cclxuICAgICAgICAgICAgICAgICAgICA8TGluZWFyUHJvZ3Jlc3MgY2xvc2VkPXtpc0Nsb3NlZH0gdmFsdWU9XCI0MlwiIC8+XHJcbiAgICAgICAgICAgICAgICA8L0NvZGU+XHJcbiAgICAgICAgICAgIDwvU2VjdGlvbj5cclxuICAgICAgICA8L1BhZ2U+XHJcbiAgICApO1xyXG59IiwiaW1wb3J0IHtcclxuICAgIENoZWNrYm94LFxyXG4gICAgSWNvbixcclxuICAgIExpc3QsIExpc3RJdGVtLFxyXG4gICAgUmFkaW8sXHJcbiAgICBTd2l0Y2hcclxufSBmcm9tICdtZGMtcmVhY3QnO1xyXG5cclxuaW1wb3J0IFBhZ2UgZnJvbSAnQC9jb21wb25lbnRzL1BhZ2UnO1xyXG5pbXBvcnQgU2VjdGlvbiBmcm9tICdAL2NvbXBvbmVudHMvU2VjdGlvbic7XHJcbmltcG9ydCBDb2RlIGZyb20gJ0AvY29tcG9uZW50cy9Db2RlJztcclxuXHJcbmNvbnN0IGlkID0gJ2xpc3QnO1xyXG5jb25zdCB0aXRsZSA9ICdMaXN0JztcclxuY29uc3QgZGVzY3JpcHRpb24gPSAnTGlzdHMgcHJlc2VudCBtdWx0aXBsZSBsaW5lIGl0ZW1zIHZlcnRpY2FsbHkgYXMgYSBzaW5nbGUgY29udGludW91cyBlbGVtZW50Lic7XHJcbmNvbnN0IGxpbmtzID0ge1xyXG4gICAgZG9jczogJ2h0dHBzOi8vZ2l0aHViLmNvbS9tYXRlcmlhbC1jb21wb25lbnRzL21hdGVyaWFsLWNvbXBvbmVudHMtd2ViL3RyZWUvbWFzdGVyL3BhY2thZ2VzL21kYy1saXN0JyxcclxuICAgIGd1aWRlOiAnaHR0cHM6Ly9tYXRlcmlhbC5pby9jb21wb25lbnRzL2xpc3RzJ1xyXG59O1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gTGlzdFBhZ2UoKSB7XHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAgIDxQYWdlIGlkPXtpZH0gdGl0bGU9e3RpdGxlfSBkZXNjcmlwdGlvbj17ZGVzY3JpcHRpb259IGxpbmtzPXtsaW5rc30+XHJcbiAgICAgICAgICAgIDxTZWN0aW9uIHRpdGxlPVwiU2luZ2xlLWxpbmUgbGlzdFwiPlxyXG4gICAgICAgICAgICAgICAgPENvZGU+XHJcbiAgICAgICAgICAgICAgICAgICAgPExpc3Q+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxMaXN0SXRlbVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dD1cIkl0ZW0gMVwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8+XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8TGlzdEl0ZW1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ9XCJJdGVtIDJcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvPlxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPExpc3RJdGVtXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0PVwiSXRlbSAzXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgLz5cclxuICAgICAgICAgICAgICAgICAgICA8L0xpc3Q+XHJcbiAgICAgICAgICAgICAgICA8L0NvZGU+XHJcbiAgICAgICAgICAgIDwvU2VjdGlvbj5cclxuXHJcbiAgICAgICAgICAgIDxTZWN0aW9uIHRpdGxlPVwiVHdvLWxpbmUgbGlzdFwiPlxyXG4gICAgICAgICAgICAgICAgPENvZGU+XHJcbiAgICAgICAgICAgICAgICAgICAgPExpc3Q+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxMaXN0SXRlbVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJpbWFyeVRleHQ9XCJJdGVtIDFcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2Vjb25kYXJ5VGV4dD1cIlNlY29uZGFyeSB0ZXh0XCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgLz5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxMaXN0SXRlbVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJpbWFyeVRleHQ9XCJJdGVtIDJcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2Vjb25kYXJ5VGV4dD1cIlNlY29uZGFyeSB0ZXh0XCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgLz5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxMaXN0SXRlbVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJpbWFyeVRleHQ9XCJJdGVtIDNcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2Vjb25kYXJ5VGV4dD1cIlNlY29uZGFyeSB0ZXh0XCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgLz5cclxuICAgICAgICAgICAgICAgICAgICA8L0xpc3Q+XHJcbiAgICAgICAgICAgICAgICA8L0NvZGU+XHJcblxyXG4gICAgICAgICAgICAgICAgPENvZGU+XHJcbiAgICAgICAgICAgICAgICAgICAgPExpc3Q+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxMaXN0SXRlbVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3ZlcmxpbmVUZXh0PVwiT3ZlcmxpbmVcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJpbWFyeVRleHQ9XCJJdGVtIDFcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvPlxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPExpc3RJdGVtXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdmVybGluZVRleHQ9XCJPdmVybGluZVwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmltYXJ5VGV4dD1cIkl0ZW0gMlwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8+XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8TGlzdEl0ZW1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG92ZXJsaW5lVGV4dD1cIk92ZXJsaW5lXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByaW1hcnlUZXh0PVwiSXRlbSAzXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgLz5cclxuICAgICAgICAgICAgICAgICAgICA8L0xpc3Q+XHJcbiAgICAgICAgICAgICAgICA8L0NvZGU+XHJcbiAgICAgICAgICAgIDwvU2VjdGlvbj5cclxuXHJcbiAgICAgICAgICAgIDxTZWN0aW9uIHRpdGxlPVwiVGhyZWUtbGluZSBsaXN0XCI+XHJcbiAgICAgICAgICAgICAgICA8Q29kZT5cclxuICAgICAgICAgICAgICAgICAgICA8TGlzdD5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPExpc3RJdGVtXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdmVybGluZVRleHQ9XCJPdmVybGluZVwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmltYXJ5VGV4dD1cIkl0ZW0gMVwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWNvbmRhcnlUZXh0PVwiU2Vjb25kYXJ5IHRleHRcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvPlxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPExpc3RJdGVtXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdmVybGluZVRleHQ9XCJPdmVybGluZVwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmltYXJ5VGV4dD1cIkl0ZW0gMlwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWNvbmRhcnlUZXh0PVwiU2Vjb25kYXJ5IHRleHRcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvPlxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPExpc3RJdGVtXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdmVybGluZVRleHQ9XCJPdmVybGluZVwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmltYXJ5VGV4dD1cIkl0ZW0gM1wiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWNvbmRhcnlUZXh0PVwiU2Vjb25kYXJ5IHRleHRcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvPlxyXG4gICAgICAgICAgICAgICAgICAgIDwvTGlzdD5cclxuICAgICAgICAgICAgICAgIDwvQ29kZT5cclxuICAgICAgICAgICAgPC9TZWN0aW9uPlxyXG5cclxuICAgICAgICAgICAgPFNlY3Rpb24gdGl0bGU9XCJMaXN0IHdpdGggaWNvbnNcIj5cclxuICAgICAgICAgICAgICAgIDxDb2RlPlxyXG4gICAgICAgICAgICAgICAgICAgIDxMaXN0PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8TGlzdEl0ZW1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGljb249XCJzdGFyXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ9XCJJdGVtIDFcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvPlxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPExpc3RJdGVtXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpY29uPVwic3RhclwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0PVwiSXRlbSAyXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgLz5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxMaXN0SXRlbVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWNvbj1cInN0YXJcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dD1cIkl0ZW0gM1wiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8+XHJcbiAgICAgICAgICAgICAgICAgICAgPC9MaXN0PlxyXG4gICAgICAgICAgICAgICAgPC9Db2RlPlxyXG4gICAgICAgICAgICA8L1NlY3Rpb24+XHJcblxyXG4gICAgICAgICAgICA8U2VjdGlvbiB0aXRsZT1cIkxpc3Qgd2l0aCBpbWFnZXNcIj5cclxuICAgICAgICAgICAgICAgIDxDb2RlPlxyXG4gICAgICAgICAgICAgICAgICAgIDxMaXN0PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8TGlzdEl0ZW1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGltYWdlPXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8aW1nIHNyYz1cImh0dHBzOi8vcGxhY2VpbWcuY29tLzU2LzU2L2FueVwiIC8+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0PVwiSXRlbSAxXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgLz5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxMaXN0SXRlbVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW1hZ2U9e1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxpbWcgc3JjPVwiaHR0cHM6Ly9wbGFjZWltZy5jb20vNTYvNTYvYW55XCIgLz5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ9XCJJdGVtIDJcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvPlxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPExpc3RJdGVtXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbWFnZT17XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGltZyBzcmM9XCJodHRwczovL3BsYWNlaW1nLmNvbS81Ni81Ni9hbnlcIiAvPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dD1cIkl0ZW0gM1wiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8+XHJcbiAgICAgICAgICAgICAgICAgICAgPC9MaXN0PlxyXG4gICAgICAgICAgICAgICAgPC9Db2RlPlxyXG4gICAgICAgICAgICA8L1NlY3Rpb24+XHJcblxyXG4gICAgICAgICAgICA8U2VjdGlvbiB0aXRsZT1cIkxpc3Qgd2l0aCB0aHVtYm5haWxzXCI+XHJcbiAgICAgICAgICAgICAgICA8Q29kZT5cclxuICAgICAgICAgICAgICAgICAgICA8TGlzdD5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPExpc3RJdGVtXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHVtYm5haWw9e1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxpbWcgc3JjPVwiaHR0cHM6Ly9wbGFjZWltZy5jb20vNDAvNDAvcGVvcGxlXCIgLz5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ9XCJJdGVtIDFcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvPlxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPExpc3RJdGVtXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHVtYm5haWw9e1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxpbWcgc3JjPVwiaHR0cHM6Ly9wbGFjZWltZy5jb20vNDAvNDAvcGVvcGxlXCIgLz5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ9XCJJdGVtIDJcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvPlxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPExpc3RJdGVtXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHVtYm5haWw9e1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxpbWcgc3JjPVwiaHR0cHM6Ly9wbGFjZWltZy5jb20vNDAvNDAvcGVvcGxlXCIgLz5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ9XCJJdGVtIDNcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvPlxyXG4gICAgICAgICAgICAgICAgICAgIDwvTGlzdD5cclxuICAgICAgICAgICAgICAgIDwvQ29kZT5cclxuICAgICAgICAgICAgPC9TZWN0aW9uPlxyXG5cclxuICAgICAgICAgICAgPFNlY3Rpb24gdGl0bGU9XCJMaXN0IHdpdGggdmlkZW9zXCI+XHJcbiAgICAgICAgICAgICAgICA8Q29kZT5cclxuICAgICAgICAgICAgICAgICAgICA8TGlzdD5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPExpc3RJdGVtXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2aWRlbz17XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGltZyBzcmM9XCJodHRwczovL3BsYWNlaW1nLmNvbS8xMDAvNTYvcGVvcGxlXCIgLz5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ9XCJJdGVtIDFcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvPlxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPExpc3RJdGVtXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2aWRlbz17XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGltZyBzcmM9XCJodHRwczovL3BsYWNlaW1nLmNvbS8xMDAvNTYvcGVvcGxlXCIgLz5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ9XCJJdGVtIDJcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvPlxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPExpc3RJdGVtXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2aWRlbz17XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGltZyBzcmM9XCJodHRwczovL3BsYWNlaW1nLmNvbS8xMDAvNTYvcGVvcGxlXCIgLz5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ9XCJJdGVtIDNcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvPlxyXG4gICAgICAgICAgICAgICAgICAgIDwvTGlzdD5cclxuICAgICAgICAgICAgICAgIDwvQ29kZT5cclxuICAgICAgICAgICAgPC9TZWN0aW9uPlxyXG5cclxuICAgICAgICAgICAgPFNlY3Rpb24gdGl0bGU9XCJMaXN0IHdpdGggY2hlY2tib3hlc1wiPlxyXG4gICAgICAgICAgICAgICAgPENvZGU+XHJcbiAgICAgICAgICAgICAgICAgICAgPExpc3Q+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxMaXN0SXRlbVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGVhZGluZ0NoZWNrYm94PXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8Q2hlY2tib3ggZGVmYXVsdENoZWNrZWQ9e2ZhbHNlfSAvPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dD1cIkl0ZW0gMVwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8+XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8TGlzdEl0ZW1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxlYWRpbmdDaGVja2JveD17XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPENoZWNrYm94IGRlZmF1bHRDaGVja2VkPXtmYWxzZX0gLz5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ9XCJJdGVtIDJcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvPlxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPExpc3RJdGVtXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZWFkaW5nQ2hlY2tib3g9e1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxDaGVja2JveCBkZWZhdWx0Q2hlY2tlZD17ZmFsc2V9IC8+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0PVwiSXRlbSAzXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgLz5cclxuICAgICAgICAgICAgICAgICAgICA8L0xpc3Q+XHJcbiAgICAgICAgICAgICAgICA8L0NvZGU+XHJcbiAgICAgICAgICAgIDwvU2VjdGlvbj5cclxuXHJcbiAgICAgICAgICAgIDxTZWN0aW9uIHRpdGxlPVwiTGlzdCB3aXRoIHJhZGlvc1wiPlxyXG4gICAgICAgICAgICAgICAgPENvZGU+XHJcbiAgICAgICAgICAgICAgICAgICAgPExpc3Q+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxMaXN0SXRlbVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGVhZGluZ1JhZGlvPXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8UmFkaW8gLz5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ9XCJJdGVtIDFcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvPlxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPExpc3RJdGVtXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZWFkaW5nUmFkaW89e1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxSYWRpbyBjaGVja2VkIC8+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0PVwiSXRlbSAyXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgLz5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxMaXN0SXRlbVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGVhZGluZ1JhZGlvPXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8UmFkaW8gLz5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ9XCJJdGVtIDNcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvPlxyXG4gICAgICAgICAgICAgICAgICAgIDwvTGlzdD5cclxuICAgICAgICAgICAgICAgIDwvQ29kZT5cclxuICAgICAgICAgICAgPC9TZWN0aW9uPlxyXG5cclxuICAgICAgICAgICAgPFNlY3Rpb24gdGl0bGU9XCJMaXN0IHdpdGggc3dpdGNoZXNcIj5cclxuICAgICAgICAgICAgICAgIDxDb2RlPlxyXG4gICAgICAgICAgICAgICAgICAgIDxMaXN0PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8TGlzdEl0ZW1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxlYWRpbmdTd2l0Y2g9e1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxTd2l0Y2ggLz5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ9XCJJdGVtIDFcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvPlxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPExpc3RJdGVtXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZWFkaW5nU3dpdGNoPXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8U3dpdGNoIGNoZWNrZWQgLz5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ9XCJJdGVtIDJcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvPlxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPExpc3RJdGVtXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZWFkaW5nU3dpdGNoPXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8U3dpdGNoIC8+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0PVwiSXRlbSAzXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgLz5cclxuICAgICAgICAgICAgICAgICAgICA8L0xpc3Q+XHJcbiAgICAgICAgICAgICAgICA8L0NvZGU+XHJcbiAgICAgICAgICAgIDwvU2VjdGlvbj5cclxuXHJcbiAgICAgICAgICAgIDxTZWN0aW9uIHRpdGxlPVwiTGlzdCB3aXRoIHRyYWlsaW5nIGljb25zXCI+XHJcbiAgICAgICAgICAgICAgICA8Q29kZT5cclxuICAgICAgICAgICAgICAgICAgICA8TGlzdD5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPExpc3RJdGVtXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0PVwiSXRlbSAxXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYWlsaW5nSWNvbj1cImluZm9cIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvPlxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPExpc3RJdGVtXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0PVwiSXRlbSAyXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYWlsaW5nSWNvbj1cImluZm9cIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvPlxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPExpc3RJdGVtXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0PVwiSXRlbSAzXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYWlsaW5nSWNvbj1cImluZm9cIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvPlxyXG4gICAgICAgICAgICAgICAgICAgIDwvTGlzdD5cclxuICAgICAgICAgICAgICAgIDwvQ29kZT5cclxuICAgICAgICAgICAgPC9TZWN0aW9uPlxyXG5cclxuICAgICAgICAgICAgPFNlY3Rpb24gdGl0bGU9XCJMaXN0IHdpdGggdHJhaWxpbmcgbWV0YVwiPlxyXG4gICAgICAgICAgICAgICAgPENvZGU+XHJcbiAgICAgICAgICAgICAgICAgICAgPExpc3Q+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxMaXN0SXRlbVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dD1cIkl0ZW0gMVwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXRhPVwiTWV0YVwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8+XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8TGlzdEl0ZW1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ9XCJJdGVtIDJcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWV0YT1cIk1ldGFcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvPlxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPExpc3RJdGVtXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0PVwiSXRlbSAzXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1ldGE9XCJNZXRhXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgLz5cclxuICAgICAgICAgICAgICAgICAgICA8L0xpc3Q+XHJcbiAgICAgICAgICAgICAgICA8L0NvZGU+XHJcbiAgICAgICAgICAgIDwvU2VjdGlvbj5cclxuXHJcbiAgICAgICAgICAgIDxTZWN0aW9uIHRpdGxlPVwiTGlzdCB3aXRoIHRyYWlsaW5nIGNoZWNrYm94ZXNcIj5cclxuICAgICAgICAgICAgICAgIDxDb2RlPlxyXG4gICAgICAgICAgICAgICAgICAgIDxMaXN0PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8TGlzdEl0ZW1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ9XCJJdGVtIDFcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhaWxpbmdDaGVja2JveD17XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPENoZWNrYm94IC8+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8+XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8TGlzdEl0ZW1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ9XCJJdGVtIDJcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhaWxpbmdDaGVja2JveD17XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPENoZWNrYm94IGNoZWNrZWQgLz5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgLz5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxMaXN0SXRlbVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dD1cIkl0ZW0gM1wiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFpbGluZ0NoZWNrYm94PXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8Q2hlY2tib3ggLz5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgLz5cclxuICAgICAgICAgICAgICAgICAgICA8L0xpc3Q+XHJcbiAgICAgICAgICAgICAgICA8L0NvZGU+XHJcbiAgICAgICAgICAgIDwvU2VjdGlvbj5cclxuXHJcbiAgICAgICAgICAgIDxTZWN0aW9uIHRpdGxlPVwiTGlzdCB3aXRoIHRyYWlsaW5nIHJhZGlvc1wiPlxyXG4gICAgICAgICAgICAgICAgPENvZGU+XHJcbiAgICAgICAgICAgICAgICAgICAgPExpc3Q+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxMaXN0SXRlbVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dD1cIkl0ZW0gMVwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFpbGluZ1JhZGlvPXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8UmFkaW8gLz5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgLz5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxMaXN0SXRlbVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dD1cIkl0ZW0gMlwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFpbGluZ1JhZGlvPXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8UmFkaW8gY2hlY2tlZCAvPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvPlxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPExpc3RJdGVtXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0PVwiSXRlbSAzXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYWlsaW5nUmFkaW89e1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxSYWRpbyAvPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvPlxyXG4gICAgICAgICAgICAgICAgICAgIDwvTGlzdD5cclxuICAgICAgICAgICAgICAgIDwvQ29kZT5cclxuICAgICAgICAgICAgPC9TZWN0aW9uPlxyXG5cclxuICAgICAgICAgICAgPFNlY3Rpb24gdGl0bGU9XCJMaXN0IHdpdGggdHJhaWxpbmcgc3dpdGNoZXNcIj5cclxuICAgICAgICAgICAgICAgIDxDb2RlPlxyXG4gICAgICAgICAgICAgICAgICAgIDxMaXN0PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8TGlzdEl0ZW1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ9XCJJdGVtIDFcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhaWxpbmdTd2l0Y2g9e1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxTd2l0Y2ggLz5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgLz5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxMaXN0SXRlbVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dD1cIkl0ZW0gMlwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFpbGluZ1N3aXRjaD17XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPFN3aXRjaCBzZWxlY3RlZCAvPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvPlxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPExpc3RJdGVtXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0PVwiSXRlbSAzXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYWlsaW5nU3dpdGNoPXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8U3dpdGNoIC8+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8+XHJcbiAgICAgICAgICAgICAgICAgICAgPC9MaXN0PlxyXG4gICAgICAgICAgICAgICAgPC9Db2RlPlxyXG4gICAgICAgICAgICA8L1NlY3Rpb24+XHJcbiAgICAgICAgPC9QYWdlPlxyXG4gICAgKTtcclxufSIsImltcG9ydCB7IHVzZUNhbGxiYWNrLCB1c2VTdGF0ZSB9IGZyb20gJ3JlYWN0JztcclxuaW1wb3J0IHtcclxuICAgIEJ1dHRvbixcclxuICAgIERpYWxvZyxcclxuICAgIEZvcm1GaWVsZCxcclxuICAgIE1lbnUsXHJcbiAgICBSYWRpb1xyXG59IGZyb20gJ21kYy1yZWFjdCc7XHJcblxyXG5pbXBvcnQgRGVtbyBmcm9tICdAL2NvbXBvbmVudHMvRGVtbyc7XHJcbmltcG9ydCBGaWVsZFNldCBmcm9tICdAL2NvbXBvbmVudHMvRmllbGRTZXQnO1xyXG5pbXBvcnQgUGFnZSBmcm9tICdAL2NvbXBvbmVudHMvUGFnZSc7XHJcblxyXG5pbXBvcnQgJy4vaW5kZXguc2Nzcyc7XHJcblxyXG5jb25zdCBpZCA9ICdtZW51JztcclxuY29uc3QgdGl0bGUgPSAnTWVudSc7XHJcbmNvbnN0IGRlc2NyaXB0aW9uID0gJ01lbnVzIGRpc3BsYXkgYSBsaXN0IG9mIGNob2ljZXMgb24gdGVtcG9yYXJ5IHN1cmZhY2VzLic7XHJcbmNvbnN0IGxpbmtzID0ge1xyXG4gICAgZG9jczogJ2h0dHBzOi8vZ2l0aHViLmNvbS9tYXRlcmlhbC1jb21wb25lbnRzL21hdGVyaWFsLWNvbXBvbmVudHMtd2ViL3RyZWUvbWFzdGVyL3BhY2thZ2VzL21kYy1tZW51JyxcclxuICAgIGd1aWRlOiAnaHR0cHM6Ly9tYXRlcmlhbC5pby9jb21wb25lbnRzL21lbnVzJ1xyXG59O1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gTWVudVBhZ2UoKSB7XHJcbiAgICBjb25zdCBbaXNCYXNpY09wZW4sIHNldEJhc2ljT3Blbl0gPSB1c2VTdGF0ZShmYWxzZSk7XHJcbiAgICBjb25zdCBbaXNRdWlja09wZW4sIHNldFF1aWNrT3Blbl0gPSB1c2VTdGF0ZShmYWxzZSk7XHJcbiAgICBjb25zdCBbaXNQZXJzaXN0ZW50T3Blbiwgc2V0UGVyc2lzdGVudE9wZW5dID0gdXNlU3RhdGUoZmFsc2UpO1xyXG4gICAgY29uc3QgW2lzQW5jaG9yZWRPcGVuLCBzZXRBbmNob3JlZE9wZW5dID0gdXNlU3RhdGUoZmFsc2UpO1xyXG4gICAgY29uc3QgW2FuY2hvclBvc2l0aW9uLCBzZXRBbmNob3JQb3NpdGlvbl0gPSB1c2VTdGF0ZShNZW51Lk9yaWdpbi5UT1BfTEVGVCk7XHJcbiAgICBjb25zdCBbYW5jaG9yT3JpZ2luLCBzZXRBbmNob3JPcmlnaW5dID0gdXNlU3RhdGUoTWVudS5PcmlnaW4uVE9QX0xFRlQpO1xyXG4gICAgY29uc3QgW3RyYW5zZm9ybU9yaWdpbiwgc2V0VHJhbnNmb3JtT3JpZ2luXSA9IHVzZVN0YXRlKE1lbnUuT3JpZ2luLlRPUF9MRUZUKTtcclxuICAgIGNvbnN0IFtpc01vZGFsT3Blbiwgc2V0TW9kYWxPcGVuXSA9IHVzZVN0YXRlKGZhbHNlKTtcclxuICAgIGNvbnN0IFtpc0RpYWxvZ09wZW4sIHNldERpYWxvZ09wZW5dID0gdXNlU3RhdGUoZmFsc2UpO1xyXG5cclxuICAgIGNvbnN0IGhhbmRsZUFuY2hvclBvc2l0aW9uQ2hhbmdlID0gdXNlQ2FsbGJhY2soKGV2ZW50LCB2YWx1ZSkgPT4ge1xyXG4gICAgICAgIHNldEFuY2hvclBvc2l0aW9uKHZhbHVlKTtcclxuICAgIH0sIFtdKTtcclxuXHJcbiAgICBjb25zdCBoYW5kbGVBbmNob3JPcmlnaW5DaGFuZ2UgPSB1c2VDYWxsYmFjaygoZXZlbnQsIHZhbHVlKSA9PiB7XHJcbiAgICAgICAgc2V0QW5jaG9yT3JpZ2luKHZhbHVlKTtcclxuICAgIH0sIFtdKTtcclxuXHJcbiAgICBjb25zdCBoYW5kbGVUcmFuc2Zvcm1PcmlnaW5DaGFuZ2UgPSB1c2VDYWxsYmFjaygoZXZlbnQsIHZhbHVlKSA9PiB7XHJcbiAgICAgICAgc2V0VHJhbnNmb3JtT3JpZ2luKHZhbHVlKTtcclxuICAgIH0sIFtdKTtcclxuXHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAgIDxQYWdlIGlkPXtpZH0gdGl0bGU9e3RpdGxlfSBkZXNjcmlwdGlvbj17ZGVzY3JpcHRpb259IGxpbmtzPXtsaW5rc30+XHJcbiAgICAgICAgICAgIDxEZW1vIHRpdGxlPVwiQmFzaWMgbWVudVwiPlxyXG4gICAgICAgICAgICAgICAgPE1lbnVcclxuICAgICAgICAgICAgICAgICAgICBhbmNob3I9e1xyXG4gICAgICAgICAgICAgICAgICAgICAgICA8QnV0dG9uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYWJlbD1cIk9wZW5cIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0bGluZWRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2xpY2s9eygpID0+IHNldEJhc2ljT3Blbih0cnVlKX1cclxuICAgICAgICAgICAgICAgICAgICAgICAgLz5cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgb3Blbj17aXNCYXNpY09wZW59XHJcbiAgICAgICAgICAgICAgICAgICAgb25DbG9zZT17KCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRCYXNpY09wZW4oZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgICAgIH19XHJcbiAgICAgICAgICAgICAgICA+XHJcbiAgICAgICAgICAgICAgICAgICAgPE1lbnUuSXRlbVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0PVwiRm9vXCJcclxuICAgICAgICAgICAgICAgICAgICAvPlxyXG5cclxuICAgICAgICAgICAgICAgICAgICA8TWVudS5JdGVtXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ9XCJCYXJcIlxyXG4gICAgICAgICAgICAgICAgICAgIC8+XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIDxNZW51Lkl0ZW1cclxuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dD1cIkJhelwiXHJcbiAgICAgICAgICAgICAgICAgICAgLz5cclxuICAgICAgICAgICAgICAgIDwvTWVudT5cclxuICAgICAgICAgICAgPC9EZW1vPlxyXG5cclxuICAgICAgICAgICAgPERlbW8gdGl0bGU9XCJRdWljayBtZW51XCI+XHJcbiAgICAgICAgICAgICAgICA8TWVudVxyXG4gICAgICAgICAgICAgICAgICAgIGFuY2hvcj17XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxCdXR0b25cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsPVwiT3BlblwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRsaW5lZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb25DbGljaz17KCkgPT4gc2V0UXVpY2tPcGVuKHRydWUpfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvPlxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBvcGVuPXtpc1F1aWNrT3Blbn1cclxuICAgICAgICAgICAgICAgICAgICBxdWlja1xyXG4gICAgICAgICAgICAgICAgICAgIG9uQ2xvc2U9eygpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2V0UXVpY2tPcGVuKGZhbHNlKTtcclxuICAgICAgICAgICAgICAgICAgICB9fVxyXG4gICAgICAgICAgICAgICAgPlxyXG4gICAgICAgICAgICAgICAgICAgIDxNZW51Lkl0ZW1cclxuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dD1cIkZvb1wiXHJcbiAgICAgICAgICAgICAgICAgICAgLz5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgPE1lbnUuSXRlbVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0PVwiQmFyXCJcclxuICAgICAgICAgICAgICAgICAgICAvPlxyXG5cclxuICAgICAgICAgICAgICAgICAgICA8TWVudS5JdGVtXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ9XCJCYXpcIlxyXG4gICAgICAgICAgICAgICAgICAgIC8+XHJcbiAgICAgICAgICAgICAgICA8L01lbnU+XHJcbiAgICAgICAgICAgIDwvRGVtbz5cclxuXHJcbiAgICAgICAgICAgIDxEZW1vIHRpdGxlPVwiUGVyc2lzdGVudCBtZW51XCI+XHJcbiAgICAgICAgICAgICAgICA8TWVudVxyXG4gICAgICAgICAgICAgICAgICAgIGFuY2hvcj17XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxCdXR0b25cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsPVwiT3BlblwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRsaW5lZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb25DbGljaz17KCkgPT4gc2V0UGVyc2lzdGVudE9wZW4odiA9PiAhdil9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8+XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIG9wZW49e2lzUGVyc2lzdGVudE9wZW59XHJcbiAgICAgICAgICAgICAgICAgICAgcGVyc2lzdGVudFxyXG4gICAgICAgICAgICAgICAgPlxyXG4gICAgICAgICAgICAgICAgICAgIDxNZW51Lkl0ZW1cclxuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dD1cIkZvb1wiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2xpY2s9eygpID0+IHNldFBlcnNpc3RlbnRPcGVuKGZhbHNlKX1cclxuICAgICAgICAgICAgICAgICAgICAvPlxyXG5cclxuICAgICAgICAgICAgICAgICAgICA8TWVudS5JdGVtXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ9XCJCYXJcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBvbkNsaWNrPXsoKSA9PiBzZXRQZXJzaXN0ZW50T3BlbihmYWxzZSl9XHJcbiAgICAgICAgICAgICAgICAgICAgLz5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgPE1lbnUuSXRlbVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0PVwiQmF6XCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgb25DbGljaz17KCkgPT4gc2V0UGVyc2lzdGVudE9wZW4oZmFsc2UpfVxyXG4gICAgICAgICAgICAgICAgICAgIC8+XHJcbiAgICAgICAgICAgICAgICA8L01lbnU+XHJcbiAgICAgICAgICAgIDwvRGVtbz5cclxuXHJcbiAgICAgICAgICAgIDxEZW1vIGlkPVwibWVudS1vcmlnaW5cIiBjbGFzc05hbWU9e2BvcmlnaW4tLSR7YW5jaG9yUG9zaXRpb24ucmVwbGFjZSgnICcsICctJyl9YH0gdGl0bGU9XCJNZW51IG9yaWdpblwiXHJcbiAgICAgICAgICAgICAgICBzZXR0aW5ncz17PD5cclxuICAgICAgICAgICAgICAgICAgICA8RmllbGRTZXQgbGVnZW5kPVwiQW5jaG9yIHBvc2l0aW9uXCI+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxGb3JtRmllbGQgbGFiZWw9XCJUb3AgbGVmdFwiPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPFJhZGlvXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU9e01lbnUuT3JpZ2luLlRPUF9MRUZUfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoZWNrZWQ9e2FuY2hvclBvc2l0aW9uID09PSBNZW51Lk9yaWdpbi5UT1BfTEVGVH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbkNoYW5nZT17aGFuZGxlQW5jaG9yUG9zaXRpb25DaGFuZ2V9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8L0Zvcm1GaWVsZD5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxGb3JtRmllbGQgbGFiZWw9XCJUb3AgcmlnaHRcIj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxSYWRpb1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlPXtNZW51Lk9yaWdpbi5UT1BfUklHSFR9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hlY2tlZD17YW5jaG9yUG9zaXRpb24gPT09IE1lbnUuT3JpZ2luLlRPUF9SSUdIVH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbkNoYW5nZT17aGFuZGxlQW5jaG9yUG9zaXRpb25DaGFuZ2V9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8L0Zvcm1GaWVsZD5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxGb3JtRmllbGQgbGFiZWw9XCJCb3R0b20gbGVmdFwiPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPFJhZGlvXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU9e01lbnUuT3JpZ2luLkJPVFRPTV9MRUZUfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoZWNrZWQ9e2FuY2hvclBvc2l0aW9uID09PSBNZW51Lk9yaWdpbi5CT1RUT01fTEVGVH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbkNoYW5nZT17aGFuZGxlQW5jaG9yUG9zaXRpb25DaGFuZ2V9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8L0Zvcm1GaWVsZD5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxGb3JtRmllbGQgbGFiZWw9XCJCb3R0b20gcmlnaHRcIj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxSYWRpb1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlPXtNZW51Lk9yaWdpbi5CT1RUT01fUklHSFR9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hlY2tlZD17YW5jaG9yUG9zaXRpb24gPT09IE1lbnUuT3JpZ2luLkJPVFRPTV9SSUdIVH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbkNoYW5nZT17aGFuZGxlQW5jaG9yUG9zaXRpb25DaGFuZ2V9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8L0Zvcm1GaWVsZD5cclxuICAgICAgICAgICAgICAgICAgICA8L0ZpZWxkU2V0PlxyXG5cclxuICAgICAgICAgICAgICAgICAgICA8RmllbGRTZXQgbGVnZW5kPVwiQW5jaG9yIG9yaWdpblwiPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8Rm9ybUZpZWxkIGxhYmVsPVwiVG9wIGxlZnRcIj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxSYWRpb1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlPXtNZW51Lk9yaWdpbi5UT1BfTEVGVH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGVja2VkPXthbmNob3JPcmlnaW4gPT09IE1lbnUuT3JpZ2luLlRPUF9MRUZUfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2hhbmdlPXtoYW5kbGVBbmNob3JPcmlnaW5DaGFuZ2V9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8L0Zvcm1GaWVsZD5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxGb3JtRmllbGQgbGFiZWw9XCJUb3AgcmlnaHRcIj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxSYWRpb1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlPXtNZW51Lk9yaWdpbi5UT1BfUklHSFR9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hlY2tlZD17YW5jaG9yT3JpZ2luID09PSBNZW51Lk9yaWdpbi5UT1BfUklHSFR9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb25DaGFuZ2U9e2hhbmRsZUFuY2hvck9yaWdpbkNoYW5nZX1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDwvRm9ybUZpZWxkPlxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPEZvcm1GaWVsZCBsYWJlbD1cIkJvdHRvbSBsZWZ0XCI+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8UmFkaW9cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZT17TWVudS5PcmlnaW4uQk9UVE9NX0xFRlR9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hlY2tlZD17YW5jaG9yT3JpZ2luID09PSBNZW51Lk9yaWdpbi5CT1RUT01fTEVGVH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbkNoYW5nZT17aGFuZGxlQW5jaG9yT3JpZ2luQ2hhbmdlfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLz5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPC9Gb3JtRmllbGQ+XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8Rm9ybUZpZWxkIGxhYmVsPVwiQm90dG9tIHJpZ2h0XCI+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8UmFkaW9cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZT17TWVudS5PcmlnaW4uQk9UVE9NX1JJR0hUfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoZWNrZWQ9e2FuY2hvck9yaWdpbiA9PT0gTWVudS5PcmlnaW4uQk9UVE9NX1JJR0hUfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2hhbmdlPXtoYW5kbGVBbmNob3JPcmlnaW5DaGFuZ2V9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8L0Zvcm1GaWVsZD5cclxuICAgICAgICAgICAgICAgICAgICA8L0ZpZWxkU2V0PlxyXG5cclxuICAgICAgICAgICAgICAgICAgICA8RmllbGRTZXQgbGVnZW5kPVwiVHJhbnNmb3JtIG9yaWdpblwiPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8Rm9ybUZpZWxkIGxhYmVsPVwiVG9wIGxlZnRcIj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxSYWRpb1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlPXtNZW51Lk9yaWdpbi5UT1BfTEVGVH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGVja2VkPXt0cmFuc2Zvcm1PcmlnaW4gPT09IE1lbnUuT3JpZ2luLlRPUF9MRUZUfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2hhbmdlPXtoYW5kbGVUcmFuc2Zvcm1PcmlnaW5DaGFuZ2V9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8L0Zvcm1GaWVsZD5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxGb3JtRmllbGQgbGFiZWw9XCJUb3AgcmlnaHRcIj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxSYWRpb1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlPXtNZW51Lk9yaWdpbi5UT1BfUklHSFR9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hlY2tlZD17dHJhbnNmb3JtT3JpZ2luID09PSBNZW51Lk9yaWdpbi5UT1BfUklHSFR9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb25DaGFuZ2U9e2hhbmRsZVRyYW5zZm9ybU9yaWdpbkNoYW5nZX1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDwvRm9ybUZpZWxkPlxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPEZvcm1GaWVsZCBsYWJlbD1cIkJvdHRvbSBsZWZ0XCI+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8UmFkaW9cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZT17TWVudS5PcmlnaW4uQk9UVE9NX0xFRlR9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hlY2tlZD17dHJhbnNmb3JtT3JpZ2luID09PSBNZW51Lk9yaWdpbi5CT1RUT01fTEVGVH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbkNoYW5nZT17aGFuZGxlVHJhbnNmb3JtT3JpZ2luQ2hhbmdlfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLz5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPC9Gb3JtRmllbGQ+XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8Rm9ybUZpZWxkIGxhYmVsPVwiQm90dG9tIHJpZ2h0XCI+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8UmFkaW9cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZT17TWVudS5PcmlnaW4uQk9UVE9NX1JJR0hUfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoZWNrZWQ9e3RyYW5zZm9ybU9yaWdpbiA9PT0gTWVudS5PcmlnaW4uQk9UVE9NX1JJR0hUfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2hhbmdlPXtoYW5kbGVUcmFuc2Zvcm1PcmlnaW5DaGFuZ2V9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8L0Zvcm1GaWVsZD5cclxuICAgICAgICAgICAgICAgICAgICA8L0ZpZWxkU2V0PlxyXG4gICAgICAgICAgICAgICAgPC8+fVxyXG4gICAgICAgICAgICA+XHJcbiAgICAgICAgICAgICAgICA8TWVudVxyXG4gICAgICAgICAgICAgICAgICAgIGFuY2hvcj17XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxCdXR0b25cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsPXtpc1BlcnNpc3RlbnRPcGVuID8gJ0Nsb3NlJyA6ICdPcGVuJ31cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dGxpbmVkXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbkNsaWNrPXsoKSA9PiBzZXRBbmNob3JlZE9wZW4odiA9PiAhdil9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8+XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGFuY2hvck9yaWdpbj17YW5jaG9yT3JpZ2lufVxyXG4gICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybU9yaWdpbj17dHJhbnNmb3JtT3JpZ2lufVxyXG4gICAgICAgICAgICAgICAgICAgIG9wZW49e2lzQW5jaG9yZWRPcGVufVxyXG4gICAgICAgICAgICAgICAgICAgIG9uQ2xvc2U9eygpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2V0QW5jaG9yZWRPcGVuKGZhbHNlKTtcclxuICAgICAgICAgICAgICAgICAgICB9fVxyXG4gICAgICAgICAgICAgICAgPlxyXG4gICAgICAgICAgICAgICAgICAgIDxNZW51Lkl0ZW1cclxuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dD1cIkZvb1wiXHJcbiAgICAgICAgICAgICAgICAgICAgLz5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgPE1lbnUuSXRlbVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0PVwiQmFyXCJcclxuICAgICAgICAgICAgICAgICAgICAvPlxyXG5cclxuICAgICAgICAgICAgICAgICAgICA8TWVudS5JdGVtXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ9XCJCYXpcIlxyXG4gICAgICAgICAgICAgICAgICAgIC8+XHJcbiAgICAgICAgICAgICAgICA8L01lbnU+XHJcbiAgICAgICAgICAgIDwvRGVtbz5cclxuXHJcbiAgICAgICAgICAgIDxEZW1vXHJcbiAgICAgICAgICAgICAgICB0aXRsZT1cIk1vZGFsIG1lbnVcIlxyXG4gICAgICAgICAgICAgICAgc2V0dXA9ezxCdXR0b24gb25DbGljaz17KCkgPT4gc2V0RGlhbG9nT3Blbih2ID0+ICF2KX0+T3BlbiBEaWFsb2c8L0J1dHRvbj59XHJcbiAgICAgICAgICAgID5cclxuICAgICAgICAgICAgICAgIDxEaWFsb2dcclxuICAgICAgICAgICAgICAgICAgICB0aXRsZT1cIkRpYWxvZ1wiXHJcbiAgICAgICAgICAgICAgICAgICAgb3Blbj17aXNEaWFsb2dPcGVufVxyXG4gICAgICAgICAgICAgICAgPlxyXG4gICAgICAgICAgICAgICAgICAgIDxNZW51XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFuY2hvcj17XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8QnV0dG9uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWw9e2lzUGVyc2lzdGVudE9wZW4gPyAnQ2xvc2UnIDogJ09wZW4nfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dGxpbmVkXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb25DbGljaz17KCkgPT4gc2V0TW9kYWxPcGVuKHYgPT4gIXYpfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLz5cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBvcGVuPXtpc01vZGFsT3Blbn1cclxuICAgICAgICAgICAgICAgICAgICAgICAgbW9kYWxcclxuICAgICAgICAgICAgICAgICAgICAgICAgb25DbG9zZT17KCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0TW9kYWxPcGVuKGZhbHNlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfX1cclxuICAgICAgICAgICAgICAgICAgICA+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxNZW51Lkl0ZW1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ9XCJGb29cIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvPlxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPE1lbnUuSXRlbVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dD1cIkJhclwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8+XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8TWVudS5JdGVtXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0PVwiQmF6XCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgLz5cclxuICAgICAgICAgICAgICAgICAgICA8L01lbnU+XHJcbiAgICAgICAgICAgICAgICA8L0RpYWxvZz5cclxuICAgICAgICAgICAgPC9EZW1vPlxyXG4gICAgICAgIDwvUGFnZT5cclxuICAgICk7XHJcbn0iLCJpbXBvcnQgeyB1c2VDYWxsYmFjaywgdXNlU3RhdGUgfSBmcm9tICdyZWFjdCc7XHJcbmltcG9ydCB7XHJcbiAgICBGb3JtRmllbGQsXHJcbiAgICBSYWRpb1xyXG59IGZyb20gJ21kYy1yZWFjdCc7XHJcblxyXG5pbXBvcnQgUGFnZSBmcm9tICdAL2NvbXBvbmVudHMvUGFnZSc7XHJcbmltcG9ydCBTZWN0aW9uIGZyb20gJ0AvY29tcG9uZW50cy9TZWN0aW9uJztcclxuaW1wb3J0IENvZGUgZnJvbSAnQC9jb21wb25lbnRzL0NvZGUnO1xyXG5cclxuY29uc3QgaWQgPSAncmFkaW8nO1xyXG5jb25zdCB0aXRsZSA9ICdSYWRpbyc7XHJcbmNvbnN0IGRlc2NyaXB0aW9uID0gJ1JhZGlvIGJ1dHRvbnMgYWxsb3cgdXNlcnMgdG8gc2VsZWN0IG9uZSBvcHRpb24gZnJvbSBhIHNldC4nO1xyXG5jb25zdCBsaW5rcyA9IHtcclxuICAgIGRvY3M6ICdodHRwczovL2dpdGh1Yi5jb20vbWF0ZXJpYWwtY29tcG9uZW50cy9tYXRlcmlhbC1jb21wb25lbnRzLXdlYi90cmVlL21hc3Rlci9wYWNrYWdlcy9tZGMtcmFkaW8nLFxyXG4gICAgZ3VpZGU6ICdodHRwczovL21hdGVyaWFsLmlvL2NvbXBvbmVudHMvcmFkaW8tYnV0dG9ucydcclxufTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIFJhZGlvUGFnZSgpIHtcclxuICAgIGNvbnN0IFt2YWx1ZTEsIHNldFZhbHVlMV0gPSB1c2VTdGF0ZSgneWVzJyk7XHJcbiAgICBjb25zdCBbdmFsdWUyLCBzZXRWYWx1ZTJdID0gdXNlU3RhdGUoJ3llcycpO1xyXG5cclxuICAgIGNvbnN0IGhhbmRsZUNoYW5nZTEgPSB1c2VDYWxsYmFjaygoZXZlbnQsIHZhbHVlKSA9PiB7XHJcbiAgICAgICAgc2V0VmFsdWUxKHZhbHVlKTtcclxuICAgIH0sIFtdKTtcclxuXHJcbiAgICBjb25zdCBoYW5kbGVDaGFuZ2UyID0gdXNlQ2FsbGJhY2soKGV2ZW50LCB2YWx1ZSkgPT4ge1xyXG4gICAgICAgIHNldFZhbHVlMih2YWx1ZSk7XHJcbiAgICB9LCBbXSk7XHJcblxyXG4gICAgcmV0dXJuIChcclxuICAgICAgICA8UGFnZSBpZD17aWR9IHRpdGxlPXt0aXRsZX0gZGVzY3JpcHRpb249e2Rlc2NyaXB0aW9ufSBsaW5rcz17bGlua3N9PlxyXG4gICAgICAgICAgICA8U2VjdGlvbiB0aXRsZT1cIkJhc2ljIHJhZGlvXCI+XHJcbiAgICAgICAgICAgICAgICA8Q29kZT5cclxuICAgICAgICAgICAgICAgICAgICA8Rm9ybUZpZWxkIGxhYmVsPVwiWWVzXCI+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxSYWRpb1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZT1cImFuc3dlcjFcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU9XCJ5ZXNcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hlY2tlZD17dmFsdWUxID09PSAneWVzJ31cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2hhbmdlPXtoYW5kbGVDaGFuZ2UxfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvPlxyXG4gICAgICAgICAgICAgICAgICAgIDwvRm9ybUZpZWxkPlxyXG5cclxuICAgICAgICAgICAgICAgICAgICA8Rm9ybUZpZWxkIGxhYmVsPVwiTm9cIj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPFJhZGlvXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lPVwiYW5zd2VyMVwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZT1cIm5vXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoZWNrZWQ9e3ZhbHVlMSA9PT0gJ25vJ31cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2hhbmdlPXtoYW5kbGVDaGFuZ2UxfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvPlxyXG4gICAgICAgICAgICAgICAgICAgIDwvRm9ybUZpZWxkPlxyXG5cclxuICAgICAgICAgICAgICAgICAgICA8Rm9ybUZpZWxkIGxhYmVsPVwiTWF5YmVcIj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPFJhZGlvXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lPVwiYW5zd2VyMVwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZT1cIm1heWJlXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoZWNrZWQ9e3ZhbHVlMSA9PT0gJ21heWJlJ31cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2hhbmdlPXtoYW5kbGVDaGFuZ2UxfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvPlxyXG4gICAgICAgICAgICAgICAgICAgIDwvRm9ybUZpZWxkPlxyXG4gICAgICAgICAgICAgICAgPC9Db2RlPlxyXG4gICAgICAgICAgICA8L1NlY3Rpb24+XHJcblxyXG4gICAgICAgICAgICA8U2VjdGlvbiB0aXRsZT1cIkRpc2FibGVkIHJhZGlvXCI+XHJcbiAgICAgICAgICAgICAgICA8Q29kZT5cclxuICAgICAgICAgICAgICAgICAgICA8Rm9ybUZpZWxkIGxhYmVsPVwiWWVzXCI+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxSYWRpb1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZT1cImFuc3dlcjJcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU9XCJ5ZXNcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hlY2tlZD17dmFsdWUyID09PSAneWVzJ31cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2hhbmdlPXtoYW5kbGVDaGFuZ2UyfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvPlxyXG4gICAgICAgICAgICAgICAgICAgIDwvRm9ybUZpZWxkPlxyXG5cclxuICAgICAgICAgICAgICAgICAgICA8Rm9ybUZpZWxkIGxhYmVsPVwiTm9cIj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPFJhZGlvXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lPVwiYW5zd2VyMlwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZT1cIm5vXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoZWNrZWQ9e3ZhbHVlMiA9PT0gJ25vJ31cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2hhbmdlPXtoYW5kbGVDaGFuZ2UyfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvPlxyXG4gICAgICAgICAgICAgICAgICAgIDwvRm9ybUZpZWxkPlxyXG5cclxuICAgICAgICAgICAgICAgICAgICA8Rm9ybUZpZWxkIGxhYmVsPVwiTWF5YmVcIj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPFJhZGlvXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lPVwiYW5zd2VyMlwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZT1cIm1heWJlXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoZWNrZWQ9e3ZhbHVlMiA9PT0gJ21heWJlJ31cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpc2FibGVkXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbkNoYW5nZT17aGFuZGxlQ2hhbmdlMn1cclxuICAgICAgICAgICAgICAgICAgICAgICAgLz5cclxuICAgICAgICAgICAgICAgICAgICA8L0Zvcm1GaWVsZD5cclxuICAgICAgICAgICAgICAgIDwvQ29kZT5cclxuICAgICAgICAgICAgPC9TZWN0aW9uPlxyXG4gICAgICAgIDwvUGFnZT5cclxuICAgICk7XHJcbn0iLCJpbXBvcnQge1xyXG4gICAgRWxldmF0aW9uLFxyXG4gICAgUmlwcGxlU3VyZmFjZVxyXG59IGZyb20gJ21kYy1yZWFjdCc7XHJcblxyXG5pbXBvcnQgUGFnZSBmcm9tICdAL2NvbXBvbmVudHMvUGFnZSc7XHJcbmltcG9ydCBTZWN0aW9uIGZyb20gJ0AvY29tcG9uZW50cy9TZWN0aW9uJztcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIFJhZGlvUGFnZSgpIHtcclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgPFBhZ2UgdGl0bGU9XCJSaXBwbGVcIj5cclxuICAgICAgICAgICAgPFNlY3Rpb24gdGl0bGU9XCJCYXNpYyByaXBwbGVcIj5cclxuICAgICAgICAgICAgICAgIDxFbGV2YXRpb24gej1cIjVcIj5cclxuICAgICAgICAgICAgICAgICAgICA8UmlwcGxlU3VyZmFjZSBzdHlsZT17eyBoZWlnaHQ6ICcxMDBweCcgfX0gLz5cclxuICAgICAgICAgICAgICAgIDwvRWxldmF0aW9uPlxyXG4gICAgICAgICAgICA8L1NlY3Rpb24+XHJcbiAgICAgICAgPC9QYWdlPlxyXG4gICAgKTtcclxufSIsImltcG9ydCB7IHVzZVN0YXRlIH0gZnJvbSAncmVhY3QnO1xyXG5pbXBvcnQge1xyXG4gICAgU2VnbWVudGVkQnV0dG9uXHJcbn0gZnJvbSAnbWRjLXJlYWN0JztcclxuXHJcbmltcG9ydCBQYWdlIGZyb20gJ0AvY29tcG9uZW50cy9QYWdlJztcclxuaW1wb3J0IFNlY3Rpb24gZnJvbSAnQC9jb21wb25lbnRzL1NlY3Rpb24nO1xyXG5pbXBvcnQgQ29kZSBmcm9tICdAL2NvbXBvbmVudHMvQ29kZSc7XHJcblxyXG5jb25zdCBpZCA9ICdzZWdtZW50ZWQtYnV0dG9uJztcclxuY29uc3QgdGl0bGUgPSAnU2VnbWVudGVkIEJ1dHRvbic7XHJcbmNvbnN0IGRlc2NyaXB0aW9uID0gJ1NlZ21lbnRlZCBidXR0b25zIGFsbG93IHVzZXJzIHRvIHRvZ2dsZSB0aGUgc2VsZWN0ZWQgc3RhdGVzIG9mIGdyb3VwZWQgYnV0dG9ucy4nO1xyXG5jb25zdCBsaW5rcyA9IHtcclxuICAgIGRvY3M6ICdodHRwczovL2dpdGh1Yi5jb20vbWF0ZXJpYWwtY29tcG9uZW50cy9tYXRlcmlhbC1jb21wb25lbnRzLXdlYi90cmVlL21hc3Rlci9wYWNrYWdlcy9tZGMtc2VnbWVudGVkLWJ1dHRvbicsXHJcbiAgICBndWlkZTogJ2h0dHBzOi8vbWF0ZXJpYWwuaW8vY29tcG9uZW50cy9idXR0b25zI3RvZ2dsZS1idXR0b24nXHJcbn07XHJcblxyXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBTZWdtZW50ZWRCdXR0b25QYWdlKCkge1xyXG4gICAgY29uc3QgW3ZhbHVlMSwgc2V0VmFsdWUxXSA9IHVzZVN0YXRlKCdzdGFyJyk7XHJcbiAgICBjb25zdCBbdmFsdWUyLCBzZXRWYWx1ZTJdID0gdXNlU3RhdGUoJ3N0YXInKTtcclxuICAgIGNvbnN0IFt2YWx1ZTMsIHNldFZhbHVlM10gPSB1c2VTdGF0ZSgnc3RhcicpO1xyXG5cclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgPFBhZ2UgaWQ9e2lkfSB0aXRsZT17dGl0bGV9IGRlc2NyaXB0aW9uPXtkZXNjcmlwdGlvbn0gbGlua3M9e2xpbmtzfT5cclxuICAgICAgICAgICAgPFNlY3Rpb24gdGl0bGU9XCJUZXh0XCI+XHJcbiAgICAgICAgICAgICAgICA8Q29kZT5cclxuICAgICAgICAgICAgICAgICAgICA8U2VnbWVudGVkQnV0dG9uIHZhbHVlPXt2YWx1ZTF9IG9uQ2hhbmdlPXtzZXRWYWx1ZTF9PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8U2VnbWVudGVkQnV0dG9uLlNlZ21lbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlPVwic3RhclwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYWJlbD1cInN0YXJcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvPlxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPFNlZ21lbnRlZEJ1dHRvbi5TZWdtZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZT1cImZhdm9yaXRlXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsPVwiZmF2b3JpdGVcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvPlxyXG4gICAgICAgICAgICAgICAgICAgIDwvU2VnbWVudGVkQnV0dG9uPlxyXG4gICAgICAgICAgICAgICAgPC9Db2RlPlxyXG4gICAgICAgICAgICA8L1NlY3Rpb24+XHJcblxyXG4gICAgICAgICAgICA8U2VjdGlvbiB0aXRsZT1cIkljb25zXCI+XHJcbiAgICAgICAgICAgICAgICA8Q29kZT5cclxuICAgICAgICAgICAgICAgICAgICA8U2VnbWVudGVkQnV0dG9uIHZhbHVlPXt2YWx1ZTJ9IG9uQ2hhbmdlPXtzZXRWYWx1ZTJ9PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8U2VnbWVudGVkQnV0dG9uLlNlZ21lbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlPVwic3RhclwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpY29uPVwic3RhclwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8+XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8U2VnbWVudGVkQnV0dG9uLlNlZ21lbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlPVwiZmF2b3JpdGVcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWNvbj1cImZhdm9yaXRlXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgLz5cclxuICAgICAgICAgICAgICAgICAgICA8L1NlZ21lbnRlZEJ1dHRvbj5cclxuICAgICAgICAgICAgICAgIDwvQ29kZT5cclxuICAgICAgICAgICAgPC9TZWN0aW9uPlxyXG5cclxuICAgICAgICAgICAgPFNlY3Rpb24gdGl0bGU9XCJUZXh0IHdpdGggSWNvbnNcIj5cclxuICAgICAgICAgICAgICAgIDxDb2RlPlxyXG4gICAgICAgICAgICAgICAgICAgIDxTZWdtZW50ZWRCdXR0b24gdmFsdWU9e3ZhbHVlM30gb25DaGFuZ2U9e3NldFZhbHVlM30+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxTZWdtZW50ZWRCdXR0b24uU2VnbWVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU9XCJzdGFyXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGljb249XCJzdGFyXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsPVwic3RhclwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8+XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8U2VnbWVudGVkQnV0dG9uLlNlZ21lbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlPVwiZmF2b3JpdGVcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWNvbj1cImZhdm9yaXRlXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsPVwiZmF2b3JpdGVcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvPlxyXG4gICAgICAgICAgICAgICAgICAgIDwvU2VnbWVudGVkQnV0dG9uPlxyXG4gICAgICAgICAgICAgICAgPC9Db2RlPlxyXG4gICAgICAgICAgICA8L1NlY3Rpb24+XHJcbiAgICAgICAgPC9QYWdlPlxyXG4gICAgKTtcclxufSIsImltcG9ydCB7IHVzZVN0YXRlIH0gZnJvbSAncmVhY3QnO1xyXG5pbXBvcnQge1xyXG4gICAgU2VsZWN0XHJcbn0gZnJvbSAnbWRjLXJlYWN0JztcclxuXHJcbmltcG9ydCBEZW1vIGZyb20gJ0AvY29tcG9uZW50cy9EZW1vJztcclxuaW1wb3J0IFBhZ2UgZnJvbSAnQC9jb21wb25lbnRzL1BhZ2UnO1xyXG5cclxuY29uc3QgaWQgPSAnc2VsZWN0JztcclxuY29uc3QgdGl0bGUgPSAnU2VsZWN0JztcclxuY29uc3QgZGVzY3JpcHRpb24gPSAnU2VnbWVudGVkIGJ1dHRvbnMgYWxsb3cgdXNlcnMgdG8gdG9nZ2xlIHRoZSBzZWxlY3RlZCBzdGF0ZXMgb2YgZ3JvdXBlZCBidXR0b25zLic7XHJcbmNvbnN0IGxpbmtzID0ge1xyXG4gICAgZG9jczogJ2h0dHBzOi8vZ2l0aHViLmNvbS9tYXRlcmlhbC1jb21wb25lbnRzL21hdGVyaWFsLWNvbXBvbmVudHMtd2ViL3RyZWUvbWFzdGVyL3BhY2thZ2VzL21kYy1zZWxlY3QnXHJcbn07XHJcblxyXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBTZWxlY3RQYWdlKCkge1xyXG4gICAgY29uc3QgW2ZpbGxlZCwgc2V0RmlsbGVkXSA9IHVzZVN0YXRlKCk7XHJcbiAgICBjb25zdCBbb3V0bGluZWQsIHNldE91dGxpbmVkXSA9IHVzZVN0YXRlKCk7XHJcbiAgICBjb25zdCBbcHJlc2VsZWN0ZWQsIHNldFByZXNlbGVjdGVkXSA9IHVzZVN0YXRlKCdmb28nKTtcclxuICAgIGNvbnN0IFttdWx0aXBsZSwgc2V0TXVsdGlwbGVdID0gdXNlU3RhdGUoW10pO1xyXG4gICAgY29uc3QgW2ljb24sIHNldEljb25dID0gdXNlU3RhdGUoKTtcclxuXHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAgIDxQYWdlIGlkPXtpZH0gdGl0bGU9e3RpdGxlfSBkZXNjcmlwdGlvbj17ZGVzY3JpcHRpb259IGxpbmtzPXtsaW5rc30+XHJcbiAgICAgICAgICAgIDxEZW1vIHRpdGxlPVwiRmlsbGVkIHNlbGVjdFwiPlxyXG4gICAgICAgICAgICAgICAgPFNlbGVjdFxyXG4gICAgICAgICAgICAgICAgICAgIGxhYmVsPVwiQ2hvb3NlXCJcclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZT17ZmlsbGVkfVxyXG4gICAgICAgICAgICAgICAgICAgIGZpbGxlZFxyXG4gICAgICAgICAgICAgICAgICAgIG9uQ2hhbmdlPXsoZXZlbnQsIHZhbHVlKSA9PiBzZXRGaWxsZWQodmFsdWUpfVxyXG4gICAgICAgICAgICAgICAgPlxyXG4gICAgICAgICAgICAgICAgICAgIDxTZWxlY3QuT3B0aW9uIHZhbHVlPVwiZm9vXCIgdGV4dD1cIkZvb1wiIC8+XHJcbiAgICAgICAgICAgICAgICAgICAgPFNlbGVjdC5PcHRpb24gdmFsdWU9XCJiYXJcIiB0ZXh0PVwiQmFyXCIgLz5cclxuICAgICAgICAgICAgICAgICAgICA8U2VsZWN0Lk9wdGlvbiB2YWx1ZT1cImJhelwiIHRleHQ9XCJCYXpcIiAvPlxyXG4gICAgICAgICAgICAgICAgPC9TZWxlY3Q+XHJcbiAgICAgICAgICAgIDwvRGVtbz5cclxuXHJcbiAgICAgICAgICAgIDxEZW1vIHRpdGxlPVwiT3V0bGluZWQgc2VsZWN0XCI+XHJcbiAgICAgICAgICAgICAgICA8U2VsZWN0XHJcbiAgICAgICAgICAgICAgICAgICAgbGFiZWw9XCJDaG9vc2VcIlxyXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlPXtvdXRsaW5lZH1cclxuICAgICAgICAgICAgICAgICAgICBvdXRsaW5lZFxyXG4gICAgICAgICAgICAgICAgICAgIG9uQ2hhbmdlPXsoZXZlbnQsIHZhbHVlKSA9PiBzZXRPdXRsaW5lZCh2YWx1ZSl9XHJcbiAgICAgICAgICAgICAgICA+XHJcbiAgICAgICAgICAgICAgICAgICAgPFNlbGVjdC5PcHRpb24gdmFsdWU9XCJmb29cIiB0ZXh0PVwiRm9vXCIgLz5cclxuICAgICAgICAgICAgICAgICAgICA8U2VsZWN0Lk9wdGlvbiB2YWx1ZT1cImJhclwiIHRleHQ9XCJCYXJcIiAvPlxyXG4gICAgICAgICAgICAgICAgICAgIDxTZWxlY3QuT3B0aW9uIHZhbHVlPVwiYmF6XCIgdGV4dD1cIkJhelwiIC8+XHJcbiAgICAgICAgICAgICAgICA8L1NlbGVjdD5cclxuICAgICAgICAgICAgPC9EZW1vPlxyXG5cclxuICAgICAgICAgICAgPERlbW8gdGl0bGU9XCJQcmVzZWxlY3RlZCBzZWxlY3RcIj5cclxuICAgICAgICAgICAgICAgIDxTZWxlY3RcclxuICAgICAgICAgICAgICAgICAgICBsYWJlbD1cIkNob29zZVwiXHJcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU9e3ByZXNlbGVjdGVkfVxyXG4gICAgICAgICAgICAgICAgICAgIGZpbGxlZFxyXG4gICAgICAgICAgICAgICAgICAgIG9uQ2hhbmdlPXsoZXZlbnQsIHZhbHVlKSA9PiBzZXRQcmVzZWxlY3RlZCh2YWx1ZSl9XHJcbiAgICAgICAgICAgICAgICA+XHJcbiAgICAgICAgICAgICAgICAgICAgPFNlbGVjdC5PcHRpb24gdmFsdWU9XCJmb29cIiB0ZXh0PVwiRm9vXCIgLz5cclxuICAgICAgICAgICAgICAgICAgICA8U2VsZWN0Lk9wdGlvbiB2YWx1ZT1cImJhclwiIHRleHQ9XCJCYXJcIiAvPlxyXG4gICAgICAgICAgICAgICAgICAgIDxTZWxlY3QuT3B0aW9uIHZhbHVlPVwiYmF6XCIgdGV4dD1cIkJhelwiIC8+XHJcbiAgICAgICAgICAgICAgICA8L1NlbGVjdD5cclxuICAgICAgICAgICAgPC9EZW1vPlxyXG5cclxuICAgICAgICAgICAgPERlbW8gdGl0bGU9XCJNdWx0aXBsZSBzZWxlY3RcIj5cclxuICAgICAgICAgICAgICAgIDxTZWxlY3RcclxuICAgICAgICAgICAgICAgICAgICBsYWJlbD1cIkNob29zZVwiXHJcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU9e211bHRpcGxlfVxyXG4gICAgICAgICAgICAgICAgICAgIGZpbGxlZFxyXG4gICAgICAgICAgICAgICAgICAgIG9uQ2hhbmdlPXsoZXZlbnQsIHZhbHVlKSA9PiBzZXRNdWx0aXBsZSh2YWx1ZSl9XHJcbiAgICAgICAgICAgICAgICA+XHJcbiAgICAgICAgICAgICAgICAgICAgPFNlbGVjdC5PcHRpb24gdmFsdWU9XCJmb29cIiB0ZXh0PVwiRm9vXCIgLz5cclxuICAgICAgICAgICAgICAgICAgICA8U2VsZWN0Lk9wdGlvbiB2YWx1ZT1cImJhclwiIHRleHQ9XCJCYXJcIiAvPlxyXG4gICAgICAgICAgICAgICAgICAgIDxTZWxlY3QuT3B0aW9uIHZhbHVlPVwiYmF6XCIgdGV4dD1cIkJhelwiIC8+XHJcbiAgICAgICAgICAgICAgICA8L1NlbGVjdD5cclxuICAgICAgICAgICAgPC9EZW1vPlxyXG5cclxuICAgICAgICAgICAgPERlbW8gdGl0bGU9XCJTZWxlY3Qgd2l0aCBhbiBpY29uXCI+XHJcbiAgICAgICAgICAgICAgICA8U2VsZWN0XHJcbiAgICAgICAgICAgICAgICAgICAgbGFiZWw9XCJDaG9vc2VcIlxyXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlPXtpY29ufVxyXG4gICAgICAgICAgICAgICAgICAgIGljb249XCJzdGFyXCJcclxuICAgICAgICAgICAgICAgICAgICBmaWxsZWRcclxuICAgICAgICAgICAgICAgICAgICBvbkNoYW5nZT17KGV2ZW50LCB2YWx1ZSkgPT4gc2V0SWNvbih2YWx1ZSl9XHJcbiAgICAgICAgICAgICAgICA+XHJcbiAgICAgICAgICAgICAgICAgICAgPFNlbGVjdC5PcHRpb24gdmFsdWU9XCJmb29cIiB0ZXh0PVwiRm9vXCIgLz5cclxuICAgICAgICAgICAgICAgICAgICA8U2VsZWN0Lk9wdGlvbiB2YWx1ZT1cImJhclwiIHRleHQ9XCJCYXJcIiAvPlxyXG4gICAgICAgICAgICAgICAgICAgIDxTZWxlY3QuT3B0aW9uIHZhbHVlPVwiYmF6XCIgdGV4dD1cIkJhelwiIC8+XHJcbiAgICAgICAgICAgICAgICA8L1NlbGVjdD5cclxuICAgICAgICAgICAgPC9EZW1vPlxyXG4gICAgICAgIDwvUGFnZT5cclxuICAgICk7XHJcbn0iLCJpbXBvcnQgeyB1c2VTdGF0ZSB9IGZyb20gJ3JlYWN0JztcclxuaW1wb3J0IHtcclxuICAgIEJ1dHRvbixcclxuICAgIFNpZGVTaGVldFxyXG59IGZyb20gJ21kYy1yZWFjdCc7XHJcblxyXG5pbXBvcnQgUGFnZSBmcm9tICdAL2NvbXBvbmVudHMvUGFnZSc7XHJcbmltcG9ydCBTZWN0aW9uIGZyb20gJ0AvY29tcG9uZW50cy9TZWN0aW9uJztcclxuaW1wb3J0IENvZGUgZnJvbSAnQC9jb21wb25lbnRzL0NvZGUnO1xyXG5cclxuY29uc3QgaWQgPSAnc2lkZS1zaGVldCc7XHJcbmNvbnN0IHRpdGxlID0gJ1NpZGUgU2hlZXQnO1xyXG5jb25zdCBkZXNjcmlwdGlvbiA9ICdTaWRlIHNoZWV0cyBhcmUgc3VyZmFjZXMgY29udGFpbmluZyBzdXBwbGVtZW50YXJ5IGNvbnRlbnQgdGhhdCBhcmUgYW5jaG9yZWQgdG8gdGhlIGxlZnQgb3IgcmlnaHQgZWRnZSBvZiB0aGUgc2NyZWVuLic7XHJcbmNvbnN0IGxpbmtzID0ge1xyXG4gICAgZ3VpZGU6ICdodHRwczovL21hdGVyaWFsLmlvL2NvbXBvbmVudHMvc2hlZXRzLXNpZGUnXHJcbn07XHJcblxyXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBTaWRlU2hlZXRQYWdlKCkge1xyXG4gICAgY29uc3QgW2lzRGlzbWlzc2libGVPcGVuLCBzZXREaXNtaXNzaWJsZU9wZW5dID0gdXNlU3RhdGUoZmFsc2UpO1xyXG4gICAgY29uc3QgW2lzTW9kYWxPcGVuLCBzZXRNb2RhbE9wZW5dID0gdXNlU3RhdGUoZmFsc2UpO1xyXG5cclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgPFBhZ2UgaWQ9e2lkfSB0aXRsZT17dGl0bGV9IGRlc2NyaXB0aW9uPXtkZXNjcmlwdGlvbn0gbGlua3M9e2xpbmtzfT5cclxuICAgICAgICAgICAgPFNlY3Rpb24gdGl0bGU9XCJCYXNpYyBzaWRlIHNoZWV0XCI+XHJcbiAgICAgICAgICAgICAgICA8Q29kZT5cclxuICAgICAgICAgICAgICAgICAgICA8U2lkZVNoZWV0IHRpdGxlPVwiVGl0bGVcIj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgQ29udGVudFxyXG4gICAgICAgICAgICAgICAgICAgIDwvU2lkZVNoZWV0PlxyXG4gICAgICAgICAgICAgICAgPC9Db2RlPlxyXG4gICAgICAgICAgICA8L1NlY3Rpb24+XHJcblxyXG4gICAgICAgICAgICA8U2VjdGlvbiB0aXRsZT1cIkRpc21pc3NpYmxlIHNpZGUgc2hlZXRcIj5cclxuICAgICAgICAgICAgICAgIDxDb2RlXHJcbiAgICAgICAgICAgICAgICAgICAgc2V0dXA9e1xyXG4gICAgICAgICAgICAgICAgICAgICAgICA8QnV0dG9uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYWJlbD1cIlRvZ2dsZVwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRsaW5lZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb25DbGljaz17KCkgPT4gc2V0RGlzbWlzc2libGVPcGVuKHYgPT4gIXYpfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvPlxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgID5cclxuICAgICAgICAgICAgICAgICAgICA8U2lkZVNoZWV0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlPVwiVGl0bGVcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjbG9zZUljb249XCJjbG9zZVwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wZW49e2lzRGlzbWlzc2libGVPcGVufVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBkaXNtaXNzaWJsZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBvbkNsb3NlPXsoKSA9PiBzZXREaXNtaXNzaWJsZU9wZW4oZmFsc2UpfVxyXG4gICAgICAgICAgICAgICAgICAgID5cclxuICAgICAgICAgICAgICAgICAgICAgICAgQ29udGVudFxyXG4gICAgICAgICAgICAgICAgICAgIDwvU2lkZVNoZWV0PlxyXG4gICAgICAgICAgICAgICAgPC9Db2RlPlxyXG4gICAgICAgICAgICA8L1NlY3Rpb24+XHJcblxyXG4gICAgICAgICAgICA8U2VjdGlvbiB0aXRsZT1cIk1vZGFsIHNpZGUgc2hlZXRcIj5cclxuICAgICAgICAgICAgICAgIDxDb2RlXHJcbiAgICAgICAgICAgICAgICAgICAgc2V0dXA9e1xyXG4gICAgICAgICAgICAgICAgICAgICAgICA8QnV0dG9uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYWJlbD1cIk9wZW5cIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0bGluZWRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2xpY2s9eygpID0+IHNldE1vZGFsT3Blbih0cnVlKX1cclxuICAgICAgICAgICAgICAgICAgICAgICAgLz5cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICA+XHJcbiAgICAgICAgICAgICAgICAgICAgPFNpZGVTaGVldFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aXRsZT1cIlRpdGxlXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2xvc2VJY29uPVwiY2xvc2VcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBvcGVuPXtpc01vZGFsT3Blbn1cclxuICAgICAgICAgICAgICAgICAgICAgICAgbW9kYWxcclxuICAgICAgICAgICAgICAgICAgICAgICAgb25DbG9zZT17KCkgPT4gc2V0TW9kYWxPcGVuKGZhbHNlKX1cclxuICAgICAgICAgICAgICAgICAgICA+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIENvbnRlbnRcclxuICAgICAgICAgICAgICAgICAgICA8L1NpZGVTaGVldD5cclxuICAgICAgICAgICAgICAgIDwvQ29kZT5cclxuICAgICAgICAgICAgPC9TZWN0aW9uPlxyXG4gICAgICAgIDwvUGFnZT5cclxuICAgICk7XHJcbn0iLCJpbXBvcnQgeyB1c2VTdGF0ZSB9IGZyb20gJ3JlYWN0JztcclxuaW1wb3J0IHtcclxuICAgIFNsaWRlclxyXG59IGZyb20gJ21kYy1yZWFjdCc7XHJcblxyXG5pbXBvcnQgUGFnZSBmcm9tICdAL2NvbXBvbmVudHMvUGFnZSc7XHJcbmltcG9ydCBTZWN0aW9uIGZyb20gJ0AvY29tcG9uZW50cy9TZWN0aW9uJztcclxuaW1wb3J0IENvZGUgZnJvbSAnQC9jb21wb25lbnRzL0NvZGUnO1xyXG5cclxuY29uc3QgaWQgPSAnc2xpZGVyJztcclxuY29uc3QgdGl0bGUgPSAnU2xpZGVyJztcclxuY29uc3QgZGVzY3JpcHRpb24gPSAnU2xpZGVycyBhbGxvdyB1c2VycyB0byBtYWtlIHNlbGVjdGlvbnMgZnJvbSBhIHJhbmdlIG9mIHZhbHVlcy4nO1xyXG5jb25zdCBsaW5rcyA9IHtcclxuICAgIGRvY3M6ICdodHRwczovL2dpdGh1Yi5jb20vbWF0ZXJpYWwtY29tcG9uZW50cy9tYXRlcmlhbC1jb21wb25lbnRzLXdlYi90cmVlL21hc3Rlci9wYWNrYWdlcy9tZGMtc2xpZGVyJyxcclxuICAgIGd1aWRlOiAnaHR0cHM6Ly9tYXRlcmlhbC5pby9jb21wb25lbnRzL3NsaWRlcnMnXHJcbn07XHJcblxyXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBTbGlkZXJQYWdlKCkge1xyXG4gICAgY29uc3QgW3ZhbHVlMSwgc2V0VmFsdWUxXSA9IHVzZVN0YXRlKDUwKTtcclxuICAgIGNvbnN0IFt2YWx1ZTIsIHNldFZhbHVlMl0gPSB1c2VTdGF0ZSg1MCk7XHJcbiAgICBjb25zdCBbdmFsdWUzLCBzZXRWYWx1ZTNdID0gdXNlU3RhdGUoNTApO1xyXG5cclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgPFBhZ2UgaWQ9e2lkfSB0aXRsZT17dGl0bGV9IGRlc2NyaXB0aW9uPXtkZXNjcmlwdGlvbn0gbGlua3M9e2xpbmtzfT5cclxuICAgICAgICAgICAgPFNlY3Rpb24gdGl0bGU9XCJDb250aW51b3VzIHNsaWRlclwiPlxyXG4gICAgICAgICAgICAgICAgPENvZGU+XHJcbiAgICAgICAgICAgICAgICAgICAgPFNsaWRlclxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZT17dmFsdWUxfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBvbkNoYW5nZT17c2V0VmFsdWUxfVxyXG4gICAgICAgICAgICAgICAgICAgIC8+XHJcbiAgICAgICAgICAgICAgICA8L0NvZGU+XHJcbiAgICAgICAgICAgIDwvU2VjdGlvbj5cclxuXHJcbiAgICAgICAgICAgIDxTZWN0aW9uIHRpdGxlPVwiRGlzY3JldGUgc2xpZGVyXCI+XHJcbiAgICAgICAgICAgICAgICA8Q29kZT5cclxuICAgICAgICAgICAgICAgICAgICA8U2xpZGVyXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlPXt2YWx1ZTJ9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0ZXA9XCIxMFwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpc2NyZXRlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2hhbmdlPXtzZXRWYWx1ZTJ9XHJcbiAgICAgICAgICAgICAgICAgICAgLz5cclxuICAgICAgICAgICAgICAgIDwvQ29kZT5cclxuICAgICAgICAgICAgPC9TZWN0aW9uPlxyXG5cclxuICAgICAgICAgICAgPFNlY3Rpb24gdGl0bGU9XCJEaXNjcmV0ZSBzbGlkZXIgd2l0aCB0aWNrIG1hcmtzXCI+XHJcbiAgICAgICAgICAgICAgICA8Q29kZT5cclxuICAgICAgICAgICAgICAgICAgICA8U2xpZGVyXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlPXt2YWx1ZTN9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0ZXA9XCIxMFwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpc2NyZXRlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpY2tNYXJrc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBvbkNoYW5nZT17c2V0VmFsdWUzfVxyXG4gICAgICAgICAgICAgICAgICAgIC8+XHJcbiAgICAgICAgICAgICAgICA8L0NvZGU+XHJcbiAgICAgICAgICAgIDwvU2VjdGlvbj5cclxuXHJcbiAgICAgICAgICAgIDxTZWN0aW9uIHRpdGxlPVwiRGlzYWJsZWQgc2xpZGVyXCI+XHJcbiAgICAgICAgICAgICAgICA8Q29kZT5cclxuICAgICAgICAgICAgICAgICAgICA8U2xpZGVyXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlPXs0Mn1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZGlzYWJsZWRcclxuICAgICAgICAgICAgICAgICAgICAvPlxyXG4gICAgICAgICAgICAgICAgPC9Db2RlPlxyXG4gICAgICAgICAgICA8L1NlY3Rpb24+XHJcbiAgICAgICAgPC9QYWdlPlxyXG4gICAgKTtcclxufSIsImltcG9ydCB7IHVzZVN0YXRlIH0gZnJvbSAncmVhY3QnO1xyXG5pbXBvcnQge1xyXG4gICAgQnV0dG9uLFxyXG4gICAgTGF5b3V0LFxyXG4gICAgU2VnbWVudGVkQnV0dG9uLFxyXG4gICAgU25hY2tiYXIsXHJcbiAgICBUZXh0RmllbGRcclxufSBmcm9tICdtZGMtcmVhY3QnO1xyXG5cclxuaW1wb3J0IFBhZ2UgZnJvbSAnQC9jb21wb25lbnRzL1BhZ2UnO1xyXG5pbXBvcnQgU2VjdGlvbiBmcm9tICdAL2NvbXBvbmVudHMvU2VjdGlvbic7XHJcbmltcG9ydCBDb2RlIGZyb20gJ0AvY29tcG9uZW50cy9Db2RlJztcclxuXHJcbmNvbnN0IGlkID0gJ3NuYWNrYmFyJztcclxuY29uc3QgdGl0bGUgPSAnU25hY2tiYXInO1xyXG5jb25zdCBkZXNjcmlwdGlvbiA9ICdTbmFja2JhcnMgcHJvdmlkZSBicmllZiBtZXNzYWdlcyBhYm91dCBhcHAgcHJvY2Vzc2VzIGF0IHRoZSBib3R0b20gb2YgdGhlIHNjcmVlbi4nO1xyXG5jb25zdCBsaW5rcyA9IHtcclxuICAgIGRvY3M6ICdodHRwczovL2dpdGh1Yi5jb20vbWF0ZXJpYWwtY29tcG9uZW50cy9tYXRlcmlhbC1jb21wb25lbnRzLXdlYi90cmVlL21hc3Rlci9wYWNrYWdlcy9tZGMtc25hY2tiYXInLFxyXG4gICAgZ3VpZGU6ICdodHRwczovL21hdGVyaWFsLmlvL2NvbXBvbmVudHMvc25hY2tiYXJzJ1xyXG59O1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gU25hY2tiYXJQYWdlKCkge1xyXG4gICAgY29uc3QgW2lzT3Blbiwgc2V0T3Blbl0gPSB1c2VTdGF0ZShmYWxzZSk7XHJcbiAgICBjb25zdCBbdGltZW91dCwgc2V0VGltZW91dF0gPSB1c2VTdGF0ZSg1MDAwKTtcclxuICAgIGNvbnN0IFtoYXNBY3Rpb24sIHNldEhhc0FjdGlvbl0gPSB1c2VTdGF0ZShmYWxzZSk7XHJcbiAgICBjb25zdCBbaXNMZWFkaW5nLCBzZXRMZWFkaW5nXSA9IHVzZVN0YXRlKGZhbHNlKTtcclxuICAgIGNvbnN0IFtpc1N0YWNrZWQsIHNldFN0YWNrZWRdID0gdXNlU3RhdGUoZmFsc2UpO1xyXG5cclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgPFBhZ2UgaWQ9e2lkfSB0aXRsZT17dGl0bGV9IGRlc2NyaXB0aW9uPXtkZXNjcmlwdGlvbn0gbGlua3M9e2xpbmtzfT5cclxuICAgICAgICAgICAgPFNlY3Rpb24gdGl0bGU9XCJEZW1vXCI+XHJcbiAgICAgICAgICAgICAgICA8TGF5b3V0IHJvdz5cclxuICAgICAgICAgICAgICAgICAgICA8ZmllbGRzZXQ+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxsZWdlbmQ+RWxlbWVudHM8L2xlZ2VuZD5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxTZWdtZW50ZWRCdXR0b24+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8U2VnbWVudGVkQnV0dG9uLlNlZ21lbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYWJlbD1cIkFjdGlvblwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0ZWQ9e2hhc0FjdGlvbn1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbkNsaWNrPXsoKSA9PiBzZXRIYXNBY3Rpb24odiA9PiAhdil9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8L1NlZ21lbnRlZEJ1dHRvbj5cclxuICAgICAgICAgICAgICAgICAgICA8L2ZpZWxkc2V0PlxyXG5cclxuICAgICAgICAgICAgICAgICAgICA8ZmllbGRzZXQ+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxsZWdlbmQ+VmFyaWFudHM8L2xlZ2VuZD5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxTZWdtZW50ZWRCdXR0b24+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8U2VnbWVudGVkQnV0dG9uLlNlZ21lbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYWJlbD1cIkxlYWRpbmdcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdGVkPXtpc0xlYWRpbmd9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb25DbGljaz17KCkgPT4gc2V0TGVhZGluZyh2ID0+ICF2KX1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8+XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPFNlZ21lbnRlZEJ1dHRvbi5TZWdtZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWw9XCJTdGFja2VkXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3RlZD17aXNTdGFja2VkfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2xpY2s9eygpID0+IHNldFN0YWNrZWQodiA9PiAhdil9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8L1NlZ21lbnRlZEJ1dHRvbj5cclxuICAgICAgICAgICAgICAgICAgICA8L2ZpZWxkc2V0PlxyXG5cclxuICAgICAgICAgICAgICAgICAgICA8VGV4dEZpZWxkXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsPVwiVGltZW91dFwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlPXt0aW1lb3V0fVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdWZmaXg9XCJtc1wiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dGxpbmVkXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2hhbmdlPXsoXywgdmFsdWUpID0+IHNldFRpbWVvdXQodmFsdWUpfVxyXG4gICAgICAgICAgICAgICAgICAgIC8+XHJcbiAgICAgICAgICAgICAgICA8L0xheW91dD5cclxuXHJcbiAgICAgICAgICAgICAgICA8Q29kZVxyXG4gICAgICAgICAgICAgICAgICAgIHNldHVwPXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgPEJ1dHRvblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWw9XCJTaG93XCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dGxpbmVkXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbkNsaWNrPXsoKSA9PiBzZXRPcGVuKHRydWUpfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvPlxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgID5cclxuICAgICAgICAgICAgICAgICAgICA8U25hY2tiYXJcclxuICAgICAgICAgICAgICAgICAgICAgICAgb3Blbj17aXNPcGVufVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aW1lb3V0PXt0aW1lb3V0fVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBsYWJlbD1cIk1lc3NhZ2VcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBhY3Rpb249e2hhc0FjdGlvbiA/XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8QnV0dG9uPkFjdGlvbjwvQnV0dG9uPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdW5kZWZpbmVkXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgbGVhZGluZz17aXNMZWFkaW5nIHx8IHVuZGVmaW5lZH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhY2tlZD17aXNTdGFja2VkIHx8IHVuZGVmaW5lZH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgb25DbG9zZT17KCkgPT4gc2V0T3Blbih1bmRlZmluZWQpfVxyXG4gICAgICAgICAgICAgICAgICAgIC8+XHJcbiAgICAgICAgICAgICAgICA8L0NvZGU+XHJcbiAgICAgICAgICAgIDwvU2VjdGlvbj5cclxuICAgICAgICA8L1BhZ2U+XHJcbiAgICApO1xyXG59IiwiaW1wb3J0IHsgdXNlU3RhdGUgfSBmcm9tICdyZWFjdCc7XHJcbmltcG9ydCB7XHJcbiAgICBTd2l0Y2hcclxufSBmcm9tICdtZGMtcmVhY3QnO1xyXG5cclxuaW1wb3J0IERlbW8gZnJvbSAnQC9jb21wb25lbnRzL0RlbW8nO1xyXG5pbXBvcnQgUGFnZSBmcm9tICdAL2NvbXBvbmVudHMvUGFnZSc7XHJcblxyXG5jb25zdCBpZCA9ICdzd2l0Y2gnO1xyXG5jb25zdCB0aXRsZSA9ICdTd2l0Y2gnO1xyXG5jb25zdCBkZXNjcmlwdGlvbiA9ICdTd2l0Y2hlcyB0b2dnbGUgdGhlIHN0YXRlIG9mIGEgc2luZ2xlIGl0ZW0gb24gb3Igb2ZmLic7XHJcbmNvbnN0IGxpbmtzID0ge1xyXG4gICAgZG9jczogJ2h0dHBzOi8vZ2l0aHViLmNvbS9tYXRlcmlhbC1jb21wb25lbnRzL21hdGVyaWFsLWNvbXBvbmVudHMtd2ViL3RyZWUvbWFzdGVyL3BhY2thZ2VzL21kYy1zd2l0Y2gnLFxyXG4gICAgZ3VpZGU6ICdodHRwczovL21hdGVyaWFsLmlvL2NvbXBvbmVudHMvc3dpdGNoZXMnXHJcbn07XHJcblxyXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBTd2l0Y2hQYWdlKCkge1xyXG4gICAgY29uc3QgW2lzU2VsZWN0ZWQsIHNldFNlbGVjdGVkXSA9IHVzZVN0YXRlKGZhbHNlKTtcclxuXHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAgIDxQYWdlIGlkPXtpZH0gdGl0bGU9e3RpdGxlfSBkZXNjcmlwdGlvbj17ZGVzY3JpcHRpb259IGxpbmtzPXtsaW5rc30+XHJcbiAgICAgICAgICAgIDxEZW1vIHRpdGxlPVwiQmFzaWMgc3dpdGNoXCI+XHJcbiAgICAgICAgICAgICAgICA8U3dpdGNoXHJcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0ZWQ9e2lzU2VsZWN0ZWR9XHJcbiAgICAgICAgICAgICAgICAgICAgb25DaGFuZ2U9eygpID0+IHNldFNlbGVjdGVkKHYgPT4gIXYpfVxyXG4gICAgICAgICAgICAgICAgLz5cclxuICAgICAgICAgICAgPC9EZW1vPlxyXG5cclxuICAgICAgICAgICAgPERlbW8gdGl0bGU9XCJEaXNhYmxlZCBzd2l0Y2hcIj5cclxuICAgICAgICAgICAgICAgIDxTd2l0Y2ggZGlzYWJsZWQgLz5cclxuICAgICAgICAgICAgPC9EZW1vPlxyXG4gICAgICAgIDwvUGFnZT5cclxuICAgICk7XHJcbn0iLCJpbXBvcnQgeyB1c2VTdGF0ZSB9IGZyb20gJ3JlYWN0JztcclxuaW1wb3J0IHtcclxuICAgIFRhYkJhciwgVGFiXHJcbn0gZnJvbSAnbWRjLXJlYWN0JztcclxuXHJcbmltcG9ydCBQYWdlIGZyb20gJ0AvY29tcG9uZW50cy9QYWdlJztcclxuaW1wb3J0IFNlY3Rpb24gZnJvbSAnQC9jb21wb25lbnRzL1NlY3Rpb24nO1xyXG5pbXBvcnQgQ29kZSBmcm9tICdAL2NvbXBvbmVudHMvQ29kZSc7XHJcblxyXG5jb25zdCBpZCA9ICd0YWJzJztcclxuY29uc3QgdGl0bGUgPSAnVGFicyc7XHJcbmNvbnN0IGRlc2NyaXB0aW9uID0gJ1RhYnMgb3JnYW5pemUgY29udGVudCBhY3Jvc3MgZGlmZmVyZW50IHNjcmVlbnMsIGRhdGEgc2V0cywgYW5kIG90aGVyIGludGVyYWN0aW9ucy4nO1xyXG5jb25zdCBsaW5rcyA9IHtcclxuICAgIGRvY3M6ICdodHRwczovL2dpdGh1Yi5jb20vbWF0ZXJpYWwtY29tcG9uZW50cy9tYXRlcmlhbC1jb21wb25lbnRzLXdlYi90cmVlL21hc3Rlci9wYWNrYWdlcy9tZGMtdGFiLWJhcicsXHJcbiAgICBndWlkZTogJ2h0dHBzOi8vbWF0ZXJpYWwuaW8vY29tcG9uZW50cy90YWJzJ1xyXG59O1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gU3dpdGNoUGFnZSgpIHtcclxuICAgIGNvbnN0IFtiYXNpYywgc2V0QmFzaWNdID0gdXNlU3RhdGUoMCk7XHJcbiAgICBjb25zdCBbbWluV2lkdGgsIHNldE1pbldpZHRoXSA9IHVzZVN0YXRlKDApO1xyXG4gICAgY29uc3QgW21pbldpZHRoSW5kaWNhdG9yLCBzZXRNaW5XaWR0aEluZGljYXRvcl0gPSB1c2VTdGF0ZSgwKTtcclxuICAgIGNvbnN0IFttaW5XaWR0aFdpdGhNaW5XaWR0aEluZGljYXRvciwgc2V0TWluV2lkdGhXaXRoTWluV2lkdGhJbmRpY2F0b3JdID0gdXNlU3RhdGUoMCk7XHJcbiAgICBjb25zdCBbZmFkZSwgc2V0RmFkZV0gPSB1c2VTdGF0ZSgwKTtcclxuICAgIGNvbnN0IFtpY29ucywgc2V0SWNvbnNdID0gdXNlU3RhdGUoMCk7XHJcbiAgICBjb25zdCBbc3RhY2tlZEljb25zLCBzZXRTdGFja2VkSWNvbnNdID0gdXNlU3RhdGUoMCk7XHJcbiAgICBjb25zdCBbb25seUljb25zLCBzZXRPbmx5SWNvbnNdID0gdXNlU3RhdGUoMCk7XHJcbiAgICBjb25zdCBbaWNvbkluZGljYXRvciwgc2V0SWNvbkluZGljYXRvcl0gPSB1c2VTdGF0ZSgwKTtcclxuICAgIGNvbnN0IFtzY3JvbGwsIHNldFNjcm9sbF0gPSB1c2VTdGF0ZSgwKTtcclxuXHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAgIDxQYWdlIGlkPXtpZH0gdGl0bGU9e3RpdGxlfSBkZXNjcmlwdGlvbj17ZGVzY3JpcHRpb259IGxpbmtzPXtsaW5rc30+XHJcbiAgICAgICAgICAgIDxTZWN0aW9uIHRpdGxlPVwiQmFzaWMgdGFic1wiPlxyXG4gICAgICAgICAgICAgICAgPENvZGU+XHJcbiAgICAgICAgICAgICAgICAgICAgPFRhYkJhclxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZT17YmFzaWN9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2hhbmdlPXt2YWx1ZSA9PiBzZXRCYXNpYyh2YWx1ZSl9XHJcbiAgICAgICAgICAgICAgICAgICAgPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8VGFiIGxhYmVsPVwiVGFiIDFcIiAvPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8VGFiIGxhYmVsPVwiVGFiIDJcIiAvPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8VGFiIGxhYmVsPVwiVGFiIDNcIiAvPlxyXG4gICAgICAgICAgICAgICAgICAgIDwvVGFiQmFyPlxyXG4gICAgICAgICAgICAgICAgPC9Db2RlPlxyXG4gICAgICAgICAgICA8L1NlY3Rpb24+XHJcblxyXG4gICAgICAgICAgICA8U2VjdGlvbiB0aXRsZT1cIk1pbiB3aWR0aCB0YWJzXCI+XHJcbiAgICAgICAgICAgICAgICA8Q29kZT5cclxuICAgICAgICAgICAgICAgICAgICA8VGFiQmFyXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlPXttaW5XaWR0aH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgbWluV2lkdGhcclxuICAgICAgICAgICAgICAgICAgICAgICAgb25DaGFuZ2U9e3ZhbHVlID0+IHNldE1pbldpZHRoKHZhbHVlKX1cclxuICAgICAgICAgICAgICAgICAgICA+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxUYWIgbGFiZWw9XCJUYWIgMVwiIC8+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxUYWIgbGFiZWw9XCJUYWIgMlwiIC8+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxUYWIgbGFiZWw9XCJUYWIgM1wiIC8+XHJcbiAgICAgICAgICAgICAgICAgICAgPC9UYWJCYXI+XHJcbiAgICAgICAgICAgICAgICA8L0NvZGU+XHJcbiAgICAgICAgICAgIDwvU2VjdGlvbj5cclxuXHJcbiAgICAgICAgICAgIDxTZWN0aW9uIHRpdGxlPVwiVGFicyB3aXRoIG1pbiB3aWR0aCBpbmRpY2F0b3JcIj5cclxuICAgICAgICAgICAgICAgIDxDb2RlPlxyXG4gICAgICAgICAgICAgICAgICAgIDxUYWJCYXJcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU9e21pbldpZHRoSW5kaWNhdG9yfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBtaW5XaWR0aEluZGljYXRvclxyXG4gICAgICAgICAgICAgICAgICAgICAgICBvbkNoYW5nZT17dmFsdWUgPT4gc2V0TWluV2lkdGhJbmRpY2F0b3IodmFsdWUpfVxyXG4gICAgICAgICAgICAgICAgICAgID5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPFRhYiBsYWJlbD1cIlRhYiAxXCIgLz5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPFRhYiBsYWJlbD1cIlRhYiAyXCIgLz5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPFRhYiBsYWJlbD1cIlRhYiAzXCIgLz5cclxuICAgICAgICAgICAgICAgICAgICA8L1RhYkJhcj5cclxuICAgICAgICAgICAgICAgIDwvQ29kZT5cclxuICAgICAgICAgICAgPC9TZWN0aW9uPlxyXG5cclxuICAgICAgICAgICAgPFNlY3Rpb24gdGl0bGU9XCJNaW4gd2lkdGggdGFicyB3aXRoIG1pbiB3aWR0aCBpbmRpY2F0b3JcIj5cclxuICAgICAgICAgICAgICAgIDxDb2RlPlxyXG4gICAgICAgICAgICAgICAgICAgIDxUYWJCYXJcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU9e21pbldpZHRoV2l0aE1pbldpZHRoSW5kaWNhdG9yfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBtaW5XaWR0aFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBtaW5XaWR0aEluZGljYXRvclxyXG4gICAgICAgICAgICAgICAgICAgICAgICBvbkNoYW5nZT17dmFsdWUgPT4gc2V0TWluV2lkdGhXaXRoTWluV2lkdGhJbmRpY2F0b3IodmFsdWUpfVxyXG4gICAgICAgICAgICAgICAgICAgID5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPFRhYiBsYWJlbD1cIlRhYiAxXCIgLz5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPFRhYiBsYWJlbD1cIlRhYiAyXCIgLz5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPFRhYiBsYWJlbD1cIlRhYiAzXCIgLz5cclxuICAgICAgICAgICAgICAgICAgICA8L1RhYkJhcj5cclxuICAgICAgICAgICAgICAgIDwvQ29kZT5cclxuICAgICAgICAgICAgPC9TZWN0aW9uPlxyXG5cclxuICAgICAgICAgICAgPFNlY3Rpb24gdGl0bGU9XCJUYWJzIHdpdGggZmFkaW5nIGluZGljYXRvclwiPlxyXG4gICAgICAgICAgICAgICAgPENvZGU+XHJcbiAgICAgICAgICAgICAgICAgICAgPFRhYkJhclxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZT17ZmFkZX1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZmFkZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBvbkNoYW5nZT17dmFsdWUgPT4gc2V0RmFkZSh2YWx1ZSl9XHJcbiAgICAgICAgICAgICAgICAgICAgPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8VGFiIGxhYmVsPVwiVGFiIDFcIiAvPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8VGFiIGxhYmVsPVwiVGFiIDJcIiAvPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8VGFiIGxhYmVsPVwiVGFiIDNcIiAvPlxyXG4gICAgICAgICAgICAgICAgICAgIDwvVGFiQmFyPlxyXG4gICAgICAgICAgICAgICAgPC9Db2RlPlxyXG4gICAgICAgICAgICA8L1NlY3Rpb24+XHJcblxyXG4gICAgICAgICAgICA8U2VjdGlvbiB0aXRsZT1cIlRhYnMgd2l0aCBpY29uc1wiPlxyXG4gICAgICAgICAgICAgICAgPENvZGU+XHJcbiAgICAgICAgICAgICAgICAgICAgPFRhYkJhclxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZT17aWNvbnN9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2hhbmdlPXt2YWx1ZSA9PiBzZXRJY29ucyh2YWx1ZSl9XHJcbiAgICAgICAgICAgICAgICAgICAgPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8VGFiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpY29uPVwic3RhclwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYWJlbD1cIlRhYiAxXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgLz5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxUYWJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGljb249XCJmYXZvcml0ZVwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYWJlbD1cIlRhYiAyXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgLz5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxUYWJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGljb249XCJzZXR0aW5nc1wiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYWJlbD1cIlRhYiAzXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgLz5cclxuICAgICAgICAgICAgICAgICAgICA8L1RhYkJhcj5cclxuICAgICAgICAgICAgICAgIDwvQ29kZT5cclxuICAgICAgICAgICAgPC9TZWN0aW9uPlxyXG5cclxuICAgICAgICAgICAgPFNlY3Rpb24gdGl0bGU9XCJUYWJzIHdpdGggc3RhY2tlZCBpY29uc1wiPlxyXG4gICAgICAgICAgICAgICAgPENvZGU+XHJcbiAgICAgICAgICAgICAgICAgICAgPFRhYkJhclxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZT17c3RhY2tlZEljb25zfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFja2VkXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2hhbmdlPXt2YWx1ZSA9PiBzZXRTdGFja2VkSWNvbnModmFsdWUpfVxyXG4gICAgICAgICAgICAgICAgICAgID5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPFRhYlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWNvbj1cInN0YXJcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWw9XCJUYWIgMVwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8+XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8VGFiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpY29uPVwiZmF2b3JpdGVcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWw9XCJUYWIgMlwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8+XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8VGFiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpY29uPVwic2V0dGluZ3NcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWw9XCJUYWIgM1wiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8+XHJcbiAgICAgICAgICAgICAgICAgICAgPC9UYWJCYXI+XHJcbiAgICAgICAgICAgICAgICA8L0NvZGU+XHJcbiAgICAgICAgICAgIDwvU2VjdGlvbj5cclxuXHJcbiAgICAgICAgICAgIDxTZWN0aW9uIHRpdGxlPVwiVGFicyB3aXRoIGljb25zIG9ubHlcIj5cclxuICAgICAgICAgICAgICAgIDxDb2RlPlxyXG4gICAgICAgICAgICAgICAgICAgIDxUYWJCYXJcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU9e29ubHlJY29uc31cclxuICAgICAgICAgICAgICAgICAgICAgICAgaW5kaWNhdG9ySWNvbj1cInN0YXJcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBvbkNoYW5nZT17dmFsdWUgPT4gc2V0T25seUljb25zKHZhbHVlKX1cclxuICAgICAgICAgICAgICAgICAgICA+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxUYWJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGljb249XCJzdGFyXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgLz5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxUYWJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGljb249XCJmYXZvcml0ZVwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8+XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8VGFiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpY29uPVwic2V0dGluZ3NcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvPlxyXG4gICAgICAgICAgICAgICAgICAgIDwvVGFiQmFyPlxyXG4gICAgICAgICAgICAgICAgPC9Db2RlPlxyXG4gICAgICAgICAgICA8L1NlY3Rpb24+XHJcblxyXG4gICAgICAgICAgICA8U2VjdGlvbiB0aXRsZT1cIlRhYnMgd2l0aCBpY29uIGluZGljYXRvclwiPlxyXG4gICAgICAgICAgICAgICAgPENvZGU+XHJcbiAgICAgICAgICAgICAgICAgICAgPFRhYkJhclxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZT17aWNvbkluZGljYXRvcn1cclxuICAgICAgICAgICAgICAgICAgICAgICAgb25DaGFuZ2U9e3ZhbHVlID0+IHNldEljb25JbmRpY2F0b3IodmFsdWUpfVxyXG4gICAgICAgICAgICAgICAgICAgID5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPFRhYiBsYWJlbD1cIlRhYiAxXCIgLz5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPFRhYiBsYWJlbD1cIlRhYiAyXCIgLz5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPFRhYiBsYWJlbD1cIlRhYiAzXCIgLz5cclxuICAgICAgICAgICAgICAgICAgICA8L1RhYkJhcj5cclxuICAgICAgICAgICAgICAgIDwvQ29kZT5cclxuICAgICAgICAgICAgPC9TZWN0aW9uPlxyXG5cclxuICAgICAgICAgICAgPFNlY3Rpb24gdGl0bGU9XCJTY3JvbGxpbmcgdGFic1wiPlxyXG4gICAgICAgICAgICAgICAgPENvZGU+XHJcbiAgICAgICAgICAgICAgICAgICAgPFRhYkJhclxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZT17c2Nyb2xsfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBvbkNoYW5nZT17dmFsdWUgPT4gc2V0U2Nyb2xsKHZhbHVlKX1cclxuICAgICAgICAgICAgICAgICAgICA+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxUYWIgbGFiZWw9XCJUYWIgMVwiIC8+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxUYWIgbGFiZWw9XCJUYWIgMlwiIC8+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxUYWIgbGFiZWw9XCJUYWIgM1wiIC8+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxUYWIgbGFiZWw9XCJUYWIgNFwiIC8+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxUYWIgbGFiZWw9XCJUYWIgNVwiIC8+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxUYWIgbGFiZWw9XCJUYWIgNlwiIC8+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxUYWIgbGFiZWw9XCJUYWIgN1wiIC8+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxUYWIgbGFiZWw9XCJUYWIgOFwiIC8+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxUYWIgbGFiZWw9XCJUYWIgOVwiIC8+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxUYWIgbGFiZWw9XCJUYWIgMTBcIiAvPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8VGFiIGxhYmVsPVwiVGFiIDExXCIgLz5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPFRhYiBsYWJlbD1cIlRhYiAxMlwiIC8+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxUYWIgbGFiZWw9XCJUYWIgMTNcIiAvPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8VGFiIGxhYmVsPVwiVGFiIDE0XCIgLz5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPFRhYiBsYWJlbD1cIlRhYiAxNVwiIC8+XHJcbiAgICAgICAgICAgICAgICAgICAgPC9UYWJCYXI+XHJcbiAgICAgICAgICAgICAgICA8L0NvZGU+XHJcbiAgICAgICAgICAgIDwvU2VjdGlvbj5cclxuICAgICAgICA8L1BhZ2U+XHJcbiAgICApO1xyXG59IiwiaW1wb3J0IHsgdXNlU3RhdGUgfSBmcm9tICdyZWFjdCc7XHJcbmltcG9ydCB7XHJcbiAgICBUYWJCYXIsIFRhYixcclxuICAgIFRleHRGaWVsZFxyXG59IGZyb20gJ21kYy1yZWFjdCc7XHJcblxyXG5pbXBvcnQgRGVtbyBmcm9tICdAL2NvbXBvbmVudHMvRGVtbyc7XHJcbmltcG9ydCBQYWdlIGZyb20gJ0AvY29tcG9uZW50cy9QYWdlJztcclxuaW1wb3J0IENvZGUgZnJvbSAnQC9jb21wb25lbnRzL0NvZGUnO1xyXG5cclxuY29uc3QgaWQgPSAndGV4dC1maWVsZCc7XHJcbmNvbnN0IHRpdGxlID0gJ1RleHQgRmllbGQnO1xyXG5jb25zdCBkZXNjcmlwdGlvbiA9ICdUZXh0IGZpZWxkcyBsZXQgdXNlcnMgZW50ZXIgYW5kIGVkaXQgdGV4dC4nO1xyXG5jb25zdCBsaW5rcyA9IHtcclxuICAgIGRvY3M6ICdodHRwczovL2dpdGh1Yi5jb20vbWF0ZXJpYWwtY29tcG9uZW50cy9tYXRlcmlhbC1jb21wb25lbnRzLXdlYi90cmVlL21hc3Rlci9wYWNrYWdlcy9tZGMtdGV4dGZpZWxkJyxcclxuICAgIGd1aWRlOiAnaHR0cHM6Ly9tYXRlcmlhbC5pby9jb21wb25lbnRzL3RleHQtZmllbGRzJ1xyXG59O1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gVHlwb2dyYXBoeVBhZ2UoKSB7XHJcbiAgICBjb25zdCBbdHlwZSwgc2V0VHlwZV0gPSB1c2VTdGF0ZSgnZmlsbGVkJyk7XHJcblxyXG4gICAgY29uc3QgaXNGaWxsZWQgPSB0eXBlID09PSAnZmlsbGVkJyB8fCB1bmRlZmluZWQ7XHJcbiAgICBjb25zdCBpc091dGxpbmVkID0gdHlwZSA9PT0gJ291dGxpbmVkJyB8fCB1bmRlZmluZWQ7XHJcblxyXG4gICAgcmV0dXJuIChcclxuICAgICAgICA8UGFnZSBpZD17aWR9IHRpdGxlPXt0aXRsZX0gZGVzY3JpcHRpb249e2Rlc2NyaXB0aW9ufSBsaW5rcz17bGlua3N9PlxyXG4gICAgICAgICAgICA8VGFiQmFyIHZhbHVlPXt0eXBlfSBvbkNoYW5nZT17c2V0VHlwZX0gbWluV2lkdGg+XHJcbiAgICAgICAgICAgICAgICA8VGFiXHJcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU9XCJmaWxsZWRcIlxyXG4gICAgICAgICAgICAgICAgICAgIGxhYmVsPVwiRmlsbGVkXCJcclxuICAgICAgICAgICAgICAgIC8+XHJcblxyXG4gICAgICAgICAgICAgICAgPFRhYlxyXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlPVwib3V0bGluZWRcIlxyXG4gICAgICAgICAgICAgICAgICAgIGxhYmVsPVwiT3V0bGluZWRcIlxyXG4gICAgICAgICAgICAgICAgLz5cclxuICAgICAgICAgICAgPC9UYWJCYXI+XHJcblxyXG4gICAgICAgICAgICA8RGVtbyB0aXRsZT1cIkJhc2ljIHRleHQgZmllbGRcIj5cclxuICAgICAgICAgICAgICAgIDxUZXh0RmllbGRcclxuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0VmFsdWU9XCJcIlxyXG4gICAgICAgICAgICAgICAgICAgIGZpbGxlZD17aXNGaWxsZWR9XHJcbiAgICAgICAgICAgICAgICAgICAgb3V0bGluZWQ9e2lzT3V0bGluZWR9XHJcbiAgICAgICAgICAgICAgICAvPlxyXG4gICAgICAgICAgICA8L0RlbW8+XHJcblxyXG4gICAgICAgICAgICA8RGVtbyB0aXRsZT1cIlRleHQgZmllbGQgd2l0aCBhIGxhYmVsXCI+XHJcbiAgICAgICAgICAgICAgICA8VGV4dEZpZWxkXHJcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdFZhbHVlPVwiXCJcclxuICAgICAgICAgICAgICAgICAgICBsYWJlbD1cIkxhYmVsXCJcclxuICAgICAgICAgICAgICAgICAgICBmaWxsZWQ9e2lzRmlsbGVkfVxyXG4gICAgICAgICAgICAgICAgICAgIG91dGxpbmVkPXtpc091dGxpbmVkfVxyXG4gICAgICAgICAgICAgICAgLz5cclxuICAgICAgICAgICAgPC9EZW1vPlxyXG5cclxuICAgICAgICAgICAgPERlbW8gdGl0bGU9XCJUZXh0YXJlYVwiPlxyXG4gICAgICAgICAgICAgICAgPFRleHRGaWVsZFxyXG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHRWYWx1ZT1cIlwiXHJcbiAgICAgICAgICAgICAgICAgICAgbGFiZWw9XCJMYWJlbFwiXHJcbiAgICAgICAgICAgICAgICAgICAgdGV4dGFyZWFcclxuICAgICAgICAgICAgICAgICAgICBmaWxsZWQ9e2lzRmlsbGVkfVxyXG4gICAgICAgICAgICAgICAgICAgIG91dGxpbmVkPXtpc091dGxpbmVkfVxyXG4gICAgICAgICAgICAgICAgLz5cclxuICAgICAgICAgICAgPC9EZW1vPlxyXG5cclxuICAgICAgICAgICAgPERlbW8gdGl0bGU9XCJBdXRvcmVzaXphYmxlIHRleHRhcmVhXCI+XHJcbiAgICAgICAgICAgICAgICA8VGV4dEZpZWxkXHJcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdFZhbHVlPVwiXCJcclxuICAgICAgICAgICAgICAgICAgICBsYWJlbD1cIkxhYmVsXCJcclxuICAgICAgICAgICAgICAgICAgICB0ZXh0YXJlYVxyXG4gICAgICAgICAgICAgICAgICAgIGF1dG9SZXNpemVcclxuICAgICAgICAgICAgICAgICAgICBmaWxsZWQ9e2lzRmlsbGVkfVxyXG4gICAgICAgICAgICAgICAgICAgIG91dGxpbmVkPXtpc091dGxpbmVkfVxyXG4gICAgICAgICAgICAgICAgLz5cclxuICAgICAgICAgICAgPC9EZW1vPlxyXG5cclxuICAgICAgICAgICAgPERlbW8gdGl0bGU9XCJQcmUtZmlsbGVkIHRleHQgZmllbGRcIj5cclxuICAgICAgICAgICAgICAgIDxUZXh0RmllbGRcclxuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0VmFsdWU9XCJTb21lIHRleHRcIlxyXG4gICAgICAgICAgICAgICAgICAgIGxhYmVsPVwiTGFiZWxcIlxyXG4gICAgICAgICAgICAgICAgICAgIGZpbGxlZD17aXNGaWxsZWR9XHJcbiAgICAgICAgICAgICAgICAgICAgb3V0bGluZWQ9e2lzT3V0bGluZWR9XHJcbiAgICAgICAgICAgICAgICAvPlxyXG4gICAgICAgICAgICA8L0RlbW8+XHJcblxyXG4gICAgICAgICAgICA8RGVtbyB0aXRsZT1cIldpdGggaGVscGVyIHRleHRcIj5cclxuICAgICAgICAgICAgICAgIDxUZXh0RmllbGRcclxuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0VmFsdWU9XCJcIlxyXG4gICAgICAgICAgICAgICAgICAgIGhlbHBlclRleHQ9XCJIZWxwZXIgdGV4dFwiXHJcbiAgICAgICAgICAgICAgICAgICAgZmlsbGVkPXtpc0ZpbGxlZH1cclxuICAgICAgICAgICAgICAgICAgICBvdXRsaW5lZD17aXNPdXRsaW5lZH1cclxuICAgICAgICAgICAgICAgIC8+XHJcbiAgICAgICAgICAgIDwvRGVtbz5cclxuXHJcbiAgICAgICAgICAgIDxEZW1vIHRpdGxlPVwiV2l0aCBwZXJzaXN0ZW50IGhlbHBlciB0ZXh0XCI+XHJcbiAgICAgICAgICAgICAgICA8VGV4dEZpZWxkXHJcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdFZhbHVlPVwiXCJcclxuICAgICAgICAgICAgICAgICAgICBwZXJzaXN0ZW50SGVscGVyVGV4dD1cIkhlbHBlciB0ZXh0XCJcclxuICAgICAgICAgICAgICAgICAgICBmaWxsZWQ9e2lzRmlsbGVkfVxyXG4gICAgICAgICAgICAgICAgICAgIG91dGxpbmVkPXtpc091dGxpbmVkfVxyXG4gICAgICAgICAgICAgICAgLz5cclxuICAgICAgICAgICAgPC9EZW1vPlxyXG5cclxuICAgICAgICAgICAgPERlbW8gdGl0bGU9XCJUZXh0IGZpZWxkIHdpdGggdmFsaWRhdGlvbiBtZXNzYWdlXCI+XHJcbiAgICAgICAgICAgICAgICA8VGV4dEZpZWxkXHJcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdFZhbHVlPVwiXCJcclxuICAgICAgICAgICAgICAgICAgICBsYWJlbD1cIkxhYmVsXCJcclxuICAgICAgICAgICAgICAgICAgICByZXF1aXJlZFxyXG4gICAgICAgICAgICAgICAgICAgIHZhbGlkYXRpb25NZXNzYWdlPVwiVmFsaWRhdGlvbiBtZXNzYWdlXCJcclxuICAgICAgICAgICAgICAgICAgICBmaWxsZWQ9e2lzRmlsbGVkfVxyXG4gICAgICAgICAgICAgICAgICAgIG91dGxpbmVkPXtpc091dGxpbmVkfVxyXG4gICAgICAgICAgICAgICAgLz5cclxuICAgICAgICAgICAgPC9EZW1vPlxyXG5cclxuICAgICAgICAgICAgPERlbW8gdGl0bGU9XCJUZXh0IGZpZWxkIHdpdGggYSBjaGFyYWN0ZXIgY291bnRlclwiPlxyXG4gICAgICAgICAgICAgICAgPFRleHRGaWVsZFxyXG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHRWYWx1ZT1cIlwiXHJcbiAgICAgICAgICAgICAgICAgICAgbGFiZWw9XCJMYWJlbFwiXHJcbiAgICAgICAgICAgICAgICAgICAgbWF4TGVuZ3RoPXsxMH1cclxuICAgICAgICAgICAgICAgICAgICBjaGFyYWN0ZXJDb3VudGVyXHJcbiAgICAgICAgICAgICAgICAgICAgZmlsbGVkPXtpc0ZpbGxlZH1cclxuICAgICAgICAgICAgICAgICAgICBvdXRsaW5lZD17aXNPdXRsaW5lZH1cclxuICAgICAgICAgICAgICAgIC8+XHJcbiAgICAgICAgICAgIDwvRGVtbz5cclxuXHJcbiAgICAgICAgICAgIDxEZW1vIHRpdGxlPVwiVGV4dCBmaWVsZCB3aXRoIGFuIGludGVybmFsIGNoYXJhY3RlciBjb3VudGVyXCI+XHJcbiAgICAgICAgICAgICAgICA8VGV4dEZpZWxkXHJcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdFZhbHVlPVwiXCJcclxuICAgICAgICAgICAgICAgICAgICBsYWJlbD1cIkxhYmVsXCJcclxuICAgICAgICAgICAgICAgICAgICBtYXhMZW5ndGg9ezEyMH1cclxuICAgICAgICAgICAgICAgICAgICBmaWxsZWQ9e2lzRmlsbGVkfVxyXG4gICAgICAgICAgICAgICAgICAgIG91dGxpbmVkPXtpc091dGxpbmVkfVxyXG4gICAgICAgICAgICAgICAgICAgIHRleHRhcmVhXHJcbiAgICAgICAgICAgICAgICAgICAgY2hhcmFjdGVyQ291bnRlcj1cImludGVybmFsXCJcclxuICAgICAgICAgICAgICAgIC8+XHJcbiAgICAgICAgICAgIDwvRGVtbz5cclxuXHJcbiAgICAgICAgICAgIDxEZW1vIHRpdGxlPVwiVGV4dCBmaWVsZCB3aXRoIGEgcHJlZml4XCI+XHJcbiAgICAgICAgICAgICAgICA8VGV4dEZpZWxkXHJcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdFZhbHVlPVwiXCJcclxuICAgICAgICAgICAgICAgICAgICBsYWJlbD1cIkxhYmVsXCJcclxuICAgICAgICAgICAgICAgICAgICBwcmVmaXg9XCJAXCJcclxuICAgICAgICAgICAgICAgICAgICBmaWxsZWQ9e2lzRmlsbGVkfVxyXG4gICAgICAgICAgICAgICAgICAgIG91dGxpbmVkPXtpc091dGxpbmVkfVxyXG4gICAgICAgICAgICAgICAgLz5cclxuICAgICAgICAgICAgPC9EZW1vPlxyXG5cclxuICAgICAgICAgICAgPERlbW8gdGl0bGU9XCJUZXh0IGZpZWxkIHdpdGggYSBzdWZmaXhcIj5cclxuICAgICAgICAgICAgICAgIDxUZXh0RmllbGRcclxuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0VmFsdWU9XCJcIlxyXG4gICAgICAgICAgICAgICAgICAgIGxhYmVsPVwiTGFiZWxcIlxyXG4gICAgICAgICAgICAgICAgICAgIHN1ZmZpeD1cIiRcIlxyXG4gICAgICAgICAgICAgICAgICAgIGZpbGxlZD17aXNGaWxsZWR9XHJcbiAgICAgICAgICAgICAgICAgICAgb3V0bGluZWQ9e2lzT3V0bGluZWR9XHJcbiAgICAgICAgICAgICAgICAvPlxyXG4gICAgICAgICAgICA8L0RlbW8+XHJcblxyXG4gICAgICAgICAgICA8RGVtbyB0aXRsZT1cIlRleHQgZmllbGQgd2l0aCBhIGxlYWRpbmcgaWNvblwiPlxyXG4gICAgICAgICAgICAgICAgPFRleHRGaWVsZFxyXG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHRWYWx1ZT1cIlwiXHJcbiAgICAgICAgICAgICAgICAgICAgbGVhZGluZ0ljb249XCJzdGFyXCJcclxuICAgICAgICAgICAgICAgICAgICBmaWxsZWQ9e2lzRmlsbGVkfVxyXG4gICAgICAgICAgICAgICAgICAgIG91dGxpbmVkPXtpc091dGxpbmVkfVxyXG4gICAgICAgICAgICAgICAgLz5cclxuICAgICAgICAgICAgPC9EZW1vPlxyXG5cclxuICAgICAgICAgICAgPERlbW8gdGl0bGU9XCJUZXh0IGZpZWxkIHdpdGggYSB0cmFpbGluZyBpY29uXCI+XHJcbiAgICAgICAgICAgICAgICA8VGV4dEZpZWxkXHJcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdFZhbHVlPVwiXCJcclxuICAgICAgICAgICAgICAgICAgICB0cmFpbGluZ0ljb249XCJlZGl0XCJcclxuICAgICAgICAgICAgICAgICAgICBmaWxsZWQ9e2lzRmlsbGVkfVxyXG4gICAgICAgICAgICAgICAgICAgIG91dGxpbmVkPXtpc091dGxpbmVkfVxyXG4gICAgICAgICAgICAgICAgLz5cclxuICAgICAgICAgICAgPC9EZW1vPlxyXG4gICAgICAgIDwvUGFnZT5cclxuICAgICk7XHJcbn0iLCJpbXBvcnQge1xyXG4gICAgSWNvbkJ1dHRvbixcclxuICAgIFRvb2x0aXAsIFJpY2hUb29sdGlwXHJcbn0gZnJvbSAnbWRjLXJlYWN0JztcclxuXHJcbmltcG9ydCBQYWdlIGZyb20gJ0AvY29tcG9uZW50cy9QYWdlJztcclxuaW1wb3J0IFNlY3Rpb24gZnJvbSAnQC9jb21wb25lbnRzL1NlY3Rpb24nO1xyXG5pbXBvcnQgQ29kZSBmcm9tICdAL2NvbXBvbmVudHMvQ29kZSc7XHJcblxyXG5jb25zdCBpZCA9ICd0b29sdGlwJztcclxuY29uc3QgdGl0bGUgPSAnVG9vbHRpcCc7XHJcbmNvbnN0IGRlc2NyaXB0aW9uID0gJ1Rvb2x0aXBzIGRpc3BsYXkgaW5mb3JtYXRpdmUgdGV4dCB3aGVuIHVzZXJzIGhvdmVyIG92ZXIsIGZvY3VzIG9uLCBvciB0YXAgYW4gZWxlbWVudC4nO1xyXG5jb25zdCBsaW5rcyA9IHtcclxuICAgIGRvY3M6ICdodHRwczovL2dpdGh1Yi5jb20vbWF0ZXJpYWwtY29tcG9uZW50cy9tYXRlcmlhbC1jb21wb25lbnRzLXdlYi90cmVlL21hc3Rlci9wYWNrYWdlcy9tZGMtdG9vbHRpcCcsXHJcbiAgICBndWlkZTogJ2h0dHBzOi8vbWF0ZXJpYWwuaW8vY29tcG9uZW50cy90b29sdGlwcydcclxufTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIFRvb2x0aXBQYWdlKCkge1xyXG4gICAgcmV0dXJuIChcclxuICAgICAgICA8UGFnZSBpZD17aWR9IHRpdGxlPXt0aXRsZX0gZGVzY3JpcHRpb249e2Rlc2NyaXB0aW9ufSBsaW5rcz17bGlua3N9PlxyXG4gICAgICAgICAgICA8U2VjdGlvbiB0aXRsZT1cIkJhc2ljIHRvb2x0aXBcIj5cclxuICAgICAgICAgICAgICAgIDxDb2RlPlxyXG4gICAgICAgICAgICAgICAgICAgIDxUb29sdGlwIGxhYmVsPVwiU3RhclwiPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8SWNvbkJ1dHRvbiBpY29uPVwic3RhclwiIC8+XHJcbiAgICAgICAgICAgICAgICAgICAgPC9Ub29sdGlwPlxyXG4gICAgICAgICAgICAgICAgPC9Db2RlPlxyXG4gICAgICAgICAgICA8L1NlY3Rpb24+XHJcblxyXG4gICAgICAgICAgICA8U2VjdGlvbiB0aXRsZT1cIk11bHRpbGluZSB0b29sdGlwXCI+XHJcbiAgICAgICAgICAgICAgICA8Q29kZT5cclxuICAgICAgICAgICAgICAgICAgICA8VG9vbHRpcCBsYWJlbD1cIlRoaXMgaXMgYSBzdGFyIGljb24gYnV0dG9uLCB5b3Ugc2hvdWxkIGNsaWNrIG9uIGl0XCI+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxJY29uQnV0dG9uIGljb249XCJzdGFyXCIgLz5cclxuICAgICAgICAgICAgICAgICAgICA8L1Rvb2x0aXA+XHJcbiAgICAgICAgICAgICAgICA8L0NvZGU+XHJcbiAgICAgICAgICAgIDwvU2VjdGlvbj5cclxuXHJcbiAgICAgICAgICAgIDxTZWN0aW9uIHRpdGxlPVwiUmljaCB0b29sdGlwXCI+XHJcbiAgICAgICAgICAgICAgICA8Q29kZT5cclxuICAgICAgICAgICAgICAgICAgICA8UmljaFRvb2x0aXBcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGU9XCJUaXRsZVwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ9XCJEZWZhdWx0IHJpY2ggdG9vbHRpcHMgYXJlIHNob3duIHdoZW4gdXNlcnMgaG92ZXIgb3ZlciBvciBmb2N1cyBvbiB0aGVpciBhbmNob3IgZWxlbWVudC4gVGhleSByZW1haW4gc2hvd24gd2hlbiB1c2VycyBmb2N1cy9ob3ZlciBvdmVyIHRoZSBjb250ZW50cyBvZiB0aGUgcmljaCB0b29sdGlwLCBidXQgYmVjb21lcyBoaWRkZW4gaWYgdGhlIHVzZXJzIGZvY3VzL2hvdmVyIG91dHNpZGUgb2YgdGhlIGFuY2hvciBlbGVtZW50IG9yIHRoZSB0b29sdGlwIGNvbnRlbnRzLiBJZiB0aGUgdXNlciBjbGlja3Mgd2l0aGluIHRoZSBjb250ZW50cyBvZiB0aGUgdG9vbHRpcCwgdGhlIHRvb2x0aXAgd2lsbCBhbHNvIGJlIGhpZGRlbi5cIlxyXG4gICAgICAgICAgICAgICAgICAgID5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPEljb25CdXR0b24gaWNvbj1cInN0YXJcIiAvPlxyXG4gICAgICAgICAgICAgICAgICAgIDwvUmljaFRvb2x0aXA+XHJcbiAgICAgICAgICAgICAgICA8L0NvZGU+XHJcbiAgICAgICAgICAgIDwvU2VjdGlvbj5cclxuICAgICAgICA8L1BhZ2U+XHJcbiAgICApO1xyXG59IiwiaW1wb3J0IHsgdXNlU3RhdGUgfSBmcm9tICdyZWFjdCc7XHJcbmltcG9ydCB7XHJcbiAgICBJY29uQnV0dG9uLFxyXG4gICAgVG9wQXBwQmFyXHJcbn0gZnJvbSAnbWRjLXJlYWN0JztcclxuXHJcbmltcG9ydCBQYWdlIGZyb20gJ0AvY29tcG9uZW50cy9QYWdlJztcclxuaW1wb3J0IFNlY3Rpb24gZnJvbSAnQC9jb21wb25lbnRzL1NlY3Rpb24nO1xyXG5pbXBvcnQgQ29kZSBmcm9tICdAL2NvbXBvbmVudHMvQ29kZSc7XHJcblxyXG5pbXBvcnQgJy4vaW5kZXguc2Nzcyc7XHJcblxyXG5jb25zdCBpZCA9ICd0b3AtYXBwLWJhcic7XHJcbmNvbnN0IHRpdGxlID0gJ1RvcCBBcHAgQmFyJztcclxuY29uc3QgZGVzY3JpcHRpb24gPSAnVGhlIHRvcCBhcHAgYmFyIGRpc3BsYXlzIGluZm9ybWF0aW9uIGFuZCBhY3Rpb25zIHJlbGF0aW5nIHRvIHRoZSBjdXJyZW50IHNjcmVlbi4nO1xyXG5jb25zdCBsaW5rcyA9IHtcclxuICAgIGRvY3M6ICdodHRwczovL2dpdGh1Yi5jb20vbWF0ZXJpYWwtY29tcG9uZW50cy9tYXRlcmlhbC1jb21wb25lbnRzLXdlYi90cmVlL21hc3Rlci9wYWNrYWdlcy9tZGMtdG9wLWFwcC1iYXInLFxyXG4gICAgZ3VpZGU6ICdodHRwczovL21hdGVyaWFsLmlvL2NvbXBvbmVudHMvYXBwLWJhcnMtdG9wJ1xyXG59O1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gVG9wQXBwQmFyUGFnZSgpIHtcclxuICAgIGNvbnN0IFtpc0NvbGxhcHNlZCwgc2V0Q29sbGFwc2VkXSA9IHVzZVN0YXRlKGZhbHNlKTtcclxuXHJcbiAgICBjb25zdCBhY3Rpb25JdGVtcyA9IFtcclxuICAgICAgICA8SWNvbkJ1dHRvbiBrZXk9XCJhZGRcIiBpY29uPVwiYWRkXCIgLz4sXHJcbiAgICAgICAgPEljb25CdXR0b24ga2V5PVwiZWRpdFwiIGljb249XCJlZGl0XCIgLz4sXHJcbiAgICAgICAgPEljb25CdXR0b24ga2V5PVwiZGVsZXRlXCIgaWNvbj1cImRlbGV0ZVwiIC8+XHJcbiAgICBdO1xyXG5cclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgPFBhZ2UgaWQ9e2lkfSB0aXRsZT17dGl0bGV9IGRlc2NyaXB0aW9uPXtkZXNjcmlwdGlvbn0gbGlua3M9e2xpbmtzfT5cclxuICAgICAgICAgICAgPFNlY3Rpb24+XHJcbiAgICAgICAgICAgICAgICA8Q29kZT5cclxuICAgICAgICAgICAgICAgICAgICA8VG9wQXBwQmFyXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlPVwiQmFzaWNcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBuYXZpZ2F0aW9uSWNvbj1cIm1lbnVcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBhY3Rpb25JdGVtcz17YWN0aW9uSXRlbXN9XHJcbiAgICAgICAgICAgICAgICAgICAgLz5cclxuICAgICAgICAgICAgICAgIDwvQ29kZT5cclxuICAgICAgICAgICAgPC9TZWN0aW9uPlxyXG5cclxuICAgICAgICAgICAgPFNlY3Rpb24+XHJcbiAgICAgICAgICAgICAgICA8Q29kZT5cclxuICAgICAgICAgICAgICAgICAgICA8VG9wQXBwQmFyXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlPVwiRGVuc2VcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBuYXZpZ2F0aW9uSWNvbj1cIm1lbnVcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBhY3Rpb25JdGVtcz17YWN0aW9uSXRlbXN9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbnNlXHJcbiAgICAgICAgICAgICAgICAgICAgLz5cclxuICAgICAgICAgICAgICAgIDwvQ29kZT5cclxuICAgICAgICAgICAgPC9TZWN0aW9uPlxyXG5cclxuICAgICAgICAgICAgPFNlY3Rpb24+XHJcbiAgICAgICAgICAgICAgICA8Q29kZT5cclxuICAgICAgICAgICAgICAgICAgICA8VG9wQXBwQmFyXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlPVwiUHJvbWluZW50XCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmF2aWdhdGlvbkljb249XCJtZW51XCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgYWN0aW9uSXRlbXM9e2FjdGlvbkl0ZW1zfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9taW5lbnRcclxuICAgICAgICAgICAgICAgICAgICAvPlxyXG4gICAgICAgICAgICAgICAgPC9Db2RlPlxyXG4gICAgICAgICAgICA8L1NlY3Rpb24+XHJcblxyXG4gICAgICAgICAgICA8U2VjdGlvbj5cclxuICAgICAgICAgICAgICAgIDxDb2RlPlxyXG4gICAgICAgICAgICAgICAgICAgIDxUb3BBcHBCYXJcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGU9XCJTaG9ydFwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hdmlnYXRpb25JY29uPVwibWVudVwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNob3J0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbGxhcHNlZD17aXNDb2xsYXBzZWR9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uTmF2aWdhdGlvbkljb25DbGljaz17KCkgPT4gc2V0Q29sbGFwc2VkKHYgPT4gIXYpfVxyXG4gICAgICAgICAgICAgICAgICAgIC8+XHJcbiAgICAgICAgICAgICAgICA8L0NvZGU+XHJcbiAgICAgICAgICAgIDwvU2VjdGlvbj5cclxuICAgICAgICA8L1BhZ2U+XHJcbiAgICApO1xyXG59IiwiaW1wb3J0IHtcclxuICAgIFR5cG9ncmFwaHlcclxufSBmcm9tICdtZGMtcmVhY3QnO1xyXG5cclxuaW1wb3J0IFBhZ2UgZnJvbSAnQC9jb21wb25lbnRzL1BhZ2UnO1xyXG5pbXBvcnQgU2VjdGlvbiBmcm9tICdAL2NvbXBvbmVudHMvU2VjdGlvbic7XHJcbmltcG9ydCBDb2RlIGZyb20gJ0AvY29tcG9uZW50cy9Db2RlJztcclxuXHJcbmNvbnN0IGlkID0gJ3R5cG9ncmFwaHknO1xyXG5jb25zdCB0aXRsZSA9ICdUeXBvZ3JhcGh5JztcclxuY29uc3QgZGVzY3JpcHRpb24gPSAnVHlwb2dyYXBoeSBleHByZXNzZXMgaGllcmFyY2h5IGFuZCBicmFuZCBwcmVzZW5jZS4nO1xyXG5jb25zdCBsaW5rcyA9IHtcclxuICAgIGRvY3M6ICdodHRwczovL2dpdGh1Yi5jb20vbWF0ZXJpYWwtY29tcG9uZW50cy9tYXRlcmlhbC1jb21wb25lbnRzLXdlYi90cmVlL21hc3Rlci9wYWNrYWdlcy9tZGMtdHlwb2dyYXBoeScsXHJcbiAgICBndWlkZTogJ2h0dHBzOi8vbWF0ZXJpYWwuaW8vZGVzaWduL3R5cG9ncmFwaHknXHJcbn07XHJcblxyXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBUeXBvZ3JhcGh5UGFnZSgpIHtcclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgPFBhZ2UgaWQ9e2lkfSB0aXRsZT17dGl0bGV9IGRlc2NyaXB0aW9uPXtkZXNjcmlwdGlvbn0gbGlua3M9e2xpbmtzfT5cclxuICAgICAgICAgICAgPFNlY3Rpb24+XHJcbiAgICAgICAgICAgICAgICA8Q29kZT5cclxuICAgICAgICAgICAgICAgICAgICA8VHlwb2dyYXBoeSB0eXBlPVwiaGVhZGxpbmUxXCIgbm9NYXJnaW4+SGVhZGxpbmUgMTwvVHlwb2dyYXBoeT5cclxuICAgICAgICAgICAgICAgIDwvQ29kZT5cclxuICAgICAgICAgICAgPC9TZWN0aW9uPlxyXG5cclxuICAgICAgICAgICAgPFNlY3Rpb24+XHJcbiAgICAgICAgICAgICAgICA8Q29kZT5cclxuICAgICAgICAgICAgICAgICAgICA8VHlwb2dyYXBoeSB0eXBlPVwiaGVhZGxpbmUyXCIgbm9NYXJnaW4+SGVhZGxpbmUgMjwvVHlwb2dyYXBoeT5cclxuICAgICAgICAgICAgICAgIDwvQ29kZT5cclxuICAgICAgICAgICAgPC9TZWN0aW9uPlxyXG5cclxuICAgICAgICAgICAgPFNlY3Rpb24+XHJcbiAgICAgICAgICAgICAgICA8Q29kZT5cclxuICAgICAgICAgICAgICAgICAgICA8VHlwb2dyYXBoeSB0eXBlPVwiaGVhZGxpbmUzXCIgbm9NYXJnaW4+SGVhZGxpbmUgMzwvVHlwb2dyYXBoeT5cclxuICAgICAgICAgICAgICAgIDwvQ29kZT5cclxuICAgICAgICAgICAgPC9TZWN0aW9uPlxyXG5cclxuICAgICAgICAgICAgPFNlY3Rpb24+XHJcbiAgICAgICAgICAgICAgICA8Q29kZT5cclxuICAgICAgICAgICAgICAgICAgICA8VHlwb2dyYXBoeSB0eXBlPVwiaGVhZGxpbmU0XCIgbm9NYXJnaW4+SGVhZGxpbmUgNDwvVHlwb2dyYXBoeT5cclxuICAgICAgICAgICAgICAgIDwvQ29kZT5cclxuICAgICAgICAgICAgPC9TZWN0aW9uPlxyXG5cclxuICAgICAgICAgICAgPFNlY3Rpb24+XHJcbiAgICAgICAgICAgICAgICA8Q29kZT5cclxuICAgICAgICAgICAgICAgICAgICA8VHlwb2dyYXBoeSB0eXBlPVwiaGVhZGxpbmU1XCIgbm9NYXJnaW4+SGVhZGxpbmUgNTwvVHlwb2dyYXBoeT5cclxuICAgICAgICAgICAgICAgIDwvQ29kZT5cclxuICAgICAgICAgICAgPC9TZWN0aW9uPlxyXG5cclxuICAgICAgICAgICAgPFNlY3Rpb24+XHJcbiAgICAgICAgICAgICAgICA8Q29kZT5cclxuICAgICAgICAgICAgICAgICAgICA8VHlwb2dyYXBoeSB0eXBlPVwiaGVhZGxpbmU2XCIgbm9NYXJnaW4+SGVhZGxpbmUgNjwvVHlwb2dyYXBoeT5cclxuICAgICAgICAgICAgICAgIDwvQ29kZT5cclxuICAgICAgICAgICAgPC9TZWN0aW9uPlxyXG5cclxuICAgICAgICAgICAgPFNlY3Rpb24+XHJcbiAgICAgICAgICAgICAgICA8Q29kZT5cclxuICAgICAgICAgICAgICAgICAgICA8VHlwb2dyYXBoeSB0eXBlPVwic3VidGl0bGUxXCIgbm9NYXJnaW4+U3VidGl0bGUgMTwvVHlwb2dyYXBoeT5cclxuICAgICAgICAgICAgICAgIDwvQ29kZT5cclxuICAgICAgICAgICAgPC9TZWN0aW9uPlxyXG5cclxuICAgICAgICAgICAgPFNlY3Rpb24+XHJcbiAgICAgICAgICAgICAgICA8Q29kZT5cclxuICAgICAgICAgICAgICAgICAgICA8VHlwb2dyYXBoeSB0eXBlPVwic3VidGl0bGUyXCIgbm9NYXJnaW4+U3VidGl0bGUgMjwvVHlwb2dyYXBoeT5cclxuICAgICAgICAgICAgICAgIDwvQ29kZT5cclxuICAgICAgICAgICAgPC9TZWN0aW9uPlxyXG5cclxuICAgICAgICAgICAgPFNlY3Rpb24+XHJcbiAgICAgICAgICAgICAgICA8Q29kZT5cclxuICAgICAgICAgICAgICAgICAgICA8VHlwb2dyYXBoeSB0eXBlPVwiYm9keTFcIiBub01hcmdpbj5Cb2R5IDE8L1R5cG9ncmFwaHk+XHJcbiAgICAgICAgICAgICAgICA8L0NvZGU+XHJcbiAgICAgICAgICAgIDwvU2VjdGlvbj5cclxuXHJcbiAgICAgICAgICAgIDxTZWN0aW9uPlxyXG4gICAgICAgICAgICAgICAgPENvZGU+XHJcbiAgICAgICAgICAgICAgICAgICAgPFR5cG9ncmFwaHkgdHlwZT1cImJvZHkyXCIgbm9NYXJnaW4+Qm9keSAyPC9UeXBvZ3JhcGh5PlxyXG4gICAgICAgICAgICAgICAgPC9Db2RlPlxyXG4gICAgICAgICAgICA8L1NlY3Rpb24+XHJcblxyXG4gICAgICAgICAgICA8U2VjdGlvbj5cclxuICAgICAgICAgICAgICAgIDxDb2RlPlxyXG4gICAgICAgICAgICAgICAgICAgIDxUeXBvZ3JhcGh5IHR5cGU9XCJjYXB0aW9uXCI+Q2FwdGlvbjwvVHlwb2dyYXBoeT5cclxuICAgICAgICAgICAgICAgIDwvQ29kZT5cclxuICAgICAgICAgICAgPC9TZWN0aW9uPlxyXG5cclxuICAgICAgICAgICAgPFNlY3Rpb24+XHJcbiAgICAgICAgICAgICAgICA8Q29kZT5cclxuICAgICAgICAgICAgICAgICAgICA8VHlwb2dyYXBoeSB0eXBlPVwiYnV0dG9uXCI+QnV0dG9uPC9UeXBvZ3JhcGh5PlxyXG4gICAgICAgICAgICAgICAgPC9Db2RlPlxyXG4gICAgICAgICAgICA8L1NlY3Rpb24+XHJcblxyXG4gICAgICAgICAgICA8U2VjdGlvbj5cclxuICAgICAgICAgICAgICAgIDxDb2RlPlxyXG4gICAgICAgICAgICAgICAgICAgIDxUeXBvZ3JhcGh5IHR5cGU9XCJvdmVybGluZVwiPk92ZXJsaW5lPC9UeXBvZ3JhcGh5PlxyXG4gICAgICAgICAgICAgICAgPC9Db2RlPlxyXG4gICAgICAgICAgICA8L1NlY3Rpb24+XHJcbiAgICAgICAgPC9QYWdlPlxyXG4gICAgKTtcclxufSIsImltcG9ydCBBdmF0YXIgZnJvbSAnLi9BdmF0YXInO1xyXG5pbXBvcnQgQmFkZ2UgZnJvbSAnLi9CYWRnZSc7XHJcbmltcG9ydCBCYW5uZXIgZnJvbSAnLi9CYW5uZXInO1xyXG5pbXBvcnQgQnV0dG9uIGZyb20gJy4vQnV0dG9uJztcclxuaW1wb3J0IENhcmQgZnJvbSAnLi9DYXJkJztcclxuaW1wb3J0IENoZWNrYm94IGZyb20gJy4vQ2hlY2tib3gnO1xyXG5pbXBvcnQgQ2hpcHMgZnJvbSAnLi9DaGlwcyc7XHJcbmltcG9ydCBDaXJjdWxhclByb2dyZXNzIGZyb20gJy4vQ2lyY3VsYXJQcm9ncmVzcyc7XHJcbmltcG9ydCBEYXRhVGFibGUgZnJvbSAnLi9EYXRhVGFibGUnO1xyXG5pbXBvcnQgRGlhbG9nIGZyb20gJy4vRGlhbG9nJztcclxuaW1wb3J0IERyYXdlciBmcm9tICcuL0RyYXdlcic7XHJcbmltcG9ydCBFbGV2YXRpb24gZnJvbSAnLi9FbGV2YXRpb24nO1xyXG5pbXBvcnQgRkFCIGZyb20gJy4vRkFCJztcclxuaW1wb3J0IEZvcm1GaWVsZCBmcm9tICcuL0Zvcm1GaWVsZCc7XHJcbmltcG9ydCBIb21lIGZyb20gJy4vSG9tZSc7XHJcbmltcG9ydCBJY29uQnV0dG9uIGZyb20gJy4vSWNvbkJ1dHRvbic7XHJcbmltcG9ydCBJbWFnZUxpc3QgZnJvbSAnLi9JbWFnZUxpc3QnO1xyXG5pbXBvcnQgTGF5b3V0R3JpZCBmcm9tICcuL0xheW91dEdyaWQnO1xyXG5pbXBvcnQgTGluZWFyUHJvZ3Jlc3MgZnJvbSAnLi9MaW5lYXJQcm9ncmVzcyc7XHJcbmltcG9ydCBMaXN0IGZyb20gJy4vTGlzdCc7XHJcbmltcG9ydCBNZW51IGZyb20gJy4vTWVudSc7XHJcbmltcG9ydCBSYWRpbyBmcm9tICcuL1JhZGlvJztcclxuaW1wb3J0IFJpcHBsZSBmcm9tICcuL1JpcHBsZSc7XHJcbmltcG9ydCBTZWdtZW50ZWRCdXR0b24gZnJvbSAnLi9TZWdtZW50ZWRCdXR0b24nO1xyXG5pbXBvcnQgU2VsZWN0IGZyb20gJy4vU2VsZWN0JztcclxuaW1wb3J0IFNpZGVTaGVldCBmcm9tICcuL1NpZGVTaGVldCc7XHJcbmltcG9ydCBTbGlkZXIgZnJvbSAnLi9TbGlkZXInO1xyXG5pbXBvcnQgU25hY2tiYXIgZnJvbSAnLi9TbmFja2Jhcic7XHJcbmltcG9ydCBTd2l0Y2ggZnJvbSAnLi9Td2l0Y2gnO1xyXG5pbXBvcnQgVGFicyBmcm9tICcuL1RhYnMnO1xyXG5pbXBvcnQgVGV4dEZpZWxkIGZyb20gJy4vVGV4dEZpZWxkJztcclxuaW1wb3J0IFRvb2x0aXAgZnJvbSAnLi9Ub29sdGlwJztcclxuaW1wb3J0IFRvcEFwcEJhciBmcm9tICcuL1RvcEFwcEJhcic7XHJcbmltcG9ydCBUeXBvZ3JhcGh5IGZyb20gJy4vVHlwb2dyYXBoeSc7XHJcblxyXG5leHBvcnQge1xyXG4gICAgQXZhdGFyLFxyXG4gICAgQmFkZ2UsXHJcbiAgICBCYW5uZXIsXHJcbiAgICBCdXR0b24sXHJcbiAgICBDYXJkLFxyXG4gICAgQ2hlY2tib3gsXHJcbiAgICBDaGlwcyxcclxuICAgIENpcmN1bGFyUHJvZ3Jlc3MsXHJcbiAgICBEYXRhVGFibGUsXHJcbiAgICBEaWFsb2csXHJcbiAgICBEcmF3ZXIsXHJcbiAgICBFbGV2YXRpb24sXHJcbiAgICBGQUIsXHJcbiAgICBGb3JtRmllbGQsXHJcbiAgICBIb21lLFxyXG4gICAgSWNvbkJ1dHRvbixcclxuICAgIEltYWdlTGlzdCxcclxuICAgIExheW91dEdyaWQsXHJcbiAgICBMaW5lYXJQcm9ncmVzcyxcclxuICAgIExpc3QsXHJcbiAgICBNZW51LFxyXG4gICAgUmFkaW8sXHJcbiAgICBSaXBwbGUsXHJcbiAgICBTZWdtZW50ZWRCdXR0b24sXHJcbiAgICBTZWxlY3QsXHJcbiAgICBTaWRlU2hlZXQsXHJcbiAgICBTbGlkZXIsXHJcbiAgICBTbmFja2JhcixcclxuICAgIFN3aXRjaCxcclxuICAgIFRhYnMsXHJcbiAgICBUZXh0RmllbGQsXHJcbiAgICBUb29sdGlwLFxyXG4gICAgVG9wQXBwQmFyLFxyXG4gICAgVHlwb2dyYXBoeVxyXG59OyIsImltcG9ydCB7XHJcbiAgICBBdmF0YXIsXHJcbiAgICBCYWRnZSxcclxuICAgIEJhbm5lcixcclxuICAgIEJ1dHRvbixcclxuICAgIENhcmQsXHJcbiAgICBDaGVja2JveCxcclxuICAgIENoaXBzLFxyXG4gICAgQ2lyY3VsYXJQcm9ncmVzcyxcclxuICAgIERhdGFUYWJsZSxcclxuICAgIERpYWxvZyxcclxuICAgIERyYXdlcixcclxuICAgIEVsZXZhdGlvbixcclxuICAgIEZBQixcclxuICAgIEZvcm1GaWVsZCxcclxuICAgIEljb25CdXR0b24sXHJcbiAgICBJbWFnZUxpc3QsXHJcbiAgICBMYXlvdXRHcmlkLFxyXG4gICAgTGluZWFyUHJvZ3Jlc3MsXHJcbiAgICBMaXN0LFxyXG4gICAgTWVudSxcclxuICAgIFJhZGlvLFxyXG4gICAgUmlwcGxlLFxyXG4gICAgU2VnbWVudGVkQnV0dG9uLFxyXG4gICAgU2VsZWN0LFxyXG4gICAgU2lkZVNoZWV0LFxyXG4gICAgU2xpZGVyLFxyXG4gICAgU25hY2tiYXIsXHJcbiAgICBTd2l0Y2gsXHJcbiAgICBUYWJzLFxyXG4gICAgVGV4dEZpZWxkLFxyXG4gICAgVG9vbHRpcCxcclxuICAgIFRvcEFwcEJhcixcclxuICAgIFR5cG9ncmFwaHlcclxufSBmcm9tICcuL3BhZ2VzJztcclxuXHJcbmV4cG9ydCBkZWZhdWx0IFtcclxuICAgIHsgdGl0bGU6ICdBdmF0YXInLCB1cmw6ICcvYXZhdGFyJywgY29tcG9uZW50OiBBdmF0YXIgfSxcclxuICAgIHsgdGl0bGU6ICdCYWRnZScsIHVybDogJy9iYWRnZScsIGNvbXBvbmVudDogQmFkZ2UgfSxcclxuICAgIHsgdGl0bGU6ICdCYW5uZXInLCB1cmw6ICcvYmFubmVyJywgY29tcG9uZW50OiBCYW5uZXIsIGltYWdlVXJsOiAnaHR0cHM6Ly9saDMuZ29vZ2xldXNlcmNvbnRlbnQuY29tL3RPWmRXYmZXdEljNUdIVFdzVzBEYXFqNUk2bENDclVOOC1ZdUVWalNuODdKTk42eDZQRWpmbW5lLWdwQm80akhCSTRncUxtaTBrTFZwdWJGNDFaVDJtTThnbGtMem8yaVdnS18talk9dzc2MC1oMzgwJyB9LFxyXG4gICAgeyB0aXRsZTogJ0J1dHRvbicsIHVybDogJy9idXR0b24nLCBjb21wb25lbnQ6IEJ1dHRvbiwgaW1hZ2VVcmw6ICdodHRwczovL2xoMy5nb29nbGV1c2VyY29udGVudC5jb20vR0hSei01UzAwdTdXa1JHbDhpVW04ZXpvUjZlb0IyTkp6dHUtdHJKdjNyYU1EdnBTQUNlUTVPMEtPb0FHN1NSSEpORE1fbVQwNEhlaTFOd2pUTi1ac0lGbXNfYnNRNHp4Unl4ZFFRPXc3NjAtaDM4MCcgfSxcclxuICAgIHsgdGl0bGU6ICdDYXJkJywgdXJsOiAnL2NhcmQnLCBjb21wb25lbnQ6IENhcmQsIGltYWdlVXJsOiAnaHR0cHM6Ly9saDMuZ29vZ2xldXNlcmNvbnRlbnQuY29tL0Z5RTNxakd3d25vZU1naXlPdUl4ZHhUUVFNOUNyMGZ0TmFrT1hPQThjcDEzN3JLTjA5QkZIcmFFUm0xTlBVRkJUR3hWZ2Noa2RsNlVBQmMxMVpjSkRNTDR1aTQ2NlcyQkZJeGM5UT13NzYwLWgzODAnIH0sXHJcbiAgICB7IHRpdGxlOiAnQ2hlY2tib3gnLCB1cmw6ICcvY2hlY2tib3gnLCBjb21wb25lbnQ6IENoZWNrYm94IH0sXHJcbiAgICB7IHRpdGxlOiAnQ2hpcHMnLCB1cmw6ICcvY2hpcHMnLCBjb21wb25lbnQ6IENoaXBzIH0sXHJcbiAgICB7IHRpdGxlOiAnQ2lyY3VsYXIgUHJvZ3Jlc3MnLCB1cmw6ICcvY2lyY3VsYXItcHJvZ3Jlc3MnLCBjb21wb25lbnQ6IENpcmN1bGFyUHJvZ3Jlc3MgfSxcclxuICAgIHsgdGl0bGU6ICdEYXRhVGFibGUnLCB1cmw6ICcvZGF0YS10YWJsZScsIGNvbXBvbmVudDogRGF0YVRhYmxlIH0sXHJcbiAgICB7IHRpdGxlOiAnRGlhbG9nJywgdXJsOiAnL2RpYWxvZycsIGNvbXBvbmVudDogRGlhbG9nIH0sXHJcbiAgICB7IHRpdGxlOiAnRHJhd2VyJywgdXJsOiAnL2RyYXdlcicsIGNvbXBvbmVudDogRHJhd2VyIH0sXHJcbiAgICB7IHRpdGxlOiAnRWxldmF0aW9uJywgdXJsOiAnL2VsZXZhdGlvbicsIGNvbXBvbmVudDogRWxldmF0aW9uIH0sXHJcbiAgICB7IHRpdGxlOiAnRkFCJywgdXJsOiAnL2ZhYicsIGNvbXBvbmVudDogRkFCLCBpbWFnZVVybDogJ2h0dHBzOi8vbGgzLmdvb2dsZXVzZXJjb250ZW50LmNvbS9UOGRsWXphYVUyU1Y4Nng2bHFOTWpsSGNyRmRLdjg1UU1XMVVuSlNoR3drbFJReXVVcVpJa2xPam5FdXFyWnpGMWg4NG9ocnp6MklUYWpiVDlJZGxqb2ZORm1QNWNzRXE2RzdXPXc3NjAtaDM4MCcgfSxcclxuICAgIHsgdGl0bGU6ICdGb3JtIEZpZWxkJywgdXJsOiAnL2Zvcm0tZmllbGQnLCBjb21wb25lbnQ6IEZvcm1GaWVsZCB9LFxyXG4gICAgeyB0aXRsZTogJ0ljb24gQnV0dG9uJywgdXJsOiAnL2ljb24tYnV0dG9uJywgY29tcG9uZW50OiBJY29uQnV0dG9uIH0sXHJcbiAgICB7IHRpdGxlOiAnSW1hZ2UgTGlzdCcsIHVybDogJy9pbWFnZS1saXN0JywgY29tcG9uZW50OiBJbWFnZUxpc3QgfSxcclxuICAgIHsgdGl0bGU6ICdMYXlvdXQgR3JpZCcsIHVybDogJy9sYXlvdXQtZ3JpZCcsIGNvbXBvbmVudDogTGF5b3V0R3JpZCB9LFxyXG4gICAgeyB0aXRsZTogJ0xpbmVhciBQcm9ncmVzcycsIHVybDogJy9saW5lYXItcHJvZ3Jlc3MnLCBjb21wb25lbnQ6IExpbmVhclByb2dyZXNzIH0sXHJcbiAgICB7IHRpdGxlOiAnTGlzdCcsIHVybDogJy9saXN0JywgY29tcG9uZW50OiBMaXN0IH0sXHJcbiAgICB7IHRpdGxlOiAnTWVudScsIHVybDogJy9tZW51JywgY29tcG9uZW50OiBNZW51IH0sXHJcbiAgICB7IHRpdGxlOiAnUmFkaW8nLCB1cmw6ICcvcmFkaW8nLCBjb21wb25lbnQ6IFJhZGlvIH0sXHJcbiAgICB7IHRpdGxlOiAnUmlwcGxlJywgdXJsOiAnL3JpcHBsZScsIGNvbXBvbmVudDogUmlwcGxlIH0sXHJcbiAgICB7IHRpdGxlOiAnU2VnbWVudGVkIEJ1dHRvbicsIHVybDogJy9zZWdtZW50ZWQtYnV0dG9uJywgY29tcG9uZW50OiBTZWdtZW50ZWRCdXR0b24sIGltYWdlVXJsOiAnJyB9LFxyXG4gICAgeyB0aXRsZTogJ1NlbGVjdCcsIHVybDogJy9zZWxlY3QnLCBjb21wb25lbnQ6IFNlbGVjdCwgaW1hZ2VVcmw6ICcnIH0sXHJcbiAgICB7IHRpdGxlOiAnU2lkZSBTaGVldCcsIHVybDogJy9zaWRlLXNoZWV0JywgY29tcG9uZW50OiBTaWRlU2hlZXQsIGltYWdlVXJsOiAnJyB9LFxyXG4gICAgeyB0aXRsZTogJ1NsaWRlcicsIHVybDogJy9zbGlkZXInLCBjb21wb25lbnQ6IFNsaWRlciwgaW1hZ2VVcmw6ICdodHRwczovL2xoMy5nb29nbGV1c2VyY29udGVudC5jb20vdzZuTmVMY2pwWHlwbzJVNl9ndnVuVWVzZ1ROT0FxekV6YjVaenh4VDRBeUdIX01fTF9FSHJ5Ymc5c0pOZzc4QkRIeWVDUElRQ2UzSGsyc1RnbFUwRVFlN2NPQnNxVU1GaWNxMWxnPXc3NjAtaDM4MCcgfSxcclxuICAgIHsgdGl0bGU6ICdTbmFja2JhcicsIHVybDogJy9zbmFja2JhcicsIGNvbXBvbmVudDogU25hY2tiYXIsIGltYWdlVXJsOiAnaHR0cHM6Ly9saDMuZ29vZ2xldXNlcmNvbnRlbnQuY29tL2ZHZ1pQRE9zelRELTJSZUFDODVsNW9wN3dDRTN1dm5QdGExM0FpYjJiU2x6TjhMWG9OWWxERzZmWTVEWTFxS3FiTFRiR0dseDlWZ2FoVURkakRnZGpxOHNKTnFvSVk0LUdQeEtSQT13NzYwLWgzODAnIH0sXHJcbiAgICB7IHRpdGxlOiAnU3dpdGNoJywgdXJsOiAnL3N3aXRjaCcsIGNvbXBvbmVudDogU3dpdGNoIH0sXHJcbiAgICB7IHRpdGxlOiAnVGFicycsIHVybDogJy90YWJzJywgY29tcG9uZW50OiBUYWJzLCBpbWFnZVVybDogJ2h0dHBzOi8vbGgzLmdvb2dsZXVzZXJjb250ZW50LmNvbS9BWUZwMlZtTW45bnNseDE4TTZFczlDNTdTN3AzemtpUVZMbDNQSHZNdS1PcGJ2SzFGbExKTjJNSGZGTlpmbWZNQ2sxZHJDdzg0RktlYno1U1RKN1FONjlJSGhIOVdGMUtrbGlyPXc3NjAtaDM4MCcgfSxcclxuICAgIHsgdGl0bGU6ICdUZXh0IEZpZWxkJywgdXJsOiAnL3RleHQtZmllbGQnLCBjb21wb25lbnQ6IFRleHRGaWVsZCwgaW1hZ2VVcmw6ICdodHRwczovL2xoMy5nb29nbGV1c2VyY29udGVudC5jb20vTHhiX2paZlhrQVNaMURDek5oeVMzSUc3bUlzUGhCVm1hWDIwSG43WG53cFNfUG85d1FJQy01ckV3VXNZbGI1VGtnTWpxSTQ1LWoxdzRpNFdNNHdTbEEtYjBxS3RtSjY5aFYwaj13NzYwLWgzODAnIH0sXHJcbiAgICB7IHRpdGxlOiAnVG9vbHRpcCcsIHVybDogJy90b29sdGlwJywgY29tcG9uZW50OiBUb29sdGlwLCBpbWFnZVVybDogJ2h0dHBzOi8vbGgzLmdvb2dsZXVzZXJjb250ZW50LmNvbS9Bc20xS0hQc1VELUdERGdsY0l0enZsMkxLV3N5ck16S01yV0RBNXNpSGFGN1BBdm5nbmlTNTdQTVpUSEZzREhrSHNqVDlkUFdDNXRFcFJCRzdpNXN5WjdzYlJpUnBMOW9FODRGPXc3NjAtaDM4MCcgfSxcclxuICAgIHsgdGl0bGU6ICdUb3AgQXBwIEJhcicsIHVybDogJy90b3AtYXBwLWJhcicsIGNvbXBvbmVudDogVG9wQXBwQmFyLCBpbWFnZVVybDogJ2h0dHBzOi8vbGgzLmdvb2dsZXVzZXJjb250ZW50LmNvbS9lb3Q5NmEtcWpBcjBReXBLS2YtNnFTSkdRUXFXMDg2LUdWMnZ2MEQ5RjM1OC1WRmlKU1dpZmc2LXEzOHZiSV9Kc3hDUG5iSk56akNIMTJPRkRYSkJ6U2NCM2hfX0hYTHdLV2tqWUE9dzc2MC1oMzgwJyB9LFxyXG4gICAgeyB0aXRsZTogJ1R5cG9ncmFwaHknLCB1cmw6ICcvdHlwb2dyYXBoeScsIGNvbXBvbmVudDogVHlwb2dyYXBoeSB9LFxyXG5dOyIsImltcG9ydCB7IFJvdXRlLCBMaW5rLCBOYXZMaW5rLCBTd2l0Y2ggfSBmcm9tICdyZWFjdC1yb3V0ZXItZG9tJztcclxuaW1wb3J0IHtcclxuICAgIERyYXdlcixcclxuICAgIEljb25CdXR0b24sXHJcbiAgICBMaXN0LFxyXG4gICAgVG9wQXBwQmFyXHJcbn0gZnJvbSAnbWRjLXJlYWN0JztcclxuXHJcbmltcG9ydCByb3V0ZXMgZnJvbSAnLi9yb3V0ZXMnO1xyXG5pbXBvcnQgeyBIb21lIH0gZnJvbSAnLi9wYWdlcyc7XHJcblxyXG5pbXBvcnQgJy4vQXBwLnNjc3MnO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gQXBwKCkge1xyXG4gICAgcmV0dXJuIChcclxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImFwcFwiPlxyXG4gICAgICAgICAgICA8VG9wQXBwQmFyXHJcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU9XCJhcHAtdG9wLWJhclwiXHJcbiAgICAgICAgICAgICAgICBuYXZpZ2F0aW9uSWNvbj17XHJcbiAgICAgICAgICAgICAgICAgICAgPEljb25CdXR0b25cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWNvbj17XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8TGluayB0bz1cIi9cIj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8aW1nIHNyYz1cImh0dHBzOi8vbWF0ZXJpYWwtY29tcG9uZW50cy5naXRodWIuaW8vbWF0ZXJpYWwtY29tcG9uZW50cy13ZWItY2F0YWxvZy9zdGF0aWMvbWVkaWEvaWNfY29tcG9uZW50XzI0cHhfd2hpdGUuc3ZnXCIgYWx0PVwiXCIgLz5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvTGluaz5cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIC8+XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aXRsZT1cIk1EQyBSZWFjdFwiXHJcbiAgICAgICAgICAgICAgICBhY3Rpb25JdGVtcz17W1xyXG4gICAgICAgICAgICAgICAgICAgIDxJY29uQnV0dG9uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleT1cImNvZGVcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50PVwiYVwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGhyZWY9XCJodHRwczovL2dpdGh1Yi5jb20vb2xlZ3BvbHlha292L21kYy1yZWFjdFwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldD1cIl9ibGFua1wiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGljb249XCJjb2RlXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGU9XCJDb2RlXCJcclxuICAgICAgICAgICAgICAgICAgICAvPixcclxuICAgICAgICAgICAgICAgICAgICA8SWNvbkJ1dHRvblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBrZXk9XCJpc3N1ZXNcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50PVwiYVwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGhyZWY9XCJodHRwczovL2dpdGh1Yi5jb20vb2xlZ3BvbHlha292L21kYy1yZWFjdC9pc3N1ZXNcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXQ9XCJfYmxhbmtcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpY29uPVwiYnVnX3JlcG9ydFwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlPVwiSXNzdWVzXCJcclxuICAgICAgICAgICAgICAgICAgICAvPixcclxuICAgICAgICAgICAgICAgICAgICA8SWNvbkJ1dHRvblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBrZXk9XCJkaXNjdXNzaW9uc1wiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnQ9XCJhXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgaHJlZj1cImh0dHBzOi8vZ2l0aHViLmNvbS9vbGVncG9seWFrb3YvbWRjLXJlYWN0L2Rpc2N1c3Npb25zXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0PVwiX2JsYW5rXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWNvbj1cImZvcnVtXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGU9XCJEaXNjdXNzaW9uc1wiXHJcbiAgICAgICAgICAgICAgICAgICAgLz5cclxuICAgICAgICAgICAgICAgIF19XHJcbiAgICAgICAgICAgIC8+XHJcblxyXG4gICAgICAgICAgICA8RHJhd2VyIGNsYXNzTmFtZT1cImFwcC1kcmF3ZXJcIiBkaXNtaXNzaWJsZSBvcGVuPlxyXG4gICAgICAgICAgICAgICAgPERyYXdlci5Db250ZW50PlxyXG4gICAgICAgICAgICAgICAgICAgIDxMaXN0IGVsZW1lbnQ9XCJuYXZcIj5cclxuICAgICAgICAgICAgICAgICAgICAgICAge3JvdXRlcy5tYXAocm91dGUgPT5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxMaXN0Lkl0ZW1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZXk9e3JvdXRlLnVybH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21wb25lbnQ9e05hdkxpbmt9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG89e3JvdXRlLnVybH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmltYXJ5VGV4dD17cm91dGUudGl0bGV9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWN0aXZlQ2xhc3NOYW1lPVwibWRjLWxpc3QtaXRlbS0tYWN0aXZhdGVkXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICl9XHJcbiAgICAgICAgICAgICAgICAgICAgPC9MaXN0PlxyXG4gICAgICAgICAgICAgICAgPC9EcmF3ZXIuQ29udGVudD5cclxuICAgICAgICAgICAgPC9EcmF3ZXI+XHJcblxyXG4gICAgICAgICAgICA8bWFpbiBjbGFzc05hbWU9XCJhcHAtY29udGVudCBtZGMtZHJhd2VyLWFwcC1jb250ZW50XCI+XHJcbiAgICAgICAgICAgICAgICA8U3dpdGNoPlxyXG4gICAgICAgICAgICAgICAgICAgIDxSb3V0ZSBleGFjdCBwYXRoPVwiL1wiIGNvbXBvbmVudD17SG9tZX0gLz5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAge3JvdXRlcy5tYXAocm91dGUgPT5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPFJvdXRlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZXk9e3JvdXRlLnVybH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhdGg9e3JvdXRlLnVybH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4YWN0PXtyb3V0ZS5leGFjdH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudD17cm91dGUuY29tcG9uZW50fVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvPlxyXG4gICAgICAgICAgICAgICAgICAgICl9XHJcbiAgICAgICAgICAgICAgICA8L1N3aXRjaD5cclxuICAgICAgICAgICAgPC9tYWluPlxyXG4gICAgICAgIDwvZGl2PlxyXG4gICAgKTtcclxufSIsImltcG9ydCB7IEJyb3dzZXJSb3V0ZXIgYXMgUm91dGVyIH0gZnJvbSAncmVhY3Qtcm91dGVyLWRvbSc7XHJcbmltcG9ydCB7IHJlbmRlciB9IGZyb20gJ3JlYWN0LWRvbSc7XHJcblxyXG5pbXBvcnQgQXBwIGZyb20gJy4vQXBwJztcclxuXHJcbmltcG9ydCAnLi9pbmRleC5zY3NzJztcclxuXHJcbmNvbnN0IGJhc2VuYW1lID0gcHJvY2Vzcy5lbnYuRU5WLnByb2R1Y3Rpb24gPyAnbWRjLXJlYWN0JyA6IHVuZGVmaW5lZDtcclxuXHJcbnJlbmRlcihcclxuICAgIDxSb3V0ZXIgYmFzZW5hbWU9e2Jhc2VuYW1lfT5cclxuICAgICAgICA8QXBwIC8+XHJcbiAgICA8L1JvdXRlcj4sXHJcbiAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjcm9vdCcpXHJcbik7Il0sIm5hbWVzIjpbImlzVmFsaWRFbGVtZW50IiwiZm9yd2FyZFJlZiIsImNsb25lRWxlbWVudCIsImNyZWF0ZUVsZW1lbnQiLCJjbGFzc25hbWVzIiwiY3JlYXRlQ29tcG9uZW50IiwiZm4iLCJkaXNwbGF5TmFtZSIsInByb3BUeXBlcyIsImRlZmF1bHRQcm9wcyIsIkNvbXBvbmVudCIsImxlbmd0aCIsIkNsb25lIiwicmVmIiwiY29tcG9uZW50IiwiZmFsbGJhY2siLCJjbGFzc05hbWUiLCJjaGlsZHJlbiIsInByb3BzIiwiaXNFbGVtZW50IiwiY2xvbmUiLCJjcmVhdGUiLCJjc3NDbGFzc2VzIiwiUk9PVCIsIk1BVEVSSUFMX0lDT05TIiwiTElHSFQiLCJEQVJLIiwiSU5BQ1RJVkUiLCJQcm9wVHlwZXMiLCJJY29uIiwic2l6ZSIsImxpZ2h0IiwiZGFyayIsImluYWN0aXZlIiwiZWxlbWVudCIsIkVsZW1lbnQiLCJjbGFzc05hbWVzIiwic3RyaW5nIiwiYm9vbCIsImRlZmF1bHQiLCJTTUFMTCIsIk1FRElVTSIsIkxBUkdFIiwiSU1BR0UiLCJJQ09OIiwiVEVYVCIsIkF2YXRhciIsImltYWdlIiwiaWNvbiIsInRleHQiLCJzcmMiLCJhbHQiLCJub2RlIiwib25lT2YiLCJJTlNFVCIsIlRSQU5TUEFSRU5UIiwiQmFkZ2UiLCJ2YWx1ZSIsImluc2V0IiwidHJhbnNwYXJlbnQiLCJvbmVPZlR5cGUiLCJudW1iZXIiLCJpc1JlcXVpcmVkIiwibnVtYmVycyIsIkJBTk5FUl9BTklNQVRJT05fQ0xPU0VfVElNRV9NUyIsIkJBTk5FUl9BTklNQVRJT05fT1BFTl9USU1FX01TIiwiRklYRUQiLCJDRU5URVJFRCIsIk1PQklMRV9TVEFDS0VEIiwiQVBQRUFSSU5HIiwiQVBQRUFSRUQiLCJPUEVOSU5HIiwiT1BFTiIsIkNMT1NJTkciLCJDT05URU5UIiwiR1JBUEhJQ19URVhUX1dSQVBQRVIiLCJHUkFQSElDIiwiQUNUSU9OUyIsIlBSSU1BUllfQUNUSU9OIiwiU0VDT05EQVJZX0FDVElPTiIsInVzZVJlZiIsInVzZUNhbGxiYWNrIiwidXNlSW1wZXJhdGl2ZUhhbmRsZSIsIkNTU1RyYW5zaXRpb24iLCJCYW5uZXIiLCJncmFwaGljIiwiYWN0aW9uIiwicHJpbWFyeUFjdGlvbiIsInNlY29uZGFyeUFjdGlvbiIsIm9wZW4iLCJjZW50ZXJlZCIsImZpeGVkIiwibW9iaWxlU3RhY2tlZCIsInJvb3RSZWYiLCJjb250ZW50UmVmIiwiY3VycmVudCIsImhhbmRsZUVudGVyaW5nIiwiaXNBcHBlYXJpbmciLCJzdHlsZSIsImhlaWdodCIsIm9mZnNldEhlaWdodCIsImhhbmRsZUV4aXRpbmciLCJjb250ZW50IiwiYXBwZWFyIiwiZW50ZXIiLCJleGl0IiwiYXBwZWFyRG9uZSIsImVudGVyQWN0aXZlIiwiZW50ZXJEb25lIiwiUkFJU0VEIiwiVU5FTEVWQVRFRCIsIk9VVExJTkVEIiwiVE9VQ0giLCJJQ09OX0xFQURJTkciLCJJQ09OX1RSQUlMSU5HIiwiUklQUExFIiwiTEFCRUwiLCJUT1VDSF9FTEVNRU5UIiwiQnV0dG9uIiwibGFiZWwiLCJsZWFkaW5nSWNvbiIsInRyYWlsaW5nSWNvbiIsInJhaXNlZCIsInVuZWxldmF0ZWQiLCJvdXRsaW5lZCIsInRvdWNoIiwiQm9vbGVhbiIsIlRJVExFIiwiU1VCVElUTEUiLCJPVkVSTElORSIsIkFDVElPTlNfRlVMTF9CTEVFRCIsIkFDVElPTl9CVVRUT05TIiwiQUNUSU9OX0lDT05TIiwiQUNUSU9OIiwiQUNUSU9OX0JVVFRPTiIsIkFDVElPTl9JQ09OIiwiSEVBREVSIiwiSEVBREVSX0dSQVBISUMiLCJIRUFERVJfQ09OVEVOVCIsIkhFQURFUl9BQ1RJT05TIiwiTUVESUEiLCJNRURJQV9TUVVBUkUiLCJNRURJQV9XSURFIiwiTUVESUFfQ09OVEVOVCIsIlNFQ1RJT04iLCJTRUNUSU9OX1BSSU1BUlkiLCJTRUNUSU9OX1NFQ09OREFSWSIsIkNhcmQiLCJDYXJkQWN0aW9uIiwiYnV0dG9uIiwiQ2FyZEFjdGlvbnMiLCJmdWxsQmxlZWQiLCJDYXJkQWN0aW9uQnV0dG9ucyIsIkNhcmRBY3Rpb25JY29ucyIsIkNoaWxkcmVuIiwiQ2FyZEhlYWRlciIsInRpdGxlIiwic3VidGl0bGUiLCJvdmVybGluZSIsImFjdGlvbnMiLCJtYXAiLCJhcnJheU9mIiwiQ2FyZE1lZGlhIiwiaW1hZ2VVcmwiLCJzcXVhcmUiLCJ3aWRlIiwiYmFja2dyb3VuZEltYWdlIiwidW5kZWZpbmVkIiwiQ2FyZFByaW1hcnlBY3Rpb24iLCJDYXJkU2VjdGlvbiIsInByaW1hcnkiLCJzZWNvbmRhcnkiLCJBY3Rpb24iLCJBY3Rpb25zIiwiQWN0aW9uQnV0dG9ucyIsIkFjdGlvbkljb25zIiwiSGVhZGVyIiwiTWVkaWEiLCJQcmltYXJ5QWN0aW9uIiwiU2VjdGlvbiIsIlNFTEVDVEVEIiwiRElTQUJMRUQiLCJBTklNX0NIRUNLRURfSU5ERVRFUk1JTkFURSIsIkFOSU1fQ0hFQ0tFRF9VTkNIRUNLRUQiLCJBTklNX0lOREVURVJNSU5BVEVfQ0hFQ0tFRCIsIkFOSU1fSU5ERVRFUk1JTkFURV9VTkNIRUNLRUQiLCJBTklNX1VOQ0hFQ0tFRF9DSEVDS0VEIiwiQU5JTV9VTkNIRUNLRURfSU5ERVRFUk1JTkFURSIsIk5BVElWRV9DT05UUk9MIiwiQkFDS0dST1VORCIsIkNIRUNLTUFSSyIsIkNIRUNLTUFSS19QQVRIIiwiTUlYRURNQVJLIiwidXNlRWZmZWN0IiwiQ2hlY2tib3giLCJjaGVja2VkIiwiaW5kZXRlcm1pbmF0ZSIsImRpc2FibGVkIiwib25DaGFuZ2UiLCJGdW5jdGlvbiIsInByb3RvdHlwZSIsImlucHV0UmVmIiwiaGFuZGxlQ2hhbmdlIiwiZXZlbnQiLCJ0YXJnZXQiLCJmdW5jIiwiU0VMRUNUSU5HX0FOSU1BVElPTl9NUyIsIkRFU0VMRUNUSU5HX0FOSU1BVElPTl9NUyIsImNoaXBTZXRDc3NDbGFzc2VzIiwiT1ZFUkZMT1ciLCJDSElQUyIsImNoaXBDc3NDbGFzc2VzIiwiRklMVEVSIiwiU0VMRUNUQUJMRSIsIlNFTEVDVElORyIsIlNFTEVDVElOR19XSVRIX1BSSU1BUllfSUNPTiIsIkRFU0VMRUNUSU5HIiwiREVTRUxFQ1RJTkdfV0lUSF9QUklNQVJZX0lDT04iLCJFTlRFUiIsIkVYSVQiLCJISURERU4iLCJXSVRIX1BSSU1BUllfR1JBUEhJQyIsIldJVEhfUFJJTUFSWV9JQ09OIiwiV0lUSF9UUkFJTElOR19BQ1RJT04iLCJXSVRIX0FWQVRBUiIsIkNFTEwiLCJQUklNQVJZX0NFTEwiLCJUUkFJTElOR19DRUxMIiwiVFJBSUxJTkdfQUNUSU9OIiwiUFJFU0VOVEFUSU9OQUxfQUNUSU9OIiwiQUNUSU9OX1RPVUNIIiwiUFJJTUFSWV9SSVBQTEUiLCJUUkFJTElOR19SSVBQTEUiLCJQUklNQVJZX0lDT04iLCJUUkFJTElOR19JQ09OIiwiVEVYVF9MQUJFTCIsIkNIRUNLTUFSS19TVkciLCJDaGlwUHJpbWFyeUFjdGlvbiIsInByZXNlbnRhdGlvbmFsIiwic2VsZWN0YWJsZSIsInNlbGVjdGVkIiwiaXNCdXR0b24iLCJDaGlwVHJhaWxpbmdBY3Rpb24iLCJDaGlwIiwiYXZhdGFyIiwicHJpbWFyeUljb24iLCJmaWx0ZXIiLCJ3aXRoQXZhdGFyIiwid2l0aFByaW1hcnlHcmFwaGljIiwid2l0aFByaW1hcnlJY29uIiwid2l0aFRyYWlsaW5nQWN0aW9uIiwic2VsZWN0aW5nQ2xhc3MiLCJkZXNlbGVjdGluZ0NsYXNzIiwiZXhpdEFjdGl2ZSIsImFueSIsIm9uQ2xpY2siLCJpc1VuZGVmaW5lZCIsImlzTnVsbCIsImlzQm9vbGVhbiIsImlzTnVtYmVyIiwiaXNTdHJpbmciLCJpc0FycmF5IiwiQXJyYXkiLCJpc09iamVjdCIsIkNoaXBTZXQiLCJjaGlwcyIsImlucHV0IiwiY2hvaWNlIiwib3ZlcmZsb3ciLCJjaGlwIiwiaGFuZGxlQ2xpY2siLCJjaGlwVmFsdWUiLCJjdXJyZW50VGFyZ2V0IiwiZGF0YXNldCIsIm5ld1ZhbHVlIiwiaW5jbHVkZXMiLCJ2IiwiY29uY2F0Iiwib25DbGlja0NhcHR1cmUiLCJzdHJpbmdzIiwiWE1MTlMiLCJzaXplUHJvcHMiLCJsYXJnZSIsInZpZXdCb3giLCJyYWRpdXMiLCJzdHJva2VXaWR0aCIsImdhcFBhdGNoU3Ryb2tlV2lkdGgiLCJzdHJva2VEYXNoYXJyYXkiLCJpbmRldGVybWluYXRlU3Ryb2tlRGFzaG9mZnNldCIsIm1lZGl1bSIsInNtYWxsIiwiSU5ERVRFUk1JTkFURSIsIkNMT1NFRCIsIkRFVEVSTUlOQVRFX0NPTlRBSU5FUiIsIkRFVEVSTUlOQVRFX0NJUkNMRV9HUkFQSElDIiwiREVURVJNSU5BVEVfVFJBQ0siLCJERVRFUk1JTkFURV9DSVJDTEUiLCJJTkRFVEVSTUlOQVRFX0NPTlRBSU5FUiIsIklOREVURVJNSU5BVEVfQ0lSQ0xFX0dSQVBISUMiLCJTUElOTkVSX0xBWUVSIiwiQ09MT1IiLCJDSVJDTEVfQ0xJUFBFUiIsIkNJUkNMRV9MRUZUIiwiQ0lSQ0xFX1JJR0hUIiwiR0FQX1BBVENIIiwiU2l6ZSIsIkNpcmN1bGFyUHJvZ3Jlc3MiLCJjbG9zZWQiLCJjb2xvcmZ1bCIsInByb2dyZXNzIiwiTnVtYmVyIiwiY3giLCJjeSIsInN0cm9rZURhc2hvZmZzZXQiLCJNYXRoIiwiUEkiLCJuIiwiUFJPR1JFU1NfQ09MT1IiLCJJY29uQnV0dG9uIiwiQU5JTUFUSU9OX1JFQURZIiwiQ0xPU0VEX0FOSU1BVElPTl9PRkYiLCJCVUZGRVIiLCJCVUZGRVJfQkFSIiwiQlVGRkVSX0RPVFMiLCJCQVIiLCJQUklNQVJZX0JBUiIsIlNFQ09OREFSWV9CQVIiLCJCQVJfSU5ORVIiLCJMaW5lYXJQcm9ncmVzcyIsImJ1ZmZlciIsInByaW1hcnlCYXJTdHlsZSIsInRyYW5zZm9ybSIsImJ1ZmZlclN0eWxlIiwiZmxleEJhc2lzIiwiU1RJQ0tZX0hFQURFUiIsIklOX1BST0dSRVNTIiwiVEFCTEVfQ09OVEFJTkVSIiwiVEFCTEUiLCJIRUFERVJfUk9XIiwiSEVBREVSX1JPV19DSEVDS0JPWCIsIkhFQURFUl9DRUxMIiwiSEVBREVSX0NFTExfQ0hFQ0tCT1giLCJIRUFERVJfQ0VMTF9OVU1FUklDIiwiSEVBREVSX0NFTExfV0lUSF9TT1JUIiwiSEVBREVSX0NFTExfU09SVEVEIiwiSEVBREVSX0NFTExfU09SVEVEX0RFU0MiLCJIRUFERVJfQ0VMTF9XUkFQUEVSIiwiSEVBREVSX0NFTExfTEFCRUwiLCJST1ciLCJST1dfQ0hFQ0tCT1giLCJST1dfU0VMRUNURUQiLCJDRUxMX0NIRUNLQk9YIiwiQ0VMTF9OVU1FUklDIiwiUEFHSU5BVElPTiIsIlBBR0lOQVRJT05fVFJBSUxJTkciLCJQQUdJTkFUSU9OX1JPV1NfUEVSX1BBR0UiLCJQQUdJTkFUSU9OX1JPV1NfUEVSX1BBR0VfTEFCRUwiLCJQQUdJTkFUSU9OX1JPV1NfUEVSX1BBR0VfU0VMRUNUIiwiUEFHSU5BVElPTl9OQVZJR0FUSU9OIiwiUEFHSU5BVElPTl9UT1RBTCIsIlBBR0lOQVRJT05fQlVUVE9OIiwiU09SVF9JQ09OX0JVVFRPTiIsIlNPUlRfU1RBVFVTX0xBQkVMIiwiUFJPR1JFU1NfSU5ESUNBVE9SIiwiU0NSSU0iLCJGT09URVIiLCJMSU5FQVJfUFJPR1JFU1MiLCJEYXRhVGFibGVQcm9ncmVzc0luZGljYXRvciIsIkZMT0FUIiwiUkVRVUlSRUQiLCJGbG9hdGluZ0xhYmVsIiwiZmxvYXQiLCJyZXF1aXJlZCIsIkFDVElWRSIsIkRFQUNUSVZBVElORyIsIkxpbmVSaXBwbGUiLCJhY3RpdmUiLCJ0cmFuc2Zvcm1PcmlnaW4iLCJLZXkiLCJBUlJPV19MRUZUIiwiQVJST1dfVVAiLCJBUlJPV19SSUdIVCIsIkFSUk9XX0RPV04iLCJIT01FIiwiRU5EIiwiUEFHRV9VUCIsIlBBR0VfRE9XTiIsIktleUNvZGUiLCJnZXRDbGllbnRXaWR0aCIsIm9mZnNldFBhcmVudCIsImNsaWVudFdpZHRoIiwiY2xvbmVOb2RlIiwic2V0UHJvcGVydHkiLCJkb2N1bWVudCIsImRvY3VtZW50RWxlbWVudCIsImFwcGVuZENoaWxkIiwicmVtb3ZlQ2hpbGQiLCJnZXRFdmVudEtleSIsImtleSIsImtleUNvZGUiLCJnZXRQYWdlWCIsInRhcmdldFRvdWNoZXMiLCJwYWdlWCIsImdldFBhZ2VZIiwicGFnZVkiLCJOT1RDSF9TSVpFX0ZBQ1RPUiIsIk5PVENIX1BBRERJTkdfUklHSFQiLCJOT1RDSEVEIiwiVVBHUkFERUQiLCJOT19MQUJFTCIsIkxFQURJTkciLCJOT1RDSCIsIlRSQUlMSU5HIiwidXNlTGF5b3V0RWZmZWN0IiwiTm90Y2hlZE91dGxpbmUiLCJub3RjaGVkIiwibm90Y2hSZWYiLCJub3RjaCIsImZsb2F0aW5nTGFiZWwiLCJmaXJzdENoaWxkIiwid2lkdGgiLCJUUkFOU0lUSU9OX09QRU5fRFVSQVRJT04iLCJUUkFOU0lUSU9OX0NMT1NFX0RVUkFUSU9OIiwiTUFSR0lOX1RPX0VER0UiLCJBTkNIT1JfVE9fTUVOVV9TVVJGQUNFX1dJRFRIX1JBVElPIiwiVE9VQ0hfRVZFTlRfV0FJVF9NUyIsIlNVUkZBQ0UiLCJTVVJGQUNFX0FOQ0hPUiIsIlNVUkZBQ0VfRklYRUQiLCJTVVJGQUNFX09QRU4iLCJTVVJGQUNFX0FOSU1BVElOR19PUEVOIiwiU1VSRkFDRV9BTklNQVRJTkdfQ0xPU0VEIiwiU1VSRkFDRV9CRUxPV19BTkNIT1IiLCJJVEVNIiwiSVRFTV9TRUxFQ1RFRCIsIlNFTEVDVElPTl9HUk9VUCIsIlNFTEVDVElPTl9HUk9VUF9JQ09OIiwiT3JpZ2luIiwiVE9QX0xFRlQiLCJUT1BfQ0VOVEVSIiwiVE9QX1JJR0hUIiwiQ0VOVEVSX0xFRlQiLCJDRU5URVIiLCJDRU5URVJfUklHSFQiLCJCT1RUT01fTEVGVCIsIkJPVFRPTV9DRU5URVIiLCJCT1RUT01fUklHSFQiLCJ1c2VTdGF0ZSIsInVzZUNyZWF0ZWQiLCJjcmVhdGVkIiwic2V0Q3JlYXRlZCIsInVzZU1vdW50ZWQiLCJ1c2VVcGRhdGVkIiwiZGVwcyIsIm1vdW50ZWQiLCJzZXRNb3VudGVkIiwidXNlVXBkYXRlZFN5bmMiLCJ1c2VVbm1vdW50ZWQiLCJsaXN0Q3NzQ2xhc3NlcyIsImxpc3RJdGVtQ3NzQ2xhc3NlcyIsIkFDVElWQVRFRCIsIk5PTl9JTlRFUkFDVElWRSIsIk9ORV9MSU5FIiwiVFdPX0xJTkVTIiwiVEhSRUVfTElORVMiLCJMRUFESU5HX0lDT04iLCJMRUFESU5HX0lNQUdFIiwiTEVBRElOR19BVkFUQVIiLCJMRUFESU5HX1RIVU1CTkFJTCIsIkxFQURJTkdfVklERU8iLCJMRUFESU5HX0NIRUNLQk9YIiwiTEVBRElOR19SQURJTyIsIkxFQURJTkdfU1dJVENIIiwiVFJBSUxJTkdfTUVUQSIsIlRSQUlMSU5HX0NIRUNLQk9YIiwiVFJBSUxJTkdfUkFESU8iLCJUUkFJTElOR19TV0lUQ0giLCJTVEFSVCIsIk9WRVJMSU5FX1RFWFQiLCJQUklNQVJZX1RFWFQiLCJTRUNPTkRBUllfVEVYVCIsImxpc3RHcm91cENzc0NsYXNzZXMiLCJTVUJIRUFERVIiLCJsaXN0RGl2aWRlckNzc0NsYXNzZXMiLCJMRUFESU5HX1RFWFQiLCJMaXN0SXRlbUNvbnRlbnQiLCJvdmVybGluZVRleHQiLCJwcmltYXJ5VGV4dCIsInNlY29uZGFyeVRleHQiLCJMaXN0SXRlbUVuZCIsIkxpc3RJdGVtU3RhcnQiLCJMaXN0SXRlbSIsInN0YXJ0IiwiZW5kIiwidGh1bWJuYWlsIiwidmlkZW8iLCJsZWFkaW5nSW1hZ2UiLCJsZWFkaW5nQXZhdGFyIiwibGVhZGluZ1RodW1ibmFpbCIsImxlYWRpbmdWaWRlbyIsImxlYWRpbmdDaGVja2JveCIsImxlYWRpbmdSYWRpbyIsImxlYWRpbmdTd2l0Y2giLCJtZXRhIiwidHJhaWxpbmdNZXRhIiwidHJhaWxpbmdDaGVja2JveCIsInRyYWlsaW5nUmFkaW8iLCJ0cmFpbGluZ1N3aXRjaCIsImFjdGl2YXRlZCIsIm5vbkludGVyYWN0aXZlIiwib25lTGluZSIsInR3b0xpbmVzIiwidGhyZWVMaW5lcyIsIndpdGhMZWFkaW5nSWNvbiIsIndpdGhMZWFkaW5nSW1hZ2UiLCJ3aXRoTGVhZGluZ0F2YXRhciIsIndpdGhMZWFkaW5nVGh1bWJuYWlsIiwid2l0aExlYWRpbmdWaWRlbyIsIndpdGhMZWFkaW5nQ2hlY2tib3giLCJ3aXRoTGVhZGluZ1JhZGlvIiwid2l0aExlYWRpbmdTd2l0Y2giLCJ3aXRoVHJhaWxpbmdNZXRhIiwid2l0aFRyYWlsaW5nSWNvbiIsIndpdGhUcmFpbGluZ0NoZWNrYm94Iiwid2l0aFRyYWlsaW5nUmFkaW8iLCJ3aXRoVHJhaWxpbmdTd2l0Y2giLCJsaW5lcyIsImhhc1N0YXJ0IiwiaGFzQ29udGVudCIsImhhc0VuZCIsIkxpc3QiLCJpdGVtcyIsIml0ZW0iLCJhcnJheSIsIkxpc3REaXZpZGVyIiwid2l0aExlYWRpbmdUZXh0IiwiTGlzdEdyb3VwIiwiTGlzdEdyb3VwU3ViaGVhZGVyIiwiSXRlbSIsIkRpdmlkZXIiLCJHcm91cCIsIlN1YmhlYWRlciIsIkNvbnRlbnQiLCJFbmQiLCJTdGFydCIsIk1lbnVJdGVtIiwiY3JlYXRlUG9ydGFsIiwiTW9kYWwiLCJyb290IiwiYWN0aXZlRWxlbWVudCIsImNsYXNzTGlzdCIsImFkZCIsImJvZHkiLCJmb2N1cyIsIkxheWVyIiwibW9kYWwiLCJkZWZhdWx0VmFsdWVzIiwidG9wIiwiYm90dG9tIiwiY2VudGVyIiwibGVmdCIsInJpZ2h0IiwiZ2V0QW5jaG9yT3JpZ2luIiwiYW5jaG9yT3JpZ2luIiwiT2JqZWN0IiwiYXNzaWduIiwia2V5cyIsInNwbGl0IiwidmFsdWVzIiwicmVkdWNlIiwicmVzdWx0IiwiTWVudVN1cmZhY2UiLCJhbmNob3IiLCJfYW5jaG9yUmVmIiwiYW5jaG9yUmVmIiwiX2FuY2hvck9yaWdpbiIsIl90cmFuc2Zvcm1PcmlnaW4iLCJxdWljayIsInBlcnNpc3RlbnQiLCJmdWxsV2lkdGgiLCJvbkNsb3NlIiwib25LZXlEb3duIiwiaGFuZGxlQm9keUNsaWNrIiwiYWRkRXZlbnRMaXN0ZW5lciIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJjbGllbnRIZWlnaHQiLCJhbmNob3JDbGllbnRSZWN0IiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0IiwiYW5jaG9yRGltZW5zaW9ucyIsIm9mZnNldFRvcCIsIm9mZnNldExlZnQiLCJvZmZzZXRXaWR0aCIsIm1heFdpZHRoIiwicG9zaXRpb24iLCJzY3JvbGxZIiwid2luZG93Iiwic2Nyb2xsWCIsImJvdHRvbU92ZXJmbG93IiwiaW5uZXJIZWlnaHQiLCJ0b3BPdmVyZmxvdyIsInJpZ2h0T3ZlcmZsb3ciLCJpbm5lcldpZHRoIiwiYWJzIiwibGVmdE92ZXJmbG93IiwiaGFuZGxlS2V5RG93biIsInN0b3BQcm9wYWdhdGlvbiIsImlzQmVsb3dBbmNob3IiLCJvYmplY3QiLCJNZW51IiwibGlzdFByb3BzIiwibGlzdFJlZiIsImZvY3VzZWRDaGlsZEluZGV4Iiwic2V0Rm9jdXNlZENoaWxkSW5kZXgiLCJ0b0FycmF5IiwiZmluZEluZGV4IiwiaSIsInByZXZlbnREZWZhdWx0IiwiaW5kZXgiLCJuZXh0SW5kZXgiLCJNZW51QW5jaG9yIiwid3JhcCIsIk1lbnVTZWxlY3Rpb25Hcm91cCIsIk1lbnVTZWxlY3Rpb25Hcm91cEljb24iLCJNZW51T3JpZ2luIiwiQW5jaG9yIiwiU3VyZmFjZSIsIlNlbGVjdGlvbkdyb3VwIiwiU2VsZWN0aW9uR3JvdXBJY29uIiwiRklMTEVEIiwiRk9DVVNFRCIsIklOVkFMSUQiLCJXSVRIX0xFQURJTkdfSUNPTiIsIlNFTEVDVEVEX1RFWFQiLCJTRUxFQ1RFRF9URVhUX0NPTlRBSU5FUiIsIkRST1BET1dOX0lDT04iLCJEUk9QRE9XTl9JQ09OX0dSQVBISUMiLCJEUk9QRE9XTl9JQ09OX0lOQUNUSVZFIiwiRFJPUERPV05fSUNPTl9BQ1RJVkUiLCJNRU5VIiwiTUVOVV9JTlZBTElEIiwiQU5DSE9SIiwiSEVMUEVSX1RFWFQiLCJWQUxJREFUSU9OX01FU1NBR0UiLCJWQUxJREFUSU9OX01FU1NBR0VfUEVSU0lTVEVOVCIsIkRyb3Bkb3duSWNvbiIsIlNlbGVjdE9wdGlvbiIsImNoZWNrYm94IiwiSGVscGVyVGV4dCIsInZhbGlkYXRpb24iLCJTZWxlY3QiLCJuYW1lIiwib3B0aW9ucyIsImhlbHBlclRleHQiLCJmaWxsZWQiLCJtdWx0aXBsZSIsIm1lbnVQcm9wcyIsImhlbHBlclRleHRQcm9wcyIsIm9wdGlvbiIsIm1lbnVSZWYiLCJzZXRBY3RpdmF0ZWQiLCJmb2N1c2VkIiwic2V0Rm9jdXNlZCIsInRvdWNoZWQiLCJzZXRUb3VjaGVkIiwic2VsZWN0ZWRUZXh0Iiwic2V0U2VsZWN0ZWRUZXh0IiwiaW50ZXJhY3Rpb25Db29yZHMiLCJzZXRJbnRlcmFjdGlvbkNvb3JkcyIsInNlbGVjdGVkT3B0aW9ucyIsImpvaW4iLCJzZWxlY3RlZE9wdGlvbiIsImZpbmQiLCJoYW5kbGVBbmNob3JDbGljayIsInRhcmdldENsaWVudFJlY3QiLCJ4IiwiY2xpZW50WCIsInkiLCJjbGllbnRZIiwiaGFuZGxlT3B0aW9uSW50ZXJhY3Rpb24iLCJ0eXBlIiwiU2V0IiwiaGFzIiwiaGFuZGxlTWVudUNsb3NlIiwicGF0aCIsImhhc1ZhbHVlIiwiZm9jdXNlZE9ySGFzVmFsdWUiLCJpc0ludmFsaWQiLCJvcHRpb25WYWx1ZSIsIk9wdGlvbiIsIkRhdGFUYWJsZVBhZ2luYXRpb24iLCJ0b3RhbENvdW50IiwiY3VycmVudFBhZ2UiLCJyb3dzUGVyUGFnZSIsIm9uRmlyc3RQYWdlIiwib25QcmV2UGFnZSIsIm9uTmV4dFBhZ2UiLCJvbkxhc3RQYWdlIiwiRGF0YVRhYmxlIiwic3RpY2t5SGVhZGVyIiwiaW5Qcm9ncmVzcyIsInBhZ2luYXRpb24iLCJEYXRhVGFibGVDZWxsIiwibnVtZXJpYyIsInNjb3BlIiwiRGF0YVRhYmxlQ29udGVudCIsIkRhdGFUYWJsZUZvb3RlciIsIkRhdGFUYWJsZUhlYWRlciIsIkRhdGFUYWJsZUhlYWRlckNlbGwiLCJzb3J0Iiwic29ydEljb25CdXR0b24iLCJvblNvcnQiLCJyb2xlIiwiaGFuZGxlU29ydEljb25DbGljayIsIndpdGhTb3J0IiwiRGF0YVRhYmxlSGVhZGVyUm93IiwiRGF0YVRhYmxlUm93IiwiQ2VsbCIsIkZvb3RlciIsIkhlYWRlckNlbGwiLCJIZWFkZXJSb3ciLCJQYWdpbmF0aW9uIiwiUm93IiwiRElBTE9HX0FOSU1BVElPTl9PUEVOX1RJTUVfTVMiLCJESUFMT0dfQU5JTUFUSU9OX0NMT1NFX1RJTUVfTVMiLCJERUZBVUxUX0FDVElPTlNfSEVJR0hUIiwiQ0xPU0UiLCJDT05UQUlORVIiLCJCVVRUT04iLCJGVUxMU0NSRUVOIiwiU0NST0xMQUJMRSIsIlNUQUNLRUQiLCJTQ1JPTExfRElWSURFUl9IRUFERVIiLCJTQ1JPTExfRElWSURFUl9GT09URVIiLCJTQ1JPTExfTE9DSyIsIkRpYWxvZ0hlYWRlciIsImNsb3NlSWNvbiIsImZ1bGxzY3JlZW4iLCJEaWFsb2dDb250ZW50IiwiRGlhbG9nQWN0aW9ucyIsIkRpYWxvZyIsInN0YWNrZWQiLCJhdXRvU3RhY2tCdXR0b25zIiwiYWN0aW9uc1JlZiIsImhhbmRsZURvY3VtZW50S2V5RG93biIsImNvbnRlbnRFbGVtZW50Iiwic2hvdWxkU2Nyb2xsIiwic2Nyb2xsSGVpZ2h0IiwiYWN0aW9uc0VsZW1lbnQiLCJoYW5kbGVTY3JvbGwiLCJpc1Njcm9sbEF0VG9wIiwic2Nyb2xsVG9wIiwiaXNTY3JvbGxBdEJvdHRvbSIsImNlaWwiLCJ0b2dnbGUiLCJyZW1vdmUiLCJoYW5kbGVFbnRlciIsImhhbmRsZUV4aXRlZCIsImhhbmRsZVNjcmltQ2xpY2siLCJhcHBlYXJBY3RpdmUiLCJjb25maXJtYXRpb24iLCJBTklNQVRJT05fRU5URVJfVElNRV9NUyIsIkFOSU1BVElPTl9FWElUX1RJTUVfTVMiLCJESVNNSVNTSUJMRSIsIk1PREFMIiwiQU5JTUFURSIsIkFQUF9DT05URU5UIiwiRHJhd2VyIiwiZGlzbWlzc2libGUiLCJhcHBDb250ZW50U2VsZWN0b3IiLCJhcHBDb250ZW50RWxlbWVudCIsInF1ZXJ5U2VsZWN0b3IiLCJuZXh0RWxlbWVudFNpYmxpbmciLCJEcmF3ZXJIZWFkZXIiLCJEcmF3ZXJDb250ZW50IiwiWiIsIlRSQU5TSVRJT04iLCJFbGV2YXRpb24iLCJ6IiwidHJhbnNpdGlvbiIsIk1JTkkiLCJFWFRFTkRFRCIsIkVYSVRFRCIsIkZBQiIsIm1pbmkiLCJleGl0ZWQiLCJBTElHTl9FTkQiLCJOT1dSQVAiLCJTUEFDRV9CRVRXRUVOIiwiRm9ybUZpZWxkIiwiYWxpZ25FbmQiLCJub3dyYXAiLCJzcGFjZUJldHdlZW4iLCJpZCIsIklNQUdFX0xJU1QiLCJJTUFHRV9MSVNUX01BU09OUlkiLCJJTUFHRV9MSVNUX1dJVEhfVEVYVF9QUk9URUNUSU9OIiwiSU1BR0VfTElTVF9JVEVNIiwiSU1BR0VfTElTVF9JTUFHRV9BU1BFQ1RfQ09OVEFJTkVSIiwiSU1BR0VfTElTVF9JTUFHRSIsIklNQUdFX0xJU1RfU1VQUE9SVElORyIsIklNQUdFX0xJU1RfTEFCRUwiLCJJbWFnZUxpc3RJdGVtIiwiaW1hZ2VTcmMiLCJmaXhlZEFzcGVjdCIsIkltYWdlTGlzdCIsIm1hc29ucnkiLCJ3aXRoVGV4dFByb3RlY3Rpb24iLCJjaGlsZCIsIkNPTFVNTiIsIkRJUkVDVElPTiIsIldSQVAiLCJXUkFQX1JFVkVSU0UiLCJBTElHTl9JVEVNUyIsIkFMSUdOX1NFTEYiLCJKVVNUSUZZX0NPTlRFTlQiLCJMYXlvdXQiLCJyb3ciLCJjb2x1bW4iLCJkaXJlY3Rpb24iLCJhbGlnbkl0ZW1zIiwiYWxpZ25TZWxmIiwianVzdGlmeUNvbnRlbnQiLCJBTElHTiIsIkZJWEVEX0NPTFVNTl9XSURUSCIsIklOTkVSIiwiQ0VMTF9TUEFOIiwiQ0VMTF9PUkRFUiIsIkNFTExfQUxJR04iLCJMYXlvdXRHcmlkIiwiYWxpZ24iLCJmaXhlZENvbHVtbldpZHRoIiwiTGF5b3V0R3JpZENlbGwiLCJzcGFuIiwiZGVza3RvcCIsInRhYmxldCIsIm1vYmlsZSIsIm9yZGVyIiwiZ3JpZCIsIk9VVEVSX0NJUkNMRSIsIklOTkVSX0NJUkNMRSIsIlJhZGlvIiwiTURDUmlwcGxlIiwiUmlwcGxlIiwidW5ib3VuZGVkIiwicmlwcGxlUmVmIiwicGFyZW50Tm9kZSIsImRlc3Ryb3kiLCJVTkJPVU5ERUQiLCJCR19GT0NVU0VEIiwiRkdfQUNUSVZBVElPTiIsIkZHX0RFQUNUSVZBVElPTiIsIlNVUkZBQ0VfUFJJTUFSWSIsIlNVUkZBQ0VfQUNDRU5UIiwiVkFSX0ZHX1NDQUxFIiwiVkFSX0ZHX1NJWkUiLCJWQVJfRkdfVFJBTlNMQVRFX0VORCIsIlZBUl9GR19UUkFOU0xBVEVfU1RBUlQiLCJWQVJfTEVGVCIsIlZBUl9UT1AiLCJERUFDVElWQVRJT05fVElNRU9VVF9NUyIsIkZHX0RFQUNUSVZBVElPTl9NUyIsIklOSVRJQUxfT1JJR0lOX1NDQUxFIiwiUEFERElORyIsIlRBUF9ERUxBWV9NUyIsInVzZVJpcHBsZSIsIlJpcHBsZVN1cmZhY2UiLCJhY2NlbnQiLCJTSU5HTEVfU0VMRUNUIiwiU0VHTUVOVCIsIlNFR01FTlRfU0VMRUNURUQiLCJTZWdtZW50ZWRCdXR0b25TZWdtZW50IiwicmlwcGxlIiwiU2VnbWVudGVkQnV0dG9uIiwic2VnbWVudHMiLCJzaW5nbGVTZWxlY3QiLCJzZWdtZW50Iiwic2VnbWVudFZhbHVlIiwiYXJpYVByb3AiLCJTZWdtZW50IiwiQ0xPU0VfQlVUVE9OIiwiU2lkZVNoZWV0SGVhZGVyIiwiU2lkZVNoZWV0Q29udGVudCIsIlNpZGVTaGVldCIsIlNpZGVTaGVldEFwcENvbnRlbnQiLCJBcHBDb250ZW50IiwiVEhVTUJfV0lEVEgiLCJSQU5HRSIsIkRJU0NSRVRFIiwiSU5QVVQiLCJUUkFDSyIsIlRSQUNLX0lOQUNUSVZFIiwiVFJBQ0tfQUNUSVZFIiwiVFJBQ0tfQUNUSVZFX0ZJTEwiLCJUSUNLX01BUktTIiwiVElDS19NQVJLX0FDVElWRSIsIlRJQ0tfTUFSS19JTkFDVElWRSIsIlRIVU1CIiwiVEhVTUJfVE9QIiwiVEhVTUJfRk9DVVNFRCIsIlRIVU1CX1dJVEhfSU5ESUNBVE9SIiwiVEhVTUJfS05PQiIsIlZBTFVFX0lORElDQVRPUl9DT05UQUlORVIiLCJWQUxVRV9JTkRJQ0FUT1IiLCJWQUxVRV9JTkRJQ0FUT1JfVEVYVCIsImdldFZhbHVlRm9yRXZlbnRLZXkiLCJldmVudEtleSIsIm1pbiIsIm1heCIsInN0ZXAiLCJkZWx0YSIsIk5hTiIsIklucHV0Iiwicm91bmQiLCJUaWNrTWFya3MiLCJmcm9tIiwiXyIsInRpY2tWYWx1ZSIsIlRyYWNrIiwiZGlzY3JldGUiLCJ0aWNrTWFya3MiLCJUaHVtYiIsIm9uU3RhcnRJbnRlcmFjdGlvbiIsIm9uRW5kSW50ZXJhY3Rpb24iLCJoYW5kbGVGb2N1cyIsImhhbmRsZUJsdXIiLCJTbGlkZXIiLCJ0cmFja1JlZiIsInNldEFjdGl2ZSIsImhhbmRsZU1vdmUiLCJoYW5kbGVVcCIsInVwZGF0ZVZhbHVlIiwidHJhY2tDbGllbnRSZWN0Iiwib2Zmc2V0WCIsInBlcmNlbnQiLCJpc05hTiIsImhhbmRsZVJvb3RJbnRlcmFjdGlvbiIsImhhbmRsZVRodW1iU3RhcnRJbnRlcmFjdGlvbiIsImhhbmRsZVRodW1iRW5kSW50ZXJhY3Rpb24iLCJERUZBVUxUX0FVVE9fRElTTUlTU19USU1FT1VUX01TIiwiQU5JTUFUSU9OX09QRU5fVElNRV9NUyIsIkFOSU1BVElPTl9DTE9TRV9USU1FX01TIiwiRElTTUlTUyIsIlNuYWNrYmFyIiwiZGlzbWlzc0ljb24iLCJsZWFkaW5nIiwidGltZW91dCIsImNsb3NlT25Fc2NhcGUiLCJ0aW1lb3V0UmVmIiwic2V0VGltZW91dCIsImNsZWFyVGltZW91dCIsIlVOU0VMRUNURUQiLCJIQU5ETEVfVFJBQ0siLCJIQU5ETEUiLCJTSEFET1ciLCJFTEVWQVRJT05fT1ZFUkxBWSIsIklDT05TIiwiSUNPTl9PTiIsIklDT05fT0ZGIiwiU3dpdGNoIiwidGFiQ2xhc3NOYW1lcyIsIk1JTl9XSURUSCIsImJhckNzc0NsYXNzZXMiLCJzY3JvbGxlckNzc0NsYXNzZXMiLCJBTklNQVRJTkciLCJTQ1JPTExfQVJFQSIsIlNDUk9MTF9BUkVBX1NDUk9MTCIsIlNDUk9MTF9DT05URU5UIiwiaW5kaWNhdG9yQ3NzQ2xhc3NlcyIsIkZBREUiLCJOT19UUkFOU0lUSU9OIiwiQ09OVEVOVF9JQ09OIiwiQ09OVEVOVF9VTkRFUkxJTkUiLCJBbGlnbiIsImNyZWF0ZUNvbnRleHQiLCJ1c2VDb250ZXh0IiwiVGFiQ29udGV4dCIsIlRhYkluZGljYXRvciIsImZhZGUiLCJ1bmRlcmxpbmUiLCJwcmV2aW91c1RhYiIsImFjdGl2ZUluZGljYXRvciIsInByZXZpb3VzSW5kaWNhdG9yIiwicHJldmlvdXNJbmRpY2F0b3JDbGllbnRSZWN0IiwiYWN0aXZlSW5kaWNhdG9yQ2xpZW50UmVjdCIsInhQb3NpdGlvbiIsIndpZHRoRGVsdGEiLCJyb290Q2xhc3NOYW1lcyIsImNvbnRlbnRDbGFzc05hbWVzIiwiVGFiIiwiaW5kaWNhdG9ySWNvbiIsIm1pbldpZHRoIiwibWluV2lkdGhJbmRpY2F0b3IiLCJvbkFjdGl2YXRlIiwiVGFiU2Nyb2xsZXIiLCJhY3RpdmVUYWIiLCJzY3JvbGxBcmVhUmVmIiwic2Nyb2xsQ29udGVudFJlZiIsInNjcm9sbEFyZWFXaWR0aCIsInNjcm9sbENvbnRlbnRXaWR0aCIsInRhYldpZHRoIiwidGFiSGFsZldpZHRoIiwic2Nyb2xsTGVmdCIsIm9mZnNldExlZnREZWx0YSIsIm9mZnNldFJpZ2h0Iiwib2Zmc2V0UmlnaHREZWx0YSIsInNjcm9sbEJ5IiwiYmVoYXZpb3IiLCJUYWJCYXIiLCJ0YWJzIiwiaWNvbkluZGljYXRvciIsInVuZGVybGluZUluZGljYXRvciIsInRhYiIsImFjdGl2ZVRhYlJlZiIsInByZXZpb3VzVGFiUmVmIiwiaGFuZGxlVGFiQ2xpY2siLCJ0YWJWYWx1ZSIsIkJPVU5ERURfQU5DSE9SX0dBUCIsIlVOQk9VTkRFRF9BTkNIT1JfR0FQIiwiTUlOX1ZJRVdQT1JUX1RPT0xUSVBfVEhSRVNIT0xEIiwiRU5URVJfRFVSQVRJT05fTVMiLCJFWElUX0RVUkFUSU9OX01TIiwiSElERV9ERUxBWV9NUyIsIlNIT1dfREVMQVlfTVMiLCJNSU5fSEVJR0hUIiwiTUFYX1dJRFRIIiwiQ0FSRVRfSU5ERU5UQVRJT04iLCJBTklNQVRJT05fU0NBTEUiLCJSSUNIIiwiTVVMVElMSU5FIiwiU0hPV0lORyIsIlNIT1dJTkdfVFJBTlNJVElPTiIsIlNIT1dOIiwiSElERSIsIkhJREVfVFJBTlNJVElPTiIsIlNVUkZBQ0VfQU5JTUFUSU9OIiwiQ09OVEVOVF9MSU5LIiwiQ0FSRVRfVE9QIiwiQ0FSRVRfQk9UVE9NIiwiVG9vbHRpcCIsInRvb2x0aXBSZWYiLCJ0YXJnZXRSZWYiLCJoYW5kbGVNb3VzZUVudGVyIiwiaGFuZGxlTW91c2VMZWF2ZSIsInRvb2x0aXBSZWN0IiwidGFyZ2V0UmVjdCIsIm92ZXJmbG93Qm90dG9tIiwib3ZlcmZsb3dSaWdodCIsIlJpY2hUb29sdGlwIiwiaGFuZGxlVGFyZ2V0TW91c2VFbnRlciIsImhhbmRsZVRhcmdldE1vdXNlTGVhdmUiLCJoYW5kbGVUb29sdGlwTW91c2VFbnRlciIsImhhbmRsZVRvb2x0aXBNb3VzZUxlYXZlIiwiZXhpdERvbmUiLCJURVhUQVJFQSIsIkxBQkVMX0ZMT0FUSU5HIiwiRU5EX0FMSUdORUQiLCJXSVRIX1RSQUlMSU5HX0lDT04iLCJXSVRIX0lOVEVSTkFMX0NPVU5URVIiLCJBRkZJWCIsIkFGRklYX1BSRUZJWCIsIkFGRklYX1NVRkZJWCIsIlJFU0laRVIiLCJIRUxQRVJfTElORSIsIkhFTFBFUl9URVhUX1BFUlNJU1RFTlQiLCJIRUxQRVJfVEVYVF9WQUxJREFUSU9OIiwiQ0hBUkFDVEVSX0NPVU5URVIiLCJDaGFyYWN0ZXJDb3VudGVyIiwibWF4VmFsdWUiLCJ0ZXh0YXJlYSIsImF1dG9SZXNpemUiLCJzZXRIZWlnaHQiLCJSZXNpemVyIiwiVGV4dEZpZWxkIiwiZGVmYXVsdFZhbHVlIiwicHJlZml4Iiwic3VmZml4IiwicGVyc2lzdGVudEhlbHBlclRleHQiLCJ2YWxpZGF0aW9uTWVzc2FnZSIsImVuZEFsaWduZWQiLCJjaGFyYWN0ZXJDb3VudGVyIiwiaW50ZXJuYWxDaGFyYWN0ZXJDb3VudGVyIiwidmFsaWQiLCJzZXRWYWxpZCIsImNvdW50Iiwic2V0Q291bnQiLCJoYW5kbGVJbnRlcmFjdGlvbiIsImhhbmRsZUlucHV0Rm9jdXMiLCJoYW5kbGVJbnB1dEJsdXIiLCJoYW5kbGVJbnB1dENoYW5nZSIsImlzVmFsaWQiLCJ2YWxpZGl0eSIsImhhc0hlbHBlckxpbmUiLCJtYXhMZW5ndGgiLCJvdXRsaW5lIiwiZGVuc2UiLCJERUJPVU5DRV9USFJPVFRMRV9SRVNJWkVfVElNRV9NUyIsIk1BWF9UT1BfQVBQX0JBUl9IRUlHSFQiLCJTVElDS1kiLCJTVElDS1lfSElEREVOIiwiU1RJQ0tZX1NIT1dOIiwiRklYRURfU0NST0xMRUQiLCJGSVhFRF9BREpVU1QiLCJQUk9NSU5FTlQiLCJQUk9NSU5FTlRfRklYRURfQURKVVNUIiwiREVOU0UiLCJERU5TRV9GSVhFRF9BREpVU1QiLCJERU5TRV9QUk9NSU5FTlRfRklYRURfQURKVVNUIiwiU0hPUlQiLCJTSE9SVF9DT0xMQVBTRUQiLCJTSE9SVF9GSVhFRF9BREpVU1QiLCJTRUNUSU9OX0FMSUdOX1NUQVJUIiwiU0VDVElPTl9BTElHTl9DRU5URVIiLCJTRUNUSU9OX0FMSUdOX0VORCIsIk5BVklHQVRJT05fSUNPTiIsIkFDVElPTl9JVEVNIiwiVG9wQXBwQmFyUm93IiwiVG9wQXBwQmFyU2VjdGlvbiIsIlRvcEFwcEJhciIsIm5hdmlnYXRpb25JY29uIiwiYWN0aW9uSXRlbXMiLCJzdGlja3kiLCJwcm9taW5lbnQiLCJzaG9ydCIsImNvbGxhcHNlZCIsIm9uTmF2aWdhdGlvbkljb25DbGljayIsInNjcm9sbGVkIiwic2V0U2Nyb2xsZWQiLCJoaWRkZW4iLCJzZXRIaWRkZW4iLCJsYXN0U2Nyb2xsUG9zaXRpb24iLCJzY3JvbGxWYWx1ZSIsInBhZ2VZT2Zmc2V0IiwiY3VycmVudFNjcm9sbFBvc2l0aW9uIiwiZGlmZiIsInNob3VsZEhpZGUiLCJUb3BBcHBCYXJBY3Rpb25JdGVtIiwiVG9wQXBwQmFyRml4ZWRBZGp1c3QiLCJUb3BBcHBCYXJOYXZpZ2F0aW9uSWNvbiIsIlRvcEFwcEJhclRpdGxlIiwiQWN0aW9uSXRlbSIsIkZpeGVkQWRqdXN0IiwiTmF2aWdhdGlvbkljb24iLCJUaXRsZSIsImVsZW1lbnRzQnlUeXBlIiwiaGVhZGxpbmUxIiwiaGVhZGxpbmUyIiwiaGVhZGxpbmUzIiwiaGVhZGxpbmU0IiwiaGVhZGxpbmU1IiwiaGVhZGxpbmU2Iiwic3VidGl0bGUxIiwic3VidGl0bGUyIiwiYm9keTEiLCJib2R5MiIsImNhcHRpb24iLCJESVNQTEFZIiwiTk9fTUFSR0lOIiwiTk9fV1JBUCIsIlR5cG9ncmFwaHkiLCJkaXNwbGF5Iiwibm9NYXJnaW4iLCJub1dyYXAiLCJqc3hUb0h0bWwiLCJwcmludENvbXBvbmVudCIsImRlcHRoIiwicmVwbGFjZSIsImVudHJpZXMiLCJpbmRlbnQiLCJyZXBlYXQiLCJpc0VtcHR5IiwicHJpbnRQcm9wcyIsImVuZHNXaXRoIiwicHJpbnRQcm9wIiwicHJpbnRWYWx1ZSIsImhsanMiLCJqYXZhc2NyaXB0Iiwic2NzcyIsInNoZWxsIiwicGxhaW50ZXh0IiwieG1sIiwicmVnaXN0ZXJMYW5ndWFnZSIsImhpZ2hsaWdodCIsImNvZGUiLCJsYW5nIiwibGFuZ3VhZ2UiLCJnZXRMYW5ndWFnZSIsIkNvZGUiLCJodG1sIiwiX19odG1sIiwiRGVtbyIsImRlc2NyaXB0aW9uIiwic2V0dXAiLCJzZXR0aW5ncyIsImlzQ29kZU9wZW4iLCJzZXRDb2RlT3BlbiIsImlzU2V0dGluZ3NPcGVuIiwic2V0U2V0dGluZ3NPcGVuIiwiRmllbGRTZXQiLCJsZWdlbmQiLCJQYWdlIiwibGlua3MiLCJndWlkZSIsImRvY3MiLCJBdmF0YXJQYWdlIiwic2V0U2l6ZSIsInNldENvbnRlbnQiLCJpY29uQnV0dG9uIiwiQmFkZ2VQYWdlIiwic2V0VmFsdWUiLCJzZXRUeXBlIiwic2V0SW5zZXQiLCJzZXRUcmFuc3BhcmVudCIsInNldE9wZW4iLCJzZXRUZXh0IiwiaGFzSWNvbiIsInNldEhhc0ljb24iLCJzZXRJY29uIiwiaGFzQWN0aW9uIiwic2V0SGFzQWN0aW9uIiwic2V0QWN0aW9uIiwiaGFzU2Vjb25kYXJ5QWN0aW9uIiwic2V0SGFzU2Vjb25kYXJ5QWN0aW9uIiwic2V0U2Vjb25kYXJ5QWN0aW9uIiwic2V0Q2VudGVyZWQiLCJzZXRGaXhlZCIsInNldE1vYmlsZVN0YWNrZWQiLCJCdXR0b25QYWdlIiwic2V0TGFiZWwiLCJoYXNMZWFkaW5nSWNvbiIsInNldEhhc0xlYWRpbmdJY29uIiwic2V0TGVhZGluZ0ljb24iLCJoYXNUcmFpbGluZ0ljb24iLCJzZXRIYXNUcmFpbGluZ0ljb24iLCJzZXRUcmFpbGluZ0ljb24iLCJwYWdlVGl0bGUiLCJDYXJkUGFnZSIsImhhc1RpdGxlIiwic2V0SGFzVGl0bGUiLCJzZXRUaXRsZSIsImhhc1N1YnRpdGxlIiwic2V0SGFzU3VidGl0bGUiLCJzZXRTdWJ0aXRsZSIsIkNoZWNrYm94UGFnZSIsInNldENoZWNrZWQiLCJjb250cm9sbGVkIiwic2V0Q29udHJvbGxlZCIsInNldEluZGV0ZXJtaW5hdGUiLCJzZXREaXNhYmxlZCIsIkNoaXBzUGFnZSIsImNob2ljZUNoaXAiLCJzZXRDaG9pY2VDaGlwcyIsImZpbHRlckNoaXBzIiwic2V0RmlsdGVyQ2hpcHMiLCJDaXJjdWxhclByb2dyZXNzUGFnZSIsInNldENvbG9yZnVsIiwic2V0Q2xvc2VkIiwidGFibGUiLCJEYXRhVGFibGVQYWdlIiwiZGF0YSIsInNldERhdGEiLCJzZXRTb3J0IiwiaGFuZGxlU29ydCIsInNsaWNlIiwiYSIsImIiLCJzY3JvbGxhYmxlQ29udGVudCIsIkRpYWxvZ1BhZ2UiLCJpc0Jhc2ljT3BlbiIsInNldEJhc2ljT3BlbiIsImlzQ29uZmlybWF0aW9uT3BlbiIsInNldENvbmZpcm1hdGlvbk9wZW4iLCJpc1N0YWNraW5nT3BlbiIsInNldFN0YWNraW5nT3BlbiIsImlzU2Nyb2xsYWJsZU9wZW4iLCJzZXRTY3JvbGxhYmxlT3BlbiIsImlzRnVsbHNjcmVlbk9wZW4iLCJzZXRGdWxsc2NyZWVuT3BlbiIsIkRyYXdlclBhZ2UiLCJpc0Rpc21pc3NpYmxlT3BlbiIsInNldERpc21pc3NpYmxlT3BlbiIsImlzTW9kYWxPcGVuIiwic2V0TW9kYWxPcGVuIiwiRWxldmF0aW9uUGFnZSIsInNldFoiLCJGQUJQYWdlIiwiaXNFeGl0ZWQiLCJzZXRFeGl0ZWQiLCJGb3JtRmllbGRQYWdlIiwibWFya2VkIiwic2V0T3B0aW9ucyIsImxhbmdQcmVmaXgiLCJtYXJrZG93biIsInJlYWRtZSIsIkhvbWVQYWdlIiwiSWNvbkJ1dHRvblBhZ2UiLCJpc09uIiwic2V0T24iLCJzdGFuZGFyZEl0ZW1zIiwiZmlsbCIsIm1hc29ucnlJdGVtcyIsInJhbmRvbSIsIkltYWdlTGlzdFBhZ2UiLCJMYXlvdXRHcmlkUGFnZSIsIkxpbmVhclByb2dyZXNzUGFnZSIsImlzQ2xvc2VkIiwiTGlzdFBhZ2UiLCJNZW51UGFnZSIsImlzUXVpY2tPcGVuIiwic2V0UXVpY2tPcGVuIiwiaXNQZXJzaXN0ZW50T3BlbiIsInNldFBlcnNpc3RlbnRPcGVuIiwiaXNBbmNob3JlZE9wZW4iLCJzZXRBbmNob3JlZE9wZW4iLCJhbmNob3JQb3NpdGlvbiIsInNldEFuY2hvclBvc2l0aW9uIiwic2V0QW5jaG9yT3JpZ2luIiwic2V0VHJhbnNmb3JtT3JpZ2luIiwiaXNEaWFsb2dPcGVuIiwic2V0RGlhbG9nT3BlbiIsImhhbmRsZUFuY2hvclBvc2l0aW9uQ2hhbmdlIiwiaGFuZGxlQW5jaG9yT3JpZ2luQ2hhbmdlIiwiaGFuZGxlVHJhbnNmb3JtT3JpZ2luQ2hhbmdlIiwiUmFkaW9QYWdlIiwidmFsdWUxIiwic2V0VmFsdWUxIiwidmFsdWUyIiwic2V0VmFsdWUyIiwiaGFuZGxlQ2hhbmdlMSIsImhhbmRsZUNoYW5nZTIiLCJTZWdtZW50ZWRCdXR0b25QYWdlIiwidmFsdWUzIiwic2V0VmFsdWUzIiwiU2VsZWN0UGFnZSIsInNldEZpbGxlZCIsInNldE91dGxpbmVkIiwicHJlc2VsZWN0ZWQiLCJzZXRQcmVzZWxlY3RlZCIsInNldE11bHRpcGxlIiwiU2lkZVNoZWV0UGFnZSIsIlNsaWRlclBhZ2UiLCJTbmFja2JhclBhZ2UiLCJpc09wZW4iLCJpc0xlYWRpbmciLCJzZXRMZWFkaW5nIiwiaXNTdGFja2VkIiwic2V0U3RhY2tlZCIsIlN3aXRjaFBhZ2UiLCJpc1NlbGVjdGVkIiwic2V0U2VsZWN0ZWQiLCJiYXNpYyIsInNldEJhc2ljIiwic2V0TWluV2lkdGgiLCJzZXRNaW5XaWR0aEluZGljYXRvciIsIm1pbldpZHRoV2l0aE1pbldpZHRoSW5kaWNhdG9yIiwic2V0TWluV2lkdGhXaXRoTWluV2lkdGhJbmRpY2F0b3IiLCJzZXRGYWRlIiwiaWNvbnMiLCJzZXRJY29ucyIsInN0YWNrZWRJY29ucyIsInNldFN0YWNrZWRJY29ucyIsIm9ubHlJY29ucyIsInNldE9ubHlJY29ucyIsInNldEljb25JbmRpY2F0b3IiLCJzY3JvbGwiLCJzZXRTY3JvbGwiLCJUeXBvZ3JhcGh5UGFnZSIsImlzRmlsbGVkIiwiaXNPdXRsaW5lZCIsIlRvb2x0aXBQYWdlIiwiVG9wQXBwQmFyUGFnZSIsImlzQ29sbGFwc2VkIiwic2V0Q29sbGFwc2VkIiwiQ2hpcHMiLCJIb21lIiwiVGFicyIsInVybCIsIlJvdXRlIiwiTGluayIsIk5hdkxpbmsiLCJyb3V0ZXMiLCJBcHAiLCJyb3V0ZSIsImV4YWN0IiwiQnJvd3NlclJvdXRlciIsIlJvdXRlciIsInJlbmRlciIsImJhc2VuYW1lIiwicHJvY2VzcyIsImVudiIsIkVOViIsInByb2R1Y3Rpb24iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///937\n')},184:(module,exports)=>{eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!\n  Copyright (c) 2018 Jed Watson.\n  Licensed under the MIT License (MIT), see\n  http://jedwatson.github.io/classnames\n*/\n/* global define */\n\n(function () {\n\t'use strict';\n\n\tvar hasOwn = {}.hasOwnProperty;\n\n\tfunction classNames() {\n\t\tvar classes = [];\n\n\t\tfor (var i = 0; i < arguments.length; i++) {\n\t\t\tvar arg = arguments[i];\n\t\t\tif (!arg) continue;\n\n\t\t\tvar argType = typeof arg;\n\n\t\t\tif (argType === 'string' || argType === 'number') {\n\t\t\t\tclasses.push(arg);\n\t\t\t} else if (Array.isArray(arg)) {\n\t\t\t\tif (arg.length) {\n\t\t\t\t\tvar inner = classNames.apply(null, arg);\n\t\t\t\t\tif (inner) {\n\t\t\t\t\t\tclasses.push(inner);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (argType === 'object') {\n\t\t\t\tif (arg.toString === Object.prototype.toString) {\n\t\t\t\t\tfor (var key in arg) {\n\t\t\t\t\t\tif (hasOwn.call(arg, key) && arg[key]) {\n\t\t\t\t\t\t\tclasses.push(key);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tclasses.push(arg.toString());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn classes.join(' ');\n\t}\n\n\tif ( true && module.exports) {\n\t\tclassNames.default = classNames;\n\t\tmodule.exports = classNames;\n\t} else if (true) {\n\t\t// register as 'classnames', consistent with npm package name\n\t\t!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function () {\n\t\t\treturn classNames;\n\t\t}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t} else {}\n}());\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTg0LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGdCQUFnQjs7QUFFaEI7QUFDQTs7QUFFQSxrQkFBa0Isc0JBQXNCO0FBQ3hDO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsS0FBSyxLQUE2QjtBQUNsQztBQUNBO0FBQ0EsR0FBRyxTQUFTLElBQTRFO0FBQ3hGO0FBQ0EsRUFBRSxpQ0FBcUIsRUFBRSxtQ0FBRTtBQUMzQjtBQUNBLEdBQUc7QUFBQSxrR0FBQztBQUNKLEdBQUcsS0FBSyxFQUVOO0FBQ0YsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL21kYy1yZWFjdC8uL25vZGVfbW9kdWxlcy9jbGFzc25hbWVzL2luZGV4LmpzPzRkMjYiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gIENvcHlyaWdodCAoYykgMjAxOCBKZWQgV2F0c29uLlxuICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UgKE1JVCksIHNlZVxuICBodHRwOi8vamVkd2F0c29uLmdpdGh1Yi5pby9jbGFzc25hbWVzXG4qL1xuLyogZ2xvYmFsIGRlZmluZSAqL1xuXG4oZnVuY3Rpb24gKCkge1xuXHQndXNlIHN0cmljdCc7XG5cblx0dmFyIGhhc093biA9IHt9Lmhhc093blByb3BlcnR5O1xuXG5cdGZ1bmN0aW9uIGNsYXNzTmFtZXMoKSB7XG5cdFx0dmFyIGNsYXNzZXMgPSBbXTtcblxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgYXJnID0gYXJndW1lbnRzW2ldO1xuXHRcdFx0aWYgKCFhcmcpIGNvbnRpbnVlO1xuXG5cdFx0XHR2YXIgYXJnVHlwZSA9IHR5cGVvZiBhcmc7XG5cblx0XHRcdGlmIChhcmdUeXBlID09PSAnc3RyaW5nJyB8fCBhcmdUeXBlID09PSAnbnVtYmVyJykge1xuXHRcdFx0XHRjbGFzc2VzLnB1c2goYXJnKTtcblx0XHRcdH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShhcmcpKSB7XG5cdFx0XHRcdGlmIChhcmcubGVuZ3RoKSB7XG5cdFx0XHRcdFx0dmFyIGlubmVyID0gY2xhc3NOYW1lcy5hcHBseShudWxsLCBhcmcpO1xuXHRcdFx0XHRcdGlmIChpbm5lcikge1xuXHRcdFx0XHRcdFx0Y2xhc3Nlcy5wdXNoKGlubmVyKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSBpZiAoYXJnVHlwZSA9PT0gJ29iamVjdCcpIHtcblx0XHRcdFx0aWYgKGFyZy50b1N0cmluZyA9PT0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZykge1xuXHRcdFx0XHRcdGZvciAodmFyIGtleSBpbiBhcmcpIHtcblx0XHRcdFx0XHRcdGlmIChoYXNPd24uY2FsbChhcmcsIGtleSkgJiYgYXJnW2tleV0pIHtcblx0XHRcdFx0XHRcdFx0Y2xhc3Nlcy5wdXNoKGtleSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGNsYXNzZXMucHVzaChhcmcudG9TdHJpbmcoKSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gY2xhc3Nlcy5qb2luKCcgJyk7XG5cdH1cblxuXHRpZiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgbW9kdWxlLmV4cG9ydHMpIHtcblx0XHRjbGFzc05hbWVzLmRlZmF1bHQgPSBjbGFzc05hbWVzO1xuXHRcdG1vZHVsZS5leHBvcnRzID0gY2xhc3NOYW1lcztcblx0fSBlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBkZWZpbmUuYW1kID09PSAnb2JqZWN0JyAmJiBkZWZpbmUuYW1kKSB7XG5cdFx0Ly8gcmVnaXN0ZXIgYXMgJ2NsYXNzbmFtZXMnLCBjb25zaXN0ZW50IHdpdGggbnBtIHBhY2thZ2UgbmFtZVxuXHRcdGRlZmluZSgnY2xhc3NuYW1lcycsIFtdLCBmdW5jdGlvbiAoKSB7XG5cdFx0XHRyZXR1cm4gY2xhc3NOYW1lcztcblx0XHR9KTtcblx0fSBlbHNlIHtcblx0XHR3aW5kb3cuY2xhc3NOYW1lcyA9IGNsYXNzTmFtZXM7XG5cdH1cbn0oKSk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///184\n")},679:(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("\n\nvar reactIs = __webpack_require__(864);\n\n/**\n * Copyright 2015, Yahoo! Inc.\n * Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.\n */\nvar REACT_STATICS = {\n  childContextTypes: true,\n  contextType: true,\n  contextTypes: true,\n  defaultProps: true,\n  displayName: true,\n  getDefaultProps: true,\n  getDerivedStateFromError: true,\n  getDerivedStateFromProps: true,\n  mixins: true,\n  propTypes: true,\n  type: true\n};\nvar KNOWN_STATICS = {\n  name: true,\n  length: true,\n  prototype: true,\n  caller: true,\n  callee: true,\n  arguments: true,\n  arity: true\n};\nvar FORWARD_REF_STATICS = {\n  '$$typeof': true,\n  render: true,\n  defaultProps: true,\n  displayName: true,\n  propTypes: true\n};\nvar MEMO_STATICS = {\n  '$$typeof': true,\n  compare: true,\n  defaultProps: true,\n  displayName: true,\n  propTypes: true,\n  type: true\n};\nvar TYPE_STATICS = {};\nTYPE_STATICS[reactIs.ForwardRef] = FORWARD_REF_STATICS;\nTYPE_STATICS[reactIs.Memo] = MEMO_STATICS;\n\nfunction getStatics(component) {\n  // React v16.11 and below\n  if (reactIs.isMemo(component)) {\n    return MEMO_STATICS;\n  } // React v16.12 and above\n\n\n  return TYPE_STATICS[component['$$typeof']] || REACT_STATICS;\n}\n\nvar defineProperty = Object.defineProperty;\nvar getOwnPropertyNames = Object.getOwnPropertyNames;\nvar getOwnPropertySymbols = Object.getOwnPropertySymbols;\nvar getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\nvar getPrototypeOf = Object.getPrototypeOf;\nvar objectPrototype = Object.prototype;\nfunction hoistNonReactStatics(targetComponent, sourceComponent, blacklist) {\n  if (typeof sourceComponent !== 'string') {\n    // don't hoist over string (html) components\n    if (objectPrototype) {\n      var inheritedComponent = getPrototypeOf(sourceComponent);\n\n      if (inheritedComponent && inheritedComponent !== objectPrototype) {\n        hoistNonReactStatics(targetComponent, inheritedComponent, blacklist);\n      }\n    }\n\n    var keys = getOwnPropertyNames(sourceComponent);\n\n    if (getOwnPropertySymbols) {\n      keys = keys.concat(getOwnPropertySymbols(sourceComponent));\n    }\n\n    var targetStatics = getStatics(targetComponent);\n    var sourceStatics = getStatics(sourceComponent);\n\n    for (var i = 0; i < keys.length; ++i) {\n      var key = keys[i];\n\n      if (!KNOWN_STATICS[key] && !(blacklist && blacklist[key]) && !(sourceStatics && sourceStatics[key]) && !(targetStatics && targetStatics[key])) {\n        var descriptor = getOwnPropertyDescriptor(sourceComponent, key);\n\n        try {\n          // Avoid failures from read-only properties\n          defineProperty(targetComponent, key, descriptor);\n        } catch (e) {}\n      }\n    }\n  }\n\n  return targetComponent;\n}\n\nmodule.exports = hoistNonReactStatics;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjc5LmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLGNBQWMsbUJBQU8sQ0FBQyxHQUFVOztBQUVoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLG9CQUFvQixpQkFBaUI7QUFDckM7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9ub2RlX21vZHVsZXMvaG9pc3Qtbm9uLXJlYWN0LXN0YXRpY3MvZGlzdC9ob2lzdC1ub24tcmVhY3Qtc3RhdGljcy5janMuanM/ZGE2YSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbnZhciByZWFjdElzID0gcmVxdWlyZSgncmVhY3QtaXMnKTtcblxuLyoqXG4gKiBDb3B5cmlnaHQgMjAxNSwgWWFob28hIEluYy5cbiAqIENvcHlyaWdodHMgbGljZW5zZWQgdW5kZXIgdGhlIE5ldyBCU0QgTGljZW5zZS4gU2VlIHRoZSBhY2NvbXBhbnlpbmcgTElDRU5TRSBmaWxlIGZvciB0ZXJtcy5cbiAqL1xudmFyIFJFQUNUX1NUQVRJQ1MgPSB7XG4gIGNoaWxkQ29udGV4dFR5cGVzOiB0cnVlLFxuICBjb250ZXh0VHlwZTogdHJ1ZSxcbiAgY29udGV4dFR5cGVzOiB0cnVlLFxuICBkZWZhdWx0UHJvcHM6IHRydWUsXG4gIGRpc3BsYXlOYW1lOiB0cnVlLFxuICBnZXREZWZhdWx0UHJvcHM6IHRydWUsXG4gIGdldERlcml2ZWRTdGF0ZUZyb21FcnJvcjogdHJ1ZSxcbiAgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzOiB0cnVlLFxuICBtaXhpbnM6IHRydWUsXG4gIHByb3BUeXBlczogdHJ1ZSxcbiAgdHlwZTogdHJ1ZVxufTtcbnZhciBLTk9XTl9TVEFUSUNTID0ge1xuICBuYW1lOiB0cnVlLFxuICBsZW5ndGg6IHRydWUsXG4gIHByb3RvdHlwZTogdHJ1ZSxcbiAgY2FsbGVyOiB0cnVlLFxuICBjYWxsZWU6IHRydWUsXG4gIGFyZ3VtZW50czogdHJ1ZSxcbiAgYXJpdHk6IHRydWVcbn07XG52YXIgRk9SV0FSRF9SRUZfU1RBVElDUyA9IHtcbiAgJyQkdHlwZW9mJzogdHJ1ZSxcbiAgcmVuZGVyOiB0cnVlLFxuICBkZWZhdWx0UHJvcHM6IHRydWUsXG4gIGRpc3BsYXlOYW1lOiB0cnVlLFxuICBwcm9wVHlwZXM6IHRydWVcbn07XG52YXIgTUVNT19TVEFUSUNTID0ge1xuICAnJCR0eXBlb2YnOiB0cnVlLFxuICBjb21wYXJlOiB0cnVlLFxuICBkZWZhdWx0UHJvcHM6IHRydWUsXG4gIGRpc3BsYXlOYW1lOiB0cnVlLFxuICBwcm9wVHlwZXM6IHRydWUsXG4gIHR5cGU6IHRydWVcbn07XG52YXIgVFlQRV9TVEFUSUNTID0ge307XG5UWVBFX1NUQVRJQ1NbcmVhY3RJcy5Gb3J3YXJkUmVmXSA9IEZPUldBUkRfUkVGX1NUQVRJQ1M7XG5UWVBFX1NUQVRJQ1NbcmVhY3RJcy5NZW1vXSA9IE1FTU9fU1RBVElDUztcblxuZnVuY3Rpb24gZ2V0U3RhdGljcyhjb21wb25lbnQpIHtcbiAgLy8gUmVhY3QgdjE2LjExIGFuZCBiZWxvd1xuICBpZiAocmVhY3RJcy5pc01lbW8oY29tcG9uZW50KSkge1xuICAgIHJldHVybiBNRU1PX1NUQVRJQ1M7XG4gIH0gLy8gUmVhY3QgdjE2LjEyIGFuZCBhYm92ZVxuXG5cbiAgcmV0dXJuIFRZUEVfU1RBVElDU1tjb21wb25lbnRbJyQkdHlwZW9mJ11dIHx8IFJFQUNUX1NUQVRJQ1M7XG59XG5cbnZhciBkZWZpbmVQcm9wZXJ0eSA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBnZXRPd25Qcm9wZXJ0eU5hbWVzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXM7XG52YXIgZ2V0T3duUHJvcGVydHlTeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scztcbnZhciBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xudmFyIGdldFByb3RvdHlwZU9mID0gT2JqZWN0LmdldFByb3RvdHlwZU9mO1xudmFyIG9iamVjdFByb3RvdHlwZSA9IE9iamVjdC5wcm90b3R5cGU7XG5mdW5jdGlvbiBob2lzdE5vblJlYWN0U3RhdGljcyh0YXJnZXRDb21wb25lbnQsIHNvdXJjZUNvbXBvbmVudCwgYmxhY2tsaXN0KSB7XG4gIGlmICh0eXBlb2Ygc291cmNlQ29tcG9uZW50ICE9PSAnc3RyaW5nJykge1xuICAgIC8vIGRvbid0IGhvaXN0IG92ZXIgc3RyaW5nIChodG1sKSBjb21wb25lbnRzXG4gICAgaWYgKG9iamVjdFByb3RvdHlwZSkge1xuICAgICAgdmFyIGluaGVyaXRlZENvbXBvbmVudCA9IGdldFByb3RvdHlwZU9mKHNvdXJjZUNvbXBvbmVudCk7XG5cbiAgICAgIGlmIChpbmhlcml0ZWRDb21wb25lbnQgJiYgaW5oZXJpdGVkQ29tcG9uZW50ICE9PSBvYmplY3RQcm90b3R5cGUpIHtcbiAgICAgICAgaG9pc3ROb25SZWFjdFN0YXRpY3ModGFyZ2V0Q29tcG9uZW50LCBpbmhlcml0ZWRDb21wb25lbnQsIGJsYWNrbGlzdCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGtleXMgPSBnZXRPd25Qcm9wZXJ0eU5hbWVzKHNvdXJjZUNvbXBvbmVudCk7XG5cbiAgICBpZiAoZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gICAgICBrZXlzID0ga2V5cy5jb25jYXQoZ2V0T3duUHJvcGVydHlTeW1ib2xzKHNvdXJjZUNvbXBvbmVudCkpO1xuICAgIH1cblxuICAgIHZhciB0YXJnZXRTdGF0aWNzID0gZ2V0U3RhdGljcyh0YXJnZXRDb21wb25lbnQpO1xuICAgIHZhciBzb3VyY2VTdGF0aWNzID0gZ2V0U3RhdGljcyhzb3VyY2VDb21wb25lbnQpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKSB7XG4gICAgICB2YXIga2V5ID0ga2V5c1tpXTtcblxuICAgICAgaWYgKCFLTk9XTl9TVEFUSUNTW2tleV0gJiYgIShibGFja2xpc3QgJiYgYmxhY2tsaXN0W2tleV0pICYmICEoc291cmNlU3RhdGljcyAmJiBzb3VyY2VTdGF0aWNzW2tleV0pICYmICEodGFyZ2V0U3RhdGljcyAmJiB0YXJnZXRTdGF0aWNzW2tleV0pKSB7XG4gICAgICAgIHZhciBkZXNjcmlwdG9yID0gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZUNvbXBvbmVudCwga2V5KTtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgIC8vIEF2b2lkIGZhaWx1cmVzIGZyb20gcmVhZC1vbmx5IHByb3BlcnRpZXNcbiAgICAgICAgICBkZWZpbmVQcm9wZXJ0eSh0YXJnZXRDb21wb25lbnQsIGtleSwgZGVzY3JpcHRvcik7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRhcmdldENvbXBvbmVudDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBob2lzdE5vblJlYWN0U3RhdGljcztcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///679\n")},826:module=>{eval("module.exports = Array.isArray || function (arr) {\n  return Object.prototype.toString.call(arr) == '[object Array]';\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODI2LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL21kYy1yZWFjdC8uL25vZGVfbW9kdWxlcy9pc2FycmF5L2luZGV4LmpzP2UzZGIiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uIChhcnIpIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChhcnIpID09ICdbb2JqZWN0IEFycmF5XSc7XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///826\n")},84:function(module){eval("/**\n * marked - a markdown parser\n * Copyright (c) 2011-2021, Christopher Jeffrey. (MIT Licensed)\n * https://github.com/markedjs/marked\n */\n\n/**\n * DO NOT EDIT THIS FILE\n * The code in this file is generated from files in ./src/\n */\n\n(function (global, factory) {\n   true ? module.exports = factory() :\n  0;\n})(this, (function () { 'use strict';\n\n  function _defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  function _createClass(Constructor, protoProps, staticProps) {\n    if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) _defineProperties(Constructor, staticProps);\n    return Constructor;\n  }\n\n  function _unsupportedIterableToArray(o, minLen) {\n    if (!o) return;\n    if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n    var n = Object.prototype.toString.call(o).slice(8, -1);\n    if (n === \"Object\" && o.constructor) n = o.constructor.name;\n    if (n === \"Map\" || n === \"Set\") return Array.from(o);\n    if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n  }\n\n  function _arrayLikeToArray(arr, len) {\n    if (len == null || len > arr.length) len = arr.length;\n\n    for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n\n    return arr2;\n  }\n\n  function _createForOfIteratorHelperLoose(o, allowArrayLike) {\n    var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"];\n    if (it) return (it = it.call(o)).next.bind(it);\n\n    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n      return function () {\n        if (i >= o.length) return {\n          done: true\n        };\n        return {\n          done: false,\n          value: o[i++]\n        };\n      };\n    }\n\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n\n  var defaults$5 = {exports: {}};\n\n  function getDefaults$1() {\n    return {\n      baseUrl: null,\n      breaks: false,\n      extensions: null,\n      gfm: true,\n      headerIds: true,\n      headerPrefix: '',\n      highlight: null,\n      langPrefix: 'language-',\n      mangle: true,\n      pedantic: false,\n      renderer: null,\n      sanitize: false,\n      sanitizer: null,\n      silent: false,\n      smartLists: false,\n      smartypants: false,\n      tokenizer: null,\n      walkTokens: null,\n      xhtml: false\n    };\n  }\n\n  function changeDefaults$1(newDefaults) {\n    defaults$5.exports.defaults = newDefaults;\n  }\n\n  defaults$5.exports = {\n    defaults: getDefaults$1(),\n    getDefaults: getDefaults$1,\n    changeDefaults: changeDefaults$1\n  };\n\n  /**\n   * Helpers\n   */\n  var escapeTest = /[&<>\"']/;\n  var escapeReplace = /[&<>\"']/g;\n  var escapeTestNoEncode = /[<>\"']|&(?!#?\\w+;)/;\n  var escapeReplaceNoEncode = /[<>\"']|&(?!#?\\w+;)/g;\n  var escapeReplacements = {\n    '&': '&amp;',\n    '<': '&lt;',\n    '>': '&gt;',\n    '\"': '&quot;',\n    \"'\": '&#39;'\n  };\n\n  var getEscapeReplacement = function getEscapeReplacement(ch) {\n    return escapeReplacements[ch];\n  };\n\n  function escape$2(html, encode) {\n    if (encode) {\n      if (escapeTest.test(html)) {\n        return html.replace(escapeReplace, getEscapeReplacement);\n      }\n    } else {\n      if (escapeTestNoEncode.test(html)) {\n        return html.replace(escapeReplaceNoEncode, getEscapeReplacement);\n      }\n    }\n\n    return html;\n  }\n\n  var unescapeTest = /&(#(?:\\d+)|(?:#x[0-9A-Fa-f]+)|(?:\\w+));?/ig;\n\n  function unescape$1(html) {\n    // explicitly match decimal, hex, and named HTML entities\n    return html.replace(unescapeTest, function (_, n) {\n      n = n.toLowerCase();\n      if (n === 'colon') return ':';\n\n      if (n.charAt(0) === '#') {\n        return n.charAt(1) === 'x' ? String.fromCharCode(parseInt(n.substring(2), 16)) : String.fromCharCode(+n.substring(1));\n      }\n\n      return '';\n    });\n  }\n\n  var caret = /(^|[^\\[])\\^/g;\n\n  function edit$1(regex, opt) {\n    regex = regex.source || regex;\n    opt = opt || '';\n    var obj = {\n      replace: function replace(name, val) {\n        val = val.source || val;\n        val = val.replace(caret, '$1');\n        regex = regex.replace(name, val);\n        return obj;\n      },\n      getRegex: function getRegex() {\n        return new RegExp(regex, opt);\n      }\n    };\n    return obj;\n  }\n\n  var nonWordAndColonTest = /[^\\w:]/g;\n  var originIndependentUrl = /^$|^[a-z][a-z0-9+.-]*:|^[?#]/i;\n\n  function cleanUrl$1(sanitize, base, href) {\n    if (sanitize) {\n      var prot;\n\n      try {\n        prot = decodeURIComponent(unescape$1(href)).replace(nonWordAndColonTest, '').toLowerCase();\n      } catch (e) {\n        return null;\n      }\n\n      if (prot.indexOf('javascript:') === 0 || prot.indexOf('vbscript:') === 0 || prot.indexOf('data:') === 0) {\n        return null;\n      }\n    }\n\n    if (base && !originIndependentUrl.test(href)) {\n      href = resolveUrl(base, href);\n    }\n\n    try {\n      href = encodeURI(href).replace(/%25/g, '%');\n    } catch (e) {\n      return null;\n    }\n\n    return href;\n  }\n\n  var baseUrls = {};\n  var justDomain = /^[^:]+:\\/*[^/]*$/;\n  var protocol = /^([^:]+:)[\\s\\S]*$/;\n  var domain = /^([^:]+:\\/*[^/]*)[\\s\\S]*$/;\n\n  function resolveUrl(base, href) {\n    if (!baseUrls[' ' + base]) {\n      // we can ignore everything in base after the last slash of its path component,\n      // but we might need to add _that_\n      // https://tools.ietf.org/html/rfc3986#section-3\n      if (justDomain.test(base)) {\n        baseUrls[' ' + base] = base + '/';\n      } else {\n        baseUrls[' ' + base] = rtrim$1(base, '/', true);\n      }\n    }\n\n    base = baseUrls[' ' + base];\n    var relativeBase = base.indexOf(':') === -1;\n\n    if (href.substring(0, 2) === '//') {\n      if (relativeBase) {\n        return href;\n      }\n\n      return base.replace(protocol, '$1') + href;\n    } else if (href.charAt(0) === '/') {\n      if (relativeBase) {\n        return href;\n      }\n\n      return base.replace(domain, '$1') + href;\n    } else {\n      return base + href;\n    }\n  }\n\n  var noopTest$1 = {\n    exec: function noopTest() {}\n  };\n\n  function merge$2(obj) {\n    var i = 1,\n        target,\n        key;\n\n    for (; i < arguments.length; i++) {\n      target = arguments[i];\n\n      for (key in target) {\n        if (Object.prototype.hasOwnProperty.call(target, key)) {\n          obj[key] = target[key];\n        }\n      }\n    }\n\n    return obj;\n  }\n\n  function splitCells$1(tableRow, count) {\n    // ensure that every cell-delimiting pipe has a space\n    // before it to distinguish it from an escaped pipe\n    var row = tableRow.replace(/\\|/g, function (match, offset, str) {\n      var escaped = false,\n          curr = offset;\n\n      while (--curr >= 0 && str[curr] === '\\\\') {\n        escaped = !escaped;\n      }\n\n      if (escaped) {\n        // odd number of slashes means | is escaped\n        // so we leave it alone\n        return '|';\n      } else {\n        // add space before unescaped |\n        return ' |';\n      }\n    }),\n        cells = row.split(/ \\|/);\n    var i = 0; // First/last cell in a row cannot be empty if it has no leading/trailing pipe\n\n    if (!cells[0].trim()) {\n      cells.shift();\n    }\n\n    if (!cells[cells.length - 1].trim()) {\n      cells.pop();\n    }\n\n    if (cells.length > count) {\n      cells.splice(count);\n    } else {\n      while (cells.length < count) {\n        cells.push('');\n      }\n    }\n\n    for (; i < cells.length; i++) {\n      // leading or trailing whitespace is ignored per the gfm spec\n      cells[i] = cells[i].trim().replace(/\\\\\\|/g, '|');\n    }\n\n    return cells;\n  } // Remove trailing 'c's. Equivalent to str.replace(/c*$/, '').\n  // /c*$/ is vulnerable to REDOS.\n  // invert: Remove suffix of non-c chars instead. Default falsey.\n\n\n  function rtrim$1(str, c, invert) {\n    var l = str.length;\n\n    if (l === 0) {\n      return '';\n    } // Length of suffix matching the invert condition.\n\n\n    var suffLen = 0; // Step left until we fail to match the invert condition.\n\n    while (suffLen < l) {\n      var currChar = str.charAt(l - suffLen - 1);\n\n      if (currChar === c && !invert) {\n        suffLen++;\n      } else if (currChar !== c && invert) {\n        suffLen++;\n      } else {\n        break;\n      }\n    }\n\n    return str.substr(0, l - suffLen);\n  }\n\n  function findClosingBracket$1(str, b) {\n    if (str.indexOf(b[1]) === -1) {\n      return -1;\n    }\n\n    var l = str.length;\n    var level = 0,\n        i = 0;\n\n    for (; i < l; i++) {\n      if (str[i] === '\\\\') {\n        i++;\n      } else if (str[i] === b[0]) {\n        level++;\n      } else if (str[i] === b[1]) {\n        level--;\n\n        if (level < 0) {\n          return i;\n        }\n      }\n    }\n\n    return -1;\n  }\n\n  function checkSanitizeDeprecation$1(opt) {\n    if (opt && opt.sanitize && !opt.silent) {\n      console.warn('marked(): sanitize and sanitizer parameters are deprecated since version 0.7.0, should not be used and will be removed in the future. Read more here: https://marked.js.org/#/USING_ADVANCED.md#options');\n    }\n  } // copied from https://stackoverflow.com/a/5450113/806777\n\n\n  function repeatString$1(pattern, count) {\n    if (count < 1) {\n      return '';\n    }\n\n    var result = '';\n\n    while (count > 1) {\n      if (count & 1) {\n        result += pattern;\n      }\n\n      count >>= 1;\n      pattern += pattern;\n    }\n\n    return result + pattern;\n  }\n\n  var helpers = {\n    escape: escape$2,\n    unescape: unescape$1,\n    edit: edit$1,\n    cleanUrl: cleanUrl$1,\n    resolveUrl: resolveUrl,\n    noopTest: noopTest$1,\n    merge: merge$2,\n    splitCells: splitCells$1,\n    rtrim: rtrim$1,\n    findClosingBracket: findClosingBracket$1,\n    checkSanitizeDeprecation: checkSanitizeDeprecation$1,\n    repeatString: repeatString$1\n  };\n\n  var defaults$4 = defaults$5.exports.defaults;\n  var rtrim = helpers.rtrim,\n      splitCells = helpers.splitCells,\n      _escape = helpers.escape,\n      findClosingBracket = helpers.findClosingBracket;\n\n  function outputLink(cap, link, raw, lexer) {\n    var href = link.href;\n    var title = link.title ? _escape(link.title) : null;\n    var text = cap[1].replace(/\\\\([\\[\\]])/g, '$1');\n\n    if (cap[0].charAt(0) !== '!') {\n      lexer.state.inLink = true;\n      var token = {\n        type: 'link',\n        raw: raw,\n        href: href,\n        title: title,\n        text: text,\n        tokens: lexer.inlineTokens(text, [])\n      };\n      lexer.state.inLink = false;\n      return token;\n    } else {\n      return {\n        type: 'image',\n        raw: raw,\n        href: href,\n        title: title,\n        text: _escape(text)\n      };\n    }\n  }\n\n  function indentCodeCompensation(raw, text) {\n    var matchIndentToCode = raw.match(/^(\\s+)(?:```)/);\n\n    if (matchIndentToCode === null) {\n      return text;\n    }\n\n    var indentToCode = matchIndentToCode[1];\n    return text.split('\\n').map(function (node) {\n      var matchIndentInNode = node.match(/^\\s+/);\n\n      if (matchIndentInNode === null) {\n        return node;\n      }\n\n      var indentInNode = matchIndentInNode[0];\n\n      if (indentInNode.length >= indentToCode.length) {\n        return node.slice(indentToCode.length);\n      }\n\n      return node;\n    }).join('\\n');\n  }\n  /**\n   * Tokenizer\n   */\n\n\n  var Tokenizer_1 = /*#__PURE__*/function () {\n    function Tokenizer(options) {\n      this.options = options || defaults$4;\n    }\n\n    var _proto = Tokenizer.prototype;\n\n    _proto.space = function space(src) {\n      var cap = this.rules.block.newline.exec(src);\n\n      if (cap) {\n        if (cap[0].length > 1) {\n          return {\n            type: 'space',\n            raw: cap[0]\n          };\n        }\n\n        return {\n          raw: '\\n'\n        };\n      }\n    };\n\n    _proto.code = function code(src) {\n      var cap = this.rules.block.code.exec(src);\n\n      if (cap) {\n        var text = cap[0].replace(/^ {1,4}/gm, '');\n        return {\n          type: 'code',\n          raw: cap[0],\n          codeBlockStyle: 'indented',\n          text: !this.options.pedantic ? rtrim(text, '\\n') : text\n        };\n      }\n    };\n\n    _proto.fences = function fences(src) {\n      var cap = this.rules.block.fences.exec(src);\n\n      if (cap) {\n        var raw = cap[0];\n        var text = indentCodeCompensation(raw, cap[3] || '');\n        return {\n          type: 'code',\n          raw: raw,\n          lang: cap[2] ? cap[2].trim() : cap[2],\n          text: text\n        };\n      }\n    };\n\n    _proto.heading = function heading(src) {\n      var cap = this.rules.block.heading.exec(src);\n\n      if (cap) {\n        var text = cap[2].trim(); // remove trailing #s\n\n        if (/#$/.test(text)) {\n          var trimmed = rtrim(text, '#');\n\n          if (this.options.pedantic) {\n            text = trimmed.trim();\n          } else if (!trimmed || / $/.test(trimmed)) {\n            // CommonMark requires space before trailing #s\n            text = trimmed.trim();\n          }\n        }\n\n        var token = {\n          type: 'heading',\n          raw: cap[0],\n          depth: cap[1].length,\n          text: text,\n          tokens: []\n        };\n        this.lexer.inline(token.text, token.tokens);\n        return token;\n      }\n    };\n\n    _proto.hr = function hr(src) {\n      var cap = this.rules.block.hr.exec(src);\n\n      if (cap) {\n        return {\n          type: 'hr',\n          raw: cap[0]\n        };\n      }\n    };\n\n    _proto.blockquote = function blockquote(src) {\n      var cap = this.rules.block.blockquote.exec(src);\n\n      if (cap) {\n        var text = cap[0].replace(/^ *> ?/gm, '');\n        return {\n          type: 'blockquote',\n          raw: cap[0],\n          tokens: this.lexer.blockTokens(text, []),\n          text: text\n        };\n      }\n    };\n\n    _proto.list = function list(src) {\n      var cap = this.rules.block.list.exec(src);\n\n      if (cap) {\n        var raw, istask, ischecked, indent, i, blankLine, endsWithBlankLine, line, lines, itemContents;\n        var bull = cap[1].trim();\n        var isordered = bull.length > 1;\n        var list = {\n          type: 'list',\n          raw: '',\n          ordered: isordered,\n          start: isordered ? +bull.slice(0, -1) : '',\n          loose: false,\n          items: []\n        };\n        bull = isordered ? \"\\\\d{1,9}\\\\\" + bull.slice(-1) : \"\\\\\" + bull;\n\n        if (this.options.pedantic) {\n          bull = isordered ? bull : '[*+-]';\n        } // Get next list item\n\n\n        var itemRegex = new RegExp(\"^( {0,3}\" + bull + \")((?: [^\\\\n]*| *)(?:\\\\n[^\\\\n]*)*(?:\\\\n|$))\"); // Get each top-level item\n\n        while (src) {\n          if (this.rules.block.hr.test(src)) {\n            // End list if we encounter an HR (possibly move into itemRegex?)\n            break;\n          }\n\n          if (!(cap = itemRegex.exec(src))) {\n            break;\n          }\n\n          lines = cap[2].split('\\n');\n\n          if (this.options.pedantic) {\n            indent = 2;\n            itemContents = lines[0].trimLeft();\n          } else {\n            indent = cap[2].search(/[^ ]/); // Find first non-space char\n\n            indent = cap[1].length + (indent > 4 ? 1 : indent); // intented code blocks after 4 spaces; indent is always 1\n\n            itemContents = lines[0].slice(indent - cap[1].length);\n          }\n\n          blankLine = false;\n          raw = cap[0];\n\n          if (!lines[0] && /^ *$/.test(lines[1])) {\n            // items begin with at most one blank line\n            raw = cap[1] + lines.slice(0, 2).join('\\n') + '\\n';\n            list.loose = true;\n            lines = [];\n          }\n\n          var nextBulletRegex = new RegExp(\"^ {0,\" + Math.min(3, indent - 1) + \"}(?:[*+-]|\\\\d{1,9}[.)])\");\n\n          for (i = 1; i < lines.length; i++) {\n            line = lines[i];\n\n            if (this.options.pedantic) {\n              // Re-align to follow commonmark nesting rules\n              line = line.replace(/^ {1,4}(?=( {4})*[^ ])/g, '  ');\n            } // End list item if found start of new bullet\n\n\n            if (nextBulletRegex.test(line)) {\n              raw = cap[1] + lines.slice(0, i).join('\\n') + '\\n';\n              break;\n            } // Until we encounter a blank line, item contents do not need indentation\n\n\n            if (!blankLine) {\n              if (!line.trim()) {\n                // Check if current line is empty\n                blankLine = true;\n              } // Dedent if possible\n\n\n              if (line.search(/[^ ]/) >= indent) {\n                itemContents += '\\n' + line.slice(indent);\n              } else {\n                itemContents += '\\n' + line;\n              }\n\n              continue;\n            } // Dedent this line\n\n\n            if (line.search(/[^ ]/) >= indent || !line.trim()) {\n              itemContents += '\\n' + line.slice(indent);\n              continue;\n            } else {\n              // Line was not properly indented; end of this item\n              raw = cap[1] + lines.slice(0, i).join('\\n') + '\\n';\n              break;\n            }\n          }\n\n          if (!list.loose) {\n            // If the previous item ended with a blank line, the list is loose\n            if (endsWithBlankLine) {\n              list.loose = true;\n            } else if (/\\n *\\n *$/.test(raw)) {\n              endsWithBlankLine = true;\n            }\n          } // Check for task list items\n\n\n          if (this.options.gfm) {\n            istask = /^\\[[ xX]\\] /.exec(itemContents);\n\n            if (istask) {\n              ischecked = istask[0] !== '[ ] ';\n              itemContents = itemContents.replace(/^\\[[ xX]\\] +/, '');\n            }\n          }\n\n          list.items.push({\n            type: 'list_item',\n            raw: raw,\n            task: !!istask,\n            checked: ischecked,\n            loose: false,\n            text: itemContents\n          });\n          list.raw += raw;\n          src = src.slice(raw.length);\n        } // Do not consume newlines at end of final item. Alternatively, make itemRegex *start* with any newlines to simplify/speed up endsWithBlankLine logic\n\n\n        list.items[list.items.length - 1].raw = raw.trimRight();\n        list.items[list.items.length - 1].text = itemContents.trimRight();\n        list.raw = list.raw.trimRight();\n        var l = list.items.length; // Item child tokens handled here at end because we needed to have the final item to trim it first\n\n        for (i = 0; i < l; i++) {\n          this.lexer.state.top = false;\n          list.items[i].tokens = this.lexer.blockTokens(list.items[i].text, []);\n\n          if (list.items[i].tokens.some(function (t) {\n            return t.type === 'space';\n          })) {\n            list.loose = true;\n            list.items[i].loose = true;\n          }\n        }\n\n        return list;\n      }\n    };\n\n    _proto.html = function html(src) {\n      var cap = this.rules.block.html.exec(src);\n\n      if (cap) {\n        var token = {\n          type: 'html',\n          raw: cap[0],\n          pre: !this.options.sanitizer && (cap[1] === 'pre' || cap[1] === 'script' || cap[1] === 'style'),\n          text: cap[0]\n        };\n\n        if (this.options.sanitize) {\n          token.type = 'paragraph';\n          token.text = this.options.sanitizer ? this.options.sanitizer(cap[0]) : _escape(cap[0]);\n          token.tokens = [];\n          this.lexer.inline(token.text, token.tokens);\n        }\n\n        return token;\n      }\n    };\n\n    _proto.def = function def(src) {\n      var cap = this.rules.block.def.exec(src);\n\n      if (cap) {\n        if (cap[3]) cap[3] = cap[3].substring(1, cap[3].length - 1);\n        var tag = cap[1].toLowerCase().replace(/\\s+/g, ' ');\n        return {\n          type: 'def',\n          tag: tag,\n          raw: cap[0],\n          href: cap[2],\n          title: cap[3]\n        };\n      }\n    };\n\n    _proto.table = function table(src) {\n      var cap = this.rules.block.table.exec(src);\n\n      if (cap) {\n        var item = {\n          type: 'table',\n          header: splitCells(cap[1]).map(function (c) {\n            return {\n              text: c\n            };\n          }),\n          align: cap[2].replace(/^ *|\\| *$/g, '').split(/ *\\| */),\n          rows: cap[3] ? cap[3].replace(/\\n$/, '').split('\\n') : []\n        };\n\n        if (item.header.length === item.align.length) {\n          item.raw = cap[0];\n          var l = item.align.length;\n          var i, j, k, row;\n\n          for (i = 0; i < l; i++) {\n            if (/^ *-+: *$/.test(item.align[i])) {\n              item.align[i] = 'right';\n            } else if (/^ *:-+: *$/.test(item.align[i])) {\n              item.align[i] = 'center';\n            } else if (/^ *:-+ *$/.test(item.align[i])) {\n              item.align[i] = 'left';\n            } else {\n              item.align[i] = null;\n            }\n          }\n\n          l = item.rows.length;\n\n          for (i = 0; i < l; i++) {\n            item.rows[i] = splitCells(item.rows[i], item.header.length).map(function (c) {\n              return {\n                text: c\n              };\n            });\n          } // parse child tokens inside headers and cells\n          // header child tokens\n\n\n          l = item.header.length;\n\n          for (j = 0; j < l; j++) {\n            item.header[j].tokens = [];\n            this.lexer.inlineTokens(item.header[j].text, item.header[j].tokens);\n          } // cell child tokens\n\n\n          l = item.rows.length;\n\n          for (j = 0; j < l; j++) {\n            row = item.rows[j];\n\n            for (k = 0; k < row.length; k++) {\n              row[k].tokens = [];\n              this.lexer.inlineTokens(row[k].text, row[k].tokens);\n            }\n          }\n\n          return item;\n        }\n      }\n    };\n\n    _proto.lheading = function lheading(src) {\n      var cap = this.rules.block.lheading.exec(src);\n\n      if (cap) {\n        var token = {\n          type: 'heading',\n          raw: cap[0],\n          depth: cap[2].charAt(0) === '=' ? 1 : 2,\n          text: cap[1],\n          tokens: []\n        };\n        this.lexer.inline(token.text, token.tokens);\n        return token;\n      }\n    };\n\n    _proto.paragraph = function paragraph(src) {\n      var cap = this.rules.block.paragraph.exec(src);\n\n      if (cap) {\n        var token = {\n          type: 'paragraph',\n          raw: cap[0],\n          text: cap[1].charAt(cap[1].length - 1) === '\\n' ? cap[1].slice(0, -1) : cap[1],\n          tokens: []\n        };\n        this.lexer.inline(token.text, token.tokens);\n        return token;\n      }\n    };\n\n    _proto.text = function text(src) {\n      var cap = this.rules.block.text.exec(src);\n\n      if (cap) {\n        var token = {\n          type: 'text',\n          raw: cap[0],\n          text: cap[0],\n          tokens: []\n        };\n        this.lexer.inline(token.text, token.tokens);\n        return token;\n      }\n    };\n\n    _proto.escape = function escape(src) {\n      var cap = this.rules.inline.escape.exec(src);\n\n      if (cap) {\n        return {\n          type: 'escape',\n          raw: cap[0],\n          text: _escape(cap[1])\n        };\n      }\n    };\n\n    _proto.tag = function tag(src) {\n      var cap = this.rules.inline.tag.exec(src);\n\n      if (cap) {\n        if (!this.lexer.state.inLink && /^<a /i.test(cap[0])) {\n          this.lexer.state.inLink = true;\n        } else if (this.lexer.state.inLink && /^<\\/a>/i.test(cap[0])) {\n          this.lexer.state.inLink = false;\n        }\n\n        if (!this.lexer.state.inRawBlock && /^<(pre|code|kbd|script)(\\s|>)/i.test(cap[0])) {\n          this.lexer.state.inRawBlock = true;\n        } else if (this.lexer.state.inRawBlock && /^<\\/(pre|code|kbd|script)(\\s|>)/i.test(cap[0])) {\n          this.lexer.state.inRawBlock = false;\n        }\n\n        return {\n          type: this.options.sanitize ? 'text' : 'html',\n          raw: cap[0],\n          inLink: this.lexer.state.inLink,\n          inRawBlock: this.lexer.state.inRawBlock,\n          text: this.options.sanitize ? this.options.sanitizer ? this.options.sanitizer(cap[0]) : _escape(cap[0]) : cap[0]\n        };\n      }\n    };\n\n    _proto.link = function link(src) {\n      var cap = this.rules.inline.link.exec(src);\n\n      if (cap) {\n        var trimmedUrl = cap[2].trim();\n\n        if (!this.options.pedantic && /^</.test(trimmedUrl)) {\n          // commonmark requires matching angle brackets\n          if (!/>$/.test(trimmedUrl)) {\n            return;\n          } // ending angle bracket cannot be escaped\n\n\n          var rtrimSlash = rtrim(trimmedUrl.slice(0, -1), '\\\\');\n\n          if ((trimmedUrl.length - rtrimSlash.length) % 2 === 0) {\n            return;\n          }\n        } else {\n          // find closing parenthesis\n          var lastParenIndex = findClosingBracket(cap[2], '()');\n\n          if (lastParenIndex > -1) {\n            var start = cap[0].indexOf('!') === 0 ? 5 : 4;\n            var linkLen = start + cap[1].length + lastParenIndex;\n            cap[2] = cap[2].substring(0, lastParenIndex);\n            cap[0] = cap[0].substring(0, linkLen).trim();\n            cap[3] = '';\n          }\n        }\n\n        var href = cap[2];\n        var title = '';\n\n        if (this.options.pedantic) {\n          // split pedantic href and title\n          var link = /^([^'\"]*[^\\s])\\s+(['\"])(.*)\\2/.exec(href);\n\n          if (link) {\n            href = link[1];\n            title = link[3];\n          }\n        } else {\n          title = cap[3] ? cap[3].slice(1, -1) : '';\n        }\n\n        href = href.trim();\n\n        if (/^</.test(href)) {\n          if (this.options.pedantic && !/>$/.test(trimmedUrl)) {\n            // pedantic allows starting angle bracket without ending angle bracket\n            href = href.slice(1);\n          } else {\n            href = href.slice(1, -1);\n          }\n        }\n\n        return outputLink(cap, {\n          href: href ? href.replace(this.rules.inline._escapes, '$1') : href,\n          title: title ? title.replace(this.rules.inline._escapes, '$1') : title\n        }, cap[0], this.lexer);\n      }\n    };\n\n    _proto.reflink = function reflink(src, links) {\n      var cap;\n\n      if ((cap = this.rules.inline.reflink.exec(src)) || (cap = this.rules.inline.nolink.exec(src))) {\n        var link = (cap[2] || cap[1]).replace(/\\s+/g, ' ');\n        link = links[link.toLowerCase()];\n\n        if (!link || !link.href) {\n          var text = cap[0].charAt(0);\n          return {\n            type: 'text',\n            raw: text,\n            text: text\n          };\n        }\n\n        return outputLink(cap, link, cap[0], this.lexer);\n      }\n    };\n\n    _proto.emStrong = function emStrong(src, maskedSrc, prevChar) {\n      if (prevChar === void 0) {\n        prevChar = '';\n      }\n\n      var match = this.rules.inline.emStrong.lDelim.exec(src);\n      if (!match) return; // _ can't be between two alphanumerics. \\p{L}\\p{N} includes non-english alphabet/numbers as well\n\n      if (match[3] && prevChar.match(/(?:[0-9A-Za-z\\xAA\\xB2\\xB3\\xB5\\xB9\\xBA\\xBC-\\xBE\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0370-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u037F\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u048A-\\u052F\\u0531-\\u0556\\u0559\\u0560-\\u0588\\u05D0-\\u05EA\\u05EF-\\u05F2\\u0620-\\u064A\\u0660-\\u0669\\u066E\\u066F\\u0671-\\u06D3\\u06D5\\u06E5\\u06E6\\u06EE-\\u06FC\\u06FF\\u0710\\u0712-\\u072F\\u074D-\\u07A5\\u07B1\\u07C0-\\u07EA\\u07F4\\u07F5\\u07FA\\u0800-\\u0815\\u081A\\u0824\\u0828\\u0840-\\u0858\\u0860-\\u086A\\u08A0-\\u08B4\\u08B6-\\u08C7\\u0904-\\u0939\\u093D\\u0950\\u0958-\\u0961\\u0966-\\u096F\\u0971-\\u0980\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BD\\u09CE\\u09DC\\u09DD\\u09DF-\\u09E1\\u09E6-\\u09F1\\u09F4-\\u09F9\\u09FC\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A59-\\u0A5C\\u0A5E\\u0A66-\\u0A6F\\u0A72-\\u0A74\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABD\\u0AD0\\u0AE0\\u0AE1\\u0AE6-\\u0AEF\\u0AF9\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3D\\u0B5C\\u0B5D\\u0B5F-\\u0B61\\u0B66-\\u0B6F\\u0B71-\\u0B77\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BD0\\u0BE6-\\u0BF2\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C39\\u0C3D\\u0C58-\\u0C5A\\u0C60\\u0C61\\u0C66-\\u0C6F\\u0C78-\\u0C7E\\u0C80\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBD\\u0CDE\\u0CE0\\u0CE1\\u0CE6-\\u0CEF\\u0CF1\\u0CF2\\u0D04-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D\\u0D4E\\u0D54-\\u0D56\\u0D58-\\u0D61\\u0D66-\\u0D78\\u0D7A-\\u0D7F\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0DE6-\\u0DEF\\u0E01-\\u0E30\\u0E32\\u0E33\\u0E40-\\u0E46\\u0E50-\\u0E59\\u0E81\\u0E82\\u0E84\\u0E86-\\u0E8A\\u0E8C-\\u0EA3\\u0EA5\\u0EA7-\\u0EB0\\u0EB2\\u0EB3\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0ED0-\\u0ED9\\u0EDC-\\u0EDF\\u0F00\\u0F20-\\u0F33\\u0F40-\\u0F47\\u0F49-\\u0F6C\\u0F88-\\u0F8C\\u1000-\\u102A\\u103F-\\u1049\\u1050-\\u1055\\u105A-\\u105D\\u1061\\u1065\\u1066\\u106E-\\u1070\\u1075-\\u1081\\u108E\\u1090-\\u1099\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u1369-\\u137C\\u1380-\\u138F\\u13A0-\\u13F5\\u13F8-\\u13FD\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16EE-\\u16F8\\u1700-\\u170C\\u170E-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176C\\u176E-\\u1770\\u1780-\\u17B3\\u17D7\\u17DC\\u17E0-\\u17E9\\u17F0-\\u17F9\\u1810-\\u1819\\u1820-\\u1878\\u1880-\\u1884\\u1887-\\u18A8\\u18AA\\u18B0-\\u18F5\\u1900-\\u191E\\u1946-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19B0-\\u19C9\\u19D0-\\u19DA\\u1A00-\\u1A16\\u1A20-\\u1A54\\u1A80-\\u1A89\\u1A90-\\u1A99\\u1AA7\\u1B05-\\u1B33\\u1B45-\\u1B4B\\u1B50-\\u1B59\\u1B83-\\u1BA0\\u1BAE-\\u1BE5\\u1C00-\\u1C23\\u1C40-\\u1C49\\u1C4D-\\u1C7D\\u1C80-\\u1C88\\u1C90-\\u1CBA\\u1CBD-\\u1CBF\\u1CE9-\\u1CEC\\u1CEE-\\u1CF3\\u1CF5\\u1CF6\\u1CFA\\u1D00-\\u1DBF\\u1E00-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u2070\\u2071\\u2074-\\u2079\\u207F-\\u2089\\u2090-\\u209C\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2119-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u212D\\u212F-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2150-\\u2189\\u2460-\\u249B\\u24EA-\\u24FF\\u2776-\\u2793\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2CE4\\u2CEB-\\u2CEE\\u2CF2\\u2CF3\\u2CFD\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D80-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u2E2F\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303C\\u3041-\\u3096\\u309D-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312F\\u3131-\\u318E\\u3192-\\u3195\\u31A0-\\u31BF\\u31F0-\\u31FF\\u3220-\\u3229\\u3248-\\u324F\\u3251-\\u325F\\u3280-\\u3289\\u32B1-\\u32BF\\u3400-\\u4DBF\\u4E00-\\u9FFC\\uA000-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA62B\\uA640-\\uA66E\\uA67F-\\uA69D\\uA6A0-\\uA6EF\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA7BF\\uA7C2-\\uA7CA\\uA7F5-\\uA801\\uA803-\\uA805\\uA807-\\uA80A\\uA80C-\\uA822\\uA830-\\uA835\\uA840-\\uA873\\uA882-\\uA8B3\\uA8D0-\\uA8D9\\uA8F2-\\uA8F7\\uA8FB\\uA8FD\\uA8FE\\uA900-\\uA925\\uA930-\\uA946\\uA960-\\uA97C\\uA984-\\uA9B2\\uA9CF-\\uA9D9\\uA9E0-\\uA9E4\\uA9E6-\\uA9FE\\uAA00-\\uAA28\\uAA40-\\uAA42\\uAA44-\\uAA4B\\uAA50-\\uAA59\\uAA60-\\uAA76\\uAA7A\\uAA7E-\\uAAAF\\uAAB1\\uAAB5\\uAAB6\\uAAB9-\\uAABD\\uAAC0\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEA\\uAAF2-\\uAAF4\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uAB30-\\uAB5A\\uAB5C-\\uAB69\\uAB70-\\uABE2\\uABF0-\\uABF9\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D\\uFB1F-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF10-\\uFF19\\uFF21-\\uFF3A\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]|\\uD800[\\uDC00-\\uDC0B\\uDC0D-\\uDC26\\uDC28-\\uDC3A\\uDC3C\\uDC3D\\uDC3F-\\uDC4D\\uDC50-\\uDC5D\\uDC80-\\uDCFA\\uDD07-\\uDD33\\uDD40-\\uDD78\\uDD8A\\uDD8B\\uDE80-\\uDE9C\\uDEA0-\\uDED0\\uDEE1-\\uDEFB\\uDF00-\\uDF23\\uDF2D-\\uDF4A\\uDF50-\\uDF75\\uDF80-\\uDF9D\\uDFA0-\\uDFC3\\uDFC8-\\uDFCF\\uDFD1-\\uDFD5]|\\uD801[\\uDC00-\\uDC9D\\uDCA0-\\uDCA9\\uDCB0-\\uDCD3\\uDCD8-\\uDCFB\\uDD00-\\uDD27\\uDD30-\\uDD63\\uDE00-\\uDF36\\uDF40-\\uDF55\\uDF60-\\uDF67]|\\uD802[\\uDC00-\\uDC05\\uDC08\\uDC0A-\\uDC35\\uDC37\\uDC38\\uDC3C\\uDC3F-\\uDC55\\uDC58-\\uDC76\\uDC79-\\uDC9E\\uDCA7-\\uDCAF\\uDCE0-\\uDCF2\\uDCF4\\uDCF5\\uDCFB-\\uDD1B\\uDD20-\\uDD39\\uDD80-\\uDDB7\\uDDBC-\\uDDCF\\uDDD2-\\uDE00\\uDE10-\\uDE13\\uDE15-\\uDE17\\uDE19-\\uDE35\\uDE40-\\uDE48\\uDE60-\\uDE7E\\uDE80-\\uDE9F\\uDEC0-\\uDEC7\\uDEC9-\\uDEE4\\uDEEB-\\uDEEF\\uDF00-\\uDF35\\uDF40-\\uDF55\\uDF58-\\uDF72\\uDF78-\\uDF91\\uDFA9-\\uDFAF]|\\uD803[\\uDC00-\\uDC48\\uDC80-\\uDCB2\\uDCC0-\\uDCF2\\uDCFA-\\uDD23\\uDD30-\\uDD39\\uDE60-\\uDE7E\\uDE80-\\uDEA9\\uDEB0\\uDEB1\\uDF00-\\uDF27\\uDF30-\\uDF45\\uDF51-\\uDF54\\uDFB0-\\uDFCB\\uDFE0-\\uDFF6]|\\uD804[\\uDC03-\\uDC37\\uDC52-\\uDC6F\\uDC83-\\uDCAF\\uDCD0-\\uDCE8\\uDCF0-\\uDCF9\\uDD03-\\uDD26\\uDD36-\\uDD3F\\uDD44\\uDD47\\uDD50-\\uDD72\\uDD76\\uDD83-\\uDDB2\\uDDC1-\\uDDC4\\uDDD0-\\uDDDA\\uDDDC\\uDDE1-\\uDDF4\\uDE00-\\uDE11\\uDE13-\\uDE2B\\uDE80-\\uDE86\\uDE88\\uDE8A-\\uDE8D\\uDE8F-\\uDE9D\\uDE9F-\\uDEA8\\uDEB0-\\uDEDE\\uDEF0-\\uDEF9\\uDF05-\\uDF0C\\uDF0F\\uDF10\\uDF13-\\uDF28\\uDF2A-\\uDF30\\uDF32\\uDF33\\uDF35-\\uDF39\\uDF3D\\uDF50\\uDF5D-\\uDF61]|\\uD805[\\uDC00-\\uDC34\\uDC47-\\uDC4A\\uDC50-\\uDC59\\uDC5F-\\uDC61\\uDC80-\\uDCAF\\uDCC4\\uDCC5\\uDCC7\\uDCD0-\\uDCD9\\uDD80-\\uDDAE\\uDDD8-\\uDDDB\\uDE00-\\uDE2F\\uDE44\\uDE50-\\uDE59\\uDE80-\\uDEAA\\uDEB8\\uDEC0-\\uDEC9\\uDF00-\\uDF1A\\uDF30-\\uDF3B]|\\uD806[\\uDC00-\\uDC2B\\uDCA0-\\uDCF2\\uDCFF-\\uDD06\\uDD09\\uDD0C-\\uDD13\\uDD15\\uDD16\\uDD18-\\uDD2F\\uDD3F\\uDD41\\uDD50-\\uDD59\\uDDA0-\\uDDA7\\uDDAA-\\uDDD0\\uDDE1\\uDDE3\\uDE00\\uDE0B-\\uDE32\\uDE3A\\uDE50\\uDE5C-\\uDE89\\uDE9D\\uDEC0-\\uDEF8]|\\uD807[\\uDC00-\\uDC08\\uDC0A-\\uDC2E\\uDC40\\uDC50-\\uDC6C\\uDC72-\\uDC8F\\uDD00-\\uDD06\\uDD08\\uDD09\\uDD0B-\\uDD30\\uDD46\\uDD50-\\uDD59\\uDD60-\\uDD65\\uDD67\\uDD68\\uDD6A-\\uDD89\\uDD98\\uDDA0-\\uDDA9\\uDEE0-\\uDEF2\\uDFB0\\uDFC0-\\uDFD4]|\\uD808[\\uDC00-\\uDF99]|\\uD809[\\uDC00-\\uDC6E\\uDC80-\\uDD43]|[\\uD80C\\uD81C-\\uD820\\uD822\\uD840-\\uD868\\uD86A-\\uD86C\\uD86F-\\uD872\\uD874-\\uD879\\uD880-\\uD883][\\uDC00-\\uDFFF]|\\uD80D[\\uDC00-\\uDC2E]|\\uD811[\\uDC00-\\uDE46]|\\uD81A[\\uDC00-\\uDE38\\uDE40-\\uDE5E\\uDE60-\\uDE69\\uDED0-\\uDEED\\uDF00-\\uDF2F\\uDF40-\\uDF43\\uDF50-\\uDF59\\uDF5B-\\uDF61\\uDF63-\\uDF77\\uDF7D-\\uDF8F]|\\uD81B[\\uDE40-\\uDE96\\uDF00-\\uDF4A\\uDF50\\uDF93-\\uDF9F\\uDFE0\\uDFE1\\uDFE3]|\\uD821[\\uDC00-\\uDFF7]|\\uD823[\\uDC00-\\uDCD5\\uDD00-\\uDD08]|\\uD82C[\\uDC00-\\uDD1E\\uDD50-\\uDD52\\uDD64-\\uDD67\\uDD70-\\uDEFB]|\\uD82F[\\uDC00-\\uDC6A\\uDC70-\\uDC7C\\uDC80-\\uDC88\\uDC90-\\uDC99]|\\uD834[\\uDEE0-\\uDEF3\\uDF60-\\uDF78]|\\uD835[\\uDC00-\\uDC54\\uDC56-\\uDC9C\\uDC9E\\uDC9F\\uDCA2\\uDCA5\\uDCA6\\uDCA9-\\uDCAC\\uDCAE-\\uDCB9\\uDCBB\\uDCBD-\\uDCC3\\uDCC5-\\uDD05\\uDD07-\\uDD0A\\uDD0D-\\uDD14\\uDD16-\\uDD1C\\uDD1E-\\uDD39\\uDD3B-\\uDD3E\\uDD40-\\uDD44\\uDD46\\uDD4A-\\uDD50\\uDD52-\\uDEA5\\uDEA8-\\uDEC0\\uDEC2-\\uDEDA\\uDEDC-\\uDEFA\\uDEFC-\\uDF14\\uDF16-\\uDF34\\uDF36-\\uDF4E\\uDF50-\\uDF6E\\uDF70-\\uDF88\\uDF8A-\\uDFA8\\uDFAA-\\uDFC2\\uDFC4-\\uDFCB\\uDFCE-\\uDFFF]|\\uD838[\\uDD00-\\uDD2C\\uDD37-\\uDD3D\\uDD40-\\uDD49\\uDD4E\\uDEC0-\\uDEEB\\uDEF0-\\uDEF9]|\\uD83A[\\uDC00-\\uDCC4\\uDCC7-\\uDCCF\\uDD00-\\uDD43\\uDD4B\\uDD50-\\uDD59]|\\uD83B[\\uDC71-\\uDCAB\\uDCAD-\\uDCAF\\uDCB1-\\uDCB4\\uDD01-\\uDD2D\\uDD2F-\\uDD3D\\uDE00-\\uDE03\\uDE05-\\uDE1F\\uDE21\\uDE22\\uDE24\\uDE27\\uDE29-\\uDE32\\uDE34-\\uDE37\\uDE39\\uDE3B\\uDE42\\uDE47\\uDE49\\uDE4B\\uDE4D-\\uDE4F\\uDE51\\uDE52\\uDE54\\uDE57\\uDE59\\uDE5B\\uDE5D\\uDE5F\\uDE61\\uDE62\\uDE64\\uDE67-\\uDE6A\\uDE6C-\\uDE72\\uDE74-\\uDE77\\uDE79-\\uDE7C\\uDE7E\\uDE80-\\uDE89\\uDE8B-\\uDE9B\\uDEA1-\\uDEA3\\uDEA5-\\uDEA9\\uDEAB-\\uDEBB]|\\uD83C[\\uDD00-\\uDD0C]|\\uD83E[\\uDFF0-\\uDFF9]|\\uD869[\\uDC00-\\uDEDD\\uDF00-\\uDFFF]|\\uD86D[\\uDC00-\\uDF34\\uDF40-\\uDFFF]|\\uD86E[\\uDC00-\\uDC1D\\uDC20-\\uDFFF]|\\uD873[\\uDC00-\\uDEA1\\uDEB0-\\uDFFF]|\\uD87A[\\uDC00-\\uDFE0]|\\uD87E[\\uDC00-\\uDE1D]|\\uD884[\\uDC00-\\uDF4A])/)) return;\n      var nextChar = match[1] || match[2] || '';\n\n      if (!nextChar || nextChar && (prevChar === '' || this.rules.inline.punctuation.exec(prevChar))) {\n        var lLength = match[0].length - 1;\n        var rDelim,\n            rLength,\n            delimTotal = lLength,\n            midDelimTotal = 0;\n        var endReg = match[0][0] === '*' ? this.rules.inline.emStrong.rDelimAst : this.rules.inline.emStrong.rDelimUnd;\n        endReg.lastIndex = 0; // Clip maskedSrc to same section of string as src (move to lexer?)\n\n        maskedSrc = maskedSrc.slice(-1 * src.length + lLength);\n\n        while ((match = endReg.exec(maskedSrc)) != null) {\n          rDelim = match[1] || match[2] || match[3] || match[4] || match[5] || match[6];\n          if (!rDelim) continue; // skip single * in __abc*abc__\n\n          rLength = rDelim.length;\n\n          if (match[3] || match[4]) {\n            // found another Left Delim\n            delimTotal += rLength;\n            continue;\n          } else if (match[5] || match[6]) {\n            // either Left or Right Delim\n            if (lLength % 3 && !((lLength + rLength) % 3)) {\n              midDelimTotal += rLength;\n              continue; // CommonMark Emphasis Rules 9-10\n            }\n          }\n\n          delimTotal -= rLength;\n          if (delimTotal > 0) continue; // Haven't found enough closing delimiters\n          // Remove extra characters. *a*** -> *a*\n\n          rLength = Math.min(rLength, rLength + delimTotal + midDelimTotal); // Create `em` if smallest delimiter has odd char count. *a***\n\n          if (Math.min(lLength, rLength) % 2) {\n            var _text = src.slice(1, lLength + match.index + rLength);\n\n            return {\n              type: 'em',\n              raw: src.slice(0, lLength + match.index + rLength + 1),\n              text: _text,\n              tokens: this.lexer.inlineTokens(_text, [])\n            };\n          } // Create 'strong' if smallest delimiter has even char count. **a***\n\n\n          var text = src.slice(2, lLength + match.index + rLength - 1);\n          return {\n            type: 'strong',\n            raw: src.slice(0, lLength + match.index + rLength + 1),\n            text: text,\n            tokens: this.lexer.inlineTokens(text, [])\n          };\n        }\n      }\n    };\n\n    _proto.codespan = function codespan(src) {\n      var cap = this.rules.inline.code.exec(src);\n\n      if (cap) {\n        var text = cap[2].replace(/\\n/g, ' ');\n        var hasNonSpaceChars = /[^ ]/.test(text);\n        var hasSpaceCharsOnBothEnds = /^ /.test(text) && / $/.test(text);\n\n        if (hasNonSpaceChars && hasSpaceCharsOnBothEnds) {\n          text = text.substring(1, text.length - 1);\n        }\n\n        text = _escape(text, true);\n        return {\n          type: 'codespan',\n          raw: cap[0],\n          text: text\n        };\n      }\n    };\n\n    _proto.br = function br(src) {\n      var cap = this.rules.inline.br.exec(src);\n\n      if (cap) {\n        return {\n          type: 'br',\n          raw: cap[0]\n        };\n      }\n    };\n\n    _proto.del = function del(src) {\n      var cap = this.rules.inline.del.exec(src);\n\n      if (cap) {\n        return {\n          type: 'del',\n          raw: cap[0],\n          text: cap[2],\n          tokens: this.lexer.inlineTokens(cap[2], [])\n        };\n      }\n    };\n\n    _proto.autolink = function autolink(src, mangle) {\n      var cap = this.rules.inline.autolink.exec(src);\n\n      if (cap) {\n        var text, href;\n\n        if (cap[2] === '@') {\n          text = _escape(this.options.mangle ? mangle(cap[1]) : cap[1]);\n          href = 'mailto:' + text;\n        } else {\n          text = _escape(cap[1]);\n          href = text;\n        }\n\n        return {\n          type: 'link',\n          raw: cap[0],\n          text: text,\n          href: href,\n          tokens: [{\n            type: 'text',\n            raw: text,\n            text: text\n          }]\n        };\n      }\n    };\n\n    _proto.url = function url(src, mangle) {\n      var cap;\n\n      if (cap = this.rules.inline.url.exec(src)) {\n        var text, href;\n\n        if (cap[2] === '@') {\n          text = _escape(this.options.mangle ? mangle(cap[0]) : cap[0]);\n          href = 'mailto:' + text;\n        } else {\n          // do extended autolink path validation\n          var prevCapZero;\n\n          do {\n            prevCapZero = cap[0];\n            cap[0] = this.rules.inline._backpedal.exec(cap[0])[0];\n          } while (prevCapZero !== cap[0]);\n\n          text = _escape(cap[0]);\n\n          if (cap[1] === 'www.') {\n            href = 'http://' + text;\n          } else {\n            href = text;\n          }\n        }\n\n        return {\n          type: 'link',\n          raw: cap[0],\n          text: text,\n          href: href,\n          tokens: [{\n            type: 'text',\n            raw: text,\n            text: text\n          }]\n        };\n      }\n    };\n\n    _proto.inlineText = function inlineText(src, smartypants) {\n      var cap = this.rules.inline.text.exec(src);\n\n      if (cap) {\n        var text;\n\n        if (this.lexer.state.inRawBlock) {\n          text = this.options.sanitize ? this.options.sanitizer ? this.options.sanitizer(cap[0]) : _escape(cap[0]) : cap[0];\n        } else {\n          text = _escape(this.options.smartypants ? smartypants(cap[0]) : cap[0]);\n        }\n\n        return {\n          type: 'text',\n          raw: cap[0],\n          text: text\n        };\n      }\n    };\n\n    return Tokenizer;\n  }();\n\n  var noopTest = helpers.noopTest,\n      edit = helpers.edit,\n      merge$1 = helpers.merge;\n  /**\n   * Block-Level Grammar\n   */\n\n  var block$1 = {\n    newline: /^(?: *(?:\\n|$))+/,\n    code: /^( {4}[^\\n]+(?:\\n(?: *(?:\\n|$))*)?)+/,\n    fences: /^ {0,3}(`{3,}(?=[^`\\n]*\\n)|~{3,})([^\\n]*)\\n(?:|([\\s\\S]*?)\\n)(?: {0,3}\\1[~`]* *(?=\\n|$)|$)/,\n    hr: /^ {0,3}((?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|$)/,\n    heading: /^ {0,3}(#{1,6})(?=\\s|$)(.*)(?:\\n+|$)/,\n    blockquote: /^( {0,3}> ?(paragraph|[^\\n]*)(?:\\n|$))+/,\n    list: /^( {0,3}bull)( [^\\n]+?)?(?:\\n|$)/,\n    html: '^ {0,3}(?:' // optional indentation\n    + '<(script|pre|style|textarea)[\\\\s>][\\\\s\\\\S]*?(?:</\\\\1>[^\\\\n]*\\\\n+|$)' // (1)\n    + '|comment[^\\\\n]*(\\\\n+|$)' // (2)\n    + '|<\\\\?[\\\\s\\\\S]*?(?:\\\\?>\\\\n*|$)' // (3)\n    + '|<![A-Z][\\\\s\\\\S]*?(?:>\\\\n*|$)' // (4)\n    + '|<!\\\\[CDATA\\\\[[\\\\s\\\\S]*?(?:\\\\]\\\\]>\\\\n*|$)' // (5)\n    + '|</?(tag)(?: +|\\\\n|/?>)[\\\\s\\\\S]*?(?:(?:\\\\n *)+\\\\n|$)' // (6)\n    + '|<(?!script|pre|style|textarea)([a-z][\\\\w-]*)(?:attribute)*? */?>(?=[ \\\\t]*(?:\\\\n|$))[\\\\s\\\\S]*?(?:(?:\\\\n *)+\\\\n|$)' // (7) open tag\n    + '|</(?!script|pre|style|textarea)[a-z][\\\\w-]*\\\\s*>(?=[ \\\\t]*(?:\\\\n|$))[\\\\s\\\\S]*?(?:(?:\\\\n *)+\\\\n|$)' // (7) closing tag\n    + ')',\n    def: /^ {0,3}\\[(label)\\]: *\\n? *<?([^\\s>]+)>?(?:(?: +\\n? *| *\\n *)(title))? *(?:\\n+|$)/,\n    table: noopTest,\n    lheading: /^([^\\n]+)\\n {0,3}(=+|-+) *(?:\\n+|$)/,\n    // regex template, placeholders will be replaced according to different paragraph\n    // interruption rules of commonmark and the original markdown spec:\n    _paragraph: /^([^\\n]+(?:\\n(?!hr|heading|lheading|blockquote|fences|list|html| +\\n)[^\\n]+)*)/,\n    text: /^[^\\n]+/\n  };\n  block$1._label = /(?!\\s*\\])(?:\\\\[\\[\\]]|[^\\[\\]])+/;\n  block$1._title = /(?:\"(?:\\\\\"?|[^\"\\\\])*\"|'[^'\\n]*(?:\\n[^'\\n]+)*\\n?'|\\([^()]*\\))/;\n  block$1.def = edit(block$1.def).replace('label', block$1._label).replace('title', block$1._title).getRegex();\n  block$1.bullet = /(?:[*+-]|\\d{1,9}[.)])/;\n  block$1.listItemStart = edit(/^( *)(bull) */).replace('bull', block$1.bullet).getRegex();\n  block$1.list = edit(block$1.list).replace(/bull/g, block$1.bullet).replace('hr', '\\\\n+(?=\\\\1?(?:(?:- *){3,}|(?:_ *){3,}|(?:\\\\* *){3,})(?:\\\\n+|$))').replace('def', '\\\\n+(?=' + block$1.def.source + ')').getRegex();\n  block$1._tag = 'address|article|aside|base|basefont|blockquote|body|caption' + '|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption' + '|figure|footer|form|frame|frameset|h[1-6]|head|header|hr|html|iframe' + '|legend|li|link|main|menu|menuitem|meta|nav|noframes|ol|optgroup|option' + '|p|param|section|source|summary|table|tbody|td|tfoot|th|thead|title|tr' + '|track|ul';\n  block$1._comment = /\x3c!--(?!-?>)[\\s\\S]*?(?:--\x3e|$)/;\n  block$1.html = edit(block$1.html, 'i').replace('comment', block$1._comment).replace('tag', block$1._tag).replace('attribute', / +[a-zA-Z:_][\\w.:-]*(?: *= *\"[^\"\\n]*\"| *= *'[^'\\n]*'| *= *[^\\s\"'=<>`]+)?/).getRegex();\n  block$1.paragraph = edit(block$1._paragraph).replace('hr', block$1.hr).replace('heading', ' {0,3}#{1,6} ').replace('|lheading', '') // setex headings don't interrupt commonmark paragraphs\n  .replace('blockquote', ' {0,3}>').replace('fences', ' {0,3}(?:`{3,}(?=[^`\\\\n]*\\\\n)|~{3,})[^\\\\n]*\\\\n').replace('list', ' {0,3}(?:[*+-]|1[.)]) ') // only lists starting from 1 can interrupt\n  .replace('html', '</?(?:tag)(?: +|\\\\n|/?>)|<(?:script|pre|style|textarea|!--)').replace('tag', block$1._tag) // pars can be interrupted by type (6) html blocks\n  .getRegex();\n  block$1.blockquote = edit(block$1.blockquote).replace('paragraph', block$1.paragraph).getRegex();\n  /**\n   * Normal Block Grammar\n   */\n\n  block$1.normal = merge$1({}, block$1);\n  /**\n   * GFM Block Grammar\n   */\n\n  block$1.gfm = merge$1({}, block$1.normal, {\n    table: '^ *([^\\\\n ].*\\\\|.*)\\\\n' // Header\n    + ' {0,3}(?:\\\\| *)?(:?-+:? *(?:\\\\| *:?-+:? *)*)(?:\\\\| *)?' // Align\n    + '(?:\\\\n((?:(?! *\\\\n|hr|heading|blockquote|code|fences|list|html).*(?:\\\\n|$))*)\\\\n*|$)' // Cells\n\n  });\n  block$1.gfm.table = edit(block$1.gfm.table).replace('hr', block$1.hr).replace('heading', ' {0,3}#{1,6} ').replace('blockquote', ' {0,3}>').replace('code', ' {4}[^\\\\n]').replace('fences', ' {0,3}(?:`{3,}(?=[^`\\\\n]*\\\\n)|~{3,})[^\\\\n]*\\\\n').replace('list', ' {0,3}(?:[*+-]|1[.)]) ') // only lists starting from 1 can interrupt\n  .replace('html', '</?(?:tag)(?: +|\\\\n|/?>)|<(?:script|pre|style|textarea|!--)').replace('tag', block$1._tag) // tables can be interrupted by type (6) html blocks\n  .getRegex();\n  /**\n   * Pedantic grammar (original John Gruber's loose markdown specification)\n   */\n\n  block$1.pedantic = merge$1({}, block$1.normal, {\n    html: edit('^ *(?:comment *(?:\\\\n|\\\\s*$)' + '|<(tag)[\\\\s\\\\S]+?</\\\\1> *(?:\\\\n{2,}|\\\\s*$)' // closed tag\n    + '|<tag(?:\"[^\"]*\"|\\'[^\\']*\\'|\\\\s[^\\'\"/>\\\\s]*)*?/?> *(?:\\\\n{2,}|\\\\s*$))').replace('comment', block$1._comment).replace(/tag/g, '(?!(?:' + 'a|em|strong|small|s|cite|q|dfn|abbr|data|time|code|var|samp|kbd|sub' + '|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo|span|br|wbr|ins|del|img)' + '\\\\b)\\\\w+(?!:|[^\\\\w\\\\s@]*@)\\\\b').getRegex(),\n    def: /^ *\\[([^\\]]+)\\]: *<?([^\\s>]+)>?(?: +([\"(][^\\n]+[\")]))? *(?:\\n+|$)/,\n    heading: /^(#{1,6})(.*)(?:\\n+|$)/,\n    fences: noopTest,\n    // fences not supported\n    paragraph: edit(block$1.normal._paragraph).replace('hr', block$1.hr).replace('heading', ' *#{1,6} *[^\\n]').replace('lheading', block$1.lheading).replace('blockquote', ' {0,3}>').replace('|fences', '').replace('|list', '').replace('|html', '').getRegex()\n  });\n  /**\n   * Inline-Level Grammar\n   */\n\n  var inline$1 = {\n    escape: /^\\\\([!\"#$%&'()*+,\\-./:;<=>?@\\[\\]\\\\^_`{|}~])/,\n    autolink: /^<(scheme:[^\\s\\x00-\\x1f<>]*|email)>/,\n    url: noopTest,\n    tag: '^comment' + '|^</[a-zA-Z][\\\\w:-]*\\\\s*>' // self-closing tag\n    + '|^<[a-zA-Z][\\\\w-]*(?:attribute)*?\\\\s*/?>' // open tag\n    + '|^<\\\\?[\\\\s\\\\S]*?\\\\?>' // processing instruction, e.g. <?php ?>\n    + '|^<![a-zA-Z]+\\\\s[\\\\s\\\\S]*?>' // declaration, e.g. <!DOCTYPE html>\n    + '|^<!\\\\[CDATA\\\\[[\\\\s\\\\S]*?\\\\]\\\\]>',\n    // CDATA section\n    link: /^!?\\[(label)\\]\\(\\s*(href)(?:\\s+(title))?\\s*\\)/,\n    reflink: /^!?\\[(label)\\]\\[(?!\\s*\\])((?:\\\\[\\[\\]]?|[^\\[\\]\\\\])+)\\]/,\n    nolink: /^!?\\[(?!\\s*\\])((?:\\[[^\\[\\]]*\\]|\\\\[\\[\\]]|[^\\[\\]])*)\\](?:\\[\\])?/,\n    reflinkSearch: 'reflink|nolink(?!\\\\()',\n    emStrong: {\n      lDelim: /^(?:\\*+(?:([punct_])|[^\\s*]))|^_+(?:([punct*])|([^\\s_]))/,\n      //        (1) and (2) can only be a Right Delimiter. (3) and (4) can only be Left.  (5) and (6) can be either Left or Right.\n      //        () Skip orphan delim inside strong    (1) #***                (2) a***#, a***                   (3) #***a, ***a                 (4) ***#              (5) #***#                 (6) a***a\n      rDelimAst: /^[^_*]*?\\_\\_[^_*]*?\\*[^_*]*?(?=\\_\\_)|[punct_](\\*+)(?=[\\s]|$)|[^punct*_\\s](\\*+)(?=[punct_\\s]|$)|[punct_\\s](\\*+)(?=[^punct*_\\s])|[\\s](\\*+)(?=[punct_])|[punct_](\\*+)(?=[punct_])|[^punct*_\\s](\\*+)(?=[^punct*_\\s])/,\n      rDelimUnd: /^[^_*]*?\\*\\*[^_*]*?\\_[^_*]*?(?=\\*\\*)|[punct*](\\_+)(?=[\\s]|$)|[^punct*_\\s](\\_+)(?=[punct*\\s]|$)|[punct*\\s](\\_+)(?=[^punct*_\\s])|[\\s](\\_+)(?=[punct*])|[punct*](\\_+)(?=[punct*])/ // ^- Not allowed for _\n\n    },\n    code: /^(`+)([^`]|[^`][\\s\\S]*?[^`])\\1(?!`)/,\n    br: /^( {2,}|\\\\)\\n(?!\\s*$)/,\n    del: noopTest,\n    text: /^(`+|[^`])(?:(?= {2,}\\n)|[\\s\\S]*?(?:(?=[\\\\<!\\[`*_]|\\b_|$)|[^ ](?= {2,}\\n)))/,\n    punctuation: /^([\\spunctuation])/\n  }; // list of punctuation marks from CommonMark spec\n  // without * and _ to handle the different emphasis markers * and _\n\n  inline$1._punctuation = '!\"#$%&\\'()+\\\\-.,/:;<=>?@\\\\[\\\\]`^{|}~';\n  inline$1.punctuation = edit(inline$1.punctuation).replace(/punctuation/g, inline$1._punctuation).getRegex(); // sequences em should skip over [title](link), `code`, <html>\n\n  inline$1.blockSkip = /\\[[^\\]]*?\\]\\([^\\)]*?\\)|`[^`]*?`|<[^>]*?>/g;\n  inline$1.escapedEmSt = /\\\\\\*|\\\\_/g;\n  inline$1._comment = edit(block$1._comment).replace('(?:--\x3e|$)', '--\x3e').getRegex();\n  inline$1.emStrong.lDelim = edit(inline$1.emStrong.lDelim).replace(/punct/g, inline$1._punctuation).getRegex();\n  inline$1.emStrong.rDelimAst = edit(inline$1.emStrong.rDelimAst, 'g').replace(/punct/g, inline$1._punctuation).getRegex();\n  inline$1.emStrong.rDelimUnd = edit(inline$1.emStrong.rDelimUnd, 'g').replace(/punct/g, inline$1._punctuation).getRegex();\n  inline$1._escapes = /\\\\([!\"#$%&'()*+,\\-./:;<=>?@\\[\\]\\\\^_`{|}~])/g;\n  inline$1._scheme = /[a-zA-Z][a-zA-Z0-9+.-]{1,31}/;\n  inline$1._email = /[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+(@)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(?![-_])/;\n  inline$1.autolink = edit(inline$1.autolink).replace('scheme', inline$1._scheme).replace('email', inline$1._email).getRegex();\n  inline$1._attribute = /\\s+[a-zA-Z:_][\\w.:-]*(?:\\s*=\\s*\"[^\"]*\"|\\s*=\\s*'[^']*'|\\s*=\\s*[^\\s\"'=<>`]+)?/;\n  inline$1.tag = edit(inline$1.tag).replace('comment', inline$1._comment).replace('attribute', inline$1._attribute).getRegex();\n  inline$1._label = /(?:\\[(?:\\\\.|[^\\[\\]\\\\])*\\]|\\\\.|`[^`]*`|[^\\[\\]\\\\`])*?/;\n  inline$1._href = /<(?:\\\\.|[^\\n<>\\\\])+>|[^\\s\\x00-\\x1f]*/;\n  inline$1._title = /\"(?:\\\\\"?|[^\"\\\\])*\"|'(?:\\\\'?|[^'\\\\])*'|\\((?:\\\\\\)?|[^)\\\\])*\\)/;\n  inline$1.link = edit(inline$1.link).replace('label', inline$1._label).replace('href', inline$1._href).replace('title', inline$1._title).getRegex();\n  inline$1.reflink = edit(inline$1.reflink).replace('label', inline$1._label).getRegex();\n  inline$1.reflinkSearch = edit(inline$1.reflinkSearch, 'g').replace('reflink', inline$1.reflink).replace('nolink', inline$1.nolink).getRegex();\n  /**\n   * Normal Inline Grammar\n   */\n\n  inline$1.normal = merge$1({}, inline$1);\n  /**\n   * Pedantic Inline Grammar\n   */\n\n  inline$1.pedantic = merge$1({}, inline$1.normal, {\n    strong: {\n      start: /^__|\\*\\*/,\n      middle: /^__(?=\\S)([\\s\\S]*?\\S)__(?!_)|^\\*\\*(?=\\S)([\\s\\S]*?\\S)\\*\\*(?!\\*)/,\n      endAst: /\\*\\*(?!\\*)/g,\n      endUnd: /__(?!_)/g\n    },\n    em: {\n      start: /^_|\\*/,\n      middle: /^()\\*(?=\\S)([\\s\\S]*?\\S)\\*(?!\\*)|^_(?=\\S)([\\s\\S]*?\\S)_(?!_)/,\n      endAst: /\\*(?!\\*)/g,\n      endUnd: /_(?!_)/g\n    },\n    link: edit(/^!?\\[(label)\\]\\((.*?)\\)/).replace('label', inline$1._label).getRegex(),\n    reflink: edit(/^!?\\[(label)\\]\\s*\\[([^\\]]*)\\]/).replace('label', inline$1._label).getRegex()\n  });\n  /**\n   * GFM Inline Grammar\n   */\n\n  inline$1.gfm = merge$1({}, inline$1.normal, {\n    escape: edit(inline$1.escape).replace('])', '~|])').getRegex(),\n    _extended_email: /[A-Za-z0-9._+-]+(@)[a-zA-Z0-9-_]+(?:\\.[a-zA-Z0-9-_]*[a-zA-Z0-9])+(?![-_])/,\n    url: /^((?:ftp|https?):\\/\\/|www\\.)(?:[a-zA-Z0-9\\-]+\\.?)+[^\\s<]*|^email/,\n    _backpedal: /(?:[^?!.,:;*_~()&]+|\\([^)]*\\)|&(?![a-zA-Z0-9]+;$)|[?!.,:;*_~)]+(?!$))+/,\n    del: /^(~~?)(?=[^\\s~])([\\s\\S]*?[^\\s~])\\1(?=[^~]|$)/,\n    text: /^([`~]+|[^`~])(?:(?= {2,}\\n)|(?=[a-zA-Z0-9.!#$%&'*+\\/=?_`{\\|}~-]+@)|[\\s\\S]*?(?:(?=[\\\\<!\\[`*~_]|\\b_|https?:\\/\\/|ftp:\\/\\/|www\\.|$)|[^ ](?= {2,}\\n)|[^a-zA-Z0-9.!#$%&'*+\\/=?_`{\\|}~-](?=[a-zA-Z0-9.!#$%&'*+\\/=?_`{\\|}~-]+@)))/\n  });\n  inline$1.gfm.url = edit(inline$1.gfm.url, 'i').replace('email', inline$1.gfm._extended_email).getRegex();\n  /**\n   * GFM + Line Breaks Inline Grammar\n   */\n\n  inline$1.breaks = merge$1({}, inline$1.gfm, {\n    br: edit(inline$1.br).replace('{2,}', '*').getRegex(),\n    text: edit(inline$1.gfm.text).replace('\\\\b_', '\\\\b_| {2,}\\\\n').replace(/\\{2,\\}/g, '*').getRegex()\n  });\n  var rules = {\n    block: block$1,\n    inline: inline$1\n  };\n\n  var Tokenizer$1 = Tokenizer_1;\n  var defaults$3 = defaults$5.exports.defaults;\n  var block = rules.block,\n      inline = rules.inline;\n  var repeatString = helpers.repeatString;\n  /**\n   * smartypants text replacement\n   */\n\n  function smartypants(text) {\n    return text // em-dashes\n    .replace(/---/g, \"\\u2014\") // en-dashes\n    .replace(/--/g, \"\\u2013\") // opening singles\n    .replace(/(^|[-\\u2014/(\\[{\"\\s])'/g, \"$1\\u2018\") // closing singles & apostrophes\n    .replace(/'/g, \"\\u2019\") // opening doubles\n    .replace(/(^|[-\\u2014/(\\[{\\u2018\\s])\"/g, \"$1\\u201C\") // closing doubles\n    .replace(/\"/g, \"\\u201D\") // ellipses\n    .replace(/\\.{3}/g, \"\\u2026\");\n  }\n  /**\n   * mangle email addresses\n   */\n\n\n  function mangle(text) {\n    var out = '',\n        i,\n        ch;\n    var l = text.length;\n\n    for (i = 0; i < l; i++) {\n      ch = text.charCodeAt(i);\n\n      if (Math.random() > 0.5) {\n        ch = 'x' + ch.toString(16);\n      }\n\n      out += '&#' + ch + ';';\n    }\n\n    return out;\n  }\n  /**\n   * Block Lexer\n   */\n\n\n  var Lexer_1 = /*#__PURE__*/function () {\n    function Lexer(options) {\n      this.tokens = [];\n      this.tokens.links = Object.create(null);\n      this.options = options || defaults$3;\n      this.options.tokenizer = this.options.tokenizer || new Tokenizer$1();\n      this.tokenizer = this.options.tokenizer;\n      this.tokenizer.options = this.options;\n      this.tokenizer.lexer = this;\n      this.inlineQueue = [];\n      this.state = {\n        inLink: false,\n        inRawBlock: false,\n        top: true\n      };\n      var rules = {\n        block: block.normal,\n        inline: inline.normal\n      };\n\n      if (this.options.pedantic) {\n        rules.block = block.pedantic;\n        rules.inline = inline.pedantic;\n      } else if (this.options.gfm) {\n        rules.block = block.gfm;\n\n        if (this.options.breaks) {\n          rules.inline = inline.breaks;\n        } else {\n          rules.inline = inline.gfm;\n        }\n      }\n\n      this.tokenizer.rules = rules;\n    }\n    /**\n     * Expose Rules\n     */\n\n\n    /**\n     * Static Lex Method\n     */\n    Lexer.lex = function lex(src, options) {\n      var lexer = new Lexer(options);\n      return lexer.lex(src);\n    }\n    /**\n     * Static Lex Inline Method\n     */\n    ;\n\n    Lexer.lexInline = function lexInline(src, options) {\n      var lexer = new Lexer(options);\n      return lexer.inlineTokens(src);\n    }\n    /**\n     * Preprocessing\n     */\n    ;\n\n    var _proto = Lexer.prototype;\n\n    _proto.lex = function lex(src) {\n      src = src.replace(/\\r\\n|\\r/g, '\\n').replace(/\\t/g, '    ');\n      this.blockTokens(src, this.tokens);\n      var next;\n\n      while (next = this.inlineQueue.shift()) {\n        this.inlineTokens(next.src, next.tokens);\n      }\n\n      return this.tokens;\n    }\n    /**\n     * Lexing\n     */\n    ;\n\n    _proto.blockTokens = function blockTokens(src, tokens) {\n      var _this = this;\n\n      if (tokens === void 0) {\n        tokens = [];\n      }\n\n      if (this.options.pedantic) {\n        src = src.replace(/^ +$/gm, '');\n      }\n\n      var token, lastToken, cutSrc, lastParagraphClipped;\n\n      while (src) {\n        if (this.options.extensions && this.options.extensions.block && this.options.extensions.block.some(function (extTokenizer) {\n          if (token = extTokenizer.call({\n            lexer: _this\n          }, src, tokens)) {\n            src = src.substring(token.raw.length);\n            tokens.push(token);\n            return true;\n          }\n\n          return false;\n        })) {\n          continue;\n        } // newline\n\n\n        if (token = this.tokenizer.space(src)) {\n          src = src.substring(token.raw.length);\n\n          if (token.type) {\n            tokens.push(token);\n          }\n\n          continue;\n        } // code\n\n\n        if (token = this.tokenizer.code(src)) {\n          src = src.substring(token.raw.length);\n          lastToken = tokens[tokens.length - 1]; // An indented code block cannot interrupt a paragraph.\n\n          if (lastToken && (lastToken.type === 'paragraph' || lastToken.type === 'text')) {\n            lastToken.raw += '\\n' + token.raw;\n            lastToken.text += '\\n' + token.text;\n            this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;\n          } else {\n            tokens.push(token);\n          }\n\n          continue;\n        } // fences\n\n\n        if (token = this.tokenizer.fences(src)) {\n          src = src.substring(token.raw.length);\n          tokens.push(token);\n          continue;\n        } // heading\n\n\n        if (token = this.tokenizer.heading(src)) {\n          src = src.substring(token.raw.length);\n          tokens.push(token);\n          continue;\n        } // hr\n\n\n        if (token = this.tokenizer.hr(src)) {\n          src = src.substring(token.raw.length);\n          tokens.push(token);\n          continue;\n        } // blockquote\n\n\n        if (token = this.tokenizer.blockquote(src)) {\n          src = src.substring(token.raw.length);\n          tokens.push(token);\n          continue;\n        } // list\n\n\n        if (token = this.tokenizer.list(src)) {\n          src = src.substring(token.raw.length);\n          tokens.push(token);\n          continue;\n        } // html\n\n\n        if (token = this.tokenizer.html(src)) {\n          src = src.substring(token.raw.length);\n          tokens.push(token);\n          continue;\n        } // def\n\n\n        if (token = this.tokenizer.def(src)) {\n          src = src.substring(token.raw.length);\n          lastToken = tokens[tokens.length - 1];\n\n          if (lastToken && (lastToken.type === 'paragraph' || lastToken.type === 'text')) {\n            lastToken.raw += '\\n' + token.raw;\n            lastToken.text += '\\n' + token.raw;\n            this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;\n          } else if (!this.tokens.links[token.tag]) {\n            this.tokens.links[token.tag] = {\n              href: token.href,\n              title: token.title\n            };\n          }\n\n          continue;\n        } // table (gfm)\n\n\n        if (token = this.tokenizer.table(src)) {\n          src = src.substring(token.raw.length);\n          tokens.push(token);\n          continue;\n        } // lheading\n\n\n        if (token = this.tokenizer.lheading(src)) {\n          src = src.substring(token.raw.length);\n          tokens.push(token);\n          continue;\n        } // top-level paragraph\n        // prevent paragraph consuming extensions by clipping 'src' to extension start\n\n\n        cutSrc = src;\n\n        if (this.options.extensions && this.options.extensions.startBlock) {\n          (function () {\n            var startIndex = Infinity;\n            var tempSrc = src.slice(1);\n            var tempStart = void 0;\n\n            _this.options.extensions.startBlock.forEach(function (getStartIndex) {\n              tempStart = getStartIndex.call({\n                lexer: this\n              }, tempSrc);\n\n              if (typeof tempStart === 'number' && tempStart >= 0) {\n                startIndex = Math.min(startIndex, tempStart);\n              }\n            });\n\n            if (startIndex < Infinity && startIndex >= 0) {\n              cutSrc = src.substring(0, startIndex + 1);\n            }\n          })();\n        }\n\n        if (this.state.top && (token = this.tokenizer.paragraph(cutSrc))) {\n          lastToken = tokens[tokens.length - 1];\n\n          if (lastParagraphClipped && lastToken.type === 'paragraph') {\n            lastToken.raw += '\\n' + token.raw;\n            lastToken.text += '\\n' + token.text;\n            this.inlineQueue.pop();\n            this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;\n          } else {\n            tokens.push(token);\n          }\n\n          lastParagraphClipped = cutSrc.length !== src.length;\n          src = src.substring(token.raw.length);\n          continue;\n        } // text\n\n\n        if (token = this.tokenizer.text(src)) {\n          src = src.substring(token.raw.length);\n          lastToken = tokens[tokens.length - 1];\n\n          if (lastToken && lastToken.type === 'text') {\n            lastToken.raw += '\\n' + token.raw;\n            lastToken.text += '\\n' + token.text;\n            this.inlineQueue.pop();\n            this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;\n          } else {\n            tokens.push(token);\n          }\n\n          continue;\n        }\n\n        if (src) {\n          var errMsg = 'Infinite loop on byte: ' + src.charCodeAt(0);\n\n          if (this.options.silent) {\n            console.error(errMsg);\n            break;\n          } else {\n            throw new Error(errMsg);\n          }\n        }\n      }\n\n      this.state.top = true;\n      return tokens;\n    };\n\n    _proto.inline = function inline(src, tokens) {\n      this.inlineQueue.push({\n        src: src,\n        tokens: tokens\n      });\n    }\n    /**\n     * Lexing/Compiling\n     */\n    ;\n\n    _proto.inlineTokens = function inlineTokens(src, tokens) {\n      var _this2 = this;\n\n      if (tokens === void 0) {\n        tokens = [];\n      }\n\n      var token, lastToken, cutSrc; // String with links masked to avoid interference with em and strong\n\n      var maskedSrc = src;\n      var match;\n      var keepPrevChar, prevChar; // Mask out reflinks\n\n      if (this.tokens.links) {\n        var links = Object.keys(this.tokens.links);\n\n        if (links.length > 0) {\n          while ((match = this.tokenizer.rules.inline.reflinkSearch.exec(maskedSrc)) != null) {\n            if (links.includes(match[0].slice(match[0].lastIndexOf('[') + 1, -1))) {\n              maskedSrc = maskedSrc.slice(0, match.index) + '[' + repeatString('a', match[0].length - 2) + ']' + maskedSrc.slice(this.tokenizer.rules.inline.reflinkSearch.lastIndex);\n            }\n          }\n        }\n      } // Mask out other blocks\n\n\n      while ((match = this.tokenizer.rules.inline.blockSkip.exec(maskedSrc)) != null) {\n        maskedSrc = maskedSrc.slice(0, match.index) + '[' + repeatString('a', match[0].length - 2) + ']' + maskedSrc.slice(this.tokenizer.rules.inline.blockSkip.lastIndex);\n      } // Mask out escaped em & strong delimiters\n\n\n      while ((match = this.tokenizer.rules.inline.escapedEmSt.exec(maskedSrc)) != null) {\n        maskedSrc = maskedSrc.slice(0, match.index) + '++' + maskedSrc.slice(this.tokenizer.rules.inline.escapedEmSt.lastIndex);\n      }\n\n      while (src) {\n        if (!keepPrevChar) {\n          prevChar = '';\n        }\n\n        keepPrevChar = false; // extensions\n\n        if (this.options.extensions && this.options.extensions.inline && this.options.extensions.inline.some(function (extTokenizer) {\n          if (token = extTokenizer.call({\n            lexer: _this2\n          }, src, tokens)) {\n            src = src.substring(token.raw.length);\n            tokens.push(token);\n            return true;\n          }\n\n          return false;\n        })) {\n          continue;\n        } // escape\n\n\n        if (token = this.tokenizer.escape(src)) {\n          src = src.substring(token.raw.length);\n          tokens.push(token);\n          continue;\n        } // tag\n\n\n        if (token = this.tokenizer.tag(src)) {\n          src = src.substring(token.raw.length);\n          lastToken = tokens[tokens.length - 1];\n\n          if (lastToken && token.type === 'text' && lastToken.type === 'text') {\n            lastToken.raw += token.raw;\n            lastToken.text += token.text;\n          } else {\n            tokens.push(token);\n          }\n\n          continue;\n        } // link\n\n\n        if (token = this.tokenizer.link(src)) {\n          src = src.substring(token.raw.length);\n          tokens.push(token);\n          continue;\n        } // reflink, nolink\n\n\n        if (token = this.tokenizer.reflink(src, this.tokens.links)) {\n          src = src.substring(token.raw.length);\n          lastToken = tokens[tokens.length - 1];\n\n          if (lastToken && token.type === 'text' && lastToken.type === 'text') {\n            lastToken.raw += token.raw;\n            lastToken.text += token.text;\n          } else {\n            tokens.push(token);\n          }\n\n          continue;\n        } // em & strong\n\n\n        if (token = this.tokenizer.emStrong(src, maskedSrc, prevChar)) {\n          src = src.substring(token.raw.length);\n          tokens.push(token);\n          continue;\n        } // code\n\n\n        if (token = this.tokenizer.codespan(src)) {\n          src = src.substring(token.raw.length);\n          tokens.push(token);\n          continue;\n        } // br\n\n\n        if (token = this.tokenizer.br(src)) {\n          src = src.substring(token.raw.length);\n          tokens.push(token);\n          continue;\n        } // del (gfm)\n\n\n        if (token = this.tokenizer.del(src)) {\n          src = src.substring(token.raw.length);\n          tokens.push(token);\n          continue;\n        } // autolink\n\n\n        if (token = this.tokenizer.autolink(src, mangle)) {\n          src = src.substring(token.raw.length);\n          tokens.push(token);\n          continue;\n        } // url (gfm)\n\n\n        if (!this.state.inLink && (token = this.tokenizer.url(src, mangle))) {\n          src = src.substring(token.raw.length);\n          tokens.push(token);\n          continue;\n        } // text\n        // prevent inlineText consuming extensions by clipping 'src' to extension start\n\n\n        cutSrc = src;\n\n        if (this.options.extensions && this.options.extensions.startInline) {\n          (function () {\n            var startIndex = Infinity;\n            var tempSrc = src.slice(1);\n            var tempStart = void 0;\n\n            _this2.options.extensions.startInline.forEach(function (getStartIndex) {\n              tempStart = getStartIndex.call({\n                lexer: this\n              }, tempSrc);\n\n              if (typeof tempStart === 'number' && tempStart >= 0) {\n                startIndex = Math.min(startIndex, tempStart);\n              }\n            });\n\n            if (startIndex < Infinity && startIndex >= 0) {\n              cutSrc = src.substring(0, startIndex + 1);\n            }\n          })();\n        }\n\n        if (token = this.tokenizer.inlineText(cutSrc, smartypants)) {\n          src = src.substring(token.raw.length);\n\n          if (token.raw.slice(-1) !== '_') {\n            // Track prevChar before string of ____ started\n            prevChar = token.raw.slice(-1);\n          }\n\n          keepPrevChar = true;\n          lastToken = tokens[tokens.length - 1];\n\n          if (lastToken && lastToken.type === 'text') {\n            lastToken.raw += token.raw;\n            lastToken.text += token.text;\n          } else {\n            tokens.push(token);\n          }\n\n          continue;\n        }\n\n        if (src) {\n          var errMsg = 'Infinite loop on byte: ' + src.charCodeAt(0);\n\n          if (this.options.silent) {\n            console.error(errMsg);\n            break;\n          } else {\n            throw new Error(errMsg);\n          }\n        }\n      }\n\n      return tokens;\n    };\n\n    _createClass(Lexer, null, [{\n      key: \"rules\",\n      get: function get() {\n        return {\n          block: block,\n          inline: inline\n        };\n      }\n    }]);\n\n    return Lexer;\n  }();\n\n  var defaults$2 = defaults$5.exports.defaults;\n  var cleanUrl = helpers.cleanUrl,\n      escape$1 = helpers.escape;\n  /**\n   * Renderer\n   */\n\n  var Renderer_1 = /*#__PURE__*/function () {\n    function Renderer(options) {\n      this.options = options || defaults$2;\n    }\n\n    var _proto = Renderer.prototype;\n\n    _proto.code = function code(_code, infostring, escaped) {\n      var lang = (infostring || '').match(/\\S*/)[0];\n\n      if (this.options.highlight) {\n        var out = this.options.highlight(_code, lang);\n\n        if (out != null && out !== _code) {\n          escaped = true;\n          _code = out;\n        }\n      }\n\n      _code = _code.replace(/\\n$/, '') + '\\n';\n\n      if (!lang) {\n        return '<pre><code>' + (escaped ? _code : escape$1(_code, true)) + '</code></pre>\\n';\n      }\n\n      return '<pre><code class=\"' + this.options.langPrefix + escape$1(lang, true) + '\">' + (escaped ? _code : escape$1(_code, true)) + '</code></pre>\\n';\n    };\n\n    _proto.blockquote = function blockquote(quote) {\n      return '<blockquote>\\n' + quote + '</blockquote>\\n';\n    };\n\n    _proto.html = function html(_html) {\n      return _html;\n    };\n\n    _proto.heading = function heading(text, level, raw, slugger) {\n      if (this.options.headerIds) {\n        return '<h' + level + ' id=\"' + this.options.headerPrefix + slugger.slug(raw) + '\">' + text + '</h' + level + '>\\n';\n      } // ignore IDs\n\n\n      return '<h' + level + '>' + text + '</h' + level + '>\\n';\n    };\n\n    _proto.hr = function hr() {\n      return this.options.xhtml ? '<hr/>\\n' : '<hr>\\n';\n    };\n\n    _proto.list = function list(body, ordered, start) {\n      var type = ordered ? 'ol' : 'ul',\n          startatt = ordered && start !== 1 ? ' start=\"' + start + '\"' : '';\n      return '<' + type + startatt + '>\\n' + body + '</' + type + '>\\n';\n    };\n\n    _proto.listitem = function listitem(text) {\n      return '<li>' + text + '</li>\\n';\n    };\n\n    _proto.checkbox = function checkbox(checked) {\n      return '<input ' + (checked ? 'checked=\"\" ' : '') + 'disabled=\"\" type=\"checkbox\"' + (this.options.xhtml ? ' /' : '') + '> ';\n    };\n\n    _proto.paragraph = function paragraph(text) {\n      return '<p>' + text + '</p>\\n';\n    };\n\n    _proto.table = function table(header, body) {\n      if (body) body = '<tbody>' + body + '</tbody>';\n      return '<table>\\n' + '<thead>\\n' + header + '</thead>\\n' + body + '</table>\\n';\n    };\n\n    _proto.tablerow = function tablerow(content) {\n      return '<tr>\\n' + content + '</tr>\\n';\n    };\n\n    _proto.tablecell = function tablecell(content, flags) {\n      var type = flags.header ? 'th' : 'td';\n      var tag = flags.align ? '<' + type + ' align=\"' + flags.align + '\">' : '<' + type + '>';\n      return tag + content + '</' + type + '>\\n';\n    } // span level renderer\n    ;\n\n    _proto.strong = function strong(text) {\n      return '<strong>' + text + '</strong>';\n    };\n\n    _proto.em = function em(text) {\n      return '<em>' + text + '</em>';\n    };\n\n    _proto.codespan = function codespan(text) {\n      return '<code>' + text + '</code>';\n    };\n\n    _proto.br = function br() {\n      return this.options.xhtml ? '<br/>' : '<br>';\n    };\n\n    _proto.del = function del(text) {\n      return '<del>' + text + '</del>';\n    };\n\n    _proto.link = function link(href, title, text) {\n      href = cleanUrl(this.options.sanitize, this.options.baseUrl, href);\n\n      if (href === null) {\n        return text;\n      }\n\n      var out = '<a href=\"' + escape$1(href) + '\"';\n\n      if (title) {\n        out += ' title=\"' + title + '\"';\n      }\n\n      out += '>' + text + '</a>';\n      return out;\n    };\n\n    _proto.image = function image(href, title, text) {\n      href = cleanUrl(this.options.sanitize, this.options.baseUrl, href);\n\n      if (href === null) {\n        return text;\n      }\n\n      var out = '<img src=\"' + href + '\" alt=\"' + text + '\"';\n\n      if (title) {\n        out += ' title=\"' + title + '\"';\n      }\n\n      out += this.options.xhtml ? '/>' : '>';\n      return out;\n    };\n\n    _proto.text = function text(_text) {\n      return _text;\n    };\n\n    return Renderer;\n  }();\n\n  /**\n   * TextRenderer\n   * returns only the textual part of the token\n   */\n\n  var TextRenderer_1 = /*#__PURE__*/function () {\n    function TextRenderer() {}\n\n    var _proto = TextRenderer.prototype;\n\n    // no need for block level renderers\n    _proto.strong = function strong(text) {\n      return text;\n    };\n\n    _proto.em = function em(text) {\n      return text;\n    };\n\n    _proto.codespan = function codespan(text) {\n      return text;\n    };\n\n    _proto.del = function del(text) {\n      return text;\n    };\n\n    _proto.html = function html(text) {\n      return text;\n    };\n\n    _proto.text = function text(_text) {\n      return _text;\n    };\n\n    _proto.link = function link(href, title, text) {\n      return '' + text;\n    };\n\n    _proto.image = function image(href, title, text) {\n      return '' + text;\n    };\n\n    _proto.br = function br() {\n      return '';\n    };\n\n    return TextRenderer;\n  }();\n\n  /**\n   * Slugger generates header id\n   */\n\n  var Slugger_1 = /*#__PURE__*/function () {\n    function Slugger() {\n      this.seen = {};\n    }\n\n    var _proto = Slugger.prototype;\n\n    _proto.serialize = function serialize(value) {\n      return value.toLowerCase().trim() // remove html tags\n      .replace(/<[!\\/a-z].*?>/ig, '') // remove unwanted chars\n      .replace(/[\\u2000-\\u206F\\u2E00-\\u2E7F\\\\'!\"#$%&()*+,./:;<=>?@[\\]^`{|}~]/g, '').replace(/\\s/g, '-');\n    }\n    /**\n     * Finds the next safe (unique) slug to use\n     */\n    ;\n\n    _proto.getNextSafeSlug = function getNextSafeSlug(originalSlug, isDryRun) {\n      var slug = originalSlug;\n      var occurenceAccumulator = 0;\n\n      if (this.seen.hasOwnProperty(slug)) {\n        occurenceAccumulator = this.seen[originalSlug];\n\n        do {\n          occurenceAccumulator++;\n          slug = originalSlug + '-' + occurenceAccumulator;\n        } while (this.seen.hasOwnProperty(slug));\n      }\n\n      if (!isDryRun) {\n        this.seen[originalSlug] = occurenceAccumulator;\n        this.seen[slug] = 0;\n      }\n\n      return slug;\n    }\n    /**\n     * Convert string to unique id\n     * @param {object} options\n     * @param {boolean} options.dryrun Generates the next unique slug without updating the internal accumulator.\n     */\n    ;\n\n    _proto.slug = function slug(value, options) {\n      if (options === void 0) {\n        options = {};\n      }\n\n      var slug = this.serialize(value);\n      return this.getNextSafeSlug(slug, options.dryrun);\n    };\n\n    return Slugger;\n  }();\n\n  var Renderer$1 = Renderer_1;\n  var TextRenderer$1 = TextRenderer_1;\n  var Slugger$1 = Slugger_1;\n  var defaults$1 = defaults$5.exports.defaults;\n  var unescape = helpers.unescape;\n  /**\n   * Parsing & Compiling\n   */\n\n  var Parser_1 = /*#__PURE__*/function () {\n    function Parser(options) {\n      this.options = options || defaults$1;\n      this.options.renderer = this.options.renderer || new Renderer$1();\n      this.renderer = this.options.renderer;\n      this.renderer.options = this.options;\n      this.textRenderer = new TextRenderer$1();\n      this.slugger = new Slugger$1();\n    }\n    /**\n     * Static Parse Method\n     */\n\n\n    Parser.parse = function parse(tokens, options) {\n      var parser = new Parser(options);\n      return parser.parse(tokens);\n    }\n    /**\n     * Static Parse Inline Method\n     */\n    ;\n\n    Parser.parseInline = function parseInline(tokens, options) {\n      var parser = new Parser(options);\n      return parser.parseInline(tokens);\n    }\n    /**\n     * Parse Loop\n     */\n    ;\n\n    var _proto = Parser.prototype;\n\n    _proto.parse = function parse(tokens, top) {\n      if (top === void 0) {\n        top = true;\n      }\n\n      var out = '',\n          i,\n          j,\n          k,\n          l2,\n          l3,\n          row,\n          cell,\n          header,\n          body,\n          token,\n          ordered,\n          start,\n          loose,\n          itemBody,\n          item,\n          checked,\n          task,\n          checkbox,\n          ret;\n      var l = tokens.length;\n\n      for (i = 0; i < l; i++) {\n        token = tokens[i]; // Run any renderer extensions\n\n        if (this.options.extensions && this.options.extensions.renderers && this.options.extensions.renderers[token.type]) {\n          ret = this.options.extensions.renderers[token.type].call({\n            parser: this\n          }, token);\n\n          if (ret !== false || !['space', 'hr', 'heading', 'code', 'table', 'blockquote', 'list', 'html', 'paragraph', 'text'].includes(token.type)) {\n            out += ret || '';\n            continue;\n          }\n        }\n\n        switch (token.type) {\n          case 'space':\n            {\n              continue;\n            }\n\n          case 'hr':\n            {\n              out += this.renderer.hr();\n              continue;\n            }\n\n          case 'heading':\n            {\n              out += this.renderer.heading(this.parseInline(token.tokens), token.depth, unescape(this.parseInline(token.tokens, this.textRenderer)), this.slugger);\n              continue;\n            }\n\n          case 'code':\n            {\n              out += this.renderer.code(token.text, token.lang, token.escaped);\n              continue;\n            }\n\n          case 'table':\n            {\n              header = ''; // header\n\n              cell = '';\n              l2 = token.header.length;\n\n              for (j = 0; j < l2; j++) {\n                cell += this.renderer.tablecell(this.parseInline(token.header[j].tokens), {\n                  header: true,\n                  align: token.align[j]\n                });\n              }\n\n              header += this.renderer.tablerow(cell);\n              body = '';\n              l2 = token.rows.length;\n\n              for (j = 0; j < l2; j++) {\n                row = token.rows[j];\n                cell = '';\n                l3 = row.length;\n\n                for (k = 0; k < l3; k++) {\n                  cell += this.renderer.tablecell(this.parseInline(row[k].tokens), {\n                    header: false,\n                    align: token.align[k]\n                  });\n                }\n\n                body += this.renderer.tablerow(cell);\n              }\n\n              out += this.renderer.table(header, body);\n              continue;\n            }\n\n          case 'blockquote':\n            {\n              body = this.parse(token.tokens);\n              out += this.renderer.blockquote(body);\n              continue;\n            }\n\n          case 'list':\n            {\n              ordered = token.ordered;\n              start = token.start;\n              loose = token.loose;\n              l2 = token.items.length;\n              body = '';\n\n              for (j = 0; j < l2; j++) {\n                item = token.items[j];\n                checked = item.checked;\n                task = item.task;\n                itemBody = '';\n\n                if (item.task) {\n                  checkbox = this.renderer.checkbox(checked);\n\n                  if (loose) {\n                    if (item.tokens.length > 0 && item.tokens[0].type === 'paragraph') {\n                      item.tokens[0].text = checkbox + ' ' + item.tokens[0].text;\n\n                      if (item.tokens[0].tokens && item.tokens[0].tokens.length > 0 && item.tokens[0].tokens[0].type === 'text') {\n                        item.tokens[0].tokens[0].text = checkbox + ' ' + item.tokens[0].tokens[0].text;\n                      }\n                    } else {\n                      item.tokens.unshift({\n                        type: 'text',\n                        text: checkbox\n                      });\n                    }\n                  } else {\n                    itemBody += checkbox;\n                  }\n                }\n\n                itemBody += this.parse(item.tokens, loose);\n                body += this.renderer.listitem(itemBody, task, checked);\n              }\n\n              out += this.renderer.list(body, ordered, start);\n              continue;\n            }\n\n          case 'html':\n            {\n              // TODO parse inline content if parameter markdown=1\n              out += this.renderer.html(token.text);\n              continue;\n            }\n\n          case 'paragraph':\n            {\n              out += this.renderer.paragraph(this.parseInline(token.tokens));\n              continue;\n            }\n\n          case 'text':\n            {\n              body = token.tokens ? this.parseInline(token.tokens) : token.text;\n\n              while (i + 1 < l && tokens[i + 1].type === 'text') {\n                token = tokens[++i];\n                body += '\\n' + (token.tokens ? this.parseInline(token.tokens) : token.text);\n              }\n\n              out += top ? this.renderer.paragraph(body) : body;\n              continue;\n            }\n\n          default:\n            {\n              var errMsg = 'Token with \"' + token.type + '\" type was not found.';\n\n              if (this.options.silent) {\n                console.error(errMsg);\n                return;\n              } else {\n                throw new Error(errMsg);\n              }\n            }\n        }\n      }\n\n      return out;\n    }\n    /**\n     * Parse Inline Tokens\n     */\n    ;\n\n    _proto.parseInline = function parseInline(tokens, renderer) {\n      renderer = renderer || this.renderer;\n      var out = '',\n          i,\n          token,\n          ret;\n      var l = tokens.length;\n\n      for (i = 0; i < l; i++) {\n        token = tokens[i]; // Run any renderer extensions\n\n        if (this.options.extensions && this.options.extensions.renderers && this.options.extensions.renderers[token.type]) {\n          ret = this.options.extensions.renderers[token.type].call({\n            parser: this\n          }, token);\n\n          if (ret !== false || !['escape', 'html', 'link', 'image', 'strong', 'em', 'codespan', 'br', 'del', 'text'].includes(token.type)) {\n            out += ret || '';\n            continue;\n          }\n        }\n\n        switch (token.type) {\n          case 'escape':\n            {\n              out += renderer.text(token.text);\n              break;\n            }\n\n          case 'html':\n            {\n              out += renderer.html(token.text);\n              break;\n            }\n\n          case 'link':\n            {\n              out += renderer.link(token.href, token.title, this.parseInline(token.tokens, renderer));\n              break;\n            }\n\n          case 'image':\n            {\n              out += renderer.image(token.href, token.title, token.text);\n              break;\n            }\n\n          case 'strong':\n            {\n              out += renderer.strong(this.parseInline(token.tokens, renderer));\n              break;\n            }\n\n          case 'em':\n            {\n              out += renderer.em(this.parseInline(token.tokens, renderer));\n              break;\n            }\n\n          case 'codespan':\n            {\n              out += renderer.codespan(token.text);\n              break;\n            }\n\n          case 'br':\n            {\n              out += renderer.br();\n              break;\n            }\n\n          case 'del':\n            {\n              out += renderer.del(this.parseInline(token.tokens, renderer));\n              break;\n            }\n\n          case 'text':\n            {\n              out += renderer.text(token.text);\n              break;\n            }\n\n          default:\n            {\n              var errMsg = 'Token with \"' + token.type + '\" type was not found.';\n\n              if (this.options.silent) {\n                console.error(errMsg);\n                return;\n              } else {\n                throw new Error(errMsg);\n              }\n            }\n        }\n      }\n\n      return out;\n    };\n\n    return Parser;\n  }();\n\n  var Lexer = Lexer_1;\n  var Parser = Parser_1;\n  var Tokenizer = Tokenizer_1;\n  var Renderer = Renderer_1;\n  var TextRenderer = TextRenderer_1;\n  var Slugger = Slugger_1;\n  var merge = helpers.merge,\n      checkSanitizeDeprecation = helpers.checkSanitizeDeprecation,\n      escape = helpers.escape;\n  var getDefaults = defaults$5.exports.getDefaults,\n      changeDefaults = defaults$5.exports.changeDefaults,\n      defaults = defaults$5.exports.defaults;\n  /**\n   * Marked\n   */\n\n  function marked(src, opt, callback) {\n    // throw error in case of non string input\n    if (typeof src === 'undefined' || src === null) {\n      throw new Error('marked(): input parameter is undefined or null');\n    }\n\n    if (typeof src !== 'string') {\n      throw new Error('marked(): input parameter is of type ' + Object.prototype.toString.call(src) + ', string expected');\n    }\n\n    if (typeof opt === 'function') {\n      callback = opt;\n      opt = null;\n    }\n\n    opt = merge({}, marked.defaults, opt || {});\n    checkSanitizeDeprecation(opt);\n\n    if (callback) {\n      var highlight = opt.highlight;\n      var tokens;\n\n      try {\n        tokens = Lexer.lex(src, opt);\n      } catch (e) {\n        return callback(e);\n      }\n\n      var done = function done(err) {\n        var out;\n\n        if (!err) {\n          try {\n            if (opt.walkTokens) {\n              marked.walkTokens(tokens, opt.walkTokens);\n            }\n\n            out = Parser.parse(tokens, opt);\n          } catch (e) {\n            err = e;\n          }\n        }\n\n        opt.highlight = highlight;\n        return err ? callback(err) : callback(null, out);\n      };\n\n      if (!highlight || highlight.length < 3) {\n        return done();\n      }\n\n      delete opt.highlight;\n      if (!tokens.length) return done();\n      var pending = 0;\n      marked.walkTokens(tokens, function (token) {\n        if (token.type === 'code') {\n          pending++;\n          setTimeout(function () {\n            highlight(token.text, token.lang, function (err, code) {\n              if (err) {\n                return done(err);\n              }\n\n              if (code != null && code !== token.text) {\n                token.text = code;\n                token.escaped = true;\n              }\n\n              pending--;\n\n              if (pending === 0) {\n                done();\n              }\n            });\n          }, 0);\n        }\n      });\n\n      if (pending === 0) {\n        done();\n      }\n\n      return;\n    }\n\n    try {\n      var _tokens = Lexer.lex(src, opt);\n\n      if (opt.walkTokens) {\n        marked.walkTokens(_tokens, opt.walkTokens);\n      }\n\n      return Parser.parse(_tokens, opt);\n    } catch (e) {\n      e.message += '\\nPlease report this to https://github.com/markedjs/marked.';\n\n      if (opt.silent) {\n        return '<p>An error occurred:</p><pre>' + escape(e.message + '', true) + '</pre>';\n      }\n\n      throw e;\n    }\n  }\n  /**\n   * Options\n   */\n\n\n  marked.options = marked.setOptions = function (opt) {\n    merge(marked.defaults, opt);\n    changeDefaults(marked.defaults);\n    return marked;\n  };\n\n  marked.getDefaults = getDefaults;\n  marked.defaults = defaults;\n  /**\n   * Use Extension\n   */\n\n  marked.use = function () {\n    var _this = this;\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    var opts = merge.apply(void 0, [{}].concat(args));\n    var extensions = marked.defaults.extensions || {\n      renderers: {},\n      childTokens: {}\n    };\n    var hasExtensions;\n    args.forEach(function (pack) {\n      // ==-- Parse \"addon\" extensions --== //\n      if (pack.extensions) {\n        hasExtensions = true;\n        pack.extensions.forEach(function (ext) {\n          if (!ext.name) {\n            throw new Error('extension name required');\n          }\n\n          if (ext.renderer) {\n            // Renderer extensions\n            var prevRenderer = extensions.renderers ? extensions.renderers[ext.name] : null;\n\n            if (prevRenderer) {\n              // Replace extension with func to run new extension but fall back if false\n              extensions.renderers[ext.name] = function () {\n                for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n                  args[_key2] = arguments[_key2];\n                }\n\n                var ret = ext.renderer.apply(this, args);\n\n                if (ret === false) {\n                  ret = prevRenderer.apply(this, args);\n                }\n\n                return ret;\n              };\n            } else {\n              extensions.renderers[ext.name] = ext.renderer;\n            }\n          }\n\n          if (ext.tokenizer) {\n            // Tokenizer Extensions\n            if (!ext.level || ext.level !== 'block' && ext.level !== 'inline') {\n              throw new Error(\"extension level must be 'block' or 'inline'\");\n            }\n\n            if (extensions[ext.level]) {\n              extensions[ext.level].unshift(ext.tokenizer);\n            } else {\n              extensions[ext.level] = [ext.tokenizer];\n            }\n\n            if (ext.start) {\n              // Function to check for start of token\n              if (ext.level === 'block') {\n                if (extensions.startBlock) {\n                  extensions.startBlock.push(ext.start);\n                } else {\n                  extensions.startBlock = [ext.start];\n                }\n              } else if (ext.level === 'inline') {\n                if (extensions.startInline) {\n                  extensions.startInline.push(ext.start);\n                } else {\n                  extensions.startInline = [ext.start];\n                }\n              }\n            }\n          }\n\n          if (ext.childTokens) {\n            // Child tokens to be visited by walkTokens\n            extensions.childTokens[ext.name] = ext.childTokens;\n          }\n        });\n      } // ==-- Parse \"overwrite\" extensions --== //\n\n\n      if (pack.renderer) {\n        (function () {\n          var renderer = marked.defaults.renderer || new Renderer();\n\n          var _loop = function _loop(prop) {\n            var prevRenderer = renderer[prop]; // Replace renderer with func to run extension, but fall back if false\n\n            renderer[prop] = function () {\n              for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n                args[_key3] = arguments[_key3];\n              }\n\n              var ret = pack.renderer[prop].apply(renderer, args);\n\n              if (ret === false) {\n                ret = prevRenderer.apply(renderer, args);\n              }\n\n              return ret;\n            };\n          };\n\n          for (var prop in pack.renderer) {\n            _loop(prop);\n          }\n\n          opts.renderer = renderer;\n        })();\n      }\n\n      if (pack.tokenizer) {\n        (function () {\n          var tokenizer = marked.defaults.tokenizer || new Tokenizer();\n\n          var _loop2 = function _loop2(prop) {\n            var prevTokenizer = tokenizer[prop]; // Replace tokenizer with func to run extension, but fall back if false\n\n            tokenizer[prop] = function () {\n              for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n                args[_key4] = arguments[_key4];\n              }\n\n              var ret = pack.tokenizer[prop].apply(tokenizer, args);\n\n              if (ret === false) {\n                ret = prevTokenizer.apply(tokenizer, args);\n              }\n\n              return ret;\n            };\n          };\n\n          for (var prop in pack.tokenizer) {\n            _loop2(prop);\n          }\n\n          opts.tokenizer = tokenizer;\n        })();\n      } // ==-- Parse WalkTokens extensions --== //\n\n\n      if (pack.walkTokens) {\n        var walkTokens = marked.defaults.walkTokens;\n\n        opts.walkTokens = function (token) {\n          pack.walkTokens.call(_this, token);\n\n          if (walkTokens) {\n            walkTokens(token);\n          }\n        };\n      }\n\n      if (hasExtensions) {\n        opts.extensions = extensions;\n      }\n\n      marked.setOptions(opts);\n    });\n  };\n  /**\n   * Run callback for every token\n   */\n\n\n  marked.walkTokens = function (tokens, callback) {\n    var _loop3 = function _loop3() {\n      var token = _step.value;\n      callback(token);\n\n      switch (token.type) {\n        case 'table':\n          {\n            for (var _iterator2 = _createForOfIteratorHelperLoose(token.header), _step2; !(_step2 = _iterator2()).done;) {\n              var cell = _step2.value;\n              marked.walkTokens(cell.tokens, callback);\n            }\n\n            for (var _iterator3 = _createForOfIteratorHelperLoose(token.rows), _step3; !(_step3 = _iterator3()).done;) {\n              var row = _step3.value;\n\n              for (var _iterator4 = _createForOfIteratorHelperLoose(row), _step4; !(_step4 = _iterator4()).done;) {\n                var _cell = _step4.value;\n                marked.walkTokens(_cell.tokens, callback);\n              }\n            }\n\n            break;\n          }\n\n        case 'list':\n          {\n            marked.walkTokens(token.items, callback);\n            break;\n          }\n\n        default:\n          {\n            if (marked.defaults.extensions && marked.defaults.extensions.childTokens && marked.defaults.extensions.childTokens[token.type]) {\n              // Walk any extensions\n              marked.defaults.extensions.childTokens[token.type].forEach(function (childTokens) {\n                marked.walkTokens(token[childTokens], callback);\n              });\n            } else if (token.tokens) {\n              marked.walkTokens(token.tokens, callback);\n            }\n          }\n      }\n    };\n\n    for (var _iterator = _createForOfIteratorHelperLoose(tokens), _step; !(_step = _iterator()).done;) {\n      _loop3();\n    }\n  };\n  /**\n   * Parse Inline\n   */\n\n\n  marked.parseInline = function (src, opt) {\n    // throw error in case of non string input\n    if (typeof src === 'undefined' || src === null) {\n      throw new Error('marked.parseInline(): input parameter is undefined or null');\n    }\n\n    if (typeof src !== 'string') {\n      throw new Error('marked.parseInline(): input parameter is of type ' + Object.prototype.toString.call(src) + ', string expected');\n    }\n\n    opt = merge({}, marked.defaults, opt || {});\n    checkSanitizeDeprecation(opt);\n\n    try {\n      var tokens = Lexer.lexInline(src, opt);\n\n      if (opt.walkTokens) {\n        marked.walkTokens(tokens, opt.walkTokens);\n      }\n\n      return Parser.parseInline(tokens, opt);\n    } catch (e) {\n      e.message += '\\nPlease report this to https://github.com/markedjs/marked.';\n\n      if (opt.silent) {\n        return '<p>An error occurred:</p><pre>' + escape(e.message + '', true) + '</pre>';\n      }\n\n      throw e;\n    }\n  };\n  /**\n   * Expose\n   */\n\n\n  marked.Parser = Parser;\n  marked.parser = Parser.parse;\n  marked.Renderer = Renderer;\n  marked.TextRenderer = TextRenderer;\n  marked.Lexer = Lexer;\n  marked.lexer = Lexer.lex;\n  marked.Tokenizer = Tokenizer;\n  marked.Slugger = Slugger;\n  marked.parse = marked;\n  var marked_1 = marked;\n\n  return marked_1;\n\n}));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esc0NBQXNDLElBQUk7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGtDQUFrQzs7QUFFbEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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O0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxVQUFVOzs7QUFHVjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFVBQVU7OztBQUdWO0FBQ0E7QUFDQSxpREFBaUQ7O0FBRWpEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQSxVQUFVOzs7QUFHVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7OztBQUdWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTs7O0FBR1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVOzs7QUFHVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7OztBQUdWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTs7O0FBR1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVOzs7QUFHVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFVBQVU7OztBQUdWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTs7O0FBR1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZTs7QUFFZjtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVOzs7QUFHVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsb0NBQW9DOztBQUVwQztBQUNBO0FBQ0Esa0NBQWtDOztBQUVsQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTs7O0FBR1I7QUFDQTtBQUNBLFFBQVE7OztBQUdSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw4QkFBOEI7O0FBRTlCO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFVBQVU7OztBQUdWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTs7O0FBR1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0EsVUFBVTs7O0FBR1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVOzs7QUFHVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQSxVQUFVOzs7QUFHVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7OztBQUdWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTs7O0FBR1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVOzs7QUFHVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7OztBQUdWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTs7O0FBR1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZTs7QUFFZjtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFROzs7QUFHUjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RCxXQUFXLEVBQUU7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVM7QUFDVCxRQUFROzs7QUFHUjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHlGQUF5Riw4QkFBOEI7QUFDdkg7QUFDQTtBQUNBOztBQUVBLHVGQUF1Riw4QkFBOEI7QUFDckg7O0FBRUEsa0ZBQWtGLDhCQUE4QjtBQUNoSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHlFQUF5RSw0QkFBNEI7QUFDckc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0IsNEJBQTRCO0FBQzlDOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBTTtBQUNOOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9ub2RlX21vZHVsZXMvbWFya2VkL2xpYi9tYXJrZWQuanM/MGU1NCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIG1hcmtlZCAtIGEgbWFya2Rvd24gcGFyc2VyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTEtMjAyMSwgQ2hyaXN0b3BoZXIgSmVmZnJleS4gKE1JVCBMaWNlbnNlZClcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9tYXJrZWRqcy9tYXJrZWRcbiAqL1xuXG4vKipcbiAqIERPIE5PVCBFRElUIFRISVMgRklMRVxuICogVGhlIGNvZGUgaW4gdGhpcyBmaWxlIGlzIGdlbmVyYXRlZCBmcm9tIGZpbGVzIGluIC4vc3JjL1xuICovXG5cbihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG4gIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpIDpcbiAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKGZhY3RvcnkpIDpcbiAgKGdsb2JhbCA9IHR5cGVvZiBnbG9iYWxUaGlzICE9PSAndW5kZWZpbmVkJyA/IGdsb2JhbFRoaXMgOiBnbG9iYWwgfHwgc2VsZiwgZ2xvYmFsLm1hcmtlZCA9IGZhY3RvcnkoKSk7XG59KSh0aGlzLCAoZnVuY3Rpb24gKCkgeyAndXNlIHN0cmljdCc7XG5cbiAgZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07XG4gICAgICBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7XG4gICAgICBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7XG4gICAgICBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHtcbiAgICBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTtcbiAgICBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7XG4gICAgcmV0dXJuIENvbnN0cnVjdG9yO1xuICB9XG5cbiAgZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8sIG1pbkxlbikge1xuICAgIGlmICghbykgcmV0dXJuO1xuICAgIGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7XG4gICAgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpO1xuICAgIGlmIChuID09PSBcIk9iamVjdFwiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7XG4gICAgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIEFycmF5LmZyb20obyk7XG4gICAgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pO1xuICB9XG5cbiAgZnVuY3Rpb24gX2FycmF5TGlrZVRvQXJyYXkoYXJyLCBsZW4pIHtcbiAgICBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDtcblxuICAgIGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKykgYXJyMltpXSA9IGFycltpXTtcblxuICAgIHJldHVybiBhcnIyO1xuICB9XG5cbiAgZnVuY3Rpb24gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXJMb29zZShvLCBhbGxvd0FycmF5TGlrZSkge1xuICAgIHZhciBpdCA9IHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdIHx8IG9bXCJAQGl0ZXJhdG9yXCJdO1xuICAgIGlmIChpdCkgcmV0dXJuIChpdCA9IGl0LmNhbGwobykpLm5leHQuYmluZChpdCk7XG5cbiAgICBpZiAoQXJyYXkuaXNBcnJheShvKSB8fCAoaXQgPSBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobykpIHx8IGFsbG93QXJyYXlMaWtlICYmIG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09PSBcIm51bWJlclwiKSB7XG4gICAgICBpZiAoaXQpIG8gPSBpdDtcbiAgICAgIHZhciBpID0gMDtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChpID49IG8ubGVuZ3RoKSByZXR1cm4ge1xuICAgICAgICAgIGRvbmU6IHRydWVcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBkb25lOiBmYWxzZSxcbiAgICAgICAgICB2YWx1ZTogb1tpKytdXG4gICAgICAgIH07XG4gICAgICB9O1xuICAgIH1cblxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gaXRlcmF0ZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTtcbiAgfVxuXG4gIHZhciBkZWZhdWx0cyQ1ID0ge2V4cG9ydHM6IHt9fTtcblxuICBmdW5jdGlvbiBnZXREZWZhdWx0cyQxKCkge1xuICAgIHJldHVybiB7XG4gICAgICBiYXNlVXJsOiBudWxsLFxuICAgICAgYnJlYWtzOiBmYWxzZSxcbiAgICAgIGV4dGVuc2lvbnM6IG51bGwsXG4gICAgICBnZm06IHRydWUsXG4gICAgICBoZWFkZXJJZHM6IHRydWUsXG4gICAgICBoZWFkZXJQcmVmaXg6ICcnLFxuICAgICAgaGlnaGxpZ2h0OiBudWxsLFxuICAgICAgbGFuZ1ByZWZpeDogJ2xhbmd1YWdlLScsXG4gICAgICBtYW5nbGU6IHRydWUsXG4gICAgICBwZWRhbnRpYzogZmFsc2UsXG4gICAgICByZW5kZXJlcjogbnVsbCxcbiAgICAgIHNhbml0aXplOiBmYWxzZSxcbiAgICAgIHNhbml0aXplcjogbnVsbCxcbiAgICAgIHNpbGVudDogZmFsc2UsXG4gICAgICBzbWFydExpc3RzOiBmYWxzZSxcbiAgICAgIHNtYXJ0eXBhbnRzOiBmYWxzZSxcbiAgICAgIHRva2VuaXplcjogbnVsbCxcbiAgICAgIHdhbGtUb2tlbnM6IG51bGwsXG4gICAgICB4aHRtbDogZmFsc2VcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gY2hhbmdlRGVmYXVsdHMkMShuZXdEZWZhdWx0cykge1xuICAgIGRlZmF1bHRzJDUuZXhwb3J0cy5kZWZhdWx0cyA9IG5ld0RlZmF1bHRzO1xuICB9XG5cbiAgZGVmYXVsdHMkNS5leHBvcnRzID0ge1xuICAgIGRlZmF1bHRzOiBnZXREZWZhdWx0cyQxKCksXG4gICAgZ2V0RGVmYXVsdHM6IGdldERlZmF1bHRzJDEsXG4gICAgY2hhbmdlRGVmYXVsdHM6IGNoYW5nZURlZmF1bHRzJDFcbiAgfTtcblxuICAvKipcbiAgICogSGVscGVyc1xuICAgKi9cbiAgdmFyIGVzY2FwZVRlc3QgPSAvWyY8PlwiJ10vO1xuICB2YXIgZXNjYXBlUmVwbGFjZSA9IC9bJjw+XCInXS9nO1xuICB2YXIgZXNjYXBlVGVzdE5vRW5jb2RlID0gL1s8PlwiJ118Jig/ISM/XFx3KzspLztcbiAgdmFyIGVzY2FwZVJlcGxhY2VOb0VuY29kZSA9IC9bPD5cIiddfCYoPyEjP1xcdys7KS9nO1xuICB2YXIgZXNjYXBlUmVwbGFjZW1lbnRzID0ge1xuICAgICcmJzogJyZhbXA7JyxcbiAgICAnPCc6ICcmbHQ7JyxcbiAgICAnPic6ICcmZ3Q7JyxcbiAgICAnXCInOiAnJnF1b3Q7JyxcbiAgICBcIidcIjogJyYjMzk7J1xuICB9O1xuXG4gIHZhciBnZXRFc2NhcGVSZXBsYWNlbWVudCA9IGZ1bmN0aW9uIGdldEVzY2FwZVJlcGxhY2VtZW50KGNoKSB7XG4gICAgcmV0dXJuIGVzY2FwZVJlcGxhY2VtZW50c1tjaF07XG4gIH07XG5cbiAgZnVuY3Rpb24gZXNjYXBlJDIoaHRtbCwgZW5jb2RlKSB7XG4gICAgaWYgKGVuY29kZSkge1xuICAgICAgaWYgKGVzY2FwZVRlc3QudGVzdChodG1sKSkge1xuICAgICAgICByZXR1cm4gaHRtbC5yZXBsYWNlKGVzY2FwZVJlcGxhY2UsIGdldEVzY2FwZVJlcGxhY2VtZW50KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGVzY2FwZVRlc3ROb0VuY29kZS50ZXN0KGh0bWwpKSB7XG4gICAgICAgIHJldHVybiBodG1sLnJlcGxhY2UoZXNjYXBlUmVwbGFjZU5vRW5jb2RlLCBnZXRFc2NhcGVSZXBsYWNlbWVudCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGh0bWw7XG4gIH1cblxuICB2YXIgdW5lc2NhcGVUZXN0ID0gLyYoIyg/OlxcZCspfCg/OiN4WzAtOUEtRmEtZl0rKXwoPzpcXHcrKSk7Py9pZztcblxuICBmdW5jdGlvbiB1bmVzY2FwZSQxKGh0bWwpIHtcbiAgICAvLyBleHBsaWNpdGx5IG1hdGNoIGRlY2ltYWwsIGhleCwgYW5kIG5hbWVkIEhUTUwgZW50aXRpZXNcbiAgICByZXR1cm4gaHRtbC5yZXBsYWNlKHVuZXNjYXBlVGVzdCwgZnVuY3Rpb24gKF8sIG4pIHtcbiAgICAgIG4gPSBuLnRvTG93ZXJDYXNlKCk7XG4gICAgICBpZiAobiA9PT0gJ2NvbG9uJykgcmV0dXJuICc6JztcblxuICAgICAgaWYgKG4uY2hhckF0KDApID09PSAnIycpIHtcbiAgICAgICAgcmV0dXJuIG4uY2hhckF0KDEpID09PSAneCcgPyBTdHJpbmcuZnJvbUNoYXJDb2RlKHBhcnNlSW50KG4uc3Vic3RyaW5nKDIpLCAxNikpIDogU3RyaW5nLmZyb21DaGFyQ29kZSgrbi5zdWJzdHJpbmcoMSkpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gJyc7XG4gICAgfSk7XG4gIH1cblxuICB2YXIgY2FyZXQgPSAvKF58W15cXFtdKVxcXi9nO1xuXG4gIGZ1bmN0aW9uIGVkaXQkMShyZWdleCwgb3B0KSB7XG4gICAgcmVnZXggPSByZWdleC5zb3VyY2UgfHwgcmVnZXg7XG4gICAgb3B0ID0gb3B0IHx8ICcnO1xuICAgIHZhciBvYmogPSB7XG4gICAgICByZXBsYWNlOiBmdW5jdGlvbiByZXBsYWNlKG5hbWUsIHZhbCkge1xuICAgICAgICB2YWwgPSB2YWwuc291cmNlIHx8IHZhbDtcbiAgICAgICAgdmFsID0gdmFsLnJlcGxhY2UoY2FyZXQsICckMScpO1xuICAgICAgICByZWdleCA9IHJlZ2V4LnJlcGxhY2UobmFtZSwgdmFsKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgIH0sXG4gICAgICBnZXRSZWdleDogZnVuY3Rpb24gZ2V0UmVnZXgoKSB7XG4gICAgICAgIHJldHVybiBuZXcgUmVnRXhwKHJlZ2V4LCBvcHQpO1xuICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIG9iajtcbiAgfVxuXG4gIHZhciBub25Xb3JkQW5kQ29sb25UZXN0ID0gL1teXFx3Ol0vZztcbiAgdmFyIG9yaWdpbkluZGVwZW5kZW50VXJsID0gL14kfF5bYS16XVthLXowLTkrLi1dKjp8Xls/I10vaTtcblxuICBmdW5jdGlvbiBjbGVhblVybCQxKHNhbml0aXplLCBiYXNlLCBocmVmKSB7XG4gICAgaWYgKHNhbml0aXplKSB7XG4gICAgICB2YXIgcHJvdDtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgcHJvdCA9IGRlY29kZVVSSUNvbXBvbmVudCh1bmVzY2FwZSQxKGhyZWYpKS5yZXBsYWNlKG5vbldvcmRBbmRDb2xvblRlc3QsICcnKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgaWYgKHByb3QuaW5kZXhPZignamF2YXNjcmlwdDonKSA9PT0gMCB8fCBwcm90LmluZGV4T2YoJ3Zic2NyaXB0OicpID09PSAwIHx8IHByb3QuaW5kZXhPZignZGF0YTonKSA9PT0gMCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoYmFzZSAmJiAhb3JpZ2luSW5kZXBlbmRlbnRVcmwudGVzdChocmVmKSkge1xuICAgICAgaHJlZiA9IHJlc29sdmVVcmwoYmFzZSwgaHJlZik7XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIGhyZWYgPSBlbmNvZGVVUkkoaHJlZikucmVwbGFjZSgvJTI1L2csICclJyk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIGhyZWY7XG4gIH1cblxuICB2YXIgYmFzZVVybHMgPSB7fTtcbiAgdmFyIGp1c3REb21haW4gPSAvXlteOl0rOlxcLypbXi9dKiQvO1xuICB2YXIgcHJvdG9jb2wgPSAvXihbXjpdKzopW1xcc1xcU10qJC87XG4gIHZhciBkb21haW4gPSAvXihbXjpdKzpcXC8qW14vXSopW1xcc1xcU10qJC87XG5cbiAgZnVuY3Rpb24gcmVzb2x2ZVVybChiYXNlLCBocmVmKSB7XG4gICAgaWYgKCFiYXNlVXJsc1snICcgKyBiYXNlXSkge1xuICAgICAgLy8gd2UgY2FuIGlnbm9yZSBldmVyeXRoaW5nIGluIGJhc2UgYWZ0ZXIgdGhlIGxhc3Qgc2xhc2ggb2YgaXRzIHBhdGggY29tcG9uZW50LFxuICAgICAgLy8gYnV0IHdlIG1pZ2h0IG5lZWQgdG8gYWRkIF90aGF0X1xuICAgICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzM5ODYjc2VjdGlvbi0zXG4gICAgICBpZiAoanVzdERvbWFpbi50ZXN0KGJhc2UpKSB7XG4gICAgICAgIGJhc2VVcmxzWycgJyArIGJhc2VdID0gYmFzZSArICcvJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJhc2VVcmxzWycgJyArIGJhc2VdID0gcnRyaW0kMShiYXNlLCAnLycsIHRydWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGJhc2UgPSBiYXNlVXJsc1snICcgKyBiYXNlXTtcbiAgICB2YXIgcmVsYXRpdmVCYXNlID0gYmFzZS5pbmRleE9mKCc6JykgPT09IC0xO1xuXG4gICAgaWYgKGhyZWYuc3Vic3RyaW5nKDAsIDIpID09PSAnLy8nKSB7XG4gICAgICBpZiAocmVsYXRpdmVCYXNlKSB7XG4gICAgICAgIHJldHVybiBocmVmO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gYmFzZS5yZXBsYWNlKHByb3RvY29sLCAnJDEnKSArIGhyZWY7XG4gICAgfSBlbHNlIGlmIChocmVmLmNoYXJBdCgwKSA9PT0gJy8nKSB7XG4gICAgICBpZiAocmVsYXRpdmVCYXNlKSB7XG4gICAgICAgIHJldHVybiBocmVmO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gYmFzZS5yZXBsYWNlKGRvbWFpbiwgJyQxJykgKyBocmVmO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gYmFzZSArIGhyZWY7XG4gICAgfVxuICB9XG5cbiAgdmFyIG5vb3BUZXN0JDEgPSB7XG4gICAgZXhlYzogZnVuY3Rpb24gbm9vcFRlc3QoKSB7fVxuICB9O1xuXG4gIGZ1bmN0aW9uIG1lcmdlJDIob2JqKSB7XG4gICAgdmFyIGkgPSAxLFxuICAgICAgICB0YXJnZXQsXG4gICAgICAgIGtleTtcblxuICAgIGZvciAoOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0YXJnZXQgPSBhcmd1bWVudHNbaV07XG5cbiAgICAgIGZvciAoa2V5IGluIHRhcmdldCkge1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRhcmdldCwga2V5KSkge1xuICAgICAgICAgIG9ialtrZXldID0gdGFyZ2V0W2tleV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gb2JqO1xuICB9XG5cbiAgZnVuY3Rpb24gc3BsaXRDZWxscyQxKHRhYmxlUm93LCBjb3VudCkge1xuICAgIC8vIGVuc3VyZSB0aGF0IGV2ZXJ5IGNlbGwtZGVsaW1pdGluZyBwaXBlIGhhcyBhIHNwYWNlXG4gICAgLy8gYmVmb3JlIGl0IHRvIGRpc3Rpbmd1aXNoIGl0IGZyb20gYW4gZXNjYXBlZCBwaXBlXG4gICAgdmFyIHJvdyA9IHRhYmxlUm93LnJlcGxhY2UoL1xcfC9nLCBmdW5jdGlvbiAobWF0Y2gsIG9mZnNldCwgc3RyKSB7XG4gICAgICB2YXIgZXNjYXBlZCA9IGZhbHNlLFxuICAgICAgICAgIGN1cnIgPSBvZmZzZXQ7XG5cbiAgICAgIHdoaWxlICgtLWN1cnIgPj0gMCAmJiBzdHJbY3Vycl0gPT09ICdcXFxcJykge1xuICAgICAgICBlc2NhcGVkID0gIWVzY2FwZWQ7XG4gICAgICB9XG5cbiAgICAgIGlmIChlc2NhcGVkKSB7XG4gICAgICAgIC8vIG9kZCBudW1iZXIgb2Ygc2xhc2hlcyBtZWFucyB8IGlzIGVzY2FwZWRcbiAgICAgICAgLy8gc28gd2UgbGVhdmUgaXQgYWxvbmVcbiAgICAgICAgcmV0dXJuICd8JztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGFkZCBzcGFjZSBiZWZvcmUgdW5lc2NhcGVkIHxcbiAgICAgICAgcmV0dXJuICcgfCc7XG4gICAgICB9XG4gICAgfSksXG4gICAgICAgIGNlbGxzID0gcm93LnNwbGl0KC8gXFx8Lyk7XG4gICAgdmFyIGkgPSAwOyAvLyBGaXJzdC9sYXN0IGNlbGwgaW4gYSByb3cgY2Fubm90IGJlIGVtcHR5IGlmIGl0IGhhcyBubyBsZWFkaW5nL3RyYWlsaW5nIHBpcGVcblxuICAgIGlmICghY2VsbHNbMF0udHJpbSgpKSB7XG4gICAgICBjZWxscy5zaGlmdCgpO1xuICAgIH1cblxuICAgIGlmICghY2VsbHNbY2VsbHMubGVuZ3RoIC0gMV0udHJpbSgpKSB7XG4gICAgICBjZWxscy5wb3AoKTtcbiAgICB9XG5cbiAgICBpZiAoY2VsbHMubGVuZ3RoID4gY291bnQpIHtcbiAgICAgIGNlbGxzLnNwbGljZShjb3VudCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHdoaWxlIChjZWxscy5sZW5ndGggPCBjb3VudCkge1xuICAgICAgICBjZWxscy5wdXNoKCcnKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKDsgaSA8IGNlbGxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAvLyBsZWFkaW5nIG9yIHRyYWlsaW5nIHdoaXRlc3BhY2UgaXMgaWdub3JlZCBwZXIgdGhlIGdmbSBzcGVjXG4gICAgICBjZWxsc1tpXSA9IGNlbGxzW2ldLnRyaW0oKS5yZXBsYWNlKC9cXFxcXFx8L2csICd8Jyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNlbGxzO1xuICB9IC8vIFJlbW92ZSB0cmFpbGluZyAnYydzLiBFcXVpdmFsZW50IHRvIHN0ci5yZXBsYWNlKC9jKiQvLCAnJykuXG4gIC8vIC9jKiQvIGlzIHZ1bG5lcmFibGUgdG8gUkVET1MuXG4gIC8vIGludmVydDogUmVtb3ZlIHN1ZmZpeCBvZiBub24tYyBjaGFycyBpbnN0ZWFkLiBEZWZhdWx0IGZhbHNleS5cblxuXG4gIGZ1bmN0aW9uIHJ0cmltJDEoc3RyLCBjLCBpbnZlcnQpIHtcbiAgICB2YXIgbCA9IHN0ci5sZW5ndGg7XG5cbiAgICBpZiAobCA9PT0gMCkge1xuICAgICAgcmV0dXJuICcnO1xuICAgIH0gLy8gTGVuZ3RoIG9mIHN1ZmZpeCBtYXRjaGluZyB0aGUgaW52ZXJ0IGNvbmRpdGlvbi5cblxuXG4gICAgdmFyIHN1ZmZMZW4gPSAwOyAvLyBTdGVwIGxlZnQgdW50aWwgd2UgZmFpbCB0byBtYXRjaCB0aGUgaW52ZXJ0IGNvbmRpdGlvbi5cblxuICAgIHdoaWxlIChzdWZmTGVuIDwgbCkge1xuICAgICAgdmFyIGN1cnJDaGFyID0gc3RyLmNoYXJBdChsIC0gc3VmZkxlbiAtIDEpO1xuXG4gICAgICBpZiAoY3VyckNoYXIgPT09IGMgJiYgIWludmVydCkge1xuICAgICAgICBzdWZmTGVuKys7XG4gICAgICB9IGVsc2UgaWYgKGN1cnJDaGFyICE9PSBjICYmIGludmVydCkge1xuICAgICAgICBzdWZmTGVuKys7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gc3RyLnN1YnN0cigwLCBsIC0gc3VmZkxlbik7XG4gIH1cblxuICBmdW5jdGlvbiBmaW5kQ2xvc2luZ0JyYWNrZXQkMShzdHIsIGIpIHtcbiAgICBpZiAoc3RyLmluZGV4T2YoYlsxXSkgPT09IC0xKSB7XG4gICAgICByZXR1cm4gLTE7XG4gICAgfVxuXG4gICAgdmFyIGwgPSBzdHIubGVuZ3RoO1xuICAgIHZhciBsZXZlbCA9IDAsXG4gICAgICAgIGkgPSAwO1xuXG4gICAgZm9yICg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGlmIChzdHJbaV0gPT09ICdcXFxcJykge1xuICAgICAgICBpKys7XG4gICAgICB9IGVsc2UgaWYgKHN0cltpXSA9PT0gYlswXSkge1xuICAgICAgICBsZXZlbCsrO1xuICAgICAgfSBlbHNlIGlmIChzdHJbaV0gPT09IGJbMV0pIHtcbiAgICAgICAgbGV2ZWwtLTtcblxuICAgICAgICBpZiAobGV2ZWwgPCAwKSB7XG4gICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gLTE7XG4gIH1cblxuICBmdW5jdGlvbiBjaGVja1Nhbml0aXplRGVwcmVjYXRpb24kMShvcHQpIHtcbiAgICBpZiAob3B0ICYmIG9wdC5zYW5pdGl6ZSAmJiAhb3B0LnNpbGVudCkge1xuICAgICAgY29uc29sZS53YXJuKCdtYXJrZWQoKTogc2FuaXRpemUgYW5kIHNhbml0aXplciBwYXJhbWV0ZXJzIGFyZSBkZXByZWNhdGVkIHNpbmNlIHZlcnNpb24gMC43LjAsIHNob3VsZCBub3QgYmUgdXNlZCBhbmQgd2lsbCBiZSByZW1vdmVkIGluIHRoZSBmdXR1cmUuIFJlYWQgbW9yZSBoZXJlOiBodHRwczovL21hcmtlZC5qcy5vcmcvIy9VU0lOR19BRFZBTkNFRC5tZCNvcHRpb25zJyk7XG4gICAgfVxuICB9IC8vIGNvcGllZCBmcm9tIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS81NDUwMTEzLzgwNjc3N1xuXG5cbiAgZnVuY3Rpb24gcmVwZWF0U3RyaW5nJDEocGF0dGVybiwgY291bnQpIHtcbiAgICBpZiAoY291bnQgPCAxKSB7XG4gICAgICByZXR1cm4gJyc7XG4gICAgfVxuXG4gICAgdmFyIHJlc3VsdCA9ICcnO1xuXG4gICAgd2hpbGUgKGNvdW50ID4gMSkge1xuICAgICAgaWYgKGNvdW50ICYgMSkge1xuICAgICAgICByZXN1bHQgKz0gcGF0dGVybjtcbiAgICAgIH1cblxuICAgICAgY291bnQgPj49IDE7XG4gICAgICBwYXR0ZXJuICs9IHBhdHRlcm47XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdCArIHBhdHRlcm47XG4gIH1cblxuICB2YXIgaGVscGVycyA9IHtcbiAgICBlc2NhcGU6IGVzY2FwZSQyLFxuICAgIHVuZXNjYXBlOiB1bmVzY2FwZSQxLFxuICAgIGVkaXQ6IGVkaXQkMSxcbiAgICBjbGVhblVybDogY2xlYW5VcmwkMSxcbiAgICByZXNvbHZlVXJsOiByZXNvbHZlVXJsLFxuICAgIG5vb3BUZXN0OiBub29wVGVzdCQxLFxuICAgIG1lcmdlOiBtZXJnZSQyLFxuICAgIHNwbGl0Q2VsbHM6IHNwbGl0Q2VsbHMkMSxcbiAgICBydHJpbTogcnRyaW0kMSxcbiAgICBmaW5kQ2xvc2luZ0JyYWNrZXQ6IGZpbmRDbG9zaW5nQnJhY2tldCQxLFxuICAgIGNoZWNrU2FuaXRpemVEZXByZWNhdGlvbjogY2hlY2tTYW5pdGl6ZURlcHJlY2F0aW9uJDEsXG4gICAgcmVwZWF0U3RyaW5nOiByZXBlYXRTdHJpbmckMVxuICB9O1xuXG4gIHZhciBkZWZhdWx0cyQ0ID0gZGVmYXVsdHMkNS5leHBvcnRzLmRlZmF1bHRzO1xuICB2YXIgcnRyaW0gPSBoZWxwZXJzLnJ0cmltLFxuICAgICAgc3BsaXRDZWxscyA9IGhlbHBlcnMuc3BsaXRDZWxscyxcbiAgICAgIF9lc2NhcGUgPSBoZWxwZXJzLmVzY2FwZSxcbiAgICAgIGZpbmRDbG9zaW5nQnJhY2tldCA9IGhlbHBlcnMuZmluZENsb3NpbmdCcmFja2V0O1xuXG4gIGZ1bmN0aW9uIG91dHB1dExpbmsoY2FwLCBsaW5rLCByYXcsIGxleGVyKSB7XG4gICAgdmFyIGhyZWYgPSBsaW5rLmhyZWY7XG4gICAgdmFyIHRpdGxlID0gbGluay50aXRsZSA/IF9lc2NhcGUobGluay50aXRsZSkgOiBudWxsO1xuICAgIHZhciB0ZXh0ID0gY2FwWzFdLnJlcGxhY2UoL1xcXFwoW1xcW1xcXV0pL2csICckMScpO1xuXG4gICAgaWYgKGNhcFswXS5jaGFyQXQoMCkgIT09ICchJykge1xuICAgICAgbGV4ZXIuc3RhdGUuaW5MaW5rID0gdHJ1ZTtcbiAgICAgIHZhciB0b2tlbiA9IHtcbiAgICAgICAgdHlwZTogJ2xpbmsnLFxuICAgICAgICByYXc6IHJhdyxcbiAgICAgICAgaHJlZjogaHJlZixcbiAgICAgICAgdGl0bGU6IHRpdGxlLFxuICAgICAgICB0ZXh0OiB0ZXh0LFxuICAgICAgICB0b2tlbnM6IGxleGVyLmlubGluZVRva2Vucyh0ZXh0LCBbXSlcbiAgICAgIH07XG4gICAgICBsZXhlci5zdGF0ZS5pbkxpbmsgPSBmYWxzZTtcbiAgICAgIHJldHVybiB0b2tlbjtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogJ2ltYWdlJyxcbiAgICAgICAgcmF3OiByYXcsXG4gICAgICAgIGhyZWY6IGhyZWYsXG4gICAgICAgIHRpdGxlOiB0aXRsZSxcbiAgICAgICAgdGV4dDogX2VzY2FwZSh0ZXh0KVxuICAgICAgfTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpbmRlbnRDb2RlQ29tcGVuc2F0aW9uKHJhdywgdGV4dCkge1xuICAgIHZhciBtYXRjaEluZGVudFRvQ29kZSA9IHJhdy5tYXRjaCgvXihcXHMrKSg/OmBgYCkvKTtcblxuICAgIGlmIChtYXRjaEluZGVudFRvQ29kZSA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHRleHQ7XG4gICAgfVxuXG4gICAgdmFyIGluZGVudFRvQ29kZSA9IG1hdGNoSW5kZW50VG9Db2RlWzFdO1xuICAgIHJldHVybiB0ZXh0LnNwbGl0KCdcXG4nKS5tYXAoZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgIHZhciBtYXRjaEluZGVudEluTm9kZSA9IG5vZGUubWF0Y2goL15cXHMrLyk7XG5cbiAgICAgIGlmIChtYXRjaEluZGVudEluTm9kZSA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgIH1cblxuICAgICAgdmFyIGluZGVudEluTm9kZSA9IG1hdGNoSW5kZW50SW5Ob2RlWzBdO1xuXG4gICAgICBpZiAoaW5kZW50SW5Ob2RlLmxlbmd0aCA+PSBpbmRlbnRUb0NvZGUubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBub2RlLnNsaWNlKGluZGVudFRvQ29kZS5sZW5ndGgpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbm9kZTtcbiAgICB9KS5qb2luKCdcXG4nKTtcbiAgfVxuICAvKipcbiAgICogVG9rZW5pemVyXG4gICAqL1xuXG5cbiAgdmFyIFRva2VuaXplcl8xID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBUb2tlbml6ZXIob3B0aW9ucykge1xuICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucyB8fCBkZWZhdWx0cyQ0O1xuICAgIH1cblxuICAgIHZhciBfcHJvdG8gPSBUb2tlbml6ZXIucHJvdG90eXBlO1xuXG4gICAgX3Byb3RvLnNwYWNlID0gZnVuY3Rpb24gc3BhY2Uoc3JjKSB7XG4gICAgICB2YXIgY2FwID0gdGhpcy5ydWxlcy5ibG9jay5uZXdsaW5lLmV4ZWMoc3JjKTtcblxuICAgICAgaWYgKGNhcCkge1xuICAgICAgICBpZiAoY2FwWzBdLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogJ3NwYWNlJyxcbiAgICAgICAgICAgIHJhdzogY2FwWzBdXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgcmF3OiAnXFxuJ1xuICAgICAgICB9O1xuICAgICAgfVxuICAgIH07XG5cbiAgICBfcHJvdG8uY29kZSA9IGZ1bmN0aW9uIGNvZGUoc3JjKSB7XG4gICAgICB2YXIgY2FwID0gdGhpcy5ydWxlcy5ibG9jay5jb2RlLmV4ZWMoc3JjKTtcblxuICAgICAgaWYgKGNhcCkge1xuICAgICAgICB2YXIgdGV4dCA9IGNhcFswXS5yZXBsYWNlKC9eIHsxLDR9L2dtLCAnJyk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdHlwZTogJ2NvZGUnLFxuICAgICAgICAgIHJhdzogY2FwWzBdLFxuICAgICAgICAgIGNvZGVCbG9ja1N0eWxlOiAnaW5kZW50ZWQnLFxuICAgICAgICAgIHRleHQ6ICF0aGlzLm9wdGlvbnMucGVkYW50aWMgPyBydHJpbSh0ZXh0LCAnXFxuJykgOiB0ZXh0XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfTtcblxuICAgIF9wcm90by5mZW5jZXMgPSBmdW5jdGlvbiBmZW5jZXMoc3JjKSB7XG4gICAgICB2YXIgY2FwID0gdGhpcy5ydWxlcy5ibG9jay5mZW5jZXMuZXhlYyhzcmMpO1xuXG4gICAgICBpZiAoY2FwKSB7XG4gICAgICAgIHZhciByYXcgPSBjYXBbMF07XG4gICAgICAgIHZhciB0ZXh0ID0gaW5kZW50Q29kZUNvbXBlbnNhdGlvbihyYXcsIGNhcFszXSB8fCAnJyk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdHlwZTogJ2NvZGUnLFxuICAgICAgICAgIHJhdzogcmF3LFxuICAgICAgICAgIGxhbmc6IGNhcFsyXSA/IGNhcFsyXS50cmltKCkgOiBjYXBbMl0sXG4gICAgICAgICAgdGV4dDogdGV4dFxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH07XG5cbiAgICBfcHJvdG8uaGVhZGluZyA9IGZ1bmN0aW9uIGhlYWRpbmcoc3JjKSB7XG4gICAgICB2YXIgY2FwID0gdGhpcy5ydWxlcy5ibG9jay5oZWFkaW5nLmV4ZWMoc3JjKTtcblxuICAgICAgaWYgKGNhcCkge1xuICAgICAgICB2YXIgdGV4dCA9IGNhcFsyXS50cmltKCk7IC8vIHJlbW92ZSB0cmFpbGluZyAjc1xuXG4gICAgICAgIGlmICgvIyQvLnRlc3QodGV4dCkpIHtcbiAgICAgICAgICB2YXIgdHJpbW1lZCA9IHJ0cmltKHRleHQsICcjJyk7XG5cbiAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLnBlZGFudGljKSB7XG4gICAgICAgICAgICB0ZXh0ID0gdHJpbW1lZC50cmltKCk7XG4gICAgICAgICAgfSBlbHNlIGlmICghdHJpbW1lZCB8fCAvICQvLnRlc3QodHJpbW1lZCkpIHtcbiAgICAgICAgICAgIC8vIENvbW1vbk1hcmsgcmVxdWlyZXMgc3BhY2UgYmVmb3JlIHRyYWlsaW5nICNzXG4gICAgICAgICAgICB0ZXh0ID0gdHJpbW1lZC50cmltKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHRva2VuID0ge1xuICAgICAgICAgIHR5cGU6ICdoZWFkaW5nJyxcbiAgICAgICAgICByYXc6IGNhcFswXSxcbiAgICAgICAgICBkZXB0aDogY2FwWzFdLmxlbmd0aCxcbiAgICAgICAgICB0ZXh0OiB0ZXh0LFxuICAgICAgICAgIHRva2VuczogW11cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5sZXhlci5pbmxpbmUodG9rZW4udGV4dCwgdG9rZW4udG9rZW5zKTtcbiAgICAgICAgcmV0dXJuIHRva2VuO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBfcHJvdG8uaHIgPSBmdW5jdGlvbiBocihzcmMpIHtcbiAgICAgIHZhciBjYXAgPSB0aGlzLnJ1bGVzLmJsb2NrLmhyLmV4ZWMoc3JjKTtcblxuICAgICAgaWYgKGNhcCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHR5cGU6ICdocicsXG4gICAgICAgICAgcmF3OiBjYXBbMF1cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgX3Byb3RvLmJsb2NrcXVvdGUgPSBmdW5jdGlvbiBibG9ja3F1b3RlKHNyYykge1xuICAgICAgdmFyIGNhcCA9IHRoaXMucnVsZXMuYmxvY2suYmxvY2txdW90ZS5leGVjKHNyYyk7XG5cbiAgICAgIGlmIChjYXApIHtcbiAgICAgICAgdmFyIHRleHQgPSBjYXBbMF0ucmVwbGFjZSgvXiAqPiA/L2dtLCAnJyk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdHlwZTogJ2Jsb2NrcXVvdGUnLFxuICAgICAgICAgIHJhdzogY2FwWzBdLFxuICAgICAgICAgIHRva2VuczogdGhpcy5sZXhlci5ibG9ja1Rva2Vucyh0ZXh0LCBbXSksXG4gICAgICAgICAgdGV4dDogdGV4dFxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH07XG5cbiAgICBfcHJvdG8ubGlzdCA9IGZ1bmN0aW9uIGxpc3Qoc3JjKSB7XG4gICAgICB2YXIgY2FwID0gdGhpcy5ydWxlcy5ibG9jay5saXN0LmV4ZWMoc3JjKTtcblxuICAgICAgaWYgKGNhcCkge1xuICAgICAgICB2YXIgcmF3LCBpc3Rhc2ssIGlzY2hlY2tlZCwgaW5kZW50LCBpLCBibGFua0xpbmUsIGVuZHNXaXRoQmxhbmtMaW5lLCBsaW5lLCBsaW5lcywgaXRlbUNvbnRlbnRzO1xuICAgICAgICB2YXIgYnVsbCA9IGNhcFsxXS50cmltKCk7XG4gICAgICAgIHZhciBpc29yZGVyZWQgPSBidWxsLmxlbmd0aCA+IDE7XG4gICAgICAgIHZhciBsaXN0ID0ge1xuICAgICAgICAgIHR5cGU6ICdsaXN0JyxcbiAgICAgICAgICByYXc6ICcnLFxuICAgICAgICAgIG9yZGVyZWQ6IGlzb3JkZXJlZCxcbiAgICAgICAgICBzdGFydDogaXNvcmRlcmVkID8gK2J1bGwuc2xpY2UoMCwgLTEpIDogJycsXG4gICAgICAgICAgbG9vc2U6IGZhbHNlLFxuICAgICAgICAgIGl0ZW1zOiBbXVxuICAgICAgICB9O1xuICAgICAgICBidWxsID0gaXNvcmRlcmVkID8gXCJcXFxcZHsxLDl9XFxcXFwiICsgYnVsbC5zbGljZSgtMSkgOiBcIlxcXFxcIiArIGJ1bGw7XG5cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5wZWRhbnRpYykge1xuICAgICAgICAgIGJ1bGwgPSBpc29yZGVyZWQgPyBidWxsIDogJ1sqKy1dJztcbiAgICAgICAgfSAvLyBHZXQgbmV4dCBsaXN0IGl0ZW1cblxuXG4gICAgICAgIHZhciBpdGVtUmVnZXggPSBuZXcgUmVnRXhwKFwiXiggezAsM31cIiArIGJ1bGwgKyBcIikoKD86IFteXFxcXG5dKnwgKikoPzpcXFxcblteXFxcXG5dKikqKD86XFxcXG58JCkpXCIpOyAvLyBHZXQgZWFjaCB0b3AtbGV2ZWwgaXRlbVxuXG4gICAgICAgIHdoaWxlIChzcmMpIHtcbiAgICAgICAgICBpZiAodGhpcy5ydWxlcy5ibG9jay5oci50ZXN0KHNyYykpIHtcbiAgICAgICAgICAgIC8vIEVuZCBsaXN0IGlmIHdlIGVuY291bnRlciBhbiBIUiAocG9zc2libHkgbW92ZSBpbnRvIGl0ZW1SZWdleD8pXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoIShjYXAgPSBpdGVtUmVnZXguZXhlYyhzcmMpKSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbGluZXMgPSBjYXBbMl0uc3BsaXQoJ1xcbicpO1xuXG4gICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5wZWRhbnRpYykge1xuICAgICAgICAgICAgaW5kZW50ID0gMjtcbiAgICAgICAgICAgIGl0ZW1Db250ZW50cyA9IGxpbmVzWzBdLnRyaW1MZWZ0KCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGluZGVudCA9IGNhcFsyXS5zZWFyY2goL1teIF0vKTsgLy8gRmluZCBmaXJzdCBub24tc3BhY2UgY2hhclxuXG4gICAgICAgICAgICBpbmRlbnQgPSBjYXBbMV0ubGVuZ3RoICsgKGluZGVudCA+IDQgPyAxIDogaW5kZW50KTsgLy8gaW50ZW50ZWQgY29kZSBibG9ja3MgYWZ0ZXIgNCBzcGFjZXM7IGluZGVudCBpcyBhbHdheXMgMVxuXG4gICAgICAgICAgICBpdGVtQ29udGVudHMgPSBsaW5lc1swXS5zbGljZShpbmRlbnQgLSBjYXBbMV0ubGVuZ3RoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBibGFua0xpbmUgPSBmYWxzZTtcbiAgICAgICAgICByYXcgPSBjYXBbMF07XG5cbiAgICAgICAgICBpZiAoIWxpbmVzWzBdICYmIC9eICokLy50ZXN0KGxpbmVzWzFdKSkge1xuICAgICAgICAgICAgLy8gaXRlbXMgYmVnaW4gd2l0aCBhdCBtb3N0IG9uZSBibGFuayBsaW5lXG4gICAgICAgICAgICByYXcgPSBjYXBbMV0gKyBsaW5lcy5zbGljZSgwLCAyKS5qb2luKCdcXG4nKSArICdcXG4nO1xuICAgICAgICAgICAgbGlzdC5sb29zZSA9IHRydWU7XG4gICAgICAgICAgICBsaW5lcyA9IFtdO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBuZXh0QnVsbGV0UmVnZXggPSBuZXcgUmVnRXhwKFwiXiB7MCxcIiArIE1hdGgubWluKDMsIGluZGVudCAtIDEpICsgXCJ9KD86WyorLV18XFxcXGR7MSw5fVsuKV0pXCIpO1xuXG4gICAgICAgICAgZm9yIChpID0gMTsgaSA8IGxpbmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsaW5lID0gbGluZXNbaV07XG5cbiAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMucGVkYW50aWMpIHtcbiAgICAgICAgICAgICAgLy8gUmUtYWxpZ24gdG8gZm9sbG93IGNvbW1vbm1hcmsgbmVzdGluZyBydWxlc1xuICAgICAgICAgICAgICBsaW5lID0gbGluZS5yZXBsYWNlKC9eIHsxLDR9KD89KCB7NH0pKlteIF0pL2csICcgICcpO1xuICAgICAgICAgICAgfSAvLyBFbmQgbGlzdCBpdGVtIGlmIGZvdW5kIHN0YXJ0IG9mIG5ldyBidWxsZXRcblxuXG4gICAgICAgICAgICBpZiAobmV4dEJ1bGxldFJlZ2V4LnRlc3QobGluZSkpIHtcbiAgICAgICAgICAgICAgcmF3ID0gY2FwWzFdICsgbGluZXMuc2xpY2UoMCwgaSkuam9pbignXFxuJykgKyAnXFxuJztcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9IC8vIFVudGlsIHdlIGVuY291bnRlciBhIGJsYW5rIGxpbmUsIGl0ZW0gY29udGVudHMgZG8gbm90IG5lZWQgaW5kZW50YXRpb25cblxuXG4gICAgICAgICAgICBpZiAoIWJsYW5rTGluZSkge1xuICAgICAgICAgICAgICBpZiAoIWxpbmUudHJpbSgpKSB7XG4gICAgICAgICAgICAgICAgLy8gQ2hlY2sgaWYgY3VycmVudCBsaW5lIGlzIGVtcHR5XG4gICAgICAgICAgICAgICAgYmxhbmtMaW5lID0gdHJ1ZTtcbiAgICAgICAgICAgICAgfSAvLyBEZWRlbnQgaWYgcG9zc2libGVcblxuXG4gICAgICAgICAgICAgIGlmIChsaW5lLnNlYXJjaCgvW14gXS8pID49IGluZGVudCkge1xuICAgICAgICAgICAgICAgIGl0ZW1Db250ZW50cyArPSAnXFxuJyArIGxpbmUuc2xpY2UoaW5kZW50KTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpdGVtQ29udGVudHMgKz0gJ1xcbicgKyBsaW5lO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9IC8vIERlZGVudCB0aGlzIGxpbmVcblxuXG4gICAgICAgICAgICBpZiAobGluZS5zZWFyY2goL1teIF0vKSA+PSBpbmRlbnQgfHwgIWxpbmUudHJpbSgpKSB7XG4gICAgICAgICAgICAgIGl0ZW1Db250ZW50cyArPSAnXFxuJyArIGxpbmUuc2xpY2UoaW5kZW50KTtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyBMaW5lIHdhcyBub3QgcHJvcGVybHkgaW5kZW50ZWQ7IGVuZCBvZiB0aGlzIGl0ZW1cbiAgICAgICAgICAgICAgcmF3ID0gY2FwWzFdICsgbGluZXMuc2xpY2UoMCwgaSkuam9pbignXFxuJykgKyAnXFxuJztcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKCFsaXN0Lmxvb3NlKSB7XG4gICAgICAgICAgICAvLyBJZiB0aGUgcHJldmlvdXMgaXRlbSBlbmRlZCB3aXRoIGEgYmxhbmsgbGluZSwgdGhlIGxpc3QgaXMgbG9vc2VcbiAgICAgICAgICAgIGlmIChlbmRzV2l0aEJsYW5rTGluZSkge1xuICAgICAgICAgICAgICBsaXN0Lmxvb3NlID0gdHJ1ZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoL1xcbiAqXFxuICokLy50ZXN0KHJhdykpIHtcbiAgICAgICAgICAgICAgZW5kc1dpdGhCbGFua0xpbmUgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gLy8gQ2hlY2sgZm9yIHRhc2sgbGlzdCBpdGVtc1xuXG5cbiAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLmdmbSkge1xuICAgICAgICAgICAgaXN0YXNrID0gL15cXFtbIHhYXVxcXSAvLmV4ZWMoaXRlbUNvbnRlbnRzKTtcblxuICAgICAgICAgICAgaWYgKGlzdGFzaykge1xuICAgICAgICAgICAgICBpc2NoZWNrZWQgPSBpc3Rhc2tbMF0gIT09ICdbIF0gJztcbiAgICAgICAgICAgICAgaXRlbUNvbnRlbnRzID0gaXRlbUNvbnRlbnRzLnJlcGxhY2UoL15cXFtbIHhYXVxcXSArLywgJycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGxpc3QuaXRlbXMucHVzaCh7XG4gICAgICAgICAgICB0eXBlOiAnbGlzdF9pdGVtJyxcbiAgICAgICAgICAgIHJhdzogcmF3LFxuICAgICAgICAgICAgdGFzazogISFpc3Rhc2ssXG4gICAgICAgICAgICBjaGVja2VkOiBpc2NoZWNrZWQsXG4gICAgICAgICAgICBsb29zZTogZmFsc2UsXG4gICAgICAgICAgICB0ZXh0OiBpdGVtQ29udGVudHNcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBsaXN0LnJhdyArPSByYXc7XG4gICAgICAgICAgc3JjID0gc3JjLnNsaWNlKHJhdy5sZW5ndGgpO1xuICAgICAgICB9IC8vIERvIG5vdCBjb25zdW1lIG5ld2xpbmVzIGF0IGVuZCBvZiBmaW5hbCBpdGVtLiBBbHRlcm5hdGl2ZWx5LCBtYWtlIGl0ZW1SZWdleCAqc3RhcnQqIHdpdGggYW55IG5ld2xpbmVzIHRvIHNpbXBsaWZ5L3NwZWVkIHVwIGVuZHNXaXRoQmxhbmtMaW5lIGxvZ2ljXG5cblxuICAgICAgICBsaXN0Lml0ZW1zW2xpc3QuaXRlbXMubGVuZ3RoIC0gMV0ucmF3ID0gcmF3LnRyaW1SaWdodCgpO1xuICAgICAgICBsaXN0Lml0ZW1zW2xpc3QuaXRlbXMubGVuZ3RoIC0gMV0udGV4dCA9IGl0ZW1Db250ZW50cy50cmltUmlnaHQoKTtcbiAgICAgICAgbGlzdC5yYXcgPSBsaXN0LnJhdy50cmltUmlnaHQoKTtcbiAgICAgICAgdmFyIGwgPSBsaXN0Lml0ZW1zLmxlbmd0aDsgLy8gSXRlbSBjaGlsZCB0b2tlbnMgaGFuZGxlZCBoZXJlIGF0IGVuZCBiZWNhdXNlIHdlIG5lZWRlZCB0byBoYXZlIHRoZSBmaW5hbCBpdGVtIHRvIHRyaW0gaXQgZmlyc3RcblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgdGhpcy5sZXhlci5zdGF0ZS50b3AgPSBmYWxzZTtcbiAgICAgICAgICBsaXN0Lml0ZW1zW2ldLnRva2VucyA9IHRoaXMubGV4ZXIuYmxvY2tUb2tlbnMobGlzdC5pdGVtc1tpXS50ZXh0LCBbXSk7XG5cbiAgICAgICAgICBpZiAobGlzdC5pdGVtc1tpXS50b2tlbnMuc29tZShmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgcmV0dXJuIHQudHlwZSA9PT0gJ3NwYWNlJztcbiAgICAgICAgICB9KSkge1xuICAgICAgICAgICAgbGlzdC5sb29zZSA9IHRydWU7XG4gICAgICAgICAgICBsaXN0Lml0ZW1zW2ldLmxvb3NlID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbGlzdDtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgX3Byb3RvLmh0bWwgPSBmdW5jdGlvbiBodG1sKHNyYykge1xuICAgICAgdmFyIGNhcCA9IHRoaXMucnVsZXMuYmxvY2suaHRtbC5leGVjKHNyYyk7XG5cbiAgICAgIGlmIChjYXApIHtcbiAgICAgICAgdmFyIHRva2VuID0ge1xuICAgICAgICAgIHR5cGU6ICdodG1sJyxcbiAgICAgICAgICByYXc6IGNhcFswXSxcbiAgICAgICAgICBwcmU6ICF0aGlzLm9wdGlvbnMuc2FuaXRpemVyICYmIChjYXBbMV0gPT09ICdwcmUnIHx8IGNhcFsxXSA9PT0gJ3NjcmlwdCcgfHwgY2FwWzFdID09PSAnc3R5bGUnKSxcbiAgICAgICAgICB0ZXh0OiBjYXBbMF1cbiAgICAgICAgfTtcblxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnNhbml0aXplKSB7XG4gICAgICAgICAgdG9rZW4udHlwZSA9ICdwYXJhZ3JhcGgnO1xuICAgICAgICAgIHRva2VuLnRleHQgPSB0aGlzLm9wdGlvbnMuc2FuaXRpemVyID8gdGhpcy5vcHRpb25zLnNhbml0aXplcihjYXBbMF0pIDogX2VzY2FwZShjYXBbMF0pO1xuICAgICAgICAgIHRva2VuLnRva2VucyA9IFtdO1xuICAgICAgICAgIHRoaXMubGV4ZXIuaW5saW5lKHRva2VuLnRleHQsIHRva2VuLnRva2Vucyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdG9rZW47XG4gICAgICB9XG4gICAgfTtcblxuICAgIF9wcm90by5kZWYgPSBmdW5jdGlvbiBkZWYoc3JjKSB7XG4gICAgICB2YXIgY2FwID0gdGhpcy5ydWxlcy5ibG9jay5kZWYuZXhlYyhzcmMpO1xuXG4gICAgICBpZiAoY2FwKSB7XG4gICAgICAgIGlmIChjYXBbM10pIGNhcFszXSA9IGNhcFszXS5zdWJzdHJpbmcoMSwgY2FwWzNdLmxlbmd0aCAtIDEpO1xuICAgICAgICB2YXIgdGFnID0gY2FwWzFdLnRvTG93ZXJDYXNlKCkucmVwbGFjZSgvXFxzKy9nLCAnICcpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHR5cGU6ICdkZWYnLFxuICAgICAgICAgIHRhZzogdGFnLFxuICAgICAgICAgIHJhdzogY2FwWzBdLFxuICAgICAgICAgIGhyZWY6IGNhcFsyXSxcbiAgICAgICAgICB0aXRsZTogY2FwWzNdXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfTtcblxuICAgIF9wcm90by50YWJsZSA9IGZ1bmN0aW9uIHRhYmxlKHNyYykge1xuICAgICAgdmFyIGNhcCA9IHRoaXMucnVsZXMuYmxvY2sudGFibGUuZXhlYyhzcmMpO1xuXG4gICAgICBpZiAoY2FwKSB7XG4gICAgICAgIHZhciBpdGVtID0ge1xuICAgICAgICAgIHR5cGU6ICd0YWJsZScsXG4gICAgICAgICAgaGVhZGVyOiBzcGxpdENlbGxzKGNhcFsxXSkubWFwKGZ1bmN0aW9uIChjKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICB0ZXh0OiBjXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH0pLFxuICAgICAgICAgIGFsaWduOiBjYXBbMl0ucmVwbGFjZSgvXiAqfFxcfCAqJC9nLCAnJykuc3BsaXQoLyAqXFx8ICovKSxcbiAgICAgICAgICByb3dzOiBjYXBbM10gPyBjYXBbM10ucmVwbGFjZSgvXFxuJC8sICcnKS5zcGxpdCgnXFxuJykgOiBbXVxuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChpdGVtLmhlYWRlci5sZW5ndGggPT09IGl0ZW0uYWxpZ24ubGVuZ3RoKSB7XG4gICAgICAgICAgaXRlbS5yYXcgPSBjYXBbMF07XG4gICAgICAgICAgdmFyIGwgPSBpdGVtLmFsaWduLmxlbmd0aDtcbiAgICAgICAgICB2YXIgaSwgaiwgaywgcm93O1xuXG4gICAgICAgICAgZm9yIChpID0gMDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgaWYgKC9eICotKzogKiQvLnRlc3QoaXRlbS5hbGlnbltpXSkpIHtcbiAgICAgICAgICAgICAgaXRlbS5hbGlnbltpXSA9ICdyaWdodCc7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKC9eICo6LSs6ICokLy50ZXN0KGl0ZW0uYWxpZ25baV0pKSB7XG4gICAgICAgICAgICAgIGl0ZW0uYWxpZ25baV0gPSAnY2VudGVyJztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoL14gKjotKyAqJC8udGVzdChpdGVtLmFsaWduW2ldKSkge1xuICAgICAgICAgICAgICBpdGVtLmFsaWduW2ldID0gJ2xlZnQnO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgaXRlbS5hbGlnbltpXSA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbCA9IGl0ZW0ucm93cy5sZW5ndGg7XG5cbiAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICBpdGVtLnJvd3NbaV0gPSBzcGxpdENlbGxzKGl0ZW0ucm93c1tpXSwgaXRlbS5oZWFkZXIubGVuZ3RoKS5tYXAoZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0ZXh0OiBjXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IC8vIHBhcnNlIGNoaWxkIHRva2VucyBpbnNpZGUgaGVhZGVycyBhbmQgY2VsbHNcbiAgICAgICAgICAvLyBoZWFkZXIgY2hpbGQgdG9rZW5zXG5cblxuICAgICAgICAgIGwgPSBpdGVtLmhlYWRlci5sZW5ndGg7XG5cbiAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgbDsgaisrKSB7XG4gICAgICAgICAgICBpdGVtLmhlYWRlcltqXS50b2tlbnMgPSBbXTtcbiAgICAgICAgICAgIHRoaXMubGV4ZXIuaW5saW5lVG9rZW5zKGl0ZW0uaGVhZGVyW2pdLnRleHQsIGl0ZW0uaGVhZGVyW2pdLnRva2Vucyk7XG4gICAgICAgICAgfSAvLyBjZWxsIGNoaWxkIHRva2Vuc1xuXG5cbiAgICAgICAgICBsID0gaXRlbS5yb3dzLmxlbmd0aDtcblxuICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBsOyBqKyspIHtcbiAgICAgICAgICAgIHJvdyA9IGl0ZW0ucm93c1tqXTtcblxuICAgICAgICAgICAgZm9yIChrID0gMDsgayA8IHJvdy5sZW5ndGg7IGsrKykge1xuICAgICAgICAgICAgICByb3dba10udG9rZW5zID0gW107XG4gICAgICAgICAgICAgIHRoaXMubGV4ZXIuaW5saW5lVG9rZW5zKHJvd1trXS50ZXh0LCByb3dba10udG9rZW5zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gaXRlbTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICBfcHJvdG8ubGhlYWRpbmcgPSBmdW5jdGlvbiBsaGVhZGluZyhzcmMpIHtcbiAgICAgIHZhciBjYXAgPSB0aGlzLnJ1bGVzLmJsb2NrLmxoZWFkaW5nLmV4ZWMoc3JjKTtcblxuICAgICAgaWYgKGNhcCkge1xuICAgICAgICB2YXIgdG9rZW4gPSB7XG4gICAgICAgICAgdHlwZTogJ2hlYWRpbmcnLFxuICAgICAgICAgIHJhdzogY2FwWzBdLFxuICAgICAgICAgIGRlcHRoOiBjYXBbMl0uY2hhckF0KDApID09PSAnPScgPyAxIDogMixcbiAgICAgICAgICB0ZXh0OiBjYXBbMV0sXG4gICAgICAgICAgdG9rZW5zOiBbXVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmxleGVyLmlubGluZSh0b2tlbi50ZXh0LCB0b2tlbi50b2tlbnMpO1xuICAgICAgICByZXR1cm4gdG9rZW47XG4gICAgICB9XG4gICAgfTtcblxuICAgIF9wcm90by5wYXJhZ3JhcGggPSBmdW5jdGlvbiBwYXJhZ3JhcGgoc3JjKSB7XG4gICAgICB2YXIgY2FwID0gdGhpcy5ydWxlcy5ibG9jay5wYXJhZ3JhcGguZXhlYyhzcmMpO1xuXG4gICAgICBpZiAoY2FwKSB7XG4gICAgICAgIHZhciB0b2tlbiA9IHtcbiAgICAgICAgICB0eXBlOiAncGFyYWdyYXBoJyxcbiAgICAgICAgICByYXc6IGNhcFswXSxcbiAgICAgICAgICB0ZXh0OiBjYXBbMV0uY2hhckF0KGNhcFsxXS5sZW5ndGggLSAxKSA9PT0gJ1xcbicgPyBjYXBbMV0uc2xpY2UoMCwgLTEpIDogY2FwWzFdLFxuICAgICAgICAgIHRva2VuczogW11cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5sZXhlci5pbmxpbmUodG9rZW4udGV4dCwgdG9rZW4udG9rZW5zKTtcbiAgICAgICAgcmV0dXJuIHRva2VuO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBfcHJvdG8udGV4dCA9IGZ1bmN0aW9uIHRleHQoc3JjKSB7XG4gICAgICB2YXIgY2FwID0gdGhpcy5ydWxlcy5ibG9jay50ZXh0LmV4ZWMoc3JjKTtcblxuICAgICAgaWYgKGNhcCkge1xuICAgICAgICB2YXIgdG9rZW4gPSB7XG4gICAgICAgICAgdHlwZTogJ3RleHQnLFxuICAgICAgICAgIHJhdzogY2FwWzBdLFxuICAgICAgICAgIHRleHQ6IGNhcFswXSxcbiAgICAgICAgICB0b2tlbnM6IFtdXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMubGV4ZXIuaW5saW5lKHRva2VuLnRleHQsIHRva2VuLnRva2Vucyk7XG4gICAgICAgIHJldHVybiB0b2tlbjtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgX3Byb3RvLmVzY2FwZSA9IGZ1bmN0aW9uIGVzY2FwZShzcmMpIHtcbiAgICAgIHZhciBjYXAgPSB0aGlzLnJ1bGVzLmlubGluZS5lc2NhcGUuZXhlYyhzcmMpO1xuXG4gICAgICBpZiAoY2FwKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdHlwZTogJ2VzY2FwZScsXG4gICAgICAgICAgcmF3OiBjYXBbMF0sXG4gICAgICAgICAgdGV4dDogX2VzY2FwZShjYXBbMV0pXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfTtcblxuICAgIF9wcm90by50YWcgPSBmdW5jdGlvbiB0YWcoc3JjKSB7XG4gICAgICB2YXIgY2FwID0gdGhpcy5ydWxlcy5pbmxpbmUudGFnLmV4ZWMoc3JjKTtcblxuICAgICAgaWYgKGNhcCkge1xuICAgICAgICBpZiAoIXRoaXMubGV4ZXIuc3RhdGUuaW5MaW5rICYmIC9ePGEgL2kudGVzdChjYXBbMF0pKSB7XG4gICAgICAgICAgdGhpcy5sZXhlci5zdGF0ZS5pbkxpbmsgPSB0cnVlO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMubGV4ZXIuc3RhdGUuaW5MaW5rICYmIC9ePFxcL2E+L2kudGVzdChjYXBbMF0pKSB7XG4gICAgICAgICAgdGhpcy5sZXhlci5zdGF0ZS5pbkxpbmsgPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdGhpcy5sZXhlci5zdGF0ZS5pblJhd0Jsb2NrICYmIC9ePChwcmV8Y29kZXxrYmR8c2NyaXB0KShcXHN8PikvaS50ZXN0KGNhcFswXSkpIHtcbiAgICAgICAgICB0aGlzLmxleGVyLnN0YXRlLmluUmF3QmxvY2sgPSB0cnVlO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMubGV4ZXIuc3RhdGUuaW5SYXdCbG9jayAmJiAvXjxcXC8ocHJlfGNvZGV8a2JkfHNjcmlwdCkoXFxzfD4pL2kudGVzdChjYXBbMF0pKSB7XG4gICAgICAgICAgdGhpcy5sZXhlci5zdGF0ZS5pblJhd0Jsb2NrID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHR5cGU6IHRoaXMub3B0aW9ucy5zYW5pdGl6ZSA/ICd0ZXh0JyA6ICdodG1sJyxcbiAgICAgICAgICByYXc6IGNhcFswXSxcbiAgICAgICAgICBpbkxpbms6IHRoaXMubGV4ZXIuc3RhdGUuaW5MaW5rLFxuICAgICAgICAgIGluUmF3QmxvY2s6IHRoaXMubGV4ZXIuc3RhdGUuaW5SYXdCbG9jayxcbiAgICAgICAgICB0ZXh0OiB0aGlzLm9wdGlvbnMuc2FuaXRpemUgPyB0aGlzLm9wdGlvbnMuc2FuaXRpemVyID8gdGhpcy5vcHRpb25zLnNhbml0aXplcihjYXBbMF0pIDogX2VzY2FwZShjYXBbMF0pIDogY2FwWzBdXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfTtcblxuICAgIF9wcm90by5saW5rID0gZnVuY3Rpb24gbGluayhzcmMpIHtcbiAgICAgIHZhciBjYXAgPSB0aGlzLnJ1bGVzLmlubGluZS5saW5rLmV4ZWMoc3JjKTtcblxuICAgICAgaWYgKGNhcCkge1xuICAgICAgICB2YXIgdHJpbW1lZFVybCA9IGNhcFsyXS50cmltKCk7XG5cbiAgICAgICAgaWYgKCF0aGlzLm9wdGlvbnMucGVkYW50aWMgJiYgL148Ly50ZXN0KHRyaW1tZWRVcmwpKSB7XG4gICAgICAgICAgLy8gY29tbW9ubWFyayByZXF1aXJlcyBtYXRjaGluZyBhbmdsZSBicmFja2V0c1xuICAgICAgICAgIGlmICghLz4kLy50ZXN0KHRyaW1tZWRVcmwpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfSAvLyBlbmRpbmcgYW5nbGUgYnJhY2tldCBjYW5ub3QgYmUgZXNjYXBlZFxuXG5cbiAgICAgICAgICB2YXIgcnRyaW1TbGFzaCA9IHJ0cmltKHRyaW1tZWRVcmwuc2xpY2UoMCwgLTEpLCAnXFxcXCcpO1xuXG4gICAgICAgICAgaWYgKCh0cmltbWVkVXJsLmxlbmd0aCAtIHJ0cmltU2xhc2gubGVuZ3RoKSAlIDIgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gZmluZCBjbG9zaW5nIHBhcmVudGhlc2lzXG4gICAgICAgICAgdmFyIGxhc3RQYXJlbkluZGV4ID0gZmluZENsb3NpbmdCcmFja2V0KGNhcFsyXSwgJygpJyk7XG5cbiAgICAgICAgICBpZiAobGFzdFBhcmVuSW5kZXggPiAtMSkge1xuICAgICAgICAgICAgdmFyIHN0YXJ0ID0gY2FwWzBdLmluZGV4T2YoJyEnKSA9PT0gMCA/IDUgOiA0O1xuICAgICAgICAgICAgdmFyIGxpbmtMZW4gPSBzdGFydCArIGNhcFsxXS5sZW5ndGggKyBsYXN0UGFyZW5JbmRleDtcbiAgICAgICAgICAgIGNhcFsyXSA9IGNhcFsyXS5zdWJzdHJpbmcoMCwgbGFzdFBhcmVuSW5kZXgpO1xuICAgICAgICAgICAgY2FwWzBdID0gY2FwWzBdLnN1YnN0cmluZygwLCBsaW5rTGVuKS50cmltKCk7XG4gICAgICAgICAgICBjYXBbM10gPSAnJztcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaHJlZiA9IGNhcFsyXTtcbiAgICAgICAgdmFyIHRpdGxlID0gJyc7XG5cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5wZWRhbnRpYykge1xuICAgICAgICAgIC8vIHNwbGl0IHBlZGFudGljIGhyZWYgYW5kIHRpdGxlXG4gICAgICAgICAgdmFyIGxpbmsgPSAvXihbXidcIl0qW15cXHNdKVxccysoWydcIl0pKC4qKVxcMi8uZXhlYyhocmVmKTtcblxuICAgICAgICAgIGlmIChsaW5rKSB7XG4gICAgICAgICAgICBocmVmID0gbGlua1sxXTtcbiAgICAgICAgICAgIHRpdGxlID0gbGlua1szXTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGl0bGUgPSBjYXBbM10gPyBjYXBbM10uc2xpY2UoMSwgLTEpIDogJyc7XG4gICAgICAgIH1cblxuICAgICAgICBocmVmID0gaHJlZi50cmltKCk7XG5cbiAgICAgICAgaWYgKC9ePC8udGVzdChocmVmKSkge1xuICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMucGVkYW50aWMgJiYgIS8+JC8udGVzdCh0cmltbWVkVXJsKSkge1xuICAgICAgICAgICAgLy8gcGVkYW50aWMgYWxsb3dzIHN0YXJ0aW5nIGFuZ2xlIGJyYWNrZXQgd2l0aG91dCBlbmRpbmcgYW5nbGUgYnJhY2tldFxuICAgICAgICAgICAgaHJlZiA9IGhyZWYuc2xpY2UoMSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGhyZWYgPSBocmVmLnNsaWNlKDEsIC0xKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gb3V0cHV0TGluayhjYXAsIHtcbiAgICAgICAgICBocmVmOiBocmVmID8gaHJlZi5yZXBsYWNlKHRoaXMucnVsZXMuaW5saW5lLl9lc2NhcGVzLCAnJDEnKSA6IGhyZWYsXG4gICAgICAgICAgdGl0bGU6IHRpdGxlID8gdGl0bGUucmVwbGFjZSh0aGlzLnJ1bGVzLmlubGluZS5fZXNjYXBlcywgJyQxJykgOiB0aXRsZVxuICAgICAgICB9LCBjYXBbMF0sIHRoaXMubGV4ZXIpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBfcHJvdG8ucmVmbGluayA9IGZ1bmN0aW9uIHJlZmxpbmsoc3JjLCBsaW5rcykge1xuICAgICAgdmFyIGNhcDtcblxuICAgICAgaWYgKChjYXAgPSB0aGlzLnJ1bGVzLmlubGluZS5yZWZsaW5rLmV4ZWMoc3JjKSkgfHwgKGNhcCA9IHRoaXMucnVsZXMuaW5saW5lLm5vbGluay5leGVjKHNyYykpKSB7XG4gICAgICAgIHZhciBsaW5rID0gKGNhcFsyXSB8fCBjYXBbMV0pLnJlcGxhY2UoL1xccysvZywgJyAnKTtcbiAgICAgICAgbGluayA9IGxpbmtzW2xpbmsudG9Mb3dlckNhc2UoKV07XG5cbiAgICAgICAgaWYgKCFsaW5rIHx8ICFsaW5rLmhyZWYpIHtcbiAgICAgICAgICB2YXIgdGV4dCA9IGNhcFswXS5jaGFyQXQoMCk7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6ICd0ZXh0JyxcbiAgICAgICAgICAgIHJhdzogdGV4dCxcbiAgICAgICAgICAgIHRleHQ6IHRleHRcbiAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG91dHB1dExpbmsoY2FwLCBsaW5rLCBjYXBbMF0sIHRoaXMubGV4ZXIpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBfcHJvdG8uZW1TdHJvbmcgPSBmdW5jdGlvbiBlbVN0cm9uZyhzcmMsIG1hc2tlZFNyYywgcHJldkNoYXIpIHtcbiAgICAgIGlmIChwcmV2Q2hhciA9PT0gdm9pZCAwKSB7XG4gICAgICAgIHByZXZDaGFyID0gJyc7XG4gICAgICB9XG5cbiAgICAgIHZhciBtYXRjaCA9IHRoaXMucnVsZXMuaW5saW5lLmVtU3Ryb25nLmxEZWxpbS5leGVjKHNyYyk7XG4gICAgICBpZiAoIW1hdGNoKSByZXR1cm47IC8vIF8gY2FuJ3QgYmUgYmV0d2VlbiB0d28gYWxwaGFudW1lcmljcy4gXFxwe0x9XFxwe059IGluY2x1ZGVzIG5vbi1lbmdsaXNoIGFscGhhYmV0L251bWJlcnMgYXMgd2VsbFxuXG4gICAgICBpZiAobWF0Y2hbM10gJiYgcHJldkNoYXIubWF0Y2goLyg/OlswLTlBLVphLXpcXHhBQVxceEIyXFx4QjNcXHhCNVxceEI5XFx4QkFcXHhCQy1cXHhCRVxceEMwLVxceEQ2XFx4RDgtXFx4RjZcXHhGOC1cXHUwMkMxXFx1MDJDNi1cXHUwMkQxXFx1MDJFMC1cXHUwMkU0XFx1MDJFQ1xcdTAyRUVcXHUwMzcwLVxcdTAzNzRcXHUwMzc2XFx1MDM3N1xcdTAzN0EtXFx1MDM3RFxcdTAzN0ZcXHUwMzg2XFx1MDM4OC1cXHUwMzhBXFx1MDM4Q1xcdTAzOEUtXFx1MDNBMVxcdTAzQTMtXFx1MDNGNVxcdTAzRjctXFx1MDQ4MVxcdTA0OEEtXFx1MDUyRlxcdTA1MzEtXFx1MDU1NlxcdTA1NTlcXHUwNTYwLVxcdTA1ODhcXHUwNUQwLVxcdTA1RUFcXHUwNUVGLVxcdTA1RjJcXHUwNjIwLVxcdTA2NEFcXHUwNjYwLVxcdTA2NjlcXHUwNjZFXFx1MDY2RlxcdTA2NzEtXFx1MDZEM1xcdTA2RDVcXHUwNkU1XFx1MDZFNlxcdTA2RUUtXFx1MDZGQ1xcdTA2RkZcXHUwNzEwXFx1MDcxMi1cXHUwNzJGXFx1MDc0RC1cXHUwN0E1XFx1MDdCMVxcdTA3QzAtXFx1MDdFQVxcdTA3RjRcXHUwN0Y1XFx1MDdGQVxcdTA4MDAtXFx1MDgxNVxcdTA4MUFcXHUwODI0XFx1MDgyOFxcdTA4NDAtXFx1MDg1OFxcdTA4NjAtXFx1MDg2QVxcdTA4QTAtXFx1MDhCNFxcdTA4QjYtXFx1MDhDN1xcdTA5MDQtXFx1MDkzOVxcdTA5M0RcXHUwOTUwXFx1MDk1OC1cXHUwOTYxXFx1MDk2Ni1cXHUwOTZGXFx1MDk3MS1cXHUwOTgwXFx1MDk4NS1cXHUwOThDXFx1MDk4RlxcdTA5OTBcXHUwOTkzLVxcdTA5QThcXHUwOUFBLVxcdTA5QjBcXHUwOUIyXFx1MDlCNi1cXHUwOUI5XFx1MDlCRFxcdTA5Q0VcXHUwOURDXFx1MDlERFxcdTA5REYtXFx1MDlFMVxcdTA5RTYtXFx1MDlGMVxcdTA5RjQtXFx1MDlGOVxcdTA5RkNcXHUwQTA1LVxcdTBBMEFcXHUwQTBGXFx1MEExMFxcdTBBMTMtXFx1MEEyOFxcdTBBMkEtXFx1MEEzMFxcdTBBMzJcXHUwQTMzXFx1MEEzNVxcdTBBMzZcXHUwQTM4XFx1MEEzOVxcdTBBNTktXFx1MEE1Q1xcdTBBNUVcXHUwQTY2LVxcdTBBNkZcXHUwQTcyLVxcdTBBNzRcXHUwQTg1LVxcdTBBOERcXHUwQThGLVxcdTBBOTFcXHUwQTkzLVxcdTBBQThcXHUwQUFBLVxcdTBBQjBcXHUwQUIyXFx1MEFCM1xcdTBBQjUtXFx1MEFCOVxcdTBBQkRcXHUwQUQwXFx1MEFFMFxcdTBBRTFcXHUwQUU2LVxcdTBBRUZcXHUwQUY5XFx1MEIwNS1cXHUwQjBDXFx1MEIwRlxcdTBCMTBcXHUwQjEzLVxcdTBCMjhcXHUwQjJBLVxcdTBCMzBcXHUwQjMyXFx1MEIzM1xcdTBCMzUtXFx1MEIzOVxcdTBCM0RcXHUwQjVDXFx1MEI1RFxcdTBCNUYtXFx1MEI2MVxcdTBCNjYtXFx1MEI2RlxcdTBCNzEtXFx1MEI3N1xcdTBCODNcXHUwQjg1LVxcdTBCOEFcXHUwQjhFLVxcdTBCOTBcXHUwQjkyLVxcdTBCOTVcXHUwQjk5XFx1MEI5QVxcdTBCOUNcXHUwQjlFXFx1MEI5RlxcdTBCQTNcXHUwQkE0XFx1MEJBOC1cXHUwQkFBXFx1MEJBRS1cXHUwQkI5XFx1MEJEMFxcdTBCRTYtXFx1MEJGMlxcdTBDMDUtXFx1MEMwQ1xcdTBDMEUtXFx1MEMxMFxcdTBDMTItXFx1MEMyOFxcdTBDMkEtXFx1MEMzOVxcdTBDM0RcXHUwQzU4LVxcdTBDNUFcXHUwQzYwXFx1MEM2MVxcdTBDNjYtXFx1MEM2RlxcdTBDNzgtXFx1MEM3RVxcdTBDODBcXHUwQzg1LVxcdTBDOENcXHUwQzhFLVxcdTBDOTBcXHUwQzkyLVxcdTBDQThcXHUwQ0FBLVxcdTBDQjNcXHUwQ0I1LVxcdTBDQjlcXHUwQ0JEXFx1MENERVxcdTBDRTBcXHUwQ0UxXFx1MENFNi1cXHUwQ0VGXFx1MENGMVxcdTBDRjJcXHUwRDA0LVxcdTBEMENcXHUwRDBFLVxcdTBEMTBcXHUwRDEyLVxcdTBEM0FcXHUwRDNEXFx1MEQ0RVxcdTBENTQtXFx1MEQ1NlxcdTBENTgtXFx1MEQ2MVxcdTBENjYtXFx1MEQ3OFxcdTBEN0EtXFx1MEQ3RlxcdTBEODUtXFx1MEQ5NlxcdTBEOUEtXFx1MERCMVxcdTBEQjMtXFx1MERCQlxcdTBEQkRcXHUwREMwLVxcdTBEQzZcXHUwREU2LVxcdTBERUZcXHUwRTAxLVxcdTBFMzBcXHUwRTMyXFx1MEUzM1xcdTBFNDAtXFx1MEU0NlxcdTBFNTAtXFx1MEU1OVxcdTBFODFcXHUwRTgyXFx1MEU4NFxcdTBFODYtXFx1MEU4QVxcdTBFOEMtXFx1MEVBM1xcdTBFQTVcXHUwRUE3LVxcdTBFQjBcXHUwRUIyXFx1MEVCM1xcdTBFQkRcXHUwRUMwLVxcdTBFQzRcXHUwRUM2XFx1MEVEMC1cXHUwRUQ5XFx1MEVEQy1cXHUwRURGXFx1MEYwMFxcdTBGMjAtXFx1MEYzM1xcdTBGNDAtXFx1MEY0N1xcdTBGNDktXFx1MEY2Q1xcdTBGODgtXFx1MEY4Q1xcdTEwMDAtXFx1MTAyQVxcdTEwM0YtXFx1MTA0OVxcdTEwNTAtXFx1MTA1NVxcdTEwNUEtXFx1MTA1RFxcdTEwNjFcXHUxMDY1XFx1MTA2NlxcdTEwNkUtXFx1MTA3MFxcdTEwNzUtXFx1MTA4MVxcdTEwOEVcXHUxMDkwLVxcdTEwOTlcXHUxMEEwLVxcdTEwQzVcXHUxMEM3XFx1MTBDRFxcdTEwRDAtXFx1MTBGQVxcdTEwRkMtXFx1MTI0OFxcdTEyNEEtXFx1MTI0RFxcdTEyNTAtXFx1MTI1NlxcdTEyNThcXHUxMjVBLVxcdTEyNURcXHUxMjYwLVxcdTEyODhcXHUxMjhBLVxcdTEyOERcXHUxMjkwLVxcdTEyQjBcXHUxMkIyLVxcdTEyQjVcXHUxMkI4LVxcdTEyQkVcXHUxMkMwXFx1MTJDMi1cXHUxMkM1XFx1MTJDOC1cXHUxMkQ2XFx1MTJEOC1cXHUxMzEwXFx1MTMxMi1cXHUxMzE1XFx1MTMxOC1cXHUxMzVBXFx1MTM2OS1cXHUxMzdDXFx1MTM4MC1cXHUxMzhGXFx1MTNBMC1cXHUxM0Y1XFx1MTNGOC1cXHUxM0ZEXFx1MTQwMS1cXHUxNjZDXFx1MTY2Ri1cXHUxNjdGXFx1MTY4MS1cXHUxNjlBXFx1MTZBMC1cXHUxNkVBXFx1MTZFRS1cXHUxNkY4XFx1MTcwMC1cXHUxNzBDXFx1MTcwRS1cXHUxNzExXFx1MTcyMC1cXHUxNzMxXFx1MTc0MC1cXHUxNzUxXFx1MTc2MC1cXHUxNzZDXFx1MTc2RS1cXHUxNzcwXFx1MTc4MC1cXHUxN0IzXFx1MTdEN1xcdTE3RENcXHUxN0UwLVxcdTE3RTlcXHUxN0YwLVxcdTE3RjlcXHUxODEwLVxcdTE4MTlcXHUxODIwLVxcdTE4NzhcXHUxODgwLVxcdTE4ODRcXHUxODg3LVxcdTE4QThcXHUxOEFBXFx1MThCMC1cXHUxOEY1XFx1MTkwMC1cXHUxOTFFXFx1MTk0Ni1cXHUxOTZEXFx1MTk3MC1cXHUxOTc0XFx1MTk4MC1cXHUxOUFCXFx1MTlCMC1cXHUxOUM5XFx1MTlEMC1cXHUxOURBXFx1MUEwMC1cXHUxQTE2XFx1MUEyMC1cXHUxQTU0XFx1MUE4MC1cXHUxQTg5XFx1MUE5MC1cXHUxQTk5XFx1MUFBN1xcdTFCMDUtXFx1MUIzM1xcdTFCNDUtXFx1MUI0QlxcdTFCNTAtXFx1MUI1OVxcdTFCODMtXFx1MUJBMFxcdTFCQUUtXFx1MUJFNVxcdTFDMDAtXFx1MUMyM1xcdTFDNDAtXFx1MUM0OVxcdTFDNEQtXFx1MUM3RFxcdTFDODAtXFx1MUM4OFxcdTFDOTAtXFx1MUNCQVxcdTFDQkQtXFx1MUNCRlxcdTFDRTktXFx1MUNFQ1xcdTFDRUUtXFx1MUNGM1xcdTFDRjVcXHUxQ0Y2XFx1MUNGQVxcdTFEMDAtXFx1MURCRlxcdTFFMDAtXFx1MUYxNVxcdTFGMTgtXFx1MUYxRFxcdTFGMjAtXFx1MUY0NVxcdTFGNDgtXFx1MUY0RFxcdTFGNTAtXFx1MUY1N1xcdTFGNTlcXHUxRjVCXFx1MUY1RFxcdTFGNUYtXFx1MUY3RFxcdTFGODAtXFx1MUZCNFxcdTFGQjYtXFx1MUZCQ1xcdTFGQkVcXHUxRkMyLVxcdTFGQzRcXHUxRkM2LVxcdTFGQ0NcXHUxRkQwLVxcdTFGRDNcXHUxRkQ2LVxcdTFGREJcXHUxRkUwLVxcdTFGRUNcXHUxRkYyLVxcdTFGRjRcXHUxRkY2LVxcdTFGRkNcXHUyMDcwXFx1MjA3MVxcdTIwNzQtXFx1MjA3OVxcdTIwN0YtXFx1MjA4OVxcdTIwOTAtXFx1MjA5Q1xcdTIxMDJcXHUyMTA3XFx1MjEwQS1cXHUyMTEzXFx1MjExNVxcdTIxMTktXFx1MjExRFxcdTIxMjRcXHUyMTI2XFx1MjEyOFxcdTIxMkEtXFx1MjEyRFxcdTIxMkYtXFx1MjEzOVxcdTIxM0MtXFx1MjEzRlxcdTIxNDUtXFx1MjE0OVxcdTIxNEVcXHUyMTUwLVxcdTIxODlcXHUyNDYwLVxcdTI0OUJcXHUyNEVBLVxcdTI0RkZcXHUyNzc2LVxcdTI3OTNcXHUyQzAwLVxcdTJDMkVcXHUyQzMwLVxcdTJDNUVcXHUyQzYwLVxcdTJDRTRcXHUyQ0VCLVxcdTJDRUVcXHUyQ0YyXFx1MkNGM1xcdTJDRkRcXHUyRDAwLVxcdTJEMjVcXHUyRDI3XFx1MkQyRFxcdTJEMzAtXFx1MkQ2N1xcdTJENkZcXHUyRDgwLVxcdTJEOTZcXHUyREEwLVxcdTJEQTZcXHUyREE4LVxcdTJEQUVcXHUyREIwLVxcdTJEQjZcXHUyREI4LVxcdTJEQkVcXHUyREMwLVxcdTJEQzZcXHUyREM4LVxcdTJEQ0VcXHUyREQwLVxcdTJERDZcXHUyREQ4LVxcdTJEREVcXHUyRTJGXFx1MzAwNS1cXHUzMDA3XFx1MzAyMS1cXHUzMDI5XFx1MzAzMS1cXHUzMDM1XFx1MzAzOC1cXHUzMDNDXFx1MzA0MS1cXHUzMDk2XFx1MzA5RC1cXHUzMDlGXFx1MzBBMS1cXHUzMEZBXFx1MzBGQy1cXHUzMEZGXFx1MzEwNS1cXHUzMTJGXFx1MzEzMS1cXHUzMThFXFx1MzE5Mi1cXHUzMTk1XFx1MzFBMC1cXHUzMUJGXFx1MzFGMC1cXHUzMUZGXFx1MzIyMC1cXHUzMjI5XFx1MzI0OC1cXHUzMjRGXFx1MzI1MS1cXHUzMjVGXFx1MzI4MC1cXHUzMjg5XFx1MzJCMS1cXHUzMkJGXFx1MzQwMC1cXHU0REJGXFx1NEUwMC1cXHU5RkZDXFx1QTAwMC1cXHVBNDhDXFx1QTREMC1cXHVBNEZEXFx1QTUwMC1cXHVBNjBDXFx1QTYxMC1cXHVBNjJCXFx1QTY0MC1cXHVBNjZFXFx1QTY3Ri1cXHVBNjlEXFx1QTZBMC1cXHVBNkVGXFx1QTcxNy1cXHVBNzFGXFx1QTcyMi1cXHVBNzg4XFx1QTc4Qi1cXHVBN0JGXFx1QTdDMi1cXHVBN0NBXFx1QTdGNS1cXHVBODAxXFx1QTgwMy1cXHVBODA1XFx1QTgwNy1cXHVBODBBXFx1QTgwQy1cXHVBODIyXFx1QTgzMC1cXHVBODM1XFx1QTg0MC1cXHVBODczXFx1QTg4Mi1cXHVBOEIzXFx1QThEMC1cXHVBOEQ5XFx1QThGMi1cXHVBOEY3XFx1QThGQlxcdUE4RkRcXHVBOEZFXFx1QTkwMC1cXHVBOTI1XFx1QTkzMC1cXHVBOTQ2XFx1QTk2MC1cXHVBOTdDXFx1QTk4NC1cXHVBOUIyXFx1QTlDRi1cXHVBOUQ5XFx1QTlFMC1cXHVBOUU0XFx1QTlFNi1cXHVBOUZFXFx1QUEwMC1cXHVBQTI4XFx1QUE0MC1cXHVBQTQyXFx1QUE0NC1cXHVBQTRCXFx1QUE1MC1cXHVBQTU5XFx1QUE2MC1cXHVBQTc2XFx1QUE3QVxcdUFBN0UtXFx1QUFBRlxcdUFBQjFcXHVBQUI1XFx1QUFCNlxcdUFBQjktXFx1QUFCRFxcdUFBQzBcXHVBQUMyXFx1QUFEQi1cXHVBQUREXFx1QUFFMC1cXHVBQUVBXFx1QUFGMi1cXHVBQUY0XFx1QUIwMS1cXHVBQjA2XFx1QUIwOS1cXHVBQjBFXFx1QUIxMS1cXHVBQjE2XFx1QUIyMC1cXHVBQjI2XFx1QUIyOC1cXHVBQjJFXFx1QUIzMC1cXHVBQjVBXFx1QUI1Qy1cXHVBQjY5XFx1QUI3MC1cXHVBQkUyXFx1QUJGMC1cXHVBQkY5XFx1QUMwMC1cXHVEN0EzXFx1RDdCMC1cXHVEN0M2XFx1RDdDQi1cXHVEN0ZCXFx1RjkwMC1cXHVGQTZEXFx1RkE3MC1cXHVGQUQ5XFx1RkIwMC1cXHVGQjA2XFx1RkIxMy1cXHVGQjE3XFx1RkIxRFxcdUZCMUYtXFx1RkIyOFxcdUZCMkEtXFx1RkIzNlxcdUZCMzgtXFx1RkIzQ1xcdUZCM0VcXHVGQjQwXFx1RkI0MVxcdUZCNDNcXHVGQjQ0XFx1RkI0Ni1cXHVGQkIxXFx1RkJEMy1cXHVGRDNEXFx1RkQ1MC1cXHVGRDhGXFx1RkQ5Mi1cXHVGREM3XFx1RkRGMC1cXHVGREZCXFx1RkU3MC1cXHVGRTc0XFx1RkU3Ni1cXHVGRUZDXFx1RkYxMC1cXHVGRjE5XFx1RkYyMS1cXHVGRjNBXFx1RkY0MS1cXHVGRjVBXFx1RkY2Ni1cXHVGRkJFXFx1RkZDMi1cXHVGRkM3XFx1RkZDQS1cXHVGRkNGXFx1RkZEMi1cXHVGRkQ3XFx1RkZEQS1cXHVGRkRDXXxcXHVEODAwW1xcdURDMDAtXFx1REMwQlxcdURDMEQtXFx1REMyNlxcdURDMjgtXFx1REMzQVxcdURDM0NcXHVEQzNEXFx1REMzRi1cXHVEQzREXFx1REM1MC1cXHVEQzVEXFx1REM4MC1cXHVEQ0ZBXFx1REQwNy1cXHVERDMzXFx1REQ0MC1cXHVERDc4XFx1REQ4QVxcdUREOEJcXHVERTgwLVxcdURFOUNcXHVERUEwLVxcdURFRDBcXHVERUUxLVxcdURFRkJcXHVERjAwLVxcdURGMjNcXHVERjJELVxcdURGNEFcXHVERjUwLVxcdURGNzVcXHVERjgwLVxcdURGOURcXHVERkEwLVxcdURGQzNcXHVERkM4LVxcdURGQ0ZcXHVERkQxLVxcdURGRDVdfFxcdUQ4MDFbXFx1REMwMC1cXHVEQzlEXFx1RENBMC1cXHVEQ0E5XFx1RENCMC1cXHVEQ0QzXFx1RENEOC1cXHVEQ0ZCXFx1REQwMC1cXHVERDI3XFx1REQzMC1cXHVERDYzXFx1REUwMC1cXHVERjM2XFx1REY0MC1cXHVERjU1XFx1REY2MC1cXHVERjY3XXxcXHVEODAyW1xcdURDMDAtXFx1REMwNVxcdURDMDhcXHVEQzBBLVxcdURDMzVcXHVEQzM3XFx1REMzOFxcdURDM0NcXHVEQzNGLVxcdURDNTVcXHVEQzU4LVxcdURDNzZcXHVEQzc5LVxcdURDOUVcXHVEQ0E3LVxcdURDQUZcXHVEQ0UwLVxcdURDRjJcXHVEQ0Y0XFx1RENGNVxcdURDRkItXFx1REQxQlxcdUREMjAtXFx1REQzOVxcdUREODAtXFx1RERCN1xcdUREQkMtXFx1RERDRlxcdURERDItXFx1REUwMFxcdURFMTAtXFx1REUxM1xcdURFMTUtXFx1REUxN1xcdURFMTktXFx1REUzNVxcdURFNDAtXFx1REU0OFxcdURFNjAtXFx1REU3RVxcdURFODAtXFx1REU5RlxcdURFQzAtXFx1REVDN1xcdURFQzktXFx1REVFNFxcdURFRUItXFx1REVFRlxcdURGMDAtXFx1REYzNVxcdURGNDAtXFx1REY1NVxcdURGNTgtXFx1REY3MlxcdURGNzgtXFx1REY5MVxcdURGQTktXFx1REZBRl18XFx1RDgwM1tcXHVEQzAwLVxcdURDNDhcXHVEQzgwLVxcdURDQjJcXHVEQ0MwLVxcdURDRjJcXHVEQ0ZBLVxcdUREMjNcXHVERDMwLVxcdUREMzlcXHVERTYwLVxcdURFN0VcXHVERTgwLVxcdURFQTlcXHVERUIwXFx1REVCMVxcdURGMDAtXFx1REYyN1xcdURGMzAtXFx1REY0NVxcdURGNTEtXFx1REY1NFxcdURGQjAtXFx1REZDQlxcdURGRTAtXFx1REZGNl18XFx1RDgwNFtcXHVEQzAzLVxcdURDMzdcXHVEQzUyLVxcdURDNkZcXHVEQzgzLVxcdURDQUZcXHVEQ0QwLVxcdURDRThcXHVEQ0YwLVxcdURDRjlcXHVERDAzLVxcdUREMjZcXHVERDM2LVxcdUREM0ZcXHVERDQ0XFx1REQ0N1xcdURENTAtXFx1REQ3MlxcdURENzZcXHVERDgzLVxcdUREQjJcXHVEREMxLVxcdUREQzRcXHVEREQwLVxcdUREREFcXHVERERDXFx1RERFMS1cXHVEREY0XFx1REUwMC1cXHVERTExXFx1REUxMy1cXHVERTJCXFx1REU4MC1cXHVERTg2XFx1REU4OFxcdURFOEEtXFx1REU4RFxcdURFOEYtXFx1REU5RFxcdURFOUYtXFx1REVBOFxcdURFQjAtXFx1REVERVxcdURFRjAtXFx1REVGOVxcdURGMDUtXFx1REYwQ1xcdURGMEZcXHVERjEwXFx1REYxMy1cXHVERjI4XFx1REYyQS1cXHVERjMwXFx1REYzMlxcdURGMzNcXHVERjM1LVxcdURGMzlcXHVERjNEXFx1REY1MFxcdURGNUQtXFx1REY2MV18XFx1RDgwNVtcXHVEQzAwLVxcdURDMzRcXHVEQzQ3LVxcdURDNEFcXHVEQzUwLVxcdURDNTlcXHVEQzVGLVxcdURDNjFcXHVEQzgwLVxcdURDQUZcXHVEQ0M0XFx1RENDNVxcdURDQzdcXHVEQ0QwLVxcdURDRDlcXHVERDgwLVxcdUREQUVcXHVEREQ4LVxcdUREREJcXHVERTAwLVxcdURFMkZcXHVERTQ0XFx1REU1MC1cXHVERTU5XFx1REU4MC1cXHVERUFBXFx1REVCOFxcdURFQzAtXFx1REVDOVxcdURGMDAtXFx1REYxQVxcdURGMzAtXFx1REYzQl18XFx1RDgwNltcXHVEQzAwLVxcdURDMkJcXHVEQ0EwLVxcdURDRjJcXHVEQ0ZGLVxcdUREMDZcXHVERDA5XFx1REQwQy1cXHVERDEzXFx1REQxNVxcdUREMTZcXHVERDE4LVxcdUREMkZcXHVERDNGXFx1REQ0MVxcdURENTAtXFx1REQ1OVxcdUREQTAtXFx1RERBN1xcdUREQUEtXFx1REREMFxcdURERTFcXHVEREUzXFx1REUwMFxcdURFMEItXFx1REUzMlxcdURFM0FcXHVERTUwXFx1REU1Qy1cXHVERTg5XFx1REU5RFxcdURFQzAtXFx1REVGOF18XFx1RDgwN1tcXHVEQzAwLVxcdURDMDhcXHVEQzBBLVxcdURDMkVcXHVEQzQwXFx1REM1MC1cXHVEQzZDXFx1REM3Mi1cXHVEQzhGXFx1REQwMC1cXHVERDA2XFx1REQwOFxcdUREMDlcXHVERDBCLVxcdUREMzBcXHVERDQ2XFx1REQ1MC1cXHVERDU5XFx1REQ2MC1cXHVERDY1XFx1REQ2N1xcdURENjhcXHVERDZBLVxcdUREODlcXHVERDk4XFx1RERBMC1cXHVEREE5XFx1REVFMC1cXHVERUYyXFx1REZCMFxcdURGQzAtXFx1REZENF18XFx1RDgwOFtcXHVEQzAwLVxcdURGOTldfFxcdUQ4MDlbXFx1REMwMC1cXHVEQzZFXFx1REM4MC1cXHVERDQzXXxbXFx1RDgwQ1xcdUQ4MUMtXFx1RDgyMFxcdUQ4MjJcXHVEODQwLVxcdUQ4NjhcXHVEODZBLVxcdUQ4NkNcXHVEODZGLVxcdUQ4NzJcXHVEODc0LVxcdUQ4NzlcXHVEODgwLVxcdUQ4ODNdW1xcdURDMDAtXFx1REZGRl18XFx1RDgwRFtcXHVEQzAwLVxcdURDMkVdfFxcdUQ4MTFbXFx1REMwMC1cXHVERTQ2XXxcXHVEODFBW1xcdURDMDAtXFx1REUzOFxcdURFNDAtXFx1REU1RVxcdURFNjAtXFx1REU2OVxcdURFRDAtXFx1REVFRFxcdURGMDAtXFx1REYyRlxcdURGNDAtXFx1REY0M1xcdURGNTAtXFx1REY1OVxcdURGNUItXFx1REY2MVxcdURGNjMtXFx1REY3N1xcdURGN0QtXFx1REY4Rl18XFx1RDgxQltcXHVERTQwLVxcdURFOTZcXHVERjAwLVxcdURGNEFcXHVERjUwXFx1REY5My1cXHVERjlGXFx1REZFMFxcdURGRTFcXHVERkUzXXxcXHVEODIxW1xcdURDMDAtXFx1REZGN118XFx1RDgyM1tcXHVEQzAwLVxcdURDRDVcXHVERDAwLVxcdUREMDhdfFxcdUQ4MkNbXFx1REMwMC1cXHVERDFFXFx1REQ1MC1cXHVERDUyXFx1REQ2NC1cXHVERDY3XFx1REQ3MC1cXHVERUZCXXxcXHVEODJGW1xcdURDMDAtXFx1REM2QVxcdURDNzAtXFx1REM3Q1xcdURDODAtXFx1REM4OFxcdURDOTAtXFx1REM5OV18XFx1RDgzNFtcXHVERUUwLVxcdURFRjNcXHVERjYwLVxcdURGNzhdfFxcdUQ4MzVbXFx1REMwMC1cXHVEQzU0XFx1REM1Ni1cXHVEQzlDXFx1REM5RVxcdURDOUZcXHVEQ0EyXFx1RENBNVxcdURDQTZcXHVEQ0E5LVxcdURDQUNcXHVEQ0FFLVxcdURDQjlcXHVEQ0JCXFx1RENCRC1cXHVEQ0MzXFx1RENDNS1cXHVERDA1XFx1REQwNy1cXHVERDBBXFx1REQwRC1cXHVERDE0XFx1REQxNi1cXHVERDFDXFx1REQxRS1cXHVERDM5XFx1REQzQi1cXHVERDNFXFx1REQ0MC1cXHVERDQ0XFx1REQ0NlxcdURENEEtXFx1REQ1MFxcdURENTItXFx1REVBNVxcdURFQTgtXFx1REVDMFxcdURFQzItXFx1REVEQVxcdURFREMtXFx1REVGQVxcdURFRkMtXFx1REYxNFxcdURGMTYtXFx1REYzNFxcdURGMzYtXFx1REY0RVxcdURGNTAtXFx1REY2RVxcdURGNzAtXFx1REY4OFxcdURGOEEtXFx1REZBOFxcdURGQUEtXFx1REZDMlxcdURGQzQtXFx1REZDQlxcdURGQ0UtXFx1REZGRl18XFx1RDgzOFtcXHVERDAwLVxcdUREMkNcXHVERDM3LVxcdUREM0RcXHVERDQwLVxcdURENDlcXHVERDRFXFx1REVDMC1cXHVERUVCXFx1REVGMC1cXHVERUY5XXxcXHVEODNBW1xcdURDMDAtXFx1RENDNFxcdURDQzctXFx1RENDRlxcdUREMDAtXFx1REQ0M1xcdURENEJcXHVERDUwLVxcdURENTldfFxcdUQ4M0JbXFx1REM3MS1cXHVEQ0FCXFx1RENBRC1cXHVEQ0FGXFx1RENCMS1cXHVEQ0I0XFx1REQwMS1cXHVERDJEXFx1REQyRi1cXHVERDNEXFx1REUwMC1cXHVERTAzXFx1REUwNS1cXHVERTFGXFx1REUyMVxcdURFMjJcXHVERTI0XFx1REUyN1xcdURFMjktXFx1REUzMlxcdURFMzQtXFx1REUzN1xcdURFMzlcXHVERTNCXFx1REU0MlxcdURFNDdcXHVERTQ5XFx1REU0QlxcdURFNEQtXFx1REU0RlxcdURFNTFcXHVERTUyXFx1REU1NFxcdURFNTdcXHVERTU5XFx1REU1QlxcdURFNURcXHVERTVGXFx1REU2MVxcdURFNjJcXHVERTY0XFx1REU2Ny1cXHVERTZBXFx1REU2Qy1cXHVERTcyXFx1REU3NC1cXHVERTc3XFx1REU3OS1cXHVERTdDXFx1REU3RVxcdURFODAtXFx1REU4OVxcdURFOEItXFx1REU5QlxcdURFQTEtXFx1REVBM1xcdURFQTUtXFx1REVBOVxcdURFQUItXFx1REVCQl18XFx1RDgzQ1tcXHVERDAwLVxcdUREMENdfFxcdUQ4M0VbXFx1REZGMC1cXHVERkY5XXxcXHVEODY5W1xcdURDMDAtXFx1REVERFxcdURGMDAtXFx1REZGRl18XFx1RDg2RFtcXHVEQzAwLVxcdURGMzRcXHVERjQwLVxcdURGRkZdfFxcdUQ4NkVbXFx1REMwMC1cXHVEQzFEXFx1REMyMC1cXHVERkZGXXxcXHVEODczW1xcdURDMDAtXFx1REVBMVxcdURFQjAtXFx1REZGRl18XFx1RDg3QVtcXHVEQzAwLVxcdURGRTBdfFxcdUQ4N0VbXFx1REMwMC1cXHVERTFEXXxcXHVEODg0W1xcdURDMDAtXFx1REY0QV0pLykpIHJldHVybjtcbiAgICAgIHZhciBuZXh0Q2hhciA9IG1hdGNoWzFdIHx8IG1hdGNoWzJdIHx8ICcnO1xuXG4gICAgICBpZiAoIW5leHRDaGFyIHx8IG5leHRDaGFyICYmIChwcmV2Q2hhciA9PT0gJycgfHwgdGhpcy5ydWxlcy5pbmxpbmUucHVuY3R1YXRpb24uZXhlYyhwcmV2Q2hhcikpKSB7XG4gICAgICAgIHZhciBsTGVuZ3RoID0gbWF0Y2hbMF0ubGVuZ3RoIC0gMTtcbiAgICAgICAgdmFyIHJEZWxpbSxcbiAgICAgICAgICAgIHJMZW5ndGgsXG4gICAgICAgICAgICBkZWxpbVRvdGFsID0gbExlbmd0aCxcbiAgICAgICAgICAgIG1pZERlbGltVG90YWwgPSAwO1xuICAgICAgICB2YXIgZW5kUmVnID0gbWF0Y2hbMF1bMF0gPT09ICcqJyA/IHRoaXMucnVsZXMuaW5saW5lLmVtU3Ryb25nLnJEZWxpbUFzdCA6IHRoaXMucnVsZXMuaW5saW5lLmVtU3Ryb25nLnJEZWxpbVVuZDtcbiAgICAgICAgZW5kUmVnLmxhc3RJbmRleCA9IDA7IC8vIENsaXAgbWFza2VkU3JjIHRvIHNhbWUgc2VjdGlvbiBvZiBzdHJpbmcgYXMgc3JjIChtb3ZlIHRvIGxleGVyPylcblxuICAgICAgICBtYXNrZWRTcmMgPSBtYXNrZWRTcmMuc2xpY2UoLTEgKiBzcmMubGVuZ3RoICsgbExlbmd0aCk7XG5cbiAgICAgICAgd2hpbGUgKChtYXRjaCA9IGVuZFJlZy5leGVjKG1hc2tlZFNyYykpICE9IG51bGwpIHtcbiAgICAgICAgICByRGVsaW0gPSBtYXRjaFsxXSB8fCBtYXRjaFsyXSB8fCBtYXRjaFszXSB8fCBtYXRjaFs0XSB8fCBtYXRjaFs1XSB8fCBtYXRjaFs2XTtcbiAgICAgICAgICBpZiAoIXJEZWxpbSkgY29udGludWU7IC8vIHNraXAgc2luZ2xlICogaW4gX19hYmMqYWJjX19cblxuICAgICAgICAgIHJMZW5ndGggPSByRGVsaW0ubGVuZ3RoO1xuXG4gICAgICAgICAgaWYgKG1hdGNoWzNdIHx8IG1hdGNoWzRdKSB7XG4gICAgICAgICAgICAvLyBmb3VuZCBhbm90aGVyIExlZnQgRGVsaW1cbiAgICAgICAgICAgIGRlbGltVG90YWwgKz0gckxlbmd0aDtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH0gZWxzZSBpZiAobWF0Y2hbNV0gfHwgbWF0Y2hbNl0pIHtcbiAgICAgICAgICAgIC8vIGVpdGhlciBMZWZ0IG9yIFJpZ2h0IERlbGltXG4gICAgICAgICAgICBpZiAobExlbmd0aCAlIDMgJiYgISgobExlbmd0aCArIHJMZW5ndGgpICUgMykpIHtcbiAgICAgICAgICAgICAgbWlkRGVsaW1Ub3RhbCArPSByTGVuZ3RoO1xuICAgICAgICAgICAgICBjb250aW51ZTsgLy8gQ29tbW9uTWFyayBFbXBoYXNpcyBSdWxlcyA5LTEwXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZGVsaW1Ub3RhbCAtPSByTGVuZ3RoO1xuICAgICAgICAgIGlmIChkZWxpbVRvdGFsID4gMCkgY29udGludWU7IC8vIEhhdmVuJ3QgZm91bmQgZW5vdWdoIGNsb3NpbmcgZGVsaW1pdGVyc1xuICAgICAgICAgIC8vIFJlbW92ZSBleHRyYSBjaGFyYWN0ZXJzLiAqYSoqKiAtPiAqYSpcblxuICAgICAgICAgIHJMZW5ndGggPSBNYXRoLm1pbihyTGVuZ3RoLCByTGVuZ3RoICsgZGVsaW1Ub3RhbCArIG1pZERlbGltVG90YWwpOyAvLyBDcmVhdGUgYGVtYCBpZiBzbWFsbGVzdCBkZWxpbWl0ZXIgaGFzIG9kZCBjaGFyIGNvdW50LiAqYSoqKlxuXG4gICAgICAgICAgaWYgKE1hdGgubWluKGxMZW5ndGgsIHJMZW5ndGgpICUgMikge1xuICAgICAgICAgICAgdmFyIF90ZXh0ID0gc3JjLnNsaWNlKDEsIGxMZW5ndGggKyBtYXRjaC5pbmRleCArIHJMZW5ndGgpO1xuXG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICB0eXBlOiAnZW0nLFxuICAgICAgICAgICAgICByYXc6IHNyYy5zbGljZSgwLCBsTGVuZ3RoICsgbWF0Y2guaW5kZXggKyByTGVuZ3RoICsgMSksXG4gICAgICAgICAgICAgIHRleHQ6IF90ZXh0LFxuICAgICAgICAgICAgICB0b2tlbnM6IHRoaXMubGV4ZXIuaW5saW5lVG9rZW5zKF90ZXh0LCBbXSlcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfSAvLyBDcmVhdGUgJ3N0cm9uZycgaWYgc21hbGxlc3QgZGVsaW1pdGVyIGhhcyBldmVuIGNoYXIgY291bnQuICoqYSoqKlxuXG5cbiAgICAgICAgICB2YXIgdGV4dCA9IHNyYy5zbGljZSgyLCBsTGVuZ3RoICsgbWF0Y2guaW5kZXggKyByTGVuZ3RoIC0gMSk7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6ICdzdHJvbmcnLFxuICAgICAgICAgICAgcmF3OiBzcmMuc2xpY2UoMCwgbExlbmd0aCArIG1hdGNoLmluZGV4ICsgckxlbmd0aCArIDEpLFxuICAgICAgICAgICAgdGV4dDogdGV4dCxcbiAgICAgICAgICAgIHRva2VuczogdGhpcy5sZXhlci5pbmxpbmVUb2tlbnModGV4dCwgW10pXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICBfcHJvdG8uY29kZXNwYW4gPSBmdW5jdGlvbiBjb2Rlc3BhbihzcmMpIHtcbiAgICAgIHZhciBjYXAgPSB0aGlzLnJ1bGVzLmlubGluZS5jb2RlLmV4ZWMoc3JjKTtcblxuICAgICAgaWYgKGNhcCkge1xuICAgICAgICB2YXIgdGV4dCA9IGNhcFsyXS5yZXBsYWNlKC9cXG4vZywgJyAnKTtcbiAgICAgICAgdmFyIGhhc05vblNwYWNlQ2hhcnMgPSAvW14gXS8udGVzdCh0ZXh0KTtcbiAgICAgICAgdmFyIGhhc1NwYWNlQ2hhcnNPbkJvdGhFbmRzID0gL14gLy50ZXN0KHRleHQpICYmIC8gJC8udGVzdCh0ZXh0KTtcblxuICAgICAgICBpZiAoaGFzTm9uU3BhY2VDaGFycyAmJiBoYXNTcGFjZUNoYXJzT25Cb3RoRW5kcykge1xuICAgICAgICAgIHRleHQgPSB0ZXh0LnN1YnN0cmluZygxLCB0ZXh0Lmxlbmd0aCAtIDEpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGV4dCA9IF9lc2NhcGUodGV4dCwgdHJ1ZSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdHlwZTogJ2NvZGVzcGFuJyxcbiAgICAgICAgICByYXc6IGNhcFswXSxcbiAgICAgICAgICB0ZXh0OiB0ZXh0XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfTtcblxuICAgIF9wcm90by5iciA9IGZ1bmN0aW9uIGJyKHNyYykge1xuICAgICAgdmFyIGNhcCA9IHRoaXMucnVsZXMuaW5saW5lLmJyLmV4ZWMoc3JjKTtcblxuICAgICAgaWYgKGNhcCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHR5cGU6ICdicicsXG4gICAgICAgICAgcmF3OiBjYXBbMF1cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgX3Byb3RvLmRlbCA9IGZ1bmN0aW9uIGRlbChzcmMpIHtcbiAgICAgIHZhciBjYXAgPSB0aGlzLnJ1bGVzLmlubGluZS5kZWwuZXhlYyhzcmMpO1xuXG4gICAgICBpZiAoY2FwKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdHlwZTogJ2RlbCcsXG4gICAgICAgICAgcmF3OiBjYXBbMF0sXG4gICAgICAgICAgdGV4dDogY2FwWzJdLFxuICAgICAgICAgIHRva2VuczogdGhpcy5sZXhlci5pbmxpbmVUb2tlbnMoY2FwWzJdLCBbXSlcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgX3Byb3RvLmF1dG9saW5rID0gZnVuY3Rpb24gYXV0b2xpbmsoc3JjLCBtYW5nbGUpIHtcbiAgICAgIHZhciBjYXAgPSB0aGlzLnJ1bGVzLmlubGluZS5hdXRvbGluay5leGVjKHNyYyk7XG5cbiAgICAgIGlmIChjYXApIHtcbiAgICAgICAgdmFyIHRleHQsIGhyZWY7XG5cbiAgICAgICAgaWYgKGNhcFsyXSA9PT0gJ0AnKSB7XG4gICAgICAgICAgdGV4dCA9IF9lc2NhcGUodGhpcy5vcHRpb25zLm1hbmdsZSA/IG1hbmdsZShjYXBbMV0pIDogY2FwWzFdKTtcbiAgICAgICAgICBocmVmID0gJ21haWx0bzonICsgdGV4dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0ZXh0ID0gX2VzY2FwZShjYXBbMV0pO1xuICAgICAgICAgIGhyZWYgPSB0ZXh0O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0eXBlOiAnbGluaycsXG4gICAgICAgICAgcmF3OiBjYXBbMF0sXG4gICAgICAgICAgdGV4dDogdGV4dCxcbiAgICAgICAgICBocmVmOiBocmVmLFxuICAgICAgICAgIHRva2VuczogW3tcbiAgICAgICAgICAgIHR5cGU6ICd0ZXh0JyxcbiAgICAgICAgICAgIHJhdzogdGV4dCxcbiAgICAgICAgICAgIHRleHQ6IHRleHRcbiAgICAgICAgICB9XVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH07XG5cbiAgICBfcHJvdG8udXJsID0gZnVuY3Rpb24gdXJsKHNyYywgbWFuZ2xlKSB7XG4gICAgICB2YXIgY2FwO1xuXG4gICAgICBpZiAoY2FwID0gdGhpcy5ydWxlcy5pbmxpbmUudXJsLmV4ZWMoc3JjKSkge1xuICAgICAgICB2YXIgdGV4dCwgaHJlZjtcblxuICAgICAgICBpZiAoY2FwWzJdID09PSAnQCcpIHtcbiAgICAgICAgICB0ZXh0ID0gX2VzY2FwZSh0aGlzLm9wdGlvbnMubWFuZ2xlID8gbWFuZ2xlKGNhcFswXSkgOiBjYXBbMF0pO1xuICAgICAgICAgIGhyZWYgPSAnbWFpbHRvOicgKyB0ZXh0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIGRvIGV4dGVuZGVkIGF1dG9saW5rIHBhdGggdmFsaWRhdGlvblxuICAgICAgICAgIHZhciBwcmV2Q2FwWmVybztcblxuICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgIHByZXZDYXBaZXJvID0gY2FwWzBdO1xuICAgICAgICAgICAgY2FwWzBdID0gdGhpcy5ydWxlcy5pbmxpbmUuX2JhY2twZWRhbC5leGVjKGNhcFswXSlbMF07XG4gICAgICAgICAgfSB3aGlsZSAocHJldkNhcFplcm8gIT09IGNhcFswXSk7XG5cbiAgICAgICAgICB0ZXh0ID0gX2VzY2FwZShjYXBbMF0pO1xuXG4gICAgICAgICAgaWYgKGNhcFsxXSA9PT0gJ3d3dy4nKSB7XG4gICAgICAgICAgICBocmVmID0gJ2h0dHA6Ly8nICsgdGV4dDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaHJlZiA9IHRleHQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0eXBlOiAnbGluaycsXG4gICAgICAgICAgcmF3OiBjYXBbMF0sXG4gICAgICAgICAgdGV4dDogdGV4dCxcbiAgICAgICAgICBocmVmOiBocmVmLFxuICAgICAgICAgIHRva2VuczogW3tcbiAgICAgICAgICAgIHR5cGU6ICd0ZXh0JyxcbiAgICAgICAgICAgIHJhdzogdGV4dCxcbiAgICAgICAgICAgIHRleHQ6IHRleHRcbiAgICAgICAgICB9XVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH07XG5cbiAgICBfcHJvdG8uaW5saW5lVGV4dCA9IGZ1bmN0aW9uIGlubGluZVRleHQoc3JjLCBzbWFydHlwYW50cykge1xuICAgICAgdmFyIGNhcCA9IHRoaXMucnVsZXMuaW5saW5lLnRleHQuZXhlYyhzcmMpO1xuXG4gICAgICBpZiAoY2FwKSB7XG4gICAgICAgIHZhciB0ZXh0O1xuXG4gICAgICAgIGlmICh0aGlzLmxleGVyLnN0YXRlLmluUmF3QmxvY2spIHtcbiAgICAgICAgICB0ZXh0ID0gdGhpcy5vcHRpb25zLnNhbml0aXplID8gdGhpcy5vcHRpb25zLnNhbml0aXplciA/IHRoaXMub3B0aW9ucy5zYW5pdGl6ZXIoY2FwWzBdKSA6IF9lc2NhcGUoY2FwWzBdKSA6IGNhcFswXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0ZXh0ID0gX2VzY2FwZSh0aGlzLm9wdGlvbnMuc21hcnR5cGFudHMgPyBzbWFydHlwYW50cyhjYXBbMF0pIDogY2FwWzBdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdHlwZTogJ3RleHQnLFxuICAgICAgICAgIHJhdzogY2FwWzBdLFxuICAgICAgICAgIHRleHQ6IHRleHRcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgcmV0dXJuIFRva2VuaXplcjtcbiAgfSgpO1xuXG4gIHZhciBub29wVGVzdCA9IGhlbHBlcnMubm9vcFRlc3QsXG4gICAgICBlZGl0ID0gaGVscGVycy5lZGl0LFxuICAgICAgbWVyZ2UkMSA9IGhlbHBlcnMubWVyZ2U7XG4gIC8qKlxuICAgKiBCbG9jay1MZXZlbCBHcmFtbWFyXG4gICAqL1xuXG4gIHZhciBibG9jayQxID0ge1xuICAgIG5ld2xpbmU6IC9eKD86ICooPzpcXG58JCkpKy8sXG4gICAgY29kZTogL14oIHs0fVteXFxuXSsoPzpcXG4oPzogKig/OlxcbnwkKSkqKT8pKy8sXG4gICAgZmVuY2VzOiAvXiB7MCwzfShgezMsfSg/PVteYFxcbl0qXFxuKXx+ezMsfSkoW15cXG5dKilcXG4oPzp8KFtcXHNcXFNdKj8pXFxuKSg/OiB7MCwzfVxcMVt+YF0qICooPz1cXG58JCl8JCkvLFxuICAgIGhyOiAvXiB7MCwzfSgoPzotICopezMsfXwoPzpfICopezMsfXwoPzpcXCogKil7Myx9KSg/Olxcbit8JCkvLFxuICAgIGhlYWRpbmc6IC9eIHswLDN9KCN7MSw2fSkoPz1cXHN8JCkoLiopKD86XFxuK3wkKS8sXG4gICAgYmxvY2txdW90ZTogL14oIHswLDN9PiA/KHBhcmFncmFwaHxbXlxcbl0qKSg/OlxcbnwkKSkrLyxcbiAgICBsaXN0OiAvXiggezAsM31idWxsKSggW15cXG5dKz8pPyg/OlxcbnwkKS8sXG4gICAgaHRtbDogJ14gezAsM30oPzonIC8vIG9wdGlvbmFsIGluZGVudGF0aW9uXG4gICAgKyAnPChzY3JpcHR8cHJlfHN0eWxlfHRleHRhcmVhKVtcXFxccz5dW1xcXFxzXFxcXFNdKj8oPzo8L1xcXFwxPlteXFxcXG5dKlxcXFxuK3wkKScgLy8gKDEpXG4gICAgKyAnfGNvbW1lbnRbXlxcXFxuXSooXFxcXG4rfCQpJyAvLyAoMilcbiAgICArICd8PFxcXFw/W1xcXFxzXFxcXFNdKj8oPzpcXFxcPz5cXFxcbip8JCknIC8vICgzKVxuICAgICsgJ3w8IVtBLVpdW1xcXFxzXFxcXFNdKj8oPzo+XFxcXG4qfCQpJyAvLyAoNClcbiAgICArICd8PCFcXFxcW0NEQVRBXFxcXFtbXFxcXHNcXFxcU10qPyg/OlxcXFxdXFxcXF0+XFxcXG4qfCQpJyAvLyAoNSlcbiAgICArICd8PC8/KHRhZykoPzogK3xcXFxcbnwvPz4pW1xcXFxzXFxcXFNdKj8oPzooPzpcXFxcbiAqKStcXFxcbnwkKScgLy8gKDYpXG4gICAgKyAnfDwoPyFzY3JpcHR8cHJlfHN0eWxlfHRleHRhcmVhKShbYS16XVtcXFxcdy1dKikoPzphdHRyaWJ1dGUpKj8gKi8/Pig/PVsgXFxcXHRdKig/OlxcXFxufCQpKVtcXFxcc1xcXFxTXSo/KD86KD86XFxcXG4gKikrXFxcXG58JCknIC8vICg3KSBvcGVuIHRhZ1xuICAgICsgJ3w8Lyg/IXNjcmlwdHxwcmV8c3R5bGV8dGV4dGFyZWEpW2Etel1bXFxcXHctXSpcXFxccyo+KD89WyBcXFxcdF0qKD86XFxcXG58JCkpW1xcXFxzXFxcXFNdKj8oPzooPzpcXFxcbiAqKStcXFxcbnwkKScgLy8gKDcpIGNsb3NpbmcgdGFnXG4gICAgKyAnKScsXG4gICAgZGVmOiAvXiB7MCwzfVxcWyhsYWJlbClcXF06ICpcXG4/ICo8PyhbXlxccz5dKyk+Pyg/Oig/OiArXFxuPyAqfCAqXFxuICopKHRpdGxlKSk/ICooPzpcXG4rfCQpLyxcbiAgICB0YWJsZTogbm9vcFRlc3QsXG4gICAgbGhlYWRpbmc6IC9eKFteXFxuXSspXFxuIHswLDN9KD0rfC0rKSAqKD86XFxuK3wkKS8sXG4gICAgLy8gcmVnZXggdGVtcGxhdGUsIHBsYWNlaG9sZGVycyB3aWxsIGJlIHJlcGxhY2VkIGFjY29yZGluZyB0byBkaWZmZXJlbnQgcGFyYWdyYXBoXG4gICAgLy8gaW50ZXJydXB0aW9uIHJ1bGVzIG9mIGNvbW1vbm1hcmsgYW5kIHRoZSBvcmlnaW5hbCBtYXJrZG93biBzcGVjOlxuICAgIF9wYXJhZ3JhcGg6IC9eKFteXFxuXSsoPzpcXG4oPyFocnxoZWFkaW5nfGxoZWFkaW5nfGJsb2NrcXVvdGV8ZmVuY2VzfGxpc3R8aHRtbHwgK1xcbilbXlxcbl0rKSopLyxcbiAgICB0ZXh0OiAvXlteXFxuXSsvXG4gIH07XG4gIGJsb2NrJDEuX2xhYmVsID0gLyg/IVxccypcXF0pKD86XFxcXFtcXFtcXF1dfFteXFxbXFxdXSkrLztcbiAgYmxvY2skMS5fdGl0bGUgPSAvKD86XCIoPzpcXFxcXCI/fFteXCJcXFxcXSkqXCJ8J1teJ1xcbl0qKD86XFxuW14nXFxuXSspKlxcbj8nfFxcKFteKCldKlxcKSkvO1xuICBibG9jayQxLmRlZiA9IGVkaXQoYmxvY2skMS5kZWYpLnJlcGxhY2UoJ2xhYmVsJywgYmxvY2skMS5fbGFiZWwpLnJlcGxhY2UoJ3RpdGxlJywgYmxvY2skMS5fdGl0bGUpLmdldFJlZ2V4KCk7XG4gIGJsb2NrJDEuYnVsbGV0ID0gLyg/OlsqKy1dfFxcZHsxLDl9Wy4pXSkvO1xuICBibG9jayQxLmxpc3RJdGVtU3RhcnQgPSBlZGl0KC9eKCAqKShidWxsKSAqLykucmVwbGFjZSgnYnVsbCcsIGJsb2NrJDEuYnVsbGV0KS5nZXRSZWdleCgpO1xuICBibG9jayQxLmxpc3QgPSBlZGl0KGJsb2NrJDEubGlzdCkucmVwbGFjZSgvYnVsbC9nLCBibG9jayQxLmJ1bGxldCkucmVwbGFjZSgnaHInLCAnXFxcXG4rKD89XFxcXDE/KD86KD86LSAqKXszLH18KD86XyAqKXszLH18KD86XFxcXCogKil7Myx9KSg/OlxcXFxuK3wkKSknKS5yZXBsYWNlKCdkZWYnLCAnXFxcXG4rKD89JyArIGJsb2NrJDEuZGVmLnNvdXJjZSArICcpJykuZ2V0UmVnZXgoKTtcbiAgYmxvY2skMS5fdGFnID0gJ2FkZHJlc3N8YXJ0aWNsZXxhc2lkZXxiYXNlfGJhc2Vmb250fGJsb2NrcXVvdGV8Ym9keXxjYXB0aW9uJyArICd8Y2VudGVyfGNvbHxjb2xncm91cHxkZHxkZXRhaWxzfGRpYWxvZ3xkaXJ8ZGl2fGRsfGR0fGZpZWxkc2V0fGZpZ2NhcHRpb24nICsgJ3xmaWd1cmV8Zm9vdGVyfGZvcm18ZnJhbWV8ZnJhbWVzZXR8aFsxLTZdfGhlYWR8aGVhZGVyfGhyfGh0bWx8aWZyYW1lJyArICd8bGVnZW5kfGxpfGxpbmt8bWFpbnxtZW51fG1lbnVpdGVtfG1ldGF8bmF2fG5vZnJhbWVzfG9sfG9wdGdyb3VwfG9wdGlvbicgKyAnfHB8cGFyYW18c2VjdGlvbnxzb3VyY2V8c3VtbWFyeXx0YWJsZXx0Ym9keXx0ZHx0Zm9vdHx0aHx0aGVhZHx0aXRsZXx0cicgKyAnfHRyYWNrfHVsJztcbiAgYmxvY2skMS5fY29tbWVudCA9IC88IS0tKD8hLT8+KVtcXHNcXFNdKj8oPzotLT58JCkvO1xuICBibG9jayQxLmh0bWwgPSBlZGl0KGJsb2NrJDEuaHRtbCwgJ2knKS5yZXBsYWNlKCdjb21tZW50JywgYmxvY2skMS5fY29tbWVudCkucmVwbGFjZSgndGFnJywgYmxvY2skMS5fdGFnKS5yZXBsYWNlKCdhdHRyaWJ1dGUnLCAvICtbYS16QS1aOl9dW1xcdy46LV0qKD86ICo9ICpcIlteXCJcXG5dKlwifCAqPSAqJ1teJ1xcbl0qJ3wgKj0gKlteXFxzXCInPTw+YF0rKT8vKS5nZXRSZWdleCgpO1xuICBibG9jayQxLnBhcmFncmFwaCA9IGVkaXQoYmxvY2skMS5fcGFyYWdyYXBoKS5yZXBsYWNlKCdocicsIGJsb2NrJDEuaHIpLnJlcGxhY2UoJ2hlYWRpbmcnLCAnIHswLDN9I3sxLDZ9ICcpLnJlcGxhY2UoJ3xsaGVhZGluZycsICcnKSAvLyBzZXRleCBoZWFkaW5ncyBkb24ndCBpbnRlcnJ1cHQgY29tbW9ubWFyayBwYXJhZ3JhcGhzXG4gIC5yZXBsYWNlKCdibG9ja3F1b3RlJywgJyB7MCwzfT4nKS5yZXBsYWNlKCdmZW5jZXMnLCAnIHswLDN9KD86YHszLH0oPz1bXmBcXFxcbl0qXFxcXG4pfH57Myx9KVteXFxcXG5dKlxcXFxuJykucmVwbGFjZSgnbGlzdCcsICcgezAsM30oPzpbKistXXwxWy4pXSkgJykgLy8gb25seSBsaXN0cyBzdGFydGluZyBmcm9tIDEgY2FuIGludGVycnVwdFxuICAucmVwbGFjZSgnaHRtbCcsICc8Lz8oPzp0YWcpKD86ICt8XFxcXG58Lz8+KXw8KD86c2NyaXB0fHByZXxzdHlsZXx0ZXh0YXJlYXwhLS0pJykucmVwbGFjZSgndGFnJywgYmxvY2skMS5fdGFnKSAvLyBwYXJzIGNhbiBiZSBpbnRlcnJ1cHRlZCBieSB0eXBlICg2KSBodG1sIGJsb2Nrc1xuICAuZ2V0UmVnZXgoKTtcbiAgYmxvY2skMS5ibG9ja3F1b3RlID0gZWRpdChibG9jayQxLmJsb2NrcXVvdGUpLnJlcGxhY2UoJ3BhcmFncmFwaCcsIGJsb2NrJDEucGFyYWdyYXBoKS5nZXRSZWdleCgpO1xuICAvKipcbiAgICogTm9ybWFsIEJsb2NrIEdyYW1tYXJcbiAgICovXG5cbiAgYmxvY2skMS5ub3JtYWwgPSBtZXJnZSQxKHt9LCBibG9jayQxKTtcbiAgLyoqXG4gICAqIEdGTSBCbG9jayBHcmFtbWFyXG4gICAqL1xuXG4gIGJsb2NrJDEuZ2ZtID0gbWVyZ2UkMSh7fSwgYmxvY2skMS5ub3JtYWwsIHtcbiAgICB0YWJsZTogJ14gKihbXlxcXFxuIF0uKlxcXFx8LiopXFxcXG4nIC8vIEhlYWRlclxuICAgICsgJyB7MCwzfSg/OlxcXFx8ICopPyg6Py0rOj8gKig/OlxcXFx8ICo6Py0rOj8gKikqKSg/OlxcXFx8ICopPycgLy8gQWxpZ25cbiAgICArICcoPzpcXFxcbigoPzooPyEgKlxcXFxufGhyfGhlYWRpbmd8YmxvY2txdW90ZXxjb2RlfGZlbmNlc3xsaXN0fGh0bWwpLiooPzpcXFxcbnwkKSkqKVxcXFxuKnwkKScgLy8gQ2VsbHNcblxuICB9KTtcbiAgYmxvY2skMS5nZm0udGFibGUgPSBlZGl0KGJsb2NrJDEuZ2ZtLnRhYmxlKS5yZXBsYWNlKCdocicsIGJsb2NrJDEuaHIpLnJlcGxhY2UoJ2hlYWRpbmcnLCAnIHswLDN9I3sxLDZ9ICcpLnJlcGxhY2UoJ2Jsb2NrcXVvdGUnLCAnIHswLDN9PicpLnJlcGxhY2UoJ2NvZGUnLCAnIHs0fVteXFxcXG5dJykucmVwbGFjZSgnZmVuY2VzJywgJyB7MCwzfSg/OmB7Myx9KD89W15gXFxcXG5dKlxcXFxuKXx+ezMsfSlbXlxcXFxuXSpcXFxcbicpLnJlcGxhY2UoJ2xpc3QnLCAnIHswLDN9KD86WyorLV18MVsuKV0pICcpIC8vIG9ubHkgbGlzdHMgc3RhcnRpbmcgZnJvbSAxIGNhbiBpbnRlcnJ1cHRcbiAgLnJlcGxhY2UoJ2h0bWwnLCAnPC8/KD86dGFnKSg/OiArfFxcXFxufC8/Pil8PCg/OnNjcmlwdHxwcmV8c3R5bGV8dGV4dGFyZWF8IS0tKScpLnJlcGxhY2UoJ3RhZycsIGJsb2NrJDEuX3RhZykgLy8gdGFibGVzIGNhbiBiZSBpbnRlcnJ1cHRlZCBieSB0eXBlICg2KSBodG1sIGJsb2Nrc1xuICAuZ2V0UmVnZXgoKTtcbiAgLyoqXG4gICAqIFBlZGFudGljIGdyYW1tYXIgKG9yaWdpbmFsIEpvaG4gR3J1YmVyJ3MgbG9vc2UgbWFya2Rvd24gc3BlY2lmaWNhdGlvbilcbiAgICovXG5cbiAgYmxvY2skMS5wZWRhbnRpYyA9IG1lcmdlJDEoe30sIGJsb2NrJDEubm9ybWFsLCB7XG4gICAgaHRtbDogZWRpdCgnXiAqKD86Y29tbWVudCAqKD86XFxcXG58XFxcXHMqJCknICsgJ3w8KHRhZylbXFxcXHNcXFxcU10rPzwvXFxcXDE+ICooPzpcXFxcbnsyLH18XFxcXHMqJCknIC8vIGNsb3NlZCB0YWdcbiAgICArICd8PHRhZyg/OlwiW15cIl0qXCJ8XFwnW15cXCddKlxcJ3xcXFxcc1teXFwnXCIvPlxcXFxzXSopKj8vPz4gKig/OlxcXFxuezIsfXxcXFxccyokKSknKS5yZXBsYWNlKCdjb21tZW50JywgYmxvY2skMS5fY29tbWVudCkucmVwbGFjZSgvdGFnL2csICcoPyEoPzonICsgJ2F8ZW18c3Ryb25nfHNtYWxsfHN8Y2l0ZXxxfGRmbnxhYmJyfGRhdGF8dGltZXxjb2RlfHZhcnxzYW1wfGtiZHxzdWInICsgJ3xzdXB8aXxifHV8bWFya3xydWJ5fHJ0fHJwfGJkaXxiZG98c3Bhbnxicnx3YnJ8aW5zfGRlbHxpbWcpJyArICdcXFxcYilcXFxcdysoPyE6fFteXFxcXHdcXFxcc0BdKkApXFxcXGInKS5nZXRSZWdleCgpLFxuICAgIGRlZjogL14gKlxcWyhbXlxcXV0rKVxcXTogKjw/KFteXFxzPl0rKT4/KD86ICsoW1wiKF1bXlxcbl0rW1wiKV0pKT8gKig/Olxcbit8JCkvLFxuICAgIGhlYWRpbmc6IC9eKCN7MSw2fSkoLiopKD86XFxuK3wkKS8sXG4gICAgZmVuY2VzOiBub29wVGVzdCxcbiAgICAvLyBmZW5jZXMgbm90IHN1cHBvcnRlZFxuICAgIHBhcmFncmFwaDogZWRpdChibG9jayQxLm5vcm1hbC5fcGFyYWdyYXBoKS5yZXBsYWNlKCdocicsIGJsb2NrJDEuaHIpLnJlcGxhY2UoJ2hlYWRpbmcnLCAnICojezEsNn0gKlteXFxuXScpLnJlcGxhY2UoJ2xoZWFkaW5nJywgYmxvY2skMS5saGVhZGluZykucmVwbGFjZSgnYmxvY2txdW90ZScsICcgezAsM30+JykucmVwbGFjZSgnfGZlbmNlcycsICcnKS5yZXBsYWNlKCd8bGlzdCcsICcnKS5yZXBsYWNlKCd8aHRtbCcsICcnKS5nZXRSZWdleCgpXG4gIH0pO1xuICAvKipcbiAgICogSW5saW5lLUxldmVsIEdyYW1tYXJcbiAgICovXG5cbiAgdmFyIGlubGluZSQxID0ge1xuICAgIGVzY2FwZTogL15cXFxcKFshXCIjJCUmJygpKissXFwtLi86Ozw9Pj9AXFxbXFxdXFxcXF5fYHt8fX5dKS8sXG4gICAgYXV0b2xpbms6IC9ePChzY2hlbWU6W15cXHNcXHgwMC1cXHgxZjw+XSp8ZW1haWwpPi8sXG4gICAgdXJsOiBub29wVGVzdCxcbiAgICB0YWc6ICdeY29tbWVudCcgKyAnfF48L1thLXpBLVpdW1xcXFx3Oi1dKlxcXFxzKj4nIC8vIHNlbGYtY2xvc2luZyB0YWdcbiAgICArICd8XjxbYS16QS1aXVtcXFxcdy1dKig/OmF0dHJpYnV0ZSkqP1xcXFxzKi8/PicgLy8gb3BlbiB0YWdcbiAgICArICd8XjxcXFxcP1tcXFxcc1xcXFxTXSo/XFxcXD8+JyAvLyBwcm9jZXNzaW5nIGluc3RydWN0aW9uLCBlLmcuIDw/cGhwID8+XG4gICAgKyAnfF48IVthLXpBLVpdK1xcXFxzW1xcXFxzXFxcXFNdKj8+JyAvLyBkZWNsYXJhdGlvbiwgZS5nLiA8IURPQ1RZUEUgaHRtbD5cbiAgICArICd8XjwhXFxcXFtDREFUQVxcXFxbW1xcXFxzXFxcXFNdKj9cXFxcXVxcXFxdPicsXG4gICAgLy8gQ0RBVEEgc2VjdGlvblxuICAgIGxpbms6IC9eIT9cXFsobGFiZWwpXFxdXFwoXFxzKihocmVmKSg/OlxccysodGl0bGUpKT9cXHMqXFwpLyxcbiAgICByZWZsaW5rOiAvXiE/XFxbKGxhYmVsKVxcXVxcWyg/IVxccypcXF0pKCg/OlxcXFxbXFxbXFxdXT98W15cXFtcXF1cXFxcXSkrKVxcXS8sXG4gICAgbm9saW5rOiAvXiE/XFxbKD8hXFxzKlxcXSkoKD86XFxbW15cXFtcXF1dKlxcXXxcXFxcW1xcW1xcXV18W15cXFtcXF1dKSopXFxdKD86XFxbXFxdKT8vLFxuICAgIHJlZmxpbmtTZWFyY2g6ICdyZWZsaW5rfG5vbGluayg/IVxcXFwoKScsXG4gICAgZW1TdHJvbmc6IHtcbiAgICAgIGxEZWxpbTogL14oPzpcXCorKD86KFtwdW5jdF9dKXxbXlxccypdKSl8Xl8rKD86KFtwdW5jdCpdKXwoW15cXHNfXSkpLyxcbiAgICAgIC8vICAgICAgICAoMSkgYW5kICgyKSBjYW4gb25seSBiZSBhIFJpZ2h0IERlbGltaXRlci4gKDMpIGFuZCAoNCkgY2FuIG9ubHkgYmUgTGVmdC4gICg1KSBhbmQgKDYpIGNhbiBiZSBlaXRoZXIgTGVmdCBvciBSaWdodC5cbiAgICAgIC8vICAgICAgICAoKSBTa2lwIG9ycGhhbiBkZWxpbSBpbnNpZGUgc3Ryb25nICAgICgxKSAjKioqICAgICAgICAgICAgICAgICgyKSBhKioqIywgYSoqKiAgICAgICAgICAgICAgICAgICAoMykgIyoqKmEsICoqKmEgICAgICAgICAgICAgICAgICg0KSAqKiojICAgICAgICAgICAgICAoNSkgIyoqKiMgICAgICAgICAgICAgICAgICg2KSBhKioqYVxuICAgICAgckRlbGltQXN0OiAvXlteXypdKj9cXF9cXF9bXl8qXSo/XFwqW15fKl0qPyg/PVxcX1xcXyl8W3B1bmN0X10oXFwqKykoPz1bXFxzXXwkKXxbXnB1bmN0Kl9cXHNdKFxcKispKD89W3B1bmN0X1xcc118JCl8W3B1bmN0X1xcc10oXFwqKykoPz1bXnB1bmN0Kl9cXHNdKXxbXFxzXShcXCorKSg/PVtwdW5jdF9dKXxbcHVuY3RfXShcXCorKSg/PVtwdW5jdF9dKXxbXnB1bmN0Kl9cXHNdKFxcKispKD89W15wdW5jdCpfXFxzXSkvLFxuICAgICAgckRlbGltVW5kOiAvXlteXypdKj9cXCpcXCpbXl8qXSo/XFxfW15fKl0qPyg/PVxcKlxcKil8W3B1bmN0Kl0oXFxfKykoPz1bXFxzXXwkKXxbXnB1bmN0Kl9cXHNdKFxcXyspKD89W3B1bmN0Klxcc118JCl8W3B1bmN0Klxcc10oXFxfKykoPz1bXnB1bmN0Kl9cXHNdKXxbXFxzXShcXF8rKSg/PVtwdW5jdCpdKXxbcHVuY3QqXShcXF8rKSg/PVtwdW5jdCpdKS8gLy8gXi0gTm90IGFsbG93ZWQgZm9yIF9cblxuICAgIH0sXG4gICAgY29kZTogL14oYCspKFteYF18W15gXVtcXHNcXFNdKj9bXmBdKVxcMSg/IWApLyxcbiAgICBicjogL14oIHsyLH18XFxcXClcXG4oPyFcXHMqJCkvLFxuICAgIGRlbDogbm9vcFRlc3QsXG4gICAgdGV4dDogL14oYCt8W15gXSkoPzooPz0gezIsfVxcbil8W1xcc1xcU10qPyg/Oig/PVtcXFxcPCFcXFtgKl9dfFxcYl98JCl8W14gXSg/PSB7Mix9XFxuKSkpLyxcbiAgICBwdW5jdHVhdGlvbjogL14oW1xcc3B1bmN0dWF0aW9uXSkvXG4gIH07IC8vIGxpc3Qgb2YgcHVuY3R1YXRpb24gbWFya3MgZnJvbSBDb21tb25NYXJrIHNwZWNcbiAgLy8gd2l0aG91dCAqIGFuZCBfIHRvIGhhbmRsZSB0aGUgZGlmZmVyZW50IGVtcGhhc2lzIG1hcmtlcnMgKiBhbmQgX1xuXG4gIGlubGluZSQxLl9wdW5jdHVhdGlvbiA9ICchXCIjJCUmXFwnKCkrXFxcXC0uLC86Ozw9Pj9AXFxcXFtcXFxcXWBee3x9fic7XG4gIGlubGluZSQxLnB1bmN0dWF0aW9uID0gZWRpdChpbmxpbmUkMS5wdW5jdHVhdGlvbikucmVwbGFjZSgvcHVuY3R1YXRpb24vZywgaW5saW5lJDEuX3B1bmN0dWF0aW9uKS5nZXRSZWdleCgpOyAvLyBzZXF1ZW5jZXMgZW0gc2hvdWxkIHNraXAgb3ZlciBbdGl0bGVdKGxpbmspLCBgY29kZWAsIDxodG1sPlxuXG4gIGlubGluZSQxLmJsb2NrU2tpcCA9IC9cXFtbXlxcXV0qP1xcXVxcKFteXFwpXSo/XFwpfGBbXmBdKj9gfDxbXj5dKj8+L2c7XG4gIGlubGluZSQxLmVzY2FwZWRFbVN0ID0gL1xcXFxcXCp8XFxcXF8vZztcbiAgaW5saW5lJDEuX2NvbW1lbnQgPSBlZGl0KGJsb2NrJDEuX2NvbW1lbnQpLnJlcGxhY2UoJyg/Oi0tPnwkKScsICctLT4nKS5nZXRSZWdleCgpO1xuICBpbmxpbmUkMS5lbVN0cm9uZy5sRGVsaW0gPSBlZGl0KGlubGluZSQxLmVtU3Ryb25nLmxEZWxpbSkucmVwbGFjZSgvcHVuY3QvZywgaW5saW5lJDEuX3B1bmN0dWF0aW9uKS5nZXRSZWdleCgpO1xuICBpbmxpbmUkMS5lbVN0cm9uZy5yRGVsaW1Bc3QgPSBlZGl0KGlubGluZSQxLmVtU3Ryb25nLnJEZWxpbUFzdCwgJ2cnKS5yZXBsYWNlKC9wdW5jdC9nLCBpbmxpbmUkMS5fcHVuY3R1YXRpb24pLmdldFJlZ2V4KCk7XG4gIGlubGluZSQxLmVtU3Ryb25nLnJEZWxpbVVuZCA9IGVkaXQoaW5saW5lJDEuZW1TdHJvbmcuckRlbGltVW5kLCAnZycpLnJlcGxhY2UoL3B1bmN0L2csIGlubGluZSQxLl9wdW5jdHVhdGlvbikuZ2V0UmVnZXgoKTtcbiAgaW5saW5lJDEuX2VzY2FwZXMgPSAvXFxcXChbIVwiIyQlJicoKSorLFxcLS4vOjs8PT4/QFxcW1xcXVxcXFxeX2B7fH1+XSkvZztcbiAgaW5saW5lJDEuX3NjaGVtZSA9IC9bYS16QS1aXVthLXpBLVowLTkrLi1dezEsMzF9LztcbiAgaW5saW5lJDEuX2VtYWlsID0gL1thLXpBLVowLTkuISMkJSYnKisvPT9eX2B7fH1+LV0rKEApW2EtekEtWjAtOV0oPzpbYS16QS1aMC05LV17MCw2MX1bYS16QS1aMC05XSk/KD86XFwuW2EtekEtWjAtOV0oPzpbYS16QS1aMC05LV17MCw2MX1bYS16QS1aMC05XSk/KSsoPyFbLV9dKS87XG4gIGlubGluZSQxLmF1dG9saW5rID0gZWRpdChpbmxpbmUkMS5hdXRvbGluaykucmVwbGFjZSgnc2NoZW1lJywgaW5saW5lJDEuX3NjaGVtZSkucmVwbGFjZSgnZW1haWwnLCBpbmxpbmUkMS5fZW1haWwpLmdldFJlZ2V4KCk7XG4gIGlubGluZSQxLl9hdHRyaWJ1dGUgPSAvXFxzK1thLXpBLVo6X11bXFx3LjotXSooPzpcXHMqPVxccypcIlteXCJdKlwifFxccyo9XFxzKidbXiddKid8XFxzKj1cXHMqW15cXHNcIic9PD5gXSspPy87XG4gIGlubGluZSQxLnRhZyA9IGVkaXQoaW5saW5lJDEudGFnKS5yZXBsYWNlKCdjb21tZW50JywgaW5saW5lJDEuX2NvbW1lbnQpLnJlcGxhY2UoJ2F0dHJpYnV0ZScsIGlubGluZSQxLl9hdHRyaWJ1dGUpLmdldFJlZ2V4KCk7XG4gIGlubGluZSQxLl9sYWJlbCA9IC8oPzpcXFsoPzpcXFxcLnxbXlxcW1xcXVxcXFxdKSpcXF18XFxcXC58YFteYF0qYHxbXlxcW1xcXVxcXFxgXSkqPy87XG4gIGlubGluZSQxLl9ocmVmID0gLzwoPzpcXFxcLnxbXlxcbjw+XFxcXF0pKz58W15cXHNcXHgwMC1cXHgxZl0qLztcbiAgaW5saW5lJDEuX3RpdGxlID0gL1wiKD86XFxcXFwiP3xbXlwiXFxcXF0pKlwifCcoPzpcXFxcJz98W14nXFxcXF0pKid8XFwoKD86XFxcXFxcKT98W14pXFxcXF0pKlxcKS87XG4gIGlubGluZSQxLmxpbmsgPSBlZGl0KGlubGluZSQxLmxpbmspLnJlcGxhY2UoJ2xhYmVsJywgaW5saW5lJDEuX2xhYmVsKS5yZXBsYWNlKCdocmVmJywgaW5saW5lJDEuX2hyZWYpLnJlcGxhY2UoJ3RpdGxlJywgaW5saW5lJDEuX3RpdGxlKS5nZXRSZWdleCgpO1xuICBpbmxpbmUkMS5yZWZsaW5rID0gZWRpdChpbmxpbmUkMS5yZWZsaW5rKS5yZXBsYWNlKCdsYWJlbCcsIGlubGluZSQxLl9sYWJlbCkuZ2V0UmVnZXgoKTtcbiAgaW5saW5lJDEucmVmbGlua1NlYXJjaCA9IGVkaXQoaW5saW5lJDEucmVmbGlua1NlYXJjaCwgJ2cnKS5yZXBsYWNlKCdyZWZsaW5rJywgaW5saW5lJDEucmVmbGluaykucmVwbGFjZSgnbm9saW5rJywgaW5saW5lJDEubm9saW5rKS5nZXRSZWdleCgpO1xuICAvKipcbiAgICogTm9ybWFsIElubGluZSBHcmFtbWFyXG4gICAqL1xuXG4gIGlubGluZSQxLm5vcm1hbCA9IG1lcmdlJDEoe30sIGlubGluZSQxKTtcbiAgLyoqXG4gICAqIFBlZGFudGljIElubGluZSBHcmFtbWFyXG4gICAqL1xuXG4gIGlubGluZSQxLnBlZGFudGljID0gbWVyZ2UkMSh7fSwgaW5saW5lJDEubm9ybWFsLCB7XG4gICAgc3Ryb25nOiB7XG4gICAgICBzdGFydDogL15fX3xcXCpcXCovLFxuICAgICAgbWlkZGxlOiAvXl9fKD89XFxTKShbXFxzXFxTXSo/XFxTKV9fKD8hXyl8XlxcKlxcKig/PVxcUykoW1xcc1xcU10qP1xcUylcXCpcXCooPyFcXCopLyxcbiAgICAgIGVuZEFzdDogL1xcKlxcKig/IVxcKikvZyxcbiAgICAgIGVuZFVuZDogL19fKD8hXykvZ1xuICAgIH0sXG4gICAgZW06IHtcbiAgICAgIHN0YXJ0OiAvXl98XFwqLyxcbiAgICAgIG1pZGRsZTogL14oKVxcKig/PVxcUykoW1xcc1xcU10qP1xcUylcXCooPyFcXCopfF5fKD89XFxTKShbXFxzXFxTXSo/XFxTKV8oPyFfKS8sXG4gICAgICBlbmRBc3Q6IC9cXCooPyFcXCopL2csXG4gICAgICBlbmRVbmQ6IC9fKD8hXykvZ1xuICAgIH0sXG4gICAgbGluazogZWRpdCgvXiE/XFxbKGxhYmVsKVxcXVxcKCguKj8pXFwpLykucmVwbGFjZSgnbGFiZWwnLCBpbmxpbmUkMS5fbGFiZWwpLmdldFJlZ2V4KCksXG4gICAgcmVmbGluazogZWRpdCgvXiE/XFxbKGxhYmVsKVxcXVxccypcXFsoW15cXF1dKilcXF0vKS5yZXBsYWNlKCdsYWJlbCcsIGlubGluZSQxLl9sYWJlbCkuZ2V0UmVnZXgoKVxuICB9KTtcbiAgLyoqXG4gICAqIEdGTSBJbmxpbmUgR3JhbW1hclxuICAgKi9cblxuICBpbmxpbmUkMS5nZm0gPSBtZXJnZSQxKHt9LCBpbmxpbmUkMS5ub3JtYWwsIHtcbiAgICBlc2NhcGU6IGVkaXQoaW5saW5lJDEuZXNjYXBlKS5yZXBsYWNlKCddKScsICd+fF0pJykuZ2V0UmVnZXgoKSxcbiAgICBfZXh0ZW5kZWRfZW1haWw6IC9bQS1aYS16MC05Ll8rLV0rKEApW2EtekEtWjAtOS1fXSsoPzpcXC5bYS16QS1aMC05LV9dKlthLXpBLVowLTldKSsoPyFbLV9dKS8sXG4gICAgdXJsOiAvXigoPzpmdHB8aHR0cHM/KTpcXC9cXC98d3d3XFwuKSg/OlthLXpBLVowLTlcXC1dK1xcLj8pK1teXFxzPF0qfF5lbWFpbC8sXG4gICAgX2JhY2twZWRhbDogLyg/OltePyEuLDo7Kl9+KCkmXSt8XFwoW14pXSpcXCl8Jig/IVthLXpBLVowLTldKzskKXxbPyEuLDo7Kl9+KV0rKD8hJCkpKy8sXG4gICAgZGVsOiAvXih+fj8pKD89W15cXHN+XSkoW1xcc1xcU10qP1teXFxzfl0pXFwxKD89W15+XXwkKS8sXG4gICAgdGV4dDogL14oW2B+XSt8W15gfl0pKD86KD89IHsyLH1cXG4pfCg/PVthLXpBLVowLTkuISMkJSYnKitcXC89P19ge1xcfH1+LV0rQCl8W1xcc1xcU10qPyg/Oig/PVtcXFxcPCFcXFtgKn5fXXxcXGJffGh0dHBzPzpcXC9cXC98ZnRwOlxcL1xcL3x3d3dcXC58JCl8W14gXSg/PSB7Mix9XFxuKXxbXmEtekEtWjAtOS4hIyQlJicqK1xcLz0/X2B7XFx8fX4tXSg/PVthLXpBLVowLTkuISMkJSYnKitcXC89P19ge1xcfH1+LV0rQCkpKS9cbiAgfSk7XG4gIGlubGluZSQxLmdmbS51cmwgPSBlZGl0KGlubGluZSQxLmdmbS51cmwsICdpJykucmVwbGFjZSgnZW1haWwnLCBpbmxpbmUkMS5nZm0uX2V4dGVuZGVkX2VtYWlsKS5nZXRSZWdleCgpO1xuICAvKipcbiAgICogR0ZNICsgTGluZSBCcmVha3MgSW5saW5lIEdyYW1tYXJcbiAgICovXG5cbiAgaW5saW5lJDEuYnJlYWtzID0gbWVyZ2UkMSh7fSwgaW5saW5lJDEuZ2ZtLCB7XG4gICAgYnI6IGVkaXQoaW5saW5lJDEuYnIpLnJlcGxhY2UoJ3syLH0nLCAnKicpLmdldFJlZ2V4KCksXG4gICAgdGV4dDogZWRpdChpbmxpbmUkMS5nZm0udGV4dCkucmVwbGFjZSgnXFxcXGJfJywgJ1xcXFxiX3wgezIsfVxcXFxuJykucmVwbGFjZSgvXFx7MixcXH0vZywgJyonKS5nZXRSZWdleCgpXG4gIH0pO1xuICB2YXIgcnVsZXMgPSB7XG4gICAgYmxvY2s6IGJsb2NrJDEsXG4gICAgaW5saW5lOiBpbmxpbmUkMVxuICB9O1xuXG4gIHZhciBUb2tlbml6ZXIkMSA9IFRva2VuaXplcl8xO1xuICB2YXIgZGVmYXVsdHMkMyA9IGRlZmF1bHRzJDUuZXhwb3J0cy5kZWZhdWx0cztcbiAgdmFyIGJsb2NrID0gcnVsZXMuYmxvY2ssXG4gICAgICBpbmxpbmUgPSBydWxlcy5pbmxpbmU7XG4gIHZhciByZXBlYXRTdHJpbmcgPSBoZWxwZXJzLnJlcGVhdFN0cmluZztcbiAgLyoqXG4gICAqIHNtYXJ0eXBhbnRzIHRleHQgcmVwbGFjZW1lbnRcbiAgICovXG5cbiAgZnVuY3Rpb24gc21hcnR5cGFudHModGV4dCkge1xuICAgIHJldHVybiB0ZXh0IC8vIGVtLWRhc2hlc1xuICAgIC5yZXBsYWNlKC8tLS0vZywgXCJcXHUyMDE0XCIpIC8vIGVuLWRhc2hlc1xuICAgIC5yZXBsYWNlKC8tLS9nLCBcIlxcdTIwMTNcIikgLy8gb3BlbmluZyBzaW5nbGVzXG4gICAgLnJlcGxhY2UoLyhefFstXFx1MjAxNC8oXFxbe1wiXFxzXSknL2csIFwiJDFcXHUyMDE4XCIpIC8vIGNsb3Npbmcgc2luZ2xlcyAmIGFwb3N0cm9waGVzXG4gICAgLnJlcGxhY2UoLycvZywgXCJcXHUyMDE5XCIpIC8vIG9wZW5pbmcgZG91Ymxlc1xuICAgIC5yZXBsYWNlKC8oXnxbLVxcdTIwMTQvKFxcW3tcXHUyMDE4XFxzXSlcIi9nLCBcIiQxXFx1MjAxQ1wiKSAvLyBjbG9zaW5nIGRvdWJsZXNcbiAgICAucmVwbGFjZSgvXCIvZywgXCJcXHUyMDFEXCIpIC8vIGVsbGlwc2VzXG4gICAgLnJlcGxhY2UoL1xcLnszfS9nLCBcIlxcdTIwMjZcIik7XG4gIH1cbiAgLyoqXG4gICAqIG1hbmdsZSBlbWFpbCBhZGRyZXNzZXNcbiAgICovXG5cblxuICBmdW5jdGlvbiBtYW5nbGUodGV4dCkge1xuICAgIHZhciBvdXQgPSAnJyxcbiAgICAgICAgaSxcbiAgICAgICAgY2g7XG4gICAgdmFyIGwgPSB0ZXh0Lmxlbmd0aDtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBsOyBpKyspIHtcbiAgICAgIGNoID0gdGV4dC5jaGFyQ29kZUF0KGkpO1xuXG4gICAgICBpZiAoTWF0aC5yYW5kb20oKSA+IDAuNSkge1xuICAgICAgICBjaCA9ICd4JyArIGNoLnRvU3RyaW5nKDE2KTtcbiAgICAgIH1cblxuICAgICAgb3V0ICs9ICcmIycgKyBjaCArICc7JztcbiAgICB9XG5cbiAgICByZXR1cm4gb3V0O1xuICB9XG4gIC8qKlxuICAgKiBCbG9jayBMZXhlclxuICAgKi9cblxuXG4gIHZhciBMZXhlcl8xID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBMZXhlcihvcHRpb25zKSB7XG4gICAgICB0aGlzLnRva2VucyA9IFtdO1xuICAgICAgdGhpcy50b2tlbnMubGlua3MgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucyB8fCBkZWZhdWx0cyQzO1xuICAgICAgdGhpcy5vcHRpb25zLnRva2VuaXplciA9IHRoaXMub3B0aW9ucy50b2tlbml6ZXIgfHwgbmV3IFRva2VuaXplciQxKCk7XG4gICAgICB0aGlzLnRva2VuaXplciA9IHRoaXMub3B0aW9ucy50b2tlbml6ZXI7XG4gICAgICB0aGlzLnRva2VuaXplci5vcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgICAgdGhpcy50b2tlbml6ZXIubGV4ZXIgPSB0aGlzO1xuICAgICAgdGhpcy5pbmxpbmVRdWV1ZSA9IFtdO1xuICAgICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgICAgaW5MaW5rOiBmYWxzZSxcbiAgICAgICAgaW5SYXdCbG9jazogZmFsc2UsXG4gICAgICAgIHRvcDogdHJ1ZVxuICAgICAgfTtcbiAgICAgIHZhciBydWxlcyA9IHtcbiAgICAgICAgYmxvY2s6IGJsb2NrLm5vcm1hbCxcbiAgICAgICAgaW5saW5lOiBpbmxpbmUubm9ybWFsXG4gICAgICB9O1xuXG4gICAgICBpZiAodGhpcy5vcHRpb25zLnBlZGFudGljKSB7XG4gICAgICAgIHJ1bGVzLmJsb2NrID0gYmxvY2sucGVkYW50aWM7XG4gICAgICAgIHJ1bGVzLmlubGluZSA9IGlubGluZS5wZWRhbnRpYztcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5vcHRpb25zLmdmbSkge1xuICAgICAgICBydWxlcy5ibG9jayA9IGJsb2NrLmdmbTtcblxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmJyZWFrcykge1xuICAgICAgICAgIHJ1bGVzLmlubGluZSA9IGlubGluZS5icmVha3M7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcnVsZXMuaW5saW5lID0gaW5saW5lLmdmbTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0aGlzLnRva2VuaXplci5ydWxlcyA9IHJ1bGVzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFeHBvc2UgUnVsZXNcbiAgICAgKi9cblxuXG4gICAgLyoqXG4gICAgICogU3RhdGljIExleCBNZXRob2RcbiAgICAgKi9cbiAgICBMZXhlci5sZXggPSBmdW5jdGlvbiBsZXgoc3JjLCBvcHRpb25zKSB7XG4gICAgICB2YXIgbGV4ZXIgPSBuZXcgTGV4ZXIob3B0aW9ucyk7XG4gICAgICByZXR1cm4gbGV4ZXIubGV4KHNyYyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN0YXRpYyBMZXggSW5saW5lIE1ldGhvZFxuICAgICAqL1xuICAgIDtcblxuICAgIExleGVyLmxleElubGluZSA9IGZ1bmN0aW9uIGxleElubGluZShzcmMsIG9wdGlvbnMpIHtcbiAgICAgIHZhciBsZXhlciA9IG5ldyBMZXhlcihvcHRpb25zKTtcbiAgICAgIHJldHVybiBsZXhlci5pbmxpbmVUb2tlbnMoc3JjKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUHJlcHJvY2Vzc2luZ1xuICAgICAqL1xuICAgIDtcblxuICAgIHZhciBfcHJvdG8gPSBMZXhlci5wcm90b3R5cGU7XG5cbiAgICBfcHJvdG8ubGV4ID0gZnVuY3Rpb24gbGV4KHNyYykge1xuICAgICAgc3JjID0gc3JjLnJlcGxhY2UoL1xcclxcbnxcXHIvZywgJ1xcbicpLnJlcGxhY2UoL1xcdC9nLCAnICAgICcpO1xuICAgICAgdGhpcy5ibG9ja1Rva2VucyhzcmMsIHRoaXMudG9rZW5zKTtcbiAgICAgIHZhciBuZXh0O1xuXG4gICAgICB3aGlsZSAobmV4dCA9IHRoaXMuaW5saW5lUXVldWUuc2hpZnQoKSkge1xuICAgICAgICB0aGlzLmlubGluZVRva2VucyhuZXh0LnNyYywgbmV4dC50b2tlbnMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy50b2tlbnM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExleGluZ1xuICAgICAqL1xuICAgIDtcblxuICAgIF9wcm90by5ibG9ja1Rva2VucyA9IGZ1bmN0aW9uIGJsb2NrVG9rZW5zKHNyYywgdG9rZW5zKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICBpZiAodG9rZW5zID09PSB2b2lkIDApIHtcbiAgICAgICAgdG9rZW5zID0gW107XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMucGVkYW50aWMpIHtcbiAgICAgICAgc3JjID0gc3JjLnJlcGxhY2UoL14gKyQvZ20sICcnKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHRva2VuLCBsYXN0VG9rZW4sIGN1dFNyYywgbGFzdFBhcmFncmFwaENsaXBwZWQ7XG5cbiAgICAgIHdoaWxlIChzcmMpIHtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5leHRlbnNpb25zICYmIHRoaXMub3B0aW9ucy5leHRlbnNpb25zLmJsb2NrICYmIHRoaXMub3B0aW9ucy5leHRlbnNpb25zLmJsb2NrLnNvbWUoZnVuY3Rpb24gKGV4dFRva2VuaXplcikge1xuICAgICAgICAgIGlmICh0b2tlbiA9IGV4dFRva2VuaXplci5jYWxsKHtcbiAgICAgICAgICAgIGxleGVyOiBfdGhpc1xuICAgICAgICAgIH0sIHNyYywgdG9rZW5zKSkge1xuICAgICAgICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyh0b2tlbi5yYXcubGVuZ3RoKTtcbiAgICAgICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSkpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfSAvLyBuZXdsaW5lXG5cblxuICAgICAgICBpZiAodG9rZW4gPSB0aGlzLnRva2VuaXplci5zcGFjZShzcmMpKSB7XG4gICAgICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyh0b2tlbi5yYXcubGVuZ3RoKTtcblxuICAgICAgICAgIGlmICh0b2tlbi50eXBlKSB7XG4gICAgICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH0gLy8gY29kZVxuXG5cbiAgICAgICAgaWYgKHRva2VuID0gdGhpcy50b2tlbml6ZXIuY29kZShzcmMpKSB7XG4gICAgICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyh0b2tlbi5yYXcubGVuZ3RoKTtcbiAgICAgICAgICBsYXN0VG9rZW4gPSB0b2tlbnNbdG9rZW5zLmxlbmd0aCAtIDFdOyAvLyBBbiBpbmRlbnRlZCBjb2RlIGJsb2NrIGNhbm5vdCBpbnRlcnJ1cHQgYSBwYXJhZ3JhcGguXG5cbiAgICAgICAgICBpZiAobGFzdFRva2VuICYmIChsYXN0VG9rZW4udHlwZSA9PT0gJ3BhcmFncmFwaCcgfHwgbGFzdFRva2VuLnR5cGUgPT09ICd0ZXh0JykpIHtcbiAgICAgICAgICAgIGxhc3RUb2tlbi5yYXcgKz0gJ1xcbicgKyB0b2tlbi5yYXc7XG4gICAgICAgICAgICBsYXN0VG9rZW4udGV4dCArPSAnXFxuJyArIHRva2VuLnRleHQ7XG4gICAgICAgICAgICB0aGlzLmlubGluZVF1ZXVlW3RoaXMuaW5saW5lUXVldWUubGVuZ3RoIC0gMV0uc3JjID0gbGFzdFRva2VuLnRleHQ7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfSAvLyBmZW5jZXNcblxuXG4gICAgICAgIGlmICh0b2tlbiA9IHRoaXMudG9rZW5pemVyLmZlbmNlcyhzcmMpKSB7XG4gICAgICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyh0b2tlbi5yYXcubGVuZ3RoKTtcbiAgICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH0gLy8gaGVhZGluZ1xuXG5cbiAgICAgICAgaWYgKHRva2VuID0gdGhpcy50b2tlbml6ZXIuaGVhZGluZyhzcmMpKSB7XG4gICAgICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyh0b2tlbi5yYXcubGVuZ3RoKTtcbiAgICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH0gLy8gaHJcblxuXG4gICAgICAgIGlmICh0b2tlbiA9IHRoaXMudG9rZW5pemVyLmhyKHNyYykpIHtcbiAgICAgICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKHRva2VuLnJhdy5sZW5ndGgpO1xuICAgICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfSAvLyBibG9ja3F1b3RlXG5cblxuICAgICAgICBpZiAodG9rZW4gPSB0aGlzLnRva2VuaXplci5ibG9ja3F1b3RlKHNyYykpIHtcbiAgICAgICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKHRva2VuLnJhdy5sZW5ndGgpO1xuICAgICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfSAvLyBsaXN0XG5cblxuICAgICAgICBpZiAodG9rZW4gPSB0aGlzLnRva2VuaXplci5saXN0KHNyYykpIHtcbiAgICAgICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKHRva2VuLnJhdy5sZW5ndGgpO1xuICAgICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfSAvLyBodG1sXG5cblxuICAgICAgICBpZiAodG9rZW4gPSB0aGlzLnRva2VuaXplci5odG1sKHNyYykpIHtcbiAgICAgICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKHRva2VuLnJhdy5sZW5ndGgpO1xuICAgICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfSAvLyBkZWZcblxuXG4gICAgICAgIGlmICh0b2tlbiA9IHRoaXMudG9rZW5pemVyLmRlZihzcmMpKSB7XG4gICAgICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyh0b2tlbi5yYXcubGVuZ3RoKTtcbiAgICAgICAgICBsYXN0VG9rZW4gPSB0b2tlbnNbdG9rZW5zLmxlbmd0aCAtIDFdO1xuXG4gICAgICAgICAgaWYgKGxhc3RUb2tlbiAmJiAobGFzdFRva2VuLnR5cGUgPT09ICdwYXJhZ3JhcGgnIHx8IGxhc3RUb2tlbi50eXBlID09PSAndGV4dCcpKSB7XG4gICAgICAgICAgICBsYXN0VG9rZW4ucmF3ICs9ICdcXG4nICsgdG9rZW4ucmF3O1xuICAgICAgICAgICAgbGFzdFRva2VuLnRleHQgKz0gJ1xcbicgKyB0b2tlbi5yYXc7XG4gICAgICAgICAgICB0aGlzLmlubGluZVF1ZXVlW3RoaXMuaW5saW5lUXVldWUubGVuZ3RoIC0gMV0uc3JjID0gbGFzdFRva2VuLnRleHQ7XG4gICAgICAgICAgfSBlbHNlIGlmICghdGhpcy50b2tlbnMubGlua3NbdG9rZW4udGFnXSkge1xuICAgICAgICAgICAgdGhpcy50b2tlbnMubGlua3NbdG9rZW4udGFnXSA9IHtcbiAgICAgICAgICAgICAgaHJlZjogdG9rZW4uaHJlZixcbiAgICAgICAgICAgICAgdGl0bGU6IHRva2VuLnRpdGxlXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9IC8vIHRhYmxlIChnZm0pXG5cblxuICAgICAgICBpZiAodG9rZW4gPSB0aGlzLnRva2VuaXplci50YWJsZShzcmMpKSB7XG4gICAgICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyh0b2tlbi5yYXcubGVuZ3RoKTtcbiAgICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH0gLy8gbGhlYWRpbmdcblxuXG4gICAgICAgIGlmICh0b2tlbiA9IHRoaXMudG9rZW5pemVyLmxoZWFkaW5nKHNyYykpIHtcbiAgICAgICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKHRva2VuLnJhdy5sZW5ndGgpO1xuICAgICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfSAvLyB0b3AtbGV2ZWwgcGFyYWdyYXBoXG4gICAgICAgIC8vIHByZXZlbnQgcGFyYWdyYXBoIGNvbnN1bWluZyBleHRlbnNpb25zIGJ5IGNsaXBwaW5nICdzcmMnIHRvIGV4dGVuc2lvbiBzdGFydFxuXG5cbiAgICAgICAgY3V0U3JjID0gc3JjO1xuXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuZXh0ZW5zaW9ucyAmJiB0aGlzLm9wdGlvbnMuZXh0ZW5zaW9ucy5zdGFydEJsb2NrKSB7XG4gICAgICAgICAgKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBzdGFydEluZGV4ID0gSW5maW5pdHk7XG4gICAgICAgICAgICB2YXIgdGVtcFNyYyA9IHNyYy5zbGljZSgxKTtcbiAgICAgICAgICAgIHZhciB0ZW1wU3RhcnQgPSB2b2lkIDA7XG5cbiAgICAgICAgICAgIF90aGlzLm9wdGlvbnMuZXh0ZW5zaW9ucy5zdGFydEJsb2NrLmZvckVhY2goZnVuY3Rpb24gKGdldFN0YXJ0SW5kZXgpIHtcbiAgICAgICAgICAgICAgdGVtcFN0YXJ0ID0gZ2V0U3RhcnRJbmRleC5jYWxsKHtcbiAgICAgICAgICAgICAgICBsZXhlcjogdGhpc1xuICAgICAgICAgICAgICB9LCB0ZW1wU3JjKTtcblxuICAgICAgICAgICAgICBpZiAodHlwZW9mIHRlbXBTdGFydCA9PT0gJ251bWJlcicgJiYgdGVtcFN0YXJ0ID49IDApIHtcbiAgICAgICAgICAgICAgICBzdGFydEluZGV4ID0gTWF0aC5taW4oc3RhcnRJbmRleCwgdGVtcFN0YXJ0KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGlmIChzdGFydEluZGV4IDwgSW5maW5pdHkgJiYgc3RhcnRJbmRleCA+PSAwKSB7XG4gICAgICAgICAgICAgIGN1dFNyYyA9IHNyYy5zdWJzdHJpbmcoMCwgc3RhcnRJbmRleCArIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5zdGF0ZS50b3AgJiYgKHRva2VuID0gdGhpcy50b2tlbml6ZXIucGFyYWdyYXBoKGN1dFNyYykpKSB7XG4gICAgICAgICAgbGFzdFRva2VuID0gdG9rZW5zW3Rva2Vucy5sZW5ndGggLSAxXTtcblxuICAgICAgICAgIGlmIChsYXN0UGFyYWdyYXBoQ2xpcHBlZCAmJiBsYXN0VG9rZW4udHlwZSA9PT0gJ3BhcmFncmFwaCcpIHtcbiAgICAgICAgICAgIGxhc3RUb2tlbi5yYXcgKz0gJ1xcbicgKyB0b2tlbi5yYXc7XG4gICAgICAgICAgICBsYXN0VG9rZW4udGV4dCArPSAnXFxuJyArIHRva2VuLnRleHQ7XG4gICAgICAgICAgICB0aGlzLmlubGluZVF1ZXVlLnBvcCgpO1xuICAgICAgICAgICAgdGhpcy5pbmxpbmVRdWV1ZVt0aGlzLmlubGluZVF1ZXVlLmxlbmd0aCAtIDFdLnNyYyA9IGxhc3RUb2tlbi50ZXh0O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbGFzdFBhcmFncmFwaENsaXBwZWQgPSBjdXRTcmMubGVuZ3RoICE9PSBzcmMubGVuZ3RoO1xuICAgICAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcodG9rZW4ucmF3Lmxlbmd0aCk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH0gLy8gdGV4dFxuXG5cbiAgICAgICAgaWYgKHRva2VuID0gdGhpcy50b2tlbml6ZXIudGV4dChzcmMpKSB7XG4gICAgICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyh0b2tlbi5yYXcubGVuZ3RoKTtcbiAgICAgICAgICBsYXN0VG9rZW4gPSB0b2tlbnNbdG9rZW5zLmxlbmd0aCAtIDFdO1xuXG4gICAgICAgICAgaWYgKGxhc3RUb2tlbiAmJiBsYXN0VG9rZW4udHlwZSA9PT0gJ3RleHQnKSB7XG4gICAgICAgICAgICBsYXN0VG9rZW4ucmF3ICs9ICdcXG4nICsgdG9rZW4ucmF3O1xuICAgICAgICAgICAgbGFzdFRva2VuLnRleHQgKz0gJ1xcbicgKyB0b2tlbi50ZXh0O1xuICAgICAgICAgICAgdGhpcy5pbmxpbmVRdWV1ZS5wb3AoKTtcbiAgICAgICAgICAgIHRoaXMuaW5saW5lUXVldWVbdGhpcy5pbmxpbmVRdWV1ZS5sZW5ndGggLSAxXS5zcmMgPSBsYXN0VG9rZW4udGV4dDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNyYykge1xuICAgICAgICAgIHZhciBlcnJNc2cgPSAnSW5maW5pdGUgbG9vcCBvbiBieXRlOiAnICsgc3JjLmNoYXJDb2RlQXQoMCk7XG5cbiAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLnNpbGVudCkge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihlcnJNc2cpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJNc2cpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0aGlzLnN0YXRlLnRvcCA9IHRydWU7XG4gICAgICByZXR1cm4gdG9rZW5zO1xuICAgIH07XG5cbiAgICBfcHJvdG8uaW5saW5lID0gZnVuY3Rpb24gaW5saW5lKHNyYywgdG9rZW5zKSB7XG4gICAgICB0aGlzLmlubGluZVF1ZXVlLnB1c2goe1xuICAgICAgICBzcmM6IHNyYyxcbiAgICAgICAgdG9rZW5zOiB0b2tlbnNcbiAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBMZXhpbmcvQ29tcGlsaW5nXG4gICAgICovXG4gICAgO1xuXG4gICAgX3Byb3RvLmlubGluZVRva2VucyA9IGZ1bmN0aW9uIGlubGluZVRva2VucyhzcmMsIHRva2Vucykge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIGlmICh0b2tlbnMgPT09IHZvaWQgMCkge1xuICAgICAgICB0b2tlbnMgPSBbXTtcbiAgICAgIH1cblxuICAgICAgdmFyIHRva2VuLCBsYXN0VG9rZW4sIGN1dFNyYzsgLy8gU3RyaW5nIHdpdGggbGlua3MgbWFza2VkIHRvIGF2b2lkIGludGVyZmVyZW5jZSB3aXRoIGVtIGFuZCBzdHJvbmdcblxuICAgICAgdmFyIG1hc2tlZFNyYyA9IHNyYztcbiAgICAgIHZhciBtYXRjaDtcbiAgICAgIHZhciBrZWVwUHJldkNoYXIsIHByZXZDaGFyOyAvLyBNYXNrIG91dCByZWZsaW5rc1xuXG4gICAgICBpZiAodGhpcy50b2tlbnMubGlua3MpIHtcbiAgICAgICAgdmFyIGxpbmtzID0gT2JqZWN0LmtleXModGhpcy50b2tlbnMubGlua3MpO1xuXG4gICAgICAgIGlmIChsaW5rcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgd2hpbGUgKChtYXRjaCA9IHRoaXMudG9rZW5pemVyLnJ1bGVzLmlubGluZS5yZWZsaW5rU2VhcmNoLmV4ZWMobWFza2VkU3JjKSkgIT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKGxpbmtzLmluY2x1ZGVzKG1hdGNoWzBdLnNsaWNlKG1hdGNoWzBdLmxhc3RJbmRleE9mKCdbJykgKyAxLCAtMSkpKSB7XG4gICAgICAgICAgICAgIG1hc2tlZFNyYyA9IG1hc2tlZFNyYy5zbGljZSgwLCBtYXRjaC5pbmRleCkgKyAnWycgKyByZXBlYXRTdHJpbmcoJ2EnLCBtYXRjaFswXS5sZW5ndGggLSAyKSArICddJyArIG1hc2tlZFNyYy5zbGljZSh0aGlzLnRva2VuaXplci5ydWxlcy5pbmxpbmUucmVmbGlua1NlYXJjaC5sYXN0SW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSAvLyBNYXNrIG91dCBvdGhlciBibG9ja3NcblxuXG4gICAgICB3aGlsZSAoKG1hdGNoID0gdGhpcy50b2tlbml6ZXIucnVsZXMuaW5saW5lLmJsb2NrU2tpcC5leGVjKG1hc2tlZFNyYykpICE9IG51bGwpIHtcbiAgICAgICAgbWFza2VkU3JjID0gbWFza2VkU3JjLnNsaWNlKDAsIG1hdGNoLmluZGV4KSArICdbJyArIHJlcGVhdFN0cmluZygnYScsIG1hdGNoWzBdLmxlbmd0aCAtIDIpICsgJ10nICsgbWFza2VkU3JjLnNsaWNlKHRoaXMudG9rZW5pemVyLnJ1bGVzLmlubGluZS5ibG9ja1NraXAubGFzdEluZGV4KTtcbiAgICAgIH0gLy8gTWFzayBvdXQgZXNjYXBlZCBlbSAmIHN0cm9uZyBkZWxpbWl0ZXJzXG5cblxuICAgICAgd2hpbGUgKChtYXRjaCA9IHRoaXMudG9rZW5pemVyLnJ1bGVzLmlubGluZS5lc2NhcGVkRW1TdC5leGVjKG1hc2tlZFNyYykpICE9IG51bGwpIHtcbiAgICAgICAgbWFza2VkU3JjID0gbWFza2VkU3JjLnNsaWNlKDAsIG1hdGNoLmluZGV4KSArICcrKycgKyBtYXNrZWRTcmMuc2xpY2UodGhpcy50b2tlbml6ZXIucnVsZXMuaW5saW5lLmVzY2FwZWRFbVN0Lmxhc3RJbmRleCk7XG4gICAgICB9XG5cbiAgICAgIHdoaWxlIChzcmMpIHtcbiAgICAgICAgaWYgKCFrZWVwUHJldkNoYXIpIHtcbiAgICAgICAgICBwcmV2Q2hhciA9ICcnO1xuICAgICAgICB9XG5cbiAgICAgICAga2VlcFByZXZDaGFyID0gZmFsc2U7IC8vIGV4dGVuc2lvbnNcblxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmV4dGVuc2lvbnMgJiYgdGhpcy5vcHRpb25zLmV4dGVuc2lvbnMuaW5saW5lICYmIHRoaXMub3B0aW9ucy5leHRlbnNpb25zLmlubGluZS5zb21lKGZ1bmN0aW9uIChleHRUb2tlbml6ZXIpIHtcbiAgICAgICAgICBpZiAodG9rZW4gPSBleHRUb2tlbml6ZXIuY2FsbCh7XG4gICAgICAgICAgICBsZXhlcjogX3RoaXMyXG4gICAgICAgICAgfSwgc3JjLCB0b2tlbnMpKSB7XG4gICAgICAgICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKHRva2VuLnJhdy5sZW5ndGgpO1xuICAgICAgICAgICAgdG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9KSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9IC8vIGVzY2FwZVxuXG5cbiAgICAgICAgaWYgKHRva2VuID0gdGhpcy50b2tlbml6ZXIuZXNjYXBlKHNyYykpIHtcbiAgICAgICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKHRva2VuLnJhdy5sZW5ndGgpO1xuICAgICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfSAvLyB0YWdcblxuXG4gICAgICAgIGlmICh0b2tlbiA9IHRoaXMudG9rZW5pemVyLnRhZyhzcmMpKSB7XG4gICAgICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyh0b2tlbi5yYXcubGVuZ3RoKTtcbiAgICAgICAgICBsYXN0VG9rZW4gPSB0b2tlbnNbdG9rZW5zLmxlbmd0aCAtIDFdO1xuXG4gICAgICAgICAgaWYgKGxhc3RUb2tlbiAmJiB0b2tlbi50eXBlID09PSAndGV4dCcgJiYgbGFzdFRva2VuLnR5cGUgPT09ICd0ZXh0Jykge1xuICAgICAgICAgICAgbGFzdFRva2VuLnJhdyArPSB0b2tlbi5yYXc7XG4gICAgICAgICAgICBsYXN0VG9rZW4udGV4dCArPSB0b2tlbi50ZXh0O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH0gLy8gbGlua1xuXG5cbiAgICAgICAgaWYgKHRva2VuID0gdGhpcy50b2tlbml6ZXIubGluayhzcmMpKSB7XG4gICAgICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyh0b2tlbi5yYXcubGVuZ3RoKTtcbiAgICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH0gLy8gcmVmbGluaywgbm9saW5rXG5cblxuICAgICAgICBpZiAodG9rZW4gPSB0aGlzLnRva2VuaXplci5yZWZsaW5rKHNyYywgdGhpcy50b2tlbnMubGlua3MpKSB7XG4gICAgICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyh0b2tlbi5yYXcubGVuZ3RoKTtcbiAgICAgICAgICBsYXN0VG9rZW4gPSB0b2tlbnNbdG9rZW5zLmxlbmd0aCAtIDFdO1xuXG4gICAgICAgICAgaWYgKGxhc3RUb2tlbiAmJiB0b2tlbi50eXBlID09PSAndGV4dCcgJiYgbGFzdFRva2VuLnR5cGUgPT09ICd0ZXh0Jykge1xuICAgICAgICAgICAgbGFzdFRva2VuLnJhdyArPSB0b2tlbi5yYXc7XG4gICAgICAgICAgICBsYXN0VG9rZW4udGV4dCArPSB0b2tlbi50ZXh0O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH0gLy8gZW0gJiBzdHJvbmdcblxuXG4gICAgICAgIGlmICh0b2tlbiA9IHRoaXMudG9rZW5pemVyLmVtU3Ryb25nKHNyYywgbWFza2VkU3JjLCBwcmV2Q2hhcikpIHtcbiAgICAgICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKHRva2VuLnJhdy5sZW5ndGgpO1xuICAgICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfSAvLyBjb2RlXG5cblxuICAgICAgICBpZiAodG9rZW4gPSB0aGlzLnRva2VuaXplci5jb2Rlc3BhbihzcmMpKSB7XG4gICAgICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyh0b2tlbi5yYXcubGVuZ3RoKTtcbiAgICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH0gLy8gYnJcblxuXG4gICAgICAgIGlmICh0b2tlbiA9IHRoaXMudG9rZW5pemVyLmJyKHNyYykpIHtcbiAgICAgICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKHRva2VuLnJhdy5sZW5ndGgpO1xuICAgICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfSAvLyBkZWwgKGdmbSlcblxuXG4gICAgICAgIGlmICh0b2tlbiA9IHRoaXMudG9rZW5pemVyLmRlbChzcmMpKSB7XG4gICAgICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyh0b2tlbi5yYXcubGVuZ3RoKTtcbiAgICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH0gLy8gYXV0b2xpbmtcblxuXG4gICAgICAgIGlmICh0b2tlbiA9IHRoaXMudG9rZW5pemVyLmF1dG9saW5rKHNyYywgbWFuZ2xlKSkge1xuICAgICAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcodG9rZW4ucmF3Lmxlbmd0aCk7XG4gICAgICAgICAgdG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9IC8vIHVybCAoZ2ZtKVxuXG5cbiAgICAgICAgaWYgKCF0aGlzLnN0YXRlLmluTGluayAmJiAodG9rZW4gPSB0aGlzLnRva2VuaXplci51cmwoc3JjLCBtYW5nbGUpKSkge1xuICAgICAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcodG9rZW4ucmF3Lmxlbmd0aCk7XG4gICAgICAgICAgdG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9IC8vIHRleHRcbiAgICAgICAgLy8gcHJldmVudCBpbmxpbmVUZXh0IGNvbnN1bWluZyBleHRlbnNpb25zIGJ5IGNsaXBwaW5nICdzcmMnIHRvIGV4dGVuc2lvbiBzdGFydFxuXG5cbiAgICAgICAgY3V0U3JjID0gc3JjO1xuXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuZXh0ZW5zaW9ucyAmJiB0aGlzLm9wdGlvbnMuZXh0ZW5zaW9ucy5zdGFydElubGluZSkge1xuICAgICAgICAgIChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgc3RhcnRJbmRleCA9IEluZmluaXR5O1xuICAgICAgICAgICAgdmFyIHRlbXBTcmMgPSBzcmMuc2xpY2UoMSk7XG4gICAgICAgICAgICB2YXIgdGVtcFN0YXJ0ID0gdm9pZCAwO1xuXG4gICAgICAgICAgICBfdGhpczIub3B0aW9ucy5leHRlbnNpb25zLnN0YXJ0SW5saW5lLmZvckVhY2goZnVuY3Rpb24gKGdldFN0YXJ0SW5kZXgpIHtcbiAgICAgICAgICAgICAgdGVtcFN0YXJ0ID0gZ2V0U3RhcnRJbmRleC5jYWxsKHtcbiAgICAgICAgICAgICAgICBsZXhlcjogdGhpc1xuICAgICAgICAgICAgICB9LCB0ZW1wU3JjKTtcblxuICAgICAgICAgICAgICBpZiAodHlwZW9mIHRlbXBTdGFydCA9PT0gJ251bWJlcicgJiYgdGVtcFN0YXJ0ID49IDApIHtcbiAgICAgICAgICAgICAgICBzdGFydEluZGV4ID0gTWF0aC5taW4oc3RhcnRJbmRleCwgdGVtcFN0YXJ0KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGlmIChzdGFydEluZGV4IDwgSW5maW5pdHkgJiYgc3RhcnRJbmRleCA+PSAwKSB7XG4gICAgICAgICAgICAgIGN1dFNyYyA9IHNyYy5zdWJzdHJpbmcoMCwgc3RhcnRJbmRleCArIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodG9rZW4gPSB0aGlzLnRva2VuaXplci5pbmxpbmVUZXh0KGN1dFNyYywgc21hcnR5cGFudHMpKSB7XG4gICAgICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyh0b2tlbi5yYXcubGVuZ3RoKTtcblxuICAgICAgICAgIGlmICh0b2tlbi5yYXcuc2xpY2UoLTEpICE9PSAnXycpIHtcbiAgICAgICAgICAgIC8vIFRyYWNrIHByZXZDaGFyIGJlZm9yZSBzdHJpbmcgb2YgX19fXyBzdGFydGVkXG4gICAgICAgICAgICBwcmV2Q2hhciA9IHRva2VuLnJhdy5zbGljZSgtMSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAga2VlcFByZXZDaGFyID0gdHJ1ZTtcbiAgICAgICAgICBsYXN0VG9rZW4gPSB0b2tlbnNbdG9rZW5zLmxlbmd0aCAtIDFdO1xuXG4gICAgICAgICAgaWYgKGxhc3RUb2tlbiAmJiBsYXN0VG9rZW4udHlwZSA9PT0gJ3RleHQnKSB7XG4gICAgICAgICAgICBsYXN0VG9rZW4ucmF3ICs9IHRva2VuLnJhdztcbiAgICAgICAgICAgIGxhc3RUb2tlbi50ZXh0ICs9IHRva2VuLnRleHQ7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzcmMpIHtcbiAgICAgICAgICB2YXIgZXJyTXNnID0gJ0luZmluaXRlIGxvb3Agb24gYnl0ZTogJyArIHNyYy5jaGFyQ29kZUF0KDApO1xuXG4gICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5zaWxlbnQpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyTXNnKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyTXNnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRva2VucztcbiAgICB9O1xuXG4gICAgX2NyZWF0ZUNsYXNzKExleGVyLCBudWxsLCBbe1xuICAgICAga2V5OiBcInJ1bGVzXCIsXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBibG9jazogYmxvY2ssXG4gICAgICAgICAgaW5saW5lOiBpbmxpbmVcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XSk7XG5cbiAgICByZXR1cm4gTGV4ZXI7XG4gIH0oKTtcblxuICB2YXIgZGVmYXVsdHMkMiA9IGRlZmF1bHRzJDUuZXhwb3J0cy5kZWZhdWx0cztcbiAgdmFyIGNsZWFuVXJsID0gaGVscGVycy5jbGVhblVybCxcbiAgICAgIGVzY2FwZSQxID0gaGVscGVycy5lc2NhcGU7XG4gIC8qKlxuICAgKiBSZW5kZXJlclxuICAgKi9cblxuICB2YXIgUmVuZGVyZXJfMSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUmVuZGVyZXIob3B0aW9ucykge1xuICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucyB8fCBkZWZhdWx0cyQyO1xuICAgIH1cblxuICAgIHZhciBfcHJvdG8gPSBSZW5kZXJlci5wcm90b3R5cGU7XG5cbiAgICBfcHJvdG8uY29kZSA9IGZ1bmN0aW9uIGNvZGUoX2NvZGUsIGluZm9zdHJpbmcsIGVzY2FwZWQpIHtcbiAgICAgIHZhciBsYW5nID0gKGluZm9zdHJpbmcgfHwgJycpLm1hdGNoKC9cXFMqLylbMF07XG5cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuaGlnaGxpZ2h0KSB7XG4gICAgICAgIHZhciBvdXQgPSB0aGlzLm9wdGlvbnMuaGlnaGxpZ2h0KF9jb2RlLCBsYW5nKTtcblxuICAgICAgICBpZiAob3V0ICE9IG51bGwgJiYgb3V0ICE9PSBfY29kZSkge1xuICAgICAgICAgIGVzY2FwZWQgPSB0cnVlO1xuICAgICAgICAgIF9jb2RlID0gb3V0O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIF9jb2RlID0gX2NvZGUucmVwbGFjZSgvXFxuJC8sICcnKSArICdcXG4nO1xuXG4gICAgICBpZiAoIWxhbmcpIHtcbiAgICAgICAgcmV0dXJuICc8cHJlPjxjb2RlPicgKyAoZXNjYXBlZCA/IF9jb2RlIDogZXNjYXBlJDEoX2NvZGUsIHRydWUpKSArICc8L2NvZGU+PC9wcmU+XFxuJztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuICc8cHJlPjxjb2RlIGNsYXNzPVwiJyArIHRoaXMub3B0aW9ucy5sYW5nUHJlZml4ICsgZXNjYXBlJDEobGFuZywgdHJ1ZSkgKyAnXCI+JyArIChlc2NhcGVkID8gX2NvZGUgOiBlc2NhcGUkMShfY29kZSwgdHJ1ZSkpICsgJzwvY29kZT48L3ByZT5cXG4nO1xuICAgIH07XG5cbiAgICBfcHJvdG8uYmxvY2txdW90ZSA9IGZ1bmN0aW9uIGJsb2NrcXVvdGUocXVvdGUpIHtcbiAgICAgIHJldHVybiAnPGJsb2NrcXVvdGU+XFxuJyArIHF1b3RlICsgJzwvYmxvY2txdW90ZT5cXG4nO1xuICAgIH07XG5cbiAgICBfcHJvdG8uaHRtbCA9IGZ1bmN0aW9uIGh0bWwoX2h0bWwpIHtcbiAgICAgIHJldHVybiBfaHRtbDtcbiAgICB9O1xuXG4gICAgX3Byb3RvLmhlYWRpbmcgPSBmdW5jdGlvbiBoZWFkaW5nKHRleHQsIGxldmVsLCByYXcsIHNsdWdnZXIpIHtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuaGVhZGVySWRzKSB7XG4gICAgICAgIHJldHVybiAnPGgnICsgbGV2ZWwgKyAnIGlkPVwiJyArIHRoaXMub3B0aW9ucy5oZWFkZXJQcmVmaXggKyBzbHVnZ2VyLnNsdWcocmF3KSArICdcIj4nICsgdGV4dCArICc8L2gnICsgbGV2ZWwgKyAnPlxcbic7XG4gICAgICB9IC8vIGlnbm9yZSBJRHNcblxuXG4gICAgICByZXR1cm4gJzxoJyArIGxldmVsICsgJz4nICsgdGV4dCArICc8L2gnICsgbGV2ZWwgKyAnPlxcbic7XG4gICAgfTtcblxuICAgIF9wcm90by5ociA9IGZ1bmN0aW9uIGhyKCkge1xuICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy54aHRtbCA/ICc8aHIvPlxcbicgOiAnPGhyPlxcbic7XG4gICAgfTtcblxuICAgIF9wcm90by5saXN0ID0gZnVuY3Rpb24gbGlzdChib2R5LCBvcmRlcmVkLCBzdGFydCkge1xuICAgICAgdmFyIHR5cGUgPSBvcmRlcmVkID8gJ29sJyA6ICd1bCcsXG4gICAgICAgICAgc3RhcnRhdHQgPSBvcmRlcmVkICYmIHN0YXJ0ICE9PSAxID8gJyBzdGFydD1cIicgKyBzdGFydCArICdcIicgOiAnJztcbiAgICAgIHJldHVybiAnPCcgKyB0eXBlICsgc3RhcnRhdHQgKyAnPlxcbicgKyBib2R5ICsgJzwvJyArIHR5cGUgKyAnPlxcbic7XG4gICAgfTtcblxuICAgIF9wcm90by5saXN0aXRlbSA9IGZ1bmN0aW9uIGxpc3RpdGVtKHRleHQpIHtcbiAgICAgIHJldHVybiAnPGxpPicgKyB0ZXh0ICsgJzwvbGk+XFxuJztcbiAgICB9O1xuXG4gICAgX3Byb3RvLmNoZWNrYm94ID0gZnVuY3Rpb24gY2hlY2tib3goY2hlY2tlZCkge1xuICAgICAgcmV0dXJuICc8aW5wdXQgJyArIChjaGVja2VkID8gJ2NoZWNrZWQ9XCJcIiAnIDogJycpICsgJ2Rpc2FibGVkPVwiXCIgdHlwZT1cImNoZWNrYm94XCInICsgKHRoaXMub3B0aW9ucy54aHRtbCA/ICcgLycgOiAnJykgKyAnPiAnO1xuICAgIH07XG5cbiAgICBfcHJvdG8ucGFyYWdyYXBoID0gZnVuY3Rpb24gcGFyYWdyYXBoKHRleHQpIHtcbiAgICAgIHJldHVybiAnPHA+JyArIHRleHQgKyAnPC9wPlxcbic7XG4gICAgfTtcblxuICAgIF9wcm90by50YWJsZSA9IGZ1bmN0aW9uIHRhYmxlKGhlYWRlciwgYm9keSkge1xuICAgICAgaWYgKGJvZHkpIGJvZHkgPSAnPHRib2R5PicgKyBib2R5ICsgJzwvdGJvZHk+JztcbiAgICAgIHJldHVybiAnPHRhYmxlPlxcbicgKyAnPHRoZWFkPlxcbicgKyBoZWFkZXIgKyAnPC90aGVhZD5cXG4nICsgYm9keSArICc8L3RhYmxlPlxcbic7XG4gICAgfTtcblxuICAgIF9wcm90by50YWJsZXJvdyA9IGZ1bmN0aW9uIHRhYmxlcm93KGNvbnRlbnQpIHtcbiAgICAgIHJldHVybiAnPHRyPlxcbicgKyBjb250ZW50ICsgJzwvdHI+XFxuJztcbiAgICB9O1xuXG4gICAgX3Byb3RvLnRhYmxlY2VsbCA9IGZ1bmN0aW9uIHRhYmxlY2VsbChjb250ZW50LCBmbGFncykge1xuICAgICAgdmFyIHR5cGUgPSBmbGFncy5oZWFkZXIgPyAndGgnIDogJ3RkJztcbiAgICAgIHZhciB0YWcgPSBmbGFncy5hbGlnbiA/ICc8JyArIHR5cGUgKyAnIGFsaWduPVwiJyArIGZsYWdzLmFsaWduICsgJ1wiPicgOiAnPCcgKyB0eXBlICsgJz4nO1xuICAgICAgcmV0dXJuIHRhZyArIGNvbnRlbnQgKyAnPC8nICsgdHlwZSArICc+XFxuJztcbiAgICB9IC8vIHNwYW4gbGV2ZWwgcmVuZGVyZXJcbiAgICA7XG5cbiAgICBfcHJvdG8uc3Ryb25nID0gZnVuY3Rpb24gc3Ryb25nKHRleHQpIHtcbiAgICAgIHJldHVybiAnPHN0cm9uZz4nICsgdGV4dCArICc8L3N0cm9uZz4nO1xuICAgIH07XG5cbiAgICBfcHJvdG8uZW0gPSBmdW5jdGlvbiBlbSh0ZXh0KSB7XG4gICAgICByZXR1cm4gJzxlbT4nICsgdGV4dCArICc8L2VtPic7XG4gICAgfTtcblxuICAgIF9wcm90by5jb2Rlc3BhbiA9IGZ1bmN0aW9uIGNvZGVzcGFuKHRleHQpIHtcbiAgICAgIHJldHVybiAnPGNvZGU+JyArIHRleHQgKyAnPC9jb2RlPic7XG4gICAgfTtcblxuICAgIF9wcm90by5iciA9IGZ1bmN0aW9uIGJyKCkge1xuICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy54aHRtbCA/ICc8YnIvPicgOiAnPGJyPic7XG4gICAgfTtcblxuICAgIF9wcm90by5kZWwgPSBmdW5jdGlvbiBkZWwodGV4dCkge1xuICAgICAgcmV0dXJuICc8ZGVsPicgKyB0ZXh0ICsgJzwvZGVsPic7XG4gICAgfTtcblxuICAgIF9wcm90by5saW5rID0gZnVuY3Rpb24gbGluayhocmVmLCB0aXRsZSwgdGV4dCkge1xuICAgICAgaHJlZiA9IGNsZWFuVXJsKHRoaXMub3B0aW9ucy5zYW5pdGl6ZSwgdGhpcy5vcHRpb25zLmJhc2VVcmwsIGhyZWYpO1xuXG4gICAgICBpZiAoaHJlZiA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gdGV4dDtcbiAgICAgIH1cblxuICAgICAgdmFyIG91dCA9ICc8YSBocmVmPVwiJyArIGVzY2FwZSQxKGhyZWYpICsgJ1wiJztcblxuICAgICAgaWYgKHRpdGxlKSB7XG4gICAgICAgIG91dCArPSAnIHRpdGxlPVwiJyArIHRpdGxlICsgJ1wiJztcbiAgICAgIH1cblxuICAgICAgb3V0ICs9ICc+JyArIHRleHQgKyAnPC9hPic7XG4gICAgICByZXR1cm4gb3V0O1xuICAgIH07XG5cbiAgICBfcHJvdG8uaW1hZ2UgPSBmdW5jdGlvbiBpbWFnZShocmVmLCB0aXRsZSwgdGV4dCkge1xuICAgICAgaHJlZiA9IGNsZWFuVXJsKHRoaXMub3B0aW9ucy5zYW5pdGl6ZSwgdGhpcy5vcHRpb25zLmJhc2VVcmwsIGhyZWYpO1xuXG4gICAgICBpZiAoaHJlZiA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gdGV4dDtcbiAgICAgIH1cblxuICAgICAgdmFyIG91dCA9ICc8aW1nIHNyYz1cIicgKyBocmVmICsgJ1wiIGFsdD1cIicgKyB0ZXh0ICsgJ1wiJztcblxuICAgICAgaWYgKHRpdGxlKSB7XG4gICAgICAgIG91dCArPSAnIHRpdGxlPVwiJyArIHRpdGxlICsgJ1wiJztcbiAgICAgIH1cblxuICAgICAgb3V0ICs9IHRoaXMub3B0aW9ucy54aHRtbCA/ICcvPicgOiAnPic7XG4gICAgICByZXR1cm4gb3V0O1xuICAgIH07XG5cbiAgICBfcHJvdG8udGV4dCA9IGZ1bmN0aW9uIHRleHQoX3RleHQpIHtcbiAgICAgIHJldHVybiBfdGV4dDtcbiAgICB9O1xuXG4gICAgcmV0dXJuIFJlbmRlcmVyO1xuICB9KCk7XG5cbiAgLyoqXG4gICAqIFRleHRSZW5kZXJlclxuICAgKiByZXR1cm5zIG9ubHkgdGhlIHRleHR1YWwgcGFydCBvZiB0aGUgdG9rZW5cbiAgICovXG5cbiAgdmFyIFRleHRSZW5kZXJlcl8xID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBUZXh0UmVuZGVyZXIoKSB7fVxuXG4gICAgdmFyIF9wcm90byA9IFRleHRSZW5kZXJlci5wcm90b3R5cGU7XG5cbiAgICAvLyBubyBuZWVkIGZvciBibG9jayBsZXZlbCByZW5kZXJlcnNcbiAgICBfcHJvdG8uc3Ryb25nID0gZnVuY3Rpb24gc3Ryb25nKHRleHQpIHtcbiAgICAgIHJldHVybiB0ZXh0O1xuICAgIH07XG5cbiAgICBfcHJvdG8uZW0gPSBmdW5jdGlvbiBlbSh0ZXh0KSB7XG4gICAgICByZXR1cm4gdGV4dDtcbiAgICB9O1xuXG4gICAgX3Byb3RvLmNvZGVzcGFuID0gZnVuY3Rpb24gY29kZXNwYW4odGV4dCkge1xuICAgICAgcmV0dXJuIHRleHQ7XG4gICAgfTtcblxuICAgIF9wcm90by5kZWwgPSBmdW5jdGlvbiBkZWwodGV4dCkge1xuICAgICAgcmV0dXJuIHRleHQ7XG4gICAgfTtcblxuICAgIF9wcm90by5odG1sID0gZnVuY3Rpb24gaHRtbCh0ZXh0KSB7XG4gICAgICByZXR1cm4gdGV4dDtcbiAgICB9O1xuXG4gICAgX3Byb3RvLnRleHQgPSBmdW5jdGlvbiB0ZXh0KF90ZXh0KSB7XG4gICAgICByZXR1cm4gX3RleHQ7XG4gICAgfTtcblxuICAgIF9wcm90by5saW5rID0gZnVuY3Rpb24gbGluayhocmVmLCB0aXRsZSwgdGV4dCkge1xuICAgICAgcmV0dXJuICcnICsgdGV4dDtcbiAgICB9O1xuXG4gICAgX3Byb3RvLmltYWdlID0gZnVuY3Rpb24gaW1hZ2UoaHJlZiwgdGl0bGUsIHRleHQpIHtcbiAgICAgIHJldHVybiAnJyArIHRleHQ7XG4gICAgfTtcblxuICAgIF9wcm90by5iciA9IGZ1bmN0aW9uIGJyKCkge1xuICAgICAgcmV0dXJuICcnO1xuICAgIH07XG5cbiAgICByZXR1cm4gVGV4dFJlbmRlcmVyO1xuICB9KCk7XG5cbiAgLyoqXG4gICAqIFNsdWdnZXIgZ2VuZXJhdGVzIGhlYWRlciBpZFxuICAgKi9cblxuICB2YXIgU2x1Z2dlcl8xID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTbHVnZ2VyKCkge1xuICAgICAgdGhpcy5zZWVuID0ge307XG4gICAgfVxuXG4gICAgdmFyIF9wcm90byA9IFNsdWdnZXIucHJvdG90eXBlO1xuXG4gICAgX3Byb3RvLnNlcmlhbGl6ZSA9IGZ1bmN0aW9uIHNlcmlhbGl6ZSh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlLnRvTG93ZXJDYXNlKCkudHJpbSgpIC8vIHJlbW92ZSBodG1sIHRhZ3NcbiAgICAgIC5yZXBsYWNlKC88WyFcXC9hLXpdLio/Pi9pZywgJycpIC8vIHJlbW92ZSB1bndhbnRlZCBjaGFyc1xuICAgICAgLnJlcGxhY2UoL1tcXHUyMDAwLVxcdTIwNkZcXHUyRTAwLVxcdTJFN0ZcXFxcJyFcIiMkJSYoKSorLC4vOjs8PT4/QFtcXF1eYHt8fX5dL2csICcnKS5yZXBsYWNlKC9cXHMvZywgJy0nKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRmluZHMgdGhlIG5leHQgc2FmZSAodW5pcXVlKSBzbHVnIHRvIHVzZVxuICAgICAqL1xuICAgIDtcblxuICAgIF9wcm90by5nZXROZXh0U2FmZVNsdWcgPSBmdW5jdGlvbiBnZXROZXh0U2FmZVNsdWcob3JpZ2luYWxTbHVnLCBpc0RyeVJ1bikge1xuICAgICAgdmFyIHNsdWcgPSBvcmlnaW5hbFNsdWc7XG4gICAgICB2YXIgb2NjdXJlbmNlQWNjdW11bGF0b3IgPSAwO1xuXG4gICAgICBpZiAodGhpcy5zZWVuLmhhc093blByb3BlcnR5KHNsdWcpKSB7XG4gICAgICAgIG9jY3VyZW5jZUFjY3VtdWxhdG9yID0gdGhpcy5zZWVuW29yaWdpbmFsU2x1Z107XG5cbiAgICAgICAgZG8ge1xuICAgICAgICAgIG9jY3VyZW5jZUFjY3VtdWxhdG9yKys7XG4gICAgICAgICAgc2x1ZyA9IG9yaWdpbmFsU2x1ZyArICctJyArIG9jY3VyZW5jZUFjY3VtdWxhdG9yO1xuICAgICAgICB9IHdoaWxlICh0aGlzLnNlZW4uaGFzT3duUHJvcGVydHkoc2x1ZykpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWlzRHJ5UnVuKSB7XG4gICAgICAgIHRoaXMuc2VlbltvcmlnaW5hbFNsdWddID0gb2NjdXJlbmNlQWNjdW11bGF0b3I7XG4gICAgICAgIHRoaXMuc2VlbltzbHVnXSA9IDA7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzbHVnO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0IHN0cmluZyB0byB1bmlxdWUgaWRcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gb3B0aW9ucy5kcnlydW4gR2VuZXJhdGVzIHRoZSBuZXh0IHVuaXF1ZSBzbHVnIHdpdGhvdXQgdXBkYXRpbmcgdGhlIGludGVybmFsIGFjY3VtdWxhdG9yLlxuICAgICAqL1xuICAgIDtcblxuICAgIF9wcm90by5zbHVnID0gZnVuY3Rpb24gc2x1Zyh2YWx1ZSwgb3B0aW9ucykge1xuICAgICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgICAgICBvcHRpb25zID0ge307XG4gICAgICB9XG5cbiAgICAgIHZhciBzbHVnID0gdGhpcy5zZXJpYWxpemUodmFsdWUpO1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0TmV4dFNhZmVTbHVnKHNsdWcsIG9wdGlvbnMuZHJ5cnVuKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIFNsdWdnZXI7XG4gIH0oKTtcblxuICB2YXIgUmVuZGVyZXIkMSA9IFJlbmRlcmVyXzE7XG4gIHZhciBUZXh0UmVuZGVyZXIkMSA9IFRleHRSZW5kZXJlcl8xO1xuICB2YXIgU2x1Z2dlciQxID0gU2x1Z2dlcl8xO1xuICB2YXIgZGVmYXVsdHMkMSA9IGRlZmF1bHRzJDUuZXhwb3J0cy5kZWZhdWx0cztcbiAgdmFyIHVuZXNjYXBlID0gaGVscGVycy51bmVzY2FwZTtcbiAgLyoqXG4gICAqIFBhcnNpbmcgJiBDb21waWxpbmdcbiAgICovXG5cbiAgdmFyIFBhcnNlcl8xID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBQYXJzZXIob3B0aW9ucykge1xuICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucyB8fCBkZWZhdWx0cyQxO1xuICAgICAgdGhpcy5vcHRpb25zLnJlbmRlcmVyID0gdGhpcy5vcHRpb25zLnJlbmRlcmVyIHx8IG5ldyBSZW5kZXJlciQxKCk7XG4gICAgICB0aGlzLnJlbmRlcmVyID0gdGhpcy5vcHRpb25zLnJlbmRlcmVyO1xuICAgICAgdGhpcy5yZW5kZXJlci5vcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgICAgdGhpcy50ZXh0UmVuZGVyZXIgPSBuZXcgVGV4dFJlbmRlcmVyJDEoKTtcbiAgICAgIHRoaXMuc2x1Z2dlciA9IG5ldyBTbHVnZ2VyJDEoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3RhdGljIFBhcnNlIE1ldGhvZFxuICAgICAqL1xuXG5cbiAgICBQYXJzZXIucGFyc2UgPSBmdW5jdGlvbiBwYXJzZSh0b2tlbnMsIG9wdGlvbnMpIHtcbiAgICAgIHZhciBwYXJzZXIgPSBuZXcgUGFyc2VyKG9wdGlvbnMpO1xuICAgICAgcmV0dXJuIHBhcnNlci5wYXJzZSh0b2tlbnMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdGF0aWMgUGFyc2UgSW5saW5lIE1ldGhvZFxuICAgICAqL1xuICAgIDtcblxuICAgIFBhcnNlci5wYXJzZUlubGluZSA9IGZ1bmN0aW9uIHBhcnNlSW5saW5lKHRva2Vucywgb3B0aW9ucykge1xuICAgICAgdmFyIHBhcnNlciA9IG5ldyBQYXJzZXIob3B0aW9ucyk7XG4gICAgICByZXR1cm4gcGFyc2VyLnBhcnNlSW5saW5lKHRva2Vucyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBhcnNlIExvb3BcbiAgICAgKi9cbiAgICA7XG5cbiAgICB2YXIgX3Byb3RvID0gUGFyc2VyLnByb3RvdHlwZTtcblxuICAgIF9wcm90by5wYXJzZSA9IGZ1bmN0aW9uIHBhcnNlKHRva2VucywgdG9wKSB7XG4gICAgICBpZiAodG9wID09PSB2b2lkIDApIHtcbiAgICAgICAgdG9wID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgdmFyIG91dCA9ICcnLFxuICAgICAgICAgIGksXG4gICAgICAgICAgaixcbiAgICAgICAgICBrLFxuICAgICAgICAgIGwyLFxuICAgICAgICAgIGwzLFxuICAgICAgICAgIHJvdyxcbiAgICAgICAgICBjZWxsLFxuICAgICAgICAgIGhlYWRlcixcbiAgICAgICAgICBib2R5LFxuICAgICAgICAgIHRva2VuLFxuICAgICAgICAgIG9yZGVyZWQsXG4gICAgICAgICAgc3RhcnQsXG4gICAgICAgICAgbG9vc2UsXG4gICAgICAgICAgaXRlbUJvZHksXG4gICAgICAgICAgaXRlbSxcbiAgICAgICAgICBjaGVja2VkLFxuICAgICAgICAgIHRhc2ssXG4gICAgICAgICAgY2hlY2tib3gsXG4gICAgICAgICAgcmV0O1xuICAgICAgdmFyIGwgPSB0b2tlbnMubGVuZ3RoO1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIHRva2VuID0gdG9rZW5zW2ldOyAvLyBSdW4gYW55IHJlbmRlcmVyIGV4dGVuc2lvbnNcblxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmV4dGVuc2lvbnMgJiYgdGhpcy5vcHRpb25zLmV4dGVuc2lvbnMucmVuZGVyZXJzICYmIHRoaXMub3B0aW9ucy5leHRlbnNpb25zLnJlbmRlcmVyc1t0b2tlbi50eXBlXSkge1xuICAgICAgICAgIHJldCA9IHRoaXMub3B0aW9ucy5leHRlbnNpb25zLnJlbmRlcmVyc1t0b2tlbi50eXBlXS5jYWxsKHtcbiAgICAgICAgICAgIHBhcnNlcjogdGhpc1xuICAgICAgICAgIH0sIHRva2VuKTtcblxuICAgICAgICAgIGlmIChyZXQgIT09IGZhbHNlIHx8ICFbJ3NwYWNlJywgJ2hyJywgJ2hlYWRpbmcnLCAnY29kZScsICd0YWJsZScsICdibG9ja3F1b3RlJywgJ2xpc3QnLCAnaHRtbCcsICdwYXJhZ3JhcGgnLCAndGV4dCddLmluY2x1ZGVzKHRva2VuLnR5cGUpKSB7XG4gICAgICAgICAgICBvdXQgKz0gcmV0IHx8ICcnO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgc3dpdGNoICh0b2tlbi50eXBlKSB7XG4gICAgICAgICAgY2FzZSAnc3BhY2UnOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIGNhc2UgJ2hyJzpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgb3V0ICs9IHRoaXMucmVuZGVyZXIuaHIoKTtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICBjYXNlICdoZWFkaW5nJzpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgb3V0ICs9IHRoaXMucmVuZGVyZXIuaGVhZGluZyh0aGlzLnBhcnNlSW5saW5lKHRva2VuLnRva2VucyksIHRva2VuLmRlcHRoLCB1bmVzY2FwZSh0aGlzLnBhcnNlSW5saW5lKHRva2VuLnRva2VucywgdGhpcy50ZXh0UmVuZGVyZXIpKSwgdGhpcy5zbHVnZ2VyKTtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICBjYXNlICdjb2RlJzpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgb3V0ICs9IHRoaXMucmVuZGVyZXIuY29kZSh0b2tlbi50ZXh0LCB0b2tlbi5sYW5nLCB0b2tlbi5lc2NhcGVkKTtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICBjYXNlICd0YWJsZSc6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGhlYWRlciA9ICcnOyAvLyBoZWFkZXJcblxuICAgICAgICAgICAgICBjZWxsID0gJyc7XG4gICAgICAgICAgICAgIGwyID0gdG9rZW4uaGVhZGVyLmxlbmd0aDtcblxuICAgICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgbDI7IGorKykge1xuICAgICAgICAgICAgICAgIGNlbGwgKz0gdGhpcy5yZW5kZXJlci50YWJsZWNlbGwodGhpcy5wYXJzZUlubGluZSh0b2tlbi5oZWFkZXJbal0udG9rZW5zKSwge1xuICAgICAgICAgICAgICAgICAgaGVhZGVyOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgYWxpZ246IHRva2VuLmFsaWduW2pdXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBoZWFkZXIgKz0gdGhpcy5yZW5kZXJlci50YWJsZXJvdyhjZWxsKTtcbiAgICAgICAgICAgICAgYm9keSA9ICcnO1xuICAgICAgICAgICAgICBsMiA9IHRva2VuLnJvd3MubGVuZ3RoO1xuXG4gICAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBsMjsgaisrKSB7XG4gICAgICAgICAgICAgICAgcm93ID0gdG9rZW4ucm93c1tqXTtcbiAgICAgICAgICAgICAgICBjZWxsID0gJyc7XG4gICAgICAgICAgICAgICAgbDMgPSByb3cubGVuZ3RoO1xuXG4gICAgICAgICAgICAgICAgZm9yIChrID0gMDsgayA8IGwzOyBrKyspIHtcbiAgICAgICAgICAgICAgICAgIGNlbGwgKz0gdGhpcy5yZW5kZXJlci50YWJsZWNlbGwodGhpcy5wYXJzZUlubGluZShyb3dba10udG9rZW5zKSwge1xuICAgICAgICAgICAgICAgICAgICBoZWFkZXI6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBhbGlnbjogdG9rZW4uYWxpZ25ba11cbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGJvZHkgKz0gdGhpcy5yZW5kZXJlci50YWJsZXJvdyhjZWxsKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIG91dCArPSB0aGlzLnJlbmRlcmVyLnRhYmxlKGhlYWRlciwgYm9keSk7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgY2FzZSAnYmxvY2txdW90ZSc6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGJvZHkgPSB0aGlzLnBhcnNlKHRva2VuLnRva2Vucyk7XG4gICAgICAgICAgICAgIG91dCArPSB0aGlzLnJlbmRlcmVyLmJsb2NrcXVvdGUoYm9keSk7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgY2FzZSAnbGlzdCc6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIG9yZGVyZWQgPSB0b2tlbi5vcmRlcmVkO1xuICAgICAgICAgICAgICBzdGFydCA9IHRva2VuLnN0YXJ0O1xuICAgICAgICAgICAgICBsb29zZSA9IHRva2VuLmxvb3NlO1xuICAgICAgICAgICAgICBsMiA9IHRva2VuLml0ZW1zLmxlbmd0aDtcbiAgICAgICAgICAgICAgYm9keSA9ICcnO1xuXG4gICAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBsMjsgaisrKSB7XG4gICAgICAgICAgICAgICAgaXRlbSA9IHRva2VuLml0ZW1zW2pdO1xuICAgICAgICAgICAgICAgIGNoZWNrZWQgPSBpdGVtLmNoZWNrZWQ7XG4gICAgICAgICAgICAgICAgdGFzayA9IGl0ZW0udGFzaztcbiAgICAgICAgICAgICAgICBpdGVtQm9keSA9ICcnO1xuXG4gICAgICAgICAgICAgICAgaWYgKGl0ZW0udGFzaykge1xuICAgICAgICAgICAgICAgICAgY2hlY2tib3ggPSB0aGlzLnJlbmRlcmVyLmNoZWNrYm94KGNoZWNrZWQpO1xuXG4gICAgICAgICAgICAgICAgICBpZiAobG9vc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGl0ZW0udG9rZW5zLmxlbmd0aCA+IDAgJiYgaXRlbS50b2tlbnNbMF0udHlwZSA9PT0gJ3BhcmFncmFwaCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICBpdGVtLnRva2Vuc1swXS50ZXh0ID0gY2hlY2tib3ggKyAnICcgKyBpdGVtLnRva2Vuc1swXS50ZXh0O1xuXG4gICAgICAgICAgICAgICAgICAgICAgaWYgKGl0ZW0udG9rZW5zWzBdLnRva2VucyAmJiBpdGVtLnRva2Vuc1swXS50b2tlbnMubGVuZ3RoID4gMCAmJiBpdGVtLnRva2Vuc1swXS50b2tlbnNbMF0udHlwZSA9PT0gJ3RleHQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpdGVtLnRva2Vuc1swXS50b2tlbnNbMF0udGV4dCA9IGNoZWNrYm94ICsgJyAnICsgaXRlbS50b2tlbnNbMF0udG9rZW5zWzBdLnRleHQ7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgIGl0ZW0udG9rZW5zLnVuc2hpZnQoe1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3RleHQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dDogY2hlY2tib3hcbiAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaXRlbUJvZHkgKz0gY2hlY2tib3g7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaXRlbUJvZHkgKz0gdGhpcy5wYXJzZShpdGVtLnRva2VucywgbG9vc2UpO1xuICAgICAgICAgICAgICAgIGJvZHkgKz0gdGhpcy5yZW5kZXJlci5saXN0aXRlbShpdGVtQm9keSwgdGFzaywgY2hlY2tlZCk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBvdXQgKz0gdGhpcy5yZW5kZXJlci5saXN0KGJvZHksIG9yZGVyZWQsIHN0YXJ0KTtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICBjYXNlICdodG1sJzpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgLy8gVE9ETyBwYXJzZSBpbmxpbmUgY29udGVudCBpZiBwYXJhbWV0ZXIgbWFya2Rvd249MVxuICAgICAgICAgICAgICBvdXQgKz0gdGhpcy5yZW5kZXJlci5odG1sKHRva2VuLnRleHQpO1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIGNhc2UgJ3BhcmFncmFwaCc6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIG91dCArPSB0aGlzLnJlbmRlcmVyLnBhcmFncmFwaCh0aGlzLnBhcnNlSW5saW5lKHRva2VuLnRva2VucykpO1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIGNhc2UgJ3RleHQnOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBib2R5ID0gdG9rZW4udG9rZW5zID8gdGhpcy5wYXJzZUlubGluZSh0b2tlbi50b2tlbnMpIDogdG9rZW4udGV4dDtcblxuICAgICAgICAgICAgICB3aGlsZSAoaSArIDEgPCBsICYmIHRva2Vuc1tpICsgMV0udHlwZSA9PT0gJ3RleHQnKSB7XG4gICAgICAgICAgICAgICAgdG9rZW4gPSB0b2tlbnNbKytpXTtcbiAgICAgICAgICAgICAgICBib2R5ICs9ICdcXG4nICsgKHRva2VuLnRva2VucyA/IHRoaXMucGFyc2VJbmxpbmUodG9rZW4udG9rZW5zKSA6IHRva2VuLnRleHQpO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgb3V0ICs9IHRvcCA/IHRoaXMucmVuZGVyZXIucGFyYWdyYXBoKGJvZHkpIDogYm9keTtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICB2YXIgZXJyTXNnID0gJ1Rva2VuIHdpdGggXCInICsgdG9rZW4udHlwZSArICdcIiB0eXBlIHdhcyBub3QgZm91bmQuJztcblxuICAgICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLnNpbGVudCkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyTXNnKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVyck1zZyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gb3V0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQYXJzZSBJbmxpbmUgVG9rZW5zXG4gICAgICovXG4gICAgO1xuXG4gICAgX3Byb3RvLnBhcnNlSW5saW5lID0gZnVuY3Rpb24gcGFyc2VJbmxpbmUodG9rZW5zLCByZW5kZXJlcikge1xuICAgICAgcmVuZGVyZXIgPSByZW5kZXJlciB8fCB0aGlzLnJlbmRlcmVyO1xuICAgICAgdmFyIG91dCA9ICcnLFxuICAgICAgICAgIGksXG4gICAgICAgICAgdG9rZW4sXG4gICAgICAgICAgcmV0O1xuICAgICAgdmFyIGwgPSB0b2tlbnMubGVuZ3RoO1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIHRva2VuID0gdG9rZW5zW2ldOyAvLyBSdW4gYW55IHJlbmRlcmVyIGV4dGVuc2lvbnNcblxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmV4dGVuc2lvbnMgJiYgdGhpcy5vcHRpb25zLmV4dGVuc2lvbnMucmVuZGVyZXJzICYmIHRoaXMub3B0aW9ucy5leHRlbnNpb25zLnJlbmRlcmVyc1t0b2tlbi50eXBlXSkge1xuICAgICAgICAgIHJldCA9IHRoaXMub3B0aW9ucy5leHRlbnNpb25zLnJlbmRlcmVyc1t0b2tlbi50eXBlXS5jYWxsKHtcbiAgICAgICAgICAgIHBhcnNlcjogdGhpc1xuICAgICAgICAgIH0sIHRva2VuKTtcblxuICAgICAgICAgIGlmIChyZXQgIT09IGZhbHNlIHx8ICFbJ2VzY2FwZScsICdodG1sJywgJ2xpbmsnLCAnaW1hZ2UnLCAnc3Ryb25nJywgJ2VtJywgJ2NvZGVzcGFuJywgJ2JyJywgJ2RlbCcsICd0ZXh0J10uaW5jbHVkZXModG9rZW4udHlwZSkpIHtcbiAgICAgICAgICAgIG91dCArPSByZXQgfHwgJyc7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBzd2l0Y2ggKHRva2VuLnR5cGUpIHtcbiAgICAgICAgICBjYXNlICdlc2NhcGUnOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBvdXQgKz0gcmVuZGVyZXIudGV4dCh0b2tlbi50ZXh0KTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICBjYXNlICdodG1sJzpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgb3V0ICs9IHJlbmRlcmVyLmh0bWwodG9rZW4udGV4dCk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgY2FzZSAnbGluayc6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIG91dCArPSByZW5kZXJlci5saW5rKHRva2VuLmhyZWYsIHRva2VuLnRpdGxlLCB0aGlzLnBhcnNlSW5saW5lKHRva2VuLnRva2VucywgcmVuZGVyZXIpKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICBjYXNlICdpbWFnZSc6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIG91dCArPSByZW5kZXJlci5pbWFnZSh0b2tlbi5ocmVmLCB0b2tlbi50aXRsZSwgdG9rZW4udGV4dCk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgY2FzZSAnc3Ryb25nJzpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgb3V0ICs9IHJlbmRlcmVyLnN0cm9uZyh0aGlzLnBhcnNlSW5saW5lKHRva2VuLnRva2VucywgcmVuZGVyZXIpKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICBjYXNlICdlbSc6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIG91dCArPSByZW5kZXJlci5lbSh0aGlzLnBhcnNlSW5saW5lKHRva2VuLnRva2VucywgcmVuZGVyZXIpKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICBjYXNlICdjb2Rlc3Bhbic6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIG91dCArPSByZW5kZXJlci5jb2Rlc3Bhbih0b2tlbi50ZXh0KTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICBjYXNlICdicic6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIG91dCArPSByZW5kZXJlci5icigpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIGNhc2UgJ2RlbCc6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIG91dCArPSByZW5kZXJlci5kZWwodGhpcy5wYXJzZUlubGluZSh0b2tlbi50b2tlbnMsIHJlbmRlcmVyKSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgY2FzZSAndGV4dCc6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIG91dCArPSByZW5kZXJlci50ZXh0KHRva2VuLnRleHQpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHZhciBlcnJNc2cgPSAnVG9rZW4gd2l0aCBcIicgKyB0b2tlbi50eXBlICsgJ1wiIHR5cGUgd2FzIG5vdCBmb3VuZC4nO1xuXG4gICAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuc2lsZW50KSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihlcnJNc2cpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyTXNnKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBvdXQ7XG4gICAgfTtcblxuICAgIHJldHVybiBQYXJzZXI7XG4gIH0oKTtcblxuICB2YXIgTGV4ZXIgPSBMZXhlcl8xO1xuICB2YXIgUGFyc2VyID0gUGFyc2VyXzE7XG4gIHZhciBUb2tlbml6ZXIgPSBUb2tlbml6ZXJfMTtcbiAgdmFyIFJlbmRlcmVyID0gUmVuZGVyZXJfMTtcbiAgdmFyIFRleHRSZW5kZXJlciA9IFRleHRSZW5kZXJlcl8xO1xuICB2YXIgU2x1Z2dlciA9IFNsdWdnZXJfMTtcbiAgdmFyIG1lcmdlID0gaGVscGVycy5tZXJnZSxcbiAgICAgIGNoZWNrU2FuaXRpemVEZXByZWNhdGlvbiA9IGhlbHBlcnMuY2hlY2tTYW5pdGl6ZURlcHJlY2F0aW9uLFxuICAgICAgZXNjYXBlID0gaGVscGVycy5lc2NhcGU7XG4gIHZhciBnZXREZWZhdWx0cyA9IGRlZmF1bHRzJDUuZXhwb3J0cy5nZXREZWZhdWx0cyxcbiAgICAgIGNoYW5nZURlZmF1bHRzID0gZGVmYXVsdHMkNS5leHBvcnRzLmNoYW5nZURlZmF1bHRzLFxuICAgICAgZGVmYXVsdHMgPSBkZWZhdWx0cyQ1LmV4cG9ydHMuZGVmYXVsdHM7XG4gIC8qKlxuICAgKiBNYXJrZWRcbiAgICovXG5cbiAgZnVuY3Rpb24gbWFya2VkKHNyYywgb3B0LCBjYWxsYmFjaykge1xuICAgIC8vIHRocm93IGVycm9yIGluIGNhc2Ugb2Ygbm9uIHN0cmluZyBpbnB1dFxuICAgIGlmICh0eXBlb2Ygc3JjID09PSAndW5kZWZpbmVkJyB8fCBzcmMgPT09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignbWFya2VkKCk6IGlucHV0IHBhcmFtZXRlciBpcyB1bmRlZmluZWQgb3IgbnVsbCcpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2Ygc3JjICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdtYXJrZWQoKTogaW5wdXQgcGFyYW1ldGVyIGlzIG9mIHR5cGUgJyArIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChzcmMpICsgJywgc3RyaW5nIGV4cGVjdGVkJyk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBvcHQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNhbGxiYWNrID0gb3B0O1xuICAgICAgb3B0ID0gbnVsbDtcbiAgICB9XG5cbiAgICBvcHQgPSBtZXJnZSh7fSwgbWFya2VkLmRlZmF1bHRzLCBvcHQgfHwge30pO1xuICAgIGNoZWNrU2FuaXRpemVEZXByZWNhdGlvbihvcHQpO1xuXG4gICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICB2YXIgaGlnaGxpZ2h0ID0gb3B0LmhpZ2hsaWdodDtcbiAgICAgIHZhciB0b2tlbnM7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHRva2VucyA9IExleGVyLmxleChzcmMsIG9wdCk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjayhlKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGRvbmUgPSBmdW5jdGlvbiBkb25lKGVycikge1xuICAgICAgICB2YXIgb3V0O1xuXG4gICAgICAgIGlmICghZXJyKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmIChvcHQud2Fsa1Rva2Vucykge1xuICAgICAgICAgICAgICBtYXJrZWQud2Fsa1Rva2Vucyh0b2tlbnMsIG9wdC53YWxrVG9rZW5zKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgb3V0ID0gUGFyc2VyLnBhcnNlKHRva2Vucywgb3B0KTtcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBlcnIgPSBlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIG9wdC5oaWdobGlnaHQgPSBoaWdobGlnaHQ7XG4gICAgICAgIHJldHVybiBlcnIgPyBjYWxsYmFjayhlcnIpIDogY2FsbGJhY2sobnVsbCwgb3V0KTtcbiAgICAgIH07XG5cbiAgICAgIGlmICghaGlnaGxpZ2h0IHx8IGhpZ2hsaWdodC5sZW5ndGggPCAzKSB7XG4gICAgICAgIHJldHVybiBkb25lKCk7XG4gICAgICB9XG5cbiAgICAgIGRlbGV0ZSBvcHQuaGlnaGxpZ2h0O1xuICAgICAgaWYgKCF0b2tlbnMubGVuZ3RoKSByZXR1cm4gZG9uZSgpO1xuICAgICAgdmFyIHBlbmRpbmcgPSAwO1xuICAgICAgbWFya2VkLndhbGtUb2tlbnModG9rZW5zLCBmdW5jdGlvbiAodG9rZW4pIHtcbiAgICAgICAgaWYgKHRva2VuLnR5cGUgPT09ICdjb2RlJykge1xuICAgICAgICAgIHBlbmRpbmcrKztcbiAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGhpZ2hsaWdodCh0b2tlbi50ZXh0LCB0b2tlbi5sYW5nLCBmdW5jdGlvbiAoZXJyLCBjb2RlKSB7XG4gICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZG9uZShlcnIpO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaWYgKGNvZGUgIT0gbnVsbCAmJiBjb2RlICE9PSB0b2tlbi50ZXh0KSB7XG4gICAgICAgICAgICAgICAgdG9rZW4udGV4dCA9IGNvZGU7XG4gICAgICAgICAgICAgICAgdG9rZW4uZXNjYXBlZCA9IHRydWU7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBwZW5kaW5nLS07XG5cbiAgICAgICAgICAgICAgaWYgKHBlbmRpbmcgPT09IDApIHtcbiAgICAgICAgICAgICAgICBkb25lKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0sIDApO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgaWYgKHBlbmRpbmcgPT09IDApIHtcbiAgICAgICAgZG9uZSgpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIHZhciBfdG9rZW5zID0gTGV4ZXIubGV4KHNyYywgb3B0KTtcblxuICAgICAgaWYgKG9wdC53YWxrVG9rZW5zKSB7XG4gICAgICAgIG1hcmtlZC53YWxrVG9rZW5zKF90b2tlbnMsIG9wdC53YWxrVG9rZW5zKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIFBhcnNlci5wYXJzZShfdG9rZW5zLCBvcHQpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGUubWVzc2FnZSArPSAnXFxuUGxlYXNlIHJlcG9ydCB0aGlzIHRvIGh0dHBzOi8vZ2l0aHViLmNvbS9tYXJrZWRqcy9tYXJrZWQuJztcblxuICAgICAgaWYgKG9wdC5zaWxlbnQpIHtcbiAgICAgICAgcmV0dXJuICc8cD5BbiBlcnJvciBvY2N1cnJlZDo8L3A+PHByZT4nICsgZXNjYXBlKGUubWVzc2FnZSArICcnLCB0cnVlKSArICc8L3ByZT4nO1xuICAgICAgfVxuXG4gICAgICB0aHJvdyBlO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogT3B0aW9uc1xuICAgKi9cblxuXG4gIG1hcmtlZC5vcHRpb25zID0gbWFya2VkLnNldE9wdGlvbnMgPSBmdW5jdGlvbiAob3B0KSB7XG4gICAgbWVyZ2UobWFya2VkLmRlZmF1bHRzLCBvcHQpO1xuICAgIGNoYW5nZURlZmF1bHRzKG1hcmtlZC5kZWZhdWx0cyk7XG4gICAgcmV0dXJuIG1hcmtlZDtcbiAgfTtcblxuICBtYXJrZWQuZ2V0RGVmYXVsdHMgPSBnZXREZWZhdWx0cztcbiAgbWFya2VkLmRlZmF1bHRzID0gZGVmYXVsdHM7XG4gIC8qKlxuICAgKiBVc2UgRXh0ZW5zaW9uXG4gICAqL1xuXG4gIG1hcmtlZC51c2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICB2YXIgb3B0cyA9IG1lcmdlLmFwcGx5KHZvaWQgMCwgW3t9XS5jb25jYXQoYXJncykpO1xuICAgIHZhciBleHRlbnNpb25zID0gbWFya2VkLmRlZmF1bHRzLmV4dGVuc2lvbnMgfHwge1xuICAgICAgcmVuZGVyZXJzOiB7fSxcbiAgICAgIGNoaWxkVG9rZW5zOiB7fVxuICAgIH07XG4gICAgdmFyIGhhc0V4dGVuc2lvbnM7XG4gICAgYXJncy5mb3JFYWNoKGZ1bmN0aW9uIChwYWNrKSB7XG4gICAgICAvLyA9PS0tIFBhcnNlIFwiYWRkb25cIiBleHRlbnNpb25zIC0tPT0gLy9cbiAgICAgIGlmIChwYWNrLmV4dGVuc2lvbnMpIHtcbiAgICAgICAgaGFzRXh0ZW5zaW9ucyA9IHRydWU7XG4gICAgICAgIHBhY2suZXh0ZW5zaW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChleHQpIHtcbiAgICAgICAgICBpZiAoIWV4dC5uYW1lKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2V4dGVuc2lvbiBuYW1lIHJlcXVpcmVkJyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGV4dC5yZW5kZXJlcikge1xuICAgICAgICAgICAgLy8gUmVuZGVyZXIgZXh0ZW5zaW9uc1xuICAgICAgICAgICAgdmFyIHByZXZSZW5kZXJlciA9IGV4dGVuc2lvbnMucmVuZGVyZXJzID8gZXh0ZW5zaW9ucy5yZW5kZXJlcnNbZXh0Lm5hbWVdIDogbnVsbDtcblxuICAgICAgICAgICAgaWYgKHByZXZSZW5kZXJlcikge1xuICAgICAgICAgICAgICAvLyBSZXBsYWNlIGV4dGVuc2lvbiB3aXRoIGZ1bmMgdG8gcnVuIG5ldyBleHRlbnNpb24gYnV0IGZhbGwgYmFjayBpZiBmYWxzZVxuICAgICAgICAgICAgICBleHRlbnNpb25zLnJlbmRlcmVyc1tleHQubmFtZV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4yKSwgX2tleTIgPSAwOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgICAgICAgICAgICAgICBhcmdzW19rZXkyXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIHJldCA9IGV4dC5yZW5kZXJlci5hcHBseSh0aGlzLCBhcmdzKTtcblxuICAgICAgICAgICAgICAgIGlmIChyZXQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICByZXQgPSBwcmV2UmVuZGVyZXIuYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGV4dGVuc2lvbnMucmVuZGVyZXJzW2V4dC5uYW1lXSA9IGV4dC5yZW5kZXJlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoZXh0LnRva2VuaXplcikge1xuICAgICAgICAgICAgLy8gVG9rZW5pemVyIEV4dGVuc2lvbnNcbiAgICAgICAgICAgIGlmICghZXh0LmxldmVsIHx8IGV4dC5sZXZlbCAhPT0gJ2Jsb2NrJyAmJiBleHQubGV2ZWwgIT09ICdpbmxpbmUnKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImV4dGVuc2lvbiBsZXZlbCBtdXN0IGJlICdibG9jaycgb3IgJ2lubGluZSdcIik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChleHRlbnNpb25zW2V4dC5sZXZlbF0pIHtcbiAgICAgICAgICAgICAgZXh0ZW5zaW9uc1tleHQubGV2ZWxdLnVuc2hpZnQoZXh0LnRva2VuaXplcik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBleHRlbnNpb25zW2V4dC5sZXZlbF0gPSBbZXh0LnRva2VuaXplcl07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChleHQuc3RhcnQpIHtcbiAgICAgICAgICAgICAgLy8gRnVuY3Rpb24gdG8gY2hlY2sgZm9yIHN0YXJ0IG9mIHRva2VuXG4gICAgICAgICAgICAgIGlmIChleHQubGV2ZWwgPT09ICdibG9jaycpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXh0ZW5zaW9ucy5zdGFydEJsb2NrKSB7XG4gICAgICAgICAgICAgICAgICBleHRlbnNpb25zLnN0YXJ0QmxvY2sucHVzaChleHQuc3RhcnQpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBleHRlbnNpb25zLnN0YXJ0QmxvY2sgPSBbZXh0LnN0YXJ0XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoZXh0LmxldmVsID09PSAnaW5saW5lJykge1xuICAgICAgICAgICAgICAgIGlmIChleHRlbnNpb25zLnN0YXJ0SW5saW5lKSB7XG4gICAgICAgICAgICAgICAgICBleHRlbnNpb25zLnN0YXJ0SW5saW5lLnB1c2goZXh0LnN0YXJ0KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgZXh0ZW5zaW9ucy5zdGFydElubGluZSA9IFtleHQuc3RhcnRdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChleHQuY2hpbGRUb2tlbnMpIHtcbiAgICAgICAgICAgIC8vIENoaWxkIHRva2VucyB0byBiZSB2aXNpdGVkIGJ5IHdhbGtUb2tlbnNcbiAgICAgICAgICAgIGV4dGVuc2lvbnMuY2hpbGRUb2tlbnNbZXh0Lm5hbWVdID0gZXh0LmNoaWxkVG9rZW5zO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9IC8vID09LS0gUGFyc2UgXCJvdmVyd3JpdGVcIiBleHRlbnNpb25zIC0tPT0gLy9cblxuXG4gICAgICBpZiAocGFjay5yZW5kZXJlcikge1xuICAgICAgICAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciByZW5kZXJlciA9IG1hcmtlZC5kZWZhdWx0cy5yZW5kZXJlciB8fCBuZXcgUmVuZGVyZXIoKTtcblxuICAgICAgICAgIHZhciBfbG9vcCA9IGZ1bmN0aW9uIF9sb29wKHByb3ApIHtcbiAgICAgICAgICAgIHZhciBwcmV2UmVuZGVyZXIgPSByZW5kZXJlcltwcm9wXTsgLy8gUmVwbGFjZSByZW5kZXJlciB3aXRoIGZ1bmMgdG8gcnVuIGV4dGVuc2lvbiwgYnV0IGZhbGwgYmFjayBpZiBmYWxzZVxuXG4gICAgICAgICAgICByZW5kZXJlcltwcm9wXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgZm9yICh2YXIgX2xlbjMgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4zKSwgX2tleTMgPSAwOyBfa2V5MyA8IF9sZW4zOyBfa2V5MysrKSB7XG4gICAgICAgICAgICAgICAgYXJnc1tfa2V5M10gPSBhcmd1bWVudHNbX2tleTNdO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgdmFyIHJldCA9IHBhY2sucmVuZGVyZXJbcHJvcF0uYXBwbHkocmVuZGVyZXIsIGFyZ3MpO1xuXG4gICAgICAgICAgICAgIGlmIChyZXQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgcmV0ID0gcHJldlJlbmRlcmVyLmFwcGx5KHJlbmRlcmVyLCBhcmdzKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH07XG5cbiAgICAgICAgICBmb3IgKHZhciBwcm9wIGluIHBhY2sucmVuZGVyZXIpIHtcbiAgICAgICAgICAgIF9sb29wKHByb3ApO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIG9wdHMucmVuZGVyZXIgPSByZW5kZXJlcjtcbiAgICAgICAgfSkoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHBhY2sudG9rZW5pemVyKSB7XG4gICAgICAgIChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyIHRva2VuaXplciA9IG1hcmtlZC5kZWZhdWx0cy50b2tlbml6ZXIgfHwgbmV3IFRva2VuaXplcigpO1xuXG4gICAgICAgICAgdmFyIF9sb29wMiA9IGZ1bmN0aW9uIF9sb29wMihwcm9wKSB7XG4gICAgICAgICAgICB2YXIgcHJldlRva2VuaXplciA9IHRva2VuaXplcltwcm9wXTsgLy8gUmVwbGFjZSB0b2tlbml6ZXIgd2l0aCBmdW5jIHRvIHJ1biBleHRlbnNpb24sIGJ1dCBmYWxsIGJhY2sgaWYgZmFsc2VcblxuICAgICAgICAgICAgdG9rZW5pemVyW3Byb3BdID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICBmb3IgKHZhciBfbGVuNCA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjQpLCBfa2V5NCA9IDA7IF9rZXk0IDwgX2xlbjQ7IF9rZXk0KyspIHtcbiAgICAgICAgICAgICAgICBhcmdzW19rZXk0XSA9IGFyZ3VtZW50c1tfa2V5NF07XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICB2YXIgcmV0ID0gcGFjay50b2tlbml6ZXJbcHJvcF0uYXBwbHkodG9rZW5pemVyLCBhcmdzKTtcblxuICAgICAgICAgICAgICBpZiAocmV0ID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIHJldCA9IHByZXZUb2tlbml6ZXIuYXBwbHkodG9rZW5pemVyLCBhcmdzKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH07XG5cbiAgICAgICAgICBmb3IgKHZhciBwcm9wIGluIHBhY2sudG9rZW5pemVyKSB7XG4gICAgICAgICAgICBfbG9vcDIocHJvcCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgb3B0cy50b2tlbml6ZXIgPSB0b2tlbml6ZXI7XG4gICAgICAgIH0pKCk7XG4gICAgICB9IC8vID09LS0gUGFyc2UgV2Fsa1Rva2VucyBleHRlbnNpb25zIC0tPT0gLy9cblxuXG4gICAgICBpZiAocGFjay53YWxrVG9rZW5zKSB7XG4gICAgICAgIHZhciB3YWxrVG9rZW5zID0gbWFya2VkLmRlZmF1bHRzLndhbGtUb2tlbnM7XG5cbiAgICAgICAgb3B0cy53YWxrVG9rZW5zID0gZnVuY3Rpb24gKHRva2VuKSB7XG4gICAgICAgICAgcGFjay53YWxrVG9rZW5zLmNhbGwoX3RoaXMsIHRva2VuKTtcblxuICAgICAgICAgIGlmICh3YWxrVG9rZW5zKSB7XG4gICAgICAgICAgICB3YWxrVG9rZW5zKHRva2VuKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIGlmIChoYXNFeHRlbnNpb25zKSB7XG4gICAgICAgIG9wdHMuZXh0ZW5zaW9ucyA9IGV4dGVuc2lvbnM7XG4gICAgICB9XG5cbiAgICAgIG1hcmtlZC5zZXRPcHRpb25zKG9wdHMpO1xuICAgIH0pO1xuICB9O1xuICAvKipcbiAgICogUnVuIGNhbGxiYWNrIGZvciBldmVyeSB0b2tlblxuICAgKi9cblxuXG4gIG1hcmtlZC53YWxrVG9rZW5zID0gZnVuY3Rpb24gKHRva2VucywgY2FsbGJhY2spIHtcbiAgICB2YXIgX2xvb3AzID0gZnVuY3Rpb24gX2xvb3AzKCkge1xuICAgICAgdmFyIHRva2VuID0gX3N0ZXAudmFsdWU7XG4gICAgICBjYWxsYmFjayh0b2tlbik7XG5cbiAgICAgIHN3aXRjaCAodG9rZW4udHlwZSkge1xuICAgICAgICBjYXNlICd0YWJsZSc6XG4gICAgICAgICAge1xuICAgICAgICAgICAgZm9yICh2YXIgX2l0ZXJhdG9yMiA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyTG9vc2UodG9rZW4uaGVhZGVyKSwgX3N0ZXAyOyAhKF9zdGVwMiA9IF9pdGVyYXRvcjIoKSkuZG9uZTspIHtcbiAgICAgICAgICAgICAgdmFyIGNlbGwgPSBfc3RlcDIudmFsdWU7XG4gICAgICAgICAgICAgIG1hcmtlZC53YWxrVG9rZW5zKGNlbGwudG9rZW5zLCBjYWxsYmFjayk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvciAodmFyIF9pdGVyYXRvcjMgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlckxvb3NlKHRva2VuLnJvd3MpLCBfc3RlcDM7ICEoX3N0ZXAzID0gX2l0ZXJhdG9yMygpKS5kb25lOykge1xuICAgICAgICAgICAgICB2YXIgcm93ID0gX3N0ZXAzLnZhbHVlO1xuXG4gICAgICAgICAgICAgIGZvciAodmFyIF9pdGVyYXRvcjQgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlckxvb3NlKHJvdyksIF9zdGVwNDsgIShfc3RlcDQgPSBfaXRlcmF0b3I0KCkpLmRvbmU7KSB7XG4gICAgICAgICAgICAgICAgdmFyIF9jZWxsID0gX3N0ZXA0LnZhbHVlO1xuICAgICAgICAgICAgICAgIG1hcmtlZC53YWxrVG9rZW5zKF9jZWxsLnRva2VucywgY2FsbGJhY2spO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlICdsaXN0JzpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBtYXJrZWQud2Fsa1Rva2Vucyh0b2tlbi5pdGVtcywgY2FsbGJhY2spO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAge1xuICAgICAgICAgICAgaWYgKG1hcmtlZC5kZWZhdWx0cy5leHRlbnNpb25zICYmIG1hcmtlZC5kZWZhdWx0cy5leHRlbnNpb25zLmNoaWxkVG9rZW5zICYmIG1hcmtlZC5kZWZhdWx0cy5leHRlbnNpb25zLmNoaWxkVG9rZW5zW3Rva2VuLnR5cGVdKSB7XG4gICAgICAgICAgICAgIC8vIFdhbGsgYW55IGV4dGVuc2lvbnNcbiAgICAgICAgICAgICAgbWFya2VkLmRlZmF1bHRzLmV4dGVuc2lvbnMuY2hpbGRUb2tlbnNbdG9rZW4udHlwZV0uZm9yRWFjaChmdW5jdGlvbiAoY2hpbGRUb2tlbnMpIHtcbiAgICAgICAgICAgICAgICBtYXJrZWQud2Fsa1Rva2Vucyh0b2tlbltjaGlsZFRva2Vuc10sIGNhbGxiYWNrKTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRva2VuLnRva2Vucykge1xuICAgICAgICAgICAgICBtYXJrZWQud2Fsa1Rva2Vucyh0b2tlbi50b2tlbnMsIGNhbGxiYWNrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIGZvciAodmFyIF9pdGVyYXRvciA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyTG9vc2UodG9rZW5zKSwgX3N0ZXA7ICEoX3N0ZXAgPSBfaXRlcmF0b3IoKSkuZG9uZTspIHtcbiAgICAgIF9sb29wMygpO1xuICAgIH1cbiAgfTtcbiAgLyoqXG4gICAqIFBhcnNlIElubGluZVxuICAgKi9cblxuXG4gIG1hcmtlZC5wYXJzZUlubGluZSA9IGZ1bmN0aW9uIChzcmMsIG9wdCkge1xuICAgIC8vIHRocm93IGVycm9yIGluIGNhc2Ugb2Ygbm9uIHN0cmluZyBpbnB1dFxuICAgIGlmICh0eXBlb2Ygc3JjID09PSAndW5kZWZpbmVkJyB8fCBzcmMgPT09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignbWFya2VkLnBhcnNlSW5saW5lKCk6IGlucHV0IHBhcmFtZXRlciBpcyB1bmRlZmluZWQgb3IgbnVsbCcpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2Ygc3JjICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdtYXJrZWQucGFyc2VJbmxpbmUoKTogaW5wdXQgcGFyYW1ldGVyIGlzIG9mIHR5cGUgJyArIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChzcmMpICsgJywgc3RyaW5nIGV4cGVjdGVkJyk7XG4gICAgfVxuXG4gICAgb3B0ID0gbWVyZ2Uoe30sIG1hcmtlZC5kZWZhdWx0cywgb3B0IHx8IHt9KTtcbiAgICBjaGVja1Nhbml0aXplRGVwcmVjYXRpb24ob3B0KTtcblxuICAgIHRyeSB7XG4gICAgICB2YXIgdG9rZW5zID0gTGV4ZXIubGV4SW5saW5lKHNyYywgb3B0KTtcblxuICAgICAgaWYgKG9wdC53YWxrVG9rZW5zKSB7XG4gICAgICAgIG1hcmtlZC53YWxrVG9rZW5zKHRva2Vucywgb3B0LndhbGtUb2tlbnMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gUGFyc2VyLnBhcnNlSW5saW5lKHRva2Vucywgb3B0KTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBlLm1lc3NhZ2UgKz0gJ1xcblBsZWFzZSByZXBvcnQgdGhpcyB0byBodHRwczovL2dpdGh1Yi5jb20vbWFya2VkanMvbWFya2VkLic7XG5cbiAgICAgIGlmIChvcHQuc2lsZW50KSB7XG4gICAgICAgIHJldHVybiAnPHA+QW4gZXJyb3Igb2NjdXJyZWQ6PC9wPjxwcmU+JyArIGVzY2FwZShlLm1lc3NhZ2UgKyAnJywgdHJ1ZSkgKyAnPC9wcmU+JztcbiAgICAgIH1cblxuICAgICAgdGhyb3cgZTtcbiAgICB9XG4gIH07XG4gIC8qKlxuICAgKiBFeHBvc2VcbiAgICovXG5cblxuICBtYXJrZWQuUGFyc2VyID0gUGFyc2VyO1xuICBtYXJrZWQucGFyc2VyID0gUGFyc2VyLnBhcnNlO1xuICBtYXJrZWQuUmVuZGVyZXIgPSBSZW5kZXJlcjtcbiAgbWFya2VkLlRleHRSZW5kZXJlciA9IFRleHRSZW5kZXJlcjtcbiAgbWFya2VkLkxleGVyID0gTGV4ZXI7XG4gIG1hcmtlZC5sZXhlciA9IExleGVyLmxleDtcbiAgbWFya2VkLlRva2VuaXplciA9IFRva2VuaXplcjtcbiAgbWFya2VkLlNsdWdnZXIgPSBTbHVnZ2VyO1xuICBtYXJrZWQucGFyc2UgPSBtYXJrZWQ7XG4gIHZhciBtYXJrZWRfMSA9IG1hcmtlZDtcblxuICByZXR1cm4gbWFya2VkXzE7XG5cbn0pKTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///84\n")},418:module=>{"use strict";eval("/*\nobject-assign\n(c) Sindre Sorhus\n@license MIT\n*/\n\n\n/* eslint-disable no-unused-vars */\nvar getOwnPropertySymbols = Object.getOwnPropertySymbols;\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\nvar propIsEnumerable = Object.prototype.propertyIsEnumerable;\n\nfunction toObject(val) {\n\tif (val === null || val === undefined) {\n\t\tthrow new TypeError('Object.assign cannot be called with null or undefined');\n\t}\n\n\treturn Object(val);\n}\n\nfunction shouldUseNative() {\n\ttry {\n\t\tif (!Object.assign) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Detect buggy property enumeration order in older V8 versions.\n\n\t\t// https://bugs.chromium.org/p/v8/issues/detail?id=4118\n\t\tvar test1 = new String('abc');  // eslint-disable-line no-new-wrappers\n\t\ttest1[5] = 'de';\n\t\tif (Object.getOwnPropertyNames(test1)[0] === '5') {\n\t\t\treturn false;\n\t\t}\n\n\t\t// https://bugs.chromium.org/p/v8/issues/detail?id=3056\n\t\tvar test2 = {};\n\t\tfor (var i = 0; i < 10; i++) {\n\t\t\ttest2['_' + String.fromCharCode(i)] = i;\n\t\t}\n\t\tvar order2 = Object.getOwnPropertyNames(test2).map(function (n) {\n\t\t\treturn test2[n];\n\t\t});\n\t\tif (order2.join('') !== '0123456789') {\n\t\t\treturn false;\n\t\t}\n\n\t\t// https://bugs.chromium.org/p/v8/issues/detail?id=3056\n\t\tvar test3 = {};\n\t\t'abcdefghijklmnopqrst'.split('').forEach(function (letter) {\n\t\t\ttest3[letter] = letter;\n\t\t});\n\t\tif (Object.keys(Object.assign({}, test3)).join('') !==\n\t\t\t\t'abcdefghijklmnopqrst') {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t} catch (err) {\n\t\t// We don't expect any of the above to throw, but better to be safe.\n\t\treturn false;\n\t}\n}\n\nmodule.exports = shouldUseNative() ? Object.assign : function (target, source) {\n\tvar from;\n\tvar to = toObject(target);\n\tvar symbols;\n\n\tfor (var s = 1; s < arguments.length; s++) {\n\t\tfrom = Object(arguments[s]);\n\n\t\tfor (var key in from) {\n\t\t\tif (hasOwnProperty.call(from, key)) {\n\t\t\t\tto[key] = from[key];\n\t\t\t}\n\t\t}\n\n\t\tif (getOwnPropertySymbols) {\n\t\t\tsymbols = getOwnPropertySymbols(from);\n\t\t\tfor (var i = 0; i < symbols.length; i++) {\n\t\t\t\tif (propIsEnumerable.call(from, symbols[i])) {\n\t\t\t\t\tto[symbols[i]] = from[symbols[i]];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn to;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDE4LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQixRQUFRO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlCQUFpQixzQkFBc0I7QUFDdkM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUJBQW1CLG9CQUFvQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL21kYy1yZWFjdC8uL25vZGVfbW9kdWxlcy9vYmplY3QtYXNzaWduL2luZGV4LmpzPzMyMGMiXSwic291cmNlc0NvbnRlbnQiOlsiLypcbm9iamVjdC1hc3NpZ25cbihjKSBTaW5kcmUgU29yaHVzXG5AbGljZW5zZSBNSVRcbiovXG5cbid1c2Ugc3RyaWN0Jztcbi8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC12YXJzICovXG52YXIgZ2V0T3duUHJvcGVydHlTeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scztcbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgcHJvcElzRW51bWVyYWJsZSA9IE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGU7XG5cbmZ1bmN0aW9uIHRvT2JqZWN0KHZhbCkge1xuXHRpZiAodmFsID09PSBudWxsIHx8IHZhbCA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignT2JqZWN0LmFzc2lnbiBjYW5ub3QgYmUgY2FsbGVkIHdpdGggbnVsbCBvciB1bmRlZmluZWQnKTtcblx0fVxuXG5cdHJldHVybiBPYmplY3QodmFsKTtcbn1cblxuZnVuY3Rpb24gc2hvdWxkVXNlTmF0aXZlKCkge1xuXHR0cnkge1xuXHRcdGlmICghT2JqZWN0LmFzc2lnbikge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdC8vIERldGVjdCBidWdneSBwcm9wZXJ0eSBlbnVtZXJhdGlvbiBvcmRlciBpbiBvbGRlciBWOCB2ZXJzaW9ucy5cblxuXHRcdC8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTQxMThcblx0XHR2YXIgdGVzdDEgPSBuZXcgU3RyaW5nKCdhYmMnKTsgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmV3LXdyYXBwZXJzXG5cdFx0dGVzdDFbNV0gPSAnZGUnO1xuXHRcdGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0ZXN0MSlbMF0gPT09ICc1Jykge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdC8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTMwNTZcblx0XHR2YXIgdGVzdDIgPSB7fTtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IDEwOyBpKyspIHtcblx0XHRcdHRlc3QyWydfJyArIFN0cmluZy5mcm9tQ2hhckNvZGUoaSldID0gaTtcblx0XHR9XG5cdFx0dmFyIG9yZGVyMiA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRlc3QyKS5tYXAoZnVuY3Rpb24gKG4pIHtcblx0XHRcdHJldHVybiB0ZXN0MltuXTtcblx0XHR9KTtcblx0XHRpZiAob3JkZXIyLmpvaW4oJycpICE9PSAnMDEyMzQ1Njc4OScpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHQvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD0zMDU2XG5cdFx0dmFyIHRlc3QzID0ge307XG5cdFx0J2FiY2RlZmdoaWprbG1ub3BxcnN0Jy5zcGxpdCgnJykuZm9yRWFjaChmdW5jdGlvbiAobGV0dGVyKSB7XG5cdFx0XHR0ZXN0M1tsZXR0ZXJdID0gbGV0dGVyO1xuXHRcdH0pO1xuXHRcdGlmIChPYmplY3Qua2V5cyhPYmplY3QuYXNzaWduKHt9LCB0ZXN0MykpLmpvaW4oJycpICE9PVxuXHRcdFx0XHQnYWJjZGVmZ2hpamtsbW5vcHFyc3QnKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRydWU7XG5cdH0gY2F0Y2ggKGVycikge1xuXHRcdC8vIFdlIGRvbid0IGV4cGVjdCBhbnkgb2YgdGhlIGFib3ZlIHRvIHRocm93LCBidXQgYmV0dGVyIHRvIGJlIHNhZmUuXG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc2hvdWxkVXNlTmF0aXZlKCkgPyBPYmplY3QuYXNzaWduIDogZnVuY3Rpb24gKHRhcmdldCwgc291cmNlKSB7XG5cdHZhciBmcm9tO1xuXHR2YXIgdG8gPSB0b09iamVjdCh0YXJnZXQpO1xuXHR2YXIgc3ltYm9scztcblxuXHRmb3IgKHZhciBzID0gMTsgcyA8IGFyZ3VtZW50cy5sZW5ndGg7IHMrKykge1xuXHRcdGZyb20gPSBPYmplY3QoYXJndW1lbnRzW3NdKTtcblxuXHRcdGZvciAodmFyIGtleSBpbiBmcm9tKSB7XG5cdFx0XHRpZiAoaGFzT3duUHJvcGVydHkuY2FsbChmcm9tLCBrZXkpKSB7XG5cdFx0XHRcdHRvW2tleV0gPSBmcm9tW2tleV07XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKGdldE93blByb3BlcnR5U3ltYm9scykge1xuXHRcdFx0c3ltYm9scyA9IGdldE93blByb3BlcnR5U3ltYm9scyhmcm9tKTtcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgc3ltYm9scy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRpZiAocHJvcElzRW51bWVyYWJsZS5jYWxsKGZyb20sIHN5bWJvbHNbaV0pKSB7XG5cdFx0XHRcdFx0dG9bc3ltYm9sc1tpXV0gPSBmcm9tW3N5bWJvbHNbaV1dO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIHRvO1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///418\n")},779:(module,__unused_webpack_exports,__webpack_require__)=>{eval("var isarray = __webpack_require__(826)\n\n/**\n * Expose `pathToRegexp`.\n */\nmodule.exports = pathToRegexp\nmodule.exports.parse = parse\nmodule.exports.compile = compile\nmodule.exports.tokensToFunction = tokensToFunction\nmodule.exports.tokensToRegExp = tokensToRegExp\n\n/**\n * The main path matching regexp utility.\n *\n * @type {RegExp}\n */\nvar PATH_REGEXP = new RegExp([\n  // Match escaped characters that would otherwise appear in future matches.\n  // This allows the user to escape special characters that won't transform.\n  '(\\\\\\\\.)',\n  // Match Express-style parameters and un-named parameters with a prefix\n  // and optional suffixes. Matches appear as:\n  //\n  // \"/:test(\\\\d+)?\" => [\"/\", \"test\", \"\\d+\", undefined, \"?\", undefined]\n  // \"/route(\\\\d+)\"  => [undefined, undefined, undefined, \"\\d+\", undefined, undefined]\n  // \"/*\"            => [\"/\", undefined, undefined, undefined, undefined, \"*\"]\n  '([\\\\/.])?(?:(?:\\\\:(\\\\w+)(?:\\\\(((?:\\\\\\\\.|[^\\\\\\\\()])+)\\\\))?|\\\\(((?:\\\\\\\\.|[^\\\\\\\\()])+)\\\\))([+*?])?|(\\\\*))'\n].join('|'), 'g')\n\n/**\n * Parse a string for the raw tokens.\n *\n * @param  {string}  str\n * @param  {Object=} options\n * @return {!Array}\n */\nfunction parse (str, options) {\n  var tokens = []\n  var key = 0\n  var index = 0\n  var path = ''\n  var defaultDelimiter = options && options.delimiter || '/'\n  var res\n\n  while ((res = PATH_REGEXP.exec(str)) != null) {\n    var m = res[0]\n    var escaped = res[1]\n    var offset = res.index\n    path += str.slice(index, offset)\n    index = offset + m.length\n\n    // Ignore already escaped sequences.\n    if (escaped) {\n      path += escaped[1]\n      continue\n    }\n\n    var next = str[index]\n    var prefix = res[2]\n    var name = res[3]\n    var capture = res[4]\n    var group = res[5]\n    var modifier = res[6]\n    var asterisk = res[7]\n\n    // Push the current path onto the tokens.\n    if (path) {\n      tokens.push(path)\n      path = ''\n    }\n\n    var partial = prefix != null && next != null && next !== prefix\n    var repeat = modifier === '+' || modifier === '*'\n    var optional = modifier === '?' || modifier === '*'\n    var delimiter = res[2] || defaultDelimiter\n    var pattern = capture || group\n\n    tokens.push({\n      name: name || key++,\n      prefix: prefix || '',\n      delimiter: delimiter,\n      optional: optional,\n      repeat: repeat,\n      partial: partial,\n      asterisk: !!asterisk,\n      pattern: pattern ? escapeGroup(pattern) : (asterisk ? '.*' : '[^' + escapeString(delimiter) + ']+?')\n    })\n  }\n\n  // Match any characters still remaining.\n  if (index < str.length) {\n    path += str.substr(index)\n  }\n\n  // If the path exists, push it onto the end.\n  if (path) {\n    tokens.push(path)\n  }\n\n  return tokens\n}\n\n/**\n * Compile a string to a template function for the path.\n *\n * @param  {string}             str\n * @param  {Object=}            options\n * @return {!function(Object=, Object=)}\n */\nfunction compile (str, options) {\n  return tokensToFunction(parse(str, options), options)\n}\n\n/**\n * Prettier encoding of URI path segments.\n *\n * @param  {string}\n * @return {string}\n */\nfunction encodeURIComponentPretty (str) {\n  return encodeURI(str).replace(/[\\/?#]/g, function (c) {\n    return '%' + c.charCodeAt(0).toString(16).toUpperCase()\n  })\n}\n\n/**\n * Encode the asterisk parameter. Similar to `pretty`, but allows slashes.\n *\n * @param  {string}\n * @return {string}\n */\nfunction encodeAsterisk (str) {\n  return encodeURI(str).replace(/[?#]/g, function (c) {\n    return '%' + c.charCodeAt(0).toString(16).toUpperCase()\n  })\n}\n\n/**\n * Expose a method for transforming tokens into the path function.\n */\nfunction tokensToFunction (tokens, options) {\n  // Compile all the tokens into regexps.\n  var matches = new Array(tokens.length)\n\n  // Compile all the patterns before compilation.\n  for (var i = 0; i < tokens.length; i++) {\n    if (typeof tokens[i] === 'object') {\n      matches[i] = new RegExp('^(?:' + tokens[i].pattern + ')$', flags(options))\n    }\n  }\n\n  return function (obj, opts) {\n    var path = ''\n    var data = obj || {}\n    var options = opts || {}\n    var encode = options.pretty ? encodeURIComponentPretty : encodeURIComponent\n\n    for (var i = 0; i < tokens.length; i++) {\n      var token = tokens[i]\n\n      if (typeof token === 'string') {\n        path += token\n\n        continue\n      }\n\n      var value = data[token.name]\n      var segment\n\n      if (value == null) {\n        if (token.optional) {\n          // Prepend partial segment prefixes.\n          if (token.partial) {\n            path += token.prefix\n          }\n\n          continue\n        } else {\n          throw new TypeError('Expected \"' + token.name + '\" to be defined')\n        }\n      }\n\n      if (isarray(value)) {\n        if (!token.repeat) {\n          throw new TypeError('Expected \"' + token.name + '\" to not repeat, but received `' + JSON.stringify(value) + '`')\n        }\n\n        if (value.length === 0) {\n          if (token.optional) {\n            continue\n          } else {\n            throw new TypeError('Expected \"' + token.name + '\" to not be empty')\n          }\n        }\n\n        for (var j = 0; j < value.length; j++) {\n          segment = encode(value[j])\n\n          if (!matches[i].test(segment)) {\n            throw new TypeError('Expected all \"' + token.name + '\" to match \"' + token.pattern + '\", but received `' + JSON.stringify(segment) + '`')\n          }\n\n          path += (j === 0 ? token.prefix : token.delimiter) + segment\n        }\n\n        continue\n      }\n\n      segment = token.asterisk ? encodeAsterisk(value) : encode(value)\n\n      if (!matches[i].test(segment)) {\n        throw new TypeError('Expected \"' + token.name + '\" to match \"' + token.pattern + '\", but received \"' + segment + '\"')\n      }\n\n      path += token.prefix + segment\n    }\n\n    return path\n  }\n}\n\n/**\n * Escape a regular expression string.\n *\n * @param  {string} str\n * @return {string}\n */\nfunction escapeString (str) {\n  return str.replace(/([.+*?=^!:${}()[\\]|\\/\\\\])/g, '\\\\$1')\n}\n\n/**\n * Escape the capturing group by escaping special characters and meaning.\n *\n * @param  {string} group\n * @return {string}\n */\nfunction escapeGroup (group) {\n  return group.replace(/([=!:$\\/()])/g, '\\\\$1')\n}\n\n/**\n * Attach the keys as a property of the regexp.\n *\n * @param  {!RegExp} re\n * @param  {Array}   keys\n * @return {!RegExp}\n */\nfunction attachKeys (re, keys) {\n  re.keys = keys\n  return re\n}\n\n/**\n * Get the flags for a regexp from the options.\n *\n * @param  {Object} options\n * @return {string}\n */\nfunction flags (options) {\n  return options && options.sensitive ? '' : 'i'\n}\n\n/**\n * Pull out keys from a regexp.\n *\n * @param  {!RegExp} path\n * @param  {!Array}  keys\n * @return {!RegExp}\n */\nfunction regexpToRegexp (path, keys) {\n  // Use a negative lookahead to match only capturing groups.\n  var groups = path.source.match(/\\((?!\\?)/g)\n\n  if (groups) {\n    for (var i = 0; i < groups.length; i++) {\n      keys.push({\n        name: i,\n        prefix: null,\n        delimiter: null,\n        optional: false,\n        repeat: false,\n        partial: false,\n        asterisk: false,\n        pattern: null\n      })\n    }\n  }\n\n  return attachKeys(path, keys)\n}\n\n/**\n * Transform an array into a regexp.\n *\n * @param  {!Array}  path\n * @param  {Array}   keys\n * @param  {!Object} options\n * @return {!RegExp}\n */\nfunction arrayToRegexp (path, keys, options) {\n  var parts = []\n\n  for (var i = 0; i < path.length; i++) {\n    parts.push(pathToRegexp(path[i], keys, options).source)\n  }\n\n  var regexp = new RegExp('(?:' + parts.join('|') + ')', flags(options))\n\n  return attachKeys(regexp, keys)\n}\n\n/**\n * Create a path regexp from string input.\n *\n * @param  {string}  path\n * @param  {!Array}  keys\n * @param  {!Object} options\n * @return {!RegExp}\n */\nfunction stringToRegexp (path, keys, options) {\n  return tokensToRegExp(parse(path, options), keys, options)\n}\n\n/**\n * Expose a function for taking tokens and returning a RegExp.\n *\n * @param  {!Array}          tokens\n * @param  {(Array|Object)=} keys\n * @param  {Object=}         options\n * @return {!RegExp}\n */\nfunction tokensToRegExp (tokens, keys, options) {\n  if (!isarray(keys)) {\n    options = /** @type {!Object} */ (keys || options)\n    keys = []\n  }\n\n  options = options || {}\n\n  var strict = options.strict\n  var end = options.end !== false\n  var route = ''\n\n  // Iterate over the tokens and create our regexp string.\n  for (var i = 0; i < tokens.length; i++) {\n    var token = tokens[i]\n\n    if (typeof token === 'string') {\n      route += escapeString(token)\n    } else {\n      var prefix = escapeString(token.prefix)\n      var capture = '(?:' + token.pattern + ')'\n\n      keys.push(token)\n\n      if (token.repeat) {\n        capture += '(?:' + prefix + capture + ')*'\n      }\n\n      if (token.optional) {\n        if (!token.partial) {\n          capture = '(?:' + prefix + '(' + capture + '))?'\n        } else {\n          capture = prefix + '(' + capture + ')?'\n        }\n      } else {\n        capture = prefix + '(' + capture + ')'\n      }\n\n      route += capture\n    }\n  }\n\n  var delimiter = escapeString(options.delimiter || '/')\n  var endsWithDelimiter = route.slice(-delimiter.length) === delimiter\n\n  // In non-strict mode we allow a slash at the end of match. If the path to\n  // match already ends with a slash, we remove it for consistency. The slash\n  // is valid at the end of a path match, not in the middle. This is important\n  // in non-ending mode, where \"/test/\" shouldn't match \"/test//route\".\n  if (!strict) {\n    route = (endsWithDelimiter ? route.slice(0, -delimiter.length) : route) + '(?:' + delimiter + '(?=$))?'\n  }\n\n  if (end) {\n    route += '$'\n  } else {\n    // In non-ending mode, we need the capturing groups to match as much as\n    // possible by using a positive lookahead to the end or next path segment.\n    route += strict && endsWithDelimiter ? '' : '(?=' + delimiter + '|$)'\n  }\n\n  return attachKeys(new RegExp('^' + route, flags(options)), keys)\n}\n\n/**\n * Normalize the given path string, returning a regular expression.\n *\n * An empty array can be passed in for the keys, which will hold the\n * placeholder key descriptions. For example, using `/user/:id`, `keys` will\n * contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.\n *\n * @param  {(string|RegExp|Array)} path\n * @param  {(Array|Object)=}       keys\n * @param  {Object=}               options\n * @return {!RegExp}\n */\nfunction pathToRegexp (path, keys, options) {\n  if (!isarray(keys)) {\n    options = /** @type {!Object} */ (keys || options)\n    keys = []\n  }\n\n  options = options || {}\n\n  if (path instanceof RegExp) {\n    return regexpToRegexp(path, /** @type {!Array} */ (keys))\n  }\n\n  if (isarray(path)) {\n    return arrayToRegexp(/** @type {!Array} */ (path), /** @type {!Array} */ (keys), options)\n  }\n\n  return stringToRegexp(/** @type {string} */ (path), /** @type {!Array} */ (keys), options)\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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O0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWSxTQUFTO0FBQ3JCLFlBQVksU0FBUztBQUNyQixZQUFZLFNBQVM7QUFDckIsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVksaUJBQWlCO0FBQzdCLFlBQVksaUJBQWlCO0FBQzdCLFlBQVksaUJBQWlCO0FBQzdCLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsU0FBUztBQUNsQztBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQixtQkFBbUI7QUFDckM7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSw0REFBNEQ7QUFDM0U7QUFDQSxZQUFZLHVCQUF1QjtBQUNuQyxZQUFZLHVCQUF1QjtBQUNuQyxZQUFZLHVCQUF1QjtBQUNuQyxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLFNBQVM7QUFDbEM7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLDJDQUEyQyxRQUFRO0FBQ25EOztBQUVBO0FBQ0Esb0NBQW9DLFFBQVEsc0JBQXNCLFFBQVE7QUFDMUU7O0FBRUEsbUNBQW1DLFFBQVEsc0JBQXNCLFFBQVE7QUFDekUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9ub2RlX21vZHVsZXMvcGF0aC10by1yZWdleHAvaW5kZXguanM/YmQxMSJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgaXNhcnJheSA9IHJlcXVpcmUoJ2lzYXJyYXknKVxuXG4vKipcbiAqIEV4cG9zZSBgcGF0aFRvUmVnZXhwYC5cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBwYXRoVG9SZWdleHBcbm1vZHVsZS5leHBvcnRzLnBhcnNlID0gcGFyc2Vcbm1vZHVsZS5leHBvcnRzLmNvbXBpbGUgPSBjb21waWxlXG5tb2R1bGUuZXhwb3J0cy50b2tlbnNUb0Z1bmN0aW9uID0gdG9rZW5zVG9GdW5jdGlvblxubW9kdWxlLmV4cG9ydHMudG9rZW5zVG9SZWdFeHAgPSB0b2tlbnNUb1JlZ0V4cFxuXG4vKipcbiAqIFRoZSBtYWluIHBhdGggbWF0Y2hpbmcgcmVnZXhwIHV0aWxpdHkuXG4gKlxuICogQHR5cGUge1JlZ0V4cH1cbiAqL1xudmFyIFBBVEhfUkVHRVhQID0gbmV3IFJlZ0V4cChbXG4gIC8vIE1hdGNoIGVzY2FwZWQgY2hhcmFjdGVycyB0aGF0IHdvdWxkIG90aGVyd2lzZSBhcHBlYXIgaW4gZnV0dXJlIG1hdGNoZXMuXG4gIC8vIFRoaXMgYWxsb3dzIHRoZSB1c2VyIHRvIGVzY2FwZSBzcGVjaWFsIGNoYXJhY3RlcnMgdGhhdCB3b24ndCB0cmFuc2Zvcm0uXG4gICcoXFxcXFxcXFwuKScsXG4gIC8vIE1hdGNoIEV4cHJlc3Mtc3R5bGUgcGFyYW1ldGVycyBhbmQgdW4tbmFtZWQgcGFyYW1ldGVycyB3aXRoIGEgcHJlZml4XG4gIC8vIGFuZCBvcHRpb25hbCBzdWZmaXhlcy4gTWF0Y2hlcyBhcHBlYXIgYXM6XG4gIC8vXG4gIC8vIFwiLzp0ZXN0KFxcXFxkKyk/XCIgPT4gW1wiL1wiLCBcInRlc3RcIiwgXCJcXGQrXCIsIHVuZGVmaW5lZCwgXCI/XCIsIHVuZGVmaW5lZF1cbiAgLy8gXCIvcm91dGUoXFxcXGQrKVwiICA9PiBbdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgXCJcXGQrXCIsIHVuZGVmaW5lZCwgdW5kZWZpbmVkXVxuICAvLyBcIi8qXCIgICAgICAgICAgICA9PiBbXCIvXCIsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgXCIqXCJdXG4gICcoW1xcXFwvLl0pPyg/Oig/OlxcXFw6KFxcXFx3KykoPzpcXFxcKCgoPzpcXFxcXFxcXC58W15cXFxcXFxcXCgpXSkrKVxcXFwpKT98XFxcXCgoKD86XFxcXFxcXFwufFteXFxcXFxcXFwoKV0pKylcXFxcKSkoWysqP10pP3woXFxcXCopKSdcbl0uam9pbignfCcpLCAnZycpXG5cbi8qKlxuICogUGFyc2UgYSBzdHJpbmcgZm9yIHRoZSByYXcgdG9rZW5zLlxuICpcbiAqIEBwYXJhbSAge3N0cmluZ30gIHN0clxuICogQHBhcmFtICB7T2JqZWN0PX0gb3B0aW9uc1xuICogQHJldHVybiB7IUFycmF5fVxuICovXG5mdW5jdGlvbiBwYXJzZSAoc3RyLCBvcHRpb25zKSB7XG4gIHZhciB0b2tlbnMgPSBbXVxuICB2YXIga2V5ID0gMFxuICB2YXIgaW5kZXggPSAwXG4gIHZhciBwYXRoID0gJydcbiAgdmFyIGRlZmF1bHREZWxpbWl0ZXIgPSBvcHRpb25zICYmIG9wdGlvbnMuZGVsaW1pdGVyIHx8ICcvJ1xuICB2YXIgcmVzXG5cbiAgd2hpbGUgKChyZXMgPSBQQVRIX1JFR0VYUC5leGVjKHN0cikpICE9IG51bGwpIHtcbiAgICB2YXIgbSA9IHJlc1swXVxuICAgIHZhciBlc2NhcGVkID0gcmVzWzFdXG4gICAgdmFyIG9mZnNldCA9IHJlcy5pbmRleFxuICAgIHBhdGggKz0gc3RyLnNsaWNlKGluZGV4LCBvZmZzZXQpXG4gICAgaW5kZXggPSBvZmZzZXQgKyBtLmxlbmd0aFxuXG4gICAgLy8gSWdub3JlIGFscmVhZHkgZXNjYXBlZCBzZXF1ZW5jZXMuXG4gICAgaWYgKGVzY2FwZWQpIHtcbiAgICAgIHBhdGggKz0gZXNjYXBlZFsxXVxuICAgICAgY29udGludWVcbiAgICB9XG5cbiAgICB2YXIgbmV4dCA9IHN0cltpbmRleF1cbiAgICB2YXIgcHJlZml4ID0gcmVzWzJdXG4gICAgdmFyIG5hbWUgPSByZXNbM11cbiAgICB2YXIgY2FwdHVyZSA9IHJlc1s0XVxuICAgIHZhciBncm91cCA9IHJlc1s1XVxuICAgIHZhciBtb2RpZmllciA9IHJlc1s2XVxuICAgIHZhciBhc3RlcmlzayA9IHJlc1s3XVxuXG4gICAgLy8gUHVzaCB0aGUgY3VycmVudCBwYXRoIG9udG8gdGhlIHRva2Vucy5cbiAgICBpZiAocGF0aCkge1xuICAgICAgdG9rZW5zLnB1c2gocGF0aClcbiAgICAgIHBhdGggPSAnJ1xuICAgIH1cblxuICAgIHZhciBwYXJ0aWFsID0gcHJlZml4ICE9IG51bGwgJiYgbmV4dCAhPSBudWxsICYmIG5leHQgIT09IHByZWZpeFxuICAgIHZhciByZXBlYXQgPSBtb2RpZmllciA9PT0gJysnIHx8IG1vZGlmaWVyID09PSAnKidcbiAgICB2YXIgb3B0aW9uYWwgPSBtb2RpZmllciA9PT0gJz8nIHx8IG1vZGlmaWVyID09PSAnKidcbiAgICB2YXIgZGVsaW1pdGVyID0gcmVzWzJdIHx8IGRlZmF1bHREZWxpbWl0ZXJcbiAgICB2YXIgcGF0dGVybiA9IGNhcHR1cmUgfHwgZ3JvdXBcblxuICAgIHRva2Vucy5wdXNoKHtcbiAgICAgIG5hbWU6IG5hbWUgfHwga2V5KyssXG4gICAgICBwcmVmaXg6IHByZWZpeCB8fCAnJyxcbiAgICAgIGRlbGltaXRlcjogZGVsaW1pdGVyLFxuICAgICAgb3B0aW9uYWw6IG9wdGlvbmFsLFxuICAgICAgcmVwZWF0OiByZXBlYXQsXG4gICAgICBwYXJ0aWFsOiBwYXJ0aWFsLFxuICAgICAgYXN0ZXJpc2s6ICEhYXN0ZXJpc2ssXG4gICAgICBwYXR0ZXJuOiBwYXR0ZXJuID8gZXNjYXBlR3JvdXAocGF0dGVybikgOiAoYXN0ZXJpc2sgPyAnLionIDogJ1teJyArIGVzY2FwZVN0cmluZyhkZWxpbWl0ZXIpICsgJ10rPycpXG4gICAgfSlcbiAgfVxuXG4gIC8vIE1hdGNoIGFueSBjaGFyYWN0ZXJzIHN0aWxsIHJlbWFpbmluZy5cbiAgaWYgKGluZGV4IDwgc3RyLmxlbmd0aCkge1xuICAgIHBhdGggKz0gc3RyLnN1YnN0cihpbmRleClcbiAgfVxuXG4gIC8vIElmIHRoZSBwYXRoIGV4aXN0cywgcHVzaCBpdCBvbnRvIHRoZSBlbmQuXG4gIGlmIChwYXRoKSB7XG4gICAgdG9rZW5zLnB1c2gocGF0aClcbiAgfVxuXG4gIHJldHVybiB0b2tlbnNcbn1cblxuLyoqXG4gKiBDb21waWxlIGEgc3RyaW5nIHRvIGEgdGVtcGxhdGUgZnVuY3Rpb24gZm9yIHRoZSBwYXRoLlxuICpcbiAqIEBwYXJhbSAge3N0cmluZ30gICAgICAgICAgICAgc3RyXG4gKiBAcGFyYW0gIHtPYmplY3Q9fSAgICAgICAgICAgIG9wdGlvbnNcbiAqIEByZXR1cm4geyFmdW5jdGlvbihPYmplY3Q9LCBPYmplY3Q9KX1cbiAqL1xuZnVuY3Rpb24gY29tcGlsZSAoc3RyLCBvcHRpb25zKSB7XG4gIHJldHVybiB0b2tlbnNUb0Z1bmN0aW9uKHBhcnNlKHN0ciwgb3B0aW9ucyksIG9wdGlvbnMpXG59XG5cbi8qKlxuICogUHJldHRpZXIgZW5jb2Rpbmcgb2YgVVJJIHBhdGggc2VnbWVudHMuXG4gKlxuICogQHBhcmFtICB7c3RyaW5nfVxuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBlbmNvZGVVUklDb21wb25lbnRQcmV0dHkgKHN0cikge1xuICByZXR1cm4gZW5jb2RlVVJJKHN0cikucmVwbGFjZSgvW1xcLz8jXS9nLCBmdW5jdGlvbiAoYykge1xuICAgIHJldHVybiAnJScgKyBjLmNoYXJDb2RlQXQoMCkudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKClcbiAgfSlcbn1cblxuLyoqXG4gKiBFbmNvZGUgdGhlIGFzdGVyaXNrIHBhcmFtZXRlci4gU2ltaWxhciB0byBgcHJldHR5YCwgYnV0IGFsbG93cyBzbGFzaGVzLlxuICpcbiAqIEBwYXJhbSAge3N0cmluZ31cbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gZW5jb2RlQXN0ZXJpc2sgKHN0cikge1xuICByZXR1cm4gZW5jb2RlVVJJKHN0cikucmVwbGFjZSgvWz8jXS9nLCBmdW5jdGlvbiAoYykge1xuICAgIHJldHVybiAnJScgKyBjLmNoYXJDb2RlQXQoMCkudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKClcbiAgfSlcbn1cblxuLyoqXG4gKiBFeHBvc2UgYSBtZXRob2QgZm9yIHRyYW5zZm9ybWluZyB0b2tlbnMgaW50byB0aGUgcGF0aCBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gdG9rZW5zVG9GdW5jdGlvbiAodG9rZW5zLCBvcHRpb25zKSB7XG4gIC8vIENvbXBpbGUgYWxsIHRoZSB0b2tlbnMgaW50byByZWdleHBzLlxuICB2YXIgbWF0Y2hlcyA9IG5ldyBBcnJheSh0b2tlbnMubGVuZ3RoKVxuXG4gIC8vIENvbXBpbGUgYWxsIHRoZSBwYXR0ZXJucyBiZWZvcmUgY29tcGlsYXRpb24uXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdG9rZW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKHR5cGVvZiB0b2tlbnNbaV0gPT09ICdvYmplY3QnKSB7XG4gICAgICBtYXRjaGVzW2ldID0gbmV3IFJlZ0V4cCgnXig/OicgKyB0b2tlbnNbaV0ucGF0dGVybiArICcpJCcsIGZsYWdzKG9wdGlvbnMpKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiAob2JqLCBvcHRzKSB7XG4gICAgdmFyIHBhdGggPSAnJ1xuICAgIHZhciBkYXRhID0gb2JqIHx8IHt9XG4gICAgdmFyIG9wdGlvbnMgPSBvcHRzIHx8IHt9XG4gICAgdmFyIGVuY29kZSA9IG9wdGlvbnMucHJldHR5ID8gZW5jb2RlVVJJQ29tcG9uZW50UHJldHR5IDogZW5jb2RlVVJJQ29tcG9uZW50XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRva2Vucy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHRva2VuID0gdG9rZW5zW2ldXG5cbiAgICAgIGlmICh0eXBlb2YgdG9rZW4gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHBhdGggKz0gdG9rZW5cblxuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICB2YXIgdmFsdWUgPSBkYXRhW3Rva2VuLm5hbWVdXG4gICAgICB2YXIgc2VnbWVudFxuXG4gICAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgICBpZiAodG9rZW4ub3B0aW9uYWwpIHtcbiAgICAgICAgICAvLyBQcmVwZW5kIHBhcnRpYWwgc2VnbWVudCBwcmVmaXhlcy5cbiAgICAgICAgICBpZiAodG9rZW4ucGFydGlhbCkge1xuICAgICAgICAgICAgcGF0aCArPSB0b2tlbi5wcmVmaXhcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0V4cGVjdGVkIFwiJyArIHRva2VuLm5hbWUgKyAnXCIgdG8gYmUgZGVmaW5lZCcpXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGlzYXJyYXkodmFsdWUpKSB7XG4gICAgICAgIGlmICghdG9rZW4ucmVwZWF0KSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgXCInICsgdG9rZW4ubmFtZSArICdcIiB0byBub3QgcmVwZWF0LCBidXQgcmVjZWl2ZWQgYCcgKyBKU09OLnN0cmluZ2lmeSh2YWx1ZSkgKyAnYCcpXG4gICAgICAgIH1cblxuICAgICAgICBpZiAodmFsdWUubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgaWYgKHRva2VuLm9wdGlvbmFsKSB7XG4gICAgICAgICAgICBjb250aW51ZVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdFeHBlY3RlZCBcIicgKyB0b2tlbi5uYW1lICsgJ1wiIHRvIG5vdCBiZSBlbXB0eScpXG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB2YWx1ZS5sZW5ndGg7IGorKykge1xuICAgICAgICAgIHNlZ21lbnQgPSBlbmNvZGUodmFsdWVbal0pXG5cbiAgICAgICAgICBpZiAoIW1hdGNoZXNbaV0udGVzdChzZWdtZW50KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgYWxsIFwiJyArIHRva2VuLm5hbWUgKyAnXCIgdG8gbWF0Y2ggXCInICsgdG9rZW4ucGF0dGVybiArICdcIiwgYnV0IHJlY2VpdmVkIGAnICsgSlNPTi5zdHJpbmdpZnkoc2VnbWVudCkgKyAnYCcpXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcGF0aCArPSAoaiA9PT0gMCA/IHRva2VuLnByZWZpeCA6IHRva2VuLmRlbGltaXRlcikgKyBzZWdtZW50XG4gICAgICAgIH1cblxuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICBzZWdtZW50ID0gdG9rZW4uYXN0ZXJpc2sgPyBlbmNvZGVBc3Rlcmlzayh2YWx1ZSkgOiBlbmNvZGUodmFsdWUpXG5cbiAgICAgIGlmICghbWF0Y2hlc1tpXS50ZXN0KHNlZ21lbnQpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0V4cGVjdGVkIFwiJyArIHRva2VuLm5hbWUgKyAnXCIgdG8gbWF0Y2ggXCInICsgdG9rZW4ucGF0dGVybiArICdcIiwgYnV0IHJlY2VpdmVkIFwiJyArIHNlZ21lbnQgKyAnXCInKVxuICAgICAgfVxuXG4gICAgICBwYXRoICs9IHRva2VuLnByZWZpeCArIHNlZ21lbnRcbiAgICB9XG5cbiAgICByZXR1cm4gcGF0aFxuICB9XG59XG5cbi8qKlxuICogRXNjYXBlIGEgcmVndWxhciBleHByZXNzaW9uIHN0cmluZy5cbiAqXG4gKiBAcGFyYW0gIHtzdHJpbmd9IHN0clxuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBlc2NhcGVTdHJpbmcgKHN0cikge1xuICByZXR1cm4gc3RyLnJlcGxhY2UoLyhbLisqPz1eIToke30oKVtcXF18XFwvXFxcXF0pL2csICdcXFxcJDEnKVxufVxuXG4vKipcbiAqIEVzY2FwZSB0aGUgY2FwdHVyaW5nIGdyb3VwIGJ5IGVzY2FwaW5nIHNwZWNpYWwgY2hhcmFjdGVycyBhbmQgbWVhbmluZy5cbiAqXG4gKiBAcGFyYW0gIHtzdHJpbmd9IGdyb3VwXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGVzY2FwZUdyb3VwIChncm91cCkge1xuICByZXR1cm4gZ3JvdXAucmVwbGFjZSgvKFs9ITokXFwvKCldKS9nLCAnXFxcXCQxJylcbn1cblxuLyoqXG4gKiBBdHRhY2ggdGhlIGtleXMgYXMgYSBwcm9wZXJ0eSBvZiB0aGUgcmVnZXhwLlxuICpcbiAqIEBwYXJhbSAgeyFSZWdFeHB9IHJlXG4gKiBAcGFyYW0gIHtBcnJheX0gICBrZXlzXG4gKiBAcmV0dXJuIHshUmVnRXhwfVxuICovXG5mdW5jdGlvbiBhdHRhY2hLZXlzIChyZSwga2V5cykge1xuICByZS5rZXlzID0ga2V5c1xuICByZXR1cm4gcmVcbn1cblxuLyoqXG4gKiBHZXQgdGhlIGZsYWdzIGZvciBhIHJlZ2V4cCBmcm9tIHRoZSBvcHRpb25zLlxuICpcbiAqIEBwYXJhbSAge09iamVjdH0gb3B0aW9uc1xuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBmbGFncyAob3B0aW9ucykge1xuICByZXR1cm4gb3B0aW9ucyAmJiBvcHRpb25zLnNlbnNpdGl2ZSA/ICcnIDogJ2knXG59XG5cbi8qKlxuICogUHVsbCBvdXQga2V5cyBmcm9tIGEgcmVnZXhwLlxuICpcbiAqIEBwYXJhbSAgeyFSZWdFeHB9IHBhdGhcbiAqIEBwYXJhbSAgeyFBcnJheX0gIGtleXNcbiAqIEByZXR1cm4geyFSZWdFeHB9XG4gKi9cbmZ1bmN0aW9uIHJlZ2V4cFRvUmVnZXhwIChwYXRoLCBrZXlzKSB7XG4gIC8vIFVzZSBhIG5lZ2F0aXZlIGxvb2thaGVhZCB0byBtYXRjaCBvbmx5IGNhcHR1cmluZyBncm91cHMuXG4gIHZhciBncm91cHMgPSBwYXRoLnNvdXJjZS5tYXRjaCgvXFwoKD8hXFw/KS9nKVxuXG4gIGlmIChncm91cHMpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGdyb3Vwcy5sZW5ndGg7IGkrKykge1xuICAgICAga2V5cy5wdXNoKHtcbiAgICAgICAgbmFtZTogaSxcbiAgICAgICAgcHJlZml4OiBudWxsLFxuICAgICAgICBkZWxpbWl0ZXI6IG51bGwsXG4gICAgICAgIG9wdGlvbmFsOiBmYWxzZSxcbiAgICAgICAgcmVwZWF0OiBmYWxzZSxcbiAgICAgICAgcGFydGlhbDogZmFsc2UsXG4gICAgICAgIGFzdGVyaXNrOiBmYWxzZSxcbiAgICAgICAgcGF0dGVybjogbnVsbFxuICAgICAgfSlcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYXR0YWNoS2V5cyhwYXRoLCBrZXlzKVxufVxuXG4vKipcbiAqIFRyYW5zZm9ybSBhbiBhcnJheSBpbnRvIGEgcmVnZXhwLlxuICpcbiAqIEBwYXJhbSAgeyFBcnJheX0gIHBhdGhcbiAqIEBwYXJhbSAge0FycmF5fSAgIGtleXNcbiAqIEBwYXJhbSAgeyFPYmplY3R9IG9wdGlvbnNcbiAqIEByZXR1cm4geyFSZWdFeHB9XG4gKi9cbmZ1bmN0aW9uIGFycmF5VG9SZWdleHAgKHBhdGgsIGtleXMsIG9wdGlvbnMpIHtcbiAgdmFyIHBhcnRzID0gW11cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHBhdGgubGVuZ3RoOyBpKyspIHtcbiAgICBwYXJ0cy5wdXNoKHBhdGhUb1JlZ2V4cChwYXRoW2ldLCBrZXlzLCBvcHRpb25zKS5zb3VyY2UpXG4gIH1cblxuICB2YXIgcmVnZXhwID0gbmV3IFJlZ0V4cCgnKD86JyArIHBhcnRzLmpvaW4oJ3wnKSArICcpJywgZmxhZ3Mob3B0aW9ucykpXG5cbiAgcmV0dXJuIGF0dGFjaEtleXMocmVnZXhwLCBrZXlzKVxufVxuXG4vKipcbiAqIENyZWF0ZSBhIHBhdGggcmVnZXhwIGZyb20gc3RyaW5nIGlucHV0LlxuICpcbiAqIEBwYXJhbSAge3N0cmluZ30gIHBhdGhcbiAqIEBwYXJhbSAgeyFBcnJheX0gIGtleXNcbiAqIEBwYXJhbSAgeyFPYmplY3R9IG9wdGlvbnNcbiAqIEByZXR1cm4geyFSZWdFeHB9XG4gKi9cbmZ1bmN0aW9uIHN0cmluZ1RvUmVnZXhwIChwYXRoLCBrZXlzLCBvcHRpb25zKSB7XG4gIHJldHVybiB0b2tlbnNUb1JlZ0V4cChwYXJzZShwYXRoLCBvcHRpb25zKSwga2V5cywgb3B0aW9ucylcbn1cblxuLyoqXG4gKiBFeHBvc2UgYSBmdW5jdGlvbiBmb3IgdGFraW5nIHRva2VucyBhbmQgcmV0dXJuaW5nIGEgUmVnRXhwLlxuICpcbiAqIEBwYXJhbSAgeyFBcnJheX0gICAgICAgICAgdG9rZW5zXG4gKiBAcGFyYW0gIHsoQXJyYXl8T2JqZWN0KT19IGtleXNcbiAqIEBwYXJhbSAge09iamVjdD19ICAgICAgICAgb3B0aW9uc1xuICogQHJldHVybiB7IVJlZ0V4cH1cbiAqL1xuZnVuY3Rpb24gdG9rZW5zVG9SZWdFeHAgKHRva2Vucywga2V5cywgb3B0aW9ucykge1xuICBpZiAoIWlzYXJyYXkoa2V5cykpIHtcbiAgICBvcHRpb25zID0gLyoqIEB0eXBlIHshT2JqZWN0fSAqLyAoa2V5cyB8fCBvcHRpb25zKVxuICAgIGtleXMgPSBbXVxuICB9XG5cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge31cblxuICB2YXIgc3RyaWN0ID0gb3B0aW9ucy5zdHJpY3RcbiAgdmFyIGVuZCA9IG9wdGlvbnMuZW5kICE9PSBmYWxzZVxuICB2YXIgcm91dGUgPSAnJ1xuXG4gIC8vIEl0ZXJhdGUgb3ZlciB0aGUgdG9rZW5zIGFuZCBjcmVhdGUgb3VyIHJlZ2V4cCBzdHJpbmcuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdG9rZW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHRva2VuID0gdG9rZW5zW2ldXG5cbiAgICBpZiAodHlwZW9mIHRva2VuID09PSAnc3RyaW5nJykge1xuICAgICAgcm91dGUgKz0gZXNjYXBlU3RyaW5nKHRva2VuKVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgcHJlZml4ID0gZXNjYXBlU3RyaW5nKHRva2VuLnByZWZpeClcbiAgICAgIHZhciBjYXB0dXJlID0gJyg/OicgKyB0b2tlbi5wYXR0ZXJuICsgJyknXG5cbiAgICAgIGtleXMucHVzaCh0b2tlbilcblxuICAgICAgaWYgKHRva2VuLnJlcGVhdCkge1xuICAgICAgICBjYXB0dXJlICs9ICcoPzonICsgcHJlZml4ICsgY2FwdHVyZSArICcpKidcbiAgICAgIH1cblxuICAgICAgaWYgKHRva2VuLm9wdGlvbmFsKSB7XG4gICAgICAgIGlmICghdG9rZW4ucGFydGlhbCkge1xuICAgICAgICAgIGNhcHR1cmUgPSAnKD86JyArIHByZWZpeCArICcoJyArIGNhcHR1cmUgKyAnKSk/J1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNhcHR1cmUgPSBwcmVmaXggKyAnKCcgKyBjYXB0dXJlICsgJyk/J1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjYXB0dXJlID0gcHJlZml4ICsgJygnICsgY2FwdHVyZSArICcpJ1xuICAgICAgfVxuXG4gICAgICByb3V0ZSArPSBjYXB0dXJlXG4gICAgfVxuICB9XG5cbiAgdmFyIGRlbGltaXRlciA9IGVzY2FwZVN0cmluZyhvcHRpb25zLmRlbGltaXRlciB8fCAnLycpXG4gIHZhciBlbmRzV2l0aERlbGltaXRlciA9IHJvdXRlLnNsaWNlKC1kZWxpbWl0ZXIubGVuZ3RoKSA9PT0gZGVsaW1pdGVyXG5cbiAgLy8gSW4gbm9uLXN0cmljdCBtb2RlIHdlIGFsbG93IGEgc2xhc2ggYXQgdGhlIGVuZCBvZiBtYXRjaC4gSWYgdGhlIHBhdGggdG9cbiAgLy8gbWF0Y2ggYWxyZWFkeSBlbmRzIHdpdGggYSBzbGFzaCwgd2UgcmVtb3ZlIGl0IGZvciBjb25zaXN0ZW5jeS4gVGhlIHNsYXNoXG4gIC8vIGlzIHZhbGlkIGF0IHRoZSBlbmQgb2YgYSBwYXRoIG1hdGNoLCBub3QgaW4gdGhlIG1pZGRsZS4gVGhpcyBpcyBpbXBvcnRhbnRcbiAgLy8gaW4gbm9uLWVuZGluZyBtb2RlLCB3aGVyZSBcIi90ZXN0L1wiIHNob3VsZG4ndCBtYXRjaCBcIi90ZXN0Ly9yb3V0ZVwiLlxuICBpZiAoIXN0cmljdCkge1xuICAgIHJvdXRlID0gKGVuZHNXaXRoRGVsaW1pdGVyID8gcm91dGUuc2xpY2UoMCwgLWRlbGltaXRlci5sZW5ndGgpIDogcm91dGUpICsgJyg/OicgKyBkZWxpbWl0ZXIgKyAnKD89JCkpPydcbiAgfVxuXG4gIGlmIChlbmQpIHtcbiAgICByb3V0ZSArPSAnJCdcbiAgfSBlbHNlIHtcbiAgICAvLyBJbiBub24tZW5kaW5nIG1vZGUsIHdlIG5lZWQgdGhlIGNhcHR1cmluZyBncm91cHMgdG8gbWF0Y2ggYXMgbXVjaCBhc1xuICAgIC8vIHBvc3NpYmxlIGJ5IHVzaW5nIGEgcG9zaXRpdmUgbG9va2FoZWFkIHRvIHRoZSBlbmQgb3IgbmV4dCBwYXRoIHNlZ21lbnQuXG4gICAgcm91dGUgKz0gc3RyaWN0ICYmIGVuZHNXaXRoRGVsaW1pdGVyID8gJycgOiAnKD89JyArIGRlbGltaXRlciArICd8JCknXG4gIH1cblxuICByZXR1cm4gYXR0YWNoS2V5cyhuZXcgUmVnRXhwKCdeJyArIHJvdXRlLCBmbGFncyhvcHRpb25zKSksIGtleXMpXG59XG5cbi8qKlxuICogTm9ybWFsaXplIHRoZSBnaXZlbiBwYXRoIHN0cmluZywgcmV0dXJuaW5nIGEgcmVndWxhciBleHByZXNzaW9uLlxuICpcbiAqIEFuIGVtcHR5IGFycmF5IGNhbiBiZSBwYXNzZWQgaW4gZm9yIHRoZSBrZXlzLCB3aGljaCB3aWxsIGhvbGQgdGhlXG4gKiBwbGFjZWhvbGRlciBrZXkgZGVzY3JpcHRpb25zLiBGb3IgZXhhbXBsZSwgdXNpbmcgYC91c2VyLzppZGAsIGBrZXlzYCB3aWxsXG4gKiBjb250YWluIGBbeyBuYW1lOiAnaWQnLCBkZWxpbWl0ZXI6ICcvJywgb3B0aW9uYWw6IGZhbHNlLCByZXBlYXQ6IGZhbHNlIH1dYC5cbiAqXG4gKiBAcGFyYW0gIHsoc3RyaW5nfFJlZ0V4cHxBcnJheSl9IHBhdGhcbiAqIEBwYXJhbSAgeyhBcnJheXxPYmplY3QpPX0gICAgICAga2V5c1xuICogQHBhcmFtICB7T2JqZWN0PX0gICAgICAgICAgICAgICBvcHRpb25zXG4gKiBAcmV0dXJuIHshUmVnRXhwfVxuICovXG5mdW5jdGlvbiBwYXRoVG9SZWdleHAgKHBhdGgsIGtleXMsIG9wdGlvbnMpIHtcbiAgaWYgKCFpc2FycmF5KGtleXMpKSB7XG4gICAgb3B0aW9ucyA9IC8qKiBAdHlwZSB7IU9iamVjdH0gKi8gKGtleXMgfHwgb3B0aW9ucylcbiAgICBrZXlzID0gW11cbiAgfVxuXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9XG5cbiAgaWYgKHBhdGggaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICByZXR1cm4gcmVnZXhwVG9SZWdleHAocGF0aCwgLyoqIEB0eXBlIHshQXJyYXl9ICovIChrZXlzKSlcbiAgfVxuXG4gIGlmIChpc2FycmF5KHBhdGgpKSB7XG4gICAgcmV0dXJuIGFycmF5VG9SZWdleHAoLyoqIEB0eXBlIHshQXJyYXl9ICovIChwYXRoKSwgLyoqIEB0eXBlIHshQXJyYXl9ICovIChrZXlzKSwgb3B0aW9ucylcbiAgfVxuXG4gIHJldHVybiBzdHJpbmdUb1JlZ2V4cCgvKiogQHR5cGUge3N0cmluZ30gKi8gKHBhdGgpLCAvKiogQHR5cGUgeyFBcnJheX0gKi8gKGtleXMpLCBvcHRpb25zKVxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///779\n")},703:(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n\nvar ReactPropTypesSecret = __webpack_require__(414);\n\nfunction emptyFunction() {}\nfunction emptyFunctionWithReset() {}\nemptyFunctionWithReset.resetWarningCache = emptyFunction;\n\nmodule.exports = function() {\n  function shim(props, propName, componentName, location, propFullName, secret) {\n    if (secret === ReactPropTypesSecret) {\n      // It is still safe when called from React.\n      return;\n    }\n    var err = new Error(\n      'Calling PropTypes validators directly is not supported by the `prop-types` package. ' +\n      'Use PropTypes.checkPropTypes() to call them. ' +\n      'Read more at http://fb.me/use-check-prop-types'\n    );\n    err.name = 'Invariant Violation';\n    throw err;\n  };\n  shim.isRequired = shim;\n  function getShim() {\n    return shim;\n  };\n  // Important!\n  // Keep this list in sync with production version in `./factoryWithTypeCheckers.js`.\n  var ReactPropTypes = {\n    array: shim,\n    bool: shim,\n    func: shim,\n    number: shim,\n    object: shim,\n    string: shim,\n    symbol: shim,\n\n    any: shim,\n    arrayOf: getShim,\n    element: shim,\n    elementType: shim,\n    instanceOf: getShim,\n    node: shim,\n    objectOf: getShim,\n    oneOf: getShim,\n    oneOfType: getShim,\n    shape: getShim,\n    exact: getShim,\n\n    checkPropTypes: emptyFunctionWithReset,\n    resetWarningCache: emptyFunction\n  };\n\n  ReactPropTypes.PropTypes = ReactPropTypes;\n\n  return ReactPropTypes;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzAzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFYTs7QUFFYiwyQkFBMkIsbUJBQU8sQ0FBQyxHQUE0Qjs7QUFFL0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9ub2RlX21vZHVsZXMvcHJvcC10eXBlcy9mYWN0b3J5V2l0aFRocm93aW5nU2hpbXMuanM/ZDdhMCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0UHJvcFR5cGVzU2VjcmV0ID0gcmVxdWlyZSgnLi9saWIvUmVhY3RQcm9wVHlwZXNTZWNyZXQnKTtcblxuZnVuY3Rpb24gZW1wdHlGdW5jdGlvbigpIHt9XG5mdW5jdGlvbiBlbXB0eUZ1bmN0aW9uV2l0aFJlc2V0KCkge31cbmVtcHR5RnVuY3Rpb25XaXRoUmVzZXQucmVzZXRXYXJuaW5nQ2FjaGUgPSBlbXB0eUZ1bmN0aW9uO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKCkge1xuICBmdW5jdGlvbiBzaGltKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSwgc2VjcmV0KSB7XG4gICAgaWYgKHNlY3JldCA9PT0gUmVhY3RQcm9wVHlwZXNTZWNyZXQpIHtcbiAgICAgIC8vIEl0IGlzIHN0aWxsIHNhZmUgd2hlbiBjYWxsZWQgZnJvbSBSZWFjdC5cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIGVyciA9IG5ldyBFcnJvcihcbiAgICAgICdDYWxsaW5nIFByb3BUeXBlcyB2YWxpZGF0b3JzIGRpcmVjdGx5IGlzIG5vdCBzdXBwb3J0ZWQgYnkgdGhlIGBwcm9wLXR5cGVzYCBwYWNrYWdlLiAnICtcbiAgICAgICdVc2UgUHJvcFR5cGVzLmNoZWNrUHJvcFR5cGVzKCkgdG8gY2FsbCB0aGVtLiAnICtcbiAgICAgICdSZWFkIG1vcmUgYXQgaHR0cDovL2ZiLm1lL3VzZS1jaGVjay1wcm9wLXR5cGVzJ1xuICAgICk7XG4gICAgZXJyLm5hbWUgPSAnSW52YXJpYW50IFZpb2xhdGlvbic7XG4gICAgdGhyb3cgZXJyO1xuICB9O1xuICBzaGltLmlzUmVxdWlyZWQgPSBzaGltO1xuICBmdW5jdGlvbiBnZXRTaGltKCkge1xuICAgIHJldHVybiBzaGltO1xuICB9O1xuICAvLyBJbXBvcnRhbnQhXG4gIC8vIEtlZXAgdGhpcyBsaXN0IGluIHN5bmMgd2l0aCBwcm9kdWN0aW9uIHZlcnNpb24gaW4gYC4vZmFjdG9yeVdpdGhUeXBlQ2hlY2tlcnMuanNgLlxuICB2YXIgUmVhY3RQcm9wVHlwZXMgPSB7XG4gICAgYXJyYXk6IHNoaW0sXG4gICAgYm9vbDogc2hpbSxcbiAgICBmdW5jOiBzaGltLFxuICAgIG51bWJlcjogc2hpbSxcbiAgICBvYmplY3Q6IHNoaW0sXG4gICAgc3RyaW5nOiBzaGltLFxuICAgIHN5bWJvbDogc2hpbSxcblxuICAgIGFueTogc2hpbSxcbiAgICBhcnJheU9mOiBnZXRTaGltLFxuICAgIGVsZW1lbnQ6IHNoaW0sXG4gICAgZWxlbWVudFR5cGU6IHNoaW0sXG4gICAgaW5zdGFuY2VPZjogZ2V0U2hpbSxcbiAgICBub2RlOiBzaGltLFxuICAgIG9iamVjdE9mOiBnZXRTaGltLFxuICAgIG9uZU9mOiBnZXRTaGltLFxuICAgIG9uZU9mVHlwZTogZ2V0U2hpbSxcbiAgICBzaGFwZTogZ2V0U2hpbSxcbiAgICBleGFjdDogZ2V0U2hpbSxcblxuICAgIGNoZWNrUHJvcFR5cGVzOiBlbXB0eUZ1bmN0aW9uV2l0aFJlc2V0LFxuICAgIHJlc2V0V2FybmluZ0NhY2hlOiBlbXB0eUZ1bmN0aW9uXG4gIH07XG5cbiAgUmVhY3RQcm9wVHlwZXMuUHJvcFR5cGVzID0gUmVhY3RQcm9wVHlwZXM7XG5cbiAgcmV0dXJuIFJlYWN0UHJvcFR5cGVzO1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///703\n")},697:(module,__unused_webpack_exports,__webpack_require__)=>{eval("/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nif (false) { var throwOnDirectAccess, ReactIs; } else {\n  // By explicitly using `prop-types` you are opting into new production behavior.\n  // http://fb.me/prop-types-in-prod\n  module.exports = __webpack_require__(703)();\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjk3LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxJQUFJLEtBQXFDLEVBQUUscUNBTzFDLENBQUM7QUFDRjtBQUNBO0FBQ0EsbUJBQW1CLG1CQUFPLENBQUMsR0FBNEI7QUFDdkQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9ub2RlX21vZHVsZXMvcHJvcC10eXBlcy9pbmRleC5qcz9kN2JjIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgdmFyIFJlYWN0SXMgPSByZXF1aXJlKCdyZWFjdC1pcycpO1xuXG4gIC8vIEJ5IGV4cGxpY2l0bHkgdXNpbmcgYHByb3AtdHlwZXNgIHlvdSBhcmUgb3B0aW5nIGludG8gbmV3IGRldmVsb3BtZW50IGJlaGF2aW9yLlxuICAvLyBodHRwOi8vZmIubWUvcHJvcC10eXBlcy1pbi1wcm9kXG4gIHZhciB0aHJvd09uRGlyZWN0QWNjZXNzID0gdHJ1ZTtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2ZhY3RvcnlXaXRoVHlwZUNoZWNrZXJzJykoUmVhY3RJcy5pc0VsZW1lbnQsIHRocm93T25EaXJlY3RBY2Nlc3MpO1xufSBlbHNlIHtcbiAgLy8gQnkgZXhwbGljaXRseSB1c2luZyBgcHJvcC10eXBlc2AgeW91IGFyZSBvcHRpbmcgaW50byBuZXcgcHJvZHVjdGlvbiBiZWhhdmlvci5cbiAgLy8gaHR0cDovL2ZiLm1lL3Byb3AtdHlwZXMtaW4tcHJvZFxuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vZmFjdG9yeVdpdGhUaHJvd2luZ1NoaW1zJykoKTtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///697\n")},414:module=>{"use strict";eval("/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n\nvar ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';\n\nmodule.exports = ReactPropTypesSecret;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDE0LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFYTs7QUFFYjs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL21kYy1yZWFjdC8uL25vZGVfbW9kdWxlcy9wcm9wLXR5cGVzL2xpYi9SZWFjdFByb3BUeXBlc1NlY3JldC5qcz81OWIwIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3RQcm9wVHlwZXNTZWNyZXQgPSAnU0VDUkVUX0RPX05PVF9QQVNTX1RISVNfT1JfWU9VX1dJTExfQkVfRklSRUQnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0UHJvcFR5cGVzU2VjcmV0O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///414\n")},448:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('/** @license React v17.0.2\n * react-dom.production.min.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n/*\n Modernizr 3.0.0pre (Custom Build) | MIT\n*/\nvar aa=__webpack_require__(294),m=__webpack_require__(418),r=__webpack_require__(840);function y(a){for(var b="https://reactjs.org/docs/error-decoder.html?invariant="+a,c=1;c<arguments.length;c++)b+="&args[]="+encodeURIComponent(arguments[c]);return"Minified React error #"+a+"; visit "+b+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}if(!aa)throw Error(y(227));var ba=new Set,ca={};function da(a,b){ea(a,b);ea(a+"Capture",b)}\nfunction ea(a,b){ca[a]=b;for(a=0;a<b.length;a++)ba.add(b[a])}\nvar fa=!("undefined"===typeof window||"undefined"===typeof window.document||"undefined"===typeof window.document.createElement),ha=/^[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$/,ia=Object.prototype.hasOwnProperty,\nja={},ka={};function la(a){if(ia.call(ka,a))return!0;if(ia.call(ja,a))return!1;if(ha.test(a))return ka[a]=!0;ja[a]=!0;return!1}function ma(a,b,c,d){if(null!==c&&0===c.type)return!1;switch(typeof b){case "function":case "symbol":return!0;case "boolean":if(d)return!1;if(null!==c)return!c.acceptsBooleans;a=a.toLowerCase().slice(0,5);return"data-"!==a&&"aria-"!==a;default:return!1}}\nfunction na(a,b,c,d){if(null===b||"undefined"===typeof b||ma(a,b,c,d))return!0;if(d)return!1;if(null!==c)switch(c.type){case 3:return!b;case 4:return!1===b;case 5:return isNaN(b);case 6:return isNaN(b)||1>b}return!1}function B(a,b,c,d,e,f,g){this.acceptsBooleans=2===b||3===b||4===b;this.attributeName=d;this.attributeNamespace=e;this.mustUseProperty=c;this.propertyName=a;this.type=b;this.sanitizeURL=f;this.removeEmptyString=g}var D={};\n"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(a){D[a]=new B(a,0,!1,a,null,!1,!1)});[["acceptCharset","accept-charset"],["className","class"],["htmlFor","for"],["httpEquiv","http-equiv"]].forEach(function(a){var b=a[0];D[b]=new B(b,1,!1,a[1],null,!1,!1)});["contentEditable","draggable","spellCheck","value"].forEach(function(a){D[a]=new B(a,2,!1,a.toLowerCase(),null,!1,!1)});\n["autoReverse","externalResourcesRequired","focusable","preserveAlpha"].forEach(function(a){D[a]=new B(a,2,!1,a,null,!1,!1)});"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(a){D[a]=new B(a,3,!1,a.toLowerCase(),null,!1,!1)});\n["checked","multiple","muted","selected"].forEach(function(a){D[a]=new B(a,3,!0,a,null,!1,!1)});["capture","download"].forEach(function(a){D[a]=new B(a,4,!1,a,null,!1,!1)});["cols","rows","size","span"].forEach(function(a){D[a]=new B(a,6,!1,a,null,!1,!1)});["rowSpan","start"].forEach(function(a){D[a]=new B(a,5,!1,a.toLowerCase(),null,!1,!1)});var oa=/[\\-:]([a-z])/g;function pa(a){return a[1].toUpperCase()}\n"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(a){var b=a.replace(oa,\npa);D[b]=new B(b,1,!1,a,null,!1,!1)});"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(a){var b=a.replace(oa,pa);D[b]=new B(b,1,!1,a,"http://www.w3.org/1999/xlink",!1,!1)});["xml:base","xml:lang","xml:space"].forEach(function(a){var b=a.replace(oa,pa);D[b]=new B(b,1,!1,a,"http://www.w3.org/XML/1998/namespace",!1,!1)});["tabIndex","crossOrigin"].forEach(function(a){D[a]=new B(a,1,!1,a.toLowerCase(),null,!1,!1)});\nD.xlinkHref=new B("xlinkHref",1,!1,"xlink:href","http://www.w3.org/1999/xlink",!0,!1);["src","href","action","formAction"].forEach(function(a){D[a]=new B(a,1,!1,a.toLowerCase(),null,!0,!0)});\nfunction qa(a,b,c,d){var e=D.hasOwnProperty(b)?D[b]:null;var f=null!==e?0===e.type:d?!1:!(2<b.length)||"o"!==b[0]&&"O"!==b[0]||"n"!==b[1]&&"N"!==b[1]?!1:!0;f||(na(b,c,e,d)&&(c=null),d||null===e?la(b)&&(null===c?a.removeAttribute(b):a.setAttribute(b,""+c)):e.mustUseProperty?a[e.propertyName]=null===c?3===e.type?!1:"":c:(b=e.attributeName,d=e.attributeNamespace,null===c?a.removeAttribute(b):(e=e.type,c=3===e||4===e&&!0===c?"":""+c,d?a.setAttributeNS(d,b,c):a.setAttribute(b,c))))}\nvar ra=aa.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,sa=60103,ta=60106,ua=60107,wa=60108,xa=60114,ya=60109,za=60110,Aa=60112,Ba=60113,Ca=60120,Da=60115,Ea=60116,Fa=60121,Ga=60128,Ha=60129,Ia=60130,Ja=60131;\nif("function"===typeof Symbol&&Symbol.for){var E=Symbol.for;sa=E("react.element");ta=E("react.portal");ua=E("react.fragment");wa=E("react.strict_mode");xa=E("react.profiler");ya=E("react.provider");za=E("react.context");Aa=E("react.forward_ref");Ba=E("react.suspense");Ca=E("react.suspense_list");Da=E("react.memo");Ea=E("react.lazy");Fa=E("react.block");E("react.scope");Ga=E("react.opaque.id");Ha=E("react.debug_trace_mode");Ia=E("react.offscreen");Ja=E("react.legacy_hidden")}\nvar Ka="function"===typeof Symbol&&Symbol.iterator;function La(a){if(null===a||"object"!==typeof a)return null;a=Ka&&a[Ka]||a["@@iterator"];return"function"===typeof a?a:null}var Ma;function Na(a){if(void 0===Ma)try{throw Error();}catch(c){var b=c.stack.trim().match(/\\n( *(at )?)/);Ma=b&&b[1]||""}return"\\n"+Ma+a}var Oa=!1;\nfunction Pa(a,b){if(!a||Oa)return"";Oa=!0;var c=Error.prepareStackTrace;Error.prepareStackTrace=void 0;try{if(b)if(b=function(){throw Error();},Object.defineProperty(b.prototype,"props",{set:function(){throw Error();}}),"object"===typeof Reflect&&Reflect.construct){try{Reflect.construct(b,[])}catch(k){var d=k}Reflect.construct(a,[],b)}else{try{b.call()}catch(k){d=k}a.call(b.prototype)}else{try{throw Error();}catch(k){d=k}a()}}catch(k){if(k&&d&&"string"===typeof k.stack){for(var e=k.stack.split("\\n"),\nf=d.stack.split("\\n"),g=e.length-1,h=f.length-1;1<=g&&0<=h&&e[g]!==f[h];)h--;for(;1<=g&&0<=h;g--,h--)if(e[g]!==f[h]){if(1!==g||1!==h){do if(g--,h--,0>h||e[g]!==f[h])return"\\n"+e[g].replace(" at new "," at ");while(1<=g&&0<=h)}break}}}finally{Oa=!1,Error.prepareStackTrace=c}return(a=a?a.displayName||a.name:"")?Na(a):""}\nfunction Qa(a){switch(a.tag){case 5:return Na(a.type);case 16:return Na("Lazy");case 13:return Na("Suspense");case 19:return Na("SuspenseList");case 0:case 2:case 15:return a=Pa(a.type,!1),a;case 11:return a=Pa(a.type.render,!1),a;case 22:return a=Pa(a.type._render,!1),a;case 1:return a=Pa(a.type,!0),a;default:return""}}\nfunction Ra(a){if(null==a)return null;if("function"===typeof a)return a.displayName||a.name||null;if("string"===typeof a)return a;switch(a){case ua:return"Fragment";case ta:return"Portal";case xa:return"Profiler";case wa:return"StrictMode";case Ba:return"Suspense";case Ca:return"SuspenseList"}if("object"===typeof a)switch(a.$$typeof){case za:return(a.displayName||"Context")+".Consumer";case ya:return(a._context.displayName||"Context")+".Provider";case Aa:var b=a.render;b=b.displayName||b.name||"";\nreturn a.displayName||(""!==b?"ForwardRef("+b+")":"ForwardRef");case Da:return Ra(a.type);case Fa:return Ra(a._render);case Ea:b=a._payload;a=a._init;try{return Ra(a(b))}catch(c){}}return null}function Sa(a){switch(typeof a){case "boolean":case "number":case "object":case "string":case "undefined":return a;default:return""}}function Ta(a){var b=a.type;return(a=a.nodeName)&&"input"===a.toLowerCase()&&("checkbox"===b||"radio"===b)}\nfunction Ua(a){var b=Ta(a)?"checked":"value",c=Object.getOwnPropertyDescriptor(a.constructor.prototype,b),d=""+a[b];if(!a.hasOwnProperty(b)&&"undefined"!==typeof c&&"function"===typeof c.get&&"function"===typeof c.set){var e=c.get,f=c.set;Object.defineProperty(a,b,{configurable:!0,get:function(){return e.call(this)},set:function(a){d=""+a;f.call(this,a)}});Object.defineProperty(a,b,{enumerable:c.enumerable});return{getValue:function(){return d},setValue:function(a){d=""+a},stopTracking:function(){a._valueTracker=\nnull;delete a[b]}}}}function Va(a){a._valueTracker||(a._valueTracker=Ua(a))}function Wa(a){if(!a)return!1;var b=a._valueTracker;if(!b)return!0;var c=b.getValue();var d="";a&&(d=Ta(a)?a.checked?"true":"false":a.value);a=d;return a!==c?(b.setValue(a),!0):!1}function Xa(a){a=a||("undefined"!==typeof document?document:void 0);if("undefined"===typeof a)return null;try{return a.activeElement||a.body}catch(b){return a.body}}\nfunction Ya(a,b){var c=b.checked;return m({},b,{defaultChecked:void 0,defaultValue:void 0,value:void 0,checked:null!=c?c:a._wrapperState.initialChecked})}function Za(a,b){var c=null==b.defaultValue?"":b.defaultValue,d=null!=b.checked?b.checked:b.defaultChecked;c=Sa(null!=b.value?b.value:c);a._wrapperState={initialChecked:d,initialValue:c,controlled:"checkbox"===b.type||"radio"===b.type?null!=b.checked:null!=b.value}}function $a(a,b){b=b.checked;null!=b&&qa(a,"checked",b,!1)}\nfunction ab(a,b){$a(a,b);var c=Sa(b.value),d=b.type;if(null!=c)if("number"===d){if(0===c&&""===a.value||a.value!=c)a.value=""+c}else a.value!==""+c&&(a.value=""+c);else if("submit"===d||"reset"===d){a.removeAttribute("value");return}b.hasOwnProperty("value")?bb(a,b.type,c):b.hasOwnProperty("defaultValue")&&bb(a,b.type,Sa(b.defaultValue));null==b.checked&&null!=b.defaultChecked&&(a.defaultChecked=!!b.defaultChecked)}\nfunction cb(a,b,c){if(b.hasOwnProperty("value")||b.hasOwnProperty("defaultValue")){var d=b.type;if(!("submit"!==d&&"reset"!==d||void 0!==b.value&&null!==b.value))return;b=""+a._wrapperState.initialValue;c||b===a.value||(a.value=b);a.defaultValue=b}c=a.name;""!==c&&(a.name="");a.defaultChecked=!!a._wrapperState.initialChecked;""!==c&&(a.name=c)}\nfunction bb(a,b,c){if("number"!==b||Xa(a.ownerDocument)!==a)null==c?a.defaultValue=""+a._wrapperState.initialValue:a.defaultValue!==""+c&&(a.defaultValue=""+c)}function db(a){var b="";aa.Children.forEach(a,function(a){null!=a&&(b+=a)});return b}function eb(a,b){a=m({children:void 0},b);if(b=db(b.children))a.children=b;return a}\nfunction fb(a,b,c,d){a=a.options;if(b){b={};for(var e=0;e<c.length;e++)b["$"+c[e]]=!0;for(c=0;c<a.length;c++)e=b.hasOwnProperty("$"+a[c].value),a[c].selected!==e&&(a[c].selected=e),e&&d&&(a[c].defaultSelected=!0)}else{c=""+Sa(c);b=null;for(e=0;e<a.length;e++){if(a[e].value===c){a[e].selected=!0;d&&(a[e].defaultSelected=!0);return}null!==b||a[e].disabled||(b=a[e])}null!==b&&(b.selected=!0)}}\nfunction gb(a,b){if(null!=b.dangerouslySetInnerHTML)throw Error(y(91));return m({},b,{value:void 0,defaultValue:void 0,children:""+a._wrapperState.initialValue})}function hb(a,b){var c=b.value;if(null==c){c=b.children;b=b.defaultValue;if(null!=c){if(null!=b)throw Error(y(92));if(Array.isArray(c)){if(!(1>=c.length))throw Error(y(93));c=c[0]}b=c}null==b&&(b="");c=b}a._wrapperState={initialValue:Sa(c)}}\nfunction ib(a,b){var c=Sa(b.value),d=Sa(b.defaultValue);null!=c&&(c=""+c,c!==a.value&&(a.value=c),null==b.defaultValue&&a.defaultValue!==c&&(a.defaultValue=c));null!=d&&(a.defaultValue=""+d)}function jb(a){var b=a.textContent;b===a._wrapperState.initialValue&&""!==b&&null!==b&&(a.value=b)}var kb={html:"http://www.w3.org/1999/xhtml",mathml:"http://www.w3.org/1998/Math/MathML",svg:"http://www.w3.org/2000/svg"};\nfunction lb(a){switch(a){case "svg":return"http://www.w3.org/2000/svg";case "math":return"http://www.w3.org/1998/Math/MathML";default:return"http://www.w3.org/1999/xhtml"}}function mb(a,b){return null==a||"http://www.w3.org/1999/xhtml"===a?lb(b):"http://www.w3.org/2000/svg"===a&&"foreignObject"===b?"http://www.w3.org/1999/xhtml":a}\nvar nb,ob=function(a){return"undefined"!==typeof MSApp&&MSApp.execUnsafeLocalFunction?function(b,c,d,e){MSApp.execUnsafeLocalFunction(function(){return a(b,c,d,e)})}:a}(function(a,b){if(a.namespaceURI!==kb.svg||"innerHTML"in a)a.innerHTML=b;else{nb=nb||document.createElement("div");nb.innerHTML="<svg>"+b.valueOf().toString()+"</svg>";for(b=nb.firstChild;a.firstChild;)a.removeChild(a.firstChild);for(;b.firstChild;)a.appendChild(b.firstChild)}});\nfunction pb(a,b){if(b){var c=a.firstChild;if(c&&c===a.lastChild&&3===c.nodeType){c.nodeValue=b;return}}a.textContent=b}\nvar qb={animationIterationCount:!0,borderImageOutset:!0,borderImageSlice:!0,borderImageWidth:!0,boxFlex:!0,boxFlexGroup:!0,boxOrdinalGroup:!0,columnCount:!0,columns:!0,flex:!0,flexGrow:!0,flexPositive:!0,flexShrink:!0,flexNegative:!0,flexOrder:!0,gridArea:!0,gridRow:!0,gridRowEnd:!0,gridRowSpan:!0,gridRowStart:!0,gridColumn:!0,gridColumnEnd:!0,gridColumnSpan:!0,gridColumnStart:!0,fontWeight:!0,lineClamp:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,tabSize:!0,widows:!0,zIndex:!0,zoom:!0,fillOpacity:!0,\nfloodOpacity:!0,stopOpacity:!0,strokeDasharray:!0,strokeDashoffset:!0,strokeMiterlimit:!0,strokeOpacity:!0,strokeWidth:!0},rb=["Webkit","ms","Moz","O"];Object.keys(qb).forEach(function(a){rb.forEach(function(b){b=b+a.charAt(0).toUpperCase()+a.substring(1);qb[b]=qb[a]})});function sb(a,b,c){return null==b||"boolean"===typeof b||""===b?"":c||"number"!==typeof b||0===b||qb.hasOwnProperty(a)&&qb[a]?(""+b).trim():b+"px"}\nfunction tb(a,b){a=a.style;for(var c in b)if(b.hasOwnProperty(c)){var d=0===c.indexOf("--"),e=sb(c,b[c],d);"float"===c&&(c="cssFloat");d?a.setProperty(c,e):a[c]=e}}var ub=m({menuitem:!0},{area:!0,base:!0,br:!0,col:!0,embed:!0,hr:!0,img:!0,input:!0,keygen:!0,link:!0,meta:!0,param:!0,source:!0,track:!0,wbr:!0});\nfunction vb(a,b){if(b){if(ub[a]&&(null!=b.children||null!=b.dangerouslySetInnerHTML))throw Error(y(137,a));if(null!=b.dangerouslySetInnerHTML){if(null!=b.children)throw Error(y(60));if(!("object"===typeof b.dangerouslySetInnerHTML&&"__html"in b.dangerouslySetInnerHTML))throw Error(y(61));}if(null!=b.style&&"object"!==typeof b.style)throw Error(y(62));}}\nfunction wb(a,b){if(-1===a.indexOf("-"))return"string"===typeof b.is;switch(a){case "annotation-xml":case "color-profile":case "font-face":case "font-face-src":case "font-face-uri":case "font-face-format":case "font-face-name":case "missing-glyph":return!1;default:return!0}}function xb(a){a=a.target||a.srcElement||window;a.correspondingUseElement&&(a=a.correspondingUseElement);return 3===a.nodeType?a.parentNode:a}var yb=null,zb=null,Ab=null;\nfunction Bb(a){if(a=Cb(a)){if("function"!==typeof yb)throw Error(y(280));var b=a.stateNode;b&&(b=Db(b),yb(a.stateNode,a.type,b))}}function Eb(a){zb?Ab?Ab.push(a):Ab=[a]:zb=a}function Fb(){if(zb){var a=zb,b=Ab;Ab=zb=null;Bb(a);if(b)for(a=0;a<b.length;a++)Bb(b[a])}}function Gb(a,b){return a(b)}function Hb(a,b,c,d,e){return a(b,c,d,e)}function Ib(){}var Jb=Gb,Kb=!1,Lb=!1;function Mb(){if(null!==zb||null!==Ab)Ib(),Fb()}\nfunction Nb(a,b,c){if(Lb)return a(b,c);Lb=!0;try{return Jb(a,b,c)}finally{Lb=!1,Mb()}}\nfunction Ob(a,b){var c=a.stateNode;if(null===c)return null;var d=Db(c);if(null===d)return null;c=d[b];a:switch(b){case "onClick":case "onClickCapture":case "onDoubleClick":case "onDoubleClickCapture":case "onMouseDown":case "onMouseDownCapture":case "onMouseMove":case "onMouseMoveCapture":case "onMouseUp":case "onMouseUpCapture":case "onMouseEnter":(d=!d.disabled)||(a=a.type,d=!("button"===a||"input"===a||"select"===a||"textarea"===a));a=!d;break a;default:a=!1}if(a)return null;if(c&&"function"!==\ntypeof c)throw Error(y(231,b,typeof c));return c}var Pb=!1;if(fa)try{var Qb={};Object.defineProperty(Qb,"passive",{get:function(){Pb=!0}});window.addEventListener("test",Qb,Qb);window.removeEventListener("test",Qb,Qb)}catch(a){Pb=!1}function Rb(a,b,c,d,e,f,g,h,k){var l=Array.prototype.slice.call(arguments,3);try{b.apply(c,l)}catch(n){this.onError(n)}}var Sb=!1,Tb=null,Ub=!1,Vb=null,Wb={onError:function(a){Sb=!0;Tb=a}};function Xb(a,b,c,d,e,f,g,h,k){Sb=!1;Tb=null;Rb.apply(Wb,arguments)}\nfunction Yb(a,b,c,d,e,f,g,h,k){Xb.apply(this,arguments);if(Sb){if(Sb){var l=Tb;Sb=!1;Tb=null}else throw Error(y(198));Ub||(Ub=!0,Vb=l)}}function Zb(a){var b=a,c=a;if(a.alternate)for(;b.return;)b=b.return;else{a=b;do b=a,0!==(b.flags&1026)&&(c=b.return),a=b.return;while(a)}return 3===b.tag?c:null}function $b(a){if(13===a.tag){var b=a.memoizedState;null===b&&(a=a.alternate,null!==a&&(b=a.memoizedState));if(null!==b)return b.dehydrated}return null}function ac(a){if(Zb(a)!==a)throw Error(y(188));}\nfunction bc(a){var b=a.alternate;if(!b){b=Zb(a);if(null===b)throw Error(y(188));return b!==a?null:a}for(var c=a,d=b;;){var e=c.return;if(null===e)break;var f=e.alternate;if(null===f){d=e.return;if(null!==d){c=d;continue}break}if(e.child===f.child){for(f=e.child;f;){if(f===c)return ac(e),a;if(f===d)return ac(e),b;f=f.sibling}throw Error(y(188));}if(c.return!==d.return)c=e,d=f;else{for(var g=!1,h=e.child;h;){if(h===c){g=!0;c=e;d=f;break}if(h===d){g=!0;d=e;c=f;break}h=h.sibling}if(!g){for(h=f.child;h;){if(h===\nc){g=!0;c=f;d=e;break}if(h===d){g=!0;d=f;c=e;break}h=h.sibling}if(!g)throw Error(y(189));}}if(c.alternate!==d)throw Error(y(190));}if(3!==c.tag)throw Error(y(188));return c.stateNode.current===c?a:b}function cc(a){a=bc(a);if(!a)return null;for(var b=a;;){if(5===b.tag||6===b.tag)return b;if(b.child)b.child.return=b,b=b.child;else{if(b===a)break;for(;!b.sibling;){if(!b.return||b.return===a)return null;b=b.return}b.sibling.return=b.return;b=b.sibling}}return null}\nfunction dc(a,b){for(var c=a.alternate;null!==b;){if(b===a||b===c)return!0;b=b.return}return!1}var ec,fc,gc,hc,ic=!1,jc=[],kc=null,lc=null,mc=null,nc=new Map,oc=new Map,pc=[],qc="mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");\nfunction rc(a,b,c,d,e){return{blockedOn:a,domEventName:b,eventSystemFlags:c|16,nativeEvent:e,targetContainers:[d]}}function sc(a,b){switch(a){case "focusin":case "focusout":kc=null;break;case "dragenter":case "dragleave":lc=null;break;case "mouseover":case "mouseout":mc=null;break;case "pointerover":case "pointerout":nc.delete(b.pointerId);break;case "gotpointercapture":case "lostpointercapture":oc.delete(b.pointerId)}}\nfunction tc(a,b,c,d,e,f){if(null===a||a.nativeEvent!==f)return a=rc(b,c,d,e,f),null!==b&&(b=Cb(b),null!==b&&fc(b)),a;a.eventSystemFlags|=d;b=a.targetContainers;null!==e&&-1===b.indexOf(e)&&b.push(e);return a}\nfunction uc(a,b,c,d,e){switch(b){case "focusin":return kc=tc(kc,a,b,c,d,e),!0;case "dragenter":return lc=tc(lc,a,b,c,d,e),!0;case "mouseover":return mc=tc(mc,a,b,c,d,e),!0;case "pointerover":var f=e.pointerId;nc.set(f,tc(nc.get(f)||null,a,b,c,d,e));return!0;case "gotpointercapture":return f=e.pointerId,oc.set(f,tc(oc.get(f)||null,a,b,c,d,e)),!0}return!1}\nfunction vc(a){var b=wc(a.target);if(null!==b){var c=Zb(b);if(null!==c)if(b=c.tag,13===b){if(b=$b(c),null!==b){a.blockedOn=b;hc(a.lanePriority,function(){r.unstable_runWithPriority(a.priority,function(){gc(c)})});return}}else if(3===b&&c.stateNode.hydrate){a.blockedOn=3===c.tag?c.stateNode.containerInfo:null;return}}a.blockedOn=null}\nfunction xc(a){if(null!==a.blockedOn)return!1;for(var b=a.targetContainers;0<b.length;){var c=yc(a.domEventName,a.eventSystemFlags,b[0],a.nativeEvent);if(null!==c)return b=Cb(c),null!==b&&fc(b),a.blockedOn=c,!1;b.shift()}return!0}function zc(a,b,c){xc(a)&&c.delete(b)}\nfunction Ac(){for(ic=!1;0<jc.length;){var a=jc[0];if(null!==a.blockedOn){a=Cb(a.blockedOn);null!==a&&ec(a);break}for(var b=a.targetContainers;0<b.length;){var c=yc(a.domEventName,a.eventSystemFlags,b[0],a.nativeEvent);if(null!==c){a.blockedOn=c;break}b.shift()}null===a.blockedOn&&jc.shift()}null!==kc&&xc(kc)&&(kc=null);null!==lc&&xc(lc)&&(lc=null);null!==mc&&xc(mc)&&(mc=null);nc.forEach(zc);oc.forEach(zc)}\nfunction Bc(a,b){a.blockedOn===b&&(a.blockedOn=null,ic||(ic=!0,r.unstable_scheduleCallback(r.unstable_NormalPriority,Ac)))}\nfunction Cc(a){function b(b){return Bc(b,a)}if(0<jc.length){Bc(jc[0],a);for(var c=1;c<jc.length;c++){var d=jc[c];d.blockedOn===a&&(d.blockedOn=null)}}null!==kc&&Bc(kc,a);null!==lc&&Bc(lc,a);null!==mc&&Bc(mc,a);nc.forEach(b);oc.forEach(b);for(c=0;c<pc.length;c++)d=pc[c],d.blockedOn===a&&(d.blockedOn=null);for(;0<pc.length&&(c=pc[0],null===c.blockedOn);)vc(c),null===c.blockedOn&&pc.shift()}\nfunction Dc(a,b){var c={};c[a.toLowerCase()]=b.toLowerCase();c["Webkit"+a]="webkit"+b;c["Moz"+a]="moz"+b;return c}var Ec={animationend:Dc("Animation","AnimationEnd"),animationiteration:Dc("Animation","AnimationIteration"),animationstart:Dc("Animation","AnimationStart"),transitionend:Dc("Transition","TransitionEnd")},Fc={},Gc={};\nfa&&(Gc=document.createElement("div").style,"AnimationEvent"in window||(delete Ec.animationend.animation,delete Ec.animationiteration.animation,delete Ec.animationstart.animation),"TransitionEvent"in window||delete Ec.transitionend.transition);function Hc(a){if(Fc[a])return Fc[a];if(!Ec[a])return a;var b=Ec[a],c;for(c in b)if(b.hasOwnProperty(c)&&c in Gc)return Fc[a]=b[c];return a}\nvar Ic=Hc("animationend"),Jc=Hc("animationiteration"),Kc=Hc("animationstart"),Lc=Hc("transitionend"),Mc=new Map,Nc=new Map,Oc=["abort","abort",Ic,"animationEnd",Jc,"animationIteration",Kc,"animationStart","canplay","canPlay","canplaythrough","canPlayThrough","durationchange","durationChange","emptied","emptied","encrypted","encrypted","ended","ended","error","error","gotpointercapture","gotPointerCapture","load","load","loadeddata","loadedData","loadedmetadata","loadedMetadata","loadstart","loadStart",\n"lostpointercapture","lostPointerCapture","playing","playing","progress","progress","seeking","seeking","stalled","stalled","suspend","suspend","timeupdate","timeUpdate",Lc,"transitionEnd","waiting","waiting"];function Pc(a,b){for(var c=0;c<a.length;c+=2){var d=a[c],e=a[c+1];e="on"+(e[0].toUpperCase()+e.slice(1));Nc.set(d,b);Mc.set(d,e);da(e,[d])}}var Qc=r.unstable_now;Qc();var F=8;\nfunction Rc(a){if(0!==(1&a))return F=15,1;if(0!==(2&a))return F=14,2;if(0!==(4&a))return F=13,4;var b=24&a;if(0!==b)return F=12,b;if(0!==(a&32))return F=11,32;b=192&a;if(0!==b)return F=10,b;if(0!==(a&256))return F=9,256;b=3584&a;if(0!==b)return F=8,b;if(0!==(a&4096))return F=7,4096;b=4186112&a;if(0!==b)return F=6,b;b=62914560&a;if(0!==b)return F=5,b;if(a&67108864)return F=4,67108864;if(0!==(a&134217728))return F=3,134217728;b=805306368&a;if(0!==b)return F=2,b;if(0!==(1073741824&a))return F=1,1073741824;\nF=8;return a}function Sc(a){switch(a){case 99:return 15;case 98:return 10;case 97:case 96:return 8;case 95:return 2;default:return 0}}function Tc(a){switch(a){case 15:case 14:return 99;case 13:case 12:case 11:case 10:return 98;case 9:case 8:case 7:case 6:case 4:case 5:return 97;case 3:case 2:case 1:return 95;case 0:return 90;default:throw Error(y(358,a));}}\nfunction Uc(a,b){var c=a.pendingLanes;if(0===c)return F=0;var d=0,e=0,f=a.expiredLanes,g=a.suspendedLanes,h=a.pingedLanes;if(0!==f)d=f,e=F=15;else if(f=c&134217727,0!==f){var k=f&~g;0!==k?(d=Rc(k),e=F):(h&=f,0!==h&&(d=Rc(h),e=F))}else f=c&~g,0!==f?(d=Rc(f),e=F):0!==h&&(d=Rc(h),e=F);if(0===d)return 0;d=31-Vc(d);d=c&((0>d?0:1<<d)<<1)-1;if(0!==b&&b!==d&&0===(b&g)){Rc(b);if(e<=F)return b;F=e}b=a.entangledLanes;if(0!==b)for(a=a.entanglements,b&=d;0<b;)c=31-Vc(b),e=1<<c,d|=a[c],b&=~e;return d}\nfunction Wc(a){a=a.pendingLanes&-1073741825;return 0!==a?a:a&1073741824?1073741824:0}function Xc(a,b){switch(a){case 15:return 1;case 14:return 2;case 12:return a=Yc(24&~b),0===a?Xc(10,b):a;case 10:return a=Yc(192&~b),0===a?Xc(8,b):a;case 8:return a=Yc(3584&~b),0===a&&(a=Yc(4186112&~b),0===a&&(a=512)),a;case 2:return b=Yc(805306368&~b),0===b&&(b=268435456),b}throw Error(y(358,a));}function Yc(a){return a&-a}function Zc(a){for(var b=[],c=0;31>c;c++)b.push(a);return b}\nfunction $c(a,b,c){a.pendingLanes|=b;var d=b-1;a.suspendedLanes&=d;a.pingedLanes&=d;a=a.eventTimes;b=31-Vc(b);a[b]=c}var Vc=Math.clz32?Math.clz32:ad,bd=Math.log,cd=Math.LN2;function ad(a){return 0===a?32:31-(bd(a)/cd|0)|0}var dd=r.unstable_UserBlockingPriority,ed=r.unstable_runWithPriority,fd=!0;function gd(a,b,c,d){Kb||Ib();var e=hd,f=Kb;Kb=!0;try{Hb(e,a,b,c,d)}finally{(Kb=f)||Mb()}}function id(a,b,c,d){ed(dd,hd.bind(null,a,b,c,d))}\nfunction hd(a,b,c,d){if(fd){var e;if((e=0===(b&4))&&0<jc.length&&-1<qc.indexOf(a))a=rc(null,a,b,c,d),jc.push(a);else{var f=yc(a,b,c,d);if(null===f)e&&sc(a,d);else{if(e){if(-1<qc.indexOf(a)){a=rc(f,a,b,c,d);jc.push(a);return}if(uc(f,a,b,c,d))return;sc(a,d)}jd(a,b,d,null,c)}}}}\nfunction yc(a,b,c,d){var e=xb(d);e=wc(e);if(null!==e){var f=Zb(e);if(null===f)e=null;else{var g=f.tag;if(13===g){e=$b(f);if(null!==e)return e;e=null}else if(3===g){if(f.stateNode.hydrate)return 3===f.tag?f.stateNode.containerInfo:null;e=null}else f!==e&&(e=null)}}jd(a,b,d,e,c);return null}var kd=null,ld=null,md=null;\nfunction nd(){if(md)return md;var a,b=ld,c=b.length,d,e="value"in kd?kd.value:kd.textContent,f=e.length;for(a=0;a<c&&b[a]===e[a];a++);var g=c-a;for(d=1;d<=g&&b[c-d]===e[f-d];d++);return md=e.slice(a,1<d?1-d:void 0)}function od(a){var b=a.keyCode;"charCode"in a?(a=a.charCode,0===a&&13===b&&(a=13)):a=b;10===a&&(a=13);return 32<=a||13===a?a:0}function pd(){return!0}function qd(){return!1}\nfunction rd(a){function b(b,d,e,f,g){this._reactName=b;this._targetInst=e;this.type=d;this.nativeEvent=f;this.target=g;this.currentTarget=null;for(var c in a)a.hasOwnProperty(c)&&(b=a[c],this[c]=b?b(f):f[c]);this.isDefaultPrevented=(null!=f.defaultPrevented?f.defaultPrevented:!1===f.returnValue)?pd:qd;this.isPropagationStopped=qd;return this}m(b.prototype,{preventDefault:function(){this.defaultPrevented=!0;var a=this.nativeEvent;a&&(a.preventDefault?a.preventDefault():"unknown"!==typeof a.returnValue&&\n(a.returnValue=!1),this.isDefaultPrevented=pd)},stopPropagation:function(){var a=this.nativeEvent;a&&(a.stopPropagation?a.stopPropagation():"unknown"!==typeof a.cancelBubble&&(a.cancelBubble=!0),this.isPropagationStopped=pd)},persist:function(){},isPersistent:pd});return b}\nvar sd={eventPhase:0,bubbles:0,cancelable:0,timeStamp:function(a){return a.timeStamp||Date.now()},defaultPrevented:0,isTrusted:0},td=rd(sd),ud=m({},sd,{view:0,detail:0}),vd=rd(ud),wd,xd,yd,Ad=m({},ud,{screenX:0,screenY:0,clientX:0,clientY:0,pageX:0,pageY:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,getModifierState:zd,button:0,buttons:0,relatedTarget:function(a){return void 0===a.relatedTarget?a.fromElement===a.srcElement?a.toElement:a.fromElement:a.relatedTarget},movementX:function(a){if("movementX"in\na)return a.movementX;a!==yd&&(yd&&"mousemove"===a.type?(wd=a.screenX-yd.screenX,xd=a.screenY-yd.screenY):xd=wd=0,yd=a);return wd},movementY:function(a){return"movementY"in a?a.movementY:xd}}),Bd=rd(Ad),Cd=m({},Ad,{dataTransfer:0}),Dd=rd(Cd),Ed=m({},ud,{relatedTarget:0}),Fd=rd(Ed),Gd=m({},sd,{animationName:0,elapsedTime:0,pseudoElement:0}),Hd=rd(Gd),Id=m({},sd,{clipboardData:function(a){return"clipboardData"in a?a.clipboardData:window.clipboardData}}),Jd=rd(Id),Kd=m({},sd,{data:0}),Ld=rd(Kd),Md={Esc:"Escape",\nSpacebar:" ",Left:"ArrowLeft",Up:"ArrowUp",Right:"ArrowRight",Down:"ArrowDown",Del:"Delete",Win:"OS",Menu:"ContextMenu",Apps:"ContextMenu",Scroll:"ScrollLock",MozPrintableKey:"Unidentified"},Nd={8:"Backspace",9:"Tab",12:"Clear",13:"Enter",16:"Shift",17:"Control",18:"Alt",19:"Pause",20:"CapsLock",27:"Escape",32:" ",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"ArrowLeft",38:"ArrowUp",39:"ArrowRight",40:"ArrowDown",45:"Insert",46:"Delete",112:"F1",113:"F2",114:"F3",115:"F4",116:"F5",117:"F6",118:"F7",\n119:"F8",120:"F9",121:"F10",122:"F11",123:"F12",144:"NumLock",145:"ScrollLock",224:"Meta"},Od={Alt:"altKey",Control:"ctrlKey",Meta:"metaKey",Shift:"shiftKey"};function Pd(a){var b=this.nativeEvent;return b.getModifierState?b.getModifierState(a):(a=Od[a])?!!b[a]:!1}function zd(){return Pd}\nvar Qd=m({},ud,{key:function(a){if(a.key){var b=Md[a.key]||a.key;if("Unidentified"!==b)return b}return"keypress"===a.type?(a=od(a),13===a?"Enter":String.fromCharCode(a)):"keydown"===a.type||"keyup"===a.type?Nd[a.keyCode]||"Unidentified":""},code:0,location:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,repeat:0,locale:0,getModifierState:zd,charCode:function(a){return"keypress"===a.type?od(a):0},keyCode:function(a){return"keydown"===a.type||"keyup"===a.type?a.keyCode:0},which:function(a){return"keypress"===\na.type?od(a):"keydown"===a.type||"keyup"===a.type?a.keyCode:0}}),Rd=rd(Qd),Sd=m({},Ad,{pointerId:0,width:0,height:0,pressure:0,tangentialPressure:0,tiltX:0,tiltY:0,twist:0,pointerType:0,isPrimary:0}),Td=rd(Sd),Ud=m({},ud,{touches:0,targetTouches:0,changedTouches:0,altKey:0,metaKey:0,ctrlKey:0,shiftKey:0,getModifierState:zd}),Vd=rd(Ud),Wd=m({},sd,{propertyName:0,elapsedTime:0,pseudoElement:0}),Xd=rd(Wd),Yd=m({},Ad,{deltaX:function(a){return"deltaX"in a?a.deltaX:"wheelDeltaX"in a?-a.wheelDeltaX:0},\ndeltaY:function(a){return"deltaY"in a?a.deltaY:"wheelDeltaY"in a?-a.wheelDeltaY:"wheelDelta"in a?-a.wheelDelta:0},deltaZ:0,deltaMode:0}),Zd=rd(Yd),$d=[9,13,27,32],ae=fa&&"CompositionEvent"in window,be=null;fa&&"documentMode"in document&&(be=document.documentMode);var ce=fa&&"TextEvent"in window&&!be,de=fa&&(!ae||be&&8<be&&11>=be),ee=String.fromCharCode(32),fe=!1;\nfunction ge(a,b){switch(a){case "keyup":return-1!==$d.indexOf(b.keyCode);case "keydown":return 229!==b.keyCode;case "keypress":case "mousedown":case "focusout":return!0;default:return!1}}function he(a){a=a.detail;return"object"===typeof a&&"data"in a?a.data:null}var ie=!1;function je(a,b){switch(a){case "compositionend":return he(b);case "keypress":if(32!==b.which)return null;fe=!0;return ee;case "textInput":return a=b.data,a===ee&&fe?null:a;default:return null}}\nfunction ke(a,b){if(ie)return"compositionend"===a||!ae&&ge(a,b)?(a=nd(),md=ld=kd=null,ie=!1,a):null;switch(a){case "paste":return null;case "keypress":if(!(b.ctrlKey||b.altKey||b.metaKey)||b.ctrlKey&&b.altKey){if(b.char&&1<b.char.length)return b.char;if(b.which)return String.fromCharCode(b.which)}return null;case "compositionend":return de&&"ko"!==b.locale?null:b.data;default:return null}}\nvar le={color:!0,date:!0,datetime:!0,"datetime-local":!0,email:!0,month:!0,number:!0,password:!0,range:!0,search:!0,tel:!0,text:!0,time:!0,url:!0,week:!0};function me(a){var b=a&&a.nodeName&&a.nodeName.toLowerCase();return"input"===b?!!le[a.type]:"textarea"===b?!0:!1}function ne(a,b,c,d){Eb(d);b=oe(b,"onChange");0<b.length&&(c=new td("onChange","change",null,c,d),a.push({event:c,listeners:b}))}var pe=null,qe=null;function re(a){se(a,0)}function te(a){var b=ue(a);if(Wa(b))return a}\nfunction ve(a,b){if("change"===a)return b}var we=!1;if(fa){var xe;if(fa){var ye="oninput"in document;if(!ye){var ze=document.createElement("div");ze.setAttribute("oninput","return;");ye="function"===typeof ze.oninput}xe=ye}else xe=!1;we=xe&&(!document.documentMode||9<document.documentMode)}function Ae(){pe&&(pe.detachEvent("onpropertychange",Be),qe=pe=null)}function Be(a){if("value"===a.propertyName&&te(qe)){var b=[];ne(b,qe,a,xb(a));a=re;if(Kb)a(b);else{Kb=!0;try{Gb(a,b)}finally{Kb=!1,Mb()}}}}\nfunction Ce(a,b,c){"focusin"===a?(Ae(),pe=b,qe=c,pe.attachEvent("onpropertychange",Be)):"focusout"===a&&Ae()}function De(a){if("selectionchange"===a||"keyup"===a||"keydown"===a)return te(qe)}function Ee(a,b){if("click"===a)return te(b)}function Fe(a,b){if("input"===a||"change"===a)return te(b)}function Ge(a,b){return a===b&&(0!==a||1/a===1/b)||a!==a&&b!==b}var He="function"===typeof Object.is?Object.is:Ge,Ie=Object.prototype.hasOwnProperty;\nfunction Je(a,b){if(He(a,b))return!0;if("object"!==typeof a||null===a||"object"!==typeof b||null===b)return!1;var c=Object.keys(a),d=Object.keys(b);if(c.length!==d.length)return!1;for(d=0;d<c.length;d++)if(!Ie.call(b,c[d])||!He(a[c[d]],b[c[d]]))return!1;return!0}function Ke(a){for(;a&&a.firstChild;)a=a.firstChild;return a}\nfunction Le(a,b){var c=Ke(a);a=0;for(var d;c;){if(3===c.nodeType){d=a+c.textContent.length;if(a<=b&&d>=b)return{node:c,offset:b-a};a=d}a:{for(;c;){if(c.nextSibling){c=c.nextSibling;break a}c=c.parentNode}c=void 0}c=Ke(c)}}function Me(a,b){return a&&b?a===b?!0:a&&3===a.nodeType?!1:b&&3===b.nodeType?Me(a,b.parentNode):"contains"in a?a.contains(b):a.compareDocumentPosition?!!(a.compareDocumentPosition(b)&16):!1:!1}\nfunction Ne(){for(var a=window,b=Xa();b instanceof a.HTMLIFrameElement;){try{var c="string"===typeof b.contentWindow.location.href}catch(d){c=!1}if(c)a=b.contentWindow;else break;b=Xa(a.document)}return b}function Oe(a){var b=a&&a.nodeName&&a.nodeName.toLowerCase();return b&&("input"===b&&("text"===a.type||"search"===a.type||"tel"===a.type||"url"===a.type||"password"===a.type)||"textarea"===b||"true"===a.contentEditable)}\nvar Pe=fa&&"documentMode"in document&&11>=document.documentMode,Qe=null,Re=null,Se=null,Te=!1;\nfunction Ue(a,b,c){var d=c.window===c?c.document:9===c.nodeType?c:c.ownerDocument;Te||null==Qe||Qe!==Xa(d)||(d=Qe,"selectionStart"in d&&Oe(d)?d={start:d.selectionStart,end:d.selectionEnd}:(d=(d.ownerDocument&&d.ownerDocument.defaultView||window).getSelection(),d={anchorNode:d.anchorNode,anchorOffset:d.anchorOffset,focusNode:d.focusNode,focusOffset:d.focusOffset}),Se&&Je(Se,d)||(Se=d,d=oe(Re,"onSelect"),0<d.length&&(b=new td("onSelect","select",null,b,c),a.push({event:b,listeners:d}),b.target=Qe)))}\nPc("cancel cancel click click close close contextmenu contextMenu copy copy cut cut auxclick auxClick dblclick doubleClick dragend dragEnd dragstart dragStart drop drop focusin focus focusout blur input input invalid invalid keydown keyDown keypress keyPress keyup keyUp mousedown mouseDown mouseup mouseUp paste paste pause pause play play pointercancel pointerCancel pointerdown pointerDown pointerup pointerUp ratechange rateChange reset reset seeked seeked submit submit touchcancel touchCancel touchend touchEnd touchstart touchStart volumechange volumeChange".split(" "),\n0);Pc("drag drag dragenter dragEnter dragexit dragExit dragleave dragLeave dragover dragOver mousemove mouseMove mouseout mouseOut mouseover mouseOver pointermove pointerMove pointerout pointerOut pointerover pointerOver scroll scroll toggle toggle touchmove touchMove wheel wheel".split(" "),1);Pc(Oc,2);for(var Ve="change selectionchange textInput compositionstart compositionend compositionupdate".split(" "),We=0;We<Ve.length;We++)Nc.set(Ve[We],0);ea("onMouseEnter",["mouseout","mouseover"]);\nea("onMouseLeave",["mouseout","mouseover"]);ea("onPointerEnter",["pointerout","pointerover"]);ea("onPointerLeave",["pointerout","pointerover"]);da("onChange","change click focusin focusout input keydown keyup selectionchange".split(" "));da("onSelect","focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" "));da("onBeforeInput",["compositionend","keypress","textInput","paste"]);da("onCompositionEnd","compositionend focusout keydown keypress keyup mousedown".split(" "));\nda("onCompositionStart","compositionstart focusout keydown keypress keyup mousedown".split(" "));da("onCompositionUpdate","compositionupdate focusout keydown keypress keyup mousedown".split(" "));var Xe="abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),Ye=new Set("cancel close invalid load scroll toggle".split(" ").concat(Xe));\nfunction Ze(a,b,c){var d=a.type||"unknown-event";a.currentTarget=c;Yb(d,b,void 0,a);a.currentTarget=null}\nfunction se(a,b){b=0!==(b&4);for(var c=0;c<a.length;c++){var d=a[c],e=d.event;d=d.listeners;a:{var f=void 0;if(b)for(var g=d.length-1;0<=g;g--){var h=d[g],k=h.instance,l=h.currentTarget;h=h.listener;if(k!==f&&e.isPropagationStopped())break a;Ze(e,h,l);f=k}else for(g=0;g<d.length;g++){h=d[g];k=h.instance;l=h.currentTarget;h=h.listener;if(k!==f&&e.isPropagationStopped())break a;Ze(e,h,l);f=k}}}if(Ub)throw a=Vb,Ub=!1,Vb=null,a;}\nfunction G(a,b){var c=$e(b),d=a+"__bubble";c.has(d)||(af(b,a,2,!1),c.add(d))}var bf="_reactListening"+Math.random().toString(36).slice(2);function cf(a){a[bf]||(a[bf]=!0,ba.forEach(function(b){Ye.has(b)||df(b,!1,a,null);df(b,!0,a,null)}))}\nfunction df(a,b,c,d){var e=4<arguments.length&&void 0!==arguments[4]?arguments[4]:0,f=c;"selectionchange"===a&&9!==c.nodeType&&(f=c.ownerDocument);if(null!==d&&!b&&Ye.has(a)){if("scroll"!==a)return;e|=2;f=d}var g=$e(f),h=a+"__"+(b?"capture":"bubble");g.has(h)||(b&&(e|=4),af(f,a,e,b),g.add(h))}\nfunction af(a,b,c,d){var e=Nc.get(b);switch(void 0===e?2:e){case 0:e=gd;break;case 1:e=id;break;default:e=hd}c=e.bind(null,b,c,a);e=void 0;!Pb||"touchstart"!==b&&"touchmove"!==b&&"wheel"!==b||(e=!0);d?void 0!==e?a.addEventListener(b,c,{capture:!0,passive:e}):a.addEventListener(b,c,!0):void 0!==e?a.addEventListener(b,c,{passive:e}):a.addEventListener(b,c,!1)}\nfunction jd(a,b,c,d,e){var f=d;if(0===(b&1)&&0===(b&2)&&null!==d)a:for(;;){if(null===d)return;var g=d.tag;if(3===g||4===g){var h=d.stateNode.containerInfo;if(h===e||8===h.nodeType&&h.parentNode===e)break;if(4===g)for(g=d.return;null!==g;){var k=g.tag;if(3===k||4===k)if(k=g.stateNode.containerInfo,k===e||8===k.nodeType&&k.parentNode===e)return;g=g.return}for(;null!==h;){g=wc(h);if(null===g)return;k=g.tag;if(5===k||6===k){d=f=g;continue a}h=h.parentNode}}d=d.return}Nb(function(){var d=f,e=xb(c),g=[];\na:{var h=Mc.get(a);if(void 0!==h){var k=td,x=a;switch(a){case "keypress":if(0===od(c))break a;case "keydown":case "keyup":k=Rd;break;case "focusin":x="focus";k=Fd;break;case "focusout":x="blur";k=Fd;break;case "beforeblur":case "afterblur":k=Fd;break;case "click":if(2===c.button)break a;case "auxclick":case "dblclick":case "mousedown":case "mousemove":case "mouseup":case "mouseout":case "mouseover":case "contextmenu":k=Bd;break;case "drag":case "dragend":case "dragenter":case "dragexit":case "dragleave":case "dragover":case "dragstart":case "drop":k=\nDd;break;case "touchcancel":case "touchend":case "touchmove":case "touchstart":k=Vd;break;case Ic:case Jc:case Kc:k=Hd;break;case Lc:k=Xd;break;case "scroll":k=vd;break;case "wheel":k=Zd;break;case "copy":case "cut":case "paste":k=Jd;break;case "gotpointercapture":case "lostpointercapture":case "pointercancel":case "pointerdown":case "pointermove":case "pointerout":case "pointerover":case "pointerup":k=Td}var w=0!==(b&4),z=!w&&"scroll"===a,u=w?null!==h?h+"Capture":null:h;w=[];for(var t=d,q;null!==\nt;){q=t;var v=q.stateNode;5===q.tag&&null!==v&&(q=v,null!==u&&(v=Ob(t,u),null!=v&&w.push(ef(t,v,q))));if(z)break;t=t.return}0<w.length&&(h=new k(h,x,null,c,e),g.push({event:h,listeners:w}))}}if(0===(b&7)){a:{h="mouseover"===a||"pointerover"===a;k="mouseout"===a||"pointerout"===a;if(h&&0===(b&16)&&(x=c.relatedTarget||c.fromElement)&&(wc(x)||x[ff]))break a;if(k||h){h=e.window===e?e:(h=e.ownerDocument)?h.defaultView||h.parentWindow:window;if(k){if(x=c.relatedTarget||c.toElement,k=d,x=x?wc(x):null,null!==\nx&&(z=Zb(x),x!==z||5!==x.tag&&6!==x.tag))x=null}else k=null,x=d;if(k!==x){w=Bd;v="onMouseLeave";u="onMouseEnter";t="mouse";if("pointerout"===a||"pointerover"===a)w=Td,v="onPointerLeave",u="onPointerEnter",t="pointer";z=null==k?h:ue(k);q=null==x?h:ue(x);h=new w(v,t+"leave",k,c,e);h.target=z;h.relatedTarget=q;v=null;wc(e)===d&&(w=new w(u,t+"enter",x,c,e),w.target=q,w.relatedTarget=z,v=w);z=v;if(k&&x)b:{w=k;u=x;t=0;for(q=w;q;q=gf(q))t++;q=0;for(v=u;v;v=gf(v))q++;for(;0<t-q;)w=gf(w),t--;for(;0<q-t;)u=\ngf(u),q--;for(;t--;){if(w===u||null!==u&&w===u.alternate)break b;w=gf(w);u=gf(u)}w=null}else w=null;null!==k&&hf(g,h,k,w,!1);null!==x&&null!==z&&hf(g,z,x,w,!0)}}}a:{h=d?ue(d):window;k=h.nodeName&&h.nodeName.toLowerCase();if("select"===k||"input"===k&&"file"===h.type)var J=ve;else if(me(h))if(we)J=Fe;else{J=De;var K=Ce}else(k=h.nodeName)&&"input"===k.toLowerCase()&&("checkbox"===h.type||"radio"===h.type)&&(J=Ee);if(J&&(J=J(a,d))){ne(g,J,c,e);break a}K&&K(a,h,d);"focusout"===a&&(K=h._wrapperState)&&\nK.controlled&&"number"===h.type&&bb(h,"number",h.value)}K=d?ue(d):window;switch(a){case "focusin":if(me(K)||"true"===K.contentEditable)Qe=K,Re=d,Se=null;break;case "focusout":Se=Re=Qe=null;break;case "mousedown":Te=!0;break;case "contextmenu":case "mouseup":case "dragend":Te=!1;Ue(g,c,e);break;case "selectionchange":if(Pe)break;case "keydown":case "keyup":Ue(g,c,e)}var Q;if(ae)b:{switch(a){case "compositionstart":var L="onCompositionStart";break b;case "compositionend":L="onCompositionEnd";break b;\ncase "compositionupdate":L="onCompositionUpdate";break b}L=void 0}else ie?ge(a,c)&&(L="onCompositionEnd"):"keydown"===a&&229===c.keyCode&&(L="onCompositionStart");L&&(de&&"ko"!==c.locale&&(ie||"onCompositionStart"!==L?"onCompositionEnd"===L&&ie&&(Q=nd()):(kd=e,ld="value"in kd?kd.value:kd.textContent,ie=!0)),K=oe(d,L),0<K.length&&(L=new Ld(L,a,null,c,e),g.push({event:L,listeners:K}),Q?L.data=Q:(Q=he(c),null!==Q&&(L.data=Q))));if(Q=ce?je(a,c):ke(a,c))d=oe(d,"onBeforeInput"),0<d.length&&(e=new Ld("onBeforeInput",\n"beforeinput",null,c,e),g.push({event:e,listeners:d}),e.data=Q)}se(g,b)})}function ef(a,b,c){return{instance:a,listener:b,currentTarget:c}}function oe(a,b){for(var c=b+"Capture",d=[];null!==a;){var e=a,f=e.stateNode;5===e.tag&&null!==f&&(e=f,f=Ob(a,c),null!=f&&d.unshift(ef(a,f,e)),f=Ob(a,b),null!=f&&d.push(ef(a,f,e)));a=a.return}return d}function gf(a){if(null===a)return null;do a=a.return;while(a&&5!==a.tag);return a?a:null}\nfunction hf(a,b,c,d,e){for(var f=b._reactName,g=[];null!==c&&c!==d;){var h=c,k=h.alternate,l=h.stateNode;if(null!==k&&k===d)break;5===h.tag&&null!==l&&(h=l,e?(k=Ob(c,f),null!=k&&g.unshift(ef(c,k,h))):e||(k=Ob(c,f),null!=k&&g.push(ef(c,k,h))));c=c.return}0!==g.length&&a.push({event:b,listeners:g})}function jf(){}var kf=null,lf=null;function mf(a,b){switch(a){case "button":case "input":case "select":case "textarea":return!!b.autoFocus}return!1}\nfunction nf(a,b){return"textarea"===a||"option"===a||"noscript"===a||"string"===typeof b.children||"number"===typeof b.children||"object"===typeof b.dangerouslySetInnerHTML&&null!==b.dangerouslySetInnerHTML&&null!=b.dangerouslySetInnerHTML.__html}var of="function"===typeof setTimeout?setTimeout:void 0,pf="function"===typeof clearTimeout?clearTimeout:void 0;function qf(a){1===a.nodeType?a.textContent="":9===a.nodeType&&(a=a.body,null!=a&&(a.textContent=""))}\nfunction rf(a){for(;null!=a;a=a.nextSibling){var b=a.nodeType;if(1===b||3===b)break}return a}function sf(a){a=a.previousSibling;for(var b=0;a;){if(8===a.nodeType){var c=a.data;if("$"===c||"$!"===c||"$?"===c){if(0===b)return a;b--}else"/$"===c&&b++}a=a.previousSibling}return null}var tf=0;function uf(a){return{$$typeof:Ga,toString:a,valueOf:a}}var vf=Math.random().toString(36).slice(2),wf="__reactFiber$"+vf,xf="__reactProps$"+vf,ff="__reactContainer$"+vf,yf="__reactEvents$"+vf;\nfunction wc(a){var b=a[wf];if(b)return b;for(var c=a.parentNode;c;){if(b=c[ff]||c[wf]){c=b.alternate;if(null!==b.child||null!==c&&null!==c.child)for(a=sf(a);null!==a;){if(c=a[wf])return c;a=sf(a)}return b}a=c;c=a.parentNode}return null}function Cb(a){a=a[wf]||a[ff];return!a||5!==a.tag&&6!==a.tag&&13!==a.tag&&3!==a.tag?null:a}function ue(a){if(5===a.tag||6===a.tag)return a.stateNode;throw Error(y(33));}function Db(a){return a[xf]||null}\nfunction $e(a){var b=a[yf];void 0===b&&(b=a[yf]=new Set);return b}var zf=[],Af=-1;function Bf(a){return{current:a}}function H(a){0>Af||(a.current=zf[Af],zf[Af]=null,Af--)}function I(a,b){Af++;zf[Af]=a.current;a.current=b}var Cf={},M=Bf(Cf),N=Bf(!1),Df=Cf;\nfunction Ef(a,b){var c=a.type.contextTypes;if(!c)return Cf;var d=a.stateNode;if(d&&d.__reactInternalMemoizedUnmaskedChildContext===b)return d.__reactInternalMemoizedMaskedChildContext;var e={},f;for(f in c)e[f]=b[f];d&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=b,a.__reactInternalMemoizedMaskedChildContext=e);return e}function Ff(a){a=a.childContextTypes;return null!==a&&void 0!==a}function Gf(){H(N);H(M)}function Hf(a,b,c){if(M.current!==Cf)throw Error(y(168));I(M,b);I(N,c)}\nfunction If(a,b,c){var d=a.stateNode;a=b.childContextTypes;if("function"!==typeof d.getChildContext)return c;d=d.getChildContext();for(var e in d)if(!(e in a))throw Error(y(108,Ra(b)||"Unknown",e));return m({},c,d)}function Jf(a){a=(a=a.stateNode)&&a.__reactInternalMemoizedMergedChildContext||Cf;Df=M.current;I(M,a);I(N,N.current);return!0}function Kf(a,b,c){var d=a.stateNode;if(!d)throw Error(y(169));c?(a=If(a,b,Df),d.__reactInternalMemoizedMergedChildContext=a,H(N),H(M),I(M,a)):H(N);I(N,c)}\nvar Lf=null,Mf=null,Nf=r.unstable_runWithPriority,Of=r.unstable_scheduleCallback,Pf=r.unstable_cancelCallback,Qf=r.unstable_shouldYield,Rf=r.unstable_requestPaint,Sf=r.unstable_now,Tf=r.unstable_getCurrentPriorityLevel,Uf=r.unstable_ImmediatePriority,Vf=r.unstable_UserBlockingPriority,Wf=r.unstable_NormalPriority,Xf=r.unstable_LowPriority,Yf=r.unstable_IdlePriority,Zf={},$f=void 0!==Rf?Rf:function(){},ag=null,bg=null,cg=!1,dg=Sf(),O=1E4>dg?Sf:function(){return Sf()-dg};\nfunction eg(){switch(Tf()){case Uf:return 99;case Vf:return 98;case Wf:return 97;case Xf:return 96;case Yf:return 95;default:throw Error(y(332));}}function fg(a){switch(a){case 99:return Uf;case 98:return Vf;case 97:return Wf;case 96:return Xf;case 95:return Yf;default:throw Error(y(332));}}function gg(a,b){a=fg(a);return Nf(a,b)}function hg(a,b,c){a=fg(a);return Of(a,b,c)}function ig(){if(null!==bg){var a=bg;bg=null;Pf(a)}jg()}\nfunction jg(){if(!cg&&null!==ag){cg=!0;var a=0;try{var b=ag;gg(99,function(){for(;a<b.length;a++){var c=b[a];do c=c(!0);while(null!==c)}});ag=null}catch(c){throw null!==ag&&(ag=ag.slice(a+1)),Of(Uf,ig),c;}finally{cg=!1}}}var kg=ra.ReactCurrentBatchConfig;function lg(a,b){if(a&&a.defaultProps){b=m({},b);a=a.defaultProps;for(var c in a)void 0===b[c]&&(b[c]=a[c]);return b}return b}var mg=Bf(null),ng=null,og=null,pg=null;function qg(){pg=og=ng=null}\nfunction rg(a){var b=mg.current;H(mg);a.type._context._currentValue=b}function sg(a,b){for(;null!==a;){var c=a.alternate;if((a.childLanes&b)===b)if(null===c||(c.childLanes&b)===b)break;else c.childLanes|=b;else a.childLanes|=b,null!==c&&(c.childLanes|=b);a=a.return}}function tg(a,b){ng=a;pg=og=null;a=a.dependencies;null!==a&&null!==a.firstContext&&(0!==(a.lanes&b)&&(ug=!0),a.firstContext=null)}\nfunction vg(a,b){if(pg!==a&&!1!==b&&0!==b){if("number"!==typeof b||1073741823===b)pg=a,b=1073741823;b={context:a,observedBits:b,next:null};if(null===og){if(null===ng)throw Error(y(308));og=b;ng.dependencies={lanes:0,firstContext:b,responders:null}}else og=og.next=b}return a._currentValue}var wg=!1;function xg(a){a.updateQueue={baseState:a.memoizedState,firstBaseUpdate:null,lastBaseUpdate:null,shared:{pending:null},effects:null}}\nfunction yg(a,b){a=a.updateQueue;b.updateQueue===a&&(b.updateQueue={baseState:a.baseState,firstBaseUpdate:a.firstBaseUpdate,lastBaseUpdate:a.lastBaseUpdate,shared:a.shared,effects:a.effects})}function zg(a,b){return{eventTime:a,lane:b,tag:0,payload:null,callback:null,next:null}}function Ag(a,b){a=a.updateQueue;if(null!==a){a=a.shared;var c=a.pending;null===c?b.next=b:(b.next=c.next,c.next=b);a.pending=b}}\nfunction Bg(a,b){var c=a.updateQueue,d=a.alternate;if(null!==d&&(d=d.updateQueue,c===d)){var e=null,f=null;c=c.firstBaseUpdate;if(null!==c){do{var g={eventTime:c.eventTime,lane:c.lane,tag:c.tag,payload:c.payload,callback:c.callback,next:null};null===f?e=f=g:f=f.next=g;c=c.next}while(null!==c);null===f?e=f=b:f=f.next=b}else e=f=b;c={baseState:d.baseState,firstBaseUpdate:e,lastBaseUpdate:f,shared:d.shared,effects:d.effects};a.updateQueue=c;return}a=c.lastBaseUpdate;null===a?c.firstBaseUpdate=b:a.next=\nb;c.lastBaseUpdate=b}\nfunction Cg(a,b,c,d){var e=a.updateQueue;wg=!1;var f=e.firstBaseUpdate,g=e.lastBaseUpdate,h=e.shared.pending;if(null!==h){e.shared.pending=null;var k=h,l=k.next;k.next=null;null===g?f=l:g.next=l;g=k;var n=a.alternate;if(null!==n){n=n.updateQueue;var A=n.lastBaseUpdate;A!==g&&(null===A?n.firstBaseUpdate=l:A.next=l,n.lastBaseUpdate=k)}}if(null!==f){A=e.baseState;g=0;n=l=k=null;do{h=f.lane;var p=f.eventTime;if((d&h)===h){null!==n&&(n=n.next={eventTime:p,lane:0,tag:f.tag,payload:f.payload,callback:f.callback,\nnext:null});a:{var C=a,x=f;h=b;p=c;switch(x.tag){case 1:C=x.payload;if("function"===typeof C){A=C.call(p,A,h);break a}A=C;break a;case 3:C.flags=C.flags&-4097|64;case 0:C=x.payload;h="function"===typeof C?C.call(p,A,h):C;if(null===h||void 0===h)break a;A=m({},A,h);break a;case 2:wg=!0}}null!==f.callback&&(a.flags|=32,h=e.effects,null===h?e.effects=[f]:h.push(f))}else p={eventTime:p,lane:h,tag:f.tag,payload:f.payload,callback:f.callback,next:null},null===n?(l=n=p,k=A):n=n.next=p,g|=h;f=f.next;if(null===\nf)if(h=e.shared.pending,null===h)break;else f=h.next,h.next=null,e.lastBaseUpdate=h,e.shared.pending=null}while(1);null===n&&(k=A);e.baseState=k;e.firstBaseUpdate=l;e.lastBaseUpdate=n;Dg|=g;a.lanes=g;a.memoizedState=A}}function Eg(a,b,c){a=b.effects;b.effects=null;if(null!==a)for(b=0;b<a.length;b++){var d=a[b],e=d.callback;if(null!==e){d.callback=null;d=c;if("function"!==typeof e)throw Error(y(191,e));e.call(d)}}}var Fg=(new aa.Component).refs;\nfunction Gg(a,b,c,d){b=a.memoizedState;c=c(d,b);c=null===c||void 0===c?b:m({},b,c);a.memoizedState=c;0===a.lanes&&(a.updateQueue.baseState=c)}\nvar Kg={isMounted:function(a){return(a=a._reactInternals)?Zb(a)===a:!1},enqueueSetState:function(a,b,c){a=a._reactInternals;var d=Hg(),e=Ig(a),f=zg(d,e);f.payload=b;void 0!==c&&null!==c&&(f.callback=c);Ag(a,f);Jg(a,e,d)},enqueueReplaceState:function(a,b,c){a=a._reactInternals;var d=Hg(),e=Ig(a),f=zg(d,e);f.tag=1;f.payload=b;void 0!==c&&null!==c&&(f.callback=c);Ag(a,f);Jg(a,e,d)},enqueueForceUpdate:function(a,b){a=a._reactInternals;var c=Hg(),d=Ig(a),e=zg(c,d);e.tag=2;void 0!==b&&null!==b&&(e.callback=\nb);Ag(a,e);Jg(a,d,c)}};function Lg(a,b,c,d,e,f,g){a=a.stateNode;return"function"===typeof a.shouldComponentUpdate?a.shouldComponentUpdate(d,f,g):b.prototype&&b.prototype.isPureReactComponent?!Je(c,d)||!Je(e,f):!0}\nfunction Mg(a,b,c){var d=!1,e=Cf;var f=b.contextType;"object"===typeof f&&null!==f?f=vg(f):(e=Ff(b)?Df:M.current,d=b.contextTypes,f=(d=null!==d&&void 0!==d)?Ef(a,e):Cf);b=new b(c,f);a.memoizedState=null!==b.state&&void 0!==b.state?b.state:null;b.updater=Kg;a.stateNode=b;b._reactInternals=a;d&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=e,a.__reactInternalMemoizedMaskedChildContext=f);return b}\nfunction Ng(a,b,c,d){a=b.state;"function"===typeof b.componentWillReceiveProps&&b.componentWillReceiveProps(c,d);"function"===typeof b.UNSAFE_componentWillReceiveProps&&b.UNSAFE_componentWillReceiveProps(c,d);b.state!==a&&Kg.enqueueReplaceState(b,b.state,null)}\nfunction Og(a,b,c,d){var e=a.stateNode;e.props=c;e.state=a.memoizedState;e.refs=Fg;xg(a);var f=b.contextType;"object"===typeof f&&null!==f?e.context=vg(f):(f=Ff(b)?Df:M.current,e.context=Ef(a,f));Cg(a,c,e,d);e.state=a.memoizedState;f=b.getDerivedStateFromProps;"function"===typeof f&&(Gg(a,b,f,c),e.state=a.memoizedState);"function"===typeof b.getDerivedStateFromProps||"function"===typeof e.getSnapshotBeforeUpdate||"function"!==typeof e.UNSAFE_componentWillMount&&"function"!==typeof e.componentWillMount||\n(b=e.state,"function"===typeof e.componentWillMount&&e.componentWillMount(),"function"===typeof e.UNSAFE_componentWillMount&&e.UNSAFE_componentWillMount(),b!==e.state&&Kg.enqueueReplaceState(e,e.state,null),Cg(a,c,e,d),e.state=a.memoizedState);"function"===typeof e.componentDidMount&&(a.flags|=4)}var Pg=Array.isArray;\nfunction Qg(a,b,c){a=c.ref;if(null!==a&&"function"!==typeof a&&"object"!==typeof a){if(c._owner){c=c._owner;if(c){if(1!==c.tag)throw Error(y(309));var d=c.stateNode}if(!d)throw Error(y(147,a));var e=""+a;if(null!==b&&null!==b.ref&&"function"===typeof b.ref&&b.ref._stringRef===e)return b.ref;b=function(a){var b=d.refs;b===Fg&&(b=d.refs={});null===a?delete b[e]:b[e]=a};b._stringRef=e;return b}if("string"!==typeof a)throw Error(y(284));if(!c._owner)throw Error(y(290,a));}return a}\nfunction Rg(a,b){if("textarea"!==a.type)throw Error(y(31,"[object Object]"===Object.prototype.toString.call(b)?"object with keys {"+Object.keys(b).join(", ")+"}":b));}\nfunction Sg(a){function b(b,c){if(a){var d=b.lastEffect;null!==d?(d.nextEffect=c,b.lastEffect=c):b.firstEffect=b.lastEffect=c;c.nextEffect=null;c.flags=8}}function c(c,d){if(!a)return null;for(;null!==d;)b(c,d),d=d.sibling;return null}function d(a,b){for(a=new Map;null!==b;)null!==b.key?a.set(b.key,b):a.set(b.index,b),b=b.sibling;return a}function e(a,b){a=Tg(a,b);a.index=0;a.sibling=null;return a}function f(b,c,d){b.index=d;if(!a)return c;d=b.alternate;if(null!==d)return d=d.index,d<c?(b.flags=2,\nc):d;b.flags=2;return c}function g(b){a&&null===b.alternate&&(b.flags=2);return b}function h(a,b,c,d){if(null===b||6!==b.tag)return b=Ug(c,a.mode,d),b.return=a,b;b=e(b,c);b.return=a;return b}function k(a,b,c,d){if(null!==b&&b.elementType===c.type)return d=e(b,c.props),d.ref=Qg(a,b,c),d.return=a,d;d=Vg(c.type,c.key,c.props,null,a.mode,d);d.ref=Qg(a,b,c);d.return=a;return d}function l(a,b,c,d){if(null===b||4!==b.tag||b.stateNode.containerInfo!==c.containerInfo||b.stateNode.implementation!==c.implementation)return b=\nWg(c,a.mode,d),b.return=a,b;b=e(b,c.children||[]);b.return=a;return b}function n(a,b,c,d,f){if(null===b||7!==b.tag)return b=Xg(c,a.mode,d,f),b.return=a,b;b=e(b,c);b.return=a;return b}function A(a,b,c){if("string"===typeof b||"number"===typeof b)return b=Ug(""+b,a.mode,c),b.return=a,b;if("object"===typeof b&&null!==b){switch(b.$$typeof){case sa:return c=Vg(b.type,b.key,b.props,null,a.mode,c),c.ref=Qg(a,null,b),c.return=a,c;case ta:return b=Wg(b,a.mode,c),b.return=a,b}if(Pg(b)||La(b))return b=Xg(b,\na.mode,c,null),b.return=a,b;Rg(a,b)}return null}function p(a,b,c,d){var e=null!==b?b.key:null;if("string"===typeof c||"number"===typeof c)return null!==e?null:h(a,b,""+c,d);if("object"===typeof c&&null!==c){switch(c.$$typeof){case sa:return c.key===e?c.type===ua?n(a,b,c.props.children,d,e):k(a,b,c,d):null;case ta:return c.key===e?l(a,b,c,d):null}if(Pg(c)||La(c))return null!==e?null:n(a,b,c,d,null);Rg(a,c)}return null}function C(a,b,c,d,e){if("string"===typeof d||"number"===typeof d)return a=a.get(c)||\nnull,h(b,a,""+d,e);if("object"===typeof d&&null!==d){switch(d.$$typeof){case sa:return a=a.get(null===d.key?c:d.key)||null,d.type===ua?n(b,a,d.props.children,e,d.key):k(b,a,d,e);case ta:return a=a.get(null===d.key?c:d.key)||null,l(b,a,d,e)}if(Pg(d)||La(d))return a=a.get(c)||null,n(b,a,d,e,null);Rg(b,d)}return null}function x(e,g,h,k){for(var l=null,t=null,u=g,z=g=0,q=null;null!==u&&z<h.length;z++){u.index>z?(q=u,u=null):q=u.sibling;var n=p(e,u,h[z],k);if(null===n){null===u&&(u=q);break}a&&u&&null===\nn.alternate&&b(e,u);g=f(n,g,z);null===t?l=n:t.sibling=n;t=n;u=q}if(z===h.length)return c(e,u),l;if(null===u){for(;z<h.length;z++)u=A(e,h[z],k),null!==u&&(g=f(u,g,z),null===t?l=u:t.sibling=u,t=u);return l}for(u=d(e,u);z<h.length;z++)q=C(u,e,z,h[z],k),null!==q&&(a&&null!==q.alternate&&u.delete(null===q.key?z:q.key),g=f(q,g,z),null===t?l=q:t.sibling=q,t=q);a&&u.forEach(function(a){return b(e,a)});return l}function w(e,g,h,k){var l=La(h);if("function"!==typeof l)throw Error(y(150));h=l.call(h);if(null==\nh)throw Error(y(151));for(var t=l=null,u=g,z=g=0,q=null,n=h.next();null!==u&&!n.done;z++,n=h.next()){u.index>z?(q=u,u=null):q=u.sibling;var w=p(e,u,n.value,k);if(null===w){null===u&&(u=q);break}a&&u&&null===w.alternate&&b(e,u);g=f(w,g,z);null===t?l=w:t.sibling=w;t=w;u=q}if(n.done)return c(e,u),l;if(null===u){for(;!n.done;z++,n=h.next())n=A(e,n.value,k),null!==n&&(g=f(n,g,z),null===t?l=n:t.sibling=n,t=n);return l}for(u=d(e,u);!n.done;z++,n=h.next())n=C(u,e,z,n.value,k),null!==n&&(a&&null!==n.alternate&&\nu.delete(null===n.key?z:n.key),g=f(n,g,z),null===t?l=n:t.sibling=n,t=n);a&&u.forEach(function(a){return b(e,a)});return l}return function(a,d,f,h){var k="object"===typeof f&&null!==f&&f.type===ua&&null===f.key;k&&(f=f.props.children);var l="object"===typeof f&&null!==f;if(l)switch(f.$$typeof){case sa:a:{l=f.key;for(k=d;null!==k;){if(k.key===l){switch(k.tag){case 7:if(f.type===ua){c(a,k.sibling);d=e(k,f.props.children);d.return=a;a=d;break a}break;default:if(k.elementType===f.type){c(a,k.sibling);\nd=e(k,f.props);d.ref=Qg(a,k,f);d.return=a;a=d;break a}}c(a,k);break}else b(a,k);k=k.sibling}f.type===ua?(d=Xg(f.props.children,a.mode,h,f.key),d.return=a,a=d):(h=Vg(f.type,f.key,f.props,null,a.mode,h),h.ref=Qg(a,d,f),h.return=a,a=h)}return g(a);case ta:a:{for(k=f.key;null!==d;){if(d.key===k)if(4===d.tag&&d.stateNode.containerInfo===f.containerInfo&&d.stateNode.implementation===f.implementation){c(a,d.sibling);d=e(d,f.children||[]);d.return=a;a=d;break a}else{c(a,d);break}else b(a,d);d=d.sibling}d=\nWg(f,a.mode,h);d.return=a;a=d}return g(a)}if("string"===typeof f||"number"===typeof f)return f=""+f,null!==d&&6===d.tag?(c(a,d.sibling),d=e(d,f),d.return=a,a=d):(c(a,d),d=Ug(f,a.mode,h),d.return=a,a=d),g(a);if(Pg(f))return x(a,d,f,h);if(La(f))return w(a,d,f,h);l&&Rg(a,f);if("undefined"===typeof f&&!k)switch(a.tag){case 1:case 22:case 0:case 11:case 15:throw Error(y(152,Ra(a.type)||"Component"));}return c(a,d)}}var Yg=Sg(!0),Zg=Sg(!1),$g={},ah=Bf($g),bh=Bf($g),ch=Bf($g);\nfunction dh(a){if(a===$g)throw Error(y(174));return a}function eh(a,b){I(ch,b);I(bh,a);I(ah,$g);a=b.nodeType;switch(a){case 9:case 11:b=(b=b.documentElement)?b.namespaceURI:mb(null,"");break;default:a=8===a?b.parentNode:b,b=a.namespaceURI||null,a=a.tagName,b=mb(b,a)}H(ah);I(ah,b)}function fh(){H(ah);H(bh);H(ch)}function gh(a){dh(ch.current);var b=dh(ah.current);var c=mb(b,a.type);b!==c&&(I(bh,a),I(ah,c))}function hh(a){bh.current===a&&(H(ah),H(bh))}var P=Bf(0);\nfunction ih(a){for(var b=a;null!==b;){if(13===b.tag){var c=b.memoizedState;if(null!==c&&(c=c.dehydrated,null===c||"$?"===c.data||"$!"===c.data))return b}else if(19===b.tag&&void 0!==b.memoizedProps.revealOrder){if(0!==(b.flags&64))return b}else if(null!==b.child){b.child.return=b;b=b.child;continue}if(b===a)break;for(;null===b.sibling;){if(null===b.return||b.return===a)return null;b=b.return}b.sibling.return=b.return;b=b.sibling}return null}var jh=null,kh=null,lh=!1;\nfunction mh(a,b){var c=nh(5,null,null,0);c.elementType="DELETED";c.type="DELETED";c.stateNode=b;c.return=a;c.flags=8;null!==a.lastEffect?(a.lastEffect.nextEffect=c,a.lastEffect=c):a.firstEffect=a.lastEffect=c}function oh(a,b){switch(a.tag){case 5:var c=a.type;b=1!==b.nodeType||c.toLowerCase()!==b.nodeName.toLowerCase()?null:b;return null!==b?(a.stateNode=b,!0):!1;case 6:return b=""===a.pendingProps||3!==b.nodeType?null:b,null!==b?(a.stateNode=b,!0):!1;case 13:return!1;default:return!1}}\nfunction ph(a){if(lh){var b=kh;if(b){var c=b;if(!oh(a,b)){b=rf(c.nextSibling);if(!b||!oh(a,b)){a.flags=a.flags&-1025|2;lh=!1;jh=a;return}mh(jh,c)}jh=a;kh=rf(b.firstChild)}else a.flags=a.flags&-1025|2,lh=!1,jh=a}}function qh(a){for(a=a.return;null!==a&&5!==a.tag&&3!==a.tag&&13!==a.tag;)a=a.return;jh=a}\nfunction rh(a){if(a!==jh)return!1;if(!lh)return qh(a),lh=!0,!1;var b=a.type;if(5!==a.tag||"head"!==b&&"body"!==b&&!nf(b,a.memoizedProps))for(b=kh;b;)mh(a,b),b=rf(b.nextSibling);qh(a);if(13===a.tag){a=a.memoizedState;a=null!==a?a.dehydrated:null;if(!a)throw Error(y(317));a:{a=a.nextSibling;for(b=0;a;){if(8===a.nodeType){var c=a.data;if("/$"===c){if(0===b){kh=rf(a.nextSibling);break a}b--}else"$"!==c&&"$!"!==c&&"$?"!==c||b++}a=a.nextSibling}kh=null}}else kh=jh?rf(a.stateNode.nextSibling):null;return!0}\nfunction sh(){kh=jh=null;lh=!1}var th=[];function uh(){for(var a=0;a<th.length;a++)th[a]._workInProgressVersionPrimary=null;th.length=0}var vh=ra.ReactCurrentDispatcher,wh=ra.ReactCurrentBatchConfig,xh=0,R=null,S=null,T=null,yh=!1,zh=!1;function Ah(){throw Error(y(321));}function Bh(a,b){if(null===b)return!1;for(var c=0;c<b.length&&c<a.length;c++)if(!He(a[c],b[c]))return!1;return!0}\nfunction Ch(a,b,c,d,e,f){xh=f;R=b;b.memoizedState=null;b.updateQueue=null;b.lanes=0;vh.current=null===a||null===a.memoizedState?Dh:Eh;a=c(d,e);if(zh){f=0;do{zh=!1;if(!(25>f))throw Error(y(301));f+=1;T=S=null;b.updateQueue=null;vh.current=Fh;a=c(d,e)}while(zh)}vh.current=Gh;b=null!==S&&null!==S.next;xh=0;T=S=R=null;yh=!1;if(b)throw Error(y(300));return a}function Hh(){var a={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};null===T?R.memoizedState=T=a:T=T.next=a;return T}\nfunction Ih(){if(null===S){var a=R.alternate;a=null!==a?a.memoizedState:null}else a=S.next;var b=null===T?R.memoizedState:T.next;if(null!==b)T=b,S=a;else{if(null===a)throw Error(y(310));S=a;a={memoizedState:S.memoizedState,baseState:S.baseState,baseQueue:S.baseQueue,queue:S.queue,next:null};null===T?R.memoizedState=T=a:T=T.next=a}return T}function Jh(a,b){return"function"===typeof b?b(a):b}\nfunction Kh(a){var b=Ih(),c=b.queue;if(null===c)throw Error(y(311));c.lastRenderedReducer=a;var d=S,e=d.baseQueue,f=c.pending;if(null!==f){if(null!==e){var g=e.next;e.next=f.next;f.next=g}d.baseQueue=e=f;c.pending=null}if(null!==e){e=e.next;d=d.baseState;var h=g=f=null,k=e;do{var l=k.lane;if((xh&l)===l)null!==h&&(h=h.next={lane:0,action:k.action,eagerReducer:k.eagerReducer,eagerState:k.eagerState,next:null}),d=k.eagerReducer===a?k.eagerState:a(d,k.action);else{var n={lane:l,action:k.action,eagerReducer:k.eagerReducer,\neagerState:k.eagerState,next:null};null===h?(g=h=n,f=d):h=h.next=n;R.lanes|=l;Dg|=l}k=k.next}while(null!==k&&k!==e);null===h?f=d:h.next=g;He(d,b.memoizedState)||(ug=!0);b.memoizedState=d;b.baseState=f;b.baseQueue=h;c.lastRenderedState=d}return[b.memoizedState,c.dispatch]}\nfunction Lh(a){var b=Ih(),c=b.queue;if(null===c)throw Error(y(311));c.lastRenderedReducer=a;var d=c.dispatch,e=c.pending,f=b.memoizedState;if(null!==e){c.pending=null;var g=e=e.next;do f=a(f,g.action),g=g.next;while(g!==e);He(f,b.memoizedState)||(ug=!0);b.memoizedState=f;null===b.baseQueue&&(b.baseState=f);c.lastRenderedState=f}return[f,d]}\nfunction Mh(a,b,c){var d=b._getVersion;d=d(b._source);var e=b._workInProgressVersionPrimary;if(null!==e)a=e===d;else if(a=a.mutableReadLanes,a=(xh&a)===a)b._workInProgressVersionPrimary=d,th.push(b);if(a)return c(b._source);th.push(b);throw Error(y(350));}\nfunction Nh(a,b,c,d){var e=U;if(null===e)throw Error(y(349));var f=b._getVersion,g=f(b._source),h=vh.current,k=h.useState(function(){return Mh(e,b,c)}),l=k[1],n=k[0];k=T;var A=a.memoizedState,p=A.refs,C=p.getSnapshot,x=A.source;A=A.subscribe;var w=R;a.memoizedState={refs:p,source:b,subscribe:d};h.useEffect(function(){p.getSnapshot=c;p.setSnapshot=l;var a=f(b._source);if(!He(g,a)){a=c(b._source);He(n,a)||(l(a),a=Ig(w),e.mutableReadLanes|=a&e.pendingLanes);a=e.mutableReadLanes;e.entangledLanes|=a;for(var d=\ne.entanglements,h=a;0<h;){var k=31-Vc(h),v=1<<k;d[k]|=a;h&=~v}}},[c,b,d]);h.useEffect(function(){return d(b._source,function(){var a=p.getSnapshot,c=p.setSnapshot;try{c(a(b._source));var d=Ig(w);e.mutableReadLanes|=d&e.pendingLanes}catch(q){c(function(){throw q;})}})},[b,d]);He(C,c)&&He(x,b)&&He(A,d)||(a={pending:null,dispatch:null,lastRenderedReducer:Jh,lastRenderedState:n},a.dispatch=l=Oh.bind(null,R,a),k.queue=a,k.baseQueue=null,n=Mh(e,b,c),k.memoizedState=k.baseState=n);return n}\nfunction Ph(a,b,c){var d=Ih();return Nh(d,a,b,c)}function Qh(a){var b=Hh();"function"===typeof a&&(a=a());b.memoizedState=b.baseState=a;a=b.queue={pending:null,dispatch:null,lastRenderedReducer:Jh,lastRenderedState:a};a=a.dispatch=Oh.bind(null,R,a);return[b.memoizedState,a]}\nfunction Rh(a,b,c,d){a={tag:a,create:b,destroy:c,deps:d,next:null};b=R.updateQueue;null===b?(b={lastEffect:null},R.updateQueue=b,b.lastEffect=a.next=a):(c=b.lastEffect,null===c?b.lastEffect=a.next=a:(d=c.next,c.next=a,a.next=d,b.lastEffect=a));return a}function Sh(a){var b=Hh();a={current:a};return b.memoizedState=a}function Th(){return Ih().memoizedState}function Uh(a,b,c,d){var e=Hh();R.flags|=a;e.memoizedState=Rh(1|b,c,void 0,void 0===d?null:d)}\nfunction Vh(a,b,c,d){var e=Ih();d=void 0===d?null:d;var f=void 0;if(null!==S){var g=S.memoizedState;f=g.destroy;if(null!==d&&Bh(d,g.deps)){Rh(b,c,f,d);return}}R.flags|=a;e.memoizedState=Rh(1|b,c,f,d)}function Wh(a,b){return Uh(516,4,a,b)}function Xh(a,b){return Vh(516,4,a,b)}function Yh(a,b){return Vh(4,2,a,b)}function Zh(a,b){if("function"===typeof b)return a=a(),b(a),function(){b(null)};if(null!==b&&void 0!==b)return a=a(),b.current=a,function(){b.current=null}}\nfunction $h(a,b,c){c=null!==c&&void 0!==c?c.concat([a]):null;return Vh(4,2,Zh.bind(null,b,a),c)}function ai(){}function bi(a,b){var c=Ih();b=void 0===b?null:b;var d=c.memoizedState;if(null!==d&&null!==b&&Bh(b,d[1]))return d[0];c.memoizedState=[a,b];return a}function ci(a,b){var c=Ih();b=void 0===b?null:b;var d=c.memoizedState;if(null!==d&&null!==b&&Bh(b,d[1]))return d[0];a=a();c.memoizedState=[a,b];return a}\nfunction di(a,b){var c=eg();gg(98>c?98:c,function(){a(!0)});gg(97<c?97:c,function(){var c=wh.transition;wh.transition=1;try{a(!1),b()}finally{wh.transition=c}})}\nfunction Oh(a,b,c){var d=Hg(),e=Ig(a),f={lane:e,action:c,eagerReducer:null,eagerState:null,next:null},g=b.pending;null===g?f.next=f:(f.next=g.next,g.next=f);b.pending=f;g=a.alternate;if(a===R||null!==g&&g===R)zh=yh=!0;else{if(0===a.lanes&&(null===g||0===g.lanes)&&(g=b.lastRenderedReducer,null!==g))try{var h=b.lastRenderedState,k=g(h,c);f.eagerReducer=g;f.eagerState=k;if(He(k,h))return}catch(l){}finally{}Jg(a,e,d)}}\nvar Gh={readContext:vg,useCallback:Ah,useContext:Ah,useEffect:Ah,useImperativeHandle:Ah,useLayoutEffect:Ah,useMemo:Ah,useReducer:Ah,useRef:Ah,useState:Ah,useDebugValue:Ah,useDeferredValue:Ah,useTransition:Ah,useMutableSource:Ah,useOpaqueIdentifier:Ah,unstable_isNewReconciler:!1},Dh={readContext:vg,useCallback:function(a,b){Hh().memoizedState=[a,void 0===b?null:b];return a},useContext:vg,useEffect:Wh,useImperativeHandle:function(a,b,c){c=null!==c&&void 0!==c?c.concat([a]):null;return Uh(4,2,Zh.bind(null,\nb,a),c)},useLayoutEffect:function(a,b){return Uh(4,2,a,b)},useMemo:function(a,b){var c=Hh();b=void 0===b?null:b;a=a();c.memoizedState=[a,b];return a},useReducer:function(a,b,c){var d=Hh();b=void 0!==c?c(b):b;d.memoizedState=d.baseState=b;a=d.queue={pending:null,dispatch:null,lastRenderedReducer:a,lastRenderedState:b};a=a.dispatch=Oh.bind(null,R,a);return[d.memoizedState,a]},useRef:Sh,useState:Qh,useDebugValue:ai,useDeferredValue:function(a){var b=Qh(a),c=b[0],d=b[1];Wh(function(){var b=wh.transition;\nwh.transition=1;try{d(a)}finally{wh.transition=b}},[a]);return c},useTransition:function(){var a=Qh(!1),b=a[0];a=di.bind(null,a[1]);Sh(a);return[a,b]},useMutableSource:function(a,b,c){var d=Hh();d.memoizedState={refs:{getSnapshot:b,setSnapshot:null},source:a,subscribe:c};return Nh(d,a,b,c)},useOpaqueIdentifier:function(){if(lh){var a=!1,b=uf(function(){a||(a=!0,c("r:"+(tf++).toString(36)));throw Error(y(355));}),c=Qh(b)[1];0===(R.mode&2)&&(R.flags|=516,Rh(5,function(){c("r:"+(tf++).toString(36))},\nvoid 0,null));return b}b="r:"+(tf++).toString(36);Qh(b);return b},unstable_isNewReconciler:!1},Eh={readContext:vg,useCallback:bi,useContext:vg,useEffect:Xh,useImperativeHandle:$h,useLayoutEffect:Yh,useMemo:ci,useReducer:Kh,useRef:Th,useState:function(){return Kh(Jh)},useDebugValue:ai,useDeferredValue:function(a){var b=Kh(Jh),c=b[0],d=b[1];Xh(function(){var b=wh.transition;wh.transition=1;try{d(a)}finally{wh.transition=b}},[a]);return c},useTransition:function(){var a=Kh(Jh)[0];return[Th().current,\na]},useMutableSource:Ph,useOpaqueIdentifier:function(){return Kh(Jh)[0]},unstable_isNewReconciler:!1},Fh={readContext:vg,useCallback:bi,useContext:vg,useEffect:Xh,useImperativeHandle:$h,useLayoutEffect:Yh,useMemo:ci,useReducer:Lh,useRef:Th,useState:function(){return Lh(Jh)},useDebugValue:ai,useDeferredValue:function(a){var b=Lh(Jh),c=b[0],d=b[1];Xh(function(){var b=wh.transition;wh.transition=1;try{d(a)}finally{wh.transition=b}},[a]);return c},useTransition:function(){var a=Lh(Jh)[0];return[Th().current,\na]},useMutableSource:Ph,useOpaqueIdentifier:function(){return Lh(Jh)[0]},unstable_isNewReconciler:!1},ei=ra.ReactCurrentOwner,ug=!1;function fi(a,b,c,d){b.child=null===a?Zg(b,null,c,d):Yg(b,a.child,c,d)}function gi(a,b,c,d,e){c=c.render;var f=b.ref;tg(b,e);d=Ch(a,b,c,d,f,e);if(null!==a&&!ug)return b.updateQueue=a.updateQueue,b.flags&=-517,a.lanes&=~e,hi(a,b,e);b.flags|=1;fi(a,b,d,e);return b.child}\nfunction ii(a,b,c,d,e,f){if(null===a){var g=c.type;if("function"===typeof g&&!ji(g)&&void 0===g.defaultProps&&null===c.compare&&void 0===c.defaultProps)return b.tag=15,b.type=g,ki(a,b,g,d,e,f);a=Vg(c.type,null,d,b,b.mode,f);a.ref=b.ref;a.return=b;return b.child=a}g=a.child;if(0===(e&f)&&(e=g.memoizedProps,c=c.compare,c=null!==c?c:Je,c(e,d)&&a.ref===b.ref))return hi(a,b,f);b.flags|=1;a=Tg(g,d);a.ref=b.ref;a.return=b;return b.child=a}\nfunction ki(a,b,c,d,e,f){if(null!==a&&Je(a.memoizedProps,d)&&a.ref===b.ref)if(ug=!1,0!==(f&e))0!==(a.flags&16384)&&(ug=!0);else return b.lanes=a.lanes,hi(a,b,f);return li(a,b,c,d,f)}\nfunction mi(a,b,c){var d=b.pendingProps,e=d.children,f=null!==a?a.memoizedState:null;if("hidden"===d.mode||"unstable-defer-without-hiding"===d.mode)if(0===(b.mode&4))b.memoizedState={baseLanes:0},ni(b,c);else if(0!==(c&1073741824))b.memoizedState={baseLanes:0},ni(b,null!==f?f.baseLanes:c);else return a=null!==f?f.baseLanes|c:c,b.lanes=b.childLanes=1073741824,b.memoizedState={baseLanes:a},ni(b,a),null;else null!==f?(d=f.baseLanes|c,b.memoizedState=null):d=c,ni(b,d);fi(a,b,e,c);return b.child}\nfunction oi(a,b){var c=b.ref;if(null===a&&null!==c||null!==a&&a.ref!==c)b.flags|=128}function li(a,b,c,d,e){var f=Ff(c)?Df:M.current;f=Ef(b,f);tg(b,e);c=Ch(a,b,c,d,f,e);if(null!==a&&!ug)return b.updateQueue=a.updateQueue,b.flags&=-517,a.lanes&=~e,hi(a,b,e);b.flags|=1;fi(a,b,c,e);return b.child}\nfunction pi(a,b,c,d,e){if(Ff(c)){var f=!0;Jf(b)}else f=!1;tg(b,e);if(null===b.stateNode)null!==a&&(a.alternate=null,b.alternate=null,b.flags|=2),Mg(b,c,d),Og(b,c,d,e),d=!0;else if(null===a){var g=b.stateNode,h=b.memoizedProps;g.props=h;var k=g.context,l=c.contextType;"object"===typeof l&&null!==l?l=vg(l):(l=Ff(c)?Df:M.current,l=Ef(b,l));var n=c.getDerivedStateFromProps,A="function"===typeof n||"function"===typeof g.getSnapshotBeforeUpdate;A||"function"!==typeof g.UNSAFE_componentWillReceiveProps&&\n"function"!==typeof g.componentWillReceiveProps||(h!==d||k!==l)&&Ng(b,g,d,l);wg=!1;var p=b.memoizedState;g.state=p;Cg(b,d,g,e);k=b.memoizedState;h!==d||p!==k||N.current||wg?("function"===typeof n&&(Gg(b,c,n,d),k=b.memoizedState),(h=wg||Lg(b,c,h,d,p,k,l))?(A||"function"!==typeof g.UNSAFE_componentWillMount&&"function"!==typeof g.componentWillMount||("function"===typeof g.componentWillMount&&g.componentWillMount(),"function"===typeof g.UNSAFE_componentWillMount&&g.UNSAFE_componentWillMount()),"function"===\ntypeof g.componentDidMount&&(b.flags|=4)):("function"===typeof g.componentDidMount&&(b.flags|=4),b.memoizedProps=d,b.memoizedState=k),g.props=d,g.state=k,g.context=l,d=h):("function"===typeof g.componentDidMount&&(b.flags|=4),d=!1)}else{g=b.stateNode;yg(a,b);h=b.memoizedProps;l=b.type===b.elementType?h:lg(b.type,h);g.props=l;A=b.pendingProps;p=g.context;k=c.contextType;"object"===typeof k&&null!==k?k=vg(k):(k=Ff(c)?Df:M.current,k=Ef(b,k));var C=c.getDerivedStateFromProps;(n="function"===typeof C||\n"function"===typeof g.getSnapshotBeforeUpdate)||"function"!==typeof g.UNSAFE_componentWillReceiveProps&&"function"!==typeof g.componentWillReceiveProps||(h!==A||p!==k)&&Ng(b,g,d,k);wg=!1;p=b.memoizedState;g.state=p;Cg(b,d,g,e);var x=b.memoizedState;h!==A||p!==x||N.current||wg?("function"===typeof C&&(Gg(b,c,C,d),x=b.memoizedState),(l=wg||Lg(b,c,l,d,p,x,k))?(n||"function"!==typeof g.UNSAFE_componentWillUpdate&&"function"!==typeof g.componentWillUpdate||("function"===typeof g.componentWillUpdate&&g.componentWillUpdate(d,\nx,k),"function"===typeof g.UNSAFE_componentWillUpdate&&g.UNSAFE_componentWillUpdate(d,x,k)),"function"===typeof g.componentDidUpdate&&(b.flags|=4),"function"===typeof g.getSnapshotBeforeUpdate&&(b.flags|=256)):("function"!==typeof g.componentDidUpdate||h===a.memoizedProps&&p===a.memoizedState||(b.flags|=4),"function"!==typeof g.getSnapshotBeforeUpdate||h===a.memoizedProps&&p===a.memoizedState||(b.flags|=256),b.memoizedProps=d,b.memoizedState=x),g.props=d,g.state=x,g.context=k,d=l):("function"!==typeof g.componentDidUpdate||\nh===a.memoizedProps&&p===a.memoizedState||(b.flags|=4),"function"!==typeof g.getSnapshotBeforeUpdate||h===a.memoizedProps&&p===a.memoizedState||(b.flags|=256),d=!1)}return qi(a,b,c,d,f,e)}\nfunction qi(a,b,c,d,e,f){oi(a,b);var g=0!==(b.flags&64);if(!d&&!g)return e&&Kf(b,c,!1),hi(a,b,f);d=b.stateNode;ei.current=b;var h=g&&"function"!==typeof c.getDerivedStateFromError?null:d.render();b.flags|=1;null!==a&&g?(b.child=Yg(b,a.child,null,f),b.child=Yg(b,null,h,f)):fi(a,b,h,f);b.memoizedState=d.state;e&&Kf(b,c,!0);return b.child}function ri(a){var b=a.stateNode;b.pendingContext?Hf(a,b.pendingContext,b.pendingContext!==b.context):b.context&&Hf(a,b.context,!1);eh(a,b.containerInfo)}\nvar si={dehydrated:null,retryLane:0};\nfunction ti(a,b,c){var d=b.pendingProps,e=P.current,f=!1,g;(g=0!==(b.flags&64))||(g=null!==a&&null===a.memoizedState?!1:0!==(e&2));g?(f=!0,b.flags&=-65):null!==a&&null===a.memoizedState||void 0===d.fallback||!0===d.unstable_avoidThisFallback||(e|=1);I(P,e&1);if(null===a){void 0!==d.fallback&&ph(b);a=d.children;e=d.fallback;if(f)return a=ui(b,a,e,c),b.child.memoizedState={baseLanes:c},b.memoizedState=si,a;if("number"===typeof d.unstable_expectedLoadTime)return a=ui(b,a,e,c),b.child.memoizedState={baseLanes:c},\nb.memoizedState=si,b.lanes=33554432,a;c=vi({mode:"visible",children:a},b.mode,c,null);c.return=b;return b.child=c}if(null!==a.memoizedState){if(f)return d=wi(a,b,d.children,d.fallback,c),f=b.child,e=a.child.memoizedState,f.memoizedState=null===e?{baseLanes:c}:{baseLanes:e.baseLanes|c},f.childLanes=a.childLanes&~c,b.memoizedState=si,d;c=xi(a,b,d.children,c);b.memoizedState=null;return c}if(f)return d=wi(a,b,d.children,d.fallback,c),f=b.child,e=a.child.memoizedState,f.memoizedState=null===e?{baseLanes:c}:\n{baseLanes:e.baseLanes|c},f.childLanes=a.childLanes&~c,b.memoizedState=si,d;c=xi(a,b,d.children,c);b.memoizedState=null;return c}function ui(a,b,c,d){var e=a.mode,f=a.child;b={mode:"hidden",children:b};0===(e&2)&&null!==f?(f.childLanes=0,f.pendingProps=b):f=vi(b,e,0,null);c=Xg(c,e,d,null);f.return=a;c.return=a;f.sibling=c;a.child=f;return c}\nfunction xi(a,b,c,d){var e=a.child;a=e.sibling;c=Tg(e,{mode:"visible",children:c});0===(b.mode&2)&&(c.lanes=d);c.return=b;c.sibling=null;null!==a&&(a.nextEffect=null,a.flags=8,b.firstEffect=b.lastEffect=a);return b.child=c}\nfunction wi(a,b,c,d,e){var f=b.mode,g=a.child;a=g.sibling;var h={mode:"hidden",children:c};0===(f&2)&&b.child!==g?(c=b.child,c.childLanes=0,c.pendingProps=h,g=c.lastEffect,null!==g?(b.firstEffect=c.firstEffect,b.lastEffect=g,g.nextEffect=null):b.firstEffect=b.lastEffect=null):c=Tg(g,h);null!==a?d=Tg(a,d):(d=Xg(d,f,e,null),d.flags|=2);d.return=b;c.return=b;c.sibling=d;b.child=c;return d}function yi(a,b){a.lanes|=b;var c=a.alternate;null!==c&&(c.lanes|=b);sg(a.return,b)}\nfunction zi(a,b,c,d,e,f){var g=a.memoizedState;null===g?a.memoizedState={isBackwards:b,rendering:null,renderingStartTime:0,last:d,tail:c,tailMode:e,lastEffect:f}:(g.isBackwards=b,g.rendering=null,g.renderingStartTime=0,g.last=d,g.tail=c,g.tailMode=e,g.lastEffect=f)}\nfunction Ai(a,b,c){var d=b.pendingProps,e=d.revealOrder,f=d.tail;fi(a,b,d.children,c);d=P.current;if(0!==(d&2))d=d&1|2,b.flags|=64;else{if(null!==a&&0!==(a.flags&64))a:for(a=b.child;null!==a;){if(13===a.tag)null!==a.memoizedState&&yi(a,c);else if(19===a.tag)yi(a,c);else if(null!==a.child){a.child.return=a;a=a.child;continue}if(a===b)break a;for(;null===a.sibling;){if(null===a.return||a.return===b)break a;a=a.return}a.sibling.return=a.return;a=a.sibling}d&=1}I(P,d);if(0===(b.mode&2))b.memoizedState=\nnull;else switch(e){case "forwards":c=b.child;for(e=null;null!==c;)a=c.alternate,null!==a&&null===ih(a)&&(e=c),c=c.sibling;c=e;null===c?(e=b.child,b.child=null):(e=c.sibling,c.sibling=null);zi(b,!1,e,c,f,b.lastEffect);break;case "backwards":c=null;e=b.child;for(b.child=null;null!==e;){a=e.alternate;if(null!==a&&null===ih(a)){b.child=e;break}a=e.sibling;e.sibling=c;c=e;e=a}zi(b,!0,c,null,f,b.lastEffect);break;case "together":zi(b,!1,null,null,void 0,b.lastEffect);break;default:b.memoizedState=null}return b.child}\nfunction hi(a,b,c){null!==a&&(b.dependencies=a.dependencies);Dg|=b.lanes;if(0!==(c&b.childLanes)){if(null!==a&&b.child!==a.child)throw Error(y(153));if(null!==b.child){a=b.child;c=Tg(a,a.pendingProps);b.child=c;for(c.return=b;null!==a.sibling;)a=a.sibling,c=c.sibling=Tg(a,a.pendingProps),c.return=b;c.sibling=null}return b.child}return null}var Bi,Ci,Di,Ei;\nBi=function(a,b){for(var c=b.child;null!==c;){if(5===c.tag||6===c.tag)a.appendChild(c.stateNode);else if(4!==c.tag&&null!==c.child){c.child.return=c;c=c.child;continue}if(c===b)break;for(;null===c.sibling;){if(null===c.return||c.return===b)return;c=c.return}c.sibling.return=c.return;c=c.sibling}};Ci=function(){};\nDi=function(a,b,c,d){var e=a.memoizedProps;if(e!==d){a=b.stateNode;dh(ah.current);var f=null;switch(c){case "input":e=Ya(a,e);d=Ya(a,d);f=[];break;case "option":e=eb(a,e);d=eb(a,d);f=[];break;case "select":e=m({},e,{value:void 0});d=m({},d,{value:void 0});f=[];break;case "textarea":e=gb(a,e);d=gb(a,d);f=[];break;default:"function"!==typeof e.onClick&&"function"===typeof d.onClick&&(a.onclick=jf)}vb(c,d);var g;c=null;for(l in e)if(!d.hasOwnProperty(l)&&e.hasOwnProperty(l)&&null!=e[l])if("style"===\nl){var h=e[l];for(g in h)h.hasOwnProperty(g)&&(c||(c={}),c[g]="")}else"dangerouslySetInnerHTML"!==l&&"children"!==l&&"suppressContentEditableWarning"!==l&&"suppressHydrationWarning"!==l&&"autoFocus"!==l&&(ca.hasOwnProperty(l)?f||(f=[]):(f=f||[]).push(l,null));for(l in d){var k=d[l];h=null!=e?e[l]:void 0;if(d.hasOwnProperty(l)&&k!==h&&(null!=k||null!=h))if("style"===l)if(h){for(g in h)!h.hasOwnProperty(g)||k&&k.hasOwnProperty(g)||(c||(c={}),c[g]="");for(g in k)k.hasOwnProperty(g)&&h[g]!==k[g]&&(c||\n(c={}),c[g]=k[g])}else c||(f||(f=[]),f.push(l,c)),c=k;else"dangerouslySetInnerHTML"===l?(k=k?k.__html:void 0,h=h?h.__html:void 0,null!=k&&h!==k&&(f=f||[]).push(l,k)):"children"===l?"string"!==typeof k&&"number"!==typeof k||(f=f||[]).push(l,""+k):"suppressContentEditableWarning"!==l&&"suppressHydrationWarning"!==l&&(ca.hasOwnProperty(l)?(null!=k&&"onScroll"===l&&G("scroll",a),f||h===k||(f=[])):"object"===typeof k&&null!==k&&k.$$typeof===Ga?k.toString():(f=f||[]).push(l,k))}c&&(f=f||[]).push("style",\nc);var l=f;if(b.updateQueue=l)b.flags|=4}};Ei=function(a,b,c,d){c!==d&&(b.flags|=4)};function Fi(a,b){if(!lh)switch(a.tailMode){case "hidden":b=a.tail;for(var c=null;null!==b;)null!==b.alternate&&(c=b),b=b.sibling;null===c?a.tail=null:c.sibling=null;break;case "collapsed":c=a.tail;for(var d=null;null!==c;)null!==c.alternate&&(d=c),c=c.sibling;null===d?b||null===a.tail?a.tail=null:a.tail.sibling=null:d.sibling=null}}\nfunction Gi(a,b,c){var d=b.pendingProps;switch(b.tag){case 2:case 16:case 15:case 0:case 11:case 7:case 8:case 12:case 9:case 14:return null;case 1:return Ff(b.type)&&Gf(),null;case 3:fh();H(N);H(M);uh();d=b.stateNode;d.pendingContext&&(d.context=d.pendingContext,d.pendingContext=null);if(null===a||null===a.child)rh(b)?b.flags|=4:d.hydrate||(b.flags|=256);Ci(b);return null;case 5:hh(b);var e=dh(ch.current);c=b.type;if(null!==a&&null!=b.stateNode)Di(a,b,c,d,e),a.ref!==b.ref&&(b.flags|=128);else{if(!d){if(null===\nb.stateNode)throw Error(y(166));return null}a=dh(ah.current);if(rh(b)){d=b.stateNode;c=b.type;var f=b.memoizedProps;d[wf]=b;d[xf]=f;switch(c){case "dialog":G("cancel",d);G("close",d);break;case "iframe":case "object":case "embed":G("load",d);break;case "video":case "audio":for(a=0;a<Xe.length;a++)G(Xe[a],d);break;case "source":G("error",d);break;case "img":case "image":case "link":G("error",d);G("load",d);break;case "details":G("toggle",d);break;case "input":Za(d,f);G("invalid",d);break;case "select":d._wrapperState=\n{wasMultiple:!!f.multiple};G("invalid",d);break;case "textarea":hb(d,f),G("invalid",d)}vb(c,f);a=null;for(var g in f)f.hasOwnProperty(g)&&(e=f[g],"children"===g?"string"===typeof e?d.textContent!==e&&(a=["children",e]):"number"===typeof e&&d.textContent!==""+e&&(a=["children",""+e]):ca.hasOwnProperty(g)&&null!=e&&"onScroll"===g&&G("scroll",d));switch(c){case "input":Va(d);cb(d,f,!0);break;case "textarea":Va(d);jb(d);break;case "select":case "option":break;default:"function"===typeof f.onClick&&(d.onclick=\njf)}d=a;b.updateQueue=d;null!==d&&(b.flags|=4)}else{g=9===e.nodeType?e:e.ownerDocument;a===kb.html&&(a=lb(c));a===kb.html?"script"===c?(a=g.createElement("div"),a.innerHTML="<script>\\x3c/script>",a=a.removeChild(a.firstChild)):"string"===typeof d.is?a=g.createElement(c,{is:d.is}):(a=g.createElement(c),"select"===c&&(g=a,d.multiple?g.multiple=!0:d.size&&(g.size=d.size))):a=g.createElementNS(a,c);a[wf]=b;a[xf]=d;Bi(a,b,!1,!1);b.stateNode=a;g=wb(c,d);switch(c){case "dialog":G("cancel",a);G("close",a);\ne=d;break;case "iframe":case "object":case "embed":G("load",a);e=d;break;case "video":case "audio":for(e=0;e<Xe.length;e++)G(Xe[e],a);e=d;break;case "source":G("error",a);e=d;break;case "img":case "image":case "link":G("error",a);G("load",a);e=d;break;case "details":G("toggle",a);e=d;break;case "input":Za(a,d);e=Ya(a,d);G("invalid",a);break;case "option":e=eb(a,d);break;case "select":a._wrapperState={wasMultiple:!!d.multiple};e=m({},d,{value:void 0});G("invalid",a);break;case "textarea":hb(a,d);e=\ngb(a,d);G("invalid",a);break;default:e=d}vb(c,e);var h=e;for(f in h)if(h.hasOwnProperty(f)){var k=h[f];"style"===f?tb(a,k):"dangerouslySetInnerHTML"===f?(k=k?k.__html:void 0,null!=k&&ob(a,k)):"children"===f?"string"===typeof k?("textarea"!==c||""!==k)&&pb(a,k):"number"===typeof k&&pb(a,""+k):"suppressContentEditableWarning"!==f&&"suppressHydrationWarning"!==f&&"autoFocus"!==f&&(ca.hasOwnProperty(f)?null!=k&&"onScroll"===f&&G("scroll",a):null!=k&&qa(a,f,k,g))}switch(c){case "input":Va(a);cb(a,d,!1);\nbreak;case "textarea":Va(a);jb(a);break;case "option":null!=d.value&&a.setAttribute("value",""+Sa(d.value));break;case "select":a.multiple=!!d.multiple;f=d.value;null!=f?fb(a,!!d.multiple,f,!1):null!=d.defaultValue&&fb(a,!!d.multiple,d.defaultValue,!0);break;default:"function"===typeof e.onClick&&(a.onclick=jf)}mf(c,d)&&(b.flags|=4)}null!==b.ref&&(b.flags|=128)}return null;case 6:if(a&&null!=b.stateNode)Ei(a,b,a.memoizedProps,d);else{if("string"!==typeof d&&null===b.stateNode)throw Error(y(166));\nc=dh(ch.current);dh(ah.current);rh(b)?(d=b.stateNode,c=b.memoizedProps,d[wf]=b,d.nodeValue!==c&&(b.flags|=4)):(d=(9===c.nodeType?c:c.ownerDocument).createTextNode(d),d[wf]=b,b.stateNode=d)}return null;case 13:H(P);d=b.memoizedState;if(0!==(b.flags&64))return b.lanes=c,b;d=null!==d;c=!1;null===a?void 0!==b.memoizedProps.fallback&&rh(b):c=null!==a.memoizedState;if(d&&!c&&0!==(b.mode&2))if(null===a&&!0!==b.memoizedProps.unstable_avoidThisFallback||0!==(P.current&1))0===V&&(V=3);else{if(0===V||3===V)V=\n4;null===U||0===(Dg&134217727)&&0===(Hi&134217727)||Ii(U,W)}if(d||c)b.flags|=4;return null;case 4:return fh(),Ci(b),null===a&&cf(b.stateNode.containerInfo),null;case 10:return rg(b),null;case 17:return Ff(b.type)&&Gf(),null;case 19:H(P);d=b.memoizedState;if(null===d)return null;f=0!==(b.flags&64);g=d.rendering;if(null===g)if(f)Fi(d,!1);else{if(0!==V||null!==a&&0!==(a.flags&64))for(a=b.child;null!==a;){g=ih(a);if(null!==g){b.flags|=64;Fi(d,!1);f=g.updateQueue;null!==f&&(b.updateQueue=f,b.flags|=4);\nnull===d.lastEffect&&(b.firstEffect=null);b.lastEffect=d.lastEffect;d=c;for(c=b.child;null!==c;)f=c,a=d,f.flags&=2,f.nextEffect=null,f.firstEffect=null,f.lastEffect=null,g=f.alternate,null===g?(f.childLanes=0,f.lanes=a,f.child=null,f.memoizedProps=null,f.memoizedState=null,f.updateQueue=null,f.dependencies=null,f.stateNode=null):(f.childLanes=g.childLanes,f.lanes=g.lanes,f.child=g.child,f.memoizedProps=g.memoizedProps,f.memoizedState=g.memoizedState,f.updateQueue=g.updateQueue,f.type=g.type,a=g.dependencies,\nf.dependencies=null===a?null:{lanes:a.lanes,firstContext:a.firstContext}),c=c.sibling;I(P,P.current&1|2);return b.child}a=a.sibling}null!==d.tail&&O()>Ji&&(b.flags|=64,f=!0,Fi(d,!1),b.lanes=33554432)}else{if(!f)if(a=ih(g),null!==a){if(b.flags|=64,f=!0,c=a.updateQueue,null!==c&&(b.updateQueue=c,b.flags|=4),Fi(d,!0),null===d.tail&&"hidden"===d.tailMode&&!g.alternate&&!lh)return b=b.lastEffect=d.lastEffect,null!==b&&(b.nextEffect=null),null}else 2*O()-d.renderingStartTime>Ji&&1073741824!==c&&(b.flags|=\n64,f=!0,Fi(d,!1),b.lanes=33554432);d.isBackwards?(g.sibling=b.child,b.child=g):(c=d.last,null!==c?c.sibling=g:b.child=g,d.last=g)}return null!==d.tail?(c=d.tail,d.rendering=c,d.tail=c.sibling,d.lastEffect=b.lastEffect,d.renderingStartTime=O(),c.sibling=null,b=P.current,I(P,f?b&1|2:b&1),c):null;case 23:case 24:return Ki(),null!==a&&null!==a.memoizedState!==(null!==b.memoizedState)&&"unstable-defer-without-hiding"!==d.mode&&(b.flags|=4),null}throw Error(y(156,b.tag));}\nfunction Li(a){switch(a.tag){case 1:Ff(a.type)&&Gf();var b=a.flags;return b&4096?(a.flags=b&-4097|64,a):null;case 3:fh();H(N);H(M);uh();b=a.flags;if(0!==(b&64))throw Error(y(285));a.flags=b&-4097|64;return a;case 5:return hh(a),null;case 13:return H(P),b=a.flags,b&4096?(a.flags=b&-4097|64,a):null;case 19:return H(P),null;case 4:return fh(),null;case 10:return rg(a),null;case 23:case 24:return Ki(),null;default:return null}}\nfunction Mi(a,b){try{var c="",d=b;do c+=Qa(d),d=d.return;while(d);var e=c}catch(f){e="\\nError generating stack: "+f.message+"\\n"+f.stack}return{value:a,source:b,stack:e}}function Ni(a,b){try{console.error(b.value)}catch(c){setTimeout(function(){throw c;})}}var Oi="function"===typeof WeakMap?WeakMap:Map;function Pi(a,b,c){c=zg(-1,c);c.tag=3;c.payload={element:null};var d=b.value;c.callback=function(){Qi||(Qi=!0,Ri=d);Ni(a,b)};return c}\nfunction Si(a,b,c){c=zg(-1,c);c.tag=3;var d=a.type.getDerivedStateFromError;if("function"===typeof d){var e=b.value;c.payload=function(){Ni(a,b);return d(e)}}var f=a.stateNode;null!==f&&"function"===typeof f.componentDidCatch&&(c.callback=function(){"function"!==typeof d&&(null===Ti?Ti=new Set([this]):Ti.add(this),Ni(a,b));var c=b.stack;this.componentDidCatch(b.value,{componentStack:null!==c?c:""})});return c}var Ui="function"===typeof WeakSet?WeakSet:Set;\nfunction Vi(a){var b=a.ref;if(null!==b)if("function"===typeof b)try{b(null)}catch(c){Wi(a,c)}else b.current=null}function Xi(a,b){switch(b.tag){case 0:case 11:case 15:case 22:return;case 1:if(b.flags&256&&null!==a){var c=a.memoizedProps,d=a.memoizedState;a=b.stateNode;b=a.getSnapshotBeforeUpdate(b.elementType===b.type?c:lg(b.type,c),d);a.__reactInternalSnapshotBeforeUpdate=b}return;case 3:b.flags&256&&qf(b.stateNode.containerInfo);return;case 5:case 6:case 4:case 17:return}throw Error(y(163));}\nfunction Yi(a,b,c){switch(c.tag){case 0:case 11:case 15:case 22:b=c.updateQueue;b=null!==b?b.lastEffect:null;if(null!==b){a=b=b.next;do{if(3===(a.tag&3)){var d=a.create;a.destroy=d()}a=a.next}while(a!==b)}b=c.updateQueue;b=null!==b?b.lastEffect:null;if(null!==b){a=b=b.next;do{var e=a;d=e.next;e=e.tag;0!==(e&4)&&0!==(e&1)&&(Zi(c,a),$i(c,a));a=d}while(a!==b)}return;case 1:a=c.stateNode;c.flags&4&&(null===b?a.componentDidMount():(d=c.elementType===c.type?b.memoizedProps:lg(c.type,b.memoizedProps),a.componentDidUpdate(d,\nb.memoizedState,a.__reactInternalSnapshotBeforeUpdate)));b=c.updateQueue;null!==b&&Eg(c,b,a);return;case 3:b=c.updateQueue;if(null!==b){a=null;if(null!==c.child)switch(c.child.tag){case 5:a=c.child.stateNode;break;case 1:a=c.child.stateNode}Eg(c,b,a)}return;case 5:a=c.stateNode;null===b&&c.flags&4&&mf(c.type,c.memoizedProps)&&a.focus();return;case 6:return;case 4:return;case 12:return;case 13:null===c.memoizedState&&(c=c.alternate,null!==c&&(c=c.memoizedState,null!==c&&(c=c.dehydrated,null!==c&&Cc(c))));\nreturn;case 19:case 17:case 20:case 21:case 23:case 24:return}throw Error(y(163));}\nfunction aj(a,b){for(var c=a;;){if(5===c.tag){var d=c.stateNode;if(b)d=d.style,"function"===typeof d.setProperty?d.setProperty("display","none","important"):d.display="none";else{d=c.stateNode;var e=c.memoizedProps.style;e=void 0!==e&&null!==e&&e.hasOwnProperty("display")?e.display:null;d.style.display=sb("display",e)}}else if(6===c.tag)c.stateNode.nodeValue=b?"":c.memoizedProps;else if((23!==c.tag&&24!==c.tag||null===c.memoizedState||c===a)&&null!==c.child){c.child.return=c;c=c.child;continue}if(c===\na)break;for(;null===c.sibling;){if(null===c.return||c.return===a)return;c=c.return}c.sibling.return=c.return;c=c.sibling}}\nfunction bj(a,b){if(Mf&&"function"===typeof Mf.onCommitFiberUnmount)try{Mf.onCommitFiberUnmount(Lf,b)}catch(f){}switch(b.tag){case 0:case 11:case 14:case 15:case 22:a=b.updateQueue;if(null!==a&&(a=a.lastEffect,null!==a)){var c=a=a.next;do{var d=c,e=d.destroy;d=d.tag;if(void 0!==e)if(0!==(d&4))Zi(b,c);else{d=b;try{e()}catch(f){Wi(d,f)}}c=c.next}while(c!==a)}break;case 1:Vi(b);a=b.stateNode;if("function"===typeof a.componentWillUnmount)try{a.props=b.memoizedProps,a.state=b.memoizedState,a.componentWillUnmount()}catch(f){Wi(b,\nf)}break;case 5:Vi(b);break;case 4:cj(a,b)}}function dj(a){a.alternate=null;a.child=null;a.dependencies=null;a.firstEffect=null;a.lastEffect=null;a.memoizedProps=null;a.memoizedState=null;a.pendingProps=null;a.return=null;a.updateQueue=null}function ej(a){return 5===a.tag||3===a.tag||4===a.tag}\nfunction fj(a){a:{for(var b=a.return;null!==b;){if(ej(b))break a;b=b.return}throw Error(y(160));}var c=b;b=c.stateNode;switch(c.tag){case 5:var d=!1;break;case 3:b=b.containerInfo;d=!0;break;case 4:b=b.containerInfo;d=!0;break;default:throw Error(y(161));}c.flags&16&&(pb(b,""),c.flags&=-17);a:b:for(c=a;;){for(;null===c.sibling;){if(null===c.return||ej(c.return)){c=null;break a}c=c.return}c.sibling.return=c.return;for(c=c.sibling;5!==c.tag&&6!==c.tag&&18!==c.tag;){if(c.flags&2)continue b;if(null===\nc.child||4===c.tag)continue b;else c.child.return=c,c=c.child}if(!(c.flags&2)){c=c.stateNode;break a}}d?gj(a,c,b):hj(a,c,b)}\nfunction gj(a,b,c){var d=a.tag,e=5===d||6===d;if(e)a=e?a.stateNode:a.stateNode.instance,b?8===c.nodeType?c.parentNode.insertBefore(a,b):c.insertBefore(a,b):(8===c.nodeType?(b=c.parentNode,b.insertBefore(a,c)):(b=c,b.appendChild(a)),c=c._reactRootContainer,null!==c&&void 0!==c||null!==b.onclick||(b.onclick=jf));else if(4!==d&&(a=a.child,null!==a))for(gj(a,b,c),a=a.sibling;null!==a;)gj(a,b,c),a=a.sibling}\nfunction hj(a,b,c){var d=a.tag,e=5===d||6===d;if(e)a=e?a.stateNode:a.stateNode.instance,b?c.insertBefore(a,b):c.appendChild(a);else if(4!==d&&(a=a.child,null!==a))for(hj(a,b,c),a=a.sibling;null!==a;)hj(a,b,c),a=a.sibling}\nfunction cj(a,b){for(var c=b,d=!1,e,f;;){if(!d){d=c.return;a:for(;;){if(null===d)throw Error(y(160));e=d.stateNode;switch(d.tag){case 5:f=!1;break a;case 3:e=e.containerInfo;f=!0;break a;case 4:e=e.containerInfo;f=!0;break a}d=d.return}d=!0}if(5===c.tag||6===c.tag){a:for(var g=a,h=c,k=h;;)if(bj(g,k),null!==k.child&&4!==k.tag)k.child.return=k,k=k.child;else{if(k===h)break a;for(;null===k.sibling;){if(null===k.return||k.return===h)break a;k=k.return}k.sibling.return=k.return;k=k.sibling}f?(g=e,h=c.stateNode,\n8===g.nodeType?g.parentNode.removeChild(h):g.removeChild(h)):e.removeChild(c.stateNode)}else if(4===c.tag){if(null!==c.child){e=c.stateNode.containerInfo;f=!0;c.child.return=c;c=c.child;continue}}else if(bj(a,c),null!==c.child){c.child.return=c;c=c.child;continue}if(c===b)break;for(;null===c.sibling;){if(null===c.return||c.return===b)return;c=c.return;4===c.tag&&(d=!1)}c.sibling.return=c.return;c=c.sibling}}\nfunction ij(a,b){switch(b.tag){case 0:case 11:case 14:case 15:case 22:var c=b.updateQueue;c=null!==c?c.lastEffect:null;if(null!==c){var d=c=c.next;do 3===(d.tag&3)&&(a=d.destroy,d.destroy=void 0,void 0!==a&&a()),d=d.next;while(d!==c)}return;case 1:return;case 5:c=b.stateNode;if(null!=c){d=b.memoizedProps;var e=null!==a?a.memoizedProps:d;a=b.type;var f=b.updateQueue;b.updateQueue=null;if(null!==f){c[xf]=d;"input"===a&&"radio"===d.type&&null!=d.name&&$a(c,d);wb(a,e);b=wb(a,d);for(e=0;e<f.length;e+=\n2){var g=f[e],h=f[e+1];"style"===g?tb(c,h):"dangerouslySetInnerHTML"===g?ob(c,h):"children"===g?pb(c,h):qa(c,g,h,b)}switch(a){case "input":ab(c,d);break;case "textarea":ib(c,d);break;case "select":a=c._wrapperState.wasMultiple,c._wrapperState.wasMultiple=!!d.multiple,f=d.value,null!=f?fb(c,!!d.multiple,f,!1):a!==!!d.multiple&&(null!=d.defaultValue?fb(c,!!d.multiple,d.defaultValue,!0):fb(c,!!d.multiple,d.multiple?[]:"",!1))}}}return;case 6:if(null===b.stateNode)throw Error(y(162));b.stateNode.nodeValue=\nb.memoizedProps;return;case 3:c=b.stateNode;c.hydrate&&(c.hydrate=!1,Cc(c.containerInfo));return;case 12:return;case 13:null!==b.memoizedState&&(jj=O(),aj(b.child,!0));kj(b);return;case 19:kj(b);return;case 17:return;case 23:case 24:aj(b,null!==b.memoizedState);return}throw Error(y(163));}function kj(a){var b=a.updateQueue;if(null!==b){a.updateQueue=null;var c=a.stateNode;null===c&&(c=a.stateNode=new Ui);b.forEach(function(b){var d=lj.bind(null,a,b);c.has(b)||(c.add(b),b.then(d,d))})}}\nfunction mj(a,b){return null!==a&&(a=a.memoizedState,null===a||null!==a.dehydrated)?(b=b.memoizedState,null!==b&&null===b.dehydrated):!1}var nj=Math.ceil,oj=ra.ReactCurrentDispatcher,pj=ra.ReactCurrentOwner,X=0,U=null,Y=null,W=0,qj=0,rj=Bf(0),V=0,sj=null,tj=0,Dg=0,Hi=0,uj=0,vj=null,jj=0,Ji=Infinity;function wj(){Ji=O()+500}var Z=null,Qi=!1,Ri=null,Ti=null,xj=!1,yj=null,zj=90,Aj=[],Bj=[],Cj=null,Dj=0,Ej=null,Fj=-1,Gj=0,Hj=0,Ij=null,Jj=!1;function Hg(){return 0!==(X&48)?O():-1!==Fj?Fj:Fj=O()}\nfunction Ig(a){a=a.mode;if(0===(a&2))return 1;if(0===(a&4))return 99===eg()?1:2;0===Gj&&(Gj=tj);if(0!==kg.transition){0!==Hj&&(Hj=null!==vj?vj.pendingLanes:0);a=Gj;var b=4186112&~Hj;b&=-b;0===b&&(a=4186112&~a,b=a&-a,0===b&&(b=8192));return b}a=eg();0!==(X&4)&&98===a?a=Xc(12,Gj):(a=Sc(a),a=Xc(a,Gj));return a}\nfunction Jg(a,b,c){if(50<Dj)throw Dj=0,Ej=null,Error(y(185));a=Kj(a,b);if(null===a)return null;$c(a,b,c);a===U&&(Hi|=b,4===V&&Ii(a,W));var d=eg();1===b?0!==(X&8)&&0===(X&48)?Lj(a):(Mj(a,c),0===X&&(wj(),ig())):(0===(X&4)||98!==d&&99!==d||(null===Cj?Cj=new Set([a]):Cj.add(a)),Mj(a,c));vj=a}function Kj(a,b){a.lanes|=b;var c=a.alternate;null!==c&&(c.lanes|=b);c=a;for(a=a.return;null!==a;)a.childLanes|=b,c=a.alternate,null!==c&&(c.childLanes|=b),c=a,a=a.return;return 3===c.tag?c.stateNode:null}\nfunction Mj(a,b){for(var c=a.callbackNode,d=a.suspendedLanes,e=a.pingedLanes,f=a.expirationTimes,g=a.pendingLanes;0<g;){var h=31-Vc(g),k=1<<h,l=f[h];if(-1===l){if(0===(k&d)||0!==(k&e)){l=b;Rc(k);var n=F;f[h]=10<=n?l+250:6<=n?l+5E3:-1}}else l<=b&&(a.expiredLanes|=k);g&=~k}d=Uc(a,a===U?W:0);b=F;if(0===d)null!==c&&(c!==Zf&&Pf(c),a.callbackNode=null,a.callbackPriority=0);else{if(null!==c){if(a.callbackPriority===b)return;c!==Zf&&Pf(c)}15===b?(c=Lj.bind(null,a),null===ag?(ag=[c],bg=Of(Uf,jg)):ag.push(c),\nc=Zf):14===b?c=hg(99,Lj.bind(null,a)):(c=Tc(b),c=hg(c,Nj.bind(null,a)));a.callbackPriority=b;a.callbackNode=c}}\nfunction Nj(a){Fj=-1;Hj=Gj=0;if(0!==(X&48))throw Error(y(327));var b=a.callbackNode;if(Oj()&&a.callbackNode!==b)return null;var c=Uc(a,a===U?W:0);if(0===c)return null;var d=c;var e=X;X|=16;var f=Pj();if(U!==a||W!==d)wj(),Qj(a,d);do try{Rj();break}catch(h){Sj(a,h)}while(1);qg();oj.current=f;X=e;null!==Y?d=0:(U=null,W=0,d=V);if(0!==(tj&Hi))Qj(a,0);else if(0!==d){2===d&&(X|=64,a.hydrate&&(a.hydrate=!1,qf(a.containerInfo)),c=Wc(a),0!==c&&(d=Tj(a,c)));if(1===d)throw b=sj,Qj(a,0),Ii(a,c),Mj(a,O()),b;a.finishedWork=\na.current.alternate;a.finishedLanes=c;switch(d){case 0:case 1:throw Error(y(345));case 2:Uj(a);break;case 3:Ii(a,c);if((c&62914560)===c&&(d=jj+500-O(),10<d)){if(0!==Uc(a,0))break;e=a.suspendedLanes;if((e&c)!==c){Hg();a.pingedLanes|=a.suspendedLanes&e;break}a.timeoutHandle=of(Uj.bind(null,a),d);break}Uj(a);break;case 4:Ii(a,c);if((c&4186112)===c)break;d=a.eventTimes;for(e=-1;0<c;){var g=31-Vc(c);f=1<<g;g=d[g];g>e&&(e=g);c&=~f}c=e;c=O()-c;c=(120>c?120:480>c?480:1080>c?1080:1920>c?1920:3E3>c?3E3:4320>\nc?4320:1960*nj(c/1960))-c;if(10<c){a.timeoutHandle=of(Uj.bind(null,a),c);break}Uj(a);break;case 5:Uj(a);break;default:throw Error(y(329));}}Mj(a,O());return a.callbackNode===b?Nj.bind(null,a):null}function Ii(a,b){b&=~uj;b&=~Hi;a.suspendedLanes|=b;a.pingedLanes&=~b;for(a=a.expirationTimes;0<b;){var c=31-Vc(b),d=1<<c;a[c]=-1;b&=~d}}\nfunction Lj(a){if(0!==(X&48))throw Error(y(327));Oj();if(a===U&&0!==(a.expiredLanes&W)){var b=W;var c=Tj(a,b);0!==(tj&Hi)&&(b=Uc(a,b),c=Tj(a,b))}else b=Uc(a,0),c=Tj(a,b);0!==a.tag&&2===c&&(X|=64,a.hydrate&&(a.hydrate=!1,qf(a.containerInfo)),b=Wc(a),0!==b&&(c=Tj(a,b)));if(1===c)throw c=sj,Qj(a,0),Ii(a,b),Mj(a,O()),c;a.finishedWork=a.current.alternate;a.finishedLanes=b;Uj(a);Mj(a,O());return null}\nfunction Vj(){if(null!==Cj){var a=Cj;Cj=null;a.forEach(function(a){a.expiredLanes|=24&a.pendingLanes;Mj(a,O())})}ig()}function Wj(a,b){var c=X;X|=1;try{return a(b)}finally{X=c,0===X&&(wj(),ig())}}function Xj(a,b){var c=X;X&=-2;X|=8;try{return a(b)}finally{X=c,0===X&&(wj(),ig())}}function ni(a,b){I(rj,qj);qj|=b;tj|=b}function Ki(){qj=rj.current;H(rj)}\nfunction Qj(a,b){a.finishedWork=null;a.finishedLanes=0;var c=a.timeoutHandle;-1!==c&&(a.timeoutHandle=-1,pf(c));if(null!==Y)for(c=Y.return;null!==c;){var d=c;switch(d.tag){case 1:d=d.type.childContextTypes;null!==d&&void 0!==d&&Gf();break;case 3:fh();H(N);H(M);uh();break;case 5:hh(d);break;case 4:fh();break;case 13:H(P);break;case 19:H(P);break;case 10:rg(d);break;case 23:case 24:Ki()}c=c.return}U=a;Y=Tg(a.current,null);W=qj=tj=b;V=0;sj=null;uj=Hi=Dg=0}\nfunction Sj(a,b){do{var c=Y;try{qg();vh.current=Gh;if(yh){for(var d=R.memoizedState;null!==d;){var e=d.queue;null!==e&&(e.pending=null);d=d.next}yh=!1}xh=0;T=S=R=null;zh=!1;pj.current=null;if(null===c||null===c.return){V=1;sj=b;Y=null;break}a:{var f=a,g=c.return,h=c,k=b;b=W;h.flags|=2048;h.firstEffect=h.lastEffect=null;if(null!==k&&"object"===typeof k&&"function"===typeof k.then){var l=k;if(0===(h.mode&2)){var n=h.alternate;n?(h.updateQueue=n.updateQueue,h.memoizedState=n.memoizedState,h.lanes=n.lanes):\n(h.updateQueue=null,h.memoizedState=null)}var A=0!==(P.current&1),p=g;do{var C;if(C=13===p.tag){var x=p.memoizedState;if(null!==x)C=null!==x.dehydrated?!0:!1;else{var w=p.memoizedProps;C=void 0===w.fallback?!1:!0!==w.unstable_avoidThisFallback?!0:A?!1:!0}}if(C){var z=p.updateQueue;if(null===z){var u=new Set;u.add(l);p.updateQueue=u}else z.add(l);if(0===(p.mode&2)){p.flags|=64;h.flags|=16384;h.flags&=-2981;if(1===h.tag)if(null===h.alternate)h.tag=17;else{var t=zg(-1,1);t.tag=2;Ag(h,t)}h.lanes|=1;break a}k=\nvoid 0;h=b;var q=f.pingCache;null===q?(q=f.pingCache=new Oi,k=new Set,q.set(l,k)):(k=q.get(l),void 0===k&&(k=new Set,q.set(l,k)));if(!k.has(h)){k.add(h);var v=Yj.bind(null,f,l,h);l.then(v,v)}p.flags|=4096;p.lanes=b;break a}p=p.return}while(null!==p);k=Error((Ra(h.type)||"A React component")+" suspended while rendering, but no fallback UI was specified.\\n\\nAdd a <Suspense fallback=...> component higher in the tree to provide a loading indicator or placeholder to display.")}5!==V&&(V=2);k=Mi(k,h);p=\ng;do{switch(p.tag){case 3:f=k;p.flags|=4096;b&=-b;p.lanes|=b;var J=Pi(p,f,b);Bg(p,J);break a;case 1:f=k;var K=p.type,Q=p.stateNode;if(0===(p.flags&64)&&("function"===typeof K.getDerivedStateFromError||null!==Q&&"function"===typeof Q.componentDidCatch&&(null===Ti||!Ti.has(Q)))){p.flags|=4096;b&=-b;p.lanes|=b;var L=Si(p,f,b);Bg(p,L);break a}}p=p.return}while(null!==p)}Zj(c)}catch(va){b=va;Y===c&&null!==c&&(Y=c=c.return);continue}break}while(1)}\nfunction Pj(){var a=oj.current;oj.current=Gh;return null===a?Gh:a}function Tj(a,b){var c=X;X|=16;var d=Pj();U===a&&W===b||Qj(a,b);do try{ak();break}catch(e){Sj(a,e)}while(1);qg();X=c;oj.current=d;if(null!==Y)throw Error(y(261));U=null;W=0;return V}function ak(){for(;null!==Y;)bk(Y)}function Rj(){for(;null!==Y&&!Qf();)bk(Y)}function bk(a){var b=ck(a.alternate,a,qj);a.memoizedProps=a.pendingProps;null===b?Zj(a):Y=b;pj.current=null}\nfunction Zj(a){var b=a;do{var c=b.alternate;a=b.return;if(0===(b.flags&2048)){c=Gi(c,b,qj);if(null!==c){Y=c;return}c=b;if(24!==c.tag&&23!==c.tag||null===c.memoizedState||0!==(qj&1073741824)||0===(c.mode&4)){for(var d=0,e=c.child;null!==e;)d|=e.lanes|e.childLanes,e=e.sibling;c.childLanes=d}null!==a&&0===(a.flags&2048)&&(null===a.firstEffect&&(a.firstEffect=b.firstEffect),null!==b.lastEffect&&(null!==a.lastEffect&&(a.lastEffect.nextEffect=b.firstEffect),a.lastEffect=b.lastEffect),1<b.flags&&(null!==\na.lastEffect?a.lastEffect.nextEffect=b:a.firstEffect=b,a.lastEffect=b))}else{c=Li(b);if(null!==c){c.flags&=2047;Y=c;return}null!==a&&(a.firstEffect=a.lastEffect=null,a.flags|=2048)}b=b.sibling;if(null!==b){Y=b;return}Y=b=a}while(null!==b);0===V&&(V=5)}function Uj(a){var b=eg();gg(99,dk.bind(null,a,b));return null}\nfunction dk(a,b){do Oj();while(null!==yj);if(0!==(X&48))throw Error(y(327));var c=a.finishedWork;if(null===c)return null;a.finishedWork=null;a.finishedLanes=0;if(c===a.current)throw Error(y(177));a.callbackNode=null;var d=c.lanes|c.childLanes,e=d,f=a.pendingLanes&~e;a.pendingLanes=e;a.suspendedLanes=0;a.pingedLanes=0;a.expiredLanes&=e;a.mutableReadLanes&=e;a.entangledLanes&=e;e=a.entanglements;for(var g=a.eventTimes,h=a.expirationTimes;0<f;){var k=31-Vc(f),l=1<<k;e[k]=0;g[k]=-1;h[k]=-1;f&=~l}null!==\nCj&&0===(d&24)&&Cj.has(a)&&Cj.delete(a);a===U&&(Y=U=null,W=0);1<c.flags?null!==c.lastEffect?(c.lastEffect.nextEffect=c,d=c.firstEffect):d=c:d=c.firstEffect;if(null!==d){e=X;X|=32;pj.current=null;kf=fd;g=Ne();if(Oe(g)){if("selectionStart"in g)h={start:g.selectionStart,end:g.selectionEnd};else a:if(h=(h=g.ownerDocument)&&h.defaultView||window,(l=h.getSelection&&h.getSelection())&&0!==l.rangeCount){h=l.anchorNode;f=l.anchorOffset;k=l.focusNode;l=l.focusOffset;try{h.nodeType,k.nodeType}catch(va){h=null;\nbreak a}var n=0,A=-1,p=-1,C=0,x=0,w=g,z=null;b:for(;;){for(var u;;){w!==h||0!==f&&3!==w.nodeType||(A=n+f);w!==k||0!==l&&3!==w.nodeType||(p=n+l);3===w.nodeType&&(n+=w.nodeValue.length);if(null===(u=w.firstChild))break;z=w;w=u}for(;;){if(w===g)break b;z===h&&++C===f&&(A=n);z===k&&++x===l&&(p=n);if(null!==(u=w.nextSibling))break;w=z;z=w.parentNode}w=u}h=-1===A||-1===p?null:{start:A,end:p}}else h=null;h=h||{start:0,end:0}}else h=null;lf={focusedElem:g,selectionRange:h};fd=!1;Ij=null;Jj=!1;Z=d;do try{ek()}catch(va){if(null===\nZ)throw Error(y(330));Wi(Z,va);Z=Z.nextEffect}while(null!==Z);Ij=null;Z=d;do try{for(g=a;null!==Z;){var t=Z.flags;t&16&&pb(Z.stateNode,"");if(t&128){var q=Z.alternate;if(null!==q){var v=q.ref;null!==v&&("function"===typeof v?v(null):v.current=null)}}switch(t&1038){case 2:fj(Z);Z.flags&=-3;break;case 6:fj(Z);Z.flags&=-3;ij(Z.alternate,Z);break;case 1024:Z.flags&=-1025;break;case 1028:Z.flags&=-1025;ij(Z.alternate,Z);break;case 4:ij(Z.alternate,Z);break;case 8:h=Z;cj(g,h);var J=h.alternate;dj(h);null!==\nJ&&dj(J)}Z=Z.nextEffect}}catch(va){if(null===Z)throw Error(y(330));Wi(Z,va);Z=Z.nextEffect}while(null!==Z);v=lf;q=Ne();t=v.focusedElem;g=v.selectionRange;if(q!==t&&t&&t.ownerDocument&&Me(t.ownerDocument.documentElement,t)){null!==g&&Oe(t)&&(q=g.start,v=g.end,void 0===v&&(v=q),"selectionStart"in t?(t.selectionStart=q,t.selectionEnd=Math.min(v,t.value.length)):(v=(q=t.ownerDocument||document)&&q.defaultView||window,v.getSelection&&(v=v.getSelection(),h=t.textContent.length,J=Math.min(g.start,h),g=void 0===\ng.end?J:Math.min(g.end,h),!v.extend&&J>g&&(h=g,g=J,J=h),h=Le(t,J),f=Le(t,g),h&&f&&(1!==v.rangeCount||v.anchorNode!==h.node||v.anchorOffset!==h.offset||v.focusNode!==f.node||v.focusOffset!==f.offset)&&(q=q.createRange(),q.setStart(h.node,h.offset),v.removeAllRanges(),J>g?(v.addRange(q),v.extend(f.node,f.offset)):(q.setEnd(f.node,f.offset),v.addRange(q))))));q=[];for(v=t;v=v.parentNode;)1===v.nodeType&&q.push({element:v,left:v.scrollLeft,top:v.scrollTop});"function"===typeof t.focus&&t.focus();for(t=\n0;t<q.length;t++)v=q[t],v.element.scrollLeft=v.left,v.element.scrollTop=v.top}fd=!!kf;lf=kf=null;a.current=c;Z=d;do try{for(t=a;null!==Z;){var K=Z.flags;K&36&&Yi(t,Z.alternate,Z);if(K&128){q=void 0;var Q=Z.ref;if(null!==Q){var L=Z.stateNode;switch(Z.tag){case 5:q=L;break;default:q=L}"function"===typeof Q?Q(q):Q.current=q}}Z=Z.nextEffect}}catch(va){if(null===Z)throw Error(y(330));Wi(Z,va);Z=Z.nextEffect}while(null!==Z);Z=null;$f();X=e}else a.current=c;if(xj)xj=!1,yj=a,zj=b;else for(Z=d;null!==Z;)b=\nZ.nextEffect,Z.nextEffect=null,Z.flags&8&&(K=Z,K.sibling=null,K.stateNode=null),Z=b;d=a.pendingLanes;0===d&&(Ti=null);1===d?a===Ej?Dj++:(Dj=0,Ej=a):Dj=0;c=c.stateNode;if(Mf&&"function"===typeof Mf.onCommitFiberRoot)try{Mf.onCommitFiberRoot(Lf,c,void 0,64===(c.current.flags&64))}catch(va){}Mj(a,O());if(Qi)throw Qi=!1,a=Ri,Ri=null,a;if(0!==(X&8))return null;ig();return null}\nfunction ek(){for(;null!==Z;){var a=Z.alternate;Jj||null===Ij||(0!==(Z.flags&8)?dc(Z,Ij)&&(Jj=!0):13===Z.tag&&mj(a,Z)&&dc(Z,Ij)&&(Jj=!0));var b=Z.flags;0!==(b&256)&&Xi(a,Z);0===(b&512)||xj||(xj=!0,hg(97,function(){Oj();return null}));Z=Z.nextEffect}}function Oj(){if(90!==zj){var a=97<zj?97:zj;zj=90;return gg(a,fk)}return!1}function $i(a,b){Aj.push(b,a);xj||(xj=!0,hg(97,function(){Oj();return null}))}function Zi(a,b){Bj.push(b,a);xj||(xj=!0,hg(97,function(){Oj();return null}))}\nfunction fk(){if(null===yj)return!1;var a=yj;yj=null;if(0!==(X&48))throw Error(y(331));var b=X;X|=32;var c=Bj;Bj=[];for(var d=0;d<c.length;d+=2){var e=c[d],f=c[d+1],g=e.destroy;e.destroy=void 0;if("function"===typeof g)try{g()}catch(k){if(null===f)throw Error(y(330));Wi(f,k)}}c=Aj;Aj=[];for(d=0;d<c.length;d+=2){e=c[d];f=c[d+1];try{var h=e.create;e.destroy=h()}catch(k){if(null===f)throw Error(y(330));Wi(f,k)}}for(h=a.current.firstEffect;null!==h;)a=h.nextEffect,h.nextEffect=null,h.flags&8&&(h.sibling=\nnull,h.stateNode=null),h=a;X=b;ig();return!0}function gk(a,b,c){b=Mi(c,b);b=Pi(a,b,1);Ag(a,b);b=Hg();a=Kj(a,1);null!==a&&($c(a,1,b),Mj(a,b))}\nfunction Wi(a,b){if(3===a.tag)gk(a,a,b);else for(var c=a.return;null!==c;){if(3===c.tag){gk(c,a,b);break}else if(1===c.tag){var d=c.stateNode;if("function"===typeof c.type.getDerivedStateFromError||"function"===typeof d.componentDidCatch&&(null===Ti||!Ti.has(d))){a=Mi(b,a);var e=Si(c,a,1);Ag(c,e);e=Hg();c=Kj(c,1);if(null!==c)$c(c,1,e),Mj(c,e);else if("function"===typeof d.componentDidCatch&&(null===Ti||!Ti.has(d)))try{d.componentDidCatch(b,a)}catch(f){}break}}c=c.return}}\nfunction Yj(a,b,c){var d=a.pingCache;null!==d&&d.delete(b);b=Hg();a.pingedLanes|=a.suspendedLanes&c;U===a&&(W&c)===c&&(4===V||3===V&&(W&62914560)===W&&500>O()-jj?Qj(a,0):uj|=c);Mj(a,b)}function lj(a,b){var c=a.stateNode;null!==c&&c.delete(b);b=0;0===b&&(b=a.mode,0===(b&2)?b=1:0===(b&4)?b=99===eg()?1:2:(0===Gj&&(Gj=tj),b=Yc(62914560&~Gj),0===b&&(b=4194304)));c=Hg();a=Kj(a,b);null!==a&&($c(a,b,c),Mj(a,c))}var ck;\nck=function(a,b,c){var d=b.lanes;if(null!==a)if(a.memoizedProps!==b.pendingProps||N.current)ug=!0;else if(0!==(c&d))ug=0!==(a.flags&16384)?!0:!1;else{ug=!1;switch(b.tag){case 3:ri(b);sh();break;case 5:gh(b);break;case 1:Ff(b.type)&&Jf(b);break;case 4:eh(b,b.stateNode.containerInfo);break;case 10:d=b.memoizedProps.value;var e=b.type._context;I(mg,e._currentValue);e._currentValue=d;break;case 13:if(null!==b.memoizedState){if(0!==(c&b.child.childLanes))return ti(a,b,c);I(P,P.current&1);b=hi(a,b,c);return null!==\nb?b.sibling:null}I(P,P.current&1);break;case 19:d=0!==(c&b.childLanes);if(0!==(a.flags&64)){if(d)return Ai(a,b,c);b.flags|=64}e=b.memoizedState;null!==e&&(e.rendering=null,e.tail=null,e.lastEffect=null);I(P,P.current);if(d)break;else return null;case 23:case 24:return b.lanes=0,mi(a,b,c)}return hi(a,b,c)}else ug=!1;b.lanes=0;switch(b.tag){case 2:d=b.type;null!==a&&(a.alternate=null,b.alternate=null,b.flags|=2);a=b.pendingProps;e=Ef(b,M.current);tg(b,c);e=Ch(null,b,d,a,e,c);b.flags|=1;if("object"===\ntypeof e&&null!==e&&"function"===typeof e.render&&void 0===e.$$typeof){b.tag=1;b.memoizedState=null;b.updateQueue=null;if(Ff(d)){var f=!0;Jf(b)}else f=!1;b.memoizedState=null!==e.state&&void 0!==e.state?e.state:null;xg(b);var g=d.getDerivedStateFromProps;"function"===typeof g&&Gg(b,d,g,a);e.updater=Kg;b.stateNode=e;e._reactInternals=b;Og(b,d,a,c);b=qi(null,b,d,!0,f,c)}else b.tag=0,fi(null,b,e,c),b=b.child;return b;case 16:e=b.elementType;a:{null!==a&&(a.alternate=null,b.alternate=null,b.flags|=2);\na=b.pendingProps;f=e._init;e=f(e._payload);b.type=e;f=b.tag=hk(e);a=lg(e,a);switch(f){case 0:b=li(null,b,e,a,c);break a;case 1:b=pi(null,b,e,a,c);break a;case 11:b=gi(null,b,e,a,c);break a;case 14:b=ii(null,b,e,lg(e.type,a),d,c);break a}throw Error(y(306,e,""));}return b;case 0:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:lg(d,e),li(a,b,d,e,c);case 1:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:lg(d,e),pi(a,b,d,e,c);case 3:ri(b);d=b.updateQueue;if(null===a||null===d)throw Error(y(282));\nd=b.pendingProps;e=b.memoizedState;e=null!==e?e.element:null;yg(a,b);Cg(b,d,null,c);d=b.memoizedState.element;if(d===e)sh(),b=hi(a,b,c);else{e=b.stateNode;if(f=e.hydrate)kh=rf(b.stateNode.containerInfo.firstChild),jh=b,f=lh=!0;if(f){a=e.mutableSourceEagerHydrationData;if(null!=a)for(e=0;e<a.length;e+=2)f=a[e],f._workInProgressVersionPrimary=a[e+1],th.push(f);c=Zg(b,null,d,c);for(b.child=c;c;)c.flags=c.flags&-3|1024,c=c.sibling}else fi(a,b,d,c),sh();b=b.child}return b;case 5:return gh(b),null===a&&\nph(b),d=b.type,e=b.pendingProps,f=null!==a?a.memoizedProps:null,g=e.children,nf(d,e)?g=null:null!==f&&nf(d,f)&&(b.flags|=16),oi(a,b),fi(a,b,g,c),b.child;case 6:return null===a&&ph(b),null;case 13:return ti(a,b,c);case 4:return eh(b,b.stateNode.containerInfo),d=b.pendingProps,null===a?b.child=Yg(b,null,d,c):fi(a,b,d,c),b.child;case 11:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:lg(d,e),gi(a,b,d,e,c);case 7:return fi(a,b,b.pendingProps,c),b.child;case 8:return fi(a,b,b.pendingProps.children,\nc),b.child;case 12:return fi(a,b,b.pendingProps.children,c),b.child;case 10:a:{d=b.type._context;e=b.pendingProps;g=b.memoizedProps;f=e.value;var h=b.type._context;I(mg,h._currentValue);h._currentValue=f;if(null!==g)if(h=g.value,f=He(h,f)?0:("function"===typeof d._calculateChangedBits?d._calculateChangedBits(h,f):1073741823)|0,0===f){if(g.children===e.children&&!N.current){b=hi(a,b,c);break a}}else for(h=b.child,null!==h&&(h.return=b);null!==h;){var k=h.dependencies;if(null!==k){g=h.child;for(var l=\nk.firstContext;null!==l;){if(l.context===d&&0!==(l.observedBits&f)){1===h.tag&&(l=zg(-1,c&-c),l.tag=2,Ag(h,l));h.lanes|=c;l=h.alternate;null!==l&&(l.lanes|=c);sg(h.return,c);k.lanes|=c;break}l=l.next}}else g=10===h.tag?h.type===b.type?null:h.child:h.child;if(null!==g)g.return=h;else for(g=h;null!==g;){if(g===b){g=null;break}h=g.sibling;if(null!==h){h.return=g.return;g=h;break}g=g.return}h=g}fi(a,b,e.children,c);b=b.child}return b;case 9:return e=b.type,f=b.pendingProps,d=f.children,tg(b,c),e=vg(e,\nf.unstable_observedBits),d=d(e),b.flags|=1,fi(a,b,d,c),b.child;case 14:return e=b.type,f=lg(e,b.pendingProps),f=lg(e.type,f),ii(a,b,e,f,d,c);case 15:return ki(a,b,b.type,b.pendingProps,d,c);case 17:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:lg(d,e),null!==a&&(a.alternate=null,b.alternate=null,b.flags|=2),b.tag=1,Ff(d)?(a=!0,Jf(b)):a=!1,tg(b,c),Mg(b,d,e),Og(b,d,e,c),qi(null,b,d,!0,a,c);case 19:return Ai(a,b,c);case 23:return mi(a,b,c);case 24:return mi(a,b,c)}throw Error(y(156,b.tag));\n};function ik(a,b,c,d){this.tag=a;this.key=c;this.sibling=this.child=this.return=this.stateNode=this.type=this.elementType=null;this.index=0;this.ref=null;this.pendingProps=b;this.dependencies=this.memoizedState=this.updateQueue=this.memoizedProps=null;this.mode=d;this.flags=0;this.lastEffect=this.firstEffect=this.nextEffect=null;this.childLanes=this.lanes=0;this.alternate=null}function nh(a,b,c,d){return new ik(a,b,c,d)}function ji(a){a=a.prototype;return!(!a||!a.isReactComponent)}\nfunction hk(a){if("function"===typeof a)return ji(a)?1:0;if(void 0!==a&&null!==a){a=a.$$typeof;if(a===Aa)return 11;if(a===Da)return 14}return 2}\nfunction Tg(a,b){var c=a.alternate;null===c?(c=nh(a.tag,b,a.key,a.mode),c.elementType=a.elementType,c.type=a.type,c.stateNode=a.stateNode,c.alternate=a,a.alternate=c):(c.pendingProps=b,c.type=a.type,c.flags=0,c.nextEffect=null,c.firstEffect=null,c.lastEffect=null);c.childLanes=a.childLanes;c.lanes=a.lanes;c.child=a.child;c.memoizedProps=a.memoizedProps;c.memoizedState=a.memoizedState;c.updateQueue=a.updateQueue;b=a.dependencies;c.dependencies=null===b?null:{lanes:b.lanes,firstContext:b.firstContext};\nc.sibling=a.sibling;c.index=a.index;c.ref=a.ref;return c}\nfunction Vg(a,b,c,d,e,f){var g=2;d=a;if("function"===typeof a)ji(a)&&(g=1);else if("string"===typeof a)g=5;else a:switch(a){case ua:return Xg(c.children,e,f,b);case Ha:g=8;e|=16;break;case wa:g=8;e|=1;break;case xa:return a=nh(12,c,b,e|8),a.elementType=xa,a.type=xa,a.lanes=f,a;case Ba:return a=nh(13,c,b,e),a.type=Ba,a.elementType=Ba,a.lanes=f,a;case Ca:return a=nh(19,c,b,e),a.elementType=Ca,a.lanes=f,a;case Ia:return vi(c,e,f,b);case Ja:return a=nh(24,c,b,e),a.elementType=Ja,a.lanes=f,a;default:if("object"===\ntypeof a&&null!==a)switch(a.$$typeof){case ya:g=10;break a;case za:g=9;break a;case Aa:g=11;break a;case Da:g=14;break a;case Ea:g=16;d=null;break a;case Fa:g=22;break a}throw Error(y(130,null==a?a:typeof a,""));}b=nh(g,c,b,e);b.elementType=a;b.type=d;b.lanes=f;return b}function Xg(a,b,c,d){a=nh(7,a,d,b);a.lanes=c;return a}function vi(a,b,c,d){a=nh(23,a,d,b);a.elementType=Ia;a.lanes=c;return a}function Ug(a,b,c){a=nh(6,a,null,b);a.lanes=c;return a}\nfunction Wg(a,b,c){b=nh(4,null!==a.children?a.children:[],a.key,b);b.lanes=c;b.stateNode={containerInfo:a.containerInfo,pendingChildren:null,implementation:a.implementation};return b}\nfunction jk(a,b,c){this.tag=b;this.containerInfo=a;this.finishedWork=this.pingCache=this.current=this.pendingChildren=null;this.timeoutHandle=-1;this.pendingContext=this.context=null;this.hydrate=c;this.callbackNode=null;this.callbackPriority=0;this.eventTimes=Zc(0);this.expirationTimes=Zc(-1);this.entangledLanes=this.finishedLanes=this.mutableReadLanes=this.expiredLanes=this.pingedLanes=this.suspendedLanes=this.pendingLanes=0;this.entanglements=Zc(0);this.mutableSourceEagerHydrationData=null}\nfunction kk(a,b,c){var d=3<arguments.length&&void 0!==arguments[3]?arguments[3]:null;return{$$typeof:ta,key:null==d?null:""+d,children:a,containerInfo:b,implementation:c}}\nfunction lk(a,b,c,d){var e=b.current,f=Hg(),g=Ig(e);a:if(c){c=c._reactInternals;b:{if(Zb(c)!==c||1!==c.tag)throw Error(y(170));var h=c;do{switch(h.tag){case 3:h=h.stateNode.context;break b;case 1:if(Ff(h.type)){h=h.stateNode.__reactInternalMemoizedMergedChildContext;break b}}h=h.return}while(null!==h);throw Error(y(171));}if(1===c.tag){var k=c.type;if(Ff(k)){c=If(c,k,h);break a}}c=h}else c=Cf;null===b.context?b.context=c:b.pendingContext=c;b=zg(f,g);b.payload={element:a};d=void 0===d?null:d;null!==\nd&&(b.callback=d);Ag(e,b);Jg(e,g,f);return g}function mk(a){a=a.current;if(!a.child)return null;switch(a.child.tag){case 5:return a.child.stateNode;default:return a.child.stateNode}}function nk(a,b){a=a.memoizedState;if(null!==a&&null!==a.dehydrated){var c=a.retryLane;a.retryLane=0!==c&&c<b?c:b}}function ok(a,b){nk(a,b);(a=a.alternate)&&nk(a,b)}function pk(){return null}\nfunction qk(a,b,c){var d=null!=c&&null!=c.hydrationOptions&&c.hydrationOptions.mutableSources||null;c=new jk(a,b,null!=c&&!0===c.hydrate);b=nh(3,null,null,2===b?7:1===b?3:0);c.current=b;b.stateNode=c;xg(b);a[ff]=c.current;cf(8===a.nodeType?a.parentNode:a);if(d)for(a=0;a<d.length;a++){b=d[a];var e=b._getVersion;e=e(b._source);null==c.mutableSourceEagerHydrationData?c.mutableSourceEagerHydrationData=[b,e]:c.mutableSourceEagerHydrationData.push(b,e)}this._internalRoot=c}\nqk.prototype.render=function(a){lk(a,this._internalRoot,null,null)};qk.prototype.unmount=function(){var a=this._internalRoot,b=a.containerInfo;lk(null,a,null,function(){b[ff]=null})};function rk(a){return!(!a||1!==a.nodeType&&9!==a.nodeType&&11!==a.nodeType&&(8!==a.nodeType||" react-mount-point-unstable "!==a.nodeValue))}\nfunction sk(a,b){b||(b=a?9===a.nodeType?a.documentElement:a.firstChild:null,b=!(!b||1!==b.nodeType||!b.hasAttribute("data-reactroot")));if(!b)for(var c;c=a.lastChild;)a.removeChild(c);return new qk(a,0,b?{hydrate:!0}:void 0)}\nfunction tk(a,b,c,d,e){var f=c._reactRootContainer;if(f){var g=f._internalRoot;if("function"===typeof e){var h=e;e=function(){var a=mk(g);h.call(a)}}lk(b,g,a,e)}else{f=c._reactRootContainer=sk(c,d);g=f._internalRoot;if("function"===typeof e){var k=e;e=function(){var a=mk(g);k.call(a)}}Xj(function(){lk(b,g,a,e)})}return mk(g)}ec=function(a){if(13===a.tag){var b=Hg();Jg(a,4,b);ok(a,4)}};fc=function(a){if(13===a.tag){var b=Hg();Jg(a,67108864,b);ok(a,67108864)}};\ngc=function(a){if(13===a.tag){var b=Hg(),c=Ig(a);Jg(a,c,b);ok(a,c)}};hc=function(a,b){return b()};\nyb=function(a,b,c){switch(b){case "input":ab(a,c);b=c.name;if("radio"===c.type&&null!=b){for(c=a;c.parentNode;)c=c.parentNode;c=c.querySelectorAll("input[name="+JSON.stringify(""+b)+\'][type="radio"]\');for(b=0;b<c.length;b++){var d=c[b];if(d!==a&&d.form===a.form){var e=Db(d);if(!e)throw Error(y(90));Wa(d);ab(d,e)}}}break;case "textarea":ib(a,c);break;case "select":b=c.value,null!=b&&fb(a,!!c.multiple,b,!1)}};Gb=Wj;\nHb=function(a,b,c,d,e){var f=X;X|=4;try{return gg(98,a.bind(null,b,c,d,e))}finally{X=f,0===X&&(wj(),ig())}};Ib=function(){0===(X&49)&&(Vj(),Oj())};Jb=function(a,b){var c=X;X|=2;try{return a(b)}finally{X=c,0===X&&(wj(),ig())}};function uk(a,b){var c=2<arguments.length&&void 0!==arguments[2]?arguments[2]:null;if(!rk(b))throw Error(y(200));return kk(a,b,null,c)}var vk={Events:[Cb,ue,Db,Eb,Fb,Oj,{current:!1}]},wk={findFiberByHostInstance:wc,bundleType:0,version:"17.0.2",rendererPackageName:"react-dom"};\nvar xk={bundleType:wk.bundleType,version:wk.version,rendererPackageName:wk.rendererPackageName,rendererConfig:wk.rendererConfig,overrideHookState:null,overrideHookStateDeletePath:null,overrideHookStateRenamePath:null,overrideProps:null,overridePropsDeletePath:null,overridePropsRenamePath:null,setSuspenseHandler:null,scheduleUpdate:null,currentDispatcherRef:ra.ReactCurrentDispatcher,findHostInstanceByFiber:function(a){a=cc(a);return null===a?null:a.stateNode},findFiberByHostInstance:wk.findFiberByHostInstance||\npk,findHostInstancesForRefresh:null,scheduleRefresh:null,scheduleRoot:null,setRefreshHandler:null,getCurrentFiber:null};if("undefined"!==typeof __REACT_DEVTOOLS_GLOBAL_HOOK__){var yk=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(!yk.isDisabled&&yk.supportsFiber)try{Lf=yk.inject(xk),Mf=yk}catch(a){}}exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=vk;exports.createPortal=uk;\nexports.findDOMNode=function(a){if(null==a)return null;if(1===a.nodeType)return a;var b=a._reactInternals;if(void 0===b){if("function"===typeof a.render)throw Error(y(188));throw Error(y(268,Object.keys(a)));}a=cc(b);a=null===a?null:a.stateNode;return a};exports.flushSync=function(a,b){var c=X;if(0!==(c&48))return a(b);X|=1;try{if(a)return gg(99,a.bind(null,b))}finally{X=c,ig()}};exports.hydrate=function(a,b,c){if(!rk(b))throw Error(y(200));return tk(null,a,b,!0,c)};\nexports.render=function(a,b,c){if(!rk(b))throw Error(y(200));return tk(null,a,b,!1,c)};exports.unmountComponentAtNode=function(a){if(!rk(a))throw Error(y(40));return a._reactRootContainer?(Xj(function(){tk(null,null,a,!1,function(){a._reactRootContainer=null;a[ff]=null})}),!0):!1};exports.unstable_batchedUpdates=Wj;exports.unstable_createPortal=function(a,b){return uk(a,b,2<arguments.length&&void 0!==arguments[2]?arguments[2]:null)};\nexports.unstable_renderSubtreeIntoContainer=function(a,b,c,d){if(!rk(c))throw Error(y(200));if(null==a||void 0===a._reactInternals)throw Error(y(38));return tk(a,b,c,!1,d)};exports.version="17.0.2";\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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cy9yZWFjdC1kb20vY2pzL3JlYWN0LWRvbS5wcm9kdWN0aW9uLm1pbi5qcz9jYTVkIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKiBAbGljZW5zZSBSZWFjdCB2MTcuMC4yXG4gKiByZWFjdC1kb20ucHJvZHVjdGlvbi5taW4uanNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuLypcbiBNb2Rlcm5penIgMy4wLjBwcmUgKEN1c3RvbSBCdWlsZCkgfCBNSVRcbiovXG4ndXNlIHN0cmljdCc7dmFyIGFhPXJlcXVpcmUoXCJyZWFjdFwiKSxtPXJlcXVpcmUoXCJvYmplY3QtYXNzaWduXCIpLHI9cmVxdWlyZShcInNjaGVkdWxlclwiKTtmdW5jdGlvbiB5KGEpe2Zvcih2YXIgYj1cImh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9lcnJvci1kZWNvZGVyLmh0bWw/aW52YXJpYW50PVwiK2EsYz0xO2M8YXJndW1lbnRzLmxlbmd0aDtjKyspYis9XCImYXJnc1tdPVwiK2VuY29kZVVSSUNvbXBvbmVudChhcmd1bWVudHNbY10pO3JldHVyblwiTWluaWZpZWQgUmVhY3QgZXJyb3IgI1wiK2ErXCI7IHZpc2l0IFwiK2IrXCIgZm9yIHRoZSBmdWxsIG1lc3NhZ2Ugb3IgdXNlIHRoZSBub24tbWluaWZpZWQgZGV2IGVudmlyb25tZW50IGZvciBmdWxsIGVycm9ycyBhbmQgYWRkaXRpb25hbCBoZWxwZnVsIHdhcm5pbmdzLlwifWlmKCFhYSl0aHJvdyBFcnJvcih5KDIyNykpO3ZhciBiYT1uZXcgU2V0LGNhPXt9O2Z1bmN0aW9uIGRhKGEsYil7ZWEoYSxiKTtlYShhK1wiQ2FwdHVyZVwiLGIpfVxuZnVuY3Rpb24gZWEoYSxiKXtjYVthXT1iO2ZvcihhPTA7YTxiLmxlbmd0aDthKyspYmEuYWRkKGJbYV0pfVxudmFyIGZhPSEoXCJ1bmRlZmluZWRcIj09PXR5cGVvZiB3aW5kb3d8fFwidW5kZWZpbmVkXCI9PT10eXBlb2Ygd2luZG93LmRvY3VtZW50fHxcInVuZGVmaW5lZFwiPT09dHlwZW9mIHdpbmRvdy5kb2N1bWVudC5jcmVhdGVFbGVtZW50KSxoYT0vXls6QS1aX2EtelxcdTAwQzAtXFx1MDBENlxcdTAwRDgtXFx1MDBGNlxcdTAwRjgtXFx1MDJGRlxcdTAzNzAtXFx1MDM3RFxcdTAzN0YtXFx1MUZGRlxcdTIwMEMtXFx1MjAwRFxcdTIwNzAtXFx1MjE4RlxcdTJDMDAtXFx1MkZFRlxcdTMwMDEtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZGRF1bOkEtWl9hLXpcXHUwMEMwLVxcdTAwRDZcXHUwMEQ4LVxcdTAwRjZcXHUwMEY4LVxcdTAyRkZcXHUwMzcwLVxcdTAzN0RcXHUwMzdGLVxcdTFGRkZcXHUyMDBDLVxcdTIwMERcXHUyMDcwLVxcdTIxOEZcXHUyQzAwLVxcdTJGRUZcXHUzMDAxLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRkRcXC0uMC05XFx1MDBCN1xcdTAzMDAtXFx1MDM2RlxcdTIwM0YtXFx1MjA0MF0qJC8saWE9T2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSxcbmphPXt9LGthPXt9O2Z1bmN0aW9uIGxhKGEpe2lmKGlhLmNhbGwoa2EsYSkpcmV0dXJuITA7aWYoaWEuY2FsbChqYSxhKSlyZXR1cm4hMTtpZihoYS50ZXN0KGEpKXJldHVybiBrYVthXT0hMDtqYVthXT0hMDtyZXR1cm4hMX1mdW5jdGlvbiBtYShhLGIsYyxkKXtpZihudWxsIT09YyYmMD09PWMudHlwZSlyZXR1cm4hMTtzd2l0Y2godHlwZW9mIGIpe2Nhc2UgXCJmdW5jdGlvblwiOmNhc2UgXCJzeW1ib2xcIjpyZXR1cm4hMDtjYXNlIFwiYm9vbGVhblwiOmlmKGQpcmV0dXJuITE7aWYobnVsbCE9PWMpcmV0dXJuIWMuYWNjZXB0c0Jvb2xlYW5zO2E9YS50b0xvd2VyQ2FzZSgpLnNsaWNlKDAsNSk7cmV0dXJuXCJkYXRhLVwiIT09YSYmXCJhcmlhLVwiIT09YTtkZWZhdWx0OnJldHVybiExfX1cbmZ1bmN0aW9uIG5hKGEsYixjLGQpe2lmKG51bGw9PT1ifHxcInVuZGVmaW5lZFwiPT09dHlwZW9mIGJ8fG1hKGEsYixjLGQpKXJldHVybiEwO2lmKGQpcmV0dXJuITE7aWYobnVsbCE9PWMpc3dpdGNoKGMudHlwZSl7Y2FzZSAzOnJldHVybiFiO2Nhc2UgNDpyZXR1cm4hMT09PWI7Y2FzZSA1OnJldHVybiBpc05hTihiKTtjYXNlIDY6cmV0dXJuIGlzTmFOKGIpfHwxPmJ9cmV0dXJuITF9ZnVuY3Rpb24gQihhLGIsYyxkLGUsZixnKXt0aGlzLmFjY2VwdHNCb29sZWFucz0yPT09Ynx8Mz09PWJ8fDQ9PT1iO3RoaXMuYXR0cmlidXRlTmFtZT1kO3RoaXMuYXR0cmlidXRlTmFtZXNwYWNlPWU7dGhpcy5tdXN0VXNlUHJvcGVydHk9Yzt0aGlzLnByb3BlcnR5TmFtZT1hO3RoaXMudHlwZT1iO3RoaXMuc2FuaXRpemVVUkw9Zjt0aGlzLnJlbW92ZUVtcHR5U3RyaW5nPWd9dmFyIEQ9e307XG5cImNoaWxkcmVuIGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MIGRlZmF1bHRWYWx1ZSBkZWZhdWx0Q2hlY2tlZCBpbm5lckhUTUwgc3VwcHJlc3NDb250ZW50RWRpdGFibGVXYXJuaW5nIHN1cHByZXNzSHlkcmF0aW9uV2FybmluZyBzdHlsZVwiLnNwbGl0KFwiIFwiKS5mb3JFYWNoKGZ1bmN0aW9uKGEpe0RbYV09bmV3IEIoYSwwLCExLGEsbnVsbCwhMSwhMSl9KTtbW1wiYWNjZXB0Q2hhcnNldFwiLFwiYWNjZXB0LWNoYXJzZXRcIl0sW1wiY2xhc3NOYW1lXCIsXCJjbGFzc1wiXSxbXCJodG1sRm9yXCIsXCJmb3JcIl0sW1wiaHR0cEVxdWl2XCIsXCJodHRwLWVxdWl2XCJdXS5mb3JFYWNoKGZ1bmN0aW9uKGEpe3ZhciBiPWFbMF07RFtiXT1uZXcgQihiLDEsITEsYVsxXSxudWxsLCExLCExKX0pO1tcImNvbnRlbnRFZGl0YWJsZVwiLFwiZHJhZ2dhYmxlXCIsXCJzcGVsbENoZWNrXCIsXCJ2YWx1ZVwiXS5mb3JFYWNoKGZ1bmN0aW9uKGEpe0RbYV09bmV3IEIoYSwyLCExLGEudG9Mb3dlckNhc2UoKSxudWxsLCExLCExKX0pO1xuW1wiYXV0b1JldmVyc2VcIixcImV4dGVybmFsUmVzb3VyY2VzUmVxdWlyZWRcIixcImZvY3VzYWJsZVwiLFwicHJlc2VydmVBbHBoYVwiXS5mb3JFYWNoKGZ1bmN0aW9uKGEpe0RbYV09bmV3IEIoYSwyLCExLGEsbnVsbCwhMSwhMSl9KTtcImFsbG93RnVsbFNjcmVlbiBhc3luYyBhdXRvRm9jdXMgYXV0b1BsYXkgY29udHJvbHMgZGVmYXVsdCBkZWZlciBkaXNhYmxlZCBkaXNhYmxlUGljdHVyZUluUGljdHVyZSBkaXNhYmxlUmVtb3RlUGxheWJhY2sgZm9ybU5vVmFsaWRhdGUgaGlkZGVuIGxvb3Agbm9Nb2R1bGUgbm9WYWxpZGF0ZSBvcGVuIHBsYXlzSW5saW5lIHJlYWRPbmx5IHJlcXVpcmVkIHJldmVyc2VkIHNjb3BlZCBzZWFtbGVzcyBpdGVtU2NvcGVcIi5zcGxpdChcIiBcIikuZm9yRWFjaChmdW5jdGlvbihhKXtEW2FdPW5ldyBCKGEsMywhMSxhLnRvTG93ZXJDYXNlKCksbnVsbCwhMSwhMSl9KTtcbltcImNoZWNrZWRcIixcIm11bHRpcGxlXCIsXCJtdXRlZFwiLFwic2VsZWN0ZWRcIl0uZm9yRWFjaChmdW5jdGlvbihhKXtEW2FdPW5ldyBCKGEsMywhMCxhLG51bGwsITEsITEpfSk7W1wiY2FwdHVyZVwiLFwiZG93bmxvYWRcIl0uZm9yRWFjaChmdW5jdGlvbihhKXtEW2FdPW5ldyBCKGEsNCwhMSxhLG51bGwsITEsITEpfSk7W1wiY29sc1wiLFwicm93c1wiLFwic2l6ZVwiLFwic3BhblwiXS5mb3JFYWNoKGZ1bmN0aW9uKGEpe0RbYV09bmV3IEIoYSw2LCExLGEsbnVsbCwhMSwhMSl9KTtbXCJyb3dTcGFuXCIsXCJzdGFydFwiXS5mb3JFYWNoKGZ1bmN0aW9uKGEpe0RbYV09bmV3IEIoYSw1LCExLGEudG9Mb3dlckNhc2UoKSxudWxsLCExLCExKX0pO3ZhciBvYT0vW1xcLTpdKFthLXpdKS9nO2Z1bmN0aW9uIHBhKGEpe3JldHVybiBhWzFdLnRvVXBwZXJDYXNlKCl9XG5cImFjY2VudC1oZWlnaHQgYWxpZ25tZW50LWJhc2VsaW5lIGFyYWJpYy1mb3JtIGJhc2VsaW5lLXNoaWZ0IGNhcC1oZWlnaHQgY2xpcC1wYXRoIGNsaXAtcnVsZSBjb2xvci1pbnRlcnBvbGF0aW9uIGNvbG9yLWludGVycG9sYXRpb24tZmlsdGVycyBjb2xvci1wcm9maWxlIGNvbG9yLXJlbmRlcmluZyBkb21pbmFudC1iYXNlbGluZSBlbmFibGUtYmFja2dyb3VuZCBmaWxsLW9wYWNpdHkgZmlsbC1ydWxlIGZsb29kLWNvbG9yIGZsb29kLW9wYWNpdHkgZm9udC1mYW1pbHkgZm9udC1zaXplIGZvbnQtc2l6ZS1hZGp1c3QgZm9udC1zdHJldGNoIGZvbnQtc3R5bGUgZm9udC12YXJpYW50IGZvbnQtd2VpZ2h0IGdseXBoLW5hbWUgZ2x5cGgtb3JpZW50YXRpb24taG9yaXpvbnRhbCBnbHlwaC1vcmllbnRhdGlvbi12ZXJ0aWNhbCBob3Jpei1hZHYteCBob3Jpei1vcmlnaW4teCBpbWFnZS1yZW5kZXJpbmcgbGV0dGVyLXNwYWNpbmcgbGlnaHRpbmctY29sb3IgbWFya2VyLWVuZCBtYXJrZXItbWlkIG1hcmtlci1zdGFydCBvdmVybGluZS1wb3NpdGlvbiBvdmVybGluZS10aGlja25lc3MgcGFpbnQtb3JkZXIgcGFub3NlLTEgcG9pbnRlci1ldmVudHMgcmVuZGVyaW5nLWludGVudCBzaGFwZS1yZW5kZXJpbmcgc3RvcC1jb2xvciBzdG9wLW9wYWNpdHkgc3RyaWtldGhyb3VnaC1wb3NpdGlvbiBzdHJpa2V0aHJvdWdoLXRoaWNrbmVzcyBzdHJva2UtZGFzaGFycmF5IHN0cm9rZS1kYXNob2Zmc2V0IHN0cm9rZS1saW5lY2FwIHN0cm9rZS1saW5lam9pbiBzdHJva2UtbWl0ZXJsaW1pdCBzdHJva2Utb3BhY2l0eSBzdHJva2Utd2lkdGggdGV4dC1hbmNob3IgdGV4dC1kZWNvcmF0aW9uIHRleHQtcmVuZGVyaW5nIHVuZGVybGluZS1wb3NpdGlvbiB1bmRlcmxpbmUtdGhpY2tuZXNzIHVuaWNvZGUtYmlkaSB1bmljb2RlLXJhbmdlIHVuaXRzLXBlci1lbSB2LWFscGhhYmV0aWMgdi1oYW5naW5nIHYtaWRlb2dyYXBoaWMgdi1tYXRoZW1hdGljYWwgdmVjdG9yLWVmZmVjdCB2ZXJ0LWFkdi15IHZlcnQtb3JpZ2luLXggdmVydC1vcmlnaW4teSB3b3JkLXNwYWNpbmcgd3JpdGluZy1tb2RlIHhtbG5zOnhsaW5rIHgtaGVpZ2h0XCIuc3BsaXQoXCIgXCIpLmZvckVhY2goZnVuY3Rpb24oYSl7dmFyIGI9YS5yZXBsYWNlKG9hLFxucGEpO0RbYl09bmV3IEIoYiwxLCExLGEsbnVsbCwhMSwhMSl9KTtcInhsaW5rOmFjdHVhdGUgeGxpbms6YXJjcm9sZSB4bGluazpyb2xlIHhsaW5rOnNob3cgeGxpbms6dGl0bGUgeGxpbms6dHlwZVwiLnNwbGl0KFwiIFwiKS5mb3JFYWNoKGZ1bmN0aW9uKGEpe3ZhciBiPWEucmVwbGFjZShvYSxwYSk7RFtiXT1uZXcgQihiLDEsITEsYSxcImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmtcIiwhMSwhMSl9KTtbXCJ4bWw6YmFzZVwiLFwieG1sOmxhbmdcIixcInhtbDpzcGFjZVwiXS5mb3JFYWNoKGZ1bmN0aW9uKGEpe3ZhciBiPWEucmVwbGFjZShvYSxwYSk7RFtiXT1uZXcgQihiLDEsITEsYSxcImh0dHA6Ly93d3cudzMub3JnL1hNTC8xOTk4L25hbWVzcGFjZVwiLCExLCExKX0pO1tcInRhYkluZGV4XCIsXCJjcm9zc09yaWdpblwiXS5mb3JFYWNoKGZ1bmN0aW9uKGEpe0RbYV09bmV3IEIoYSwxLCExLGEudG9Mb3dlckNhc2UoKSxudWxsLCExLCExKX0pO1xuRC54bGlua0hyZWY9bmV3IEIoXCJ4bGlua0hyZWZcIiwxLCExLFwieGxpbms6aHJlZlwiLFwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGlua1wiLCEwLCExKTtbXCJzcmNcIixcImhyZWZcIixcImFjdGlvblwiLFwiZm9ybUFjdGlvblwiXS5mb3JFYWNoKGZ1bmN0aW9uKGEpe0RbYV09bmV3IEIoYSwxLCExLGEudG9Mb3dlckNhc2UoKSxudWxsLCEwLCEwKX0pO1xuZnVuY3Rpb24gcWEoYSxiLGMsZCl7dmFyIGU9RC5oYXNPd25Qcm9wZXJ0eShiKT9EW2JdOm51bGw7dmFyIGY9bnVsbCE9PWU/MD09PWUudHlwZTpkPyExOiEoMjxiLmxlbmd0aCl8fFwib1wiIT09YlswXSYmXCJPXCIhPT1iWzBdfHxcIm5cIiE9PWJbMV0mJlwiTlwiIT09YlsxXT8hMTohMDtmfHwobmEoYixjLGUsZCkmJihjPW51bGwpLGR8fG51bGw9PT1lP2xhKGIpJiYobnVsbD09PWM/YS5yZW1vdmVBdHRyaWJ1dGUoYik6YS5zZXRBdHRyaWJ1dGUoYixcIlwiK2MpKTplLm11c3RVc2VQcm9wZXJ0eT9hW2UucHJvcGVydHlOYW1lXT1udWxsPT09Yz8zPT09ZS50eXBlPyExOlwiXCI6YzooYj1lLmF0dHJpYnV0ZU5hbWUsZD1lLmF0dHJpYnV0ZU5hbWVzcGFjZSxudWxsPT09Yz9hLnJlbW92ZUF0dHJpYnV0ZShiKTooZT1lLnR5cGUsYz0zPT09ZXx8ND09PWUmJiEwPT09Yz9cIlwiOlwiXCIrYyxkP2Euc2V0QXR0cmlidXRlTlMoZCxiLGMpOmEuc2V0QXR0cmlidXRlKGIsYykpKSl9XG52YXIgcmE9YWEuX19TRUNSRVRfSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfWU9VX1dJTExfQkVfRklSRUQsc2E9NjAxMDMsdGE9NjAxMDYsdWE9NjAxMDcsd2E9NjAxMDgseGE9NjAxMTQseWE9NjAxMDksemE9NjAxMTAsQWE9NjAxMTIsQmE9NjAxMTMsQ2E9NjAxMjAsRGE9NjAxMTUsRWE9NjAxMTYsRmE9NjAxMjEsR2E9NjAxMjgsSGE9NjAxMjksSWE9NjAxMzAsSmE9NjAxMzE7XG5pZihcImZ1bmN0aW9uXCI9PT10eXBlb2YgU3ltYm9sJiZTeW1ib2wuZm9yKXt2YXIgRT1TeW1ib2wuZm9yO3NhPUUoXCJyZWFjdC5lbGVtZW50XCIpO3RhPUUoXCJyZWFjdC5wb3J0YWxcIik7dWE9RShcInJlYWN0LmZyYWdtZW50XCIpO3dhPUUoXCJyZWFjdC5zdHJpY3RfbW9kZVwiKTt4YT1FKFwicmVhY3QucHJvZmlsZXJcIik7eWE9RShcInJlYWN0LnByb3ZpZGVyXCIpO3phPUUoXCJyZWFjdC5jb250ZXh0XCIpO0FhPUUoXCJyZWFjdC5mb3J3YXJkX3JlZlwiKTtCYT1FKFwicmVhY3Quc3VzcGVuc2VcIik7Q2E9RShcInJlYWN0LnN1c3BlbnNlX2xpc3RcIik7RGE9RShcInJlYWN0Lm1lbW9cIik7RWE9RShcInJlYWN0LmxhenlcIik7RmE9RShcInJlYWN0LmJsb2NrXCIpO0UoXCJyZWFjdC5zY29wZVwiKTtHYT1FKFwicmVhY3Qub3BhcXVlLmlkXCIpO0hhPUUoXCJyZWFjdC5kZWJ1Z190cmFjZV9tb2RlXCIpO0lhPUUoXCJyZWFjdC5vZmZzY3JlZW5cIik7SmE9RShcInJlYWN0LmxlZ2FjeV9oaWRkZW5cIil9XG52YXIgS2E9XCJmdW5jdGlvblwiPT09dHlwZW9mIFN5bWJvbCYmU3ltYm9sLml0ZXJhdG9yO2Z1bmN0aW9uIExhKGEpe2lmKG51bGw9PT1hfHxcIm9iamVjdFwiIT09dHlwZW9mIGEpcmV0dXJuIG51bGw7YT1LYSYmYVtLYV18fGFbXCJAQGl0ZXJhdG9yXCJdO3JldHVyblwiZnVuY3Rpb25cIj09PXR5cGVvZiBhP2E6bnVsbH12YXIgTWE7ZnVuY3Rpb24gTmEoYSl7aWYodm9pZCAwPT09TWEpdHJ5e3Rocm93IEVycm9yKCk7fWNhdGNoKGMpe3ZhciBiPWMuc3RhY2sudHJpbSgpLm1hdGNoKC9cXG4oICooYXQgKT8pLyk7TWE9YiYmYlsxXXx8XCJcIn1yZXR1cm5cIlxcblwiK01hK2F9dmFyIE9hPSExO1xuZnVuY3Rpb24gUGEoYSxiKXtpZighYXx8T2EpcmV0dXJuXCJcIjtPYT0hMDt2YXIgYz1FcnJvci5wcmVwYXJlU3RhY2tUcmFjZTtFcnJvci5wcmVwYXJlU3RhY2tUcmFjZT12b2lkIDA7dHJ5e2lmKGIpaWYoYj1mdW5jdGlvbigpe3Rocm93IEVycm9yKCk7fSxPYmplY3QuZGVmaW5lUHJvcGVydHkoYi5wcm90b3R5cGUsXCJwcm9wc1wiLHtzZXQ6ZnVuY3Rpb24oKXt0aHJvdyBFcnJvcigpO319KSxcIm9iamVjdFwiPT09dHlwZW9mIFJlZmxlY3QmJlJlZmxlY3QuY29uc3RydWN0KXt0cnl7UmVmbGVjdC5jb25zdHJ1Y3QoYixbXSl9Y2F0Y2goayl7dmFyIGQ9a31SZWZsZWN0LmNvbnN0cnVjdChhLFtdLGIpfWVsc2V7dHJ5e2IuY2FsbCgpfWNhdGNoKGspe2Q9a31hLmNhbGwoYi5wcm90b3R5cGUpfWVsc2V7dHJ5e3Rocm93IEVycm9yKCk7fWNhdGNoKGspe2Q9a31hKCl9fWNhdGNoKGspe2lmKGsmJmQmJlwic3RyaW5nXCI9PT10eXBlb2Ygay5zdGFjayl7Zm9yKHZhciBlPWsuc3RhY2suc3BsaXQoXCJcXG5cIiksXG5mPWQuc3RhY2suc3BsaXQoXCJcXG5cIiksZz1lLmxlbmd0aC0xLGg9Zi5sZW5ndGgtMTsxPD1nJiYwPD1oJiZlW2ddIT09ZltoXTspaC0tO2Zvcig7MTw9ZyYmMDw9aDtnLS0saC0tKWlmKGVbZ10hPT1mW2hdKXtpZigxIT09Z3x8MSE9PWgpe2RvIGlmKGctLSxoLS0sMD5ofHxlW2ddIT09ZltoXSlyZXR1cm5cIlxcblwiK2VbZ10ucmVwbGFjZShcIiBhdCBuZXcgXCIsXCIgYXQgXCIpO3doaWxlKDE8PWcmJjA8PWgpfWJyZWFrfX19ZmluYWxseXtPYT0hMSxFcnJvci5wcmVwYXJlU3RhY2tUcmFjZT1jfXJldHVybihhPWE/YS5kaXNwbGF5TmFtZXx8YS5uYW1lOlwiXCIpP05hKGEpOlwiXCJ9XG5mdW5jdGlvbiBRYShhKXtzd2l0Y2goYS50YWcpe2Nhc2UgNTpyZXR1cm4gTmEoYS50eXBlKTtjYXNlIDE2OnJldHVybiBOYShcIkxhenlcIik7Y2FzZSAxMzpyZXR1cm4gTmEoXCJTdXNwZW5zZVwiKTtjYXNlIDE5OnJldHVybiBOYShcIlN1c3BlbnNlTGlzdFwiKTtjYXNlIDA6Y2FzZSAyOmNhc2UgMTU6cmV0dXJuIGE9UGEoYS50eXBlLCExKSxhO2Nhc2UgMTE6cmV0dXJuIGE9UGEoYS50eXBlLnJlbmRlciwhMSksYTtjYXNlIDIyOnJldHVybiBhPVBhKGEudHlwZS5fcmVuZGVyLCExKSxhO2Nhc2UgMTpyZXR1cm4gYT1QYShhLnR5cGUsITApLGE7ZGVmYXVsdDpyZXR1cm5cIlwifX1cbmZ1bmN0aW9uIFJhKGEpe2lmKG51bGw9PWEpcmV0dXJuIG51bGw7aWYoXCJmdW5jdGlvblwiPT09dHlwZW9mIGEpcmV0dXJuIGEuZGlzcGxheU5hbWV8fGEubmFtZXx8bnVsbDtpZihcInN0cmluZ1wiPT09dHlwZW9mIGEpcmV0dXJuIGE7c3dpdGNoKGEpe2Nhc2UgdWE6cmV0dXJuXCJGcmFnbWVudFwiO2Nhc2UgdGE6cmV0dXJuXCJQb3J0YWxcIjtjYXNlIHhhOnJldHVyblwiUHJvZmlsZXJcIjtjYXNlIHdhOnJldHVyblwiU3RyaWN0TW9kZVwiO2Nhc2UgQmE6cmV0dXJuXCJTdXNwZW5zZVwiO2Nhc2UgQ2E6cmV0dXJuXCJTdXNwZW5zZUxpc3RcIn1pZihcIm9iamVjdFwiPT09dHlwZW9mIGEpc3dpdGNoKGEuJCR0eXBlb2Ype2Nhc2UgemE6cmV0dXJuKGEuZGlzcGxheU5hbWV8fFwiQ29udGV4dFwiKStcIi5Db25zdW1lclwiO2Nhc2UgeWE6cmV0dXJuKGEuX2NvbnRleHQuZGlzcGxheU5hbWV8fFwiQ29udGV4dFwiKStcIi5Qcm92aWRlclwiO2Nhc2UgQWE6dmFyIGI9YS5yZW5kZXI7Yj1iLmRpc3BsYXlOYW1lfHxiLm5hbWV8fFwiXCI7XG5yZXR1cm4gYS5kaXNwbGF5TmFtZXx8KFwiXCIhPT1iP1wiRm9yd2FyZFJlZihcIitiK1wiKVwiOlwiRm9yd2FyZFJlZlwiKTtjYXNlIERhOnJldHVybiBSYShhLnR5cGUpO2Nhc2UgRmE6cmV0dXJuIFJhKGEuX3JlbmRlcik7Y2FzZSBFYTpiPWEuX3BheWxvYWQ7YT1hLl9pbml0O3RyeXtyZXR1cm4gUmEoYShiKSl9Y2F0Y2goYyl7fX1yZXR1cm4gbnVsbH1mdW5jdGlvbiBTYShhKXtzd2l0Y2godHlwZW9mIGEpe2Nhc2UgXCJib29sZWFuXCI6Y2FzZSBcIm51bWJlclwiOmNhc2UgXCJvYmplY3RcIjpjYXNlIFwic3RyaW5nXCI6Y2FzZSBcInVuZGVmaW5lZFwiOnJldHVybiBhO2RlZmF1bHQ6cmV0dXJuXCJcIn19ZnVuY3Rpb24gVGEoYSl7dmFyIGI9YS50eXBlO3JldHVybihhPWEubm9kZU5hbWUpJiZcImlucHV0XCI9PT1hLnRvTG93ZXJDYXNlKCkmJihcImNoZWNrYm94XCI9PT1ifHxcInJhZGlvXCI9PT1iKX1cbmZ1bmN0aW9uIFVhKGEpe3ZhciBiPVRhKGEpP1wiY2hlY2tlZFwiOlwidmFsdWVcIixjPU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoYS5jb25zdHJ1Y3Rvci5wcm90b3R5cGUsYiksZD1cIlwiK2FbYl07aWYoIWEuaGFzT3duUHJvcGVydHkoYikmJlwidW5kZWZpbmVkXCIhPT10eXBlb2YgYyYmXCJmdW5jdGlvblwiPT09dHlwZW9mIGMuZ2V0JiZcImZ1bmN0aW9uXCI9PT10eXBlb2YgYy5zZXQpe3ZhciBlPWMuZ2V0LGY9Yy5zZXQ7T2JqZWN0LmRlZmluZVByb3BlcnR5KGEsYix7Y29uZmlndXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiBlLmNhbGwodGhpcyl9LHNldDpmdW5jdGlvbihhKXtkPVwiXCIrYTtmLmNhbGwodGhpcyxhKX19KTtPYmplY3QuZGVmaW5lUHJvcGVydHkoYSxiLHtlbnVtZXJhYmxlOmMuZW51bWVyYWJsZX0pO3JldHVybntnZXRWYWx1ZTpmdW5jdGlvbigpe3JldHVybiBkfSxzZXRWYWx1ZTpmdW5jdGlvbihhKXtkPVwiXCIrYX0sc3RvcFRyYWNraW5nOmZ1bmN0aW9uKCl7YS5fdmFsdWVUcmFja2VyPVxubnVsbDtkZWxldGUgYVtiXX19fX1mdW5jdGlvbiBWYShhKXthLl92YWx1ZVRyYWNrZXJ8fChhLl92YWx1ZVRyYWNrZXI9VWEoYSkpfWZ1bmN0aW9uIFdhKGEpe2lmKCFhKXJldHVybiExO3ZhciBiPWEuX3ZhbHVlVHJhY2tlcjtpZighYilyZXR1cm4hMDt2YXIgYz1iLmdldFZhbHVlKCk7dmFyIGQ9XCJcIjthJiYoZD1UYShhKT9hLmNoZWNrZWQ/XCJ0cnVlXCI6XCJmYWxzZVwiOmEudmFsdWUpO2E9ZDtyZXR1cm4gYSE9PWM/KGIuc2V0VmFsdWUoYSksITApOiExfWZ1bmN0aW9uIFhhKGEpe2E9YXx8KFwidW5kZWZpbmVkXCIhPT10eXBlb2YgZG9jdW1lbnQ/ZG9jdW1lbnQ6dm9pZCAwKTtpZihcInVuZGVmaW5lZFwiPT09dHlwZW9mIGEpcmV0dXJuIG51bGw7dHJ5e3JldHVybiBhLmFjdGl2ZUVsZW1lbnR8fGEuYm9keX1jYXRjaChiKXtyZXR1cm4gYS5ib2R5fX1cbmZ1bmN0aW9uIFlhKGEsYil7dmFyIGM9Yi5jaGVja2VkO3JldHVybiBtKHt9LGIse2RlZmF1bHRDaGVja2VkOnZvaWQgMCxkZWZhdWx0VmFsdWU6dm9pZCAwLHZhbHVlOnZvaWQgMCxjaGVja2VkOm51bGwhPWM/YzphLl93cmFwcGVyU3RhdGUuaW5pdGlhbENoZWNrZWR9KX1mdW5jdGlvbiBaYShhLGIpe3ZhciBjPW51bGw9PWIuZGVmYXVsdFZhbHVlP1wiXCI6Yi5kZWZhdWx0VmFsdWUsZD1udWxsIT1iLmNoZWNrZWQ/Yi5jaGVja2VkOmIuZGVmYXVsdENoZWNrZWQ7Yz1TYShudWxsIT1iLnZhbHVlP2IudmFsdWU6Yyk7YS5fd3JhcHBlclN0YXRlPXtpbml0aWFsQ2hlY2tlZDpkLGluaXRpYWxWYWx1ZTpjLGNvbnRyb2xsZWQ6XCJjaGVja2JveFwiPT09Yi50eXBlfHxcInJhZGlvXCI9PT1iLnR5cGU/bnVsbCE9Yi5jaGVja2VkOm51bGwhPWIudmFsdWV9fWZ1bmN0aW9uICRhKGEsYil7Yj1iLmNoZWNrZWQ7bnVsbCE9YiYmcWEoYSxcImNoZWNrZWRcIixiLCExKX1cbmZ1bmN0aW9uIGFiKGEsYil7JGEoYSxiKTt2YXIgYz1TYShiLnZhbHVlKSxkPWIudHlwZTtpZihudWxsIT1jKWlmKFwibnVtYmVyXCI9PT1kKXtpZigwPT09YyYmXCJcIj09PWEudmFsdWV8fGEudmFsdWUhPWMpYS52YWx1ZT1cIlwiK2N9ZWxzZSBhLnZhbHVlIT09XCJcIitjJiYoYS52YWx1ZT1cIlwiK2MpO2Vsc2UgaWYoXCJzdWJtaXRcIj09PWR8fFwicmVzZXRcIj09PWQpe2EucmVtb3ZlQXR0cmlidXRlKFwidmFsdWVcIik7cmV0dXJufWIuaGFzT3duUHJvcGVydHkoXCJ2YWx1ZVwiKT9iYihhLGIudHlwZSxjKTpiLmhhc093blByb3BlcnR5KFwiZGVmYXVsdFZhbHVlXCIpJiZiYihhLGIudHlwZSxTYShiLmRlZmF1bHRWYWx1ZSkpO251bGw9PWIuY2hlY2tlZCYmbnVsbCE9Yi5kZWZhdWx0Q2hlY2tlZCYmKGEuZGVmYXVsdENoZWNrZWQ9ISFiLmRlZmF1bHRDaGVja2VkKX1cbmZ1bmN0aW9uIGNiKGEsYixjKXtpZihiLmhhc093blByb3BlcnR5KFwidmFsdWVcIil8fGIuaGFzT3duUHJvcGVydHkoXCJkZWZhdWx0VmFsdWVcIikpe3ZhciBkPWIudHlwZTtpZighKFwic3VibWl0XCIhPT1kJiZcInJlc2V0XCIhPT1kfHx2b2lkIDAhPT1iLnZhbHVlJiZudWxsIT09Yi52YWx1ZSkpcmV0dXJuO2I9XCJcIithLl93cmFwcGVyU3RhdGUuaW5pdGlhbFZhbHVlO2N8fGI9PT1hLnZhbHVlfHwoYS52YWx1ZT1iKTthLmRlZmF1bHRWYWx1ZT1ifWM9YS5uYW1lO1wiXCIhPT1jJiYoYS5uYW1lPVwiXCIpO2EuZGVmYXVsdENoZWNrZWQ9ISFhLl93cmFwcGVyU3RhdGUuaW5pdGlhbENoZWNrZWQ7XCJcIiE9PWMmJihhLm5hbWU9Yyl9XG5mdW5jdGlvbiBiYihhLGIsYyl7aWYoXCJudW1iZXJcIiE9PWJ8fFhhKGEub3duZXJEb2N1bWVudCkhPT1hKW51bGw9PWM/YS5kZWZhdWx0VmFsdWU9XCJcIithLl93cmFwcGVyU3RhdGUuaW5pdGlhbFZhbHVlOmEuZGVmYXVsdFZhbHVlIT09XCJcIitjJiYoYS5kZWZhdWx0VmFsdWU9XCJcIitjKX1mdW5jdGlvbiBkYihhKXt2YXIgYj1cIlwiO2FhLkNoaWxkcmVuLmZvckVhY2goYSxmdW5jdGlvbihhKXtudWxsIT1hJiYoYis9YSl9KTtyZXR1cm4gYn1mdW5jdGlvbiBlYihhLGIpe2E9bSh7Y2hpbGRyZW46dm9pZCAwfSxiKTtpZihiPWRiKGIuY2hpbGRyZW4pKWEuY2hpbGRyZW49YjtyZXR1cm4gYX1cbmZ1bmN0aW9uIGZiKGEsYixjLGQpe2E9YS5vcHRpb25zO2lmKGIpe2I9e307Zm9yKHZhciBlPTA7ZTxjLmxlbmd0aDtlKyspYltcIiRcIitjW2VdXT0hMDtmb3IoYz0wO2M8YS5sZW5ndGg7YysrKWU9Yi5oYXNPd25Qcm9wZXJ0eShcIiRcIithW2NdLnZhbHVlKSxhW2NdLnNlbGVjdGVkIT09ZSYmKGFbY10uc2VsZWN0ZWQ9ZSksZSYmZCYmKGFbY10uZGVmYXVsdFNlbGVjdGVkPSEwKX1lbHNle2M9XCJcIitTYShjKTtiPW51bGw7Zm9yKGU9MDtlPGEubGVuZ3RoO2UrKyl7aWYoYVtlXS52YWx1ZT09PWMpe2FbZV0uc2VsZWN0ZWQ9ITA7ZCYmKGFbZV0uZGVmYXVsdFNlbGVjdGVkPSEwKTtyZXR1cm59bnVsbCE9PWJ8fGFbZV0uZGlzYWJsZWR8fChiPWFbZV0pfW51bGwhPT1iJiYoYi5zZWxlY3RlZD0hMCl9fVxuZnVuY3Rpb24gZ2IoYSxiKXtpZihudWxsIT1iLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MKXRocm93IEVycm9yKHkoOTEpKTtyZXR1cm4gbSh7fSxiLHt2YWx1ZTp2b2lkIDAsZGVmYXVsdFZhbHVlOnZvaWQgMCxjaGlsZHJlbjpcIlwiK2EuX3dyYXBwZXJTdGF0ZS5pbml0aWFsVmFsdWV9KX1mdW5jdGlvbiBoYihhLGIpe3ZhciBjPWIudmFsdWU7aWYobnVsbD09Yyl7Yz1iLmNoaWxkcmVuO2I9Yi5kZWZhdWx0VmFsdWU7aWYobnVsbCE9Yyl7aWYobnVsbCE9Yil0aHJvdyBFcnJvcih5KDkyKSk7aWYoQXJyYXkuaXNBcnJheShjKSl7aWYoISgxPj1jLmxlbmd0aCkpdGhyb3cgRXJyb3IoeSg5MykpO2M9Y1swXX1iPWN9bnVsbD09YiYmKGI9XCJcIik7Yz1ifWEuX3dyYXBwZXJTdGF0ZT17aW5pdGlhbFZhbHVlOlNhKGMpfX1cbmZ1bmN0aW9uIGliKGEsYil7dmFyIGM9U2EoYi52YWx1ZSksZD1TYShiLmRlZmF1bHRWYWx1ZSk7bnVsbCE9YyYmKGM9XCJcIitjLGMhPT1hLnZhbHVlJiYoYS52YWx1ZT1jKSxudWxsPT1iLmRlZmF1bHRWYWx1ZSYmYS5kZWZhdWx0VmFsdWUhPT1jJiYoYS5kZWZhdWx0VmFsdWU9YykpO251bGwhPWQmJihhLmRlZmF1bHRWYWx1ZT1cIlwiK2QpfWZ1bmN0aW9uIGpiKGEpe3ZhciBiPWEudGV4dENvbnRlbnQ7Yj09PWEuX3dyYXBwZXJTdGF0ZS5pbml0aWFsVmFsdWUmJlwiXCIhPT1iJiZudWxsIT09YiYmKGEudmFsdWU9Yil9dmFyIGtiPXtodG1sOlwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbFwiLG1hdGhtbDpcImh0dHA6Ly93d3cudzMub3JnLzE5OTgvTWF0aC9NYXRoTUxcIixzdmc6XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wifTtcbmZ1bmN0aW9uIGxiKGEpe3N3aXRjaChhKXtjYXNlIFwic3ZnXCI6cmV0dXJuXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiO2Nhc2UgXCJtYXRoXCI6cmV0dXJuXCJodHRwOi8vd3d3LnczLm9yZy8xOTk4L01hdGgvTWF0aE1MXCI7ZGVmYXVsdDpyZXR1cm5cImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWxcIn19ZnVuY3Rpb24gbWIoYSxiKXtyZXR1cm4gbnVsbD09YXx8XCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sXCI9PT1hP2xiKGIpOlwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIj09PWEmJlwiZm9yZWlnbk9iamVjdFwiPT09Yj9cImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWxcIjphfVxudmFyIG5iLG9iPWZ1bmN0aW9uKGEpe3JldHVyblwidW5kZWZpbmVkXCIhPT10eXBlb2YgTVNBcHAmJk1TQXBwLmV4ZWNVbnNhZmVMb2NhbEZ1bmN0aW9uP2Z1bmN0aW9uKGIsYyxkLGUpe01TQXBwLmV4ZWNVbnNhZmVMb2NhbEZ1bmN0aW9uKGZ1bmN0aW9uKCl7cmV0dXJuIGEoYixjLGQsZSl9KX06YX0oZnVuY3Rpb24oYSxiKXtpZihhLm5hbWVzcGFjZVVSSSE9PWtiLnN2Z3x8XCJpbm5lckhUTUxcImluIGEpYS5pbm5lckhUTUw9YjtlbHNle25iPW5ifHxkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO25iLmlubmVySFRNTD1cIjxzdmc+XCIrYi52YWx1ZU9mKCkudG9TdHJpbmcoKStcIjwvc3ZnPlwiO2ZvcihiPW5iLmZpcnN0Q2hpbGQ7YS5maXJzdENoaWxkOylhLnJlbW92ZUNoaWxkKGEuZmlyc3RDaGlsZCk7Zm9yKDtiLmZpcnN0Q2hpbGQ7KWEuYXBwZW5kQ2hpbGQoYi5maXJzdENoaWxkKX19KTtcbmZ1bmN0aW9uIHBiKGEsYil7aWYoYil7dmFyIGM9YS5maXJzdENoaWxkO2lmKGMmJmM9PT1hLmxhc3RDaGlsZCYmMz09PWMubm9kZVR5cGUpe2Mubm9kZVZhbHVlPWI7cmV0dXJufX1hLnRleHRDb250ZW50PWJ9XG52YXIgcWI9e2FuaW1hdGlvbkl0ZXJhdGlvbkNvdW50OiEwLGJvcmRlckltYWdlT3V0c2V0OiEwLGJvcmRlckltYWdlU2xpY2U6ITAsYm9yZGVySW1hZ2VXaWR0aDohMCxib3hGbGV4OiEwLGJveEZsZXhHcm91cDohMCxib3hPcmRpbmFsR3JvdXA6ITAsY29sdW1uQ291bnQ6ITAsY29sdW1uczohMCxmbGV4OiEwLGZsZXhHcm93OiEwLGZsZXhQb3NpdGl2ZTohMCxmbGV4U2hyaW5rOiEwLGZsZXhOZWdhdGl2ZTohMCxmbGV4T3JkZXI6ITAsZ3JpZEFyZWE6ITAsZ3JpZFJvdzohMCxncmlkUm93RW5kOiEwLGdyaWRSb3dTcGFuOiEwLGdyaWRSb3dTdGFydDohMCxncmlkQ29sdW1uOiEwLGdyaWRDb2x1bW5FbmQ6ITAsZ3JpZENvbHVtblNwYW46ITAsZ3JpZENvbHVtblN0YXJ0OiEwLGZvbnRXZWlnaHQ6ITAsbGluZUNsYW1wOiEwLGxpbmVIZWlnaHQ6ITAsb3BhY2l0eTohMCxvcmRlcjohMCxvcnBoYW5zOiEwLHRhYlNpemU6ITAsd2lkb3dzOiEwLHpJbmRleDohMCx6b29tOiEwLGZpbGxPcGFjaXR5OiEwLFxuZmxvb2RPcGFjaXR5OiEwLHN0b3BPcGFjaXR5OiEwLHN0cm9rZURhc2hhcnJheTohMCxzdHJva2VEYXNob2Zmc2V0OiEwLHN0cm9rZU1pdGVybGltaXQ6ITAsc3Ryb2tlT3BhY2l0eTohMCxzdHJva2VXaWR0aDohMH0scmI9W1wiV2Via2l0XCIsXCJtc1wiLFwiTW96XCIsXCJPXCJdO09iamVjdC5rZXlzKHFiKS5mb3JFYWNoKGZ1bmN0aW9uKGEpe3JiLmZvckVhY2goZnVuY3Rpb24oYil7Yj1iK2EuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkrYS5zdWJzdHJpbmcoMSk7cWJbYl09cWJbYV19KX0pO2Z1bmN0aW9uIHNiKGEsYixjKXtyZXR1cm4gbnVsbD09Ynx8XCJib29sZWFuXCI9PT10eXBlb2YgYnx8XCJcIj09PWI/XCJcIjpjfHxcIm51bWJlclwiIT09dHlwZW9mIGJ8fDA9PT1ifHxxYi5oYXNPd25Qcm9wZXJ0eShhKSYmcWJbYV0/KFwiXCIrYikudHJpbSgpOmIrXCJweFwifVxuZnVuY3Rpb24gdGIoYSxiKXthPWEuc3R5bGU7Zm9yKHZhciBjIGluIGIpaWYoYi5oYXNPd25Qcm9wZXJ0eShjKSl7dmFyIGQ9MD09PWMuaW5kZXhPZihcIi0tXCIpLGU9c2IoYyxiW2NdLGQpO1wiZmxvYXRcIj09PWMmJihjPVwiY3NzRmxvYXRcIik7ZD9hLnNldFByb3BlcnR5KGMsZSk6YVtjXT1lfX12YXIgdWI9bSh7bWVudWl0ZW06ITB9LHthcmVhOiEwLGJhc2U6ITAsYnI6ITAsY29sOiEwLGVtYmVkOiEwLGhyOiEwLGltZzohMCxpbnB1dDohMCxrZXlnZW46ITAsbGluazohMCxtZXRhOiEwLHBhcmFtOiEwLHNvdXJjZTohMCx0cmFjazohMCx3YnI6ITB9KTtcbmZ1bmN0aW9uIHZiKGEsYil7aWYoYil7aWYodWJbYV0mJihudWxsIT1iLmNoaWxkcmVufHxudWxsIT1iLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MKSl0aHJvdyBFcnJvcih5KDEzNyxhKSk7aWYobnVsbCE9Yi5kYW5nZXJvdXNseVNldElubmVySFRNTCl7aWYobnVsbCE9Yi5jaGlsZHJlbil0aHJvdyBFcnJvcih5KDYwKSk7aWYoIShcIm9iamVjdFwiPT09dHlwZW9mIGIuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwmJlwiX19odG1sXCJpbiBiLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MKSl0aHJvdyBFcnJvcih5KDYxKSk7fWlmKG51bGwhPWIuc3R5bGUmJlwib2JqZWN0XCIhPT10eXBlb2YgYi5zdHlsZSl0aHJvdyBFcnJvcih5KDYyKSk7fX1cbmZ1bmN0aW9uIHdiKGEsYil7aWYoLTE9PT1hLmluZGV4T2YoXCItXCIpKXJldHVyblwic3RyaW5nXCI9PT10eXBlb2YgYi5pcztzd2l0Y2goYSl7Y2FzZSBcImFubm90YXRpb24teG1sXCI6Y2FzZSBcImNvbG9yLXByb2ZpbGVcIjpjYXNlIFwiZm9udC1mYWNlXCI6Y2FzZSBcImZvbnQtZmFjZS1zcmNcIjpjYXNlIFwiZm9udC1mYWNlLXVyaVwiOmNhc2UgXCJmb250LWZhY2UtZm9ybWF0XCI6Y2FzZSBcImZvbnQtZmFjZS1uYW1lXCI6Y2FzZSBcIm1pc3NpbmctZ2x5cGhcIjpyZXR1cm4hMTtkZWZhdWx0OnJldHVybiEwfX1mdW5jdGlvbiB4YihhKXthPWEudGFyZ2V0fHxhLnNyY0VsZW1lbnR8fHdpbmRvdzthLmNvcnJlc3BvbmRpbmdVc2VFbGVtZW50JiYoYT1hLmNvcnJlc3BvbmRpbmdVc2VFbGVtZW50KTtyZXR1cm4gMz09PWEubm9kZVR5cGU/YS5wYXJlbnROb2RlOmF9dmFyIHliPW51bGwsemI9bnVsbCxBYj1udWxsO1xuZnVuY3Rpb24gQmIoYSl7aWYoYT1DYihhKSl7aWYoXCJmdW5jdGlvblwiIT09dHlwZW9mIHliKXRocm93IEVycm9yKHkoMjgwKSk7dmFyIGI9YS5zdGF0ZU5vZGU7YiYmKGI9RGIoYikseWIoYS5zdGF0ZU5vZGUsYS50eXBlLGIpKX19ZnVuY3Rpb24gRWIoYSl7emI/QWI/QWIucHVzaChhKTpBYj1bYV06emI9YX1mdW5jdGlvbiBGYigpe2lmKHpiKXt2YXIgYT16YixiPUFiO0FiPXpiPW51bGw7QmIoYSk7aWYoYilmb3IoYT0wO2E8Yi5sZW5ndGg7YSsrKUJiKGJbYV0pfX1mdW5jdGlvbiBHYihhLGIpe3JldHVybiBhKGIpfWZ1bmN0aW9uIEhiKGEsYixjLGQsZSl7cmV0dXJuIGEoYixjLGQsZSl9ZnVuY3Rpb24gSWIoKXt9dmFyIEpiPUdiLEtiPSExLExiPSExO2Z1bmN0aW9uIE1iKCl7aWYobnVsbCE9PXpifHxudWxsIT09QWIpSWIoKSxGYigpfVxuZnVuY3Rpb24gTmIoYSxiLGMpe2lmKExiKXJldHVybiBhKGIsYyk7TGI9ITA7dHJ5e3JldHVybiBKYihhLGIsYyl9ZmluYWxseXtMYj0hMSxNYigpfX1cbmZ1bmN0aW9uIE9iKGEsYil7dmFyIGM9YS5zdGF0ZU5vZGU7aWYobnVsbD09PWMpcmV0dXJuIG51bGw7dmFyIGQ9RGIoYyk7aWYobnVsbD09PWQpcmV0dXJuIG51bGw7Yz1kW2JdO2E6c3dpdGNoKGIpe2Nhc2UgXCJvbkNsaWNrXCI6Y2FzZSBcIm9uQ2xpY2tDYXB0dXJlXCI6Y2FzZSBcIm9uRG91YmxlQ2xpY2tcIjpjYXNlIFwib25Eb3VibGVDbGlja0NhcHR1cmVcIjpjYXNlIFwib25Nb3VzZURvd25cIjpjYXNlIFwib25Nb3VzZURvd25DYXB0dXJlXCI6Y2FzZSBcIm9uTW91c2VNb3ZlXCI6Y2FzZSBcIm9uTW91c2VNb3ZlQ2FwdHVyZVwiOmNhc2UgXCJvbk1vdXNlVXBcIjpjYXNlIFwib25Nb3VzZVVwQ2FwdHVyZVwiOmNhc2UgXCJvbk1vdXNlRW50ZXJcIjooZD0hZC5kaXNhYmxlZCl8fChhPWEudHlwZSxkPSEoXCJidXR0b25cIj09PWF8fFwiaW5wdXRcIj09PWF8fFwic2VsZWN0XCI9PT1hfHxcInRleHRhcmVhXCI9PT1hKSk7YT0hZDticmVhayBhO2RlZmF1bHQ6YT0hMX1pZihhKXJldHVybiBudWxsO2lmKGMmJlwiZnVuY3Rpb25cIiE9PVxudHlwZW9mIGMpdGhyb3cgRXJyb3IoeSgyMzEsYix0eXBlb2YgYykpO3JldHVybiBjfXZhciBQYj0hMTtpZihmYSl0cnl7dmFyIFFiPXt9O09iamVjdC5kZWZpbmVQcm9wZXJ0eShRYixcInBhc3NpdmVcIix7Z2V0OmZ1bmN0aW9uKCl7UGI9ITB9fSk7d2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJ0ZXN0XCIsUWIsUWIpO3dpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwidGVzdFwiLFFiLFFiKX1jYXRjaChhKXtQYj0hMX1mdW5jdGlvbiBSYihhLGIsYyxkLGUsZixnLGgsayl7dmFyIGw9QXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLDMpO3RyeXtiLmFwcGx5KGMsbCl9Y2F0Y2gobil7dGhpcy5vbkVycm9yKG4pfX12YXIgU2I9ITEsVGI9bnVsbCxVYj0hMSxWYj1udWxsLFdiPXtvbkVycm9yOmZ1bmN0aW9uKGEpe1NiPSEwO1RiPWF9fTtmdW5jdGlvbiBYYihhLGIsYyxkLGUsZixnLGgsayl7U2I9ITE7VGI9bnVsbDtSYi5hcHBseShXYixhcmd1bWVudHMpfVxuZnVuY3Rpb24gWWIoYSxiLGMsZCxlLGYsZyxoLGspe1hiLmFwcGx5KHRoaXMsYXJndW1lbnRzKTtpZihTYil7aWYoU2Ipe3ZhciBsPVRiO1NiPSExO1RiPW51bGx9ZWxzZSB0aHJvdyBFcnJvcih5KDE5OCkpO1VifHwoVWI9ITAsVmI9bCl9fWZ1bmN0aW9uIFpiKGEpe3ZhciBiPWEsYz1hO2lmKGEuYWx0ZXJuYXRlKWZvcig7Yi5yZXR1cm47KWI9Yi5yZXR1cm47ZWxzZXthPWI7ZG8gYj1hLDAhPT0oYi5mbGFncyYxMDI2KSYmKGM9Yi5yZXR1cm4pLGE9Yi5yZXR1cm47d2hpbGUoYSl9cmV0dXJuIDM9PT1iLnRhZz9jOm51bGx9ZnVuY3Rpb24gJGIoYSl7aWYoMTM9PT1hLnRhZyl7dmFyIGI9YS5tZW1vaXplZFN0YXRlO251bGw9PT1iJiYoYT1hLmFsdGVybmF0ZSxudWxsIT09YSYmKGI9YS5tZW1vaXplZFN0YXRlKSk7aWYobnVsbCE9PWIpcmV0dXJuIGIuZGVoeWRyYXRlZH1yZXR1cm4gbnVsbH1mdW5jdGlvbiBhYyhhKXtpZihaYihhKSE9PWEpdGhyb3cgRXJyb3IoeSgxODgpKTt9XG5mdW5jdGlvbiBiYyhhKXt2YXIgYj1hLmFsdGVybmF0ZTtpZighYil7Yj1aYihhKTtpZihudWxsPT09Yil0aHJvdyBFcnJvcih5KDE4OCkpO3JldHVybiBiIT09YT9udWxsOmF9Zm9yKHZhciBjPWEsZD1iOzspe3ZhciBlPWMucmV0dXJuO2lmKG51bGw9PT1lKWJyZWFrO3ZhciBmPWUuYWx0ZXJuYXRlO2lmKG51bGw9PT1mKXtkPWUucmV0dXJuO2lmKG51bGwhPT1kKXtjPWQ7Y29udGludWV9YnJlYWt9aWYoZS5jaGlsZD09PWYuY2hpbGQpe2ZvcihmPWUuY2hpbGQ7Zjspe2lmKGY9PT1jKXJldHVybiBhYyhlKSxhO2lmKGY9PT1kKXJldHVybiBhYyhlKSxiO2Y9Zi5zaWJsaW5nfXRocm93IEVycm9yKHkoMTg4KSk7fWlmKGMucmV0dXJuIT09ZC5yZXR1cm4pYz1lLGQ9ZjtlbHNle2Zvcih2YXIgZz0hMSxoPWUuY2hpbGQ7aDspe2lmKGg9PT1jKXtnPSEwO2M9ZTtkPWY7YnJlYWt9aWYoaD09PWQpe2c9ITA7ZD1lO2M9ZjticmVha31oPWguc2libGluZ31pZighZyl7Zm9yKGg9Zi5jaGlsZDtoOyl7aWYoaD09PVxuYyl7Zz0hMDtjPWY7ZD1lO2JyZWFrfWlmKGg9PT1kKXtnPSEwO2Q9ZjtjPWU7YnJlYWt9aD1oLnNpYmxpbmd9aWYoIWcpdGhyb3cgRXJyb3IoeSgxODkpKTt9fWlmKGMuYWx0ZXJuYXRlIT09ZCl0aHJvdyBFcnJvcih5KDE5MCkpO31pZigzIT09Yy50YWcpdGhyb3cgRXJyb3IoeSgxODgpKTtyZXR1cm4gYy5zdGF0ZU5vZGUuY3VycmVudD09PWM/YTpifWZ1bmN0aW9uIGNjKGEpe2E9YmMoYSk7aWYoIWEpcmV0dXJuIG51bGw7Zm9yKHZhciBiPWE7Oyl7aWYoNT09PWIudGFnfHw2PT09Yi50YWcpcmV0dXJuIGI7aWYoYi5jaGlsZCliLmNoaWxkLnJldHVybj1iLGI9Yi5jaGlsZDtlbHNle2lmKGI9PT1hKWJyZWFrO2Zvcig7IWIuc2libGluZzspe2lmKCFiLnJldHVybnx8Yi5yZXR1cm49PT1hKXJldHVybiBudWxsO2I9Yi5yZXR1cm59Yi5zaWJsaW5nLnJldHVybj1iLnJldHVybjtiPWIuc2libGluZ319cmV0dXJuIG51bGx9XG5mdW5jdGlvbiBkYyhhLGIpe2Zvcih2YXIgYz1hLmFsdGVybmF0ZTtudWxsIT09Yjspe2lmKGI9PT1hfHxiPT09YylyZXR1cm4hMDtiPWIucmV0dXJufXJldHVybiExfXZhciBlYyxmYyxnYyxoYyxpYz0hMSxqYz1bXSxrYz1udWxsLGxjPW51bGwsbWM9bnVsbCxuYz1uZXcgTWFwLG9jPW5ldyBNYXAscGM9W10scWM9XCJtb3VzZWRvd24gbW91c2V1cCB0b3VjaGNhbmNlbCB0b3VjaGVuZCB0b3VjaHN0YXJ0IGF1eGNsaWNrIGRibGNsaWNrIHBvaW50ZXJjYW5jZWwgcG9pbnRlcmRvd24gcG9pbnRlcnVwIGRyYWdlbmQgZHJhZ3N0YXJ0IGRyb3AgY29tcG9zaXRpb25lbmQgY29tcG9zaXRpb25zdGFydCBrZXlkb3duIGtleXByZXNzIGtleXVwIGlucHV0IHRleHRJbnB1dCBjb3B5IGN1dCBwYXN0ZSBjbGljayBjaGFuZ2UgY29udGV4dG1lbnUgcmVzZXQgc3VibWl0XCIuc3BsaXQoXCIgXCIpO1xuZnVuY3Rpb24gcmMoYSxiLGMsZCxlKXtyZXR1cm57YmxvY2tlZE9uOmEsZG9tRXZlbnROYW1lOmIsZXZlbnRTeXN0ZW1GbGFnczpjfDE2LG5hdGl2ZUV2ZW50OmUsdGFyZ2V0Q29udGFpbmVyczpbZF19fWZ1bmN0aW9uIHNjKGEsYil7c3dpdGNoKGEpe2Nhc2UgXCJmb2N1c2luXCI6Y2FzZSBcImZvY3Vzb3V0XCI6a2M9bnVsbDticmVhaztjYXNlIFwiZHJhZ2VudGVyXCI6Y2FzZSBcImRyYWdsZWF2ZVwiOmxjPW51bGw7YnJlYWs7Y2FzZSBcIm1vdXNlb3ZlclwiOmNhc2UgXCJtb3VzZW91dFwiOm1jPW51bGw7YnJlYWs7Y2FzZSBcInBvaW50ZXJvdmVyXCI6Y2FzZSBcInBvaW50ZXJvdXRcIjpuYy5kZWxldGUoYi5wb2ludGVySWQpO2JyZWFrO2Nhc2UgXCJnb3Rwb2ludGVyY2FwdHVyZVwiOmNhc2UgXCJsb3N0cG9pbnRlcmNhcHR1cmVcIjpvYy5kZWxldGUoYi5wb2ludGVySWQpfX1cbmZ1bmN0aW9uIHRjKGEsYixjLGQsZSxmKXtpZihudWxsPT09YXx8YS5uYXRpdmVFdmVudCE9PWYpcmV0dXJuIGE9cmMoYixjLGQsZSxmKSxudWxsIT09YiYmKGI9Q2IoYiksbnVsbCE9PWImJmZjKGIpKSxhO2EuZXZlbnRTeXN0ZW1GbGFnc3w9ZDtiPWEudGFyZ2V0Q29udGFpbmVycztudWxsIT09ZSYmLTE9PT1iLmluZGV4T2YoZSkmJmIucHVzaChlKTtyZXR1cm4gYX1cbmZ1bmN0aW9uIHVjKGEsYixjLGQsZSl7c3dpdGNoKGIpe2Nhc2UgXCJmb2N1c2luXCI6cmV0dXJuIGtjPXRjKGtjLGEsYixjLGQsZSksITA7Y2FzZSBcImRyYWdlbnRlclwiOnJldHVybiBsYz10YyhsYyxhLGIsYyxkLGUpLCEwO2Nhc2UgXCJtb3VzZW92ZXJcIjpyZXR1cm4gbWM9dGMobWMsYSxiLGMsZCxlKSwhMDtjYXNlIFwicG9pbnRlcm92ZXJcIjp2YXIgZj1lLnBvaW50ZXJJZDtuYy5zZXQoZix0YyhuYy5nZXQoZil8fG51bGwsYSxiLGMsZCxlKSk7cmV0dXJuITA7Y2FzZSBcImdvdHBvaW50ZXJjYXB0dXJlXCI6cmV0dXJuIGY9ZS5wb2ludGVySWQsb2Muc2V0KGYsdGMob2MuZ2V0KGYpfHxudWxsLGEsYixjLGQsZSkpLCEwfXJldHVybiExfVxuZnVuY3Rpb24gdmMoYSl7dmFyIGI9d2MoYS50YXJnZXQpO2lmKG51bGwhPT1iKXt2YXIgYz1aYihiKTtpZihudWxsIT09YylpZihiPWMudGFnLDEzPT09Yil7aWYoYj0kYihjKSxudWxsIT09Yil7YS5ibG9ja2VkT249YjtoYyhhLmxhbmVQcmlvcml0eSxmdW5jdGlvbigpe3IudW5zdGFibGVfcnVuV2l0aFByaW9yaXR5KGEucHJpb3JpdHksZnVuY3Rpb24oKXtnYyhjKX0pfSk7cmV0dXJufX1lbHNlIGlmKDM9PT1iJiZjLnN0YXRlTm9kZS5oeWRyYXRlKXthLmJsb2NrZWRPbj0zPT09Yy50YWc/Yy5zdGF0ZU5vZGUuY29udGFpbmVySW5mbzpudWxsO3JldHVybn19YS5ibG9ja2VkT249bnVsbH1cbmZ1bmN0aW9uIHhjKGEpe2lmKG51bGwhPT1hLmJsb2NrZWRPbilyZXR1cm4hMTtmb3IodmFyIGI9YS50YXJnZXRDb250YWluZXJzOzA8Yi5sZW5ndGg7KXt2YXIgYz15YyhhLmRvbUV2ZW50TmFtZSxhLmV2ZW50U3lzdGVtRmxhZ3MsYlswXSxhLm5hdGl2ZUV2ZW50KTtpZihudWxsIT09YylyZXR1cm4gYj1DYihjKSxudWxsIT09YiYmZmMoYiksYS5ibG9ja2VkT249YywhMTtiLnNoaWZ0KCl9cmV0dXJuITB9ZnVuY3Rpb24gemMoYSxiLGMpe3hjKGEpJiZjLmRlbGV0ZShiKX1cbmZ1bmN0aW9uIEFjKCl7Zm9yKGljPSExOzA8amMubGVuZ3RoOyl7dmFyIGE9amNbMF07aWYobnVsbCE9PWEuYmxvY2tlZE9uKXthPUNiKGEuYmxvY2tlZE9uKTtudWxsIT09YSYmZWMoYSk7YnJlYWt9Zm9yKHZhciBiPWEudGFyZ2V0Q29udGFpbmVyczswPGIubGVuZ3RoOyl7dmFyIGM9eWMoYS5kb21FdmVudE5hbWUsYS5ldmVudFN5c3RlbUZsYWdzLGJbMF0sYS5uYXRpdmVFdmVudCk7aWYobnVsbCE9PWMpe2EuYmxvY2tlZE9uPWM7YnJlYWt9Yi5zaGlmdCgpfW51bGw9PT1hLmJsb2NrZWRPbiYmamMuc2hpZnQoKX1udWxsIT09a2MmJnhjKGtjKSYmKGtjPW51bGwpO251bGwhPT1sYyYmeGMobGMpJiYobGM9bnVsbCk7bnVsbCE9PW1jJiZ4YyhtYykmJihtYz1udWxsKTtuYy5mb3JFYWNoKHpjKTtvYy5mb3JFYWNoKHpjKX1cbmZ1bmN0aW9uIEJjKGEsYil7YS5ibG9ja2VkT249PT1iJiYoYS5ibG9ja2VkT249bnVsbCxpY3x8KGljPSEwLHIudW5zdGFibGVfc2NoZWR1bGVDYWxsYmFjayhyLnVuc3RhYmxlX05vcm1hbFByaW9yaXR5LEFjKSkpfVxuZnVuY3Rpb24gQ2MoYSl7ZnVuY3Rpb24gYihiKXtyZXR1cm4gQmMoYixhKX1pZigwPGpjLmxlbmd0aCl7QmMoamNbMF0sYSk7Zm9yKHZhciBjPTE7YzxqYy5sZW5ndGg7YysrKXt2YXIgZD1qY1tjXTtkLmJsb2NrZWRPbj09PWEmJihkLmJsb2NrZWRPbj1udWxsKX19bnVsbCE9PWtjJiZCYyhrYyxhKTtudWxsIT09bGMmJkJjKGxjLGEpO251bGwhPT1tYyYmQmMobWMsYSk7bmMuZm9yRWFjaChiKTtvYy5mb3JFYWNoKGIpO2ZvcihjPTA7YzxwYy5sZW5ndGg7YysrKWQ9cGNbY10sZC5ibG9ja2VkT249PT1hJiYoZC5ibG9ja2VkT249bnVsbCk7Zm9yKDswPHBjLmxlbmd0aCYmKGM9cGNbMF0sbnVsbD09PWMuYmxvY2tlZE9uKTspdmMoYyksbnVsbD09PWMuYmxvY2tlZE9uJiZwYy5zaGlmdCgpfVxuZnVuY3Rpb24gRGMoYSxiKXt2YXIgYz17fTtjW2EudG9Mb3dlckNhc2UoKV09Yi50b0xvd2VyQ2FzZSgpO2NbXCJXZWJraXRcIithXT1cIndlYmtpdFwiK2I7Y1tcIk1velwiK2FdPVwibW96XCIrYjtyZXR1cm4gY312YXIgRWM9e2FuaW1hdGlvbmVuZDpEYyhcIkFuaW1hdGlvblwiLFwiQW5pbWF0aW9uRW5kXCIpLGFuaW1hdGlvbml0ZXJhdGlvbjpEYyhcIkFuaW1hdGlvblwiLFwiQW5pbWF0aW9uSXRlcmF0aW9uXCIpLGFuaW1hdGlvbnN0YXJ0OkRjKFwiQW5pbWF0aW9uXCIsXCJBbmltYXRpb25TdGFydFwiKSx0cmFuc2l0aW9uZW5kOkRjKFwiVHJhbnNpdGlvblwiLFwiVHJhbnNpdGlvbkVuZFwiKX0sRmM9e30sR2M9e307XG5mYSYmKEdjPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIikuc3R5bGUsXCJBbmltYXRpb25FdmVudFwiaW4gd2luZG93fHwoZGVsZXRlIEVjLmFuaW1hdGlvbmVuZC5hbmltYXRpb24sZGVsZXRlIEVjLmFuaW1hdGlvbml0ZXJhdGlvbi5hbmltYXRpb24sZGVsZXRlIEVjLmFuaW1hdGlvbnN0YXJ0LmFuaW1hdGlvbiksXCJUcmFuc2l0aW9uRXZlbnRcImluIHdpbmRvd3x8ZGVsZXRlIEVjLnRyYW5zaXRpb25lbmQudHJhbnNpdGlvbik7ZnVuY3Rpb24gSGMoYSl7aWYoRmNbYV0pcmV0dXJuIEZjW2FdO2lmKCFFY1thXSlyZXR1cm4gYTt2YXIgYj1FY1thXSxjO2ZvcihjIGluIGIpaWYoYi5oYXNPd25Qcm9wZXJ0eShjKSYmYyBpbiBHYylyZXR1cm4gRmNbYV09YltjXTtyZXR1cm4gYX1cbnZhciBJYz1IYyhcImFuaW1hdGlvbmVuZFwiKSxKYz1IYyhcImFuaW1hdGlvbml0ZXJhdGlvblwiKSxLYz1IYyhcImFuaW1hdGlvbnN0YXJ0XCIpLExjPUhjKFwidHJhbnNpdGlvbmVuZFwiKSxNYz1uZXcgTWFwLE5jPW5ldyBNYXAsT2M9W1wiYWJvcnRcIixcImFib3J0XCIsSWMsXCJhbmltYXRpb25FbmRcIixKYyxcImFuaW1hdGlvbkl0ZXJhdGlvblwiLEtjLFwiYW5pbWF0aW9uU3RhcnRcIixcImNhbnBsYXlcIixcImNhblBsYXlcIixcImNhbnBsYXl0aHJvdWdoXCIsXCJjYW5QbGF5VGhyb3VnaFwiLFwiZHVyYXRpb25jaGFuZ2VcIixcImR1cmF0aW9uQ2hhbmdlXCIsXCJlbXB0aWVkXCIsXCJlbXB0aWVkXCIsXCJlbmNyeXB0ZWRcIixcImVuY3J5cHRlZFwiLFwiZW5kZWRcIixcImVuZGVkXCIsXCJlcnJvclwiLFwiZXJyb3JcIixcImdvdHBvaW50ZXJjYXB0dXJlXCIsXCJnb3RQb2ludGVyQ2FwdHVyZVwiLFwibG9hZFwiLFwibG9hZFwiLFwibG9hZGVkZGF0YVwiLFwibG9hZGVkRGF0YVwiLFwibG9hZGVkbWV0YWRhdGFcIixcImxvYWRlZE1ldGFkYXRhXCIsXCJsb2Fkc3RhcnRcIixcImxvYWRTdGFydFwiLFxuXCJsb3N0cG9pbnRlcmNhcHR1cmVcIixcImxvc3RQb2ludGVyQ2FwdHVyZVwiLFwicGxheWluZ1wiLFwicGxheWluZ1wiLFwicHJvZ3Jlc3NcIixcInByb2dyZXNzXCIsXCJzZWVraW5nXCIsXCJzZWVraW5nXCIsXCJzdGFsbGVkXCIsXCJzdGFsbGVkXCIsXCJzdXNwZW5kXCIsXCJzdXNwZW5kXCIsXCJ0aW1ldXBkYXRlXCIsXCJ0aW1lVXBkYXRlXCIsTGMsXCJ0cmFuc2l0aW9uRW5kXCIsXCJ3YWl0aW5nXCIsXCJ3YWl0aW5nXCJdO2Z1bmN0aW9uIFBjKGEsYil7Zm9yKHZhciBjPTA7YzxhLmxlbmd0aDtjKz0yKXt2YXIgZD1hW2NdLGU9YVtjKzFdO2U9XCJvblwiKyhlWzBdLnRvVXBwZXJDYXNlKCkrZS5zbGljZSgxKSk7TmMuc2V0KGQsYik7TWMuc2V0KGQsZSk7ZGEoZSxbZF0pfX12YXIgUWM9ci51bnN0YWJsZV9ub3c7UWMoKTt2YXIgRj04O1xuZnVuY3Rpb24gUmMoYSl7aWYoMCE9PSgxJmEpKXJldHVybiBGPTE1LDE7aWYoMCE9PSgyJmEpKXJldHVybiBGPTE0LDI7aWYoMCE9PSg0JmEpKXJldHVybiBGPTEzLDQ7dmFyIGI9MjQmYTtpZigwIT09YilyZXR1cm4gRj0xMixiO2lmKDAhPT0oYSYzMikpcmV0dXJuIEY9MTEsMzI7Yj0xOTImYTtpZigwIT09YilyZXR1cm4gRj0xMCxiO2lmKDAhPT0oYSYyNTYpKXJldHVybiBGPTksMjU2O2I9MzU4NCZhO2lmKDAhPT1iKXJldHVybiBGPTgsYjtpZigwIT09KGEmNDA5NikpcmV0dXJuIEY9Nyw0MDk2O2I9NDE4NjExMiZhO2lmKDAhPT1iKXJldHVybiBGPTYsYjtiPTYyOTE0NTYwJmE7aWYoMCE9PWIpcmV0dXJuIEY9NSxiO2lmKGEmNjcxMDg4NjQpcmV0dXJuIEY9NCw2NzEwODg2NDtpZigwIT09KGEmMTM0MjE3NzI4KSlyZXR1cm4gRj0zLDEzNDIxNzcyODtiPTgwNTMwNjM2OCZhO2lmKDAhPT1iKXJldHVybiBGPTIsYjtpZigwIT09KDEwNzM3NDE4MjQmYSkpcmV0dXJuIEY9MSwxMDczNzQxODI0O1xuRj04O3JldHVybiBhfWZ1bmN0aW9uIFNjKGEpe3N3aXRjaChhKXtjYXNlIDk5OnJldHVybiAxNTtjYXNlIDk4OnJldHVybiAxMDtjYXNlIDk3OmNhc2UgOTY6cmV0dXJuIDg7Y2FzZSA5NTpyZXR1cm4gMjtkZWZhdWx0OnJldHVybiAwfX1mdW5jdGlvbiBUYyhhKXtzd2l0Y2goYSl7Y2FzZSAxNTpjYXNlIDE0OnJldHVybiA5OTtjYXNlIDEzOmNhc2UgMTI6Y2FzZSAxMTpjYXNlIDEwOnJldHVybiA5ODtjYXNlIDk6Y2FzZSA4OmNhc2UgNzpjYXNlIDY6Y2FzZSA0OmNhc2UgNTpyZXR1cm4gOTc7Y2FzZSAzOmNhc2UgMjpjYXNlIDE6cmV0dXJuIDk1O2Nhc2UgMDpyZXR1cm4gOTA7ZGVmYXVsdDp0aHJvdyBFcnJvcih5KDM1OCxhKSk7fX1cbmZ1bmN0aW9uIFVjKGEsYil7dmFyIGM9YS5wZW5kaW5nTGFuZXM7aWYoMD09PWMpcmV0dXJuIEY9MDt2YXIgZD0wLGU9MCxmPWEuZXhwaXJlZExhbmVzLGc9YS5zdXNwZW5kZWRMYW5lcyxoPWEucGluZ2VkTGFuZXM7aWYoMCE9PWYpZD1mLGU9Rj0xNTtlbHNlIGlmKGY9YyYxMzQyMTc3MjcsMCE9PWYpe3ZhciBrPWYmfmc7MCE9PWs/KGQ9UmMoayksZT1GKTooaCY9ZiwwIT09aCYmKGQ9UmMoaCksZT1GKSl9ZWxzZSBmPWMmfmcsMCE9PWY/KGQ9UmMoZiksZT1GKTowIT09aCYmKGQ9UmMoaCksZT1GKTtpZigwPT09ZClyZXR1cm4gMDtkPTMxLVZjKGQpO2Q9YyYoKDA+ZD8wOjE8PGQpPDwxKS0xO2lmKDAhPT1iJiZiIT09ZCYmMD09PShiJmcpKXtSYyhiKTtpZihlPD1GKXJldHVybiBiO0Y9ZX1iPWEuZW50YW5nbGVkTGFuZXM7aWYoMCE9PWIpZm9yKGE9YS5lbnRhbmdsZW1lbnRzLGImPWQ7MDxiOyljPTMxLVZjKGIpLGU9MTw8YyxkfD1hW2NdLGImPX5lO3JldHVybiBkfVxuZnVuY3Rpb24gV2MoYSl7YT1hLnBlbmRpbmdMYW5lcyYtMTA3Mzc0MTgyNTtyZXR1cm4gMCE9PWE/YTphJjEwNzM3NDE4MjQ/MTA3Mzc0MTgyNDowfWZ1bmN0aW9uIFhjKGEsYil7c3dpdGNoKGEpe2Nhc2UgMTU6cmV0dXJuIDE7Y2FzZSAxNDpyZXR1cm4gMjtjYXNlIDEyOnJldHVybiBhPVljKDI0Jn5iKSwwPT09YT9YYygxMCxiKTphO2Nhc2UgMTA6cmV0dXJuIGE9WWMoMTkyJn5iKSwwPT09YT9YYyg4LGIpOmE7Y2FzZSA4OnJldHVybiBhPVljKDM1ODQmfmIpLDA9PT1hJiYoYT1ZYyg0MTg2MTEyJn5iKSwwPT09YSYmKGE9NTEyKSksYTtjYXNlIDI6cmV0dXJuIGI9WWMoODA1MzA2MzY4Jn5iKSwwPT09YiYmKGI9MjY4NDM1NDU2KSxifXRocm93IEVycm9yKHkoMzU4LGEpKTt9ZnVuY3Rpb24gWWMoYSl7cmV0dXJuIGEmLWF9ZnVuY3Rpb24gWmMoYSl7Zm9yKHZhciBiPVtdLGM9MDszMT5jO2MrKyliLnB1c2goYSk7cmV0dXJuIGJ9XG5mdW5jdGlvbiAkYyhhLGIsYyl7YS5wZW5kaW5nTGFuZXN8PWI7dmFyIGQ9Yi0xO2Euc3VzcGVuZGVkTGFuZXMmPWQ7YS5waW5nZWRMYW5lcyY9ZDthPWEuZXZlbnRUaW1lcztiPTMxLVZjKGIpO2FbYl09Y312YXIgVmM9TWF0aC5jbHozMj9NYXRoLmNsejMyOmFkLGJkPU1hdGgubG9nLGNkPU1hdGguTE4yO2Z1bmN0aW9uIGFkKGEpe3JldHVybiAwPT09YT8zMjozMS0oYmQoYSkvY2R8MCl8MH12YXIgZGQ9ci51bnN0YWJsZV9Vc2VyQmxvY2tpbmdQcmlvcml0eSxlZD1yLnVuc3RhYmxlX3J1bldpdGhQcmlvcml0eSxmZD0hMDtmdW5jdGlvbiBnZChhLGIsYyxkKXtLYnx8SWIoKTt2YXIgZT1oZCxmPUtiO0tiPSEwO3RyeXtIYihlLGEsYixjLGQpfWZpbmFsbHl7KEtiPWYpfHxNYigpfX1mdW5jdGlvbiBpZChhLGIsYyxkKXtlZChkZCxoZC5iaW5kKG51bGwsYSxiLGMsZCkpfVxuZnVuY3Rpb24gaGQoYSxiLGMsZCl7aWYoZmQpe3ZhciBlO2lmKChlPTA9PT0oYiY0KSkmJjA8amMubGVuZ3RoJiYtMTxxYy5pbmRleE9mKGEpKWE9cmMobnVsbCxhLGIsYyxkKSxqYy5wdXNoKGEpO2Vsc2V7dmFyIGY9eWMoYSxiLGMsZCk7aWYobnVsbD09PWYpZSYmc2MoYSxkKTtlbHNle2lmKGUpe2lmKC0xPHFjLmluZGV4T2YoYSkpe2E9cmMoZixhLGIsYyxkKTtqYy5wdXNoKGEpO3JldHVybn1pZih1YyhmLGEsYixjLGQpKXJldHVybjtzYyhhLGQpfWpkKGEsYixkLG51bGwsYyl9fX19XG5mdW5jdGlvbiB5YyhhLGIsYyxkKXt2YXIgZT14YihkKTtlPXdjKGUpO2lmKG51bGwhPT1lKXt2YXIgZj1aYihlKTtpZihudWxsPT09ZillPW51bGw7ZWxzZXt2YXIgZz1mLnRhZztpZigxMz09PWcpe2U9JGIoZik7aWYobnVsbCE9PWUpcmV0dXJuIGU7ZT1udWxsfWVsc2UgaWYoMz09PWcpe2lmKGYuc3RhdGVOb2RlLmh5ZHJhdGUpcmV0dXJuIDM9PT1mLnRhZz9mLnN0YXRlTm9kZS5jb250YWluZXJJbmZvOm51bGw7ZT1udWxsfWVsc2UgZiE9PWUmJihlPW51bGwpfX1qZChhLGIsZCxlLGMpO3JldHVybiBudWxsfXZhciBrZD1udWxsLGxkPW51bGwsbWQ9bnVsbDtcbmZ1bmN0aW9uIG5kKCl7aWYobWQpcmV0dXJuIG1kO3ZhciBhLGI9bGQsYz1iLmxlbmd0aCxkLGU9XCJ2YWx1ZVwiaW4ga2Q/a2QudmFsdWU6a2QudGV4dENvbnRlbnQsZj1lLmxlbmd0aDtmb3IoYT0wO2E8YyYmYlthXT09PWVbYV07YSsrKTt2YXIgZz1jLWE7Zm9yKGQ9MTtkPD1nJiZiW2MtZF09PT1lW2YtZF07ZCsrKTtyZXR1cm4gbWQ9ZS5zbGljZShhLDE8ZD8xLWQ6dm9pZCAwKX1mdW5jdGlvbiBvZChhKXt2YXIgYj1hLmtleUNvZGU7XCJjaGFyQ29kZVwiaW4gYT8oYT1hLmNoYXJDb2RlLDA9PT1hJiYxMz09PWImJihhPTEzKSk6YT1iOzEwPT09YSYmKGE9MTMpO3JldHVybiAzMjw9YXx8MTM9PT1hP2E6MH1mdW5jdGlvbiBwZCgpe3JldHVybiEwfWZ1bmN0aW9uIHFkKCl7cmV0dXJuITF9XG5mdW5jdGlvbiByZChhKXtmdW5jdGlvbiBiKGIsZCxlLGYsZyl7dGhpcy5fcmVhY3ROYW1lPWI7dGhpcy5fdGFyZ2V0SW5zdD1lO3RoaXMudHlwZT1kO3RoaXMubmF0aXZlRXZlbnQ9Zjt0aGlzLnRhcmdldD1nO3RoaXMuY3VycmVudFRhcmdldD1udWxsO2Zvcih2YXIgYyBpbiBhKWEuaGFzT3duUHJvcGVydHkoYykmJihiPWFbY10sdGhpc1tjXT1iP2IoZik6ZltjXSk7dGhpcy5pc0RlZmF1bHRQcmV2ZW50ZWQ9KG51bGwhPWYuZGVmYXVsdFByZXZlbnRlZD9mLmRlZmF1bHRQcmV2ZW50ZWQ6ITE9PT1mLnJldHVyblZhbHVlKT9wZDpxZDt0aGlzLmlzUHJvcGFnYXRpb25TdG9wcGVkPXFkO3JldHVybiB0aGlzfW0oYi5wcm90b3R5cGUse3ByZXZlbnREZWZhdWx0OmZ1bmN0aW9uKCl7dGhpcy5kZWZhdWx0UHJldmVudGVkPSEwO3ZhciBhPXRoaXMubmF0aXZlRXZlbnQ7YSYmKGEucHJldmVudERlZmF1bHQ/YS5wcmV2ZW50RGVmYXVsdCgpOlwidW5rbm93blwiIT09dHlwZW9mIGEucmV0dXJuVmFsdWUmJlxuKGEucmV0dXJuVmFsdWU9ITEpLHRoaXMuaXNEZWZhdWx0UHJldmVudGVkPXBkKX0sc3RvcFByb3BhZ2F0aW9uOmZ1bmN0aW9uKCl7dmFyIGE9dGhpcy5uYXRpdmVFdmVudDthJiYoYS5zdG9wUHJvcGFnYXRpb24/YS5zdG9wUHJvcGFnYXRpb24oKTpcInVua25vd25cIiE9PXR5cGVvZiBhLmNhbmNlbEJ1YmJsZSYmKGEuY2FuY2VsQnViYmxlPSEwKSx0aGlzLmlzUHJvcGFnYXRpb25TdG9wcGVkPXBkKX0scGVyc2lzdDpmdW5jdGlvbigpe30saXNQZXJzaXN0ZW50OnBkfSk7cmV0dXJuIGJ9XG52YXIgc2Q9e2V2ZW50UGhhc2U6MCxidWJibGVzOjAsY2FuY2VsYWJsZTowLHRpbWVTdGFtcDpmdW5jdGlvbihhKXtyZXR1cm4gYS50aW1lU3RhbXB8fERhdGUubm93KCl9LGRlZmF1bHRQcmV2ZW50ZWQ6MCxpc1RydXN0ZWQ6MH0sdGQ9cmQoc2QpLHVkPW0oe30sc2Qse3ZpZXc6MCxkZXRhaWw6MH0pLHZkPXJkKHVkKSx3ZCx4ZCx5ZCxBZD1tKHt9LHVkLHtzY3JlZW5YOjAsc2NyZWVuWTowLGNsaWVudFg6MCxjbGllbnRZOjAscGFnZVg6MCxwYWdlWTowLGN0cmxLZXk6MCxzaGlmdEtleTowLGFsdEtleTowLG1ldGFLZXk6MCxnZXRNb2RpZmllclN0YXRlOnpkLGJ1dHRvbjowLGJ1dHRvbnM6MCxyZWxhdGVkVGFyZ2V0OmZ1bmN0aW9uKGEpe3JldHVybiB2b2lkIDA9PT1hLnJlbGF0ZWRUYXJnZXQ/YS5mcm9tRWxlbWVudD09PWEuc3JjRWxlbWVudD9hLnRvRWxlbWVudDphLmZyb21FbGVtZW50OmEucmVsYXRlZFRhcmdldH0sbW92ZW1lbnRYOmZ1bmN0aW9uKGEpe2lmKFwibW92ZW1lbnRYXCJpblxuYSlyZXR1cm4gYS5tb3ZlbWVudFg7YSE9PXlkJiYoeWQmJlwibW91c2Vtb3ZlXCI9PT1hLnR5cGU/KHdkPWEuc2NyZWVuWC15ZC5zY3JlZW5YLHhkPWEuc2NyZWVuWS15ZC5zY3JlZW5ZKTp4ZD13ZD0wLHlkPWEpO3JldHVybiB3ZH0sbW92ZW1lbnRZOmZ1bmN0aW9uKGEpe3JldHVyblwibW92ZW1lbnRZXCJpbiBhP2EubW92ZW1lbnRZOnhkfX0pLEJkPXJkKEFkKSxDZD1tKHt9LEFkLHtkYXRhVHJhbnNmZXI6MH0pLERkPXJkKENkKSxFZD1tKHt9LHVkLHtyZWxhdGVkVGFyZ2V0OjB9KSxGZD1yZChFZCksR2Q9bSh7fSxzZCx7YW5pbWF0aW9uTmFtZTowLGVsYXBzZWRUaW1lOjAscHNldWRvRWxlbWVudDowfSksSGQ9cmQoR2QpLElkPW0oe30sc2Qse2NsaXBib2FyZERhdGE6ZnVuY3Rpb24oYSl7cmV0dXJuXCJjbGlwYm9hcmREYXRhXCJpbiBhP2EuY2xpcGJvYXJkRGF0YTp3aW5kb3cuY2xpcGJvYXJkRGF0YX19KSxKZD1yZChJZCksS2Q9bSh7fSxzZCx7ZGF0YTowfSksTGQ9cmQoS2QpLE1kPXtFc2M6XCJFc2NhcGVcIixcblNwYWNlYmFyOlwiIFwiLExlZnQ6XCJBcnJvd0xlZnRcIixVcDpcIkFycm93VXBcIixSaWdodDpcIkFycm93UmlnaHRcIixEb3duOlwiQXJyb3dEb3duXCIsRGVsOlwiRGVsZXRlXCIsV2luOlwiT1NcIixNZW51OlwiQ29udGV4dE1lbnVcIixBcHBzOlwiQ29udGV4dE1lbnVcIixTY3JvbGw6XCJTY3JvbGxMb2NrXCIsTW96UHJpbnRhYmxlS2V5OlwiVW5pZGVudGlmaWVkXCJ9LE5kPXs4OlwiQmFja3NwYWNlXCIsOTpcIlRhYlwiLDEyOlwiQ2xlYXJcIiwxMzpcIkVudGVyXCIsMTY6XCJTaGlmdFwiLDE3OlwiQ29udHJvbFwiLDE4OlwiQWx0XCIsMTk6XCJQYXVzZVwiLDIwOlwiQ2Fwc0xvY2tcIiwyNzpcIkVzY2FwZVwiLDMyOlwiIFwiLDMzOlwiUGFnZVVwXCIsMzQ6XCJQYWdlRG93blwiLDM1OlwiRW5kXCIsMzY6XCJIb21lXCIsMzc6XCJBcnJvd0xlZnRcIiwzODpcIkFycm93VXBcIiwzOTpcIkFycm93UmlnaHRcIiw0MDpcIkFycm93RG93blwiLDQ1OlwiSW5zZXJ0XCIsNDY6XCJEZWxldGVcIiwxMTI6XCJGMVwiLDExMzpcIkYyXCIsMTE0OlwiRjNcIiwxMTU6XCJGNFwiLDExNjpcIkY1XCIsMTE3OlwiRjZcIiwxMTg6XCJGN1wiLFxuMTE5OlwiRjhcIiwxMjA6XCJGOVwiLDEyMTpcIkYxMFwiLDEyMjpcIkYxMVwiLDEyMzpcIkYxMlwiLDE0NDpcIk51bUxvY2tcIiwxNDU6XCJTY3JvbGxMb2NrXCIsMjI0OlwiTWV0YVwifSxPZD17QWx0OlwiYWx0S2V5XCIsQ29udHJvbDpcImN0cmxLZXlcIixNZXRhOlwibWV0YUtleVwiLFNoaWZ0Olwic2hpZnRLZXlcIn07ZnVuY3Rpb24gUGQoYSl7dmFyIGI9dGhpcy5uYXRpdmVFdmVudDtyZXR1cm4gYi5nZXRNb2RpZmllclN0YXRlP2IuZ2V0TW9kaWZpZXJTdGF0ZShhKTooYT1PZFthXSk/ISFiW2FdOiExfWZ1bmN0aW9uIHpkKCl7cmV0dXJuIFBkfVxudmFyIFFkPW0oe30sdWQse2tleTpmdW5jdGlvbihhKXtpZihhLmtleSl7dmFyIGI9TWRbYS5rZXldfHxhLmtleTtpZihcIlVuaWRlbnRpZmllZFwiIT09YilyZXR1cm4gYn1yZXR1cm5cImtleXByZXNzXCI9PT1hLnR5cGU/KGE9b2QoYSksMTM9PT1hP1wiRW50ZXJcIjpTdHJpbmcuZnJvbUNoYXJDb2RlKGEpKTpcImtleWRvd25cIj09PWEudHlwZXx8XCJrZXl1cFwiPT09YS50eXBlP05kW2Eua2V5Q29kZV18fFwiVW5pZGVudGlmaWVkXCI6XCJcIn0sY29kZTowLGxvY2F0aW9uOjAsY3RybEtleTowLHNoaWZ0S2V5OjAsYWx0S2V5OjAsbWV0YUtleTowLHJlcGVhdDowLGxvY2FsZTowLGdldE1vZGlmaWVyU3RhdGU6emQsY2hhckNvZGU6ZnVuY3Rpb24oYSl7cmV0dXJuXCJrZXlwcmVzc1wiPT09YS50eXBlP29kKGEpOjB9LGtleUNvZGU6ZnVuY3Rpb24oYSl7cmV0dXJuXCJrZXlkb3duXCI9PT1hLnR5cGV8fFwia2V5dXBcIj09PWEudHlwZT9hLmtleUNvZGU6MH0sd2hpY2g6ZnVuY3Rpb24oYSl7cmV0dXJuXCJrZXlwcmVzc1wiPT09XG5hLnR5cGU/b2QoYSk6XCJrZXlkb3duXCI9PT1hLnR5cGV8fFwia2V5dXBcIj09PWEudHlwZT9hLmtleUNvZGU6MH19KSxSZD1yZChRZCksU2Q9bSh7fSxBZCx7cG9pbnRlcklkOjAsd2lkdGg6MCxoZWlnaHQ6MCxwcmVzc3VyZTowLHRhbmdlbnRpYWxQcmVzc3VyZTowLHRpbHRYOjAsdGlsdFk6MCx0d2lzdDowLHBvaW50ZXJUeXBlOjAsaXNQcmltYXJ5OjB9KSxUZD1yZChTZCksVWQ9bSh7fSx1ZCx7dG91Y2hlczowLHRhcmdldFRvdWNoZXM6MCxjaGFuZ2VkVG91Y2hlczowLGFsdEtleTowLG1ldGFLZXk6MCxjdHJsS2V5OjAsc2hpZnRLZXk6MCxnZXRNb2RpZmllclN0YXRlOnpkfSksVmQ9cmQoVWQpLFdkPW0oe30sc2Qse3Byb3BlcnR5TmFtZTowLGVsYXBzZWRUaW1lOjAscHNldWRvRWxlbWVudDowfSksWGQ9cmQoV2QpLFlkPW0oe30sQWQse2RlbHRhWDpmdW5jdGlvbihhKXtyZXR1cm5cImRlbHRhWFwiaW4gYT9hLmRlbHRhWDpcIndoZWVsRGVsdGFYXCJpbiBhPy1hLndoZWVsRGVsdGFYOjB9LFxuZGVsdGFZOmZ1bmN0aW9uKGEpe3JldHVyblwiZGVsdGFZXCJpbiBhP2EuZGVsdGFZOlwid2hlZWxEZWx0YVlcImluIGE/LWEud2hlZWxEZWx0YVk6XCJ3aGVlbERlbHRhXCJpbiBhPy1hLndoZWVsRGVsdGE6MH0sZGVsdGFaOjAsZGVsdGFNb2RlOjB9KSxaZD1yZChZZCksJGQ9WzksMTMsMjcsMzJdLGFlPWZhJiZcIkNvbXBvc2l0aW9uRXZlbnRcImluIHdpbmRvdyxiZT1udWxsO2ZhJiZcImRvY3VtZW50TW9kZVwiaW4gZG9jdW1lbnQmJihiZT1kb2N1bWVudC5kb2N1bWVudE1vZGUpO3ZhciBjZT1mYSYmXCJUZXh0RXZlbnRcImluIHdpbmRvdyYmIWJlLGRlPWZhJiYoIWFlfHxiZSYmODxiZSYmMTE+PWJlKSxlZT1TdHJpbmcuZnJvbUNoYXJDb2RlKDMyKSxmZT0hMTtcbmZ1bmN0aW9uIGdlKGEsYil7c3dpdGNoKGEpe2Nhc2UgXCJrZXl1cFwiOnJldHVybi0xIT09JGQuaW5kZXhPZihiLmtleUNvZGUpO2Nhc2UgXCJrZXlkb3duXCI6cmV0dXJuIDIyOSE9PWIua2V5Q29kZTtjYXNlIFwia2V5cHJlc3NcIjpjYXNlIFwibW91c2Vkb3duXCI6Y2FzZSBcImZvY3Vzb3V0XCI6cmV0dXJuITA7ZGVmYXVsdDpyZXR1cm4hMX19ZnVuY3Rpb24gaGUoYSl7YT1hLmRldGFpbDtyZXR1cm5cIm9iamVjdFwiPT09dHlwZW9mIGEmJlwiZGF0YVwiaW4gYT9hLmRhdGE6bnVsbH12YXIgaWU9ITE7ZnVuY3Rpb24gamUoYSxiKXtzd2l0Y2goYSl7Y2FzZSBcImNvbXBvc2l0aW9uZW5kXCI6cmV0dXJuIGhlKGIpO2Nhc2UgXCJrZXlwcmVzc1wiOmlmKDMyIT09Yi53aGljaClyZXR1cm4gbnVsbDtmZT0hMDtyZXR1cm4gZWU7Y2FzZSBcInRleHRJbnB1dFwiOnJldHVybiBhPWIuZGF0YSxhPT09ZWUmJmZlP251bGw6YTtkZWZhdWx0OnJldHVybiBudWxsfX1cbmZ1bmN0aW9uIGtlKGEsYil7aWYoaWUpcmV0dXJuXCJjb21wb3NpdGlvbmVuZFwiPT09YXx8IWFlJiZnZShhLGIpPyhhPW5kKCksbWQ9bGQ9a2Q9bnVsbCxpZT0hMSxhKTpudWxsO3N3aXRjaChhKXtjYXNlIFwicGFzdGVcIjpyZXR1cm4gbnVsbDtjYXNlIFwia2V5cHJlc3NcIjppZighKGIuY3RybEtleXx8Yi5hbHRLZXl8fGIubWV0YUtleSl8fGIuY3RybEtleSYmYi5hbHRLZXkpe2lmKGIuY2hhciYmMTxiLmNoYXIubGVuZ3RoKXJldHVybiBiLmNoYXI7aWYoYi53aGljaClyZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShiLndoaWNoKX1yZXR1cm4gbnVsbDtjYXNlIFwiY29tcG9zaXRpb25lbmRcIjpyZXR1cm4gZGUmJlwia29cIiE9PWIubG9jYWxlP251bGw6Yi5kYXRhO2RlZmF1bHQ6cmV0dXJuIG51bGx9fVxudmFyIGxlPXtjb2xvcjohMCxkYXRlOiEwLGRhdGV0aW1lOiEwLFwiZGF0ZXRpbWUtbG9jYWxcIjohMCxlbWFpbDohMCxtb250aDohMCxudW1iZXI6ITAscGFzc3dvcmQ6ITAscmFuZ2U6ITAsc2VhcmNoOiEwLHRlbDohMCx0ZXh0OiEwLHRpbWU6ITAsdXJsOiEwLHdlZWs6ITB9O2Z1bmN0aW9uIG1lKGEpe3ZhciBiPWEmJmEubm9kZU5hbWUmJmEubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtyZXR1cm5cImlucHV0XCI9PT1iPyEhbGVbYS50eXBlXTpcInRleHRhcmVhXCI9PT1iPyEwOiExfWZ1bmN0aW9uIG5lKGEsYixjLGQpe0ViKGQpO2I9b2UoYixcIm9uQ2hhbmdlXCIpOzA8Yi5sZW5ndGgmJihjPW5ldyB0ZChcIm9uQ2hhbmdlXCIsXCJjaGFuZ2VcIixudWxsLGMsZCksYS5wdXNoKHtldmVudDpjLGxpc3RlbmVyczpifSkpfXZhciBwZT1udWxsLHFlPW51bGw7ZnVuY3Rpb24gcmUoYSl7c2UoYSwwKX1mdW5jdGlvbiB0ZShhKXt2YXIgYj11ZShhKTtpZihXYShiKSlyZXR1cm4gYX1cbmZ1bmN0aW9uIHZlKGEsYil7aWYoXCJjaGFuZ2VcIj09PWEpcmV0dXJuIGJ9dmFyIHdlPSExO2lmKGZhKXt2YXIgeGU7aWYoZmEpe3ZhciB5ZT1cIm9uaW5wdXRcImluIGRvY3VtZW50O2lmKCF5ZSl7dmFyIHplPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7emUuc2V0QXR0cmlidXRlKFwib25pbnB1dFwiLFwicmV0dXJuO1wiKTt5ZT1cImZ1bmN0aW9uXCI9PT10eXBlb2YgemUub25pbnB1dH14ZT15ZX1lbHNlIHhlPSExO3dlPXhlJiYoIWRvY3VtZW50LmRvY3VtZW50TW9kZXx8OTxkb2N1bWVudC5kb2N1bWVudE1vZGUpfWZ1bmN0aW9uIEFlKCl7cGUmJihwZS5kZXRhY2hFdmVudChcIm9ucHJvcGVydHljaGFuZ2VcIixCZSkscWU9cGU9bnVsbCl9ZnVuY3Rpb24gQmUoYSl7aWYoXCJ2YWx1ZVwiPT09YS5wcm9wZXJ0eU5hbWUmJnRlKHFlKSl7dmFyIGI9W107bmUoYixxZSxhLHhiKGEpKTthPXJlO2lmKEtiKWEoYik7ZWxzZXtLYj0hMDt0cnl7R2IoYSxiKX1maW5hbGx5e0tiPSExLE1iKCl9fX19XG5mdW5jdGlvbiBDZShhLGIsYyl7XCJmb2N1c2luXCI9PT1hPyhBZSgpLHBlPWIscWU9YyxwZS5hdHRhY2hFdmVudChcIm9ucHJvcGVydHljaGFuZ2VcIixCZSkpOlwiZm9jdXNvdXRcIj09PWEmJkFlKCl9ZnVuY3Rpb24gRGUoYSl7aWYoXCJzZWxlY3Rpb25jaGFuZ2VcIj09PWF8fFwia2V5dXBcIj09PWF8fFwia2V5ZG93blwiPT09YSlyZXR1cm4gdGUocWUpfWZ1bmN0aW9uIEVlKGEsYil7aWYoXCJjbGlja1wiPT09YSlyZXR1cm4gdGUoYil9ZnVuY3Rpb24gRmUoYSxiKXtpZihcImlucHV0XCI9PT1hfHxcImNoYW5nZVwiPT09YSlyZXR1cm4gdGUoYil9ZnVuY3Rpb24gR2UoYSxiKXtyZXR1cm4gYT09PWImJigwIT09YXx8MS9hPT09MS9iKXx8YSE9PWEmJmIhPT1ifXZhciBIZT1cImZ1bmN0aW9uXCI9PT10eXBlb2YgT2JqZWN0LmlzP09iamVjdC5pczpHZSxJZT1PYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuZnVuY3Rpb24gSmUoYSxiKXtpZihIZShhLGIpKXJldHVybiEwO2lmKFwib2JqZWN0XCIhPT10eXBlb2YgYXx8bnVsbD09PWF8fFwib2JqZWN0XCIhPT10eXBlb2YgYnx8bnVsbD09PWIpcmV0dXJuITE7dmFyIGM9T2JqZWN0LmtleXMoYSksZD1PYmplY3Qua2V5cyhiKTtpZihjLmxlbmd0aCE9PWQubGVuZ3RoKXJldHVybiExO2ZvcihkPTA7ZDxjLmxlbmd0aDtkKyspaWYoIUllLmNhbGwoYixjW2RdKXx8IUhlKGFbY1tkXV0sYltjW2RdXSkpcmV0dXJuITE7cmV0dXJuITB9ZnVuY3Rpb24gS2UoYSl7Zm9yKDthJiZhLmZpcnN0Q2hpbGQ7KWE9YS5maXJzdENoaWxkO3JldHVybiBhfVxuZnVuY3Rpb24gTGUoYSxiKXt2YXIgYz1LZShhKTthPTA7Zm9yKHZhciBkO2M7KXtpZigzPT09Yy5ub2RlVHlwZSl7ZD1hK2MudGV4dENvbnRlbnQubGVuZ3RoO2lmKGE8PWImJmQ+PWIpcmV0dXJue25vZGU6YyxvZmZzZXQ6Yi1hfTthPWR9YTp7Zm9yKDtjOyl7aWYoYy5uZXh0U2libGluZyl7Yz1jLm5leHRTaWJsaW5nO2JyZWFrIGF9Yz1jLnBhcmVudE5vZGV9Yz12b2lkIDB9Yz1LZShjKX19ZnVuY3Rpb24gTWUoYSxiKXtyZXR1cm4gYSYmYj9hPT09Yj8hMDphJiYzPT09YS5ub2RlVHlwZT8hMTpiJiYzPT09Yi5ub2RlVHlwZT9NZShhLGIucGFyZW50Tm9kZSk6XCJjb250YWluc1wiaW4gYT9hLmNvbnRhaW5zKGIpOmEuY29tcGFyZURvY3VtZW50UG9zaXRpb24/ISEoYS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbihiKSYxNik6ITE6ITF9XG5mdW5jdGlvbiBOZSgpe2Zvcih2YXIgYT13aW5kb3csYj1YYSgpO2IgaW5zdGFuY2VvZiBhLkhUTUxJRnJhbWVFbGVtZW50Oyl7dHJ5e3ZhciBjPVwic3RyaW5nXCI9PT10eXBlb2YgYi5jb250ZW50V2luZG93LmxvY2F0aW9uLmhyZWZ9Y2F0Y2goZCl7Yz0hMX1pZihjKWE9Yi5jb250ZW50V2luZG93O2Vsc2UgYnJlYWs7Yj1YYShhLmRvY3VtZW50KX1yZXR1cm4gYn1mdW5jdGlvbiBPZShhKXt2YXIgYj1hJiZhLm5vZGVOYW1lJiZhLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7cmV0dXJuIGImJihcImlucHV0XCI9PT1iJiYoXCJ0ZXh0XCI9PT1hLnR5cGV8fFwic2VhcmNoXCI9PT1hLnR5cGV8fFwidGVsXCI9PT1hLnR5cGV8fFwidXJsXCI9PT1hLnR5cGV8fFwicGFzc3dvcmRcIj09PWEudHlwZSl8fFwidGV4dGFyZWFcIj09PWJ8fFwidHJ1ZVwiPT09YS5jb250ZW50RWRpdGFibGUpfVxudmFyIFBlPWZhJiZcImRvY3VtZW50TW9kZVwiaW4gZG9jdW1lbnQmJjExPj1kb2N1bWVudC5kb2N1bWVudE1vZGUsUWU9bnVsbCxSZT1udWxsLFNlPW51bGwsVGU9ITE7XG5mdW5jdGlvbiBVZShhLGIsYyl7dmFyIGQ9Yy53aW5kb3c9PT1jP2MuZG9jdW1lbnQ6OT09PWMubm9kZVR5cGU/YzpjLm93bmVyRG9jdW1lbnQ7VGV8fG51bGw9PVFlfHxRZSE9PVhhKGQpfHwoZD1RZSxcInNlbGVjdGlvblN0YXJ0XCJpbiBkJiZPZShkKT9kPXtzdGFydDpkLnNlbGVjdGlvblN0YXJ0LGVuZDpkLnNlbGVjdGlvbkVuZH06KGQ9KGQub3duZXJEb2N1bWVudCYmZC5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3fHx3aW5kb3cpLmdldFNlbGVjdGlvbigpLGQ9e2FuY2hvck5vZGU6ZC5hbmNob3JOb2RlLGFuY2hvck9mZnNldDpkLmFuY2hvck9mZnNldCxmb2N1c05vZGU6ZC5mb2N1c05vZGUsZm9jdXNPZmZzZXQ6ZC5mb2N1c09mZnNldH0pLFNlJiZKZShTZSxkKXx8KFNlPWQsZD1vZShSZSxcIm9uU2VsZWN0XCIpLDA8ZC5sZW5ndGgmJihiPW5ldyB0ZChcIm9uU2VsZWN0XCIsXCJzZWxlY3RcIixudWxsLGIsYyksYS5wdXNoKHtldmVudDpiLGxpc3RlbmVyczpkfSksYi50YXJnZXQ9UWUpKSl9XG5QYyhcImNhbmNlbCBjYW5jZWwgY2xpY2sgY2xpY2sgY2xvc2UgY2xvc2UgY29udGV4dG1lbnUgY29udGV4dE1lbnUgY29weSBjb3B5IGN1dCBjdXQgYXV4Y2xpY2sgYXV4Q2xpY2sgZGJsY2xpY2sgZG91YmxlQ2xpY2sgZHJhZ2VuZCBkcmFnRW5kIGRyYWdzdGFydCBkcmFnU3RhcnQgZHJvcCBkcm9wIGZvY3VzaW4gZm9jdXMgZm9jdXNvdXQgYmx1ciBpbnB1dCBpbnB1dCBpbnZhbGlkIGludmFsaWQga2V5ZG93biBrZXlEb3duIGtleXByZXNzIGtleVByZXNzIGtleXVwIGtleVVwIG1vdXNlZG93biBtb3VzZURvd24gbW91c2V1cCBtb3VzZVVwIHBhc3RlIHBhc3RlIHBhdXNlIHBhdXNlIHBsYXkgcGxheSBwb2ludGVyY2FuY2VsIHBvaW50ZXJDYW5jZWwgcG9pbnRlcmRvd24gcG9pbnRlckRvd24gcG9pbnRlcnVwIHBvaW50ZXJVcCByYXRlY2hhbmdlIHJhdGVDaGFuZ2UgcmVzZXQgcmVzZXQgc2Vla2VkIHNlZWtlZCBzdWJtaXQgc3VibWl0IHRvdWNoY2FuY2VsIHRvdWNoQ2FuY2VsIHRvdWNoZW5kIHRvdWNoRW5kIHRvdWNoc3RhcnQgdG91Y2hTdGFydCB2b2x1bWVjaGFuZ2Ugdm9sdW1lQ2hhbmdlXCIuc3BsaXQoXCIgXCIpLFxuMCk7UGMoXCJkcmFnIGRyYWcgZHJhZ2VudGVyIGRyYWdFbnRlciBkcmFnZXhpdCBkcmFnRXhpdCBkcmFnbGVhdmUgZHJhZ0xlYXZlIGRyYWdvdmVyIGRyYWdPdmVyIG1vdXNlbW92ZSBtb3VzZU1vdmUgbW91c2VvdXQgbW91c2VPdXQgbW91c2VvdmVyIG1vdXNlT3ZlciBwb2ludGVybW92ZSBwb2ludGVyTW92ZSBwb2ludGVyb3V0IHBvaW50ZXJPdXQgcG9pbnRlcm92ZXIgcG9pbnRlck92ZXIgc2Nyb2xsIHNjcm9sbCB0b2dnbGUgdG9nZ2xlIHRvdWNobW92ZSB0b3VjaE1vdmUgd2hlZWwgd2hlZWxcIi5zcGxpdChcIiBcIiksMSk7UGMoT2MsMik7Zm9yKHZhciBWZT1cImNoYW5nZSBzZWxlY3Rpb25jaGFuZ2UgdGV4dElucHV0IGNvbXBvc2l0aW9uc3RhcnQgY29tcG9zaXRpb25lbmQgY29tcG9zaXRpb251cGRhdGVcIi5zcGxpdChcIiBcIiksV2U9MDtXZTxWZS5sZW5ndGg7V2UrKylOYy5zZXQoVmVbV2VdLDApO2VhKFwib25Nb3VzZUVudGVyXCIsW1wibW91c2VvdXRcIixcIm1vdXNlb3ZlclwiXSk7XG5lYShcIm9uTW91c2VMZWF2ZVwiLFtcIm1vdXNlb3V0XCIsXCJtb3VzZW92ZXJcIl0pO2VhKFwib25Qb2ludGVyRW50ZXJcIixbXCJwb2ludGVyb3V0XCIsXCJwb2ludGVyb3ZlclwiXSk7ZWEoXCJvblBvaW50ZXJMZWF2ZVwiLFtcInBvaW50ZXJvdXRcIixcInBvaW50ZXJvdmVyXCJdKTtkYShcIm9uQ2hhbmdlXCIsXCJjaGFuZ2UgY2xpY2sgZm9jdXNpbiBmb2N1c291dCBpbnB1dCBrZXlkb3duIGtleXVwIHNlbGVjdGlvbmNoYW5nZVwiLnNwbGl0KFwiIFwiKSk7ZGEoXCJvblNlbGVjdFwiLFwiZm9jdXNvdXQgY29udGV4dG1lbnUgZHJhZ2VuZCBmb2N1c2luIGtleWRvd24ga2V5dXAgbW91c2Vkb3duIG1vdXNldXAgc2VsZWN0aW9uY2hhbmdlXCIuc3BsaXQoXCIgXCIpKTtkYShcIm9uQmVmb3JlSW5wdXRcIixbXCJjb21wb3NpdGlvbmVuZFwiLFwia2V5cHJlc3NcIixcInRleHRJbnB1dFwiLFwicGFzdGVcIl0pO2RhKFwib25Db21wb3NpdGlvbkVuZFwiLFwiY29tcG9zaXRpb25lbmQgZm9jdXNvdXQga2V5ZG93biBrZXlwcmVzcyBrZXl1cCBtb3VzZWRvd25cIi5zcGxpdChcIiBcIikpO1xuZGEoXCJvbkNvbXBvc2l0aW9uU3RhcnRcIixcImNvbXBvc2l0aW9uc3RhcnQgZm9jdXNvdXQga2V5ZG93biBrZXlwcmVzcyBrZXl1cCBtb3VzZWRvd25cIi5zcGxpdChcIiBcIikpO2RhKFwib25Db21wb3NpdGlvblVwZGF0ZVwiLFwiY29tcG9zaXRpb251cGRhdGUgZm9jdXNvdXQga2V5ZG93biBrZXlwcmVzcyBrZXl1cCBtb3VzZWRvd25cIi5zcGxpdChcIiBcIikpO3ZhciBYZT1cImFib3J0IGNhbnBsYXkgY2FucGxheXRocm91Z2ggZHVyYXRpb25jaGFuZ2UgZW1wdGllZCBlbmNyeXB0ZWQgZW5kZWQgZXJyb3IgbG9hZGVkZGF0YSBsb2FkZWRtZXRhZGF0YSBsb2Fkc3RhcnQgcGF1c2UgcGxheSBwbGF5aW5nIHByb2dyZXNzIHJhdGVjaGFuZ2Ugc2Vla2VkIHNlZWtpbmcgc3RhbGxlZCBzdXNwZW5kIHRpbWV1cGRhdGUgdm9sdW1lY2hhbmdlIHdhaXRpbmdcIi5zcGxpdChcIiBcIiksWWU9bmV3IFNldChcImNhbmNlbCBjbG9zZSBpbnZhbGlkIGxvYWQgc2Nyb2xsIHRvZ2dsZVwiLnNwbGl0KFwiIFwiKS5jb25jYXQoWGUpKTtcbmZ1bmN0aW9uIFplKGEsYixjKXt2YXIgZD1hLnR5cGV8fFwidW5rbm93bi1ldmVudFwiO2EuY3VycmVudFRhcmdldD1jO1liKGQsYix2b2lkIDAsYSk7YS5jdXJyZW50VGFyZ2V0PW51bGx9XG5mdW5jdGlvbiBzZShhLGIpe2I9MCE9PShiJjQpO2Zvcih2YXIgYz0wO2M8YS5sZW5ndGg7YysrKXt2YXIgZD1hW2NdLGU9ZC5ldmVudDtkPWQubGlzdGVuZXJzO2E6e3ZhciBmPXZvaWQgMDtpZihiKWZvcih2YXIgZz1kLmxlbmd0aC0xOzA8PWc7Zy0tKXt2YXIgaD1kW2ddLGs9aC5pbnN0YW5jZSxsPWguY3VycmVudFRhcmdldDtoPWgubGlzdGVuZXI7aWYoayE9PWYmJmUuaXNQcm9wYWdhdGlvblN0b3BwZWQoKSlicmVhayBhO1plKGUsaCxsKTtmPWt9ZWxzZSBmb3IoZz0wO2c8ZC5sZW5ndGg7ZysrKXtoPWRbZ107az1oLmluc3RhbmNlO2w9aC5jdXJyZW50VGFyZ2V0O2g9aC5saXN0ZW5lcjtpZihrIT09ZiYmZS5pc1Byb3BhZ2F0aW9uU3RvcHBlZCgpKWJyZWFrIGE7WmUoZSxoLGwpO2Y9a319fWlmKFViKXRocm93IGE9VmIsVWI9ITEsVmI9bnVsbCxhO31cbmZ1bmN0aW9uIEcoYSxiKXt2YXIgYz0kZShiKSxkPWErXCJfX2J1YmJsZVwiO2MuaGFzKGQpfHwoYWYoYixhLDIsITEpLGMuYWRkKGQpKX12YXIgYmY9XCJfcmVhY3RMaXN0ZW5pbmdcIitNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zbGljZSgyKTtmdW5jdGlvbiBjZihhKXthW2JmXXx8KGFbYmZdPSEwLGJhLmZvckVhY2goZnVuY3Rpb24oYil7WWUuaGFzKGIpfHxkZihiLCExLGEsbnVsbCk7ZGYoYiwhMCxhLG51bGwpfSkpfVxuZnVuY3Rpb24gZGYoYSxiLGMsZCl7dmFyIGU9NDxhcmd1bWVudHMubGVuZ3RoJiZ2b2lkIDAhPT1hcmd1bWVudHNbNF0/YXJndW1lbnRzWzRdOjAsZj1jO1wic2VsZWN0aW9uY2hhbmdlXCI9PT1hJiY5IT09Yy5ub2RlVHlwZSYmKGY9Yy5vd25lckRvY3VtZW50KTtpZihudWxsIT09ZCYmIWImJlllLmhhcyhhKSl7aWYoXCJzY3JvbGxcIiE9PWEpcmV0dXJuO2V8PTI7Zj1kfXZhciBnPSRlKGYpLGg9YStcIl9fXCIrKGI/XCJjYXB0dXJlXCI6XCJidWJibGVcIik7Zy5oYXMoaCl8fChiJiYoZXw9NCksYWYoZixhLGUsYiksZy5hZGQoaCkpfVxuZnVuY3Rpb24gYWYoYSxiLGMsZCl7dmFyIGU9TmMuZ2V0KGIpO3N3aXRjaCh2b2lkIDA9PT1lPzI6ZSl7Y2FzZSAwOmU9Z2Q7YnJlYWs7Y2FzZSAxOmU9aWQ7YnJlYWs7ZGVmYXVsdDplPWhkfWM9ZS5iaW5kKG51bGwsYixjLGEpO2U9dm9pZCAwOyFQYnx8XCJ0b3VjaHN0YXJ0XCIhPT1iJiZcInRvdWNobW92ZVwiIT09YiYmXCJ3aGVlbFwiIT09Ynx8KGU9ITApO2Q/dm9pZCAwIT09ZT9hLmFkZEV2ZW50TGlzdGVuZXIoYixjLHtjYXB0dXJlOiEwLHBhc3NpdmU6ZX0pOmEuYWRkRXZlbnRMaXN0ZW5lcihiLGMsITApOnZvaWQgMCE9PWU/YS5hZGRFdmVudExpc3RlbmVyKGIsYyx7cGFzc2l2ZTplfSk6YS5hZGRFdmVudExpc3RlbmVyKGIsYywhMSl9XG5mdW5jdGlvbiBqZChhLGIsYyxkLGUpe3ZhciBmPWQ7aWYoMD09PShiJjEpJiYwPT09KGImMikmJm51bGwhPT1kKWE6Zm9yKDs7KXtpZihudWxsPT09ZClyZXR1cm47dmFyIGc9ZC50YWc7aWYoMz09PWd8fDQ9PT1nKXt2YXIgaD1kLnN0YXRlTm9kZS5jb250YWluZXJJbmZvO2lmKGg9PT1lfHw4PT09aC5ub2RlVHlwZSYmaC5wYXJlbnROb2RlPT09ZSlicmVhaztpZig0PT09Zylmb3IoZz1kLnJldHVybjtudWxsIT09Zzspe3ZhciBrPWcudGFnO2lmKDM9PT1rfHw0PT09aylpZihrPWcuc3RhdGVOb2RlLmNvbnRhaW5lckluZm8saz09PWV8fDg9PT1rLm5vZGVUeXBlJiZrLnBhcmVudE5vZGU9PT1lKXJldHVybjtnPWcucmV0dXJufWZvcig7bnVsbCE9PWg7KXtnPXdjKGgpO2lmKG51bGw9PT1nKXJldHVybjtrPWcudGFnO2lmKDU9PT1rfHw2PT09ayl7ZD1mPWc7Y29udGludWUgYX1oPWgucGFyZW50Tm9kZX19ZD1kLnJldHVybn1OYihmdW5jdGlvbigpe3ZhciBkPWYsZT14YihjKSxnPVtdO1xuYTp7dmFyIGg9TWMuZ2V0KGEpO2lmKHZvaWQgMCE9PWgpe3ZhciBrPXRkLHg9YTtzd2l0Y2goYSl7Y2FzZSBcImtleXByZXNzXCI6aWYoMD09PW9kKGMpKWJyZWFrIGE7Y2FzZSBcImtleWRvd25cIjpjYXNlIFwia2V5dXBcIjprPVJkO2JyZWFrO2Nhc2UgXCJmb2N1c2luXCI6eD1cImZvY3VzXCI7az1GZDticmVhaztjYXNlIFwiZm9jdXNvdXRcIjp4PVwiYmx1clwiO2s9RmQ7YnJlYWs7Y2FzZSBcImJlZm9yZWJsdXJcIjpjYXNlIFwiYWZ0ZXJibHVyXCI6az1GZDticmVhaztjYXNlIFwiY2xpY2tcIjppZigyPT09Yy5idXR0b24pYnJlYWsgYTtjYXNlIFwiYXV4Y2xpY2tcIjpjYXNlIFwiZGJsY2xpY2tcIjpjYXNlIFwibW91c2Vkb3duXCI6Y2FzZSBcIm1vdXNlbW92ZVwiOmNhc2UgXCJtb3VzZXVwXCI6Y2FzZSBcIm1vdXNlb3V0XCI6Y2FzZSBcIm1vdXNlb3ZlclwiOmNhc2UgXCJjb250ZXh0bWVudVwiOms9QmQ7YnJlYWs7Y2FzZSBcImRyYWdcIjpjYXNlIFwiZHJhZ2VuZFwiOmNhc2UgXCJkcmFnZW50ZXJcIjpjYXNlIFwiZHJhZ2V4aXRcIjpjYXNlIFwiZHJhZ2xlYXZlXCI6Y2FzZSBcImRyYWdvdmVyXCI6Y2FzZSBcImRyYWdzdGFydFwiOmNhc2UgXCJkcm9wXCI6az1cbkRkO2JyZWFrO2Nhc2UgXCJ0b3VjaGNhbmNlbFwiOmNhc2UgXCJ0b3VjaGVuZFwiOmNhc2UgXCJ0b3VjaG1vdmVcIjpjYXNlIFwidG91Y2hzdGFydFwiOms9VmQ7YnJlYWs7Y2FzZSBJYzpjYXNlIEpjOmNhc2UgS2M6az1IZDticmVhaztjYXNlIExjOms9WGQ7YnJlYWs7Y2FzZSBcInNjcm9sbFwiOms9dmQ7YnJlYWs7Y2FzZSBcIndoZWVsXCI6az1aZDticmVhaztjYXNlIFwiY29weVwiOmNhc2UgXCJjdXRcIjpjYXNlIFwicGFzdGVcIjprPUpkO2JyZWFrO2Nhc2UgXCJnb3Rwb2ludGVyY2FwdHVyZVwiOmNhc2UgXCJsb3N0cG9pbnRlcmNhcHR1cmVcIjpjYXNlIFwicG9pbnRlcmNhbmNlbFwiOmNhc2UgXCJwb2ludGVyZG93blwiOmNhc2UgXCJwb2ludGVybW92ZVwiOmNhc2UgXCJwb2ludGVyb3V0XCI6Y2FzZSBcInBvaW50ZXJvdmVyXCI6Y2FzZSBcInBvaW50ZXJ1cFwiOms9VGR9dmFyIHc9MCE9PShiJjQpLHo9IXcmJlwic2Nyb2xsXCI9PT1hLHU9dz9udWxsIT09aD9oK1wiQ2FwdHVyZVwiOm51bGw6aDt3PVtdO2Zvcih2YXIgdD1kLHE7bnVsbCE9PVxudDspe3E9dDt2YXIgdj1xLnN0YXRlTm9kZTs1PT09cS50YWcmJm51bGwhPT12JiYocT12LG51bGwhPT11JiYodj1PYih0LHUpLG51bGwhPXYmJncucHVzaChlZih0LHYscSkpKSk7aWYoeilicmVhazt0PXQucmV0dXJufTA8dy5sZW5ndGgmJihoPW5ldyBrKGgseCxudWxsLGMsZSksZy5wdXNoKHtldmVudDpoLGxpc3RlbmVyczp3fSkpfX1pZigwPT09KGImNykpe2E6e2g9XCJtb3VzZW92ZXJcIj09PWF8fFwicG9pbnRlcm92ZXJcIj09PWE7az1cIm1vdXNlb3V0XCI9PT1hfHxcInBvaW50ZXJvdXRcIj09PWE7aWYoaCYmMD09PShiJjE2KSYmKHg9Yy5yZWxhdGVkVGFyZ2V0fHxjLmZyb21FbGVtZW50KSYmKHdjKHgpfHx4W2ZmXSkpYnJlYWsgYTtpZihrfHxoKXtoPWUud2luZG93PT09ZT9lOihoPWUub3duZXJEb2N1bWVudCk/aC5kZWZhdWx0Vmlld3x8aC5wYXJlbnRXaW5kb3c6d2luZG93O2lmKGspe2lmKHg9Yy5yZWxhdGVkVGFyZ2V0fHxjLnRvRWxlbWVudCxrPWQseD14P3djKHgpOm51bGwsbnVsbCE9PVxueCYmKHo9WmIoeCkseCE9PXp8fDUhPT14LnRhZyYmNiE9PXgudGFnKSl4PW51bGx9ZWxzZSBrPW51bGwseD1kO2lmKGshPT14KXt3PUJkO3Y9XCJvbk1vdXNlTGVhdmVcIjt1PVwib25Nb3VzZUVudGVyXCI7dD1cIm1vdXNlXCI7aWYoXCJwb2ludGVyb3V0XCI9PT1hfHxcInBvaW50ZXJvdmVyXCI9PT1hKXc9VGQsdj1cIm9uUG9pbnRlckxlYXZlXCIsdT1cIm9uUG9pbnRlckVudGVyXCIsdD1cInBvaW50ZXJcIjt6PW51bGw9PWs/aDp1ZShrKTtxPW51bGw9PXg/aDp1ZSh4KTtoPW5ldyB3KHYsdCtcImxlYXZlXCIsayxjLGUpO2gudGFyZ2V0PXo7aC5yZWxhdGVkVGFyZ2V0PXE7dj1udWxsO3djKGUpPT09ZCYmKHc9bmV3IHcodSx0K1wiZW50ZXJcIix4LGMsZSksdy50YXJnZXQ9cSx3LnJlbGF0ZWRUYXJnZXQ9eix2PXcpO3o9djtpZihrJiZ4KWI6e3c9azt1PXg7dD0wO2ZvcihxPXc7cTtxPWdmKHEpKXQrKztxPTA7Zm9yKHY9dTt2O3Y9Z2YodikpcSsrO2Zvcig7MDx0LXE7KXc9Z2YodyksdC0tO2Zvcig7MDxxLXQ7KXU9XG5nZih1KSxxLS07Zm9yKDt0LS07KXtpZih3PT09dXx8bnVsbCE9PXUmJnc9PT11LmFsdGVybmF0ZSlicmVhayBiO3c9Z2Yodyk7dT1nZih1KX13PW51bGx9ZWxzZSB3PW51bGw7bnVsbCE9PWsmJmhmKGcsaCxrLHcsITEpO251bGwhPT14JiZudWxsIT09eiYmaGYoZyx6LHgsdywhMCl9fX1hOntoPWQ/dWUoZCk6d2luZG93O2s9aC5ub2RlTmFtZSYmaC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO2lmKFwic2VsZWN0XCI9PT1rfHxcImlucHV0XCI9PT1rJiZcImZpbGVcIj09PWgudHlwZSl2YXIgSj12ZTtlbHNlIGlmKG1lKGgpKWlmKHdlKUo9RmU7ZWxzZXtKPURlO3ZhciBLPUNlfWVsc2Uoaz1oLm5vZGVOYW1lKSYmXCJpbnB1dFwiPT09ay50b0xvd2VyQ2FzZSgpJiYoXCJjaGVja2JveFwiPT09aC50eXBlfHxcInJhZGlvXCI9PT1oLnR5cGUpJiYoSj1FZSk7aWYoSiYmKEo9SihhLGQpKSl7bmUoZyxKLGMsZSk7YnJlYWsgYX1LJiZLKGEsaCxkKTtcImZvY3Vzb3V0XCI9PT1hJiYoSz1oLl93cmFwcGVyU3RhdGUpJiZcbksuY29udHJvbGxlZCYmXCJudW1iZXJcIj09PWgudHlwZSYmYmIoaCxcIm51bWJlclwiLGgudmFsdWUpfUs9ZD91ZShkKTp3aW5kb3c7c3dpdGNoKGEpe2Nhc2UgXCJmb2N1c2luXCI6aWYobWUoSyl8fFwidHJ1ZVwiPT09Sy5jb250ZW50RWRpdGFibGUpUWU9SyxSZT1kLFNlPW51bGw7YnJlYWs7Y2FzZSBcImZvY3Vzb3V0XCI6U2U9UmU9UWU9bnVsbDticmVhaztjYXNlIFwibW91c2Vkb3duXCI6VGU9ITA7YnJlYWs7Y2FzZSBcImNvbnRleHRtZW51XCI6Y2FzZSBcIm1vdXNldXBcIjpjYXNlIFwiZHJhZ2VuZFwiOlRlPSExO1VlKGcsYyxlKTticmVhaztjYXNlIFwic2VsZWN0aW9uY2hhbmdlXCI6aWYoUGUpYnJlYWs7Y2FzZSBcImtleWRvd25cIjpjYXNlIFwia2V5dXBcIjpVZShnLGMsZSl9dmFyIFE7aWYoYWUpYjp7c3dpdGNoKGEpe2Nhc2UgXCJjb21wb3NpdGlvbnN0YXJ0XCI6dmFyIEw9XCJvbkNvbXBvc2l0aW9uU3RhcnRcIjticmVhayBiO2Nhc2UgXCJjb21wb3NpdGlvbmVuZFwiOkw9XCJvbkNvbXBvc2l0aW9uRW5kXCI7YnJlYWsgYjtcbmNhc2UgXCJjb21wb3NpdGlvbnVwZGF0ZVwiOkw9XCJvbkNvbXBvc2l0aW9uVXBkYXRlXCI7YnJlYWsgYn1MPXZvaWQgMH1lbHNlIGllP2dlKGEsYykmJihMPVwib25Db21wb3NpdGlvbkVuZFwiKTpcImtleWRvd25cIj09PWEmJjIyOT09PWMua2V5Q29kZSYmKEw9XCJvbkNvbXBvc2l0aW9uU3RhcnRcIik7TCYmKGRlJiZcImtvXCIhPT1jLmxvY2FsZSYmKGllfHxcIm9uQ29tcG9zaXRpb25TdGFydFwiIT09TD9cIm9uQ29tcG9zaXRpb25FbmRcIj09PUwmJmllJiYoUT1uZCgpKTooa2Q9ZSxsZD1cInZhbHVlXCJpbiBrZD9rZC52YWx1ZTprZC50ZXh0Q29udGVudCxpZT0hMCkpLEs9b2UoZCxMKSwwPEsubGVuZ3RoJiYoTD1uZXcgTGQoTCxhLG51bGwsYyxlKSxnLnB1c2goe2V2ZW50OkwsbGlzdGVuZXJzOkt9KSxRP0wuZGF0YT1ROihRPWhlKGMpLG51bGwhPT1RJiYoTC5kYXRhPVEpKSkpO2lmKFE9Y2U/amUoYSxjKTprZShhLGMpKWQ9b2UoZCxcIm9uQmVmb3JlSW5wdXRcIiksMDxkLmxlbmd0aCYmKGU9bmV3IExkKFwib25CZWZvcmVJbnB1dFwiLFxuXCJiZWZvcmVpbnB1dFwiLG51bGwsYyxlKSxnLnB1c2goe2V2ZW50OmUsbGlzdGVuZXJzOmR9KSxlLmRhdGE9USl9c2UoZyxiKX0pfWZ1bmN0aW9uIGVmKGEsYixjKXtyZXR1cm57aW5zdGFuY2U6YSxsaXN0ZW5lcjpiLGN1cnJlbnRUYXJnZXQ6Y319ZnVuY3Rpb24gb2UoYSxiKXtmb3IodmFyIGM9YitcIkNhcHR1cmVcIixkPVtdO251bGwhPT1hOyl7dmFyIGU9YSxmPWUuc3RhdGVOb2RlOzU9PT1lLnRhZyYmbnVsbCE9PWYmJihlPWYsZj1PYihhLGMpLG51bGwhPWYmJmQudW5zaGlmdChlZihhLGYsZSkpLGY9T2IoYSxiKSxudWxsIT1mJiZkLnB1c2goZWYoYSxmLGUpKSk7YT1hLnJldHVybn1yZXR1cm4gZH1mdW5jdGlvbiBnZihhKXtpZihudWxsPT09YSlyZXR1cm4gbnVsbDtkbyBhPWEucmV0dXJuO3doaWxlKGEmJjUhPT1hLnRhZyk7cmV0dXJuIGE/YTpudWxsfVxuZnVuY3Rpb24gaGYoYSxiLGMsZCxlKXtmb3IodmFyIGY9Yi5fcmVhY3ROYW1lLGc9W107bnVsbCE9PWMmJmMhPT1kOyl7dmFyIGg9YyxrPWguYWx0ZXJuYXRlLGw9aC5zdGF0ZU5vZGU7aWYobnVsbCE9PWsmJms9PT1kKWJyZWFrOzU9PT1oLnRhZyYmbnVsbCE9PWwmJihoPWwsZT8oaz1PYihjLGYpLG51bGwhPWsmJmcudW5zaGlmdChlZihjLGssaCkpKTplfHwoaz1PYihjLGYpLG51bGwhPWsmJmcucHVzaChlZihjLGssaCkpKSk7Yz1jLnJldHVybn0wIT09Zy5sZW5ndGgmJmEucHVzaCh7ZXZlbnQ6YixsaXN0ZW5lcnM6Z30pfWZ1bmN0aW9uIGpmKCl7fXZhciBrZj1udWxsLGxmPW51bGw7ZnVuY3Rpb24gbWYoYSxiKXtzd2l0Y2goYSl7Y2FzZSBcImJ1dHRvblwiOmNhc2UgXCJpbnB1dFwiOmNhc2UgXCJzZWxlY3RcIjpjYXNlIFwidGV4dGFyZWFcIjpyZXR1cm4hIWIuYXV0b0ZvY3VzfXJldHVybiExfVxuZnVuY3Rpb24gbmYoYSxiKXtyZXR1cm5cInRleHRhcmVhXCI9PT1hfHxcIm9wdGlvblwiPT09YXx8XCJub3NjcmlwdFwiPT09YXx8XCJzdHJpbmdcIj09PXR5cGVvZiBiLmNoaWxkcmVufHxcIm51bWJlclwiPT09dHlwZW9mIGIuY2hpbGRyZW58fFwib2JqZWN0XCI9PT10eXBlb2YgYi5kYW5nZXJvdXNseVNldElubmVySFRNTCYmbnVsbCE9PWIuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwmJm51bGwhPWIuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwuX19odG1sfXZhciBvZj1cImZ1bmN0aW9uXCI9PT10eXBlb2Ygc2V0VGltZW91dD9zZXRUaW1lb3V0OnZvaWQgMCxwZj1cImZ1bmN0aW9uXCI9PT10eXBlb2YgY2xlYXJUaW1lb3V0P2NsZWFyVGltZW91dDp2b2lkIDA7ZnVuY3Rpb24gcWYoYSl7MT09PWEubm9kZVR5cGU/YS50ZXh0Q29udGVudD1cIlwiOjk9PT1hLm5vZGVUeXBlJiYoYT1hLmJvZHksbnVsbCE9YSYmKGEudGV4dENvbnRlbnQ9XCJcIikpfVxuZnVuY3Rpb24gcmYoYSl7Zm9yKDtudWxsIT1hO2E9YS5uZXh0U2libGluZyl7dmFyIGI9YS5ub2RlVHlwZTtpZigxPT09Ynx8Mz09PWIpYnJlYWt9cmV0dXJuIGF9ZnVuY3Rpb24gc2YoYSl7YT1hLnByZXZpb3VzU2libGluZztmb3IodmFyIGI9MDthOyl7aWYoOD09PWEubm9kZVR5cGUpe3ZhciBjPWEuZGF0YTtpZihcIiRcIj09PWN8fFwiJCFcIj09PWN8fFwiJD9cIj09PWMpe2lmKDA9PT1iKXJldHVybiBhO2ItLX1lbHNlXCIvJFwiPT09YyYmYisrfWE9YS5wcmV2aW91c1NpYmxpbmd9cmV0dXJuIG51bGx9dmFyIHRmPTA7ZnVuY3Rpb24gdWYoYSl7cmV0dXJueyQkdHlwZW9mOkdhLHRvU3RyaW5nOmEsdmFsdWVPZjphfX12YXIgdmY9TWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc2xpY2UoMiksd2Y9XCJfX3JlYWN0RmliZXIkXCIrdmYseGY9XCJfX3JlYWN0UHJvcHMkXCIrdmYsZmY9XCJfX3JlYWN0Q29udGFpbmVyJFwiK3ZmLHlmPVwiX19yZWFjdEV2ZW50cyRcIit2ZjtcbmZ1bmN0aW9uIHdjKGEpe3ZhciBiPWFbd2ZdO2lmKGIpcmV0dXJuIGI7Zm9yKHZhciBjPWEucGFyZW50Tm9kZTtjOyl7aWYoYj1jW2ZmXXx8Y1t3Zl0pe2M9Yi5hbHRlcm5hdGU7aWYobnVsbCE9PWIuY2hpbGR8fG51bGwhPT1jJiZudWxsIT09Yy5jaGlsZClmb3IoYT1zZihhKTtudWxsIT09YTspe2lmKGM9YVt3Zl0pcmV0dXJuIGM7YT1zZihhKX1yZXR1cm4gYn1hPWM7Yz1hLnBhcmVudE5vZGV9cmV0dXJuIG51bGx9ZnVuY3Rpb24gQ2IoYSl7YT1hW3dmXXx8YVtmZl07cmV0dXJuIWF8fDUhPT1hLnRhZyYmNiE9PWEudGFnJiYxMyE9PWEudGFnJiYzIT09YS50YWc/bnVsbDphfWZ1bmN0aW9uIHVlKGEpe2lmKDU9PT1hLnRhZ3x8Nj09PWEudGFnKXJldHVybiBhLnN0YXRlTm9kZTt0aHJvdyBFcnJvcih5KDMzKSk7fWZ1bmN0aW9uIERiKGEpe3JldHVybiBhW3hmXXx8bnVsbH1cbmZ1bmN0aW9uICRlKGEpe3ZhciBiPWFbeWZdO3ZvaWQgMD09PWImJihiPWFbeWZdPW5ldyBTZXQpO3JldHVybiBifXZhciB6Zj1bXSxBZj0tMTtmdW5jdGlvbiBCZihhKXtyZXR1cm57Y3VycmVudDphfX1mdW5jdGlvbiBIKGEpezA+QWZ8fChhLmN1cnJlbnQ9emZbQWZdLHpmW0FmXT1udWxsLEFmLS0pfWZ1bmN0aW9uIEkoYSxiKXtBZisrO3pmW0FmXT1hLmN1cnJlbnQ7YS5jdXJyZW50PWJ9dmFyIENmPXt9LE09QmYoQ2YpLE49QmYoITEpLERmPUNmO1xuZnVuY3Rpb24gRWYoYSxiKXt2YXIgYz1hLnR5cGUuY29udGV4dFR5cGVzO2lmKCFjKXJldHVybiBDZjt2YXIgZD1hLnN0YXRlTm9kZTtpZihkJiZkLl9fcmVhY3RJbnRlcm5hbE1lbW9pemVkVW5tYXNrZWRDaGlsZENvbnRleHQ9PT1iKXJldHVybiBkLl9fcmVhY3RJbnRlcm5hbE1lbW9pemVkTWFza2VkQ2hpbGRDb250ZXh0O3ZhciBlPXt9LGY7Zm9yKGYgaW4gYyllW2ZdPWJbZl07ZCYmKGE9YS5zdGF0ZU5vZGUsYS5fX3JlYWN0SW50ZXJuYWxNZW1vaXplZFVubWFza2VkQ2hpbGRDb250ZXh0PWIsYS5fX3JlYWN0SW50ZXJuYWxNZW1vaXplZE1hc2tlZENoaWxkQ29udGV4dD1lKTtyZXR1cm4gZX1mdW5jdGlvbiBGZihhKXthPWEuY2hpbGRDb250ZXh0VHlwZXM7cmV0dXJuIG51bGwhPT1hJiZ2b2lkIDAhPT1hfWZ1bmN0aW9uIEdmKCl7SChOKTtIKE0pfWZ1bmN0aW9uIEhmKGEsYixjKXtpZihNLmN1cnJlbnQhPT1DZil0aHJvdyBFcnJvcih5KDE2OCkpO0koTSxiKTtJKE4sYyl9XG5mdW5jdGlvbiBJZihhLGIsYyl7dmFyIGQ9YS5zdGF0ZU5vZGU7YT1iLmNoaWxkQ29udGV4dFR5cGVzO2lmKFwiZnVuY3Rpb25cIiE9PXR5cGVvZiBkLmdldENoaWxkQ29udGV4dClyZXR1cm4gYztkPWQuZ2V0Q2hpbGRDb250ZXh0KCk7Zm9yKHZhciBlIGluIGQpaWYoIShlIGluIGEpKXRocm93IEVycm9yKHkoMTA4LFJhKGIpfHxcIlVua25vd25cIixlKSk7cmV0dXJuIG0oe30sYyxkKX1mdW5jdGlvbiBKZihhKXthPShhPWEuc3RhdGVOb2RlKSYmYS5fX3JlYWN0SW50ZXJuYWxNZW1vaXplZE1lcmdlZENoaWxkQ29udGV4dHx8Q2Y7RGY9TS5jdXJyZW50O0koTSxhKTtJKE4sTi5jdXJyZW50KTtyZXR1cm4hMH1mdW5jdGlvbiBLZihhLGIsYyl7dmFyIGQ9YS5zdGF0ZU5vZGU7aWYoIWQpdGhyb3cgRXJyb3IoeSgxNjkpKTtjPyhhPUlmKGEsYixEZiksZC5fX3JlYWN0SW50ZXJuYWxNZW1vaXplZE1lcmdlZENoaWxkQ29udGV4dD1hLEgoTiksSChNKSxJKE0sYSkpOkgoTik7SShOLGMpfVxudmFyIExmPW51bGwsTWY9bnVsbCxOZj1yLnVuc3RhYmxlX3J1bldpdGhQcmlvcml0eSxPZj1yLnVuc3RhYmxlX3NjaGVkdWxlQ2FsbGJhY2ssUGY9ci51bnN0YWJsZV9jYW5jZWxDYWxsYmFjayxRZj1yLnVuc3RhYmxlX3Nob3VsZFlpZWxkLFJmPXIudW5zdGFibGVfcmVxdWVzdFBhaW50LFNmPXIudW5zdGFibGVfbm93LFRmPXIudW5zdGFibGVfZ2V0Q3VycmVudFByaW9yaXR5TGV2ZWwsVWY9ci51bnN0YWJsZV9JbW1lZGlhdGVQcmlvcml0eSxWZj1yLnVuc3RhYmxlX1VzZXJCbG9ja2luZ1ByaW9yaXR5LFdmPXIudW5zdGFibGVfTm9ybWFsUHJpb3JpdHksWGY9ci51bnN0YWJsZV9Mb3dQcmlvcml0eSxZZj1yLnVuc3RhYmxlX0lkbGVQcmlvcml0eSxaZj17fSwkZj12b2lkIDAhPT1SZj9SZjpmdW5jdGlvbigpe30sYWc9bnVsbCxiZz1udWxsLGNnPSExLGRnPVNmKCksTz0xRTQ+ZGc/U2Y6ZnVuY3Rpb24oKXtyZXR1cm4gU2YoKS1kZ307XG5mdW5jdGlvbiBlZygpe3N3aXRjaChUZigpKXtjYXNlIFVmOnJldHVybiA5OTtjYXNlIFZmOnJldHVybiA5ODtjYXNlIFdmOnJldHVybiA5NztjYXNlIFhmOnJldHVybiA5NjtjYXNlIFlmOnJldHVybiA5NTtkZWZhdWx0OnRocm93IEVycm9yKHkoMzMyKSk7fX1mdW5jdGlvbiBmZyhhKXtzd2l0Y2goYSl7Y2FzZSA5OTpyZXR1cm4gVWY7Y2FzZSA5ODpyZXR1cm4gVmY7Y2FzZSA5NzpyZXR1cm4gV2Y7Y2FzZSA5NjpyZXR1cm4gWGY7Y2FzZSA5NTpyZXR1cm4gWWY7ZGVmYXVsdDp0aHJvdyBFcnJvcih5KDMzMikpO319ZnVuY3Rpb24gZ2coYSxiKXthPWZnKGEpO3JldHVybiBOZihhLGIpfWZ1bmN0aW9uIGhnKGEsYixjKXthPWZnKGEpO3JldHVybiBPZihhLGIsYyl9ZnVuY3Rpb24gaWcoKXtpZihudWxsIT09Ymcpe3ZhciBhPWJnO2JnPW51bGw7UGYoYSl9amcoKX1cbmZ1bmN0aW9uIGpnKCl7aWYoIWNnJiZudWxsIT09YWcpe2NnPSEwO3ZhciBhPTA7dHJ5e3ZhciBiPWFnO2dnKDk5LGZ1bmN0aW9uKCl7Zm9yKDthPGIubGVuZ3RoO2ErKyl7dmFyIGM9YlthXTtkbyBjPWMoITApO3doaWxlKG51bGwhPT1jKX19KTthZz1udWxsfWNhdGNoKGMpe3Rocm93IG51bGwhPT1hZyYmKGFnPWFnLnNsaWNlKGErMSkpLE9mKFVmLGlnKSxjO31maW5hbGx5e2NnPSExfX19dmFyIGtnPXJhLlJlYWN0Q3VycmVudEJhdGNoQ29uZmlnO2Z1bmN0aW9uIGxnKGEsYil7aWYoYSYmYS5kZWZhdWx0UHJvcHMpe2I9bSh7fSxiKTthPWEuZGVmYXVsdFByb3BzO2Zvcih2YXIgYyBpbiBhKXZvaWQgMD09PWJbY10mJihiW2NdPWFbY10pO3JldHVybiBifXJldHVybiBifXZhciBtZz1CZihudWxsKSxuZz1udWxsLG9nPW51bGwscGc9bnVsbDtmdW5jdGlvbiBxZygpe3BnPW9nPW5nPW51bGx9XG5mdW5jdGlvbiByZyhhKXt2YXIgYj1tZy5jdXJyZW50O0gobWcpO2EudHlwZS5fY29udGV4dC5fY3VycmVudFZhbHVlPWJ9ZnVuY3Rpb24gc2coYSxiKXtmb3IoO251bGwhPT1hOyl7dmFyIGM9YS5hbHRlcm5hdGU7aWYoKGEuY2hpbGRMYW5lcyZiKT09PWIpaWYobnVsbD09PWN8fChjLmNoaWxkTGFuZXMmYik9PT1iKWJyZWFrO2Vsc2UgYy5jaGlsZExhbmVzfD1iO2Vsc2UgYS5jaGlsZExhbmVzfD1iLG51bGwhPT1jJiYoYy5jaGlsZExhbmVzfD1iKTthPWEucmV0dXJufX1mdW5jdGlvbiB0ZyhhLGIpe25nPWE7cGc9b2c9bnVsbDthPWEuZGVwZW5kZW5jaWVzO251bGwhPT1hJiZudWxsIT09YS5maXJzdENvbnRleHQmJigwIT09KGEubGFuZXMmYikmJih1Zz0hMCksYS5maXJzdENvbnRleHQ9bnVsbCl9XG5mdW5jdGlvbiB2ZyhhLGIpe2lmKHBnIT09YSYmITEhPT1iJiYwIT09Yil7aWYoXCJudW1iZXJcIiE9PXR5cGVvZiBifHwxMDczNzQxODIzPT09YilwZz1hLGI9MTA3Mzc0MTgyMztiPXtjb250ZXh0OmEsb2JzZXJ2ZWRCaXRzOmIsbmV4dDpudWxsfTtpZihudWxsPT09b2cpe2lmKG51bGw9PT1uZyl0aHJvdyBFcnJvcih5KDMwOCkpO29nPWI7bmcuZGVwZW5kZW5jaWVzPXtsYW5lczowLGZpcnN0Q29udGV4dDpiLHJlc3BvbmRlcnM6bnVsbH19ZWxzZSBvZz1vZy5uZXh0PWJ9cmV0dXJuIGEuX2N1cnJlbnRWYWx1ZX12YXIgd2c9ITE7ZnVuY3Rpb24geGcoYSl7YS51cGRhdGVRdWV1ZT17YmFzZVN0YXRlOmEubWVtb2l6ZWRTdGF0ZSxmaXJzdEJhc2VVcGRhdGU6bnVsbCxsYXN0QmFzZVVwZGF0ZTpudWxsLHNoYXJlZDp7cGVuZGluZzpudWxsfSxlZmZlY3RzOm51bGx9fVxuZnVuY3Rpb24geWcoYSxiKXthPWEudXBkYXRlUXVldWU7Yi51cGRhdGVRdWV1ZT09PWEmJihiLnVwZGF0ZVF1ZXVlPXtiYXNlU3RhdGU6YS5iYXNlU3RhdGUsZmlyc3RCYXNlVXBkYXRlOmEuZmlyc3RCYXNlVXBkYXRlLGxhc3RCYXNlVXBkYXRlOmEubGFzdEJhc2VVcGRhdGUsc2hhcmVkOmEuc2hhcmVkLGVmZmVjdHM6YS5lZmZlY3RzfSl9ZnVuY3Rpb24gemcoYSxiKXtyZXR1cm57ZXZlbnRUaW1lOmEsbGFuZTpiLHRhZzowLHBheWxvYWQ6bnVsbCxjYWxsYmFjazpudWxsLG5leHQ6bnVsbH19ZnVuY3Rpb24gQWcoYSxiKXthPWEudXBkYXRlUXVldWU7aWYobnVsbCE9PWEpe2E9YS5zaGFyZWQ7dmFyIGM9YS5wZW5kaW5nO251bGw9PT1jP2IubmV4dD1iOihiLm5leHQ9Yy5uZXh0LGMubmV4dD1iKTthLnBlbmRpbmc9Yn19XG5mdW5jdGlvbiBCZyhhLGIpe3ZhciBjPWEudXBkYXRlUXVldWUsZD1hLmFsdGVybmF0ZTtpZihudWxsIT09ZCYmKGQ9ZC51cGRhdGVRdWV1ZSxjPT09ZCkpe3ZhciBlPW51bGwsZj1udWxsO2M9Yy5maXJzdEJhc2VVcGRhdGU7aWYobnVsbCE9PWMpe2Rve3ZhciBnPXtldmVudFRpbWU6Yy5ldmVudFRpbWUsbGFuZTpjLmxhbmUsdGFnOmMudGFnLHBheWxvYWQ6Yy5wYXlsb2FkLGNhbGxiYWNrOmMuY2FsbGJhY2ssbmV4dDpudWxsfTtudWxsPT09Zj9lPWY9ZzpmPWYubmV4dD1nO2M9Yy5uZXh0fXdoaWxlKG51bGwhPT1jKTtudWxsPT09Zj9lPWY9YjpmPWYubmV4dD1ifWVsc2UgZT1mPWI7Yz17YmFzZVN0YXRlOmQuYmFzZVN0YXRlLGZpcnN0QmFzZVVwZGF0ZTplLGxhc3RCYXNlVXBkYXRlOmYsc2hhcmVkOmQuc2hhcmVkLGVmZmVjdHM6ZC5lZmZlY3RzfTthLnVwZGF0ZVF1ZXVlPWM7cmV0dXJufWE9Yy5sYXN0QmFzZVVwZGF0ZTtudWxsPT09YT9jLmZpcnN0QmFzZVVwZGF0ZT1iOmEubmV4dD1cbmI7Yy5sYXN0QmFzZVVwZGF0ZT1ifVxuZnVuY3Rpb24gQ2coYSxiLGMsZCl7dmFyIGU9YS51cGRhdGVRdWV1ZTt3Zz0hMTt2YXIgZj1lLmZpcnN0QmFzZVVwZGF0ZSxnPWUubGFzdEJhc2VVcGRhdGUsaD1lLnNoYXJlZC5wZW5kaW5nO2lmKG51bGwhPT1oKXtlLnNoYXJlZC5wZW5kaW5nPW51bGw7dmFyIGs9aCxsPWsubmV4dDtrLm5leHQ9bnVsbDtudWxsPT09Zz9mPWw6Zy5uZXh0PWw7Zz1rO3ZhciBuPWEuYWx0ZXJuYXRlO2lmKG51bGwhPT1uKXtuPW4udXBkYXRlUXVldWU7dmFyIEE9bi5sYXN0QmFzZVVwZGF0ZTtBIT09ZyYmKG51bGw9PT1BP24uZmlyc3RCYXNlVXBkYXRlPWw6QS5uZXh0PWwsbi5sYXN0QmFzZVVwZGF0ZT1rKX19aWYobnVsbCE9PWYpe0E9ZS5iYXNlU3RhdGU7Zz0wO249bD1rPW51bGw7ZG97aD1mLmxhbmU7dmFyIHA9Zi5ldmVudFRpbWU7aWYoKGQmaCk9PT1oKXtudWxsIT09biYmKG49bi5uZXh0PXtldmVudFRpbWU6cCxsYW5lOjAsdGFnOmYudGFnLHBheWxvYWQ6Zi5wYXlsb2FkLGNhbGxiYWNrOmYuY2FsbGJhY2ssXG5uZXh0Om51bGx9KTthOnt2YXIgQz1hLHg9ZjtoPWI7cD1jO3N3aXRjaCh4LnRhZyl7Y2FzZSAxOkM9eC5wYXlsb2FkO2lmKFwiZnVuY3Rpb25cIj09PXR5cGVvZiBDKXtBPUMuY2FsbChwLEEsaCk7YnJlYWsgYX1BPUM7YnJlYWsgYTtjYXNlIDM6Qy5mbGFncz1DLmZsYWdzJi00MDk3fDY0O2Nhc2UgMDpDPXgucGF5bG9hZDtoPVwiZnVuY3Rpb25cIj09PXR5cGVvZiBDP0MuY2FsbChwLEEsaCk6QztpZihudWxsPT09aHx8dm9pZCAwPT09aClicmVhayBhO0E9bSh7fSxBLGgpO2JyZWFrIGE7Y2FzZSAyOndnPSEwfX1udWxsIT09Zi5jYWxsYmFjayYmKGEuZmxhZ3N8PTMyLGg9ZS5lZmZlY3RzLG51bGw9PT1oP2UuZWZmZWN0cz1bZl06aC5wdXNoKGYpKX1lbHNlIHA9e2V2ZW50VGltZTpwLGxhbmU6aCx0YWc6Zi50YWcscGF5bG9hZDpmLnBheWxvYWQsY2FsbGJhY2s6Zi5jYWxsYmFjayxuZXh0Om51bGx9LG51bGw9PT1uPyhsPW49cCxrPUEpOm49bi5uZXh0PXAsZ3w9aDtmPWYubmV4dDtpZihudWxsPT09XG5mKWlmKGg9ZS5zaGFyZWQucGVuZGluZyxudWxsPT09aClicmVhaztlbHNlIGY9aC5uZXh0LGgubmV4dD1udWxsLGUubGFzdEJhc2VVcGRhdGU9aCxlLnNoYXJlZC5wZW5kaW5nPW51bGx9d2hpbGUoMSk7bnVsbD09PW4mJihrPUEpO2UuYmFzZVN0YXRlPWs7ZS5maXJzdEJhc2VVcGRhdGU9bDtlLmxhc3RCYXNlVXBkYXRlPW47RGd8PWc7YS5sYW5lcz1nO2EubWVtb2l6ZWRTdGF0ZT1BfX1mdW5jdGlvbiBFZyhhLGIsYyl7YT1iLmVmZmVjdHM7Yi5lZmZlY3RzPW51bGw7aWYobnVsbCE9PWEpZm9yKGI9MDtiPGEubGVuZ3RoO2IrKyl7dmFyIGQ9YVtiXSxlPWQuY2FsbGJhY2s7aWYobnVsbCE9PWUpe2QuY2FsbGJhY2s9bnVsbDtkPWM7aWYoXCJmdW5jdGlvblwiIT09dHlwZW9mIGUpdGhyb3cgRXJyb3IoeSgxOTEsZSkpO2UuY2FsbChkKX19fXZhciBGZz0obmV3IGFhLkNvbXBvbmVudCkucmVmcztcbmZ1bmN0aW9uIEdnKGEsYixjLGQpe2I9YS5tZW1vaXplZFN0YXRlO2M9YyhkLGIpO2M9bnVsbD09PWN8fHZvaWQgMD09PWM/YjptKHt9LGIsYyk7YS5tZW1vaXplZFN0YXRlPWM7MD09PWEubGFuZXMmJihhLnVwZGF0ZVF1ZXVlLmJhc2VTdGF0ZT1jKX1cbnZhciBLZz17aXNNb3VudGVkOmZ1bmN0aW9uKGEpe3JldHVybihhPWEuX3JlYWN0SW50ZXJuYWxzKT9aYihhKT09PWE6ITF9LGVucXVldWVTZXRTdGF0ZTpmdW5jdGlvbihhLGIsYyl7YT1hLl9yZWFjdEludGVybmFsczt2YXIgZD1IZygpLGU9SWcoYSksZj16ZyhkLGUpO2YucGF5bG9hZD1iO3ZvaWQgMCE9PWMmJm51bGwhPT1jJiYoZi5jYWxsYmFjaz1jKTtBZyhhLGYpO0pnKGEsZSxkKX0sZW5xdWV1ZVJlcGxhY2VTdGF0ZTpmdW5jdGlvbihhLGIsYyl7YT1hLl9yZWFjdEludGVybmFsczt2YXIgZD1IZygpLGU9SWcoYSksZj16ZyhkLGUpO2YudGFnPTE7Zi5wYXlsb2FkPWI7dm9pZCAwIT09YyYmbnVsbCE9PWMmJihmLmNhbGxiYWNrPWMpO0FnKGEsZik7SmcoYSxlLGQpfSxlbnF1ZXVlRm9yY2VVcGRhdGU6ZnVuY3Rpb24oYSxiKXthPWEuX3JlYWN0SW50ZXJuYWxzO3ZhciBjPUhnKCksZD1JZyhhKSxlPXpnKGMsZCk7ZS50YWc9Mjt2b2lkIDAhPT1iJiZudWxsIT09YiYmKGUuY2FsbGJhY2s9XG5iKTtBZyhhLGUpO0pnKGEsZCxjKX19O2Z1bmN0aW9uIExnKGEsYixjLGQsZSxmLGcpe2E9YS5zdGF0ZU5vZGU7cmV0dXJuXCJmdW5jdGlvblwiPT09dHlwZW9mIGEuc2hvdWxkQ29tcG9uZW50VXBkYXRlP2Euc2hvdWxkQ29tcG9uZW50VXBkYXRlKGQsZixnKTpiLnByb3RvdHlwZSYmYi5wcm90b3R5cGUuaXNQdXJlUmVhY3RDb21wb25lbnQ/IUplKGMsZCl8fCFKZShlLGYpOiEwfVxuZnVuY3Rpb24gTWcoYSxiLGMpe3ZhciBkPSExLGU9Q2Y7dmFyIGY9Yi5jb250ZXh0VHlwZTtcIm9iamVjdFwiPT09dHlwZW9mIGYmJm51bGwhPT1mP2Y9dmcoZik6KGU9RmYoYik/RGY6TS5jdXJyZW50LGQ9Yi5jb250ZXh0VHlwZXMsZj0oZD1udWxsIT09ZCYmdm9pZCAwIT09ZCk/RWYoYSxlKTpDZik7Yj1uZXcgYihjLGYpO2EubWVtb2l6ZWRTdGF0ZT1udWxsIT09Yi5zdGF0ZSYmdm9pZCAwIT09Yi5zdGF0ZT9iLnN0YXRlOm51bGw7Yi51cGRhdGVyPUtnO2Euc3RhdGVOb2RlPWI7Yi5fcmVhY3RJbnRlcm5hbHM9YTtkJiYoYT1hLnN0YXRlTm9kZSxhLl9fcmVhY3RJbnRlcm5hbE1lbW9pemVkVW5tYXNrZWRDaGlsZENvbnRleHQ9ZSxhLl9fcmVhY3RJbnRlcm5hbE1lbW9pemVkTWFza2VkQ2hpbGRDb250ZXh0PWYpO3JldHVybiBifVxuZnVuY3Rpb24gTmcoYSxiLGMsZCl7YT1iLnN0YXRlO1wiZnVuY3Rpb25cIj09PXR5cGVvZiBiLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMmJmIuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhjLGQpO1wiZnVuY3Rpb25cIj09PXR5cGVvZiBiLlVOU0FGRV9jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzJiZiLlVOU0FGRV9jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKGMsZCk7Yi5zdGF0ZSE9PWEmJktnLmVucXVldWVSZXBsYWNlU3RhdGUoYixiLnN0YXRlLG51bGwpfVxuZnVuY3Rpb24gT2coYSxiLGMsZCl7dmFyIGU9YS5zdGF0ZU5vZGU7ZS5wcm9wcz1jO2Uuc3RhdGU9YS5tZW1vaXplZFN0YXRlO2UucmVmcz1GZzt4ZyhhKTt2YXIgZj1iLmNvbnRleHRUeXBlO1wib2JqZWN0XCI9PT10eXBlb2YgZiYmbnVsbCE9PWY/ZS5jb250ZXh0PXZnKGYpOihmPUZmKGIpP0RmOk0uY3VycmVudCxlLmNvbnRleHQ9RWYoYSxmKSk7Q2coYSxjLGUsZCk7ZS5zdGF0ZT1hLm1lbW9pemVkU3RhdGU7Zj1iLmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcztcImZ1bmN0aW9uXCI9PT10eXBlb2YgZiYmKEdnKGEsYixmLGMpLGUuc3RhdGU9YS5tZW1vaXplZFN0YXRlKTtcImZ1bmN0aW9uXCI9PT10eXBlb2YgYi5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHN8fFwiZnVuY3Rpb25cIj09PXR5cGVvZiBlLmdldFNuYXBzaG90QmVmb3JlVXBkYXRlfHxcImZ1bmN0aW9uXCIhPT10eXBlb2YgZS5VTlNBRkVfY29tcG9uZW50V2lsbE1vdW50JiZcImZ1bmN0aW9uXCIhPT10eXBlb2YgZS5jb21wb25lbnRXaWxsTW91bnR8fFxuKGI9ZS5zdGF0ZSxcImZ1bmN0aW9uXCI9PT10eXBlb2YgZS5jb21wb25lbnRXaWxsTW91bnQmJmUuY29tcG9uZW50V2lsbE1vdW50KCksXCJmdW5jdGlvblwiPT09dHlwZW9mIGUuVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudCYmZS5VTlNBRkVfY29tcG9uZW50V2lsbE1vdW50KCksYiE9PWUuc3RhdGUmJktnLmVucXVldWVSZXBsYWNlU3RhdGUoZSxlLnN0YXRlLG51bGwpLENnKGEsYyxlLGQpLGUuc3RhdGU9YS5tZW1vaXplZFN0YXRlKTtcImZ1bmN0aW9uXCI9PT10eXBlb2YgZS5jb21wb25lbnREaWRNb3VudCYmKGEuZmxhZ3N8PTQpfXZhciBQZz1BcnJheS5pc0FycmF5O1xuZnVuY3Rpb24gUWcoYSxiLGMpe2E9Yy5yZWY7aWYobnVsbCE9PWEmJlwiZnVuY3Rpb25cIiE9PXR5cGVvZiBhJiZcIm9iamVjdFwiIT09dHlwZW9mIGEpe2lmKGMuX293bmVyKXtjPWMuX293bmVyO2lmKGMpe2lmKDEhPT1jLnRhZyl0aHJvdyBFcnJvcih5KDMwOSkpO3ZhciBkPWMuc3RhdGVOb2RlfWlmKCFkKXRocm93IEVycm9yKHkoMTQ3LGEpKTt2YXIgZT1cIlwiK2E7aWYobnVsbCE9PWImJm51bGwhPT1iLnJlZiYmXCJmdW5jdGlvblwiPT09dHlwZW9mIGIucmVmJiZiLnJlZi5fc3RyaW5nUmVmPT09ZSlyZXR1cm4gYi5yZWY7Yj1mdW5jdGlvbihhKXt2YXIgYj1kLnJlZnM7Yj09PUZnJiYoYj1kLnJlZnM9e30pO251bGw9PT1hP2RlbGV0ZSBiW2VdOmJbZV09YX07Yi5fc3RyaW5nUmVmPWU7cmV0dXJuIGJ9aWYoXCJzdHJpbmdcIiE9PXR5cGVvZiBhKXRocm93IEVycm9yKHkoMjg0KSk7aWYoIWMuX293bmVyKXRocm93IEVycm9yKHkoMjkwLGEpKTt9cmV0dXJuIGF9XG5mdW5jdGlvbiBSZyhhLGIpe2lmKFwidGV4dGFyZWFcIiE9PWEudHlwZSl0aHJvdyBFcnJvcih5KDMxLFwiW29iamVjdCBPYmplY3RdXCI9PT1PYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoYik/XCJvYmplY3Qgd2l0aCBrZXlzIHtcIitPYmplY3Qua2V5cyhiKS5qb2luKFwiLCBcIikrXCJ9XCI6YikpO31cbmZ1bmN0aW9uIFNnKGEpe2Z1bmN0aW9uIGIoYixjKXtpZihhKXt2YXIgZD1iLmxhc3RFZmZlY3Q7bnVsbCE9PWQ/KGQubmV4dEVmZmVjdD1jLGIubGFzdEVmZmVjdD1jKTpiLmZpcnN0RWZmZWN0PWIubGFzdEVmZmVjdD1jO2MubmV4dEVmZmVjdD1udWxsO2MuZmxhZ3M9OH19ZnVuY3Rpb24gYyhjLGQpe2lmKCFhKXJldHVybiBudWxsO2Zvcig7bnVsbCE9PWQ7KWIoYyxkKSxkPWQuc2libGluZztyZXR1cm4gbnVsbH1mdW5jdGlvbiBkKGEsYil7Zm9yKGE9bmV3IE1hcDtudWxsIT09YjspbnVsbCE9PWIua2V5P2Euc2V0KGIua2V5LGIpOmEuc2V0KGIuaW5kZXgsYiksYj1iLnNpYmxpbmc7cmV0dXJuIGF9ZnVuY3Rpb24gZShhLGIpe2E9VGcoYSxiKTthLmluZGV4PTA7YS5zaWJsaW5nPW51bGw7cmV0dXJuIGF9ZnVuY3Rpb24gZihiLGMsZCl7Yi5pbmRleD1kO2lmKCFhKXJldHVybiBjO2Q9Yi5hbHRlcm5hdGU7aWYobnVsbCE9PWQpcmV0dXJuIGQ9ZC5pbmRleCxkPGM/KGIuZmxhZ3M9MixcbmMpOmQ7Yi5mbGFncz0yO3JldHVybiBjfWZ1bmN0aW9uIGcoYil7YSYmbnVsbD09PWIuYWx0ZXJuYXRlJiYoYi5mbGFncz0yKTtyZXR1cm4gYn1mdW5jdGlvbiBoKGEsYixjLGQpe2lmKG51bGw9PT1ifHw2IT09Yi50YWcpcmV0dXJuIGI9VWcoYyxhLm1vZGUsZCksYi5yZXR1cm49YSxiO2I9ZShiLGMpO2IucmV0dXJuPWE7cmV0dXJuIGJ9ZnVuY3Rpb24gayhhLGIsYyxkKXtpZihudWxsIT09YiYmYi5lbGVtZW50VHlwZT09PWMudHlwZSlyZXR1cm4gZD1lKGIsYy5wcm9wcyksZC5yZWY9UWcoYSxiLGMpLGQucmV0dXJuPWEsZDtkPVZnKGMudHlwZSxjLmtleSxjLnByb3BzLG51bGwsYS5tb2RlLGQpO2QucmVmPVFnKGEsYixjKTtkLnJldHVybj1hO3JldHVybiBkfWZ1bmN0aW9uIGwoYSxiLGMsZCl7aWYobnVsbD09PWJ8fDQhPT1iLnRhZ3x8Yi5zdGF0ZU5vZGUuY29udGFpbmVySW5mbyE9PWMuY29udGFpbmVySW5mb3x8Yi5zdGF0ZU5vZGUuaW1wbGVtZW50YXRpb24hPT1jLmltcGxlbWVudGF0aW9uKXJldHVybiBiPVxuV2coYyxhLm1vZGUsZCksYi5yZXR1cm49YSxiO2I9ZShiLGMuY2hpbGRyZW58fFtdKTtiLnJldHVybj1hO3JldHVybiBifWZ1bmN0aW9uIG4oYSxiLGMsZCxmKXtpZihudWxsPT09Ynx8NyE9PWIudGFnKXJldHVybiBiPVhnKGMsYS5tb2RlLGQsZiksYi5yZXR1cm49YSxiO2I9ZShiLGMpO2IucmV0dXJuPWE7cmV0dXJuIGJ9ZnVuY3Rpb24gQShhLGIsYyl7aWYoXCJzdHJpbmdcIj09PXR5cGVvZiBifHxcIm51bWJlclwiPT09dHlwZW9mIGIpcmV0dXJuIGI9VWcoXCJcIitiLGEubW9kZSxjKSxiLnJldHVybj1hLGI7aWYoXCJvYmplY3RcIj09PXR5cGVvZiBiJiZudWxsIT09Yil7c3dpdGNoKGIuJCR0eXBlb2Ype2Nhc2Ugc2E6cmV0dXJuIGM9VmcoYi50eXBlLGIua2V5LGIucHJvcHMsbnVsbCxhLm1vZGUsYyksYy5yZWY9UWcoYSxudWxsLGIpLGMucmV0dXJuPWEsYztjYXNlIHRhOnJldHVybiBiPVdnKGIsYS5tb2RlLGMpLGIucmV0dXJuPWEsYn1pZihQZyhiKXx8TGEoYikpcmV0dXJuIGI9WGcoYixcbmEubW9kZSxjLG51bGwpLGIucmV0dXJuPWEsYjtSZyhhLGIpfXJldHVybiBudWxsfWZ1bmN0aW9uIHAoYSxiLGMsZCl7dmFyIGU9bnVsbCE9PWI/Yi5rZXk6bnVsbDtpZihcInN0cmluZ1wiPT09dHlwZW9mIGN8fFwibnVtYmVyXCI9PT10eXBlb2YgYylyZXR1cm4gbnVsbCE9PWU/bnVsbDpoKGEsYixcIlwiK2MsZCk7aWYoXCJvYmplY3RcIj09PXR5cGVvZiBjJiZudWxsIT09Yyl7c3dpdGNoKGMuJCR0eXBlb2Ype2Nhc2Ugc2E6cmV0dXJuIGMua2V5PT09ZT9jLnR5cGU9PT11YT9uKGEsYixjLnByb3BzLmNoaWxkcmVuLGQsZSk6ayhhLGIsYyxkKTpudWxsO2Nhc2UgdGE6cmV0dXJuIGMua2V5PT09ZT9sKGEsYixjLGQpOm51bGx9aWYoUGcoYyl8fExhKGMpKXJldHVybiBudWxsIT09ZT9udWxsOm4oYSxiLGMsZCxudWxsKTtSZyhhLGMpfXJldHVybiBudWxsfWZ1bmN0aW9uIEMoYSxiLGMsZCxlKXtpZihcInN0cmluZ1wiPT09dHlwZW9mIGR8fFwibnVtYmVyXCI9PT10eXBlb2YgZClyZXR1cm4gYT1hLmdldChjKXx8XG5udWxsLGgoYixhLFwiXCIrZCxlKTtpZihcIm9iamVjdFwiPT09dHlwZW9mIGQmJm51bGwhPT1kKXtzd2l0Y2goZC4kJHR5cGVvZil7Y2FzZSBzYTpyZXR1cm4gYT1hLmdldChudWxsPT09ZC5rZXk/YzpkLmtleSl8fG51bGwsZC50eXBlPT09dWE/bihiLGEsZC5wcm9wcy5jaGlsZHJlbixlLGQua2V5KTprKGIsYSxkLGUpO2Nhc2UgdGE6cmV0dXJuIGE9YS5nZXQobnVsbD09PWQua2V5P2M6ZC5rZXkpfHxudWxsLGwoYixhLGQsZSl9aWYoUGcoZCl8fExhKGQpKXJldHVybiBhPWEuZ2V0KGMpfHxudWxsLG4oYixhLGQsZSxudWxsKTtSZyhiLGQpfXJldHVybiBudWxsfWZ1bmN0aW9uIHgoZSxnLGgsayl7Zm9yKHZhciBsPW51bGwsdD1udWxsLHU9Zyx6PWc9MCxxPW51bGw7bnVsbCE9PXUmJno8aC5sZW5ndGg7eisrKXt1LmluZGV4Pno/KHE9dSx1PW51bGwpOnE9dS5zaWJsaW5nO3ZhciBuPXAoZSx1LGhbel0sayk7aWYobnVsbD09PW4pe251bGw9PT11JiYodT1xKTticmVha31hJiZ1JiZudWxsPT09XG5uLmFsdGVybmF0ZSYmYihlLHUpO2c9ZihuLGcseik7bnVsbD09PXQ/bD1uOnQuc2libGluZz1uO3Q9bjt1PXF9aWYoej09PWgubGVuZ3RoKXJldHVybiBjKGUsdSksbDtpZihudWxsPT09dSl7Zm9yKDt6PGgubGVuZ3RoO3orKyl1PUEoZSxoW3pdLGspLG51bGwhPT11JiYoZz1mKHUsZyx6KSxudWxsPT09dD9sPXU6dC5zaWJsaW5nPXUsdD11KTtyZXR1cm4gbH1mb3IodT1kKGUsdSk7ejxoLmxlbmd0aDt6KyspcT1DKHUsZSx6LGhbel0sayksbnVsbCE9PXEmJihhJiZudWxsIT09cS5hbHRlcm5hdGUmJnUuZGVsZXRlKG51bGw9PT1xLmtleT96OnEua2V5KSxnPWYocSxnLHopLG51bGw9PT10P2w9cTp0LnNpYmxpbmc9cSx0PXEpO2EmJnUuZm9yRWFjaChmdW5jdGlvbihhKXtyZXR1cm4gYihlLGEpfSk7cmV0dXJuIGx9ZnVuY3Rpb24gdyhlLGcsaCxrKXt2YXIgbD1MYShoKTtpZihcImZ1bmN0aW9uXCIhPT10eXBlb2YgbCl0aHJvdyBFcnJvcih5KDE1MCkpO2g9bC5jYWxsKGgpO2lmKG51bGw9PVxuaCl0aHJvdyBFcnJvcih5KDE1MSkpO2Zvcih2YXIgdD1sPW51bGwsdT1nLHo9Zz0wLHE9bnVsbCxuPWgubmV4dCgpO251bGwhPT11JiYhbi5kb25lO3orKyxuPWgubmV4dCgpKXt1LmluZGV4Pno/KHE9dSx1PW51bGwpOnE9dS5zaWJsaW5nO3ZhciB3PXAoZSx1LG4udmFsdWUsayk7aWYobnVsbD09PXcpe251bGw9PT11JiYodT1xKTticmVha31hJiZ1JiZudWxsPT09dy5hbHRlcm5hdGUmJmIoZSx1KTtnPWYodyxnLHopO251bGw9PT10P2w9dzp0LnNpYmxpbmc9dzt0PXc7dT1xfWlmKG4uZG9uZSlyZXR1cm4gYyhlLHUpLGw7aWYobnVsbD09PXUpe2Zvcig7IW4uZG9uZTt6Kyssbj1oLm5leHQoKSluPUEoZSxuLnZhbHVlLGspLG51bGwhPT1uJiYoZz1mKG4sZyx6KSxudWxsPT09dD9sPW46dC5zaWJsaW5nPW4sdD1uKTtyZXR1cm4gbH1mb3IodT1kKGUsdSk7IW4uZG9uZTt6Kyssbj1oLm5leHQoKSluPUModSxlLHosbi52YWx1ZSxrKSxudWxsIT09biYmKGEmJm51bGwhPT1uLmFsdGVybmF0ZSYmXG51LmRlbGV0ZShudWxsPT09bi5rZXk/ejpuLmtleSksZz1mKG4sZyx6KSxudWxsPT09dD9sPW46dC5zaWJsaW5nPW4sdD1uKTthJiZ1LmZvckVhY2goZnVuY3Rpb24oYSl7cmV0dXJuIGIoZSxhKX0pO3JldHVybiBsfXJldHVybiBmdW5jdGlvbihhLGQsZixoKXt2YXIgaz1cIm9iamVjdFwiPT09dHlwZW9mIGYmJm51bGwhPT1mJiZmLnR5cGU9PT11YSYmbnVsbD09PWYua2V5O2smJihmPWYucHJvcHMuY2hpbGRyZW4pO3ZhciBsPVwib2JqZWN0XCI9PT10eXBlb2YgZiYmbnVsbCE9PWY7aWYobClzd2l0Y2goZi4kJHR5cGVvZil7Y2FzZSBzYTphOntsPWYua2V5O2ZvcihrPWQ7bnVsbCE9PWs7KXtpZihrLmtleT09PWwpe3N3aXRjaChrLnRhZyl7Y2FzZSA3OmlmKGYudHlwZT09PXVhKXtjKGEsay5zaWJsaW5nKTtkPWUoayxmLnByb3BzLmNoaWxkcmVuKTtkLnJldHVybj1hO2E9ZDticmVhayBhfWJyZWFrO2RlZmF1bHQ6aWYoay5lbGVtZW50VHlwZT09PWYudHlwZSl7YyhhLGsuc2libGluZyk7XG5kPWUoayxmLnByb3BzKTtkLnJlZj1RZyhhLGssZik7ZC5yZXR1cm49YTthPWQ7YnJlYWsgYX19YyhhLGspO2JyZWFrfWVsc2UgYihhLGspO2s9ay5zaWJsaW5nfWYudHlwZT09PXVhPyhkPVhnKGYucHJvcHMuY2hpbGRyZW4sYS5tb2RlLGgsZi5rZXkpLGQucmV0dXJuPWEsYT1kKTooaD1WZyhmLnR5cGUsZi5rZXksZi5wcm9wcyxudWxsLGEubW9kZSxoKSxoLnJlZj1RZyhhLGQsZiksaC5yZXR1cm49YSxhPWgpfXJldHVybiBnKGEpO2Nhc2UgdGE6YTp7Zm9yKGs9Zi5rZXk7bnVsbCE9PWQ7KXtpZihkLmtleT09PWspaWYoND09PWQudGFnJiZkLnN0YXRlTm9kZS5jb250YWluZXJJbmZvPT09Zi5jb250YWluZXJJbmZvJiZkLnN0YXRlTm9kZS5pbXBsZW1lbnRhdGlvbj09PWYuaW1wbGVtZW50YXRpb24pe2MoYSxkLnNpYmxpbmcpO2Q9ZShkLGYuY2hpbGRyZW58fFtdKTtkLnJldHVybj1hO2E9ZDticmVhayBhfWVsc2V7YyhhLGQpO2JyZWFrfWVsc2UgYihhLGQpO2Q9ZC5zaWJsaW5nfWQ9XG5XZyhmLGEubW9kZSxoKTtkLnJldHVybj1hO2E9ZH1yZXR1cm4gZyhhKX1pZihcInN0cmluZ1wiPT09dHlwZW9mIGZ8fFwibnVtYmVyXCI9PT10eXBlb2YgZilyZXR1cm4gZj1cIlwiK2YsbnVsbCE9PWQmJjY9PT1kLnRhZz8oYyhhLGQuc2libGluZyksZD1lKGQsZiksZC5yZXR1cm49YSxhPWQpOihjKGEsZCksZD1VZyhmLGEubW9kZSxoKSxkLnJldHVybj1hLGE9ZCksZyhhKTtpZihQZyhmKSlyZXR1cm4geChhLGQsZixoKTtpZihMYShmKSlyZXR1cm4gdyhhLGQsZixoKTtsJiZSZyhhLGYpO2lmKFwidW5kZWZpbmVkXCI9PT10eXBlb2YgZiYmIWspc3dpdGNoKGEudGFnKXtjYXNlIDE6Y2FzZSAyMjpjYXNlIDA6Y2FzZSAxMTpjYXNlIDE1OnRocm93IEVycm9yKHkoMTUyLFJhKGEudHlwZSl8fFwiQ29tcG9uZW50XCIpKTt9cmV0dXJuIGMoYSxkKX19dmFyIFlnPVNnKCEwKSxaZz1TZyghMSksJGc9e30sYWg9QmYoJGcpLGJoPUJmKCRnKSxjaD1CZigkZyk7XG5mdW5jdGlvbiBkaChhKXtpZihhPT09JGcpdGhyb3cgRXJyb3IoeSgxNzQpKTtyZXR1cm4gYX1mdW5jdGlvbiBlaChhLGIpe0koY2gsYik7SShiaCxhKTtJKGFoLCRnKTthPWIubm9kZVR5cGU7c3dpdGNoKGEpe2Nhc2UgOTpjYXNlIDExOmI9KGI9Yi5kb2N1bWVudEVsZW1lbnQpP2IubmFtZXNwYWNlVVJJOm1iKG51bGwsXCJcIik7YnJlYWs7ZGVmYXVsdDphPTg9PT1hP2IucGFyZW50Tm9kZTpiLGI9YS5uYW1lc3BhY2VVUkl8fG51bGwsYT1hLnRhZ05hbWUsYj1tYihiLGEpfUgoYWgpO0koYWgsYil9ZnVuY3Rpb24gZmgoKXtIKGFoKTtIKGJoKTtIKGNoKX1mdW5jdGlvbiBnaChhKXtkaChjaC5jdXJyZW50KTt2YXIgYj1kaChhaC5jdXJyZW50KTt2YXIgYz1tYihiLGEudHlwZSk7YiE9PWMmJihJKGJoLGEpLEkoYWgsYykpfWZ1bmN0aW9uIGhoKGEpe2JoLmN1cnJlbnQ9PT1hJiYoSChhaCksSChiaCkpfXZhciBQPUJmKDApO1xuZnVuY3Rpb24gaWgoYSl7Zm9yKHZhciBiPWE7bnVsbCE9PWI7KXtpZigxMz09PWIudGFnKXt2YXIgYz1iLm1lbW9pemVkU3RhdGU7aWYobnVsbCE9PWMmJihjPWMuZGVoeWRyYXRlZCxudWxsPT09Y3x8XCIkP1wiPT09Yy5kYXRhfHxcIiQhXCI9PT1jLmRhdGEpKXJldHVybiBifWVsc2UgaWYoMTk9PT1iLnRhZyYmdm9pZCAwIT09Yi5tZW1vaXplZFByb3BzLnJldmVhbE9yZGVyKXtpZigwIT09KGIuZmxhZ3MmNjQpKXJldHVybiBifWVsc2UgaWYobnVsbCE9PWIuY2hpbGQpe2IuY2hpbGQucmV0dXJuPWI7Yj1iLmNoaWxkO2NvbnRpbnVlfWlmKGI9PT1hKWJyZWFrO2Zvcig7bnVsbD09PWIuc2libGluZzspe2lmKG51bGw9PT1iLnJldHVybnx8Yi5yZXR1cm49PT1hKXJldHVybiBudWxsO2I9Yi5yZXR1cm59Yi5zaWJsaW5nLnJldHVybj1iLnJldHVybjtiPWIuc2libGluZ31yZXR1cm4gbnVsbH12YXIgamg9bnVsbCxraD1udWxsLGxoPSExO1xuZnVuY3Rpb24gbWgoYSxiKXt2YXIgYz1uaCg1LG51bGwsbnVsbCwwKTtjLmVsZW1lbnRUeXBlPVwiREVMRVRFRFwiO2MudHlwZT1cIkRFTEVURURcIjtjLnN0YXRlTm9kZT1iO2MucmV0dXJuPWE7Yy5mbGFncz04O251bGwhPT1hLmxhc3RFZmZlY3Q/KGEubGFzdEVmZmVjdC5uZXh0RWZmZWN0PWMsYS5sYXN0RWZmZWN0PWMpOmEuZmlyc3RFZmZlY3Q9YS5sYXN0RWZmZWN0PWN9ZnVuY3Rpb24gb2goYSxiKXtzd2l0Y2goYS50YWcpe2Nhc2UgNTp2YXIgYz1hLnR5cGU7Yj0xIT09Yi5ub2RlVHlwZXx8Yy50b0xvd2VyQ2FzZSgpIT09Yi5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpP251bGw6YjtyZXR1cm4gbnVsbCE9PWI/KGEuc3RhdGVOb2RlPWIsITApOiExO2Nhc2UgNjpyZXR1cm4gYj1cIlwiPT09YS5wZW5kaW5nUHJvcHN8fDMhPT1iLm5vZGVUeXBlP251bGw6YixudWxsIT09Yj8oYS5zdGF0ZU5vZGU9YiwhMCk6ITE7Y2FzZSAxMzpyZXR1cm4hMTtkZWZhdWx0OnJldHVybiExfX1cbmZ1bmN0aW9uIHBoKGEpe2lmKGxoKXt2YXIgYj1raDtpZihiKXt2YXIgYz1iO2lmKCFvaChhLGIpKXtiPXJmKGMubmV4dFNpYmxpbmcpO2lmKCFifHwhb2goYSxiKSl7YS5mbGFncz1hLmZsYWdzJi0xMDI1fDI7bGg9ITE7amg9YTtyZXR1cm59bWgoamgsYyl9amg9YTtraD1yZihiLmZpcnN0Q2hpbGQpfWVsc2UgYS5mbGFncz1hLmZsYWdzJi0xMDI1fDIsbGg9ITEsamg9YX19ZnVuY3Rpb24gcWgoYSl7Zm9yKGE9YS5yZXR1cm47bnVsbCE9PWEmJjUhPT1hLnRhZyYmMyE9PWEudGFnJiYxMyE9PWEudGFnOylhPWEucmV0dXJuO2poPWF9XG5mdW5jdGlvbiByaChhKXtpZihhIT09amgpcmV0dXJuITE7aWYoIWxoKXJldHVybiBxaChhKSxsaD0hMCwhMTt2YXIgYj1hLnR5cGU7aWYoNSE9PWEudGFnfHxcImhlYWRcIiE9PWImJlwiYm9keVwiIT09YiYmIW5mKGIsYS5tZW1vaXplZFByb3BzKSlmb3IoYj1raDtiOyltaChhLGIpLGI9cmYoYi5uZXh0U2libGluZyk7cWgoYSk7aWYoMTM9PT1hLnRhZyl7YT1hLm1lbW9pemVkU3RhdGU7YT1udWxsIT09YT9hLmRlaHlkcmF0ZWQ6bnVsbDtpZighYSl0aHJvdyBFcnJvcih5KDMxNykpO2E6e2E9YS5uZXh0U2libGluZztmb3IoYj0wO2E7KXtpZig4PT09YS5ub2RlVHlwZSl7dmFyIGM9YS5kYXRhO2lmKFwiLyRcIj09PWMpe2lmKDA9PT1iKXtraD1yZihhLm5leHRTaWJsaW5nKTticmVhayBhfWItLX1lbHNlXCIkXCIhPT1jJiZcIiQhXCIhPT1jJiZcIiQ/XCIhPT1jfHxiKyt9YT1hLm5leHRTaWJsaW5nfWtoPW51bGx9fWVsc2Uga2g9amg/cmYoYS5zdGF0ZU5vZGUubmV4dFNpYmxpbmcpOm51bGw7cmV0dXJuITB9XG5mdW5jdGlvbiBzaCgpe2toPWpoPW51bGw7bGg9ITF9dmFyIHRoPVtdO2Z1bmN0aW9uIHVoKCl7Zm9yKHZhciBhPTA7YTx0aC5sZW5ndGg7YSsrKXRoW2FdLl93b3JrSW5Qcm9ncmVzc1ZlcnNpb25QcmltYXJ5PW51bGw7dGgubGVuZ3RoPTB9dmFyIHZoPXJhLlJlYWN0Q3VycmVudERpc3BhdGNoZXIsd2g9cmEuUmVhY3RDdXJyZW50QmF0Y2hDb25maWcseGg9MCxSPW51bGwsUz1udWxsLFQ9bnVsbCx5aD0hMSx6aD0hMTtmdW5jdGlvbiBBaCgpe3Rocm93IEVycm9yKHkoMzIxKSk7fWZ1bmN0aW9uIEJoKGEsYil7aWYobnVsbD09PWIpcmV0dXJuITE7Zm9yKHZhciBjPTA7YzxiLmxlbmd0aCYmYzxhLmxlbmd0aDtjKyspaWYoIUhlKGFbY10sYltjXSkpcmV0dXJuITE7cmV0dXJuITB9XG5mdW5jdGlvbiBDaChhLGIsYyxkLGUsZil7eGg9ZjtSPWI7Yi5tZW1vaXplZFN0YXRlPW51bGw7Yi51cGRhdGVRdWV1ZT1udWxsO2IubGFuZXM9MDt2aC5jdXJyZW50PW51bGw9PT1hfHxudWxsPT09YS5tZW1vaXplZFN0YXRlP0RoOkVoO2E9YyhkLGUpO2lmKHpoKXtmPTA7ZG97emg9ITE7aWYoISgyNT5mKSl0aHJvdyBFcnJvcih5KDMwMSkpO2YrPTE7VD1TPW51bGw7Yi51cGRhdGVRdWV1ZT1udWxsO3ZoLmN1cnJlbnQ9Rmg7YT1jKGQsZSl9d2hpbGUoemgpfXZoLmN1cnJlbnQ9R2g7Yj1udWxsIT09UyYmbnVsbCE9PVMubmV4dDt4aD0wO1Q9Uz1SPW51bGw7eWg9ITE7aWYoYil0aHJvdyBFcnJvcih5KDMwMCkpO3JldHVybiBhfWZ1bmN0aW9uIEhoKCl7dmFyIGE9e21lbW9pemVkU3RhdGU6bnVsbCxiYXNlU3RhdGU6bnVsbCxiYXNlUXVldWU6bnVsbCxxdWV1ZTpudWxsLG5leHQ6bnVsbH07bnVsbD09PVQ/Ui5tZW1vaXplZFN0YXRlPVQ9YTpUPVQubmV4dD1hO3JldHVybiBUfVxuZnVuY3Rpb24gSWgoKXtpZihudWxsPT09Uyl7dmFyIGE9Ui5hbHRlcm5hdGU7YT1udWxsIT09YT9hLm1lbW9pemVkU3RhdGU6bnVsbH1lbHNlIGE9Uy5uZXh0O3ZhciBiPW51bGw9PT1UP1IubWVtb2l6ZWRTdGF0ZTpULm5leHQ7aWYobnVsbCE9PWIpVD1iLFM9YTtlbHNle2lmKG51bGw9PT1hKXRocm93IEVycm9yKHkoMzEwKSk7Uz1hO2E9e21lbW9pemVkU3RhdGU6Uy5tZW1vaXplZFN0YXRlLGJhc2VTdGF0ZTpTLmJhc2VTdGF0ZSxiYXNlUXVldWU6Uy5iYXNlUXVldWUscXVldWU6Uy5xdWV1ZSxuZXh0Om51bGx9O251bGw9PT1UP1IubWVtb2l6ZWRTdGF0ZT1UPWE6VD1ULm5leHQ9YX1yZXR1cm4gVH1mdW5jdGlvbiBKaChhLGIpe3JldHVyblwiZnVuY3Rpb25cIj09PXR5cGVvZiBiP2IoYSk6Yn1cbmZ1bmN0aW9uIEtoKGEpe3ZhciBiPUloKCksYz1iLnF1ZXVlO2lmKG51bGw9PT1jKXRocm93IEVycm9yKHkoMzExKSk7Yy5sYXN0UmVuZGVyZWRSZWR1Y2VyPWE7dmFyIGQ9UyxlPWQuYmFzZVF1ZXVlLGY9Yy5wZW5kaW5nO2lmKG51bGwhPT1mKXtpZihudWxsIT09ZSl7dmFyIGc9ZS5uZXh0O2UubmV4dD1mLm5leHQ7Zi5uZXh0PWd9ZC5iYXNlUXVldWU9ZT1mO2MucGVuZGluZz1udWxsfWlmKG51bGwhPT1lKXtlPWUubmV4dDtkPWQuYmFzZVN0YXRlO3ZhciBoPWc9Zj1udWxsLGs9ZTtkb3t2YXIgbD1rLmxhbmU7aWYoKHhoJmwpPT09bCludWxsIT09aCYmKGg9aC5uZXh0PXtsYW5lOjAsYWN0aW9uOmsuYWN0aW9uLGVhZ2VyUmVkdWNlcjprLmVhZ2VyUmVkdWNlcixlYWdlclN0YXRlOmsuZWFnZXJTdGF0ZSxuZXh0Om51bGx9KSxkPWsuZWFnZXJSZWR1Y2VyPT09YT9rLmVhZ2VyU3RhdGU6YShkLGsuYWN0aW9uKTtlbHNle3ZhciBuPXtsYW5lOmwsYWN0aW9uOmsuYWN0aW9uLGVhZ2VyUmVkdWNlcjprLmVhZ2VyUmVkdWNlcixcbmVhZ2VyU3RhdGU6ay5lYWdlclN0YXRlLG5leHQ6bnVsbH07bnVsbD09PWg/KGc9aD1uLGY9ZCk6aD1oLm5leHQ9bjtSLmxhbmVzfD1sO0RnfD1sfWs9ay5uZXh0fXdoaWxlKG51bGwhPT1rJiZrIT09ZSk7bnVsbD09PWg/Zj1kOmgubmV4dD1nO0hlKGQsYi5tZW1vaXplZFN0YXRlKXx8KHVnPSEwKTtiLm1lbW9pemVkU3RhdGU9ZDtiLmJhc2VTdGF0ZT1mO2IuYmFzZVF1ZXVlPWg7Yy5sYXN0UmVuZGVyZWRTdGF0ZT1kfXJldHVybltiLm1lbW9pemVkU3RhdGUsYy5kaXNwYXRjaF19XG5mdW5jdGlvbiBMaChhKXt2YXIgYj1JaCgpLGM9Yi5xdWV1ZTtpZihudWxsPT09Yyl0aHJvdyBFcnJvcih5KDMxMSkpO2MubGFzdFJlbmRlcmVkUmVkdWNlcj1hO3ZhciBkPWMuZGlzcGF0Y2gsZT1jLnBlbmRpbmcsZj1iLm1lbW9pemVkU3RhdGU7aWYobnVsbCE9PWUpe2MucGVuZGluZz1udWxsO3ZhciBnPWU9ZS5uZXh0O2RvIGY9YShmLGcuYWN0aW9uKSxnPWcubmV4dDt3aGlsZShnIT09ZSk7SGUoZixiLm1lbW9pemVkU3RhdGUpfHwodWc9ITApO2IubWVtb2l6ZWRTdGF0ZT1mO251bGw9PT1iLmJhc2VRdWV1ZSYmKGIuYmFzZVN0YXRlPWYpO2MubGFzdFJlbmRlcmVkU3RhdGU9Zn1yZXR1cm5bZixkXX1cbmZ1bmN0aW9uIE1oKGEsYixjKXt2YXIgZD1iLl9nZXRWZXJzaW9uO2Q9ZChiLl9zb3VyY2UpO3ZhciBlPWIuX3dvcmtJblByb2dyZXNzVmVyc2lvblByaW1hcnk7aWYobnVsbCE9PWUpYT1lPT09ZDtlbHNlIGlmKGE9YS5tdXRhYmxlUmVhZExhbmVzLGE9KHhoJmEpPT09YSliLl93b3JrSW5Qcm9ncmVzc1ZlcnNpb25QcmltYXJ5PWQsdGgucHVzaChiKTtpZihhKXJldHVybiBjKGIuX3NvdXJjZSk7dGgucHVzaChiKTt0aHJvdyBFcnJvcih5KDM1MCkpO31cbmZ1bmN0aW9uIE5oKGEsYixjLGQpe3ZhciBlPVU7aWYobnVsbD09PWUpdGhyb3cgRXJyb3IoeSgzNDkpKTt2YXIgZj1iLl9nZXRWZXJzaW9uLGc9ZihiLl9zb3VyY2UpLGg9dmguY3VycmVudCxrPWgudXNlU3RhdGUoZnVuY3Rpb24oKXtyZXR1cm4gTWgoZSxiLGMpfSksbD1rWzFdLG49a1swXTtrPVQ7dmFyIEE9YS5tZW1vaXplZFN0YXRlLHA9QS5yZWZzLEM9cC5nZXRTbmFwc2hvdCx4PUEuc291cmNlO0E9QS5zdWJzY3JpYmU7dmFyIHc9UjthLm1lbW9pemVkU3RhdGU9e3JlZnM6cCxzb3VyY2U6YixzdWJzY3JpYmU6ZH07aC51c2VFZmZlY3QoZnVuY3Rpb24oKXtwLmdldFNuYXBzaG90PWM7cC5zZXRTbmFwc2hvdD1sO3ZhciBhPWYoYi5fc291cmNlKTtpZighSGUoZyxhKSl7YT1jKGIuX3NvdXJjZSk7SGUobixhKXx8KGwoYSksYT1JZyh3KSxlLm11dGFibGVSZWFkTGFuZXN8PWEmZS5wZW5kaW5nTGFuZXMpO2E9ZS5tdXRhYmxlUmVhZExhbmVzO2UuZW50YW5nbGVkTGFuZXN8PWE7Zm9yKHZhciBkPVxuZS5lbnRhbmdsZW1lbnRzLGg9YTswPGg7KXt2YXIgaz0zMS1WYyhoKSx2PTE8PGs7ZFtrXXw9YTtoJj1+dn19fSxbYyxiLGRdKTtoLnVzZUVmZmVjdChmdW5jdGlvbigpe3JldHVybiBkKGIuX3NvdXJjZSxmdW5jdGlvbigpe3ZhciBhPXAuZ2V0U25hcHNob3QsYz1wLnNldFNuYXBzaG90O3RyeXtjKGEoYi5fc291cmNlKSk7dmFyIGQ9SWcodyk7ZS5tdXRhYmxlUmVhZExhbmVzfD1kJmUucGVuZGluZ0xhbmVzfWNhdGNoKHEpe2MoZnVuY3Rpb24oKXt0aHJvdyBxO30pfX0pfSxbYixkXSk7SGUoQyxjKSYmSGUoeCxiKSYmSGUoQSxkKXx8KGE9e3BlbmRpbmc6bnVsbCxkaXNwYXRjaDpudWxsLGxhc3RSZW5kZXJlZFJlZHVjZXI6SmgsbGFzdFJlbmRlcmVkU3RhdGU6bn0sYS5kaXNwYXRjaD1sPU9oLmJpbmQobnVsbCxSLGEpLGsucXVldWU9YSxrLmJhc2VRdWV1ZT1udWxsLG49TWgoZSxiLGMpLGsubWVtb2l6ZWRTdGF0ZT1rLmJhc2VTdGF0ZT1uKTtyZXR1cm4gbn1cbmZ1bmN0aW9uIFBoKGEsYixjKXt2YXIgZD1JaCgpO3JldHVybiBOaChkLGEsYixjKX1mdW5jdGlvbiBRaChhKXt2YXIgYj1IaCgpO1wiZnVuY3Rpb25cIj09PXR5cGVvZiBhJiYoYT1hKCkpO2IubWVtb2l6ZWRTdGF0ZT1iLmJhc2VTdGF0ZT1hO2E9Yi5xdWV1ZT17cGVuZGluZzpudWxsLGRpc3BhdGNoOm51bGwsbGFzdFJlbmRlcmVkUmVkdWNlcjpKaCxsYXN0UmVuZGVyZWRTdGF0ZTphfTthPWEuZGlzcGF0Y2g9T2guYmluZChudWxsLFIsYSk7cmV0dXJuW2IubWVtb2l6ZWRTdGF0ZSxhXX1cbmZ1bmN0aW9uIFJoKGEsYixjLGQpe2E9e3RhZzphLGNyZWF0ZTpiLGRlc3Ryb3k6YyxkZXBzOmQsbmV4dDpudWxsfTtiPVIudXBkYXRlUXVldWU7bnVsbD09PWI/KGI9e2xhc3RFZmZlY3Q6bnVsbH0sUi51cGRhdGVRdWV1ZT1iLGIubGFzdEVmZmVjdD1hLm5leHQ9YSk6KGM9Yi5sYXN0RWZmZWN0LG51bGw9PT1jP2IubGFzdEVmZmVjdD1hLm5leHQ9YTooZD1jLm5leHQsYy5uZXh0PWEsYS5uZXh0PWQsYi5sYXN0RWZmZWN0PWEpKTtyZXR1cm4gYX1mdW5jdGlvbiBTaChhKXt2YXIgYj1IaCgpO2E9e2N1cnJlbnQ6YX07cmV0dXJuIGIubWVtb2l6ZWRTdGF0ZT1hfWZ1bmN0aW9uIFRoKCl7cmV0dXJuIEloKCkubWVtb2l6ZWRTdGF0ZX1mdW5jdGlvbiBVaChhLGIsYyxkKXt2YXIgZT1IaCgpO1IuZmxhZ3N8PWE7ZS5tZW1vaXplZFN0YXRlPVJoKDF8YixjLHZvaWQgMCx2b2lkIDA9PT1kP251bGw6ZCl9XG5mdW5jdGlvbiBWaChhLGIsYyxkKXt2YXIgZT1JaCgpO2Q9dm9pZCAwPT09ZD9udWxsOmQ7dmFyIGY9dm9pZCAwO2lmKG51bGwhPT1TKXt2YXIgZz1TLm1lbW9pemVkU3RhdGU7Zj1nLmRlc3Ryb3k7aWYobnVsbCE9PWQmJkJoKGQsZy5kZXBzKSl7UmgoYixjLGYsZCk7cmV0dXJufX1SLmZsYWdzfD1hO2UubWVtb2l6ZWRTdGF0ZT1SaCgxfGIsYyxmLGQpfWZ1bmN0aW9uIFdoKGEsYil7cmV0dXJuIFVoKDUxNiw0LGEsYil9ZnVuY3Rpb24gWGgoYSxiKXtyZXR1cm4gVmgoNTE2LDQsYSxiKX1mdW5jdGlvbiBZaChhLGIpe3JldHVybiBWaCg0LDIsYSxiKX1mdW5jdGlvbiBaaChhLGIpe2lmKFwiZnVuY3Rpb25cIj09PXR5cGVvZiBiKXJldHVybiBhPWEoKSxiKGEpLGZ1bmN0aW9uKCl7YihudWxsKX07aWYobnVsbCE9PWImJnZvaWQgMCE9PWIpcmV0dXJuIGE9YSgpLGIuY3VycmVudD1hLGZ1bmN0aW9uKCl7Yi5jdXJyZW50PW51bGx9fVxuZnVuY3Rpb24gJGgoYSxiLGMpe2M9bnVsbCE9PWMmJnZvaWQgMCE9PWM/Yy5jb25jYXQoW2FdKTpudWxsO3JldHVybiBWaCg0LDIsWmguYmluZChudWxsLGIsYSksYyl9ZnVuY3Rpb24gYWkoKXt9ZnVuY3Rpb24gYmkoYSxiKXt2YXIgYz1JaCgpO2I9dm9pZCAwPT09Yj9udWxsOmI7dmFyIGQ9Yy5tZW1vaXplZFN0YXRlO2lmKG51bGwhPT1kJiZudWxsIT09YiYmQmgoYixkWzFdKSlyZXR1cm4gZFswXTtjLm1lbW9pemVkU3RhdGU9W2EsYl07cmV0dXJuIGF9ZnVuY3Rpb24gY2koYSxiKXt2YXIgYz1JaCgpO2I9dm9pZCAwPT09Yj9udWxsOmI7dmFyIGQ9Yy5tZW1vaXplZFN0YXRlO2lmKG51bGwhPT1kJiZudWxsIT09YiYmQmgoYixkWzFdKSlyZXR1cm4gZFswXTthPWEoKTtjLm1lbW9pemVkU3RhdGU9W2EsYl07cmV0dXJuIGF9XG5mdW5jdGlvbiBkaShhLGIpe3ZhciBjPWVnKCk7Z2coOTg+Yz85ODpjLGZ1bmN0aW9uKCl7YSghMCl9KTtnZyg5NzxjPzk3OmMsZnVuY3Rpb24oKXt2YXIgYz13aC50cmFuc2l0aW9uO3doLnRyYW5zaXRpb249MTt0cnl7YSghMSksYigpfWZpbmFsbHl7d2gudHJhbnNpdGlvbj1jfX0pfVxuZnVuY3Rpb24gT2goYSxiLGMpe3ZhciBkPUhnKCksZT1JZyhhKSxmPXtsYW5lOmUsYWN0aW9uOmMsZWFnZXJSZWR1Y2VyOm51bGwsZWFnZXJTdGF0ZTpudWxsLG5leHQ6bnVsbH0sZz1iLnBlbmRpbmc7bnVsbD09PWc/Zi5uZXh0PWY6KGYubmV4dD1nLm5leHQsZy5uZXh0PWYpO2IucGVuZGluZz1mO2c9YS5hbHRlcm5hdGU7aWYoYT09PVJ8fG51bGwhPT1nJiZnPT09Uil6aD15aD0hMDtlbHNle2lmKDA9PT1hLmxhbmVzJiYobnVsbD09PWd8fDA9PT1nLmxhbmVzKSYmKGc9Yi5sYXN0UmVuZGVyZWRSZWR1Y2VyLG51bGwhPT1nKSl0cnl7dmFyIGg9Yi5sYXN0UmVuZGVyZWRTdGF0ZSxrPWcoaCxjKTtmLmVhZ2VyUmVkdWNlcj1nO2YuZWFnZXJTdGF0ZT1rO2lmKEhlKGssaCkpcmV0dXJufWNhdGNoKGwpe31maW5hbGx5e31KZyhhLGUsZCl9fVxudmFyIEdoPXtyZWFkQ29udGV4dDp2Zyx1c2VDYWxsYmFjazpBaCx1c2VDb250ZXh0OkFoLHVzZUVmZmVjdDpBaCx1c2VJbXBlcmF0aXZlSGFuZGxlOkFoLHVzZUxheW91dEVmZmVjdDpBaCx1c2VNZW1vOkFoLHVzZVJlZHVjZXI6QWgsdXNlUmVmOkFoLHVzZVN0YXRlOkFoLHVzZURlYnVnVmFsdWU6QWgsdXNlRGVmZXJyZWRWYWx1ZTpBaCx1c2VUcmFuc2l0aW9uOkFoLHVzZU11dGFibGVTb3VyY2U6QWgsdXNlT3BhcXVlSWRlbnRpZmllcjpBaCx1bnN0YWJsZV9pc05ld1JlY29uY2lsZXI6ITF9LERoPXtyZWFkQ29udGV4dDp2Zyx1c2VDYWxsYmFjazpmdW5jdGlvbihhLGIpe0hoKCkubWVtb2l6ZWRTdGF0ZT1bYSx2b2lkIDA9PT1iP251bGw6Yl07cmV0dXJuIGF9LHVzZUNvbnRleHQ6dmcsdXNlRWZmZWN0OldoLHVzZUltcGVyYXRpdmVIYW5kbGU6ZnVuY3Rpb24oYSxiLGMpe2M9bnVsbCE9PWMmJnZvaWQgMCE9PWM/Yy5jb25jYXQoW2FdKTpudWxsO3JldHVybiBVaCg0LDIsWmguYmluZChudWxsLFxuYixhKSxjKX0sdXNlTGF5b3V0RWZmZWN0OmZ1bmN0aW9uKGEsYil7cmV0dXJuIFVoKDQsMixhLGIpfSx1c2VNZW1vOmZ1bmN0aW9uKGEsYil7dmFyIGM9SGgoKTtiPXZvaWQgMD09PWI/bnVsbDpiO2E9YSgpO2MubWVtb2l6ZWRTdGF0ZT1bYSxiXTtyZXR1cm4gYX0sdXNlUmVkdWNlcjpmdW5jdGlvbihhLGIsYyl7dmFyIGQ9SGgoKTtiPXZvaWQgMCE9PWM/YyhiKTpiO2QubWVtb2l6ZWRTdGF0ZT1kLmJhc2VTdGF0ZT1iO2E9ZC5xdWV1ZT17cGVuZGluZzpudWxsLGRpc3BhdGNoOm51bGwsbGFzdFJlbmRlcmVkUmVkdWNlcjphLGxhc3RSZW5kZXJlZFN0YXRlOmJ9O2E9YS5kaXNwYXRjaD1PaC5iaW5kKG51bGwsUixhKTtyZXR1cm5bZC5tZW1vaXplZFN0YXRlLGFdfSx1c2VSZWY6U2gsdXNlU3RhdGU6UWgsdXNlRGVidWdWYWx1ZTphaSx1c2VEZWZlcnJlZFZhbHVlOmZ1bmN0aW9uKGEpe3ZhciBiPVFoKGEpLGM9YlswXSxkPWJbMV07V2goZnVuY3Rpb24oKXt2YXIgYj13aC50cmFuc2l0aW9uO1xud2gudHJhbnNpdGlvbj0xO3RyeXtkKGEpfWZpbmFsbHl7d2gudHJhbnNpdGlvbj1ifX0sW2FdKTtyZXR1cm4gY30sdXNlVHJhbnNpdGlvbjpmdW5jdGlvbigpe3ZhciBhPVFoKCExKSxiPWFbMF07YT1kaS5iaW5kKG51bGwsYVsxXSk7U2goYSk7cmV0dXJuW2EsYl19LHVzZU11dGFibGVTb3VyY2U6ZnVuY3Rpb24oYSxiLGMpe3ZhciBkPUhoKCk7ZC5tZW1vaXplZFN0YXRlPXtyZWZzOntnZXRTbmFwc2hvdDpiLHNldFNuYXBzaG90Om51bGx9LHNvdXJjZTphLHN1YnNjcmliZTpjfTtyZXR1cm4gTmgoZCxhLGIsYyl9LHVzZU9wYXF1ZUlkZW50aWZpZXI6ZnVuY3Rpb24oKXtpZihsaCl7dmFyIGE9ITEsYj11ZihmdW5jdGlvbigpe2F8fChhPSEwLGMoXCJyOlwiKyh0ZisrKS50b1N0cmluZygzNikpKTt0aHJvdyBFcnJvcih5KDM1NSkpO30pLGM9UWgoYilbMV07MD09PShSLm1vZGUmMikmJihSLmZsYWdzfD01MTYsUmgoNSxmdW5jdGlvbigpe2MoXCJyOlwiKyh0ZisrKS50b1N0cmluZygzNikpfSxcbnZvaWQgMCxudWxsKSk7cmV0dXJuIGJ9Yj1cInI6XCIrKHRmKyspLnRvU3RyaW5nKDM2KTtRaChiKTtyZXR1cm4gYn0sdW5zdGFibGVfaXNOZXdSZWNvbmNpbGVyOiExfSxFaD17cmVhZENvbnRleHQ6dmcsdXNlQ2FsbGJhY2s6YmksdXNlQ29udGV4dDp2Zyx1c2VFZmZlY3Q6WGgsdXNlSW1wZXJhdGl2ZUhhbmRsZTokaCx1c2VMYXlvdXRFZmZlY3Q6WWgsdXNlTWVtbzpjaSx1c2VSZWR1Y2VyOktoLHVzZVJlZjpUaCx1c2VTdGF0ZTpmdW5jdGlvbigpe3JldHVybiBLaChKaCl9LHVzZURlYnVnVmFsdWU6YWksdXNlRGVmZXJyZWRWYWx1ZTpmdW5jdGlvbihhKXt2YXIgYj1LaChKaCksYz1iWzBdLGQ9YlsxXTtYaChmdW5jdGlvbigpe3ZhciBiPXdoLnRyYW5zaXRpb247d2gudHJhbnNpdGlvbj0xO3RyeXtkKGEpfWZpbmFsbHl7d2gudHJhbnNpdGlvbj1ifX0sW2FdKTtyZXR1cm4gY30sdXNlVHJhbnNpdGlvbjpmdW5jdGlvbigpe3ZhciBhPUtoKEpoKVswXTtyZXR1cm5bVGgoKS5jdXJyZW50LFxuYV19LHVzZU11dGFibGVTb3VyY2U6UGgsdXNlT3BhcXVlSWRlbnRpZmllcjpmdW5jdGlvbigpe3JldHVybiBLaChKaClbMF19LHVuc3RhYmxlX2lzTmV3UmVjb25jaWxlcjohMX0sRmg9e3JlYWRDb250ZXh0OnZnLHVzZUNhbGxiYWNrOmJpLHVzZUNvbnRleHQ6dmcsdXNlRWZmZWN0OlhoLHVzZUltcGVyYXRpdmVIYW5kbGU6JGgsdXNlTGF5b3V0RWZmZWN0OlloLHVzZU1lbW86Y2ksdXNlUmVkdWNlcjpMaCx1c2VSZWY6VGgsdXNlU3RhdGU6ZnVuY3Rpb24oKXtyZXR1cm4gTGgoSmgpfSx1c2VEZWJ1Z1ZhbHVlOmFpLHVzZURlZmVycmVkVmFsdWU6ZnVuY3Rpb24oYSl7dmFyIGI9TGgoSmgpLGM9YlswXSxkPWJbMV07WGgoZnVuY3Rpb24oKXt2YXIgYj13aC50cmFuc2l0aW9uO3doLnRyYW5zaXRpb249MTt0cnl7ZChhKX1maW5hbGx5e3doLnRyYW5zaXRpb249Yn19LFthXSk7cmV0dXJuIGN9LHVzZVRyYW5zaXRpb246ZnVuY3Rpb24oKXt2YXIgYT1MaChKaClbMF07cmV0dXJuW1RoKCkuY3VycmVudCxcbmFdfSx1c2VNdXRhYmxlU291cmNlOlBoLHVzZU9wYXF1ZUlkZW50aWZpZXI6ZnVuY3Rpb24oKXtyZXR1cm4gTGgoSmgpWzBdfSx1bnN0YWJsZV9pc05ld1JlY29uY2lsZXI6ITF9LGVpPXJhLlJlYWN0Q3VycmVudE93bmVyLHVnPSExO2Z1bmN0aW9uIGZpKGEsYixjLGQpe2IuY2hpbGQ9bnVsbD09PWE/WmcoYixudWxsLGMsZCk6WWcoYixhLmNoaWxkLGMsZCl9ZnVuY3Rpb24gZ2koYSxiLGMsZCxlKXtjPWMucmVuZGVyO3ZhciBmPWIucmVmO3RnKGIsZSk7ZD1DaChhLGIsYyxkLGYsZSk7aWYobnVsbCE9PWEmJiF1ZylyZXR1cm4gYi51cGRhdGVRdWV1ZT1hLnVwZGF0ZVF1ZXVlLGIuZmxhZ3MmPS01MTcsYS5sYW5lcyY9fmUsaGkoYSxiLGUpO2IuZmxhZ3N8PTE7ZmkoYSxiLGQsZSk7cmV0dXJuIGIuY2hpbGR9XG5mdW5jdGlvbiBpaShhLGIsYyxkLGUsZil7aWYobnVsbD09PWEpe3ZhciBnPWMudHlwZTtpZihcImZ1bmN0aW9uXCI9PT10eXBlb2YgZyYmIWppKGcpJiZ2b2lkIDA9PT1nLmRlZmF1bHRQcm9wcyYmbnVsbD09PWMuY29tcGFyZSYmdm9pZCAwPT09Yy5kZWZhdWx0UHJvcHMpcmV0dXJuIGIudGFnPTE1LGIudHlwZT1nLGtpKGEsYixnLGQsZSxmKTthPVZnKGMudHlwZSxudWxsLGQsYixiLm1vZGUsZik7YS5yZWY9Yi5yZWY7YS5yZXR1cm49YjtyZXR1cm4gYi5jaGlsZD1hfWc9YS5jaGlsZDtpZigwPT09KGUmZikmJihlPWcubWVtb2l6ZWRQcm9wcyxjPWMuY29tcGFyZSxjPW51bGwhPT1jP2M6SmUsYyhlLGQpJiZhLnJlZj09PWIucmVmKSlyZXR1cm4gaGkoYSxiLGYpO2IuZmxhZ3N8PTE7YT1UZyhnLGQpO2EucmVmPWIucmVmO2EucmV0dXJuPWI7cmV0dXJuIGIuY2hpbGQ9YX1cbmZ1bmN0aW9uIGtpKGEsYixjLGQsZSxmKXtpZihudWxsIT09YSYmSmUoYS5tZW1vaXplZFByb3BzLGQpJiZhLnJlZj09PWIucmVmKWlmKHVnPSExLDAhPT0oZiZlKSkwIT09KGEuZmxhZ3MmMTYzODQpJiYodWc9ITApO2Vsc2UgcmV0dXJuIGIubGFuZXM9YS5sYW5lcyxoaShhLGIsZik7cmV0dXJuIGxpKGEsYixjLGQsZil9XG5mdW5jdGlvbiBtaShhLGIsYyl7dmFyIGQ9Yi5wZW5kaW5nUHJvcHMsZT1kLmNoaWxkcmVuLGY9bnVsbCE9PWE/YS5tZW1vaXplZFN0YXRlOm51bGw7aWYoXCJoaWRkZW5cIj09PWQubW9kZXx8XCJ1bnN0YWJsZS1kZWZlci13aXRob3V0LWhpZGluZ1wiPT09ZC5tb2RlKWlmKDA9PT0oYi5tb2RlJjQpKWIubWVtb2l6ZWRTdGF0ZT17YmFzZUxhbmVzOjB9LG5pKGIsYyk7ZWxzZSBpZigwIT09KGMmMTA3Mzc0MTgyNCkpYi5tZW1vaXplZFN0YXRlPXtiYXNlTGFuZXM6MH0sbmkoYixudWxsIT09Zj9mLmJhc2VMYW5lczpjKTtlbHNlIHJldHVybiBhPW51bGwhPT1mP2YuYmFzZUxhbmVzfGM6YyxiLmxhbmVzPWIuY2hpbGRMYW5lcz0xMDczNzQxODI0LGIubWVtb2l6ZWRTdGF0ZT17YmFzZUxhbmVzOmF9LG5pKGIsYSksbnVsbDtlbHNlIG51bGwhPT1mPyhkPWYuYmFzZUxhbmVzfGMsYi5tZW1vaXplZFN0YXRlPW51bGwpOmQ9YyxuaShiLGQpO2ZpKGEsYixlLGMpO3JldHVybiBiLmNoaWxkfVxuZnVuY3Rpb24gb2koYSxiKXt2YXIgYz1iLnJlZjtpZihudWxsPT09YSYmbnVsbCE9PWN8fG51bGwhPT1hJiZhLnJlZiE9PWMpYi5mbGFnc3w9MTI4fWZ1bmN0aW9uIGxpKGEsYixjLGQsZSl7dmFyIGY9RmYoYyk/RGY6TS5jdXJyZW50O2Y9RWYoYixmKTt0ZyhiLGUpO2M9Q2goYSxiLGMsZCxmLGUpO2lmKG51bGwhPT1hJiYhdWcpcmV0dXJuIGIudXBkYXRlUXVldWU9YS51cGRhdGVRdWV1ZSxiLmZsYWdzJj0tNTE3LGEubGFuZXMmPX5lLGhpKGEsYixlKTtiLmZsYWdzfD0xO2ZpKGEsYixjLGUpO3JldHVybiBiLmNoaWxkfVxuZnVuY3Rpb24gcGkoYSxiLGMsZCxlKXtpZihGZihjKSl7dmFyIGY9ITA7SmYoYil9ZWxzZSBmPSExO3RnKGIsZSk7aWYobnVsbD09PWIuc3RhdGVOb2RlKW51bGwhPT1hJiYoYS5hbHRlcm5hdGU9bnVsbCxiLmFsdGVybmF0ZT1udWxsLGIuZmxhZ3N8PTIpLE1nKGIsYyxkKSxPZyhiLGMsZCxlKSxkPSEwO2Vsc2UgaWYobnVsbD09PWEpe3ZhciBnPWIuc3RhdGVOb2RlLGg9Yi5tZW1vaXplZFByb3BzO2cucHJvcHM9aDt2YXIgaz1nLmNvbnRleHQsbD1jLmNvbnRleHRUeXBlO1wib2JqZWN0XCI9PT10eXBlb2YgbCYmbnVsbCE9PWw/bD12ZyhsKToobD1GZihjKT9EZjpNLmN1cnJlbnQsbD1FZihiLGwpKTt2YXIgbj1jLmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyxBPVwiZnVuY3Rpb25cIj09PXR5cGVvZiBufHxcImZ1bmN0aW9uXCI9PT10eXBlb2YgZy5nZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZTtBfHxcImZ1bmN0aW9uXCIhPT10eXBlb2YgZy5VTlNBRkVfY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyYmXG5cImZ1bmN0aW9uXCIhPT10eXBlb2YgZy5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzfHwoaCE9PWR8fGshPT1sKSYmTmcoYixnLGQsbCk7d2c9ITE7dmFyIHA9Yi5tZW1vaXplZFN0YXRlO2cuc3RhdGU9cDtDZyhiLGQsZyxlKTtrPWIubWVtb2l6ZWRTdGF0ZTtoIT09ZHx8cCE9PWt8fE4uY3VycmVudHx8d2c/KFwiZnVuY3Rpb25cIj09PXR5cGVvZiBuJiYoR2coYixjLG4sZCksaz1iLm1lbW9pemVkU3RhdGUpLChoPXdnfHxMZyhiLGMsaCxkLHAsayxsKSk/KEF8fFwiZnVuY3Rpb25cIiE9PXR5cGVvZiBnLlVOU0FGRV9jb21wb25lbnRXaWxsTW91bnQmJlwiZnVuY3Rpb25cIiE9PXR5cGVvZiBnLmNvbXBvbmVudFdpbGxNb3VudHx8KFwiZnVuY3Rpb25cIj09PXR5cGVvZiBnLmNvbXBvbmVudFdpbGxNb3VudCYmZy5jb21wb25lbnRXaWxsTW91bnQoKSxcImZ1bmN0aW9uXCI9PT10eXBlb2YgZy5VTlNBRkVfY29tcG9uZW50V2lsbE1vdW50JiZnLlVOU0FGRV9jb21wb25lbnRXaWxsTW91bnQoKSksXCJmdW5jdGlvblwiPT09XG50eXBlb2YgZy5jb21wb25lbnREaWRNb3VudCYmKGIuZmxhZ3N8PTQpKTooXCJmdW5jdGlvblwiPT09dHlwZW9mIGcuY29tcG9uZW50RGlkTW91bnQmJihiLmZsYWdzfD00KSxiLm1lbW9pemVkUHJvcHM9ZCxiLm1lbW9pemVkU3RhdGU9ayksZy5wcm9wcz1kLGcuc3RhdGU9ayxnLmNvbnRleHQ9bCxkPWgpOihcImZ1bmN0aW9uXCI9PT10eXBlb2YgZy5jb21wb25lbnREaWRNb3VudCYmKGIuZmxhZ3N8PTQpLGQ9ITEpfWVsc2V7Zz1iLnN0YXRlTm9kZTt5ZyhhLGIpO2g9Yi5tZW1vaXplZFByb3BzO2w9Yi50eXBlPT09Yi5lbGVtZW50VHlwZT9oOmxnKGIudHlwZSxoKTtnLnByb3BzPWw7QT1iLnBlbmRpbmdQcm9wcztwPWcuY29udGV4dDtrPWMuY29udGV4dFR5cGU7XCJvYmplY3RcIj09PXR5cGVvZiBrJiZudWxsIT09az9rPXZnKGspOihrPUZmKGMpP0RmOk0uY3VycmVudCxrPUVmKGIsaykpO3ZhciBDPWMuZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzOyhuPVwiZnVuY3Rpb25cIj09PXR5cGVvZiBDfHxcblwiZnVuY3Rpb25cIj09PXR5cGVvZiBnLmdldFNuYXBzaG90QmVmb3JlVXBkYXRlKXx8XCJmdW5jdGlvblwiIT09dHlwZW9mIGcuVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMmJlwiZnVuY3Rpb25cIiE9PXR5cGVvZiBnLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHN8fChoIT09QXx8cCE9PWspJiZOZyhiLGcsZCxrKTt3Zz0hMTtwPWIubWVtb2l6ZWRTdGF0ZTtnLnN0YXRlPXA7Q2coYixkLGcsZSk7dmFyIHg9Yi5tZW1vaXplZFN0YXRlO2ghPT1BfHxwIT09eHx8Ti5jdXJyZW50fHx3Zz8oXCJmdW5jdGlvblwiPT09dHlwZW9mIEMmJihHZyhiLGMsQyxkKSx4PWIubWVtb2l6ZWRTdGF0ZSksKGw9d2d8fExnKGIsYyxsLGQscCx4LGspKT8obnx8XCJmdW5jdGlvblwiIT09dHlwZW9mIGcuVU5TQUZFX2NvbXBvbmVudFdpbGxVcGRhdGUmJlwiZnVuY3Rpb25cIiE9PXR5cGVvZiBnLmNvbXBvbmVudFdpbGxVcGRhdGV8fChcImZ1bmN0aW9uXCI9PT10eXBlb2YgZy5jb21wb25lbnRXaWxsVXBkYXRlJiZnLmNvbXBvbmVudFdpbGxVcGRhdGUoZCxcbngsayksXCJmdW5jdGlvblwiPT09dHlwZW9mIGcuVU5TQUZFX2NvbXBvbmVudFdpbGxVcGRhdGUmJmcuVU5TQUZFX2NvbXBvbmVudFdpbGxVcGRhdGUoZCx4LGspKSxcImZ1bmN0aW9uXCI9PT10eXBlb2YgZy5jb21wb25lbnREaWRVcGRhdGUmJihiLmZsYWdzfD00KSxcImZ1bmN0aW9uXCI9PT10eXBlb2YgZy5nZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSYmKGIuZmxhZ3N8PTI1NikpOihcImZ1bmN0aW9uXCIhPT10eXBlb2YgZy5jb21wb25lbnREaWRVcGRhdGV8fGg9PT1hLm1lbW9pemVkUHJvcHMmJnA9PT1hLm1lbW9pemVkU3RhdGV8fChiLmZsYWdzfD00KSxcImZ1bmN0aW9uXCIhPT10eXBlb2YgZy5nZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZXx8aD09PWEubWVtb2l6ZWRQcm9wcyYmcD09PWEubWVtb2l6ZWRTdGF0ZXx8KGIuZmxhZ3N8PTI1NiksYi5tZW1vaXplZFByb3BzPWQsYi5tZW1vaXplZFN0YXRlPXgpLGcucHJvcHM9ZCxnLnN0YXRlPXgsZy5jb250ZXh0PWssZD1sKTooXCJmdW5jdGlvblwiIT09dHlwZW9mIGcuY29tcG9uZW50RGlkVXBkYXRlfHxcbmg9PT1hLm1lbW9pemVkUHJvcHMmJnA9PT1hLm1lbW9pemVkU3RhdGV8fChiLmZsYWdzfD00KSxcImZ1bmN0aW9uXCIhPT10eXBlb2YgZy5nZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZXx8aD09PWEubWVtb2l6ZWRQcm9wcyYmcD09PWEubWVtb2l6ZWRTdGF0ZXx8KGIuZmxhZ3N8PTI1NiksZD0hMSl9cmV0dXJuIHFpKGEsYixjLGQsZixlKX1cbmZ1bmN0aW9uIHFpKGEsYixjLGQsZSxmKXtvaShhLGIpO3ZhciBnPTAhPT0oYi5mbGFncyY2NCk7aWYoIWQmJiFnKXJldHVybiBlJiZLZihiLGMsITEpLGhpKGEsYixmKTtkPWIuc3RhdGVOb2RlO2VpLmN1cnJlbnQ9Yjt2YXIgaD1nJiZcImZ1bmN0aW9uXCIhPT10eXBlb2YgYy5nZXREZXJpdmVkU3RhdGVGcm9tRXJyb3I/bnVsbDpkLnJlbmRlcigpO2IuZmxhZ3N8PTE7bnVsbCE9PWEmJmc/KGIuY2hpbGQ9WWcoYixhLmNoaWxkLG51bGwsZiksYi5jaGlsZD1ZZyhiLG51bGwsaCxmKSk6ZmkoYSxiLGgsZik7Yi5tZW1vaXplZFN0YXRlPWQuc3RhdGU7ZSYmS2YoYixjLCEwKTtyZXR1cm4gYi5jaGlsZH1mdW5jdGlvbiByaShhKXt2YXIgYj1hLnN0YXRlTm9kZTtiLnBlbmRpbmdDb250ZXh0P0hmKGEsYi5wZW5kaW5nQ29udGV4dCxiLnBlbmRpbmdDb250ZXh0IT09Yi5jb250ZXh0KTpiLmNvbnRleHQmJkhmKGEsYi5jb250ZXh0LCExKTtlaChhLGIuY29udGFpbmVySW5mbyl9XG52YXIgc2k9e2RlaHlkcmF0ZWQ6bnVsbCxyZXRyeUxhbmU6MH07XG5mdW5jdGlvbiB0aShhLGIsYyl7dmFyIGQ9Yi5wZW5kaW5nUHJvcHMsZT1QLmN1cnJlbnQsZj0hMSxnOyhnPTAhPT0oYi5mbGFncyY2NCkpfHwoZz1udWxsIT09YSYmbnVsbD09PWEubWVtb2l6ZWRTdGF0ZT8hMTowIT09KGUmMikpO2c/KGY9ITAsYi5mbGFncyY9LTY1KTpudWxsIT09YSYmbnVsbD09PWEubWVtb2l6ZWRTdGF0ZXx8dm9pZCAwPT09ZC5mYWxsYmFja3x8ITA9PT1kLnVuc3RhYmxlX2F2b2lkVGhpc0ZhbGxiYWNrfHwoZXw9MSk7SShQLGUmMSk7aWYobnVsbD09PWEpe3ZvaWQgMCE9PWQuZmFsbGJhY2smJnBoKGIpO2E9ZC5jaGlsZHJlbjtlPWQuZmFsbGJhY2s7aWYoZilyZXR1cm4gYT11aShiLGEsZSxjKSxiLmNoaWxkLm1lbW9pemVkU3RhdGU9e2Jhc2VMYW5lczpjfSxiLm1lbW9pemVkU3RhdGU9c2ksYTtpZihcIm51bWJlclwiPT09dHlwZW9mIGQudW5zdGFibGVfZXhwZWN0ZWRMb2FkVGltZSlyZXR1cm4gYT11aShiLGEsZSxjKSxiLmNoaWxkLm1lbW9pemVkU3RhdGU9e2Jhc2VMYW5lczpjfSxcbmIubWVtb2l6ZWRTdGF0ZT1zaSxiLmxhbmVzPTMzNTU0NDMyLGE7Yz12aSh7bW9kZTpcInZpc2libGVcIixjaGlsZHJlbjphfSxiLm1vZGUsYyxudWxsKTtjLnJldHVybj1iO3JldHVybiBiLmNoaWxkPWN9aWYobnVsbCE9PWEubWVtb2l6ZWRTdGF0ZSl7aWYoZilyZXR1cm4gZD13aShhLGIsZC5jaGlsZHJlbixkLmZhbGxiYWNrLGMpLGY9Yi5jaGlsZCxlPWEuY2hpbGQubWVtb2l6ZWRTdGF0ZSxmLm1lbW9pemVkU3RhdGU9bnVsbD09PWU/e2Jhc2VMYW5lczpjfTp7YmFzZUxhbmVzOmUuYmFzZUxhbmVzfGN9LGYuY2hpbGRMYW5lcz1hLmNoaWxkTGFuZXMmfmMsYi5tZW1vaXplZFN0YXRlPXNpLGQ7Yz14aShhLGIsZC5jaGlsZHJlbixjKTtiLm1lbW9pemVkU3RhdGU9bnVsbDtyZXR1cm4gY31pZihmKXJldHVybiBkPXdpKGEsYixkLmNoaWxkcmVuLGQuZmFsbGJhY2ssYyksZj1iLmNoaWxkLGU9YS5jaGlsZC5tZW1vaXplZFN0YXRlLGYubWVtb2l6ZWRTdGF0ZT1udWxsPT09ZT97YmFzZUxhbmVzOmN9Olxue2Jhc2VMYW5lczplLmJhc2VMYW5lc3xjfSxmLmNoaWxkTGFuZXM9YS5jaGlsZExhbmVzJn5jLGIubWVtb2l6ZWRTdGF0ZT1zaSxkO2M9eGkoYSxiLGQuY2hpbGRyZW4sYyk7Yi5tZW1vaXplZFN0YXRlPW51bGw7cmV0dXJuIGN9ZnVuY3Rpb24gdWkoYSxiLGMsZCl7dmFyIGU9YS5tb2RlLGY9YS5jaGlsZDtiPXttb2RlOlwiaGlkZGVuXCIsY2hpbGRyZW46Yn07MD09PShlJjIpJiZudWxsIT09Zj8oZi5jaGlsZExhbmVzPTAsZi5wZW5kaW5nUHJvcHM9Yik6Zj12aShiLGUsMCxudWxsKTtjPVhnKGMsZSxkLG51bGwpO2YucmV0dXJuPWE7Yy5yZXR1cm49YTtmLnNpYmxpbmc9YzthLmNoaWxkPWY7cmV0dXJuIGN9XG5mdW5jdGlvbiB4aShhLGIsYyxkKXt2YXIgZT1hLmNoaWxkO2E9ZS5zaWJsaW5nO2M9VGcoZSx7bW9kZTpcInZpc2libGVcIixjaGlsZHJlbjpjfSk7MD09PShiLm1vZGUmMikmJihjLmxhbmVzPWQpO2MucmV0dXJuPWI7Yy5zaWJsaW5nPW51bGw7bnVsbCE9PWEmJihhLm5leHRFZmZlY3Q9bnVsbCxhLmZsYWdzPTgsYi5maXJzdEVmZmVjdD1iLmxhc3RFZmZlY3Q9YSk7cmV0dXJuIGIuY2hpbGQ9Y31cbmZ1bmN0aW9uIHdpKGEsYixjLGQsZSl7dmFyIGY9Yi5tb2RlLGc9YS5jaGlsZDthPWcuc2libGluZzt2YXIgaD17bW9kZTpcImhpZGRlblwiLGNoaWxkcmVuOmN9OzA9PT0oZiYyKSYmYi5jaGlsZCE9PWc/KGM9Yi5jaGlsZCxjLmNoaWxkTGFuZXM9MCxjLnBlbmRpbmdQcm9wcz1oLGc9Yy5sYXN0RWZmZWN0LG51bGwhPT1nPyhiLmZpcnN0RWZmZWN0PWMuZmlyc3RFZmZlY3QsYi5sYXN0RWZmZWN0PWcsZy5uZXh0RWZmZWN0PW51bGwpOmIuZmlyc3RFZmZlY3Q9Yi5sYXN0RWZmZWN0PW51bGwpOmM9VGcoZyxoKTtudWxsIT09YT9kPVRnKGEsZCk6KGQ9WGcoZCxmLGUsbnVsbCksZC5mbGFnc3w9Mik7ZC5yZXR1cm49YjtjLnJldHVybj1iO2Muc2libGluZz1kO2IuY2hpbGQ9YztyZXR1cm4gZH1mdW5jdGlvbiB5aShhLGIpe2EubGFuZXN8PWI7dmFyIGM9YS5hbHRlcm5hdGU7bnVsbCE9PWMmJihjLmxhbmVzfD1iKTtzZyhhLnJldHVybixiKX1cbmZ1bmN0aW9uIHppKGEsYixjLGQsZSxmKXt2YXIgZz1hLm1lbW9pemVkU3RhdGU7bnVsbD09PWc/YS5tZW1vaXplZFN0YXRlPXtpc0JhY2t3YXJkczpiLHJlbmRlcmluZzpudWxsLHJlbmRlcmluZ1N0YXJ0VGltZTowLGxhc3Q6ZCx0YWlsOmMsdGFpbE1vZGU6ZSxsYXN0RWZmZWN0OmZ9OihnLmlzQmFja3dhcmRzPWIsZy5yZW5kZXJpbmc9bnVsbCxnLnJlbmRlcmluZ1N0YXJ0VGltZT0wLGcubGFzdD1kLGcudGFpbD1jLGcudGFpbE1vZGU9ZSxnLmxhc3RFZmZlY3Q9Zil9XG5mdW5jdGlvbiBBaShhLGIsYyl7dmFyIGQ9Yi5wZW5kaW5nUHJvcHMsZT1kLnJldmVhbE9yZGVyLGY9ZC50YWlsO2ZpKGEsYixkLmNoaWxkcmVuLGMpO2Q9UC5jdXJyZW50O2lmKDAhPT0oZCYyKSlkPWQmMXwyLGIuZmxhZ3N8PTY0O2Vsc2V7aWYobnVsbCE9PWEmJjAhPT0oYS5mbGFncyY2NCkpYTpmb3IoYT1iLmNoaWxkO251bGwhPT1hOyl7aWYoMTM9PT1hLnRhZyludWxsIT09YS5tZW1vaXplZFN0YXRlJiZ5aShhLGMpO2Vsc2UgaWYoMTk9PT1hLnRhZyl5aShhLGMpO2Vsc2UgaWYobnVsbCE9PWEuY2hpbGQpe2EuY2hpbGQucmV0dXJuPWE7YT1hLmNoaWxkO2NvbnRpbnVlfWlmKGE9PT1iKWJyZWFrIGE7Zm9yKDtudWxsPT09YS5zaWJsaW5nOyl7aWYobnVsbD09PWEucmV0dXJufHxhLnJldHVybj09PWIpYnJlYWsgYTthPWEucmV0dXJufWEuc2libGluZy5yZXR1cm49YS5yZXR1cm47YT1hLnNpYmxpbmd9ZCY9MX1JKFAsZCk7aWYoMD09PShiLm1vZGUmMikpYi5tZW1vaXplZFN0YXRlPVxubnVsbDtlbHNlIHN3aXRjaChlKXtjYXNlIFwiZm9yd2FyZHNcIjpjPWIuY2hpbGQ7Zm9yKGU9bnVsbDtudWxsIT09YzspYT1jLmFsdGVybmF0ZSxudWxsIT09YSYmbnVsbD09PWloKGEpJiYoZT1jKSxjPWMuc2libGluZztjPWU7bnVsbD09PWM/KGU9Yi5jaGlsZCxiLmNoaWxkPW51bGwpOihlPWMuc2libGluZyxjLnNpYmxpbmc9bnVsbCk7emkoYiwhMSxlLGMsZixiLmxhc3RFZmZlY3QpO2JyZWFrO2Nhc2UgXCJiYWNrd2FyZHNcIjpjPW51bGw7ZT1iLmNoaWxkO2ZvcihiLmNoaWxkPW51bGw7bnVsbCE9PWU7KXthPWUuYWx0ZXJuYXRlO2lmKG51bGwhPT1hJiZudWxsPT09aWgoYSkpe2IuY2hpbGQ9ZTticmVha31hPWUuc2libGluZztlLnNpYmxpbmc9YztjPWU7ZT1hfXppKGIsITAsYyxudWxsLGYsYi5sYXN0RWZmZWN0KTticmVhaztjYXNlIFwidG9nZXRoZXJcIjp6aShiLCExLG51bGwsbnVsbCx2b2lkIDAsYi5sYXN0RWZmZWN0KTticmVhaztkZWZhdWx0OmIubWVtb2l6ZWRTdGF0ZT1udWxsfXJldHVybiBiLmNoaWxkfVxuZnVuY3Rpb24gaGkoYSxiLGMpe251bGwhPT1hJiYoYi5kZXBlbmRlbmNpZXM9YS5kZXBlbmRlbmNpZXMpO0RnfD1iLmxhbmVzO2lmKDAhPT0oYyZiLmNoaWxkTGFuZXMpKXtpZihudWxsIT09YSYmYi5jaGlsZCE9PWEuY2hpbGQpdGhyb3cgRXJyb3IoeSgxNTMpKTtpZihudWxsIT09Yi5jaGlsZCl7YT1iLmNoaWxkO2M9VGcoYSxhLnBlbmRpbmdQcm9wcyk7Yi5jaGlsZD1jO2ZvcihjLnJldHVybj1iO251bGwhPT1hLnNpYmxpbmc7KWE9YS5zaWJsaW5nLGM9Yy5zaWJsaW5nPVRnKGEsYS5wZW5kaW5nUHJvcHMpLGMucmV0dXJuPWI7Yy5zaWJsaW5nPW51bGx9cmV0dXJuIGIuY2hpbGR9cmV0dXJuIG51bGx9dmFyIEJpLENpLERpLEVpO1xuQmk9ZnVuY3Rpb24oYSxiKXtmb3IodmFyIGM9Yi5jaGlsZDtudWxsIT09Yzspe2lmKDU9PT1jLnRhZ3x8Nj09PWMudGFnKWEuYXBwZW5kQ2hpbGQoYy5zdGF0ZU5vZGUpO2Vsc2UgaWYoNCE9PWMudGFnJiZudWxsIT09Yy5jaGlsZCl7Yy5jaGlsZC5yZXR1cm49YztjPWMuY2hpbGQ7Y29udGludWV9aWYoYz09PWIpYnJlYWs7Zm9yKDtudWxsPT09Yy5zaWJsaW5nOyl7aWYobnVsbD09PWMucmV0dXJufHxjLnJldHVybj09PWIpcmV0dXJuO2M9Yy5yZXR1cm59Yy5zaWJsaW5nLnJldHVybj1jLnJldHVybjtjPWMuc2libGluZ319O0NpPWZ1bmN0aW9uKCl7fTtcbkRpPWZ1bmN0aW9uKGEsYixjLGQpe3ZhciBlPWEubWVtb2l6ZWRQcm9wcztpZihlIT09ZCl7YT1iLnN0YXRlTm9kZTtkaChhaC5jdXJyZW50KTt2YXIgZj1udWxsO3N3aXRjaChjKXtjYXNlIFwiaW5wdXRcIjplPVlhKGEsZSk7ZD1ZYShhLGQpO2Y9W107YnJlYWs7Y2FzZSBcIm9wdGlvblwiOmU9ZWIoYSxlKTtkPWViKGEsZCk7Zj1bXTticmVhaztjYXNlIFwic2VsZWN0XCI6ZT1tKHt9LGUse3ZhbHVlOnZvaWQgMH0pO2Q9bSh7fSxkLHt2YWx1ZTp2b2lkIDB9KTtmPVtdO2JyZWFrO2Nhc2UgXCJ0ZXh0YXJlYVwiOmU9Z2IoYSxlKTtkPWdiKGEsZCk7Zj1bXTticmVhaztkZWZhdWx0OlwiZnVuY3Rpb25cIiE9PXR5cGVvZiBlLm9uQ2xpY2smJlwiZnVuY3Rpb25cIj09PXR5cGVvZiBkLm9uQ2xpY2smJihhLm9uY2xpY2s9amYpfXZiKGMsZCk7dmFyIGc7Yz1udWxsO2ZvcihsIGluIGUpaWYoIWQuaGFzT3duUHJvcGVydHkobCkmJmUuaGFzT3duUHJvcGVydHkobCkmJm51bGwhPWVbbF0paWYoXCJzdHlsZVwiPT09XG5sKXt2YXIgaD1lW2xdO2ZvcihnIGluIGgpaC5oYXNPd25Qcm9wZXJ0eShnKSYmKGN8fChjPXt9KSxjW2ddPVwiXCIpfWVsc2VcImRhbmdlcm91c2x5U2V0SW5uZXJIVE1MXCIhPT1sJiZcImNoaWxkcmVuXCIhPT1sJiZcInN1cHByZXNzQ29udGVudEVkaXRhYmxlV2FybmluZ1wiIT09bCYmXCJzdXBwcmVzc0h5ZHJhdGlvbldhcm5pbmdcIiE9PWwmJlwiYXV0b0ZvY3VzXCIhPT1sJiYoY2EuaGFzT3duUHJvcGVydHkobCk/Znx8KGY9W10pOihmPWZ8fFtdKS5wdXNoKGwsbnVsbCkpO2ZvcihsIGluIGQpe3ZhciBrPWRbbF07aD1udWxsIT1lP2VbbF06dm9pZCAwO2lmKGQuaGFzT3duUHJvcGVydHkobCkmJmshPT1oJiYobnVsbCE9a3x8bnVsbCE9aCkpaWYoXCJzdHlsZVwiPT09bClpZihoKXtmb3IoZyBpbiBoKSFoLmhhc093blByb3BlcnR5KGcpfHxrJiZrLmhhc093blByb3BlcnR5KGcpfHwoY3x8KGM9e30pLGNbZ109XCJcIik7Zm9yKGcgaW4gaylrLmhhc093blByb3BlcnR5KGcpJiZoW2ddIT09a1tnXSYmKGN8fFxuKGM9e30pLGNbZ109a1tnXSl9ZWxzZSBjfHwoZnx8KGY9W10pLGYucHVzaChsLGMpKSxjPWs7ZWxzZVwiZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxcIj09PWw/KGs9az9rLl9faHRtbDp2b2lkIDAsaD1oP2guX19odG1sOnZvaWQgMCxudWxsIT1rJiZoIT09ayYmKGY9Znx8W10pLnB1c2gobCxrKSk6XCJjaGlsZHJlblwiPT09bD9cInN0cmluZ1wiIT09dHlwZW9mIGsmJlwibnVtYmVyXCIhPT10eXBlb2Yga3x8KGY9Znx8W10pLnB1c2gobCxcIlwiK2spOlwic3VwcHJlc3NDb250ZW50RWRpdGFibGVXYXJuaW5nXCIhPT1sJiZcInN1cHByZXNzSHlkcmF0aW9uV2FybmluZ1wiIT09bCYmKGNhLmhhc093blByb3BlcnR5KGwpPyhudWxsIT1rJiZcIm9uU2Nyb2xsXCI9PT1sJiZHKFwic2Nyb2xsXCIsYSksZnx8aD09PWt8fChmPVtdKSk6XCJvYmplY3RcIj09PXR5cGVvZiBrJiZudWxsIT09ayYmay4kJHR5cGVvZj09PUdhP2sudG9TdHJpbmcoKTooZj1mfHxbXSkucHVzaChsLGspKX1jJiYoZj1mfHxbXSkucHVzaChcInN0eWxlXCIsXG5jKTt2YXIgbD1mO2lmKGIudXBkYXRlUXVldWU9bCliLmZsYWdzfD00fX07RWk9ZnVuY3Rpb24oYSxiLGMsZCl7YyE9PWQmJihiLmZsYWdzfD00KX07ZnVuY3Rpb24gRmkoYSxiKXtpZighbGgpc3dpdGNoKGEudGFpbE1vZGUpe2Nhc2UgXCJoaWRkZW5cIjpiPWEudGFpbDtmb3IodmFyIGM9bnVsbDtudWxsIT09YjspbnVsbCE9PWIuYWx0ZXJuYXRlJiYoYz1iKSxiPWIuc2libGluZztudWxsPT09Yz9hLnRhaWw9bnVsbDpjLnNpYmxpbmc9bnVsbDticmVhaztjYXNlIFwiY29sbGFwc2VkXCI6Yz1hLnRhaWw7Zm9yKHZhciBkPW51bGw7bnVsbCE9PWM7KW51bGwhPT1jLmFsdGVybmF0ZSYmKGQ9YyksYz1jLnNpYmxpbmc7bnVsbD09PWQ/Ynx8bnVsbD09PWEudGFpbD9hLnRhaWw9bnVsbDphLnRhaWwuc2libGluZz1udWxsOmQuc2libGluZz1udWxsfX1cbmZ1bmN0aW9uIEdpKGEsYixjKXt2YXIgZD1iLnBlbmRpbmdQcm9wcztzd2l0Y2goYi50YWcpe2Nhc2UgMjpjYXNlIDE2OmNhc2UgMTU6Y2FzZSAwOmNhc2UgMTE6Y2FzZSA3OmNhc2UgODpjYXNlIDEyOmNhc2UgOTpjYXNlIDE0OnJldHVybiBudWxsO2Nhc2UgMTpyZXR1cm4gRmYoYi50eXBlKSYmR2YoKSxudWxsO2Nhc2UgMzpmaCgpO0goTik7SChNKTt1aCgpO2Q9Yi5zdGF0ZU5vZGU7ZC5wZW5kaW5nQ29udGV4dCYmKGQuY29udGV4dD1kLnBlbmRpbmdDb250ZXh0LGQucGVuZGluZ0NvbnRleHQ9bnVsbCk7aWYobnVsbD09PWF8fG51bGw9PT1hLmNoaWxkKXJoKGIpP2IuZmxhZ3N8PTQ6ZC5oeWRyYXRlfHwoYi5mbGFnc3w9MjU2KTtDaShiKTtyZXR1cm4gbnVsbDtjYXNlIDU6aGgoYik7dmFyIGU9ZGgoY2guY3VycmVudCk7Yz1iLnR5cGU7aWYobnVsbCE9PWEmJm51bGwhPWIuc3RhdGVOb2RlKURpKGEsYixjLGQsZSksYS5yZWYhPT1iLnJlZiYmKGIuZmxhZ3N8PTEyOCk7ZWxzZXtpZighZCl7aWYobnVsbD09PVxuYi5zdGF0ZU5vZGUpdGhyb3cgRXJyb3IoeSgxNjYpKTtyZXR1cm4gbnVsbH1hPWRoKGFoLmN1cnJlbnQpO2lmKHJoKGIpKXtkPWIuc3RhdGVOb2RlO2M9Yi50eXBlO3ZhciBmPWIubWVtb2l6ZWRQcm9wcztkW3dmXT1iO2RbeGZdPWY7c3dpdGNoKGMpe2Nhc2UgXCJkaWFsb2dcIjpHKFwiY2FuY2VsXCIsZCk7RyhcImNsb3NlXCIsZCk7YnJlYWs7Y2FzZSBcImlmcmFtZVwiOmNhc2UgXCJvYmplY3RcIjpjYXNlIFwiZW1iZWRcIjpHKFwibG9hZFwiLGQpO2JyZWFrO2Nhc2UgXCJ2aWRlb1wiOmNhc2UgXCJhdWRpb1wiOmZvcihhPTA7YTxYZS5sZW5ndGg7YSsrKUcoWGVbYV0sZCk7YnJlYWs7Y2FzZSBcInNvdXJjZVwiOkcoXCJlcnJvclwiLGQpO2JyZWFrO2Nhc2UgXCJpbWdcIjpjYXNlIFwiaW1hZ2VcIjpjYXNlIFwibGlua1wiOkcoXCJlcnJvclwiLGQpO0coXCJsb2FkXCIsZCk7YnJlYWs7Y2FzZSBcImRldGFpbHNcIjpHKFwidG9nZ2xlXCIsZCk7YnJlYWs7Y2FzZSBcImlucHV0XCI6WmEoZCxmKTtHKFwiaW52YWxpZFwiLGQpO2JyZWFrO2Nhc2UgXCJzZWxlY3RcIjpkLl93cmFwcGVyU3RhdGU9XG57d2FzTXVsdGlwbGU6ISFmLm11bHRpcGxlfTtHKFwiaW52YWxpZFwiLGQpO2JyZWFrO2Nhc2UgXCJ0ZXh0YXJlYVwiOmhiKGQsZiksRyhcImludmFsaWRcIixkKX12YihjLGYpO2E9bnVsbDtmb3IodmFyIGcgaW4gZilmLmhhc093blByb3BlcnR5KGcpJiYoZT1mW2ddLFwiY2hpbGRyZW5cIj09PWc/XCJzdHJpbmdcIj09PXR5cGVvZiBlP2QudGV4dENvbnRlbnQhPT1lJiYoYT1bXCJjaGlsZHJlblwiLGVdKTpcIm51bWJlclwiPT09dHlwZW9mIGUmJmQudGV4dENvbnRlbnQhPT1cIlwiK2UmJihhPVtcImNoaWxkcmVuXCIsXCJcIitlXSk6Y2EuaGFzT3duUHJvcGVydHkoZykmJm51bGwhPWUmJlwib25TY3JvbGxcIj09PWcmJkcoXCJzY3JvbGxcIixkKSk7c3dpdGNoKGMpe2Nhc2UgXCJpbnB1dFwiOlZhKGQpO2NiKGQsZiwhMCk7YnJlYWs7Y2FzZSBcInRleHRhcmVhXCI6VmEoZCk7amIoZCk7YnJlYWs7Y2FzZSBcInNlbGVjdFwiOmNhc2UgXCJvcHRpb25cIjpicmVhaztkZWZhdWx0OlwiZnVuY3Rpb25cIj09PXR5cGVvZiBmLm9uQ2xpY2smJihkLm9uY2xpY2s9XG5qZil9ZD1hO2IudXBkYXRlUXVldWU9ZDtudWxsIT09ZCYmKGIuZmxhZ3N8PTQpfWVsc2V7Zz05PT09ZS5ub2RlVHlwZT9lOmUub3duZXJEb2N1bWVudDthPT09a2IuaHRtbCYmKGE9bGIoYykpO2E9PT1rYi5odG1sP1wic2NyaXB0XCI9PT1jPyhhPWcuY3JlYXRlRWxlbWVudChcImRpdlwiKSxhLmlubmVySFRNTD1cIjxzY3JpcHQ+XFx4M2Mvc2NyaXB0PlwiLGE9YS5yZW1vdmVDaGlsZChhLmZpcnN0Q2hpbGQpKTpcInN0cmluZ1wiPT09dHlwZW9mIGQuaXM/YT1nLmNyZWF0ZUVsZW1lbnQoYyx7aXM6ZC5pc30pOihhPWcuY3JlYXRlRWxlbWVudChjKSxcInNlbGVjdFwiPT09YyYmKGc9YSxkLm11bHRpcGxlP2cubXVsdGlwbGU9ITA6ZC5zaXplJiYoZy5zaXplPWQuc2l6ZSkpKTphPWcuY3JlYXRlRWxlbWVudE5TKGEsYyk7YVt3Zl09YjthW3hmXT1kO0JpKGEsYiwhMSwhMSk7Yi5zdGF0ZU5vZGU9YTtnPXdiKGMsZCk7c3dpdGNoKGMpe2Nhc2UgXCJkaWFsb2dcIjpHKFwiY2FuY2VsXCIsYSk7RyhcImNsb3NlXCIsYSk7XG5lPWQ7YnJlYWs7Y2FzZSBcImlmcmFtZVwiOmNhc2UgXCJvYmplY3RcIjpjYXNlIFwiZW1iZWRcIjpHKFwibG9hZFwiLGEpO2U9ZDticmVhaztjYXNlIFwidmlkZW9cIjpjYXNlIFwiYXVkaW9cIjpmb3IoZT0wO2U8WGUubGVuZ3RoO2UrKylHKFhlW2VdLGEpO2U9ZDticmVhaztjYXNlIFwic291cmNlXCI6RyhcImVycm9yXCIsYSk7ZT1kO2JyZWFrO2Nhc2UgXCJpbWdcIjpjYXNlIFwiaW1hZ2VcIjpjYXNlIFwibGlua1wiOkcoXCJlcnJvclwiLGEpO0coXCJsb2FkXCIsYSk7ZT1kO2JyZWFrO2Nhc2UgXCJkZXRhaWxzXCI6RyhcInRvZ2dsZVwiLGEpO2U9ZDticmVhaztjYXNlIFwiaW5wdXRcIjpaYShhLGQpO2U9WWEoYSxkKTtHKFwiaW52YWxpZFwiLGEpO2JyZWFrO2Nhc2UgXCJvcHRpb25cIjplPWViKGEsZCk7YnJlYWs7Y2FzZSBcInNlbGVjdFwiOmEuX3dyYXBwZXJTdGF0ZT17d2FzTXVsdGlwbGU6ISFkLm11bHRpcGxlfTtlPW0oe30sZCx7dmFsdWU6dm9pZCAwfSk7RyhcImludmFsaWRcIixhKTticmVhaztjYXNlIFwidGV4dGFyZWFcIjpoYihhLGQpO2U9XG5nYihhLGQpO0coXCJpbnZhbGlkXCIsYSk7YnJlYWs7ZGVmYXVsdDplPWR9dmIoYyxlKTt2YXIgaD1lO2ZvcihmIGluIGgpaWYoaC5oYXNPd25Qcm9wZXJ0eShmKSl7dmFyIGs9aFtmXTtcInN0eWxlXCI9PT1mP3RiKGEsayk6XCJkYW5nZXJvdXNseVNldElubmVySFRNTFwiPT09Zj8oaz1rP2suX19odG1sOnZvaWQgMCxudWxsIT1rJiZvYihhLGspKTpcImNoaWxkcmVuXCI9PT1mP1wic3RyaW5nXCI9PT10eXBlb2Ygaz8oXCJ0ZXh0YXJlYVwiIT09Y3x8XCJcIiE9PWspJiZwYihhLGspOlwibnVtYmVyXCI9PT10eXBlb2YgayYmcGIoYSxcIlwiK2spOlwic3VwcHJlc3NDb250ZW50RWRpdGFibGVXYXJuaW5nXCIhPT1mJiZcInN1cHByZXNzSHlkcmF0aW9uV2FybmluZ1wiIT09ZiYmXCJhdXRvRm9jdXNcIiE9PWYmJihjYS5oYXNPd25Qcm9wZXJ0eShmKT9udWxsIT1rJiZcIm9uU2Nyb2xsXCI9PT1mJiZHKFwic2Nyb2xsXCIsYSk6bnVsbCE9ayYmcWEoYSxmLGssZykpfXN3aXRjaChjKXtjYXNlIFwiaW5wdXRcIjpWYShhKTtjYihhLGQsITEpO1xuYnJlYWs7Y2FzZSBcInRleHRhcmVhXCI6VmEoYSk7amIoYSk7YnJlYWs7Y2FzZSBcIm9wdGlvblwiOm51bGwhPWQudmFsdWUmJmEuc2V0QXR0cmlidXRlKFwidmFsdWVcIixcIlwiK1NhKGQudmFsdWUpKTticmVhaztjYXNlIFwic2VsZWN0XCI6YS5tdWx0aXBsZT0hIWQubXVsdGlwbGU7Zj1kLnZhbHVlO251bGwhPWY/ZmIoYSwhIWQubXVsdGlwbGUsZiwhMSk6bnVsbCE9ZC5kZWZhdWx0VmFsdWUmJmZiKGEsISFkLm11bHRpcGxlLGQuZGVmYXVsdFZhbHVlLCEwKTticmVhaztkZWZhdWx0OlwiZnVuY3Rpb25cIj09PXR5cGVvZiBlLm9uQ2xpY2smJihhLm9uY2xpY2s9amYpfW1mKGMsZCkmJihiLmZsYWdzfD00KX1udWxsIT09Yi5yZWYmJihiLmZsYWdzfD0xMjgpfXJldHVybiBudWxsO2Nhc2UgNjppZihhJiZudWxsIT1iLnN0YXRlTm9kZSlFaShhLGIsYS5tZW1vaXplZFByb3BzLGQpO2Vsc2V7aWYoXCJzdHJpbmdcIiE9PXR5cGVvZiBkJiZudWxsPT09Yi5zdGF0ZU5vZGUpdGhyb3cgRXJyb3IoeSgxNjYpKTtcbmM9ZGgoY2guY3VycmVudCk7ZGgoYWguY3VycmVudCk7cmgoYik/KGQ9Yi5zdGF0ZU5vZGUsYz1iLm1lbW9pemVkUHJvcHMsZFt3Zl09YixkLm5vZGVWYWx1ZSE9PWMmJihiLmZsYWdzfD00KSk6KGQ9KDk9PT1jLm5vZGVUeXBlP2M6Yy5vd25lckRvY3VtZW50KS5jcmVhdGVUZXh0Tm9kZShkKSxkW3dmXT1iLGIuc3RhdGVOb2RlPWQpfXJldHVybiBudWxsO2Nhc2UgMTM6SChQKTtkPWIubWVtb2l6ZWRTdGF0ZTtpZigwIT09KGIuZmxhZ3MmNjQpKXJldHVybiBiLmxhbmVzPWMsYjtkPW51bGwhPT1kO2M9ITE7bnVsbD09PWE/dm9pZCAwIT09Yi5tZW1vaXplZFByb3BzLmZhbGxiYWNrJiZyaChiKTpjPW51bGwhPT1hLm1lbW9pemVkU3RhdGU7aWYoZCYmIWMmJjAhPT0oYi5tb2RlJjIpKWlmKG51bGw9PT1hJiYhMCE9PWIubWVtb2l6ZWRQcm9wcy51bnN0YWJsZV9hdm9pZFRoaXNGYWxsYmFja3x8MCE9PShQLmN1cnJlbnQmMSkpMD09PVYmJihWPTMpO2Vsc2V7aWYoMD09PVZ8fDM9PT1WKVY9XG40O251bGw9PT1VfHwwPT09KERnJjEzNDIxNzcyNykmJjA9PT0oSGkmMTM0MjE3NzI3KXx8SWkoVSxXKX1pZihkfHxjKWIuZmxhZ3N8PTQ7cmV0dXJuIG51bGw7Y2FzZSA0OnJldHVybiBmaCgpLENpKGIpLG51bGw9PT1hJiZjZihiLnN0YXRlTm9kZS5jb250YWluZXJJbmZvKSxudWxsO2Nhc2UgMTA6cmV0dXJuIHJnKGIpLG51bGw7Y2FzZSAxNzpyZXR1cm4gRmYoYi50eXBlKSYmR2YoKSxudWxsO2Nhc2UgMTk6SChQKTtkPWIubWVtb2l6ZWRTdGF0ZTtpZihudWxsPT09ZClyZXR1cm4gbnVsbDtmPTAhPT0oYi5mbGFncyY2NCk7Zz1kLnJlbmRlcmluZztpZihudWxsPT09ZylpZihmKUZpKGQsITEpO2Vsc2V7aWYoMCE9PVZ8fG51bGwhPT1hJiYwIT09KGEuZmxhZ3MmNjQpKWZvcihhPWIuY2hpbGQ7bnVsbCE9PWE7KXtnPWloKGEpO2lmKG51bGwhPT1nKXtiLmZsYWdzfD02NDtGaShkLCExKTtmPWcudXBkYXRlUXVldWU7bnVsbCE9PWYmJihiLnVwZGF0ZVF1ZXVlPWYsYi5mbGFnc3w9NCk7XG5udWxsPT09ZC5sYXN0RWZmZWN0JiYoYi5maXJzdEVmZmVjdD1udWxsKTtiLmxhc3RFZmZlY3Q9ZC5sYXN0RWZmZWN0O2Q9Yztmb3IoYz1iLmNoaWxkO251bGwhPT1jOylmPWMsYT1kLGYuZmxhZ3MmPTIsZi5uZXh0RWZmZWN0PW51bGwsZi5maXJzdEVmZmVjdD1udWxsLGYubGFzdEVmZmVjdD1udWxsLGc9Zi5hbHRlcm5hdGUsbnVsbD09PWc/KGYuY2hpbGRMYW5lcz0wLGYubGFuZXM9YSxmLmNoaWxkPW51bGwsZi5tZW1vaXplZFByb3BzPW51bGwsZi5tZW1vaXplZFN0YXRlPW51bGwsZi51cGRhdGVRdWV1ZT1udWxsLGYuZGVwZW5kZW5jaWVzPW51bGwsZi5zdGF0ZU5vZGU9bnVsbCk6KGYuY2hpbGRMYW5lcz1nLmNoaWxkTGFuZXMsZi5sYW5lcz1nLmxhbmVzLGYuY2hpbGQ9Zy5jaGlsZCxmLm1lbW9pemVkUHJvcHM9Zy5tZW1vaXplZFByb3BzLGYubWVtb2l6ZWRTdGF0ZT1nLm1lbW9pemVkU3RhdGUsZi51cGRhdGVRdWV1ZT1nLnVwZGF0ZVF1ZXVlLGYudHlwZT1nLnR5cGUsYT1nLmRlcGVuZGVuY2llcyxcbmYuZGVwZW5kZW5jaWVzPW51bGw9PT1hP251bGw6e2xhbmVzOmEubGFuZXMsZmlyc3RDb250ZXh0OmEuZmlyc3RDb250ZXh0fSksYz1jLnNpYmxpbmc7SShQLFAuY3VycmVudCYxfDIpO3JldHVybiBiLmNoaWxkfWE9YS5zaWJsaW5nfW51bGwhPT1kLnRhaWwmJk8oKT5KaSYmKGIuZmxhZ3N8PTY0LGY9ITAsRmkoZCwhMSksYi5sYW5lcz0zMzU1NDQzMil9ZWxzZXtpZighZilpZihhPWloKGcpLG51bGwhPT1hKXtpZihiLmZsYWdzfD02NCxmPSEwLGM9YS51cGRhdGVRdWV1ZSxudWxsIT09YyYmKGIudXBkYXRlUXVldWU9YyxiLmZsYWdzfD00KSxGaShkLCEwKSxudWxsPT09ZC50YWlsJiZcImhpZGRlblwiPT09ZC50YWlsTW9kZSYmIWcuYWx0ZXJuYXRlJiYhbGgpcmV0dXJuIGI9Yi5sYXN0RWZmZWN0PWQubGFzdEVmZmVjdCxudWxsIT09YiYmKGIubmV4dEVmZmVjdD1udWxsKSxudWxsfWVsc2UgMipPKCktZC5yZW5kZXJpbmdTdGFydFRpbWU+SmkmJjEwNzM3NDE4MjQhPT1jJiYoYi5mbGFnc3w9XG42NCxmPSEwLEZpKGQsITEpLGIubGFuZXM9MzM1NTQ0MzIpO2QuaXNCYWNrd2FyZHM/KGcuc2libGluZz1iLmNoaWxkLGIuY2hpbGQ9Zyk6KGM9ZC5sYXN0LG51bGwhPT1jP2Muc2libGluZz1nOmIuY2hpbGQ9ZyxkLmxhc3Q9Zyl9cmV0dXJuIG51bGwhPT1kLnRhaWw/KGM9ZC50YWlsLGQucmVuZGVyaW5nPWMsZC50YWlsPWMuc2libGluZyxkLmxhc3RFZmZlY3Q9Yi5sYXN0RWZmZWN0LGQucmVuZGVyaW5nU3RhcnRUaW1lPU8oKSxjLnNpYmxpbmc9bnVsbCxiPVAuY3VycmVudCxJKFAsZj9iJjF8MjpiJjEpLGMpOm51bGw7Y2FzZSAyMzpjYXNlIDI0OnJldHVybiBLaSgpLG51bGwhPT1hJiZudWxsIT09YS5tZW1vaXplZFN0YXRlIT09KG51bGwhPT1iLm1lbW9pemVkU3RhdGUpJiZcInVuc3RhYmxlLWRlZmVyLXdpdGhvdXQtaGlkaW5nXCIhPT1kLm1vZGUmJihiLmZsYWdzfD00KSxudWxsfXRocm93IEVycm9yKHkoMTU2LGIudGFnKSk7fVxuZnVuY3Rpb24gTGkoYSl7c3dpdGNoKGEudGFnKXtjYXNlIDE6RmYoYS50eXBlKSYmR2YoKTt2YXIgYj1hLmZsYWdzO3JldHVybiBiJjQwOTY/KGEuZmxhZ3M9YiYtNDA5N3w2NCxhKTpudWxsO2Nhc2UgMzpmaCgpO0goTik7SChNKTt1aCgpO2I9YS5mbGFncztpZigwIT09KGImNjQpKXRocm93IEVycm9yKHkoMjg1KSk7YS5mbGFncz1iJi00MDk3fDY0O3JldHVybiBhO2Nhc2UgNTpyZXR1cm4gaGgoYSksbnVsbDtjYXNlIDEzOnJldHVybiBIKFApLGI9YS5mbGFncyxiJjQwOTY/KGEuZmxhZ3M9YiYtNDA5N3w2NCxhKTpudWxsO2Nhc2UgMTk6cmV0dXJuIEgoUCksbnVsbDtjYXNlIDQ6cmV0dXJuIGZoKCksbnVsbDtjYXNlIDEwOnJldHVybiByZyhhKSxudWxsO2Nhc2UgMjM6Y2FzZSAyNDpyZXR1cm4gS2koKSxudWxsO2RlZmF1bHQ6cmV0dXJuIG51bGx9fVxuZnVuY3Rpb24gTWkoYSxiKXt0cnl7dmFyIGM9XCJcIixkPWI7ZG8gYys9UWEoZCksZD1kLnJldHVybjt3aGlsZShkKTt2YXIgZT1jfWNhdGNoKGYpe2U9XCJcXG5FcnJvciBnZW5lcmF0aW5nIHN0YWNrOiBcIitmLm1lc3NhZ2UrXCJcXG5cIitmLnN0YWNrfXJldHVybnt2YWx1ZTphLHNvdXJjZTpiLHN0YWNrOmV9fWZ1bmN0aW9uIE5pKGEsYil7dHJ5e2NvbnNvbGUuZXJyb3IoYi52YWx1ZSl9Y2F0Y2goYyl7c2V0VGltZW91dChmdW5jdGlvbigpe3Rocm93IGM7fSl9fXZhciBPaT1cImZ1bmN0aW9uXCI9PT10eXBlb2YgV2Vha01hcD9XZWFrTWFwOk1hcDtmdW5jdGlvbiBQaShhLGIsYyl7Yz16ZygtMSxjKTtjLnRhZz0zO2MucGF5bG9hZD17ZWxlbWVudDpudWxsfTt2YXIgZD1iLnZhbHVlO2MuY2FsbGJhY2s9ZnVuY3Rpb24oKXtRaXx8KFFpPSEwLFJpPWQpO05pKGEsYil9O3JldHVybiBjfVxuZnVuY3Rpb24gU2koYSxiLGMpe2M9emcoLTEsYyk7Yy50YWc9Mzt2YXIgZD1hLnR5cGUuZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yO2lmKFwiZnVuY3Rpb25cIj09PXR5cGVvZiBkKXt2YXIgZT1iLnZhbHVlO2MucGF5bG9hZD1mdW5jdGlvbigpe05pKGEsYik7cmV0dXJuIGQoZSl9fXZhciBmPWEuc3RhdGVOb2RlO251bGwhPT1mJiZcImZ1bmN0aW9uXCI9PT10eXBlb2YgZi5jb21wb25lbnREaWRDYXRjaCYmKGMuY2FsbGJhY2s9ZnVuY3Rpb24oKXtcImZ1bmN0aW9uXCIhPT10eXBlb2YgZCYmKG51bGw9PT1UaT9UaT1uZXcgU2V0KFt0aGlzXSk6VGkuYWRkKHRoaXMpLE5pKGEsYikpO3ZhciBjPWIuc3RhY2s7dGhpcy5jb21wb25lbnREaWRDYXRjaChiLnZhbHVlLHtjb21wb25lbnRTdGFjazpudWxsIT09Yz9jOlwiXCJ9KX0pO3JldHVybiBjfXZhciBVaT1cImZ1bmN0aW9uXCI9PT10eXBlb2YgV2Vha1NldD9XZWFrU2V0OlNldDtcbmZ1bmN0aW9uIFZpKGEpe3ZhciBiPWEucmVmO2lmKG51bGwhPT1iKWlmKFwiZnVuY3Rpb25cIj09PXR5cGVvZiBiKXRyeXtiKG51bGwpfWNhdGNoKGMpe1dpKGEsYyl9ZWxzZSBiLmN1cnJlbnQ9bnVsbH1mdW5jdGlvbiBYaShhLGIpe3N3aXRjaChiLnRhZyl7Y2FzZSAwOmNhc2UgMTE6Y2FzZSAxNTpjYXNlIDIyOnJldHVybjtjYXNlIDE6aWYoYi5mbGFncyYyNTYmJm51bGwhPT1hKXt2YXIgYz1hLm1lbW9pemVkUHJvcHMsZD1hLm1lbW9pemVkU3RhdGU7YT1iLnN0YXRlTm9kZTtiPWEuZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUoYi5lbGVtZW50VHlwZT09PWIudHlwZT9jOmxnKGIudHlwZSxjKSxkKTthLl9fcmVhY3RJbnRlcm5hbFNuYXBzaG90QmVmb3JlVXBkYXRlPWJ9cmV0dXJuO2Nhc2UgMzpiLmZsYWdzJjI1NiYmcWYoYi5zdGF0ZU5vZGUuY29udGFpbmVySW5mbyk7cmV0dXJuO2Nhc2UgNTpjYXNlIDY6Y2FzZSA0OmNhc2UgMTc6cmV0dXJufXRocm93IEVycm9yKHkoMTYzKSk7fVxuZnVuY3Rpb24gWWkoYSxiLGMpe3N3aXRjaChjLnRhZyl7Y2FzZSAwOmNhc2UgMTE6Y2FzZSAxNTpjYXNlIDIyOmI9Yy51cGRhdGVRdWV1ZTtiPW51bGwhPT1iP2IubGFzdEVmZmVjdDpudWxsO2lmKG51bGwhPT1iKXthPWI9Yi5uZXh0O2Rve2lmKDM9PT0oYS50YWcmMykpe3ZhciBkPWEuY3JlYXRlO2EuZGVzdHJveT1kKCl9YT1hLm5leHR9d2hpbGUoYSE9PWIpfWI9Yy51cGRhdGVRdWV1ZTtiPW51bGwhPT1iP2IubGFzdEVmZmVjdDpudWxsO2lmKG51bGwhPT1iKXthPWI9Yi5uZXh0O2Rve3ZhciBlPWE7ZD1lLm5leHQ7ZT1lLnRhZzswIT09KGUmNCkmJjAhPT0oZSYxKSYmKFppKGMsYSksJGkoYyxhKSk7YT1kfXdoaWxlKGEhPT1iKX1yZXR1cm47Y2FzZSAxOmE9Yy5zdGF0ZU5vZGU7Yy5mbGFncyY0JiYobnVsbD09PWI/YS5jb21wb25lbnREaWRNb3VudCgpOihkPWMuZWxlbWVudFR5cGU9PT1jLnR5cGU/Yi5tZW1vaXplZFByb3BzOmxnKGMudHlwZSxiLm1lbW9pemVkUHJvcHMpLGEuY29tcG9uZW50RGlkVXBkYXRlKGQsXG5iLm1lbW9pemVkU3RhdGUsYS5fX3JlYWN0SW50ZXJuYWxTbmFwc2hvdEJlZm9yZVVwZGF0ZSkpKTtiPWMudXBkYXRlUXVldWU7bnVsbCE9PWImJkVnKGMsYixhKTtyZXR1cm47Y2FzZSAzOmI9Yy51cGRhdGVRdWV1ZTtpZihudWxsIT09Yil7YT1udWxsO2lmKG51bGwhPT1jLmNoaWxkKXN3aXRjaChjLmNoaWxkLnRhZyl7Y2FzZSA1OmE9Yy5jaGlsZC5zdGF0ZU5vZGU7YnJlYWs7Y2FzZSAxOmE9Yy5jaGlsZC5zdGF0ZU5vZGV9RWcoYyxiLGEpfXJldHVybjtjYXNlIDU6YT1jLnN0YXRlTm9kZTtudWxsPT09YiYmYy5mbGFncyY0JiZtZihjLnR5cGUsYy5tZW1vaXplZFByb3BzKSYmYS5mb2N1cygpO3JldHVybjtjYXNlIDY6cmV0dXJuO2Nhc2UgNDpyZXR1cm47Y2FzZSAxMjpyZXR1cm47Y2FzZSAxMzpudWxsPT09Yy5tZW1vaXplZFN0YXRlJiYoYz1jLmFsdGVybmF0ZSxudWxsIT09YyYmKGM9Yy5tZW1vaXplZFN0YXRlLG51bGwhPT1jJiYoYz1jLmRlaHlkcmF0ZWQsbnVsbCE9PWMmJkNjKGMpKSkpO1xucmV0dXJuO2Nhc2UgMTk6Y2FzZSAxNzpjYXNlIDIwOmNhc2UgMjE6Y2FzZSAyMzpjYXNlIDI0OnJldHVybn10aHJvdyBFcnJvcih5KDE2MykpO31cbmZ1bmN0aW9uIGFqKGEsYil7Zm9yKHZhciBjPWE7Oyl7aWYoNT09PWMudGFnKXt2YXIgZD1jLnN0YXRlTm9kZTtpZihiKWQ9ZC5zdHlsZSxcImZ1bmN0aW9uXCI9PT10eXBlb2YgZC5zZXRQcm9wZXJ0eT9kLnNldFByb3BlcnR5KFwiZGlzcGxheVwiLFwibm9uZVwiLFwiaW1wb3J0YW50XCIpOmQuZGlzcGxheT1cIm5vbmVcIjtlbHNle2Q9Yy5zdGF0ZU5vZGU7dmFyIGU9Yy5tZW1vaXplZFByb3BzLnN0eWxlO2U9dm9pZCAwIT09ZSYmbnVsbCE9PWUmJmUuaGFzT3duUHJvcGVydHkoXCJkaXNwbGF5XCIpP2UuZGlzcGxheTpudWxsO2Quc3R5bGUuZGlzcGxheT1zYihcImRpc3BsYXlcIixlKX19ZWxzZSBpZig2PT09Yy50YWcpYy5zdGF0ZU5vZGUubm9kZVZhbHVlPWI/XCJcIjpjLm1lbW9pemVkUHJvcHM7ZWxzZSBpZigoMjMhPT1jLnRhZyYmMjQhPT1jLnRhZ3x8bnVsbD09PWMubWVtb2l6ZWRTdGF0ZXx8Yz09PWEpJiZudWxsIT09Yy5jaGlsZCl7Yy5jaGlsZC5yZXR1cm49YztjPWMuY2hpbGQ7Y29udGludWV9aWYoYz09PVxuYSlicmVhaztmb3IoO251bGw9PT1jLnNpYmxpbmc7KXtpZihudWxsPT09Yy5yZXR1cm58fGMucmV0dXJuPT09YSlyZXR1cm47Yz1jLnJldHVybn1jLnNpYmxpbmcucmV0dXJuPWMucmV0dXJuO2M9Yy5zaWJsaW5nfX1cbmZ1bmN0aW9uIGJqKGEsYil7aWYoTWYmJlwiZnVuY3Rpb25cIj09PXR5cGVvZiBNZi5vbkNvbW1pdEZpYmVyVW5tb3VudCl0cnl7TWYub25Db21taXRGaWJlclVubW91bnQoTGYsYil9Y2F0Y2goZil7fXN3aXRjaChiLnRhZyl7Y2FzZSAwOmNhc2UgMTE6Y2FzZSAxNDpjYXNlIDE1OmNhc2UgMjI6YT1iLnVwZGF0ZVF1ZXVlO2lmKG51bGwhPT1hJiYoYT1hLmxhc3RFZmZlY3QsbnVsbCE9PWEpKXt2YXIgYz1hPWEubmV4dDtkb3t2YXIgZD1jLGU9ZC5kZXN0cm95O2Q9ZC50YWc7aWYodm9pZCAwIT09ZSlpZigwIT09KGQmNCkpWmkoYixjKTtlbHNle2Q9Yjt0cnl7ZSgpfWNhdGNoKGYpe1dpKGQsZil9fWM9Yy5uZXh0fXdoaWxlKGMhPT1hKX1icmVhaztjYXNlIDE6VmkoYik7YT1iLnN0YXRlTm9kZTtpZihcImZ1bmN0aW9uXCI9PT10eXBlb2YgYS5jb21wb25lbnRXaWxsVW5tb3VudCl0cnl7YS5wcm9wcz1iLm1lbW9pemVkUHJvcHMsYS5zdGF0ZT1iLm1lbW9pemVkU3RhdGUsYS5jb21wb25lbnRXaWxsVW5tb3VudCgpfWNhdGNoKGYpe1dpKGIsXG5mKX1icmVhaztjYXNlIDU6VmkoYik7YnJlYWs7Y2FzZSA0OmNqKGEsYil9fWZ1bmN0aW9uIGRqKGEpe2EuYWx0ZXJuYXRlPW51bGw7YS5jaGlsZD1udWxsO2EuZGVwZW5kZW5jaWVzPW51bGw7YS5maXJzdEVmZmVjdD1udWxsO2EubGFzdEVmZmVjdD1udWxsO2EubWVtb2l6ZWRQcm9wcz1udWxsO2EubWVtb2l6ZWRTdGF0ZT1udWxsO2EucGVuZGluZ1Byb3BzPW51bGw7YS5yZXR1cm49bnVsbDthLnVwZGF0ZVF1ZXVlPW51bGx9ZnVuY3Rpb24gZWooYSl7cmV0dXJuIDU9PT1hLnRhZ3x8Mz09PWEudGFnfHw0PT09YS50YWd9XG5mdW5jdGlvbiBmaihhKXthOntmb3IodmFyIGI9YS5yZXR1cm47bnVsbCE9PWI7KXtpZihlaihiKSlicmVhayBhO2I9Yi5yZXR1cm59dGhyb3cgRXJyb3IoeSgxNjApKTt9dmFyIGM9YjtiPWMuc3RhdGVOb2RlO3N3aXRjaChjLnRhZyl7Y2FzZSA1OnZhciBkPSExO2JyZWFrO2Nhc2UgMzpiPWIuY29udGFpbmVySW5mbztkPSEwO2JyZWFrO2Nhc2UgNDpiPWIuY29udGFpbmVySW5mbztkPSEwO2JyZWFrO2RlZmF1bHQ6dGhyb3cgRXJyb3IoeSgxNjEpKTt9Yy5mbGFncyYxNiYmKHBiKGIsXCJcIiksYy5mbGFncyY9LTE3KTthOmI6Zm9yKGM9YTs7KXtmb3IoO251bGw9PT1jLnNpYmxpbmc7KXtpZihudWxsPT09Yy5yZXR1cm58fGVqKGMucmV0dXJuKSl7Yz1udWxsO2JyZWFrIGF9Yz1jLnJldHVybn1jLnNpYmxpbmcucmV0dXJuPWMucmV0dXJuO2ZvcihjPWMuc2libGluZzs1IT09Yy50YWcmJjYhPT1jLnRhZyYmMTghPT1jLnRhZzspe2lmKGMuZmxhZ3MmMiljb250aW51ZSBiO2lmKG51bGw9PT1cbmMuY2hpbGR8fDQ9PT1jLnRhZyljb250aW51ZSBiO2Vsc2UgYy5jaGlsZC5yZXR1cm49YyxjPWMuY2hpbGR9aWYoIShjLmZsYWdzJjIpKXtjPWMuc3RhdGVOb2RlO2JyZWFrIGF9fWQ/Z2ooYSxjLGIpOmhqKGEsYyxiKX1cbmZ1bmN0aW9uIGdqKGEsYixjKXt2YXIgZD1hLnRhZyxlPTU9PT1kfHw2PT09ZDtpZihlKWE9ZT9hLnN0YXRlTm9kZTphLnN0YXRlTm9kZS5pbnN0YW5jZSxiPzg9PT1jLm5vZGVUeXBlP2MucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoYSxiKTpjLmluc2VydEJlZm9yZShhLGIpOig4PT09Yy5ub2RlVHlwZT8oYj1jLnBhcmVudE5vZGUsYi5pbnNlcnRCZWZvcmUoYSxjKSk6KGI9YyxiLmFwcGVuZENoaWxkKGEpKSxjPWMuX3JlYWN0Um9vdENvbnRhaW5lcixudWxsIT09YyYmdm9pZCAwIT09Y3x8bnVsbCE9PWIub25jbGlja3x8KGIub25jbGljaz1qZikpO2Vsc2UgaWYoNCE9PWQmJihhPWEuY2hpbGQsbnVsbCE9PWEpKWZvcihnaihhLGIsYyksYT1hLnNpYmxpbmc7bnVsbCE9PWE7KWdqKGEsYixjKSxhPWEuc2libGluZ31cbmZ1bmN0aW9uIGhqKGEsYixjKXt2YXIgZD1hLnRhZyxlPTU9PT1kfHw2PT09ZDtpZihlKWE9ZT9hLnN0YXRlTm9kZTphLnN0YXRlTm9kZS5pbnN0YW5jZSxiP2MuaW5zZXJ0QmVmb3JlKGEsYik6Yy5hcHBlbmRDaGlsZChhKTtlbHNlIGlmKDQhPT1kJiYoYT1hLmNoaWxkLG51bGwhPT1hKSlmb3IoaGooYSxiLGMpLGE9YS5zaWJsaW5nO251bGwhPT1hOyloaihhLGIsYyksYT1hLnNpYmxpbmd9XG5mdW5jdGlvbiBjaihhLGIpe2Zvcih2YXIgYz1iLGQ9ITEsZSxmOzspe2lmKCFkKXtkPWMucmV0dXJuO2E6Zm9yKDs7KXtpZihudWxsPT09ZCl0aHJvdyBFcnJvcih5KDE2MCkpO2U9ZC5zdGF0ZU5vZGU7c3dpdGNoKGQudGFnKXtjYXNlIDU6Zj0hMTticmVhayBhO2Nhc2UgMzplPWUuY29udGFpbmVySW5mbztmPSEwO2JyZWFrIGE7Y2FzZSA0OmU9ZS5jb250YWluZXJJbmZvO2Y9ITA7YnJlYWsgYX1kPWQucmV0dXJufWQ9ITB9aWYoNT09PWMudGFnfHw2PT09Yy50YWcpe2E6Zm9yKHZhciBnPWEsaD1jLGs9aDs7KWlmKGJqKGcsayksbnVsbCE9PWsuY2hpbGQmJjQhPT1rLnRhZylrLmNoaWxkLnJldHVybj1rLGs9ay5jaGlsZDtlbHNle2lmKGs9PT1oKWJyZWFrIGE7Zm9yKDtudWxsPT09ay5zaWJsaW5nOyl7aWYobnVsbD09PWsucmV0dXJufHxrLnJldHVybj09PWgpYnJlYWsgYTtrPWsucmV0dXJufWsuc2libGluZy5yZXR1cm49ay5yZXR1cm47az1rLnNpYmxpbmd9Zj8oZz1lLGg9Yy5zdGF0ZU5vZGUsXG44PT09Zy5ub2RlVHlwZT9nLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoaCk6Zy5yZW1vdmVDaGlsZChoKSk6ZS5yZW1vdmVDaGlsZChjLnN0YXRlTm9kZSl9ZWxzZSBpZig0PT09Yy50YWcpe2lmKG51bGwhPT1jLmNoaWxkKXtlPWMuc3RhdGVOb2RlLmNvbnRhaW5lckluZm87Zj0hMDtjLmNoaWxkLnJldHVybj1jO2M9Yy5jaGlsZDtjb250aW51ZX19ZWxzZSBpZihiaihhLGMpLG51bGwhPT1jLmNoaWxkKXtjLmNoaWxkLnJldHVybj1jO2M9Yy5jaGlsZDtjb250aW51ZX1pZihjPT09YilicmVhaztmb3IoO251bGw9PT1jLnNpYmxpbmc7KXtpZihudWxsPT09Yy5yZXR1cm58fGMucmV0dXJuPT09YilyZXR1cm47Yz1jLnJldHVybjs0PT09Yy50YWcmJihkPSExKX1jLnNpYmxpbmcucmV0dXJuPWMucmV0dXJuO2M9Yy5zaWJsaW5nfX1cbmZ1bmN0aW9uIGlqKGEsYil7c3dpdGNoKGIudGFnKXtjYXNlIDA6Y2FzZSAxMTpjYXNlIDE0OmNhc2UgMTU6Y2FzZSAyMjp2YXIgYz1iLnVwZGF0ZVF1ZXVlO2M9bnVsbCE9PWM/Yy5sYXN0RWZmZWN0Om51bGw7aWYobnVsbCE9PWMpe3ZhciBkPWM9Yy5uZXh0O2RvIDM9PT0oZC50YWcmMykmJihhPWQuZGVzdHJveSxkLmRlc3Ryb3k9dm9pZCAwLHZvaWQgMCE9PWEmJmEoKSksZD1kLm5leHQ7d2hpbGUoZCE9PWMpfXJldHVybjtjYXNlIDE6cmV0dXJuO2Nhc2UgNTpjPWIuc3RhdGVOb2RlO2lmKG51bGwhPWMpe2Q9Yi5tZW1vaXplZFByb3BzO3ZhciBlPW51bGwhPT1hP2EubWVtb2l6ZWRQcm9wczpkO2E9Yi50eXBlO3ZhciBmPWIudXBkYXRlUXVldWU7Yi51cGRhdGVRdWV1ZT1udWxsO2lmKG51bGwhPT1mKXtjW3hmXT1kO1wiaW5wdXRcIj09PWEmJlwicmFkaW9cIj09PWQudHlwZSYmbnVsbCE9ZC5uYW1lJiYkYShjLGQpO3diKGEsZSk7Yj13YihhLGQpO2ZvcihlPTA7ZTxmLmxlbmd0aDtlKz1cbjIpe3ZhciBnPWZbZV0saD1mW2UrMV07XCJzdHlsZVwiPT09Zz90YihjLGgpOlwiZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxcIj09PWc/b2IoYyxoKTpcImNoaWxkcmVuXCI9PT1nP3BiKGMsaCk6cWEoYyxnLGgsYil9c3dpdGNoKGEpe2Nhc2UgXCJpbnB1dFwiOmFiKGMsZCk7YnJlYWs7Y2FzZSBcInRleHRhcmVhXCI6aWIoYyxkKTticmVhaztjYXNlIFwic2VsZWN0XCI6YT1jLl93cmFwcGVyU3RhdGUud2FzTXVsdGlwbGUsYy5fd3JhcHBlclN0YXRlLndhc011bHRpcGxlPSEhZC5tdWx0aXBsZSxmPWQudmFsdWUsbnVsbCE9Zj9mYihjLCEhZC5tdWx0aXBsZSxmLCExKTphIT09ISFkLm11bHRpcGxlJiYobnVsbCE9ZC5kZWZhdWx0VmFsdWU/ZmIoYywhIWQubXVsdGlwbGUsZC5kZWZhdWx0VmFsdWUsITApOmZiKGMsISFkLm11bHRpcGxlLGQubXVsdGlwbGU/W106XCJcIiwhMSkpfX19cmV0dXJuO2Nhc2UgNjppZihudWxsPT09Yi5zdGF0ZU5vZGUpdGhyb3cgRXJyb3IoeSgxNjIpKTtiLnN0YXRlTm9kZS5ub2RlVmFsdWU9XG5iLm1lbW9pemVkUHJvcHM7cmV0dXJuO2Nhc2UgMzpjPWIuc3RhdGVOb2RlO2MuaHlkcmF0ZSYmKGMuaHlkcmF0ZT0hMSxDYyhjLmNvbnRhaW5lckluZm8pKTtyZXR1cm47Y2FzZSAxMjpyZXR1cm47Y2FzZSAxMzpudWxsIT09Yi5tZW1vaXplZFN0YXRlJiYoamo9TygpLGFqKGIuY2hpbGQsITApKTtraihiKTtyZXR1cm47Y2FzZSAxOTpraihiKTtyZXR1cm47Y2FzZSAxNzpyZXR1cm47Y2FzZSAyMzpjYXNlIDI0OmFqKGIsbnVsbCE9PWIubWVtb2l6ZWRTdGF0ZSk7cmV0dXJufXRocm93IEVycm9yKHkoMTYzKSk7fWZ1bmN0aW9uIGtqKGEpe3ZhciBiPWEudXBkYXRlUXVldWU7aWYobnVsbCE9PWIpe2EudXBkYXRlUXVldWU9bnVsbDt2YXIgYz1hLnN0YXRlTm9kZTtudWxsPT09YyYmKGM9YS5zdGF0ZU5vZGU9bmV3IFVpKTtiLmZvckVhY2goZnVuY3Rpb24oYil7dmFyIGQ9bGouYmluZChudWxsLGEsYik7Yy5oYXMoYil8fChjLmFkZChiKSxiLnRoZW4oZCxkKSl9KX19XG5mdW5jdGlvbiBtaihhLGIpe3JldHVybiBudWxsIT09YSYmKGE9YS5tZW1vaXplZFN0YXRlLG51bGw9PT1hfHxudWxsIT09YS5kZWh5ZHJhdGVkKT8oYj1iLm1lbW9pemVkU3RhdGUsbnVsbCE9PWImJm51bGw9PT1iLmRlaHlkcmF0ZWQpOiExfXZhciBuaj1NYXRoLmNlaWwsb2o9cmEuUmVhY3RDdXJyZW50RGlzcGF0Y2hlcixwaj1yYS5SZWFjdEN1cnJlbnRPd25lcixYPTAsVT1udWxsLFk9bnVsbCxXPTAscWo9MCxyaj1CZigwKSxWPTAsc2o9bnVsbCx0aj0wLERnPTAsSGk9MCx1aj0wLHZqPW51bGwsamo9MCxKaT1JbmZpbml0eTtmdW5jdGlvbiB3aigpe0ppPU8oKSs1MDB9dmFyIFo9bnVsbCxRaT0hMSxSaT1udWxsLFRpPW51bGwseGo9ITEseWo9bnVsbCx6aj05MCxBaj1bXSxCaj1bXSxDaj1udWxsLERqPTAsRWo9bnVsbCxGaj0tMSxHaj0wLEhqPTAsSWo9bnVsbCxKaj0hMTtmdW5jdGlvbiBIZygpe3JldHVybiAwIT09KFgmNDgpP08oKTotMSE9PUZqP0ZqOkZqPU8oKX1cbmZ1bmN0aW9uIElnKGEpe2E9YS5tb2RlO2lmKDA9PT0oYSYyKSlyZXR1cm4gMTtpZigwPT09KGEmNCkpcmV0dXJuIDk5PT09ZWcoKT8xOjI7MD09PUdqJiYoR2o9dGopO2lmKDAhPT1rZy50cmFuc2l0aW9uKXswIT09SGomJihIaj1udWxsIT09dmo/dmoucGVuZGluZ0xhbmVzOjApO2E9R2o7dmFyIGI9NDE4NjExMiZ+SGo7YiY9LWI7MD09PWImJihhPTQxODYxMTImfmEsYj1hJi1hLDA9PT1iJiYoYj04MTkyKSk7cmV0dXJuIGJ9YT1lZygpOzAhPT0oWCY0KSYmOTg9PT1hP2E9WGMoMTIsR2opOihhPVNjKGEpLGE9WGMoYSxHaikpO3JldHVybiBhfVxuZnVuY3Rpb24gSmcoYSxiLGMpe2lmKDUwPERqKXRocm93IERqPTAsRWo9bnVsbCxFcnJvcih5KDE4NSkpO2E9S2ooYSxiKTtpZihudWxsPT09YSlyZXR1cm4gbnVsbDskYyhhLGIsYyk7YT09PVUmJihIaXw9Yiw0PT09ViYmSWkoYSxXKSk7dmFyIGQ9ZWcoKTsxPT09Yj8wIT09KFgmOCkmJjA9PT0oWCY0OCk/TGooYSk6KE1qKGEsYyksMD09PVgmJih3aigpLGlnKCkpKTooMD09PShYJjQpfHw5OCE9PWQmJjk5IT09ZHx8KG51bGw9PT1Daj9Daj1uZXcgU2V0KFthXSk6Q2ouYWRkKGEpKSxNaihhLGMpKTt2aj1hfWZ1bmN0aW9uIEtqKGEsYil7YS5sYW5lc3w9Yjt2YXIgYz1hLmFsdGVybmF0ZTtudWxsIT09YyYmKGMubGFuZXN8PWIpO2M9YTtmb3IoYT1hLnJldHVybjtudWxsIT09YTspYS5jaGlsZExhbmVzfD1iLGM9YS5hbHRlcm5hdGUsbnVsbCE9PWMmJihjLmNoaWxkTGFuZXN8PWIpLGM9YSxhPWEucmV0dXJuO3JldHVybiAzPT09Yy50YWc/Yy5zdGF0ZU5vZGU6bnVsbH1cbmZ1bmN0aW9uIE1qKGEsYil7Zm9yKHZhciBjPWEuY2FsbGJhY2tOb2RlLGQ9YS5zdXNwZW5kZWRMYW5lcyxlPWEucGluZ2VkTGFuZXMsZj1hLmV4cGlyYXRpb25UaW1lcyxnPWEucGVuZGluZ0xhbmVzOzA8Zzspe3ZhciBoPTMxLVZjKGcpLGs9MTw8aCxsPWZbaF07aWYoLTE9PT1sKXtpZigwPT09KGsmZCl8fDAhPT0oayZlKSl7bD1iO1JjKGspO3ZhciBuPUY7ZltoXT0xMDw9bj9sKzI1MDo2PD1uP2wrNUUzOi0xfX1lbHNlIGw8PWImJihhLmV4cGlyZWRMYW5lc3w9ayk7ZyY9fmt9ZD1VYyhhLGE9PT1VP1c6MCk7Yj1GO2lmKDA9PT1kKW51bGwhPT1jJiYoYyE9PVpmJiZQZihjKSxhLmNhbGxiYWNrTm9kZT1udWxsLGEuY2FsbGJhY2tQcmlvcml0eT0wKTtlbHNle2lmKG51bGwhPT1jKXtpZihhLmNhbGxiYWNrUHJpb3JpdHk9PT1iKXJldHVybjtjIT09WmYmJlBmKGMpfTE1PT09Yj8oYz1Mai5iaW5kKG51bGwsYSksbnVsbD09PWFnPyhhZz1bY10sYmc9T2YoVWYsamcpKTphZy5wdXNoKGMpLFxuYz1aZik6MTQ9PT1iP2M9aGcoOTksTGouYmluZChudWxsLGEpKTooYz1UYyhiKSxjPWhnKGMsTmouYmluZChudWxsLGEpKSk7YS5jYWxsYmFja1ByaW9yaXR5PWI7YS5jYWxsYmFja05vZGU9Y319XG5mdW5jdGlvbiBOaihhKXtGaj0tMTtIaj1Haj0wO2lmKDAhPT0oWCY0OCkpdGhyb3cgRXJyb3IoeSgzMjcpKTt2YXIgYj1hLmNhbGxiYWNrTm9kZTtpZihPaigpJiZhLmNhbGxiYWNrTm9kZSE9PWIpcmV0dXJuIG51bGw7dmFyIGM9VWMoYSxhPT09VT9XOjApO2lmKDA9PT1jKXJldHVybiBudWxsO3ZhciBkPWM7dmFyIGU9WDtYfD0xNjt2YXIgZj1QaigpO2lmKFUhPT1hfHxXIT09ZCl3aigpLFFqKGEsZCk7ZG8gdHJ5e1JqKCk7YnJlYWt9Y2F0Y2goaCl7U2ooYSxoKX13aGlsZSgxKTtxZygpO29qLmN1cnJlbnQ9ZjtYPWU7bnVsbCE9PVk/ZD0wOihVPW51bGwsVz0wLGQ9Vik7aWYoMCE9PSh0aiZIaSkpUWooYSwwKTtlbHNlIGlmKDAhPT1kKXsyPT09ZCYmKFh8PTY0LGEuaHlkcmF0ZSYmKGEuaHlkcmF0ZT0hMSxxZihhLmNvbnRhaW5lckluZm8pKSxjPVdjKGEpLDAhPT1jJiYoZD1UaihhLGMpKSk7aWYoMT09PWQpdGhyb3cgYj1zaixRaihhLDApLElpKGEsYyksTWooYSxPKCkpLGI7YS5maW5pc2hlZFdvcms9XG5hLmN1cnJlbnQuYWx0ZXJuYXRlO2EuZmluaXNoZWRMYW5lcz1jO3N3aXRjaChkKXtjYXNlIDA6Y2FzZSAxOnRocm93IEVycm9yKHkoMzQ1KSk7Y2FzZSAyOlVqKGEpO2JyZWFrO2Nhc2UgMzpJaShhLGMpO2lmKChjJjYyOTE0NTYwKT09PWMmJihkPWpqKzUwMC1PKCksMTA8ZCkpe2lmKDAhPT1VYyhhLDApKWJyZWFrO2U9YS5zdXNwZW5kZWRMYW5lcztpZigoZSZjKSE9PWMpe0hnKCk7YS5waW5nZWRMYW5lc3w9YS5zdXNwZW5kZWRMYW5lcyZlO2JyZWFrfWEudGltZW91dEhhbmRsZT1vZihVai5iaW5kKG51bGwsYSksZCk7YnJlYWt9VWooYSk7YnJlYWs7Y2FzZSA0OklpKGEsYyk7aWYoKGMmNDE4NjExMik9PT1jKWJyZWFrO2Q9YS5ldmVudFRpbWVzO2ZvcihlPS0xOzA8Yzspe3ZhciBnPTMxLVZjKGMpO2Y9MTw8ZztnPWRbZ107Zz5lJiYoZT1nKTtjJj1+Zn1jPWU7Yz1PKCktYztjPSgxMjA+Yz8xMjA6NDgwPmM/NDgwOjEwODA+Yz8xMDgwOjE5MjA+Yz8xOTIwOjNFMz5jPzNFMzo0MzIwPlxuYz80MzIwOjE5NjAqbmooYy8xOTYwKSktYztpZigxMDxjKXthLnRpbWVvdXRIYW5kbGU9b2YoVWouYmluZChudWxsLGEpLGMpO2JyZWFrfVVqKGEpO2JyZWFrO2Nhc2UgNTpVaihhKTticmVhaztkZWZhdWx0OnRocm93IEVycm9yKHkoMzI5KSk7fX1NaihhLE8oKSk7cmV0dXJuIGEuY2FsbGJhY2tOb2RlPT09Yj9Oai5iaW5kKG51bGwsYSk6bnVsbH1mdW5jdGlvbiBJaShhLGIpe2ImPX51ajtiJj1+SGk7YS5zdXNwZW5kZWRMYW5lc3w9YjthLnBpbmdlZExhbmVzJj1+Yjtmb3IoYT1hLmV4cGlyYXRpb25UaW1lczswPGI7KXt2YXIgYz0zMS1WYyhiKSxkPTE8PGM7YVtjXT0tMTtiJj1+ZH19XG5mdW5jdGlvbiBMaihhKXtpZigwIT09KFgmNDgpKXRocm93IEVycm9yKHkoMzI3KSk7T2ooKTtpZihhPT09VSYmMCE9PShhLmV4cGlyZWRMYW5lcyZXKSl7dmFyIGI9Vzt2YXIgYz1UaihhLGIpOzAhPT0odGomSGkpJiYoYj1VYyhhLGIpLGM9VGooYSxiKSl9ZWxzZSBiPVVjKGEsMCksYz1UaihhLGIpOzAhPT1hLnRhZyYmMj09PWMmJihYfD02NCxhLmh5ZHJhdGUmJihhLmh5ZHJhdGU9ITEscWYoYS5jb250YWluZXJJbmZvKSksYj1XYyhhKSwwIT09YiYmKGM9VGooYSxiKSkpO2lmKDE9PT1jKXRocm93IGM9c2osUWooYSwwKSxJaShhLGIpLE1qKGEsTygpKSxjO2EuZmluaXNoZWRXb3JrPWEuY3VycmVudC5hbHRlcm5hdGU7YS5maW5pc2hlZExhbmVzPWI7VWooYSk7TWooYSxPKCkpO3JldHVybiBudWxsfVxuZnVuY3Rpb24gVmooKXtpZihudWxsIT09Q2ope3ZhciBhPUNqO0NqPW51bGw7YS5mb3JFYWNoKGZ1bmN0aW9uKGEpe2EuZXhwaXJlZExhbmVzfD0yNCZhLnBlbmRpbmdMYW5lcztNaihhLE8oKSl9KX1pZygpfWZ1bmN0aW9uIFdqKGEsYil7dmFyIGM9WDtYfD0xO3RyeXtyZXR1cm4gYShiKX1maW5hbGx5e1g9YywwPT09WCYmKHdqKCksaWcoKSl9fWZ1bmN0aW9uIFhqKGEsYil7dmFyIGM9WDtYJj0tMjtYfD04O3RyeXtyZXR1cm4gYShiKX1maW5hbGx5e1g9YywwPT09WCYmKHdqKCksaWcoKSl9fWZ1bmN0aW9uIG5pKGEsYil7SShyaixxaik7cWp8PWI7dGp8PWJ9ZnVuY3Rpb24gS2koKXtxaj1yai5jdXJyZW50O0gocmopfVxuZnVuY3Rpb24gUWooYSxiKXthLmZpbmlzaGVkV29yaz1udWxsO2EuZmluaXNoZWRMYW5lcz0wO3ZhciBjPWEudGltZW91dEhhbmRsZTstMSE9PWMmJihhLnRpbWVvdXRIYW5kbGU9LTEscGYoYykpO2lmKG51bGwhPT1ZKWZvcihjPVkucmV0dXJuO251bGwhPT1jOyl7dmFyIGQ9Yztzd2l0Y2goZC50YWcpe2Nhc2UgMTpkPWQudHlwZS5jaGlsZENvbnRleHRUeXBlcztudWxsIT09ZCYmdm9pZCAwIT09ZCYmR2YoKTticmVhaztjYXNlIDM6ZmgoKTtIKE4pO0goTSk7dWgoKTticmVhaztjYXNlIDU6aGgoZCk7YnJlYWs7Y2FzZSA0OmZoKCk7YnJlYWs7Y2FzZSAxMzpIKFApO2JyZWFrO2Nhc2UgMTk6SChQKTticmVhaztjYXNlIDEwOnJnKGQpO2JyZWFrO2Nhc2UgMjM6Y2FzZSAyNDpLaSgpfWM9Yy5yZXR1cm59VT1hO1k9VGcoYS5jdXJyZW50LG51bGwpO1c9cWo9dGo9YjtWPTA7c2o9bnVsbDt1aj1IaT1EZz0wfVxuZnVuY3Rpb24gU2ooYSxiKXtkb3t2YXIgYz1ZO3RyeXtxZygpO3ZoLmN1cnJlbnQ9R2g7aWYoeWgpe2Zvcih2YXIgZD1SLm1lbW9pemVkU3RhdGU7bnVsbCE9PWQ7KXt2YXIgZT1kLnF1ZXVlO251bGwhPT1lJiYoZS5wZW5kaW5nPW51bGwpO2Q9ZC5uZXh0fXloPSExfXhoPTA7VD1TPVI9bnVsbDt6aD0hMTtwai5jdXJyZW50PW51bGw7aWYobnVsbD09PWN8fG51bGw9PT1jLnJldHVybil7Vj0xO3NqPWI7WT1udWxsO2JyZWFrfWE6e3ZhciBmPWEsZz1jLnJldHVybixoPWMsaz1iO2I9VztoLmZsYWdzfD0yMDQ4O2guZmlyc3RFZmZlY3Q9aC5sYXN0RWZmZWN0PW51bGw7aWYobnVsbCE9PWsmJlwib2JqZWN0XCI9PT10eXBlb2YgayYmXCJmdW5jdGlvblwiPT09dHlwZW9mIGsudGhlbil7dmFyIGw9aztpZigwPT09KGgubW9kZSYyKSl7dmFyIG49aC5hbHRlcm5hdGU7bj8oaC51cGRhdGVRdWV1ZT1uLnVwZGF0ZVF1ZXVlLGgubWVtb2l6ZWRTdGF0ZT1uLm1lbW9pemVkU3RhdGUsaC5sYW5lcz1uLmxhbmVzKTpcbihoLnVwZGF0ZVF1ZXVlPW51bGwsaC5tZW1vaXplZFN0YXRlPW51bGwpfXZhciBBPTAhPT0oUC5jdXJyZW50JjEpLHA9Zztkb3t2YXIgQztpZihDPTEzPT09cC50YWcpe3ZhciB4PXAubWVtb2l6ZWRTdGF0ZTtpZihudWxsIT09eClDPW51bGwhPT14LmRlaHlkcmF0ZWQ/ITA6ITE7ZWxzZXt2YXIgdz1wLm1lbW9pemVkUHJvcHM7Qz12b2lkIDA9PT13LmZhbGxiYWNrPyExOiEwIT09dy51bnN0YWJsZV9hdm9pZFRoaXNGYWxsYmFjaz8hMDpBPyExOiEwfX1pZihDKXt2YXIgej1wLnVwZGF0ZVF1ZXVlO2lmKG51bGw9PT16KXt2YXIgdT1uZXcgU2V0O3UuYWRkKGwpO3AudXBkYXRlUXVldWU9dX1lbHNlIHouYWRkKGwpO2lmKDA9PT0ocC5tb2RlJjIpKXtwLmZsYWdzfD02NDtoLmZsYWdzfD0xNjM4NDtoLmZsYWdzJj0tMjk4MTtpZigxPT09aC50YWcpaWYobnVsbD09PWguYWx0ZXJuYXRlKWgudGFnPTE3O2Vsc2V7dmFyIHQ9emcoLTEsMSk7dC50YWc9MjtBZyhoLHQpfWgubGFuZXN8PTE7YnJlYWsgYX1rPVxudm9pZCAwO2g9Yjt2YXIgcT1mLnBpbmdDYWNoZTtudWxsPT09cT8ocT1mLnBpbmdDYWNoZT1uZXcgT2ksaz1uZXcgU2V0LHEuc2V0KGwsaykpOihrPXEuZ2V0KGwpLHZvaWQgMD09PWsmJihrPW5ldyBTZXQscS5zZXQobCxrKSkpO2lmKCFrLmhhcyhoKSl7ay5hZGQoaCk7dmFyIHY9WWouYmluZChudWxsLGYsbCxoKTtsLnRoZW4odix2KX1wLmZsYWdzfD00MDk2O3AubGFuZXM9YjticmVhayBhfXA9cC5yZXR1cm59d2hpbGUobnVsbCE9PXApO2s9RXJyb3IoKFJhKGgudHlwZSl8fFwiQSBSZWFjdCBjb21wb25lbnRcIikrXCIgc3VzcGVuZGVkIHdoaWxlIHJlbmRlcmluZywgYnV0IG5vIGZhbGxiYWNrIFVJIHdhcyBzcGVjaWZpZWQuXFxuXFxuQWRkIGEgPFN1c3BlbnNlIGZhbGxiYWNrPS4uLj4gY29tcG9uZW50IGhpZ2hlciBpbiB0aGUgdHJlZSB0byBwcm92aWRlIGEgbG9hZGluZyBpbmRpY2F0b3Igb3IgcGxhY2Vob2xkZXIgdG8gZGlzcGxheS5cIil9NSE9PVYmJihWPTIpO2s9TWkoayxoKTtwPVxuZztkb3tzd2l0Y2gocC50YWcpe2Nhc2UgMzpmPWs7cC5mbGFnc3w9NDA5NjtiJj0tYjtwLmxhbmVzfD1iO3ZhciBKPVBpKHAsZixiKTtCZyhwLEopO2JyZWFrIGE7Y2FzZSAxOmY9azt2YXIgSz1wLnR5cGUsUT1wLnN0YXRlTm9kZTtpZigwPT09KHAuZmxhZ3MmNjQpJiYoXCJmdW5jdGlvblwiPT09dHlwZW9mIEsuZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yfHxudWxsIT09USYmXCJmdW5jdGlvblwiPT09dHlwZW9mIFEuY29tcG9uZW50RGlkQ2F0Y2gmJihudWxsPT09VGl8fCFUaS5oYXMoUSkpKSl7cC5mbGFnc3w9NDA5NjtiJj0tYjtwLmxhbmVzfD1iO3ZhciBMPVNpKHAsZixiKTtCZyhwLEwpO2JyZWFrIGF9fXA9cC5yZXR1cm59d2hpbGUobnVsbCE9PXApfVpqKGMpfWNhdGNoKHZhKXtiPXZhO1k9PT1jJiZudWxsIT09YyYmKFk9Yz1jLnJldHVybik7Y29udGludWV9YnJlYWt9d2hpbGUoMSl9XG5mdW5jdGlvbiBQaigpe3ZhciBhPW9qLmN1cnJlbnQ7b2ouY3VycmVudD1HaDtyZXR1cm4gbnVsbD09PWE/R2g6YX1mdW5jdGlvbiBUaihhLGIpe3ZhciBjPVg7WHw9MTY7dmFyIGQ9UGooKTtVPT09YSYmVz09PWJ8fFFqKGEsYik7ZG8gdHJ5e2FrKCk7YnJlYWt9Y2F0Y2goZSl7U2ooYSxlKX13aGlsZSgxKTtxZygpO1g9Yztvai5jdXJyZW50PWQ7aWYobnVsbCE9PVkpdGhyb3cgRXJyb3IoeSgyNjEpKTtVPW51bGw7Vz0wO3JldHVybiBWfWZ1bmN0aW9uIGFrKCl7Zm9yKDtudWxsIT09WTspYmsoWSl9ZnVuY3Rpb24gUmooKXtmb3IoO251bGwhPT1ZJiYhUWYoKTspYmsoWSl9ZnVuY3Rpb24gYmsoYSl7dmFyIGI9Y2soYS5hbHRlcm5hdGUsYSxxaik7YS5tZW1vaXplZFByb3BzPWEucGVuZGluZ1Byb3BzO251bGw9PT1iP1pqKGEpOlk9Yjtwai5jdXJyZW50PW51bGx9XG5mdW5jdGlvbiBaaihhKXt2YXIgYj1hO2Rve3ZhciBjPWIuYWx0ZXJuYXRlO2E9Yi5yZXR1cm47aWYoMD09PShiLmZsYWdzJjIwNDgpKXtjPUdpKGMsYixxaik7aWYobnVsbCE9PWMpe1k9YztyZXR1cm59Yz1iO2lmKDI0IT09Yy50YWcmJjIzIT09Yy50YWd8fG51bGw9PT1jLm1lbW9pemVkU3RhdGV8fDAhPT0ocWomMTA3Mzc0MTgyNCl8fDA9PT0oYy5tb2RlJjQpKXtmb3IodmFyIGQ9MCxlPWMuY2hpbGQ7bnVsbCE9PWU7KWR8PWUubGFuZXN8ZS5jaGlsZExhbmVzLGU9ZS5zaWJsaW5nO2MuY2hpbGRMYW5lcz1kfW51bGwhPT1hJiYwPT09KGEuZmxhZ3MmMjA0OCkmJihudWxsPT09YS5maXJzdEVmZmVjdCYmKGEuZmlyc3RFZmZlY3Q9Yi5maXJzdEVmZmVjdCksbnVsbCE9PWIubGFzdEVmZmVjdCYmKG51bGwhPT1hLmxhc3RFZmZlY3QmJihhLmxhc3RFZmZlY3QubmV4dEVmZmVjdD1iLmZpcnN0RWZmZWN0KSxhLmxhc3RFZmZlY3Q9Yi5sYXN0RWZmZWN0KSwxPGIuZmxhZ3MmJihudWxsIT09XG5hLmxhc3RFZmZlY3Q/YS5sYXN0RWZmZWN0Lm5leHRFZmZlY3Q9YjphLmZpcnN0RWZmZWN0PWIsYS5sYXN0RWZmZWN0PWIpKX1lbHNle2M9TGkoYik7aWYobnVsbCE9PWMpe2MuZmxhZ3MmPTIwNDc7WT1jO3JldHVybn1udWxsIT09YSYmKGEuZmlyc3RFZmZlY3Q9YS5sYXN0RWZmZWN0PW51bGwsYS5mbGFnc3w9MjA0OCl9Yj1iLnNpYmxpbmc7aWYobnVsbCE9PWIpe1k9YjtyZXR1cm59WT1iPWF9d2hpbGUobnVsbCE9PWIpOzA9PT1WJiYoVj01KX1mdW5jdGlvbiBVaihhKXt2YXIgYj1lZygpO2dnKDk5LGRrLmJpbmQobnVsbCxhLGIpKTtyZXR1cm4gbnVsbH1cbmZ1bmN0aW9uIGRrKGEsYil7ZG8gT2ooKTt3aGlsZShudWxsIT09eWopO2lmKDAhPT0oWCY0OCkpdGhyb3cgRXJyb3IoeSgzMjcpKTt2YXIgYz1hLmZpbmlzaGVkV29yaztpZihudWxsPT09YylyZXR1cm4gbnVsbDthLmZpbmlzaGVkV29yaz1udWxsO2EuZmluaXNoZWRMYW5lcz0wO2lmKGM9PT1hLmN1cnJlbnQpdGhyb3cgRXJyb3IoeSgxNzcpKTthLmNhbGxiYWNrTm9kZT1udWxsO3ZhciBkPWMubGFuZXN8Yy5jaGlsZExhbmVzLGU9ZCxmPWEucGVuZGluZ0xhbmVzJn5lO2EucGVuZGluZ0xhbmVzPWU7YS5zdXNwZW5kZWRMYW5lcz0wO2EucGluZ2VkTGFuZXM9MDthLmV4cGlyZWRMYW5lcyY9ZTthLm11dGFibGVSZWFkTGFuZXMmPWU7YS5lbnRhbmdsZWRMYW5lcyY9ZTtlPWEuZW50YW5nbGVtZW50cztmb3IodmFyIGc9YS5ldmVudFRpbWVzLGg9YS5leHBpcmF0aW9uVGltZXM7MDxmOyl7dmFyIGs9MzEtVmMoZiksbD0xPDxrO2Vba109MDtnW2tdPS0xO2hba109LTE7ZiY9fmx9bnVsbCE9PVxuQ2omJjA9PT0oZCYyNCkmJkNqLmhhcyhhKSYmQ2ouZGVsZXRlKGEpO2E9PT1VJiYoWT1VPW51bGwsVz0wKTsxPGMuZmxhZ3M/bnVsbCE9PWMubGFzdEVmZmVjdD8oYy5sYXN0RWZmZWN0Lm5leHRFZmZlY3Q9YyxkPWMuZmlyc3RFZmZlY3QpOmQ9YzpkPWMuZmlyc3RFZmZlY3Q7aWYobnVsbCE9PWQpe2U9WDtYfD0zMjtwai5jdXJyZW50PW51bGw7a2Y9ZmQ7Zz1OZSgpO2lmKE9lKGcpKXtpZihcInNlbGVjdGlvblN0YXJ0XCJpbiBnKWg9e3N0YXJ0Omcuc2VsZWN0aW9uU3RhcnQsZW5kOmcuc2VsZWN0aW9uRW5kfTtlbHNlIGE6aWYoaD0oaD1nLm93bmVyRG9jdW1lbnQpJiZoLmRlZmF1bHRWaWV3fHx3aW5kb3csKGw9aC5nZXRTZWxlY3Rpb24mJmguZ2V0U2VsZWN0aW9uKCkpJiYwIT09bC5yYW5nZUNvdW50KXtoPWwuYW5jaG9yTm9kZTtmPWwuYW5jaG9yT2Zmc2V0O2s9bC5mb2N1c05vZGU7bD1sLmZvY3VzT2Zmc2V0O3RyeXtoLm5vZGVUeXBlLGsubm9kZVR5cGV9Y2F0Y2godmEpe2g9bnVsbDtcbmJyZWFrIGF9dmFyIG49MCxBPS0xLHA9LTEsQz0wLHg9MCx3PWcsej1udWxsO2I6Zm9yKDs7KXtmb3IodmFyIHU7Oyl7dyE9PWh8fDAhPT1mJiYzIT09dy5ub2RlVHlwZXx8KEE9bitmKTt3IT09a3x8MCE9PWwmJjMhPT13Lm5vZGVUeXBlfHwocD1uK2wpOzM9PT13Lm5vZGVUeXBlJiYobis9dy5ub2RlVmFsdWUubGVuZ3RoKTtpZihudWxsPT09KHU9dy5maXJzdENoaWxkKSlicmVhazt6PXc7dz11fWZvcig7Oyl7aWYodz09PWcpYnJlYWsgYjt6PT09aCYmKytDPT09ZiYmKEE9bik7ej09PWsmJisreD09PWwmJihwPW4pO2lmKG51bGwhPT0odT13Lm5leHRTaWJsaW5nKSlicmVhazt3PXo7ej13LnBhcmVudE5vZGV9dz11fWg9LTE9PT1BfHwtMT09PXA/bnVsbDp7c3RhcnQ6QSxlbmQ6cH19ZWxzZSBoPW51bGw7aD1ofHx7c3RhcnQ6MCxlbmQ6MH19ZWxzZSBoPW51bGw7bGY9e2ZvY3VzZWRFbGVtOmcsc2VsZWN0aW9uUmFuZ2U6aH07ZmQ9ITE7SWo9bnVsbDtKaj0hMTtaPWQ7ZG8gdHJ5e2VrKCl9Y2F0Y2godmEpe2lmKG51bGw9PT1cblopdGhyb3cgRXJyb3IoeSgzMzApKTtXaShaLHZhKTtaPVoubmV4dEVmZmVjdH13aGlsZShudWxsIT09Wik7SWo9bnVsbDtaPWQ7ZG8gdHJ5e2ZvcihnPWE7bnVsbCE9PVo7KXt2YXIgdD1aLmZsYWdzO3QmMTYmJnBiKFouc3RhdGVOb2RlLFwiXCIpO2lmKHQmMTI4KXt2YXIgcT1aLmFsdGVybmF0ZTtpZihudWxsIT09cSl7dmFyIHY9cS5yZWY7bnVsbCE9PXYmJihcImZ1bmN0aW9uXCI9PT10eXBlb2Ygdj92KG51bGwpOnYuY3VycmVudD1udWxsKX19c3dpdGNoKHQmMTAzOCl7Y2FzZSAyOmZqKFopO1ouZmxhZ3MmPS0zO2JyZWFrO2Nhc2UgNjpmaihaKTtaLmZsYWdzJj0tMztpaihaLmFsdGVybmF0ZSxaKTticmVhaztjYXNlIDEwMjQ6Wi5mbGFncyY9LTEwMjU7YnJlYWs7Y2FzZSAxMDI4OlouZmxhZ3MmPS0xMDI1O2lqKFouYWx0ZXJuYXRlLFopO2JyZWFrO2Nhc2UgNDppaihaLmFsdGVybmF0ZSxaKTticmVhaztjYXNlIDg6aD1aO2NqKGcsaCk7dmFyIEo9aC5hbHRlcm5hdGU7ZGooaCk7bnVsbCE9PVxuSiYmZGooSil9Wj1aLm5leHRFZmZlY3R9fWNhdGNoKHZhKXtpZihudWxsPT09Wil0aHJvdyBFcnJvcih5KDMzMCkpO1dpKFosdmEpO1o9Wi5uZXh0RWZmZWN0fXdoaWxlKG51bGwhPT1aKTt2PWxmO3E9TmUoKTt0PXYuZm9jdXNlZEVsZW07Zz12LnNlbGVjdGlvblJhbmdlO2lmKHEhPT10JiZ0JiZ0Lm93bmVyRG9jdW1lbnQmJk1lKHQub3duZXJEb2N1bWVudC5kb2N1bWVudEVsZW1lbnQsdCkpe251bGwhPT1nJiZPZSh0KSYmKHE9Zy5zdGFydCx2PWcuZW5kLHZvaWQgMD09PXYmJih2PXEpLFwic2VsZWN0aW9uU3RhcnRcImluIHQ/KHQuc2VsZWN0aW9uU3RhcnQ9cSx0LnNlbGVjdGlvbkVuZD1NYXRoLm1pbih2LHQudmFsdWUubGVuZ3RoKSk6KHY9KHE9dC5vd25lckRvY3VtZW50fHxkb2N1bWVudCkmJnEuZGVmYXVsdFZpZXd8fHdpbmRvdyx2LmdldFNlbGVjdGlvbiYmKHY9di5nZXRTZWxlY3Rpb24oKSxoPXQudGV4dENvbnRlbnQubGVuZ3RoLEo9TWF0aC5taW4oZy5zdGFydCxoKSxnPXZvaWQgMD09PVxuZy5lbmQ/SjpNYXRoLm1pbihnLmVuZCxoKSwhdi5leHRlbmQmJko+ZyYmKGg9ZyxnPUosSj1oKSxoPUxlKHQsSiksZj1MZSh0LGcpLGgmJmYmJigxIT09di5yYW5nZUNvdW50fHx2LmFuY2hvck5vZGUhPT1oLm5vZGV8fHYuYW5jaG9yT2Zmc2V0IT09aC5vZmZzZXR8fHYuZm9jdXNOb2RlIT09Zi5ub2RlfHx2LmZvY3VzT2Zmc2V0IT09Zi5vZmZzZXQpJiYocT1xLmNyZWF0ZVJhbmdlKCkscS5zZXRTdGFydChoLm5vZGUsaC5vZmZzZXQpLHYucmVtb3ZlQWxsUmFuZ2VzKCksSj5nPyh2LmFkZFJhbmdlKHEpLHYuZXh0ZW5kKGYubm9kZSxmLm9mZnNldCkpOihxLnNldEVuZChmLm5vZGUsZi5vZmZzZXQpLHYuYWRkUmFuZ2UocSkpKSkpKTtxPVtdO2Zvcih2PXQ7dj12LnBhcmVudE5vZGU7KTE9PT12Lm5vZGVUeXBlJiZxLnB1c2goe2VsZW1lbnQ6dixsZWZ0OnYuc2Nyb2xsTGVmdCx0b3A6di5zY3JvbGxUb3B9KTtcImZ1bmN0aW9uXCI9PT10eXBlb2YgdC5mb2N1cyYmdC5mb2N1cygpO2Zvcih0PVxuMDt0PHEubGVuZ3RoO3QrKyl2PXFbdF0sdi5lbGVtZW50LnNjcm9sbExlZnQ9di5sZWZ0LHYuZWxlbWVudC5zY3JvbGxUb3A9di50b3B9ZmQ9ISFrZjtsZj1rZj1udWxsO2EuY3VycmVudD1jO1o9ZDtkbyB0cnl7Zm9yKHQ9YTtudWxsIT09Wjspe3ZhciBLPVouZmxhZ3M7SyYzNiYmWWkodCxaLmFsdGVybmF0ZSxaKTtpZihLJjEyOCl7cT12b2lkIDA7dmFyIFE9Wi5yZWY7aWYobnVsbCE9PVEpe3ZhciBMPVouc3RhdGVOb2RlO3N3aXRjaChaLnRhZyl7Y2FzZSA1OnE9TDticmVhaztkZWZhdWx0OnE9TH1cImZ1bmN0aW9uXCI9PT10eXBlb2YgUT9RKHEpOlEuY3VycmVudD1xfX1aPVoubmV4dEVmZmVjdH19Y2F0Y2godmEpe2lmKG51bGw9PT1aKXRocm93IEVycm9yKHkoMzMwKSk7V2koWix2YSk7Wj1aLm5leHRFZmZlY3R9d2hpbGUobnVsbCE9PVopO1o9bnVsbDskZigpO1g9ZX1lbHNlIGEuY3VycmVudD1jO2lmKHhqKXhqPSExLHlqPWEsemo9YjtlbHNlIGZvcihaPWQ7bnVsbCE9PVo7KWI9XG5aLm5leHRFZmZlY3QsWi5uZXh0RWZmZWN0PW51bGwsWi5mbGFncyY4JiYoSz1aLEsuc2libGluZz1udWxsLEsuc3RhdGVOb2RlPW51bGwpLFo9YjtkPWEucGVuZGluZ0xhbmVzOzA9PT1kJiYoVGk9bnVsbCk7MT09PWQ/YT09PUVqP0RqKys6KERqPTAsRWo9YSk6RGo9MDtjPWMuc3RhdGVOb2RlO2lmKE1mJiZcImZ1bmN0aW9uXCI9PT10eXBlb2YgTWYub25Db21taXRGaWJlclJvb3QpdHJ5e01mLm9uQ29tbWl0RmliZXJSb290KExmLGMsdm9pZCAwLDY0PT09KGMuY3VycmVudC5mbGFncyY2NCkpfWNhdGNoKHZhKXt9TWooYSxPKCkpO2lmKFFpKXRocm93IFFpPSExLGE9UmksUmk9bnVsbCxhO2lmKDAhPT0oWCY4KSlyZXR1cm4gbnVsbDtpZygpO3JldHVybiBudWxsfVxuZnVuY3Rpb24gZWsoKXtmb3IoO251bGwhPT1aOyl7dmFyIGE9Wi5hbHRlcm5hdGU7Smp8fG51bGw9PT1Janx8KDAhPT0oWi5mbGFncyY4KT9kYyhaLElqKSYmKEpqPSEwKToxMz09PVoudGFnJiZtaihhLFopJiZkYyhaLElqKSYmKEpqPSEwKSk7dmFyIGI9Wi5mbGFnczswIT09KGImMjU2KSYmWGkoYSxaKTswPT09KGImNTEyKXx8eGp8fCh4aj0hMCxoZyg5NyxmdW5jdGlvbigpe09qKCk7cmV0dXJuIG51bGx9KSk7Wj1aLm5leHRFZmZlY3R9fWZ1bmN0aW9uIE9qKCl7aWYoOTAhPT16ail7dmFyIGE9OTc8emo/OTc6emo7emo9OTA7cmV0dXJuIGdnKGEsZmspfXJldHVybiExfWZ1bmN0aW9uICRpKGEsYil7QWoucHVzaChiLGEpO3hqfHwoeGo9ITAsaGcoOTcsZnVuY3Rpb24oKXtPaigpO3JldHVybiBudWxsfSkpfWZ1bmN0aW9uIFppKGEsYil7QmoucHVzaChiLGEpO3hqfHwoeGo9ITAsaGcoOTcsZnVuY3Rpb24oKXtPaigpO3JldHVybiBudWxsfSkpfVxuZnVuY3Rpb24gZmsoKXtpZihudWxsPT09eWopcmV0dXJuITE7dmFyIGE9eWo7eWo9bnVsbDtpZigwIT09KFgmNDgpKXRocm93IEVycm9yKHkoMzMxKSk7dmFyIGI9WDtYfD0zMjt2YXIgYz1CajtCaj1bXTtmb3IodmFyIGQ9MDtkPGMubGVuZ3RoO2QrPTIpe3ZhciBlPWNbZF0sZj1jW2QrMV0sZz1lLmRlc3Ryb3k7ZS5kZXN0cm95PXZvaWQgMDtpZihcImZ1bmN0aW9uXCI9PT10eXBlb2YgZyl0cnl7ZygpfWNhdGNoKGspe2lmKG51bGw9PT1mKXRocm93IEVycm9yKHkoMzMwKSk7V2koZixrKX19Yz1BajtBaj1bXTtmb3IoZD0wO2Q8Yy5sZW5ndGg7ZCs9Mil7ZT1jW2RdO2Y9Y1tkKzFdO3RyeXt2YXIgaD1lLmNyZWF0ZTtlLmRlc3Ryb3k9aCgpfWNhdGNoKGspe2lmKG51bGw9PT1mKXRocm93IEVycm9yKHkoMzMwKSk7V2koZixrKX19Zm9yKGg9YS5jdXJyZW50LmZpcnN0RWZmZWN0O251bGwhPT1oOylhPWgubmV4dEVmZmVjdCxoLm5leHRFZmZlY3Q9bnVsbCxoLmZsYWdzJjgmJihoLnNpYmxpbmc9XG5udWxsLGguc3RhdGVOb2RlPW51bGwpLGg9YTtYPWI7aWcoKTtyZXR1cm4hMH1mdW5jdGlvbiBnayhhLGIsYyl7Yj1NaShjLGIpO2I9UGkoYSxiLDEpO0FnKGEsYik7Yj1IZygpO2E9S2ooYSwxKTtudWxsIT09YSYmKCRjKGEsMSxiKSxNaihhLGIpKX1cbmZ1bmN0aW9uIFdpKGEsYil7aWYoMz09PWEudGFnKWdrKGEsYSxiKTtlbHNlIGZvcih2YXIgYz1hLnJldHVybjtudWxsIT09Yzspe2lmKDM9PT1jLnRhZyl7Z2soYyxhLGIpO2JyZWFrfWVsc2UgaWYoMT09PWMudGFnKXt2YXIgZD1jLnN0YXRlTm9kZTtpZihcImZ1bmN0aW9uXCI9PT10eXBlb2YgYy50eXBlLmdldERlcml2ZWRTdGF0ZUZyb21FcnJvcnx8XCJmdW5jdGlvblwiPT09dHlwZW9mIGQuY29tcG9uZW50RGlkQ2F0Y2gmJihudWxsPT09VGl8fCFUaS5oYXMoZCkpKXthPU1pKGIsYSk7dmFyIGU9U2koYyxhLDEpO0FnKGMsZSk7ZT1IZygpO2M9S2ooYywxKTtpZihudWxsIT09YykkYyhjLDEsZSksTWooYyxlKTtlbHNlIGlmKFwiZnVuY3Rpb25cIj09PXR5cGVvZiBkLmNvbXBvbmVudERpZENhdGNoJiYobnVsbD09PVRpfHwhVGkuaGFzKGQpKSl0cnl7ZC5jb21wb25lbnREaWRDYXRjaChiLGEpfWNhdGNoKGYpe31icmVha319Yz1jLnJldHVybn19XG5mdW5jdGlvbiBZaihhLGIsYyl7dmFyIGQ9YS5waW5nQ2FjaGU7bnVsbCE9PWQmJmQuZGVsZXRlKGIpO2I9SGcoKTthLnBpbmdlZExhbmVzfD1hLnN1c3BlbmRlZExhbmVzJmM7VT09PWEmJihXJmMpPT09YyYmKDQ9PT1WfHwzPT09ViYmKFcmNjI5MTQ1NjApPT09VyYmNTAwPk8oKS1qaj9RaihhLDApOnVqfD1jKTtNaihhLGIpfWZ1bmN0aW9uIGxqKGEsYil7dmFyIGM9YS5zdGF0ZU5vZGU7bnVsbCE9PWMmJmMuZGVsZXRlKGIpO2I9MDswPT09YiYmKGI9YS5tb2RlLDA9PT0oYiYyKT9iPTE6MD09PShiJjQpP2I9OTk9PT1lZygpPzE6MjooMD09PUdqJiYoR2o9dGopLGI9WWMoNjI5MTQ1NjAmfkdqKSwwPT09YiYmKGI9NDE5NDMwNCkpKTtjPUhnKCk7YT1LaihhLGIpO251bGwhPT1hJiYoJGMoYSxiLGMpLE1qKGEsYykpfXZhciBjaztcbmNrPWZ1bmN0aW9uKGEsYixjKXt2YXIgZD1iLmxhbmVzO2lmKG51bGwhPT1hKWlmKGEubWVtb2l6ZWRQcm9wcyE9PWIucGVuZGluZ1Byb3BzfHxOLmN1cnJlbnQpdWc9ITA7ZWxzZSBpZigwIT09KGMmZCkpdWc9MCE9PShhLmZsYWdzJjE2Mzg0KT8hMDohMTtlbHNle3VnPSExO3N3aXRjaChiLnRhZyl7Y2FzZSAzOnJpKGIpO3NoKCk7YnJlYWs7Y2FzZSA1OmdoKGIpO2JyZWFrO2Nhc2UgMTpGZihiLnR5cGUpJiZKZihiKTticmVhaztjYXNlIDQ6ZWgoYixiLnN0YXRlTm9kZS5jb250YWluZXJJbmZvKTticmVhaztjYXNlIDEwOmQ9Yi5tZW1vaXplZFByb3BzLnZhbHVlO3ZhciBlPWIudHlwZS5fY29udGV4dDtJKG1nLGUuX2N1cnJlbnRWYWx1ZSk7ZS5fY3VycmVudFZhbHVlPWQ7YnJlYWs7Y2FzZSAxMzppZihudWxsIT09Yi5tZW1vaXplZFN0YXRlKXtpZigwIT09KGMmYi5jaGlsZC5jaGlsZExhbmVzKSlyZXR1cm4gdGkoYSxiLGMpO0koUCxQLmN1cnJlbnQmMSk7Yj1oaShhLGIsYyk7cmV0dXJuIG51bGwhPT1cbmI/Yi5zaWJsaW5nOm51bGx9SShQLFAuY3VycmVudCYxKTticmVhaztjYXNlIDE5OmQ9MCE9PShjJmIuY2hpbGRMYW5lcyk7aWYoMCE9PShhLmZsYWdzJjY0KSl7aWYoZClyZXR1cm4gQWkoYSxiLGMpO2IuZmxhZ3N8PTY0fWU9Yi5tZW1vaXplZFN0YXRlO251bGwhPT1lJiYoZS5yZW5kZXJpbmc9bnVsbCxlLnRhaWw9bnVsbCxlLmxhc3RFZmZlY3Q9bnVsbCk7SShQLFAuY3VycmVudCk7aWYoZClicmVhaztlbHNlIHJldHVybiBudWxsO2Nhc2UgMjM6Y2FzZSAyNDpyZXR1cm4gYi5sYW5lcz0wLG1pKGEsYixjKX1yZXR1cm4gaGkoYSxiLGMpfWVsc2UgdWc9ITE7Yi5sYW5lcz0wO3N3aXRjaChiLnRhZyl7Y2FzZSAyOmQ9Yi50eXBlO251bGwhPT1hJiYoYS5hbHRlcm5hdGU9bnVsbCxiLmFsdGVybmF0ZT1udWxsLGIuZmxhZ3N8PTIpO2E9Yi5wZW5kaW5nUHJvcHM7ZT1FZihiLE0uY3VycmVudCk7dGcoYixjKTtlPUNoKG51bGwsYixkLGEsZSxjKTtiLmZsYWdzfD0xO2lmKFwib2JqZWN0XCI9PT1cbnR5cGVvZiBlJiZudWxsIT09ZSYmXCJmdW5jdGlvblwiPT09dHlwZW9mIGUucmVuZGVyJiZ2b2lkIDA9PT1lLiQkdHlwZW9mKXtiLnRhZz0xO2IubWVtb2l6ZWRTdGF0ZT1udWxsO2IudXBkYXRlUXVldWU9bnVsbDtpZihGZihkKSl7dmFyIGY9ITA7SmYoYil9ZWxzZSBmPSExO2IubWVtb2l6ZWRTdGF0ZT1udWxsIT09ZS5zdGF0ZSYmdm9pZCAwIT09ZS5zdGF0ZT9lLnN0YXRlOm51bGw7eGcoYik7dmFyIGc9ZC5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHM7XCJmdW5jdGlvblwiPT09dHlwZW9mIGcmJkdnKGIsZCxnLGEpO2UudXBkYXRlcj1LZztiLnN0YXRlTm9kZT1lO2UuX3JlYWN0SW50ZXJuYWxzPWI7T2coYixkLGEsYyk7Yj1xaShudWxsLGIsZCwhMCxmLGMpfWVsc2UgYi50YWc9MCxmaShudWxsLGIsZSxjKSxiPWIuY2hpbGQ7cmV0dXJuIGI7Y2FzZSAxNjplPWIuZWxlbWVudFR5cGU7YTp7bnVsbCE9PWEmJihhLmFsdGVybmF0ZT1udWxsLGIuYWx0ZXJuYXRlPW51bGwsYi5mbGFnc3w9Mik7XG5hPWIucGVuZGluZ1Byb3BzO2Y9ZS5faW5pdDtlPWYoZS5fcGF5bG9hZCk7Yi50eXBlPWU7Zj1iLnRhZz1oayhlKTthPWxnKGUsYSk7c3dpdGNoKGYpe2Nhc2UgMDpiPWxpKG51bGwsYixlLGEsYyk7YnJlYWsgYTtjYXNlIDE6Yj1waShudWxsLGIsZSxhLGMpO2JyZWFrIGE7Y2FzZSAxMTpiPWdpKG51bGwsYixlLGEsYyk7YnJlYWsgYTtjYXNlIDE0OmI9aWkobnVsbCxiLGUsbGcoZS50eXBlLGEpLGQsYyk7YnJlYWsgYX10aHJvdyBFcnJvcih5KDMwNixlLFwiXCIpKTt9cmV0dXJuIGI7Y2FzZSAwOnJldHVybiBkPWIudHlwZSxlPWIucGVuZGluZ1Byb3BzLGU9Yi5lbGVtZW50VHlwZT09PWQ/ZTpsZyhkLGUpLGxpKGEsYixkLGUsYyk7Y2FzZSAxOnJldHVybiBkPWIudHlwZSxlPWIucGVuZGluZ1Byb3BzLGU9Yi5lbGVtZW50VHlwZT09PWQ/ZTpsZyhkLGUpLHBpKGEsYixkLGUsYyk7Y2FzZSAzOnJpKGIpO2Q9Yi51cGRhdGVRdWV1ZTtpZihudWxsPT09YXx8bnVsbD09PWQpdGhyb3cgRXJyb3IoeSgyODIpKTtcbmQ9Yi5wZW5kaW5nUHJvcHM7ZT1iLm1lbW9pemVkU3RhdGU7ZT1udWxsIT09ZT9lLmVsZW1lbnQ6bnVsbDt5ZyhhLGIpO0NnKGIsZCxudWxsLGMpO2Q9Yi5tZW1vaXplZFN0YXRlLmVsZW1lbnQ7aWYoZD09PWUpc2goKSxiPWhpKGEsYixjKTtlbHNle2U9Yi5zdGF0ZU5vZGU7aWYoZj1lLmh5ZHJhdGUpa2g9cmYoYi5zdGF0ZU5vZGUuY29udGFpbmVySW5mby5maXJzdENoaWxkKSxqaD1iLGY9bGg9ITA7aWYoZil7YT1lLm11dGFibGVTb3VyY2VFYWdlckh5ZHJhdGlvbkRhdGE7aWYobnVsbCE9YSlmb3IoZT0wO2U8YS5sZW5ndGg7ZSs9MilmPWFbZV0sZi5fd29ya0luUHJvZ3Jlc3NWZXJzaW9uUHJpbWFyeT1hW2UrMV0sdGgucHVzaChmKTtjPVpnKGIsbnVsbCxkLGMpO2ZvcihiLmNoaWxkPWM7YzspYy5mbGFncz1jLmZsYWdzJi0zfDEwMjQsYz1jLnNpYmxpbmd9ZWxzZSBmaShhLGIsZCxjKSxzaCgpO2I9Yi5jaGlsZH1yZXR1cm4gYjtjYXNlIDU6cmV0dXJuIGdoKGIpLG51bGw9PT1hJiZcbnBoKGIpLGQ9Yi50eXBlLGU9Yi5wZW5kaW5nUHJvcHMsZj1udWxsIT09YT9hLm1lbW9pemVkUHJvcHM6bnVsbCxnPWUuY2hpbGRyZW4sbmYoZCxlKT9nPW51bGw6bnVsbCE9PWYmJm5mKGQsZikmJihiLmZsYWdzfD0xNiksb2koYSxiKSxmaShhLGIsZyxjKSxiLmNoaWxkO2Nhc2UgNjpyZXR1cm4gbnVsbD09PWEmJnBoKGIpLG51bGw7Y2FzZSAxMzpyZXR1cm4gdGkoYSxiLGMpO2Nhc2UgNDpyZXR1cm4gZWgoYixiLnN0YXRlTm9kZS5jb250YWluZXJJbmZvKSxkPWIucGVuZGluZ1Byb3BzLG51bGw9PT1hP2IuY2hpbGQ9WWcoYixudWxsLGQsYyk6ZmkoYSxiLGQsYyksYi5jaGlsZDtjYXNlIDExOnJldHVybiBkPWIudHlwZSxlPWIucGVuZGluZ1Byb3BzLGU9Yi5lbGVtZW50VHlwZT09PWQ/ZTpsZyhkLGUpLGdpKGEsYixkLGUsYyk7Y2FzZSA3OnJldHVybiBmaShhLGIsYi5wZW5kaW5nUHJvcHMsYyksYi5jaGlsZDtjYXNlIDg6cmV0dXJuIGZpKGEsYixiLnBlbmRpbmdQcm9wcy5jaGlsZHJlbixcbmMpLGIuY2hpbGQ7Y2FzZSAxMjpyZXR1cm4gZmkoYSxiLGIucGVuZGluZ1Byb3BzLmNoaWxkcmVuLGMpLGIuY2hpbGQ7Y2FzZSAxMDphOntkPWIudHlwZS5fY29udGV4dDtlPWIucGVuZGluZ1Byb3BzO2c9Yi5tZW1vaXplZFByb3BzO2Y9ZS52YWx1ZTt2YXIgaD1iLnR5cGUuX2NvbnRleHQ7SShtZyxoLl9jdXJyZW50VmFsdWUpO2guX2N1cnJlbnRWYWx1ZT1mO2lmKG51bGwhPT1nKWlmKGg9Zy52YWx1ZSxmPUhlKGgsZik/MDooXCJmdW5jdGlvblwiPT09dHlwZW9mIGQuX2NhbGN1bGF0ZUNoYW5nZWRCaXRzP2QuX2NhbGN1bGF0ZUNoYW5nZWRCaXRzKGgsZik6MTA3Mzc0MTgyMyl8MCwwPT09Zil7aWYoZy5jaGlsZHJlbj09PWUuY2hpbGRyZW4mJiFOLmN1cnJlbnQpe2I9aGkoYSxiLGMpO2JyZWFrIGF9fWVsc2UgZm9yKGg9Yi5jaGlsZCxudWxsIT09aCYmKGgucmV0dXJuPWIpO251bGwhPT1oOyl7dmFyIGs9aC5kZXBlbmRlbmNpZXM7aWYobnVsbCE9PWspe2c9aC5jaGlsZDtmb3IodmFyIGw9XG5rLmZpcnN0Q29udGV4dDtudWxsIT09bDspe2lmKGwuY29udGV4dD09PWQmJjAhPT0obC5vYnNlcnZlZEJpdHMmZikpezE9PT1oLnRhZyYmKGw9emcoLTEsYyYtYyksbC50YWc9MixBZyhoLGwpKTtoLmxhbmVzfD1jO2w9aC5hbHRlcm5hdGU7bnVsbCE9PWwmJihsLmxhbmVzfD1jKTtzZyhoLnJldHVybixjKTtrLmxhbmVzfD1jO2JyZWFrfWw9bC5uZXh0fX1lbHNlIGc9MTA9PT1oLnRhZz9oLnR5cGU9PT1iLnR5cGU/bnVsbDpoLmNoaWxkOmguY2hpbGQ7aWYobnVsbCE9PWcpZy5yZXR1cm49aDtlbHNlIGZvcihnPWg7bnVsbCE9PWc7KXtpZihnPT09Yil7Zz1udWxsO2JyZWFrfWg9Zy5zaWJsaW5nO2lmKG51bGwhPT1oKXtoLnJldHVybj1nLnJldHVybjtnPWg7YnJlYWt9Zz1nLnJldHVybn1oPWd9ZmkoYSxiLGUuY2hpbGRyZW4sYyk7Yj1iLmNoaWxkfXJldHVybiBiO2Nhc2UgOTpyZXR1cm4gZT1iLnR5cGUsZj1iLnBlbmRpbmdQcm9wcyxkPWYuY2hpbGRyZW4sdGcoYixjKSxlPXZnKGUsXG5mLnVuc3RhYmxlX29ic2VydmVkQml0cyksZD1kKGUpLGIuZmxhZ3N8PTEsZmkoYSxiLGQsYyksYi5jaGlsZDtjYXNlIDE0OnJldHVybiBlPWIudHlwZSxmPWxnKGUsYi5wZW5kaW5nUHJvcHMpLGY9bGcoZS50eXBlLGYpLGlpKGEsYixlLGYsZCxjKTtjYXNlIDE1OnJldHVybiBraShhLGIsYi50eXBlLGIucGVuZGluZ1Byb3BzLGQsYyk7Y2FzZSAxNzpyZXR1cm4gZD1iLnR5cGUsZT1iLnBlbmRpbmdQcm9wcyxlPWIuZWxlbWVudFR5cGU9PT1kP2U6bGcoZCxlKSxudWxsIT09YSYmKGEuYWx0ZXJuYXRlPW51bGwsYi5hbHRlcm5hdGU9bnVsbCxiLmZsYWdzfD0yKSxiLnRhZz0xLEZmKGQpPyhhPSEwLEpmKGIpKTphPSExLHRnKGIsYyksTWcoYixkLGUpLE9nKGIsZCxlLGMpLHFpKG51bGwsYixkLCEwLGEsYyk7Y2FzZSAxOTpyZXR1cm4gQWkoYSxiLGMpO2Nhc2UgMjM6cmV0dXJuIG1pKGEsYixjKTtjYXNlIDI0OnJldHVybiBtaShhLGIsYyl9dGhyb3cgRXJyb3IoeSgxNTYsYi50YWcpKTtcbn07ZnVuY3Rpb24gaWsoYSxiLGMsZCl7dGhpcy50YWc9YTt0aGlzLmtleT1jO3RoaXMuc2libGluZz10aGlzLmNoaWxkPXRoaXMucmV0dXJuPXRoaXMuc3RhdGVOb2RlPXRoaXMudHlwZT10aGlzLmVsZW1lbnRUeXBlPW51bGw7dGhpcy5pbmRleD0wO3RoaXMucmVmPW51bGw7dGhpcy5wZW5kaW5nUHJvcHM9Yjt0aGlzLmRlcGVuZGVuY2llcz10aGlzLm1lbW9pemVkU3RhdGU9dGhpcy51cGRhdGVRdWV1ZT10aGlzLm1lbW9pemVkUHJvcHM9bnVsbDt0aGlzLm1vZGU9ZDt0aGlzLmZsYWdzPTA7dGhpcy5sYXN0RWZmZWN0PXRoaXMuZmlyc3RFZmZlY3Q9dGhpcy5uZXh0RWZmZWN0PW51bGw7dGhpcy5jaGlsZExhbmVzPXRoaXMubGFuZXM9MDt0aGlzLmFsdGVybmF0ZT1udWxsfWZ1bmN0aW9uIG5oKGEsYixjLGQpe3JldHVybiBuZXcgaWsoYSxiLGMsZCl9ZnVuY3Rpb24gamkoYSl7YT1hLnByb3RvdHlwZTtyZXR1cm4hKCFhfHwhYS5pc1JlYWN0Q29tcG9uZW50KX1cbmZ1bmN0aW9uIGhrKGEpe2lmKFwiZnVuY3Rpb25cIj09PXR5cGVvZiBhKXJldHVybiBqaShhKT8xOjA7aWYodm9pZCAwIT09YSYmbnVsbCE9PWEpe2E9YS4kJHR5cGVvZjtpZihhPT09QWEpcmV0dXJuIDExO2lmKGE9PT1EYSlyZXR1cm4gMTR9cmV0dXJuIDJ9XG5mdW5jdGlvbiBUZyhhLGIpe3ZhciBjPWEuYWx0ZXJuYXRlO251bGw9PT1jPyhjPW5oKGEudGFnLGIsYS5rZXksYS5tb2RlKSxjLmVsZW1lbnRUeXBlPWEuZWxlbWVudFR5cGUsYy50eXBlPWEudHlwZSxjLnN0YXRlTm9kZT1hLnN0YXRlTm9kZSxjLmFsdGVybmF0ZT1hLGEuYWx0ZXJuYXRlPWMpOihjLnBlbmRpbmdQcm9wcz1iLGMudHlwZT1hLnR5cGUsYy5mbGFncz0wLGMubmV4dEVmZmVjdD1udWxsLGMuZmlyc3RFZmZlY3Q9bnVsbCxjLmxhc3RFZmZlY3Q9bnVsbCk7Yy5jaGlsZExhbmVzPWEuY2hpbGRMYW5lcztjLmxhbmVzPWEubGFuZXM7Yy5jaGlsZD1hLmNoaWxkO2MubWVtb2l6ZWRQcm9wcz1hLm1lbW9pemVkUHJvcHM7Yy5tZW1vaXplZFN0YXRlPWEubWVtb2l6ZWRTdGF0ZTtjLnVwZGF0ZVF1ZXVlPWEudXBkYXRlUXVldWU7Yj1hLmRlcGVuZGVuY2llcztjLmRlcGVuZGVuY2llcz1udWxsPT09Yj9udWxsOntsYW5lczpiLmxhbmVzLGZpcnN0Q29udGV4dDpiLmZpcnN0Q29udGV4dH07XG5jLnNpYmxpbmc9YS5zaWJsaW5nO2MuaW5kZXg9YS5pbmRleDtjLnJlZj1hLnJlZjtyZXR1cm4gY31cbmZ1bmN0aW9uIFZnKGEsYixjLGQsZSxmKXt2YXIgZz0yO2Q9YTtpZihcImZ1bmN0aW9uXCI9PT10eXBlb2YgYSlqaShhKSYmKGc9MSk7ZWxzZSBpZihcInN0cmluZ1wiPT09dHlwZW9mIGEpZz01O2Vsc2UgYTpzd2l0Y2goYSl7Y2FzZSB1YTpyZXR1cm4gWGcoYy5jaGlsZHJlbixlLGYsYik7Y2FzZSBIYTpnPTg7ZXw9MTY7YnJlYWs7Y2FzZSB3YTpnPTg7ZXw9MTticmVhaztjYXNlIHhhOnJldHVybiBhPW5oKDEyLGMsYixlfDgpLGEuZWxlbWVudFR5cGU9eGEsYS50eXBlPXhhLGEubGFuZXM9ZixhO2Nhc2UgQmE6cmV0dXJuIGE9bmgoMTMsYyxiLGUpLGEudHlwZT1CYSxhLmVsZW1lbnRUeXBlPUJhLGEubGFuZXM9ZixhO2Nhc2UgQ2E6cmV0dXJuIGE9bmgoMTksYyxiLGUpLGEuZWxlbWVudFR5cGU9Q2EsYS5sYW5lcz1mLGE7Y2FzZSBJYTpyZXR1cm4gdmkoYyxlLGYsYik7Y2FzZSBKYTpyZXR1cm4gYT1uaCgyNCxjLGIsZSksYS5lbGVtZW50VHlwZT1KYSxhLmxhbmVzPWYsYTtkZWZhdWx0OmlmKFwib2JqZWN0XCI9PT1cbnR5cGVvZiBhJiZudWxsIT09YSlzd2l0Y2goYS4kJHR5cGVvZil7Y2FzZSB5YTpnPTEwO2JyZWFrIGE7Y2FzZSB6YTpnPTk7YnJlYWsgYTtjYXNlIEFhOmc9MTE7YnJlYWsgYTtjYXNlIERhOmc9MTQ7YnJlYWsgYTtjYXNlIEVhOmc9MTY7ZD1udWxsO2JyZWFrIGE7Y2FzZSBGYTpnPTIyO2JyZWFrIGF9dGhyb3cgRXJyb3IoeSgxMzAsbnVsbD09YT9hOnR5cGVvZiBhLFwiXCIpKTt9Yj1uaChnLGMsYixlKTtiLmVsZW1lbnRUeXBlPWE7Yi50eXBlPWQ7Yi5sYW5lcz1mO3JldHVybiBifWZ1bmN0aW9uIFhnKGEsYixjLGQpe2E9bmgoNyxhLGQsYik7YS5sYW5lcz1jO3JldHVybiBhfWZ1bmN0aW9uIHZpKGEsYixjLGQpe2E9bmgoMjMsYSxkLGIpO2EuZWxlbWVudFR5cGU9SWE7YS5sYW5lcz1jO3JldHVybiBhfWZ1bmN0aW9uIFVnKGEsYixjKXthPW5oKDYsYSxudWxsLGIpO2EubGFuZXM9YztyZXR1cm4gYX1cbmZ1bmN0aW9uIFdnKGEsYixjKXtiPW5oKDQsbnVsbCE9PWEuY2hpbGRyZW4/YS5jaGlsZHJlbjpbXSxhLmtleSxiKTtiLmxhbmVzPWM7Yi5zdGF0ZU5vZGU9e2NvbnRhaW5lckluZm86YS5jb250YWluZXJJbmZvLHBlbmRpbmdDaGlsZHJlbjpudWxsLGltcGxlbWVudGF0aW9uOmEuaW1wbGVtZW50YXRpb259O3JldHVybiBifVxuZnVuY3Rpb24gamsoYSxiLGMpe3RoaXMudGFnPWI7dGhpcy5jb250YWluZXJJbmZvPWE7dGhpcy5maW5pc2hlZFdvcms9dGhpcy5waW5nQ2FjaGU9dGhpcy5jdXJyZW50PXRoaXMucGVuZGluZ0NoaWxkcmVuPW51bGw7dGhpcy50aW1lb3V0SGFuZGxlPS0xO3RoaXMucGVuZGluZ0NvbnRleHQ9dGhpcy5jb250ZXh0PW51bGw7dGhpcy5oeWRyYXRlPWM7dGhpcy5jYWxsYmFja05vZGU9bnVsbDt0aGlzLmNhbGxiYWNrUHJpb3JpdHk9MDt0aGlzLmV2ZW50VGltZXM9WmMoMCk7dGhpcy5leHBpcmF0aW9uVGltZXM9WmMoLTEpO3RoaXMuZW50YW5nbGVkTGFuZXM9dGhpcy5maW5pc2hlZExhbmVzPXRoaXMubXV0YWJsZVJlYWRMYW5lcz10aGlzLmV4cGlyZWRMYW5lcz10aGlzLnBpbmdlZExhbmVzPXRoaXMuc3VzcGVuZGVkTGFuZXM9dGhpcy5wZW5kaW5nTGFuZXM9MDt0aGlzLmVudGFuZ2xlbWVudHM9WmMoMCk7dGhpcy5tdXRhYmxlU291cmNlRWFnZXJIeWRyYXRpb25EYXRhPW51bGx9XG5mdW5jdGlvbiBrayhhLGIsYyl7dmFyIGQ9Mzxhcmd1bWVudHMubGVuZ3RoJiZ2b2lkIDAhPT1hcmd1bWVudHNbM10/YXJndW1lbnRzWzNdOm51bGw7cmV0dXJueyQkdHlwZW9mOnRhLGtleTpudWxsPT1kP251bGw6XCJcIitkLGNoaWxkcmVuOmEsY29udGFpbmVySW5mbzpiLGltcGxlbWVudGF0aW9uOmN9fVxuZnVuY3Rpb24gbGsoYSxiLGMsZCl7dmFyIGU9Yi5jdXJyZW50LGY9SGcoKSxnPUlnKGUpO2E6aWYoYyl7Yz1jLl9yZWFjdEludGVybmFscztiOntpZihaYihjKSE9PWN8fDEhPT1jLnRhZyl0aHJvdyBFcnJvcih5KDE3MCkpO3ZhciBoPWM7ZG97c3dpdGNoKGgudGFnKXtjYXNlIDM6aD1oLnN0YXRlTm9kZS5jb250ZXh0O2JyZWFrIGI7Y2FzZSAxOmlmKEZmKGgudHlwZSkpe2g9aC5zdGF0ZU5vZGUuX19yZWFjdEludGVybmFsTWVtb2l6ZWRNZXJnZWRDaGlsZENvbnRleHQ7YnJlYWsgYn19aD1oLnJldHVybn13aGlsZShudWxsIT09aCk7dGhyb3cgRXJyb3IoeSgxNzEpKTt9aWYoMT09PWMudGFnKXt2YXIgaz1jLnR5cGU7aWYoRmYoaykpe2M9SWYoYyxrLGgpO2JyZWFrIGF9fWM9aH1lbHNlIGM9Q2Y7bnVsbD09PWIuY29udGV4dD9iLmNvbnRleHQ9YzpiLnBlbmRpbmdDb250ZXh0PWM7Yj16ZyhmLGcpO2IucGF5bG9hZD17ZWxlbWVudDphfTtkPXZvaWQgMD09PWQ/bnVsbDpkO251bGwhPT1cbmQmJihiLmNhbGxiYWNrPWQpO0FnKGUsYik7SmcoZSxnLGYpO3JldHVybiBnfWZ1bmN0aW9uIG1rKGEpe2E9YS5jdXJyZW50O2lmKCFhLmNoaWxkKXJldHVybiBudWxsO3N3aXRjaChhLmNoaWxkLnRhZyl7Y2FzZSA1OnJldHVybiBhLmNoaWxkLnN0YXRlTm9kZTtkZWZhdWx0OnJldHVybiBhLmNoaWxkLnN0YXRlTm9kZX19ZnVuY3Rpb24gbmsoYSxiKXthPWEubWVtb2l6ZWRTdGF0ZTtpZihudWxsIT09YSYmbnVsbCE9PWEuZGVoeWRyYXRlZCl7dmFyIGM9YS5yZXRyeUxhbmU7YS5yZXRyeUxhbmU9MCE9PWMmJmM8Yj9jOmJ9fWZ1bmN0aW9uIG9rKGEsYil7bmsoYSxiKTsoYT1hLmFsdGVybmF0ZSkmJm5rKGEsYil9ZnVuY3Rpb24gcGsoKXtyZXR1cm4gbnVsbH1cbmZ1bmN0aW9uIHFrKGEsYixjKXt2YXIgZD1udWxsIT1jJiZudWxsIT1jLmh5ZHJhdGlvbk9wdGlvbnMmJmMuaHlkcmF0aW9uT3B0aW9ucy5tdXRhYmxlU291cmNlc3x8bnVsbDtjPW5ldyBqayhhLGIsbnVsbCE9YyYmITA9PT1jLmh5ZHJhdGUpO2I9bmgoMyxudWxsLG51bGwsMj09PWI/NzoxPT09Yj8zOjApO2MuY3VycmVudD1iO2Iuc3RhdGVOb2RlPWM7eGcoYik7YVtmZl09Yy5jdXJyZW50O2NmKDg9PT1hLm5vZGVUeXBlP2EucGFyZW50Tm9kZTphKTtpZihkKWZvcihhPTA7YTxkLmxlbmd0aDthKyspe2I9ZFthXTt2YXIgZT1iLl9nZXRWZXJzaW9uO2U9ZShiLl9zb3VyY2UpO251bGw9PWMubXV0YWJsZVNvdXJjZUVhZ2VySHlkcmF0aW9uRGF0YT9jLm11dGFibGVTb3VyY2VFYWdlckh5ZHJhdGlvbkRhdGE9W2IsZV06Yy5tdXRhYmxlU291cmNlRWFnZXJIeWRyYXRpb25EYXRhLnB1c2goYixlKX10aGlzLl9pbnRlcm5hbFJvb3Q9Y31cbnFrLnByb3RvdHlwZS5yZW5kZXI9ZnVuY3Rpb24oYSl7bGsoYSx0aGlzLl9pbnRlcm5hbFJvb3QsbnVsbCxudWxsKX07cWsucHJvdG90eXBlLnVubW91bnQ9ZnVuY3Rpb24oKXt2YXIgYT10aGlzLl9pbnRlcm5hbFJvb3QsYj1hLmNvbnRhaW5lckluZm87bGsobnVsbCxhLG51bGwsZnVuY3Rpb24oKXtiW2ZmXT1udWxsfSl9O2Z1bmN0aW9uIHJrKGEpe3JldHVybiEoIWF8fDEhPT1hLm5vZGVUeXBlJiY5IT09YS5ub2RlVHlwZSYmMTEhPT1hLm5vZGVUeXBlJiYoOCE9PWEubm9kZVR5cGV8fFwiIHJlYWN0LW1vdW50LXBvaW50LXVuc3RhYmxlIFwiIT09YS5ub2RlVmFsdWUpKX1cbmZ1bmN0aW9uIHNrKGEsYil7Ynx8KGI9YT85PT09YS5ub2RlVHlwZT9hLmRvY3VtZW50RWxlbWVudDphLmZpcnN0Q2hpbGQ6bnVsbCxiPSEoIWJ8fDEhPT1iLm5vZGVUeXBlfHwhYi5oYXNBdHRyaWJ1dGUoXCJkYXRhLXJlYWN0cm9vdFwiKSkpO2lmKCFiKWZvcih2YXIgYztjPWEubGFzdENoaWxkOylhLnJlbW92ZUNoaWxkKGMpO3JldHVybiBuZXcgcWsoYSwwLGI/e2h5ZHJhdGU6ITB9OnZvaWQgMCl9XG5mdW5jdGlvbiB0ayhhLGIsYyxkLGUpe3ZhciBmPWMuX3JlYWN0Um9vdENvbnRhaW5lcjtpZihmKXt2YXIgZz1mLl9pbnRlcm5hbFJvb3Q7aWYoXCJmdW5jdGlvblwiPT09dHlwZW9mIGUpe3ZhciBoPWU7ZT1mdW5jdGlvbigpe3ZhciBhPW1rKGcpO2guY2FsbChhKX19bGsoYixnLGEsZSl9ZWxzZXtmPWMuX3JlYWN0Um9vdENvbnRhaW5lcj1zayhjLGQpO2c9Zi5faW50ZXJuYWxSb290O2lmKFwiZnVuY3Rpb25cIj09PXR5cGVvZiBlKXt2YXIgaz1lO2U9ZnVuY3Rpb24oKXt2YXIgYT1tayhnKTtrLmNhbGwoYSl9fVhqKGZ1bmN0aW9uKCl7bGsoYixnLGEsZSl9KX1yZXR1cm4gbWsoZyl9ZWM9ZnVuY3Rpb24oYSl7aWYoMTM9PT1hLnRhZyl7dmFyIGI9SGcoKTtKZyhhLDQsYik7b2soYSw0KX19O2ZjPWZ1bmN0aW9uKGEpe2lmKDEzPT09YS50YWcpe3ZhciBiPUhnKCk7SmcoYSw2NzEwODg2NCxiKTtvayhhLDY3MTA4ODY0KX19O1xuZ2M9ZnVuY3Rpb24oYSl7aWYoMTM9PT1hLnRhZyl7dmFyIGI9SGcoKSxjPUlnKGEpO0pnKGEsYyxiKTtvayhhLGMpfX07aGM9ZnVuY3Rpb24oYSxiKXtyZXR1cm4gYigpfTtcbnliPWZ1bmN0aW9uKGEsYixjKXtzd2l0Y2goYil7Y2FzZSBcImlucHV0XCI6YWIoYSxjKTtiPWMubmFtZTtpZihcInJhZGlvXCI9PT1jLnR5cGUmJm51bGwhPWIpe2ZvcihjPWE7Yy5wYXJlbnROb2RlOyljPWMucGFyZW50Tm9kZTtjPWMucXVlcnlTZWxlY3RvckFsbChcImlucHV0W25hbWU9XCIrSlNPTi5zdHJpbmdpZnkoXCJcIitiKSsnXVt0eXBlPVwicmFkaW9cIl0nKTtmb3IoYj0wO2I8Yy5sZW5ndGg7YisrKXt2YXIgZD1jW2JdO2lmKGQhPT1hJiZkLmZvcm09PT1hLmZvcm0pe3ZhciBlPURiKGQpO2lmKCFlKXRocm93IEVycm9yKHkoOTApKTtXYShkKTthYihkLGUpfX19YnJlYWs7Y2FzZSBcInRleHRhcmVhXCI6aWIoYSxjKTticmVhaztjYXNlIFwic2VsZWN0XCI6Yj1jLnZhbHVlLG51bGwhPWImJmZiKGEsISFjLm11bHRpcGxlLGIsITEpfX07R2I9V2o7XG5IYj1mdW5jdGlvbihhLGIsYyxkLGUpe3ZhciBmPVg7WHw9NDt0cnl7cmV0dXJuIGdnKDk4LGEuYmluZChudWxsLGIsYyxkLGUpKX1maW5hbGx5e1g9ZiwwPT09WCYmKHdqKCksaWcoKSl9fTtJYj1mdW5jdGlvbigpezA9PT0oWCY0OSkmJihWaigpLE9qKCkpfTtKYj1mdW5jdGlvbihhLGIpe3ZhciBjPVg7WHw9Mjt0cnl7cmV0dXJuIGEoYil9ZmluYWxseXtYPWMsMD09PVgmJih3aigpLGlnKCkpfX07ZnVuY3Rpb24gdWsoYSxiKXt2YXIgYz0yPGFyZ3VtZW50cy5sZW5ndGgmJnZvaWQgMCE9PWFyZ3VtZW50c1syXT9hcmd1bWVudHNbMl06bnVsbDtpZighcmsoYikpdGhyb3cgRXJyb3IoeSgyMDApKTtyZXR1cm4ga2soYSxiLG51bGwsYyl9dmFyIHZrPXtFdmVudHM6W0NiLHVlLERiLEViLEZiLE9qLHtjdXJyZW50OiExfV19LHdrPXtmaW5kRmliZXJCeUhvc3RJbnN0YW5jZTp3YyxidW5kbGVUeXBlOjAsdmVyc2lvbjpcIjE3LjAuMlwiLHJlbmRlcmVyUGFja2FnZU5hbWU6XCJyZWFjdC1kb21cIn07XG52YXIgeGs9e2J1bmRsZVR5cGU6d2suYnVuZGxlVHlwZSx2ZXJzaW9uOndrLnZlcnNpb24scmVuZGVyZXJQYWNrYWdlTmFtZTp3ay5yZW5kZXJlclBhY2thZ2VOYW1lLHJlbmRlcmVyQ29uZmlnOndrLnJlbmRlcmVyQ29uZmlnLG92ZXJyaWRlSG9va1N0YXRlOm51bGwsb3ZlcnJpZGVIb29rU3RhdGVEZWxldGVQYXRoOm51bGwsb3ZlcnJpZGVIb29rU3RhdGVSZW5hbWVQYXRoOm51bGwsb3ZlcnJpZGVQcm9wczpudWxsLG92ZXJyaWRlUHJvcHNEZWxldGVQYXRoOm51bGwsb3ZlcnJpZGVQcm9wc1JlbmFtZVBhdGg6bnVsbCxzZXRTdXNwZW5zZUhhbmRsZXI6bnVsbCxzY2hlZHVsZVVwZGF0ZTpudWxsLGN1cnJlbnREaXNwYXRjaGVyUmVmOnJhLlJlYWN0Q3VycmVudERpc3BhdGNoZXIsZmluZEhvc3RJbnN0YW5jZUJ5RmliZXI6ZnVuY3Rpb24oYSl7YT1jYyhhKTtyZXR1cm4gbnVsbD09PWE/bnVsbDphLnN0YXRlTm9kZX0sZmluZEZpYmVyQnlIb3N0SW5zdGFuY2U6d2suZmluZEZpYmVyQnlIb3N0SW5zdGFuY2V8fFxucGssZmluZEhvc3RJbnN0YW5jZXNGb3JSZWZyZXNoOm51bGwsc2NoZWR1bGVSZWZyZXNoOm51bGwsc2NoZWR1bGVSb290Om51bGwsc2V0UmVmcmVzaEhhbmRsZXI6bnVsbCxnZXRDdXJyZW50RmliZXI6bnVsbH07aWYoXCJ1bmRlZmluZWRcIiE9PXR5cGVvZiBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18pe3ZhciB5az1fX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX187aWYoIXlrLmlzRGlzYWJsZWQmJnlrLnN1cHBvcnRzRmliZXIpdHJ5e0xmPXlrLmluamVjdCh4ayksTWY9eWt9Y2F0Y2goYSl7fX1leHBvcnRzLl9fU0VDUkVUX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0ZJUkVEPXZrO2V4cG9ydHMuY3JlYXRlUG9ydGFsPXVrO1xuZXhwb3J0cy5maW5kRE9NTm9kZT1mdW5jdGlvbihhKXtpZihudWxsPT1hKXJldHVybiBudWxsO2lmKDE9PT1hLm5vZGVUeXBlKXJldHVybiBhO3ZhciBiPWEuX3JlYWN0SW50ZXJuYWxzO2lmKHZvaWQgMD09PWIpe2lmKFwiZnVuY3Rpb25cIj09PXR5cGVvZiBhLnJlbmRlcil0aHJvdyBFcnJvcih5KDE4OCkpO3Rocm93IEVycm9yKHkoMjY4LE9iamVjdC5rZXlzKGEpKSk7fWE9Y2MoYik7YT1udWxsPT09YT9udWxsOmEuc3RhdGVOb2RlO3JldHVybiBhfTtleHBvcnRzLmZsdXNoU3luYz1mdW5jdGlvbihhLGIpe3ZhciBjPVg7aWYoMCE9PShjJjQ4KSlyZXR1cm4gYShiKTtYfD0xO3RyeXtpZihhKXJldHVybiBnZyg5OSxhLmJpbmQobnVsbCxiKSl9ZmluYWxseXtYPWMsaWcoKX19O2V4cG9ydHMuaHlkcmF0ZT1mdW5jdGlvbihhLGIsYyl7aWYoIXJrKGIpKXRocm93IEVycm9yKHkoMjAwKSk7cmV0dXJuIHRrKG51bGwsYSxiLCEwLGMpfTtcbmV4cG9ydHMucmVuZGVyPWZ1bmN0aW9uKGEsYixjKXtpZighcmsoYikpdGhyb3cgRXJyb3IoeSgyMDApKTtyZXR1cm4gdGsobnVsbCxhLGIsITEsYyl9O2V4cG9ydHMudW5tb3VudENvbXBvbmVudEF0Tm9kZT1mdW5jdGlvbihhKXtpZighcmsoYSkpdGhyb3cgRXJyb3IoeSg0MCkpO3JldHVybiBhLl9yZWFjdFJvb3RDb250YWluZXI/KFhqKGZ1bmN0aW9uKCl7dGsobnVsbCxudWxsLGEsITEsZnVuY3Rpb24oKXthLl9yZWFjdFJvb3RDb250YWluZXI9bnVsbDthW2ZmXT1udWxsfSl9KSwhMCk6ITF9O2V4cG9ydHMudW5zdGFibGVfYmF0Y2hlZFVwZGF0ZXM9V2o7ZXhwb3J0cy51bnN0YWJsZV9jcmVhdGVQb3J0YWw9ZnVuY3Rpb24oYSxiKXtyZXR1cm4gdWsoYSxiLDI8YXJndW1lbnRzLmxlbmd0aCYmdm9pZCAwIT09YXJndW1lbnRzWzJdP2FyZ3VtZW50c1syXTpudWxsKX07XG5leHBvcnRzLnVuc3RhYmxlX3JlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyPWZ1bmN0aW9uKGEsYixjLGQpe2lmKCFyayhjKSl0aHJvdyBFcnJvcih5KDIwMCkpO2lmKG51bGw9PWF8fHZvaWQgMD09PWEuX3JlYWN0SW50ZXJuYWxzKXRocm93IEVycm9yKHkoMzgpKTtyZXR1cm4gdGsoYSxiLGMsITEsZCl9O2V4cG9ydHMudmVyc2lvbj1cIjE3LjAuMlwiO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///448\n')},935:(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("\n\nfunction checkDCE() {\n  /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */\n  if (\n    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === 'undefined' ||\n    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== 'function'\n  ) {\n    return;\n  }\n  if (false) {}\n  try {\n    // Verify that the code above has been dead code eliminated (DCE'd).\n    __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);\n  } catch (err) {\n    // DevTools shouldn't crash React, no matter what.\n    // We should still report in case we break this code.\n    console.error(err);\n  }\n}\n\nif (true) {\n  // DCE check should happen before ReactDOM bundle executes so that\n  // DevTools can report bad minification during injection.\n  checkDCE();\n  module.exports = __webpack_require__(448);\n} else {}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTM1LmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLEtBQXFDLEVBQUUsRUFTMUM7QUFDSDtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxJQUFJLElBQXFDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBLEVBQUUseUNBQTZEO0FBQy9ELEVBQUUsS0FBSyxFQUVOIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbWRjLXJlYWN0Ly4vbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9pbmRleC5qcz84YmM4Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gY2hlY2tEQ0UoKSB7XG4gIC8qIGdsb2JhbCBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18gKi9cbiAgaWYgKFxuICAgIHR5cGVvZiBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18gPT09ICd1bmRlZmluZWQnIHx8XG4gICAgdHlwZW9mIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXy5jaGVja0RDRSAhPT0gJ2Z1bmN0aW9uJ1xuICApIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAvLyBUaGlzIGJyYW5jaCBpcyB1bnJlYWNoYWJsZSBiZWNhdXNlIHRoaXMgZnVuY3Rpb24gaXMgb25seSBjYWxsZWRcbiAgICAvLyBpbiBwcm9kdWN0aW9uLCBidXQgdGhlIGNvbmRpdGlvbiBpcyB0cnVlIG9ubHkgaW4gZGV2ZWxvcG1lbnQuXG4gICAgLy8gVGhlcmVmb3JlIGlmIHRoZSBicmFuY2ggaXMgc3RpbGwgaGVyZSwgZGVhZCBjb2RlIGVsaW1pbmF0aW9uIHdhc24ndFxuICAgIC8vIHByb3Blcmx5IGFwcGxpZWQuXG4gICAgLy8gRG9uJ3QgY2hhbmdlIHRoZSBtZXNzYWdlLiBSZWFjdCBEZXZUb29scyByZWxpZXMgb24gaXQuIEFsc28gbWFrZSBzdXJlXG4gICAgLy8gdGhpcyBtZXNzYWdlIGRvZXNuJ3Qgb2NjdXIgZWxzZXdoZXJlIGluIHRoaXMgZnVuY3Rpb24sIG9yIGl0IHdpbGwgY2F1c2VcbiAgICAvLyBhIGZhbHNlIHBvc2l0aXZlLlxuICAgIHRocm93IG5ldyBFcnJvcignXl9eJyk7XG4gIH1cbiAgdHJ5IHtcbiAgICAvLyBWZXJpZnkgdGhhdCB0aGUgY29kZSBhYm92ZSBoYXMgYmVlbiBkZWFkIGNvZGUgZWxpbWluYXRlZCAoRENFJ2QpLlxuICAgIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXy5jaGVja0RDRShjaGVja0RDRSk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIC8vIERldlRvb2xzIHNob3VsZG4ndCBjcmFzaCBSZWFjdCwgbm8gbWF0dGVyIHdoYXQuXG4gICAgLy8gV2Ugc2hvdWxkIHN0aWxsIHJlcG9ydCBpbiBjYXNlIHdlIGJyZWFrIHRoaXMgY29kZS5cbiAgICBjb25zb2xlLmVycm9yKGVycik7XG4gIH1cbn1cblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcbiAgLy8gRENFIGNoZWNrIHNob3VsZCBoYXBwZW4gYmVmb3JlIFJlYWN0RE9NIGJ1bmRsZSBleGVjdXRlcyBzbyB0aGF0XG4gIC8vIERldlRvb2xzIGNhbiByZXBvcnQgYmFkIG1pbmlmaWNhdGlvbiBkdXJpbmcgaW5qZWN0aW9uLlxuICBjaGVja0RDRSgpO1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3JlYWN0LWRvbS5wcm9kdWN0aW9uLm1pbi5qcycpO1xufSBlbHNlIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9yZWFjdC1kb20uZGV2ZWxvcG1lbnQuanMnKTtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///935\n")},921:(__unused_webpack_module,exports)=>{"use strict";eval('/** @license React v16.13.1\n * react-is.production.min.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nvar b="function"===typeof Symbol&&Symbol.for,c=b?Symbol.for("react.element"):60103,d=b?Symbol.for("react.portal"):60106,e=b?Symbol.for("react.fragment"):60107,f=b?Symbol.for("react.strict_mode"):60108,g=b?Symbol.for("react.profiler"):60114,h=b?Symbol.for("react.provider"):60109,k=b?Symbol.for("react.context"):60110,l=b?Symbol.for("react.async_mode"):60111,m=b?Symbol.for("react.concurrent_mode"):60111,n=b?Symbol.for("react.forward_ref"):60112,p=b?Symbol.for("react.suspense"):60113,q=b?\nSymbol.for("react.suspense_list"):60120,r=b?Symbol.for("react.memo"):60115,t=b?Symbol.for("react.lazy"):60116,v=b?Symbol.for("react.block"):60121,w=b?Symbol.for("react.fundamental"):60117,x=b?Symbol.for("react.responder"):60118,y=b?Symbol.for("react.scope"):60119;\nfunction z(a){if("object"===typeof a&&null!==a){var u=a.$$typeof;switch(u){case c:switch(a=a.type,a){case l:case m:case e:case g:case f:case p:return a;default:switch(a=a&&a.$$typeof,a){case k:case n:case t:case r:case h:return a;default:return u}}case d:return u}}}function A(a){return z(a)===m}exports.AsyncMode=l;exports.ConcurrentMode=m;exports.ContextConsumer=k;exports.ContextProvider=h;exports.Element=c;exports.ForwardRef=n;exports.Fragment=e;exports.Lazy=t;exports.Memo=r;exports.Portal=d;\nexports.Profiler=g;exports.StrictMode=f;exports.Suspense=p;exports.isAsyncMode=function(a){return A(a)||z(a)===l};exports.isConcurrentMode=A;exports.isContextConsumer=function(a){return z(a)===k};exports.isContextProvider=function(a){return z(a)===h};exports.isElement=function(a){return"object"===typeof a&&null!==a&&a.$$typeof===c};exports.isForwardRef=function(a){return z(a)===n};exports.isFragment=function(a){return z(a)===e};exports.isLazy=function(a){return z(a)===t};\nexports.isMemo=function(a){return z(a)===r};exports.isPortal=function(a){return z(a)===d};exports.isProfiler=function(a){return z(a)===g};exports.isStrictMode=function(a){return z(a)===f};exports.isSuspense=function(a){return z(a)===p};\nexports.isValidElementType=function(a){return"string"===typeof a||"function"===typeof a||a===e||a===m||a===g||a===f||a===p||a===q||"object"===typeof a&&null!==a&&(a.$$typeof===t||a.$$typeof===r||a.$$typeof===h||a.$$typeof===k||a.$$typeof===n||a.$$typeof===w||a.$$typeof===x||a.$$typeof===y||a.$$typeof===v)};exports.typeOf=z;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTIxLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWE7QUFDYjtBQUNBLGNBQWMsa0NBQWtDLGlCQUFpQixVQUFVLDBCQUEwQixtREFBbUQsa0NBQWtDLDRDQUE0QyxrQkFBa0Isa0JBQWtCLGNBQWMsZ0JBQWdCLGlCQUFpQixHQUFHLHNCQUFzQixHQUFHLHVCQUF1QixHQUFHLHVCQUF1QixHQUFHLGVBQWUsR0FBRyxrQkFBa0IsR0FBRyxnQkFBZ0IsR0FBRyxZQUFZLEdBQUcsWUFBWSxHQUFHLGNBQWM7QUFDL2UsZ0JBQWdCLEdBQUcsa0JBQWtCLEdBQUcsZ0JBQWdCLEdBQUcsbUJBQW1CLGFBQWEsdUJBQXVCLHdCQUF3QixHQUFHLHlCQUF5QixhQUFhLGlCQUFpQix5QkFBeUIsYUFBYSxpQkFBaUIsaUJBQWlCLGFBQWEscURBQXFELG9CQUFvQixhQUFhLGlCQUFpQixrQkFBa0IsYUFBYSxpQkFBaUIsY0FBYyxhQUFhO0FBQzNjLGNBQWMsYUFBYSxpQkFBaUIsZ0JBQWdCLGFBQWEsaUJBQWlCLGtCQUFrQixhQUFhLGlCQUFpQixvQkFBb0IsYUFBYSxpQkFBaUIsa0JBQWtCLGFBQWE7QUFDM04sMEJBQTBCLGFBQWEsNlFBQTZRLGNBQWMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9ub2RlX21vZHVsZXMvcmVhY3QtaXMvY2pzL3JlYWN0LWlzLnByb2R1Y3Rpb24ubWluLmpzP2E5M2QiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqIEBsaWNlbnNlIFJlYWN0IHYxNi4xMy4xXG4gKiByZWFjdC1pcy5wcm9kdWN0aW9uLm1pbi5qc1xuICpcbiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbid1c2Ugc3RyaWN0Jzt2YXIgYj1cImZ1bmN0aW9uXCI9PT10eXBlb2YgU3ltYm9sJiZTeW1ib2wuZm9yLGM9Yj9TeW1ib2wuZm9yKFwicmVhY3QuZWxlbWVudFwiKTo2MDEwMyxkPWI/U3ltYm9sLmZvcihcInJlYWN0LnBvcnRhbFwiKTo2MDEwNixlPWI/U3ltYm9sLmZvcihcInJlYWN0LmZyYWdtZW50XCIpOjYwMTA3LGY9Yj9TeW1ib2wuZm9yKFwicmVhY3Quc3RyaWN0X21vZGVcIik6NjAxMDgsZz1iP1N5bWJvbC5mb3IoXCJyZWFjdC5wcm9maWxlclwiKTo2MDExNCxoPWI/U3ltYm9sLmZvcihcInJlYWN0LnByb3ZpZGVyXCIpOjYwMTA5LGs9Yj9TeW1ib2wuZm9yKFwicmVhY3QuY29udGV4dFwiKTo2MDExMCxsPWI/U3ltYm9sLmZvcihcInJlYWN0LmFzeW5jX21vZGVcIik6NjAxMTEsbT1iP1N5bWJvbC5mb3IoXCJyZWFjdC5jb25jdXJyZW50X21vZGVcIik6NjAxMTEsbj1iP1N5bWJvbC5mb3IoXCJyZWFjdC5mb3J3YXJkX3JlZlwiKTo2MDExMixwPWI/U3ltYm9sLmZvcihcInJlYWN0LnN1c3BlbnNlXCIpOjYwMTEzLHE9Yj9cblN5bWJvbC5mb3IoXCJyZWFjdC5zdXNwZW5zZV9saXN0XCIpOjYwMTIwLHI9Yj9TeW1ib2wuZm9yKFwicmVhY3QubWVtb1wiKTo2MDExNSx0PWI/U3ltYm9sLmZvcihcInJlYWN0LmxhenlcIik6NjAxMTYsdj1iP1N5bWJvbC5mb3IoXCJyZWFjdC5ibG9ja1wiKTo2MDEyMSx3PWI/U3ltYm9sLmZvcihcInJlYWN0LmZ1bmRhbWVudGFsXCIpOjYwMTE3LHg9Yj9TeW1ib2wuZm9yKFwicmVhY3QucmVzcG9uZGVyXCIpOjYwMTE4LHk9Yj9TeW1ib2wuZm9yKFwicmVhY3Quc2NvcGVcIik6NjAxMTk7XG5mdW5jdGlvbiB6KGEpe2lmKFwib2JqZWN0XCI9PT10eXBlb2YgYSYmbnVsbCE9PWEpe3ZhciB1PWEuJCR0eXBlb2Y7c3dpdGNoKHUpe2Nhc2UgYzpzd2l0Y2goYT1hLnR5cGUsYSl7Y2FzZSBsOmNhc2UgbTpjYXNlIGU6Y2FzZSBnOmNhc2UgZjpjYXNlIHA6cmV0dXJuIGE7ZGVmYXVsdDpzd2l0Y2goYT1hJiZhLiQkdHlwZW9mLGEpe2Nhc2UgazpjYXNlIG46Y2FzZSB0OmNhc2UgcjpjYXNlIGg6cmV0dXJuIGE7ZGVmYXVsdDpyZXR1cm4gdX19Y2FzZSBkOnJldHVybiB1fX19ZnVuY3Rpb24gQShhKXtyZXR1cm4geihhKT09PW19ZXhwb3J0cy5Bc3luY01vZGU9bDtleHBvcnRzLkNvbmN1cnJlbnRNb2RlPW07ZXhwb3J0cy5Db250ZXh0Q29uc3VtZXI9aztleHBvcnRzLkNvbnRleHRQcm92aWRlcj1oO2V4cG9ydHMuRWxlbWVudD1jO2V4cG9ydHMuRm9yd2FyZFJlZj1uO2V4cG9ydHMuRnJhZ21lbnQ9ZTtleHBvcnRzLkxhenk9dDtleHBvcnRzLk1lbW89cjtleHBvcnRzLlBvcnRhbD1kO1xuZXhwb3J0cy5Qcm9maWxlcj1nO2V4cG9ydHMuU3RyaWN0TW9kZT1mO2V4cG9ydHMuU3VzcGVuc2U9cDtleHBvcnRzLmlzQXN5bmNNb2RlPWZ1bmN0aW9uKGEpe3JldHVybiBBKGEpfHx6KGEpPT09bH07ZXhwb3J0cy5pc0NvbmN1cnJlbnRNb2RlPUE7ZXhwb3J0cy5pc0NvbnRleHRDb25zdW1lcj1mdW5jdGlvbihhKXtyZXR1cm4geihhKT09PWt9O2V4cG9ydHMuaXNDb250ZXh0UHJvdmlkZXI9ZnVuY3Rpb24oYSl7cmV0dXJuIHooYSk9PT1ofTtleHBvcnRzLmlzRWxlbWVudD1mdW5jdGlvbihhKXtyZXR1cm5cIm9iamVjdFwiPT09dHlwZW9mIGEmJm51bGwhPT1hJiZhLiQkdHlwZW9mPT09Y307ZXhwb3J0cy5pc0ZvcndhcmRSZWY9ZnVuY3Rpb24oYSl7cmV0dXJuIHooYSk9PT1ufTtleHBvcnRzLmlzRnJhZ21lbnQ9ZnVuY3Rpb24oYSl7cmV0dXJuIHooYSk9PT1lfTtleHBvcnRzLmlzTGF6eT1mdW5jdGlvbihhKXtyZXR1cm4geihhKT09PXR9O1xuZXhwb3J0cy5pc01lbW89ZnVuY3Rpb24oYSl7cmV0dXJuIHooYSk9PT1yfTtleHBvcnRzLmlzUG9ydGFsPWZ1bmN0aW9uKGEpe3JldHVybiB6KGEpPT09ZH07ZXhwb3J0cy5pc1Byb2ZpbGVyPWZ1bmN0aW9uKGEpe3JldHVybiB6KGEpPT09Z307ZXhwb3J0cy5pc1N0cmljdE1vZGU9ZnVuY3Rpb24oYSl7cmV0dXJuIHooYSk9PT1mfTtleHBvcnRzLmlzU3VzcGVuc2U9ZnVuY3Rpb24oYSl7cmV0dXJuIHooYSk9PT1wfTtcbmV4cG9ydHMuaXNWYWxpZEVsZW1lbnRUeXBlPWZ1bmN0aW9uKGEpe3JldHVyblwic3RyaW5nXCI9PT10eXBlb2YgYXx8XCJmdW5jdGlvblwiPT09dHlwZW9mIGF8fGE9PT1lfHxhPT09bXx8YT09PWd8fGE9PT1mfHxhPT09cHx8YT09PXF8fFwib2JqZWN0XCI9PT10eXBlb2YgYSYmbnVsbCE9PWEmJihhLiQkdHlwZW9mPT09dHx8YS4kJHR5cGVvZj09PXJ8fGEuJCR0eXBlb2Y9PT1ofHxhLiQkdHlwZW9mPT09a3x8YS4kJHR5cGVvZj09PW58fGEuJCR0eXBlb2Y9PT13fHxhLiQkdHlwZW9mPT09eHx8YS4kJHR5cGVvZj09PXl8fGEuJCR0eXBlb2Y9PT12KX07ZXhwb3J0cy50eXBlT2Y9ejtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///921\n')},864:(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("\n\nif (true) {\n  module.exports = __webpack_require__(921);\n} else {}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODY0LmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLElBQUksSUFBcUM7QUFDekMsRUFBRSx5Q0FBNEQ7QUFDOUQsRUFBRSxLQUFLLEVBRU4iLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9ub2RlX21vZHVsZXMvcmVhY3QtaXMvaW5kZXguanM/NGNlYyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtaXMucHJvZHVjdGlvbi5taW4uanMnKTtcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtaXMuZGV2ZWxvcG1lbnQuanMnKTtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///864\n")},251:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('/** @license React v17.0.2\n * react-jsx-runtime.production.min.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n__webpack_require__(418);var f=__webpack_require__(294),g=60103;exports.Fragment=60107;if("function"===typeof Symbol&&Symbol.for){var h=Symbol.for;g=h("react.element");exports.Fragment=h("react.fragment")}var m=f.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner,n=Object.prototype.hasOwnProperty,p={key:!0,ref:!0,__self:!0,__source:!0};\nfunction q(c,a,k){var b,d={},e=null,l=null;void 0!==k&&(e=""+k);void 0!==a.key&&(e=""+a.key);void 0!==a.ref&&(l=a.ref);for(b in a)n.call(a,b)&&!p.hasOwnProperty(b)&&(d[b]=a[b]);if(c&&c.defaultProps)for(b in a=c.defaultProps,a)void 0===d[b]&&(d[b]=a[b]);return{$$typeof:g,type:c,key:e,ref:l,props:d,_owner:m.current}}exports.jsx=q;exports.jsxs=q;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjUxLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDYSxtQkFBTyxDQUFDLEdBQWUsRUFBRSxNQUFNLG1CQUFPLENBQUMsR0FBTyxVQUFVLGdCQUFnQixPQUFPLDJDQUEyQyxpQkFBaUIscUJBQXFCLGdCQUFnQixxQkFBcUIsa0hBQWtIO0FBQ3BVLGtCQUFrQixVQUFVLGVBQWUscUJBQXFCLDZCQUE2QiwwQkFBMEIsMERBQTBELDRFQUE0RSxPQUFPLHdEQUF3RCxXQUFXLEdBQUcsWUFBWSIsInNvdXJjZXMiOlsid2VicGFjazovL21kYy1yZWFjdC8uL25vZGVfbW9kdWxlcy9yZWFjdC9janMvcmVhY3QtanN4LXJ1bnRpbWUucHJvZHVjdGlvbi5taW4uanM/ZDMxZCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiogQGxpY2Vuc2UgUmVhY3QgdjE3LjAuMlxuICogcmVhY3QtanN4LXJ1bnRpbWUucHJvZHVjdGlvbi5taW4uanNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuJ3VzZSBzdHJpY3QnO3JlcXVpcmUoXCJvYmplY3QtYXNzaWduXCIpO3ZhciBmPXJlcXVpcmUoXCJyZWFjdFwiKSxnPTYwMTAzO2V4cG9ydHMuRnJhZ21lbnQ9NjAxMDc7aWYoXCJmdW5jdGlvblwiPT09dHlwZW9mIFN5bWJvbCYmU3ltYm9sLmZvcil7dmFyIGg9U3ltYm9sLmZvcjtnPWgoXCJyZWFjdC5lbGVtZW50XCIpO2V4cG9ydHMuRnJhZ21lbnQ9aChcInJlYWN0LmZyYWdtZW50XCIpfXZhciBtPWYuX19TRUNSRVRfSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfWU9VX1dJTExfQkVfRklSRUQuUmVhY3RDdXJyZW50T3duZXIsbj1PYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LHA9e2tleTohMCxyZWY6ITAsX19zZWxmOiEwLF9fc291cmNlOiEwfTtcbmZ1bmN0aW9uIHEoYyxhLGspe3ZhciBiLGQ9e30sZT1udWxsLGw9bnVsbDt2b2lkIDAhPT1rJiYoZT1cIlwiK2spO3ZvaWQgMCE9PWEua2V5JiYoZT1cIlwiK2Eua2V5KTt2b2lkIDAhPT1hLnJlZiYmKGw9YS5yZWYpO2ZvcihiIGluIGEpbi5jYWxsKGEsYikmJiFwLmhhc093blByb3BlcnR5KGIpJiYoZFtiXT1hW2JdKTtpZihjJiZjLmRlZmF1bHRQcm9wcylmb3IoYiBpbiBhPWMuZGVmYXVsdFByb3BzLGEpdm9pZCAwPT09ZFtiXSYmKGRbYl09YVtiXSk7cmV0dXJueyQkdHlwZW9mOmcsdHlwZTpjLGtleTplLHJlZjpsLHByb3BzOmQsX293bmVyOm0uY3VycmVudH19ZXhwb3J0cy5qc3g9cTtleHBvcnRzLmpzeHM9cTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///251\n')},408:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('/** @license React v17.0.2\n * react.production.min.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nvar l=__webpack_require__(418),n=60103,p=60106;exports.Fragment=60107;exports.StrictMode=60108;exports.Profiler=60114;var q=60109,r=60110,t=60112;exports.Suspense=60113;var u=60115,v=60116;\nif("function"===typeof Symbol&&Symbol.for){var w=Symbol.for;n=w("react.element");p=w("react.portal");exports.Fragment=w("react.fragment");exports.StrictMode=w("react.strict_mode");exports.Profiler=w("react.profiler");q=w("react.provider");r=w("react.context");t=w("react.forward_ref");exports.Suspense=w("react.suspense");u=w("react.memo");v=w("react.lazy")}var x="function"===typeof Symbol&&Symbol.iterator;\nfunction y(a){if(null===a||"object"!==typeof a)return null;a=x&&a[x]||a["@@iterator"];return"function"===typeof a?a:null}function z(a){for(var b="https://reactjs.org/docs/error-decoder.html?invariant="+a,c=1;c<arguments.length;c++)b+="&args[]="+encodeURIComponent(arguments[c]);return"Minified React error #"+a+"; visit "+b+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}\nvar A={isMounted:function(){return!1},enqueueForceUpdate:function(){},enqueueReplaceState:function(){},enqueueSetState:function(){}},B={};function C(a,b,c){this.props=a;this.context=b;this.refs=B;this.updater=c||A}C.prototype.isReactComponent={};C.prototype.setState=function(a,b){if("object"!==typeof a&&"function"!==typeof a&&null!=a)throw Error(z(85));this.updater.enqueueSetState(this,a,b,"setState")};C.prototype.forceUpdate=function(a){this.updater.enqueueForceUpdate(this,a,"forceUpdate")};\nfunction D(){}D.prototype=C.prototype;function E(a,b,c){this.props=a;this.context=b;this.refs=B;this.updater=c||A}var F=E.prototype=new D;F.constructor=E;l(F,C.prototype);F.isPureReactComponent=!0;var G={current:null},H=Object.prototype.hasOwnProperty,I={key:!0,ref:!0,__self:!0,__source:!0};\nfunction J(a,b,c){var e,d={},k=null,h=null;if(null!=b)for(e in void 0!==b.ref&&(h=b.ref),void 0!==b.key&&(k=""+b.key),b)H.call(b,e)&&!I.hasOwnProperty(e)&&(d[e]=b[e]);var g=arguments.length-2;if(1===g)d.children=c;else if(1<g){for(var f=Array(g),m=0;m<g;m++)f[m]=arguments[m+2];d.children=f}if(a&&a.defaultProps)for(e in g=a.defaultProps,g)void 0===d[e]&&(d[e]=g[e]);return{$$typeof:n,type:a,key:k,ref:h,props:d,_owner:G.current}}\nfunction K(a,b){return{$$typeof:n,type:a.type,key:b,ref:a.ref,props:a.props,_owner:a._owner}}function L(a){return"object"===typeof a&&null!==a&&a.$$typeof===n}function escape(a){var b={"=":"=0",":":"=2"};return"$"+a.replace(/[=:]/g,function(a){return b[a]})}var M=/\\/+/g;function N(a,b){return"object"===typeof a&&null!==a&&null!=a.key?escape(""+a.key):b.toString(36)}\nfunction O(a,b,c,e,d){var k=typeof a;if("undefined"===k||"boolean"===k)a=null;var h=!1;if(null===a)h=!0;else switch(k){case "string":case "number":h=!0;break;case "object":switch(a.$$typeof){case n:case p:h=!0}}if(h)return h=a,d=d(h),a=""===e?"."+N(h,0):e,Array.isArray(d)?(c="",null!=a&&(c=a.replace(M,"$&/")+"/"),O(d,b,c,"",function(a){return a})):null!=d&&(L(d)&&(d=K(d,c+(!d.key||h&&h.key===d.key?"":(""+d.key).replace(M,"$&/")+"/")+a)),b.push(d)),1;h=0;e=""===e?".":e+":";if(Array.isArray(a))for(var g=\n0;g<a.length;g++){k=a[g];var f=e+N(k,g);h+=O(k,b,c,f,d)}else if(f=y(a),"function"===typeof f)for(a=f.call(a),g=0;!(k=a.next()).done;)k=k.value,f=e+N(k,g++),h+=O(k,b,c,f,d);else if("object"===k)throw b=""+a,Error(z(31,"[object Object]"===b?"object with keys {"+Object.keys(a).join(", ")+"}":b));return h}function P(a,b,c){if(null==a)return a;var e=[],d=0;O(a,e,"","",function(a){return b.call(c,a,d++)});return e}\nfunction Q(a){if(-1===a._status){var b=a._result;b=b();a._status=0;a._result=b;b.then(function(b){0===a._status&&(b=b.default,a._status=1,a._result=b)},function(b){0===a._status&&(a._status=2,a._result=b)})}if(1===a._status)return a._result;throw a._result;}var R={current:null};function S(){var a=R.current;if(null===a)throw Error(z(321));return a}var T={ReactCurrentDispatcher:R,ReactCurrentBatchConfig:{transition:0},ReactCurrentOwner:G,IsSomeRendererActing:{current:!1},assign:l};\nexports.Children={map:P,forEach:function(a,b,c){P(a,function(){b.apply(this,arguments)},c)},count:function(a){var b=0;P(a,function(){b++});return b},toArray:function(a){return P(a,function(a){return a})||[]},only:function(a){if(!L(a))throw Error(z(143));return a}};exports.Component=C;exports.PureComponent=E;exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=T;\nexports.cloneElement=function(a,b,c){if(null===a||void 0===a)throw Error(z(267,a));var e=l({},a.props),d=a.key,k=a.ref,h=a._owner;if(null!=b){void 0!==b.ref&&(k=b.ref,h=G.current);void 0!==b.key&&(d=""+b.key);if(a.type&&a.type.defaultProps)var g=a.type.defaultProps;for(f in b)H.call(b,f)&&!I.hasOwnProperty(f)&&(e[f]=void 0===b[f]&&void 0!==g?g[f]:b[f])}var f=arguments.length-2;if(1===f)e.children=c;else if(1<f){g=Array(f);for(var m=0;m<f;m++)g[m]=arguments[m+2];e.children=g}return{$$typeof:n,type:a.type,\nkey:d,ref:k,props:e,_owner:h}};exports.createContext=function(a,b){void 0===b&&(b=null);a={$$typeof:r,_calculateChangedBits:b,_currentValue:a,_currentValue2:a,_threadCount:0,Provider:null,Consumer:null};a.Provider={$$typeof:q,_context:a};return a.Consumer=a};exports.createElement=J;exports.createFactory=function(a){var b=J.bind(null,a);b.type=a;return b};exports.createRef=function(){return{current:null}};exports.forwardRef=function(a){return{$$typeof:t,render:a}};exports.isValidElement=L;\nexports.lazy=function(a){return{$$typeof:v,_payload:{_status:-1,_result:a},_init:Q}};exports.memo=function(a,b){return{$$typeof:u,type:a,compare:void 0===b?null:b}};exports.useCallback=function(a,b){return S().useCallback(a,b)};exports.useContext=function(a,b){return S().useContext(a,b)};exports.useDebugValue=function(){};exports.useEffect=function(a,b){return S().useEffect(a,b)};exports.useImperativeHandle=function(a,b,c){return S().useImperativeHandle(a,b,c)};\nexports.useLayoutEffect=function(a,b){return S().useLayoutEffect(a,b)};exports.useMemo=function(a,b){return S().useMemo(a,b)};exports.useReducer=function(a,b,c){return S().useReducer(a,b,c)};exports.useRef=function(a){return S().useRef(a)};exports.useState=function(a){return S().useState(a)};exports.version="17.0.2";\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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Ly9tZGMtcmVhY3QvLi9ub2RlX21vZHVsZXMvcmVhY3QvY2pzL3JlYWN0LnByb2R1Y3Rpb24ubWluLmpzP2JlMjQiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqIEBsaWNlbnNlIFJlYWN0IHYxNy4wLjJcbiAqIHJlYWN0LnByb2R1Y3Rpb24ubWluLmpzXG4gKlxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cbid1c2Ugc3RyaWN0Jzt2YXIgbD1yZXF1aXJlKFwib2JqZWN0LWFzc2lnblwiKSxuPTYwMTAzLHA9NjAxMDY7ZXhwb3J0cy5GcmFnbWVudD02MDEwNztleHBvcnRzLlN0cmljdE1vZGU9NjAxMDg7ZXhwb3J0cy5Qcm9maWxlcj02MDExNDt2YXIgcT02MDEwOSxyPTYwMTEwLHQ9NjAxMTI7ZXhwb3J0cy5TdXNwZW5zZT02MDExMzt2YXIgdT02MDExNSx2PTYwMTE2O1xuaWYoXCJmdW5jdGlvblwiPT09dHlwZW9mIFN5bWJvbCYmU3ltYm9sLmZvcil7dmFyIHc9U3ltYm9sLmZvcjtuPXcoXCJyZWFjdC5lbGVtZW50XCIpO3A9dyhcInJlYWN0LnBvcnRhbFwiKTtleHBvcnRzLkZyYWdtZW50PXcoXCJyZWFjdC5mcmFnbWVudFwiKTtleHBvcnRzLlN0cmljdE1vZGU9dyhcInJlYWN0LnN0cmljdF9tb2RlXCIpO2V4cG9ydHMuUHJvZmlsZXI9dyhcInJlYWN0LnByb2ZpbGVyXCIpO3E9dyhcInJlYWN0LnByb3ZpZGVyXCIpO3I9dyhcInJlYWN0LmNvbnRleHRcIik7dD13KFwicmVhY3QuZm9yd2FyZF9yZWZcIik7ZXhwb3J0cy5TdXNwZW5zZT13KFwicmVhY3Quc3VzcGVuc2VcIik7dT13KFwicmVhY3QubWVtb1wiKTt2PXcoXCJyZWFjdC5sYXp5XCIpfXZhciB4PVwiZnVuY3Rpb25cIj09PXR5cGVvZiBTeW1ib2wmJlN5bWJvbC5pdGVyYXRvcjtcbmZ1bmN0aW9uIHkoYSl7aWYobnVsbD09PWF8fFwib2JqZWN0XCIhPT10eXBlb2YgYSlyZXR1cm4gbnVsbDthPXgmJmFbeF18fGFbXCJAQGl0ZXJhdG9yXCJdO3JldHVyblwiZnVuY3Rpb25cIj09PXR5cGVvZiBhP2E6bnVsbH1mdW5jdGlvbiB6KGEpe2Zvcih2YXIgYj1cImh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9lcnJvci1kZWNvZGVyLmh0bWw/aW52YXJpYW50PVwiK2EsYz0xO2M8YXJndW1lbnRzLmxlbmd0aDtjKyspYis9XCImYXJnc1tdPVwiK2VuY29kZVVSSUNvbXBvbmVudChhcmd1bWVudHNbY10pO3JldHVyblwiTWluaWZpZWQgUmVhY3QgZXJyb3IgI1wiK2ErXCI7IHZpc2l0IFwiK2IrXCIgZm9yIHRoZSBmdWxsIG1lc3NhZ2Ugb3IgdXNlIHRoZSBub24tbWluaWZpZWQgZGV2IGVudmlyb25tZW50IGZvciBmdWxsIGVycm9ycyBhbmQgYWRkaXRpb25hbCBoZWxwZnVsIHdhcm5pbmdzLlwifVxudmFyIEE9e2lzTW91bnRlZDpmdW5jdGlvbigpe3JldHVybiExfSxlbnF1ZXVlRm9yY2VVcGRhdGU6ZnVuY3Rpb24oKXt9LGVucXVldWVSZXBsYWNlU3RhdGU6ZnVuY3Rpb24oKXt9LGVucXVldWVTZXRTdGF0ZTpmdW5jdGlvbigpe319LEI9e307ZnVuY3Rpb24gQyhhLGIsYyl7dGhpcy5wcm9wcz1hO3RoaXMuY29udGV4dD1iO3RoaXMucmVmcz1CO3RoaXMudXBkYXRlcj1jfHxBfUMucHJvdG90eXBlLmlzUmVhY3RDb21wb25lbnQ9e307Qy5wcm90b3R5cGUuc2V0U3RhdGU9ZnVuY3Rpb24oYSxiKXtpZihcIm9iamVjdFwiIT09dHlwZW9mIGEmJlwiZnVuY3Rpb25cIiE9PXR5cGVvZiBhJiZudWxsIT1hKXRocm93IEVycm9yKHooODUpKTt0aGlzLnVwZGF0ZXIuZW5xdWV1ZVNldFN0YXRlKHRoaXMsYSxiLFwic2V0U3RhdGVcIil9O0MucHJvdG90eXBlLmZvcmNlVXBkYXRlPWZ1bmN0aW9uKGEpe3RoaXMudXBkYXRlci5lbnF1ZXVlRm9yY2VVcGRhdGUodGhpcyxhLFwiZm9yY2VVcGRhdGVcIil9O1xuZnVuY3Rpb24gRCgpe31ELnByb3RvdHlwZT1DLnByb3RvdHlwZTtmdW5jdGlvbiBFKGEsYixjKXt0aGlzLnByb3BzPWE7dGhpcy5jb250ZXh0PWI7dGhpcy5yZWZzPUI7dGhpcy51cGRhdGVyPWN8fEF9dmFyIEY9RS5wcm90b3R5cGU9bmV3IEQ7Ri5jb25zdHJ1Y3Rvcj1FO2woRixDLnByb3RvdHlwZSk7Ri5pc1B1cmVSZWFjdENvbXBvbmVudD0hMDt2YXIgRz17Y3VycmVudDpudWxsfSxIPU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHksST17a2V5OiEwLHJlZjohMCxfX3NlbGY6ITAsX19zb3VyY2U6ITB9O1xuZnVuY3Rpb24gSihhLGIsYyl7dmFyIGUsZD17fSxrPW51bGwsaD1udWxsO2lmKG51bGwhPWIpZm9yKGUgaW4gdm9pZCAwIT09Yi5yZWYmJihoPWIucmVmKSx2b2lkIDAhPT1iLmtleSYmKGs9XCJcIitiLmtleSksYilILmNhbGwoYixlKSYmIUkuaGFzT3duUHJvcGVydHkoZSkmJihkW2VdPWJbZV0pO3ZhciBnPWFyZ3VtZW50cy5sZW5ndGgtMjtpZigxPT09ZylkLmNoaWxkcmVuPWM7ZWxzZSBpZigxPGcpe2Zvcih2YXIgZj1BcnJheShnKSxtPTA7bTxnO20rKylmW21dPWFyZ3VtZW50c1ttKzJdO2QuY2hpbGRyZW49Zn1pZihhJiZhLmRlZmF1bHRQcm9wcylmb3IoZSBpbiBnPWEuZGVmYXVsdFByb3BzLGcpdm9pZCAwPT09ZFtlXSYmKGRbZV09Z1tlXSk7cmV0dXJueyQkdHlwZW9mOm4sdHlwZTphLGtleTprLHJlZjpoLHByb3BzOmQsX293bmVyOkcuY3VycmVudH19XG5mdW5jdGlvbiBLKGEsYil7cmV0dXJueyQkdHlwZW9mOm4sdHlwZTphLnR5cGUsa2V5OmIscmVmOmEucmVmLHByb3BzOmEucHJvcHMsX293bmVyOmEuX293bmVyfX1mdW5jdGlvbiBMKGEpe3JldHVyblwib2JqZWN0XCI9PT10eXBlb2YgYSYmbnVsbCE9PWEmJmEuJCR0eXBlb2Y9PT1ufWZ1bmN0aW9uIGVzY2FwZShhKXt2YXIgYj17XCI9XCI6XCI9MFwiLFwiOlwiOlwiPTJcIn07cmV0dXJuXCIkXCIrYS5yZXBsYWNlKC9bPTpdL2csZnVuY3Rpb24oYSl7cmV0dXJuIGJbYV19KX12YXIgTT0vXFwvKy9nO2Z1bmN0aW9uIE4oYSxiKXtyZXR1cm5cIm9iamVjdFwiPT09dHlwZW9mIGEmJm51bGwhPT1hJiZudWxsIT1hLmtleT9lc2NhcGUoXCJcIithLmtleSk6Yi50b1N0cmluZygzNil9XG5mdW5jdGlvbiBPKGEsYixjLGUsZCl7dmFyIGs9dHlwZW9mIGE7aWYoXCJ1bmRlZmluZWRcIj09PWt8fFwiYm9vbGVhblwiPT09aylhPW51bGw7dmFyIGg9ITE7aWYobnVsbD09PWEpaD0hMDtlbHNlIHN3aXRjaChrKXtjYXNlIFwic3RyaW5nXCI6Y2FzZSBcIm51bWJlclwiOmg9ITA7YnJlYWs7Y2FzZSBcIm9iamVjdFwiOnN3aXRjaChhLiQkdHlwZW9mKXtjYXNlIG46Y2FzZSBwOmg9ITB9fWlmKGgpcmV0dXJuIGg9YSxkPWQoaCksYT1cIlwiPT09ZT9cIi5cIitOKGgsMCk6ZSxBcnJheS5pc0FycmF5KGQpPyhjPVwiXCIsbnVsbCE9YSYmKGM9YS5yZXBsYWNlKE0sXCIkJi9cIikrXCIvXCIpLE8oZCxiLGMsXCJcIixmdW5jdGlvbihhKXtyZXR1cm4gYX0pKTpudWxsIT1kJiYoTChkKSYmKGQ9SyhkLGMrKCFkLmtleXx8aCYmaC5rZXk9PT1kLmtleT9cIlwiOihcIlwiK2Qua2V5KS5yZXBsYWNlKE0sXCIkJi9cIikrXCIvXCIpK2EpKSxiLnB1c2goZCkpLDE7aD0wO2U9XCJcIj09PWU/XCIuXCI6ZStcIjpcIjtpZihBcnJheS5pc0FycmF5KGEpKWZvcih2YXIgZz1cbjA7ZzxhLmxlbmd0aDtnKyspe2s9YVtnXTt2YXIgZj1lK04oayxnKTtoKz1PKGssYixjLGYsZCl9ZWxzZSBpZihmPXkoYSksXCJmdW5jdGlvblwiPT09dHlwZW9mIGYpZm9yKGE9Zi5jYWxsKGEpLGc9MDshKGs9YS5uZXh0KCkpLmRvbmU7KWs9ay52YWx1ZSxmPWUrTihrLGcrKyksaCs9TyhrLGIsYyxmLGQpO2Vsc2UgaWYoXCJvYmplY3RcIj09PWspdGhyb3cgYj1cIlwiK2EsRXJyb3IoeigzMSxcIltvYmplY3QgT2JqZWN0XVwiPT09Yj9cIm9iamVjdCB3aXRoIGtleXMge1wiK09iamVjdC5rZXlzKGEpLmpvaW4oXCIsIFwiKStcIn1cIjpiKSk7cmV0dXJuIGh9ZnVuY3Rpb24gUChhLGIsYyl7aWYobnVsbD09YSlyZXR1cm4gYTt2YXIgZT1bXSxkPTA7TyhhLGUsXCJcIixcIlwiLGZ1bmN0aW9uKGEpe3JldHVybiBiLmNhbGwoYyxhLGQrKyl9KTtyZXR1cm4gZX1cbmZ1bmN0aW9uIFEoYSl7aWYoLTE9PT1hLl9zdGF0dXMpe3ZhciBiPWEuX3Jlc3VsdDtiPWIoKTthLl9zdGF0dXM9MDthLl9yZXN1bHQ9YjtiLnRoZW4oZnVuY3Rpb24oYil7MD09PWEuX3N0YXR1cyYmKGI9Yi5kZWZhdWx0LGEuX3N0YXR1cz0xLGEuX3Jlc3VsdD1iKX0sZnVuY3Rpb24oYil7MD09PWEuX3N0YXR1cyYmKGEuX3N0YXR1cz0yLGEuX3Jlc3VsdD1iKX0pfWlmKDE9PT1hLl9zdGF0dXMpcmV0dXJuIGEuX3Jlc3VsdDt0aHJvdyBhLl9yZXN1bHQ7fXZhciBSPXtjdXJyZW50Om51bGx9O2Z1bmN0aW9uIFMoKXt2YXIgYT1SLmN1cnJlbnQ7aWYobnVsbD09PWEpdGhyb3cgRXJyb3IoeigzMjEpKTtyZXR1cm4gYX12YXIgVD17UmVhY3RDdXJyZW50RGlzcGF0Y2hlcjpSLFJlYWN0Q3VycmVudEJhdGNoQ29uZmlnOnt0cmFuc2l0aW9uOjB9LFJlYWN0Q3VycmVudE93bmVyOkcsSXNTb21lUmVuZGVyZXJBY3Rpbmc6e2N1cnJlbnQ6ITF9LGFzc2lnbjpsfTtcbmV4cG9ydHMuQ2hpbGRyZW49e21hcDpQLGZvckVhY2g6ZnVuY3Rpb24oYSxiLGMpe1AoYSxmdW5jdGlvbigpe2IuYXBwbHkodGhpcyxhcmd1bWVudHMpfSxjKX0sY291bnQ6ZnVuY3Rpb24oYSl7dmFyIGI9MDtQKGEsZnVuY3Rpb24oKXtiKyt9KTtyZXR1cm4gYn0sdG9BcnJheTpmdW5jdGlvbihhKXtyZXR1cm4gUChhLGZ1bmN0aW9uKGEpe3JldHVybiBhfSl8fFtdfSxvbmx5OmZ1bmN0aW9uKGEpe2lmKCFMKGEpKXRocm93IEVycm9yKHooMTQzKSk7cmV0dXJuIGF9fTtleHBvcnRzLkNvbXBvbmVudD1DO2V4cG9ydHMuUHVyZUNvbXBvbmVudD1FO2V4cG9ydHMuX19TRUNSRVRfSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfWU9VX1dJTExfQkVfRklSRUQ9VDtcbmV4cG9ydHMuY2xvbmVFbGVtZW50PWZ1bmN0aW9uKGEsYixjKXtpZihudWxsPT09YXx8dm9pZCAwPT09YSl0aHJvdyBFcnJvcih6KDI2NyxhKSk7dmFyIGU9bCh7fSxhLnByb3BzKSxkPWEua2V5LGs9YS5yZWYsaD1hLl9vd25lcjtpZihudWxsIT1iKXt2b2lkIDAhPT1iLnJlZiYmKGs9Yi5yZWYsaD1HLmN1cnJlbnQpO3ZvaWQgMCE9PWIua2V5JiYoZD1cIlwiK2Iua2V5KTtpZihhLnR5cGUmJmEudHlwZS5kZWZhdWx0UHJvcHMpdmFyIGc9YS50eXBlLmRlZmF1bHRQcm9wcztmb3IoZiBpbiBiKUguY2FsbChiLGYpJiYhSS5oYXNPd25Qcm9wZXJ0eShmKSYmKGVbZl09dm9pZCAwPT09YltmXSYmdm9pZCAwIT09Zz9nW2ZdOmJbZl0pfXZhciBmPWFyZ3VtZW50cy5sZW5ndGgtMjtpZigxPT09ZillLmNoaWxkcmVuPWM7ZWxzZSBpZigxPGYpe2c9QXJyYXkoZik7Zm9yKHZhciBtPTA7bTxmO20rKylnW21dPWFyZ3VtZW50c1ttKzJdO2UuY2hpbGRyZW49Z31yZXR1cm57JCR0eXBlb2Y6bix0eXBlOmEudHlwZSxcbmtleTpkLHJlZjprLHByb3BzOmUsX293bmVyOmh9fTtleHBvcnRzLmNyZWF0ZUNvbnRleHQ9ZnVuY3Rpb24oYSxiKXt2b2lkIDA9PT1iJiYoYj1udWxsKTthPXskJHR5cGVvZjpyLF9jYWxjdWxhdGVDaGFuZ2VkQml0czpiLF9jdXJyZW50VmFsdWU6YSxfY3VycmVudFZhbHVlMjphLF90aHJlYWRDb3VudDowLFByb3ZpZGVyOm51bGwsQ29uc3VtZXI6bnVsbH07YS5Qcm92aWRlcj17JCR0eXBlb2Y6cSxfY29udGV4dDphfTtyZXR1cm4gYS5Db25zdW1lcj1hfTtleHBvcnRzLmNyZWF0ZUVsZW1lbnQ9SjtleHBvcnRzLmNyZWF0ZUZhY3Rvcnk9ZnVuY3Rpb24oYSl7dmFyIGI9Si5iaW5kKG51bGwsYSk7Yi50eXBlPWE7cmV0dXJuIGJ9O2V4cG9ydHMuY3JlYXRlUmVmPWZ1bmN0aW9uKCl7cmV0dXJue2N1cnJlbnQ6bnVsbH19O2V4cG9ydHMuZm9yd2FyZFJlZj1mdW5jdGlvbihhKXtyZXR1cm57JCR0eXBlb2Y6dCxyZW5kZXI6YX19O2V4cG9ydHMuaXNWYWxpZEVsZW1lbnQ9TDtcbmV4cG9ydHMubGF6eT1mdW5jdGlvbihhKXtyZXR1cm57JCR0eXBlb2Y6dixfcGF5bG9hZDp7X3N0YXR1czotMSxfcmVzdWx0OmF9LF9pbml0OlF9fTtleHBvcnRzLm1lbW89ZnVuY3Rpb24oYSxiKXtyZXR1cm57JCR0eXBlb2Y6dSx0eXBlOmEsY29tcGFyZTp2b2lkIDA9PT1iP251bGw6Yn19O2V4cG9ydHMudXNlQ2FsbGJhY2s9ZnVuY3Rpb24oYSxiKXtyZXR1cm4gUygpLnVzZUNhbGxiYWNrKGEsYil9O2V4cG9ydHMudXNlQ29udGV4dD1mdW5jdGlvbihhLGIpe3JldHVybiBTKCkudXNlQ29udGV4dChhLGIpfTtleHBvcnRzLnVzZURlYnVnVmFsdWU9ZnVuY3Rpb24oKXt9O2V4cG9ydHMudXNlRWZmZWN0PWZ1bmN0aW9uKGEsYil7cmV0dXJuIFMoKS51c2VFZmZlY3QoYSxiKX07ZXhwb3J0cy51c2VJbXBlcmF0aXZlSGFuZGxlPWZ1bmN0aW9uKGEsYixjKXtyZXR1cm4gUygpLnVzZUltcGVyYXRpdmVIYW5kbGUoYSxiLGMpfTtcbmV4cG9ydHMudXNlTGF5b3V0RWZmZWN0PWZ1bmN0aW9uKGEsYil7cmV0dXJuIFMoKS51c2VMYXlvdXRFZmZlY3QoYSxiKX07ZXhwb3J0cy51c2VNZW1vPWZ1bmN0aW9uKGEsYil7cmV0dXJuIFMoKS51c2VNZW1vKGEsYil9O2V4cG9ydHMudXNlUmVkdWNlcj1mdW5jdGlvbihhLGIsYyl7cmV0dXJuIFMoKS51c2VSZWR1Y2VyKGEsYixjKX07ZXhwb3J0cy51c2VSZWY9ZnVuY3Rpb24oYSl7cmV0dXJuIFMoKS51c2VSZWYoYSl9O2V4cG9ydHMudXNlU3RhdGU9ZnVuY3Rpb24oYSl7cmV0dXJuIFMoKS51c2VTdGF0ZShhKX07ZXhwb3J0cy52ZXJzaW9uPVwiMTcuMC4yXCI7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///408\n')},294:(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("\n\nif (true) {\n  module.exports = __webpack_require__(408);\n} else {}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjk0LmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLElBQUksSUFBcUM7QUFDekMsRUFBRSx5Q0FBeUQ7QUFDM0QsRUFBRSxLQUFLLEVBRU4iLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9ub2RlX21vZHVsZXMvcmVhY3QvaW5kZXguanM/YWI1YiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QucHJvZHVjdGlvbi5taW4uanMnKTtcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QuZGV2ZWxvcG1lbnQuanMnKTtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///294\n")},893:(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("\n\nif (true) {\n  module.exports = __webpack_require__(251);\n} else {}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODkzLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLElBQUksSUFBcUM7QUFDekMsRUFBRSx5Q0FBcUU7QUFDdkUsRUFBRSxLQUFLLEVBRU4iLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9ub2RlX21vZHVsZXMvcmVhY3QvanN4LXJ1bnRpbWUuanM/OWNhNSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtanN4LXJ1bnRpbWUucHJvZHVjdGlvbi5taW4uanMnKTtcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtanN4LXJ1bnRpbWUuZGV2ZWxvcG1lbnQuanMnKTtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///893\n")},53:(__unused_webpack_module,exports)=>{"use strict";eval('/** @license React v0.20.2\n * scheduler.production.min.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nvar f,g,h,k;if("object"===typeof performance&&"function"===typeof performance.now){var l=performance;exports.unstable_now=function(){return l.now()}}else{var p=Date,q=p.now();exports.unstable_now=function(){return p.now()-q}}\nif("undefined"===typeof window||"function"!==typeof MessageChannel){var t=null,u=null,w=function(){if(null!==t)try{var a=exports.unstable_now();t(!0,a);t=null}catch(b){throw setTimeout(w,0),b;}};f=function(a){null!==t?setTimeout(f,0,a):(t=a,setTimeout(w,0))};g=function(a,b){u=setTimeout(a,b)};h=function(){clearTimeout(u)};exports.unstable_shouldYield=function(){return!1};k=exports.unstable_forceFrameRate=function(){}}else{var x=window.setTimeout,y=window.clearTimeout;if("undefined"!==typeof console){var z=\nwindow.cancelAnimationFrame;"function"!==typeof window.requestAnimationFrame&&console.error("This browser doesn\'t support requestAnimationFrame. Make sure that you load a polyfill in older browsers. https://reactjs.org/link/react-polyfills");"function"!==typeof z&&console.error("This browser doesn\'t support cancelAnimationFrame. Make sure that you load a polyfill in older browsers. https://reactjs.org/link/react-polyfills")}var A=!1,B=null,C=-1,D=5,E=0;exports.unstable_shouldYield=function(){return exports.unstable_now()>=\nE};k=function(){};exports.unstable_forceFrameRate=function(a){0>a||125<a?console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"):D=0<a?Math.floor(1E3/a):5};var F=new MessageChannel,G=F.port2;F.port1.onmessage=function(){if(null!==B){var a=exports.unstable_now();E=a+D;try{B(!0,a)?G.postMessage(null):(A=!1,B=null)}catch(b){throw G.postMessage(null),b;}}else A=!1};f=function(a){B=a;A||(A=!0,G.postMessage(null))};g=function(a,b){C=\nx(function(){a(exports.unstable_now())},b)};h=function(){y(C);C=-1}}function H(a,b){var c=a.length;a.push(b);a:for(;;){var d=c-1>>>1,e=a[d];if(void 0!==e&&0<I(e,b))a[d]=b,a[c]=e,c=d;else break a}}function J(a){a=a[0];return void 0===a?null:a}\nfunction K(a){var b=a[0];if(void 0!==b){var c=a.pop();if(c!==b){a[0]=c;a:for(var d=0,e=a.length;d<e;){var m=2*(d+1)-1,n=a[m],v=m+1,r=a[v];if(void 0!==n&&0>I(n,c))void 0!==r&&0>I(r,n)?(a[d]=r,a[v]=c,d=v):(a[d]=n,a[m]=c,d=m);else if(void 0!==r&&0>I(r,c))a[d]=r,a[v]=c,d=v;else break a}}return b}return null}function I(a,b){var c=a.sortIndex-b.sortIndex;return 0!==c?c:a.id-b.id}var L=[],M=[],N=1,O=null,P=3,Q=!1,R=!1,S=!1;\nfunction T(a){for(var b=J(M);null!==b;){if(null===b.callback)K(M);else if(b.startTime<=a)K(M),b.sortIndex=b.expirationTime,H(L,b);else break;b=J(M)}}function U(a){S=!1;T(a);if(!R)if(null!==J(L))R=!0,f(V);else{var b=J(M);null!==b&&g(U,b.startTime-a)}}\nfunction V(a,b){R=!1;S&&(S=!1,h());Q=!0;var c=P;try{T(b);for(O=J(L);null!==O&&(!(O.expirationTime>b)||a&&!exports.unstable_shouldYield());){var d=O.callback;if("function"===typeof d){O.callback=null;P=O.priorityLevel;var e=d(O.expirationTime<=b);b=exports.unstable_now();"function"===typeof e?O.callback=e:O===J(L)&&K(L);T(b)}else K(L);O=J(L)}if(null!==O)var m=!0;else{var n=J(M);null!==n&&g(U,n.startTime-b);m=!1}return m}finally{O=null,P=c,Q=!1}}var W=k;exports.unstable_IdlePriority=5;\nexports.unstable_ImmediatePriority=1;exports.unstable_LowPriority=4;exports.unstable_NormalPriority=3;exports.unstable_Profiling=null;exports.unstable_UserBlockingPriority=2;exports.unstable_cancelCallback=function(a){a.callback=null};exports.unstable_continueExecution=function(){R||Q||(R=!0,f(V))};exports.unstable_getCurrentPriorityLevel=function(){return P};exports.unstable_getFirstCallbackNode=function(){return J(L)};\nexports.unstable_next=function(a){switch(P){case 1:case 2:case 3:var b=3;break;default:b=P}var c=P;P=b;try{return a()}finally{P=c}};exports.unstable_pauseExecution=function(){};exports.unstable_requestPaint=W;exports.unstable_runWithPriority=function(a,b){switch(a){case 1:case 2:case 3:case 4:case 5:break;default:a=3}var c=P;P=a;try{return b()}finally{P=c}};\nexports.unstable_scheduleCallback=function(a,b,c){var d=exports.unstable_now();"object"===typeof c&&null!==c?(c=c.delay,c="number"===typeof c&&0<c?d+c:d):c=d;switch(a){case 1:var e=-1;break;case 2:e=250;break;case 5:e=1073741823;break;case 4:e=1E4;break;default:e=5E3}e=c+e;a={id:N++,callback:b,priorityLevel:a,startTime:c,expirationTime:e,sortIndex:-1};c>d?(a.sortIndex=c,H(M,a),null===J(L)&&a===J(M)&&(S?h():S=!0,g(U,c-d))):(a.sortIndex=e,H(L,a),R||Q||(R=!0,f(V)));return a};\nexports.unstable_wrapCallback=function(a){var b=P;return function(){var c=P;P=b;try{return a.apply(this,arguments)}finally{P=c}}};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNhLFlBQVksdUVBQXVFLGtCQUFrQixvQkFBb0IsWUFBWSxnQkFBZ0IsS0FBSyxxQkFBcUIsb0JBQW9CLFlBQVk7QUFDNU4sb0VBQW9FLCtCQUErQixnQkFBZ0IsNkJBQTZCLFFBQVEsT0FBTyxTQUFTLDJCQUEyQixjQUFjLGtEQUFrRCxnQkFBZ0IsbUJBQW1CLGFBQWEsaUJBQWlCLDRCQUE0QixZQUFZLFVBQVUsRUFBRSwrQkFBK0IsY0FBYyxLQUFLLDhDQUE4QyxpQ0FBaUM7QUFDemYsNEJBQTRCLHNOQUFzTiwwTEFBMEwsNkJBQTZCLDRCQUE0QixZQUFZO0FBQ2pmLEdBQUcsZUFBZSwrQkFBK0IsYUFBYSx1S0FBdUssbUNBQW1DLDZCQUE2QixhQUFhLDZCQUE2QixNQUFNLElBQUksMENBQTBDLFNBQVMsOEJBQThCLFdBQVcsY0FBYyxJQUFJLCtCQUErQixnQkFBZ0I7QUFDdGYsYUFBYSwwQkFBMEIsS0FBSyxhQUFhLEtBQUssTUFBTSxnQkFBZ0IsZUFBZSxVQUFVLFFBQVEsRUFBRSxxQkFBcUIsMENBQTBDLGNBQWMsY0FBYyxPQUFPO0FBQ3pOLGNBQWMsV0FBVyxlQUFlLGNBQWMsVUFBVSxPQUFPLHlCQUF5QixJQUFJLEVBQUUsb0NBQW9DLHFGQUFxRiwrQ0FBK0MsY0FBYyxTQUFTLFlBQVksZ0JBQWdCLDhCQUE4Qix5QkFBeUI7QUFDeFgsY0FBYyxlQUFlLFNBQVMsRUFBRSwwQkFBMEIsZ0VBQWdFLFdBQVcsUUFBUSxjQUFjLEtBQUssS0FBSywrQkFBK0IsS0FBSyxXQUFXO0FBQzVOLGdCQUFnQixLQUFLLGNBQWMsS0FBSyxRQUFRLElBQUksS0FBSyxXQUFXLHNFQUFzRSxFQUFFLGlCQUFpQiwwQkFBMEIsZ0JBQWdCLGtCQUFrQiw2QkFBNkIseUJBQXlCLGtEQUFrRCxLQUFLLFVBQVUsT0FBTyxxQkFBcUIsS0FBSyxXQUFXLDZCQUE2QixLQUFLLFNBQVMsUUFBUSxpQkFBaUIsUUFBUSw2QkFBNkI7QUFDcmUsa0NBQWtDLEdBQUcsNEJBQTRCLEdBQUcsK0JBQStCLEdBQUcsMEJBQTBCLE1BQU0scUNBQXFDLEdBQUcsK0JBQStCLGFBQWEsaUJBQWlCLGtDQUFrQyxZQUFZLG1CQUFtQix3Q0FBd0MsWUFBWSxVQUFVLHFDQUFxQyxZQUFZO0FBQzNaLHFCQUFxQixhQUFhLFVBQVUsNkJBQTZCLE1BQU0sWUFBWSxRQUFRLElBQUksSUFBSSxXQUFXLFFBQVEsTUFBTSwrQkFBK0IsY0FBYyw2QkFBNkIsR0FBRyxnQ0FBZ0MsZUFBZSxVQUFVLHlDQUF5QyxZQUFZLFFBQVEsSUFBSSxJQUFJLFdBQVcsUUFBUTtBQUNsVyxpQ0FBaUMsaUJBQWlCLDZCQUE2QiwrRUFBK0UsVUFBVSxnQkFBZ0IsTUFBTSxhQUFhLE1BQU0sb0JBQW9CLE1BQU0sYUFBYSxNQUFNLGNBQWMsTUFBTSxHQUFHLDZFQUE2RSxpSEFBaUg7QUFDbmQsNkJBQTZCLGFBQWEsUUFBUSxrQkFBa0IsUUFBUSxJQUFJLElBQUksK0JBQStCLFFBQVEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9ub2RlX21vZHVsZXMvc2NoZWR1bGVyL2Nqcy9zY2hlZHVsZXIucHJvZHVjdGlvbi5taW4uanM/ZmIwNyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiogQGxpY2Vuc2UgUmVhY3QgdjAuMjAuMlxuICogc2NoZWR1bGVyLnByb2R1Y3Rpb24ubWluLmpzXG4gKlxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cbid1c2Ugc3RyaWN0Jzt2YXIgZixnLGgsaztpZihcIm9iamVjdFwiPT09dHlwZW9mIHBlcmZvcm1hbmNlJiZcImZ1bmN0aW9uXCI9PT10eXBlb2YgcGVyZm9ybWFuY2Uubm93KXt2YXIgbD1wZXJmb3JtYW5jZTtleHBvcnRzLnVuc3RhYmxlX25vdz1mdW5jdGlvbigpe3JldHVybiBsLm5vdygpfX1lbHNle3ZhciBwPURhdGUscT1wLm5vdygpO2V4cG9ydHMudW5zdGFibGVfbm93PWZ1bmN0aW9uKCl7cmV0dXJuIHAubm93KCktcX19XG5pZihcInVuZGVmaW5lZFwiPT09dHlwZW9mIHdpbmRvd3x8XCJmdW5jdGlvblwiIT09dHlwZW9mIE1lc3NhZ2VDaGFubmVsKXt2YXIgdD1udWxsLHU9bnVsbCx3PWZ1bmN0aW9uKCl7aWYobnVsbCE9PXQpdHJ5e3ZhciBhPWV4cG9ydHMudW5zdGFibGVfbm93KCk7dCghMCxhKTt0PW51bGx9Y2F0Y2goYil7dGhyb3cgc2V0VGltZW91dCh3LDApLGI7fX07Zj1mdW5jdGlvbihhKXtudWxsIT09dD9zZXRUaW1lb3V0KGYsMCxhKToodD1hLHNldFRpbWVvdXQodywwKSl9O2c9ZnVuY3Rpb24oYSxiKXt1PXNldFRpbWVvdXQoYSxiKX07aD1mdW5jdGlvbigpe2NsZWFyVGltZW91dCh1KX07ZXhwb3J0cy51bnN0YWJsZV9zaG91bGRZaWVsZD1mdW5jdGlvbigpe3JldHVybiExfTtrPWV4cG9ydHMudW5zdGFibGVfZm9yY2VGcmFtZVJhdGU9ZnVuY3Rpb24oKXt9fWVsc2V7dmFyIHg9d2luZG93LnNldFRpbWVvdXQseT13aW5kb3cuY2xlYXJUaW1lb3V0O2lmKFwidW5kZWZpbmVkXCIhPT10eXBlb2YgY29uc29sZSl7dmFyIHo9XG53aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWU7XCJmdW5jdGlvblwiIT09dHlwZW9mIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUmJmNvbnNvbGUuZXJyb3IoXCJUaGlzIGJyb3dzZXIgZG9lc24ndCBzdXBwb3J0IHJlcXVlc3RBbmltYXRpb25GcmFtZS4gTWFrZSBzdXJlIHRoYXQgeW91IGxvYWQgYSBwb2x5ZmlsbCBpbiBvbGRlciBicm93c2Vycy4gaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3JlYWN0LXBvbHlmaWxsc1wiKTtcImZ1bmN0aW9uXCIhPT10eXBlb2YgeiYmY29uc29sZS5lcnJvcihcIlRoaXMgYnJvd3NlciBkb2Vzbid0IHN1cHBvcnQgY2FuY2VsQW5pbWF0aW9uRnJhbWUuIE1ha2Ugc3VyZSB0aGF0IHlvdSBsb2FkIGEgcG9seWZpbGwgaW4gb2xkZXIgYnJvd3NlcnMuIGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9yZWFjdC1wb2x5ZmlsbHNcIil9dmFyIEE9ITEsQj1udWxsLEM9LTEsRD01LEU9MDtleHBvcnRzLnVuc3RhYmxlX3Nob3VsZFlpZWxkPWZ1bmN0aW9uKCl7cmV0dXJuIGV4cG9ydHMudW5zdGFibGVfbm93KCk+PVxuRX07az1mdW5jdGlvbigpe307ZXhwb3J0cy51bnN0YWJsZV9mb3JjZUZyYW1lUmF0ZT1mdW5jdGlvbihhKXswPmF8fDEyNTxhP2NvbnNvbGUuZXJyb3IoXCJmb3JjZUZyYW1lUmF0ZSB0YWtlcyBhIHBvc2l0aXZlIGludCBiZXR3ZWVuIDAgYW5kIDEyNSwgZm9yY2luZyBmcmFtZSByYXRlcyBoaWdoZXIgdGhhbiAxMjUgZnBzIGlzIG5vdCBzdXBwb3J0ZWRcIik6RD0wPGE/TWF0aC5mbG9vcigxRTMvYSk6NX07dmFyIEY9bmV3IE1lc3NhZ2VDaGFubmVsLEc9Ri5wb3J0MjtGLnBvcnQxLm9ubWVzc2FnZT1mdW5jdGlvbigpe2lmKG51bGwhPT1CKXt2YXIgYT1leHBvcnRzLnVuc3RhYmxlX25vdygpO0U9YStEO3RyeXtCKCEwLGEpP0cucG9zdE1lc3NhZ2UobnVsbCk6KEE9ITEsQj1udWxsKX1jYXRjaChiKXt0aHJvdyBHLnBvc3RNZXNzYWdlKG51bGwpLGI7fX1lbHNlIEE9ITF9O2Y9ZnVuY3Rpb24oYSl7Qj1hO0F8fChBPSEwLEcucG9zdE1lc3NhZ2UobnVsbCkpfTtnPWZ1bmN0aW9uKGEsYil7Qz1cbngoZnVuY3Rpb24oKXthKGV4cG9ydHMudW5zdGFibGVfbm93KCkpfSxiKX07aD1mdW5jdGlvbigpe3koQyk7Qz0tMX19ZnVuY3Rpb24gSChhLGIpe3ZhciBjPWEubGVuZ3RoO2EucHVzaChiKTthOmZvcig7Oyl7dmFyIGQ9Yy0xPj4+MSxlPWFbZF07aWYodm9pZCAwIT09ZSYmMDxJKGUsYikpYVtkXT1iLGFbY109ZSxjPWQ7ZWxzZSBicmVhayBhfX1mdW5jdGlvbiBKKGEpe2E9YVswXTtyZXR1cm4gdm9pZCAwPT09YT9udWxsOmF9XG5mdW5jdGlvbiBLKGEpe3ZhciBiPWFbMF07aWYodm9pZCAwIT09Yil7dmFyIGM9YS5wb3AoKTtpZihjIT09Yil7YVswXT1jO2E6Zm9yKHZhciBkPTAsZT1hLmxlbmd0aDtkPGU7KXt2YXIgbT0yKihkKzEpLTEsbj1hW21dLHY9bSsxLHI9YVt2XTtpZih2b2lkIDAhPT1uJiYwPkkobixjKSl2b2lkIDAhPT1yJiYwPkkocixuKT8oYVtkXT1yLGFbdl09YyxkPXYpOihhW2RdPW4sYVttXT1jLGQ9bSk7ZWxzZSBpZih2b2lkIDAhPT1yJiYwPkkocixjKSlhW2RdPXIsYVt2XT1jLGQ9djtlbHNlIGJyZWFrIGF9fXJldHVybiBifXJldHVybiBudWxsfWZ1bmN0aW9uIEkoYSxiKXt2YXIgYz1hLnNvcnRJbmRleC1iLnNvcnRJbmRleDtyZXR1cm4gMCE9PWM/YzphLmlkLWIuaWR9dmFyIEw9W10sTT1bXSxOPTEsTz1udWxsLFA9MyxRPSExLFI9ITEsUz0hMTtcbmZ1bmN0aW9uIFQoYSl7Zm9yKHZhciBiPUooTSk7bnVsbCE9PWI7KXtpZihudWxsPT09Yi5jYWxsYmFjaylLKE0pO2Vsc2UgaWYoYi5zdGFydFRpbWU8PWEpSyhNKSxiLnNvcnRJbmRleD1iLmV4cGlyYXRpb25UaW1lLEgoTCxiKTtlbHNlIGJyZWFrO2I9SihNKX19ZnVuY3Rpb24gVShhKXtTPSExO1QoYSk7aWYoIVIpaWYobnVsbCE9PUooTCkpUj0hMCxmKFYpO2Vsc2V7dmFyIGI9SihNKTtudWxsIT09YiYmZyhVLGIuc3RhcnRUaW1lLWEpfX1cbmZ1bmN0aW9uIFYoYSxiKXtSPSExO1MmJihTPSExLGgoKSk7UT0hMDt2YXIgYz1QO3RyeXtUKGIpO2ZvcihPPUooTCk7bnVsbCE9PU8mJighKE8uZXhwaXJhdGlvblRpbWU+Yil8fGEmJiFleHBvcnRzLnVuc3RhYmxlX3Nob3VsZFlpZWxkKCkpOyl7dmFyIGQ9Ty5jYWxsYmFjaztpZihcImZ1bmN0aW9uXCI9PT10eXBlb2YgZCl7Ty5jYWxsYmFjaz1udWxsO1A9Ty5wcmlvcml0eUxldmVsO3ZhciBlPWQoTy5leHBpcmF0aW9uVGltZTw9Yik7Yj1leHBvcnRzLnVuc3RhYmxlX25vdygpO1wiZnVuY3Rpb25cIj09PXR5cGVvZiBlP08uY2FsbGJhY2s9ZTpPPT09SihMKSYmSyhMKTtUKGIpfWVsc2UgSyhMKTtPPUooTCl9aWYobnVsbCE9PU8pdmFyIG09ITA7ZWxzZXt2YXIgbj1KKE0pO251bGwhPT1uJiZnKFUsbi5zdGFydFRpbWUtYik7bT0hMX1yZXR1cm4gbX1maW5hbGx5e089bnVsbCxQPWMsUT0hMX19dmFyIFc9aztleHBvcnRzLnVuc3RhYmxlX0lkbGVQcmlvcml0eT01O1xuZXhwb3J0cy51bnN0YWJsZV9JbW1lZGlhdGVQcmlvcml0eT0xO2V4cG9ydHMudW5zdGFibGVfTG93UHJpb3JpdHk9NDtleHBvcnRzLnVuc3RhYmxlX05vcm1hbFByaW9yaXR5PTM7ZXhwb3J0cy51bnN0YWJsZV9Qcm9maWxpbmc9bnVsbDtleHBvcnRzLnVuc3RhYmxlX1VzZXJCbG9ja2luZ1ByaW9yaXR5PTI7ZXhwb3J0cy51bnN0YWJsZV9jYW5jZWxDYWxsYmFjaz1mdW5jdGlvbihhKXthLmNhbGxiYWNrPW51bGx9O2V4cG9ydHMudW5zdGFibGVfY29udGludWVFeGVjdXRpb249ZnVuY3Rpb24oKXtSfHxRfHwoUj0hMCxmKFYpKX07ZXhwb3J0cy51bnN0YWJsZV9nZXRDdXJyZW50UHJpb3JpdHlMZXZlbD1mdW5jdGlvbigpe3JldHVybiBQfTtleHBvcnRzLnVuc3RhYmxlX2dldEZpcnN0Q2FsbGJhY2tOb2RlPWZ1bmN0aW9uKCl7cmV0dXJuIEooTCl9O1xuZXhwb3J0cy51bnN0YWJsZV9uZXh0PWZ1bmN0aW9uKGEpe3N3aXRjaChQKXtjYXNlIDE6Y2FzZSAyOmNhc2UgMzp2YXIgYj0zO2JyZWFrO2RlZmF1bHQ6Yj1QfXZhciBjPVA7UD1iO3RyeXtyZXR1cm4gYSgpfWZpbmFsbHl7UD1jfX07ZXhwb3J0cy51bnN0YWJsZV9wYXVzZUV4ZWN1dGlvbj1mdW5jdGlvbigpe307ZXhwb3J0cy51bnN0YWJsZV9yZXF1ZXN0UGFpbnQ9VztleHBvcnRzLnVuc3RhYmxlX3J1bldpdGhQcmlvcml0eT1mdW5jdGlvbihhLGIpe3N3aXRjaChhKXtjYXNlIDE6Y2FzZSAyOmNhc2UgMzpjYXNlIDQ6Y2FzZSA1OmJyZWFrO2RlZmF1bHQ6YT0zfXZhciBjPVA7UD1hO3RyeXtyZXR1cm4gYigpfWZpbmFsbHl7UD1jfX07XG5leHBvcnRzLnVuc3RhYmxlX3NjaGVkdWxlQ2FsbGJhY2s9ZnVuY3Rpb24oYSxiLGMpe3ZhciBkPWV4cG9ydHMudW5zdGFibGVfbm93KCk7XCJvYmplY3RcIj09PXR5cGVvZiBjJiZudWxsIT09Yz8oYz1jLmRlbGF5LGM9XCJudW1iZXJcIj09PXR5cGVvZiBjJiYwPGM/ZCtjOmQpOmM9ZDtzd2l0Y2goYSl7Y2FzZSAxOnZhciBlPS0xO2JyZWFrO2Nhc2UgMjplPTI1MDticmVhaztjYXNlIDU6ZT0xMDczNzQxODIzO2JyZWFrO2Nhc2UgNDplPTFFNDticmVhaztkZWZhdWx0OmU9NUUzfWU9YytlO2E9e2lkOk4rKyxjYWxsYmFjazpiLHByaW9yaXR5TGV2ZWw6YSxzdGFydFRpbWU6YyxleHBpcmF0aW9uVGltZTplLHNvcnRJbmRleDotMX07Yz5kPyhhLnNvcnRJbmRleD1jLEgoTSxhKSxudWxsPT09SihMKSYmYT09PUooTSkmJihTP2goKTpTPSEwLGcoVSxjLWQpKSk6KGEuc29ydEluZGV4PWUsSChMLGEpLFJ8fFF8fChSPSEwLGYoVikpKTtyZXR1cm4gYX07XG5leHBvcnRzLnVuc3RhYmxlX3dyYXBDYWxsYmFjaz1mdW5jdGlvbihhKXt2YXIgYj1QO3JldHVybiBmdW5jdGlvbigpe3ZhciBjPVA7UD1iO3RyeXtyZXR1cm4gYS5hcHBseSh0aGlzLGFyZ3VtZW50cyl9ZmluYWxseXtQPWN9fX07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///53\n')},840:(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("\n\nif (true) {\n  module.exports = __webpack_require__(53);\n} else {}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODQwLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLElBQUksSUFBcUM7QUFDekMsRUFBRSx3Q0FBNkQ7QUFDL0QsRUFBRSxLQUFLLEVBRU4iLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9ub2RlX21vZHVsZXMvc2NoZWR1bGVyL2luZGV4LmpzPzQwMjkiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJykge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3NjaGVkdWxlci5wcm9kdWN0aW9uLm1pbi5qcycpO1xufSBlbHNlIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9zY2hlZHVsZXIuZGV2ZWxvcG1lbnQuanMnKTtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///840\n")},996:e=>{"use strict";e.exports="# MDC React\r\n\r\n[Material Components Web](https://github.com/material-components/material-components-web) implemented in React.\r\n\r\n## Setup\r\n\r\nInstall the library using npm:\r\n\r\n```sh\r\nnpm i mdc-react\r\n```\r\n\r\nIf you plan on using the Sass files, you'll also need to install `sass`:\r\n\r\n```sh\r\nnpm i -D sass\r\n```\r\n\r\n> **NOTE**: MDC React (as well as MDC Web) uses the new [Sass Module System](https://sass-lang.com/blog/the-module-system-is-launched). Unfortunately at this time the `node-sass` implementation does not support it. Please use the `sass` library.\r\n\r\n## Usage\r\n\r\n### JS\r\n\r\nTo use the components just import what you need from the library:\r\n\r\n```jsx\r\nimport { Button } from 'mdc-react';\r\n\r\nconst App = () => {\r\n    return (\r\n        <div>\r\n            <Button>Click me!</Button>\r\n        </div>\r\n    );\r\n};\r\n```\r\n\r\nAlternatively you can import only the components you need:\r\n\r\n```jsx\r\nimport Button from 'mdc-react/button';\r\nimport Typography from 'mdc-react/typography';\r\n\r\nconst App = () => {\r\n    return (\r\n        <div>\r\n            <Typography>Hello world!</Typography>\r\n            <Button>Click me!</Button>\r\n        </div>\r\n    );\r\n};\r\n```\r\n\r\n### Sass\r\n\r\nYou can use all the styles:\r\n\r\n```scss\r\n@use 'path-to-node_modules/mdc-react';\r\n```\r\n\r\nor only the ones you need:\r\n\r\n```scss\r\n@use 'path-to-node_modules/mdc-react/src/button';\r\n@use 'path-to-node_modules/mdc-react/src/typography';\r\n```"},390:module=>{eval("var deepFreezeEs6 = {exports: {}};\n\nfunction deepFreeze(obj) {\n    if (obj instanceof Map) {\n        obj.clear = obj.delete = obj.set = function () {\n            throw new Error('map is read-only');\n        };\n    } else if (obj instanceof Set) {\n        obj.add = obj.clear = obj.delete = function () {\n            throw new Error('set is read-only');\n        };\n    }\n\n    // Freeze self\n    Object.freeze(obj);\n\n    Object.getOwnPropertyNames(obj).forEach(function (name) {\n        var prop = obj[name];\n\n        // Freeze prop if it is an object\n        if (typeof prop == 'object' && !Object.isFrozen(prop)) {\n            deepFreeze(prop);\n        }\n    });\n\n    return obj;\n}\n\ndeepFreezeEs6.exports = deepFreeze;\ndeepFreezeEs6.exports.default = deepFreeze;\n\nvar deepFreeze$1 = deepFreezeEs6.exports;\n\n/** @typedef {import('highlight.js').CallbackResponse} CallbackResponse */\n/** @typedef {import('highlight.js').CompiledMode} CompiledMode */\n/** @implements CallbackResponse */\n\nclass Response {\n  /**\n   * @param {CompiledMode} mode\n   */\n  constructor(mode) {\n    // eslint-disable-next-line no-undefined\n    if (mode.data === undefined) mode.data = {};\n\n    this.data = mode.data;\n    this.isMatchIgnored = false;\n  }\n\n  ignoreMatch() {\n    this.isMatchIgnored = true;\n  }\n}\n\n/**\n * @param {string} value\n * @returns {string}\n */\nfunction escapeHTML(value) {\n  return value\n    .replace(/&/g, '&amp;')\n    .replace(/</g, '&lt;')\n    .replace(/>/g, '&gt;')\n    .replace(/\"/g, '&quot;')\n    .replace(/'/g, '&#x27;');\n}\n\n/**\n * performs a shallow merge of multiple objects into one\n *\n * @template T\n * @param {T} original\n * @param {Record<string,any>[]} objects\n * @returns {T} a single new object\n */\nfunction inherit$1(original, ...objects) {\n  /** @type Record<string,any> */\n  const result = Object.create(null);\n\n  for (const key in original) {\n    result[key] = original[key];\n  }\n  objects.forEach(function(obj) {\n    for (const key in obj) {\n      result[key] = obj[key];\n    }\n  });\n  return /** @type {T} */ (result);\n}\n\n/**\n * @typedef {object} Renderer\n * @property {(text: string) => void} addText\n * @property {(node: Node) => void} openNode\n * @property {(node: Node) => void} closeNode\n * @property {() => string} value\n */\n\n/** @typedef {{kind?: string, sublanguage?: boolean}} Node */\n/** @typedef {{walk: (r: Renderer) => void}} Tree */\n/** */\n\nconst SPAN_CLOSE = '</span>';\n\n/**\n * Determines if a node needs to be wrapped in <span>\n *\n * @param {Node} node */\nconst emitsWrappingTags = (node) => {\n  return !!node.kind;\n};\n\n/**\n *\n * @param {string} name\n * @param {{prefix:string}} options\n */\nconst expandScopeName = (name, { prefix }) => {\n  if (name.includes(\".\")) {\n    const pieces = name.split(\".\");\n    return [\n      `${prefix}${pieces.shift()}`,\n      ...(pieces.map((x, i) => `${x}${\"_\".repeat(i + 1)}`))\n    ].join(\" \");\n  }\n  return `${prefix}${name}`;\n};\n\n/** @type {Renderer} */\nclass HTMLRenderer {\n  /**\n   * Creates a new HTMLRenderer\n   *\n   * @param {Tree} parseTree - the parse tree (must support `walk` API)\n   * @param {{classPrefix: string}} options\n   */\n  constructor(parseTree, options) {\n    this.buffer = \"\";\n    this.classPrefix = options.classPrefix;\n    parseTree.walk(this);\n  }\n\n  /**\n   * Adds texts to the output stream\n   *\n   * @param {string} text */\n  addText(text) {\n    this.buffer += escapeHTML(text);\n  }\n\n  /**\n   * Adds a node open to the output stream (if needed)\n   *\n   * @param {Node} node */\n  openNode(node) {\n    if (!emitsWrappingTags(node)) return;\n\n    let scope = node.kind;\n    if (node.sublanguage) {\n      scope = `language-${scope}`;\n    } else {\n      scope = expandScopeName(scope, { prefix: this.classPrefix });\n    }\n    this.span(scope);\n  }\n\n  /**\n   * Adds a node close to the output stream (if needed)\n   *\n   * @param {Node} node */\n  closeNode(node) {\n    if (!emitsWrappingTags(node)) return;\n\n    this.buffer += SPAN_CLOSE;\n  }\n\n  /**\n   * returns the accumulated buffer\n  */\n  value() {\n    return this.buffer;\n  }\n\n  // helpers\n\n  /**\n   * Builds a span element\n   *\n   * @param {string} className */\n  span(className) {\n    this.buffer += `<span class=\"${className}\">`;\n  }\n}\n\n/** @typedef {{kind?: string, sublanguage?: boolean, children: Node[]} | string} Node */\n/** @typedef {{kind?: string, sublanguage?: boolean, children: Node[]} } DataNode */\n/** @typedef {import('highlight.js').Emitter} Emitter */\n/**  */\n\nclass TokenTree {\n  constructor() {\n    /** @type DataNode */\n    this.rootNode = { children: [] };\n    this.stack = [this.rootNode];\n  }\n\n  get top() {\n    return this.stack[this.stack.length - 1];\n  }\n\n  get root() { return this.rootNode; }\n\n  /** @param {Node} node */\n  add(node) {\n    this.top.children.push(node);\n  }\n\n  /** @param {string} kind */\n  openNode(kind) {\n    /** @type Node */\n    const node = { kind, children: [] };\n    this.add(node);\n    this.stack.push(node);\n  }\n\n  closeNode() {\n    if (this.stack.length > 1) {\n      return this.stack.pop();\n    }\n    // eslint-disable-next-line no-undefined\n    return undefined;\n  }\n\n  closeAllNodes() {\n    while (this.closeNode());\n  }\n\n  toJSON() {\n    return JSON.stringify(this.rootNode, null, 4);\n  }\n\n  /**\n   * @typedef { import(\"./html_renderer\").Renderer } Renderer\n   * @param {Renderer} builder\n   */\n  walk(builder) {\n    // this does not\n    return this.constructor._walk(builder, this.rootNode);\n    // this works\n    // return TokenTree._walk(builder, this.rootNode);\n  }\n\n  /**\n   * @param {Renderer} builder\n   * @param {Node} node\n   */\n  static _walk(builder, node) {\n    if (typeof node === \"string\") {\n      builder.addText(node);\n    } else if (node.children) {\n      builder.openNode(node);\n      node.children.forEach((child) => this._walk(builder, child));\n      builder.closeNode(node);\n    }\n    return builder;\n  }\n\n  /**\n   * @param {Node} node\n   */\n  static _collapse(node) {\n    if (typeof node === \"string\") return;\n    if (!node.children) return;\n\n    if (node.children.every(el => typeof el === \"string\")) {\n      // node.text = node.children.join(\"\");\n      // delete node.children;\n      node.children = [node.children.join(\"\")];\n    } else {\n      node.children.forEach((child) => {\n        TokenTree._collapse(child);\n      });\n    }\n  }\n}\n\n/**\n  Currently this is all private API, but this is the minimal API necessary\n  that an Emitter must implement to fully support the parser.\n\n  Minimal interface:\n\n  - addKeyword(text, kind)\n  - addText(text)\n  - addSublanguage(emitter, subLanguageName)\n  - finalize()\n  - openNode(kind)\n  - closeNode()\n  - closeAllNodes()\n  - toHTML()\n\n*/\n\n/**\n * @implements {Emitter}\n */\nclass TokenTreeEmitter extends TokenTree {\n  /**\n   * @param {*} options\n   */\n  constructor(options) {\n    super();\n    this.options = options;\n  }\n\n  /**\n   * @param {string} text\n   * @param {string} kind\n   */\n  addKeyword(text, kind) {\n    if (text === \"\") { return; }\n\n    this.openNode(kind);\n    this.addText(text);\n    this.closeNode();\n  }\n\n  /**\n   * @param {string} text\n   */\n  addText(text) {\n    if (text === \"\") { return; }\n\n    this.add(text);\n  }\n\n  /**\n   * @param {Emitter & {root: DataNode}} emitter\n   * @param {string} name\n   */\n  addSublanguage(emitter, name) {\n    /** @type DataNode */\n    const node = emitter.root;\n    node.kind = name;\n    node.sublanguage = true;\n    this.add(node);\n  }\n\n  toHTML() {\n    const renderer = new HTMLRenderer(this, this.options);\n    return renderer.value();\n  }\n\n  finalize() {\n    return true;\n  }\n}\n\n/**\n * @param {string} value\n * @returns {RegExp}\n * */\n\n/**\n * @param {RegExp | string } re\n * @returns {string}\n */\nfunction source(re) {\n  if (!re) return null;\n  if (typeof re === \"string\") return re;\n\n  return re.source;\n}\n\n/**\n * @param {RegExp | string } re\n * @returns {string}\n */\nfunction lookahead(re) {\n  return concat('(?=', re, ')');\n}\n\n/**\n * @param {...(RegExp | string) } args\n * @returns {string}\n */\nfunction concat(...args) {\n  const joined = args.map((x) => source(x)).join(\"\");\n  return joined;\n}\n\nfunction stripOptionsFromArgs(args) {\n  const opts = args[args.length - 1];\n\n  if (typeof opts === 'object' && opts.constructor === Object) {\n    args.splice(args.length - 1, 1);\n    return opts;\n  } else {\n    return {};\n  }\n}\n\n/**\n * Any of the passed expresssions may match\n *\n * Creates a huge this | this | that | that match\n * @param {(RegExp | string)[] } args\n * @returns {string}\n */\nfunction either(...args) {\n  const opts = stripOptionsFromArgs(args);\n  const joined = '(' +\n    (opts.capture ? \"\" : \"?:\") +\n    args.map((x) => source(x)).join(\"|\") + \")\";\n  return joined;\n}\n\n/**\n * @param {RegExp} re\n * @returns {number}\n */\nfunction countMatchGroups(re) {\n  return (new RegExp(re.toString() + '|')).exec('').length - 1;\n}\n\n/**\n * Does lexeme start with a regular expression match at the beginning\n * @param {RegExp} re\n * @param {string} lexeme\n */\nfunction startsWith(re, lexeme) {\n  const match = re && re.exec(lexeme);\n  return match && match.index === 0;\n}\n\n// BACKREF_RE matches an open parenthesis or backreference. To avoid\n// an incorrect parse, it additionally matches the following:\n// - [...] elements, where the meaning of parentheses and escapes change\n// - other escape sequences, so we do not misparse escape sequences as\n//   interesting elements\n// - non-matching or lookahead parentheses, which do not capture. These\n//   follow the '(' with a '?'.\nconst BACKREF_RE = /\\[(?:[^\\\\\\]]|\\\\.)*\\]|\\(\\??|\\\\([1-9][0-9]*)|\\\\./;\n\n// **INTERNAL** Not intended for outside usage\n// join logically computes regexps.join(separator), but fixes the\n// backreferences so they continue to match.\n// it also places each individual regular expression into it's own\n// match group, keeping track of the sequencing of those match groups\n// is currently an exercise for the caller. :-)\n/**\n * @param {(string | RegExp)[]} regexps\n * @param {{joinWith: string}} opts\n * @returns {string}\n */\nfunction _rewriteBackreferences(regexps, { joinWith }) {\n  let numCaptures = 0;\n\n  return regexps.map((regex) => {\n    numCaptures += 1;\n    const offset = numCaptures;\n    let re = source(regex);\n    let out = '';\n\n    while (re.length > 0) {\n      const match = BACKREF_RE.exec(re);\n      if (!match) {\n        out += re;\n        break;\n      }\n      out += re.substring(0, match.index);\n      re = re.substring(match.index + match[0].length);\n      if (match[0][0] === '\\\\' && match[1]) {\n        // Adjust the backreference.\n        out += '\\\\' + String(Number(match[1]) + offset);\n      } else {\n        out += match[0];\n        if (match[0] === '(') {\n          numCaptures++;\n        }\n      }\n    }\n    return out;\n  }).map(re => `(${re})`).join(joinWith);\n}\n\n/** @typedef {import('highlight.js').Mode} Mode */\n/** @typedef {import('highlight.js').ModeCallback} ModeCallback */\n\n// Common regexps\nconst MATCH_NOTHING_RE = /\\b\\B/;\nconst IDENT_RE = '[a-zA-Z]\\\\w*';\nconst UNDERSCORE_IDENT_RE = '[a-zA-Z_]\\\\w*';\nconst NUMBER_RE = '\\\\b\\\\d+(\\\\.\\\\d+)?';\nconst C_NUMBER_RE = '(-?)(\\\\b0[xX][a-fA-F0-9]+|(\\\\b\\\\d+(\\\\.\\\\d*)?|\\\\.\\\\d+)([eE][-+]?\\\\d+)?)'; // 0x..., 0..., decimal, float\nconst BINARY_NUMBER_RE = '\\\\b(0b[01]+)'; // 0b...\nconst RE_STARTERS_RE = '!|!=|!==|%|%=|&|&&|&=|\\\\*|\\\\*=|\\\\+|\\\\+=|,|-|-=|/=|/|:|;|<<|<<=|<=|<|===|==|=|>>>=|>>=|>=|>>>|>>|>|\\\\?|\\\\[|\\\\{|\\\\(|\\\\^|\\\\^=|\\\\||\\\\|=|\\\\|\\\\||~';\n\n/**\n* @param { Partial<Mode> & {binary?: string | RegExp} } opts\n*/\nconst SHEBANG = (opts = {}) => {\n  const beginShebang = /^#![ ]*\\//;\n  if (opts.binary) {\n    opts.begin = concat(\n      beginShebang,\n      /.*\\b/,\n      opts.binary,\n      /\\b.*/);\n  }\n  return inherit$1({\n    scope: 'meta',\n    begin: beginShebang,\n    end: /$/,\n    relevance: 0,\n    /** @type {ModeCallback} */\n    \"on:begin\": (m, resp) => {\n      if (m.index !== 0) resp.ignoreMatch();\n    }\n  }, opts);\n};\n\n// Common modes\nconst BACKSLASH_ESCAPE = {\n  begin: '\\\\\\\\[\\\\s\\\\S]', relevance: 0\n};\nconst APOS_STRING_MODE = {\n  scope: 'string',\n  begin: '\\'',\n  end: '\\'',\n  illegal: '\\\\n',\n  contains: [BACKSLASH_ESCAPE]\n};\nconst QUOTE_STRING_MODE = {\n  scope: 'string',\n  begin: '\"',\n  end: '\"',\n  illegal: '\\\\n',\n  contains: [BACKSLASH_ESCAPE]\n};\nconst PHRASAL_WORDS_MODE = {\n  begin: /\\b(a|an|the|are|I'm|isn't|don't|doesn't|won't|but|just|should|pretty|simply|enough|gonna|going|wtf|so|such|will|you|your|they|like|more)\\b/\n};\n/**\n * Creates a comment mode\n *\n * @param {string | RegExp} begin\n * @param {string | RegExp} end\n * @param {Mode | {}} [modeOptions]\n * @returns {Partial<Mode>}\n */\nconst COMMENT = function(begin, end, modeOptions = {}) {\n  const mode = inherit$1(\n    {\n      scope: 'comment',\n      begin,\n      end,\n      contains: []\n    },\n    modeOptions\n  );\n  mode.contains.push({\n    scope: 'doctag',\n    // hack to avoid the space from being included. the space is necessary to\n    // match here to prevent the plain text rule below from gobbling up doctags\n    begin: '[ ]*(?=(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):)',\n    end: /(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):/,\n    excludeBegin: true,\n    relevance: 0\n  });\n  const ENGLISH_WORD = either(\n    // list of common 1 and 2 letter words in English\n    \"I\",\n    \"a\",\n    \"is\",\n    \"so\",\n    \"us\",\n    \"to\",\n    \"at\",\n    \"if\",\n    \"in\",\n    \"it\",\n    \"on\",\n    // note: this is not an exhaustive list of contractions, just popular ones\n    /[A-Za-z]+['](d|ve|re|ll|t|s|n)/, // contractions - can't we'd they're let's, etc\n    /[A-Za-z]+[-][a-z]+/, // `no-way`, etc.\n    /[A-Za-z][a-z]{2,}/ // allow capitalized words at beginning of sentences\n  );\n  // looking like plain text, more likely to be a comment\n  mode.contains.push(\n    {\n      // TODO: how to include \", (, ) without breaking grammars that use these for\n      // comment delimiters?\n      // begin: /[ ]+([()\"]?([A-Za-z'-]{3,}|is|a|I|so|us|[tT][oO]|at|if|in|it|on)[.]?[()\":]?([.][ ]|[ ]|\\))){3}/\n      // ---\n\n      // this tries to find sequences of 3 english words in a row (without any\n      // \"programming\" type syntax) this gives us a strong signal that we've\n      // TRULY found a comment - vs perhaps scanning with the wrong language.\n      // It's possible to find something that LOOKS like the start of the\n      // comment - but then if there is no readable text - good chance it is a\n      // false match and not a comment.\n      //\n      // for a visual example please see:\n      // https://github.com/highlightjs/highlight.js/issues/2827\n\n      begin: concat(\n        /[ ]+/, // necessary to prevent us gobbling up doctags like /* @author Bob Mcgill */\n        '(',\n        ENGLISH_WORD,\n        /[.]?[:]?([.][ ]|[ ])/,\n        '){3}') // look for 3 words in a row\n    }\n  );\n  return mode;\n};\nconst C_LINE_COMMENT_MODE = COMMENT('//', '$');\nconst C_BLOCK_COMMENT_MODE = COMMENT('/\\\\*', '\\\\*/');\nconst HASH_COMMENT_MODE = COMMENT('#', '$');\nconst NUMBER_MODE = {\n  scope: 'number',\n  begin: NUMBER_RE,\n  relevance: 0\n};\nconst C_NUMBER_MODE = {\n  scope: 'number',\n  begin: C_NUMBER_RE,\n  relevance: 0\n};\nconst BINARY_NUMBER_MODE = {\n  scope: 'number',\n  begin: BINARY_NUMBER_RE,\n  relevance: 0\n};\nconst REGEXP_MODE = {\n  // this outer rule makes sure we actually have a WHOLE regex and not simply\n  // an expression such as:\n  //\n  //     3 / something\n  //\n  // (which will then blow up when regex's `illegal` sees the newline)\n  begin: /(?=\\/[^/\\n]*\\/)/,\n  contains: [{\n    scope: 'regexp',\n    begin: /\\//,\n    end: /\\/[gimuy]*/,\n    illegal: /\\n/,\n    contains: [\n      BACKSLASH_ESCAPE,\n      {\n        begin: /\\[/,\n        end: /\\]/,\n        relevance: 0,\n        contains: [BACKSLASH_ESCAPE]\n      }\n    ]\n  }]\n};\nconst TITLE_MODE = {\n  scope: 'title',\n  begin: IDENT_RE,\n  relevance: 0\n};\nconst UNDERSCORE_TITLE_MODE = {\n  scope: 'title',\n  begin: UNDERSCORE_IDENT_RE,\n  relevance: 0\n};\nconst METHOD_GUARD = {\n  // excludes method names from keyword processing\n  begin: '\\\\.\\\\s*' + UNDERSCORE_IDENT_RE,\n  relevance: 0\n};\n\n/**\n * Adds end same as begin mechanics to a mode\n *\n * Your mode must include at least a single () match group as that first match\n * group is what is used for comparison\n * @param {Partial<Mode>} mode\n */\nconst END_SAME_AS_BEGIN = function(mode) {\n  return Object.assign(mode,\n    {\n      /** @type {ModeCallback} */\n      'on:begin': (m, resp) => { resp.data._beginMatch = m[1]; },\n      /** @type {ModeCallback} */\n      'on:end': (m, resp) => { if (resp.data._beginMatch !== m[1]) resp.ignoreMatch(); }\n    });\n};\n\nvar MODES = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    MATCH_NOTHING_RE: MATCH_NOTHING_RE,\n    IDENT_RE: IDENT_RE,\n    UNDERSCORE_IDENT_RE: UNDERSCORE_IDENT_RE,\n    NUMBER_RE: NUMBER_RE,\n    C_NUMBER_RE: C_NUMBER_RE,\n    BINARY_NUMBER_RE: BINARY_NUMBER_RE,\n    RE_STARTERS_RE: RE_STARTERS_RE,\n    SHEBANG: SHEBANG,\n    BACKSLASH_ESCAPE: BACKSLASH_ESCAPE,\n    APOS_STRING_MODE: APOS_STRING_MODE,\n    QUOTE_STRING_MODE: QUOTE_STRING_MODE,\n    PHRASAL_WORDS_MODE: PHRASAL_WORDS_MODE,\n    COMMENT: COMMENT,\n    C_LINE_COMMENT_MODE: C_LINE_COMMENT_MODE,\n    C_BLOCK_COMMENT_MODE: C_BLOCK_COMMENT_MODE,\n    HASH_COMMENT_MODE: HASH_COMMENT_MODE,\n    NUMBER_MODE: NUMBER_MODE,\n    C_NUMBER_MODE: C_NUMBER_MODE,\n    BINARY_NUMBER_MODE: BINARY_NUMBER_MODE,\n    REGEXP_MODE: REGEXP_MODE,\n    TITLE_MODE: TITLE_MODE,\n    UNDERSCORE_TITLE_MODE: UNDERSCORE_TITLE_MODE,\n    METHOD_GUARD: METHOD_GUARD,\n    END_SAME_AS_BEGIN: END_SAME_AS_BEGIN\n});\n\n/**\n@typedef {import('highlight.js').CallbackResponse} CallbackResponse\n@typedef {import('highlight.js').CompilerExt} CompilerExt\n*/\n\n// Grammar extensions / plugins\n// See: https://github.com/highlightjs/highlight.js/issues/2833\n\n// Grammar extensions allow \"syntactic sugar\" to be added to the grammar modes\n// without requiring any underlying changes to the compiler internals.\n\n// `compileMatch` being the perfect small example of now allowing a grammar\n// author to write `match` when they desire to match a single expression rather\n// than being forced to use `begin`.  The extension then just moves `match` into\n// `begin` when it runs.  Ie, no features have been added, but we've just made\n// the experience of writing (and reading grammars) a little bit nicer.\n\n// ------\n\n// TODO: We need negative look-behind support to do this properly\n/**\n * Skip a match if it has a preceding dot\n *\n * This is used for `beginKeywords` to prevent matching expressions such as\n * `bob.keyword.do()`. The mode compiler automatically wires this up as a\n * special _internal_ 'on:begin' callback for modes with `beginKeywords`\n * @param {RegExpMatchArray} match\n * @param {CallbackResponse} response\n */\nfunction skipIfHasPrecedingDot(match, response) {\n  const before = match.input[match.index - 1];\n  if (before === \".\") {\n    response.ignoreMatch();\n  }\n}\n\n/**\n *\n * @type {CompilerExt}\n */\nfunction scopeClassName(mode, _parent) {\n  // eslint-disable-next-line no-undefined\n  if (mode.className !== undefined) {\n    mode.scope = mode.className;\n    delete mode.className;\n  }\n}\n\n/**\n * `beginKeywords` syntactic sugar\n * @type {CompilerExt}\n */\nfunction beginKeywords(mode, parent) {\n  if (!parent) return;\n  if (!mode.beginKeywords) return;\n\n  // for languages with keywords that include non-word characters checking for\n  // a word boundary is not sufficient, so instead we check for a word boundary\n  // or whitespace - this does no harm in any case since our keyword engine\n  // doesn't allow spaces in keywords anyways and we still check for the boundary\n  // first\n  mode.begin = '\\\\b(' + mode.beginKeywords.split(' ').join('|') + ')(?!\\\\.)(?=\\\\b|\\\\s)';\n  mode.__beforeBegin = skipIfHasPrecedingDot;\n  mode.keywords = mode.keywords || mode.beginKeywords;\n  delete mode.beginKeywords;\n\n  // prevents double relevance, the keywords themselves provide\n  // relevance, the mode doesn't need to double it\n  // eslint-disable-next-line no-undefined\n  if (mode.relevance === undefined) mode.relevance = 0;\n}\n\n/**\n * Allow `illegal` to contain an array of illegal values\n * @type {CompilerExt}\n */\nfunction compileIllegal(mode, _parent) {\n  if (!Array.isArray(mode.illegal)) return;\n\n  mode.illegal = either(...mode.illegal);\n}\n\n/**\n * `match` to match a single expression for readability\n * @type {CompilerExt}\n */\nfunction compileMatch(mode, _parent) {\n  if (!mode.match) return;\n  if (mode.begin || mode.end) throw new Error(\"begin & end are not supported with match\");\n\n  mode.begin = mode.match;\n  delete mode.match;\n}\n\n/**\n * provides the default 1 relevance to all modes\n * @type {CompilerExt}\n */\nfunction compileRelevance(mode, _parent) {\n  // eslint-disable-next-line no-undefined\n  if (mode.relevance === undefined) mode.relevance = 1;\n}\n\n// allow beforeMatch to act as a \"qualifier\" for the match\n// the full match begin must be [beforeMatch][begin]\nconst beforeMatchExt = (mode, parent) => {\n  if (!mode.beforeMatch) return;\n  // starts conflicts with endsParent which we need to make sure the child\n  // rule is not matched multiple times\n  if (mode.starts) throw new Error(\"beforeMatch cannot be used with starts\");\n\n  const originalMode = Object.assign({}, mode);\n  Object.keys(mode).forEach((key) => { delete mode[key]; });\n\n  mode.keywords = originalMode.keywords;\n  mode.begin = concat(originalMode.beforeMatch, lookahead(originalMode.begin));\n  mode.starts = {\n    relevance: 0,\n    contains: [\n      Object.assign(originalMode, { endsParent: true })\n    ]\n  };\n  mode.relevance = 0;\n\n  delete originalMode.beforeMatch;\n};\n\n// keywords that should have no default relevance value\nconst COMMON_KEYWORDS = [\n  'of',\n  'and',\n  'for',\n  'in',\n  'not',\n  'or',\n  'if',\n  'then',\n  'parent', // common variable name\n  'list', // common variable name\n  'value' // common variable name\n];\n\nconst DEFAULT_KEYWORD_SCOPE = \"keyword\";\n\n/**\n * Given raw keywords from a language definition, compile them.\n *\n * @param {string | Record<string,string|string[]> | Array<string>} rawKeywords\n * @param {boolean} caseInsensitive\n */\nfunction compileKeywords(rawKeywords, caseInsensitive, scopeName = DEFAULT_KEYWORD_SCOPE) {\n  /** @type KeywordDict */\n  const compiledKeywords = Object.create(null);\n\n  // input can be a string of keywords, an array of keywords, or a object with\n  // named keys representing scopeName (which can then point to a string or array)\n  if (typeof rawKeywords === 'string') {\n    compileList(scopeName, rawKeywords.split(\" \"));\n  } else if (Array.isArray(rawKeywords)) {\n    compileList(scopeName, rawKeywords);\n  } else {\n    Object.keys(rawKeywords).forEach(function(scopeName) {\n      // collapse all our objects back into the parent object\n      Object.assign(\n        compiledKeywords,\n        compileKeywords(rawKeywords[scopeName], caseInsensitive, scopeName)\n      );\n    });\n  }\n  return compiledKeywords;\n\n  // ---\n\n  /**\n   * Compiles an individual list of keywords\n   *\n   * Ex: \"for if when while|5\"\n   *\n   * @param {string} scopeName\n   * @param {Array<string>} keywordList\n   */\n  function compileList(scopeName, keywordList) {\n    if (caseInsensitive) {\n      keywordList = keywordList.map(x => x.toLowerCase());\n    }\n    keywordList.forEach(function(keyword) {\n      const pair = keyword.split('|');\n      compiledKeywords[pair[0]] = [scopeName, scoreForKeyword(pair[0], pair[1])];\n    });\n  }\n}\n\n/**\n * Returns the proper score for a given keyword\n *\n * Also takes into account comment keywords, which will be scored 0 UNLESS\n * another score has been manually assigned.\n * @param {string} keyword\n * @param {string} [providedScore]\n */\nfunction scoreForKeyword(keyword, providedScore) {\n  // manual scores always win over common keywords\n  // so you can force a score of 1 if you really insist\n  if (providedScore) {\n    return Number(providedScore);\n  }\n\n  return commonKeyword(keyword) ? 0 : 1;\n}\n\n/**\n * Determines if a given keyword is common or not\n *\n * @param {string} keyword */\nfunction commonKeyword(keyword) {\n  return COMMON_KEYWORDS.includes(keyword.toLowerCase());\n}\n\n/*\n\nFor the reasoning behind this please see:\nhttps://github.com/highlightjs/highlight.js/issues/2880#issuecomment-747275419\n\n*/\n\n/**\n * @type {Record<string, boolean>}\n */\nconst seenDeprecations = {};\n\n/**\n * @param {string} message\n */\nconst error = (message) => {\n  console.error(message);\n};\n\n/**\n * @param {string} message\n * @param {any} args\n */\nconst warn = (message, ...args) => {\n  console.log(`WARN: ${message}`, ...args);\n};\n\n/**\n * @param {string} version\n * @param {string} message\n */\nconst deprecated = (version, message) => {\n  if (seenDeprecations[`${version}/${message}`]) return;\n\n  console.log(`Deprecated as of ${version}. ${message}`);\n  seenDeprecations[`${version}/${message}`] = true;\n};\n\n/* eslint-disable no-throw-literal */\n\n/**\n@typedef {import('highlight.js').CompiledMode} CompiledMode\n*/\n\nconst MultiClassError = new Error();\n\n/**\n * Renumbers labeled scope names to account for additional inner match\n * groups that otherwise would break everything.\n *\n * Lets say we 3 match scopes:\n *\n *   { 1 => ..., 2 => ..., 3 => ... }\n *\n * So what we need is a clean match like this:\n *\n *   (a)(b)(c) => [ \"a\", \"b\", \"c\" ]\n *\n * But this falls apart with inner match groups:\n *\n * (a)(((b)))(c) => [\"a\", \"b\", \"b\", \"b\", \"c\" ]\n *\n * Our scopes are now \"out of alignment\" and we're repeating `b` 3 times.\n * What needs to happen is the numbers are remapped:\n *\n *   { 1 => ..., 2 => ..., 5 => ... }\n *\n * We also need to know that the ONLY groups that should be output\n * are 1, 2, and 5.  This function handles this behavior.\n *\n * @param {CompiledMode} mode\n * @param {Array<RegExp>} regexes\n * @param {{key: \"beginScope\"|\"endScope\"}} opts\n */\nfunction remapScopeNames(mode, regexes, { key }) {\n  let offset = 0;\n  const scopeNames = mode[key];\n  /** @type Record<number,boolean> */\n  const emit = {};\n  /** @type Record<number,string> */\n  const positions = {};\n\n  for (let i = 1; i <= regexes.length; i++) {\n    positions[i + offset] = scopeNames[i];\n    emit[i + offset] = true;\n    offset += countMatchGroups(regexes[i - 1]);\n  }\n  // we use _emit to keep track of which match groups are \"top-level\" to avoid double\n  // output from inside match groups\n  mode[key] = positions;\n  mode[key]._emit = emit;\n  mode[key]._multi = true;\n}\n\n/**\n * @param {CompiledMode} mode\n */\nfunction beginMultiClass(mode) {\n  if (!Array.isArray(mode.begin)) return;\n\n  if (mode.skip || mode.excludeBegin || mode.returnBegin) {\n    error(\"skip, excludeBegin, returnBegin not compatible with beginScope: {}\");\n    throw MultiClassError;\n  }\n\n  if (typeof mode.beginScope !== \"object\" || mode.beginScope === null) {\n    error(\"beginScope must be object\");\n    throw MultiClassError;\n  }\n\n  remapScopeNames(mode, mode.begin, {key: \"beginScope\"});\n  mode.begin = _rewriteBackreferences(mode.begin, { joinWith: \"\" });\n}\n\n/**\n * @param {CompiledMode} mode\n */\nfunction endMultiClass(mode) {\n  if (!Array.isArray(mode.end)) return;\n\n  if (mode.skip || mode.excludeEnd || mode.returnEnd) {\n    error(\"skip, excludeEnd, returnEnd not compatible with endScope: {}\");\n    throw MultiClassError;\n  }\n\n  if (typeof mode.endScope !== \"object\" || mode.endScope === null) {\n    error(\"endScope must be object\");\n    throw MultiClassError;\n  }\n\n  remapScopeNames(mode, mode.end, {key: \"endScope\"});\n  mode.end = _rewriteBackreferences(mode.end, { joinWith: \"\" });\n}\n\n/**\n * this exists only to allow `scope: {}` to be used beside `match:`\n * Otherwise `beginScope` would necessary and that would look weird\n\n  {\n    match: [ /def/, /\\w+/ ]\n    scope: { 1: \"keyword\" , 2: \"title\" }\n  }\n\n * @param {CompiledMode} mode\n */\nfunction scopeSugar(mode) {\n  if (mode.scope && typeof mode.scope === \"object\" && mode.scope !== null) {\n    mode.beginScope = mode.scope;\n    delete mode.scope;\n  }\n}\n\n/**\n * @param {CompiledMode} mode\n */\nfunction MultiClass(mode) {\n  scopeSugar(mode);\n\n  if (typeof mode.beginScope === \"string\") {\n    mode.beginScope = { _wrap: mode.beginScope };\n  }\n  if (typeof mode.endScope === \"string\") {\n    mode.endScope = { _wrap: mode.endScope };\n  }\n\n  beginMultiClass(mode);\n  endMultiClass(mode);\n}\n\n/**\n@typedef {import('highlight.js').Mode} Mode\n@typedef {import('highlight.js').CompiledMode} CompiledMode\n@typedef {import('highlight.js').Language} Language\n@typedef {import('highlight.js').HLJSPlugin} HLJSPlugin\n@typedef {import('highlight.js').CompiledLanguage} CompiledLanguage\n*/\n\n// compilation\n\n/**\n * Compiles a language definition result\n *\n * Given the raw result of a language definition (Language), compiles this so\n * that it is ready for highlighting code.\n * @param {Language} language\n * @returns {CompiledLanguage}\n */\nfunction compileLanguage(language) {\n  /**\n   * Builds a regex with the case sensitivity of the current language\n   *\n   * @param {RegExp | string} value\n   * @param {boolean} [global]\n   */\n  function langRe(value, global) {\n    return new RegExp(\n      source(value),\n      'm' + (language.case_insensitive ? 'i' : '') + (global ? 'g' : '')\n    );\n  }\n\n  /**\n    Stores multiple regular expressions and allows you to quickly search for\n    them all in a string simultaneously - returning the first match.  It does\n    this by creating a huge (a|b|c) regex - each individual item wrapped with ()\n    and joined by `|` - using match groups to track position.  When a match is\n    found checking which position in the array has content allows us to figure\n    out which of the original regexes / match groups triggered the match.\n\n    The match object itself (the result of `Regex.exec`) is returned but also\n    enhanced by merging in any meta-data that was registered with the regex.\n    This is how we keep track of which mode matched, and what type of rule\n    (`illegal`, `begin`, end, etc).\n  */\n  class MultiRegex {\n    constructor() {\n      this.matchIndexes = {};\n      // @ts-ignore\n      this.regexes = [];\n      this.matchAt = 1;\n      this.position = 0;\n    }\n\n    // @ts-ignore\n    addRule(re, opts) {\n      opts.position = this.position++;\n      // @ts-ignore\n      this.matchIndexes[this.matchAt] = opts;\n      this.regexes.push([opts, re]);\n      this.matchAt += countMatchGroups(re) + 1;\n    }\n\n    compile() {\n      if (this.regexes.length === 0) {\n        // avoids the need to check length every time exec is called\n        // @ts-ignore\n        this.exec = () => null;\n      }\n      const terminators = this.regexes.map(el => el[1]);\n      this.matcherRe = langRe(_rewriteBackreferences(terminators, { joinWith: '|' }), true);\n      this.lastIndex = 0;\n    }\n\n    /** @param {string} s */\n    exec(s) {\n      this.matcherRe.lastIndex = this.lastIndex;\n      const match = this.matcherRe.exec(s);\n      if (!match) { return null; }\n\n      // eslint-disable-next-line no-undefined\n      const i = match.findIndex((el, i) => i > 0 && el !== undefined);\n      // @ts-ignore\n      const matchData = this.matchIndexes[i];\n      // trim off any earlier non-relevant match groups (ie, the other regex\n      // match groups that make up the multi-matcher)\n      match.splice(0, i);\n\n      return Object.assign(match, matchData);\n    }\n  }\n\n  /*\n    Created to solve the key deficiently with MultiRegex - there is no way to\n    test for multiple matches at a single location.  Why would we need to do\n    that?  In the future a more dynamic engine will allow certain matches to be\n    ignored.  An example: if we matched say the 3rd regex in a large group but\n    decided to ignore it - we'd need to started testing again at the 4th\n    regex... but MultiRegex itself gives us no real way to do that.\n\n    So what this class creates MultiRegexs on the fly for whatever search\n    position they are needed.\n\n    NOTE: These additional MultiRegex objects are created dynamically.  For most\n    grammars most of the time we will never actually need anything more than the\n    first MultiRegex - so this shouldn't have too much overhead.\n\n    Say this is our search group, and we match regex3, but wish to ignore it.\n\n      regex1 | regex2 | regex3 | regex4 | regex5    ' ie, startAt = 0\n\n    What we need is a new MultiRegex that only includes the remaining\n    possibilities:\n\n      regex4 | regex5                               ' ie, startAt = 3\n\n    This class wraps all that complexity up in a simple API... `startAt` decides\n    where in the array of expressions to start doing the matching. It\n    auto-increments, so if a match is found at position 2, then startAt will be\n    set to 3.  If the end is reached startAt will return to 0.\n\n    MOST of the time the parser will be setting startAt manually to 0.\n  */\n  class ResumableMultiRegex {\n    constructor() {\n      // @ts-ignore\n      this.rules = [];\n      // @ts-ignore\n      this.multiRegexes = [];\n      this.count = 0;\n\n      this.lastIndex = 0;\n      this.regexIndex = 0;\n    }\n\n    // @ts-ignore\n    getMatcher(index) {\n      if (this.multiRegexes[index]) return this.multiRegexes[index];\n\n      const matcher = new MultiRegex();\n      this.rules.slice(index).forEach(([re, opts]) => matcher.addRule(re, opts));\n      matcher.compile();\n      this.multiRegexes[index] = matcher;\n      return matcher;\n    }\n\n    resumingScanAtSamePosition() {\n      return this.regexIndex !== 0;\n    }\n\n    considerAll() {\n      this.regexIndex = 0;\n    }\n\n    // @ts-ignore\n    addRule(re, opts) {\n      this.rules.push([re, opts]);\n      if (opts.type === \"begin\") this.count++;\n    }\n\n    /** @param {string} s */\n    exec(s) {\n      const m = this.getMatcher(this.regexIndex);\n      m.lastIndex = this.lastIndex;\n      let result = m.exec(s);\n\n      // The following is because we have no easy way to say \"resume scanning at the\n      // existing position but also skip the current rule ONLY\". What happens is\n      // all prior rules are also skipped which can result in matching the wrong\n      // thing. Example of matching \"booger\":\n\n      // our matcher is [string, \"booger\", number]\n      //\n      // ....booger....\n\n      // if \"booger\" is ignored then we'd really need a regex to scan from the\n      // SAME position for only: [string, number] but ignoring \"booger\" (if it\n      // was the first match), a simple resume would scan ahead who knows how\n      // far looking only for \"number\", ignoring potential string matches (or\n      // future \"booger\" matches that might be valid.)\n\n      // So what we do: We execute two matchers, one resuming at the same\n      // position, but the second full matcher starting at the position after:\n\n      //     /--- resume first regex match here (for [number])\n      //     |/---- full match here for [string, \"booger\", number]\n      //     vv\n      // ....booger....\n\n      // Which ever results in a match first is then used. So this 3-4 step\n      // process essentially allows us to say \"match at this position, excluding\n      // a prior rule that was ignored\".\n      //\n      // 1. Match \"booger\" first, ignore. Also proves that [string] does non match.\n      // 2. Resume matching for [number]\n      // 3. Match at index + 1 for [string, \"booger\", number]\n      // 4. If #2 and #3 result in matches, which came first?\n      if (this.resumingScanAtSamePosition()) {\n        if (result && result.index === this.lastIndex) ; else { // use the second matcher result\n          const m2 = this.getMatcher(0);\n          m2.lastIndex = this.lastIndex + 1;\n          result = m2.exec(s);\n        }\n      }\n\n      if (result) {\n        this.regexIndex += result.position + 1;\n        if (this.regexIndex === this.count) {\n          // wrap-around to considering all matches again\n          this.considerAll();\n        }\n      }\n\n      return result;\n    }\n  }\n\n  /**\n   * Given a mode, builds a huge ResumableMultiRegex that can be used to walk\n   * the content and find matches.\n   *\n   * @param {CompiledMode} mode\n   * @returns {ResumableMultiRegex}\n   */\n  function buildModeRegex(mode) {\n    const mm = new ResumableMultiRegex();\n\n    mode.contains.forEach(term => mm.addRule(term.begin, { rule: term, type: \"begin\" }));\n\n    if (mode.terminatorEnd) {\n      mm.addRule(mode.terminatorEnd, { type: \"end\" });\n    }\n    if (mode.illegal) {\n      mm.addRule(mode.illegal, { type: \"illegal\" });\n    }\n\n    return mm;\n  }\n\n  /** skip vs abort vs ignore\n   *\n   * @skip   - The mode is still entered and exited normally (and contains rules apply),\n   *           but all content is held and added to the parent buffer rather than being\n   *           output when the mode ends.  Mostly used with `sublanguage` to build up\n   *           a single large buffer than can be parsed by sublanguage.\n   *\n   *             - The mode begin ands ends normally.\n   *             - Content matched is added to the parent mode buffer.\n   *             - The parser cursor is moved forward normally.\n   *\n   * @abort  - A hack placeholder until we have ignore.  Aborts the mode (as if it\n   *           never matched) but DOES NOT continue to match subsequent `contains`\n   *           modes.  Abort is bad/suboptimal because it can result in modes\n   *           farther down not getting applied because an earlier rule eats the\n   *           content but then aborts.\n   *\n   *             - The mode does not begin.\n   *             - Content matched by `begin` is added to the mode buffer.\n   *             - The parser cursor is moved forward accordingly.\n   *\n   * @ignore - Ignores the mode (as if it never matched) and continues to match any\n   *           subsequent `contains` modes.  Ignore isn't technically possible with\n   *           the current parser implementation.\n   *\n   *             - The mode does not begin.\n   *             - Content matched by `begin` is ignored.\n   *             - The parser cursor is not moved forward.\n   */\n\n  /**\n   * Compiles an individual mode\n   *\n   * This can raise an error if the mode contains certain detectable known logic\n   * issues.\n   * @param {Mode} mode\n   * @param {CompiledMode | null} [parent]\n   * @returns {CompiledMode | never}\n   */\n  function compileMode(mode, parent) {\n    const cmode = /** @type CompiledMode */ (mode);\n    if (mode.isCompiled) return cmode;\n\n    [\n      scopeClassName,\n      // do this early so compiler extensions generally don't have to worry about\n      // the distinction between match/begin\n      compileMatch,\n      MultiClass,\n      beforeMatchExt\n    ].forEach(ext => ext(mode, parent));\n\n    language.compilerExtensions.forEach(ext => ext(mode, parent));\n\n    // __beforeBegin is considered private API, internal use only\n    mode.__beforeBegin = null;\n\n    [\n      beginKeywords,\n      // do this later so compiler extensions that come earlier have access to the\n      // raw array if they wanted to perhaps manipulate it, etc.\n      compileIllegal,\n      // default to 1 relevance if not specified\n      compileRelevance\n    ].forEach(ext => ext(mode, parent));\n\n    mode.isCompiled = true;\n\n    let keywordPattern = null;\n    if (typeof mode.keywords === \"object\" && mode.keywords.$pattern) {\n      // we need a copy because keywords might be compiled multiple times\n      // so we can't go deleting $pattern from the original on the first\n      // pass\n      mode.keywords = Object.assign({}, mode.keywords);\n      keywordPattern = mode.keywords.$pattern;\n      delete mode.keywords.$pattern;\n    }\n    keywordPattern = keywordPattern || /\\w+/;\n\n    if (mode.keywords) {\n      mode.keywords = compileKeywords(mode.keywords, language.case_insensitive);\n    }\n\n    cmode.keywordPatternRe = langRe(keywordPattern, true);\n\n    if (parent) {\n      if (!mode.begin) mode.begin = /\\B|\\b/;\n      cmode.beginRe = langRe(mode.begin);\n      if (!mode.end && !mode.endsWithParent) mode.end = /\\B|\\b/;\n      if (mode.end) cmode.endRe = langRe(mode.end);\n      cmode.terminatorEnd = source(mode.end) || '';\n      if (mode.endsWithParent && parent.terminatorEnd) {\n        cmode.terminatorEnd += (mode.end ? '|' : '') + parent.terminatorEnd;\n      }\n    }\n    if (mode.illegal) cmode.illegalRe = langRe(/** @type {RegExp | string} */ (mode.illegal));\n    if (!mode.contains) mode.contains = [];\n\n    mode.contains = [].concat(...mode.contains.map(function(c) {\n      return expandOrCloneMode(c === 'self' ? mode : c);\n    }));\n    mode.contains.forEach(function(c) { compileMode(/** @type Mode */ (c), cmode); });\n\n    if (mode.starts) {\n      compileMode(mode.starts, parent);\n    }\n\n    cmode.matcher = buildModeRegex(cmode);\n    return cmode;\n  }\n\n  if (!language.compilerExtensions) language.compilerExtensions = [];\n\n  // self is not valid at the top-level\n  if (language.contains && language.contains.includes('self')) {\n    throw new Error(\"ERR: contains `self` is not supported at the top-level of a language.  See documentation.\");\n  }\n\n  // we need a null object, which inherit will guarantee\n  language.classNameAliases = inherit$1(language.classNameAliases || {});\n\n  return compileMode(/** @type Mode */ (language));\n}\n\n/**\n * Determines if a mode has a dependency on it's parent or not\n *\n * If a mode does have a parent dependency then often we need to clone it if\n * it's used in multiple places so that each copy points to the correct parent,\n * where-as modes without a parent can often safely be re-used at the bottom of\n * a mode chain.\n *\n * @param {Mode | null} mode\n * @returns {boolean} - is there a dependency on the parent?\n * */\nfunction dependencyOnParent(mode) {\n  if (!mode) return false;\n\n  return mode.endsWithParent || dependencyOnParent(mode.starts);\n}\n\n/**\n * Expands a mode or clones it if necessary\n *\n * This is necessary for modes with parental dependenceis (see notes on\n * `dependencyOnParent`) and for nodes that have `variants` - which must then be\n * exploded into their own individual modes at compile time.\n *\n * @param {Mode} mode\n * @returns {Mode | Mode[]}\n * */\nfunction expandOrCloneMode(mode) {\n  if (mode.variants && !mode.cachedVariants) {\n    mode.cachedVariants = mode.variants.map(function(variant) {\n      return inherit$1(mode, { variants: null }, variant);\n    });\n  }\n\n  // EXPAND\n  // if we have variants then essentially \"replace\" the mode with the variants\n  // this happens in compileMode, where this function is called from\n  if (mode.cachedVariants) {\n    return mode.cachedVariants;\n  }\n\n  // CLONE\n  // if we have dependencies on parents then we need a unique\n  // instance of ourselves, so we can be reused with many\n  // different parents without issue\n  if (dependencyOnParent(mode)) {\n    return inherit$1(mode, { starts: mode.starts ? inherit$1(mode.starts) : null });\n  }\n\n  if (Object.isFrozen(mode)) {\n    return inherit$1(mode);\n  }\n\n  // no special dependency issues, just return ourselves\n  return mode;\n}\n\nvar version = \"11.2.0\";\n\n/*\nSyntax highlighting with language autodetection.\nhttps://highlightjs.org/\n*/\n\n/**\n@typedef {import('highlight.js').Mode} Mode\n@typedef {import('highlight.js').CompiledMode} CompiledMode\n@typedef {import('highlight.js').Language} Language\n@typedef {import('highlight.js').HLJSApi} HLJSApi\n@typedef {import('highlight.js').HLJSPlugin} HLJSPlugin\n@typedef {import('highlight.js').PluginEvent} PluginEvent\n@typedef {import('highlight.js').HLJSOptions} HLJSOptions\n@typedef {import('highlight.js').LanguageFn} LanguageFn\n@typedef {import('highlight.js').HighlightedHTMLElement} HighlightedHTMLElement\n@typedef {import('highlight.js').BeforeHighlightContext} BeforeHighlightContext\n@typedef {import('highlight.js/private').MatchType} MatchType\n@typedef {import('highlight.js/private').KeywordData} KeywordData\n@typedef {import('highlight.js/private').EnhancedMatch} EnhancedMatch\n@typedef {import('highlight.js/private').AnnotatedError} AnnotatedError\n@typedef {import('highlight.js').AutoHighlightResult} AutoHighlightResult\n@typedef {import('highlight.js').HighlightOptions} HighlightOptions\n@typedef {import('highlight.js').HighlightResult} HighlightResult\n*/\n\n\nconst escape = escapeHTML;\nconst inherit = inherit$1;\nconst NO_MATCH = Symbol(\"nomatch\");\nconst MAX_KEYWORD_HITS = 7;\n\n/**\n * @param {any} hljs - object that is extended (legacy)\n * @returns {HLJSApi}\n */\nconst HLJS = function(hljs) {\n  // Global internal variables used within the highlight.js library.\n  /** @type {Record<string, Language>} */\n  const languages = Object.create(null);\n  /** @type {Record<string, string>} */\n  const aliases = Object.create(null);\n  /** @type {HLJSPlugin[]} */\n  const plugins = [];\n\n  // safe/production mode - swallows more errors, tries to keep running\n  // even if a single syntax or parse hits a fatal error\n  let SAFE_MODE = true;\n  const LANGUAGE_NOT_FOUND = \"Could not find the language '{}', did you forget to load/include a language module?\";\n  /** @type {Language} */\n  const PLAINTEXT_LANGUAGE = { disableAutodetect: true, name: 'Plain text', contains: [] };\n\n  // Global options used when within external APIs. This is modified when\n  // calling the `hljs.configure` function.\n  /** @type HLJSOptions */\n  let options = {\n    ignoreUnescapedHTML: false,\n    noHighlightRe: /^(no-?highlight)$/i,\n    languageDetectRe: /\\blang(?:uage)?-([\\w-]+)\\b/i,\n    classPrefix: 'hljs-',\n    cssSelector: 'pre code',\n    languages: null,\n    // beta configuration options, subject to change, welcome to discuss\n    // https://github.com/highlightjs/highlight.js/issues/1086\n    __emitter: TokenTreeEmitter\n  };\n\n  /* Utility functions */\n\n  /**\n   * Tests a language name to see if highlighting should be skipped\n   * @param {string} languageName\n   */\n  function shouldNotHighlight(languageName) {\n    return options.noHighlightRe.test(languageName);\n  }\n\n  /**\n   * @param {HighlightedHTMLElement} block - the HTML element to determine language for\n   */\n  function blockLanguage(block) {\n    let classes = block.className + ' ';\n\n    classes += block.parentNode ? block.parentNode.className : '';\n\n    // language-* takes precedence over non-prefixed class names.\n    const match = options.languageDetectRe.exec(classes);\n    if (match) {\n      const language = getLanguage(match[1]);\n      if (!language) {\n        warn(LANGUAGE_NOT_FOUND.replace(\"{}\", match[1]));\n        warn(\"Falling back to no-highlight mode for this block.\", block);\n      }\n      return language ? match[1] : 'no-highlight';\n    }\n\n    return classes\n      .split(/\\s+/)\n      .find((_class) => shouldNotHighlight(_class) || getLanguage(_class));\n  }\n\n  /**\n   * Core highlighting function.\n   *\n   * OLD API\n   * highlight(lang, code, ignoreIllegals, continuation)\n   *\n   * NEW API\n   * highlight(code, {lang, ignoreIllegals})\n   *\n   * @param {string} codeOrLanguageName - the language to use for highlighting\n   * @param {string | HighlightOptions} optionsOrCode - the code to highlight\n   * @param {boolean} [ignoreIllegals] - whether to ignore illegal matches, default is to bail\n   *\n   * @returns {HighlightResult} Result - an object that represents the result\n   * @property {string} language - the language name\n   * @property {number} relevance - the relevance score\n   * @property {string} value - the highlighted HTML code\n   * @property {string} code - the original raw code\n   * @property {CompiledMode} top - top of the current mode stack\n   * @property {boolean} illegal - indicates whether any illegal matches were found\n  */\n  function highlight(codeOrLanguageName, optionsOrCode, ignoreIllegals) {\n    let code = \"\";\n    let languageName = \"\";\n    if (typeof optionsOrCode === \"object\") {\n      code = codeOrLanguageName;\n      ignoreIllegals = optionsOrCode.ignoreIllegals;\n      languageName = optionsOrCode.language;\n    } else {\n      // old API\n      deprecated(\"10.7.0\", \"highlight(lang, code, ...args) has been deprecated.\");\n      deprecated(\"10.7.0\", \"Please use highlight(code, options) instead.\\nhttps://github.com/highlightjs/highlight.js/issues/2277\");\n      languageName = codeOrLanguageName;\n      code = optionsOrCode;\n    }\n\n    // https://github.com/highlightjs/highlight.js/issues/3149\n    // eslint-disable-next-line no-undefined\n    if (ignoreIllegals === undefined) { ignoreIllegals = true; }\n\n    /** @type {BeforeHighlightContext} */\n    const context = {\n      code,\n      language: languageName\n    };\n    // the plugin can change the desired language or the code to be highlighted\n    // just be changing the object it was passed\n    fire(\"before:highlight\", context);\n\n    // a before plugin can usurp the result completely by providing it's own\n    // in which case we don't even need to call highlight\n    const result = context.result\n      ? context.result\n      : _highlight(context.language, context.code, ignoreIllegals);\n\n    result.code = context.code;\n    // the plugin can change anything in result to suite it\n    fire(\"after:highlight\", result);\n\n    return result;\n  }\n\n  /**\n   * private highlight that's used internally and does not fire callbacks\n   *\n   * @param {string} languageName - the language to use for highlighting\n   * @param {string} codeToHighlight - the code to highlight\n   * @param {boolean?} [ignoreIllegals] - whether to ignore illegal matches, default is to bail\n   * @param {CompiledMode?} [continuation] - current continuation mode, if any\n   * @returns {HighlightResult} - result of the highlight operation\n  */\n  function _highlight(languageName, codeToHighlight, ignoreIllegals, continuation) {\n    const keywordHits = Object.create(null);\n\n    /**\n     * Return keyword data if a match is a keyword\n     * @param {CompiledMode} mode - current mode\n     * @param {string} matchText - the textual match\n     * @returns {KeywordData | false}\n     */\n    function keywordData(mode, matchText) {\n      return mode.keywords[matchText];\n    }\n\n    function processKeywords() {\n      if (!top.keywords) {\n        emitter.addText(modeBuffer);\n        return;\n      }\n\n      let lastIndex = 0;\n      top.keywordPatternRe.lastIndex = 0;\n      let match = top.keywordPatternRe.exec(modeBuffer);\n      let buf = \"\";\n\n      while (match) {\n        buf += modeBuffer.substring(lastIndex, match.index);\n        const word = language.case_insensitive ? match[0].toLowerCase() : match[0];\n        const data = keywordData(top, word);\n        if (data) {\n          const [kind, keywordRelevance] = data;\n          emitter.addText(buf);\n          buf = \"\";\n\n          keywordHits[word] = (keywordHits[word] || 0) + 1;\n          if (keywordHits[word] <= MAX_KEYWORD_HITS) relevance += keywordRelevance;\n          if (kind.startsWith(\"_\")) {\n            // _ implied for relevance only, do not highlight\n            // by applying a class name\n            buf += match[0];\n          } else {\n            const cssClass = language.classNameAliases[kind] || kind;\n            emitter.addKeyword(match[0], cssClass);\n          }\n        } else {\n          buf += match[0];\n        }\n        lastIndex = top.keywordPatternRe.lastIndex;\n        match = top.keywordPatternRe.exec(modeBuffer);\n      }\n      buf += modeBuffer.substr(lastIndex);\n      emitter.addText(buf);\n    }\n\n    function processSubLanguage() {\n      if (modeBuffer === \"\") return;\n      /** @type HighlightResult */\n      let result = null;\n\n      if (typeof top.subLanguage === 'string') {\n        if (!languages[top.subLanguage]) {\n          emitter.addText(modeBuffer);\n          return;\n        }\n        result = _highlight(top.subLanguage, modeBuffer, true, continuations[top.subLanguage]);\n        continuations[top.subLanguage] = /** @type {CompiledMode} */ (result._top);\n      } else {\n        result = highlightAuto(modeBuffer, top.subLanguage.length ? top.subLanguage : null);\n      }\n\n      // Counting embedded language score towards the host language may be disabled\n      // with zeroing the containing mode relevance. Use case in point is Markdown that\n      // allows XML everywhere and makes every XML snippet to have a much larger Markdown\n      // score.\n      if (top.relevance > 0) {\n        relevance += result.relevance;\n      }\n      emitter.addSublanguage(result._emitter, result.language);\n    }\n\n    function processBuffer() {\n      if (top.subLanguage != null) {\n        processSubLanguage();\n      } else {\n        processKeywords();\n      }\n      modeBuffer = '';\n    }\n\n    /**\n     * @param {CompiledMode} mode\n     * @param {RegExpMatchArray} match\n     */\n    function emitMultiClass(scope, match) {\n      let i = 1;\n      // eslint-disable-next-line no-undefined\n      while (match[i] !== undefined) {\n        if (!scope._emit[i]) { i++; continue; }\n        const klass = language.classNameAliases[scope[i]] || scope[i];\n        const text = match[i];\n        if (klass) {\n          emitter.addKeyword(text, klass);\n        } else {\n          modeBuffer = text;\n          processKeywords();\n          modeBuffer = \"\";\n        }\n        i++;\n      }\n    }\n\n    /**\n     * @param {CompiledMode} mode - new mode to start\n     * @param {RegExpMatchArray} match\n     */\n    function startNewMode(mode, match) {\n      if (mode.scope && typeof mode.scope === \"string\") {\n        emitter.openNode(language.classNameAliases[mode.scope] || mode.scope);\n      }\n      if (mode.beginScope) {\n        // beginScope just wraps the begin match itself in a scope\n        if (mode.beginScope._wrap) {\n          emitter.addKeyword(modeBuffer, language.classNameAliases[mode.beginScope._wrap] || mode.beginScope._wrap);\n          modeBuffer = \"\";\n        } else if (mode.beginScope._multi) {\n          // at this point modeBuffer should just be the match\n          emitMultiClass(mode.beginScope, match);\n          modeBuffer = \"\";\n        }\n      }\n\n      top = Object.create(mode, { parent: { value: top } });\n      return top;\n    }\n\n    /**\n     * @param {CompiledMode } mode - the mode to potentially end\n     * @param {RegExpMatchArray} match - the latest match\n     * @param {string} matchPlusRemainder - match plus remainder of content\n     * @returns {CompiledMode | void} - the next mode, or if void continue on in current mode\n     */\n    function endOfMode(mode, match, matchPlusRemainder) {\n      let matched = startsWith(mode.endRe, matchPlusRemainder);\n\n      if (matched) {\n        if (mode[\"on:end\"]) {\n          const resp = new Response(mode);\n          mode[\"on:end\"](match, resp);\n          if (resp.isMatchIgnored) matched = false;\n        }\n\n        if (matched) {\n          while (mode.endsParent && mode.parent) {\n            mode = mode.parent;\n          }\n          return mode;\n        }\n      }\n      // even if on:end fires an `ignore` it's still possible\n      // that we might trigger the end node because of a parent mode\n      if (mode.endsWithParent) {\n        return endOfMode(mode.parent, match, matchPlusRemainder);\n      }\n    }\n\n    /**\n     * Handle matching but then ignoring a sequence of text\n     *\n     * @param {string} lexeme - string containing full match text\n     */\n    function doIgnore(lexeme) {\n      if (top.matcher.regexIndex === 0) {\n        // no more regexes to potentially match here, so we move the cursor forward one\n        // space\n        modeBuffer += lexeme[0];\n        return 1;\n      } else {\n        // no need to move the cursor, we still have additional regexes to try and\n        // match at this very spot\n        resumeScanAtSamePosition = true;\n        return 0;\n      }\n    }\n\n    /**\n     * Handle the start of a new potential mode match\n     *\n     * @param {EnhancedMatch} match - the current match\n     * @returns {number} how far to advance the parse cursor\n     */\n    function doBeginMatch(match) {\n      const lexeme = match[0];\n      const newMode = match.rule;\n\n      const resp = new Response(newMode);\n      // first internal before callbacks, then the public ones\n      const beforeCallbacks = [newMode.__beforeBegin, newMode[\"on:begin\"]];\n      for (const cb of beforeCallbacks) {\n        if (!cb) continue;\n        cb(match, resp);\n        if (resp.isMatchIgnored) return doIgnore(lexeme);\n      }\n\n      if (newMode.skip) {\n        modeBuffer += lexeme;\n      } else {\n        if (newMode.excludeBegin) {\n          modeBuffer += lexeme;\n        }\n        processBuffer();\n        if (!newMode.returnBegin && !newMode.excludeBegin) {\n          modeBuffer = lexeme;\n        }\n      }\n      startNewMode(newMode, match);\n      return newMode.returnBegin ? 0 : lexeme.length;\n    }\n\n    /**\n     * Handle the potential end of mode\n     *\n     * @param {RegExpMatchArray} match - the current match\n     */\n    function doEndMatch(match) {\n      const lexeme = match[0];\n      const matchPlusRemainder = codeToHighlight.substr(match.index);\n\n      const endMode = endOfMode(top, match, matchPlusRemainder);\n      if (!endMode) { return NO_MATCH; }\n\n      const origin = top;\n      if (top.endScope && top.endScope._wrap) {\n        processBuffer();\n        emitter.addKeyword(lexeme, top.endScope._wrap);\n      } else if (top.endScope && top.endScope._multi) {\n        processBuffer();\n        emitMultiClass(top.endScope, match);\n      } else if (origin.skip) {\n        modeBuffer += lexeme;\n      } else {\n        if (!(origin.returnEnd || origin.excludeEnd)) {\n          modeBuffer += lexeme;\n        }\n        processBuffer();\n        if (origin.excludeEnd) {\n          modeBuffer = lexeme;\n        }\n      }\n      do {\n        if (top.scope) {\n          emitter.closeNode();\n        }\n        if (!top.skip && !top.subLanguage) {\n          relevance += top.relevance;\n        }\n        top = top.parent;\n      } while (top !== endMode.parent);\n      if (endMode.starts) {\n        startNewMode(endMode.starts, match);\n      }\n      return origin.returnEnd ? 0 : lexeme.length;\n    }\n\n    function processContinuations() {\n      const list = [];\n      for (let current = top; current !== language; current = current.parent) {\n        if (current.scope) {\n          list.unshift(current.scope);\n        }\n      }\n      list.forEach(item => emitter.openNode(item));\n    }\n\n    /** @type {{type?: MatchType, index?: number, rule?: Mode}}} */\n    let lastMatch = {};\n\n    /**\n     *  Process an individual match\n     *\n     * @param {string} textBeforeMatch - text preceding the match (since the last match)\n     * @param {EnhancedMatch} [match] - the match itself\n     */\n    function processLexeme(textBeforeMatch, match) {\n      const lexeme = match && match[0];\n\n      // add non-matched text to the current mode buffer\n      modeBuffer += textBeforeMatch;\n\n      if (lexeme == null) {\n        processBuffer();\n        return 0;\n      }\n\n      // we've found a 0 width match and we're stuck, so we need to advance\n      // this happens when we have badly behaved rules that have optional matchers to the degree that\n      // sometimes they can end up matching nothing at all\n      // Ref: https://github.com/highlightjs/highlight.js/issues/2140\n      if (lastMatch.type === \"begin\" && match.type === \"end\" && lastMatch.index === match.index && lexeme === \"\") {\n        // spit the \"skipped\" character that our regex choked on back into the output sequence\n        modeBuffer += codeToHighlight.slice(match.index, match.index + 1);\n        if (!SAFE_MODE) {\n          /** @type {AnnotatedError} */\n          const err = new Error(`0 width match regex (${languageName})`);\n          err.languageName = languageName;\n          err.badRule = lastMatch.rule;\n          throw err;\n        }\n        return 1;\n      }\n      lastMatch = match;\n\n      if (match.type === \"begin\") {\n        return doBeginMatch(match);\n      } else if (match.type === \"illegal\" && !ignoreIllegals) {\n        // illegal match, we do not continue processing\n        /** @type {AnnotatedError} */\n        const err = new Error('Illegal lexeme \"' + lexeme + '\" for mode \"' + (top.scope || '<unnamed>') + '\"');\n        err.mode = top;\n        throw err;\n      } else if (match.type === \"end\") {\n        const processed = doEndMatch(match);\n        if (processed !== NO_MATCH) {\n          return processed;\n        }\n      }\n\n      // edge case for when illegal matches $ (end of line) which is technically\n      // a 0 width match but not a begin/end match so it's not caught by the\n      // first handler (when ignoreIllegals is true)\n      if (match.type === \"illegal\" && lexeme === \"\") {\n        // advance so we aren't stuck in an infinite loop\n        return 1;\n      }\n\n      // infinite loops are BAD, this is a last ditch catch all. if we have a\n      // decent number of iterations yet our index (cursor position in our\n      // parsing) still 3x behind our index then something is very wrong\n      // so we bail\n      if (iterations > 100000 && iterations > match.index * 3) {\n        const err = new Error('potential infinite loop, way more iterations than matches');\n        throw err;\n      }\n\n      /*\n      Why might be find ourselves here?  An potential end match that was\n      triggered but could not be completed.  IE, `doEndMatch` returned NO_MATCH.\n      (this could be because a callback requests the match be ignored, etc)\n\n      This causes no real harm other than stopping a few times too many.\n      */\n\n      modeBuffer += lexeme;\n      return lexeme.length;\n    }\n\n    const language = getLanguage(languageName);\n    if (!language) {\n      error(LANGUAGE_NOT_FOUND.replace(\"{}\", languageName));\n      throw new Error('Unknown language: \"' + languageName + '\"');\n    }\n\n    const md = compileLanguage(language);\n    let result = '';\n    /** @type {CompiledMode} */\n    let top = continuation || md;\n    /** @type Record<string,CompiledMode> */\n    const continuations = {}; // keep continuations for sub-languages\n    const emitter = new options.__emitter(options);\n    processContinuations();\n    let modeBuffer = '';\n    let relevance = 0;\n    let index = 0;\n    let iterations = 0;\n    let resumeScanAtSamePosition = false;\n\n    try {\n      top.matcher.considerAll();\n\n      for (;;) {\n        iterations++;\n        if (resumeScanAtSamePosition) {\n          // only regexes not matched previously will now be\n          // considered for a potential match\n          resumeScanAtSamePosition = false;\n        } else {\n          top.matcher.considerAll();\n        }\n        top.matcher.lastIndex = index;\n\n        const match = top.matcher.exec(codeToHighlight);\n        // console.log(\"match\", match[0], match.rule && match.rule.begin)\n\n        if (!match) break;\n\n        const beforeMatch = codeToHighlight.substring(index, match.index);\n        const processedCount = processLexeme(beforeMatch, match);\n        index = match.index + processedCount;\n      }\n      processLexeme(codeToHighlight.substr(index));\n      emitter.closeAllNodes();\n      emitter.finalize();\n      result = emitter.toHTML();\n\n      return {\n        language: languageName,\n        value: result,\n        relevance: relevance,\n        illegal: false,\n        _emitter: emitter,\n        _top: top\n      };\n    } catch (err) {\n      if (err.message && err.message.includes('Illegal')) {\n        return {\n          language: languageName,\n          value: escape(codeToHighlight),\n          illegal: true,\n          relevance: 0,\n          _illegalBy: {\n            message: err.message,\n            index: index,\n            context: codeToHighlight.slice(index - 100, index + 100),\n            mode: err.mode,\n            resultSoFar: result\n          },\n          _emitter: emitter\n        };\n      } else if (SAFE_MODE) {\n        return {\n          language: languageName,\n          value: escape(codeToHighlight),\n          illegal: false,\n          relevance: 0,\n          errorRaised: err,\n          _emitter: emitter,\n          _top: top\n        };\n      } else {\n        throw err;\n      }\n    }\n  }\n\n  /**\n   * returns a valid highlight result, without actually doing any actual work,\n   * auto highlight starts with this and it's possible for small snippets that\n   * auto-detection may not find a better match\n   * @param {string} code\n   * @returns {HighlightResult}\n   */\n  function justTextHighlightResult(code) {\n    const result = {\n      value: escape(code),\n      illegal: false,\n      relevance: 0,\n      _top: PLAINTEXT_LANGUAGE,\n      _emitter: new options.__emitter(options)\n    };\n    result._emitter.addText(code);\n    return result;\n  }\n\n  /**\n  Highlighting with language detection. Accepts a string with the code to\n  highlight. Returns an object with the following properties:\n\n  - language (detected language)\n  - relevance (int)\n  - value (an HTML string with highlighting markup)\n  - secondBest (object with the same structure for second-best heuristically\n    detected language, may be absent)\n\n    @param {string} code\n    @param {Array<string>} [languageSubset]\n    @returns {AutoHighlightResult}\n  */\n  function highlightAuto(code, languageSubset) {\n    languageSubset = languageSubset || options.languages || Object.keys(languages);\n    const plaintext = justTextHighlightResult(code);\n\n    const results = languageSubset.filter(getLanguage).filter(autoDetection).map(name =>\n      _highlight(name, code, false)\n    );\n    results.unshift(plaintext); // plaintext is always an option\n\n    const sorted = results.sort((a, b) => {\n      // sort base on relevance\n      if (a.relevance !== b.relevance) return b.relevance - a.relevance;\n\n      // always award the tie to the base language\n      // ie if C++ and Arduino are tied, it's more likely to be C++\n      if (a.language && b.language) {\n        if (getLanguage(a.language).supersetOf === b.language) {\n          return 1;\n        } else if (getLanguage(b.language).supersetOf === a.language) {\n          return -1;\n        }\n      }\n\n      // otherwise say they are equal, which has the effect of sorting on\n      // relevance while preserving the original ordering - which is how ties\n      // have historically been settled, ie the language that comes first always\n      // wins in the case of a tie\n      return 0;\n    });\n\n    const [best, secondBest] = sorted;\n\n    /** @type {AutoHighlightResult} */\n    const result = best;\n    result.secondBest = secondBest;\n\n    return result;\n  }\n\n  /**\n   * Builds new class name for block given the language name\n   *\n   * @param {HTMLElement} element\n   * @param {string} [currentLang]\n   * @param {string} [resultLang]\n   */\n  function updateClassName(element, currentLang, resultLang) {\n    const language = (currentLang && aliases[currentLang]) || resultLang;\n\n    element.classList.add(\"hljs\");\n    element.classList.add(`language-${language}`);\n  }\n\n  /**\n   * Applies highlighting to a DOM node containing code.\n   *\n   * @param {HighlightedHTMLElement} element - the HTML element to highlight\n  */\n  function highlightElement(element) {\n    /** @type HTMLElement */\n    let node = null;\n    const language = blockLanguage(element);\n\n    if (shouldNotHighlight(language)) return;\n\n    fire(\"before:highlightElement\",\n      { el: element, language: language });\n\n    // we should be all text, no child nodes\n    if (!options.ignoreUnescapedHTML && element.children.length > 0) {\n      console.warn(\"One of your code blocks includes unescaped HTML. This is a potentially serious security risk.\");\n      console.warn(\"https://github.com/highlightjs/highlight.js/issues/2886\");\n      console.warn(element);\n    }\n\n    node = element;\n    const text = node.textContent;\n    const result = language ? highlight(text, { language, ignoreIllegals: true }) : highlightAuto(text);\n\n    element.innerHTML = result.value;\n    updateClassName(element, language, result.language);\n    element.result = {\n      language: result.language,\n      // TODO: remove with version 11.0\n      re: result.relevance,\n      relevance: result.relevance\n    };\n    if (result.secondBest) {\n      element.secondBest = {\n        language: result.secondBest.language,\n        relevance: result.secondBest.relevance\n      };\n    }\n\n    fire(\"after:highlightElement\", { el: element, result, text });\n  }\n\n  /**\n   * Updates highlight.js global options with the passed options\n   *\n   * @param {Partial<HLJSOptions>} userOptions\n   */\n  function configure(userOptions) {\n    options = inherit(options, userOptions);\n  }\n\n  // TODO: remove v12, deprecated\n  const initHighlighting = () => {\n    highlightAll();\n    deprecated(\"10.6.0\", \"initHighlighting() deprecated.  Use highlightAll() now.\");\n  };\n\n  // TODO: remove v12, deprecated\n  function initHighlightingOnLoad() {\n    highlightAll();\n    deprecated(\"10.6.0\", \"initHighlightingOnLoad() deprecated.  Use highlightAll() now.\");\n  }\n\n  let wantsHighlight = false;\n\n  /**\n   * auto-highlights all pre>code elements on the page\n   */\n  function highlightAll() {\n    // if we are called too early in the loading process\n    if (document.readyState === \"loading\") {\n      wantsHighlight = true;\n      return;\n    }\n\n    const blocks = document.querySelectorAll(options.cssSelector);\n    blocks.forEach(highlightElement);\n  }\n\n  function boot() {\n    // if a highlight was requested before DOM was loaded, do now\n    if (wantsHighlight) highlightAll();\n  }\n\n  // make sure we are in the browser environment\n  if (typeof window !== 'undefined' && window.addEventListener) {\n    window.addEventListener('DOMContentLoaded', boot, false);\n  }\n\n  /**\n   * Register a language grammar module\n   *\n   * @param {string} languageName\n   * @param {LanguageFn} languageDefinition\n   */\n  function registerLanguage(languageName, languageDefinition) {\n    let lang = null;\n    try {\n      lang = languageDefinition(hljs);\n    } catch (error$1) {\n      error(\"Language definition for '{}' could not be registered.\".replace(\"{}\", languageName));\n      // hard or soft error\n      if (!SAFE_MODE) { throw error$1; } else { error(error$1); }\n      // languages that have serious errors are replaced with essentially a\n      // \"plaintext\" stand-in so that the code blocks will still get normal\n      // css classes applied to them - and one bad language won't break the\n      // entire highlighter\n      lang = PLAINTEXT_LANGUAGE;\n    }\n    // give it a temporary name if it doesn't have one in the meta-data\n    if (!lang.name) lang.name = languageName;\n    languages[languageName] = lang;\n    lang.rawDefinition = languageDefinition.bind(null, hljs);\n\n    if (lang.aliases) {\n      registerAliases(lang.aliases, { languageName });\n    }\n  }\n\n  /**\n   * Remove a language grammar module\n   *\n   * @param {string} languageName\n   */\n  function unregisterLanguage(languageName) {\n    delete languages[languageName];\n    for (const alias of Object.keys(aliases)) {\n      if (aliases[alias] === languageName) {\n        delete aliases[alias];\n      }\n    }\n  }\n\n  /**\n   * @returns {string[]} List of language internal names\n   */\n  function listLanguages() {\n    return Object.keys(languages);\n  }\n\n  /**\n   * @param {string} name - name of the language to retrieve\n   * @returns {Language | undefined}\n   */\n  function getLanguage(name) {\n    name = (name || '').toLowerCase();\n    return languages[name] || languages[aliases[name]];\n  }\n\n  /**\n   *\n   * @param {string|string[]} aliasList - single alias or list of aliases\n   * @param {{languageName: string}} opts\n   */\n  function registerAliases(aliasList, { languageName }) {\n    if (typeof aliasList === 'string') {\n      aliasList = [aliasList];\n    }\n    aliasList.forEach(alias => { aliases[alias.toLowerCase()] = languageName; });\n  }\n\n  /**\n   * Determines if a given language has auto-detection enabled\n   * @param {string} name - name of the language\n   */\n  function autoDetection(name) {\n    const lang = getLanguage(name);\n    return lang && !lang.disableAutodetect;\n  }\n\n  /**\n   * Upgrades the old highlightBlock plugins to the new\n   * highlightElement API\n   * @param {HLJSPlugin} plugin\n   */\n  function upgradePluginAPI(plugin) {\n    // TODO: remove with v12\n    if (plugin[\"before:highlightBlock\"] && !plugin[\"before:highlightElement\"]) {\n      plugin[\"before:highlightElement\"] = (data) => {\n        plugin[\"before:highlightBlock\"](\n          Object.assign({ block: data.el }, data)\n        );\n      };\n    }\n    if (plugin[\"after:highlightBlock\"] && !plugin[\"after:highlightElement\"]) {\n      plugin[\"after:highlightElement\"] = (data) => {\n        plugin[\"after:highlightBlock\"](\n          Object.assign({ block: data.el }, data)\n        );\n      };\n    }\n  }\n\n  /**\n   * @param {HLJSPlugin} plugin\n   */\n  function addPlugin(plugin) {\n    upgradePluginAPI(plugin);\n    plugins.push(plugin);\n  }\n\n  /**\n   *\n   * @param {PluginEvent} event\n   * @param {any} args\n   */\n  function fire(event, args) {\n    const cb = event;\n    plugins.forEach(function(plugin) {\n      if (plugin[cb]) {\n        plugin[cb](args);\n      }\n    });\n  }\n\n  /**\n   * DEPRECATED\n   * @param {HighlightedHTMLElement} el\n   */\n  function deprecateHighlightBlock(el) {\n    deprecated(\"10.7.0\", \"highlightBlock will be removed entirely in v12.0\");\n    deprecated(\"10.7.0\", \"Please use highlightElement now.\");\n\n    return highlightElement(el);\n  }\n\n  /* Interface definition */\n  Object.assign(hljs, {\n    highlight,\n    highlightAuto,\n    highlightAll,\n    highlightElement,\n    // TODO: Remove with v12 API\n    highlightBlock: deprecateHighlightBlock,\n    configure,\n    initHighlighting,\n    initHighlightingOnLoad,\n    registerLanguage,\n    unregisterLanguage,\n    listLanguages,\n    getLanguage,\n    registerAliases,\n    autoDetection,\n    inherit,\n    addPlugin\n  });\n\n  hljs.debugMode = function() { SAFE_MODE = false; };\n  hljs.safeMode = function() { SAFE_MODE = true; };\n  hljs.versionString = version;\n\n  for (const key in MODES) {\n    // @ts-ignore\n    if (typeof MODES[key] === \"object\") {\n      // @ts-ignore\n      deepFreeze$1(MODES[key]);\n    }\n  }\n\n  // merge all the modes/regexes into our main object\n  Object.assign(hljs, MODES);\n\n  return hljs;\n};\n\n// export an \"instance\" of the highlighter\nvar highlight = HLJS({});\n\nmodule.exports = highlight;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFlBQVk7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGdCQUFnQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsZ0JBQWdCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSxZQUFZO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsYUFBYTtBQUMxQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBLGFBQWEsd0JBQXdCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVILGdDQUFnQztBQUNoQywrQkFBK0I7QUFDL0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsdUJBQXVCOztBQUV2QiIsInNvdXJjZXMiOlsid2VicGFjazovL21kYy1yZWFjdC8uL25vZGVfbW9kdWxlcy9oaWdobGlnaHQuanMvbGliL2NvcmUuanM/YzQyYSJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgZGVlcEZyZWV6ZUVzNiA9IHtleHBvcnRzOiB7fX07XG5cbmZ1bmN0aW9uIGRlZXBGcmVlemUob2JqKSB7XG4gICAgaWYgKG9iaiBpbnN0YW5jZW9mIE1hcCkge1xuICAgICAgICBvYmouY2xlYXIgPSBvYmouZGVsZXRlID0gb2JqLnNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignbWFwIGlzIHJlYWQtb25seScpO1xuICAgICAgICB9O1xuICAgIH0gZWxzZSBpZiAob2JqIGluc3RhbmNlb2YgU2V0KSB7XG4gICAgICAgIG9iai5hZGQgPSBvYmouY2xlYXIgPSBvYmouZGVsZXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzZXQgaXMgcmVhZC1vbmx5Jyk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gRnJlZXplIHNlbGZcbiAgICBPYmplY3QuZnJlZXplKG9iaik7XG5cbiAgICBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhvYmopLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgdmFyIHByb3AgPSBvYmpbbmFtZV07XG5cbiAgICAgICAgLy8gRnJlZXplIHByb3AgaWYgaXQgaXMgYW4gb2JqZWN0XG4gICAgICAgIGlmICh0eXBlb2YgcHJvcCA9PSAnb2JqZWN0JyAmJiAhT2JqZWN0LmlzRnJvemVuKHByb3ApKSB7XG4gICAgICAgICAgICBkZWVwRnJlZXplKHByb3ApO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gb2JqO1xufVxuXG5kZWVwRnJlZXplRXM2LmV4cG9ydHMgPSBkZWVwRnJlZXplO1xuZGVlcEZyZWV6ZUVzNi5leHBvcnRzLmRlZmF1bHQgPSBkZWVwRnJlZXplO1xuXG52YXIgZGVlcEZyZWV6ZSQxID0gZGVlcEZyZWV6ZUVzNi5leHBvcnRzO1xuXG4vKiogQHR5cGVkZWYge2ltcG9ydCgnaGlnaGxpZ2h0LmpzJykuQ2FsbGJhY2tSZXNwb25zZX0gQ2FsbGJhY2tSZXNwb25zZSAqL1xuLyoqIEB0eXBlZGVmIHtpbXBvcnQoJ2hpZ2hsaWdodC5qcycpLkNvbXBpbGVkTW9kZX0gQ29tcGlsZWRNb2RlICovXG4vKiogQGltcGxlbWVudHMgQ2FsbGJhY2tSZXNwb25zZSAqL1xuXG5jbGFzcyBSZXNwb25zZSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge0NvbXBpbGVkTW9kZX0gbW9kZVxuICAgKi9cbiAgY29uc3RydWN0b3IobW9kZSkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlZmluZWRcbiAgICBpZiAobW9kZS5kYXRhID09PSB1bmRlZmluZWQpIG1vZGUuZGF0YSA9IHt9O1xuXG4gICAgdGhpcy5kYXRhID0gbW9kZS5kYXRhO1xuICAgIHRoaXMuaXNNYXRjaElnbm9yZWQgPSBmYWxzZTtcbiAgfVxuXG4gIGlnbm9yZU1hdGNoKCkge1xuICAgIHRoaXMuaXNNYXRjaElnbm9yZWQgPSB0cnVlO1xuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBlc2NhcGVIVE1MKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZVxuICAgIC5yZXBsYWNlKC8mL2csICcmYW1wOycpXG4gICAgLnJlcGxhY2UoLzwvZywgJyZsdDsnKVxuICAgIC5yZXBsYWNlKC8+L2csICcmZ3Q7JylcbiAgICAucmVwbGFjZSgvXCIvZywgJyZxdW90OycpXG4gICAgLnJlcGxhY2UoLycvZywgJyYjeDI3OycpO1xufVxuXG4vKipcbiAqIHBlcmZvcm1zIGEgc2hhbGxvdyBtZXJnZSBvZiBtdWx0aXBsZSBvYmplY3RzIGludG8gb25lXG4gKlxuICogQHRlbXBsYXRlIFRcbiAqIEBwYXJhbSB7VH0gb3JpZ2luYWxcbiAqIEBwYXJhbSB7UmVjb3JkPHN0cmluZyxhbnk+W119IG9iamVjdHNcbiAqIEByZXR1cm5zIHtUfSBhIHNpbmdsZSBuZXcgb2JqZWN0XG4gKi9cbmZ1bmN0aW9uIGluaGVyaXQkMShvcmlnaW5hbCwgLi4ub2JqZWN0cykge1xuICAvKiogQHR5cGUgUmVjb3JkPHN0cmluZyxhbnk+ICovXG4gIGNvbnN0IHJlc3VsdCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbiAgZm9yIChjb25zdCBrZXkgaW4gb3JpZ2luYWwpIHtcbiAgICByZXN1bHRba2V5XSA9IG9yaWdpbmFsW2tleV07XG4gIH1cbiAgb2JqZWN0cy5mb3JFYWNoKGZ1bmN0aW9uKG9iaikge1xuICAgIGZvciAoY29uc3Qga2V5IGluIG9iaikge1xuICAgICAgcmVzdWx0W2tleV0gPSBvYmpba2V5XTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gLyoqIEB0eXBlIHtUfSAqLyAocmVzdWx0KTtcbn1cblxuLyoqXG4gKiBAdHlwZWRlZiB7b2JqZWN0fSBSZW5kZXJlclxuICogQHByb3BlcnR5IHsodGV4dDogc3RyaW5nKSA9PiB2b2lkfSBhZGRUZXh0XG4gKiBAcHJvcGVydHkgeyhub2RlOiBOb2RlKSA9PiB2b2lkfSBvcGVuTm9kZVxuICogQHByb3BlcnR5IHsobm9kZTogTm9kZSkgPT4gdm9pZH0gY2xvc2VOb2RlXG4gKiBAcHJvcGVydHkgeygpID0+IHN0cmluZ30gdmFsdWVcbiAqL1xuXG4vKiogQHR5cGVkZWYge3traW5kPzogc3RyaW5nLCBzdWJsYW5ndWFnZT86IGJvb2xlYW59fSBOb2RlICovXG4vKiogQHR5cGVkZWYge3t3YWxrOiAocjogUmVuZGVyZXIpID0+IHZvaWR9fSBUcmVlICovXG4vKiogKi9cblxuY29uc3QgU1BBTl9DTE9TRSA9ICc8L3NwYW4+JztcblxuLyoqXG4gKiBEZXRlcm1pbmVzIGlmIGEgbm9kZSBuZWVkcyB0byBiZSB3cmFwcGVkIGluIDxzcGFuPlxuICpcbiAqIEBwYXJhbSB7Tm9kZX0gbm9kZSAqL1xuY29uc3QgZW1pdHNXcmFwcGluZ1RhZ3MgPSAobm9kZSkgPT4ge1xuICByZXR1cm4gISFub2RlLmtpbmQ7XG59O1xuXG4vKipcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICogQHBhcmFtIHt7cHJlZml4OnN0cmluZ319IG9wdGlvbnNcbiAqL1xuY29uc3QgZXhwYW5kU2NvcGVOYW1lID0gKG5hbWUsIHsgcHJlZml4IH0pID0+IHtcbiAgaWYgKG5hbWUuaW5jbHVkZXMoXCIuXCIpKSB7XG4gICAgY29uc3QgcGllY2VzID0gbmFtZS5zcGxpdChcIi5cIik7XG4gICAgcmV0dXJuIFtcbiAgICAgIGAke3ByZWZpeH0ke3BpZWNlcy5zaGlmdCgpfWAsXG4gICAgICAuLi4ocGllY2VzLm1hcCgoeCwgaSkgPT4gYCR7eH0ke1wiX1wiLnJlcGVhdChpICsgMSl9YCkpXG4gICAgXS5qb2luKFwiIFwiKTtcbiAgfVxuICByZXR1cm4gYCR7cHJlZml4fSR7bmFtZX1gO1xufTtcblxuLyoqIEB0eXBlIHtSZW5kZXJlcn0gKi9cbmNsYXNzIEhUTUxSZW5kZXJlciB7XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IEhUTUxSZW5kZXJlclxuICAgKlxuICAgKiBAcGFyYW0ge1RyZWV9IHBhcnNlVHJlZSAtIHRoZSBwYXJzZSB0cmVlIChtdXN0IHN1cHBvcnQgYHdhbGtgIEFQSSlcbiAgICogQHBhcmFtIHt7Y2xhc3NQcmVmaXg6IHN0cmluZ319IG9wdGlvbnNcbiAgICovXG4gIGNvbnN0cnVjdG9yKHBhcnNlVHJlZSwgb3B0aW9ucykge1xuICAgIHRoaXMuYnVmZmVyID0gXCJcIjtcbiAgICB0aGlzLmNsYXNzUHJlZml4ID0gb3B0aW9ucy5jbGFzc1ByZWZpeDtcbiAgICBwYXJzZVRyZWUud2Fsayh0aGlzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIHRleHRzIHRvIHRoZSBvdXRwdXQgc3RyZWFtXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0ICovXG4gIGFkZFRleHQodGV4dCkge1xuICAgIHRoaXMuYnVmZmVyICs9IGVzY2FwZUhUTUwodGV4dCk7XG4gIH1cblxuICAvKipcbiAgICogQWRkcyBhIG5vZGUgb3BlbiB0byB0aGUgb3V0cHV0IHN0cmVhbSAoaWYgbmVlZGVkKVxuICAgKlxuICAgKiBAcGFyYW0ge05vZGV9IG5vZGUgKi9cbiAgb3Blbk5vZGUobm9kZSkge1xuICAgIGlmICghZW1pdHNXcmFwcGluZ1RhZ3Mobm9kZSkpIHJldHVybjtcblxuICAgIGxldCBzY29wZSA9IG5vZGUua2luZDtcbiAgICBpZiAobm9kZS5zdWJsYW5ndWFnZSkge1xuICAgICAgc2NvcGUgPSBgbGFuZ3VhZ2UtJHtzY29wZX1gO1xuICAgIH0gZWxzZSB7XG4gICAgICBzY29wZSA9IGV4cGFuZFNjb3BlTmFtZShzY29wZSwgeyBwcmVmaXg6IHRoaXMuY2xhc3NQcmVmaXggfSk7XG4gICAgfVxuICAgIHRoaXMuc3BhbihzY29wZSk7XG4gIH1cblxuICAvKipcbiAgICogQWRkcyBhIG5vZGUgY2xvc2UgdG8gdGhlIG91dHB1dCBzdHJlYW0gKGlmIG5lZWRlZClcbiAgICpcbiAgICogQHBhcmFtIHtOb2RlfSBub2RlICovXG4gIGNsb3NlTm9kZShub2RlKSB7XG4gICAgaWYgKCFlbWl0c1dyYXBwaW5nVGFncyhub2RlKSkgcmV0dXJuO1xuXG4gICAgdGhpcy5idWZmZXIgKz0gU1BBTl9DTE9TRTtcbiAgfVxuXG4gIC8qKlxuICAgKiByZXR1cm5zIHRoZSBhY2N1bXVsYXRlZCBidWZmZXJcbiAgKi9cbiAgdmFsdWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuYnVmZmVyO1xuICB9XG5cbiAgLy8gaGVscGVyc1xuXG4gIC8qKlxuICAgKiBCdWlsZHMgYSBzcGFuIGVsZW1lbnRcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNsYXNzTmFtZSAqL1xuICBzcGFuKGNsYXNzTmFtZSkge1xuICAgIHRoaXMuYnVmZmVyICs9IGA8c3BhbiBjbGFzcz1cIiR7Y2xhc3NOYW1lfVwiPmA7XG4gIH1cbn1cblxuLyoqIEB0eXBlZGVmIHt7a2luZD86IHN0cmluZywgc3VibGFuZ3VhZ2U/OiBib29sZWFuLCBjaGlsZHJlbjogTm9kZVtdfSB8IHN0cmluZ30gTm9kZSAqL1xuLyoqIEB0eXBlZGVmIHt7a2luZD86IHN0cmluZywgc3VibGFuZ3VhZ2U/OiBib29sZWFuLCBjaGlsZHJlbjogTm9kZVtdfSB9IERhdGFOb2RlICovXG4vKiogQHR5cGVkZWYge2ltcG9ydCgnaGlnaGxpZ2h0LmpzJykuRW1pdHRlcn0gRW1pdHRlciAqL1xuLyoqICAqL1xuXG5jbGFzcyBUb2tlblRyZWUge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICAvKiogQHR5cGUgRGF0YU5vZGUgKi9cbiAgICB0aGlzLnJvb3ROb2RlID0geyBjaGlsZHJlbjogW10gfTtcbiAgICB0aGlzLnN0YWNrID0gW3RoaXMucm9vdE5vZGVdO1xuICB9XG5cbiAgZ2V0IHRvcCgpIHtcbiAgICByZXR1cm4gdGhpcy5zdGFja1t0aGlzLnN0YWNrLmxlbmd0aCAtIDFdO1xuICB9XG5cbiAgZ2V0IHJvb3QoKSB7IHJldHVybiB0aGlzLnJvb3ROb2RlOyB9XG5cbiAgLyoqIEBwYXJhbSB7Tm9kZX0gbm9kZSAqL1xuICBhZGQobm9kZSkge1xuICAgIHRoaXMudG9wLmNoaWxkcmVuLnB1c2gobm9kZSk7XG4gIH1cblxuICAvKiogQHBhcmFtIHtzdHJpbmd9IGtpbmQgKi9cbiAgb3Blbk5vZGUoa2luZCkge1xuICAgIC8qKiBAdHlwZSBOb2RlICovXG4gICAgY29uc3Qgbm9kZSA9IHsga2luZCwgY2hpbGRyZW46IFtdIH07XG4gICAgdGhpcy5hZGQobm9kZSk7XG4gICAgdGhpcy5zdGFjay5wdXNoKG5vZGUpO1xuICB9XG5cbiAgY2xvc2VOb2RlKCkge1xuICAgIGlmICh0aGlzLnN0YWNrLmxlbmd0aCA+IDEpIHtcbiAgICAgIHJldHVybiB0aGlzLnN0YWNrLnBvcCgpO1xuICAgIH1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5kZWZpbmVkXG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuXG4gIGNsb3NlQWxsTm9kZXMoKSB7XG4gICAgd2hpbGUgKHRoaXMuY2xvc2VOb2RlKCkpO1xuICB9XG5cbiAgdG9KU09OKCkge1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh0aGlzLnJvb3ROb2RlLCBudWxsLCA0KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAdHlwZWRlZiB7IGltcG9ydChcIi4vaHRtbF9yZW5kZXJlclwiKS5SZW5kZXJlciB9IFJlbmRlcmVyXG4gICAqIEBwYXJhbSB7UmVuZGVyZXJ9IGJ1aWxkZXJcbiAgICovXG4gIHdhbGsoYnVpbGRlcikge1xuICAgIC8vIHRoaXMgZG9lcyBub3RcbiAgICByZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci5fd2FsayhidWlsZGVyLCB0aGlzLnJvb3ROb2RlKTtcbiAgICAvLyB0aGlzIHdvcmtzXG4gICAgLy8gcmV0dXJuIFRva2VuVHJlZS5fd2FsayhidWlsZGVyLCB0aGlzLnJvb3ROb2RlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1JlbmRlcmVyfSBidWlsZGVyXG4gICAqIEBwYXJhbSB7Tm9kZX0gbm9kZVxuICAgKi9cbiAgc3RhdGljIF93YWxrKGJ1aWxkZXIsIG5vZGUpIHtcbiAgICBpZiAodHlwZW9mIG5vZGUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIGJ1aWxkZXIuYWRkVGV4dChub2RlKTtcbiAgICB9IGVsc2UgaWYgKG5vZGUuY2hpbGRyZW4pIHtcbiAgICAgIGJ1aWxkZXIub3Blbk5vZGUobm9kZSk7XG4gICAgICBub2RlLmNoaWxkcmVuLmZvckVhY2goKGNoaWxkKSA9PiB0aGlzLl93YWxrKGJ1aWxkZXIsIGNoaWxkKSk7XG4gICAgICBidWlsZGVyLmNsb3NlTm9kZShub2RlKTtcbiAgICB9XG4gICAgcmV0dXJuIGJ1aWxkZXI7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtOb2RlfSBub2RlXG4gICAqL1xuICBzdGF0aWMgX2NvbGxhcHNlKG5vZGUpIHtcbiAgICBpZiAodHlwZW9mIG5vZGUgPT09IFwic3RyaW5nXCIpIHJldHVybjtcbiAgICBpZiAoIW5vZGUuY2hpbGRyZW4pIHJldHVybjtcblxuICAgIGlmIChub2RlLmNoaWxkcmVuLmV2ZXJ5KGVsID0+IHR5cGVvZiBlbCA9PT0gXCJzdHJpbmdcIikpIHtcbiAgICAgIC8vIG5vZGUudGV4dCA9IG5vZGUuY2hpbGRyZW4uam9pbihcIlwiKTtcbiAgICAgIC8vIGRlbGV0ZSBub2RlLmNoaWxkcmVuO1xuICAgICAgbm9kZS5jaGlsZHJlbiA9IFtub2RlLmNoaWxkcmVuLmpvaW4oXCJcIildO1xuICAgIH0gZWxzZSB7XG4gICAgICBub2RlLmNoaWxkcmVuLmZvckVhY2goKGNoaWxkKSA9PiB7XG4gICAgICAgIFRva2VuVHJlZS5fY29sbGFwc2UoY2hpbGQpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICBDdXJyZW50bHkgdGhpcyBpcyBhbGwgcHJpdmF0ZSBBUEksIGJ1dCB0aGlzIGlzIHRoZSBtaW5pbWFsIEFQSSBuZWNlc3NhcnlcbiAgdGhhdCBhbiBFbWl0dGVyIG11c3QgaW1wbGVtZW50IHRvIGZ1bGx5IHN1cHBvcnQgdGhlIHBhcnNlci5cblxuICBNaW5pbWFsIGludGVyZmFjZTpcblxuICAtIGFkZEtleXdvcmQodGV4dCwga2luZClcbiAgLSBhZGRUZXh0KHRleHQpXG4gIC0gYWRkU3VibGFuZ3VhZ2UoZW1pdHRlciwgc3ViTGFuZ3VhZ2VOYW1lKVxuICAtIGZpbmFsaXplKClcbiAgLSBvcGVuTm9kZShraW5kKVxuICAtIGNsb3NlTm9kZSgpXG4gIC0gY2xvc2VBbGxOb2RlcygpXG4gIC0gdG9IVE1MKClcblxuKi9cblxuLyoqXG4gKiBAaW1wbGVtZW50cyB7RW1pdHRlcn1cbiAqL1xuY2xhc3MgVG9rZW5UcmVlRW1pdHRlciBleHRlbmRzIFRva2VuVHJlZSB7XG4gIC8qKlxuICAgKiBAcGFyYW0geyp9IG9wdGlvbnNcbiAgICovXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRleHRcbiAgICogQHBhcmFtIHtzdHJpbmd9IGtpbmRcbiAgICovXG4gIGFkZEtleXdvcmQodGV4dCwga2luZCkge1xuICAgIGlmICh0ZXh0ID09PSBcIlwiKSB7IHJldHVybjsgfVxuXG4gICAgdGhpcy5vcGVuTm9kZShraW5kKTtcbiAgICB0aGlzLmFkZFRleHQodGV4dCk7XG4gICAgdGhpcy5jbG9zZU5vZGUoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dFxuICAgKi9cbiAgYWRkVGV4dCh0ZXh0KSB7XG4gICAgaWYgKHRleHQgPT09IFwiXCIpIHsgcmV0dXJuOyB9XG5cbiAgICB0aGlzLmFkZCh0ZXh0KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0VtaXR0ZXIgJiB7cm9vdDogRGF0YU5vZGV9fSBlbWl0dGVyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAqL1xuICBhZGRTdWJsYW5ndWFnZShlbWl0dGVyLCBuYW1lKSB7XG4gICAgLyoqIEB0eXBlIERhdGFOb2RlICovXG4gICAgY29uc3Qgbm9kZSA9IGVtaXR0ZXIucm9vdDtcbiAgICBub2RlLmtpbmQgPSBuYW1lO1xuICAgIG5vZGUuc3VibGFuZ3VhZ2UgPSB0cnVlO1xuICAgIHRoaXMuYWRkKG5vZGUpO1xuICB9XG5cbiAgdG9IVE1MKCkge1xuICAgIGNvbnN0IHJlbmRlcmVyID0gbmV3IEhUTUxSZW5kZXJlcih0aGlzLCB0aGlzLm9wdGlvbnMpO1xuICAgIHJldHVybiByZW5kZXJlci52YWx1ZSgpO1xuICB9XG5cbiAgZmluYWxpemUoKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVcbiAqIEByZXR1cm5zIHtSZWdFeHB9XG4gKiAqL1xuXG4vKipcbiAqIEBwYXJhbSB7UmVnRXhwIHwgc3RyaW5nIH0gcmVcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIHNvdXJjZShyZSkge1xuICBpZiAoIXJlKSByZXR1cm4gbnVsbDtcbiAgaWYgKHR5cGVvZiByZSA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIHJlO1xuXG4gIHJldHVybiByZS5zb3VyY2U7XG59XG5cbi8qKlxuICogQHBhcmFtIHtSZWdFeHAgfCBzdHJpbmcgfSByZVxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gbG9va2FoZWFkKHJlKSB7XG4gIHJldHVybiBjb25jYXQoJyg/PScsIHJlLCAnKScpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7Li4uKFJlZ0V4cCB8IHN0cmluZykgfSBhcmdzXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBjb25jYXQoLi4uYXJncykge1xuICBjb25zdCBqb2luZWQgPSBhcmdzLm1hcCgoeCkgPT4gc291cmNlKHgpKS5qb2luKFwiXCIpO1xuICByZXR1cm4gam9pbmVkO1xufVxuXG5mdW5jdGlvbiBzdHJpcE9wdGlvbnNGcm9tQXJncyhhcmdzKSB7XG4gIGNvbnN0IG9wdHMgPSBhcmdzW2FyZ3MubGVuZ3RoIC0gMV07XG5cbiAgaWYgKHR5cGVvZiBvcHRzID09PSAnb2JqZWN0JyAmJiBvcHRzLmNvbnN0cnVjdG9yID09PSBPYmplY3QpIHtcbiAgICBhcmdzLnNwbGljZShhcmdzLmxlbmd0aCAtIDEsIDEpO1xuICAgIHJldHVybiBvcHRzO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB7fTtcbiAgfVxufVxuXG4vKipcbiAqIEFueSBvZiB0aGUgcGFzc2VkIGV4cHJlc3NzaW9ucyBtYXkgbWF0Y2hcbiAqXG4gKiBDcmVhdGVzIGEgaHVnZSB0aGlzIHwgdGhpcyB8IHRoYXQgfCB0aGF0IG1hdGNoXG4gKiBAcGFyYW0geyhSZWdFeHAgfCBzdHJpbmcpW10gfSBhcmdzXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBlaXRoZXIoLi4uYXJncykge1xuICBjb25zdCBvcHRzID0gc3RyaXBPcHRpb25zRnJvbUFyZ3MoYXJncyk7XG4gIGNvbnN0IGpvaW5lZCA9ICcoJyArXG4gICAgKG9wdHMuY2FwdHVyZSA/IFwiXCIgOiBcIj86XCIpICtcbiAgICBhcmdzLm1hcCgoeCkgPT4gc291cmNlKHgpKS5qb2luKFwifFwiKSArIFwiKVwiO1xuICByZXR1cm4gam9pbmVkO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7UmVnRXhwfSByZVxuICogQHJldHVybnMge251bWJlcn1cbiAqL1xuZnVuY3Rpb24gY291bnRNYXRjaEdyb3VwcyhyZSkge1xuICByZXR1cm4gKG5ldyBSZWdFeHAocmUudG9TdHJpbmcoKSArICd8JykpLmV4ZWMoJycpLmxlbmd0aCAtIDE7XG59XG5cbi8qKlxuICogRG9lcyBsZXhlbWUgc3RhcnQgd2l0aCBhIHJlZ3VsYXIgZXhwcmVzc2lvbiBtYXRjaCBhdCB0aGUgYmVnaW5uaW5nXG4gKiBAcGFyYW0ge1JlZ0V4cH0gcmVcbiAqIEBwYXJhbSB7c3RyaW5nfSBsZXhlbWVcbiAqL1xuZnVuY3Rpb24gc3RhcnRzV2l0aChyZSwgbGV4ZW1lKSB7XG4gIGNvbnN0IG1hdGNoID0gcmUgJiYgcmUuZXhlYyhsZXhlbWUpO1xuICByZXR1cm4gbWF0Y2ggJiYgbWF0Y2guaW5kZXggPT09IDA7XG59XG5cbi8vIEJBQ0tSRUZfUkUgbWF0Y2hlcyBhbiBvcGVuIHBhcmVudGhlc2lzIG9yIGJhY2tyZWZlcmVuY2UuIFRvIGF2b2lkXG4vLyBhbiBpbmNvcnJlY3QgcGFyc2UsIGl0IGFkZGl0aW9uYWxseSBtYXRjaGVzIHRoZSBmb2xsb3dpbmc6XG4vLyAtIFsuLi5dIGVsZW1lbnRzLCB3aGVyZSB0aGUgbWVhbmluZyBvZiBwYXJlbnRoZXNlcyBhbmQgZXNjYXBlcyBjaGFuZ2Vcbi8vIC0gb3RoZXIgZXNjYXBlIHNlcXVlbmNlcywgc28gd2UgZG8gbm90IG1pc3BhcnNlIGVzY2FwZSBzZXF1ZW5jZXMgYXNcbi8vICAgaW50ZXJlc3RpbmcgZWxlbWVudHNcbi8vIC0gbm9uLW1hdGNoaW5nIG9yIGxvb2thaGVhZCBwYXJlbnRoZXNlcywgd2hpY2ggZG8gbm90IGNhcHR1cmUuIFRoZXNlXG4vLyAgIGZvbGxvdyB0aGUgJygnIHdpdGggYSAnPycuXG5jb25zdCBCQUNLUkVGX1JFID0gL1xcWyg/OlteXFxcXFxcXV18XFxcXC4pKlxcXXxcXChcXD8/fFxcXFwoWzEtOV1bMC05XSopfFxcXFwuLztcblxuLy8gKipJTlRFUk5BTCoqIE5vdCBpbnRlbmRlZCBmb3Igb3V0c2lkZSB1c2FnZVxuLy8gam9pbiBsb2dpY2FsbHkgY29tcHV0ZXMgcmVnZXhwcy5qb2luKHNlcGFyYXRvciksIGJ1dCBmaXhlcyB0aGVcbi8vIGJhY2tyZWZlcmVuY2VzIHNvIHRoZXkgY29udGludWUgdG8gbWF0Y2guXG4vLyBpdCBhbHNvIHBsYWNlcyBlYWNoIGluZGl2aWR1YWwgcmVndWxhciBleHByZXNzaW9uIGludG8gaXQncyBvd25cbi8vIG1hdGNoIGdyb3VwLCBrZWVwaW5nIHRyYWNrIG9mIHRoZSBzZXF1ZW5jaW5nIG9mIHRob3NlIG1hdGNoIGdyb3Vwc1xuLy8gaXMgY3VycmVudGx5IGFuIGV4ZXJjaXNlIGZvciB0aGUgY2FsbGVyLiA6LSlcbi8qKlxuICogQHBhcmFtIHsoc3RyaW5nIHwgUmVnRXhwKVtdfSByZWdleHBzXG4gKiBAcGFyYW0ge3tqb2luV2l0aDogc3RyaW5nfX0gb3B0c1xuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gX3Jld3JpdGVCYWNrcmVmZXJlbmNlcyhyZWdleHBzLCB7IGpvaW5XaXRoIH0pIHtcbiAgbGV0IG51bUNhcHR1cmVzID0gMDtcblxuICByZXR1cm4gcmVnZXhwcy5tYXAoKHJlZ2V4KSA9PiB7XG4gICAgbnVtQ2FwdHVyZXMgKz0gMTtcbiAgICBjb25zdCBvZmZzZXQgPSBudW1DYXB0dXJlcztcbiAgICBsZXQgcmUgPSBzb3VyY2UocmVnZXgpO1xuICAgIGxldCBvdXQgPSAnJztcblxuICAgIHdoaWxlIChyZS5sZW5ndGggPiAwKSB7XG4gICAgICBjb25zdCBtYXRjaCA9IEJBQ0tSRUZfUkUuZXhlYyhyZSk7XG4gICAgICBpZiAoIW1hdGNoKSB7XG4gICAgICAgIG91dCArPSByZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBvdXQgKz0gcmUuc3Vic3RyaW5nKDAsIG1hdGNoLmluZGV4KTtcbiAgICAgIHJlID0gcmUuc3Vic3RyaW5nKG1hdGNoLmluZGV4ICsgbWF0Y2hbMF0ubGVuZ3RoKTtcbiAgICAgIGlmIChtYXRjaFswXVswXSA9PT0gJ1xcXFwnICYmIG1hdGNoWzFdKSB7XG4gICAgICAgIC8vIEFkanVzdCB0aGUgYmFja3JlZmVyZW5jZS5cbiAgICAgICAgb3V0ICs9ICdcXFxcJyArIFN0cmluZyhOdW1iZXIobWF0Y2hbMV0pICsgb2Zmc2V0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG91dCArPSBtYXRjaFswXTtcbiAgICAgICAgaWYgKG1hdGNoWzBdID09PSAnKCcpIHtcbiAgICAgICAgICBudW1DYXB0dXJlcysrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvdXQ7XG4gIH0pLm1hcChyZSA9PiBgKCR7cmV9KWApLmpvaW4oam9pbldpdGgpO1xufVxuXG4vKiogQHR5cGVkZWYge2ltcG9ydCgnaGlnaGxpZ2h0LmpzJykuTW9kZX0gTW9kZSAqL1xuLyoqIEB0eXBlZGVmIHtpbXBvcnQoJ2hpZ2hsaWdodC5qcycpLk1vZGVDYWxsYmFja30gTW9kZUNhbGxiYWNrICovXG5cbi8vIENvbW1vbiByZWdleHBzXG5jb25zdCBNQVRDSF9OT1RISU5HX1JFID0gL1xcYlxcQi87XG5jb25zdCBJREVOVF9SRSA9ICdbYS16QS1aXVxcXFx3Kic7XG5jb25zdCBVTkRFUlNDT1JFX0lERU5UX1JFID0gJ1thLXpBLVpfXVxcXFx3Kic7XG5jb25zdCBOVU1CRVJfUkUgPSAnXFxcXGJcXFxcZCsoXFxcXC5cXFxcZCspPyc7XG5jb25zdCBDX05VTUJFUl9SRSA9ICcoLT8pKFxcXFxiMFt4WF1bYS1mQS1GMC05XSt8KFxcXFxiXFxcXGQrKFxcXFwuXFxcXGQqKT98XFxcXC5cXFxcZCspKFtlRV1bLStdP1xcXFxkKyk/KSc7IC8vIDB4Li4uLCAwLi4uLCBkZWNpbWFsLCBmbG9hdFxuY29uc3QgQklOQVJZX05VTUJFUl9SRSA9ICdcXFxcYigwYlswMV0rKSc7IC8vIDBiLi4uXG5jb25zdCBSRV9TVEFSVEVSU19SRSA9ICchfCE9fCE9PXwlfCU9fCZ8JiZ8Jj18XFxcXCp8XFxcXCo9fFxcXFwrfFxcXFwrPXwsfC18LT18Lz18L3w6fDt8PDx8PDw9fDw9fDx8PT09fD09fD18Pj4+PXw+Pj18Pj18Pj4+fD4+fD58XFxcXD98XFxcXFt8XFxcXHt8XFxcXCh8XFxcXF58XFxcXF49fFxcXFx8fFxcXFx8PXxcXFxcfFxcXFx8fH4nO1xuXG4vKipcbiogQHBhcmFtIHsgUGFydGlhbDxNb2RlPiAmIHtiaW5hcnk/OiBzdHJpbmcgfCBSZWdFeHB9IH0gb3B0c1xuKi9cbmNvbnN0IFNIRUJBTkcgPSAob3B0cyA9IHt9KSA9PiB7XG4gIGNvbnN0IGJlZ2luU2hlYmFuZyA9IC9eIyFbIF0qXFwvLztcbiAgaWYgKG9wdHMuYmluYXJ5KSB7XG4gICAgb3B0cy5iZWdpbiA9IGNvbmNhdChcbiAgICAgIGJlZ2luU2hlYmFuZyxcbiAgICAgIC8uKlxcYi8sXG4gICAgICBvcHRzLmJpbmFyeSxcbiAgICAgIC9cXGIuKi8pO1xuICB9XG4gIHJldHVybiBpbmhlcml0JDEoe1xuICAgIHNjb3BlOiAnbWV0YScsXG4gICAgYmVnaW46IGJlZ2luU2hlYmFuZyxcbiAgICBlbmQ6IC8kLyxcbiAgICByZWxldmFuY2U6IDAsXG4gICAgLyoqIEB0eXBlIHtNb2RlQ2FsbGJhY2t9ICovXG4gICAgXCJvbjpiZWdpblwiOiAobSwgcmVzcCkgPT4ge1xuICAgICAgaWYgKG0uaW5kZXggIT09IDApIHJlc3AuaWdub3JlTWF0Y2goKTtcbiAgICB9XG4gIH0sIG9wdHMpO1xufTtcblxuLy8gQ29tbW9uIG1vZGVzXG5jb25zdCBCQUNLU0xBU0hfRVNDQVBFID0ge1xuICBiZWdpbjogJ1xcXFxcXFxcW1xcXFxzXFxcXFNdJywgcmVsZXZhbmNlOiAwXG59O1xuY29uc3QgQVBPU19TVFJJTkdfTU9ERSA9IHtcbiAgc2NvcGU6ICdzdHJpbmcnLFxuICBiZWdpbjogJ1xcJycsXG4gIGVuZDogJ1xcJycsXG4gIGlsbGVnYWw6ICdcXFxcbicsXG4gIGNvbnRhaW5zOiBbQkFDS1NMQVNIX0VTQ0FQRV1cbn07XG5jb25zdCBRVU9URV9TVFJJTkdfTU9ERSA9IHtcbiAgc2NvcGU6ICdzdHJpbmcnLFxuICBiZWdpbjogJ1wiJyxcbiAgZW5kOiAnXCInLFxuICBpbGxlZ2FsOiAnXFxcXG4nLFxuICBjb250YWluczogW0JBQ0tTTEFTSF9FU0NBUEVdXG59O1xuY29uc3QgUEhSQVNBTF9XT1JEU19NT0RFID0ge1xuICBiZWdpbjogL1xcYihhfGFufHRoZXxhcmV8SSdtfGlzbid0fGRvbid0fGRvZXNuJ3R8d29uJ3R8YnV0fGp1c3R8c2hvdWxkfHByZXR0eXxzaW1wbHl8ZW5vdWdofGdvbm5hfGdvaW5nfHd0Znxzb3xzdWNofHdpbGx8eW91fHlvdXJ8dGhleXxsaWtlfG1vcmUpXFxiL1xufTtcbi8qKlxuICogQ3JlYXRlcyBhIGNvbW1lbnQgbW9kZVxuICpcbiAqIEBwYXJhbSB7c3RyaW5nIHwgUmVnRXhwfSBiZWdpblxuICogQHBhcmFtIHtzdHJpbmcgfCBSZWdFeHB9IGVuZFxuICogQHBhcmFtIHtNb2RlIHwge319IFttb2RlT3B0aW9uc11cbiAqIEByZXR1cm5zIHtQYXJ0aWFsPE1vZGU+fVxuICovXG5jb25zdCBDT01NRU5UID0gZnVuY3Rpb24oYmVnaW4sIGVuZCwgbW9kZU9wdGlvbnMgPSB7fSkge1xuICBjb25zdCBtb2RlID0gaW5oZXJpdCQxKFxuICAgIHtcbiAgICAgIHNjb3BlOiAnY29tbWVudCcsXG4gICAgICBiZWdpbixcbiAgICAgIGVuZCxcbiAgICAgIGNvbnRhaW5zOiBbXVxuICAgIH0sXG4gICAgbW9kZU9wdGlvbnNcbiAgKTtcbiAgbW9kZS5jb250YWlucy5wdXNoKHtcbiAgICBzY29wZTogJ2RvY3RhZycsXG4gICAgLy8gaGFjayB0byBhdm9pZCB0aGUgc3BhY2UgZnJvbSBiZWluZyBpbmNsdWRlZC4gdGhlIHNwYWNlIGlzIG5lY2Vzc2FyeSB0b1xuICAgIC8vIG1hdGNoIGhlcmUgdG8gcHJldmVudCB0aGUgcGxhaW4gdGV4dCBydWxlIGJlbG93IGZyb20gZ29iYmxpbmcgdXAgZG9jdGFnc1xuICAgIGJlZ2luOiAnWyBdKig/PShUT0RPfEZJWE1FfE5PVEV8QlVHfE9QVElNSVpFfEhBQ0t8WFhYKTopJyxcbiAgICBlbmQ6IC8oVE9ET3xGSVhNRXxOT1RFfEJVR3xPUFRJTUlaRXxIQUNLfFhYWCk6LyxcbiAgICBleGNsdWRlQmVnaW46IHRydWUsXG4gICAgcmVsZXZhbmNlOiAwXG4gIH0pO1xuICBjb25zdCBFTkdMSVNIX1dPUkQgPSBlaXRoZXIoXG4gICAgLy8gbGlzdCBvZiBjb21tb24gMSBhbmQgMiBsZXR0ZXIgd29yZHMgaW4gRW5nbGlzaFxuICAgIFwiSVwiLFxuICAgIFwiYVwiLFxuICAgIFwiaXNcIixcbiAgICBcInNvXCIsXG4gICAgXCJ1c1wiLFxuICAgIFwidG9cIixcbiAgICBcImF0XCIsXG4gICAgXCJpZlwiLFxuICAgIFwiaW5cIixcbiAgICBcIml0XCIsXG4gICAgXCJvblwiLFxuICAgIC8vIG5vdGU6IHRoaXMgaXMgbm90IGFuIGV4aGF1c3RpdmUgbGlzdCBvZiBjb250cmFjdGlvbnMsIGp1c3QgcG9wdWxhciBvbmVzXG4gICAgL1tBLVphLXpdK1snXShkfHZlfHJlfGxsfHR8c3xuKS8sIC8vIGNvbnRyYWN0aW9ucyAtIGNhbid0IHdlJ2QgdGhleSdyZSBsZXQncywgZXRjXG4gICAgL1tBLVphLXpdK1stXVthLXpdKy8sIC8vIGBuby13YXlgLCBldGMuXG4gICAgL1tBLVphLXpdW2Etel17Mix9LyAvLyBhbGxvdyBjYXBpdGFsaXplZCB3b3JkcyBhdCBiZWdpbm5pbmcgb2Ygc2VudGVuY2VzXG4gICk7XG4gIC8vIGxvb2tpbmcgbGlrZSBwbGFpbiB0ZXh0LCBtb3JlIGxpa2VseSB0byBiZSBhIGNvbW1lbnRcbiAgbW9kZS5jb250YWlucy5wdXNoKFxuICAgIHtcbiAgICAgIC8vIFRPRE86IGhvdyB0byBpbmNsdWRlIFwiLCAoLCApIHdpdGhvdXQgYnJlYWtpbmcgZ3JhbW1hcnMgdGhhdCB1c2UgdGhlc2UgZm9yXG4gICAgICAvLyBjb21tZW50IGRlbGltaXRlcnM/XG4gICAgICAvLyBiZWdpbjogL1sgXSsoWygpXCJdPyhbQS1aYS16Jy1dezMsfXxpc3xhfEl8c298dXN8W3RUXVtvT118YXR8aWZ8aW58aXR8b24pWy5dP1soKVwiOl0/KFsuXVsgXXxbIF18XFwpKSl7M30vXG4gICAgICAvLyAtLS1cblxuICAgICAgLy8gdGhpcyB0cmllcyB0byBmaW5kIHNlcXVlbmNlcyBvZiAzIGVuZ2xpc2ggd29yZHMgaW4gYSByb3cgKHdpdGhvdXQgYW55XG4gICAgICAvLyBcInByb2dyYW1taW5nXCIgdHlwZSBzeW50YXgpIHRoaXMgZ2l2ZXMgdXMgYSBzdHJvbmcgc2lnbmFsIHRoYXQgd2UndmVcbiAgICAgIC8vIFRSVUxZIGZvdW5kIGEgY29tbWVudCAtIHZzIHBlcmhhcHMgc2Nhbm5pbmcgd2l0aCB0aGUgd3JvbmcgbGFuZ3VhZ2UuXG4gICAgICAvLyBJdCdzIHBvc3NpYmxlIHRvIGZpbmQgc29tZXRoaW5nIHRoYXQgTE9PS1MgbGlrZSB0aGUgc3RhcnQgb2YgdGhlXG4gICAgICAvLyBjb21tZW50IC0gYnV0IHRoZW4gaWYgdGhlcmUgaXMgbm8gcmVhZGFibGUgdGV4dCAtIGdvb2QgY2hhbmNlIGl0IGlzIGFcbiAgICAgIC8vIGZhbHNlIG1hdGNoIGFuZCBub3QgYSBjb21tZW50LlxuICAgICAgLy9cbiAgICAgIC8vIGZvciBhIHZpc3VhbCBleGFtcGxlIHBsZWFzZSBzZWU6XG4gICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vaGlnaGxpZ2h0anMvaGlnaGxpZ2h0LmpzL2lzc3Vlcy8yODI3XG5cbiAgICAgIGJlZ2luOiBjb25jYXQoXG4gICAgICAgIC9bIF0rLywgLy8gbmVjZXNzYXJ5IHRvIHByZXZlbnQgdXMgZ29iYmxpbmcgdXAgZG9jdGFncyBsaWtlIC8qIEBhdXRob3IgQm9iIE1jZ2lsbCAqL1xuICAgICAgICAnKCcsXG4gICAgICAgIEVOR0xJU0hfV09SRCxcbiAgICAgICAgL1suXT9bOl0/KFsuXVsgXXxbIF0pLyxcbiAgICAgICAgJyl7M30nKSAvLyBsb29rIGZvciAzIHdvcmRzIGluIGEgcm93XG4gICAgfVxuICApO1xuICByZXR1cm4gbW9kZTtcbn07XG5jb25zdCBDX0xJTkVfQ09NTUVOVF9NT0RFID0gQ09NTUVOVCgnLy8nLCAnJCcpO1xuY29uc3QgQ19CTE9DS19DT01NRU5UX01PREUgPSBDT01NRU5UKCcvXFxcXConLCAnXFxcXCovJyk7XG5jb25zdCBIQVNIX0NPTU1FTlRfTU9ERSA9IENPTU1FTlQoJyMnLCAnJCcpO1xuY29uc3QgTlVNQkVSX01PREUgPSB7XG4gIHNjb3BlOiAnbnVtYmVyJyxcbiAgYmVnaW46IE5VTUJFUl9SRSxcbiAgcmVsZXZhbmNlOiAwXG59O1xuY29uc3QgQ19OVU1CRVJfTU9ERSA9IHtcbiAgc2NvcGU6ICdudW1iZXInLFxuICBiZWdpbjogQ19OVU1CRVJfUkUsXG4gIHJlbGV2YW5jZTogMFxufTtcbmNvbnN0IEJJTkFSWV9OVU1CRVJfTU9ERSA9IHtcbiAgc2NvcGU6ICdudW1iZXInLFxuICBiZWdpbjogQklOQVJZX05VTUJFUl9SRSxcbiAgcmVsZXZhbmNlOiAwXG59O1xuY29uc3QgUkVHRVhQX01PREUgPSB7XG4gIC8vIHRoaXMgb3V0ZXIgcnVsZSBtYWtlcyBzdXJlIHdlIGFjdHVhbGx5IGhhdmUgYSBXSE9MRSByZWdleCBhbmQgbm90IHNpbXBseVxuICAvLyBhbiBleHByZXNzaW9uIHN1Y2ggYXM6XG4gIC8vXG4gIC8vICAgICAzIC8gc29tZXRoaW5nXG4gIC8vXG4gIC8vICh3aGljaCB3aWxsIHRoZW4gYmxvdyB1cCB3aGVuIHJlZ2V4J3MgYGlsbGVnYWxgIHNlZXMgdGhlIG5ld2xpbmUpXG4gIGJlZ2luOiAvKD89XFwvW14vXFxuXSpcXC8pLyxcbiAgY29udGFpbnM6IFt7XG4gICAgc2NvcGU6ICdyZWdleHAnLFxuICAgIGJlZ2luOiAvXFwvLyxcbiAgICBlbmQ6IC9cXC9bZ2ltdXldKi8sXG4gICAgaWxsZWdhbDogL1xcbi8sXG4gICAgY29udGFpbnM6IFtcbiAgICAgIEJBQ0tTTEFTSF9FU0NBUEUsXG4gICAgICB7XG4gICAgICAgIGJlZ2luOiAvXFxbLyxcbiAgICAgICAgZW5kOiAvXFxdLyxcbiAgICAgICAgcmVsZXZhbmNlOiAwLFxuICAgICAgICBjb250YWluczogW0JBQ0tTTEFTSF9FU0NBUEVdXG4gICAgICB9XG4gICAgXVxuICB9XVxufTtcbmNvbnN0IFRJVExFX01PREUgPSB7XG4gIHNjb3BlOiAndGl0bGUnLFxuICBiZWdpbjogSURFTlRfUkUsXG4gIHJlbGV2YW5jZTogMFxufTtcbmNvbnN0IFVOREVSU0NPUkVfVElUTEVfTU9ERSA9IHtcbiAgc2NvcGU6ICd0aXRsZScsXG4gIGJlZ2luOiBVTkRFUlNDT1JFX0lERU5UX1JFLFxuICByZWxldmFuY2U6IDBcbn07XG5jb25zdCBNRVRIT0RfR1VBUkQgPSB7XG4gIC8vIGV4Y2x1ZGVzIG1ldGhvZCBuYW1lcyBmcm9tIGtleXdvcmQgcHJvY2Vzc2luZ1xuICBiZWdpbjogJ1xcXFwuXFxcXHMqJyArIFVOREVSU0NPUkVfSURFTlRfUkUsXG4gIHJlbGV2YW5jZTogMFxufTtcblxuLyoqXG4gKiBBZGRzIGVuZCBzYW1lIGFzIGJlZ2luIG1lY2hhbmljcyB0byBhIG1vZGVcbiAqXG4gKiBZb3VyIG1vZGUgbXVzdCBpbmNsdWRlIGF0IGxlYXN0IGEgc2luZ2xlICgpIG1hdGNoIGdyb3VwIGFzIHRoYXQgZmlyc3QgbWF0Y2hcbiAqIGdyb3VwIGlzIHdoYXQgaXMgdXNlZCBmb3IgY29tcGFyaXNvblxuICogQHBhcmFtIHtQYXJ0aWFsPE1vZGU+fSBtb2RlXG4gKi9cbmNvbnN0IEVORF9TQU1FX0FTX0JFR0lOID0gZnVuY3Rpb24obW9kZSkge1xuICByZXR1cm4gT2JqZWN0LmFzc2lnbihtb2RlLFxuICAgIHtcbiAgICAgIC8qKiBAdHlwZSB7TW9kZUNhbGxiYWNrfSAqL1xuICAgICAgJ29uOmJlZ2luJzogKG0sIHJlc3ApID0+IHsgcmVzcC5kYXRhLl9iZWdpbk1hdGNoID0gbVsxXTsgfSxcbiAgICAgIC8qKiBAdHlwZSB7TW9kZUNhbGxiYWNrfSAqL1xuICAgICAgJ29uOmVuZCc6IChtLCByZXNwKSA9PiB7IGlmIChyZXNwLmRhdGEuX2JlZ2luTWF0Y2ggIT09IG1bMV0pIHJlc3AuaWdub3JlTWF0Y2goKTsgfVxuICAgIH0pO1xufTtcblxudmFyIE1PREVTID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuICAgIF9fcHJvdG9fXzogbnVsbCxcbiAgICBNQVRDSF9OT1RISU5HX1JFOiBNQVRDSF9OT1RISU5HX1JFLFxuICAgIElERU5UX1JFOiBJREVOVF9SRSxcbiAgICBVTkRFUlNDT1JFX0lERU5UX1JFOiBVTkRFUlNDT1JFX0lERU5UX1JFLFxuICAgIE5VTUJFUl9SRTogTlVNQkVSX1JFLFxuICAgIENfTlVNQkVSX1JFOiBDX05VTUJFUl9SRSxcbiAgICBCSU5BUllfTlVNQkVSX1JFOiBCSU5BUllfTlVNQkVSX1JFLFxuICAgIFJFX1NUQVJURVJTX1JFOiBSRV9TVEFSVEVSU19SRSxcbiAgICBTSEVCQU5HOiBTSEVCQU5HLFxuICAgIEJBQ0tTTEFTSF9FU0NBUEU6IEJBQ0tTTEFTSF9FU0NBUEUsXG4gICAgQVBPU19TVFJJTkdfTU9ERTogQVBPU19TVFJJTkdfTU9ERSxcbiAgICBRVU9URV9TVFJJTkdfTU9ERTogUVVPVEVfU1RSSU5HX01PREUsXG4gICAgUEhSQVNBTF9XT1JEU19NT0RFOiBQSFJBU0FMX1dPUkRTX01PREUsXG4gICAgQ09NTUVOVDogQ09NTUVOVCxcbiAgICBDX0xJTkVfQ09NTUVOVF9NT0RFOiBDX0xJTkVfQ09NTUVOVF9NT0RFLFxuICAgIENfQkxPQ0tfQ09NTUVOVF9NT0RFOiBDX0JMT0NLX0NPTU1FTlRfTU9ERSxcbiAgICBIQVNIX0NPTU1FTlRfTU9ERTogSEFTSF9DT01NRU5UX01PREUsXG4gICAgTlVNQkVSX01PREU6IE5VTUJFUl9NT0RFLFxuICAgIENfTlVNQkVSX01PREU6IENfTlVNQkVSX01PREUsXG4gICAgQklOQVJZX05VTUJFUl9NT0RFOiBCSU5BUllfTlVNQkVSX01PREUsXG4gICAgUkVHRVhQX01PREU6IFJFR0VYUF9NT0RFLFxuICAgIFRJVExFX01PREU6IFRJVExFX01PREUsXG4gICAgVU5ERVJTQ09SRV9USVRMRV9NT0RFOiBVTkRFUlNDT1JFX1RJVExFX01PREUsXG4gICAgTUVUSE9EX0dVQVJEOiBNRVRIT0RfR1VBUkQsXG4gICAgRU5EX1NBTUVfQVNfQkVHSU46IEVORF9TQU1FX0FTX0JFR0lOXG59KTtcblxuLyoqXG5AdHlwZWRlZiB7aW1wb3J0KCdoaWdobGlnaHQuanMnKS5DYWxsYmFja1Jlc3BvbnNlfSBDYWxsYmFja1Jlc3BvbnNlXG5AdHlwZWRlZiB7aW1wb3J0KCdoaWdobGlnaHQuanMnKS5Db21waWxlckV4dH0gQ29tcGlsZXJFeHRcbiovXG5cbi8vIEdyYW1tYXIgZXh0ZW5zaW9ucyAvIHBsdWdpbnNcbi8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2hpZ2hsaWdodGpzL2hpZ2hsaWdodC5qcy9pc3N1ZXMvMjgzM1xuXG4vLyBHcmFtbWFyIGV4dGVuc2lvbnMgYWxsb3cgXCJzeW50YWN0aWMgc3VnYXJcIiB0byBiZSBhZGRlZCB0byB0aGUgZ3JhbW1hciBtb2Rlc1xuLy8gd2l0aG91dCByZXF1aXJpbmcgYW55IHVuZGVybHlpbmcgY2hhbmdlcyB0byB0aGUgY29tcGlsZXIgaW50ZXJuYWxzLlxuXG4vLyBgY29tcGlsZU1hdGNoYCBiZWluZyB0aGUgcGVyZmVjdCBzbWFsbCBleGFtcGxlIG9mIG5vdyBhbGxvd2luZyBhIGdyYW1tYXJcbi8vIGF1dGhvciB0byB3cml0ZSBgbWF0Y2hgIHdoZW4gdGhleSBkZXNpcmUgdG8gbWF0Y2ggYSBzaW5nbGUgZXhwcmVzc2lvbiByYXRoZXJcbi8vIHRoYW4gYmVpbmcgZm9yY2VkIHRvIHVzZSBgYmVnaW5gLiAgVGhlIGV4dGVuc2lvbiB0aGVuIGp1c3QgbW92ZXMgYG1hdGNoYCBpbnRvXG4vLyBgYmVnaW5gIHdoZW4gaXQgcnVucy4gIEllLCBubyBmZWF0dXJlcyBoYXZlIGJlZW4gYWRkZWQsIGJ1dCB3ZSd2ZSBqdXN0IG1hZGVcbi8vIHRoZSBleHBlcmllbmNlIG9mIHdyaXRpbmcgKGFuZCByZWFkaW5nIGdyYW1tYXJzKSBhIGxpdHRsZSBiaXQgbmljZXIuXG5cbi8vIC0tLS0tLVxuXG4vLyBUT0RPOiBXZSBuZWVkIG5lZ2F0aXZlIGxvb2stYmVoaW5kIHN1cHBvcnQgdG8gZG8gdGhpcyBwcm9wZXJseVxuLyoqXG4gKiBTa2lwIGEgbWF0Y2ggaWYgaXQgaGFzIGEgcHJlY2VkaW5nIGRvdFxuICpcbiAqIFRoaXMgaXMgdXNlZCBmb3IgYGJlZ2luS2V5d29yZHNgIHRvIHByZXZlbnQgbWF0Y2hpbmcgZXhwcmVzc2lvbnMgc3VjaCBhc1xuICogYGJvYi5rZXl3b3JkLmRvKClgLiBUaGUgbW9kZSBjb21waWxlciBhdXRvbWF0aWNhbGx5IHdpcmVzIHRoaXMgdXAgYXMgYVxuICogc3BlY2lhbCBfaW50ZXJuYWxfICdvbjpiZWdpbicgY2FsbGJhY2sgZm9yIG1vZGVzIHdpdGggYGJlZ2luS2V5d29yZHNgXG4gKiBAcGFyYW0ge1JlZ0V4cE1hdGNoQXJyYXl9IG1hdGNoXG4gKiBAcGFyYW0ge0NhbGxiYWNrUmVzcG9uc2V9IHJlc3BvbnNlXG4gKi9cbmZ1bmN0aW9uIHNraXBJZkhhc1ByZWNlZGluZ0RvdChtYXRjaCwgcmVzcG9uc2UpIHtcbiAgY29uc3QgYmVmb3JlID0gbWF0Y2guaW5wdXRbbWF0Y2guaW5kZXggLSAxXTtcbiAgaWYgKGJlZm9yZSA9PT0gXCIuXCIpIHtcbiAgICByZXNwb25zZS5pZ25vcmVNYXRjaCgpO1xuICB9XG59XG5cbi8qKlxuICpcbiAqIEB0eXBlIHtDb21waWxlckV4dH1cbiAqL1xuZnVuY3Rpb24gc2NvcGVDbGFzc05hbWUobW9kZSwgX3BhcmVudCkge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5kZWZpbmVkXG4gIGlmIChtb2RlLmNsYXNzTmFtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgbW9kZS5zY29wZSA9IG1vZGUuY2xhc3NOYW1lO1xuICAgIGRlbGV0ZSBtb2RlLmNsYXNzTmFtZTtcbiAgfVxufVxuXG4vKipcbiAqIGBiZWdpbktleXdvcmRzYCBzeW50YWN0aWMgc3VnYXJcbiAqIEB0eXBlIHtDb21waWxlckV4dH1cbiAqL1xuZnVuY3Rpb24gYmVnaW5LZXl3b3Jkcyhtb2RlLCBwYXJlbnQpIHtcbiAgaWYgKCFwYXJlbnQpIHJldHVybjtcbiAgaWYgKCFtb2RlLmJlZ2luS2V5d29yZHMpIHJldHVybjtcblxuICAvLyBmb3IgbGFuZ3VhZ2VzIHdpdGgga2V5d29yZHMgdGhhdCBpbmNsdWRlIG5vbi13b3JkIGNoYXJhY3RlcnMgY2hlY2tpbmcgZm9yXG4gIC8vIGEgd29yZCBib3VuZGFyeSBpcyBub3Qgc3VmZmljaWVudCwgc28gaW5zdGVhZCB3ZSBjaGVjayBmb3IgYSB3b3JkIGJvdW5kYXJ5XG4gIC8vIG9yIHdoaXRlc3BhY2UgLSB0aGlzIGRvZXMgbm8gaGFybSBpbiBhbnkgY2FzZSBzaW5jZSBvdXIga2V5d29yZCBlbmdpbmVcbiAgLy8gZG9lc24ndCBhbGxvdyBzcGFjZXMgaW4ga2V5d29yZHMgYW55d2F5cyBhbmQgd2Ugc3RpbGwgY2hlY2sgZm9yIHRoZSBib3VuZGFyeVxuICAvLyBmaXJzdFxuICBtb2RlLmJlZ2luID0gJ1xcXFxiKCcgKyBtb2RlLmJlZ2luS2V5d29yZHMuc3BsaXQoJyAnKS5qb2luKCd8JykgKyAnKSg/IVxcXFwuKSg/PVxcXFxifFxcXFxzKSc7XG4gIG1vZGUuX19iZWZvcmVCZWdpbiA9IHNraXBJZkhhc1ByZWNlZGluZ0RvdDtcbiAgbW9kZS5rZXl3b3JkcyA9IG1vZGUua2V5d29yZHMgfHwgbW9kZS5iZWdpbktleXdvcmRzO1xuICBkZWxldGUgbW9kZS5iZWdpbktleXdvcmRzO1xuXG4gIC8vIHByZXZlbnRzIGRvdWJsZSByZWxldmFuY2UsIHRoZSBrZXl3b3JkcyB0aGVtc2VsdmVzIHByb3ZpZGVcbiAgLy8gcmVsZXZhbmNlLCB0aGUgbW9kZSBkb2Vzbid0IG5lZWQgdG8gZG91YmxlIGl0XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlZmluZWRcbiAgaWYgKG1vZGUucmVsZXZhbmNlID09PSB1bmRlZmluZWQpIG1vZGUucmVsZXZhbmNlID0gMDtcbn1cblxuLyoqXG4gKiBBbGxvdyBgaWxsZWdhbGAgdG8gY29udGFpbiBhbiBhcnJheSBvZiBpbGxlZ2FsIHZhbHVlc1xuICogQHR5cGUge0NvbXBpbGVyRXh0fVxuICovXG5mdW5jdGlvbiBjb21waWxlSWxsZWdhbChtb2RlLCBfcGFyZW50KSB7XG4gIGlmICghQXJyYXkuaXNBcnJheShtb2RlLmlsbGVnYWwpKSByZXR1cm47XG5cbiAgbW9kZS5pbGxlZ2FsID0gZWl0aGVyKC4uLm1vZGUuaWxsZWdhbCk7XG59XG5cbi8qKlxuICogYG1hdGNoYCB0byBtYXRjaCBhIHNpbmdsZSBleHByZXNzaW9uIGZvciByZWFkYWJpbGl0eVxuICogQHR5cGUge0NvbXBpbGVyRXh0fVxuICovXG5mdW5jdGlvbiBjb21waWxlTWF0Y2gobW9kZSwgX3BhcmVudCkge1xuICBpZiAoIW1vZGUubWF0Y2gpIHJldHVybjtcbiAgaWYgKG1vZGUuYmVnaW4gfHwgbW9kZS5lbmQpIHRocm93IG5ldyBFcnJvcihcImJlZ2luICYgZW5kIGFyZSBub3Qgc3VwcG9ydGVkIHdpdGggbWF0Y2hcIik7XG5cbiAgbW9kZS5iZWdpbiA9IG1vZGUubWF0Y2g7XG4gIGRlbGV0ZSBtb2RlLm1hdGNoO1xufVxuXG4vKipcbiAqIHByb3ZpZGVzIHRoZSBkZWZhdWx0IDEgcmVsZXZhbmNlIHRvIGFsbCBtb2Rlc1xuICogQHR5cGUge0NvbXBpbGVyRXh0fVxuICovXG5mdW5jdGlvbiBjb21waWxlUmVsZXZhbmNlKG1vZGUsIF9wYXJlbnQpIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVmaW5lZFxuICBpZiAobW9kZS5yZWxldmFuY2UgPT09IHVuZGVmaW5lZCkgbW9kZS5yZWxldmFuY2UgPSAxO1xufVxuXG4vLyBhbGxvdyBiZWZvcmVNYXRjaCB0byBhY3QgYXMgYSBcInF1YWxpZmllclwiIGZvciB0aGUgbWF0Y2hcbi8vIHRoZSBmdWxsIG1hdGNoIGJlZ2luIG11c3QgYmUgW2JlZm9yZU1hdGNoXVtiZWdpbl1cbmNvbnN0IGJlZm9yZU1hdGNoRXh0ID0gKG1vZGUsIHBhcmVudCkgPT4ge1xuICBpZiAoIW1vZGUuYmVmb3JlTWF0Y2gpIHJldHVybjtcbiAgLy8gc3RhcnRzIGNvbmZsaWN0cyB3aXRoIGVuZHNQYXJlbnQgd2hpY2ggd2UgbmVlZCB0byBtYWtlIHN1cmUgdGhlIGNoaWxkXG4gIC8vIHJ1bGUgaXMgbm90IG1hdGNoZWQgbXVsdGlwbGUgdGltZXNcbiAgaWYgKG1vZGUuc3RhcnRzKSB0aHJvdyBuZXcgRXJyb3IoXCJiZWZvcmVNYXRjaCBjYW5ub3QgYmUgdXNlZCB3aXRoIHN0YXJ0c1wiKTtcblxuICBjb25zdCBvcmlnaW5hbE1vZGUgPSBPYmplY3QuYXNzaWduKHt9LCBtb2RlKTtcbiAgT2JqZWN0LmtleXMobW9kZSkuZm9yRWFjaCgoa2V5KSA9PiB7IGRlbGV0ZSBtb2RlW2tleV07IH0pO1xuXG4gIG1vZGUua2V5d29yZHMgPSBvcmlnaW5hbE1vZGUua2V5d29yZHM7XG4gIG1vZGUuYmVnaW4gPSBjb25jYXQob3JpZ2luYWxNb2RlLmJlZm9yZU1hdGNoLCBsb29rYWhlYWQob3JpZ2luYWxNb2RlLmJlZ2luKSk7XG4gIG1vZGUuc3RhcnRzID0ge1xuICAgIHJlbGV2YW5jZTogMCxcbiAgICBjb250YWluczogW1xuICAgICAgT2JqZWN0LmFzc2lnbihvcmlnaW5hbE1vZGUsIHsgZW5kc1BhcmVudDogdHJ1ZSB9KVxuICAgIF1cbiAgfTtcbiAgbW9kZS5yZWxldmFuY2UgPSAwO1xuXG4gIGRlbGV0ZSBvcmlnaW5hbE1vZGUuYmVmb3JlTWF0Y2g7XG59O1xuXG4vLyBrZXl3b3JkcyB0aGF0IHNob3VsZCBoYXZlIG5vIGRlZmF1bHQgcmVsZXZhbmNlIHZhbHVlXG5jb25zdCBDT01NT05fS0VZV09SRFMgPSBbXG4gICdvZicsXG4gICdhbmQnLFxuICAnZm9yJyxcbiAgJ2luJyxcbiAgJ25vdCcsXG4gICdvcicsXG4gICdpZicsXG4gICd0aGVuJyxcbiAgJ3BhcmVudCcsIC8vIGNvbW1vbiB2YXJpYWJsZSBuYW1lXG4gICdsaXN0JywgLy8gY29tbW9uIHZhcmlhYmxlIG5hbWVcbiAgJ3ZhbHVlJyAvLyBjb21tb24gdmFyaWFibGUgbmFtZVxuXTtcblxuY29uc3QgREVGQVVMVF9LRVlXT1JEX1NDT1BFID0gXCJrZXl3b3JkXCI7XG5cbi8qKlxuICogR2l2ZW4gcmF3IGtleXdvcmRzIGZyb20gYSBsYW5ndWFnZSBkZWZpbml0aW9uLCBjb21waWxlIHRoZW0uXG4gKlxuICogQHBhcmFtIHtzdHJpbmcgfCBSZWNvcmQ8c3RyaW5nLHN0cmluZ3xzdHJpbmdbXT4gfCBBcnJheTxzdHJpbmc+fSByYXdLZXl3b3Jkc1xuICogQHBhcmFtIHtib29sZWFufSBjYXNlSW5zZW5zaXRpdmVcbiAqL1xuZnVuY3Rpb24gY29tcGlsZUtleXdvcmRzKHJhd0tleXdvcmRzLCBjYXNlSW5zZW5zaXRpdmUsIHNjb3BlTmFtZSA9IERFRkFVTFRfS0VZV09SRF9TQ09QRSkge1xuICAvKiogQHR5cGUgS2V5d29yZERpY3QgKi9cbiAgY29uc3QgY29tcGlsZWRLZXl3b3JkcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbiAgLy8gaW5wdXQgY2FuIGJlIGEgc3RyaW5nIG9mIGtleXdvcmRzLCBhbiBhcnJheSBvZiBrZXl3b3Jkcywgb3IgYSBvYmplY3Qgd2l0aFxuICAvLyBuYW1lZCBrZXlzIHJlcHJlc2VudGluZyBzY29wZU5hbWUgKHdoaWNoIGNhbiB0aGVuIHBvaW50IHRvIGEgc3RyaW5nIG9yIGFycmF5KVxuICBpZiAodHlwZW9mIHJhd0tleXdvcmRzID09PSAnc3RyaW5nJykge1xuICAgIGNvbXBpbGVMaXN0KHNjb3BlTmFtZSwgcmF3S2V5d29yZHMuc3BsaXQoXCIgXCIpKTtcbiAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHJhd0tleXdvcmRzKSkge1xuICAgIGNvbXBpbGVMaXN0KHNjb3BlTmFtZSwgcmF3S2V5d29yZHMpO1xuICB9IGVsc2Uge1xuICAgIE9iamVjdC5rZXlzKHJhd0tleXdvcmRzKS5mb3JFYWNoKGZ1bmN0aW9uKHNjb3BlTmFtZSkge1xuICAgICAgLy8gY29sbGFwc2UgYWxsIG91ciBvYmplY3RzIGJhY2sgaW50byB0aGUgcGFyZW50IG9iamVjdFxuICAgICAgT2JqZWN0LmFzc2lnbihcbiAgICAgICAgY29tcGlsZWRLZXl3b3JkcyxcbiAgICAgICAgY29tcGlsZUtleXdvcmRzKHJhd0tleXdvcmRzW3Njb3BlTmFtZV0sIGNhc2VJbnNlbnNpdGl2ZSwgc2NvcGVOYW1lKVxuICAgICAgKTtcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gY29tcGlsZWRLZXl3b3JkcztcblxuICAvLyAtLS1cblxuICAvKipcbiAgICogQ29tcGlsZXMgYW4gaW5kaXZpZHVhbCBsaXN0IG9mIGtleXdvcmRzXG4gICAqXG4gICAqIEV4OiBcImZvciBpZiB3aGVuIHdoaWxlfDVcIlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gc2NvcGVOYW1lXG4gICAqIEBwYXJhbSB7QXJyYXk8c3RyaW5nPn0ga2V5d29yZExpc3RcbiAgICovXG4gIGZ1bmN0aW9uIGNvbXBpbGVMaXN0KHNjb3BlTmFtZSwga2V5d29yZExpc3QpIHtcbiAgICBpZiAoY2FzZUluc2Vuc2l0aXZlKSB7XG4gICAgICBrZXl3b3JkTGlzdCA9IGtleXdvcmRMaXN0Lm1hcCh4ID0+IHgudG9Mb3dlckNhc2UoKSk7XG4gICAgfVxuICAgIGtleXdvcmRMaXN0LmZvckVhY2goZnVuY3Rpb24oa2V5d29yZCkge1xuICAgICAgY29uc3QgcGFpciA9IGtleXdvcmQuc3BsaXQoJ3wnKTtcbiAgICAgIGNvbXBpbGVkS2V5d29yZHNbcGFpclswXV0gPSBbc2NvcGVOYW1lLCBzY29yZUZvcktleXdvcmQocGFpclswXSwgcGFpclsxXSldO1xuICAgIH0pO1xuICB9XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgcHJvcGVyIHNjb3JlIGZvciBhIGdpdmVuIGtleXdvcmRcbiAqXG4gKiBBbHNvIHRha2VzIGludG8gYWNjb3VudCBjb21tZW50IGtleXdvcmRzLCB3aGljaCB3aWxsIGJlIHNjb3JlZCAwIFVOTEVTU1xuICogYW5vdGhlciBzY29yZSBoYXMgYmVlbiBtYW51YWxseSBhc3NpZ25lZC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXl3b3JkXG4gKiBAcGFyYW0ge3N0cmluZ30gW3Byb3ZpZGVkU2NvcmVdXG4gKi9cbmZ1bmN0aW9uIHNjb3JlRm9yS2V5d29yZChrZXl3b3JkLCBwcm92aWRlZFNjb3JlKSB7XG4gIC8vIG1hbnVhbCBzY29yZXMgYWx3YXlzIHdpbiBvdmVyIGNvbW1vbiBrZXl3b3Jkc1xuICAvLyBzbyB5b3UgY2FuIGZvcmNlIGEgc2NvcmUgb2YgMSBpZiB5b3UgcmVhbGx5IGluc2lzdFxuICBpZiAocHJvdmlkZWRTY29yZSkge1xuICAgIHJldHVybiBOdW1iZXIocHJvdmlkZWRTY29yZSk7XG4gIH1cblxuICByZXR1cm4gY29tbW9uS2V5d29yZChrZXl3b3JkKSA/IDAgOiAxO1xufVxuXG4vKipcbiAqIERldGVybWluZXMgaWYgYSBnaXZlbiBrZXl3b3JkIGlzIGNvbW1vbiBvciBub3RcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5d29yZCAqL1xuZnVuY3Rpb24gY29tbW9uS2V5d29yZChrZXl3b3JkKSB7XG4gIHJldHVybiBDT01NT05fS0VZV09SRFMuaW5jbHVkZXMoa2V5d29yZC50b0xvd2VyQ2FzZSgpKTtcbn1cblxuLypcblxuRm9yIHRoZSByZWFzb25pbmcgYmVoaW5kIHRoaXMgcGxlYXNlIHNlZTpcbmh0dHBzOi8vZ2l0aHViLmNvbS9oaWdobGlnaHRqcy9oaWdobGlnaHQuanMvaXNzdWVzLzI4ODAjaXNzdWVjb21tZW50LTc0NzI3NTQxOVxuXG4qL1xuXG4vKipcbiAqIEB0eXBlIHtSZWNvcmQ8c3RyaW5nLCBib29sZWFuPn1cbiAqL1xuY29uc3Qgc2VlbkRlcHJlY2F0aW9ucyA9IHt9O1xuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBtZXNzYWdlXG4gKi9cbmNvbnN0IGVycm9yID0gKG1lc3NhZ2UpID0+IHtcbiAgY29uc29sZS5lcnJvcihtZXNzYWdlKTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IG1lc3NhZ2VcbiAqIEBwYXJhbSB7YW55fSBhcmdzXG4gKi9cbmNvbnN0IHdhcm4gPSAobWVzc2FnZSwgLi4uYXJncykgPT4ge1xuICBjb25zb2xlLmxvZyhgV0FSTjogJHttZXNzYWdlfWAsIC4uLmFyZ3MpO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gdmVyc2lvblxuICogQHBhcmFtIHtzdHJpbmd9IG1lc3NhZ2VcbiAqL1xuY29uc3QgZGVwcmVjYXRlZCA9ICh2ZXJzaW9uLCBtZXNzYWdlKSA9PiB7XG4gIGlmIChzZWVuRGVwcmVjYXRpb25zW2Ake3ZlcnNpb259LyR7bWVzc2FnZX1gXSkgcmV0dXJuO1xuXG4gIGNvbnNvbGUubG9nKGBEZXByZWNhdGVkIGFzIG9mICR7dmVyc2lvbn0uICR7bWVzc2FnZX1gKTtcbiAgc2VlbkRlcHJlY2F0aW9uc1tgJHt2ZXJzaW9ufS8ke21lc3NhZ2V9YF0gPSB0cnVlO1xufTtcblxuLyogZXNsaW50LWRpc2FibGUgbm8tdGhyb3ctbGl0ZXJhbCAqL1xuXG4vKipcbkB0eXBlZGVmIHtpbXBvcnQoJ2hpZ2hsaWdodC5qcycpLkNvbXBpbGVkTW9kZX0gQ29tcGlsZWRNb2RlXG4qL1xuXG5jb25zdCBNdWx0aUNsYXNzRXJyb3IgPSBuZXcgRXJyb3IoKTtcblxuLyoqXG4gKiBSZW51bWJlcnMgbGFiZWxlZCBzY29wZSBuYW1lcyB0byBhY2NvdW50IGZvciBhZGRpdGlvbmFsIGlubmVyIG1hdGNoXG4gKiBncm91cHMgdGhhdCBvdGhlcndpc2Ugd291bGQgYnJlYWsgZXZlcnl0aGluZy5cbiAqXG4gKiBMZXRzIHNheSB3ZSAzIG1hdGNoIHNjb3BlczpcbiAqXG4gKiAgIHsgMSA9PiAuLi4sIDIgPT4gLi4uLCAzID0+IC4uLiB9XG4gKlxuICogU28gd2hhdCB3ZSBuZWVkIGlzIGEgY2xlYW4gbWF0Y2ggbGlrZSB0aGlzOlxuICpcbiAqICAgKGEpKGIpKGMpID0+IFsgXCJhXCIsIFwiYlwiLCBcImNcIiBdXG4gKlxuICogQnV0IHRoaXMgZmFsbHMgYXBhcnQgd2l0aCBpbm5lciBtYXRjaCBncm91cHM6XG4gKlxuICogKGEpKCgoYikpKShjKSA9PiBbXCJhXCIsIFwiYlwiLCBcImJcIiwgXCJiXCIsIFwiY1wiIF1cbiAqXG4gKiBPdXIgc2NvcGVzIGFyZSBub3cgXCJvdXQgb2YgYWxpZ25tZW50XCIgYW5kIHdlJ3JlIHJlcGVhdGluZyBgYmAgMyB0aW1lcy5cbiAqIFdoYXQgbmVlZHMgdG8gaGFwcGVuIGlzIHRoZSBudW1iZXJzIGFyZSByZW1hcHBlZDpcbiAqXG4gKiAgIHsgMSA9PiAuLi4sIDIgPT4gLi4uLCA1ID0+IC4uLiB9XG4gKlxuICogV2UgYWxzbyBuZWVkIHRvIGtub3cgdGhhdCB0aGUgT05MWSBncm91cHMgdGhhdCBzaG91bGQgYmUgb3V0cHV0XG4gKiBhcmUgMSwgMiwgYW5kIDUuICBUaGlzIGZ1bmN0aW9uIGhhbmRsZXMgdGhpcyBiZWhhdmlvci5cbiAqXG4gKiBAcGFyYW0ge0NvbXBpbGVkTW9kZX0gbW9kZVxuICogQHBhcmFtIHtBcnJheTxSZWdFeHA+fSByZWdleGVzXG4gKiBAcGFyYW0ge3trZXk6IFwiYmVnaW5TY29wZVwifFwiZW5kU2NvcGVcIn19IG9wdHNcbiAqL1xuZnVuY3Rpb24gcmVtYXBTY29wZU5hbWVzKG1vZGUsIHJlZ2V4ZXMsIHsga2V5IH0pIHtcbiAgbGV0IG9mZnNldCA9IDA7XG4gIGNvbnN0IHNjb3BlTmFtZXMgPSBtb2RlW2tleV07XG4gIC8qKiBAdHlwZSBSZWNvcmQ8bnVtYmVyLGJvb2xlYW4+ICovXG4gIGNvbnN0IGVtaXQgPSB7fTtcbiAgLyoqIEB0eXBlIFJlY29yZDxudW1iZXIsc3RyaW5nPiAqL1xuICBjb25zdCBwb3NpdGlvbnMgPSB7fTtcblxuICBmb3IgKGxldCBpID0gMTsgaSA8PSByZWdleGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgcG9zaXRpb25zW2kgKyBvZmZzZXRdID0gc2NvcGVOYW1lc1tpXTtcbiAgICBlbWl0W2kgKyBvZmZzZXRdID0gdHJ1ZTtcbiAgICBvZmZzZXQgKz0gY291bnRNYXRjaEdyb3VwcyhyZWdleGVzW2kgLSAxXSk7XG4gIH1cbiAgLy8gd2UgdXNlIF9lbWl0IHRvIGtlZXAgdHJhY2sgb2Ygd2hpY2ggbWF0Y2ggZ3JvdXBzIGFyZSBcInRvcC1sZXZlbFwiIHRvIGF2b2lkIGRvdWJsZVxuICAvLyBvdXRwdXQgZnJvbSBpbnNpZGUgbWF0Y2ggZ3JvdXBzXG4gIG1vZGVba2V5XSA9IHBvc2l0aW9ucztcbiAgbW9kZVtrZXldLl9lbWl0ID0gZW1pdDtcbiAgbW9kZVtrZXldLl9tdWx0aSA9IHRydWU7XG59XG5cbi8qKlxuICogQHBhcmFtIHtDb21waWxlZE1vZGV9IG1vZGVcbiAqL1xuZnVuY3Rpb24gYmVnaW5NdWx0aUNsYXNzKG1vZGUpIHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KG1vZGUuYmVnaW4pKSByZXR1cm47XG5cbiAgaWYgKG1vZGUuc2tpcCB8fCBtb2RlLmV4Y2x1ZGVCZWdpbiB8fCBtb2RlLnJldHVybkJlZ2luKSB7XG4gICAgZXJyb3IoXCJza2lwLCBleGNsdWRlQmVnaW4sIHJldHVybkJlZ2luIG5vdCBjb21wYXRpYmxlIHdpdGggYmVnaW5TY29wZToge31cIik7XG4gICAgdGhyb3cgTXVsdGlDbGFzc0Vycm9yO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBtb2RlLmJlZ2luU2NvcGUgIT09IFwib2JqZWN0XCIgfHwgbW9kZS5iZWdpblNjb3BlID09PSBudWxsKSB7XG4gICAgZXJyb3IoXCJiZWdpblNjb3BlIG11c3QgYmUgb2JqZWN0XCIpO1xuICAgIHRocm93IE11bHRpQ2xhc3NFcnJvcjtcbiAgfVxuXG4gIHJlbWFwU2NvcGVOYW1lcyhtb2RlLCBtb2RlLmJlZ2luLCB7a2V5OiBcImJlZ2luU2NvcGVcIn0pO1xuICBtb2RlLmJlZ2luID0gX3Jld3JpdGVCYWNrcmVmZXJlbmNlcyhtb2RlLmJlZ2luLCB7IGpvaW5XaXRoOiBcIlwiIH0pO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7Q29tcGlsZWRNb2RlfSBtb2RlXG4gKi9cbmZ1bmN0aW9uIGVuZE11bHRpQ2xhc3MobW9kZSkge1xuICBpZiAoIUFycmF5LmlzQXJyYXkobW9kZS5lbmQpKSByZXR1cm47XG5cbiAgaWYgKG1vZGUuc2tpcCB8fCBtb2RlLmV4Y2x1ZGVFbmQgfHwgbW9kZS5yZXR1cm5FbmQpIHtcbiAgICBlcnJvcihcInNraXAsIGV4Y2x1ZGVFbmQsIHJldHVybkVuZCBub3QgY29tcGF0aWJsZSB3aXRoIGVuZFNjb3BlOiB7fVwiKTtcbiAgICB0aHJvdyBNdWx0aUNsYXNzRXJyb3I7XG4gIH1cblxuICBpZiAodHlwZW9mIG1vZGUuZW5kU2NvcGUgIT09IFwib2JqZWN0XCIgfHwgbW9kZS5lbmRTY29wZSA9PT0gbnVsbCkge1xuICAgIGVycm9yKFwiZW5kU2NvcGUgbXVzdCBiZSBvYmplY3RcIik7XG4gICAgdGhyb3cgTXVsdGlDbGFzc0Vycm9yO1xuICB9XG5cbiAgcmVtYXBTY29wZU5hbWVzKG1vZGUsIG1vZGUuZW5kLCB7a2V5OiBcImVuZFNjb3BlXCJ9KTtcbiAgbW9kZS5lbmQgPSBfcmV3cml0ZUJhY2tyZWZlcmVuY2VzKG1vZGUuZW5kLCB7IGpvaW5XaXRoOiBcIlwiIH0pO1xufVxuXG4vKipcbiAqIHRoaXMgZXhpc3RzIG9ubHkgdG8gYWxsb3cgYHNjb3BlOiB7fWAgdG8gYmUgdXNlZCBiZXNpZGUgYG1hdGNoOmBcbiAqIE90aGVyd2lzZSBgYmVnaW5TY29wZWAgd291bGQgbmVjZXNzYXJ5IGFuZCB0aGF0IHdvdWxkIGxvb2sgd2VpcmRcblxuICB7XG4gICAgbWF0Y2g6IFsgL2RlZi8sIC9cXHcrLyBdXG4gICAgc2NvcGU6IHsgMTogXCJrZXl3b3JkXCIgLCAyOiBcInRpdGxlXCIgfVxuICB9XG5cbiAqIEBwYXJhbSB7Q29tcGlsZWRNb2RlfSBtb2RlXG4gKi9cbmZ1bmN0aW9uIHNjb3BlU3VnYXIobW9kZSkge1xuICBpZiAobW9kZS5zY29wZSAmJiB0eXBlb2YgbW9kZS5zY29wZSA9PT0gXCJvYmplY3RcIiAmJiBtb2RlLnNjb3BlICE9PSBudWxsKSB7XG4gICAgbW9kZS5iZWdpblNjb3BlID0gbW9kZS5zY29wZTtcbiAgICBkZWxldGUgbW9kZS5zY29wZTtcbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7Q29tcGlsZWRNb2RlfSBtb2RlXG4gKi9cbmZ1bmN0aW9uIE11bHRpQ2xhc3MobW9kZSkge1xuICBzY29wZVN1Z2FyKG1vZGUpO1xuXG4gIGlmICh0eXBlb2YgbW9kZS5iZWdpblNjb3BlID09PSBcInN0cmluZ1wiKSB7XG4gICAgbW9kZS5iZWdpblNjb3BlID0geyBfd3JhcDogbW9kZS5iZWdpblNjb3BlIH07XG4gIH1cbiAgaWYgKHR5cGVvZiBtb2RlLmVuZFNjb3BlID09PSBcInN0cmluZ1wiKSB7XG4gICAgbW9kZS5lbmRTY29wZSA9IHsgX3dyYXA6IG1vZGUuZW5kU2NvcGUgfTtcbiAgfVxuXG4gIGJlZ2luTXVsdGlDbGFzcyhtb2RlKTtcbiAgZW5kTXVsdGlDbGFzcyhtb2RlKTtcbn1cblxuLyoqXG5AdHlwZWRlZiB7aW1wb3J0KCdoaWdobGlnaHQuanMnKS5Nb2RlfSBNb2RlXG5AdHlwZWRlZiB7aW1wb3J0KCdoaWdobGlnaHQuanMnKS5Db21waWxlZE1vZGV9IENvbXBpbGVkTW9kZVxuQHR5cGVkZWYge2ltcG9ydCgnaGlnaGxpZ2h0LmpzJykuTGFuZ3VhZ2V9IExhbmd1YWdlXG5AdHlwZWRlZiB7aW1wb3J0KCdoaWdobGlnaHQuanMnKS5ITEpTUGx1Z2lufSBITEpTUGx1Z2luXG5AdHlwZWRlZiB7aW1wb3J0KCdoaWdobGlnaHQuanMnKS5Db21waWxlZExhbmd1YWdlfSBDb21waWxlZExhbmd1YWdlXG4qL1xuXG4vLyBjb21waWxhdGlvblxuXG4vKipcbiAqIENvbXBpbGVzIGEgbGFuZ3VhZ2UgZGVmaW5pdGlvbiByZXN1bHRcbiAqXG4gKiBHaXZlbiB0aGUgcmF3IHJlc3VsdCBvZiBhIGxhbmd1YWdlIGRlZmluaXRpb24gKExhbmd1YWdlKSwgY29tcGlsZXMgdGhpcyBzb1xuICogdGhhdCBpdCBpcyByZWFkeSBmb3IgaGlnaGxpZ2h0aW5nIGNvZGUuXG4gKiBAcGFyYW0ge0xhbmd1YWdlfSBsYW5ndWFnZVxuICogQHJldHVybnMge0NvbXBpbGVkTGFuZ3VhZ2V9XG4gKi9cbmZ1bmN0aW9uIGNvbXBpbGVMYW5ndWFnZShsYW5ndWFnZSkge1xuICAvKipcbiAgICogQnVpbGRzIGEgcmVnZXggd2l0aCB0aGUgY2FzZSBzZW5zaXRpdml0eSBvZiB0aGUgY3VycmVudCBsYW5ndWFnZVxuICAgKlxuICAgKiBAcGFyYW0ge1JlZ0V4cCB8IHN0cmluZ30gdmFsdWVcbiAgICogQHBhcmFtIHtib29sZWFufSBbZ2xvYmFsXVxuICAgKi9cbiAgZnVuY3Rpb24gbGFuZ1JlKHZhbHVlLCBnbG9iYWwpIHtcbiAgICByZXR1cm4gbmV3IFJlZ0V4cChcbiAgICAgIHNvdXJjZSh2YWx1ZSksXG4gICAgICAnbScgKyAobGFuZ3VhZ2UuY2FzZV9pbnNlbnNpdGl2ZSA/ICdpJyA6ICcnKSArIChnbG9iYWwgPyAnZycgOiAnJylcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAgU3RvcmVzIG11bHRpcGxlIHJlZ3VsYXIgZXhwcmVzc2lvbnMgYW5kIGFsbG93cyB5b3UgdG8gcXVpY2tseSBzZWFyY2ggZm9yXG4gICAgdGhlbSBhbGwgaW4gYSBzdHJpbmcgc2ltdWx0YW5lb3VzbHkgLSByZXR1cm5pbmcgdGhlIGZpcnN0IG1hdGNoLiAgSXQgZG9lc1xuICAgIHRoaXMgYnkgY3JlYXRpbmcgYSBodWdlIChhfGJ8YykgcmVnZXggLSBlYWNoIGluZGl2aWR1YWwgaXRlbSB3cmFwcGVkIHdpdGggKClcbiAgICBhbmQgam9pbmVkIGJ5IGB8YCAtIHVzaW5nIG1hdGNoIGdyb3VwcyB0byB0cmFjayBwb3NpdGlvbi4gIFdoZW4gYSBtYXRjaCBpc1xuICAgIGZvdW5kIGNoZWNraW5nIHdoaWNoIHBvc2l0aW9uIGluIHRoZSBhcnJheSBoYXMgY29udGVudCBhbGxvd3MgdXMgdG8gZmlndXJlXG4gICAgb3V0IHdoaWNoIG9mIHRoZSBvcmlnaW5hbCByZWdleGVzIC8gbWF0Y2ggZ3JvdXBzIHRyaWdnZXJlZCB0aGUgbWF0Y2guXG5cbiAgICBUaGUgbWF0Y2ggb2JqZWN0IGl0c2VsZiAodGhlIHJlc3VsdCBvZiBgUmVnZXguZXhlY2ApIGlzIHJldHVybmVkIGJ1dCBhbHNvXG4gICAgZW5oYW5jZWQgYnkgbWVyZ2luZyBpbiBhbnkgbWV0YS1kYXRhIHRoYXQgd2FzIHJlZ2lzdGVyZWQgd2l0aCB0aGUgcmVnZXguXG4gICAgVGhpcyBpcyBob3cgd2Uga2VlcCB0cmFjayBvZiB3aGljaCBtb2RlIG1hdGNoZWQsIGFuZCB3aGF0IHR5cGUgb2YgcnVsZVxuICAgIChgaWxsZWdhbGAsIGBiZWdpbmAsIGVuZCwgZXRjKS5cbiAgKi9cbiAgY2xhc3MgTXVsdGlSZWdleCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICB0aGlzLm1hdGNoSW5kZXhlcyA9IHt9O1xuICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgdGhpcy5yZWdleGVzID0gW107XG4gICAgICB0aGlzLm1hdGNoQXQgPSAxO1xuICAgICAgdGhpcy5wb3NpdGlvbiA9IDA7XG4gICAgfVxuXG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIGFkZFJ1bGUocmUsIG9wdHMpIHtcbiAgICAgIG9wdHMucG9zaXRpb24gPSB0aGlzLnBvc2l0aW9uKys7XG4gICAgICAvLyBAdHMtaWdub3JlXG4gICAgICB0aGlzLm1hdGNoSW5kZXhlc1t0aGlzLm1hdGNoQXRdID0gb3B0cztcbiAgICAgIHRoaXMucmVnZXhlcy5wdXNoKFtvcHRzLCByZV0pO1xuICAgICAgdGhpcy5tYXRjaEF0ICs9IGNvdW50TWF0Y2hHcm91cHMocmUpICsgMTtcbiAgICB9XG5cbiAgICBjb21waWxlKCkge1xuICAgICAgaWYgKHRoaXMucmVnZXhlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgLy8gYXZvaWRzIHRoZSBuZWVkIHRvIGNoZWNrIGxlbmd0aCBldmVyeSB0aW1lIGV4ZWMgaXMgY2FsbGVkXG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgdGhpcy5leGVjID0gKCkgPT4gbnVsbDtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHRlcm1pbmF0b3JzID0gdGhpcy5yZWdleGVzLm1hcChlbCA9PiBlbFsxXSk7XG4gICAgICB0aGlzLm1hdGNoZXJSZSA9IGxhbmdSZShfcmV3cml0ZUJhY2tyZWZlcmVuY2VzKHRlcm1pbmF0b3JzLCB7IGpvaW5XaXRoOiAnfCcgfSksIHRydWUpO1xuICAgICAgdGhpcy5sYXN0SW5kZXggPSAwO1xuICAgIH1cblxuICAgIC8qKiBAcGFyYW0ge3N0cmluZ30gcyAqL1xuICAgIGV4ZWMocykge1xuICAgICAgdGhpcy5tYXRjaGVyUmUubGFzdEluZGV4ID0gdGhpcy5sYXN0SW5kZXg7XG4gICAgICBjb25zdCBtYXRjaCA9IHRoaXMubWF0Y2hlclJlLmV4ZWMocyk7XG4gICAgICBpZiAoIW1hdGNoKSB7IHJldHVybiBudWxsOyB9XG5cbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlZmluZWRcbiAgICAgIGNvbnN0IGkgPSBtYXRjaC5maW5kSW5kZXgoKGVsLCBpKSA9PiBpID4gMCAmJiBlbCAhPT0gdW5kZWZpbmVkKTtcbiAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgIGNvbnN0IG1hdGNoRGF0YSA9IHRoaXMubWF0Y2hJbmRleGVzW2ldO1xuICAgICAgLy8gdHJpbSBvZmYgYW55IGVhcmxpZXIgbm9uLXJlbGV2YW50IG1hdGNoIGdyb3VwcyAoaWUsIHRoZSBvdGhlciByZWdleFxuICAgICAgLy8gbWF0Y2ggZ3JvdXBzIHRoYXQgbWFrZSB1cCB0aGUgbXVsdGktbWF0Y2hlcilcbiAgICAgIG1hdGNoLnNwbGljZSgwLCBpKTtcblxuICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24obWF0Y2gsIG1hdGNoRGF0YSk7XG4gICAgfVxuICB9XG5cbiAgLypcbiAgICBDcmVhdGVkIHRvIHNvbHZlIHRoZSBrZXkgZGVmaWNpZW50bHkgd2l0aCBNdWx0aVJlZ2V4IC0gdGhlcmUgaXMgbm8gd2F5IHRvXG4gICAgdGVzdCBmb3IgbXVsdGlwbGUgbWF0Y2hlcyBhdCBhIHNpbmdsZSBsb2NhdGlvbi4gIFdoeSB3b3VsZCB3ZSBuZWVkIHRvIGRvXG4gICAgdGhhdD8gIEluIHRoZSBmdXR1cmUgYSBtb3JlIGR5bmFtaWMgZW5naW5lIHdpbGwgYWxsb3cgY2VydGFpbiBtYXRjaGVzIHRvIGJlXG4gICAgaWdub3JlZC4gIEFuIGV4YW1wbGU6IGlmIHdlIG1hdGNoZWQgc2F5IHRoZSAzcmQgcmVnZXggaW4gYSBsYXJnZSBncm91cCBidXRcbiAgICBkZWNpZGVkIHRvIGlnbm9yZSBpdCAtIHdlJ2QgbmVlZCB0byBzdGFydGVkIHRlc3RpbmcgYWdhaW4gYXQgdGhlIDR0aFxuICAgIHJlZ2V4Li4uIGJ1dCBNdWx0aVJlZ2V4IGl0c2VsZiBnaXZlcyB1cyBubyByZWFsIHdheSB0byBkbyB0aGF0LlxuXG4gICAgU28gd2hhdCB0aGlzIGNsYXNzIGNyZWF0ZXMgTXVsdGlSZWdleHMgb24gdGhlIGZseSBmb3Igd2hhdGV2ZXIgc2VhcmNoXG4gICAgcG9zaXRpb24gdGhleSBhcmUgbmVlZGVkLlxuXG4gICAgTk9URTogVGhlc2UgYWRkaXRpb25hbCBNdWx0aVJlZ2V4IG9iamVjdHMgYXJlIGNyZWF0ZWQgZHluYW1pY2FsbHkuICBGb3IgbW9zdFxuICAgIGdyYW1tYXJzIG1vc3Qgb2YgdGhlIHRpbWUgd2Ugd2lsbCBuZXZlciBhY3R1YWxseSBuZWVkIGFueXRoaW5nIG1vcmUgdGhhbiB0aGVcbiAgICBmaXJzdCBNdWx0aVJlZ2V4IC0gc28gdGhpcyBzaG91bGRuJ3QgaGF2ZSB0b28gbXVjaCBvdmVyaGVhZC5cblxuICAgIFNheSB0aGlzIGlzIG91ciBzZWFyY2ggZ3JvdXAsIGFuZCB3ZSBtYXRjaCByZWdleDMsIGJ1dCB3aXNoIHRvIGlnbm9yZSBpdC5cblxuICAgICAgcmVnZXgxIHwgcmVnZXgyIHwgcmVnZXgzIHwgcmVnZXg0IHwgcmVnZXg1ICAgICcgaWUsIHN0YXJ0QXQgPSAwXG5cbiAgICBXaGF0IHdlIG5lZWQgaXMgYSBuZXcgTXVsdGlSZWdleCB0aGF0IG9ubHkgaW5jbHVkZXMgdGhlIHJlbWFpbmluZ1xuICAgIHBvc3NpYmlsaXRpZXM6XG5cbiAgICAgIHJlZ2V4NCB8IHJlZ2V4NSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnIGllLCBzdGFydEF0ID0gM1xuXG4gICAgVGhpcyBjbGFzcyB3cmFwcyBhbGwgdGhhdCBjb21wbGV4aXR5IHVwIGluIGEgc2ltcGxlIEFQSS4uLiBgc3RhcnRBdGAgZGVjaWRlc1xuICAgIHdoZXJlIGluIHRoZSBhcnJheSBvZiBleHByZXNzaW9ucyB0byBzdGFydCBkb2luZyB0aGUgbWF0Y2hpbmcuIEl0XG4gICAgYXV0by1pbmNyZW1lbnRzLCBzbyBpZiBhIG1hdGNoIGlzIGZvdW5kIGF0IHBvc2l0aW9uIDIsIHRoZW4gc3RhcnRBdCB3aWxsIGJlXG4gICAgc2V0IHRvIDMuICBJZiB0aGUgZW5kIGlzIHJlYWNoZWQgc3RhcnRBdCB3aWxsIHJldHVybiB0byAwLlxuXG4gICAgTU9TVCBvZiB0aGUgdGltZSB0aGUgcGFyc2VyIHdpbGwgYmUgc2V0dGluZyBzdGFydEF0IG1hbnVhbGx5IHRvIDAuXG4gICovXG4gIGNsYXNzIFJlc3VtYWJsZU11bHRpUmVnZXgge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgdGhpcy5ydWxlcyA9IFtdO1xuICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgdGhpcy5tdWx0aVJlZ2V4ZXMgPSBbXTtcbiAgICAgIHRoaXMuY291bnQgPSAwO1xuXG4gICAgICB0aGlzLmxhc3RJbmRleCA9IDA7XG4gICAgICB0aGlzLnJlZ2V4SW5kZXggPSAwO1xuICAgIH1cblxuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBnZXRNYXRjaGVyKGluZGV4KSB7XG4gICAgICBpZiAodGhpcy5tdWx0aVJlZ2V4ZXNbaW5kZXhdKSByZXR1cm4gdGhpcy5tdWx0aVJlZ2V4ZXNbaW5kZXhdO1xuXG4gICAgICBjb25zdCBtYXRjaGVyID0gbmV3IE11bHRpUmVnZXgoKTtcbiAgICAgIHRoaXMucnVsZXMuc2xpY2UoaW5kZXgpLmZvckVhY2goKFtyZSwgb3B0c10pID0+IG1hdGNoZXIuYWRkUnVsZShyZSwgb3B0cykpO1xuICAgICAgbWF0Y2hlci5jb21waWxlKCk7XG4gICAgICB0aGlzLm11bHRpUmVnZXhlc1tpbmRleF0gPSBtYXRjaGVyO1xuICAgICAgcmV0dXJuIG1hdGNoZXI7XG4gICAgfVxuXG4gICAgcmVzdW1pbmdTY2FuQXRTYW1lUG9zaXRpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5yZWdleEluZGV4ICE9PSAwO1xuICAgIH1cblxuICAgIGNvbnNpZGVyQWxsKCkge1xuICAgICAgdGhpcy5yZWdleEluZGV4ID0gMDtcbiAgICB9XG5cbiAgICAvLyBAdHMtaWdub3JlXG4gICAgYWRkUnVsZShyZSwgb3B0cykge1xuICAgICAgdGhpcy5ydWxlcy5wdXNoKFtyZSwgb3B0c10pO1xuICAgICAgaWYgKG9wdHMudHlwZSA9PT0gXCJiZWdpblwiKSB0aGlzLmNvdW50Kys7XG4gICAgfVxuXG4gICAgLyoqIEBwYXJhbSB7c3RyaW5nfSBzICovXG4gICAgZXhlYyhzKSB7XG4gICAgICBjb25zdCBtID0gdGhpcy5nZXRNYXRjaGVyKHRoaXMucmVnZXhJbmRleCk7XG4gICAgICBtLmxhc3RJbmRleCA9IHRoaXMubGFzdEluZGV4O1xuICAgICAgbGV0IHJlc3VsdCA9IG0uZXhlYyhzKTtcblxuICAgICAgLy8gVGhlIGZvbGxvd2luZyBpcyBiZWNhdXNlIHdlIGhhdmUgbm8gZWFzeSB3YXkgdG8gc2F5IFwicmVzdW1lIHNjYW5uaW5nIGF0IHRoZVxuICAgICAgLy8gZXhpc3RpbmcgcG9zaXRpb24gYnV0IGFsc28gc2tpcCB0aGUgY3VycmVudCBydWxlIE9OTFlcIi4gV2hhdCBoYXBwZW5zIGlzXG4gICAgICAvLyBhbGwgcHJpb3IgcnVsZXMgYXJlIGFsc28gc2tpcHBlZCB3aGljaCBjYW4gcmVzdWx0IGluIG1hdGNoaW5nIHRoZSB3cm9uZ1xuICAgICAgLy8gdGhpbmcuIEV4YW1wbGUgb2YgbWF0Y2hpbmcgXCJib29nZXJcIjpcblxuICAgICAgLy8gb3VyIG1hdGNoZXIgaXMgW3N0cmluZywgXCJib29nZXJcIiwgbnVtYmVyXVxuICAgICAgLy9cbiAgICAgIC8vIC4uLi5ib29nZXIuLi4uXG5cbiAgICAgIC8vIGlmIFwiYm9vZ2VyXCIgaXMgaWdub3JlZCB0aGVuIHdlJ2QgcmVhbGx5IG5lZWQgYSByZWdleCB0byBzY2FuIGZyb20gdGhlXG4gICAgICAvLyBTQU1FIHBvc2l0aW9uIGZvciBvbmx5OiBbc3RyaW5nLCBudW1iZXJdIGJ1dCBpZ25vcmluZyBcImJvb2dlclwiIChpZiBpdFxuICAgICAgLy8gd2FzIHRoZSBmaXJzdCBtYXRjaCksIGEgc2ltcGxlIHJlc3VtZSB3b3VsZCBzY2FuIGFoZWFkIHdobyBrbm93cyBob3dcbiAgICAgIC8vIGZhciBsb29raW5nIG9ubHkgZm9yIFwibnVtYmVyXCIsIGlnbm9yaW5nIHBvdGVudGlhbCBzdHJpbmcgbWF0Y2hlcyAob3JcbiAgICAgIC8vIGZ1dHVyZSBcImJvb2dlclwiIG1hdGNoZXMgdGhhdCBtaWdodCBiZSB2YWxpZC4pXG5cbiAgICAgIC8vIFNvIHdoYXQgd2UgZG86IFdlIGV4ZWN1dGUgdHdvIG1hdGNoZXJzLCBvbmUgcmVzdW1pbmcgYXQgdGhlIHNhbWVcbiAgICAgIC8vIHBvc2l0aW9uLCBidXQgdGhlIHNlY29uZCBmdWxsIG1hdGNoZXIgc3RhcnRpbmcgYXQgdGhlIHBvc2l0aW9uIGFmdGVyOlxuXG4gICAgICAvLyAgICAgLy0tLSByZXN1bWUgZmlyc3QgcmVnZXggbWF0Y2ggaGVyZSAoZm9yIFtudW1iZXJdKVxuICAgICAgLy8gICAgIHwvLS0tLSBmdWxsIG1hdGNoIGhlcmUgZm9yIFtzdHJpbmcsIFwiYm9vZ2VyXCIsIG51bWJlcl1cbiAgICAgIC8vICAgICB2dlxuICAgICAgLy8gLi4uLmJvb2dlci4uLi5cblxuICAgICAgLy8gV2hpY2ggZXZlciByZXN1bHRzIGluIGEgbWF0Y2ggZmlyc3QgaXMgdGhlbiB1c2VkLiBTbyB0aGlzIDMtNCBzdGVwXG4gICAgICAvLyBwcm9jZXNzIGVzc2VudGlhbGx5IGFsbG93cyB1cyB0byBzYXkgXCJtYXRjaCBhdCB0aGlzIHBvc2l0aW9uLCBleGNsdWRpbmdcbiAgICAgIC8vIGEgcHJpb3IgcnVsZSB0aGF0IHdhcyBpZ25vcmVkXCIuXG4gICAgICAvL1xuICAgICAgLy8gMS4gTWF0Y2ggXCJib29nZXJcIiBmaXJzdCwgaWdub3JlLiBBbHNvIHByb3ZlcyB0aGF0IFtzdHJpbmddIGRvZXMgbm9uIG1hdGNoLlxuICAgICAgLy8gMi4gUmVzdW1lIG1hdGNoaW5nIGZvciBbbnVtYmVyXVxuICAgICAgLy8gMy4gTWF0Y2ggYXQgaW5kZXggKyAxIGZvciBbc3RyaW5nLCBcImJvb2dlclwiLCBudW1iZXJdXG4gICAgICAvLyA0LiBJZiAjMiBhbmQgIzMgcmVzdWx0IGluIG1hdGNoZXMsIHdoaWNoIGNhbWUgZmlyc3Q/XG4gICAgICBpZiAodGhpcy5yZXN1bWluZ1NjYW5BdFNhbWVQb3NpdGlvbigpKSB7XG4gICAgICAgIGlmIChyZXN1bHQgJiYgcmVzdWx0LmluZGV4ID09PSB0aGlzLmxhc3RJbmRleCkgOyBlbHNlIHsgLy8gdXNlIHRoZSBzZWNvbmQgbWF0Y2hlciByZXN1bHRcbiAgICAgICAgICBjb25zdCBtMiA9IHRoaXMuZ2V0TWF0Y2hlcigwKTtcbiAgICAgICAgICBtMi5sYXN0SW5kZXggPSB0aGlzLmxhc3RJbmRleCArIDE7XG4gICAgICAgICAgcmVzdWx0ID0gbTIuZXhlYyhzKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgIHRoaXMucmVnZXhJbmRleCArPSByZXN1bHQucG9zaXRpb24gKyAxO1xuICAgICAgICBpZiAodGhpcy5yZWdleEluZGV4ID09PSB0aGlzLmNvdW50KSB7XG4gICAgICAgICAgLy8gd3JhcC1hcm91bmQgdG8gY29uc2lkZXJpbmcgYWxsIG1hdGNoZXMgYWdhaW5cbiAgICAgICAgICB0aGlzLmNvbnNpZGVyQWxsKCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogR2l2ZW4gYSBtb2RlLCBidWlsZHMgYSBodWdlIFJlc3VtYWJsZU11bHRpUmVnZXggdGhhdCBjYW4gYmUgdXNlZCB0byB3YWxrXG4gICAqIHRoZSBjb250ZW50IGFuZCBmaW5kIG1hdGNoZXMuXG4gICAqXG4gICAqIEBwYXJhbSB7Q29tcGlsZWRNb2RlfSBtb2RlXG4gICAqIEByZXR1cm5zIHtSZXN1bWFibGVNdWx0aVJlZ2V4fVxuICAgKi9cbiAgZnVuY3Rpb24gYnVpbGRNb2RlUmVnZXgobW9kZSkge1xuICAgIGNvbnN0IG1tID0gbmV3IFJlc3VtYWJsZU11bHRpUmVnZXgoKTtcblxuICAgIG1vZGUuY29udGFpbnMuZm9yRWFjaCh0ZXJtID0+IG1tLmFkZFJ1bGUodGVybS5iZWdpbiwgeyBydWxlOiB0ZXJtLCB0eXBlOiBcImJlZ2luXCIgfSkpO1xuXG4gICAgaWYgKG1vZGUudGVybWluYXRvckVuZCkge1xuICAgICAgbW0uYWRkUnVsZShtb2RlLnRlcm1pbmF0b3JFbmQsIHsgdHlwZTogXCJlbmRcIiB9KTtcbiAgICB9XG4gICAgaWYgKG1vZGUuaWxsZWdhbCkge1xuICAgICAgbW0uYWRkUnVsZShtb2RlLmlsbGVnYWwsIHsgdHlwZTogXCJpbGxlZ2FsXCIgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG1tO1xuICB9XG5cbiAgLyoqIHNraXAgdnMgYWJvcnQgdnMgaWdub3JlXG4gICAqXG4gICAqIEBza2lwICAgLSBUaGUgbW9kZSBpcyBzdGlsbCBlbnRlcmVkIGFuZCBleGl0ZWQgbm9ybWFsbHkgKGFuZCBjb250YWlucyBydWxlcyBhcHBseSksXG4gICAqICAgICAgICAgICBidXQgYWxsIGNvbnRlbnQgaXMgaGVsZCBhbmQgYWRkZWQgdG8gdGhlIHBhcmVudCBidWZmZXIgcmF0aGVyIHRoYW4gYmVpbmdcbiAgICogICAgICAgICAgIG91dHB1dCB3aGVuIHRoZSBtb2RlIGVuZHMuICBNb3N0bHkgdXNlZCB3aXRoIGBzdWJsYW5ndWFnZWAgdG8gYnVpbGQgdXBcbiAgICogICAgICAgICAgIGEgc2luZ2xlIGxhcmdlIGJ1ZmZlciB0aGFuIGNhbiBiZSBwYXJzZWQgYnkgc3VibGFuZ3VhZ2UuXG4gICAqXG4gICAqICAgICAgICAgICAgIC0gVGhlIG1vZGUgYmVnaW4gYW5kcyBlbmRzIG5vcm1hbGx5LlxuICAgKiAgICAgICAgICAgICAtIENvbnRlbnQgbWF0Y2hlZCBpcyBhZGRlZCB0byB0aGUgcGFyZW50IG1vZGUgYnVmZmVyLlxuICAgKiAgICAgICAgICAgICAtIFRoZSBwYXJzZXIgY3Vyc29yIGlzIG1vdmVkIGZvcndhcmQgbm9ybWFsbHkuXG4gICAqXG4gICAqIEBhYm9ydCAgLSBBIGhhY2sgcGxhY2Vob2xkZXIgdW50aWwgd2UgaGF2ZSBpZ25vcmUuICBBYm9ydHMgdGhlIG1vZGUgKGFzIGlmIGl0XG4gICAqICAgICAgICAgICBuZXZlciBtYXRjaGVkKSBidXQgRE9FUyBOT1QgY29udGludWUgdG8gbWF0Y2ggc3Vic2VxdWVudCBgY29udGFpbnNgXG4gICAqICAgICAgICAgICBtb2Rlcy4gIEFib3J0IGlzIGJhZC9zdWJvcHRpbWFsIGJlY2F1c2UgaXQgY2FuIHJlc3VsdCBpbiBtb2Rlc1xuICAgKiAgICAgICAgICAgZmFydGhlciBkb3duIG5vdCBnZXR0aW5nIGFwcGxpZWQgYmVjYXVzZSBhbiBlYXJsaWVyIHJ1bGUgZWF0cyB0aGVcbiAgICogICAgICAgICAgIGNvbnRlbnQgYnV0IHRoZW4gYWJvcnRzLlxuICAgKlxuICAgKiAgICAgICAgICAgICAtIFRoZSBtb2RlIGRvZXMgbm90IGJlZ2luLlxuICAgKiAgICAgICAgICAgICAtIENvbnRlbnQgbWF0Y2hlZCBieSBgYmVnaW5gIGlzIGFkZGVkIHRvIHRoZSBtb2RlIGJ1ZmZlci5cbiAgICogICAgICAgICAgICAgLSBUaGUgcGFyc2VyIGN1cnNvciBpcyBtb3ZlZCBmb3J3YXJkIGFjY29yZGluZ2x5LlxuICAgKlxuICAgKiBAaWdub3JlIC0gSWdub3JlcyB0aGUgbW9kZSAoYXMgaWYgaXQgbmV2ZXIgbWF0Y2hlZCkgYW5kIGNvbnRpbnVlcyB0byBtYXRjaCBhbnlcbiAgICogICAgICAgICAgIHN1YnNlcXVlbnQgYGNvbnRhaW5zYCBtb2Rlcy4gIElnbm9yZSBpc24ndCB0ZWNobmljYWxseSBwb3NzaWJsZSB3aXRoXG4gICAqICAgICAgICAgICB0aGUgY3VycmVudCBwYXJzZXIgaW1wbGVtZW50YXRpb24uXG4gICAqXG4gICAqICAgICAgICAgICAgIC0gVGhlIG1vZGUgZG9lcyBub3QgYmVnaW4uXG4gICAqICAgICAgICAgICAgIC0gQ29udGVudCBtYXRjaGVkIGJ5IGBiZWdpbmAgaXMgaWdub3JlZC5cbiAgICogICAgICAgICAgICAgLSBUaGUgcGFyc2VyIGN1cnNvciBpcyBub3QgbW92ZWQgZm9yd2FyZC5cbiAgICovXG5cbiAgLyoqXG4gICAqIENvbXBpbGVzIGFuIGluZGl2aWR1YWwgbW9kZVxuICAgKlxuICAgKiBUaGlzIGNhbiByYWlzZSBhbiBlcnJvciBpZiB0aGUgbW9kZSBjb250YWlucyBjZXJ0YWluIGRldGVjdGFibGUga25vd24gbG9naWNcbiAgICogaXNzdWVzLlxuICAgKiBAcGFyYW0ge01vZGV9IG1vZGVcbiAgICogQHBhcmFtIHtDb21waWxlZE1vZGUgfCBudWxsfSBbcGFyZW50XVxuICAgKiBAcmV0dXJucyB7Q29tcGlsZWRNb2RlIHwgbmV2ZXJ9XG4gICAqL1xuICBmdW5jdGlvbiBjb21waWxlTW9kZShtb2RlLCBwYXJlbnQpIHtcbiAgICBjb25zdCBjbW9kZSA9IC8qKiBAdHlwZSBDb21waWxlZE1vZGUgKi8gKG1vZGUpO1xuICAgIGlmIChtb2RlLmlzQ29tcGlsZWQpIHJldHVybiBjbW9kZTtcblxuICAgIFtcbiAgICAgIHNjb3BlQ2xhc3NOYW1lLFxuICAgICAgLy8gZG8gdGhpcyBlYXJseSBzbyBjb21waWxlciBleHRlbnNpb25zIGdlbmVyYWxseSBkb24ndCBoYXZlIHRvIHdvcnJ5IGFib3V0XG4gICAgICAvLyB0aGUgZGlzdGluY3Rpb24gYmV0d2VlbiBtYXRjaC9iZWdpblxuICAgICAgY29tcGlsZU1hdGNoLFxuICAgICAgTXVsdGlDbGFzcyxcbiAgICAgIGJlZm9yZU1hdGNoRXh0XG4gICAgXS5mb3JFYWNoKGV4dCA9PiBleHQobW9kZSwgcGFyZW50KSk7XG5cbiAgICBsYW5ndWFnZS5jb21waWxlckV4dGVuc2lvbnMuZm9yRWFjaChleHQgPT4gZXh0KG1vZGUsIHBhcmVudCkpO1xuXG4gICAgLy8gX19iZWZvcmVCZWdpbiBpcyBjb25zaWRlcmVkIHByaXZhdGUgQVBJLCBpbnRlcm5hbCB1c2Ugb25seVxuICAgIG1vZGUuX19iZWZvcmVCZWdpbiA9IG51bGw7XG5cbiAgICBbXG4gICAgICBiZWdpbktleXdvcmRzLFxuICAgICAgLy8gZG8gdGhpcyBsYXRlciBzbyBjb21waWxlciBleHRlbnNpb25zIHRoYXQgY29tZSBlYXJsaWVyIGhhdmUgYWNjZXNzIHRvIHRoZVxuICAgICAgLy8gcmF3IGFycmF5IGlmIHRoZXkgd2FudGVkIHRvIHBlcmhhcHMgbWFuaXB1bGF0ZSBpdCwgZXRjLlxuICAgICAgY29tcGlsZUlsbGVnYWwsXG4gICAgICAvLyBkZWZhdWx0IHRvIDEgcmVsZXZhbmNlIGlmIG5vdCBzcGVjaWZpZWRcbiAgICAgIGNvbXBpbGVSZWxldmFuY2VcbiAgICBdLmZvckVhY2goZXh0ID0+IGV4dChtb2RlLCBwYXJlbnQpKTtcblxuICAgIG1vZGUuaXNDb21waWxlZCA9IHRydWU7XG5cbiAgICBsZXQga2V5d29yZFBhdHRlcm4gPSBudWxsO1xuICAgIGlmICh0eXBlb2YgbW9kZS5rZXl3b3JkcyA9PT0gXCJvYmplY3RcIiAmJiBtb2RlLmtleXdvcmRzLiRwYXR0ZXJuKSB7XG4gICAgICAvLyB3ZSBuZWVkIGEgY29weSBiZWNhdXNlIGtleXdvcmRzIG1pZ2h0IGJlIGNvbXBpbGVkIG11bHRpcGxlIHRpbWVzXG4gICAgICAvLyBzbyB3ZSBjYW4ndCBnbyBkZWxldGluZyAkcGF0dGVybiBmcm9tIHRoZSBvcmlnaW5hbCBvbiB0aGUgZmlyc3RcbiAgICAgIC8vIHBhc3NcbiAgICAgIG1vZGUua2V5d29yZHMgPSBPYmplY3QuYXNzaWduKHt9LCBtb2RlLmtleXdvcmRzKTtcbiAgICAgIGtleXdvcmRQYXR0ZXJuID0gbW9kZS5rZXl3b3Jkcy4kcGF0dGVybjtcbiAgICAgIGRlbGV0ZSBtb2RlLmtleXdvcmRzLiRwYXR0ZXJuO1xuICAgIH1cbiAgICBrZXl3b3JkUGF0dGVybiA9IGtleXdvcmRQYXR0ZXJuIHx8IC9cXHcrLztcblxuICAgIGlmIChtb2RlLmtleXdvcmRzKSB7XG4gICAgICBtb2RlLmtleXdvcmRzID0gY29tcGlsZUtleXdvcmRzKG1vZGUua2V5d29yZHMsIGxhbmd1YWdlLmNhc2VfaW5zZW5zaXRpdmUpO1xuICAgIH1cblxuICAgIGNtb2RlLmtleXdvcmRQYXR0ZXJuUmUgPSBsYW5nUmUoa2V5d29yZFBhdHRlcm4sIHRydWUpO1xuXG4gICAgaWYgKHBhcmVudCkge1xuICAgICAgaWYgKCFtb2RlLmJlZ2luKSBtb2RlLmJlZ2luID0gL1xcQnxcXGIvO1xuICAgICAgY21vZGUuYmVnaW5SZSA9IGxhbmdSZShtb2RlLmJlZ2luKTtcbiAgICAgIGlmICghbW9kZS5lbmQgJiYgIW1vZGUuZW5kc1dpdGhQYXJlbnQpIG1vZGUuZW5kID0gL1xcQnxcXGIvO1xuICAgICAgaWYgKG1vZGUuZW5kKSBjbW9kZS5lbmRSZSA9IGxhbmdSZShtb2RlLmVuZCk7XG4gICAgICBjbW9kZS50ZXJtaW5hdG9yRW5kID0gc291cmNlKG1vZGUuZW5kKSB8fCAnJztcbiAgICAgIGlmIChtb2RlLmVuZHNXaXRoUGFyZW50ICYmIHBhcmVudC50ZXJtaW5hdG9yRW5kKSB7XG4gICAgICAgIGNtb2RlLnRlcm1pbmF0b3JFbmQgKz0gKG1vZGUuZW5kID8gJ3wnIDogJycpICsgcGFyZW50LnRlcm1pbmF0b3JFbmQ7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChtb2RlLmlsbGVnYWwpIGNtb2RlLmlsbGVnYWxSZSA9IGxhbmdSZSgvKiogQHR5cGUge1JlZ0V4cCB8IHN0cmluZ30gKi8gKG1vZGUuaWxsZWdhbCkpO1xuICAgIGlmICghbW9kZS5jb250YWlucykgbW9kZS5jb250YWlucyA9IFtdO1xuXG4gICAgbW9kZS5jb250YWlucyA9IFtdLmNvbmNhdCguLi5tb2RlLmNvbnRhaW5zLm1hcChmdW5jdGlvbihjKSB7XG4gICAgICByZXR1cm4gZXhwYW5kT3JDbG9uZU1vZGUoYyA9PT0gJ3NlbGYnID8gbW9kZSA6IGMpO1xuICAgIH0pKTtcbiAgICBtb2RlLmNvbnRhaW5zLmZvckVhY2goZnVuY3Rpb24oYykgeyBjb21waWxlTW9kZSgvKiogQHR5cGUgTW9kZSAqLyAoYyksIGNtb2RlKTsgfSk7XG5cbiAgICBpZiAobW9kZS5zdGFydHMpIHtcbiAgICAgIGNvbXBpbGVNb2RlKG1vZGUuc3RhcnRzLCBwYXJlbnQpO1xuICAgIH1cblxuICAgIGNtb2RlLm1hdGNoZXIgPSBidWlsZE1vZGVSZWdleChjbW9kZSk7XG4gICAgcmV0dXJuIGNtb2RlO1xuICB9XG5cbiAgaWYgKCFsYW5ndWFnZS5jb21waWxlckV4dGVuc2lvbnMpIGxhbmd1YWdlLmNvbXBpbGVyRXh0ZW5zaW9ucyA9IFtdO1xuXG4gIC8vIHNlbGYgaXMgbm90IHZhbGlkIGF0IHRoZSB0b3AtbGV2ZWxcbiAgaWYgKGxhbmd1YWdlLmNvbnRhaW5zICYmIGxhbmd1YWdlLmNvbnRhaW5zLmluY2x1ZGVzKCdzZWxmJykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJFUlI6IGNvbnRhaW5zIGBzZWxmYCBpcyBub3Qgc3VwcG9ydGVkIGF0IHRoZSB0b3AtbGV2ZWwgb2YgYSBsYW5ndWFnZS4gIFNlZSBkb2N1bWVudGF0aW9uLlwiKTtcbiAgfVxuXG4gIC8vIHdlIG5lZWQgYSBudWxsIG9iamVjdCwgd2hpY2ggaW5oZXJpdCB3aWxsIGd1YXJhbnRlZVxuICBsYW5ndWFnZS5jbGFzc05hbWVBbGlhc2VzID0gaW5oZXJpdCQxKGxhbmd1YWdlLmNsYXNzTmFtZUFsaWFzZXMgfHwge30pO1xuXG4gIHJldHVybiBjb21waWxlTW9kZSgvKiogQHR5cGUgTW9kZSAqLyAobGFuZ3VhZ2UpKTtcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmVzIGlmIGEgbW9kZSBoYXMgYSBkZXBlbmRlbmN5IG9uIGl0J3MgcGFyZW50IG9yIG5vdFxuICpcbiAqIElmIGEgbW9kZSBkb2VzIGhhdmUgYSBwYXJlbnQgZGVwZW5kZW5jeSB0aGVuIG9mdGVuIHdlIG5lZWQgdG8gY2xvbmUgaXQgaWZcbiAqIGl0J3MgdXNlZCBpbiBtdWx0aXBsZSBwbGFjZXMgc28gdGhhdCBlYWNoIGNvcHkgcG9pbnRzIHRvIHRoZSBjb3JyZWN0IHBhcmVudCxcbiAqIHdoZXJlLWFzIG1vZGVzIHdpdGhvdXQgYSBwYXJlbnQgY2FuIG9mdGVuIHNhZmVseSBiZSByZS11c2VkIGF0IHRoZSBib3R0b20gb2ZcbiAqIGEgbW9kZSBjaGFpbi5cbiAqXG4gKiBAcGFyYW0ge01vZGUgfCBudWxsfSBtb2RlXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gLSBpcyB0aGVyZSBhIGRlcGVuZGVuY3kgb24gdGhlIHBhcmVudD9cbiAqICovXG5mdW5jdGlvbiBkZXBlbmRlbmN5T25QYXJlbnQobW9kZSkge1xuICBpZiAoIW1vZGUpIHJldHVybiBmYWxzZTtcblxuICByZXR1cm4gbW9kZS5lbmRzV2l0aFBhcmVudCB8fCBkZXBlbmRlbmN5T25QYXJlbnQobW9kZS5zdGFydHMpO1xufVxuXG4vKipcbiAqIEV4cGFuZHMgYSBtb2RlIG9yIGNsb25lcyBpdCBpZiBuZWNlc3NhcnlcbiAqXG4gKiBUaGlzIGlzIG5lY2Vzc2FyeSBmb3IgbW9kZXMgd2l0aCBwYXJlbnRhbCBkZXBlbmRlbmNlaXMgKHNlZSBub3RlcyBvblxuICogYGRlcGVuZGVuY3lPblBhcmVudGApIGFuZCBmb3Igbm9kZXMgdGhhdCBoYXZlIGB2YXJpYW50c2AgLSB3aGljaCBtdXN0IHRoZW4gYmVcbiAqIGV4cGxvZGVkIGludG8gdGhlaXIgb3duIGluZGl2aWR1YWwgbW9kZXMgYXQgY29tcGlsZSB0aW1lLlxuICpcbiAqIEBwYXJhbSB7TW9kZX0gbW9kZVxuICogQHJldHVybnMge01vZGUgfCBNb2RlW119XG4gKiAqL1xuZnVuY3Rpb24gZXhwYW5kT3JDbG9uZU1vZGUobW9kZSkge1xuICBpZiAobW9kZS52YXJpYW50cyAmJiAhbW9kZS5jYWNoZWRWYXJpYW50cykge1xuICAgIG1vZGUuY2FjaGVkVmFyaWFudHMgPSBtb2RlLnZhcmlhbnRzLm1hcChmdW5jdGlvbih2YXJpYW50KSB7XG4gICAgICByZXR1cm4gaW5oZXJpdCQxKG1vZGUsIHsgdmFyaWFudHM6IG51bGwgfSwgdmFyaWFudCk7XG4gICAgfSk7XG4gIH1cblxuICAvLyBFWFBBTkRcbiAgLy8gaWYgd2UgaGF2ZSB2YXJpYW50cyB0aGVuIGVzc2VudGlhbGx5IFwicmVwbGFjZVwiIHRoZSBtb2RlIHdpdGggdGhlIHZhcmlhbnRzXG4gIC8vIHRoaXMgaGFwcGVucyBpbiBjb21waWxlTW9kZSwgd2hlcmUgdGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQgZnJvbVxuICBpZiAobW9kZS5jYWNoZWRWYXJpYW50cykge1xuICAgIHJldHVybiBtb2RlLmNhY2hlZFZhcmlhbnRzO1xuICB9XG5cbiAgLy8gQ0xPTkVcbiAgLy8gaWYgd2UgaGF2ZSBkZXBlbmRlbmNpZXMgb24gcGFyZW50cyB0aGVuIHdlIG5lZWQgYSB1bmlxdWVcbiAgLy8gaW5zdGFuY2Ugb2Ygb3Vyc2VsdmVzLCBzbyB3ZSBjYW4gYmUgcmV1c2VkIHdpdGggbWFueVxuICAvLyBkaWZmZXJlbnQgcGFyZW50cyB3aXRob3V0IGlzc3VlXG4gIGlmIChkZXBlbmRlbmN5T25QYXJlbnQobW9kZSkpIHtcbiAgICByZXR1cm4gaW5oZXJpdCQxKG1vZGUsIHsgc3RhcnRzOiBtb2RlLnN0YXJ0cyA/IGluaGVyaXQkMShtb2RlLnN0YXJ0cykgOiBudWxsIH0pO1xuICB9XG5cbiAgaWYgKE9iamVjdC5pc0Zyb3plbihtb2RlKSkge1xuICAgIHJldHVybiBpbmhlcml0JDEobW9kZSk7XG4gIH1cblxuICAvLyBubyBzcGVjaWFsIGRlcGVuZGVuY3kgaXNzdWVzLCBqdXN0IHJldHVybiBvdXJzZWx2ZXNcbiAgcmV0dXJuIG1vZGU7XG59XG5cbnZhciB2ZXJzaW9uID0gXCIxMS4yLjBcIjtcblxuLypcblN5bnRheCBoaWdobGlnaHRpbmcgd2l0aCBsYW5ndWFnZSBhdXRvZGV0ZWN0aW9uLlxuaHR0cHM6Ly9oaWdobGlnaHRqcy5vcmcvXG4qL1xuXG4vKipcbkB0eXBlZGVmIHtpbXBvcnQoJ2hpZ2hsaWdodC5qcycpLk1vZGV9IE1vZGVcbkB0eXBlZGVmIHtpbXBvcnQoJ2hpZ2hsaWdodC5qcycpLkNvbXBpbGVkTW9kZX0gQ29tcGlsZWRNb2RlXG5AdHlwZWRlZiB7aW1wb3J0KCdoaWdobGlnaHQuanMnKS5MYW5ndWFnZX0gTGFuZ3VhZ2VcbkB0eXBlZGVmIHtpbXBvcnQoJ2hpZ2hsaWdodC5qcycpLkhMSlNBcGl9IEhMSlNBcGlcbkB0eXBlZGVmIHtpbXBvcnQoJ2hpZ2hsaWdodC5qcycpLkhMSlNQbHVnaW59IEhMSlNQbHVnaW5cbkB0eXBlZGVmIHtpbXBvcnQoJ2hpZ2hsaWdodC5qcycpLlBsdWdpbkV2ZW50fSBQbHVnaW5FdmVudFxuQHR5cGVkZWYge2ltcG9ydCgnaGlnaGxpZ2h0LmpzJykuSExKU09wdGlvbnN9IEhMSlNPcHRpb25zXG5AdHlwZWRlZiB7aW1wb3J0KCdoaWdobGlnaHQuanMnKS5MYW5ndWFnZUZufSBMYW5ndWFnZUZuXG5AdHlwZWRlZiB7aW1wb3J0KCdoaWdobGlnaHQuanMnKS5IaWdobGlnaHRlZEhUTUxFbGVtZW50fSBIaWdobGlnaHRlZEhUTUxFbGVtZW50XG5AdHlwZWRlZiB7aW1wb3J0KCdoaWdobGlnaHQuanMnKS5CZWZvcmVIaWdobGlnaHRDb250ZXh0fSBCZWZvcmVIaWdobGlnaHRDb250ZXh0XG5AdHlwZWRlZiB7aW1wb3J0KCdoaWdobGlnaHQuanMvcHJpdmF0ZScpLk1hdGNoVHlwZX0gTWF0Y2hUeXBlXG5AdHlwZWRlZiB7aW1wb3J0KCdoaWdobGlnaHQuanMvcHJpdmF0ZScpLktleXdvcmREYXRhfSBLZXl3b3JkRGF0YVxuQHR5cGVkZWYge2ltcG9ydCgnaGlnaGxpZ2h0LmpzL3ByaXZhdGUnKS5FbmhhbmNlZE1hdGNofSBFbmhhbmNlZE1hdGNoXG5AdHlwZWRlZiB7aW1wb3J0KCdoaWdobGlnaHQuanMvcHJpdmF0ZScpLkFubm90YXRlZEVycm9yfSBBbm5vdGF0ZWRFcnJvclxuQHR5cGVkZWYge2ltcG9ydCgnaGlnaGxpZ2h0LmpzJykuQXV0b0hpZ2hsaWdodFJlc3VsdH0gQXV0b0hpZ2hsaWdodFJlc3VsdFxuQHR5cGVkZWYge2ltcG9ydCgnaGlnaGxpZ2h0LmpzJykuSGlnaGxpZ2h0T3B0aW9uc30gSGlnaGxpZ2h0T3B0aW9uc1xuQHR5cGVkZWYge2ltcG9ydCgnaGlnaGxpZ2h0LmpzJykuSGlnaGxpZ2h0UmVzdWx0fSBIaWdobGlnaHRSZXN1bHRcbiovXG5cblxuY29uc3QgZXNjYXBlID0gZXNjYXBlSFRNTDtcbmNvbnN0IGluaGVyaXQgPSBpbmhlcml0JDE7XG5jb25zdCBOT19NQVRDSCA9IFN5bWJvbChcIm5vbWF0Y2hcIik7XG5jb25zdCBNQVhfS0VZV09SRF9ISVRTID0gNztcblxuLyoqXG4gKiBAcGFyYW0ge2FueX0gaGxqcyAtIG9iamVjdCB0aGF0IGlzIGV4dGVuZGVkIChsZWdhY3kpXG4gKiBAcmV0dXJucyB7SExKU0FwaX1cbiAqL1xuY29uc3QgSExKUyA9IGZ1bmN0aW9uKGhsanMpIHtcbiAgLy8gR2xvYmFsIGludGVybmFsIHZhcmlhYmxlcyB1c2VkIHdpdGhpbiB0aGUgaGlnaGxpZ2h0LmpzIGxpYnJhcnkuXG4gIC8qKiBAdHlwZSB7UmVjb3JkPHN0cmluZywgTGFuZ3VhZ2U+fSAqL1xuICBjb25zdCBsYW5ndWFnZXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAvKiogQHR5cGUge1JlY29yZDxzdHJpbmcsIHN0cmluZz59ICovXG4gIGNvbnN0IGFsaWFzZXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAvKiogQHR5cGUge0hMSlNQbHVnaW5bXX0gKi9cbiAgY29uc3QgcGx1Z2lucyA9IFtdO1xuXG4gIC8vIHNhZmUvcHJvZHVjdGlvbiBtb2RlIC0gc3dhbGxvd3MgbW9yZSBlcnJvcnMsIHRyaWVzIHRvIGtlZXAgcnVubmluZ1xuICAvLyBldmVuIGlmIGEgc2luZ2xlIHN5bnRheCBvciBwYXJzZSBoaXRzIGEgZmF0YWwgZXJyb3JcbiAgbGV0IFNBRkVfTU9ERSA9IHRydWU7XG4gIGNvbnN0IExBTkdVQUdFX05PVF9GT1VORCA9IFwiQ291bGQgbm90IGZpbmQgdGhlIGxhbmd1YWdlICd7fScsIGRpZCB5b3UgZm9yZ2V0IHRvIGxvYWQvaW5jbHVkZSBhIGxhbmd1YWdlIG1vZHVsZT9cIjtcbiAgLyoqIEB0eXBlIHtMYW5ndWFnZX0gKi9cbiAgY29uc3QgUExBSU5URVhUX0xBTkdVQUdFID0geyBkaXNhYmxlQXV0b2RldGVjdDogdHJ1ZSwgbmFtZTogJ1BsYWluIHRleHQnLCBjb250YWluczogW10gfTtcblxuICAvLyBHbG9iYWwgb3B0aW9ucyB1c2VkIHdoZW4gd2l0aGluIGV4dGVybmFsIEFQSXMuIFRoaXMgaXMgbW9kaWZpZWQgd2hlblxuICAvLyBjYWxsaW5nIHRoZSBgaGxqcy5jb25maWd1cmVgIGZ1bmN0aW9uLlxuICAvKiogQHR5cGUgSExKU09wdGlvbnMgKi9cbiAgbGV0IG9wdGlvbnMgPSB7XG4gICAgaWdub3JlVW5lc2NhcGVkSFRNTDogZmFsc2UsXG4gICAgbm9IaWdobGlnaHRSZTogL14obm8tP2hpZ2hsaWdodCkkL2ksXG4gICAgbGFuZ3VhZ2VEZXRlY3RSZTogL1xcYmxhbmcoPzp1YWdlKT8tKFtcXHctXSspXFxiL2ksXG4gICAgY2xhc3NQcmVmaXg6ICdobGpzLScsXG4gICAgY3NzU2VsZWN0b3I6ICdwcmUgY29kZScsXG4gICAgbGFuZ3VhZ2VzOiBudWxsLFxuICAgIC8vIGJldGEgY29uZmlndXJhdGlvbiBvcHRpb25zLCBzdWJqZWN0IHRvIGNoYW5nZSwgd2VsY29tZSB0byBkaXNjdXNzXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2hpZ2hsaWdodGpzL2hpZ2hsaWdodC5qcy9pc3N1ZXMvMTA4NlxuICAgIF9fZW1pdHRlcjogVG9rZW5UcmVlRW1pdHRlclxuICB9O1xuXG4gIC8qIFV0aWxpdHkgZnVuY3Rpb25zICovXG5cbiAgLyoqXG4gICAqIFRlc3RzIGEgbGFuZ3VhZ2UgbmFtZSB0byBzZWUgaWYgaGlnaGxpZ2h0aW5nIHNob3VsZCBiZSBza2lwcGVkXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBsYW5ndWFnZU5hbWVcbiAgICovXG4gIGZ1bmN0aW9uIHNob3VsZE5vdEhpZ2hsaWdodChsYW5ndWFnZU5hbWUpIHtcbiAgICByZXR1cm4gb3B0aW9ucy5ub0hpZ2hsaWdodFJlLnRlc3QobGFuZ3VhZ2VOYW1lKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0hpZ2hsaWdodGVkSFRNTEVsZW1lbnR9IGJsb2NrIC0gdGhlIEhUTUwgZWxlbWVudCB0byBkZXRlcm1pbmUgbGFuZ3VhZ2UgZm9yXG4gICAqL1xuICBmdW5jdGlvbiBibG9ja0xhbmd1YWdlKGJsb2NrKSB7XG4gICAgbGV0IGNsYXNzZXMgPSBibG9jay5jbGFzc05hbWUgKyAnICc7XG5cbiAgICBjbGFzc2VzICs9IGJsb2NrLnBhcmVudE5vZGUgPyBibG9jay5wYXJlbnROb2RlLmNsYXNzTmFtZSA6ICcnO1xuXG4gICAgLy8gbGFuZ3VhZ2UtKiB0YWtlcyBwcmVjZWRlbmNlIG92ZXIgbm9uLXByZWZpeGVkIGNsYXNzIG5hbWVzLlxuICAgIGNvbnN0IG1hdGNoID0gb3B0aW9ucy5sYW5ndWFnZURldGVjdFJlLmV4ZWMoY2xhc3Nlcyk7XG4gICAgaWYgKG1hdGNoKSB7XG4gICAgICBjb25zdCBsYW5ndWFnZSA9IGdldExhbmd1YWdlKG1hdGNoWzFdKTtcbiAgICAgIGlmICghbGFuZ3VhZ2UpIHtcbiAgICAgICAgd2FybihMQU5HVUFHRV9OT1RfRk9VTkQucmVwbGFjZShcInt9XCIsIG1hdGNoWzFdKSk7XG4gICAgICAgIHdhcm4oXCJGYWxsaW5nIGJhY2sgdG8gbm8taGlnaGxpZ2h0IG1vZGUgZm9yIHRoaXMgYmxvY2suXCIsIGJsb2NrKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBsYW5ndWFnZSA/IG1hdGNoWzFdIDogJ25vLWhpZ2hsaWdodCc7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNsYXNzZXNcbiAgICAgIC5zcGxpdCgvXFxzKy8pXG4gICAgICAuZmluZCgoX2NsYXNzKSA9PiBzaG91bGROb3RIaWdobGlnaHQoX2NsYXNzKSB8fCBnZXRMYW5ndWFnZShfY2xhc3MpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb3JlIGhpZ2hsaWdodGluZyBmdW5jdGlvbi5cbiAgICpcbiAgICogT0xEIEFQSVxuICAgKiBoaWdobGlnaHQobGFuZywgY29kZSwgaWdub3JlSWxsZWdhbHMsIGNvbnRpbnVhdGlvbilcbiAgICpcbiAgICogTkVXIEFQSVxuICAgKiBoaWdobGlnaHQoY29kZSwge2xhbmcsIGlnbm9yZUlsbGVnYWxzfSlcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNvZGVPckxhbmd1YWdlTmFtZSAtIHRoZSBsYW5ndWFnZSB0byB1c2UgZm9yIGhpZ2hsaWdodGluZ1xuICAgKiBAcGFyYW0ge3N0cmluZyB8IEhpZ2hsaWdodE9wdGlvbnN9IG9wdGlvbnNPckNvZGUgLSB0aGUgY29kZSB0byBoaWdobGlnaHRcbiAgICogQHBhcmFtIHtib29sZWFufSBbaWdub3JlSWxsZWdhbHNdIC0gd2hldGhlciB0byBpZ25vcmUgaWxsZWdhbCBtYXRjaGVzLCBkZWZhdWx0IGlzIHRvIGJhaWxcbiAgICpcbiAgICogQHJldHVybnMge0hpZ2hsaWdodFJlc3VsdH0gUmVzdWx0IC0gYW4gb2JqZWN0IHRoYXQgcmVwcmVzZW50cyB0aGUgcmVzdWx0XG4gICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBsYW5ndWFnZSAtIHRoZSBsYW5ndWFnZSBuYW1lXG4gICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSByZWxldmFuY2UgLSB0aGUgcmVsZXZhbmNlIHNjb3JlXG4gICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSB2YWx1ZSAtIHRoZSBoaWdobGlnaHRlZCBIVE1MIGNvZGVcbiAgICogQHByb3BlcnR5IHtzdHJpbmd9IGNvZGUgLSB0aGUgb3JpZ2luYWwgcmF3IGNvZGVcbiAgICogQHByb3BlcnR5IHtDb21waWxlZE1vZGV9IHRvcCAtIHRvcCBvZiB0aGUgY3VycmVudCBtb2RlIHN0YWNrXG4gICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gaWxsZWdhbCAtIGluZGljYXRlcyB3aGV0aGVyIGFueSBpbGxlZ2FsIG1hdGNoZXMgd2VyZSBmb3VuZFxuICAqL1xuICBmdW5jdGlvbiBoaWdobGlnaHQoY29kZU9yTGFuZ3VhZ2VOYW1lLCBvcHRpb25zT3JDb2RlLCBpZ25vcmVJbGxlZ2Fscykge1xuICAgIGxldCBjb2RlID0gXCJcIjtcbiAgICBsZXQgbGFuZ3VhZ2VOYW1lID0gXCJcIjtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnNPckNvZGUgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgIGNvZGUgPSBjb2RlT3JMYW5ndWFnZU5hbWU7XG4gICAgICBpZ25vcmVJbGxlZ2FscyA9IG9wdGlvbnNPckNvZGUuaWdub3JlSWxsZWdhbHM7XG4gICAgICBsYW5ndWFnZU5hbWUgPSBvcHRpb25zT3JDb2RlLmxhbmd1YWdlO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBvbGQgQVBJXG4gICAgICBkZXByZWNhdGVkKFwiMTAuNy4wXCIsIFwiaGlnaGxpZ2h0KGxhbmcsIGNvZGUsIC4uLmFyZ3MpIGhhcyBiZWVuIGRlcHJlY2F0ZWQuXCIpO1xuICAgICAgZGVwcmVjYXRlZChcIjEwLjcuMFwiLCBcIlBsZWFzZSB1c2UgaGlnaGxpZ2h0KGNvZGUsIG9wdGlvbnMpIGluc3RlYWQuXFxuaHR0cHM6Ly9naXRodWIuY29tL2hpZ2hsaWdodGpzL2hpZ2hsaWdodC5qcy9pc3N1ZXMvMjI3N1wiKTtcbiAgICAgIGxhbmd1YWdlTmFtZSA9IGNvZGVPckxhbmd1YWdlTmFtZTtcbiAgICAgIGNvZGUgPSBvcHRpb25zT3JDb2RlO1xuICAgIH1cblxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9oaWdobGlnaHRqcy9oaWdobGlnaHQuanMvaXNzdWVzLzMxNDlcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5kZWZpbmVkXG4gICAgaWYgKGlnbm9yZUlsbGVnYWxzID09PSB1bmRlZmluZWQpIHsgaWdub3JlSWxsZWdhbHMgPSB0cnVlOyB9XG5cbiAgICAvKiogQHR5cGUge0JlZm9yZUhpZ2hsaWdodENvbnRleHR9ICovXG4gICAgY29uc3QgY29udGV4dCA9IHtcbiAgICAgIGNvZGUsXG4gICAgICBsYW5ndWFnZTogbGFuZ3VhZ2VOYW1lXG4gICAgfTtcbiAgICAvLyB0aGUgcGx1Z2luIGNhbiBjaGFuZ2UgdGhlIGRlc2lyZWQgbGFuZ3VhZ2Ugb3IgdGhlIGNvZGUgdG8gYmUgaGlnaGxpZ2h0ZWRcbiAgICAvLyBqdXN0IGJlIGNoYW5naW5nIHRoZSBvYmplY3QgaXQgd2FzIHBhc3NlZFxuICAgIGZpcmUoXCJiZWZvcmU6aGlnaGxpZ2h0XCIsIGNvbnRleHQpO1xuXG4gICAgLy8gYSBiZWZvcmUgcGx1Z2luIGNhbiB1c3VycCB0aGUgcmVzdWx0IGNvbXBsZXRlbHkgYnkgcHJvdmlkaW5nIGl0J3Mgb3duXG4gICAgLy8gaW4gd2hpY2ggY2FzZSB3ZSBkb24ndCBldmVuIG5lZWQgdG8gY2FsbCBoaWdobGlnaHRcbiAgICBjb25zdCByZXN1bHQgPSBjb250ZXh0LnJlc3VsdFxuICAgICAgPyBjb250ZXh0LnJlc3VsdFxuICAgICAgOiBfaGlnaGxpZ2h0KGNvbnRleHQubGFuZ3VhZ2UsIGNvbnRleHQuY29kZSwgaWdub3JlSWxsZWdhbHMpO1xuXG4gICAgcmVzdWx0LmNvZGUgPSBjb250ZXh0LmNvZGU7XG4gICAgLy8gdGhlIHBsdWdpbiBjYW4gY2hhbmdlIGFueXRoaW5nIGluIHJlc3VsdCB0byBzdWl0ZSBpdFxuICAgIGZpcmUoXCJhZnRlcjpoaWdobGlnaHRcIiwgcmVzdWx0KTtcblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogcHJpdmF0ZSBoaWdobGlnaHQgdGhhdCdzIHVzZWQgaW50ZXJuYWxseSBhbmQgZG9lcyBub3QgZmlyZSBjYWxsYmFja3NcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGxhbmd1YWdlTmFtZSAtIHRoZSBsYW5ndWFnZSB0byB1c2UgZm9yIGhpZ2hsaWdodGluZ1xuICAgKiBAcGFyYW0ge3N0cmluZ30gY29kZVRvSGlnaGxpZ2h0IC0gdGhlIGNvZGUgdG8gaGlnaGxpZ2h0XG4gICAqIEBwYXJhbSB7Ym9vbGVhbj99IFtpZ25vcmVJbGxlZ2Fsc10gLSB3aGV0aGVyIHRvIGlnbm9yZSBpbGxlZ2FsIG1hdGNoZXMsIGRlZmF1bHQgaXMgdG8gYmFpbFxuICAgKiBAcGFyYW0ge0NvbXBpbGVkTW9kZT99IFtjb250aW51YXRpb25dIC0gY3VycmVudCBjb250aW51YXRpb24gbW9kZSwgaWYgYW55XG4gICAqIEByZXR1cm5zIHtIaWdobGlnaHRSZXN1bHR9IC0gcmVzdWx0IG9mIHRoZSBoaWdobGlnaHQgb3BlcmF0aW9uXG4gICovXG4gIGZ1bmN0aW9uIF9oaWdobGlnaHQobGFuZ3VhZ2VOYW1lLCBjb2RlVG9IaWdobGlnaHQsIGlnbm9yZUlsbGVnYWxzLCBjb250aW51YXRpb24pIHtcbiAgICBjb25zdCBrZXl3b3JkSGl0cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4ga2V5d29yZCBkYXRhIGlmIGEgbWF0Y2ggaXMgYSBrZXl3b3JkXG4gICAgICogQHBhcmFtIHtDb21waWxlZE1vZGV9IG1vZGUgLSBjdXJyZW50IG1vZGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbWF0Y2hUZXh0IC0gdGhlIHRleHR1YWwgbWF0Y2hcbiAgICAgKiBAcmV0dXJucyB7S2V5d29yZERhdGEgfCBmYWxzZX1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBrZXl3b3JkRGF0YShtb2RlLCBtYXRjaFRleHQpIHtcbiAgICAgIHJldHVybiBtb2RlLmtleXdvcmRzW21hdGNoVGV4dF07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcHJvY2Vzc0tleXdvcmRzKCkge1xuICAgICAgaWYgKCF0b3Aua2V5d29yZHMpIHtcbiAgICAgICAgZW1pdHRlci5hZGRUZXh0KG1vZGVCdWZmZXIpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGxldCBsYXN0SW5kZXggPSAwO1xuICAgICAgdG9wLmtleXdvcmRQYXR0ZXJuUmUubGFzdEluZGV4ID0gMDtcbiAgICAgIGxldCBtYXRjaCA9IHRvcC5rZXl3b3JkUGF0dGVyblJlLmV4ZWMobW9kZUJ1ZmZlcik7XG4gICAgICBsZXQgYnVmID0gXCJcIjtcblxuICAgICAgd2hpbGUgKG1hdGNoKSB7XG4gICAgICAgIGJ1ZiArPSBtb2RlQnVmZmVyLnN1YnN0cmluZyhsYXN0SW5kZXgsIG1hdGNoLmluZGV4KTtcbiAgICAgICAgY29uc3Qgd29yZCA9IGxhbmd1YWdlLmNhc2VfaW5zZW5zaXRpdmUgPyBtYXRjaFswXS50b0xvd2VyQ2FzZSgpIDogbWF0Y2hbMF07XG4gICAgICAgIGNvbnN0IGRhdGEgPSBrZXl3b3JkRGF0YSh0b3AsIHdvcmQpO1xuICAgICAgICBpZiAoZGF0YSkge1xuICAgICAgICAgIGNvbnN0IFtraW5kLCBrZXl3b3JkUmVsZXZhbmNlXSA9IGRhdGE7XG4gICAgICAgICAgZW1pdHRlci5hZGRUZXh0KGJ1Zik7XG4gICAgICAgICAgYnVmID0gXCJcIjtcblxuICAgICAgICAgIGtleXdvcmRIaXRzW3dvcmRdID0gKGtleXdvcmRIaXRzW3dvcmRdIHx8IDApICsgMTtcbiAgICAgICAgICBpZiAoa2V5d29yZEhpdHNbd29yZF0gPD0gTUFYX0tFWVdPUkRfSElUUykgcmVsZXZhbmNlICs9IGtleXdvcmRSZWxldmFuY2U7XG4gICAgICAgICAgaWYgKGtpbmQuc3RhcnRzV2l0aChcIl9cIikpIHtcbiAgICAgICAgICAgIC8vIF8gaW1wbGllZCBmb3IgcmVsZXZhbmNlIG9ubHksIGRvIG5vdCBoaWdobGlnaHRcbiAgICAgICAgICAgIC8vIGJ5IGFwcGx5aW5nIGEgY2xhc3MgbmFtZVxuICAgICAgICAgICAgYnVmICs9IG1hdGNoWzBdO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBjc3NDbGFzcyA9IGxhbmd1YWdlLmNsYXNzTmFtZUFsaWFzZXNba2luZF0gfHwga2luZDtcbiAgICAgICAgICAgIGVtaXR0ZXIuYWRkS2V5d29yZChtYXRjaFswXSwgY3NzQ2xhc3MpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBidWYgKz0gbWF0Y2hbMF07XG4gICAgICAgIH1cbiAgICAgICAgbGFzdEluZGV4ID0gdG9wLmtleXdvcmRQYXR0ZXJuUmUubGFzdEluZGV4O1xuICAgICAgICBtYXRjaCA9IHRvcC5rZXl3b3JkUGF0dGVyblJlLmV4ZWMobW9kZUJ1ZmZlcik7XG4gICAgICB9XG4gICAgICBidWYgKz0gbW9kZUJ1ZmZlci5zdWJzdHIobGFzdEluZGV4KTtcbiAgICAgIGVtaXR0ZXIuYWRkVGV4dChidWYpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHByb2Nlc3NTdWJMYW5ndWFnZSgpIHtcbiAgICAgIGlmIChtb2RlQnVmZmVyID09PSBcIlwiKSByZXR1cm47XG4gICAgICAvKiogQHR5cGUgSGlnaGxpZ2h0UmVzdWx0ICovXG4gICAgICBsZXQgcmVzdWx0ID0gbnVsbDtcblxuICAgICAgaWYgKHR5cGVvZiB0b3Auc3ViTGFuZ3VhZ2UgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGlmICghbGFuZ3VhZ2VzW3RvcC5zdWJMYW5ndWFnZV0pIHtcbiAgICAgICAgICBlbWl0dGVyLmFkZFRleHQobW9kZUJ1ZmZlcik7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdCA9IF9oaWdobGlnaHQodG9wLnN1Ykxhbmd1YWdlLCBtb2RlQnVmZmVyLCB0cnVlLCBjb250aW51YXRpb25zW3RvcC5zdWJMYW5ndWFnZV0pO1xuICAgICAgICBjb250aW51YXRpb25zW3RvcC5zdWJMYW5ndWFnZV0gPSAvKiogQHR5cGUge0NvbXBpbGVkTW9kZX0gKi8gKHJlc3VsdC5fdG9wKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdCA9IGhpZ2hsaWdodEF1dG8obW9kZUJ1ZmZlciwgdG9wLnN1Ykxhbmd1YWdlLmxlbmd0aCA/IHRvcC5zdWJMYW5ndWFnZSA6IG51bGwpO1xuICAgICAgfVxuXG4gICAgICAvLyBDb3VudGluZyBlbWJlZGRlZCBsYW5ndWFnZSBzY29yZSB0b3dhcmRzIHRoZSBob3N0IGxhbmd1YWdlIG1heSBiZSBkaXNhYmxlZFxuICAgICAgLy8gd2l0aCB6ZXJvaW5nIHRoZSBjb250YWluaW5nIG1vZGUgcmVsZXZhbmNlLiBVc2UgY2FzZSBpbiBwb2ludCBpcyBNYXJrZG93biB0aGF0XG4gICAgICAvLyBhbGxvd3MgWE1MIGV2ZXJ5d2hlcmUgYW5kIG1ha2VzIGV2ZXJ5IFhNTCBzbmlwcGV0IHRvIGhhdmUgYSBtdWNoIGxhcmdlciBNYXJrZG93blxuICAgICAgLy8gc2NvcmUuXG4gICAgICBpZiAodG9wLnJlbGV2YW5jZSA+IDApIHtcbiAgICAgICAgcmVsZXZhbmNlICs9IHJlc3VsdC5yZWxldmFuY2U7XG4gICAgICB9XG4gICAgICBlbWl0dGVyLmFkZFN1Ymxhbmd1YWdlKHJlc3VsdC5fZW1pdHRlciwgcmVzdWx0Lmxhbmd1YWdlKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwcm9jZXNzQnVmZmVyKCkge1xuICAgICAgaWYgKHRvcC5zdWJMYW5ndWFnZSAhPSBudWxsKSB7XG4gICAgICAgIHByb2Nlc3NTdWJMYW5ndWFnZSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHJvY2Vzc0tleXdvcmRzKCk7XG4gICAgICB9XG4gICAgICBtb2RlQnVmZmVyID0gJyc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtDb21waWxlZE1vZGV9IG1vZGVcbiAgICAgKiBAcGFyYW0ge1JlZ0V4cE1hdGNoQXJyYXl9IG1hdGNoXG4gICAgICovXG4gICAgZnVuY3Rpb24gZW1pdE11bHRpQ2xhc3Moc2NvcGUsIG1hdGNoKSB7XG4gICAgICBsZXQgaSA9IDE7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5kZWZpbmVkXG4gICAgICB3aGlsZSAobWF0Y2hbaV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAoIXNjb3BlLl9lbWl0W2ldKSB7IGkrKzsgY29udGludWU7IH1cbiAgICAgICAgY29uc3Qga2xhc3MgPSBsYW5ndWFnZS5jbGFzc05hbWVBbGlhc2VzW3Njb3BlW2ldXSB8fCBzY29wZVtpXTtcbiAgICAgICAgY29uc3QgdGV4dCA9IG1hdGNoW2ldO1xuICAgICAgICBpZiAoa2xhc3MpIHtcbiAgICAgICAgICBlbWl0dGVyLmFkZEtleXdvcmQodGV4dCwga2xhc3MpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG1vZGVCdWZmZXIgPSB0ZXh0O1xuICAgICAgICAgIHByb2Nlc3NLZXl3b3JkcygpO1xuICAgICAgICAgIG1vZGVCdWZmZXIgPSBcIlwiO1xuICAgICAgICB9XG4gICAgICAgIGkrKztcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0NvbXBpbGVkTW9kZX0gbW9kZSAtIG5ldyBtb2RlIHRvIHN0YXJ0XG4gICAgICogQHBhcmFtIHtSZWdFeHBNYXRjaEFycmF5fSBtYXRjaFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHN0YXJ0TmV3TW9kZShtb2RlLCBtYXRjaCkge1xuICAgICAgaWYgKG1vZGUuc2NvcGUgJiYgdHlwZW9mIG1vZGUuc2NvcGUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgZW1pdHRlci5vcGVuTm9kZShsYW5ndWFnZS5jbGFzc05hbWVBbGlhc2VzW21vZGUuc2NvcGVdIHx8IG1vZGUuc2NvcGUpO1xuICAgICAgfVxuICAgICAgaWYgKG1vZGUuYmVnaW5TY29wZSkge1xuICAgICAgICAvLyBiZWdpblNjb3BlIGp1c3Qgd3JhcHMgdGhlIGJlZ2luIG1hdGNoIGl0c2VsZiBpbiBhIHNjb3BlXG4gICAgICAgIGlmIChtb2RlLmJlZ2luU2NvcGUuX3dyYXApIHtcbiAgICAgICAgICBlbWl0dGVyLmFkZEtleXdvcmQobW9kZUJ1ZmZlciwgbGFuZ3VhZ2UuY2xhc3NOYW1lQWxpYXNlc1ttb2RlLmJlZ2luU2NvcGUuX3dyYXBdIHx8IG1vZGUuYmVnaW5TY29wZS5fd3JhcCk7XG4gICAgICAgICAgbW9kZUJ1ZmZlciA9IFwiXCI7XG4gICAgICAgIH0gZWxzZSBpZiAobW9kZS5iZWdpblNjb3BlLl9tdWx0aSkge1xuICAgICAgICAgIC8vIGF0IHRoaXMgcG9pbnQgbW9kZUJ1ZmZlciBzaG91bGQganVzdCBiZSB0aGUgbWF0Y2hcbiAgICAgICAgICBlbWl0TXVsdGlDbGFzcyhtb2RlLmJlZ2luU2NvcGUsIG1hdGNoKTtcbiAgICAgICAgICBtb2RlQnVmZmVyID0gXCJcIjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0b3AgPSBPYmplY3QuY3JlYXRlKG1vZGUsIHsgcGFyZW50OiB7IHZhbHVlOiB0b3AgfSB9KTtcbiAgICAgIHJldHVybiB0b3A7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtDb21waWxlZE1vZGUgfSBtb2RlIC0gdGhlIG1vZGUgdG8gcG90ZW50aWFsbHkgZW5kXG4gICAgICogQHBhcmFtIHtSZWdFeHBNYXRjaEFycmF5fSBtYXRjaCAtIHRoZSBsYXRlc3QgbWF0Y2hcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbWF0Y2hQbHVzUmVtYWluZGVyIC0gbWF0Y2ggcGx1cyByZW1haW5kZXIgb2YgY29udGVudFxuICAgICAqIEByZXR1cm5zIHtDb21waWxlZE1vZGUgfCB2b2lkfSAtIHRoZSBuZXh0IG1vZGUsIG9yIGlmIHZvaWQgY29udGludWUgb24gaW4gY3VycmVudCBtb2RlXG4gICAgICovXG4gICAgZnVuY3Rpb24gZW5kT2ZNb2RlKG1vZGUsIG1hdGNoLCBtYXRjaFBsdXNSZW1haW5kZXIpIHtcbiAgICAgIGxldCBtYXRjaGVkID0gc3RhcnRzV2l0aChtb2RlLmVuZFJlLCBtYXRjaFBsdXNSZW1haW5kZXIpO1xuXG4gICAgICBpZiAobWF0Y2hlZCkge1xuICAgICAgICBpZiAobW9kZVtcIm9uOmVuZFwiXSkge1xuICAgICAgICAgIGNvbnN0IHJlc3AgPSBuZXcgUmVzcG9uc2UobW9kZSk7XG4gICAgICAgICAgbW9kZVtcIm9uOmVuZFwiXShtYXRjaCwgcmVzcCk7XG4gICAgICAgICAgaWYgKHJlc3AuaXNNYXRjaElnbm9yZWQpIG1hdGNoZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtYXRjaGVkKSB7XG4gICAgICAgICAgd2hpbGUgKG1vZGUuZW5kc1BhcmVudCAmJiBtb2RlLnBhcmVudCkge1xuICAgICAgICAgICAgbW9kZSA9IG1vZGUucGFyZW50O1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbW9kZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gZXZlbiBpZiBvbjplbmQgZmlyZXMgYW4gYGlnbm9yZWAgaXQncyBzdGlsbCBwb3NzaWJsZVxuICAgICAgLy8gdGhhdCB3ZSBtaWdodCB0cmlnZ2VyIHRoZSBlbmQgbm9kZSBiZWNhdXNlIG9mIGEgcGFyZW50IG1vZGVcbiAgICAgIGlmIChtb2RlLmVuZHNXaXRoUGFyZW50KSB7XG4gICAgICAgIHJldHVybiBlbmRPZk1vZGUobW9kZS5wYXJlbnQsIG1hdGNoLCBtYXRjaFBsdXNSZW1haW5kZXIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEhhbmRsZSBtYXRjaGluZyBidXQgdGhlbiBpZ25vcmluZyBhIHNlcXVlbmNlIG9mIHRleHRcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBsZXhlbWUgLSBzdHJpbmcgY29udGFpbmluZyBmdWxsIG1hdGNoIHRleHRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBkb0lnbm9yZShsZXhlbWUpIHtcbiAgICAgIGlmICh0b3AubWF0Y2hlci5yZWdleEluZGV4ID09PSAwKSB7XG4gICAgICAgIC8vIG5vIG1vcmUgcmVnZXhlcyB0byBwb3RlbnRpYWxseSBtYXRjaCBoZXJlLCBzbyB3ZSBtb3ZlIHRoZSBjdXJzb3IgZm9yd2FyZCBvbmVcbiAgICAgICAgLy8gc3BhY2VcbiAgICAgICAgbW9kZUJ1ZmZlciArPSBsZXhlbWVbMF07XG4gICAgICAgIHJldHVybiAxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gbm8gbmVlZCB0byBtb3ZlIHRoZSBjdXJzb3IsIHdlIHN0aWxsIGhhdmUgYWRkaXRpb25hbCByZWdleGVzIHRvIHRyeSBhbmRcbiAgICAgICAgLy8gbWF0Y2ggYXQgdGhpcyB2ZXJ5IHNwb3RcbiAgICAgICAgcmVzdW1lU2NhbkF0U2FtZVBvc2l0aW9uID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSGFuZGxlIHRoZSBzdGFydCBvZiBhIG5ldyBwb3RlbnRpYWwgbW9kZSBtYXRjaFxuICAgICAqXG4gICAgICogQHBhcmFtIHtFbmhhbmNlZE1hdGNofSBtYXRjaCAtIHRoZSBjdXJyZW50IG1hdGNoXG4gICAgICogQHJldHVybnMge251bWJlcn0gaG93IGZhciB0byBhZHZhbmNlIHRoZSBwYXJzZSBjdXJzb3JcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBkb0JlZ2luTWF0Y2gobWF0Y2gpIHtcbiAgICAgIGNvbnN0IGxleGVtZSA9IG1hdGNoWzBdO1xuICAgICAgY29uc3QgbmV3TW9kZSA9IG1hdGNoLnJ1bGU7XG5cbiAgICAgIGNvbnN0IHJlc3AgPSBuZXcgUmVzcG9uc2UobmV3TW9kZSk7XG4gICAgICAvLyBmaXJzdCBpbnRlcm5hbCBiZWZvcmUgY2FsbGJhY2tzLCB0aGVuIHRoZSBwdWJsaWMgb25lc1xuICAgICAgY29uc3QgYmVmb3JlQ2FsbGJhY2tzID0gW25ld01vZGUuX19iZWZvcmVCZWdpbiwgbmV3TW9kZVtcIm9uOmJlZ2luXCJdXTtcbiAgICAgIGZvciAoY29uc3QgY2Igb2YgYmVmb3JlQ2FsbGJhY2tzKSB7XG4gICAgICAgIGlmICghY2IpIGNvbnRpbnVlO1xuICAgICAgICBjYihtYXRjaCwgcmVzcCk7XG4gICAgICAgIGlmIChyZXNwLmlzTWF0Y2hJZ25vcmVkKSByZXR1cm4gZG9JZ25vcmUobGV4ZW1lKTtcbiAgICAgIH1cblxuICAgICAgaWYgKG5ld01vZGUuc2tpcCkge1xuICAgICAgICBtb2RlQnVmZmVyICs9IGxleGVtZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChuZXdNb2RlLmV4Y2x1ZGVCZWdpbikge1xuICAgICAgICAgIG1vZGVCdWZmZXIgKz0gbGV4ZW1lO1xuICAgICAgICB9XG4gICAgICAgIHByb2Nlc3NCdWZmZXIoKTtcbiAgICAgICAgaWYgKCFuZXdNb2RlLnJldHVybkJlZ2luICYmICFuZXdNb2RlLmV4Y2x1ZGVCZWdpbikge1xuICAgICAgICAgIG1vZGVCdWZmZXIgPSBsZXhlbWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHN0YXJ0TmV3TW9kZShuZXdNb2RlLCBtYXRjaCk7XG4gICAgICByZXR1cm4gbmV3TW9kZS5yZXR1cm5CZWdpbiA/IDAgOiBsZXhlbWUubGVuZ3RoO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEhhbmRsZSB0aGUgcG90ZW50aWFsIGVuZCBvZiBtb2RlXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1JlZ0V4cE1hdGNoQXJyYXl9IG1hdGNoIC0gdGhlIGN1cnJlbnQgbWF0Y2hcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBkb0VuZE1hdGNoKG1hdGNoKSB7XG4gICAgICBjb25zdCBsZXhlbWUgPSBtYXRjaFswXTtcbiAgICAgIGNvbnN0IG1hdGNoUGx1c1JlbWFpbmRlciA9IGNvZGVUb0hpZ2hsaWdodC5zdWJzdHIobWF0Y2guaW5kZXgpO1xuXG4gICAgICBjb25zdCBlbmRNb2RlID0gZW5kT2ZNb2RlKHRvcCwgbWF0Y2gsIG1hdGNoUGx1c1JlbWFpbmRlcik7XG4gICAgICBpZiAoIWVuZE1vZGUpIHsgcmV0dXJuIE5PX01BVENIOyB9XG5cbiAgICAgIGNvbnN0IG9yaWdpbiA9IHRvcDtcbiAgICAgIGlmICh0b3AuZW5kU2NvcGUgJiYgdG9wLmVuZFNjb3BlLl93cmFwKSB7XG4gICAgICAgIHByb2Nlc3NCdWZmZXIoKTtcbiAgICAgICAgZW1pdHRlci5hZGRLZXl3b3JkKGxleGVtZSwgdG9wLmVuZFNjb3BlLl93cmFwKTtcbiAgICAgIH0gZWxzZSBpZiAodG9wLmVuZFNjb3BlICYmIHRvcC5lbmRTY29wZS5fbXVsdGkpIHtcbiAgICAgICAgcHJvY2Vzc0J1ZmZlcigpO1xuICAgICAgICBlbWl0TXVsdGlDbGFzcyh0b3AuZW5kU2NvcGUsIG1hdGNoKTtcbiAgICAgIH0gZWxzZSBpZiAob3JpZ2luLnNraXApIHtcbiAgICAgICAgbW9kZUJ1ZmZlciArPSBsZXhlbWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoIShvcmlnaW4ucmV0dXJuRW5kIHx8IG9yaWdpbi5leGNsdWRlRW5kKSkge1xuICAgICAgICAgIG1vZGVCdWZmZXIgKz0gbGV4ZW1lO1xuICAgICAgICB9XG4gICAgICAgIHByb2Nlc3NCdWZmZXIoKTtcbiAgICAgICAgaWYgKG9yaWdpbi5leGNsdWRlRW5kKSB7XG4gICAgICAgICAgbW9kZUJ1ZmZlciA9IGxleGVtZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZG8ge1xuICAgICAgICBpZiAodG9wLnNjb3BlKSB7XG4gICAgICAgICAgZW1pdHRlci5jbG9zZU5vZGUoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRvcC5za2lwICYmICF0b3Auc3ViTGFuZ3VhZ2UpIHtcbiAgICAgICAgICByZWxldmFuY2UgKz0gdG9wLnJlbGV2YW5jZTtcbiAgICAgICAgfVxuICAgICAgICB0b3AgPSB0b3AucGFyZW50O1xuICAgICAgfSB3aGlsZSAodG9wICE9PSBlbmRNb2RlLnBhcmVudCk7XG4gICAgICBpZiAoZW5kTW9kZS5zdGFydHMpIHtcbiAgICAgICAgc3RhcnROZXdNb2RlKGVuZE1vZGUuc3RhcnRzLCBtYXRjaCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gb3JpZ2luLnJldHVybkVuZCA/IDAgOiBsZXhlbWUubGVuZ3RoO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHByb2Nlc3NDb250aW51YXRpb25zKCkge1xuICAgICAgY29uc3QgbGlzdCA9IFtdO1xuICAgICAgZm9yIChsZXQgY3VycmVudCA9IHRvcDsgY3VycmVudCAhPT0gbGFuZ3VhZ2U7IGN1cnJlbnQgPSBjdXJyZW50LnBhcmVudCkge1xuICAgICAgICBpZiAoY3VycmVudC5zY29wZSkge1xuICAgICAgICAgIGxpc3QudW5zaGlmdChjdXJyZW50LnNjb3BlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgbGlzdC5mb3JFYWNoKGl0ZW0gPT4gZW1pdHRlci5vcGVuTm9kZShpdGVtKSk7XG4gICAgfVxuXG4gICAgLyoqIEB0eXBlIHt7dHlwZT86IE1hdGNoVHlwZSwgaW5kZXg/OiBudW1iZXIsIHJ1bGU/OiBNb2RlfX19ICovXG4gICAgbGV0IGxhc3RNYXRjaCA9IHt9O1xuXG4gICAgLyoqXG4gICAgICogIFByb2Nlc3MgYW4gaW5kaXZpZHVhbCBtYXRjaFxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRleHRCZWZvcmVNYXRjaCAtIHRleHQgcHJlY2VkaW5nIHRoZSBtYXRjaCAoc2luY2UgdGhlIGxhc3QgbWF0Y2gpXG4gICAgICogQHBhcmFtIHtFbmhhbmNlZE1hdGNofSBbbWF0Y2hdIC0gdGhlIG1hdGNoIGl0c2VsZlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHByb2Nlc3NMZXhlbWUodGV4dEJlZm9yZU1hdGNoLCBtYXRjaCkge1xuICAgICAgY29uc3QgbGV4ZW1lID0gbWF0Y2ggJiYgbWF0Y2hbMF07XG5cbiAgICAgIC8vIGFkZCBub24tbWF0Y2hlZCB0ZXh0IHRvIHRoZSBjdXJyZW50IG1vZGUgYnVmZmVyXG4gICAgICBtb2RlQnVmZmVyICs9IHRleHRCZWZvcmVNYXRjaDtcblxuICAgICAgaWYgKGxleGVtZSA9PSBudWxsKSB7XG4gICAgICAgIHByb2Nlc3NCdWZmZXIoKTtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9XG5cbiAgICAgIC8vIHdlJ3ZlIGZvdW5kIGEgMCB3aWR0aCBtYXRjaCBhbmQgd2UncmUgc3R1Y2ssIHNvIHdlIG5lZWQgdG8gYWR2YW5jZVxuICAgICAgLy8gdGhpcyBoYXBwZW5zIHdoZW4gd2UgaGF2ZSBiYWRseSBiZWhhdmVkIHJ1bGVzIHRoYXQgaGF2ZSBvcHRpb25hbCBtYXRjaGVycyB0byB0aGUgZGVncmVlIHRoYXRcbiAgICAgIC8vIHNvbWV0aW1lcyB0aGV5IGNhbiBlbmQgdXAgbWF0Y2hpbmcgbm90aGluZyBhdCBhbGxcbiAgICAgIC8vIFJlZjogaHR0cHM6Ly9naXRodWIuY29tL2hpZ2hsaWdodGpzL2hpZ2hsaWdodC5qcy9pc3N1ZXMvMjE0MFxuICAgICAgaWYgKGxhc3RNYXRjaC50eXBlID09PSBcImJlZ2luXCIgJiYgbWF0Y2gudHlwZSA9PT0gXCJlbmRcIiAmJiBsYXN0TWF0Y2guaW5kZXggPT09IG1hdGNoLmluZGV4ICYmIGxleGVtZSA9PT0gXCJcIikge1xuICAgICAgICAvLyBzcGl0IHRoZSBcInNraXBwZWRcIiBjaGFyYWN0ZXIgdGhhdCBvdXIgcmVnZXggY2hva2VkIG9uIGJhY2sgaW50byB0aGUgb3V0cHV0IHNlcXVlbmNlXG4gICAgICAgIG1vZGVCdWZmZXIgKz0gY29kZVRvSGlnaGxpZ2h0LnNsaWNlKG1hdGNoLmluZGV4LCBtYXRjaC5pbmRleCArIDEpO1xuICAgICAgICBpZiAoIVNBRkVfTU9ERSkge1xuICAgICAgICAgIC8qKiBAdHlwZSB7QW5ub3RhdGVkRXJyb3J9ICovXG4gICAgICAgICAgY29uc3QgZXJyID0gbmV3IEVycm9yKGAwIHdpZHRoIG1hdGNoIHJlZ2V4ICgke2xhbmd1YWdlTmFtZX0pYCk7XG4gICAgICAgICAgZXJyLmxhbmd1YWdlTmFtZSA9IGxhbmd1YWdlTmFtZTtcbiAgICAgICAgICBlcnIuYmFkUnVsZSA9IGxhc3RNYXRjaC5ydWxlO1xuICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gMTtcbiAgICAgIH1cbiAgICAgIGxhc3RNYXRjaCA9IG1hdGNoO1xuXG4gICAgICBpZiAobWF0Y2gudHlwZSA9PT0gXCJiZWdpblwiKSB7XG4gICAgICAgIHJldHVybiBkb0JlZ2luTWF0Y2gobWF0Y2gpO1xuICAgICAgfSBlbHNlIGlmIChtYXRjaC50eXBlID09PSBcImlsbGVnYWxcIiAmJiAhaWdub3JlSWxsZWdhbHMpIHtcbiAgICAgICAgLy8gaWxsZWdhbCBtYXRjaCwgd2UgZG8gbm90IGNvbnRpbnVlIHByb2Nlc3NpbmdcbiAgICAgICAgLyoqIEB0eXBlIHtBbm5vdGF0ZWRFcnJvcn0gKi9cbiAgICAgICAgY29uc3QgZXJyID0gbmV3IEVycm9yKCdJbGxlZ2FsIGxleGVtZSBcIicgKyBsZXhlbWUgKyAnXCIgZm9yIG1vZGUgXCInICsgKHRvcC5zY29wZSB8fCAnPHVubmFtZWQ+JykgKyAnXCInKTtcbiAgICAgICAgZXJyLm1vZGUgPSB0b3A7XG4gICAgICAgIHRocm93IGVycjtcbiAgICAgIH0gZWxzZSBpZiAobWF0Y2gudHlwZSA9PT0gXCJlbmRcIikge1xuICAgICAgICBjb25zdCBwcm9jZXNzZWQgPSBkb0VuZE1hdGNoKG1hdGNoKTtcbiAgICAgICAgaWYgKHByb2Nlc3NlZCAhPT0gTk9fTUFUQ0gpIHtcbiAgICAgICAgICByZXR1cm4gcHJvY2Vzc2VkO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIGVkZ2UgY2FzZSBmb3Igd2hlbiBpbGxlZ2FsIG1hdGNoZXMgJCAoZW5kIG9mIGxpbmUpIHdoaWNoIGlzIHRlY2huaWNhbGx5XG4gICAgICAvLyBhIDAgd2lkdGggbWF0Y2ggYnV0IG5vdCBhIGJlZ2luL2VuZCBtYXRjaCBzbyBpdCdzIG5vdCBjYXVnaHQgYnkgdGhlXG4gICAgICAvLyBmaXJzdCBoYW5kbGVyICh3aGVuIGlnbm9yZUlsbGVnYWxzIGlzIHRydWUpXG4gICAgICBpZiAobWF0Y2gudHlwZSA9PT0gXCJpbGxlZ2FsXCIgJiYgbGV4ZW1lID09PSBcIlwiKSB7XG4gICAgICAgIC8vIGFkdmFuY2Ugc28gd2UgYXJlbid0IHN0dWNrIGluIGFuIGluZmluaXRlIGxvb3BcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgICB9XG5cbiAgICAgIC8vIGluZmluaXRlIGxvb3BzIGFyZSBCQUQsIHRoaXMgaXMgYSBsYXN0IGRpdGNoIGNhdGNoIGFsbC4gaWYgd2UgaGF2ZSBhXG4gICAgICAvLyBkZWNlbnQgbnVtYmVyIG9mIGl0ZXJhdGlvbnMgeWV0IG91ciBpbmRleCAoY3Vyc29yIHBvc2l0aW9uIGluIG91clxuICAgICAgLy8gcGFyc2luZykgc3RpbGwgM3ggYmVoaW5kIG91ciBpbmRleCB0aGVuIHNvbWV0aGluZyBpcyB2ZXJ5IHdyb25nXG4gICAgICAvLyBzbyB3ZSBiYWlsXG4gICAgICBpZiAoaXRlcmF0aW9ucyA+IDEwMDAwMCAmJiBpdGVyYXRpb25zID4gbWF0Y2guaW5kZXggKiAzKSB7XG4gICAgICAgIGNvbnN0IGVyciA9IG5ldyBFcnJvcigncG90ZW50aWFsIGluZmluaXRlIGxvb3AsIHdheSBtb3JlIGl0ZXJhdGlvbnMgdGhhbiBtYXRjaGVzJyk7XG4gICAgICAgIHRocm93IGVycjtcbiAgICAgIH1cblxuICAgICAgLypcbiAgICAgIFdoeSBtaWdodCBiZSBmaW5kIG91cnNlbHZlcyBoZXJlPyAgQW4gcG90ZW50aWFsIGVuZCBtYXRjaCB0aGF0IHdhc1xuICAgICAgdHJpZ2dlcmVkIGJ1dCBjb3VsZCBub3QgYmUgY29tcGxldGVkLiAgSUUsIGBkb0VuZE1hdGNoYCByZXR1cm5lZCBOT19NQVRDSC5cbiAgICAgICh0aGlzIGNvdWxkIGJlIGJlY2F1c2UgYSBjYWxsYmFjayByZXF1ZXN0cyB0aGUgbWF0Y2ggYmUgaWdub3JlZCwgZXRjKVxuXG4gICAgICBUaGlzIGNhdXNlcyBubyByZWFsIGhhcm0gb3RoZXIgdGhhbiBzdG9wcGluZyBhIGZldyB0aW1lcyB0b28gbWFueS5cbiAgICAgICovXG5cbiAgICAgIG1vZGVCdWZmZXIgKz0gbGV4ZW1lO1xuICAgICAgcmV0dXJuIGxleGVtZS5sZW5ndGg7XG4gICAgfVxuXG4gICAgY29uc3QgbGFuZ3VhZ2UgPSBnZXRMYW5ndWFnZShsYW5ndWFnZU5hbWUpO1xuICAgIGlmICghbGFuZ3VhZ2UpIHtcbiAgICAgIGVycm9yKExBTkdVQUdFX05PVF9GT1VORC5yZXBsYWNlKFwie31cIiwgbGFuZ3VhZ2VOYW1lKSk7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gbGFuZ3VhZ2U6IFwiJyArIGxhbmd1YWdlTmFtZSArICdcIicpO1xuICAgIH1cblxuICAgIGNvbnN0IG1kID0gY29tcGlsZUxhbmd1YWdlKGxhbmd1YWdlKTtcbiAgICBsZXQgcmVzdWx0ID0gJyc7XG4gICAgLyoqIEB0eXBlIHtDb21waWxlZE1vZGV9ICovXG4gICAgbGV0IHRvcCA9IGNvbnRpbnVhdGlvbiB8fCBtZDtcbiAgICAvKiogQHR5cGUgUmVjb3JkPHN0cmluZyxDb21waWxlZE1vZGU+ICovXG4gICAgY29uc3QgY29udGludWF0aW9ucyA9IHt9OyAvLyBrZWVwIGNvbnRpbnVhdGlvbnMgZm9yIHN1Yi1sYW5ndWFnZXNcbiAgICBjb25zdCBlbWl0dGVyID0gbmV3IG9wdGlvbnMuX19lbWl0dGVyKG9wdGlvbnMpO1xuICAgIHByb2Nlc3NDb250aW51YXRpb25zKCk7XG4gICAgbGV0IG1vZGVCdWZmZXIgPSAnJztcbiAgICBsZXQgcmVsZXZhbmNlID0gMDtcbiAgICBsZXQgaW5kZXggPSAwO1xuICAgIGxldCBpdGVyYXRpb25zID0gMDtcbiAgICBsZXQgcmVzdW1lU2NhbkF0U2FtZVBvc2l0aW9uID0gZmFsc2U7XG5cbiAgICB0cnkge1xuICAgICAgdG9wLm1hdGNoZXIuY29uc2lkZXJBbGwoKTtcblxuICAgICAgZm9yICg7Oykge1xuICAgICAgICBpdGVyYXRpb25zKys7XG4gICAgICAgIGlmIChyZXN1bWVTY2FuQXRTYW1lUG9zaXRpb24pIHtcbiAgICAgICAgICAvLyBvbmx5IHJlZ2V4ZXMgbm90IG1hdGNoZWQgcHJldmlvdXNseSB3aWxsIG5vdyBiZVxuICAgICAgICAgIC8vIGNvbnNpZGVyZWQgZm9yIGEgcG90ZW50aWFsIG1hdGNoXG4gICAgICAgICAgcmVzdW1lU2NhbkF0U2FtZVBvc2l0aW9uID0gZmFsc2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdG9wLm1hdGNoZXIuY29uc2lkZXJBbGwoKTtcbiAgICAgICAgfVxuICAgICAgICB0b3AubWF0Y2hlci5sYXN0SW5kZXggPSBpbmRleDtcblxuICAgICAgICBjb25zdCBtYXRjaCA9IHRvcC5tYXRjaGVyLmV4ZWMoY29kZVRvSGlnaGxpZ2h0KTtcbiAgICAgICAgLy8gY29uc29sZS5sb2coXCJtYXRjaFwiLCBtYXRjaFswXSwgbWF0Y2gucnVsZSAmJiBtYXRjaC5ydWxlLmJlZ2luKVxuXG4gICAgICAgIGlmICghbWF0Y2gpIGJyZWFrO1xuXG4gICAgICAgIGNvbnN0IGJlZm9yZU1hdGNoID0gY29kZVRvSGlnaGxpZ2h0LnN1YnN0cmluZyhpbmRleCwgbWF0Y2guaW5kZXgpO1xuICAgICAgICBjb25zdCBwcm9jZXNzZWRDb3VudCA9IHByb2Nlc3NMZXhlbWUoYmVmb3JlTWF0Y2gsIG1hdGNoKTtcbiAgICAgICAgaW5kZXggPSBtYXRjaC5pbmRleCArIHByb2Nlc3NlZENvdW50O1xuICAgICAgfVxuICAgICAgcHJvY2Vzc0xleGVtZShjb2RlVG9IaWdobGlnaHQuc3Vic3RyKGluZGV4KSk7XG4gICAgICBlbWl0dGVyLmNsb3NlQWxsTm9kZXMoKTtcbiAgICAgIGVtaXR0ZXIuZmluYWxpemUoKTtcbiAgICAgIHJlc3VsdCA9IGVtaXR0ZXIudG9IVE1MKCk7XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGxhbmd1YWdlOiBsYW5ndWFnZU5hbWUsXG4gICAgICAgIHZhbHVlOiByZXN1bHQsXG4gICAgICAgIHJlbGV2YW5jZTogcmVsZXZhbmNlLFxuICAgICAgICBpbGxlZ2FsOiBmYWxzZSxcbiAgICAgICAgX2VtaXR0ZXI6IGVtaXR0ZXIsXG4gICAgICAgIF90b3A6IHRvcFxuICAgICAgfTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGlmIChlcnIubWVzc2FnZSAmJiBlcnIubWVzc2FnZS5pbmNsdWRlcygnSWxsZWdhbCcpKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbGFuZ3VhZ2U6IGxhbmd1YWdlTmFtZSxcbiAgICAgICAgICB2YWx1ZTogZXNjYXBlKGNvZGVUb0hpZ2hsaWdodCksXG4gICAgICAgICAgaWxsZWdhbDogdHJ1ZSxcbiAgICAgICAgICByZWxldmFuY2U6IDAsXG4gICAgICAgICAgX2lsbGVnYWxCeToge1xuICAgICAgICAgICAgbWVzc2FnZTogZXJyLm1lc3NhZ2UsXG4gICAgICAgICAgICBpbmRleDogaW5kZXgsXG4gICAgICAgICAgICBjb250ZXh0OiBjb2RlVG9IaWdobGlnaHQuc2xpY2UoaW5kZXggLSAxMDAsIGluZGV4ICsgMTAwKSxcbiAgICAgICAgICAgIG1vZGU6IGVyci5tb2RlLFxuICAgICAgICAgICAgcmVzdWx0U29GYXI6IHJlc3VsdFxuICAgICAgICAgIH0sXG4gICAgICAgICAgX2VtaXR0ZXI6IGVtaXR0ZXJcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSBpZiAoU0FGRV9NT0RFKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbGFuZ3VhZ2U6IGxhbmd1YWdlTmFtZSxcbiAgICAgICAgICB2YWx1ZTogZXNjYXBlKGNvZGVUb0hpZ2hsaWdodCksXG4gICAgICAgICAgaWxsZWdhbDogZmFsc2UsXG4gICAgICAgICAgcmVsZXZhbmNlOiAwLFxuICAgICAgICAgIGVycm9yUmFpc2VkOiBlcnIsXG4gICAgICAgICAgX2VtaXR0ZXI6IGVtaXR0ZXIsXG4gICAgICAgICAgX3RvcDogdG9wXG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBlcnI7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIHJldHVybnMgYSB2YWxpZCBoaWdobGlnaHQgcmVzdWx0LCB3aXRob3V0IGFjdHVhbGx5IGRvaW5nIGFueSBhY3R1YWwgd29yayxcbiAgICogYXV0byBoaWdobGlnaHQgc3RhcnRzIHdpdGggdGhpcyBhbmQgaXQncyBwb3NzaWJsZSBmb3Igc21hbGwgc25pcHBldHMgdGhhdFxuICAgKiBhdXRvLWRldGVjdGlvbiBtYXkgbm90IGZpbmQgYSBiZXR0ZXIgbWF0Y2hcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNvZGVcbiAgICogQHJldHVybnMge0hpZ2hsaWdodFJlc3VsdH1cbiAgICovXG4gIGZ1bmN0aW9uIGp1c3RUZXh0SGlnaGxpZ2h0UmVzdWx0KGNvZGUpIHtcbiAgICBjb25zdCByZXN1bHQgPSB7XG4gICAgICB2YWx1ZTogZXNjYXBlKGNvZGUpLFxuICAgICAgaWxsZWdhbDogZmFsc2UsXG4gICAgICByZWxldmFuY2U6IDAsXG4gICAgICBfdG9wOiBQTEFJTlRFWFRfTEFOR1VBR0UsXG4gICAgICBfZW1pdHRlcjogbmV3IG9wdGlvbnMuX19lbWl0dGVyKG9wdGlvbnMpXG4gICAgfTtcbiAgICByZXN1bHQuX2VtaXR0ZXIuYWRkVGV4dChjb2RlKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gIEhpZ2hsaWdodGluZyB3aXRoIGxhbmd1YWdlIGRldGVjdGlvbi4gQWNjZXB0cyBhIHN0cmluZyB3aXRoIHRoZSBjb2RlIHRvXG4gIGhpZ2hsaWdodC4gUmV0dXJucyBhbiBvYmplY3Qgd2l0aCB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG5cbiAgLSBsYW5ndWFnZSAoZGV0ZWN0ZWQgbGFuZ3VhZ2UpXG4gIC0gcmVsZXZhbmNlIChpbnQpXG4gIC0gdmFsdWUgKGFuIEhUTUwgc3RyaW5nIHdpdGggaGlnaGxpZ2h0aW5nIG1hcmt1cClcbiAgLSBzZWNvbmRCZXN0IChvYmplY3Qgd2l0aCB0aGUgc2FtZSBzdHJ1Y3R1cmUgZm9yIHNlY29uZC1iZXN0IGhldXJpc3RpY2FsbHlcbiAgICBkZXRlY3RlZCBsYW5ndWFnZSwgbWF5IGJlIGFic2VudClcblxuICAgIEBwYXJhbSB7c3RyaW5nfSBjb2RlXG4gICAgQHBhcmFtIHtBcnJheTxzdHJpbmc+fSBbbGFuZ3VhZ2VTdWJzZXRdXG4gICAgQHJldHVybnMge0F1dG9IaWdobGlnaHRSZXN1bHR9XG4gICovXG4gIGZ1bmN0aW9uIGhpZ2hsaWdodEF1dG8oY29kZSwgbGFuZ3VhZ2VTdWJzZXQpIHtcbiAgICBsYW5ndWFnZVN1YnNldCA9IGxhbmd1YWdlU3Vic2V0IHx8IG9wdGlvbnMubGFuZ3VhZ2VzIHx8IE9iamVjdC5rZXlzKGxhbmd1YWdlcyk7XG4gICAgY29uc3QgcGxhaW50ZXh0ID0ganVzdFRleHRIaWdobGlnaHRSZXN1bHQoY29kZSk7XG5cbiAgICBjb25zdCByZXN1bHRzID0gbGFuZ3VhZ2VTdWJzZXQuZmlsdGVyKGdldExhbmd1YWdlKS5maWx0ZXIoYXV0b0RldGVjdGlvbikubWFwKG5hbWUgPT5cbiAgICAgIF9oaWdobGlnaHQobmFtZSwgY29kZSwgZmFsc2UpXG4gICAgKTtcbiAgICByZXN1bHRzLnVuc2hpZnQocGxhaW50ZXh0KTsgLy8gcGxhaW50ZXh0IGlzIGFsd2F5cyBhbiBvcHRpb25cblxuICAgIGNvbnN0IHNvcnRlZCA9IHJlc3VsdHMuc29ydCgoYSwgYikgPT4ge1xuICAgICAgLy8gc29ydCBiYXNlIG9uIHJlbGV2YW5jZVxuICAgICAgaWYgKGEucmVsZXZhbmNlICE9PSBiLnJlbGV2YW5jZSkgcmV0dXJuIGIucmVsZXZhbmNlIC0gYS5yZWxldmFuY2U7XG5cbiAgICAgIC8vIGFsd2F5cyBhd2FyZCB0aGUgdGllIHRvIHRoZSBiYXNlIGxhbmd1YWdlXG4gICAgICAvLyBpZSBpZiBDKysgYW5kIEFyZHVpbm8gYXJlIHRpZWQsIGl0J3MgbW9yZSBsaWtlbHkgdG8gYmUgQysrXG4gICAgICBpZiAoYS5sYW5ndWFnZSAmJiBiLmxhbmd1YWdlKSB7XG4gICAgICAgIGlmIChnZXRMYW5ndWFnZShhLmxhbmd1YWdlKS5zdXBlcnNldE9mID09PSBiLmxhbmd1YWdlKSB7XG4gICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH0gZWxzZSBpZiAoZ2V0TGFuZ3VhZ2UoYi5sYW5ndWFnZSkuc3VwZXJzZXRPZiA9PT0gYS5sYW5ndWFnZSkge1xuICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBvdGhlcndpc2Ugc2F5IHRoZXkgYXJlIGVxdWFsLCB3aGljaCBoYXMgdGhlIGVmZmVjdCBvZiBzb3J0aW5nIG9uXG4gICAgICAvLyByZWxldmFuY2Ugd2hpbGUgcHJlc2VydmluZyB0aGUgb3JpZ2luYWwgb3JkZXJpbmcgLSB3aGljaCBpcyBob3cgdGllc1xuICAgICAgLy8gaGF2ZSBoaXN0b3JpY2FsbHkgYmVlbiBzZXR0bGVkLCBpZSB0aGUgbGFuZ3VhZ2UgdGhhdCBjb21lcyBmaXJzdCBhbHdheXNcbiAgICAgIC8vIHdpbnMgaW4gdGhlIGNhc2Ugb2YgYSB0aWVcbiAgICAgIHJldHVybiAwO1xuICAgIH0pO1xuXG4gICAgY29uc3QgW2Jlc3QsIHNlY29uZEJlc3RdID0gc29ydGVkO1xuXG4gICAgLyoqIEB0eXBlIHtBdXRvSGlnaGxpZ2h0UmVzdWx0fSAqL1xuICAgIGNvbnN0IHJlc3VsdCA9IGJlc3Q7XG4gICAgcmVzdWx0LnNlY29uZEJlc3QgPSBzZWNvbmRCZXN0O1xuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBCdWlsZHMgbmV3IGNsYXNzIG5hbWUgZm9yIGJsb2NrIGdpdmVuIHRoZSBsYW5ndWFnZSBuYW1lXG4gICAqXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnRcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtjdXJyZW50TGFuZ11cbiAgICogQHBhcmFtIHtzdHJpbmd9IFtyZXN1bHRMYW5nXVxuICAgKi9cbiAgZnVuY3Rpb24gdXBkYXRlQ2xhc3NOYW1lKGVsZW1lbnQsIGN1cnJlbnRMYW5nLCByZXN1bHRMYW5nKSB7XG4gICAgY29uc3QgbGFuZ3VhZ2UgPSAoY3VycmVudExhbmcgJiYgYWxpYXNlc1tjdXJyZW50TGFuZ10pIHx8IHJlc3VsdExhbmc7XG5cbiAgICBlbGVtZW50LmNsYXNzTGlzdC5hZGQoXCJobGpzXCIpO1xuICAgIGVsZW1lbnQuY2xhc3NMaXN0LmFkZChgbGFuZ3VhZ2UtJHtsYW5ndWFnZX1gKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBcHBsaWVzIGhpZ2hsaWdodGluZyB0byBhIERPTSBub2RlIGNvbnRhaW5pbmcgY29kZS5cbiAgICpcbiAgICogQHBhcmFtIHtIaWdobGlnaHRlZEhUTUxFbGVtZW50fSBlbGVtZW50IC0gdGhlIEhUTUwgZWxlbWVudCB0byBoaWdobGlnaHRcbiAgKi9cbiAgZnVuY3Rpb24gaGlnaGxpZ2h0RWxlbWVudChlbGVtZW50KSB7XG4gICAgLyoqIEB0eXBlIEhUTUxFbGVtZW50ICovXG4gICAgbGV0IG5vZGUgPSBudWxsO1xuICAgIGNvbnN0IGxhbmd1YWdlID0gYmxvY2tMYW5ndWFnZShlbGVtZW50KTtcblxuICAgIGlmIChzaG91bGROb3RIaWdobGlnaHQobGFuZ3VhZ2UpKSByZXR1cm47XG5cbiAgICBmaXJlKFwiYmVmb3JlOmhpZ2hsaWdodEVsZW1lbnRcIixcbiAgICAgIHsgZWw6IGVsZW1lbnQsIGxhbmd1YWdlOiBsYW5ndWFnZSB9KTtcblxuICAgIC8vIHdlIHNob3VsZCBiZSBhbGwgdGV4dCwgbm8gY2hpbGQgbm9kZXNcbiAgICBpZiAoIW9wdGlvbnMuaWdub3JlVW5lc2NhcGVkSFRNTCAmJiBlbGVtZW50LmNoaWxkcmVuLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnNvbGUud2FybihcIk9uZSBvZiB5b3VyIGNvZGUgYmxvY2tzIGluY2x1ZGVzIHVuZXNjYXBlZCBIVE1MLiBUaGlzIGlzIGEgcG90ZW50aWFsbHkgc2VyaW91cyBzZWN1cml0eSByaXNrLlwiKTtcbiAgICAgIGNvbnNvbGUud2FybihcImh0dHBzOi8vZ2l0aHViLmNvbS9oaWdobGlnaHRqcy9oaWdobGlnaHQuanMvaXNzdWVzLzI4ODZcIik7XG4gICAgICBjb25zb2xlLndhcm4oZWxlbWVudCk7XG4gICAgfVxuXG4gICAgbm9kZSA9IGVsZW1lbnQ7XG4gICAgY29uc3QgdGV4dCA9IG5vZGUudGV4dENvbnRlbnQ7XG4gICAgY29uc3QgcmVzdWx0ID0gbGFuZ3VhZ2UgPyBoaWdobGlnaHQodGV4dCwgeyBsYW5ndWFnZSwgaWdub3JlSWxsZWdhbHM6IHRydWUgfSkgOiBoaWdobGlnaHRBdXRvKHRleHQpO1xuXG4gICAgZWxlbWVudC5pbm5lckhUTUwgPSByZXN1bHQudmFsdWU7XG4gICAgdXBkYXRlQ2xhc3NOYW1lKGVsZW1lbnQsIGxhbmd1YWdlLCByZXN1bHQubGFuZ3VhZ2UpO1xuICAgIGVsZW1lbnQucmVzdWx0ID0ge1xuICAgICAgbGFuZ3VhZ2U6IHJlc3VsdC5sYW5ndWFnZSxcbiAgICAgIC8vIFRPRE86IHJlbW92ZSB3aXRoIHZlcnNpb24gMTEuMFxuICAgICAgcmU6IHJlc3VsdC5yZWxldmFuY2UsXG4gICAgICByZWxldmFuY2U6IHJlc3VsdC5yZWxldmFuY2VcbiAgICB9O1xuICAgIGlmIChyZXN1bHQuc2Vjb25kQmVzdCkge1xuICAgICAgZWxlbWVudC5zZWNvbmRCZXN0ID0ge1xuICAgICAgICBsYW5ndWFnZTogcmVzdWx0LnNlY29uZEJlc3QubGFuZ3VhZ2UsXG4gICAgICAgIHJlbGV2YW5jZTogcmVzdWx0LnNlY29uZEJlc3QucmVsZXZhbmNlXG4gICAgICB9O1xuICAgIH1cblxuICAgIGZpcmUoXCJhZnRlcjpoaWdobGlnaHRFbGVtZW50XCIsIHsgZWw6IGVsZW1lbnQsIHJlc3VsdCwgdGV4dCB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGVzIGhpZ2hsaWdodC5qcyBnbG9iYWwgb3B0aW9ucyB3aXRoIHRoZSBwYXNzZWQgb3B0aW9uc1xuICAgKlxuICAgKiBAcGFyYW0ge1BhcnRpYWw8SExKU09wdGlvbnM+fSB1c2VyT3B0aW9uc1xuICAgKi9cbiAgZnVuY3Rpb24gY29uZmlndXJlKHVzZXJPcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IGluaGVyaXQob3B0aW9ucywgdXNlck9wdGlvbnMpO1xuICB9XG5cbiAgLy8gVE9ETzogcmVtb3ZlIHYxMiwgZGVwcmVjYXRlZFxuICBjb25zdCBpbml0SGlnaGxpZ2h0aW5nID0gKCkgPT4ge1xuICAgIGhpZ2hsaWdodEFsbCgpO1xuICAgIGRlcHJlY2F0ZWQoXCIxMC42LjBcIiwgXCJpbml0SGlnaGxpZ2h0aW5nKCkgZGVwcmVjYXRlZC4gIFVzZSBoaWdobGlnaHRBbGwoKSBub3cuXCIpO1xuICB9O1xuXG4gIC8vIFRPRE86IHJlbW92ZSB2MTIsIGRlcHJlY2F0ZWRcbiAgZnVuY3Rpb24gaW5pdEhpZ2hsaWdodGluZ09uTG9hZCgpIHtcbiAgICBoaWdobGlnaHRBbGwoKTtcbiAgICBkZXByZWNhdGVkKFwiMTAuNi4wXCIsIFwiaW5pdEhpZ2hsaWdodGluZ09uTG9hZCgpIGRlcHJlY2F0ZWQuICBVc2UgaGlnaGxpZ2h0QWxsKCkgbm93LlwiKTtcbiAgfVxuXG4gIGxldCB3YW50c0hpZ2hsaWdodCA9IGZhbHNlO1xuXG4gIC8qKlxuICAgKiBhdXRvLWhpZ2hsaWdodHMgYWxsIHByZT5jb2RlIGVsZW1lbnRzIG9uIHRoZSBwYWdlXG4gICAqL1xuICBmdW5jdGlvbiBoaWdobGlnaHRBbGwoKSB7XG4gICAgLy8gaWYgd2UgYXJlIGNhbGxlZCB0b28gZWFybHkgaW4gdGhlIGxvYWRpbmcgcHJvY2Vzc1xuICAgIGlmIChkb2N1bWVudC5yZWFkeVN0YXRlID09PSBcImxvYWRpbmdcIikge1xuICAgICAgd2FudHNIaWdobGlnaHQgPSB0cnVlO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGJsb2NrcyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwob3B0aW9ucy5jc3NTZWxlY3Rvcik7XG4gICAgYmxvY2tzLmZvckVhY2goaGlnaGxpZ2h0RWxlbWVudCk7XG4gIH1cblxuICBmdW5jdGlvbiBib290KCkge1xuICAgIC8vIGlmIGEgaGlnaGxpZ2h0IHdhcyByZXF1ZXN0ZWQgYmVmb3JlIERPTSB3YXMgbG9hZGVkLCBkbyBub3dcbiAgICBpZiAod2FudHNIaWdobGlnaHQpIGhpZ2hsaWdodEFsbCgpO1xuICB9XG5cbiAgLy8gbWFrZSBzdXJlIHdlIGFyZSBpbiB0aGUgYnJvd3NlciBlbnZpcm9ubWVudFxuICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignRE9NQ29udGVudExvYWRlZCcsIGJvb3QsIGZhbHNlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWdpc3RlciBhIGxhbmd1YWdlIGdyYW1tYXIgbW9kdWxlXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBsYW5ndWFnZU5hbWVcbiAgICogQHBhcmFtIHtMYW5ndWFnZUZufSBsYW5ndWFnZURlZmluaXRpb25cbiAgICovXG4gIGZ1bmN0aW9uIHJlZ2lzdGVyTGFuZ3VhZ2UobGFuZ3VhZ2VOYW1lLCBsYW5ndWFnZURlZmluaXRpb24pIHtcbiAgICBsZXQgbGFuZyA9IG51bGw7XG4gICAgdHJ5IHtcbiAgICAgIGxhbmcgPSBsYW5ndWFnZURlZmluaXRpb24oaGxqcyk7XG4gICAgfSBjYXRjaCAoZXJyb3IkMSkge1xuICAgICAgZXJyb3IoXCJMYW5ndWFnZSBkZWZpbml0aW9uIGZvciAne30nIGNvdWxkIG5vdCBiZSByZWdpc3RlcmVkLlwiLnJlcGxhY2UoXCJ7fVwiLCBsYW5ndWFnZU5hbWUpKTtcbiAgICAgIC8vIGhhcmQgb3Igc29mdCBlcnJvclxuICAgICAgaWYgKCFTQUZFX01PREUpIHsgdGhyb3cgZXJyb3IkMTsgfSBlbHNlIHsgZXJyb3IoZXJyb3IkMSk7IH1cbiAgICAgIC8vIGxhbmd1YWdlcyB0aGF0IGhhdmUgc2VyaW91cyBlcnJvcnMgYXJlIHJlcGxhY2VkIHdpdGggZXNzZW50aWFsbHkgYVxuICAgICAgLy8gXCJwbGFpbnRleHRcIiBzdGFuZC1pbiBzbyB0aGF0IHRoZSBjb2RlIGJsb2NrcyB3aWxsIHN0aWxsIGdldCBub3JtYWxcbiAgICAgIC8vIGNzcyBjbGFzc2VzIGFwcGxpZWQgdG8gdGhlbSAtIGFuZCBvbmUgYmFkIGxhbmd1YWdlIHdvbid0IGJyZWFrIHRoZVxuICAgICAgLy8gZW50aXJlIGhpZ2hsaWdodGVyXG4gICAgICBsYW5nID0gUExBSU5URVhUX0xBTkdVQUdFO1xuICAgIH1cbiAgICAvLyBnaXZlIGl0IGEgdGVtcG9yYXJ5IG5hbWUgaWYgaXQgZG9lc24ndCBoYXZlIG9uZSBpbiB0aGUgbWV0YS1kYXRhXG4gICAgaWYgKCFsYW5nLm5hbWUpIGxhbmcubmFtZSA9IGxhbmd1YWdlTmFtZTtcbiAgICBsYW5ndWFnZXNbbGFuZ3VhZ2VOYW1lXSA9IGxhbmc7XG4gICAgbGFuZy5yYXdEZWZpbml0aW9uID0gbGFuZ3VhZ2VEZWZpbml0aW9uLmJpbmQobnVsbCwgaGxqcyk7XG5cbiAgICBpZiAobGFuZy5hbGlhc2VzKSB7XG4gICAgICByZWdpc3RlckFsaWFzZXMobGFuZy5hbGlhc2VzLCB7IGxhbmd1YWdlTmFtZSB9KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlIGEgbGFuZ3VhZ2UgZ3JhbW1hciBtb2R1bGVcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGxhbmd1YWdlTmFtZVxuICAgKi9cbiAgZnVuY3Rpb24gdW5yZWdpc3Rlckxhbmd1YWdlKGxhbmd1YWdlTmFtZSkge1xuICAgIGRlbGV0ZSBsYW5ndWFnZXNbbGFuZ3VhZ2VOYW1lXTtcbiAgICBmb3IgKGNvbnN0IGFsaWFzIG9mIE9iamVjdC5rZXlzKGFsaWFzZXMpKSB7XG4gICAgICBpZiAoYWxpYXNlc1thbGlhc10gPT09IGxhbmd1YWdlTmFtZSkge1xuICAgICAgICBkZWxldGUgYWxpYXNlc1thbGlhc107XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm5zIHtzdHJpbmdbXX0gTGlzdCBvZiBsYW5ndWFnZSBpbnRlcm5hbCBuYW1lc1xuICAgKi9cbiAgZnVuY3Rpb24gbGlzdExhbmd1YWdlcygpIHtcbiAgICByZXR1cm4gT2JqZWN0LmtleXMobGFuZ3VhZ2VzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSAtIG5hbWUgb2YgdGhlIGxhbmd1YWdlIHRvIHJldHJpZXZlXG4gICAqIEByZXR1cm5zIHtMYW5ndWFnZSB8IHVuZGVmaW5lZH1cbiAgICovXG4gIGZ1bmN0aW9uIGdldExhbmd1YWdlKG5hbWUpIHtcbiAgICBuYW1lID0gKG5hbWUgfHwgJycpLnRvTG93ZXJDYXNlKCk7XG4gICAgcmV0dXJuIGxhbmd1YWdlc1tuYW1lXSB8fCBsYW5ndWFnZXNbYWxpYXNlc1tuYW1lXV07XG4gIH1cblxuICAvKipcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd8c3RyaW5nW119IGFsaWFzTGlzdCAtIHNpbmdsZSBhbGlhcyBvciBsaXN0IG9mIGFsaWFzZXNcbiAgICogQHBhcmFtIHt7bGFuZ3VhZ2VOYW1lOiBzdHJpbmd9fSBvcHRzXG4gICAqL1xuICBmdW5jdGlvbiByZWdpc3RlckFsaWFzZXMoYWxpYXNMaXN0LCB7IGxhbmd1YWdlTmFtZSB9KSB7XG4gICAgaWYgKHR5cGVvZiBhbGlhc0xpc3QgPT09ICdzdHJpbmcnKSB7XG4gICAgICBhbGlhc0xpc3QgPSBbYWxpYXNMaXN0XTtcbiAgICB9XG4gICAgYWxpYXNMaXN0LmZvckVhY2goYWxpYXMgPT4geyBhbGlhc2VzW2FsaWFzLnRvTG93ZXJDYXNlKCldID0gbGFuZ3VhZ2VOYW1lOyB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXRlcm1pbmVzIGlmIGEgZ2l2ZW4gbGFuZ3VhZ2UgaGFzIGF1dG8tZGV0ZWN0aW9uIGVuYWJsZWRcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgLSBuYW1lIG9mIHRoZSBsYW5ndWFnZVxuICAgKi9cbiAgZnVuY3Rpb24gYXV0b0RldGVjdGlvbihuYW1lKSB7XG4gICAgY29uc3QgbGFuZyA9IGdldExhbmd1YWdlKG5hbWUpO1xuICAgIHJldHVybiBsYW5nICYmICFsYW5nLmRpc2FibGVBdXRvZGV0ZWN0O1xuICB9XG5cbiAgLyoqXG4gICAqIFVwZ3JhZGVzIHRoZSBvbGQgaGlnaGxpZ2h0QmxvY2sgcGx1Z2lucyB0byB0aGUgbmV3XG4gICAqIGhpZ2hsaWdodEVsZW1lbnQgQVBJXG4gICAqIEBwYXJhbSB7SExKU1BsdWdpbn0gcGx1Z2luXG4gICAqL1xuICBmdW5jdGlvbiB1cGdyYWRlUGx1Z2luQVBJKHBsdWdpbikge1xuICAgIC8vIFRPRE86IHJlbW92ZSB3aXRoIHYxMlxuICAgIGlmIChwbHVnaW5bXCJiZWZvcmU6aGlnaGxpZ2h0QmxvY2tcIl0gJiYgIXBsdWdpbltcImJlZm9yZTpoaWdobGlnaHRFbGVtZW50XCJdKSB7XG4gICAgICBwbHVnaW5bXCJiZWZvcmU6aGlnaGxpZ2h0RWxlbWVudFwiXSA9IChkYXRhKSA9PiB7XG4gICAgICAgIHBsdWdpbltcImJlZm9yZTpoaWdobGlnaHRCbG9ja1wiXShcbiAgICAgICAgICBPYmplY3QuYXNzaWduKHsgYmxvY2s6IGRhdGEuZWwgfSwgZGF0YSlcbiAgICAgICAgKTtcbiAgICAgIH07XG4gICAgfVxuICAgIGlmIChwbHVnaW5bXCJhZnRlcjpoaWdobGlnaHRCbG9ja1wiXSAmJiAhcGx1Z2luW1wiYWZ0ZXI6aGlnaGxpZ2h0RWxlbWVudFwiXSkge1xuICAgICAgcGx1Z2luW1wiYWZ0ZXI6aGlnaGxpZ2h0RWxlbWVudFwiXSA9IChkYXRhKSA9PiB7XG4gICAgICAgIHBsdWdpbltcImFmdGVyOmhpZ2hsaWdodEJsb2NrXCJdKFxuICAgICAgICAgIE9iamVjdC5hc3NpZ24oeyBibG9jazogZGF0YS5lbCB9LCBkYXRhKVxuICAgICAgICApO1xuICAgICAgfTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtITEpTUGx1Z2lufSBwbHVnaW5cbiAgICovXG4gIGZ1bmN0aW9uIGFkZFBsdWdpbihwbHVnaW4pIHtcbiAgICB1cGdyYWRlUGx1Z2luQVBJKHBsdWdpbik7XG4gICAgcGx1Z2lucy5wdXNoKHBsdWdpbik7XG4gIH1cblxuICAvKipcbiAgICpcbiAgICogQHBhcmFtIHtQbHVnaW5FdmVudH0gZXZlbnRcbiAgICogQHBhcmFtIHthbnl9IGFyZ3NcbiAgICovXG4gIGZ1bmN0aW9uIGZpcmUoZXZlbnQsIGFyZ3MpIHtcbiAgICBjb25zdCBjYiA9IGV2ZW50O1xuICAgIHBsdWdpbnMuZm9yRWFjaChmdW5jdGlvbihwbHVnaW4pIHtcbiAgICAgIGlmIChwbHVnaW5bY2JdKSB7XG4gICAgICAgIHBsdWdpbltjYl0oYXJncyk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogREVQUkVDQVRFRFxuICAgKiBAcGFyYW0ge0hpZ2hsaWdodGVkSFRNTEVsZW1lbnR9IGVsXG4gICAqL1xuICBmdW5jdGlvbiBkZXByZWNhdGVIaWdobGlnaHRCbG9jayhlbCkge1xuICAgIGRlcHJlY2F0ZWQoXCIxMC43LjBcIiwgXCJoaWdobGlnaHRCbG9jayB3aWxsIGJlIHJlbW92ZWQgZW50aXJlbHkgaW4gdjEyLjBcIik7XG4gICAgZGVwcmVjYXRlZChcIjEwLjcuMFwiLCBcIlBsZWFzZSB1c2UgaGlnaGxpZ2h0RWxlbWVudCBub3cuXCIpO1xuXG4gICAgcmV0dXJuIGhpZ2hsaWdodEVsZW1lbnQoZWwpO1xuICB9XG5cbiAgLyogSW50ZXJmYWNlIGRlZmluaXRpb24gKi9cbiAgT2JqZWN0LmFzc2lnbihobGpzLCB7XG4gICAgaGlnaGxpZ2h0LFxuICAgIGhpZ2hsaWdodEF1dG8sXG4gICAgaGlnaGxpZ2h0QWxsLFxuICAgIGhpZ2hsaWdodEVsZW1lbnQsXG4gICAgLy8gVE9ETzogUmVtb3ZlIHdpdGggdjEyIEFQSVxuICAgIGhpZ2hsaWdodEJsb2NrOiBkZXByZWNhdGVIaWdobGlnaHRCbG9jayxcbiAgICBjb25maWd1cmUsXG4gICAgaW5pdEhpZ2hsaWdodGluZyxcbiAgICBpbml0SGlnaGxpZ2h0aW5nT25Mb2FkLFxuICAgIHJlZ2lzdGVyTGFuZ3VhZ2UsXG4gICAgdW5yZWdpc3Rlckxhbmd1YWdlLFxuICAgIGxpc3RMYW5ndWFnZXMsXG4gICAgZ2V0TGFuZ3VhZ2UsXG4gICAgcmVnaXN0ZXJBbGlhc2VzLFxuICAgIGF1dG9EZXRlY3Rpb24sXG4gICAgaW5oZXJpdCxcbiAgICBhZGRQbHVnaW5cbiAgfSk7XG5cbiAgaGxqcy5kZWJ1Z01vZGUgPSBmdW5jdGlvbigpIHsgU0FGRV9NT0RFID0gZmFsc2U7IH07XG4gIGhsanMuc2FmZU1vZGUgPSBmdW5jdGlvbigpIHsgU0FGRV9NT0RFID0gdHJ1ZTsgfTtcbiAgaGxqcy52ZXJzaW9uU3RyaW5nID0gdmVyc2lvbjtcblxuICBmb3IgKGNvbnN0IGtleSBpbiBNT0RFUykge1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBpZiAodHlwZW9mIE1PREVTW2tleV0gPT09IFwib2JqZWN0XCIpIHtcbiAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgIGRlZXBGcmVlemUkMShNT0RFU1trZXldKTtcbiAgICB9XG4gIH1cblxuICAvLyBtZXJnZSBhbGwgdGhlIG1vZGVzL3JlZ2V4ZXMgaW50byBvdXIgbWFpbiBvYmplY3RcbiAgT2JqZWN0LmFzc2lnbihobGpzLCBNT0RFUyk7XG5cbiAgcmV0dXJuIGhsanM7XG59O1xuXG4vLyBleHBvcnQgYW4gXCJpbnN0YW5jZVwiIG9mIHRoZSBoaWdobGlnaHRlclxudmFyIGhpZ2hsaWdodCA9IEhMSlMoe30pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGhpZ2hsaWdodDtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///390\n")}},__webpack_module_cache__={};function __webpack_require__(e){var n=__webpack_module_cache__[e];if(void 0!==n)return n.exports;var t=__webpack_module_cache__[e]={exports:{}};return __webpack_modules__[e].call(t.exports,t,t.exports,__webpack_require__),t.exports}__webpack_require__.n=e=>{var n=e&&e.__esModule?()=>e.default:()=>e;return __webpack_require__.d(n,{a:n}),n},__webpack_require__.d=(e,n)=>{for(var t in n)__webpack_require__.o(n,t)&&!__webpack_require__.o(e,t)&&Object.defineProperty(e,t,{enumerable:!0,get:n[t]})},__webpack_require__.g=function(){if("object"==typeof globalThis)return globalThis;try{return this||new Function("return this")()}catch(e){if("object"==typeof window)return window}}(),__webpack_require__.o=(e,n)=>Object.prototype.hasOwnProperty.call(e,n);var __webpack_exports__=__webpack_require__(937)})();