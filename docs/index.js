(()=>{var __webpack_modules__={929:(__unused_webpack_module,__unused_webpack___webpack_exports__,__webpack_require__)=>{"use strict";eval('\n;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}\n;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/inheritsLoose.js\n\nfunction _inheritsLoose(subClass, superClass) {\n  subClass.prototype = Object.create(superClass.prototype);\n  subClass.prototype.constructor = subClass;\n  _setPrototypeOf(subClass, superClass);\n}\n// EXTERNAL MODULE: ./node_modules/react/index.js\nvar react = __webpack_require__(294);\n// EXTERNAL MODULE: ./node_modules/prop-types/index.js\nvar prop_types = __webpack_require__(697);\nvar prop_types_default = /*#__PURE__*/__webpack_require__.n(prop_types);\n;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/extends.js\nfunction extends_extends() {\n  extends_extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return extends_extends.apply(this, arguments);\n}\n;// CONCATENATED MODULE: ./node_modules/resolve-pathname/esm/resolve-pathname.js\nfunction isAbsolute(pathname) {\n  return pathname.charAt(0) === \'/\';\n}\n\n// About 1.5x faster than the two-arg version of Array#splice()\nfunction spliceOne(list, index) {\n  for (var i = index, k = i + 1, n = list.length; k < n; i += 1, k += 1) {\n    list[i] = list[k];\n  }\n\n  list.pop();\n}\n\n// This implementation is based heavily on node\'s url.parse\nfunction resolvePathname(to, from) {\n  if (from === undefined) from = \'\';\n\n  var toParts = (to && to.split(\'/\')) || [];\n  var fromParts = (from && from.split(\'/\')) || [];\n\n  var isToAbs = to && isAbsolute(to);\n  var isFromAbs = from && isAbsolute(from);\n  var mustEndAbs = isToAbs || isFromAbs;\n\n  if (to && isAbsolute(to)) {\n    // to is absolute\n    fromParts = toParts;\n  } else if (toParts.length) {\n    // to is relative, drop the filename\n    fromParts.pop();\n    fromParts = fromParts.concat(toParts);\n  }\n\n  if (!fromParts.length) return \'/\';\n\n  var hasTrailingSlash;\n  if (fromParts.length) {\n    var last = fromParts[fromParts.length - 1];\n    hasTrailingSlash = last === \'.\' || last === \'..\' || last === \'\';\n  } else {\n    hasTrailingSlash = false;\n  }\n\n  var up = 0;\n  for (var i = fromParts.length; i >= 0; i--) {\n    var part = fromParts[i];\n\n    if (part === \'.\') {\n      spliceOne(fromParts, i);\n    } else if (part === \'..\') {\n      spliceOne(fromParts, i);\n      up++;\n    } else if (up) {\n      spliceOne(fromParts, i);\n      up--;\n    }\n  }\n\n  if (!mustEndAbs) for (; up--; up) fromParts.unshift(\'..\');\n\n  if (\n    mustEndAbs &&\n    fromParts[0] !== \'\' &&\n    (!fromParts[0] || !isAbsolute(fromParts[0]))\n  )\n    fromParts.unshift(\'\');\n\n  var result = fromParts.join(\'/\');\n\n  if (hasTrailingSlash && result.substr(-1) !== \'/\') result += \'/\';\n\n  return result;\n}\n\n/* harmony default export */ const resolve_pathname = (resolvePathname);\n\n;// CONCATENATED MODULE: ./node_modules/tiny-invariant/dist/tiny-invariant.esm.js\nvar isProduction = "production" === \'production\';\nvar prefix = \'Invariant failed\';\nfunction tiny_invariant_esm_invariant(condition, message) {\n    if (condition) {\n        return;\n    }\n    if (isProduction) {\n        throw new Error(prefix);\n    }\n    throw new Error(prefix + ": " + (message || \'\'));\n}\n\n/* harmony default export */ const tiny_invariant_esm = (tiny_invariant_esm_invariant);\n\n;// CONCATENATED MODULE: ./node_modules/history/esm/history.js\n\n\n\n\n\n\nfunction addLeadingSlash(path) {\n  return path.charAt(0) === \'/\' ? path : \'/\' + path;\n}\nfunction stripLeadingSlash(path) {\n  return path.charAt(0) === \'/\' ? path.substr(1) : path;\n}\nfunction hasBasename(path, prefix) {\n  return path.toLowerCase().indexOf(prefix.toLowerCase()) === 0 && \'/?#\'.indexOf(path.charAt(prefix.length)) !== -1;\n}\nfunction stripBasename(path, prefix) {\n  return hasBasename(path, prefix) ? path.substr(prefix.length) : path;\n}\nfunction stripTrailingSlash(path) {\n  return path.charAt(path.length - 1) === \'/\' ? path.slice(0, -1) : path;\n}\nfunction parsePath(path) {\n  var pathname = path || \'/\';\n  var search = \'\';\n  var hash = \'\';\n  var hashIndex = pathname.indexOf(\'#\');\n\n  if (hashIndex !== -1) {\n    hash = pathname.substr(hashIndex);\n    pathname = pathname.substr(0, hashIndex);\n  }\n\n  var searchIndex = pathname.indexOf(\'?\');\n\n  if (searchIndex !== -1) {\n    search = pathname.substr(searchIndex);\n    pathname = pathname.substr(0, searchIndex);\n  }\n\n  return {\n    pathname: pathname,\n    search: search === \'?\' ? \'\' : search,\n    hash: hash === \'#\' ? \'\' : hash\n  };\n}\nfunction createPath(location) {\n  var pathname = location.pathname,\n      search = location.search,\n      hash = location.hash;\n  var path = pathname || \'/\';\n  if (search && search !== \'?\') path += search.charAt(0) === \'?\' ? search : "?" + search;\n  if (hash && hash !== \'#\') path += hash.charAt(0) === \'#\' ? hash : "#" + hash;\n  return path;\n}\n\nfunction history_createLocation(path, state, key, currentLocation) {\n  var location;\n\n  if (typeof path === \'string\') {\n    // Two-arg form: push(path, state)\n    location = parsePath(path);\n    location.state = state;\n  } else {\n    // One-arg form: push(location)\n    location = extends_extends({}, path);\n    if (location.pathname === undefined) location.pathname = \'\';\n\n    if (location.search) {\n      if (location.search.charAt(0) !== \'?\') location.search = \'?\' + location.search;\n    } else {\n      location.search = \'\';\n    }\n\n    if (location.hash) {\n      if (location.hash.charAt(0) !== \'#\') location.hash = \'#\' + location.hash;\n    } else {\n      location.hash = \'\';\n    }\n\n    if (state !== undefined && location.state === undefined) location.state = state;\n  }\n\n  try {\n    location.pathname = decodeURI(location.pathname);\n  } catch (e) {\n    if (e instanceof URIError) {\n      throw new URIError(\'Pathname "\' + location.pathname + \'" could not be decoded. \' + \'This is likely caused by an invalid percent-encoding.\');\n    } else {\n      throw e;\n    }\n  }\n\n  if (key) location.key = key;\n\n  if (currentLocation) {\n    // Resolve incomplete/relative pathname relative to current location.\n    if (!location.pathname) {\n      location.pathname = currentLocation.pathname;\n    } else if (location.pathname.charAt(0) !== \'/\') {\n      location.pathname = resolve_pathname(location.pathname, currentLocation.pathname);\n    }\n  } else {\n    // When there is no prior location and pathname is empty, set it to /\n    if (!location.pathname) {\n      location.pathname = \'/\';\n    }\n  }\n\n  return location;\n}\nfunction history_locationsAreEqual(a, b) {\n  return a.pathname === b.pathname && a.search === b.search && a.hash === b.hash && a.key === b.key && valueEqual(a.state, b.state);\n}\n\nfunction createTransitionManager() {\n  var prompt = null;\n\n  function setPrompt(nextPrompt) {\n     false ? 0 : void 0;\n    prompt = nextPrompt;\n    return function () {\n      if (prompt === nextPrompt) prompt = null;\n    };\n  }\n\n  function confirmTransitionTo(location, action, getUserConfirmation, callback) {\n    // TODO: If another transition starts while we\'re still confirming\n    // the previous one, we may end up in a weird state. Figure out the\n    // best way to handle this.\n    if (prompt != null) {\n      var result = typeof prompt === \'function\' ? prompt(location, action) : prompt;\n\n      if (typeof result === \'string\') {\n        if (typeof getUserConfirmation === \'function\') {\n          getUserConfirmation(result, callback);\n        } else {\n           false ? 0 : void 0;\n          callback(true);\n        }\n      } else {\n        // Return false from a transition hook to cancel the transition.\n        callback(result !== false);\n      }\n    } else {\n      callback(true);\n    }\n  }\n\n  var listeners = [];\n\n  function appendListener(fn) {\n    var isActive = true;\n\n    function listener() {\n      if (isActive) fn.apply(void 0, arguments);\n    }\n\n    listeners.push(listener);\n    return function () {\n      isActive = false;\n      listeners = listeners.filter(function (item) {\n        return item !== listener;\n      });\n    };\n  }\n\n  function notifyListeners() {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    listeners.forEach(function (listener) {\n      return listener.apply(void 0, args);\n    });\n  }\n\n  return {\n    setPrompt: setPrompt,\n    confirmTransitionTo: confirmTransitionTo,\n    appendListener: appendListener,\n    notifyListeners: notifyListeners\n  };\n}\n\nvar canUseDOM = !!(typeof window !== \'undefined\' && window.document && window.document.createElement);\nfunction getConfirmation(message, callback) {\n  callback(window.confirm(message)); // eslint-disable-line no-alert\n}\n/**\n * Returns true if the HTML5 history API is supported. Taken from Modernizr.\n *\n * https://github.com/Modernizr/Modernizr/blob/master/LICENSE\n * https://github.com/Modernizr/Modernizr/blob/master/feature-detects/history.js\n * changed to avoid false negatives for Windows Phones: https://github.com/reactjs/react-router/issues/586\n */\n\nfunction supportsHistory() {\n  var ua = window.navigator.userAgent;\n  if ((ua.indexOf(\'Android 2.\') !== -1 || ua.indexOf(\'Android 4.0\') !== -1) && ua.indexOf(\'Mobile Safari\') !== -1 && ua.indexOf(\'Chrome\') === -1 && ua.indexOf(\'Windows Phone\') === -1) return false;\n  return window.history && \'pushState\' in window.history;\n}\n/**\n * Returns true if browser fires popstate on hash change.\n * IE10 and IE11 do not.\n */\n\nfunction supportsPopStateOnHashChange() {\n  return window.navigator.userAgent.indexOf(\'Trident\') === -1;\n}\n/**\n * Returns false if using go(n) with hash history causes a full page reload.\n */\n\nfunction supportsGoWithoutReloadUsingHash() {\n  return window.navigator.userAgent.indexOf(\'Firefox\') === -1;\n}\n/**\n * Returns true if a given popstate event is an extraneous WebKit event.\n * Accounts for the fact that Chrome on iOS fires real popstate events\n * containing undefined state when pressing the back button.\n */\n\nfunction isExtraneousPopstateEvent(event) {\n  return event.state === undefined && navigator.userAgent.indexOf(\'CriOS\') === -1;\n}\n\nvar PopStateEvent = \'popstate\';\nvar HashChangeEvent = \'hashchange\';\n\nfunction getHistoryState() {\n  try {\n    return window.history.state || {};\n  } catch (e) {\n    // IE 11 sometimes throws when accessing window.history.state\n    // See https://github.com/ReactTraining/history/pull/289\n    return {};\n  }\n}\n/**\n * Creates a history object that uses the HTML5 history API including\n * pushState, replaceState, and the popstate event.\n */\n\n\nfunction createBrowserHistory(props) {\n  if (props === void 0) {\n    props = {};\n  }\n\n  !canUseDOM ?  false ? 0 : tiny_invariant_esm(false) : void 0;\n  var globalHistory = window.history;\n  var canUseHistory = supportsHistory();\n  var needsHashChangeListener = !supportsPopStateOnHashChange();\n  var _props = props,\n      _props$forceRefresh = _props.forceRefresh,\n      forceRefresh = _props$forceRefresh === void 0 ? false : _props$forceRefresh,\n      _props$getUserConfirm = _props.getUserConfirmation,\n      getUserConfirmation = _props$getUserConfirm === void 0 ? getConfirmation : _props$getUserConfirm,\n      _props$keyLength = _props.keyLength,\n      keyLength = _props$keyLength === void 0 ? 6 : _props$keyLength;\n  var basename = props.basename ? stripTrailingSlash(addLeadingSlash(props.basename)) : \'\';\n\n  function getDOMLocation(historyState) {\n    var _ref = historyState || {},\n        key = _ref.key,\n        state = _ref.state;\n\n    var _window$location = window.location,\n        pathname = _window$location.pathname,\n        search = _window$location.search,\n        hash = _window$location.hash;\n    var path = pathname + search + hash;\n     false ? 0 : void 0;\n    if (basename) path = stripBasename(path, basename);\n    return history_createLocation(path, state, key);\n  }\n\n  function createKey() {\n    return Math.random().toString(36).substr(2, keyLength);\n  }\n\n  var transitionManager = createTransitionManager();\n\n  function setState(nextState) {\n    extends_extends(history, nextState);\n\n    history.length = globalHistory.length;\n    transitionManager.notifyListeners(history.location, history.action);\n  }\n\n  function handlePopState(event) {\n    // Ignore extraneous popstate events in WebKit.\n    if (isExtraneousPopstateEvent(event)) return;\n    handlePop(getDOMLocation(event.state));\n  }\n\n  function handleHashChange() {\n    handlePop(getDOMLocation(getHistoryState()));\n  }\n\n  var forceNextPop = false;\n\n  function handlePop(location) {\n    if (forceNextPop) {\n      forceNextPop = false;\n      setState();\n    } else {\n      var action = \'POP\';\n      transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {\n        if (ok) {\n          setState({\n            action: action,\n            location: location\n          });\n        } else {\n          revertPop(location);\n        }\n      });\n    }\n  }\n\n  function revertPop(fromLocation) {\n    var toLocation = history.location; // TODO: We could probably make this more reliable by\n    // keeping a list of keys we\'ve seen in sessionStorage.\n    // Instead, we just default to 0 for keys we don\'t know.\n\n    var toIndex = allKeys.indexOf(toLocation.key);\n    if (toIndex === -1) toIndex = 0;\n    var fromIndex = allKeys.indexOf(fromLocation.key);\n    if (fromIndex === -1) fromIndex = 0;\n    var delta = toIndex - fromIndex;\n\n    if (delta) {\n      forceNextPop = true;\n      go(delta);\n    }\n  }\n\n  var initialLocation = getDOMLocation(getHistoryState());\n  var allKeys = [initialLocation.key]; // Public interface\n\n  function createHref(location) {\n    return basename + createPath(location);\n  }\n\n  function push(path, state) {\n     false ? 0 : void 0;\n    var action = \'PUSH\';\n    var location = history_createLocation(path, state, createKey(), history.location);\n    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {\n      if (!ok) return;\n      var href = createHref(location);\n      var key = location.key,\n          state = location.state;\n\n      if (canUseHistory) {\n        globalHistory.pushState({\n          key: key,\n          state: state\n        }, null, href);\n\n        if (forceRefresh) {\n          window.location.href = href;\n        } else {\n          var prevIndex = allKeys.indexOf(history.location.key);\n          var nextKeys = allKeys.slice(0, prevIndex + 1);\n          nextKeys.push(location.key);\n          allKeys = nextKeys;\n          setState({\n            action: action,\n            location: location\n          });\n        }\n      } else {\n         false ? 0 : void 0;\n        window.location.href = href;\n      }\n    });\n  }\n\n  function replace(path, state) {\n     false ? 0 : void 0;\n    var action = \'REPLACE\';\n    var location = history_createLocation(path, state, createKey(), history.location);\n    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {\n      if (!ok) return;\n      var href = createHref(location);\n      var key = location.key,\n          state = location.state;\n\n      if (canUseHistory) {\n        globalHistory.replaceState({\n          key: key,\n          state: state\n        }, null, href);\n\n        if (forceRefresh) {\n          window.location.replace(href);\n        } else {\n          var prevIndex = allKeys.indexOf(history.location.key);\n          if (prevIndex !== -1) allKeys[prevIndex] = location.key;\n          setState({\n            action: action,\n            location: location\n          });\n        }\n      } else {\n         false ? 0 : void 0;\n        window.location.replace(href);\n      }\n    });\n  }\n\n  function go(n) {\n    globalHistory.go(n);\n  }\n\n  function goBack() {\n    go(-1);\n  }\n\n  function goForward() {\n    go(1);\n  }\n\n  var listenerCount = 0;\n\n  function checkDOMListeners(delta) {\n    listenerCount += delta;\n\n    if (listenerCount === 1 && delta === 1) {\n      window.addEventListener(PopStateEvent, handlePopState);\n      if (needsHashChangeListener) window.addEventListener(HashChangeEvent, handleHashChange);\n    } else if (listenerCount === 0) {\n      window.removeEventListener(PopStateEvent, handlePopState);\n      if (needsHashChangeListener) window.removeEventListener(HashChangeEvent, handleHashChange);\n    }\n  }\n\n  var isBlocked = false;\n\n  function block(prompt) {\n    if (prompt === void 0) {\n      prompt = false;\n    }\n\n    var unblock = transitionManager.setPrompt(prompt);\n\n    if (!isBlocked) {\n      checkDOMListeners(1);\n      isBlocked = true;\n    }\n\n    return function () {\n      if (isBlocked) {\n        isBlocked = false;\n        checkDOMListeners(-1);\n      }\n\n      return unblock();\n    };\n  }\n\n  function listen(listener) {\n    var unlisten = transitionManager.appendListener(listener);\n    checkDOMListeners(1);\n    return function () {\n      checkDOMListeners(-1);\n      unlisten();\n    };\n  }\n\n  var history = {\n    length: globalHistory.length,\n    action: \'POP\',\n    location: initialLocation,\n    createHref: createHref,\n    push: push,\n    replace: replace,\n    go: go,\n    goBack: goBack,\n    goForward: goForward,\n    block: block,\n    listen: listen\n  };\n  return history;\n}\n\nvar HashChangeEvent$1 = \'hashchange\';\nvar HashPathCoders = {\n  hashbang: {\n    encodePath: function encodePath(path) {\n      return path.charAt(0) === \'!\' ? path : \'!/\' + stripLeadingSlash(path);\n    },\n    decodePath: function decodePath(path) {\n      return path.charAt(0) === \'!\' ? path.substr(1) : path;\n    }\n  },\n  noslash: {\n    encodePath: stripLeadingSlash,\n    decodePath: addLeadingSlash\n  },\n  slash: {\n    encodePath: addLeadingSlash,\n    decodePath: addLeadingSlash\n  }\n};\n\nfunction stripHash(url) {\n  var hashIndex = url.indexOf(\'#\');\n  return hashIndex === -1 ? url : url.slice(0, hashIndex);\n}\n\nfunction getHashPath() {\n  // We can\'t use window.location.hash here because it\'s not\n  // consistent across browsers - Firefox will pre-decode it!\n  var href = window.location.href;\n  var hashIndex = href.indexOf(\'#\');\n  return hashIndex === -1 ? \'\' : href.substring(hashIndex + 1);\n}\n\nfunction pushHashPath(path) {\n  window.location.hash = path;\n}\n\nfunction replaceHashPath(path) {\n  window.location.replace(stripHash(window.location.href) + \'#\' + path);\n}\n\nfunction createHashHistory(props) {\n  if (props === void 0) {\n    props = {};\n  }\n\n  !canUseDOM ?  false ? 0 : tiny_invariant_esm(false) : void 0;\n  var globalHistory = window.history;\n  var canGoWithoutReload = supportsGoWithoutReloadUsingHash();\n  var _props = props,\n      _props$getUserConfirm = _props.getUserConfirmation,\n      getUserConfirmation = _props$getUserConfirm === void 0 ? getConfirmation : _props$getUserConfirm,\n      _props$hashType = _props.hashType,\n      hashType = _props$hashType === void 0 ? \'slash\' : _props$hashType;\n  var basename = props.basename ? stripTrailingSlash(addLeadingSlash(props.basename)) : \'\';\n  var _HashPathCoders$hashT = HashPathCoders[hashType],\n      encodePath = _HashPathCoders$hashT.encodePath,\n      decodePath = _HashPathCoders$hashT.decodePath;\n\n  function getDOMLocation() {\n    var path = decodePath(getHashPath());\n     false ? 0 : void 0;\n    if (basename) path = stripBasename(path, basename);\n    return history_createLocation(path);\n  }\n\n  var transitionManager = createTransitionManager();\n\n  function setState(nextState) {\n    extends_extends(history, nextState);\n\n    history.length = globalHistory.length;\n    transitionManager.notifyListeners(history.location, history.action);\n  }\n\n  var forceNextPop = false;\n  var ignorePath = null;\n\n  function locationsAreEqual$$1(a, b) {\n    return a.pathname === b.pathname && a.search === b.search && a.hash === b.hash;\n  }\n\n  function handleHashChange() {\n    var path = getHashPath();\n    var encodedPath = encodePath(path);\n\n    if (path !== encodedPath) {\n      // Ensure we always have a properly-encoded hash.\n      replaceHashPath(encodedPath);\n    } else {\n      var location = getDOMLocation();\n      var prevLocation = history.location;\n      if (!forceNextPop && locationsAreEqual$$1(prevLocation, location)) return; // A hashchange doesn\'t always == location change.\n\n      if (ignorePath === createPath(location)) return; // Ignore this change; we already setState in push/replace.\n\n      ignorePath = null;\n      handlePop(location);\n    }\n  }\n\n  function handlePop(location) {\n    if (forceNextPop) {\n      forceNextPop = false;\n      setState();\n    } else {\n      var action = \'POP\';\n      transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {\n        if (ok) {\n          setState({\n            action: action,\n            location: location\n          });\n        } else {\n          revertPop(location);\n        }\n      });\n    }\n  }\n\n  function revertPop(fromLocation) {\n    var toLocation = history.location; // TODO: We could probably make this more reliable by\n    // keeping a list of paths we\'ve seen in sessionStorage.\n    // Instead, we just default to 0 for paths we don\'t know.\n\n    var toIndex = allPaths.lastIndexOf(createPath(toLocation));\n    if (toIndex === -1) toIndex = 0;\n    var fromIndex = allPaths.lastIndexOf(createPath(fromLocation));\n    if (fromIndex === -1) fromIndex = 0;\n    var delta = toIndex - fromIndex;\n\n    if (delta) {\n      forceNextPop = true;\n      go(delta);\n    }\n  } // Ensure the hash is encoded properly before doing anything else.\n\n\n  var path = getHashPath();\n  var encodedPath = encodePath(path);\n  if (path !== encodedPath) replaceHashPath(encodedPath);\n  var initialLocation = getDOMLocation();\n  var allPaths = [createPath(initialLocation)]; // Public interface\n\n  function createHref(location) {\n    var baseTag = document.querySelector(\'base\');\n    var href = \'\';\n\n    if (baseTag && baseTag.getAttribute(\'href\')) {\n      href = stripHash(window.location.href);\n    }\n\n    return href + \'#\' + encodePath(basename + createPath(location));\n  }\n\n  function push(path, state) {\n     false ? 0 : void 0;\n    var action = \'PUSH\';\n    var location = history_createLocation(path, undefined, undefined, history.location);\n    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {\n      if (!ok) return;\n      var path = createPath(location);\n      var encodedPath = encodePath(basename + path);\n      var hashChanged = getHashPath() !== encodedPath;\n\n      if (hashChanged) {\n        // We cannot tell if a hashchange was caused by a PUSH, so we\'d\n        // rather setState here and ignore the hashchange. The caveat here\n        // is that other hash histories in the page will consider it a POP.\n        ignorePath = path;\n        pushHashPath(encodedPath);\n        var prevIndex = allPaths.lastIndexOf(createPath(history.location));\n        var nextPaths = allPaths.slice(0, prevIndex + 1);\n        nextPaths.push(path);\n        allPaths = nextPaths;\n        setState({\n          action: action,\n          location: location\n        });\n      } else {\n         false ? 0 : void 0;\n        setState();\n      }\n    });\n  }\n\n  function replace(path, state) {\n     false ? 0 : void 0;\n    var action = \'REPLACE\';\n    var location = history_createLocation(path, undefined, undefined, history.location);\n    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {\n      if (!ok) return;\n      var path = createPath(location);\n      var encodedPath = encodePath(basename + path);\n      var hashChanged = getHashPath() !== encodedPath;\n\n      if (hashChanged) {\n        // We cannot tell if a hashchange was caused by a REPLACE, so we\'d\n        // rather setState here and ignore the hashchange. The caveat here\n        // is that other hash histories in the page will consider it a POP.\n        ignorePath = path;\n        replaceHashPath(encodedPath);\n      }\n\n      var prevIndex = allPaths.indexOf(createPath(history.location));\n      if (prevIndex !== -1) allPaths[prevIndex] = path;\n      setState({\n        action: action,\n        location: location\n      });\n    });\n  }\n\n  function go(n) {\n     false ? 0 : void 0;\n    globalHistory.go(n);\n  }\n\n  function goBack() {\n    go(-1);\n  }\n\n  function goForward() {\n    go(1);\n  }\n\n  var listenerCount = 0;\n\n  function checkDOMListeners(delta) {\n    listenerCount += delta;\n\n    if (listenerCount === 1 && delta === 1) {\n      window.addEventListener(HashChangeEvent$1, handleHashChange);\n    } else if (listenerCount === 0) {\n      window.removeEventListener(HashChangeEvent$1, handleHashChange);\n    }\n  }\n\n  var isBlocked = false;\n\n  function block(prompt) {\n    if (prompt === void 0) {\n      prompt = false;\n    }\n\n    var unblock = transitionManager.setPrompt(prompt);\n\n    if (!isBlocked) {\n      checkDOMListeners(1);\n      isBlocked = true;\n    }\n\n    return function () {\n      if (isBlocked) {\n        isBlocked = false;\n        checkDOMListeners(-1);\n      }\n\n      return unblock();\n    };\n  }\n\n  function listen(listener) {\n    var unlisten = transitionManager.appendListener(listener);\n    checkDOMListeners(1);\n    return function () {\n      checkDOMListeners(-1);\n      unlisten();\n    };\n  }\n\n  var history = {\n    length: globalHistory.length,\n    action: \'POP\',\n    location: initialLocation,\n    createHref: createHref,\n    push: push,\n    replace: replace,\n    go: go,\n    goBack: goBack,\n    goForward: goForward,\n    block: block,\n    listen: listen\n  };\n  return history;\n}\n\nfunction clamp(n, lowerBound, upperBound) {\n  return Math.min(Math.max(n, lowerBound), upperBound);\n}\n/**\n * Creates a history object that stores locations in memory.\n */\n\n\nfunction createMemoryHistory(props) {\n  if (props === void 0) {\n    props = {};\n  }\n\n  var _props = props,\n      getUserConfirmation = _props.getUserConfirmation,\n      _props$initialEntries = _props.initialEntries,\n      initialEntries = _props$initialEntries === void 0 ? [\'/\'] : _props$initialEntries,\n      _props$initialIndex = _props.initialIndex,\n      initialIndex = _props$initialIndex === void 0 ? 0 : _props$initialIndex,\n      _props$keyLength = _props.keyLength,\n      keyLength = _props$keyLength === void 0 ? 6 : _props$keyLength;\n  var transitionManager = createTransitionManager();\n\n  function setState(nextState) {\n    extends_extends(history, nextState);\n\n    history.length = history.entries.length;\n    transitionManager.notifyListeners(history.location, history.action);\n  }\n\n  function createKey() {\n    return Math.random().toString(36).substr(2, keyLength);\n  }\n\n  var index = clamp(initialIndex, 0, initialEntries.length - 1);\n  var entries = initialEntries.map(function (entry) {\n    return typeof entry === \'string\' ? history_createLocation(entry, undefined, createKey()) : history_createLocation(entry, undefined, entry.key || createKey());\n  }); // Public interface\n\n  var createHref = createPath;\n\n  function push(path, state) {\n     false ? 0 : void 0;\n    var action = \'PUSH\';\n    var location = history_createLocation(path, state, createKey(), history.location);\n    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {\n      if (!ok) return;\n      var prevIndex = history.index;\n      var nextIndex = prevIndex + 1;\n      var nextEntries = history.entries.slice(0);\n\n      if (nextEntries.length > nextIndex) {\n        nextEntries.splice(nextIndex, nextEntries.length - nextIndex, location);\n      } else {\n        nextEntries.push(location);\n      }\n\n      setState({\n        action: action,\n        location: location,\n        index: nextIndex,\n        entries: nextEntries\n      });\n    });\n  }\n\n  function replace(path, state) {\n     false ? 0 : void 0;\n    var action = \'REPLACE\';\n    var location = history_createLocation(path, state, createKey(), history.location);\n    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {\n      if (!ok) return;\n      history.entries[history.index] = location;\n      setState({\n        action: action,\n        location: location\n      });\n    });\n  }\n\n  function go(n) {\n    var nextIndex = clamp(history.index + n, 0, history.entries.length - 1);\n    var action = \'POP\';\n    var location = history.entries[nextIndex];\n    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {\n      if (ok) {\n        setState({\n          action: action,\n          location: location,\n          index: nextIndex\n        });\n      } else {\n        // Mimic the behavior of DOM histories by\n        // causing a render after a cancelled POP.\n        setState();\n      }\n    });\n  }\n\n  function goBack() {\n    go(-1);\n  }\n\n  function goForward() {\n    go(1);\n  }\n\n  function canGo(n) {\n    var nextIndex = history.index + n;\n    return nextIndex >= 0 && nextIndex < history.entries.length;\n  }\n\n  function block(prompt) {\n    if (prompt === void 0) {\n      prompt = false;\n    }\n\n    return transitionManager.setPrompt(prompt);\n  }\n\n  function listen(listener) {\n    return transitionManager.appendListener(listener);\n  }\n\n  var history = {\n    length: entries.length,\n    action: \'POP\',\n    location: entries[index],\n    index: index,\n    entries: entries,\n    createHref: createHref,\n    push: push,\n    replace: replace,\n    go: go,\n    goBack: goBack,\n    goForward: goForward,\n    canGo: canGo,\n    block: block,\n    listen: listen\n  };\n  return history;\n}\n\n\n\n;// CONCATENATED MODULE: ./node_modules/mini-create-react-context/dist/esm/index.js\n\n\n\n\n\nvar MAX_SIGNED_31_BIT_INT = 1073741823;\nvar commonjsGlobal = typeof globalThis !== \'undefined\' ? globalThis : typeof window !== \'undefined\' ? window : typeof __webpack_require__.g !== \'undefined\' ? __webpack_require__.g : {};\n\nfunction getUniqueId() {\n  var key = \'__global_unique_id__\';\n  return commonjsGlobal[key] = (commonjsGlobal[key] || 0) + 1;\n}\n\nfunction objectIs(x, y) {\n  if (x === y) {\n    return x !== 0 || 1 / x === 1 / y;\n  } else {\n    return x !== x && y !== y;\n  }\n}\n\nfunction createEventEmitter(value) {\n  var handlers = [];\n  return {\n    on: function on(handler) {\n      handlers.push(handler);\n    },\n    off: function off(handler) {\n      handlers = handlers.filter(function (h) {\n        return h !== handler;\n      });\n    },\n    get: function get() {\n      return value;\n    },\n    set: function set(newValue, changedBits) {\n      value = newValue;\n      handlers.forEach(function (handler) {\n        return handler(value, changedBits);\n      });\n    }\n  };\n}\n\nfunction onlyChild(children) {\n  return Array.isArray(children) ? children[0] : children;\n}\n\nfunction createReactContext(defaultValue, calculateChangedBits) {\n  var _Provider$childContex, _Consumer$contextType;\n\n  var contextProp = \'__create-react-context-\' + getUniqueId() + \'__\';\n\n  var Provider = /*#__PURE__*/function (_Component) {\n    _inheritsLoose(Provider, _Component);\n\n    function Provider() {\n      var _this;\n\n      _this = _Component.apply(this, arguments) || this;\n      _this.emitter = createEventEmitter(_this.props.value);\n      return _this;\n    }\n\n    var _proto = Provider.prototype;\n\n    _proto.getChildContext = function getChildContext() {\n      var _ref;\n\n      return _ref = {}, _ref[contextProp] = this.emitter, _ref;\n    };\n\n    _proto.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {\n      if (this.props.value !== nextProps.value) {\n        var oldValue = this.props.value;\n        var newValue = nextProps.value;\n        var changedBits;\n\n        if (objectIs(oldValue, newValue)) {\n          changedBits = 0;\n        } else {\n          changedBits = typeof calculateChangedBits === \'function\' ? calculateChangedBits(oldValue, newValue) : MAX_SIGNED_31_BIT_INT;\n\n          if (false) {}\n\n          changedBits |= 0;\n\n          if (changedBits !== 0) {\n            this.emitter.set(nextProps.value, changedBits);\n          }\n        }\n      }\n    };\n\n    _proto.render = function render() {\n      return this.props.children;\n    };\n\n    return Provider;\n  }(react.Component);\n\n  Provider.childContextTypes = (_Provider$childContex = {}, _Provider$childContex[contextProp] = (prop_types_default()).object.isRequired, _Provider$childContex);\n\n  var Consumer = /*#__PURE__*/function (_Component2) {\n    _inheritsLoose(Consumer, _Component2);\n\n    function Consumer() {\n      var _this2;\n\n      _this2 = _Component2.apply(this, arguments) || this;\n      _this2.state = {\n        value: _this2.getValue()\n      };\n\n      _this2.onUpdate = function (newValue, changedBits) {\n        var observedBits = _this2.observedBits | 0;\n\n        if ((observedBits & changedBits) !== 0) {\n          _this2.setState({\n            value: _this2.getValue()\n          });\n        }\n      };\n\n      return _this2;\n    }\n\n    var _proto2 = Consumer.prototype;\n\n    _proto2.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {\n      var observedBits = nextProps.observedBits;\n      this.observedBits = observedBits === undefined || observedBits === null ? MAX_SIGNED_31_BIT_INT : observedBits;\n    };\n\n    _proto2.componentDidMount = function componentDidMount() {\n      if (this.context[contextProp]) {\n        this.context[contextProp].on(this.onUpdate);\n      }\n\n      var observedBits = this.props.observedBits;\n      this.observedBits = observedBits === undefined || observedBits === null ? MAX_SIGNED_31_BIT_INT : observedBits;\n    };\n\n    _proto2.componentWillUnmount = function componentWillUnmount() {\n      if (this.context[contextProp]) {\n        this.context[contextProp].off(this.onUpdate);\n      }\n    };\n\n    _proto2.getValue = function getValue() {\n      if (this.context[contextProp]) {\n        return this.context[contextProp].get();\n      } else {\n        return defaultValue;\n      }\n    };\n\n    _proto2.render = function render() {\n      return onlyChild(this.props.children)(this.state.value);\n    };\n\n    return Consumer;\n  }(react.Component);\n\n  Consumer.contextTypes = (_Consumer$contextType = {}, _Consumer$contextType[contextProp] = (prop_types_default()).object, _Consumer$contextType);\n  return {\n    Provider: Provider,\n    Consumer: Consumer\n  };\n}\n\nvar index = react.createContext || createReactContext;\n\n/* harmony default export */ const esm = (index);\n\n// EXTERNAL MODULE: ./node_modules/path-to-regexp/index.js\nvar path_to_regexp = __webpack_require__(779);\nvar path_to_regexp_default = /*#__PURE__*/__webpack_require__.n(path_to_regexp);\n// EXTERNAL MODULE: ./node_modules/react-is/index.js\nvar react_is = __webpack_require__(864);\n;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/objectWithoutPropertiesLoose.js\nfunction objectWithoutPropertiesLoose_objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}\n// EXTERNAL MODULE: ./node_modules/hoist-non-react-statics/dist/hoist-non-react-statics.cjs.js\nvar hoist_non_react_statics_cjs = __webpack_require__(679);\n;// CONCATENATED MODULE: ./node_modules/react-router/esm/react-router.js\n\n\n\n\n\n\n\n\n\n\n\n\n\n// TODO: Replace with React.createContext once we can assume React 16+\n\nvar createNamedContext = function createNamedContext(name) {\n  var context = esm();\n  context.displayName = name;\n  return context;\n};\n\nvar historyContext = /*#__PURE__*/createNamedContext("Router-History");\n\nvar context = /*#__PURE__*/createNamedContext("Router");\n\n/**\n * The public API for putting history on context.\n */\n\nvar Router = /*#__PURE__*/function (_React$Component) {\n  _inheritsLoose(Router, _React$Component);\n\n  Router.computeRootMatch = function computeRootMatch(pathname) {\n    return {\n      path: "/",\n      url: "/",\n      params: {},\n      isExact: pathname === "/"\n    };\n  };\n\n  function Router(props) {\n    var _this;\n\n    _this = _React$Component.call(this, props) || this;\n    _this.state = {\n      location: props.history.location\n    }; // This is a bit of a hack. We have to start listening for location\n    // changes here in the constructor in case there are any <Redirect>s\n    // on the initial render. If there are, they will replace/push when\n    // they mount and since cDM fires in children before parents, we may\n    // get a new location before the <Router> is mounted.\n\n    _this._isMounted = false;\n    _this._pendingLocation = null;\n\n    if (!props.staticContext) {\n      _this.unlisten = props.history.listen(function (location) {\n        if (_this._isMounted) {\n          _this.setState({\n            location: location\n          });\n        } else {\n          _this._pendingLocation = location;\n        }\n      });\n    }\n\n    return _this;\n  }\n\n  var _proto = Router.prototype;\n\n  _proto.componentDidMount = function componentDidMount() {\n    this._isMounted = true;\n\n    if (this._pendingLocation) {\n      this.setState({\n        location: this._pendingLocation\n      });\n    }\n  };\n\n  _proto.componentWillUnmount = function componentWillUnmount() {\n    if (this.unlisten) {\n      this.unlisten();\n      this._isMounted = false;\n      this._pendingLocation = null;\n    }\n  };\n\n  _proto.render = function render() {\n    return /*#__PURE__*/react.createElement(context.Provider, {\n      value: {\n        history: this.props.history,\n        location: this.state.location,\n        match: Router.computeRootMatch(this.state.location.pathname),\n        staticContext: this.props.staticContext\n      }\n    }, /*#__PURE__*/react.createElement(historyContext.Provider, {\n      children: this.props.children || null,\n      value: this.props.history\n    }));\n  };\n\n  return Router;\n}(react.Component);\n\nif (false) {}\n\n/**\n * The public API for a <Router> that stores location in memory.\n */\n\nvar MemoryRouter = /*#__PURE__*/function (_React$Component) {\n  _inheritsLoose(MemoryRouter, _React$Component);\n\n  function MemoryRouter() {\n    var _this;\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;\n    _this.history = createMemoryHistory(_this.props);\n    return _this;\n  }\n\n  var _proto = MemoryRouter.prototype;\n\n  _proto.render = function render() {\n    return /*#__PURE__*/react.createElement(Router, {\n      history: this.history,\n      children: this.props.children\n    });\n  };\n\n  return MemoryRouter;\n}(react.Component);\n\nif (false) {}\n\nvar Lifecycle = /*#__PURE__*/function (_React$Component) {\n  _inheritsLoose(Lifecycle, _React$Component);\n\n  function Lifecycle() {\n    return _React$Component.apply(this, arguments) || this;\n  }\n\n  var _proto = Lifecycle.prototype;\n\n  _proto.componentDidMount = function componentDidMount() {\n    if (this.props.onMount) this.props.onMount.call(this, this);\n  };\n\n  _proto.componentDidUpdate = function componentDidUpdate(prevProps) {\n    if (this.props.onUpdate) this.props.onUpdate.call(this, this, prevProps);\n  };\n\n  _proto.componentWillUnmount = function componentWillUnmount() {\n    if (this.props.onUnmount) this.props.onUnmount.call(this, this);\n  };\n\n  _proto.render = function render() {\n    return null;\n  };\n\n  return Lifecycle;\n}(react.Component);\n\n/**\n * The public API for prompting the user before navigating away from a screen.\n */\n\nfunction Prompt(_ref) {\n  var message = _ref.message,\n      _ref$when = _ref.when,\n      when = _ref$when === void 0 ? true : _ref$when;\n  return /*#__PURE__*/React.createElement(context.Consumer, null, function (context) {\n    !context ?  false ? 0 : invariant(false) : void 0;\n    if (!when || context.staticContext) return null;\n    var method = context.history.block;\n    return /*#__PURE__*/React.createElement(Lifecycle, {\n      onMount: function onMount(self) {\n        self.release = method(message);\n      },\n      onUpdate: function onUpdate(self, prevProps) {\n        if (prevProps.message !== message) {\n          self.release();\n          self.release = method(message);\n        }\n      },\n      onUnmount: function onUnmount(self) {\n        self.release();\n      },\n      message: message\n    });\n  });\n}\n\nif (false) { var messageType; }\n\nvar cache = {};\nvar cacheLimit = 10000;\nvar cacheCount = 0;\n\nfunction compilePath(path) {\n  if (cache[path]) return cache[path];\n  var generator = pathToRegexp.compile(path);\n\n  if (cacheCount < cacheLimit) {\n    cache[path] = generator;\n    cacheCount++;\n  }\n\n  return generator;\n}\n/**\n * Public API for generating a URL pathname from a path and parameters.\n */\n\n\nfunction generatePath(path, params) {\n  if (path === void 0) {\n    path = "/";\n  }\n\n  if (params === void 0) {\n    params = {};\n  }\n\n  return path === "/" ? path : compilePath(path)(params, {\n    pretty: true\n  });\n}\n\n/**\n * The public API for navigating programmatically with a component.\n */\n\nfunction Redirect(_ref) {\n  var computedMatch = _ref.computedMatch,\n      to = _ref.to,\n      _ref$push = _ref.push,\n      push = _ref$push === void 0 ? false : _ref$push;\n  return /*#__PURE__*/React.createElement(context.Consumer, null, function (context) {\n    !context ?  false ? 0 : invariant(false) : void 0;\n    var history = context.history,\n        staticContext = context.staticContext;\n    var method = push ? history.push : history.replace;\n    var location = createLocation(computedMatch ? typeof to === "string" ? generatePath(to, computedMatch.params) : _extends({}, to, {\n      pathname: generatePath(to.pathname, computedMatch.params)\n    }) : to); // When rendering in a static context,\n    // set the new location immediately.\n\n    if (staticContext) {\n      method(location);\n      return null;\n    }\n\n    return /*#__PURE__*/React.createElement(Lifecycle, {\n      onMount: function onMount() {\n        method(location);\n      },\n      onUpdate: function onUpdate(self, prevProps) {\n        var prevLocation = createLocation(prevProps.to);\n\n        if (!locationsAreEqual(prevLocation, _extends({}, location, {\n          key: prevLocation.key\n        }))) {\n          method(location);\n        }\n      },\n      to: to\n    });\n  });\n}\n\nif (false) {}\n\nvar cache$1 = {};\nvar cacheLimit$1 = 10000;\nvar cacheCount$1 = 0;\n\nfunction compilePath$1(path, options) {\n  var cacheKey = "" + options.end + options.strict + options.sensitive;\n  var pathCache = cache$1[cacheKey] || (cache$1[cacheKey] = {});\n  if (pathCache[path]) return pathCache[path];\n  var keys = [];\n  var regexp = path_to_regexp_default()(path, keys, options);\n  var result = {\n    regexp: regexp,\n    keys: keys\n  };\n\n  if (cacheCount$1 < cacheLimit$1) {\n    pathCache[path] = result;\n    cacheCount$1++;\n  }\n\n  return result;\n}\n/**\n * Public API for matching a URL pathname to a path.\n */\n\n\nfunction matchPath(pathname, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  if (typeof options === "string" || Array.isArray(options)) {\n    options = {\n      path: options\n    };\n  }\n\n  var _options = options,\n      path = _options.path,\n      _options$exact = _options.exact,\n      exact = _options$exact === void 0 ? false : _options$exact,\n      _options$strict = _options.strict,\n      strict = _options$strict === void 0 ? false : _options$strict,\n      _options$sensitive = _options.sensitive,\n      sensitive = _options$sensitive === void 0 ? false : _options$sensitive;\n  var paths = [].concat(path);\n  return paths.reduce(function (matched, path) {\n    if (!path && path !== "") return null;\n    if (matched) return matched;\n\n    var _compilePath = compilePath$1(path, {\n      end: exact,\n      strict: strict,\n      sensitive: sensitive\n    }),\n        regexp = _compilePath.regexp,\n        keys = _compilePath.keys;\n\n    var match = regexp.exec(pathname);\n    if (!match) return null;\n    var url = match[0],\n        values = match.slice(1);\n    var isExact = pathname === url;\n    if (exact && !isExact) return null;\n    return {\n      path: path,\n      // the path used to match\n      url: path === "/" && url === "" ? "/" : url,\n      // the matched portion of the URL\n      isExact: isExact,\n      // whether or not we matched exactly\n      params: keys.reduce(function (memo, key, index) {\n        memo[key.name] = values[index];\n        return memo;\n      }, {})\n    };\n  }, null);\n}\n\nfunction isEmptyChildren(children) {\n  return react.Children.count(children) === 0;\n}\n\nfunction evalChildrenDev(children, props, path) {\n  var value = children(props);\n   false ? 0 : void 0;\n  return value || null;\n}\n/**\n * The public API for matching a single path and rendering.\n */\n\n\nvar Route = /*#__PURE__*/function (_React$Component) {\n  _inheritsLoose(Route, _React$Component);\n\n  function Route() {\n    return _React$Component.apply(this, arguments) || this;\n  }\n\n  var _proto = Route.prototype;\n\n  _proto.render = function render() {\n    var _this = this;\n\n    return /*#__PURE__*/react.createElement(context.Consumer, null, function (context$1) {\n      !context$1 ?  false ? 0 : tiny_invariant_esm(false) : void 0;\n      var location = _this.props.location || context$1.location;\n      var match = _this.props.computedMatch ? _this.props.computedMatch // <Switch> already computed the match for us\n      : _this.props.path ? matchPath(location.pathname, _this.props) : context$1.match;\n\n      var props = extends_extends({}, context$1, {\n        location: location,\n        match: match\n      });\n\n      var _this$props = _this.props,\n          children = _this$props.children,\n          component = _this$props.component,\n          render = _this$props.render; // Preact uses an empty array as children by\n      // default, so use null if that\'s the case.\n\n      if (Array.isArray(children) && isEmptyChildren(children)) {\n        children = null;\n      }\n\n      return /*#__PURE__*/react.createElement(context.Provider, {\n        value: props\n      }, props.match ? children ? typeof children === "function" ?  false ? 0 : children(props) : children : component ? /*#__PURE__*/react.createElement(component, props) : render ? render(props) : null : typeof children === "function" ?  false ? 0 : children(props) : null);\n    });\n  };\n\n  return Route;\n}(react.Component);\n\nif (false) {}\n\nfunction react_router_addLeadingSlash(path) {\n  return path.charAt(0) === "/" ? path : "/" + path;\n}\n\nfunction addBasename(basename, location) {\n  if (!basename) return location;\n  return extends_extends({}, location, {\n    pathname: react_router_addLeadingSlash(basename) + location.pathname\n  });\n}\n\nfunction react_router_stripBasename(basename, location) {\n  if (!basename) return location;\n  var base = react_router_addLeadingSlash(basename);\n  if (location.pathname.indexOf(base) !== 0) return location;\n  return extends_extends({}, location, {\n    pathname: location.pathname.substr(base.length)\n  });\n}\n\nfunction createURL(location) {\n  return typeof location === "string" ? location : createPath(location);\n}\n\nfunction staticHandler(methodName) {\n  return function () {\n      false ? 0 : tiny_invariant_esm(false) ;\n  };\n}\n\nfunction noop() {}\n/**\n * The public top-level API for a "static" <Router>, so-called because it\n * can\'t actually change the current location. Instead, it just records\n * location changes in a context object. Useful mainly in testing and\n * server-rendering scenarios.\n */\n\n\nvar StaticRouter = /*#__PURE__*/function (_React$Component) {\n  _inheritsLoose(StaticRouter, _React$Component);\n\n  function StaticRouter() {\n    var _this;\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;\n\n    _this.handlePush = function (location) {\n      return _this.navigateTo(location, "PUSH");\n    };\n\n    _this.handleReplace = function (location) {\n      return _this.navigateTo(location, "REPLACE");\n    };\n\n    _this.handleListen = function () {\n      return noop;\n    };\n\n    _this.handleBlock = function () {\n      return noop;\n    };\n\n    return _this;\n  }\n\n  var _proto = StaticRouter.prototype;\n\n  _proto.navigateTo = function navigateTo(location, action) {\n    var _this$props = this.props,\n        _this$props$basename = _this$props.basename,\n        basename = _this$props$basename === void 0 ? "" : _this$props$basename,\n        _this$props$context = _this$props.context,\n        context = _this$props$context === void 0 ? {} : _this$props$context;\n    context.action = action;\n    context.location = addBasename(basename, history_createLocation(location));\n    context.url = createURL(context.location);\n  };\n\n  _proto.render = function render() {\n    var _this$props2 = this.props,\n        _this$props2$basename = _this$props2.basename,\n        basename = _this$props2$basename === void 0 ? "" : _this$props2$basename,\n        _this$props2$context = _this$props2.context,\n        context = _this$props2$context === void 0 ? {} : _this$props2$context,\n        _this$props2$location = _this$props2.location,\n        location = _this$props2$location === void 0 ? "/" : _this$props2$location,\n        rest = objectWithoutPropertiesLoose_objectWithoutPropertiesLoose(_this$props2, ["basename", "context", "location"]);\n\n    var history = {\n      createHref: function createHref(path) {\n        return react_router_addLeadingSlash(basename + createURL(path));\n      },\n      action: "POP",\n      location: react_router_stripBasename(basename, history_createLocation(location)),\n      push: this.handlePush,\n      replace: this.handleReplace,\n      go: staticHandler("go"),\n      goBack: staticHandler("goBack"),\n      goForward: staticHandler("goForward"),\n      listen: this.handleListen,\n      block: this.handleBlock\n    };\n    return /*#__PURE__*/react.createElement(Router, extends_extends({}, rest, {\n      history: history,\n      staticContext: context\n    }));\n  };\n\n  return StaticRouter;\n}(react.Component);\n\nif (false) {}\n\n/**\n * The public API for rendering the first <Route> that matches.\n */\n\nvar Switch = /*#__PURE__*/function (_React$Component) {\n  _inheritsLoose(Switch, _React$Component);\n\n  function Switch() {\n    return _React$Component.apply(this, arguments) || this;\n  }\n\n  var _proto = Switch.prototype;\n\n  _proto.render = function render() {\n    var _this = this;\n\n    return /*#__PURE__*/react.createElement(context.Consumer, null, function (context) {\n      !context ?  false ? 0 : tiny_invariant_esm(false) : void 0;\n      var location = _this.props.location || context.location;\n      var element, match; // We use React.Children.forEach instead of React.Children.toArray().find()\n      // here because toArray adds keys to all child elements and we do not want\n      // to trigger an unmount/remount for two <Route>s that render the same\n      // component at different URLs.\n\n      react.Children.forEach(_this.props.children, function (child) {\n        if (match == null && /*#__PURE__*/react.isValidElement(child)) {\n          element = child;\n          var path = child.props.path || child.props.from;\n          match = path ? matchPath(location.pathname, extends_extends({}, child.props, {\n            path: path\n          })) : context.match;\n        }\n      });\n      return match ? /*#__PURE__*/react.cloneElement(element, {\n        location: location,\n        computedMatch: match\n      }) : null;\n    });\n  };\n\n  return Switch;\n}(react.Component);\n\nif (false) {}\n\n/**\n * A public higher-order component to access the imperative API\n */\n\nfunction withRouter(Component) {\n  var displayName = "withRouter(" + (Component.displayName || Component.name) + ")";\n\n  var C = function C(props) {\n    var wrappedComponentRef = props.wrappedComponentRef,\n        remainingProps = _objectWithoutPropertiesLoose(props, ["wrappedComponentRef"]);\n\n    return /*#__PURE__*/React.createElement(context.Consumer, null, function (context) {\n      !context ?  false ? 0 : invariant(false) : void 0;\n      return /*#__PURE__*/React.createElement(Component, _extends({}, remainingProps, context, {\n        ref: wrappedComponentRef\n      }));\n    });\n  };\n\n  C.displayName = displayName;\n  C.WrappedComponent = Component;\n\n  if (false) {}\n\n  return hoistStatics(C, Component);\n}\n\nvar useContext = react.useContext;\nfunction useHistory() {\n  if (false) {}\n\n  return useContext(historyContext);\n}\nfunction useLocation() {\n  if (false) {}\n\n  return useContext(context).location;\n}\nfunction useParams() {\n  if (false) {}\n\n  var match = useContext(context).match;\n  return match ? match.params : {};\n}\nfunction useRouteMatch(path) {\n  if (false) {}\n\n  var location = useLocation();\n  var match = useContext(context).match;\n  return path ? matchPath(location.pathname, path) : match;\n}\n\nif (false) { var secondaryBuildName, initialBuildName, buildNames, key, global; }\n\n\n//# sourceMappingURL=react-router.js.map\n\n;// CONCATENATED MODULE: ./node_modules/react-router-dom/esm/react-router-dom.js\n\n\n\n\n\n\n\n\n\n\n\n/**\n * The public API for a <Router> that uses HTML5 history.\n */\n\nvar BrowserRouter = /*#__PURE__*/function (_React$Component) {\n  _inheritsLoose(BrowserRouter, _React$Component);\n\n  function BrowserRouter() {\n    var _this;\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;\n    _this.history = createBrowserHistory(_this.props);\n    return _this;\n  }\n\n  var _proto = BrowserRouter.prototype;\n\n  _proto.render = function render() {\n    return /*#__PURE__*/react.createElement(Router, {\n      history: this.history,\n      children: this.props.children\n    });\n  };\n\n  return BrowserRouter;\n}(react.Component);\n\nif (false) {}\n\n/**\n * The public API for a <Router> that uses window.location.hash.\n */\n\nvar HashRouter = /*#__PURE__*/function (_React$Component) {\n  _inheritsLoose(HashRouter, _React$Component);\n\n  function HashRouter() {\n    var _this;\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;\n    _this.history = createHashHistory(_this.props);\n    return _this;\n  }\n\n  var _proto = HashRouter.prototype;\n\n  _proto.render = function render() {\n    return /*#__PURE__*/react.createElement(Router, {\n      history: this.history,\n      children: this.props.children\n    });\n  };\n\n  return HashRouter;\n}(react.Component);\n\nif (false) {}\n\nvar resolveToLocation = function resolveToLocation(to, currentLocation) {\n  return typeof to === "function" ? to(currentLocation) : to;\n};\nvar normalizeToLocation = function normalizeToLocation(to, currentLocation) {\n  return typeof to === "string" ? history_createLocation(to, null, null, currentLocation) : to;\n};\n\nvar forwardRefShim = function forwardRefShim(C) {\n  return C;\n};\n\nvar react_router_dom_forwardRef = react.forwardRef;\n\nif (typeof react_router_dom_forwardRef === "undefined") {\n  react_router_dom_forwardRef = forwardRefShim;\n}\n\nfunction isModifiedEvent(event) {\n  return !!(event.metaKey || event.altKey || event.ctrlKey || event.shiftKey);\n}\n\nvar LinkAnchor = react_router_dom_forwardRef(function (_ref, forwardedRef) {\n  var innerRef = _ref.innerRef,\n      navigate = _ref.navigate,\n      _onClick = _ref.onClick,\n      rest = objectWithoutPropertiesLoose_objectWithoutPropertiesLoose(_ref, ["innerRef", "navigate", "onClick"]);\n\n  var target = rest.target;\n\n  var props = extends_extends({}, rest, {\n    onClick: function onClick(event) {\n      try {\n        if (_onClick) _onClick(event);\n      } catch (ex) {\n        event.preventDefault();\n        throw ex;\n      }\n\n      if (!event.defaultPrevented && // onClick prevented default\n      event.button === 0 && ( // ignore everything but left clicks\n      !target || target === "_self") && // let browser handle "target=_blank" etc.\n      !isModifiedEvent(event) // ignore clicks with modifier keys\n      ) {\n          event.preventDefault();\n          navigate();\n        }\n    }\n  }); // React 15 compat\n\n\n  if (forwardRefShim !== react_router_dom_forwardRef) {\n    props.ref = forwardedRef || innerRef;\n  } else {\n    props.ref = innerRef;\n  }\n  /* eslint-disable-next-line jsx-a11y/anchor-has-content */\n\n\n  return /*#__PURE__*/react.createElement("a", props);\n});\n\nif (false) {}\n/**\n * The public API for rendering a history-aware <a>.\n */\n\n\nvar Link = react_router_dom_forwardRef(function (_ref2, forwardedRef) {\n  var _ref2$component = _ref2.component,\n      component = _ref2$component === void 0 ? LinkAnchor : _ref2$component,\n      replace = _ref2.replace,\n      to = _ref2.to,\n      innerRef = _ref2.innerRef,\n      rest = objectWithoutPropertiesLoose_objectWithoutPropertiesLoose(_ref2, ["component", "replace", "to", "innerRef"]);\n\n  return /*#__PURE__*/react.createElement(context.Consumer, null, function (context) {\n    !context ?  false ? 0 : tiny_invariant_esm(false) : void 0;\n    var history = context.history;\n    var location = normalizeToLocation(resolveToLocation(to, context.location), context.location);\n    var href = location ? history.createHref(location) : "";\n\n    var props = extends_extends({}, rest, {\n      href: href,\n      navigate: function navigate() {\n        var location = resolveToLocation(to, context.location);\n        var isDuplicateNavigation = createPath(context.location) === createPath(normalizeToLocation(location));\n        var method = replace || isDuplicateNavigation ? history.replace : history.push;\n        method(location);\n      }\n    }); // React 15 compat\n\n\n    if (forwardRefShim !== react_router_dom_forwardRef) {\n      props.ref = forwardedRef || innerRef;\n    } else {\n      props.innerRef = innerRef;\n    }\n\n    return /*#__PURE__*/react.createElement(component, props);\n  });\n});\n\nif (false) { var refType, toType; }\n\nvar forwardRefShim$1 = function forwardRefShim(C) {\n  return C;\n};\n\nvar forwardRef$1 = react.forwardRef;\n\nif (typeof forwardRef$1 === "undefined") {\n  forwardRef$1 = forwardRefShim$1;\n}\n\nfunction joinClassnames() {\n  for (var _len = arguments.length, classnames = new Array(_len), _key = 0; _key < _len; _key++) {\n    classnames[_key] = arguments[_key];\n  }\n\n  return classnames.filter(function (i) {\n    return i;\n  }).join(" ");\n}\n/**\n * A <Link> wrapper that knows if it\'s "active" or not.\n */\n\n\nvar NavLink = forwardRef$1(function (_ref, forwardedRef) {\n  var _ref$ariaCurrent = _ref["aria-current"],\n      ariaCurrent = _ref$ariaCurrent === void 0 ? "page" : _ref$ariaCurrent,\n      _ref$activeClassName = _ref.activeClassName,\n      activeClassName = _ref$activeClassName === void 0 ? "active" : _ref$activeClassName,\n      activeStyle = _ref.activeStyle,\n      classNameProp = _ref.className,\n      exact = _ref.exact,\n      isActiveProp = _ref.isActive,\n      locationProp = _ref.location,\n      sensitive = _ref.sensitive,\n      strict = _ref.strict,\n      styleProp = _ref.style,\n      to = _ref.to,\n      innerRef = _ref.innerRef,\n      rest = objectWithoutPropertiesLoose_objectWithoutPropertiesLoose(_ref, ["aria-current", "activeClassName", "activeStyle", "className", "exact", "isActive", "location", "sensitive", "strict", "style", "to", "innerRef"]);\n\n  return /*#__PURE__*/react.createElement(context.Consumer, null, function (context) {\n    !context ?  false ? 0 : tiny_invariant_esm(false) : void 0;\n    var currentLocation = locationProp || context.location;\n    var toLocation = normalizeToLocation(resolveToLocation(to, currentLocation), currentLocation);\n    var path = toLocation.pathname; // Regex taken from: https://github.com/pillarjs/path-to-regexp/blob/master/index.js#L202\n\n    var escapedPath = path && path.replace(/([.+*?=^!:${}()[\\]|/\\\\])/g, "\\\\$1");\n    var match = escapedPath ? matchPath(currentLocation.pathname, {\n      path: escapedPath,\n      exact: exact,\n      sensitive: sensitive,\n      strict: strict\n    }) : null;\n    var isActive = !!(isActiveProp ? isActiveProp(match, currentLocation) : match);\n    var className = typeof classNameProp === "function" ? classNameProp(isActive) : classNameProp;\n    var style = typeof styleProp === "function" ? styleProp(isActive) : styleProp;\n\n    if (isActive) {\n      className = joinClassnames(className, activeClassName);\n      style = extends_extends({}, style, activeStyle);\n    }\n\n    var props = extends_extends({\n      "aria-current": isActive && ariaCurrent || null,\n      className: className,\n      style: style,\n      to: toLocation\n    }, rest); // React 15 compat\n\n\n    if (forwardRefShim$1 !== forwardRef$1) {\n      props.ref = forwardedRef || innerRef;\n    } else {\n      props.innerRef = innerRef;\n    }\n\n    return /*#__PURE__*/react.createElement(Link, props);\n  });\n});\n\nif (false) { var ariaCurrentType; }\n\n\n//# sourceMappingURL=react-router-dom.js.map\n\n// EXTERNAL MODULE: ./node_modules/react-dom/index.js\nvar react_dom = __webpack_require__(935);\n// EXTERNAL MODULE: ./node_modules/classnames/index.js\nvar classnames = __webpack_require__(184);\nvar classnames_default = /*#__PURE__*/__webpack_require__.n(classnames);\n;// CONCATENATED MODULE: ./src/component.js\nvar _excluded = ["component", "fallback", "className", "children"];\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = component_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction component_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\nfunction createComponent(_ref, fn) {\n  var displayName = _ref.displayName,\n      propTypes = _ref.propTypes,\n      defaultProps = _ref.defaultProps;\n  var Component = fn.length > 1 ? /*#__PURE__*/forwardRef(fn) : fn;\n  Component.displayName = displayName;\n  Component.propTypes = propTypes;\n  Component.defaultProps = defaultProps;\n  return Component;\n}\nvar Clone = /*#__PURE__*/(0,react.forwardRef)(function Clone(_ref2, ref) {\n  var component = _ref2.component,\n      fallback = _ref2.fallback,\n      className = _ref2.className,\n      _ref2$children = _ref2.children,\n      children = _ref2$children === void 0 ? component : _ref2$children,\n      props = _objectWithoutProperties(_ref2, _excluded);\n\n  if ( /*#__PURE__*/(0,react.isValidElement)(component)) {\n    return /*#__PURE__*/(0,react.cloneElement)(component, _objectSpread({\n      ref: ref,\n      className: classnames_default()(className, component.props.className)\n    }, props));\n  } else if ( /*#__PURE__*/(0,react.isValidElement)(fallback)) {\n    return /*#__PURE__*/(0,react.cloneElement)(fallback, _objectSpread({\n      ref: ref,\n      className: classnames_default()(className, fallback.props.className)\n    }, props));\n  } else if (fallback) {\n    return /*#__PURE__*/(0,react.createElement)(fallback, _objectSpread({\n      ref: ref,\n      className: className\n    }, props), children);\n  } else {\n    return children;\n  }\n});\n\n;// CONCATENATED MODULE: ./src/icon/constants.js\nvar cssClasses = {\n  ROOT: \'mdc-icon\',\n  LIGHT: \'mdc-icon--light\',\n  DARK: \'mdc-icon--dark\',\n  INACTIVE: \'mdc-icon--inactive\'\n};\n// EXTERNAL MODULE: ./node_modules/react/jsx-runtime.js\nvar jsx_runtime = __webpack_require__(893);\n;// CONCATENATED MODULE: ./src/icon/Icon.jsx\nvar Icon_excluded = ["name", "type", "size", "light", "dark", "inactive", "element", "component", "children", "className"];\n\nfunction Icon_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction Icon_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { Icon_ownKeys(Object(source), true).forEach(function (key) { Icon_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { Icon_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction Icon_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction Icon_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = Icon_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction Icon_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\n\nvar Icon = /*#__PURE__*/(0,react.forwardRef)(function (_ref, ref) {\n  var _classnames;\n\n  var name = _ref.name,\n      type = _ref.type,\n      size = _ref.size,\n      _ref$light = _ref.light,\n      light = _ref$light === void 0 ? false : _ref$light,\n      _ref$dark = _ref.dark,\n      dark = _ref$dark === void 0 ? false : _ref$dark,\n      _ref$inactive = _ref.inactive,\n      inactive = _ref$inactive === void 0 ? false : _ref$inactive,\n      _ref$element = _ref.element,\n      element = _ref$element === void 0 ? \'i\' : _ref$element,\n      _ref$component = _ref.component,\n      Element = _ref$component === void 0 ? element : _ref$component,\n      _ref$children = _ref.children,\n      children = _ref$children === void 0 ? name : _ref$children,\n      className = _ref.className,\n      props = Icon_objectWithoutProperties(_ref, Icon_excluded);\n\n  var classNames = classnames_default()(cssClasses.ROOT, (_classnames = {}, Icon_defineProperty(_classnames, "".concat(cssClasses.ROOT, "--").concat(type), type), Icon_defineProperty(_classnames, "".concat(cssClasses.ROOT, "--").concat(size), size), Icon_defineProperty(_classnames, cssClasses.LIGHT, light), Icon_defineProperty(_classnames, cssClasses.DARK, dark), Icon_defineProperty(_classnames, cssClasses.INACTIVE, inactive), _classnames), className);\n  return /*#__PURE__*/(0,jsx_runtime.jsx)(Element, Icon_objectSpread(Icon_objectSpread({\n    ref: ref,\n    className: classNames\n  }, props), {}, {\n    children: children\n  }));\n});\nIcon.displayName = \'MDCIcon\';\nIcon.propTypes = {\n  type: prop_types_default().oneOf([\'\', \'filled\', \'outlined\', \'round\', \'sharp\', \'two-tone\']),\n  size: (prop_types_default()).string,\n  light: (prop_types_default()).bool,\n  dark: (prop_types_default()).bool,\n  inactive: (prop_types_default()).bool\n};\n/* harmony default export */ const icon_Icon = (Icon);\n;// CONCATENATED MODULE: ./src/icon/index.js\n\n;// CONCATENATED MODULE: ./src/avatar/constants.js\nvar constants_cssClasses = {\n  ROOT: \'mdc-avatar\',\n  SMALL: \'mdc-avatar--small\',\n  MEDIUM: \'mdc-avatar--medium\',\n  LARGE: \'mdc-avatar--large\',\n  IMAGE: \'mdc-avatar__image\',\n  ICON: \'mdc-avatar__icon\',\n  TEXT: \'mdc-avatar__text\'\n};\n;// CONCATENATED MODULE: ./src/avatar/Avatar.jsx\nvar Avatar_excluded = ["image", "icon", "text", "size", "element", "component", "className", "children"];\n\nfunction Avatar_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction Avatar_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { Avatar_ownKeys(Object(source), true).forEach(function (key) { Avatar_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { Avatar_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction Avatar_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction Avatar_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = Avatar_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction Avatar_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\n\n\n\n\nvar Avatar = /*#__PURE__*/(0,react.forwardRef)(function (_ref, ref) {\n  var image = _ref.image,\n      icon = _ref.icon,\n      text = _ref.text,\n      size = _ref.size,\n      _ref$element = _ref.element,\n      element = _ref$element === void 0 ? \'span\' : _ref$element,\n      _ref$component = _ref.component,\n      Element = _ref$component === void 0 ? element : _ref$component,\n      className = _ref.className,\n      _ref$children = _ref.children,\n      children = _ref$children === void 0 ? text : _ref$children,\n      props = Avatar_objectWithoutProperties(_ref, Avatar_excluded);\n\n  var classNames = classnames_default()(constants_cssClasses.ROOT, Avatar_defineProperty({}, "".concat(constants_cssClasses.ROOT, "--").concat(size), size), className);\n  return /*#__PURE__*/(0,jsx_runtime.jsxs)(Element, Avatar_objectSpread(Avatar_objectSpread({\n    ref: ref,\n    className: classNames\n  }, props), {}, {\n    children: [image && /*#__PURE__*/(0,jsx_runtime.jsx)("img", {\n      className: constants_cssClasses.IMAGE,\n      src: (image === null || image === void 0 ? void 0 : image.src) || image,\n      alt: (image === null || image === void 0 ? void 0 : image.alt) || \'\'\n    }), icon && /*#__PURE__*/(0,jsx_runtime.jsx)(Clone, {\n      component: icon,\n      fallback: icon_Icon,\n      className: constants_cssClasses.ICON\n    }), children && /*#__PURE__*/(0,jsx_runtime.jsx)(Clone, {\n      component: children,\n      fallback: "span",\n      className: constants_cssClasses.TEXT\n    })]\n  }));\n});\nAvatar.displayName = \'MDCAvatar\';\nAvatar.propTypes = {\n  src: (prop_types_default()).string,\n  icon: (prop_types_default()).node,\n  text: (prop_types_default()).node,\n  size: prop_types_default().oneOf([\'small\', \'medium\', \'large\'])\n};\n/* harmony default export */ const avatar_Avatar = (Avatar);\n;// CONCATENATED MODULE: ./src/avatar/index.js\n\n;// CONCATENATED MODULE: ./src/badge/constants.js\nvar badge_constants_cssClasses = {\n  ROOT: \'mdc-badge\',\n  INSET: \'mdc-badge--inset\',\n  TRANSPARENT: \'mdc-badge--transparent\'\n};\n;// CONCATENATED MODULE: ./src/badge/Badge.jsx\nvar Badge_excluded = ["value", "inset", "transparent", "element", "className"];\n\nfunction Badge_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction Badge_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { Badge_ownKeys(Object(source), true).forEach(function (key) { Badge_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { Badge_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction Badge_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction Badge_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = Badge_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction Badge_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\n\nvar Badge = /*#__PURE__*/(0,react.forwardRef)(function (_ref, ref) {\n  var _classnames;\n\n  var value = _ref.value,\n      _ref$inset = _ref.inset,\n      inset = _ref$inset === void 0 ? false : _ref$inset,\n      _ref$transparent = _ref.transparent,\n      transparent = _ref$transparent === void 0 ? false : _ref$transparent,\n      _ref$element = _ref.element,\n      Element = _ref$element === void 0 ? \'span\' : _ref$element,\n      className = _ref.className,\n      props = Badge_objectWithoutProperties(_ref, Badge_excluded);\n\n  var classNames = classnames_default()(badge_constants_cssClasses.ROOT, (_classnames = {}, Badge_defineProperty(_classnames, badge_constants_cssClasses.INSET, inset), Badge_defineProperty(_classnames, badge_constants_cssClasses.TRANSPARENT, transparent), _classnames), className);\n  return /*#__PURE__*/(0,jsx_runtime.jsx)(Element, Badge_objectSpread({\n    ref: ref,\n    className: classNames,\n    "data-badge": value\n  }, props));\n});\nBadge.displayName = \'MDCBadge\';\nBadge.propTypes = {\n  value: prop_types_default().oneOfType([(prop_types_default()).number, (prop_types_default()).string]).isRequired,\n  inset: (prop_types_default()).bool,\n  transparent: (prop_types_default()).bool\n};\n/* harmony default export */ const badge_Badge = (Badge);\n;// CONCATENATED MODULE: ./src/badge/index.js\n\n;// CONCATENATED MODULE: ./node_modules/dom-helpers/esm/hasClass.js\n/**\n * Checks if a given element has a CSS class.\n * \n * @param element the element\n * @param className the CSS class name\n */\nfunction hasClass(element, className) {\n  if (element.classList) return !!className && element.classList.contains(className);\n  return (" " + (element.className.baseVal || element.className) + " ").indexOf(" " + className + " ") !== -1;\n}\n;// CONCATENATED MODULE: ./node_modules/dom-helpers/esm/addClass.js\n\n/**\n * Adds a CSS class to a given element.\n * \n * @param element the element\n * @param className the CSS class name\n */\n\nfunction addClass_addClass(element, className) {\n  if (element.classList) element.classList.add(className);else if (!hasClass(element, className)) if (typeof element.className === \'string\') element.className = element.className + " " + className;else element.setAttribute(\'class\', (element.className && element.className.baseVal || \'\') + " " + className);\n}\n;// CONCATENATED MODULE: ./node_modules/dom-helpers/esm/removeClass.js\nfunction replaceClassName(origClass, classToRemove) {\n  return origClass.replace(new RegExp("(^|\\\\s)" + classToRemove + "(?:\\\\s|$)", \'g\'), \'$1\').replace(/\\s+/g, \' \').replace(/^\\s*|\\s*$/g, \'\');\n}\n/**\n * Removes a CSS class from a given element.\n * \n * @param element the element\n * @param className the CSS class name\n */\n\n\nfunction removeClass_removeClass(element, className) {\n  if (element.classList) {\n    element.classList.remove(className);\n  } else if (typeof element.className === \'string\') {\n    element.className = replaceClassName(element.className, className);\n  } else {\n    element.setAttribute(\'class\', replaceClassName(element.className && element.className.baseVal || \'\', className));\n  }\n}\n;// CONCATENATED MODULE: ./node_modules/react-transition-group/esm/config.js\n/* harmony default export */ const config = ({\n  disabled: false\n});\n;// CONCATENATED MODULE: ./node_modules/react-transition-group/esm/TransitionGroupContext.js\n\n/* harmony default export */ const TransitionGroupContext = (react.createContext(null));\n;// CONCATENATED MODULE: ./node_modules/react-transition-group/esm/Transition.js\n\n\n\n\n\n\n\n\nvar UNMOUNTED = \'unmounted\';\nvar EXITED = \'exited\';\nvar ENTERING = \'entering\';\nvar ENTERED = \'entered\';\nvar EXITING = \'exiting\';\n/**\n * The Transition component lets you describe a transition from one component\n * state to another _over time_ with a simple declarative API. Most commonly\n * it\'s used to animate the mounting and unmounting of a component, but can also\n * be used to describe in-place transition states as well.\n *\n * ---\n *\n * **Note**: `Transition` is a platform-agnostic base component. If you\'re using\n * transitions in CSS, you\'ll probably want to use\n * [`CSSTransition`](https://reactcommunity.org/react-transition-group/css-transition)\n * instead. It inherits all the features of `Transition`, but contains\n * additional features necessary to play nice with CSS transitions (hence the\n * name of the component).\n *\n * ---\n *\n * By default the `Transition` component does not alter the behavior of the\n * component it renders, it only tracks "enter" and "exit" states for the\n * components. It\'s up to you to give meaning and effect to those states. For\n * example we can add styles to a component when it enters or exits:\n *\n * ```jsx\n * import { Transition } from \'react-transition-group\';\n *\n * const duration = 300;\n *\n * const defaultStyle = {\n *   transition: `opacity ${duration}ms ease-in-out`,\n *   opacity: 0,\n * }\n *\n * const transitionStyles = {\n *   entering: { opacity: 1 },\n *   entered:  { opacity: 1 },\n *   exiting:  { opacity: 0 },\n *   exited:  { opacity: 0 },\n * };\n *\n * const Fade = ({ in: inProp }) => (\n *   <Transition in={inProp} timeout={duration}>\n *     {state => (\n *       <div style={{\n *         ...defaultStyle,\n *         ...transitionStyles[state]\n *       }}>\n *         I\'m a fade Transition!\n *       </div>\n *     )}\n *   </Transition>\n * );\n * ```\n *\n * There are 4 main states a Transition can be in:\n *  - `\'entering\'`\n *  - `\'entered\'`\n *  - `\'exiting\'`\n *  - `\'exited\'`\n *\n * Transition state is toggled via the `in` prop. When `true` the component\n * begins the "Enter" stage. During this stage, the component will shift from\n * its current transition state, to `\'entering\'` for the duration of the\n * transition and then to the `\'entered\'` stage once it\'s complete. Let\'s take\n * the following example (we\'ll use the\n * [useState](https://reactjs.org/docs/hooks-reference.html#usestate) hook):\n *\n * ```jsx\n * function App() {\n *   const [inProp, setInProp] = useState(false);\n *   return (\n *     <div>\n *       <Transition in={inProp} timeout={500}>\n *         {state => (\n *           // ...\n *         )}\n *       </Transition>\n *       <button onClick={() => setInProp(true)}>\n *         Click to Enter\n *       </button>\n *     </div>\n *   );\n * }\n * ```\n *\n * When the button is clicked the component will shift to the `\'entering\'` state\n * and stay there for 500ms (the value of `timeout`) before it finally switches\n * to `\'entered\'`.\n *\n * When `in` is `false` the same thing happens except the state moves from\n * `\'exiting\'` to `\'exited\'`.\n */\n\nvar Transition = /*#__PURE__*/function (_React$Component) {\n  _inheritsLoose(Transition, _React$Component);\n\n  function Transition(props, context) {\n    var _this;\n\n    _this = _React$Component.call(this, props, context) || this;\n    var parentGroup = context; // In the context of a TransitionGroup all enters are really appears\n\n    var appear = parentGroup && !parentGroup.isMounting ? props.enter : props.appear;\n    var initialStatus;\n    _this.appearStatus = null;\n\n    if (props.in) {\n      if (appear) {\n        initialStatus = EXITED;\n        _this.appearStatus = ENTERING;\n      } else {\n        initialStatus = ENTERED;\n      }\n    } else {\n      if (props.unmountOnExit || props.mountOnEnter) {\n        initialStatus = UNMOUNTED;\n      } else {\n        initialStatus = EXITED;\n      }\n    }\n\n    _this.state = {\n      status: initialStatus\n    };\n    _this.nextCallback = null;\n    return _this;\n  }\n\n  Transition.getDerivedStateFromProps = function getDerivedStateFromProps(_ref, prevState) {\n    var nextIn = _ref.in;\n\n    if (nextIn && prevState.status === UNMOUNTED) {\n      return {\n        status: EXITED\n      };\n    }\n\n    return null;\n  } // getSnapshotBeforeUpdate(prevProps) {\n  //   let nextStatus = null\n  //   if (prevProps !== this.props) {\n  //     const { status } = this.state\n  //     if (this.props.in) {\n  //       if (status !== ENTERING && status !== ENTERED) {\n  //         nextStatus = ENTERING\n  //       }\n  //     } else {\n  //       if (status === ENTERING || status === ENTERED) {\n  //         nextStatus = EXITING\n  //       }\n  //     }\n  //   }\n  //   return { nextStatus }\n  // }\n  ;\n\n  var _proto = Transition.prototype;\n\n  _proto.componentDidMount = function componentDidMount() {\n    this.updateStatus(true, this.appearStatus);\n  };\n\n  _proto.componentDidUpdate = function componentDidUpdate(prevProps) {\n    var nextStatus = null;\n\n    if (prevProps !== this.props) {\n      var status = this.state.status;\n\n      if (this.props.in) {\n        if (status !== ENTERING && status !== ENTERED) {\n          nextStatus = ENTERING;\n        }\n      } else {\n        if (status === ENTERING || status === ENTERED) {\n          nextStatus = EXITING;\n        }\n      }\n    }\n\n    this.updateStatus(false, nextStatus);\n  };\n\n  _proto.componentWillUnmount = function componentWillUnmount() {\n    this.cancelNextCallback();\n  };\n\n  _proto.getTimeouts = function getTimeouts() {\n    var timeout = this.props.timeout;\n    var exit, enter, appear;\n    exit = enter = appear = timeout;\n\n    if (timeout != null && typeof timeout !== \'number\') {\n      exit = timeout.exit;\n      enter = timeout.enter; // TODO: remove fallback for next major\n\n      appear = timeout.appear !== undefined ? timeout.appear : enter;\n    }\n\n    return {\n      exit: exit,\n      enter: enter,\n      appear: appear\n    };\n  };\n\n  _proto.updateStatus = function updateStatus(mounting, nextStatus) {\n    if (mounting === void 0) {\n      mounting = false;\n    }\n\n    if (nextStatus !== null) {\n      // nextStatus will always be ENTERING or EXITING.\n      this.cancelNextCallback();\n\n      if (nextStatus === ENTERING) {\n        this.performEnter(mounting);\n      } else {\n        this.performExit();\n      }\n    } else if (this.props.unmountOnExit && this.state.status === EXITED) {\n      this.setState({\n        status: UNMOUNTED\n      });\n    }\n  };\n\n  _proto.performEnter = function performEnter(mounting) {\n    var _this2 = this;\n\n    var enter = this.props.enter;\n    var appearing = this.context ? this.context.isMounting : mounting;\n\n    var _ref2 = this.props.nodeRef ? [appearing] : [react_dom.findDOMNode(this), appearing],\n        maybeNode = _ref2[0],\n        maybeAppearing = _ref2[1];\n\n    var timeouts = this.getTimeouts();\n    var enterTimeout = appearing ? timeouts.appear : timeouts.enter; // no enter animation skip right to ENTERED\n    // if we are mounting and running this it means appear _must_ be set\n\n    if (!mounting && !enter || config.disabled) {\n      this.safeSetState({\n        status: ENTERED\n      }, function () {\n        _this2.props.onEntered(maybeNode);\n      });\n      return;\n    }\n\n    this.props.onEnter(maybeNode, maybeAppearing);\n    this.safeSetState({\n      status: ENTERING\n    }, function () {\n      _this2.props.onEntering(maybeNode, maybeAppearing);\n\n      _this2.onTransitionEnd(enterTimeout, function () {\n        _this2.safeSetState({\n          status: ENTERED\n        }, function () {\n          _this2.props.onEntered(maybeNode, maybeAppearing);\n        });\n      });\n    });\n  };\n\n  _proto.performExit = function performExit() {\n    var _this3 = this;\n\n    var exit = this.props.exit;\n    var timeouts = this.getTimeouts();\n    var maybeNode = this.props.nodeRef ? undefined : react_dom.findDOMNode(this); // no exit animation skip right to EXITED\n\n    if (!exit || config.disabled) {\n      this.safeSetState({\n        status: EXITED\n      }, function () {\n        _this3.props.onExited(maybeNode);\n      });\n      return;\n    }\n\n    this.props.onExit(maybeNode);\n    this.safeSetState({\n      status: EXITING\n    }, function () {\n      _this3.props.onExiting(maybeNode);\n\n      _this3.onTransitionEnd(timeouts.exit, function () {\n        _this3.safeSetState({\n          status: EXITED\n        }, function () {\n          _this3.props.onExited(maybeNode);\n        });\n      });\n    });\n  };\n\n  _proto.cancelNextCallback = function cancelNextCallback() {\n    if (this.nextCallback !== null) {\n      this.nextCallback.cancel();\n      this.nextCallback = null;\n    }\n  };\n\n  _proto.safeSetState = function safeSetState(nextState, callback) {\n    // This shouldn\'t be necessary, but there are weird race conditions with\n    // setState callbacks and unmounting in testing, so always make sure that\n    // we can cancel any pending setState callbacks after we unmount.\n    callback = this.setNextCallback(callback);\n    this.setState(nextState, callback);\n  };\n\n  _proto.setNextCallback = function setNextCallback(callback) {\n    var _this4 = this;\n\n    var active = true;\n\n    this.nextCallback = function (event) {\n      if (active) {\n        active = false;\n        _this4.nextCallback = null;\n        callback(event);\n      }\n    };\n\n    this.nextCallback.cancel = function () {\n      active = false;\n    };\n\n    return this.nextCallback;\n  };\n\n  _proto.onTransitionEnd = function onTransitionEnd(timeout, handler) {\n    this.setNextCallback(handler);\n    var node = this.props.nodeRef ? this.props.nodeRef.current : react_dom.findDOMNode(this);\n    var doesNotHaveTimeoutOrListener = timeout == null && !this.props.addEndListener;\n\n    if (!node || doesNotHaveTimeoutOrListener) {\n      setTimeout(this.nextCallback, 0);\n      return;\n    }\n\n    if (this.props.addEndListener) {\n      var _ref3 = this.props.nodeRef ? [this.nextCallback] : [node, this.nextCallback],\n          maybeNode = _ref3[0],\n          maybeNextCallback = _ref3[1];\n\n      this.props.addEndListener(maybeNode, maybeNextCallback);\n    }\n\n    if (timeout != null) {\n      setTimeout(this.nextCallback, timeout);\n    }\n  };\n\n  _proto.render = function render() {\n    var status = this.state.status;\n\n    if (status === UNMOUNTED) {\n      return null;\n    }\n\n    var _this$props = this.props,\n        children = _this$props.children,\n        _in = _this$props.in,\n        _mountOnEnter = _this$props.mountOnEnter,\n        _unmountOnExit = _this$props.unmountOnExit,\n        _appear = _this$props.appear,\n        _enter = _this$props.enter,\n        _exit = _this$props.exit,\n        _timeout = _this$props.timeout,\n        _addEndListener = _this$props.addEndListener,\n        _onEnter = _this$props.onEnter,\n        _onEntering = _this$props.onEntering,\n        _onEntered = _this$props.onEntered,\n        _onExit = _this$props.onExit,\n        _onExiting = _this$props.onExiting,\n        _onExited = _this$props.onExited,\n        _nodeRef = _this$props.nodeRef,\n        childProps = objectWithoutPropertiesLoose_objectWithoutPropertiesLoose(_this$props, ["children", "in", "mountOnEnter", "unmountOnExit", "appear", "enter", "exit", "timeout", "addEndListener", "onEnter", "onEntering", "onEntered", "onExit", "onExiting", "onExited", "nodeRef"]);\n\n    return (\n      /*#__PURE__*/\n      // allows for nested Transitions\n      react.createElement(TransitionGroupContext.Provider, {\n        value: null\n      }, typeof children === \'function\' ? children(status, childProps) : react.cloneElement(react.Children.only(children), childProps))\n    );\n  };\n\n  return Transition;\n}(react.Component);\n\nTransition.contextType = TransitionGroupContext;\nTransition.propTypes =  false ? 0 : {}; // Name the function so it is clearer in the documentation\n\nfunction Transition_noop() {}\n\nTransition.defaultProps = {\n  in: false,\n  mountOnEnter: false,\n  unmountOnExit: false,\n  appear: false,\n  enter: true,\n  exit: true,\n  onEnter: Transition_noop,\n  onEntering: Transition_noop,\n  onEntered: Transition_noop,\n  onExit: Transition_noop,\n  onExiting: Transition_noop,\n  onExited: Transition_noop\n};\nTransition.UNMOUNTED = UNMOUNTED;\nTransition.EXITED = EXITED;\nTransition.ENTERING = ENTERING;\nTransition.ENTERED = ENTERED;\nTransition.EXITING = EXITING;\n/* harmony default export */ const esm_Transition = (Transition);\n;// CONCATENATED MODULE: ./node_modules/react-transition-group/esm/CSSTransition.js\n\n\n\n\n\n\n\n\n\n\nvar _addClass = function addClass(node, classes) {\n  return node && classes && classes.split(\' \').forEach(function (c) {\n    return addClass_addClass(node, c);\n  });\n};\n\nvar removeClass = function removeClass(node, classes) {\n  return node && classes && classes.split(\' \').forEach(function (c) {\n    return removeClass_removeClass(node, c);\n  });\n};\n/**\n * A transition component inspired by the excellent\n * [ng-animate](https://docs.angularjs.org/api/ngAnimate) library, you should\n * use it if you\'re using CSS transitions or animations. It\'s built upon the\n * [`Transition`](https://reactcommunity.org/react-transition-group/transition)\n * component, so it inherits all of its props.\n *\n * `CSSTransition` applies a pair of class names during the `appear`, `enter`,\n * and `exit` states of the transition. The first class is applied and then a\n * second `*-active` class in order to activate the CSS transition. After the\n * transition, matching `*-done` class names are applied to persist the\n * transition state.\n *\n * ```jsx\n * function App() {\n *   const [inProp, setInProp] = useState(false);\n *   return (\n *     <div>\n *       <CSSTransition in={inProp} timeout={200} classNames="my-node">\n *         <div>\n *           {"I\'ll receive my-node-* classes"}\n *         </div>\n *       </CSSTransition>\n *       <button type="button" onClick={() => setInProp(true)}>\n *         Click to Enter\n *       </button>\n *     </div>\n *   );\n * }\n * ```\n *\n * When the `in` prop is set to `true`, the child component will first receive\n * the class `example-enter`, then the `example-enter-active` will be added in\n * the next tick. `CSSTransition` [forces a\n * reflow](https://github.com/reactjs/react-transition-group/blob/5007303e729a74be66a21c3e2205e4916821524b/src/CSSTransition.js#L208-L215)\n * between before adding the `example-enter-active`. This is an important trick\n * because it allows us to transition between `example-enter` and\n * `example-enter-active` even though they were added immediately one after\n * another. Most notably, this is what makes it possible for us to animate\n * _appearance_.\n *\n * ```css\n * .my-node-enter {\n *   opacity: 0;\n * }\n * .my-node-enter-active {\n *   opacity: 1;\n *   transition: opacity 200ms;\n * }\n * .my-node-exit {\n *   opacity: 1;\n * }\n * .my-node-exit-active {\n *   opacity: 0;\n *   transition: opacity 200ms;\n * }\n * ```\n *\n * `*-active` classes represent which styles you want to animate **to**, so it\'s\n * important to add `transition` declaration only to them, otherwise transitions\n * might not behave as intended! This might not be obvious when the transitions\n * are symmetrical, i.e. when `*-enter-active` is the same as `*-exit`, like in\n * the example above (minus `transition`), but it becomes apparent in more\n * complex transitions.\n *\n * **Note**: If you\'re using the\n * [`appear`](http://reactcommunity.org/react-transition-group/transition#Transition-prop-appear)\n * prop, make sure to define styles for `.appear-*` classes as well.\n */\n\n\nvar CSSTransition = /*#__PURE__*/function (_React$Component) {\n  _inheritsLoose(CSSTransition, _React$Component);\n\n  function CSSTransition() {\n    var _this;\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;\n    _this.appliedClasses = {\n      appear: {},\n      enter: {},\n      exit: {}\n    };\n\n    _this.onEnter = function (maybeNode, maybeAppearing) {\n      var _this$resolveArgument = _this.resolveArguments(maybeNode, maybeAppearing),\n          node = _this$resolveArgument[0],\n          appearing = _this$resolveArgument[1];\n\n      _this.removeClasses(node, \'exit\');\n\n      _this.addClass(node, appearing ? \'appear\' : \'enter\', \'base\');\n\n      if (_this.props.onEnter) {\n        _this.props.onEnter(maybeNode, maybeAppearing);\n      }\n    };\n\n    _this.onEntering = function (maybeNode, maybeAppearing) {\n      var _this$resolveArgument2 = _this.resolveArguments(maybeNode, maybeAppearing),\n          node = _this$resolveArgument2[0],\n          appearing = _this$resolveArgument2[1];\n\n      var type = appearing ? \'appear\' : \'enter\';\n\n      _this.addClass(node, type, \'active\');\n\n      if (_this.props.onEntering) {\n        _this.props.onEntering(maybeNode, maybeAppearing);\n      }\n    };\n\n    _this.onEntered = function (maybeNode, maybeAppearing) {\n      var _this$resolveArgument3 = _this.resolveArguments(maybeNode, maybeAppearing),\n          node = _this$resolveArgument3[0],\n          appearing = _this$resolveArgument3[1];\n\n      var type = appearing ? \'appear\' : \'enter\';\n\n      _this.removeClasses(node, type);\n\n      _this.addClass(node, type, \'done\');\n\n      if (_this.props.onEntered) {\n        _this.props.onEntered(maybeNode, maybeAppearing);\n      }\n    };\n\n    _this.onExit = function (maybeNode) {\n      var _this$resolveArgument4 = _this.resolveArguments(maybeNode),\n          node = _this$resolveArgument4[0];\n\n      _this.removeClasses(node, \'appear\');\n\n      _this.removeClasses(node, \'enter\');\n\n      _this.addClass(node, \'exit\', \'base\');\n\n      if (_this.props.onExit) {\n        _this.props.onExit(maybeNode);\n      }\n    };\n\n    _this.onExiting = function (maybeNode) {\n      var _this$resolveArgument5 = _this.resolveArguments(maybeNode),\n          node = _this$resolveArgument5[0];\n\n      _this.addClass(node, \'exit\', \'active\');\n\n      if (_this.props.onExiting) {\n        _this.props.onExiting(maybeNode);\n      }\n    };\n\n    _this.onExited = function (maybeNode) {\n      var _this$resolveArgument6 = _this.resolveArguments(maybeNode),\n          node = _this$resolveArgument6[0];\n\n      _this.removeClasses(node, \'exit\');\n\n      _this.addClass(node, \'exit\', \'done\');\n\n      if (_this.props.onExited) {\n        _this.props.onExited(maybeNode);\n      }\n    };\n\n    _this.resolveArguments = function (maybeNode, maybeAppearing) {\n      return _this.props.nodeRef ? [_this.props.nodeRef.current, maybeNode] // here `maybeNode` is actually `appearing`\n      : [maybeNode, maybeAppearing];\n    };\n\n    _this.getClassNames = function (type) {\n      var classNames = _this.props.classNames;\n      var isStringClassNames = typeof classNames === \'string\';\n      var prefix = isStringClassNames && classNames ? classNames + "-" : \'\';\n      var baseClassName = isStringClassNames ? "" + prefix + type : classNames[type];\n      var activeClassName = isStringClassNames ? baseClassName + "-active" : classNames[type + "Active"];\n      var doneClassName = isStringClassNames ? baseClassName + "-done" : classNames[type + "Done"];\n      return {\n        baseClassName: baseClassName,\n        activeClassName: activeClassName,\n        doneClassName: doneClassName\n      };\n    };\n\n    return _this;\n  }\n\n  var _proto = CSSTransition.prototype;\n\n  _proto.addClass = function addClass(node, type, phase) {\n    var className = this.getClassNames(type)[phase + "ClassName"];\n\n    var _this$getClassNames = this.getClassNames(\'enter\'),\n        doneClassName = _this$getClassNames.doneClassName;\n\n    if (type === \'appear\' && phase === \'done\' && doneClassName) {\n      className += " " + doneClassName;\n    } // This is to force a repaint,\n    // which is necessary in order to transition styles when adding a class name.\n\n\n    if (phase === \'active\') {\n      /* eslint-disable no-unused-expressions */\n      node && node.scrollTop;\n    }\n\n    if (className) {\n      this.appliedClasses[type][phase] = className;\n\n      _addClass(node, className);\n    }\n  };\n\n  _proto.removeClasses = function removeClasses(node, type) {\n    var _this$appliedClasses$ = this.appliedClasses[type],\n        baseClassName = _this$appliedClasses$.base,\n        activeClassName = _this$appliedClasses$.active,\n        doneClassName = _this$appliedClasses$.done;\n    this.appliedClasses[type] = {};\n\n    if (baseClassName) {\n      removeClass(node, baseClassName);\n    }\n\n    if (activeClassName) {\n      removeClass(node, activeClassName);\n    }\n\n    if (doneClassName) {\n      removeClass(node, doneClassName);\n    }\n  };\n\n  _proto.render = function render() {\n    var _this$props = this.props,\n        _ = _this$props.classNames,\n        props = objectWithoutPropertiesLoose_objectWithoutPropertiesLoose(_this$props, ["classNames"]);\n\n    return /*#__PURE__*/react.createElement(esm_Transition, extends_extends({}, props, {\n      onEnter: this.onEnter,\n      onEntered: this.onEntered,\n      onEntering: this.onEntering,\n      onExit: this.onExit,\n      onExiting: this.onExiting,\n      onExited: this.onExited\n    }));\n  };\n\n  return CSSTransition;\n}(react.Component);\n\nCSSTransition.defaultProps = {\n  classNames: \'\'\n};\nCSSTransition.propTypes =  false ? 0 : {};\n/* harmony default export */ const esm_CSSTransition = (CSSTransition);\n;// CONCATENATED MODULE: ./src/banner/constants.js\nvar numbers = {\n  BANNER_ANIMATION_CLOSE_TIME_MS: 250,\n  BANNER_ANIMATION_OPEN_TIME_MS: 300\n};\nvar banner_constants_cssClasses = {\n  ROOT: \'mdc-banner\',\n  FIXED: \'mdc-banner--fixed\',\n  CENTERED: \'mdc-banner--centered\',\n  MOBILE_STACKED: \'mdc-banner--mobile-stacked\',\n  APPEARING: \'mdc-banner--appearing\',\n  APPEARED: \'mdc-banner--appeared\',\n  OPENING: \'mdc-banner--opening\',\n  OPEN: \'mdc-banner--open\',\n  CLOSING: \'mdc-banner--closing\',\n  CONTENT: \'mdc-banner__content\',\n  GRAPHIC_TEXT_WRAPPER: \'mdc-banner__graphic-text-wrapper\',\n  GRAPHIC: \'mdc-banner__graphic\',\n  ICON: \'mdc-banner__icon\',\n  TEXT: \'mdc-banner__text\',\n  ACTIONS: \'mdc-banner__actions\',\n  PRIMARY_ACTION: \'mdc-banner__primary-action\',\n  SECONDARY_ACTION: \'mdc-banner__secondary-action\'\n};\n;// CONCATENATED MODULE: ./src/banner/Banner.jsx\nvar Banner_excluded = ["text", "icon", "graphic", "action", "primaryAction", "secondaryAction", "open", "centered", "fixed", "mobileStacked", "element", "component", "className", "children"];\n\nfunction Banner_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction Banner_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { Banner_ownKeys(Object(source), true).forEach(function (key) { Banner_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { Banner_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction Banner_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction Banner_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = Banner_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction Banner_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\n\n\n\n\n\nvar Banner = /*#__PURE__*/(0,react.forwardRef)(function (_ref, ref) {\n  var _classnames;\n\n  var text = _ref.text,\n      icon = _ref.icon,\n      _ref$graphic = _ref.graphic,\n      graphic = _ref$graphic === void 0 ? icon : _ref$graphic,\n      action = _ref.action,\n      _ref$primaryAction = _ref.primaryAction,\n      primaryAction = _ref$primaryAction === void 0 ? action : _ref$primaryAction,\n      secondaryAction = _ref.secondaryAction,\n      _ref$open = _ref.open,\n      open = _ref$open === void 0 ? false : _ref$open,\n      _ref$centered = _ref.centered,\n      centered = _ref$centered === void 0 ? false : _ref$centered,\n      _ref$fixed = _ref.fixed,\n      fixed = _ref$fixed === void 0 ? false : _ref$fixed,\n      _ref$mobileStacked = _ref.mobileStacked,\n      mobileStacked = _ref$mobileStacked === void 0 ? false : _ref$mobileStacked,\n      _ref$element = _ref.element,\n      element = _ref$element === void 0 ? \'div\' : _ref$element,\n      _ref$component = _ref.component,\n      Element = _ref$component === void 0 ? element : _ref$component,\n      className = _ref.className,\n      _ref$children = _ref.children,\n      children = _ref$children === void 0 ? text : _ref$children,\n      props = Banner_objectWithoutProperties(_ref, Banner_excluded);\n\n  var rootRef = (0,react.useRef)();\n  var contentRef = (0,react.useRef)();\n  (0,react.useImperativeHandle)(ref, function () {\n    return rootRef.current;\n  });\n  var handleEntering = (0,react.useCallback)(function (node, isAppearing) {\n    if (!isAppearing) {\n      node.style.height = "".concat(contentRef.current.offsetHeight, "px");\n    }\n  }, []);\n  var handleExiting = (0,react.useCallback)(function (node) {\n    node.style.height = \'0px\';\n  }, []);\n  var classNames = classnames_default()(banner_constants_cssClasses.ROOT, (_classnames = {}, Banner_defineProperty(_classnames, banner_constants_cssClasses.FIXED, fixed), Banner_defineProperty(_classnames, banner_constants_cssClasses.CENTERED, centered), Banner_defineProperty(_classnames, banner_constants_cssClasses.MOBILE_STACKED, mobileStacked), _classnames), className);\n\n  var content = /*#__PURE__*/(0,jsx_runtime.jsxs)("div", {\n    ref: contentRef,\n    className: banner_constants_cssClasses.CONTENT,\n    role: "status",\n    children: [/*#__PURE__*/(0,jsx_runtime.jsxs)("div", {\n      className: banner_constants_cssClasses.GRAPHIC_TEXT_WRAPPER,\n      children: [graphic && /*#__PURE__*/(0,jsx_runtime.jsx)("div", {\n        className: banner_constants_cssClasses.GRAPHIC,\n        children: /*#__PURE__*/(0,jsx_runtime.jsx)(Clone, {\n          component: graphic,\n          fallback: icon_Icon,\n          className: banner_constants_cssClasses.ICON\n        })\n      }), /*#__PURE__*/(0,jsx_runtime.jsx)(Clone, {\n        component: children,\n        fallback: "div",\n        className: banner_constants_cssClasses.TEXT\n      })]\n    }), primaryAction && /*#__PURE__*/(0,jsx_runtime.jsxs)("div", {\n      className: banner_constants_cssClasses.ACTIONS,\n      children: [secondaryAction && /*#__PURE__*/(0,jsx_runtime.jsx)(Clone, {\n        component: secondaryAction,\n        className: banner_constants_cssClasses.SECONDARY_ACTION\n      }), /*#__PURE__*/(0,jsx_runtime.jsx)(Clone, {\n        component: primaryAction,\n        className: banner_constants_cssClasses.PRIMARY_ACTION\n      })]\n    })]\n  });\n\n  return /*#__PURE__*/(0,jsx_runtime.jsx)(esm_CSSTransition, {\n    "in": open,\n    appear: open,\n    timeout: {\n      appear: 0,\n      enter: numbers.BANNER_ANIMATION_OPEN_TIME_MS,\n      exit: numbers.BANNER_ANIMATION_CLOSE_TIME_MS\n    },\n    classNames: {\n      appear: banner_constants_cssClasses.APPEARING,\n      appearDone: banner_constants_cssClasses.APPEARED,\n      enter: banner_constants_cssClasses.OPENING,\n      enterActive: banner_constants_cssClasses.OPEN,\n      enterDone: banner_constants_cssClasses.OPEN,\n      exit: banner_constants_cssClasses.CLOSING\n    },\n    mountOnEnter: true,\n    unmountOnExit: true,\n    onEntering: handleEntering,\n    onExiting: handleExiting,\n    children: /*#__PURE__*/(0,jsx_runtime.jsx)(Element, Banner_objectSpread(Banner_objectSpread({\n      ref: rootRef,\n      className: classNames,\n      role: "banner"\n    }, props), {}, {\n      children: content\n    }))\n  });\n});\nBanner.displayName = \'MDCBanner\';\nBanner.propTypes = {\n  text: (prop_types_default()).node.isRequired,\n  icon: (prop_types_default()).node,\n  graphic: (prop_types_default()).element,\n  action: (prop_types_default()).element,\n  primaryAction: (prop_types_default()).element,\n  secondaryAction: (prop_types_default()).element,\n  open: (prop_types_default()).bool,\n  appear: (prop_types_default()).bool,\n  fixed: (prop_types_default()).bool,\n  centered: (prop_types_default()).bool,\n  mobileStacked: (prop_types_default()).bool\n};\n/* harmony default export */ const banner_Banner = (Banner);\n;// CONCATENATED MODULE: ./src/banner/index.js\n\n;// CONCATENATED MODULE: ./src/button/constants.js\nvar button_constants_cssClasses = {\n  ROOT: \'mdc-button\',\n  RAISED: \'mdc-button--raised\',\n  UNELEVATED: \'mdc-button--unelevated\',\n  OUTLINED: \'mdc-button--outlined\',\n  TOUCH: \'mdc-button--touch\',\n  ICON_LEADING: \'mdc-button--icon-leading\',\n  ICON_TRAILING: \'mdc-button--icon-trailing\',\n  RIPPLE: \'mdc-button__ripple\',\n  ICON: \'mdc-button__icon\',\n  LABEL: \'mdc-button__label\',\n  TOUCH_ELEMENT: \'mdc-button__touch\'\n};\n;// CONCATENATED MODULE: ./src/button/Button.jsx\nvar Button_excluded = ["label", "icon", "leadingIcon", "trailingIcon", "raised", "unelevated", "outlined", "touch", "element", "component", "className", "children"];\n\nfunction Button_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction Button_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { Button_ownKeys(Object(source), true).forEach(function (key) { Button_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { Button_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction Button_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction Button_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = Button_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction Button_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\n\n\n\n\nvar Button = /*#__PURE__*/(0,react.forwardRef)(function (_ref, ref) {\n  var _classnames;\n\n  var label = _ref.label,\n      icon = _ref.icon,\n      _ref$leadingIcon = _ref.leadingIcon,\n      leadingIcon = _ref$leadingIcon === void 0 ? icon : _ref$leadingIcon,\n      trailingIcon = _ref.trailingIcon,\n      _ref$raised = _ref.raised,\n      raised = _ref$raised === void 0 ? false : _ref$raised,\n      _ref$unelevated = _ref.unelevated,\n      unelevated = _ref$unelevated === void 0 ? false : _ref$unelevated,\n      _ref$outlined = _ref.outlined,\n      outlined = _ref$outlined === void 0 ? false : _ref$outlined,\n      _ref$touch = _ref.touch,\n      touch = _ref$touch === void 0 ? false : _ref$touch,\n      _ref$element = _ref.element,\n      element = _ref$element === void 0 ? \'button\' : _ref$element,\n      _ref$component = _ref.component,\n      Element = _ref$component === void 0 ? element : _ref$component,\n      className = _ref.className,\n      _ref$children = _ref.children,\n      children = _ref$children === void 0 ? label : _ref$children,\n      props = Button_objectWithoutProperties(_ref, Button_excluded);\n\n  var classNames = classnames_default()(button_constants_cssClasses.ROOT, (_classnames = {}, Button_defineProperty(_classnames, button_constants_cssClasses.RAISED, raised), Button_defineProperty(_classnames, button_constants_cssClasses.UNELEVATED, unelevated), Button_defineProperty(_classnames, button_constants_cssClasses.OUTLINED, outlined), Button_defineProperty(_classnames, button_constants_cssClasses.TOUCH, touch), Button_defineProperty(_classnames, button_constants_cssClasses.ICON_LEADING, Boolean(leadingIcon)), Button_defineProperty(_classnames, button_constants_cssClasses.ICON_TRAILING, Boolean(trailingIcon)), _classnames), className);\n  return /*#__PURE__*/(0,jsx_runtime.jsxs)(Element, Button_objectSpread(Button_objectSpread({\n    ref: ref,\n    className: classNames\n  }, props), {}, {\n    children: [/*#__PURE__*/(0,jsx_runtime.jsx)("span", {\n      className: button_constants_cssClasses.RIPPLE\n    }), touch && /*#__PURE__*/(0,jsx_runtime.jsx)("span", {\n      className: button_constants_cssClasses.TOUCH_ELEMENT\n    }), leadingIcon && /*#__PURE__*/(0,jsx_runtime.jsx)(Clone, {\n      component: leadingIcon,\n      fallback: icon_Icon,\n      className: button_constants_cssClasses.ICON,\n      "aria-hidden": "true"\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)("span", {\n      className: button_constants_cssClasses.LABEL,\n      children: children\n    }), trailingIcon && /*#__PURE__*/(0,jsx_runtime.jsx)(Clone, {\n      component: trailingIcon,\n      fallback: icon_Icon,\n      className: button_constants_cssClasses.ICON,\n      "aria-hidden": "true"\n    })]\n  }));\n});\nButton.displayName = \'MDCButton\';\nButton.propTypes = {\n  label: (prop_types_default()).node,\n  icon: (prop_types_default()).node,\n  leadingIcon: (prop_types_default()).node,\n  trailingIcon: (prop_types_default()).node,\n  raised: (prop_types_default()).bool,\n  unelevated: (prop_types_default()).bool,\n  outlined: (prop_types_default()).bool,\n  touch: (prop_types_default()).bool\n};\n/* harmony default export */ const button_Button = (Button);\n;// CONCATENATED MODULE: ./src/button/index.js\n\n;// CONCATENATED MODULE: ./src/card/constants.js\nvar card_constants_cssClasses = {\n  ROOT: \'mdc-card\',\n  OUTLINED: \'mdc-card--outlined\',\n  TITLE: \'mdc-card__title\',\n  SUBTITLE: \'mdc-card__subtitle\',\n  OVERLINE: \'mdc-card__overline\',\n  ACTIONS: \'mdc-card__actions\',\n  ACTIONS_FULL_BLEED: \'mdc-card__actions--full-bleed\',\n  ACTION_BUTTONS: \'mdc-card__action-buttons\',\n  ACTION_ICONS: \'mdc-card__action-icons\',\n  ACTION: \'mdc-card__action\',\n  ACTION_BUTTON: \'mdc-card__action--button\',\n  ACTION_ICON: \'mdc-card__action--icon\',\n  CONTENT: \'mdc-card__content\',\n  HEADER: \'mdc-card__header\',\n  HEADER_GRAPHIC: \'mdc-card__header__graphic\',\n  HEADER_CONTENT: \'mdc-card__header__content\',\n  HEADER_ACTIONS: \'mdc-card__header__actions\',\n  MEDIA: \'mdc-card__media\',\n  MEDIA_SQUARE: \'mdc-card__media--square\',\n  MEDIA_WIDE: \'mdc-card__media--16-9\',\n  MEDIA_CONTENT: \'mdc-card__media-content\',\n  PRIMARY_ACTION: \'mdc-card__primary-action\',\n  SECTION: \'mdc-card__section\',\n  SECTION_PRIMARY: \'mdc-card__section--primary\',\n  SECTION_SECONDARY: \'mdc-card__section--secondary\',\n  RIPPLE: \'mdc-card__ripple\'\n};\n;// CONCATENATED MODULE: ./src/card/Card.jsx\nvar Card_excluded = ["outlined", "element", "component", "className"];\n\nfunction Card_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction Card_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { Card_ownKeys(Object(source), true).forEach(function (key) { Card_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { Card_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction Card_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction Card_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = Card_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction Card_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\n\nvar Card = /*#__PURE__*/(0,react.forwardRef)(function (_ref, ref) {\n  var _ref$outlined = _ref.outlined,\n      outlined = _ref$outlined === void 0 ? false : _ref$outlined,\n      _ref$element = _ref.element,\n      element = _ref$element === void 0 ? \'div\' : _ref$element,\n      _ref$component = _ref.component,\n      Element = _ref$component === void 0 ? element : _ref$component,\n      className = _ref.className,\n      props = Card_objectWithoutProperties(_ref, Card_excluded);\n\n  var classNames = classnames_default()(card_constants_cssClasses.ROOT, Card_defineProperty({}, card_constants_cssClasses.OUTLINED, outlined), className);\n  return /*#__PURE__*/(0,jsx_runtime.jsx)(Element, Card_objectSpread({\n    ref: ref,\n    className: classNames\n  }, props));\n});\nCard.displayName = \'MDCCard\';\nCard.propTypes = {\n  outlined: (prop_types_default()).bool\n};\n/* harmony default export */ const card_Card = (Card);\n;// CONCATENATED MODULE: ./src/card/CardAction.jsx\nvar CardAction_excluded = ["button", "icon", "component", "className", "children"];\n\nfunction CardAction_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction CardAction_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { CardAction_ownKeys(Object(source), true).forEach(function (key) { CardAction_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { CardAction_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction CardAction_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction CardAction_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = CardAction_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction CardAction_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\n\nfunction CardAction(_ref) {\n  var _classnames;\n\n  var _ref$button = _ref.button,\n      button = _ref$button === void 0 ? false : _ref$button,\n      _ref$icon = _ref.icon,\n      icon = _ref$icon === void 0 ? false : _ref$icon,\n      component = _ref.component,\n      className = _ref.className,\n      _ref$children = _ref.children,\n      children = _ref$children === void 0 ? component : _ref$children,\n      props = CardAction_objectWithoutProperties(_ref, CardAction_excluded);\n\n  var classNames = classnames_default()(card_constants_cssClasses.ACTION, (_classnames = {}, CardAction_defineProperty(_classnames, card_constants_cssClasses.ACTION_BUTTON, button), CardAction_defineProperty(_classnames, card_constants_cssClasses.ACTION_ICON, icon), _classnames), className);\n  return /*#__PURE__*/(0,jsx_runtime.jsx)(Clone, CardAction_objectSpread({\n    component: children,\n    className: classNames\n  }, props));\n}\nCardAction.displayName = \'MDCCardAction\';\nCardAction.propTypes = {\n  button: (prop_types_default()).bool,\n  icon: (prop_types_default()).bool\n};\n;// CONCATENATED MODULE: ./src/card/CardActions.jsx\nvar CardActions_excluded = ["fullBleed", "element", "className"];\n\nfunction CardActions_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction CardActions_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { CardActions_ownKeys(Object(source), true).forEach(function (key) { CardActions_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { CardActions_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction CardActions_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction CardActions_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = CardActions_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction CardActions_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\n\nvar CardActions = /*#__PURE__*/(0,react.forwardRef)(function (_ref, ref) {\n  var _ref$fullBleed = _ref.fullBleed,\n      fullBleed = _ref$fullBleed === void 0 ? false : _ref$fullBleed,\n      _ref$element = _ref.element,\n      Element = _ref$element === void 0 ? \'div\' : _ref$element,\n      className = _ref.className,\n      props = CardActions_objectWithoutProperties(_ref, CardActions_excluded);\n\n  var classNames = classnames_default()(card_constants_cssClasses.ACTIONS, CardActions_defineProperty({}, card_constants_cssClasses.ACTIONS_FULL_BLEED, fullBleed), className);\n  return /*#__PURE__*/(0,jsx_runtime.jsx)(Element, CardActions_objectSpread({\n    ref: ref,\n    className: classNames\n  }, props));\n});\nCardActions.displayName = \'MDCCardActions\';\nCardActions.propTypes = {\n  fullBleed: (prop_types_default()).bool\n};\n/* harmony default export */ const card_CardActions = (CardActions);\n;// CONCATENATED MODULE: ./src/card/CardActionButtons.jsx\nvar CardActionButtons_excluded = ["element", "component", "className", "children"];\n\nfunction CardActionButtons_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction CardActionButtons_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { CardActionButtons_ownKeys(Object(source), true).forEach(function (key) { CardActionButtons_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { CardActionButtons_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction CardActionButtons_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction CardActionButtons_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = CardActionButtons_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction CardActionButtons_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\n\nvar CardActionButtons = /*#__PURE__*/(0,react.forwardRef)(function (_ref, ref) {\n  var _ref$element = _ref.element,\n      element = _ref$element === void 0 ? \'div\' : _ref$element,\n      _ref$component = _ref.component,\n      Element = _ref$component === void 0 ? element : _ref$component,\n      className = _ref.className,\n      children = _ref.children,\n      props = CardActionButtons_objectWithoutProperties(_ref, CardActionButtons_excluded);\n\n  var classNames = classnames_default()(card_constants_cssClasses.ACTION_BUTTONS, className);\n  return /*#__PURE__*/(0,jsx_runtime.jsx)(Element, CardActionButtons_objectSpread(CardActionButtons_objectSpread({\n    ref: ref,\n    className: classNames\n  }, props), {}, {\n    children: /*#__PURE__*/(0,jsx_runtime.jsx)(Clone, {\n      component: children,\n      className: "".concat(card_constants_cssClasses.ACTION, " ").concat(card_constants_cssClasses.ACTION_BUTTON)\n    })\n  }));\n});\nCardActionButtons.displayName = \'MDCCardActionButtons\';\n/* harmony default export */ const card_CardActionButtons = (CardActionButtons);\n;// CONCATENATED MODULE: ./src/card/CardActionIcons.jsx\nvar CardActionIcons_excluded = ["element", "component", "className", "children"];\n\nfunction CardActionIcons_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction CardActionIcons_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { CardActionIcons_ownKeys(Object(source), true).forEach(function (key) { CardActionIcons_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { CardActionIcons_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction CardActionIcons_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction CardActionIcons_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = CardActionIcons_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction CardActionIcons_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\n\nvar CardActionIcons = /*#__PURE__*/(0,react.forwardRef)(function (_ref, ref) {\n  var _ref$element = _ref.element,\n      element = _ref$element === void 0 ? \'div\' : _ref$element,\n      _ref$component = _ref.component,\n      Element = _ref$component === void 0 ? element : _ref$component,\n      className = _ref.className,\n      children = _ref.children,\n      props = CardActionIcons_objectWithoutProperties(_ref, CardActionIcons_excluded);\n\n  var classNames = classnames_default()(card_constants_cssClasses.ACTION_ICONS, className);\n  return /*#__PURE__*/(0,jsx_runtime.jsx)(Element, CardActionIcons_objectSpread(CardActionIcons_objectSpread({\n    ref: ref,\n    className: classNames\n  }, props), {}, {\n    children: /*#__PURE__*/(0,jsx_runtime.jsx)(Clone, {\n      component: children,\n      className: "".concat(card_constants_cssClasses.ACTION, " ").concat(card_constants_cssClasses.ACTION_ICON)\n    })\n  }));\n});\nCardActionIcons.displayName = \'MDCCardActionIcons\';\n/* harmony default export */ const card_CardActionIcons = (CardActionIcons);\n;// CONCATENATED MODULE: ./src/card/CardHeader.jsx\nvar CardHeader_excluded = ["title", "subtitle", "overline", "graphic", "actions", "element", "component", "className", "children"];\n\nfunction CardHeader_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction CardHeader_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { CardHeader_ownKeys(Object(source), true).forEach(function (key) { CardHeader_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { CardHeader_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction CardHeader_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction CardHeader_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = CardHeader_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction CardHeader_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\n\n\n\nvar CardHeader = /*#__PURE__*/(0,react.forwardRef)(function (_ref, ref) {\n  var title = _ref.title,\n      subtitle = _ref.subtitle,\n      overline = _ref.overline,\n      graphic = _ref.graphic,\n      actions = _ref.actions,\n      _ref$element = _ref.element,\n      element = _ref$element === void 0 ? \'div\' : _ref$element,\n      _ref$component = _ref.component,\n      Element = _ref$component === void 0 ? element : _ref$component,\n      className = _ref.className,\n      children = _ref.children,\n      props = CardHeader_objectWithoutProperties(_ref, CardHeader_excluded);\n\n  var classNames = classnames_default()(card_constants_cssClasses.HEADER, className);\n  return /*#__PURE__*/(0,jsx_runtime.jsxs)(Element, CardHeader_objectSpread(CardHeader_objectSpread({\n    ref: ref,\n    className: classNames\n  }, props), {}, {\n    children: [graphic && /*#__PURE__*/(0,jsx_runtime.jsx)(Clone, {\n      component: graphic,\n      className: card_constants_cssClasses.HEADER_GRAPHIC\n    }), /*#__PURE__*/(0,jsx_runtime.jsxs)("div", {\n      className: card_constants_cssClasses.HEADER_CONTENT,\n      children: [overline && /*#__PURE__*/(0,jsx_runtime.jsx)(Clone, {\n        component: overline,\n        fallback: "span",\n        className: card_constants_cssClasses.OVERLINE\n      }), title && /*#__PURE__*/(0,jsx_runtime.jsx)(Clone, {\n        component: title,\n        fallback: "h2",\n        className: card_constants_cssClasses.TITLE\n      }), subtitle && /*#__PURE__*/(0,jsx_runtime.jsx)(Clone, {\n        component: subtitle,\n        fallback: "h3",\n        className: card_constants_cssClasses.SUBTITLE\n      }), children]\n    }), actions && /*#__PURE__*/(0,jsx_runtime.jsx)("div", {\n      className: card_constants_cssClasses.HEADER_ACTIONS,\n      children: react.Children.map(actions, function (action) {\n        return /*#__PURE__*/(0,jsx_runtime.jsx)(Clone, {\n          component: action,\n          className: card_constants_cssClasses.ACTION\n        });\n      })\n    })]\n  }));\n});\nCardHeader.displayName = \'MDCCardHeader\';\nCardHeader.propTypes = {\n  title: (prop_types_default()).node,\n  subtitle: (prop_types_default()).node,\n  overline: (prop_types_default()).node,\n  graphic: (prop_types_default()).element,\n  actions: prop_types_default().oneOfType([(prop_types_default()).element, prop_types_default().arrayOf((prop_types_default()).element)])\n};\n/* harmony default export */ const card_CardHeader = (CardHeader);\n;// CONCATENATED MODULE: ./src/card/CardMedia.jsx\nvar CardMedia_excluded = ["imageUrl", "content", "square", "wide", "element", "component", "className", "children"];\n\nfunction CardMedia_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction CardMedia_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { CardMedia_ownKeys(Object(source), true).forEach(function (key) { CardMedia_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { CardMedia_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction CardMedia_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction CardMedia_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = CardMedia_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction CardMedia_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\n\nvar CardMedia = /*#__PURE__*/(0,react.forwardRef)(function (_ref, ref) {\n  var _classnames;\n\n  var imageUrl = _ref.imageUrl,\n      content = _ref.content,\n      _ref$square = _ref.square,\n      square = _ref$square === void 0 ? false : _ref$square,\n      _ref$wide = _ref.wide,\n      wide = _ref$wide === void 0 ? false : _ref$wide,\n      _ref$element = _ref.element,\n      element = _ref$element === void 0 ? \'div\' : _ref$element,\n      _ref$component = _ref.component,\n      Element = _ref$component === void 0 ? element : _ref$component,\n      className = _ref.className,\n      _ref$children = _ref.children,\n      children = _ref$children === void 0 ? content : _ref$children,\n      props = CardMedia_objectWithoutProperties(_ref, CardMedia_excluded);\n\n  var classNames = classnames_default()(card_constants_cssClasses.MEDIA, (_classnames = {}, CardMedia_defineProperty(_classnames, card_constants_cssClasses.MEDIA_SQUARE, square), CardMedia_defineProperty(_classnames, card_constants_cssClasses.MEDIA_WIDE, wide), _classnames), className);\n  var style = imageUrl ? {\n    backgroundImage: "url(".concat(imageUrl, ")")\n  } : undefined;\n  return /*#__PURE__*/(0,jsx_runtime.jsx)(Element, CardMedia_objectSpread(CardMedia_objectSpread({\n    ref: ref,\n    className: classNames,\n    style: style\n  }, props), {}, {\n    children: children && /*#__PURE__*/(0,jsx_runtime.jsx)("div", {\n      className: card_constants_cssClasses.MEDIA_CONTENT,\n      children: children\n    })\n  }));\n});\nCardMedia.displayName = \'MDCCardMedia\';\nCardMedia.propTypes = {\n  imageUrl: (prop_types_default()).string,\n  content: (prop_types_default()).node,\n  square: (prop_types_default()).bool,\n  wide: (prop_types_default()).bool\n};\n/* harmony default export */ const card_CardMedia = (CardMedia);\n;// CONCATENATED MODULE: ./src/card/CardPrimaryAction.jsx\nvar CardPrimaryAction_excluded = ["element", "component", "className", "children"];\n\nfunction CardPrimaryAction_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction CardPrimaryAction_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { CardPrimaryAction_ownKeys(Object(source), true).forEach(function (key) { CardPrimaryAction_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { CardPrimaryAction_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction CardPrimaryAction_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction CardPrimaryAction_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = CardPrimaryAction_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction CardPrimaryAction_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\n\nvar CardPrimaryAction = /*#__PURE__*/(0,react.forwardRef)(function (_ref, ref) {\n  var _ref$element = _ref.element,\n      element = _ref$element === void 0 ? \'div\' : _ref$element,\n      _ref$component = _ref.component,\n      Element = _ref$component === void 0 ? element : _ref$component,\n      className = _ref.className,\n      children = _ref.children,\n      props = CardPrimaryAction_objectWithoutProperties(_ref, CardPrimaryAction_excluded);\n\n  var classNames = classnames_default()(card_constants_cssClasses.PRIMARY_ACTION, className);\n  return /*#__PURE__*/(0,jsx_runtime.jsxs)(Element, CardPrimaryAction_objectSpread(CardPrimaryAction_objectSpread({\n    ref: ref,\n    className: classNames,\n    tabIndex: "0"\n  }, props), {}, {\n    children: [children, /*#__PURE__*/(0,jsx_runtime.jsx)("div", {\n      className: card_constants_cssClasses.RIPPLE\n    })]\n  }));\n});\nCardPrimaryAction.displayName = \'MDCCardPrimaryAction\';\n/* harmony default export */ const card_CardPrimaryAction = (CardPrimaryAction);\n;// CONCATENATED MODULE: ./src/card/CardSection.jsx\nvar CardSection_excluded = ["primary", "secondary", "element", "component", "className"];\n\nfunction CardSection_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction CardSection_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { CardSection_ownKeys(Object(source), true).forEach(function (key) { CardSection_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { CardSection_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction CardSection_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction CardSection_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = CardSection_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction CardSection_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\n\nvar CardSection = /*#__PURE__*/(0,react.forwardRef)(function (_ref, ref) {\n  var _classnames;\n\n  var _ref$primary = _ref.primary,\n      primary = _ref$primary === void 0 ? false : _ref$primary,\n      _ref$secondary = _ref.secondary,\n      secondary = _ref$secondary === void 0 ? false : _ref$secondary,\n      _ref$element = _ref.element,\n      element = _ref$element === void 0 ? \'div\' : _ref$element,\n      _ref$component = _ref.component,\n      Element = _ref$component === void 0 ? element : _ref$component,\n      className = _ref.className,\n      props = CardSection_objectWithoutProperties(_ref, CardSection_excluded);\n\n  var classNames = classnames_default()(card_constants_cssClasses.SECTION, (_classnames = {}, CardSection_defineProperty(_classnames, card_constants_cssClasses.SECTION_PRIMARY, primary), CardSection_defineProperty(_classnames, card_constants_cssClasses.SECTION_SECONDARY, secondary), _classnames), className);\n  return /*#__PURE__*/(0,jsx_runtime.jsx)(Element, CardSection_objectSpread({\n    ref: ref,\n    className: classNames\n  }, props));\n});\nCardSection.displayName = \'MDCCardSection\';\nCardSection.propTypes = {\n  primary: (prop_types_default()).bool,\n  secondary: (prop_types_default()).bool\n};\n/* harmony default export */ const card_CardSection = (CardSection);\n;// CONCATENATED MODULE: ./src/card/index.js\n\n\n\n\n\n\n\n\n\ncard_Card.Action = CardAction;\ncard_Card.Actions = card_CardActions;\ncard_Card.ActionButtons = card_CardActionButtons;\ncard_Card.ActionIcons = card_CardActionIcons;\ncard_Card.Header = card_CardHeader;\ncard_Card.Media = card_CardMedia;\ncard_Card.PrimaryAction = card_CardPrimaryAction;\ncard_Card.Section = card_CardSection;\n\n;// CONCATENATED MODULE: ./src/checkbox/constants.js\nvar checkbox_constants_cssClasses = {\n  ROOT: \'mdc-checkbox\',\n  SELECTED: \'mdc-checkbox--selected\',\n  TOUCH: \'mdc-checkbox--touch\',\n  DISABLED: \'mdc-checkbox--disabled\',\n  ANIM_CHECKED_INDETERMINATE: \'mdc-checkbox--anim-checked-indeterminate\',\n  ANIM_CHECKED_UNCHECKED: \'mdc-checkbox--anim-checked-unchecked\',\n  ANIM_INDETERMINATE_CHECKED: \'mdc-checkbox--anim-indeterminate-checked\',\n  ANIM_INDETERMINATE_UNCHECKED: \'mdc-checkbox--anim-indeterminate-unchecked\',\n  ANIM_UNCHECKED_CHECKED: \'mdc-checkbox--anim-unchecked-checked\',\n  ANIM_UNCHECKED_INDETERMINATE: \'mdc-checkbox--anim-unchecked-indeterminate\',\n  NATIVE_CONTROL: \'mdc-checkbox__native-control\',\n  BACKGROUND: \'mdc-checkbox__background\',\n  CHECKMARK: \'mdc-checkbox__checkmark\',\n  CHECKMARK_PATH: \'mdc-checkbox__checkmark-path\',\n  MIXEDMARK: \'mdc-checkbox__mixedmark\',\n  RIPPLE: \'mdc-checkbox__ripple\'\n};\n;// CONCATENATED MODULE: ./src/checkbox/Checkbox.jsx\nvar Checkbox_excluded = ["checked", "indeterminate", "disabled", "touch", "onChange", "className"];\n\nfunction Checkbox_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction Checkbox_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { Checkbox_ownKeys(Object(source), true).forEach(function (key) { Checkbox_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { Checkbox_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction Checkbox_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction Checkbox_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = Checkbox_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction Checkbox_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\n\n\nvar Checkbox = /*#__PURE__*/(0,react.forwardRef)(function (_ref, ref) {\n  var _classnames;\n\n  var checked = _ref.checked,\n      indeterminate = _ref.indeterminate,\n      _ref$disabled = _ref.disabled,\n      disabled = _ref$disabled === void 0 ? false : _ref$disabled,\n      _ref$touch = _ref.touch,\n      touch = _ref$touch === void 0 ? false : _ref$touch,\n      _ref$onChange = _ref.onChange,\n      onChange = _ref$onChange === void 0 ? Function.prototype : _ref$onChange,\n      className = _ref.className,\n      props = Checkbox_objectWithoutProperties(_ref, Checkbox_excluded);\n\n  var inputRef = (0,react.useRef)();\n  (0,react.useEffect)(function () {\n    inputRef.current.indeterminate = indeterminate;\n  }, [indeterminate]);\n  var handleChange = (0,react.useCallback)(function (event) {\n    onChange(event, event.target.checked, event.target);\n  }, [onChange]);\n  var classNames = classnames_default()(checkbox_constants_cssClasses.ROOT, (_classnames = {}, Checkbox_defineProperty(_classnames, checkbox_constants_cssClasses.SELECTED, checked), Checkbox_defineProperty(_classnames, checkbox_constants_cssClasses.DISABLED, disabled), Checkbox_defineProperty(_classnames, checkbox_constants_cssClasses.TOUCH, touch), _classnames), className);\n  return /*#__PURE__*/(0,jsx_runtime.jsxs)("div", {\n    ref: ref,\n    className: classNames,\n    children: [/*#__PURE__*/(0,jsx_runtime.jsx)("input", Checkbox_objectSpread({\n      ref: inputRef,\n      className: checkbox_constants_cssClasses.NATIVE_CONTROL,\n      type: "checkbox",\n      checked: checked,\n      disabled: disabled,\n      onChange: handleChange\n    }, props)), /*#__PURE__*/(0,jsx_runtime.jsxs)("div", {\n      className: checkbox_constants_cssClasses.BACKGROUND,\n      children: [/*#__PURE__*/(0,jsx_runtime.jsx)("svg", {\n        className: checkbox_constants_cssClasses.CHECKMARK,\n        viewBox: "0 0 24 24",\n        children: /*#__PURE__*/(0,jsx_runtime.jsx)("path", {\n          className: checkbox_constants_cssClasses.CHECKMARK_PATH,\n          fill: "none",\n          d: "M1.73,12.91 8.1,19.28 22.79,4.59"\n        })\n      }), /*#__PURE__*/(0,jsx_runtime.jsx)("div", {\n        className: checkbox_constants_cssClasses.MIXEDMARK\n      })]\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)("div", {\n      className: checkbox_constants_cssClasses.RIPPLE\n    })]\n  });\n});\nCheckbox.displayName = \'MDCCheckbox\';\nCheckbox.propTypes = {\n  checked: (prop_types_default()).bool,\n  indeterminate: (prop_types_default()).bool,\n  disabled: (prop_types_default()).bool,\n  touch: (prop_types_default()).bool,\n  onChange: (prop_types_default()).func\n};\n/* harmony default export */ const checkbox_Checkbox = (Checkbox);\n;// CONCATENATED MODULE: ./src/checkbox/index.js\n\n;// CONCATENATED MODULE: ./src/chips/constants.js\nvar constants_numbers = {\n  SELECTING_ANIMATION_MS: 150,\n  DESELECTING_ANIMATION_MS: 100\n};\nvar chipSetCssClasses = {\n  ROOT: \'mdc-evolution-chip-set\',\n  OVERFLOW: \'mdc-evolution-chip-set--overflow\',\n  CHIPS: \'mdc-evolution-chip-set__chips\'\n};\nvar chipCssClasses = {\n  ROOT: \'mdc-evolution-chip\',\n  FILTER: \'mdc-evolution-chip--filter\',\n  SELECTABLE: \'mdc-evolution-chip--selectable\',\n  SELECTED: \'mdc-evolution-chip--selected\',\n  SELECTING: \'mdc-evolution-chip--selecting\',\n  SELECTING_WITH_PRIMARY_ICON: \'mdc-evolution-chip--selecting-with-primary-icon\',\n  DESELECTING: \'mdc-evolution-chip--deselecting\',\n  DESELECTING_WITH_PRIMARY_ICON: \'mdc-evolution-chip--deselecting-with-primary-icon\',\n  OUTLINED: \'mdc-evolution-chip--outlined\',\n  ENTER: \'mdc-evolution-chip--enter\',\n  EXIT: \'mdc-evolution-chip--exit\',\n  HIDDEN: \'mdc-evolution-chip--hidden\',\n  DISABLED: \'mdc-evolution-chip--disabled\',\n  TOUCH: \'mdc-evolution-chip--touch\',\n  WITH_PRIMARY_GRAPHIC: \'mdc-evolution-chip--with-primary-graphic\',\n  WITH_PRIMARY_ICON: \'mdc-evolution-chip--with-primary-icon\',\n  WITH_TRAILING_ACTION: \'mdc-evolution-chip--with-trailing-action\',\n  WITH_AVATAR: \'mdc-evolution-chip--with-avatar\',\n  CELL: \'mdc-evolution-chip__cell\',\n  PRIMARY_CELL: \'mdc-evolution-chip__cell--primary\',\n  TRAILING_CELL: \'mdc-evolution-chip__cell--trailing\',\n  ACTION: \'mdc-evolution-chip__action\',\n  PRIMARY_ACTION: \'mdc-evolution-chip__action--primary\',\n  TRAILING_ACTION: \'mdc-evolution-chip__action--trailing\',\n  PRESENTATIONAL_ACTION: \'mdc-evolution-chip__action--presentational\',\n  ACTION_TOUCH: \'mdc-evolution-chip__action-touch\',\n  RIPPLE: \'mdc-evolution-chip__ripple\',\n  PRIMARY_RIPPLE: \'mdc-evolution-chip__ripple--primary\',\n  TRAILING_RIPPLE: \'mdc-evolution-chip__ripple--trailing\',\n  GRAPHIC: \'mdc-evolution-chip__graphic\',\n  ICON: \'mdc-evolution-chip__icon\',\n  PRIMARY_ICON: \'mdc-evolution-chip__icon--primary\',\n  TRAILING_ICON: \'mdc-evolution-chip__icon--trailing\',\n  TEXT_LABEL: \'mdc-evolution-chip__text-label\',\n  CHECKMARK: \'mdc-evolution-chip__checkmark\',\n  CHECKMARK_SVG: \'mdc-evolution-chip__checkmark-svg\',\n  CHECKMARK_PATH: \'mdc-evolution-chip__checkmark-path\'\n};\n;// CONCATENATED MODULE: ./src/chips/ChipPrimaryAction.jsx\nvar ChipPrimaryAction_excluded = ["text", "graphic", "icon", "presentational", "selectable", "selected", "disabled", "element", "component", "children"];\n\nfunction ChipPrimaryAction_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction ChipPrimaryAction_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ChipPrimaryAction_ownKeys(Object(source), true).forEach(function (key) { ChipPrimaryAction_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ChipPrimaryAction_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction ChipPrimaryAction_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction ChipPrimaryAction_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = ChipPrimaryAction_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction ChipPrimaryAction_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\n\n\nfunction ChipPrimaryAction(_ref) {\n  var text = _ref.text,\n      graphic = _ref.graphic,\n      icon = _ref.icon,\n      _ref$presentational = _ref.presentational,\n      presentational = _ref$presentational === void 0 ? false : _ref$presentational,\n      _ref$selectable = _ref.selectable,\n      selectable = _ref$selectable === void 0 ? false : _ref$selectable,\n      _ref$selected = _ref.selected,\n      selected = _ref$selected === void 0 ? false : _ref$selected,\n      _ref$disabled = _ref.disabled,\n      disabled = _ref$disabled === void 0 ? false : _ref$disabled,\n      _ref$element = _ref.element,\n      element = _ref$element === void 0 ? \'button\' : _ref$element,\n      _ref$component = _ref.component,\n      Element = _ref$component === void 0 ? element : _ref$component,\n      _ref$children = _ref.children,\n      children = _ref$children === void 0 ? text : _ref$children,\n      props = ChipPrimaryAction_objectWithoutProperties(_ref, ChipPrimaryAction_excluded);\n\n  var isButton = Element === \'button\';\n  var classNames = classnames_default()(chipCssClasses.ACTION, chipCssClasses.PRIMARY_ACTION, ChipPrimaryAction_defineProperty({}, chipCssClasses.PRESENTATIONAL_ACTION, presentational));\n  return /*#__PURE__*/(0,jsx_runtime.jsxs)(Element, ChipPrimaryAction_objectSpread(ChipPrimaryAction_objectSpread({\n    className: classNames,\n    type: isButton ? \'button\' : undefined,\n    disabled: isButton && disabled,\n    tabIndex: disabled ? \'-1\' : \'0\',\n    role: !isButton ? \'option\' : undefined,\n    "aria-selected": !isButton ? selected : undefined,\n    "aria-disabled": !isButton ? disabled : undefined\n  }, props), {}, {\n    children: [/*#__PURE__*/(0,jsx_runtime.jsx)("span", {\n      className: "".concat(chipCssClasses.RIPPLE, " ").concat(chipCssClasses.PRIMARY_RIPPLE)\n    }), (graphic || icon || selectable) && /*#__PURE__*/(0,jsx_runtime.jsxs)("span", {\n      className: chipCssClasses.GRAPHIC,\n      children: [graphic, icon && /*#__PURE__*/(0,jsx_runtime.jsx)(Clone, {\n        component: icon,\n        fallback: icon_Icon,\n        className: "".concat(chipCssClasses.ICON, " ").concat(chipCssClasses.PRIMARY_ICON)\n      }), selectable && /*#__PURE__*/(0,jsx_runtime.jsx)("span", {\n        className: chipCssClasses.CHECKMARK,\n        children: /*#__PURE__*/(0,jsx_runtime.jsx)("svg", {\n          className: chipCssClasses.CHECKMARK_SVG,\n          viewBox: "-2 -3 30 30",\n          children: /*#__PURE__*/(0,jsx_runtime.jsx)("path", {\n            className: chipCssClasses.CHECKMARK_PATH,\n            fill: "none",\n            stroke: "black",\n            d: "M1.73,12.91 8.1,19.28 22.79,4.59"\n          })\n        })\n      })]\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)("span", {\n      className: chipCssClasses.TEXT_LABEL,\n      children: children\n    })]\n  }));\n}\n;// CONCATENATED MODULE: ./src/chips/ChipTrailingAction.jsx\nvar ChipTrailingAction_excluded = ["icon", "presentational"];\n\nfunction ChipTrailingAction_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction ChipTrailingAction_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ChipTrailingAction_ownKeys(Object(source), true).forEach(function (key) { ChipTrailingAction_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ChipTrailingAction_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction ChipTrailingAction_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction ChipTrailingAction_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = ChipTrailingAction_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction ChipTrailingAction_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\n\n\nfunction ChipTrailingAction(_ref) {\n  var icon = _ref.icon,\n      _ref$presentational = _ref.presentational,\n      presentational = _ref$presentational === void 0 ? false : _ref$presentational,\n      props = ChipTrailingAction_objectWithoutProperties(_ref, ChipTrailingAction_excluded);\n\n  var classNames = classnames_default()(chipCssClasses.ACTION, chipCssClasses.TRAILING_ACTION, ChipTrailingAction_defineProperty({}, chipCssClasses.PRESENTATIONAL_ACTION, presentational));\n  return /*#__PURE__*/(0,jsx_runtime.jsxs)("button", ChipTrailingAction_objectSpread(ChipTrailingAction_objectSpread({\n    className: classNames,\n    type: "button",\n    tabIndex: "-1",\n    "aria-hidden": "true"\n  }, props), {}, {\n    children: [/*#__PURE__*/(0,jsx_runtime.jsx)("span", {\n      className: "".concat(chipCssClasses.RIPPLE, " ").concat(chipCssClasses.TRAILING_RIPPLE)\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Clone, {\n      component: icon,\n      fallback: icon_Icon,\n      className: "".concat(chipCssClasses.ICON, " ").concat(chipCssClasses.TRAILING_ICON)\n    })]\n  }));\n}\n;// CONCATENATED MODULE: ./src/chips/Chip.jsx\nvar Chip_excluded = ["value", "text", "icon", "avatar", "graphic", "primaryIcon", "trailingIcon", "selectable", "filter", "selected", "outlined", "disabled", "touch", "withAvatar", "element", "component", "className"];\n\nfunction Chip_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction Chip_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { Chip_ownKeys(Object(source), true).forEach(function (key) { Chip_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { Chip_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction Chip_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction Chip_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = Chip_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction Chip_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\n\n\n\n\n\n\nvar Chip = /*#__PURE__*/(0,react.forwardRef)(function (_ref, ref) {\n  var _classnames;\n\n  var value = _ref.value,\n      text = _ref.text,\n      icon = _ref.icon,\n      avatar = _ref.avatar,\n      _ref$graphic = _ref.graphic,\n      graphic = _ref$graphic === void 0 ? avatar : _ref$graphic,\n      _ref$primaryIcon = _ref.primaryIcon,\n      primaryIcon = _ref$primaryIcon === void 0 ? icon : _ref$primaryIcon,\n      trailingIcon = _ref.trailingIcon,\n      _ref$selectable = _ref.selectable,\n      selectable = _ref$selectable === void 0 ? false : _ref$selectable,\n      _ref$filter = _ref.filter,\n      filter = _ref$filter === void 0 ? false : _ref$filter,\n      _ref$selected = _ref.selected,\n      selected = _ref$selected === void 0 ? false : _ref$selected,\n      _ref$outlined = _ref.outlined,\n      outlined = _ref$outlined === void 0 ? false : _ref$outlined,\n      _ref$disabled = _ref.disabled,\n      disabled = _ref$disabled === void 0 ? false : _ref$disabled,\n      _ref$touch = _ref.touch,\n      touch = _ref$touch === void 0 ? false : _ref$touch,\n      _ref$withAvatar = _ref.withAvatar,\n      withAvatar = _ref$withAvatar === void 0 ? Boolean(avatar) : _ref$withAvatar,\n      _ref$element = _ref.element,\n      element = _ref$element === void 0 ? \'span\' : _ref$element,\n      _ref$component = _ref.component,\n      Element = _ref$component === void 0 ? element : _ref$component,\n      className = _ref.className,\n      props = Chip_objectWithoutProperties(_ref, Chip_excluded);\n\n  var withPrimaryGraphic = selectable || Boolean(graphic) || Boolean(primaryIcon);\n  var withPrimaryIcon = Boolean(primaryIcon);\n  var withTrailingAction = Boolean(trailingIcon);\n  var classNames = classnames_default()(chipCssClasses.ROOT, (_classnames = {}, Chip_defineProperty(_classnames, chipCssClasses.SELECTABLE, selectable), Chip_defineProperty(_classnames, chipCssClasses.FILTER, filter), Chip_defineProperty(_classnames, chipCssClasses.OUTLINED, outlined), Chip_defineProperty(_classnames, chipCssClasses.DISABLED, disabled), Chip_defineProperty(_classnames, chipCssClasses.TOUCH, touch), Chip_defineProperty(_classnames, chipCssClasses.WITH_PRIMARY_GRAPHIC, withPrimaryGraphic), Chip_defineProperty(_classnames, chipCssClasses.WITH_PRIMARY_ICON, withPrimaryIcon), Chip_defineProperty(_classnames, chipCssClasses.WITH_TRAILING_ACTION, withTrailingAction), Chip_defineProperty(_classnames, chipCssClasses.WITH_AVATAR, withAvatar), _classnames), className);\n  var selectingClass = withPrimaryIcon ? chipCssClasses.SELECTING_WITH_PRIMARY_ICON : chipCssClasses.SELECTING;\n  var deselectingClass = withPrimaryIcon ? chipCssClasses.DESELECTING_WITH_PRIMARY_ICON : chipCssClasses.DESELECTING;\n  return /*#__PURE__*/(0,jsx_runtime.jsx)(esm_CSSTransition, {\n    "in": selected,\n    appear: true,\n    timeout: {\n      enter: constants_numbers.SELECTING_ANIMATION_MS,\n      exit: constants_numbers.DESELECTING_ANIMATION_MS\n    },\n    classNames: {\n      enter: selectingClass,\n      enterActive: "".concat(chipCssClasses.SELECTED, " ").concat(selectingClass),\n      enterDone: chipCssClasses.SELECTED,\n      exit: deselectingClass,\n      exitActive: deselectingClass\n    },\n    children: /*#__PURE__*/(0,jsx_runtime.jsx)(Element, Chip_objectSpread(Chip_objectSpread({\n      ref: ref,\n      className: classNames,\n      "data-value": value,\n      role: selectable ? \'presentation\' : \'row\'\n    }, props), {}, {\n      children: selectable ? /*#__PURE__*/(0,jsx_runtime.jsx)(ChipPrimaryAction, {\n        element: "span",\n        text: text,\n        graphic: graphic,\n        icon: primaryIcon,\n        selectable: selectable,\n        selected: selected,\n        disabled: disabled\n      }) : /*#__PURE__*/(0,jsx_runtime.jsxs)(jsx_runtime.Fragment, {\n        children: [/*#__PURE__*/(0,jsx_runtime.jsx)("span", {\n          className: "".concat(chipCssClasses.CELL, " ").concat(chipCssClasses.PRIMARY_CELL),\n          role: "gridcell",\n          children: /*#__PURE__*/(0,jsx_runtime.jsx)(ChipPrimaryAction, {\n            text: text,\n            graphic: graphic,\n            icon: primaryIcon,\n            disabled: disabled\n          })\n        }), trailingIcon && /*#__PURE__*/(0,jsx_runtime.jsx)("span", {\n          className: "".concat(chipCssClasses.CELL, " ").concat(chipCssClasses.TRAILING_CELL),\n          role: "gridcell",\n          children: /*#__PURE__*/(0,jsx_runtime.jsx)(ChipTrailingAction, {\n            icon: trailingIcon,\n            disabled: disabled\n          })\n        })]\n      })\n    }))\n  });\n});\nChip.displayName = \'MDCChip\';\nChip.propTypes = {\n  value: (prop_types_default()).any,\n  text: (prop_types_default()).node,\n  leadingIcon: (prop_types_default()).node,\n  trailingIcon: (prop_types_default()).node,\n  selected: (prop_types_default()).bool,\n  outlined: (prop_types_default()).bool,\n  onClick: (prop_types_default()).func\n};\n/* harmony default export */ const chips_Chip = (Chip);\n;// CONCATENATED MODULE: ./src/types.js\nfunction _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }\n\nfunction isUndefined(value) {\n  return value === undefined;\n}\nfunction isNull(value) {\n  return value === null;\n}\nfunction isBoolean(value) {\n  return typeof value === \'boolean\';\n}\nfunction isNumber(value) {\n  return typeof value === \'number\';\n}\nfunction isString(value) {\n  return typeof value === \'string\';\n}\nfunction isArray(value) {\n  return Array.isArray(value);\n}\nfunction isObject(value) {\n  return _typeof(value) === \'object\' && !isNull(value) && !isArray(value);\n}\n;// CONCATENATED MODULE: ./src/chips/ChipSet.jsx\nvar ChipSet_excluded = ["value", "chips", "input", "choice", "filter", "overflow", "onChange", "element", "component", "className", "children"];\n\nfunction ChipSet_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction ChipSet_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ChipSet_ownKeys(Object(source), true).forEach(function (key) { ChipSet_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ChipSet_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction ChipSet_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction ChipSet_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = ChipSet_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction ChipSet_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\n\n\n\n\nvar ChipSet = /*#__PURE__*/(0,react.forwardRef)(function (_ref, ref) {\n  var value = _ref.value,\n      chips = _ref.chips,\n      _ref$input = _ref.input,\n      input = _ref$input === void 0 ? false : _ref$input,\n      _ref$choice = _ref.choice,\n      choice = _ref$choice === void 0 ? !input && !isUndefined(value) && !isArray(value) : _ref$choice,\n      _ref$filter = _ref.filter,\n      filter = _ref$filter === void 0 ? !input && !isUndefined(value) && isArray(value) : _ref$filter,\n      _ref$overflow = _ref.overflow,\n      overflow = _ref$overflow === void 0 ? false : _ref$overflow,\n      _ref$onChange = _ref.onChange,\n      onChange = _ref$onChange === void 0 ? Function.prototype : _ref$onChange,\n      _ref$element = _ref.element,\n      element = _ref$element === void 0 ? \'div\' : _ref$element,\n      _ref$component = _ref.component,\n      Element = _ref$component === void 0 ? element : _ref$component,\n      className = _ref.className,\n      _ref$children = _ref.children,\n      children = _ref$children === void 0 ? chips === null || chips === void 0 ? void 0 : chips.map(function (chip) {\n    return (0,react.createElement)(chips_Chip, chip);\n  }) : _ref$children,\n      props = ChipSet_objectWithoutProperties(_ref, ChipSet_excluded);\n\n  var handleClick = (0,react.useCallback)(function (event) {\n    var chipValue = event.currentTarget.dataset.value;\n    var newValue = choice ? chipValue : value.includes(chipValue) ? value.filter(function (v) {\n      return v !== chipValue;\n    }) : value.concat(chipValue);\n    onChange(newValue);\n  }, [value, choice, onChange]);\n  var classNames = classnames_default()(chipSetCssClasses.ROOT, ChipSet_defineProperty({}, chipSetCssClasses.OVERFLOW, overflow), className);\n  return /*#__PURE__*/(0,jsx_runtime.jsx)(Element, ChipSet_objectSpread(ChipSet_objectSpread({\n    ref: ref,\n    className: classNames,\n    role: filter ? \'listbox\' : \'grid\'\n  }, props), {}, {\n    children: /*#__PURE__*/(0,jsx_runtime.jsx)("div", {\n      className: chipSetCssClasses.CHIPS,\n      role: "presentation",\n      children: isUndefined(value) ? children : react.Children.map(children, function (chip) {\n        var chipValue = chip.props.value;\n        return (0,react.cloneElement)(chip, {\n          selectable: true,\n          selected: choice ? value === chipValue : value.includes(chipValue),\n          onClickCapture: choice || filter ? handleClick : undefined\n        });\n      })\n    })\n  }));\n});\nChipSet.displayName = \'MDCChipSet\';\nChipSet.propTypes = {\n  value: (prop_types_default()).any,\n  input: (prop_types_default()).bool,\n  choice: (prop_types_default()).bool,\n  filter: (prop_types_default()).bool,\n  overflow: (prop_types_default()).bool,\n  onChange: (prop_types_default()).func\n};\n/* harmony default export */ const chips_ChipSet = (ChipSet);\n;// CONCATENATED MODULE: ./src/chips/index.js\n\n\nchips_Chip.Set = chips_ChipSet;\n\n;// CONCATENATED MODULE: ./src/circular-progress/constants.js\nvar strings = {\n  XMLNS: \'http://www.w3.org/2000/svg\'\n};\nvar sizeProps = {\n  large: {\n    viewBox: 48,\n    radius: 18,\n    strokeWidth: 4,\n    gapPatchStrokeWidth: 3.2,\n    strokeDasharray: 113.097,\n    indeterminateStrokeDashoffset: 56.549\n  },\n  medium: {\n    viewBox: 32,\n    radius: 12.5,\n    strokeWidth: 3,\n    gapPatchStrokeWidth: 2.4,\n    strokeDasharray: 78.54,\n    indeterminateStrokeDashoffset: 39.27\n  },\n  small: {\n    viewBox: 24,\n    radius: 8.75,\n    strokeWidth: 2.5,\n    gapPatchStrokeWidth: 2,\n    strokeDasharray: 54.978,\n    indeterminateStrokeDashoffset: 27.489\n  }\n};\nvar circular_progress_constants_cssClasses = {\n  ROOT: \'mdc-circular-progress\',\n  SMALL: \'mdc-circular-progress--small\',\n  MEDIUM: \'mdc-circular-progress--medium\',\n  LARGE: \'mdc-circular-progress--large\',\n  INDETERMINATE: \'mdc-circular-progress--indeterminate\',\n  CLOSED: \'mdc-circular-progress--closed\',\n  DETERMINATE_CONTAINER: \'mdc-circular-progress__determinate-container\',\n  DETERMINATE_CIRCLE_GRAPHIC: \'mdc-circular-progress__determinate-circle-graphic\',\n  DETERMINATE_TRACK: \'mdc-circular-progress__determinate-track\',\n  DETERMINATE_CIRCLE: \'mdc-circular-progress__determinate-circle\',\n  INDETERMINATE_CONTAINER: \'mdc-circular-progress__indeterminate-container\',\n  INDETERMINATE_CIRCLE_GRAPHIC: \'mdc-circular-progress__indeterminate-circle-graphic\',\n  SPINNER_LAYER: \'mdc-circular-progress__spinner-layer\',\n  COLOR: \'mdc-circular-progress__color\',\n  CIRCLE_CLIPPER: \'mdc-circular-progress__circle-clipper\',\n  CIRCLE_LEFT: \'mdc-circular-progress__circle-left\',\n  CIRCLE_RIGHT: \'mdc-circular-progress__circle-right\',\n  GAP_PATCH: \'mdc-circular-progress__gap-patch\'\n};\nvar Size = {\n  LARGE: \'large\',\n  MEDIUM: \'medium\',\n  SMALL: \'small\'\n};\n;// CONCATENATED MODULE: ./src/circular-progress/CircularProgress.jsx\nvar CircularProgress_excluded = ["value", "size", "indeterminate", "closed", "colorful", "className"];\n\nfunction CircularProgress_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction CircularProgress_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { CircularProgress_ownKeys(Object(source), true).forEach(function (key) { CircularProgress_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { CircularProgress_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction CircularProgress_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction CircularProgress_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = CircularProgress_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction CircularProgress_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\n\n\nvar CircularProgress = /*#__PURE__*/(0,react.forwardRef)(function (_ref, ref) {\n  var _classnames;\n\n  var _ref$value = _ref.value,\n      value = _ref$value === void 0 ? 0 : _ref$value,\n      _ref$size = _ref.size,\n      size = _ref$size === void 0 ? Size.MEDIUM : _ref$size,\n      _ref$indeterminate = _ref.indeterminate,\n      indeterminate = _ref$indeterminate === void 0 ? false : _ref$indeterminate,\n      _ref$closed = _ref.closed,\n      closed = _ref$closed === void 0 ? false : _ref$closed,\n      _ref$colorful = _ref.colorful,\n      colorful = _ref$colorful === void 0 ? false : _ref$colorful,\n      className = _ref.className,\n      props = CircularProgress_objectWithoutProperties(_ref, CircularProgress_excluded);\n\n  var classNames = classnames_default()(circular_progress_constants_cssClasses.ROOT, (_classnames = {}, CircularProgress_defineProperty(_classnames, "".concat(circular_progress_constants_cssClasses.ROOT, "--").concat(size), size), CircularProgress_defineProperty(_classnames, circular_progress_constants_cssClasses.INDETERMINATE, indeterminate), CircularProgress_defineProperty(_classnames, circular_progress_constants_cssClasses.CLOSED, closed), _classnames), className);\n  var _sizeProps$size = sizeProps[size],\n      viewBox = _sizeProps$size.viewBox,\n      radius = _sizeProps$size.radius,\n      strokeDasharray = _sizeProps$size.strokeDasharray,\n      strokeWidth = _sizeProps$size.strokeWidth,\n      gapPatchStrokeWidth = _sizeProps$size.gapPatchStrokeWidth,\n      indeterminateStrokeDashoffset = _sizeProps$size.indeterminateStrokeDashoffset;\n  var progress = value > 1 ? value / 100 : Number(value);\n  var cx = viewBox / 2,\n      cy = viewBox / 2;\n  var strokeDashoffset = 2 * Math.PI * radius * (1 - progress);\n  return /*#__PURE__*/(0,jsx_runtime.jsxs)("div", CircularProgress_objectSpread(CircularProgress_objectSpread({\n    ref: ref,\n    className: classNames,\n    role: "progressbar",\n    "aria-valuemin": 0,\n    "aria-valuemax": 1,\n    "aria-valuenow": progress\n  }, props), {}, {\n    children: [!indeterminate && /*#__PURE__*/(0,jsx_runtime.jsx)("div", {\n      className: circular_progress_constants_cssClasses.DETERMINATE_CONTAINER,\n      children: /*#__PURE__*/(0,jsx_runtime.jsxs)("svg", {\n        className: circular_progress_constants_cssClasses.DETERMINATE_CIRCLE_GRAPHIC,\n        viewBox: "0 0 ".concat(viewBox, " ").concat(viewBox),\n        xmlns: strings.XMLNS,\n        children: [/*#__PURE__*/(0,jsx_runtime.jsx)("circle", {\n          className: circular_progress_constants_cssClasses.DETERMINATE_TRACK,\n          cx: cx,\n          cy: cy,\n          r: radius,\n          strokeWidth: strokeWidth\n        }), /*#__PURE__*/(0,jsx_runtime.jsx)("circle", {\n          className: circular_progress_constants_cssClasses.DETERMINATE_CIRCLE,\n          cx: cx,\n          cy: cy,\n          r: radius,\n          strokeWidth: strokeWidth,\n          strokeDasharray: strokeDasharray,\n          strokeDashoffset: strokeDashoffset\n        })]\n      })\n    }), indeterminate && /*#__PURE__*/(0,jsx_runtime.jsx)("div", {\n      className: circular_progress_constants_cssClasses.INDETERMINATE_CONTAINER,\n      children: (colorful ? [1, 2, 3, 4] : [0]).map(function (n) {\n        return /*#__PURE__*/(0,jsx_runtime.jsxs)("div", {\n          className: classnames_default()(circular_progress_constants_cssClasses.SPINNER_LAYER, CircularProgress_defineProperty({}, "".concat(circular_progress_constants_cssClasses.PROGRESS_COLOR, "-").concat(n), n)),\n          children: [/*#__PURE__*/(0,jsx_runtime.jsx)("div", {\n            className: "".concat(circular_progress_constants_cssClasses.CIRCLE_CLIPPER, " ").concat(circular_progress_constants_cssClasses.CIRCLE_LEFT),\n            children: /*#__PURE__*/(0,jsx_runtime.jsx)("svg", {\n              className: circular_progress_constants_cssClasses.INDETERMINATE_CIRCLE_GRAPHIC,\n              viewBox: "0 0 ".concat(viewBox, " ").concat(viewBox),\n              xmlns: strings.XMLNS,\n              children: /*#__PURE__*/(0,jsx_runtime.jsx)("circle", {\n                cx: cx,\n                cy: cy,\n                r: radius,\n                strokeWidth: strokeWidth,\n                strokeDasharray: strokeDasharray,\n                strokeDashoffset: indeterminateStrokeDashoffset\n              })\n            })\n          }), /*#__PURE__*/(0,jsx_runtime.jsx)("div", {\n            className: circular_progress_constants_cssClasses.GAP_PATCH,\n            children: /*#__PURE__*/(0,jsx_runtime.jsx)("svg", {\n              className: circular_progress_constants_cssClasses.INDETERMINATE_CIRCLE_GRAPHIC,\n              viewBox: "0 0 ".concat(viewBox, " ").concat(viewBox),\n              xmlns: strings.XMLNS,\n              children: /*#__PURE__*/(0,jsx_runtime.jsx)("circle", {\n                cx: cx,\n                cy: cy,\n                r: radius,\n                strokeWidth: gapPatchStrokeWidth,\n                strokeDasharray: strokeDasharray,\n                strokeDashoffset: indeterminateStrokeDashoffset\n              })\n            })\n          }), /*#__PURE__*/(0,jsx_runtime.jsx)("div", {\n            className: "".concat(circular_progress_constants_cssClasses.CIRCLE_CLIPPER, " ").concat(circular_progress_constants_cssClasses.CIRCLE_RIGHT),\n            children: /*#__PURE__*/(0,jsx_runtime.jsx)("svg", {\n              className: circular_progress_constants_cssClasses.INDETERMINATE_CIRCLE_GRAPHIC,\n              viewBox: "0 0 ".concat(viewBox, " ").concat(viewBox),\n              xmlns: strings.XMLNS,\n              children: /*#__PURE__*/(0,jsx_runtime.jsx)("circle", {\n                cx: cx,\n                cy: cy,\n                r: radius,\n                strokeWidth: strokeWidth,\n                strokeDasharray: strokeDasharray,\n                strokeDashoffset: indeterminateStrokeDashoffset\n              })\n            })\n          })]\n        }, n);\n      })\n    })]\n  }));\n});\nCircularProgress.displayName = \'MDCCircularProgress\';\nCircularProgress.propTypes = {\n  value: prop_types_default().oneOfType([(prop_types_default()).number, (prop_types_default()).string]),\n  size: prop_types_default().oneOf([Size.SMALL, Size.MEDIUM, Size.LARGE]),\n  indeterminate: (prop_types_default()).bool,\n  closed: (prop_types_default()).bool,\n  colorful: (prop_types_default()).bool\n};\nCircularProgress.Size = Size;\n/* harmony default export */ const circular_progress_CircularProgress = (CircularProgress);\n;// CONCATENATED MODULE: ./src/circular-progress/index.js\n\n;// CONCATENATED MODULE: ./src/icon-button/constants.js\nvar icon_button_constants_cssClasses = {\n  ROOT: \'mdc-icon-button\',\n  TOUCH: \'mdc-icon-button--touch\',\n  ICON: \'mdc-icon-button__icon\',\n  RIPPLE: \'mdc-icon-button__ripple\',\n  TOUCH_ELEMENT: \'mdc-icon-button__touch\'\n};\n;// CONCATENATED MODULE: ./src/icon-button/IconButton.jsx\nvar IconButton_excluded = ["icon", "touch", "element", "component", "className", "children"];\n\nfunction IconButton_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction IconButton_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { IconButton_ownKeys(Object(source), true).forEach(function (key) { IconButton_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { IconButton_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction IconButton_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction IconButton_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = IconButton_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction IconButton_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\n\n\n\n\nvar IconButton = /*#__PURE__*/(0,react.forwardRef)(function (_ref, ref) {\n  var _classnames;\n\n  var icon = _ref.icon,\n      _ref$touch = _ref.touch,\n      touch = _ref$touch === void 0 ? false : _ref$touch,\n      _ref$element = _ref.element,\n      element = _ref$element === void 0 ? \'button\' : _ref$element,\n      _ref$component = _ref.component,\n      Element = _ref$component === void 0 ? element : _ref$component,\n      className = _ref.className,\n      _ref$children = _ref.children,\n      children = _ref$children === void 0 ? icon : _ref$children,\n      props = IconButton_objectWithoutProperties(_ref, IconButton_excluded);\n\n  var classNames = classnames_default()(icon_button_constants_cssClasses.ROOT, (_classnames = {}, IconButton_defineProperty(_classnames, cssClasses.ROOT, typeof children === \'string\'), IconButton_defineProperty(_classnames, icon_button_constants_cssClasses.TOUCH, touch), _classnames), className);\n  return /*#__PURE__*/(0,jsx_runtime.jsxs)(Element, IconButton_objectSpread(IconButton_objectSpread({\n    ref: ref,\n    className: classNames\n  }, props), {}, {\n    children: [/*#__PURE__*/(0,jsx_runtime.jsx)("div", {\n      className: icon_button_constants_cssClasses.RIPPLE\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Clone, {\n      component: children,\n      className: icon_button_constants_cssClasses.ICON\n    }), touch && /*#__PURE__*/(0,jsx_runtime.jsx)("div", {\n      className: icon_button_constants_cssClasses.TOUCH_ELEMENT\n    })]\n  }));\n});\nIconButton.displayName = \'MDCIconButton\';\nIconButton.propTypes = {\n  icon: (prop_types_default()).node,\n  touch: (prop_types_default()).bool\n};\n/* harmony default export */ const icon_button_IconButton = (IconButton);\n;// CONCATENATED MODULE: ./src/icon-button/index.js\n\n;// CONCATENATED MODULE: ./src/linear-progress/constants.js\nvar linear_progress_constants_cssClasses = {\n  ROOT: \'mdc-linear-progress\',\n  INDETERMINATE: \'mdc-linear-progress--indeterminate\',\n  ANIMATION_READY: \'mdc-linear-progress--animation-ready\',\n  CLOSED: \'mdc-linear-progress--closed\',\n  CLOSED_ANIMATION_OFF: \'mdc-linear-progress--closed-animation-off\',\n  BUFFER: \'mdc-linear-progress__buffer\',\n  BUFFER_BAR: \'mdc-linear-progress__buffer-bar\',\n  BUFFER_DOTS: \'mdc-linear-progress__buffer-dots\',\n  BAR: \'mdc-linear-progress__bar\',\n  PRIMARY_BAR: \'mdc-linear-progress__primary-bar\',\n  SECONDARY_BAR: \'mdc-linear-progress__secondary-bar\',\n  BAR_INNER: \'mdc-linear-progress__bar-inner\'\n};\n;// CONCATENATED MODULE: ./src/linear-progress/LinearProgress.jsx\nvar LinearProgress_excluded = ["value", "buffer", "indeterminate", "closed", "className"];\n\nfunction LinearProgress_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction LinearProgress_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { LinearProgress_ownKeys(Object(source), true).forEach(function (key) { LinearProgress_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { LinearProgress_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction LinearProgress_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction LinearProgress_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = LinearProgress_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction LinearProgress_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\n\n\nvar LinearProgress = /*#__PURE__*/(0,react.forwardRef)(function (_ref, ref) {\n  var _classnames;\n\n  var _ref$value = _ref.value,\n      value = _ref$value === void 0 ? 0 : _ref$value,\n      _ref$buffer = _ref.buffer,\n      buffer = _ref$buffer === void 0 ? 0 : _ref$buffer,\n      _ref$indeterminate = _ref.indeterminate,\n      indeterminate = _ref$indeterminate === void 0 ? false : _ref$indeterminate,\n      _ref$closed = _ref.closed,\n      closed = _ref$closed === void 0 ? false : _ref$closed,\n      className = _ref.className,\n      props = LinearProgress_objectWithoutProperties(_ref, LinearProgress_excluded);\n\n  var classNames = classnames_default()(linear_progress_constants_cssClasses.ROOT, (_classnames = {}, LinearProgress_defineProperty(_classnames, linear_progress_constants_cssClasses.INDETERMINATE, indeterminate), LinearProgress_defineProperty(_classnames, linear_progress_constants_cssClasses.ANIMATION_READY, indeterminate), LinearProgress_defineProperty(_classnames, linear_progress_constants_cssClasses.CLOSED, closed), _classnames), className);\n  var primaryBarStyle = {\n    transform: "scaleX(".concat(indeterminate ? 1 : value > 1 ? value * 0.01 : value, ")")\n  };\n  var bufferStyle = {\n    flexBasis: buffer ? "".concat(indeterminate ? 1 : buffer < 1 ? buffer * 100 : buffer, "%") : undefined\n  };\n  return /*#__PURE__*/(0,jsx_runtime.jsxs)("div", LinearProgress_objectSpread(LinearProgress_objectSpread({\n    ref: ref,\n    className: classNames,\n    role: "progressbar",\n    "aria-valuemin": "0",\n    "aria-valuemax": "1",\n    "aria-valuenow": value > 1 ? value * 0.01 : value\n  }, props), {}, {\n    children: [/*#__PURE__*/(0,jsx_runtime.jsxs)("div", {\n      className: linear_progress_constants_cssClasses.BUFFER,\n      children: [/*#__PURE__*/(0,jsx_runtime.jsx)("div", {\n        className: linear_progress_constants_cssClasses.BUFFER_BAR,\n        style: bufferStyle\n      }), /*#__PURE__*/(0,jsx_runtime.jsx)("div", {\n        className: linear_progress_constants_cssClasses.BUFFER_DOTS\n      })]\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)("div", {\n      className: "".concat(linear_progress_constants_cssClasses.BAR, " ").concat(linear_progress_constants_cssClasses.PRIMARY_BAR),\n      style: primaryBarStyle,\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)("span", {\n        className: linear_progress_constants_cssClasses.BAR_INNER\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)("div", {\n      className: "".concat(linear_progress_constants_cssClasses.BAR, " ").concat(linear_progress_constants_cssClasses.SECONDARY_BAR),\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)("span", {\n        className: linear_progress_constants_cssClasses.BAR_INNER\n      })\n    })]\n  }));\n});\nLinearProgress.displayName = \'MDCLinearProgress\';\nLinearProgress.propTypes = {\n  value: prop_types_default().oneOfType([(prop_types_default()).number, (prop_types_default()).string]),\n  buffer: prop_types_default().oneOfType([(prop_types_default()).number, (prop_types_default()).string]),\n  indeterminate: (prop_types_default()).bool,\n  closed: (prop_types_default()).bool\n};\n/* harmony default export */ const linear_progress_LinearProgress = (LinearProgress);\n;// CONCATENATED MODULE: ./src/linear-progress/index.js\n\n;// CONCATENATED MODULE: ./src/data-table/constants.js\nvar data_table_constants_cssClasses = {\n  ROOT: \'mdc-data-table\',\n  STICKY_HEADER: \'mdc-data-table--sticky-header\',\n  IN_PROGRESS: \'mdc-data-table--in-progress\',\n  TABLE_CONTAINER: \'mdc-data-table__table-container\',\n  TABLE: \'mdc-data-table__table\',\n  HEADER: \'mdc-data-table__header\',\n  HEADER_ROW: \'mdc-data-table__header-row\',\n  HEADER_ROW_CHECKBOX: \'mdc-data-table__header-row-checkbox\',\n  HEADER_CELL: \'mdc-data-table__header-cell\',\n  HEADER_CELL_CHECKBOX: \'mdc-data-table__header-cell--checkbox\',\n  HEADER_CELL_NUMERIC: \'mdc-data-table__header-cell--numeric\',\n  HEADER_CELL_WITH_SORT: \'mdc-data-table__header-cell--with-sort\',\n  HEADER_CELL_SORTED: \'mdc-data-table__header-cell--sorted\',\n  HEADER_CELL_SORTED_DESC: \'mdc-data-table__header-cell--sorted-descending\',\n  HEADER_CELL_WRAPPER: \'mdc-data-table__header-cell-wrapper\',\n  HEADER_CELL_LABEL: \'mdc-data-table__header-cell-label\',\n  CONTENT: \'mdc-data-table__content\',\n  ROW: \'mdc-data-table__row\',\n  ROW_CHECKBOX: \'mdc-data-table__row-checkbox\',\n  ROW_SELECTED: \'mdc-data-table__row--selected\',\n  CELL: \'mdc-data-table__cell\',\n  CELL_CHECKBOX: \'mdc-data-table__cell--checkbox\',\n  CELL_NUMERIC: \'mdc-data-table__cell--numeric\',\n  PAGINATION: \'mdc-data-table__pagination\',\n  PAGINATION_TRAILING: \'mdc-data-table__pagination-trailing\',\n  PAGINATION_ROWS_PER_PAGE: \'mdc-data-table__pagination-rows-per-page\',\n  PAGINATION_ROWS_PER_PAGE_LABEL: \'mdc-data-table__pagination-rows-per-page-label\',\n  PAGINATION_ROWS_PER_PAGE_SELECT: \'mdc-data-table__pagination-rows-per-page-select\',\n  PAGINATION_NAVIGATION: \'mdc-data-table__pagination-navigation\',\n  PAGINATION_TOTAL: \'mdc-data-table__pagination-total\',\n  PAGINATION_BUTTON: \'mdc-data-table__pagination-button\',\n  SORT_ICON_BUTTON: \'mdc-data-table__sort-icon-button\',\n  SORT_STATUS_LABEL: \'mdc-data-table__sort-status-label\',\n  PROGRESS_INDICATOR: \'mdc-data-table__progress-indicator\',\n  SCRIM: \'mdc-data-table__scrim\',\n  FOOTER: \'mdc-data-table__footer\',\n  LINEAR_PROGRESS: \'mdc-data-table__linear-progress\'\n};\n;// CONCATENATED MODULE: ./src/data-table/DataTableProgressIndicator.jsx\nfunction DataTableProgressIndicator_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction DataTableProgressIndicator_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { DataTableProgressIndicator_ownKeys(Object(source), true).forEach(function (key) { DataTableProgressIndicator_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { DataTableProgressIndicator_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction DataTableProgressIndicator_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n\n\n\n\n\nvar DataTableProgressIndicator = /*#__PURE__*/(0,react.forwardRef)(function (props, ref) {\n  return /*#__PURE__*/(0,jsx_runtime.jsxs)("div", DataTableProgressIndicator_objectSpread(DataTableProgressIndicator_objectSpread({\n    ref: ref,\n    className: data_table_constants_cssClasses.PROGRESS_INDICATOR\n  }, props), {}, {\n    children: [/*#__PURE__*/(0,jsx_runtime.jsx)("div", {\n      className: data_table_constants_cssClasses.SCRIM\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(linear_progress_LinearProgress, {\n      className: data_table_constants_cssClasses.LINEAR_PROGRESS,\n      indeterminate: true\n    })]\n  }));\n});\nDataTableProgressIndicator.displayName = \'MDCDataTableProgressIndicator\';\n/* harmony default export */ const data_table_DataTableProgressIndicator = (DataTableProgressIndicator);\n;// CONCATENATED MODULE: ./src/floating-label/constants.js\nvar floating_label_constants_cssClasses = {\n  ROOT: \'mdc-floating-label\',\n  FLOAT: \'mdc-floating-label--float-above\',\n  REQUIRED: \'mdc-floating-label--required\'\n};\n;// CONCATENATED MODULE: ./src/floating-label/FloatingLabel.jsx\nvar FloatingLabel_excluded = ["label", "float", "required", "className", "children"];\n\nfunction FloatingLabel_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction FloatingLabel_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { FloatingLabel_ownKeys(Object(source), true).forEach(function (key) { FloatingLabel_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { FloatingLabel_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction FloatingLabel_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction FloatingLabel_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = FloatingLabel_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction FloatingLabel_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\n\nvar FloatingLabel = /*#__PURE__*/(0,react.forwardRef)(function (_ref, ref) {\n  var _classnames;\n\n  var label = _ref.label,\n      _ref$float = _ref["float"],\n      _float = _ref$float === void 0 ? false : _ref$float,\n      _ref$required = _ref.required,\n      required = _ref$required === void 0 ? false : _ref$required,\n      className = _ref.className,\n      _ref$children = _ref.children,\n      children = _ref$children === void 0 ? label : _ref$children,\n      props = FloatingLabel_objectWithoutProperties(_ref, FloatingLabel_excluded);\n\n  var classNames = classnames_default()(floating_label_constants_cssClasses.ROOT, (_classnames = {}, FloatingLabel_defineProperty(_classnames, floating_label_constants_cssClasses.FLOAT, _float), FloatingLabel_defineProperty(_classnames, floating_label_constants_cssClasses.REQUIRED, required), _classnames), className);\n  return /*#__PURE__*/(0,jsx_runtime.jsx)("span", FloatingLabel_objectSpread(FloatingLabel_objectSpread({\n    ref: ref,\n    className: classNames\n  }, props), {}, {\n    children: children\n  }));\n});\nFloatingLabel.displayName = \'MDCFloatingLabel\';\nFloatingLabel.propTypes = {\n  label: (prop_types_default()).string,\n  "float": (prop_types_default()).bool,\n  required: (prop_types_default()).bool\n};\n/* harmony default export */ const floating_label_FloatingLabel = (FloatingLabel);\n;// CONCATENATED MODULE: ./src/floating-label/index.js\n\n;// CONCATENATED MODULE: ./src/line-ripple/constants.js\nvar line_ripple_constants_cssClasses = {\n  ROOT: \'mdc-line-ripple\',\n  ACTIVE: \'mdc-line-ripple--active\',\n  DEACTIVATING: \'mdc-line-ripple--deactivating\'\n};\n;// CONCATENATED MODULE: ./src/line-ripple/LineRipple.jsx\nvar LineRipple_excluded = ["active", "transformOrigin"];\n\nfunction LineRipple_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction LineRipple_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { LineRipple_ownKeys(Object(source), true).forEach(function (key) { LineRipple_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { LineRipple_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction LineRipple_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction LineRipple_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = LineRipple_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction LineRipple_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\n\nvar LineRipple = /*#__PURE__*/(0,react.forwardRef)(function (_ref, ref) {\n  var _ref$active = _ref.active,\n      active = _ref$active === void 0 ? false : _ref$active,\n      transformOrigin = _ref.transformOrigin,\n      props = LineRipple_objectWithoutProperties(_ref, LineRipple_excluded);\n\n  var style = transformOrigin && {\n    transformOrigin: "".concat(transformOrigin, "px")\n  };\n  var classNames = classnames_default()(line_ripple_constants_cssClasses.ROOT, LineRipple_defineProperty({}, line_ripple_constants_cssClasses.ACTIVE, active));\n  return /*#__PURE__*/(0,jsx_runtime.jsx)("span", LineRipple_objectSpread({\n    ref: ref,\n    style: style,\n    className: classNames\n  }, props));\n});\nLineRipple.displayName = \'MDCLineRipple\';\nLineRipple.propTypes = {\n  active: (prop_types_default()).bool\n};\n/* harmony default export */ const line_ripple_LineRipple = (LineRipple);\n;// CONCATENATED MODULE: ./src/line-ripple/index.js\n\n;// CONCATENATED MODULE: ./src/constants.js\nvar Key = {\n  ARROW_LEFT: \'ArrowLeft\',\n  ARROW_UP: \'ArrowUp\',\n  ARROW_RIGHT: \'ArrowRight\',\n  ARROW_DOWN: \'ArrowDown\',\n  HOME: \'Home\',\n  END: \'End\',\n  PAGE_UP: \'PageUp\',\n  PAGE_DOWN: \'PageDown\'\n};\nvar KeyCode = {\n  PAGE_UP: 33,\n  PAGE_DOWN: 34,\n  END: 35,\n  HOME: 36,\n  ARROW_LEFT: 37,\n  ARROW_UP: 38,\n  ARROW_RIGHT: 39,\n  ARROW_DOWN: 40\n};\n;// CONCATENATED MODULE: ./src/utils.js\n\nfunction getClientWidth(element) {\n  if (element.offsetParent !== null) {\n    return element.clientWidth;\n  }\n\n  var clone = element.cloneNode(true);\n  clone.style.setProperty(\'position\', \'absolute\');\n  clone.style.setProperty(\'transform\', \'translate(-9999px, -9999px)\');\n  document.documentElement.appendChild(clone);\n  var clientWidth = clone.clientWidth;\n  document.documentElement.removeChild(clone);\n  return clientWidth;\n}\nfunction getClientHeight(element) {\n  if (element.offsetParent !== null) {\n    return element.clientHeight;\n  }\n\n  var clone = element.cloneNode(true);\n  clone.style.setProperty(\'position\', \'absolute\');\n  clone.style.setProperty(\'transform\', \'translate(-9999px, -9999px)\');\n  document.documentElement.appendChild(clone);\n  var clientHeight = clone.clientHeight;\n  document.documentElement.removeChild(clone);\n  return clientHeight;\n}\nfunction getEventKey(event) {\n  switch (event.key || event.keyCode) {\n    case Key.ARROW_LEFT:\n    case KeyCode.ARROW_LEFT:\n      return Key.ARROW_LEFT;\n\n    case Key.ARROW_UP:\n    case KeyCode.ARROW_UP:\n      return Key.ARROW_UP;\n\n    case Key.ARROW_RIGHT:\n    case KeyCode.ARROW_RIGHT:\n      return Key.ARROW_RIGHT;\n\n    case Key.ARROW_DOWN:\n    case KeyCode.ARROW_DOWN:\n      return Key.ARROW_DOWN;\n\n    case Key.HOME:\n    case KeyCode.HOME:\n      return Key.HOME;\n\n    case Key.END:\n    case KeyCode.END:\n      return Key.END;\n\n    case Key.PAGE_UP:\n    case KeyCode.PAGE_UP:\n      return Key.PAGE_UP;\n\n    case Key.PAGE_DOWN:\n    case KeyCode.PAGE_DOWN:\n      return Key.PAGE_DOWN;\n\n    default:\n      return undefined;\n  }\n}\nfunction getPageX(event) {\n  var _event$targetTouches;\n\n  if (((_event$targetTouches = event.targetTouches) === null || _event$targetTouches === void 0 ? void 0 : _event$targetTouches.length) > 0) {\n    return event.targetTouches[0].pageX;\n  }\n\n  return event.pageX;\n}\nfunction getPageY(event) {\n  var _event$targetTouches2;\n\n  if (((_event$targetTouches2 = event.targetTouches) === null || _event$targetTouches2 === void 0 ? void 0 : _event$targetTouches2.length) > 0) {\n    return event.targetTouches[0].pageY;\n  }\n\n  return event.pageY;\n}\n;// CONCATENATED MODULE: ./src/notched-outline/constants.js\nvar notched_outline_constants_numbers = {\n  NOTCH_SIZE_FACTOR: 0.75,\n  NOTCH_PADDING_RIGHT: 8\n};\nvar notched_outline_constants_cssClasses = {\n  ROOT: \'mdc-notched-outline\',\n  NOTCHED: \'mdc-notched-outline--notched\',\n  UPGRADED: \'mdc-notched-outline--upgraded\',\n  NO_LABEL: \'mdc-notched-outline--no-label\',\n  LEADING: \'mdc-notched-outline__leading\',\n  NOTCH: \'mdc-notched-outline__notch\',\n  TRAILING: \'mdc-notched-outline__trailing\'\n};\n;// CONCATENATED MODULE: ./src/notched-outline/NotchedOutline.jsx\nvar NotchedOutline_excluded = ["notched", "className", "children"];\n\nfunction NotchedOutline_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction NotchedOutline_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { NotchedOutline_ownKeys(Object(source), true).forEach(function (key) { NotchedOutline_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { NotchedOutline_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction NotchedOutline_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction NotchedOutline_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = NotchedOutline_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction NotchedOutline_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\n\n\n\nvar NotchedOutline = /*#__PURE__*/(0,react.forwardRef)(function (_ref, ref) {\n  var _classnames;\n\n  var _ref$notched = _ref.notched,\n      notched = _ref$notched === void 0 ? false : _ref$notched,\n      className = _ref.className,\n      children = _ref.children,\n      props = NotchedOutline_objectWithoutProperties(_ref, NotchedOutline_excluded);\n\n  var notchRef = (0,react.useRef)();\n  (0,react.useLayoutEffect)(function () {\n    var notch = notchRef.current;\n    var floatingLabel = notch === null || notch === void 0 ? void 0 : notch.firstChild;\n    if (!notch || !floatingLabel) return;\n    var width = getClientWidth(floatingLabel);\n\n    if (notched) {\n      notchRef.current.style.width = "".concat(width * notched_outline_constants_numbers.NOTCH_SIZE_FACTOR + notched_outline_constants_numbers.NOTCH_PADDING_RIGHT, "px");\n    } else {\n      notchRef.current.style.width = \'auto\';\n    }\n  }, [notched]);\n  var classNames = classnames_default()(notched_outline_constants_cssClasses.ROOT, notched_outline_constants_cssClasses.UPGRADED, (_classnames = {}, NotchedOutline_defineProperty(_classnames, notched_outline_constants_cssClasses.NOTCHED, notched), NotchedOutline_defineProperty(_classnames, notched_outline_constants_cssClasses.NO_LABEL, !children), _classnames), className);\n  return /*#__PURE__*/(0,jsx_runtime.jsxs)("span", NotchedOutline_objectSpread(NotchedOutline_objectSpread({\n    ref: ref,\n    className: classNames\n  }, props), {}, {\n    children: [/*#__PURE__*/(0,jsx_runtime.jsx)("span", {\n      className: notched_outline_constants_cssClasses.LEADING\n    }), children && /*#__PURE__*/(0,jsx_runtime.jsx)("span", {\n      ref: notchRef,\n      className: notched_outline_constants_cssClasses.NOTCH,\n      children: children\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)("span", {\n      className: notched_outline_constants_cssClasses.TRAILING\n    })]\n  }));\n});\nNotchedOutline.displayName = \'MDCNotchedOutline\';\nNotchedOutline.propTypes = {\n  notched: (prop_types_default()).bool\n};\n/* harmony default export */ const notched_outline_NotchedOutline = (NotchedOutline);\n;// CONCATENATED MODULE: ./src/notched-outline/index.js\n\n;// CONCATENATED MODULE: ./src/menu/constants.js\nvar menu_constants_numbers = {\n  TRANSITION_OPEN_DURATION: 120,\n  TRANSITION_CLOSE_DURATION: 75,\n  MARGIN_TO_EDGE: 32,\n  ANCHOR_TO_MENU_SURFACE_WIDTH_RATIO: 0.67,\n  TOUCH_EVENT_WAIT_MS: 30\n};\nvar menu_constants_cssClasses = {\n  ROOT: \'mdc-menu\',\n  SURFACE: \'mdc-menu-surface\',\n  SURFACE_ANCHOR: \'mdc-menu-surface--anchor\',\n  SURFACE_FIXED: \'mdc-menu-surface--fixed\',\n  SURFACE_OPEN: \'mdc-menu-surface--open\',\n  SURFACE_ANIMATING_OPEN: \'mdc-menu-surface--animating-open\',\n  SURFACE_ANIMATING_CLOSED: \'mdc-menu-surface--animating-closed\',\n  SURFACE_BELOW_ANCHOR: \'mdc-menu-surface--is-open-below\',\n  ITEM: \'mdc-menu-item\',\n  ITEM_SELECTED: \'mdc-menu-item--selected\',\n  SELECTION_GROUP: \'mdc-menu__selection-group\',\n  SELECTION_GROUP_ICON: \'mdc-menu__selection-group-icon\'\n};\nvar Origin = {\n  TOP_LEFT: \'top left\',\n  TOP_CENTER: \'top center\',\n  TOP_RIGHT: \'top right\',\n  CENTER_LEFT: \'center left\',\n  CENTER: \'center center\',\n  CENTER_RIGHT: \'center right\',\n  BOTTOM_LEFT: \'bottom left\',\n  BOTTOM_CENTER: \'bottom center\',\n  BOTTOM_RIGHT: \'bottom right\'\n};\n;// CONCATENATED MODULE: ./src/hooks.js\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\n\nfunction useCreated(fn) {\n  var _useState = useState(false),\n      _useState2 = _slicedToArray(_useState, 2),\n      created = _useState2[0],\n      setCreated = _useState2[1];\n\n  if (created) return;\n  fn();\n  setCreated(true);\n}\nfunction useMounted(fn) {\n  (0,react.useEffect)(function () {\n    return fn();\n  }, []);\n}\nfunction useUpdated(fn, deps) {\n  var _useState3 = (0,react.useState)(false),\n      _useState4 = _slicedToArray(_useState3, 2),\n      mounted = _useState4[0],\n      setMounted = _useState4[1];\n\n  (0,react.useEffect)(function () {\n    if (!mounted) return setMounted(true);\n    return fn();\n  }, deps);\n}\nfunction useUpdatedSync(fn, deps) {\n  var _useState5 = (0,react.useState)(false),\n      _useState6 = _slicedToArray(_useState5, 2),\n      mounted = _useState6[0],\n      setMounted = _useState6[1];\n\n  (0,react.useLayoutEffect)(function () {\n    if (!mounted) return setMounted(true);\n    return fn();\n  }, deps);\n}\nfunction useUnmounted(fn) {\n  (0,react.useEffect)(function () {\n    return function () {\n      return fn();\n    };\n  }, []);\n}\n;// CONCATENATED MODULE: ./src/list/constants.js\nvar listCssClasses = {\n  ROOT: \'mdc-list\'\n};\nvar listItemCssClasses = {\n  ROOT: \'mdc-list-item\',\n  ACTIVATED: \'mdc-list-item--activated\',\n  SELECTED: \'mdc-list-item--selected\',\n  DISABLED: \'mdc-list-item--disabled\',\n  NON_INTERACTIVE: \'mdc-list-item--non-interactive\',\n  ONE_LINE: \'mdc-list-item--with-one-line\',\n  TWO_LINES: \'mdc-list-item--with-two-lines\',\n  THREE_LINES: \'mdc-list-item--with-three-lines\',\n  OVERLINE: \'mdc-list-item--with-overline\',\n  LEADING_ICON: \'mdc-list-item--with-leading-icon\',\n  LEADING_IMAGE: \'mdc-list-item--with-leading-image\',\n  LEADING_AVATAR: \'mdc-list-item--with-leading-avatar\',\n  LEADING_THUMBNAIL: \'mdc-list-item--with-leading-thumbnail\',\n  LEADING_VIDEO: \'mdc-list-item--with-leading-video\',\n  LEADING_CHECKBOX: \'mdc-list-item--with-leading-checkbox\',\n  LEADING_RADIO: \'mdc-list-item--with-leading-radio\',\n  LEADING_SWITCH: \'mdc-list-item--with-leading-switch\',\n  TRAILING_ICON: \'mdc-list-item--with-trailing-icon\',\n  TRAILING_META: \'mdc-list-item--with-trailing-meta\',\n  TRAILING_CHECKBOX: \'mdc-list-item--with-trailing-checkbox\',\n  TRAILING_RADIO: \'mdc-list-item--with-trailing-radio\',\n  TRAILING_SWITCH: \'mdc-list-item--with-trailing-switch\',\n  START: \'mdc-list-item__start\',\n  CONTENT: \'mdc-list-item__content\',\n  END: \'mdc-list-item__end\',\n  OVERLINE_TEXT: \'mdc-list-item__overline-text\',\n  PRIMARY_TEXT: \'mdc-list-item__primary-text\',\n  SECONDARY_TEXT: \'mdc-list-item__secondary-text\',\n  RIPPLE: \'mdc-list-item__ripple\'\n};\nvar listGroupCssClasses = {\n  ROOT: \'mdc-list-group\',\n  SUBHEADER: \'mdc-list-group__subheader\'\n};\nvar listDividerCssClasses = {\n  ROOT: \'mdc-list-divider\',\n  LEADING_TEXT: \'mdc-list-divider--with-leading-text\',\n  LEADING_ICON: \'mdc-list-divider--with-leading-icon\',\n  LEADING_IMAGE: \'mdc-list-divider--with-leading-image\',\n  LEADING_VIDEO: \'mdc-list-divider--with-leading-video\',\n  LEADING_THUMBNAIL: \'mdc-list-divider--with-leading-thumbnail\',\n  LEADING_AVATAR: \'mdc-list-divider--with-leading-avatar\',\n  LEADING_CHECKBOX: \'mdc-list-divider--with-leading-checkbox\',\n  LEADING_SWITCH: \'mdc-list-divider--with-leading-switch\',\n  LEADING_RADIO: \'mdc-list-divider--with-leading-radio\'\n};\n;// CONCATENATED MODULE: ./src/list/ListItemContent.jsx\nvar ListItemContent_excluded = ["overline", "primary", "secondary", "overlineText", "primaryText", "secondaryText", "element", "component", "className", "children"];\n\nfunction ListItemContent_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction ListItemContent_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ListItemContent_ownKeys(Object(source), true).forEach(function (key) { ListItemContent_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ListItemContent_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction ListItemContent_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction ListItemContent_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = ListItemContent_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction ListItemContent_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\n\n\n\nvar ListItemContent = /*#__PURE__*/(0,react.forwardRef)(function (_ref, ref) {\n  var overline = _ref.overline,\n      primary = _ref.primary,\n      secondary = _ref.secondary,\n      _ref$overlineText = _ref.overlineText,\n      overlineText = _ref$overlineText === void 0 ? overline : _ref$overlineText,\n      _ref$primaryText = _ref.primaryText,\n      primaryText = _ref$primaryText === void 0 ? primary : _ref$primaryText,\n      _ref$secondaryText = _ref.secondaryText,\n      secondaryText = _ref$secondaryText === void 0 ? secondary : _ref$secondaryText,\n      _ref$element = _ref.element,\n      element = _ref$element === void 0 ? \'span\' : _ref$element,\n      _ref$component = _ref.component,\n      Element = _ref$component === void 0 ? element : _ref$component,\n      className = _ref.className,\n      children = _ref.children,\n      props = ListItemContent_objectWithoutProperties(_ref, ListItemContent_excluded);\n\n  var classNames = classnames_default()(listItemCssClasses.CONTENT, className);\n  return /*#__PURE__*/(0,jsx_runtime.jsxs)(Element, ListItemContent_objectSpread(ListItemContent_objectSpread({\n    ref: ref,\n    className: classNames\n  }, props), {}, {\n    children: [overlineText && /*#__PURE__*/(0,jsx_runtime.jsx)(Clone, {\n      component: overlineText,\n      fallback: "span",\n      className: listItemCssClasses.OVERLINE_TEXT\n    }), primaryText && /*#__PURE__*/(0,jsx_runtime.jsx)(Clone, {\n      component: primaryText,\n      fallback: "span",\n      className: listItemCssClasses.PRIMARY_TEXT\n    }), secondaryText && /*#__PURE__*/(0,jsx_runtime.jsx)(Clone, {\n      component: secondaryText,\n      fallback: "span",\n      className: listItemCssClasses.SECONDARY_TEXT\n    }), children]\n  }));\n});\nListItemContent.displayName = \'MDCListItemContent\';\nListItemContent.propTypes = {\n  overlineText: (prop_types_default()).node,\n  primaryText: (prop_types_default()).node,\n  secondaryText: (prop_types_default()).node\n};\n/* harmony default export */ const list_ListItemContent = (ListItemContent);\n;// CONCATENATED MODULE: ./src/list/ListItemEnd.jsx\nvar ListItemEnd_excluded = ["element", "component", "className"];\n\nfunction ListItemEnd_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction ListItemEnd_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ListItemEnd_ownKeys(Object(source), true).forEach(function (key) { ListItemEnd_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ListItemEnd_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction ListItemEnd_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction ListItemEnd_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = ListItemEnd_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction ListItemEnd_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\nvar ListItemEnd = /*#__PURE__*/(0,react.forwardRef)(function (_ref, ref) {\n  var _ref$element = _ref.element,\n      element = _ref$element === void 0 ? \'span\' : _ref$element,\n      _ref$component = _ref.component,\n      Element = _ref$component === void 0 ? element : _ref$component,\n      className = _ref.className,\n      props = ListItemEnd_objectWithoutProperties(_ref, ListItemEnd_excluded);\n\n  var classNames = classnames_default()(listItemCssClasses.END, className);\n  return /*#__PURE__*/(0,jsx_runtime.jsx)(Element, ListItemEnd_objectSpread({\n    ref: ref,\n    className: classNames\n  }, props));\n});\nListItemEnd.displayName = \'MDCListItemEnd\';\n/* harmony default export */ const list_ListItemEnd = (ListItemEnd);\n;// CONCATENATED MODULE: ./src/list/ListItemStart.jsx\nvar ListItemStart_excluded = ["element", "component", "className"];\n\nfunction ListItemStart_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction ListItemStart_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ListItemStart_ownKeys(Object(source), true).forEach(function (key) { ListItemStart_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ListItemStart_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction ListItemStart_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction ListItemStart_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = ListItemStart_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction ListItemStart_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\nvar ListItemStart = /*#__PURE__*/(0,react.forwardRef)(function (_ref, ref) {\n  var _ref$element = _ref.element,\n      element = _ref$element === void 0 ? \'span\' : _ref$element,\n      _ref$component = _ref.component,\n      Element = _ref$component === void 0 ? element : _ref$component,\n      className = _ref.className,\n      props = ListItemStart_objectWithoutProperties(_ref, ListItemStart_excluded);\n\n  var classNames = classnames_default()(listItemCssClasses.START, className);\n  return /*#__PURE__*/(0,jsx_runtime.jsx)(Element, ListItemStart_objectSpread({\n    ref: ref,\n    className: classNames\n  }, props));\n});\nListItemStart.displayName = \'MDCListItemStart\';\n/* harmony default export */ const list_ListItemStart = (ListItemStart);\n;// CONCATENATED MODULE: ./src/list/ListItem.jsx\nvar ListItem_excluded = ["start", "content", "end", "text", "overlineText", "primaryText", "secondaryText", "icon", "image", "avatar", "thumbnail", "video", "leadingIcon", "leadingImage", "leadingAvatar", "leadingThumbnail", "leadingVideo", "leadingCheckbox", "leadingRadio", "leadingSwitch", "meta", "trailingMeta", "trailingIcon", "trailingCheckbox", "trailingRadio", "trailingSwitch", "activated", "selected", "disabled", "nonInteractive", "oneLine", "twoLines", "threeLines", "withLeadingIcon", "withLeadingImage", "withLeadingAvatar", "withLeadingThumbnail", "withLeadingVideo", "withLeadingCheckbox", "withLeadingRadio", "withLeadingSwitch", "withTrailingMeta", "withTrailingIcon", "withTrailingCheckbox", "withTrailingRadio", "withTrailingSwitch", "element", "component", "className", "children"];\n\nfunction ListItem_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction ListItem_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ListItem_ownKeys(Object(source), true).forEach(function (key) { ListItem_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ListItem_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction ListItem_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction ListItem_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = ListItem_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction ListItem_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\n\n\n\n\n\n\n\nvar ListItem = /*#__PURE__*/(0,react.forwardRef)(function (_ref, ref) {\n  var _classnames;\n\n  var start = _ref.start,\n      content = _ref.content,\n      end = _ref.end,\n      text = _ref.text,\n      overlineText = _ref.overlineText,\n      _ref$primaryText = _ref.primaryText,\n      primaryText = _ref$primaryText === void 0 ? text : _ref$primaryText,\n      secondaryText = _ref.secondaryText,\n      icon = _ref.icon,\n      image = _ref.image,\n      avatar = _ref.avatar,\n      thumbnail = _ref.thumbnail,\n      video = _ref.video,\n      _ref$leadingIcon = _ref.leadingIcon,\n      leadingIcon = _ref$leadingIcon === void 0 ? icon : _ref$leadingIcon,\n      _ref$leadingImage = _ref.leadingImage,\n      leadingImage = _ref$leadingImage === void 0 ? image : _ref$leadingImage,\n      _ref$leadingAvatar = _ref.leadingAvatar,\n      leadingAvatar = _ref$leadingAvatar === void 0 ? avatar : _ref$leadingAvatar,\n      _ref$leadingThumbnail = _ref.leadingThumbnail,\n      leadingThumbnail = _ref$leadingThumbnail === void 0 ? thumbnail : _ref$leadingThumbnail,\n      _ref$leadingVideo = _ref.leadingVideo,\n      leadingVideo = _ref$leadingVideo === void 0 ? video : _ref$leadingVideo,\n      leadingCheckbox = _ref.leadingCheckbox,\n      leadingRadio = _ref.leadingRadio,\n      leadingSwitch = _ref.leadingSwitch,\n      meta = _ref.meta,\n      _ref$trailingMeta = _ref.trailingMeta,\n      trailingMeta = _ref$trailingMeta === void 0 ? meta : _ref$trailingMeta,\n      trailingIcon = _ref.trailingIcon,\n      trailingCheckbox = _ref.trailingCheckbox,\n      trailingRadio = _ref.trailingRadio,\n      trailingSwitch = _ref.trailingSwitch,\n      _ref$activated = _ref.activated,\n      activated = _ref$activated === void 0 ? false : _ref$activated,\n      _ref$selected = _ref.selected,\n      selected = _ref$selected === void 0 ? false : _ref$selected,\n      _ref$disabled = _ref.disabled,\n      disabled = _ref$disabled === void 0 ? false : _ref$disabled,\n      _ref$nonInteractive = _ref.nonInteractive,\n      nonInteractive = _ref$nonInteractive === void 0 ? false : _ref$nonInteractive,\n      _ref$oneLine = _ref.oneLine,\n      oneLine = _ref$oneLine === void 0 ? false : _ref$oneLine,\n      _ref$twoLines = _ref.twoLines,\n      twoLines = _ref$twoLines === void 0 ? false : _ref$twoLines,\n      _ref$threeLines = _ref.threeLines,\n      threeLines = _ref$threeLines === void 0 ? false : _ref$threeLines,\n      _ref$withLeadingIcon = _ref.withLeadingIcon,\n      withLeadingIcon = _ref$withLeadingIcon === void 0 ? Boolean(leadingIcon) : _ref$withLeadingIcon,\n      _ref$withLeadingImage = _ref.withLeadingImage,\n      withLeadingImage = _ref$withLeadingImage === void 0 ? Boolean(leadingImage) : _ref$withLeadingImage,\n      _ref$withLeadingAvata = _ref.withLeadingAvatar,\n      withLeadingAvatar = _ref$withLeadingAvata === void 0 ? Boolean(leadingAvatar) : _ref$withLeadingAvata,\n      _ref$withLeadingThumb = _ref.withLeadingThumbnail,\n      withLeadingThumbnail = _ref$withLeadingThumb === void 0 ? Boolean(leadingThumbnail) : _ref$withLeadingThumb,\n      _ref$withLeadingVideo = _ref.withLeadingVideo,\n      withLeadingVideo = _ref$withLeadingVideo === void 0 ? Boolean(leadingVideo) : _ref$withLeadingVideo,\n      _ref$withLeadingCheck = _ref.withLeadingCheckbox,\n      withLeadingCheckbox = _ref$withLeadingCheck === void 0 ? Boolean(leadingCheckbox) : _ref$withLeadingCheck,\n      _ref$withLeadingRadio = _ref.withLeadingRadio,\n      withLeadingRadio = _ref$withLeadingRadio === void 0 ? Boolean(leadingRadio) : _ref$withLeadingRadio,\n      _ref$withLeadingSwitc = _ref.withLeadingSwitch,\n      withLeadingSwitch = _ref$withLeadingSwitc === void 0 ? Boolean(leadingSwitch) : _ref$withLeadingSwitc,\n      _ref$withTrailingMeta = _ref.withTrailingMeta,\n      withTrailingMeta = _ref$withTrailingMeta === void 0 ? Boolean(trailingMeta) : _ref$withTrailingMeta,\n      _ref$withTrailingIcon = _ref.withTrailingIcon,\n      withTrailingIcon = _ref$withTrailingIcon === void 0 ? Boolean(trailingIcon) : _ref$withTrailingIcon,\n      _ref$withTrailingChec = _ref.withTrailingCheckbox,\n      withTrailingCheckbox = _ref$withTrailingChec === void 0 ? Boolean(trailingCheckbox) : _ref$withTrailingChec,\n      _ref$withTrailingRadi = _ref.withTrailingRadio,\n      withTrailingRadio = _ref$withTrailingRadi === void 0 ? Boolean(trailingRadio) : _ref$withTrailingRadi,\n      _ref$withTrailingSwit = _ref.withTrailingSwitch,\n      withTrailingSwitch = _ref$withTrailingSwit === void 0 ? Boolean(trailingSwitch) : _ref$withTrailingSwit,\n      _ref$element = _ref.element,\n      element = _ref$element === void 0 ? \'li\' : _ref$element,\n      _ref$component = _ref.component,\n      Element = _ref$component === void 0 ? element : _ref$component,\n      className = _ref.className,\n      children = _ref.children,\n      props = ListItem_objectWithoutProperties(_ref, ListItem_excluded);\n\n  var lines = Boolean(overlineText) + Boolean(primaryText) + Boolean(secondaryText);\n  var hasStart = Boolean(start || leadingIcon || leadingImage || leadingAvatar || leadingThumbnail || leadingVideo || leadingCheckbox || leadingRadio || leadingSwitch);\n  var hasContent = Boolean(content || overlineText || primaryText || secondaryText);\n  var hasEnd = Boolean(end || trailingMeta || trailingIcon || trailingCheckbox || trailingRadio || trailingSwitch);\n  var classNames = classnames_default()(listItemCssClasses.ROOT, (_classnames = {}, ListItem_defineProperty(_classnames, listItemCssClasses.ACTIVATED, activated), ListItem_defineProperty(_classnames, listItemCssClasses.SELECTED, selected), ListItem_defineProperty(_classnames, listItemCssClasses.DISABLED, disabled), ListItem_defineProperty(_classnames, listItemCssClasses.ONE_LINE, oneLine || lines === 1), ListItem_defineProperty(_classnames, listItemCssClasses.TWO_LINES, twoLines || lines === 2), ListItem_defineProperty(_classnames, listItemCssClasses.THREE_LINES, threeLines || lines === 3), ListItem_defineProperty(_classnames, listItemCssClasses.NON_INTERACTIVE, nonInteractive), ListItem_defineProperty(_classnames, listItemCssClasses.OVERLINE, overlineText), ListItem_defineProperty(_classnames, listItemCssClasses.LEADING_ICON, withLeadingIcon), ListItem_defineProperty(_classnames, listItemCssClasses.LEADING_IMAGE, withLeadingImage), ListItem_defineProperty(_classnames, listItemCssClasses.LEADING_AVATAR, withLeadingAvatar), ListItem_defineProperty(_classnames, listItemCssClasses.LEADING_THUMBNAIL, withLeadingThumbnail), ListItem_defineProperty(_classnames, listItemCssClasses.LEADING_VIDEO, withLeadingVideo), ListItem_defineProperty(_classnames, listItemCssClasses.LEADING_CHECKBOX, withLeadingCheckbox), ListItem_defineProperty(_classnames, listItemCssClasses.LEADING_RADIO, withLeadingRadio), ListItem_defineProperty(_classnames, listItemCssClasses.LEADING_SWITCH, withLeadingSwitch), ListItem_defineProperty(_classnames, listItemCssClasses.TRAILING_ICON, withTrailingIcon), ListItem_defineProperty(_classnames, listItemCssClasses.TRAILING_META, withTrailingMeta), ListItem_defineProperty(_classnames, listItemCssClasses.TRAILING_CHECKBOX, withTrailingCheckbox), ListItem_defineProperty(_classnames, listItemCssClasses.TRAILING_RADIO, withTrailingRadio), ListItem_defineProperty(_classnames, listItemCssClasses.TRAILING_SWITCH, withTrailingSwitch), _classnames), className);\n  return /*#__PURE__*/(0,jsx_runtime.jsxs)(Element, ListItem_objectSpread(ListItem_objectSpread({\n    ref: ref,\n    className: classNames\n  }, props), {}, {\n    children: [/*#__PURE__*/(0,jsx_runtime.jsx)("span", {\n      className: listItemCssClasses.RIPPLE\n    }), hasStart && /*#__PURE__*/(0,jsx_runtime.jsxs)(list_ListItemStart, {\n      children: [start, leadingIcon && /*#__PURE__*/(0,jsx_runtime.jsx)(Clone, {\n        component: leadingIcon,\n        fallback: icon_Icon\n      }), leadingImage, leadingAvatar, leadingThumbnail, leadingVideo, leadingCheckbox, leadingRadio, leadingSwitch]\n    }), hasContent && /*#__PURE__*/(0,jsx_runtime.jsx)(list_ListItemContent, {\n      overlineText: overlineText,\n      primaryText: primaryText,\n      secondaryText: secondaryText,\n      children: content\n    }), hasEnd && /*#__PURE__*/(0,jsx_runtime.jsxs)(list_ListItemEnd, {\n      children: [end, trailingMeta, trailingIcon && /*#__PURE__*/(0,jsx_runtime.jsx)(Clone, {\n        component: trailingIcon,\n        fallback: icon_Icon\n      }), trailingCheckbox, trailingRadio, trailingSwitch]\n    }), children]\n  }));\n});\nListItem.displayName = \'MDCListItem\';\nListItem.propTypes = {\n  start: (prop_types_default()).node,\n  content: (prop_types_default()).node,\n  end: (prop_types_default()).node,\n  text: (prop_types_default()).node,\n  overlineText: (prop_types_default()).node,\n  primaryText: (prop_types_default()).node,\n  secondaryText: (prop_types_default()).node,\n  icon: (prop_types_default()).node,\n  image: (prop_types_default()).element,\n  avatar: (prop_types_default()).element,\n  thumbnail: (prop_types_default()).element,\n  video: (prop_types_default()).element,\n  leadingIcon: (prop_types_default()).node,\n  leadingImage: (prop_types_default()).element,\n  leadingAvatar: (prop_types_default()).element,\n  leadingThumbnail: (prop_types_default()).element,\n  leadingVideo: (prop_types_default()).element,\n  leadingCheckbox: (prop_types_default()).element,\n  leadingRadio: (prop_types_default()).element,\n  leadingSwitch: (prop_types_default()).element,\n  meta: (prop_types_default()).node,\n  trailingMeta: (prop_types_default()).node,\n  trailingIcon: (prop_types_default()).node,\n  trailingCheckbox: (prop_types_default()).element,\n  trailingRadio: (prop_types_default()).element,\n  trailingSwitch: (prop_types_default()).element,\n  activated: (prop_types_default()).bool,\n  selected: (prop_types_default()).bool,\n  disabled: (prop_types_default()).bool,\n  nonInteractive: (prop_types_default()).bool,\n  withLeadingIcon: (prop_types_default()).bool,\n  withLeadingImage: (prop_types_default()).bool,\n  withLeadingAvatar: (prop_types_default()).bool,\n  withLeadingThumbnail: (prop_types_default()).bool,\n  withLeadingVideo: (prop_types_default()).bool,\n  withLeadingCheckbox: (prop_types_default()).bool,\n  withLeadingRadio: (prop_types_default()).bool,\n  withLeadingSwitch: (prop_types_default()).bool,\n  withTrailingMeta: (prop_types_default()).bool,\n  withTrailingIcon: (prop_types_default()).bool,\n  withTrailingCheckbox: (prop_types_default()).bool,\n  withTrailingRadio: (prop_types_default()).bool,\n  withTrailingSwitch: (prop_types_default()).bool\n};\n/* harmony default export */ const list_ListItem = (ListItem);\n;// CONCATENATED MODULE: ./src/list/List.jsx\nvar List_excluded = ["items", "element", "className", "children"];\n\nfunction List_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction List_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { List_ownKeys(Object(source), true).forEach(function (key) { List_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { List_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction List_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction List_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = List_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction List_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\n\n\n\nvar List = /*#__PURE__*/(0,react.forwardRef)(function (_ref, ref) {\n  var items = _ref.items,\n      _ref$element = _ref.element,\n      Element = _ref$element === void 0 ? \'ul\' : _ref$element,\n      className = _ref.className,\n      _ref$children = _ref.children,\n      children = _ref$children === void 0 ? items === null || items === void 0 ? void 0 : items.map(function (item) {\n    return (0,react.createElement)(list_ListItem, item);\n  }) : _ref$children,\n      props = List_objectWithoutProperties(_ref, List_excluded);\n\n  var classNames = classnames_default()(listCssClasses.ROOT, className);\n  return /*#__PURE__*/(0,jsx_runtime.jsx)(Element, List_objectSpread(List_objectSpread({\n    ref: ref,\n    className: classNames\n  }, props), {}, {\n    children: children\n  }));\n});\nList.displayName = \'MDCList\';\nlist_ListItem.propTypes = {\n  items: (prop_types_default()).array\n};\n/* harmony default export */ const list_List = (List);\n;// CONCATENATED MODULE: ./src/list/ListDivider.jsx\nvar ListDivider_excluded = ["withLeadingText", "withLeadingIcon", "withLeadingImage", "withLeadingThumbnail", "withLeadingVideo", "withLeadingCheckbox", "withLeadingRadio", "withLeadingSwitch", "element", "className"];\n\nfunction ListDivider_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction ListDivider_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ListDivider_ownKeys(Object(source), true).forEach(function (key) { ListDivider_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ListDivider_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction ListDivider_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction ListDivider_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = ListDivider_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction ListDivider_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\n\nvar ListDivider = /*#__PURE__*/(0,react.forwardRef)(function (_ref, ref) {\n  var _classnames;\n\n  var _ref$withLeadingText = _ref.withLeadingText,\n      withLeadingText = _ref$withLeadingText === void 0 ? false : _ref$withLeadingText,\n      _ref$withLeadingIcon = _ref.withLeadingIcon,\n      withLeadingIcon = _ref$withLeadingIcon === void 0 ? false : _ref$withLeadingIcon,\n      _ref$withLeadingImage = _ref.withLeadingImage,\n      withLeadingImage = _ref$withLeadingImage === void 0 ? false : _ref$withLeadingImage,\n      _ref$withLeadingThumb = _ref.withLeadingThumbnail,\n      withLeadingThumbnail = _ref$withLeadingThumb === void 0 ? false : _ref$withLeadingThumb,\n      _ref$withLeadingVideo = _ref.withLeadingVideo,\n      withLeadingVideo = _ref$withLeadingVideo === void 0 ? false : _ref$withLeadingVideo,\n      _ref$withLeadingCheck = _ref.withLeadingCheckbox,\n      withLeadingCheckbox = _ref$withLeadingCheck === void 0 ? false : _ref$withLeadingCheck,\n      _ref$withLeadingRadio = _ref.withLeadingRadio,\n      withLeadingRadio = _ref$withLeadingRadio === void 0 ? false : _ref$withLeadingRadio,\n      _ref$withLeadingSwitc = _ref.withLeadingSwitch,\n      withLeadingSwitch = _ref$withLeadingSwitc === void 0 ? false : _ref$withLeadingSwitc,\n      _ref$element = _ref.element,\n      Element = _ref$element === void 0 ? \'li\' : _ref$element,\n      className = _ref.className,\n      props = ListDivider_objectWithoutProperties(_ref, ListDivider_excluded);\n\n  var classNames = classnames_default()(listDividerCssClasses.ROOT, (_classnames = {}, ListDivider_defineProperty(_classnames, listDividerCssClasses.LEADING_TEXT, withLeadingText), ListDivider_defineProperty(_classnames, listDividerCssClasses.LEADING_ICON, withLeadingIcon), ListDivider_defineProperty(_classnames, listDividerCssClasses.LEADING_IMAGE, withLeadingImage), ListDivider_defineProperty(_classnames, listDividerCssClasses.LEADING_THUMBNAIL, withLeadingThumbnail), ListDivider_defineProperty(_classnames, listDividerCssClasses.LEADING_VIDEO, withLeadingVideo), ListDivider_defineProperty(_classnames, listDividerCssClasses.LEADING_CHECKBOX, withLeadingCheckbox), ListDivider_defineProperty(_classnames, listDividerCssClasses.LEADING_RADIO, withLeadingRadio), ListDivider_defineProperty(_classnames, listDividerCssClasses.LEADING_SWITCH, withLeadingSwitch), _classnames), className);\n  return /*#__PURE__*/(0,jsx_runtime.jsx)(Element, ListDivider_objectSpread({\n    ref: ref,\n    className: classNames,\n    role: Element === \'li\' ? \'separator\' : undefined\n  }, props));\n});\nListDivider.displayName = \'MDCListDivider\';\nListDivider.propTypes = {\n  withLeadingText: (prop_types_default()).bool,\n  withLeadingIcon: (prop_types_default()).bool,\n  withLeadingImage: (prop_types_default()).bool,\n  withLeadingThumbnail: (prop_types_default()).bool,\n  withLeadingVideo: (prop_types_default()).bool,\n  withLeadingAvatar: (prop_types_default()).bool,\n  withLeadingCheckbox: (prop_types_default()).bool,\n  withLeadingSwitch: (prop_types_default()).bool,\n  withLeadingRadio: (prop_types_default()).bool\n};\n/* harmony default export */ const list_ListDivider = (ListDivider);\n;// CONCATENATED MODULE: ./src/list/ListGroup.jsx\nvar ListGroup_excluded = ["element", "className"];\n\nfunction ListGroup_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction ListGroup_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ListGroup_ownKeys(Object(source), true).forEach(function (key) { ListGroup_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ListGroup_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction ListGroup_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction ListGroup_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = ListGroup_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction ListGroup_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\nvar ListGroup = /*#__PURE__*/(0,react.forwardRef)(function (_ref, ref) {\n  var _ref$element = _ref.element,\n      Element = _ref$element === void 0 ? \'div\' : _ref$element,\n      className = _ref.className,\n      props = ListGroup_objectWithoutProperties(_ref, ListGroup_excluded);\n\n  var classNames = classnames_default()(listGroupCssClasses.ROOT, className);\n  return /*#__PURE__*/(0,jsx_runtime.jsx)(Element, ListGroup_objectSpread({\n    ref: ref,\n    className: classNames\n  }, props));\n});\nListGroup.displayName = \'MDCListGroup\';\n/* harmony default export */ const list_ListGroup = (ListGroup);\n;// CONCATENATED MODULE: ./src/list/ListGroupSubheader.jsx\nvar ListGroupSubheader_excluded = ["title", "element", "className", "children"];\n\nfunction ListGroupSubheader_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction ListGroupSubheader_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ListGroupSubheader_ownKeys(Object(source), true).forEach(function (key) { ListGroupSubheader_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ListGroupSubheader_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction ListGroupSubheader_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction ListGroupSubheader_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = ListGroupSubheader_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction ListGroupSubheader_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\n\nvar ListGroupSubheader = /*#__PURE__*/(0,react.forwardRef)(function (_ref, ref) {\n  var title = _ref.title,\n      _ref$element = _ref.element,\n      Element = _ref$element === void 0 ? \'h3\' : _ref$element,\n      className = _ref.className,\n      _ref$children = _ref.children,\n      children = _ref$children === void 0 ? title : _ref$children,\n      props = ListGroupSubheader_objectWithoutProperties(_ref, ListGroupSubheader_excluded);\n\n  var classNames = classnames_default()(listGroupCssClasses.SUBHEADER, className);\n  return /*#__PURE__*/(0,jsx_runtime.jsx)(Element, ListGroupSubheader_objectSpread(ListGroupSubheader_objectSpread({\n    ref: ref,\n    className: classNames\n  }, props), {}, {\n    children: children\n  }));\n});\nListGroupSubheader.displayName = \'MDCListGroupSubheader\';\nListGroupSubheader.propTypes = {\n  title: (prop_types_default()).string\n};\n/* harmony default export */ const list_ListGroupSubheader = (ListGroupSubheader);\n;// CONCATENATED MODULE: ./src/list/index.js\n\n\n\n\n\n\n\n\nlist_List.Item = list_ListItem;\nlist_List.Divider = list_ListDivider;\nlist_List.Group = list_ListGroup;\nlist_ListGroup.Subheader = list_ListGroupSubheader;\nlist_ListItem.Content = list_ListItemContent;\nlist_ListItem.End = list_ListItemEnd;\nlist_ListItem.Start = list_ListItemStart;\n\n;// CONCATENATED MODULE: ./src/menu/MenuItem.jsx\nvar MenuItem_excluded = ["selected", "disabled", "className"];\n\nfunction MenuItem_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction MenuItem_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { MenuItem_ownKeys(Object(source), true).forEach(function (key) { MenuItem_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { MenuItem_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction MenuItem_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction MenuItem_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = MenuItem_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction MenuItem_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\n\nvar MenuItem = /*#__PURE__*/(0,react.forwardRef)(function (_ref, ref) {\n  var _ref$selected = _ref.selected,\n      selected = _ref$selected === void 0 ? false : _ref$selected,\n      _ref$disabled = _ref.disabled,\n      disabled = _ref$disabled === void 0 ? false : _ref$disabled,\n      className = _ref.className,\n      props = MenuItem_objectWithoutProperties(_ref, MenuItem_excluded);\n\n  var classNames = classnames_default()(menu_constants_cssClasses.ITEM, MenuItem_defineProperty({}, menu_constants_cssClasses.ITEM_SELECTED, selected), className);\n  return /*#__PURE__*/(0,jsx_runtime.jsx)(list_ListItem, MenuItem_objectSpread({\n    ref: ref,\n    role: "menuitem",\n    className: classNames,\n    selected: selected,\n    disabled: disabled,\n    "data-disabled": disabled || undefined,\n    tabIndex: disabled ? \'-1\' : undefined\n  }, props));\n});\nMenuItem.displayName = \'MDCMenuItem\';\nMenuItem.propTypes = MenuItem_objectSpread({}, list_ListItem.propTypes);\n/* harmony default export */ const menu_MenuItem = (MenuItem);\n;// CONCATENATED MODULE: ./src/modal/constants.js\nvar modal_constants_cssClasses = {\n  ROOT: \'mdc-modal\',\n  FIXED: \'mdc-modal--fixed\'\n};\n;// CONCATENATED MODULE: ./src/modal/Modal.jsx\n\n\n\n\nfunction Modal(_ref) {\n  var _ref$fixed = _ref.fixed,\n      fixed = _ref$fixed === void 0 ? false : _ref$fixed,\n      _ref$element = _ref.element,\n      element = _ref$element === void 0 ? \'div\' : _ref$element,\n      children = _ref.children;\n  var rootRef = (0,react.useRef)(document.createElement(element));\n  (0,react.useEffect)(function () {\n    var root = rootRef.current;\n    var activeElement = document.activeElement;\n    root.className = modal_constants_cssClasses.ROOT;\n\n    if (fixed) {\n      root.classList.add(modal_constants_cssClasses.FIXED);\n    }\n\n    document.body.appendChild(root);\n    root.firstChild.focus();\n    return function () {\n      activeElement.focus();\n      document.body.removeChild(root);\n    };\n  }, [fixed]);\n  return /*#__PURE__*/(0,react_dom.createPortal)(children, rootRef.current);\n}\nModal.displayName = \'MDCModal\';\nModal.propTypes = {\n  fixed: (prop_types_default()).bool,\n  element: (prop_types_default()).string,\n  children: (prop_types_default()).node.isRequired\n};\n;// CONCATENATED MODULE: ./src/modal/index.js\n\n;// CONCATENATED MODULE: ./src/layer/Layer.jsx\nvar Layer_excluded = ["modal", "fixed", "children"];\n\nfunction Layer_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction Layer_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { Layer_ownKeys(Object(source), true).forEach(function (key) { Layer_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { Layer_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction Layer_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction Layer_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = Layer_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction Layer_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\nfunction Layer(_ref) {\n  var _ref$modal = _ref.modal,\n      modal = _ref$modal === void 0 ? false : _ref$modal,\n      _ref$fixed = _ref.fixed,\n      fixed = _ref$fixed === void 0 ? false : _ref$fixed,\n      children = _ref.children,\n      props = Layer_objectWithoutProperties(_ref, Layer_excluded);\n\n  return /*#__PURE__*/(0,jsx_runtime.jsx)(esm_CSSTransition, Layer_objectSpread(Layer_objectSpread({}, props), {}, {\n    children: modal ? /*#__PURE__*/(0,jsx_runtime.jsx)(Modal, {\n      fixed: fixed,\n      children: children\n    }) : children\n  }));\n}\nLayer.displayName = \'MDCLayer\';\nLayer.propTypes = {\n  modal: (prop_types_default()).bool,\n  fixed: (prop_types_default()).bool\n};\n;// CONCATENATED MODULE: ./src/layer/index.js\n\n;// CONCATENATED MODULE: ./src/menu/utils.js\nfunction utils_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { utils_typeof = function _typeof(obj) { return typeof obj; }; } else { utils_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return utils_typeof(obj); }\n\nvar defaultValues = {\n  top: false,\n  bottom: false,\n  center: false,\n  left: false,\n  right: false\n};\nfunction getAnchorOrigin() {\n  var anchorOrigin = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \'\';\n\n  if (utils_typeof(anchorOrigin) === \'object\') {\n    return Object.assign({}, defaultValues, anchorOrigin);\n  }\n\n  var keys = anchorOrigin.split(\' \');\n  var values = keys.reduce(function (result, key) {\n    result[key] = true;\n    return result;\n  }, {});\n  return Object.assign({}, defaultValues, values);\n}\n;// CONCATENATED MODULE: ./src/menu/MenuSurface.jsx\nvar MenuSurface_excluded = ["anchor", "anchorRef", "anchorOrigin", "transformOrigin", "open", "modal", "quick", "fixed", "persistent", "fullWidth", "onClose", "onKeyDown", "className"];\n\nfunction MenuSurface_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction MenuSurface_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { MenuSurface_ownKeys(Object(source), true).forEach(function (key) { MenuSurface_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { MenuSurface_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction MenuSurface_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction MenuSurface_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = MenuSurface_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction MenuSurface_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\n\n\n\n\n\n\n\nvar MenuSurface = /*#__PURE__*/(0,react.forwardRef)(function (_ref, ref) {\n  var _classnames;\n\n  var anchor = _ref.anchor,\n      _anchorRef = _ref.anchorRef,\n      _ref$anchorOrigin = _ref.anchorOrigin,\n      _anchorOrigin = _ref$anchorOrigin === void 0 ? Origin.TOP_LEFT : _ref$anchorOrigin,\n      _ref$transformOrigin = _ref.transformOrigin,\n      _transformOrigin = _ref$transformOrigin === void 0 ? _anchorOrigin : _ref$transformOrigin,\n      _ref$open = _ref.open,\n      open = _ref$open === void 0 ? false : _ref$open,\n      _ref$modal = _ref.modal,\n      modal = _ref$modal === void 0 ? false : _ref$modal,\n      _ref$quick = _ref.quick,\n      quick = _ref$quick === void 0 ? false : _ref$quick,\n      _ref$fixed = _ref.fixed,\n      fixed = _ref$fixed === void 0 ? false : _ref$fixed,\n      _ref$persistent = _ref.persistent,\n      persistent = _ref$persistent === void 0 ? false : _ref$persistent,\n      _ref$fullWidth = _ref.fullWidth,\n      fullWidth = _ref$fullWidth === void 0 ? false : _ref$fullWidth,\n      _ref$onClose = _ref.onClose,\n      onClose = _ref$onClose === void 0 ? Function.prototype : _ref$onClose,\n      _ref$onKeyDown = _ref.onKeyDown,\n      onKeyDown = _ref$onKeyDown === void 0 ? Function.prototype : _ref$onKeyDown,\n      className = _ref.className,\n      props = MenuSurface_objectWithoutProperties(_ref, MenuSurface_excluded);\n\n  var rootRef = (0,react.useRef)();\n  var anchorRef = (0,react.useRef)(_anchorRef === null || _anchorRef === void 0 ? void 0 : _anchorRef.current);\n  (0,react.useImperativeHandle)(ref, function () {\n    return rootRef.current;\n  });\n  (0,react.useEffect)(function () {\n    if (!_anchorRef) return;\n    anchorRef.current = _anchorRef.current;\n  }, [_anchorRef]);\n  useUpdated(function () {\n    if (!open || persistent) return;\n\n    function handleBodyClick(event) {\n      onClose(event);\n    }\n\n    document.body.addEventListener(\'click\', handleBodyClick, true);\n    return function () {\n      document.body.removeEventListener(\'click\', handleBodyClick, true);\n    };\n  }, [open, persistent, onClose]);\n  useUpdated(function () {\n    if (!open || !rootRef.current || !anchorRef.current) return;\n    var anchor = anchorRef.current;\n    var _rootRef$current = rootRef.current,\n        width = _rootRef$current.clientWidth,\n        height = _rootRef$current.clientHeight;\n    var anchorClientRect = anchor.getBoundingClientRect();\n    var anchorDimensions = modal ? anchorClientRect : {\n      top: anchor.offsetTop,\n      left: anchor.offsetLeft,\n      bottom: anchor.offsetTop + anchor.offsetHeight,\n      right: anchor.offsetLeft + anchor.offsetWidth,\n      width: anchor.offsetWidth,\n      height: anchor.offsetHeight\n    };\n    var style = {\n      top: anchorDimensions.top,\n      left: anchorDimensions.left,\n      width: fullWidth ? \'100%\' : undefined,\n      maxWidth: fullWidth ? "".concat(anchorDimensions.width, "px") : undefined,\n      position: fixed ? \'fixed\' : \'absolute\',\n      transformOrigin: _transformOrigin\n    };\n    var scrollY = modal && !fixed ? window.scrollY : 0;\n    var scrollX = modal && !fixed ? window.scrollX : 0;\n    var anchorOrigin = getAnchorOrigin(_anchorOrigin);\n    var transformOrigin = getAnchorOrigin(_transformOrigin);\n\n    if (anchorOrigin.top) {\n      style.top = anchorDimensions.top;\n    } else if (anchorOrigin.bottom) {\n      style.top = anchorDimensions.bottom;\n    }\n\n    if (anchorOrigin.left) {\n      style.left = anchorDimensions.left;\n    } else if (anchorOrigin.right) {\n      style.left = anchorDimensions.right;\n    }\n\n    if (transformOrigin.top) {\n      var top = scrollY + style.top;\n      var bottomOverflow = scrollY + (anchorOrigin.bottom ? anchorClientRect.bottom : anchorClientRect.top) + height - window.innerHeight;\n      style.top = bottomOverflow > 0 ? top - bottomOverflow : top;\n    } else if (transformOrigin.bottom) {\n      var _top = scrollY + style.top - height;\n\n      var topOverflow = scrollY + (anchorOrigin.bottom ? anchorClientRect.bottom : anchorClientRect.top) - height;\n      style.top = topOverflow > 0 ? _top : 0;\n    }\n\n    if (transformOrigin.left) {\n      var left = style.left;\n      var rightOverflow = scrollX + window.innerWidth - (anchorOrigin.left ? anchorClientRect.left : anchorClientRect.right) + width;\n      style.left = rightOverflow > 0 ? left : left - Math.abs(rightOverflow);\n    } else if (transformOrigin.right) {\n      var _left = style.left - width;\n\n      var leftOverflow = scrollX + (anchorOrigin.right ? anchorClientRect.right : anchorClientRect.left) - width;\n      style.left = leftOverflow > 0 ? _left : 0;\n    }\n\n    rootRef.current.style.top = "".concat(style.top, "px");\n    rootRef.current.style.left = "".concat(style.left, "px");\n    rootRef.current.style.position = style.position;\n    rootRef.current.style.width = style.width;\n    rootRef.current.style.maxWidth = style.maxWidth;\n    rootRef.current.style.transformOrigin = style.transformOrigin;\n  }, [open, modal, fixed, _anchorOrigin, _transformOrigin]);\n  var handleKeyDown = (0,react.useCallback)(function (event) {\n    if (event.key === \'Escape\' && !persistent) {\n      event.stopPropagation();\n      onClose(event);\n    }\n\n    onKeyDown(event);\n  }, [persistent, onKeyDown, onClose]);\n\n  var isBelowAnchor = _anchorOrigin.includes(\'bottom\') && _transformOrigin.includes(\'top\');\n\n  var classNames = classnames_default()(menu_constants_cssClasses.SURFACE, (_classnames = {}, MenuSurface_defineProperty(_classnames, menu_constants_cssClasses.SURFACE_FIXED, fixed), MenuSurface_defineProperty(_classnames, menu_constants_cssClasses.SURFACE_BELOW_ANCHOR, isBelowAnchor), _classnames), className);\n  return /*#__PURE__*/(0,jsx_runtime.jsxs)(jsx_runtime.Fragment, {\n    children: [anchor && (0,react.cloneElement)(anchor, {\n      ref: anchorRef\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Layer, {\n      "in": open,\n      modal: modal,\n      timeout: quick ? 0 : {\n        enter: menu_constants_numbers.TRANSITION_OPEN_DURATION,\n        exit: menu_constants_numbers.TRANSITION_CLOSE_DURATION\n      },\n      classNames: quick ? {\n        enterDone: menu_constants_cssClasses.SURFACE_OPEN\n      } : {\n        enter: menu_constants_cssClasses.SURFACE_ANIMATING_OPEN,\n        enterActive: menu_constants_cssClasses.SURFACE_ANIMATING_OPEN,\n        enterDone: menu_constants_cssClasses.SURFACE_OPEN,\n        exit: menu_constants_cssClasses.SURFACE_OPEN,\n        exitActive: menu_constants_cssClasses.SURFACE_ANIMATING_CLOSED\n      },\n      mountOnEnter: true,\n      unmountOnExit: true,\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)("div", MenuSurface_objectSpread({\n        ref: rootRef,\n        className: classNames,\n        onKeyDown: handleKeyDown\n      }, props))\n    })]\n  });\n});\nMenuSurface.displayName = \'MDCMenuSurface\';\nMenuSurface.propTypes = {\n  anchor: (prop_types_default()).element,\n  anchorRef: (prop_types_default()).object,\n  anchorOrigin: prop_types_default().oneOf(Object.values(Origin)),\n  open: (prop_types_default()).bool,\n  modal: (prop_types_default()).bool,\n  quick: (prop_types_default()).bool,\n  fixed: (prop_types_default()).bool,\n  persistent: (prop_types_default()).bool,\n  fullWidth: (prop_types_default()).bool,\n  onClose: (prop_types_default()).func\n};\n/* harmony default export */ const menu_MenuSurface = (MenuSurface);\n;// CONCATENATED MODULE: ./src/menu/Menu.jsx\nvar Menu_excluded = ["open", "items", "listProps", "children", "className"];\n\nfunction Menu_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction Menu_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { Menu_ownKeys(Object(source), true).forEach(function (key) { Menu_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { Menu_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction Menu_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction Menu_slicedToArray(arr, i) { return Menu_arrayWithHoles(arr) || Menu_iterableToArrayLimit(arr, i) || Menu_unsupportedIterableToArray(arr, i) || Menu_nonIterableRest(); }\n\nfunction Menu_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction Menu_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return Menu_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return Menu_arrayLikeToArray(o, minLen); }\n\nfunction Menu_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction Menu_iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction Menu_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction Menu_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = Menu_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction Menu_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\n\n\n\n\n\n\nvar Menu = /*#__PURE__*/(0,react.forwardRef)(function (_ref, ref) {\n  var open = _ref.open,\n      items = _ref.items,\n      _ref$listProps = _ref.listProps,\n      listProps = _ref$listProps === void 0 ? {} : _ref$listProps,\n      _ref$children = _ref.children,\n      children = _ref$children === void 0 ? items === null || items === void 0 ? void 0 : items.map(function (item) {\n    return (0,react.createElement)(menu_MenuItem, item);\n  }) : _ref$children,\n      className = _ref.className,\n      props = Menu_objectWithoutProperties(_ref, Menu_excluded);\n\n  var listRef = (0,react.useRef)();\n\n  var _useState = (0,react.useState)(0),\n      _useState2 = Menu_slicedToArray(_useState, 2),\n      focusedChildIndex = _useState2[0],\n      setFocusedChildIndex = _useState2[1];\n\n  (0,react.useEffect)(function () {\n    if (open) {\n      setFocusedChildIndex(react.Children.toArray(children).findIndex(function (i) {\n        return i.props.selected;\n      }));\n    }\n  }, [open, children]);\n  useUpdated(function () {\n    if (open) {\n      var _listRef$current$chil;\n\n      (_listRef$current$chil = listRef.current.children[focusedChildIndex]) === null || _listRef$current$chil === void 0 ? void 0 : _listRef$current$chil.focus();\n    }\n  }, [focusedChildIndex, open]);\n  var handleKeyDown = (0,react.useCallback)(function (event) {\n    event.preventDefault();\n\n    if (event.key === \'ArrowDown\') {\n      setFocusedChildIndex(function (index) {\n        var nextIndex = index + 1;\n        return nextIndex < listRef.current.children.length ? nextIndex : index;\n      });\n    } else if (event.key === \'ArrowUp\') {\n      setFocusedChildIndex(function (index) {\n        var nextIndex = index - 1;\n        return nextIndex >= 0 ? nextIndex : index;\n      });\n    }\n  }, []);\n  var classNames = classnames_default()(menu_constants_cssClasses.ROOT, className);\n  return /*#__PURE__*/(0,jsx_runtime.jsx)(menu_MenuSurface, Menu_objectSpread(Menu_objectSpread({\n    ref: ref,\n    open: open,\n    className: classNames,\n    onKeyDown: handleKeyDown\n  }, props), {}, {\n    children: /*#__PURE__*/(0,jsx_runtime.jsx)(list_List, Menu_objectSpread(Menu_objectSpread({\n      ref: listRef,\n      role: "menu",\n      "aria-hidden": "true",\n      "aria-orientation": "vertical",\n      tabIndex: open ? 0 : -1\n    }, listProps), {}, {\n      children: react.Children.map(children, function (item, index) {\n        return /*#__PURE__*/(0,jsx_runtime.jsx)(Clone, {\n          component: item,\n          tabIndex: index === focusedChildIndex ? 0 : -1\n        });\n      })\n    }))\n  }));\n});\nMenu.displayName = \'MDCMenu\';\nMenu.propTypes = Menu_objectSpread(Menu_objectSpread({}, menu_MenuSurface.propTypes), {}, {\n  listProps: (prop_types_default()).object\n});\n/* harmony default export */ const menu_Menu = (Menu);\n;// CONCATENATED MODULE: ./src/menu/MenuAnchor.jsx\nvar MenuAnchor_excluded = ["wrap", "element", "className", "children"];\n\nfunction MenuAnchor_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction MenuAnchor_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { MenuAnchor_ownKeys(Object(source), true).forEach(function (key) { MenuAnchor_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { MenuAnchor_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction MenuAnchor_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction MenuAnchor_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = MenuAnchor_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction MenuAnchor_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\nvar MenuAnchor = /*#__PURE__*/(0,react.forwardRef)(function (_ref, ref) {\n  var _ref$wrap = _ref.wrap,\n      wrap = _ref$wrap === void 0 ? true : _ref$wrap,\n      _ref$element = _ref.element,\n      element = _ref$element === void 0 ? \'div\' : _ref$element,\n      className = _ref.className,\n      children = _ref.children,\n      props = MenuAnchor_objectWithoutProperties(_ref, MenuAnchor_excluded);\n\n  return wrap ? (0,react.createElement)(element, MenuAnchor_objectSpread({\n    ref: ref,\n    className: classnames_default()(menu_constants_cssClasses.SURFACE_ANCHOR, className)\n  }, props), children) : (0,react.cloneElement)(children, MenuAnchor_objectSpread({\n    ref: ref,\n    className: classnames_default()(children.props.className, menu_constants_cssClasses.SURFACE_ANCHOR)\n  }, props));\n});\nMenuAnchor.displayName = \'MDCMenuAnchor\';\n/* harmony default export */ const menu_MenuAnchor = (MenuAnchor);\n;// CONCATENATED MODULE: ./src/menu/MenuSelectionGroup.jsx\nvar MenuSelectionGroup_excluded = ["element"];\n\nfunction MenuSelectionGroup_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction MenuSelectionGroup_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { MenuSelectionGroup_ownKeys(Object(source), true).forEach(function (key) { MenuSelectionGroup_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { MenuSelectionGroup_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction MenuSelectionGroup_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction MenuSelectionGroup_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = MenuSelectionGroup_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction MenuSelectionGroup_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\nvar MenuSelectionGroup = /*#__PURE__*/(0,react.forwardRef)(function (_ref, ref) {\n  var _ref$element = _ref.element,\n      Element = _ref$element === void 0 ? \'ul\' : _ref$element,\n      props = MenuSelectionGroup_objectWithoutProperties(_ref, MenuSelectionGroup_excluded);\n\n  return /*#__PURE__*/(0,jsx_runtime.jsx)("li", {\n    ref: ref,\n    children: /*#__PURE__*/(0,jsx_runtime.jsx)(Element, MenuSelectionGroup_objectSpread({\n      className: "mdc-menu__selection-group"\n    }, props))\n  });\n});\nMenuSelectionGroup.displayName = \'MDCMenuSelectionGroup\';\n/* harmony default export */ const menu_MenuSelectionGroup = (MenuSelectionGroup);\n;// CONCATENATED MODULE: ./src/menu/MenuSelectionGroupIcon.jsx\nfunction MenuSelectionGroupIcon_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction MenuSelectionGroupIcon_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { MenuSelectionGroupIcon_ownKeys(Object(source), true).forEach(function (key) { MenuSelectionGroupIcon_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { MenuSelectionGroupIcon_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction MenuSelectionGroupIcon_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n\n\nfunction MenuSelectionGroupIcon(props) {\n  return /*#__PURE__*/(0,jsx_runtime.jsx)(icon_Icon, MenuSelectionGroupIcon_objectSpread({\n    className: "mdc-menu__selection-group-icon"\n  }, props));\n}\nMenuSelectionGroupIcon.displayName = \'MDCMenuSelectionGroupIcon\';\n;// CONCATENATED MODULE: ./src/menu/index.js\n\n\n\n\n\n\n\nmenu_Menu.Anchor = menu_MenuAnchor;\nmenu_Menu.Item = menu_MenuItem;\nmenu_Menu.Origin = Origin;\nmenu_Menu.Surface = menu_MenuSurface;\nmenu_Menu.SelectionGroup = menu_MenuSelectionGroup;\nmenu_Menu.SelectionGroupIcon = MenuSelectionGroupIcon;\n\n;// CONCATENATED MODULE: ./src/select/constants.js\nvar select_constants_cssClasses = {\n  ROOT: \'mdc-select\',\n  FILLED: \'mdc-select--filled\',\n  OUTLINED: \'mdc-select--outlined\',\n  ACTIVATED: \'mdc-select--activated\',\n  DISABLED: \'mdc-select--disabled\',\n  FOCUSED: \'mdc-select--focused\',\n  REQUIRED: \'mdc-select--required\',\n  INVALID: \'mdc-select--invalid\',\n  NO_LABEL: \'mdc-select--no-label\',\n  WITH_LEADING_ICON: \'mdc-select--with-leading-icon\',\n  ANCHOR: \'mdc-select__anchor\',\n  DROPDOWN_ICON: \'mdc-select__dropdown-icon\',\n  DROPDOWN_ICON_GRAPHIC: \'mdc-select__dropdown-icon-graphic\',\n  DROPDOWN_ICON_INACTIVE: \'mdc-select__dropdown-icon-inactive\',\n  DROPDOWN_ICON_ACTIVE: \'mdc-select__dropdown-icon-active\',\n  ICON: \'mdc-select__icon\',\n  MENU: \'mdc-select__menu\',\n  MENU_INVALID: \'mdc-select__menu--invalid\',\n  RIPPLE: \'mdc-select__ripple\',\n  SELECTED_TEXT: \'mdc-select__selected-text\',\n  SELECTED_TEXT_CONTAINER: \'mdc-select__selected-text-container\',\n  HELPER_TEXT: \'mdc-select-helper-text\',\n  VALIDATION_MESSAGE: \'mdc-select-helper-text--validation-msg\',\n  VALIDATION_MESSAGE_PERSISTENT: \'mdc-select-helper-text--validation-msg-persistent\'\n};\nvar optionCssClasses = {\n  ROOT: \'mdc-select__option\',\n  ONE_LINE: \'mdc-select__one-line-option\',\n  TWO_LINE: \'mdc-select__two-line-option\',\n  WITH_LEADING_CONTENT: \'mdc-select__option-with-leading-content\',\n  WITH_META: \'mdc-select__option-with-meta\'\n};\n;// CONCATENATED MODULE: ./src/select/DropdownIcon.jsx\n\n\n\n\nvar DropdownIcon = function DropdownIcon() {\n  return /*#__PURE__*/(0,jsx_runtime.jsx)("span", {\n    className: select_constants_cssClasses.DROPDOWN_ICON,\n    children: /*#__PURE__*/(0,jsx_runtime.jsxs)("svg", {\n      className: select_constants_cssClasses.DROPDOWN_ICON_GRAPHIC,\n      viewBox: "7 10 10 5",\n      focusable: "false",\n      children: [/*#__PURE__*/(0,jsx_runtime.jsx)("polygon", {\n        className: select_constants_cssClasses.DROPDOWN_ICON_INACTIVE,\n        stroke: "none",\n        fillRule: "evenodd",\n        points: "7 10 12 15 17 10"\n      }), /*#__PURE__*/(0,jsx_runtime.jsx)("polygon", {\n        className: select_constants_cssClasses.DROPDOWN_ICON_ACTIVE,\n        stroke: "none",\n        fillRule: "evenodd",\n        points: "7 15 12 10 17 15"\n      })]\n    })\n  });\n};\n\n/* harmony default export */ const select_DropdownIcon = (DropdownIcon);\n;// CONCATENATED MODULE: ./src/select/SelectOption.jsx\nvar SelectOption_excluded = ["icon", "image", "avatar", "primaryText", "secondaryText", "meta", "selected", "checkbox", "oneLine", "twoLines", "className", "onClick"];\n\nfunction SelectOption_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction SelectOption_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { SelectOption_ownKeys(Object(source), true).forEach(function (key) { SelectOption_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { SelectOption_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction SelectOption_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction SelectOption_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = SelectOption_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction SelectOption_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\n\n\nvar SelectOption = /*#__PURE__*/(0,react.forwardRef)(function (_ref, ref) {\n  var _classnames;\n\n  var icon = _ref.icon,\n      image = _ref.image,\n      avatar = _ref.avatar,\n      primaryText = _ref.primaryText,\n      secondaryText = _ref.secondaryText,\n      meta = _ref.meta,\n      selected = _ref.selected,\n      _ref$checkbox = _ref.checkbox,\n      checkbox = _ref$checkbox === void 0 ? false : _ref$checkbox,\n      _ref$oneLine = _ref.oneLine,\n      oneLine = _ref$oneLine === void 0 ? false : _ref$oneLine,\n      _ref$twoLines = _ref.twoLines,\n      twoLines = _ref$twoLines === void 0 ? false : _ref$twoLines,\n      className = _ref.className,\n      onClick = _ref.onClick,\n      props = SelectOption_objectWithoutProperties(_ref, SelectOption_excluded);\n\n  var lines = Boolean(primaryText) + Boolean(secondaryText);\n  var hasLeadingContent = Boolean(checkbox || icon || image || avatar);\n  var classNames = classnames_default()(optionCssClasses.ROOT, (_classnames = {}, SelectOption_defineProperty(_classnames, optionCssClasses.ONE_LINE, oneLine || lines === 1), SelectOption_defineProperty(_classnames, optionCssClasses.TWO_LINE, twoLines || lines === 2), SelectOption_defineProperty(_classnames, optionCssClasses.WITH_LEADING_CONTENT, hasLeadingContent), SelectOption_defineProperty(_classnames, optionCssClasses.WITH_META, meta), _classnames), className);\n  return /*#__PURE__*/(0,jsx_runtime.jsx)(menu_MenuItem, SelectOption_objectSpread({\n    ref: ref,\n    className: classNames,\n    leadingCheckbox: checkbox ? /*#__PURE__*/(0,jsx_runtime.jsx)(checkbox_Checkbox, {\n      checked: selected\n    }) : undefined,\n    icon: icon,\n    image: image,\n    avatar: avatar,\n    primaryText: primaryText,\n    secondaryText: secondaryText,\n    meta: meta,\n    selected: selected,\n    oneLine: oneLine,\n    twoLines: twoLines,\n    withLeadingCheckbox: checkbox,\n    onClick: onClick\n  }, props));\n});\nSelectOption.displayName = \'MDCSelectOption\';\n/* harmony default export */ const select_SelectOption = (SelectOption);\n;// CONCATENATED MODULE: ./src/select/HelperText.jsx\nvar HelperText_excluded = ["validation", "persistent", "element"];\n\nfunction HelperText_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction HelperText_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { HelperText_ownKeys(Object(source), true).forEach(function (key) { HelperText_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { HelperText_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction HelperText_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction HelperText_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = HelperText_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction HelperText_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\n\nvar HelperText = function HelperText(_ref) {\n  var _classnames;\n\n  var _ref$validation = _ref.validation,\n      validation = _ref$validation === void 0 ? false : _ref$validation,\n      _ref$persistent = _ref.persistent,\n      persistent = _ref$persistent === void 0 ? false : _ref$persistent,\n      _ref$element = _ref.element,\n      Element = _ref$element === void 0 ? \'p\' : _ref$element,\n      props = HelperText_objectWithoutProperties(_ref, HelperText_excluded);\n\n  var classNames = classnames_default()(select_constants_cssClasses.HELPER_TEXT, (_classnames = {}, HelperText_defineProperty(_classnames, select_constants_cssClasses.VALIDATION_MESSAGE, validation), HelperText_defineProperty(_classnames, select_constants_cssClasses.VALIDATION_MESSAGE_PERSISTENT, persistent), _classnames));\n  return /*#__PURE__*/(0,jsx_runtime.jsx)(Element, HelperText_objectSpread({\n    className: classNames\n  }, props));\n};\n\nHelperText.displayName = \'MDCSelectHelperText\';\nHelperText.propTypes = {\n  persistent: (prop_types_default()).bool,\n  validation: (prop_types_default()).bool\n};\n/* harmony default export */ const select_HelperText = (HelperText);\n;// CONCATENATED MODULE: ./src/select/Select.jsx\nvar Select_excluded = ["name", "value", "options", "label", "icon", "leadingIcon", "helperText", "filled", "outlined", "multiple", "disabled", "required", "onChange", "menuProps", "listProps", "helperTextProps", "className", "children"];\n\nfunction Select_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction Select_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { Select_ownKeys(Object(source), true).forEach(function (key) { Select_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { Select_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction Select_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || Select_unsupportedIterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return Select_arrayLikeToArray(arr); }\n\nfunction Select_slicedToArray(arr, i) { return Select_arrayWithHoles(arr) || Select_iterableToArrayLimit(arr, i) || Select_unsupportedIterableToArray(arr, i) || Select_nonIterableRest(); }\n\nfunction Select_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction Select_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return Select_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return Select_arrayLikeToArray(o, minLen); }\n\nfunction Select_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction Select_iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction Select_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction Select_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = Select_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction Select_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nvar Select = /*#__PURE__*/(0,react.forwardRef)(function (_ref, ref) {\n  var _classnames;\n\n  var name = _ref.name,\n      value = _ref.value,\n      options = _ref.options,\n      label = _ref.label,\n      icon = _ref.icon,\n      _ref$leadingIcon = _ref.leadingIcon,\n      leadingIcon = _ref$leadingIcon === void 0 ? icon : _ref$leadingIcon,\n      helperText = _ref.helperText,\n      _ref$filled = _ref.filled,\n      filled = _ref$filled === void 0 ? false : _ref$filled,\n      _ref$outlined = _ref.outlined,\n      outlined = _ref$outlined === void 0 ? false : _ref$outlined,\n      _ref$multiple = _ref.multiple,\n      multiple = _ref$multiple === void 0 ? isArray(value) : _ref$multiple,\n      _ref$disabled = _ref.disabled,\n      disabled = _ref$disabled === void 0 ? false : _ref$disabled,\n      _ref$required = _ref.required,\n      required = _ref$required === void 0 ? false : _ref$required,\n      _ref$onChange = _ref.onChange,\n      onChange = _ref$onChange === void 0 ? Function.prototype : _ref$onChange,\n      _ref$menuProps = _ref.menuProps,\n      menuProps = _ref$menuProps === void 0 ? {} : _ref$menuProps,\n      _ref$listProps = _ref.listProps,\n      listProps = _ref$listProps === void 0 ? {} : _ref$listProps,\n      _ref$helperTextProps = _ref.helperTextProps,\n      helperTextProps = _ref$helperTextProps === void 0 ? {} : _ref$helperTextProps,\n      className = _ref.className,\n      _ref$children = _ref.children,\n      children = _ref$children === void 0 ? options === null || options === void 0 ? void 0 : options.map(function (option) {\n    return (0,react.createElement)(select_SelectOption, option);\n  }) : _ref$children,\n      props = Select_objectWithoutProperties(_ref, Select_excluded);\n\n  var anchorRef = (0,react.useRef)();\n  var inputRef = (0,react.useRef)();\n  var menuRef = (0,react.useRef)();\n\n  var _useState = (0,react.useState)(false),\n      _useState2 = Select_slicedToArray(_useState, 2),\n      activated = _useState2[0],\n      setActivated = _useState2[1];\n\n  var _useState3 = (0,react.useState)(false),\n      _useState4 = Select_slicedToArray(_useState3, 2),\n      focused = _useState4[0],\n      setFocused = _useState4[1];\n\n  var _useState5 = (0,react.useState)(false),\n      _useState6 = Select_slicedToArray(_useState5, 2),\n      touched = _useState6[0],\n      setTouched = _useState6[1];\n\n  var _useState7 = (0,react.useState)(),\n      _useState8 = Select_slicedToArray(_useState7, 2),\n      selectedText = _useState8[0],\n      setSelectedText = _useState8[1];\n\n  var _useState9 = (0,react.useState)(),\n      _useState10 = Select_slicedToArray(_useState9, 2),\n      interactionCoords = _useState10[0],\n      setInteractionCoords = _useState10[1];\n\n  (0,react.useEffect)(function () {\n    if (multiple) {\n      var selectedOptions = react.Children.toArray(children).map(function (option) {\n        return option.props;\n      }).filter(function (option) {\n        return value.includes(option.value);\n      });\n\n      var _selectedText = selectedOptions.map(function (option) {\n        return option.text || option.children;\n      }).join(\', \');\n\n      setSelectedText(_selectedText);\n    } else {\n      var selectedOption = react.Children.toArray(children).map(function (option) {\n        return option.props;\n      }).find(function (option) {\n        return option.value === value;\n      });\n\n      if (selectedOption) {\n        setSelectedText(selectedOption.text || selectedOption.children);\n      }\n    }\n  }, [value, multiple, children]);\n  var handleAnchorClick = (0,react.useCallback)(function (event) {\n    if (activated) {\n      setActivated(false);\n      setFocused(false);\n    } else {\n      var targetClientRect = event.target.getBoundingClientRect();\n      setInteractionCoords({\n        x: event.clientX - targetClientRect.left,\n        y: event.clientY - targetClientRect.top\n      });\n      setActivated(true);\n      setFocused(true);\n    }\n  }, [activated]);\n  var handleOptionInteraction = (0,react.useCallback)(function (event) {\n    if (event.type === \'keydown\' && event.key !== \' \' && event.key !== \'Enter\') return;\n    var option = event.currentTarget.dataset;\n    if (option.disabled) return;\n\n    if (multiple) {\n      var values = new Set(value);\n      values.has(option.value) ? values["delete"](option.value) : values.add(option.value);\n      event.target = {\n        name: name,\n        value: _toConsumableArray(values)\n      };\n      onChange(event, _toConsumableArray(values));\n    } else {\n      event.target = {\n        name: name,\n        value: option.value\n      };\n      onChange(event, option.value);\n      setActivated(false);\n      setFocused(false);\n    }\n  }, [value, name, multiple, onChange]);\n  var handleMenuClose = (0,react.useCallback)(function (event) {\n    if (event.type === \'click\' && event.target === anchorRef.current) return;\n    if (multiple && event.type === \'click\' && event.path.includes(menuRef.current)) return;\n    setActivated(false);\n    setFocused(false);\n    setTouched(true);\n  }, [multiple]);\n  var handleKeyDown = (0,react.useCallback)(function (event) {\n    if (event.key === \' \' || event.key === \'Enter\' || event.key === \'ArrowDown\' || event.key === \'ArrowUp\') {\n      event.preventDefault();\n      event.stopPropagation();\n      setActivated(true);\n    }\n  }, []);\n  var hasValue = isArray(value) ? value.length > 0 : Boolean(value);\n  var focusedOrHasValue = focused || hasValue;\n  var isInvalid = touched && required && !hasValue;\n  var classNames = classnames_default()(select_constants_cssClasses.ROOT, (_classnames = {}, Select_defineProperty(_classnames, select_constants_cssClasses.FILLED, filled), Select_defineProperty(_classnames, select_constants_cssClasses.OUTLINED, outlined), Select_defineProperty(_classnames, select_constants_cssClasses.ACTIVATED, activated), Select_defineProperty(_classnames, select_constants_cssClasses.DISABLED, disabled), Select_defineProperty(_classnames, select_constants_cssClasses.FOCUSED, focused), Select_defineProperty(_classnames, select_constants_cssClasses.REQUIRED, required), Select_defineProperty(_classnames, select_constants_cssClasses.INVALID, isInvalid), Select_defineProperty(_classnames, select_constants_cssClasses.NO_LABEL, !label), Select_defineProperty(_classnames, select_constants_cssClasses.WITH_LEADING_ICON, leadingIcon), _classnames), className);\n  return /*#__PURE__*/(0,jsx_runtime.jsxs)(jsx_runtime.Fragment, {\n    children: [/*#__PURE__*/(0,jsx_runtime.jsxs)("div", {\n      ref: ref,\n      className: classNames,\n      children: [name && /*#__PURE__*/(0,jsx_runtime.jsx)("input", Select_objectSpread({\n        ref: inputRef,\n        type: "hidden",\n        name: name,\n        value: value,\n        required: required,\n        disabled: disabled\n      }, props)), /*#__PURE__*/(0,jsx_runtime.jsxs)("div", {\n        ref: anchorRef,\n        className: select_constants_cssClasses.ANCHOR,\n        "aria-required": required || undefined,\n        tabIndex: !disabled ? 0 : undefined,\n        onKeyDown: handleKeyDown,\n        onClick: handleAnchorClick,\n        children: [filled && /*#__PURE__*/(0,jsx_runtime.jsx)("div", {\n          className: select_constants_cssClasses.RIPPLE\n        }), filled && label && /*#__PURE__*/(0,jsx_runtime.jsx)(floating_label_FloatingLabel, {\n          label: label,\n          "float": focusedOrHasValue\n        }), outlined && /*#__PURE__*/(0,jsx_runtime.jsx)(notched_outline_NotchedOutline, {\n          notched: focusedOrHasValue,\n          children: label && /*#__PURE__*/(0,jsx_runtime.jsx)(floating_label_FloatingLabel, {\n            label: label,\n            "float": focusedOrHasValue\n          })\n        }), leadingIcon && /*#__PURE__*/(0,jsx_runtime.jsx)(Clone, {\n          component: leadingIcon,\n          fallback: icon_Icon,\n          className: select_constants_cssClasses.ICON,\n          tabIndex: "0",\n          role: "button"\n        }), /*#__PURE__*/(0,jsx_runtime.jsx)("span", {\n          className: select_constants_cssClasses.SELECTED_TEXT_CONTAINER,\n          children: /*#__PURE__*/(0,jsx_runtime.jsx)("span", {\n            className: select_constants_cssClasses.SELECTED_TEXT,\n            children: selectedText\n          })\n        }), /*#__PURE__*/(0,jsx_runtime.jsx)(select_DropdownIcon, {}), filled && /*#__PURE__*/(0,jsx_runtime.jsx)(line_ripple_LineRipple, {\n          active: focused,\n          transformOrigin: interactionCoords === null || interactionCoords === void 0 ? void 0 : interactionCoords.x\n        })]\n      }), /*#__PURE__*/(0,jsx_runtime.jsx)(menu_Menu, Select_objectSpread(Select_objectSpread({\n        ref: menuRef,\n        anchorRef: anchorRef,\n        className: select_constants_cssClasses.MENU,\n        open: activated,\n        anchorOrigin: Origin.BOTTOM_CENTER,\n        transformOrigin: Origin.TOP_CENTER,\n        fullWidth: true,\n        listProps: listProps,\n        onClose: handleMenuClose\n      }, menuProps), {}, {\n        children: react.Children.map(children, function (option) {\n          var optionValue = option.props.value;\n          return (0,react.cloneElement)(option, {\n            value: undefined,\n            \'data-value\': optionValue,\n            selected: !isUndefined(value) && (multiple ? value.includes(optionValue) : optionValue === value),\n            checkbox: multiple,\n            onClick: handleOptionInteraction,\n            onKeyDown: handleOptionInteraction\n          });\n        })\n      }))]\n    }), helperText && /*#__PURE__*/(0,jsx_runtime.jsx)(select_HelperText, Select_objectSpread(Select_objectSpread({}, helperTextProps), {}, {\n      children: helperText\n    }))]\n  });\n});\nSelect.displayName = \'MDCSelect\';\nSelect.propTypes = {\n  value: (prop_types_default()).any,\n  options: prop_types_default().arrayOf((prop_types_default()).object),\n  label: (prop_types_default()).string,\n  leadingIcon: (prop_types_default()).element,\n  helperText: (prop_types_default()).string,\n  filled: (prop_types_default()).bool,\n  outlined: (prop_types_default()).bool,\n  multiple: (prop_types_default()).bool,\n  disabled: (prop_types_default()).bool,\n  required: (prop_types_default()).bool,\n  children: prop_types_default().oneOfType([(prop_types_default()).element, prop_types_default().arrayOf((prop_types_default()).element)]),\n  menuProps: (prop_types_default()).object,\n  helperTextProps: (prop_types_default()).object,\n  onChange: (prop_types_default()).func\n};\n/* harmony default export */ const select_Select = (Select);\n;// CONCATENATED MODULE: ./src/select/index.js\n\n\nselect_Select.Option = select_SelectOption;\n\n;// CONCATENATED MODULE: ./src/data-table/DataTablePagination.jsx\nvar DataTablePagination_excluded = ["totalCount", "currentPage", "rowsPerPage", "onFirstPage", "onPrevPage", "onNextPage", "onLastPage", "className"];\n\nfunction DataTablePagination_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction DataTablePagination_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { DataTablePagination_ownKeys(Object(source), true).forEach(function (key) { DataTablePagination_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { DataTablePagination_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction DataTablePagination_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction DataTablePagination_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = DataTablePagination_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction DataTablePagination_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\n\n\n\nvar DataTablePagination = /*#__PURE__*/(0,react.forwardRef)(function (_ref, ref) {\n  var totalCount = _ref.totalCount,\n      _ref$currentPage = _ref.currentPage,\n      currentPage = _ref$currentPage === void 0 ? 1 : _ref$currentPage,\n      _ref$rowsPerPage = _ref.rowsPerPage,\n      rowsPerPage = _ref$rowsPerPage === void 0 ? 10 : _ref$rowsPerPage,\n      _ref$onFirstPage = _ref.onFirstPage,\n      onFirstPage = _ref$onFirstPage === void 0 ? Function.prototype : _ref$onFirstPage,\n      _ref$onPrevPage = _ref.onPrevPage,\n      onPrevPage = _ref$onPrevPage === void 0 ? Function.prototype : _ref$onPrevPage,\n      _ref$onNextPage = _ref.onNextPage,\n      onNextPage = _ref$onNextPage === void 0 ? Function.prototype : _ref$onNextPage,\n      _ref$onLastPage = _ref.onLastPage,\n      onLastPage = _ref$onLastPage === void 0 ? Function.prototype : _ref$onLastPage,\n      className = _ref.className,\n      props = DataTablePagination_objectWithoutProperties(_ref, DataTablePagination_excluded);\n\n  var classNames = classnames_default()(data_table_constants_cssClasses.PAGINATION, className);\n  return /*#__PURE__*/(0,jsx_runtime.jsx)("div", DataTablePagination_objectSpread(DataTablePagination_objectSpread({\n    ref: ref,\n    className: classNames\n  }, props), {}, {\n    children: /*#__PURE__*/(0,jsx_runtime.jsxs)("div", {\n      className: data_table_constants_cssClasses.PAGINATION_TRAILING,\n      children: [/*#__PURE__*/(0,jsx_runtime.jsxs)("div", {\n        className: data_table_constants_cssClasses.PAGINATION_ROWS_PER_PAGE,\n        children: [/*#__PURE__*/(0,jsx_runtime.jsx)("div", {\n          className: data_table_constants_cssClasses.PAGINATION_ROWS_PER_PAGE_LABEL,\n          children: "\\u0420\\u044F\\u0434\\u043E\\u0432 \\u043D\\u0430 \\u0441\\u0442\\u0440."\n        }), /*#__PURE__*/(0,jsx_runtime.jsx)(select_Select, {\n          className: data_table_constants_cssClasses.PAGINATION_ROWS_PER_PAGE_SELECT,\n          options: [10, 25, 50, 100].map(function (value) {\n            return {\n              key: value,\n              text: value //selected: value === rowsPerPage\n\n            };\n          })\n        })]\n      }), /*#__PURE__*/(0,jsx_runtime.jsxs)("div", {\n        className: data_table_constants_cssClasses.PAGINATION_NAVIGATION,\n        children: [/*#__PURE__*/(0,jsx_runtime.jsxs)("div", {\n          className: data_table_constants_cssClasses.PAGINATION_TOTAL,\n          children: [currentPage, "\\u2011", rowsPerPage, " \\u0438\\u0437 ", totalCount]\n        }), /*#__PURE__*/(0,jsx_runtime.jsx)(icon_button_IconButton, {\n          className: data_table_constants_cssClasses.PAGINATION_BUTTON,\n          icon: "first_page",\n          onClick: onFirstPage\n        }), /*#__PURE__*/(0,jsx_runtime.jsx)(icon_button_IconButton, {\n          className: data_table_constants_cssClasses.PAGINATION_BUTTON,\n          icon: "chevron_left",\n          onClick: onPrevPage\n        }), /*#__PURE__*/(0,jsx_runtime.jsx)(icon_button_IconButton, {\n          className: data_table_constants_cssClasses.PAGINATION_BUTTON,\n          icon: "chevron_right",\n          onClick: onNextPage\n        }), /*#__PURE__*/(0,jsx_runtime.jsx)(icon_button_IconButton, {\n          className: data_table_constants_cssClasses.PAGINATION_BUTTON,\n          icon: "last_page",\n          onClick: onLastPage\n        })]\n      })]\n    })\n  }));\n});\nDataTablePagination.displayName = \'MDCDataTablePagination\';\n/* harmony default export */ const data_table_DataTablePagination = (DataTablePagination);\n;// CONCATENATED MODULE: ./src/data-table/DataTable.jsx\nvar DataTable_excluded = ["stickyHeader", "inProgress", "pagination", "className", "children"];\n\nfunction DataTable_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction DataTable_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { DataTable_ownKeys(Object(source), true).forEach(function (key) { DataTable_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { DataTable_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction DataTable_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction DataTable_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = DataTable_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction DataTable_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\n\n\n\n\nvar DataTable = /*#__PURE__*/(0,react.forwardRef)(function (_ref, ref) {\n  var _classnames;\n\n  var _ref$stickyHeader = _ref.stickyHeader,\n      stickyHeader = _ref$stickyHeader === void 0 ? false : _ref$stickyHeader,\n      _ref$inProgress = _ref.inProgress,\n      inProgress = _ref$inProgress === void 0 ? false : _ref$inProgress,\n      pagination = _ref.pagination,\n      className = _ref.className,\n      children = _ref.children,\n      props = DataTable_objectWithoutProperties(_ref, DataTable_excluded);\n\n  var classNames = classnames_default()(data_table_constants_cssClasses.ROOT, (_classnames = {}, DataTable_defineProperty(_classnames, data_table_constants_cssClasses.STICKY_HEADER, stickyHeader), DataTable_defineProperty(_classnames, data_table_constants_cssClasses.IN_PROGRESS, inProgress), _classnames), className);\n  return /*#__PURE__*/(0,jsx_runtime.jsxs)("div", DataTable_objectSpread(DataTable_objectSpread({\n    ref: ref,\n    className: classNames\n  }, props), {}, {\n    children: [/*#__PURE__*/(0,jsx_runtime.jsx)("div", {\n      className: data_table_constants_cssClasses.TABLE_CONTAINER,\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)("table", {\n        className: data_table_constants_cssClasses.TABLE,\n        children: children\n      })\n    }), inProgress && /*#__PURE__*/(0,jsx_runtime.jsx)(data_table_DataTableProgressIndicator, {}), pagination && /*#__PURE__*/(0,jsx_runtime.jsx)(data_table_DataTablePagination, DataTable_objectSpread({}, pagination))]\n  }));\n});\nDataTable.displayName = \'MDCDataTable\';\nDataTable.propTypes = {\n  stickyHeader: (prop_types_default()).bool,\n  inProgress: (prop_types_default()).bool\n};\n/* harmony default export */ const data_table_DataTable = (DataTable);\n;// CONCATENATED MODULE: ./src/data-table/DataTableCell.jsx\nvar DataTableCell_excluded = ["checkbox", "numeric", "element", "scope", "className", "children"];\n\nfunction DataTableCell_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction DataTableCell_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { DataTableCell_ownKeys(Object(source), true).forEach(function (key) { DataTableCell_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { DataTableCell_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction DataTableCell_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction DataTableCell_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = DataTableCell_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction DataTableCell_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\n\n\nvar DataTableCell = /*#__PURE__*/(0,react.forwardRef)(function (_ref, ref) {\n  var _classnames;\n\n  var _ref$checkbox = _ref.checkbox,\n      checkbox = _ref$checkbox === void 0 ? false : _ref$checkbox,\n      _ref$numeric = _ref.numeric,\n      numeric = _ref$numeric === void 0 ? false : _ref$numeric,\n      _ref$element = _ref.element,\n      Element = _ref$element === void 0 ? \'td\' : _ref$element,\n      scope = _ref.scope,\n      className = _ref.className,\n      children = _ref.children,\n      props = DataTableCell_objectWithoutProperties(_ref, DataTableCell_excluded);\n\n  var classNames = classnames_default()(data_table_constants_cssClasses.CELL, (_classnames = {}, DataTableCell_defineProperty(_classnames, data_table_constants_cssClasses.CELL_CHECKBOX, checkbox), DataTableCell_defineProperty(_classnames, data_table_constants_cssClasses.CELL_NUMERIC, numeric), _classnames), className);\n  return /*#__PURE__*/(0,jsx_runtime.jsx)(Element, DataTableCell_objectSpread(DataTableCell_objectSpread({\n    ref: ref,\n    className: classNames,\n    scope: scope\n  }, props), {}, {\n    children: checkbox ? /*#__PURE__*/(0,jsx_runtime.jsx)(Clone, {\n      component: children,\n      className: data_table_constants_cssClasses.ROW_CHECKBOX\n    }) : children\n  }));\n});\nDataTableCell.displayName = \'MDCDataTableCell\';\nDataTableCell.propTypes = {\n  checkbox: (prop_types_default()).bool,\n  numeric: (prop_types_default()).bool\n};\n/* harmony default export */ const data_table_DataTableCell = (DataTableCell);\n;// CONCATENATED MODULE: ./src/data-table/DataTableContent.jsx\nvar DataTableContent_excluded = ["className"];\n\nfunction DataTableContent_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction DataTableContent_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { DataTableContent_ownKeys(Object(source), true).forEach(function (key) { DataTableContent_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { DataTableContent_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction DataTableContent_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction DataTableContent_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = DataTableContent_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction DataTableContent_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\nvar DataTableContent = /*#__PURE__*/(0,react.forwardRef)(function (_ref, ref) {\n  var className = _ref.className,\n      props = DataTableContent_objectWithoutProperties(_ref, DataTableContent_excluded);\n\n  var classNames = classnames_default()(data_table_constants_cssClasses.CONTENT, className);\n  return /*#__PURE__*/(0,jsx_runtime.jsx)("tbody", DataTableContent_objectSpread({\n    ref: ref,\n    className: classNames\n  }, props));\n});\nDataTableContent.displayName = \'MDCDataTableContent\';\n/* harmony default export */ const data_table_DataTableContent = (DataTableContent);\n;// CONCATENATED MODULE: ./src/data-table/DataTableFooter.jsx\nvar DataTableFooter_excluded = ["className"];\n\nfunction DataTableFooter_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction DataTableFooter_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { DataTableFooter_ownKeys(Object(source), true).forEach(function (key) { DataTableFooter_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { DataTableFooter_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction DataTableFooter_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction DataTableFooter_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = DataTableFooter_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction DataTableFooter_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\nvar DataTableFooter = /*#__PURE__*/(0,react.forwardRef)(function (_ref, ref) {\n  var className = _ref.className,\n      props = DataTableFooter_objectWithoutProperties(_ref, DataTableFooter_excluded);\n\n  var classNames = classnames_default()(data_table_constants_cssClasses.FOOTER, className);\n  return /*#__PURE__*/(0,jsx_runtime.jsx)("tfoot", DataTableFooter_objectSpread({\n    ref: ref,\n    className: classNames\n  }, props));\n});\nDataTableFooter.displayName = \'MDCDataTableFooter\';\n/* harmony default export */ const data_table_DataTableFooter = (DataTableFooter);\n;// CONCATENATED MODULE: ./src/data-table/DataTableHeader.jsx\nvar DataTableHeader_excluded = ["className"];\n\nfunction DataTableHeader_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction DataTableHeader_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { DataTableHeader_ownKeys(Object(source), true).forEach(function (key) { DataTableHeader_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { DataTableHeader_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction DataTableHeader_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction DataTableHeader_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = DataTableHeader_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction DataTableHeader_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\nvar DataTableHeader = /*#__PURE__*/(0,react.forwardRef)(function (_ref, ref) {\n  var className = _ref.className,\n      props = DataTableHeader_objectWithoutProperties(_ref, DataTableHeader_excluded);\n\n  var classNames = classnames_default()(data_table_constants_cssClasses.HEADER, className);\n  return /*#__PURE__*/(0,jsx_runtime.jsx)("thead", DataTableHeader_objectSpread({\n    ref: ref,\n    className: classNames\n  }, props));\n});\nDataTableHeader.displayName = \'MDCDataTableHeader\';\n/* harmony default export */ const data_table_DataTableHeader = (DataTableHeader);\n;// CONCATENATED MODULE: ./src/data-table/DataTableHeaderCell.jsx\nvar DataTableHeaderCell_excluded = ["value", "label", "checkbox", "numeric", "sort", "sortIconButton", "onSort", "element", "role", "scope", "className", "children"];\n\nfunction DataTableHeaderCell_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction DataTableHeaderCell_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { DataTableHeaderCell_ownKeys(Object(source), true).forEach(function (key) { DataTableHeaderCell_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { DataTableHeaderCell_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction DataTableHeaderCell_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction DataTableHeaderCell_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = DataTableHeaderCell_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction DataTableHeaderCell_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\n\n\n\n\nvar DataTableHeaderCell = /*#__PURE__*/(0,react.forwardRef)(function (_ref, ref) {\n  var _classnames;\n\n  var value = _ref.value,\n      label = _ref.label,\n      _ref$checkbox = _ref.checkbox,\n      checkbox = _ref$checkbox === void 0 ? false : _ref$checkbox,\n      _ref$numeric = _ref.numeric,\n      numeric = _ref$numeric === void 0 ? false : _ref$numeric,\n      sort = _ref.sort,\n      _ref$sortIconButton = _ref.sortIconButton,\n      sortIconButton = _ref$sortIconButton === void 0 ? \'arrow_upward\' : _ref$sortIconButton,\n      _ref$onSort = _ref.onSort,\n      onSort = _ref$onSort === void 0 ? Function.prototype : _ref$onSort,\n      _ref$element = _ref.element,\n      Element = _ref$element === void 0 ? \'th\' : _ref$element,\n      _ref$role = _ref.role,\n      role = _ref$role === void 0 ? \'columnheader\' : _ref$role,\n      _ref$scope = _ref.scope,\n      scope = _ref$scope === void 0 ? \'col\' : _ref$scope,\n      className = _ref.className,\n      _ref$children = _ref.children,\n      children = _ref$children === void 0 ? label : _ref$children,\n      props = DataTableHeaderCell_objectWithoutProperties(_ref, DataTableHeaderCell_excluded);\n\n  var handleSortIconClick = (0,react.useCallback)(function () {\n    onSort({\n      label: label,\n      value: value\n    });\n  }, [label, value, onSort]);\n  var withSort = typeof sort === \'number\';\n  var classNames = classnames_default()(data_table_constants_cssClasses.HEADER_CELL, (_classnames = {}, DataTableHeaderCell_defineProperty(_classnames, data_table_constants_cssClasses.HEADER_CELL_CHECKBOX, checkbox), DataTableHeaderCell_defineProperty(_classnames, data_table_constants_cssClasses.HEADER_CELL_NUMERIC, numeric), DataTableHeaderCell_defineProperty(_classnames, data_table_constants_cssClasses.HEADER_CELL_WITH_SORT, withSort), DataTableHeaderCell_defineProperty(_classnames, data_table_constants_cssClasses.HEADER_CELL_SORTED, sort === 1 || sort === -1), DataTableHeaderCell_defineProperty(_classnames, data_table_constants_cssClasses.HEADER_CELL_SORTED_DESC, sort === -1), _classnames), className);\n  return /*#__PURE__*/(0,jsx_runtime.jsx)(Element, DataTableHeaderCell_objectSpread(DataTableHeaderCell_objectSpread({\n    ref: ref,\n    className: classNames,\n    role: role,\n    scope: scope\n  }, props), {}, {\n    children: withSort ? /*#__PURE__*/(0,jsx_runtime.jsxs)("div", {\n      className: data_table_constants_cssClasses.HEADER_CELL_WRAPPER,\n      children: [/*#__PURE__*/(0,jsx_runtime.jsx)("div", {\n        className: data_table_constants_cssClasses.HEADER_CELL_LABEL,\n        children: children\n      }), /*#__PURE__*/(0,jsx_runtime.jsx)(Clone, {\n        component: sortIconButton,\n        fallback: icon_button_IconButton,\n        className: data_table_constants_cssClasses.SORT_ICON_BUTTON,\n        onClick: handleSortIconClick\n      }), /*#__PURE__*/(0,jsx_runtime.jsx)("div", {\n        className: data_table_constants_cssClasses.SORT_STATUS_LABEL,\n        "aria-hidden": "true"\n      })]\n    }) : checkbox ? /*#__PURE__*/(0,jsx_runtime.jsx)(Clone, {\n      component: children,\n      className: data_table_constants_cssClasses.HEADER_ROW_CHECKBOX\n    }) : children\n  }));\n});\nDataTableHeaderCell.displayName = \'MDCDataTableHeaderCell\';\nDataTableHeaderCell.propTypes = {\n  value: (prop_types_default()).any,\n  label: (prop_types_default()).string,\n  numeric: (prop_types_default()).bool,\n  checkbox: (prop_types_default()).bool,\n  sort: prop_types_default().oneOf([-1, 0, 1]),\n  sortIconButton: (prop_types_default()).node,\n  onSort: (prop_types_default()).func\n};\n/* harmony default export */ const data_table_DataTableHeaderCell = (DataTableHeaderCell);\n;// CONCATENATED MODULE: ./src/data-table/DataTableHeaderRow.jsx\nvar DataTableHeaderRow_excluded = ["className"];\n\nfunction DataTableHeaderRow_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction DataTableHeaderRow_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { DataTableHeaderRow_ownKeys(Object(source), true).forEach(function (key) { DataTableHeaderRow_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { DataTableHeaderRow_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction DataTableHeaderRow_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction DataTableHeaderRow_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = DataTableHeaderRow_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction DataTableHeaderRow_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\nvar DataTableHeaderRow = /*#__PURE__*/(0,react.forwardRef)(function (_ref, ref) {\n  var className = _ref.className,\n      props = DataTableHeaderRow_objectWithoutProperties(_ref, DataTableHeaderRow_excluded);\n\n  var classNames = classnames_default()(data_table_constants_cssClasses.HEADER_ROW, className);\n  return /*#__PURE__*/(0,jsx_runtime.jsx)("tr", DataTableHeaderRow_objectSpread({\n    ref: ref,\n    className: classNames\n  }, props));\n});\nDataTableHeaderRow.displayName = \'MDCDataTableHeaderRow\';\n/* harmony default export */ const data_table_DataTableHeaderRow = (DataTableHeaderRow);\n;// CONCATENATED MODULE: ./src/data-table/DataTableRow.jsx\nvar DataTableRow_excluded = ["selected", "className"];\n\nfunction DataTableRow_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction DataTableRow_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { DataTableRow_ownKeys(Object(source), true).forEach(function (key) { DataTableRow_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { DataTableRow_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction DataTableRow_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction DataTableRow_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = DataTableRow_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction DataTableRow_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\n\nvar DataTableRow = /*#__PURE__*/(0,react.forwardRef)(function (_ref, ref) {\n  var _ref$selected = _ref.selected,\n      selected = _ref$selected === void 0 ? false : _ref$selected,\n      className = _ref.className,\n      props = DataTableRow_objectWithoutProperties(_ref, DataTableRow_excluded);\n\n  var classNames = classnames_default()(data_table_constants_cssClasses.ROW, DataTableRow_defineProperty({}, data_table_constants_cssClasses.ROW_SELECTED, selected), className);\n  return /*#__PURE__*/(0,jsx_runtime.jsx)("tr", DataTableRow_objectSpread({\n    ref: ref,\n    className: classNames\n  }, props));\n});\nDataTableRow.displayName = \'MDCDataTableRow\';\nDataTableRow.propTypes = {\n  selected: (prop_types_default()).bool\n};\n/* harmony default export */ const data_table_DataTableRow = (DataTableRow);\n;// CONCATENATED MODULE: ./src/data-table/index.js\n\n\n\n\n\n\n\n\n\ndata_table_DataTable.Cell = data_table_DataTableCell;\ndata_table_DataTable.Content = data_table_DataTableContent;\ndata_table_DataTable.Footer = data_table_DataTableFooter;\ndata_table_DataTable.Header = data_table_DataTableHeader;\ndata_table_DataTable.HeaderCell = data_table_DataTableHeaderCell;\ndata_table_DataTable.HeaderRow = data_table_DataTableHeaderRow;\ndata_table_DataTable.Pagination = data_table_DataTablePagination;\ndata_table_DataTable.Row = data_table_DataTableRow;\n\n;// CONCATENATED MODULE: ./src/dialog/constants.js\nvar dialog_constants_numbers = {\n  DIALOG_ANIMATION_OPEN_TIME_MS: 150,\n  DIALOG_ANIMATION_CLOSE_TIME_MS: 75,\n  DEFAULT_ACTIONS_HEIGHT: 52\n};\nvar dialog_constants_cssClasses = {\n  ROOT: \'mdc-dialog\',\n  HEADER: \'mdc-dialog__header\',\n  TITLE: \'mdc-dialog__title\',\n  CLOSE: \'mdc-dialog__close\',\n  CONTENT: \'mdc-dialog__content\',\n  CONTAINER: \'mdc-dialog__container\',\n  ACTIONS: \'mdc-dialog__actions\',\n  BUTTON: \'mdc-dialog__button\',\n  SURFACE: \'mdc-dialog__surface\',\n  SCRIM: \'mdc-dialog__scrim\',\n  OPEN: \'mdc-dialog--open\',\n  OPENING: \'mdc-dialog--opening\',\n  CLOSING: \'mdc-dialog--closing\',\n  FULLSCREEN: \'mdc-dialog--fullscreen\',\n  SHEET: \'mdc-dialog--sheet\',\n  SCROLLABLE: \'mdc-dialog--scrollable\',\n  STACKED: \'mdc-dialog--stacked\',\n  NO_CONTENT_PADDING: \'mdc-dialog--no-content-padding\',\n  SCROLL_DIVIDER_HEADER: \'mdc-dialog-scroll-divider-header\',\n  SCROLL_DIVIDER_FOOTER: \'mdc-dialog-scroll-divider-footer\',\n  SCROLL_LOCK: \'mdc-dialog-scroll-lock\'\n};\n;// CONCATENATED MODULE: ./src/dialog/DialogHeader.jsx\nvar DialogHeader_excluded = ["title", "closeIcon", "fullscreen", "onClose", "children"];\n\nfunction DialogHeader_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction DialogHeader_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { DialogHeader_ownKeys(Object(source), true).forEach(function (key) { DialogHeader_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { DialogHeader_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction DialogHeader_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction DialogHeader_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = DialogHeader_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction DialogHeader_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\n\n\nvar DialogHeader = /*#__PURE__*/(0,react.forwardRef)(function (_ref, ref) {\n  var title = _ref.title,\n      closeIcon = _ref.closeIcon,\n      fullscreen = _ref.fullscreen,\n      onClose = _ref.onClose,\n      children = _ref.children,\n      props = DialogHeader_objectWithoutProperties(_ref, DialogHeader_excluded);\n\n  return /*#__PURE__*/(0,jsx_runtime.jsxs)("div", DialogHeader_objectSpread(DialogHeader_objectSpread({\n    ref: ref,\n    className: dialog_constants_cssClasses.HEADER\n  }, props), {}, {\n    children: [/*#__PURE__*/(0,jsx_runtime.jsx)(Clone, {\n      component: title,\n      fallback: "h2",\n      className: dialog_constants_cssClasses.TITLE\n    }), (fullscreen || closeIcon) && /*#__PURE__*/(0,jsx_runtime.jsx)(Clone, {\n      component: closeIcon,\n      fallback: /*#__PURE__*/(0,jsx_runtime.jsx)(icon_button_IconButton, {\n        icon: "close"\n      }),\n      className: dialog_constants_cssClasses.CLOSE,\n      onClick: onClose\n    }), children]\n  }));\n});\nDialogHeader.displayName = \'MDCDialogHeader\';\n/* harmony default export */ const dialog_DialogHeader = (DialogHeader);\n;// CONCATENATED MODULE: ./src/dialog/DialogContent.jsx\nfunction DialogContent_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction DialogContent_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { DialogContent_ownKeys(Object(source), true).forEach(function (key) { DialogContent_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { DialogContent_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction DialogContent_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n\n\n\nvar DialogContent = /*#__PURE__*/(0,react.forwardRef)(function (props, ref) {\n  return /*#__PURE__*/(0,jsx_runtime.jsx)("div", DialogContent_objectSpread({\n    ref: ref,\n    className: dialog_constants_cssClasses.CONTENT\n  }, props));\n});\nDialogContent.displayName = \'MDCDialogContent\';\n/* harmony default export */ const dialog_DialogContent = (DialogContent);\n;// CONCATENATED MODULE: ./src/dialog/DialogActions.jsx\n\n\n\n\nvar DialogActions = /*#__PURE__*/(0,react.forwardRef)(function (_ref, ref) {\n  var children = _ref.children;\n  return /*#__PURE__*/(0,jsx_runtime.jsx)("div", {\n    ref: ref,\n    className: dialog_constants_cssClasses.ACTIONS,\n    children: /*#__PURE__*/(0,jsx_runtime.jsx)(Clone, {\n      component: children,\n      className: dialog_constants_cssClasses.BUTTON\n    })\n  });\n});\nDialogActions.displayName = \'MDCDialogActions\';\n/* harmony default export */ const dialog_DialogActions = (DialogActions);\n;// CONCATENATED MODULE: ./src/dialog/Dialog.jsx\nvar Dialog_excluded = ["title", "header", "content", "actions", "closeIcon", "open", "appear", "fullscreen", "persistent", "sheet", "stacked", "autoStackButtons", "noContentPadding", "onClose", "element", "className", "children"];\n\nfunction Dialog_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction Dialog_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { Dialog_ownKeys(Object(source), true).forEach(function (key) { Dialog_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { Dialog_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction Dialog_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction Dialog_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = Dialog_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction Dialog_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nvar Dialog = /*#__PURE__*/(0,react.forwardRef)(function (_ref, ref) {\n  var _classnames;\n\n  var title = _ref.title,\n      header = _ref.header,\n      content = _ref.content,\n      actions = _ref.actions,\n      closeIcon = _ref.closeIcon,\n      _ref$open = _ref.open,\n      open = _ref$open === void 0 ? false : _ref$open,\n      _ref$appear = _ref.appear,\n      appear = _ref$appear === void 0 ? false : _ref$appear,\n      _ref$fullscreen = _ref.fullscreen,\n      fullscreen = _ref$fullscreen === void 0 ? false : _ref$fullscreen,\n      _ref$persistent = _ref.persistent,\n      persistent = _ref$persistent === void 0 ? false : _ref$persistent,\n      _ref$sheet = _ref.sheet,\n      sheet = _ref$sheet === void 0 ? false : _ref$sheet,\n      _ref$stacked = _ref.stacked,\n      stacked = _ref$stacked === void 0 ? false : _ref$stacked,\n      _ref$autoStackButtons = _ref.autoStackButtons,\n      autoStackButtons = _ref$autoStackButtons === void 0 ? false : _ref$autoStackButtons,\n      noContentPadding = _ref.noContentPadding,\n      _ref$onClose = _ref.onClose,\n      onClose = _ref$onClose === void 0 ? Function.prototype : _ref$onClose,\n      _ref$element = _ref.element,\n      Element = _ref$element === void 0 ? \'div\' : _ref$element,\n      className = _ref.className,\n      _ref$children = _ref.children,\n      children = _ref$children === void 0 ? content : _ref$children,\n      props = Dialog_objectWithoutProperties(_ref, Dialog_excluded);\n\n  var rootRef = (0,react.useRef)();\n  var contentRef = (0,react.useRef)();\n  var actionsRef = (0,react.useRef)();\n  (0,react.useImperativeHandle)(ref, function () {\n    return rootRef.current;\n  });\n  useUpdated(function () {\n    if (persistent) return;\n\n    function handleDocumentKeyDown(event) {\n      if (event.key === \'Escape\' || event.keyCode === 27) {\n        event.stopPropagation();\n        onClose();\n      }\n    }\n\n    if (open) {\n      document.addEventListener(\'keydown\', handleDocumentKeyDown);\n    } else {\n      document.removeEventListener(\'keydown\', handleDocumentKeyDown);\n    }\n\n    return function () {\n      return document.removeEventListener(\'keydown\', handleDocumentKeyDown);\n    };\n  }, [open, persistent, onClose]);\n  useUpdated(function () {\n    if (!contentRef.current || !open) return;\n    var contentElement = contentRef.current;\n    var shouldScroll = contentElement.scrollHeight > contentElement.offsetHeight;\n\n    if (shouldScroll) {\n      rootRef.current.classList.add(dialog_constants_cssClasses.SCROLLABLE);\n    }\n  }, [open]);\n  useUpdated(function () {\n    if (!actionsRef.current || !open || !autoStackButtons) return;\n    var actionsElement = actionsRef.current;\n\n    if (actionsElement.clientHeight > dialog_constants_numbers.DEFAULT_ACTIONS_HEIGHT) {\n      rootRef.current.classList.add(dialog_constants_cssClasses.STACKED);\n    }\n  }, [open, autoStackButtons]);\n  useUpdated(function () {\n    if (!contentRef.current || !fullscreen) return;\n    var contentElement = contentRef.current;\n\n    function handleScroll() {\n      var isScrollAtTop = contentElement.scrollTop === 0;\n      var isScrollAtBottom = Math.ceil(contentElement.scrollHeight - contentElement.scrollTop) === contentElement.clientHeight;\n      rootRef.current.classList.toggle(dialog_constants_cssClasses.SCROLL_DIVIDER_HEADER, !isScrollAtTop);\n      rootRef.current.classList.toggle(dialog_constants_cssClasses.SCROLL_DIVIDER_FOOTER, !isScrollAtBottom);\n    }\n\n    contentElement.addEventListener(\'scroll\', handleScroll);\n\n    if (open) {\n      handleScroll();\n    }\n\n    return function () {\n      return contentElement.removeEventListener(\'scroll\', handleScroll);\n    };\n  }, [open, fullscreen]);\n  useUnmounted(function () {\n    document.body.classList.remove(dialog_constants_cssClasses.SCROLL_LOCK);\n  });\n  var handleEnter = (0,react.useCallback)(function () {\n    document.body.classList.add(dialog_constants_cssClasses.SCROLL_LOCK);\n  }, []);\n  var handleExited = (0,react.useCallback)(function () {\n    document.body.classList.remove(dialog_constants_cssClasses.SCROLL_LOCK);\n  }, []);\n  var handleScrimClick = (0,react.useCallback)(function () {\n    if (persistent) return;\n    onClose();\n  }, [persistent, onClose]);\n  var classNames = classnames_default()(dialog_constants_cssClasses.ROOT, (_classnames = {}, Dialog_defineProperty(_classnames, dialog_constants_cssClasses.FULLSCREEN, fullscreen), Dialog_defineProperty(_classnames, dialog_constants_cssClasses.SHEET, sheet), Dialog_defineProperty(_classnames, dialog_constants_cssClasses.STACKED, stacked), Dialog_defineProperty(_classnames, dialog_constants_cssClasses.NO_CONTENT_PADDING, noContentPadding), _classnames), className);\n  return /*#__PURE__*/(0,jsx_runtime.jsx)(Layer, {\n    modal: true,\n    "in": open,\n    appear: appear,\n    timeout: {\n      enter: dialog_constants_numbers.DIALOG_ANIMATION_OPEN_TIME_MS,\n      exit: dialog_constants_numbers.DIALOG_ANIMATION_CLOSE_TIME_MS\n    },\n    classNames: {\n      appear: dialog_constants_cssClasses.OPENING,\n      appearActive: dialog_constants_cssClasses.OPEN,\n      enter: dialog_constants_cssClasses.OPENING,\n      enterActive: dialog_constants_cssClasses.OPEN,\n      enterDone: dialog_constants_cssClasses.OPEN,\n      exit: dialog_constants_cssClasses.CLOSING\n    },\n    mountOnEnter: true,\n    unmountOnExit: true,\n    onEnter: handleEnter,\n    onExited: handleExited,\n    children: /*#__PURE__*/(0,jsx_runtime.jsxs)(Element, Dialog_objectSpread(Dialog_objectSpread({\n      ref: rootRef,\n      className: classNames\n    }, props), {}, {\n      children: [/*#__PURE__*/(0,jsx_runtime.jsx)("div", {\n        className: dialog_constants_cssClasses.CONTAINER,\n        children: /*#__PURE__*/(0,jsx_runtime.jsxs)("div", {\n          className: dialog_constants_cssClasses.SURFACE,\n          role: "alertdialog",\n          "aria-modal": "true",\n          children: [sheet && /*#__PURE__*/(0,jsx_runtime.jsx)(Clone, {\n            component: closeIcon,\n            fallback: /*#__PURE__*/(0,jsx_runtime.jsx)(icon_button_IconButton, {\n              icon: "close"\n            }),\n            className: dialog_constants_cssClasses.CLOSE,\n            onClick: onClose\n          }), title && /*#__PURE__*/(0,jsx_runtime.jsx)(dialog_DialogHeader, {\n            title: title,\n            closeIcon: closeIcon,\n            fullscreen: fullscreen,\n            onClose: onClose\n          }), (header === null || header === void 0 ? void 0 : header.type) === dialog_DialogHeader && (0,react.cloneElement)(header, {\n            fullscreen: fullscreen,\n            onClose: onClose\n          }), children && ((children === null || children === void 0 ? void 0 : children.type) === dialog_DialogContent ? (0,react.cloneElement)(children, {\n            ref: contentRef\n          }) : /*#__PURE__*/(0,jsx_runtime.jsx)(dialog_DialogContent, {\n            ref: contentRef,\n            children: children\n          })), actions && (actions.type === dialog_DialogActions ? (0,react.cloneElement)(actions, {\n            ref: actionsRef\n          }) : /*#__PURE__*/(0,jsx_runtime.jsx)(dialog_DialogActions, {\n            ref: actionsRef,\n            children: actions\n          }))]\n        })\n      }), /*#__PURE__*/(0,jsx_runtime.jsx)("div", {\n        className: dialog_constants_cssClasses.SCRIM,\n        onClick: handleScrimClick\n      })]\n    }))\n  });\n});\nDialog.displayName = \'MDCDialog\';\nDialog.propTypes = {\n  title: (prop_types_default()).node,\n  header: (prop_types_default()).node,\n  content: (prop_types_default()).node,\n  actions: prop_types_default().oneOfType([(prop_types_default()).node, prop_types_default().arrayOf((prop_types_default()).node)]),\n  closeIcon: (prop_types_default()).node,\n  open: (prop_types_default()).bool,\n  appear: (prop_types_default()).bool,\n  fullscreen: (prop_types_default()).bool,\n  persistent: (prop_types_default()).bool,\n  sheet: (prop_types_default()).bool,\n  stacked: (prop_types_default()).bool,\n  autoStackButtons: (prop_types_default()).bool,\n  noContentPadding: (prop_types_default()).bool,\n  onClose: (prop_types_default()).func\n};\n/* harmony default export */ const dialog_Dialog = (Dialog);\n;// CONCATENATED MODULE: ./src/dialog/index.js\n\n\n\n\ndialog_Dialog.Header = dialog_DialogHeader;\ndialog_Dialog.Content = dialog_DialogContent;\ndialog_Dialog.Actions = dialog_DialogActions;\n\n;// CONCATENATED MODULE: ./src/drawer/constants.js\nvar drawer_constants_numbers = {\n  ANIMATION_ENTER_TIME_MS: 250,\n  ANIMATION_EXIT_TIME_MS: 200\n};\nvar drawer_constants_cssClasses = {\n  ROOT: \'mdc-drawer\',\n  DISMISSIBLE: \'mdc-drawer--dismissible\',\n  MODAL: \'mdc-drawer--modal\',\n  OPEN: \'mdc-drawer--open\',\n  ANIMATE: \'mdc-drawer--animate\',\n  OPENING: \'mdc-drawer--opening\',\n  CLOSING: \'mdc-drawer--closing\',\n  CONTENT: \'mdc-drawer__content\',\n  HEADER: \'mdc-drawer__header\',\n  TITLE: \'mdc-drawer__title\',\n  SUBTITLE: \'mdc-drawer__subtitle\',\n  GRAPHIC: \'mdc-drawer__graphic\',\n  APP_CONTENT: \'mdc-drawer-app-content\',\n  SCRIM: \'mdc-drawer-scrim\'\n};\n;// CONCATENATED MODULE: ./src/drawer/Drawer.jsx\nvar Drawer_excluded = ["open", "appear", "dismissible", "modal", "appContentSelector", "onClose", "element", "component", "className", "children"];\n\nfunction Drawer_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction Drawer_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { Drawer_ownKeys(Object(source), true).forEach(function (key) { Drawer_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { Drawer_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction Drawer_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction Drawer_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = Drawer_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction Drawer_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\n\n\n\n\nvar Drawer = /*#__PURE__*/(0,react.forwardRef)(function (_ref, ref) {\n  var _classnames;\n\n  var _ref$open = _ref.open,\n      open = _ref$open === void 0 ? false : _ref$open,\n      _ref$appear = _ref.appear,\n      appear = _ref$appear === void 0 ? true : _ref$appear,\n      _ref$dismissible = _ref.dismissible,\n      dismissible = _ref$dismissible === void 0 ? false : _ref$dismissible,\n      _ref$modal = _ref.modal,\n      modal = _ref$modal === void 0 ? false : _ref$modal,\n      appContentSelector = _ref.appContentSelector,\n      _ref$onClose = _ref.onClose,\n      onClose = _ref$onClose === void 0 ? Function.prototype : _ref$onClose,\n      _ref$element = _ref.element,\n      element = _ref$element === void 0 ? \'aside\' : _ref$element,\n      _ref$component = _ref.component,\n      Element = _ref$component === void 0 ? element : _ref$component,\n      className = _ref.className,\n      children = _ref.children,\n      props = Drawer_objectWithoutProperties(_ref, Drawer_excluded);\n\n  var rootRef = (0,react.useRef)();\n  (0,react.useImperativeHandle)(ref, function () {\n    return rootRef.current;\n  });\n  (0,react.useEffect)(function () {\n    var _rootRef$current;\n\n    if (!dismissible) return;\n    var appContentElement = appContentSelector ? document.querySelector(appContentSelector) : (_rootRef$current = rootRef.current) === null || _rootRef$current === void 0 ? void 0 : _rootRef$current.nextElementSibling;\n    appContentElement === null || appContentElement === void 0 ? void 0 : appContentElement.classList.add(drawer_constants_cssClasses.APP_CONTENT);\n    return function () {\n      appContentElement === null || appContentElement === void 0 ? void 0 : appContentElement.classList.remove(drawer_constants_cssClasses.APP_CONTENT);\n    };\n  }, [dismissible, appContentSelector]);\n  (0,react.useEffect)(function () {\n    if (!modal) return;\n\n    function handleDocumentKeyDown(event) {\n      if (event.key && event.key === \'Escape\' || event.keyCode === 27) {\n        onClose();\n      }\n    }\n\n    document.addEventListener(\'keydown\', handleDocumentKeyDown);\n    return function () {\n      return document.removeEventListener(\'keydown\', handleDocumentKeyDown);\n    };\n  }, [modal, onClose]);\n  var classNames = classnames_default()(drawer_constants_cssClasses.ROOT, (_classnames = {}, Drawer_defineProperty(_classnames, drawer_constants_cssClasses.DISMISSIBLE, dismissible), Drawer_defineProperty(_classnames, drawer_constants_cssClasses.MODAL, modal), _classnames), className);\n  return /*#__PURE__*/(0,jsx_runtime.jsx)(Layer, {\n    modal: modal,\n    fixed: modal,\n    "in": open,\n    appear: appear,\n    timeout: {\n      enter: drawer_constants_numbers.ANIMATION_ENTER_TIME_MS,\n      exit: drawer_constants_numbers.ANIMATION_EXIT_TIME_MS\n    },\n    classNames: {\n      appear: drawer_constants_cssClasses.OPEN,\n      enter: "".concat(drawer_constants_cssClasses.OPEN, " ").concat(drawer_constants_cssClasses.ANIMATE),\n      enterActive: "".concat(drawer_constants_cssClasses.OPEN, " ").concat(drawer_constants_cssClasses.OPENING),\n      enterDone: drawer_constants_cssClasses.OPEN,\n      exit: "".concat(drawer_constants_cssClasses.OPEN, " ").concat(drawer_constants_cssClasses.CLOSING),\n      exitActive: drawer_constants_cssClasses.CLOSING\n    },\n    mountOnEnter: modal,\n    unmountOnExit: modal,\n    children: /*#__PURE__*/(0,jsx_runtime.jsxs)(jsx_runtime.Fragment, {\n      children: [/*#__PURE__*/(0,jsx_runtime.jsx)(Element, Drawer_objectSpread(Drawer_objectSpread({\n        ref: rootRef,\n        className: classNames\n      }, props), {}, {\n        children: children\n      })), modal && /*#__PURE__*/(0,jsx_runtime.jsx)("div", {\n        className: drawer_constants_cssClasses.SCRIM,\n        onClick: onClose\n      })]\n    })\n  });\n});\nDrawer.displayName = \'MDCDrawer\';\nDrawer.propTypes = {\n  open: (prop_types_default()).bool,\n  appear: (prop_types_default()).bool,\n  dismissible: (prop_types_default()).bool,\n  modal: (prop_types_default()).bool,\n  appContentSelector: (prop_types_default()).string,\n  onClose: (prop_types_default()).func\n};\n/* harmony default export */ const drawer_Drawer = (Drawer);\n;// CONCATENATED MODULE: ./src/drawer/DrawerHeader.jsx\nvar DrawerHeader_excluded = ["title", "subtitle", "graphic", "element", "children"];\n\nfunction DrawerHeader_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction DrawerHeader_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { DrawerHeader_ownKeys(Object(source), true).forEach(function (key) { DrawerHeader_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { DrawerHeader_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction DrawerHeader_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction DrawerHeader_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = DrawerHeader_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction DrawerHeader_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\n\n\nvar DrawerHeader = /*#__PURE__*/(0,react.forwardRef)(function (_ref, ref) {\n  var title = _ref.title,\n      subtitle = _ref.subtitle,\n      graphic = _ref.graphic,\n      _ref$element = _ref.element,\n      Element = _ref$element === void 0 ? \'header\' : _ref$element,\n      children = _ref.children,\n      props = DrawerHeader_objectWithoutProperties(_ref, DrawerHeader_excluded);\n\n  return /*#__PURE__*/(0,jsx_runtime.jsxs)(Element, DrawerHeader_objectSpread(DrawerHeader_objectSpread({\n    ref: ref,\n    className: drawer_constants_cssClasses.HEADER\n  }, props), {}, {\n    children: [graphic && /*#__PURE__*/(0,jsx_runtime.jsx)(Clone, {\n      component: graphic,\n      className: drawer_constants_cssClasses.GRAPHIC\n    }), title && /*#__PURE__*/(0,jsx_runtime.jsx)(Clone, {\n      component: title,\n      fallback: "h3",\n      className: drawer_constants_cssClasses.TITLE\n    }), subtitle && /*#__PURE__*/(0,jsx_runtime.jsx)(Clone, {\n      component: subtitle,\n      fallback: "h6",\n      className: drawer_constants_cssClasses.SUBTITLE\n    }), children]\n  }));\n});\nDrawerHeader.displayName = \'MDCDrawerHeader\';\nDrawerHeader.propTypes = {\n  title: (prop_types_default()).node,\n  subtitle: (prop_types_default()).node,\n  graphic: (prop_types_default()).element\n};\n/* harmony default export */ const drawer_DrawerHeader = (DrawerHeader);\n;// CONCATENATED MODULE: ./src/drawer/DrawerContent.jsx\nvar DrawerContent_excluded = ["element"];\n\nfunction DrawerContent_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction DrawerContent_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { DrawerContent_ownKeys(Object(source), true).forEach(function (key) { DrawerContent_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { DrawerContent_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction DrawerContent_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction DrawerContent_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = DrawerContent_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction DrawerContent_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\nvar DrawerContent = /*#__PURE__*/(0,react.forwardRef)(function (_ref, ref) {\n  var _ref$element = _ref.element,\n      Element = _ref$element === void 0 ? \'div\' : _ref$element,\n      props = DrawerContent_objectWithoutProperties(_ref, DrawerContent_excluded);\n\n  return /*#__PURE__*/(0,jsx_runtime.jsx)(Element, DrawerContent_objectSpread({\n    ref: ref,\n    className: drawer_constants_cssClasses.CONTENT\n  }, props));\n});\nDrawerContent.displayName = \'MDCDrawerContent\';\n/* harmony default export */ const drawer_DrawerContent = (DrawerContent);\n;// CONCATENATED MODULE: ./src/drawer/index.js\n\n\n\ndrawer_Drawer.Header = drawer_DrawerHeader;\ndrawer_Drawer.Content = drawer_DrawerContent;\n\n;// CONCATENATED MODULE: ./src/elevation/constants.js\nvar elevation_constants_cssClasses = {\n  ROOT: \'mdc-elevation\',\n  Z: \'mdc-elevation--z\',\n  TRANSITION: \'mdc-elevation-transition\'\n};\n;// CONCATENATED MODULE: ./src/elevation/Elevation.jsx\nvar Elevation_excluded = ["z", "transition", "element", "component", "className"];\n\nfunction Elevation_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction Elevation_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { Elevation_ownKeys(Object(source), true).forEach(function (key) { Elevation_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { Elevation_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction Elevation_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction Elevation_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = Elevation_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction Elevation_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\nvar Elevation = /*#__PURE__*/(0,react.forwardRef)(function (_ref, ref) {\n  var _classnames;\n\n  var _ref$z = _ref.z,\n      z = _ref$z === void 0 ? 0 : _ref$z,\n      _ref$transition = _ref.transition,\n      transition = _ref$transition === void 0 ? false : _ref$transition,\n      _ref$element = _ref.element,\n      element = _ref$element === void 0 ? \'div\' : _ref$element,\n      _ref$component = _ref.component,\n      Element = _ref$component === void 0 ? element : _ref$component,\n      className = _ref.className,\n      props = Elevation_objectWithoutProperties(_ref, Elevation_excluded);\n\n  var classNames = classnames_default()(elevation_constants_cssClasses.ROOT, (_classnames = {}, Elevation_defineProperty(_classnames, "".concat(elevation_constants_cssClasses.Z).concat(z), z), Elevation_defineProperty(_classnames, elevation_constants_cssClasses.TRANSITION, transition), _classnames), className);\n  return /*#__PURE__*/(0,jsx_runtime.jsx)(Element, Elevation_objectSpread({\n    ref: ref,\n    className: classNames\n  }, props));\n});\nElevation.displayName = \'MDCElevation\';\n/* harmony default export */ const elevation_Elevation = (Elevation);\n;// CONCATENATED MODULE: ./src/elevation/index.js\n\n;// CONCATENATED MODULE: ./src/fab/constants.js\nvar fab_constants_cssClasses = {\n  ROOT: \'mdc-fab\',\n  MINI: \'mdc-fab--mini\',\n  EXTENDED: \'mdc-fab--extended\',\n  EXITED: \'mdc-fab--exited\',\n  ICON: \'mdc-fab__icon\',\n  LABEL: \'mdc-fab__label\',\n  RIPPLE: \'mdc-fab__ripple\'\n};\n;// CONCATENATED MODULE: ./src/fab/FAB.jsx\nvar FAB_excluded = ["icon", "label", "leadingIcon", "trailingIcon", "mini", "exited", "element", "component", "className", "children"];\n\nfunction FAB_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction FAB_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { FAB_ownKeys(Object(source), true).forEach(function (key) { FAB_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { FAB_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction FAB_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction FAB_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = FAB_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction FAB_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\n\n\n\n\nvar FAB = /*#__PURE__*/(0,react.forwardRef)(function (_ref, ref) {\n  var _classnames;\n\n  var icon = _ref.icon,\n      label = _ref.label,\n      _ref$leadingIcon = _ref.leadingIcon,\n      leadingIcon = _ref$leadingIcon === void 0 ? icon : _ref$leadingIcon,\n      trailingIcon = _ref.trailingIcon,\n      _ref$mini = _ref.mini,\n      mini = _ref$mini === void 0 ? false : _ref$mini,\n      _ref$exited = _ref.exited,\n      exited = _ref$exited === void 0 ? false : _ref$exited,\n      _ref$element = _ref.element,\n      element = _ref$element === void 0 ? \'button\' : _ref$element,\n      _ref$component = _ref.component,\n      Element = _ref$component === void 0 ? element : _ref$component,\n      className = _ref.className,\n      _ref$children = _ref.children,\n      children = _ref$children === void 0 ? label : _ref$children,\n      props = FAB_objectWithoutProperties(_ref, FAB_excluded);\n\n  var classNames = classnames_default()(fab_constants_cssClasses.ROOT, (_classnames = {}, FAB_defineProperty(_classnames, fab_constants_cssClasses.MINI, mini), FAB_defineProperty(_classnames, fab_constants_cssClasses.EXTENDED, label), FAB_defineProperty(_classnames, fab_constants_cssClasses.EXITED, exited), _classnames), className);\n  return /*#__PURE__*/(0,jsx_runtime.jsxs)(Element, FAB_objectSpread(FAB_objectSpread({\n    ref: ref,\n    className: classNames\n  }, props), {}, {\n    children: [/*#__PURE__*/(0,jsx_runtime.jsx)("div", {\n      className: fab_constants_cssClasses.RIPPLE\n    }), leadingIcon && /*#__PURE__*/(0,jsx_runtime.jsx)(Clone, {\n      component: leadingIcon,\n      fallback: icon_Icon,\n      className: fab_constants_cssClasses.ICON\n    }), children && /*#__PURE__*/(0,jsx_runtime.jsx)("span", {\n      className: fab_constants_cssClasses.LABEL,\n      children: children\n    }), trailingIcon && /*#__PURE__*/(0,jsx_runtime.jsx)(Clone, {\n      component: trailingIcon,\n      fallback: icon_Icon,\n      className: fab_constants_cssClasses.ICON\n    })]\n  }));\n});\nFAB.displayName = \'MDCFAB\';\nFAB.propTypes = {\n  icon: (prop_types_default()).node,\n  label: (prop_types_default()).node,\n  leadingIcon: (prop_types_default()).node,\n  trailingIcon: (prop_types_default()).node,\n  mini: (prop_types_default()).bool,\n  exited: (prop_types_default()).bool\n};\n/* harmony default export */ const fab_FAB = (FAB);\n;// CONCATENATED MODULE: ./src/fab/index.js\n\n;// CONCATENATED MODULE: ./src/form-field/constants.js\nvar form_field_constants_cssClasses = {\n  ROOT: \'mdc-form-field\',\n  ALIGN_END: \'mdc-form-field--align-end\',\n  NOWRAP: \'mdc-form-field--nowrap\',\n  SPACE_BETWEEN: \'mdc-form-field--space-between\'\n};\n;// CONCATENATED MODULE: ./src/form-field/FormField.jsx\nvar FormField_excluded = ["label", "alignEnd", "nowrap", "spaceBetween", "element", "className", "children"];\n\nfunction FormField_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction FormField_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { FormField_ownKeys(Object(source), true).forEach(function (key) { FormField_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { FormField_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction FormField_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction FormField_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = FormField_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction FormField_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\n\n\nvar FormField = /*#__PURE__*/(0,react.forwardRef)(function (_ref, ref) {\n  var _classnames;\n\n  var label = _ref.label,\n      _ref$alignEnd = _ref.alignEnd,\n      alignEnd = _ref$alignEnd === void 0 ? false : _ref$alignEnd,\n      _ref$nowrap = _ref.nowrap,\n      nowrap = _ref$nowrap === void 0 ? false : _ref$nowrap,\n      _ref$spaceBetween = _ref.spaceBetween,\n      spaceBetween = _ref$spaceBetween === void 0 ? false : _ref$spaceBetween,\n      _ref$element = _ref.element,\n      Element = _ref$element === void 0 ? \'div\' : _ref$element,\n      className = _ref.className,\n      children = _ref.children,\n      props = FormField_objectWithoutProperties(_ref, FormField_excluded);\n\n  var classNames = classnames_default()(form_field_constants_cssClasses.ROOT, (_classnames = {}, FormField_defineProperty(_classnames, form_field_constants_cssClasses.ALIGN_END, alignEnd), FormField_defineProperty(_classnames, form_field_constants_cssClasses.NOWRAP, nowrap), FormField_defineProperty(_classnames, form_field_constants_cssClasses.SPACE_BETWEEN, spaceBetween), _classnames), className);\n  return /*#__PURE__*/(0,jsx_runtime.jsxs)(Element, FormField_objectSpread(FormField_objectSpread({\n    ref: ref,\n    className: classNames\n  }, props), {}, {\n    children: [children, label && /*#__PURE__*/(0,jsx_runtime.jsx)("label", {\n      htmlFor: children.props.id,\n      children: label\n    })]\n  }));\n});\nFormField.displayName = \'MDCFormField\';\nFormField.propTypes = {\n  label: (prop_types_default()).node,\n  alignEnd: (prop_types_default()).bool,\n  nowrap: (prop_types_default()).bool,\n  spaceBetween: (prop_types_default()).bool,\n  children: (prop_types_default()).any.isRequired\n};\n/* harmony default export */ const form_field_FormField = (FormField);\n;// CONCATENATED MODULE: ./src/form-field/index.js\n\n;// CONCATENATED MODULE: ./src/image-list/constants.js\nvar image_list_constants_cssClasses = {\n  IMAGE_LIST: \'mdc-image-list\',\n  IMAGE_LIST_MASONRY: \'mdc-image-list--masonry\',\n  IMAGE_LIST_WITH_TEXT_PROTECTION: \'mdc-image-list--with-text-protection\',\n  IMAGE_LIST_ITEM: \'mdc-image-list__item\',\n  IMAGE_LIST_IMAGE_ASPECT_CONTAINER: \'mdc-image-list__image-aspect-container\',\n  IMAGE_LIST_IMAGE: \'mdc-image-list__image\',\n  IMAGE_LIST_SUPPORTING: \'mdc-image-list__supporting\',\n  IMAGE_LIST_LABEL: \'mdc-image-list__label\'\n};\n;// CONCATENATED MODULE: ./src/image-list/ImageListItem.jsx\nvar ImageListItem_excluded = ["imageSrc", "label", "fixedAspect", "element", "className"];\n\nfunction ImageListItem_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction ImageListItem_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ImageListItem_ownKeys(Object(source), true).forEach(function (key) { ImageListItem_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ImageListItem_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction ImageListItem_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction ImageListItem_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = ImageListItem_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction ImageListItem_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\n\n\nvar ImageListItem = /*#__PURE__*/(0,react.forwardRef)(function (_ref, ref) {\n  var imageSrc = _ref.imageSrc,\n      label = _ref.label,\n      _ref$fixedAspect = _ref.fixedAspect,\n      fixedAspect = _ref$fixedAspect === void 0 ? true : _ref$fixedAspect,\n      _ref$element = _ref.element,\n      Element = _ref$element === void 0 ? \'li\' : _ref$element,\n      className = _ref.className,\n      props = ImageListItem_objectWithoutProperties(_ref, ImageListItem_excluded);\n\n  var classNames = classnames_default()(image_list_constants_cssClasses.IMAGE_LIST_ITEM, className);\n  return /*#__PURE__*/(0,jsx_runtime.jsxs)(Element, ImageListItem_objectSpread(ImageListItem_objectSpread({\n    ref: ref,\n    className: classNames\n  }, props), {}, {\n    children: [fixedAspect ? /*#__PURE__*/(0,jsx_runtime.jsx)("div", {\n      className: image_list_constants_cssClasses.IMAGE_LIST_IMAGE_ASPECT_CONTAINER,\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)("img", {\n        className: image_list_constants_cssClasses.IMAGE_LIST_IMAGE,\n        src: imageSrc,\n        alt: label\n      })\n    }) : /*#__PURE__*/(0,jsx_runtime.jsx)("img", {\n      className: image_list_constants_cssClasses.IMAGE_LIST_IMAGE,\n      src: imageSrc,\n      alt: label\n    }), label && /*#__PURE__*/(0,jsx_runtime.jsx)("div", {\n      className: image_list_constants_cssClasses.IMAGE_LIST_SUPPORTING,\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)("span", {\n        className: image_list_constants_cssClasses.IMAGE_LIST_LABEL,\n        children: label\n      })\n    })]\n  }));\n});\nImageListItem.displayName = \'MDCImageListItem\';\nImageListItem.propTypes = {\n  imageSrc: (prop_types_default()).string,\n  label: (prop_types_default()).node,\n  fixedAspect: (prop_types_default()).bool\n};\n/* harmony default export */ const image_list_ImageListItem = (ImageListItem);\n;// CONCATENATED MODULE: ./src/image-list/ImageList.jsx\nvar ImageList_excluded = ["items", "masonry", "withTextProtection", "element", "className", "children"];\n\nfunction ImageList_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction ImageList_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ImageList_ownKeys(Object(source), true).forEach(function (key) { ImageList_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ImageList_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction ImageList_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction ImageList_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = ImageList_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction ImageList_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\n\n\n\nvar ImageList = /*#__PURE__*/(0,react.forwardRef)(function (_ref, ref) {\n  var _classnames;\n\n  var items = _ref.items,\n      _ref$masonry = _ref.masonry,\n      masonry = _ref$masonry === void 0 ? false : _ref$masonry,\n      _ref$withTextProtecti = _ref.withTextProtection,\n      withTextProtection = _ref$withTextProtecti === void 0 ? false : _ref$withTextProtecti,\n      _ref$element = _ref.element,\n      Element = _ref$element === void 0 ? \'ul\' : _ref$element,\n      className = _ref.className,\n      _ref$children = _ref.children,\n      children = _ref$children === void 0 ? items === null || items === void 0 ? void 0 : items.map(function (item) {\n    return (0,react.createElement)(image_list_ImageListItem, item);\n  }) : _ref$children,\n      props = ImageList_objectWithoutProperties(_ref, ImageList_excluded);\n\n  var classNames = classnames_default()(image_list_constants_cssClasses.IMAGE_LIST, (_classnames = {}, ImageList_defineProperty(_classnames, image_list_constants_cssClasses.IMAGE_LIST_MASONRY, masonry), ImageList_defineProperty(_classnames, image_list_constants_cssClasses.IMAGE_LIST_WITH_TEXT_PROTECTION, withTextProtection), _classnames), className);\n  return /*#__PURE__*/(0,jsx_runtime.jsx)(Element, ImageList_objectSpread(ImageList_objectSpread({\n    ref: ref,\n    className: classNames\n  }, props), {}, {\n    children: react.Children.map(children, function (child) {\n      return (0,react.cloneElement)(child, {\n        fixedAspect: masonry ? false : undefined\n      });\n    })\n  }));\n});\nImageList.displayName = \'MDCImageList\';\nImageList.propTypes = {\n  items: (prop_types_default()).array,\n  masonry: (prop_types_default()).bool,\n  withTextProtection: (prop_types_default()).bool\n};\n/* harmony default export */ const image_list_ImageList = (ImageList);\n;// CONCATENATED MODULE: ./src/image-list/index.js\n\n\nimage_list_ImageList.Item = image_list_ImageListItem;\n\n;// CONCATENATED MODULE: ./src/layout/constants.js\nvar layout_constants_cssClasses = {\n  ROOT: \'mdc-layout\',\n  ROW: \'mdc-layout--row\',\n  COLUMN: \'mdc-layout--column\',\n  DIRECTION: \'mdc-layout--direction\',\n  WRAP: \'mdc-layout--wrap\',\n  WRAP_REVERSE: \'mdc-layout--wrap-reverse\',\n  ALIGN_ITEMS: \'mdc-layout--align-items\',\n  ALIGN_SELF: \'mdc-layout--align-self\',\n  JUSTIFY_CONTENT: \'mdc-layout--justify-content\'\n};\n;// CONCATENATED MODULE: ./src/layout/Layout.jsx\nvar Layout_excluded = ["row", "column", "direction", "wrap", "alignItems", "alignSelf", "justifyContent", "element", "component", "className"];\n\nfunction Layout_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction Layout_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { Layout_ownKeys(Object(source), true).forEach(function (key) { Layout_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { Layout_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction Layout_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction Layout_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = Layout_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction Layout_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\n\nvar Layout = /*#__PURE__*/(0,react.forwardRef)(function (_ref, ref) {\n  var _classnames;\n\n  var row = _ref.row,\n      column = _ref.column,\n      direction = _ref.direction,\n      wrap = _ref.wrap,\n      alignItems = _ref.alignItems,\n      alignSelf = _ref.alignSelf,\n      justifyContent = _ref.justifyContent,\n      _ref$element = _ref.element,\n      element = _ref$element === void 0 ? \'div\' : _ref$element,\n      _ref$component = _ref.component,\n      Element = _ref$component === void 0 ? element : _ref$component,\n      className = _ref.className,\n      props = Layout_objectWithoutProperties(_ref, Layout_excluded);\n\n  var classNames = classnames_default()(layout_constants_cssClasses.ROOT, (_classnames = {}, Layout_defineProperty(_classnames, layout_constants_cssClasses.ROW, row), Layout_defineProperty(_classnames, layout_constants_cssClasses.COLUMN, column), Layout_defineProperty(_classnames, "".concat(layout_constants_cssClasses.DIRECTION, "--").concat(direction), direction), Layout_defineProperty(_classnames, "".concat(layout_constants_cssClasses.ALIGN_ITEMS, "--").concat(alignItems), alignItems), Layout_defineProperty(_classnames, "".concat(layout_constants_cssClasses.ALIGN_SELF, "--").concat(alignSelf), alignSelf), Layout_defineProperty(_classnames, "".concat(layout_constants_cssClasses.JUSTIFY_CONTENT, "--").concat(justifyContent), justifyContent), Layout_defineProperty(_classnames, layout_constants_cssClasses.WRAP, wrap === true), Layout_defineProperty(_classnames, layout_constants_cssClasses.WRAP_REVERSE, wrap === \'reverse\'), _classnames), className);\n  return /*#__PURE__*/(0,jsx_runtime.jsx)(Element, Layout_objectSpread({\n    ref: ref,\n    className: classNames\n  }, props));\n});\nLayout.displayName = \'MDCLayout\';\nLayout.propTypes = {\n  row: (prop_types_default()).bool,\n  column: (prop_types_default()).bool,\n  direction: prop_types_default().oneOf([\'row\', \'column\']),\n  wrap: prop_types_default().oneOfType([(prop_types_default()).bool, (prop_types_default()).string]),\n  alignItems: prop_types_default().oneOf([\'start\', \'center\', \'end\']),\n  alignSelf: prop_types_default().oneOf([\'start\', \'center\', \'end\']),\n  justifyContent: prop_types_default().oneOf([\'start\', \'center\', \'end\', \'around\', \'between\'])\n};\n/* harmony default export */ const layout_Layout = ((/* unused pure expression or super */ null && (Layout)));\n;// CONCATENATED MODULE: ./src/layout/index.js\n\n;// CONCATENATED MODULE: ./src/layout-grid/constants.js\nvar layout_grid_constants_cssClasses = {\n  ROOT: \'mdc-layout-grid\',\n  ALIGN: \'mdc-layout-grid--align\',\n  FIXED_COLUMN_WIDTH: \'mdc-layout-grid--fixed-column-width\',\n  INNER: \'mdc-layout-grid__inner\',\n  CELL: \'mdc-layout-grid__cell\',\n  CELL_SPAN: \'mdc-layout-grid__cell--span\',\n  CELL_ORDER: \'mdc-layout-grid__cell--order\',\n  CELL_ALIGN: \'mdc-layout-grid__cell--align\'\n};\n;// CONCATENATED MODULE: ./src/layout-grid/LayoutGrid.jsx\nvar LayoutGrid_excluded = ["align", "fixedColumnWidth", "element", "component", "className", "children"];\n\nfunction LayoutGrid_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction LayoutGrid_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { LayoutGrid_ownKeys(Object(source), true).forEach(function (key) { LayoutGrid_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { LayoutGrid_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction LayoutGrid_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction LayoutGrid_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = LayoutGrid_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction LayoutGrid_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\n\nvar LayoutGrid = /*#__PURE__*/(0,react.forwardRef)(function (_ref, ref) {\n  var _classnames;\n\n  var align = _ref.align,\n      _ref$fixedColumnWidth = _ref.fixedColumnWidth,\n      fixedColumnWidth = _ref$fixedColumnWidth === void 0 ? false : _ref$fixedColumnWidth,\n      _ref$element = _ref.element,\n      element = _ref$element === void 0 ? \'div\' : _ref$element,\n      _ref$component = _ref.component,\n      component = _ref$component === void 0 ? element : _ref$component,\n      className = _ref.className,\n      children = _ref.children,\n      props = LayoutGrid_objectWithoutProperties(_ref, LayoutGrid_excluded);\n\n  var Element = component;\n  var classNames = classnames_default()(layout_grid_constants_cssClasses.ROOT, (_classnames = {}, LayoutGrid_defineProperty(_classnames, "".concat(layout_grid_constants_cssClasses.ALIGN, "-").concat(align), align), LayoutGrid_defineProperty(_classnames, layout_grid_constants_cssClasses.FIXED_COLUMN_WIDTH, fixedColumnWidth), _classnames), className);\n  return /*#__PURE__*/(0,jsx_runtime.jsx)(Element, LayoutGrid_objectSpread(LayoutGrid_objectSpread({\n    ref: ref,\n    className: classNames\n  }, props), {}, {\n    children: /*#__PURE__*/(0,jsx_runtime.jsx)("div", {\n      className: layout_grid_constants_cssClasses.INNER,\n      children: children\n    })\n  }));\n});\nLayoutGrid.displayName = \'MDCLayoutGrid\';\nLayoutGrid.propTypes = {\n  align: prop_types_default().oneOf([\'left\', \'right\']),\n  fixedColumnWidth: (prop_types_default()).bool\n};\n/* harmony default export */ const layout_grid_LayoutGrid = (LayoutGrid);\n;// CONCATENATED MODULE: ./src/layout-grid/LayoutGridCell.jsx\nvar LayoutGridCell_excluded = ["span", "desktop", "tablet", "mobile", "order", "align", "grid", "element", "component", "className", "children"];\n\nfunction LayoutGridCell_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction LayoutGridCell_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { LayoutGridCell_ownKeys(Object(source), true).forEach(function (key) { LayoutGridCell_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { LayoutGridCell_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction LayoutGridCell_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction LayoutGridCell_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = LayoutGridCell_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction LayoutGridCell_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\n\nvar LayoutGridCell = /*#__PURE__*/(0,react.forwardRef)(function (_ref, ref) {\n  var _classnames;\n\n  var span = _ref.span,\n      desktop = _ref.desktop,\n      tablet = _ref.tablet,\n      mobile = _ref.mobile,\n      order = _ref.order,\n      align = _ref.align,\n      _ref$grid = _ref.grid,\n      grid = _ref$grid === void 0 ? false : _ref$grid,\n      _ref$element = _ref.element,\n      element = _ref$element === void 0 ? \'div\' : _ref$element,\n      _ref$component = _ref.component,\n      component = _ref$component === void 0 ? element : _ref$component,\n      className = _ref.className,\n      children = _ref.children,\n      props = LayoutGridCell_objectWithoutProperties(_ref, LayoutGridCell_excluded);\n\n  var Element = component;\n  var classNames = classnames_default()(layout_grid_constants_cssClasses.CELL, (_classnames = {}, LayoutGridCell_defineProperty(_classnames, "".concat(layout_grid_constants_cssClasses.CELL_SPAN, "-").concat(span), span), LayoutGridCell_defineProperty(_classnames, "".concat(layout_grid_constants_cssClasses.CELL_SPAN, "-").concat(desktop, "-desktop"), desktop), LayoutGridCell_defineProperty(_classnames, "".concat(layout_grid_constants_cssClasses.CELL_SPAN, "-").concat(tablet, "-tablet"), tablet), LayoutGridCell_defineProperty(_classnames, "".concat(layout_grid_constants_cssClasses.CELL_SPAN, "-").concat(mobile, "-mobile"), mobile), LayoutGridCell_defineProperty(_classnames, "".concat(layout_grid_constants_cssClasses.CELL_ORDER, "-").concat(order), order), LayoutGridCell_defineProperty(_classnames, "".concat(layout_grid_constants_cssClasses.CELL_ALIGN, "-").concat(align), align), _classnames), className);\n  return /*#__PURE__*/(0,jsx_runtime.jsx)(Element, LayoutGridCell_objectSpread(LayoutGridCell_objectSpread({\n    ref: ref,\n    className: classNames\n  }, props), {}, {\n    children: grid ? /*#__PURE__*/(0,jsx_runtime.jsx)("div", {\n      className: layout_grid_constants_cssClasses.INNER,\n      children: children\n    }) : children\n  }));\n});\nLayoutGridCell.displayName = \'MDCLayoutGridCell\';\nLayoutGridCell.propTypes = {\n  span: prop_types_default().oneOfType([(prop_types_default()).number, (prop_types_default()).string]),\n  desktop: (prop_types_default()).number,\n  tablet: (prop_types_default()).number,\n  mobile: (prop_types_default()).number,\n  order: (prop_types_default()).number,\n  align: prop_types_default().oneOf([\'top\', \'middle\', \'bottom\']),\n  grid: (prop_types_default()).bool\n};\n/* harmony default export */ const layout_grid_LayoutGridCell = (LayoutGridCell);\n;// CONCATENATED MODULE: ./src/layout-grid/index.js\n\n\nlayout_grid_LayoutGrid.Cell = layout_grid_LayoutGridCell;\n\n;// CONCATENATED MODULE: ./src/radio/constants.js\nvar radio_constants_cssClasses = {\n  ROOT: \'mdc-radio\',\n  DISABLED: \'mdc-radio--disabled\',\n  TOUCH: \'mdc-radio--touch\',\n  NATIVE_CONTROL: \'mdc-radio__native-control\',\n  BACKGROUND: \'mdc-radio__background\',\n  OUTER_CIRCLE: \'mdc-radio__outer-circle\',\n  INNER_CIRCLE: \'mdc-radio__inner-circle\',\n  RIPPLE: \'mdc-radio__ripple\'\n};\n;// CONCATENATED MODULE: ./src/radio/Radio.jsx\nvar Radio_excluded = ["value", "checked", "disabled", "touch", "onChange", "className"];\n\nfunction Radio_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction Radio_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { Radio_ownKeys(Object(source), true).forEach(function (key) { Radio_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { Radio_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction Radio_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction Radio_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = Radio_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction Radio_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\n\n\nvar Radio = /*#__PURE__*/(0,react.forwardRef)(function (_ref, ref) {\n  var _classnames;\n\n  var value = _ref.value,\n      checked = _ref.checked,\n      _ref$disabled = _ref.disabled,\n      disabled = _ref$disabled === void 0 ? false : _ref$disabled,\n      _ref$touch = _ref.touch,\n      touch = _ref$touch === void 0 ? false : _ref$touch,\n      _ref$onChange = _ref.onChange,\n      onChange = _ref$onChange === void 0 ? Function.prototype : _ref$onChange,\n      className = _ref.className,\n      props = Radio_objectWithoutProperties(_ref, Radio_excluded);\n\n  var inputRef = (0,react.useRef)();\n  var handleChange = (0,react.useCallback)(function (event) {\n    onChange(event, event.target.value, event.target);\n  }, [onChange]);\n  var classNames = classnames_default()(radio_constants_cssClasses.ROOT, (_classnames = {}, Radio_defineProperty(_classnames, radio_constants_cssClasses.DISABLED, disabled), Radio_defineProperty(_classnames, radio_constants_cssClasses.TOUCH, touch), _classnames), className);\n  return /*#__PURE__*/(0,jsx_runtime.jsxs)("div", {\n    ref: ref,\n    className: classNames,\n    children: [/*#__PURE__*/(0,jsx_runtime.jsx)("input", Radio_objectSpread({\n      ref: inputRef,\n      className: radio_constants_cssClasses.NATIVE_CONTROL,\n      type: "radio",\n      value: value,\n      checked: checked,\n      disabled: disabled,\n      onChange: handleChange\n    }, props)), /*#__PURE__*/(0,jsx_runtime.jsxs)("div", {\n      className: radio_constants_cssClasses.BACKGROUND,\n      children: [/*#__PURE__*/(0,jsx_runtime.jsx)("div", {\n        className: radio_constants_cssClasses.OUTER_CIRCLE\n      }), /*#__PURE__*/(0,jsx_runtime.jsx)("div", {\n        className: radio_constants_cssClasses.INNER_CIRCLE\n      })]\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)("div", {\n      className: radio_constants_cssClasses.RIPPLE\n    })]\n  });\n});\nRadio.displayName = \'MDCRadio\';\nRadio.propTypes = {\n  value: (prop_types_default()).any,\n  checked: (prop_types_default()).bool,\n  disabled: (prop_types_default()).bool,\n  touch: (prop_types_default()).bool,\n  onChange: (prop_types_default()).func\n};\n/* harmony default export */ const radio_Radio = (Radio);\n;// CONCATENATED MODULE: ./src/radio/index.js\n\n;// CONCATENATED MODULE: ./node_modules/tslib/tslib.es6.js\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nfunction __extends(d, b) {\r\n    if (typeof b !== "function" && b !== null)\r\n        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nvar __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nfunction __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === "function")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nfunction __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nfunction __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nfunction __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nfunction __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nfunction __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError("Generator is already executing.");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nvar __createBinding = Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n});\r\n\r\nfunction __exportStar(m, o) {\r\n    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);\r\n}\r\n\r\nfunction __values(o) {\r\n    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === "number") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");\r\n}\r\n\r\nfunction __read(o, n) {\r\n    var m = typeof Symbol === "function" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i["return"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nfunction __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nfunction __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n}\r\n\r\nfunction __spreadArray(to, from, pack) {\r\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\r\n        if (ar || !(i in from)) {\r\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\r\n            ar[i] = from[i];\r\n        }\r\n    }\r\n    return to.concat(ar || Array.prototype.slice.call(from));\r\n}\r\n\r\nfunction __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nfunction __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume("next", value); }\r\n    function reject(value) { resume("throw", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nfunction __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nfunction __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nfunction __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nvar __setModuleDefault = Object.create ? (function(o, v) {\r\n    Object.defineProperty(o, "default", { enumerable: true, value: v });\r\n}) : function(o, v) {\r\n    o["default"] = v;\r\n};\r\n\r\nfunction __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\r\n    __setModuleDefault(result, mod);\r\n    return result;\r\n}\r\n\r\nfunction __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nfunction __classPrivateFieldGet(receiver, state, kind, f) {\r\n    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");\r\n    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");\r\n    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);\r\n}\r\n\r\nfunction __classPrivateFieldSet(receiver, state, value, kind, f) {\r\n    if (kind === "m") throw new TypeError("Private method is not writable");\r\n    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");\r\n    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");\r\n    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\r\n}\r\n\n;// CONCATENATED MODULE: ./node_modules/@material/base/foundation.js\n/**\n * @license\n * Copyright 2016 Google Inc.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the "Software"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\nvar MDCFoundation = /** @class */ (function () {\n    function MDCFoundation(adapter) {\n        if (adapter === void 0) { adapter = {}; }\n        this.adapter = adapter;\n    }\n    Object.defineProperty(MDCFoundation, "cssClasses", {\n        get: function () {\n            // Classes extending MDCFoundation should implement this method to return an object which exports every\n            // CSS class the foundation class needs as a property. e.g. {ACTIVE: \'mdc-component--active\'}\n            return {};\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(MDCFoundation, "strings", {\n        get: function () {\n            // Classes extending MDCFoundation should implement this method to return an object which exports all\n            // semantic strings as constants. e.g. {ARIA_ROLE: \'tablist\'}\n            return {};\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(MDCFoundation, "numbers", {\n        get: function () {\n            // Classes extending MDCFoundation should implement this method to return an object which exports all\n            // of its semantic numbers as constants. e.g. {ANIMATION_DELAY_MS: 350}\n            return {};\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(MDCFoundation, "defaultAdapter", {\n        get: function () {\n            // Classes extending MDCFoundation may choose to implement this getter in order to provide a convenient\n            // way of viewing the necessary methods of an adapter. In the future, this could also be used for adapter\n            // validation.\n            return {};\n        },\n        enumerable: false,\n        configurable: true\n    });\n    MDCFoundation.prototype.init = function () {\n        // Subclasses should override this method to perform initialization routines (registering events, etc.)\n    };\n    MDCFoundation.prototype.destroy = function () {\n        // Subclasses should override this method to perform de-initialization routines (de-registering events, etc.)\n    };\n    return MDCFoundation;\n}());\n\n// tslint:disable-next-line:no-default-export Needed for backward compatibility with MDC Web v0.44.0 and earlier.\n/* harmony default export */ const foundation = ((/* unused pure expression or super */ null && (MDCFoundation)));\n//# sourceMappingURL=foundation.js.map\n;// CONCATENATED MODULE: ./node_modules/@material/base/component.js\n/**\n * @license\n * Copyright 2016 Google Inc.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the "Software"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\n\n\nvar MDCComponent = /** @class */ (function () {\n    function MDCComponent(root, foundation) {\n        var args = [];\n        for (var _i = 2; _i < arguments.length; _i++) {\n            args[_i - 2] = arguments[_i];\n        }\n        this.root = root;\n        this.initialize.apply(this, __spreadArray([], __read(args)));\n        // Note that we initialize foundation here and not within the constructor\'s\n        // default param so that this.root is defined and can be used within the\n        // foundation class.\n        this.foundation =\n            foundation === undefined ? this.getDefaultFoundation() : foundation;\n        this.foundation.init();\n        this.initialSyncWithDOM();\n    }\n    MDCComponent.attachTo = function (root) {\n        // Subclasses which extend MDCBase should provide an attachTo() method that takes a root element and\n        // returns an instantiated component with its root set to that element. Also note that in the cases of\n        // subclasses, an explicit foundation class will not have to be passed in; it will simply be initialized\n        // from getDefaultFoundation().\n        return new MDCComponent(root, new MDCFoundation({}));\n    };\n    /* istanbul ignore next: method param only exists for typing purposes; it does not need to be unit tested */\n    MDCComponent.prototype.initialize = function () {\n        var _args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            _args[_i] = arguments[_i];\n        }\n        // Subclasses can override this to do any additional setup work that would be considered part of a\n        // "constructor". Essentially, it is a hook into the parent constructor before the foundation is\n        // initialized. Any additional arguments besides root and foundation will be passed in here.\n    };\n    MDCComponent.prototype.getDefaultFoundation = function () {\n        // Subclasses must override this method to return a properly configured foundation class for the\n        // component.\n        throw new Error(\'Subclasses must override getDefaultFoundation to return a properly configured \' +\n            \'foundation class\');\n    };\n    MDCComponent.prototype.initialSyncWithDOM = function () {\n        // Subclasses should override this method if they need to perform work to synchronize with a host DOM\n        // object. An example of this would be a form control wrapper that needs to synchronize its internal state\n        // to some property or attribute of the host DOM. Please note: this is *not* the place to perform DOM\n        // reads/writes that would cause layout / paint, as this is called synchronously from within the constructor.\n    };\n    MDCComponent.prototype.destroy = function () {\n        // Subclasses may implement this method to release any resources / deregister any listeners they have\n        // attached. An example of this might be deregistering a resize event from the window object.\n        this.foundation.destroy();\n    };\n    MDCComponent.prototype.listen = function (evtType, handler, options) {\n        this.root.addEventListener(evtType, handler, options);\n    };\n    MDCComponent.prototype.unlisten = function (evtType, handler, options) {\n        this.root.removeEventListener(evtType, handler, options);\n    };\n    /**\n     * Fires a cross-browser-compatible custom event from the component root of the given type, with the given data.\n     */\n    MDCComponent.prototype.emit = function (evtType, evtData, shouldBubble) {\n        if (shouldBubble === void 0) { shouldBubble = false; }\n        var evt;\n        if (typeof CustomEvent === \'function\') {\n            evt = new CustomEvent(evtType, {\n                bubbles: shouldBubble,\n                detail: evtData,\n            });\n        }\n        else {\n            evt = document.createEvent(\'CustomEvent\');\n            evt.initCustomEvent(evtType, shouldBubble, false, evtData);\n        }\n        this.root.dispatchEvent(evt);\n    };\n    return MDCComponent;\n}());\n\n// tslint:disable-next-line:no-default-export Needed for backward compatibility with MDC Web v0.44.0 and earlier.\n/* harmony default export */ const component = ((/* unused pure expression or super */ null && (MDCComponent)));\n//# sourceMappingURL=component.js.map\n;// CONCATENATED MODULE: ./node_modules/@material/dom/events.js\n/**\n * @license\n * Copyright 2019 Google Inc.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the "Software"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\n/**\n * Determine whether the current browser supports passive event listeners, and\n * if so, use them.\n */\nfunction applyPassive(globalObj) {\n    if (globalObj === void 0) { globalObj = window; }\n    return supportsPassiveOption(globalObj) ?\n        { passive: true } :\n        false;\n}\nfunction supportsPassiveOption(globalObj) {\n    if (globalObj === void 0) { globalObj = window; }\n    // See\n    // https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener\n    var passiveSupported = false;\n    try {\n        var options = {\n            // This function will be called when the browser\n            // attempts to access the passive property.\n            get passive() {\n                passiveSupported = true;\n                return false;\n            }\n        };\n        var handler = function () { };\n        globalObj.document.addEventListener(\'test\', handler, options);\n        globalObj.document.removeEventListener(\'test\', handler, options);\n    }\n    catch (err) {\n        passiveSupported = false;\n    }\n    return passiveSupported;\n}\n//# sourceMappingURL=events.js.map\n;// CONCATENATED MODULE: ./node_modules/@material/dom/ponyfill.js\n/**\n * @license\n * Copyright 2018 Google Inc.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the "Software"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\n/**\n * @fileoverview A "ponyfill" is a polyfill that doesn\'t modify the global prototype chain.\n * This makes ponyfills safer than traditional polyfills, especially for libraries like MDC.\n */\nfunction closest(element, selector) {\n    if (element.closest) {\n        return element.closest(selector);\n    }\n    var el = element;\n    while (el) {\n        if (matches(el, selector)) {\n            return el;\n        }\n        el = el.parentElement;\n    }\n    return null;\n}\nfunction matches(element, selector) {\n    var nativeMatches = element.matches\n        || element.webkitMatchesSelector\n        || element.msMatchesSelector;\n    return nativeMatches.call(element, selector);\n}\n/**\n * Used to compute the estimated scroll width of elements. When an element is\n * hidden due to display: none; being applied to a parent element, the width is\n * returned as 0. However, the element will have a true width once no longer\n * inside a display: none context. This method computes an estimated width when\n * the element is hidden or returns the true width when the element is visble.\n * @param {Element} element the element whose width to estimate\n */\nfunction estimateScrollWidth(element) {\n    // Check the offsetParent. If the element inherits display: none from any\n    // parent, the offsetParent property will be null (see\n    // https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/offsetParent).\n    // This check ensures we only clone the node when necessary.\n    var htmlEl = element;\n    if (htmlEl.offsetParent !== null) {\n        return htmlEl.scrollWidth;\n    }\n    var clone = htmlEl.cloneNode(true);\n    clone.style.setProperty(\'position\', \'absolute\');\n    clone.style.setProperty(\'transform\', \'translate(-9999px, -9999px)\');\n    document.documentElement.appendChild(clone);\n    var scrollWidth = clone.scrollWidth;\n    document.documentElement.removeChild(clone);\n    return scrollWidth;\n}\n//# sourceMappingURL=ponyfill.js.map\n;// CONCATENATED MODULE: ./node_modules/@material/ripple/constants.js\n/**\n * @license\n * Copyright 2016 Google Inc.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the "Software"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\nvar ripple_constants_cssClasses = {\n    // Ripple is a special case where the "root" component is really a "mixin" of sorts,\n    // given that it\'s an \'upgrade\' to an existing component. That being said it is the root\n    // CSS class that all other CSS classes derive from.\n    BG_FOCUSED: \'mdc-ripple-upgraded--background-focused\',\n    FG_ACTIVATION: \'mdc-ripple-upgraded--foreground-activation\',\n    FG_DEACTIVATION: \'mdc-ripple-upgraded--foreground-deactivation\',\n    ROOT: \'mdc-ripple-upgraded\',\n    UNBOUNDED: \'mdc-ripple-upgraded--unbounded\',\n};\nvar constants_strings = {\n    VAR_FG_SCALE: \'--mdc-ripple-fg-scale\',\n    VAR_FG_SIZE: \'--mdc-ripple-fg-size\',\n    VAR_FG_TRANSLATE_END: \'--mdc-ripple-fg-translate-end\',\n    VAR_FG_TRANSLATE_START: \'--mdc-ripple-fg-translate-start\',\n    VAR_LEFT: \'--mdc-ripple-left\',\n    VAR_TOP: \'--mdc-ripple-top\',\n};\nvar ripple_constants_numbers = {\n    DEACTIVATION_TIMEOUT_MS: 225,\n    FG_DEACTIVATION_MS: 150,\n    INITIAL_ORIGIN_SCALE: 0.6,\n    PADDING: 10,\n    TAP_DELAY_MS: 300, // Delay between touch and simulated mouse events on touch devices\n};\n//# sourceMappingURL=constants.js.map\n;// CONCATENATED MODULE: ./node_modules/@material/ripple/util.js\n/**\n * Stores result from supportsCssVariables to avoid redundant processing to\n * detect CSS custom variable support.\n */\nvar supportsCssVariables_;\nfunction supportsCssVariables(windowObj, forceRefresh) {\n    if (forceRefresh === void 0) { forceRefresh = false; }\n    var CSS = windowObj.CSS;\n    var supportsCssVars = supportsCssVariables_;\n    if (typeof supportsCssVariables_ === \'boolean\' && !forceRefresh) {\n        return supportsCssVariables_;\n    }\n    var supportsFunctionPresent = CSS && typeof CSS.supports === \'function\';\n    if (!supportsFunctionPresent) {\n        return false;\n    }\n    var explicitlySupportsCssVars = CSS.supports(\'--css-vars\', \'yes\');\n    // See: https://bugs.webkit.org/show_bug.cgi?id=154669\n    // See: README section on Safari\n    var weAreFeatureDetectingSafari10plus = (CSS.supports(\'(--css-vars: yes)\') &&\n        CSS.supports(\'color\', \'#00000000\'));\n    supportsCssVars =\n        explicitlySupportsCssVars || weAreFeatureDetectingSafari10plus;\n    if (!forceRefresh) {\n        supportsCssVariables_ = supportsCssVars;\n    }\n    return supportsCssVars;\n}\nfunction getNormalizedEventCoords(evt, pageOffset, clientRect) {\n    if (!evt) {\n        return { x: 0, y: 0 };\n    }\n    var x = pageOffset.x, y = pageOffset.y;\n    var documentX = x + clientRect.left;\n    var documentY = y + clientRect.top;\n    var normalizedX;\n    var normalizedY;\n    // Determine touch point relative to the ripple container.\n    if (evt.type === \'touchstart\') {\n        var touchEvent = evt;\n        normalizedX = touchEvent.changedTouches[0].pageX - documentX;\n        normalizedY = touchEvent.changedTouches[0].pageY - documentY;\n    }\n    else {\n        var mouseEvent = evt;\n        normalizedX = mouseEvent.pageX - documentX;\n        normalizedY = mouseEvent.pageY - documentY;\n    }\n    return { x: normalizedX, y: normalizedY };\n}\n//# sourceMappingURL=util.js.map\n;// CONCATENATED MODULE: ./node_modules/@material/ripple/foundation.js\n/**\n * @license\n * Copyright 2016 Google Inc.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the "Software"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\n\n\n\n\n// Activation events registered on the root element of each instance for activation\nvar ACTIVATION_EVENT_TYPES = [\n    \'touchstart\', \'pointerdown\', \'mousedown\', \'keydown\',\n];\n// Deactivation events registered on documentElement when a pointer-related down event occurs\nvar POINTER_DEACTIVATION_EVENT_TYPES = [\n    \'touchend\', \'pointerup\', \'mouseup\', \'contextmenu\',\n];\n// simultaneous nested activations\nvar activatedTargets = [];\nvar MDCRippleFoundation = /** @class */ (function (_super) {\n    __extends(MDCRippleFoundation, _super);\n    function MDCRippleFoundation(adapter) {\n        var _this = _super.call(this, __assign(__assign({}, MDCRippleFoundation.defaultAdapter), adapter)) || this;\n        _this.activationAnimationHasEnded = false;\n        _this.activationTimer = 0;\n        _this.fgDeactivationRemovalTimer = 0;\n        _this.fgScale = \'0\';\n        _this.frame = { width: 0, height: 0 };\n        _this.initialSize = 0;\n        _this.layoutFrame = 0;\n        _this.maxRadius = 0;\n        _this.unboundedCoords = { left: 0, top: 0 };\n        _this.activationState = _this.defaultActivationState();\n        _this.activationTimerCallback = function () {\n            _this.activationAnimationHasEnded = true;\n            _this.runDeactivationUXLogicIfReady();\n        };\n        _this.activateHandler = function (e) {\n            _this.activateImpl(e);\n        };\n        _this.deactivateHandler = function () {\n            _this.deactivateImpl();\n        };\n        _this.focusHandler = function () {\n            _this.handleFocus();\n        };\n        _this.blurHandler = function () {\n            _this.handleBlur();\n        };\n        _this.resizeHandler = function () {\n            _this.layout();\n        };\n        return _this;\n    }\n    Object.defineProperty(MDCRippleFoundation, "cssClasses", {\n        get: function () {\n            return ripple_constants_cssClasses;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(MDCRippleFoundation, "strings", {\n        get: function () {\n            return constants_strings;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(MDCRippleFoundation, "numbers", {\n        get: function () {\n            return ripple_constants_numbers;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(MDCRippleFoundation, "defaultAdapter", {\n        get: function () {\n            return {\n                addClass: function () { return undefined; },\n                browserSupportsCssVars: function () { return true; },\n                computeBoundingRect: function () {\n                    return ({ top: 0, right: 0, bottom: 0, left: 0, width: 0, height: 0 });\n                },\n                containsEventTarget: function () { return true; },\n                deregisterDocumentInteractionHandler: function () { return undefined; },\n                deregisterInteractionHandler: function () { return undefined; },\n                deregisterResizeHandler: function () { return undefined; },\n                getWindowPageOffset: function () { return ({ x: 0, y: 0 }); },\n                isSurfaceActive: function () { return true; },\n                isSurfaceDisabled: function () { return true; },\n                isUnbounded: function () { return true; },\n                registerDocumentInteractionHandler: function () { return undefined; },\n                registerInteractionHandler: function () { return undefined; },\n                registerResizeHandler: function () { return undefined; },\n                removeClass: function () { return undefined; },\n                updateCssVariable: function () { return undefined; },\n            };\n        },\n        enumerable: false,\n        configurable: true\n    });\n    MDCRippleFoundation.prototype.init = function () {\n        var _this = this;\n        var supportsPressRipple = this.supportsPressRipple();\n        this.registerRootHandlers(supportsPressRipple);\n        if (supportsPressRipple) {\n            var _a = MDCRippleFoundation.cssClasses, ROOT_1 = _a.ROOT, UNBOUNDED_1 = _a.UNBOUNDED;\n            requestAnimationFrame(function () {\n                _this.adapter.addClass(ROOT_1);\n                if (_this.adapter.isUnbounded()) {\n                    _this.adapter.addClass(UNBOUNDED_1);\n                    // Unbounded ripples need layout logic applied immediately to set coordinates for both shade and ripple\n                    _this.layoutInternal();\n                }\n            });\n        }\n    };\n    MDCRippleFoundation.prototype.destroy = function () {\n        var _this = this;\n        if (this.supportsPressRipple()) {\n            if (this.activationTimer) {\n                clearTimeout(this.activationTimer);\n                this.activationTimer = 0;\n                this.adapter.removeClass(MDCRippleFoundation.cssClasses.FG_ACTIVATION);\n            }\n            if (this.fgDeactivationRemovalTimer) {\n                clearTimeout(this.fgDeactivationRemovalTimer);\n                this.fgDeactivationRemovalTimer = 0;\n                this.adapter.removeClass(MDCRippleFoundation.cssClasses.FG_DEACTIVATION);\n            }\n            var _a = MDCRippleFoundation.cssClasses, ROOT_2 = _a.ROOT, UNBOUNDED_2 = _a.UNBOUNDED;\n            requestAnimationFrame(function () {\n                _this.adapter.removeClass(ROOT_2);\n                _this.adapter.removeClass(UNBOUNDED_2);\n                _this.removeCssVars();\n            });\n        }\n        this.deregisterRootHandlers();\n        this.deregisterDeactivationHandlers();\n    };\n    /**\n     * @param evt Optional event containing position information.\n     */\n    MDCRippleFoundation.prototype.activate = function (evt) {\n        this.activateImpl(evt);\n    };\n    MDCRippleFoundation.prototype.deactivate = function () {\n        this.deactivateImpl();\n    };\n    MDCRippleFoundation.prototype.layout = function () {\n        var _this = this;\n        if (this.layoutFrame) {\n            cancelAnimationFrame(this.layoutFrame);\n        }\n        this.layoutFrame = requestAnimationFrame(function () {\n            _this.layoutInternal();\n            _this.layoutFrame = 0;\n        });\n    };\n    MDCRippleFoundation.prototype.setUnbounded = function (unbounded) {\n        var UNBOUNDED = MDCRippleFoundation.cssClasses.UNBOUNDED;\n        if (unbounded) {\n            this.adapter.addClass(UNBOUNDED);\n        }\n        else {\n            this.adapter.removeClass(UNBOUNDED);\n        }\n    };\n    MDCRippleFoundation.prototype.handleFocus = function () {\n        var _this = this;\n        requestAnimationFrame(function () { return _this.adapter.addClass(MDCRippleFoundation.cssClasses.BG_FOCUSED); });\n    };\n    MDCRippleFoundation.prototype.handleBlur = function () {\n        var _this = this;\n        requestAnimationFrame(function () { return _this.adapter.removeClass(MDCRippleFoundation.cssClasses.BG_FOCUSED); });\n    };\n    /**\n     * We compute this property so that we are not querying information about the client\n     * until the point in time where the foundation requests it. This prevents scenarios where\n     * client-side feature-detection may happen too early, such as when components are rendered on the server\n     * and then initialized at mount time on the client.\n     */\n    MDCRippleFoundation.prototype.supportsPressRipple = function () {\n        return this.adapter.browserSupportsCssVars();\n    };\n    MDCRippleFoundation.prototype.defaultActivationState = function () {\n        return {\n            activationEvent: undefined,\n            hasDeactivationUXRun: false,\n            isActivated: false,\n            isProgrammatic: false,\n            wasActivatedByPointer: false,\n            wasElementMadeActive: false,\n        };\n    };\n    /**\n     * supportsPressRipple Passed from init to save a redundant function call\n     */\n    MDCRippleFoundation.prototype.registerRootHandlers = function (supportsPressRipple) {\n        var e_1, _a;\n        if (supportsPressRipple) {\n            try {\n                for (var ACTIVATION_EVENT_TYPES_1 = __values(ACTIVATION_EVENT_TYPES), ACTIVATION_EVENT_TYPES_1_1 = ACTIVATION_EVENT_TYPES_1.next(); !ACTIVATION_EVENT_TYPES_1_1.done; ACTIVATION_EVENT_TYPES_1_1 = ACTIVATION_EVENT_TYPES_1.next()) {\n                    var evtType = ACTIVATION_EVENT_TYPES_1_1.value;\n                    this.adapter.registerInteractionHandler(evtType, this.activateHandler);\n                }\n            }\n            catch (e_1_1) { e_1 = { error: e_1_1 }; }\n            finally {\n                try {\n                    if (ACTIVATION_EVENT_TYPES_1_1 && !ACTIVATION_EVENT_TYPES_1_1.done && (_a = ACTIVATION_EVENT_TYPES_1.return)) _a.call(ACTIVATION_EVENT_TYPES_1);\n                }\n                finally { if (e_1) throw e_1.error; }\n            }\n            if (this.adapter.isUnbounded()) {\n                this.adapter.registerResizeHandler(this.resizeHandler);\n            }\n        }\n        this.adapter.registerInteractionHandler(\'focus\', this.focusHandler);\n        this.adapter.registerInteractionHandler(\'blur\', this.blurHandler);\n    };\n    MDCRippleFoundation.prototype.registerDeactivationHandlers = function (evt) {\n        var e_2, _a;\n        if (evt.type === \'keydown\') {\n            this.adapter.registerInteractionHandler(\'keyup\', this.deactivateHandler);\n        }\n        else {\n            try {\n                for (var POINTER_DEACTIVATION_EVENT_TYPES_1 = __values(POINTER_DEACTIVATION_EVENT_TYPES), POINTER_DEACTIVATION_EVENT_TYPES_1_1 = POINTER_DEACTIVATION_EVENT_TYPES_1.next(); !POINTER_DEACTIVATION_EVENT_TYPES_1_1.done; POINTER_DEACTIVATION_EVENT_TYPES_1_1 = POINTER_DEACTIVATION_EVENT_TYPES_1.next()) {\n                    var evtType = POINTER_DEACTIVATION_EVENT_TYPES_1_1.value;\n                    this.adapter.registerDocumentInteractionHandler(evtType, this.deactivateHandler);\n                }\n            }\n            catch (e_2_1) { e_2 = { error: e_2_1 }; }\n            finally {\n                try {\n                    if (POINTER_DEACTIVATION_EVENT_TYPES_1_1 && !POINTER_DEACTIVATION_EVENT_TYPES_1_1.done && (_a = POINTER_DEACTIVATION_EVENT_TYPES_1.return)) _a.call(POINTER_DEACTIVATION_EVENT_TYPES_1);\n                }\n                finally { if (e_2) throw e_2.error; }\n            }\n        }\n    };\n    MDCRippleFoundation.prototype.deregisterRootHandlers = function () {\n        var e_3, _a;\n        try {\n            for (var ACTIVATION_EVENT_TYPES_2 = __values(ACTIVATION_EVENT_TYPES), ACTIVATION_EVENT_TYPES_2_1 = ACTIVATION_EVENT_TYPES_2.next(); !ACTIVATION_EVENT_TYPES_2_1.done; ACTIVATION_EVENT_TYPES_2_1 = ACTIVATION_EVENT_TYPES_2.next()) {\n                var evtType = ACTIVATION_EVENT_TYPES_2_1.value;\n                this.adapter.deregisterInteractionHandler(evtType, this.activateHandler);\n            }\n        }\n        catch (e_3_1) { e_3 = { error: e_3_1 }; }\n        finally {\n            try {\n                if (ACTIVATION_EVENT_TYPES_2_1 && !ACTIVATION_EVENT_TYPES_2_1.done && (_a = ACTIVATION_EVENT_TYPES_2.return)) _a.call(ACTIVATION_EVENT_TYPES_2);\n            }\n            finally { if (e_3) throw e_3.error; }\n        }\n        this.adapter.deregisterInteractionHandler(\'focus\', this.focusHandler);\n        this.adapter.deregisterInteractionHandler(\'blur\', this.blurHandler);\n        if (this.adapter.isUnbounded()) {\n            this.adapter.deregisterResizeHandler(this.resizeHandler);\n        }\n    };\n    MDCRippleFoundation.prototype.deregisterDeactivationHandlers = function () {\n        var e_4, _a;\n        this.adapter.deregisterInteractionHandler(\'keyup\', this.deactivateHandler);\n        try {\n            for (var POINTER_DEACTIVATION_EVENT_TYPES_2 = __values(POINTER_DEACTIVATION_EVENT_TYPES), POINTER_DEACTIVATION_EVENT_TYPES_2_1 = POINTER_DEACTIVATION_EVENT_TYPES_2.next(); !POINTER_DEACTIVATION_EVENT_TYPES_2_1.done; POINTER_DEACTIVATION_EVENT_TYPES_2_1 = POINTER_DEACTIVATION_EVENT_TYPES_2.next()) {\n                var evtType = POINTER_DEACTIVATION_EVENT_TYPES_2_1.value;\n                this.adapter.deregisterDocumentInteractionHandler(evtType, this.deactivateHandler);\n            }\n        }\n        catch (e_4_1) { e_4 = { error: e_4_1 }; }\n        finally {\n            try {\n                if (POINTER_DEACTIVATION_EVENT_TYPES_2_1 && !POINTER_DEACTIVATION_EVENT_TYPES_2_1.done && (_a = POINTER_DEACTIVATION_EVENT_TYPES_2.return)) _a.call(POINTER_DEACTIVATION_EVENT_TYPES_2);\n            }\n            finally { if (e_4) throw e_4.error; }\n        }\n    };\n    MDCRippleFoundation.prototype.removeCssVars = function () {\n        var _this = this;\n        var rippleStrings = MDCRippleFoundation.strings;\n        var keys = Object.keys(rippleStrings);\n        keys.forEach(function (key) {\n            if (key.indexOf(\'VAR_\') === 0) {\n                _this.adapter.updateCssVariable(rippleStrings[key], null);\n            }\n        });\n    };\n    MDCRippleFoundation.prototype.activateImpl = function (evt) {\n        var _this = this;\n        if (this.adapter.isSurfaceDisabled()) {\n            return;\n        }\n        var activationState = this.activationState;\n        if (activationState.isActivated) {\n            return;\n        }\n        // Avoid reacting to follow-on events fired by touch device after an already-processed user interaction\n        var previousActivationEvent = this.previousActivationEvent;\n        var isSameInteraction = previousActivationEvent && evt !== undefined && previousActivationEvent.type !== evt.type;\n        if (isSameInteraction) {\n            return;\n        }\n        activationState.isActivated = true;\n        activationState.isProgrammatic = evt === undefined;\n        activationState.activationEvent = evt;\n        activationState.wasActivatedByPointer = activationState.isProgrammatic ? false : evt !== undefined && (evt.type === \'mousedown\' || evt.type === \'touchstart\' || evt.type === \'pointerdown\');\n        var hasActivatedChild = evt !== undefined &&\n            activatedTargets.length > 0 &&\n            activatedTargets.some(function (target) { return _this.adapter.containsEventTarget(target); });\n        if (hasActivatedChild) {\n            // Immediately reset activation state, while preserving logic that prevents touch follow-on events\n            this.resetActivationState();\n            return;\n        }\n        if (evt !== undefined) {\n            activatedTargets.push(evt.target);\n            this.registerDeactivationHandlers(evt);\n        }\n        activationState.wasElementMadeActive = this.checkElementMadeActive(evt);\n        if (activationState.wasElementMadeActive) {\n            this.animateActivation();\n        }\n        requestAnimationFrame(function () {\n            // Reset array on next frame after the current event has had a chance to bubble to prevent ancestor ripples\n            activatedTargets = [];\n            if (!activationState.wasElementMadeActive\n                && evt !== undefined\n                && (evt.key === \' \' || evt.keyCode === 32)) {\n                // If space was pressed, try again within an rAF call to detect :active, because different UAs report\n                // active states inconsistently when they\'re called within event handling code:\n                // - https://bugs.chromium.org/p/chromium/issues/detail?id=635971\n                // - https://bugzilla.mozilla.org/show_bug.cgi?id=1293741\n                // We try first outside rAF to support Edge, which does not exhibit this problem, but will crash if a CSS\n                // variable is set within a rAF callback for a submit button interaction (#2241).\n                activationState.wasElementMadeActive = _this.checkElementMadeActive(evt);\n                if (activationState.wasElementMadeActive) {\n                    _this.animateActivation();\n                }\n            }\n            if (!activationState.wasElementMadeActive) {\n                // Reset activation state immediately if element was not made active.\n                _this.activationState = _this.defaultActivationState();\n            }\n        });\n    };\n    MDCRippleFoundation.prototype.checkElementMadeActive = function (evt) {\n        return (evt !== undefined && evt.type === \'keydown\') ?\n            this.adapter.isSurfaceActive() :\n            true;\n    };\n    MDCRippleFoundation.prototype.animateActivation = function () {\n        var _this = this;\n        var _a = MDCRippleFoundation.strings, VAR_FG_TRANSLATE_START = _a.VAR_FG_TRANSLATE_START, VAR_FG_TRANSLATE_END = _a.VAR_FG_TRANSLATE_END;\n        var _b = MDCRippleFoundation.cssClasses, FG_DEACTIVATION = _b.FG_DEACTIVATION, FG_ACTIVATION = _b.FG_ACTIVATION;\n        var DEACTIVATION_TIMEOUT_MS = MDCRippleFoundation.numbers.DEACTIVATION_TIMEOUT_MS;\n        this.layoutInternal();\n        var translateStart = \'\';\n        var translateEnd = \'\';\n        if (!this.adapter.isUnbounded()) {\n            var _c = this.getFgTranslationCoordinates(), startPoint = _c.startPoint, endPoint = _c.endPoint;\n            translateStart = startPoint.x + "px, " + startPoint.y + "px";\n            translateEnd = endPoint.x + "px, " + endPoint.y + "px";\n        }\n        this.adapter.updateCssVariable(VAR_FG_TRANSLATE_START, translateStart);\n        this.adapter.updateCssVariable(VAR_FG_TRANSLATE_END, translateEnd);\n        // Cancel any ongoing activation/deactivation animations\n        clearTimeout(this.activationTimer);\n        clearTimeout(this.fgDeactivationRemovalTimer);\n        this.rmBoundedActivationClasses();\n        this.adapter.removeClass(FG_DEACTIVATION);\n        // Force layout in order to re-trigger the animation.\n        this.adapter.computeBoundingRect();\n        this.adapter.addClass(FG_ACTIVATION);\n        this.activationTimer = setTimeout(function () {\n            _this.activationTimerCallback();\n        }, DEACTIVATION_TIMEOUT_MS);\n    };\n    MDCRippleFoundation.prototype.getFgTranslationCoordinates = function () {\n        var _a = this.activationState, activationEvent = _a.activationEvent, wasActivatedByPointer = _a.wasActivatedByPointer;\n        var startPoint;\n        if (wasActivatedByPointer) {\n            startPoint = getNormalizedEventCoords(activationEvent, this.adapter.getWindowPageOffset(), this.adapter.computeBoundingRect());\n        }\n        else {\n            startPoint = {\n                x: this.frame.width / 2,\n                y: this.frame.height / 2,\n            };\n        }\n        // Center the element around the start point.\n        startPoint = {\n            x: startPoint.x - (this.initialSize / 2),\n            y: startPoint.y - (this.initialSize / 2),\n        };\n        var endPoint = {\n            x: (this.frame.width / 2) - (this.initialSize / 2),\n            y: (this.frame.height / 2) - (this.initialSize / 2),\n        };\n        return { startPoint: startPoint, endPoint: endPoint };\n    };\n    MDCRippleFoundation.prototype.runDeactivationUXLogicIfReady = function () {\n        var _this = this;\n        // This method is called both when a pointing device is released, and when the activation animation ends.\n        // The deactivation animation should only run after both of those occur.\n        var FG_DEACTIVATION = MDCRippleFoundation.cssClasses.FG_DEACTIVATION;\n        var _a = this.activationState, hasDeactivationUXRun = _a.hasDeactivationUXRun, isActivated = _a.isActivated;\n        var activationHasEnded = hasDeactivationUXRun || !isActivated;\n        if (activationHasEnded && this.activationAnimationHasEnded) {\n            this.rmBoundedActivationClasses();\n            this.adapter.addClass(FG_DEACTIVATION);\n            this.fgDeactivationRemovalTimer = setTimeout(function () {\n                _this.adapter.removeClass(FG_DEACTIVATION);\n            }, ripple_constants_numbers.FG_DEACTIVATION_MS);\n        }\n    };\n    MDCRippleFoundation.prototype.rmBoundedActivationClasses = function () {\n        var FG_ACTIVATION = MDCRippleFoundation.cssClasses.FG_ACTIVATION;\n        this.adapter.removeClass(FG_ACTIVATION);\n        this.activationAnimationHasEnded = false;\n        this.adapter.computeBoundingRect();\n    };\n    MDCRippleFoundation.prototype.resetActivationState = function () {\n        var _this = this;\n        this.previousActivationEvent = this.activationState.activationEvent;\n        this.activationState = this.defaultActivationState();\n        // Touch devices may fire additional events for the same interaction within a short time.\n        // Store the previous event until it\'s safe to assume that subsequent events are for new interactions.\n        setTimeout(function () { return _this.previousActivationEvent = undefined; }, MDCRippleFoundation.numbers.TAP_DELAY_MS);\n    };\n    MDCRippleFoundation.prototype.deactivateImpl = function () {\n        var _this = this;\n        var activationState = this.activationState;\n        // This can happen in scenarios such as when you have a keyup event that blurs the element.\n        if (!activationState.isActivated) {\n            return;\n        }\n        var state = __assign({}, activationState);\n        if (activationState.isProgrammatic) {\n            requestAnimationFrame(function () {\n                _this.animateDeactivation(state);\n            });\n            this.resetActivationState();\n        }\n        else {\n            this.deregisterDeactivationHandlers();\n            requestAnimationFrame(function () {\n                _this.activationState.hasDeactivationUXRun = true;\n                _this.animateDeactivation(state);\n                _this.resetActivationState();\n            });\n        }\n    };\n    MDCRippleFoundation.prototype.animateDeactivation = function (_a) {\n        var wasActivatedByPointer = _a.wasActivatedByPointer, wasElementMadeActive = _a.wasElementMadeActive;\n        if (wasActivatedByPointer || wasElementMadeActive) {\n            this.runDeactivationUXLogicIfReady();\n        }\n    };\n    MDCRippleFoundation.prototype.layoutInternal = function () {\n        var _this = this;\n        this.frame = this.adapter.computeBoundingRect();\n        var maxDim = Math.max(this.frame.height, this.frame.width);\n        // Surface diameter is treated differently for unbounded vs. bounded ripples.\n        // Unbounded ripple diameter is calculated smaller since the surface is expected to already be padded appropriately\n        // to extend the hitbox, and the ripple is expected to meet the edges of the padded hitbox (which is typically\n        // square). Bounded ripples, on the other hand, are fully expected to expand beyond the surface\'s longest diameter\n        // (calculated based on the diagonal plus a constant padding), and are clipped at the surface\'s border via\n        // `overflow: hidden`.\n        var getBoundedRadius = function () {\n            var hypotenuse = Math.sqrt(Math.pow(_this.frame.width, 2) + Math.pow(_this.frame.height, 2));\n            return hypotenuse + MDCRippleFoundation.numbers.PADDING;\n        };\n        this.maxRadius = this.adapter.isUnbounded() ? maxDim : getBoundedRadius();\n        // Ripple is sized as a fraction of the largest dimension of the surface, then scales up using a CSS scale transform\n        var initialSize = Math.floor(maxDim * MDCRippleFoundation.numbers.INITIAL_ORIGIN_SCALE);\n        // Unbounded ripple size should always be even number to equally center align.\n        if (this.adapter.isUnbounded() && initialSize % 2 !== 0) {\n            this.initialSize = initialSize - 1;\n        }\n        else {\n            this.initialSize = initialSize;\n        }\n        this.fgScale = "" + this.maxRadius / this.initialSize;\n        this.updateLayoutCssVars();\n    };\n    MDCRippleFoundation.prototype.updateLayoutCssVars = function () {\n        var _a = MDCRippleFoundation.strings, VAR_FG_SIZE = _a.VAR_FG_SIZE, VAR_LEFT = _a.VAR_LEFT, VAR_TOP = _a.VAR_TOP, VAR_FG_SCALE = _a.VAR_FG_SCALE;\n        this.adapter.updateCssVariable(VAR_FG_SIZE, this.initialSize + "px");\n        this.adapter.updateCssVariable(VAR_FG_SCALE, this.fgScale);\n        if (this.adapter.isUnbounded()) {\n            this.unboundedCoords = {\n                left: Math.round((this.frame.width / 2) - (this.initialSize / 2)),\n                top: Math.round((this.frame.height / 2) - (this.initialSize / 2)),\n            };\n            this.adapter.updateCssVariable(VAR_LEFT, this.unboundedCoords.left + "px");\n            this.adapter.updateCssVariable(VAR_TOP, this.unboundedCoords.top + "px");\n        }\n    };\n    return MDCRippleFoundation;\n}(MDCFoundation));\n\n// tslint:disable-next-line:no-default-export Needed for backward compatibility with MDC Web v0.44.0 and earlier.\n/* harmony default export */ const ripple_foundation = ((/* unused pure expression or super */ null && (MDCRippleFoundation)));\n//# sourceMappingURL=foundation.js.map\n;// CONCATENATED MODULE: ./node_modules/@material/ripple/component.js\n/**\n * @license\n * Copyright 2016 Google Inc.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the "Software"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\n\n\n\n\n\n\nvar MDCRipple = /** @class */ (function (_super) {\n    __extends(MDCRipple, _super);\n    function MDCRipple() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.disabled = false;\n        return _this;\n    }\n    MDCRipple.attachTo = function (root, opts) {\n        if (opts === void 0) { opts = {\n            isUnbounded: undefined\n        }; }\n        var ripple = new MDCRipple(root);\n        // Only override unbounded behavior if option is explicitly specified\n        if (opts.isUnbounded !== undefined) {\n            ripple.unbounded = opts.isUnbounded;\n        }\n        return ripple;\n    };\n    MDCRipple.createAdapter = function (instance) {\n        return {\n            addClass: function (className) { return instance.root.classList.add(className); },\n            browserSupportsCssVars: function () { return supportsCssVariables(window); },\n            computeBoundingRect: function () { return instance.root.getBoundingClientRect(); },\n            containsEventTarget: function (target) { return instance.root.contains(target); },\n            deregisterDocumentInteractionHandler: function (evtType, handler) {\n                return document.documentElement.removeEventListener(evtType, handler, applyPassive());\n            },\n            deregisterInteractionHandler: function (evtType, handler) {\n                return instance.root\n                    .removeEventListener(evtType, handler, applyPassive());\n            },\n            deregisterResizeHandler: function (handler) {\n                return window.removeEventListener(\'resize\', handler);\n            },\n            getWindowPageOffset: function () {\n                return ({ x: window.pageXOffset, y: window.pageYOffset });\n            },\n            isSurfaceActive: function () { return matches(instance.root, \':active\'); },\n            isSurfaceDisabled: function () { return Boolean(instance.disabled); },\n            isUnbounded: function () { return Boolean(instance.unbounded); },\n            registerDocumentInteractionHandler: function (evtType, handler) {\n                return document.documentElement.addEventListener(evtType, handler, applyPassive());\n            },\n            registerInteractionHandler: function (evtType, handler) {\n                return instance.root\n                    .addEventListener(evtType, handler, applyPassive());\n            },\n            registerResizeHandler: function (handler) {\n                return window.addEventListener(\'resize\', handler);\n            },\n            removeClass: function (className) { return instance.root.classList.remove(className); },\n            updateCssVariable: function (varName, value) {\n                return instance.root.style.setProperty(varName, value);\n            },\n        };\n    };\n    Object.defineProperty(MDCRipple.prototype, "unbounded", {\n        get: function () {\n            return Boolean(this.isUnbounded);\n        },\n        set: function (unbounded) {\n            this.isUnbounded = Boolean(unbounded);\n            this.setUnbounded();\n        },\n        enumerable: false,\n        configurable: true\n    });\n    MDCRipple.prototype.activate = function () {\n        this.foundation.activate();\n    };\n    MDCRipple.prototype.deactivate = function () {\n        this.foundation.deactivate();\n    };\n    MDCRipple.prototype.layout = function () {\n        this.foundation.layout();\n    };\n    MDCRipple.prototype.getDefaultFoundation = function () {\n        return new MDCRippleFoundation(MDCRipple.createAdapter(this));\n    };\n    MDCRipple.prototype.initialSyncWithDOM = function () {\n        var root = this.root;\n        this.isUnbounded = \'mdcRippleIsUnbounded\' in root.dataset;\n    };\n    /**\n     * Closure Compiler throws an access control error when directly accessing a\n     * protected or private property inside a getter/setter, like unbounded above.\n     * By accessing the protected property inside a method, we solve that problem.\n     * That\'s why this function exists.\n     */\n    MDCRipple.prototype.setUnbounded = function () {\n        this.foundation.setUnbounded(Boolean(this.isUnbounded));\n    };\n    return MDCRipple;\n}(MDCComponent));\n\n//# sourceMappingURL=component.js.map\n;// CONCATENATED MODULE: ./src/ripple/Ripple.jsx\nvar Ripple_excluded = ["unbounded", "disabled", "className", "element"];\n\nfunction Ripple_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction Ripple_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { Ripple_ownKeys(Object(source), true).forEach(function (key) { Ripple_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { Ripple_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction Ripple_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction Ripple_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = Ripple_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction Ripple_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\nfunction Ripple(_ref) {\n  var _ref$unbounded = _ref.unbounded,\n      unbounded = _ref$unbounded === void 0 ? false : _ref$unbounded,\n      _ref$disabled = _ref.disabled,\n      disabled = _ref$disabled === void 0 ? false : _ref$disabled,\n      className = _ref.className,\n      _ref$element = _ref.element,\n      Element = _ref$element === void 0 ? \'span\' : _ref$element,\n      props = Ripple_objectWithoutProperties(_ref, Ripple_excluded);\n\n  var rootRef = (0,react.useRef)();\n  var rippleRef = (0,react.useRef)();\n  (0,react.useEffect)(function () {\n    if (disabled) return;\n\n    if (!rippleRef.current) {\n      rippleRef.current = new MDCRipple(rootRef.current.parentNode);\n    }\n\n    rippleRef.current.unbounded = unbounded;\n    return function () {\n      return rippleRef.current.destroy();\n    };\n  }, [disabled, unbounded]);\n  var classNames = classnames_default()(className);\n  return /*#__PURE__*/(0,jsx_runtime.jsx)(Element, Ripple_objectSpread({\n    ref: rootRef,\n    className: classNames\n  }, props));\n}\nRipple.displayName = \'MDCRipple\';\n;// CONCATENATED MODULE: ./src/ripple/constants.js\nvar src_ripple_constants_cssClasses = {\n  ROOT: \'mdc-ripple-upgraded\',\n  UNBOUNDED: \'mdc-ripple-upgraded--unbounded\',\n  BG_FOCUSED: \'mdc-ripple-upgraded--background-focused\',\n  FG_ACTIVATION: \'mdc-ripple-upgraded--foreground-activation\',\n  FG_DEACTIVATION: \'mdc-ripple-upgraded--foreground-deactivation\',\n  SURFACE: \'mdc-ripple-surface\',\n  SURFACE_PRIMARY: \'mdc-ripple-surface--primary\',\n  SURFACE_ACCENT: \'mdc-ripple-surface--accent\'\n};\nvar ripple_constants_strings = {\n  VAR_FG_SCALE: \'--mdc-ripple-fg-scale\',\n  VAR_FG_SIZE: \'--mdc-ripple-fg-size\',\n  VAR_FG_TRANSLATE_END: \'--mdc-ripple-fg-translate-end\',\n  VAR_FG_TRANSLATE_START: \'--mdc-ripple-fg-translate-start\',\n  VAR_LEFT: \'--mdc-ripple-left\',\n  VAR_TOP: \'--mdc-ripple-top\'\n};\nvar src_ripple_constants_numbers = {\n  DEACTIVATION_TIMEOUT_MS: 225,\n  // Corresponds to $mdc-ripple-translate-duration (i.e. activation animation duration)\n  FG_DEACTIVATION_MS: 150,\n  // Corresponds to $mdc-ripple-fade-out-duration (i.e. deactivation animation duration)\n  INITIAL_ORIGIN_SCALE: 0.6,\n  PADDING: 10,\n  TAP_DELAY_MS: 300 // Delay between touch and simulated mouse events on touch devices\n\n};\n;// CONCATENATED MODULE: ./src/ripple/hooks.js\n\n\nfunction useRipple(rootRef) {\n  var unbounded = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  var rippleRef = (0,react.useRef)();\n  (0,react.useEffect)(function () {\n    if (!rippleRef.current) {\n      rippleRef.current = new MDCRipple(rootRef.current);\n    }\n\n    rippleRef.current.unbounded = unbounded;\n    return function () {\n      return rippleRef.current.destroy();\n    };\n  }, [rootRef, unbounded]);\n  return rippleRef.current;\n}\n;// CONCATENATED MODULE: ./src/ripple/RippleSurface.jsx\nvar RippleSurface_excluded = ["primary", "accent", "className", "element"];\n\nfunction RippleSurface_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction RippleSurface_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { RippleSurface_ownKeys(Object(source), true).forEach(function (key) { RippleSurface_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { RippleSurface_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction RippleSurface_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction RippleSurface_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = RippleSurface_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction RippleSurface_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\n\n\nvar RippleSurface = /*#__PURE__*/(0,react.forwardRef)(function (_ref, ref) {\n  var _classnames;\n\n  var primary = _ref.primary,\n      accent = _ref.accent,\n      className = _ref.className,\n      _ref$element = _ref.element,\n      Element = _ref$element === void 0 ? \'div\' : _ref$element,\n      props = RippleSurface_objectWithoutProperties(_ref, RippleSurface_excluded);\n\n  var rootRef = (0,react.useRef)();\n  (0,react.useImperativeHandle)(ref, function () {\n    return rootRef.current;\n  });\n  useRipple(rootRef);\n  var classNames = classnames_default()(src_ripple_constants_cssClasses.SURFACE, (_classnames = {}, RippleSurface_defineProperty(_classnames, src_ripple_constants_cssClasses.SURFACE_PRIMARY, primary), RippleSurface_defineProperty(_classnames, src_ripple_constants_cssClasses.SURFACE_ACCENT, accent), _classnames), className);\n  return /*#__PURE__*/(0,jsx_runtime.jsx)(Element, RippleSurface_objectSpread({\n    ref: rootRef,\n    className: classNames\n  }, props));\n});\nRippleSurface.displayName = \'MDCRippleSurface\';\nRippleSurface.propTypes = {\n  primary: (prop_types_default()).bool,\n  accent: (prop_types_default()).bool\n};\n/* harmony default export */ const ripple_RippleSurface = (RippleSurface);\n;// CONCATENATED MODULE: ./src/ripple/index.js\n\n\n\n;// CONCATENATED MODULE: ./src/segmented-button/constants.js\nvar segmented_button_constants_cssClasses = {\n  ROOT: \'mdc-segmented-button\',\n  SINGLE_SELECT: \'mdc-segmented-button--single-select\',\n  SEGMENT: \'mdc-segmented-button__segment\',\n  SEGMENT_SELECTED: \'mdc-segmented-button__segment--selected\',\n  ICON: \'mdc-segmented-button__icon\',\n  LABEL: \'mdc-segmented-button__label\',\n  RIPPLE: \'mdc-segmented-button__ripple\',\n  TOUCH: \'mdc-segmented-button--touch\',\n  TOUCH_ELEMENT: \'mdc-segmented-button__touch\'\n};\n;// CONCATENATED MODULE: ./src/segmented-button/SegmentedButtonSegment.jsx\nvar SegmentedButtonSegment_excluded = ["label", "icon", "selected", "touch", "ripple", "element", "component", "className", "children"];\n\nfunction SegmentedButtonSegment_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction SegmentedButtonSegment_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { SegmentedButtonSegment_ownKeys(Object(source), true).forEach(function (key) { SegmentedButtonSegment_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { SegmentedButtonSegment_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction SegmentedButtonSegment_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction SegmentedButtonSegment_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = SegmentedButtonSegment_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction SegmentedButtonSegment_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\n\n\n\n\nvar SegmentedButtonSegment = /*#__PURE__*/(0,react.forwardRef)(function (_ref, ref) {\n  var _classnames;\n\n  var label = _ref.label,\n      icon = _ref.icon,\n      selected = _ref.selected,\n      touch = _ref.touch,\n      ripple = _ref.ripple,\n      _ref$element = _ref.element,\n      element = _ref$element === void 0 ? \'button\' : _ref$element,\n      _ref$component = _ref.component,\n      Element = _ref$component === void 0 ? element : _ref$component,\n      className = _ref.className,\n      _ref$children = _ref.children,\n      children = _ref$children === void 0 ? label : _ref$children,\n      props = SegmentedButtonSegment_objectWithoutProperties(_ref, SegmentedButtonSegment_excluded);\n\n  var classNames = classnames_default()(segmented_button_constants_cssClasses.SEGMENT, (_classnames = {}, SegmentedButtonSegment_defineProperty(_classnames, segmented_button_constants_cssClasses.SEGMENT_SELECTED, selected), SegmentedButtonSegment_defineProperty(_classnames, segmented_button_constants_cssClasses.TOUCH, touch), _classnames), className);\n  return /*#__PURE__*/(0,jsx_runtime.jsxs)(Element, SegmentedButtonSegment_objectSpread(SegmentedButtonSegment_objectSpread({\n    ref: ref,\n    className: classNames\n  }, props), {}, {\n    children: [ripple && /*#__PURE__*/(0,jsx_runtime.jsx)("div", {\n      className: segmented_button_constants_cssClasses.RIPPLE\n    }), touch && /*#__PURE__*/(0,jsx_runtime.jsx)("div", {\n      className: segmented_button_constants_cssClasses.TOUCH_ELEMENT\n    }), icon && /*#__PURE__*/(0,jsx_runtime.jsx)(Clone, {\n      component: icon,\n      fallback: icon_Icon,\n      className: segmented_button_constants_cssClasses.ICON\n    }), children && /*#__PURE__*/(0,jsx_runtime.jsx)("span", {\n      className: segmented_button_constants_cssClasses.LABEL,\n      children: children\n    })]\n  }));\n});\nSegmentedButtonSegment.displayName = \'MDCSegmentedButtonSegment\';\nSegmentedButtonSegment.propTypes = {\n  label: (prop_types_default()).string,\n  icon: (prop_types_default()).node,\n  selected: (prop_types_default()).bool,\n  ripple: (prop_types_default()).bool\n};\n/* harmony default export */ const segmented_button_SegmentedButtonSegment = (SegmentedButtonSegment);\n;// CONCATENATED MODULE: ./src/segmented-button/SegmentedButton.jsx\nvar SegmentedButton_excluded = ["value", "segments", "singleSelect", "ripple", "touch", "onChange", "element", "component", "className", "children"];\n\nfunction SegmentedButton_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction SegmentedButton_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { SegmentedButton_ownKeys(Object(source), true).forEach(function (key) { SegmentedButton_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { SegmentedButton_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction SegmentedButton_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction SegmentedButton_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = SegmentedButton_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction SegmentedButton_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\n\n\n\n\nvar SegmentedButton = /*#__PURE__*/(0,react.forwardRef)(function (_ref, ref) {\n  var value = _ref.value,\n      segments = _ref.segments,\n      _ref$singleSelect = _ref.singleSelect,\n      singleSelect = _ref$singleSelect === void 0 ? !isUndefined(value) && !isArray(value) : _ref$singleSelect,\n      _ref$ripple = _ref.ripple,\n      ripple = _ref$ripple === void 0 ? true : _ref$ripple,\n      _ref$touch = _ref.touch,\n      touch = _ref$touch === void 0 ? false : _ref$touch,\n      _ref$onChange = _ref.onChange,\n      onChange = _ref$onChange === void 0 ? Function.prototype : _ref$onChange,\n      _ref$element = _ref.element,\n      element = _ref$element === void 0 ? \'div\' : _ref$element,\n      _ref$component = _ref.component,\n      Element = _ref$component === void 0 ? element : _ref$component,\n      className = _ref.className,\n      _ref$children = _ref.children,\n      children = _ref$children === void 0 ? segments === null || segments === void 0 ? void 0 : segments.map(function (segment) {\n    return (0,react.createElement)(segmented_button_SegmentedButtonSegment, segment);\n  }) : _ref$children,\n      props = SegmentedButton_objectWithoutProperties(_ref, SegmentedButton_excluded);\n\n  var handleClick = (0,react.useCallback)(function (event) {\n    var segmentValue = event.currentTarget.value;\n    var newValue = singleSelect ? segmentValue : value.includes(segmentValue) ? value.filter(function (v) {\n      return v !== segmentValue;\n    }) : value.concat(segmentValue);\n    onChange(newValue);\n  }, [value, singleSelect, onChange]);\n  var classNames = classnames_default()(segmented_button_constants_cssClasses.ROOT, SegmentedButton_defineProperty({}, segmented_button_constants_cssClasses.SINGLE_SELECT, singleSelect), className);\n  return /*#__PURE__*/(0,jsx_runtime.jsx)(Element, SegmentedButton_objectSpread(SegmentedButton_objectSpread({\n    ref: ref,\n    className: classNames,\n    role: singleSelect ? \'radiogroup\' : \'group\'\n  }, props), {}, {\n    children: isUndefined(value) ? children : react.Children.map(children, function (segment) {\n      var _clone;\n\n      var ariaProp = singleSelect ? \'aria-checked\' : \'aria-pressed\';\n      var selected = singleSelect ? value === segment.props.value : value.includes(segment.props.value);\n      return (0,react.cloneElement)(segment, (_clone = {\n        ripple: ripple,\n        touch: touch,\n        selected: selected,\n        role: singleSelect ? \'radio\' : undefined\n      }, SegmentedButton_defineProperty(_clone, ariaProp, selected), SegmentedButton_defineProperty(_clone, "onClickCapture", handleClick), _clone));\n    })\n  }));\n});\nSegmentedButton.displayName = \'MDCSegmentedButton\';\nSegmentedButton.propTypes = {\n  value: (prop_types_default()).any,\n  segments: prop_types_default().arrayOf(prop_types_default().oneOfType([(prop_types_default()).object, (prop_types_default()).element])),\n  singleSelect: (prop_types_default()).bool,\n  ripple: (prop_types_default()).bool,\n  touch: (prop_types_default()).bool,\n  onChange: (prop_types_default()).func\n};\n/* harmony default export */ const segmented_button_SegmentedButton = (SegmentedButton);\n;// CONCATENATED MODULE: ./src/segmented-button/index.js\n\n\nsegmented_button_SegmentedButton.Segment = segmented_button_SegmentedButtonSegment;\n\n;// CONCATENATED MODULE: ./src/side-sheet/constants.js\nvar side_sheet_constants_numbers = {\n  ANIMATION_ENTER_TIME_MS: 250,\n  ANIMATION_EXIT_TIME_MS: 200\n};\nvar side_sheet_constants_cssClasses = {\n  ROOT: \'mdc-side-sheet\',\n  DISMISSIBLE: \'mdc-side-sheet--dismissible\',\n  MODAL: \'mdc-side-sheet--modal\',\n  OPEN: \'mdc-side-sheet--open\',\n  ANIMATE: \'mdc-side-sheet--animate\',\n  OPENING: \'mdc-side-sheet--opening\',\n  CLOSING: \'mdc-side-sheet--closing\',\n  CONTENT: \'mdc-side-sheet__content\',\n  HEADER: \'mdc-side-sheet__header\',\n  TITLE: \'mdc-side-sheet__title\',\n  CLOSE_BUTTON: \'mdc-side-sheet__close-button\',\n  APP_CONTENT: \'mdc-side-sheet-app-content\',\n  SCRIM: \'mdc-side-sheet-scrim\'\n};\n;// CONCATENATED MODULE: ./src/side-sheet/SideSheetHeader.jsx\nvar SideSheetHeader_excluded = ["title", "closeIcon", "onClose", "element"];\n\nfunction SideSheetHeader_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction SideSheetHeader_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { SideSheetHeader_ownKeys(Object(source), true).forEach(function (key) { SideSheetHeader_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { SideSheetHeader_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction SideSheetHeader_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction SideSheetHeader_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = SideSheetHeader_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction SideSheetHeader_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\n\n\nvar SideSheetHeader = /*#__PURE__*/(0,react.forwardRef)(function (_ref, ref) {\n  var title = _ref.title,\n      closeIcon = _ref.closeIcon,\n      onClose = _ref.onClose,\n      _ref$element = _ref.element,\n      Element = _ref$element === void 0 ? \'header\' : _ref$element,\n      props = SideSheetHeader_objectWithoutProperties(_ref, SideSheetHeader_excluded);\n\n  return /*#__PURE__*/(0,jsx_runtime.jsxs)(Element, SideSheetHeader_objectSpread(SideSheetHeader_objectSpread({\n    ref: ref,\n    className: side_sheet_constants_cssClasses.HEADER\n  }, props), {}, {\n    children: [title && /*#__PURE__*/(0,jsx_runtime.jsx)(Clone, {\n      component: title,\n      fallback: "h3",\n      className: side_sheet_constants_cssClasses.TITLE\n    }), closeIcon && /*#__PURE__*/(0,jsx_runtime.jsx)(Clone, {\n      component: closeIcon,\n      fallback: icon_button_IconButton,\n      className: side_sheet_constants_cssClasses.CLOSE_BUTTON,\n      onClick: onClose\n    })]\n  }));\n});\nSideSheetHeader.displayName = \'MDCSideSheetHeader\';\n/* harmony default export */ const side_sheet_SideSheetHeader = (SideSheetHeader);\n;// CONCATENATED MODULE: ./src/side-sheet/SideSheetContent.jsx\nvar SideSheetContent_excluded = ["element"];\n\nfunction SideSheetContent_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction SideSheetContent_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { SideSheetContent_ownKeys(Object(source), true).forEach(function (key) { SideSheetContent_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { SideSheetContent_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction SideSheetContent_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction SideSheetContent_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = SideSheetContent_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction SideSheetContent_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\nvar SideSheetContent = /*#__PURE__*/(0,react.forwardRef)(function (_ref, ref) {\n  var _ref$element = _ref.element,\n      Element = _ref$element === void 0 ? \'div\' : _ref$element,\n      props = SideSheetContent_objectWithoutProperties(_ref, SideSheetContent_excluded);\n\n  return /*#__PURE__*/(0,jsx_runtime.jsx)(Element, SideSheetContent_objectSpread({\n    ref: ref,\n    className: side_sheet_constants_cssClasses.CONTENT\n  }, props));\n});\nSideSheetContent.displayName = \'MDCSideSheetContent\';\n/* harmony default export */ const side_sheet_SideSheetContent = (SideSheetContent);\n;// CONCATENATED MODULE: ./src/side-sheet/SideSheet.jsx\nvar SideSheet_excluded = ["title", "content", "open", "appear", "dismissible", "modal", "closeIcon", "appContentSelector", "onClose", "element", "component", "className", "children"];\n\nfunction SideSheet_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction SideSheet_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { SideSheet_ownKeys(Object(source), true).forEach(function (key) { SideSheet_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { SideSheet_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction SideSheet_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction SideSheet_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = SideSheet_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction SideSheet_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\n\n\n\n\n\n\nvar SideSheet = /*#__PURE__*/(0,react.forwardRef)(function (_ref, ref) {\n  var _classnames;\n\n  var title = _ref.title,\n      content = _ref.content,\n      _ref$open = _ref.open,\n      open = _ref$open === void 0 ? false : _ref$open,\n      _ref$appear = _ref.appear,\n      appear = _ref$appear === void 0 ? false : _ref$appear,\n      _ref$dismissible = _ref.dismissible,\n      dismissible = _ref$dismissible === void 0 ? false : _ref$dismissible,\n      _ref$modal = _ref.modal,\n      modal = _ref$modal === void 0 ? false : _ref$modal,\n      _ref$closeIcon = _ref.closeIcon,\n      closeIcon = _ref$closeIcon === void 0 ? dismissible && \'close\' : _ref$closeIcon,\n      appContentSelector = _ref.appContentSelector,\n      _ref$onClose = _ref.onClose,\n      onClose = _ref$onClose === void 0 ? Function.prototype : _ref$onClose,\n      _ref$element = _ref.element,\n      element = _ref$element === void 0 ? \'aside\' : _ref$element,\n      _ref$component = _ref.component,\n      Element = _ref$component === void 0 ? element : _ref$component,\n      className = _ref.className,\n      children = _ref.children,\n      props = SideSheet_objectWithoutProperties(_ref, SideSheet_excluded);\n\n  var rootRef = (0,react.useRef)();\n  (0,react.useImperativeHandle)(ref, function () {\n    return rootRef.current;\n  });\n  (0,react.useEffect)(function () {\n    if (!dismissible) return;\n    var appContentElement = appContentSelector ? document.querySelector(appContentSelector) : rootRef.current.nextElementSibling;\n    appContentElement === null || appContentElement === void 0 ? void 0 : appContentElement.classList.add(side_sheet_constants_cssClasses.APP_CONTENT);\n    return function () {\n      appContentElement === null || appContentElement === void 0 ? void 0 : appContentElement.classList.remove(side_sheet_constants_cssClasses.APP_CONTENT);\n    };\n  }, [dismissible, appContentSelector]);\n  (0,react.useEffect)(function () {\n    if (!modal) return;\n\n    function handleDocumentKeyDown(event) {\n      if (event.key && event.key === \'Escape\' || event.keyCode === 27) {\n        onClose();\n      }\n    }\n\n    document.addEventListener(\'keydown\', handleDocumentKeyDown);\n    return function () {\n      return document.removeEventListener(\'keydown\', handleDocumentKeyDown);\n    };\n  }, [modal, onClose]);\n  var classNames = classnames_default()(side_sheet_constants_cssClasses.ROOT, (_classnames = {}, SideSheet_defineProperty(_classnames, side_sheet_constants_cssClasses.DISMISSIBLE, dismissible), SideSheet_defineProperty(_classnames, side_sheet_constants_cssClasses.MODAL, modal), _classnames), className);\n  return /*#__PURE__*/(0,jsx_runtime.jsx)(Layer, {\n    "in": open,\n    appear: appear,\n    modal: modal,\n    fixed: modal,\n    timeout: {\n      enter: side_sheet_constants_numbers.ANIMATION_ENTER_TIME_MS,\n      exit: side_sheet_constants_numbers.ANIMATION_EXIT_TIME_MS\n    },\n    classNames: {\n      appear: side_sheet_constants_cssClasses.OPEN,\n      enter: "".concat(side_sheet_constants_cssClasses.OPEN, " ").concat(side_sheet_constants_cssClasses.ANIMATE),\n      enterActive: "".concat(side_sheet_constants_cssClasses.OPEN, " ").concat(side_sheet_constants_cssClasses.OPENING),\n      enterDone: side_sheet_constants_cssClasses.OPEN,\n      exit: "".concat(side_sheet_constants_cssClasses.OPEN, " ").concat(side_sheet_constants_cssClasses.CLOSING),\n      exitActive: side_sheet_constants_cssClasses.CLOSING\n    },\n    mountOnEnter: modal,\n    unmountOnExit: modal,\n    children: /*#__PURE__*/(0,jsx_runtime.jsxs)(jsx_runtime.Fragment, {\n      children: [/*#__PURE__*/(0,jsx_runtime.jsxs)(Element, SideSheet_objectSpread(SideSheet_objectSpread({\n        ref: rootRef,\n        className: classNames\n      }, props), {}, {\n        children: [(title || dismissible) && /*#__PURE__*/(0,jsx_runtime.jsx)(side_sheet_SideSheetHeader, {\n          title: title,\n          onClose: onClose,\n          closeIcon: closeIcon\n        }), content && /*#__PURE__*/(0,jsx_runtime.jsx)(side_sheet_SideSheetContent, {\n          children: content\n        }), children]\n      })), modal && /*#__PURE__*/(0,jsx_runtime.jsx)("div", {\n        className: side_sheet_constants_cssClasses.SCRIM,\n        onClick: onClose\n      })]\n    })\n  });\n});\nSideSheet.displayName = \'MDCSideSheet\';\nSideSheet.propTypes = {\n  title: (prop_types_default()).string,\n  content: (prop_types_default()).node,\n  closeIcon: (prop_types_default()).node,\n  open: (prop_types_default()).bool,\n  appear: (prop_types_default()).bool,\n  dismissible: (prop_types_default()).bool,\n  modal: (prop_types_default()).bool,\n  appContentSelector: (prop_types_default()).string,\n  onClose: (prop_types_default()).func\n};\n/* harmony default export */ const side_sheet_SideSheet = (SideSheet);\n;// CONCATENATED MODULE: ./src/side-sheet/SideSheetAppContent.jsx\nvar SideSheetAppContent_excluded = ["element", "className"];\n\nfunction SideSheetAppContent_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction SideSheetAppContent_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { SideSheetAppContent_ownKeys(Object(source), true).forEach(function (key) { SideSheetAppContent_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { SideSheetAppContent_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction SideSheetAppContent_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction SideSheetAppContent_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = SideSheetAppContent_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction SideSheetAppContent_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\nvar SideSheetAppContent = /*#__PURE__*/(0,react.forwardRef)(function (_ref, ref) {\n  var _ref$element = _ref.element,\n      Element = _ref$element === void 0 ? \'div\' : _ref$element,\n      className = _ref.className,\n      props = SideSheetAppContent_objectWithoutProperties(_ref, SideSheetAppContent_excluded);\n\n  var classNames = classnames_default()(side_sheet_constants_cssClasses.APP_CONTENT, className);\n  return /*#__PURE__*/(0,jsx_runtime.jsx)(Element, SideSheetAppContent_objectSpread({\n    ref: ref,\n    className: classNames\n  }, props));\n});\nSideSheetAppContent.displayName = \'MDCSideSheetAppContent\';\n/* harmony default export */ const side_sheet_SideSheetAppContent = (SideSheetAppContent);\n;// CONCATENATED MODULE: ./src/side-sheet/index.js\n\n\n\n\nside_sheet_SideSheet.Header = side_sheet_SideSheetHeader;\nside_sheet_SideSheet.Content = side_sheet_SideSheetContent;\nside_sheet_SideSheet.AppContent = side_sheet_SideSheetAppContent;\n\n;// CONCATENATED MODULE: ./src/slider/constants.js\nvar slider_constants_numbers = {\n  THUMB_WIDTH: 48\n};\nvar slider_constants_cssClasses = {\n  ROOT: \'mdc-slider\',\n  RANGE: \'mdc-slider--range\',\n  DISCRETE: \'mdc-slider--discrete\',\n  DISABLED: \'mdc-slider--disabled\',\n  INPUT: \'mdc-slider__input\',\n  TRACK: \'mdc-slider__track\',\n  TRACK_INACTIVE: \'mdc-slider__track--inactive\',\n  TRACK_ACTIVE: \'mdc-slider__track--active\',\n  TRACK_ACTIVE_FILL: \'mdc-slider__track--active_fill\',\n  TICK_MARKS: \'mdc-slider__tick-marks\',\n  TICK_MARK_ACTIVE: \'mdc-slider__tick-mark--active\',\n  TICK_MARK_INACTIVE: \'mdc-slider__tick-mark--inactive\',\n  THUMB: \'mdc-slider__thumb\',\n  THUMB_TOP: \'mdc-slider__thumb--top\',\n  THUMB_FOCUSED: \'mdc-slider__thumb--focused\',\n  THUMB_WITH_INDICATOR: \'mdc-slider__thumb--with-indicator\',\n  THUMB_KNOB: \'mdc-slider__thumb-knob\',\n  VALUE_INDICATOR_CONTAINER: \'mdc-slider__value-indicator-container\',\n  VALUE_INDICATOR: \'mdc-slider__value-indicator\',\n  VALUE_INDICATOR_TEXT: \'mdc-slider__value-indicator-text\'\n};\n;// CONCATENATED MODULE: ./src/slider/utils.js\n\nfunction getValueForEventKey(eventKey, value, min, max, step) {\n  var delta = Number(step) || (max - min) / 100;\n\n  switch (eventKey) {\n    case Key.ARROW_LEFT:\n    case Key.ARROW_DOWN:\n      return value - delta;\n\n    case Key.ARROW_RIGHT:\n    case Key.ARROW_UP:\n      return value + delta;\n\n    case Key.HOME:\n      return min;\n\n    case Key.END:\n      return max;\n\n    default:\n      return NaN;\n  }\n}\n;// CONCATENATED MODULE: ./src/slider/Input.jsx\nvar Input_excluded = ["value"];\n\nfunction Input_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction Input_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { Input_ownKeys(Object(source), true).forEach(function (key) { Input_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { Input_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction Input_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction Input_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = Input_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction Input_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\nvar Input = /*#__PURE__*/(0,react.forwardRef)(function (_ref, ref) {\n  var value = _ref.value,\n      props = Input_objectWithoutProperties(_ref, Input_excluded);\n\n  return /*#__PURE__*/(0,jsx_runtime.jsx)("input", Input_objectSpread({\n    ref: ref,\n    className: slider_constants_cssClasses.INPUT,\n    type: "range",\n    value: Math.round(value),\n    onChange: Function.prototype\n  }, props));\n});\nInput.displayName = \'MDCSliderInput\';\n/* harmony default export */ const slider_Input = (Input);\n;// CONCATENATED MODULE: ./src/slider/TickMarks.jsx\nfunction TickMarks_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n\n\n\n\nvar TickMarks = function TickMarks(_ref) {\n  var value = _ref.value,\n      min = _ref.min,\n      max = _ref.max,\n      _ref$step = _ref.step,\n      step = _ref$step === void 0 ? 1 : _ref$step;\n  return /*#__PURE__*/(0,jsx_runtime.jsx)("div", {\n    className: slider_constants_cssClasses.TICK_MARKS,\n    children: Array.from(new Array((max - min) / step + 1)).map(function (_, i) {\n      return step * i + Number(min);\n    }).map(function (tickValue) {\n      var _classnames;\n\n      return /*#__PURE__*/(0,jsx_runtime.jsx)("div", {\n        "data-value": tickValue,\n        className: classnames_default()((_classnames = {}, TickMarks_defineProperty(_classnames, slider_constants_cssClasses.TICK_MARK_ACTIVE, tickValue <= value), TickMarks_defineProperty(_classnames, slider_constants_cssClasses.TICK_MARK_INACTIVE, tickValue > value), _classnames))\n      }, tickValue);\n    })\n  });\n};\n\nTickMarks.displayName = \'MDCSliderTickMarks\';\n/* harmony default export */ const slider_TickMarks = (TickMarks);\n;// CONCATENATED MODULE: ./src/slider/Track.jsx\n\n\n\n\n\nvar Track = /*#__PURE__*/(0,react.forwardRef)(function (_ref, ref) {\n  var value = _ref.value,\n      min = _ref.min,\n      max = _ref.max,\n      step = _ref.step,\n      discrete = _ref.discrete,\n      tickMarks = _ref.tickMarks;\n  var style = {\n    transform: "scaleX(".concat((value - min) / (max - min), ")")\n  };\n  return /*#__PURE__*/(0,jsx_runtime.jsxs)("div", {\n    ref: ref,\n    className: slider_constants_cssClasses.TRACK,\n    children: [/*#__PURE__*/(0,jsx_runtime.jsx)("div", {\n      className: slider_constants_cssClasses.TRACK_INACTIVE\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)("div", {\n      className: slider_constants_cssClasses.TRACK_ACTIVE,\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)("div", {\n        className: slider_constants_cssClasses.TRACK_ACTIVE_FILL,\n        style: style\n      })\n    }), discrete && tickMarks && /*#__PURE__*/(0,jsx_runtime.jsx)(slider_TickMarks, {\n      value: value,\n      min: min,\n      max: max,\n      step: step\n    })]\n  });\n});\nTrack.displayName = \'MDCSliderTrack\';\n/* harmony default export */ const slider_Track = (Track);\n;// CONCATENATED MODULE: ./src/slider/Thumb.jsx\nvar Thumb_excluded = ["value", "min", "max", "discrete", "disabled", "onStartInteraction", "onEndInteraction"];\n\nfunction Thumb_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction Thumb_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { Thumb_ownKeys(Object(source), true).forEach(function (key) { Thumb_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { Thumb_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction Thumb_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction Thumb_slicedToArray(arr, i) { return Thumb_arrayWithHoles(arr) || Thumb_iterableToArrayLimit(arr, i) || Thumb_unsupportedIterableToArray(arr, i) || Thumb_nonIterableRest(); }\n\nfunction Thumb_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction Thumb_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return Thumb_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return Thumb_arrayLikeToArray(o, minLen); }\n\nfunction Thumb_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction Thumb_iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction Thumb_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction Thumb_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = Thumb_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction Thumb_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\n\nvar Thumb = /*#__PURE__*/(0,react.forwardRef)(function (_ref, ref) {\n  var _classnames;\n\n  var value = _ref.value,\n      min = _ref.min,\n      max = _ref.max,\n      discrete = _ref.discrete,\n      disabled = _ref.disabled,\n      onStartInteraction = _ref.onStartInteraction,\n      onEndInteraction = _ref.onEndInteraction,\n      props = Thumb_objectWithoutProperties(_ref, Thumb_excluded);\n\n  var _useState = (0,react.useState)(false),\n      _useState2 = Thumb_slicedToArray(_useState, 2),\n      focused = _useState2[0],\n      setFocused = _useState2[1];\n\n  var handleFocus = (0,react.useCallback)(function () {\n    setFocused(true);\n  }, []);\n  var handleBlur = (0,react.useCallback)(function () {\n    setFocused(false);\n  }, []);\n  var classNames = classnames_default()(slider_constants_cssClasses.THUMB, (_classnames = {}, Thumb_defineProperty(_classnames, slider_constants_cssClasses.THUMB_FOCUSED, focused), Thumb_defineProperty(_classnames, slider_constants_cssClasses.THUMB_WITH_INDICATOR, discrete && focused), _classnames));\n  var style = {\n    left: "calc(".concat((value - min) / (max - min) * 100, "% - ").concat(slider_constants_numbers.THUMB_WIDTH * 0.5, "px)")\n  };\n  return /*#__PURE__*/(0,jsx_runtime.jsxs)("div", Thumb_objectSpread(Thumb_objectSpread({\n    ref: ref,\n    className: classNames,\n    role: "slider",\n    tabIndex: disabled ? \'-1\' : \'0\',\n    "aria-valuemin": "0",\n    "aria-valuemax": "100",\n    "aria-valuenow": "50",\n    "aria-disabled": disabled || undefined,\n    style: style,\n    onFocus: handleFocus,\n    onBlur: handleBlur,\n    onMouseDown: onStartInteraction,\n    onMouseUp: onEndInteraction,\n    onTouchStart: onStartInteraction,\n    onTouchEnd: onEndInteraction\n  }, props), {}, {\n    children: [discrete && /*#__PURE__*/(0,jsx_runtime.jsx)("div", {\n      className: slider_constants_cssClasses.VALUE_INDICATOR_CONTAINER,\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)("div", {\n        className: slider_constants_cssClasses.VALUE_INDICATOR,\n        children: /*#__PURE__*/(0,jsx_runtime.jsx)("span", {\n          className: slider_constants_cssClasses.VALUE_INDICATOR_TEXT,\n          children: value\n        })\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)("div", {\n      className: slider_constants_cssClasses.THUMB_KNOB\n    })]\n  }));\n});\nThumb.displayName = \'MDCSliderThumb\';\n/* harmony default export */ const slider_Thumb = (Thumb);\n;// CONCATENATED MODULE: ./src/slider/Slider.jsx\nvar Slider_excluded = ["name", "value", "min", "max", "step", "discrete", "disabled", "tickMarks", "onChange", "className"];\n\nfunction Slider_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction Slider_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { Slider_ownKeys(Object(source), true).forEach(function (key) { Slider_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { Slider_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction Slider_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction Slider_slicedToArray(arr, i) { return Slider_arrayWithHoles(arr) || Slider_iterableToArrayLimit(arr, i) || Slider_unsupportedIterableToArray(arr, i) || Slider_nonIterableRest(); }\n\nfunction Slider_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction Slider_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return Slider_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return Slider_arrayLikeToArray(o, minLen); }\n\nfunction Slider_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction Slider_iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction Slider_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction Slider_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = Slider_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction Slider_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\n\n\n\n\n\n\n\n\nvar Slider = /*#__PURE__*/(0,react.forwardRef)(function (_ref, ref) {\n  var _classnames;\n\n  var name = _ref.name,\n      _ref$value = _ref.value,\n      value = _ref$value === void 0 ? 0 : _ref$value,\n      _ref$min = _ref.min,\n      min = _ref$min === void 0 ? 0 : _ref$min,\n      _ref$max = _ref.max,\n      max = _ref$max === void 0 ? 100 : _ref$max,\n      step = _ref.step,\n      _ref$discrete = _ref.discrete,\n      discrete = _ref$discrete === void 0 ? false : _ref$discrete,\n      _ref$disabled = _ref.disabled,\n      disabled = _ref$disabled === void 0 ? false : _ref$disabled,\n      _ref$tickMarks = _ref.tickMarks,\n      tickMarks = _ref$tickMarks === void 0 ? false : _ref$tickMarks,\n      _ref$onChange = _ref.onChange,\n      onChange = _ref$onChange === void 0 ? Function.prototype : _ref$onChange,\n      className = _ref.className,\n      props = Slider_objectWithoutProperties(_ref, Slider_excluded);\n\n  var inputRef = (0,react.useRef)();\n  var trackRef = (0,react.useRef)();\n\n  var _useState = (0,react.useState)(false),\n      _useState2 = Slider_slicedToArray(_useState, 2),\n      active = _useState2[0],\n      setActive = _useState2[1];\n\n  useUpdated(function () {\n    if (disabled) return;\n\n    if (active) {\n      document.body.addEventListener(\'mousemove\', handleMove);\n      document.body.addEventListener(\'touchmove\', handleMove);\n      document.body.addEventListener(\'mouseup\', handleUp);\n      document.body.addEventListener(\'touchend\', handleUp);\n    } else {\n      document.body.removeEventListener(\'mousemove\', handleMove);\n      document.body.removeEventListener(\'touchmove\', handleMove);\n      document.body.removeEventListener(\'mouseup\', handleUp);\n      document.body.removeEventListener(\'touchend\', handleUp);\n    }\n\n    return function () {\n      document.body.removeEventListener(\'mousemove\', handleMove);\n      document.body.removeEventListener(\'touchmove\', handleMove);\n      document.body.removeEventListener(\'mouseup\', handleUp);\n      document.body.removeEventListener(\'touchend\', handleUp);\n    };\n  }, [active]);\n  var updateValue = (0,react.useCallback)(function (newValue) {\n    if (newValue < min) {\n      newValue = Number(min);\n    } else if (newValue > max) {\n      newValue = Number(max);\n    }\n\n    if (step) {\n      newValue = Math.round(newValue / step) * step;\n    }\n\n    onChange(newValue);\n  }, [min, max, step, onChange]);\n  var handleMove = (0,react.useCallback)(function (event) {\n    var trackClientRect = trackRef.current.getBoundingClientRect();\n    var pageX = getPageX(event);\n    var offsetX = pageX - trackClientRect.left;\n    var percent = offsetX / trackClientRect.width;\n    var value = Number(min) + percent * (max - min);\n    updateValue(value);\n  }, [min, max, updateValue]);\n  var handleKeyDown = (0,react.useCallback)(function (event) {\n    event.preventDefault();\n    var value = Number(inputRef.current.value);\n    var eventKey = getEventKey(event);\n    var newValue = getValueForEventKey(eventKey, value, min, max, step);\n    if (isNaN(newValue)) return;\n    updateValue(newValue);\n  }, [min, max, step, updateValue]);\n  var handleRootInteraction = (0,react.useCallback)(function (event) {\n    handleMove(event);\n  }, [handleMove]);\n  var handleUp = (0,react.useCallback)(function () {\n    setActive(false);\n  }, []);\n  var handleThumbStartInteraction = (0,react.useCallback)(function () {\n    setActive(true);\n  }, []);\n  var handleThumbEndInteraction = (0,react.useCallback)(function () {\n    setActive(false);\n  }, []);\n  var classNames = classnames_default()(slider_constants_cssClasses.ROOT, (_classnames = {}, Slider_defineProperty(_classnames, slider_constants_cssClasses.DISCRETE, discrete), Slider_defineProperty(_classnames, slider_constants_cssClasses.DISABLED, disabled), _classnames), className);\n  return /*#__PURE__*/(0,jsx_runtime.jsxs)("div", Slider_objectSpread(Slider_objectSpread({\n    ref: ref,\n    className: classNames,\n    onMouseDown: handleRootInteraction,\n    onTouchStart: handleRootInteraction\n  }, props), {}, {\n    children: [/*#__PURE__*/(0,jsx_runtime.jsx)(slider_Input, {\n      ref: inputRef,\n      name: name,\n      value: value,\n      min: min,\n      max: max,\n      step: step,\n      disabled: disabled\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(slider_Track, {\n      ref: trackRef,\n      value: value,\n      min: min,\n      max: max,\n      step: step,\n      discrete: discrete,\n      tickMarks: tickMarks\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(slider_Thumb, {\n      value: value,\n      min: min,\n      max: max,\n      discrete: discrete,\n      onStartInteraction: handleThumbStartInteraction,\n      onEndInteraction: handleThumbEndInteraction,\n      onKeyDown: handleKeyDown\n    })]\n  }));\n});\nSlider.displayName = \'MDCSlider\';\nSlider.propTypes = {\n  value: prop_types_default().oneOfType([(prop_types_default()).number, (prop_types_default()).string]),\n  min: prop_types_default().oneOfType([(prop_types_default()).number, (prop_types_default()).string]),\n  max: prop_types_default().oneOfType([(prop_types_default()).number, (prop_types_default()).string]),\n  step: prop_types_default().oneOfType([(prop_types_default()).number, (prop_types_default()).string]),\n  discrete: (prop_types_default()).bool,\n  disabled: (prop_types_default()).bool,\n  tickMarks: (prop_types_default()).bool,\n  onChange: (prop_types_default()).func\n};\n/* harmony default export */ const slider_Slider = (Slider);\n;// CONCATENATED MODULE: ./src/slider/index.js\n\n;// CONCATENATED MODULE: ./src/snackbar/constants.js\nvar snackbar_constants_numbers = {\n  DEFAULT_AUTO_DISMISS_TIMEOUT_MS: 5000,\n  ANIMATION_OPEN_TIME_MS: 150,\n  ANIMATION_CLOSE_TIME_MS: 75\n};\nvar snackbar_constants_cssClasses = {\n  ROOT: \'mdc-snackbar\',\n  LEADING: \'mdc-snackbar--leading\',\n  STACKED: \'mdc-snackbar--stacked\',\n  OPENING: \'mdc-snackbar--opening\',\n  OPEN: \'mdc-snackbar--open\',\n  CLOSING: \'mdc-snackbar--closing\',\n  SURFACE: \'mdc-snackbar__surface\',\n  LABEL: \'mdc-snackbar__label\',\n  ACTIONS: \'mdc-snackbar__actions\',\n  ACTION: \'mdc-snackbar__action\',\n  DISMISS: \'mdc-snackbar__dismiss\'\n};\n;// CONCATENATED MODULE: ./src/snackbar/Snackbar.jsx\nvar Snackbar_excluded = ["label", "action", "dismissIcon", "open", "appear", "leading", "stacked", "dismissible", "timeout", "closeOnEscape", "onClose", "element", "className", "children"];\n\nfunction Snackbar_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction Snackbar_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { Snackbar_ownKeys(Object(source), true).forEach(function (key) { Snackbar_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { Snackbar_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction Snackbar_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction Snackbar_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = Snackbar_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction Snackbar_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\n\n\n\n\n\n\nvar Snackbar = /*#__PURE__*/(0,react.forwardRef)(function (_ref, ref) {\n  var _classnames;\n\n  var label = _ref.label,\n      action = _ref.action,\n      _ref$dismissIcon = _ref.dismissIcon,\n      dismissIcon = _ref$dismissIcon === void 0 ? \'close\' : _ref$dismissIcon,\n      _ref$open = _ref.open,\n      open = _ref$open === void 0 ? false : _ref$open,\n      _ref$appear = _ref.appear,\n      appear = _ref$appear === void 0 ? false : _ref$appear,\n      _ref$leading = _ref.leading,\n      leading = _ref$leading === void 0 ? false : _ref$leading,\n      _ref$stacked = _ref.stacked,\n      stacked = _ref$stacked === void 0 ? false : _ref$stacked,\n      _ref$dismissible = _ref.dismissible,\n      dismissible = _ref$dismissible === void 0 ? true : _ref$dismissible,\n      _ref$timeout = _ref.timeout,\n      timeout = _ref$timeout === void 0 ? snackbar_constants_numbers.DEFAULT_AUTO_DISMISS_TIMEOUT_MS : _ref$timeout,\n      _ref$closeOnEscape = _ref.closeOnEscape,\n      closeOnEscape = _ref$closeOnEscape === void 0 ? true : _ref$closeOnEscape,\n      _ref$onClose = _ref.onClose,\n      onClose = _ref$onClose === void 0 ? Function.prototype : _ref$onClose,\n      _ref$element = _ref.element,\n      Element = _ref$element === void 0 ? \'div\' : _ref$element,\n      className = _ref.className,\n      _ref$children = _ref.children,\n      children = _ref$children === void 0 ? label : _ref$children,\n      props = Snackbar_objectWithoutProperties(_ref, Snackbar_excluded);\n\n  var timeoutRef = (0,react.useRef)();\n  useUpdated(function () {\n    if (open) {\n      timeoutRef.current = setTimeout(function () {\n        timeoutRef.current = null;\n        onClose();\n      }, timeout);\n    } else {\n      if (timeoutRef.current) {\n        clearTimeout(timeoutRef.current);\n        timeoutRef.current = null;\n      }\n    }\n\n    return function () {\n      return clearTimeout(timeoutRef.current);\n    };\n  }, [open]);\n  var handleKeyDown = (0,react.useCallback)(function (event) {\n    if (closeOnEscape && event.key === \'Escape\' || event.keyCode === 27) {\n      onClose();\n    }\n  }, [closeOnEscape, onClose]);\n  var classNames = classnames_default()(snackbar_constants_cssClasses.ROOT, (_classnames = {}, Snackbar_defineProperty(_classnames, snackbar_constants_cssClasses.LEADING, leading), Snackbar_defineProperty(_classnames, snackbar_constants_cssClasses.STACKED, stacked), _classnames), className);\n  return /*#__PURE__*/(0,jsx_runtime.jsx)(Layer, {\n    modal: true,\n    "in": open,\n    appear: appear,\n    timeout: {\n      enter: snackbar_constants_numbers.ANIMATION_OPEN_TIME_MS,\n      exit: snackbar_constants_numbers.ANIMATION_CLOSE_TIME_MS\n    },\n    classNames: {\n      appear: snackbar_constants_cssClasses.OPENING,\n      appearActive: snackbar_constants_cssClasses.OPEN,\n      enter: snackbar_constants_cssClasses.OPENING,\n      enterActive: snackbar_constants_cssClasses.OPEN,\n      enterDone: snackbar_constants_cssClasses.OPEN,\n      exit: snackbar_constants_cssClasses.CLOSING\n    },\n    mountOnEnter: true,\n    unmountOnExit: true,\n    children: /*#__PURE__*/(0,jsx_runtime.jsx)(Element, Snackbar_objectSpread(Snackbar_objectSpread({\n      ref: ref,\n      className: classNames,\n      onKeyDown: handleKeyDown\n    }, props), {}, {\n      children: /*#__PURE__*/(0,jsx_runtime.jsxs)("div", {\n        className: snackbar_constants_cssClasses.SURFACE,\n        role: "status",\n        "aria-relevant": "additions",\n        children: [/*#__PURE__*/(0,jsx_runtime.jsx)("div", {\n          className: snackbar_constants_cssClasses.LABEL,\n          "aria-atomic": "false",\n          children: children\n        }), /*#__PURE__*/(0,jsx_runtime.jsxs)("div", {\n          className: snackbar_constants_cssClasses.ACTIONS,\n          "aria-atomic": "true",\n          children: [action && /*#__PURE__*/(0,jsx_runtime.jsx)(Clone, {\n            component: action,\n            className: snackbar_constants_cssClasses.ACTION\n          }), dismissible && /*#__PURE__*/(0,jsx_runtime.jsx)(Clone, {\n            component: dismissIcon,\n            fallback: icon_button_IconButton,\n            className: snackbar_constants_cssClasses.DISMISS,\n            onClick: onClose\n          })]\n        })]\n      })\n    }))\n  });\n});\nSnackbar.displayName = \'MDCSnackbar\';\nSnackbar.propTypes = {\n  label: (prop_types_default()).string,\n  action: (prop_types_default()).element,\n  dismissIcon: (prop_types_default()).node,\n  open: (prop_types_default()).bool,\n  appear: (prop_types_default()).bool,\n  leading: (prop_types_default()).bool,\n  stacked: (prop_types_default()).bool,\n  dismissible: (prop_types_default()).bool,\n  timeout: (prop_types_default()).number,\n  closeOnEscape: (prop_types_default()).bool,\n  onClose: (prop_types_default()).func\n};\n/* harmony default export */ const snackbar_Snackbar = (Snackbar);\n;// CONCATENATED MODULE: ./src/snackbar/index.js\n\n;// CONCATENATED MODULE: ./src/switch/constants.js\nvar switch_constants_cssClasses = {\n  ROOT: \'mdc-switch\',\n  SELECTED: \'mdc-switch--selected\',\n  UNSELECTED: \'mdc-switch--unselected\',\n  TRACK: \'mdc-switch__track\',\n  HANDLE_TRACK: \'mdc-switch__handle-track\',\n  HANDLE: \'mdc-switch__handle\',\n  SHADOW: \'mdc-switch__shadow\',\n  ELEVATION_OVERLAY: \'mdc-elevation-overlay\',\n  RIPPLE: \'mdc-switch__ripple\',\n  ICONS: \'mdc-switch__icons\',\n  ICON: \'mdc-switch__icon\',\n  ICON_ON: \'mdc-switch__icon--on\',\n  ICON_OFF: \'mdc-switch__icon--off\'\n};\n;// CONCATENATED MODULE: ./src/switch/Switch.jsx\nvar Switch_excluded = ["selected", "onChange", "className"];\n\nfunction Switch_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction Switch_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { Switch_ownKeys(Object(source), true).forEach(function (key) { Switch_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { Switch_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction Switch_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction Switch_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = Switch_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction Switch_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\n\n\nvar Switch_Switch = /*#__PURE__*/(0,react.forwardRef)(function (_ref, ref) {\n  var _classnames;\n\n  var _ref$selected = _ref.selected,\n      selected = _ref$selected === void 0 ? false : _ref$selected,\n      _ref$onChange = _ref.onChange,\n      onChange = _ref$onChange === void 0 ? Function.prototype : _ref$onChange,\n      className = _ref.className,\n      props = Switch_objectWithoutProperties(_ref, Switch_excluded);\n\n  var handleClick = (0,react.useCallback)(function (event) {\n    event.stopPropagation();\n    event.target = event.currentTarget;\n    onChange(event, !selected, event.currentTarget);\n  }, [selected, onChange]);\n  var classNames = classnames_default()(switch_constants_cssClasses.ROOT, (_classnames = {}, Switch_defineProperty(_classnames, switch_constants_cssClasses.SELECTED, selected), Switch_defineProperty(_classnames, switch_constants_cssClasses.UNSELECTED, !selected), _classnames), className);\n  return /*#__PURE__*/(0,jsx_runtime.jsxs)("button", Switch_objectSpread(Switch_objectSpread({\n    ref: ref,\n    type: "button",\n    className: classNames,\n    role: "switch",\n    "aria-checked": selected,\n    onClick: handleClick\n  }, props), {}, {\n    children: [/*#__PURE__*/(0,jsx_runtime.jsx)("div", {\n      className: switch_constants_cssClasses.TRACK\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)("div", {\n      className: switch_constants_cssClasses.HANDLE_TRACK,\n      children: /*#__PURE__*/(0,jsx_runtime.jsxs)("div", {\n        className: switch_constants_cssClasses.HANDLE,\n        children: [/*#__PURE__*/(0,jsx_runtime.jsx)("div", {\n          className: switch_constants_cssClasses.SHADOW,\n          children: /*#__PURE__*/(0,jsx_runtime.jsx)("div", {\n            className: switch_constants_cssClasses.ELEVATION_OVERLAY\n          })\n        }), /*#__PURE__*/(0,jsx_runtime.jsx)("div", {\n          className: switch_constants_cssClasses.RIPPLE\n        }), /*#__PURE__*/(0,jsx_runtime.jsxs)("div", {\n          className: switch_constants_cssClasses.ICONS,\n          children: [/*#__PURE__*/(0,jsx_runtime.jsx)("svg", {\n            className: "".concat(switch_constants_cssClasses.ICON, " ").concat(switch_constants_cssClasses.ICON_ON),\n            viewBox: "0 0 24 24",\n            children: /*#__PURE__*/(0,jsx_runtime.jsx)("path", {\n              d: "M19.69,5.23L8.96,15.96l-4.23-4.23L2.96,13.5l6,6L21.46,7L19.69,5.23z"\n            })\n          }), /*#__PURE__*/(0,jsx_runtime.jsx)("svg", {\n            className: "".concat(switch_constants_cssClasses.ICON, " ").concat(switch_constants_cssClasses.ICON_OFF),\n            viewBox: "0 0 24 24",\n            children: /*#__PURE__*/(0,jsx_runtime.jsx)("path", {\n              d: "M20 13H4v-2h16v2z"\n            })\n          })]\n        })]\n      })\n    })]\n  }));\n});\nSwitch_Switch.displayName = \'MDCSwitch\';\nSwitch_Switch.propTypes = {\n  selected: (prop_types_default()).bool,\n  disabled: (prop_types_default()).bool,\n  onChange: (prop_types_default()).func\n};\n/* harmony default export */ const switch_Switch = (Switch_Switch);\n;// CONCATENATED MODULE: ./src/switch/index.js\n\n;// CONCATENATED MODULE: ./src/symbol/constants.js\nvar symbol_constants_cssClasses = {\n  ROOT: \'mdc-symbol\',\n  LIGHT: \'mdc-symbol--light\',\n  DARK: \'mdc-symbol--dark\',\n  INACTIVE: \'mdc-symbol--inactive\'\n};\nvar size = {\n  SMALLER: 16,\n  SMALL: 18,\n  MEDIUM: 24,\n  LARGE: 36,\n  LARGER: 48\n};\n;// CONCATENATED MODULE: ./src/symbol/utils.js\n\nfunction getSizeValue(arg) {\n  if (arg === undefined) return;\n\n  if (isNaN(arg)) {\n    return size[arg.toUpperCase()];\n  }\n\n  return Number(arg);\n}\nfunction getFontVariationSettings(fill, wght, grad, opsz) {\n  var parts = [];\n\n  if (fill) {\n    parts.push(\'"FILL" 1\');\n  }\n\n  if (!isNaN(wght)) {\n    parts.push(\'"wght" \' + wght);\n  }\n\n  if (!isNaN(grad)) {\n    parts.push(\'"GRAD" \' + Number(grad));\n  }\n\n  if (!isNaN(opsz)) {\n    parts.push(\'"opsz" \' + opsz);\n  } // "FILL" 0, "wght" 100, "GRAD" 0, "opsz" 48\n\n\n  return parts.length > 0 ? parts.join(\', \') : undefined;\n}\n;// CONCATENATED MODULE: ./src/symbol/Symbol.jsx\nvar Symbol_excluded = ["name", "type", "size", "weight", "grade", "filled", "light", "dark", "inactive", "element", "component", "children", "className"];\n\nfunction Symbol_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction Symbol_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { Symbol_ownKeys(Object(source), true).forEach(function (key) { Symbol_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { Symbol_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction Symbol_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction Symbol_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = Symbol_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction Symbol_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\n\n\n\nvar _Symbol = /*#__PURE__*/(0,react.forwardRef)(function (_ref, ref) {\n  var _classnames;\n\n  var name = _ref.name,\n      _ref$type = _ref.type,\n      type = _ref$type === void 0 ? \'outlined\' : _ref$type,\n      size = _ref.size,\n      weight = _ref.weight,\n      grade = _ref.grade,\n      _ref$filled = _ref.filled,\n      filled = _ref$filled === void 0 ? false : _ref$filled,\n      _ref$light = _ref.light,\n      light = _ref$light === void 0 ? false : _ref$light,\n      _ref$dark = _ref.dark,\n      dark = _ref$dark === void 0 ? false : _ref$dark,\n      _ref$inactive = _ref.inactive,\n      inactive = _ref$inactive === void 0 ? false : _ref$inactive,\n      _ref$element = _ref.element,\n      element = _ref$element === void 0 ? \'i\' : _ref$element,\n      _ref$component = _ref.component,\n      Element = _ref$component === void 0 ? element : _ref$component,\n      _ref$children = _ref.children,\n      children = _ref$children === void 0 ? name : _ref$children,\n      className = _ref.className,\n      props = Symbol_objectWithoutProperties(_ref, Symbol_excluded);\n\n  var classNames = classnames_default()(symbol_constants_cssClasses.ROOT, (_classnames = {}, Symbol_defineProperty(_classnames, "".concat(symbol_constants_cssClasses.ROOT, "--").concat(type), type), Symbol_defineProperty(_classnames, "".concat(symbol_constants_cssClasses.ROOT, "--").concat(size), size), Symbol_defineProperty(_classnames, symbol_constants_cssClasses.LIGHT, light), Symbol_defineProperty(_classnames, symbol_constants_cssClasses.DARK, dark), Symbol_defineProperty(_classnames, symbol_constants_cssClasses.INACTIVE, inactive), _classnames), className);\n  var fontVariationSettings = getFontVariationSettings(filled, weight, grade, getSizeValue(size));\n  var style = fontVariationSettings ? {\n    fontVariationSettings: fontVariationSettings\n  } : undefined;\n  return /*#__PURE__*/(0,jsx_runtime.jsx)(Element, Symbol_objectSpread(Symbol_objectSpread({\n    ref: ref,\n    style: style,\n    className: classNames\n  }, props), {}, {\n    children: children\n  }));\n});\n\n_Symbol.displayName = \'MDCSymbol\';\n_Symbol.propTypes = {\n  name: (prop_types_default()).string,\n  type: prop_types_default().oneOf([\'outlined\', \'rounded\', \'sharp\']),\n  size: prop_types_default().oneOfType([(prop_types_default()).number, (prop_types_default()).string]),\n  weight: prop_types_default().oneOfType([(prop_types_default()).number, (prop_types_default()).string]),\n  grade: prop_types_default().oneOfType([(prop_types_default()).number, (prop_types_default()).string]),\n  filled: (prop_types_default()).bool,\n  dark: (prop_types_default()).bool,\n  light: (prop_types_default()).bool,\n  inactive: (prop_types_default()).bool\n};\n/* harmony default export */ const symbol_Symbol = (_Symbol);\n;// CONCATENATED MODULE: ./src/symbol/index.js\n\n;// CONCATENATED MODULE: ./src/tabs/constants.js\nvar tabClassNames = {\n  ROOT: \'mdc-tab\',\n  ACTIVE: \'mdc-tab--active\',\n  STACKED: \'mdc-tab--stacked\',\n  MIN_WIDTH: \'mdc-tab--min-width\',\n  CONTENT: \'mdc-tab__content\',\n  ICON: \'mdc-tab__icon\',\n  LABEL: \'mdc-tab__text-label\',\n  RIPPLE: \'mdc-tab__ripple\'\n};\nvar barCssClasses = {\n  ROOT: \'mdc-tab-bar\'\n};\nvar scrollerCssClasses = {\n  ROOT: \'mdc-tab-scroller\',\n  ALIGN: \'mdc-tab-scroller--align\',\n  ANIMATING: \'mdc-tab-scroller--animating\',\n  SCROLL_AREA: \'mdc-tab-scroller__scroll-area\',\n  SCROLL_AREA_SCROLL: \'mdc-tab-scroller__scroll-area--scroll\',\n  SCROLL_CONTENT: \'mdc-tab-scroller__scroll-content\'\n};\nvar indicatorCssClasses = {\n  ROOT: \'mdc-tab-indicator\',\n  ACTIVE: \'mdc-tab-indicator--active\',\n  FADE: \'mdc-tab-indicator--fade\',\n  NO_TRANSITION: \'mdc-tab-indicator--no-transition\',\n  CONTENT: \'mdc-tab-indicator__content\',\n  CONTENT_ICON: \'mdc-tab-indicator__content--icon material-icons\',\n  CONTENT_UNDERLINE: \'mdc-tab-indicator__content--underline\'\n};\nvar Align = {\n  START: \'start\',\n  CENTER: \'center\',\n  END: \'end\'\n};\n;// CONCATENATED MODULE: ./src/tabs/context.js\n\n/* harmony default export */ const tabs_context = (/*#__PURE__*/(0,react.createContext)({}));\n;// CONCATENATED MODULE: ./src/tabs/TabIndicator.jsx\nvar TabIndicator_excluded = ["icon", "active", "fade", "underline"];\n\nfunction TabIndicator_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction TabIndicator_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { TabIndicator_ownKeys(Object(source), true).forEach(function (key) { TabIndicator_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { TabIndicator_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction TabIndicator_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction TabIndicator_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = TabIndicator_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction TabIndicator_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\n\n\n\nvar TabIndicator = /*#__PURE__*/(0,react.forwardRef)(function (_ref, ref) {\n  var _classnames, _classnames2;\n\n  var icon = _ref.icon,\n      _ref$active = _ref.active,\n      active = _ref$active === void 0 ? false : _ref$active,\n      _ref$fade = _ref.fade,\n      fade = _ref$fade === void 0 ? false : _ref$fade,\n      _ref$underline = _ref.underline,\n      underline = _ref$underline === void 0 ? !icon : _ref$underline,\n      props = TabIndicator_objectWithoutProperties(_ref, TabIndicator_excluded);\n\n  var _useContext = (0,react.useContext)(tabs_context),\n      previousTab = _useContext.previousTab;\n\n  var rootRef = (0,react.useRef)();\n  var contentRef = (0,react.useRef)();\n  (0,react.useImperativeHandle)(ref, function () {\n    return rootRef.current;\n  });\n  useUpdatedSync(function () {\n    if (fade || !active || !previousTab) return;\n    var activeIndicator = rootRef.current;\n    var previousIndicator = previousTab.querySelector(\'.mdc-tab-indicator\');\n    var previousIndicatorClientRect = previousIndicator.getBoundingClientRect();\n    var activeIndicatorClientRect = activeIndicator.getBoundingClientRect();\n    var xPosition = previousIndicatorClientRect.left - activeIndicatorClientRect.left;\n    var widthDelta = previousIndicatorClientRect.width / activeIndicatorClientRect.width;\n    rootRef.current.classList.add(indicatorCssClasses.NO_TRANSITION);\n    contentRef.current.style.transform = "translateX(".concat(xPosition, "px) scaleX(").concat(widthDelta, ")"); // Force repaint before updating classes and transform to ensure the transform properly takes effect\n\n    contentRef.current.getBoundingClientRect();\n    rootRef.current.classList.remove(indicatorCssClasses.NO_TRANSITION);\n    contentRef.current.style.transform = \'\';\n  }, [fade, active]);\n  var rootClassNames = classnames_default()(indicatorCssClasses.ROOT, (_classnames = {}, TabIndicator_defineProperty(_classnames, indicatorCssClasses.ACTIVE, active), TabIndicator_defineProperty(_classnames, indicatorCssClasses.FADE, fade), _classnames));\n  var contentClassNames = classnames_default()(indicatorCssClasses.CONTENT, (_classnames2 = {}, TabIndicator_defineProperty(_classnames2, indicatorCssClasses.CONTENT_ICON, icon), TabIndicator_defineProperty(_classnames2, indicatorCssClasses.CONTENT_UNDERLINE, underline), _classnames2));\n  return /*#__PURE__*/(0,jsx_runtime.jsx)("span", TabIndicator_objectSpread(TabIndicator_objectSpread({\n    ref: rootRef,\n    className: rootClassNames\n  }, props), {}, {\n    children: /*#__PURE__*/(0,jsx_runtime.jsx)("span", {\n      ref: contentRef,\n      className: contentClassNames,\n      children: icon\n    })\n  }));\n});\nTabIndicator.displayName = \'MDCTabIndicator\';\nTabIndicator.propTypes = {\n  icon: (prop_types_default()).node,\n  active: (prop_types_default()).bool,\n  fade: (prop_types_default()).bool,\n  underline: (prop_types_default()).bool\n};\n/* harmony default export */ const tabs_TabIndicator = (TabIndicator);\n;// CONCATENATED MODULE: ./src/tabs/Tab.jsx\nvar Tab_excluded = ["value", "icon", "label", "indicatorIcon", "active", "stacked", "minWidth", "minWidthIndicator", "fade", "underline", "onClick", "element", "component", "className", "children"];\n\nfunction Tab_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction Tab_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { Tab_ownKeys(Object(source), true).forEach(function (key) { Tab_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { Tab_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction Tab_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction Tab_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = Tab_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction Tab_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\n\n\n\n\n\nvar Tab = /*#__PURE__*/(0,react.forwardRef)(function (_ref, ref) {\n  var _classnames;\n\n  var value = _ref.value,\n      icon = _ref.icon,\n      label = _ref.label,\n      indicatorIcon = _ref.indicatorIcon,\n      _ref$active = _ref.active,\n      active = _ref$active === void 0 ? false : _ref$active,\n      _ref$stacked = _ref.stacked,\n      stacked = _ref$stacked === void 0 ? false : _ref$stacked,\n      _ref$minWidth = _ref.minWidth,\n      minWidth = _ref$minWidth === void 0 ? false : _ref$minWidth,\n      _ref$minWidthIndicato = _ref.minWidthIndicator,\n      minWidthIndicator = _ref$minWidthIndicato === void 0 ? false : _ref$minWidthIndicato,\n      _ref$fade = _ref.fade,\n      fade = _ref$fade === void 0 ? false : _ref$fade,\n      _ref$underline = _ref.underline,\n      underline = _ref$underline === void 0 ? !indicatorIcon : _ref$underline,\n      _ref$onClick = _ref.onClick,\n      onClick = _ref$onClick === void 0 ? Function.prototype : _ref$onClick,\n      _ref$element = _ref.element,\n      element = _ref$element === void 0 ? \'button\' : _ref$element,\n      _ref$component = _ref.component,\n      Element = _ref$component === void 0 ? element : _ref$component,\n      className = _ref.className,\n      _ref$children = _ref.children,\n      children = _ref$children === void 0 ? label : _ref$children,\n      props = Tab_objectWithoutProperties(_ref, Tab_excluded);\n\n  var rootRef = (0,react.useRef)();\n  (0,react.useImperativeHandle)(ref, function () {\n    return rootRef.current;\n  });\n  var handleClick = (0,react.useCallback)(function () {\n    onClick(rootRef.current, value);\n  }, [value, onClick]);\n  var classNames = classnames_default()(tabClassNames.ROOT, (_classnames = {}, Tab_defineProperty(_classnames, tabClassNames.ACTIVE, active), Tab_defineProperty(_classnames, tabClassNames.STACKED, stacked), Tab_defineProperty(_classnames, tabClassNames.MIN_WIDTH, minWidth), _classnames), className);\n  return /*#__PURE__*/(0,jsx_runtime.jsxs)(Element, Tab_objectSpread(Tab_objectSpread({\n    ref: rootRef,\n    className: classNames,\n    "data-value": value,\n    role: "tab",\n    "aria-selected": active ? \'true\' : \'false\',\n    tabIndex: active ? 0 : -1,\n    onClick: handleClick\n  }, props), {}, {\n    children: [/*#__PURE__*/(0,jsx_runtime.jsxs)("div", {\n      className: tabClassNames.CONTENT,\n      children: [icon && /*#__PURE__*/(0,jsx_runtime.jsx)(Clone, {\n        component: icon,\n        fallback: icon_Icon,\n        className: tabClassNames.ICON\n      }), children && /*#__PURE__*/(0,jsx_runtime.jsx)("span", {\n        className: tabClassNames.LABEL,\n        children: children\n      }), minWidthIndicator && /*#__PURE__*/(0,jsx_runtime.jsx)(tabs_TabIndicator, {\n        icon: indicatorIcon,\n        active: active,\n        fade: fade,\n        underline: underline\n      })]\n    }), !minWidthIndicator && /*#__PURE__*/(0,jsx_runtime.jsx)(tabs_TabIndicator, {\n      icon: indicatorIcon,\n      active: active,\n      fade: fade,\n      underline: underline\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)("div", {\n      className: tabClassNames.RIPPLE\n    })]\n  }));\n});\nTab.displayName = \'MDCTab\';\nTab.propTypes = {\n  value: (prop_types_default()).any,\n  icon: (prop_types_default()).node,\n  label: (prop_types_default()).node,\n  indicatorIcon: (prop_types_default()).node,\n  active: (prop_types_default()).bool,\n  stacked: (prop_types_default()).bool,\n  minWidth: (prop_types_default()).bool,\n  minWidthIndicator: (prop_types_default()).bool,\n  fade: (prop_types_default()).bool,\n  underline: (prop_types_default()).bool,\n  onActivate: (prop_types_default()).func\n};\n/* harmony default export */ const tabs_Tab = (Tab);\n;// CONCATENATED MODULE: ./src/tabs/TabScroller.jsx\nvar TabScroller_excluded = ["align", "activeTab", "children"];\n\nfunction TabScroller_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction TabScroller_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { TabScroller_ownKeys(Object(source), true).forEach(function (key) { TabScroller_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { TabScroller_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction TabScroller_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction TabScroller_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = TabScroller_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction TabScroller_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\n\nvar TabScroller = /*#__PURE__*/(0,react.forwardRef)(function (_ref, ref) {\n  var align = _ref.align,\n      activeTab = _ref.activeTab,\n      children = _ref.children,\n      props = TabScroller_objectWithoutProperties(_ref, TabScroller_excluded);\n\n  var scrollAreaRef = (0,react.useRef)();\n  var scrollContentRef = (0,react.useRef)();\n  useMounted(function () {\n    var scrollAreaWidth = scrollAreaRef.current.offsetWidth;\n    var scrollContentWidth = scrollContentRef.current.offsetWidth;\n\n    if (scrollContentWidth > scrollAreaWidth) {\n      scrollAreaRef.current.classList.add(scrollerCssClasses.SCROLL_AREA_SCROLL);\n    }\n  });\n  useUpdated(function () {\n    if (!activeTab) return;\n    var scrollAreaWidth = scrollAreaRef.current.offsetWidth;\n    var tabWidth = activeTab.offsetWidth;\n    var tabHalfWidth = tabWidth * 0.5;\n    var offsetLeft = activeTab.offsetLeft - scrollAreaRef.current.scrollLeft;\n    var offsetLeftDelta = activeTab.offsetLeft - scrollAreaRef.current.scrollLeft;\n    var offsetRight = activeTab.offsetLeft + tabWidth - scrollAreaRef.current.scrollLeft;\n    var offsetRightDelta = scrollAreaWidth - offsetRight;\n\n    if (offsetRight > scrollAreaWidth || offsetRightDelta < tabHalfWidth) {\n      scrollAreaRef.current.scrollBy({\n        left: offsetRight > scrollAreaWidth ? Math.abs(offsetRightDelta) + tabHalfWidth : tabHalfWidth - offsetRightDelta,\n        behavior: \'smooth\'\n      });\n    } else if (offsetLeft < 0 || offsetLeftDelta < tabHalfWidth) {\n      scrollAreaRef.current.scrollBy({\n        left: offsetLeft < 0 ? offsetLeftDelta - tabHalfWidth : -(tabHalfWidth - offsetLeftDelta),\n        behavior: \'smooth\'\n      });\n    }\n  }, [activeTab]);\n  var classNames = classnames_default()(scrollerCssClasses.ROOT, TabScroller_defineProperty({}, "".concat(scrollerCssClasses.ALIGN, "-").concat(align), align));\n  return /*#__PURE__*/(0,jsx_runtime.jsx)("div", TabScroller_objectSpread(TabScroller_objectSpread({\n    ref: ref,\n    className: classNames\n  }, props), {}, {\n    children: /*#__PURE__*/(0,jsx_runtime.jsx)("div", {\n      ref: scrollAreaRef,\n      className: scrollerCssClasses.SCROLL_AREA,\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)("div", {\n        ref: scrollContentRef,\n        className: scrollerCssClasses.SCROLL_CONTENT,\n        children: children\n      })\n    })\n  }));\n});\nTabScroller.displayName = \'MDCTabScroller\';\n/* harmony default export */ const tabs_TabScroller = (TabScroller);\n;// CONCATENATED MODULE: ./src/tabs/TabBar.jsx\nvar TabBar_excluded = ["tabs", "value", "align", "indicatorIcon", "stacked", "minWidth", "minWidthIndicator", "fade", "iconIndicator", "underlineIndicator", "onChange", "element", "component", "className", "children"];\n\nfunction TabBar_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction TabBar_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { TabBar_ownKeys(Object(source), true).forEach(function (key) { TabBar_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { TabBar_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction TabBar_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction TabBar_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = TabBar_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction TabBar_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\n\n\n\n\n\n\nvar TabBar = /*#__PURE__*/(0,react.forwardRef)(function (_ref, ref) {\n  var tabs = _ref.tabs,\n      value = _ref.value,\n      align = _ref.align,\n      indicatorIcon = _ref.indicatorIcon,\n      _ref$stacked = _ref.stacked,\n      stacked = _ref$stacked === void 0 ? false : _ref$stacked,\n      _ref$minWidth = _ref.minWidth,\n      minWidth = _ref$minWidth === void 0 ? false : _ref$minWidth,\n      _ref$minWidthIndicato = _ref.minWidthIndicator,\n      minWidthIndicator = _ref$minWidthIndicato === void 0 ? false : _ref$minWidthIndicato,\n      _ref$fade = _ref.fade,\n      fade = _ref$fade === void 0 ? false : _ref$fade,\n      _ref$iconIndicator = _ref.iconIndicator,\n      iconIndicator = _ref$iconIndicator === void 0 ? Boolean(indicatorIcon) : _ref$iconIndicator,\n      _ref$underlineIndicat = _ref.underlineIndicator,\n      underlineIndicator = _ref$underlineIndicat === void 0 ? !iconIndicator : _ref$underlineIndicat,\n      _ref$onChange = _ref.onChange,\n      onChange = _ref$onChange === void 0 ? Function.prototype : _ref$onChange,\n      _ref$element = _ref.element,\n      element = _ref$element === void 0 ? \'div\' : _ref$element,\n      _ref$component = _ref.component,\n      Element = _ref$component === void 0 ? element : _ref$component,\n      className = _ref.className,\n      _ref$children = _ref.children,\n      children = _ref$children === void 0 ? tabs === null || tabs === void 0 ? void 0 : tabs.map(function (tab) {\n    return (0,react.createElement)(tabs_Tab, tab);\n  }) : _ref$children,\n      props = TabBar_objectWithoutProperties(_ref, TabBar_excluded);\n\n  var rootRef = (0,react.useRef)();\n  var activeTabRef = (0,react.useRef)();\n  var previousTabRef = (0,react.useRef)();\n  (0,react.useImperativeHandle)(ref, function () {\n    return rootRef.current;\n  });\n  (0,react.useEffect)(function () {\n    activeTabRef.current = rootRef.current.querySelector(".".concat(tabClassNames.ACTIVE));\n  }, []);\n  var handleTabClick = (0,react.useCallback)(function (element, value) {\n    previousTabRef.current = activeTabRef.current;\n    activeTabRef.current = element;\n    onChange(value);\n  }, [onChange]);\n  var classNames = classnames_default()(barCssClasses.ROOT, className);\n  return /*#__PURE__*/(0,jsx_runtime.jsx)(Element, TabBar_objectSpread(TabBar_objectSpread({\n    ref: rootRef,\n    className: classNames,\n    role: "tablist"\n  }, props), {}, {\n    children: !isUndefined(value) ? /*#__PURE__*/(0,jsx_runtime.jsx)(tabs_context.Provider, {\n      value: {\n        activeTab: activeTabRef.current,\n        previousTab: previousTabRef.current\n      },\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(tabs_TabScroller, {\n        align: align,\n        activeTab: activeTabRef.current,\n        children: react.Children.map(children, function (tab, index) {\n          var tabValue = isUndefined(tab.props.value) ? index : tab.props.value;\n          return (0,react.cloneElement)(tab, {\n            value: tabValue,\n            active: tabValue === value,\n            indicatorIcon: tab.props.indicatorIcon || indicatorIcon,\n            stacked: tab.props.stacked || stacked,\n            minWidth: tab.props.minWidth || minWidth,\n            minWidthIndicator: tab.props.minWidthIndicator || minWidthIndicator,\n            fade: fade,\n            underline: underlineIndicator,\n            onClick: handleTabClick\n          });\n        })\n      })\n    }) : children\n  }));\n});\nTabBar.displayName = \'MDCTabBar\';\nTabBar.propTypes = {\n  align: prop_types_default().oneOf(Object.values(Align)),\n  indicatorIcon: (prop_types_default()).node,\n  stacked: (prop_types_default()).bool,\n  minWidth: (prop_types_default()).bool,\n  fade: (prop_types_default()).bool,\n  iconIndicator: (prop_types_default()).bool,\n  underlineIndicator: (prop_types_default()).bool,\n  onChange: (prop_types_default()).func\n};\nTabBar.Align = Align;\n/* harmony default export */ const tabs_TabBar = (TabBar);\n;// CONCATENATED MODULE: ./src/tabs/index.js\n\n\ntabs_Tab.Bar = tabs_TabBar;\n\n;// CONCATENATED MODULE: ./src/tooltip/constants.js\nvar tooltip_constants_numbers = {\n  BOUNDED_ANCHOR_GAP: 4,\n  UNBOUNDED_ANCHOR_GAP: 8,\n  MIN_VIEWPORT_TOOLTIP_THRESHOLD: 8,\n  ENTER_DURATION_MS: 150,\n  EXIT_DURATION_MS: 75,\n  HIDE_DELAY_MS: 600,\n  SHOW_DELAY_MS: 500,\n  MIN_HEIGHT: 24,\n  MAX_WIDTH: 200,\n  CARET_INDENTATION: 24,\n  ANIMATION_SCALE: 0.8\n};\nvar tooltip_constants_cssClasses = {\n  ROOT: \'mdc-tooltip\',\n  RICH: \'mdc-tooltip--rich\',\n  MULTILINE: \'mdc-tooltip--multiline\',\n  SHOWING: \'mdc-tooltip--showing\',\n  ACTIONS: \'mdc-tooltip--rich-actions\',\n  SHOWING_TRANSITION: \'mdc-tooltip--showing-transition\',\n  SHOWN: \'mdc-tooltip--shown\',\n  HIDE: \'mdc-tooltip--hide\',\n  HIDE_TRANSITION: \'mdc-tooltip--hide-transition\',\n  SURFACE: \'mdc-tooltip__surface\',\n  SURFACE_ANIMATION: \'mdc-tooltip__surface-animation\',\n  TITLE: \'mdc-tooltip__title\',\n  CONTENT: \'mdc-tooltip__content\',\n  CONTENT_LINK: \'mdc-tooltip__content-link\',\n  ACTION: \'mdc-tooltip__action\',\n  CARET_TOP: \'mdc-tooltip__caret-surface-top\',\n  CARET_BOTTOM: \'mdc-tooltip__caret-surface-bottom\'\n};\n;// CONCATENATED MODULE: ./src/tooltip/Tooltip.jsx\nfunction Tooltip_slicedToArray(arr, i) { return Tooltip_arrayWithHoles(arr) || Tooltip_iterableToArrayLimit(arr, i) || Tooltip_unsupportedIterableToArray(arr, i) || Tooltip_nonIterableRest(); }\n\nfunction Tooltip_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction Tooltip_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return Tooltip_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return Tooltip_arrayLikeToArray(o, minLen); }\n\nfunction Tooltip_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction Tooltip_iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction Tooltip_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\n\n\n\n\n\n\n\n\nvar Tooltip = /*#__PURE__*/(0,react.forwardRef)(function (_ref, ref) {\n  var label = _ref.label,\n      _ref$element = _ref.element,\n      Element = _ref$element === void 0 ? \'div\' : _ref$element,\n      className = _ref.className,\n      children = _ref.children;\n  var tooltipRef = (0,react.useRef)();\n  var targetRef = (0,react.useRef)(null);\n\n  var _useState = (0,react.useState)(false),\n      _useState2 = Tooltip_slicedToArray(_useState, 2),\n      active = _useState2[0],\n      setActive = _useState2[1];\n\n  (0,react.useImperativeHandle)(ref, function () {\n    return tooltipRef.current;\n  });\n  (0,react.useEffect)(function () {\n    function handleScroll() {\n      setActive(function (active) {\n        return active && !active;\n      });\n    }\n\n    document.addEventListener(\'scroll\', handleScroll);\n    return function () {\n      document.removeEventListener(\'scroll\', handleScroll);\n    };\n  }, []);\n  var handleMouseEnter = (0,react.useCallback)(function (event) {\n    targetRef.current = event.currentTarget;\n    setActive(true);\n  }, []);\n  var handleMouseLeave = (0,react.useCallback)(function () {\n    targetRef.current = null;\n    setActive(false);\n  }, []);\n  var handleEntering = (0,react.useCallback)(function () {\n    var tooltipRect = tooltipRef.current.getBoundingClientRect();\n    var targetRect = targetRef.current.getBoundingClientRect();\n    var top = targetRect.top + targetRect.height + tooltip_constants_numbers.UNBOUNDED_ANCHOR_GAP;\n    var left = targetRect.left + targetRect.width * 0.5 - tooltipRect.width * 0.5;\n    var right = left + tooltipRect.width;\n    var bottom = top + tooltipRect.height;\n    var overflowBottom = window.innerHeight - bottom;\n    var overflowRight = window.innerWidth - right;\n\n    if (tooltipRect.height > tooltip_constants_numbers.MIN_HEIGHT && tooltipRect.width >= tooltip_constants_numbers.MAX_WIDTH) {\n      tooltipRef.current.classList.add(tooltip_constants_cssClasses.MULTILINE);\n    }\n\n    if (overflowBottom < 0) {\n      tooltipRef.current.style.top = "".concat(targetRect.top - tooltipRect.height - tooltip_constants_numbers.UNBOUNDED_ANCHOR_GAP, "px");\n    } else {\n      tooltipRef.current.style.top = "".concat(top, "px");\n    }\n\n    if (overflowRight < 0) {\n      tooltipRef.current.style.left = "".concat(targetRect.right - tooltipRect.width, "px");\n    } else {\n      tooltipRef.current.style.left = "".concat(left < 0 ? targetRect.left : left, "px");\n    }\n  }, []);\n  var classNames = classnames_default()(tooltip_constants_cssClasses.ROOT, className);\n  return /*#__PURE__*/(0,jsx_runtime.jsxs)(jsx_runtime.Fragment, {\n    children: [/*#__PURE__*/(0,jsx_runtime.jsx)(Clone, {\n      component: children,\n      onMouseEnter: handleMouseEnter,\n      onMouseLeave: handleMouseLeave\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Layer, {\n      modal: true,\n      "in": active,\n      timeout: {\n        enter: tooltip_constants_numbers.SHOW_DELAY_MS,\n        exit: tooltip_constants_numbers.HIDE_DELAY_MS\n      },\n      classNames: {\n        enter: tooltip_constants_cssClasses.SHOWING_TRANSITION,\n        enterActive: "".concat(tooltip_constants_cssClasses.SHOWING_TRANSITION, " ").concat(tooltip_constants_cssClasses.SHOWING),\n        enterDone: "".concat(tooltip_constants_cssClasses.SHOWING_TRANSITION, " ").concat(tooltip_constants_cssClasses.SHOWN),\n        exit: "".concat(tooltip_constants_cssClasses.HIDE_TRANSITION, " ").concat(tooltip_constants_cssClasses.HIDE),\n        exitActive: "".concat(tooltip_constants_cssClasses.HIDE_TRANSITION, " ").concat(tooltip_constants_cssClasses.HIDE)\n      },\n      onEntering: handleEntering,\n      mountOnEnter: true,\n      unmountOnExit: true,\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(Element, {\n        ref: tooltipRef,\n        className: classNames,\n        role: "tooltip",\n        "aria-hidden": active ? undefined : \'true\',\n        children: /*#__PURE__*/(0,jsx_runtime.jsx)("div", {\n          className: "".concat(tooltip_constants_cssClasses.SURFACE, " ").concat(tooltip_constants_cssClasses.SURFACE_ANIMATION),\n          children: label\n        })\n      })\n    })]\n  });\n});\nTooltip.displayName = \'MDCTooltip\';\n/* harmony default export */ const tooltip_Tooltip = (Tooltip);\n;// CONCATENATED MODULE: ./src/tooltip/RichTooltip.jsx\nfunction RichTooltip_slicedToArray(arr, i) { return RichTooltip_arrayWithHoles(arr) || RichTooltip_iterableToArrayLimit(arr, i) || RichTooltip_unsupportedIterableToArray(arr, i) || RichTooltip_nonIterableRest(); }\n\nfunction RichTooltip_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction RichTooltip_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return RichTooltip_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return RichTooltip_arrayLikeToArray(o, minLen); }\n\nfunction RichTooltip_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction RichTooltip_iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction RichTooltip_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\n\n\n\n\n\n\n\n\nvar RichTooltip = /*#__PURE__*/(0,react.forwardRef)(function (_ref, ref) {\n  var title = _ref.title,\n      content = _ref.content,\n      actions = _ref.actions,\n      _ref$element = _ref.element,\n      Element = _ref$element === void 0 ? \'div\' : _ref$element,\n      className = _ref.className,\n      children = _ref.children;\n  var tooltipRef = (0,react.useRef)();\n  var targetRef = (0,react.useRef)();\n\n  var _useState = (0,react.useState)(false),\n      _useState2 = RichTooltip_slicedToArray(_useState, 2),\n      active = _useState2[0],\n      setActive = _useState2[1];\n\n  (0,react.useImperativeHandle)(ref, function () {\n    return tooltipRef.current;\n  });\n  (0,react.useEffect)(function () {\n    function handleScroll() {\n      setActive(function (active) {\n        return active && !active;\n      });\n    }\n\n    document.addEventListener(\'scroll\', handleScroll);\n    return function () {\n      document.removeEventListener(\'scroll\', handleScroll);\n    };\n  }, []);\n  var handleTargetMouseEnter = (0,react.useCallback)(function () {\n    setActive(true);\n  }, []);\n  var handleTargetMouseLeave = (0,react.useCallback)(function () {\n    setActive(false);\n  }, []);\n  var handleTooltipMouseEnter = (0,react.useCallback)(function () {\n    setActive(true);\n  }, []);\n  var handleTooltipMouseLeave = (0,react.useCallback)(function () {\n    setActive(false);\n  }, []);\n  var handleEntering = (0,react.useCallback)(function () {\n    var tooltipRect = tooltipRef.current.getBoundingClientRect();\n    var targetRect = targetRef.current.getBoundingClientRect();\n    var width = tooltipRef.current.firstChild.clientWidth;\n    var height = tooltipRef.current.firstChild.scrollHeight;\n    var top = targetRect.bottom + window.scrollY + tooltip_constants_numbers.UNBOUNDED_ANCHOR_GAP;\n    var left = targetRect.right + window.scrollX + tooltip_constants_numbers.UNBOUNDED_ANCHOR_GAP;\n    var right = left + width + tooltip_constants_numbers.MIN_VIEWPORT_TOOLTIP_THRESHOLD;\n    var bottom = top + height + tooltip_constants_numbers.MIN_VIEWPORT_TOOLTIP_THRESHOLD;\n    var overflowBottom = window.innerHeight - bottom;\n    var overflowRight = window.innerWidth - right;\n\n    if (overflowBottom < 0) {\n      tooltipRef.current.style.top = "".concat(top + overflowBottom, "px");\n    } else {\n      tooltipRef.current.style.top = "".concat(top, "px");\n    }\n\n    if (overflowRight < 0) {\n      tooltipRef.current.style.left = "".concat(targetRect.right - tooltipRect.width, "px");\n    } else {\n      tooltipRef.current.style.left = "".concat(left < 0 ? targetRect.left : left, "px");\n    }\n\n    tooltipRef.current.getBoundingClientRect();\n  }, []);\n  var classNames = classnames_default()(tooltip_constants_cssClasses.ROOT, tooltip_constants_cssClasses.RICH, className);\n  return /*#__PURE__*/(0,jsx_runtime.jsxs)(jsx_runtime.Fragment, {\n    children: [/*#__PURE__*/(0,jsx_runtime.jsx)(Clone, {\n      component: children,\n      ref: targetRef,\n      onMouseEnter: handleTargetMouseEnter,\n      onMouseLeave: handleTargetMouseLeave\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Layer, {\n      modal: true,\n      "in": active,\n      timeout: {\n        enter: tooltip_constants_numbers.SHOW_DELAY_MS,\n        exit: tooltip_constants_numbers.HIDE_DELAY_MS\n      },\n      classNames: {\n        enter: tooltip_constants_cssClasses.SHOWING_TRANSITION,\n        enterActive: "".concat(tooltip_constants_cssClasses.SHOWING_TRANSITION, " ").concat(tooltip_constants_cssClasses.SHOWING),\n        enterDone: "".concat(tooltip_constants_cssClasses.SHOWING_TRANSITION, " ").concat(tooltip_constants_cssClasses.SHOWN),\n        exit: tooltip_constants_cssClasses.SHOWN,\n        exitActive: "".concat(tooltip_constants_cssClasses.HIDE_TRANSITION, " ").concat(tooltip_constants_cssClasses.SHOWN),\n        exitDone: "".concat(tooltip_constants_cssClasses.HIDE_TRANSITION, " ").concat(tooltip_constants_cssClasses.HIDE)\n      },\n      mountOnEnter: true,\n      unmountOnExit: true,\n      onEntering: handleEntering,\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(Element, {\n        ref: tooltipRef,\n        className: classNames,\n        role: "tooltip",\n        "aria-hidden": active ? undefined : \'true\',\n        "aria-expanded": active ? \'true\' : undefined,\n        onMouseEnter: handleTooltipMouseEnter,\n        onMouseLeave: handleTooltipMouseLeave,\n        children: /*#__PURE__*/(0,jsx_runtime.jsxs)("div", {\n          className: "".concat(tooltip_constants_cssClasses.SURFACE, " ").concat(tooltip_constants_cssClasses.SURFACE_ANIMATION),\n          children: [title && /*#__PURE__*/(0,jsx_runtime.jsx)("h2", {\n            className: tooltip_constants_cssClasses.TITLE,\n            children: title\n          }), content && /*#__PURE__*/(0,jsx_runtime.jsx)("p", {\n            className: tooltip_constants_cssClasses.CONTENT,\n            children: content\n          }), actions && /*#__PURE__*/(0,jsx_runtime.jsx)("div", {\n            className: tooltip_constants_cssClasses.ACTIONS,\n            children: react.Children.map(actions, function (action) {\n              return /*#__PURE__*/(0,jsx_runtime.jsx)(Clone, {\n                component: action,\n                "aria-label": "action"\n              });\n            })\n          })]\n        })\n      })\n    })]\n  });\n});\nRichTooltip.displayName = \'MDCRichTooltip\';\n/* harmony default export */ const tooltip_RichTooltip = (RichTooltip);\n;// CONCATENATED MODULE: ./src/tooltip/index.js\n\n\n;// CONCATENATED MODULE: ./src/text-field/constants.js\nvar text_field_constants_cssClasses = {\n  ROOT: \'mdc-text-field\',\n  FILLED: \'mdc-text-field--filled\',\n  OUTLINED: \'mdc-text-field--outlined\',\n  TEXTAREA: \'mdc-text-field--textarea\',\n  DISABLED: \'mdc-text-field--disabled\',\n  FOCUSED: \'mdc-text-field--focused\',\n  INVALID: \'mdc-text-field--invalid\',\n  LABEL_FLOATING: \'mdc-text-field--label-floating\',\n  NO_LABEL: \'mdc-text-field--no-label\',\n  END_ALIGNED: \'mdc-text-field--end-aligned\',\n  WITH_LEADING_ICON: \'mdc-text-field--with-leading-icon\',\n  WITH_TRAILING_ICON: \'mdc-text-field--with-trailing-icon\',\n  WITH_INTERNAL_COUNTER: \'mdc-text-field--with-internal-counter\',\n  ICON: \'mdc-text-field__icon\',\n  ICON_LEADING: \'mdc-text-field__icon--leading\',\n  ICON_TRAILING: \'mdc-text-field__icon--trailing\',\n  INPUT: \'mdc-text-field__input\',\n  AFFIX: \'mdc-text-field__affix\',\n  AFFIX_PREFIX: \'mdc-text-field__affix--prefix\',\n  AFFIX_SUFFIX: \'mdc-text-field__affix--suffix\',\n  RESIZER: \'mdc-text-field__resizer\',\n  RIPPLE: \'mdc-text-field__ripple\',\n  HELPER_LINE: \'mdc-text-field-helper-line\',\n  HELPER_TEXT: \'mdc-text-field-helper-text\',\n  HELPER_TEXT_PERSISTENT: \'mdc-text-field-helper-text--persistent\',\n  HELPER_TEXT_VALIDATION: \'mdc-text-field-helper-text--validation-msg\',\n  CHARACTER_COUNTER: \'mdc-text-field-character-counter\'\n};\n;// CONCATENATED MODULE: ./src/text-field/HelperText.jsx\nvar text_field_HelperText_excluded = ["persistent", "validation"];\n\nfunction text_field_HelperText_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction text_field_HelperText_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { text_field_HelperText_ownKeys(Object(source), true).forEach(function (key) { text_field_HelperText_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { text_field_HelperText_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction text_field_HelperText_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction text_field_HelperText_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = text_field_HelperText_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction text_field_HelperText_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\n\nvar HelperText_HelperText = function HelperText(_ref) {\n  var _classnames;\n\n  var _ref$persistent = _ref.persistent,\n      persistent = _ref$persistent === void 0 ? false : _ref$persistent,\n      _ref$validation = _ref.validation,\n      validation = _ref$validation === void 0 ? false : _ref$validation,\n      props = text_field_HelperText_objectWithoutProperties(_ref, text_field_HelperText_excluded);\n\n  var classNames = classnames_default()(text_field_constants_cssClasses.HELPER_TEXT, (_classnames = {}, text_field_HelperText_defineProperty(_classnames, text_field_constants_cssClasses.HELPER_TEXT_PERSISTENT, persistent), text_field_HelperText_defineProperty(_classnames, text_field_constants_cssClasses.HELPER_TEXT_VALIDATION, validation), _classnames));\n  return /*#__PURE__*/(0,jsx_runtime.jsx)("div", text_field_HelperText_objectSpread({\n    className: classNames\n  }, props));\n};\n\nHelperText_HelperText.displayName = \'MDCTextFieldHelperText\';\nHelperText_HelperText.propTypes = {\n  persistent: (prop_types_default()).bool,\n  validation: (prop_types_default()).bool\n};\n/* harmony default export */ const text_field_HelperText = (HelperText_HelperText);\n;// CONCATENATED MODULE: ./src/text-field/CharacterCounter.jsx\nvar CharacterCounter_excluded = ["value", "maxValue"];\n\nfunction CharacterCounter_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction CharacterCounter_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { CharacterCounter_ownKeys(Object(source), true).forEach(function (key) { CharacterCounter_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { CharacterCounter_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction CharacterCounter_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction CharacterCounter_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = CharacterCounter_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction CharacterCounter_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\nfunction CharacterCounter(_ref) {\n  var _ref$value = _ref.value,\n      value = _ref$value === void 0 ? 0 : _ref$value,\n      maxValue = _ref.maxValue,\n      props = CharacterCounter_objectWithoutProperties(_ref, CharacterCounter_excluded);\n\n  return /*#__PURE__*/(0,jsx_runtime.jsx)("div", CharacterCounter_objectSpread(CharacterCounter_objectSpread({\n    className: "mdc-text-field-character-counter"\n  }, props), {}, {\n    children: value + (maxValue ? " / ".concat(maxValue) : \'\')\n  }));\n}\nCharacterCounter.displayName = \'MDCTextFieldCharacterCounter\';\nCharacterCounter.propTypes = {\n  value: (prop_types_default()).number,\n  maxValue: (prop_types_default()).number\n};\n;// CONCATENATED MODULE: ./src/text-field/Input.jsx\nvar text_field_Input_excluded = ["textarea", "autoResize", "element"];\n\nfunction text_field_Input_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction text_field_Input_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { text_field_Input_ownKeys(Object(source), true).forEach(function (key) { text_field_Input_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { text_field_Input_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction text_field_Input_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction text_field_Input_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = text_field_Input_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction text_field_Input_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\nvar Input_Input = /*#__PURE__*/(0,react.forwardRef)(function (_ref, ref) {\n  var textarea = _ref.textarea,\n      autoResize = _ref.autoResize,\n      _ref$element = _ref.element,\n      Element = _ref$element === void 0 ? textarea ? \'textarea\' : \'input\' : _ref$element,\n      props = text_field_Input_objectWithoutProperties(_ref, text_field_Input_excluded);\n\n  (0,react.useLayoutEffect)(function () {\n    if (!autoResize) return;\n    var element = ref.current;\n\n    function setHeight() {\n      element.style.height = \'1rem\';\n      element.style.height = "".concat(element.scrollHeight, "px");\n    }\n\n    setHeight();\n    element.addEventListener(\'input\', setHeight);\n    return function () {\n      return element.removeEventListener(\'input\', setHeight);\n    };\n  }, [autoResize, ref]);\n  return /*#__PURE__*/(0,jsx_runtime.jsx)(Element, text_field_Input_objectSpread({\n    ref: ref,\n    className: text_field_constants_cssClasses.INPUT\n  }, props));\n});\nInput_Input.displayName = \'MDCTextFieldInput\';\n/* harmony default export */ const text_field_Input = (Input_Input);\n;// CONCATENATED MODULE: ./src/text-field/Resizer.jsx\nvar Resizer_excluded = ["textarea", "autoResize", "children"];\n\nfunction Resizer_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction Resizer_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { Resizer_ownKeys(Object(source), true).forEach(function (key) { Resizer_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { Resizer_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction Resizer_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction Resizer_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = Resizer_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction Resizer_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\nvar Resizer = function Resizer(_ref) {\n  var textarea = _ref.textarea,\n      autoResize = _ref.autoResize,\n      children = _ref.children,\n      props = Resizer_objectWithoutProperties(_ref, Resizer_excluded);\n\n  return textarea && !autoResize ? /*#__PURE__*/(0,jsx_runtime.jsx)("span", Resizer_objectSpread(Resizer_objectSpread({\n    className: text_field_constants_cssClasses.RESIZER\n  }, props), {}, {\n    children: children\n  })) : children;\n};\n\nResizer.displayName = \'MDCTextFieldResizer\';\n/* harmony default export */ const text_field_Resizer = (Resizer);\n;// CONCATENATED MODULE: ./src/text-field/TextField.jsx\nvar TextField_excluded = ["value", "defaultValue", "label", "leadingIcon", "trailingIcon", "prefix", "suffix", "persistentHelperText", "helperText", "validationMessage", "filled", "outlined", "fullWidth", "disabled", "textarea", "endAligned", "autoResize", "characterCounter", "internalCharacterCounter", "className", "element", "onFocus", "onBlur", "onChange"];\n\nfunction TextField_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction TextField_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { TextField_ownKeys(Object(source), true).forEach(function (key) { TextField_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { TextField_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction TextField_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction TextField_slicedToArray(arr, i) { return TextField_arrayWithHoles(arr) || TextField_iterableToArrayLimit(arr, i) || TextField_unsupportedIterableToArray(arr, i) || TextField_nonIterableRest(); }\n\nfunction TextField_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction TextField_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return TextField_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return TextField_arrayLikeToArray(o, minLen); }\n\nfunction TextField_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction TextField_iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction TextField_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction TextField_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = TextField_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction TextField_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nvar TextField = /*#__PURE__*/(0,react.forwardRef)(function (_ref, ref) {\n  var _inputRef$current2, _classnames, _inputRef$current3;\n\n  var value = _ref.value,\n      defaultValue = _ref.defaultValue,\n      label = _ref.label,\n      leadingIcon = _ref.leadingIcon,\n      trailingIcon = _ref.trailingIcon,\n      prefix = _ref.prefix,\n      suffix = _ref.suffix,\n      persistentHelperText = _ref.persistentHelperText,\n      _ref$helperText = _ref.helperText,\n      helperText = _ref$helperText === void 0 ? persistentHelperText : _ref$helperText,\n      validationMessage = _ref.validationMessage,\n      _ref$filled = _ref.filled,\n      filled = _ref$filled === void 0 ? false : _ref$filled,\n      _ref$outlined = _ref.outlined,\n      outlined = _ref$outlined === void 0 ? false : _ref$outlined,\n      _ref$fullWidth = _ref.fullWidth,\n      fullWidth = _ref$fullWidth === void 0 ? false : _ref$fullWidth,\n      _ref$disabled = _ref.disabled,\n      disabled = _ref$disabled === void 0 ? false : _ref$disabled,\n      _ref$textarea = _ref.textarea,\n      textarea = _ref$textarea === void 0 ? false : _ref$textarea,\n      _ref$endAligned = _ref.endAligned,\n      endAligned = _ref$endAligned === void 0 ? false : _ref$endAligned,\n      _ref$autoResize = _ref.autoResize,\n      autoResize = _ref$autoResize === void 0 ? false : _ref$autoResize,\n      _ref$characterCounter = _ref.characterCounter,\n      characterCounter = _ref$characterCounter === void 0 ? false : _ref$characterCounter,\n      _ref$internalCharacte = _ref.internalCharacterCounter,\n      internalCharacterCounter = _ref$internalCharacte === void 0 ? characterCounter === \'internal\' : _ref$internalCharacte,\n      className = _ref.className,\n      _ref$element = _ref.element,\n      Element = _ref$element === void 0 ? \'label\' : _ref$element,\n      _ref$onFocus = _ref.onFocus,\n      onFocus = _ref$onFocus === void 0 ? Function.prototype : _ref$onFocus,\n      _ref$onBlur = _ref.onBlur,\n      onBlur = _ref$onBlur === void 0 ? Function.prototype : _ref$onBlur,\n      _ref$onChange = _ref.onChange,\n      onChange = _ref$onChange === void 0 ? Function.prototype : _ref$onChange,\n      props = TextField_objectWithoutProperties(_ref, TextField_excluded);\n\n  var inputRef = (0,react.useRef)();\n\n  var _useState = (0,react.useState)(false),\n      _useState2 = TextField_slicedToArray(_useState, 2),\n      focused = _useState2[0],\n      setFocused = _useState2[1];\n\n  var _useState3 = (0,react.useState)(false),\n      _useState4 = TextField_slicedToArray(_useState3, 2),\n      touched = _useState4[0],\n      setTouched = _useState4[1];\n\n  var _useState5 = (0,react.useState)(true),\n      _useState6 = TextField_slicedToArray(_useState5, 2),\n      valid = _useState6[0],\n      setValid = _useState6[1];\n\n  var _useState7 = (0,react.useState)(),\n      _useState8 = TextField_slicedToArray(_useState7, 2),\n      interactionCoords = _useState8[0],\n      setInteractionCoords = _useState8[1];\n\n  var _useState9 = (0,react.useState)((value === null || value === void 0 ? void 0 : value.length) || (defaultValue === null || defaultValue === void 0 ? void 0 : defaultValue.value) || 0),\n      _useState10 = TextField_slicedToArray(_useState9, 2),\n      count = _useState10[0],\n      setCount = _useState10[1];\n\n  var handleInteraction = (0,react.useCallback)(function (event) {\n    var targetClientRect = event.target.getBoundingClientRect();\n    setInteractionCoords({\n      x: event.clientX - targetClientRect.left,\n      y: event.clientY - targetClientRect.top\n    });\n  }, []);\n  var handleInputFocus = (0,react.useCallback)(function (event) {\n    setFocused(true);\n    setTouched(true);\n    onFocus(event);\n  }, [onFocus]);\n  var handleInputBlur = (0,react.useCallback)(function (event) {\n    setFocused(false);\n    setInteractionCoords();\n    onBlur(event);\n  }, [onBlur]);\n  var handleInputChange = (0,react.useCallback)(function (event) {\n    var _inputRef$current;\n\n    var value = inputRef.current.value;\n    var isValid = (_inputRef$current = inputRef.current) === null || _inputRef$current === void 0 ? void 0 : _inputRef$current.validity.valid;\n    setCount(value.length);\n    setValid(isValid);\n    onChange(event, value);\n  }, [onChange]);\n  var focusedOrHasValue = focused || value !== undefined && value !== null && value !== \'\' || defaultValue !== undefined && defaultValue !== null && defaultValue !== \'\' || Boolean((_inputRef$current2 = inputRef.current) === null || _inputRef$current2 === void 0 ? void 0 : _inputRef$current2.value);\n  var hasHelperLine = helperText || validationMessage || characterCounter;\n  var classNames = classnames_default()(text_field_constants_cssClasses.ROOT, (_classnames = {}, TextField_defineProperty(_classnames, text_field_constants_cssClasses.FILLED, filled && !fullWidth), TextField_defineProperty(_classnames, text_field_constants_cssClasses.OUTLINED, outlined && !fullWidth), TextField_defineProperty(_classnames, text_field_constants_cssClasses.TEXTAREA, textarea), TextField_defineProperty(_classnames, text_field_constants_cssClasses.DISABLED, disabled), TextField_defineProperty(_classnames, text_field_constants_cssClasses.FOCUSED, focused), TextField_defineProperty(_classnames, text_field_constants_cssClasses.INVALID, !valid && touched), TextField_defineProperty(_classnames, text_field_constants_cssClasses.LABEL_FLOATING, focusedOrHasValue), TextField_defineProperty(_classnames, text_field_constants_cssClasses.NO_LABEL, !label), TextField_defineProperty(_classnames, text_field_constants_cssClasses.END_ALIGNED, endAligned), TextField_defineProperty(_classnames, text_field_constants_cssClasses.WITH_LEADING_ICON, leadingIcon), TextField_defineProperty(_classnames, text_field_constants_cssClasses.WITH_TRAILING_ICON, trailingIcon), TextField_defineProperty(_classnames, text_field_constants_cssClasses.WITH_INTERNAL_COUNTER, internalCharacterCounter), _classnames), className);\n  return /*#__PURE__*/(0,jsx_runtime.jsxs)(jsx_runtime.Fragment, {\n    children: [/*#__PURE__*/(0,jsx_runtime.jsxs)(Element, {\n      ref: ref,\n      className: classNames,\n      onMouseDown: handleInteraction,\n      onTouchStart: handleInteraction,\n      children: [filled && /*#__PURE__*/(0,jsx_runtime.jsx)("div", {\n        className: text_field_constants_cssClasses.RIPPLE\n      }), filled && label && /*#__PURE__*/(0,jsx_runtime.jsx)(floating_label_FloatingLabel, {\n        label: label,\n        "float": focusedOrHasValue\n      }), outlined && /*#__PURE__*/(0,jsx_runtime.jsx)(notched_outline_NotchedOutline, {\n        notched: focusedOrHasValue,\n        children: label && /*#__PURE__*/(0,jsx_runtime.jsx)(floating_label_FloatingLabel, {\n          label: label,\n          "float": focusedOrHasValue\n        })\n      }), leadingIcon && /*#__PURE__*/(0,jsx_runtime.jsx)(Clone, {\n        component: leadingIcon,\n        fallback: icon_Icon,\n        className: "".concat(text_field_constants_cssClasses.ICON, " ").concat(text_field_constants_cssClasses.ICON_LEADING),\n        tabIndex: "0",\n        role: "button"\n      }), prefix && /*#__PURE__*/(0,jsx_runtime.jsx)("span", {\n        className: "".concat(text_field_constants_cssClasses.AFFIX, " ").concat(text_field_constants_cssClasses.AFFIX_PREFIX),\n        children: prefix\n      }), /*#__PURE__*/(0,jsx_runtime.jsxs)(text_field_Resizer, {\n        textarea: textarea,\n        autoResize: autoResize,\n        children: [/*#__PURE__*/(0,jsx_runtime.jsx)(text_field_Input, TextField_objectSpread({\n          ref: inputRef,\n          value: value,\n          defaultValue: defaultValue,\n          textarea: textarea,\n          autoResize: autoResize,\n          disabled: disabled,\n          onInput: handleInputChange,\n          onFocus: handleInputFocus,\n          onBlur: handleInputBlur\n        }, props)), internalCharacterCounter && /*#__PURE__*/(0,jsx_runtime.jsx)(CharacterCounter, {\n          value: count,\n          maxValue: props.maxLength\n        })]\n      }), suffix && /*#__PURE__*/(0,jsx_runtime.jsx)("span", {\n        className: "".concat(text_field_constants_cssClasses.AFFIX, " ").concat(text_field_constants_cssClasses.AFFIX_SUFFIX),\n        children: suffix\n      }), trailingIcon && /*#__PURE__*/(0,jsx_runtime.jsx)(Clone, {\n        component: trailingIcon,\n        fallback: icon_Icon,\n        className: "".concat(text_field_constants_cssClasses.ICON, " ").concat(text_field_constants_cssClasses.ICON_TRAILING),\n        tabIndex: "0",\n        role: "button"\n      }), filled && /*#__PURE__*/(0,jsx_runtime.jsx)(line_ripple_LineRipple, {\n        active: focused,\n        transformOrigin: interactionCoords === null || interactionCoords === void 0 ? void 0 : interactionCoords.x\n      })]\n    }), hasHelperLine && /*#__PURE__*/(0,jsx_runtime.jsxs)("div", {\n      className: text_field_constants_cssClasses.HELPER_LINE,\n      children: [helperText && /*#__PURE__*/(0,jsx_runtime.jsx)(text_field_HelperText, {\n        persistent: Boolean(persistentHelperText),\n        children: helperText\n      }), validationMessage && !valid && /*#__PURE__*/(0,jsx_runtime.jsx)(text_field_HelperText, {\n        validation: true,\n        children: typeof validationMessage === \'string\' ? validationMessage : (_inputRef$current3 = inputRef.current) === null || _inputRef$current3 === void 0 ? void 0 : _inputRef$current3.validationMessage\n      }), characterCounter && !internalCharacterCounter && /*#__PURE__*/(0,jsx_runtime.jsx)(CharacterCounter, {\n        value: count,\n        maxValue: props.maxLength\n      })]\n    })]\n  });\n});\nTextField.displayName = \'MDCTextField\';\nTextField.propTypes = {\n  value: (prop_types_default()).any,\n  label: (prop_types_default()).string,\n  leadingIcon: (prop_types_default()).node,\n  trailingIcon: (prop_types_default()).node,\n  prefix: (prop_types_default()).string,\n  suffix: (prop_types_default()).string,\n  outline: (prop_types_default()).bool,\n  fullWidth: (prop_types_default()).bool,\n  textarea: (prop_types_default()).bool,\n  dense: (prop_types_default()).bool,\n  disabled: (prop_types_default()).bool,\n  helperText: (prop_types_default()).string,\n  persistentHelperText: (prop_types_default()).string,\n  validationMessage: prop_types_default().oneOfType([(prop_types_default()).bool, (prop_types_default()).string])\n};\n/* harmony default export */ const text_field_TextField = (TextField);\n;// CONCATENATED MODULE: ./src/text-field/index.js\n\n;// CONCATENATED MODULE: ./src/top-app-bar/constants.js\nvar top_app_bar_constants_numbers = {\n  DEBOUNCE_THROTTLE_RESIZE_TIME_MS: 100,\n  MAX_TOP_APP_BAR_HEIGHT: 128\n};\nvar top_app_bar_constants_cssClasses = {\n  ROOT: \'mdc-top-app-bar\',\n  FIXED: \'mdc-top-app-bar--fixed\',\n  FIXED_SCROLLED: \'mdc-top-app-bar--fixed-scrolled\',\n  FIXED_ADJUST: \'mdc-top-app-bar--fixed-adjust\',\n  PROMINENT: \'mdc-top-app-bar--prominent\',\n  PROMINENT_FIXED_ADJUST: \'mdc-top-app-bar--prominent-fixed-adjust\',\n  DENSE: \'mdc-top-app-bar--dense\',\n  DENSE_FIXED_ADJUST: \'mdc-top-app-bar--dense-fixed-adjust\',\n  DENSE_PROMINENT_FIXED_ADJUST: \'mdc-top-app-bar--dense-prominent-fixed-adjust\',\n  SHORT: \'mdc-top-app-bar--short\',\n  SHORT_COLLAPSED: \'mdc-top-app-bar--short-collapsed\',\n  SHORT_FIXED_ADJUST: \'mdc-top-app-bar--short-fixed-adjust\',\n  STICKY: \'mdc-top-app-bar--sticky\',\n  STICKY_HIDDEN: \'mdc-top-app-bar--sticky-hidden\',\n  STICKY_SHOWN: \'mdc-top-app-bar--sticky-shown\',\n  RAISED: \'mdc-top-app-bar--raised\',\n  ROW: \'mdc-top-app-bar__row\',\n  SECTION: \'mdc-top-app-bar__section\',\n  SECTION_ALIGN_START: \'mdc-top-app-bar__section--align-start\',\n  SECTION_ALIGN_CENTER: \'mdc-top-app-bar__section--align-center\',\n  SECTION_ALIGN_END: \'mdc-top-app-bar__section--align-end\',\n  NAVIGATION_ICON: \'mdc-top-app-bar__navigation-icon\',\n  ACTION_ITEM: \'mdc-top-app-bar__action-item\',\n  TITLE: \'mdc-top-app-bar__title\'\n};\nvar constants_Align = {\n  START: \'start\',\n  CENTER: \'center\',\n  END: \'end\'\n};\n;// CONCATENATED MODULE: ./src/top-app-bar/TopAppBarRow.jsx\nvar TopAppBarRow_excluded = ["element", "className"];\n\nfunction TopAppBarRow_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction TopAppBarRow_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { TopAppBarRow_ownKeys(Object(source), true).forEach(function (key) { TopAppBarRow_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { TopAppBarRow_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction TopAppBarRow_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction TopAppBarRow_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = TopAppBarRow_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction TopAppBarRow_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\nvar TopAppBarRow = /*#__PURE__*/(0,react.forwardRef)(function (_ref, ref) {\n  var _ref$element = _ref.element,\n      Element = _ref$element === void 0 ? \'div\' : _ref$element,\n      className = _ref.className,\n      props = TopAppBarRow_objectWithoutProperties(_ref, TopAppBarRow_excluded);\n\n  var classNames = classnames_default()(top_app_bar_constants_cssClasses.ROW, className);\n  return /*#__PURE__*/(0,jsx_runtime.jsx)(Element, TopAppBarRow_objectSpread({\n    ref: ref,\n    className: classNames\n  }, props));\n});\nTopAppBarRow.displayName = \'MDCTopAppBarRow\';\n/* harmony default export */ const top_app_bar_TopAppBarRow = (TopAppBarRow);\n;// CONCATENATED MODULE: ./src/top-app-bar/TopAppBarSection.jsx\nvar TopAppBarSection_excluded = ["align", "element", "className"];\n\nfunction TopAppBarSection_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction TopAppBarSection_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { TopAppBarSection_ownKeys(Object(source), true).forEach(function (key) { TopAppBarSection_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { TopAppBarSection_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction TopAppBarSection_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction TopAppBarSection_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = TopAppBarSection_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction TopAppBarSection_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\n\nvar TopAppBarSection = /*#__PURE__*/(0,react.forwardRef)(function (_ref, ref) {\n  var _classnames;\n\n  var align = _ref.align,\n      _ref$element = _ref.element,\n      Element = _ref$element === void 0 ? \'section\' : _ref$element,\n      className = _ref.className,\n      props = TopAppBarSection_objectWithoutProperties(_ref, TopAppBarSection_excluded);\n\n  var classNames = classnames_default()(top_app_bar_constants_cssClasses.SECTION, (_classnames = {}, TopAppBarSection_defineProperty(_classnames, top_app_bar_constants_cssClasses.SECTION_ALIGN_START, align === constants_Align.START), TopAppBarSection_defineProperty(_classnames, top_app_bar_constants_cssClasses.SECTION_ALIGN_CENTER, align === constants_Align.CENTER), TopAppBarSection_defineProperty(_classnames, top_app_bar_constants_cssClasses.SECTION_ALIGN_END, align === constants_Align.END), _classnames), className);\n  return /*#__PURE__*/(0,jsx_runtime.jsx)(Element, TopAppBarSection_objectSpread({\n    ref: ref,\n    className: classNames\n  }, props));\n});\nTopAppBarSection.displayName = \'MDCTopAppBarSection\';\nTopAppBarSection.propTypes = {\n  align: prop_types_default().oneOf(Object.values(constants_Align))\n};\n/* harmony default export */ const top_app_bar_TopAppBarSection = (TopAppBarSection);\n;// CONCATENATED MODULE: ./src/top-app-bar/TopAppBar.jsx\nvar TopAppBar_excluded = ["title", "navigationIcon", "actionItems", "fixed", "sticky", "dense", "prominent", "short", "collapsed", "raised", "onNavigationIconClick", "element", "component", "className", "children"];\n\nfunction TopAppBar_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction TopAppBar_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { TopAppBar_ownKeys(Object(source), true).forEach(function (key) { TopAppBar_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { TopAppBar_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction TopAppBar_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction TopAppBar_slicedToArray(arr, i) { return TopAppBar_arrayWithHoles(arr) || TopAppBar_iterableToArrayLimit(arr, i) || TopAppBar_unsupportedIterableToArray(arr, i) || TopAppBar_nonIterableRest(); }\n\nfunction TopAppBar_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction TopAppBar_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return TopAppBar_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return TopAppBar_arrayLikeToArray(o, minLen); }\n\nfunction TopAppBar_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction TopAppBar_iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction TopAppBar_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction TopAppBar_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = TopAppBar_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction TopAppBar_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\n\n\n\n\n\n\nvar TopAppBar = /*#__PURE__*/(0,react.forwardRef)(function (_ref, ref) {\n  var _classnames;\n\n  var title = _ref.title,\n      navigationIcon = _ref.navigationIcon,\n      actionItems = _ref.actionItems,\n      _ref$fixed = _ref.fixed,\n      fixed = _ref$fixed === void 0 ? false : _ref$fixed,\n      _ref$sticky = _ref.sticky,\n      sticky = _ref$sticky === void 0 ? false : _ref$sticky,\n      _ref$dense = _ref.dense,\n      dense = _ref$dense === void 0 ? false : _ref$dense,\n      _ref$prominent = _ref.prominent,\n      prominent = _ref$prominent === void 0 ? false : _ref$prominent,\n      _ref$short = _ref["short"],\n      _short = _ref$short === void 0 ? false : _ref$short,\n      _ref$collapsed = _ref.collapsed,\n      collapsed = _ref$collapsed === void 0 ? false : _ref$collapsed,\n      _ref$raised = _ref.raised,\n      raised = _ref$raised === void 0 ? false : _ref$raised,\n      _ref$onNavigationIcon = _ref.onNavigationIconClick,\n      onNavigationIconClick = _ref$onNavigationIcon === void 0 ? Function.prototype : _ref$onNavigationIcon,\n      _ref$element = _ref.element,\n      element = _ref$element === void 0 ? \'header\' : _ref$element,\n      _ref$component = _ref.component,\n      Element = _ref$component === void 0 ? element : _ref$component,\n      className = _ref.className,\n      children = _ref.children,\n      props = TopAppBar_objectWithoutProperties(_ref, TopAppBar_excluded);\n\n  var rootRef = (0,react.useRef)();\n\n  var _useState = (0,react.useState)(false),\n      _useState2 = TopAppBar_slicedToArray(_useState, 2),\n      scrolled = _useState2[0],\n      setScrolled = _useState2[1];\n\n  var _useState3 = (0,react.useState)(false),\n      _useState4 = TopAppBar_slicedToArray(_useState3, 2),\n      hidden = _useState4[0],\n      setHidden = _useState4[1];\n\n  (0,react.useImperativeHandle)(ref, function () {\n    return rootRef.current;\n  });\n  (0,react.useEffect)(function () {\n    var lastScrollPosition = 0;\n\n    function handleScroll() {\n      var scrollValue = window.pageYOffset;\n\n      if (fixed) {\n        setScrolled(scrollValue > 0);\n      } else if (sticky) {\n        var currentScrollPosition = Math.max(scrollValue, 0);\n        var diff = currentScrollPosition - lastScrollPosition;\n        var shouldHide = diff > 0;\n        lastScrollPosition = currentScrollPosition;\n        setHidden(shouldHide);\n      }\n    }\n\n    window.addEventListener(\'scroll\', handleScroll);\n    return function () {\n      window.removeEventListener(\'scroll\', handleScroll);\n    };\n  }, [fixed, sticky]);\n  var classNames = classnames_default()(top_app_bar_constants_cssClasses.ROOT, (_classnames = {}, TopAppBar_defineProperty(_classnames, top_app_bar_constants_cssClasses.FIXED, fixed), TopAppBar_defineProperty(_classnames, top_app_bar_constants_cssClasses.STICKY, sticky), TopAppBar_defineProperty(_classnames, top_app_bar_constants_cssClasses.DENSE, dense), TopAppBar_defineProperty(_classnames, top_app_bar_constants_cssClasses.PROMINENT, prominent), TopAppBar_defineProperty(_classnames, top_app_bar_constants_cssClasses.SHORT, _short), TopAppBar_defineProperty(_classnames, top_app_bar_constants_cssClasses.SHORT_COLLAPSED, _short && collapsed), TopAppBar_defineProperty(_classnames, top_app_bar_constants_cssClasses.FIXED_SCROLLED, fixed && scrolled), TopAppBar_defineProperty(_classnames, top_app_bar_constants_cssClasses.STICKY_HIDDEN, sticky && hidden), TopAppBar_defineProperty(_classnames, top_app_bar_constants_cssClasses.STICKY_SHOWN, sticky && !hidden), TopAppBar_defineProperty(_classnames, top_app_bar_constants_cssClasses.RAISED, raised), _classnames), className);\n  return /*#__PURE__*/(0,jsx_runtime.jsx)(Element, TopAppBar_objectSpread(TopAppBar_objectSpread({\n    ref: rootRef,\n    className: classNames\n  }, props), {}, {\n    children: children || /*#__PURE__*/(0,jsx_runtime.jsxs)(top_app_bar_TopAppBarRow, {\n      children: [(title || navigationIcon) && /*#__PURE__*/(0,jsx_runtime.jsxs)(top_app_bar_TopAppBarSection, {\n        align: constants_Align.START,\n        children: [navigationIcon && /*#__PURE__*/(0,jsx_runtime.jsx)(Clone, {\n          component: navigationIcon,\n          fallback: icon_button_IconButton,\n          className: top_app_bar_constants_cssClasses.NAVIGATION_ICON,\n          onClick: onNavigationIconClick\n        }), title && /*#__PURE__*/(0,jsx_runtime.jsx)(Clone, {\n          component: title,\n          fallback: "span",\n          className: top_app_bar_constants_cssClasses.TITLE\n        })]\n      }), actionItems && /*#__PURE__*/(0,jsx_runtime.jsx)(top_app_bar_TopAppBarSection, {\n        align: constants_Align.END,\n        children: react.Children.map(actionItems, function (item) {\n          return /*#__PURE__*/(0,jsx_runtime.jsx)(Clone, {\n            component: item,\n            className: top_app_bar_constants_cssClasses.ACTION_ITEM\n          });\n        })\n      })]\n    })\n  }));\n});\nTopAppBar.displayName = \'MDCTopAppBar\';\nTopAppBar.propTypes = {\n  title: (prop_types_default()).node,\n  navigationIcon: (prop_types_default()).node,\n  actionItems: prop_types_default().oneOfType([(prop_types_default()).element, prop_types_default().arrayOf((prop_types_default()).element)]),\n  fixed: (prop_types_default()).bool,\n  sticky: (prop_types_default()).bool,\n  dense: (prop_types_default()).bool,\n  prominent: (prop_types_default()).bool,\n  "short": (prop_types_default()).bool,\n  collapsed: (prop_types_default()).bool,\n  raised: (prop_types_default()).bool\n};\n/* harmony default export */ const top_app_bar_TopAppBar = (TopAppBar);\n;// CONCATENATED MODULE: ./src/top-app-bar/TopAppBarActionItem.jsx\nvar TopAppBarActionItem_excluded = ["element", "component", "className"];\n\nfunction TopAppBarActionItem_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction TopAppBarActionItem_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { TopAppBarActionItem_ownKeys(Object(source), true).forEach(function (key) { TopAppBarActionItem_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { TopAppBarActionItem_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction TopAppBarActionItem_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction TopAppBarActionItem_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = TopAppBarActionItem_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction TopAppBarActionItem_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\nvar TopAppBarActionItem = /*#__PURE__*/(0,react.forwardRef)(function (_ref, ref) {\n  var _ref$element = _ref.element,\n      element = _ref$element === void 0 ? \'span\' : _ref$element,\n      _ref$component = _ref.component,\n      Element = _ref$component === void 0 ? element : _ref$component,\n      className = _ref.className,\n      props = TopAppBarActionItem_objectWithoutProperties(_ref, TopAppBarActionItem_excluded);\n\n  var classNames = classnames_default()(top_app_bar_constants_cssClasses.ACTION_ITEM, className);\n  return /*#__PURE__*/(0,jsx_runtime.jsx)(Element, TopAppBarActionItem_objectSpread({\n    ref: ref,\n    className: classNames\n  }, props));\n});\nTopAppBarActionItem.displayName = \'MDCTopAppBarActionItem\';\n/* harmony default export */ const top_app_bar_TopAppBarActionItem = (TopAppBarActionItem);\n;// CONCATENATED MODULE: ./src/top-app-bar/TopAppBarFixedAdjust.jsx\nvar TopAppBarFixedAdjust_excluded = ["dense", "prominent", "short", "element", "component", "className"];\n\nfunction TopAppBarFixedAdjust_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction TopAppBarFixedAdjust_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { TopAppBarFixedAdjust_ownKeys(Object(source), true).forEach(function (key) { TopAppBarFixedAdjust_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { TopAppBarFixedAdjust_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction TopAppBarFixedAdjust_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction TopAppBarFixedAdjust_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = TopAppBarFixedAdjust_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction TopAppBarFixedAdjust_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\nvar TopAppBarFixedAdjust = /*#__PURE__*/(0,react.forwardRef)(function (_ref, ref) {\n  var _classnames;\n\n  var _ref$dense = _ref.dense,\n      dense = _ref$dense === void 0 ? false : _ref$dense,\n      _ref$prominent = _ref.prominent,\n      prominent = _ref$prominent === void 0 ? false : _ref$prominent,\n      _ref$short = _ref["short"],\n      _short = _ref$short === void 0 ? false : _ref$short,\n      _ref$element = _ref.element,\n      element = _ref$element === void 0 ? \'div\' : _ref$element,\n      _ref$component = _ref.component,\n      Element = _ref$component === void 0 ? element : _ref$component,\n      className = _ref.className,\n      props = TopAppBarFixedAdjust_objectWithoutProperties(_ref, TopAppBarFixedAdjust_excluded);\n\n  var classNames = classnames_default()(top_app_bar_constants_cssClasses.FIXED_ADJUST, (_classnames = {}, TopAppBarFixedAdjust_defineProperty(_classnames, top_app_bar_constants_cssClasses.DENSE_FIXED_ADJUST, dense), TopAppBarFixedAdjust_defineProperty(_classnames, top_app_bar_constants_cssClasses.PROMINENT_FIXED_ADJUST, prominent), TopAppBarFixedAdjust_defineProperty(_classnames, top_app_bar_constants_cssClasses.DENSE_PROMINENT_FIXED_ADJUST, dense && prominent), TopAppBarFixedAdjust_defineProperty(_classnames, top_app_bar_constants_cssClasses.SHORT_FIXED_ADJUST, _short), _classnames), className);\n  return /*#__PURE__*/(0,jsx_runtime.jsx)(Element, TopAppBarFixedAdjust_objectSpread({\n    ref: ref,\n    className: classNames\n  }, props));\n});\nTopAppBarFixedAdjust.displayName = \'MDCTopAppBarFixedAdjust\';\n/* harmony default export */ const top_app_bar_TopAppBarFixedAdjust = (TopAppBarFixedAdjust);\n;// CONCATENATED MODULE: ./src/top-app-bar/TopAppBarNavigationIcon.jsx\nvar TopAppBarNavigationIcon_excluded = ["className"];\n\nfunction TopAppBarNavigationIcon_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction TopAppBarNavigationIcon_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { TopAppBarNavigationIcon_ownKeys(Object(source), true).forEach(function (key) { TopAppBarNavigationIcon_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { TopAppBarNavigationIcon_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction TopAppBarNavigationIcon_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction TopAppBarNavigationIcon_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = TopAppBarNavigationIcon_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction TopAppBarNavigationIcon_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\n\nvar TopAppBarNavigationIcon = /*#__PURE__*/(0,react.forwardRef)(function (_ref, ref) {\n  var className = _ref.className,\n      props = TopAppBarNavigationIcon_objectWithoutProperties(_ref, TopAppBarNavigationIcon_excluded);\n\n  var classNames = classnames_default()(top_app_bar_constants_cssClasses.NAVIGATION_ICON, className);\n  return /*#__PURE__*/(0,jsx_runtime.jsx)(icon_button_IconButton, TopAppBarNavigationIcon_objectSpread({\n    ref: ref,\n    className: classNames\n  }, props));\n});\nTopAppBarNavigationIcon.displayName = \'MDCTopAppBarNavigationIcon\';\n/* harmony default export */ const top_app_bar_TopAppBarNavigationIcon = (TopAppBarNavigationIcon);\n;// CONCATENATED MODULE: ./src/top-app-bar/TopAppBarTitle.jsx\nvar TopAppBarTitle_excluded = ["element", "className"];\n\nfunction TopAppBarTitle_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction TopAppBarTitle_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { TopAppBarTitle_ownKeys(Object(source), true).forEach(function (key) { TopAppBarTitle_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { TopAppBarTitle_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction TopAppBarTitle_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction TopAppBarTitle_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = TopAppBarTitle_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction TopAppBarTitle_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\nvar TopAppBarTitle = /*#__PURE__*/(0,react.forwardRef)(function (_ref, ref) {\n  var _ref$element = _ref.element,\n      Element = _ref$element === void 0 ? \'span\' : _ref$element,\n      className = _ref.className,\n      props = TopAppBarTitle_objectWithoutProperties(_ref, TopAppBarTitle_excluded);\n\n  var classNames = classnames_default()(top_app_bar_constants_cssClasses.TITLE, className);\n  return /*#__PURE__*/(0,jsx_runtime.jsx)(Element, TopAppBarTitle_objectSpread({\n    ref: ref,\n    className: classNames\n  }, props));\n});\nTopAppBarTitle.displayName = \'MDCTopAppBarTitle\';\n/* harmony default export */ const top_app_bar_TopAppBarTitle = (TopAppBarTitle);\n;// CONCATENATED MODULE: ./src/top-app-bar/index.js\n\n\n\n\n\n\n\ntop_app_bar_TopAppBar.ActionItem = top_app_bar_TopAppBarActionItem;\ntop_app_bar_TopAppBar.FixedAdjust = top_app_bar_TopAppBarFixedAdjust;\ntop_app_bar_TopAppBar.NavigationIcon = top_app_bar_TopAppBarNavigationIcon;\ntop_app_bar_TopAppBar.Row = top_app_bar_TopAppBarRow;\ntop_app_bar_TopAppBar.Section = top_app_bar_TopAppBarSection;\ntop_app_bar_TopAppBar.Title = top_app_bar_TopAppBarTitle;\n\n;// CONCATENATED MODULE: ./src/typography/constants.js\nvar elementsByType = {\n  headline1: \'h1\',\n  headline2: \'h2\',\n  headline3: \'h3\',\n  headline4: \'h4\',\n  headline5: \'h5\',\n  headline6: \'h6\',\n  subtitle1: \'h5\',\n  subtitle2: \'h6\',\n  body1: \'p\',\n  body2: \'p\',\n  button: \'span\',\n  caption: \'span\',\n  overline: \'span\'\n};\nvar typography_constants_cssClasses = {\n  ROOT: \'mdc-typography\',\n  DISPLAY: \'mdc-typography--display\',\n  ALIGN: \'mdc-typography--align\',\n  NO_MARGIN: \'mdc-typography--no-margin\',\n  NO_WRAP: \'mdc-typography--no-wrap\'\n};\n;// CONCATENATED MODULE: ./src/typography/Typography.jsx\nvar Typography_excluded = ["type", "display", "align", "noMargin", "noWrap", "element", "component", "className"];\n\nfunction Typography_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction Typography_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { Typography_ownKeys(Object(source), true).forEach(function (key) { Typography_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { Typography_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction Typography_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction Typography_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = Typography_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction Typography_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\n\nvar Typography = /*#__PURE__*/(0,react.forwardRef)(function (_ref, ref) {\n  var _classnames;\n\n  var _ref$type = _ref.type,\n      type = _ref$type === void 0 ? \'body1\' : _ref$type,\n      display = _ref.display,\n      align = _ref.align,\n      _ref$noMargin = _ref.noMargin,\n      noMargin = _ref$noMargin === void 0 ? false : _ref$noMargin,\n      _ref$noWrap = _ref.noWrap,\n      noWrap = _ref$noWrap === void 0 ? false : _ref$noWrap,\n      _ref$element = _ref.element,\n      element = _ref$element === void 0 ? elementsByType[type] : _ref$element,\n      _ref$component = _ref.component,\n      Element = _ref$component === void 0 ? element : _ref$component,\n      className = _ref.className,\n      props = Typography_objectWithoutProperties(_ref, Typography_excluded);\n\n  var classNames = classnames_default()(typography_constants_cssClasses.ROOT, "".concat(typography_constants_cssClasses.ROOT, "--").concat(type), (_classnames = {}, Typography_defineProperty(_classnames, "".concat(typography_constants_cssClasses.DISPLAY, "-").concat(display), display), Typography_defineProperty(_classnames, "".concat(typography_constants_cssClasses.ALIGN, "-").concat(align), align), Typography_defineProperty(_classnames, typography_constants_cssClasses.NO_MARGIN, noMargin), Typography_defineProperty(_classnames, typography_constants_cssClasses.NO_WRAP, noWrap), _classnames), className);\n  return /*#__PURE__*/(0,jsx_runtime.jsx)(Element, Typography_objectSpread({\n    ref: ref,\n    className: classNames\n  }, props));\n});\nTypography.displayName = \'MDCTypography\';\nTypography.propTypes = {\n  type: prop_types_default().oneOf(Object.keys(elementsByType)),\n  display: prop_types_default().oneOf([\'block\', \'inline\', \'inline-block\']),\n  align: prop_types_default().oneOf([\'left\', \'center\', \'right\', \'justify\']),\n  noMargin: (prop_types_default()).bool,\n  noWrap: (prop_types_default()).bool\n};\n/* harmony default export */ const typography_Typography = (Typography);\n;// CONCATENATED MODULE: ./src/typography/index.js\n\n;// CONCATENATED MODULE: ./src/index.js\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n;// CONCATENATED MODULE: ./docs/src/utils/code.js\nfunction code_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { code_typeof = function _typeof(obj) { return typeof obj; }; } else { code_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return code_typeof(obj); }\n\nfunction code_slicedToArray(arr, i) { return code_arrayWithHoles(arr) || code_iterableToArrayLimit(arr, i) || code_unsupportedIterableToArray(arr, i) || code_nonIterableRest(); }\n\nfunction code_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction code_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return code_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return code_arrayLikeToArray(o, minLen); }\n\nfunction code_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction code_iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction code_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\n\nfunction jsxToHtml(root) {\n  return react.Children.toArray(root).map(function (item) {\n    return printComponent(item);\n  }).join(\'\\n\');\n}\nfunction printComponent(component) {\n  var depth = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  var type = typeof component.type === \'string\' ? component.type : component.type.displayName.replace(\'MDC\', \'\');\n  var children = component.props.children;\n  var props = Object.entries(component.props).filter(function (_ref) {\n    var _ref2 = code_slicedToArray(_ref, 2),\n        key = _ref2[0],\n        value = _ref2[1];\n\n    return key !== \'children\' && value !== undefined;\n  });\n  var indent = \'  \'.repeat(depth);\n  var result = indent + "<".concat(type);\n\n  if (!isEmpty(props)) {\n    result += " ".concat(printProps(props, depth + 1));\n  }\n\n  if (!children) {\n    result += result.endsWith(\'\\n\') ? indent + \'/>\' : \' />\';\n  } else if ( /*#__PURE__*/(0,react.isValidElement)(children)) {\n    result += ">\\n".concat(printComponent(children, depth + 1), "\\n").concat(indent, "</").concat(type, ">");\n  } else if (Array.isArray(children)) {\n    result += result.endsWith(\'\\n\') ? indent + \'>\\n\' : \'>\\n\';\n    result += children.map(function (child) {\n      return printComponent(child, depth + 1);\n    }).join(\'\\n\');\n    result += "\\n".concat(indent, "</").concat(type, ">");\n  } else {\n    result += ">".concat(children, "</").concat(type, ">");\n  }\n\n  return result;\n}\n\nfunction printProps(props, depth) {\n  var result = \'\';\n  var indent = \'  \'.repeat(depth);\n\n  if (props.length < 3) {\n    result += props.map(printProp).join(\' \');\n  } else {\n    result += "\\n".concat(indent).concat(props.map(printProp).join(\'\\n\' + indent), "\\n");\n  }\n\n  return result;\n}\n\nfunction printProp(_ref3) {\n  var _ref4 = code_slicedToArray(_ref3, 2),\n      key = _ref4[0],\n      value = _ref4[1];\n\n  if (value === true) {\n    return key;\n  } else if (typeof value === \'string\') {\n    return "".concat(key, "=\\"").concat(value, "\\"");\n  } else {\n    return "".concat(key, "={").concat(printValue(value), "}");\n  }\n}\n\nfunction printValue(value) {\n  if (typeof value === \'string\') {\n    return "\'".concat(value, "\'");\n  } else if (Array.isArray(value)) {\n    return "[".concat(value.map(function (v) {\n      return printValue(v);\n    }).join(\', \'), "]");\n  } else if ( /*#__PURE__*/(0,react.isValidElement)(value)) {\n    return printComponent(value);\n  } else if (typeof value === \'function\') {\n    return "".concat(value.name || \'[Function]\');\n  } else {\n    return value;\n  }\n}\n\nfunction isEmpty(value) {\n  if (!value) {\n    return true;\n  } else if (Array.isArray(value)) {\n    return value.length === 0;\n  } else if (code_typeof(value) === \'object\') {\n    return Object.keys(value).length === 0;\n  }\n}\n// EXTERNAL MODULE: ./node_modules/highlight.js/lib/core.js\nvar core = __webpack_require__(390);\n;// CONCATENATED MODULE: ./node_modules/highlight.js/es/core.js\n// https://nodejs.org/api/packages.html#packages_writing_dual_packages_while_avoiding_or_minimizing_hazards\n\n/* harmony default export */ const es_core = (core);\n\n;// CONCATENATED MODULE: ./node_modules/highlight.js/es/languages/javascript.js\nconst IDENT_RE = \'[A-Za-z$_][0-9A-Za-z$_]*\';\nconst KEYWORDS = [\n  "as", // for exports\n  "in",\n  "of",\n  "if",\n  "for",\n  "while",\n  "finally",\n  "var",\n  "new",\n  "function",\n  "do",\n  "return",\n  "void",\n  "else",\n  "break",\n  "catch",\n  "instanceof",\n  "with",\n  "throw",\n  "case",\n  "default",\n  "try",\n  "switch",\n  "continue",\n  "typeof",\n  "delete",\n  "let",\n  "yield",\n  "const",\n  "class",\n  // JS handles these with a special rule\n  // "get",\n  // "set",\n  "debugger",\n  "async",\n  "await",\n  "static",\n  "import",\n  "from",\n  "export",\n  "extends"\n];\nconst LITERALS = [\n  "true",\n  "false",\n  "null",\n  "undefined",\n  "NaN",\n  "Infinity"\n];\n\nconst TYPES = [\n  "Intl",\n  "DataView",\n  "Number",\n  "Math",\n  "Date",\n  "String",\n  "RegExp",\n  "Object",\n  "Function",\n  "Boolean",\n  "Error",\n  "Symbol",\n  "Set",\n  "Map",\n  "WeakSet",\n  "WeakMap",\n  "Proxy",\n  "Reflect",\n  "JSON",\n  "Promise",\n  "Float64Array",\n  "Int16Array",\n  "Int32Array",\n  "Int8Array",\n  "Uint16Array",\n  "Uint32Array",\n  "Float32Array",\n  "Array",\n  "Uint8Array",\n  "Uint8ClampedArray",\n  "ArrayBuffer",\n  "BigInt64Array",\n  "BigUint64Array",\n  "BigInt"\n];\n\nconst ERROR_TYPES = [\n  "EvalError",\n  "InternalError",\n  "RangeError",\n  "ReferenceError",\n  "SyntaxError",\n  "TypeError",\n  "URIError"\n];\n\nconst BUILT_IN_GLOBALS = [\n  "setInterval",\n  "setTimeout",\n  "clearInterval",\n  "clearTimeout",\n\n  "require",\n  "exports",\n\n  "eval",\n  "isFinite",\n  "isNaN",\n  "parseFloat",\n  "parseInt",\n  "decodeURI",\n  "decodeURIComponent",\n  "encodeURI",\n  "encodeURIComponent",\n  "escape",\n  "unescape"\n];\n\nconst BUILT_IN_VARIABLES = [\n  "arguments",\n  "this",\n  "super",\n  "console",\n  "window",\n  "document",\n  "localStorage",\n  "module",\n  "global" // Node.js\n];\n\nconst BUILT_INS = [].concat(\n  BUILT_IN_GLOBALS,\n  TYPES,\n  ERROR_TYPES\n);\n\n/**\n * @param {string} value\n * @returns {RegExp}\n * */\n\n/**\n * @param {RegExp | string } re\n * @returns {string}\n */\nfunction source(re) {\n  if (!re) return null;\n  if (typeof re === "string") return re;\n\n  return re.source;\n}\n\n/**\n * @param {RegExp | string } re\n * @returns {string}\n */\nfunction lookahead(re) {\n  return concat(\'(?=\', re, \')\');\n}\n\n/**\n * @param {...(RegExp | string) } args\n * @returns {string}\n */\nfunction concat(...args) {\n  const joined = args.map((x) => source(x)).join("");\n  return joined;\n}\n\n/*\nLanguage: JavaScript\nDescription: JavaScript (JS) is a lightweight, interpreted, or just-in-time compiled programming language with first-class functions.\nCategory: common, scripting, web\nWebsite: https://developer.mozilla.org/en-US/docs/Web/JavaScript\n*/\n\n/** @type LanguageFn */\nfunction javascript(hljs) {\n  /**\n   * Takes a string like "<Booger" and checks to see\n   * if we can find a matching "</Booger" later in the\n   * content.\n   * @param {RegExpMatchArray} match\n   * @param {{after:number}} param1\n   */\n  const hasClosingTag = (match, { after }) => {\n    const tag = "</" + match[0].slice(1);\n    const pos = match.input.indexOf(tag, after);\n    return pos !== -1;\n  };\n\n  const IDENT_RE$1 = IDENT_RE;\n  const FRAGMENT = {\n    begin: \'<>\',\n    end: \'</>\'\n  };\n  const XML_TAG = {\n    begin: /<[A-Za-z0-9\\\\._:-]+/,\n    end: /\\/[A-Za-z0-9\\\\._:-]+>|\\/>/,\n    /**\n     * @param {RegExpMatchArray} match\n     * @param {CallbackResponse} response\n     */\n    isTrulyOpeningTag: (match, response) => {\n      const afterMatchIndex = match[0].length + match.index;\n      const nextChar = match.input[afterMatchIndex];\n      // nested type?\n      // HTML should not include another raw `<` inside a tag\n      // But a type might: `<Array<Array<number>>`, etc.\n      if (nextChar === "<") {\n        response.ignoreMatch();\n        return;\n      }\n      // <something>\n      // This is now either a tag or a type.\n      if (nextChar === ">") {\n        // if we cannot find a matching closing tag, then we\n        // will ignore it\n        if (!hasClosingTag(match, { after: afterMatchIndex })) {\n          response.ignoreMatch();\n        }\n      }\n    }\n  };\n  const KEYWORDS$1 = {\n    $pattern: IDENT_RE,\n    keyword: KEYWORDS,\n    literal: LITERALS,\n    built_in: BUILT_INS,\n    "variable.language": BUILT_IN_VARIABLES\n  };\n\n  // https://tc39.es/ecma262/#sec-literals-numeric-literals\n  const decimalDigits = \'[0-9](_?[0-9])*\';\n  const frac = `\\\\.(${decimalDigits})`;\n  // DecimalIntegerLiteral, including Annex B NonOctalDecimalIntegerLiteral\n  // https://tc39.es/ecma262/#sec-additional-syntax-numeric-literals\n  const decimalInteger = `0|[1-9](_?[0-9])*|0[0-7]*[89][0-9]*`;\n  const NUMBER = {\n    className: \'number\',\n    variants: [\n      // DecimalLiteral\n      { begin: `(\\\\b(${decimalInteger})((${frac})|\\\\.)?|(${frac}))` +\n        `[eE][+-]?(${decimalDigits})\\\\b` },\n      { begin: `\\\\b(${decimalInteger})\\\\b((${frac})\\\\b|\\\\.)?|(${frac})\\\\b` },\n\n      // DecimalBigIntegerLiteral\n      { begin: `\\\\b(0|[1-9](_?[0-9])*)n\\\\b` },\n\n      // NonDecimalIntegerLiteral\n      { begin: "\\\\b0[xX][0-9a-fA-F](_?[0-9a-fA-F])*n?\\\\b" },\n      { begin: "\\\\b0[bB][0-1](_?[0-1])*n?\\\\b" },\n      { begin: "\\\\b0[oO][0-7](_?[0-7])*n?\\\\b" },\n\n      // LegacyOctalIntegerLiteral (does not include underscore separators)\n      // https://tc39.es/ecma262/#sec-additional-syntax-numeric-literals\n      { begin: "\\\\b0[0-7]+n?\\\\b" },\n    ],\n    relevance: 0\n  };\n\n  const SUBST = {\n    className: \'subst\',\n    begin: \'\\\\$\\\\{\',\n    end: \'\\\\}\',\n    keywords: KEYWORDS$1,\n    contains: [] // defined later\n  };\n  const HTML_TEMPLATE = {\n    begin: \'html`\',\n    end: \'\',\n    starts: {\n      end: \'`\',\n      returnEnd: false,\n      contains: [\n        hljs.BACKSLASH_ESCAPE,\n        SUBST\n      ],\n      subLanguage: \'xml\'\n    }\n  };\n  const CSS_TEMPLATE = {\n    begin: \'css`\',\n    end: \'\',\n    starts: {\n      end: \'`\',\n      returnEnd: false,\n      contains: [\n        hljs.BACKSLASH_ESCAPE,\n        SUBST\n      ],\n      subLanguage: \'css\'\n    }\n  };\n  const TEMPLATE_STRING = {\n    className: \'string\',\n    begin: \'`\',\n    end: \'`\',\n    contains: [\n      hljs.BACKSLASH_ESCAPE,\n      SUBST\n    ]\n  };\n  const JSDOC_COMMENT = hljs.COMMENT(\n    /\\/\\*\\*(?!\\/)/,\n    \'\\\\*/\',\n    {\n      relevance: 0,\n      contains: [\n        {\n          begin: \'(?=@[A-Za-z]+)\',\n          relevance: 0,\n          contains: [\n            {\n              className: \'doctag\',\n              begin: \'@[A-Za-z]+\'\n            },\n            {\n              className: \'type\',\n              begin: \'\\\\{\',\n              end: \'\\\\}\',\n              excludeEnd: true,\n              excludeBegin: true,\n              relevance: 0\n            },\n            {\n              className: \'variable\',\n              begin: IDENT_RE$1 + \'(?=\\\\s*(-)|$)\',\n              endsParent: true,\n              relevance: 0\n            },\n            // eat spaces (not newlines) so we can find\n            // types or variables\n            {\n              begin: /(?=[^\\n])\\s/,\n              relevance: 0\n            }\n          ]\n        }\n      ]\n    }\n  );\n  const COMMENT = {\n    className: "comment",\n    variants: [\n      JSDOC_COMMENT,\n      hljs.C_BLOCK_COMMENT_MODE,\n      hljs.C_LINE_COMMENT_MODE\n    ]\n  };\n  const SUBST_INTERNALS = [\n    hljs.APOS_STRING_MODE,\n    hljs.QUOTE_STRING_MODE,\n    HTML_TEMPLATE,\n    CSS_TEMPLATE,\n    TEMPLATE_STRING,\n    NUMBER,\n    hljs.REGEXP_MODE\n  ];\n  SUBST.contains = SUBST_INTERNALS\n    .concat({\n      // we need to pair up {} inside our subst to prevent\n      // it from ending too early by matching another }\n      begin: /\\{/,\n      end: /\\}/,\n      keywords: KEYWORDS$1,\n      contains: [\n        "self"\n      ].concat(SUBST_INTERNALS)\n    });\n  const SUBST_AND_COMMENTS = [].concat(COMMENT, SUBST.contains);\n  const PARAMS_CONTAINS = SUBST_AND_COMMENTS.concat([\n    // eat recursive parens in sub expressions\n    {\n      begin: /\\(/,\n      end: /\\)/,\n      keywords: KEYWORDS$1,\n      contains: ["self"].concat(SUBST_AND_COMMENTS)\n    }\n  ]);\n  const PARAMS = {\n    className: \'params\',\n    begin: /\\(/,\n    end: /\\)/,\n    excludeBegin: true,\n    excludeEnd: true,\n    keywords: KEYWORDS$1,\n    contains: PARAMS_CONTAINS\n  };\n\n  // ES6 classes\n  const CLASS_OR_EXTENDS = {\n    variants: [\n      {\n        match: [\n          /class/,\n          /\\s+/,\n          IDENT_RE$1\n        ],\n        scope: {\n          1: "keyword",\n          3: "title.class"\n        }\n      },\n      {\n        match: [\n          /extends/,\n          /\\s+/,\n          concat(IDENT_RE$1, "(", concat(/\\./, IDENT_RE$1), ")*")\n        ],\n        scope: {\n          1: "keyword",\n          3: "title.class.inherited"\n        }\n      }\n    ]\n  };\n\n  const CLASS_REFERENCE = {\n    relevance: 0,\n    match: /\\b[A-Z][a-z]+([A-Z][a-z]+)*/,\n    className: "title.class",\n    keywords: {\n      _: [\n        // se we still get relevance credit for JS library classes\n        ...TYPES,\n        ...ERROR_TYPES\n      ]\n    }\n  };\n\n  const USE_STRICT = {\n    label: "use_strict",\n    className: \'meta\',\n    relevance: 10,\n    begin: /^\\s*[\'"]use (strict|asm)[\'"]/\n  };\n\n  const FUNCTION_DEFINITION = {\n    variants: [\n      {\n        match: [\n          /function/,\n          /\\s+/,\n          IDENT_RE$1,\n          /(?=\\s*\\()/\n        ]\n      },\n      // anonymous function\n      {\n        match: [\n          /function/,\n          /\\s*(?=\\()/\n        ]\n      }\n    ],\n    className: {\n      1: "keyword",\n      3: "title.function"\n    },\n    label: "func.def",\n    contains: [ PARAMS ],\n    illegal: /%/\n  };\n\n  const UPPER_CASE_CONSTANT = {\n    relevance: 0,\n    match: /\\b[A-Z][A-Z_0-9]+\\b/,\n    className: "variable.constant"\n  };\n\n  function noneOf(list) {\n    return concat("(?!", list.join("|"), ")");\n  }\n\n  const FUNCTION_CALL = {\n    match: concat(\n      /\\b/,\n      noneOf([\n        ...BUILT_IN_GLOBALS,\n        "super"\n      ]),\n      IDENT_RE$1, lookahead(/\\(/)),\n    className: "title.function",\n    relevance: 0\n  };\n\n  const PROPERTY_ACCESS = {\n    begin: concat(/\\./, lookahead(\n      concat(IDENT_RE$1, /(?![0-9A-Za-z$_(])/)\n    )),\n    end: IDENT_RE$1,\n    excludeBegin: true,\n    keywords: "prototype",\n    className: "property",\n    relevance: 0\n  };\n\n  const GETTER_OR_SETTER = {\n    match: [\n      /get|set/,\n      /\\s+/,\n      IDENT_RE$1,\n      /(?=\\()/\n    ],\n    className: {\n      1: "keyword",\n      3: "title.function"\n    },\n    contains: [\n      { // eat to avoid empty params\n        begin: /\\(\\)/\n      },\n      PARAMS\n    ]\n  };\n\n  const FUNC_LEAD_IN_RE = \'(\\\\(\' +\n    \'[^()]*(\\\\(\' +\n    \'[^()]*(\\\\(\' +\n    \'[^()]*\' +\n    \'\\\\)[^()]*)*\' +\n    \'\\\\)[^()]*)*\' +\n    \'\\\\)|\' + hljs.UNDERSCORE_IDENT_RE + \')\\\\s*=>\';\n\n  const FUNCTION_VARIABLE = {\n    match: [\n      /const|var|let/, /\\s+/,\n      IDENT_RE$1, /\\s*/,\n      /=\\s*/,\n      lookahead(FUNC_LEAD_IN_RE)\n    ],\n    className: {\n      1: "keyword",\n      3: "title.function"\n    },\n    contains: [\n      PARAMS\n    ]\n  };\n\n  return {\n    name: \'Javascript\',\n    aliases: [\'js\', \'jsx\', \'mjs\', \'cjs\'],\n    keywords: KEYWORDS$1,\n    // this will be extended by TypeScript\n    exports: { PARAMS_CONTAINS },\n    illegal: /#(?![$_A-z])/,\n    contains: [\n      hljs.SHEBANG({\n        label: "shebang",\n        binary: "node",\n        relevance: 5\n      }),\n      USE_STRICT,\n      hljs.APOS_STRING_MODE,\n      hljs.QUOTE_STRING_MODE,\n      HTML_TEMPLATE,\n      CSS_TEMPLATE,\n      TEMPLATE_STRING,\n      COMMENT,\n      NUMBER,\n      CLASS_REFERENCE,\n      {\n        className: \'attr\',\n        begin: IDENT_RE$1 + lookahead(\':\'),\n        relevance: 0\n      },\n      FUNCTION_VARIABLE,\n      { // "value" container\n        begin: \'(\' + hljs.RE_STARTERS_RE + \'|\\\\b(case|return|throw)\\\\b)\\\\s*\',\n        keywords: \'return throw case\',\n        relevance: 0,\n        contains: [\n          COMMENT,\n          hljs.REGEXP_MODE,\n          {\n            className: \'function\',\n            // we have to count the parens to make sure we actually have the\n            // correct bounding ( ) before the =>.  There could be any number of\n            // sub-expressions inside also surrounded by parens.\n            begin: FUNC_LEAD_IN_RE,\n            returnBegin: true,\n            end: \'\\\\s*=>\',\n            contains: [\n              {\n                className: \'params\',\n                variants: [\n                  {\n                    begin: hljs.UNDERSCORE_IDENT_RE,\n                    relevance: 0\n                  },\n                  {\n                    className: null,\n                    begin: /\\(\\s*\\)/,\n                    skip: true\n                  },\n                  {\n                    begin: /\\(/,\n                    end: /\\)/,\n                    excludeBegin: true,\n                    excludeEnd: true,\n                    keywords: KEYWORDS$1,\n                    contains: PARAMS_CONTAINS\n                  }\n                ]\n              }\n            ]\n          },\n          { // could be a comma delimited list of params to a function call\n            begin: /,/,\n            relevance: 0\n          },\n          {\n            match: /\\s+/,\n            relevance: 0\n          },\n          { // JSX\n            variants: [\n              { begin: FRAGMENT.begin, end: FRAGMENT.end },\n              {\n                begin: XML_TAG.begin,\n                // we carefully check the opening tag to see if it truly\n                // is a tag and not a false positive\n                \'on:begin\': XML_TAG.isTrulyOpeningTag,\n                end: XML_TAG.end\n              }\n            ],\n            subLanguage: \'xml\',\n            contains: [\n              {\n                begin: XML_TAG.begin,\n                end: XML_TAG.end,\n                skip: true,\n                contains: [\'self\']\n              }\n            ]\n          }\n        ],\n      },\n      FUNCTION_DEFINITION,\n      {\n        // prevent this from getting swallowed up by function\n        // since they appear "function like"\n        beginKeywords: "while if switch catch for"\n      },\n      {\n        // we have to count the parens to make sure we actually have the correct\n        // bounding ( ).  There could be any number of sub-expressions inside\n        // also surrounded by parens.\n        begin: \'\\\\b(?!function)\' + hljs.UNDERSCORE_IDENT_RE +\n          \'\\\\(\' + // first parens\n          \'[^()]*(\\\\(\' +\n            \'[^()]*(\\\\(\' +\n              \'[^()]*\' +\n            \'\\\\)[^()]*)*\' +\n          \'\\\\)[^()]*)*\' +\n          \'\\\\)\\\\s*\\\\{\', // end parens\n        returnBegin:true,\n        label: "func.def",\n        contains: [\n          PARAMS,\n          hljs.inherit(hljs.TITLE_MODE, { begin: IDENT_RE$1, className: "title.function" })\n        ]\n      },\n      // catch ... so it won\'t trigger the property rule below\n      {\n        match: /\\.\\.\\./,\n        relevance: 0\n      },\n      PROPERTY_ACCESS,\n      // hack: prevents detection of keywords in some circumstances\n      // .keyword()\n      // $keyword = x\n      {\n        match: \'\\\\$\' + IDENT_RE$1,\n        relevance: 0\n      },\n      {\n        match: [ /\\bconstructor(?=\\s*\\()/ ],\n        className: { 1: "title.function" },\n        contains: [ PARAMS ]\n      },\n      FUNCTION_CALL,\n      UPPER_CASE_CONSTANT,\n      CLASS_OR_EXTENDS,\n      GETTER_OR_SETTER,\n      {\n        match: /\\$[(.]/ // relevance booster for a pattern common to JS libs: `$(something)` and `$.something`\n      }\n    ]\n  };\n}\n\n/* harmony default export */ const languages_javascript = (javascript);\n\n;// CONCATENATED MODULE: ./node_modules/highlight.js/es/languages/scss.js\nconst MODES = (hljs) => {\n  return {\n    IMPORTANT: {\n      scope: \'meta\',\n      begin: \'!important\'\n    },\n    HEXCOLOR: {\n      scope: \'number\',\n      begin: \'#([a-fA-F0-9]{6}|[a-fA-F0-9]{3})\'\n    },\n    ATTRIBUTE_SELECTOR_MODE: {\n      scope: \'selector-attr\',\n      begin: /\\[/,\n      end: /\\]/,\n      illegal: \'$\',\n      contains: [\n        hljs.APOS_STRING_MODE,\n        hljs.QUOTE_STRING_MODE\n      ]\n    },\n    CSS_NUMBER_MODE: {\n      scope: \'number\',\n      begin: hljs.NUMBER_RE + \'(\' +\n        \'%|em|ex|ch|rem\' +\n        \'|vw|vh|vmin|vmax\' +\n        \'|cm|mm|in|pt|pc|px\' +\n        \'|deg|grad|rad|turn\' +\n        \'|s|ms\' +\n        \'|Hz|kHz\' +\n        \'|dpi|dpcm|dppx\' +\n        \')?\',\n      relevance: 0\n    },\n    CSS_VARIABLE: {\n      className: "attr",\n      begin: /--[A-Za-z][A-Za-z0-9_-]*/\n    }\n  };\n};\n\nconst TAGS = [\n  \'a\',\n  \'abbr\',\n  \'address\',\n  \'article\',\n  \'aside\',\n  \'audio\',\n  \'b\',\n  \'blockquote\',\n  \'body\',\n  \'button\',\n  \'canvas\',\n  \'caption\',\n  \'cite\',\n  \'code\',\n  \'dd\',\n  \'del\',\n  \'details\',\n  \'dfn\',\n  \'div\',\n  \'dl\',\n  \'dt\',\n  \'em\',\n  \'fieldset\',\n  \'figcaption\',\n  \'figure\',\n  \'footer\',\n  \'form\',\n  \'h1\',\n  \'h2\',\n  \'h3\',\n  \'h4\',\n  \'h5\',\n  \'h6\',\n  \'header\',\n  \'hgroup\',\n  \'html\',\n  \'i\',\n  \'iframe\',\n  \'img\',\n  \'input\',\n  \'ins\',\n  \'kbd\',\n  \'label\',\n  \'legend\',\n  \'li\',\n  \'main\',\n  \'mark\',\n  \'menu\',\n  \'nav\',\n  \'object\',\n  \'ol\',\n  \'p\',\n  \'q\',\n  \'quote\',\n  \'samp\',\n  \'section\',\n  \'span\',\n  \'strong\',\n  \'summary\',\n  \'sup\',\n  \'table\',\n  \'tbody\',\n  \'td\',\n  \'textarea\',\n  \'tfoot\',\n  \'th\',\n  \'thead\',\n  \'time\',\n  \'tr\',\n  \'ul\',\n  \'var\',\n  \'video\'\n];\n\nconst MEDIA_FEATURES = [\n  \'any-hover\',\n  \'any-pointer\',\n  \'aspect-ratio\',\n  \'color\',\n  \'color-gamut\',\n  \'color-index\',\n  \'device-aspect-ratio\',\n  \'device-height\',\n  \'device-width\',\n  \'display-mode\',\n  \'forced-colors\',\n  \'grid\',\n  \'height\',\n  \'hover\',\n  \'inverted-colors\',\n  \'monochrome\',\n  \'orientation\',\n  \'overflow-block\',\n  \'overflow-inline\',\n  \'pointer\',\n  \'prefers-color-scheme\',\n  \'prefers-contrast\',\n  \'prefers-reduced-motion\',\n  \'prefers-reduced-transparency\',\n  \'resolution\',\n  \'scan\',\n  \'scripting\',\n  \'update\',\n  \'width\',\n  // TODO: find a better solution?\n  \'min-width\',\n  \'max-width\',\n  \'min-height\',\n  \'max-height\'\n];\n\n// https://developer.mozilla.org/en-US/docs/Web/CSS/Pseudo-classes\nconst PSEUDO_CLASSES = [\n  \'active\',\n  \'any-link\',\n  \'blank\',\n  \'checked\',\n  \'current\',\n  \'default\',\n  \'defined\',\n  \'dir\', // dir()\n  \'disabled\',\n  \'drop\',\n  \'empty\',\n  \'enabled\',\n  \'first\',\n  \'first-child\',\n  \'first-of-type\',\n  \'fullscreen\',\n  \'future\',\n  \'focus\',\n  \'focus-visible\',\n  \'focus-within\',\n  \'has\', // has()\n  \'host\', // host or host()\n  \'host-context\', // host-context()\n  \'hover\',\n  \'indeterminate\',\n  \'in-range\',\n  \'invalid\',\n  \'is\', // is()\n  \'lang\', // lang()\n  \'last-child\',\n  \'last-of-type\',\n  \'left\',\n  \'link\',\n  \'local-link\',\n  \'not\', // not()\n  \'nth-child\', // nth-child()\n  \'nth-col\', // nth-col()\n  \'nth-last-child\', // nth-last-child()\n  \'nth-last-col\', // nth-last-col()\n  \'nth-last-of-type\', //nth-last-of-type()\n  \'nth-of-type\', //nth-of-type()\n  \'only-child\',\n  \'only-of-type\',\n  \'optional\',\n  \'out-of-range\',\n  \'past\',\n  \'placeholder-shown\',\n  \'read-only\',\n  \'read-write\',\n  \'required\',\n  \'right\',\n  \'root\',\n  \'scope\',\n  \'target\',\n  \'target-within\',\n  \'user-invalid\',\n  \'valid\',\n  \'visited\',\n  \'where\' // where()\n];\n\n// https://developer.mozilla.org/en-US/docs/Web/CSS/Pseudo-elements\nconst PSEUDO_ELEMENTS = [\n  \'after\',\n  \'backdrop\',\n  \'before\',\n  \'cue\',\n  \'cue-region\',\n  \'first-letter\',\n  \'first-line\',\n  \'grammar-error\',\n  \'marker\',\n  \'part\',\n  \'placeholder\',\n  \'selection\',\n  \'slotted\',\n  \'spelling-error\'\n];\n\nconst ATTRIBUTES = [\n  \'align-content\',\n  \'align-items\',\n  \'align-self\',\n  \'animation\',\n  \'animation-delay\',\n  \'animation-direction\',\n  \'animation-duration\',\n  \'animation-fill-mode\',\n  \'animation-iteration-count\',\n  \'animation-name\',\n  \'animation-play-state\',\n  \'animation-timing-function\',\n  \'auto\',\n  \'backface-visibility\',\n  \'background\',\n  \'background-attachment\',\n  \'background-clip\',\n  \'background-color\',\n  \'background-image\',\n  \'background-origin\',\n  \'background-position\',\n  \'background-repeat\',\n  \'background-size\',\n  \'border\',\n  \'border-bottom\',\n  \'border-bottom-color\',\n  \'border-bottom-left-radius\',\n  \'border-bottom-right-radius\',\n  \'border-bottom-style\',\n  \'border-bottom-width\',\n  \'border-collapse\',\n  \'border-color\',\n  \'border-image\',\n  \'border-image-outset\',\n  \'border-image-repeat\',\n  \'border-image-slice\',\n  \'border-image-source\',\n  \'border-image-width\',\n  \'border-left\',\n  \'border-left-color\',\n  \'border-left-style\',\n  \'border-left-width\',\n  \'border-radius\',\n  \'border-right\',\n  \'border-right-color\',\n  \'border-right-style\',\n  \'border-right-width\',\n  \'border-spacing\',\n  \'border-style\',\n  \'border-top\',\n  \'border-top-color\',\n  \'border-top-left-radius\',\n  \'border-top-right-radius\',\n  \'border-top-style\',\n  \'border-top-width\',\n  \'border-width\',\n  \'bottom\',\n  \'box-decoration-break\',\n  \'box-shadow\',\n  \'box-sizing\',\n  \'break-after\',\n  \'break-before\',\n  \'break-inside\',\n  \'caption-side\',\n  \'clear\',\n  \'clip\',\n  \'clip-path\',\n  \'color\',\n  \'column-count\',\n  \'column-fill\',\n  \'column-gap\',\n  \'column-rule\',\n  \'column-rule-color\',\n  \'column-rule-style\',\n  \'column-rule-width\',\n  \'column-span\',\n  \'column-width\',\n  \'columns\',\n  \'content\',\n  \'counter-increment\',\n  \'counter-reset\',\n  \'cursor\',\n  \'direction\',\n  \'display\',\n  \'empty-cells\',\n  \'filter\',\n  \'flex\',\n  \'flex-basis\',\n  \'flex-direction\',\n  \'flex-flow\',\n  \'flex-grow\',\n  \'flex-shrink\',\n  \'flex-wrap\',\n  \'float\',\n  \'font\',\n  \'font-display\',\n  \'font-family\',\n  \'font-feature-settings\',\n  \'font-kerning\',\n  \'font-language-override\',\n  \'font-size\',\n  \'font-size-adjust\',\n  \'font-smoothing\',\n  \'font-stretch\',\n  \'font-style\',\n  \'font-variant\',\n  \'font-variant-ligatures\',\n  \'font-variation-settings\',\n  \'font-weight\',\n  \'height\',\n  \'hyphens\',\n  \'icon\',\n  \'image-orientation\',\n  \'image-rendering\',\n  \'image-resolution\',\n  \'ime-mode\',\n  \'inherit\',\n  \'initial\',\n  \'justify-content\',\n  \'left\',\n  \'letter-spacing\',\n  \'line-height\',\n  \'list-style\',\n  \'list-style-image\',\n  \'list-style-position\',\n  \'list-style-type\',\n  \'margin\',\n  \'margin-bottom\',\n  \'margin-left\',\n  \'margin-right\',\n  \'margin-top\',\n  \'marks\',\n  \'mask\',\n  \'max-height\',\n  \'max-width\',\n  \'min-height\',\n  \'min-width\',\n  \'nav-down\',\n  \'nav-index\',\n  \'nav-left\',\n  \'nav-right\',\n  \'nav-up\',\n  \'none\',\n  \'normal\',\n  \'object-fit\',\n  \'object-position\',\n  \'opacity\',\n  \'order\',\n  \'orphans\',\n  \'outline\',\n  \'outline-color\',\n  \'outline-offset\',\n  \'outline-style\',\n  \'outline-width\',\n  \'overflow\',\n  \'overflow-wrap\',\n  \'overflow-x\',\n  \'overflow-y\',\n  \'padding\',\n  \'padding-bottom\',\n  \'padding-left\',\n  \'padding-right\',\n  \'padding-top\',\n  \'page-break-after\',\n  \'page-break-before\',\n  \'page-break-inside\',\n  \'perspective\',\n  \'perspective-origin\',\n  \'pointer-events\',\n  \'position\',\n  \'quotes\',\n  \'resize\',\n  \'right\',\n  \'src\', // @font-face\n  \'tab-size\',\n  \'table-layout\',\n  \'text-align\',\n  \'text-align-last\',\n  \'text-decoration\',\n  \'text-decoration-color\',\n  \'text-decoration-line\',\n  \'text-decoration-style\',\n  \'text-indent\',\n  \'text-overflow\',\n  \'text-rendering\',\n  \'text-shadow\',\n  \'text-transform\',\n  \'text-underline-position\',\n  \'top\',\n  \'transform\',\n  \'transform-origin\',\n  \'transform-style\',\n  \'transition\',\n  \'transition-delay\',\n  \'transition-duration\',\n  \'transition-property\',\n  \'transition-timing-function\',\n  \'unicode-bidi\',\n  \'vertical-align\',\n  \'visibility\',\n  \'white-space\',\n  \'widows\',\n  \'width\',\n  \'word-break\',\n  \'word-spacing\',\n  \'word-wrap\',\n  \'z-index\'\n  // reverse makes sure longer attributes `font-weight` are matched fully\n  // instead of getting false positives on say `font`\n].reverse();\n\n/*\nLanguage: SCSS\nDescription: Scss is an extension of the syntax of CSS.\nAuthor: Kurt Emch <kurt@kurtemch.com>\nWebsite: https://sass-lang.com\nCategory: common, css, web\n*/\n\n/** @type LanguageFn */\nfunction scss(hljs) {\n  const modes = MODES(hljs);\n  const PSEUDO_ELEMENTS$1 = PSEUDO_ELEMENTS;\n  const PSEUDO_CLASSES$1 = PSEUDO_CLASSES;\n\n  const AT_IDENTIFIER = \'@[a-z-]+\'; // @font-face\n  const AT_MODIFIERS = "and or not only";\n  const IDENT_RE = \'[a-zA-Z-][a-zA-Z0-9_-]*\';\n  const VARIABLE = {\n    className: \'variable\',\n    begin: \'(\\\\$\' + IDENT_RE + \')\\\\b\'\n  };\n\n  return {\n    name: \'SCSS\',\n    case_insensitive: true,\n    illegal: \'[=/|\\\']\',\n    contains: [\n      hljs.C_LINE_COMMENT_MODE,\n      hljs.C_BLOCK_COMMENT_MODE,\n      {\n        className: \'selector-id\',\n        begin: \'#[A-Za-z0-9_-]+\',\n        relevance: 0\n      },\n      {\n        className: \'selector-class\',\n        begin: \'\\\\.[A-Za-z0-9_-]+\',\n        relevance: 0\n      },\n      modes.ATTRIBUTE_SELECTOR_MODE,\n      {\n        className: \'selector-tag\',\n        begin: \'\\\\b(\' + TAGS.join(\'|\') + \')\\\\b\',\n        // was there, before, but why?\n        relevance: 0\n      },\n      {\n        className: \'selector-pseudo\',\n        begin: \':(\' + PSEUDO_CLASSES$1.join(\'|\') + \')\'\n      },\n      {\n        className: \'selector-pseudo\',\n        begin: \'::(\' + PSEUDO_ELEMENTS$1.join(\'|\') + \')\'\n      },\n      VARIABLE,\n      { // pseudo-selector params\n        begin: /\\(/,\n        end: /\\)/,\n        contains: [ modes.CSS_NUMBER_MODE ]\n      },\n      modes.CSS_VARIABLE,\n      {\n        className: \'attribute\',\n        begin: \'\\\\b(\' + ATTRIBUTES.join(\'|\') + \')\\\\b\'\n      },\n      {\n        begin: \'\\\\b(whitespace|wait|w-resize|visible|vertical-text|vertical-ideographic|uppercase|upper-roman|upper-alpha|underline|transparent|top|thin|thick|text|text-top|text-bottom|tb-rl|table-header-group|table-footer-group|sw-resize|super|strict|static|square|solid|small-caps|separate|se-resize|scroll|s-resize|rtl|row-resize|ridge|right|repeat|repeat-y|repeat-x|relative|progress|pointer|overline|outside|outset|oblique|nowrap|not-allowed|normal|none|nw-resize|no-repeat|no-drop|newspaper|ne-resize|n-resize|move|middle|medium|ltr|lr-tb|lowercase|lower-roman|lower-alpha|loose|list-item|line|line-through|line-edge|lighter|left|keep-all|justify|italic|inter-word|inter-ideograph|inside|inset|inline|inline-block|inherit|inactive|ideograph-space|ideograph-parenthesis|ideograph-numeric|ideograph-alpha|horizontal|hidden|help|hand|groove|fixed|ellipsis|e-resize|double|dotted|distribute|distribute-space|distribute-letter|distribute-all-lines|disc|disabled|default|decimal|dashed|crosshair|collapse|col-resize|circle|char|center|capitalize|break-word|break-all|bottom|both|bolder|bold|block|bidi-override|below|baseline|auto|always|all-scroll|absolute|table|table-cell)\\\\b\'\n      },\n      {\n        begin: \':\',\n        end: \';\',\n        contains: [\n          VARIABLE,\n          modes.HEXCOLOR,\n          modes.CSS_NUMBER_MODE,\n          hljs.QUOTE_STRING_MODE,\n          hljs.APOS_STRING_MODE,\n          modes.IMPORTANT\n        ]\n      },\n      // matching these here allows us to treat them more like regular CSS\n      // rules so everything between the {} gets regular rule highlighting,\n      // which is what we want for page and font-face\n      {\n        begin: \'@(page|font-face)\',\n        keywords: {\n          $pattern: AT_IDENTIFIER,\n          keyword: \'@page @font-face\'\n        }\n      },\n      {\n        begin: \'@\',\n        end: \'[{;]\',\n        returnBegin: true,\n        keywords: {\n          $pattern: /[a-z-]+/,\n          keyword: AT_MODIFIERS,\n          attribute: MEDIA_FEATURES.join(" ")\n        },\n        contains: [\n          {\n            begin: AT_IDENTIFIER,\n            className: "keyword"\n          },\n          {\n            begin: /[a-z-]+(?=:)/,\n            className: "attribute"\n          },\n          VARIABLE,\n          hljs.QUOTE_STRING_MODE,\n          hljs.APOS_STRING_MODE,\n          modes.HEXCOLOR,\n          modes.CSS_NUMBER_MODE\n        ]\n      }\n    ]\n  };\n}\n\n/* harmony default export */ const languages_scss = (scss);\n\n;// CONCATENATED MODULE: ./node_modules/highlight.js/es/languages/shell.js\n/*\nLanguage: Shell Session\nRequires: bash.js\nAuthor: TSUYUSATO Kitsune <make.just.on@gmail.com>\nCategory: common\nAudit: 2020\n*/\n\n/** @type LanguageFn */\nfunction shell(hljs) {\n  return {\n    name: \'Shell Session\',\n    aliases: [ \'console\', \'shellsession\' ],\n    contains: [\n      {\n        className: \'meta\',\n        // We cannot add \\s (spaces) in the regular expression otherwise it will be too broad and produce unexpected result.\n        // For instance, in the following example, it would match "echo /path/to/home >" as a prompt:\n        // echo /path/to/home > t.exe\n        begin: /^\\s{0,3}[/~\\w\\d[\\]()@-]*[>%$#][ ]?/,\n        starts: {\n          end: /[^\\\\](?=\\s*$)/,\n          subLanguage: \'bash\'\n        }\n      }\n    ]\n  };\n}\n\n/* harmony default export */ const languages_shell = (shell);\n\n;// CONCATENATED MODULE: ./node_modules/highlight.js/es/languages/plaintext.js\n/*\nLanguage: Plain text\nAuthor: Egor Rogov (e.rogov@postgrespro.ru)\nDescription: Plain text without any highlighting.\nCategory: common\n*/\n\nfunction plaintext(hljs) {\n  return {\n    name: \'Plain text\',\n    aliases: [\n      \'text\',\n      \'txt\'\n    ],\n    disableAutodetect: true\n  };\n}\n\n/* harmony default export */ const languages_plaintext = (plaintext);\n\n;// CONCATENATED MODULE: ./node_modules/highlight.js/es/languages/xml.js\n/**\n * @param {string} value\n * @returns {RegExp}\n * */\n\n/**\n * @param {RegExp | string } re\n * @returns {string}\n */\nfunction xml_source(re) {\n  if (!re) return null;\n  if (typeof re === "string") return re;\n\n  return re.source;\n}\n\n/**\n * @param {RegExp | string } re\n * @returns {string}\n */\nfunction xml_lookahead(re) {\n  return xml_concat(\'(?=\', re, \')\');\n}\n\n/**\n * @param {RegExp | string } re\n * @returns {string}\n */\nfunction optional(re) {\n  return xml_concat(\'(?:\', re, \')?\');\n}\n\n/**\n * @param {...(RegExp | string) } args\n * @returns {string}\n */\nfunction xml_concat(...args) {\n  const joined = args.map((x) => xml_source(x)).join("");\n  return joined;\n}\n\nfunction stripOptionsFromArgs(args) {\n  const opts = args[args.length - 1];\n\n  if (typeof opts === \'object\' && opts.constructor === Object) {\n    args.splice(args.length - 1, 1);\n    return opts;\n  } else {\n    return {};\n  }\n}\n\n/**\n * Any of the passed expresssions may match\n *\n * Creates a huge this | this | that | that match\n * @param {(RegExp | string)[] } args\n * @returns {string}\n */\nfunction either(...args) {\n  const opts = stripOptionsFromArgs(args);\n  const joined = \'(\' +\n    (opts.capture ? "" : "?:") +\n    args.map((x) => xml_source(x)).join("|") + ")";\n  return joined;\n}\n\n/*\nLanguage: HTML, XML\nWebsite: https://www.w3.org/XML/\nCategory: common, web\nAudit: 2020\n*/\n\n/** @type LanguageFn */\nfunction xml(hljs) {\n  // Element names can contain letters, digits, hyphens, underscores, and periods\n  const TAG_NAME_RE = xml_concat(/[A-Z_]/, optional(/[A-Z0-9_.-]*:/), /[A-Z0-9_.-]*/);\n  const XML_IDENT_RE = /[A-Za-z0-9._:-]+/;\n  const XML_ENTITIES = {\n    className: \'symbol\',\n    begin: /&[a-z]+;|&#[0-9]+;|&#x[a-f0-9]+;/\n  };\n  const XML_META_KEYWORDS = {\n    begin: /\\s/,\n    contains: [\n      {\n        className: \'keyword\',\n        begin: /#?[a-z_][a-z1-9_-]+/,\n        illegal: /\\n/\n      }\n    ]\n  };\n  const XML_META_PAR_KEYWORDS = hljs.inherit(XML_META_KEYWORDS, {\n    begin: /\\(/,\n    end: /\\)/\n  });\n  const APOS_META_STRING_MODE = hljs.inherit(hljs.APOS_STRING_MODE, {\n    className: \'string\'\n  });\n  const QUOTE_META_STRING_MODE = hljs.inherit(hljs.QUOTE_STRING_MODE, {\n    className: \'string\'\n  });\n  const TAG_INTERNALS = {\n    endsWithParent: true,\n    illegal: /</,\n    relevance: 0,\n    contains: [\n      {\n        className: \'attr\',\n        begin: XML_IDENT_RE,\n        relevance: 0\n      },\n      {\n        begin: /=\\s*/,\n        relevance: 0,\n        contains: [\n          {\n            className: \'string\',\n            endsParent: true,\n            variants: [\n              {\n                begin: /"/,\n                end: /"/,\n                contains: [ XML_ENTITIES ]\n              },\n              {\n                begin: /\'/,\n                end: /\'/,\n                contains: [ XML_ENTITIES ]\n              },\n              {\n                begin: /[^\\s"\'=<>`]+/\n              }\n            ]\n          }\n        ]\n      }\n    ]\n  };\n  return {\n    name: \'HTML, XML\',\n    aliases: [\n      \'html\',\n      \'xhtml\',\n      \'rss\',\n      \'atom\',\n      \'xjb\',\n      \'xsd\',\n      \'xsl\',\n      \'plist\',\n      \'wsf\',\n      \'svg\'\n    ],\n    case_insensitive: true,\n    contains: [\n      {\n        className: \'meta\',\n        begin: /<![a-z]/,\n        end: />/,\n        relevance: 10,\n        contains: [\n          XML_META_KEYWORDS,\n          QUOTE_META_STRING_MODE,\n          APOS_META_STRING_MODE,\n          XML_META_PAR_KEYWORDS,\n          {\n            begin: /\\[/,\n            end: /\\]/,\n            contains: [\n              {\n                className: \'meta\',\n                begin: /<![a-z]/,\n                end: />/,\n                contains: [\n                  XML_META_KEYWORDS,\n                  XML_META_PAR_KEYWORDS,\n                  QUOTE_META_STRING_MODE,\n                  APOS_META_STRING_MODE\n                ]\n              }\n            ]\n          }\n        ]\n      },\n      hljs.COMMENT(\n        /\x3c!--/,\n        /--\x3e/,\n        {\n          relevance: 10\n        }\n      ),\n      {\n        begin: /<!\\[CDATA\\[/,\n        end: /\\]\\]>/,\n        relevance: 10\n      },\n      XML_ENTITIES,\n      {\n        className: \'meta\',\n        begin: /<\\?xml/,\n        end: /\\?>/,\n        relevance: 10\n      },\n      {\n        className: \'tag\',\n        /*\n        The lookahead pattern (?=...) ensures that \'begin\' only matches\n        \'<style\' as a single word, followed by a whitespace or an\n        ending bracket.\n        */\n        begin: /<style(?=\\s|>)/,\n        end: />/,\n        keywords: {\n          name: \'style\'\n        },\n        contains: [ TAG_INTERNALS ],\n        starts: {\n          end: /<\\/style>/,\n          returnEnd: true,\n          subLanguage: [\n            \'css\',\n            \'xml\'\n          ]\n        }\n      },\n      {\n        className: \'tag\',\n        // See the comment in the <style tag about the lookahead pattern\n        begin: /<script(?=\\s|>)/,\n        end: />/,\n        keywords: {\n          name: \'script\'\n        },\n        contains: [ TAG_INTERNALS ],\n        starts: {\n          end: /<\\/script>/,\n          returnEnd: true,\n          subLanguage: [\n            \'javascript\',\n            \'handlebars\',\n            \'xml\'\n          ]\n        }\n      },\n      // we need this for now for jSX\n      {\n        className: \'tag\',\n        begin: /<>|<\\/>/\n      },\n      // open tag\n      {\n        className: \'tag\',\n        begin: xml_concat(\n          /</,\n          xml_lookahead(xml_concat(\n            TAG_NAME_RE,\n            // <tag/>\n            // <tag>\n            // <tag ...\n            either(/\\/>/, />/, /\\s/)\n          ))\n        ),\n        end: /\\/?>/,\n        contains: [\n          {\n            className: \'name\',\n            begin: TAG_NAME_RE,\n            relevance: 0,\n            starts: TAG_INTERNALS\n          }\n        ]\n      },\n      // close tag\n      {\n        className: \'tag\',\n        begin: xml_concat(\n          /<\\//,\n          xml_lookahead(xml_concat(\n            TAG_NAME_RE, />/\n          ))\n        ),\n        contains: [\n          {\n            className: \'name\',\n            begin: TAG_NAME_RE,\n            relevance: 0\n          },\n          {\n            begin: />/,\n            relevance: 0,\n            endsParent: true\n          }\n        ]\n      }\n    ]\n  };\n}\n\n/* harmony default export */ const languages_xml = (xml);\n\n;// CONCATENATED MODULE: ./docs/src/utils/highlight.js\n\n\n\n\n\n\nes_core.registerLanguage(\'javascript\', languages_javascript);\nes_core.registerLanguage(\'scss\', languages_scss);\nes_core.registerLanguage(\'shell\', languages_shell);\nes_core.registerLanguage(\'plaintext\', languages_plaintext);\nes_core.registerLanguage(\'xml\', languages_xml);\nfunction highlight(code, lang) {\n  var language = es_core.getLanguage(lang) ? lang : \'plaintext\';\n  return es_core.highlight(code, {\n    language: language\n  }).value;\n}\n;// CONCATENATED MODULE: ./docs/src/components/Code/index.jsx\n\n\n\n\nfunction Code(_ref) {\n  var lang = _ref.lang,\n      children = _ref.children;\n  var html = jsxToHtml(children);\n  return /*#__PURE__*/(0,jsx_runtime.jsx)("div", {\n    className: "code",\n    children: /*#__PURE__*/(0,jsx_runtime.jsx)("pre", {\n      className: "hljs language-".concat(lang),\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)("code", {\n        dangerouslySetInnerHTML: {\n          __html: highlight(html, \'jsx\')\n        }\n      })\n    })\n  });\n}\n;// CONCATENATED MODULE: ./docs/src/components/Demo/index.jsx\nvar Demo_excluded = ["title", "description", "setup", "settings", "code", "children"];\n\nfunction Demo_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction Demo_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { Demo_ownKeys(Object(source), true).forEach(function (key) { Demo_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { Demo_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction Demo_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction Demo_slicedToArray(arr, i) { return Demo_arrayWithHoles(arr) || Demo_iterableToArrayLimit(arr, i) || Demo_unsupportedIterableToArray(arr, i) || Demo_nonIterableRest(); }\n\nfunction Demo_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction Demo_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return Demo_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return Demo_arrayLikeToArray(o, minLen); }\n\nfunction Demo_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction Demo_iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction Demo_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction Demo_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = Demo_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction Demo_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\n\n\n\nfunction Demo(_ref) {\n  var _ref$title = _ref.title,\n      title = _ref$title === void 0 ? \'Demo\' : _ref$title,\n      description = _ref.description,\n      setup = _ref.setup,\n      settings = _ref.settings,\n      code = _ref.code,\n      _ref$children = _ref.children,\n      children = _ref$children === void 0 ? code : _ref$children,\n      props = Demo_objectWithoutProperties(_ref, Demo_excluded);\n\n  var _useState = (0,react.useState)(false),\n      _useState2 = Demo_slicedToArray(_useState, 2),\n      isCodeOpen = _useState2[0],\n      setCodeOpen = _useState2[1];\n\n  var _useState3 = (0,react.useState)(false),\n      _useState4 = Demo_slicedToArray(_useState3, 2),\n      isSettingsOpen = _useState4[0],\n      setSettingsOpen = _useState4[1];\n\n  var classNames = classnames_default()(\'demo\', {\n    \'demo--with-settings\': settings\n  });\n  return /*#__PURE__*/(0,jsx_runtime.jsxs)(card_Card, Demo_objectSpread(Demo_objectSpread({\n    element: "article",\n    className: classNames,\n    outlined: true\n  }, props), {}, {\n    children: [/*#__PURE__*/(0,jsx_runtime.jsx)(card_Card.Header, {\n      title: title,\n      actions: [/*#__PURE__*/(0,jsx_runtime.jsx)(icon_button_IconButton, {\n        icon: isCodeOpen ? \'code_off\' : \'code\',\n        title: isCodeOpen ? \'Hide code\' : \'Show code\',\n        onClick: function onClick() {\n          return setCodeOpen(function (v) {\n            return !v;\n          });\n        }\n      }, "code"), settings ? /*#__PURE__*/(0,jsx_runtime.jsx)(icon_button_IconButton, {\n        icon: "settings",\n        title: "\\u041D\\u0430\\u0441\\u0442\\u0440\\u043E\\u0439\\u043A\\u0438",\n        onClick: function onClick() {\n          return setSettingsOpen(true);\n        }\n      }, "settings") : null]\n    }), description && /*#__PURE__*/(0,jsx_runtime.jsx)(card_Card.Section, {\n      secondary: true,\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(typography_Typography, {\n        noMargin: true,\n        children: description\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsxs)(card_Card.Section, {\n      primary: true,\n      children: [setup, children]\n    }), isCodeOpen && /*#__PURE__*/(0,jsx_runtime.jsx)(card_Card.Section, {\n      secondary: true,\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(Code, {\n        lang: "jsx",\n        children: children\n      })\n    }), settings && /*#__PURE__*/(0,jsx_runtime.jsx)(side_sheet_SideSheet, {\n      title: "Settings",\n      open: isSettingsOpen // appear\n      ,\n      closeIcon: "close",\n      onClose: function onClose() {\n        return setSettingsOpen(false);\n      },\n      dismissible: true,\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(side_sheet_SideSheet.Content, {\n        children: settings\n      })\n    })]\n  }));\n}\n;// CONCATENATED MODULE: ./docs/src/components/FieldSet/index.jsx\n\n\n\nfunction FieldSet(_ref) {\n  var legend = _ref.legend,\n      children = _ref.children;\n  return /*#__PURE__*/(0,jsx_runtime.jsxs)("fieldset", {\n    children: [/*#__PURE__*/(0,jsx_runtime.jsx)("legend", {\n      children: legend\n    }), children]\n  });\n}\n;// CONCATENATED MODULE: ./docs/src/components/Page/index.jsx\nvar Page_excluded = ["id", "title", "description", "links", "children"];\n\nfunction Page_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction Page_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { Page_ownKeys(Object(source), true).forEach(function (key) { Page_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { Page_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction Page_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction Page_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = Page_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction Page_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\nfunction Page(_ref) {\n  var id = _ref.id,\n      title = _ref.title,\n      description = _ref.description,\n      links = _ref.links,\n      children = _ref.children,\n      props = Page_objectWithoutProperties(_ref, Page_excluded);\n\n  return /*#__PURE__*/(0,jsx_runtime.jsxs)("article", Page_objectSpread(Page_objectSpread({\n    id: "".concat(id, "-page"),\n    className: "page"\n  }, props), {}, {\n    children: [title && /*#__PURE__*/(0,jsx_runtime.jsxs)("header", {\n      className: "page-header",\n      children: [/*#__PURE__*/(0,jsx_runtime.jsx)(typography_Typography, {\n        className: "page-title",\n        type: "headline4",\n        noMargin: true,\n        children: title\n      }), description && /*#__PURE__*/(0,jsx_runtime.jsx)(typography_Typography, {\n        className: "page-description",\n        type: "body1",\n        noMargin: true,\n        children: description\n      }), links && /*#__PURE__*/(0,jsx_runtime.jsxs)("ul", {\n        children: [links.guide && /*#__PURE__*/(0,jsx_runtime.jsx)("li", {\n          children: /*#__PURE__*/(0,jsx_runtime.jsx)("a", {\n            href: links.guide,\n            target: "_blank",\n            rel: "noreferrer",\n            children: "Guide"\n          })\n        }), links.docs && /*#__PURE__*/(0,jsx_runtime.jsx)("li", {\n          children: /*#__PURE__*/(0,jsx_runtime.jsx)("a", {\n            href: links.docs,\n            target: "_blank",\n            rel: "noreferrer",\n            children: "Docs"\n          })\n        })]\n      })]\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)("div", {\n      className: "page-content",\n      children: children\n    })]\n  }));\n}\n;// CONCATENATED MODULE: ./docs/src/pages/Avatar/index.jsx\nfunction Avatar_slicedToArray(arr, i) { return Avatar_arrayWithHoles(arr) || Avatar_iterableToArrayLimit(arr, i) || Avatar_unsupportedIterableToArray(arr, i) || Avatar_nonIterableRest(); }\n\nfunction Avatar_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction Avatar_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return Avatar_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return Avatar_arrayLikeToArray(o, minLen); }\n\nfunction Avatar_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction Avatar_iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction Avatar_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\n\n\n\n\n\n\n\n\nvar id = \'avatar\';\nvar title = \'Avatar\';\nvar description = \'Avatars are found throughout material design with uses in everything from tables to dialog menus.\';\nfunction AvatarPage() {\n  var _useState = (0,react.useState)(\'medium\'),\n      _useState2 = Avatar_slicedToArray(_useState, 2),\n      size = _useState2[0],\n      setSize = _useState2[1];\n\n  var _useState3 = (0,react.useState)(\'image\'),\n      _useState4 = Avatar_slicedToArray(_useState3, 2),\n      content = _useState4[0],\n      setContent = _useState4[1];\n\n  return /*#__PURE__*/(0,jsx_runtime.jsx)(Page, {\n    id: id,\n    title: title,\n    description: description,\n    children: /*#__PURE__*/(0,jsx_runtime.jsx)(Demo, {\n      title: "Demo",\n      settings: /*#__PURE__*/(0,jsx_runtime.jsxs)(jsx_runtime.Fragment, {\n        children: [/*#__PURE__*/(0,jsx_runtime.jsx)(FieldSet, {\n          legend: "Content",\n          children: /*#__PURE__*/(0,jsx_runtime.jsx)(segmented_button_SegmentedButton, {\n            segments: [{\n              value: \'image\',\n              label: \'Image\'\n            }, {\n              value: \'icon\',\n              label: \'Icon\'\n            }, {\n              value: \'text\',\n              label: \'Text\'\n            }],\n            value: content,\n            onChange: setContent\n          })\n        }), /*#__PURE__*/(0,jsx_runtime.jsx)(FieldSet, {\n          legend: "Size",\n          children: /*#__PURE__*/(0,jsx_runtime.jsx)(segmented_button_SegmentedButton, {\n            segments: [{\n              value: \'small\',\n              label: \'Small\'\n            }, {\n              value: \'medium\',\n              label: \'Medium\'\n            }, {\n              value: \'large\',\n              label: \'Large\'\n            }],\n            value: size,\n            onChange: setSize\n          })\n        })]\n      }),\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(avatar_Avatar, {\n        image: content === \'image\' ? \'https://placeimg.com/128/128/people\' : undefined,\n        icon: content === \'icon\' ? \'star\' : undefined,\n        text: content === \'text\' ? \'MD\' : undefined,\n        size: size\n      })\n    })\n  });\n}\n;// CONCATENATED MODULE: ./docs/src/pages/Badge/index.jsx\nfunction Badge_slicedToArray(arr, i) { return Badge_arrayWithHoles(arr) || Badge_iterableToArrayLimit(arr, i) || Badge_unsupportedIterableToArray(arr, i) || Badge_nonIterableRest(); }\n\nfunction Badge_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction Badge_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return Badge_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return Badge_arrayLikeToArray(o, minLen); }\n\nfunction Badge_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction Badge_iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction Badge_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\n\n\n\n\n\n\nvar Badge_id = \'badge\';\nvar Badge_title = \'Badge\';\nvar Badge_description = \'Badge generates a small badge to the top-right of its child(ren).\';\nvar content = {\n  avatar: /*#__PURE__*/(0,jsx_runtime.jsx)(avatar_Avatar, {\n    text: "MD",\n    size: "medium"\n  }),\n  button: /*#__PURE__*/(0,jsx_runtime.jsx)(button_Button, {\n    outlined: true,\n    children: "Button"\n  }),\n  icon: /*#__PURE__*/(0,jsx_runtime.jsx)(icon_Icon, {\n    children: "star"\n  }),\n  iconButton: /*#__PURE__*/(0,jsx_runtime.jsx)(icon_button_IconButton, {\n    icon: "star"\n  }),\n  text: \'Text\'\n};\nfunction BadgePage() {\n  var _useState = (0,react.useState)(0),\n      _useState2 = Badge_slicedToArray(_useState, 2),\n      value = _useState2[0],\n      setValue = _useState2[1];\n\n  var _useState3 = (0,react.useState)(\'avatar\'),\n      _useState4 = Badge_slicedToArray(_useState3, 2),\n      type = _useState4[0],\n      setType = _useState4[1];\n\n  var _useState5 = (0,react.useState)(false),\n      _useState6 = Badge_slicedToArray(_useState5, 2),\n      inset = _useState6[0],\n      setInset = _useState6[1];\n\n  var _useState7 = (0,react.useState)(false),\n      _useState8 = Badge_slicedToArray(_useState7, 2),\n      transparent = _useState8[0],\n      setTransparent = _useState8[1];\n\n  return /*#__PURE__*/(0,jsx_runtime.jsx)(Page, {\n    id: Badge_id,\n    title: Badge_title,\n    description: Badge_description,\n    children: /*#__PURE__*/(0,jsx_runtime.jsx)(Demo, {\n      settings: [/*#__PURE__*/(0,jsx_runtime.jsx)(text_field_TextField, {\n        value: value,\n        label: "Value",\n        outlined: true,\n        onChange: function onChange(_, value) {\n          return setValue(value);\n        }\n      }, "value"), /*#__PURE__*/(0,jsx_runtime.jsx)(FieldSet, {\n        legend: "Content",\n        children: /*#__PURE__*/(0,jsx_runtime.jsx)(segmented_button_SegmentedButton, {\n          segments: [{\n            value: \'avatar\',\n            label: \'Avatar\'\n          }, {\n            value: \'button\',\n            label: \'Button\'\n          }, {\n            value: \'icon\',\n            label: \'Icon\'\n          }, {\n            value: \'iconButton\',\n            label: \'Icon Button\'\n          }, {\n            value: \'text\',\n            label: \'Text\'\n          }],\n          value: type,\n          onChange: setType\n        })\n      }, "content"), /*#__PURE__*/(0,jsx_runtime.jsx)(form_field_FormField, {\n        label: "Inset",\n        alignEnd: true,\n        spaceBetween: true,\n        children: /*#__PURE__*/(0,jsx_runtime.jsx)(switch_Switch, {\n          selected: inset,\n          onChange: function onChange() {\n            return setInset(function (v) {\n              return !v;\n            });\n          }\n        })\n      }, "inset"), /*#__PURE__*/(0,jsx_runtime.jsx)(form_field_FormField, {\n        label: "Transparent",\n        alignEnd: true,\n        spaceBetween: true,\n        children: /*#__PURE__*/(0,jsx_runtime.jsx)(switch_Switch, {\n          selected: transparent,\n          onChange: function onChange() {\n            return setTransparent(function (v) {\n              return !v;\n            });\n          }\n        })\n      }, "transparent")],\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(badge_Badge, {\n        value: value,\n        inset: inset || undefined,\n        transparent: transparent || undefined,\n        children: content[type]\n      })\n    })\n  });\n}\n;// CONCATENATED MODULE: ./docs/src/pages/Banner/index.jsx\nfunction Banner_slicedToArray(arr, i) { return Banner_arrayWithHoles(arr) || Banner_iterableToArrayLimit(arr, i) || Banner_unsupportedIterableToArray(arr, i) || Banner_nonIterableRest(); }\n\nfunction Banner_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction Banner_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return Banner_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return Banner_arrayLikeToArray(o, minLen); }\n\nfunction Banner_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction Banner_iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction Banner_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\n\n\n\n\n\n\n\n\nvar Banner_id = \'banner\';\nvar Banner_title = \'Banner\';\nvar Banner_description = \'A banner displays a prominent message and related optional actions.\';\nvar links = {\n  docs: \'https://github.com/material-components/material-components-web/tree/master/packages/mdc-banner\',\n  guide: \'https://material.io/components/banners\'\n};\nfunction Banner_BadgePage() {\n  var _useState = (0,react.useState)(false),\n      _useState2 = Banner_slicedToArray(_useState, 2),\n      open = _useState2[0],\n      setOpen = _useState2[1];\n\n  var _useState3 = (0,react.useState)(\'Lorem ipsum\'),\n      _useState4 = Banner_slicedToArray(_useState3, 2),\n      text = _useState4[0],\n      setText = _useState4[1];\n\n  var _useState5 = (0,react.useState)(false),\n      _useState6 = Banner_slicedToArray(_useState5, 2),\n      hasIcon = _useState6[0],\n      setHasIcon = _useState6[1];\n\n  var _useState7 = (0,react.useState)(\'\'),\n      _useState8 = Banner_slicedToArray(_useState7, 2),\n      icon = _useState8[0],\n      setIcon = _useState8[1];\n\n  var _useState9 = (0,react.useState)(false),\n      _useState10 = Banner_slicedToArray(_useState9, 2),\n      hasAction = _useState10[0],\n      setHasAction = _useState10[1];\n\n  var _useState11 = (0,react.useState)(\'\'),\n      _useState12 = Banner_slicedToArray(_useState11, 2),\n      action = _useState12[0],\n      setAction = _useState12[1];\n\n  var _useState13 = (0,react.useState)(false),\n      _useState14 = Banner_slicedToArray(_useState13, 2),\n      hasSecondaryAction = _useState14[0],\n      setHasSecondaryAction = _useState14[1];\n\n  var _useState15 = (0,react.useState)(\'\'),\n      _useState16 = Banner_slicedToArray(_useState15, 2),\n      secondaryAction = _useState16[0],\n      setSecondaryAction = _useState16[1];\n\n  var _useState17 = (0,react.useState)(false),\n      _useState18 = Banner_slicedToArray(_useState17, 2),\n      centered = _useState18[0],\n      setCentered = _useState18[1];\n\n  var _useState19 = (0,react.useState)(false),\n      _useState20 = Banner_slicedToArray(_useState19, 2),\n      fixed = _useState20[0],\n      setFixed = _useState20[1];\n\n  var _useState21 = (0,react.useState)(false),\n      _useState22 = Banner_slicedToArray(_useState21, 2),\n      mobileStacked = _useState22[0],\n      setMobileStacked = _useState22[1];\n\n  return /*#__PURE__*/(0,jsx_runtime.jsx)(Page, {\n    id: Banner_id,\n    title: Banner_title,\n    description: Banner_description,\n    links: links,\n    children: /*#__PURE__*/(0,jsx_runtime.jsx)(Demo, {\n      title: "Demo",\n      setup: /*#__PURE__*/(0,jsx_runtime.jsx)(top_app_bar_TopAppBar, {\n        title: "Title",\n        actionItems: /*#__PURE__*/(0,jsx_runtime.jsx)(button_Button, {\n          label: "Toggle",\n          onClick: function onClick() {\n            return setOpen(function (v) {\n              return !v;\n            });\n          }\n        }),\n        raised: true\n      }),\n      settings: /*#__PURE__*/(0,jsx_runtime.jsxs)(jsx_runtime.Fragment, {\n        children: [/*#__PURE__*/(0,jsx_runtime.jsx)(text_field_TextField, {\n          value: text,\n          label: "Text",\n          onChange: function onChange(_, value) {\n            return setText(value);\n          },\n          outlined: true\n        }), /*#__PURE__*/(0,jsx_runtime.jsx)(text_field_TextField, {\n          value: icon,\n          label: "Icon",\n          trailingIcon: /*#__PURE__*/(0,jsx_runtime.jsx)(switch_Switch, {\n            selected: hasIcon,\n            onChange: function onChange() {\n              return setHasIcon(function (v) {\n                return !v;\n              });\n            }\n          }),\n          outlined: true,\n          disabled: !hasIcon,\n          onChange: function onChange(_, value) {\n            return setIcon(value);\n          }\n        }), /*#__PURE__*/(0,jsx_runtime.jsx)(text_field_TextField, {\n          value: action,\n          label: "Action",\n          trailingIcon: /*#__PURE__*/(0,jsx_runtime.jsx)(switch_Switch, {\n            selected: hasAction,\n            onChange: function onChange() {\n              return setHasAction(function (v) {\n                return !v;\n              });\n            }\n          }),\n          disabled: !hasAction,\n          outlined: true,\n          onChange: function onChange(_, value) {\n            return setAction(value);\n          }\n        }), /*#__PURE__*/(0,jsx_runtime.jsx)(text_field_TextField, {\n          value: secondaryAction,\n          label: "Secondary action",\n          trailingIcon: /*#__PURE__*/(0,jsx_runtime.jsx)(switch_Switch, {\n            selected: hasSecondaryAction,\n            onChange: function onChange() {\n              return setHasSecondaryAction(function (v) {\n                return !v;\n              });\n            }\n          }),\n          disabled: !hasSecondaryAction,\n          outlined: true,\n          onChange: function onChange(_, value) {\n            return setSecondaryAction(value);\n          }\n        }), /*#__PURE__*/(0,jsx_runtime.jsx)(form_field_FormField, {\n          label: "Centered",\n          alignEnd: true,\n          spaceBetween: true,\n          children: /*#__PURE__*/(0,jsx_runtime.jsx)(switch_Switch, {\n            selected: centered,\n            onChange: function onChange() {\n              return setCentered(function (v) {\n                return !v;\n              });\n            }\n          })\n        }), /*#__PURE__*/(0,jsx_runtime.jsx)(form_field_FormField, {\n          label: "Fixed",\n          alignEnd: true,\n          spaceBetween: true,\n          children: /*#__PURE__*/(0,jsx_runtime.jsx)(switch_Switch, {\n            selected: fixed,\n            onChange: function onChange() {\n              return setFixed(function (v) {\n                return !v;\n              });\n            }\n          })\n        }), /*#__PURE__*/(0,jsx_runtime.jsx)(form_field_FormField, {\n          label: "Mobile stacked",\n          alignEnd: true,\n          spaceBetween: true,\n          children: /*#__PURE__*/(0,jsx_runtime.jsx)(switch_Switch, {\n            selected: mobileStacked,\n            onChange: function onChange() {\n              return setMobileStacked(function (v) {\n                return !v;\n              });\n            }\n          })\n        })]\n      }),\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(banner_Banner, {\n        text: text,\n        icon: hasIcon ? icon : undefined,\n        action: hasAction ? /*#__PURE__*/(0,jsx_runtime.jsx)(button_Button, {\n          children: action\n        }) : undefined,\n        secondaryAction: hasSecondaryAction ? /*#__PURE__*/(0,jsx_runtime.jsx)(button_Button, {\n          children: secondaryAction\n        }) : undefined,\n        open: open || undefined,\n        centered: centered || undefined,\n        fixed: fixed || undefined,\n        mobileStacked: mobileStacked || undefined\n      })\n    })\n  });\n}\n;// CONCATENATED MODULE: ./docs/src/pages/Button/index.jsx\nfunction Button_slicedToArray(arr, i) { return Button_arrayWithHoles(arr) || Button_iterableToArrayLimit(arr, i) || Button_unsupportedIterableToArray(arr, i) || Button_nonIterableRest(); }\n\nfunction Button_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction Button_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return Button_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return Button_arrayLikeToArray(o, minLen); }\n\nfunction Button_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction Button_iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction Button_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\n\n\n\n\n\n\n\n\nvar Button_id = \'button\';\nvar Button_title = \'Button\';\nvar Button_description = \'Buttons communicate an action a user can take. They are typically placed throughout your UI, in places like dialogs, forms, cards, and toolbars.\';\nvar Button_links = {\n  docs: \'https://github.com/material-components/material-components-web/tree/master/packages/mdc-button\',\n  guide: \'https://material.io/components/buttons\'\n};\nfunction ButtonPage() {\n  var _useState = (0,react.useState)(\'Button\'),\n      _useState2 = Button_slicedToArray(_useState, 2),\n      label = _useState2[0],\n      setLabel = _useState2[1];\n\n  var _useState3 = (0,react.useState)(false),\n      _useState4 = Button_slicedToArray(_useState3, 2),\n      hasLeadingIcon = _useState4[0],\n      setHasLeadingIcon = _useState4[1];\n\n  var _useState5 = (0,react.useState)(\'save\'),\n      _useState6 = Button_slicedToArray(_useState5, 2),\n      leadingIcon = _useState6[0],\n      setLeadingIcon = _useState6[1];\n\n  var _useState7 = (0,react.useState)(false),\n      _useState8 = Button_slicedToArray(_useState7, 2),\n      hasTrailingIcon = _useState8[0],\n      setHasTrailingIcon = _useState8[1];\n\n  var _useState9 = (0,react.useState)(\'close\'),\n      _useState10 = Button_slicedToArray(_useState9, 2),\n      trailingIcon = _useState10[0],\n      setTrailingIcon = _useState10[1];\n\n  var _useState11 = (0,react.useState)(\'plain\'),\n      _useState12 = Button_slicedToArray(_useState11, 2),\n      type = _useState12[0],\n      setType = _useState12[1];\n\n  return /*#__PURE__*/(0,jsx_runtime.jsx)(Page, {\n    id: Button_id,\n    title: Button_title,\n    description: Button_description,\n    links: Button_links,\n    children: /*#__PURE__*/(0,jsx_runtime.jsx)(Demo, {\n      title: "Demo",\n      settings: /*#__PURE__*/(0,jsx_runtime.jsxs)(jsx_runtime.Fragment, {\n        children: [/*#__PURE__*/(0,jsx_runtime.jsx)(text_field_TextField, {\n          value: label,\n          label: "Label",\n          outlined: true,\n          onChange: function onChange(_, value) {\n            return setLabel(value);\n          }\n        }), /*#__PURE__*/(0,jsx_runtime.jsx)(text_field_TextField, {\n          value: leadingIcon,\n          label: "Leading icon",\n          trailingIcon: /*#__PURE__*/(0,jsx_runtime.jsx)(switch_Switch, {\n            selected: hasLeadingIcon,\n            onChange: function onChange() {\n              return setHasLeadingIcon(function (v) {\n                return !v;\n              });\n            }\n          }),\n          outlined: true,\n          disabled: !hasLeadingIcon,\n          onChange: function onChange(_, value) {\n            return setLeadingIcon(value);\n          }\n        }), /*#__PURE__*/(0,jsx_runtime.jsx)(text_field_TextField, {\n          value: trailingIcon,\n          label: "Trailing icon",\n          trailingIcon: /*#__PURE__*/(0,jsx_runtime.jsx)(switch_Switch, {\n            selected: hasTrailingIcon,\n            onChange: function onChange() {\n              return setHasTrailingIcon(function (v) {\n                return !v;\n              });\n            }\n          }),\n          outlined: true,\n          disabled: !hasTrailingIcon,\n          onChange: function onChange(_, value) {\n            return setTrailingIcon(value);\n          }\n        }), /*#__PURE__*/(0,jsx_runtime.jsx)(FieldSet, {\n          legend: "Type",\n          children: /*#__PURE__*/(0,jsx_runtime.jsx)(segmented_button_SegmentedButton, {\n            segments: [{\n              value: \'plain\',\n              label: \'Plain\'\n            }, {\n              value: \'outlined\',\n              label: \'Outlined\'\n            }, {\n              value: \'unelevated\',\n              label: \'Unelevated\'\n            }, {\n              value: \'raised\',\n              label: \'Raised\'\n            }],\n            value: type,\n            onChange: setType\n          })\n        })]\n      }),\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(button_Button, {\n        leadingIcon: hasLeadingIcon ? leadingIcon : undefined,\n        trailingIcon: hasTrailingIcon ? trailingIcon : undefined,\n        outlined: type === \'outlined\' || undefined,\n        unelevated: type === \'unelevated\' || undefined,\n        raised: type === \'raised\' || undefined,\n        children: label\n      })\n    })\n  });\n}\n;// CONCATENATED MODULE: ./docs/src/pages/Card/index.jsx\nfunction Card_slicedToArray(arr, i) { return Card_arrayWithHoles(arr) || Card_iterableToArrayLimit(arr, i) || Card_unsupportedIterableToArray(arr, i) || Card_nonIterableRest(); }\n\nfunction Card_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction Card_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return Card_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return Card_arrayLikeToArray(o, minLen); }\n\nfunction Card_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction Card_iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction Card_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\n\n\n\n\n\n\n\nvar Card_id = \'card\';\nvar pageTitle = \'Card\';\nvar Card_description = \'Cards contain content and actions about a single subject.\';\nvar Card_links = {\n  docs: \'https://github.com/material-components/material-components-web/tree/master/packages/mdc-card\',\n  guide: \'https://material.io/components/cards\'\n};\n\'\';\nfunction CardPage() {\n  var _useState = (0,react.useState)(true),\n      _useState2 = Card_slicedToArray(_useState, 2),\n      hasTitle = _useState2[0],\n      setHasTitle = _useState2[1];\n\n  var _useState3 = (0,react.useState)(\'Title\'),\n      _useState4 = Card_slicedToArray(_useState3, 2),\n      title = _useState4[0],\n      setTitle = _useState4[1];\n\n  var _useState5 = (0,react.useState)(true),\n      _useState6 = Card_slicedToArray(_useState5, 2),\n      hasSubtitle = _useState6[0],\n      setHasSubtitle = _useState6[1];\n\n  var _useState7 = (0,react.useState)(\'Subtitle\'),\n      _useState8 = Card_slicedToArray(_useState7, 2),\n      subtitle = _useState8[0],\n      setSubtitle = _useState8[1];\n\n  return /*#__PURE__*/(0,jsx_runtime.jsx)(Page, {\n    id: Card_id,\n    title: pageTitle,\n    description: Card_description,\n    links: Card_links,\n    children: /*#__PURE__*/(0,jsx_runtime.jsx)(Demo, {\n      settings: /*#__PURE__*/(0,jsx_runtime.jsxs)(jsx_runtime.Fragment, {\n        children: [/*#__PURE__*/(0,jsx_runtime.jsx)(text_field_TextField, {\n          value: title,\n          label: "Title",\n          trailingIcon: /*#__PURE__*/(0,jsx_runtime.jsx)(switch_Switch, {\n            selected: hasTitle,\n            onChange: function onChange() {\n              return setHasTitle(function (v) {\n                return !v;\n              });\n            }\n          }),\n          outlined: true,\n          disabled: !hasTitle,\n          onChange: function onChange(_, value) {\n            return setTitle(value);\n          }\n        }), /*#__PURE__*/(0,jsx_runtime.jsx)(text_field_TextField, {\n          value: subtitle,\n          label: "Subtitle",\n          trailingIcon: /*#__PURE__*/(0,jsx_runtime.jsx)(switch_Switch, {\n            selected: hasSubtitle,\n            onChange: function onChange() {\n              return setHasSubtitle(function (v) {\n                return !v;\n              });\n            }\n          }),\n          outlined: true,\n          disabled: !hasSubtitle,\n          onChange: function onChange(_, value) {\n            return setSubtitle(value);\n          }\n        })]\n      }),\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(card_Card, {\n        children: /*#__PURE__*/(0,jsx_runtime.jsx)(card_Card.Header, {\n          overline: "Overline",\n          title: hasTitle ? title : undefined,\n          subtitle: hasSubtitle ? subtitle : undefined\n        })\n      })\n    })\n  });\n}\n;// CONCATENATED MODULE: ./docs/src/pages/Checkbox/index.jsx\nfunction Checkbox_slicedToArray(arr, i) { return Checkbox_arrayWithHoles(arr) || Checkbox_iterableToArrayLimit(arr, i) || Checkbox_unsupportedIterableToArray(arr, i) || Checkbox_nonIterableRest(); }\n\nfunction Checkbox_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction Checkbox_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return Checkbox_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return Checkbox_arrayLikeToArray(o, minLen); }\n\nfunction Checkbox_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction Checkbox_iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction Checkbox_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\n\n\n\n\n\nvar Checkbox_id = \'checkbox\';\nvar Checkbox_title = \'Checkbox\';\nvar Checkbox_description = \'Checkboxes allow the user to select multiple options from a set.\';\nvar Checkbox_links = {\n  docs: \'https://github.com/material-components/material-components-web/tree/master/packages/mdc-checkbox\',\n  guide: \'https://material.io/components/checkboxes\'\n};\nfunction CheckboxPage() {\n  var _useState = (0,react.useState)(false),\n      _useState2 = Checkbox_slicedToArray(_useState, 2),\n      checked = _useState2[0],\n      setChecked = _useState2[1];\n\n  var _useState3 = (0,react.useState)(true),\n      _useState4 = Checkbox_slicedToArray(_useState3, 2),\n      controlled = _useState4[0],\n      setControlled = _useState4[1];\n\n  var _useState5 = (0,react.useState)(),\n      _useState6 = Checkbox_slicedToArray(_useState5, 2),\n      indeterminate = _useState6[0],\n      setIndeterminate = _useState6[1];\n\n  var _useState7 = (0,react.useState)(),\n      _useState8 = Checkbox_slicedToArray(_useState7, 2),\n      disabled = _useState8[0],\n      setDisabled = _useState8[1];\n\n  return /*#__PURE__*/(0,jsx_runtime.jsx)(Page, {\n    id: Checkbox_id,\n    title: Checkbox_title,\n    description: Checkbox_description,\n    links: Checkbox_links,\n    children: /*#__PURE__*/(0,jsx_runtime.jsx)(Demo, {\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(checkbox_Checkbox, {\n        checked: controlled ? checked : undefined,\n        defaultChecked: !controlled ? false : undefined,\n        indeterminate: indeterminate,\n        disabled: disabled,\n        onChange: function onChange() {\n          return setChecked(function (v) {\n            return !v;\n          });\n        }\n      })\n    })\n  });\n}\n;// CONCATENATED MODULE: ./docs/src/pages/Chips/index.jsx\nfunction Chips_slicedToArray(arr, i) { return Chips_arrayWithHoles(arr) || Chips_iterableToArrayLimit(arr, i) || Chips_unsupportedIterableToArray(arr, i) || Chips_nonIterableRest(); }\n\nfunction Chips_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction Chips_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return Chips_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return Chips_arrayLikeToArray(o, minLen); }\n\nfunction Chips_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction Chips_iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction Chips_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\n\n\n\n\n\n\nvar Chips_id = \'chips\';\nvar Chips_title = \'Chips\';\nvar Chips_description = \'Chips are compact elements that allow users to enter information, select a choice, filter content, or trigger an action.\';\nvar Chips_links = {\n  docs: \'https://github.com/material-components/material-components-web/tree/master/packages/mdc-chips\',\n  guide: \'https://material.io/components/chips\'\n};\nfunction ChipsPage() {\n  var _useState = (0,react.useState)(\'foo\'),\n      _useState2 = Chips_slicedToArray(_useState, 2),\n      choiceChip = _useState2[0],\n      setChoiceChips = _useState2[1];\n\n  var _useState3 = (0,react.useState)([\'foo\']),\n      _useState4 = Chips_slicedToArray(_useState3, 2),\n      filterChips = _useState4[0],\n      setFilterChips = _useState4[1];\n\n  return /*#__PURE__*/(0,jsx_runtime.jsxs)(Page, {\n    id: Chips_id,\n    title: Chips_title,\n    description: Chips_description,\n    links: Chips_links,\n    children: [/*#__PURE__*/(0,jsx_runtime.jsx)(Demo, {\n      title: "Basic chips",\n      children: /*#__PURE__*/(0,jsx_runtime.jsxs)(chips_ChipSet, {\n        children: [/*#__PURE__*/(0,jsx_runtime.jsx)(chips_Chip, {\n          text: "Foo"\n        }), /*#__PURE__*/(0,jsx_runtime.jsx)(chips_Chip, {\n          text: "Bar"\n        }), /*#__PURE__*/(0,jsx_runtime.jsx)(chips_Chip, {\n          text: "Baz"\n        })]\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Demo, {\n      title: "Chips with icons",\n      children: /*#__PURE__*/(0,jsx_runtime.jsxs)(chips_ChipSet, {\n        children: [/*#__PURE__*/(0,jsx_runtime.jsx)(chips_Chip, {\n          text: "Foo",\n          icon: "star"\n        }), /*#__PURE__*/(0,jsx_runtime.jsx)(chips_Chip, {\n          text: "Bar",\n          icon: "star"\n        }), /*#__PURE__*/(0,jsx_runtime.jsx)(chips_Chip, {\n          text: "Baz",\n          icon: "star"\n        })]\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Demo, {\n      title: "Chips with trailing icons",\n      children: /*#__PURE__*/(0,jsx_runtime.jsxs)(chips_ChipSet, {\n        children: [/*#__PURE__*/(0,jsx_runtime.jsx)(chips_Chip, {\n          text: "Foo",\n          trailingIcon: "delete"\n        }), /*#__PURE__*/(0,jsx_runtime.jsx)(chips_Chip, {\n          text: "Bar",\n          trailingIcon: "delete"\n        }), /*#__PURE__*/(0,jsx_runtime.jsx)(chips_Chip, {\n          text: "Baz",\n          trailingIcon: "delete"\n        })]\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Demo, {\n      title: "Chips with avatars",\n      children: /*#__PURE__*/(0,jsx_runtime.jsxs)(chips_ChipSet, {\n        children: [/*#__PURE__*/(0,jsx_runtime.jsx)(chips_Chip, {\n          text: "Foo",\n          avatar: /*#__PURE__*/(0,jsx_runtime.jsx)(avatar_Avatar, {\n            image: "https://placeimg.com/128/128/people",\n            size: "small"\n          })\n        }), /*#__PURE__*/(0,jsx_runtime.jsx)(chips_Chip, {\n          text: "Bar",\n          avatar: /*#__PURE__*/(0,jsx_runtime.jsx)(avatar_Avatar, {\n            image: "https://placeimg.com/128/128/people",\n            size: "small"\n          })\n        }), /*#__PURE__*/(0,jsx_runtime.jsx)(chips_Chip, {\n          text: "Baz",\n          avatar: /*#__PURE__*/(0,jsx_runtime.jsx)(avatar_Avatar, {\n            image: "https://placeimg.com/128/128/people",\n            size: "small"\n          })\n        })]\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Demo, {\n      title: "Choice chips",\n      children: /*#__PURE__*/(0,jsx_runtime.jsxs)(chips_ChipSet, {\n        value: choiceChip,\n        onChange: function onChange(value) {\n          return setChoiceChips(value);\n        },\n        children: [/*#__PURE__*/(0,jsx_runtime.jsx)(chips_Chip, {\n          value: "foo",\n          text: "Foo"\n        }), /*#__PURE__*/(0,jsx_runtime.jsx)(chips_Chip, {\n          value: "bar",\n          text: "Bar"\n        }), /*#__PURE__*/(0,jsx_runtime.jsx)(chips_Chip, {\n          value: "baz",\n          text: "Baz"\n        })]\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Demo, {\n      title: "Filter chips",\n      children: /*#__PURE__*/(0,jsx_runtime.jsxs)(chips_ChipSet, {\n        value: filterChips,\n        onChange: function onChange(value) {\n          return setFilterChips(value);\n        },\n        children: [/*#__PURE__*/(0,jsx_runtime.jsx)(chips_Chip, {\n          value: "foo",\n          text: "Foo"\n        }), /*#__PURE__*/(0,jsx_runtime.jsx)(chips_Chip, {\n          value: "bar",\n          text: "Bar"\n        }), /*#__PURE__*/(0,jsx_runtime.jsx)(chips_Chip, {\n          value: "baz",\n          text: "Baz"\n        })]\n      })\n    })]\n  });\n}\n;// CONCATENATED MODULE: ./docs/src/pages/CircularProgress/index.jsx\nfunction CircularProgress_slicedToArray(arr, i) { return CircularProgress_arrayWithHoles(arr) || CircularProgress_iterableToArrayLimit(arr, i) || CircularProgress_unsupportedIterableToArray(arr, i) || CircularProgress_nonIterableRest(); }\n\nfunction CircularProgress_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction CircularProgress_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return CircularProgress_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return CircularProgress_arrayLikeToArray(o, minLen); }\n\nfunction CircularProgress_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction CircularProgress_iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction CircularProgress_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\n\n\n\n\n\n\n\n\nvar CircularProgress_id = \'circular-progress\';\nvar CircularProgress_title = \'Circular Progress\';\nvar CircularProgress_description = \'Circular progress indicators display progress by animating an indicator along an invisible circular track in a clockwise direction.\';\nvar CircularProgress_links = {\n  docs: \'https://github.com/material-components/material-components-web/tree/master/packages/mdc-circular-progress\',\n  guide: \'https://material.io/components/progress-indicators#circular-progress-indicators\'\n};\nfunction CircularProgressPage() {\n  var _useState = (0,react.useState)(42),\n      _useState2 = CircularProgress_slicedToArray(_useState, 2),\n      value = _useState2[0],\n      setValue = _useState2[1];\n\n  var _useState3 = (0,react.useState)(\'medium\'),\n      _useState4 = CircularProgress_slicedToArray(_useState3, 2),\n      size = _useState4[0],\n      setSize = _useState4[1];\n\n  var _useState5 = (0,react.useState)(false),\n      _useState6 = CircularProgress_slicedToArray(_useState5, 2),\n      indeterminate = _useState6[0],\n      setIndeterminate = _useState6[1];\n\n  var _useState7 = (0,react.useState)(false),\n      _useState8 = CircularProgress_slicedToArray(_useState7, 2),\n      colorful = _useState8[0],\n      setColorful = _useState8[1];\n\n  var _useState9 = (0,react.useState)(false),\n      _useState10 = CircularProgress_slicedToArray(_useState9, 2),\n      closed = _useState10[0],\n      setClosed = _useState10[1];\n\n  return /*#__PURE__*/(0,jsx_runtime.jsx)(Page, {\n    id: CircularProgress_id,\n    title: CircularProgress_title,\n    description: CircularProgress_description,\n    links: CircularProgress_links,\n    children: /*#__PURE__*/(0,jsx_runtime.jsx)(Demo, {\n      settings: /*#__PURE__*/(0,jsx_runtime.jsxs)(jsx_runtime.Fragment, {\n        children: [/*#__PURE__*/(0,jsx_runtime.jsx)(text_field_TextField, {\n          value: value,\n          label: "Value",\n          outlined: true,\n          onChange: function onChange(_, value) {\n            return setValue(value);\n          }\n        }), /*#__PURE__*/(0,jsx_runtime.jsx)(FieldSet, {\n          legend: "Size",\n          children: /*#__PURE__*/(0,jsx_runtime.jsx)(segmented_button_SegmentedButton, {\n            segments: [{\n              value: \'small\',\n              label: \'Small\'\n            }, {\n              value: \'medium\',\n              label: \'Medium\'\n            }, {\n              value: \'large\',\n              label: \'Large\'\n            }],\n            value: size,\n            onChange: setSize\n          })\n        }), /*#__PURE__*/(0,jsx_runtime.jsx)(form_field_FormField, {\n          label: "Indeterminate",\n          alignEnd: true,\n          spaceBetween: true,\n          children: /*#__PURE__*/(0,jsx_runtime.jsx)(switch_Switch, {\n            selected: indeterminate,\n            onChange: function onChange() {\n              return setIndeterminate(function (v) {\n                return !v;\n              });\n            }\n          })\n        }), /*#__PURE__*/(0,jsx_runtime.jsx)(form_field_FormField, {\n          label: "Colorful",\n          alignEnd: true,\n          spaceBetween: true,\n          children: /*#__PURE__*/(0,jsx_runtime.jsx)(switch_Switch, {\n            selected: colorful,\n            onChange: function onChange() {\n              return setColorful(function (v) {\n                return !v;\n              });\n            }\n          })\n        }), /*#__PURE__*/(0,jsx_runtime.jsx)(form_field_FormField, {\n          label: "Closed",\n          alignEnd: true,\n          spaceBetween: true,\n          children: /*#__PURE__*/(0,jsx_runtime.jsx)(switch_Switch, {\n            selected: closed,\n            onChange: function onChange() {\n              return setClosed(function (v) {\n                return !v;\n              });\n            }\n          })\n        })]\n      }),\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(circular_progress_CircularProgress, {\n        value: indeterminate ? undefined : value,\n        size: size,\n        indeterminate: indeterminate || undefined,\n        colorful: colorful || undefined,\n        closed: closed || undefined\n      })\n    })\n  });\n}\n;// CONCATENATED MODULE: ./docs/src/pages/DataTable/index.jsx\nfunction DataTable_slicedToArray(arr, i) { return DataTable_arrayWithHoles(arr) || DataTable_iterableToArrayLimit(arr, i) || DataTable_unsupportedIterableToArray(arr, i) || DataTable_nonIterableRest(); }\n\nfunction DataTable_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction DataTable_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return DataTable_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return DataTable_arrayLikeToArray(o, minLen); }\n\nfunction DataTable_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction DataTable_iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction DataTable_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\n\n\n\n\n\n\nvar DataTable_id = \'data-table\';\nvar DataTable_title = \'Data Table\';\nvar DataTable_description = \'Data tables display sets of data across rows and columns.\';\nvar DataTable_links = {\n  docs: \'https://github.com/material-components/material-components-web/tree/master/packages/mdc-data-table\',\n  guide: \'https://material.io/components/data-tables\'\n};\nvar table = [[\'Frozen yogurt\', 24, 4.0, \'Super tasty\'], [\'Ice cream sandwich\', 37, 4.33333333333, \'I like ice cream more\'], [\'Eclair\', 24, 6.0, \'New filing flavor\']];\nfunction DataTablePage() {\n  var _useState = (0,react.useState)(table),\n      _useState2 = DataTable_slicedToArray(_useState, 2),\n      data = _useState2[0],\n      setData = _useState2[1];\n\n  var _useState3 = (0,react.useState)(0),\n      _useState4 = DataTable_slicedToArray(_useState3, 2),\n      sort = _useState4[0],\n      setSort = _useState4[1];\n\n  var handleSort = (0,react.useCallback)(function () {\n    setSort(function (sort) {\n      if (sort === -1) {\n        setData(function (data) {\n          return data.slice().sort(function (a, b) {\n            return a[1] - b[1];\n          });\n        });\n        setSort(1);\n      } else {\n        setData(function (data) {\n          return data.slice().sort(function (a, b) {\n            return b[1] - a[1];\n          });\n        });\n        setSort(-1);\n      }\n    });\n  }, []);\n  return /*#__PURE__*/(0,jsx_runtime.jsx)(Page, {\n    id: DataTable_id,\n    title: DataTable_title,\n    description: DataTable_description,\n    links: DataTable_links,\n    children: /*#__PURE__*/(0,jsx_runtime.jsx)(Demo, {\n      title: "Sortable data table",\n      children: /*#__PURE__*/(0,jsx_runtime.jsxs)(data_table_DataTable, {\n        children: [/*#__PURE__*/(0,jsx_runtime.jsx)(data_table_DataTable.Header, {\n          children: /*#__PURE__*/(0,jsx_runtime.jsxs)(data_table_DataTable.HeaderRow, {\n            children: [/*#__PURE__*/(0,jsx_runtime.jsx)(data_table_DataTable.HeaderCell, {\n              children: "Dessert"\n            }), /*#__PURE__*/(0,jsx_runtime.jsx)(data_table_DataTable.HeaderCell, {\n              numeric: true,\n              sort: sort,\n              onSort: handleSort,\n              children: "Carbs (g)"\n            }), /*#__PURE__*/(0,jsx_runtime.jsx)(data_table_DataTable.HeaderCell, {\n              numeric: true,\n              children: "Protein (g)"\n            }), /*#__PURE__*/(0,jsx_runtime.jsx)(data_table_DataTable.HeaderCell, {\n              children: "Comments"\n            })]\n          })\n        }), /*#__PURE__*/(0,jsx_runtime.jsx)(data_table_DataTable.Content, {\n          children: data.map(function (row, index) {\n            return /*#__PURE__*/(0,jsx_runtime.jsx)(data_table_DataTable.Row, {\n              children: row.map(function (value, index) {\n                return /*#__PURE__*/(0,jsx_runtime.jsx)(data_table_DataTable.Cell, {\n                  scope: index === 0 ? \'row\' : undefined,\n                  numeric: typeof value === \'number\' || undefined,\n                  children: value\n                }, index);\n              })\n            }, index);\n          })\n        })]\n      })\n    })\n  });\n}\n;// CONCATENATED MODULE: ./docs/src/pages/Dialog/index.jsx\nfunction Dialog_slicedToArray(arr, i) { return Dialog_arrayWithHoles(arr) || Dialog_iterableToArrayLimit(arr, i) || Dialog_unsupportedIterableToArray(arr, i) || Dialog_nonIterableRest(); }\n\nfunction Dialog_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction Dialog_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return Dialog_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return Dialog_arrayLikeToArray(o, minLen); }\n\nfunction Dialog_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction Dialog_iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction Dialog_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\n\n\n\n\n\n\nvar Dialog_id = \'dialog\';\nvar Dialog_title = \'Dialog\';\nvar Dialog_description = \'Dialogs inform users about a specific task and may contain critical information, require decisions, or involve multiple tasks.\';\nvar Dialog_links = {\n  docs: \'https://github.com/material-components/material-components-web/tree/master/packages/mdc-dialog\',\n  guide: \'https://material.io/components/dialogs\'\n};\nvar scrollableContent = "\\n    Lorem ipsum dolor sit amet consectetur adipisicing elit. Sunt earum quibusdam dolor hic accusamus, deserunt libero? Deleniti ratione libero, eveniet neque aliquam repellat dicta obcaecati atque, sequi voluptatem explicabo beatae!\\n\\n    Lorem ipsum dolor sit amet consectetur adipisicing elit. Veritatis animi vel cupiditate eveniet? Laudantium recusandae illo minus saepe itaque dolores fugiat, perferendis nostrum! Assumenda fugiat fuga deserunt omnis odit dicta!\\n\\n    Lorem ipsum dolor sit amet consectetur adipisicing elit. Minus accusantium a quisquam in repudiandae et ullam cum dignissimos exercitationem, blanditiis perspiciatis alias hic vel, laudantium aliquam omnis recusandae nemo animi.\\n\\n    Lorem ipsum dolor sit amet consectetur adipisicing elit. Sunt earum quibusdam dolor hic accusamus, deserunt libero? Deleniti ratione libero, eveniet neque aliquam repellat dicta obcaecati atque, sequi voluptatem explicabo beatae!\\n\\n    Lorem ipsum dolor sit amet consectetur adipisicing elit. Veritatis animi vel cupiditate eveniet? Laudantium recusandae illo minus saepe itaque dolores fugiat, perferendis nostrum! Assumenda fugiat fuga deserunt omnis odit dicta!\\n\\n    Lorem ipsum dolor sit amet consectetur adipisicing elit. Minus accusantium a quisquam in repudiandae et ullam cum dignissimos exercitationem, blanditiis perspiciatis alias hic vel, laudantium aliquam omnis recusandae nemo animi.\\n\\n    Lorem ipsum dolor sit amet consectetur adipisicing elit. Sunt earum quibusdam dolor hic accusamus, deserunt libero? Deleniti ratione libero, eveniet neque aliquam repellat dicta obcaecati atque, sequi voluptatem explicabo beatae!\\n\\n    Lorem ipsum dolor sit amet consectetur adipisicing elit. Veritatis animi vel cupiditate eveniet? Laudantium recusandae illo minus saepe itaque dolores fugiat, perferendis nostrum! Assumenda fugiat fuga deserunt omnis odit dicta!\\n\\n    Lorem ipsum dolor sit amet consectetur adipisicing elit. Minus accusantium a quisquam in repudiandae et ullam cum dignissimos exercitationem, blanditiis perspiciatis alias hic vel, laudantium aliquam omnis recusandae nemo animi.\\n\\n    Lorem ipsum dolor sit amet consectetur adipisicing elit. Sunt earum quibusdam dolor hic accusamus, deserunt libero? Deleniti ratione libero, eveniet neque aliquam repellat dicta obcaecati atque, sequi voluptatem explicabo beatae!\\n\\n    Lorem ipsum dolor sit amet consectetur adipisicing elit. Veritatis animi vel cupiditate eveniet? Laudantium recusandae illo minus saepe itaque dolores fugiat, perferendis nostrum! Assumenda fugiat fuga deserunt omnis odit dicta!\\n\\n    Lorem ipsum dolor sit amet consectetur adipisicing elit. Minus accusantium a quisquam in repudiandae et ullam cum dignissimos exercitationem, blanditiis perspiciatis alias hic vel, laudantium aliquam omnis recusandae nemo animi.\\n\\n    Lorem ipsum dolor sit amet consectetur adipisicing elit. Sunt earum quibusdam dolor hic accusamus, deserunt libero? Deleniti ratione libero, eveniet neque aliquam repellat dicta obcaecati atque, sequi voluptatem explicabo beatae!\\n\\n    Lorem ipsum dolor sit amet consectetur adipisicing elit. Veritatis animi vel cupiditate eveniet? Laudantium recusandae illo minus saepe itaque dolores fugiat, perferendis nostrum! Assumenda fugiat fuga deserunt omnis odit dicta!\\n\\n    Lorem ipsum dolor sit amet consectetur adipisicing elit. Minus accusantium a quisquam in repudiandae et ullam cum dignissimos exercitationem, blanditiis perspiciatis alias hic vel, laudantium aliquam omnis recusandae nemo animi.\\n\\n    Lorem ipsum dolor sit amet consectetur adipisicing elit. Sunt earum quibusdam dolor hic accusamus, deserunt libero? Deleniti ratione libero, eveniet neque aliquam repellat dicta obcaecati atque, sequi voluptatem explicabo beatae!\\n\\n    Lorem ipsum dolor sit amet consectetur adipisicing elit. Veritatis animi vel cupiditate eveniet? Laudantium recusandae illo minus saepe itaque dolores fugiat, perferendis nostrum! Assumenda fugiat fuga deserunt omnis odit dicta!\\n\\n    Lorem ipsum dolor sit amet consectetur adipisicing elit. Minus accusantium a quisquam in repudiandae et ullam cum dignissimos exercitationem, blanditiis perspiciatis alias hic vel, laudantium aliquam omnis recusandae nemo animi.\\n";\nfunction DialogPage() {\n  var _useState = (0,react.useState)(false),\n      _useState2 = Dialog_slicedToArray(_useState, 2),\n      isBasicOpen = _useState2[0],\n      setBasicOpen = _useState2[1];\n\n  var _useState3 = (0,react.useState)(false),\n      _useState4 = Dialog_slicedToArray(_useState3, 2),\n      isConfirmationOpen = _useState4[0],\n      setConfirmationOpen = _useState4[1];\n\n  var _useState5 = (0,react.useState)(false),\n      _useState6 = Dialog_slicedToArray(_useState5, 2),\n      isStackingOpen = _useState6[0],\n      setStackingOpen = _useState6[1];\n\n  var _useState7 = (0,react.useState)(false),\n      _useState8 = Dialog_slicedToArray(_useState7, 2),\n      isScrollableOpen = _useState8[0],\n      setScrollableOpen = _useState8[1];\n\n  var _useState9 = (0,react.useState)(false),\n      _useState10 = Dialog_slicedToArray(_useState9, 2),\n      isFullscreenOpen = _useState10[0],\n      setFullscreenOpen = _useState10[1];\n\n  var _useState11 = (0,react.useState)(false),\n      _useState12 = Dialog_slicedToArray(_useState11, 2),\n      isFloatingSheetOpen = _useState12[0],\n      setFloatingSheetOpen = _useState12[1];\n\n  return /*#__PURE__*/(0,jsx_runtime.jsxs)(Page, {\n    id: Dialog_id,\n    title: Dialog_title,\n    description: Dialog_description,\n    links: Dialog_links,\n    children: [/*#__PURE__*/(0,jsx_runtime.jsx)(Demo, {\n      title: "Basic dialog",\n      setup: /*#__PURE__*/(0,jsx_runtime.jsx)(button_Button, {\n        onClick: function onClick() {\n          return setBasicOpen(function (v) {\n            return !v;\n          });\n        },\n        children: "Open"\n      }),\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(dialog_Dialog, {\n        title: "Title",\n        content: "Content",\n        open: isBasicOpen,\n        onClose: function onClose() {\n          return setBasicOpen(function (v) {\n            return !v;\n          });\n        }\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Demo, {\n      title: "Confirmation dialog",\n      setup: /*#__PURE__*/(0,jsx_runtime.jsx)(button_Button, {\n        onClick: function onClick() {\n          return setConfirmationOpen(function (v) {\n            return !v;\n          });\n        },\n        children: "Open"\n      }),\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(dialog_Dialog, {\n        title: "Title",\n        content: "Are you sure?",\n        open: isConfirmationOpen,\n        persistent: true,\n        actions: [/*#__PURE__*/(0,jsx_runtime.jsx)(button_Button, {\n          onClick: function onClick() {\n            return setConfirmationOpen(function (v) {\n              return !v;\n            });\n          },\n          children: "Close"\n        }, "close"), /*#__PURE__*/(0,jsx_runtime.jsx)(button_Button, {\n          children: "Confirm"\n        }, "confirm")],\n        onClose: function onClose() {\n          return setConfirmationOpen(function (v) {\n            return !v;\n          });\n        }\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Demo, {\n      title: "Dialog with stacking buttons",\n      setup: /*#__PURE__*/(0,jsx_runtime.jsx)(button_Button, {\n        onClick: function onClick() {\n          return setStackingOpen(function (v) {\n            return !v;\n          });\n        },\n        children: "Open"\n      }),\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(dialog_Dialog, {\n        title: "Title",\n        content: "Content",\n        open: isStackingOpen,\n        autoStackButtons: true,\n        actions: [/*#__PURE__*/(0,jsx_runtime.jsx)(button_Button, {\n          onClick: function onClick() {\n            return setStackingOpen(function (v) {\n              return !v;\n            });\n          },\n          children: "A very very very very very long button"\n        }, "close"), /*#__PURE__*/(0,jsx_runtime.jsx)(button_Button, {\n          children: "A very very very very very long button"\n        }, "confirm")],\n        onClose: function onClose() {\n          return setStackingOpen(function (v) {\n            return !v;\n          });\n        }\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Demo, {\n      title: "Scrollable dialog",\n      setup: /*#__PURE__*/(0,jsx_runtime.jsx)(button_Button, {\n        onClick: function onClick() {\n          return setScrollableOpen(function (v) {\n            return !v;\n          });\n        },\n        children: "Open"\n      }),\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(dialog_Dialog, {\n        title: "Title",\n        open: isScrollableOpen,\n        actions: [/*#__PURE__*/(0,jsx_runtime.jsx)(button_Button, {\n          onClick: function onClick() {\n            return setScrollableOpen(function (v) {\n              return !v;\n            });\n          },\n          children: "Close"\n        }, "close")],\n        onClose: function onClose() {\n          return setScrollableOpen(function (v) {\n            return !v;\n          });\n        },\n        children: scrollableContent\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Demo, {\n      title: "Fullscreen dialog",\n      setup: /*#__PURE__*/(0,jsx_runtime.jsx)(button_Button, {\n        onClick: function onClick() {\n          return setFullscreenOpen(function (v) {\n            return !v;\n          });\n        },\n        children: "Open"\n      }),\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(dialog_Dialog, {\n        title: "Fullscreen Dialog",\n        open: isFullscreenOpen,\n        fullscreen: true,\n        actions: /*#__PURE__*/(0,jsx_runtime.jsx)(button_Button, {\n          onClick: function onClick() {\n            return setFullscreenOpen(function (v) {\n              return !v;\n            });\n          },\n          children: "Close"\n        }, "close"),\n        onClose: function onClose() {\n          return setFullscreenOpen(function (v) {\n            return !v;\n          });\n        },\n        children: scrollableContent\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Demo, {\n      title: "Floating sheet",\n      setup: /*#__PURE__*/(0,jsx_runtime.jsx)(button_Button, {\n        onClick: function onClick() {\n          return setFloatingSheetOpen(true);\n        },\n        children: "Open"\n      }),\n      children: /*#__PURE__*/(0,jsx_runtime.jsxs)(dialog_Dialog, {\n        open: isFloatingSheetOpen,\n        sheet: true,\n        onClose: function onClose() {\n          return setFloatingSheetOpen(false);\n        },\n        children: [/*#__PURE__*/(0,jsx_runtime.jsx)("h3", {\n          children: "Sheets"\n        }), "There are no action buttons. Any HTML content can go here. Title is also defined through content."]\n      })\n    })]\n  });\n}\n;// CONCATENATED MODULE: ./docs/src/pages/Drawer/index.jsx\nfunction Drawer_slicedToArray(arr, i) { return Drawer_arrayWithHoles(arr) || Drawer_iterableToArrayLimit(arr, i) || Drawer_unsupportedIterableToArray(arr, i) || Drawer_nonIterableRest(); }\n\nfunction Drawer_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction Drawer_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return Drawer_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return Drawer_arrayLikeToArray(o, minLen); }\n\nfunction Drawer_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction Drawer_iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction Drawer_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\n\n\n\n\n\n\nvar Drawer_id = \'drawer\';\nvar Drawer_title = \'Drawer\';\nvar Drawer_description = \'Navigation drawers provide access to destinations in your app.\';\nvar Drawer_links = {\n  docs: \'https://github.com/material-components/material-components-web/tree/master/packages/mdc-drawer\',\n  guide: \'https://material.io/components/navigation-drawer\'\n};\nfunction DrawerPage() {\n  var _useState = (0,react.useState)(false),\n      _useState2 = Drawer_slicedToArray(_useState, 2),\n      isDismissibleOpen = _useState2[0],\n      setDismissibleOpen = _useState2[1];\n\n  var _useState3 = (0,react.useState)(false),\n      _useState4 = Drawer_slicedToArray(_useState3, 2),\n      isModalOpen = _useState4[0],\n      setModalOpen = _useState4[1];\n\n  return /*#__PURE__*/(0,jsx_runtime.jsxs)(Page, {\n    id: Drawer_id,\n    title: Drawer_title,\n    description: Drawer_description,\n    links: Drawer_links,\n    children: [/*#__PURE__*/(0,jsx_runtime.jsx)(Demo, {\n      title: "Permanent drawer",\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(drawer_Drawer, {\n        children: /*#__PURE__*/(0,jsx_runtime.jsx)(drawer_Drawer.Header, {\n          title: "Title"\n        })\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Demo, {\n      title: "Dismissible drawer",\n      setup: /*#__PURE__*/(0,jsx_runtime.jsx)(button_Button, {\n        label: "Toggle",\n        onClick: function onClick() {\n          return setDismissibleOpen(function (v) {\n            return !v;\n          });\n        }\n      }),\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(drawer_Drawer, {\n        open: isDismissibleOpen,\n        dismissible: true,\n        children: /*#__PURE__*/(0,jsx_runtime.jsx)(drawer_Drawer.Header, {\n          title: "Title"\n        })\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Demo, {\n      title: "Modal drawer",\n      setup: /*#__PURE__*/(0,jsx_runtime.jsx)(button_Button, {\n        label: "Toggle",\n        onClick: function onClick() {\n          return setModalOpen(function (v) {\n            return !v;\n          });\n        }\n      }),\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(drawer_Drawer, {\n        open: isModalOpen,\n        onClose: function onClose() {\n          return setModalOpen(function (v) {\n            return !v;\n          });\n        },\n        modal: true,\n        children: /*#__PURE__*/(0,jsx_runtime.jsx)(drawer_Drawer.Header, {\n          title: "Title"\n        })\n      })\n    })]\n  });\n}\n;// CONCATENATED MODULE: ./docs/src/pages/Elevation/index.jsx\nfunction Elevation_slicedToArray(arr, i) { return Elevation_arrayWithHoles(arr) || Elevation_iterableToArrayLimit(arr, i) || Elevation_unsupportedIterableToArray(arr, i) || Elevation_nonIterableRest(); }\n\nfunction Elevation_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction Elevation_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return Elevation_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return Elevation_arrayLikeToArray(o, minLen); }\n\nfunction Elevation_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction Elevation_iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction Elevation_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\n\n\n\n\n\n\nvar Elevation_id = \'elevation\';\nvar Elevation_title = \'Elevation\';\nvar Elevation_description = \'Elevation is the relative distance between two surfaces along the z-axis.\';\nvar Elevation_links = {\n  docs: \'https://github.com/material-components/material-components-web/tree/master/packages/mdc-elevation\',\n  guide: \'https://material.io/design/environment/elevation\'\n};\nfunction ElevationPage() {\n  var _useState = (0,react.useState)(0),\n      _useState2 = Elevation_slicedToArray(_useState, 2),\n      z = _useState2[0],\n      setZ = _useState2[1];\n\n  var handleChange = (0,react.useCallback)(function (value) {\n    setZ(value);\n  }, []);\n  return /*#__PURE__*/(0,jsx_runtime.jsx)(Page, {\n    id: Elevation_id,\n    title: Elevation_title,\n    description: Elevation_description,\n    links: Elevation_links,\n    children: /*#__PURE__*/(0,jsx_runtime.jsx)(Demo, {\n      setup: /*#__PURE__*/(0,jsx_runtime.jsx)(slider_Slider, {\n        value: z,\n        min: "0",\n        max: "24",\n        step: "1",\n        discrete: true,\n        tickMarks: true,\n        onChange: handleChange\n      }),\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(elevation_Elevation, {\n        z: z\n      })\n    })\n  });\n}\n;// CONCATENATED MODULE: ./docs/src/pages/FAB/index.jsx\nfunction FAB_slicedToArray(arr, i) { return FAB_arrayWithHoles(arr) || FAB_iterableToArrayLimit(arr, i) || FAB_unsupportedIterableToArray(arr, i) || FAB_nonIterableRest(); }\n\nfunction FAB_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction FAB_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return FAB_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return FAB_arrayLikeToArray(o, minLen); }\n\nfunction FAB_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction FAB_iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction FAB_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\n\n\n\n\n\n\nvar FAB_id = \'fab\';\nvar FAB_title = \'FAB\';\nvar FAB_description = \'A floating action button (FAB) represents the primary action of a screen.\';\nvar FAB_links = {\n  docs: \'https://github.com/material-components/material-components-web/tree/master/packages/mdc-fab\',\n  guide: \'https://material.io/components/buttons-floating-action-button\'\n};\nfunction FABPage() {\n  var _useState = (0,react.useState)(false),\n      _useState2 = FAB_slicedToArray(_useState, 2),\n      isExited = _useState2[0],\n      setExited = _useState2[1];\n\n  return /*#__PURE__*/(0,jsx_runtime.jsxs)(Page, {\n    id: FAB_id,\n    title: FAB_title,\n    description: FAB_description,\n    links: FAB_links,\n    children: [/*#__PURE__*/(0,jsx_runtime.jsx)(Demo, {\n      title: "Basic FAB",\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(fab_FAB, {\n        icon: "star"\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Demo, {\n      title: "Mini FAB",\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(fab_FAB, {\n        icon: "star",\n        mini: true\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Demo, {\n      title: "Extended FAB",\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(fab_FAB, {\n        icon: "star",\n        label: "Star"\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Demo, {\n      title: "Extended FAB with a trailing icon",\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(fab_FAB, {\n        label: "Star",\n        trailingIcon: "star"\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Demo, {\n      title: "Animated FAB",\n      setup: /*#__PURE__*/(0,jsx_runtime.jsx)(button_Button, {\n        label: "Toggle",\n        onClick: function onClick() {\n          return setExited(function (v) {\n            return !v;\n          });\n        }\n      }),\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(fab_FAB, {\n        icon: "star",\n        exited: isExited\n      })\n    })]\n  });\n}\n;// CONCATENATED MODULE: ./docs/src/pages/FormField/index.jsx\n\n\n\n\n\n\nvar FormField_id = \'form-field\';\nvar FormField_title = \'Form Field\';\nvar FormField_description = \'Form Field aligns a form field (for example, a checkbox) with its label and makes it RTL-aware.\';\nvar FormField_links = {\n  docs: \'https://github.com/material-components/material-components-web/tree/master/packages/mdc-form-field\'\n};\nfunction FormFieldPage() {\n  return /*#__PURE__*/(0,jsx_runtime.jsxs)(Page, {\n    id: FormField_id,\n    title: FormField_title,\n    description: FormField_description,\n    links: FormField_links,\n    children: [/*#__PURE__*/(0,jsx_runtime.jsx)(Demo, {\n      title: "Basic form field",\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(form_field_FormField, {\n        label: "Label",\n        children: /*#__PURE__*/(0,jsx_runtime.jsx)(checkbox_Checkbox, {})\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Demo, {\n      title: "Form field that goes before the element",\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(form_field_FormField, {\n        label: "Label",\n        alignEnd: true,\n        children: /*#__PURE__*/(0,jsx_runtime.jsx)(checkbox_Checkbox, {})\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Demo, {\n      title: "No wrap form field",\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(form_field_FormField, {\n        label: "Label",\n        nowrap: true,\n        children: /*#__PURE__*/(0,jsx_runtime.jsx)(checkbox_Checkbox, {})\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Demo, {\n      title: "Form field with space between",\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(form_field_FormField, {\n        label: "Label",\n        spaceBetween: true,\n        children: /*#__PURE__*/(0,jsx_runtime.jsx)(checkbox_Checkbox, {})\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Demo, {\n      title: "Block form field",\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(form_field_FormField, {\n        label: "Label",\n        block: true,\n        children: /*#__PURE__*/(0,jsx_runtime.jsx)(checkbox_Checkbox, {})\n      })\n    })]\n  });\n}\n// EXTERNAL MODULE: ./node_modules/marked/lib/marked.js\nvar marked = __webpack_require__(84);\nvar marked_default = /*#__PURE__*/__webpack_require__.n(marked);\n;// CONCATENATED MODULE: ./docs/src/utils/markdown.js\n\n\nmarked_default().setOptions({\n  highlight: highlight,\n  langPrefix: \'hljs language-\'\n});\n/* harmony default export */ const markdown = ((marked_default()));\n;// CONCATENATED MODULE: ./package.json\nconst package_namespaceObject = JSON.parse(\'{"i8":"1.0.0-beta.9"}\');\n;// CONCATENATED MODULE: ./README.md\nconst README_namespaceObject = "# MDC React\\r\\n\\r\\n[Material Components Web](https://github.com/material-components/material-components-web) implemented in React.\\r\\n\\r\\n## Setup\\r\\n\\r\\nInstall the library using npm:\\r\\n\\r\\n```sh\\r\\nnpm i mdc-react\\r\\n```\\r\\n\\r\\nIf you plan on using the Sass files, you\'ll also need to install `sass`:\\r\\n\\r\\n```sh\\r\\nnpm i -D sass\\r\\n```\\r\\n\\r\\n> **NOTE**: MDC React (as well as MDC Web) uses the new [Sass Module System](https://sass-lang.com/blog/the-module-system-is-launched). Unfortunately at this time the `node-sass` implementation does not support it. Please use the `sass` library.\\r\\n\\r\\n### Icons\\r\\n\\r\\nTo use [Material Icons](https://fonts.google.com/icons?icon.set=Material+Icons) include them in your HTML:\\r\\n\\r\\n```html\\r\\n<link href=\\"https://fonts.googleapis.com/css2?family=Material+Icons\\" rel=\\"stylesheet\\">\\r\\n```\\r\\n\\r\\n### Symbols (NEW)\\r\\n\\r\\nTo use [Material Symbols](https://fonts.google.com/icons?icon.set=Material+Symbols) include them in your HTML:\\r\\n\\r\\n```html\\r\\n<link href=\\"https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined\\" rel=\\"stylesheet\\">\\r\\n```\\r\\n\\r\\nThe above snippet includes the default configuration for each <a href=\\"https://fonts.google.com/knowledge/glossary/axis_in_variable_fonts\\" target=\\"_blank\\" class=\\"external\\">axis</a>, with <a href=\\"https://fonts.google.com/knowledge/glossary/weight_axis\\" target=\\"_blank\\" class=\\"external\\">weight</a> at 400, <a href=\\"https://fonts.google.com/knowledge/glossary/optical_size_axis\\" target=\\"_blank\\" class=\\"external\\">optical size</a> at 48, <a href=\\"https://fonts.google.com/knowledge/glossary/grade_axis\\" target=\\"_blank\\" class=\\"external\\">grade</a> at 0 and <a href=\\"https://fonts.google.com/knowledge/glossary/fill_axis\\" target=\\"_blank\\" class=\\"external\\">fill</a> (also 0.)\\r\\n\\r\\n> To configure the symbols follow the [developer guide](https://developers.google.com/fonts/docs/material_symbols).\\r\\n\\r\\n## Usage\\r\\n\\r\\n### JS\\r\\n\\r\\nTo use the components just import what you need from the library:\\r\\n\\r\\n```jsx\\r\\nimport { Button } from \'mdc-react\';\\r\\n\\r\\nconst App = () => {\\r\\n    return (\\r\\n        <div>\\r\\n            <Button>Click me!</Button>\\r\\n        </div>\\r\\n    );\\r\\n};\\r\\n```\\r\\n\\r\\nAlternatively you can import only the components you need:\\r\\n\\r\\n```jsx\\r\\nimport Button from \'mdc-react/button\';\\r\\nimport Typography from \'mdc-react/typography\';\\r\\n\\r\\nconst App = () => {\\r\\n    return (\\r\\n        <div>\\r\\n            <Typography>Hello world!</Typography>\\r\\n            <Button>Click me!</Button>\\r\\n        </div>\\r\\n    );\\r\\n};\\r\\n```\\r\\n\\r\\n### Sass\\r\\n\\r\\nYou can use all the styles:\\r\\n\\r\\n```scss\\r\\n@use \'path-to-node_modules/mdc-react\';\\r\\n```\\r\\n\\r\\nor only the ones you need:\\r\\n\\r\\n```scss\\r\\n@use \'path-to-node_modules/mdc-react/src/button\';\\r\\n@use \'path-to-node_modules/mdc-react/src/typography\';\\r\\n```";\n;// CONCATENATED MODULE: ./docs/src/pages/Home/index.jsx\n\n\n\n\n\n\n\n\nvar html = markdown(README_namespaceObject);\nfunction HomePage() {\n  return /*#__PURE__*/(0,jsx_runtime.jsxs)(Page, {\n    id: "home",\n    children: [/*#__PURE__*/(0,jsx_runtime.jsx)(typography_Typography, {\n      type: "overline",\n      children: package_namespaceObject.i8\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)("article", {\n      className: "markdown",\n      dangerouslySetInnerHTML: {\n        __html: html\n      }\n    })]\n  });\n}\n;// CONCATENATED MODULE: ./docs/src/pages/Icon/index.jsx\nfunction Icon_slicedToArray(arr, i) { return Icon_arrayWithHoles(arr) || Icon_iterableToArrayLimit(arr, i) || Icon_unsupportedIterableToArray(arr, i) || Icon_nonIterableRest(); }\n\nfunction Icon_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction Icon_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return Icon_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return Icon_arrayLikeToArray(o, minLen); }\n\nfunction Icon_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction Icon_iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction Icon_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\n\n\n\n\n\n\n\n\n\nvar Icon_id = \'icon\';\nvar Icon_title = \'Icon\';\nvar Icon_description = \'Material design system icons are simple, modern, friendly, and sometimes quirky. Each icon is created using our design guidelines to depict in simple and minimal forms the universal concepts used commonly throughout a UI.\';\nvar Icon_links = {\n  docs: \'https://developers.google.com/fonts/docs/material_icons\',\n  guide: \'https://material.io/design/iconography\'\n};\nfunction IconPage() {\n  var _useState = (0,react.useState)(\'flag\'),\n      _useState2 = Icon_slicedToArray(_useState, 2),\n      name = _useState2[0],\n      setName = _useState2[1];\n\n  var _useState3 = (0,react.useState)(\'\'),\n      _useState4 = Icon_slicedToArray(_useState3, 2),\n      size = _useState4[0],\n      setSize = _useState4[1];\n\n  var _useState5 = (0,react.useState)(\'\'),\n      _useState6 = Icon_slicedToArray(_useState5, 2),\n      type = _useState6[0],\n      setType = _useState6[1];\n\n  var _useState7 = (0,react.useState)(\'\'),\n      _useState8 = Icon_slicedToArray(_useState7, 2),\n      tone = _useState8[0],\n      setTone = _useState8[1];\n\n  var _useState9 = (0,react.useState)(false),\n      _useState10 = Icon_slicedToArray(_useState9, 2),\n      inactive = _useState10[0],\n      setInactive = _useState10[1];\n\n  return /*#__PURE__*/(0,jsx_runtime.jsx)(Page, {\n    id: Icon_id,\n    title: Icon_title,\n    description: Icon_description,\n    links: Icon_links,\n    children: /*#__PURE__*/(0,jsx_runtime.jsx)(Demo, {\n      title: "Demo",\n      settings: /*#__PURE__*/(0,jsx_runtime.jsxs)(jsx_runtime.Fragment, {\n        children: [/*#__PURE__*/(0,jsx_runtime.jsx)(text_field_TextField, {\n          value: name,\n          label: "Label",\n          outlined: true,\n          onChange: function onChange(_, value) {\n            return setName(value);\n          }\n        }), /*#__PURE__*/(0,jsx_runtime.jsx)(FieldSet, {\n          legend: "Type",\n          children: /*#__PURE__*/(0,jsx_runtime.jsx)(segmented_button_SegmentedButton, {\n            segments: [{\n              value: \'filled\',\n              label: \'Filled\'\n            }, {\n              value: \'outlined\',\n              label: \'Outlined\'\n            }, {\n              value: \'round\',\n              label: \'Round\'\n            }, {\n              value: \'sharp\',\n              label: \'Sharp\'\n            }, {\n              value: \'two-tone\',\n              label: \'Two Tone\'\n            }],\n            value: type,\n            onChange: setType\n          })\n        }), /*#__PURE__*/(0,jsx_runtime.jsx)(FieldSet, {\n          legend: "Size",\n          children: /*#__PURE__*/(0,jsx_runtime.jsx)(segmented_button_SegmentedButton, {\n            segments: [{\n              value: \'smaller\',\n              label: \'Smaller\'\n            }, {\n              value: \'small\',\n              label: \'Small\'\n            }, {\n              value: \'medium\',\n              label: \'Medium\'\n            }, {\n              value: \'large\',\n              label: \'Large\'\n            }, {\n              value: \'larger\',\n              label: \'Larger\'\n            }],\n            value: size,\n            onChange: setSize\n          })\n        }), /*#__PURE__*/(0,jsx_runtime.jsx)(FieldSet, {\n          legend: "Tone",\n          children: /*#__PURE__*/(0,jsx_runtime.jsx)(segmented_button_SegmentedButton, {\n            segments: [{\n              value: \'\',\n              label: \'None\'\n            }, {\n              value: \'light\',\n              label: \'Light\'\n            }, {\n              value: \'dark\',\n              label: \'Dark\'\n            }],\n            value: tone,\n            onChange: setTone\n          })\n        }), /*#__PURE__*/(0,jsx_runtime.jsx)(form_field_FormField, {\n          label: "Inactive",\n          alignEnd: true,\n          spaceBetween: true,\n          children: /*#__PURE__*/(0,jsx_runtime.jsx)(switch_Switch, {\n            selected: inactive,\n            onChange: function onChange() {\n              return setInactive(function (v) {\n                return !v;\n              });\n            }\n          })\n        })]\n      }),\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(icon_Icon, {\n        name: name,\n        type: type,\n        size: size,\n        light: tone === \'light\',\n        dark: tone === \'dark\',\n        inactive: inactive\n      })\n    })\n  });\n}\n;// CONCATENATED MODULE: ./docs/src/pages/IconButton/index.jsx\nfunction IconButton_slicedToArray(arr, i) { return IconButton_arrayWithHoles(arr) || IconButton_iterableToArrayLimit(arr, i) || IconButton_unsupportedIterableToArray(arr, i) || IconButton_nonIterableRest(); }\n\nfunction IconButton_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction IconButton_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return IconButton_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return IconButton_arrayLikeToArray(o, minLen); }\n\nfunction IconButton_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction IconButton_iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction IconButton_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\n\n\n\n\n\n\n\nvar IconButton_id = \'icon-button\';\nvar IconButton_title = \'Icon Button\';\nvar IconButton_description = \'Icon buttons allow users to take actions, and make choices, with a single tap.\';\nvar IconButton_links = {\n  docs: \'https://github.com/material-components/material-components-web/tree/master/packages/mdc-icon-button\',\n  guide: \'https://material.io/components/buttons\'\n};\nfunction IconButtonPage() {\n  var _useState = (0,react.useState)(true),\n      _useState2 = IconButton_slicedToArray(_useState, 2),\n      isOn = _useState2[0],\n      setOn = _useState2[1];\n\n  return /*#__PURE__*/(0,jsx_runtime.jsxs)(Page, {\n    id: IconButton_id,\n    title: IconButton_title,\n    description: IconButton_description,\n    links: IconButton_links,\n    children: [/*#__PURE__*/(0,jsx_runtime.jsx)(Demo, {\n      title: "Basic icon button",\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(icon_button_IconButton, {\n        icon: "flag"\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Demo, {\n      title: "Toggling icon button",\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(icon_button_IconButton, {\n        icon: isOn ? \'favorite\' : \'favorite_outlined\',\n        onClick: function onClick() {\n          return setOn(function (v) {\n            return !v;\n          });\n        }\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Demo, {\n      title: "With a symbol",\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(icon_button_IconButton, {\n        icon: /*#__PURE__*/(0,jsx_runtime.jsx)(symbol_Symbol, {\n          children: "flag"\n        })\n      })\n    })]\n  });\n}\n;// CONCATENATED MODULE: ./docs/src/pages/ImageList/index.jsx\nfunction pages_ImageList_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction pages_ImageList_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { pages_ImageList_ownKeys(Object(source), true).forEach(function (key) { pages_ImageList_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { pages_ImageList_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction pages_ImageList_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n\nvar ImageList_id = \'image-list\';\nvar ImageList_title = \'Image List\';\nvar ImageList_description = \'Image lists display a collection of images in an organized grid.\';\nvar ImageList_links = {\n  docs: \'https://github.com/material-components/material-components-web/tree/master/packages/mdc-image-list\',\n  guide: \'https://material.io/components/image-lists\'\n};\n\n\n\n\n\nvar standardItems = new Array(15).fill(1).map(function () {\n  return {\n    imageSrc: \'https://placeimg.com/360/360/any\',\n    label: \'Text Label\'\n  };\n});\nvar masonryItems = new Array(15).fill(1).map(function () {\n  return {\n    imageSrc: "https://placeimg.com/".concat(Math.random() > 0.5 ? \'480/360\' : \'360/480\', "/any"),\n    label: \'Text Label\'\n  };\n});\nfunction ImageListPage() {\n  return /*#__PURE__*/(0,jsx_runtime.jsxs)(Page, {\n    id: ImageList_id,\n    title: ImageList_title,\n    description: ImageList_description,\n    links: ImageList_links,\n    children: [/*#__PURE__*/(0,jsx_runtime.jsx)(Demo, {\n      id: "standard-image-list",\n      title: "Standard Image List",\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(image_list_ImageList, {\n        children: standardItems.map(function (item, index) {\n          return /*#__PURE__*/(0,jsx_runtime.jsx)(image_list_ImageList.Item, pages_ImageList_objectSpread({}, item), index);\n        })\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Demo, {\n      id: "standard-image-list",\n      title: "Standard Image List with Text Protection",\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(image_list_ImageList, {\n        withTextProtection: true,\n        children: standardItems.map(function (item, index) {\n          return /*#__PURE__*/(0,jsx_runtime.jsx)(image_list_ImageList.Item, pages_ImageList_objectSpread({}, item), index);\n        })\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Demo, {\n      id: "masonry-image-list",\n      title: "Masonry Image List",\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(image_list_ImageList, {\n        masonry: true,\n        children: masonryItems.map(function (item, index) {\n          return /*#__PURE__*/(0,jsx_runtime.jsx)(image_list_ImageList.Item, pages_ImageList_objectSpread({}, item), index);\n        })\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Demo, {\n      id: "masonry-image-list",\n      title: "Masonry Image List with Text Protection",\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(image_list_ImageList, {\n        masonry: true,\n        withTextProtection: true,\n        children: masonryItems.map(function (item, index) {\n          return /*#__PURE__*/(0,jsx_runtime.jsx)(image_list_ImageList.Item, pages_ImageList_objectSpread({}, item), index);\n        })\n      })\n    })]\n  });\n}\n;// CONCATENATED MODULE: ./docs/src/pages/LayoutGrid/index.jsx\n\n\n\n\n\n\nvar LayoutGrid_id = \'layout-grid\';\nvar LayoutGrid_title = \'Layout Grid\';\nvar LayoutGrid_description = \'Material designs responsive UI is based on a 12-column grid layout.\';\nvar LayoutGrid_links = {\n  docs: \'https://github.com/material-components/material-components-web/tree/master/packages/mdc-layout-grid\',\n  guide: \'https://material.io/design/layout/responsive-layout-grid.html\'\n};\nfunction LayoutGridPage() {\n  return /*#__PURE__*/(0,jsx_runtime.jsxs)(Page, {\n    id: LayoutGrid_id,\n    title: LayoutGrid_title,\n    description: LayoutGrid_description,\n    links: LayoutGrid_links,\n    children: [/*#__PURE__*/(0,jsx_runtime.jsx)(Demo, {\n      title: "Basic grid",\n      children: /*#__PURE__*/(0,jsx_runtime.jsxs)(layout_grid_LayoutGrid, {\n        children: [/*#__PURE__*/(0,jsx_runtime.jsx)(layout_grid_LayoutGrid.Cell, {\n          span: "6"\n        }), /*#__PURE__*/(0,jsx_runtime.jsx)(layout_grid_LayoutGrid.Cell, {\n          span: "3"\n        }), /*#__PURE__*/(0,jsx_runtime.jsx)(layout_grid_LayoutGrid.Cell, {\n          span: "2"\n        }), /*#__PURE__*/(0,jsx_runtime.jsx)(layout_grid_LayoutGrid.Cell, {\n          span: "1"\n        }), /*#__PURE__*/(0,jsx_runtime.jsx)(layout_grid_LayoutGrid.Cell, {\n          span: "3"\n        }), /*#__PURE__*/(0,jsx_runtime.jsx)(layout_grid_LayoutGrid.Cell, {\n          span: "1"\n        }), /*#__PURE__*/(0,jsx_runtime.jsx)(layout_grid_LayoutGrid.Cell, {\n          span: "8"\n        })]\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Demo, {\n      title: "Nested grid",\n      children: /*#__PURE__*/(0,jsx_runtime.jsxs)(layout_grid_LayoutGrid, {\n        children: [/*#__PURE__*/(0,jsx_runtime.jsxs)(layout_grid_LayoutGrid.Cell, {\n          grid: true,\n          children: [/*#__PURE__*/(0,jsx_runtime.jsx)(layout_grid_LayoutGrid.Cell, {}), /*#__PURE__*/(0,jsx_runtime.jsx)(layout_grid_LayoutGrid.Cell, {}), /*#__PURE__*/(0,jsx_runtime.jsx)(layout_grid_LayoutGrid.Cell, {})]\n        }), /*#__PURE__*/(0,jsx_runtime.jsx)(layout_grid_LayoutGrid.Cell, {}), /*#__PURE__*/(0,jsx_runtime.jsx)(layout_grid_LayoutGrid.Cell, {})]\n      })\n    })]\n  });\n}\n;// CONCATENATED MODULE: ./docs/src/pages/LinearProgress/index.jsx\nfunction LinearProgress_slicedToArray(arr, i) { return LinearProgress_arrayWithHoles(arr) || LinearProgress_iterableToArrayLimit(arr, i) || LinearProgress_unsupportedIterableToArray(arr, i) || LinearProgress_nonIterableRest(); }\n\nfunction LinearProgress_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction LinearProgress_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return LinearProgress_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return LinearProgress_arrayLikeToArray(o, minLen); }\n\nfunction LinearProgress_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction LinearProgress_iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction LinearProgress_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\n\n\n\n\n\n\nvar LinearProgress_id = \'linear-progress\';\nvar LinearProgress_title = \'Linear Progress\';\nvar LinearProgress_description = \'Progress indicators display the length of a process or express an unspecified wait time.\';\nvar LinearProgress_links = {\n  docs: \'\',\n  guide: \'\'\n};\nfunction LinearProgressPage() {\n  var _useState = (0,react.useState)(true),\n      _useState2 = LinearProgress_slicedToArray(_useState, 2),\n      isClosed = _useState2[0],\n      setClosed = _useState2[1];\n\n  return /*#__PURE__*/(0,jsx_runtime.jsxs)(Page, {\n    id: LinearProgress_id,\n    title: LinearProgress_title,\n    description: LinearProgress_description,\n    links: LinearProgress_links,\n    children: [/*#__PURE__*/(0,jsx_runtime.jsx)(Demo, {\n      title: "Basic linear progress",\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(linear_progress_LinearProgress, {\n        value: "42"\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Demo, {\n      title: "Linear progress with a buffer",\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(linear_progress_LinearProgress, {\n        value: "42",\n        buffer: "84"\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Demo, {\n      title: "Indeterminate linear progress",\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(linear_progress_LinearProgress, {\n        indeterminate: true\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Demo, {\n      title: "Closed linear progress",\n      setup: /*#__PURE__*/(0,jsx_runtime.jsx)(button_Button, {\n        onClick: function onClick() {\n          return setClosed(function (v) {\n            return !v;\n          });\n        },\n        children: "Toggle"\n      }),\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(linear_progress_LinearProgress, {\n        closed: isClosed,\n        value: "42"\n      })\n    })]\n  });\n}\n;// CONCATENATED MODULE: ./docs/src/pages/List/index.jsx\n\n\n\n\n\nvar List_id = \'list\';\nvar List_title = \'List\';\nvar List_description = \'Lists present multiple line items vertically as a single continuous element.\';\nvar List_links = {\n  docs: \'https://github.com/material-components/material-components-web/tree/master/packages/mdc-list\',\n  guide: \'https://material.io/components/lists\'\n};\nfunction ListPage() {\n  return /*#__PURE__*/(0,jsx_runtime.jsxs)(Page, {\n    id: List_id,\n    title: List_title,\n    description: List_description,\n    links: List_links,\n    children: [/*#__PURE__*/(0,jsx_runtime.jsx)(Demo, {\n      title: "Single-line list",\n      children: /*#__PURE__*/(0,jsx_runtime.jsxs)(list_List, {\n        children: [/*#__PURE__*/(0,jsx_runtime.jsx)(list_ListItem, {\n          text: "Item 1"\n        }), /*#__PURE__*/(0,jsx_runtime.jsx)(list_ListItem, {\n          text: "Item 2"\n        }), /*#__PURE__*/(0,jsx_runtime.jsx)(list_ListItem, {\n          text: "Item 3"\n        })]\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsxs)(Demo, {\n      title: "Two-line list",\n      children: [/*#__PURE__*/(0,jsx_runtime.jsxs)(list_List, {\n        children: [/*#__PURE__*/(0,jsx_runtime.jsx)(list_ListItem, {\n          primaryText: "Item 1",\n          secondaryText: "Secondary text"\n        }), /*#__PURE__*/(0,jsx_runtime.jsx)(list_ListItem, {\n          primaryText: "Item 2",\n          secondaryText: "Secondary text"\n        }), /*#__PURE__*/(0,jsx_runtime.jsx)(list_ListItem, {\n          primaryText: "Item 3",\n          secondaryText: "Secondary text"\n        })]\n      }), /*#__PURE__*/(0,jsx_runtime.jsxs)(list_List, {\n        children: [/*#__PURE__*/(0,jsx_runtime.jsx)(list_ListItem, {\n          overlineText: "Overline",\n          primaryText: "Item 1"\n        }), /*#__PURE__*/(0,jsx_runtime.jsx)(list_ListItem, {\n          overlineText: "Overline",\n          primaryText: "Item 2"\n        }), /*#__PURE__*/(0,jsx_runtime.jsx)(list_ListItem, {\n          overlineText: "Overline",\n          primaryText: "Item 3"\n        })]\n      })]\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Demo, {\n      title: "Three-line list",\n      children: /*#__PURE__*/(0,jsx_runtime.jsxs)(list_List, {\n        children: [/*#__PURE__*/(0,jsx_runtime.jsx)(list_ListItem, {\n          overlineText: "Overline",\n          primaryText: "Item 1",\n          secondaryText: "Secondary text"\n        }), /*#__PURE__*/(0,jsx_runtime.jsx)(list_ListItem, {\n          overlineText: "Overline",\n          primaryText: "Item 2",\n          secondaryText: "Secondary text"\n        }), /*#__PURE__*/(0,jsx_runtime.jsx)(list_ListItem, {\n          overlineText: "Overline",\n          primaryText: "Item 3",\n          secondaryText: "Secondary text"\n        })]\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Demo, {\n      title: "List with icons",\n      children: /*#__PURE__*/(0,jsx_runtime.jsxs)(list_List, {\n        children: [/*#__PURE__*/(0,jsx_runtime.jsx)(list_ListItem, {\n          icon: "star",\n          text: "Item 1"\n        }), /*#__PURE__*/(0,jsx_runtime.jsx)(list_ListItem, {\n          icon: "star",\n          text: "Item 2"\n        }), /*#__PURE__*/(0,jsx_runtime.jsx)(list_ListItem, {\n          icon: "star",\n          text: "Item 3"\n        })]\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Demo, {\n      title: "List with images",\n      children: /*#__PURE__*/(0,jsx_runtime.jsxs)(list_List, {\n        children: [/*#__PURE__*/(0,jsx_runtime.jsx)(list_ListItem, {\n          image: /*#__PURE__*/(0,jsx_runtime.jsx)("img", {\n            src: "https://placeimg.com/56/56/any"\n          }),\n          text: "Item 1"\n        }), /*#__PURE__*/(0,jsx_runtime.jsx)(list_ListItem, {\n          image: /*#__PURE__*/(0,jsx_runtime.jsx)("img", {\n            src: "https://placeimg.com/56/56/any"\n          }),\n          text: "Item 2"\n        }), /*#__PURE__*/(0,jsx_runtime.jsx)(list_ListItem, {\n          image: /*#__PURE__*/(0,jsx_runtime.jsx)("img", {\n            src: "https://placeimg.com/56/56/any"\n          }),\n          text: "Item 3"\n        })]\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Demo, {\n      title: "List with thumbnails",\n      children: /*#__PURE__*/(0,jsx_runtime.jsxs)(list_List, {\n        children: [/*#__PURE__*/(0,jsx_runtime.jsx)(list_ListItem, {\n          thumbnail: /*#__PURE__*/(0,jsx_runtime.jsx)("img", {\n            src: "https://placeimg.com/40/40/people"\n          }),\n          text: "Item 1"\n        }), /*#__PURE__*/(0,jsx_runtime.jsx)(list_ListItem, {\n          thumbnail: /*#__PURE__*/(0,jsx_runtime.jsx)("img", {\n            src: "https://placeimg.com/40/40/people"\n          }),\n          text: "Item 2"\n        }), /*#__PURE__*/(0,jsx_runtime.jsx)(list_ListItem, {\n          thumbnail: /*#__PURE__*/(0,jsx_runtime.jsx)("img", {\n            src: "https://placeimg.com/40/40/people"\n          }),\n          text: "Item 3"\n        })]\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Demo, {\n      title: "List with videos",\n      children: /*#__PURE__*/(0,jsx_runtime.jsxs)(list_List, {\n        children: [/*#__PURE__*/(0,jsx_runtime.jsx)(list_ListItem, {\n          video: /*#__PURE__*/(0,jsx_runtime.jsx)("img", {\n            src: "https://placeimg.com/100/56/people"\n          }),\n          text: "Item 1"\n        }), /*#__PURE__*/(0,jsx_runtime.jsx)(list_ListItem, {\n          video: /*#__PURE__*/(0,jsx_runtime.jsx)("img", {\n            src: "https://placeimg.com/100/56/people"\n          }),\n          text: "Item 2"\n        }), /*#__PURE__*/(0,jsx_runtime.jsx)(list_ListItem, {\n          video: /*#__PURE__*/(0,jsx_runtime.jsx)("img", {\n            src: "https://placeimg.com/100/56/people"\n          }),\n          text: "Item 3"\n        })]\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Demo, {\n      title: "List with checkboxes",\n      children: /*#__PURE__*/(0,jsx_runtime.jsxs)(list_List, {\n        children: [/*#__PURE__*/(0,jsx_runtime.jsx)(list_ListItem, {\n          leadingCheckbox: /*#__PURE__*/(0,jsx_runtime.jsx)(checkbox_Checkbox, {\n            defaultChecked: false\n          }),\n          text: "Item 1"\n        }), /*#__PURE__*/(0,jsx_runtime.jsx)(list_ListItem, {\n          leadingCheckbox: /*#__PURE__*/(0,jsx_runtime.jsx)(checkbox_Checkbox, {\n            defaultChecked: false\n          }),\n          text: "Item 2"\n        }), /*#__PURE__*/(0,jsx_runtime.jsx)(list_ListItem, {\n          leadingCheckbox: /*#__PURE__*/(0,jsx_runtime.jsx)(checkbox_Checkbox, {\n            defaultChecked: false\n          }),\n          text: "Item 3"\n        })]\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Demo, {\n      title: "List with radios",\n      children: /*#__PURE__*/(0,jsx_runtime.jsxs)(list_List, {\n        children: [/*#__PURE__*/(0,jsx_runtime.jsx)(list_ListItem, {\n          leadingRadio: /*#__PURE__*/(0,jsx_runtime.jsx)(radio_Radio, {}),\n          text: "Item 1"\n        }), /*#__PURE__*/(0,jsx_runtime.jsx)(list_ListItem, {\n          leadingRadio: /*#__PURE__*/(0,jsx_runtime.jsx)(radio_Radio, {\n            checked: true\n          }),\n          text: "Item 2"\n        }), /*#__PURE__*/(0,jsx_runtime.jsx)(list_ListItem, {\n          leadingRadio: /*#__PURE__*/(0,jsx_runtime.jsx)(radio_Radio, {}),\n          text: "Item 3"\n        })]\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Demo, {\n      title: "List with switches",\n      children: /*#__PURE__*/(0,jsx_runtime.jsxs)(list_List, {\n        children: [/*#__PURE__*/(0,jsx_runtime.jsx)(list_ListItem, {\n          leadingSwitch: /*#__PURE__*/(0,jsx_runtime.jsx)(switch_Switch, {}),\n          text: "Item 1"\n        }), /*#__PURE__*/(0,jsx_runtime.jsx)(list_ListItem, {\n          leadingSwitch: /*#__PURE__*/(0,jsx_runtime.jsx)(switch_Switch, {\n            checked: true\n          }),\n          text: "Item 2"\n        }), /*#__PURE__*/(0,jsx_runtime.jsx)(list_ListItem, {\n          leadingSwitch: /*#__PURE__*/(0,jsx_runtime.jsx)(switch_Switch, {}),\n          text: "Item 3"\n        })]\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Demo, {\n      title: "List with trailing icons",\n      children: /*#__PURE__*/(0,jsx_runtime.jsxs)(list_List, {\n        children: [/*#__PURE__*/(0,jsx_runtime.jsx)(list_ListItem, {\n          text: "Item 1",\n          trailingIcon: "info"\n        }), /*#__PURE__*/(0,jsx_runtime.jsx)(list_ListItem, {\n          text: "Item 2",\n          trailingIcon: "info"\n        }), /*#__PURE__*/(0,jsx_runtime.jsx)(list_ListItem, {\n          text: "Item 3",\n          trailingIcon: "info"\n        })]\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Demo, {\n      title: "List with trailing meta",\n      children: /*#__PURE__*/(0,jsx_runtime.jsxs)(list_List, {\n        children: [/*#__PURE__*/(0,jsx_runtime.jsx)(list_ListItem, {\n          text: "Item 1",\n          meta: "Meta"\n        }), /*#__PURE__*/(0,jsx_runtime.jsx)(list_ListItem, {\n          text: "Item 2",\n          meta: "Meta"\n        }), /*#__PURE__*/(0,jsx_runtime.jsx)(list_ListItem, {\n          text: "Item 3",\n          meta: "Meta"\n        })]\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Demo, {\n      title: "List with trailing checkboxes",\n      children: /*#__PURE__*/(0,jsx_runtime.jsxs)(list_List, {\n        children: [/*#__PURE__*/(0,jsx_runtime.jsx)(list_ListItem, {\n          text: "Item 1",\n          trailingCheckbox: /*#__PURE__*/(0,jsx_runtime.jsx)(checkbox_Checkbox, {})\n        }), /*#__PURE__*/(0,jsx_runtime.jsx)(list_ListItem, {\n          text: "Item 2",\n          trailingCheckbox: /*#__PURE__*/(0,jsx_runtime.jsx)(checkbox_Checkbox, {\n            checked: true\n          })\n        }), /*#__PURE__*/(0,jsx_runtime.jsx)(list_ListItem, {\n          text: "Item 3",\n          trailingCheckbox: /*#__PURE__*/(0,jsx_runtime.jsx)(checkbox_Checkbox, {})\n        })]\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Demo, {\n      title: "List with trailing radios",\n      children: /*#__PURE__*/(0,jsx_runtime.jsxs)(list_List, {\n        children: [/*#__PURE__*/(0,jsx_runtime.jsx)(list_ListItem, {\n          text: "Item 1",\n          trailingRadio: /*#__PURE__*/(0,jsx_runtime.jsx)(radio_Radio, {})\n        }), /*#__PURE__*/(0,jsx_runtime.jsx)(list_ListItem, {\n          text: "Item 2",\n          trailingRadio: /*#__PURE__*/(0,jsx_runtime.jsx)(radio_Radio, {\n            checked: true\n          })\n        }), /*#__PURE__*/(0,jsx_runtime.jsx)(list_ListItem, {\n          text: "Item 3",\n          trailingRadio: /*#__PURE__*/(0,jsx_runtime.jsx)(radio_Radio, {})\n        })]\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Demo, {\n      title: "List with trailing switches",\n      children: /*#__PURE__*/(0,jsx_runtime.jsxs)(list_List, {\n        children: [/*#__PURE__*/(0,jsx_runtime.jsx)(list_ListItem, {\n          text: "Item 1",\n          trailingSwitch: /*#__PURE__*/(0,jsx_runtime.jsx)(switch_Switch, {})\n        }), /*#__PURE__*/(0,jsx_runtime.jsx)(list_ListItem, {\n          text: "Item 2",\n          trailingSwitch: /*#__PURE__*/(0,jsx_runtime.jsx)(switch_Switch, {\n            selected: true\n          })\n        }), /*#__PURE__*/(0,jsx_runtime.jsx)(list_ListItem, {\n          text: "Item 3",\n          trailingSwitch: /*#__PURE__*/(0,jsx_runtime.jsx)(switch_Switch, {})\n        })]\n      })\n    })]\n  });\n}\n;// CONCATENATED MODULE: ./docs/src/pages/Menu/index.jsx\nfunction pages_Menu_slicedToArray(arr, i) { return pages_Menu_arrayWithHoles(arr) || pages_Menu_iterableToArrayLimit(arr, i) || pages_Menu_unsupportedIterableToArray(arr, i) || pages_Menu_nonIterableRest(); }\n\nfunction pages_Menu_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction pages_Menu_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return pages_Menu_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return pages_Menu_arrayLikeToArray(o, minLen); }\n\nfunction pages_Menu_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction pages_Menu_iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction pages_Menu_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\n\n\n\n\n\n\n\n\n\nvar Menu_id = \'menu\';\nvar Menu_title = \'Menu\';\nvar Menu_description = \'Menus display a list of choices on temporary surfaces.\';\nvar Menu_links = {\n  docs: \'https://github.com/material-components/material-components-web/tree/master/packages/mdc-menu\',\n  guide: \'https://material.io/components/menus\'\n};\nfunction MenuPage() {\n  var _useState = (0,react.useState)(false),\n      _useState2 = pages_Menu_slicedToArray(_useState, 2),\n      isBasicOpen = _useState2[0],\n      setBasicOpen = _useState2[1];\n\n  var _useState3 = (0,react.useState)(false),\n      _useState4 = pages_Menu_slicedToArray(_useState3, 2),\n      isQuickOpen = _useState4[0],\n      setQuickOpen = _useState4[1];\n\n  var _useState5 = (0,react.useState)(false),\n      _useState6 = pages_Menu_slicedToArray(_useState5, 2),\n      isPersistentOpen = _useState6[0],\n      setPersistentOpen = _useState6[1];\n\n  var _useState7 = (0,react.useState)(false),\n      _useState8 = pages_Menu_slicedToArray(_useState7, 2),\n      isAnchoredOpen = _useState8[0],\n      setAnchoredOpen = _useState8[1];\n\n  var _useState9 = (0,react.useState)(menu_Menu.Origin.TOP_LEFT),\n      _useState10 = pages_Menu_slicedToArray(_useState9, 2),\n      anchorPosition = _useState10[0],\n      setAnchorPosition = _useState10[1];\n\n  var _useState11 = (0,react.useState)(menu_Menu.Origin.TOP_LEFT),\n      _useState12 = pages_Menu_slicedToArray(_useState11, 2),\n      anchorOrigin = _useState12[0],\n      setAnchorOrigin = _useState12[1];\n\n  var _useState13 = (0,react.useState)(menu_Menu.Origin.TOP_LEFT),\n      _useState14 = pages_Menu_slicedToArray(_useState13, 2),\n      transformOrigin = _useState14[0],\n      setTransformOrigin = _useState14[1];\n\n  var _useState15 = (0,react.useState)(false),\n      _useState16 = pages_Menu_slicedToArray(_useState15, 2),\n      isModalOpen = _useState16[0],\n      setModalOpen = _useState16[1];\n\n  var _useState17 = (0,react.useState)(false),\n      _useState18 = pages_Menu_slicedToArray(_useState17, 2),\n      isDialogOpen = _useState18[0],\n      setDialogOpen = _useState18[1];\n\n  var handleAnchorPositionChange = (0,react.useCallback)(function (event, value) {\n    setAnchorPosition(value);\n  }, []);\n  var handleAnchorOriginChange = (0,react.useCallback)(function (event, value) {\n    setAnchorOrigin(value);\n  }, []);\n  var handleTransformOriginChange = (0,react.useCallback)(function (event, value) {\n    setTransformOrigin(value);\n  }, []);\n  return /*#__PURE__*/(0,jsx_runtime.jsxs)(Page, {\n    id: Menu_id,\n    title: Menu_title,\n    description: Menu_description,\n    links: Menu_links,\n    children: [/*#__PURE__*/(0,jsx_runtime.jsx)(Demo, {\n      title: "Basic menu",\n      children: /*#__PURE__*/(0,jsx_runtime.jsxs)(menu_Menu, {\n        anchor: /*#__PURE__*/(0,jsx_runtime.jsx)(button_Button, {\n          label: "Open",\n          outlined: true,\n          onClick: function onClick() {\n            return setBasicOpen(true);\n          }\n        }),\n        open: isBasicOpen,\n        onClose: function onClose() {\n          setBasicOpen(false);\n        },\n        children: [/*#__PURE__*/(0,jsx_runtime.jsx)(menu_Menu.Item, {\n          text: "Foo"\n        }), /*#__PURE__*/(0,jsx_runtime.jsx)(menu_Menu.Item, {\n          text: "Bar"\n        }), /*#__PURE__*/(0,jsx_runtime.jsx)(menu_Menu.Item, {\n          text: "Baz"\n        })]\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Demo, {\n      title: "Quick menu",\n      children: /*#__PURE__*/(0,jsx_runtime.jsxs)(menu_Menu, {\n        anchor: /*#__PURE__*/(0,jsx_runtime.jsx)(button_Button, {\n          label: "Open",\n          outlined: true,\n          onClick: function onClick() {\n            return setQuickOpen(true);\n          }\n        }),\n        open: isQuickOpen,\n        quick: true,\n        onClose: function onClose() {\n          setQuickOpen(false);\n        },\n        children: [/*#__PURE__*/(0,jsx_runtime.jsx)(menu_Menu.Item, {\n          text: "Foo"\n        }), /*#__PURE__*/(0,jsx_runtime.jsx)(menu_Menu.Item, {\n          text: "Bar"\n        }), /*#__PURE__*/(0,jsx_runtime.jsx)(menu_Menu.Item, {\n          text: "Baz"\n        })]\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Demo, {\n      title: "Persistent menu",\n      children: /*#__PURE__*/(0,jsx_runtime.jsxs)(menu_Menu, {\n        anchor: /*#__PURE__*/(0,jsx_runtime.jsx)(button_Button, {\n          label: "Open",\n          outlined: true,\n          onClick: function onClick() {\n            return setPersistentOpen(function (v) {\n              return !v;\n            });\n          }\n        }),\n        open: isPersistentOpen,\n        persistent: true,\n        children: [/*#__PURE__*/(0,jsx_runtime.jsx)(menu_Menu.Item, {\n          text: "Foo",\n          onClick: function onClick() {\n            return setPersistentOpen(false);\n          }\n        }), /*#__PURE__*/(0,jsx_runtime.jsx)(menu_Menu.Item, {\n          text: "Bar",\n          onClick: function onClick() {\n            return setPersistentOpen(false);\n          }\n        }), /*#__PURE__*/(0,jsx_runtime.jsx)(menu_Menu.Item, {\n          text: "Baz",\n          onClick: function onClick() {\n            return setPersistentOpen(false);\n          }\n        })]\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Demo, {\n      id: "menu-origin",\n      className: "origin--".concat(anchorPosition.replace(\' \', \'-\')),\n      title: "Menu origin",\n      settings: /*#__PURE__*/(0,jsx_runtime.jsxs)(jsx_runtime.Fragment, {\n        children: [/*#__PURE__*/(0,jsx_runtime.jsxs)(FieldSet, {\n          legend: "Anchor position",\n          children: [/*#__PURE__*/(0,jsx_runtime.jsx)(form_field_FormField, {\n            label: "Top left",\n            children: /*#__PURE__*/(0,jsx_runtime.jsx)(radio_Radio, {\n              value: menu_Menu.Origin.TOP_LEFT,\n              checked: anchorPosition === menu_Menu.Origin.TOP_LEFT,\n              onChange: handleAnchorPositionChange\n            })\n          }), /*#__PURE__*/(0,jsx_runtime.jsx)(form_field_FormField, {\n            label: "Top right",\n            children: /*#__PURE__*/(0,jsx_runtime.jsx)(radio_Radio, {\n              value: menu_Menu.Origin.TOP_RIGHT,\n              checked: anchorPosition === menu_Menu.Origin.TOP_RIGHT,\n              onChange: handleAnchorPositionChange\n            })\n          }), /*#__PURE__*/(0,jsx_runtime.jsx)(form_field_FormField, {\n            label: "Bottom left",\n            children: /*#__PURE__*/(0,jsx_runtime.jsx)(radio_Radio, {\n              value: menu_Menu.Origin.BOTTOM_LEFT,\n              checked: anchorPosition === menu_Menu.Origin.BOTTOM_LEFT,\n              onChange: handleAnchorPositionChange\n            })\n          }), /*#__PURE__*/(0,jsx_runtime.jsx)(form_field_FormField, {\n            label: "Bottom right",\n            children: /*#__PURE__*/(0,jsx_runtime.jsx)(radio_Radio, {\n              value: menu_Menu.Origin.BOTTOM_RIGHT,\n              checked: anchorPosition === menu_Menu.Origin.BOTTOM_RIGHT,\n              onChange: handleAnchorPositionChange\n            })\n          })]\n        }), /*#__PURE__*/(0,jsx_runtime.jsxs)(FieldSet, {\n          legend: "Anchor origin",\n          children: [/*#__PURE__*/(0,jsx_runtime.jsx)(form_field_FormField, {\n            label: "Top left",\n            children: /*#__PURE__*/(0,jsx_runtime.jsx)(radio_Radio, {\n              value: menu_Menu.Origin.TOP_LEFT,\n              checked: anchorOrigin === menu_Menu.Origin.TOP_LEFT,\n              onChange: handleAnchorOriginChange\n            })\n          }), /*#__PURE__*/(0,jsx_runtime.jsx)(form_field_FormField, {\n            label: "Top right",\n            children: /*#__PURE__*/(0,jsx_runtime.jsx)(radio_Radio, {\n              value: menu_Menu.Origin.TOP_RIGHT,\n              checked: anchorOrigin === menu_Menu.Origin.TOP_RIGHT,\n              onChange: handleAnchorOriginChange\n            })\n          }), /*#__PURE__*/(0,jsx_runtime.jsx)(form_field_FormField, {\n            label: "Bottom left",\n            children: /*#__PURE__*/(0,jsx_runtime.jsx)(radio_Radio, {\n              value: menu_Menu.Origin.BOTTOM_LEFT,\n              checked: anchorOrigin === menu_Menu.Origin.BOTTOM_LEFT,\n              onChange: handleAnchorOriginChange\n            })\n          }), /*#__PURE__*/(0,jsx_runtime.jsx)(form_field_FormField, {\n            label: "Bottom right",\n            children: /*#__PURE__*/(0,jsx_runtime.jsx)(radio_Radio, {\n              value: menu_Menu.Origin.BOTTOM_RIGHT,\n              checked: anchorOrigin === menu_Menu.Origin.BOTTOM_RIGHT,\n              onChange: handleAnchorOriginChange\n            })\n          })]\n        }), /*#__PURE__*/(0,jsx_runtime.jsxs)(FieldSet, {\n          legend: "Transform origin",\n          children: [/*#__PURE__*/(0,jsx_runtime.jsx)(form_field_FormField, {\n            label: "Top left",\n            children: /*#__PURE__*/(0,jsx_runtime.jsx)(radio_Radio, {\n              value: menu_Menu.Origin.TOP_LEFT,\n              checked: transformOrigin === menu_Menu.Origin.TOP_LEFT,\n              onChange: handleTransformOriginChange\n            })\n          }), /*#__PURE__*/(0,jsx_runtime.jsx)(form_field_FormField, {\n            label: "Top right",\n            children: /*#__PURE__*/(0,jsx_runtime.jsx)(radio_Radio, {\n              value: menu_Menu.Origin.TOP_RIGHT,\n              checked: transformOrigin === menu_Menu.Origin.TOP_RIGHT,\n              onChange: handleTransformOriginChange\n            })\n          }), /*#__PURE__*/(0,jsx_runtime.jsx)(form_field_FormField, {\n            label: "Bottom left",\n            children: /*#__PURE__*/(0,jsx_runtime.jsx)(radio_Radio, {\n              value: menu_Menu.Origin.BOTTOM_LEFT,\n              checked: transformOrigin === menu_Menu.Origin.BOTTOM_LEFT,\n              onChange: handleTransformOriginChange\n            })\n          }), /*#__PURE__*/(0,jsx_runtime.jsx)(form_field_FormField, {\n            label: "Bottom right",\n            children: /*#__PURE__*/(0,jsx_runtime.jsx)(radio_Radio, {\n              value: menu_Menu.Origin.BOTTOM_RIGHT,\n              checked: transformOrigin === menu_Menu.Origin.BOTTOM_RIGHT,\n              onChange: handleTransformOriginChange\n            })\n          })]\n        })]\n      }),\n      children: /*#__PURE__*/(0,jsx_runtime.jsxs)(menu_Menu, {\n        anchor: /*#__PURE__*/(0,jsx_runtime.jsx)(button_Button, {\n          label: isPersistentOpen ? \'Close\' : \'Open\',\n          outlined: true,\n          onClick: function onClick() {\n            return setAnchoredOpen(function (v) {\n              return !v;\n            });\n          }\n        }),\n        anchorOrigin: anchorOrigin,\n        transformOrigin: transformOrigin,\n        open: isAnchoredOpen,\n        onClose: function onClose() {\n          setAnchoredOpen(false);\n        },\n        children: [/*#__PURE__*/(0,jsx_runtime.jsx)(menu_Menu.Item, {\n          text: "Foo"\n        }), /*#__PURE__*/(0,jsx_runtime.jsx)(menu_Menu.Item, {\n          text: "Bar"\n        }), /*#__PURE__*/(0,jsx_runtime.jsx)(menu_Menu.Item, {\n          text: "Baz"\n        })]\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Demo, {\n      title: "Modal menu",\n      setup: /*#__PURE__*/(0,jsx_runtime.jsx)(button_Button, {\n        onClick: function onClick() {\n          return setDialogOpen(function (v) {\n            return !v;\n          });\n        },\n        children: "Open Dialog"\n      }),\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(dialog_Dialog, {\n        title: "Dialog",\n        open: isDialogOpen,\n        onClose: function onClose() {\n          return setDialogOpen(function (v) {\n            return !v;\n          });\n        },\n        children: /*#__PURE__*/(0,jsx_runtime.jsx)(dialog_Dialog.Content, {\n          children: /*#__PURE__*/(0,jsx_runtime.jsxs)(menu_Menu, {\n            anchor: /*#__PURE__*/(0,jsx_runtime.jsx)(button_Button, {\n              label: isPersistentOpen ? \'Close\' : \'Open\',\n              outlined: true,\n              onClick: function onClick() {\n                return setModalOpen(function (v) {\n                  return !v;\n                });\n              }\n            }),\n            open: isModalOpen,\n            modal: true,\n            onClose: function onClose() {\n              setModalOpen(false);\n            },\n            children: [/*#__PURE__*/(0,jsx_runtime.jsx)(menu_Menu.Item, {\n              text: "Foo"\n            }), /*#__PURE__*/(0,jsx_runtime.jsx)(menu_Menu.Item, {\n              text: "Bar"\n            }), /*#__PURE__*/(0,jsx_runtime.jsx)(menu_Menu.Item, {\n              text: "Baz"\n            })]\n          })\n        })\n      })\n    })]\n  });\n}\n;// CONCATENATED MODULE: ./docs/src/pages/Radio/index.jsx\nfunction Radio_slicedToArray(arr, i) { return Radio_arrayWithHoles(arr) || Radio_iterableToArrayLimit(arr, i) || Radio_unsupportedIterableToArray(arr, i) || Radio_nonIterableRest(); }\n\nfunction Radio_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction Radio_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return Radio_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return Radio_arrayLikeToArray(o, minLen); }\n\nfunction Radio_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction Radio_iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction Radio_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\n\n\n\n\n\n\nvar Radio_id = \'radio\';\nvar Radio_title = \'Radio\';\nvar Radio_description = \'Radio buttons allow users to select one option from a set.\';\nvar Radio_links = {\n  docs: \'https://github.com/material-components/material-components-web/tree/master/packages/mdc-radio\',\n  guide: \'https://material.io/components/radio-buttons\'\n};\nfunction RadioPage() {\n  var _useState = (0,react.useState)(\'yes\'),\n      _useState2 = Radio_slicedToArray(_useState, 2),\n      value1 = _useState2[0],\n      setValue1 = _useState2[1];\n\n  var _useState3 = (0,react.useState)(\'yes\'),\n      _useState4 = Radio_slicedToArray(_useState3, 2),\n      value2 = _useState4[0],\n      setValue2 = _useState4[1];\n\n  var handleChange1 = (0,react.useCallback)(function (event, value) {\n    setValue1(value);\n  }, []);\n  var handleChange2 = (0,react.useCallback)(function (event, value) {\n    setValue2(value);\n  }, []);\n  return /*#__PURE__*/(0,jsx_runtime.jsxs)(Page, {\n    id: Radio_id,\n    title: Radio_title,\n    description: Radio_description,\n    links: Radio_links,\n    children: [/*#__PURE__*/(0,jsx_runtime.jsxs)(Demo, {\n      title: "Basic radio",\n      children: [/*#__PURE__*/(0,jsx_runtime.jsx)(form_field_FormField, {\n        label: "Yes",\n        children: /*#__PURE__*/(0,jsx_runtime.jsx)(radio_Radio, {\n          name: "answer1",\n          value: "yes",\n          checked: value1 === \'yes\',\n          onChange: handleChange1\n        })\n      }), /*#__PURE__*/(0,jsx_runtime.jsx)(form_field_FormField, {\n        label: "No",\n        children: /*#__PURE__*/(0,jsx_runtime.jsx)(radio_Radio, {\n          name: "answer1",\n          value: "no",\n          checked: value1 === \'no\',\n          onChange: handleChange1\n        })\n      }), /*#__PURE__*/(0,jsx_runtime.jsx)(form_field_FormField, {\n        label: "Maybe",\n        children: /*#__PURE__*/(0,jsx_runtime.jsx)(radio_Radio, {\n          name: "answer1",\n          value: "maybe",\n          checked: value1 === \'maybe\',\n          onChange: handleChange1\n        })\n      })]\n    }), /*#__PURE__*/(0,jsx_runtime.jsxs)(Demo, {\n      title: "Disabled radio",\n      children: [/*#__PURE__*/(0,jsx_runtime.jsx)(form_field_FormField, {\n        label: "Yes",\n        children: /*#__PURE__*/(0,jsx_runtime.jsx)(radio_Radio, {\n          name: "answer2",\n          value: "yes",\n          checked: value2 === \'yes\',\n          onChange: handleChange2\n        })\n      }), /*#__PURE__*/(0,jsx_runtime.jsx)(form_field_FormField, {\n        label: "No",\n        children: /*#__PURE__*/(0,jsx_runtime.jsx)(radio_Radio, {\n          name: "answer2",\n          value: "no",\n          checked: value2 === \'no\',\n          onChange: handleChange2\n        })\n      }), /*#__PURE__*/(0,jsx_runtime.jsx)(form_field_FormField, {\n        label: "Maybe",\n        children: /*#__PURE__*/(0,jsx_runtime.jsx)(radio_Radio, {\n          name: "answer2",\n          value: "maybe",\n          checked: value2 === \'maybe\',\n          disabled: true,\n          onChange: handleChange2\n        })\n      })]\n    })]\n  });\n}\n;// CONCATENATED MODULE: ./docs/src/pages/Ripple/index.jsx\n\n\n\n\nfunction Ripple_RadioPage() {\n  return /*#__PURE__*/(0,jsx_runtime.jsx)(Page, {\n    title: "Ripple",\n    children: /*#__PURE__*/(0,jsx_runtime.jsx)(Demo, {\n      title: "Basic ripple",\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(elevation_Elevation, {\n        z: "5",\n        children: /*#__PURE__*/(0,jsx_runtime.jsx)(ripple_RippleSurface, {\n          style: {\n            height: \'100px\'\n          }\n        })\n      })\n    })\n  });\n}\n;// CONCATENATED MODULE: ./docs/src/pages/SegmentedButton/index.jsx\nfunction SegmentedButton_slicedToArray(arr, i) { return SegmentedButton_arrayWithHoles(arr) || SegmentedButton_iterableToArrayLimit(arr, i) || SegmentedButton_unsupportedIterableToArray(arr, i) || SegmentedButton_nonIterableRest(); }\n\nfunction SegmentedButton_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction SegmentedButton_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return SegmentedButton_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return SegmentedButton_arrayLikeToArray(o, minLen); }\n\nfunction SegmentedButton_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction SegmentedButton_iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction SegmentedButton_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\n\n\n\n\n\n\nvar SegmentedButton_id = \'segmented-button\';\nvar SegmentedButton_title = \'Segmented Button\';\nvar SegmentedButton_description = \'Segmented buttons allow users to toggle the selected states of grouped buttons.\';\nvar SegmentedButton_links = {\n  docs: \'https://github.com/material-components/material-components-web/tree/master/packages/mdc-segmented-button\',\n  guide: \'https://material.io/components/buttons#toggle-button\'\n};\nfunction SegmentedButtonPage() {\n  var _useState = (0,react.useState)(\'star\'),\n      _useState2 = SegmentedButton_slicedToArray(_useState, 2),\n      value1 = _useState2[0],\n      setValue1 = _useState2[1];\n\n  var _useState3 = (0,react.useState)(\'star\'),\n      _useState4 = SegmentedButton_slicedToArray(_useState3, 2),\n      value2 = _useState4[0],\n      setValue2 = _useState4[1];\n\n  var _useState5 = (0,react.useState)(\'star\'),\n      _useState6 = SegmentedButton_slicedToArray(_useState5, 2),\n      value3 = _useState6[0],\n      setValue3 = _useState6[1];\n\n  return /*#__PURE__*/(0,jsx_runtime.jsxs)(Page, {\n    id: SegmentedButton_id,\n    title: SegmentedButton_title,\n    description: SegmentedButton_description,\n    links: SegmentedButton_links,\n    children: [/*#__PURE__*/(0,jsx_runtime.jsx)(Demo, {\n      title: "Text",\n      children: /*#__PURE__*/(0,jsx_runtime.jsxs)(segmented_button_SegmentedButton, {\n        value: value1,\n        onChange: setValue1,\n        children: [/*#__PURE__*/(0,jsx_runtime.jsx)(segmented_button_SegmentedButton.Segment, {\n          value: "star",\n          label: "star"\n        }), /*#__PURE__*/(0,jsx_runtime.jsx)(segmented_button_SegmentedButton.Segment, {\n          value: "favorite",\n          label: "favorite"\n        })]\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Demo, {\n      title: "Icons",\n      children: /*#__PURE__*/(0,jsx_runtime.jsxs)(segmented_button_SegmentedButton, {\n        value: value2,\n        onChange: setValue2,\n        children: [/*#__PURE__*/(0,jsx_runtime.jsx)(segmented_button_SegmentedButton.Segment, {\n          value: "star",\n          icon: "star"\n        }), /*#__PURE__*/(0,jsx_runtime.jsx)(segmented_button_SegmentedButton.Segment, {\n          value: "favorite",\n          icon: "favorite"\n        })]\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Demo, {\n      title: "Text with Icons",\n      children: /*#__PURE__*/(0,jsx_runtime.jsxs)(segmented_button_SegmentedButton, {\n        value: value3,\n        onChange: setValue3,\n        children: [/*#__PURE__*/(0,jsx_runtime.jsx)(segmented_button_SegmentedButton.Segment, {\n          value: "star",\n          icon: "star",\n          label: "star"\n        }), /*#__PURE__*/(0,jsx_runtime.jsx)(segmented_button_SegmentedButton.Segment, {\n          value: "favorite",\n          icon: "favorite",\n          label: "favorite"\n        })]\n      })\n    })]\n  });\n}\n;// CONCATENATED MODULE: ./docs/src/pages/Select/index.jsx\nfunction pages_Select_slicedToArray(arr, i) { return pages_Select_arrayWithHoles(arr) || pages_Select_iterableToArrayLimit(arr, i) || pages_Select_unsupportedIterableToArray(arr, i) || pages_Select_nonIterableRest(); }\n\nfunction pages_Select_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction pages_Select_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return pages_Select_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return pages_Select_arrayLikeToArray(o, minLen); }\n\nfunction pages_Select_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction pages_Select_iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction pages_Select_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\n\n\n\n\n\n\n\nvar Select_id = \'select\';\nvar Select_title = \'Select\';\nvar Select_description = \'Segmented buttons allow users to toggle the selected states of grouped buttons.\';\nvar Select_links = {\n  docs: \'https://github.com/material-components/material-components-web/tree/master/packages/mdc-select\'\n};\nfunction SelectPage() {\n  var _useState = (0,react.useState)(),\n      _useState2 = pages_Select_slicedToArray(_useState, 2),\n      filled = _useState2[0],\n      setFilled = _useState2[1];\n\n  var _useState3 = (0,react.useState)(),\n      _useState4 = pages_Select_slicedToArray(_useState3, 2),\n      outlined = _useState4[0],\n      setOutlined = _useState4[1];\n\n  var _useState5 = (0,react.useState)(\'foo\'),\n      _useState6 = pages_Select_slicedToArray(_useState5, 2),\n      preselected = _useState6[0],\n      setPreselected = _useState6[1];\n\n  var _useState7 = (0,react.useState)([]),\n      _useState8 = pages_Select_slicedToArray(_useState7, 2),\n      multiple = _useState8[0],\n      setMultiple = _useState8[1];\n\n  var _useState9 = (0,react.useState)(),\n      _useState10 = pages_Select_slicedToArray(_useState9, 2),\n      icon = _useState10[0],\n      setIcon = _useState10[1];\n\n  return /*#__PURE__*/(0,jsx_runtime.jsxs)(Page, {\n    id: Select_id,\n    title: Select_title,\n    description: Select_description,\n    links: Select_links,\n    children: [/*#__PURE__*/(0,jsx_runtime.jsx)(Demo, {\n      title: "Filled select",\n      children: /*#__PURE__*/(0,jsx_runtime.jsxs)(select_Select, {\n        label: "Choose",\n        value: filled,\n        filled: true,\n        onChange: function onChange(event, value) {\n          return setFilled(value);\n        },\n        children: [/*#__PURE__*/(0,jsx_runtime.jsx)(select_Select.Option, {\n          value: "foo",\n          text: "Foo"\n        }), /*#__PURE__*/(0,jsx_runtime.jsx)(select_Select.Option, {\n          value: "bar",\n          text: "Bar"\n        }), /*#__PURE__*/(0,jsx_runtime.jsx)(select_Select.Option, {\n          value: "baz",\n          text: "Baz"\n        })]\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Demo, {\n      title: "Outlined select",\n      children: /*#__PURE__*/(0,jsx_runtime.jsxs)(select_Select, {\n        label: "Choose",\n        value: outlined,\n        outlined: true,\n        onChange: function onChange(event, value) {\n          return setOutlined(value);\n        },\n        children: [/*#__PURE__*/(0,jsx_runtime.jsx)(select_Select.Option, {\n          value: "foo",\n          text: "Foo"\n        }), /*#__PURE__*/(0,jsx_runtime.jsx)(select_Select.Option, {\n          value: "bar",\n          text: "Bar"\n        }), /*#__PURE__*/(0,jsx_runtime.jsx)(select_Select.Option, {\n          value: "baz",\n          text: "Baz"\n        })]\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Demo, {\n      title: "Preselected select",\n      children: /*#__PURE__*/(0,jsx_runtime.jsxs)(select_Select, {\n        label: "Choose",\n        value: preselected,\n        filled: true,\n        onChange: function onChange(event, value) {\n          return setPreselected(value);\n        },\n        children: [/*#__PURE__*/(0,jsx_runtime.jsx)(select_Select.Option, {\n          value: "foo",\n          text: "Foo"\n        }), /*#__PURE__*/(0,jsx_runtime.jsx)(select_Select.Option, {\n          value: "bar",\n          text: "Bar"\n        }), /*#__PURE__*/(0,jsx_runtime.jsx)(select_Select.Option, {\n          value: "baz",\n          text: "Baz"\n        })]\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Demo, {\n      title: "Multiple select",\n      children: /*#__PURE__*/(0,jsx_runtime.jsxs)(select_Select, {\n        label: "Choose",\n        value: multiple,\n        filled: true,\n        onChange: function onChange(event, value) {\n          return setMultiple(value);\n        },\n        children: [/*#__PURE__*/(0,jsx_runtime.jsx)(select_Select.Option, {\n          value: "foo",\n          text: "Foo"\n        }), /*#__PURE__*/(0,jsx_runtime.jsx)(select_Select.Option, {\n          value: "bar",\n          text: "Bar"\n        }), /*#__PURE__*/(0,jsx_runtime.jsx)(select_Select.Option, {\n          value: "baz",\n          text: "Baz"\n        })]\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Demo, {\n      title: "Select with an icon",\n      children: /*#__PURE__*/(0,jsx_runtime.jsxs)(select_Select, {\n        label: "Choose",\n        value: icon,\n        icon: "star",\n        filled: true,\n        onChange: function onChange(event, value) {\n          return setIcon(value);\n        },\n        children: [/*#__PURE__*/(0,jsx_runtime.jsx)(select_Select.Option, {\n          value: "foo",\n          text: "Foo"\n        }), /*#__PURE__*/(0,jsx_runtime.jsx)(select_Select.Option, {\n          value: "bar",\n          text: "Bar"\n        }), /*#__PURE__*/(0,jsx_runtime.jsx)(select_Select.Option, {\n          value: "baz",\n          text: "Baz"\n        })]\n      })\n    })]\n  });\n}\n;// CONCATENATED MODULE: ./docs/src/pages/SideSheet/index.jsx\nfunction SideSheet_slicedToArray(arr, i) { return SideSheet_arrayWithHoles(arr) || SideSheet_iterableToArrayLimit(arr, i) || SideSheet_unsupportedIterableToArray(arr, i) || SideSheet_nonIterableRest(); }\n\nfunction SideSheet_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction SideSheet_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return SideSheet_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return SideSheet_arrayLikeToArray(o, minLen); }\n\nfunction SideSheet_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction SideSheet_iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction SideSheet_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\n\n\n\n\n\n\n\nvar SideSheet_id = \'side-sheet\';\nvar SideSheet_title = \'Side Sheet\';\nvar SideSheet_description = \'Side sheets are surfaces containing supplementary content that are anchored to the left or right edge of the screen.\';\nvar SideSheet_links = {\n  guide: \'https://material.io/components/sheets-side\'\n};\nfunction SideSheetPage() {\n  var _useState = (0,react.useState)(false),\n      _useState2 = SideSheet_slicedToArray(_useState, 2),\n      isDismissibleOpen = _useState2[0],\n      setDismissibleOpen = _useState2[1];\n\n  var _useState3 = (0,react.useState)(false),\n      _useState4 = SideSheet_slicedToArray(_useState3, 2),\n      isModalOpen = _useState4[0],\n      setModalOpen = _useState4[1];\n\n  return /*#__PURE__*/(0,jsx_runtime.jsxs)(Page, {\n    id: SideSheet_id,\n    title: SideSheet_title,\n    description: SideSheet_description,\n    links: SideSheet_links,\n    children: [/*#__PURE__*/(0,jsx_runtime.jsx)(Demo, {\n      title: "Basic side sheet",\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(side_sheet_SideSheet, {\n        title: "Title",\n        children: "Content"\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Demo, {\n      title: "Dismissible side sheet",\n      setup: /*#__PURE__*/(0,jsx_runtime.jsx)(button_Button, {\n        label: "Toggle",\n        outlined: true,\n        onClick: function onClick() {\n          return setDismissibleOpen(function (v) {\n            return !v;\n          });\n        }\n      }),\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(side_sheet_SideSheet, {\n        title: "Title",\n        closeIcon: "close",\n        open: isDismissibleOpen,\n        dismissible: true,\n        onClose: function onClose() {\n          return setDismissibleOpen(false);\n        },\n        children: "Content"\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Demo, {\n      title: "Modal side sheet",\n      setup: /*#__PURE__*/(0,jsx_runtime.jsx)(button_Button, {\n        label: "Open",\n        outlined: true,\n        onClick: function onClick() {\n          return setModalOpen(true);\n        }\n      }),\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(side_sheet_SideSheet, {\n        title: "Title",\n        closeIcon: "close",\n        open: isModalOpen,\n        modal: true,\n        onClose: function onClose() {\n          return setModalOpen(false);\n        },\n        children: "Content"\n      })\n    })]\n  });\n}\n;// CONCATENATED MODULE: ./docs/src/pages/Slider/index.jsx\nfunction pages_Slider_slicedToArray(arr, i) { return pages_Slider_arrayWithHoles(arr) || pages_Slider_iterableToArrayLimit(arr, i) || pages_Slider_unsupportedIterableToArray(arr, i) || pages_Slider_nonIterableRest(); }\n\nfunction pages_Slider_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction pages_Slider_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return pages_Slider_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return pages_Slider_arrayLikeToArray(o, minLen); }\n\nfunction pages_Slider_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction pages_Slider_iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction pages_Slider_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\n\n\n\n\n\n\n\nvar Slider_id = \'slider\';\nvar Slider_title = \'Slider\';\nvar Slider_description = \'Sliders allow users to make selections from a range of values.\';\nvar Slider_links = {\n  docs: \'https://github.com/material-components/material-components-web/tree/master/packages/mdc-slider\',\n  guide: \'https://material.io/components/sliders\'\n};\nfunction SliderPage() {\n  var _useState = (0,react.useState)(50),\n      _useState2 = pages_Slider_slicedToArray(_useState, 2),\n      value1 = _useState2[0],\n      setValue1 = _useState2[1];\n\n  var _useState3 = (0,react.useState)(50),\n      _useState4 = pages_Slider_slicedToArray(_useState3, 2),\n      value2 = _useState4[0],\n      setValue2 = _useState4[1];\n\n  var _useState5 = (0,react.useState)(50),\n      _useState6 = pages_Slider_slicedToArray(_useState5, 2),\n      value3 = _useState6[0],\n      setValue3 = _useState6[1];\n\n  return /*#__PURE__*/(0,jsx_runtime.jsxs)(Page, {\n    id: Slider_id,\n    title: Slider_title,\n    description: Slider_description,\n    links: Slider_links,\n    children: [/*#__PURE__*/(0,jsx_runtime.jsx)(Demo, {\n      title: "Continuous slider",\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(slider_Slider, {\n        value: value1,\n        onChange: setValue1\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Demo, {\n      title: "Discrete slider",\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(slider_Slider, {\n        value: value2,\n        step: "10",\n        discrete: true,\n        onChange: setValue2\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Demo, {\n      title: "Discrete slider with tick marks",\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(slider_Slider, {\n        value: value3,\n        step: "10",\n        discrete: true,\n        tickMarks: true,\n        onChange: setValue3\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Demo, {\n      title: "Disabled slider",\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(slider_Slider, {\n        value: 42,\n        disabled: true\n      })\n    })]\n  });\n}\n;// CONCATENATED MODULE: ./docs/src/pages/Snackbar/index.jsx\nfunction Snackbar_slicedToArray(arr, i) { return Snackbar_arrayWithHoles(arr) || Snackbar_iterableToArrayLimit(arr, i) || Snackbar_unsupportedIterableToArray(arr, i) || Snackbar_nonIterableRest(); }\n\nfunction Snackbar_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction Snackbar_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return Snackbar_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return Snackbar_arrayLikeToArray(o, minLen); }\n\nfunction Snackbar_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction Snackbar_iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction Snackbar_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\n\n\n\n\n\n\n\n\nvar Snackbar_id = \'snackbar\';\nvar Snackbar_title = \'Snackbar\';\nvar Snackbar_description = \'Snackbars provide brief messages about app processes at the bottom of the screen.\';\nvar Snackbar_links = {\n  docs: \'https://github.com/material-components/material-components-web/tree/master/packages/mdc-snackbar\',\n  guide: \'https://material.io/components/snackbars\'\n};\nfunction SnackbarPage() {\n  var _useState = (0,react.useState)(false),\n      _useState2 = Snackbar_slicedToArray(_useState, 2),\n      isOpen = _useState2[0],\n      setOpen = _useState2[1];\n\n  var _useState3 = (0,react.useState)(5000),\n      _useState4 = Snackbar_slicedToArray(_useState3, 2),\n      timeout = _useState4[0],\n      setTimeout = _useState4[1];\n\n  var _useState5 = (0,react.useState)(false),\n      _useState6 = Snackbar_slicedToArray(_useState5, 2),\n      hasAction = _useState6[0],\n      setHasAction = _useState6[1];\n\n  var _useState7 = (0,react.useState)(false),\n      _useState8 = Snackbar_slicedToArray(_useState7, 2),\n      isLeading = _useState8[0],\n      setLeading = _useState8[1];\n\n  var _useState9 = (0,react.useState)(false),\n      _useState10 = Snackbar_slicedToArray(_useState9, 2),\n      isStacked = _useState10[0],\n      setStacked = _useState10[1];\n\n  return /*#__PURE__*/(0,jsx_runtime.jsx)(Page, {\n    id: Snackbar_id,\n    title: Snackbar_title,\n    description: Snackbar_description,\n    links: Snackbar_links,\n    children: /*#__PURE__*/(0,jsx_runtime.jsx)(Demo, {\n      title: "Demo",\n      setup: /*#__PURE__*/(0,jsx_runtime.jsx)(button_Button, {\n        label: "Show",\n        outlined: true,\n        onClick: function onClick() {\n          return setOpen(true);\n        }\n      }),\n      settings: /*#__PURE__*/(0,jsx_runtime.jsxs)(jsx_runtime.Fragment, {\n        children: [/*#__PURE__*/(0,jsx_runtime.jsx)(FieldSet, {\n          legend: "Elements",\n          children: /*#__PURE__*/(0,jsx_runtime.jsx)(segmented_button_SegmentedButton, {\n            children: /*#__PURE__*/(0,jsx_runtime.jsx)(segmented_button_SegmentedButton.Segment, {\n              label: "Action",\n              selected: hasAction,\n              onClick: function onClick() {\n                return setHasAction(function (v) {\n                  return !v;\n                });\n              }\n            })\n          })\n        }), /*#__PURE__*/(0,jsx_runtime.jsx)(FieldSet, {\n          legend: "Variants",\n          children: /*#__PURE__*/(0,jsx_runtime.jsxs)(segmented_button_SegmentedButton, {\n            children: [/*#__PURE__*/(0,jsx_runtime.jsx)(segmented_button_SegmentedButton.Segment, {\n              label: "Leading",\n              selected: isLeading,\n              onClick: function onClick() {\n                return setLeading(function (v) {\n                  return !v;\n                });\n              }\n            }), /*#__PURE__*/(0,jsx_runtime.jsx)(segmented_button_SegmentedButton.Segment, {\n              label: "Stacked",\n              selected: isStacked,\n              onClick: function onClick() {\n                return setStacked(function (v) {\n                  return !v;\n                });\n              }\n            })]\n          })\n        }), /*#__PURE__*/(0,jsx_runtime.jsx)(text_field_TextField, {\n          label: "Timeout",\n          value: timeout,\n          suffix: "ms",\n          outlined: true,\n          onChange: function onChange(_, value) {\n            return setTimeout(value);\n          }\n        })]\n      }),\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(snackbar_Snackbar, {\n        open: isOpen,\n        timeout: timeout,\n        label: "Message",\n        action: hasAction ? /*#__PURE__*/(0,jsx_runtime.jsx)(button_Button, {\n          children: "Action"\n        }) : undefined,\n        leading: isLeading || undefined,\n        stacked: isStacked || undefined,\n        onClose: function onClose() {\n          return setOpen(undefined);\n        }\n      })\n    })\n  });\n}\n;// CONCATENATED MODULE: ./docs/src/pages/Switch/index.jsx\nfunction Switch_slicedToArray(arr, i) { return Switch_arrayWithHoles(arr) || Switch_iterableToArrayLimit(arr, i) || Switch_unsupportedIterableToArray(arr, i) || Switch_nonIterableRest(); }\n\nfunction Switch_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction Switch_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return Switch_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return Switch_arrayLikeToArray(o, minLen); }\n\nfunction Switch_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction Switch_iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction Switch_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\n\n\n\n\n\n\nvar Switch_id = \'switch\';\nvar Switch_title = \'Switch\';\nvar Switch_description = \'Switches toggle the state of a single item on or off.\';\nvar Switch_links = {\n  docs: \'https://github.com/material-components/material-components-web/tree/master/packages/mdc-switch\',\n  guide: \'https://material.io/components/switches\'\n};\nfunction SwitchPage() {\n  var _useState = (0,react.useState)(false),\n      _useState2 = Switch_slicedToArray(_useState, 2),\n      isSelected = _useState2[0],\n      setSelected = _useState2[1];\n\n  return /*#__PURE__*/(0,jsx_runtime.jsxs)(Page, {\n    id: Switch_id,\n    title: Switch_title,\n    description: Switch_description,\n    links: Switch_links,\n    children: [/*#__PURE__*/(0,jsx_runtime.jsx)(Demo, {\n      title: "Basic switch",\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(switch_Switch, {\n        selected: isSelected,\n        onChange: function onChange() {\n          return setSelected(function (v) {\n            return !v;\n          });\n        }\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Demo, {\n      title: "Disabled switch",\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(switch_Switch, {\n        disabled: true\n      })\n    })]\n  });\n}\n;// CONCATENATED MODULE: ./docs/src/pages/Symbol/index.jsx\nfunction Symbol_slicedToArray(arr, i) { return Symbol_arrayWithHoles(arr) || Symbol_iterableToArrayLimit(arr, i) || Symbol_unsupportedIterableToArray(arr, i) || Symbol_nonIterableRest(); }\n\nfunction Symbol_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction Symbol_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return Symbol_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return Symbol_arrayLikeToArray(o, minLen); }\n\nfunction Symbol_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction Symbol_iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction Symbol_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\n\n\n\n\n\n\n\n\n\nvar Symbol_id = \'symbol\';\nvar Symbol_title = \'Symbol\';\nvar Symbol_description = \'Material Symbols are our newest icons, consolidating over 2,500 glyphs in a single font file with a wide range of design variants. Symbols are available in three styles and four adjustable variable font axes (fill, weight, grade, and optical size).\';\nvar Symbol_links = {\n  docs: \'https://developers.google.com/fonts/docs/material_symbols\',\n  guide: \'https://material.io/design/iconography\'\n};\nfunction SymbolPage() {\n  var _useState = (0,react.useState)(\'flag\'),\n      _useState2 = Symbol_slicedToArray(_useState, 2),\n      name = _useState2[0],\n      setName = _useState2[1];\n\n  var _useState3 = (0,react.useState)(\'\'),\n      _useState4 = Symbol_slicedToArray(_useState3, 2),\n      size = _useState4[0],\n      setSize = _useState4[1];\n\n  var _useState5 = (0,react.useState)(\'outlined\'),\n      _useState6 = Symbol_slicedToArray(_useState5, 2),\n      type = _useState6[0],\n      setType = _useState6[1];\n\n  var _useState7 = (0,react.useState)(\'\'),\n      _useState8 = Symbol_slicedToArray(_useState7, 2),\n      tone = _useState8[0],\n      setTone = _useState8[1];\n\n  var _useState9 = (0,react.useState)(300),\n      _useState10 = Symbol_slicedToArray(_useState9, 2),\n      weight = _useState10[0],\n      setWeight = _useState10[1];\n\n  var _useState11 = (0,react.useState)(0),\n      _useState12 = Symbol_slicedToArray(_useState11, 2),\n      grade = _useState12[0],\n      setGrade = _useState12[1];\n\n  var _useState13 = (0,react.useState)(false),\n      _useState14 = Symbol_slicedToArray(_useState13, 2),\n      filled = _useState14[0],\n      setFilled = _useState14[1];\n\n  var _useState15 = (0,react.useState)(false),\n      _useState16 = Symbol_slicedToArray(_useState15, 2),\n      inactive = _useState16[0],\n      setInactive = _useState16[1];\n\n  return /*#__PURE__*/(0,jsx_runtime.jsx)(Page, {\n    id: Symbol_id,\n    title: Symbol_title,\n    description: Symbol_description,\n    links: Symbol_links,\n    children: /*#__PURE__*/(0,jsx_runtime.jsx)(Demo, {\n      settings: /*#__PURE__*/(0,jsx_runtime.jsxs)(jsx_runtime.Fragment, {\n        children: [/*#__PURE__*/(0,jsx_runtime.jsx)(text_field_TextField, {\n          value: name,\n          label: "Label",\n          outlined: true,\n          onChange: function onChange(_, value) {\n            return setName(value);\n          }\n        }), /*#__PURE__*/(0,jsx_runtime.jsx)(FieldSet, {\n          legend: "Type",\n          children: /*#__PURE__*/(0,jsx_runtime.jsx)(segmented_button_SegmentedButton, {\n            segments: [{\n              value: \'outlined\',\n              label: \'Outlined\'\n            }, {\n              value: \'rounded\',\n              label: \'Rounded\'\n            }, {\n              value: \'sharp\',\n              label: \'Sharp\'\n            }],\n            value: type,\n            onChange: setType\n          })\n        }), /*#__PURE__*/(0,jsx_runtime.jsx)(form_field_FormField, {\n          label: "Filled",\n          alignEnd: true,\n          spaceBetween: true,\n          children: /*#__PURE__*/(0,jsx_runtime.jsx)(switch_Switch, {\n            selected: filled,\n            onChange: function onChange() {\n              return setFilled(function (v) {\n                return !v;\n              });\n            }\n          })\n        }), /*#__PURE__*/(0,jsx_runtime.jsx)(FieldSet, {\n          legend: "Size",\n          children: /*#__PURE__*/(0,jsx_runtime.jsx)(segmented_button_SegmentedButton, {\n            segments: [{\n              value: \'smaller\',\n              label: \'Smaller\'\n            }, {\n              value: \'small\',\n              label: \'Small\'\n            }, {\n              value: \'medium\',\n              label: \'Medium\'\n            }, {\n              value: \'large\',\n              label: \'Large\'\n            }, {\n              value: \'larger\',\n              label: \'Larger\'\n            }],\n            value: size,\n            onChange: setSize\n          })\n        }), /*#__PURE__*/(0,jsx_runtime.jsx)(form_field_FormField, {\n          label: "Weight",\n          block: true,\n          children: /*#__PURE__*/(0,jsx_runtime.jsx)(slider_Slider, {\n            value: weight,\n            min: "100",\n            max: "700",\n            step: "100",\n            discrete: true,\n            tickMarks: true,\n            onChange: setWeight\n          })\n        }), /*#__PURE__*/(0,jsx_runtime.jsx)(FieldSet, {\n          legend: "Grade",\n          children: /*#__PURE__*/(0,jsx_runtime.jsx)(segmented_button_SegmentedButton, {\n            segments: [{\n              value: -25,\n              label: \'Low\'\n            }, {\n              value: 0,\n              label: \'Normal\'\n            }, {\n              value: 200,\n              label: \'High\'\n            }],\n            value: grade,\n            onChange: setGrade\n          })\n        }), /*#__PURE__*/(0,jsx_runtime.jsx)(FieldSet, {\n          legend: "Tone",\n          children: /*#__PURE__*/(0,jsx_runtime.jsx)(segmented_button_SegmentedButton, {\n            segments: [{\n              value: \'\',\n              label: \'None\'\n            }, {\n              value: \'light\',\n              label: \'Light\'\n            }, {\n              value: \'dark\',\n              label: \'Dark\'\n            }],\n            value: tone,\n            onChange: setTone\n          })\n        }), /*#__PURE__*/(0,jsx_runtime.jsx)(form_field_FormField, {\n          label: "Inactive",\n          alignEnd: true,\n          spaceBetween: true,\n          children: /*#__PURE__*/(0,jsx_runtime.jsx)(switch_Switch, {\n            selected: inactive,\n            onChange: function onChange() {\n              return setInactive(function (v) {\n                return !v;\n              });\n            }\n          })\n        })]\n      }),\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(symbol_Symbol, {\n        name: name,\n        type: type,\n        size: size,\n        weight: weight,\n        grade: grade,\n        filled: filled,\n        light: tone === \'light\',\n        dark: tone === \'dark\',\n        inactive: inactive\n      })\n    })\n  });\n}\n;// CONCATENATED MODULE: ./docs/src/pages/Tabs/index.jsx\nfunction Tabs_slicedToArray(arr, i) { return Tabs_arrayWithHoles(arr) || Tabs_iterableToArrayLimit(arr, i) || Tabs_unsupportedIterableToArray(arr, i) || Tabs_nonIterableRest(); }\n\nfunction Tabs_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction Tabs_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return Tabs_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return Tabs_arrayLikeToArray(o, minLen); }\n\nfunction Tabs_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction Tabs_iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction Tabs_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\n\n\n\n\n\n\n\nvar Tabs_id = \'tabs\';\nvar Tabs_title = \'Tabs\';\nvar Tabs_description = \'Tabs organize content across different screens, data sets, and other interactions.\';\nvar Tabs_links = {\n  docs: \'https://github.com/material-components/material-components-web/tree/master/packages/mdc-tab-bar\',\n  guide: \'https://material.io/components/tabs\'\n};\nfunction Tabs_SwitchPage() {\n  var _useState = (0,react.useState)(0),\n      _useState2 = Tabs_slicedToArray(_useState, 2),\n      basic = _useState2[0],\n      setBasic = _useState2[1];\n\n  var _useState3 = (0,react.useState)(0),\n      _useState4 = Tabs_slicedToArray(_useState3, 2),\n      minWidth = _useState4[0],\n      setMinWidth = _useState4[1];\n\n  var _useState5 = (0,react.useState)(0),\n      _useState6 = Tabs_slicedToArray(_useState5, 2),\n      minWidthIndicator = _useState6[0],\n      setMinWidthIndicator = _useState6[1];\n\n  var _useState7 = (0,react.useState)(0),\n      _useState8 = Tabs_slicedToArray(_useState7, 2),\n      minWidthWithMinWidthIndicator = _useState8[0],\n      setMinWidthWithMinWidthIndicator = _useState8[1];\n\n  var _useState9 = (0,react.useState)(0),\n      _useState10 = Tabs_slicedToArray(_useState9, 2),\n      fade = _useState10[0],\n      setFade = _useState10[1];\n\n  var _useState11 = (0,react.useState)(0),\n      _useState12 = Tabs_slicedToArray(_useState11, 2),\n      icons = _useState12[0],\n      setIcons = _useState12[1];\n\n  var _useState13 = (0,react.useState)(0),\n      _useState14 = Tabs_slicedToArray(_useState13, 2),\n      stackedIcons = _useState14[0],\n      setStackedIcons = _useState14[1];\n\n  var _useState15 = (0,react.useState)(0),\n      _useState16 = Tabs_slicedToArray(_useState15, 2),\n      onlyIcons = _useState16[0],\n      setOnlyIcons = _useState16[1];\n\n  var _useState17 = (0,react.useState)(0),\n      _useState18 = Tabs_slicedToArray(_useState17, 2),\n      iconIndicator = _useState18[0],\n      setIconIndicator = _useState18[1];\n\n  var _useState19 = (0,react.useState)(0),\n      _useState20 = Tabs_slicedToArray(_useState19, 2),\n      scroll = _useState20[0],\n      setScroll = _useState20[1];\n\n  return /*#__PURE__*/(0,jsx_runtime.jsxs)(Page, {\n    id: Tabs_id,\n    title: Tabs_title,\n    description: Tabs_description,\n    links: Tabs_links,\n    children: [/*#__PURE__*/(0,jsx_runtime.jsx)(Demo, {\n      title: "Basic tabs",\n      children: /*#__PURE__*/(0,jsx_runtime.jsxs)(tabs_TabBar, {\n        value: basic,\n        onChange: function onChange(value) {\n          return setBasic(value);\n        },\n        children: [/*#__PURE__*/(0,jsx_runtime.jsx)(tabs_Tab, {\n          label: "Tab 1"\n        }), /*#__PURE__*/(0,jsx_runtime.jsx)(tabs_Tab, {\n          label: "Tab 2"\n        }), /*#__PURE__*/(0,jsx_runtime.jsx)(tabs_Tab, {\n          label: "Tab 3"\n        })]\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Demo, {\n      title: "Min width tabs",\n      children: /*#__PURE__*/(0,jsx_runtime.jsxs)(tabs_TabBar, {\n        value: minWidth,\n        minWidth: true,\n        onChange: function onChange(value) {\n          return setMinWidth(value);\n        },\n        children: [/*#__PURE__*/(0,jsx_runtime.jsx)(tabs_Tab, {\n          label: "Tab 1"\n        }), /*#__PURE__*/(0,jsx_runtime.jsx)(tabs_Tab, {\n          label: "Tab 2"\n        }), /*#__PURE__*/(0,jsx_runtime.jsx)(tabs_Tab, {\n          label: "Tab 3"\n        })]\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Demo, {\n      title: "Tabs with min width indicator",\n      children: /*#__PURE__*/(0,jsx_runtime.jsxs)(tabs_TabBar, {\n        value: minWidthIndicator,\n        minWidthIndicator: true,\n        onChange: function onChange(value) {\n          return setMinWidthIndicator(value);\n        },\n        children: [/*#__PURE__*/(0,jsx_runtime.jsx)(tabs_Tab, {\n          label: "Tab 1"\n        }), /*#__PURE__*/(0,jsx_runtime.jsx)(tabs_Tab, {\n          label: "Tab 2"\n        }), /*#__PURE__*/(0,jsx_runtime.jsx)(tabs_Tab, {\n          label: "Tab 3"\n        })]\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Demo, {\n      title: "Min width tabs with min width indicator",\n      children: /*#__PURE__*/(0,jsx_runtime.jsxs)(tabs_TabBar, {\n        value: minWidthWithMinWidthIndicator,\n        minWidth: true,\n        minWidthIndicator: true,\n        onChange: function onChange(value) {\n          return setMinWidthWithMinWidthIndicator(value);\n        },\n        children: [/*#__PURE__*/(0,jsx_runtime.jsx)(tabs_Tab, {\n          label: "Tab 1"\n        }), /*#__PURE__*/(0,jsx_runtime.jsx)(tabs_Tab, {\n          label: "Tab 2"\n        }), /*#__PURE__*/(0,jsx_runtime.jsx)(tabs_Tab, {\n          label: "Tab 3"\n        })]\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Demo, {\n      title: "Tabs with fading indicator",\n      children: /*#__PURE__*/(0,jsx_runtime.jsxs)(tabs_TabBar, {\n        value: fade,\n        fade: true,\n        onChange: function onChange(value) {\n          return setFade(value);\n        },\n        children: [/*#__PURE__*/(0,jsx_runtime.jsx)(tabs_Tab, {\n          label: "Tab 1"\n        }), /*#__PURE__*/(0,jsx_runtime.jsx)(tabs_Tab, {\n          label: "Tab 2"\n        }), /*#__PURE__*/(0,jsx_runtime.jsx)(tabs_Tab, {\n          label: "Tab 3"\n        })]\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Demo, {\n      title: "Tabs with icons",\n      children: /*#__PURE__*/(0,jsx_runtime.jsxs)(tabs_TabBar, {\n        value: icons,\n        onChange: function onChange(value) {\n          return setIcons(value);\n        },\n        children: [/*#__PURE__*/(0,jsx_runtime.jsx)(tabs_Tab, {\n          icon: "star",\n          label: "Tab 1"\n        }), /*#__PURE__*/(0,jsx_runtime.jsx)(tabs_Tab, {\n          icon: "favorite",\n          label: "Tab 2"\n        }), /*#__PURE__*/(0,jsx_runtime.jsx)(tabs_Tab, {\n          icon: "settings",\n          label: "Tab 3"\n        })]\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Demo, {\n      title: "Tabs with stacked icons",\n      children: /*#__PURE__*/(0,jsx_runtime.jsxs)(tabs_TabBar, {\n        value: stackedIcons,\n        stacked: true,\n        onChange: function onChange(value) {\n          return setStackedIcons(value);\n        },\n        children: [/*#__PURE__*/(0,jsx_runtime.jsx)(tabs_Tab, {\n          icon: "star",\n          label: "Tab 1"\n        }), /*#__PURE__*/(0,jsx_runtime.jsx)(tabs_Tab, {\n          icon: "favorite",\n          label: "Tab 2"\n        }), /*#__PURE__*/(0,jsx_runtime.jsx)(tabs_Tab, {\n          icon: "settings",\n          label: "Tab 3"\n        })]\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Demo, {\n      title: "Tabs with icons only",\n      children: /*#__PURE__*/(0,jsx_runtime.jsxs)(tabs_TabBar, {\n        value: onlyIcons,\n        indicatorIcon: "star",\n        onChange: function onChange(value) {\n          return setOnlyIcons(value);\n        },\n        children: [/*#__PURE__*/(0,jsx_runtime.jsx)(tabs_Tab, {\n          icon: "star"\n        }), /*#__PURE__*/(0,jsx_runtime.jsx)(tabs_Tab, {\n          icon: "favorite"\n        }), /*#__PURE__*/(0,jsx_runtime.jsx)(tabs_Tab, {\n          icon: "settings"\n        })]\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Demo, {\n      title: "Tabs with icon indicator",\n      children: /*#__PURE__*/(0,jsx_runtime.jsxs)(tabs_TabBar, {\n        value: iconIndicator,\n        onChange: function onChange(value) {\n          return setIconIndicator(value);\n        },\n        children: [/*#__PURE__*/(0,jsx_runtime.jsx)(tabs_Tab, {\n          label: "Tab 1"\n        }), /*#__PURE__*/(0,jsx_runtime.jsx)(tabs_Tab, {\n          label: "Tab 2"\n        }), /*#__PURE__*/(0,jsx_runtime.jsx)(tabs_Tab, {\n          label: "Tab 3"\n        })]\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Demo, {\n      title: "Scrolling tabs",\n      children: /*#__PURE__*/(0,jsx_runtime.jsxs)(tabs_TabBar, {\n        value: scroll,\n        onChange: function onChange(value) {\n          return setScroll(value);\n        },\n        children: [/*#__PURE__*/(0,jsx_runtime.jsx)(tabs_Tab, {\n          label: "Tab 1"\n        }), /*#__PURE__*/(0,jsx_runtime.jsx)(tabs_Tab, {\n          label: "Tab 2"\n        }), /*#__PURE__*/(0,jsx_runtime.jsx)(tabs_Tab, {\n          label: "Tab 3"\n        }), /*#__PURE__*/(0,jsx_runtime.jsx)(tabs_Tab, {\n          label: "Tab 4"\n        }), /*#__PURE__*/(0,jsx_runtime.jsx)(tabs_Tab, {\n          label: "Tab 5"\n        }), /*#__PURE__*/(0,jsx_runtime.jsx)(tabs_Tab, {\n          label: "Tab 6"\n        }), /*#__PURE__*/(0,jsx_runtime.jsx)(tabs_Tab, {\n          label: "Tab 7"\n        }), /*#__PURE__*/(0,jsx_runtime.jsx)(tabs_Tab, {\n          label: "Tab 8"\n        }), /*#__PURE__*/(0,jsx_runtime.jsx)(tabs_Tab, {\n          label: "Tab 9"\n        }), /*#__PURE__*/(0,jsx_runtime.jsx)(tabs_Tab, {\n          label: "Tab 10"\n        }), /*#__PURE__*/(0,jsx_runtime.jsx)(tabs_Tab, {\n          label: "Tab 11"\n        }), /*#__PURE__*/(0,jsx_runtime.jsx)(tabs_Tab, {\n          label: "Tab 12"\n        }), /*#__PURE__*/(0,jsx_runtime.jsx)(tabs_Tab, {\n          label: "Tab 13"\n        }), /*#__PURE__*/(0,jsx_runtime.jsx)(tabs_Tab, {\n          label: "Tab 14"\n        }), /*#__PURE__*/(0,jsx_runtime.jsx)(tabs_Tab, {\n          label: "Tab 15"\n        })]\n      })\n    })]\n  });\n}\n;// CONCATENATED MODULE: ./docs/src/pages/TextField/index.jsx\nfunction pages_TextField_slicedToArray(arr, i) { return pages_TextField_arrayWithHoles(arr) || pages_TextField_iterableToArrayLimit(arr, i) || pages_TextField_unsupportedIterableToArray(arr, i) || pages_TextField_nonIterableRest(); }\n\nfunction pages_TextField_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction pages_TextField_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return pages_TextField_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return pages_TextField_arrayLikeToArray(o, minLen); }\n\nfunction pages_TextField_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction pages_TextField_iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction pages_TextField_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\n\n\n\n\n\n\n\nvar TextField_id = \'text-field\';\nvar TextField_title = \'Text Field\';\nvar TextField_description = \'Text fields let users enter and edit text.\';\nvar TextField_links = {\n  docs: \'https://github.com/material-components/material-components-web/tree/master/packages/mdc-textfield\',\n  guide: \'https://material.io/components/text-fields\'\n};\nfunction TypographyPage() {\n  var _useState = (0,react.useState)(\'filled\'),\n      _useState2 = pages_TextField_slicedToArray(_useState, 2),\n      type = _useState2[0],\n      setType = _useState2[1];\n\n  var isFilled = type === \'filled\' || undefined;\n  var isOutlined = type === \'outlined\' || undefined;\n  return /*#__PURE__*/(0,jsx_runtime.jsxs)(Page, {\n    id: TextField_id,\n    title: TextField_title,\n    description: TextField_description,\n    links: TextField_links,\n    children: [/*#__PURE__*/(0,jsx_runtime.jsxs)(tabs_TabBar, {\n      value: type,\n      onChange: setType,\n      minWidth: true,\n      children: [/*#__PURE__*/(0,jsx_runtime.jsx)(tabs_Tab, {\n        value: "filled",\n        label: "Filled"\n      }), /*#__PURE__*/(0,jsx_runtime.jsx)(tabs_Tab, {\n        value: "outlined",\n        label: "Outlined"\n      })]\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Demo, {\n      title: "Basic text field",\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(text_field_TextField, {\n        defaultValue: "",\n        filled: isFilled,\n        outlined: isOutlined\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Demo, {\n      title: "Text field with a label",\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(text_field_TextField, {\n        defaultValue: "",\n        label: "Label",\n        filled: isFilled,\n        outlined: isOutlined\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Demo, {\n      title: "Textarea",\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(text_field_TextField, {\n        defaultValue: "",\n        label: "Label",\n        textarea: true,\n        filled: isFilled,\n        outlined: isOutlined\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Demo, {\n      title: "Autoresizable textarea",\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(text_field_TextField, {\n        defaultValue: "",\n        label: "Label",\n        textarea: true,\n        autoResize: true,\n        filled: isFilled,\n        outlined: isOutlined\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Demo, {\n      title: "Pre-filled text field",\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(text_field_TextField, {\n        defaultValue: "Some text",\n        label: "Label",\n        filled: isFilled,\n        outlined: isOutlined\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Demo, {\n      title: "With helper text",\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(text_field_TextField, {\n        defaultValue: "",\n        helperText: "Helper text",\n        filled: isFilled,\n        outlined: isOutlined\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Demo, {\n      title: "With persistent helper text",\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(text_field_TextField, {\n        defaultValue: "",\n        persistentHelperText: "Helper text",\n        filled: isFilled,\n        outlined: isOutlined\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Demo, {\n      title: "Text field with validation message",\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(text_field_TextField, {\n        defaultValue: "",\n        label: "Label",\n        required: true,\n        validationMessage: "Validation message",\n        filled: isFilled,\n        outlined: isOutlined\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Demo, {\n      title: "Text field with a character counter",\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(text_field_TextField, {\n        defaultValue: "",\n        label: "Label",\n        maxLength: 10,\n        characterCounter: true,\n        filled: isFilled,\n        outlined: isOutlined\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Demo, {\n      title: "Text field with an internal character counter",\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(text_field_TextField, {\n        defaultValue: "",\n        label: "Label",\n        maxLength: 120,\n        filled: isFilled,\n        outlined: isOutlined,\n        textarea: true,\n        characterCounter: "internal"\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Demo, {\n      title: "Text field with a prefix",\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(text_field_TextField, {\n        defaultValue: "",\n        label: "Label",\n        prefix: "@",\n        filled: isFilled,\n        outlined: isOutlined\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Demo, {\n      title: "Text field with a suffix",\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(text_field_TextField, {\n        defaultValue: "",\n        label: "Label",\n        suffix: "$",\n        filled: isFilled,\n        outlined: isOutlined\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Demo, {\n      title: "Text field with a leading icon",\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(text_field_TextField, {\n        defaultValue: "",\n        leadingIcon: "star",\n        filled: isFilled,\n        outlined: isOutlined\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Demo, {\n      title: "Text field with a trailing icon",\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(text_field_TextField, {\n        defaultValue: "",\n        trailingIcon: "edit",\n        filled: isFilled,\n        outlined: isOutlined\n      })\n    })]\n  });\n}\n;// CONCATENATED MODULE: ./docs/src/pages/Tooltip/index.jsx\n\n\n\n\n\n\nvar Tooltip_id = \'tooltip\';\nvar Tooltip_title = \'Tooltip\';\nvar Tooltip_description = \'Tooltips display informative text when users hover over, focus on, or tap an element.\';\nvar Tooltip_links = {\n  docs: \'https://github.com/material-components/material-components-web/tree/master/packages/mdc-tooltip\',\n  guide: \'https://material.io/components/tooltips\'\n};\nfunction TooltipPage() {\n  return /*#__PURE__*/(0,jsx_runtime.jsxs)(Page, {\n    id: Tooltip_id,\n    title: Tooltip_title,\n    description: Tooltip_description,\n    links: Tooltip_links,\n    children: [/*#__PURE__*/(0,jsx_runtime.jsx)(Demo, {\n      title: "Basic tooltip",\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(tooltip_Tooltip, {\n        label: "Star",\n        children: /*#__PURE__*/(0,jsx_runtime.jsx)(icon_button_IconButton, {\n          icon: "star"\n        })\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Demo, {\n      title: "Multiline tooltip",\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(tooltip_Tooltip, {\n        label: "This is a star icon button, you should click on it",\n        children: /*#__PURE__*/(0,jsx_runtime.jsx)(icon_button_IconButton, {\n          icon: "star"\n        })\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Demo, {\n      title: "Rich tooltip",\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(tooltip_RichTooltip, {\n        title: "Title",\n        content: "Default rich tooltips are shown when users hover over or focus on their anchor element. They remain shown when users focus/hover over the contents of the rich tooltip, but becomes hidden if the users focus/hover outside of the anchor element or the tooltip contents. If the user clicks within the contents of the tooltip, the tooltip will also be hidden.",\n        children: /*#__PURE__*/(0,jsx_runtime.jsx)(icon_button_IconButton, {\n          icon: "star"\n        })\n      })\n    })]\n  });\n}\n;// CONCATENATED MODULE: ./docs/src/pages/TopAppBar/index.jsx\nfunction pages_TopAppBar_slicedToArray(arr, i) { return pages_TopAppBar_arrayWithHoles(arr) || pages_TopAppBar_iterableToArrayLimit(arr, i) || pages_TopAppBar_unsupportedIterableToArray(arr, i) || pages_TopAppBar_nonIterableRest(); }\n\nfunction pages_TopAppBar_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction pages_TopAppBar_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return pages_TopAppBar_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return pages_TopAppBar_arrayLikeToArray(o, minLen); }\n\nfunction pages_TopAppBar_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction pages_TopAppBar_iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction pages_TopAppBar_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\n\n\n\n\n\n\n\n\nvar TopAppBar_id = \'top-app-bar\';\nvar TopAppBar_title = \'Top App Bar\';\nvar TopAppBar_description = \'The top app bar displays information and actions relating to the current screen.\';\nvar TopAppBar_links = {\n  docs: \'https://github.com/material-components/material-components-web/tree/master/packages/mdc-top-app-bar\',\n  guide: \'https://material.io/components/app-bars-top\'\n};\nfunction TopAppBarPage() {\n  var _useState = (0,react.useState)(false),\n      _useState2 = pages_TopAppBar_slicedToArray(_useState, 2),\n      isCollapsed = _useState2[0],\n      setCollapsed = _useState2[1];\n\n  var actionItems = [/*#__PURE__*/(0,jsx_runtime.jsx)(icon_button_IconButton, {\n    icon: "add"\n  }, "add"), /*#__PURE__*/(0,jsx_runtime.jsx)(icon_button_IconButton, {\n    icon: "edit"\n  }, "edit"), /*#__PURE__*/(0,jsx_runtime.jsx)(icon_button_IconButton, {\n    icon: "delete"\n  }, "delete")];\n  return /*#__PURE__*/(0,jsx_runtime.jsxs)(Page, {\n    id: TopAppBar_id,\n    title: TopAppBar_title,\n    description: TopAppBar_description,\n    links: TopAppBar_links,\n    children: [/*#__PURE__*/(0,jsx_runtime.jsx)(Demo, {\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(top_app_bar_TopAppBar, {\n        title: "Basic",\n        navigationIcon: "menu",\n        actionItems: actionItems\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Demo, {\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(top_app_bar_TopAppBar, {\n        title: "Dense",\n        navigationIcon: "menu",\n        actionItems: actionItems,\n        dense: true\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Demo, {\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(top_app_bar_TopAppBar, {\n        title: "Prominent",\n        navigationIcon: "menu",\n        actionItems: actionItems,\n        prominent: true\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Demo, {\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(top_app_bar_TopAppBar, {\n        title: "Short",\n        navigationIcon: "menu",\n        "short": true,\n        collapsed: isCollapsed,\n        onNavigationIconClick: function onNavigationIconClick() {\n          return setCollapsed(function (v) {\n            return !v;\n          });\n        }\n      })\n    })]\n  });\n}\n;// CONCATENATED MODULE: ./docs/src/pages/Typography/index.jsx\n\n\n\n\n\n\nvar Typography_id = \'typography\';\nvar Typography_title = \'Typography\';\nvar Typography_description = \'Typography expresses hierarchy and brand presence.\';\nvar Typography_links = {\n  docs: \'https://github.com/material-components/material-components-web/tree/master/packages/mdc-typography\',\n  guide: \'https://material.io/design/typography\'\n};\nfunction Typography_TypographyPage() {\n  return /*#__PURE__*/(0,jsx_runtime.jsx)(Page, {\n    id: Typography_id,\n    title: Typography_title,\n    description: Typography_description,\n    links: Typography_links,\n    children: /*#__PURE__*/(0,jsx_runtime.jsxs)(Demo, {\n      children: [/*#__PURE__*/(0,jsx_runtime.jsx)(typography_Typography, {\n        type: "headline1",\n        noMargin: true,\n        children: "Headline 1"\n      }), /*#__PURE__*/(0,jsx_runtime.jsx)(typography_Typography, {\n        type: "headline2",\n        noMargin: true,\n        children: "Headline 2"\n      }), /*#__PURE__*/(0,jsx_runtime.jsx)(typography_Typography, {\n        type: "headline3",\n        noMargin: true,\n        children: "Headline 3"\n      }), /*#__PURE__*/(0,jsx_runtime.jsx)(typography_Typography, {\n        type: "headline4",\n        noMargin: true,\n        children: "Headline 4"\n      }), /*#__PURE__*/(0,jsx_runtime.jsx)(typography_Typography, {\n        type: "headline5",\n        noMargin: true,\n        children: "Headline 5"\n      }), /*#__PURE__*/(0,jsx_runtime.jsx)(typography_Typography, {\n        type: "headline6",\n        noMargin: true,\n        children: "Headline 6"\n      }), /*#__PURE__*/(0,jsx_runtime.jsx)(typography_Typography, {\n        type: "subtitle1",\n        noMargin: true,\n        children: "Subtitle 1"\n      }), /*#__PURE__*/(0,jsx_runtime.jsx)(typography_Typography, {\n        type: "subtitle2",\n        noMargin: true,\n        children: "Subtitle 2"\n      }), /*#__PURE__*/(0,jsx_runtime.jsx)(typography_Typography, {\n        type: "body1",\n        noMargin: true,\n        children: "Body 1"\n      }), /*#__PURE__*/(0,jsx_runtime.jsx)(typography_Typography, {\n        type: "body2",\n        noMargin: true,\n        children: "Body 2"\n      }), /*#__PURE__*/(0,jsx_runtime.jsx)(typography_Typography, {\n        type: "caption",\n        children: "Caption"\n      }), /*#__PURE__*/(0,jsx_runtime.jsx)(typography_Typography, {\n        type: "button",\n        children: "Button"\n      }), /*#__PURE__*/(0,jsx_runtime.jsx)(typography_Typography, {\n        type: "overline",\n        children: "Overline"\n      })]\n    })\n  });\n}\n;// CONCATENATED MODULE: ./docs/src/pages/index.js\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n;// CONCATENATED MODULE: ./docs/src/routes.js\n\n/* harmony default export */ const routes = ([{\n  title: \'Avatar\',\n  url: \'/avatar\',\n  component: AvatarPage,\n  icon: \'account_circle\'\n}, {\n  title: \'Badge\',\n  url: \'/badge\',\n  component: BadgePage,\n  icon: \'mark_email_unread\'\n}, {\n  title: \'Banner\',\n  url: \'/banner\',\n  component: Banner_BadgePage,\n  icon: \'error_outline\',\n  imageUrl: \'https://lh3.googleusercontent.com/tOZdWbfWtIc5GHTWsW0Daqj5I6lCCrUN8-YuEVjSn87JNN6x6PEjfmne-gpBo4jHBI4gqLmi0kLVpubF41ZT2mM8glkLzo2iWgK_-jY=w760-h380\'\n}, {\n  title: \'Button\',\n  url: \'/button\',\n  component: ButtonPage,\n  icon: \'crop_7_5\',\n  imageUrl: \'https://lh3.googleusercontent.com/GHRz-5S00u7WkRGl8iUm8ezoR6eoB2NJztu-trJv3raMDvpSACeQ5O0KOoAG7SRHJNDM_mT04Hei1NwjTN-ZsIFms_bsQ4zxRyxdQQ=w760-h380\'\n}, {\n  title: \'Card\',\n  url: \'/card\',\n  component: CardPage,\n  icon: \'wysiwyg\',\n  imageUrl: \'https://lh3.googleusercontent.com/FyE3qjGwwnoeMgiyOuIxdxTQQM9Cr0ftNakOXOA8cp137rKN09BFHraERm1NPUFBTGxVgchkdl6UABc11ZcJDML4ui466W2BFIxc9Q=w760-h380\'\n}, {\n  title: \'Checkbox\',\n  url: \'/checkbox\',\n  component: CheckboxPage,\n  icon: \'check_box\'\n}, {\n  title: \'Chips\',\n  url: \'/chips\',\n  component: ChipsPage,\n  icon: \'label\'\n}, {\n  title: \'Circular Progress\',\n  url: \'/circular-progress\',\n  component: CircularProgressPage,\n  icon: \'circle\'\n}, {\n  title: \'DataTable\',\n  url: \'/data-table\',\n  component: DataTablePage,\n  icon: \'table_chart\'\n}, {\n  title: \'Dialog\',\n  url: \'/dialog\',\n  component: DialogPage,\n  icon: \'video_label\'\n}, {\n  title: \'Drawer\',\n  url: \'/drawer\',\n  component: DrawerPage,\n  icon: \'view_quilt\'\n}, {\n  title: \'Elevation\',\n  url: \'/elevation\',\n  component: ElevationPage,\n  icon: \'layers\'\n}, {\n  title: \'FAB\',\n  url: \'/fab\',\n  component: FABPage,\n  icon: \'add_circle\',\n  imageUrl: \'https://lh3.googleusercontent.com/T8dlYzaaU2SV86x6lqNMjlHcrFdKv85QMW1UnJShGwklRQyuUqZIklOjnEuqrZzF1h84ohrzz2ITajbT9IdljofNFmP5csEq6G7W=w760-h380\'\n}, {\n  title: \'Form Field\',\n  url: \'/form-field\',\n  component: FormFieldPage,\n  icon: \'short_text\'\n}, {\n  title: \'Icon\',\n  url: \'/icon\',\n  component: IconPage,\n  icon: \'category\'\n}, {\n  title: \'Icon Button\',\n  url: \'/icon-button\',\n  component: IconButtonPage,\n  icon: \'info\'\n}, {\n  title: \'Image List\',\n  url: \'/image-list\',\n  component: ImageListPage,\n  icon: \'dashboard\'\n}, {\n  title: \'Layout Grid\',\n  url: \'/layout-grid\',\n  component: LayoutGridPage,\n  icon: \'calendar_view_month\'\n}, {\n  title: \'Linear Progress\',\n  url: \'/linear-progress\',\n  component: LinearProgressPage,\n  icon: \'horizontal_rule\'\n}, {\n  title: \'List\',\n  url: \'/list\',\n  component: ListPage,\n  icon: \'format_list_bulleted\'\n}, {\n  title: \'Menu\',\n  url: \'/menu\',\n  component: MenuPage,\n  icon: \'list_alt\'\n}, {\n  title: \'Radio\',\n  url: \'/radio\',\n  component: RadioPage,\n  icon: \'radio_button_checked\'\n}, {\n  title: \'Ripple\',\n  url: \'/ripple\',\n  component: Ripple_RadioPage,\n  icon: \'ads_click\'\n}, {\n  title: \'Segmented Button\',\n  url: \'/segmented-button\',\n  icon: \'linear_scale\',\n  component: SegmentedButtonPage,\n  imageUrl: \'\'\n}, {\n  title: \'Select\',\n  url: \'/select\',\n  component: SelectPage,\n  icon: \'ballot\',\n  imageUrl: \'\'\n}, {\n  title: \'Side Sheet\',\n  url: \'/side-sheet\',\n  component: SideSheetPage,\n  icon: \'view_sidebar\',\n  imageUrl: \'\'\n}, {\n  title: \'Slider\',\n  url: \'/slider\',\n  component: SliderPage,\n  icon: \'commit\',\n  imageUrl: \'https://lh3.googleusercontent.com/w6nNeLcjpXypo2U6_gvunUesgTNOAqzEzb5ZzxxT4AyGH_M_L_EHrybg9sJNg78BDHyeCPIQCe3Hk2sTglU0EQe7cOBsqUMFicq1lg=w760-h380\'\n}, {\n  title: \'Snackbar\',\n  url: \'/snackbar\',\n  component: SnackbarPage,\n  icon: \'call_to_action\',\n  imageUrl: \'https://lh3.googleusercontent.com/fGgZPDOszTD-2ReAC85l5op7wCE3uvnPta13Aib2bSlzN8LXoNYlDG6fY5DY1qKqbLTbGGlx9VgahUDdjDgdjq8sJNqoIY4-GPxKRA=w760-h380\'\n}, {\n  title: \'Switch\',\n  url: \'/switch\',\n  component: SwitchPage,\n  icon: \'toggle_on\'\n}, {\n  title: \'Symbol\',\n  url: \'/symbol\',\n  component: SymbolPage,\n  icon: \'category\'\n}, {\n  title: \'Tabs\',\n  url: \'/tabs\',\n  component: Tabs_SwitchPage,\n  icon: \'tab\',\n  imageUrl: \'https://lh3.googleusercontent.com/AYFp2VmMn9nslx18M6Es9C57S7p3zkiQVLl3PHvMu-OpbvK1FlLJN2MHfFNZfmfMCk1drCw84FKebz5STJ7QN69IHhH9WF1Kklir=w760-h380\'\n}, {\n  title: \'Text Field\',\n  url: \'/text-field\',\n  component: TypographyPage,\n  icon: \'text_fields\',\n  imageUrl: \'https://lh3.googleusercontent.com/Lxb_jZfXkASZ1DCzNhyS3IG7mIsPhBVmaX20Hn7XnwpS_Po9wQIC-5rEwUsYlb5TkgMjqI45-j1w4i4WM4wSlA-b0qKtmJ69hV0j=w760-h380\'\n}, {\n  title: \'Tooltip\',\n  url: \'/tooltip\',\n  component: TooltipPage,\n  icon: \'filter_frames\',\n  imageUrl: \'https://lh3.googleusercontent.com/Asm1KHPsUD-GDDglcItzvl2LKWsyrMzKMrWDA5siHaF7PAvngniS57PMZTHFsDHkHsjT9dPWC5tEpRBG7i5syZ7sbRiRpL9oE84F=w760-h380\'\n}, {\n  title: \'Top App Bar\',\n  url: \'/top-app-bar\',\n  component: TopAppBarPage,\n  icon: \'view_compact\',\n  imageUrl: \'https://lh3.googleusercontent.com/eot96a-qjAr0QypKKf-6qSJGQQqW086-GV2vv0D9F358-VFiJSWifg6-q38vbI_JsxCPnbJNzjCH12OFDXJBzScB3h__HXLwKWkjYA=w760-h380\'\n}, {\n  title: \'Typography\',\n  url: \'/typography\',\n  component: Typography_TypographyPage,\n  icon: \'title\'\n}]);\n;// CONCATENATED MODULE: ./docs/src/App.jsx\n\n\n\n\n\n\n\n\nfunction App() {\n  (0,react.useEffect)(function () {\n    var activeNavItem = document.querySelector(\'.app-drawer .mdc-list-item--activated\');\n\n    if (activeNavItem) {\n      activeNavItem.scrollIntoView({\n        behavior: \'smooth\',\n        block: \'center\'\n      });\n    }\n  }, []);\n  return /*#__PURE__*/(0,jsx_runtime.jsxs)("div", {\n    className: "app mdc-typography mdc-theme--dark",\n    children: [/*#__PURE__*/(0,jsx_runtime.jsx)(top_app_bar_TopAppBar, {\n      className: "app-top-bar",\n      navigationIcon: /*#__PURE__*/(0,jsx_runtime.jsx)(icon_button_IconButton, {\n        icon: /*#__PURE__*/(0,jsx_runtime.jsx)(Link, {\n          to: "/",\n          children: /*#__PURE__*/(0,jsx_runtime.jsx)("img", {\n            src: "https://material-components.github.io/material-components-web-catalog/static/media/ic_component_24px_white.svg",\n            alt: ""\n          })\n        })\n      }),\n      title: /*#__PURE__*/(0,jsx_runtime.jsx)(Link, {\n        to: "/",\n        className: "app-home-link",\n        children: "MDC React"\n      }),\n      actionItems: [/*#__PURE__*/(0,jsx_runtime.jsx)(icon_button_IconButton, {\n        element: "a",\n        href: "https://github.com/olegpolyakov/mdc-react",\n        target: "_blank",\n        icon: "code",\n        title: "Code"\n      }, "code"), /*#__PURE__*/(0,jsx_runtime.jsx)(icon_button_IconButton, {\n        element: "a",\n        href: "https://github.com/olegpolyakov/mdc-react/issues",\n        target: "_blank",\n        icon: "bug_report",\n        title: "Issues"\n      }, "issues"), /*#__PURE__*/(0,jsx_runtime.jsx)(icon_button_IconButton, {\n        element: "a",\n        href: "https://github.com/olegpolyakov/mdc-react/discussions",\n        target: "_blank",\n        icon: "forum",\n        title: "Discussions"\n      }, "discussions")]\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(drawer_Drawer, {\n      className: "app-drawer",\n      dismissible: true,\n      open: true,\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(drawer_Drawer.Content, {\n        children: /*#__PURE__*/(0,jsx_runtime.jsx)(list_List, {\n          element: "nav",\n          children: routes.map(function (route) {\n            return /*#__PURE__*/(0,jsx_runtime.jsx)(list_List.Item, {\n              component: NavLink,\n              to: route.url,\n              leadingIcon: /*#__PURE__*/(0,jsx_runtime.jsx)(icon_Icon, {\n                type: "outlined",\n                children: route.icon\n              }),\n              primaryText: route.title,\n              activeClassName: "mdc-list-item--activated"\n            }, route.url);\n          })\n        })\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)("main", {\n      className: "app-content mdc-drawer-app-content",\n      children: /*#__PURE__*/(0,jsx_runtime.jsxs)(Switch, {\n        children: [/*#__PURE__*/(0,jsx_runtime.jsx)(Route, {\n          exact: true,\n          path: "/",\n          component: HomePage\n        }), routes.map(function (route) {\n          return /*#__PURE__*/(0,jsx_runtime.jsx)(Route, {\n            path: route.url,\n            exact: route.exact,\n            component: route.component\n          }, route.url);\n        })]\n      })\n    })]\n  });\n}\n;// CONCATENATED MODULE: ./docs/src/index.js\n\n\n\n\n\nvar basename = {"WEBPACK_BUNDLE":true,"WEBPACK_BUILD":true,"production":true}.production ? \'mdc-react\' : undefined;\n(0,react_dom.render)( /*#__PURE__*/(0,jsx_runtime.jsx)(BrowserRouter, {\n  basename: basename,\n  children: /*#__PURE__*/(0,jsx_runtime.jsx)(App, {})\n}), document.querySelector(\'#root\'));//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTI5LmpzIiwibWFwcGluZ3MiOiI7O0FBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEM7O0FDUGlEO0FBQ2xDO0FBQ2Y7QUFDQTtBQUNBLEVBQUUsZUFBYztBQUNoQixDOzs7Ozs7O0FDTGUsU0FBUyxlQUFRO0FBQ2hDLEVBQUUsZUFBUTtBQUNWLG9CQUFvQixzQkFBc0I7QUFDMUM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsU0FBUyxlQUFRO0FBQ2pCLEM7O0FDaEJBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0RBQWtELE9BQU87QUFDekQ7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBLGlDQUFpQyxRQUFRO0FBQ3pDOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwwQkFBMEIsTUFBTTs7QUFFaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsdURBQWUsZUFBZSxFQUFDOzs7QUMxRS9CLG1CQUFtQixZQUFvQjtBQUN2QztBQUNBLFNBQVMsNEJBQVM7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx5REFBZSw0QkFBUyxFQUFDOzs7QUNaaUM7QUFDWDtBQUNWO0FBQ0Y7QUFDSTs7QUFFdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsU0FBUyxzQkFBYztBQUN2Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLGVBQWUsZUFBUSxHQUFHO0FBQzFCOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLDBCQUEwQixnQkFBZTtBQUN6QztBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTLHlCQUFpQjtBQUMxQjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJLE1BQXFDLEdBQUcsQ0FBdUU7QUFDbkg7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLFVBQVUsTUFBcUMsR0FBRyxDQUFpRztBQUNuSjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0Esd0VBQXdFLGFBQWE7QUFDckY7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZUFBZSxNQUFxQyxHQUFHLENBQStDLEdBQUcsa0JBQVM7QUFDbEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLE1BQXFDLEdBQUcsQ0FBd047QUFDcFE7QUFDQSxXQUFXLHNCQUFjO0FBQ3pCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLElBQUksZUFBUTs7QUFFWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFVBQVU7QUFDVjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx1Q0FBdUM7O0FBRXZDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUksTUFBcUMsR0FBRyxDQUE2TztBQUN6UjtBQUNBLG1CQUFtQixzQkFBYztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsUUFBUTtBQUNSLFFBQVEsTUFBcUMsR0FBRyxDQUErRztBQUMvSjtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0EsSUFBSSxNQUFxQyxHQUFHLENBQWdQO0FBQzVSO0FBQ0EsbUJBQW1CLHNCQUFjO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLFFBQVE7QUFDUixRQUFRLE1BQXFDLEdBQUcsQ0FBa0g7QUFDbEs7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVB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QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0EsZ0JBQWdCO0FBQ2hCLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxRQUFRO0FBQ1I7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGlCQUFpQjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsWUFBWTtBQUNaO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFlBQVk7QUFDWjtBQUNBLGdCQUFnQiwwQ0FBMEM7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLGdEQUFnRDtBQUMxRjtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EscUJBQXFCLHFCQUFxQjtBQUMxQztBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwyREFBZSxVQUFVLEVBQUM7OztBQzFyQjFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLDRCQUE0QixFQUFFLGFBQWEsRUFBRTtBQUM3QyxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FB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QVEsR0FBR0MsOERBQUEsQ0FBZ0JHLFVBQWhCLEdBQTZCLFdBQTdCLEdBQTJDbHZDLFNBQTVEO0FBRUE2dUMsb0JBQU0sZUFDRixvQkFBQyxhQUFEO0FBQVEsVUFBUSxFQUFFQyxRQUFsQjtBQUFBLHlCQUNJLG9CQUFDLEdBQUQ7QUFESixFQURFLEVBSUYxZ0MsUUFBUSxDQUFDZ1ksYUFBVCxDQUF1QixPQUF2QixDQUpFLENBQU4iLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vc2V0UHJvdG90eXBlT2YuanM/MDZkMCIsIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vaW5oZXJpdHNMb29zZS5qcz85M2JkIiwid2VicGFjazovL21kYy1yZWFjdC8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9leHRlbmRzLmpzP2M3NGUiLCJ3ZWJwYWNrOi8vbWRjLXJlYWN0Ly4vbm9kZV9tb2R1bGVzL3Jlc29sdmUtcGF0aG5hbWUvZXNtL3Jlc29sdmUtcGF0aG5hbWUuanM/OTQyMSIsIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9ub2RlX21vZHVsZXMvdGlueS1pbnZhcmlhbnQvZGlzdC90aW55LWludmFyaWFudC5lc20uanM/ZjUxZiIsIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9ub2RlX21vZHVsZXMvaGlzdG9yeS9lc20vaGlzdG9yeS5qcz8yZTEwIiwid2VicGFjazovL21kYy1yZWFjdC8uL25vZGVfbW9kdWxlcy9taW5pLWNyZWF0ZS1yZWFjdC1jb250ZXh0L2Rpc3QvZXNtL2luZGV4LmpzP2I0NDgiLCJ3ZWJwYWNrOi8vbWRjLXJlYWN0Ly4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UuanM/YWFjNCIsIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyL2VzbS9yZWFjdC1yb3V0ZXIuanM/NGYyZSIsIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyLWRvbS9lc20vcmVhY3Qtcm91dGVyLWRvbS5qcz9lNzkyIiwid2VicGFjazovL21kYy1yZWFjdC8uL3NyYy9jb21wb25lbnQuanM/YTI5MCIsIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9zcmMvaWNvbi9jb25zdGFudHMuanM/YjRkZSIsIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9zcmMvaWNvbi9JY29uLmpzeD8zYmI5Iiwid2VicGFjazovL21kYy1yZWFjdC8uL3NyYy9pY29uL2luZGV4LmpzP2E2YTUiLCJ3ZWJwYWNrOi8vbWRjLXJlYWN0Ly4vc3JjL2F2YXRhci9jb25zdGFudHMuanM/YmZlZSIsIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9zcmMvYXZhdGFyL0F2YXRhci5qc3g/M2IwMCIsIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9zcmMvYXZhdGFyL2luZGV4LmpzP2VkNzEiLCJ3ZWJwYWNrOi8vbWRjLXJlYWN0Ly4vc3JjL2JhZGdlL2NvbnN0YW50cy5qcz80ZjQ5Iiwid2VicGFjazovL21kYy1yZWFjdC8uL3NyYy9iYWRnZS9CYWRnZS5qc3g/NzY1MSIsIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9zcmMvYmFkZ2UvaW5kZXguanM/Y2IwYyIsIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9ub2RlX21vZHVsZXMvZG9tLWhlbHBlcnMvZXNtL2hhc0NsYXNzLmpzPzI5NzUiLCJ3ZWJwYWNrOi8vbWRjLXJlYWN0Ly4vbm9kZV9tb2R1bGVzL2RvbS1oZWxwZXJzL2VzbS9hZGRDbGFzcy5qcz83NjkzIiwid2VicGFjazovL21kYy1yZWFjdC8uL25vZGVfbW9kdWxlcy9kb20taGVscGVycy9lc20vcmVtb3ZlQ2xhc3MuanM/ZDVhOSIsIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9ub2RlX21vZHVsZXMvcmVhY3QtdHJhbnNpdGlvbi1ncm91cC9lc20vY29uZmlnLmpzPzJhNDIiLCJ3ZWJwYWNrOi8vbWRjLXJlYWN0Ly4vbm9kZV9tb2R1bGVzL3JlYWN0LXRyYW5zaXRpb24tZ3JvdXAvZXNtL1RyYW5zaXRpb25Hcm91cENvbnRleHQuanM/ZDBmNCIsIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9ub2RlX21vZHVsZXMvcmVhY3QtdHJhbnNpdGlvbi1ncm91cC9lc20vVHJhbnNpdGlvbi5qcz83NTFiIiwid2VicGFjazovL21kYy1yZWFjdC8uL25vZGVfbW9kdWxlcy9yZWFjdC10cmFuc2l0aW9uLWdyb3VwL2VzbS9DU1NUcmFuc2l0aW9uLmpzP2E1MGYiLCJ3ZWJwYWNrOi8vbWRjLXJlYWN0Ly4vc3JjL2Jhbm5lci9jb25zdGFudHMuanM/ZDg4OCIsIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9zcmMvYmFubmVyL0Jhbm5lci5qc3g/ZTIyYiIsIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9zcmMvYmFubmVyL2luZGV4LmpzP2M4MGEiLCJ3ZWJwYWNrOi8vbWRjLXJlYWN0Ly4vc3JjL2J1dHRvbi9jb25zdGFudHMuanM/ZTU2NCIsIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9zcmMvYnV0dG9uL0J1dHRvbi5qc3g/YmFkNCIsIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9zcmMvYnV0dG9uL2luZGV4LmpzPzIwOGYiLCJ3ZWJwYWNrOi8vbWRjLXJlYWN0Ly4vc3JjL2NhcmQvY29uc3RhbnRzLmpzP2UxN2YiLCJ3ZWJwYWNrOi8vbWRjLXJlYWN0Ly4vc3JjL2NhcmQvQ2FyZC5qc3g/NDE1MiIsIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9zcmMvY2FyZC9DYXJkQWN0aW9uLmpzeD9iZGZmIiwid2VicGFjazovL21kYy1yZWFjdC8uL3NyYy9jYXJkL0NhcmRBY3Rpb25zLmpzeD9jZjU0Iiwid2VicGFjazovL21kYy1yZWFjdC8uL3NyYy9jYXJkL0NhcmRBY3Rpb25CdXR0b25zLmpzeD8yZjRlIiwid2VicGFjazovL21kYy1yZWFjdC8uL3NyYy9jYXJkL0NhcmRBY3Rpb25JY29ucy5qc3g/NWNlOSIsIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9zcmMvY2FyZC9DYXJkSGVhZGVyLmpzeD8wMTBlIiwid2VicGFjazovL21kYy1yZWFjdC8uL3NyYy9jYXJkL0NhcmRNZWRpYS5qc3g/ODc5OSIsIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9zcmMvY2FyZC9DYXJkUHJpbWFyeUFjdGlvbi5qc3g/NDkwNyIsIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9zcmMvY2FyZC9DYXJkU2VjdGlvbi5qc3g/Zjk5NSIsIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9zcmMvY2FyZC9pbmRleC5qcz81MjNlIiwid2VicGFjazovL21kYy1yZWFjdC8uL3NyYy9jaGVja2JveC9jb25zdGFudHMuanM/ZDhjMSIsIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9zcmMvY2hlY2tib3gvQ2hlY2tib3guanN4PzMyMWMiLCJ3ZWJwYWNrOi8vbWRjLXJlYWN0Ly4vc3JjL2NoZWNrYm94L2luZGV4LmpzPzEwZmIiLCJ3ZWJwYWNrOi8vbWRjLXJlYWN0Ly4vc3JjL2NoaXBzL2NvbnN0YW50cy5qcz82ZjY2Iiwid2VicGFjazovL21kYy1yZWFjdC8uL3NyYy9jaGlwcy9DaGlwUHJpbWFyeUFjdGlvbi5qc3g/YjFiNSIsIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9zcmMvY2hpcHMvQ2hpcFRyYWlsaW5nQWN0aW9uLmpzeD8zZTcwIiwid2VicGFjazovL21kYy1yZWFjdC8uL3NyYy9jaGlwcy9DaGlwLmpzeD9hMzVkIiwid2VicGFjazovL21kYy1yZWFjdC8uL3NyYy90eXBlcy5qcz82NzkyIiwid2VicGFjazovL21kYy1yZWFjdC8uL3NyYy9jaGlwcy9DaGlwU2V0LmpzeD9mMGI1Iiwid2VicGFjazovL21kYy1yZWFjdC8uL3NyYy9jaGlwcy9pbmRleC5qcz9kYTQ1Iiwid2VicGFjazovL21kYy1yZWFjdC8uL3NyYy9jaXJjdWxhci1wcm9ncmVzcy9jb25zdGFudHMuanM/MTMwOSIsIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9zcmMvY2lyY3VsYXItcHJvZ3Jlc3MvQ2lyY3VsYXJQcm9ncmVzcy5qc3g/MjBhYSIsIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9zcmMvY2lyY3VsYXItcHJvZ3Jlc3MvaW5kZXguanM/MWI1NCIsIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9zcmMvaWNvbi1idXR0b24vY29uc3RhbnRzLmpzPzIxZTYiLCJ3ZWJwYWNrOi8vbWRjLXJlYWN0Ly4vc3JjL2ljb24tYnV0dG9uL0ljb25CdXR0b24uanN4Pzg0ZmYiLCJ3ZWJwYWNrOi8vbWRjLXJlYWN0Ly4vc3JjL2ljb24tYnV0dG9uL2luZGV4LmpzPzE5YjIiLCJ3ZWJwYWNrOi8vbWRjLXJlYWN0Ly4vc3JjL2xpbmVhci1wcm9ncmVzcy9jb25zdGFudHMuanM/NWU5YiIsIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9zcmMvbGluZWFyLXByb2dyZXNzL0xpbmVhclByb2dyZXNzLmpzeD9kYTJiIiwid2VicGFjazovL21kYy1yZWFjdC8uL3NyYy9saW5lYXItcHJvZ3Jlc3MvaW5kZXguanM/Yzk0OCIsIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9zcmMvZGF0YS10YWJsZS9jb25zdGFudHMuanM/YjRjNyIsIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9zcmMvZGF0YS10YWJsZS9EYXRhVGFibGVQcm9ncmVzc0luZGljYXRvci5qc3g/MTUyOSIsIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9zcmMvZmxvYXRpbmctbGFiZWwvY29uc3RhbnRzLmpzPzVlNDQiLCJ3ZWJwYWNrOi8vbWRjLXJlYWN0Ly4vc3JjL2Zsb2F0aW5nLWxhYmVsL0Zsb2F0aW5nTGFiZWwuanN4PzQ5YTciLCJ3ZWJwYWNrOi8vbWRjLXJlYWN0Ly4vc3JjL2Zsb2F0aW5nLWxhYmVsL2luZGV4LmpzPzdkYmQiLCJ3ZWJwYWNrOi8vbWRjLXJlYWN0Ly4vc3JjL2xpbmUtcmlwcGxlL2NvbnN0YW50cy5qcz8zYzcwIiwid2VicGFjazovL21kYy1yZWFjdC8uL3NyYy9saW5lLXJpcHBsZS9MaW5lUmlwcGxlLmpzeD80NzUyIiwid2VicGFjazovL21kYy1yZWFjdC8uL3NyYy9saW5lLXJpcHBsZS9pbmRleC5qcz8wYmM5Iiwid2VicGFjazovL21kYy1yZWFjdC8uL3NyYy9jb25zdGFudHMuanM/NWZiMCIsIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9zcmMvdXRpbHMuanM/MDI1ZSIsIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9zcmMvbm90Y2hlZC1vdXRsaW5lL2NvbnN0YW50cy5qcz9jYjhkIiwid2VicGFjazovL21kYy1yZWFjdC8uL3NyYy9ub3RjaGVkLW91dGxpbmUvTm90Y2hlZE91dGxpbmUuanN4PzY5ZTkiLCJ3ZWJwYWNrOi8vbWRjLXJlYWN0Ly4vc3JjL25vdGNoZWQtb3V0bGluZS9pbmRleC5qcz9kNjdlIiwid2VicGFjazovL21kYy1yZWFjdC8uL3NyYy9tZW51L2NvbnN0YW50cy5qcz9hYzQwIiwid2VicGFjazovL21kYy1yZWFjdC8uL3NyYy9ob29rcy5qcz9mNzEwIiwid2VicGFjazovL21kYy1yZWFjdC8uL3NyYy9saXN0L2NvbnN0YW50cy5qcz84ODhmIiwid2VicGFjazovL21kYy1yZWFjdC8uL3NyYy9saXN0L0xpc3RJdGVtQ29udGVudC5qc3g/YzlhYiIsIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9zcmMvbGlzdC9MaXN0SXRlbUVuZC5qc3g/M2I1ZSIsIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9zcmMvbGlzdC9MaXN0SXRlbVN0YXJ0LmpzeD84YmNlIiwid2VicGFjazovL21kYy1yZWFjdC8uL3NyYy9saXN0L0xpc3RJdGVtLmpzeD81MmQxIiwid2VicGFjazovL21kYy1yZWFjdC8uL3NyYy9saXN0L0xpc3QuanN4PzNlYjkiLCJ3ZWJwYWNrOi8vbWRjLXJlYWN0Ly4vc3JjL2xpc3QvTGlzdERpdmlkZXIuanN4PzNiYmEiLCJ3ZWJwYWNrOi8vbWRjLXJlYWN0Ly4vc3JjL2xpc3QvTGlzdEdyb3VwLmpzeD9iNmY2Iiwid2VicGFjazovL21kYy1yZWFjdC8uL3NyYy9saXN0L0xpc3RHcm91cFN1YmhlYWRlci5qc3g/MjllNSIsIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9zcmMvbGlzdC9pbmRleC5qcz81MzU0Iiwid2VicGFjazovL21kYy1yZWFjdC8uL3NyYy9tZW51L01lbnVJdGVtLmpzeD8zNGNhIiwid2VicGFjazovL21kYy1yZWFjdC8uL3NyYy9tb2RhbC9jb25zdGFudHMuanM/NmQ1MyIsIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9zcmMvbW9kYWwvTW9kYWwuanN4PzYzZmMiLCJ3ZWJwYWNrOi8vbWRjLXJlYWN0Ly4vc3JjL21vZGFsL2luZGV4LmpzPzdlNjgiLCJ3ZWJwYWNrOi8vbWRjLXJlYWN0Ly4vc3JjL2xheWVyL0xheWVyLmpzeD8zMjQxIiwid2VicGFjazovL21kYy1yZWFjdC8uL3NyYy9sYXllci9pbmRleC5qcz9kY2VlIiwid2VicGFjazovL21kYy1yZWFjdC8uL3NyYy9tZW51L3V0aWxzLmpzP2I4OWYiLCJ3ZWJwYWNrOi8vbWRjLXJlYWN0Ly4vc3JjL21lbnUvTWVudVN1cmZhY2UuanN4P2Y4MTIiLCJ3ZWJwYWNrOi8vbWRjLXJlYWN0Ly4vc3JjL21lbnUvTWVudS5qc3g/MDEzYSIsIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9zcmMvbWVudS9NZW51QW5jaG9yLmpzeD82ZjEwIiwid2VicGFjazovL21kYy1yZWFjdC8uL3NyYy9tZW51L01lbnVTZWxlY3Rpb25Hcm91cC5qc3g/MDkxMCIsIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9zcmMvbWVudS9NZW51U2VsZWN0aW9uR3JvdXBJY29uLmpzeD9mYTY4Iiwid2VicGFjazovL21kYy1yZWFjdC8uL3NyYy9tZW51L2luZGV4LmpzPzhmNTQiLCJ3ZWJwYWNrOi8vbWRjLXJlYWN0Ly4vc3JjL3NlbGVjdC9jb25zdGFudHMuanM/ZmVhOSIsIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9zcmMvc2VsZWN0L0Ryb3Bkb3duSWNvbi5qc3g/Yjc4NSIsIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9zcmMvc2VsZWN0L1NlbGVjdE9wdGlvbi5qc3g/YTZhYyIsIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9zcmMvc2VsZWN0L0hlbHBlclRleHQuanN4PzZlNTIiLCJ3ZWJwYWNrOi8vbWRjLXJlYWN0Ly4vc3JjL3NlbGVjdC9TZWxlY3QuanN4P2NkMTQiLCJ3ZWJwYWNrOi8vbWRjLXJlYWN0Ly4vc3JjL3NlbGVjdC9pbmRleC5qcz85Y2RkIiwid2VicGFjazovL21kYy1yZWFjdC8uL3NyYy9kYXRhLXRhYmxlL0RhdGFUYWJsZVBhZ2luYXRpb24uanN4PzI0YmEiLCJ3ZWJwYWNrOi8vbWRjLXJlYWN0Ly4vc3JjL2RhdGEtdGFibGUvRGF0YVRhYmxlLmpzeD8yMzU5Iiwid2VicGFjazovL21kYy1yZWFjdC8uL3NyYy9kYXRhLXRhYmxlL0RhdGFUYWJsZUNlbGwuanN4P2RhZWYiLCJ3ZWJwYWNrOi8vbWRjLXJlYWN0Ly4vc3JjL2RhdGEtdGFibGUvRGF0YVRhYmxlQ29udGVudC5qc3g/YjcxZiIsIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9zcmMvZGF0YS10YWJsZS9EYXRhVGFibGVGb290ZXIuanN4P2VjZWEiLCJ3ZWJwYWNrOi8vbWRjLXJlYWN0Ly4vc3JjL2RhdGEtdGFibGUvRGF0YVRhYmxlSGVhZGVyLmpzeD8xMDY0Iiwid2VicGFjazovL21kYy1yZWFjdC8uL3NyYy9kYXRhLXRhYmxlL0RhdGFUYWJsZUhlYWRlckNlbGwuanN4PzI4ZGQiLCJ3ZWJwYWNrOi8vbWRjLXJlYWN0Ly4vc3JjL2RhdGEtdGFibGUvRGF0YVRhYmxlSGVhZGVyUm93LmpzeD9hMjEwIiwid2VicGFjazovL21kYy1yZWFjdC8uL3NyYy9kYXRhLXRhYmxlL0RhdGFUYWJsZVJvdy5qc3g/MWE5ZiIsIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9zcmMvZGF0YS10YWJsZS9pbmRleC5qcz9kOGU3Iiwid2VicGFjazovL21kYy1yZWFjdC8uL3NyYy9kaWFsb2cvY29uc3RhbnRzLmpzP2I0MjkiLCJ3ZWJwYWNrOi8vbWRjLXJlYWN0Ly4vc3JjL2RpYWxvZy9EaWFsb2dIZWFkZXIuanN4PzcyMTEiLCJ3ZWJwYWNrOi8vbWRjLXJlYWN0Ly4vc3JjL2RpYWxvZy9EaWFsb2dDb250ZW50LmpzeD9mZDU3Iiwid2VicGFjazovL21kYy1yZWFjdC8uL3NyYy9kaWFsb2cvRGlhbG9nQWN0aW9ucy5qc3g/MTk1MiIsIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9zcmMvZGlhbG9nL0RpYWxvZy5qc3g/YzJiNSIsIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9zcmMvZGlhbG9nL2luZGV4LmpzPzRkODMiLCJ3ZWJwYWNrOi8vbWRjLXJlYWN0Ly4vc3JjL2RyYXdlci9jb25zdGFudHMuanM/OWQ2OSIsIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9zcmMvZHJhd2VyL0RyYXdlci5qc3g/NTBhYyIsIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9zcmMvZHJhd2VyL0RyYXdlckhlYWRlci5qc3g/NGM0OCIsIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9zcmMvZHJhd2VyL0RyYXdlckNvbnRlbnQuanN4P2E0NjYiLCJ3ZWJwYWNrOi8vbWRjLXJlYWN0Ly4vc3JjL2RyYXdlci9pbmRleC5qcz83MDgzIiwid2VicGFjazovL21kYy1yZWFjdC8uL3NyYy9lbGV2YXRpb24vY29uc3RhbnRzLmpzPzY1NWQiLCJ3ZWJwYWNrOi8vbWRjLXJlYWN0Ly4vc3JjL2VsZXZhdGlvbi9FbGV2YXRpb24uanN4P2M0MmIiLCJ3ZWJwYWNrOi8vbWRjLXJlYWN0Ly4vc3JjL2VsZXZhdGlvbi9pbmRleC5qcz84OGVhIiwid2VicGFjazovL21kYy1yZWFjdC8uL3NyYy9mYWIvY29uc3RhbnRzLmpzPzQ3NGYiLCJ3ZWJwYWNrOi8vbWRjLXJlYWN0Ly4vc3JjL2ZhYi9GQUIuanN4Pzg1NzgiLCJ3ZWJwYWNrOi8vbWRjLXJlYWN0Ly4vc3JjL2ZhYi9pbmRleC5qcz9hZjc4Iiwid2VicGFjazovL21kYy1yZWFjdC8uL3NyYy9mb3JtLWZpZWxkL2NvbnN0YW50cy5qcz85ZjlmIiwid2VicGFjazovL21kYy1yZWFjdC8uL3NyYy9mb3JtLWZpZWxkL0Zvcm1GaWVsZC5qc3g/ODUyOCIsIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9zcmMvZm9ybS1maWVsZC9pbmRleC5qcz81ZWQyIiwid2VicGFjazovL21kYy1yZWFjdC8uL3NyYy9pbWFnZS1saXN0L2NvbnN0YW50cy5qcz9hN2E3Iiwid2VicGFjazovL21kYy1yZWFjdC8uL3NyYy9pbWFnZS1saXN0L0ltYWdlTGlzdEl0ZW0uanN4PzM2NDQiLCJ3ZWJwYWNrOi8vbWRjLXJlYWN0Ly4vc3JjL2ltYWdlLWxpc3QvSW1hZ2VMaXN0LmpzeD9kZjEzIiwid2VicGFjazovL21kYy1yZWFjdC8uL3NyYy9pbWFnZS1saXN0L2luZGV4LmpzPzVhYmMiLCJ3ZWJwYWNrOi8vbWRjLXJlYWN0Ly4vc3JjL2xheW91dC9jb25zdGFudHMuanM/MjdkNSIsIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9zcmMvbGF5b3V0L0xheW91dC5qc3g/YjQwMSIsIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9zcmMvbGF5b3V0L2luZGV4LmpzP2YzNzYiLCJ3ZWJwYWNrOi8vbWRjLXJlYWN0Ly4vc3JjL2xheW91dC1ncmlkL2NvbnN0YW50cy5qcz9hODYxIiwid2VicGFjazovL21kYy1yZWFjdC8uL3NyYy9sYXlvdXQtZ3JpZC9MYXlvdXRHcmlkLmpzeD9lNWFhIiwid2VicGFjazovL21kYy1yZWFjdC8uL3NyYy9sYXlvdXQtZ3JpZC9MYXlvdXRHcmlkQ2VsbC5qc3g/ZTY3MyIsIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9zcmMvbGF5b3V0LWdyaWQvaW5kZXguanM/ZGMxMiIsIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9zcmMvcmFkaW8vY29uc3RhbnRzLmpzPzY2NjQiLCJ3ZWJwYWNrOi8vbWRjLXJlYWN0Ly4vc3JjL3JhZGlvL1JhZGlvLmpzeD8xZmFlIiwid2VicGFjazovL21kYy1yZWFjdC8uL3NyYy9yYWRpby9pbmRleC5qcz8yNzkyIiwid2VicGFjazovL21kYy1yZWFjdC8uL25vZGVfbW9kdWxlcy90c2xpYi90c2xpYi5lczYuanM/OWFiNCIsIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL2Jhc2UvZm91bmRhdGlvbi5qcz82Njg5Iiwid2VicGFjazovL21kYy1yZWFjdC8uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvYmFzZS9jb21wb25lbnQuanM/ODEzNiIsIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL2RvbS9ldmVudHMuanM/OTM3MyIsIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL2RvbS9wb255ZmlsbC5qcz9kODdmIiwid2VicGFjazovL21kYy1yZWFjdC8uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvcmlwcGxlL2NvbnN0YW50cy5qcz82NDVlIiwid2VicGFjazovL21kYy1yZWFjdC8uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvcmlwcGxlL3V0aWwuanM/MWRmYyIsIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL3JpcHBsZS9mb3VuZGF0aW9uLmpzPzQzMDMiLCJ3ZWJwYWNrOi8vbWRjLXJlYWN0Ly4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC9yaXBwbGUvY29tcG9uZW50LmpzPzQwZmYiLCJ3ZWJwYWNrOi8vbWRjLXJlYWN0Ly4vc3JjL3JpcHBsZS9SaXBwbGUuanN4PzFmNmYiLCJ3ZWJwYWNrOi8vbWRjLXJlYWN0Ly4vc3JjL3JpcHBsZS9jb25zdGFudHMuanM/NTRiMCIsIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9zcmMvcmlwcGxlL2hvb2tzLmpzPzg3MDQiLCJ3ZWJwYWNrOi8vbWRjLXJlYWN0Ly4vc3JjL3JpcHBsZS9SaXBwbGVTdXJmYWNlLmpzeD8wYzA4Iiwid2VicGFjazovL21kYy1yZWFjdC8uL3NyYy9yaXBwbGUvaW5kZXguanM/OTQyMiIsIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9zcmMvc2VnbWVudGVkLWJ1dHRvbi9jb25zdGFudHMuanM/NzM0ZiIsIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9zcmMvc2VnbWVudGVkLWJ1dHRvbi9TZWdtZW50ZWRCdXR0b25TZWdtZW50LmpzeD8xNDc4Iiwid2VicGFjazovL21kYy1yZWFjdC8uL3NyYy9zZWdtZW50ZWQtYnV0dG9uL1NlZ21lbnRlZEJ1dHRvbi5qc3g/NThjZiIsIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9zcmMvc2VnbWVudGVkLWJ1dHRvbi9pbmRleC5qcz8wNzM4Iiwid2VicGFjazovL21kYy1yZWFjdC8uL3NyYy9zaWRlLXNoZWV0L2NvbnN0YW50cy5qcz8yMTg2Iiwid2VicGFjazovL21kYy1yZWFjdC8uL3NyYy9zaWRlLXNoZWV0L1NpZGVTaGVldEhlYWRlci5qc3g/MzBlNiIsIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9zcmMvc2lkZS1zaGVldC9TaWRlU2hlZXRDb250ZW50LmpzeD85MjFhIiwid2VicGFjazovL21kYy1yZWFjdC8uL3NyYy9zaWRlLXNoZWV0L1NpZGVTaGVldC5qc3g/NjJjNCIsIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9zcmMvc2lkZS1zaGVldC9TaWRlU2hlZXRBcHBDb250ZW50LmpzeD9lZTkzIiwid2VicGFjazovL21kYy1yZWFjdC8uL3NyYy9zaWRlLXNoZWV0L2luZGV4LmpzPzU1NGIiLCJ3ZWJwYWNrOi8vbWRjLXJlYWN0Ly4vc3JjL3NsaWRlci9jb25zdGFudHMuanM/OTIzNCIsIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9zcmMvc2xpZGVyL3V0aWxzLmpzPzY0ZmEiLCJ3ZWJwYWNrOi8vbWRjLXJlYWN0Ly4vc3JjL3NsaWRlci9JbnB1dC5qc3g/NGU0MSIsIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9zcmMvc2xpZGVyL1RpY2tNYXJrcy5qc3g/MzMxMyIsIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9zcmMvc2xpZGVyL1RyYWNrLmpzeD84NjdiIiwid2VicGFjazovL21kYy1yZWFjdC8uL3NyYy9zbGlkZXIvVGh1bWIuanN4PzRmYjUiLCJ3ZWJwYWNrOi8vbWRjLXJlYWN0Ly4vc3JjL3NsaWRlci9TbGlkZXIuanN4PzBmYTAiLCJ3ZWJwYWNrOi8vbWRjLXJlYWN0Ly4vc3JjL3NsaWRlci9pbmRleC5qcz82ZTE1Iiwid2VicGFjazovL21kYy1yZWFjdC8uL3NyYy9zbmFja2Jhci9jb25zdGFudHMuanM/YTBhNCIsIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9zcmMvc25hY2tiYXIvU25hY2tiYXIuanN4PzJkZDAiLCJ3ZWJwYWNrOi8vbWRjLXJlYWN0Ly4vc3JjL3NuYWNrYmFyL2luZGV4LmpzP2Q4MDciLCJ3ZWJwYWNrOi8vbWRjLXJlYWN0Ly4vc3JjL3N3aXRjaC9jb25zdGFudHMuanM/YzBhZCIsIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9zcmMvc3dpdGNoL1N3aXRjaC5qc3g/ZjEzYiIsIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9zcmMvc3dpdGNoL2luZGV4LmpzPzc3ZTgiLCJ3ZWJwYWNrOi8vbWRjLXJlYWN0Ly4vc3JjL3N5bWJvbC9jb25zdGFudHMuanM/MzAzNSIsIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9zcmMvc3ltYm9sL3V0aWxzLmpzPzRlYjIiLCJ3ZWJwYWNrOi8vbWRjLXJlYWN0Ly4vc3JjL3N5bWJvbC9TeW1ib2wuanN4PzMyZDAiLCJ3ZWJwYWNrOi8vbWRjLXJlYWN0Ly4vc3JjL3N5bWJvbC9pbmRleC5qcz81OWFjIiwid2VicGFjazovL21kYy1yZWFjdC8uL3NyYy90YWJzL2NvbnN0YW50cy5qcz9iNGNlIiwid2VicGFjazovL21kYy1yZWFjdC8uL3NyYy90YWJzL2NvbnRleHQuanM/MWU1YSIsIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9zcmMvdGFicy9UYWJJbmRpY2F0b3IuanN4P2ZhYTkiLCJ3ZWJwYWNrOi8vbWRjLXJlYWN0Ly4vc3JjL3RhYnMvVGFiLmpzeD80NWQwIiwid2VicGFjazovL21kYy1yZWFjdC8uL3NyYy90YWJzL1RhYlNjcm9sbGVyLmpzeD9mNjA2Iiwid2VicGFjazovL21kYy1yZWFjdC8uL3NyYy90YWJzL1RhYkJhci5qc3g/YTZhNSIsIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9zcmMvdGFicy9pbmRleC5qcz9mMjM1Iiwid2VicGFjazovL21kYy1yZWFjdC8uL3NyYy90b29sdGlwL2NvbnN0YW50cy5qcz8zODhkIiwid2VicGFjazovL21kYy1yZWFjdC8uL3NyYy90b29sdGlwL1Rvb2x0aXAuanN4PzI0NmIiLCJ3ZWJwYWNrOi8vbWRjLXJlYWN0Ly4vc3JjL3Rvb2x0aXAvUmljaFRvb2x0aXAuanN4P2MwNTMiLCJ3ZWJwYWNrOi8vbWRjLXJlYWN0Ly4vc3JjL3Rvb2x0aXAvaW5kZXguanM/MjY5MSIsIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9zcmMvdGV4dC1maWVsZC9jb25zdGFudHMuanM/MGExYyIsIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9zcmMvdGV4dC1maWVsZC9IZWxwZXJUZXh0LmpzeD9jNTA0Iiwid2VicGFjazovL21kYy1yZWFjdC8uL3NyYy90ZXh0LWZpZWxkL0NoYXJhY3RlckNvdW50ZXIuanN4PzdmMjAiLCJ3ZWJwYWNrOi8vbWRjLXJlYWN0Ly4vc3JjL3RleHQtZmllbGQvSW5wdXQuanN4PzZkMWQiLCJ3ZWJwYWNrOi8vbWRjLXJlYWN0Ly4vc3JjL3RleHQtZmllbGQvUmVzaXplci5qc3g/ZTU3OSIsIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9zcmMvdGV4dC1maWVsZC9UZXh0RmllbGQuanN4P2E2ZDkiLCJ3ZWJwYWNrOi8vbWRjLXJlYWN0Ly4vc3JjL3RleHQtZmllbGQvaW5kZXguanM/NWQwZiIsIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9zcmMvdG9wLWFwcC1iYXIvY29uc3RhbnRzLmpzPzE3YWQiLCJ3ZWJwYWNrOi8vbWRjLXJlYWN0Ly4vc3JjL3RvcC1hcHAtYmFyL1RvcEFwcEJhclJvdy5qc3g/NzEzNCIsIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9zcmMvdG9wLWFwcC1iYXIvVG9wQXBwQmFyU2VjdGlvbi5qc3g/ZjVlYSIsIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9zcmMvdG9wLWFwcC1iYXIvVG9wQXBwQmFyLmpzeD9lZTMzIiwid2VicGFjazovL21kYy1yZWFjdC8uL3NyYy90b3AtYXBwLWJhci9Ub3BBcHBCYXJBY3Rpb25JdGVtLmpzeD81Mjc2Iiwid2VicGFjazovL21kYy1yZWFjdC8uL3NyYy90b3AtYXBwLWJhci9Ub3BBcHBCYXJGaXhlZEFkanVzdC5qc3g/NWJlZCIsIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9zcmMvdG9wLWFwcC1iYXIvVG9wQXBwQmFyTmF2aWdhdGlvbkljb24uanN4PzlkMzYiLCJ3ZWJwYWNrOi8vbWRjLXJlYWN0Ly4vc3JjL3RvcC1hcHAtYmFyL1RvcEFwcEJhclRpdGxlLmpzeD83NmZhIiwid2VicGFjazovL21kYy1yZWFjdC8uL3NyYy90b3AtYXBwLWJhci9pbmRleC5qcz82MjY1Iiwid2VicGFjazovL21kYy1yZWFjdC8uL3NyYy90eXBvZ3JhcGh5L2NvbnN0YW50cy5qcz81MDg1Iiwid2VicGFjazovL21kYy1yZWFjdC8uL3NyYy90eXBvZ3JhcGh5L1R5cG9ncmFwaHkuanN4PzM1OTAiLCJ3ZWJwYWNrOi8vbWRjLXJlYWN0Ly4vc3JjL3R5cG9ncmFwaHkvaW5kZXguanM/NjNjNCIsIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9zcmMvaW5kZXguanM/YjYzNSIsIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9kb2NzL3NyYy91dGlscy9jb2RlLmpzPzc5ODYiLCJ3ZWJwYWNrOi8vbWRjLXJlYWN0Ly4vbm9kZV9tb2R1bGVzL2hpZ2hsaWdodC5qcy9lcy9jb3JlLmpzP2I3YjgiLCJ3ZWJwYWNrOi8vbWRjLXJlYWN0Ly4vbm9kZV9tb2R1bGVzL2hpZ2hsaWdodC5qcy9lcy9sYW5ndWFnZXMvamF2YXNjcmlwdC5qcz9hYzcxIiwid2VicGFjazovL21kYy1yZWFjdC8uL25vZGVfbW9kdWxlcy9oaWdobGlnaHQuanMvZXMvbGFuZ3VhZ2VzL3Njc3MuanM/MzhmMSIsIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9ub2RlX21vZHVsZXMvaGlnaGxpZ2h0LmpzL2VzL2xhbmd1YWdlcy9zaGVsbC5qcz83N2JiIiwid2VicGFjazovL21kYy1yZWFjdC8uL25vZGVfbW9kdWxlcy9oaWdobGlnaHQuanMvZXMvbGFuZ3VhZ2VzL3BsYWludGV4dC5qcz8wYTIxIiwid2VicGFjazovL21kYy1yZWFjdC8uL25vZGVfbW9kdWxlcy9oaWdobGlnaHQuanMvZXMvbGFuZ3VhZ2VzL3htbC5qcz8zNjMxIiwid2VicGFjazovL21kYy1yZWFjdC8uL2RvY3Mvc3JjL3V0aWxzL2hpZ2hsaWdodC5qcz8yMGQ5Iiwid2VicGFjazovL21kYy1yZWFjdC8uL2RvY3Mvc3JjL2NvbXBvbmVudHMvQ29kZS9pbmRleC5qc3g/YmQ1OCIsIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9kb2NzL3NyYy9jb21wb25lbnRzL0RlbW8vaW5kZXguanN4PzFlYTUiLCJ3ZWJwYWNrOi8vbWRjLXJlYWN0Ly4vZG9jcy9zcmMvY29tcG9uZW50cy9GaWVsZFNldC9pbmRleC5qc3g/MWQwNSIsIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9kb2NzL3NyYy9jb21wb25lbnRzL1BhZ2UvaW5kZXguanN4PzBkMjYiLCJ3ZWJwYWNrOi8vbWRjLXJlYWN0Ly4vZG9jcy9zcmMvcGFnZXMvQXZhdGFyL2luZGV4LmpzeD8wMmRhIiwid2VicGFjazovL21kYy1yZWFjdC8uL2RvY3Mvc3JjL3BhZ2VzL0JhZGdlL2luZGV4LmpzeD8yNTcyIiwid2VicGFjazovL21kYy1yZWFjdC8uL2RvY3Mvc3JjL3BhZ2VzL0Jhbm5lci9pbmRleC5qc3g/YTFmOSIsIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9kb2NzL3NyYy9wYWdlcy9CdXR0b24vaW5kZXguanN4PzBlNDYiLCJ3ZWJwYWNrOi8vbWRjLXJlYWN0Ly4vZG9jcy9zcmMvcGFnZXMvQ2FyZC9pbmRleC5qc3g/OGQ2ZiIsIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9kb2NzL3NyYy9wYWdlcy9DaGVja2JveC9pbmRleC5qc3g/ODJjNiIsIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9kb2NzL3NyYy9wYWdlcy9DaGlwcy9pbmRleC5qc3g/MDUzOCIsIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9kb2NzL3NyYy9wYWdlcy9DaXJjdWxhclByb2dyZXNzL2luZGV4LmpzeD9jODg1Iiwid2VicGFjazovL21kYy1yZWFjdC8uL2RvY3Mvc3JjL3BhZ2VzL0RhdGFUYWJsZS9pbmRleC5qc3g/NTlhZCIsIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9kb2NzL3NyYy9wYWdlcy9EaWFsb2cvaW5kZXguanN4PzYwMGYiLCJ3ZWJwYWNrOi8vbWRjLXJlYWN0Ly4vZG9jcy9zcmMvcGFnZXMvRHJhd2VyL2luZGV4LmpzeD9hODQ2Iiwid2VicGFjazovL21kYy1yZWFjdC8uL2RvY3Mvc3JjL3BhZ2VzL0VsZXZhdGlvbi9pbmRleC5qc3g/YjlkNCIsIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9kb2NzL3NyYy9wYWdlcy9GQUIvaW5kZXguanN4PzY5Y2MiLCJ3ZWJwYWNrOi8vbWRjLXJlYWN0Ly4vZG9jcy9zcmMvcGFnZXMvRm9ybUZpZWxkL2luZGV4LmpzeD85OTJjIiwid2VicGFjazovL21kYy1yZWFjdC8uL2RvY3Mvc3JjL3V0aWxzL21hcmtkb3duLmpzPzJiMDYiLCJ3ZWJwYWNrOi8vbWRjLXJlYWN0Ly4vZG9jcy9zcmMvcGFnZXMvSG9tZS9pbmRleC5qc3g/YTEwNCIsIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9kb2NzL3NyYy9wYWdlcy9JY29uL2luZGV4LmpzeD9iOTAzIiwid2VicGFjazovL21kYy1yZWFjdC8uL2RvY3Mvc3JjL3BhZ2VzL0ljb25CdXR0b24vaW5kZXguanN4P2RjZDEiLCJ3ZWJwYWNrOi8vbWRjLXJlYWN0Ly4vZG9jcy9zcmMvcGFnZXMvSW1hZ2VMaXN0L2luZGV4LmpzeD85YjAxIiwid2VicGFjazovL21kYy1yZWFjdC8uL2RvY3Mvc3JjL3BhZ2VzL0xheW91dEdyaWQvaW5kZXguanN4PzBlZjIiLCJ3ZWJwYWNrOi8vbWRjLXJlYWN0Ly4vZG9jcy9zcmMvcGFnZXMvTGluZWFyUHJvZ3Jlc3MvaW5kZXguanN4Pzc2ODQiLCJ3ZWJwYWNrOi8vbWRjLXJlYWN0Ly4vZG9jcy9zcmMvcGFnZXMvTGlzdC9pbmRleC5qc3g/ZGEzYiIsIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9kb2NzL3NyYy9wYWdlcy9NZW51L2luZGV4LmpzeD9kOWNlIiwid2VicGFjazovL21kYy1yZWFjdC8uL2RvY3Mvc3JjL3BhZ2VzL1JhZGlvL2luZGV4LmpzeD8xOTY2Iiwid2VicGFjazovL21kYy1yZWFjdC8uL2RvY3Mvc3JjL3BhZ2VzL1JpcHBsZS9pbmRleC5qc3g/YTk2MyIsIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9kb2NzL3NyYy9wYWdlcy9TZWdtZW50ZWRCdXR0b24vaW5kZXguanN4PzNkYmUiLCJ3ZWJwYWNrOi8vbWRjLXJlYWN0Ly4vZG9jcy9zcmMvcGFnZXMvU2VsZWN0L2luZGV4LmpzeD9kZmQxIiwid2VicGFjazovL21kYy1yZWFjdC8uL2RvY3Mvc3JjL3BhZ2VzL1NpZGVTaGVldC9pbmRleC5qc3g/OTM0NSIsIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9kb2NzL3NyYy9wYWdlcy9TbGlkZXIvaW5kZXguanN4P2FmODkiLCJ3ZWJwYWNrOi8vbWRjLXJlYWN0Ly4vZG9jcy9zcmMvcGFnZXMvU25hY2tiYXIvaW5kZXguanN4PzVhYjQiLCJ3ZWJwYWNrOi8vbWRjLXJlYWN0Ly4vZG9jcy9zcmMvcGFnZXMvU3dpdGNoL2luZGV4LmpzeD85Njc3Iiwid2VicGFjazovL21kYy1yZWFjdC8uL2RvY3Mvc3JjL3BhZ2VzL1N5bWJvbC9pbmRleC5qc3g/M2YwZiIsIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9kb2NzL3NyYy9wYWdlcy9UYWJzL2luZGV4LmpzeD9lYmRkIiwid2VicGFjazovL21kYy1yZWFjdC8uL2RvY3Mvc3JjL3BhZ2VzL1RleHRGaWVsZC9pbmRleC5qc3g/YmMxYSIsIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9kb2NzL3NyYy9wYWdlcy9Ub29sdGlwL2luZGV4LmpzeD85YjMzIiwid2VicGFjazovL21kYy1yZWFjdC8uL2RvY3Mvc3JjL3BhZ2VzL1RvcEFwcEJhci9pbmRleC5qc3g/Y2IzNSIsIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9kb2NzL3NyYy9wYWdlcy9UeXBvZ3JhcGh5L2luZGV4LmpzeD8wNDgzIiwid2VicGFjazovL21kYy1yZWFjdC8uL2RvY3Mvc3JjL3BhZ2VzL2luZGV4LmpzP2QxYTMiLCJ3ZWJwYWNrOi8vbWRjLXJlYWN0Ly4vZG9jcy9zcmMvcm91dGVzLmpzPzliNDUiLCJ3ZWJwYWNrOi8vbWRjLXJlYWN0Ly4vZG9jcy9zcmMvQXBwLmpzeD85NWJhIiwid2VicGFjazovL21kYy1yZWFjdC8uL2RvY3Mvc3JjL2luZGV4LmpzPzBiNTEiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHtcbiAgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7XG4gICAgby5fX3Byb3RvX18gPSBwO1xuICAgIHJldHVybiBvO1xuICB9O1xuXG4gIHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7XG59IiwiaW1wb3J0IHNldFByb3RvdHlwZU9mIGZyb20gXCIuL3NldFByb3RvdHlwZU9mLmpzXCI7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBfaW5oZXJpdHNMb29zZShzdWJDbGFzcywgc3VwZXJDbGFzcykge1xuICBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MucHJvdG90eXBlKTtcbiAgc3ViQ2xhc3MucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gc3ViQ2xhc3M7XG4gIHNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTtcbn0iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBfZXh0ZW5kcygpIHtcbiAgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTtcblxuICAgICAgZm9yICh2YXIga2V5IGluIHNvdXJjZSkge1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkge1xuICAgICAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9O1xuXG4gIHJldHVybiBfZXh0ZW5kcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufSIsImZ1bmN0aW9uIGlzQWJzb2x1dGUocGF0aG5hbWUpIHtcbiAgcmV0dXJuIHBhdGhuYW1lLmNoYXJBdCgwKSA9PT0gJy8nO1xufVxuXG4vLyBBYm91dCAxLjV4IGZhc3RlciB0aGFuIHRoZSB0d28tYXJnIHZlcnNpb24gb2YgQXJyYXkjc3BsaWNlKClcbmZ1bmN0aW9uIHNwbGljZU9uZShsaXN0LCBpbmRleCkge1xuICBmb3IgKHZhciBpID0gaW5kZXgsIGsgPSBpICsgMSwgbiA9IGxpc3QubGVuZ3RoOyBrIDwgbjsgaSArPSAxLCBrICs9IDEpIHtcbiAgICBsaXN0W2ldID0gbGlzdFtrXTtcbiAgfVxuXG4gIGxpc3QucG9wKCk7XG59XG5cbi8vIFRoaXMgaW1wbGVtZW50YXRpb24gaXMgYmFzZWQgaGVhdmlseSBvbiBub2RlJ3MgdXJsLnBhcnNlXG5mdW5jdGlvbiByZXNvbHZlUGF0aG5hbWUodG8sIGZyb20pIHtcbiAgaWYgKGZyb20gPT09IHVuZGVmaW5lZCkgZnJvbSA9ICcnO1xuXG4gIHZhciB0b1BhcnRzID0gKHRvICYmIHRvLnNwbGl0KCcvJykpIHx8IFtdO1xuICB2YXIgZnJvbVBhcnRzID0gKGZyb20gJiYgZnJvbS5zcGxpdCgnLycpKSB8fCBbXTtcblxuICB2YXIgaXNUb0FicyA9IHRvICYmIGlzQWJzb2x1dGUodG8pO1xuICB2YXIgaXNGcm9tQWJzID0gZnJvbSAmJiBpc0Fic29sdXRlKGZyb20pO1xuICB2YXIgbXVzdEVuZEFicyA9IGlzVG9BYnMgfHwgaXNGcm9tQWJzO1xuXG4gIGlmICh0byAmJiBpc0Fic29sdXRlKHRvKSkge1xuICAgIC8vIHRvIGlzIGFic29sdXRlXG4gICAgZnJvbVBhcnRzID0gdG9QYXJ0cztcbiAgfSBlbHNlIGlmICh0b1BhcnRzLmxlbmd0aCkge1xuICAgIC8vIHRvIGlzIHJlbGF0aXZlLCBkcm9wIHRoZSBmaWxlbmFtZVxuICAgIGZyb21QYXJ0cy5wb3AoKTtcbiAgICBmcm9tUGFydHMgPSBmcm9tUGFydHMuY29uY2F0KHRvUGFydHMpO1xuICB9XG5cbiAgaWYgKCFmcm9tUGFydHMubGVuZ3RoKSByZXR1cm4gJy8nO1xuXG4gIHZhciBoYXNUcmFpbGluZ1NsYXNoO1xuICBpZiAoZnJvbVBhcnRzLmxlbmd0aCkge1xuICAgIHZhciBsYXN0ID0gZnJvbVBhcnRzW2Zyb21QYXJ0cy5sZW5ndGggLSAxXTtcbiAgICBoYXNUcmFpbGluZ1NsYXNoID0gbGFzdCA9PT0gJy4nIHx8IGxhc3QgPT09ICcuLicgfHwgbGFzdCA9PT0gJyc7XG4gIH0gZWxzZSB7XG4gICAgaGFzVHJhaWxpbmdTbGFzaCA9IGZhbHNlO1xuICB9XG5cbiAgdmFyIHVwID0gMDtcbiAgZm9yICh2YXIgaSA9IGZyb21QYXJ0cy5sZW5ndGg7IGkgPj0gMDsgaS0tKSB7XG4gICAgdmFyIHBhcnQgPSBmcm9tUGFydHNbaV07XG5cbiAgICBpZiAocGFydCA9PT0gJy4nKSB7XG4gICAgICBzcGxpY2VPbmUoZnJvbVBhcnRzLCBpKTtcbiAgICB9IGVsc2UgaWYgKHBhcnQgPT09ICcuLicpIHtcbiAgICAgIHNwbGljZU9uZShmcm9tUGFydHMsIGkpO1xuICAgICAgdXArKztcbiAgICB9IGVsc2UgaWYgKHVwKSB7XG4gICAgICBzcGxpY2VPbmUoZnJvbVBhcnRzLCBpKTtcbiAgICAgIHVwLS07XG4gICAgfVxuICB9XG5cbiAgaWYgKCFtdXN0RW5kQWJzKSBmb3IgKDsgdXAtLTsgdXApIGZyb21QYXJ0cy51bnNoaWZ0KCcuLicpO1xuXG4gIGlmIChcbiAgICBtdXN0RW5kQWJzICYmXG4gICAgZnJvbVBhcnRzWzBdICE9PSAnJyAmJlxuICAgICghZnJvbVBhcnRzWzBdIHx8ICFpc0Fic29sdXRlKGZyb21QYXJ0c1swXSkpXG4gIClcbiAgICBmcm9tUGFydHMudW5zaGlmdCgnJyk7XG5cbiAgdmFyIHJlc3VsdCA9IGZyb21QYXJ0cy5qb2luKCcvJyk7XG5cbiAgaWYgKGhhc1RyYWlsaW5nU2xhc2ggJiYgcmVzdWx0LnN1YnN0cigtMSkgIT09ICcvJykgcmVzdWx0ICs9ICcvJztcblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgZGVmYXVsdCByZXNvbHZlUGF0aG5hbWU7XG4iLCJ2YXIgaXNQcm9kdWN0aW9uID0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJztcbnZhciBwcmVmaXggPSAnSW52YXJpYW50IGZhaWxlZCc7XG5mdW5jdGlvbiBpbnZhcmlhbnQoY29uZGl0aW9uLCBtZXNzYWdlKSB7XG4gICAgaWYgKGNvbmRpdGlvbikge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChpc1Byb2R1Y3Rpb24pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKHByZWZpeCk7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihwcmVmaXggKyBcIjogXCIgKyAobWVzc2FnZSB8fCAnJykpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBpbnZhcmlhbnQ7XG4iLCJpbXBvcnQgX2V4dGVuZHMgZnJvbSAnQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vZXh0ZW5kcyc7XG5pbXBvcnQgcmVzb2x2ZVBhdGhuYW1lIGZyb20gJ3Jlc29sdmUtcGF0aG5hbWUnO1xuaW1wb3J0IHZhbHVlRXF1YWwgZnJvbSAndmFsdWUtZXF1YWwnO1xuaW1wb3J0IHdhcm5pbmcgZnJvbSAndGlueS13YXJuaW5nJztcbmltcG9ydCBpbnZhcmlhbnQgZnJvbSAndGlueS1pbnZhcmlhbnQnO1xuXG5mdW5jdGlvbiBhZGRMZWFkaW5nU2xhc2gocGF0aCkge1xuICByZXR1cm4gcGF0aC5jaGFyQXQoMCkgPT09ICcvJyA/IHBhdGggOiAnLycgKyBwYXRoO1xufVxuZnVuY3Rpb24gc3RyaXBMZWFkaW5nU2xhc2gocGF0aCkge1xuICByZXR1cm4gcGF0aC5jaGFyQXQoMCkgPT09ICcvJyA/IHBhdGguc3Vic3RyKDEpIDogcGF0aDtcbn1cbmZ1bmN0aW9uIGhhc0Jhc2VuYW1lKHBhdGgsIHByZWZpeCkge1xuICByZXR1cm4gcGF0aC50b0xvd2VyQ2FzZSgpLmluZGV4T2YocHJlZml4LnRvTG93ZXJDYXNlKCkpID09PSAwICYmICcvPyMnLmluZGV4T2YocGF0aC5jaGFyQXQocHJlZml4Lmxlbmd0aCkpICE9PSAtMTtcbn1cbmZ1bmN0aW9uIHN0cmlwQmFzZW5hbWUocGF0aCwgcHJlZml4KSB7XG4gIHJldHVybiBoYXNCYXNlbmFtZShwYXRoLCBwcmVmaXgpID8gcGF0aC5zdWJzdHIocHJlZml4Lmxlbmd0aCkgOiBwYXRoO1xufVxuZnVuY3Rpb24gc3RyaXBUcmFpbGluZ1NsYXNoKHBhdGgpIHtcbiAgcmV0dXJuIHBhdGguY2hhckF0KHBhdGgubGVuZ3RoIC0gMSkgPT09ICcvJyA/IHBhdGguc2xpY2UoMCwgLTEpIDogcGF0aDtcbn1cbmZ1bmN0aW9uIHBhcnNlUGF0aChwYXRoKSB7XG4gIHZhciBwYXRobmFtZSA9IHBhdGggfHwgJy8nO1xuICB2YXIgc2VhcmNoID0gJyc7XG4gIHZhciBoYXNoID0gJyc7XG4gIHZhciBoYXNoSW5kZXggPSBwYXRobmFtZS5pbmRleE9mKCcjJyk7XG5cbiAgaWYgKGhhc2hJbmRleCAhPT0gLTEpIHtcbiAgICBoYXNoID0gcGF0aG5hbWUuc3Vic3RyKGhhc2hJbmRleCk7XG4gICAgcGF0aG5hbWUgPSBwYXRobmFtZS5zdWJzdHIoMCwgaGFzaEluZGV4KTtcbiAgfVxuXG4gIHZhciBzZWFyY2hJbmRleCA9IHBhdGhuYW1lLmluZGV4T2YoJz8nKTtcblxuICBpZiAoc2VhcmNoSW5kZXggIT09IC0xKSB7XG4gICAgc2VhcmNoID0gcGF0aG5hbWUuc3Vic3RyKHNlYXJjaEluZGV4KTtcbiAgICBwYXRobmFtZSA9IHBhdGhuYW1lLnN1YnN0cigwLCBzZWFyY2hJbmRleCk7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHBhdGhuYW1lOiBwYXRobmFtZSxcbiAgICBzZWFyY2g6IHNlYXJjaCA9PT0gJz8nID8gJycgOiBzZWFyY2gsXG4gICAgaGFzaDogaGFzaCA9PT0gJyMnID8gJycgOiBoYXNoXG4gIH07XG59XG5mdW5jdGlvbiBjcmVhdGVQYXRoKGxvY2F0aW9uKSB7XG4gIHZhciBwYXRobmFtZSA9IGxvY2F0aW9uLnBhdGhuYW1lLFxuICAgICAgc2VhcmNoID0gbG9jYXRpb24uc2VhcmNoLFxuICAgICAgaGFzaCA9IGxvY2F0aW9uLmhhc2g7XG4gIHZhciBwYXRoID0gcGF0aG5hbWUgfHwgJy8nO1xuICBpZiAoc2VhcmNoICYmIHNlYXJjaCAhPT0gJz8nKSBwYXRoICs9IHNlYXJjaC5jaGFyQXQoMCkgPT09ICc/JyA/IHNlYXJjaCA6IFwiP1wiICsgc2VhcmNoO1xuICBpZiAoaGFzaCAmJiBoYXNoICE9PSAnIycpIHBhdGggKz0gaGFzaC5jaGFyQXQoMCkgPT09ICcjJyA/IGhhc2ggOiBcIiNcIiArIGhhc2g7XG4gIHJldHVybiBwYXRoO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVMb2NhdGlvbihwYXRoLCBzdGF0ZSwga2V5LCBjdXJyZW50TG9jYXRpb24pIHtcbiAgdmFyIGxvY2F0aW9uO1xuXG4gIGlmICh0eXBlb2YgcGF0aCA9PT0gJ3N0cmluZycpIHtcbiAgICAvLyBUd28tYXJnIGZvcm06IHB1c2gocGF0aCwgc3RhdGUpXG4gICAgbG9jYXRpb24gPSBwYXJzZVBhdGgocGF0aCk7XG4gICAgbG9jYXRpb24uc3RhdGUgPSBzdGF0ZTtcbiAgfSBlbHNlIHtcbiAgICAvLyBPbmUtYXJnIGZvcm06IHB1c2gobG9jYXRpb24pXG4gICAgbG9jYXRpb24gPSBfZXh0ZW5kcyh7fSwgcGF0aCk7XG4gICAgaWYgKGxvY2F0aW9uLnBhdGhuYW1lID09PSB1bmRlZmluZWQpIGxvY2F0aW9uLnBhdGhuYW1lID0gJyc7XG5cbiAgICBpZiAobG9jYXRpb24uc2VhcmNoKSB7XG4gICAgICBpZiAobG9jYXRpb24uc2VhcmNoLmNoYXJBdCgwKSAhPT0gJz8nKSBsb2NhdGlvbi5zZWFyY2ggPSAnPycgKyBsb2NhdGlvbi5zZWFyY2g7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxvY2F0aW9uLnNlYXJjaCA9ICcnO1xuICAgIH1cblxuICAgIGlmIChsb2NhdGlvbi5oYXNoKSB7XG4gICAgICBpZiAobG9jYXRpb24uaGFzaC5jaGFyQXQoMCkgIT09ICcjJykgbG9jYXRpb24uaGFzaCA9ICcjJyArIGxvY2F0aW9uLmhhc2g7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxvY2F0aW9uLmhhc2ggPSAnJztcbiAgICB9XG5cbiAgICBpZiAoc3RhdGUgIT09IHVuZGVmaW5lZCAmJiBsb2NhdGlvbi5zdGF0ZSA9PT0gdW5kZWZpbmVkKSBsb2NhdGlvbi5zdGF0ZSA9IHN0YXRlO1xuICB9XG5cbiAgdHJ5IHtcbiAgICBsb2NhdGlvbi5wYXRobmFtZSA9IGRlY29kZVVSSShsb2NhdGlvbi5wYXRobmFtZSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBpZiAoZSBpbnN0YW5jZW9mIFVSSUVycm9yKSB7XG4gICAgICB0aHJvdyBuZXcgVVJJRXJyb3IoJ1BhdGhuYW1lIFwiJyArIGxvY2F0aW9uLnBhdGhuYW1lICsgJ1wiIGNvdWxkIG5vdCBiZSBkZWNvZGVkLiAnICsgJ1RoaXMgaXMgbGlrZWx5IGNhdXNlZCBieSBhbiBpbnZhbGlkIHBlcmNlbnQtZW5jb2RpbmcuJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IGU7XG4gICAgfVxuICB9XG5cbiAgaWYgKGtleSkgbG9jYXRpb24ua2V5ID0ga2V5O1xuXG4gIGlmIChjdXJyZW50TG9jYXRpb24pIHtcbiAgICAvLyBSZXNvbHZlIGluY29tcGxldGUvcmVsYXRpdmUgcGF0aG5hbWUgcmVsYXRpdmUgdG8gY3VycmVudCBsb2NhdGlvbi5cbiAgICBpZiAoIWxvY2F0aW9uLnBhdGhuYW1lKSB7XG4gICAgICBsb2NhdGlvbi5wYXRobmFtZSA9IGN1cnJlbnRMb2NhdGlvbi5wYXRobmFtZTtcbiAgICB9IGVsc2UgaWYgKGxvY2F0aW9uLnBhdGhuYW1lLmNoYXJBdCgwKSAhPT0gJy8nKSB7XG4gICAgICBsb2NhdGlvbi5wYXRobmFtZSA9IHJlc29sdmVQYXRobmFtZShsb2NhdGlvbi5wYXRobmFtZSwgY3VycmVudExvY2F0aW9uLnBhdGhuYW1lKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gV2hlbiB0aGVyZSBpcyBubyBwcmlvciBsb2NhdGlvbiBhbmQgcGF0aG5hbWUgaXMgZW1wdHksIHNldCBpdCB0byAvXG4gICAgaWYgKCFsb2NhdGlvbi5wYXRobmFtZSkge1xuICAgICAgbG9jYXRpb24ucGF0aG5hbWUgPSAnLyc7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGxvY2F0aW9uO1xufVxuZnVuY3Rpb24gbG9jYXRpb25zQXJlRXF1YWwoYSwgYikge1xuICByZXR1cm4gYS5wYXRobmFtZSA9PT0gYi5wYXRobmFtZSAmJiBhLnNlYXJjaCA9PT0gYi5zZWFyY2ggJiYgYS5oYXNoID09PSBiLmhhc2ggJiYgYS5rZXkgPT09IGIua2V5ICYmIHZhbHVlRXF1YWwoYS5zdGF0ZSwgYi5zdGF0ZSk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVRyYW5zaXRpb25NYW5hZ2VyKCkge1xuICB2YXIgcHJvbXB0ID0gbnVsbDtcblxuICBmdW5jdGlvbiBzZXRQcm9tcHQobmV4dFByb21wdCkge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IHdhcm5pbmcocHJvbXB0ID09IG51bGwsICdBIGhpc3Rvcnkgc3VwcG9ydHMgb25seSBvbmUgcHJvbXB0IGF0IGEgdGltZScpIDogdm9pZCAwO1xuICAgIHByb21wdCA9IG5leHRQcm9tcHQ7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChwcm9tcHQgPT09IG5leHRQcm9tcHQpIHByb21wdCA9IG51bGw7XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNvbmZpcm1UcmFuc2l0aW9uVG8obG9jYXRpb24sIGFjdGlvbiwgZ2V0VXNlckNvbmZpcm1hdGlvbiwgY2FsbGJhY2spIHtcbiAgICAvLyBUT0RPOiBJZiBhbm90aGVyIHRyYW5zaXRpb24gc3RhcnRzIHdoaWxlIHdlJ3JlIHN0aWxsIGNvbmZpcm1pbmdcbiAgICAvLyB0aGUgcHJldmlvdXMgb25lLCB3ZSBtYXkgZW5kIHVwIGluIGEgd2VpcmQgc3RhdGUuIEZpZ3VyZSBvdXQgdGhlXG4gICAgLy8gYmVzdCB3YXkgdG8gaGFuZGxlIHRoaXMuXG4gICAgaWYgKHByb21wdCAhPSBudWxsKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gdHlwZW9mIHByb21wdCA9PT0gJ2Z1bmN0aW9uJyA/IHByb21wdChsb2NhdGlvbiwgYWN0aW9uKSA6IHByb21wdDtcblxuICAgICAgaWYgKHR5cGVvZiByZXN1bHQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZ2V0VXNlckNvbmZpcm1hdGlvbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIGdldFVzZXJDb25maXJtYXRpb24ocmVzdWx0LCBjYWxsYmFjayk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gd2FybmluZyhmYWxzZSwgJ0EgaGlzdG9yeSBuZWVkcyBhIGdldFVzZXJDb25maXJtYXRpb24gZnVuY3Rpb24gaW4gb3JkZXIgdG8gdXNlIGEgcHJvbXB0IG1lc3NhZ2UnKSA6IHZvaWQgMDtcbiAgICAgICAgICBjYWxsYmFjayh0cnVlKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gUmV0dXJuIGZhbHNlIGZyb20gYSB0cmFuc2l0aW9uIGhvb2sgdG8gY2FuY2VsIHRoZSB0cmFuc2l0aW9uLlxuICAgICAgICBjYWxsYmFjayhyZXN1bHQgIT09IGZhbHNlKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY2FsbGJhY2sodHJ1ZSk7XG4gICAgfVxuICB9XG5cbiAgdmFyIGxpc3RlbmVycyA9IFtdO1xuXG4gIGZ1bmN0aW9uIGFwcGVuZExpc3RlbmVyKGZuKSB7XG4gICAgdmFyIGlzQWN0aXZlID0gdHJ1ZTtcblxuICAgIGZ1bmN0aW9uIGxpc3RlbmVyKCkge1xuICAgICAgaWYgKGlzQWN0aXZlKSBmbi5hcHBseSh2b2lkIDAsIGFyZ3VtZW50cyk7XG4gICAgfVxuXG4gICAgbGlzdGVuZXJzLnB1c2gobGlzdGVuZXIpO1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICBpc0FjdGl2ZSA9IGZhbHNlO1xuICAgICAgbGlzdGVuZXJzID0gbGlzdGVuZXJzLmZpbHRlcihmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICByZXR1cm4gaXRlbSAhPT0gbGlzdGVuZXI7XG4gICAgICB9KTtcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gbm90aWZ5TGlzdGVuZXJzKCkge1xuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICBsaXN0ZW5lcnMuZm9yRWFjaChmdW5jdGlvbiAobGlzdGVuZXIpIHtcbiAgICAgIHJldHVybiBsaXN0ZW5lci5hcHBseSh2b2lkIDAsIGFyZ3MpO1xuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBzZXRQcm9tcHQ6IHNldFByb21wdCxcbiAgICBjb25maXJtVHJhbnNpdGlvblRvOiBjb25maXJtVHJhbnNpdGlvblRvLFxuICAgIGFwcGVuZExpc3RlbmVyOiBhcHBlbmRMaXN0ZW5lcixcbiAgICBub3RpZnlMaXN0ZW5lcnM6IG5vdGlmeUxpc3RlbmVyc1xuICB9O1xufVxuXG52YXIgY2FuVXNlRE9NID0gISEodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LmRvY3VtZW50ICYmIHdpbmRvdy5kb2N1bWVudC5jcmVhdGVFbGVtZW50KTtcbmZ1bmN0aW9uIGdldENvbmZpcm1hdGlvbihtZXNzYWdlLCBjYWxsYmFjaykge1xuICBjYWxsYmFjayh3aW5kb3cuY29uZmlybShtZXNzYWdlKSk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tYWxlcnRcbn1cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBIVE1MNSBoaXN0b3J5IEFQSSBpcyBzdXBwb3J0ZWQuIFRha2VuIGZyb20gTW9kZXJuaXpyLlxuICpcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9Nb2Rlcm5penIvTW9kZXJuaXpyL2Jsb2IvbWFzdGVyL0xJQ0VOU0VcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9Nb2Rlcm5penIvTW9kZXJuaXpyL2Jsb2IvbWFzdGVyL2ZlYXR1cmUtZGV0ZWN0cy9oaXN0b3J5LmpzXG4gKiBjaGFuZ2VkIHRvIGF2b2lkIGZhbHNlIG5lZ2F0aXZlcyBmb3IgV2luZG93cyBQaG9uZXM6IGh0dHBzOi8vZ2l0aHViLmNvbS9yZWFjdGpzL3JlYWN0LXJvdXRlci9pc3N1ZXMvNTg2XG4gKi9cblxuZnVuY3Rpb24gc3VwcG9ydHNIaXN0b3J5KCkge1xuICB2YXIgdWEgPSB3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudDtcbiAgaWYgKCh1YS5pbmRleE9mKCdBbmRyb2lkIDIuJykgIT09IC0xIHx8IHVhLmluZGV4T2YoJ0FuZHJvaWQgNC4wJykgIT09IC0xKSAmJiB1YS5pbmRleE9mKCdNb2JpbGUgU2FmYXJpJykgIT09IC0xICYmIHVhLmluZGV4T2YoJ0Nocm9tZScpID09PSAtMSAmJiB1YS5pbmRleE9mKCdXaW5kb3dzIFBob25lJykgPT09IC0xKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiB3aW5kb3cuaGlzdG9yeSAmJiAncHVzaFN0YXRlJyBpbiB3aW5kb3cuaGlzdG9yeTtcbn1cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIGJyb3dzZXIgZmlyZXMgcG9wc3RhdGUgb24gaGFzaCBjaGFuZ2UuXG4gKiBJRTEwIGFuZCBJRTExIGRvIG5vdC5cbiAqL1xuXG5mdW5jdGlvbiBzdXBwb3J0c1BvcFN0YXRlT25IYXNoQ2hhbmdlKCkge1xuICByZXR1cm4gd2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZignVHJpZGVudCcpID09PSAtMTtcbn1cbi8qKlxuICogUmV0dXJucyBmYWxzZSBpZiB1c2luZyBnbyhuKSB3aXRoIGhhc2ggaGlzdG9yeSBjYXVzZXMgYSBmdWxsIHBhZ2UgcmVsb2FkLlxuICovXG5cbmZ1bmN0aW9uIHN1cHBvcnRzR29XaXRob3V0UmVsb2FkVXNpbmdIYXNoKCkge1xuICByZXR1cm4gd2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZignRmlyZWZveCcpID09PSAtMTtcbn1cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIGEgZ2l2ZW4gcG9wc3RhdGUgZXZlbnQgaXMgYW4gZXh0cmFuZW91cyBXZWJLaXQgZXZlbnQuXG4gKiBBY2NvdW50cyBmb3IgdGhlIGZhY3QgdGhhdCBDaHJvbWUgb24gaU9TIGZpcmVzIHJlYWwgcG9wc3RhdGUgZXZlbnRzXG4gKiBjb250YWluaW5nIHVuZGVmaW5lZCBzdGF0ZSB3aGVuIHByZXNzaW5nIHRoZSBiYWNrIGJ1dHRvbi5cbiAqL1xuXG5mdW5jdGlvbiBpc0V4dHJhbmVvdXNQb3BzdGF0ZUV2ZW50KGV2ZW50KSB7XG4gIHJldHVybiBldmVudC5zdGF0ZSA9PT0gdW5kZWZpbmVkICYmIG5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZignQ3JpT1MnKSA9PT0gLTE7XG59XG5cbnZhciBQb3BTdGF0ZUV2ZW50ID0gJ3BvcHN0YXRlJztcbnZhciBIYXNoQ2hhbmdlRXZlbnQgPSAnaGFzaGNoYW5nZSc7XG5cbmZ1bmN0aW9uIGdldEhpc3RvcnlTdGF0ZSgpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gd2luZG93Lmhpc3Rvcnkuc3RhdGUgfHwge307XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICAvLyBJRSAxMSBzb21ldGltZXMgdGhyb3dzIHdoZW4gYWNjZXNzaW5nIHdpbmRvdy5oaXN0b3J5LnN0YXRlXG4gICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9SZWFjdFRyYWluaW5nL2hpc3RvcnkvcHVsbC8yODlcbiAgICByZXR1cm4ge307XG4gIH1cbn1cbi8qKlxuICogQ3JlYXRlcyBhIGhpc3Rvcnkgb2JqZWN0IHRoYXQgdXNlcyB0aGUgSFRNTDUgaGlzdG9yeSBBUEkgaW5jbHVkaW5nXG4gKiBwdXNoU3RhdGUsIHJlcGxhY2VTdGF0ZSwgYW5kIHRoZSBwb3BzdGF0ZSBldmVudC5cbiAqL1xuXG5cbmZ1bmN0aW9uIGNyZWF0ZUJyb3dzZXJIaXN0b3J5KHByb3BzKSB7XG4gIGlmIChwcm9wcyA9PT0gdm9pZCAwKSB7XG4gICAgcHJvcHMgPSB7fTtcbiAgfVxuXG4gICFjYW5Vc2VET00gPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdCcm93c2VyIGhpc3RvcnkgbmVlZHMgYSBET00nKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gIHZhciBnbG9iYWxIaXN0b3J5ID0gd2luZG93Lmhpc3Rvcnk7XG4gIHZhciBjYW5Vc2VIaXN0b3J5ID0gc3VwcG9ydHNIaXN0b3J5KCk7XG4gIHZhciBuZWVkc0hhc2hDaGFuZ2VMaXN0ZW5lciA9ICFzdXBwb3J0c1BvcFN0YXRlT25IYXNoQ2hhbmdlKCk7XG4gIHZhciBfcHJvcHMgPSBwcm9wcyxcbiAgICAgIF9wcm9wcyRmb3JjZVJlZnJlc2ggPSBfcHJvcHMuZm9yY2VSZWZyZXNoLFxuICAgICAgZm9yY2VSZWZyZXNoID0gX3Byb3BzJGZvcmNlUmVmcmVzaCA9PT0gdm9pZCAwID8gZmFsc2UgOiBfcHJvcHMkZm9yY2VSZWZyZXNoLFxuICAgICAgX3Byb3BzJGdldFVzZXJDb25maXJtID0gX3Byb3BzLmdldFVzZXJDb25maXJtYXRpb24sXG4gICAgICBnZXRVc2VyQ29uZmlybWF0aW9uID0gX3Byb3BzJGdldFVzZXJDb25maXJtID09PSB2b2lkIDAgPyBnZXRDb25maXJtYXRpb24gOiBfcHJvcHMkZ2V0VXNlckNvbmZpcm0sXG4gICAgICBfcHJvcHMka2V5TGVuZ3RoID0gX3Byb3BzLmtleUxlbmd0aCxcbiAgICAgIGtleUxlbmd0aCA9IF9wcm9wcyRrZXlMZW5ndGggPT09IHZvaWQgMCA/IDYgOiBfcHJvcHMka2V5TGVuZ3RoO1xuICB2YXIgYmFzZW5hbWUgPSBwcm9wcy5iYXNlbmFtZSA/IHN0cmlwVHJhaWxpbmdTbGFzaChhZGRMZWFkaW5nU2xhc2gocHJvcHMuYmFzZW5hbWUpKSA6ICcnO1xuXG4gIGZ1bmN0aW9uIGdldERPTUxvY2F0aW9uKGhpc3RvcnlTdGF0ZSkge1xuICAgIHZhciBfcmVmID0gaGlzdG9yeVN0YXRlIHx8IHt9LFxuICAgICAgICBrZXkgPSBfcmVmLmtleSxcbiAgICAgICAgc3RhdGUgPSBfcmVmLnN0YXRlO1xuXG4gICAgdmFyIF93aW5kb3ckbG9jYXRpb24gPSB3aW5kb3cubG9jYXRpb24sXG4gICAgICAgIHBhdGhuYW1lID0gX3dpbmRvdyRsb2NhdGlvbi5wYXRobmFtZSxcbiAgICAgICAgc2VhcmNoID0gX3dpbmRvdyRsb2NhdGlvbi5zZWFyY2gsXG4gICAgICAgIGhhc2ggPSBfd2luZG93JGxvY2F0aW9uLmhhc2g7XG4gICAgdmFyIHBhdGggPSBwYXRobmFtZSArIHNlYXJjaCArIGhhc2g7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gd2FybmluZyghYmFzZW5hbWUgfHwgaGFzQmFzZW5hbWUocGF0aCwgYmFzZW5hbWUpLCAnWW91IGFyZSBhdHRlbXB0aW5nIHRvIHVzZSBhIGJhc2VuYW1lIG9uIGEgcGFnZSB3aG9zZSBVUkwgcGF0aCBkb2VzIG5vdCBiZWdpbiAnICsgJ3dpdGggdGhlIGJhc2VuYW1lLiBFeHBlY3RlZCBwYXRoIFwiJyArIHBhdGggKyAnXCIgdG8gYmVnaW4gd2l0aCBcIicgKyBiYXNlbmFtZSArICdcIi4nKSA6IHZvaWQgMDtcbiAgICBpZiAoYmFzZW5hbWUpIHBhdGggPSBzdHJpcEJhc2VuYW1lKHBhdGgsIGJhc2VuYW1lKTtcbiAgICByZXR1cm4gY3JlYXRlTG9jYXRpb24ocGF0aCwgc3RhdGUsIGtleSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVLZXkoKSB7XG4gICAgcmV0dXJuIE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnN1YnN0cigyLCBrZXlMZW5ndGgpO1xuICB9XG5cbiAgdmFyIHRyYW5zaXRpb25NYW5hZ2VyID0gY3JlYXRlVHJhbnNpdGlvbk1hbmFnZXIoKTtcblxuICBmdW5jdGlvbiBzZXRTdGF0ZShuZXh0U3RhdGUpIHtcbiAgICBfZXh0ZW5kcyhoaXN0b3J5LCBuZXh0U3RhdGUpO1xuXG4gICAgaGlzdG9yeS5sZW5ndGggPSBnbG9iYWxIaXN0b3J5Lmxlbmd0aDtcbiAgICB0cmFuc2l0aW9uTWFuYWdlci5ub3RpZnlMaXN0ZW5lcnMoaGlzdG9yeS5sb2NhdGlvbiwgaGlzdG9yeS5hY3Rpb24pO1xuICB9XG5cbiAgZnVuY3Rpb24gaGFuZGxlUG9wU3RhdGUoZXZlbnQpIHtcbiAgICAvLyBJZ25vcmUgZXh0cmFuZW91cyBwb3BzdGF0ZSBldmVudHMgaW4gV2ViS2l0LlxuICAgIGlmIChpc0V4dHJhbmVvdXNQb3BzdGF0ZUV2ZW50KGV2ZW50KSkgcmV0dXJuO1xuICAgIGhhbmRsZVBvcChnZXRET01Mb2NhdGlvbihldmVudC5zdGF0ZSkpO1xuICB9XG5cbiAgZnVuY3Rpb24gaGFuZGxlSGFzaENoYW5nZSgpIHtcbiAgICBoYW5kbGVQb3AoZ2V0RE9NTG9jYXRpb24oZ2V0SGlzdG9yeVN0YXRlKCkpKTtcbiAgfVxuXG4gIHZhciBmb3JjZU5leHRQb3AgPSBmYWxzZTtcblxuICBmdW5jdGlvbiBoYW5kbGVQb3AobG9jYXRpb24pIHtcbiAgICBpZiAoZm9yY2VOZXh0UG9wKSB7XG4gICAgICBmb3JjZU5leHRQb3AgPSBmYWxzZTtcbiAgICAgIHNldFN0YXRlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBhY3Rpb24gPSAnUE9QJztcbiAgICAgIHRyYW5zaXRpb25NYW5hZ2VyLmNvbmZpcm1UcmFuc2l0aW9uVG8obG9jYXRpb24sIGFjdGlvbiwgZ2V0VXNlckNvbmZpcm1hdGlvbiwgZnVuY3Rpb24gKG9rKSB7XG4gICAgICAgIGlmIChvaykge1xuICAgICAgICAgIHNldFN0YXRlKHtcbiAgICAgICAgICAgIGFjdGlvbjogYWN0aW9uLFxuICAgICAgICAgICAgbG9jYXRpb246IGxvY2F0aW9uXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV2ZXJ0UG9wKGxvY2F0aW9uKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmV2ZXJ0UG9wKGZyb21Mb2NhdGlvbikge1xuICAgIHZhciB0b0xvY2F0aW9uID0gaGlzdG9yeS5sb2NhdGlvbjsgLy8gVE9ETzogV2UgY291bGQgcHJvYmFibHkgbWFrZSB0aGlzIG1vcmUgcmVsaWFibGUgYnlcbiAgICAvLyBrZWVwaW5nIGEgbGlzdCBvZiBrZXlzIHdlJ3ZlIHNlZW4gaW4gc2Vzc2lvblN0b3JhZ2UuXG4gICAgLy8gSW5zdGVhZCwgd2UganVzdCBkZWZhdWx0IHRvIDAgZm9yIGtleXMgd2UgZG9uJ3Qga25vdy5cblxuICAgIHZhciB0b0luZGV4ID0gYWxsS2V5cy5pbmRleE9mKHRvTG9jYXRpb24ua2V5KTtcbiAgICBpZiAodG9JbmRleCA9PT0gLTEpIHRvSW5kZXggPSAwO1xuICAgIHZhciBmcm9tSW5kZXggPSBhbGxLZXlzLmluZGV4T2YoZnJvbUxvY2F0aW9uLmtleSk7XG4gICAgaWYgKGZyb21JbmRleCA9PT0gLTEpIGZyb21JbmRleCA9IDA7XG4gICAgdmFyIGRlbHRhID0gdG9JbmRleCAtIGZyb21JbmRleDtcblxuICAgIGlmIChkZWx0YSkge1xuICAgICAgZm9yY2VOZXh0UG9wID0gdHJ1ZTtcbiAgICAgIGdvKGRlbHRhKTtcbiAgICB9XG4gIH1cblxuICB2YXIgaW5pdGlhbExvY2F0aW9uID0gZ2V0RE9NTG9jYXRpb24oZ2V0SGlzdG9yeVN0YXRlKCkpO1xuICB2YXIgYWxsS2V5cyA9IFtpbml0aWFsTG9jYXRpb24ua2V5XTsgLy8gUHVibGljIGludGVyZmFjZVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUhyZWYobG9jYXRpb24pIHtcbiAgICByZXR1cm4gYmFzZW5hbWUgKyBjcmVhdGVQYXRoKGxvY2F0aW9uKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHB1c2gocGF0aCwgc3RhdGUpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyB3YXJuaW5nKCEodHlwZW9mIHBhdGggPT09ICdvYmplY3QnICYmIHBhdGguc3RhdGUgIT09IHVuZGVmaW5lZCAmJiBzdGF0ZSAhPT0gdW5kZWZpbmVkKSwgJ1lvdSBzaG91bGQgYXZvaWQgcHJvdmlkaW5nIGEgMm5kIHN0YXRlIGFyZ3VtZW50IHRvIHB1c2ggd2hlbiB0aGUgMXN0ICcgKyAnYXJndW1lbnQgaXMgYSBsb2NhdGlvbi1saWtlIG9iamVjdCB0aGF0IGFscmVhZHkgaGFzIHN0YXRlOyBpdCBpcyBpZ25vcmVkJykgOiB2b2lkIDA7XG4gICAgdmFyIGFjdGlvbiA9ICdQVVNIJztcbiAgICB2YXIgbG9jYXRpb24gPSBjcmVhdGVMb2NhdGlvbihwYXRoLCBzdGF0ZSwgY3JlYXRlS2V5KCksIGhpc3RvcnkubG9jYXRpb24pO1xuICAgIHRyYW5zaXRpb25NYW5hZ2VyLmNvbmZpcm1UcmFuc2l0aW9uVG8obG9jYXRpb24sIGFjdGlvbiwgZ2V0VXNlckNvbmZpcm1hdGlvbiwgZnVuY3Rpb24gKG9rKSB7XG4gICAgICBpZiAoIW9rKSByZXR1cm47XG4gICAgICB2YXIgaHJlZiA9IGNyZWF0ZUhyZWYobG9jYXRpb24pO1xuICAgICAgdmFyIGtleSA9IGxvY2F0aW9uLmtleSxcbiAgICAgICAgICBzdGF0ZSA9IGxvY2F0aW9uLnN0YXRlO1xuXG4gICAgICBpZiAoY2FuVXNlSGlzdG9yeSkge1xuICAgICAgICBnbG9iYWxIaXN0b3J5LnB1c2hTdGF0ZSh7XG4gICAgICAgICAga2V5OiBrZXksXG4gICAgICAgICAgc3RhdGU6IHN0YXRlXG4gICAgICAgIH0sIG51bGwsIGhyZWYpO1xuXG4gICAgICAgIGlmIChmb3JjZVJlZnJlc2gpIHtcbiAgICAgICAgICB3aW5kb3cubG9jYXRpb24uaHJlZiA9IGhyZWY7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIHByZXZJbmRleCA9IGFsbEtleXMuaW5kZXhPZihoaXN0b3J5LmxvY2F0aW9uLmtleSk7XG4gICAgICAgICAgdmFyIG5leHRLZXlzID0gYWxsS2V5cy5zbGljZSgwLCBwcmV2SW5kZXggKyAxKTtcbiAgICAgICAgICBuZXh0S2V5cy5wdXNoKGxvY2F0aW9uLmtleSk7XG4gICAgICAgICAgYWxsS2V5cyA9IG5leHRLZXlzO1xuICAgICAgICAgIHNldFN0YXRlKHtcbiAgICAgICAgICAgIGFjdGlvbjogYWN0aW9uLFxuICAgICAgICAgICAgbG9jYXRpb246IGxvY2F0aW9uXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IHdhcm5pbmcoc3RhdGUgPT09IHVuZGVmaW5lZCwgJ0Jyb3dzZXIgaGlzdG9yeSBjYW5ub3QgcHVzaCBzdGF0ZSBpbiBicm93c2VycyB0aGF0IGRvIG5vdCBzdXBwb3J0IEhUTUw1IGhpc3RvcnknKSA6IHZvaWQgMDtcbiAgICAgICAgd2luZG93LmxvY2F0aW9uLmhyZWYgPSBocmVmO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVwbGFjZShwYXRoLCBzdGF0ZSkge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IHdhcm5pbmcoISh0eXBlb2YgcGF0aCA9PT0gJ29iamVjdCcgJiYgcGF0aC5zdGF0ZSAhPT0gdW5kZWZpbmVkICYmIHN0YXRlICE9PSB1bmRlZmluZWQpLCAnWW91IHNob3VsZCBhdm9pZCBwcm92aWRpbmcgYSAybmQgc3RhdGUgYXJndW1lbnQgdG8gcmVwbGFjZSB3aGVuIHRoZSAxc3QgJyArICdhcmd1bWVudCBpcyBhIGxvY2F0aW9uLWxpa2Ugb2JqZWN0IHRoYXQgYWxyZWFkeSBoYXMgc3RhdGU7IGl0IGlzIGlnbm9yZWQnKSA6IHZvaWQgMDtcbiAgICB2YXIgYWN0aW9uID0gJ1JFUExBQ0UnO1xuICAgIHZhciBsb2NhdGlvbiA9IGNyZWF0ZUxvY2F0aW9uKHBhdGgsIHN0YXRlLCBjcmVhdGVLZXkoKSwgaGlzdG9yeS5sb2NhdGlvbik7XG4gICAgdHJhbnNpdGlvbk1hbmFnZXIuY29uZmlybVRyYW5zaXRpb25Ubyhsb2NhdGlvbiwgYWN0aW9uLCBnZXRVc2VyQ29uZmlybWF0aW9uLCBmdW5jdGlvbiAob2spIHtcbiAgICAgIGlmICghb2spIHJldHVybjtcbiAgICAgIHZhciBocmVmID0gY3JlYXRlSHJlZihsb2NhdGlvbik7XG4gICAgICB2YXIga2V5ID0gbG9jYXRpb24ua2V5LFxuICAgICAgICAgIHN0YXRlID0gbG9jYXRpb24uc3RhdGU7XG5cbiAgICAgIGlmIChjYW5Vc2VIaXN0b3J5KSB7XG4gICAgICAgIGdsb2JhbEhpc3RvcnkucmVwbGFjZVN0YXRlKHtcbiAgICAgICAgICBrZXk6IGtleSxcbiAgICAgICAgICBzdGF0ZTogc3RhdGVcbiAgICAgICAgfSwgbnVsbCwgaHJlZik7XG5cbiAgICAgICAgaWYgKGZvcmNlUmVmcmVzaCkge1xuICAgICAgICAgIHdpbmRvdy5sb2NhdGlvbi5yZXBsYWNlKGhyZWYpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBwcmV2SW5kZXggPSBhbGxLZXlzLmluZGV4T2YoaGlzdG9yeS5sb2NhdGlvbi5rZXkpO1xuICAgICAgICAgIGlmIChwcmV2SW5kZXggIT09IC0xKSBhbGxLZXlzW3ByZXZJbmRleF0gPSBsb2NhdGlvbi5rZXk7XG4gICAgICAgICAgc2V0U3RhdGUoe1xuICAgICAgICAgICAgYWN0aW9uOiBhY3Rpb24sXG4gICAgICAgICAgICBsb2NhdGlvbjogbG9jYXRpb25cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gd2FybmluZyhzdGF0ZSA9PT0gdW5kZWZpbmVkLCAnQnJvd3NlciBoaXN0b3J5IGNhbm5vdCByZXBsYWNlIHN0YXRlIGluIGJyb3dzZXJzIHRoYXQgZG8gbm90IHN1cHBvcnQgSFRNTDUgaGlzdG9yeScpIDogdm9pZCAwO1xuICAgICAgICB3aW5kb3cubG9jYXRpb24ucmVwbGFjZShocmVmKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdvKG4pIHtcbiAgICBnbG9iYWxIaXN0b3J5LmdvKG4pO1xuICB9XG5cbiAgZnVuY3Rpb24gZ29CYWNrKCkge1xuICAgIGdvKC0xKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdvRm9yd2FyZCgpIHtcbiAgICBnbygxKTtcbiAgfVxuXG4gIHZhciBsaXN0ZW5lckNvdW50ID0gMDtcblxuICBmdW5jdGlvbiBjaGVja0RPTUxpc3RlbmVycyhkZWx0YSkge1xuICAgIGxpc3RlbmVyQ291bnQgKz0gZGVsdGE7XG5cbiAgICBpZiAobGlzdGVuZXJDb3VudCA9PT0gMSAmJiBkZWx0YSA9PT0gMSkge1xuICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoUG9wU3RhdGVFdmVudCwgaGFuZGxlUG9wU3RhdGUpO1xuICAgICAgaWYgKG5lZWRzSGFzaENoYW5nZUxpc3RlbmVyKSB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihIYXNoQ2hhbmdlRXZlbnQsIGhhbmRsZUhhc2hDaGFuZ2UpO1xuICAgIH0gZWxzZSBpZiAobGlzdGVuZXJDb3VudCA9PT0gMCkge1xuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoUG9wU3RhdGVFdmVudCwgaGFuZGxlUG9wU3RhdGUpO1xuICAgICAgaWYgKG5lZWRzSGFzaENoYW5nZUxpc3RlbmVyKSB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihIYXNoQ2hhbmdlRXZlbnQsIGhhbmRsZUhhc2hDaGFuZ2UpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBpc0Jsb2NrZWQgPSBmYWxzZTtcblxuICBmdW5jdGlvbiBibG9jayhwcm9tcHQpIHtcbiAgICBpZiAocHJvbXB0ID09PSB2b2lkIDApIHtcbiAgICAgIHByb21wdCA9IGZhbHNlO1xuICAgIH1cblxuICAgIHZhciB1bmJsb2NrID0gdHJhbnNpdGlvbk1hbmFnZXIuc2V0UHJvbXB0KHByb21wdCk7XG5cbiAgICBpZiAoIWlzQmxvY2tlZCkge1xuICAgICAgY2hlY2tET01MaXN0ZW5lcnMoMSk7XG4gICAgICBpc0Jsb2NrZWQgPSB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoaXNCbG9ja2VkKSB7XG4gICAgICAgIGlzQmxvY2tlZCA9IGZhbHNlO1xuICAgICAgICBjaGVja0RPTUxpc3RlbmVycygtMSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB1bmJsb2NrKCk7XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGxpc3RlbihsaXN0ZW5lcikge1xuICAgIHZhciB1bmxpc3RlbiA9IHRyYW5zaXRpb25NYW5hZ2VyLmFwcGVuZExpc3RlbmVyKGxpc3RlbmVyKTtcbiAgICBjaGVja0RPTUxpc3RlbmVycygxKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgY2hlY2tET01MaXN0ZW5lcnMoLTEpO1xuICAgICAgdW5saXN0ZW4oKTtcbiAgICB9O1xuICB9XG5cbiAgdmFyIGhpc3RvcnkgPSB7XG4gICAgbGVuZ3RoOiBnbG9iYWxIaXN0b3J5Lmxlbmd0aCxcbiAgICBhY3Rpb246ICdQT1AnLFxuICAgIGxvY2F0aW9uOiBpbml0aWFsTG9jYXRpb24sXG4gICAgY3JlYXRlSHJlZjogY3JlYXRlSHJlZixcbiAgICBwdXNoOiBwdXNoLFxuICAgIHJlcGxhY2U6IHJlcGxhY2UsXG4gICAgZ286IGdvLFxuICAgIGdvQmFjazogZ29CYWNrLFxuICAgIGdvRm9yd2FyZDogZ29Gb3J3YXJkLFxuICAgIGJsb2NrOiBibG9jayxcbiAgICBsaXN0ZW46IGxpc3RlblxuICB9O1xuICByZXR1cm4gaGlzdG9yeTtcbn1cblxudmFyIEhhc2hDaGFuZ2VFdmVudCQxID0gJ2hhc2hjaGFuZ2UnO1xudmFyIEhhc2hQYXRoQ29kZXJzID0ge1xuICBoYXNoYmFuZzoge1xuICAgIGVuY29kZVBhdGg6IGZ1bmN0aW9uIGVuY29kZVBhdGgocGF0aCkge1xuICAgICAgcmV0dXJuIHBhdGguY2hhckF0KDApID09PSAnIScgPyBwYXRoIDogJyEvJyArIHN0cmlwTGVhZGluZ1NsYXNoKHBhdGgpO1xuICAgIH0sXG4gICAgZGVjb2RlUGF0aDogZnVuY3Rpb24gZGVjb2RlUGF0aChwYXRoKSB7XG4gICAgICByZXR1cm4gcGF0aC5jaGFyQXQoMCkgPT09ICchJyA/IHBhdGguc3Vic3RyKDEpIDogcGF0aDtcbiAgICB9XG4gIH0sXG4gIG5vc2xhc2g6IHtcbiAgICBlbmNvZGVQYXRoOiBzdHJpcExlYWRpbmdTbGFzaCxcbiAgICBkZWNvZGVQYXRoOiBhZGRMZWFkaW5nU2xhc2hcbiAgfSxcbiAgc2xhc2g6IHtcbiAgICBlbmNvZGVQYXRoOiBhZGRMZWFkaW5nU2xhc2gsXG4gICAgZGVjb2RlUGF0aDogYWRkTGVhZGluZ1NsYXNoXG4gIH1cbn07XG5cbmZ1bmN0aW9uIHN0cmlwSGFzaCh1cmwpIHtcbiAgdmFyIGhhc2hJbmRleCA9IHVybC5pbmRleE9mKCcjJyk7XG4gIHJldHVybiBoYXNoSW5kZXggPT09IC0xID8gdXJsIDogdXJsLnNsaWNlKDAsIGhhc2hJbmRleCk7XG59XG5cbmZ1bmN0aW9uIGdldEhhc2hQYXRoKCkge1xuICAvLyBXZSBjYW4ndCB1c2Ugd2luZG93LmxvY2F0aW9uLmhhc2ggaGVyZSBiZWNhdXNlIGl0J3Mgbm90XG4gIC8vIGNvbnNpc3RlbnQgYWNyb3NzIGJyb3dzZXJzIC0gRmlyZWZveCB3aWxsIHByZS1kZWNvZGUgaXQhXG4gIHZhciBocmVmID0gd2luZG93LmxvY2F0aW9uLmhyZWY7XG4gIHZhciBoYXNoSW5kZXggPSBocmVmLmluZGV4T2YoJyMnKTtcbiAgcmV0dXJuIGhhc2hJbmRleCA9PT0gLTEgPyAnJyA6IGhyZWYuc3Vic3RyaW5nKGhhc2hJbmRleCArIDEpO1xufVxuXG5mdW5jdGlvbiBwdXNoSGFzaFBhdGgocGF0aCkge1xuICB3aW5kb3cubG9jYXRpb24uaGFzaCA9IHBhdGg7XG59XG5cbmZ1bmN0aW9uIHJlcGxhY2VIYXNoUGF0aChwYXRoKSB7XG4gIHdpbmRvdy5sb2NhdGlvbi5yZXBsYWNlKHN0cmlwSGFzaCh3aW5kb3cubG9jYXRpb24uaHJlZikgKyAnIycgKyBwYXRoKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlSGFzaEhpc3RvcnkocHJvcHMpIHtcbiAgaWYgKHByb3BzID09PSB2b2lkIDApIHtcbiAgICBwcm9wcyA9IHt9O1xuICB9XG5cbiAgIWNhblVzZURPTSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ0hhc2ggaGlzdG9yeSBuZWVkcyBhIERPTScpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgdmFyIGdsb2JhbEhpc3RvcnkgPSB3aW5kb3cuaGlzdG9yeTtcbiAgdmFyIGNhbkdvV2l0aG91dFJlbG9hZCA9IHN1cHBvcnRzR29XaXRob3V0UmVsb2FkVXNpbmdIYXNoKCk7XG4gIHZhciBfcHJvcHMgPSBwcm9wcyxcbiAgICAgIF9wcm9wcyRnZXRVc2VyQ29uZmlybSA9IF9wcm9wcy5nZXRVc2VyQ29uZmlybWF0aW9uLFxuICAgICAgZ2V0VXNlckNvbmZpcm1hdGlvbiA9IF9wcm9wcyRnZXRVc2VyQ29uZmlybSA9PT0gdm9pZCAwID8gZ2V0Q29uZmlybWF0aW9uIDogX3Byb3BzJGdldFVzZXJDb25maXJtLFxuICAgICAgX3Byb3BzJGhhc2hUeXBlID0gX3Byb3BzLmhhc2hUeXBlLFxuICAgICAgaGFzaFR5cGUgPSBfcHJvcHMkaGFzaFR5cGUgPT09IHZvaWQgMCA/ICdzbGFzaCcgOiBfcHJvcHMkaGFzaFR5cGU7XG4gIHZhciBiYXNlbmFtZSA9IHByb3BzLmJhc2VuYW1lID8gc3RyaXBUcmFpbGluZ1NsYXNoKGFkZExlYWRpbmdTbGFzaChwcm9wcy5iYXNlbmFtZSkpIDogJyc7XG4gIHZhciBfSGFzaFBhdGhDb2RlcnMkaGFzaFQgPSBIYXNoUGF0aENvZGVyc1toYXNoVHlwZV0sXG4gICAgICBlbmNvZGVQYXRoID0gX0hhc2hQYXRoQ29kZXJzJGhhc2hULmVuY29kZVBhdGgsXG4gICAgICBkZWNvZGVQYXRoID0gX0hhc2hQYXRoQ29kZXJzJGhhc2hULmRlY29kZVBhdGg7XG5cbiAgZnVuY3Rpb24gZ2V0RE9NTG9jYXRpb24oKSB7XG4gICAgdmFyIHBhdGggPSBkZWNvZGVQYXRoKGdldEhhc2hQYXRoKCkpO1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IHdhcm5pbmcoIWJhc2VuYW1lIHx8IGhhc0Jhc2VuYW1lKHBhdGgsIGJhc2VuYW1lKSwgJ1lvdSBhcmUgYXR0ZW1wdGluZyB0byB1c2UgYSBiYXNlbmFtZSBvbiBhIHBhZ2Ugd2hvc2UgVVJMIHBhdGggZG9lcyBub3QgYmVnaW4gJyArICd3aXRoIHRoZSBiYXNlbmFtZS4gRXhwZWN0ZWQgcGF0aCBcIicgKyBwYXRoICsgJ1wiIHRvIGJlZ2luIHdpdGggXCInICsgYmFzZW5hbWUgKyAnXCIuJykgOiB2b2lkIDA7XG4gICAgaWYgKGJhc2VuYW1lKSBwYXRoID0gc3RyaXBCYXNlbmFtZShwYXRoLCBiYXNlbmFtZSk7XG4gICAgcmV0dXJuIGNyZWF0ZUxvY2F0aW9uKHBhdGgpO1xuICB9XG5cbiAgdmFyIHRyYW5zaXRpb25NYW5hZ2VyID0gY3JlYXRlVHJhbnNpdGlvbk1hbmFnZXIoKTtcblxuICBmdW5jdGlvbiBzZXRTdGF0ZShuZXh0U3RhdGUpIHtcbiAgICBfZXh0ZW5kcyhoaXN0b3J5LCBuZXh0U3RhdGUpO1xuXG4gICAgaGlzdG9yeS5sZW5ndGggPSBnbG9iYWxIaXN0b3J5Lmxlbmd0aDtcbiAgICB0cmFuc2l0aW9uTWFuYWdlci5ub3RpZnlMaXN0ZW5lcnMoaGlzdG9yeS5sb2NhdGlvbiwgaGlzdG9yeS5hY3Rpb24pO1xuICB9XG5cbiAgdmFyIGZvcmNlTmV4dFBvcCA9IGZhbHNlO1xuICB2YXIgaWdub3JlUGF0aCA9IG51bGw7XG5cbiAgZnVuY3Rpb24gbG9jYXRpb25zQXJlRXF1YWwkJDEoYSwgYikge1xuICAgIHJldHVybiBhLnBhdGhuYW1lID09PSBiLnBhdGhuYW1lICYmIGEuc2VhcmNoID09PSBiLnNlYXJjaCAmJiBhLmhhc2ggPT09IGIuaGFzaDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGhhbmRsZUhhc2hDaGFuZ2UoKSB7XG4gICAgdmFyIHBhdGggPSBnZXRIYXNoUGF0aCgpO1xuICAgIHZhciBlbmNvZGVkUGF0aCA9IGVuY29kZVBhdGgocGF0aCk7XG5cbiAgICBpZiAocGF0aCAhPT0gZW5jb2RlZFBhdGgpIHtcbiAgICAgIC8vIEVuc3VyZSB3ZSBhbHdheXMgaGF2ZSBhIHByb3Blcmx5LWVuY29kZWQgaGFzaC5cbiAgICAgIHJlcGxhY2VIYXNoUGF0aChlbmNvZGVkUGF0aCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBsb2NhdGlvbiA9IGdldERPTUxvY2F0aW9uKCk7XG4gICAgICB2YXIgcHJldkxvY2F0aW9uID0gaGlzdG9yeS5sb2NhdGlvbjtcbiAgICAgIGlmICghZm9yY2VOZXh0UG9wICYmIGxvY2F0aW9uc0FyZUVxdWFsJCQxKHByZXZMb2NhdGlvbiwgbG9jYXRpb24pKSByZXR1cm47IC8vIEEgaGFzaGNoYW5nZSBkb2Vzbid0IGFsd2F5cyA9PSBsb2NhdGlvbiBjaGFuZ2UuXG5cbiAgICAgIGlmIChpZ25vcmVQYXRoID09PSBjcmVhdGVQYXRoKGxvY2F0aW9uKSkgcmV0dXJuOyAvLyBJZ25vcmUgdGhpcyBjaGFuZ2U7IHdlIGFscmVhZHkgc2V0U3RhdGUgaW4gcHVzaC9yZXBsYWNlLlxuXG4gICAgICBpZ25vcmVQYXRoID0gbnVsbDtcbiAgICAgIGhhbmRsZVBvcChsb2NhdGlvbik7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaGFuZGxlUG9wKGxvY2F0aW9uKSB7XG4gICAgaWYgKGZvcmNlTmV4dFBvcCkge1xuICAgICAgZm9yY2VOZXh0UG9wID0gZmFsc2U7XG4gICAgICBzZXRTdGF0ZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgYWN0aW9uID0gJ1BPUCc7XG4gICAgICB0cmFuc2l0aW9uTWFuYWdlci5jb25maXJtVHJhbnNpdGlvblRvKGxvY2F0aW9uLCBhY3Rpb24sIGdldFVzZXJDb25maXJtYXRpb24sIGZ1bmN0aW9uIChvaykge1xuICAgICAgICBpZiAob2spIHtcbiAgICAgICAgICBzZXRTdGF0ZSh7XG4gICAgICAgICAgICBhY3Rpb246IGFjdGlvbixcbiAgICAgICAgICAgIGxvY2F0aW9uOiBsb2NhdGlvblxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldmVydFBvcChsb2NhdGlvbik7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJldmVydFBvcChmcm9tTG9jYXRpb24pIHtcbiAgICB2YXIgdG9Mb2NhdGlvbiA9IGhpc3RvcnkubG9jYXRpb247IC8vIFRPRE86IFdlIGNvdWxkIHByb2JhYmx5IG1ha2UgdGhpcyBtb3JlIHJlbGlhYmxlIGJ5XG4gICAgLy8ga2VlcGluZyBhIGxpc3Qgb2YgcGF0aHMgd2UndmUgc2VlbiBpbiBzZXNzaW9uU3RvcmFnZS5cbiAgICAvLyBJbnN0ZWFkLCB3ZSBqdXN0IGRlZmF1bHQgdG8gMCBmb3IgcGF0aHMgd2UgZG9uJ3Qga25vdy5cblxuICAgIHZhciB0b0luZGV4ID0gYWxsUGF0aHMubGFzdEluZGV4T2YoY3JlYXRlUGF0aCh0b0xvY2F0aW9uKSk7XG4gICAgaWYgKHRvSW5kZXggPT09IC0xKSB0b0luZGV4ID0gMDtcbiAgICB2YXIgZnJvbUluZGV4ID0gYWxsUGF0aHMubGFzdEluZGV4T2YoY3JlYXRlUGF0aChmcm9tTG9jYXRpb24pKTtcbiAgICBpZiAoZnJvbUluZGV4ID09PSAtMSkgZnJvbUluZGV4ID0gMDtcbiAgICB2YXIgZGVsdGEgPSB0b0luZGV4IC0gZnJvbUluZGV4O1xuXG4gICAgaWYgKGRlbHRhKSB7XG4gICAgICBmb3JjZU5leHRQb3AgPSB0cnVlO1xuICAgICAgZ28oZGVsdGEpO1xuICAgIH1cbiAgfSAvLyBFbnN1cmUgdGhlIGhhc2ggaXMgZW5jb2RlZCBwcm9wZXJseSBiZWZvcmUgZG9pbmcgYW55dGhpbmcgZWxzZS5cblxuXG4gIHZhciBwYXRoID0gZ2V0SGFzaFBhdGgoKTtcbiAgdmFyIGVuY29kZWRQYXRoID0gZW5jb2RlUGF0aChwYXRoKTtcbiAgaWYgKHBhdGggIT09IGVuY29kZWRQYXRoKSByZXBsYWNlSGFzaFBhdGgoZW5jb2RlZFBhdGgpO1xuICB2YXIgaW5pdGlhbExvY2F0aW9uID0gZ2V0RE9NTG9jYXRpb24oKTtcbiAgdmFyIGFsbFBhdGhzID0gW2NyZWF0ZVBhdGgoaW5pdGlhbExvY2F0aW9uKV07IC8vIFB1YmxpYyBpbnRlcmZhY2VcblxuICBmdW5jdGlvbiBjcmVhdGVIcmVmKGxvY2F0aW9uKSB7XG4gICAgdmFyIGJhc2VUYWcgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdiYXNlJyk7XG4gICAgdmFyIGhyZWYgPSAnJztcblxuICAgIGlmIChiYXNlVGFnICYmIGJhc2VUYWcuZ2V0QXR0cmlidXRlKCdocmVmJykpIHtcbiAgICAgIGhyZWYgPSBzdHJpcEhhc2god2luZG93LmxvY2F0aW9uLmhyZWYpO1xuICAgIH1cblxuICAgIHJldHVybiBocmVmICsgJyMnICsgZW5jb2RlUGF0aChiYXNlbmFtZSArIGNyZWF0ZVBhdGgobG9jYXRpb24pKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHB1c2gocGF0aCwgc3RhdGUpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyB3YXJuaW5nKHN0YXRlID09PSB1bmRlZmluZWQsICdIYXNoIGhpc3RvcnkgY2Fubm90IHB1c2ggc3RhdGU7IGl0IGlzIGlnbm9yZWQnKSA6IHZvaWQgMDtcbiAgICB2YXIgYWN0aW9uID0gJ1BVU0gnO1xuICAgIHZhciBsb2NhdGlvbiA9IGNyZWF0ZUxvY2F0aW9uKHBhdGgsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBoaXN0b3J5LmxvY2F0aW9uKTtcbiAgICB0cmFuc2l0aW9uTWFuYWdlci5jb25maXJtVHJhbnNpdGlvblRvKGxvY2F0aW9uLCBhY3Rpb24sIGdldFVzZXJDb25maXJtYXRpb24sIGZ1bmN0aW9uIChvaykge1xuICAgICAgaWYgKCFvaykgcmV0dXJuO1xuICAgICAgdmFyIHBhdGggPSBjcmVhdGVQYXRoKGxvY2F0aW9uKTtcbiAgICAgIHZhciBlbmNvZGVkUGF0aCA9IGVuY29kZVBhdGgoYmFzZW5hbWUgKyBwYXRoKTtcbiAgICAgIHZhciBoYXNoQ2hhbmdlZCA9IGdldEhhc2hQYXRoKCkgIT09IGVuY29kZWRQYXRoO1xuXG4gICAgICBpZiAoaGFzaENoYW5nZWQpIHtcbiAgICAgICAgLy8gV2UgY2Fubm90IHRlbGwgaWYgYSBoYXNoY2hhbmdlIHdhcyBjYXVzZWQgYnkgYSBQVVNILCBzbyB3ZSdkXG4gICAgICAgIC8vIHJhdGhlciBzZXRTdGF0ZSBoZXJlIGFuZCBpZ25vcmUgdGhlIGhhc2hjaGFuZ2UuIFRoZSBjYXZlYXQgaGVyZVxuICAgICAgICAvLyBpcyB0aGF0IG90aGVyIGhhc2ggaGlzdG9yaWVzIGluIHRoZSBwYWdlIHdpbGwgY29uc2lkZXIgaXQgYSBQT1AuXG4gICAgICAgIGlnbm9yZVBhdGggPSBwYXRoO1xuICAgICAgICBwdXNoSGFzaFBhdGgoZW5jb2RlZFBhdGgpO1xuICAgICAgICB2YXIgcHJldkluZGV4ID0gYWxsUGF0aHMubGFzdEluZGV4T2YoY3JlYXRlUGF0aChoaXN0b3J5LmxvY2F0aW9uKSk7XG4gICAgICAgIHZhciBuZXh0UGF0aHMgPSBhbGxQYXRocy5zbGljZSgwLCBwcmV2SW5kZXggKyAxKTtcbiAgICAgICAgbmV4dFBhdGhzLnB1c2gocGF0aCk7XG4gICAgICAgIGFsbFBhdGhzID0gbmV4dFBhdGhzO1xuICAgICAgICBzZXRTdGF0ZSh7XG4gICAgICAgICAgYWN0aW9uOiBhY3Rpb24sXG4gICAgICAgICAgbG9jYXRpb246IGxvY2F0aW9uXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gd2FybmluZyhmYWxzZSwgJ0hhc2ggaGlzdG9yeSBjYW5ub3QgUFVTSCB0aGUgc2FtZSBwYXRoOyBhIG5ldyBlbnRyeSB3aWxsIG5vdCBiZSBhZGRlZCB0byB0aGUgaGlzdG9yeSBzdGFjaycpIDogdm9pZCAwO1xuICAgICAgICBzZXRTdGF0ZSgpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVwbGFjZShwYXRoLCBzdGF0ZSkge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IHdhcm5pbmcoc3RhdGUgPT09IHVuZGVmaW5lZCwgJ0hhc2ggaGlzdG9yeSBjYW5ub3QgcmVwbGFjZSBzdGF0ZTsgaXQgaXMgaWdub3JlZCcpIDogdm9pZCAwO1xuICAgIHZhciBhY3Rpb24gPSAnUkVQTEFDRSc7XG4gICAgdmFyIGxvY2F0aW9uID0gY3JlYXRlTG9jYXRpb24ocGF0aCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGhpc3RvcnkubG9jYXRpb24pO1xuICAgIHRyYW5zaXRpb25NYW5hZ2VyLmNvbmZpcm1UcmFuc2l0aW9uVG8obG9jYXRpb24sIGFjdGlvbiwgZ2V0VXNlckNvbmZpcm1hdGlvbiwgZnVuY3Rpb24gKG9rKSB7XG4gICAgICBpZiAoIW9rKSByZXR1cm47XG4gICAgICB2YXIgcGF0aCA9IGNyZWF0ZVBhdGgobG9jYXRpb24pO1xuICAgICAgdmFyIGVuY29kZWRQYXRoID0gZW5jb2RlUGF0aChiYXNlbmFtZSArIHBhdGgpO1xuICAgICAgdmFyIGhhc2hDaGFuZ2VkID0gZ2V0SGFzaFBhdGgoKSAhPT0gZW5jb2RlZFBhdGg7XG5cbiAgICAgIGlmIChoYXNoQ2hhbmdlZCkge1xuICAgICAgICAvLyBXZSBjYW5ub3QgdGVsbCBpZiBhIGhhc2hjaGFuZ2Ugd2FzIGNhdXNlZCBieSBhIFJFUExBQ0UsIHNvIHdlJ2RcbiAgICAgICAgLy8gcmF0aGVyIHNldFN0YXRlIGhlcmUgYW5kIGlnbm9yZSB0aGUgaGFzaGNoYW5nZS4gVGhlIGNhdmVhdCBoZXJlXG4gICAgICAgIC8vIGlzIHRoYXQgb3RoZXIgaGFzaCBoaXN0b3JpZXMgaW4gdGhlIHBhZ2Ugd2lsbCBjb25zaWRlciBpdCBhIFBPUC5cbiAgICAgICAgaWdub3JlUGF0aCA9IHBhdGg7XG4gICAgICAgIHJlcGxhY2VIYXNoUGF0aChlbmNvZGVkUGF0aCk7XG4gICAgICB9XG5cbiAgICAgIHZhciBwcmV2SW5kZXggPSBhbGxQYXRocy5pbmRleE9mKGNyZWF0ZVBhdGgoaGlzdG9yeS5sb2NhdGlvbikpO1xuICAgICAgaWYgKHByZXZJbmRleCAhPT0gLTEpIGFsbFBhdGhzW3ByZXZJbmRleF0gPSBwYXRoO1xuICAgICAgc2V0U3RhdGUoe1xuICAgICAgICBhY3Rpb246IGFjdGlvbixcbiAgICAgICAgbG9jYXRpb246IGxvY2F0aW9uXG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdvKG4pIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyB3YXJuaW5nKGNhbkdvV2l0aG91dFJlbG9hZCwgJ0hhc2ggaGlzdG9yeSBnbyhuKSBjYXVzZXMgYSBmdWxsIHBhZ2UgcmVsb2FkIGluIHRoaXMgYnJvd3NlcicpIDogdm9pZCAwO1xuICAgIGdsb2JhbEhpc3RvcnkuZ28obik7XG4gIH1cblxuICBmdW5jdGlvbiBnb0JhY2soKSB7XG4gICAgZ28oLTEpO1xuICB9XG5cbiAgZnVuY3Rpb24gZ29Gb3J3YXJkKCkge1xuICAgIGdvKDEpO1xuICB9XG5cbiAgdmFyIGxpc3RlbmVyQ291bnQgPSAwO1xuXG4gIGZ1bmN0aW9uIGNoZWNrRE9NTGlzdGVuZXJzKGRlbHRhKSB7XG4gICAgbGlzdGVuZXJDb3VudCArPSBkZWx0YTtcblxuICAgIGlmIChsaXN0ZW5lckNvdW50ID09PSAxICYmIGRlbHRhID09PSAxKSB7XG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihIYXNoQ2hhbmdlRXZlbnQkMSwgaGFuZGxlSGFzaENoYW5nZSk7XG4gICAgfSBlbHNlIGlmIChsaXN0ZW5lckNvdW50ID09PSAwKSB7XG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihIYXNoQ2hhbmdlRXZlbnQkMSwgaGFuZGxlSGFzaENoYW5nZSk7XG4gICAgfVxuICB9XG5cbiAgdmFyIGlzQmxvY2tlZCA9IGZhbHNlO1xuXG4gIGZ1bmN0aW9uIGJsb2NrKHByb21wdCkge1xuICAgIGlmIChwcm9tcHQgPT09IHZvaWQgMCkge1xuICAgICAgcHJvbXB0ID0gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIHVuYmxvY2sgPSB0cmFuc2l0aW9uTWFuYWdlci5zZXRQcm9tcHQocHJvbXB0KTtcblxuICAgIGlmICghaXNCbG9ja2VkKSB7XG4gICAgICBjaGVja0RPTUxpc3RlbmVycygxKTtcbiAgICAgIGlzQmxvY2tlZCA9IHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChpc0Jsb2NrZWQpIHtcbiAgICAgICAgaXNCbG9ja2VkID0gZmFsc2U7XG4gICAgICAgIGNoZWNrRE9NTGlzdGVuZXJzKC0xKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHVuYmxvY2soKTtcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gbGlzdGVuKGxpc3RlbmVyKSB7XG4gICAgdmFyIHVubGlzdGVuID0gdHJhbnNpdGlvbk1hbmFnZXIuYXBwZW5kTGlzdGVuZXIobGlzdGVuZXIpO1xuICAgIGNoZWNrRE9NTGlzdGVuZXJzKDEpO1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICBjaGVja0RPTUxpc3RlbmVycygtMSk7XG4gICAgICB1bmxpc3RlbigpO1xuICAgIH07XG4gIH1cblxuICB2YXIgaGlzdG9yeSA9IHtcbiAgICBsZW5ndGg6IGdsb2JhbEhpc3RvcnkubGVuZ3RoLFxuICAgIGFjdGlvbjogJ1BPUCcsXG4gICAgbG9jYXRpb246IGluaXRpYWxMb2NhdGlvbixcbiAgICBjcmVhdGVIcmVmOiBjcmVhdGVIcmVmLFxuICAgIHB1c2g6IHB1c2gsXG4gICAgcmVwbGFjZTogcmVwbGFjZSxcbiAgICBnbzogZ28sXG4gICAgZ29CYWNrOiBnb0JhY2ssXG4gICAgZ29Gb3J3YXJkOiBnb0ZvcndhcmQsXG4gICAgYmxvY2s6IGJsb2NrLFxuICAgIGxpc3RlbjogbGlzdGVuXG4gIH07XG4gIHJldHVybiBoaXN0b3J5O1xufVxuXG5mdW5jdGlvbiBjbGFtcChuLCBsb3dlckJvdW5kLCB1cHBlckJvdW5kKSB7XG4gIHJldHVybiBNYXRoLm1pbihNYXRoLm1heChuLCBsb3dlckJvdW5kKSwgdXBwZXJCb3VuZCk7XG59XG4vKipcbiAqIENyZWF0ZXMgYSBoaXN0b3J5IG9iamVjdCB0aGF0IHN0b3JlcyBsb2NhdGlvbnMgaW4gbWVtb3J5LlxuICovXG5cblxuZnVuY3Rpb24gY3JlYXRlTWVtb3J5SGlzdG9yeShwcm9wcykge1xuICBpZiAocHJvcHMgPT09IHZvaWQgMCkge1xuICAgIHByb3BzID0ge307XG4gIH1cblxuICB2YXIgX3Byb3BzID0gcHJvcHMsXG4gICAgICBnZXRVc2VyQ29uZmlybWF0aW9uID0gX3Byb3BzLmdldFVzZXJDb25maXJtYXRpb24sXG4gICAgICBfcHJvcHMkaW5pdGlhbEVudHJpZXMgPSBfcHJvcHMuaW5pdGlhbEVudHJpZXMsXG4gICAgICBpbml0aWFsRW50cmllcyA9IF9wcm9wcyRpbml0aWFsRW50cmllcyA9PT0gdm9pZCAwID8gWycvJ10gOiBfcHJvcHMkaW5pdGlhbEVudHJpZXMsXG4gICAgICBfcHJvcHMkaW5pdGlhbEluZGV4ID0gX3Byb3BzLmluaXRpYWxJbmRleCxcbiAgICAgIGluaXRpYWxJbmRleCA9IF9wcm9wcyRpbml0aWFsSW5kZXggPT09IHZvaWQgMCA/IDAgOiBfcHJvcHMkaW5pdGlhbEluZGV4LFxuICAgICAgX3Byb3BzJGtleUxlbmd0aCA9IF9wcm9wcy5rZXlMZW5ndGgsXG4gICAgICBrZXlMZW5ndGggPSBfcHJvcHMka2V5TGVuZ3RoID09PSB2b2lkIDAgPyA2IDogX3Byb3BzJGtleUxlbmd0aDtcbiAgdmFyIHRyYW5zaXRpb25NYW5hZ2VyID0gY3JlYXRlVHJhbnNpdGlvbk1hbmFnZXIoKTtcblxuICBmdW5jdGlvbiBzZXRTdGF0ZShuZXh0U3RhdGUpIHtcbiAgICBfZXh0ZW5kcyhoaXN0b3J5LCBuZXh0U3RhdGUpO1xuXG4gICAgaGlzdG9yeS5sZW5ndGggPSBoaXN0b3J5LmVudHJpZXMubGVuZ3RoO1xuICAgIHRyYW5zaXRpb25NYW5hZ2VyLm5vdGlmeUxpc3RlbmVycyhoaXN0b3J5LmxvY2F0aW9uLCBoaXN0b3J5LmFjdGlvbik7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVLZXkoKSB7XG4gICAgcmV0dXJuIE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnN1YnN0cigyLCBrZXlMZW5ndGgpO1xuICB9XG5cbiAgdmFyIGluZGV4ID0gY2xhbXAoaW5pdGlhbEluZGV4LCAwLCBpbml0aWFsRW50cmllcy5sZW5ndGggLSAxKTtcbiAgdmFyIGVudHJpZXMgPSBpbml0aWFsRW50cmllcy5tYXAoZnVuY3Rpb24gKGVudHJ5KSB7XG4gICAgcmV0dXJuIHR5cGVvZiBlbnRyeSA9PT0gJ3N0cmluZycgPyBjcmVhdGVMb2NhdGlvbihlbnRyeSwgdW5kZWZpbmVkLCBjcmVhdGVLZXkoKSkgOiBjcmVhdGVMb2NhdGlvbihlbnRyeSwgdW5kZWZpbmVkLCBlbnRyeS5rZXkgfHwgY3JlYXRlS2V5KCkpO1xuICB9KTsgLy8gUHVibGljIGludGVyZmFjZVxuXG4gIHZhciBjcmVhdGVIcmVmID0gY3JlYXRlUGF0aDtcblxuICBmdW5jdGlvbiBwdXNoKHBhdGgsIHN0YXRlKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gd2FybmluZyghKHR5cGVvZiBwYXRoID09PSAnb2JqZWN0JyAmJiBwYXRoLnN0YXRlICE9PSB1bmRlZmluZWQgJiYgc3RhdGUgIT09IHVuZGVmaW5lZCksICdZb3Ugc2hvdWxkIGF2b2lkIHByb3ZpZGluZyBhIDJuZCBzdGF0ZSBhcmd1bWVudCB0byBwdXNoIHdoZW4gdGhlIDFzdCAnICsgJ2FyZ3VtZW50IGlzIGEgbG9jYXRpb24tbGlrZSBvYmplY3QgdGhhdCBhbHJlYWR5IGhhcyBzdGF0ZTsgaXQgaXMgaWdub3JlZCcpIDogdm9pZCAwO1xuICAgIHZhciBhY3Rpb24gPSAnUFVTSCc7XG4gICAgdmFyIGxvY2F0aW9uID0gY3JlYXRlTG9jYXRpb24ocGF0aCwgc3RhdGUsIGNyZWF0ZUtleSgpLCBoaXN0b3J5LmxvY2F0aW9uKTtcbiAgICB0cmFuc2l0aW9uTWFuYWdlci5jb25maXJtVHJhbnNpdGlvblRvKGxvY2F0aW9uLCBhY3Rpb24sIGdldFVzZXJDb25maXJtYXRpb24sIGZ1bmN0aW9uIChvaykge1xuICAgICAgaWYgKCFvaykgcmV0dXJuO1xuICAgICAgdmFyIHByZXZJbmRleCA9IGhpc3RvcnkuaW5kZXg7XG4gICAgICB2YXIgbmV4dEluZGV4ID0gcHJldkluZGV4ICsgMTtcbiAgICAgIHZhciBuZXh0RW50cmllcyA9IGhpc3RvcnkuZW50cmllcy5zbGljZSgwKTtcblxuICAgICAgaWYgKG5leHRFbnRyaWVzLmxlbmd0aCA+IG5leHRJbmRleCkge1xuICAgICAgICBuZXh0RW50cmllcy5zcGxpY2UobmV4dEluZGV4LCBuZXh0RW50cmllcy5sZW5ndGggLSBuZXh0SW5kZXgsIGxvY2F0aW9uKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5leHRFbnRyaWVzLnB1c2gobG9jYXRpb24pO1xuICAgICAgfVxuXG4gICAgICBzZXRTdGF0ZSh7XG4gICAgICAgIGFjdGlvbjogYWN0aW9uLFxuICAgICAgICBsb2NhdGlvbjogbG9jYXRpb24sXG4gICAgICAgIGluZGV4OiBuZXh0SW5kZXgsXG4gICAgICAgIGVudHJpZXM6IG5leHRFbnRyaWVzXG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlcGxhY2UocGF0aCwgc3RhdGUpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyB3YXJuaW5nKCEodHlwZW9mIHBhdGggPT09ICdvYmplY3QnICYmIHBhdGguc3RhdGUgIT09IHVuZGVmaW5lZCAmJiBzdGF0ZSAhPT0gdW5kZWZpbmVkKSwgJ1lvdSBzaG91bGQgYXZvaWQgcHJvdmlkaW5nIGEgMm5kIHN0YXRlIGFyZ3VtZW50IHRvIHJlcGxhY2Ugd2hlbiB0aGUgMXN0ICcgKyAnYXJndW1lbnQgaXMgYSBsb2NhdGlvbi1saWtlIG9iamVjdCB0aGF0IGFscmVhZHkgaGFzIHN0YXRlOyBpdCBpcyBpZ25vcmVkJykgOiB2b2lkIDA7XG4gICAgdmFyIGFjdGlvbiA9ICdSRVBMQUNFJztcbiAgICB2YXIgbG9jYXRpb24gPSBjcmVhdGVMb2NhdGlvbihwYXRoLCBzdGF0ZSwgY3JlYXRlS2V5KCksIGhpc3RvcnkubG9jYXRpb24pO1xuICAgIHRyYW5zaXRpb25NYW5hZ2VyLmNvbmZpcm1UcmFuc2l0aW9uVG8obG9jYXRpb24sIGFjdGlvbiwgZ2V0VXNlckNvbmZpcm1hdGlvbiwgZnVuY3Rpb24gKG9rKSB7XG4gICAgICBpZiAoIW9rKSByZXR1cm47XG4gICAgICBoaXN0b3J5LmVudHJpZXNbaGlzdG9yeS5pbmRleF0gPSBsb2NhdGlvbjtcbiAgICAgIHNldFN0YXRlKHtcbiAgICAgICAgYWN0aW9uOiBhY3Rpb24sXG4gICAgICAgIGxvY2F0aW9uOiBsb2NhdGlvblxuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBnbyhuKSB7XG4gICAgdmFyIG5leHRJbmRleCA9IGNsYW1wKGhpc3RvcnkuaW5kZXggKyBuLCAwLCBoaXN0b3J5LmVudHJpZXMubGVuZ3RoIC0gMSk7XG4gICAgdmFyIGFjdGlvbiA9ICdQT1AnO1xuICAgIHZhciBsb2NhdGlvbiA9IGhpc3RvcnkuZW50cmllc1tuZXh0SW5kZXhdO1xuICAgIHRyYW5zaXRpb25NYW5hZ2VyLmNvbmZpcm1UcmFuc2l0aW9uVG8obG9jYXRpb24sIGFjdGlvbiwgZ2V0VXNlckNvbmZpcm1hdGlvbiwgZnVuY3Rpb24gKG9rKSB7XG4gICAgICBpZiAob2spIHtcbiAgICAgICAgc2V0U3RhdGUoe1xuICAgICAgICAgIGFjdGlvbjogYWN0aW9uLFxuICAgICAgICAgIGxvY2F0aW9uOiBsb2NhdGlvbixcbiAgICAgICAgICBpbmRleDogbmV4dEluZGV4XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gTWltaWMgdGhlIGJlaGF2aW9yIG9mIERPTSBoaXN0b3JpZXMgYnlcbiAgICAgICAgLy8gY2F1c2luZyBhIHJlbmRlciBhZnRlciBhIGNhbmNlbGxlZCBQT1AuXG4gICAgICAgIHNldFN0YXRlKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBnb0JhY2soKSB7XG4gICAgZ28oLTEpO1xuICB9XG5cbiAgZnVuY3Rpb24gZ29Gb3J3YXJkKCkge1xuICAgIGdvKDEpO1xuICB9XG5cbiAgZnVuY3Rpb24gY2FuR28obikge1xuICAgIHZhciBuZXh0SW5kZXggPSBoaXN0b3J5LmluZGV4ICsgbjtcbiAgICByZXR1cm4gbmV4dEluZGV4ID49IDAgJiYgbmV4dEluZGV4IDwgaGlzdG9yeS5lbnRyaWVzLmxlbmd0aDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGJsb2NrKHByb21wdCkge1xuICAgIGlmIChwcm9tcHQgPT09IHZvaWQgMCkge1xuICAgICAgcHJvbXB0ID0gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRyYW5zaXRpb25NYW5hZ2VyLnNldFByb21wdChwcm9tcHQpO1xuICB9XG5cbiAgZnVuY3Rpb24gbGlzdGVuKGxpc3RlbmVyKSB7XG4gICAgcmV0dXJuIHRyYW5zaXRpb25NYW5hZ2VyLmFwcGVuZExpc3RlbmVyKGxpc3RlbmVyKTtcbiAgfVxuXG4gIHZhciBoaXN0b3J5ID0ge1xuICAgIGxlbmd0aDogZW50cmllcy5sZW5ndGgsXG4gICAgYWN0aW9uOiAnUE9QJyxcbiAgICBsb2NhdGlvbjogZW50cmllc1tpbmRleF0sXG4gICAgaW5kZXg6IGluZGV4LFxuICAgIGVudHJpZXM6IGVudHJpZXMsXG4gICAgY3JlYXRlSHJlZjogY3JlYXRlSHJlZixcbiAgICBwdXNoOiBwdXNoLFxuICAgIHJlcGxhY2U6IHJlcGxhY2UsXG4gICAgZ286IGdvLFxuICAgIGdvQmFjazogZ29CYWNrLFxuICAgIGdvRm9yd2FyZDogZ29Gb3J3YXJkLFxuICAgIGNhbkdvOiBjYW5HbyxcbiAgICBibG9jazogYmxvY2ssXG4gICAgbGlzdGVuOiBsaXN0ZW5cbiAgfTtcbiAgcmV0dXJuIGhpc3Rvcnk7XG59XG5cbmV4cG9ydCB7IGNyZWF0ZUJyb3dzZXJIaXN0b3J5LCBjcmVhdGVIYXNoSGlzdG9yeSwgY3JlYXRlTWVtb3J5SGlzdG9yeSwgY3JlYXRlTG9jYXRpb24sIGxvY2F0aW9uc0FyZUVxdWFsLCBwYXJzZVBhdGgsIGNyZWF0ZVBhdGggfTtcbiIsImltcG9ydCBSZWFjdCwgeyBDb21wb25lbnQgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgX2luaGVyaXRzTG9vc2UgZnJvbSAnQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vaW5oZXJpdHNMb29zZSc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IHdhcm5pbmcgZnJvbSAndGlueS13YXJuaW5nJztcblxudmFyIE1BWF9TSUdORURfMzFfQklUX0lOVCA9IDEwNzM3NDE4MjM7XG52YXIgY29tbW9uanNHbG9iYWwgPSB0eXBlb2YgZ2xvYmFsVGhpcyAhPT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWxUaGlzIDogdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cgOiB0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJyA/IGdsb2JhbCA6IHt9O1xuXG5mdW5jdGlvbiBnZXRVbmlxdWVJZCgpIHtcbiAgdmFyIGtleSA9ICdfX2dsb2JhbF91bmlxdWVfaWRfXyc7XG4gIHJldHVybiBjb21tb25qc0dsb2JhbFtrZXldID0gKGNvbW1vbmpzR2xvYmFsW2tleV0gfHwgMCkgKyAxO1xufVxuXG5mdW5jdGlvbiBvYmplY3RJcyh4LCB5KSB7XG4gIGlmICh4ID09PSB5KSB7XG4gICAgcmV0dXJuIHggIT09IDAgfHwgMSAvIHggPT09IDEgLyB5O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB4ICE9PSB4ICYmIHkgIT09IHk7XG4gIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlRXZlbnRFbWl0dGVyKHZhbHVlKSB7XG4gIHZhciBoYW5kbGVycyA9IFtdO1xuICByZXR1cm4ge1xuICAgIG9uOiBmdW5jdGlvbiBvbihoYW5kbGVyKSB7XG4gICAgICBoYW5kbGVycy5wdXNoKGhhbmRsZXIpO1xuICAgIH0sXG4gICAgb2ZmOiBmdW5jdGlvbiBvZmYoaGFuZGxlcikge1xuICAgICAgaGFuZGxlcnMgPSBoYW5kbGVycy5maWx0ZXIoZnVuY3Rpb24gKGgpIHtcbiAgICAgICAgcmV0dXJuIGggIT09IGhhbmRsZXI7XG4gICAgICB9KTtcbiAgICB9LFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQobmV3VmFsdWUsIGNoYW5nZWRCaXRzKSB7XG4gICAgICB2YWx1ZSA9IG5ld1ZhbHVlO1xuICAgICAgaGFuZGxlcnMuZm9yRWFjaChmdW5jdGlvbiAoaGFuZGxlcikge1xuICAgICAgICByZXR1cm4gaGFuZGxlcih2YWx1ZSwgY2hhbmdlZEJpdHMpO1xuICAgICAgfSk7XG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiBvbmx5Q2hpbGQoY2hpbGRyZW4pIHtcbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pID8gY2hpbGRyZW5bMF0gOiBjaGlsZHJlbjtcbn1cblxuZnVuY3Rpb24gY3JlYXRlUmVhY3RDb250ZXh0KGRlZmF1bHRWYWx1ZSwgY2FsY3VsYXRlQ2hhbmdlZEJpdHMpIHtcbiAgdmFyIF9Qcm92aWRlciRjaGlsZENvbnRleCwgX0NvbnN1bWVyJGNvbnRleHRUeXBlO1xuXG4gIHZhciBjb250ZXh0UHJvcCA9ICdfX2NyZWF0ZS1yZWFjdC1jb250ZXh0LScgKyBnZXRVbmlxdWVJZCgpICsgJ19fJztcblxuICB2YXIgUHJvdmlkZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9Db21wb25lbnQpIHtcbiAgICBfaW5oZXJpdHNMb29zZShQcm92aWRlciwgX0NvbXBvbmVudCk7XG5cbiAgICBmdW5jdGlvbiBQcm92aWRlcigpIHtcbiAgICAgIHZhciBfdGhpcztcblxuICAgICAgX3RoaXMgPSBfQ29tcG9uZW50LmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgIF90aGlzLmVtaXR0ZXIgPSBjcmVhdGVFdmVudEVtaXR0ZXIoX3RoaXMucHJvcHMudmFsdWUpO1xuICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cblxuICAgIHZhciBfcHJvdG8gPSBQcm92aWRlci5wcm90b3R5cGU7XG5cbiAgICBfcHJvdG8uZ2V0Q2hpbGRDb250ZXh0ID0gZnVuY3Rpb24gZ2V0Q2hpbGRDb250ZXh0KCkge1xuICAgICAgdmFyIF9yZWY7XG5cbiAgICAgIHJldHVybiBfcmVmID0ge30sIF9yZWZbY29udGV4dFByb3BdID0gdGhpcy5lbWl0dGVyLCBfcmVmO1xuICAgIH07XG5cbiAgICBfcHJvdG8uY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyA9IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMobmV4dFByb3BzKSB7XG4gICAgICBpZiAodGhpcy5wcm9wcy52YWx1ZSAhPT0gbmV4dFByb3BzLnZhbHVlKSB7XG4gICAgICAgIHZhciBvbGRWYWx1ZSA9IHRoaXMucHJvcHMudmFsdWU7XG4gICAgICAgIHZhciBuZXdWYWx1ZSA9IG5leHRQcm9wcy52YWx1ZTtcbiAgICAgICAgdmFyIGNoYW5nZWRCaXRzO1xuXG4gICAgICAgIGlmIChvYmplY3RJcyhvbGRWYWx1ZSwgbmV3VmFsdWUpKSB7XG4gICAgICAgICAgY2hhbmdlZEJpdHMgPSAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNoYW5nZWRCaXRzID0gdHlwZW9mIGNhbGN1bGF0ZUNoYW5nZWRCaXRzID09PSAnZnVuY3Rpb24nID8gY2FsY3VsYXRlQ2hhbmdlZEJpdHMob2xkVmFsdWUsIG5ld1ZhbHVlKSA6IE1BWF9TSUdORURfMzFfQklUX0lOVDtcblxuICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICB3YXJuaW5nKChjaGFuZ2VkQml0cyAmIE1BWF9TSUdORURfMzFfQklUX0lOVCkgPT09IGNoYW5nZWRCaXRzLCAnY2FsY3VsYXRlQ2hhbmdlZEJpdHM6IEV4cGVjdGVkIHRoZSByZXR1cm4gdmFsdWUgdG8gYmUgYSAnICsgJzMxLWJpdCBpbnRlZ2VyLiBJbnN0ZWFkIHJlY2VpdmVkOiAnICsgY2hhbmdlZEJpdHMpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNoYW5nZWRCaXRzIHw9IDA7XG5cbiAgICAgICAgICBpZiAoY2hhbmdlZEJpdHMgIT09IDApIHtcbiAgICAgICAgICAgIHRoaXMuZW1pdHRlci5zZXQobmV4dFByb3BzLnZhbHVlLCBjaGFuZ2VkQml0cyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIF9wcm90by5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgICByZXR1cm4gdGhpcy5wcm9wcy5jaGlsZHJlbjtcbiAgICB9O1xuXG4gICAgcmV0dXJuIFByb3ZpZGVyO1xuICB9KENvbXBvbmVudCk7XG5cbiAgUHJvdmlkZXIuY2hpbGRDb250ZXh0VHlwZXMgPSAoX1Byb3ZpZGVyJGNoaWxkQ29udGV4ID0ge30sIF9Qcm92aWRlciRjaGlsZENvbnRleFtjb250ZXh0UHJvcF0gPSBQcm9wVHlwZXMub2JqZWN0LmlzUmVxdWlyZWQsIF9Qcm92aWRlciRjaGlsZENvbnRleCk7XG5cbiAgdmFyIENvbnN1bWVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfQ29tcG9uZW50Mikge1xuICAgIF9pbmhlcml0c0xvb3NlKENvbnN1bWVyLCBfQ29tcG9uZW50Mik7XG5cbiAgICBmdW5jdGlvbiBDb25zdW1lcigpIHtcbiAgICAgIHZhciBfdGhpczI7XG5cbiAgICAgIF90aGlzMiA9IF9Db21wb25lbnQyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgIF90aGlzMi5zdGF0ZSA9IHtcbiAgICAgICAgdmFsdWU6IF90aGlzMi5nZXRWYWx1ZSgpXG4gICAgICB9O1xuXG4gICAgICBfdGhpczIub25VcGRhdGUgPSBmdW5jdGlvbiAobmV3VmFsdWUsIGNoYW5nZWRCaXRzKSB7XG4gICAgICAgIHZhciBvYnNlcnZlZEJpdHMgPSBfdGhpczIub2JzZXJ2ZWRCaXRzIHwgMDtcblxuICAgICAgICBpZiAoKG9ic2VydmVkQml0cyAmIGNoYW5nZWRCaXRzKSAhPT0gMCkge1xuICAgICAgICAgIF90aGlzMi5zZXRTdGF0ZSh7XG4gICAgICAgICAgICB2YWx1ZTogX3RoaXMyLmdldFZhbHVlKClcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgcmV0dXJuIF90aGlzMjtcbiAgICB9XG5cbiAgICB2YXIgX3Byb3RvMiA9IENvbnN1bWVyLnByb3RvdHlwZTtcblxuICAgIF9wcm90bzIuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyA9IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMobmV4dFByb3BzKSB7XG4gICAgICB2YXIgb2JzZXJ2ZWRCaXRzID0gbmV4dFByb3BzLm9ic2VydmVkQml0cztcbiAgICAgIHRoaXMub2JzZXJ2ZWRCaXRzID0gb2JzZXJ2ZWRCaXRzID09PSB1bmRlZmluZWQgfHwgb2JzZXJ2ZWRCaXRzID09PSBudWxsID8gTUFYX1NJR05FRF8zMV9CSVRfSU5UIDogb2JzZXJ2ZWRCaXRzO1xuICAgIH07XG5cbiAgICBfcHJvdG8yLmNvbXBvbmVudERpZE1vdW50ID0gZnVuY3Rpb24gY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgICBpZiAodGhpcy5jb250ZXh0W2NvbnRleHRQcm9wXSkge1xuICAgICAgICB0aGlzLmNvbnRleHRbY29udGV4dFByb3BdLm9uKHRoaXMub25VcGRhdGUpO1xuICAgICAgfVxuXG4gICAgICB2YXIgb2JzZXJ2ZWRCaXRzID0gdGhpcy5wcm9wcy5vYnNlcnZlZEJpdHM7XG4gICAgICB0aGlzLm9ic2VydmVkQml0cyA9IG9ic2VydmVkQml0cyA9PT0gdW5kZWZpbmVkIHx8IG9ic2VydmVkQml0cyA9PT0gbnVsbCA/IE1BWF9TSUdORURfMzFfQklUX0lOVCA6IG9ic2VydmVkQml0cztcbiAgICB9O1xuXG4gICAgX3Byb3RvMi5jb21wb25lbnRXaWxsVW5tb3VudCA9IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgICAgaWYgKHRoaXMuY29udGV4dFtjb250ZXh0UHJvcF0pIHtcbiAgICAgICAgdGhpcy5jb250ZXh0W2NvbnRleHRQcm9wXS5vZmYodGhpcy5vblVwZGF0ZSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIF9wcm90bzIuZ2V0VmFsdWUgPSBmdW5jdGlvbiBnZXRWYWx1ZSgpIHtcbiAgICAgIGlmICh0aGlzLmNvbnRleHRbY29udGV4dFByb3BdKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnRleHRbY29udGV4dFByb3BdLmdldCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGRlZmF1bHRWYWx1ZTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgX3Byb3RvMi5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgICByZXR1cm4gb25seUNoaWxkKHRoaXMucHJvcHMuY2hpbGRyZW4pKHRoaXMuc3RhdGUudmFsdWUpO1xuICAgIH07XG5cbiAgICByZXR1cm4gQ29uc3VtZXI7XG4gIH0oQ29tcG9uZW50KTtcblxuICBDb25zdW1lci5jb250ZXh0VHlwZXMgPSAoX0NvbnN1bWVyJGNvbnRleHRUeXBlID0ge30sIF9Db25zdW1lciRjb250ZXh0VHlwZVtjb250ZXh0UHJvcF0gPSBQcm9wVHlwZXMub2JqZWN0LCBfQ29uc3VtZXIkY29udGV4dFR5cGUpO1xuICByZXR1cm4ge1xuICAgIFByb3ZpZGVyOiBQcm92aWRlcixcbiAgICBDb25zdW1lcjogQ29uc3VtZXJcbiAgfTtcbn1cblxudmFyIGluZGV4ID0gUmVhY3QuY3JlYXRlQ29udGV4dCB8fCBjcmVhdGVSZWFjdENvbnRleHQ7XG5cbmV4cG9ydCBkZWZhdWx0IGluZGV4O1xuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2Uoc291cmNlLCBleGNsdWRlZCkge1xuICBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTtcbiAgdmFyIHRhcmdldCA9IHt9O1xuICB2YXIgc291cmNlS2V5cyA9IE9iamVjdC5rZXlzKHNvdXJjZSk7XG4gIHZhciBrZXksIGk7XG5cbiAgZm9yIChpID0gMDsgaSA8IHNvdXJjZUtleXMubGVuZ3RoOyBpKyspIHtcbiAgICBrZXkgPSBzb3VyY2VLZXlzW2ldO1xuICAgIGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7XG4gICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59IiwiaW1wb3J0IF9pbmhlcml0c0xvb3NlIGZyb20gJ0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2luaGVyaXRzTG9vc2UnO1xuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgeyBjcmVhdGVNZW1vcnlIaXN0b3J5LCBjcmVhdGVMb2NhdGlvbiwgbG9jYXRpb25zQXJlRXF1YWwsIGNyZWF0ZVBhdGggfSBmcm9tICdoaXN0b3J5JztcbmltcG9ydCB3YXJuaW5nIGZyb20gJ3Rpbnktd2FybmluZyc7XG5pbXBvcnQgY3JlYXRlQ29udGV4dCBmcm9tICdtaW5pLWNyZWF0ZS1yZWFjdC1jb250ZXh0JztcbmltcG9ydCBpbnZhcmlhbnQgZnJvbSAndGlueS1pbnZhcmlhbnQnO1xuaW1wb3J0IF9leHRlbmRzIGZyb20gJ0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2V4dGVuZHMnO1xuaW1wb3J0IHBhdGhUb1JlZ2V4cCBmcm9tICdwYXRoLXRvLXJlZ2V4cCc7XG5pbXBvcnQgeyBpc1ZhbGlkRWxlbWVudFR5cGUgfSBmcm9tICdyZWFjdC1pcyc7XG5pbXBvcnQgX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UgZnJvbSAnQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZSc7XG5pbXBvcnQgaG9pc3RTdGF0aWNzIGZyb20gJ2hvaXN0LW5vbi1yZWFjdC1zdGF0aWNzJztcblxuLy8gVE9ETzogUmVwbGFjZSB3aXRoIFJlYWN0LmNyZWF0ZUNvbnRleHQgb25jZSB3ZSBjYW4gYXNzdW1lIFJlYWN0IDE2K1xuXG52YXIgY3JlYXRlTmFtZWRDb250ZXh0ID0gZnVuY3Rpb24gY3JlYXRlTmFtZWRDb250ZXh0KG5hbWUpIHtcbiAgdmFyIGNvbnRleHQgPSBjcmVhdGVDb250ZXh0KCk7XG4gIGNvbnRleHQuZGlzcGxheU5hbWUgPSBuYW1lO1xuICByZXR1cm4gY29udGV4dDtcbn07XG5cbnZhciBoaXN0b3J5Q29udGV4dCA9IC8qI19fUFVSRV9fKi9jcmVhdGVOYW1lZENvbnRleHQoXCJSb3V0ZXItSGlzdG9yeVwiKTtcblxudmFyIGNvbnRleHQgPSAvKiNfX1BVUkVfXyovY3JlYXRlTmFtZWRDb250ZXh0KFwiUm91dGVyXCIpO1xuXG4vKipcbiAqIFRoZSBwdWJsaWMgQVBJIGZvciBwdXR0aW5nIGhpc3Rvcnkgb24gY29udGV4dC5cbiAqL1xuXG52YXIgUm91dGVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfUmVhY3QkQ29tcG9uZW50KSB7XG4gIF9pbmhlcml0c0xvb3NlKFJvdXRlciwgX1JlYWN0JENvbXBvbmVudCk7XG5cbiAgUm91dGVyLmNvbXB1dGVSb290TWF0Y2ggPSBmdW5jdGlvbiBjb21wdXRlUm9vdE1hdGNoKHBhdGhuYW1lKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHBhdGg6IFwiL1wiLFxuICAgICAgdXJsOiBcIi9cIixcbiAgICAgIHBhcmFtczoge30sXG4gICAgICBpc0V4YWN0OiBwYXRobmFtZSA9PT0gXCIvXCJcbiAgICB9O1xuICB9O1xuXG4gIGZ1bmN0aW9uIFJvdXRlcihwcm9wcykge1xuICAgIHZhciBfdGhpcztcblxuICAgIF90aGlzID0gX1JlYWN0JENvbXBvbmVudC5jYWxsKHRoaXMsIHByb3BzKSB8fCB0aGlzO1xuICAgIF90aGlzLnN0YXRlID0ge1xuICAgICAgbG9jYXRpb246IHByb3BzLmhpc3RvcnkubG9jYXRpb25cbiAgICB9OyAvLyBUaGlzIGlzIGEgYml0IG9mIGEgaGFjay4gV2UgaGF2ZSB0byBzdGFydCBsaXN0ZW5pbmcgZm9yIGxvY2F0aW9uXG4gICAgLy8gY2hhbmdlcyBoZXJlIGluIHRoZSBjb25zdHJ1Y3RvciBpbiBjYXNlIHRoZXJlIGFyZSBhbnkgPFJlZGlyZWN0PnNcbiAgICAvLyBvbiB0aGUgaW5pdGlhbCByZW5kZXIuIElmIHRoZXJlIGFyZSwgdGhleSB3aWxsIHJlcGxhY2UvcHVzaCB3aGVuXG4gICAgLy8gdGhleSBtb3VudCBhbmQgc2luY2UgY0RNIGZpcmVzIGluIGNoaWxkcmVuIGJlZm9yZSBwYXJlbnRzLCB3ZSBtYXlcbiAgICAvLyBnZXQgYSBuZXcgbG9jYXRpb24gYmVmb3JlIHRoZSA8Um91dGVyPiBpcyBtb3VudGVkLlxuXG4gICAgX3RoaXMuX2lzTW91bnRlZCA9IGZhbHNlO1xuICAgIF90aGlzLl9wZW5kaW5nTG9jYXRpb24gPSBudWxsO1xuXG4gICAgaWYgKCFwcm9wcy5zdGF0aWNDb250ZXh0KSB7XG4gICAgICBfdGhpcy51bmxpc3RlbiA9IHByb3BzLmhpc3RvcnkubGlzdGVuKGZ1bmN0aW9uIChsb2NhdGlvbikge1xuICAgICAgICBpZiAoX3RoaXMuX2lzTW91bnRlZCkge1xuICAgICAgICAgIF90aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgIGxvY2F0aW9uOiBsb2NhdGlvblxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIF90aGlzLl9wZW5kaW5nTG9jYXRpb24gPSBsb2NhdGlvbjtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IFJvdXRlci5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLmNvbXBvbmVudERpZE1vdW50ID0gZnVuY3Rpb24gY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgdGhpcy5faXNNb3VudGVkID0gdHJ1ZTtcblxuICAgIGlmICh0aGlzLl9wZW5kaW5nTG9jYXRpb24pIHtcbiAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICBsb2NhdGlvbjogdGhpcy5fcGVuZGluZ0xvY2F0aW9uXG4gICAgICB9KTtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLmNvbXBvbmVudFdpbGxVbm1vdW50ID0gZnVuY3Rpb24gY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgaWYgKHRoaXMudW5saXN0ZW4pIHtcbiAgICAgIHRoaXMudW5saXN0ZW4oKTtcbiAgICAgIHRoaXMuX2lzTW91bnRlZCA9IGZhbHNlO1xuICAgICAgdGhpcy5fcGVuZGluZ0xvY2F0aW9uID0gbnVsbDtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoY29udGV4dC5Qcm92aWRlciwge1xuICAgICAgdmFsdWU6IHtcbiAgICAgICAgaGlzdG9yeTogdGhpcy5wcm9wcy5oaXN0b3J5LFxuICAgICAgICBsb2NhdGlvbjogdGhpcy5zdGF0ZS5sb2NhdGlvbixcbiAgICAgICAgbWF0Y2g6IFJvdXRlci5jb21wdXRlUm9vdE1hdGNoKHRoaXMuc3RhdGUubG9jYXRpb24ucGF0aG5hbWUpLFxuICAgICAgICBzdGF0aWNDb250ZXh0OiB0aGlzLnByb3BzLnN0YXRpY0NvbnRleHRcbiAgICAgIH1cbiAgICB9LCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChoaXN0b3J5Q29udGV4dC5Qcm92aWRlciwge1xuICAgICAgY2hpbGRyZW46IHRoaXMucHJvcHMuY2hpbGRyZW4gfHwgbnVsbCxcbiAgICAgIHZhbHVlOiB0aGlzLnByb3BzLmhpc3RvcnlcbiAgICB9KSk7XG4gIH07XG5cbiAgcmV0dXJuIFJvdXRlcjtcbn0oUmVhY3QuQ29tcG9uZW50KTtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICBSb3V0ZXIucHJvcFR5cGVzID0ge1xuICAgIGNoaWxkcmVuOiBQcm9wVHlwZXMubm9kZSxcbiAgICBoaXN0b3J5OiBQcm9wVHlwZXMub2JqZWN0LmlzUmVxdWlyZWQsXG4gICAgc3RhdGljQ29udGV4dDogUHJvcFR5cGVzLm9iamVjdFxuICB9O1xuXG4gIFJvdXRlci5wcm90b3R5cGUuY29tcG9uZW50RGlkVXBkYXRlID0gZnVuY3Rpb24gKHByZXZQcm9wcykge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IHdhcm5pbmcocHJldlByb3BzLmhpc3RvcnkgPT09IHRoaXMucHJvcHMuaGlzdG9yeSwgXCJZb3UgY2Fubm90IGNoYW5nZSA8Um91dGVyIGhpc3Rvcnk+XCIpIDogdm9pZCAwO1xuICB9O1xufVxuXG4vKipcbiAqIFRoZSBwdWJsaWMgQVBJIGZvciBhIDxSb3V0ZXI+IHRoYXQgc3RvcmVzIGxvY2F0aW9uIGluIG1lbW9yeS5cbiAqL1xuXG52YXIgTWVtb3J5Um91dGVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfUmVhY3QkQ29tcG9uZW50KSB7XG4gIF9pbmhlcml0c0xvb3NlKE1lbW9yeVJvdXRlciwgX1JlYWN0JENvbXBvbmVudCk7XG5cbiAgZnVuY3Rpb24gTWVtb3J5Um91dGVyKCkge1xuICAgIHZhciBfdGhpcztcblxuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICBfdGhpcyA9IF9SZWFjdCRDb21wb25lbnQuY2FsbC5hcHBseShfUmVhY3QkQ29tcG9uZW50LCBbdGhpc10uY29uY2F0KGFyZ3MpKSB8fCB0aGlzO1xuICAgIF90aGlzLmhpc3RvcnkgPSBjcmVhdGVNZW1vcnlIaXN0b3J5KF90aGlzLnByb3BzKTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICB2YXIgX3Byb3RvID0gTWVtb3J5Um91dGVyLnByb3RvdHlwZTtcblxuICBfcHJvdG8ucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChSb3V0ZXIsIHtcbiAgICAgIGhpc3Rvcnk6IHRoaXMuaGlzdG9yeSxcbiAgICAgIGNoaWxkcmVuOiB0aGlzLnByb3BzLmNoaWxkcmVuXG4gICAgfSk7XG4gIH07XG5cbiAgcmV0dXJuIE1lbW9yeVJvdXRlcjtcbn0oUmVhY3QuQ29tcG9uZW50KTtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICBNZW1vcnlSb3V0ZXIucHJvcFR5cGVzID0ge1xuICAgIGluaXRpYWxFbnRyaWVzOiBQcm9wVHlwZXMuYXJyYXksXG4gICAgaW5pdGlhbEluZGV4OiBQcm9wVHlwZXMubnVtYmVyLFxuICAgIGdldFVzZXJDb25maXJtYXRpb246IFByb3BUeXBlcy5mdW5jLFxuICAgIGtleUxlbmd0aDogUHJvcFR5cGVzLm51bWJlcixcbiAgICBjaGlsZHJlbjogUHJvcFR5cGVzLm5vZGVcbiAgfTtcblxuICBNZW1vcnlSb3V0ZXIucHJvdG90eXBlLmNvbXBvbmVudERpZE1vdW50ID0gZnVuY3Rpb24gKCkge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IHdhcm5pbmcoIXRoaXMucHJvcHMuaGlzdG9yeSwgXCI8TWVtb3J5Um91dGVyPiBpZ25vcmVzIHRoZSBoaXN0b3J5IHByb3AuIFRvIHVzZSBhIGN1c3RvbSBoaXN0b3J5LCBcIiArIFwidXNlIGBpbXBvcnQgeyBSb3V0ZXIgfWAgaW5zdGVhZCBvZiBgaW1wb3J0IHsgTWVtb3J5Um91dGVyIGFzIFJvdXRlciB9YC5cIikgOiB2b2lkIDA7XG4gIH07XG59XG5cbnZhciBMaWZlY3ljbGUgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9SZWFjdCRDb21wb25lbnQpIHtcbiAgX2luaGVyaXRzTG9vc2UoTGlmZWN5Y2xlLCBfUmVhY3QkQ29tcG9uZW50KTtcblxuICBmdW5jdGlvbiBMaWZlY3ljbGUoKSB7XG4gICAgcmV0dXJuIF9SZWFjdCRDb21wb25lbnQuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IExpZmVjeWNsZS5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLmNvbXBvbmVudERpZE1vdW50ID0gZnVuY3Rpb24gY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgaWYgKHRoaXMucHJvcHMub25Nb3VudCkgdGhpcy5wcm9wcy5vbk1vdW50LmNhbGwodGhpcywgdGhpcyk7XG4gIH07XG5cbiAgX3Byb3RvLmNvbXBvbmVudERpZFVwZGF0ZSA9IGZ1bmN0aW9uIGNvbXBvbmVudERpZFVwZGF0ZShwcmV2UHJvcHMpIHtcbiAgICBpZiAodGhpcy5wcm9wcy5vblVwZGF0ZSkgdGhpcy5wcm9wcy5vblVwZGF0ZS5jYWxsKHRoaXMsIHRoaXMsIHByZXZQcm9wcyk7XG4gIH07XG5cbiAgX3Byb3RvLmNvbXBvbmVudFdpbGxVbm1vdW50ID0gZnVuY3Rpb24gY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgaWYgKHRoaXMucHJvcHMub25Vbm1vdW50KSB0aGlzLnByb3BzLm9uVW5tb3VudC5jYWxsKHRoaXMsIHRoaXMpO1xuICB9O1xuXG4gIF9wcm90by5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH07XG5cbiAgcmV0dXJuIExpZmVjeWNsZTtcbn0oUmVhY3QuQ29tcG9uZW50KTtcblxuLyoqXG4gKiBUaGUgcHVibGljIEFQSSBmb3IgcHJvbXB0aW5nIHRoZSB1c2VyIGJlZm9yZSBuYXZpZ2F0aW5nIGF3YXkgZnJvbSBhIHNjcmVlbi5cbiAqL1xuXG5mdW5jdGlvbiBQcm9tcHQoX3JlZikge1xuICB2YXIgbWVzc2FnZSA9IF9yZWYubWVzc2FnZSxcbiAgICAgIF9yZWYkd2hlbiA9IF9yZWYud2hlbixcbiAgICAgIHdoZW4gPSBfcmVmJHdoZW4gPT09IHZvaWQgMCA/IHRydWUgOiBfcmVmJHdoZW47XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChjb250ZXh0LkNvbnN1bWVyLCBudWxsLCBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgICFjb250ZXh0ID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCBcIllvdSBzaG91bGQgbm90IHVzZSA8UHJvbXB0PiBvdXRzaWRlIGEgPFJvdXRlcj5cIikgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICAgIGlmICghd2hlbiB8fCBjb250ZXh0LnN0YXRpY0NvbnRleHQpIHJldHVybiBudWxsO1xuICAgIHZhciBtZXRob2QgPSBjb250ZXh0Lmhpc3RvcnkuYmxvY2s7XG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KExpZmVjeWNsZSwge1xuICAgICAgb25Nb3VudDogZnVuY3Rpb24gb25Nb3VudChzZWxmKSB7XG4gICAgICAgIHNlbGYucmVsZWFzZSA9IG1ldGhvZChtZXNzYWdlKTtcbiAgICAgIH0sXG4gICAgICBvblVwZGF0ZTogZnVuY3Rpb24gb25VcGRhdGUoc2VsZiwgcHJldlByb3BzKSB7XG4gICAgICAgIGlmIChwcmV2UHJvcHMubWVzc2FnZSAhPT0gbWVzc2FnZSkge1xuICAgICAgICAgIHNlbGYucmVsZWFzZSgpO1xuICAgICAgICAgIHNlbGYucmVsZWFzZSA9IG1ldGhvZChtZXNzYWdlKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIG9uVW5tb3VudDogZnVuY3Rpb24gb25Vbm1vdW50KHNlbGYpIHtcbiAgICAgICAgc2VsZi5yZWxlYXNlKCk7XG4gICAgICB9LFxuICAgICAgbWVzc2FnZTogbWVzc2FnZVxuICAgIH0pO1xuICB9KTtcbn1cblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICB2YXIgbWVzc2FnZVR5cGUgPSBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMuZnVuYywgUHJvcFR5cGVzLnN0cmluZ10pO1xuICBQcm9tcHQucHJvcFR5cGVzID0ge1xuICAgIHdoZW46IFByb3BUeXBlcy5ib29sLFxuICAgIG1lc3NhZ2U6IG1lc3NhZ2VUeXBlLmlzUmVxdWlyZWRcbiAgfTtcbn1cblxudmFyIGNhY2hlID0ge307XG52YXIgY2FjaGVMaW1pdCA9IDEwMDAwO1xudmFyIGNhY2hlQ291bnQgPSAwO1xuXG5mdW5jdGlvbiBjb21waWxlUGF0aChwYXRoKSB7XG4gIGlmIChjYWNoZVtwYXRoXSkgcmV0dXJuIGNhY2hlW3BhdGhdO1xuICB2YXIgZ2VuZXJhdG9yID0gcGF0aFRvUmVnZXhwLmNvbXBpbGUocGF0aCk7XG5cbiAgaWYgKGNhY2hlQ291bnQgPCBjYWNoZUxpbWl0KSB7XG4gICAgY2FjaGVbcGF0aF0gPSBnZW5lcmF0b3I7XG4gICAgY2FjaGVDb3VudCsrO1xuICB9XG5cbiAgcmV0dXJuIGdlbmVyYXRvcjtcbn1cbi8qKlxuICogUHVibGljIEFQSSBmb3IgZ2VuZXJhdGluZyBhIFVSTCBwYXRobmFtZSBmcm9tIGEgcGF0aCBhbmQgcGFyYW1ldGVycy5cbiAqL1xuXG5cbmZ1bmN0aW9uIGdlbmVyYXRlUGF0aChwYXRoLCBwYXJhbXMpIHtcbiAgaWYgKHBhdGggPT09IHZvaWQgMCkge1xuICAgIHBhdGggPSBcIi9cIjtcbiAgfVxuXG4gIGlmIChwYXJhbXMgPT09IHZvaWQgMCkge1xuICAgIHBhcmFtcyA9IHt9O1xuICB9XG5cbiAgcmV0dXJuIHBhdGggPT09IFwiL1wiID8gcGF0aCA6IGNvbXBpbGVQYXRoKHBhdGgpKHBhcmFtcywge1xuICAgIHByZXR0eTogdHJ1ZVxuICB9KTtcbn1cblxuLyoqXG4gKiBUaGUgcHVibGljIEFQSSBmb3IgbmF2aWdhdGluZyBwcm9ncmFtbWF0aWNhbGx5IHdpdGggYSBjb21wb25lbnQuXG4gKi9cblxuZnVuY3Rpb24gUmVkaXJlY3QoX3JlZikge1xuICB2YXIgY29tcHV0ZWRNYXRjaCA9IF9yZWYuY29tcHV0ZWRNYXRjaCxcbiAgICAgIHRvID0gX3JlZi50byxcbiAgICAgIF9yZWYkcHVzaCA9IF9yZWYucHVzaCxcbiAgICAgIHB1c2ggPSBfcmVmJHB1c2ggPT09IHZvaWQgMCA/IGZhbHNlIDogX3JlZiRwdXNoO1xuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoY29udGV4dC5Db25zdW1lciwgbnVsbCwgZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICAhY29udGV4dCA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgXCJZb3Ugc2hvdWxkIG5vdCB1c2UgPFJlZGlyZWN0PiBvdXRzaWRlIGEgPFJvdXRlcj5cIikgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICAgIHZhciBoaXN0b3J5ID0gY29udGV4dC5oaXN0b3J5LFxuICAgICAgICBzdGF0aWNDb250ZXh0ID0gY29udGV4dC5zdGF0aWNDb250ZXh0O1xuICAgIHZhciBtZXRob2QgPSBwdXNoID8gaGlzdG9yeS5wdXNoIDogaGlzdG9yeS5yZXBsYWNlO1xuICAgIHZhciBsb2NhdGlvbiA9IGNyZWF0ZUxvY2F0aW9uKGNvbXB1dGVkTWF0Y2ggPyB0eXBlb2YgdG8gPT09IFwic3RyaW5nXCIgPyBnZW5lcmF0ZVBhdGgodG8sIGNvbXB1dGVkTWF0Y2gucGFyYW1zKSA6IF9leHRlbmRzKHt9LCB0bywge1xuICAgICAgcGF0aG5hbWU6IGdlbmVyYXRlUGF0aCh0by5wYXRobmFtZSwgY29tcHV0ZWRNYXRjaC5wYXJhbXMpXG4gICAgfSkgOiB0byk7IC8vIFdoZW4gcmVuZGVyaW5nIGluIGEgc3RhdGljIGNvbnRleHQsXG4gICAgLy8gc2V0IHRoZSBuZXcgbG9jYXRpb24gaW1tZWRpYXRlbHkuXG5cbiAgICBpZiAoc3RhdGljQ29udGV4dCkge1xuICAgICAgbWV0aG9kKGxvY2F0aW9uKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChMaWZlY3ljbGUsIHtcbiAgICAgIG9uTW91bnQ6IGZ1bmN0aW9uIG9uTW91bnQoKSB7XG4gICAgICAgIG1ldGhvZChsb2NhdGlvbik7XG4gICAgICB9LFxuICAgICAgb25VcGRhdGU6IGZ1bmN0aW9uIG9uVXBkYXRlKHNlbGYsIHByZXZQcm9wcykge1xuICAgICAgICB2YXIgcHJldkxvY2F0aW9uID0gY3JlYXRlTG9jYXRpb24ocHJldlByb3BzLnRvKTtcblxuICAgICAgICBpZiAoIWxvY2F0aW9uc0FyZUVxdWFsKHByZXZMb2NhdGlvbiwgX2V4dGVuZHMoe30sIGxvY2F0aW9uLCB7XG4gICAgICAgICAga2V5OiBwcmV2TG9jYXRpb24ua2V5XG4gICAgICAgIH0pKSkge1xuICAgICAgICAgIG1ldGhvZChsb2NhdGlvbik7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB0bzogdG9cbiAgICB9KTtcbiAgfSk7XG59XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgUmVkaXJlY3QucHJvcFR5cGVzID0ge1xuICAgIHB1c2g6IFByb3BUeXBlcy5ib29sLFxuICAgIGZyb206IFByb3BUeXBlcy5zdHJpbmcsXG4gICAgdG86IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5zdHJpbmcsIFByb3BUeXBlcy5vYmplY3RdKS5pc1JlcXVpcmVkXG4gIH07XG59XG5cbnZhciBjYWNoZSQxID0ge307XG52YXIgY2FjaGVMaW1pdCQxID0gMTAwMDA7XG52YXIgY2FjaGVDb3VudCQxID0gMDtcblxuZnVuY3Rpb24gY29tcGlsZVBhdGgkMShwYXRoLCBvcHRpb25zKSB7XG4gIHZhciBjYWNoZUtleSA9IFwiXCIgKyBvcHRpb25zLmVuZCArIG9wdGlvbnMuc3RyaWN0ICsgb3B0aW9ucy5zZW5zaXRpdmU7XG4gIHZhciBwYXRoQ2FjaGUgPSBjYWNoZSQxW2NhY2hlS2V5XSB8fCAoY2FjaGUkMVtjYWNoZUtleV0gPSB7fSk7XG4gIGlmIChwYXRoQ2FjaGVbcGF0aF0pIHJldHVybiBwYXRoQ2FjaGVbcGF0aF07XG4gIHZhciBrZXlzID0gW107XG4gIHZhciByZWdleHAgPSBwYXRoVG9SZWdleHAocGF0aCwga2V5cywgb3B0aW9ucyk7XG4gIHZhciByZXN1bHQgPSB7XG4gICAgcmVnZXhwOiByZWdleHAsXG4gICAga2V5czoga2V5c1xuICB9O1xuXG4gIGlmIChjYWNoZUNvdW50JDEgPCBjYWNoZUxpbWl0JDEpIHtcbiAgICBwYXRoQ2FjaGVbcGF0aF0gPSByZXN1bHQ7XG4gICAgY2FjaGVDb3VudCQxKys7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuLyoqXG4gKiBQdWJsaWMgQVBJIGZvciBtYXRjaGluZyBhIFVSTCBwYXRobmFtZSB0byBhIHBhdGguXG4gKi9cblxuXG5mdW5jdGlvbiBtYXRjaFBhdGgocGF0aG5hbWUsIG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuXG4gIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gXCJzdHJpbmdcIiB8fCBBcnJheS5pc0FycmF5KG9wdGlvbnMpKSB7XG4gICAgb3B0aW9ucyA9IHtcbiAgICAgIHBhdGg6IG9wdGlvbnNcbiAgICB9O1xuICB9XG5cbiAgdmFyIF9vcHRpb25zID0gb3B0aW9ucyxcbiAgICAgIHBhdGggPSBfb3B0aW9ucy5wYXRoLFxuICAgICAgX29wdGlvbnMkZXhhY3QgPSBfb3B0aW9ucy5leGFjdCxcbiAgICAgIGV4YWN0ID0gX29wdGlvbnMkZXhhY3QgPT09IHZvaWQgMCA/IGZhbHNlIDogX29wdGlvbnMkZXhhY3QsXG4gICAgICBfb3B0aW9ucyRzdHJpY3QgPSBfb3B0aW9ucy5zdHJpY3QsXG4gICAgICBzdHJpY3QgPSBfb3B0aW9ucyRzdHJpY3QgPT09IHZvaWQgMCA/IGZhbHNlIDogX29wdGlvbnMkc3RyaWN0LFxuICAgICAgX29wdGlvbnMkc2Vuc2l0aXZlID0gX29wdGlvbnMuc2Vuc2l0aXZlLFxuICAgICAgc2Vuc2l0aXZlID0gX29wdGlvbnMkc2Vuc2l0aXZlID09PSB2b2lkIDAgPyBmYWxzZSA6IF9vcHRpb25zJHNlbnNpdGl2ZTtcbiAgdmFyIHBhdGhzID0gW10uY29uY2F0KHBhdGgpO1xuICByZXR1cm4gcGF0aHMucmVkdWNlKGZ1bmN0aW9uIChtYXRjaGVkLCBwYXRoKSB7XG4gICAgaWYgKCFwYXRoICYmIHBhdGggIT09IFwiXCIpIHJldHVybiBudWxsO1xuICAgIGlmIChtYXRjaGVkKSByZXR1cm4gbWF0Y2hlZDtcblxuICAgIHZhciBfY29tcGlsZVBhdGggPSBjb21waWxlUGF0aCQxKHBhdGgsIHtcbiAgICAgIGVuZDogZXhhY3QsXG4gICAgICBzdHJpY3Q6IHN0cmljdCxcbiAgICAgIHNlbnNpdGl2ZTogc2Vuc2l0aXZlXG4gICAgfSksXG4gICAgICAgIHJlZ2V4cCA9IF9jb21waWxlUGF0aC5yZWdleHAsXG4gICAgICAgIGtleXMgPSBfY29tcGlsZVBhdGgua2V5cztcblxuICAgIHZhciBtYXRjaCA9IHJlZ2V4cC5leGVjKHBhdGhuYW1lKTtcbiAgICBpZiAoIW1hdGNoKSByZXR1cm4gbnVsbDtcbiAgICB2YXIgdXJsID0gbWF0Y2hbMF0sXG4gICAgICAgIHZhbHVlcyA9IG1hdGNoLnNsaWNlKDEpO1xuICAgIHZhciBpc0V4YWN0ID0gcGF0aG5hbWUgPT09IHVybDtcbiAgICBpZiAoZXhhY3QgJiYgIWlzRXhhY3QpIHJldHVybiBudWxsO1xuICAgIHJldHVybiB7XG4gICAgICBwYXRoOiBwYXRoLFxuICAgICAgLy8gdGhlIHBhdGggdXNlZCB0byBtYXRjaFxuICAgICAgdXJsOiBwYXRoID09PSBcIi9cIiAmJiB1cmwgPT09IFwiXCIgPyBcIi9cIiA6IHVybCxcbiAgICAgIC8vIHRoZSBtYXRjaGVkIHBvcnRpb24gb2YgdGhlIFVSTFxuICAgICAgaXNFeGFjdDogaXNFeGFjdCxcbiAgICAgIC8vIHdoZXRoZXIgb3Igbm90IHdlIG1hdGNoZWQgZXhhY3RseVxuICAgICAgcGFyYW1zOiBrZXlzLnJlZHVjZShmdW5jdGlvbiAobWVtbywga2V5LCBpbmRleCkge1xuICAgICAgICBtZW1vW2tleS5uYW1lXSA9IHZhbHVlc1tpbmRleF07XG4gICAgICAgIHJldHVybiBtZW1vO1xuICAgICAgfSwge30pXG4gICAgfTtcbiAgfSwgbnVsbCk7XG59XG5cbmZ1bmN0aW9uIGlzRW1wdHlDaGlsZHJlbihjaGlsZHJlbikge1xuICByZXR1cm4gUmVhY3QuQ2hpbGRyZW4uY291bnQoY2hpbGRyZW4pID09PSAwO1xufVxuXG5mdW5jdGlvbiBldmFsQ2hpbGRyZW5EZXYoY2hpbGRyZW4sIHByb3BzLCBwYXRoKSB7XG4gIHZhciB2YWx1ZSA9IGNoaWxkcmVuKHByb3BzKTtcbiAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gd2FybmluZyh2YWx1ZSAhPT0gdW5kZWZpbmVkLCBcIllvdSByZXR1cm5lZCBgdW5kZWZpbmVkYCBmcm9tIHRoZSBgY2hpbGRyZW5gIGZ1bmN0aW9uIG9mIFwiICsgKFwiPFJvdXRlXCIgKyAocGF0aCA/IFwiIHBhdGg9XFxcIlwiICsgcGF0aCArIFwiXFxcIlwiIDogXCJcIikgKyBcIj4sIGJ1dCB5b3UgXCIpICsgXCJzaG91bGQgaGF2ZSByZXR1cm5lZCBhIFJlYWN0IGVsZW1lbnQgb3IgYG51bGxgXCIpIDogdm9pZCAwO1xuICByZXR1cm4gdmFsdWUgfHwgbnVsbDtcbn1cbi8qKlxuICogVGhlIHB1YmxpYyBBUEkgZm9yIG1hdGNoaW5nIGEgc2luZ2xlIHBhdGggYW5kIHJlbmRlcmluZy5cbiAqL1xuXG5cbnZhciBSb3V0ZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX1JlYWN0JENvbXBvbmVudCkge1xuICBfaW5oZXJpdHNMb29zZShSb3V0ZSwgX1JlYWN0JENvbXBvbmVudCk7XG5cbiAgZnVuY3Rpb24gUm91dGUoKSB7XG4gICAgcmV0dXJuIF9SZWFjdCRDb21wb25lbnQuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IFJvdXRlLnByb3RvdHlwZTtcblxuICBfcHJvdG8ucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoY29udGV4dC5Db25zdW1lciwgbnVsbCwgZnVuY3Rpb24gKGNvbnRleHQkMSkge1xuICAgICAgIWNvbnRleHQkMSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgXCJZb3Ugc2hvdWxkIG5vdCB1c2UgPFJvdXRlPiBvdXRzaWRlIGEgPFJvdXRlcj5cIikgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICAgICAgdmFyIGxvY2F0aW9uID0gX3RoaXMucHJvcHMubG9jYXRpb24gfHwgY29udGV4dCQxLmxvY2F0aW9uO1xuICAgICAgdmFyIG1hdGNoID0gX3RoaXMucHJvcHMuY29tcHV0ZWRNYXRjaCA/IF90aGlzLnByb3BzLmNvbXB1dGVkTWF0Y2ggLy8gPFN3aXRjaD4gYWxyZWFkeSBjb21wdXRlZCB0aGUgbWF0Y2ggZm9yIHVzXG4gICAgICA6IF90aGlzLnByb3BzLnBhdGggPyBtYXRjaFBhdGgobG9jYXRpb24ucGF0aG5hbWUsIF90aGlzLnByb3BzKSA6IGNvbnRleHQkMS5tYXRjaDtcblxuICAgICAgdmFyIHByb3BzID0gX2V4dGVuZHMoe30sIGNvbnRleHQkMSwge1xuICAgICAgICBsb2NhdGlvbjogbG9jYXRpb24sXG4gICAgICAgIG1hdGNoOiBtYXRjaFxuICAgICAgfSk7XG5cbiAgICAgIHZhciBfdGhpcyRwcm9wcyA9IF90aGlzLnByb3BzLFxuICAgICAgICAgIGNoaWxkcmVuID0gX3RoaXMkcHJvcHMuY2hpbGRyZW4sXG4gICAgICAgICAgY29tcG9uZW50ID0gX3RoaXMkcHJvcHMuY29tcG9uZW50LFxuICAgICAgICAgIHJlbmRlciA9IF90aGlzJHByb3BzLnJlbmRlcjsgLy8gUHJlYWN0IHVzZXMgYW4gZW1wdHkgYXJyYXkgYXMgY2hpbGRyZW4gYnlcbiAgICAgIC8vIGRlZmF1bHQsIHNvIHVzZSBudWxsIGlmIHRoYXQncyB0aGUgY2FzZS5cblxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pICYmIGlzRW1wdHlDaGlsZHJlbihjaGlsZHJlbikpIHtcbiAgICAgICAgY2hpbGRyZW4gPSBudWxsO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoY29udGV4dC5Qcm92aWRlciwge1xuICAgICAgICB2YWx1ZTogcHJvcHNcbiAgICAgIH0sIHByb3BzLm1hdGNoID8gY2hpbGRyZW4gPyB0eXBlb2YgY2hpbGRyZW4gPT09IFwiZnVuY3Rpb25cIiA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGV2YWxDaGlsZHJlbkRldihjaGlsZHJlbiwgcHJvcHMsIF90aGlzLnByb3BzLnBhdGgpIDogY2hpbGRyZW4ocHJvcHMpIDogY2hpbGRyZW4gOiBjb21wb25lbnQgPyAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChjb21wb25lbnQsIHByb3BzKSA6IHJlbmRlciA/IHJlbmRlcihwcm9wcykgOiBudWxsIDogdHlwZW9mIGNoaWxkcmVuID09PSBcImZ1bmN0aW9uXCIgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBldmFsQ2hpbGRyZW5EZXYoY2hpbGRyZW4sIHByb3BzLCBfdGhpcy5wcm9wcy5wYXRoKSA6IGNoaWxkcmVuKHByb3BzKSA6IG51bGwpO1xuICAgIH0pO1xuICB9O1xuXG4gIHJldHVybiBSb3V0ZTtcbn0oUmVhY3QuQ29tcG9uZW50KTtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICBSb3V0ZS5wcm9wVHlwZXMgPSB7XG4gICAgY2hpbGRyZW46IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5mdW5jLCBQcm9wVHlwZXMubm9kZV0pLFxuICAgIGNvbXBvbmVudDogZnVuY3Rpb24gY29tcG9uZW50KHByb3BzLCBwcm9wTmFtZSkge1xuICAgICAgaWYgKHByb3BzW3Byb3BOYW1lXSAmJiAhaXNWYWxpZEVsZW1lbnRUeXBlKHByb3BzW3Byb3BOYW1lXSkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBFcnJvcihcIkludmFsaWQgcHJvcCAnY29tcG9uZW50JyBzdXBwbGllZCB0byAnUm91dGUnOiB0aGUgcHJvcCBpcyBub3QgYSB2YWxpZCBSZWFjdCBjb21wb25lbnRcIik7XG4gICAgICB9XG4gICAgfSxcbiAgICBleGFjdDogUHJvcFR5cGVzLmJvb2wsXG4gICAgbG9jYXRpb246IFByb3BUeXBlcy5vYmplY3QsXG4gICAgcGF0aDogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLnN0cmluZywgUHJvcFR5cGVzLmFycmF5T2YoUHJvcFR5cGVzLnN0cmluZyldKSxcbiAgICByZW5kZXI6IFByb3BUeXBlcy5mdW5jLFxuICAgIHNlbnNpdGl2ZTogUHJvcFR5cGVzLmJvb2wsXG4gICAgc3RyaWN0OiBQcm9wVHlwZXMuYm9vbFxuICB9O1xuXG4gIFJvdXRlLnByb3RvdHlwZS5jb21wb25lbnREaWRNb3VudCA9IGZ1bmN0aW9uICgpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyB3YXJuaW5nKCEodGhpcy5wcm9wcy5jaGlsZHJlbiAmJiAhaXNFbXB0eUNoaWxkcmVuKHRoaXMucHJvcHMuY2hpbGRyZW4pICYmIHRoaXMucHJvcHMuY29tcG9uZW50KSwgXCJZb3Ugc2hvdWxkIG5vdCB1c2UgPFJvdXRlIGNvbXBvbmVudD4gYW5kIDxSb3V0ZSBjaGlsZHJlbj4gaW4gdGhlIHNhbWUgcm91dGU7IDxSb3V0ZSBjb21wb25lbnQ+IHdpbGwgYmUgaWdub3JlZFwiKSA6IHZvaWQgMDtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyB3YXJuaW5nKCEodGhpcy5wcm9wcy5jaGlsZHJlbiAmJiAhaXNFbXB0eUNoaWxkcmVuKHRoaXMucHJvcHMuY2hpbGRyZW4pICYmIHRoaXMucHJvcHMucmVuZGVyKSwgXCJZb3Ugc2hvdWxkIG5vdCB1c2UgPFJvdXRlIHJlbmRlcj4gYW5kIDxSb3V0ZSBjaGlsZHJlbj4gaW4gdGhlIHNhbWUgcm91dGU7IDxSb3V0ZSByZW5kZXI+IHdpbGwgYmUgaWdub3JlZFwiKSA6IHZvaWQgMDtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyB3YXJuaW5nKCEodGhpcy5wcm9wcy5jb21wb25lbnQgJiYgdGhpcy5wcm9wcy5yZW5kZXIpLCBcIllvdSBzaG91bGQgbm90IHVzZSA8Um91dGUgY29tcG9uZW50PiBhbmQgPFJvdXRlIHJlbmRlcj4gaW4gdGhlIHNhbWUgcm91dGU7IDxSb3V0ZSByZW5kZXI+IHdpbGwgYmUgaWdub3JlZFwiKSA6IHZvaWQgMDtcbiAgfTtcblxuICBSb3V0ZS5wcm90b3R5cGUuY29tcG9uZW50RGlkVXBkYXRlID0gZnVuY3Rpb24gKHByZXZQcm9wcykge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IHdhcm5pbmcoISh0aGlzLnByb3BzLmxvY2F0aW9uICYmICFwcmV2UHJvcHMubG9jYXRpb24pLCAnPFJvdXRlPiBlbGVtZW50cyBzaG91bGQgbm90IGNoYW5nZSBmcm9tIHVuY29udHJvbGxlZCB0byBjb250cm9sbGVkIChvciB2aWNlIHZlcnNhKS4gWW91IGluaXRpYWxseSB1c2VkIG5vIFwibG9jYXRpb25cIiBwcm9wIGFuZCB0aGVuIHByb3ZpZGVkIG9uZSBvbiBhIHN1YnNlcXVlbnQgcmVuZGVyLicpIDogdm9pZCAwO1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IHdhcm5pbmcoISghdGhpcy5wcm9wcy5sb2NhdGlvbiAmJiBwcmV2UHJvcHMubG9jYXRpb24pLCAnPFJvdXRlPiBlbGVtZW50cyBzaG91bGQgbm90IGNoYW5nZSBmcm9tIGNvbnRyb2xsZWQgdG8gdW5jb250cm9sbGVkIChvciB2aWNlIHZlcnNhKS4gWW91IHByb3ZpZGVkIGEgXCJsb2NhdGlvblwiIHByb3AgaW5pdGlhbGx5IGJ1dCBvbWl0dGVkIGl0IG9uIGEgc3Vic2VxdWVudCByZW5kZXIuJykgOiB2b2lkIDA7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGFkZExlYWRpbmdTbGFzaChwYXRoKSB7XG4gIHJldHVybiBwYXRoLmNoYXJBdCgwKSA9PT0gXCIvXCIgPyBwYXRoIDogXCIvXCIgKyBwYXRoO1xufVxuXG5mdW5jdGlvbiBhZGRCYXNlbmFtZShiYXNlbmFtZSwgbG9jYXRpb24pIHtcbiAgaWYgKCFiYXNlbmFtZSkgcmV0dXJuIGxvY2F0aW9uO1xuICByZXR1cm4gX2V4dGVuZHMoe30sIGxvY2F0aW9uLCB7XG4gICAgcGF0aG5hbWU6IGFkZExlYWRpbmdTbGFzaChiYXNlbmFtZSkgKyBsb2NhdGlvbi5wYXRobmFtZVxuICB9KTtcbn1cblxuZnVuY3Rpb24gc3RyaXBCYXNlbmFtZShiYXNlbmFtZSwgbG9jYXRpb24pIHtcbiAgaWYgKCFiYXNlbmFtZSkgcmV0dXJuIGxvY2F0aW9uO1xuICB2YXIgYmFzZSA9IGFkZExlYWRpbmdTbGFzaChiYXNlbmFtZSk7XG4gIGlmIChsb2NhdGlvbi5wYXRobmFtZS5pbmRleE9mKGJhc2UpICE9PSAwKSByZXR1cm4gbG9jYXRpb247XG4gIHJldHVybiBfZXh0ZW5kcyh7fSwgbG9jYXRpb24sIHtcbiAgICBwYXRobmFtZTogbG9jYXRpb24ucGF0aG5hbWUuc3Vic3RyKGJhc2UubGVuZ3RoKVxuICB9KTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlVVJMKGxvY2F0aW9uKSB7XG4gIHJldHVybiB0eXBlb2YgbG9jYXRpb24gPT09IFwic3RyaW5nXCIgPyBsb2NhdGlvbiA6IGNyZWF0ZVBhdGgobG9jYXRpb24pO1xufVxuXG5mdW5jdGlvbiBzdGF0aWNIYW5kbGVyKG1ldGhvZE5hbWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCBcIllvdSBjYW5ub3QgJXMgd2l0aCA8U3RhdGljUm91dGVyPlwiLCBtZXRob2ROYW1lKSA6IGludmFyaWFudChmYWxzZSkgO1xuICB9O1xufVxuXG5mdW5jdGlvbiBub29wKCkge31cbi8qKlxuICogVGhlIHB1YmxpYyB0b3AtbGV2ZWwgQVBJIGZvciBhIFwic3RhdGljXCIgPFJvdXRlcj4sIHNvLWNhbGxlZCBiZWNhdXNlIGl0XG4gKiBjYW4ndCBhY3R1YWxseSBjaGFuZ2UgdGhlIGN1cnJlbnQgbG9jYXRpb24uIEluc3RlYWQsIGl0IGp1c3QgcmVjb3Jkc1xuICogbG9jYXRpb24gY2hhbmdlcyBpbiBhIGNvbnRleHQgb2JqZWN0LiBVc2VmdWwgbWFpbmx5IGluIHRlc3RpbmcgYW5kXG4gKiBzZXJ2ZXItcmVuZGVyaW5nIHNjZW5hcmlvcy5cbiAqL1xuXG5cbnZhciBTdGF0aWNSb3V0ZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9SZWFjdCRDb21wb25lbnQpIHtcbiAgX2luaGVyaXRzTG9vc2UoU3RhdGljUm91dGVyLCBfUmVhY3QkQ29tcG9uZW50KTtcblxuICBmdW5jdGlvbiBTdGF0aWNSb3V0ZXIoKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIF90aGlzID0gX1JlYWN0JENvbXBvbmVudC5jYWxsLmFwcGx5KF9SZWFjdCRDb21wb25lbnQsIFt0aGlzXS5jb25jYXQoYXJncykpIHx8IHRoaXM7XG5cbiAgICBfdGhpcy5oYW5kbGVQdXNoID0gZnVuY3Rpb24gKGxvY2F0aW9uKSB7XG4gICAgICByZXR1cm4gX3RoaXMubmF2aWdhdGVUbyhsb2NhdGlvbiwgXCJQVVNIXCIpO1xuICAgIH07XG5cbiAgICBfdGhpcy5oYW5kbGVSZXBsYWNlID0gZnVuY3Rpb24gKGxvY2F0aW9uKSB7XG4gICAgICByZXR1cm4gX3RoaXMubmF2aWdhdGVUbyhsb2NhdGlvbiwgXCJSRVBMQUNFXCIpO1xuICAgIH07XG5cbiAgICBfdGhpcy5oYW5kbGVMaXN0ZW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gbm9vcDtcbiAgICB9O1xuXG4gICAgX3RoaXMuaGFuZGxlQmxvY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gbm9vcDtcbiAgICB9O1xuXG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IFN0YXRpY1JvdXRlci5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLm5hdmlnYXRlVG8gPSBmdW5jdGlvbiBuYXZpZ2F0ZVRvKGxvY2F0aW9uLCBhY3Rpb24pIHtcbiAgICB2YXIgX3RoaXMkcHJvcHMgPSB0aGlzLnByb3BzLFxuICAgICAgICBfdGhpcyRwcm9wcyRiYXNlbmFtZSA9IF90aGlzJHByb3BzLmJhc2VuYW1lLFxuICAgICAgICBiYXNlbmFtZSA9IF90aGlzJHByb3BzJGJhc2VuYW1lID09PSB2b2lkIDAgPyBcIlwiIDogX3RoaXMkcHJvcHMkYmFzZW5hbWUsXG4gICAgICAgIF90aGlzJHByb3BzJGNvbnRleHQgPSBfdGhpcyRwcm9wcy5jb250ZXh0LFxuICAgICAgICBjb250ZXh0ID0gX3RoaXMkcHJvcHMkY29udGV4dCA9PT0gdm9pZCAwID8ge30gOiBfdGhpcyRwcm9wcyRjb250ZXh0O1xuICAgIGNvbnRleHQuYWN0aW9uID0gYWN0aW9uO1xuICAgIGNvbnRleHQubG9jYXRpb24gPSBhZGRCYXNlbmFtZShiYXNlbmFtZSwgY3JlYXRlTG9jYXRpb24obG9jYXRpb24pKTtcbiAgICBjb250ZXh0LnVybCA9IGNyZWF0ZVVSTChjb250ZXh0LmxvY2F0aW9uKTtcbiAgfTtcblxuICBfcHJvdG8ucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgIHZhciBfdGhpcyRwcm9wczIgPSB0aGlzLnByb3BzLFxuICAgICAgICBfdGhpcyRwcm9wczIkYmFzZW5hbWUgPSBfdGhpcyRwcm9wczIuYmFzZW5hbWUsXG4gICAgICAgIGJhc2VuYW1lID0gX3RoaXMkcHJvcHMyJGJhc2VuYW1lID09PSB2b2lkIDAgPyBcIlwiIDogX3RoaXMkcHJvcHMyJGJhc2VuYW1lLFxuICAgICAgICBfdGhpcyRwcm9wczIkY29udGV4dCA9IF90aGlzJHByb3BzMi5jb250ZXh0LFxuICAgICAgICBjb250ZXh0ID0gX3RoaXMkcHJvcHMyJGNvbnRleHQgPT09IHZvaWQgMCA/IHt9IDogX3RoaXMkcHJvcHMyJGNvbnRleHQsXG4gICAgICAgIF90aGlzJHByb3BzMiRsb2NhdGlvbiA9IF90aGlzJHByb3BzMi5sb2NhdGlvbixcbiAgICAgICAgbG9jYXRpb24gPSBfdGhpcyRwcm9wczIkbG9jYXRpb24gPT09IHZvaWQgMCA/IFwiL1wiIDogX3RoaXMkcHJvcHMyJGxvY2F0aW9uLFxuICAgICAgICByZXN0ID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UoX3RoaXMkcHJvcHMyLCBbXCJiYXNlbmFtZVwiLCBcImNvbnRleHRcIiwgXCJsb2NhdGlvblwiXSk7XG5cbiAgICB2YXIgaGlzdG9yeSA9IHtcbiAgICAgIGNyZWF0ZUhyZWY6IGZ1bmN0aW9uIGNyZWF0ZUhyZWYocGF0aCkge1xuICAgICAgICByZXR1cm4gYWRkTGVhZGluZ1NsYXNoKGJhc2VuYW1lICsgY3JlYXRlVVJMKHBhdGgpKTtcbiAgICAgIH0sXG4gICAgICBhY3Rpb246IFwiUE9QXCIsXG4gICAgICBsb2NhdGlvbjogc3RyaXBCYXNlbmFtZShiYXNlbmFtZSwgY3JlYXRlTG9jYXRpb24obG9jYXRpb24pKSxcbiAgICAgIHB1c2g6IHRoaXMuaGFuZGxlUHVzaCxcbiAgICAgIHJlcGxhY2U6IHRoaXMuaGFuZGxlUmVwbGFjZSxcbiAgICAgIGdvOiBzdGF0aWNIYW5kbGVyKFwiZ29cIiksXG4gICAgICBnb0JhY2s6IHN0YXRpY0hhbmRsZXIoXCJnb0JhY2tcIiksXG4gICAgICBnb0ZvcndhcmQ6IHN0YXRpY0hhbmRsZXIoXCJnb0ZvcndhcmRcIiksXG4gICAgICBsaXN0ZW46IHRoaXMuaGFuZGxlTGlzdGVuLFxuICAgICAgYmxvY2s6IHRoaXMuaGFuZGxlQmxvY2tcbiAgICB9O1xuICAgIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChSb3V0ZXIsIF9leHRlbmRzKHt9LCByZXN0LCB7XG4gICAgICBoaXN0b3J5OiBoaXN0b3J5LFxuICAgICAgc3RhdGljQ29udGV4dDogY29udGV4dFxuICAgIH0pKTtcbiAgfTtcblxuICByZXR1cm4gU3RhdGljUm91dGVyO1xufShSZWFjdC5Db21wb25lbnQpO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gIFN0YXRpY1JvdXRlci5wcm9wVHlwZXMgPSB7XG4gICAgYmFzZW5hbWU6IFByb3BUeXBlcy5zdHJpbmcsXG4gICAgY29udGV4dDogUHJvcFR5cGVzLm9iamVjdCxcbiAgICBsb2NhdGlvbjogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLnN0cmluZywgUHJvcFR5cGVzLm9iamVjdF0pXG4gIH07XG5cbiAgU3RhdGljUm91dGVyLnByb3RvdHlwZS5jb21wb25lbnREaWRNb3VudCA9IGZ1bmN0aW9uICgpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyB3YXJuaW5nKCF0aGlzLnByb3BzLmhpc3RvcnksIFwiPFN0YXRpY1JvdXRlcj4gaWdub3JlcyB0aGUgaGlzdG9yeSBwcm9wLiBUbyB1c2UgYSBjdXN0b20gaGlzdG9yeSwgXCIgKyBcInVzZSBgaW1wb3J0IHsgUm91dGVyIH1gIGluc3RlYWQgb2YgYGltcG9ydCB7IFN0YXRpY1JvdXRlciBhcyBSb3V0ZXIgfWAuXCIpIDogdm9pZCAwO1xuICB9O1xufVxuXG4vKipcbiAqIFRoZSBwdWJsaWMgQVBJIGZvciByZW5kZXJpbmcgdGhlIGZpcnN0IDxSb3V0ZT4gdGhhdCBtYXRjaGVzLlxuICovXG5cbnZhciBTd2l0Y2ggPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9SZWFjdCRDb21wb25lbnQpIHtcbiAgX2luaGVyaXRzTG9vc2UoU3dpdGNoLCBfUmVhY3QkQ29tcG9uZW50KTtcblxuICBmdW5jdGlvbiBTd2l0Y2goKSB7XG4gICAgcmV0dXJuIF9SZWFjdCRDb21wb25lbnQuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IFN3aXRjaC5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KGNvbnRleHQuQ29uc3VtZXIsIG51bGwsIGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgICAhY29udGV4dCA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgXCJZb3Ugc2hvdWxkIG5vdCB1c2UgPFN3aXRjaD4gb3V0c2lkZSBhIDxSb3V0ZXI+XCIpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgICAgIHZhciBsb2NhdGlvbiA9IF90aGlzLnByb3BzLmxvY2F0aW9uIHx8IGNvbnRleHQubG9jYXRpb247XG4gICAgICB2YXIgZWxlbWVudCwgbWF0Y2g7IC8vIFdlIHVzZSBSZWFjdC5DaGlsZHJlbi5mb3JFYWNoIGluc3RlYWQgb2YgUmVhY3QuQ2hpbGRyZW4udG9BcnJheSgpLmZpbmQoKVxuICAgICAgLy8gaGVyZSBiZWNhdXNlIHRvQXJyYXkgYWRkcyBrZXlzIHRvIGFsbCBjaGlsZCBlbGVtZW50cyBhbmQgd2UgZG8gbm90IHdhbnRcbiAgICAgIC8vIHRvIHRyaWdnZXIgYW4gdW5tb3VudC9yZW1vdW50IGZvciB0d28gPFJvdXRlPnMgdGhhdCByZW5kZXIgdGhlIHNhbWVcbiAgICAgIC8vIGNvbXBvbmVudCBhdCBkaWZmZXJlbnQgVVJMcy5cblxuICAgICAgUmVhY3QuQ2hpbGRyZW4uZm9yRWFjaChfdGhpcy5wcm9wcy5jaGlsZHJlbiwgZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgIGlmIChtYXRjaCA9PSBudWxsICYmIC8qI19fUFVSRV9fKi9SZWFjdC5pc1ZhbGlkRWxlbWVudChjaGlsZCkpIHtcbiAgICAgICAgICBlbGVtZW50ID0gY2hpbGQ7XG4gICAgICAgICAgdmFyIHBhdGggPSBjaGlsZC5wcm9wcy5wYXRoIHx8IGNoaWxkLnByb3BzLmZyb207XG4gICAgICAgICAgbWF0Y2ggPSBwYXRoID8gbWF0Y2hQYXRoKGxvY2F0aW9uLnBhdGhuYW1lLCBfZXh0ZW5kcyh7fSwgY2hpbGQucHJvcHMsIHtcbiAgICAgICAgICAgIHBhdGg6IHBhdGhcbiAgICAgICAgICB9KSkgOiBjb250ZXh0Lm1hdGNoO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBtYXRjaCA/IC8qI19fUFVSRV9fKi9SZWFjdC5jbG9uZUVsZW1lbnQoZWxlbWVudCwge1xuICAgICAgICBsb2NhdGlvbjogbG9jYXRpb24sXG4gICAgICAgIGNvbXB1dGVkTWF0Y2g6IG1hdGNoXG4gICAgICB9KSA6IG51bGw7XG4gICAgfSk7XG4gIH07XG5cbiAgcmV0dXJuIFN3aXRjaDtcbn0oUmVhY3QuQ29tcG9uZW50KTtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICBTd2l0Y2gucHJvcFR5cGVzID0ge1xuICAgIGNoaWxkcmVuOiBQcm9wVHlwZXMubm9kZSxcbiAgICBsb2NhdGlvbjogUHJvcFR5cGVzLm9iamVjdFxuICB9O1xuXG4gIFN3aXRjaC5wcm90b3R5cGUuY29tcG9uZW50RGlkVXBkYXRlID0gZnVuY3Rpb24gKHByZXZQcm9wcykge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IHdhcm5pbmcoISh0aGlzLnByb3BzLmxvY2F0aW9uICYmICFwcmV2UHJvcHMubG9jYXRpb24pLCAnPFN3aXRjaD4gZWxlbWVudHMgc2hvdWxkIG5vdCBjaGFuZ2UgZnJvbSB1bmNvbnRyb2xsZWQgdG8gY29udHJvbGxlZCAob3IgdmljZSB2ZXJzYSkuIFlvdSBpbml0aWFsbHkgdXNlZCBubyBcImxvY2F0aW9uXCIgcHJvcCBhbmQgdGhlbiBwcm92aWRlZCBvbmUgb24gYSBzdWJzZXF1ZW50IHJlbmRlci4nKSA6IHZvaWQgMDtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyB3YXJuaW5nKCEoIXRoaXMucHJvcHMubG9jYXRpb24gJiYgcHJldlByb3BzLmxvY2F0aW9uKSwgJzxTd2l0Y2g+IGVsZW1lbnRzIHNob3VsZCBub3QgY2hhbmdlIGZyb20gY29udHJvbGxlZCB0byB1bmNvbnRyb2xsZWQgKG9yIHZpY2UgdmVyc2EpLiBZb3UgcHJvdmlkZWQgYSBcImxvY2F0aW9uXCIgcHJvcCBpbml0aWFsbHkgYnV0IG9taXR0ZWQgaXQgb24gYSBzdWJzZXF1ZW50IHJlbmRlci4nKSA6IHZvaWQgMDtcbiAgfTtcbn1cblxuLyoqXG4gKiBBIHB1YmxpYyBoaWdoZXItb3JkZXIgY29tcG9uZW50IHRvIGFjY2VzcyB0aGUgaW1wZXJhdGl2ZSBBUElcbiAqL1xuXG5mdW5jdGlvbiB3aXRoUm91dGVyKENvbXBvbmVudCkge1xuICB2YXIgZGlzcGxheU5hbWUgPSBcIndpdGhSb3V0ZXIoXCIgKyAoQ29tcG9uZW50LmRpc3BsYXlOYW1lIHx8IENvbXBvbmVudC5uYW1lKSArIFwiKVwiO1xuXG4gIHZhciBDID0gZnVuY3Rpb24gQyhwcm9wcykge1xuICAgIHZhciB3cmFwcGVkQ29tcG9uZW50UmVmID0gcHJvcHMud3JhcHBlZENvbXBvbmVudFJlZixcbiAgICAgICAgcmVtYWluaW5nUHJvcHMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShwcm9wcywgW1wid3JhcHBlZENvbXBvbmVudFJlZlwiXSk7XG5cbiAgICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoY29udGV4dC5Db25zdW1lciwgbnVsbCwgZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICAgICFjb250ZXh0ID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCBcIllvdSBzaG91bGQgbm90IHVzZSA8XCIgKyBkaXNwbGF5TmFtZSArIFwiIC8+IG91dHNpZGUgYSA8Um91dGVyPlwiKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gICAgICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoQ29tcG9uZW50LCBfZXh0ZW5kcyh7fSwgcmVtYWluaW5nUHJvcHMsIGNvbnRleHQsIHtcbiAgICAgICAgcmVmOiB3cmFwcGVkQ29tcG9uZW50UmVmXG4gICAgICB9KSk7XG4gICAgfSk7XG4gIH07XG5cbiAgQy5kaXNwbGF5TmFtZSA9IGRpc3BsYXlOYW1lO1xuICBDLldyYXBwZWRDb21wb25lbnQgPSBDb21wb25lbnQ7XG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgIEMucHJvcFR5cGVzID0ge1xuICAgICAgd3JhcHBlZENvbXBvbmVudFJlZjogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLnN0cmluZywgUHJvcFR5cGVzLmZ1bmMsIFByb3BUeXBlcy5vYmplY3RdKVxuICAgIH07XG4gIH1cblxuICByZXR1cm4gaG9pc3RTdGF0aWNzKEMsIENvbXBvbmVudCk7XG59XG5cbnZhciB1c2VDb250ZXh0ID0gUmVhY3QudXNlQ29udGV4dDtcbmZ1bmN0aW9uIHVzZUhpc3RvcnkoKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAhKHR5cGVvZiB1c2VDb250ZXh0ID09PSBcImZ1bmN0aW9uXCIpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCBcIllvdSBtdXN0IHVzZSBSZWFjdCA+PSAxNi44IGluIG9yZGVyIHRvIHVzZSB1c2VIaXN0b3J5KClcIikgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICB9XG5cbiAgcmV0dXJuIHVzZUNvbnRleHQoaGlzdG9yeUNvbnRleHQpO1xufVxuZnVuY3Rpb24gdXNlTG9jYXRpb24oKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAhKHR5cGVvZiB1c2VDb250ZXh0ID09PSBcImZ1bmN0aW9uXCIpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCBcIllvdSBtdXN0IHVzZSBSZWFjdCA+PSAxNi44IGluIG9yZGVyIHRvIHVzZSB1c2VMb2NhdGlvbigpXCIpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgfVxuXG4gIHJldHVybiB1c2VDb250ZXh0KGNvbnRleHQpLmxvY2F0aW9uO1xufVxuZnVuY3Rpb24gdXNlUGFyYW1zKCkge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgISh0eXBlb2YgdXNlQ29udGV4dCA9PT0gXCJmdW5jdGlvblwiKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgXCJZb3UgbXVzdCB1c2UgUmVhY3QgPj0gMTYuOCBpbiBvcmRlciB0byB1c2UgdXNlUGFyYW1zKClcIikgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICB9XG5cbiAgdmFyIG1hdGNoID0gdXNlQ29udGV4dChjb250ZXh0KS5tYXRjaDtcbiAgcmV0dXJuIG1hdGNoID8gbWF0Y2gucGFyYW1zIDoge307XG59XG5mdW5jdGlvbiB1c2VSb3V0ZU1hdGNoKHBhdGgpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICEodHlwZW9mIHVzZUNvbnRleHQgPT09IFwiZnVuY3Rpb25cIikgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsIFwiWW91IG11c3QgdXNlIFJlYWN0ID49IDE2LjggaW4gb3JkZXIgdG8gdXNlIHVzZVJvdXRlTWF0Y2goKVwiKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gIH1cblxuICB2YXIgbG9jYXRpb24gPSB1c2VMb2NhdGlvbigpO1xuICB2YXIgbWF0Y2ggPSB1c2VDb250ZXh0KGNvbnRleHQpLm1hdGNoO1xuICByZXR1cm4gcGF0aCA/IG1hdGNoUGF0aChsb2NhdGlvbi5wYXRobmFtZSwgcGF0aCkgOiBtYXRjaDtcbn1cblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHZhciBnbG9iYWwgPSB3aW5kb3c7XG4gICAgdmFyIGtleSA9IFwiX19yZWFjdF9yb3V0ZXJfYnVpbGRfX1wiO1xuICAgIHZhciBidWlsZE5hbWVzID0ge1xuICAgICAgY2pzOiBcIkNvbW1vbkpTXCIsXG4gICAgICBlc206IFwiRVMgbW9kdWxlc1wiLFxuICAgICAgdW1kOiBcIlVNRFwiXG4gICAgfTtcblxuICAgIGlmIChnbG9iYWxba2V5XSAmJiBnbG9iYWxba2V5XSAhPT0gXCJlc21cIikge1xuICAgICAgdmFyIGluaXRpYWxCdWlsZE5hbWUgPSBidWlsZE5hbWVzW2dsb2JhbFtrZXldXTtcbiAgICAgIHZhciBzZWNvbmRhcnlCdWlsZE5hbWUgPSBidWlsZE5hbWVzW1wiZXNtXCJdOyAvLyBUT0RPOiBBZGQgbGluayB0byBhcnRpY2xlIHRoYXQgZXhwbGFpbnMgaW4gZGV0YWlsIGhvdyB0byBhdm9pZFxuICAgICAgLy8gbG9hZGluZyAyIGRpZmZlcmVudCBidWlsZHMuXG5cbiAgICAgIHRocm93IG5ldyBFcnJvcihcIllvdSBhcmUgbG9hZGluZyB0aGUgXCIgKyBzZWNvbmRhcnlCdWlsZE5hbWUgKyBcIiBidWlsZCBvZiBSZWFjdCBSb3V0ZXIgXCIgKyAoXCJvbiBhIHBhZ2UgdGhhdCBpcyBhbHJlYWR5IHJ1bm5pbmcgdGhlIFwiICsgaW5pdGlhbEJ1aWxkTmFtZSArIFwiIFwiKSArIFwiYnVpbGQsIHNvIHRoaW5ncyB3b24ndCB3b3JrIHJpZ2h0LlwiKTtcbiAgICB9XG5cbiAgICBnbG9iYWxba2V5XSA9IFwiZXNtXCI7XG4gIH1cbn1cblxuZXhwb3J0IHsgTWVtb3J5Um91dGVyLCBQcm9tcHQsIFJlZGlyZWN0LCBSb3V0ZSwgUm91dGVyLCBTdGF0aWNSb3V0ZXIsIFN3aXRjaCwgaGlzdG9yeUNvbnRleHQgYXMgX19IaXN0b3J5Q29udGV4dCwgY29udGV4dCBhcyBfX1JvdXRlckNvbnRleHQsIGdlbmVyYXRlUGF0aCwgbWF0Y2hQYXRoLCB1c2VIaXN0b3J5LCB1c2VMb2NhdGlvbiwgdXNlUGFyYW1zLCB1c2VSb3V0ZU1hdGNoLCB3aXRoUm91dGVyIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZWFjdC1yb3V0ZXIuanMubWFwXG4iLCJpbXBvcnQgeyBSb3V0ZXIsIF9fUm91dGVyQ29udGV4dCwgbWF0Y2hQYXRoIH0gZnJvbSAncmVhY3Qtcm91dGVyJztcbmV4cG9ydCB7IE1lbW9yeVJvdXRlciwgUHJvbXB0LCBSZWRpcmVjdCwgUm91dGUsIFJvdXRlciwgU3RhdGljUm91dGVyLCBTd2l0Y2gsIGdlbmVyYXRlUGF0aCwgbWF0Y2hQYXRoLCB1c2VIaXN0b3J5LCB1c2VMb2NhdGlvbiwgdXNlUGFyYW1zLCB1c2VSb3V0ZU1hdGNoLCB3aXRoUm91dGVyIH0gZnJvbSAncmVhY3Qtcm91dGVyJztcbmltcG9ydCBfaW5oZXJpdHNMb29zZSBmcm9tICdAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9pbmhlcml0c0xvb3NlJztcbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBjcmVhdGVCcm93c2VySGlzdG9yeSwgY3JlYXRlSGFzaEhpc3RvcnksIGNyZWF0ZUxvY2F0aW9uLCBjcmVhdGVQYXRoIH0gZnJvbSAnaGlzdG9yeSc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IHdhcm5pbmcgZnJvbSAndGlueS13YXJuaW5nJztcbmltcG9ydCBfZXh0ZW5kcyBmcm9tICdAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9leHRlbmRzJztcbmltcG9ydCBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZSBmcm9tICdAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlJztcbmltcG9ydCBpbnZhcmlhbnQgZnJvbSAndGlueS1pbnZhcmlhbnQnO1xuXG4vKipcbiAqIFRoZSBwdWJsaWMgQVBJIGZvciBhIDxSb3V0ZXI+IHRoYXQgdXNlcyBIVE1MNSBoaXN0b3J5LlxuICovXG5cbnZhciBCcm93c2VyUm91dGVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfUmVhY3QkQ29tcG9uZW50KSB7XG4gIF9pbmhlcml0c0xvb3NlKEJyb3dzZXJSb3V0ZXIsIF9SZWFjdCRDb21wb25lbnQpO1xuXG4gIGZ1bmN0aW9uIEJyb3dzZXJSb3V0ZXIoKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIF90aGlzID0gX1JlYWN0JENvbXBvbmVudC5jYWxsLmFwcGx5KF9SZWFjdCRDb21wb25lbnQsIFt0aGlzXS5jb25jYXQoYXJncykpIHx8IHRoaXM7XG4gICAgX3RoaXMuaGlzdG9yeSA9IGNyZWF0ZUJyb3dzZXJIaXN0b3J5KF90aGlzLnByb3BzKTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICB2YXIgX3Byb3RvID0gQnJvd3NlclJvdXRlci5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoUm91dGVyLCB7XG4gICAgICBoaXN0b3J5OiB0aGlzLmhpc3RvcnksXG4gICAgICBjaGlsZHJlbjogdGhpcy5wcm9wcy5jaGlsZHJlblxuICAgIH0pO1xuICB9O1xuXG4gIHJldHVybiBCcm93c2VyUm91dGVyO1xufShSZWFjdC5Db21wb25lbnQpO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gIEJyb3dzZXJSb3V0ZXIucHJvcFR5cGVzID0ge1xuICAgIGJhc2VuYW1lOiBQcm9wVHlwZXMuc3RyaW5nLFxuICAgIGNoaWxkcmVuOiBQcm9wVHlwZXMubm9kZSxcbiAgICBmb3JjZVJlZnJlc2g6IFByb3BUeXBlcy5ib29sLFxuICAgIGdldFVzZXJDb25maXJtYXRpb246IFByb3BUeXBlcy5mdW5jLFxuICAgIGtleUxlbmd0aDogUHJvcFR5cGVzLm51bWJlclxuICB9O1xuXG4gIEJyb3dzZXJSb3V0ZXIucHJvdG90eXBlLmNvbXBvbmVudERpZE1vdW50ID0gZnVuY3Rpb24gKCkge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IHdhcm5pbmcoIXRoaXMucHJvcHMuaGlzdG9yeSwgXCI8QnJvd3NlclJvdXRlcj4gaWdub3JlcyB0aGUgaGlzdG9yeSBwcm9wLiBUbyB1c2UgYSBjdXN0b20gaGlzdG9yeSwgXCIgKyBcInVzZSBgaW1wb3J0IHsgUm91dGVyIH1gIGluc3RlYWQgb2YgYGltcG9ydCB7IEJyb3dzZXJSb3V0ZXIgYXMgUm91dGVyIH1gLlwiKSA6IHZvaWQgMDtcbiAgfTtcbn1cblxuLyoqXG4gKiBUaGUgcHVibGljIEFQSSBmb3IgYSA8Um91dGVyPiB0aGF0IHVzZXMgd2luZG93LmxvY2F0aW9uLmhhc2guXG4gKi9cblxudmFyIEhhc2hSb3V0ZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9SZWFjdCRDb21wb25lbnQpIHtcbiAgX2luaGVyaXRzTG9vc2UoSGFzaFJvdXRlciwgX1JlYWN0JENvbXBvbmVudCk7XG5cbiAgZnVuY3Rpb24gSGFzaFJvdXRlcigpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgX3RoaXMgPSBfUmVhY3QkQ29tcG9uZW50LmNhbGwuYXBwbHkoX1JlYWN0JENvbXBvbmVudCwgW3RoaXNdLmNvbmNhdChhcmdzKSkgfHwgdGhpcztcbiAgICBfdGhpcy5oaXN0b3J5ID0gY3JlYXRlSGFzaEhpc3RvcnkoX3RoaXMucHJvcHMpO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBIYXNoUm91dGVyLnByb3RvdHlwZTtcblxuICBfcHJvdG8ucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChSb3V0ZXIsIHtcbiAgICAgIGhpc3Rvcnk6IHRoaXMuaGlzdG9yeSxcbiAgICAgIGNoaWxkcmVuOiB0aGlzLnByb3BzLmNoaWxkcmVuXG4gICAgfSk7XG4gIH07XG5cbiAgcmV0dXJuIEhhc2hSb3V0ZXI7XG59KFJlYWN0LkNvbXBvbmVudCk7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgSGFzaFJvdXRlci5wcm9wVHlwZXMgPSB7XG4gICAgYmFzZW5hbWU6IFByb3BUeXBlcy5zdHJpbmcsXG4gICAgY2hpbGRyZW46IFByb3BUeXBlcy5ub2RlLFxuICAgIGdldFVzZXJDb25maXJtYXRpb246IFByb3BUeXBlcy5mdW5jLFxuICAgIGhhc2hUeXBlOiBQcm9wVHlwZXMub25lT2YoW1wiaGFzaGJhbmdcIiwgXCJub3NsYXNoXCIsIFwic2xhc2hcIl0pXG4gIH07XG5cbiAgSGFzaFJvdXRlci5wcm90b3R5cGUuY29tcG9uZW50RGlkTW91bnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gd2FybmluZyghdGhpcy5wcm9wcy5oaXN0b3J5LCBcIjxIYXNoUm91dGVyPiBpZ25vcmVzIHRoZSBoaXN0b3J5IHByb3AuIFRvIHVzZSBhIGN1c3RvbSBoaXN0b3J5LCBcIiArIFwidXNlIGBpbXBvcnQgeyBSb3V0ZXIgfWAgaW5zdGVhZCBvZiBgaW1wb3J0IHsgSGFzaFJvdXRlciBhcyBSb3V0ZXIgfWAuXCIpIDogdm9pZCAwO1xuICB9O1xufVxuXG52YXIgcmVzb2x2ZVRvTG9jYXRpb24gPSBmdW5jdGlvbiByZXNvbHZlVG9Mb2NhdGlvbih0bywgY3VycmVudExvY2F0aW9uKSB7XG4gIHJldHVybiB0eXBlb2YgdG8gPT09IFwiZnVuY3Rpb25cIiA/IHRvKGN1cnJlbnRMb2NhdGlvbikgOiB0bztcbn07XG52YXIgbm9ybWFsaXplVG9Mb2NhdGlvbiA9IGZ1bmN0aW9uIG5vcm1hbGl6ZVRvTG9jYXRpb24odG8sIGN1cnJlbnRMb2NhdGlvbikge1xuICByZXR1cm4gdHlwZW9mIHRvID09PSBcInN0cmluZ1wiID8gY3JlYXRlTG9jYXRpb24odG8sIG51bGwsIG51bGwsIGN1cnJlbnRMb2NhdGlvbikgOiB0bztcbn07XG5cbnZhciBmb3J3YXJkUmVmU2hpbSA9IGZ1bmN0aW9uIGZvcndhcmRSZWZTaGltKEMpIHtcbiAgcmV0dXJuIEM7XG59O1xuXG52YXIgZm9yd2FyZFJlZiA9IFJlYWN0LmZvcndhcmRSZWY7XG5cbmlmICh0eXBlb2YgZm9yd2FyZFJlZiA9PT0gXCJ1bmRlZmluZWRcIikge1xuICBmb3J3YXJkUmVmID0gZm9yd2FyZFJlZlNoaW07XG59XG5cbmZ1bmN0aW9uIGlzTW9kaWZpZWRFdmVudChldmVudCkge1xuICByZXR1cm4gISEoZXZlbnQubWV0YUtleSB8fCBldmVudC5hbHRLZXkgfHwgZXZlbnQuY3RybEtleSB8fCBldmVudC5zaGlmdEtleSk7XG59XG5cbnZhciBMaW5rQW5jaG9yID0gZm9yd2FyZFJlZihmdW5jdGlvbiAoX3JlZiwgZm9yd2FyZGVkUmVmKSB7XG4gIHZhciBpbm5lclJlZiA9IF9yZWYuaW5uZXJSZWYsXG4gICAgICBuYXZpZ2F0ZSA9IF9yZWYubmF2aWdhdGUsXG4gICAgICBfb25DbGljayA9IF9yZWYub25DbGljayxcbiAgICAgIHJlc3QgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShfcmVmLCBbXCJpbm5lclJlZlwiLCBcIm5hdmlnYXRlXCIsIFwib25DbGlja1wiXSk7XG5cbiAgdmFyIHRhcmdldCA9IHJlc3QudGFyZ2V0O1xuXG4gIHZhciBwcm9wcyA9IF9leHRlbmRzKHt9LCByZXN0LCB7XG4gICAgb25DbGljazogZnVuY3Rpb24gb25DbGljayhldmVudCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKF9vbkNsaWNrKSBfb25DbGljayhldmVudCk7XG4gICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB0aHJvdyBleDtcbiAgICAgIH1cblxuICAgICAgaWYgKCFldmVudC5kZWZhdWx0UHJldmVudGVkICYmIC8vIG9uQ2xpY2sgcHJldmVudGVkIGRlZmF1bHRcbiAgICAgIGV2ZW50LmJ1dHRvbiA9PT0gMCAmJiAoIC8vIGlnbm9yZSBldmVyeXRoaW5nIGJ1dCBsZWZ0IGNsaWNrc1xuICAgICAgIXRhcmdldCB8fCB0YXJnZXQgPT09IFwiX3NlbGZcIikgJiYgLy8gbGV0IGJyb3dzZXIgaGFuZGxlIFwidGFyZ2V0PV9ibGFua1wiIGV0Yy5cbiAgICAgICFpc01vZGlmaWVkRXZlbnQoZXZlbnQpIC8vIGlnbm9yZSBjbGlja3Mgd2l0aCBtb2RpZmllciBrZXlzXG4gICAgICApIHtcbiAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIG5hdmlnYXRlKCk7XG4gICAgICAgIH1cbiAgICB9XG4gIH0pOyAvLyBSZWFjdCAxNSBjb21wYXRcblxuXG4gIGlmIChmb3J3YXJkUmVmU2hpbSAhPT0gZm9yd2FyZFJlZikge1xuICAgIHByb3BzLnJlZiA9IGZvcndhcmRlZFJlZiB8fCBpbm5lclJlZjtcbiAgfSBlbHNlIHtcbiAgICBwcm9wcy5yZWYgPSBpbm5lclJlZjtcbiAgfVxuICAvKiBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUganN4LWExMXkvYW5jaG9yLWhhcy1jb250ZW50ICovXG5cblxuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJhXCIsIHByb3BzKTtcbn0pO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gIExpbmtBbmNob3IuZGlzcGxheU5hbWUgPSBcIkxpbmtBbmNob3JcIjtcbn1cbi8qKlxuICogVGhlIHB1YmxpYyBBUEkgZm9yIHJlbmRlcmluZyBhIGhpc3RvcnktYXdhcmUgPGE+LlxuICovXG5cblxudmFyIExpbmsgPSBmb3J3YXJkUmVmKGZ1bmN0aW9uIChfcmVmMiwgZm9yd2FyZGVkUmVmKSB7XG4gIHZhciBfcmVmMiRjb21wb25lbnQgPSBfcmVmMi5jb21wb25lbnQsXG4gICAgICBjb21wb25lbnQgPSBfcmVmMiRjb21wb25lbnQgPT09IHZvaWQgMCA/IExpbmtBbmNob3IgOiBfcmVmMiRjb21wb25lbnQsXG4gICAgICByZXBsYWNlID0gX3JlZjIucmVwbGFjZSxcbiAgICAgIHRvID0gX3JlZjIudG8sXG4gICAgICBpbm5lclJlZiA9IF9yZWYyLmlubmVyUmVmLFxuICAgICAgcmVzdCA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKF9yZWYyLCBbXCJjb21wb25lbnRcIiwgXCJyZXBsYWNlXCIsIFwidG9cIiwgXCJpbm5lclJlZlwiXSk7XG5cbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KF9fUm91dGVyQ29udGV4dC5Db25zdW1lciwgbnVsbCwgZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICAhY29udGV4dCA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgXCJZb3Ugc2hvdWxkIG5vdCB1c2UgPExpbms+IG91dHNpZGUgYSA8Um91dGVyPlwiKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gICAgdmFyIGhpc3RvcnkgPSBjb250ZXh0Lmhpc3Rvcnk7XG4gICAgdmFyIGxvY2F0aW9uID0gbm9ybWFsaXplVG9Mb2NhdGlvbihyZXNvbHZlVG9Mb2NhdGlvbih0bywgY29udGV4dC5sb2NhdGlvbiksIGNvbnRleHQubG9jYXRpb24pO1xuICAgIHZhciBocmVmID0gbG9jYXRpb24gPyBoaXN0b3J5LmNyZWF0ZUhyZWYobG9jYXRpb24pIDogXCJcIjtcblxuICAgIHZhciBwcm9wcyA9IF9leHRlbmRzKHt9LCByZXN0LCB7XG4gICAgICBocmVmOiBocmVmLFxuICAgICAgbmF2aWdhdGU6IGZ1bmN0aW9uIG5hdmlnYXRlKCkge1xuICAgICAgICB2YXIgbG9jYXRpb24gPSByZXNvbHZlVG9Mb2NhdGlvbih0bywgY29udGV4dC5sb2NhdGlvbik7XG4gICAgICAgIHZhciBpc0R1cGxpY2F0ZU5hdmlnYXRpb24gPSBjcmVhdGVQYXRoKGNvbnRleHQubG9jYXRpb24pID09PSBjcmVhdGVQYXRoKG5vcm1hbGl6ZVRvTG9jYXRpb24obG9jYXRpb24pKTtcbiAgICAgICAgdmFyIG1ldGhvZCA9IHJlcGxhY2UgfHwgaXNEdXBsaWNhdGVOYXZpZ2F0aW9uID8gaGlzdG9yeS5yZXBsYWNlIDogaGlzdG9yeS5wdXNoO1xuICAgICAgICBtZXRob2QobG9jYXRpb24pO1xuICAgICAgfVxuICAgIH0pOyAvLyBSZWFjdCAxNSBjb21wYXRcblxuXG4gICAgaWYgKGZvcndhcmRSZWZTaGltICE9PSBmb3J3YXJkUmVmKSB7XG4gICAgICBwcm9wcy5yZWYgPSBmb3J3YXJkZWRSZWYgfHwgaW5uZXJSZWY7XG4gICAgfSBlbHNlIHtcbiAgICAgIHByb3BzLmlubmVyUmVmID0gaW5uZXJSZWY7XG4gICAgfVxuXG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KGNvbXBvbmVudCwgcHJvcHMpO1xuICB9KTtcbn0pO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gIHZhciB0b1R5cGUgPSBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMuc3RyaW5nLCBQcm9wVHlwZXMub2JqZWN0LCBQcm9wVHlwZXMuZnVuY10pO1xuICB2YXIgcmVmVHlwZSA9IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5zdHJpbmcsIFByb3BUeXBlcy5mdW5jLCBQcm9wVHlwZXMuc2hhcGUoe1xuICAgIGN1cnJlbnQ6IFByb3BUeXBlcy5hbnlcbiAgfSldKTtcbiAgTGluay5kaXNwbGF5TmFtZSA9IFwiTGlua1wiO1xuICBMaW5rLnByb3BUeXBlcyA9IHtcbiAgICBpbm5lclJlZjogcmVmVHlwZSxcbiAgICBvbkNsaWNrOiBQcm9wVHlwZXMuZnVuYyxcbiAgICByZXBsYWNlOiBQcm9wVHlwZXMuYm9vbCxcbiAgICB0YXJnZXQ6IFByb3BUeXBlcy5zdHJpbmcsXG4gICAgdG86IHRvVHlwZS5pc1JlcXVpcmVkXG4gIH07XG59XG5cbnZhciBmb3J3YXJkUmVmU2hpbSQxID0gZnVuY3Rpb24gZm9yd2FyZFJlZlNoaW0oQykge1xuICByZXR1cm4gQztcbn07XG5cbnZhciBmb3J3YXJkUmVmJDEgPSBSZWFjdC5mb3J3YXJkUmVmO1xuXG5pZiAodHlwZW9mIGZvcndhcmRSZWYkMSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICBmb3J3YXJkUmVmJDEgPSBmb3J3YXJkUmVmU2hpbSQxO1xufVxuXG5mdW5jdGlvbiBqb2luQ2xhc3NuYW1lcygpIHtcbiAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGNsYXNzbmFtZXMgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgY2xhc3NuYW1lc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgfVxuXG4gIHJldHVybiBjbGFzc25hbWVzLmZpbHRlcihmdW5jdGlvbiAoaSkge1xuICAgIHJldHVybiBpO1xuICB9KS5qb2luKFwiIFwiKTtcbn1cbi8qKlxuICogQSA8TGluaz4gd3JhcHBlciB0aGF0IGtub3dzIGlmIGl0J3MgXCJhY3RpdmVcIiBvciBub3QuXG4gKi9cblxuXG52YXIgTmF2TGluayA9IGZvcndhcmRSZWYkMShmdW5jdGlvbiAoX3JlZiwgZm9yd2FyZGVkUmVmKSB7XG4gIHZhciBfcmVmJGFyaWFDdXJyZW50ID0gX3JlZltcImFyaWEtY3VycmVudFwiXSxcbiAgICAgIGFyaWFDdXJyZW50ID0gX3JlZiRhcmlhQ3VycmVudCA9PT0gdm9pZCAwID8gXCJwYWdlXCIgOiBfcmVmJGFyaWFDdXJyZW50LFxuICAgICAgX3JlZiRhY3RpdmVDbGFzc05hbWUgPSBfcmVmLmFjdGl2ZUNsYXNzTmFtZSxcbiAgICAgIGFjdGl2ZUNsYXNzTmFtZSA9IF9yZWYkYWN0aXZlQ2xhc3NOYW1lID09PSB2b2lkIDAgPyBcImFjdGl2ZVwiIDogX3JlZiRhY3RpdmVDbGFzc05hbWUsXG4gICAgICBhY3RpdmVTdHlsZSA9IF9yZWYuYWN0aXZlU3R5bGUsXG4gICAgICBjbGFzc05hbWVQcm9wID0gX3JlZi5jbGFzc05hbWUsXG4gICAgICBleGFjdCA9IF9yZWYuZXhhY3QsXG4gICAgICBpc0FjdGl2ZVByb3AgPSBfcmVmLmlzQWN0aXZlLFxuICAgICAgbG9jYXRpb25Qcm9wID0gX3JlZi5sb2NhdGlvbixcbiAgICAgIHNlbnNpdGl2ZSA9IF9yZWYuc2Vuc2l0aXZlLFxuICAgICAgc3RyaWN0ID0gX3JlZi5zdHJpY3QsXG4gICAgICBzdHlsZVByb3AgPSBfcmVmLnN0eWxlLFxuICAgICAgdG8gPSBfcmVmLnRvLFxuICAgICAgaW5uZXJSZWYgPSBfcmVmLmlubmVyUmVmLFxuICAgICAgcmVzdCA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKF9yZWYsIFtcImFyaWEtY3VycmVudFwiLCBcImFjdGl2ZUNsYXNzTmFtZVwiLCBcImFjdGl2ZVN0eWxlXCIsIFwiY2xhc3NOYW1lXCIsIFwiZXhhY3RcIiwgXCJpc0FjdGl2ZVwiLCBcImxvY2F0aW9uXCIsIFwic2Vuc2l0aXZlXCIsIFwic3RyaWN0XCIsIFwic3R5bGVcIiwgXCJ0b1wiLCBcImlubmVyUmVmXCJdKTtcblxuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoX19Sb3V0ZXJDb250ZXh0LkNvbnN1bWVyLCBudWxsLCBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgICFjb250ZXh0ID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCBcIllvdSBzaG91bGQgbm90IHVzZSA8TmF2TGluaz4gb3V0c2lkZSBhIDxSb3V0ZXI+XCIpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgICB2YXIgY3VycmVudExvY2F0aW9uID0gbG9jYXRpb25Qcm9wIHx8IGNvbnRleHQubG9jYXRpb247XG4gICAgdmFyIHRvTG9jYXRpb24gPSBub3JtYWxpemVUb0xvY2F0aW9uKHJlc29sdmVUb0xvY2F0aW9uKHRvLCBjdXJyZW50TG9jYXRpb24pLCBjdXJyZW50TG9jYXRpb24pO1xuICAgIHZhciBwYXRoID0gdG9Mb2NhdGlvbi5wYXRobmFtZTsgLy8gUmVnZXggdGFrZW4gZnJvbTogaHR0cHM6Ly9naXRodWIuY29tL3BpbGxhcmpzL3BhdGgtdG8tcmVnZXhwL2Jsb2IvbWFzdGVyL2luZGV4LmpzI0wyMDJcblxuICAgIHZhciBlc2NhcGVkUGF0aCA9IHBhdGggJiYgcGF0aC5yZXBsYWNlKC8oWy4rKj89XiE6JHt9KClbXFxdfC9cXFxcXSkvZywgXCJcXFxcJDFcIik7XG4gICAgdmFyIG1hdGNoID0gZXNjYXBlZFBhdGggPyBtYXRjaFBhdGgoY3VycmVudExvY2F0aW9uLnBhdGhuYW1lLCB7XG4gICAgICBwYXRoOiBlc2NhcGVkUGF0aCxcbiAgICAgIGV4YWN0OiBleGFjdCxcbiAgICAgIHNlbnNpdGl2ZTogc2Vuc2l0aXZlLFxuICAgICAgc3RyaWN0OiBzdHJpY3RcbiAgICB9KSA6IG51bGw7XG4gICAgdmFyIGlzQWN0aXZlID0gISEoaXNBY3RpdmVQcm9wID8gaXNBY3RpdmVQcm9wKG1hdGNoLCBjdXJyZW50TG9jYXRpb24pIDogbWF0Y2gpO1xuICAgIHZhciBjbGFzc05hbWUgPSB0eXBlb2YgY2xhc3NOYW1lUHJvcCA9PT0gXCJmdW5jdGlvblwiID8gY2xhc3NOYW1lUHJvcChpc0FjdGl2ZSkgOiBjbGFzc05hbWVQcm9wO1xuICAgIHZhciBzdHlsZSA9IHR5cGVvZiBzdHlsZVByb3AgPT09IFwiZnVuY3Rpb25cIiA/IHN0eWxlUHJvcChpc0FjdGl2ZSkgOiBzdHlsZVByb3A7XG5cbiAgICBpZiAoaXNBY3RpdmUpIHtcbiAgICAgIGNsYXNzTmFtZSA9IGpvaW5DbGFzc25hbWVzKGNsYXNzTmFtZSwgYWN0aXZlQ2xhc3NOYW1lKTtcbiAgICAgIHN0eWxlID0gX2V4dGVuZHMoe30sIHN0eWxlLCBhY3RpdmVTdHlsZSk7XG4gICAgfVxuXG4gICAgdmFyIHByb3BzID0gX2V4dGVuZHMoe1xuICAgICAgXCJhcmlhLWN1cnJlbnRcIjogaXNBY3RpdmUgJiYgYXJpYUN1cnJlbnQgfHwgbnVsbCxcbiAgICAgIGNsYXNzTmFtZTogY2xhc3NOYW1lLFxuICAgICAgc3R5bGU6IHN0eWxlLFxuICAgICAgdG86IHRvTG9jYXRpb25cbiAgICB9LCByZXN0KTsgLy8gUmVhY3QgMTUgY29tcGF0XG5cblxuICAgIGlmIChmb3J3YXJkUmVmU2hpbSQxICE9PSBmb3J3YXJkUmVmJDEpIHtcbiAgICAgIHByb3BzLnJlZiA9IGZvcndhcmRlZFJlZiB8fCBpbm5lclJlZjtcbiAgICB9IGVsc2Uge1xuICAgICAgcHJvcHMuaW5uZXJSZWYgPSBpbm5lclJlZjtcbiAgICB9XG5cbiAgICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoTGluaywgcHJvcHMpO1xuICB9KTtcbn0pO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gIE5hdkxpbmsuZGlzcGxheU5hbWUgPSBcIk5hdkxpbmtcIjtcbiAgdmFyIGFyaWFDdXJyZW50VHlwZSA9IFByb3BUeXBlcy5vbmVPZihbXCJwYWdlXCIsIFwic3RlcFwiLCBcImxvY2F0aW9uXCIsIFwiZGF0ZVwiLCBcInRpbWVcIiwgXCJ0cnVlXCIsIFwiZmFsc2VcIl0pO1xuICBOYXZMaW5rLnByb3BUeXBlcyA9IF9leHRlbmRzKHt9LCBMaW5rLnByb3BUeXBlcywge1xuICAgIFwiYXJpYS1jdXJyZW50XCI6IGFyaWFDdXJyZW50VHlwZSxcbiAgICBhY3RpdmVDbGFzc05hbWU6IFByb3BUeXBlcy5zdHJpbmcsXG4gICAgYWN0aXZlU3R5bGU6IFByb3BUeXBlcy5vYmplY3QsXG4gICAgY2xhc3NOYW1lOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMuc3RyaW5nLCBQcm9wVHlwZXMuZnVuY10pLFxuICAgIGV4YWN0OiBQcm9wVHlwZXMuYm9vbCxcbiAgICBpc0FjdGl2ZTogUHJvcFR5cGVzLmZ1bmMsXG4gICAgbG9jYXRpb246IFByb3BUeXBlcy5vYmplY3QsXG4gICAgc2Vuc2l0aXZlOiBQcm9wVHlwZXMuYm9vbCxcbiAgICBzdHJpY3Q6IFByb3BUeXBlcy5ib29sLFxuICAgIHN0eWxlOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMub2JqZWN0LCBQcm9wVHlwZXMuZnVuY10pXG4gIH0pO1xufVxuXG5leHBvcnQgeyBCcm93c2VyUm91dGVyLCBIYXNoUm91dGVyLCBMaW5rLCBOYXZMaW5rIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZWFjdC1yb3V0ZXItZG9tLmpzLm1hcFxuIiwiaW1wb3J0IHsgaXNWYWxpZEVsZW1lbnQsIGZvcndhcmRSZWYsIGNsb25lRWxlbWVudCwgY3JlYXRlRWxlbWVudCB9IGZyb20gJ3JlYWN0JztcclxuaW1wb3J0IGNsYXNzbmFtZXMgZnJvbSAnY2xhc3NuYW1lcyc7XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlQ29tcG9uZW50KHsgZGlzcGxheU5hbWUsIHByb3BUeXBlcywgZGVmYXVsdFByb3BzLCB9LCBmbikge1xyXG4gICAgY29uc3QgQ29tcG9uZW50ID0gZm4ubGVuZ3RoID4gMSA/IGZvcndhcmRSZWYoZm4pIDogZm47XHJcblxyXG4gICAgQ29tcG9uZW50LmRpc3BsYXlOYW1lID0gZGlzcGxheU5hbWU7XHJcbiAgICBDb21wb25lbnQucHJvcFR5cGVzID0gcHJvcFR5cGVzO1xyXG4gICAgQ29tcG9uZW50LmRlZmF1bHRQcm9wcyA9IGRlZmF1bHRQcm9wcztcclxuXHJcbiAgICByZXR1cm4gQ29tcG9uZW50O1xyXG59XHJcblxyXG5leHBvcnQgY29uc3QgQ2xvbmUgPSBmb3J3YXJkUmVmKGZ1bmN0aW9uIENsb25lKHtcclxuICAgIGNvbXBvbmVudCxcclxuICAgIGZhbGxiYWNrLFxyXG5cclxuICAgIGNsYXNzTmFtZSxcclxuICAgIGNoaWxkcmVuID0gY29tcG9uZW50LFxyXG4gICAgLi4ucHJvcHNcclxufSwgcmVmKSB7XHJcbiAgICBpZiAoaXNWYWxpZEVsZW1lbnQoY29tcG9uZW50KSkge1xyXG4gICAgICAgIHJldHVybiBjbG9uZUVsZW1lbnQoY29tcG9uZW50LCB7XHJcbiAgICAgICAgICAgIHJlZixcclxuICAgICAgICAgICAgY2xhc3NOYW1lOiBjbGFzc25hbWVzKGNsYXNzTmFtZSwgY29tcG9uZW50LnByb3BzLmNsYXNzTmFtZSksXHJcbiAgICAgICAgICAgIC4uLnByb3BzXHJcbiAgICAgICAgfSk7XHJcbiAgICB9IGVsc2UgaWYgKGlzVmFsaWRFbGVtZW50KGZhbGxiYWNrKSkge1xyXG4gICAgICAgIHJldHVybiBjbG9uZUVsZW1lbnQoZmFsbGJhY2ssIHtcclxuICAgICAgICAgICAgcmVmLFxyXG4gICAgICAgICAgICBjbGFzc05hbWU6IGNsYXNzbmFtZXMoY2xhc3NOYW1lLCBmYWxsYmFjay5wcm9wcy5jbGFzc05hbWUpLFxyXG4gICAgICAgICAgICAuLi5wcm9wc1xyXG4gICAgICAgIH0pO1xyXG4gICAgfSBlbHNlIGlmIChmYWxsYmFjaykge1xyXG4gICAgICAgIHJldHVybiBjcmVhdGVFbGVtZW50KGZhbGxiYWNrLCB7XHJcbiAgICAgICAgICAgIHJlZixcclxuICAgICAgICAgICAgY2xhc3NOYW1lLFxyXG4gICAgICAgICAgICAuLi5wcm9wc1xyXG4gICAgICAgIH0sIGNoaWxkcmVuKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIGNoaWxkcmVuO1xyXG4gICAgfVxyXG59KTtcclxuXHJcbmV4cG9ydCB7XHJcbiAgICBpc1ZhbGlkRWxlbWVudCBhcyBpc0VsZW1lbnQsXHJcbiAgICBjbG9uZUVsZW1lbnQgYXMgY2xvbmUsXHJcbiAgICBjcmVhdGVFbGVtZW50IGFzIGNyZWF0ZVxyXG59OyIsImV4cG9ydCBjb25zdCBjc3NDbGFzc2VzID0ge1xyXG4gICAgUk9PVDogJ21kYy1pY29uJyxcclxuICAgIExJR0hUOiAnbWRjLWljb24tLWxpZ2h0JyxcclxuICAgIERBUks6ICdtZGMtaWNvbi0tZGFyaycsXHJcbiAgICBJTkFDVElWRTogJ21kYy1pY29uLS1pbmFjdGl2ZSdcclxufTsiLCJpbXBvcnQgeyBmb3J3YXJkUmVmIH0gZnJvbSAncmVhY3QnO1xyXG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xyXG5pbXBvcnQgY2xhc3NuYW1lcyBmcm9tICdjbGFzc25hbWVzJztcclxuXHJcbmltcG9ydCB7IGNzc0NsYXNzZXMgfSBmcm9tICcuL2NvbnN0YW50cyc7XHJcblxyXG5jb25zdCBJY29uID0gZm9yd2FyZFJlZigoe1xyXG4gICAgbmFtZSxcclxuICAgIHR5cGUsXHJcbiAgICBzaXplLFxyXG4gICAgbGlnaHQgPSBmYWxzZSxcclxuICAgIGRhcmsgPSBmYWxzZSxcclxuICAgIGluYWN0aXZlID0gZmFsc2UsXHJcblxyXG4gICAgZWxlbWVudCA9ICdpJyxcclxuICAgIGNvbXBvbmVudDogRWxlbWVudCA9IGVsZW1lbnQsXHJcbiAgICBjaGlsZHJlbiA9IG5hbWUsXHJcbiAgICBjbGFzc05hbWUsXHJcbiAgICAuLi5wcm9wc1xyXG59LCByZWYpID0+IHtcclxuICAgIGNvbnN0IGNsYXNzTmFtZXMgPSBjbGFzc25hbWVzKGNzc0NsYXNzZXMuUk9PVCwge1xyXG4gICAgICAgIFtgJHtjc3NDbGFzc2VzLlJPT1R9LS0ke3R5cGV9YF06IHR5cGUsXHJcbiAgICAgICAgW2Ake2Nzc0NsYXNzZXMuUk9PVH0tLSR7c2l6ZX1gXTogc2l6ZSxcclxuICAgICAgICBbY3NzQ2xhc3Nlcy5MSUdIVF06IGxpZ2h0LFxyXG4gICAgICAgIFtjc3NDbGFzc2VzLkRBUktdOiBkYXJrLFxyXG4gICAgICAgIFtjc3NDbGFzc2VzLklOQUNUSVZFXTogaW5hY3RpdmVcclxuICAgIH0sIGNsYXNzTmFtZSk7XHJcblxyXG4gICAgcmV0dXJuIChcclxuICAgICAgICA8RWxlbWVudCByZWY9e3JlZn0gY2xhc3NOYW1lPXtjbGFzc05hbWVzfSB7Li4ucHJvcHN9PlxyXG4gICAgICAgICAgICB7Y2hpbGRyZW59XHJcbiAgICAgICAgPC9FbGVtZW50PlxyXG4gICAgKTtcclxufSk7XHJcblxyXG5JY29uLmRpc3BsYXlOYW1lID0gJ01EQ0ljb24nO1xyXG5cclxuSWNvbi5wcm9wVHlwZXMgPSB7XHJcbiAgICB0eXBlOiBQcm9wVHlwZXMub25lT2YoWycnLCAnZmlsbGVkJywgJ291dGxpbmVkJywgJ3JvdW5kJywgJ3NoYXJwJywgJ3R3by10b25lJ10pLFxyXG4gICAgc2l6ZTogUHJvcFR5cGVzLnN0cmluZyxcclxuICAgIGxpZ2h0OiBQcm9wVHlwZXMuYm9vbCxcclxuICAgIGRhcms6IFByb3BUeXBlcy5ib29sLFxyXG4gICAgaW5hY3RpdmU6IFByb3BUeXBlcy5ib29sXHJcbn07XHJcblxyXG5leHBvcnQgZGVmYXVsdCBJY29uOyIsImV4cG9ydCB7IGRlZmF1bHQgfSBmcm9tICcuL0ljb24nOyIsImV4cG9ydCBjb25zdCBjc3NDbGFzc2VzID0ge1xyXG4gICAgUk9PVDogJ21kYy1hdmF0YXInLFxyXG4gICAgU01BTEw6ICdtZGMtYXZhdGFyLS1zbWFsbCcsXHJcbiAgICBNRURJVU06ICdtZGMtYXZhdGFyLS1tZWRpdW0nLFxyXG4gICAgTEFSR0U6ICdtZGMtYXZhdGFyLS1sYXJnZScsXHJcblxyXG4gICAgSU1BR0U6ICdtZGMtYXZhdGFyX19pbWFnZScsXHJcbiAgICBJQ09OOiAnbWRjLWF2YXRhcl9faWNvbicsXHJcbiAgICBURVhUOiAnbWRjLWF2YXRhcl9fdGV4dCdcclxufTsiLCJpbXBvcnQgeyBmb3J3YXJkUmVmIH0gZnJvbSAncmVhY3QnO1xyXG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xyXG5pbXBvcnQgY2xhc3NuYW1lcyBmcm9tICdjbGFzc25hbWVzJztcclxuXHJcbmltcG9ydCB7IENsb25lIH0gZnJvbSAnLi4vY29tcG9uZW50JztcclxuaW1wb3J0IEljb24gZnJvbSAnLi4vaWNvbic7XHJcblxyXG5pbXBvcnQgeyBjc3NDbGFzc2VzIH0gZnJvbSAnLi9jb25zdGFudHMnO1xyXG5cclxuY29uc3QgQXZhdGFyID0gZm9yd2FyZFJlZigoe1xyXG4gICAgaW1hZ2UsXHJcbiAgICBpY29uLFxyXG4gICAgdGV4dCxcclxuICAgIHNpemUsXHJcblxyXG4gICAgZWxlbWVudCA9ICdzcGFuJyxcclxuICAgIGNvbXBvbmVudDogRWxlbWVudCA9IGVsZW1lbnQsXHJcbiAgICBjbGFzc05hbWUsXHJcbiAgICBjaGlsZHJlbiA9IHRleHQsXHJcbiAgICAuLi5wcm9wc1xyXG59LCByZWYpID0+IHtcclxuICAgIGNvbnN0IGNsYXNzTmFtZXMgPSBjbGFzc25hbWVzKGNzc0NsYXNzZXMuUk9PVCwge1xyXG4gICAgICAgIFtgJHtjc3NDbGFzc2VzLlJPT1R9LS0ke3NpemV9YF06IHNpemVcclxuICAgIH0sIGNsYXNzTmFtZSk7XHJcblxyXG4gICAgcmV0dXJuIChcclxuICAgICAgICA8RWxlbWVudCByZWY9e3JlZn0gY2xhc3NOYW1lPXtjbGFzc05hbWVzfSB7Li4ucHJvcHN9PlxyXG4gICAgICAgICAgICB7aW1hZ2UgJiZcclxuICAgICAgICAgICAgICAgIDxpbWdcclxuICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU9e2Nzc0NsYXNzZXMuSU1BR0V9XHJcbiAgICAgICAgICAgICAgICAgICAgc3JjPXtpbWFnZT8uc3JjIHx8IGltYWdlfVxyXG4gICAgICAgICAgICAgICAgICAgIGFsdD17aW1hZ2U/LmFsdCB8fCAnJ31cclxuICAgICAgICAgICAgICAgIC8+XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHtpY29uICYmXHJcbiAgICAgICAgICAgICAgICA8Q2xvbmVcclxuICAgICAgICAgICAgICAgICAgICBjb21wb25lbnQ9e2ljb259XHJcbiAgICAgICAgICAgICAgICAgICAgZmFsbGJhY2s9e0ljb259XHJcbiAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPXtjc3NDbGFzc2VzLklDT059XHJcbiAgICAgICAgICAgICAgICAvPlxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB7Y2hpbGRyZW4gJiZcclxuICAgICAgICAgICAgICAgIDxDbG9uZVxyXG4gICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudD17Y2hpbGRyZW59XHJcbiAgICAgICAgICAgICAgICAgICAgZmFsbGJhY2s9XCJzcGFuXCJcclxuICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU9e2Nzc0NsYXNzZXMuVEVYVH1cclxuICAgICAgICAgICAgICAgIC8+XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICA8L0VsZW1lbnQ+XHJcbiAgICApO1xyXG59KTtcclxuXHJcbkF2YXRhci5kaXNwbGF5TmFtZSA9ICdNRENBdmF0YXInO1xyXG5cclxuQXZhdGFyLnByb3BUeXBlcyA9IHtcclxuICAgIHNyYzogUHJvcFR5cGVzLnN0cmluZyxcclxuICAgIGljb246IFByb3BUeXBlcy5ub2RlLFxyXG4gICAgdGV4dDogUHJvcFR5cGVzLm5vZGUsXHJcbiAgICBzaXplOiBQcm9wVHlwZXMub25lT2YoWydzbWFsbCcsICdtZWRpdW0nLCAnbGFyZ2UnXSlcclxufTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IEF2YXRhcjsiLCJleHBvcnQgeyBkZWZhdWx0IH0gZnJvbSAnLi9BdmF0YXInOyIsImV4cG9ydCBjb25zdCBjc3NDbGFzc2VzID0ge1xyXG4gICAgUk9PVDogJ21kYy1iYWRnZScsXHJcbiAgICBJTlNFVDogJ21kYy1iYWRnZS0taW5zZXQnLFxyXG4gICAgVFJBTlNQQVJFTlQ6ICdtZGMtYmFkZ2UtLXRyYW5zcGFyZW50J1xyXG59OyIsImltcG9ydCB7IGZvcndhcmRSZWYgfSBmcm9tICdyZWFjdCc7XHJcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XHJcbmltcG9ydCBjbGFzc25hbWVzIGZyb20gJ2NsYXNzbmFtZXMnO1xyXG5cclxuaW1wb3J0IHsgY3NzQ2xhc3NlcyB9IGZyb20gJy4vY29uc3RhbnRzJztcclxuXHJcbmNvbnN0IEJhZGdlID0gZm9yd2FyZFJlZigoe1xyXG4gICAgdmFsdWUsXHJcbiAgICBpbnNldCA9IGZhbHNlLFxyXG4gICAgdHJhbnNwYXJlbnQgPSBmYWxzZSxcclxuXHJcbiAgICBlbGVtZW50OiBFbGVtZW50ID0gJ3NwYW4nLFxyXG4gICAgY2xhc3NOYW1lLFxyXG4gICAgLi4ucHJvcHNcclxufSwgcmVmKSA9PiB7XHJcbiAgICBjb25zdCBjbGFzc05hbWVzID0gY2xhc3NuYW1lcyhjc3NDbGFzc2VzLlJPT1QsIHtcclxuICAgICAgICBbY3NzQ2xhc3Nlcy5JTlNFVF06IGluc2V0LFxyXG4gICAgICAgIFtjc3NDbGFzc2VzLlRSQU5TUEFSRU5UXTogdHJhbnNwYXJlbnRcclxuICAgIH0sIGNsYXNzTmFtZSk7XHJcblxyXG4gICAgcmV0dXJuIChcclxuICAgICAgICA8RWxlbWVudFxyXG4gICAgICAgICAgICByZWY9e3JlZn1cclxuICAgICAgICAgICAgY2xhc3NOYW1lPXtjbGFzc05hbWVzfVxyXG4gICAgICAgICAgICBkYXRhLWJhZGdlPXt2YWx1ZX1cclxuICAgICAgICAgICAgey4uLnByb3BzfVxyXG4gICAgICAgIC8+XHJcbiAgICApO1xyXG59KTtcclxuXHJcbkJhZGdlLmRpc3BsYXlOYW1lID0gJ01EQ0JhZGdlJztcclxuXHJcbkJhZGdlLnByb3BUeXBlcyA9IHtcclxuICAgIHZhbHVlOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMubnVtYmVyLCBQcm9wVHlwZXMuc3RyaW5nXSkuaXNSZXF1aXJlZCxcclxuICAgIGluc2V0OiBQcm9wVHlwZXMuYm9vbCxcclxuICAgIHRyYW5zcGFyZW50OiBQcm9wVHlwZXMuYm9vbFxyXG59O1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgQmFkZ2U7IiwiZXhwb3J0IHsgZGVmYXVsdCB9IGZyb20gJy4vQmFkZ2UnOyIsIi8qKlxuICogQ2hlY2tzIGlmIGEgZ2l2ZW4gZWxlbWVudCBoYXMgYSBDU1MgY2xhc3MuXG4gKiBcbiAqIEBwYXJhbSBlbGVtZW50IHRoZSBlbGVtZW50XG4gKiBAcGFyYW0gY2xhc3NOYW1lIHRoZSBDU1MgY2xhc3MgbmFtZVxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBoYXNDbGFzcyhlbGVtZW50LCBjbGFzc05hbWUpIHtcbiAgaWYgKGVsZW1lbnQuY2xhc3NMaXN0KSByZXR1cm4gISFjbGFzc05hbWUgJiYgZWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnMoY2xhc3NOYW1lKTtcbiAgcmV0dXJuIChcIiBcIiArIChlbGVtZW50LmNsYXNzTmFtZS5iYXNlVmFsIHx8IGVsZW1lbnQuY2xhc3NOYW1lKSArIFwiIFwiKS5pbmRleE9mKFwiIFwiICsgY2xhc3NOYW1lICsgXCIgXCIpICE9PSAtMTtcbn0iLCJpbXBvcnQgaGFzQ2xhc3MgZnJvbSAnLi9oYXNDbGFzcyc7XG4vKipcbiAqIEFkZHMgYSBDU1MgY2xhc3MgdG8gYSBnaXZlbiBlbGVtZW50LlxuICogXG4gKiBAcGFyYW0gZWxlbWVudCB0aGUgZWxlbWVudFxuICogQHBhcmFtIGNsYXNzTmFtZSB0aGUgQ1NTIGNsYXNzIG5hbWVcbiAqL1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBhZGRDbGFzcyhlbGVtZW50LCBjbGFzc05hbWUpIHtcbiAgaWYgKGVsZW1lbnQuY2xhc3NMaXN0KSBlbGVtZW50LmNsYXNzTGlzdC5hZGQoY2xhc3NOYW1lKTtlbHNlIGlmICghaGFzQ2xhc3MoZWxlbWVudCwgY2xhc3NOYW1lKSkgaWYgKHR5cGVvZiBlbGVtZW50LmNsYXNzTmFtZSA9PT0gJ3N0cmluZycpIGVsZW1lbnQuY2xhc3NOYW1lID0gZWxlbWVudC5jbGFzc05hbWUgKyBcIiBcIiArIGNsYXNzTmFtZTtlbHNlIGVsZW1lbnQuc2V0QXR0cmlidXRlKCdjbGFzcycsIChlbGVtZW50LmNsYXNzTmFtZSAmJiBlbGVtZW50LmNsYXNzTmFtZS5iYXNlVmFsIHx8ICcnKSArIFwiIFwiICsgY2xhc3NOYW1lKTtcbn0iLCJmdW5jdGlvbiByZXBsYWNlQ2xhc3NOYW1lKG9yaWdDbGFzcywgY2xhc3NUb1JlbW92ZSkge1xuICByZXR1cm4gb3JpZ0NsYXNzLnJlcGxhY2UobmV3IFJlZ0V4cChcIihefFxcXFxzKVwiICsgY2xhc3NUb1JlbW92ZSArIFwiKD86XFxcXHN8JClcIiwgJ2cnKSwgJyQxJykucmVwbGFjZSgvXFxzKy9nLCAnICcpLnJlcGxhY2UoL15cXHMqfFxccyokL2csICcnKTtcbn1cbi8qKlxuICogUmVtb3ZlcyBhIENTUyBjbGFzcyBmcm9tIGEgZ2l2ZW4gZWxlbWVudC5cbiAqIFxuICogQHBhcmFtIGVsZW1lbnQgdGhlIGVsZW1lbnRcbiAqIEBwYXJhbSBjbGFzc05hbWUgdGhlIENTUyBjbGFzcyBuYW1lXG4gKi9cblxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiByZW1vdmVDbGFzcyhlbGVtZW50LCBjbGFzc05hbWUpIHtcbiAgaWYgKGVsZW1lbnQuY2xhc3NMaXN0KSB7XG4gICAgZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKGNsYXNzTmFtZSk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGVsZW1lbnQuY2xhc3NOYW1lID09PSAnc3RyaW5nJykge1xuICAgIGVsZW1lbnQuY2xhc3NOYW1lID0gcmVwbGFjZUNsYXNzTmFtZShlbGVtZW50LmNsYXNzTmFtZSwgY2xhc3NOYW1lKTtcbiAgfSBlbHNlIHtcbiAgICBlbGVtZW50LnNldEF0dHJpYnV0ZSgnY2xhc3MnLCByZXBsYWNlQ2xhc3NOYW1lKGVsZW1lbnQuY2xhc3NOYW1lICYmIGVsZW1lbnQuY2xhc3NOYW1lLmJhc2VWYWwgfHwgJycsIGNsYXNzTmFtZSkpO1xuICB9XG59IiwiZXhwb3J0IGRlZmF1bHQge1xuICBkaXNhYmxlZDogZmFsc2Vcbn07IiwiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmV4cG9ydCBkZWZhdWx0IFJlYWN0LmNyZWF0ZUNvbnRleHQobnVsbCk7IiwiaW1wb3J0IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlXCI7XG5pbXBvcnQgX2luaGVyaXRzTG9vc2UgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2luaGVyaXRzTG9vc2VcIjtcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IFJlYWN0RE9NIGZyb20gJ3JlYWN0LWRvbSc7XG5pbXBvcnQgY29uZmlnIGZyb20gJy4vY29uZmlnJztcbmltcG9ydCB7IHRpbWVvdXRzU2hhcGUgfSBmcm9tICcuL3V0aWxzL1Byb3BUeXBlcyc7XG5pbXBvcnQgVHJhbnNpdGlvbkdyb3VwQ29udGV4dCBmcm9tICcuL1RyYW5zaXRpb25Hcm91cENvbnRleHQnO1xuZXhwb3J0IHZhciBVTk1PVU5URUQgPSAndW5tb3VudGVkJztcbmV4cG9ydCB2YXIgRVhJVEVEID0gJ2V4aXRlZCc7XG5leHBvcnQgdmFyIEVOVEVSSU5HID0gJ2VudGVyaW5nJztcbmV4cG9ydCB2YXIgRU5URVJFRCA9ICdlbnRlcmVkJztcbmV4cG9ydCB2YXIgRVhJVElORyA9ICdleGl0aW5nJztcbi8qKlxuICogVGhlIFRyYW5zaXRpb24gY29tcG9uZW50IGxldHMgeW91IGRlc2NyaWJlIGEgdHJhbnNpdGlvbiBmcm9tIG9uZSBjb21wb25lbnRcbiAqIHN0YXRlIHRvIGFub3RoZXIgX292ZXIgdGltZV8gd2l0aCBhIHNpbXBsZSBkZWNsYXJhdGl2ZSBBUEkuIE1vc3QgY29tbW9ubHlcbiAqIGl0J3MgdXNlZCB0byBhbmltYXRlIHRoZSBtb3VudGluZyBhbmQgdW5tb3VudGluZyBvZiBhIGNvbXBvbmVudCwgYnV0IGNhbiBhbHNvXG4gKiBiZSB1c2VkIHRvIGRlc2NyaWJlIGluLXBsYWNlIHRyYW5zaXRpb24gc3RhdGVzIGFzIHdlbGwuXG4gKlxuICogLS0tXG4gKlxuICogKipOb3RlKio6IGBUcmFuc2l0aW9uYCBpcyBhIHBsYXRmb3JtLWFnbm9zdGljIGJhc2UgY29tcG9uZW50LiBJZiB5b3UncmUgdXNpbmdcbiAqIHRyYW5zaXRpb25zIGluIENTUywgeW91J2xsIHByb2JhYmx5IHdhbnQgdG8gdXNlXG4gKiBbYENTU1RyYW5zaXRpb25gXShodHRwczovL3JlYWN0Y29tbXVuaXR5Lm9yZy9yZWFjdC10cmFuc2l0aW9uLWdyb3VwL2Nzcy10cmFuc2l0aW9uKVxuICogaW5zdGVhZC4gSXQgaW5oZXJpdHMgYWxsIHRoZSBmZWF0dXJlcyBvZiBgVHJhbnNpdGlvbmAsIGJ1dCBjb250YWluc1xuICogYWRkaXRpb25hbCBmZWF0dXJlcyBuZWNlc3NhcnkgdG8gcGxheSBuaWNlIHdpdGggQ1NTIHRyYW5zaXRpb25zIChoZW5jZSB0aGVcbiAqIG5hbWUgb2YgdGhlIGNvbXBvbmVudCkuXG4gKlxuICogLS0tXG4gKlxuICogQnkgZGVmYXVsdCB0aGUgYFRyYW5zaXRpb25gIGNvbXBvbmVudCBkb2VzIG5vdCBhbHRlciB0aGUgYmVoYXZpb3Igb2YgdGhlXG4gKiBjb21wb25lbnQgaXQgcmVuZGVycywgaXQgb25seSB0cmFja3MgXCJlbnRlclwiIGFuZCBcImV4aXRcIiBzdGF0ZXMgZm9yIHRoZVxuICogY29tcG9uZW50cy4gSXQncyB1cCB0byB5b3UgdG8gZ2l2ZSBtZWFuaW5nIGFuZCBlZmZlY3QgdG8gdGhvc2Ugc3RhdGVzLiBGb3JcbiAqIGV4YW1wbGUgd2UgY2FuIGFkZCBzdHlsZXMgdG8gYSBjb21wb25lbnQgd2hlbiBpdCBlbnRlcnMgb3IgZXhpdHM6XG4gKlxuICogYGBganN4XG4gKiBpbXBvcnQgeyBUcmFuc2l0aW9uIH0gZnJvbSAncmVhY3QtdHJhbnNpdGlvbi1ncm91cCc7XG4gKlxuICogY29uc3QgZHVyYXRpb24gPSAzMDA7XG4gKlxuICogY29uc3QgZGVmYXVsdFN0eWxlID0ge1xuICogICB0cmFuc2l0aW9uOiBgb3BhY2l0eSAke2R1cmF0aW9ufW1zIGVhc2UtaW4tb3V0YCxcbiAqICAgb3BhY2l0eTogMCxcbiAqIH1cbiAqXG4gKiBjb25zdCB0cmFuc2l0aW9uU3R5bGVzID0ge1xuICogICBlbnRlcmluZzogeyBvcGFjaXR5OiAxIH0sXG4gKiAgIGVudGVyZWQ6ICB7IG9wYWNpdHk6IDEgfSxcbiAqICAgZXhpdGluZzogIHsgb3BhY2l0eTogMCB9LFxuICogICBleGl0ZWQ6ICB7IG9wYWNpdHk6IDAgfSxcbiAqIH07XG4gKlxuICogY29uc3QgRmFkZSA9ICh7IGluOiBpblByb3AgfSkgPT4gKFxuICogICA8VHJhbnNpdGlvbiBpbj17aW5Qcm9wfSB0aW1lb3V0PXtkdXJhdGlvbn0+XG4gKiAgICAge3N0YXRlID0+IChcbiAqICAgICAgIDxkaXYgc3R5bGU9e3tcbiAqICAgICAgICAgLi4uZGVmYXVsdFN0eWxlLFxuICogICAgICAgICAuLi50cmFuc2l0aW9uU3R5bGVzW3N0YXRlXVxuICogICAgICAgfX0+XG4gKiAgICAgICAgIEknbSBhIGZhZGUgVHJhbnNpdGlvbiFcbiAqICAgICAgIDwvZGl2PlxuICogICAgICl9XG4gKiAgIDwvVHJhbnNpdGlvbj5cbiAqICk7XG4gKiBgYGBcbiAqXG4gKiBUaGVyZSBhcmUgNCBtYWluIHN0YXRlcyBhIFRyYW5zaXRpb24gY2FuIGJlIGluOlxuICogIC0gYCdlbnRlcmluZydgXG4gKiAgLSBgJ2VudGVyZWQnYFxuICogIC0gYCdleGl0aW5nJ2BcbiAqICAtIGAnZXhpdGVkJ2BcbiAqXG4gKiBUcmFuc2l0aW9uIHN0YXRlIGlzIHRvZ2dsZWQgdmlhIHRoZSBgaW5gIHByb3AuIFdoZW4gYHRydWVgIHRoZSBjb21wb25lbnRcbiAqIGJlZ2lucyB0aGUgXCJFbnRlclwiIHN0YWdlLiBEdXJpbmcgdGhpcyBzdGFnZSwgdGhlIGNvbXBvbmVudCB3aWxsIHNoaWZ0IGZyb21cbiAqIGl0cyBjdXJyZW50IHRyYW5zaXRpb24gc3RhdGUsIHRvIGAnZW50ZXJpbmcnYCBmb3IgdGhlIGR1cmF0aW9uIG9mIHRoZVxuICogdHJhbnNpdGlvbiBhbmQgdGhlbiB0byB0aGUgYCdlbnRlcmVkJ2Agc3RhZ2Ugb25jZSBpdCdzIGNvbXBsZXRlLiBMZXQncyB0YWtlXG4gKiB0aGUgZm9sbG93aW5nIGV4YW1wbGUgKHdlJ2xsIHVzZSB0aGVcbiAqIFt1c2VTdGF0ZV0oaHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL2hvb2tzLXJlZmVyZW5jZS5odG1sI3VzZXN0YXRlKSBob29rKTpcbiAqXG4gKiBgYGBqc3hcbiAqIGZ1bmN0aW9uIEFwcCgpIHtcbiAqICAgY29uc3QgW2luUHJvcCwgc2V0SW5Qcm9wXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAqICAgcmV0dXJuIChcbiAqICAgICA8ZGl2PlxuICogICAgICAgPFRyYW5zaXRpb24gaW49e2luUHJvcH0gdGltZW91dD17NTAwfT5cbiAqICAgICAgICAge3N0YXRlID0+IChcbiAqICAgICAgICAgICAvLyAuLi5cbiAqICAgICAgICAgKX1cbiAqICAgICAgIDwvVHJhbnNpdGlvbj5cbiAqICAgICAgIDxidXR0b24gb25DbGljaz17KCkgPT4gc2V0SW5Qcm9wKHRydWUpfT5cbiAqICAgICAgICAgQ2xpY2sgdG8gRW50ZXJcbiAqICAgICAgIDwvYnV0dG9uPlxuICogICAgIDwvZGl2PlxuICogICApO1xuICogfVxuICogYGBgXG4gKlxuICogV2hlbiB0aGUgYnV0dG9uIGlzIGNsaWNrZWQgdGhlIGNvbXBvbmVudCB3aWxsIHNoaWZ0IHRvIHRoZSBgJ2VudGVyaW5nJ2Agc3RhdGVcbiAqIGFuZCBzdGF5IHRoZXJlIGZvciA1MDBtcyAodGhlIHZhbHVlIG9mIGB0aW1lb3V0YCkgYmVmb3JlIGl0IGZpbmFsbHkgc3dpdGNoZXNcbiAqIHRvIGAnZW50ZXJlZCdgLlxuICpcbiAqIFdoZW4gYGluYCBpcyBgZmFsc2VgIHRoZSBzYW1lIHRoaW5nIGhhcHBlbnMgZXhjZXB0IHRoZSBzdGF0ZSBtb3ZlcyBmcm9tXG4gKiBgJ2V4aXRpbmcnYCB0byBgJ2V4aXRlZCdgLlxuICovXG5cbnZhciBUcmFuc2l0aW9uID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfUmVhY3QkQ29tcG9uZW50KSB7XG4gIF9pbmhlcml0c0xvb3NlKFRyYW5zaXRpb24sIF9SZWFjdCRDb21wb25lbnQpO1xuXG4gIGZ1bmN0aW9uIFRyYW5zaXRpb24ocHJvcHMsIGNvbnRleHQpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBfdGhpcyA9IF9SZWFjdCRDb21wb25lbnQuY2FsbCh0aGlzLCBwcm9wcywgY29udGV4dCkgfHwgdGhpcztcbiAgICB2YXIgcGFyZW50R3JvdXAgPSBjb250ZXh0OyAvLyBJbiB0aGUgY29udGV4dCBvZiBhIFRyYW5zaXRpb25Hcm91cCBhbGwgZW50ZXJzIGFyZSByZWFsbHkgYXBwZWFyc1xuXG4gICAgdmFyIGFwcGVhciA9IHBhcmVudEdyb3VwICYmICFwYXJlbnRHcm91cC5pc01vdW50aW5nID8gcHJvcHMuZW50ZXIgOiBwcm9wcy5hcHBlYXI7XG4gICAgdmFyIGluaXRpYWxTdGF0dXM7XG4gICAgX3RoaXMuYXBwZWFyU3RhdHVzID0gbnVsbDtcblxuICAgIGlmIChwcm9wcy5pbikge1xuICAgICAgaWYgKGFwcGVhcikge1xuICAgICAgICBpbml0aWFsU3RhdHVzID0gRVhJVEVEO1xuICAgICAgICBfdGhpcy5hcHBlYXJTdGF0dXMgPSBFTlRFUklORztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGluaXRpYWxTdGF0dXMgPSBFTlRFUkVEO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAocHJvcHMudW5tb3VudE9uRXhpdCB8fCBwcm9wcy5tb3VudE9uRW50ZXIpIHtcbiAgICAgICAgaW5pdGlhbFN0YXR1cyA9IFVOTU9VTlRFRDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGluaXRpYWxTdGF0dXMgPSBFWElURUQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgX3RoaXMuc3RhdGUgPSB7XG4gICAgICBzdGF0dXM6IGluaXRpYWxTdGF0dXNcbiAgICB9O1xuICAgIF90aGlzLm5leHRDYWxsYmFjayA9IG51bGw7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgVHJhbnNpdGlvbi5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMgPSBmdW5jdGlvbiBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMoX3JlZiwgcHJldlN0YXRlKSB7XG4gICAgdmFyIG5leHRJbiA9IF9yZWYuaW47XG5cbiAgICBpZiAobmV4dEluICYmIHByZXZTdGF0ZS5zdGF0dXMgPT09IFVOTU9VTlRFRCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc3RhdHVzOiBFWElURURcbiAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH0gLy8gZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUocHJldlByb3BzKSB7XG4gIC8vICAgbGV0IG5leHRTdGF0dXMgPSBudWxsXG4gIC8vICAgaWYgKHByZXZQcm9wcyAhPT0gdGhpcy5wcm9wcykge1xuICAvLyAgICAgY29uc3QgeyBzdGF0dXMgfSA9IHRoaXMuc3RhdGVcbiAgLy8gICAgIGlmICh0aGlzLnByb3BzLmluKSB7XG4gIC8vICAgICAgIGlmIChzdGF0dXMgIT09IEVOVEVSSU5HICYmIHN0YXR1cyAhPT0gRU5URVJFRCkge1xuICAvLyAgICAgICAgIG5leHRTdGF0dXMgPSBFTlRFUklOR1xuICAvLyAgICAgICB9XG4gIC8vICAgICB9IGVsc2Uge1xuICAvLyAgICAgICBpZiAoc3RhdHVzID09PSBFTlRFUklORyB8fCBzdGF0dXMgPT09IEVOVEVSRUQpIHtcbiAgLy8gICAgICAgICBuZXh0U3RhdHVzID0gRVhJVElOR1xuICAvLyAgICAgICB9XG4gIC8vICAgICB9XG4gIC8vICAgfVxuICAvLyAgIHJldHVybiB7IG5leHRTdGF0dXMgfVxuICAvLyB9XG4gIDtcblxuICB2YXIgX3Byb3RvID0gVHJhbnNpdGlvbi5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLmNvbXBvbmVudERpZE1vdW50ID0gZnVuY3Rpb24gY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgdGhpcy51cGRhdGVTdGF0dXModHJ1ZSwgdGhpcy5hcHBlYXJTdGF0dXMpO1xuICB9O1xuXG4gIF9wcm90by5jb21wb25lbnREaWRVcGRhdGUgPSBmdW5jdGlvbiBjb21wb25lbnREaWRVcGRhdGUocHJldlByb3BzKSB7XG4gICAgdmFyIG5leHRTdGF0dXMgPSBudWxsO1xuXG4gICAgaWYgKHByZXZQcm9wcyAhPT0gdGhpcy5wcm9wcykge1xuICAgICAgdmFyIHN0YXR1cyA9IHRoaXMuc3RhdGUuc3RhdHVzO1xuXG4gICAgICBpZiAodGhpcy5wcm9wcy5pbikge1xuICAgICAgICBpZiAoc3RhdHVzICE9PSBFTlRFUklORyAmJiBzdGF0dXMgIT09IEVOVEVSRUQpIHtcbiAgICAgICAgICBuZXh0U3RhdHVzID0gRU5URVJJTkc7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChzdGF0dXMgPT09IEVOVEVSSU5HIHx8IHN0YXR1cyA9PT0gRU5URVJFRCkge1xuICAgICAgICAgIG5leHRTdGF0dXMgPSBFWElUSU5HO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy51cGRhdGVTdGF0dXMoZmFsc2UsIG5leHRTdGF0dXMpO1xuICB9O1xuXG4gIF9wcm90by5jb21wb25lbnRXaWxsVW5tb3VudCA9IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgIHRoaXMuY2FuY2VsTmV4dENhbGxiYWNrKCk7XG4gIH07XG5cbiAgX3Byb3RvLmdldFRpbWVvdXRzID0gZnVuY3Rpb24gZ2V0VGltZW91dHMoKSB7XG4gICAgdmFyIHRpbWVvdXQgPSB0aGlzLnByb3BzLnRpbWVvdXQ7XG4gICAgdmFyIGV4aXQsIGVudGVyLCBhcHBlYXI7XG4gICAgZXhpdCA9IGVudGVyID0gYXBwZWFyID0gdGltZW91dDtcblxuICAgIGlmICh0aW1lb3V0ICE9IG51bGwgJiYgdHlwZW9mIHRpbWVvdXQgIT09ICdudW1iZXInKSB7XG4gICAgICBleGl0ID0gdGltZW91dC5leGl0O1xuICAgICAgZW50ZXIgPSB0aW1lb3V0LmVudGVyOyAvLyBUT0RPOiByZW1vdmUgZmFsbGJhY2sgZm9yIG5leHQgbWFqb3JcblxuICAgICAgYXBwZWFyID0gdGltZW91dC5hcHBlYXIgIT09IHVuZGVmaW5lZCA/IHRpbWVvdXQuYXBwZWFyIDogZW50ZXI7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGV4aXQ6IGV4aXQsXG4gICAgICBlbnRlcjogZW50ZXIsXG4gICAgICBhcHBlYXI6IGFwcGVhclxuICAgIH07XG4gIH07XG5cbiAgX3Byb3RvLnVwZGF0ZVN0YXR1cyA9IGZ1bmN0aW9uIHVwZGF0ZVN0YXR1cyhtb3VudGluZywgbmV4dFN0YXR1cykge1xuICAgIGlmIChtb3VudGluZyA9PT0gdm9pZCAwKSB7XG4gICAgICBtb3VudGluZyA9IGZhbHNlO1xuICAgIH1cblxuICAgIGlmIChuZXh0U3RhdHVzICE9PSBudWxsKSB7XG4gICAgICAvLyBuZXh0U3RhdHVzIHdpbGwgYWx3YXlzIGJlIEVOVEVSSU5HIG9yIEVYSVRJTkcuXG4gICAgICB0aGlzLmNhbmNlbE5leHRDYWxsYmFjaygpO1xuXG4gICAgICBpZiAobmV4dFN0YXR1cyA9PT0gRU5URVJJTkcpIHtcbiAgICAgICAgdGhpcy5wZXJmb3JtRW50ZXIobW91bnRpbmcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5wZXJmb3JtRXhpdCgpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodGhpcy5wcm9wcy51bm1vdW50T25FeGl0ICYmIHRoaXMuc3RhdGUuc3RhdHVzID09PSBFWElURUQpIHtcbiAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICBzdGF0dXM6IFVOTU9VTlRFRFxuICAgICAgfSk7XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5wZXJmb3JtRW50ZXIgPSBmdW5jdGlvbiBwZXJmb3JtRW50ZXIobW91bnRpbmcpIHtcbiAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgIHZhciBlbnRlciA9IHRoaXMucHJvcHMuZW50ZXI7XG4gICAgdmFyIGFwcGVhcmluZyA9IHRoaXMuY29udGV4dCA/IHRoaXMuY29udGV4dC5pc01vdW50aW5nIDogbW91bnRpbmc7XG5cbiAgICB2YXIgX3JlZjIgPSB0aGlzLnByb3BzLm5vZGVSZWYgPyBbYXBwZWFyaW5nXSA6IFtSZWFjdERPTS5maW5kRE9NTm9kZSh0aGlzKSwgYXBwZWFyaW5nXSxcbiAgICAgICAgbWF5YmVOb2RlID0gX3JlZjJbMF0sXG4gICAgICAgIG1heWJlQXBwZWFyaW5nID0gX3JlZjJbMV07XG5cbiAgICB2YXIgdGltZW91dHMgPSB0aGlzLmdldFRpbWVvdXRzKCk7XG4gICAgdmFyIGVudGVyVGltZW91dCA9IGFwcGVhcmluZyA/IHRpbWVvdXRzLmFwcGVhciA6IHRpbWVvdXRzLmVudGVyOyAvLyBubyBlbnRlciBhbmltYXRpb24gc2tpcCByaWdodCB0byBFTlRFUkVEXG4gICAgLy8gaWYgd2UgYXJlIG1vdW50aW5nIGFuZCBydW5uaW5nIHRoaXMgaXQgbWVhbnMgYXBwZWFyIF9tdXN0XyBiZSBzZXRcblxuICAgIGlmICghbW91bnRpbmcgJiYgIWVudGVyIHx8IGNvbmZpZy5kaXNhYmxlZCkge1xuICAgICAgdGhpcy5zYWZlU2V0U3RhdGUoe1xuICAgICAgICBzdGF0dXM6IEVOVEVSRURcbiAgICAgIH0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3RoaXMyLnByb3BzLm9uRW50ZXJlZChtYXliZU5vZGUpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5wcm9wcy5vbkVudGVyKG1heWJlTm9kZSwgbWF5YmVBcHBlYXJpbmcpO1xuICAgIHRoaXMuc2FmZVNldFN0YXRlKHtcbiAgICAgIHN0YXR1czogRU5URVJJTkdcbiAgICB9LCBmdW5jdGlvbiAoKSB7XG4gICAgICBfdGhpczIucHJvcHMub25FbnRlcmluZyhtYXliZU5vZGUsIG1heWJlQXBwZWFyaW5nKTtcblxuICAgICAgX3RoaXMyLm9uVHJhbnNpdGlvbkVuZChlbnRlclRpbWVvdXQsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3RoaXMyLnNhZmVTZXRTdGF0ZSh7XG4gICAgICAgICAgc3RhdHVzOiBFTlRFUkVEXG4gICAgICAgIH0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBfdGhpczIucHJvcHMub25FbnRlcmVkKG1heWJlTm9kZSwgbWF5YmVBcHBlYXJpbmcpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9O1xuXG4gIF9wcm90by5wZXJmb3JtRXhpdCA9IGZ1bmN0aW9uIHBlcmZvcm1FeGl0KCkge1xuICAgIHZhciBfdGhpczMgPSB0aGlzO1xuXG4gICAgdmFyIGV4aXQgPSB0aGlzLnByb3BzLmV4aXQ7XG4gICAgdmFyIHRpbWVvdXRzID0gdGhpcy5nZXRUaW1lb3V0cygpO1xuICAgIHZhciBtYXliZU5vZGUgPSB0aGlzLnByb3BzLm5vZGVSZWYgPyB1bmRlZmluZWQgOiBSZWFjdERPTS5maW5kRE9NTm9kZSh0aGlzKTsgLy8gbm8gZXhpdCBhbmltYXRpb24gc2tpcCByaWdodCB0byBFWElURURcblxuICAgIGlmICghZXhpdCB8fCBjb25maWcuZGlzYWJsZWQpIHtcbiAgICAgIHRoaXMuc2FmZVNldFN0YXRlKHtcbiAgICAgICAgc3RhdHVzOiBFWElURURcbiAgICAgIH0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3RoaXMzLnByb3BzLm9uRXhpdGVkKG1heWJlTm9kZSk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLnByb3BzLm9uRXhpdChtYXliZU5vZGUpO1xuICAgIHRoaXMuc2FmZVNldFN0YXRlKHtcbiAgICAgIHN0YXR1czogRVhJVElOR1xuICAgIH0sIGZ1bmN0aW9uICgpIHtcbiAgICAgIF90aGlzMy5wcm9wcy5vbkV4aXRpbmcobWF5YmVOb2RlKTtcblxuICAgICAgX3RoaXMzLm9uVHJhbnNpdGlvbkVuZCh0aW1lb3V0cy5leGl0LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIF90aGlzMy5zYWZlU2V0U3RhdGUoe1xuICAgICAgICAgIHN0YXR1czogRVhJVEVEXG4gICAgICAgIH0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBfdGhpczMucHJvcHMub25FeGl0ZWQobWF5YmVOb2RlKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfTtcblxuICBfcHJvdG8uY2FuY2VsTmV4dENhbGxiYWNrID0gZnVuY3Rpb24gY2FuY2VsTmV4dENhbGxiYWNrKCkge1xuICAgIGlmICh0aGlzLm5leHRDYWxsYmFjayAhPT0gbnVsbCkge1xuICAgICAgdGhpcy5uZXh0Q2FsbGJhY2suY2FuY2VsKCk7XG4gICAgICB0aGlzLm5leHRDYWxsYmFjayA9IG51bGw7XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5zYWZlU2V0U3RhdGUgPSBmdW5jdGlvbiBzYWZlU2V0U3RhdGUobmV4dFN0YXRlLCBjYWxsYmFjaykge1xuICAgIC8vIFRoaXMgc2hvdWxkbid0IGJlIG5lY2Vzc2FyeSwgYnV0IHRoZXJlIGFyZSB3ZWlyZCByYWNlIGNvbmRpdGlvbnMgd2l0aFxuICAgIC8vIHNldFN0YXRlIGNhbGxiYWNrcyBhbmQgdW5tb3VudGluZyBpbiB0ZXN0aW5nLCBzbyBhbHdheXMgbWFrZSBzdXJlIHRoYXRcbiAgICAvLyB3ZSBjYW4gY2FuY2VsIGFueSBwZW5kaW5nIHNldFN0YXRlIGNhbGxiYWNrcyBhZnRlciB3ZSB1bm1vdW50LlxuICAgIGNhbGxiYWNrID0gdGhpcy5zZXROZXh0Q2FsbGJhY2soY2FsbGJhY2spO1xuICAgIHRoaXMuc2V0U3RhdGUobmV4dFN0YXRlLCBjYWxsYmFjayk7XG4gIH07XG5cbiAgX3Byb3RvLnNldE5leHRDYWxsYmFjayA9IGZ1bmN0aW9uIHNldE5leHRDYWxsYmFjayhjYWxsYmFjaykge1xuICAgIHZhciBfdGhpczQgPSB0aGlzO1xuXG4gICAgdmFyIGFjdGl2ZSA9IHRydWU7XG5cbiAgICB0aGlzLm5leHRDYWxsYmFjayA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgaWYgKGFjdGl2ZSkge1xuICAgICAgICBhY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgX3RoaXM0Lm5leHRDYWxsYmFjayA9IG51bGw7XG4gICAgICAgIGNhbGxiYWNrKGV2ZW50KTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdGhpcy5uZXh0Q2FsbGJhY2suY2FuY2VsID0gZnVuY3Rpb24gKCkge1xuICAgICAgYWN0aXZlID0gZmFsc2U7XG4gICAgfTtcblxuICAgIHJldHVybiB0aGlzLm5leHRDYWxsYmFjaztcbiAgfTtcblxuICBfcHJvdG8ub25UcmFuc2l0aW9uRW5kID0gZnVuY3Rpb24gb25UcmFuc2l0aW9uRW5kKHRpbWVvdXQsIGhhbmRsZXIpIHtcbiAgICB0aGlzLnNldE5leHRDYWxsYmFjayhoYW5kbGVyKTtcbiAgICB2YXIgbm9kZSA9IHRoaXMucHJvcHMubm9kZVJlZiA/IHRoaXMucHJvcHMubm9kZVJlZi5jdXJyZW50IDogUmVhY3RET00uZmluZERPTU5vZGUodGhpcyk7XG4gICAgdmFyIGRvZXNOb3RIYXZlVGltZW91dE9yTGlzdGVuZXIgPSB0aW1lb3V0ID09IG51bGwgJiYgIXRoaXMucHJvcHMuYWRkRW5kTGlzdGVuZXI7XG5cbiAgICBpZiAoIW5vZGUgfHwgZG9lc05vdEhhdmVUaW1lb3V0T3JMaXN0ZW5lcikge1xuICAgICAgc2V0VGltZW91dCh0aGlzLm5leHRDYWxsYmFjaywgMCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHRoaXMucHJvcHMuYWRkRW5kTGlzdGVuZXIpIHtcbiAgICAgIHZhciBfcmVmMyA9IHRoaXMucHJvcHMubm9kZVJlZiA/IFt0aGlzLm5leHRDYWxsYmFja10gOiBbbm9kZSwgdGhpcy5uZXh0Q2FsbGJhY2tdLFxuICAgICAgICAgIG1heWJlTm9kZSA9IF9yZWYzWzBdLFxuICAgICAgICAgIG1heWJlTmV4dENhbGxiYWNrID0gX3JlZjNbMV07XG5cbiAgICAgIHRoaXMucHJvcHMuYWRkRW5kTGlzdGVuZXIobWF5YmVOb2RlLCBtYXliZU5leHRDYWxsYmFjayk7XG4gICAgfVxuXG4gICAgaWYgKHRpbWVvdXQgIT0gbnVsbCkge1xuICAgICAgc2V0VGltZW91dCh0aGlzLm5leHRDYWxsYmFjaywgdGltZW91dCk7XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgdmFyIHN0YXR1cyA9IHRoaXMuc3RhdGUuc3RhdHVzO1xuXG4gICAgaWYgKHN0YXR1cyA9PT0gVU5NT1VOVEVEKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICB2YXIgX3RoaXMkcHJvcHMgPSB0aGlzLnByb3BzLFxuICAgICAgICBjaGlsZHJlbiA9IF90aGlzJHByb3BzLmNoaWxkcmVuLFxuICAgICAgICBfaW4gPSBfdGhpcyRwcm9wcy5pbixcbiAgICAgICAgX21vdW50T25FbnRlciA9IF90aGlzJHByb3BzLm1vdW50T25FbnRlcixcbiAgICAgICAgX3VubW91bnRPbkV4aXQgPSBfdGhpcyRwcm9wcy51bm1vdW50T25FeGl0LFxuICAgICAgICBfYXBwZWFyID0gX3RoaXMkcHJvcHMuYXBwZWFyLFxuICAgICAgICBfZW50ZXIgPSBfdGhpcyRwcm9wcy5lbnRlcixcbiAgICAgICAgX2V4aXQgPSBfdGhpcyRwcm9wcy5leGl0LFxuICAgICAgICBfdGltZW91dCA9IF90aGlzJHByb3BzLnRpbWVvdXQsXG4gICAgICAgIF9hZGRFbmRMaXN0ZW5lciA9IF90aGlzJHByb3BzLmFkZEVuZExpc3RlbmVyLFxuICAgICAgICBfb25FbnRlciA9IF90aGlzJHByb3BzLm9uRW50ZXIsXG4gICAgICAgIF9vbkVudGVyaW5nID0gX3RoaXMkcHJvcHMub25FbnRlcmluZyxcbiAgICAgICAgX29uRW50ZXJlZCA9IF90aGlzJHByb3BzLm9uRW50ZXJlZCxcbiAgICAgICAgX29uRXhpdCA9IF90aGlzJHByb3BzLm9uRXhpdCxcbiAgICAgICAgX29uRXhpdGluZyA9IF90aGlzJHByb3BzLm9uRXhpdGluZyxcbiAgICAgICAgX29uRXhpdGVkID0gX3RoaXMkcHJvcHMub25FeGl0ZWQsXG4gICAgICAgIF9ub2RlUmVmID0gX3RoaXMkcHJvcHMubm9kZVJlZixcbiAgICAgICAgY2hpbGRQcm9wcyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKF90aGlzJHByb3BzLCBbXCJjaGlsZHJlblwiLCBcImluXCIsIFwibW91bnRPbkVudGVyXCIsIFwidW5tb3VudE9uRXhpdFwiLCBcImFwcGVhclwiLCBcImVudGVyXCIsIFwiZXhpdFwiLCBcInRpbWVvdXRcIiwgXCJhZGRFbmRMaXN0ZW5lclwiLCBcIm9uRW50ZXJcIiwgXCJvbkVudGVyaW5nXCIsIFwib25FbnRlcmVkXCIsIFwib25FeGl0XCIsIFwib25FeGl0aW5nXCIsIFwib25FeGl0ZWRcIiwgXCJub2RlUmVmXCJdKTtcblxuICAgIHJldHVybiAoXG4gICAgICAvKiNfX1BVUkVfXyovXG4gICAgICAvLyBhbGxvd3MgZm9yIG5lc3RlZCBUcmFuc2l0aW9uc1xuICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChUcmFuc2l0aW9uR3JvdXBDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgICAgIHZhbHVlOiBudWxsXG4gICAgICB9LCB0eXBlb2YgY2hpbGRyZW4gPT09ICdmdW5jdGlvbicgPyBjaGlsZHJlbihzdGF0dXMsIGNoaWxkUHJvcHMpIDogUmVhY3QuY2xvbmVFbGVtZW50KFJlYWN0LkNoaWxkcmVuLm9ubHkoY2hpbGRyZW4pLCBjaGlsZFByb3BzKSlcbiAgICApO1xuICB9O1xuXG4gIHJldHVybiBUcmFuc2l0aW9uO1xufShSZWFjdC5Db21wb25lbnQpO1xuXG5UcmFuc2l0aW9uLmNvbnRleHRUeXBlID0gVHJhbnNpdGlvbkdyb3VwQ29udGV4dDtcblRyYW5zaXRpb24ucHJvcFR5cGVzID0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8ge1xuICAvKipcbiAgICogQSBSZWFjdCByZWZlcmVuY2UgdG8gRE9NIGVsZW1lbnQgdGhhdCBuZWVkIHRvIHRyYW5zaXRpb246XG4gICAqIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS81MTEyNzEzMC80NjcxOTMyXG4gICAqXG4gICAqICAgLSBXaGVuIGBub2RlUmVmYCBwcm9wIGlzIHVzZWQsIGBub2RlYCBpcyBub3QgcGFzc2VkIHRvIGNhbGxiYWNrIGZ1bmN0aW9uc1xuICAgKiAgICAgIChlLmcuIGBvbkVudGVyYCkgYmVjYXVzZSB1c2VyIGFscmVhZHkgaGFzIGRpcmVjdCBhY2Nlc3MgdG8gdGhlIG5vZGUuXG4gICAqICAgLSBXaGVuIGNoYW5naW5nIGBrZXlgIHByb3Agb2YgYFRyYW5zaXRpb25gIGluIGEgYFRyYW5zaXRpb25Hcm91cGAgYSBuZXdcbiAgICogICAgIGBub2RlUmVmYCBuZWVkIHRvIGJlIHByb3ZpZGVkIHRvIGBUcmFuc2l0aW9uYCB3aXRoIGNoYW5nZWQgYGtleWAgcHJvcFxuICAgKiAgICAgKHNlZVxuICAgKiAgICAgW3Rlc3QvQ1NTVHJhbnNpdGlvbi10ZXN0LmpzXShodHRwczovL2dpdGh1Yi5jb20vcmVhY3Rqcy9yZWFjdC10cmFuc2l0aW9uLWdyb3VwL2Jsb2IvMTM0MzVmODk3YjNhYjcxZjZlMTlkNzI0ZjE0NTU5NmY1OTEwNTgxYy90ZXN0L0NTU1RyYW5zaXRpb24tdGVzdC5qcyNMMzYyLUw0MzcpKS5cbiAgICovXG4gIG5vZGVSZWY6IFByb3BUeXBlcy5zaGFwZSh7XG4gICAgY3VycmVudDogdHlwZW9mIEVsZW1lbnQgPT09ICd1bmRlZmluZWQnID8gUHJvcFR5cGVzLmFueSA6IGZ1bmN0aW9uIChwcm9wVmFsdWUsIGtleSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSwgc2VjcmV0KSB7XG4gICAgICB2YXIgdmFsdWUgPSBwcm9wVmFsdWVba2V5XTtcbiAgICAgIHJldHVybiBQcm9wVHlwZXMuaW5zdGFuY2VPZih2YWx1ZSAmJiAnb3duZXJEb2N1bWVudCcgaW4gdmFsdWUgPyB2YWx1ZS5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3LkVsZW1lbnQgOiBFbGVtZW50KShwcm9wVmFsdWUsIGtleSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSwgc2VjcmV0KTtcbiAgICB9XG4gIH0pLFxuXG4gIC8qKlxuICAgKiBBIGBmdW5jdGlvbmAgY2hpbGQgY2FuIGJlIHVzZWQgaW5zdGVhZCBvZiBhIFJlYWN0IGVsZW1lbnQuIFRoaXMgZnVuY3Rpb24gaXNcbiAgICogY2FsbGVkIHdpdGggdGhlIGN1cnJlbnQgdHJhbnNpdGlvbiBzdGF0dXMgKGAnZW50ZXJpbmcnYCwgYCdlbnRlcmVkJ2AsXG4gICAqIGAnZXhpdGluZydgLCBgJ2V4aXRlZCdgKSwgd2hpY2ggY2FuIGJlIHVzZWQgdG8gYXBwbHkgY29udGV4dFxuICAgKiBzcGVjaWZpYyBwcm9wcyB0byBhIGNvbXBvbmVudC5cbiAgICpcbiAgICogYGBganN4XG4gICAqIDxUcmFuc2l0aW9uIGluPXt0aGlzLnN0YXRlLmlufSB0aW1lb3V0PXsxNTB9PlxuICAgKiAgIHtzdGF0ZSA9PiAoXG4gICAqICAgICA8TXlDb21wb25lbnQgY2xhc3NOYW1lPXtgZmFkZSBmYWRlLSR7c3RhdGV9YH0gLz5cbiAgICogICApfVxuICAgKiA8L1RyYW5zaXRpb24+XG4gICAqIGBgYFxuICAgKi9cbiAgY2hpbGRyZW46IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWQsIFByb3BUeXBlcy5lbGVtZW50LmlzUmVxdWlyZWRdKS5pc1JlcXVpcmVkLFxuXG4gIC8qKlxuICAgKiBTaG93IHRoZSBjb21wb25lbnQ7IHRyaWdnZXJzIHRoZSBlbnRlciBvciBleGl0IHN0YXRlc1xuICAgKi9cbiAgaW46IFByb3BUeXBlcy5ib29sLFxuXG4gIC8qKlxuICAgKiBCeSBkZWZhdWx0IHRoZSBjaGlsZCBjb21wb25lbnQgaXMgbW91bnRlZCBpbW1lZGlhdGVseSBhbG9uZyB3aXRoXG4gICAqIHRoZSBwYXJlbnQgYFRyYW5zaXRpb25gIGNvbXBvbmVudC4gSWYgeW91IHdhbnQgdG8gXCJsYXp5IG1vdW50XCIgdGhlIGNvbXBvbmVudCBvbiB0aGVcbiAgICogZmlyc3QgYGluPXt0cnVlfWAgeW91IGNhbiBzZXQgYG1vdW50T25FbnRlcmAuIEFmdGVyIHRoZSBmaXJzdCBlbnRlciB0cmFuc2l0aW9uIHRoZSBjb21wb25lbnQgd2lsbCBzdGF5XG4gICAqIG1vdW50ZWQsIGV2ZW4gb24gXCJleGl0ZWRcIiwgdW5sZXNzIHlvdSBhbHNvIHNwZWNpZnkgYHVubW91bnRPbkV4aXRgLlxuICAgKi9cbiAgbW91bnRPbkVudGVyOiBQcm9wVHlwZXMuYm9vbCxcblxuICAvKipcbiAgICogQnkgZGVmYXVsdCB0aGUgY2hpbGQgY29tcG9uZW50IHN0YXlzIG1vdW50ZWQgYWZ0ZXIgaXQgcmVhY2hlcyB0aGUgYCdleGl0ZWQnYCBzdGF0ZS5cbiAgICogU2V0IGB1bm1vdW50T25FeGl0YCBpZiB5b3UnZCBwcmVmZXIgdG8gdW5tb3VudCB0aGUgY29tcG9uZW50IGFmdGVyIGl0IGZpbmlzaGVzIGV4aXRpbmcuXG4gICAqL1xuICB1bm1vdW50T25FeGl0OiBQcm9wVHlwZXMuYm9vbCxcblxuICAvKipcbiAgICogQnkgZGVmYXVsdCB0aGUgY2hpbGQgY29tcG9uZW50IGRvZXMgbm90IHBlcmZvcm0gdGhlIGVudGVyIHRyYW5zaXRpb24gd2hlblxuICAgKiBpdCBmaXJzdCBtb3VudHMsIHJlZ2FyZGxlc3Mgb2YgdGhlIHZhbHVlIG9mIGBpbmAuIElmIHlvdSB3YW50IHRoaXNcbiAgICogYmVoYXZpb3IsIHNldCBib3RoIGBhcHBlYXJgIGFuZCBgaW5gIHRvIGB0cnVlYC5cbiAgICpcbiAgICogPiAqKk5vdGUqKjogdGhlcmUgYXJlIG5vIHNwZWNpYWwgYXBwZWFyIHN0YXRlcyBsaWtlIGBhcHBlYXJpbmdgL2BhcHBlYXJlZGAsIHRoaXMgcHJvcFxuICAgKiA+IG9ubHkgYWRkcyBhbiBhZGRpdGlvbmFsIGVudGVyIHRyYW5zaXRpb24uIEhvd2V2ZXIsIGluIHRoZVxuICAgKiA+IGA8Q1NTVHJhbnNpdGlvbj5gIGNvbXBvbmVudCB0aGF0IGZpcnN0IGVudGVyIHRyYW5zaXRpb24gZG9lcyByZXN1bHQgaW5cbiAgICogPiBhZGRpdGlvbmFsIGAuYXBwZWFyLSpgIGNsYXNzZXMsIHRoYXQgd2F5IHlvdSBjYW4gY2hvb3NlIHRvIHN0eWxlIGl0XG4gICAqID4gZGlmZmVyZW50bHkuXG4gICAqL1xuICBhcHBlYXI6IFByb3BUeXBlcy5ib29sLFxuXG4gIC8qKlxuICAgKiBFbmFibGUgb3IgZGlzYWJsZSBlbnRlciB0cmFuc2l0aW9ucy5cbiAgICovXG4gIGVudGVyOiBQcm9wVHlwZXMuYm9vbCxcblxuICAvKipcbiAgICogRW5hYmxlIG9yIGRpc2FibGUgZXhpdCB0cmFuc2l0aW9ucy5cbiAgICovXG4gIGV4aXQ6IFByb3BUeXBlcy5ib29sLFxuXG4gIC8qKlxuICAgKiBUaGUgZHVyYXRpb24gb2YgdGhlIHRyYW5zaXRpb24sIGluIG1pbGxpc2Vjb25kcy5cbiAgICogUmVxdWlyZWQgdW5sZXNzIGBhZGRFbmRMaXN0ZW5lcmAgaXMgcHJvdmlkZWQuXG4gICAqXG4gICAqIFlvdSBtYXkgc3BlY2lmeSBhIHNpbmdsZSB0aW1lb3V0IGZvciBhbGwgdHJhbnNpdGlvbnM6XG4gICAqXG4gICAqIGBgYGpzeFxuICAgKiB0aW1lb3V0PXs1MDB9XG4gICAqIGBgYFxuICAgKlxuICAgKiBvciBpbmRpdmlkdWFsbHk6XG4gICAqXG4gICAqIGBgYGpzeFxuICAgKiB0aW1lb3V0PXt7XG4gICAqICBhcHBlYXI6IDUwMCxcbiAgICogIGVudGVyOiAzMDAsXG4gICAqICBleGl0OiA1MDAsXG4gICAqIH19XG4gICAqIGBgYFxuICAgKlxuICAgKiAtIGBhcHBlYXJgIGRlZmF1bHRzIHRvIHRoZSB2YWx1ZSBvZiBgZW50ZXJgXG4gICAqIC0gYGVudGVyYCBkZWZhdWx0cyB0byBgMGBcbiAgICogLSBgZXhpdGAgZGVmYXVsdHMgdG8gYDBgXG4gICAqXG4gICAqIEB0eXBlIHtudW1iZXIgfCB7IGVudGVyPzogbnVtYmVyLCBleGl0PzogbnVtYmVyLCBhcHBlYXI/OiBudW1iZXIgfX1cbiAgICovXG4gIHRpbWVvdXQ6IGZ1bmN0aW9uIHRpbWVvdXQocHJvcHMpIHtcbiAgICB2YXIgcHQgPSB0aW1lb3V0c1NoYXBlO1xuICAgIGlmICghcHJvcHMuYWRkRW5kTGlzdGVuZXIpIHB0ID0gcHQuaXNSZXF1aXJlZDtcblxuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIHJldHVybiBwdC5hcHBseSh2b2lkIDAsIFtwcm9wc10uY29uY2F0KGFyZ3MpKTtcbiAgfSxcblxuICAvKipcbiAgICogQWRkIGEgY3VzdG9tIHRyYW5zaXRpb24gZW5kIHRyaWdnZXIuIENhbGxlZCB3aXRoIHRoZSB0cmFuc2l0aW9uaW5nXG4gICAqIERPTSBub2RlIGFuZCBhIGBkb25lYCBjYWxsYmFjay4gQWxsb3dzIGZvciBtb3JlIGZpbmUgZ3JhaW5lZCB0cmFuc2l0aW9uIGVuZFxuICAgKiBsb2dpYy4gVGltZW91dHMgYXJlIHN0aWxsIHVzZWQgYXMgYSBmYWxsYmFjayBpZiBwcm92aWRlZC5cbiAgICpcbiAgICogKipOb3RlKio6IHdoZW4gYG5vZGVSZWZgIHByb3AgaXMgcGFzc2VkLCBgbm9kZWAgaXMgbm90IHBhc3NlZC5cbiAgICpcbiAgICogYGBganN4XG4gICAqIGFkZEVuZExpc3RlbmVyPXsobm9kZSwgZG9uZSkgPT4ge1xuICAgKiAgIC8vIHVzZSB0aGUgY3NzIHRyYW5zaXRpb25lbmQgZXZlbnQgdG8gbWFyayB0aGUgZmluaXNoIG9mIGEgdHJhbnNpdGlvblxuICAgKiAgIG5vZGUuYWRkRXZlbnRMaXN0ZW5lcigndHJhbnNpdGlvbmVuZCcsIGRvbmUsIGZhbHNlKTtcbiAgICogfX1cbiAgICogYGBgXG4gICAqL1xuICBhZGRFbmRMaXN0ZW5lcjogUHJvcFR5cGVzLmZ1bmMsXG5cbiAgLyoqXG4gICAqIENhbGxiYWNrIGZpcmVkIGJlZm9yZSB0aGUgXCJlbnRlcmluZ1wiIHN0YXR1cyBpcyBhcHBsaWVkLiBBbiBleHRyYSBwYXJhbWV0ZXJcbiAgICogYGlzQXBwZWFyaW5nYCBpcyBzdXBwbGllZCB0byBpbmRpY2F0ZSBpZiB0aGUgZW50ZXIgc3RhZ2UgaXMgb2NjdXJyaW5nIG9uIHRoZSBpbml0aWFsIG1vdW50XG4gICAqXG4gICAqICoqTm90ZSoqOiB3aGVuIGBub2RlUmVmYCBwcm9wIGlzIHBhc3NlZCwgYG5vZGVgIGlzIG5vdCBwYXNzZWQuXG4gICAqXG4gICAqIEB0eXBlIEZ1bmN0aW9uKG5vZGU6IEh0bWxFbGVtZW50LCBpc0FwcGVhcmluZzogYm9vbCkgLT4gdm9pZFxuICAgKi9cbiAgb25FbnRlcjogUHJvcFR5cGVzLmZ1bmMsXG5cbiAgLyoqXG4gICAqIENhbGxiYWNrIGZpcmVkIGFmdGVyIHRoZSBcImVudGVyaW5nXCIgc3RhdHVzIGlzIGFwcGxpZWQuIEFuIGV4dHJhIHBhcmFtZXRlclxuICAgKiBgaXNBcHBlYXJpbmdgIGlzIHN1cHBsaWVkIHRvIGluZGljYXRlIGlmIHRoZSBlbnRlciBzdGFnZSBpcyBvY2N1cnJpbmcgb24gdGhlIGluaXRpYWwgbW91bnRcbiAgICpcbiAgICogKipOb3RlKio6IHdoZW4gYG5vZGVSZWZgIHByb3AgaXMgcGFzc2VkLCBgbm9kZWAgaXMgbm90IHBhc3NlZC5cbiAgICpcbiAgICogQHR5cGUgRnVuY3Rpb24obm9kZTogSHRtbEVsZW1lbnQsIGlzQXBwZWFyaW5nOiBib29sKVxuICAgKi9cbiAgb25FbnRlcmluZzogUHJvcFR5cGVzLmZ1bmMsXG5cbiAgLyoqXG4gICAqIENhbGxiYWNrIGZpcmVkIGFmdGVyIHRoZSBcImVudGVyZWRcIiBzdGF0dXMgaXMgYXBwbGllZC4gQW4gZXh0cmEgcGFyYW1ldGVyXG4gICAqIGBpc0FwcGVhcmluZ2AgaXMgc3VwcGxpZWQgdG8gaW5kaWNhdGUgaWYgdGhlIGVudGVyIHN0YWdlIGlzIG9jY3VycmluZyBvbiB0aGUgaW5pdGlhbCBtb3VudFxuICAgKlxuICAgKiAqKk5vdGUqKjogd2hlbiBgbm9kZVJlZmAgcHJvcCBpcyBwYXNzZWQsIGBub2RlYCBpcyBub3QgcGFzc2VkLlxuICAgKlxuICAgKiBAdHlwZSBGdW5jdGlvbihub2RlOiBIdG1sRWxlbWVudCwgaXNBcHBlYXJpbmc6IGJvb2wpIC0+IHZvaWRcbiAgICovXG4gIG9uRW50ZXJlZDogUHJvcFR5cGVzLmZ1bmMsXG5cbiAgLyoqXG4gICAqIENhbGxiYWNrIGZpcmVkIGJlZm9yZSB0aGUgXCJleGl0aW5nXCIgc3RhdHVzIGlzIGFwcGxpZWQuXG4gICAqXG4gICAqICoqTm90ZSoqOiB3aGVuIGBub2RlUmVmYCBwcm9wIGlzIHBhc3NlZCwgYG5vZGVgIGlzIG5vdCBwYXNzZWQuXG4gICAqXG4gICAqIEB0eXBlIEZ1bmN0aW9uKG5vZGU6IEh0bWxFbGVtZW50KSAtPiB2b2lkXG4gICAqL1xuICBvbkV4aXQ6IFByb3BUeXBlcy5mdW5jLFxuXG4gIC8qKlxuICAgKiBDYWxsYmFjayBmaXJlZCBhZnRlciB0aGUgXCJleGl0aW5nXCIgc3RhdHVzIGlzIGFwcGxpZWQuXG4gICAqXG4gICAqICoqTm90ZSoqOiB3aGVuIGBub2RlUmVmYCBwcm9wIGlzIHBhc3NlZCwgYG5vZGVgIGlzIG5vdCBwYXNzZWQuXG4gICAqXG4gICAqIEB0eXBlIEZ1bmN0aW9uKG5vZGU6IEh0bWxFbGVtZW50KSAtPiB2b2lkXG4gICAqL1xuICBvbkV4aXRpbmc6IFByb3BUeXBlcy5mdW5jLFxuXG4gIC8qKlxuICAgKiBDYWxsYmFjayBmaXJlZCBhZnRlciB0aGUgXCJleGl0ZWRcIiBzdGF0dXMgaXMgYXBwbGllZC5cbiAgICpcbiAgICogKipOb3RlKio6IHdoZW4gYG5vZGVSZWZgIHByb3AgaXMgcGFzc2VkLCBgbm9kZWAgaXMgbm90IHBhc3NlZFxuICAgKlxuICAgKiBAdHlwZSBGdW5jdGlvbihub2RlOiBIdG1sRWxlbWVudCkgLT4gdm9pZFxuICAgKi9cbiAgb25FeGl0ZWQ6IFByb3BUeXBlcy5mdW5jXG59IDoge307IC8vIE5hbWUgdGhlIGZ1bmN0aW9uIHNvIGl0IGlzIGNsZWFyZXIgaW4gdGhlIGRvY3VtZW50YXRpb25cblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cblRyYW5zaXRpb24uZGVmYXVsdFByb3BzID0ge1xuICBpbjogZmFsc2UsXG4gIG1vdW50T25FbnRlcjogZmFsc2UsXG4gIHVubW91bnRPbkV4aXQ6IGZhbHNlLFxuICBhcHBlYXI6IGZhbHNlLFxuICBlbnRlcjogdHJ1ZSxcbiAgZXhpdDogdHJ1ZSxcbiAgb25FbnRlcjogbm9vcCxcbiAgb25FbnRlcmluZzogbm9vcCxcbiAgb25FbnRlcmVkOiBub29wLFxuICBvbkV4aXQ6IG5vb3AsXG4gIG9uRXhpdGluZzogbm9vcCxcbiAgb25FeGl0ZWQ6IG5vb3Bcbn07XG5UcmFuc2l0aW9uLlVOTU9VTlRFRCA9IFVOTU9VTlRFRDtcblRyYW5zaXRpb24uRVhJVEVEID0gRVhJVEVEO1xuVHJhbnNpdGlvbi5FTlRFUklORyA9IEVOVEVSSU5HO1xuVHJhbnNpdGlvbi5FTlRFUkVEID0gRU5URVJFRDtcblRyYW5zaXRpb24uRVhJVElORyA9IEVYSVRJTkc7XG5leHBvcnQgZGVmYXVsdCBUcmFuc2l0aW9uOyIsImltcG9ydCBfZXh0ZW5kcyBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vZXh0ZW5kc1wiO1xuaW1wb3J0IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlXCI7XG5pbXBvcnQgX2luaGVyaXRzTG9vc2UgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2luaGVyaXRzTG9vc2VcIjtcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgYWRkT25lQ2xhc3MgZnJvbSAnZG9tLWhlbHBlcnMvYWRkQ2xhc3MnO1xuaW1wb3J0IHJlbW92ZU9uZUNsYXNzIGZyb20gJ2RvbS1oZWxwZXJzL3JlbW92ZUNsYXNzJztcbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgVHJhbnNpdGlvbiBmcm9tICcuL1RyYW5zaXRpb24nO1xuaW1wb3J0IHsgY2xhc3NOYW1lc1NoYXBlIH0gZnJvbSAnLi91dGlscy9Qcm9wVHlwZXMnO1xuXG52YXIgX2FkZENsYXNzID0gZnVuY3Rpb24gYWRkQ2xhc3Mobm9kZSwgY2xhc3Nlcykge1xuICByZXR1cm4gbm9kZSAmJiBjbGFzc2VzICYmIGNsYXNzZXMuc3BsaXQoJyAnKS5mb3JFYWNoKGZ1bmN0aW9uIChjKSB7XG4gICAgcmV0dXJuIGFkZE9uZUNsYXNzKG5vZGUsIGMpO1xuICB9KTtcbn07XG5cbnZhciByZW1vdmVDbGFzcyA9IGZ1bmN0aW9uIHJlbW92ZUNsYXNzKG5vZGUsIGNsYXNzZXMpIHtcbiAgcmV0dXJuIG5vZGUgJiYgY2xhc3NlcyAmJiBjbGFzc2VzLnNwbGl0KCcgJykuZm9yRWFjaChmdW5jdGlvbiAoYykge1xuICAgIHJldHVybiByZW1vdmVPbmVDbGFzcyhub2RlLCBjKTtcbiAgfSk7XG59O1xuLyoqXG4gKiBBIHRyYW5zaXRpb24gY29tcG9uZW50IGluc3BpcmVkIGJ5IHRoZSBleGNlbGxlbnRcbiAqIFtuZy1hbmltYXRlXShodHRwczovL2RvY3MuYW5ndWxhcmpzLm9yZy9hcGkvbmdBbmltYXRlKSBsaWJyYXJ5LCB5b3Ugc2hvdWxkXG4gKiB1c2UgaXQgaWYgeW91J3JlIHVzaW5nIENTUyB0cmFuc2l0aW9ucyBvciBhbmltYXRpb25zLiBJdCdzIGJ1aWx0IHVwb24gdGhlXG4gKiBbYFRyYW5zaXRpb25gXShodHRwczovL3JlYWN0Y29tbXVuaXR5Lm9yZy9yZWFjdC10cmFuc2l0aW9uLWdyb3VwL3RyYW5zaXRpb24pXG4gKiBjb21wb25lbnQsIHNvIGl0IGluaGVyaXRzIGFsbCBvZiBpdHMgcHJvcHMuXG4gKlxuICogYENTU1RyYW5zaXRpb25gIGFwcGxpZXMgYSBwYWlyIG9mIGNsYXNzIG5hbWVzIGR1cmluZyB0aGUgYGFwcGVhcmAsIGBlbnRlcmAsXG4gKiBhbmQgYGV4aXRgIHN0YXRlcyBvZiB0aGUgdHJhbnNpdGlvbi4gVGhlIGZpcnN0IGNsYXNzIGlzIGFwcGxpZWQgYW5kIHRoZW4gYVxuICogc2Vjb25kIGAqLWFjdGl2ZWAgY2xhc3MgaW4gb3JkZXIgdG8gYWN0aXZhdGUgdGhlIENTUyB0cmFuc2l0aW9uLiBBZnRlciB0aGVcbiAqIHRyYW5zaXRpb24sIG1hdGNoaW5nIGAqLWRvbmVgIGNsYXNzIG5hbWVzIGFyZSBhcHBsaWVkIHRvIHBlcnNpc3QgdGhlXG4gKiB0cmFuc2l0aW9uIHN0YXRlLlxuICpcbiAqIGBgYGpzeFxuICogZnVuY3Rpb24gQXBwKCkge1xuICogICBjb25zdCBbaW5Qcm9wLCBzZXRJblByb3BdID0gdXNlU3RhdGUoZmFsc2UpO1xuICogICByZXR1cm4gKFxuICogICAgIDxkaXY+XG4gKiAgICAgICA8Q1NTVHJhbnNpdGlvbiBpbj17aW5Qcm9wfSB0aW1lb3V0PXsyMDB9IGNsYXNzTmFtZXM9XCJteS1ub2RlXCI+XG4gKiAgICAgICAgIDxkaXY+XG4gKiAgICAgICAgICAge1wiSSdsbCByZWNlaXZlIG15LW5vZGUtKiBjbGFzc2VzXCJ9XG4gKiAgICAgICAgIDwvZGl2PlxuICogICAgICAgPC9DU1NUcmFuc2l0aW9uPlxuICogICAgICAgPGJ1dHRvbiB0eXBlPVwiYnV0dG9uXCIgb25DbGljaz17KCkgPT4gc2V0SW5Qcm9wKHRydWUpfT5cbiAqICAgICAgICAgQ2xpY2sgdG8gRW50ZXJcbiAqICAgICAgIDwvYnV0dG9uPlxuICogICAgIDwvZGl2PlxuICogICApO1xuICogfVxuICogYGBgXG4gKlxuICogV2hlbiB0aGUgYGluYCBwcm9wIGlzIHNldCB0byBgdHJ1ZWAsIHRoZSBjaGlsZCBjb21wb25lbnQgd2lsbCBmaXJzdCByZWNlaXZlXG4gKiB0aGUgY2xhc3MgYGV4YW1wbGUtZW50ZXJgLCB0aGVuIHRoZSBgZXhhbXBsZS1lbnRlci1hY3RpdmVgIHdpbGwgYmUgYWRkZWQgaW5cbiAqIHRoZSBuZXh0IHRpY2suIGBDU1NUcmFuc2l0aW9uYCBbZm9yY2VzIGFcbiAqIHJlZmxvd10oaHR0cHM6Ly9naXRodWIuY29tL3JlYWN0anMvcmVhY3QtdHJhbnNpdGlvbi1ncm91cC9ibG9iLzUwMDczMDNlNzI5YTc0YmU2NmEyMWMzZTIyMDVlNDkxNjgyMTUyNGIvc3JjL0NTU1RyYW5zaXRpb24uanMjTDIwOC1MMjE1KVxuICogYmV0d2VlbiBiZWZvcmUgYWRkaW5nIHRoZSBgZXhhbXBsZS1lbnRlci1hY3RpdmVgLiBUaGlzIGlzIGFuIGltcG9ydGFudCB0cmlja1xuICogYmVjYXVzZSBpdCBhbGxvd3MgdXMgdG8gdHJhbnNpdGlvbiBiZXR3ZWVuIGBleGFtcGxlLWVudGVyYCBhbmRcbiAqIGBleGFtcGxlLWVudGVyLWFjdGl2ZWAgZXZlbiB0aG91Z2ggdGhleSB3ZXJlIGFkZGVkIGltbWVkaWF0ZWx5IG9uZSBhZnRlclxuICogYW5vdGhlci4gTW9zdCBub3RhYmx5LCB0aGlzIGlzIHdoYXQgbWFrZXMgaXQgcG9zc2libGUgZm9yIHVzIHRvIGFuaW1hdGVcbiAqIF9hcHBlYXJhbmNlXy5cbiAqXG4gKiBgYGBjc3NcbiAqIC5teS1ub2RlLWVudGVyIHtcbiAqICAgb3BhY2l0eTogMDtcbiAqIH1cbiAqIC5teS1ub2RlLWVudGVyLWFjdGl2ZSB7XG4gKiAgIG9wYWNpdHk6IDE7XG4gKiAgIHRyYW5zaXRpb246IG9wYWNpdHkgMjAwbXM7XG4gKiB9XG4gKiAubXktbm9kZS1leGl0IHtcbiAqICAgb3BhY2l0eTogMTtcbiAqIH1cbiAqIC5teS1ub2RlLWV4aXQtYWN0aXZlIHtcbiAqICAgb3BhY2l0eTogMDtcbiAqICAgdHJhbnNpdGlvbjogb3BhY2l0eSAyMDBtcztcbiAqIH1cbiAqIGBgYFxuICpcbiAqIGAqLWFjdGl2ZWAgY2xhc3NlcyByZXByZXNlbnQgd2hpY2ggc3R5bGVzIHlvdSB3YW50IHRvIGFuaW1hdGUgKip0byoqLCBzbyBpdCdzXG4gKiBpbXBvcnRhbnQgdG8gYWRkIGB0cmFuc2l0aW9uYCBkZWNsYXJhdGlvbiBvbmx5IHRvIHRoZW0sIG90aGVyd2lzZSB0cmFuc2l0aW9uc1xuICogbWlnaHQgbm90IGJlaGF2ZSBhcyBpbnRlbmRlZCEgVGhpcyBtaWdodCBub3QgYmUgb2J2aW91cyB3aGVuIHRoZSB0cmFuc2l0aW9uc1xuICogYXJlIHN5bW1ldHJpY2FsLCBpLmUuIHdoZW4gYCotZW50ZXItYWN0aXZlYCBpcyB0aGUgc2FtZSBhcyBgKi1leGl0YCwgbGlrZSBpblxuICogdGhlIGV4YW1wbGUgYWJvdmUgKG1pbnVzIGB0cmFuc2l0aW9uYCksIGJ1dCBpdCBiZWNvbWVzIGFwcGFyZW50IGluIG1vcmVcbiAqIGNvbXBsZXggdHJhbnNpdGlvbnMuXG4gKlxuICogKipOb3RlKio6IElmIHlvdSdyZSB1c2luZyB0aGVcbiAqIFtgYXBwZWFyYF0oaHR0cDovL3JlYWN0Y29tbXVuaXR5Lm9yZy9yZWFjdC10cmFuc2l0aW9uLWdyb3VwL3RyYW5zaXRpb24jVHJhbnNpdGlvbi1wcm9wLWFwcGVhcilcbiAqIHByb3AsIG1ha2Ugc3VyZSB0byBkZWZpbmUgc3R5bGVzIGZvciBgLmFwcGVhci0qYCBjbGFzc2VzIGFzIHdlbGwuXG4gKi9cblxuXG52YXIgQ1NTVHJhbnNpdGlvbiA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX1JlYWN0JENvbXBvbmVudCkge1xuICBfaW5oZXJpdHNMb29zZShDU1NUcmFuc2l0aW9uLCBfUmVhY3QkQ29tcG9uZW50KTtcblxuICBmdW5jdGlvbiBDU1NUcmFuc2l0aW9uKCkge1xuICAgIHZhciBfdGhpcztcblxuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICBfdGhpcyA9IF9SZWFjdCRDb21wb25lbnQuY2FsbC5hcHBseShfUmVhY3QkQ29tcG9uZW50LCBbdGhpc10uY29uY2F0KGFyZ3MpKSB8fCB0aGlzO1xuICAgIF90aGlzLmFwcGxpZWRDbGFzc2VzID0ge1xuICAgICAgYXBwZWFyOiB7fSxcbiAgICAgIGVudGVyOiB7fSxcbiAgICAgIGV4aXQ6IHt9XG4gICAgfTtcblxuICAgIF90aGlzLm9uRW50ZXIgPSBmdW5jdGlvbiAobWF5YmVOb2RlLCBtYXliZUFwcGVhcmluZykge1xuICAgICAgdmFyIF90aGlzJHJlc29sdmVBcmd1bWVudCA9IF90aGlzLnJlc29sdmVBcmd1bWVudHMobWF5YmVOb2RlLCBtYXliZUFwcGVhcmluZyksXG4gICAgICAgICAgbm9kZSA9IF90aGlzJHJlc29sdmVBcmd1bWVudFswXSxcbiAgICAgICAgICBhcHBlYXJpbmcgPSBfdGhpcyRyZXNvbHZlQXJndW1lbnRbMV07XG5cbiAgICAgIF90aGlzLnJlbW92ZUNsYXNzZXMobm9kZSwgJ2V4aXQnKTtcblxuICAgICAgX3RoaXMuYWRkQ2xhc3Mobm9kZSwgYXBwZWFyaW5nID8gJ2FwcGVhcicgOiAnZW50ZXInLCAnYmFzZScpO1xuXG4gICAgICBpZiAoX3RoaXMucHJvcHMub25FbnRlcikge1xuICAgICAgICBfdGhpcy5wcm9wcy5vbkVudGVyKG1heWJlTm9kZSwgbWF5YmVBcHBlYXJpbmcpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBfdGhpcy5vbkVudGVyaW5nID0gZnVuY3Rpb24gKG1heWJlTm9kZSwgbWF5YmVBcHBlYXJpbmcpIHtcbiAgICAgIHZhciBfdGhpcyRyZXNvbHZlQXJndW1lbnQyID0gX3RoaXMucmVzb2x2ZUFyZ3VtZW50cyhtYXliZU5vZGUsIG1heWJlQXBwZWFyaW5nKSxcbiAgICAgICAgICBub2RlID0gX3RoaXMkcmVzb2x2ZUFyZ3VtZW50MlswXSxcbiAgICAgICAgICBhcHBlYXJpbmcgPSBfdGhpcyRyZXNvbHZlQXJndW1lbnQyWzFdO1xuXG4gICAgICB2YXIgdHlwZSA9IGFwcGVhcmluZyA/ICdhcHBlYXInIDogJ2VudGVyJztcblxuICAgICAgX3RoaXMuYWRkQ2xhc3Mobm9kZSwgdHlwZSwgJ2FjdGl2ZScpO1xuXG4gICAgICBpZiAoX3RoaXMucHJvcHMub25FbnRlcmluZykge1xuICAgICAgICBfdGhpcy5wcm9wcy5vbkVudGVyaW5nKG1heWJlTm9kZSwgbWF5YmVBcHBlYXJpbmcpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBfdGhpcy5vbkVudGVyZWQgPSBmdW5jdGlvbiAobWF5YmVOb2RlLCBtYXliZUFwcGVhcmluZykge1xuICAgICAgdmFyIF90aGlzJHJlc29sdmVBcmd1bWVudDMgPSBfdGhpcy5yZXNvbHZlQXJndW1lbnRzKG1heWJlTm9kZSwgbWF5YmVBcHBlYXJpbmcpLFxuICAgICAgICAgIG5vZGUgPSBfdGhpcyRyZXNvbHZlQXJndW1lbnQzWzBdLFxuICAgICAgICAgIGFwcGVhcmluZyA9IF90aGlzJHJlc29sdmVBcmd1bWVudDNbMV07XG5cbiAgICAgIHZhciB0eXBlID0gYXBwZWFyaW5nID8gJ2FwcGVhcicgOiAnZW50ZXInO1xuXG4gICAgICBfdGhpcy5yZW1vdmVDbGFzc2VzKG5vZGUsIHR5cGUpO1xuXG4gICAgICBfdGhpcy5hZGRDbGFzcyhub2RlLCB0eXBlLCAnZG9uZScpO1xuXG4gICAgICBpZiAoX3RoaXMucHJvcHMub25FbnRlcmVkKSB7XG4gICAgICAgIF90aGlzLnByb3BzLm9uRW50ZXJlZChtYXliZU5vZGUsIG1heWJlQXBwZWFyaW5nKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgX3RoaXMub25FeGl0ID0gZnVuY3Rpb24gKG1heWJlTm9kZSkge1xuICAgICAgdmFyIF90aGlzJHJlc29sdmVBcmd1bWVudDQgPSBfdGhpcy5yZXNvbHZlQXJndW1lbnRzKG1heWJlTm9kZSksXG4gICAgICAgICAgbm9kZSA9IF90aGlzJHJlc29sdmVBcmd1bWVudDRbMF07XG5cbiAgICAgIF90aGlzLnJlbW92ZUNsYXNzZXMobm9kZSwgJ2FwcGVhcicpO1xuXG4gICAgICBfdGhpcy5yZW1vdmVDbGFzc2VzKG5vZGUsICdlbnRlcicpO1xuXG4gICAgICBfdGhpcy5hZGRDbGFzcyhub2RlLCAnZXhpdCcsICdiYXNlJyk7XG5cbiAgICAgIGlmIChfdGhpcy5wcm9wcy5vbkV4aXQpIHtcbiAgICAgICAgX3RoaXMucHJvcHMub25FeGl0KG1heWJlTm9kZSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIF90aGlzLm9uRXhpdGluZyA9IGZ1bmN0aW9uIChtYXliZU5vZGUpIHtcbiAgICAgIHZhciBfdGhpcyRyZXNvbHZlQXJndW1lbnQ1ID0gX3RoaXMucmVzb2x2ZUFyZ3VtZW50cyhtYXliZU5vZGUpLFxuICAgICAgICAgIG5vZGUgPSBfdGhpcyRyZXNvbHZlQXJndW1lbnQ1WzBdO1xuXG4gICAgICBfdGhpcy5hZGRDbGFzcyhub2RlLCAnZXhpdCcsICdhY3RpdmUnKTtcblxuICAgICAgaWYgKF90aGlzLnByb3BzLm9uRXhpdGluZykge1xuICAgICAgICBfdGhpcy5wcm9wcy5vbkV4aXRpbmcobWF5YmVOb2RlKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgX3RoaXMub25FeGl0ZWQgPSBmdW5jdGlvbiAobWF5YmVOb2RlKSB7XG4gICAgICB2YXIgX3RoaXMkcmVzb2x2ZUFyZ3VtZW50NiA9IF90aGlzLnJlc29sdmVBcmd1bWVudHMobWF5YmVOb2RlKSxcbiAgICAgICAgICBub2RlID0gX3RoaXMkcmVzb2x2ZUFyZ3VtZW50NlswXTtcblxuICAgICAgX3RoaXMucmVtb3ZlQ2xhc3Nlcyhub2RlLCAnZXhpdCcpO1xuXG4gICAgICBfdGhpcy5hZGRDbGFzcyhub2RlLCAnZXhpdCcsICdkb25lJyk7XG5cbiAgICAgIGlmIChfdGhpcy5wcm9wcy5vbkV4aXRlZCkge1xuICAgICAgICBfdGhpcy5wcm9wcy5vbkV4aXRlZChtYXliZU5vZGUpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBfdGhpcy5yZXNvbHZlQXJndW1lbnRzID0gZnVuY3Rpb24gKG1heWJlTm9kZSwgbWF5YmVBcHBlYXJpbmcpIHtcbiAgICAgIHJldHVybiBfdGhpcy5wcm9wcy5ub2RlUmVmID8gW190aGlzLnByb3BzLm5vZGVSZWYuY3VycmVudCwgbWF5YmVOb2RlXSAvLyBoZXJlIGBtYXliZU5vZGVgIGlzIGFjdHVhbGx5IGBhcHBlYXJpbmdgXG4gICAgICA6IFttYXliZU5vZGUsIG1heWJlQXBwZWFyaW5nXTtcbiAgICB9O1xuXG4gICAgX3RoaXMuZ2V0Q2xhc3NOYW1lcyA9IGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICB2YXIgY2xhc3NOYW1lcyA9IF90aGlzLnByb3BzLmNsYXNzTmFtZXM7XG4gICAgICB2YXIgaXNTdHJpbmdDbGFzc05hbWVzID0gdHlwZW9mIGNsYXNzTmFtZXMgPT09ICdzdHJpbmcnO1xuICAgICAgdmFyIHByZWZpeCA9IGlzU3RyaW5nQ2xhc3NOYW1lcyAmJiBjbGFzc05hbWVzID8gY2xhc3NOYW1lcyArIFwiLVwiIDogJyc7XG4gICAgICB2YXIgYmFzZUNsYXNzTmFtZSA9IGlzU3RyaW5nQ2xhc3NOYW1lcyA/IFwiXCIgKyBwcmVmaXggKyB0eXBlIDogY2xhc3NOYW1lc1t0eXBlXTtcbiAgICAgIHZhciBhY3RpdmVDbGFzc05hbWUgPSBpc1N0cmluZ0NsYXNzTmFtZXMgPyBiYXNlQ2xhc3NOYW1lICsgXCItYWN0aXZlXCIgOiBjbGFzc05hbWVzW3R5cGUgKyBcIkFjdGl2ZVwiXTtcbiAgICAgIHZhciBkb25lQ2xhc3NOYW1lID0gaXNTdHJpbmdDbGFzc05hbWVzID8gYmFzZUNsYXNzTmFtZSArIFwiLWRvbmVcIiA6IGNsYXNzTmFtZXNbdHlwZSArIFwiRG9uZVwiXTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGJhc2VDbGFzc05hbWU6IGJhc2VDbGFzc05hbWUsXG4gICAgICAgIGFjdGl2ZUNsYXNzTmFtZTogYWN0aXZlQ2xhc3NOYW1lLFxuICAgICAgICBkb25lQ2xhc3NOYW1lOiBkb25lQ2xhc3NOYW1lXG4gICAgICB9O1xuICAgIH07XG5cbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICB2YXIgX3Byb3RvID0gQ1NTVHJhbnNpdGlvbi5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLmFkZENsYXNzID0gZnVuY3Rpb24gYWRkQ2xhc3Mobm9kZSwgdHlwZSwgcGhhc2UpIHtcbiAgICB2YXIgY2xhc3NOYW1lID0gdGhpcy5nZXRDbGFzc05hbWVzKHR5cGUpW3BoYXNlICsgXCJDbGFzc05hbWVcIl07XG5cbiAgICB2YXIgX3RoaXMkZ2V0Q2xhc3NOYW1lcyA9IHRoaXMuZ2V0Q2xhc3NOYW1lcygnZW50ZXInKSxcbiAgICAgICAgZG9uZUNsYXNzTmFtZSA9IF90aGlzJGdldENsYXNzTmFtZXMuZG9uZUNsYXNzTmFtZTtcblxuICAgIGlmICh0eXBlID09PSAnYXBwZWFyJyAmJiBwaGFzZSA9PT0gJ2RvbmUnICYmIGRvbmVDbGFzc05hbWUpIHtcbiAgICAgIGNsYXNzTmFtZSArPSBcIiBcIiArIGRvbmVDbGFzc05hbWU7XG4gICAgfSAvLyBUaGlzIGlzIHRvIGZvcmNlIGEgcmVwYWludCxcbiAgICAvLyB3aGljaCBpcyBuZWNlc3NhcnkgaW4gb3JkZXIgdG8gdHJhbnNpdGlvbiBzdHlsZXMgd2hlbiBhZGRpbmcgYSBjbGFzcyBuYW1lLlxuXG5cbiAgICBpZiAocGhhc2UgPT09ICdhY3RpdmUnKSB7XG4gICAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby11bnVzZWQtZXhwcmVzc2lvbnMgKi9cbiAgICAgIG5vZGUgJiYgbm9kZS5zY3JvbGxUb3A7XG4gICAgfVxuXG4gICAgaWYgKGNsYXNzTmFtZSkge1xuICAgICAgdGhpcy5hcHBsaWVkQ2xhc3Nlc1t0eXBlXVtwaGFzZV0gPSBjbGFzc05hbWU7XG5cbiAgICAgIF9hZGRDbGFzcyhub2RlLCBjbGFzc05hbWUpO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8ucmVtb3ZlQ2xhc3NlcyA9IGZ1bmN0aW9uIHJlbW92ZUNsYXNzZXMobm9kZSwgdHlwZSkge1xuICAgIHZhciBfdGhpcyRhcHBsaWVkQ2xhc3NlcyQgPSB0aGlzLmFwcGxpZWRDbGFzc2VzW3R5cGVdLFxuICAgICAgICBiYXNlQ2xhc3NOYW1lID0gX3RoaXMkYXBwbGllZENsYXNzZXMkLmJhc2UsXG4gICAgICAgIGFjdGl2ZUNsYXNzTmFtZSA9IF90aGlzJGFwcGxpZWRDbGFzc2VzJC5hY3RpdmUsXG4gICAgICAgIGRvbmVDbGFzc05hbWUgPSBfdGhpcyRhcHBsaWVkQ2xhc3NlcyQuZG9uZTtcbiAgICB0aGlzLmFwcGxpZWRDbGFzc2VzW3R5cGVdID0ge307XG5cbiAgICBpZiAoYmFzZUNsYXNzTmFtZSkge1xuICAgICAgcmVtb3ZlQ2xhc3Mobm9kZSwgYmFzZUNsYXNzTmFtZSk7XG4gICAgfVxuXG4gICAgaWYgKGFjdGl2ZUNsYXNzTmFtZSkge1xuICAgICAgcmVtb3ZlQ2xhc3Mobm9kZSwgYWN0aXZlQ2xhc3NOYW1lKTtcbiAgICB9XG5cbiAgICBpZiAoZG9uZUNsYXNzTmFtZSkge1xuICAgICAgcmVtb3ZlQ2xhc3Mobm9kZSwgZG9uZUNsYXNzTmFtZSk7XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgdmFyIF90aGlzJHByb3BzID0gdGhpcy5wcm9wcyxcbiAgICAgICAgXyA9IF90aGlzJHByb3BzLmNsYXNzTmFtZXMsXG4gICAgICAgIHByb3BzID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UoX3RoaXMkcHJvcHMsIFtcImNsYXNzTmFtZXNcIl0pO1xuXG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFRyYW5zaXRpb24sIF9leHRlbmRzKHt9LCBwcm9wcywge1xuICAgICAgb25FbnRlcjogdGhpcy5vbkVudGVyLFxuICAgICAgb25FbnRlcmVkOiB0aGlzLm9uRW50ZXJlZCxcbiAgICAgIG9uRW50ZXJpbmc6IHRoaXMub25FbnRlcmluZyxcbiAgICAgIG9uRXhpdDogdGhpcy5vbkV4aXQsXG4gICAgICBvbkV4aXRpbmc6IHRoaXMub25FeGl0aW5nLFxuICAgICAgb25FeGl0ZWQ6IHRoaXMub25FeGl0ZWRcbiAgICB9KSk7XG4gIH07XG5cbiAgcmV0dXJuIENTU1RyYW5zaXRpb247XG59KFJlYWN0LkNvbXBvbmVudCk7XG5cbkNTU1RyYW5zaXRpb24uZGVmYXVsdFByb3BzID0ge1xuICBjbGFzc05hbWVzOiAnJ1xufTtcbkNTU1RyYW5zaXRpb24ucHJvcFR5cGVzID0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gX2V4dGVuZHMoe30sIFRyYW5zaXRpb24ucHJvcFR5cGVzLCB7XG4gIC8qKlxuICAgKiBUaGUgYW5pbWF0aW9uIGNsYXNzTmFtZXMgYXBwbGllZCB0byB0aGUgY29tcG9uZW50IGFzIGl0IGFwcGVhcnMsIGVudGVycyxcbiAgICogZXhpdHMgb3IgaGFzIGZpbmlzaGVkIHRoZSB0cmFuc2l0aW9uLiBBIHNpbmdsZSBuYW1lIGNhbiBiZSBwcm92aWRlZCwgd2hpY2hcbiAgICogd2lsbCBiZSBzdWZmaXhlZCBmb3IgZWFjaCBzdGFnZSwgZS5nLiBgY2xhc3NOYW1lcz1cImZhZGVcImAgYXBwbGllczpcbiAgICpcbiAgICogLSBgZmFkZS1hcHBlYXJgLCBgZmFkZS1hcHBlYXItYWN0aXZlYCwgYGZhZGUtYXBwZWFyLWRvbmVgXG4gICAqIC0gYGZhZGUtZW50ZXJgLCBgZmFkZS1lbnRlci1hY3RpdmVgLCBgZmFkZS1lbnRlci1kb25lYFxuICAgKiAtIGBmYWRlLWV4aXRgLCBgZmFkZS1leGl0LWFjdGl2ZWAsIGBmYWRlLWV4aXQtZG9uZWBcbiAgICpcbiAgICogQSBmZXcgZGV0YWlscyB0byBub3RlIGFib3V0IGhvdyB0aGVzZSBjbGFzc2VzIGFyZSBhcHBsaWVkOlxuICAgKlxuICAgKiAxLiBUaGV5IGFyZSBfam9pbmVkXyB3aXRoIHRoZSBvbmVzIHRoYXQgYXJlIGFscmVhZHkgZGVmaW5lZCBvbiB0aGUgY2hpbGRcbiAgICogICAgY29tcG9uZW50LCBzbyBpZiB5b3Ugd2FudCB0byBhZGQgc29tZSBiYXNlIHN0eWxlcywgeW91IGNhbiB1c2VcbiAgICogICAgYGNsYXNzTmFtZWAgd2l0aG91dCB3b3JyeWluZyB0aGF0IGl0IHdpbGwgYmUgb3ZlcnJpZGRlbi5cbiAgICpcbiAgICogMi4gSWYgdGhlIHRyYW5zaXRpb24gY29tcG9uZW50IG1vdW50cyB3aXRoIGBpbj17ZmFsc2V9YCwgbm8gY2xhc3NlcyBhcmVcbiAgICogICAgYXBwbGllZCB5ZXQuIFlvdSBtaWdodCBiZSBleHBlY3RpbmcgYCotZXhpdC1kb25lYCwgYnV0IGlmIHlvdSB0aGlua1xuICAgKiAgICBhYm91dCBpdCwgYSBjb21wb25lbnQgY2Fubm90IGZpbmlzaCBleGl0aW5nIGlmIGl0IGhhc24ndCBlbnRlcmVkIHlldC5cbiAgICpcbiAgICogMi4gYGZhZGUtYXBwZWFyLWRvbmVgIGFuZCBgZmFkZS1lbnRlci1kb25lYCB3aWxsIF9ib3RoXyBiZSBhcHBsaWVkLiBUaGlzXG4gICAqICAgIGFsbG93cyB5b3UgdG8gZGVmaW5lIGRpZmZlcmVudCBiZWhhdmlvciBmb3Igd2hlbiBhcHBlYXJpbmcgaXMgZG9uZSBhbmRcbiAgICogICAgd2hlbiByZWd1bGFyIGVudGVyaW5nIGlzIGRvbmUsIHVzaW5nIHNlbGVjdG9ycyBsaWtlXG4gICAqICAgIGAuZmFkZS1lbnRlci1kb25lOm5vdCguZmFkZS1hcHBlYXItZG9uZSlgLiBGb3IgZXhhbXBsZSwgeW91IGNvdWxkIGFwcGx5XG4gICAqICAgIGFuIGVwaWMgZW50cmFuY2UgYW5pbWF0aW9uIHdoZW4gZWxlbWVudCBmaXJzdCBhcHBlYXJzIGluIHRoZSBET00gdXNpbmdcbiAgICogICAgW0FuaW1hdGUuY3NzXShodHRwczovL2RhbmVkZW4uZ2l0aHViLmlvL2FuaW1hdGUuY3NzLykuIE90aGVyd2lzZSB5b3UgY2FuXG4gICAqICAgIHNpbXBseSB1c2UgYGZhZGUtZW50ZXItZG9uZWAgZm9yIGRlZmluaW5nIGJvdGggY2FzZXMuXG4gICAqXG4gICAqIEVhY2ggaW5kaXZpZHVhbCBjbGFzc05hbWVzIGNhbiBhbHNvIGJlIHNwZWNpZmllZCBpbmRlcGVuZGVudGx5IGxpa2U6XG4gICAqXG4gICAqIGBgYGpzXG4gICAqIGNsYXNzTmFtZXM9e3tcbiAgICogIGFwcGVhcjogJ215LWFwcGVhcicsXG4gICAqICBhcHBlYXJBY3RpdmU6ICdteS1hY3RpdmUtYXBwZWFyJyxcbiAgICogIGFwcGVhckRvbmU6ICdteS1kb25lLWFwcGVhcicsXG4gICAqICBlbnRlcjogJ215LWVudGVyJyxcbiAgICogIGVudGVyQWN0aXZlOiAnbXktYWN0aXZlLWVudGVyJyxcbiAgICogIGVudGVyRG9uZTogJ215LWRvbmUtZW50ZXInLFxuICAgKiAgZXhpdDogJ215LWV4aXQnLFxuICAgKiAgZXhpdEFjdGl2ZTogJ215LWFjdGl2ZS1leGl0JyxcbiAgICogIGV4aXREb25lOiAnbXktZG9uZS1leGl0JyxcbiAgICogfX1cbiAgICogYGBgXG4gICAqXG4gICAqIElmIHlvdSB3YW50IHRvIHNldCB0aGVzZSBjbGFzc2VzIHVzaW5nIENTUyBNb2R1bGVzOlxuICAgKlxuICAgKiBgYGBqc1xuICAgKiBpbXBvcnQgc3R5bGVzIGZyb20gJy4vc3R5bGVzLmNzcyc7XG4gICAqIGBgYFxuICAgKlxuICAgKiB5b3UgbWlnaHQgd2FudCB0byB1c2UgY2FtZWxDYXNlIGluIHlvdXIgQ1NTIGZpbGUsIHRoYXQgd2F5IGNvdWxkIHNpbXBseVxuICAgKiBzcHJlYWQgdGhlbSBpbnN0ZWFkIG9mIGxpc3RpbmcgdGhlbSBvbmUgYnkgb25lOlxuICAgKlxuICAgKiBgYGBqc1xuICAgKiBjbGFzc05hbWVzPXt7IC4uLnN0eWxlcyB9fVxuICAgKiBgYGBcbiAgICpcbiAgICogQHR5cGUge3N0cmluZyB8IHtcbiAgICogIGFwcGVhcj86IHN0cmluZyxcbiAgICogIGFwcGVhckFjdGl2ZT86IHN0cmluZyxcbiAgICogIGFwcGVhckRvbmU/OiBzdHJpbmcsXG4gICAqICBlbnRlcj86IHN0cmluZyxcbiAgICogIGVudGVyQWN0aXZlPzogc3RyaW5nLFxuICAgKiAgZW50ZXJEb25lPzogc3RyaW5nLFxuICAgKiAgZXhpdD86IHN0cmluZyxcbiAgICogIGV4aXRBY3RpdmU/OiBzdHJpbmcsXG4gICAqICBleGl0RG9uZT86IHN0cmluZyxcbiAgICogfX1cbiAgICovXG4gIGNsYXNzTmFtZXM6IGNsYXNzTmFtZXNTaGFwZSxcblxuICAvKipcbiAgICogQSBgPFRyYW5zaXRpb24+YCBjYWxsYmFjayBmaXJlZCBpbW1lZGlhdGVseSBhZnRlciB0aGUgJ2VudGVyJyBvciAnYXBwZWFyJyBjbGFzcyBpc1xuICAgKiBhcHBsaWVkLlxuICAgKlxuICAgKiAqKk5vdGUqKjogd2hlbiBgbm9kZVJlZmAgcHJvcCBpcyBwYXNzZWQsIGBub2RlYCBpcyBub3QgcGFzc2VkLlxuICAgKlxuICAgKiBAdHlwZSBGdW5jdGlvbihub2RlOiBIdG1sRWxlbWVudCwgaXNBcHBlYXJpbmc6IGJvb2wpXG4gICAqL1xuICBvbkVudGVyOiBQcm9wVHlwZXMuZnVuYyxcblxuICAvKipcbiAgICogQSBgPFRyYW5zaXRpb24+YCBjYWxsYmFjayBmaXJlZCBpbW1lZGlhdGVseSBhZnRlciB0aGUgJ2VudGVyLWFjdGl2ZScgb3JcbiAgICogJ2FwcGVhci1hY3RpdmUnIGNsYXNzIGlzIGFwcGxpZWQuXG4gICAqXG4gICAqICoqTm90ZSoqOiB3aGVuIGBub2RlUmVmYCBwcm9wIGlzIHBhc3NlZCwgYG5vZGVgIGlzIG5vdCBwYXNzZWQuXG4gICAqXG4gICAqIEB0eXBlIEZ1bmN0aW9uKG5vZGU6IEh0bWxFbGVtZW50LCBpc0FwcGVhcmluZzogYm9vbClcbiAgICovXG4gIG9uRW50ZXJpbmc6IFByb3BUeXBlcy5mdW5jLFxuXG4gIC8qKlxuICAgKiBBIGA8VHJhbnNpdGlvbj5gIGNhbGxiYWNrIGZpcmVkIGltbWVkaWF0ZWx5IGFmdGVyIHRoZSAnZW50ZXInIG9yXG4gICAqICdhcHBlYXInIGNsYXNzZXMgYXJlICoqcmVtb3ZlZCoqIGFuZCB0aGUgYGRvbmVgIGNsYXNzIGlzIGFkZGVkIHRvIHRoZSBET00gbm9kZS5cbiAgICpcbiAgICogKipOb3RlKio6IHdoZW4gYG5vZGVSZWZgIHByb3AgaXMgcGFzc2VkLCBgbm9kZWAgaXMgbm90IHBhc3NlZC5cbiAgICpcbiAgICogQHR5cGUgRnVuY3Rpb24obm9kZTogSHRtbEVsZW1lbnQsIGlzQXBwZWFyaW5nOiBib29sKVxuICAgKi9cbiAgb25FbnRlcmVkOiBQcm9wVHlwZXMuZnVuYyxcblxuICAvKipcbiAgICogQSBgPFRyYW5zaXRpb24+YCBjYWxsYmFjayBmaXJlZCBpbW1lZGlhdGVseSBhZnRlciB0aGUgJ2V4aXQnIGNsYXNzIGlzXG4gICAqIGFwcGxpZWQuXG4gICAqXG4gICAqICoqTm90ZSoqOiB3aGVuIGBub2RlUmVmYCBwcm9wIGlzIHBhc3NlZCwgYG5vZGVgIGlzIG5vdCBwYXNzZWRcbiAgICpcbiAgICogQHR5cGUgRnVuY3Rpb24obm9kZTogSHRtbEVsZW1lbnQpXG4gICAqL1xuICBvbkV4aXQ6IFByb3BUeXBlcy5mdW5jLFxuXG4gIC8qKlxuICAgKiBBIGA8VHJhbnNpdGlvbj5gIGNhbGxiYWNrIGZpcmVkIGltbWVkaWF0ZWx5IGFmdGVyIHRoZSAnZXhpdC1hY3RpdmUnIGlzIGFwcGxpZWQuXG4gICAqXG4gICAqICoqTm90ZSoqOiB3aGVuIGBub2RlUmVmYCBwcm9wIGlzIHBhc3NlZCwgYG5vZGVgIGlzIG5vdCBwYXNzZWRcbiAgICpcbiAgICogQHR5cGUgRnVuY3Rpb24obm9kZTogSHRtbEVsZW1lbnQpXG4gICAqL1xuICBvbkV4aXRpbmc6IFByb3BUeXBlcy5mdW5jLFxuXG4gIC8qKlxuICAgKiBBIGA8VHJhbnNpdGlvbj5gIGNhbGxiYWNrIGZpcmVkIGltbWVkaWF0ZWx5IGFmdGVyIHRoZSAnZXhpdCcgY2xhc3Nlc1xuICAgKiBhcmUgKipyZW1vdmVkKiogYW5kIHRoZSBgZXhpdC1kb25lYCBjbGFzcyBpcyBhZGRlZCB0byB0aGUgRE9NIG5vZGUuXG4gICAqXG4gICAqICoqTm90ZSoqOiB3aGVuIGBub2RlUmVmYCBwcm9wIGlzIHBhc3NlZCwgYG5vZGVgIGlzIG5vdCBwYXNzZWRcbiAgICpcbiAgICogQHR5cGUgRnVuY3Rpb24obm9kZTogSHRtbEVsZW1lbnQpXG4gICAqL1xuICBvbkV4aXRlZDogUHJvcFR5cGVzLmZ1bmNcbn0pIDoge307XG5leHBvcnQgZGVmYXVsdCBDU1NUcmFuc2l0aW9uOyIsImV4cG9ydCBjb25zdCBudW1iZXJzID0ge1xyXG4gICAgQkFOTkVSX0FOSU1BVElPTl9DTE9TRV9USU1FX01TOiAyNTAsXHJcbiAgICBCQU5ORVJfQU5JTUFUSU9OX09QRU5fVElNRV9NUzogMzAwLFxyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IGNzc0NsYXNzZXMgPSB7XHJcbiAgICBST09UOiAnbWRjLWJhbm5lcicsXHJcbiAgICBGSVhFRDogJ21kYy1iYW5uZXItLWZpeGVkJyxcclxuICAgIENFTlRFUkVEOiAnbWRjLWJhbm5lci0tY2VudGVyZWQnLFxyXG4gICAgTU9CSUxFX1NUQUNLRUQ6ICdtZGMtYmFubmVyLS1tb2JpbGUtc3RhY2tlZCcsXHJcbiAgICBBUFBFQVJJTkc6ICdtZGMtYmFubmVyLS1hcHBlYXJpbmcnLFxyXG4gICAgQVBQRUFSRUQ6ICdtZGMtYmFubmVyLS1hcHBlYXJlZCcsXHJcbiAgICBPUEVOSU5HOiAnbWRjLWJhbm5lci0tb3BlbmluZycsXHJcbiAgICBPUEVOOiAnbWRjLWJhbm5lci0tb3BlbicsXHJcbiAgICBDTE9TSU5HOiAnbWRjLWJhbm5lci0tY2xvc2luZycsXHJcblxyXG4gICAgQ09OVEVOVDogJ21kYy1iYW5uZXJfX2NvbnRlbnQnLFxyXG4gICAgR1JBUEhJQ19URVhUX1dSQVBQRVI6ICdtZGMtYmFubmVyX19ncmFwaGljLXRleHQtd3JhcHBlcicsXHJcbiAgICBHUkFQSElDOiAnbWRjLWJhbm5lcl9fZ3JhcGhpYycsXHJcbiAgICBJQ09OOiAnbWRjLWJhbm5lcl9faWNvbicsXHJcbiAgICBURVhUOiAnbWRjLWJhbm5lcl9fdGV4dCcsXHJcbiAgICBBQ1RJT05TOiAnbWRjLWJhbm5lcl9fYWN0aW9ucycsXHJcbiAgICBQUklNQVJZX0FDVElPTjogJ21kYy1iYW5uZXJfX3ByaW1hcnktYWN0aW9uJyxcclxuICAgIFNFQ09OREFSWV9BQ1RJT046ICdtZGMtYmFubmVyX19zZWNvbmRhcnktYWN0aW9uJ1xyXG59OyIsImltcG9ydCB7IGZvcndhcmRSZWYsIHVzZVJlZiwgdXNlQ2FsbGJhY2ssIHVzZUltcGVyYXRpdmVIYW5kbGUgfSBmcm9tICdyZWFjdCc7XHJcbmltcG9ydCB7IENTU1RyYW5zaXRpb24gfSBmcm9tICdyZWFjdC10cmFuc2l0aW9uLWdyb3VwJztcclxuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcclxuaW1wb3J0IGNsYXNzbmFtZXMgZnJvbSAnY2xhc3NuYW1lcyc7XHJcblxyXG5pbXBvcnQgeyBDbG9uZSB9IGZyb20gJy4uL2NvbXBvbmVudCc7XHJcbmltcG9ydCBJY29uIGZyb20gJy4uL2ljb24nO1xyXG5cclxuaW1wb3J0IHsgbnVtYmVycywgY3NzQ2xhc3NlcyB9IGZyb20gJy4vY29uc3RhbnRzJztcclxuXHJcbmNvbnN0IEJhbm5lciA9IGZvcndhcmRSZWYoKHtcclxuICAgIHRleHQsXHJcbiAgICBpY29uLFxyXG4gICAgZ3JhcGhpYyA9IGljb24sXHJcbiAgICBhY3Rpb24sXHJcbiAgICBwcmltYXJ5QWN0aW9uID0gYWN0aW9uLFxyXG4gICAgc2Vjb25kYXJ5QWN0aW9uLFxyXG4gICAgb3BlbiA9IGZhbHNlLFxyXG4gICAgY2VudGVyZWQgPSBmYWxzZSxcclxuICAgIGZpeGVkID0gZmFsc2UsXHJcbiAgICBtb2JpbGVTdGFja2VkID0gZmFsc2UsXHJcblxyXG4gICAgZWxlbWVudCA9ICdkaXYnLFxyXG4gICAgY29tcG9uZW50OiBFbGVtZW50ID0gZWxlbWVudCxcclxuICAgIGNsYXNzTmFtZSxcclxuICAgIGNoaWxkcmVuID0gdGV4dCxcclxuICAgIC4uLnByb3BzXHJcbn0sIHJlZikgPT4ge1xyXG4gICAgY29uc3Qgcm9vdFJlZiA9IHVzZVJlZigpO1xyXG4gICAgY29uc3QgY29udGVudFJlZiA9IHVzZVJlZigpO1xyXG5cclxuICAgIHVzZUltcGVyYXRpdmVIYW5kbGUocmVmLCAoKSA9PiByb290UmVmLmN1cnJlbnQpO1xyXG5cclxuICAgIGNvbnN0IGhhbmRsZUVudGVyaW5nID0gdXNlQ2FsbGJhY2soKG5vZGUsIGlzQXBwZWFyaW5nKSA9PiB7XHJcbiAgICAgICAgaWYgKCFpc0FwcGVhcmluZykge1xyXG4gICAgICAgICAgICBub2RlLnN0eWxlLmhlaWdodCA9IGAke2NvbnRlbnRSZWYuY3VycmVudC5vZmZzZXRIZWlnaHR9cHhgO1xyXG4gICAgICAgIH1cclxuICAgIH0sIFtdKTtcclxuXHJcbiAgICBjb25zdCBoYW5kbGVFeGl0aW5nID0gdXNlQ2FsbGJhY2sobm9kZSA9PiB7XHJcbiAgICAgICAgbm9kZS5zdHlsZS5oZWlnaHQgPSAnMHB4JztcclxuICAgIH0sIFtdKTtcclxuXHJcbiAgICBjb25zdCBjbGFzc05hbWVzID0gY2xhc3NuYW1lcyhjc3NDbGFzc2VzLlJPT1QsIHtcclxuICAgICAgICBbY3NzQ2xhc3Nlcy5GSVhFRF06IGZpeGVkLFxyXG4gICAgICAgIFtjc3NDbGFzc2VzLkNFTlRFUkVEXTogY2VudGVyZWQsXHJcbiAgICAgICAgW2Nzc0NsYXNzZXMuTU9CSUxFX1NUQUNLRURdOiBtb2JpbGVTdGFja2VkXHJcbiAgICB9LCBjbGFzc05hbWUpO1xyXG5cclxuICAgIGNvbnN0IGNvbnRlbnQgPSAoXHJcbiAgICAgICAgPGRpdiByZWY9e2NvbnRlbnRSZWZ9IGNsYXNzTmFtZT17Y3NzQ2xhc3Nlcy5DT05URU5UfSByb2xlPVwic3RhdHVzXCI+XHJcbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXtjc3NDbGFzc2VzLkdSQVBISUNfVEVYVF9XUkFQUEVSfT5cclxuICAgICAgICAgICAgICAgIHtncmFwaGljICYmXHJcbiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9e2Nzc0NsYXNzZXMuR1JBUEhJQ30+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxDbG9uZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50PXtncmFwaGljfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmFsbGJhY2s9e0ljb259XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU9e2Nzc0NsYXNzZXMuSUNPTn1cclxuICAgICAgICAgICAgICAgICAgICAgICAgLz5cclxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICA8Q2xvbmVcclxuICAgICAgICAgICAgICAgICAgICBjb21wb25lbnQ9e2NoaWxkcmVufVxyXG4gICAgICAgICAgICAgICAgICAgIGZhbGxiYWNrPVwiZGl2XCJcclxuICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU9e2Nzc0NsYXNzZXMuVEVYVH1cclxuICAgICAgICAgICAgICAgIC8+XHJcbiAgICAgICAgICAgIDwvZGl2PlxyXG5cclxuICAgICAgICAgICAge3ByaW1hcnlBY3Rpb24gJiZcclxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXtjc3NDbGFzc2VzLkFDVElPTlN9PlxyXG4gICAgICAgICAgICAgICAgICAgIHtzZWNvbmRhcnlBY3Rpb24gJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgPENsb25lXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21wb25lbnQ9e3NlY29uZGFyeUFjdGlvbn1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT17Y3NzQ2xhc3Nlcy5TRUNPTkRBUllfQUNUSU9OfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvPlxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgPENsb25lXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudD17cHJpbWFyeUFjdGlvbn1cclxuICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPXtjc3NDbGFzc2VzLlBSSU1BUllfQUNUSU9OfVxyXG4gICAgICAgICAgICAgICAgICAgIC8+XHJcbiAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIDwvZGl2PlxyXG4gICAgKTtcclxuXHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAgIDxDU1NUcmFuc2l0aW9uXHJcbiAgICAgICAgICAgIGluPXtvcGVufVxyXG4gICAgICAgICAgICBhcHBlYXI9e29wZW59XHJcbiAgICAgICAgICAgIHRpbWVvdXQ9e3tcclxuICAgICAgICAgICAgICAgIGFwcGVhcjogMCxcclxuICAgICAgICAgICAgICAgIGVudGVyOiBudW1iZXJzLkJBTk5FUl9BTklNQVRJT05fT1BFTl9USU1FX01TLFxyXG4gICAgICAgICAgICAgICAgZXhpdDogbnVtYmVycy5CQU5ORVJfQU5JTUFUSU9OX0NMT1NFX1RJTUVfTVNcclxuICAgICAgICAgICAgfX1cclxuICAgICAgICAgICAgY2xhc3NOYW1lcz17e1xyXG4gICAgICAgICAgICAgICAgYXBwZWFyOiBjc3NDbGFzc2VzLkFQUEVBUklORyxcclxuICAgICAgICAgICAgICAgIGFwcGVhckRvbmU6IGNzc0NsYXNzZXMuQVBQRUFSRUQsXHJcbiAgICAgICAgICAgICAgICBlbnRlcjogY3NzQ2xhc3Nlcy5PUEVOSU5HLFxyXG4gICAgICAgICAgICAgICAgZW50ZXJBY3RpdmU6IGNzc0NsYXNzZXMuT1BFTixcclxuICAgICAgICAgICAgICAgIGVudGVyRG9uZTogY3NzQ2xhc3Nlcy5PUEVOLFxyXG4gICAgICAgICAgICAgICAgZXhpdDogY3NzQ2xhc3Nlcy5DTE9TSU5HXHJcbiAgICAgICAgICAgIH19XHJcbiAgICAgICAgICAgIG1vdW50T25FbnRlclxyXG4gICAgICAgICAgICB1bm1vdW50T25FeGl0XHJcbiAgICAgICAgICAgIG9uRW50ZXJpbmc9e2hhbmRsZUVudGVyaW5nfVxyXG4gICAgICAgICAgICBvbkV4aXRpbmc9e2hhbmRsZUV4aXRpbmd9XHJcbiAgICAgICAgPlxyXG4gICAgICAgICAgICA8RWxlbWVudCByZWY9e3Jvb3RSZWZ9IGNsYXNzTmFtZT17Y2xhc3NOYW1lc30gcm9sZT1cImJhbm5lclwiIHsuLi5wcm9wc30+XHJcbiAgICAgICAgICAgICAgICB7Y29udGVudH1cclxuICAgICAgICAgICAgPC9FbGVtZW50PlxyXG4gICAgICAgIDwvQ1NTVHJhbnNpdGlvbj5cclxuICAgICk7XHJcbn0pO1xyXG5cclxuQmFubmVyLmRpc3BsYXlOYW1lID0gJ01EQ0Jhbm5lcic7XHJcblxyXG5CYW5uZXIucHJvcFR5cGVzID0ge1xyXG4gICAgdGV4dDogUHJvcFR5cGVzLm5vZGUuaXNSZXF1aXJlZCxcclxuICAgIGljb246IFByb3BUeXBlcy5ub2RlLFxyXG4gICAgZ3JhcGhpYzogUHJvcFR5cGVzLmVsZW1lbnQsXHJcbiAgICBhY3Rpb246IFByb3BUeXBlcy5lbGVtZW50LFxyXG4gICAgcHJpbWFyeUFjdGlvbjogUHJvcFR5cGVzLmVsZW1lbnQsXHJcbiAgICBzZWNvbmRhcnlBY3Rpb246IFByb3BUeXBlcy5lbGVtZW50LFxyXG4gICAgb3BlbjogUHJvcFR5cGVzLmJvb2wsXHJcbiAgICBhcHBlYXI6IFByb3BUeXBlcy5ib29sLFxyXG4gICAgZml4ZWQ6IFByb3BUeXBlcy5ib29sLFxyXG4gICAgY2VudGVyZWQ6IFByb3BUeXBlcy5ib29sLFxyXG4gICAgbW9iaWxlU3RhY2tlZDogUHJvcFR5cGVzLmJvb2xcclxufTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IEJhbm5lcjsiLCJleHBvcnQgeyBkZWZhdWx0IH0gZnJvbSAnLi9CYW5uZXInOyIsImV4cG9ydCBjb25zdCBjc3NDbGFzc2VzID0ge1xyXG4gICAgUk9PVDogJ21kYy1idXR0b24nLFxyXG4gICAgUkFJU0VEOiAnbWRjLWJ1dHRvbi0tcmFpc2VkJyxcclxuICAgIFVORUxFVkFURUQ6ICdtZGMtYnV0dG9uLS11bmVsZXZhdGVkJyxcclxuICAgIE9VVExJTkVEOiAnbWRjLWJ1dHRvbi0tb3V0bGluZWQnLFxyXG4gICAgVE9VQ0g6ICdtZGMtYnV0dG9uLS10b3VjaCcsXHJcbiAgICBJQ09OX0xFQURJTkc6ICdtZGMtYnV0dG9uLS1pY29uLWxlYWRpbmcnLFxyXG4gICAgSUNPTl9UUkFJTElORzogJ21kYy1idXR0b24tLWljb24tdHJhaWxpbmcnLFxyXG5cclxuICAgIFJJUFBMRTogJ21kYy1idXR0b25fX3JpcHBsZScsXHJcbiAgICBJQ09OOiAnbWRjLWJ1dHRvbl9faWNvbicsXHJcbiAgICBMQUJFTDogJ21kYy1idXR0b25fX2xhYmVsJyxcclxuICAgIFRPVUNIX0VMRU1FTlQ6ICdtZGMtYnV0dG9uX190b3VjaCdcclxufTsiLCJpbXBvcnQgeyBmb3J3YXJkUmVmIH0gZnJvbSAncmVhY3QnO1xyXG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xyXG5pbXBvcnQgY2xhc3NuYW1lcyBmcm9tICdjbGFzc25hbWVzJztcclxuXHJcbmltcG9ydCB7IENsb25lIH0gZnJvbSAnLi4vY29tcG9uZW50JztcclxuaW1wb3J0IEljb24gZnJvbSAnLi4vaWNvbic7XHJcbmltcG9ydCB7IGNzc0NsYXNzZXMgfSBmcm9tICcuL2NvbnN0YW50cyc7XHJcblxyXG5jb25zdCBCdXR0b24gPSBmb3J3YXJkUmVmKCh7XHJcbiAgICBsYWJlbCxcclxuICAgIGljb24sXHJcbiAgICBsZWFkaW5nSWNvbiA9IGljb24sXHJcbiAgICB0cmFpbGluZ0ljb24sXHJcbiAgICByYWlzZWQgPSBmYWxzZSxcclxuICAgIHVuZWxldmF0ZWQgPSBmYWxzZSxcclxuICAgIG91dGxpbmVkID0gZmFsc2UsXHJcbiAgICB0b3VjaCA9IGZhbHNlLFxyXG5cclxuICAgIGVsZW1lbnQgPSAnYnV0dG9uJyxcclxuICAgIGNvbXBvbmVudDogRWxlbWVudCA9IGVsZW1lbnQsXHJcbiAgICBjbGFzc05hbWUsXHJcbiAgICBjaGlsZHJlbiA9IGxhYmVsLFxyXG4gICAgLi4ucHJvcHNcclxufSwgcmVmKSA9PiB7XHJcbiAgICBjb25zdCBjbGFzc05hbWVzID0gY2xhc3NuYW1lcyhjc3NDbGFzc2VzLlJPT1QsIHtcclxuICAgICAgICBbY3NzQ2xhc3Nlcy5SQUlTRURdOiByYWlzZWQsXHJcbiAgICAgICAgW2Nzc0NsYXNzZXMuVU5FTEVWQVRFRF06IHVuZWxldmF0ZWQsXHJcbiAgICAgICAgW2Nzc0NsYXNzZXMuT1VUTElORURdOiBvdXRsaW5lZCxcclxuICAgICAgICBbY3NzQ2xhc3Nlcy5UT1VDSF06IHRvdWNoLFxyXG4gICAgICAgIFtjc3NDbGFzc2VzLklDT05fTEVBRElOR106IEJvb2xlYW4obGVhZGluZ0ljb24pLFxyXG4gICAgICAgIFtjc3NDbGFzc2VzLklDT05fVFJBSUxJTkddOiBCb29sZWFuKHRyYWlsaW5nSWNvbilcclxuICAgIH0sIGNsYXNzTmFtZSk7XHJcblxyXG4gICAgcmV0dXJuIChcclxuICAgICAgICA8RWxlbWVudCByZWY9e3JlZn0gY2xhc3NOYW1lPXtjbGFzc05hbWVzfSB7Li4ucHJvcHN9PlxyXG4gICAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9e2Nzc0NsYXNzZXMuUklQUExFfSAvPlxyXG5cclxuICAgICAgICAgICAge3RvdWNoICYmXHJcbiAgICAgICAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9e2Nzc0NsYXNzZXMuVE9VQ0hfRUxFTUVOVH0gLz5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAge2xlYWRpbmdJY29uICYmXHJcbiAgICAgICAgICAgICAgICA8Q2xvbmVcclxuICAgICAgICAgICAgICAgICAgICBjb21wb25lbnQ9e2xlYWRpbmdJY29ufVxyXG4gICAgICAgICAgICAgICAgICAgIGZhbGxiYWNrPXtJY29ufVxyXG4gICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT17Y3NzQ2xhc3Nlcy5JQ09OfVxyXG4gICAgICAgICAgICAgICAgICAgIGFyaWEtaGlkZGVuPVwidHJ1ZVwiXHJcbiAgICAgICAgICAgICAgICAvPlxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9e2Nzc0NsYXNzZXMuTEFCRUx9PntjaGlsZHJlbn08L3NwYW4+XHJcblxyXG4gICAgICAgICAgICB7dHJhaWxpbmdJY29uICYmXHJcbiAgICAgICAgICAgICAgICA8Q2xvbmVcclxuICAgICAgICAgICAgICAgICAgICBjb21wb25lbnQ9e3RyYWlsaW5nSWNvbn1cclxuICAgICAgICAgICAgICAgICAgICBmYWxsYmFjaz17SWNvbn1cclxuICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU9e2Nzc0NsYXNzZXMuSUNPTn1cclxuICAgICAgICAgICAgICAgICAgICBhcmlhLWhpZGRlbj1cInRydWVcIlxyXG4gICAgICAgICAgICAgICAgLz5cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIDwvRWxlbWVudD5cclxuICAgICk7XHJcbn0pO1xyXG5cclxuQnV0dG9uLmRpc3BsYXlOYW1lID0gJ01EQ0J1dHRvbic7XHJcblxyXG5CdXR0b24ucHJvcFR5cGVzID0ge1xyXG4gICAgbGFiZWw6IFByb3BUeXBlcy5ub2RlLFxyXG4gICAgaWNvbjogUHJvcFR5cGVzLm5vZGUsXHJcbiAgICBsZWFkaW5nSWNvbjogUHJvcFR5cGVzLm5vZGUsXHJcbiAgICB0cmFpbGluZ0ljb246IFByb3BUeXBlcy5ub2RlLFxyXG4gICAgcmFpc2VkOiBQcm9wVHlwZXMuYm9vbCxcclxuICAgIHVuZWxldmF0ZWQ6IFByb3BUeXBlcy5ib29sLFxyXG4gICAgb3V0bGluZWQ6IFByb3BUeXBlcy5ib29sLFxyXG4gICAgdG91Y2g6IFByb3BUeXBlcy5ib29sXHJcbn07XHJcblxyXG5leHBvcnQgZGVmYXVsdCBCdXR0b247IiwiZXhwb3J0IHsgZGVmYXVsdCB9IGZyb20gJy4vQnV0dG9uJzsiLCJleHBvcnQgY29uc3QgY3NzQ2xhc3NlcyA9IHtcclxuICAgIFJPT1Q6ICdtZGMtY2FyZCcsXHJcbiAgICBPVVRMSU5FRDogJ21kYy1jYXJkLS1vdXRsaW5lZCcsXHJcblxyXG4gICAgVElUTEU6ICdtZGMtY2FyZF9fdGl0bGUnLFxyXG4gICAgU1VCVElUTEU6ICdtZGMtY2FyZF9fc3VidGl0bGUnLFxyXG4gICAgT1ZFUkxJTkU6ICdtZGMtY2FyZF9fb3ZlcmxpbmUnLFxyXG5cclxuICAgIEFDVElPTlM6ICdtZGMtY2FyZF9fYWN0aW9ucycsXHJcbiAgICBBQ1RJT05TX0ZVTExfQkxFRUQ6ICdtZGMtY2FyZF9fYWN0aW9ucy0tZnVsbC1ibGVlZCcsXHJcblxyXG4gICAgQUNUSU9OX0JVVFRPTlM6ICdtZGMtY2FyZF9fYWN0aW9uLWJ1dHRvbnMnLFxyXG4gICAgQUNUSU9OX0lDT05TOiAnbWRjLWNhcmRfX2FjdGlvbi1pY29ucycsXHJcblxyXG4gICAgQUNUSU9OOiAnbWRjLWNhcmRfX2FjdGlvbicsXHJcbiAgICBBQ1RJT05fQlVUVE9OOiAnbWRjLWNhcmRfX2FjdGlvbi0tYnV0dG9uJyxcclxuICAgIEFDVElPTl9JQ09OOiAnbWRjLWNhcmRfX2FjdGlvbi0taWNvbicsXHJcblxyXG4gICAgQ09OVEVOVDogJ21kYy1jYXJkX19jb250ZW50JyxcclxuXHJcbiAgICBIRUFERVI6ICdtZGMtY2FyZF9faGVhZGVyJyxcclxuICAgIEhFQURFUl9HUkFQSElDOiAnbWRjLWNhcmRfX2hlYWRlcl9fZ3JhcGhpYycsXHJcbiAgICBIRUFERVJfQ09OVEVOVDogJ21kYy1jYXJkX19oZWFkZXJfX2NvbnRlbnQnLFxyXG4gICAgSEVBREVSX0FDVElPTlM6ICdtZGMtY2FyZF9faGVhZGVyX19hY3Rpb25zJyxcclxuXHJcbiAgICBNRURJQTogJ21kYy1jYXJkX19tZWRpYScsXHJcbiAgICBNRURJQV9TUVVBUkU6ICdtZGMtY2FyZF9fbWVkaWEtLXNxdWFyZScsXHJcbiAgICBNRURJQV9XSURFOiAnbWRjLWNhcmRfX21lZGlhLS0xNi05JyxcclxuICAgIE1FRElBX0NPTlRFTlQ6ICdtZGMtY2FyZF9fbWVkaWEtY29udGVudCcsXHJcblxyXG4gICAgUFJJTUFSWV9BQ1RJT046ICdtZGMtY2FyZF9fcHJpbWFyeS1hY3Rpb24nLFxyXG5cclxuICAgIFNFQ1RJT046ICdtZGMtY2FyZF9fc2VjdGlvbicsXHJcbiAgICBTRUNUSU9OX1BSSU1BUlk6ICdtZGMtY2FyZF9fc2VjdGlvbi0tcHJpbWFyeScsXHJcbiAgICBTRUNUSU9OX1NFQ09OREFSWTogJ21kYy1jYXJkX19zZWN0aW9uLS1zZWNvbmRhcnknLFxyXG5cclxuICAgIFJJUFBMRTogJ21kYy1jYXJkX19yaXBwbGUnXHJcbn07IiwiaW1wb3J0IHsgZm9yd2FyZFJlZiB9IGZyb20gJ3JlYWN0JztcclxuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcclxuaW1wb3J0IGNsYXNzbmFtZXMgZnJvbSAnY2xhc3NuYW1lcyc7XHJcblxyXG5pbXBvcnQgeyBjc3NDbGFzc2VzIH0gZnJvbSAnLi9jb25zdGFudHMnO1xyXG5cclxuY29uc3QgQ2FyZCA9IGZvcndhcmRSZWYoKHtcclxuICAgIG91dGxpbmVkID0gZmFsc2UsXHJcblxyXG4gICAgZWxlbWVudCA9ICdkaXYnLFxyXG4gICAgY29tcG9uZW50OiBFbGVtZW50ID0gZWxlbWVudCxcclxuICAgIGNsYXNzTmFtZSxcclxuICAgIC4uLnByb3BzXHJcbn0sIHJlZikgPT4ge1xyXG4gICAgY29uc3QgY2xhc3NOYW1lcyA9IGNsYXNzbmFtZXMoY3NzQ2xhc3Nlcy5ST09ULCB7XHJcbiAgICAgICAgW2Nzc0NsYXNzZXMuT1VUTElORURdOiBvdXRsaW5lZFxyXG4gICAgfSwgY2xhc3NOYW1lKTtcclxuXHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAgIDxFbGVtZW50IHJlZj17cmVmfSBjbGFzc05hbWU9e2NsYXNzTmFtZXN9IHsuLi5wcm9wc30gLz5cclxuICAgICk7XHJcbn0pO1xyXG5cclxuQ2FyZC5kaXNwbGF5TmFtZSA9ICdNRENDYXJkJztcclxuXHJcbkNhcmQucHJvcFR5cGVzID0ge1xyXG4gICAgb3V0bGluZWQ6IFByb3BUeXBlcy5ib29sXHJcbn07XHJcblxyXG5leHBvcnQgZGVmYXVsdCBDYXJkOyIsImltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XHJcbmltcG9ydCBjbGFzc25hbWVzIGZyb20gJ2NsYXNzbmFtZXMnO1xyXG5cclxuaW1wb3J0IHsgQ2xvbmUgfSBmcm9tICcuLi9jb21wb25lbnQnO1xyXG5cclxuaW1wb3J0IHsgY3NzQ2xhc3NlcyB9IGZyb20gJy4vY29uc3RhbnRzJztcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIENhcmRBY3Rpb24oe1xyXG4gICAgYnV0dG9uID0gZmFsc2UsXHJcbiAgICBpY29uID0gZmFsc2UsXHJcblxyXG4gICAgY29tcG9uZW50LFxyXG4gICAgY2xhc3NOYW1lLFxyXG4gICAgY2hpbGRyZW4gPSBjb21wb25lbnQsXHJcbiAgICAuLi5wcm9wc1xyXG59KSB7XHJcbiAgICBjb25zdCBjbGFzc05hbWVzID0gY2xhc3NuYW1lcyhjc3NDbGFzc2VzLkFDVElPTiwge1xyXG4gICAgICAgIFtjc3NDbGFzc2VzLkFDVElPTl9CVVRUT05dOiBidXR0b24sXHJcbiAgICAgICAgW2Nzc0NsYXNzZXMuQUNUSU9OX0lDT05dOiBpY29uXHJcbiAgICB9LCBjbGFzc05hbWUpO1xyXG5cclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgPENsb25lXHJcbiAgICAgICAgICAgIGNvbXBvbmVudD17Y2hpbGRyZW59XHJcbiAgICAgICAgICAgIGNsYXNzTmFtZT17Y2xhc3NOYW1lc31cclxuICAgICAgICAgICAgey4uLnByb3BzfVxyXG4gICAgICAgIC8+XHJcbiAgICApO1xyXG59XHJcblxyXG5DYXJkQWN0aW9uLmRpc3BsYXlOYW1lID0gJ01EQ0NhcmRBY3Rpb24nO1xyXG5cclxuQ2FyZEFjdGlvbi5wcm9wVHlwZXMgPSB7XHJcbiAgICBidXR0b246IFByb3BUeXBlcy5ib29sLFxyXG4gICAgaWNvbjogUHJvcFR5cGVzLmJvb2xcclxufTsiLCJpbXBvcnQgeyBmb3J3YXJkUmVmIH0gZnJvbSAncmVhY3QnO1xyXG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xyXG5pbXBvcnQgY2xhc3NuYW1lcyBmcm9tICdjbGFzc25hbWVzJztcclxuXHJcbmltcG9ydCB7IGNzc0NsYXNzZXMgfSBmcm9tICcuL2NvbnN0YW50cyc7XHJcblxyXG5jb25zdCBDYXJkQWN0aW9ucyA9IGZvcndhcmRSZWYoKHtcclxuICAgIGZ1bGxCbGVlZCA9IGZhbHNlLFxyXG5cclxuICAgIGVsZW1lbnQ6IEVsZW1lbnQgPSAnZGl2JyxcclxuICAgIGNsYXNzTmFtZSxcclxuICAgIC4uLnByb3BzXHJcbn0sIHJlZikgPT4ge1xyXG4gICAgY29uc3QgY2xhc3NOYW1lcyA9IGNsYXNzbmFtZXMoY3NzQ2xhc3Nlcy5BQ1RJT05TLCB7XHJcbiAgICAgICAgW2Nzc0NsYXNzZXMuQUNUSU9OU19GVUxMX0JMRUVEXTogZnVsbEJsZWVkXHJcbiAgICB9LCBjbGFzc05hbWUpO1xyXG5cclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgPEVsZW1lbnQgcmVmPXtyZWZ9IGNsYXNzTmFtZT17Y2xhc3NOYW1lc30gey4uLnByb3BzfSAvPlxyXG4gICAgKTtcclxufSk7XHJcblxyXG5DYXJkQWN0aW9ucy5kaXNwbGF5TmFtZSA9ICdNRENDYXJkQWN0aW9ucyc7XHJcblxyXG5DYXJkQWN0aW9ucy5wcm9wVHlwZXMgPSB7XHJcbiAgICBmdWxsQmxlZWQ6IFByb3BUeXBlcy5ib29sXHJcbn07XHJcblxyXG5leHBvcnQgZGVmYXVsdCBDYXJkQWN0aW9uczsiLCJpbXBvcnQgeyBmb3J3YXJkUmVmIH0gZnJvbSAncmVhY3QnO1xyXG5pbXBvcnQgY2xhc3NuYW1lcyBmcm9tICdjbGFzc25hbWVzJztcclxuXHJcbmltcG9ydCB7IENsb25lIH0gZnJvbSAnLi4vY29tcG9uZW50JztcclxuXHJcbmltcG9ydCB7IGNzc0NsYXNzZXMgfSBmcm9tICcuL2NvbnN0YW50cyc7XHJcblxyXG5jb25zdCBDYXJkQWN0aW9uQnV0dG9ucyA9IGZvcndhcmRSZWYoKHtcclxuICAgIGVsZW1lbnQgPSAnZGl2JyxcclxuICAgIGNvbXBvbmVudDogRWxlbWVudCA9IGVsZW1lbnQsXHJcbiAgICBjbGFzc05hbWUsXHJcbiAgICBjaGlsZHJlbixcclxuICAgIC4uLnByb3BzXHJcbn0sIHJlZikgPT4ge1xyXG4gICAgY29uc3QgY2xhc3NOYW1lcyA9IGNsYXNzbmFtZXMoY3NzQ2xhc3Nlcy5BQ1RJT05fQlVUVE9OUywgY2xhc3NOYW1lKTtcclxuXHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAgIDxFbGVtZW50IHJlZj17cmVmfSBjbGFzc05hbWU9e2NsYXNzTmFtZXN9IHsuLi5wcm9wc30+XHJcbiAgICAgICAgICAgIDxDbG9uZVxyXG4gICAgICAgICAgICAgICAgY29tcG9uZW50PXtjaGlsZHJlbn1cclxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZT17YCR7Y3NzQ2xhc3Nlcy5BQ1RJT059ICR7Y3NzQ2xhc3Nlcy5BQ1RJT05fQlVUVE9OfWB9XHJcbiAgICAgICAgICAgIC8+XHJcbiAgICAgICAgPC9FbGVtZW50PlxyXG4gICAgKTtcclxufSk7XHJcblxyXG5DYXJkQWN0aW9uQnV0dG9ucy5kaXNwbGF5TmFtZSA9ICdNRENDYXJkQWN0aW9uQnV0dG9ucyc7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBDYXJkQWN0aW9uQnV0dG9uczsiLCJpbXBvcnQgeyBmb3J3YXJkUmVmIH0gZnJvbSAncmVhY3QnO1xyXG5pbXBvcnQgY2xhc3NuYW1lcyBmcm9tICdjbGFzc25hbWVzJztcclxuXHJcbmltcG9ydCB7IENsb25lIH0gZnJvbSAnLi4vY29tcG9uZW50JztcclxuXHJcbmltcG9ydCB7IGNzc0NsYXNzZXMgfSBmcm9tICcuL2NvbnN0YW50cyc7XHJcblxyXG5jb25zdCBDYXJkQWN0aW9uSWNvbnMgPSBmb3J3YXJkUmVmKCh7XHJcbiAgICBlbGVtZW50ID0gJ2RpdicsXHJcbiAgICBjb21wb25lbnQ6IEVsZW1lbnQgPSBlbGVtZW50LFxyXG4gICAgY2xhc3NOYW1lLFxyXG4gICAgY2hpbGRyZW4sXHJcbiAgICAuLi5wcm9wc1xyXG59LCByZWYpID0+IHtcclxuICAgIGNvbnN0IGNsYXNzTmFtZXMgPSBjbGFzc25hbWVzKGNzc0NsYXNzZXMuQUNUSU9OX0lDT05TLCBjbGFzc05hbWUpO1xyXG5cclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgPEVsZW1lbnQgcmVmPXtyZWZ9IGNsYXNzTmFtZT17Y2xhc3NOYW1lc30gey4uLnByb3BzfT5cclxuICAgICAgICAgICAgPENsb25lXHJcbiAgICAgICAgICAgICAgICBjb21wb25lbnQ9e2NoaWxkcmVufVxyXG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lPXtgJHtjc3NDbGFzc2VzLkFDVElPTn0gJHtjc3NDbGFzc2VzLkFDVElPTl9JQ09OfWB9XHJcbiAgICAgICAgICAgIC8+XHJcbiAgICAgICAgPC9FbGVtZW50PlxyXG4gICAgKTtcclxufSk7XHJcblxyXG5DYXJkQWN0aW9uSWNvbnMuZGlzcGxheU5hbWUgPSAnTURDQ2FyZEFjdGlvbkljb25zJztcclxuXHJcbmV4cG9ydCBkZWZhdWx0IENhcmRBY3Rpb25JY29uczsiLCJpbXBvcnQgeyBDaGlsZHJlbiwgZm9yd2FyZFJlZiB9IGZyb20gJ3JlYWN0JztcclxuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcclxuaW1wb3J0IGNsYXNzbmFtZXMgZnJvbSAnY2xhc3NuYW1lcyc7XHJcblxyXG5pbXBvcnQgeyBDbG9uZSB9IGZyb20gJy4uL2NvbXBvbmVudCc7XHJcblxyXG5pbXBvcnQgeyBjc3NDbGFzc2VzIH0gZnJvbSAnLi9jb25zdGFudHMnO1xyXG5cclxuY29uc3QgQ2FyZEhlYWRlciA9IGZvcndhcmRSZWYoKHtcclxuICAgIHRpdGxlLFxyXG4gICAgc3VidGl0bGUsXHJcbiAgICBvdmVybGluZSxcclxuICAgIGdyYXBoaWMsXHJcbiAgICBhY3Rpb25zLFxyXG5cclxuICAgIGVsZW1lbnQgPSAnZGl2JyxcclxuICAgIGNvbXBvbmVudDogRWxlbWVudCA9IGVsZW1lbnQsXHJcbiAgICBjbGFzc05hbWUsXHJcbiAgICBjaGlsZHJlbixcclxuICAgIC4uLnByb3BzXHJcbn0sIHJlZikgPT4ge1xyXG4gICAgY29uc3QgY2xhc3NOYW1lcyA9IGNsYXNzbmFtZXMoY3NzQ2xhc3Nlcy5IRUFERVIsIGNsYXNzTmFtZSk7XHJcblxyXG4gICAgcmV0dXJuIChcclxuICAgICAgICA8RWxlbWVudCByZWY9e3JlZn0gY2xhc3NOYW1lPXtjbGFzc05hbWVzfSB7Li4ucHJvcHN9PlxyXG4gICAgICAgICAgICB7Z3JhcGhpYyAmJlxyXG4gICAgICAgICAgICAgICAgPENsb25lXHJcbiAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50PXtncmFwaGljfVxyXG4gICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT17Y3NzQ2xhc3Nlcy5IRUFERVJfR1JBUEhJQ31cclxuICAgICAgICAgICAgICAgIC8+XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXtjc3NDbGFzc2VzLkhFQURFUl9DT05URU5UfT5cclxuICAgICAgICAgICAgICAgIHtvdmVybGluZSAmJlxyXG4gICAgICAgICAgICAgICAgICAgIDxDbG9uZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb21wb25lbnQ9e292ZXJsaW5lfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmYWxsYmFjaz1cInNwYW5cIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU9e2Nzc0NsYXNzZXMuT1ZFUkxJTkV9XHJcbiAgICAgICAgICAgICAgICAgICAgLz5cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICB7dGl0bGUgJiZcclxuICAgICAgICAgICAgICAgICAgICA8Q2xvbmVcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50PXt0aXRsZX1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZmFsbGJhY2s9XCJoMlwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT17Y3NzQ2xhc3Nlcy5USVRMRX1cclxuICAgICAgICAgICAgICAgICAgICAvPlxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHtzdWJ0aXRsZSAmJlxyXG4gICAgICAgICAgICAgICAgICAgIDxDbG9uZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb21wb25lbnQ9e3N1YnRpdGxlfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmYWxsYmFjaz1cImgzXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPXtjc3NDbGFzc2VzLlNVQlRJVExFfVxyXG4gICAgICAgICAgICAgICAgICAgIC8+XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAge2NoaWxkcmVufVxyXG4gICAgICAgICAgICA8L2Rpdj5cclxuXHJcbiAgICAgICAgICAgIHthY3Rpb25zICYmXHJcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17Y3NzQ2xhc3Nlcy5IRUFERVJfQUNUSU9OU30+XHJcbiAgICAgICAgICAgICAgICAgICAge0NoaWxkcmVuLm1hcChhY3Rpb25zLCBhY3Rpb24gPT5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPENsb25lXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21wb25lbnQ9e2FjdGlvbn1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT17Y3NzQ2xhc3Nlcy5BQ1RJT059XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8+XHJcbiAgICAgICAgICAgICAgICAgICAgKX1cclxuICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgPC9FbGVtZW50PlxyXG4gICAgKTtcclxufSk7XHJcblxyXG5DYXJkSGVhZGVyLmRpc3BsYXlOYW1lID0gJ01EQ0NhcmRIZWFkZXInO1xyXG5cclxuQ2FyZEhlYWRlci5wcm9wVHlwZXMgPSB7XHJcbiAgICB0aXRsZTogUHJvcFR5cGVzLm5vZGUsXHJcbiAgICBzdWJ0aXRsZTogUHJvcFR5cGVzLm5vZGUsXHJcbiAgICBvdmVybGluZTogUHJvcFR5cGVzLm5vZGUsXHJcbiAgICBncmFwaGljOiBQcm9wVHlwZXMuZWxlbWVudCxcclxuICAgIGFjdGlvbnM6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1xyXG4gICAgICAgIFByb3BUeXBlcy5lbGVtZW50LFxyXG4gICAgICAgIFByb3BUeXBlcy5hcnJheU9mKFByb3BUeXBlcy5lbGVtZW50KVxyXG4gICAgXSlcclxufTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IENhcmRIZWFkZXI7IiwiaW1wb3J0IHsgZm9yd2FyZFJlZiB9IGZyb20gJ3JlYWN0JztcclxuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcclxuaW1wb3J0IGNsYXNzbmFtZXMgZnJvbSAnY2xhc3NuYW1lcyc7XHJcblxyXG5pbXBvcnQgeyBjc3NDbGFzc2VzIH0gZnJvbSAnLi9jb25zdGFudHMnO1xyXG5cclxuY29uc3QgQ2FyZE1lZGlhID0gZm9yd2FyZFJlZigoe1xyXG4gICAgaW1hZ2VVcmwsXHJcbiAgICBjb250ZW50LFxyXG4gICAgc3F1YXJlID0gZmFsc2UsXHJcbiAgICB3aWRlID0gZmFsc2UsXHJcblxyXG4gICAgZWxlbWVudCA9ICdkaXYnLFxyXG4gICAgY29tcG9uZW50OiBFbGVtZW50ID0gZWxlbWVudCxcclxuICAgIGNsYXNzTmFtZSxcclxuICAgIGNoaWxkcmVuID0gY29udGVudCxcclxuICAgIC4uLnByb3BzXHJcbn0sIHJlZikgPT4ge1xyXG4gICAgY29uc3QgY2xhc3NOYW1lcyA9IGNsYXNzbmFtZXMoY3NzQ2xhc3Nlcy5NRURJQSwge1xyXG4gICAgICAgIFtjc3NDbGFzc2VzLk1FRElBX1NRVUFSRV06IHNxdWFyZSxcclxuICAgICAgICBbY3NzQ2xhc3Nlcy5NRURJQV9XSURFXTogd2lkZSxcclxuICAgIH0sIGNsYXNzTmFtZSk7XHJcblxyXG4gICAgY29uc3Qgc3R5bGUgPSBpbWFnZVVybCA/IHtcclxuICAgICAgICBiYWNrZ3JvdW5kSW1hZ2U6IGB1cmwoJHtpbWFnZVVybH0pYFxyXG4gICAgfSA6IHVuZGVmaW5lZDtcclxuXHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAgIDxFbGVtZW50IHJlZj17cmVmfSBjbGFzc05hbWU9e2NsYXNzTmFtZXN9IHN0eWxlPXtzdHlsZX0gey4uLnByb3BzfT5cclxuICAgICAgICAgICAge2NoaWxkcmVuICYmXHJcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17Y3NzQ2xhc3Nlcy5NRURJQV9DT05URU5UfT57Y2hpbGRyZW59PC9kaXY+XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICA8L0VsZW1lbnQ+XHJcbiAgICApO1xyXG59KTtcclxuXHJcbkNhcmRNZWRpYS5kaXNwbGF5TmFtZSA9ICdNRENDYXJkTWVkaWEnO1xyXG5cclxuQ2FyZE1lZGlhLnByb3BUeXBlcyA9IHtcclxuICAgIGltYWdlVXJsOiBQcm9wVHlwZXMuc3RyaW5nLFxyXG4gICAgY29udGVudDogUHJvcFR5cGVzLm5vZGUsXHJcbiAgICBzcXVhcmU6IFByb3BUeXBlcy5ib29sLFxyXG4gICAgd2lkZTogUHJvcFR5cGVzLmJvb2xcclxufTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IENhcmRNZWRpYTsiLCJpbXBvcnQgeyBmb3J3YXJkUmVmIH0gZnJvbSAncmVhY3QnO1xyXG5pbXBvcnQgY2xhc3NuYW1lcyBmcm9tICdjbGFzc25hbWVzJztcclxuXHJcbmltcG9ydCB7IGNzc0NsYXNzZXMgfSBmcm9tICcuL2NvbnN0YW50cyc7XHJcblxyXG5jb25zdCBDYXJkUHJpbWFyeUFjdGlvbiA9IGZvcndhcmRSZWYoKHtcclxuICAgIGVsZW1lbnQgPSAnZGl2JyxcclxuICAgIGNvbXBvbmVudDogRWxlbWVudCA9IGVsZW1lbnQsXHJcbiAgICBjbGFzc05hbWUsXHJcbiAgICBjaGlsZHJlbixcclxuICAgIC4uLnByb3BzXHJcbn0sIHJlZikgPT4ge1xyXG4gICAgY29uc3QgY2xhc3NOYW1lcyA9IGNsYXNzbmFtZXMoY3NzQ2xhc3Nlcy5QUklNQVJZX0FDVElPTiwgY2xhc3NOYW1lKTtcclxuXHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAgIDxFbGVtZW50IHJlZj17cmVmfSBjbGFzc05hbWU9e2NsYXNzTmFtZXN9IHRhYkluZGV4PVwiMFwiIHsuLi5wcm9wc30+XHJcbiAgICAgICAgICAgIHtjaGlsZHJlbn1cclxuXHJcbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXtjc3NDbGFzc2VzLlJJUFBMRX0gLz5cclxuICAgICAgICA8L0VsZW1lbnQ+XHJcbiAgICApO1xyXG59KTtcclxuXHJcbkNhcmRQcmltYXJ5QWN0aW9uLmRpc3BsYXlOYW1lID0gJ01EQ0NhcmRQcmltYXJ5QWN0aW9uJztcclxuXHJcbmV4cG9ydCBkZWZhdWx0IENhcmRQcmltYXJ5QWN0aW9uOyIsImltcG9ydCB7IGZvcndhcmRSZWYgfSBmcm9tICdyZWFjdCc7XHJcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XHJcbmltcG9ydCBjbGFzc25hbWVzIGZyb20gJ2NsYXNzbmFtZXMnO1xyXG5cclxuaW1wb3J0IHsgY3NzQ2xhc3NlcyB9IGZyb20gJy4vY29uc3RhbnRzJztcclxuXHJcbmNvbnN0IENhcmRTZWN0aW9uID0gZm9yd2FyZFJlZigoe1xyXG4gICAgcHJpbWFyeSA9IGZhbHNlLFxyXG4gICAgc2Vjb25kYXJ5ID0gZmFsc2UsXHJcblxyXG4gICAgZWxlbWVudCA9ICdkaXYnLFxyXG4gICAgY29tcG9uZW50OiBFbGVtZW50ID0gZWxlbWVudCxcclxuICAgIGNsYXNzTmFtZSxcclxuICAgIC4uLnByb3BzXHJcbn0sIHJlZikgPT4ge1xyXG4gICAgY29uc3QgY2xhc3NOYW1lcyA9IGNsYXNzbmFtZXMoY3NzQ2xhc3Nlcy5TRUNUSU9OLCB7XHJcbiAgICAgICAgW2Nzc0NsYXNzZXMuU0VDVElPTl9QUklNQVJZXTogcHJpbWFyeSxcclxuICAgICAgICBbY3NzQ2xhc3Nlcy5TRUNUSU9OX1NFQ09OREFSWV06IHNlY29uZGFyeSxcclxuICAgIH0sIGNsYXNzTmFtZSk7XHJcblxyXG4gICAgcmV0dXJuIChcclxuICAgICAgICA8RWxlbWVudCByZWY9e3JlZn0gY2xhc3NOYW1lPXtjbGFzc05hbWVzfSB7Li4ucHJvcHN9IC8+XHJcbiAgICApO1xyXG59KTtcclxuXHJcbkNhcmRTZWN0aW9uLmRpc3BsYXlOYW1lID0gJ01EQ0NhcmRTZWN0aW9uJztcclxuXHJcbkNhcmRTZWN0aW9uLnByb3BUeXBlcyA9IHtcclxuICAgIHByaW1hcnk6IFByb3BUeXBlcy5ib29sLFxyXG4gICAgc2Vjb25kYXJ5OiBQcm9wVHlwZXMuYm9vbFxyXG59O1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgQ2FyZFNlY3Rpb247IiwiaW1wb3J0IENhcmQgZnJvbSAnLi9DYXJkJztcclxuaW1wb3J0IENhcmRBY3Rpb24gZnJvbSAnLi9DYXJkQWN0aW9uJztcclxuaW1wb3J0IENhcmRBY3Rpb25zIGZyb20gJy4vQ2FyZEFjdGlvbnMnO1xyXG5pbXBvcnQgQ2FyZEFjdGlvbkJ1dHRvbnMgZnJvbSAnLi9DYXJkQWN0aW9uQnV0dG9ucyc7XHJcbmltcG9ydCBDYXJkQWN0aW9uSWNvbnMgZnJvbSAnLi9DYXJkQWN0aW9uSWNvbnMnO1xyXG5pbXBvcnQgQ2FyZEhlYWRlciBmcm9tICcuL0NhcmRIZWFkZXInO1xyXG5pbXBvcnQgQ2FyZE1lZGlhIGZyb20gJy4vQ2FyZE1lZGlhJztcclxuaW1wb3J0IENhcmRQcmltYXJ5QWN0aW9uIGZyb20gJy4vQ2FyZFByaW1hcnlBY3Rpb24nO1xyXG5pbXBvcnQgQ2FyZFNlY3Rpb24gZnJvbSAnLi9DYXJkU2VjdGlvbic7XHJcblxyXG5DYXJkLkFjdGlvbiA9IENhcmRBY3Rpb247XHJcbkNhcmQuQWN0aW9ucyA9IENhcmRBY3Rpb25zO1xyXG5DYXJkLkFjdGlvbkJ1dHRvbnMgPSBDYXJkQWN0aW9uQnV0dG9ucztcclxuQ2FyZC5BY3Rpb25JY29ucyA9IENhcmRBY3Rpb25JY29ucztcclxuQ2FyZC5IZWFkZXIgPSBDYXJkSGVhZGVyO1xyXG5DYXJkLk1lZGlhID0gQ2FyZE1lZGlhO1xyXG5DYXJkLlByaW1hcnlBY3Rpb24gPSBDYXJkUHJpbWFyeUFjdGlvbjtcclxuQ2FyZC5TZWN0aW9uID0gQ2FyZFNlY3Rpb247XHJcblxyXG5leHBvcnQge1xyXG4gICAgQ2FyZCBhcyBkZWZhdWx0LFxyXG4gICAgQ2FyZEFjdGlvbixcclxuICAgIENhcmRBY3Rpb25zLFxyXG4gICAgQ2FyZEFjdGlvbkJ1dHRvbnMsXHJcbiAgICBDYXJkQWN0aW9uSWNvbnMsXHJcbiAgICBDYXJkSGVhZGVyLFxyXG4gICAgQ2FyZE1lZGlhLFxyXG4gICAgQ2FyZFByaW1hcnlBY3Rpb24sXHJcbiAgICBDYXJkU2VjdGlvblxyXG59OyIsImV4cG9ydCBjb25zdCBjc3NDbGFzc2VzID0ge1xyXG4gICAgUk9PVDogJ21kYy1jaGVja2JveCcsXHJcbiAgICBTRUxFQ1RFRDogJ21kYy1jaGVja2JveC0tc2VsZWN0ZWQnLFxyXG4gICAgVE9VQ0g6ICdtZGMtY2hlY2tib3gtLXRvdWNoJyxcclxuICAgIERJU0FCTEVEOiAnbWRjLWNoZWNrYm94LS1kaXNhYmxlZCcsXHJcbiAgICBBTklNX0NIRUNLRURfSU5ERVRFUk1JTkFURTogJ21kYy1jaGVja2JveC0tYW5pbS1jaGVja2VkLWluZGV0ZXJtaW5hdGUnLFxyXG4gICAgQU5JTV9DSEVDS0VEX1VOQ0hFQ0tFRDogJ21kYy1jaGVja2JveC0tYW5pbS1jaGVja2VkLXVuY2hlY2tlZCcsXHJcbiAgICBBTklNX0lOREVURVJNSU5BVEVfQ0hFQ0tFRDogJ21kYy1jaGVja2JveC0tYW5pbS1pbmRldGVybWluYXRlLWNoZWNrZWQnLFxyXG4gICAgQU5JTV9JTkRFVEVSTUlOQVRFX1VOQ0hFQ0tFRDogJ21kYy1jaGVja2JveC0tYW5pbS1pbmRldGVybWluYXRlLXVuY2hlY2tlZCcsXHJcbiAgICBBTklNX1VOQ0hFQ0tFRF9DSEVDS0VEOiAnbWRjLWNoZWNrYm94LS1hbmltLXVuY2hlY2tlZC1jaGVja2VkJyxcclxuICAgIEFOSU1fVU5DSEVDS0VEX0lOREVURVJNSU5BVEU6ICdtZGMtY2hlY2tib3gtLWFuaW0tdW5jaGVja2VkLWluZGV0ZXJtaW5hdGUnLFxyXG5cclxuICAgIE5BVElWRV9DT05UUk9MOiAnbWRjLWNoZWNrYm94X19uYXRpdmUtY29udHJvbCcsXHJcbiAgICBCQUNLR1JPVU5EOiAnbWRjLWNoZWNrYm94X19iYWNrZ3JvdW5kJyxcclxuICAgIENIRUNLTUFSSzogJ21kYy1jaGVja2JveF9fY2hlY2ttYXJrJyxcclxuICAgIENIRUNLTUFSS19QQVRIOiAnbWRjLWNoZWNrYm94X19jaGVja21hcmstcGF0aCcsXHJcbiAgICBNSVhFRE1BUks6ICdtZGMtY2hlY2tib3hfX21peGVkbWFyaycsXHJcbiAgICBSSVBQTEU6ICdtZGMtY2hlY2tib3hfX3JpcHBsZSdcclxufTsiLCJpbXBvcnQgeyBmb3J3YXJkUmVmLCB1c2VSZWYsIHVzZUVmZmVjdCwgdXNlQ2FsbGJhY2sgfSBmcm9tICdyZWFjdCc7XHJcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XHJcbmltcG9ydCBjbGFzc25hbWVzIGZyb20gJ2NsYXNzbmFtZXMnO1xyXG5cclxuaW1wb3J0IHsgY3NzQ2xhc3NlcyB9IGZyb20gJy4vY29uc3RhbnRzJztcclxuXHJcbmNvbnN0IENoZWNrYm94ID0gZm9yd2FyZFJlZigoe1xyXG4gICAgY2hlY2tlZCxcclxuICAgIGluZGV0ZXJtaW5hdGUsXHJcbiAgICBkaXNhYmxlZCA9IGZhbHNlLFxyXG4gICAgdG91Y2ggPSBmYWxzZSxcclxuICAgIG9uQ2hhbmdlID0gRnVuY3Rpb24ucHJvdG90eXBlLFxyXG5cclxuICAgIGNsYXNzTmFtZSxcclxuICAgIC4uLnByb3BzXHJcbn0sIHJlZikgPT4ge1xyXG4gICAgY29uc3QgaW5wdXRSZWYgPSB1c2VSZWYoKTtcclxuXHJcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgICAgIGlucHV0UmVmLmN1cnJlbnQuaW5kZXRlcm1pbmF0ZSA9IGluZGV0ZXJtaW5hdGU7XHJcbiAgICB9LCBbaW5kZXRlcm1pbmF0ZV0pO1xyXG5cclxuICAgIGNvbnN0IGhhbmRsZUNoYW5nZSA9IHVzZUNhbGxiYWNrKGV2ZW50ID0+IHtcclxuICAgICAgICBvbkNoYW5nZShldmVudCwgZXZlbnQudGFyZ2V0LmNoZWNrZWQsIGV2ZW50LnRhcmdldCk7XHJcbiAgICB9LCBbb25DaGFuZ2VdKTtcclxuXHJcbiAgICBjb25zdCBjbGFzc05hbWVzID0gY2xhc3NuYW1lcyhjc3NDbGFzc2VzLlJPT1QsIHtcclxuICAgICAgICBbY3NzQ2xhc3Nlcy5TRUxFQ1RFRF06IGNoZWNrZWQsXHJcbiAgICAgICAgW2Nzc0NsYXNzZXMuRElTQUJMRURdOiBkaXNhYmxlZCxcclxuICAgICAgICBbY3NzQ2xhc3Nlcy5UT1VDSF06IHRvdWNoXHJcbiAgICB9LCBjbGFzc05hbWUpO1xyXG5cclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgPGRpdiByZWY9e3JlZn0gY2xhc3NOYW1lPXtjbGFzc05hbWVzfT5cclxuICAgICAgICAgICAgPGlucHV0XHJcbiAgICAgICAgICAgICAgICByZWY9e2lucHV0UmVmfVxyXG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lPXtjc3NDbGFzc2VzLk5BVElWRV9DT05UUk9MfVxyXG4gICAgICAgICAgICAgICAgdHlwZT1cImNoZWNrYm94XCJcclxuICAgICAgICAgICAgICAgIGNoZWNrZWQ9e2NoZWNrZWR9XHJcbiAgICAgICAgICAgICAgICBkaXNhYmxlZD17ZGlzYWJsZWR9XHJcbiAgICAgICAgICAgICAgICBvbkNoYW5nZT17aGFuZGxlQ2hhbmdlfVxyXG4gICAgICAgICAgICAgICAgey4uLnByb3BzfVxyXG4gICAgICAgICAgICAvPlxyXG5cclxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9e2Nzc0NsYXNzZXMuQkFDS0dST1VORH0+XHJcbiAgICAgICAgICAgICAgICA8c3ZnIGNsYXNzTmFtZT17Y3NzQ2xhc3Nlcy5DSEVDS01BUkt9IHZpZXdCb3g9XCIwIDAgMjQgMjRcIj5cclxuICAgICAgICAgICAgICAgICAgICA8cGF0aCBjbGFzc05hbWU9e2Nzc0NsYXNzZXMuQ0hFQ0tNQVJLX1BBVEh9IGZpbGw9XCJub25lXCIgZD1cIk0xLjczLDEyLjkxIDguMSwxOS4yOCAyMi43OSw0LjU5XCIgLz5cclxuICAgICAgICAgICAgICAgIDwvc3ZnPlxyXG5cclxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXtjc3NDbGFzc2VzLk1JWEVETUFSS30gLz5cclxuICAgICAgICAgICAgPC9kaXY+XHJcblxyXG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17Y3NzQ2xhc3Nlcy5SSVBQTEV9IC8+XHJcbiAgICAgICAgPC9kaXY+XHJcbiAgICApO1xyXG59KTtcclxuXHJcbkNoZWNrYm94LmRpc3BsYXlOYW1lID0gJ01EQ0NoZWNrYm94JztcclxuXHJcbkNoZWNrYm94LnByb3BUeXBlcyA9IHtcclxuICAgIGNoZWNrZWQ6IFByb3BUeXBlcy5ib29sLFxyXG4gICAgaW5kZXRlcm1pbmF0ZTogUHJvcFR5cGVzLmJvb2wsXHJcbiAgICBkaXNhYmxlZDogUHJvcFR5cGVzLmJvb2wsXHJcbiAgICB0b3VjaDogUHJvcFR5cGVzLmJvb2wsXHJcbiAgICBvbkNoYW5nZTogUHJvcFR5cGVzLmZ1bmNcclxufTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IENoZWNrYm94OyIsImV4cG9ydCB7IGRlZmF1bHQgfSBmcm9tICcuL0NoZWNrYm94JzsiLCJleHBvcnQgY29uc3QgbnVtYmVycyA9IHtcclxuICAgIFNFTEVDVElOR19BTklNQVRJT05fTVM6IDE1MCxcclxuICAgIERFU0VMRUNUSU5HX0FOSU1BVElPTl9NUzogMTAwXHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgY2hpcFNldENzc0NsYXNzZXMgPSB7XHJcbiAgICBST09UOiAnbWRjLWV2b2x1dGlvbi1jaGlwLXNldCcsXHJcbiAgICBPVkVSRkxPVzogJ21kYy1ldm9sdXRpb24tY2hpcC1zZXQtLW92ZXJmbG93JyxcclxuICAgIENISVBTOiAnbWRjLWV2b2x1dGlvbi1jaGlwLXNldF9fY2hpcHMnXHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgY2hpcENzc0NsYXNzZXMgPSB7XHJcbiAgICBST09UOiAnbWRjLWV2b2x1dGlvbi1jaGlwJyxcclxuICAgIEZJTFRFUjogJ21kYy1ldm9sdXRpb24tY2hpcC0tZmlsdGVyJyxcclxuICAgIFNFTEVDVEFCTEU6ICdtZGMtZXZvbHV0aW9uLWNoaXAtLXNlbGVjdGFibGUnLFxyXG4gICAgU0VMRUNURUQ6ICdtZGMtZXZvbHV0aW9uLWNoaXAtLXNlbGVjdGVkJyxcclxuICAgIFNFTEVDVElORzogJ21kYy1ldm9sdXRpb24tY2hpcC0tc2VsZWN0aW5nJyxcclxuICAgIFNFTEVDVElOR19XSVRIX1BSSU1BUllfSUNPTjogJ21kYy1ldm9sdXRpb24tY2hpcC0tc2VsZWN0aW5nLXdpdGgtcHJpbWFyeS1pY29uJyxcclxuICAgIERFU0VMRUNUSU5HOiAnbWRjLWV2b2x1dGlvbi1jaGlwLS1kZXNlbGVjdGluZycsXHJcbiAgICBERVNFTEVDVElOR19XSVRIX1BSSU1BUllfSUNPTjogJ21kYy1ldm9sdXRpb24tY2hpcC0tZGVzZWxlY3Rpbmctd2l0aC1wcmltYXJ5LWljb24nLFxyXG4gICAgT1VUTElORUQ6ICdtZGMtZXZvbHV0aW9uLWNoaXAtLW91dGxpbmVkJyxcclxuICAgIEVOVEVSOiAnbWRjLWV2b2x1dGlvbi1jaGlwLS1lbnRlcicsXHJcbiAgICBFWElUOiAnbWRjLWV2b2x1dGlvbi1jaGlwLS1leGl0JyxcclxuICAgIEhJRERFTjogJ21kYy1ldm9sdXRpb24tY2hpcC0taGlkZGVuJyxcclxuICAgIERJU0FCTEVEOiAnbWRjLWV2b2x1dGlvbi1jaGlwLS1kaXNhYmxlZCcsXHJcbiAgICBUT1VDSDogJ21kYy1ldm9sdXRpb24tY2hpcC0tdG91Y2gnLFxyXG4gICAgV0lUSF9QUklNQVJZX0dSQVBISUM6ICdtZGMtZXZvbHV0aW9uLWNoaXAtLXdpdGgtcHJpbWFyeS1ncmFwaGljJyxcclxuICAgIFdJVEhfUFJJTUFSWV9JQ09OOiAnbWRjLWV2b2x1dGlvbi1jaGlwLS13aXRoLXByaW1hcnktaWNvbicsXHJcbiAgICBXSVRIX1RSQUlMSU5HX0FDVElPTjogJ21kYy1ldm9sdXRpb24tY2hpcC0td2l0aC10cmFpbGluZy1hY3Rpb24nLFxyXG4gICAgV0lUSF9BVkFUQVI6ICdtZGMtZXZvbHV0aW9uLWNoaXAtLXdpdGgtYXZhdGFyJyxcclxuXHJcbiAgICBDRUxMOiAnbWRjLWV2b2x1dGlvbi1jaGlwX19jZWxsJyxcclxuICAgIFBSSU1BUllfQ0VMTDogJ21kYy1ldm9sdXRpb24tY2hpcF9fY2VsbC0tcHJpbWFyeScsXHJcbiAgICBUUkFJTElOR19DRUxMOiAnbWRjLWV2b2x1dGlvbi1jaGlwX19jZWxsLS10cmFpbGluZycsXHJcblxyXG4gICAgQUNUSU9OOiAnbWRjLWV2b2x1dGlvbi1jaGlwX19hY3Rpb24nLFxyXG4gICAgUFJJTUFSWV9BQ1RJT046ICdtZGMtZXZvbHV0aW9uLWNoaXBfX2FjdGlvbi0tcHJpbWFyeScsXHJcbiAgICBUUkFJTElOR19BQ1RJT046ICdtZGMtZXZvbHV0aW9uLWNoaXBfX2FjdGlvbi0tdHJhaWxpbmcnLFxyXG4gICAgUFJFU0VOVEFUSU9OQUxfQUNUSU9OOiAnbWRjLWV2b2x1dGlvbi1jaGlwX19hY3Rpb24tLXByZXNlbnRhdGlvbmFsJyxcclxuICAgIEFDVElPTl9UT1VDSDogJ21kYy1ldm9sdXRpb24tY2hpcF9fYWN0aW9uLXRvdWNoJyxcclxuXHJcbiAgICBSSVBQTEU6ICdtZGMtZXZvbHV0aW9uLWNoaXBfX3JpcHBsZScsXHJcbiAgICBQUklNQVJZX1JJUFBMRTogJ21kYy1ldm9sdXRpb24tY2hpcF9fcmlwcGxlLS1wcmltYXJ5JyxcclxuICAgIFRSQUlMSU5HX1JJUFBMRTogJ21kYy1ldm9sdXRpb24tY2hpcF9fcmlwcGxlLS10cmFpbGluZycsXHJcblxyXG4gICAgR1JBUEhJQzogJ21kYy1ldm9sdXRpb24tY2hpcF9fZ3JhcGhpYycsXHJcbiAgICBJQ09OOiAnbWRjLWV2b2x1dGlvbi1jaGlwX19pY29uJyxcclxuICAgIFBSSU1BUllfSUNPTjogJ21kYy1ldm9sdXRpb24tY2hpcF9faWNvbi0tcHJpbWFyeScsXHJcbiAgICBUUkFJTElOR19JQ09OOiAnbWRjLWV2b2x1dGlvbi1jaGlwX19pY29uLS10cmFpbGluZycsXHJcbiAgICBURVhUX0xBQkVMOiAnbWRjLWV2b2x1dGlvbi1jaGlwX190ZXh0LWxhYmVsJyxcclxuICAgIENIRUNLTUFSSzogJ21kYy1ldm9sdXRpb24tY2hpcF9fY2hlY2ttYXJrJyxcclxuICAgIENIRUNLTUFSS19TVkc6ICdtZGMtZXZvbHV0aW9uLWNoaXBfX2NoZWNrbWFyay1zdmcnLFxyXG4gICAgQ0hFQ0tNQVJLX1BBVEg6ICdtZGMtZXZvbHV0aW9uLWNoaXBfX2NoZWNrbWFyay1wYXRoJ1xyXG59OyIsImltcG9ydCBjbGFzc25hbWVzIGZyb20gJ2NsYXNzbmFtZXMnO1xyXG5cclxuaW1wb3J0IHsgQ2xvbmUgfSBmcm9tICcuLi9jb21wb25lbnQnO1xyXG5pbXBvcnQgSWNvbiBmcm9tICcuLi9pY29uJztcclxuXHJcbmltcG9ydCB7IGNoaXBDc3NDbGFzc2VzIGFzIGNzc0NsYXNzZXMgfSBmcm9tICcuL2NvbnN0YW50cyc7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBDaGlwUHJpbWFyeUFjdGlvbih7XHJcbiAgICB0ZXh0LFxyXG4gICAgZ3JhcGhpYyxcclxuICAgIGljb24sXHJcbiAgICBwcmVzZW50YXRpb25hbCA9IGZhbHNlLFxyXG4gICAgc2VsZWN0YWJsZSA9IGZhbHNlLFxyXG4gICAgc2VsZWN0ZWQgPSBmYWxzZSxcclxuICAgIGRpc2FibGVkID0gZmFsc2UsXHJcblxyXG4gICAgZWxlbWVudCA9ICdidXR0b24nLFxyXG4gICAgY29tcG9uZW50OiBFbGVtZW50ID0gZWxlbWVudCxcclxuICAgIGNoaWxkcmVuID0gdGV4dCxcclxuICAgIC4uLnByb3BzXHJcbn0pIHtcclxuICAgIGNvbnN0IGlzQnV0dG9uID0gRWxlbWVudCA9PT0gJ2J1dHRvbic7XHJcbiAgICBjb25zdCBjbGFzc05hbWVzID0gY2xhc3NuYW1lcyhjc3NDbGFzc2VzLkFDVElPTiwgY3NzQ2xhc3Nlcy5QUklNQVJZX0FDVElPTiwge1xyXG4gICAgICAgIFtjc3NDbGFzc2VzLlBSRVNFTlRBVElPTkFMX0FDVElPTl06IHByZXNlbnRhdGlvbmFsXHJcbiAgICB9KTtcclxuXHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAgIDxFbGVtZW50XHJcbiAgICAgICAgICAgIGNsYXNzTmFtZT17Y2xhc3NOYW1lc31cclxuICAgICAgICAgICAgdHlwZT17aXNCdXR0b24gPyAnYnV0dG9uJyA6IHVuZGVmaW5lZH1cclxuICAgICAgICAgICAgZGlzYWJsZWQ9e2lzQnV0dG9uICYmIGRpc2FibGVkfVxyXG4gICAgICAgICAgICB0YWJJbmRleD17ZGlzYWJsZWQgPyAnLTEnIDogJzAnfVxyXG4gICAgICAgICAgICByb2xlPXshaXNCdXR0b24gPyAnb3B0aW9uJyA6IHVuZGVmaW5lZH1cclxuICAgICAgICAgICAgYXJpYS1zZWxlY3RlZD17IWlzQnV0dG9uID8gc2VsZWN0ZWQgOiB1bmRlZmluZWR9XHJcbiAgICAgICAgICAgIGFyaWEtZGlzYWJsZWQ9eyFpc0J1dHRvbiA/IGRpc2FibGVkIDogdW5kZWZpbmVkfVxyXG4gICAgICAgICAgICB7Li4ucHJvcHN9XHJcbiAgICAgICAgPlxyXG4gICAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9e2Ake2Nzc0NsYXNzZXMuUklQUExFfSAke2Nzc0NsYXNzZXMuUFJJTUFSWV9SSVBQTEV9YH0gLz5cclxuXHJcbiAgICAgICAgICAgIHsoZ3JhcGhpYyB8fCBpY29uIHx8IHNlbGVjdGFibGUpICYmXHJcbiAgICAgICAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9e2Nzc0NsYXNzZXMuR1JBUEhJQ30+XHJcbiAgICAgICAgICAgICAgICAgICAge2dyYXBoaWN9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHtpY29uICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxDbG9uZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50PXtpY29ufVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmFsbGJhY2s9e0ljb259XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU9e2Ake2Nzc0NsYXNzZXMuSUNPTn0gJHtjc3NDbGFzc2VzLlBSSU1BUllfSUNPTn1gfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvPlxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAge3NlbGVjdGFibGUgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3NOYW1lPXtjc3NDbGFzc2VzLkNIRUNLTUFSS30+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3ZnIGNsYXNzTmFtZT17Y3NzQ2xhc3Nlcy5DSEVDS01BUktfU1ZHfSB2aWV3Qm94PVwiLTIgLTMgMzAgMzBcIj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8cGF0aFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU9e2Nzc0NsYXNzZXMuQ0hFQ0tNQVJLX1BBVEh9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbGw9XCJub25lXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3Ryb2tlPVwiYmxhY2tcIiBkPVwiTTEuNzMsMTIuOTEgOC4xLDE5LjI4IDIyLjc5LDQuNTlcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L3N2Zz5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPC9zcGFuPlxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIDwvc3Bhbj5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgPHNwYW4gY2xhc3NOYW1lPXtjc3NDbGFzc2VzLlRFWFRfTEFCRUx9PntjaGlsZHJlbn08L3NwYW4+XHJcbiAgICAgICAgPC9FbGVtZW50PlxyXG4gICAgKTtcclxufSIsImltcG9ydCBjbGFzc25hbWVzIGZyb20gJ2NsYXNzbmFtZXMnO1xyXG5cclxuaW1wb3J0IHsgQ2xvbmUgfSBmcm9tICcuLi9jb21wb25lbnQnO1xyXG5pbXBvcnQgSWNvbiBmcm9tICcuLi9pY29uJztcclxuXHJcbmltcG9ydCB7IGNoaXBDc3NDbGFzc2VzIGFzIGNzc0NsYXNzZXMgfSBmcm9tICcuL2NvbnN0YW50cyc7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBDaGlwVHJhaWxpbmdBY3Rpb24oe1xyXG4gICAgaWNvbixcclxuICAgIHByZXNlbnRhdGlvbmFsID0gZmFsc2UsXHJcbiAgICAuLi5wcm9wc1xyXG59KSB7XHJcbiAgICBjb25zdCBjbGFzc05hbWVzID0gY2xhc3NuYW1lcyhjc3NDbGFzc2VzLkFDVElPTiwgY3NzQ2xhc3Nlcy5UUkFJTElOR19BQ1RJT04sIHtcclxuICAgICAgICBbY3NzQ2xhc3Nlcy5QUkVTRU5UQVRJT05BTF9BQ1RJT05dOiBwcmVzZW50YXRpb25hbFxyXG4gICAgfSk7XHJcblxyXG4gICAgcmV0dXJuIChcclxuICAgICAgICA8YnV0dG9uXHJcbiAgICAgICAgICAgIGNsYXNzTmFtZT17Y2xhc3NOYW1lc31cclxuICAgICAgICAgICAgdHlwZT1cImJ1dHRvblwiXHJcbiAgICAgICAgICAgIHRhYkluZGV4PVwiLTFcIlxyXG4gICAgICAgICAgICBhcmlhLWhpZGRlbj1cInRydWVcIlxyXG4gICAgICAgICAgICB7Li4ucHJvcHN9XHJcbiAgICAgICAgPlxyXG4gICAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9e2Ake2Nzc0NsYXNzZXMuUklQUExFfSAke2Nzc0NsYXNzZXMuVFJBSUxJTkdfUklQUExFfWB9IC8+XHJcblxyXG4gICAgICAgICAgICA8Q2xvbmVcclxuICAgICAgICAgICAgICAgIGNvbXBvbmVudD17aWNvbn1cclxuICAgICAgICAgICAgICAgIGZhbGxiYWNrPXtJY29ufVxyXG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lPXtgJHtjc3NDbGFzc2VzLklDT059ICR7Y3NzQ2xhc3Nlcy5UUkFJTElOR19JQ09OfWB9XHJcbiAgICAgICAgICAgIC8+XHJcbiAgICAgICAgPC9idXR0b24+XHJcbiAgICApO1xyXG59IiwiaW1wb3J0IHsgZm9yd2FyZFJlZiB9IGZyb20gJ3JlYWN0JztcclxuaW1wb3J0IHsgQ1NTVHJhbnNpdGlvbiB9IGZyb20gJ3JlYWN0LXRyYW5zaXRpb24tZ3JvdXAnO1xyXG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xyXG5pbXBvcnQgY2xhc3NuYW1lcyBmcm9tICdjbGFzc25hbWVzJztcclxuXHJcbmltcG9ydCB7IG51bWJlcnMsIGNoaXBDc3NDbGFzc2VzIGFzIGNzc0NsYXNzZXMgfSBmcm9tICcuL2NvbnN0YW50cyc7XHJcbmltcG9ydCBDaGlwUHJpbWFyeUFjdGlvbiBmcm9tICcuL0NoaXBQcmltYXJ5QWN0aW9uJztcclxuaW1wb3J0IENoaXBUcmFpbGluZ0FjdGlvbiBmcm9tICcuL0NoaXBUcmFpbGluZ0FjdGlvbic7XHJcblxyXG5jb25zdCBDaGlwID0gZm9yd2FyZFJlZigoe1xyXG4gICAgdmFsdWUsXHJcbiAgICB0ZXh0LFxyXG4gICAgaWNvbixcclxuICAgIGF2YXRhcixcclxuICAgIGdyYXBoaWMgPSBhdmF0YXIsXHJcbiAgICBwcmltYXJ5SWNvbiA9IGljb24sXHJcbiAgICB0cmFpbGluZ0ljb24sXHJcbiAgICBzZWxlY3RhYmxlID0gZmFsc2UsXHJcbiAgICBmaWx0ZXIgPSBmYWxzZSxcclxuICAgIHNlbGVjdGVkID0gZmFsc2UsXHJcbiAgICBvdXRsaW5lZCA9IGZhbHNlLFxyXG4gICAgZGlzYWJsZWQgPSBmYWxzZSxcclxuICAgIHRvdWNoID0gZmFsc2UsXHJcbiAgICB3aXRoQXZhdGFyID0gQm9vbGVhbihhdmF0YXIpLFxyXG5cclxuICAgIGVsZW1lbnQgPSAnc3BhbicsXHJcbiAgICBjb21wb25lbnQ6IEVsZW1lbnQgPSBlbGVtZW50LFxyXG4gICAgY2xhc3NOYW1lLFxyXG4gICAgLi4ucHJvcHNcclxufSwgcmVmKSA9PiB7XHJcbiAgICBjb25zdCB3aXRoUHJpbWFyeUdyYXBoaWMgPSBzZWxlY3RhYmxlIHx8IEJvb2xlYW4oZ3JhcGhpYykgfHwgQm9vbGVhbihwcmltYXJ5SWNvbik7XHJcbiAgICBjb25zdCB3aXRoUHJpbWFyeUljb24gPSBCb29sZWFuKHByaW1hcnlJY29uKTtcclxuICAgIGNvbnN0IHdpdGhUcmFpbGluZ0FjdGlvbiA9IEJvb2xlYW4odHJhaWxpbmdJY29uKTtcclxuXHJcbiAgICBjb25zdCBjbGFzc05hbWVzID0gY2xhc3NuYW1lcyhjc3NDbGFzc2VzLlJPT1QsIHtcclxuICAgICAgICBbY3NzQ2xhc3Nlcy5TRUxFQ1RBQkxFXTogc2VsZWN0YWJsZSxcclxuICAgICAgICBbY3NzQ2xhc3Nlcy5GSUxURVJdOiBmaWx0ZXIsXHJcbiAgICAgICAgW2Nzc0NsYXNzZXMuT1VUTElORURdOiBvdXRsaW5lZCxcclxuICAgICAgICBbY3NzQ2xhc3Nlcy5ESVNBQkxFRF06IGRpc2FibGVkLFxyXG4gICAgICAgIFtjc3NDbGFzc2VzLlRPVUNIXTogdG91Y2gsXHJcbiAgICAgICAgW2Nzc0NsYXNzZXMuV0lUSF9QUklNQVJZX0dSQVBISUNdOiB3aXRoUHJpbWFyeUdyYXBoaWMsXHJcbiAgICAgICAgW2Nzc0NsYXNzZXMuV0lUSF9QUklNQVJZX0lDT05dOiB3aXRoUHJpbWFyeUljb24sXHJcbiAgICAgICAgW2Nzc0NsYXNzZXMuV0lUSF9UUkFJTElOR19BQ1RJT05dOiB3aXRoVHJhaWxpbmdBY3Rpb24sXHJcbiAgICAgICAgW2Nzc0NsYXNzZXMuV0lUSF9BVkFUQVJdOiB3aXRoQXZhdGFyXHJcbiAgICB9LCBjbGFzc05hbWUpO1xyXG5cclxuICAgIGNvbnN0IHNlbGVjdGluZ0NsYXNzID0gd2l0aFByaW1hcnlJY29uID8gY3NzQ2xhc3Nlcy5TRUxFQ1RJTkdfV0lUSF9QUklNQVJZX0lDT04gOiBjc3NDbGFzc2VzLlNFTEVDVElORztcclxuICAgIGNvbnN0IGRlc2VsZWN0aW5nQ2xhc3MgPSB3aXRoUHJpbWFyeUljb24gPyBjc3NDbGFzc2VzLkRFU0VMRUNUSU5HX1dJVEhfUFJJTUFSWV9JQ09OIDogY3NzQ2xhc3Nlcy5ERVNFTEVDVElORztcclxuXHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAgIDxDU1NUcmFuc2l0aW9uXHJcbiAgICAgICAgICAgIGluPXtzZWxlY3RlZH1cclxuICAgICAgICAgICAgYXBwZWFyXHJcbiAgICAgICAgICAgIHRpbWVvdXQ9e3tcclxuICAgICAgICAgICAgICAgIGVudGVyOiBudW1iZXJzLlNFTEVDVElOR19BTklNQVRJT05fTVMsXHJcbiAgICAgICAgICAgICAgICBleGl0OiBudW1iZXJzLkRFU0VMRUNUSU5HX0FOSU1BVElPTl9NU1xyXG4gICAgICAgICAgICB9fVxyXG4gICAgICAgICAgICBjbGFzc05hbWVzPXt7XHJcbiAgICAgICAgICAgICAgICBlbnRlcjogc2VsZWN0aW5nQ2xhc3MsXHJcbiAgICAgICAgICAgICAgICBlbnRlckFjdGl2ZTogYCR7Y3NzQ2xhc3Nlcy5TRUxFQ1RFRH0gJHtzZWxlY3RpbmdDbGFzc31gLFxyXG4gICAgICAgICAgICAgICAgZW50ZXJEb25lOiBjc3NDbGFzc2VzLlNFTEVDVEVELFxyXG4gICAgICAgICAgICAgICAgZXhpdDogZGVzZWxlY3RpbmdDbGFzcyxcclxuICAgICAgICAgICAgICAgIGV4aXRBY3RpdmU6IGRlc2VsZWN0aW5nQ2xhc3NcclxuICAgICAgICAgICAgfX1cclxuICAgICAgICA+XHJcbiAgICAgICAgICAgIDxFbGVtZW50XHJcbiAgICAgICAgICAgICAgICByZWY9e3JlZn1cclxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZT17Y2xhc3NOYW1lc31cclxuICAgICAgICAgICAgICAgIGRhdGEtdmFsdWU9e3ZhbHVlfVxyXG4gICAgICAgICAgICAgICAgcm9sZT17c2VsZWN0YWJsZSA/ICdwcmVzZW50YXRpb24nIDogJ3Jvdyd9XHJcbiAgICAgICAgICAgICAgICB7Li4ucHJvcHN9XHJcbiAgICAgICAgICAgID5cclxuICAgICAgICAgICAgICAgIHtzZWxlY3RhYmxlID9cclxuICAgICAgICAgICAgICAgICAgICA8Q2hpcFByaW1hcnlBY3Rpb25cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudD1cInNwYW5cIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0PXt0ZXh0fVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBncmFwaGljPXtncmFwaGljfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpY29uPXtwcmltYXJ5SWNvbn1cclxuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0YWJsZT17c2VsZWN0YWJsZX1cclxuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0ZWQ9e3NlbGVjdGVkfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBkaXNhYmxlZD17ZGlzYWJsZWR9XHJcbiAgICAgICAgICAgICAgICAgICAgLz5cclxuICAgICAgICAgICAgICAgICAgICA6XHJcbiAgICAgICAgICAgICAgICAgICAgPD5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3NOYW1lPXtgJHtjc3NDbGFzc2VzLkNFTEx9ICR7Y3NzQ2xhc3Nlcy5QUklNQVJZX0NFTEx9YH0gcm9sZT1cImdyaWRjZWxsXCI+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8Q2hpcFByaW1hcnlBY3Rpb25cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0PXt0ZXh0fVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdyYXBoaWM9e2dyYXBoaWN9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWNvbj17cHJpbWFyeUljb259XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlzYWJsZWQ9e2Rpc2FibGVkfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLz5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPC9zcGFuPlxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAge3RyYWlsaW5nSWNvbiAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3NOYW1lPXtgJHtjc3NDbGFzc2VzLkNFTEx9ICR7Y3NzQ2xhc3Nlcy5UUkFJTElOR19DRUxMfWB9IHJvbGU9XCJncmlkY2VsbFwiPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxDaGlwVHJhaWxpbmdBY3Rpb25cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWNvbj17dHJhaWxpbmdJY29ufVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXNhYmxlZD17ZGlzYWJsZWR9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLz5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvc3Bhbj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIDwvPlxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICA8L0VsZW1lbnQ+XHJcbiAgICAgICAgPC9DU1NUcmFuc2l0aW9uPlxyXG4gICAgKTtcclxufSk7XHJcblxyXG5DaGlwLmRpc3BsYXlOYW1lID0gJ01EQ0NoaXAnO1xyXG5cclxuQ2hpcC5wcm9wVHlwZXMgPSB7XHJcbiAgICB2YWx1ZTogUHJvcFR5cGVzLmFueSxcclxuICAgIHRleHQ6IFByb3BUeXBlcy5ub2RlLFxyXG4gICAgbGVhZGluZ0ljb246IFByb3BUeXBlcy5ub2RlLFxyXG4gICAgdHJhaWxpbmdJY29uOiBQcm9wVHlwZXMubm9kZSxcclxuICAgIHNlbGVjdGVkOiBQcm9wVHlwZXMuYm9vbCxcclxuICAgIG91dGxpbmVkOiBQcm9wVHlwZXMuYm9vbCxcclxuICAgIG9uQ2xpY2s6IFByb3BUeXBlcy5mdW5jXHJcbn07XHJcblxyXG5leHBvcnQgZGVmYXVsdCBDaGlwOyIsImV4cG9ydCBmdW5jdGlvbiBpc1VuZGVmaW5lZCh2YWx1ZSkge1xyXG4gICAgcmV0dXJuIHZhbHVlID09PSB1bmRlZmluZWQ7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBpc051bGwodmFsdWUpIHtcclxuICAgIHJldHVybiB2YWx1ZSA9PT0gbnVsbDtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGlzQm9vbGVhbih2YWx1ZSkge1xyXG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gaXNOdW1iZXIodmFsdWUpIHtcclxuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gaXNTdHJpbmcodmFsdWUpIHtcclxuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gaXNBcnJheSh2YWx1ZSkge1xyXG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkodmFsdWUpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcclxuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmICFpc051bGwodmFsdWUpICYmICFpc0FycmF5KHZhbHVlKTtcclxufSIsImltcG9ydCB7IENoaWxkcmVuLCBmb3J3YXJkUmVmLCB1c2VDYWxsYmFjayB9IGZyb20gJ3JlYWN0JztcclxuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcclxuaW1wb3J0IGNsYXNzbmFtZXMgZnJvbSAnY2xhc3NuYW1lcyc7XHJcblxyXG5pbXBvcnQgeyBpc1VuZGVmaW5lZCwgaXNBcnJheSB9IGZyb20gJy4uL3R5cGVzJztcclxuaW1wb3J0IHsgY2xvbmUsIGNyZWF0ZSB9IGZyb20gJy4uL2NvbXBvbmVudCc7XHJcblxyXG5pbXBvcnQgeyBjaGlwU2V0Q3NzQ2xhc3NlcyBhcyBjc3NDbGFzc2VzIH0gZnJvbSAnLi9jb25zdGFudHMnO1xyXG5pbXBvcnQgQ2hpcCBmcm9tICcuL0NoaXAnO1xyXG5cclxuY29uc3QgQ2hpcFNldCA9IGZvcndhcmRSZWYoKHtcclxuICAgIHZhbHVlLFxyXG4gICAgY2hpcHMsXHJcbiAgICBpbnB1dCA9IGZhbHNlLFxyXG4gICAgY2hvaWNlID0gKCFpbnB1dCAmJiAhaXNVbmRlZmluZWQodmFsdWUpICYmICFpc0FycmF5KHZhbHVlKSksXHJcbiAgICBmaWx0ZXIgPSAoIWlucHV0ICYmICFpc1VuZGVmaW5lZCh2YWx1ZSkgJiYgaXNBcnJheSh2YWx1ZSkpLFxyXG4gICAgb3ZlcmZsb3cgPSBmYWxzZSxcclxuICAgIG9uQ2hhbmdlID0gRnVuY3Rpb24ucHJvdG90eXBlLFxyXG5cclxuICAgIGVsZW1lbnQgPSAnZGl2JyxcclxuICAgIGNvbXBvbmVudDogRWxlbWVudCA9IGVsZW1lbnQsXHJcbiAgICBjbGFzc05hbWUsXHJcbiAgICBjaGlsZHJlbiA9IGNoaXBzPy5tYXAoY2hpcCA9PiBjcmVhdGUoQ2hpcCwgY2hpcCkpLFxyXG4gICAgLi4ucHJvcHNcclxufSwgcmVmKSA9PiB7XHJcbiAgICBjb25zdCBoYW5kbGVDbGljayA9IHVzZUNhbGxiYWNrKGV2ZW50ID0+IHtcclxuICAgICAgICBjb25zdCBjaGlwVmFsdWUgPSBldmVudC5jdXJyZW50VGFyZ2V0LmRhdGFzZXQudmFsdWU7XHJcbiAgICAgICAgY29uc3QgbmV3VmFsdWUgPSBjaG9pY2UgPyBjaGlwVmFsdWUgOlxyXG4gICAgICAgICAgICAodmFsdWUuaW5jbHVkZXMoY2hpcFZhbHVlKSA/XHJcbiAgICAgICAgICAgICAgICB2YWx1ZS5maWx0ZXIodiA9PiB2ICE9PSBjaGlwVmFsdWUpIDpcclxuICAgICAgICAgICAgICAgIHZhbHVlLmNvbmNhdChjaGlwVmFsdWUpXHJcbiAgICAgICAgICAgICk7XHJcblxyXG4gICAgICAgIG9uQ2hhbmdlKG5ld1ZhbHVlKTtcclxuICAgIH0sIFt2YWx1ZSwgY2hvaWNlLCBvbkNoYW5nZV0pO1xyXG5cclxuICAgIGNvbnN0IGNsYXNzTmFtZXMgPSBjbGFzc25hbWVzKGNzc0NsYXNzZXMuUk9PVCwge1xyXG4gICAgICAgIFtjc3NDbGFzc2VzLk9WRVJGTE9XXTogb3ZlcmZsb3dcclxuICAgIH0sIGNsYXNzTmFtZSk7XHJcblxyXG4gICAgcmV0dXJuIChcclxuICAgICAgICA8RWxlbWVudCByZWY9e3JlZn0gY2xhc3NOYW1lPXtjbGFzc05hbWVzfSByb2xlPXtmaWx0ZXIgPyAnbGlzdGJveCcgOiAnZ3JpZCd9IHsuLi5wcm9wc30+XHJcbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXtjc3NDbGFzc2VzLkNISVBTfSByb2xlPVwicHJlc2VudGF0aW9uXCI+XHJcbiAgICAgICAgICAgICAgICB7aXNVbmRlZmluZWQodmFsdWUpID8gY2hpbGRyZW4gOlxyXG4gICAgICAgICAgICAgICAgICAgIENoaWxkcmVuLm1hcChjaGlsZHJlbiwgY2hpcCA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNoaXBWYWx1ZSA9IGNoaXAucHJvcHMudmFsdWU7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2xvbmUoY2hpcCwge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0YWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdGVkOiBjaG9pY2UgPyB2YWx1ZSA9PT0gY2hpcFZhbHVlIDogdmFsdWUuaW5jbHVkZXMoY2hpcFZhbHVlKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2xpY2tDYXB0dXJlOiAoY2hvaWNlIHx8IGZpbHRlcikgPyBoYW5kbGVDbGljayA6IHVuZGVmaW5lZCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgPC9FbGVtZW50PlxyXG4gICAgKTtcclxufSk7XHJcblxyXG5DaGlwU2V0LmRpc3BsYXlOYW1lID0gJ01EQ0NoaXBTZXQnO1xyXG5cclxuQ2hpcFNldC5wcm9wVHlwZXMgPSB7XHJcbiAgICB2YWx1ZTogUHJvcFR5cGVzLmFueSxcclxuICAgIGlucHV0OiBQcm9wVHlwZXMuYm9vbCxcclxuICAgIGNob2ljZTogUHJvcFR5cGVzLmJvb2wsXHJcbiAgICBmaWx0ZXI6IFByb3BUeXBlcy5ib29sLFxyXG4gICAgb3ZlcmZsb3c6IFByb3BUeXBlcy5ib29sLFxyXG4gICAgb25DaGFuZ2U6IFByb3BUeXBlcy5mdW5jXHJcbn07XHJcblxyXG5leHBvcnQgZGVmYXVsdCBDaGlwU2V0OyIsImltcG9ydCBDaGlwIGZyb20gJy4vQ2hpcCc7XHJcbmltcG9ydCBDaGlwU2V0IGZyb20gJy4vQ2hpcFNldCc7XHJcblxyXG5DaGlwLlNldCA9IENoaXBTZXQ7XHJcblxyXG5leHBvcnQge1xyXG4gICAgQ2hpcCxcclxuICAgIENoaXBTZXRcclxufTsiLCJleHBvcnQgY29uc3Qgc3RyaW5ncyA9IHtcclxuICAgIFhNTE5TOiAnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnLFxyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IHNpemVQcm9wcyA9IHtcclxuICAgIGxhcmdlOiB7XHJcbiAgICAgICAgdmlld0JveDogNDgsXHJcbiAgICAgICAgcmFkaXVzOiAxOCxcclxuICAgICAgICBzdHJva2VXaWR0aDogNCxcclxuICAgICAgICBnYXBQYXRjaFN0cm9rZVdpZHRoOiAzLjIsXHJcbiAgICAgICAgc3Ryb2tlRGFzaGFycmF5OiAxMTMuMDk3LFxyXG4gICAgICAgIGluZGV0ZXJtaW5hdGVTdHJva2VEYXNob2Zmc2V0OiA1Ni41NDlcclxuICAgIH0sXHJcbiAgICBtZWRpdW06IHtcclxuICAgICAgICB2aWV3Qm94OiAzMixcclxuICAgICAgICByYWRpdXM6IDEyLjUsXHJcbiAgICAgICAgc3Ryb2tlV2lkdGg6IDMsXHJcbiAgICAgICAgZ2FwUGF0Y2hTdHJva2VXaWR0aDogMi40LFxyXG4gICAgICAgIHN0cm9rZURhc2hhcnJheTogNzguNTQsXHJcbiAgICAgICAgaW5kZXRlcm1pbmF0ZVN0cm9rZURhc2hvZmZzZXQ6IDM5LjI3XHJcbiAgICB9LFxyXG4gICAgc21hbGw6IHtcclxuICAgICAgICB2aWV3Qm94OiAyNCxcclxuICAgICAgICByYWRpdXM6IDguNzUsXHJcbiAgICAgICAgc3Ryb2tlV2lkdGg6IDIuNSxcclxuICAgICAgICBnYXBQYXRjaFN0cm9rZVdpZHRoOiAyLFxyXG4gICAgICAgIHN0cm9rZURhc2hhcnJheTogNTQuOTc4LFxyXG4gICAgICAgIGluZGV0ZXJtaW5hdGVTdHJva2VEYXNob2Zmc2V0OiAyNy40ODlcclxuICAgIH1cclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCBjc3NDbGFzc2VzID0ge1xyXG4gICAgUk9PVDogJ21kYy1jaXJjdWxhci1wcm9ncmVzcycsXHJcbiAgICBTTUFMTDogJ21kYy1jaXJjdWxhci1wcm9ncmVzcy0tc21hbGwnLFxyXG4gICAgTUVESVVNOiAnbWRjLWNpcmN1bGFyLXByb2dyZXNzLS1tZWRpdW0nLFxyXG4gICAgTEFSR0U6ICdtZGMtY2lyY3VsYXItcHJvZ3Jlc3MtLWxhcmdlJyxcclxuICAgIElOREVURVJNSU5BVEU6ICdtZGMtY2lyY3VsYXItcHJvZ3Jlc3MtLWluZGV0ZXJtaW5hdGUnLFxyXG4gICAgQ0xPU0VEOiAnbWRjLWNpcmN1bGFyLXByb2dyZXNzLS1jbG9zZWQnLFxyXG5cclxuICAgIERFVEVSTUlOQVRFX0NPTlRBSU5FUjogJ21kYy1jaXJjdWxhci1wcm9ncmVzc19fZGV0ZXJtaW5hdGUtY29udGFpbmVyJyxcclxuICAgIERFVEVSTUlOQVRFX0NJUkNMRV9HUkFQSElDOiAnbWRjLWNpcmN1bGFyLXByb2dyZXNzX19kZXRlcm1pbmF0ZS1jaXJjbGUtZ3JhcGhpYycsXHJcbiAgICBERVRFUk1JTkFURV9UUkFDSzogJ21kYy1jaXJjdWxhci1wcm9ncmVzc19fZGV0ZXJtaW5hdGUtdHJhY2snLFxyXG4gICAgREVURVJNSU5BVEVfQ0lSQ0xFOiAnbWRjLWNpcmN1bGFyLXByb2dyZXNzX19kZXRlcm1pbmF0ZS1jaXJjbGUnLFxyXG5cclxuICAgIElOREVURVJNSU5BVEVfQ09OVEFJTkVSOiAnbWRjLWNpcmN1bGFyLXByb2dyZXNzX19pbmRldGVybWluYXRlLWNvbnRhaW5lcicsXHJcbiAgICBJTkRFVEVSTUlOQVRFX0NJUkNMRV9HUkFQSElDOiAnbWRjLWNpcmN1bGFyLXByb2dyZXNzX19pbmRldGVybWluYXRlLWNpcmNsZS1ncmFwaGljJyxcclxuXHJcbiAgICBTUElOTkVSX0xBWUVSOiAnbWRjLWNpcmN1bGFyLXByb2dyZXNzX19zcGlubmVyLWxheWVyJyxcclxuICAgIENPTE9SOiAnbWRjLWNpcmN1bGFyLXByb2dyZXNzX19jb2xvcicsXHJcbiAgICBDSVJDTEVfQ0xJUFBFUjogJ21kYy1jaXJjdWxhci1wcm9ncmVzc19fY2lyY2xlLWNsaXBwZXInLFxyXG4gICAgQ0lSQ0xFX0xFRlQ6ICdtZGMtY2lyY3VsYXItcHJvZ3Jlc3NfX2NpcmNsZS1sZWZ0JyxcclxuICAgIENJUkNMRV9SSUdIVDogJ21kYy1jaXJjdWxhci1wcm9ncmVzc19fY2lyY2xlLXJpZ2h0JyxcclxuICAgIEdBUF9QQVRDSDogJ21kYy1jaXJjdWxhci1wcm9ncmVzc19fZ2FwLXBhdGNoJ1xyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IFNpemUgPSB7XHJcbiAgICBMQVJHRTogJ2xhcmdlJyxcclxuICAgIE1FRElVTTogJ21lZGl1bScsXHJcbiAgICBTTUFMTDogJ3NtYWxsJ1xyXG59OyIsImltcG9ydCB7IGZvcndhcmRSZWYgfSBmcm9tICdyZWFjdCc7XHJcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XHJcbmltcG9ydCBjbGFzc25hbWVzIGZyb20gJ2NsYXNzbmFtZXMnO1xyXG5cclxuaW1wb3J0IHsgc3RyaW5ncywgY3NzQ2xhc3Nlcywgc2l6ZVByb3BzLCBTaXplIH0gZnJvbSAnLi9jb25zdGFudHMnO1xyXG5cclxuY29uc3QgQ2lyY3VsYXJQcm9ncmVzcyA9IGZvcndhcmRSZWYoKHtcclxuICAgIHZhbHVlID0gMCxcclxuICAgIHNpemUgPSBTaXplLk1FRElVTSxcclxuICAgIGluZGV0ZXJtaW5hdGUgPSBmYWxzZSxcclxuICAgIGNsb3NlZCA9IGZhbHNlLFxyXG4gICAgY29sb3JmdWwgPSBmYWxzZSxcclxuXHJcbiAgICBjbGFzc05hbWUsXHJcbiAgICAuLi5wcm9wc1xyXG59LCByZWYpID0+IHtcclxuICAgIGNvbnN0IGNsYXNzTmFtZXMgPSBjbGFzc25hbWVzKGNzc0NsYXNzZXMuUk9PVCwge1xyXG4gICAgICAgIFtgJHtjc3NDbGFzc2VzLlJPT1R9LS0ke3NpemV9YF06IHNpemUsXHJcbiAgICAgICAgW2Nzc0NsYXNzZXMuSU5ERVRFUk1JTkFURV06IGluZGV0ZXJtaW5hdGUsXHJcbiAgICAgICAgW2Nzc0NsYXNzZXMuQ0xPU0VEXTogY2xvc2VkXHJcbiAgICB9LCBjbGFzc05hbWUpO1xyXG5cclxuICAgIGNvbnN0IHsgdmlld0JveCwgcmFkaXVzLCBzdHJva2VEYXNoYXJyYXksIHN0cm9rZVdpZHRoLCBnYXBQYXRjaFN0cm9rZVdpZHRoLCBpbmRldGVybWluYXRlU3Ryb2tlRGFzaG9mZnNldCB9ID0gc2l6ZVByb3BzW3NpemVdO1xyXG4gICAgY29uc3QgcHJvZ3Jlc3MgPSB2YWx1ZSA+IDEgPyAodmFsdWUgLyAxMDApIDogTnVtYmVyKHZhbHVlKTtcclxuICAgIGNvbnN0IGN4ID0gdmlld0JveCAvIDIsIGN5ID0gdmlld0JveCAvIDI7XHJcbiAgICBjb25zdCBzdHJva2VEYXNob2Zmc2V0ID0gKDIgKiBNYXRoLlBJICogcmFkaXVzKSAqICgxIC0gcHJvZ3Jlc3MpO1xyXG5cclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgPGRpdlxyXG4gICAgICAgICAgICByZWY9e3JlZn1cclxuICAgICAgICAgICAgY2xhc3NOYW1lPXtjbGFzc05hbWVzfVxyXG4gICAgICAgICAgICByb2xlPVwicHJvZ3Jlc3NiYXJcIlxyXG4gICAgICAgICAgICBhcmlhLXZhbHVlbWluPXswfVxyXG4gICAgICAgICAgICBhcmlhLXZhbHVlbWF4PXsxfVxyXG4gICAgICAgICAgICBhcmlhLXZhbHVlbm93PXtwcm9ncmVzc31cclxuICAgICAgICAgICAgey4uLnByb3BzfVxyXG4gICAgICAgID5cclxuICAgICAgICAgICAgeyFpbmRldGVybWluYXRlICYmXHJcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17Y3NzQ2xhc3Nlcy5ERVRFUk1JTkFURV9DT05UQUlORVJ9PlxyXG4gICAgICAgICAgICAgICAgICAgIDxzdmcgY2xhc3NOYW1lPXtjc3NDbGFzc2VzLkRFVEVSTUlOQVRFX0NJUkNMRV9HUkFQSElDfSB2aWV3Qm94PXtgMCAwICR7dmlld0JveH0gJHt2aWV3Qm94fWB9IHhtbG5zPXtzdHJpbmdzLlhNTE5TfT5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPGNpcmNsZSBjbGFzc05hbWU9e2Nzc0NsYXNzZXMuREVURVJNSU5BVEVfVFJBQ0t9IGN4PXtjeH0gY3k9e2N5fSByPXtyYWRpdXN9IHN0cm9rZVdpZHRoPXtzdHJva2VXaWR0aH0gLz5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPGNpcmNsZSBjbGFzc05hbWU9e2Nzc0NsYXNzZXMuREVURVJNSU5BVEVfQ0lSQ0xFfSBjeD17Y3h9IGN5PXtjeX0gcj17cmFkaXVzfSBzdHJva2VXaWR0aD17c3Ryb2tlV2lkdGh9IHN0cm9rZURhc2hhcnJheT17c3Ryb2tlRGFzaGFycmF5fSBzdHJva2VEYXNob2Zmc2V0PXtzdHJva2VEYXNob2Zmc2V0fSAvPlxyXG4gICAgICAgICAgICAgICAgICAgIDwvc3ZnPlxyXG4gICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHtpbmRldGVybWluYXRlICYmXHJcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17Y3NzQ2xhc3Nlcy5JTkRFVEVSTUlOQVRFX0NPTlRBSU5FUn0+XHJcbiAgICAgICAgICAgICAgICAgICAgeyhjb2xvcmZ1bCA/IFsxLCAyLCAzLCA0XSA6IFswXSkubWFwKG4gPT5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBrZXk9e259IGNsYXNzTmFtZT17Y2xhc3NuYW1lcyhjc3NDbGFzc2VzLlNQSU5ORVJfTEFZRVIsIHsgW2Ake2Nzc0NsYXNzZXMuUFJPR1JFU1NfQ09MT1J9LSR7bn1gXTogbiB9KX0+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17YCR7Y3NzQ2xhc3Nlcy5DSVJDTEVfQ0xJUFBFUn0gJHtjc3NDbGFzc2VzLkNJUkNMRV9MRUZUfWB9PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzdmcgY2xhc3NOYW1lPXtjc3NDbGFzc2VzLklOREVURVJNSU5BVEVfQ0lSQ0xFX0dSQVBISUN9IHZpZXdCb3g9e2AwIDAgJHt2aWV3Qm94fSAke3ZpZXdCb3h9YH0geG1sbnM9e3N0cmluZ3MuWE1MTlN9PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8Y2lyY2xlIGN4PXtjeH0gY3k9e2N5fSByPXtyYWRpdXN9IHN0cm9rZVdpZHRoPXtzdHJva2VXaWR0aH0gc3Ryb2tlRGFzaGFycmF5PXtzdHJva2VEYXNoYXJyYXl9IHN0cm9rZURhc2hvZmZzZXQ9e2luZGV0ZXJtaW5hdGVTdHJva2VEYXNob2Zmc2V0fSAvPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvc3ZnPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+PGRpdiBjbGFzc05hbWU9e2Nzc0NsYXNzZXMuR0FQX1BBVENIfT5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3ZnIGNsYXNzTmFtZT17Y3NzQ2xhc3Nlcy5JTkRFVEVSTUlOQVRFX0NJUkNMRV9HUkFQSElDfSB2aWV3Qm94PXtgMCAwICR7dmlld0JveH0gJHt2aWV3Qm94fWB9IHhtbG5zPXtzdHJpbmdzLlhNTE5TfT5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGNpcmNsZSBjeD17Y3h9IGN5PXtjeX0gcj17cmFkaXVzfSBzdHJva2VXaWR0aD17Z2FwUGF0Y2hTdHJva2VXaWR0aH0gc3Ryb2tlRGFzaGFycmF5PXtzdHJva2VEYXNoYXJyYXl9IHN0cm9rZURhc2hvZmZzZXQ9e2luZGV0ZXJtaW5hdGVTdHJva2VEYXNob2Zmc2V0fSAvPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvc3ZnPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+PGRpdiBjbGFzc05hbWU9e2Ake2Nzc0NsYXNzZXMuQ0lSQ0xFX0NMSVBQRVJ9ICR7Y3NzQ2xhc3Nlcy5DSVJDTEVfUklHSFR9YH0+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHN2ZyBjbGFzc05hbWU9e2Nzc0NsYXNzZXMuSU5ERVRFUk1JTkFURV9DSVJDTEVfR1JBUEhJQ30gdmlld0JveD17YDAgMCAke3ZpZXdCb3h9ICR7dmlld0JveH1gfSB4bWxucz17c3RyaW5ncy5YTUxOU30+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxjaXJjbGUgY3g9e2N4fSBjeT17Y3l9IHI9e3JhZGl1c30gc3Ryb2tlV2lkdGg9e3N0cm9rZVdpZHRofSBzdHJva2VEYXNoYXJyYXk9e3N0cm9rZURhc2hhcnJheX0gc3Ryb2tlRGFzaG9mZnNldD17aW5kZXRlcm1pbmF0ZVN0cm9rZURhc2hvZmZzZXR9IC8+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9zdmc+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICAgICAgICAgKX1cclxuICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgPC9kaXY+XHJcbiAgICApO1xyXG59KTtcclxuXHJcbkNpcmN1bGFyUHJvZ3Jlc3MuZGlzcGxheU5hbWUgPSAnTURDQ2lyY3VsYXJQcm9ncmVzcyc7XHJcblxyXG5DaXJjdWxhclByb2dyZXNzLnByb3BUeXBlcyA9IHtcclxuICAgIHZhbHVlOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMubnVtYmVyLCBQcm9wVHlwZXMuc3RyaW5nXSksXHJcbiAgICBzaXplOiBQcm9wVHlwZXMub25lT2YoW1NpemUuU01BTEwsIFNpemUuTUVESVVNLCBTaXplLkxBUkdFXSksXHJcbiAgICBpbmRldGVybWluYXRlOiBQcm9wVHlwZXMuYm9vbCxcclxuICAgIGNsb3NlZDogUHJvcFR5cGVzLmJvb2wsXHJcbiAgICBjb2xvcmZ1bDogUHJvcFR5cGVzLmJvb2xcclxufTtcclxuXHJcbkNpcmN1bGFyUHJvZ3Jlc3MuU2l6ZSA9IFNpemU7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBDaXJjdWxhclByb2dyZXNzOyIsImV4cG9ydCB7IGRlZmF1bHQgfSBmcm9tICcuL0NpcmN1bGFyUHJvZ3Jlc3MnOyIsImV4cG9ydCBjb25zdCBjc3NDbGFzc2VzID0ge1xyXG4gICAgUk9PVDogJ21kYy1pY29uLWJ1dHRvbicsXHJcbiAgICBUT1VDSDogJ21kYy1pY29uLWJ1dHRvbi0tdG91Y2gnLFxyXG5cclxuICAgIElDT046ICdtZGMtaWNvbi1idXR0b25fX2ljb24nLFxyXG4gICAgUklQUExFOiAnbWRjLWljb24tYnV0dG9uX19yaXBwbGUnLFxyXG4gICAgVE9VQ0hfRUxFTUVOVDogJ21kYy1pY29uLWJ1dHRvbl9fdG91Y2gnXHJcbn07IiwiaW1wb3J0IHsgZm9yd2FyZFJlZiB9IGZyb20gJ3JlYWN0JztcclxuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcclxuaW1wb3J0IGNsYXNzbmFtZXMgZnJvbSAnY2xhc3NuYW1lcyc7XHJcblxyXG5pbXBvcnQgeyBDbG9uZSB9IGZyb20gJy4uL2NvbXBvbmVudCc7XHJcbmltcG9ydCB7IGNzc0NsYXNzZXMgYXMgaWNvbkNzc0NsYXNzZXMgfSBmcm9tICcuLi9pY29uL2NvbnN0YW50cyc7XHJcblxyXG5pbXBvcnQgeyBjc3NDbGFzc2VzIH0gZnJvbSAnLi9jb25zdGFudHMnO1xyXG5cclxuY29uc3QgSWNvbkJ1dHRvbiA9IGZvcndhcmRSZWYoKHtcclxuICAgIGljb24sXHJcbiAgICB0b3VjaCA9IGZhbHNlLFxyXG5cclxuICAgIGVsZW1lbnQgPSAnYnV0dG9uJyxcclxuICAgIGNvbXBvbmVudDogRWxlbWVudCA9IGVsZW1lbnQsXHJcbiAgICBjbGFzc05hbWUsXHJcbiAgICBjaGlsZHJlbiA9IGljb24sXHJcbiAgICAuLi5wcm9wc1xyXG59LCByZWYpID0+IHtcclxuICAgIGNvbnN0IGNsYXNzTmFtZXMgPSBjbGFzc25hbWVzKGNzc0NsYXNzZXMuUk9PVCwge1xyXG4gICAgICAgIFtpY29uQ3NzQ2xhc3Nlcy5ST09UXTogdHlwZW9mIGNoaWxkcmVuID09PSAnc3RyaW5nJyxcclxuICAgICAgICBbY3NzQ2xhc3Nlcy5UT1VDSF06IHRvdWNoXHJcbiAgICB9LCBjbGFzc05hbWUpO1xyXG5cclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgPEVsZW1lbnQgcmVmPXtyZWZ9IGNsYXNzTmFtZT17Y2xhc3NOYW1lc30gey4uLnByb3BzfT5cclxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9e2Nzc0NsYXNzZXMuUklQUExFfSAvPlxyXG5cclxuICAgICAgICAgICAgPENsb25lXHJcbiAgICAgICAgICAgICAgICBjb21wb25lbnQ9e2NoaWxkcmVufVxyXG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lPXtjc3NDbGFzc2VzLklDT059XHJcbiAgICAgICAgICAgIC8+XHJcblxyXG4gICAgICAgICAgICB7dG91Y2ggJiZcclxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXtjc3NDbGFzc2VzLlRPVUNIX0VMRU1FTlR9IC8+XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICA8L0VsZW1lbnQ+XHJcbiAgICApO1xyXG59KTtcclxuXHJcbkljb25CdXR0b24uZGlzcGxheU5hbWUgPSAnTURDSWNvbkJ1dHRvbic7XHJcblxyXG5JY29uQnV0dG9uLnByb3BUeXBlcyA9IHtcclxuICAgIGljb246IFByb3BUeXBlcy5ub2RlLFxyXG4gICAgdG91Y2g6IFByb3BUeXBlcy5ib29sXHJcbn07XHJcblxyXG5leHBvcnQgZGVmYXVsdCBJY29uQnV0dG9uOyIsImV4cG9ydCB7IGRlZmF1bHQgfSBmcm9tICcuL0ljb25CdXR0b24nOyIsImV4cG9ydCBjb25zdCBjc3NDbGFzc2VzID0ge1xyXG4gICAgUk9PVDogJ21kYy1saW5lYXItcHJvZ3Jlc3MnLFxyXG4gICAgSU5ERVRFUk1JTkFURTogJ21kYy1saW5lYXItcHJvZ3Jlc3MtLWluZGV0ZXJtaW5hdGUnLFxyXG4gICAgQU5JTUFUSU9OX1JFQURZOiAnbWRjLWxpbmVhci1wcm9ncmVzcy0tYW5pbWF0aW9uLXJlYWR5JyxcclxuICAgIENMT1NFRDogJ21kYy1saW5lYXItcHJvZ3Jlc3MtLWNsb3NlZCcsXHJcbiAgICBDTE9TRURfQU5JTUFUSU9OX09GRjogJ21kYy1saW5lYXItcHJvZ3Jlc3MtLWNsb3NlZC1hbmltYXRpb24tb2ZmJyxcclxuXHJcbiAgICBCVUZGRVI6ICdtZGMtbGluZWFyLXByb2dyZXNzX19idWZmZXInLFxyXG4gICAgQlVGRkVSX0JBUjogJ21kYy1saW5lYXItcHJvZ3Jlc3NfX2J1ZmZlci1iYXInLFxyXG4gICAgQlVGRkVSX0RPVFM6ICdtZGMtbGluZWFyLXByb2dyZXNzX19idWZmZXItZG90cycsXHJcblxyXG4gICAgQkFSOiAnbWRjLWxpbmVhci1wcm9ncmVzc19fYmFyJyxcclxuICAgIFBSSU1BUllfQkFSOiAnbWRjLWxpbmVhci1wcm9ncmVzc19fcHJpbWFyeS1iYXInLFxyXG4gICAgU0VDT05EQVJZX0JBUjogJ21kYy1saW5lYXItcHJvZ3Jlc3NfX3NlY29uZGFyeS1iYXInLFxyXG4gICAgQkFSX0lOTkVSOiAnbWRjLWxpbmVhci1wcm9ncmVzc19fYmFyLWlubmVyJ1xyXG59OyIsImltcG9ydCB7IGZvcndhcmRSZWYgfSBmcm9tICdyZWFjdCc7XHJcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XHJcbmltcG9ydCBjbGFzc25hbWVzIGZyb20gJ2NsYXNzbmFtZXMnO1xyXG5cclxuaW1wb3J0IHsgY3NzQ2xhc3NlcyB9IGZyb20gJy4vY29uc3RhbnRzJztcclxuXHJcbmNvbnN0IExpbmVhclByb2dyZXNzID0gZm9yd2FyZFJlZigoe1xyXG4gICAgdmFsdWUgPSAwLFxyXG4gICAgYnVmZmVyID0gMCxcclxuICAgIGluZGV0ZXJtaW5hdGUgPSBmYWxzZSxcclxuICAgIGNsb3NlZCA9IGZhbHNlLFxyXG5cclxuICAgIGNsYXNzTmFtZSxcclxuICAgIC4uLnByb3BzXHJcbn0sIHJlZikgPT4ge1xyXG4gICAgY29uc3QgY2xhc3NOYW1lcyA9IGNsYXNzbmFtZXMoY3NzQ2xhc3Nlcy5ST09ULCB7XHJcbiAgICAgICAgW2Nzc0NsYXNzZXMuSU5ERVRFUk1JTkFURV06IGluZGV0ZXJtaW5hdGUsXHJcbiAgICAgICAgW2Nzc0NsYXNzZXMuQU5JTUFUSU9OX1JFQURZXTogaW5kZXRlcm1pbmF0ZSxcclxuICAgICAgICBbY3NzQ2xhc3Nlcy5DTE9TRURdOiBjbG9zZWRcclxuICAgIH0sIGNsYXNzTmFtZSk7XHJcblxyXG4gICAgY29uc3QgcHJpbWFyeUJhclN0eWxlID0ge1xyXG4gICAgICAgIHRyYW5zZm9ybTogYHNjYWxlWCgke2luZGV0ZXJtaW5hdGUgPyAxIDogKHZhbHVlID4gMSA/ICh2YWx1ZSAqIDAuMDEpIDogdmFsdWUpfSlgXHJcbiAgICB9O1xyXG5cclxuICAgIGNvbnN0IGJ1ZmZlclN0eWxlID0ge1xyXG4gICAgICAgIGZsZXhCYXNpczogYnVmZmVyID8gYCR7aW5kZXRlcm1pbmF0ZSA/IDEgOiAoYnVmZmVyIDwgMSA/IChidWZmZXIgKiAxMDApIDogYnVmZmVyKX0lYCA6IHVuZGVmaW5lZFxyXG4gICAgfTtcclxuXHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAgIDxkaXZcclxuICAgICAgICAgICAgcmVmPXtyZWZ9XHJcbiAgICAgICAgICAgIGNsYXNzTmFtZT17Y2xhc3NOYW1lc31cclxuICAgICAgICAgICAgcm9sZT1cInByb2dyZXNzYmFyXCJcclxuICAgICAgICAgICAgYXJpYS12YWx1ZW1pbj1cIjBcIlxyXG4gICAgICAgICAgICBhcmlhLXZhbHVlbWF4PVwiMVwiXHJcbiAgICAgICAgICAgIGFyaWEtdmFsdWVub3c9e3ZhbHVlID4gMSA/ICh2YWx1ZSAqIDAuMDEpIDogdmFsdWV9XHJcbiAgICAgICAgICAgIHsuLi5wcm9wc31cclxuICAgICAgICA+XHJcbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXtjc3NDbGFzc2VzLkJVRkZFUn0+XHJcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17Y3NzQ2xhc3Nlcy5CVUZGRVJfQkFSfSBzdHlsZT17YnVmZmVyU3R5bGV9IC8+XHJcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17Y3NzQ2xhc3Nlcy5CVUZGRVJfRE9UU30gLz5cclxuICAgICAgICAgICAgPC9kaXY+XHJcblxyXG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17YCR7Y3NzQ2xhc3Nlcy5CQVJ9ICR7Y3NzQ2xhc3Nlcy5QUklNQVJZX0JBUn1gfSBzdHlsZT17cHJpbWFyeUJhclN0eWxlfT5cclxuICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT17Y3NzQ2xhc3Nlcy5CQVJfSU5ORVJ9IC8+XHJcbiAgICAgICAgICAgIDwvZGl2PlxyXG5cclxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9e2Ake2Nzc0NsYXNzZXMuQkFSfSAke2Nzc0NsYXNzZXMuU0VDT05EQVJZX0JBUn1gfT5cclxuICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT17Y3NzQ2xhc3Nlcy5CQVJfSU5ORVJ9IC8+XHJcbiAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgIDwvZGl2PlxyXG4gICAgKTtcclxufSk7XHJcblxyXG5MaW5lYXJQcm9ncmVzcy5kaXNwbGF5TmFtZSA9ICdNRENMaW5lYXJQcm9ncmVzcyc7XHJcblxyXG5MaW5lYXJQcm9ncmVzcy5wcm9wVHlwZXMgPSB7XHJcbiAgICB2YWx1ZTogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLm51bWJlciwgUHJvcFR5cGVzLnN0cmluZ10pLFxyXG4gICAgYnVmZmVyOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMubnVtYmVyLCBQcm9wVHlwZXMuc3RyaW5nXSksXHJcbiAgICBpbmRldGVybWluYXRlOiBQcm9wVHlwZXMuYm9vbCxcclxuICAgIGNsb3NlZDogUHJvcFR5cGVzLmJvb2xcclxufTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IExpbmVhclByb2dyZXNzOyIsImV4cG9ydCB7IGRlZmF1bHQgfSBmcm9tICcuL0xpbmVhclByb2dyZXNzJzsiLCJleHBvcnQgY29uc3QgY3NzQ2xhc3NlcyA9IHtcclxuICAgIFJPT1Q6ICdtZGMtZGF0YS10YWJsZScsXHJcbiAgICBTVElDS1lfSEVBREVSOiAnbWRjLWRhdGEtdGFibGUtLXN0aWNreS1oZWFkZXInLFxyXG4gICAgSU5fUFJPR1JFU1M6ICdtZGMtZGF0YS10YWJsZS0taW4tcHJvZ3Jlc3MnLFxyXG5cclxuICAgIFRBQkxFX0NPTlRBSU5FUjogJ21kYy1kYXRhLXRhYmxlX190YWJsZS1jb250YWluZXInLFxyXG4gICAgVEFCTEU6ICdtZGMtZGF0YS10YWJsZV9fdGFibGUnLFxyXG5cclxuICAgIEhFQURFUjogJ21kYy1kYXRhLXRhYmxlX19oZWFkZXInLFxyXG4gICAgSEVBREVSX1JPVzogJ21kYy1kYXRhLXRhYmxlX19oZWFkZXItcm93JyxcclxuICAgIEhFQURFUl9ST1dfQ0hFQ0tCT1g6ICdtZGMtZGF0YS10YWJsZV9faGVhZGVyLXJvdy1jaGVja2JveCcsXHJcbiAgICBIRUFERVJfQ0VMTDogJ21kYy1kYXRhLXRhYmxlX19oZWFkZXItY2VsbCcsXHJcbiAgICBIRUFERVJfQ0VMTF9DSEVDS0JPWDogJ21kYy1kYXRhLXRhYmxlX19oZWFkZXItY2VsbC0tY2hlY2tib3gnLFxyXG4gICAgSEVBREVSX0NFTExfTlVNRVJJQzogJ21kYy1kYXRhLXRhYmxlX19oZWFkZXItY2VsbC0tbnVtZXJpYycsXHJcbiAgICBIRUFERVJfQ0VMTF9XSVRIX1NPUlQ6ICdtZGMtZGF0YS10YWJsZV9faGVhZGVyLWNlbGwtLXdpdGgtc29ydCcsXHJcbiAgICBIRUFERVJfQ0VMTF9TT1JURUQ6ICdtZGMtZGF0YS10YWJsZV9faGVhZGVyLWNlbGwtLXNvcnRlZCcsXHJcbiAgICBIRUFERVJfQ0VMTF9TT1JURURfREVTQzogJ21kYy1kYXRhLXRhYmxlX19oZWFkZXItY2VsbC0tc29ydGVkLWRlc2NlbmRpbmcnLFxyXG4gICAgSEVBREVSX0NFTExfV1JBUFBFUjogJ21kYy1kYXRhLXRhYmxlX19oZWFkZXItY2VsbC13cmFwcGVyJyxcclxuICAgIEhFQURFUl9DRUxMX0xBQkVMOiAnbWRjLWRhdGEtdGFibGVfX2hlYWRlci1jZWxsLWxhYmVsJyxcclxuXHJcbiAgICBDT05URU5UOiAnbWRjLWRhdGEtdGFibGVfX2NvbnRlbnQnLFxyXG5cclxuICAgIFJPVzogJ21kYy1kYXRhLXRhYmxlX19yb3cnLFxyXG4gICAgUk9XX0NIRUNLQk9YOiAnbWRjLWRhdGEtdGFibGVfX3Jvdy1jaGVja2JveCcsXHJcbiAgICBST1dfU0VMRUNURUQ6ICdtZGMtZGF0YS10YWJsZV9fcm93LS1zZWxlY3RlZCcsXHJcblxyXG4gICAgQ0VMTDogJ21kYy1kYXRhLXRhYmxlX19jZWxsJyxcclxuICAgIENFTExfQ0hFQ0tCT1g6ICdtZGMtZGF0YS10YWJsZV9fY2VsbC0tY2hlY2tib3gnLFxyXG4gICAgQ0VMTF9OVU1FUklDOiAnbWRjLWRhdGEtdGFibGVfX2NlbGwtLW51bWVyaWMnLFxyXG5cclxuICAgIFBBR0lOQVRJT046ICdtZGMtZGF0YS10YWJsZV9fcGFnaW5hdGlvbicsXHJcbiAgICBQQUdJTkFUSU9OX1RSQUlMSU5HOiAnbWRjLWRhdGEtdGFibGVfX3BhZ2luYXRpb24tdHJhaWxpbmcnLFxyXG4gICAgUEFHSU5BVElPTl9ST1dTX1BFUl9QQUdFOiAnbWRjLWRhdGEtdGFibGVfX3BhZ2luYXRpb24tcm93cy1wZXItcGFnZScsXHJcbiAgICBQQUdJTkFUSU9OX1JPV1NfUEVSX1BBR0VfTEFCRUw6ICdtZGMtZGF0YS10YWJsZV9fcGFnaW5hdGlvbi1yb3dzLXBlci1wYWdlLWxhYmVsJyxcclxuICAgIFBBR0lOQVRJT05fUk9XU19QRVJfUEFHRV9TRUxFQ1Q6ICdtZGMtZGF0YS10YWJsZV9fcGFnaW5hdGlvbi1yb3dzLXBlci1wYWdlLXNlbGVjdCcsXHJcbiAgICBQQUdJTkFUSU9OX05BVklHQVRJT046ICdtZGMtZGF0YS10YWJsZV9fcGFnaW5hdGlvbi1uYXZpZ2F0aW9uJyxcclxuICAgIFBBR0lOQVRJT05fVE9UQUw6ICdtZGMtZGF0YS10YWJsZV9fcGFnaW5hdGlvbi10b3RhbCcsXHJcbiAgICBQQUdJTkFUSU9OX0JVVFRPTjogJ21kYy1kYXRhLXRhYmxlX19wYWdpbmF0aW9uLWJ1dHRvbicsXHJcblxyXG4gICAgU09SVF9JQ09OX0JVVFRPTjogJ21kYy1kYXRhLXRhYmxlX19zb3J0LWljb24tYnV0dG9uJyxcclxuICAgIFNPUlRfU1RBVFVTX0xBQkVMOiAnbWRjLWRhdGEtdGFibGVfX3NvcnQtc3RhdHVzLWxhYmVsJyxcclxuICAgIFBST0dSRVNTX0lORElDQVRPUjogJ21kYy1kYXRhLXRhYmxlX19wcm9ncmVzcy1pbmRpY2F0b3InLFxyXG4gICAgU0NSSU06ICdtZGMtZGF0YS10YWJsZV9fc2NyaW0nLFxyXG4gICAgRk9PVEVSOiAnbWRjLWRhdGEtdGFibGVfX2Zvb3RlcicsXHJcbiAgICBMSU5FQVJfUFJPR1JFU1M6ICdtZGMtZGF0YS10YWJsZV9fbGluZWFyLXByb2dyZXNzJ1xyXG59OyIsImltcG9ydCB7IGZvcndhcmRSZWYgfSBmcm9tICdyZWFjdCc7XHJcblxyXG5pbXBvcnQgTGluZWFyUHJvZ3Jlc3MgZnJvbSAnLi4vbGluZWFyLXByb2dyZXNzJztcclxuXHJcbmltcG9ydCB7IGNzc0NsYXNzZXMgfSBmcm9tICcuL2NvbnN0YW50cyc7XHJcblxyXG5jb25zdCBEYXRhVGFibGVQcm9ncmVzc0luZGljYXRvciA9IGZvcndhcmRSZWYoKHByb3BzLCByZWYpID0+IHtcclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgPGRpdiByZWY9e3JlZn0gY2xhc3NOYW1lPXtjc3NDbGFzc2VzLlBST0dSRVNTX0lORElDQVRPUn0gey4uLnByb3BzfT5cclxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9e2Nzc0NsYXNzZXMuU0NSSU19IC8+XHJcblxyXG4gICAgICAgICAgICA8TGluZWFyUHJvZ3Jlc3MgY2xhc3NOYW1lPXtjc3NDbGFzc2VzLkxJTkVBUl9QUk9HUkVTU30gaW5kZXRlcm1pbmF0ZSAvPlxyXG4gICAgICAgIDwvZGl2PlxyXG4gICAgKTtcclxufSk7XHJcblxyXG5EYXRhVGFibGVQcm9ncmVzc0luZGljYXRvci5kaXNwbGF5TmFtZSA9ICdNRENEYXRhVGFibGVQcm9ncmVzc0luZGljYXRvcic7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBEYXRhVGFibGVQcm9ncmVzc0luZGljYXRvcjsiLCJleHBvcnQgY29uc3QgY3NzQ2xhc3NlcyA9IHtcclxuICAgIFJPT1Q6ICdtZGMtZmxvYXRpbmctbGFiZWwnLFxyXG4gICAgRkxPQVQ6ICdtZGMtZmxvYXRpbmctbGFiZWwtLWZsb2F0LWFib3ZlJyxcclxuICAgIFJFUVVJUkVEOiAnbWRjLWZsb2F0aW5nLWxhYmVsLS1yZXF1aXJlZCdcclxufTsiLCJpbXBvcnQgeyBmb3J3YXJkUmVmIH0gZnJvbSAncmVhY3QnO1xyXG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xyXG5pbXBvcnQgY2xhc3NuYW1lcyBmcm9tICdjbGFzc25hbWVzJztcclxuXHJcbmltcG9ydCB7IGNzc0NsYXNzZXMgfSBmcm9tICcuL2NvbnN0YW50cyc7XHJcblxyXG5jb25zdCBGbG9hdGluZ0xhYmVsID0gZm9yd2FyZFJlZigoe1xyXG4gICAgbGFiZWwsXHJcbiAgICBmbG9hdCA9IGZhbHNlLFxyXG4gICAgcmVxdWlyZWQgPSBmYWxzZSxcclxuXHJcbiAgICBjbGFzc05hbWUsXHJcbiAgICBjaGlsZHJlbiA9IGxhYmVsLFxyXG4gICAgLi4ucHJvcHNcclxufSwgcmVmKSA9PiB7XHJcbiAgICBjb25zdCBjbGFzc05hbWVzID0gY2xhc3NuYW1lcyhjc3NDbGFzc2VzLlJPT1QsIHtcclxuICAgICAgICBbY3NzQ2xhc3Nlcy5GTE9BVF06IGZsb2F0LFxyXG4gICAgICAgIFtjc3NDbGFzc2VzLlJFUVVJUkVEXTogcmVxdWlyZWRcclxuICAgIH0sIGNsYXNzTmFtZSk7XHJcblxyXG4gICAgcmV0dXJuIChcclxuICAgICAgICA8c3BhbiByZWY9e3JlZn0gY2xhc3NOYW1lPXtjbGFzc05hbWVzfSB7Li4ucHJvcHN9PlxyXG4gICAgICAgICAgICB7Y2hpbGRyZW59XHJcbiAgICAgICAgPC9zcGFuPlxyXG4gICAgKTtcclxufSk7XHJcblxyXG5GbG9hdGluZ0xhYmVsLmRpc3BsYXlOYW1lID0gJ01EQ0Zsb2F0aW5nTGFiZWwnO1xyXG5cclxuRmxvYXRpbmdMYWJlbC5wcm9wVHlwZXMgPSB7XHJcbiAgICBsYWJlbDogUHJvcFR5cGVzLnN0cmluZyxcclxuICAgIGZsb2F0OiBQcm9wVHlwZXMuYm9vbCxcclxuICAgIHJlcXVpcmVkOiBQcm9wVHlwZXMuYm9vbFxyXG59O1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgRmxvYXRpbmdMYWJlbDsiLCJleHBvcnQgeyBkZWZhdWx0IH0gZnJvbSAnLi9GbG9hdGluZ0xhYmVsJzsiLCJleHBvcnQgY29uc3QgY3NzQ2xhc3NlcyA9IHtcclxuICAgIFJPT1Q6ICdtZGMtbGluZS1yaXBwbGUnLFxyXG4gICAgQUNUSVZFOiAnbWRjLWxpbmUtcmlwcGxlLS1hY3RpdmUnLFxyXG4gICAgREVBQ1RJVkFUSU5HOiAnbWRjLWxpbmUtcmlwcGxlLS1kZWFjdGl2YXRpbmcnXHJcbn07IiwiaW1wb3J0IHsgZm9yd2FyZFJlZiB9IGZyb20gJ3JlYWN0JztcclxuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcclxuaW1wb3J0IGNsYXNzbmFtZXMgZnJvbSAnY2xhc3NuYW1lcyc7XHJcblxyXG5pbXBvcnQgeyBjc3NDbGFzc2VzIH0gZnJvbSAnLi9jb25zdGFudHMnO1xyXG5cclxuY29uc3QgTGluZVJpcHBsZSA9IGZvcndhcmRSZWYoKHtcclxuICAgIGFjdGl2ZSA9IGZhbHNlLFxyXG4gICAgdHJhbnNmb3JtT3JpZ2luLFxyXG5cclxuICAgIC4uLnByb3BzXHJcbn0sIHJlZikgPT4ge1xyXG4gICAgY29uc3Qgc3R5bGUgPSB0cmFuc2Zvcm1PcmlnaW4gJiYge1xyXG4gICAgICAgIHRyYW5zZm9ybU9yaWdpbjogYCR7dHJhbnNmb3JtT3JpZ2lufXB4YFxyXG4gICAgfTtcclxuXHJcbiAgICBjb25zdCBjbGFzc05hbWVzID0gY2xhc3NuYW1lcyhjc3NDbGFzc2VzLlJPT1QsIHtcclxuICAgICAgICBbY3NzQ2xhc3Nlcy5BQ1RJVkVdOiBhY3RpdmVcclxuICAgIH0pO1xyXG5cclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgPHNwYW5cclxuICAgICAgICAgICAgcmVmPXtyZWZ9XHJcbiAgICAgICAgICAgIHN0eWxlPXtzdHlsZX1cclxuICAgICAgICAgICAgY2xhc3NOYW1lPXtjbGFzc05hbWVzfVxyXG4gICAgICAgICAgICB7Li4ucHJvcHN9XHJcbiAgICAgICAgLz5cclxuICAgICk7XHJcbn0pO1xyXG5cclxuTGluZVJpcHBsZS5kaXNwbGF5TmFtZSA9ICdNRENMaW5lUmlwcGxlJztcclxuXHJcbkxpbmVSaXBwbGUucHJvcFR5cGVzID0ge1xyXG4gICAgYWN0aXZlOiBQcm9wVHlwZXMuYm9vbFxyXG59O1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgTGluZVJpcHBsZTsiLCJleHBvcnQgeyBkZWZhdWx0IH0gZnJvbSAnLi9MaW5lUmlwcGxlJzsiLCJleHBvcnQgY29uc3QgS2V5ID0ge1xyXG4gICAgQVJST1dfTEVGVDogJ0Fycm93TGVmdCcsXHJcbiAgICBBUlJPV19VUDogJ0Fycm93VXAnLFxyXG4gICAgQVJST1dfUklHSFQ6ICdBcnJvd1JpZ2h0JyxcclxuICAgIEFSUk9XX0RPV046ICdBcnJvd0Rvd24nLFxyXG4gICAgSE9NRTogJ0hvbWUnLFxyXG4gICAgRU5EOiAnRW5kJyxcclxuICAgIFBBR0VfVVA6ICdQYWdlVXAnLFxyXG4gICAgUEFHRV9ET1dOOiAnUGFnZURvd24nXHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgS2V5Q29kZSA9IHtcclxuICAgIFBBR0VfVVA6IDMzLFxyXG4gICAgUEFHRV9ET1dOOiAzNCxcclxuICAgIEVORDogMzUsXHJcbiAgICBIT01FOiAzNixcclxuICAgIEFSUk9XX0xFRlQ6IDM3LFxyXG4gICAgQVJST1dfVVA6IDM4LFxyXG4gICAgQVJST1dfUklHSFQ6IDM5LFxyXG4gICAgQVJST1dfRE9XTjogNDBcclxufTsiLCJpbXBvcnQgeyBLZXksIEtleUNvZGUgfSBmcm9tICcuL2NvbnN0YW50cyc7XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gZ2V0Q2xpZW50V2lkdGgoZWxlbWVudCkge1xyXG4gICAgaWYgKGVsZW1lbnQub2Zmc2V0UGFyZW50ICE9PSBudWxsKSB7XHJcbiAgICAgICAgcmV0dXJuIGVsZW1lbnQuY2xpZW50V2lkdGg7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgY2xvbmUgPSBlbGVtZW50LmNsb25lTm9kZSh0cnVlKTtcclxuICAgIGNsb25lLnN0eWxlLnNldFByb3BlcnR5KCdwb3NpdGlvbicsICdhYnNvbHV0ZScpO1xyXG4gICAgY2xvbmUuc3R5bGUuc2V0UHJvcGVydHkoJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUoLTk5OTlweCwgLTk5OTlweCknKTtcclxuICAgIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5hcHBlbmRDaGlsZChjbG9uZSk7XHJcbiAgICBjb25zdCBjbGllbnRXaWR0aCA9IGNsb25lLmNsaWVudFdpZHRoO1xyXG4gICAgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnJlbW92ZUNoaWxkKGNsb25lKTtcclxuXHJcbiAgICByZXR1cm4gY2xpZW50V2lkdGg7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRDbGllbnRIZWlnaHQoZWxlbWVudCkge1xyXG4gICAgaWYgKGVsZW1lbnQub2Zmc2V0UGFyZW50ICE9PSBudWxsKSB7XHJcbiAgICAgICAgcmV0dXJuIGVsZW1lbnQuY2xpZW50SGVpZ2h0O1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IGNsb25lID0gZWxlbWVudC5jbG9uZU5vZGUodHJ1ZSk7XHJcbiAgICBjbG9uZS5zdHlsZS5zZXRQcm9wZXJ0eSgncG9zaXRpb24nLCAnYWJzb2x1dGUnKTtcclxuICAgIGNsb25lLnN0eWxlLnNldFByb3BlcnR5KCd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlKC05OTk5cHgsIC05OTk5cHgpJyk7XHJcbiAgICBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuYXBwZW5kQ2hpbGQoY2xvbmUpO1xyXG4gICAgY29uc3QgY2xpZW50SGVpZ2h0ID0gY2xvbmUuY2xpZW50SGVpZ2h0O1xyXG4gICAgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnJlbW92ZUNoaWxkKGNsb25lKTtcclxuXHJcbiAgICByZXR1cm4gY2xpZW50SGVpZ2h0O1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gZ2V0RXZlbnRLZXkoZXZlbnQpIHtcclxuICAgIHN3aXRjaCAoZXZlbnQua2V5IHx8IGV2ZW50LmtleUNvZGUpIHtcclxuICAgICAgICBjYXNlIEtleS5BUlJPV19MRUZUOlxyXG4gICAgICAgIGNhc2UgS2V5Q29kZS5BUlJPV19MRUZUOlxyXG4gICAgICAgICAgICByZXR1cm4gS2V5LkFSUk9XX0xFRlQ7XHJcblxyXG4gICAgICAgIGNhc2UgS2V5LkFSUk9XX1VQOlxyXG4gICAgICAgIGNhc2UgS2V5Q29kZS5BUlJPV19VUDpcclxuICAgICAgICAgICAgcmV0dXJuIEtleS5BUlJPV19VUDtcclxuXHJcbiAgICAgICAgY2FzZSBLZXkuQVJST1dfUklHSFQ6XHJcbiAgICAgICAgY2FzZSBLZXlDb2RlLkFSUk9XX1JJR0hUOlxyXG4gICAgICAgICAgICByZXR1cm4gS2V5LkFSUk9XX1JJR0hUO1xyXG5cclxuICAgICAgICBjYXNlIEtleS5BUlJPV19ET1dOOlxyXG4gICAgICAgIGNhc2UgS2V5Q29kZS5BUlJPV19ET1dOOlxyXG4gICAgICAgICAgICByZXR1cm4gS2V5LkFSUk9XX0RPV047XHJcblxyXG4gICAgICAgIGNhc2UgS2V5LkhPTUU6XHJcbiAgICAgICAgY2FzZSBLZXlDb2RlLkhPTUU6XHJcbiAgICAgICAgICAgIHJldHVybiBLZXkuSE9NRTtcclxuXHJcbiAgICAgICAgY2FzZSBLZXkuRU5EOlxyXG4gICAgICAgIGNhc2UgS2V5Q29kZS5FTkQ6XHJcbiAgICAgICAgICAgIHJldHVybiBLZXkuRU5EO1xyXG5cclxuICAgICAgICBjYXNlIEtleS5QQUdFX1VQOlxyXG4gICAgICAgIGNhc2UgS2V5Q29kZS5QQUdFX1VQOlxyXG4gICAgICAgICAgICByZXR1cm4gS2V5LlBBR0VfVVA7XHJcblxyXG4gICAgICAgIGNhc2UgS2V5LlBBR0VfRE9XTjpcclxuICAgICAgICBjYXNlIEtleUNvZGUuUEFHRV9ET1dOOlxyXG4gICAgICAgICAgICByZXR1cm4gS2V5LlBBR0VfRE9XTjtcclxuXHJcbiAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgIH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGdldFBhZ2VYKGV2ZW50KSB7XHJcbiAgICBpZiAoZXZlbnQudGFyZ2V0VG91Y2hlcz8ubGVuZ3RoID4gMCkge1xyXG4gICAgICAgIHJldHVybiBldmVudC50YXJnZXRUb3VjaGVzWzBdLnBhZ2VYO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBldmVudC5wYWdlWDtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGdldFBhZ2VZKGV2ZW50KSB7XHJcbiAgICBpZiAoZXZlbnQudGFyZ2V0VG91Y2hlcz8ubGVuZ3RoID4gMCkge1xyXG4gICAgICAgIHJldHVybiBldmVudC50YXJnZXRUb3VjaGVzWzBdLnBhZ2VZO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBldmVudC5wYWdlWTtcclxufSIsImV4cG9ydCBjb25zdCBudW1iZXJzID0ge1xyXG4gICAgTk9UQ0hfU0laRV9GQUNUT1I6IDAuNzUsXHJcbiAgICBOT1RDSF9QQURESU5HX1JJR0hUOiA4XHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgY3NzQ2xhc3NlcyA9IHtcclxuICAgIFJPT1Q6ICdtZGMtbm90Y2hlZC1vdXRsaW5lJyxcclxuICAgIE5PVENIRUQ6ICdtZGMtbm90Y2hlZC1vdXRsaW5lLS1ub3RjaGVkJyxcclxuICAgIFVQR1JBREVEOiAnbWRjLW5vdGNoZWQtb3V0bGluZS0tdXBncmFkZWQnLFxyXG4gICAgTk9fTEFCRUw6ICdtZGMtbm90Y2hlZC1vdXRsaW5lLS1uby1sYWJlbCcsXHJcblxyXG4gICAgTEVBRElORzogJ21kYy1ub3RjaGVkLW91dGxpbmVfX2xlYWRpbmcnLFxyXG4gICAgTk9UQ0g6ICdtZGMtbm90Y2hlZC1vdXRsaW5lX19ub3RjaCcsXHJcbiAgICBUUkFJTElORzogJ21kYy1ub3RjaGVkLW91dGxpbmVfX3RyYWlsaW5nJ1xyXG59OyIsImltcG9ydCB7IGZvcndhcmRSZWYsIHVzZVJlZiwgdXNlTGF5b3V0RWZmZWN0IH0gZnJvbSAncmVhY3QnO1xyXG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xyXG5pbXBvcnQgY2xhc3NuYW1lcyBmcm9tICdjbGFzc25hbWVzJztcclxuXHJcbmltcG9ydCB7IGdldENsaWVudFdpZHRoIH0gZnJvbSAnLi4vdXRpbHMnO1xyXG5cclxuaW1wb3J0IHsgbnVtYmVycywgY3NzQ2xhc3NlcyB9IGZyb20gJy4vY29uc3RhbnRzJztcclxuXHJcbmNvbnN0IE5vdGNoZWRPdXRsaW5lID0gZm9yd2FyZFJlZigoe1xyXG4gICAgbm90Y2hlZCA9IGZhbHNlLFxyXG5cclxuICAgIGNsYXNzTmFtZSxcclxuICAgIGNoaWxkcmVuLFxyXG4gICAgLi4ucHJvcHNcclxufSwgcmVmKSA9PiB7XHJcbiAgICBjb25zdCBub3RjaFJlZiA9IHVzZVJlZigpO1xyXG5cclxuICAgIHVzZUxheW91dEVmZmVjdCgoKSA9PiB7XHJcbiAgICAgICAgY29uc3Qgbm90Y2ggPSBub3RjaFJlZi5jdXJyZW50O1xyXG4gICAgICAgIGNvbnN0IGZsb2F0aW5nTGFiZWwgPSBub3RjaD8uZmlyc3RDaGlsZDtcclxuXHJcbiAgICAgICAgaWYgKCFub3RjaCB8fCAhZmxvYXRpbmdMYWJlbCkgcmV0dXJuO1xyXG5cclxuICAgICAgICBjb25zdCB3aWR0aCA9IGdldENsaWVudFdpZHRoKGZsb2F0aW5nTGFiZWwpO1xyXG5cclxuICAgICAgICBpZiAobm90Y2hlZCkge1xyXG4gICAgICAgICAgICBub3RjaFJlZi5jdXJyZW50LnN0eWxlLndpZHRoID0gYCR7d2lkdGggKiBudW1iZXJzLk5PVENIX1NJWkVfRkFDVE9SICsgbnVtYmVycy5OT1RDSF9QQURESU5HX1JJR0hUfXB4YDtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBub3RjaFJlZi5jdXJyZW50LnN0eWxlLndpZHRoID0gJ2F1dG8nO1xyXG4gICAgICAgIH1cclxuICAgIH0sIFtub3RjaGVkXSk7XHJcblxyXG4gICAgY29uc3QgY2xhc3NOYW1lcyA9IGNsYXNzbmFtZXMoY3NzQ2xhc3Nlcy5ST09ULCBjc3NDbGFzc2VzLlVQR1JBREVELCB7XHJcbiAgICAgICAgW2Nzc0NsYXNzZXMuTk9UQ0hFRF06IG5vdGNoZWQsXHJcbiAgICAgICAgW2Nzc0NsYXNzZXMuTk9fTEFCRUxdOiAhY2hpbGRyZW5cclxuICAgIH0sIGNsYXNzTmFtZSk7XHJcblxyXG4gICAgcmV0dXJuIChcclxuICAgICAgICA8c3BhbiByZWY9e3JlZn0gY2xhc3NOYW1lPXtjbGFzc05hbWVzfSB7Li4ucHJvcHN9PlxyXG4gICAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9e2Nzc0NsYXNzZXMuTEVBRElOR30gLz5cclxuXHJcbiAgICAgICAgICAgIHtjaGlsZHJlbiAmJlxyXG4gICAgICAgICAgICAgICAgPHNwYW4gcmVmPXtub3RjaFJlZn0gY2xhc3NOYW1lPXtjc3NDbGFzc2VzLk5PVENIfT5cclxuICAgICAgICAgICAgICAgICAgICB7Y2hpbGRyZW59XHJcbiAgICAgICAgICAgICAgICA8L3NwYW4+XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT17Y3NzQ2xhc3Nlcy5UUkFJTElOR30gLz5cclxuICAgICAgICA8L3NwYW4+XHJcbiAgICApO1xyXG59KTtcclxuXHJcbk5vdGNoZWRPdXRsaW5lLmRpc3BsYXlOYW1lID0gJ01EQ05vdGNoZWRPdXRsaW5lJztcclxuXHJcbk5vdGNoZWRPdXRsaW5lLnByb3BUeXBlcyA9IHtcclxuICAgIG5vdGNoZWQ6IFByb3BUeXBlcy5ib29sXHJcbn07XHJcblxyXG5leHBvcnQgZGVmYXVsdCBOb3RjaGVkT3V0bGluZTsiLCJleHBvcnQgeyBkZWZhdWx0IH0gZnJvbSAnLi9Ob3RjaGVkT3V0bGluZSc7IiwiZXhwb3J0IGNvbnN0IG51bWJlcnMgPSB7XHJcbiAgICBUUkFOU0lUSU9OX09QRU5fRFVSQVRJT046IDEyMCxcclxuICAgIFRSQU5TSVRJT05fQ0xPU0VfRFVSQVRJT046IDc1LFxyXG4gICAgTUFSR0lOX1RPX0VER0U6IDMyLFxyXG4gICAgQU5DSE9SX1RPX01FTlVfU1VSRkFDRV9XSURUSF9SQVRJTzogMC42NyxcclxuICAgIFRPVUNIX0VWRU5UX1dBSVRfTVM6IDMwXHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgY3NzQ2xhc3NlcyA9IHtcclxuICAgIFJPT1Q6ICdtZGMtbWVudScsXHJcblxyXG4gICAgU1VSRkFDRTogJ21kYy1tZW51LXN1cmZhY2UnLFxyXG4gICAgU1VSRkFDRV9BTkNIT1I6ICdtZGMtbWVudS1zdXJmYWNlLS1hbmNob3InLFxyXG4gICAgU1VSRkFDRV9GSVhFRDogJ21kYy1tZW51LXN1cmZhY2UtLWZpeGVkJyxcclxuICAgIFNVUkZBQ0VfT1BFTjogJ21kYy1tZW51LXN1cmZhY2UtLW9wZW4nLFxyXG4gICAgU1VSRkFDRV9BTklNQVRJTkdfT1BFTjogJ21kYy1tZW51LXN1cmZhY2UtLWFuaW1hdGluZy1vcGVuJyxcclxuICAgIFNVUkZBQ0VfQU5JTUFUSU5HX0NMT1NFRDogJ21kYy1tZW51LXN1cmZhY2UtLWFuaW1hdGluZy1jbG9zZWQnLFxyXG4gICAgU1VSRkFDRV9CRUxPV19BTkNIT1I6ICdtZGMtbWVudS1zdXJmYWNlLS1pcy1vcGVuLWJlbG93JyxcclxuXHJcbiAgICBJVEVNOiAnbWRjLW1lbnUtaXRlbScsXHJcbiAgICBJVEVNX1NFTEVDVEVEOiAnbWRjLW1lbnUtaXRlbS0tc2VsZWN0ZWQnLFxyXG5cclxuICAgIFNFTEVDVElPTl9HUk9VUDogJ21kYy1tZW51X19zZWxlY3Rpb24tZ3JvdXAnLFxyXG4gICAgU0VMRUNUSU9OX0dST1VQX0lDT046ICdtZGMtbWVudV9fc2VsZWN0aW9uLWdyb3VwLWljb24nXHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgT3JpZ2luID0ge1xyXG4gICAgVE9QX0xFRlQ6ICd0b3AgbGVmdCcsXHJcbiAgICBUT1BfQ0VOVEVSOiAndG9wIGNlbnRlcicsXHJcbiAgICBUT1BfUklHSFQ6ICd0b3AgcmlnaHQnLFxyXG4gICAgQ0VOVEVSX0xFRlQ6ICdjZW50ZXIgbGVmdCcsXHJcbiAgICBDRU5URVI6ICdjZW50ZXIgY2VudGVyJyxcclxuICAgIENFTlRFUl9SSUdIVDogJ2NlbnRlciByaWdodCcsXHJcbiAgICBCT1RUT01fTEVGVDogJ2JvdHRvbSBsZWZ0JyxcclxuICAgIEJPVFRPTV9DRU5URVI6ICdib3R0b20gY2VudGVyJyxcclxuICAgIEJPVFRPTV9SSUdIVDogJ2JvdHRvbSByaWdodCdcclxufTsiLCJpbXBvcnQgeyB1c2VFZmZlY3QsIHVzZUxheW91dEVmZmVjdCwgdXNlU3RhdGUgfSBmcm9tICdyZWFjdCc7XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gdXNlQ3JlYXRlZChmbikge1xyXG4gICAgY29uc3QgW2NyZWF0ZWQsIHNldENyZWF0ZWRdID0gdXNlU3RhdGUoZmFsc2UpO1xyXG5cclxuICAgIGlmIChjcmVhdGVkKSByZXR1cm47XHJcblxyXG4gICAgZm4oKTtcclxuICAgIHNldENyZWF0ZWQodHJ1ZSk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiB1c2VNb3VudGVkKGZuKSB7XHJcbiAgICB1c2VFZmZlY3QoKCkgPT4gZm4oKSwgW10pO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gdXNlVXBkYXRlZChmbiwgZGVwcykge1xyXG4gICAgY29uc3QgW21vdW50ZWQsIHNldE1vdW50ZWRdID0gdXNlU3RhdGUoZmFsc2UpO1xyXG5cclxuICAgIHVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICAgICAgaWYgKCFtb3VudGVkKSByZXR1cm4gc2V0TW91bnRlZCh0cnVlKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIGZuKCk7XHJcbiAgICB9LCBkZXBzKTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIHVzZVVwZGF0ZWRTeW5jKGZuLCBkZXBzKSB7XHJcbiAgICBjb25zdCBbbW91bnRlZCwgc2V0TW91bnRlZF0gPSB1c2VTdGF0ZShmYWxzZSk7XHJcblxyXG4gICAgdXNlTGF5b3V0RWZmZWN0KCgpID0+IHtcclxuICAgICAgICBpZiAoIW1vdW50ZWQpIHJldHVybiBzZXRNb3VudGVkKHRydWUpO1xyXG5cclxuICAgICAgICByZXR1cm4gZm4oKTtcclxuICAgIH0sIGRlcHMpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gdXNlVW5tb3VudGVkKGZuKSB7XHJcbiAgICB1c2VFZmZlY3QoKCkgPT4gKCkgPT4gZm4oKSwgW10pO1xyXG59IiwiZXhwb3J0IGNvbnN0IGxpc3RDc3NDbGFzc2VzID0ge1xyXG4gICAgUk9PVDogJ21kYy1saXN0J1xyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IGxpc3RJdGVtQ3NzQ2xhc3NlcyA9IHtcclxuICAgIFJPT1Q6ICdtZGMtbGlzdC1pdGVtJyxcclxuICAgIEFDVElWQVRFRDogJ21kYy1saXN0LWl0ZW0tLWFjdGl2YXRlZCcsXHJcbiAgICBTRUxFQ1RFRDogJ21kYy1saXN0LWl0ZW0tLXNlbGVjdGVkJyxcclxuICAgIERJU0FCTEVEOiAnbWRjLWxpc3QtaXRlbS0tZGlzYWJsZWQnLFxyXG4gICAgTk9OX0lOVEVSQUNUSVZFOiAnbWRjLWxpc3QtaXRlbS0tbm9uLWludGVyYWN0aXZlJyxcclxuXHJcbiAgICBPTkVfTElORTogJ21kYy1saXN0LWl0ZW0tLXdpdGgtb25lLWxpbmUnLFxyXG4gICAgVFdPX0xJTkVTOiAnbWRjLWxpc3QtaXRlbS0td2l0aC10d28tbGluZXMnLFxyXG4gICAgVEhSRUVfTElORVM6ICdtZGMtbGlzdC1pdGVtLS13aXRoLXRocmVlLWxpbmVzJyxcclxuICAgIE9WRVJMSU5FOiAnbWRjLWxpc3QtaXRlbS0td2l0aC1vdmVybGluZScsXHJcbiAgICBMRUFESU5HX0lDT046ICdtZGMtbGlzdC1pdGVtLS13aXRoLWxlYWRpbmctaWNvbicsXHJcbiAgICBMRUFESU5HX0lNQUdFOiAnbWRjLWxpc3QtaXRlbS0td2l0aC1sZWFkaW5nLWltYWdlJyxcclxuICAgIExFQURJTkdfQVZBVEFSOiAnbWRjLWxpc3QtaXRlbS0td2l0aC1sZWFkaW5nLWF2YXRhcicsXHJcbiAgICBMRUFESU5HX1RIVU1CTkFJTDogJ21kYy1saXN0LWl0ZW0tLXdpdGgtbGVhZGluZy10aHVtYm5haWwnLFxyXG4gICAgTEVBRElOR19WSURFTzogJ21kYy1saXN0LWl0ZW0tLXdpdGgtbGVhZGluZy12aWRlbycsXHJcbiAgICBMRUFESU5HX0NIRUNLQk9YOiAnbWRjLWxpc3QtaXRlbS0td2l0aC1sZWFkaW5nLWNoZWNrYm94JyxcclxuICAgIExFQURJTkdfUkFESU86ICdtZGMtbGlzdC1pdGVtLS13aXRoLWxlYWRpbmctcmFkaW8nLFxyXG4gICAgTEVBRElOR19TV0lUQ0g6ICdtZGMtbGlzdC1pdGVtLS13aXRoLWxlYWRpbmctc3dpdGNoJyxcclxuICAgIFRSQUlMSU5HX0lDT046ICdtZGMtbGlzdC1pdGVtLS13aXRoLXRyYWlsaW5nLWljb24nLFxyXG4gICAgVFJBSUxJTkdfTUVUQTogJ21kYy1saXN0LWl0ZW0tLXdpdGgtdHJhaWxpbmctbWV0YScsXHJcbiAgICBUUkFJTElOR19DSEVDS0JPWDogJ21kYy1saXN0LWl0ZW0tLXdpdGgtdHJhaWxpbmctY2hlY2tib3gnLFxyXG4gICAgVFJBSUxJTkdfUkFESU86ICdtZGMtbGlzdC1pdGVtLS13aXRoLXRyYWlsaW5nLXJhZGlvJyxcclxuICAgIFRSQUlMSU5HX1NXSVRDSDogJ21kYy1saXN0LWl0ZW0tLXdpdGgtdHJhaWxpbmctc3dpdGNoJyxcclxuXHJcbiAgICBTVEFSVDogJ21kYy1saXN0LWl0ZW1fX3N0YXJ0JyxcclxuICAgIENPTlRFTlQ6ICdtZGMtbGlzdC1pdGVtX19jb250ZW50JyxcclxuICAgIEVORDogJ21kYy1saXN0LWl0ZW1fX2VuZCcsXHJcblxyXG4gICAgT1ZFUkxJTkVfVEVYVDogJ21kYy1saXN0LWl0ZW1fX292ZXJsaW5lLXRleHQnLFxyXG4gICAgUFJJTUFSWV9URVhUOiAnbWRjLWxpc3QtaXRlbV9fcHJpbWFyeS10ZXh0JyxcclxuICAgIFNFQ09OREFSWV9URVhUOiAnbWRjLWxpc3QtaXRlbV9fc2Vjb25kYXJ5LXRleHQnLFxyXG5cclxuICAgIFJJUFBMRTogJ21kYy1saXN0LWl0ZW1fX3JpcHBsZSdcclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCBsaXN0R3JvdXBDc3NDbGFzc2VzID0ge1xyXG4gICAgUk9PVDogJ21kYy1saXN0LWdyb3VwJyxcclxuICAgIFNVQkhFQURFUjogJ21kYy1saXN0LWdyb3VwX19zdWJoZWFkZXInXHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgbGlzdERpdmlkZXJDc3NDbGFzc2VzID0ge1xyXG4gICAgUk9PVDogJ21kYy1saXN0LWRpdmlkZXInLFxyXG4gICAgTEVBRElOR19URVhUOiAnbWRjLWxpc3QtZGl2aWRlci0td2l0aC1sZWFkaW5nLXRleHQnLFxyXG4gICAgTEVBRElOR19JQ09OOiAnbWRjLWxpc3QtZGl2aWRlci0td2l0aC1sZWFkaW5nLWljb24nLFxyXG4gICAgTEVBRElOR19JTUFHRTogJ21kYy1saXN0LWRpdmlkZXItLXdpdGgtbGVhZGluZy1pbWFnZScsXHJcbiAgICBMRUFESU5HX1ZJREVPOiAnbWRjLWxpc3QtZGl2aWRlci0td2l0aC1sZWFkaW5nLXZpZGVvJyxcclxuICAgIExFQURJTkdfVEhVTUJOQUlMOiAnbWRjLWxpc3QtZGl2aWRlci0td2l0aC1sZWFkaW5nLXRodW1ibmFpbCcsXHJcbiAgICBMRUFESU5HX0FWQVRBUjogJ21kYy1saXN0LWRpdmlkZXItLXdpdGgtbGVhZGluZy1hdmF0YXInLFxyXG4gICAgTEVBRElOR19DSEVDS0JPWDogJ21kYy1saXN0LWRpdmlkZXItLXdpdGgtbGVhZGluZy1jaGVja2JveCcsXHJcbiAgICBMRUFESU5HX1NXSVRDSDogJ21kYy1saXN0LWRpdmlkZXItLXdpdGgtbGVhZGluZy1zd2l0Y2gnLFxyXG4gICAgTEVBRElOR19SQURJTzogJ21kYy1saXN0LWRpdmlkZXItLXdpdGgtbGVhZGluZy1yYWRpbycsXHJcbn07IiwiaW1wb3J0IHsgZm9yd2FyZFJlZiB9IGZyb20gJ3JlYWN0JztcclxuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcclxuaW1wb3J0IGNsYXNzbmFtZXMgZnJvbSAnY2xhc3NuYW1lcyc7XHJcblxyXG5pbXBvcnQgeyBDbG9uZSB9IGZyb20gJy4uL2NvbXBvbmVudCc7XHJcblxyXG5pbXBvcnQgeyBsaXN0SXRlbUNzc0NsYXNzZXMgYXMgY3NzQ2xhc3NlcyB9IGZyb20gJy4vY29uc3RhbnRzJztcclxuXHJcbmNvbnN0IExpc3RJdGVtQ29udGVudCA9IGZvcndhcmRSZWYoKHtcclxuICAgIG92ZXJsaW5lLFxyXG4gICAgcHJpbWFyeSxcclxuICAgIHNlY29uZGFyeSxcclxuICAgIG92ZXJsaW5lVGV4dCA9IG92ZXJsaW5lLFxyXG4gICAgcHJpbWFyeVRleHQgPSBwcmltYXJ5LFxyXG4gICAgc2Vjb25kYXJ5VGV4dCA9IHNlY29uZGFyeSxcclxuXHJcbiAgICBlbGVtZW50ID0gJ3NwYW4nLFxyXG4gICAgY29tcG9uZW50OiBFbGVtZW50ID0gZWxlbWVudCxcclxuICAgIGNsYXNzTmFtZSxcclxuICAgIGNoaWxkcmVuLFxyXG4gICAgLi4ucHJvcHNcclxufSwgcmVmKSA9PiB7XHJcbiAgICBjb25zdCBjbGFzc05hbWVzID0gY2xhc3NuYW1lcyhjc3NDbGFzc2VzLkNPTlRFTlQsIGNsYXNzTmFtZSk7XHJcblxyXG4gICAgcmV0dXJuIChcclxuICAgICAgICA8RWxlbWVudCByZWY9e3JlZn0gY2xhc3NOYW1lPXtjbGFzc05hbWVzfSB7Li4ucHJvcHN9PlxyXG4gICAgICAgICAgICB7b3ZlcmxpbmVUZXh0ICYmXHJcbiAgICAgICAgICAgICAgICA8Q2xvbmVcclxuICAgICAgICAgICAgICAgICAgICBjb21wb25lbnQ9e292ZXJsaW5lVGV4dH1cclxuICAgICAgICAgICAgICAgICAgICBmYWxsYmFjaz1cInNwYW5cIlxyXG4gICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT17Y3NzQ2xhc3Nlcy5PVkVSTElORV9URVhUfVxyXG4gICAgICAgICAgICAgICAgLz5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAge3ByaW1hcnlUZXh0ICYmXHJcbiAgICAgICAgICAgICAgICA8Q2xvbmVcclxuICAgICAgICAgICAgICAgICAgICBjb21wb25lbnQ9e3ByaW1hcnlUZXh0fVxyXG4gICAgICAgICAgICAgICAgICAgIGZhbGxiYWNrPVwic3BhblwiXHJcbiAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPXtjc3NDbGFzc2VzLlBSSU1BUllfVEVYVH1cclxuICAgICAgICAgICAgICAgIC8+XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHtzZWNvbmRhcnlUZXh0ICYmXHJcbiAgICAgICAgICAgICAgICA8Q2xvbmVcclxuICAgICAgICAgICAgICAgICAgICBjb21wb25lbnQ9e3NlY29uZGFyeVRleHR9XHJcbiAgICAgICAgICAgICAgICAgICAgZmFsbGJhY2s9XCJzcGFuXCJcclxuICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU9e2Nzc0NsYXNzZXMuU0VDT05EQVJZX1RFWFR9XHJcbiAgICAgICAgICAgICAgICAvPlxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB7Y2hpbGRyZW59XHJcbiAgICAgICAgPC9FbGVtZW50PlxyXG4gICAgKTtcclxufSk7XHJcblxyXG5MaXN0SXRlbUNvbnRlbnQuZGlzcGxheU5hbWUgPSAnTURDTGlzdEl0ZW1Db250ZW50JztcclxuXHJcbkxpc3RJdGVtQ29udGVudC5wcm9wVHlwZXMgPSB7XHJcbiAgICBvdmVybGluZVRleHQ6IFByb3BUeXBlcy5ub2RlLFxyXG4gICAgcHJpbWFyeVRleHQ6IFByb3BUeXBlcy5ub2RlLFxyXG4gICAgc2Vjb25kYXJ5VGV4dDogUHJvcFR5cGVzLm5vZGVcclxufTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IExpc3RJdGVtQ29udGVudDsiLCJpbXBvcnQgeyBmb3J3YXJkUmVmIH0gZnJvbSAncmVhY3QnO1xyXG5pbXBvcnQgY2xhc3NuYW1lcyBmcm9tICdjbGFzc25hbWVzJztcclxuXHJcbmltcG9ydCB7IGxpc3RJdGVtQ3NzQ2xhc3NlcyBhcyBjc3NDbGFzc2VzIH0gZnJvbSAnLi9jb25zdGFudHMnO1xyXG5cclxuY29uc3QgTGlzdEl0ZW1FbmQgPSBmb3J3YXJkUmVmKCh7XHJcbiAgICBlbGVtZW50ID0gJ3NwYW4nLFxyXG4gICAgY29tcG9uZW50OiBFbGVtZW50ID0gZWxlbWVudCxcclxuICAgIGNsYXNzTmFtZSxcclxuICAgIC4uLnByb3BzXHJcbn0sIHJlZikgPT4ge1xyXG4gICAgY29uc3QgY2xhc3NOYW1lcyA9IGNsYXNzbmFtZXMoY3NzQ2xhc3Nlcy5FTkQsIGNsYXNzTmFtZSk7XHJcblxyXG4gICAgcmV0dXJuIChcclxuICAgICAgICA8RWxlbWVudCByZWY9e3JlZn0gY2xhc3NOYW1lPXtjbGFzc05hbWVzfSB7Li4ucHJvcHN9IC8+XHJcbiAgICApO1xyXG59KTtcclxuXHJcbkxpc3RJdGVtRW5kLmRpc3BsYXlOYW1lID0gJ01EQ0xpc3RJdGVtRW5kJztcclxuXHJcbmV4cG9ydCBkZWZhdWx0IExpc3RJdGVtRW5kOyIsImltcG9ydCB7IGZvcndhcmRSZWYgfSBmcm9tICdyZWFjdCc7XHJcbmltcG9ydCBjbGFzc25hbWVzIGZyb20gJ2NsYXNzbmFtZXMnO1xyXG5cclxuaW1wb3J0IHsgbGlzdEl0ZW1Dc3NDbGFzc2VzIGFzIGNzc0NsYXNzZXMgfSBmcm9tICcuL2NvbnN0YW50cyc7XHJcblxyXG5jb25zdCBMaXN0SXRlbVN0YXJ0ID0gZm9yd2FyZFJlZigoe1xyXG4gICAgZWxlbWVudCA9ICdzcGFuJyxcclxuICAgIGNvbXBvbmVudDogRWxlbWVudCA9IGVsZW1lbnQsXHJcbiAgICBjbGFzc05hbWUsXHJcbiAgICAuLi5wcm9wc1xyXG59LCByZWYpID0+IHtcclxuICAgIGNvbnN0IGNsYXNzTmFtZXMgPSBjbGFzc25hbWVzKGNzc0NsYXNzZXMuU1RBUlQsIGNsYXNzTmFtZSk7XHJcblxyXG4gICAgcmV0dXJuIChcclxuICAgICAgICA8RWxlbWVudCByZWY9e3JlZn0gY2xhc3NOYW1lPXtjbGFzc05hbWVzfSB7Li4ucHJvcHN9IC8+XHJcbiAgICApO1xyXG59KTtcclxuXHJcbkxpc3RJdGVtU3RhcnQuZGlzcGxheU5hbWUgPSAnTURDTGlzdEl0ZW1TdGFydCc7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBMaXN0SXRlbVN0YXJ0OyIsImltcG9ydCB7IGZvcndhcmRSZWYgfSBmcm9tICdyZWFjdCc7XHJcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XHJcbmltcG9ydCBjbGFzc25hbWVzIGZyb20gJ2NsYXNzbmFtZXMnO1xyXG5cclxuaW1wb3J0IHsgQ2xvbmUgfSBmcm9tICcuLi9jb21wb25lbnQnO1xyXG5pbXBvcnQgSWNvbiBmcm9tICcuLi9pY29uJztcclxuXHJcbmltcG9ydCB7IGxpc3RJdGVtQ3NzQ2xhc3NlcyBhcyBjc3NDbGFzc2VzIH0gZnJvbSAnLi9jb25zdGFudHMnO1xyXG5pbXBvcnQgTGlzdEl0ZW1Db250ZW50IGZyb20gJy4vTGlzdEl0ZW1Db250ZW50JztcclxuaW1wb3J0IExpc3RJdGVtRW5kIGZyb20gJy4vTGlzdEl0ZW1FbmQnO1xyXG5pbXBvcnQgTGlzdEl0ZW1TdGFydCBmcm9tICcuL0xpc3RJdGVtU3RhcnQnO1xyXG5cclxuY29uc3QgTGlzdEl0ZW0gPSBmb3J3YXJkUmVmKCh7XHJcbiAgICBzdGFydCxcclxuICAgIGNvbnRlbnQsXHJcbiAgICBlbmQsXHJcbiAgICB0ZXh0LFxyXG4gICAgb3ZlcmxpbmVUZXh0LFxyXG4gICAgcHJpbWFyeVRleHQgPSB0ZXh0LFxyXG4gICAgc2Vjb25kYXJ5VGV4dCxcclxuICAgIGljb24sXHJcbiAgICBpbWFnZSxcclxuICAgIGF2YXRhcixcclxuICAgIHRodW1ibmFpbCxcclxuICAgIHZpZGVvLFxyXG4gICAgbGVhZGluZ0ljb24gPSBpY29uLFxyXG4gICAgbGVhZGluZ0ltYWdlID0gaW1hZ2UsXHJcbiAgICBsZWFkaW5nQXZhdGFyID0gYXZhdGFyLFxyXG4gICAgbGVhZGluZ1RodW1ibmFpbCA9IHRodW1ibmFpbCxcclxuICAgIGxlYWRpbmdWaWRlbyA9IHZpZGVvLFxyXG4gICAgbGVhZGluZ0NoZWNrYm94LFxyXG4gICAgbGVhZGluZ1JhZGlvLFxyXG4gICAgbGVhZGluZ1N3aXRjaCxcclxuICAgIG1ldGEsXHJcbiAgICB0cmFpbGluZ01ldGEgPSBtZXRhLFxyXG4gICAgdHJhaWxpbmdJY29uLFxyXG4gICAgdHJhaWxpbmdDaGVja2JveCxcclxuICAgIHRyYWlsaW5nUmFkaW8sXHJcbiAgICB0cmFpbGluZ1N3aXRjaCxcclxuICAgIGFjdGl2YXRlZCA9IGZhbHNlLFxyXG4gICAgc2VsZWN0ZWQgPSBmYWxzZSxcclxuICAgIGRpc2FibGVkID0gZmFsc2UsXHJcbiAgICBub25JbnRlcmFjdGl2ZSA9IGZhbHNlLFxyXG4gICAgb25lTGluZSA9IGZhbHNlLFxyXG4gICAgdHdvTGluZXMgPSBmYWxzZSxcclxuICAgIHRocmVlTGluZXMgPSBmYWxzZSxcclxuICAgIHdpdGhMZWFkaW5nSWNvbiA9IEJvb2xlYW4obGVhZGluZ0ljb24pLFxyXG4gICAgd2l0aExlYWRpbmdJbWFnZSA9IEJvb2xlYW4obGVhZGluZ0ltYWdlKSxcclxuICAgIHdpdGhMZWFkaW5nQXZhdGFyID0gQm9vbGVhbihsZWFkaW5nQXZhdGFyKSxcclxuICAgIHdpdGhMZWFkaW5nVGh1bWJuYWlsID0gQm9vbGVhbihsZWFkaW5nVGh1bWJuYWlsKSxcclxuICAgIHdpdGhMZWFkaW5nVmlkZW8gPSBCb29sZWFuKGxlYWRpbmdWaWRlbyksXHJcbiAgICB3aXRoTGVhZGluZ0NoZWNrYm94ID0gQm9vbGVhbihsZWFkaW5nQ2hlY2tib3gpLFxyXG4gICAgd2l0aExlYWRpbmdSYWRpbyA9IEJvb2xlYW4obGVhZGluZ1JhZGlvKSxcclxuICAgIHdpdGhMZWFkaW5nU3dpdGNoID0gQm9vbGVhbihsZWFkaW5nU3dpdGNoKSxcclxuICAgIHdpdGhUcmFpbGluZ01ldGEgPSBCb29sZWFuKHRyYWlsaW5nTWV0YSksXHJcbiAgICB3aXRoVHJhaWxpbmdJY29uID0gQm9vbGVhbih0cmFpbGluZ0ljb24pLFxyXG4gICAgd2l0aFRyYWlsaW5nQ2hlY2tib3ggPSBCb29sZWFuKHRyYWlsaW5nQ2hlY2tib3gpLFxyXG4gICAgd2l0aFRyYWlsaW5nUmFkaW8gPSBCb29sZWFuKHRyYWlsaW5nUmFkaW8pLFxyXG4gICAgd2l0aFRyYWlsaW5nU3dpdGNoID0gQm9vbGVhbih0cmFpbGluZ1N3aXRjaCksXHJcblxyXG4gICAgZWxlbWVudCA9ICdsaScsXHJcbiAgICBjb21wb25lbnQ6IEVsZW1lbnQgPSBlbGVtZW50LFxyXG4gICAgY2xhc3NOYW1lLFxyXG4gICAgY2hpbGRyZW4sXHJcbiAgICAuLi5wcm9wc1xyXG59LCByZWYpID0+IHtcclxuICAgIGNvbnN0IGxpbmVzID0gQm9vbGVhbihvdmVybGluZVRleHQpICsgQm9vbGVhbihwcmltYXJ5VGV4dCkgKyBCb29sZWFuKHNlY29uZGFyeVRleHQpO1xyXG4gICAgY29uc3QgaGFzU3RhcnQgPSBCb29sZWFuKFxyXG4gICAgICAgIHN0YXJ0IHx8IGxlYWRpbmdJY29uIHx8IGxlYWRpbmdJbWFnZSB8fCBsZWFkaW5nQXZhdGFyIHx8IGxlYWRpbmdUaHVtYm5haWwgfHxcclxuICAgICAgICBsZWFkaW5nVmlkZW8gfHwgbGVhZGluZ0NoZWNrYm94IHx8IGxlYWRpbmdSYWRpbyB8fCBsZWFkaW5nU3dpdGNoXHJcbiAgICApO1xyXG4gICAgY29uc3QgaGFzQ29udGVudCA9IEJvb2xlYW4oY29udGVudCB8fCBvdmVybGluZVRleHQgfHwgcHJpbWFyeVRleHQgfHwgc2Vjb25kYXJ5VGV4dCk7XHJcbiAgICBjb25zdCBoYXNFbmQgPSBCb29sZWFuKFxyXG4gICAgICAgIGVuZCB8fCB0cmFpbGluZ01ldGEgfHwgdHJhaWxpbmdJY29uIHx8XHJcbiAgICAgICAgdHJhaWxpbmdDaGVja2JveCB8fCB0cmFpbGluZ1JhZGlvIHx8IHRyYWlsaW5nU3dpdGNoXHJcbiAgICApO1xyXG5cclxuICAgIGNvbnN0IGNsYXNzTmFtZXMgPSBjbGFzc25hbWVzKGNzc0NsYXNzZXMuUk9PVCwge1xyXG4gICAgICAgIFtjc3NDbGFzc2VzLkFDVElWQVRFRF06IGFjdGl2YXRlZCxcclxuICAgICAgICBbY3NzQ2xhc3Nlcy5TRUxFQ1RFRF06IHNlbGVjdGVkLFxyXG4gICAgICAgIFtjc3NDbGFzc2VzLkRJU0FCTEVEXTogZGlzYWJsZWQsXHJcbiAgICAgICAgW2Nzc0NsYXNzZXMuT05FX0xJTkVdOiBvbmVMaW5lIHx8IGxpbmVzID09PSAxLFxyXG4gICAgICAgIFtjc3NDbGFzc2VzLlRXT19MSU5FU106IHR3b0xpbmVzIHx8IGxpbmVzID09PSAyLFxyXG4gICAgICAgIFtjc3NDbGFzc2VzLlRIUkVFX0xJTkVTXTogdGhyZWVMaW5lcyB8fCBsaW5lcyA9PT0gMyxcclxuICAgICAgICBbY3NzQ2xhc3Nlcy5OT05fSU5URVJBQ1RJVkVdOiBub25JbnRlcmFjdGl2ZSxcclxuICAgICAgICBbY3NzQ2xhc3Nlcy5PVkVSTElORV06IG92ZXJsaW5lVGV4dCxcclxuICAgICAgICBbY3NzQ2xhc3Nlcy5MRUFESU5HX0lDT05dOiB3aXRoTGVhZGluZ0ljb24sXHJcbiAgICAgICAgW2Nzc0NsYXNzZXMuTEVBRElOR19JTUFHRV06IHdpdGhMZWFkaW5nSW1hZ2UsXHJcbiAgICAgICAgW2Nzc0NsYXNzZXMuTEVBRElOR19BVkFUQVJdOiB3aXRoTGVhZGluZ0F2YXRhcixcclxuICAgICAgICBbY3NzQ2xhc3Nlcy5MRUFESU5HX1RIVU1CTkFJTF06IHdpdGhMZWFkaW5nVGh1bWJuYWlsLFxyXG4gICAgICAgIFtjc3NDbGFzc2VzLkxFQURJTkdfVklERU9dOiB3aXRoTGVhZGluZ1ZpZGVvLFxyXG4gICAgICAgIFtjc3NDbGFzc2VzLkxFQURJTkdfQ0hFQ0tCT1hdOiB3aXRoTGVhZGluZ0NoZWNrYm94LFxyXG4gICAgICAgIFtjc3NDbGFzc2VzLkxFQURJTkdfUkFESU9dOiB3aXRoTGVhZGluZ1JhZGlvLFxyXG4gICAgICAgIFtjc3NDbGFzc2VzLkxFQURJTkdfU1dJVENIXTogd2l0aExlYWRpbmdTd2l0Y2gsXHJcbiAgICAgICAgW2Nzc0NsYXNzZXMuVFJBSUxJTkdfSUNPTl06IHdpdGhUcmFpbGluZ0ljb24sXHJcbiAgICAgICAgW2Nzc0NsYXNzZXMuVFJBSUxJTkdfTUVUQV06IHdpdGhUcmFpbGluZ01ldGEsXHJcbiAgICAgICAgW2Nzc0NsYXNzZXMuVFJBSUxJTkdfQ0hFQ0tCT1hdOiB3aXRoVHJhaWxpbmdDaGVja2JveCxcclxuICAgICAgICBbY3NzQ2xhc3Nlcy5UUkFJTElOR19SQURJT106IHdpdGhUcmFpbGluZ1JhZGlvLFxyXG4gICAgICAgIFtjc3NDbGFzc2VzLlRSQUlMSU5HX1NXSVRDSF06IHdpdGhUcmFpbGluZ1N3aXRjaFxyXG4gICAgfSwgY2xhc3NOYW1lKTtcclxuXHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAgIDxFbGVtZW50IHJlZj17cmVmfSBjbGFzc05hbWU9e2NsYXNzTmFtZXN9IHsuLi5wcm9wc30+XHJcbiAgICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT17Y3NzQ2xhc3Nlcy5SSVBQTEV9IC8+XHJcblxyXG4gICAgICAgICAgICB7aGFzU3RhcnQgJiZcclxuICAgICAgICAgICAgICAgIDxMaXN0SXRlbVN0YXJ0PlxyXG4gICAgICAgICAgICAgICAgICAgIHtzdGFydH1cclxuICAgICAgICAgICAgICAgICAgICB7bGVhZGluZ0ljb24gJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgPENsb25lXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21wb25lbnQ9e2xlYWRpbmdJY29ufVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmFsbGJhY2s9e0ljb259XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8+XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHtsZWFkaW5nSW1hZ2V9XHJcbiAgICAgICAgICAgICAgICAgICAge2xlYWRpbmdBdmF0YXJ9XHJcbiAgICAgICAgICAgICAgICAgICAge2xlYWRpbmdUaHVtYm5haWx9XHJcbiAgICAgICAgICAgICAgICAgICAge2xlYWRpbmdWaWRlb31cclxuICAgICAgICAgICAgICAgICAgICB7bGVhZGluZ0NoZWNrYm94fVxyXG4gICAgICAgICAgICAgICAgICAgIHtsZWFkaW5nUmFkaW99XHJcbiAgICAgICAgICAgICAgICAgICAge2xlYWRpbmdTd2l0Y2h9XHJcbiAgICAgICAgICAgICAgICA8L0xpc3RJdGVtU3RhcnQ+XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHtoYXNDb250ZW50ICYmXHJcbiAgICAgICAgICAgICAgICA8TGlzdEl0ZW1Db250ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgb3ZlcmxpbmVUZXh0PXtvdmVybGluZVRleHR9XHJcbiAgICAgICAgICAgICAgICAgICAgcHJpbWFyeVRleHQ9e3ByaW1hcnlUZXh0fVxyXG4gICAgICAgICAgICAgICAgICAgIHNlY29uZGFyeVRleHQ9e3NlY29uZGFyeVRleHR9XHJcbiAgICAgICAgICAgICAgICA+XHJcbiAgICAgICAgICAgICAgICAgICAge2NvbnRlbnR9XHJcbiAgICAgICAgICAgICAgICA8L0xpc3RJdGVtQ29udGVudD5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAge2hhc0VuZCAmJlxyXG4gICAgICAgICAgICAgICAgPExpc3RJdGVtRW5kPlxyXG4gICAgICAgICAgICAgICAgICAgIHtlbmR9XHJcbiAgICAgICAgICAgICAgICAgICAge3RyYWlsaW5nTWV0YX1cclxuICAgICAgICAgICAgICAgICAgICB7dHJhaWxpbmdJY29uICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxDbG9uZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50PXt0cmFpbGluZ0ljb259XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmYWxsYmFjaz17SWNvbn1cclxuICAgICAgICAgICAgICAgICAgICAgICAgLz5cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAge3RyYWlsaW5nQ2hlY2tib3h9XHJcbiAgICAgICAgICAgICAgICAgICAge3RyYWlsaW5nUmFkaW99XHJcbiAgICAgICAgICAgICAgICAgICAge3RyYWlsaW5nU3dpdGNofVxyXG4gICAgICAgICAgICAgICAgPC9MaXN0SXRlbUVuZD5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAge2NoaWxkcmVufVxyXG4gICAgICAgIDwvRWxlbWVudD5cclxuICAgICk7XHJcbn0pO1xyXG5cclxuTGlzdEl0ZW0uZGlzcGxheU5hbWUgPSAnTURDTGlzdEl0ZW0nO1xyXG5cclxuTGlzdEl0ZW0ucHJvcFR5cGVzID0ge1xyXG4gICAgc3RhcnQ6IFByb3BUeXBlcy5ub2RlLFxyXG4gICAgY29udGVudDogUHJvcFR5cGVzLm5vZGUsXHJcbiAgICBlbmQ6IFByb3BUeXBlcy5ub2RlLFxyXG4gICAgdGV4dDogUHJvcFR5cGVzLm5vZGUsXHJcbiAgICBvdmVybGluZVRleHQ6IFByb3BUeXBlcy5ub2RlLFxyXG4gICAgcHJpbWFyeVRleHQ6IFByb3BUeXBlcy5ub2RlLFxyXG4gICAgc2Vjb25kYXJ5VGV4dDogUHJvcFR5cGVzLm5vZGUsXHJcbiAgICBpY29uOiBQcm9wVHlwZXMubm9kZSxcclxuICAgIGltYWdlOiBQcm9wVHlwZXMuZWxlbWVudCxcclxuICAgIGF2YXRhcjogUHJvcFR5cGVzLmVsZW1lbnQsXHJcbiAgICB0aHVtYm5haWw6IFByb3BUeXBlcy5lbGVtZW50LFxyXG4gICAgdmlkZW86IFByb3BUeXBlcy5lbGVtZW50LFxyXG4gICAgbGVhZGluZ0ljb246IFByb3BUeXBlcy5ub2RlLFxyXG4gICAgbGVhZGluZ0ltYWdlOiBQcm9wVHlwZXMuZWxlbWVudCxcclxuICAgIGxlYWRpbmdBdmF0YXI6IFByb3BUeXBlcy5lbGVtZW50LFxyXG4gICAgbGVhZGluZ1RodW1ibmFpbDogUHJvcFR5cGVzLmVsZW1lbnQsXHJcbiAgICBsZWFkaW5nVmlkZW86IFByb3BUeXBlcy5lbGVtZW50LFxyXG4gICAgbGVhZGluZ0NoZWNrYm94OiBQcm9wVHlwZXMuZWxlbWVudCxcclxuICAgIGxlYWRpbmdSYWRpbzogUHJvcFR5cGVzLmVsZW1lbnQsXHJcbiAgICBsZWFkaW5nU3dpdGNoOiBQcm9wVHlwZXMuZWxlbWVudCxcclxuICAgIG1ldGE6IFByb3BUeXBlcy5ub2RlLFxyXG4gICAgdHJhaWxpbmdNZXRhOiBQcm9wVHlwZXMubm9kZSxcclxuICAgIHRyYWlsaW5nSWNvbjogUHJvcFR5cGVzLm5vZGUsXHJcbiAgICB0cmFpbGluZ0NoZWNrYm94OiBQcm9wVHlwZXMuZWxlbWVudCxcclxuICAgIHRyYWlsaW5nUmFkaW86IFByb3BUeXBlcy5lbGVtZW50LFxyXG4gICAgdHJhaWxpbmdTd2l0Y2g6IFByb3BUeXBlcy5lbGVtZW50LFxyXG4gICAgYWN0aXZhdGVkOiBQcm9wVHlwZXMuYm9vbCxcclxuICAgIHNlbGVjdGVkOiBQcm9wVHlwZXMuYm9vbCxcclxuICAgIGRpc2FibGVkOiBQcm9wVHlwZXMuYm9vbCxcclxuICAgIG5vbkludGVyYWN0aXZlOiBQcm9wVHlwZXMuYm9vbCxcclxuICAgIHdpdGhMZWFkaW5nSWNvbjogUHJvcFR5cGVzLmJvb2wsXHJcbiAgICB3aXRoTGVhZGluZ0ltYWdlOiBQcm9wVHlwZXMuYm9vbCxcclxuICAgIHdpdGhMZWFkaW5nQXZhdGFyOiBQcm9wVHlwZXMuYm9vbCxcclxuICAgIHdpdGhMZWFkaW5nVGh1bWJuYWlsOiBQcm9wVHlwZXMuYm9vbCxcclxuICAgIHdpdGhMZWFkaW5nVmlkZW86IFByb3BUeXBlcy5ib29sLFxyXG4gICAgd2l0aExlYWRpbmdDaGVja2JveDogUHJvcFR5cGVzLmJvb2wsXHJcbiAgICB3aXRoTGVhZGluZ1JhZGlvOiBQcm9wVHlwZXMuYm9vbCxcclxuICAgIHdpdGhMZWFkaW5nU3dpdGNoOiBQcm9wVHlwZXMuYm9vbCxcclxuICAgIHdpdGhUcmFpbGluZ01ldGE6IFByb3BUeXBlcy5ib29sLFxyXG4gICAgd2l0aFRyYWlsaW5nSWNvbjogUHJvcFR5cGVzLmJvb2wsXHJcbiAgICB3aXRoVHJhaWxpbmdDaGVja2JveDogUHJvcFR5cGVzLmJvb2wsXHJcbiAgICB3aXRoVHJhaWxpbmdSYWRpbzogUHJvcFR5cGVzLmJvb2wsXHJcbiAgICB3aXRoVHJhaWxpbmdTd2l0Y2g6IFByb3BUeXBlcy5ib29sXHJcbn07XHJcblxyXG5leHBvcnQgZGVmYXVsdCBMaXN0SXRlbTsiLCJpbXBvcnQgeyBmb3J3YXJkUmVmIH0gZnJvbSAncmVhY3QnO1xyXG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xyXG5pbXBvcnQgY2xhc3NuYW1lcyBmcm9tICdjbGFzc25hbWVzJztcclxuXHJcbmltcG9ydCB7IGNyZWF0ZSB9IGZyb20gJy4uL2NvbXBvbmVudCc7XHJcblxyXG5pbXBvcnQgeyBsaXN0Q3NzQ2xhc3NlcyBhcyBjc3NDbGFzc2VzIH0gZnJvbSAnLi9jb25zdGFudHMnO1xyXG5pbXBvcnQgTGlzdEl0ZW0gZnJvbSAnLi9MaXN0SXRlbSc7XHJcblxyXG5jb25zdCBMaXN0ID0gZm9yd2FyZFJlZigoe1xyXG4gICAgaXRlbXMsXHJcblxyXG4gICAgZWxlbWVudDogRWxlbWVudCA9ICd1bCcsXHJcbiAgICBjbGFzc05hbWUsXHJcbiAgICBjaGlsZHJlbiA9IGl0ZW1zPy5tYXAoaXRlbSA9PiBjcmVhdGUoTGlzdEl0ZW0sIGl0ZW0pKSxcclxuICAgIC4uLnByb3BzXHJcbn0sIHJlZikgPT4ge1xyXG4gICAgY29uc3QgY2xhc3NOYW1lcyA9IGNsYXNzbmFtZXMoY3NzQ2xhc3Nlcy5ST09ULCBjbGFzc05hbWUpO1xyXG5cclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgPEVsZW1lbnQgcmVmPXtyZWZ9IGNsYXNzTmFtZT17Y2xhc3NOYW1lc30gey4uLnByb3BzfT5cclxuICAgICAgICAgICAge2NoaWxkcmVufVxyXG4gICAgICAgIDwvRWxlbWVudD5cclxuICAgICk7XHJcbn0pO1xyXG5cclxuTGlzdC5kaXNwbGF5TmFtZSA9ICdNRENMaXN0JztcclxuXHJcbkxpc3RJdGVtLnByb3BUeXBlcyA9IHtcclxuICAgIGl0ZW1zOiBQcm9wVHlwZXMuYXJyYXlcclxufTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IExpc3Q7IiwiaW1wb3J0IHsgZm9yd2FyZFJlZiB9IGZyb20gJ3JlYWN0JztcclxuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcclxuaW1wb3J0IGNsYXNzbmFtZXMgZnJvbSAnY2xhc3NuYW1lcyc7XHJcblxyXG5pbXBvcnQgeyBsaXN0RGl2aWRlckNzc0NsYXNzZXMgYXMgY3NzQ2xhc3NlcyB9IGZyb20gJy4vY29uc3RhbnRzJztcclxuXHJcbmNvbnN0IExpc3REaXZpZGVyID0gZm9yd2FyZFJlZigoe1xyXG4gICAgd2l0aExlYWRpbmdUZXh0ID0gZmFsc2UsXHJcbiAgICB3aXRoTGVhZGluZ0ljb24gPSBmYWxzZSxcclxuICAgIHdpdGhMZWFkaW5nSW1hZ2UgPSBmYWxzZSxcclxuICAgIHdpdGhMZWFkaW5nVGh1bWJuYWlsID0gZmFsc2UsXHJcbiAgICB3aXRoTGVhZGluZ1ZpZGVvID0gZmFsc2UsXHJcbiAgICB3aXRoTGVhZGluZ0NoZWNrYm94ID0gZmFsc2UsXHJcbiAgICB3aXRoTGVhZGluZ1JhZGlvID0gZmFsc2UsXHJcbiAgICB3aXRoTGVhZGluZ1N3aXRjaCA9IGZhbHNlLFxyXG5cclxuICAgIGVsZW1lbnQ6IEVsZW1lbnQgPSAnbGknLFxyXG4gICAgY2xhc3NOYW1lLFxyXG4gICAgLi4ucHJvcHNcclxufSwgcmVmKSA9PiB7XHJcbiAgICBjb25zdCBjbGFzc05hbWVzID0gY2xhc3NuYW1lcyhjc3NDbGFzc2VzLlJPT1QsIHtcclxuICAgICAgICBbY3NzQ2xhc3Nlcy5MRUFESU5HX1RFWFRdOiB3aXRoTGVhZGluZ1RleHQsXHJcbiAgICAgICAgW2Nzc0NsYXNzZXMuTEVBRElOR19JQ09OXTogd2l0aExlYWRpbmdJY29uLFxyXG4gICAgICAgIFtjc3NDbGFzc2VzLkxFQURJTkdfSU1BR0VdOiB3aXRoTGVhZGluZ0ltYWdlLFxyXG4gICAgICAgIFtjc3NDbGFzc2VzLkxFQURJTkdfVEhVTUJOQUlMXTogd2l0aExlYWRpbmdUaHVtYm5haWwsXHJcbiAgICAgICAgW2Nzc0NsYXNzZXMuTEVBRElOR19WSURFT106IHdpdGhMZWFkaW5nVmlkZW8sXHJcbiAgICAgICAgW2Nzc0NsYXNzZXMuTEVBRElOR19DSEVDS0JPWF06IHdpdGhMZWFkaW5nQ2hlY2tib3gsXHJcbiAgICAgICAgW2Nzc0NsYXNzZXMuTEVBRElOR19SQURJT106IHdpdGhMZWFkaW5nUmFkaW8sXHJcbiAgICAgICAgW2Nzc0NsYXNzZXMuTEVBRElOR19TV0lUQ0hdOiB3aXRoTGVhZGluZ1N3aXRjaFxyXG4gICAgfSwgY2xhc3NOYW1lKTtcclxuXHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAgIDxFbGVtZW50XHJcbiAgICAgICAgICAgIHJlZj17cmVmfVxyXG4gICAgICAgICAgICBjbGFzc05hbWU9e2NsYXNzTmFtZXN9XHJcbiAgICAgICAgICAgIHJvbGU9e0VsZW1lbnQgPT09ICdsaScgPyAnc2VwYXJhdG9yJyA6IHVuZGVmaW5lZH1cclxuICAgICAgICAgICAgey4uLnByb3BzfVxyXG4gICAgICAgIC8+XHJcbiAgICApO1xyXG59KTtcclxuXHJcbkxpc3REaXZpZGVyLmRpc3BsYXlOYW1lID0gJ01EQ0xpc3REaXZpZGVyJztcclxuXHJcbkxpc3REaXZpZGVyLnByb3BUeXBlcyA9IHtcclxuICAgIHdpdGhMZWFkaW5nVGV4dDogUHJvcFR5cGVzLmJvb2wsXHJcbiAgICB3aXRoTGVhZGluZ0ljb246IFByb3BUeXBlcy5ib29sLFxyXG4gICAgd2l0aExlYWRpbmdJbWFnZTogUHJvcFR5cGVzLmJvb2wsXHJcbiAgICB3aXRoTGVhZGluZ1RodW1ibmFpbDogUHJvcFR5cGVzLmJvb2wsXHJcbiAgICB3aXRoTGVhZGluZ1ZpZGVvOiBQcm9wVHlwZXMuYm9vbCxcclxuICAgIHdpdGhMZWFkaW5nQXZhdGFyOiBQcm9wVHlwZXMuYm9vbCxcclxuICAgIHdpdGhMZWFkaW5nQ2hlY2tib3g6IFByb3BUeXBlcy5ib29sLFxyXG4gICAgd2l0aExlYWRpbmdTd2l0Y2g6IFByb3BUeXBlcy5ib29sLFxyXG4gICAgd2l0aExlYWRpbmdSYWRpbzogUHJvcFR5cGVzLmJvb2xcclxufTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IExpc3REaXZpZGVyOyIsImltcG9ydCB7IGZvcndhcmRSZWYgfSBmcm9tICdyZWFjdCc7XHJcbmltcG9ydCBjbGFzc25hbWVzIGZyb20gJ2NsYXNzbmFtZXMnO1xyXG5cclxuaW1wb3J0IHsgbGlzdEdyb3VwQ3NzQ2xhc3NlcyBhcyBjc3NDbGFzc2VzIH0gZnJvbSAnLi9jb25zdGFudHMnO1xyXG5cclxuY29uc3QgTGlzdEdyb3VwID0gZm9yd2FyZFJlZigoe1xyXG4gICAgZWxlbWVudDogRWxlbWVudCA9ICdkaXYnLFxyXG4gICAgY2xhc3NOYW1lLFxyXG4gICAgLi4ucHJvcHNcclxufSwgcmVmKSA9PiB7XHJcbiAgICBjb25zdCBjbGFzc05hbWVzID0gY2xhc3NuYW1lcyhjc3NDbGFzc2VzLlJPT1QsIGNsYXNzTmFtZSk7XHJcblxyXG4gICAgcmV0dXJuIChcclxuICAgICAgICA8RWxlbWVudCByZWY9e3JlZn0gY2xhc3NOYW1lPXtjbGFzc05hbWVzfSB7Li4ucHJvcHN9IC8+XHJcbiAgICApO1xyXG59KTtcclxuXHJcbkxpc3RHcm91cC5kaXNwbGF5TmFtZSA9ICdNRENMaXN0R3JvdXAnO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgTGlzdEdyb3VwOyIsImltcG9ydCB7IGZvcndhcmRSZWYgfSBmcm9tICdyZWFjdCc7XHJcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XHJcbmltcG9ydCBjbGFzc25hbWVzIGZyb20gJ2NsYXNzbmFtZXMnO1xyXG5cclxuaW1wb3J0IHsgbGlzdEdyb3VwQ3NzQ2xhc3NlcyBhcyBjc3NDbGFzc2VzIH0gZnJvbSAnLi9jb25zdGFudHMnO1xyXG5cclxuY29uc3QgTGlzdEdyb3VwU3ViaGVhZGVyID0gZm9yd2FyZFJlZigoe1xyXG4gICAgdGl0bGUsXHJcblxyXG4gICAgZWxlbWVudDogRWxlbWVudCA9ICdoMycsXHJcbiAgICBjbGFzc05hbWUsXHJcbiAgICBjaGlsZHJlbiA9IHRpdGxlLFxyXG4gICAgLi4ucHJvcHNcclxufSwgcmVmKSA9PiB7XHJcbiAgICBjb25zdCBjbGFzc05hbWVzID0gY2xhc3NuYW1lcyhjc3NDbGFzc2VzLlNVQkhFQURFUiwgY2xhc3NOYW1lKTtcclxuXHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAgIDxFbGVtZW50IHJlZj17cmVmfSBjbGFzc05hbWU9e2NsYXNzTmFtZXN9IHsuLi5wcm9wc30+e2NoaWxkcmVufTwvRWxlbWVudD5cclxuICAgICk7XHJcbn0pO1xyXG5cclxuTGlzdEdyb3VwU3ViaGVhZGVyLmRpc3BsYXlOYW1lID0gJ01EQ0xpc3RHcm91cFN1YmhlYWRlcic7XHJcblxyXG5MaXN0R3JvdXBTdWJoZWFkZXIucHJvcFR5cGVzID0ge1xyXG4gICAgdGl0bGU6IFByb3BUeXBlcy5zdHJpbmdcclxufTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IExpc3RHcm91cFN1YmhlYWRlcjsiLCJpbXBvcnQgTGlzdCBmcm9tICcuL0xpc3QnO1xyXG5pbXBvcnQgTGlzdERpdmlkZXIgZnJvbSAnLi9MaXN0RGl2aWRlcic7XHJcbmltcG9ydCBMaXN0R3JvdXAgZnJvbSAnLi9MaXN0R3JvdXAnO1xyXG5pbXBvcnQgTGlzdEdyb3VwU3ViaGVhZGVyIGZyb20gJy4vTGlzdEdyb3VwU3ViaGVhZGVyJztcclxuaW1wb3J0IExpc3RJdGVtIGZyb20gJy4vTGlzdEl0ZW0nO1xyXG5pbXBvcnQgTGlzdEl0ZW1Db250ZW50IGZyb20gJy4vTGlzdEl0ZW1Db250ZW50JztcclxuaW1wb3J0IExpc3RJdGVtRW5kIGZyb20gJy4vTGlzdEl0ZW1FbmQnO1xyXG5pbXBvcnQgTGlzdEl0ZW1TdGFydCBmcm9tICcuL0xpc3RJdGVtU3RhcnQnO1xyXG5cclxuTGlzdC5JdGVtID0gTGlzdEl0ZW07XHJcbkxpc3QuRGl2aWRlciA9IExpc3REaXZpZGVyO1xyXG5MaXN0Lkdyb3VwID0gTGlzdEdyb3VwO1xyXG5MaXN0R3JvdXAuU3ViaGVhZGVyID0gTGlzdEdyb3VwU3ViaGVhZGVyO1xyXG5MaXN0SXRlbS5Db250ZW50ID0gTGlzdEl0ZW1Db250ZW50O1xyXG5MaXN0SXRlbS5FbmQgPSBMaXN0SXRlbUVuZDtcclxuTGlzdEl0ZW0uU3RhcnQgPSBMaXN0SXRlbVN0YXJ0O1xyXG5cclxuZXhwb3J0IHtcclxuICAgIExpc3QgYXMgZGVmYXVsdCxcclxuICAgIExpc3REaXZpZGVyLFxyXG4gICAgTGlzdEdyb3VwLFxyXG4gICAgTGlzdEdyb3VwU3ViaGVhZGVyLFxyXG4gICAgTGlzdEl0ZW0sXHJcbiAgICBMaXN0SXRlbVN0YXJ0LFxyXG4gICAgTGlzdEl0ZW1FbmQsXHJcbiAgICBMaXN0SXRlbUNvbnRlbnRcclxufTsiLCJpbXBvcnQgeyBmb3J3YXJkUmVmIH0gZnJvbSAncmVhY3QnO1xyXG5pbXBvcnQgY2xhc3NuYW1lcyBmcm9tICdjbGFzc25hbWVzJztcclxuXHJcbmltcG9ydCB7IExpc3RJdGVtIH0gZnJvbSAnLi4vbGlzdCc7XHJcbmltcG9ydCB7IGNzc0NsYXNzZXMgfSBmcm9tICcuL2NvbnN0YW50cyc7XHJcblxyXG5jb25zdCBNZW51SXRlbSA9IGZvcndhcmRSZWYoKHtcclxuICAgIHNlbGVjdGVkID0gZmFsc2UsXHJcbiAgICBkaXNhYmxlZCA9IGZhbHNlLFxyXG5cclxuICAgIGNsYXNzTmFtZSxcclxuICAgIC4uLnByb3BzXHJcbn0sIHJlZikgPT4ge1xyXG4gICAgY29uc3QgY2xhc3NOYW1lcyA9IGNsYXNzbmFtZXMoY3NzQ2xhc3Nlcy5JVEVNLCB7XHJcbiAgICAgICAgW2Nzc0NsYXNzZXMuSVRFTV9TRUxFQ1RFRF06IHNlbGVjdGVkXHJcbiAgICB9LCBjbGFzc05hbWUpO1xyXG5cclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgPExpc3RJdGVtXHJcbiAgICAgICAgICAgIHJlZj17cmVmfVxyXG4gICAgICAgICAgICByb2xlPVwibWVudWl0ZW1cIlxyXG4gICAgICAgICAgICBjbGFzc05hbWU9e2NsYXNzTmFtZXN9XHJcbiAgICAgICAgICAgIHNlbGVjdGVkPXtzZWxlY3RlZH1cclxuICAgICAgICAgICAgZGlzYWJsZWQ9e2Rpc2FibGVkfVxyXG4gICAgICAgICAgICBkYXRhLWRpc2FibGVkPXtkaXNhYmxlZCB8fCB1bmRlZmluZWR9XHJcbiAgICAgICAgICAgIHRhYkluZGV4PXtkaXNhYmxlZCA/ICctMScgOiB1bmRlZmluZWR9XHJcbiAgICAgICAgICAgIHsuLi5wcm9wc31cclxuICAgICAgICAvPlxyXG4gICAgKTtcclxufSk7XHJcblxyXG5NZW51SXRlbS5kaXNwbGF5TmFtZSA9ICdNRENNZW51SXRlbSc7XHJcblxyXG5NZW51SXRlbS5wcm9wVHlwZXMgPSB7XHJcbiAgICAuLi5MaXN0SXRlbS5wcm9wVHlwZXNcclxufTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IE1lbnVJdGVtOyIsImV4cG9ydCBjb25zdCBjc3NDbGFzc2VzID0ge1xyXG4gICAgUk9PVDogJ21kYy1tb2RhbCcsXHJcbiAgICBGSVhFRDogJ21kYy1tb2RhbC0tZml4ZWQnXHJcbn07IiwiaW1wb3J0IHsgdXNlUmVmLCB1c2VFZmZlY3QgfSBmcm9tICdyZWFjdCc7XHJcbmltcG9ydCB7IGNyZWF0ZVBvcnRhbCB9IGZyb20gJ3JlYWN0LWRvbSc7XHJcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XHJcblxyXG5pbXBvcnQgeyBjc3NDbGFzc2VzIH0gZnJvbSAnLi9jb25zdGFudHMnO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gTW9kYWwoe1xyXG4gICAgZml4ZWQgPSBmYWxzZSxcclxuICAgIGVsZW1lbnQgPSAnZGl2JyxcclxuICAgIGNoaWxkcmVuXHJcbn0pIHtcclxuICAgIGNvbnN0IHJvb3RSZWYgPSB1c2VSZWYoZG9jdW1lbnQuY3JlYXRlRWxlbWVudChlbGVtZW50KSk7XHJcblxyXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgICAgICBjb25zdCByb290ID0gcm9vdFJlZi5jdXJyZW50O1xyXG4gICAgICAgIGNvbnN0IGFjdGl2ZUVsZW1lbnQgPSBkb2N1bWVudC5hY3RpdmVFbGVtZW50O1xyXG5cclxuICAgICAgICByb290LmNsYXNzTmFtZSA9IGNzc0NsYXNzZXMuUk9PVDtcclxuXHJcbiAgICAgICAgaWYgKGZpeGVkKSB7XHJcbiAgICAgICAgICAgIHJvb3QuY2xhc3NMaXN0LmFkZChjc3NDbGFzc2VzLkZJWEVEKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQocm9vdCk7XHJcbiAgICAgICAgcm9vdC5maXJzdENoaWxkLmZvY3VzKCk7XHJcblxyXG4gICAgICAgIHJldHVybiAoKSA9PiB7XHJcbiAgICAgICAgICAgIGFjdGl2ZUVsZW1lbnQuZm9jdXMoKTtcclxuICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChyb290KTtcclxuICAgICAgICB9O1xyXG4gICAgfSwgW2ZpeGVkXSk7XHJcblxyXG4gICAgcmV0dXJuIGNyZWF0ZVBvcnRhbChjaGlsZHJlbiwgcm9vdFJlZi5jdXJyZW50KTtcclxufVxyXG5cclxuTW9kYWwuZGlzcGxheU5hbWUgPSAnTURDTW9kYWwnO1xyXG5cclxuTW9kYWwucHJvcFR5cGVzID0ge1xyXG4gICAgZml4ZWQ6IFByb3BUeXBlcy5ib29sLFxyXG4gICAgZWxlbWVudDogUHJvcFR5cGVzLnN0cmluZyxcclxuICAgIGNoaWxkcmVuOiBQcm9wVHlwZXMubm9kZS5pc1JlcXVpcmVkXHJcbn07IiwiZXhwb3J0IHsgZGVmYXVsdCB9IGZyb20gJy4vTW9kYWwnOyIsImltcG9ydCB7IENTU1RyYW5zaXRpb24gfSBmcm9tICdyZWFjdC10cmFuc2l0aW9uLWdyb3VwJztcclxuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcclxuXHJcbmltcG9ydCBNb2RhbCBmcm9tICcuLi9tb2RhbCc7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBMYXllcih7XHJcbiAgICBtb2RhbCA9IGZhbHNlLFxyXG4gICAgZml4ZWQgPSBmYWxzZSxcclxuXHJcbiAgICBjaGlsZHJlbixcclxuICAgIC4uLnByb3BzXHJcbn0pIHtcclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgPENTU1RyYW5zaXRpb24gey4uLnByb3BzfT5cclxuICAgICAgICAgICAge21vZGFsID9cclxuICAgICAgICAgICAgICAgIDxNb2RhbCBmaXhlZD17Zml4ZWR9PlxyXG4gICAgICAgICAgICAgICAgICAgIHtjaGlsZHJlbn1cclxuICAgICAgICAgICAgICAgIDwvTW9kYWw+XHJcbiAgICAgICAgICAgICAgICA6XHJcbiAgICAgICAgICAgICAgICBjaGlsZHJlblxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgPC9DU1NUcmFuc2l0aW9uPlxyXG4gICAgKTtcclxufVxyXG5cclxuTGF5ZXIuZGlzcGxheU5hbWUgPSAnTURDTGF5ZXInO1xyXG5cclxuTGF5ZXIucHJvcFR5cGVzID0ge1xyXG4gICAgbW9kYWw6IFByb3BUeXBlcy5ib29sLFxyXG4gICAgZml4ZWQ6IFByb3BUeXBlcy5ib29sXHJcbn07IiwiZXhwb3J0IHsgZGVmYXVsdCB9IGZyb20gJy4vTGF5ZXInOyIsImNvbnN0IGRlZmF1bHRWYWx1ZXMgPSB7XHJcbiAgICB0b3A6IGZhbHNlLFxyXG4gICAgYm90dG9tOiBmYWxzZSxcclxuICAgIGNlbnRlcjogZmFsc2UsXHJcbiAgICBsZWZ0OiBmYWxzZSxcclxuICAgIHJpZ2h0OiBmYWxzZVxyXG59O1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGdldEFuY2hvck9yaWdpbihhbmNob3JPcmlnaW4gPSAnJykge1xyXG4gICAgaWYgKHR5cGVvZiBhbmNob3JPcmlnaW4gPT09ICdvYmplY3QnKSB7XHJcbiAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIGRlZmF1bHRWYWx1ZXMsIGFuY2hvck9yaWdpbik7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3Qga2V5cyA9IGFuY2hvck9yaWdpbi5zcGxpdCgnICcpO1xyXG5cclxuICAgIGNvbnN0IHZhbHVlcyA9IGtleXMucmVkdWNlKChyZXN1bHQsIGtleSkgPT4ge1xyXG4gICAgICAgIHJlc3VsdFtrZXldID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH0sIHt9KTtcclxuXHJcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgZGVmYXVsdFZhbHVlcywgdmFsdWVzKTtcclxufSIsImltcG9ydCB7IGZvcndhcmRSZWYsIHVzZVJlZiwgdXNlSW1wZXJhdGl2ZUhhbmRsZSwgdXNlQ2FsbGJhY2ssIHVzZUVmZmVjdCB9IGZyb20gJ3JlYWN0JztcclxuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcclxuaW1wb3J0IGNsYXNzbmFtZXMgZnJvbSAnY2xhc3NuYW1lcyc7XHJcblxyXG5pbXBvcnQgeyB1c2VVcGRhdGVkIH0gZnJvbSAnLi4vaG9va3MnO1xyXG5pbXBvcnQgeyBjbG9uZSB9IGZyb20gJy4uL2NvbXBvbmVudCc7XHJcbmltcG9ydCBMYXllciBmcm9tICcuLi9sYXllcic7XHJcblxyXG5pbXBvcnQgeyBudW1iZXJzLCBjc3NDbGFzc2VzLCBPcmlnaW4gfSBmcm9tICcuL2NvbnN0YW50cyc7XHJcbmltcG9ydCB7IGdldEFuY2hvck9yaWdpbiB9IGZyb20gJy4vdXRpbHMnO1xyXG5cclxuY29uc3QgTWVudVN1cmZhY2UgPSBmb3J3YXJkUmVmKCh7XHJcbiAgICBhbmNob3IsXHJcbiAgICBhbmNob3JSZWY6IF9hbmNob3JSZWYsXHJcbiAgICBhbmNob3JPcmlnaW46IF9hbmNob3JPcmlnaW4gPSBPcmlnaW4uVE9QX0xFRlQsXHJcbiAgICB0cmFuc2Zvcm1PcmlnaW46IF90cmFuc2Zvcm1PcmlnaW4gPSBfYW5jaG9yT3JpZ2luLFxyXG4gICAgb3BlbiA9IGZhbHNlLFxyXG4gICAgbW9kYWwgPSBmYWxzZSxcclxuICAgIHF1aWNrID0gZmFsc2UsXHJcbiAgICBmaXhlZCA9IGZhbHNlLFxyXG4gICAgcGVyc2lzdGVudCA9IGZhbHNlLFxyXG4gICAgZnVsbFdpZHRoID0gZmFsc2UsXHJcbiAgICBvbkNsb3NlID0gRnVuY3Rpb24ucHJvdG90eXBlLFxyXG4gICAgb25LZXlEb3duID0gRnVuY3Rpb24ucHJvdG90eXBlLFxyXG5cclxuICAgIGNsYXNzTmFtZSxcclxuICAgIC4uLnByb3BzXHJcbn0sIHJlZikgPT4ge1xyXG4gICAgY29uc3Qgcm9vdFJlZiA9IHVzZVJlZigpO1xyXG4gICAgY29uc3QgYW5jaG9yUmVmID0gdXNlUmVmKF9hbmNob3JSZWY/LmN1cnJlbnQpO1xyXG5cclxuICAgIHVzZUltcGVyYXRpdmVIYW5kbGUocmVmLCAoKSA9PiByb290UmVmLmN1cnJlbnQpO1xyXG5cclxuICAgIHVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICAgICAgaWYgKCFfYW5jaG9yUmVmKSByZXR1cm47XHJcblxyXG4gICAgICAgIGFuY2hvclJlZi5jdXJyZW50ID0gX2FuY2hvclJlZi5jdXJyZW50O1xyXG4gICAgfSwgW19hbmNob3JSZWZdKTtcclxuXHJcbiAgICB1c2VVcGRhdGVkKCgpID0+IHtcclxuICAgICAgICBpZiAoIW9wZW4gfHwgcGVyc2lzdGVudCkgcmV0dXJuO1xyXG5cclxuICAgICAgICBmdW5jdGlvbiBoYW5kbGVCb2R5Q2xpY2soZXZlbnQpIHtcclxuICAgICAgICAgICAgb25DbG9zZShldmVudCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBkb2N1bWVudC5ib2R5LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgaGFuZGxlQm9keUNsaWNrLCB0cnVlKTtcclxuXHJcbiAgICAgICAgcmV0dXJuICgpID0+IHtcclxuICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIGhhbmRsZUJvZHlDbGljaywgdHJ1ZSk7XHJcbiAgICAgICAgfTtcclxuICAgIH0sIFtvcGVuLCBwZXJzaXN0ZW50LCBvbkNsb3NlXSk7XHJcblxyXG4gICAgdXNlVXBkYXRlZCgoKSA9PiB7XHJcbiAgICAgICAgaWYgKCFvcGVuIHx8ICFyb290UmVmLmN1cnJlbnQgfHwgIWFuY2hvclJlZi5jdXJyZW50KSByZXR1cm47XHJcblxyXG4gICAgICAgIGNvbnN0IGFuY2hvciA9IGFuY2hvclJlZi5jdXJyZW50O1xyXG4gICAgICAgIGNvbnN0IHsgY2xpZW50V2lkdGg6IHdpZHRoLCBjbGllbnRIZWlnaHQ6IGhlaWdodCB9ID0gcm9vdFJlZi5jdXJyZW50O1xyXG4gICAgICAgIGNvbnN0IGFuY2hvckNsaWVudFJlY3QgPSBhbmNob3IuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XHJcbiAgICAgICAgY29uc3QgYW5jaG9yRGltZW5zaW9ucyA9IG1vZGFsID8gYW5jaG9yQ2xpZW50UmVjdCA6IHtcclxuICAgICAgICAgICAgdG9wOiBhbmNob3Iub2Zmc2V0VG9wLFxyXG4gICAgICAgICAgICBsZWZ0OiBhbmNob3Iub2Zmc2V0TGVmdCxcclxuICAgICAgICAgICAgYm90dG9tOiBhbmNob3Iub2Zmc2V0VG9wICsgYW5jaG9yLm9mZnNldEhlaWdodCxcclxuICAgICAgICAgICAgcmlnaHQ6IGFuY2hvci5vZmZzZXRMZWZ0ICsgYW5jaG9yLm9mZnNldFdpZHRoLFxyXG4gICAgICAgICAgICB3aWR0aDogYW5jaG9yLm9mZnNldFdpZHRoLFxyXG4gICAgICAgICAgICBoZWlnaHQ6IGFuY2hvci5vZmZzZXRIZWlnaHRcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBjb25zdCBzdHlsZSA9IHtcclxuICAgICAgICAgICAgdG9wOiBhbmNob3JEaW1lbnNpb25zLnRvcCxcclxuICAgICAgICAgICAgbGVmdDogYW5jaG9yRGltZW5zaW9ucy5sZWZ0LFxyXG4gICAgICAgICAgICB3aWR0aDogZnVsbFdpZHRoID8gJzEwMCUnIDogdW5kZWZpbmVkLFxyXG4gICAgICAgICAgICBtYXhXaWR0aDogZnVsbFdpZHRoID8gYCR7YW5jaG9yRGltZW5zaW9ucy53aWR0aH1weGAgOiB1bmRlZmluZWQsXHJcbiAgICAgICAgICAgIHBvc2l0aW9uOiBmaXhlZCA/ICdmaXhlZCcgOiAnYWJzb2x1dGUnLFxyXG4gICAgICAgICAgICB0cmFuc2Zvcm1PcmlnaW46IF90cmFuc2Zvcm1PcmlnaW5cclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBjb25zdCBzY3JvbGxZID0gKG1vZGFsICYmICFmaXhlZCkgPyB3aW5kb3cuc2Nyb2xsWSA6IDA7XHJcbiAgICAgICAgY29uc3Qgc2Nyb2xsWCA9IChtb2RhbCAmJiAhZml4ZWQpID8gd2luZG93LnNjcm9sbFggOiAwO1xyXG5cclxuICAgICAgICBjb25zdCBhbmNob3JPcmlnaW4gPSBnZXRBbmNob3JPcmlnaW4oX2FuY2hvck9yaWdpbik7XHJcbiAgICAgICAgY29uc3QgdHJhbnNmb3JtT3JpZ2luID0gZ2V0QW5jaG9yT3JpZ2luKF90cmFuc2Zvcm1PcmlnaW4pO1xyXG5cclxuICAgICAgICBpZiAoYW5jaG9yT3JpZ2luLnRvcCkge1xyXG4gICAgICAgICAgICBzdHlsZS50b3AgPSBhbmNob3JEaW1lbnNpb25zLnRvcDtcclxuICAgICAgICB9IGVsc2UgaWYgKGFuY2hvck9yaWdpbi5ib3R0b20pIHtcclxuICAgICAgICAgICAgc3R5bGUudG9wID0gYW5jaG9yRGltZW5zaW9ucy5ib3R0b207XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoYW5jaG9yT3JpZ2luLmxlZnQpIHtcclxuICAgICAgICAgICAgc3R5bGUubGVmdCA9IGFuY2hvckRpbWVuc2lvbnMubGVmdDtcclxuICAgICAgICB9IGVsc2UgaWYgKGFuY2hvck9yaWdpbi5yaWdodCkge1xyXG4gICAgICAgICAgICBzdHlsZS5sZWZ0ID0gYW5jaG9yRGltZW5zaW9ucy5yaWdodDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICh0cmFuc2Zvcm1PcmlnaW4udG9wKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHRvcCA9IHNjcm9sbFkgKyBzdHlsZS50b3A7XHJcbiAgICAgICAgICAgIGNvbnN0IGJvdHRvbU92ZXJmbG93ID0gc2Nyb2xsWSArIChhbmNob3JPcmlnaW4uYm90dG9tID8gYW5jaG9yQ2xpZW50UmVjdC5ib3R0b20gOiBhbmNob3JDbGllbnRSZWN0LnRvcCkgKyBoZWlnaHQgLSB3aW5kb3cuaW5uZXJIZWlnaHQ7XHJcblxyXG4gICAgICAgICAgICBzdHlsZS50b3AgPSBib3R0b21PdmVyZmxvdyA+IDAgPyAodG9wIC0gYm90dG9tT3ZlcmZsb3cpIDogdG9wO1xyXG4gICAgICAgIH0gZWxzZSBpZiAodHJhbnNmb3JtT3JpZ2luLmJvdHRvbSkge1xyXG4gICAgICAgICAgICBjb25zdCB0b3AgPSBzY3JvbGxZICsgc3R5bGUudG9wIC0gaGVpZ2h0O1xyXG4gICAgICAgICAgICBjb25zdCB0b3BPdmVyZmxvdyA9IHNjcm9sbFkgKyAoYW5jaG9yT3JpZ2luLmJvdHRvbSA/IGFuY2hvckNsaWVudFJlY3QuYm90dG9tIDogYW5jaG9yQ2xpZW50UmVjdC50b3ApIC0gaGVpZ2h0O1xyXG5cclxuICAgICAgICAgICAgc3R5bGUudG9wID0gdG9wT3ZlcmZsb3cgPiAwID8gdG9wIDogMDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICh0cmFuc2Zvcm1PcmlnaW4ubGVmdCkge1xyXG4gICAgICAgICAgICBjb25zdCBsZWZ0ID0gc3R5bGUubGVmdDtcclxuICAgICAgICAgICAgY29uc3QgcmlnaHRPdmVyZmxvdyA9IHNjcm9sbFggKyB3aW5kb3cuaW5uZXJXaWR0aCAtIChhbmNob3JPcmlnaW4ubGVmdCA/IGFuY2hvckNsaWVudFJlY3QubGVmdCA6IGFuY2hvckNsaWVudFJlY3QucmlnaHQpICsgd2lkdGg7XHJcblxyXG4gICAgICAgICAgICBzdHlsZS5sZWZ0ID0gcmlnaHRPdmVyZmxvdyA+IDAgPyBsZWZ0IDogbGVmdCAtIE1hdGguYWJzKHJpZ2h0T3ZlcmZsb3cpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAodHJhbnNmb3JtT3JpZ2luLnJpZ2h0KSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGxlZnQgPSBzdHlsZS5sZWZ0IC0gd2lkdGg7XHJcbiAgICAgICAgICAgIGNvbnN0IGxlZnRPdmVyZmxvdyA9IHNjcm9sbFggKyAoYW5jaG9yT3JpZ2luLnJpZ2h0ID8gYW5jaG9yQ2xpZW50UmVjdC5yaWdodCA6IGFuY2hvckNsaWVudFJlY3QubGVmdCkgLSB3aWR0aDtcclxuXHJcbiAgICAgICAgICAgIHN0eWxlLmxlZnQgPSBsZWZ0T3ZlcmZsb3cgPiAwID8gbGVmdCA6IDA7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByb290UmVmLmN1cnJlbnQuc3R5bGUudG9wID0gYCR7c3R5bGUudG9wfXB4YDtcclxuICAgICAgICByb290UmVmLmN1cnJlbnQuc3R5bGUubGVmdCA9IGAke3N0eWxlLmxlZnR9cHhgO1xyXG4gICAgICAgIHJvb3RSZWYuY3VycmVudC5zdHlsZS5wb3NpdGlvbiA9IHN0eWxlLnBvc2l0aW9uO1xyXG4gICAgICAgIHJvb3RSZWYuY3VycmVudC5zdHlsZS53aWR0aCA9IHN0eWxlLndpZHRoO1xyXG4gICAgICAgIHJvb3RSZWYuY3VycmVudC5zdHlsZS5tYXhXaWR0aCA9IHN0eWxlLm1heFdpZHRoO1xyXG4gICAgICAgIHJvb3RSZWYuY3VycmVudC5zdHlsZS50cmFuc2Zvcm1PcmlnaW4gPSBzdHlsZS50cmFuc2Zvcm1PcmlnaW47XHJcbiAgICB9LCBbb3BlbiwgbW9kYWwsIGZpeGVkLCBfYW5jaG9yT3JpZ2luLCBfdHJhbnNmb3JtT3JpZ2luXSk7XHJcblxyXG4gICAgY29uc3QgaGFuZGxlS2V5RG93biA9IHVzZUNhbGxiYWNrKGV2ZW50ID0+IHtcclxuICAgICAgICBpZiAoZXZlbnQua2V5ID09PSAnRXNjYXBlJyAmJiAhcGVyc2lzdGVudCkge1xyXG4gICAgICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcclxuICAgICAgICAgICAgb25DbG9zZShldmVudCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBvbktleURvd24oZXZlbnQpO1xyXG4gICAgfSwgW3BlcnNpc3RlbnQsIG9uS2V5RG93biwgb25DbG9zZV0pO1xyXG5cclxuICAgIGNvbnN0IGlzQmVsb3dBbmNob3IgPSAoXHJcbiAgICAgICAgX2FuY2hvck9yaWdpbi5pbmNsdWRlcygnYm90dG9tJykgJiZcclxuICAgICAgICBfdHJhbnNmb3JtT3JpZ2luLmluY2x1ZGVzKCd0b3AnKVxyXG4gICAgKTtcclxuXHJcbiAgICBjb25zdCBjbGFzc05hbWVzID0gY2xhc3NuYW1lcyhjc3NDbGFzc2VzLlNVUkZBQ0UsIHtcclxuICAgICAgICBbY3NzQ2xhc3Nlcy5TVVJGQUNFX0ZJWEVEXTogZml4ZWQsXHJcbiAgICAgICAgW2Nzc0NsYXNzZXMuU1VSRkFDRV9CRUxPV19BTkNIT1JdOiBpc0JlbG93QW5jaG9yXHJcbiAgICB9LCBjbGFzc05hbWUpO1xyXG5cclxuICAgIHJldHVybiAoPD5cclxuICAgICAgICB7YW5jaG9yICYmXHJcbiAgICAgICAgICAgIGNsb25lKGFuY2hvciwgeyByZWY6IGFuY2hvclJlZiB9KVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgPExheWVyXHJcbiAgICAgICAgICAgIGluPXtvcGVufVxyXG4gICAgICAgICAgICBtb2RhbD17bW9kYWx9XHJcbiAgICAgICAgICAgIHRpbWVvdXQ9e3F1aWNrID8gMCA6IHtcclxuICAgICAgICAgICAgICAgIGVudGVyOiBudW1iZXJzLlRSQU5TSVRJT05fT1BFTl9EVVJBVElPTixcclxuICAgICAgICAgICAgICAgIGV4aXQ6IG51bWJlcnMuVFJBTlNJVElPTl9DTE9TRV9EVVJBVElPTlxyXG4gICAgICAgICAgICB9fVxyXG4gICAgICAgICAgICBjbGFzc05hbWVzPXtxdWljayA/IHtcclxuICAgICAgICAgICAgICAgIGVudGVyRG9uZTogY3NzQ2xhc3Nlcy5TVVJGQUNFX09QRU4sXHJcbiAgICAgICAgICAgIH0gOiB7XHJcbiAgICAgICAgICAgICAgICBlbnRlcjogY3NzQ2xhc3Nlcy5TVVJGQUNFX0FOSU1BVElOR19PUEVOLFxyXG4gICAgICAgICAgICAgICAgZW50ZXJBY3RpdmU6IGNzc0NsYXNzZXMuU1VSRkFDRV9BTklNQVRJTkdfT1BFTixcclxuICAgICAgICAgICAgICAgIGVudGVyRG9uZTogY3NzQ2xhc3Nlcy5TVVJGQUNFX09QRU4sXHJcbiAgICAgICAgICAgICAgICBleGl0OiBjc3NDbGFzc2VzLlNVUkZBQ0VfT1BFTixcclxuICAgICAgICAgICAgICAgIGV4aXRBY3RpdmU6IGNzc0NsYXNzZXMuU1VSRkFDRV9BTklNQVRJTkdfQ0xPU0VEXHJcbiAgICAgICAgICAgIH19XHJcbiAgICAgICAgICAgIG1vdW50T25FbnRlclxyXG4gICAgICAgICAgICB1bm1vdW50T25FeGl0XHJcbiAgICAgICAgPlxyXG4gICAgICAgICAgICA8ZGl2XHJcbiAgICAgICAgICAgICAgICByZWY9e3Jvb3RSZWZ9XHJcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU9e2NsYXNzTmFtZXN9XHJcbiAgICAgICAgICAgICAgICBvbktleURvd249e2hhbmRsZUtleURvd259XHJcbiAgICAgICAgICAgICAgICB7Li4ucHJvcHN9XHJcbiAgICAgICAgICAgIC8+XHJcbiAgICAgICAgPC9MYXllcj5cclxuICAgIDwvPik7XHJcbn0pO1xyXG5cclxuTWVudVN1cmZhY2UuZGlzcGxheU5hbWUgPSAnTURDTWVudVN1cmZhY2UnO1xyXG5cclxuTWVudVN1cmZhY2UucHJvcFR5cGVzID0ge1xyXG4gICAgYW5jaG9yOiBQcm9wVHlwZXMuZWxlbWVudCxcclxuICAgIGFuY2hvclJlZjogUHJvcFR5cGVzLm9iamVjdCxcclxuICAgIGFuY2hvck9yaWdpbjogUHJvcFR5cGVzLm9uZU9mKE9iamVjdC52YWx1ZXMoT3JpZ2luKSksXHJcbiAgICBvcGVuOiBQcm9wVHlwZXMuYm9vbCxcclxuICAgIG1vZGFsOiBQcm9wVHlwZXMuYm9vbCxcclxuICAgIHF1aWNrOiBQcm9wVHlwZXMuYm9vbCxcclxuICAgIGZpeGVkOiBQcm9wVHlwZXMuYm9vbCxcclxuICAgIHBlcnNpc3RlbnQ6IFByb3BUeXBlcy5ib29sLFxyXG4gICAgZnVsbFdpZHRoOiBQcm9wVHlwZXMuYm9vbCxcclxuICAgIG9uQ2xvc2U6IFByb3BUeXBlcy5mdW5jXHJcbn07XHJcblxyXG5leHBvcnQgZGVmYXVsdCBNZW51U3VyZmFjZTsiLCJpbXBvcnQgeyBmb3J3YXJkUmVmLCB1c2VTdGF0ZSwgdXNlRWZmZWN0LCB1c2VDYWxsYmFjaywgdXNlUmVmLCBDaGlsZHJlbiB9IGZyb20gJ3JlYWN0JztcclxuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcclxuaW1wb3J0IGNsYXNzbmFtZXMgZnJvbSAnY2xhc3NuYW1lcyc7XHJcblxyXG5pbXBvcnQgeyB1c2VVcGRhdGVkIH0gZnJvbSAnLi4vaG9va3MnO1xyXG5pbXBvcnQgeyBDbG9uZSwgY3JlYXRlIH0gZnJvbSAnLi4vY29tcG9uZW50JztcclxuaW1wb3J0IExpc3QgZnJvbSAnLi4vbGlzdCc7XHJcblxyXG5pbXBvcnQgeyBjc3NDbGFzc2VzIH0gZnJvbSAnLi9jb25zdGFudHMnO1xyXG5pbXBvcnQgTWVudUl0ZW0gZnJvbSAnLi9NZW51SXRlbSc7XHJcbmltcG9ydCBNZW51U3VyZmFjZSBmcm9tICcuL01lbnVTdXJmYWNlJztcclxuXHJcbmNvbnN0IE1lbnUgPSBmb3J3YXJkUmVmKCh7XHJcbiAgICBvcGVuLFxyXG4gICAgaXRlbXMsXHJcbiAgICBsaXN0UHJvcHMgPSB7fSxcclxuXHJcbiAgICBjaGlsZHJlbiA9IGl0ZW1zPy5tYXAoaXRlbSA9PiBjcmVhdGUoTWVudUl0ZW0sIGl0ZW0pKSxcclxuICAgIGNsYXNzTmFtZSxcclxuICAgIC4uLnByb3BzXHJcbn0sIHJlZikgPT4ge1xyXG4gICAgY29uc3QgbGlzdFJlZiA9IHVzZVJlZigpO1xyXG5cclxuICAgIGNvbnN0IFtmb2N1c2VkQ2hpbGRJbmRleCwgc2V0Rm9jdXNlZENoaWxkSW5kZXhdID0gdXNlU3RhdGUoMCk7XHJcblxyXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgICAgICBpZiAob3Blbikge1xyXG4gICAgICAgICAgICBzZXRGb2N1c2VkQ2hpbGRJbmRleChcclxuICAgICAgICAgICAgICAgIENoaWxkcmVuLnRvQXJyYXkoY2hpbGRyZW4pLmZpbmRJbmRleChpID0+IGkucHJvcHMuc2VsZWN0ZWQpXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgfVxyXG4gICAgfSwgW29wZW4sIGNoaWxkcmVuXSk7XHJcblxyXG4gICAgdXNlVXBkYXRlZCgoKSA9PiB7XHJcbiAgICAgICAgaWYgKG9wZW4pIHtcclxuICAgICAgICAgICAgbGlzdFJlZi5jdXJyZW50LmNoaWxkcmVuW2ZvY3VzZWRDaGlsZEluZGV4XT8uZm9jdXMoKTtcclxuICAgICAgICB9XHJcbiAgICB9LCBbZm9jdXNlZENoaWxkSW5kZXgsIG9wZW5dKTtcclxuXHJcbiAgICBjb25zdCBoYW5kbGVLZXlEb3duID0gdXNlQ2FsbGJhY2soZXZlbnQgPT4ge1xyXG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XHJcblxyXG4gICAgICAgIGlmIChldmVudC5rZXkgPT09ICdBcnJvd0Rvd24nKSB7XHJcbiAgICAgICAgICAgIHNldEZvY3VzZWRDaGlsZEluZGV4KGluZGV4ID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG5leHRJbmRleCA9IGluZGV4ICsgMTtcclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV4dEluZGV4IDwgbGlzdFJlZi5jdXJyZW50LmNoaWxkcmVuLmxlbmd0aCA/IG5leHRJbmRleCA6IGluZGV4O1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9IGVsc2UgaWYgKGV2ZW50LmtleSA9PT0gJ0Fycm93VXAnKSB7XHJcbiAgICAgICAgICAgIHNldEZvY3VzZWRDaGlsZEluZGV4KGluZGV4ID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG5leHRJbmRleCA9IGluZGV4IC0gMTtcclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV4dEluZGV4ID49IDAgPyBuZXh0SW5kZXggOiBpbmRleDtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSwgW10pO1xyXG5cclxuICAgIGNvbnN0IGNsYXNzTmFtZXMgPSBjbGFzc25hbWVzKGNzc0NsYXNzZXMuUk9PVCwgY2xhc3NOYW1lKTtcclxuXHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAgIDxNZW51U3VyZmFjZVxyXG4gICAgICAgICAgICByZWY9e3JlZn1cclxuICAgICAgICAgICAgb3Blbj17b3Blbn1cclxuICAgICAgICAgICAgY2xhc3NOYW1lPXtjbGFzc05hbWVzfVxyXG4gICAgICAgICAgICBvbktleURvd249e2hhbmRsZUtleURvd259XHJcbiAgICAgICAgICAgIHsuLi5wcm9wc31cclxuICAgICAgICA+XHJcbiAgICAgICAgICAgIDxMaXN0XHJcbiAgICAgICAgICAgICAgICByZWY9e2xpc3RSZWZ9XHJcbiAgICAgICAgICAgICAgICByb2xlPVwibWVudVwiXHJcbiAgICAgICAgICAgICAgICBhcmlhLWhpZGRlbj1cInRydWVcIlxyXG4gICAgICAgICAgICAgICAgYXJpYS1vcmllbnRhdGlvbj1cInZlcnRpY2FsXCJcclxuICAgICAgICAgICAgICAgIHRhYkluZGV4PXtvcGVuID8gMCA6IC0xfVxyXG4gICAgICAgICAgICAgICAgey4uLmxpc3RQcm9wc31cclxuICAgICAgICAgICAgPlxyXG4gICAgICAgICAgICAgICAge0NoaWxkcmVuLm1hcChjaGlsZHJlbiwgKGl0ZW0sIGluZGV4KSA9PlxyXG4gICAgICAgICAgICAgICAgICAgIDxDbG9uZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb21wb25lbnQ9e2l0ZW19XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhYkluZGV4PXsoaW5kZXggPT09IGZvY3VzZWRDaGlsZEluZGV4KSA/IDAgOiAtMX1cclxuICAgICAgICAgICAgICAgICAgICAvPlxyXG4gICAgICAgICAgICAgICAgKX1cclxuICAgICAgICAgICAgPC9MaXN0PlxyXG4gICAgICAgIDwvTWVudVN1cmZhY2U+XHJcbiAgICApO1xyXG59KTtcclxuXHJcbk1lbnUuZGlzcGxheU5hbWUgPSAnTURDTWVudSc7XHJcblxyXG5NZW51LnByb3BUeXBlcyA9IHtcclxuICAgIC4uLk1lbnVTdXJmYWNlLnByb3BUeXBlcyxcclxuICAgIGxpc3RQcm9wczogUHJvcFR5cGVzLm9iamVjdFxyXG59O1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgTWVudTsiLCJpbXBvcnQgeyBmb3J3YXJkUmVmIH0gZnJvbSAncmVhY3QnO1xyXG5pbXBvcnQgY2xhc3NuYW1lcyBmcm9tICdjbGFzc25hbWVzJztcclxuXHJcbmltcG9ydCB7IGNyZWF0ZSwgY2xvbmUgfSBmcm9tICcuLi9jb21wb25lbnQnO1xyXG5pbXBvcnQgeyBjc3NDbGFzc2VzIH0gZnJvbSAnLi9jb25zdGFudHMnO1xyXG5cclxuY29uc3QgTWVudUFuY2hvciA9IGZvcndhcmRSZWYoKHtcclxuICAgIHdyYXAgPSB0cnVlLFxyXG5cclxuICAgIGVsZW1lbnQgPSAnZGl2JyxcclxuICAgIGNsYXNzTmFtZSxcclxuICAgIGNoaWxkcmVuLFxyXG4gICAgLi4ucHJvcHNcclxufSwgcmVmKSA9PiB7XHJcbiAgICByZXR1cm4gd3JhcCA/XHJcbiAgICAgICAgY3JlYXRlKGVsZW1lbnQsIHtcclxuICAgICAgICAgICAgcmVmLFxyXG4gICAgICAgICAgICBjbGFzc05hbWU6IGNsYXNzbmFtZXMoY3NzQ2xhc3Nlcy5TVVJGQUNFX0FOQ0hPUiwgY2xhc3NOYW1lKSxcclxuICAgICAgICAgICAgLi4ucHJvcHNcclxuICAgICAgICB9LCBjaGlsZHJlbilcclxuICAgICAgICA6XHJcbiAgICAgICAgY2xvbmUoY2hpbGRyZW4sIHtcclxuICAgICAgICAgICAgcmVmLFxyXG4gICAgICAgICAgICBjbGFzc05hbWU6IGNsYXNzbmFtZXMoY2hpbGRyZW4ucHJvcHMuY2xhc3NOYW1lLCBjc3NDbGFzc2VzLlNVUkZBQ0VfQU5DSE9SKSxcclxuICAgICAgICAgICAgLi4ucHJvcHNcclxuICAgICAgICB9KTtcclxufSk7XHJcblxyXG5NZW51QW5jaG9yLmRpc3BsYXlOYW1lID0gJ01EQ01lbnVBbmNob3InO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgTWVudUFuY2hvcjsiLCJpbXBvcnQgeyBmb3J3YXJkUmVmIH0gZnJvbSAncmVhY3QnO1xyXG5cclxuY29uc3QgTWVudVNlbGVjdGlvbkdyb3VwID0gZm9yd2FyZFJlZigoe1xyXG4gICAgZWxlbWVudDogRWxlbWVudCA9ICd1bCcsXHJcbiAgICAuLi5wcm9wc1xyXG59LCByZWYpID0+IHtcclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgPGxpIHJlZj17cmVmfT5cclxuICAgICAgICAgICAgPEVsZW1lbnQgY2xhc3NOYW1lPVwibWRjLW1lbnVfX3NlbGVjdGlvbi1ncm91cFwiIHsuLi5wcm9wc30gLz5cclxuICAgICAgICA8L2xpPlxyXG4gICAgKTtcclxufSk7XHJcblxyXG5NZW51U2VsZWN0aW9uR3JvdXAuZGlzcGxheU5hbWUgPSAnTURDTWVudVNlbGVjdGlvbkdyb3VwJztcclxuXHJcbmV4cG9ydCBkZWZhdWx0IE1lbnVTZWxlY3Rpb25Hcm91cDsiLCJpbXBvcnQgSWNvbiBmcm9tICcuLi9pY29uJztcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIE1lbnVTZWxlY3Rpb25Hcm91cEljb24ocHJvcHMpIHtcclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgPEljb25cclxuICAgICAgICAgICAgY2xhc3NOYW1lPVwibWRjLW1lbnVfX3NlbGVjdGlvbi1ncm91cC1pY29uXCJcclxuICAgICAgICAgICAgey4uLnByb3BzfVxyXG4gICAgICAgIC8+XHJcbiAgICApO1xyXG59XHJcblxyXG5NZW51U2VsZWN0aW9uR3JvdXBJY29uLmRpc3BsYXlOYW1lID0gJ01EQ01lbnVTZWxlY3Rpb25Hcm91cEljb24nOyIsImltcG9ydCB7IE9yaWdpbiBhcyBNZW51T3JpZ2luIH0gZnJvbSAnLi9jb25zdGFudHMnO1xyXG5pbXBvcnQgTWVudSBmcm9tICcuL01lbnUnO1xyXG5pbXBvcnQgTWVudUFuY2hvciBmcm9tICcuL01lbnVBbmNob3InO1xyXG5pbXBvcnQgTWVudUl0ZW0gZnJvbSAnLi9NZW51SXRlbSc7XHJcbmltcG9ydCBNZW51U3VyZmFjZSBmcm9tICcuL01lbnVTdXJmYWNlJztcclxuaW1wb3J0IE1lbnVTZWxlY3Rpb25Hcm91cCBmcm9tICcuL01lbnVTZWxlY3Rpb25Hcm91cCc7XHJcbmltcG9ydCBNZW51U2VsZWN0aW9uR3JvdXBJY29uIGZyb20gJy4vTWVudVNlbGVjdGlvbkdyb3VwSWNvbic7XHJcblxyXG5NZW51LkFuY2hvciA9IE1lbnVBbmNob3I7XHJcbk1lbnUuSXRlbSA9IE1lbnVJdGVtO1xyXG5NZW51Lk9yaWdpbiA9IE1lbnVPcmlnaW47XHJcbk1lbnUuU3VyZmFjZSA9IE1lbnVTdXJmYWNlO1xyXG5NZW51LlNlbGVjdGlvbkdyb3VwID0gTWVudVNlbGVjdGlvbkdyb3VwO1xyXG5NZW51LlNlbGVjdGlvbkdyb3VwSWNvbiA9IE1lbnVTZWxlY3Rpb25Hcm91cEljb247XHJcblxyXG5leHBvcnQge1xyXG4gICAgTWVudSBhcyBkZWZhdWx0LFxyXG4gICAgTWVudUFuY2hvcixcclxuICAgIE1lbnVJdGVtLFxyXG4gICAgTWVudU9yaWdpbixcclxuICAgIE1lbnVTdXJmYWNlLFxyXG4gICAgTWVudVNlbGVjdGlvbkdyb3VwLFxyXG4gICAgTWVudVNlbGVjdGlvbkdyb3VwSWNvblxyXG59OyIsImV4cG9ydCBjb25zdCBjc3NDbGFzc2VzID0ge1xyXG4gICAgUk9PVDogJ21kYy1zZWxlY3QnLFxyXG4gICAgRklMTEVEOiAnbWRjLXNlbGVjdC0tZmlsbGVkJyxcclxuICAgIE9VVExJTkVEOiAnbWRjLXNlbGVjdC0tb3V0bGluZWQnLFxyXG4gICAgQUNUSVZBVEVEOiAnbWRjLXNlbGVjdC0tYWN0aXZhdGVkJyxcclxuICAgIERJU0FCTEVEOiAnbWRjLXNlbGVjdC0tZGlzYWJsZWQnLFxyXG4gICAgRk9DVVNFRDogJ21kYy1zZWxlY3QtLWZvY3VzZWQnLFxyXG4gICAgUkVRVUlSRUQ6ICdtZGMtc2VsZWN0LS1yZXF1aXJlZCcsXHJcbiAgICBJTlZBTElEOiAnbWRjLXNlbGVjdC0taW52YWxpZCcsXHJcbiAgICBOT19MQUJFTDogJ21kYy1zZWxlY3QtLW5vLWxhYmVsJyxcclxuICAgIFdJVEhfTEVBRElOR19JQ09OOiAnbWRjLXNlbGVjdC0td2l0aC1sZWFkaW5nLWljb24nLFxyXG5cclxuICAgIEFOQ0hPUjogJ21kYy1zZWxlY3RfX2FuY2hvcicsXHJcblxyXG4gICAgRFJPUERPV05fSUNPTjogJ21kYy1zZWxlY3RfX2Ryb3Bkb3duLWljb24nLFxyXG4gICAgRFJPUERPV05fSUNPTl9HUkFQSElDOiAnbWRjLXNlbGVjdF9fZHJvcGRvd24taWNvbi1ncmFwaGljJyxcclxuICAgIERST1BET1dOX0lDT05fSU5BQ1RJVkU6ICdtZGMtc2VsZWN0X19kcm9wZG93bi1pY29uLWluYWN0aXZlJyxcclxuICAgIERST1BET1dOX0lDT05fQUNUSVZFOiAnbWRjLXNlbGVjdF9fZHJvcGRvd24taWNvbi1hY3RpdmUnLFxyXG5cclxuICAgIElDT046ICdtZGMtc2VsZWN0X19pY29uJyxcclxuXHJcbiAgICBNRU5VOiAnbWRjLXNlbGVjdF9fbWVudScsXHJcbiAgICBNRU5VX0lOVkFMSUQ6ICdtZGMtc2VsZWN0X19tZW51LS1pbnZhbGlkJyxcclxuXHJcbiAgICBSSVBQTEU6ICdtZGMtc2VsZWN0X19yaXBwbGUnLFxyXG5cclxuICAgIFNFTEVDVEVEX1RFWFQ6ICdtZGMtc2VsZWN0X19zZWxlY3RlZC10ZXh0JyxcclxuICAgIFNFTEVDVEVEX1RFWFRfQ09OVEFJTkVSOiAnbWRjLXNlbGVjdF9fc2VsZWN0ZWQtdGV4dC1jb250YWluZXInLFxyXG5cclxuICAgIEhFTFBFUl9URVhUOiAnbWRjLXNlbGVjdC1oZWxwZXItdGV4dCcsXHJcbiAgICBWQUxJREFUSU9OX01FU1NBR0U6ICdtZGMtc2VsZWN0LWhlbHBlci10ZXh0LS12YWxpZGF0aW9uLW1zZycsXHJcbiAgICBWQUxJREFUSU9OX01FU1NBR0VfUEVSU0lTVEVOVDogJ21kYy1zZWxlY3QtaGVscGVyLXRleHQtLXZhbGlkYXRpb24tbXNnLXBlcnNpc3RlbnQnXHJcbn07XHJcblxyXG5leHBvcnQgY29uc3Qgb3B0aW9uQ3NzQ2xhc3NlcyA9IHtcclxuICAgIFJPT1Q6ICdtZGMtc2VsZWN0X19vcHRpb24nLFxyXG4gICAgT05FX0xJTkU6ICdtZGMtc2VsZWN0X19vbmUtbGluZS1vcHRpb24nLFxyXG4gICAgVFdPX0xJTkU6ICdtZGMtc2VsZWN0X190d28tbGluZS1vcHRpb24nLFxyXG4gICAgV0lUSF9MRUFESU5HX0NPTlRFTlQ6ICdtZGMtc2VsZWN0X19vcHRpb24td2l0aC1sZWFkaW5nLWNvbnRlbnQnLFxyXG4gICAgV0lUSF9NRVRBOiAnbWRjLXNlbGVjdF9fb3B0aW9uLXdpdGgtbWV0YScsXHJcbn07IiwiaW1wb3J0IHsgY3NzQ2xhc3NlcyB9IGZyb20gJy4vY29uc3RhbnRzJztcclxuXHJcbmNvbnN0IERyb3Bkb3duSWNvbiA9ICgpID0+IHtcclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgPHNwYW4gY2xhc3NOYW1lPXtjc3NDbGFzc2VzLkRST1BET1dOX0lDT059PlxyXG4gICAgICAgICAgICA8c3ZnXHJcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU9e2Nzc0NsYXNzZXMuRFJPUERPV05fSUNPTl9HUkFQSElDfVxyXG4gICAgICAgICAgICAgICAgdmlld0JveD1cIjcgMTAgMTAgNVwiXHJcbiAgICAgICAgICAgICAgICBmb2N1c2FibGU9XCJmYWxzZVwiXHJcbiAgICAgICAgICAgID5cclxuICAgICAgICAgICAgICAgIDxwb2x5Z29uXHJcbiAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPXtjc3NDbGFzc2VzLkRST1BET1dOX0lDT05fSU5BQ1RJVkV9XHJcbiAgICAgICAgICAgICAgICAgICAgc3Ryb2tlPVwibm9uZVwiXHJcbiAgICAgICAgICAgICAgICAgICAgZmlsbFJ1bGU9XCJldmVub2RkXCJcclxuICAgICAgICAgICAgICAgICAgICBwb2ludHM9XCI3IDEwIDEyIDE1IDE3IDEwXCJcclxuICAgICAgICAgICAgICAgIC8+XHJcblxyXG4gICAgICAgICAgICAgICAgPHBvbHlnb25cclxuICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU9e2Nzc0NsYXNzZXMuRFJPUERPV05fSUNPTl9BQ1RJVkV9XHJcbiAgICAgICAgICAgICAgICAgICAgc3Ryb2tlPVwibm9uZVwiXHJcbiAgICAgICAgICAgICAgICAgICAgZmlsbFJ1bGU9XCJldmVub2RkXCJcclxuICAgICAgICAgICAgICAgICAgICBwb2ludHM9XCI3IDE1IDEyIDEwIDE3IDE1XCJcclxuICAgICAgICAgICAgICAgIC8+XHJcbiAgICAgICAgICAgIDwvc3ZnPlxyXG4gICAgICAgIDwvc3Bhbj5cclxuICAgICk7XHJcbn07XHJcblxyXG5leHBvcnQgZGVmYXVsdCBEcm9wZG93bkljb247IiwiaW1wb3J0IHsgZm9yd2FyZFJlZiB9IGZyb20gJ3JlYWN0JztcclxuaW1wb3J0IGNsYXNzbmFtZXMgZnJvbSAnY2xhc3NuYW1lcyc7XHJcblxyXG5pbXBvcnQgQ2hlY2tib3ggZnJvbSAnLi4vY2hlY2tib3gnO1xyXG5pbXBvcnQgeyBNZW51SXRlbSB9IGZyb20gJy4uL21lbnUnO1xyXG5cclxuaW1wb3J0IHsgb3B0aW9uQ3NzQ2xhc3NlcyBhcyBjc3NDbGFzc2VzIH0gZnJvbSAnLi9jb25zdGFudHMnO1xyXG5cclxuY29uc3QgU2VsZWN0T3B0aW9uID0gZm9yd2FyZFJlZigoe1xyXG4gICAgaWNvbixcclxuICAgIGltYWdlLFxyXG4gICAgYXZhdGFyLFxyXG4gICAgcHJpbWFyeVRleHQsXHJcbiAgICBzZWNvbmRhcnlUZXh0LFxyXG4gICAgbWV0YSxcclxuICAgIHNlbGVjdGVkLFxyXG4gICAgY2hlY2tib3ggPSBmYWxzZSxcclxuICAgIG9uZUxpbmUgPSBmYWxzZSxcclxuICAgIHR3b0xpbmVzID0gZmFsc2UsXHJcbiAgICBjbGFzc05hbWUsXHJcbiAgICBvbkNsaWNrLFxyXG4gICAgLi4ucHJvcHNcclxufSwgcmVmKSA9PiB7XHJcbiAgICBjb25zdCBsaW5lcyA9IEJvb2xlYW4ocHJpbWFyeVRleHQpICsgQm9vbGVhbihzZWNvbmRhcnlUZXh0KTtcclxuICAgIGNvbnN0IGhhc0xlYWRpbmdDb250ZW50ID0gQm9vbGVhbihjaGVja2JveCB8fCBpY29uIHx8IGltYWdlIHx8IGF2YXRhcik7XHJcblxyXG4gICAgY29uc3QgY2xhc3NOYW1lcyA9IGNsYXNzbmFtZXMoY3NzQ2xhc3Nlcy5ST09ULCB7XHJcbiAgICAgICAgW2Nzc0NsYXNzZXMuT05FX0xJTkVdOiBvbmVMaW5lIHx8IGxpbmVzID09PSAxLFxyXG4gICAgICAgIFtjc3NDbGFzc2VzLlRXT19MSU5FXTogdHdvTGluZXMgfHwgbGluZXMgPT09IDIsXHJcbiAgICAgICAgW2Nzc0NsYXNzZXMuV0lUSF9MRUFESU5HX0NPTlRFTlRdOiBoYXNMZWFkaW5nQ29udGVudCxcclxuICAgICAgICBbY3NzQ2xhc3Nlcy5XSVRIX01FVEFdOiBtZXRhXHJcbiAgICB9LCBjbGFzc05hbWUpO1xyXG5cclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgPE1lbnVJdGVtXHJcbiAgICAgICAgICAgIHJlZj17cmVmfVxyXG4gICAgICAgICAgICBjbGFzc05hbWU9e2NsYXNzTmFtZXN9XHJcbiAgICAgICAgICAgIGxlYWRpbmdDaGVja2JveD17Y2hlY2tib3ggPyA8Q2hlY2tib3ggY2hlY2tlZD17c2VsZWN0ZWR9IC8+IDogdW5kZWZpbmVkfVxyXG4gICAgICAgICAgICBpY29uPXtpY29ufVxyXG4gICAgICAgICAgICBpbWFnZT17aW1hZ2V9XHJcbiAgICAgICAgICAgIGF2YXRhcj17YXZhdGFyfVxyXG4gICAgICAgICAgICBwcmltYXJ5VGV4dD17cHJpbWFyeVRleHR9XHJcbiAgICAgICAgICAgIHNlY29uZGFyeVRleHQ9e3NlY29uZGFyeVRleHR9XHJcbiAgICAgICAgICAgIG1ldGE9e21ldGF9XHJcbiAgICAgICAgICAgIHNlbGVjdGVkPXtzZWxlY3RlZH1cclxuICAgICAgICAgICAgb25lTGluZT17b25lTGluZX1cclxuICAgICAgICAgICAgdHdvTGluZXM9e3R3b0xpbmVzfVxyXG4gICAgICAgICAgICB3aXRoTGVhZGluZ0NoZWNrYm94PXtjaGVja2JveH1cclxuICAgICAgICAgICAgb25DbGljaz17b25DbGlja31cclxuICAgICAgICAgICAgey4uLnByb3BzfVxyXG4gICAgICAgIC8+XHJcbiAgICApO1xyXG59KTtcclxuXHJcblNlbGVjdE9wdGlvbi5kaXNwbGF5TmFtZSA9ICdNRENTZWxlY3RPcHRpb24nO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgU2VsZWN0T3B0aW9uOyIsImltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XHJcbmltcG9ydCBjbGFzc25hbWVzIGZyb20gJ2NsYXNzbmFtZXMnO1xyXG5cclxuaW1wb3J0IHsgY3NzQ2xhc3NlcyB9IGZyb20gJy4vY29uc3RhbnRzJztcclxuXHJcbmNvbnN0IEhlbHBlclRleHQgPSAoe1xyXG4gICAgdmFsaWRhdGlvbiA9IGZhbHNlLFxyXG4gICAgcGVyc2lzdGVudCA9IGZhbHNlLFxyXG5cclxuICAgIGVsZW1lbnQ6IEVsZW1lbnQgPSAncCcsXHJcbiAgICAuLi5wcm9wc1xyXG59KSA9PiB7XHJcbiAgICBjb25zdCBjbGFzc05hbWVzID0gY2xhc3NuYW1lcyhjc3NDbGFzc2VzLkhFTFBFUl9URVhULCB7XHJcbiAgICAgICAgW2Nzc0NsYXNzZXMuVkFMSURBVElPTl9NRVNTQUdFXTogdmFsaWRhdGlvbixcclxuICAgICAgICBbY3NzQ2xhc3Nlcy5WQUxJREFUSU9OX01FU1NBR0VfUEVSU0lTVEVOVF06IHBlcnNpc3RlbnRcclxuICAgIH0pO1xyXG5cclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgPEVsZW1lbnQgY2xhc3NOYW1lPXtjbGFzc05hbWVzfSB7Li4ucHJvcHN9IC8+XHJcbiAgICApO1xyXG59O1xyXG5cclxuSGVscGVyVGV4dC5kaXNwbGF5TmFtZSA9ICdNRENTZWxlY3RIZWxwZXJUZXh0JztcclxuXHJcbkhlbHBlclRleHQucHJvcFR5cGVzID0ge1xyXG4gICAgcGVyc2lzdGVudDogUHJvcFR5cGVzLmJvb2wsXHJcbiAgICB2YWxpZGF0aW9uOiBQcm9wVHlwZXMuYm9vbFxyXG59O1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgSGVscGVyVGV4dDsiLCJpbXBvcnQgeyB1c2VSZWYsIHVzZVN0YXRlLCB1c2VFZmZlY3QsIHVzZUNhbGxiYWNrLCBDaGlsZHJlbiwgZm9yd2FyZFJlZiB9IGZyb20gJ3JlYWN0JztcclxuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcclxuaW1wb3J0IGNsYXNzbmFtZXMgZnJvbSAnY2xhc3NuYW1lcyc7XHJcblxyXG5pbXBvcnQgeyBpc1VuZGVmaW5lZCwgaXNBcnJheSB9IGZyb20gJy4uL3R5cGVzJztcclxuaW1wb3J0IHsgQ2xvbmUsIGNyZWF0ZSwgY2xvbmUgfSBmcm9tICcuLi9jb21wb25lbnQnO1xyXG5pbXBvcnQgRmxvYXRpbmdMYWJlbCBmcm9tICcuLi9mbG9hdGluZy1sYWJlbCc7XHJcbmltcG9ydCBJY29uIGZyb20gJy4uL2ljb24nO1xyXG5pbXBvcnQgTGluZVJpcHBsZSBmcm9tICcuLi9saW5lLXJpcHBsZSc7XHJcbmltcG9ydCBOb3RjaGVkT3V0bGluZSBmcm9tICcuLi9ub3RjaGVkLW91dGxpbmUnO1xyXG5pbXBvcnQgTWVudSwgeyBNZW51T3JpZ2luIH0gZnJvbSAnLi4vbWVudSc7XHJcblxyXG5pbXBvcnQgeyBjc3NDbGFzc2VzIH0gZnJvbSAnLi9jb25zdGFudHMnO1xyXG5pbXBvcnQgRHJvcGRvd25JY29uIGZyb20gJy4vRHJvcGRvd25JY29uJztcclxuaW1wb3J0IFNlbGVjdE9wdGlvbiBmcm9tICcuL1NlbGVjdE9wdGlvbic7XHJcbmltcG9ydCBIZWxwZXJUZXh0IGZyb20gJy4vSGVscGVyVGV4dCc7XHJcblxyXG5jb25zdCBTZWxlY3QgPSBmb3J3YXJkUmVmKCh7XHJcbiAgICBuYW1lLFxyXG4gICAgdmFsdWUsXHJcbiAgICBvcHRpb25zLFxyXG4gICAgbGFiZWwsXHJcbiAgICBpY29uLFxyXG4gICAgbGVhZGluZ0ljb24gPSBpY29uLFxyXG4gICAgaGVscGVyVGV4dCxcclxuICAgIGZpbGxlZCA9IGZhbHNlLFxyXG4gICAgb3V0bGluZWQgPSBmYWxzZSxcclxuICAgIG11bHRpcGxlID0gaXNBcnJheSh2YWx1ZSksXHJcbiAgICBkaXNhYmxlZCA9IGZhbHNlLFxyXG4gICAgcmVxdWlyZWQgPSBmYWxzZSxcclxuICAgIG9uQ2hhbmdlID0gRnVuY3Rpb24ucHJvdG90eXBlLFxyXG4gICAgbWVudVByb3BzID0ge30sXHJcbiAgICBsaXN0UHJvcHMgPSB7fSxcclxuICAgIGhlbHBlclRleHRQcm9wcyA9IHt9LFxyXG5cclxuICAgIGNsYXNzTmFtZSxcclxuICAgIGNoaWxkcmVuID0gb3B0aW9ucz8ubWFwKG9wdGlvbiA9PiBjcmVhdGUoU2VsZWN0T3B0aW9uLCBvcHRpb24pKSxcclxuICAgIC4uLnByb3BzXHJcbn0sIHJlZikgPT4ge1xyXG4gICAgY29uc3QgYW5jaG9yUmVmID0gdXNlUmVmKCk7XHJcbiAgICBjb25zdCBpbnB1dFJlZiA9IHVzZVJlZigpO1xyXG4gICAgY29uc3QgbWVudVJlZiA9IHVzZVJlZigpO1xyXG5cclxuICAgIGNvbnN0IFthY3RpdmF0ZWQsIHNldEFjdGl2YXRlZF0gPSB1c2VTdGF0ZShmYWxzZSk7XHJcbiAgICBjb25zdCBbZm9jdXNlZCwgc2V0Rm9jdXNlZF0gPSB1c2VTdGF0ZShmYWxzZSk7XHJcbiAgICBjb25zdCBbdG91Y2hlZCwgc2V0VG91Y2hlZF0gPSB1c2VTdGF0ZShmYWxzZSk7XHJcbiAgICBjb25zdCBbc2VsZWN0ZWRUZXh0LCBzZXRTZWxlY3RlZFRleHRdID0gdXNlU3RhdGUoKTtcclxuICAgIGNvbnN0IFtpbnRlcmFjdGlvbkNvb3Jkcywgc2V0SW50ZXJhY3Rpb25Db29yZHNdID0gdXNlU3RhdGUoKTtcclxuXHJcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgICAgIGlmIChtdWx0aXBsZSkge1xyXG4gICAgICAgICAgICBjb25zdCBzZWxlY3RlZE9wdGlvbnMgPSAoQ2hpbGRyZW4udG9BcnJheShjaGlsZHJlbikubWFwKG9wdGlvbiA9PiBvcHRpb24ucHJvcHMpKVxyXG4gICAgICAgICAgICAgICAgLmZpbHRlcihvcHRpb24gPT4gdmFsdWUuaW5jbHVkZXMob3B0aW9uLnZhbHVlKSk7XHJcblxyXG4gICAgICAgICAgICBjb25zdCBzZWxlY3RlZFRleHQgPSBzZWxlY3RlZE9wdGlvbnMubWFwKG9wdGlvbiA9PiBvcHRpb24udGV4dCB8fCBvcHRpb24uY2hpbGRyZW4pLmpvaW4oJywgJyk7XHJcbiAgICAgICAgICAgIHNldFNlbGVjdGVkVGV4dChzZWxlY3RlZFRleHQpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHNlbGVjdGVkT3B0aW9uID0gKENoaWxkcmVuLnRvQXJyYXkoY2hpbGRyZW4pLm1hcChvcHRpb24gPT4gb3B0aW9uLnByb3BzKSlcclxuICAgICAgICAgICAgICAgIC5maW5kKG9wdGlvbiA9PiBvcHRpb24udmFsdWUgPT09IHZhbHVlKTtcclxuXHJcbiAgICAgICAgICAgIGlmIChzZWxlY3RlZE9wdGlvbikge1xyXG4gICAgICAgICAgICAgICAgc2V0U2VsZWN0ZWRUZXh0KHNlbGVjdGVkT3B0aW9uLnRleHQgfHwgc2VsZWN0ZWRPcHRpb24uY2hpbGRyZW4pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfSwgW3ZhbHVlLCBtdWx0aXBsZSwgY2hpbGRyZW5dKTtcclxuXHJcbiAgICBjb25zdCBoYW5kbGVBbmNob3JDbGljayA9IHVzZUNhbGxiYWNrKGV2ZW50ID0+IHtcclxuICAgICAgICBpZiAoYWN0aXZhdGVkKSB7XHJcbiAgICAgICAgICAgIHNldEFjdGl2YXRlZChmYWxzZSk7XHJcbiAgICAgICAgICAgIHNldEZvY3VzZWQoZmFsc2UpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHRhcmdldENsaWVudFJlY3QgPSBldmVudC50YXJnZXQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XHJcblxyXG4gICAgICAgICAgICBzZXRJbnRlcmFjdGlvbkNvb3Jkcyh7XHJcbiAgICAgICAgICAgICAgICB4OiBldmVudC5jbGllbnRYIC0gdGFyZ2V0Q2xpZW50UmVjdC5sZWZ0LFxyXG4gICAgICAgICAgICAgICAgeTogZXZlbnQuY2xpZW50WSAtIHRhcmdldENsaWVudFJlY3QudG9wXHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgc2V0QWN0aXZhdGVkKHRydWUpO1xyXG4gICAgICAgICAgICBzZXRGb2N1c2VkKHRydWUpO1xyXG4gICAgICAgIH1cclxuICAgIH0sIFthY3RpdmF0ZWRdKTtcclxuXHJcbiAgICBjb25zdCBoYW5kbGVPcHRpb25JbnRlcmFjdGlvbiA9IHVzZUNhbGxiYWNrKGV2ZW50ID0+IHtcclxuICAgICAgICBpZiAoXHJcbiAgICAgICAgICAgIGV2ZW50LnR5cGUgPT09ICdrZXlkb3duJyAmJlxyXG4gICAgICAgICAgICBldmVudC5rZXkgIT09ICcgJyAmJlxyXG4gICAgICAgICAgICBldmVudC5rZXkgIT09ICdFbnRlcidcclxuICAgICAgICApIHJldHVybjtcclxuXHJcbiAgICAgICAgY29uc3Qgb3B0aW9uID0gZXZlbnQuY3VycmVudFRhcmdldC5kYXRhc2V0O1xyXG5cclxuICAgICAgICBpZiAob3B0aW9uLmRpc2FibGVkKSByZXR1cm47XHJcblxyXG4gICAgICAgIGlmIChtdWx0aXBsZSkge1xyXG4gICAgICAgICAgICBjb25zdCB2YWx1ZXMgPSBuZXcgU2V0KHZhbHVlKTtcclxuXHJcbiAgICAgICAgICAgIHZhbHVlcy5oYXMob3B0aW9uLnZhbHVlKSA/XHJcbiAgICAgICAgICAgICAgICB2YWx1ZXMuZGVsZXRlKG9wdGlvbi52YWx1ZSkgOlxyXG4gICAgICAgICAgICAgICAgdmFsdWVzLmFkZChvcHRpb24udmFsdWUpO1xyXG5cclxuICAgICAgICAgICAgZXZlbnQudGFyZ2V0ID0geyBuYW1lLCB2YWx1ZTogWy4uLnZhbHVlc10gfTtcclxuXHJcbiAgICAgICAgICAgIG9uQ2hhbmdlKGV2ZW50LCBbLi4udmFsdWVzXSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgZXZlbnQudGFyZ2V0ID0geyBuYW1lLCB2YWx1ZTogb3B0aW9uLnZhbHVlIH07XHJcblxyXG4gICAgICAgICAgICBvbkNoYW5nZShldmVudCwgb3B0aW9uLnZhbHVlKTtcclxuXHJcbiAgICAgICAgICAgIHNldEFjdGl2YXRlZChmYWxzZSk7XHJcbiAgICAgICAgICAgIHNldEZvY3VzZWQoZmFsc2UpO1xyXG4gICAgICAgIH1cclxuICAgIH0sIFt2YWx1ZSwgbmFtZSwgbXVsdGlwbGUsIG9uQ2hhbmdlXSk7XHJcblxyXG4gICAgY29uc3QgaGFuZGxlTWVudUNsb3NlID0gdXNlQ2FsbGJhY2soZXZlbnQgPT4ge1xyXG4gICAgICAgIGlmIChldmVudC50eXBlID09PSAnY2xpY2snICYmIGV2ZW50LnRhcmdldCA9PT0gYW5jaG9yUmVmLmN1cnJlbnQpIHJldHVybjtcclxuICAgICAgICBpZiAobXVsdGlwbGUgJiYgZXZlbnQudHlwZSA9PT0gJ2NsaWNrJyAmJiBldmVudC5wYXRoLmluY2x1ZGVzKG1lbnVSZWYuY3VycmVudCkpIHJldHVybjtcclxuXHJcbiAgICAgICAgc2V0QWN0aXZhdGVkKGZhbHNlKTtcclxuICAgICAgICBzZXRGb2N1c2VkKGZhbHNlKTtcclxuICAgICAgICBzZXRUb3VjaGVkKHRydWUpO1xyXG4gICAgfSwgW211bHRpcGxlXSk7XHJcblxyXG4gICAgY29uc3QgaGFuZGxlS2V5RG93biA9IHVzZUNhbGxiYWNrKGV2ZW50ID0+IHtcclxuICAgICAgICBpZiAoXHJcbiAgICAgICAgICAgIGV2ZW50LmtleSA9PT0gJyAnIHx8XHJcbiAgICAgICAgICAgIGV2ZW50LmtleSA9PT0gJ0VudGVyJyB8fFxyXG4gICAgICAgICAgICBldmVudC5rZXkgPT09ICdBcnJvd0Rvd24nIHx8XHJcbiAgICAgICAgICAgIGV2ZW50LmtleSA9PT0gJ0Fycm93VXAnXHJcbiAgICAgICAgKSB7XHJcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xyXG5cclxuICAgICAgICAgICAgc2V0QWN0aXZhdGVkKHRydWUpO1xyXG4gICAgICAgIH1cclxuICAgIH0sIFtdKTtcclxuXHJcbiAgICBjb25zdCBoYXNWYWx1ZSA9IGlzQXJyYXkodmFsdWUpID8gdmFsdWUubGVuZ3RoID4gMCA6IEJvb2xlYW4odmFsdWUpO1xyXG4gICAgY29uc3QgZm9jdXNlZE9ySGFzVmFsdWUgPSBmb2N1c2VkIHx8IGhhc1ZhbHVlO1xyXG4gICAgY29uc3QgaXNJbnZhbGlkID0gdG91Y2hlZCAmJiByZXF1aXJlZCAmJiAhaGFzVmFsdWU7XHJcblxyXG4gICAgY29uc3QgY2xhc3NOYW1lcyA9IGNsYXNzbmFtZXMoY3NzQ2xhc3Nlcy5ST09ULCB7XHJcbiAgICAgICAgW2Nzc0NsYXNzZXMuRklMTEVEXTogZmlsbGVkLFxyXG4gICAgICAgIFtjc3NDbGFzc2VzLk9VVExJTkVEXTogb3V0bGluZWQsXHJcbiAgICAgICAgW2Nzc0NsYXNzZXMuQUNUSVZBVEVEXTogYWN0aXZhdGVkLFxyXG4gICAgICAgIFtjc3NDbGFzc2VzLkRJU0FCTEVEXTogZGlzYWJsZWQsXHJcbiAgICAgICAgW2Nzc0NsYXNzZXMuRk9DVVNFRF06IGZvY3VzZWQsXHJcbiAgICAgICAgW2Nzc0NsYXNzZXMuUkVRVUlSRURdOiByZXF1aXJlZCxcclxuICAgICAgICBbY3NzQ2xhc3Nlcy5JTlZBTElEXTogaXNJbnZhbGlkLFxyXG4gICAgICAgIFtjc3NDbGFzc2VzLk5PX0xBQkVMXTogIWxhYmVsLFxyXG4gICAgICAgIFtjc3NDbGFzc2VzLldJVEhfTEVBRElOR19JQ09OXTogbGVhZGluZ0ljb25cclxuICAgIH0sIGNsYXNzTmFtZSk7XHJcblxyXG4gICAgcmV0dXJuICg8PlxyXG4gICAgICAgIDxkaXYgcmVmPXtyZWZ9IGNsYXNzTmFtZT17Y2xhc3NOYW1lc30+XHJcbiAgICAgICAgICAgIHtuYW1lICYmXHJcbiAgICAgICAgICAgICAgICA8aW5wdXRcclxuICAgICAgICAgICAgICAgICAgICByZWY9e2lucHV0UmVmfVxyXG4gICAgICAgICAgICAgICAgICAgIHR5cGU9XCJoaWRkZW5cIlxyXG4gICAgICAgICAgICAgICAgICAgIG5hbWU9e25hbWV9XHJcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU9e3ZhbHVlfVxyXG4gICAgICAgICAgICAgICAgICAgIHJlcXVpcmVkPXtyZXF1aXJlZH1cclxuICAgICAgICAgICAgICAgICAgICBkaXNhYmxlZD17ZGlzYWJsZWR9XHJcbiAgICAgICAgICAgICAgICAgICAgey4uLnByb3BzfVxyXG4gICAgICAgICAgICAgICAgLz5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgPGRpdlxyXG4gICAgICAgICAgICAgICAgcmVmPXthbmNob3JSZWZ9XHJcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU9e2Nzc0NsYXNzZXMuQU5DSE9SfVxyXG4gICAgICAgICAgICAgICAgYXJpYS1yZXF1aXJlZD17cmVxdWlyZWQgfHwgdW5kZWZpbmVkfVxyXG4gICAgICAgICAgICAgICAgdGFiSW5kZXg9eyFkaXNhYmxlZCA/IDAgOiB1bmRlZmluZWR9XHJcbiAgICAgICAgICAgICAgICBvbktleURvd249e2hhbmRsZUtleURvd259XHJcbiAgICAgICAgICAgICAgICBvbkNsaWNrPXtoYW5kbGVBbmNob3JDbGlja31cclxuICAgICAgICAgICAgPlxyXG4gICAgICAgICAgICAgICAge2ZpbGxlZCAmJlxyXG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXtjc3NDbGFzc2VzLlJJUFBMRX0gLz5cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICB7ZmlsbGVkICYmIGxhYmVsICYmXHJcbiAgICAgICAgICAgICAgICAgICAgPEZsb2F0aW5nTGFiZWxcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWw9e2xhYmVsfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmbG9hdD17Zm9jdXNlZE9ySGFzVmFsdWV9XHJcbiAgICAgICAgICAgICAgICAgICAgLz5cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICB7b3V0bGluZWQgJiZcclxuICAgICAgICAgICAgICAgICAgICA8Tm90Y2hlZE91dGxpbmUgbm90Y2hlZD17Zm9jdXNlZE9ySGFzVmFsdWV9PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB7bGFiZWwgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxGbG9hdGluZ0xhYmVsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWw9e2xhYmVsfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZsb2F0PXtmb2N1c2VkT3JIYXNWYWx1ZX1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICA8L05vdGNoZWRPdXRsaW5lPlxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHtsZWFkaW5nSWNvbiAmJlxyXG4gICAgICAgICAgICAgICAgICAgIDxDbG9uZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb21wb25lbnQ9e2xlYWRpbmdJY29ufVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmYWxsYmFjaz17SWNvbn1cclxuICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPXtjc3NDbGFzc2VzLklDT059XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhYkluZGV4PVwiMFwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvbGU9XCJidXR0b25cIlxyXG4gICAgICAgICAgICAgICAgICAgIC8+XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgPHNwYW4gY2xhc3NOYW1lPXtjc3NDbGFzc2VzLlNFTEVDVEVEX1RFWFRfQ09OVEFJTkVSfT5cclxuICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9e2Nzc0NsYXNzZXMuU0VMRUNURURfVEVYVH0+e3NlbGVjdGVkVGV4dH08L3NwYW4+XHJcbiAgICAgICAgICAgICAgICA8L3NwYW4+XHJcblxyXG4gICAgICAgICAgICAgICAgPERyb3Bkb3duSWNvbiAvPlxyXG5cclxuICAgICAgICAgICAgICAgIHtmaWxsZWQgJiZcclxuICAgICAgICAgICAgICAgICAgICA8TGluZVJpcHBsZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBhY3RpdmU9e2ZvY3VzZWR9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybU9yaWdpbj17aW50ZXJhY3Rpb25Db29yZHM/Lnh9XHJcbiAgICAgICAgICAgICAgICAgICAgLz5cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgPC9kaXY+XHJcblxyXG4gICAgICAgICAgICA8TWVudVxyXG4gICAgICAgICAgICAgICAgcmVmPXttZW51UmVmfVxyXG4gICAgICAgICAgICAgICAgYW5jaG9yUmVmPXthbmNob3JSZWZ9XHJcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU9e2Nzc0NsYXNzZXMuTUVOVX1cclxuICAgICAgICAgICAgICAgIG9wZW49e2FjdGl2YXRlZH1cclxuICAgICAgICAgICAgICAgIGFuY2hvck9yaWdpbj17TWVudU9yaWdpbi5CT1RUT01fQ0VOVEVSfVxyXG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtT3JpZ2luPXtNZW51T3JpZ2luLlRPUF9DRU5URVJ9XHJcbiAgICAgICAgICAgICAgICBmdWxsV2lkdGhcclxuICAgICAgICAgICAgICAgIGxpc3RQcm9wcz17bGlzdFByb3BzfVxyXG4gICAgICAgICAgICAgICAgb25DbG9zZT17aGFuZGxlTWVudUNsb3NlfVxyXG4gICAgICAgICAgICAgICAgey4uLm1lbnVQcm9wc31cclxuICAgICAgICAgICAgPlxyXG4gICAgICAgICAgICAgICAge0NoaWxkcmVuLm1hcChjaGlsZHJlbiwgb3B0aW9uID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBvcHRpb25WYWx1ZSA9IG9wdGlvbi5wcm9wcy52YWx1ZTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNsb25lKG9wdGlvbiwge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdW5kZWZpbmVkLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAnZGF0YS12YWx1ZSc6IG9wdGlvblZhbHVlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3RlZDogIWlzVW5kZWZpbmVkKHZhbHVlKSAmJiAobXVsdGlwbGUgPyB2YWx1ZS5pbmNsdWRlcyhvcHRpb25WYWx1ZSkgOiBvcHRpb25WYWx1ZSA9PT0gdmFsdWUpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjaGVja2JveDogbXVsdGlwbGUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2xpY2s6IGhhbmRsZU9wdGlvbkludGVyYWN0aW9uLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBvbktleURvd246IGhhbmRsZU9wdGlvbkludGVyYWN0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9KX1cclxuICAgICAgICAgICAgPC9NZW51PlxyXG4gICAgICAgIDwvZGl2PlxyXG5cclxuICAgICAgICB7aGVscGVyVGV4dCAmJlxyXG4gICAgICAgICAgICA8SGVscGVyVGV4dCB7Li4uaGVscGVyVGV4dFByb3BzfT57aGVscGVyVGV4dH08L0hlbHBlclRleHQ+XHJcbiAgICAgICAgfVxyXG4gICAgPC8+KTtcclxufSk7XHJcblxyXG5TZWxlY3QuZGlzcGxheU5hbWUgPSAnTURDU2VsZWN0JztcclxuXHJcblNlbGVjdC5wcm9wVHlwZXMgPSB7XHJcbiAgICB2YWx1ZTogUHJvcFR5cGVzLmFueSxcclxuICAgIG9wdGlvbnM6IFByb3BUeXBlcy5hcnJheU9mKFByb3BUeXBlcy5vYmplY3QpLFxyXG4gICAgbGFiZWw6IFByb3BUeXBlcy5zdHJpbmcsXHJcbiAgICBsZWFkaW5nSWNvbjogUHJvcFR5cGVzLmVsZW1lbnQsXHJcbiAgICBoZWxwZXJUZXh0OiBQcm9wVHlwZXMuc3RyaW5nLFxyXG4gICAgZmlsbGVkOiBQcm9wVHlwZXMuYm9vbCxcclxuICAgIG91dGxpbmVkOiBQcm9wVHlwZXMuYm9vbCxcclxuICAgIG11bHRpcGxlOiBQcm9wVHlwZXMuYm9vbCxcclxuICAgIGRpc2FibGVkOiBQcm9wVHlwZXMuYm9vbCxcclxuICAgIHJlcXVpcmVkOiBQcm9wVHlwZXMuYm9vbCxcclxuICAgIGNoaWxkcmVuOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtcclxuICAgICAgICBQcm9wVHlwZXMuZWxlbWVudCxcclxuICAgICAgICBQcm9wVHlwZXMuYXJyYXlPZihQcm9wVHlwZXMuZWxlbWVudClcclxuICAgIF0pLFxyXG4gICAgbWVudVByb3BzOiBQcm9wVHlwZXMub2JqZWN0LFxyXG4gICAgaGVscGVyVGV4dFByb3BzOiBQcm9wVHlwZXMub2JqZWN0LFxyXG4gICAgb25DaGFuZ2U6IFByb3BUeXBlcy5mdW5jXHJcbn07XHJcblxyXG5leHBvcnQgZGVmYXVsdCBTZWxlY3Q7IiwiaW1wb3J0IFNlbGVjdCBmcm9tICcuL1NlbGVjdCc7XHJcbmltcG9ydCBTZWxlY3RPcHRpb24gZnJvbSAnLi9TZWxlY3RPcHRpb24nO1xyXG5cclxuU2VsZWN0Lk9wdGlvbiA9IFNlbGVjdE9wdGlvbjtcclxuXHJcbmV4cG9ydCB7XHJcbiAgICBTZWxlY3QgYXMgZGVmYXVsdCxcclxuICAgIFNlbGVjdE9wdGlvblxyXG59OyIsImltcG9ydCB7IGZvcndhcmRSZWYgfSBmcm9tICdyZWFjdCc7XHJcbmltcG9ydCBjbGFzc25hbWVzIGZyb20gJ2NsYXNzbmFtZXMnO1xyXG5cclxuaW1wb3J0IEljb25CdXR0b24gZnJvbSAnLi4vaWNvbi1idXR0b24nO1xyXG5pbXBvcnQgU2VsZWN0IGZyb20gJy4uL3NlbGVjdCc7XHJcblxyXG5pbXBvcnQgeyBjc3NDbGFzc2VzIH0gZnJvbSAnLi9jb25zdGFudHMnO1xyXG5cclxuY29uc3QgRGF0YVRhYmxlUGFnaW5hdGlvbiA9IGZvcndhcmRSZWYoKHtcclxuICAgIHRvdGFsQ291bnQsXHJcbiAgICBjdXJyZW50UGFnZSA9IDEsXHJcbiAgICByb3dzUGVyUGFnZSA9IDEwLFxyXG4gICAgb25GaXJzdFBhZ2UgPSBGdW5jdGlvbi5wcm90b3R5cGUsXHJcbiAgICBvblByZXZQYWdlID0gRnVuY3Rpb24ucHJvdG90eXBlLFxyXG4gICAgb25OZXh0UGFnZSA9IEZ1bmN0aW9uLnByb3RvdHlwZSxcclxuICAgIG9uTGFzdFBhZ2UgPSBGdW5jdGlvbi5wcm90b3R5cGUsXHJcblxyXG4gICAgY2xhc3NOYW1lLFxyXG4gICAgLi4ucHJvcHNcclxufSwgcmVmKSA9PiB7XHJcbiAgICBjb25zdCBjbGFzc05hbWVzID0gY2xhc3NuYW1lcyhjc3NDbGFzc2VzLlBBR0lOQVRJT04sIGNsYXNzTmFtZSk7XHJcblxyXG4gICAgcmV0dXJuIChcclxuICAgICAgICA8ZGl2IHJlZj17cmVmfSBjbGFzc05hbWU9e2NsYXNzTmFtZXN9IHsuLi5wcm9wc30+XHJcbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXtjc3NDbGFzc2VzLlBBR0lOQVRJT05fVFJBSUxJTkd9PlxyXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9e2Nzc0NsYXNzZXMuUEFHSU5BVElPTl9ST1dTX1BFUl9QQUdFfT5cclxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17Y3NzQ2xhc3Nlcy5QQUdJTkFUSU9OX1JPV1NfUEVSX1BBR0VfTEFCRUx9PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICDQoNGP0LTQvtCyINC90LAg0YHRgtGALlxyXG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PlxyXG5cclxuICAgICAgICAgICAgICAgICAgICA8U2VsZWN0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT17Y3NzQ2xhc3Nlcy5QQUdJTkFUSU9OX1JPV1NfUEVSX1BBR0VfU0VMRUNUfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zPXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFsxMCwgMjUsIDUwLCAxMDBdLm1hcCh2YWx1ZSA9PiAoe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleTogdmFsdWUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dDogdmFsdWUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9zZWxlY3RlZDogdmFsdWUgPT09IHJvd3NQZXJQYWdlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIC8+XHJcbiAgICAgICAgICAgICAgICA8L2Rpdj5cclxuXHJcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17Y3NzQ2xhc3Nlcy5QQUdJTkFUSU9OX05BVklHQVRJT059PlxyXG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXtjc3NDbGFzc2VzLlBBR0lOQVRJT05fVE9UQUx9PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB7Y3VycmVudFBhZ2V94oCRe3Jvd3NQZXJQYWdlfSDQuNC3IHt0b3RhbENvdW50fVxyXG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PlxyXG5cclxuICAgICAgICAgICAgICAgICAgICA8SWNvbkJ1dHRvblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU9e2Nzc0NsYXNzZXMuUEFHSU5BVElPTl9CVVRUT059XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGljb249XCJmaXJzdF9wYWdlXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgb25DbGljaz17b25GaXJzdFBhZ2V9XHJcbiAgICAgICAgICAgICAgICAgICAgLz5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgPEljb25CdXR0b25cclxuICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPXtjc3NDbGFzc2VzLlBBR0lOQVRJT05fQlVUVE9OfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpY29uPVwiY2hldnJvbl9sZWZ0XCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgb25DbGljaz17b25QcmV2UGFnZX1cclxuICAgICAgICAgICAgICAgICAgICAvPlxyXG5cclxuICAgICAgICAgICAgICAgICAgICA8SWNvbkJ1dHRvblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU9e2Nzc0NsYXNzZXMuUEFHSU5BVElPTl9CVVRUT059XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGljb249XCJjaGV2cm9uX3JpZ2h0XCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgb25DbGljaz17b25OZXh0UGFnZX1cclxuICAgICAgICAgICAgICAgICAgICAvPlxyXG5cclxuICAgICAgICAgICAgICAgICAgICA8SWNvbkJ1dHRvblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU9e2Nzc0NsYXNzZXMuUEFHSU5BVElPTl9CVVRUT059XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGljb249XCJsYXN0X3BhZ2VcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBvbkNsaWNrPXtvbkxhc3RQYWdlfVxyXG4gICAgICAgICAgICAgICAgICAgIC8+XHJcbiAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgPC9kaXY+XHJcbiAgICApO1xyXG59KTtcclxuXHJcbkRhdGFUYWJsZVBhZ2luYXRpb24uZGlzcGxheU5hbWUgPSAnTURDRGF0YVRhYmxlUGFnaW5hdGlvbic7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBEYXRhVGFibGVQYWdpbmF0aW9uOyIsImltcG9ydCB7IGZvcndhcmRSZWYgfSBmcm9tICdyZWFjdCc7XHJcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XHJcbmltcG9ydCBjbGFzc25hbWVzIGZyb20gJ2NsYXNzbmFtZXMnO1xyXG5cclxuaW1wb3J0IERhdGFUYWJsZVByb2dyZXNzSW5kaWNhdG9yIGZyb20gJy4vRGF0YVRhYmxlUHJvZ3Jlc3NJbmRpY2F0b3InO1xyXG5pbXBvcnQgRGF0YVRhYmxlUGFnaW5hdGlvbiBmcm9tICcuL0RhdGFUYWJsZVBhZ2luYXRpb24nO1xyXG5pbXBvcnQgeyBjc3NDbGFzc2VzIH0gZnJvbSAnLi9jb25zdGFudHMnO1xyXG5cclxuY29uc3QgRGF0YVRhYmxlID0gZm9yd2FyZFJlZigoe1xyXG4gICAgc3RpY2t5SGVhZGVyID0gZmFsc2UsXHJcbiAgICBpblByb2dyZXNzID0gZmFsc2UsXHJcbiAgICBwYWdpbmF0aW9uLFxyXG5cclxuICAgIGNsYXNzTmFtZSxcclxuICAgIGNoaWxkcmVuLFxyXG4gICAgLi4ucHJvcHNcclxufSwgcmVmKSA9PiB7XHJcbiAgICBjb25zdCBjbGFzc05hbWVzID0gY2xhc3NuYW1lcyhjc3NDbGFzc2VzLlJPT1QsIHtcclxuICAgICAgICBbY3NzQ2xhc3Nlcy5TVElDS1lfSEVBREVSXTogc3RpY2t5SGVhZGVyLFxyXG4gICAgICAgIFtjc3NDbGFzc2VzLklOX1BST0dSRVNTXTogaW5Qcm9ncmVzc1xyXG4gICAgfSwgY2xhc3NOYW1lKTtcclxuXHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAgIDxkaXYgcmVmPXtyZWZ9IGNsYXNzTmFtZT17Y2xhc3NOYW1lc30gey4uLnByb3BzfT5cclxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9e2Nzc0NsYXNzZXMuVEFCTEVfQ09OVEFJTkVSfT5cclxuICAgICAgICAgICAgICAgIDx0YWJsZSBjbGFzc05hbWU9e2Nzc0NsYXNzZXMuVEFCTEV9PlxyXG4gICAgICAgICAgICAgICAgICAgIHtjaGlsZHJlbn1cclxuICAgICAgICAgICAgICAgIDwvdGFibGU+XHJcbiAgICAgICAgICAgIDwvZGl2PlxyXG5cclxuICAgICAgICAgICAge2luUHJvZ3Jlc3MgJiZcclxuICAgICAgICAgICAgICAgIDxEYXRhVGFibGVQcm9ncmVzc0luZGljYXRvciAvPlxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB7cGFnaW5hdGlvbiAmJlxyXG4gICAgICAgICAgICAgICAgPERhdGFUYWJsZVBhZ2luYXRpb24gey4uLnBhZ2luYXRpb259IC8+XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICA8L2Rpdj5cclxuICAgICk7XHJcbn0pO1xyXG5cclxuRGF0YVRhYmxlLmRpc3BsYXlOYW1lID0gJ01EQ0RhdGFUYWJsZSc7XHJcblxyXG5EYXRhVGFibGUucHJvcFR5cGVzID0ge1xyXG4gICAgc3RpY2t5SGVhZGVyOiBQcm9wVHlwZXMuYm9vbCxcclxuICAgIGluUHJvZ3Jlc3M6IFByb3BUeXBlcy5ib29sXHJcbn07XHJcblxyXG5leHBvcnQgZGVmYXVsdCBEYXRhVGFibGU7IiwiaW1wb3J0IHsgZm9yd2FyZFJlZiB9IGZyb20gJ3JlYWN0JztcclxuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcclxuaW1wb3J0IGNsYXNzbmFtZXMgZnJvbSAnY2xhc3NuYW1lcyc7XHJcblxyXG5pbXBvcnQgeyBDbG9uZSB9IGZyb20gJy4uL2NvbXBvbmVudCc7XHJcblxyXG5pbXBvcnQgeyBjc3NDbGFzc2VzIH0gZnJvbSAnLi9jb25zdGFudHMnO1xyXG5cclxuY29uc3QgRGF0YVRhYmxlQ2VsbCA9IGZvcndhcmRSZWYoKHtcclxuICAgIGNoZWNrYm94ID0gZmFsc2UsXHJcbiAgICBudW1lcmljID0gZmFsc2UsXHJcblxyXG4gICAgZWxlbWVudDogRWxlbWVudCA9ICd0ZCcsXHJcbiAgICBzY29wZSxcclxuICAgIGNsYXNzTmFtZSxcclxuICAgIGNoaWxkcmVuLFxyXG4gICAgLi4ucHJvcHNcclxufSwgcmVmKSA9PiB7XHJcbiAgICBjb25zdCBjbGFzc05hbWVzID0gY2xhc3NuYW1lcyhjc3NDbGFzc2VzLkNFTEwsIHtcclxuICAgICAgICBbY3NzQ2xhc3Nlcy5DRUxMX0NIRUNLQk9YXTogY2hlY2tib3gsXHJcbiAgICAgICAgW2Nzc0NsYXNzZXMuQ0VMTF9OVU1FUklDXTogbnVtZXJpY1xyXG4gICAgfSwgY2xhc3NOYW1lKTtcclxuXHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAgIDxFbGVtZW50IHJlZj17cmVmfSBjbGFzc05hbWU9e2NsYXNzTmFtZXN9IHNjb3BlPXtzY29wZX0gey4uLnByb3BzfT5cclxuICAgICAgICAgICAge2NoZWNrYm94ID9cclxuICAgICAgICAgICAgICAgIDxDbG9uZVxyXG4gICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudD17Y2hpbGRyZW59XHJcbiAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPXtjc3NDbGFzc2VzLlJPV19DSEVDS0JPWH1cclxuICAgICAgICAgICAgICAgIC8+XHJcbiAgICAgICAgICAgICAgICA6XHJcbiAgICAgICAgICAgICAgICBjaGlsZHJlblxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgPC9FbGVtZW50PlxyXG4gICAgKTtcclxufSk7XHJcblxyXG5EYXRhVGFibGVDZWxsLmRpc3BsYXlOYW1lID0gJ01EQ0RhdGFUYWJsZUNlbGwnO1xyXG5cclxuRGF0YVRhYmxlQ2VsbC5wcm9wVHlwZXMgPSB7XHJcbiAgICBjaGVja2JveDogUHJvcFR5cGVzLmJvb2wsXHJcbiAgICBudW1lcmljOiBQcm9wVHlwZXMuYm9vbFxyXG59O1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgRGF0YVRhYmxlQ2VsbDsiLCJpbXBvcnQgeyBmb3J3YXJkUmVmIH0gZnJvbSAncmVhY3QnO1xyXG5pbXBvcnQgY2xhc3NuYW1lcyBmcm9tICdjbGFzc25hbWVzJztcclxuXHJcbmltcG9ydCB7IGNzc0NsYXNzZXMgfSBmcm9tICcuL2NvbnN0YW50cyc7XHJcblxyXG5jb25zdCBEYXRhVGFibGVDb250ZW50ID0gZm9yd2FyZFJlZigoeyBjbGFzc05hbWUsIC4uLnByb3BzIH0sIHJlZikgPT4ge1xyXG4gICAgY29uc3QgY2xhc3NOYW1lcyA9IGNsYXNzbmFtZXMoY3NzQ2xhc3Nlcy5DT05URU5ULCBjbGFzc05hbWUpO1xyXG5cclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgPHRib2R5IHJlZj17cmVmfSBjbGFzc05hbWU9e2NsYXNzTmFtZXN9IHsuLi5wcm9wc30gLz5cclxuICAgICk7XHJcbn0pO1xyXG5cclxuRGF0YVRhYmxlQ29udGVudC5kaXNwbGF5TmFtZSA9ICdNRENEYXRhVGFibGVDb250ZW50JztcclxuXHJcbmV4cG9ydCBkZWZhdWx0IERhdGFUYWJsZUNvbnRlbnQ7IiwiaW1wb3J0IHsgZm9yd2FyZFJlZiB9IGZyb20gJ3JlYWN0JztcclxuaW1wb3J0IGNsYXNzbmFtZXMgZnJvbSAnY2xhc3NuYW1lcyc7XHJcblxyXG5pbXBvcnQgeyBjc3NDbGFzc2VzIH0gZnJvbSAnLi9jb25zdGFudHMnO1xyXG5cclxuY29uc3QgRGF0YVRhYmxlRm9vdGVyID0gZm9yd2FyZFJlZigoeyBjbGFzc05hbWUsIC4uLnByb3BzIH0sIHJlZikgPT4ge1xyXG4gICAgY29uc3QgY2xhc3NOYW1lcyA9IGNsYXNzbmFtZXMoY3NzQ2xhc3Nlcy5GT09URVIsIGNsYXNzTmFtZSk7XHJcblxyXG4gICAgcmV0dXJuIChcclxuICAgICAgICA8dGZvb3QgcmVmPXtyZWZ9IGNsYXNzTmFtZT17Y2xhc3NOYW1lc30gey4uLnByb3BzfSAvPlxyXG4gICAgKTtcclxufSk7XHJcblxyXG5EYXRhVGFibGVGb290ZXIuZGlzcGxheU5hbWUgPSAnTURDRGF0YVRhYmxlRm9vdGVyJztcclxuXHJcbmV4cG9ydCBkZWZhdWx0IERhdGFUYWJsZUZvb3RlcjsiLCJpbXBvcnQgeyBmb3J3YXJkUmVmIH0gZnJvbSAncmVhY3QnO1xyXG5pbXBvcnQgY2xhc3NuYW1lcyBmcm9tICdjbGFzc25hbWVzJztcclxuXHJcbmltcG9ydCB7IGNzc0NsYXNzZXMgfSBmcm9tICcuL2NvbnN0YW50cyc7XHJcblxyXG5jb25zdCBEYXRhVGFibGVIZWFkZXIgPSBmb3J3YXJkUmVmKCh7IGNsYXNzTmFtZSwgLi4ucHJvcHMgfSwgcmVmKSA9PiB7XHJcbiAgICBjb25zdCBjbGFzc05hbWVzID0gY2xhc3NuYW1lcyhjc3NDbGFzc2VzLkhFQURFUiwgY2xhc3NOYW1lKTtcclxuXHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAgIDx0aGVhZCByZWY9e3JlZn0gY2xhc3NOYW1lPXtjbGFzc05hbWVzfSB7Li4ucHJvcHN9IC8+XHJcbiAgICApO1xyXG59KTtcclxuXHJcbkRhdGFUYWJsZUhlYWRlci5kaXNwbGF5TmFtZSA9ICdNRENEYXRhVGFibGVIZWFkZXInO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgRGF0YVRhYmxlSGVhZGVyOyIsImltcG9ydCB7IGZvcndhcmRSZWYsIHVzZUNhbGxiYWNrIH0gZnJvbSAncmVhY3QnO1xyXG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xyXG5pbXBvcnQgY2xhc3NuYW1lcyBmcm9tICdjbGFzc25hbWVzJztcclxuXHJcbmltcG9ydCB7IENsb25lIH0gZnJvbSAnLi4vY29tcG9uZW50JztcclxuaW1wb3J0IEljb25CdXR0b24gZnJvbSAnLi4vaWNvbi1idXR0b24nO1xyXG5cclxuaW1wb3J0IHsgY3NzQ2xhc3NlcyB9IGZyb20gJy4vY29uc3RhbnRzJztcclxuXHJcbmNvbnN0IERhdGFUYWJsZUhlYWRlckNlbGwgPSBmb3J3YXJkUmVmKCh7XHJcbiAgICB2YWx1ZSxcclxuICAgIGxhYmVsLFxyXG4gICAgY2hlY2tib3ggPSBmYWxzZSxcclxuICAgIG51bWVyaWMgPSBmYWxzZSxcclxuICAgIHNvcnQsXHJcbiAgICBzb3J0SWNvbkJ1dHRvbiA9ICdhcnJvd191cHdhcmQnLFxyXG4gICAgb25Tb3J0ID0gRnVuY3Rpb24ucHJvdG90eXBlLFxyXG5cclxuICAgIGVsZW1lbnQ6IEVsZW1lbnQgPSAndGgnLFxyXG4gICAgcm9sZSA9ICdjb2x1bW5oZWFkZXInLFxyXG4gICAgc2NvcGUgPSAnY29sJyxcclxuICAgIGNsYXNzTmFtZSxcclxuICAgIGNoaWxkcmVuID0gbGFiZWwsXHJcbiAgICAuLi5wcm9wc1xyXG59LCByZWYpID0+IHtcclxuICAgIGNvbnN0IGhhbmRsZVNvcnRJY29uQ2xpY2sgPSB1c2VDYWxsYmFjaygoKSA9PiB7XHJcbiAgICAgICAgb25Tb3J0KHsgbGFiZWwsIHZhbHVlIH0pO1xyXG4gICAgfSwgW2xhYmVsLCB2YWx1ZSwgb25Tb3J0XSk7XHJcblxyXG4gICAgY29uc3Qgd2l0aFNvcnQgPSB0eXBlb2Ygc29ydCA9PT0gJ251bWJlcic7XHJcblxyXG4gICAgY29uc3QgY2xhc3NOYW1lcyA9IGNsYXNzbmFtZXMoY3NzQ2xhc3Nlcy5IRUFERVJfQ0VMTCwge1xyXG4gICAgICAgIFtjc3NDbGFzc2VzLkhFQURFUl9DRUxMX0NIRUNLQk9YXTogY2hlY2tib3gsXHJcbiAgICAgICAgW2Nzc0NsYXNzZXMuSEVBREVSX0NFTExfTlVNRVJJQ106IG51bWVyaWMsXHJcbiAgICAgICAgW2Nzc0NsYXNzZXMuSEVBREVSX0NFTExfV0lUSF9TT1JUXTogd2l0aFNvcnQsXHJcbiAgICAgICAgW2Nzc0NsYXNzZXMuSEVBREVSX0NFTExfU09SVEVEXTogc29ydCA9PT0gMSB8fCBzb3J0ID09PSAtMSxcclxuICAgICAgICBbY3NzQ2xhc3Nlcy5IRUFERVJfQ0VMTF9TT1JURURfREVTQ106IHNvcnQgPT09IC0xXHJcbiAgICB9LCBjbGFzc05hbWUpO1xyXG5cclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgPEVsZW1lbnRcclxuICAgICAgICAgICAgcmVmPXtyZWZ9XHJcbiAgICAgICAgICAgIGNsYXNzTmFtZT17Y2xhc3NOYW1lc31cclxuICAgICAgICAgICAgcm9sZT17cm9sZX1cclxuICAgICAgICAgICAgc2NvcGU9e3Njb3BlfVxyXG4gICAgICAgICAgICB7Li4ucHJvcHN9XHJcbiAgICAgICAgPlxyXG4gICAgICAgICAgICB7d2l0aFNvcnQgP1xyXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9e2Nzc0NsYXNzZXMuSEVBREVSX0NFTExfV1JBUFBFUn0+XHJcbiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9e2Nzc0NsYXNzZXMuSEVBREVSX0NFTExfTEFCRUx9PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB7Y2hpbGRyZW59XHJcbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIDxDbG9uZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb21wb25lbnQ9e3NvcnRJY29uQnV0dG9ufVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmYWxsYmFjaz17SWNvbkJ1dHRvbn1cclxuICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPXtjc3NDbGFzc2VzLlNPUlRfSUNPTl9CVVRUT059XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2xpY2s9e2hhbmRsZVNvcnRJY29uQ2xpY2t9XHJcbiAgICAgICAgICAgICAgICAgICAgLz5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9e2Nzc0NsYXNzZXMuU09SVF9TVEFUVVNfTEFCRUx9IGFyaWEtaGlkZGVuPVwidHJ1ZVwiIC8+XHJcbiAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgICAgIDpcclxuICAgICAgICAgICAgICAgIChjaGVja2JveCA/XHJcbiAgICAgICAgICAgICAgICAgICAgPENsb25lXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudD17Y2hpbGRyZW59XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT17Y3NzQ2xhc3Nlcy5IRUFERVJfUk9XX0NIRUNLQk9YfVxyXG4gICAgICAgICAgICAgICAgICAgIC8+XHJcbiAgICAgICAgICAgICAgICAgICAgOlxyXG4gICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuXHJcbiAgICAgICAgICAgICAgICApXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICA8L0VsZW1lbnQ+XHJcbiAgICApO1xyXG59KTtcclxuXHJcbkRhdGFUYWJsZUhlYWRlckNlbGwuZGlzcGxheU5hbWUgPSAnTURDRGF0YVRhYmxlSGVhZGVyQ2VsbCc7XHJcblxyXG5EYXRhVGFibGVIZWFkZXJDZWxsLnByb3BUeXBlcyA9IHtcclxuICAgIHZhbHVlOiBQcm9wVHlwZXMuYW55LFxyXG4gICAgbGFiZWw6IFByb3BUeXBlcy5zdHJpbmcsXHJcbiAgICBudW1lcmljOiBQcm9wVHlwZXMuYm9vbCxcclxuICAgIGNoZWNrYm94OiBQcm9wVHlwZXMuYm9vbCxcclxuICAgIHNvcnQ6IFByb3BUeXBlcy5vbmVPZihbLTEsIDAsIDFdKSxcclxuICAgIHNvcnRJY29uQnV0dG9uOiBQcm9wVHlwZXMubm9kZSxcclxuICAgIG9uU29ydDogUHJvcFR5cGVzLmZ1bmNcclxufTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IERhdGFUYWJsZUhlYWRlckNlbGw7IiwiaW1wb3J0IHsgZm9yd2FyZFJlZiB9IGZyb20gJ3JlYWN0JztcclxuaW1wb3J0IGNsYXNzbmFtZXMgZnJvbSAnY2xhc3NuYW1lcyc7XHJcblxyXG5pbXBvcnQgeyBjc3NDbGFzc2VzIH0gZnJvbSAnLi9jb25zdGFudHMnO1xyXG5cclxuY29uc3QgRGF0YVRhYmxlSGVhZGVyUm93ID0gZm9yd2FyZFJlZigoeyBjbGFzc05hbWUsIC4uLnByb3BzIH0sIHJlZikgPT4ge1xyXG4gICAgY29uc3QgY2xhc3NOYW1lcyA9IGNsYXNzbmFtZXMoY3NzQ2xhc3Nlcy5IRUFERVJfUk9XLCBjbGFzc05hbWUpO1xyXG5cclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgPHRyIHJlZj17cmVmfSBjbGFzc05hbWU9e2NsYXNzTmFtZXN9IHsuLi5wcm9wc30gLz5cclxuICAgICk7XHJcbn0pO1xyXG5cclxuRGF0YVRhYmxlSGVhZGVyUm93LmRpc3BsYXlOYW1lID0gJ01EQ0RhdGFUYWJsZUhlYWRlclJvdyc7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBEYXRhVGFibGVIZWFkZXJSb3c7IiwiaW1wb3J0IHsgZm9yd2FyZFJlZiB9IGZyb20gJ3JlYWN0JztcclxuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcclxuaW1wb3J0IGNsYXNzbmFtZXMgZnJvbSAnY2xhc3NuYW1lcyc7XHJcblxyXG5pbXBvcnQgeyBjc3NDbGFzc2VzIH0gZnJvbSAnLi9jb25zdGFudHMnO1xyXG5cclxuY29uc3QgRGF0YVRhYmxlUm93ID0gZm9yd2FyZFJlZigoe1xyXG4gICAgc2VsZWN0ZWQgPSBmYWxzZSxcclxuXHJcbiAgICBjbGFzc05hbWUsXHJcbiAgICAuLi5wcm9wc1xyXG59LCByZWYpID0+IHtcclxuICAgIGNvbnN0IGNsYXNzTmFtZXMgPSBjbGFzc25hbWVzKGNzc0NsYXNzZXMuUk9XLCB7XHJcbiAgICAgICAgW2Nzc0NsYXNzZXMuUk9XX1NFTEVDVEVEXTogc2VsZWN0ZWRcclxuICAgIH0sIGNsYXNzTmFtZSk7XHJcblxyXG4gICAgcmV0dXJuIChcclxuICAgICAgICA8dHIgcmVmPXtyZWZ9IGNsYXNzTmFtZT17Y2xhc3NOYW1lc30gey4uLnByb3BzfSAvPlxyXG4gICAgKTtcclxufSk7XHJcblxyXG5EYXRhVGFibGVSb3cuZGlzcGxheU5hbWUgPSAnTURDRGF0YVRhYmxlUm93JztcclxuXHJcbkRhdGFUYWJsZVJvdy5wcm9wVHlwZXMgPSB7XHJcbiAgICBzZWxlY3RlZDogUHJvcFR5cGVzLmJvb2xcclxufTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IERhdGFUYWJsZVJvdzsiLCJpbXBvcnQgRGF0YVRhYmxlIGZyb20gJy4vRGF0YVRhYmxlJztcclxuaW1wb3J0IERhdGFUYWJsZUNlbGwgZnJvbSAnLi9EYXRhVGFibGVDZWxsJztcclxuaW1wb3J0IERhdGFUYWJsZUNvbnRlbnQgZnJvbSAnLi9EYXRhVGFibGVDb250ZW50JztcclxuaW1wb3J0IERhdGFUYWJsZUZvb3RlciBmcm9tICcuL0RhdGFUYWJsZUZvb3Rlcic7XHJcbmltcG9ydCBEYXRhVGFibGVIZWFkZXIgZnJvbSAnLi9EYXRhVGFibGVIZWFkZXInO1xyXG5pbXBvcnQgRGF0YVRhYmxlSGVhZGVyQ2VsbCBmcm9tICcuL0RhdGFUYWJsZUhlYWRlckNlbGwnO1xyXG5pbXBvcnQgRGF0YVRhYmxlSGVhZGVyUm93IGZyb20gJy4vRGF0YVRhYmxlSGVhZGVyUm93JztcclxuaW1wb3J0IERhdGFUYWJsZVBhZ2luYXRpb24gZnJvbSAnLi9EYXRhVGFibGVQYWdpbmF0aW9uJztcclxuaW1wb3J0IERhdGFUYWJsZVJvdyBmcm9tICcuL0RhdGFUYWJsZVJvdyc7XHJcblxyXG5EYXRhVGFibGUuQ2VsbCA9IERhdGFUYWJsZUNlbGw7XHJcbkRhdGFUYWJsZS5Db250ZW50ID0gRGF0YVRhYmxlQ29udGVudDtcclxuRGF0YVRhYmxlLkZvb3RlciA9IERhdGFUYWJsZUZvb3RlcjtcclxuRGF0YVRhYmxlLkhlYWRlciA9IERhdGFUYWJsZUhlYWRlcjtcclxuRGF0YVRhYmxlLkhlYWRlckNlbGwgPSBEYXRhVGFibGVIZWFkZXJDZWxsO1xyXG5EYXRhVGFibGUuSGVhZGVyUm93ID0gRGF0YVRhYmxlSGVhZGVyUm93O1xyXG5EYXRhVGFibGUuUGFnaW5hdGlvbiA9IERhdGFUYWJsZVBhZ2luYXRpb247XHJcbkRhdGFUYWJsZS5Sb3cgPSBEYXRhVGFibGVSb3c7XHJcblxyXG5leHBvcnQge1xyXG4gICAgRGF0YVRhYmxlIGFzIGRlZmF1bHQsXHJcbiAgICBEYXRhVGFibGVDZWxsLFxyXG4gICAgRGF0YVRhYmxlQ29udGVudCxcclxuICAgIERhdGFUYWJsZUZvb3RlcixcclxuICAgIERhdGFUYWJsZUhlYWRlcixcclxuICAgIERhdGFUYWJsZUhlYWRlckNlbGwsXHJcbiAgICBEYXRhVGFibGVIZWFkZXJSb3csXHJcbiAgICBEYXRhVGFibGVQYWdpbmF0aW9uLFxyXG4gICAgRGF0YVRhYmxlUm93XHJcbn07IiwiZXhwb3J0IGNvbnN0IG51bWJlcnMgPSB7XHJcbiAgICBESUFMT0dfQU5JTUFUSU9OX09QRU5fVElNRV9NUzogMTUwLFxyXG4gICAgRElBTE9HX0FOSU1BVElPTl9DTE9TRV9USU1FX01TOiA3NSxcclxuICAgIERFRkFVTFRfQUNUSU9OU19IRUlHSFQ6IDUyXHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgY3NzQ2xhc3NlcyA9IHtcclxuICAgIFJPT1Q6ICdtZGMtZGlhbG9nJyxcclxuICAgIEhFQURFUjogJ21kYy1kaWFsb2dfX2hlYWRlcicsXHJcbiAgICBUSVRMRTogJ21kYy1kaWFsb2dfX3RpdGxlJyxcclxuICAgIENMT1NFOiAnbWRjLWRpYWxvZ19fY2xvc2UnLFxyXG4gICAgQ09OVEVOVDogJ21kYy1kaWFsb2dfX2NvbnRlbnQnLFxyXG4gICAgQ09OVEFJTkVSOiAnbWRjLWRpYWxvZ19fY29udGFpbmVyJyxcclxuICAgIEFDVElPTlM6ICdtZGMtZGlhbG9nX19hY3Rpb25zJyxcclxuICAgIEJVVFRPTjogJ21kYy1kaWFsb2dfX2J1dHRvbicsXHJcbiAgICBTVVJGQUNFOiAnbWRjLWRpYWxvZ19fc3VyZmFjZScsXHJcbiAgICBTQ1JJTTogJ21kYy1kaWFsb2dfX3NjcmltJyxcclxuXHJcbiAgICBPUEVOOiAnbWRjLWRpYWxvZy0tb3BlbicsXHJcbiAgICBPUEVOSU5HOiAnbWRjLWRpYWxvZy0tb3BlbmluZycsXHJcbiAgICBDTE9TSU5HOiAnbWRjLWRpYWxvZy0tY2xvc2luZycsXHJcbiAgICBGVUxMU0NSRUVOOiAnbWRjLWRpYWxvZy0tZnVsbHNjcmVlbicsXHJcbiAgICBTSEVFVDogJ21kYy1kaWFsb2ctLXNoZWV0JyxcclxuICAgIFNDUk9MTEFCTEU6ICdtZGMtZGlhbG9nLS1zY3JvbGxhYmxlJyxcclxuICAgIFNUQUNLRUQ6ICdtZGMtZGlhbG9nLS1zdGFja2VkJyxcclxuICAgIE5PX0NPTlRFTlRfUEFERElORzogJ21kYy1kaWFsb2ctLW5vLWNvbnRlbnQtcGFkZGluZycsXHJcblxyXG4gICAgU0NST0xMX0RJVklERVJfSEVBREVSOiAnbWRjLWRpYWxvZy1zY3JvbGwtZGl2aWRlci1oZWFkZXInLFxyXG4gICAgU0NST0xMX0RJVklERVJfRk9PVEVSOiAnbWRjLWRpYWxvZy1zY3JvbGwtZGl2aWRlci1mb290ZXInLFxyXG4gICAgU0NST0xMX0xPQ0s6ICdtZGMtZGlhbG9nLXNjcm9sbC1sb2NrJ1xyXG59OyIsImltcG9ydCB7IGZvcndhcmRSZWYgfSBmcm9tICdyZWFjdCc7XHJcblxyXG5pbXBvcnQgeyBDbG9uZSB9IGZyb20gJy4uL2NvbXBvbmVudCc7XHJcbmltcG9ydCBJY29uQnV0dG9uIGZyb20gJy4uL2ljb24tYnV0dG9uJztcclxuXHJcbmltcG9ydCB7IGNzc0NsYXNzZXMgfSBmcm9tICcuL2NvbnN0YW50cyc7XHJcblxyXG5jb25zdCBEaWFsb2dIZWFkZXIgPSBmb3J3YXJkUmVmKCh7XHJcbiAgICB0aXRsZSxcclxuICAgIGNsb3NlSWNvbixcclxuICAgIGZ1bGxzY3JlZW4sXHJcbiAgICBvbkNsb3NlLFxyXG5cclxuICAgIGNoaWxkcmVuLFxyXG4gICAgLi4ucHJvcHNcclxufSwgcmVmKSA9PiB7XHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAgIDxkaXYgcmVmPXtyZWZ9IGNsYXNzTmFtZT17Y3NzQ2xhc3Nlcy5IRUFERVJ9IHsuLi5wcm9wc30+XHJcbiAgICAgICAgICAgIDxDbG9uZVxyXG4gICAgICAgICAgICAgICAgY29tcG9uZW50PXt0aXRsZX1cclxuICAgICAgICAgICAgICAgIGZhbGxiYWNrPVwiaDJcIlxyXG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lPXtjc3NDbGFzc2VzLlRJVExFfVxyXG4gICAgICAgICAgICAvPlxyXG5cclxuICAgICAgICAgICAgeyhmdWxsc2NyZWVuIHx8IGNsb3NlSWNvbikgJiZcclxuICAgICAgICAgICAgICAgIDxDbG9uZVxyXG4gICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudD17Y2xvc2VJY29ufVxyXG4gICAgICAgICAgICAgICAgICAgIGZhbGxiYWNrPXs8SWNvbkJ1dHRvbiBpY29uPVwiY2xvc2VcIiAvPn1cclxuICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU9e2Nzc0NsYXNzZXMuQ0xPU0V9XHJcbiAgICAgICAgICAgICAgICAgICAgb25DbGljaz17b25DbG9zZX1cclxuICAgICAgICAgICAgICAgIC8+XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHtjaGlsZHJlbn1cclxuICAgICAgICA8L2Rpdj5cclxuICAgICk7XHJcbn0pO1xyXG5cclxuRGlhbG9nSGVhZGVyLmRpc3BsYXlOYW1lID0gJ01EQ0RpYWxvZ0hlYWRlcic7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBEaWFsb2dIZWFkZXI7IiwiaW1wb3J0IHsgZm9yd2FyZFJlZiB9IGZyb20gJ3JlYWN0JztcclxuXHJcbmltcG9ydCB7IGNzc0NsYXNzZXMgfSBmcm9tICcuL2NvbnN0YW50cyc7XHJcblxyXG5jb25zdCBEaWFsb2dDb250ZW50ID0gZm9yd2FyZFJlZigocHJvcHMsIHJlZikgPT4ge1xyXG4gICAgcmV0dXJuIChcclxuICAgICAgICA8ZGl2IHJlZj17cmVmfSBjbGFzc05hbWU9e2Nzc0NsYXNzZXMuQ09OVEVOVH0gey4uLnByb3BzfSAvPlxyXG4gICAgKTtcclxufSk7XHJcblxyXG5EaWFsb2dDb250ZW50LmRpc3BsYXlOYW1lID0gJ01EQ0RpYWxvZ0NvbnRlbnQnO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgRGlhbG9nQ29udGVudDsiLCJpbXBvcnQgeyBmb3J3YXJkUmVmIH0gZnJvbSAncmVhY3QnO1xyXG5cclxuaW1wb3J0IHsgQ2xvbmUgfSBmcm9tICcuLi9jb21wb25lbnQnO1xyXG5cclxuaW1wb3J0IHsgY3NzQ2xhc3NlcyB9IGZyb20gJy4vY29uc3RhbnRzJztcclxuXHJcbmNvbnN0IERpYWxvZ0FjdGlvbnMgPSBmb3J3YXJkUmVmKCh7IGNoaWxkcmVuIH0sIHJlZikgPT4ge1xyXG4gICAgcmV0dXJuIChcclxuICAgICAgICA8ZGl2IHJlZj17cmVmfSBjbGFzc05hbWU9e2Nzc0NsYXNzZXMuQUNUSU9OU30+XHJcbiAgICAgICAgICAgIDxDbG9uZVxyXG4gICAgICAgICAgICAgICAgY29tcG9uZW50PXtjaGlsZHJlbn1cclxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZT17Y3NzQ2xhc3Nlcy5CVVRUT059XHJcbiAgICAgICAgICAgIC8+XHJcbiAgICAgICAgPC9kaXY+XHJcbiAgICApO1xyXG59KTtcclxuXHJcbkRpYWxvZ0FjdGlvbnMuZGlzcGxheU5hbWUgPSAnTURDRGlhbG9nQWN0aW9ucyc7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBEaWFsb2dBY3Rpb25zOyIsImltcG9ydCB7IGZvcndhcmRSZWYsIHVzZVJlZiwgdXNlQ2FsbGJhY2ssIHVzZUltcGVyYXRpdmVIYW5kbGUgfSBmcm9tICdyZWFjdCc7XHJcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XHJcbmltcG9ydCBjbGFzc25hbWVzIGZyb20gJ2NsYXNzbmFtZXMnO1xyXG5cclxuaW1wb3J0IHsgY2xvbmUsIENsb25lIH0gZnJvbSAnLi4vY29tcG9uZW50JztcclxuaW1wb3J0IHsgdXNlVXBkYXRlZCwgdXNlVW5tb3VudGVkIH0gZnJvbSAnLi4vaG9va3MnO1xyXG5pbXBvcnQgSWNvbkJ1dHRvbiBmcm9tICcuLi9pY29uLWJ1dHRvbic7XHJcbmltcG9ydCBMYXllciBmcm9tICcuLi9sYXllcic7XHJcblxyXG5pbXBvcnQgeyBudW1iZXJzLCBjc3NDbGFzc2VzIH0gZnJvbSAnLi9jb25zdGFudHMnO1xyXG5pbXBvcnQgRGlhbG9nSGVhZGVyIGZyb20gJy4vRGlhbG9nSGVhZGVyJztcclxuaW1wb3J0IERpYWxvZ0NvbnRlbnQgZnJvbSAnLi9EaWFsb2dDb250ZW50JztcclxuaW1wb3J0IERpYWxvZ0FjdGlvbnMgZnJvbSAnLi9EaWFsb2dBY3Rpb25zJztcclxuXHJcbmNvbnN0IERpYWxvZyA9IGZvcndhcmRSZWYoKHtcclxuICAgIHRpdGxlLFxyXG4gICAgaGVhZGVyLFxyXG4gICAgY29udGVudCxcclxuICAgIGFjdGlvbnMsXHJcbiAgICBjbG9zZUljb24sXHJcbiAgICBvcGVuID0gZmFsc2UsXHJcbiAgICBhcHBlYXIgPSBmYWxzZSxcclxuICAgIGZ1bGxzY3JlZW4gPSBmYWxzZSxcclxuICAgIHBlcnNpc3RlbnQgPSBmYWxzZSxcclxuICAgIHNoZWV0ID0gZmFsc2UsXHJcbiAgICBzdGFja2VkID0gZmFsc2UsXHJcbiAgICBhdXRvU3RhY2tCdXR0b25zID0gZmFsc2UsXHJcbiAgICBub0NvbnRlbnRQYWRkaW5nLFxyXG4gICAgb25DbG9zZSA9IEZ1bmN0aW9uLnByb3RvdHlwZSxcclxuXHJcbiAgICBlbGVtZW50OiBFbGVtZW50ID0gJ2RpdicsXHJcbiAgICBjbGFzc05hbWUsXHJcbiAgICBjaGlsZHJlbiA9IGNvbnRlbnQsXHJcbiAgICAuLi5wcm9wc1xyXG59LCByZWYpID0+IHtcclxuICAgIGNvbnN0IHJvb3RSZWYgPSB1c2VSZWYoKTtcclxuICAgIGNvbnN0IGNvbnRlbnRSZWYgPSB1c2VSZWYoKTtcclxuICAgIGNvbnN0IGFjdGlvbnNSZWYgPSB1c2VSZWYoKTtcclxuXHJcbiAgICB1c2VJbXBlcmF0aXZlSGFuZGxlKHJlZiwgKCkgPT4gcm9vdFJlZi5jdXJyZW50KTtcclxuXHJcbiAgICB1c2VVcGRhdGVkKCgpID0+IHtcclxuICAgICAgICBpZiAocGVyc2lzdGVudCkgcmV0dXJuO1xyXG5cclxuICAgICAgICBmdW5jdGlvbiBoYW5kbGVEb2N1bWVudEtleURvd24oZXZlbnQpIHtcclxuICAgICAgICAgICAgaWYgKGV2ZW50LmtleSA9PT0gJ0VzY2FwZScgfHwgZXZlbnQua2V5Q29kZSA9PT0gMjcpIHtcclxuICAgICAgICAgICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xyXG4gICAgICAgICAgICAgICAgb25DbG9zZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAob3Blbikge1xyXG4gICAgICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgaGFuZGxlRG9jdW1lbnRLZXlEb3duKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdrZXlkb3duJywgaGFuZGxlRG9jdW1lbnRLZXlEb3duKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiAoKSA9PiBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdrZXlkb3duJywgaGFuZGxlRG9jdW1lbnRLZXlEb3duKTtcclxuICAgIH0sIFtvcGVuLCBwZXJzaXN0ZW50LCBvbkNsb3NlXSk7XHJcblxyXG4gICAgdXNlVXBkYXRlZCgoKSA9PiB7XHJcbiAgICAgICAgaWYgKCFjb250ZW50UmVmLmN1cnJlbnQgfHwgIW9wZW4pIHJldHVybjtcclxuXHJcbiAgICAgICAgY29uc3QgY29udGVudEVsZW1lbnQgPSBjb250ZW50UmVmLmN1cnJlbnQ7XHJcbiAgICAgICAgY29uc3Qgc2hvdWxkU2Nyb2xsID0gY29udGVudEVsZW1lbnQuc2Nyb2xsSGVpZ2h0ID4gY29udGVudEVsZW1lbnQub2Zmc2V0SGVpZ2h0O1xyXG5cclxuICAgICAgICBpZiAoc2hvdWxkU2Nyb2xsKSB7XHJcbiAgICAgICAgICAgIHJvb3RSZWYuY3VycmVudC5jbGFzc0xpc3QuYWRkKGNzc0NsYXNzZXMuU0NST0xMQUJMRSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSwgW29wZW5dKTtcclxuXHJcbiAgICB1c2VVcGRhdGVkKCgpID0+IHtcclxuICAgICAgICBpZiAoIWFjdGlvbnNSZWYuY3VycmVudCB8fCAhb3BlbiB8fCAhYXV0b1N0YWNrQnV0dG9ucykgcmV0dXJuO1xyXG5cclxuICAgICAgICBjb25zdCBhY3Rpb25zRWxlbWVudCA9IGFjdGlvbnNSZWYuY3VycmVudDtcclxuXHJcbiAgICAgICAgaWYgKGFjdGlvbnNFbGVtZW50LmNsaWVudEhlaWdodCA+IG51bWJlcnMuREVGQVVMVF9BQ1RJT05TX0hFSUdIVCkge1xyXG4gICAgICAgICAgICByb290UmVmLmN1cnJlbnQuY2xhc3NMaXN0LmFkZChjc3NDbGFzc2VzLlNUQUNLRUQpO1xyXG4gICAgICAgIH1cclxuICAgIH0sIFtvcGVuLCBhdXRvU3RhY2tCdXR0b25zXSk7XHJcblxyXG4gICAgdXNlVXBkYXRlZCgoKSA9PiB7XHJcbiAgICAgICAgaWYgKCFjb250ZW50UmVmLmN1cnJlbnQgfHwgIWZ1bGxzY3JlZW4pIHJldHVybjtcclxuXHJcbiAgICAgICAgY29uc3QgY29udGVudEVsZW1lbnQgPSBjb250ZW50UmVmLmN1cnJlbnQ7XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIGhhbmRsZVNjcm9sbCgpIHtcclxuICAgICAgICAgICAgY29uc3QgaXNTY3JvbGxBdFRvcCA9IGNvbnRlbnRFbGVtZW50LnNjcm9sbFRvcCA9PT0gMDtcclxuICAgICAgICAgICAgY29uc3QgaXNTY3JvbGxBdEJvdHRvbSA9IE1hdGguY2VpbChjb250ZW50RWxlbWVudC5zY3JvbGxIZWlnaHQgLSBjb250ZW50RWxlbWVudC5zY3JvbGxUb3ApID09PSBjb250ZW50RWxlbWVudC5jbGllbnRIZWlnaHQ7XHJcblxyXG4gICAgICAgICAgICByb290UmVmLmN1cnJlbnQuY2xhc3NMaXN0LnRvZ2dsZShjc3NDbGFzc2VzLlNDUk9MTF9ESVZJREVSX0hFQURFUiwgIWlzU2Nyb2xsQXRUb3ApO1xyXG4gICAgICAgICAgICByb290UmVmLmN1cnJlbnQuY2xhc3NMaXN0LnRvZ2dsZShjc3NDbGFzc2VzLlNDUk9MTF9ESVZJREVSX0ZPT1RFUiwgIWlzU2Nyb2xsQXRCb3R0b20pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY29udGVudEVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgaGFuZGxlU2Nyb2xsKTtcclxuXHJcbiAgICAgICAgaWYgKG9wZW4pIHtcclxuICAgICAgICAgICAgaGFuZGxlU2Nyb2xsKCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gKCkgPT4gY29udGVudEVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgaGFuZGxlU2Nyb2xsKTtcclxuICAgIH0sIFtvcGVuLCBmdWxsc2NyZWVuXSk7XHJcblxyXG4gICAgdXNlVW5tb3VudGVkKCgpID0+IHtcclxuICAgICAgICBkb2N1bWVudC5ib2R5LmNsYXNzTGlzdC5yZW1vdmUoY3NzQ2xhc3Nlcy5TQ1JPTExfTE9DSyk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBjb25zdCBoYW5kbGVFbnRlciA9IHVzZUNhbGxiYWNrKCgpID0+IHtcclxuICAgICAgICBkb2N1bWVudC5ib2R5LmNsYXNzTGlzdC5hZGQoY3NzQ2xhc3Nlcy5TQ1JPTExfTE9DSyk7XHJcbiAgICB9LCBbXSk7XHJcblxyXG4gICAgY29uc3QgaGFuZGxlRXhpdGVkID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xyXG4gICAgICAgIGRvY3VtZW50LmJvZHkuY2xhc3NMaXN0LnJlbW92ZShjc3NDbGFzc2VzLlNDUk9MTF9MT0NLKTtcclxuICAgIH0sIFtdKTtcclxuXHJcbiAgICBjb25zdCBoYW5kbGVTY3JpbUNsaWNrID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xyXG4gICAgICAgIGlmIChwZXJzaXN0ZW50KSByZXR1cm47XHJcblxyXG4gICAgICAgIG9uQ2xvc2UoKTtcclxuICAgIH0sIFtwZXJzaXN0ZW50LCBvbkNsb3NlXSk7XHJcblxyXG4gICAgY29uc3QgY2xhc3NOYW1lcyA9IGNsYXNzbmFtZXMoY3NzQ2xhc3Nlcy5ST09ULCB7XHJcbiAgICAgICAgW2Nzc0NsYXNzZXMuRlVMTFNDUkVFTl06IGZ1bGxzY3JlZW4sXHJcbiAgICAgICAgW2Nzc0NsYXNzZXMuU0hFRVRdOiBzaGVldCxcclxuICAgICAgICBbY3NzQ2xhc3Nlcy5TVEFDS0VEXTogc3RhY2tlZCxcclxuICAgICAgICBbY3NzQ2xhc3Nlcy5OT19DT05URU5UX1BBRERJTkddOiBub0NvbnRlbnRQYWRkaW5nXHJcbiAgICB9LCBjbGFzc05hbWUpO1xyXG5cclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgPExheWVyXHJcbiAgICAgICAgICAgIG1vZGFsXHJcbiAgICAgICAgICAgIGluPXtvcGVufVxyXG4gICAgICAgICAgICBhcHBlYXI9e2FwcGVhcn1cclxuICAgICAgICAgICAgdGltZW91dD17e1xyXG4gICAgICAgICAgICAgICAgZW50ZXI6IG51bWJlcnMuRElBTE9HX0FOSU1BVElPTl9PUEVOX1RJTUVfTVMsXHJcbiAgICAgICAgICAgICAgICBleGl0OiBudW1iZXJzLkRJQUxPR19BTklNQVRJT05fQ0xPU0VfVElNRV9NU1xyXG4gICAgICAgICAgICB9fVxyXG4gICAgICAgICAgICBjbGFzc05hbWVzPXt7XHJcbiAgICAgICAgICAgICAgICBhcHBlYXI6IGNzc0NsYXNzZXMuT1BFTklORyxcclxuICAgICAgICAgICAgICAgIGFwcGVhckFjdGl2ZTogY3NzQ2xhc3Nlcy5PUEVOLFxyXG4gICAgICAgICAgICAgICAgZW50ZXI6IGNzc0NsYXNzZXMuT1BFTklORyxcclxuICAgICAgICAgICAgICAgIGVudGVyQWN0aXZlOiBjc3NDbGFzc2VzLk9QRU4sXHJcbiAgICAgICAgICAgICAgICBlbnRlckRvbmU6IGNzc0NsYXNzZXMuT1BFTixcclxuICAgICAgICAgICAgICAgIGV4aXQ6IGNzc0NsYXNzZXMuQ0xPU0lOR1xyXG4gICAgICAgICAgICB9fVxyXG4gICAgICAgICAgICBtb3VudE9uRW50ZXJcclxuICAgICAgICAgICAgdW5tb3VudE9uRXhpdFxyXG4gICAgICAgICAgICBvbkVudGVyPXtoYW5kbGVFbnRlcn1cclxuICAgICAgICAgICAgb25FeGl0ZWQ9e2hhbmRsZUV4aXRlZH1cclxuICAgICAgICA+XHJcbiAgICAgICAgICAgIDxFbGVtZW50XHJcbiAgICAgICAgICAgICAgICByZWY9e3Jvb3RSZWZ9XHJcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU9e2NsYXNzTmFtZXN9XHJcbiAgICAgICAgICAgICAgICB7Li4ucHJvcHN9XHJcbiAgICAgICAgICAgID5cclxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXtjc3NDbGFzc2VzLkNPTlRBSU5FUn0+XHJcbiAgICAgICAgICAgICAgICAgICAgPGRpdlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU9e2Nzc0NsYXNzZXMuU1VSRkFDRX1cclxuICAgICAgICAgICAgICAgICAgICAgICAgcm9sZT1cImFsZXJ0ZGlhbG9nXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgYXJpYS1tb2RhbD1cInRydWVcIlxyXG4gICAgICAgICAgICAgICAgICAgID5cclxuICAgICAgICAgICAgICAgICAgICAgICAge3NoZWV0ICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8Q2xvbmVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21wb25lbnQ9e2Nsb3NlSWNvbn1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmYWxsYmFjaz17PEljb25CdXR0b24gaWNvbj1cImNsb3NlXCIgLz59XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPXtjc3NDbGFzc2VzLkNMT1NFfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2xpY2s9e29uQ2xvc2V9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICB7dGl0bGUgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxEaWFsb2dIZWFkZXJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aXRsZT17dGl0bGV9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xvc2VJY29uPXtjbG9zZUljb259XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnVsbHNjcmVlbj17ZnVsbHNjcmVlbn1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbkNsb3NlPXtvbkNsb3NlfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLz5cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAge2hlYWRlcj8udHlwZSA9PT0gRGlhbG9nSGVhZGVyICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbG9uZShoZWFkZXIsIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmdWxsc2NyZWVuLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2xvc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHtjaGlsZHJlbiAmJiAoY2hpbGRyZW4/LnR5cGUgPT09IERpYWxvZ0NvbnRlbnQgP1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xvbmUoY2hpbGRyZW4sIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWY6IGNvbnRlbnRSZWZcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8RGlhbG9nQ29udGVudCByZWY9e2NvbnRlbnRSZWZ9PntjaGlsZHJlbn08L0RpYWxvZ0NvbnRlbnQ+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICl9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICB7YWN0aW9ucyAmJiAoYWN0aW9ucy50eXBlID09PSBEaWFsb2dBY3Rpb25zID9cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsb25lKGFjdGlvbnMsIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWY6IGFjdGlvbnNSZWZcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8RGlhbG9nQWN0aW9ucyByZWY9e2FjdGlvbnNSZWZ9PnthY3Rpb25zfTwvRGlhbG9nQWN0aW9ucz5cclxuICAgICAgICAgICAgICAgICAgICAgICAgKX1cclxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgICAgIDwvZGl2PlxyXG5cclxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXtjc3NDbGFzc2VzLlNDUklNfSBvbkNsaWNrPXtoYW5kbGVTY3JpbUNsaWNrfSAvPlxyXG4gICAgICAgICAgICA8L0VsZW1lbnQ+XHJcbiAgICAgICAgPC9MYXllcj5cclxuICAgICk7XHJcbn0pO1xyXG5cclxuRGlhbG9nLmRpc3BsYXlOYW1lID0gJ01EQ0RpYWxvZyc7XHJcblxyXG5EaWFsb2cucHJvcFR5cGVzID0ge1xyXG4gICAgdGl0bGU6IFByb3BUeXBlcy5ub2RlLFxyXG4gICAgaGVhZGVyOiBQcm9wVHlwZXMubm9kZSxcclxuICAgIGNvbnRlbnQ6IFByb3BUeXBlcy5ub2RlLFxyXG4gICAgYWN0aW9uczogUHJvcFR5cGVzLm9uZU9mVHlwZShbXHJcbiAgICAgICAgUHJvcFR5cGVzLm5vZGUsXHJcbiAgICAgICAgUHJvcFR5cGVzLmFycmF5T2YoUHJvcFR5cGVzLm5vZGUpXHJcbiAgICBdKSxcclxuICAgIGNsb3NlSWNvbjogUHJvcFR5cGVzLm5vZGUsXHJcbiAgICBvcGVuOiBQcm9wVHlwZXMuYm9vbCxcclxuICAgIGFwcGVhcjogUHJvcFR5cGVzLmJvb2wsXHJcbiAgICBmdWxsc2NyZWVuOiBQcm9wVHlwZXMuYm9vbCxcclxuICAgIHBlcnNpc3RlbnQ6IFByb3BUeXBlcy5ib29sLFxyXG4gICAgc2hlZXQ6IFByb3BUeXBlcy5ib29sLFxyXG4gICAgc3RhY2tlZDogUHJvcFR5cGVzLmJvb2wsXHJcbiAgICBhdXRvU3RhY2tCdXR0b25zOiBQcm9wVHlwZXMuYm9vbCxcclxuICAgIG5vQ29udGVudFBhZGRpbmc6IFByb3BUeXBlcy5ib29sLFxyXG4gICAgb25DbG9zZTogUHJvcFR5cGVzLmZ1bmNcclxufTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IERpYWxvZzsiLCJpbXBvcnQgRGlhbG9nIGZyb20gJy4vRGlhbG9nJztcclxuaW1wb3J0IERpYWxvZ0hlYWRlciBmcm9tICcuL0RpYWxvZ0hlYWRlcic7XHJcbmltcG9ydCBEaWFsb2dDb250ZW50IGZyb20gJy4vRGlhbG9nQ29udGVudCc7XHJcbmltcG9ydCBEaWFsb2dBY3Rpb25zIGZyb20gJy4vRGlhbG9nQWN0aW9ucyc7XHJcblxyXG5EaWFsb2cuSGVhZGVyID0gRGlhbG9nSGVhZGVyO1xyXG5EaWFsb2cuQ29udGVudCA9IERpYWxvZ0NvbnRlbnQ7XHJcbkRpYWxvZy5BY3Rpb25zID0gRGlhbG9nQWN0aW9ucztcclxuXHJcbmV4cG9ydCB7XHJcbiAgICBEaWFsb2cgYXMgZGVmYXVsdCxcclxuICAgIERpYWxvZ0hlYWRlcixcclxuICAgIERpYWxvZ0NvbnRlbnQsXHJcbiAgICBEaWFsb2dBY3Rpb25zXHJcbn07IiwiZXhwb3J0IGNvbnN0IG51bWJlcnMgPSB7XHJcbiAgICBBTklNQVRJT05fRU5URVJfVElNRV9NUzogMjUwLFxyXG4gICAgQU5JTUFUSU9OX0VYSVRfVElNRV9NUzogMjAwXHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgY3NzQ2xhc3NlcyA9IHtcclxuICAgIFJPT1Q6ICdtZGMtZHJhd2VyJyxcclxuICAgIERJU01JU1NJQkxFOiAnbWRjLWRyYXdlci0tZGlzbWlzc2libGUnLFxyXG4gICAgTU9EQUw6ICdtZGMtZHJhd2VyLS1tb2RhbCcsXHJcbiAgICBPUEVOOiAnbWRjLWRyYXdlci0tb3BlbicsXHJcbiAgICBBTklNQVRFOiAnbWRjLWRyYXdlci0tYW5pbWF0ZScsXHJcbiAgICBPUEVOSU5HOiAnbWRjLWRyYXdlci0tb3BlbmluZycsXHJcbiAgICBDTE9TSU5HOiAnbWRjLWRyYXdlci0tY2xvc2luZycsXHJcblxyXG4gICAgQ09OVEVOVDogJ21kYy1kcmF3ZXJfX2NvbnRlbnQnLFxyXG4gICAgSEVBREVSOiAnbWRjLWRyYXdlcl9faGVhZGVyJyxcclxuICAgIFRJVExFOiAnbWRjLWRyYXdlcl9fdGl0bGUnLFxyXG4gICAgU1VCVElUTEU6ICdtZGMtZHJhd2VyX19zdWJ0aXRsZScsXHJcbiAgICBHUkFQSElDOiAnbWRjLWRyYXdlcl9fZ3JhcGhpYycsXHJcblxyXG4gICAgQVBQX0NPTlRFTlQ6ICdtZGMtZHJhd2VyLWFwcC1jb250ZW50JyxcclxuICAgIFNDUklNOiAnbWRjLWRyYXdlci1zY3JpbScsXHJcbn07IiwiaW1wb3J0IHsgZm9yd2FyZFJlZiwgdXNlUmVmLCB1c2VJbXBlcmF0aXZlSGFuZGxlLCB1c2VFZmZlY3QgfSBmcm9tICdyZWFjdCc7XHJcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XHJcbmltcG9ydCBjbGFzc25hbWVzIGZyb20gJ2NsYXNzbmFtZXMnO1xyXG5cclxuaW1wb3J0IExheWVyIGZyb20gJy4uL2xheWVyJztcclxuXHJcbmltcG9ydCB7IG51bWJlcnMsIGNzc0NsYXNzZXMgfSBmcm9tICcuL2NvbnN0YW50cyc7XHJcblxyXG5jb25zdCBEcmF3ZXIgPSBmb3J3YXJkUmVmKCh7XHJcbiAgICBvcGVuID0gZmFsc2UsXHJcbiAgICBhcHBlYXIgPSB0cnVlLFxyXG4gICAgZGlzbWlzc2libGUgPSBmYWxzZSxcclxuICAgIG1vZGFsID0gZmFsc2UsXHJcbiAgICBhcHBDb250ZW50U2VsZWN0b3IsXHJcbiAgICBvbkNsb3NlID0gRnVuY3Rpb24ucHJvdG90eXBlLFxyXG5cclxuICAgIGVsZW1lbnQgPSAnYXNpZGUnLFxyXG4gICAgY29tcG9uZW50OiBFbGVtZW50ID0gZWxlbWVudCxcclxuICAgIGNsYXNzTmFtZSxcclxuICAgIGNoaWxkcmVuLFxyXG4gICAgLi4ucHJvcHNcclxufSwgcmVmKSA9PiB7XHJcbiAgICBjb25zdCByb290UmVmID0gdXNlUmVmKCk7XHJcblxyXG4gICAgdXNlSW1wZXJhdGl2ZUhhbmRsZShyZWYsICgpID0+IHJvb3RSZWYuY3VycmVudCk7XHJcblxyXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgICAgICBpZiAoIWRpc21pc3NpYmxlKSByZXR1cm47XHJcblxyXG4gICAgICAgIGNvbnN0IGFwcENvbnRlbnRFbGVtZW50ID0gYXBwQ29udGVudFNlbGVjdG9yID9cclxuICAgICAgICAgICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvcihhcHBDb250ZW50U2VsZWN0b3IpIDpcclxuICAgICAgICAgICAgcm9vdFJlZi5jdXJyZW50Py5uZXh0RWxlbWVudFNpYmxpbmc7XHJcblxyXG4gICAgICAgIGFwcENvbnRlbnRFbGVtZW50Py5jbGFzc0xpc3QuYWRkKGNzc0NsYXNzZXMuQVBQX0NPTlRFTlQpO1xyXG5cclxuICAgICAgICByZXR1cm4gKCkgPT4ge1xyXG4gICAgICAgICAgICBhcHBDb250ZW50RWxlbWVudD8uY2xhc3NMaXN0LnJlbW92ZShjc3NDbGFzc2VzLkFQUF9DT05URU5UKTtcclxuICAgICAgICB9O1xyXG4gICAgfSwgW2Rpc21pc3NpYmxlLCBhcHBDb250ZW50U2VsZWN0b3JdKTtcclxuXHJcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgICAgIGlmICghbW9kYWwpIHJldHVybjtcclxuXHJcbiAgICAgICAgZnVuY3Rpb24gaGFuZGxlRG9jdW1lbnRLZXlEb3duKGV2ZW50KSB7XHJcbiAgICAgICAgICAgIGlmIChldmVudC5rZXkgJiYgZXZlbnQua2V5ID09PSAnRXNjYXBlJyB8fCBldmVudC5rZXlDb2RlID09PSAyNykge1xyXG4gICAgICAgICAgICAgICAgb25DbG9zZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgaGFuZGxlRG9jdW1lbnRLZXlEb3duKTtcclxuXHJcbiAgICAgICAgcmV0dXJuICgpID0+IGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCBoYW5kbGVEb2N1bWVudEtleURvd24pO1xyXG4gICAgfSwgW21vZGFsLCBvbkNsb3NlXSk7XHJcblxyXG4gICAgY29uc3QgY2xhc3NOYW1lcyA9IGNsYXNzbmFtZXMoY3NzQ2xhc3Nlcy5ST09ULCB7XHJcbiAgICAgICAgW2Nzc0NsYXNzZXMuRElTTUlTU0lCTEVdOiBkaXNtaXNzaWJsZSxcclxuICAgICAgICBbY3NzQ2xhc3Nlcy5NT0RBTF06IG1vZGFsXHJcbiAgICB9LCBjbGFzc05hbWUpO1xyXG5cclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgPExheWVyXHJcbiAgICAgICAgICAgIG1vZGFsPXttb2RhbH1cclxuICAgICAgICAgICAgZml4ZWQ9e21vZGFsfVxyXG4gICAgICAgICAgICBpbj17b3Blbn1cclxuICAgICAgICAgICAgYXBwZWFyPXthcHBlYXJ9XHJcbiAgICAgICAgICAgIHRpbWVvdXQ9e3tcclxuICAgICAgICAgICAgICAgIGVudGVyOiBudW1iZXJzLkFOSU1BVElPTl9FTlRFUl9USU1FX01TLFxyXG4gICAgICAgICAgICAgICAgZXhpdDogbnVtYmVycy5BTklNQVRJT05fRVhJVF9USU1FX01TXHJcbiAgICAgICAgICAgIH19XHJcbiAgICAgICAgICAgIGNsYXNzTmFtZXM9e3tcclxuICAgICAgICAgICAgICAgIGFwcGVhcjogY3NzQ2xhc3Nlcy5PUEVOLFxyXG4gICAgICAgICAgICAgICAgZW50ZXI6IGAke2Nzc0NsYXNzZXMuT1BFTn0gJHtjc3NDbGFzc2VzLkFOSU1BVEV9YCxcclxuICAgICAgICAgICAgICAgIGVudGVyQWN0aXZlOiBgJHtjc3NDbGFzc2VzLk9QRU59ICR7Y3NzQ2xhc3Nlcy5PUEVOSU5HfWAsXHJcbiAgICAgICAgICAgICAgICBlbnRlckRvbmU6IGNzc0NsYXNzZXMuT1BFTixcclxuICAgICAgICAgICAgICAgIGV4aXQ6IGAke2Nzc0NsYXNzZXMuT1BFTn0gJHtjc3NDbGFzc2VzLkNMT1NJTkd9YCxcclxuICAgICAgICAgICAgICAgIGV4aXRBY3RpdmU6IGNzc0NsYXNzZXMuQ0xPU0lOR1xyXG4gICAgICAgICAgICB9fVxyXG4gICAgICAgICAgICBtb3VudE9uRW50ZXI9e21vZGFsfVxyXG4gICAgICAgICAgICB1bm1vdW50T25FeGl0PXttb2RhbH1cclxuICAgICAgICA+XHJcbiAgICAgICAgICAgIDw+XHJcbiAgICAgICAgICAgICAgICA8RWxlbWVudFxyXG4gICAgICAgICAgICAgICAgICAgIHJlZj17cm9vdFJlZn1cclxuICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU9e2NsYXNzTmFtZXN9XHJcbiAgICAgICAgICAgICAgICAgICAgey4uLnByb3BzfVxyXG4gICAgICAgICAgICAgICAgPlxyXG4gICAgICAgICAgICAgICAgICAgIHtjaGlsZHJlbn1cclxuICAgICAgICAgICAgICAgIDwvRWxlbWVudD5cclxuXHJcbiAgICAgICAgICAgICAgICB7bW9kYWwgJiZcclxuICAgICAgICAgICAgICAgICAgICA8ZGl2XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT17Y3NzQ2xhc3Nlcy5TQ1JJTX1cclxuICAgICAgICAgICAgICAgICAgICAgICAgb25DbGljaz17b25DbG9zZX1cclxuICAgICAgICAgICAgICAgICAgICAvPlxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICA8Lz5cclxuICAgICAgICA8L0xheWVyPlxyXG4gICAgKTtcclxufSk7XHJcblxyXG5EcmF3ZXIuZGlzcGxheU5hbWUgPSAnTURDRHJhd2VyJztcclxuXHJcbkRyYXdlci5wcm9wVHlwZXMgPSB7XHJcbiAgICBvcGVuOiBQcm9wVHlwZXMuYm9vbCxcclxuICAgIGFwcGVhcjogUHJvcFR5cGVzLmJvb2wsXHJcbiAgICBkaXNtaXNzaWJsZTogUHJvcFR5cGVzLmJvb2wsXHJcbiAgICBtb2RhbDogUHJvcFR5cGVzLmJvb2wsXHJcbiAgICBhcHBDb250ZW50U2VsZWN0b3I6IFByb3BUeXBlcy5zdHJpbmcsXHJcbiAgICBvbkNsb3NlOiBQcm9wVHlwZXMuZnVuY1xyXG59O1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgRHJhd2VyOyIsImltcG9ydCB7IGZvcndhcmRSZWYgfSBmcm9tICdyZWFjdCc7XHJcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XHJcblxyXG5pbXBvcnQgeyBDbG9uZSB9IGZyb20gJy4uL2NvbXBvbmVudCc7XHJcblxyXG5pbXBvcnQgeyBjc3NDbGFzc2VzIH0gZnJvbSAnLi9jb25zdGFudHMnO1xyXG5cclxuY29uc3QgRHJhd2VySGVhZGVyID0gZm9yd2FyZFJlZigoe1xyXG4gICAgdGl0bGUsXHJcbiAgICBzdWJ0aXRsZSxcclxuICAgIGdyYXBoaWMsXHJcblxyXG4gICAgZWxlbWVudDogRWxlbWVudCA9ICdoZWFkZXInLFxyXG4gICAgY2hpbGRyZW4sXHJcbiAgICAuLi5wcm9wc1xyXG59LCByZWYpID0+IHtcclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgPEVsZW1lbnQgcmVmPXtyZWZ9IGNsYXNzTmFtZT17Y3NzQ2xhc3Nlcy5IRUFERVJ9IHsuLi5wcm9wc30+XHJcbiAgICAgICAgICAgIHtncmFwaGljICYmXHJcbiAgICAgICAgICAgICAgICA8Q2xvbmVcclxuICAgICAgICAgICAgICAgICAgICBjb21wb25lbnQ9e2dyYXBoaWN9XHJcbiAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPXtjc3NDbGFzc2VzLkdSQVBISUN9XHJcbiAgICAgICAgICAgICAgICAvPlxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB7dGl0bGUgJiZcclxuICAgICAgICAgICAgICAgIDxDbG9uZVxyXG4gICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudD17dGl0bGV9XHJcbiAgICAgICAgICAgICAgICAgICAgZmFsbGJhY2s9XCJoM1wiXHJcbiAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPXtjc3NDbGFzc2VzLlRJVExFfVxyXG4gICAgICAgICAgICAgICAgLz5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAge3N1YnRpdGxlICYmXHJcbiAgICAgICAgICAgICAgICA8Q2xvbmVcclxuICAgICAgICAgICAgICAgICAgICBjb21wb25lbnQ9e3N1YnRpdGxlfVxyXG4gICAgICAgICAgICAgICAgICAgIGZhbGxiYWNrPVwiaDZcIlxyXG4gICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT17Y3NzQ2xhc3Nlcy5TVUJUSVRMRX1cclxuICAgICAgICAgICAgICAgIC8+XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHtjaGlsZHJlbn1cclxuICAgICAgICA8L0VsZW1lbnQ+XHJcbiAgICApO1xyXG59KTtcclxuXHJcbkRyYXdlckhlYWRlci5kaXNwbGF5TmFtZSA9ICdNRENEcmF3ZXJIZWFkZXInO1xyXG5cclxuRHJhd2VySGVhZGVyLnByb3BUeXBlcyA9IHtcclxuICAgIHRpdGxlOiBQcm9wVHlwZXMubm9kZSxcclxuICAgIHN1YnRpdGxlOiBQcm9wVHlwZXMubm9kZSxcclxuICAgIGdyYXBoaWM6IFByb3BUeXBlcy5lbGVtZW50XHJcbn07XHJcblxyXG5leHBvcnQgZGVmYXVsdCBEcmF3ZXJIZWFkZXI7IiwiaW1wb3J0IHsgZm9yd2FyZFJlZiB9IGZyb20gJ3JlYWN0JztcclxuXHJcbmltcG9ydCB7IGNzc0NsYXNzZXMgfSBmcm9tICcuL2NvbnN0YW50cyc7XHJcblxyXG5jb25zdCBEcmF3ZXJDb250ZW50ID0gZm9yd2FyZFJlZigoe1xyXG4gICAgZWxlbWVudDogRWxlbWVudCA9ICdkaXYnLFxyXG4gICAgLi4ucHJvcHNcclxufSwgcmVmKSA9PiB7XHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAgIDxFbGVtZW50IHJlZj17cmVmfSBjbGFzc05hbWU9e2Nzc0NsYXNzZXMuQ09OVEVOVH0gey4uLnByb3BzfSAvPlxyXG4gICAgKTtcclxufSk7XHJcblxyXG5EcmF3ZXJDb250ZW50LmRpc3BsYXlOYW1lID0gJ01EQ0RyYXdlckNvbnRlbnQnO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgRHJhd2VyQ29udGVudDsiLCJpbXBvcnQgRHJhd2VyIGZyb20gJy4vRHJhd2VyJztcclxuaW1wb3J0IERyYXdlckhlYWRlciBmcm9tICcuL0RyYXdlckhlYWRlcic7XHJcbmltcG9ydCBEcmF3ZXJDb250ZW50IGZyb20gJy4vRHJhd2VyQ29udGVudCc7XHJcblxyXG5EcmF3ZXIuSGVhZGVyID0gRHJhd2VySGVhZGVyO1xyXG5EcmF3ZXIuQ29udGVudCA9IERyYXdlckNvbnRlbnQ7XHJcblxyXG5leHBvcnQge1xyXG4gICAgRHJhd2VyIGFzIGRlZmF1bHQsXHJcbiAgICBEcmF3ZXJIZWFkZXIsXHJcbiAgICBEcmF3ZXJDb250ZW50XHJcbn07IiwiZXhwb3J0IGNvbnN0IGNzc0NsYXNzZXMgPSB7XHJcbiAgICBST09UOiAnbWRjLWVsZXZhdGlvbicsXHJcbiAgICBaOiAnbWRjLWVsZXZhdGlvbi0teicsXHJcbiAgICBUUkFOU0lUSU9OOiAnbWRjLWVsZXZhdGlvbi10cmFuc2l0aW9uJ1xyXG59OyIsImltcG9ydCB7IGZvcndhcmRSZWYgfSBmcm9tICdyZWFjdCc7XHJcbmltcG9ydCBjbGFzc25hbWVzIGZyb20gJ2NsYXNzbmFtZXMnO1xyXG5cclxuaW1wb3J0IHsgY3NzQ2xhc3NlcyB9IGZyb20gJy4vY29uc3RhbnRzJztcclxuXHJcbmNvbnN0IEVsZXZhdGlvbiA9IGZvcndhcmRSZWYoKHtcclxuICAgIHogPSAwLFxyXG4gICAgdHJhbnNpdGlvbiA9IGZhbHNlLFxyXG5cclxuICAgIGVsZW1lbnQgPSAnZGl2JyxcclxuICAgIGNvbXBvbmVudDogRWxlbWVudCA9IGVsZW1lbnQsXHJcbiAgICBjbGFzc05hbWUsXHJcbiAgICAuLi5wcm9wc1xyXG59LCByZWYpID0+IHtcclxuICAgIGNvbnN0IGNsYXNzTmFtZXMgPSBjbGFzc25hbWVzKGNzc0NsYXNzZXMuUk9PVCwge1xyXG4gICAgICAgIFtgJHtjc3NDbGFzc2VzLlp9JHt6fWBdOiB6LFxyXG4gICAgICAgIFtjc3NDbGFzc2VzLlRSQU5TSVRJT05dOiB0cmFuc2l0aW9uXHJcbiAgICB9LCBjbGFzc05hbWUpO1xyXG5cclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgPEVsZW1lbnQgcmVmPXtyZWZ9IGNsYXNzTmFtZT17Y2xhc3NOYW1lc30gey4uLnByb3BzfSAvPlxyXG4gICAgKTtcclxufSk7XHJcblxyXG5FbGV2YXRpb24uZGlzcGxheU5hbWUgPSAnTURDRWxldmF0aW9uJztcclxuXHJcbmV4cG9ydCBkZWZhdWx0IEVsZXZhdGlvbjsiLCJleHBvcnQgeyBkZWZhdWx0IH0gZnJvbSAnLi9FbGV2YXRpb24nOyIsImV4cG9ydCBjb25zdCBjc3NDbGFzc2VzID0ge1xyXG4gICAgUk9PVDogJ21kYy1mYWInLFxyXG4gICAgTUlOSTogJ21kYy1mYWItLW1pbmknLFxyXG4gICAgRVhURU5ERUQ6ICdtZGMtZmFiLS1leHRlbmRlZCcsXHJcbiAgICBFWElURUQ6ICdtZGMtZmFiLS1leGl0ZWQnLFxyXG5cclxuICAgIElDT046ICdtZGMtZmFiX19pY29uJyxcclxuICAgIExBQkVMOiAnbWRjLWZhYl9fbGFiZWwnLFxyXG4gICAgUklQUExFOiAnbWRjLWZhYl9fcmlwcGxlJ1xyXG59OyIsImltcG9ydCB7IGZvcndhcmRSZWYgfSBmcm9tICdyZWFjdCc7XHJcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XHJcbmltcG9ydCBjbGFzc25hbWVzIGZyb20gJ2NsYXNzbmFtZXMnO1xyXG5cclxuaW1wb3J0IHsgQ2xvbmUgfSBmcm9tICcuLi9jb21wb25lbnQnO1xyXG5pbXBvcnQgSWNvbiBmcm9tICcuLi9pY29uJztcclxuXHJcbmltcG9ydCB7IGNzc0NsYXNzZXMgfSBmcm9tICcuL2NvbnN0YW50cyc7XHJcblxyXG5jb25zdCBGQUIgPSBmb3J3YXJkUmVmKCh7XHJcbiAgICBpY29uLFxyXG4gICAgbGFiZWwsXHJcbiAgICBsZWFkaW5nSWNvbiA9IGljb24sXHJcbiAgICB0cmFpbGluZ0ljb24sXHJcbiAgICBtaW5pID0gZmFsc2UsXHJcbiAgICBleGl0ZWQgPSBmYWxzZSxcclxuXHJcbiAgICBlbGVtZW50ID0gJ2J1dHRvbicsXHJcbiAgICBjb21wb25lbnQ6IEVsZW1lbnQgPSBlbGVtZW50LFxyXG4gICAgY2xhc3NOYW1lLFxyXG4gICAgY2hpbGRyZW4gPSBsYWJlbCxcclxuICAgIC4uLnByb3BzXHJcbn0sIHJlZikgPT4ge1xyXG4gICAgY29uc3QgY2xhc3NOYW1lcyA9IGNsYXNzbmFtZXMoY3NzQ2xhc3Nlcy5ST09ULCB7XHJcbiAgICAgICAgW2Nzc0NsYXNzZXMuTUlOSV06IG1pbmksXHJcbiAgICAgICAgW2Nzc0NsYXNzZXMuRVhURU5ERURdOiBsYWJlbCxcclxuICAgICAgICBbY3NzQ2xhc3Nlcy5FWElURURdOiBleGl0ZWRcclxuICAgIH0sIGNsYXNzTmFtZSk7XHJcblxyXG4gICAgcmV0dXJuIChcclxuICAgICAgICA8RWxlbWVudCByZWY9e3JlZn0gY2xhc3NOYW1lPXtjbGFzc05hbWVzfSB7Li4ucHJvcHN9PlxyXG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17Y3NzQ2xhc3Nlcy5SSVBQTEV9IC8+XHJcblxyXG4gICAgICAgICAgICB7bGVhZGluZ0ljb24gJiZcclxuICAgICAgICAgICAgICAgIDxDbG9uZVxyXG4gICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudD17bGVhZGluZ0ljb259XHJcbiAgICAgICAgICAgICAgICAgICAgZmFsbGJhY2s9e0ljb259XHJcbiAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPXtjc3NDbGFzc2VzLklDT059XHJcbiAgICAgICAgICAgICAgICAvPlxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB7Y2hpbGRyZW4gJiZcclxuICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT17Y3NzQ2xhc3Nlcy5MQUJFTH0+e2NoaWxkcmVufTwvc3Bhbj5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAge3RyYWlsaW5nSWNvbiAmJlxyXG4gICAgICAgICAgICAgICAgPENsb25lXHJcbiAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50PXt0cmFpbGluZ0ljb259XHJcbiAgICAgICAgICAgICAgICAgICAgZmFsbGJhY2s9e0ljb259XHJcbiAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPXtjc3NDbGFzc2VzLklDT059XHJcbiAgICAgICAgICAgICAgICAvPlxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgPC9FbGVtZW50PlxyXG4gICAgKTtcclxufSk7XHJcblxyXG5GQUIuZGlzcGxheU5hbWUgPSAnTURDRkFCJztcclxuXHJcbkZBQi5wcm9wVHlwZXMgPSB7XHJcbiAgICBpY29uOiBQcm9wVHlwZXMubm9kZSxcclxuICAgIGxhYmVsOiBQcm9wVHlwZXMubm9kZSxcclxuICAgIGxlYWRpbmdJY29uOiBQcm9wVHlwZXMubm9kZSxcclxuICAgIHRyYWlsaW5nSWNvbjogUHJvcFR5cGVzLm5vZGUsXHJcbiAgICBtaW5pOiBQcm9wVHlwZXMuYm9vbCxcclxuICAgIGV4aXRlZDogUHJvcFR5cGVzLmJvb2xcclxufTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IEZBQjsiLCJleHBvcnQgeyBkZWZhdWx0IH0gZnJvbSAnLi9GQUInOyIsImV4cG9ydCBjb25zdCBjc3NDbGFzc2VzID0ge1xyXG4gICAgUk9PVDogJ21kYy1mb3JtLWZpZWxkJyxcclxuICAgIEFMSUdOX0VORDogJ21kYy1mb3JtLWZpZWxkLS1hbGlnbi1lbmQnLFxyXG4gICAgTk9XUkFQOiAnbWRjLWZvcm0tZmllbGQtLW5vd3JhcCcsXHJcbiAgICBTUEFDRV9CRVRXRUVOOiAnbWRjLWZvcm0tZmllbGQtLXNwYWNlLWJldHdlZW4nXHJcbn07IiwiaW1wb3J0IHsgZm9yd2FyZFJlZiB9IGZyb20gJ3JlYWN0JztcclxuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcclxuaW1wb3J0IGNsYXNzbmFtZXMgZnJvbSAnY2xhc3NuYW1lcyc7XHJcblxyXG5pbXBvcnQgeyBjc3NDbGFzc2VzIH0gZnJvbSAnLi9jb25zdGFudHMnO1xyXG5cclxuY29uc3QgRm9ybUZpZWxkID0gZm9yd2FyZFJlZigoe1xyXG4gICAgbGFiZWwsXHJcbiAgICBhbGlnbkVuZCA9IGZhbHNlLFxyXG4gICAgbm93cmFwID0gZmFsc2UsXHJcbiAgICBzcGFjZUJldHdlZW4gPSBmYWxzZSxcclxuXHJcbiAgICBlbGVtZW50OiBFbGVtZW50ID0gJ2RpdicsXHJcbiAgICBjbGFzc05hbWUsXHJcbiAgICBjaGlsZHJlbixcclxuICAgIC4uLnByb3BzXHJcbn0sIHJlZikgPT4ge1xyXG4gICAgY29uc3QgY2xhc3NOYW1lcyA9IGNsYXNzbmFtZXMoY3NzQ2xhc3Nlcy5ST09ULCB7XHJcbiAgICAgICAgW2Nzc0NsYXNzZXMuQUxJR05fRU5EXTogYWxpZ25FbmQsXHJcbiAgICAgICAgW2Nzc0NsYXNzZXMuTk9XUkFQXTogbm93cmFwLFxyXG4gICAgICAgIFtjc3NDbGFzc2VzLlNQQUNFX0JFVFdFRU5dOiBzcGFjZUJldHdlZW5cclxuICAgIH0sIGNsYXNzTmFtZSk7XHJcblxyXG4gICAgcmV0dXJuIChcclxuICAgICAgICA8RWxlbWVudCByZWY9e3JlZn0gY2xhc3NOYW1lPXtjbGFzc05hbWVzfSB7Li4ucHJvcHN9PlxyXG4gICAgICAgICAgICB7Y2hpbGRyZW59XHJcblxyXG4gICAgICAgICAgICB7bGFiZWwgJiZcclxuICAgICAgICAgICAgICAgIDxsYWJlbCBodG1sRm9yPXtjaGlsZHJlbi5wcm9wcy5pZH0+e2xhYmVsfTwvbGFiZWw+XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICA8L0VsZW1lbnQ+XHJcbiAgICApO1xyXG59KTtcclxuXHJcbkZvcm1GaWVsZC5kaXNwbGF5TmFtZSA9ICdNRENGb3JtRmllbGQnO1xyXG5cclxuRm9ybUZpZWxkLnByb3BUeXBlcyA9IHtcclxuICAgIGxhYmVsOiBQcm9wVHlwZXMubm9kZSxcclxuICAgIGFsaWduRW5kOiBQcm9wVHlwZXMuYm9vbCxcclxuICAgIG5vd3JhcDogUHJvcFR5cGVzLmJvb2wsXHJcbiAgICBzcGFjZUJldHdlZW46IFByb3BUeXBlcy5ib29sLFxyXG4gICAgY2hpbGRyZW46IFByb3BUeXBlcy5hbnkuaXNSZXF1aXJlZFxyXG59O1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgRm9ybUZpZWxkOyIsImV4cG9ydCB7IGRlZmF1bHQgfSBmcm9tICcuL0Zvcm1GaWVsZCc7IiwiZXhwb3J0IGNvbnN0IGNzc0NsYXNzZXMgPSB7XHJcbiAgICBJTUFHRV9MSVNUOiAnbWRjLWltYWdlLWxpc3QnLFxyXG4gICAgSU1BR0VfTElTVF9NQVNPTlJZOiAnbWRjLWltYWdlLWxpc3QtLW1hc29ucnknLFxyXG4gICAgSU1BR0VfTElTVF9XSVRIX1RFWFRfUFJPVEVDVElPTjogJ21kYy1pbWFnZS1saXN0LS13aXRoLXRleHQtcHJvdGVjdGlvbicsXHJcblxyXG4gICAgSU1BR0VfTElTVF9JVEVNOiAnbWRjLWltYWdlLWxpc3RfX2l0ZW0nLFxyXG4gICAgSU1BR0VfTElTVF9JTUFHRV9BU1BFQ1RfQ09OVEFJTkVSOiAnbWRjLWltYWdlLWxpc3RfX2ltYWdlLWFzcGVjdC1jb250YWluZXInLFxyXG4gICAgSU1BR0VfTElTVF9JTUFHRTogJ21kYy1pbWFnZS1saXN0X19pbWFnZScsXHJcbiAgICBJTUFHRV9MSVNUX1NVUFBPUlRJTkc6ICdtZGMtaW1hZ2UtbGlzdF9fc3VwcG9ydGluZycsXHJcbiAgICBJTUFHRV9MSVNUX0xBQkVMOiAnbWRjLWltYWdlLWxpc3RfX2xhYmVsJ1xyXG59OyIsImltcG9ydCB7IGZvcndhcmRSZWYgfSBmcm9tICdyZWFjdCc7XHJcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XHJcbmltcG9ydCBjbGFzc25hbWVzIGZyb20gJ2NsYXNzbmFtZXMnO1xyXG5cclxuaW1wb3J0IHsgY3NzQ2xhc3NlcyB9IGZyb20gJy4vY29uc3RhbnRzJztcclxuXHJcbmNvbnN0IEltYWdlTGlzdEl0ZW0gPSBmb3J3YXJkUmVmKCh7XHJcbiAgICBpbWFnZVNyYyxcclxuICAgIGxhYmVsLFxyXG4gICAgZml4ZWRBc3BlY3QgPSB0cnVlLFxyXG5cclxuICAgIGVsZW1lbnQ6IEVsZW1lbnQgPSAnbGknLFxyXG4gICAgY2xhc3NOYW1lLFxyXG4gICAgLi4ucHJvcHNcclxufSwgcmVmKSA9PiB7XHJcbiAgICBjb25zdCBjbGFzc05hbWVzID0gY2xhc3NuYW1lcyhjc3NDbGFzc2VzLklNQUdFX0xJU1RfSVRFTSwgY2xhc3NOYW1lKTtcclxuXHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAgIDxFbGVtZW50IHJlZj17cmVmfSBjbGFzc05hbWU9e2NsYXNzTmFtZXN9IHsuLi5wcm9wc30+XHJcbiAgICAgICAgICAgIHtmaXhlZEFzcGVjdCA/XHJcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17Y3NzQ2xhc3Nlcy5JTUFHRV9MSVNUX0lNQUdFX0FTUEVDVF9DT05UQUlORVJ9PlxyXG4gICAgICAgICAgICAgICAgICAgIDxpbWcgY2xhc3NOYW1lPXtjc3NDbGFzc2VzLklNQUdFX0xJU1RfSU1BR0V9IHNyYz17aW1hZ2VTcmN9IGFsdD17bGFiZWx9IC8+XHJcbiAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgICAgIDpcclxuICAgICAgICAgICAgICAgIDxpbWcgY2xhc3NOYW1lPXtjc3NDbGFzc2VzLklNQUdFX0xJU1RfSU1BR0V9IHNyYz17aW1hZ2VTcmN9IGFsdD17bGFiZWx9IC8+XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHtsYWJlbCAmJlxyXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9e2Nzc0NsYXNzZXMuSU1BR0VfTElTVF9TVVBQT1JUSU5HfT5cclxuICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9e2Nzc0NsYXNzZXMuSU1BR0VfTElTVF9MQUJFTH0+e2xhYmVsfTwvc3Bhbj5cclxuICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgPC9FbGVtZW50PlxyXG4gICAgKTtcclxufSk7XHJcblxyXG5JbWFnZUxpc3RJdGVtLmRpc3BsYXlOYW1lID0gJ01EQ0ltYWdlTGlzdEl0ZW0nO1xyXG5cclxuSW1hZ2VMaXN0SXRlbS5wcm9wVHlwZXMgPSB7XHJcbiAgICBpbWFnZVNyYzogUHJvcFR5cGVzLnN0cmluZyxcclxuICAgIGxhYmVsOiBQcm9wVHlwZXMubm9kZSxcclxuICAgIGZpeGVkQXNwZWN0OiBQcm9wVHlwZXMuYm9vbFxyXG59O1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgSW1hZ2VMaXN0SXRlbTsiLCJpbXBvcnQgeyBDaGlsZHJlbiwgZm9yd2FyZFJlZiB9IGZyb20gJ3JlYWN0JztcclxuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcclxuaW1wb3J0IGNsYXNzbmFtZXMgZnJvbSAnY2xhc3NuYW1lcyc7XHJcblxyXG5pbXBvcnQgeyBjbG9uZSwgY3JlYXRlIH0gZnJvbSAnLi4vY29tcG9uZW50JztcclxuXHJcbmltcG9ydCB7IGNzc0NsYXNzZXMgfSBmcm9tICcuL2NvbnN0YW50cyc7XHJcbmltcG9ydCBJbWFnZUxpc3RJdGVtIGZyb20gJy4vSW1hZ2VMaXN0SXRlbSc7XHJcblxyXG5jb25zdCBJbWFnZUxpc3QgPSBmb3J3YXJkUmVmKCh7XHJcbiAgICBpdGVtcyxcclxuICAgIG1hc29ucnkgPSBmYWxzZSxcclxuICAgIHdpdGhUZXh0UHJvdGVjdGlvbiA9IGZhbHNlLFxyXG5cclxuICAgIGVsZW1lbnQ6IEVsZW1lbnQgPSAndWwnLFxyXG4gICAgY2xhc3NOYW1lLFxyXG4gICAgY2hpbGRyZW4gPSBpdGVtcz8ubWFwKGl0ZW0gPT4gY3JlYXRlKEltYWdlTGlzdEl0ZW0sIGl0ZW0pKSxcclxuICAgIC4uLnByb3BzXHJcbn0sIHJlZikgPT4ge1xyXG4gICAgY29uc3QgY2xhc3NOYW1lcyA9IGNsYXNzbmFtZXMoY3NzQ2xhc3Nlcy5JTUFHRV9MSVNULCB7XHJcbiAgICAgICAgW2Nzc0NsYXNzZXMuSU1BR0VfTElTVF9NQVNPTlJZXTogbWFzb25yeSxcclxuICAgICAgICBbY3NzQ2xhc3Nlcy5JTUFHRV9MSVNUX1dJVEhfVEVYVF9QUk9URUNUSU9OXTogd2l0aFRleHRQcm90ZWN0aW9uXHJcbiAgICB9LCBjbGFzc05hbWUpO1xyXG5cclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgPEVsZW1lbnQgcmVmPXtyZWZ9IGNsYXNzTmFtZT17Y2xhc3NOYW1lc30gey4uLnByb3BzfT5cclxuICAgICAgICAgICAge0NoaWxkcmVuLm1hcChjaGlsZHJlbiwgY2hpbGQgPT5cclxuICAgICAgICAgICAgICAgIGNsb25lKGNoaWxkLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgZml4ZWRBc3BlY3Q6IG1hc29ucnkgPyBmYWxzZSA6IHVuZGVmaW5lZFxyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgKX1cclxuICAgICAgICA8L0VsZW1lbnQ+XHJcbiAgICApO1xyXG59KTtcclxuXHJcbkltYWdlTGlzdC5kaXNwbGF5TmFtZSA9ICdNRENJbWFnZUxpc3QnO1xyXG5cclxuSW1hZ2VMaXN0LnByb3BUeXBlcyA9IHtcclxuICAgIGl0ZW1zOiBQcm9wVHlwZXMuYXJyYXksXHJcbiAgICBtYXNvbnJ5OiBQcm9wVHlwZXMuYm9vbCxcclxuICAgIHdpdGhUZXh0UHJvdGVjdGlvbjogUHJvcFR5cGVzLmJvb2xcclxufTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IEltYWdlTGlzdDsiLCJpbXBvcnQgSW1hZ2VMaXN0IGZyb20gJy4vSW1hZ2VMaXN0JztcclxuaW1wb3J0IEltYWdlTGlzdEl0ZW0gZnJvbSAnLi9JbWFnZUxpc3RJdGVtJztcclxuXHJcbkltYWdlTGlzdC5JdGVtID0gSW1hZ2VMaXN0SXRlbTtcclxuXHJcbmV4cG9ydCB7XHJcbiAgICBJbWFnZUxpc3QgYXMgZGVmYXVsdCxcclxuICAgIEltYWdlTGlzdEl0ZW1cclxufTsiLCJleHBvcnQgY29uc3QgY3NzQ2xhc3NlcyA9IHtcclxuICAgIFJPT1Q6ICdtZGMtbGF5b3V0JyxcclxuICAgIFJPVzogJ21kYy1sYXlvdXQtLXJvdycsXHJcbiAgICBDT0xVTU46ICdtZGMtbGF5b3V0LS1jb2x1bW4nLFxyXG4gICAgRElSRUNUSU9OOiAnbWRjLWxheW91dC0tZGlyZWN0aW9uJyxcclxuICAgIFdSQVA6ICdtZGMtbGF5b3V0LS13cmFwJyxcclxuICAgIFdSQVBfUkVWRVJTRTogJ21kYy1sYXlvdXQtLXdyYXAtcmV2ZXJzZScsXHJcbiAgICBBTElHTl9JVEVNUzogJ21kYy1sYXlvdXQtLWFsaWduLWl0ZW1zJyxcclxuICAgIEFMSUdOX1NFTEY6ICdtZGMtbGF5b3V0LS1hbGlnbi1zZWxmJyxcclxuICAgIEpVU1RJRllfQ09OVEVOVDogJ21kYy1sYXlvdXQtLWp1c3RpZnktY29udGVudCdcclxufTsiLCJpbXBvcnQgeyBmb3J3YXJkUmVmIH0gZnJvbSAncmVhY3QnO1xyXG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xyXG5pbXBvcnQgY2xhc3NuYW1lcyBmcm9tICdjbGFzc25hbWVzJztcclxuXHJcbmltcG9ydCB7IGNzc0NsYXNzZXMgfSBmcm9tICcuL2NvbnN0YW50cyc7XHJcblxyXG5jb25zdCBMYXlvdXQgPSBmb3J3YXJkUmVmKCh7XHJcbiAgICByb3csXHJcbiAgICBjb2x1bW4sXHJcbiAgICBkaXJlY3Rpb24sXHJcbiAgICB3cmFwLFxyXG4gICAgYWxpZ25JdGVtcyxcclxuICAgIGFsaWduU2VsZixcclxuICAgIGp1c3RpZnlDb250ZW50LFxyXG5cclxuICAgIGVsZW1lbnQgPSAnZGl2JyxcclxuICAgIGNvbXBvbmVudDogRWxlbWVudCA9IGVsZW1lbnQsXHJcbiAgICBjbGFzc05hbWUsXHJcbiAgICAuLi5wcm9wc1xyXG59LCByZWYpID0+IHtcclxuICAgIGNvbnN0IGNsYXNzTmFtZXMgPSBjbGFzc25hbWVzKGNzc0NsYXNzZXMuUk9PVCwge1xyXG4gICAgICAgIFtjc3NDbGFzc2VzLlJPV106IHJvdyxcclxuICAgICAgICBbY3NzQ2xhc3Nlcy5DT0xVTU5dOiBjb2x1bW4sXHJcbiAgICAgICAgW2Ake2Nzc0NsYXNzZXMuRElSRUNUSU9OfS0tJHtkaXJlY3Rpb259YF06IGRpcmVjdGlvbixcclxuICAgICAgICBbYCR7Y3NzQ2xhc3Nlcy5BTElHTl9JVEVNU30tLSR7YWxpZ25JdGVtc31gXTogYWxpZ25JdGVtcyxcclxuICAgICAgICBbYCR7Y3NzQ2xhc3Nlcy5BTElHTl9TRUxGfS0tJHthbGlnblNlbGZ9YF06IGFsaWduU2VsZixcclxuICAgICAgICBbYCR7Y3NzQ2xhc3Nlcy5KVVNUSUZZX0NPTlRFTlR9LS0ke2p1c3RpZnlDb250ZW50fWBdOiBqdXN0aWZ5Q29udGVudCxcclxuICAgICAgICBbY3NzQ2xhc3Nlcy5XUkFQXTogd3JhcCA9PT0gdHJ1ZSxcclxuICAgICAgICBbY3NzQ2xhc3Nlcy5XUkFQX1JFVkVSU0VdOiB3cmFwID09PSAncmV2ZXJzZSdcclxuICAgIH0sIGNsYXNzTmFtZSk7XHJcblxyXG4gICAgcmV0dXJuIChcclxuICAgICAgICA8RWxlbWVudCByZWY9e3JlZn0gY2xhc3NOYW1lPXtjbGFzc05hbWVzfSB7Li4ucHJvcHN9IC8+XHJcbiAgICApO1xyXG59KTtcclxuXHJcbkxheW91dC5kaXNwbGF5TmFtZSA9ICdNRENMYXlvdXQnO1xyXG5cclxuTGF5b3V0LnByb3BUeXBlcyA9IHtcclxuICAgIHJvdzogUHJvcFR5cGVzLmJvb2wsXHJcbiAgICBjb2x1bW46IFByb3BUeXBlcy5ib29sLFxyXG4gICAgZGlyZWN0aW9uOiBQcm9wVHlwZXMub25lT2YoWydyb3cnLCAnY29sdW1uJ10pLFxyXG4gICAgd3JhcDogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLmJvb2wsIFByb3BUeXBlcy5zdHJpbmddKSxcclxuICAgIGFsaWduSXRlbXM6IFByb3BUeXBlcy5vbmVPZihbJ3N0YXJ0JywgJ2NlbnRlcicsICdlbmQnXSksXHJcbiAgICBhbGlnblNlbGY6IFByb3BUeXBlcy5vbmVPZihbJ3N0YXJ0JywgJ2NlbnRlcicsICdlbmQnXSksXHJcbiAgICBqdXN0aWZ5Q29udGVudDogUHJvcFR5cGVzLm9uZU9mKFsnc3RhcnQnLCAnY2VudGVyJywgJ2VuZCcsICdhcm91bmQnLCAnYmV0d2VlbiddKVxyXG59O1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgTGF5b3V0OyIsImV4cG9ydCB7IGRlZmF1bHQgfSBmcm9tICcuL0xheW91dCc7IiwiZXhwb3J0IGNvbnN0IGNzc0NsYXNzZXMgPSB7XHJcbiAgICBST09UOiAnbWRjLWxheW91dC1ncmlkJyxcclxuICAgIEFMSUdOOiAnbWRjLWxheW91dC1ncmlkLS1hbGlnbicsXHJcbiAgICBGSVhFRF9DT0xVTU5fV0lEVEg6ICdtZGMtbGF5b3V0LWdyaWQtLWZpeGVkLWNvbHVtbi13aWR0aCcsXHJcblxyXG4gICAgSU5ORVI6ICdtZGMtbGF5b3V0LWdyaWRfX2lubmVyJyxcclxuXHJcbiAgICBDRUxMOiAnbWRjLWxheW91dC1ncmlkX19jZWxsJyxcclxuICAgIENFTExfU1BBTjogJ21kYy1sYXlvdXQtZ3JpZF9fY2VsbC0tc3BhbicsXHJcbiAgICBDRUxMX09SREVSOiAnbWRjLWxheW91dC1ncmlkX19jZWxsLS1vcmRlcicsXHJcbiAgICBDRUxMX0FMSUdOOiAnbWRjLWxheW91dC1ncmlkX19jZWxsLS1hbGlnbidcclxufTsiLCJpbXBvcnQgeyBmb3J3YXJkUmVmIH0gZnJvbSAncmVhY3QnO1xyXG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xyXG5pbXBvcnQgY2xhc3NuYW1lcyBmcm9tICdjbGFzc25hbWVzJztcclxuaW1wb3J0IHsgY3NzQ2xhc3NlcyB9IGZyb20gJy4vY29uc3RhbnRzJztcclxuXHJcbmNvbnN0IExheW91dEdyaWQgPSBmb3J3YXJkUmVmKCh7XHJcbiAgICBhbGlnbixcclxuICAgIGZpeGVkQ29sdW1uV2lkdGggPSBmYWxzZSxcclxuXHJcbiAgICBlbGVtZW50ID0gJ2RpdicsXHJcbiAgICBjb21wb25lbnQgPSBlbGVtZW50LFxyXG4gICAgY2xhc3NOYW1lLFxyXG4gICAgY2hpbGRyZW4sXHJcbiAgICAuLi5wcm9wc1xyXG59LCByZWYpID0+IHtcclxuICAgIGNvbnN0IEVsZW1lbnQgPSBjb21wb25lbnQ7XHJcbiAgICBjb25zdCBjbGFzc05hbWVzID0gY2xhc3NuYW1lcyhjc3NDbGFzc2VzLlJPT1QsIHtcclxuICAgICAgICBbYCR7Y3NzQ2xhc3Nlcy5BTElHTn0tJHthbGlnbn1gXTogYWxpZ24sXHJcbiAgICAgICAgW2Nzc0NsYXNzZXMuRklYRURfQ09MVU1OX1dJRFRIXTogZml4ZWRDb2x1bW5XaWR0aFxyXG4gICAgfSwgY2xhc3NOYW1lKTtcclxuXHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAgIDxFbGVtZW50IHJlZj17cmVmfSBjbGFzc05hbWU9e2NsYXNzTmFtZXN9IHsuLi5wcm9wc30+XHJcbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXtjc3NDbGFzc2VzLklOTkVSfT57Y2hpbGRyZW59PC9kaXY+XHJcbiAgICAgICAgPC9FbGVtZW50PlxyXG4gICAgKTtcclxufSk7XHJcblxyXG5MYXlvdXRHcmlkLmRpc3BsYXlOYW1lID0gJ01EQ0xheW91dEdyaWQnO1xyXG5cclxuTGF5b3V0R3JpZC5wcm9wVHlwZXMgPSB7XHJcbiAgICBhbGlnbjogUHJvcFR5cGVzLm9uZU9mKFsnbGVmdCcsICdyaWdodCddKSxcclxuICAgIGZpeGVkQ29sdW1uV2lkdGg6IFByb3BUeXBlcy5ib29sXHJcbn07XHJcblxyXG5leHBvcnQgZGVmYXVsdCBMYXlvdXRHcmlkOyIsImltcG9ydCB7IGZvcndhcmRSZWYgfSBmcm9tICdyZWFjdCc7XHJcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XHJcbmltcG9ydCBjbGFzc25hbWVzIGZyb20gJ2NsYXNzbmFtZXMnO1xyXG5pbXBvcnQgeyBjc3NDbGFzc2VzIH0gZnJvbSAnLi9jb25zdGFudHMnO1xyXG5cclxuY29uc3QgTGF5b3V0R3JpZENlbGwgPSBmb3J3YXJkUmVmKCh7XHJcbiAgICBzcGFuLFxyXG4gICAgZGVza3RvcCxcclxuICAgIHRhYmxldCxcclxuICAgIG1vYmlsZSxcclxuICAgIG9yZGVyLFxyXG4gICAgYWxpZ24sXHJcbiAgICBncmlkID0gZmFsc2UsXHJcblxyXG4gICAgZWxlbWVudCA9ICdkaXYnLFxyXG4gICAgY29tcG9uZW50ID0gZWxlbWVudCxcclxuICAgIGNsYXNzTmFtZSxcclxuICAgIGNoaWxkcmVuLFxyXG4gICAgLi4ucHJvcHNcclxufSwgcmVmKSA9PiB7XHJcbiAgICBjb25zdCBFbGVtZW50ID0gY29tcG9uZW50O1xyXG4gICAgY29uc3QgY2xhc3NOYW1lcyA9IGNsYXNzbmFtZXMoY3NzQ2xhc3Nlcy5DRUxMLCB7XHJcbiAgICAgICAgW2Ake2Nzc0NsYXNzZXMuQ0VMTF9TUEFOfS0ke3NwYW59YF06IHNwYW4sXHJcbiAgICAgICAgW2Ake2Nzc0NsYXNzZXMuQ0VMTF9TUEFOfS0ke2Rlc2t0b3B9LWRlc2t0b3BgXTogZGVza3RvcCxcclxuICAgICAgICBbYCR7Y3NzQ2xhc3Nlcy5DRUxMX1NQQU59LSR7dGFibGV0fS10YWJsZXRgXTogdGFibGV0LFxyXG4gICAgICAgIFtgJHtjc3NDbGFzc2VzLkNFTExfU1BBTn0tJHttb2JpbGV9LW1vYmlsZWBdOiBtb2JpbGUsXHJcbiAgICAgICAgW2Ake2Nzc0NsYXNzZXMuQ0VMTF9PUkRFUn0tJHtvcmRlcn1gXTogb3JkZXIsXHJcbiAgICAgICAgW2Ake2Nzc0NsYXNzZXMuQ0VMTF9BTElHTn0tJHthbGlnbn1gXTogYWxpZ25cclxuICAgIH0sIGNsYXNzTmFtZSk7XHJcblxyXG4gICAgcmV0dXJuIChcclxuICAgICAgICA8RWxlbWVudCByZWY9e3JlZn0gY2xhc3NOYW1lPXtjbGFzc05hbWVzfSB7Li4ucHJvcHN9PlxyXG4gICAgICAgICAgICB7Z3JpZCA/XHJcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17Y3NzQ2xhc3Nlcy5JTk5FUn0+XHJcbiAgICAgICAgICAgICAgICAgICAge2NoaWxkcmVufVxyXG4gICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICAgICA6XHJcbiAgICAgICAgICAgICAgICBjaGlsZHJlblxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgPC9FbGVtZW50PlxyXG4gICAgKTtcclxufSk7XHJcblxyXG5MYXlvdXRHcmlkQ2VsbC5kaXNwbGF5TmFtZSA9ICdNRENMYXlvdXRHcmlkQ2VsbCc7XHJcblxyXG5MYXlvdXRHcmlkQ2VsbC5wcm9wVHlwZXMgPSB7XHJcbiAgICBzcGFuOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMubnVtYmVyLCBQcm9wVHlwZXMuc3RyaW5nXSksXHJcbiAgICBkZXNrdG9wOiBQcm9wVHlwZXMubnVtYmVyLFxyXG4gICAgdGFibGV0OiBQcm9wVHlwZXMubnVtYmVyLFxyXG4gICAgbW9iaWxlOiBQcm9wVHlwZXMubnVtYmVyLFxyXG4gICAgb3JkZXI6IFByb3BUeXBlcy5udW1iZXIsXHJcbiAgICBhbGlnbjogUHJvcFR5cGVzLm9uZU9mKFsndG9wJywgJ21pZGRsZScsICdib3R0b20nXSksXHJcbiAgICBncmlkOiBQcm9wVHlwZXMuYm9vbFxyXG59O1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgTGF5b3V0R3JpZENlbGw7IiwiaW1wb3J0IExheW91dEdyaWQgZnJvbSAnLi9MYXlvdXRHcmlkJztcclxuaW1wb3J0IExheW91dEdyaWRDZWxsIGZyb20gJy4vTGF5b3V0R3JpZENlbGwnO1xyXG5cclxuTGF5b3V0R3JpZC5DZWxsID0gTGF5b3V0R3JpZENlbGw7XHJcblxyXG5leHBvcnQge1xyXG4gICAgTGF5b3V0R3JpZCBhcyBkZWZhdWx0LFxyXG4gICAgTGF5b3V0R3JpZENlbGxcclxufTsiLCJleHBvcnQgY29uc3QgY3NzQ2xhc3NlcyA9IHtcclxuICAgIFJPT1Q6ICdtZGMtcmFkaW8nLFxyXG4gICAgRElTQUJMRUQ6ICdtZGMtcmFkaW8tLWRpc2FibGVkJyxcclxuICAgIFRPVUNIOiAnbWRjLXJhZGlvLS10b3VjaCcsXHJcblxyXG4gICAgTkFUSVZFX0NPTlRST0w6ICdtZGMtcmFkaW9fX25hdGl2ZS1jb250cm9sJyxcclxuICAgIEJBQ0tHUk9VTkQ6ICdtZGMtcmFkaW9fX2JhY2tncm91bmQnLFxyXG4gICAgT1VURVJfQ0lSQ0xFOiAnbWRjLXJhZGlvX19vdXRlci1jaXJjbGUnLFxyXG4gICAgSU5ORVJfQ0lSQ0xFOiAnbWRjLXJhZGlvX19pbm5lci1jaXJjbGUnLFxyXG4gICAgUklQUExFOiAnbWRjLXJhZGlvX19yaXBwbGUnXHJcbn07IiwiaW1wb3J0IHsgdXNlUmVmLCB1c2VDYWxsYmFjaywgZm9yd2FyZFJlZiB9IGZyb20gJ3JlYWN0JztcclxuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcclxuaW1wb3J0IGNsYXNzbmFtZXMgZnJvbSAnY2xhc3NuYW1lcyc7XHJcblxyXG5pbXBvcnQgeyBjc3NDbGFzc2VzIH0gZnJvbSAnLi9jb25zdGFudHMnO1xyXG5cclxuY29uc3QgUmFkaW8gPSBmb3J3YXJkUmVmKCh7XHJcbiAgICB2YWx1ZSxcclxuICAgIGNoZWNrZWQsXHJcbiAgICBkaXNhYmxlZCA9IGZhbHNlLFxyXG4gICAgdG91Y2ggPSBmYWxzZSxcclxuICAgIG9uQ2hhbmdlID0gRnVuY3Rpb24ucHJvdG90eXBlLFxyXG5cclxuICAgIGNsYXNzTmFtZSxcclxuICAgIC4uLnByb3BzXHJcbn0sIHJlZikgPT4ge1xyXG4gICAgY29uc3QgaW5wdXRSZWYgPSB1c2VSZWYoKTtcclxuXHJcbiAgICBjb25zdCBoYW5kbGVDaGFuZ2UgPSB1c2VDYWxsYmFjayhldmVudCA9PiB7XHJcbiAgICAgICAgb25DaGFuZ2UoZXZlbnQsIGV2ZW50LnRhcmdldC52YWx1ZSwgZXZlbnQudGFyZ2V0KTtcclxuICAgIH0sIFtvbkNoYW5nZV0pO1xyXG5cclxuICAgIGNvbnN0IGNsYXNzTmFtZXMgPSBjbGFzc25hbWVzKGNzc0NsYXNzZXMuUk9PVCwge1xyXG4gICAgICAgIFtjc3NDbGFzc2VzLkRJU0FCTEVEXTogZGlzYWJsZWQsXHJcbiAgICAgICAgW2Nzc0NsYXNzZXMuVE9VQ0hdOiB0b3VjaFxyXG4gICAgfSwgY2xhc3NOYW1lKTtcclxuXHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAgIDxkaXYgcmVmPXtyZWZ9IGNsYXNzTmFtZT17Y2xhc3NOYW1lc30+XHJcbiAgICAgICAgICAgIDxpbnB1dFxyXG4gICAgICAgICAgICAgICAgcmVmPXtpbnB1dFJlZn1cclxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZT17Y3NzQ2xhc3Nlcy5OQVRJVkVfQ09OVFJPTH1cclxuICAgICAgICAgICAgICAgIHR5cGU9XCJyYWRpb1wiXHJcbiAgICAgICAgICAgICAgICB2YWx1ZT17dmFsdWV9XHJcbiAgICAgICAgICAgICAgICBjaGVja2VkPXtjaGVja2VkfVxyXG4gICAgICAgICAgICAgICAgZGlzYWJsZWQ9e2Rpc2FibGVkfVxyXG4gICAgICAgICAgICAgICAgb25DaGFuZ2U9e2hhbmRsZUNoYW5nZX1cclxuICAgICAgICAgICAgICAgIHsuLi5wcm9wc31cclxuICAgICAgICAgICAgLz5cclxuXHJcbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXtjc3NDbGFzc2VzLkJBQ0tHUk9VTkR9PlxyXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9e2Nzc0NsYXNzZXMuT1VURVJfQ0lSQ0xFfSAvPlxyXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9e2Nzc0NsYXNzZXMuSU5ORVJfQ0lSQ0xFfSAvPlxyXG4gICAgICAgICAgICA8L2Rpdj5cclxuXHJcbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXtjc3NDbGFzc2VzLlJJUFBMRX0gLz5cclxuICAgICAgICA8L2Rpdj5cclxuICAgICk7XHJcbn0pO1xyXG5cclxuUmFkaW8uZGlzcGxheU5hbWUgPSAnTURDUmFkaW8nO1xyXG5cclxuUmFkaW8ucHJvcFR5cGVzID0ge1xyXG4gICAgdmFsdWU6IFByb3BUeXBlcy5hbnksXHJcbiAgICBjaGVja2VkOiBQcm9wVHlwZXMuYm9vbCxcclxuICAgIGRpc2FibGVkOiBQcm9wVHlwZXMuYm9vbCxcclxuICAgIHRvdWNoOiBQcm9wVHlwZXMuYm9vbCxcclxuICAgIG9uQ2hhbmdlOiBQcm9wVHlwZXMuZnVuY1xyXG59O1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgUmFkaW87IiwiZXhwb3J0IHsgZGVmYXVsdCB9IGZyb20gJy4vUmFkaW8nOyIsIi8qISAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG5Db3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi5cclxuXHJcblBlcm1pc3Npb24gdG8gdXNlLCBjb3B5LCBtb2RpZnksIGFuZC9vciBkaXN0cmlidXRlIHRoaXMgc29mdHdhcmUgZm9yIGFueVxyXG5wdXJwb3NlIHdpdGggb3Igd2l0aG91dCBmZWUgaXMgaGVyZWJ5IGdyYW50ZWQuXHJcblxyXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiIEFORCBUSEUgQVVUSE9SIERJU0NMQUlNUyBBTEwgV0FSUkFOVElFUyBXSVRIXHJcblJFR0FSRCBUTyBUSElTIFNPRlRXQVJFIElOQ0xVRElORyBBTEwgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWVxyXG5BTkQgRklUTkVTUy4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUiBCRSBMSUFCTEUgRk9SIEFOWSBTUEVDSUFMLCBESVJFQ1QsXHJcbklORElSRUNULCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgT1IgQU5ZIERBTUFHRVMgV0hBVFNPRVZFUiBSRVNVTFRJTkcgRlJPTVxyXG5MT1NTIE9GIFVTRSwgREFUQSBPUiBQUk9GSVRTLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgTkVHTElHRU5DRSBPUlxyXG5PVEhFUiBUT1JUSU9VUyBBQ1RJT04sIEFSSVNJTkcgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgVVNFIE9SXHJcblBFUkZPUk1BTkNFIE9GIFRISVMgU09GVFdBUkUuXHJcbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXHJcbi8qIGdsb2JhbCBSZWZsZWN0LCBQcm9taXNlICovXHJcblxyXG52YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uKGQsIGIpIHtcclxuICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcclxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XHJcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIHApKSBkW3BdID0gYltwXTsgfTtcclxuICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG59O1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fZXh0ZW5kcyhkLCBiKSB7XHJcbiAgICBpZiAodHlwZW9mIGIgIT09IFwiZnVuY3Rpb25cIiAmJiBiICE9PSBudWxsKVxyXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDbGFzcyBleHRlbmRzIHZhbHVlIFwiICsgU3RyaW5nKGIpICsgXCIgaXMgbm90IGEgY29uc3RydWN0b3Igb3IgbnVsbFwiKTtcclxuICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cclxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcclxufVxyXG5cclxuZXhwb3J0IHZhciBfX2Fzc2lnbiA9IGZ1bmN0aW9uKCkge1xyXG4gICAgX19hc3NpZ24gPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uIF9fYXNzaWduKHQpIHtcclxuICAgICAgICBmb3IgKHZhciBzLCBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcclxuICAgICAgICAgICAgcyA9IGFyZ3VtZW50c1tpXTtcclxuICAgICAgICAgICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApKSB0W3BdID0gc1twXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHQ7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gX19hc3NpZ24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fcmVzdChzLCBlKSB7XHJcbiAgICB2YXIgdCA9IHt9O1xyXG4gICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApICYmIGUuaW5kZXhPZihwKSA8IDApXHJcbiAgICAgICAgdFtwXSA9IHNbcF07XHJcbiAgICBpZiAocyAhPSBudWxsICYmIHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzID09PSBcImZ1bmN0aW9uXCIpXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIHAgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHMpOyBpIDwgcC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAoZS5pbmRleE9mKHBbaV0pIDwgMCAmJiBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwocywgcFtpXSkpXHJcbiAgICAgICAgICAgICAgICB0W3BbaV1dID0gc1twW2ldXTtcclxuICAgICAgICB9XHJcbiAgICByZXR1cm4gdDtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcclxuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XHJcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xyXG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcclxuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX3BhcmFtKHBhcmFtSW5kZXgsIGRlY29yYXRvcikge1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uICh0YXJnZXQsIGtleSkgeyBkZWNvcmF0b3IodGFyZ2V0LCBrZXksIHBhcmFtSW5kZXgpOyB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX21ldGFkYXRhKG1ldGFkYXRhS2V5LCBtZXRhZGF0YVZhbHVlKSB7XHJcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEobWV0YWRhdGFLZXksIG1ldGFkYXRhVmFsdWUpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19hd2FpdGVyKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xyXG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XHJcbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XHJcbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XHJcbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cclxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XHJcbiAgICB9KTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fZ2VuZXJhdG9yKHRoaXNBcmcsIGJvZHkpIHtcclxuICAgIHZhciBfID0geyBsYWJlbDogMCwgc2VudDogZnVuY3Rpb24oKSB7IGlmICh0WzBdICYgMSkgdGhyb3cgdFsxXTsgcmV0dXJuIHRbMV07IH0sIHRyeXM6IFtdLCBvcHM6IFtdIH0sIGYsIHksIHQsIGc7XHJcbiAgICByZXR1cm4gZyA9IHsgbmV4dDogdmVyYigwKSwgXCJ0aHJvd1wiOiB2ZXJiKDEpLCBcInJldHVyblwiOiB2ZXJiKDIpIH0sIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiAoZ1tTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9KSwgZztcclxuICAgIGZ1bmN0aW9uIHZlcmIobikgeyByZXR1cm4gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHN0ZXAoW24sIHZdKTsgfTsgfVxyXG4gICAgZnVuY3Rpb24gc3RlcChvcCkge1xyXG4gICAgICAgIGlmIChmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgZXhlY3V0aW5nLlwiKTtcclxuICAgICAgICB3aGlsZSAoXykgdHJ5IHtcclxuICAgICAgICAgICAgaWYgKGYgPSAxLCB5ICYmICh0ID0gb3BbMF0gJiAyID8geVtcInJldHVyblwiXSA6IG9wWzBdID8geVtcInRocm93XCJdIHx8ICgodCA9IHlbXCJyZXR1cm5cIl0pICYmIHQuY2FsbCh5KSwgMCkgOiB5Lm5leHQpICYmICEodCA9IHQuY2FsbCh5LCBvcFsxXSkpLmRvbmUpIHJldHVybiB0O1xyXG4gICAgICAgICAgICBpZiAoeSA9IDAsIHQpIG9wID0gW29wWzBdICYgMiwgdC52YWx1ZV07XHJcbiAgICAgICAgICAgIHN3aXRjaCAob3BbMF0pIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgMDogY2FzZSAxOiB0ID0gb3A7IGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSA0OiBfLmxhYmVsKys7IHJldHVybiB7IHZhbHVlOiBvcFsxXSwgZG9uZTogZmFsc2UgfTtcclxuICAgICAgICAgICAgICAgIGNhc2UgNTogXy5sYWJlbCsrOyB5ID0gb3BbMV07IG9wID0gWzBdOyBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIGNhc2UgNzogb3AgPSBfLm9wcy5wb3AoKTsgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEodCA9IF8udHJ5cywgdCA9IHQubGVuZ3RoID4gMCAmJiB0W3QubGVuZ3RoIC0gMV0pICYmIChvcFswXSA9PT0gNiB8fCBvcFswXSA9PT0gMikpIHsgXyA9IDA7IGNvbnRpbnVlOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSAzICYmICghdCB8fCAob3BbMV0gPiB0WzBdICYmIG9wWzFdIDwgdFszXSkpKSB7IF8ubGFiZWwgPSBvcFsxXTsgYnJlYWs7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDYgJiYgXy5sYWJlbCA8IHRbMV0pIHsgXy5sYWJlbCA9IHRbMV07IHQgPSBvcDsgYnJlYWs7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAodCAmJiBfLmxhYmVsIDwgdFsyXSkgeyBfLmxhYmVsID0gdFsyXTsgXy5vcHMucHVzaChvcCk7IGJyZWFrOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRbMl0pIF8ub3BzLnBvcCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIF8udHJ5cy5wb3AoKTsgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgb3AgPSBib2R5LmNhbGwodGhpc0FyZywgXyk7XHJcbiAgICAgICAgfSBjYXRjaCAoZSkgeyBvcCA9IFs2LCBlXTsgeSA9IDA7IH0gZmluYWxseSB7IGYgPSB0ID0gMDsgfVxyXG4gICAgICAgIGlmIChvcFswXSAmIDUpIHRocm93IG9wWzFdOyByZXR1cm4geyB2YWx1ZTogb3BbMF0gPyBvcFsxXSA6IHZvaWQgMCwgZG9uZTogdHJ1ZSB9O1xyXG4gICAgfVxyXG59XHJcblxyXG5leHBvcnQgdmFyIF9fY3JlYXRlQmluZGluZyA9IE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcclxuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfSk7XHJcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XHJcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xyXG4gICAgb1trMl0gPSBtW2tdO1xyXG59KTtcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2V4cG9ydFN0YXIobSwgbykge1xyXG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAocCAhPT0gXCJkZWZhdWx0XCIgJiYgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvLCBwKSkgX19jcmVhdGVCaW5kaW5nKG8sIG0sIHApO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX192YWx1ZXMobykge1xyXG4gICAgdmFyIHMgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgU3ltYm9sLml0ZXJhdG9yLCBtID0gcyAmJiBvW3NdLCBpID0gMDtcclxuICAgIGlmIChtKSByZXR1cm4gbS5jYWxsKG8pO1xyXG4gICAgaWYgKG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09PSBcIm51bWJlclwiKSByZXR1cm4ge1xyXG4gICAgICAgIG5leHQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYgKG8gJiYgaSA+PSBvLmxlbmd0aCkgbyA9IHZvaWQgMDtcclxuICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IG8gJiYgb1tpKytdLCBkb25lOiAhbyB9O1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKHMgPyBcIk9iamVjdCBpcyBub3QgaXRlcmFibGUuXCIgOiBcIlN5bWJvbC5pdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX3JlYWQobywgbikge1xyXG4gICAgdmFyIG0gPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdO1xyXG4gICAgaWYgKCFtKSByZXR1cm4gbztcclxuICAgIHZhciBpID0gbS5jYWxsKG8pLCByLCBhciA9IFtdLCBlO1xyXG4gICAgdHJ5IHtcclxuICAgICAgICB3aGlsZSAoKG4gPT09IHZvaWQgMCB8fCBuLS0gPiAwKSAmJiAhKHIgPSBpLm5leHQoKSkuZG9uZSkgYXIucHVzaChyLnZhbHVlKTtcclxuICAgIH1cclxuICAgIGNhdGNoIChlcnJvcikgeyBlID0geyBlcnJvcjogZXJyb3IgfTsgfVxyXG4gICAgZmluYWxseSB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgaWYgKHIgJiYgIXIuZG9uZSAmJiAobSA9IGlbXCJyZXR1cm5cIl0pKSBtLmNhbGwoaSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZpbmFsbHkgeyBpZiAoZSkgdGhyb3cgZS5lcnJvcjsgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGFyO1xyXG59XHJcblxyXG4vKiogQGRlcHJlY2F0ZWQgKi9cclxuZXhwb3J0IGZ1bmN0aW9uIF9fc3ByZWFkKCkge1xyXG4gICAgZm9yICh2YXIgYXIgPSBbXSwgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspXHJcbiAgICAgICAgYXIgPSBhci5jb25jYXQoX19yZWFkKGFyZ3VtZW50c1tpXSkpO1xyXG4gICAgcmV0dXJuIGFyO1xyXG59XHJcblxyXG4vKiogQGRlcHJlY2F0ZWQgKi9cclxuZXhwb3J0IGZ1bmN0aW9uIF9fc3ByZWFkQXJyYXlzKCkge1xyXG4gICAgZm9yICh2YXIgcyA9IDAsIGkgPSAwLCBpbCA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBpbDsgaSsrKSBzICs9IGFyZ3VtZW50c1tpXS5sZW5ndGg7XHJcbiAgICBmb3IgKHZhciByID0gQXJyYXkocyksIGsgPSAwLCBpID0gMDsgaSA8IGlsOyBpKyspXHJcbiAgICAgICAgZm9yICh2YXIgYSA9IGFyZ3VtZW50c1tpXSwgaiA9IDAsIGpsID0gYS5sZW5ndGg7IGogPCBqbDsgaisrLCBrKyspXHJcbiAgICAgICAgICAgIHJba10gPSBhW2pdO1xyXG4gICAgcmV0dXJuIHI7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX3NwcmVhZEFycmF5KHRvLCBmcm9tLCBwYWNrKSB7XHJcbiAgICBpZiAocGFjayB8fCBhcmd1bWVudHMubGVuZ3RoID09PSAyKSBmb3IgKHZhciBpID0gMCwgbCA9IGZyb20ubGVuZ3RoLCBhcjsgaSA8IGw7IGkrKykge1xyXG4gICAgICAgIGlmIChhciB8fCAhKGkgaW4gZnJvbSkpIHtcclxuICAgICAgICAgICAgaWYgKCFhcikgYXIgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChmcm9tLCAwLCBpKTtcclxuICAgICAgICAgICAgYXJbaV0gPSBmcm9tW2ldO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiB0by5jb25jYXQoYXIgfHwgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZnJvbSkpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19hd2FpdCh2KSB7XHJcbiAgICByZXR1cm4gdGhpcyBpbnN0YW5jZW9mIF9fYXdhaXQgPyAodGhpcy52ID0gdiwgdGhpcykgOiBuZXcgX19hd2FpdCh2KTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fYXN5bmNHZW5lcmF0b3IodGhpc0FyZywgX2FyZ3VtZW50cywgZ2VuZXJhdG9yKSB7XHJcbiAgICBpZiAoIVN5bWJvbC5hc3luY0l0ZXJhdG9yKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3ltYm9sLmFzeW5jSXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xyXG4gICAgdmFyIGcgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSksIGksIHEgPSBbXTtcclxuICAgIHJldHVybiBpID0ge30sIHZlcmIoXCJuZXh0XCIpLCB2ZXJiKFwidGhyb3dcIiksIHZlcmIoXCJyZXR1cm5cIiksIGlbU3ltYm9sLmFzeW5jSXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSwgaTtcclxuICAgIGZ1bmN0aW9uIHZlcmIobikgeyBpZiAoZ1tuXSkgaVtuXSA9IGZ1bmN0aW9uICh2KSB7IHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAoYSwgYikgeyBxLnB1c2goW24sIHYsIGEsIGJdKSA+IDEgfHwgcmVzdW1lKG4sIHYpOyB9KTsgfTsgfVxyXG4gICAgZnVuY3Rpb24gcmVzdW1lKG4sIHYpIHsgdHJ5IHsgc3RlcChnW25dKHYpKTsgfSBjYXRjaCAoZSkgeyBzZXR0bGUocVswXVszXSwgZSk7IH0gfVxyXG4gICAgZnVuY3Rpb24gc3RlcChyKSB7IHIudmFsdWUgaW5zdGFuY2VvZiBfX2F3YWl0ID8gUHJvbWlzZS5yZXNvbHZlKHIudmFsdWUudikudGhlbihmdWxmaWxsLCByZWplY3QpIDogc2V0dGxlKHFbMF1bMl0sIHIpOyB9XHJcbiAgICBmdW5jdGlvbiBmdWxmaWxsKHZhbHVlKSB7IHJlc3VtZShcIm5leHRcIiwgdmFsdWUpOyB9XHJcbiAgICBmdW5jdGlvbiByZWplY3QodmFsdWUpIHsgcmVzdW1lKFwidGhyb3dcIiwgdmFsdWUpOyB9XHJcbiAgICBmdW5jdGlvbiBzZXR0bGUoZiwgdikgeyBpZiAoZih2KSwgcS5zaGlmdCgpLCBxLmxlbmd0aCkgcmVzdW1lKHFbMF1bMF0sIHFbMF1bMV0pOyB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2FzeW5jRGVsZWdhdG9yKG8pIHtcclxuICAgIHZhciBpLCBwO1xyXG4gICAgcmV0dXJuIGkgPSB7fSwgdmVyYihcIm5leHRcIiksIHZlcmIoXCJ0aHJvd1wiLCBmdW5jdGlvbiAoZSkgeyB0aHJvdyBlOyB9KSwgdmVyYihcInJldHVyblwiKSwgaVtTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSwgaTtcclxuICAgIGZ1bmN0aW9uIHZlcmIobiwgZikgeyBpW25dID0gb1tuXSA/IGZ1bmN0aW9uICh2KSB7IHJldHVybiAocCA9ICFwKSA/IHsgdmFsdWU6IF9fYXdhaXQob1tuXSh2KSksIGRvbmU6IG4gPT09IFwicmV0dXJuXCIgfSA6IGYgPyBmKHYpIDogdjsgfSA6IGY7IH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fYXN5bmNWYWx1ZXMobykge1xyXG4gICAgaWYgKCFTeW1ib2wuYXN5bmNJdGVyYXRvcikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN5bWJvbC5hc3luY0l0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcclxuICAgIHZhciBtID0gb1tTeW1ib2wuYXN5bmNJdGVyYXRvcl0sIGk7XHJcbiAgICByZXR1cm4gbSA/IG0uY2FsbChvKSA6IChvID0gdHlwZW9mIF9fdmFsdWVzID09PSBcImZ1bmN0aW9uXCIgPyBfX3ZhbHVlcyhvKSA6IG9bU3ltYm9sLml0ZXJhdG9yXSgpLCBpID0ge30sIHZlcmIoXCJuZXh0XCIpLCB2ZXJiKFwidGhyb3dcIiksIHZlcmIoXCJyZXR1cm5cIiksIGlbU3ltYm9sLmFzeW5jSXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSwgaSk7XHJcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgaVtuXSA9IG9bbl0gJiYgZnVuY3Rpb24gKHYpIHsgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHsgdiA9IG9bbl0odiksIHNldHRsZShyZXNvbHZlLCByZWplY3QsIHYuZG9uZSwgdi52YWx1ZSk7IH0pOyB9OyB9XHJcbiAgICBmdW5jdGlvbiBzZXR0bGUocmVzb2x2ZSwgcmVqZWN0LCBkLCB2KSB7IFByb21pc2UucmVzb2x2ZSh2KS50aGVuKGZ1bmN0aW9uKHYpIHsgcmVzb2x2ZSh7IHZhbHVlOiB2LCBkb25lOiBkIH0pOyB9LCByZWplY3QpOyB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX21ha2VUZW1wbGF0ZU9iamVjdChjb29rZWQsIHJhdykge1xyXG4gICAgaWYgKE9iamVjdC5kZWZpbmVQcm9wZXJ0eSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkoY29va2VkLCBcInJhd1wiLCB7IHZhbHVlOiByYXcgfSk7IH0gZWxzZSB7IGNvb2tlZC5yYXcgPSByYXc7IH1cclxuICAgIHJldHVybiBjb29rZWQ7XHJcbn07XHJcblxyXG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCB2KSB7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XHJcbn0pIDogZnVuY3Rpb24obywgdikge1xyXG4gICAgb1tcImRlZmF1bHRcIl0gPSB2O1xyXG59O1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9faW1wb3J0U3Rhcihtb2QpIHtcclxuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XHJcbiAgICB2YXIgcmVzdWx0ID0ge307XHJcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoayAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwgayk7XHJcbiAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9faW1wb3J0RGVmYXVsdChtb2QpIHtcclxuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgZGVmYXVsdDogbW9kIH07XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHJlY2VpdmVyLCBzdGF0ZSwga2luZCwgZikge1xyXG4gICAgaWYgKGtpbmQgPT09IFwiYVwiICYmICFmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJpdmF0ZSBhY2Nlc3NvciB3YXMgZGVmaW5lZCB3aXRob3V0IGEgZ2V0dGVyXCIpO1xyXG4gICAgaWYgKHR5cGVvZiBzdGF0ZSA9PT0gXCJmdW5jdGlvblwiID8gcmVjZWl2ZXIgIT09IHN0YXRlIHx8ICFmIDogIXN0YXRlLmhhcyhyZWNlaXZlcikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgcmVhZCBwcml2YXRlIG1lbWJlciBmcm9tIGFuIG9iamVjdCB3aG9zZSBjbGFzcyBkaWQgbm90IGRlY2xhcmUgaXRcIik7XHJcbiAgICByZXR1cm4ga2luZCA9PT0gXCJtXCIgPyBmIDoga2luZCA9PT0gXCJhXCIgPyBmLmNhbGwocmVjZWl2ZXIpIDogZiA/IGYudmFsdWUgOiBzdGF0ZS5nZXQocmVjZWl2ZXIpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19jbGFzc1ByaXZhdGVGaWVsZFNldChyZWNlaXZlciwgc3RhdGUsIHZhbHVlLCBraW5kLCBmKSB7XHJcbiAgICBpZiAoa2luZCA9PT0gXCJtXCIpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIG1ldGhvZCBpcyBub3Qgd3JpdGFibGVcIik7XHJcbiAgICBpZiAoa2luZCA9PT0gXCJhXCIgJiYgIWYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIGFjY2Vzc29yIHdhcyBkZWZpbmVkIHdpdGhvdXQgYSBzZXR0ZXJcIik7XHJcbiAgICBpZiAodHlwZW9mIHN0YXRlID09PSBcImZ1bmN0aW9uXCIgPyByZWNlaXZlciAhPT0gc3RhdGUgfHwgIWYgOiAhc3RhdGUuaGFzKHJlY2VpdmVyKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCB3cml0ZSBwcml2YXRlIG1lbWJlciB0byBhbiBvYmplY3Qgd2hvc2UgY2xhc3MgZGlkIG5vdCBkZWNsYXJlIGl0XCIpO1xyXG4gICAgcmV0dXJuIChraW5kID09PSBcImFcIiA/IGYuY2FsbChyZWNlaXZlciwgdmFsdWUpIDogZiA/IGYudmFsdWUgPSB2YWx1ZSA6IHN0YXRlLnNldChyZWNlaXZlciwgdmFsdWUpKSwgdmFsdWU7XHJcbn1cclxuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy5cbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuICogVEhFIFNPRlRXQVJFLlxuICovXG52YXIgTURDRm91bmRhdGlvbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNRENGb3VuZGF0aW9uKGFkYXB0ZXIpIHtcbiAgICAgICAgaWYgKGFkYXB0ZXIgPT09IHZvaWQgMCkgeyBhZGFwdGVyID0ge307IH1cbiAgICAgICAgdGhpcy5hZGFwdGVyID0gYWRhcHRlcjtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1EQ0ZvdW5kYXRpb24sIFwiY3NzQ2xhc3Nlc1wiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgLy8gQ2xhc3NlcyBleHRlbmRpbmcgTURDRm91bmRhdGlvbiBzaG91bGQgaW1wbGVtZW50IHRoaXMgbWV0aG9kIHRvIHJldHVybiBhbiBvYmplY3Qgd2hpY2ggZXhwb3J0cyBldmVyeVxuICAgICAgICAgICAgLy8gQ1NTIGNsYXNzIHRoZSBmb3VuZGF0aW9uIGNsYXNzIG5lZWRzIGFzIGEgcHJvcGVydHkuIGUuZy4ge0FDVElWRTogJ21kYy1jb21wb25lbnQtLWFjdGl2ZSd9XG4gICAgICAgICAgICByZXR1cm4ge307XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTURDRm91bmRhdGlvbiwgXCJzdHJpbmdzXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvLyBDbGFzc2VzIGV4dGVuZGluZyBNRENGb3VuZGF0aW9uIHNob3VsZCBpbXBsZW1lbnQgdGhpcyBtZXRob2QgdG8gcmV0dXJuIGFuIG9iamVjdCB3aGljaCBleHBvcnRzIGFsbFxuICAgICAgICAgICAgLy8gc2VtYW50aWMgc3RyaW5ncyBhcyBjb25zdGFudHMuIGUuZy4ge0FSSUFfUk9MRTogJ3RhYmxpc3QnfVxuICAgICAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1EQ0ZvdW5kYXRpb24sIFwibnVtYmVyc1wiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgLy8gQ2xhc3NlcyBleHRlbmRpbmcgTURDRm91bmRhdGlvbiBzaG91bGQgaW1wbGVtZW50IHRoaXMgbWV0aG9kIHRvIHJldHVybiBhbiBvYmplY3Qgd2hpY2ggZXhwb3J0cyBhbGxcbiAgICAgICAgICAgIC8vIG9mIGl0cyBzZW1hbnRpYyBudW1iZXJzIGFzIGNvbnN0YW50cy4gZS5nLiB7QU5JTUFUSU9OX0RFTEFZX01TOiAzNTB9XG4gICAgICAgICAgICByZXR1cm4ge307XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTURDRm91bmRhdGlvbiwgXCJkZWZhdWx0QWRhcHRlclwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgLy8gQ2xhc3NlcyBleHRlbmRpbmcgTURDRm91bmRhdGlvbiBtYXkgY2hvb3NlIHRvIGltcGxlbWVudCB0aGlzIGdldHRlciBpbiBvcmRlciB0byBwcm92aWRlIGEgY29udmVuaWVudFxuICAgICAgICAgICAgLy8gd2F5IG9mIHZpZXdpbmcgdGhlIG5lY2Vzc2FyeSBtZXRob2RzIG9mIGFuIGFkYXB0ZXIuIEluIHRoZSBmdXR1cmUsIHRoaXMgY291bGQgYWxzbyBiZSB1c2VkIGZvciBhZGFwdGVyXG4gICAgICAgICAgICAvLyB2YWxpZGF0aW9uLlxuICAgICAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgTURDRm91bmRhdGlvbi5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gU3ViY2xhc3NlcyBzaG91bGQgb3ZlcnJpZGUgdGhpcyBtZXRob2QgdG8gcGVyZm9ybSBpbml0aWFsaXphdGlvbiByb3V0aW5lcyAocmVnaXN0ZXJpbmcgZXZlbnRzLCBldGMuKVxuICAgIH07XG4gICAgTURDRm91bmRhdGlvbi5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gU3ViY2xhc3NlcyBzaG91bGQgb3ZlcnJpZGUgdGhpcyBtZXRob2QgdG8gcGVyZm9ybSBkZS1pbml0aWFsaXphdGlvbiByb3V0aW5lcyAoZGUtcmVnaXN0ZXJpbmcgZXZlbnRzLCBldGMuKVxuICAgIH07XG4gICAgcmV0dXJuIE1EQ0ZvdW5kYXRpb247XG59KCkpO1xuZXhwb3J0IHsgTURDRm91bmRhdGlvbiB9O1xuLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLWRlZmF1bHQtZXhwb3J0IE5lZWRlZCBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eSB3aXRoIE1EQyBXZWIgdjAuNDQuMCBhbmQgZWFybGllci5cbmV4cG9ydCBkZWZhdWx0IE1EQ0ZvdW5kYXRpb247XG4vLyMgc291cmNlTWFwcGluZ1VSTD1mb3VuZGF0aW9uLmpzLm1hcCIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuXG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICpcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4gKiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbiAqIFRIRSBTT0ZUV0FSRS5cbiAqL1xuaW1wb3J0IHsgX19yZWFkLCBfX3NwcmVhZEFycmF5IH0gZnJvbSBcInRzbGliXCI7XG5pbXBvcnQgeyBNRENGb3VuZGF0aW9uIH0gZnJvbSAnLi9mb3VuZGF0aW9uJztcbnZhciBNRENDb21wb25lbnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTURDQ29tcG9uZW50KHJvb3QsIGZvdW5kYXRpb24pIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAyOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIGFyZ3NbX2kgLSAyXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yb290ID0gcm9vdDtcbiAgICAgICAgdGhpcy5pbml0aWFsaXplLmFwcGx5KHRoaXMsIF9fc3ByZWFkQXJyYXkoW10sIF9fcmVhZChhcmdzKSkpO1xuICAgICAgICAvLyBOb3RlIHRoYXQgd2UgaW5pdGlhbGl6ZSBmb3VuZGF0aW9uIGhlcmUgYW5kIG5vdCB3aXRoaW4gdGhlIGNvbnN0cnVjdG9yJ3NcbiAgICAgICAgLy8gZGVmYXVsdCBwYXJhbSBzbyB0aGF0IHRoaXMucm9vdCBpcyBkZWZpbmVkIGFuZCBjYW4gYmUgdXNlZCB3aXRoaW4gdGhlXG4gICAgICAgIC8vIGZvdW5kYXRpb24gY2xhc3MuXG4gICAgICAgIHRoaXMuZm91bmRhdGlvbiA9XG4gICAgICAgICAgICBmb3VuZGF0aW9uID09PSB1bmRlZmluZWQgPyB0aGlzLmdldERlZmF1bHRGb3VuZGF0aW9uKCkgOiBmb3VuZGF0aW9uO1xuICAgICAgICB0aGlzLmZvdW5kYXRpb24uaW5pdCgpO1xuICAgICAgICB0aGlzLmluaXRpYWxTeW5jV2l0aERPTSgpO1xuICAgIH1cbiAgICBNRENDb21wb25lbnQuYXR0YWNoVG8gPSBmdW5jdGlvbiAocm9vdCkge1xuICAgICAgICAvLyBTdWJjbGFzc2VzIHdoaWNoIGV4dGVuZCBNRENCYXNlIHNob3VsZCBwcm92aWRlIGFuIGF0dGFjaFRvKCkgbWV0aG9kIHRoYXQgdGFrZXMgYSByb290IGVsZW1lbnQgYW5kXG4gICAgICAgIC8vIHJldHVybnMgYW4gaW5zdGFudGlhdGVkIGNvbXBvbmVudCB3aXRoIGl0cyByb290IHNldCB0byB0aGF0IGVsZW1lbnQuIEFsc28gbm90ZSB0aGF0IGluIHRoZSBjYXNlcyBvZlxuICAgICAgICAvLyBzdWJjbGFzc2VzLCBhbiBleHBsaWNpdCBmb3VuZGF0aW9uIGNsYXNzIHdpbGwgbm90IGhhdmUgdG8gYmUgcGFzc2VkIGluOyBpdCB3aWxsIHNpbXBseSBiZSBpbml0aWFsaXplZFxuICAgICAgICAvLyBmcm9tIGdldERlZmF1bHRGb3VuZGF0aW9uKCkuXG4gICAgICAgIHJldHVybiBuZXcgTURDQ29tcG9uZW50KHJvb3QsIG5ldyBNRENGb3VuZGF0aW9uKHt9KSk7XG4gICAgfTtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dDogbWV0aG9kIHBhcmFtIG9ubHkgZXhpc3RzIGZvciB0eXBpbmcgcHVycG9zZXM7IGl0IGRvZXMgbm90IG5lZWQgdG8gYmUgdW5pdCB0ZXN0ZWQgKi9cbiAgICBNRENDb21wb25lbnQucHJvdG90eXBlLmluaXRpYWxpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfYXJncyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgX2FyZ3NbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgfVxuICAgICAgICAvLyBTdWJjbGFzc2VzIGNhbiBvdmVycmlkZSB0aGlzIHRvIGRvIGFueSBhZGRpdGlvbmFsIHNldHVwIHdvcmsgdGhhdCB3b3VsZCBiZSBjb25zaWRlcmVkIHBhcnQgb2YgYVxuICAgICAgICAvLyBcImNvbnN0cnVjdG9yXCIuIEVzc2VudGlhbGx5LCBpdCBpcyBhIGhvb2sgaW50byB0aGUgcGFyZW50IGNvbnN0cnVjdG9yIGJlZm9yZSB0aGUgZm91bmRhdGlvbiBpc1xuICAgICAgICAvLyBpbml0aWFsaXplZC4gQW55IGFkZGl0aW9uYWwgYXJndW1lbnRzIGJlc2lkZXMgcm9vdCBhbmQgZm91bmRhdGlvbiB3aWxsIGJlIHBhc3NlZCBpbiBoZXJlLlxuICAgIH07XG4gICAgTURDQ29tcG9uZW50LnByb3RvdHlwZS5nZXREZWZhdWx0Rm91bmRhdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gU3ViY2xhc3NlcyBtdXN0IG92ZXJyaWRlIHRoaXMgbWV0aG9kIHRvIHJldHVybiBhIHByb3Blcmx5IGNvbmZpZ3VyZWQgZm91bmRhdGlvbiBjbGFzcyBmb3IgdGhlXG4gICAgICAgIC8vIGNvbXBvbmVudC5cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTdWJjbGFzc2VzIG11c3Qgb3ZlcnJpZGUgZ2V0RGVmYXVsdEZvdW5kYXRpb24gdG8gcmV0dXJuIGEgcHJvcGVybHkgY29uZmlndXJlZCAnICtcbiAgICAgICAgICAgICdmb3VuZGF0aW9uIGNsYXNzJyk7XG4gICAgfTtcbiAgICBNRENDb21wb25lbnQucHJvdG90eXBlLmluaXRpYWxTeW5jV2l0aERPTSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gU3ViY2xhc3NlcyBzaG91bGQgb3ZlcnJpZGUgdGhpcyBtZXRob2QgaWYgdGhleSBuZWVkIHRvIHBlcmZvcm0gd29yayB0byBzeW5jaHJvbml6ZSB3aXRoIGEgaG9zdCBET01cbiAgICAgICAgLy8gb2JqZWN0LiBBbiBleGFtcGxlIG9mIHRoaXMgd291bGQgYmUgYSBmb3JtIGNvbnRyb2wgd3JhcHBlciB0aGF0IG5lZWRzIHRvIHN5bmNocm9uaXplIGl0cyBpbnRlcm5hbCBzdGF0ZVxuICAgICAgICAvLyB0byBzb21lIHByb3BlcnR5IG9yIGF0dHJpYnV0ZSBvZiB0aGUgaG9zdCBET00uIFBsZWFzZSBub3RlOiB0aGlzIGlzICpub3QqIHRoZSBwbGFjZSB0byBwZXJmb3JtIERPTVxuICAgICAgICAvLyByZWFkcy93cml0ZXMgdGhhdCB3b3VsZCBjYXVzZSBsYXlvdXQgLyBwYWludCwgYXMgdGhpcyBpcyBjYWxsZWQgc3luY2hyb25vdXNseSBmcm9tIHdpdGhpbiB0aGUgY29uc3RydWN0b3IuXG4gICAgfTtcbiAgICBNRENDb21wb25lbnQucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIFN1YmNsYXNzZXMgbWF5IGltcGxlbWVudCB0aGlzIG1ldGhvZCB0byByZWxlYXNlIGFueSByZXNvdXJjZXMgLyBkZXJlZ2lzdGVyIGFueSBsaXN0ZW5lcnMgdGhleSBoYXZlXG4gICAgICAgIC8vIGF0dGFjaGVkLiBBbiBleGFtcGxlIG9mIHRoaXMgbWlnaHQgYmUgZGVyZWdpc3RlcmluZyBhIHJlc2l6ZSBldmVudCBmcm9tIHRoZSB3aW5kb3cgb2JqZWN0LlxuICAgICAgICB0aGlzLmZvdW5kYXRpb24uZGVzdHJveSgpO1xuICAgIH07XG4gICAgTURDQ29tcG9uZW50LnByb3RvdHlwZS5saXN0ZW4gPSBmdW5jdGlvbiAoZXZ0VHlwZSwgaGFuZGxlciwgb3B0aW9ucykge1xuICAgICAgICB0aGlzLnJvb3QuYWRkRXZlbnRMaXN0ZW5lcihldnRUeXBlLCBoYW5kbGVyLCBvcHRpb25zKTtcbiAgICB9O1xuICAgIE1EQ0NvbXBvbmVudC5wcm90b3R5cGUudW5saXN0ZW4gPSBmdW5jdGlvbiAoZXZ0VHlwZSwgaGFuZGxlciwgb3B0aW9ucykge1xuICAgICAgICB0aGlzLnJvb3QucmVtb3ZlRXZlbnRMaXN0ZW5lcihldnRUeXBlLCBoYW5kbGVyLCBvcHRpb25zKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEZpcmVzIGEgY3Jvc3MtYnJvd3Nlci1jb21wYXRpYmxlIGN1c3RvbSBldmVudCBmcm9tIHRoZSBjb21wb25lbnQgcm9vdCBvZiB0aGUgZ2l2ZW4gdHlwZSwgd2l0aCB0aGUgZ2l2ZW4gZGF0YS5cbiAgICAgKi9cbiAgICBNRENDb21wb25lbnQucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbiAoZXZ0VHlwZSwgZXZ0RGF0YSwgc2hvdWxkQnViYmxlKSB7XG4gICAgICAgIGlmIChzaG91bGRCdWJibGUgPT09IHZvaWQgMCkgeyBzaG91bGRCdWJibGUgPSBmYWxzZTsgfVxuICAgICAgICB2YXIgZXZ0O1xuICAgICAgICBpZiAodHlwZW9mIEN1c3RvbUV2ZW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBldnQgPSBuZXcgQ3VzdG9tRXZlbnQoZXZ0VHlwZSwge1xuICAgICAgICAgICAgICAgIGJ1YmJsZXM6IHNob3VsZEJ1YmJsZSxcbiAgICAgICAgICAgICAgICBkZXRhaWw6IGV2dERhdGEsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGV2dCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdDdXN0b21FdmVudCcpO1xuICAgICAgICAgICAgZXZ0LmluaXRDdXN0b21FdmVudChldnRUeXBlLCBzaG91bGRCdWJibGUsIGZhbHNlLCBldnREYXRhKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJvb3QuZGlzcGF0Y2hFdmVudChldnQpO1xuICAgIH07XG4gICAgcmV0dXJuIE1EQ0NvbXBvbmVudDtcbn0oKSk7XG5leHBvcnQgeyBNRENDb21wb25lbnQgfTtcbi8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpuby1kZWZhdWx0LWV4cG9ydCBOZWVkZWQgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHkgd2l0aCBNREMgV2ViIHYwLjQ0LjAgYW5kIGVhcmxpZXIuXG5leHBvcnQgZGVmYXVsdCBNRENDb21wb25lbnQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb21wb25lbnQuanMubWFwIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTkgR29vZ2xlIEluYy5cbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuICogVEhFIFNPRlRXQVJFLlxuICovXG4vKipcbiAqIERldGVybWluZSB3aGV0aGVyIHRoZSBjdXJyZW50IGJyb3dzZXIgc3VwcG9ydHMgcGFzc2l2ZSBldmVudCBsaXN0ZW5lcnMsIGFuZFxuICogaWYgc28sIHVzZSB0aGVtLlxuICovXG5leHBvcnQgZnVuY3Rpb24gYXBwbHlQYXNzaXZlKGdsb2JhbE9iaikge1xuICAgIGlmIChnbG9iYWxPYmogPT09IHZvaWQgMCkgeyBnbG9iYWxPYmogPSB3aW5kb3c7IH1cbiAgICByZXR1cm4gc3VwcG9ydHNQYXNzaXZlT3B0aW9uKGdsb2JhbE9iaikgP1xuICAgICAgICB7IHBhc3NpdmU6IHRydWUgfSA6XG4gICAgICAgIGZhbHNlO1xufVxuZnVuY3Rpb24gc3VwcG9ydHNQYXNzaXZlT3B0aW9uKGdsb2JhbE9iaikge1xuICAgIGlmIChnbG9iYWxPYmogPT09IHZvaWQgMCkgeyBnbG9iYWxPYmogPSB3aW5kb3c7IH1cbiAgICAvLyBTZWVcbiAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvRXZlbnRUYXJnZXQvYWRkRXZlbnRMaXN0ZW5lclxuICAgIHZhciBwYXNzaXZlU3VwcG9ydGVkID0gZmFsc2U7XG4gICAgdHJ5IHtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSB7XG4gICAgICAgICAgICAvLyBUaGlzIGZ1bmN0aW9uIHdpbGwgYmUgY2FsbGVkIHdoZW4gdGhlIGJyb3dzZXJcbiAgICAgICAgICAgIC8vIGF0dGVtcHRzIHRvIGFjY2VzcyB0aGUgcGFzc2l2ZSBwcm9wZXJ0eS5cbiAgICAgICAgICAgIGdldCBwYXNzaXZlKCkge1xuICAgICAgICAgICAgICAgIHBhc3NpdmVTdXBwb3J0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGhhbmRsZXIgPSBmdW5jdGlvbiAoKSB7IH07XG4gICAgICAgIGdsb2JhbE9iai5kb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCd0ZXN0JywgaGFuZGxlciwgb3B0aW9ucyk7XG4gICAgICAgIGdsb2JhbE9iai5kb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCd0ZXN0JywgaGFuZGxlciwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgcGFzc2l2ZVN1cHBvcnRlZCA9IGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gcGFzc2l2ZVN1cHBvcnRlZDtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWV2ZW50cy5qcy5tYXAiLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOCBHb29nbGUgSW5jLlxuICpcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbiAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuICogYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4gKiBUSEUgU09GVFdBUkUuXG4gKi9cbi8qKlxuICogQGZpbGVvdmVydmlldyBBIFwicG9ueWZpbGxcIiBpcyBhIHBvbHlmaWxsIHRoYXQgZG9lc24ndCBtb2RpZnkgdGhlIGdsb2JhbCBwcm90b3R5cGUgY2hhaW4uXG4gKiBUaGlzIG1ha2VzIHBvbnlmaWxscyBzYWZlciB0aGFuIHRyYWRpdGlvbmFsIHBvbHlmaWxscywgZXNwZWNpYWxseSBmb3IgbGlicmFyaWVzIGxpa2UgTURDLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY2xvc2VzdChlbGVtZW50LCBzZWxlY3Rvcikge1xuICAgIGlmIChlbGVtZW50LmNsb3Nlc3QpIHtcbiAgICAgICAgcmV0dXJuIGVsZW1lbnQuY2xvc2VzdChzZWxlY3Rvcik7XG4gICAgfVxuICAgIHZhciBlbCA9IGVsZW1lbnQ7XG4gICAgd2hpbGUgKGVsKSB7XG4gICAgICAgIGlmIChtYXRjaGVzKGVsLCBzZWxlY3RvcikpIHtcbiAgICAgICAgICAgIHJldHVybiBlbDtcbiAgICAgICAgfVxuICAgICAgICBlbCA9IGVsLnBhcmVudEVsZW1lbnQ7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuZXhwb3J0IGZ1bmN0aW9uIG1hdGNoZXMoZWxlbWVudCwgc2VsZWN0b3IpIHtcbiAgICB2YXIgbmF0aXZlTWF0Y2hlcyA9IGVsZW1lbnQubWF0Y2hlc1xuICAgICAgICB8fCBlbGVtZW50LndlYmtpdE1hdGNoZXNTZWxlY3RvclxuICAgICAgICB8fCBlbGVtZW50Lm1zTWF0Y2hlc1NlbGVjdG9yO1xuICAgIHJldHVybiBuYXRpdmVNYXRjaGVzLmNhbGwoZWxlbWVudCwgc2VsZWN0b3IpO1xufVxuLyoqXG4gKiBVc2VkIHRvIGNvbXB1dGUgdGhlIGVzdGltYXRlZCBzY3JvbGwgd2lkdGggb2YgZWxlbWVudHMuIFdoZW4gYW4gZWxlbWVudCBpc1xuICogaGlkZGVuIGR1ZSB0byBkaXNwbGF5OiBub25lOyBiZWluZyBhcHBsaWVkIHRvIGEgcGFyZW50IGVsZW1lbnQsIHRoZSB3aWR0aCBpc1xuICogcmV0dXJuZWQgYXMgMC4gSG93ZXZlciwgdGhlIGVsZW1lbnQgd2lsbCBoYXZlIGEgdHJ1ZSB3aWR0aCBvbmNlIG5vIGxvbmdlclxuICogaW5zaWRlIGEgZGlzcGxheTogbm9uZSBjb250ZXh0LiBUaGlzIG1ldGhvZCBjb21wdXRlcyBhbiBlc3RpbWF0ZWQgd2lkdGggd2hlblxuICogdGhlIGVsZW1lbnQgaXMgaGlkZGVuIG9yIHJldHVybnMgdGhlIHRydWUgd2lkdGggd2hlbiB0aGUgZWxlbWVudCBpcyB2aXNibGUuXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnQgdGhlIGVsZW1lbnQgd2hvc2Ugd2lkdGggdG8gZXN0aW1hdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVzdGltYXRlU2Nyb2xsV2lkdGgoZWxlbWVudCkge1xuICAgIC8vIENoZWNrIHRoZSBvZmZzZXRQYXJlbnQuIElmIHRoZSBlbGVtZW50IGluaGVyaXRzIGRpc3BsYXk6IG5vbmUgZnJvbSBhbnlcbiAgICAvLyBwYXJlbnQsIHRoZSBvZmZzZXRQYXJlbnQgcHJvcGVydHkgd2lsbCBiZSBudWxsIChzZWVcbiAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvSFRNTEVsZW1lbnQvb2Zmc2V0UGFyZW50KS5cbiAgICAvLyBUaGlzIGNoZWNrIGVuc3VyZXMgd2Ugb25seSBjbG9uZSB0aGUgbm9kZSB3aGVuIG5lY2Vzc2FyeS5cbiAgICB2YXIgaHRtbEVsID0gZWxlbWVudDtcbiAgICBpZiAoaHRtbEVsLm9mZnNldFBhcmVudCAhPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gaHRtbEVsLnNjcm9sbFdpZHRoO1xuICAgIH1cbiAgICB2YXIgY2xvbmUgPSBodG1sRWwuY2xvbmVOb2RlKHRydWUpO1xuICAgIGNsb25lLnN0eWxlLnNldFByb3BlcnR5KCdwb3NpdGlvbicsICdhYnNvbHV0ZScpO1xuICAgIGNsb25lLnN0eWxlLnNldFByb3BlcnR5KCd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlKC05OTk5cHgsIC05OTk5cHgpJyk7XG4gICAgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmFwcGVuZENoaWxkKGNsb25lKTtcbiAgICB2YXIgc2Nyb2xsV2lkdGggPSBjbG9uZS5zY3JvbGxXaWR0aDtcbiAgICBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQucmVtb3ZlQ2hpbGQoY2xvbmUpO1xuICAgIHJldHVybiBzY3JvbGxXaWR0aDtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBvbnlmaWxsLmpzLm1hcCIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuXG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICpcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4gKiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbiAqIFRIRSBTT0ZUV0FSRS5cbiAqL1xuZXhwb3J0IHZhciBjc3NDbGFzc2VzID0ge1xuICAgIC8vIFJpcHBsZSBpcyBhIHNwZWNpYWwgY2FzZSB3aGVyZSB0aGUgXCJyb290XCIgY29tcG9uZW50IGlzIHJlYWxseSBhIFwibWl4aW5cIiBvZiBzb3J0cyxcbiAgICAvLyBnaXZlbiB0aGF0IGl0J3MgYW4gJ3VwZ3JhZGUnIHRvIGFuIGV4aXN0aW5nIGNvbXBvbmVudC4gVGhhdCBiZWluZyBzYWlkIGl0IGlzIHRoZSByb290XG4gICAgLy8gQ1NTIGNsYXNzIHRoYXQgYWxsIG90aGVyIENTUyBjbGFzc2VzIGRlcml2ZSBmcm9tLlxuICAgIEJHX0ZPQ1VTRUQ6ICdtZGMtcmlwcGxlLXVwZ3JhZGVkLS1iYWNrZ3JvdW5kLWZvY3VzZWQnLFxuICAgIEZHX0FDVElWQVRJT046ICdtZGMtcmlwcGxlLXVwZ3JhZGVkLS1mb3JlZ3JvdW5kLWFjdGl2YXRpb24nLFxuICAgIEZHX0RFQUNUSVZBVElPTjogJ21kYy1yaXBwbGUtdXBncmFkZWQtLWZvcmVncm91bmQtZGVhY3RpdmF0aW9uJyxcbiAgICBST09UOiAnbWRjLXJpcHBsZS11cGdyYWRlZCcsXG4gICAgVU5CT1VOREVEOiAnbWRjLXJpcHBsZS11cGdyYWRlZC0tdW5ib3VuZGVkJyxcbn07XG5leHBvcnQgdmFyIHN0cmluZ3MgPSB7XG4gICAgVkFSX0ZHX1NDQUxFOiAnLS1tZGMtcmlwcGxlLWZnLXNjYWxlJyxcbiAgICBWQVJfRkdfU0laRTogJy0tbWRjLXJpcHBsZS1mZy1zaXplJyxcbiAgICBWQVJfRkdfVFJBTlNMQVRFX0VORDogJy0tbWRjLXJpcHBsZS1mZy10cmFuc2xhdGUtZW5kJyxcbiAgICBWQVJfRkdfVFJBTlNMQVRFX1NUQVJUOiAnLS1tZGMtcmlwcGxlLWZnLXRyYW5zbGF0ZS1zdGFydCcsXG4gICAgVkFSX0xFRlQ6ICctLW1kYy1yaXBwbGUtbGVmdCcsXG4gICAgVkFSX1RPUDogJy0tbWRjLXJpcHBsZS10b3AnLFxufTtcbmV4cG9ydCB2YXIgbnVtYmVycyA9IHtcbiAgICBERUFDVElWQVRJT05fVElNRU9VVF9NUzogMjI1LFxuICAgIEZHX0RFQUNUSVZBVElPTl9NUzogMTUwLFxuICAgIElOSVRJQUxfT1JJR0lOX1NDQUxFOiAwLjYsXG4gICAgUEFERElORzogMTAsXG4gICAgVEFQX0RFTEFZX01TOiAzMDAsIC8vIERlbGF5IGJldHdlZW4gdG91Y2ggYW5kIHNpbXVsYXRlZCBtb3VzZSBldmVudHMgb24gdG91Y2ggZGV2aWNlc1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbnN0YW50cy5qcy5tYXAiLCIvKipcbiAqIFN0b3JlcyByZXN1bHQgZnJvbSBzdXBwb3J0c0Nzc1ZhcmlhYmxlcyB0byBhdm9pZCByZWR1bmRhbnQgcHJvY2Vzc2luZyB0b1xuICogZGV0ZWN0IENTUyBjdXN0b20gdmFyaWFibGUgc3VwcG9ydC5cbiAqL1xudmFyIHN1cHBvcnRzQ3NzVmFyaWFibGVzXztcbmV4cG9ydCBmdW5jdGlvbiBzdXBwb3J0c0Nzc1ZhcmlhYmxlcyh3aW5kb3dPYmosIGZvcmNlUmVmcmVzaCkge1xuICAgIGlmIChmb3JjZVJlZnJlc2ggPT09IHZvaWQgMCkgeyBmb3JjZVJlZnJlc2ggPSBmYWxzZTsgfVxuICAgIHZhciBDU1MgPSB3aW5kb3dPYmouQ1NTO1xuICAgIHZhciBzdXBwb3J0c0Nzc1ZhcnMgPSBzdXBwb3J0c0Nzc1ZhcmlhYmxlc187XG4gICAgaWYgKHR5cGVvZiBzdXBwb3J0c0Nzc1ZhcmlhYmxlc18gPT09ICdib29sZWFuJyAmJiAhZm9yY2VSZWZyZXNoKSB7XG4gICAgICAgIHJldHVybiBzdXBwb3J0c0Nzc1ZhcmlhYmxlc187XG4gICAgfVxuICAgIHZhciBzdXBwb3J0c0Z1bmN0aW9uUHJlc2VudCA9IENTUyAmJiB0eXBlb2YgQ1NTLnN1cHBvcnRzID09PSAnZnVuY3Rpb24nO1xuICAgIGlmICghc3VwcG9ydHNGdW5jdGlvblByZXNlbnQpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB2YXIgZXhwbGljaXRseVN1cHBvcnRzQ3NzVmFycyA9IENTUy5zdXBwb3J0cygnLS1jc3MtdmFycycsICd5ZXMnKTtcbiAgICAvLyBTZWU6IGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0xNTQ2NjlcbiAgICAvLyBTZWU6IFJFQURNRSBzZWN0aW9uIG9uIFNhZmFyaVxuICAgIHZhciB3ZUFyZUZlYXR1cmVEZXRlY3RpbmdTYWZhcmkxMHBsdXMgPSAoQ1NTLnN1cHBvcnRzKCcoLS1jc3MtdmFyczogeWVzKScpICYmXG4gICAgICAgIENTUy5zdXBwb3J0cygnY29sb3InLCAnIzAwMDAwMDAwJykpO1xuICAgIHN1cHBvcnRzQ3NzVmFycyA9XG4gICAgICAgIGV4cGxpY2l0bHlTdXBwb3J0c0Nzc1ZhcnMgfHwgd2VBcmVGZWF0dXJlRGV0ZWN0aW5nU2FmYXJpMTBwbHVzO1xuICAgIGlmICghZm9yY2VSZWZyZXNoKSB7XG4gICAgICAgIHN1cHBvcnRzQ3NzVmFyaWFibGVzXyA9IHN1cHBvcnRzQ3NzVmFycztcbiAgICB9XG4gICAgcmV0dXJuIHN1cHBvcnRzQ3NzVmFycztcbn1cbmV4cG9ydCBmdW5jdGlvbiBnZXROb3JtYWxpemVkRXZlbnRDb29yZHMoZXZ0LCBwYWdlT2Zmc2V0LCBjbGllbnRSZWN0KSB7XG4gICAgaWYgKCFldnQpIHtcbiAgICAgICAgcmV0dXJuIHsgeDogMCwgeTogMCB9O1xuICAgIH1cbiAgICB2YXIgeCA9IHBhZ2VPZmZzZXQueCwgeSA9IHBhZ2VPZmZzZXQueTtcbiAgICB2YXIgZG9jdW1lbnRYID0geCArIGNsaWVudFJlY3QubGVmdDtcbiAgICB2YXIgZG9jdW1lbnRZID0geSArIGNsaWVudFJlY3QudG9wO1xuICAgIHZhciBub3JtYWxpemVkWDtcbiAgICB2YXIgbm9ybWFsaXplZFk7XG4gICAgLy8gRGV0ZXJtaW5lIHRvdWNoIHBvaW50IHJlbGF0aXZlIHRvIHRoZSByaXBwbGUgY29udGFpbmVyLlxuICAgIGlmIChldnQudHlwZSA9PT0gJ3RvdWNoc3RhcnQnKSB7XG4gICAgICAgIHZhciB0b3VjaEV2ZW50ID0gZXZ0O1xuICAgICAgICBub3JtYWxpemVkWCA9IHRvdWNoRXZlbnQuY2hhbmdlZFRvdWNoZXNbMF0ucGFnZVggLSBkb2N1bWVudFg7XG4gICAgICAgIG5vcm1hbGl6ZWRZID0gdG91Y2hFdmVudC5jaGFuZ2VkVG91Y2hlc1swXS5wYWdlWSAtIGRvY3VtZW50WTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHZhciBtb3VzZUV2ZW50ID0gZXZ0O1xuICAgICAgICBub3JtYWxpemVkWCA9IG1vdXNlRXZlbnQucGFnZVggLSBkb2N1bWVudFg7XG4gICAgICAgIG5vcm1hbGl6ZWRZID0gbW91c2VFdmVudC5wYWdlWSAtIGRvY3VtZW50WTtcbiAgICB9XG4gICAgcmV0dXJuIHsgeDogbm9ybWFsaXplZFgsIHk6IG5vcm1hbGl6ZWRZIH07XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD11dGlsLmpzLm1hcCIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuXG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICpcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4gKiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbiAqIFRIRSBTT0ZUV0FSRS5cbiAqL1xuaW1wb3J0IHsgX19hc3NpZ24sIF9fZXh0ZW5kcywgX192YWx1ZXMgfSBmcm9tIFwidHNsaWJcIjtcbmltcG9ydCB7IE1EQ0ZvdW5kYXRpb24gfSBmcm9tICdAbWF0ZXJpYWwvYmFzZS9mb3VuZGF0aW9uJztcbmltcG9ydCB7IGNzc0NsYXNzZXMsIG51bWJlcnMsIHN0cmluZ3MgfSBmcm9tICcuL2NvbnN0YW50cyc7XG5pbXBvcnQgeyBnZXROb3JtYWxpemVkRXZlbnRDb29yZHMgfSBmcm9tICcuL3V0aWwnO1xuLy8gQWN0aXZhdGlvbiBldmVudHMgcmVnaXN0ZXJlZCBvbiB0aGUgcm9vdCBlbGVtZW50IG9mIGVhY2ggaW5zdGFuY2UgZm9yIGFjdGl2YXRpb25cbnZhciBBQ1RJVkFUSU9OX0VWRU5UX1RZUEVTID0gW1xuICAgICd0b3VjaHN0YXJ0JywgJ3BvaW50ZXJkb3duJywgJ21vdXNlZG93bicsICdrZXlkb3duJyxcbl07XG4vLyBEZWFjdGl2YXRpb24gZXZlbnRzIHJlZ2lzdGVyZWQgb24gZG9jdW1lbnRFbGVtZW50IHdoZW4gYSBwb2ludGVyLXJlbGF0ZWQgZG93biBldmVudCBvY2N1cnNcbnZhciBQT0lOVEVSX0RFQUNUSVZBVElPTl9FVkVOVF9UWVBFUyA9IFtcbiAgICAndG91Y2hlbmQnLCAncG9pbnRlcnVwJywgJ21vdXNldXAnLCAnY29udGV4dG1lbnUnLFxuXTtcbi8vIHNpbXVsdGFuZW91cyBuZXN0ZWQgYWN0aXZhdGlvbnNcbnZhciBhY3RpdmF0ZWRUYXJnZXRzID0gW107XG52YXIgTURDUmlwcGxlRm91bmRhdGlvbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTURDUmlwcGxlRm91bmRhdGlvbiwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBNRENSaXBwbGVGb3VuZGF0aW9uKGFkYXB0ZXIpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgX19hc3NpZ24oX19hc3NpZ24oe30sIE1EQ1JpcHBsZUZvdW5kYXRpb24uZGVmYXVsdEFkYXB0ZXIpLCBhZGFwdGVyKSkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuYWN0aXZhdGlvbkFuaW1hdGlvbkhhc0VuZGVkID0gZmFsc2U7XG4gICAgICAgIF90aGlzLmFjdGl2YXRpb25UaW1lciA9IDA7XG4gICAgICAgIF90aGlzLmZnRGVhY3RpdmF0aW9uUmVtb3ZhbFRpbWVyID0gMDtcbiAgICAgICAgX3RoaXMuZmdTY2FsZSA9ICcwJztcbiAgICAgICAgX3RoaXMuZnJhbWUgPSB7IHdpZHRoOiAwLCBoZWlnaHQ6IDAgfTtcbiAgICAgICAgX3RoaXMuaW5pdGlhbFNpemUgPSAwO1xuICAgICAgICBfdGhpcy5sYXlvdXRGcmFtZSA9IDA7XG4gICAgICAgIF90aGlzLm1heFJhZGl1cyA9IDA7XG4gICAgICAgIF90aGlzLnVuYm91bmRlZENvb3JkcyA9IHsgbGVmdDogMCwgdG9wOiAwIH07XG4gICAgICAgIF90aGlzLmFjdGl2YXRpb25TdGF0ZSA9IF90aGlzLmRlZmF1bHRBY3RpdmF0aW9uU3RhdGUoKTtcbiAgICAgICAgX3RoaXMuYWN0aXZhdGlvblRpbWVyQ2FsbGJhY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpcy5hY3RpdmF0aW9uQW5pbWF0aW9uSGFzRW5kZWQgPSB0cnVlO1xuICAgICAgICAgICAgX3RoaXMucnVuRGVhY3RpdmF0aW9uVVhMb2dpY0lmUmVhZHkoKTtcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuYWN0aXZhdGVIYW5kbGVyID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIF90aGlzLmFjdGl2YXRlSW1wbChlKTtcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuZGVhY3RpdmF0ZUhhbmRsZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpcy5kZWFjdGl2YXRlSW1wbCgpO1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5mb2N1c0hhbmRsZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpcy5oYW5kbGVGb2N1cygpO1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5ibHVySGFuZGxlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzLmhhbmRsZUJsdXIoKTtcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMucmVzaXplSGFuZGxlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzLmxheW91dCgpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNRENSaXBwbGVGb3VuZGF0aW9uLCBcImNzc0NsYXNzZXNcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBjc3NDbGFzc2VzO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1EQ1JpcHBsZUZvdW5kYXRpb24sIFwic3RyaW5nc1wiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHN0cmluZ3M7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTURDUmlwcGxlRm91bmRhdGlvbiwgXCJudW1iZXJzXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVtYmVycztcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNRENSaXBwbGVGb3VuZGF0aW9uLCBcImRlZmF1bHRBZGFwdGVyXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGFkZENsYXNzOiBmdW5jdGlvbiAoKSB7IHJldHVybiB1bmRlZmluZWQ7IH0sXG4gICAgICAgICAgICAgICAgYnJvd3NlclN1cHBvcnRzQ3NzVmFyczogZnVuY3Rpb24gKCkgeyByZXR1cm4gdHJ1ZTsgfSxcbiAgICAgICAgICAgICAgICBjb21wdXRlQm91bmRpbmdSZWN0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoeyB0b3A6IDAsIHJpZ2h0OiAwLCBib3R0b206IDAsIGxlZnQ6IDAsIHdpZHRoOiAwLCBoZWlnaHQ6IDAgfSk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBjb250YWluc0V2ZW50VGFyZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0cnVlOyB9LFxuICAgICAgICAgICAgICAgIGRlcmVnaXN0ZXJEb2N1bWVudEludGVyYWN0aW9uSGFuZGxlcjogZnVuY3Rpb24gKCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9LFxuICAgICAgICAgICAgICAgIGRlcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXI6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSxcbiAgICAgICAgICAgICAgICBkZXJlZ2lzdGVyUmVzaXplSGFuZGxlcjogZnVuY3Rpb24gKCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9LFxuICAgICAgICAgICAgICAgIGdldFdpbmRvd1BhZ2VPZmZzZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuICh7IHg6IDAsIHk6IDAgfSk7IH0sXG4gICAgICAgICAgICAgICAgaXNTdXJmYWNlQWN0aXZlOiBmdW5jdGlvbiAoKSB7IHJldHVybiB0cnVlOyB9LFxuICAgICAgICAgICAgICAgIGlzU3VyZmFjZURpc2FibGVkOiBmdW5jdGlvbiAoKSB7IHJldHVybiB0cnVlOyB9LFxuICAgICAgICAgICAgICAgIGlzVW5ib3VuZGVkOiBmdW5jdGlvbiAoKSB7IHJldHVybiB0cnVlOyB9LFxuICAgICAgICAgICAgICAgIHJlZ2lzdGVyRG9jdW1lbnRJbnRlcmFjdGlvbkhhbmRsZXI6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSxcbiAgICAgICAgICAgICAgICByZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcjogZnVuY3Rpb24gKCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9LFxuICAgICAgICAgICAgICAgIHJlZ2lzdGVyUmVzaXplSGFuZGxlcjogZnVuY3Rpb24gKCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9LFxuICAgICAgICAgICAgICAgIHJlbW92ZUNsYXNzOiBmdW5jdGlvbiAoKSB7IHJldHVybiB1bmRlZmluZWQ7IH0sXG4gICAgICAgICAgICAgICAgdXBkYXRlQ3NzVmFyaWFibGU6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBNRENSaXBwbGVGb3VuZGF0aW9uLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgc3VwcG9ydHNQcmVzc1JpcHBsZSA9IHRoaXMuc3VwcG9ydHNQcmVzc1JpcHBsZSgpO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyUm9vdEhhbmRsZXJzKHN1cHBvcnRzUHJlc3NSaXBwbGUpO1xuICAgICAgICBpZiAoc3VwcG9ydHNQcmVzc1JpcHBsZSkge1xuICAgICAgICAgICAgdmFyIF9hID0gTURDUmlwcGxlRm91bmRhdGlvbi5jc3NDbGFzc2VzLCBST09UXzEgPSBfYS5ST09ULCBVTkJPVU5ERURfMSA9IF9hLlVOQk9VTkRFRDtcbiAgICAgICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuYWRhcHRlci5hZGRDbGFzcyhST09UXzEpO1xuICAgICAgICAgICAgICAgIGlmIChfdGhpcy5hZGFwdGVyLmlzVW5ib3VuZGVkKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuYWRhcHRlci5hZGRDbGFzcyhVTkJPVU5ERURfMSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIFVuYm91bmRlZCByaXBwbGVzIG5lZWQgbGF5b3V0IGxvZ2ljIGFwcGxpZWQgaW1tZWRpYXRlbHkgdG8gc2V0IGNvb3JkaW5hdGVzIGZvciBib3RoIHNoYWRlIGFuZCByaXBwbGVcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMubGF5b3V0SW50ZXJuYWwoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgTURDUmlwcGxlRm91bmRhdGlvbi5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKHRoaXMuc3VwcG9ydHNQcmVzc1JpcHBsZSgpKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5hY3RpdmF0aW9uVGltZXIpIHtcbiAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5hY3RpdmF0aW9uVGltZXIpO1xuICAgICAgICAgICAgICAgIHRoaXMuYWN0aXZhdGlvblRpbWVyID0gMDtcbiAgICAgICAgICAgICAgICB0aGlzLmFkYXB0ZXIucmVtb3ZlQ2xhc3MoTURDUmlwcGxlRm91bmRhdGlvbi5jc3NDbGFzc2VzLkZHX0FDVElWQVRJT04pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuZmdEZWFjdGl2YXRpb25SZW1vdmFsVGltZXIpIHtcbiAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5mZ0RlYWN0aXZhdGlvblJlbW92YWxUaW1lcik7XG4gICAgICAgICAgICAgICAgdGhpcy5mZ0RlYWN0aXZhdGlvblJlbW92YWxUaW1lciA9IDA7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGFwdGVyLnJlbW92ZUNsYXNzKE1EQ1JpcHBsZUZvdW5kYXRpb24uY3NzQ2xhc3Nlcy5GR19ERUFDVElWQVRJT04pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIF9hID0gTURDUmlwcGxlRm91bmRhdGlvbi5jc3NDbGFzc2VzLCBST09UXzIgPSBfYS5ST09ULCBVTkJPVU5ERURfMiA9IF9hLlVOQk9VTkRFRDtcbiAgICAgICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuYWRhcHRlci5yZW1vdmVDbGFzcyhST09UXzIpO1xuICAgICAgICAgICAgICAgIF90aGlzLmFkYXB0ZXIucmVtb3ZlQ2xhc3MoVU5CT1VOREVEXzIpO1xuICAgICAgICAgICAgICAgIF90aGlzLnJlbW92ZUNzc1ZhcnMoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZGVyZWdpc3RlclJvb3RIYW5kbGVycygpO1xuICAgICAgICB0aGlzLmRlcmVnaXN0ZXJEZWFjdGl2YXRpb25IYW5kbGVycygpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIGV2dCBPcHRpb25hbCBldmVudCBjb250YWluaW5nIHBvc2l0aW9uIGluZm9ybWF0aW9uLlxuICAgICAqL1xuICAgIE1EQ1JpcHBsZUZvdW5kYXRpb24ucHJvdG90eXBlLmFjdGl2YXRlID0gZnVuY3Rpb24gKGV2dCkge1xuICAgICAgICB0aGlzLmFjdGl2YXRlSW1wbChldnQpO1xuICAgIH07XG4gICAgTURDUmlwcGxlRm91bmRhdGlvbi5wcm90b3R5cGUuZGVhY3RpdmF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5kZWFjdGl2YXRlSW1wbCgpO1xuICAgIH07XG4gICAgTURDUmlwcGxlRm91bmRhdGlvbi5wcm90b3R5cGUubGF5b3V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAodGhpcy5sYXlvdXRGcmFtZSkge1xuICAgICAgICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUodGhpcy5sYXlvdXRGcmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5sYXlvdXRGcmFtZSA9IHJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpcy5sYXlvdXRJbnRlcm5hbCgpO1xuICAgICAgICAgICAgX3RoaXMubGF5b3V0RnJhbWUgPSAwO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIE1EQ1JpcHBsZUZvdW5kYXRpb24ucHJvdG90eXBlLnNldFVuYm91bmRlZCA9IGZ1bmN0aW9uICh1bmJvdW5kZWQpIHtcbiAgICAgICAgdmFyIFVOQk9VTkRFRCA9IE1EQ1JpcHBsZUZvdW5kYXRpb24uY3NzQ2xhc3Nlcy5VTkJPVU5ERUQ7XG4gICAgICAgIGlmICh1bmJvdW5kZWQpIHtcbiAgICAgICAgICAgIHRoaXMuYWRhcHRlci5hZGRDbGFzcyhVTkJPVU5ERUQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5hZGFwdGVyLnJlbW92ZUNsYXNzKFVOQk9VTkRFRCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE1EQ1JpcHBsZUZvdW5kYXRpb24ucHJvdG90eXBlLmhhbmRsZUZvY3VzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuYWRhcHRlci5hZGRDbGFzcyhNRENSaXBwbGVGb3VuZGF0aW9uLmNzc0NsYXNzZXMuQkdfRk9DVVNFRCk7IH0pO1xuICAgIH07XG4gICAgTURDUmlwcGxlRm91bmRhdGlvbi5wcm90b3R5cGUuaGFuZGxlQmx1ciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLmFkYXB0ZXIucmVtb3ZlQ2xhc3MoTURDUmlwcGxlRm91bmRhdGlvbi5jc3NDbGFzc2VzLkJHX0ZPQ1VTRUQpOyB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFdlIGNvbXB1dGUgdGhpcyBwcm9wZXJ0eSBzbyB0aGF0IHdlIGFyZSBub3QgcXVlcnlpbmcgaW5mb3JtYXRpb24gYWJvdXQgdGhlIGNsaWVudFxuICAgICAqIHVudGlsIHRoZSBwb2ludCBpbiB0aW1lIHdoZXJlIHRoZSBmb3VuZGF0aW9uIHJlcXVlc3RzIGl0LiBUaGlzIHByZXZlbnRzIHNjZW5hcmlvcyB3aGVyZVxuICAgICAqIGNsaWVudC1zaWRlIGZlYXR1cmUtZGV0ZWN0aW9uIG1heSBoYXBwZW4gdG9vIGVhcmx5LCBzdWNoIGFzIHdoZW4gY29tcG9uZW50cyBhcmUgcmVuZGVyZWQgb24gdGhlIHNlcnZlclxuICAgICAqIGFuZCB0aGVuIGluaXRpYWxpemVkIGF0IG1vdW50IHRpbWUgb24gdGhlIGNsaWVudC5cbiAgICAgKi9cbiAgICBNRENSaXBwbGVGb3VuZGF0aW9uLnByb3RvdHlwZS5zdXBwb3J0c1ByZXNzUmlwcGxlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hZGFwdGVyLmJyb3dzZXJTdXBwb3J0c0Nzc1ZhcnMoKTtcbiAgICB9O1xuICAgIE1EQ1JpcHBsZUZvdW5kYXRpb24ucHJvdG90eXBlLmRlZmF1bHRBY3RpdmF0aW9uU3RhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBhY3RpdmF0aW9uRXZlbnQ6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGhhc0RlYWN0aXZhdGlvblVYUnVuOiBmYWxzZSxcbiAgICAgICAgICAgIGlzQWN0aXZhdGVkOiBmYWxzZSxcbiAgICAgICAgICAgIGlzUHJvZ3JhbW1hdGljOiBmYWxzZSxcbiAgICAgICAgICAgIHdhc0FjdGl2YXRlZEJ5UG9pbnRlcjogZmFsc2UsXG4gICAgICAgICAgICB3YXNFbGVtZW50TWFkZUFjdGl2ZTogZmFsc2UsXG4gICAgICAgIH07XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBzdXBwb3J0c1ByZXNzUmlwcGxlIFBhc3NlZCBmcm9tIGluaXQgdG8gc2F2ZSBhIHJlZHVuZGFudCBmdW5jdGlvbiBjYWxsXG4gICAgICovXG4gICAgTURDUmlwcGxlRm91bmRhdGlvbi5wcm90b3R5cGUucmVnaXN0ZXJSb290SGFuZGxlcnMgPSBmdW5jdGlvbiAoc3VwcG9ydHNQcmVzc1JpcHBsZSkge1xuICAgICAgICB2YXIgZV8xLCBfYTtcbiAgICAgICAgaWYgKHN1cHBvcnRzUHJlc3NSaXBwbGUpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgQUNUSVZBVElPTl9FVkVOVF9UWVBFU18xID0gX192YWx1ZXMoQUNUSVZBVElPTl9FVkVOVF9UWVBFUyksIEFDVElWQVRJT05fRVZFTlRfVFlQRVNfMV8xID0gQUNUSVZBVElPTl9FVkVOVF9UWVBFU18xLm5leHQoKTsgIUFDVElWQVRJT05fRVZFTlRfVFlQRVNfMV8xLmRvbmU7IEFDVElWQVRJT05fRVZFTlRfVFlQRVNfMV8xID0gQUNUSVZBVElPTl9FVkVOVF9UWVBFU18xLm5leHQoKSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZXZ0VHlwZSA9IEFDVElWQVRJT05fRVZFTlRfVFlQRVNfMV8xLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFkYXB0ZXIucmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXIoZXZ0VHlwZSwgdGhpcy5hY3RpdmF0ZUhhbmRsZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlXzFfMSkgeyBlXzEgPSB7IGVycm9yOiBlXzFfMSB9OyB9XG4gICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoQUNUSVZBVElPTl9FVkVOVF9UWVBFU18xXzEgJiYgIUFDVElWQVRJT05fRVZFTlRfVFlQRVNfMV8xLmRvbmUgJiYgKF9hID0gQUNUSVZBVElPTl9FVkVOVF9UWVBFU18xLnJldHVybikpIF9hLmNhbGwoQUNUSVZBVElPTl9FVkVOVF9UWVBFU18xKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZmluYWxseSB7IGlmIChlXzEpIHRocm93IGVfMS5lcnJvcjsgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuYWRhcHRlci5pc1VuYm91bmRlZCgpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGFwdGVyLnJlZ2lzdGVyUmVzaXplSGFuZGxlcih0aGlzLnJlc2l6ZUhhbmRsZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuYWRhcHRlci5yZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcignZm9jdXMnLCB0aGlzLmZvY3VzSGFuZGxlcik7XG4gICAgICAgIHRoaXMuYWRhcHRlci5yZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcignYmx1cicsIHRoaXMuYmx1ckhhbmRsZXIpO1xuICAgIH07XG4gICAgTURDUmlwcGxlRm91bmRhdGlvbi5wcm90b3R5cGUucmVnaXN0ZXJEZWFjdGl2YXRpb25IYW5kbGVycyA9IGZ1bmN0aW9uIChldnQpIHtcbiAgICAgICAgdmFyIGVfMiwgX2E7XG4gICAgICAgIGlmIChldnQudHlwZSA9PT0gJ2tleWRvd24nKSB7XG4gICAgICAgICAgICB0aGlzLmFkYXB0ZXIucmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXIoJ2tleXVwJywgdGhpcy5kZWFjdGl2YXRlSGFuZGxlcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIFBPSU5URVJfREVBQ1RJVkFUSU9OX0VWRU5UX1RZUEVTXzEgPSBfX3ZhbHVlcyhQT0lOVEVSX0RFQUNUSVZBVElPTl9FVkVOVF9UWVBFUyksIFBPSU5URVJfREVBQ1RJVkFUSU9OX0VWRU5UX1RZUEVTXzFfMSA9IFBPSU5URVJfREVBQ1RJVkFUSU9OX0VWRU5UX1RZUEVTXzEubmV4dCgpOyAhUE9JTlRFUl9ERUFDVElWQVRJT05fRVZFTlRfVFlQRVNfMV8xLmRvbmU7IFBPSU5URVJfREVBQ1RJVkFUSU9OX0VWRU5UX1RZUEVTXzFfMSA9IFBPSU5URVJfREVBQ1RJVkFUSU9OX0VWRU5UX1RZUEVTXzEubmV4dCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBldnRUeXBlID0gUE9JTlRFUl9ERUFDVElWQVRJT05fRVZFTlRfVFlQRVNfMV8xLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFkYXB0ZXIucmVnaXN0ZXJEb2N1bWVudEludGVyYWN0aW9uSGFuZGxlcihldnRUeXBlLCB0aGlzLmRlYWN0aXZhdGVIYW5kbGVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZV8yXzEpIHsgZV8yID0geyBlcnJvcjogZV8yXzEgfTsgfVxuICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKFBPSU5URVJfREVBQ1RJVkFUSU9OX0VWRU5UX1RZUEVTXzFfMSAmJiAhUE9JTlRFUl9ERUFDVElWQVRJT05fRVZFTlRfVFlQRVNfMV8xLmRvbmUgJiYgKF9hID0gUE9JTlRFUl9ERUFDVElWQVRJT05fRVZFTlRfVFlQRVNfMS5yZXR1cm4pKSBfYS5jYWxsKFBPSU5URVJfREVBQ1RJVkFUSU9OX0VWRU5UX1RZUEVTXzEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmaW5hbGx5IHsgaWYgKGVfMikgdGhyb3cgZV8yLmVycm9yOyB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE1EQ1JpcHBsZUZvdW5kYXRpb24ucHJvdG90eXBlLmRlcmVnaXN0ZXJSb290SGFuZGxlcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBlXzMsIF9hO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZm9yICh2YXIgQUNUSVZBVElPTl9FVkVOVF9UWVBFU18yID0gX192YWx1ZXMoQUNUSVZBVElPTl9FVkVOVF9UWVBFUyksIEFDVElWQVRJT05fRVZFTlRfVFlQRVNfMl8xID0gQUNUSVZBVElPTl9FVkVOVF9UWVBFU18yLm5leHQoKTsgIUFDVElWQVRJT05fRVZFTlRfVFlQRVNfMl8xLmRvbmU7IEFDVElWQVRJT05fRVZFTlRfVFlQRVNfMl8xID0gQUNUSVZBVElPTl9FVkVOVF9UWVBFU18yLm5leHQoKSkge1xuICAgICAgICAgICAgICAgIHZhciBldnRUeXBlID0gQUNUSVZBVElPTl9FVkVOVF9UWVBFU18yXzEudmFsdWU7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGFwdGVyLmRlcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXIoZXZ0VHlwZSwgdGhpcy5hY3RpdmF0ZUhhbmRsZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlXzNfMSkgeyBlXzMgPSB7IGVycm9yOiBlXzNfMSB9OyB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpZiAoQUNUSVZBVElPTl9FVkVOVF9UWVBFU18yXzEgJiYgIUFDVElWQVRJT05fRVZFTlRfVFlQRVNfMl8xLmRvbmUgJiYgKF9hID0gQUNUSVZBVElPTl9FVkVOVF9UWVBFU18yLnJldHVybikpIF9hLmNhbGwoQUNUSVZBVElPTl9FVkVOVF9UWVBFU18yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZV8zKSB0aHJvdyBlXzMuZXJyb3I7IH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFkYXB0ZXIuZGVyZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcignZm9jdXMnLCB0aGlzLmZvY3VzSGFuZGxlcik7XG4gICAgICAgIHRoaXMuYWRhcHRlci5kZXJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyKCdibHVyJywgdGhpcy5ibHVySGFuZGxlcik7XG4gICAgICAgIGlmICh0aGlzLmFkYXB0ZXIuaXNVbmJvdW5kZWQoKSkge1xuICAgICAgICAgICAgdGhpcy5hZGFwdGVyLmRlcmVnaXN0ZXJSZXNpemVIYW5kbGVyKHRoaXMucmVzaXplSGFuZGxlcik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE1EQ1JpcHBsZUZvdW5kYXRpb24ucHJvdG90eXBlLmRlcmVnaXN0ZXJEZWFjdGl2YXRpb25IYW5kbGVycyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGVfNCwgX2E7XG4gICAgICAgIHRoaXMuYWRhcHRlci5kZXJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyKCdrZXl1cCcsIHRoaXMuZGVhY3RpdmF0ZUhhbmRsZXIpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZm9yICh2YXIgUE9JTlRFUl9ERUFDVElWQVRJT05fRVZFTlRfVFlQRVNfMiA9IF9fdmFsdWVzKFBPSU5URVJfREVBQ1RJVkFUSU9OX0VWRU5UX1RZUEVTKSwgUE9JTlRFUl9ERUFDVElWQVRJT05fRVZFTlRfVFlQRVNfMl8xID0gUE9JTlRFUl9ERUFDVElWQVRJT05fRVZFTlRfVFlQRVNfMi5uZXh0KCk7ICFQT0lOVEVSX0RFQUNUSVZBVElPTl9FVkVOVF9UWVBFU18yXzEuZG9uZTsgUE9JTlRFUl9ERUFDVElWQVRJT05fRVZFTlRfVFlQRVNfMl8xID0gUE9JTlRFUl9ERUFDVElWQVRJT05fRVZFTlRfVFlQRVNfMi5uZXh0KCkpIHtcbiAgICAgICAgICAgICAgICB2YXIgZXZ0VHlwZSA9IFBPSU5URVJfREVBQ1RJVkFUSU9OX0VWRU5UX1RZUEVTXzJfMS52YWx1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLmFkYXB0ZXIuZGVyZWdpc3RlckRvY3VtZW50SW50ZXJhY3Rpb25IYW5kbGVyKGV2dFR5cGUsIHRoaXMuZGVhY3RpdmF0ZUhhbmRsZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlXzRfMSkgeyBlXzQgPSB7IGVycm9yOiBlXzRfMSB9OyB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpZiAoUE9JTlRFUl9ERUFDVElWQVRJT05fRVZFTlRfVFlQRVNfMl8xICYmICFQT0lOVEVSX0RFQUNUSVZBVElPTl9FVkVOVF9UWVBFU18yXzEuZG9uZSAmJiAoX2EgPSBQT0lOVEVSX0RFQUNUSVZBVElPTl9FVkVOVF9UWVBFU18yLnJldHVybikpIF9hLmNhbGwoUE9JTlRFUl9ERUFDVElWQVRJT05fRVZFTlRfVFlQRVNfMik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaW5hbGx5IHsgaWYgKGVfNCkgdGhyb3cgZV80LmVycm9yOyB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE1EQ1JpcHBsZUZvdW5kYXRpb24ucHJvdG90eXBlLnJlbW92ZUNzc1ZhcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciByaXBwbGVTdHJpbmdzID0gTURDUmlwcGxlRm91bmRhdGlvbi5zdHJpbmdzO1xuICAgICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHJpcHBsZVN0cmluZ3MpO1xuICAgICAgICBrZXlzLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgaWYgKGtleS5pbmRleE9mKCdWQVJfJykgPT09IDApIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5hZGFwdGVyLnVwZGF0ZUNzc1ZhcmlhYmxlKHJpcHBsZVN0cmluZ3Nba2V5XSwgbnVsbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgTURDUmlwcGxlRm91bmRhdGlvbi5wcm90b3R5cGUuYWN0aXZhdGVJbXBsID0gZnVuY3Rpb24gKGV2dCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAodGhpcy5hZGFwdGVyLmlzU3VyZmFjZURpc2FibGVkKCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYWN0aXZhdGlvblN0YXRlID0gdGhpcy5hY3RpdmF0aW9uU3RhdGU7XG4gICAgICAgIGlmIChhY3RpdmF0aW9uU3RhdGUuaXNBY3RpdmF0ZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBBdm9pZCByZWFjdGluZyB0byBmb2xsb3ctb24gZXZlbnRzIGZpcmVkIGJ5IHRvdWNoIGRldmljZSBhZnRlciBhbiBhbHJlYWR5LXByb2Nlc3NlZCB1c2VyIGludGVyYWN0aW9uXG4gICAgICAgIHZhciBwcmV2aW91c0FjdGl2YXRpb25FdmVudCA9IHRoaXMucHJldmlvdXNBY3RpdmF0aW9uRXZlbnQ7XG4gICAgICAgIHZhciBpc1NhbWVJbnRlcmFjdGlvbiA9IHByZXZpb3VzQWN0aXZhdGlvbkV2ZW50ICYmIGV2dCAhPT0gdW5kZWZpbmVkICYmIHByZXZpb3VzQWN0aXZhdGlvbkV2ZW50LnR5cGUgIT09IGV2dC50eXBlO1xuICAgICAgICBpZiAoaXNTYW1lSW50ZXJhY3Rpb24pIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBhY3RpdmF0aW9uU3RhdGUuaXNBY3RpdmF0ZWQgPSB0cnVlO1xuICAgICAgICBhY3RpdmF0aW9uU3RhdGUuaXNQcm9ncmFtbWF0aWMgPSBldnQgPT09IHVuZGVmaW5lZDtcbiAgICAgICAgYWN0aXZhdGlvblN0YXRlLmFjdGl2YXRpb25FdmVudCA9IGV2dDtcbiAgICAgICAgYWN0aXZhdGlvblN0YXRlLndhc0FjdGl2YXRlZEJ5UG9pbnRlciA9IGFjdGl2YXRpb25TdGF0ZS5pc1Byb2dyYW1tYXRpYyA/IGZhbHNlIDogZXZ0ICE9PSB1bmRlZmluZWQgJiYgKGV2dC50eXBlID09PSAnbW91c2Vkb3duJyB8fCBldnQudHlwZSA9PT0gJ3RvdWNoc3RhcnQnIHx8IGV2dC50eXBlID09PSAncG9pbnRlcmRvd24nKTtcbiAgICAgICAgdmFyIGhhc0FjdGl2YXRlZENoaWxkID0gZXZ0ICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIGFjdGl2YXRlZFRhcmdldHMubGVuZ3RoID4gMCAmJlxuICAgICAgICAgICAgYWN0aXZhdGVkVGFyZ2V0cy5zb21lKGZ1bmN0aW9uICh0YXJnZXQpIHsgcmV0dXJuIF90aGlzLmFkYXB0ZXIuY29udGFpbnNFdmVudFRhcmdldCh0YXJnZXQpOyB9KTtcbiAgICAgICAgaWYgKGhhc0FjdGl2YXRlZENoaWxkKSB7XG4gICAgICAgICAgICAvLyBJbW1lZGlhdGVseSByZXNldCBhY3RpdmF0aW9uIHN0YXRlLCB3aGlsZSBwcmVzZXJ2aW5nIGxvZ2ljIHRoYXQgcHJldmVudHMgdG91Y2ggZm9sbG93LW9uIGV2ZW50c1xuICAgICAgICAgICAgdGhpcy5yZXNldEFjdGl2YXRpb25TdGF0ZSgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChldnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgYWN0aXZhdGVkVGFyZ2V0cy5wdXNoKGV2dC50YXJnZXQpO1xuICAgICAgICAgICAgdGhpcy5yZWdpc3RlckRlYWN0aXZhdGlvbkhhbmRsZXJzKGV2dCk7XG4gICAgICAgIH1cbiAgICAgICAgYWN0aXZhdGlvblN0YXRlLndhc0VsZW1lbnRNYWRlQWN0aXZlID0gdGhpcy5jaGVja0VsZW1lbnRNYWRlQWN0aXZlKGV2dCk7XG4gICAgICAgIGlmIChhY3RpdmF0aW9uU3RhdGUud2FzRWxlbWVudE1hZGVBY3RpdmUpIHtcbiAgICAgICAgICAgIHRoaXMuYW5pbWF0ZUFjdGl2YXRpb24oKTtcbiAgICAgICAgfVxuICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgLy8gUmVzZXQgYXJyYXkgb24gbmV4dCBmcmFtZSBhZnRlciB0aGUgY3VycmVudCBldmVudCBoYXMgaGFkIGEgY2hhbmNlIHRvIGJ1YmJsZSB0byBwcmV2ZW50IGFuY2VzdG9yIHJpcHBsZXNcbiAgICAgICAgICAgIGFjdGl2YXRlZFRhcmdldHMgPSBbXTtcbiAgICAgICAgICAgIGlmICghYWN0aXZhdGlvblN0YXRlLndhc0VsZW1lbnRNYWRlQWN0aXZlXG4gICAgICAgICAgICAgICAgJiYgZXZ0ICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICAmJiAoZXZ0LmtleSA9PT0gJyAnIHx8IGV2dC5rZXlDb2RlID09PSAzMikpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiBzcGFjZSB3YXMgcHJlc3NlZCwgdHJ5IGFnYWluIHdpdGhpbiBhbiByQUYgY2FsbCB0byBkZXRlY3QgOmFjdGl2ZSwgYmVjYXVzZSBkaWZmZXJlbnQgVUFzIHJlcG9ydFxuICAgICAgICAgICAgICAgIC8vIGFjdGl2ZSBzdGF0ZXMgaW5jb25zaXN0ZW50bHkgd2hlbiB0aGV5J3JlIGNhbGxlZCB3aXRoaW4gZXZlbnQgaGFuZGxpbmcgY29kZTpcbiAgICAgICAgICAgICAgICAvLyAtIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTYzNTk3MVxuICAgICAgICAgICAgICAgIC8vIC0gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTI5Mzc0MVxuICAgICAgICAgICAgICAgIC8vIFdlIHRyeSBmaXJzdCBvdXRzaWRlIHJBRiB0byBzdXBwb3J0IEVkZ2UsIHdoaWNoIGRvZXMgbm90IGV4aGliaXQgdGhpcyBwcm9ibGVtLCBidXQgd2lsbCBjcmFzaCBpZiBhIENTU1xuICAgICAgICAgICAgICAgIC8vIHZhcmlhYmxlIGlzIHNldCB3aXRoaW4gYSByQUYgY2FsbGJhY2sgZm9yIGEgc3VibWl0IGJ1dHRvbiBpbnRlcmFjdGlvbiAoIzIyNDEpLlxuICAgICAgICAgICAgICAgIGFjdGl2YXRpb25TdGF0ZS53YXNFbGVtZW50TWFkZUFjdGl2ZSA9IF90aGlzLmNoZWNrRWxlbWVudE1hZGVBY3RpdmUoZXZ0KTtcbiAgICAgICAgICAgICAgICBpZiAoYWN0aXZhdGlvblN0YXRlLndhc0VsZW1lbnRNYWRlQWN0aXZlKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmFuaW1hdGVBY3RpdmF0aW9uKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFhY3RpdmF0aW9uU3RhdGUud2FzRWxlbWVudE1hZGVBY3RpdmUpIHtcbiAgICAgICAgICAgICAgICAvLyBSZXNldCBhY3RpdmF0aW9uIHN0YXRlIGltbWVkaWF0ZWx5IGlmIGVsZW1lbnQgd2FzIG5vdCBtYWRlIGFjdGl2ZS5cbiAgICAgICAgICAgICAgICBfdGhpcy5hY3RpdmF0aW9uU3RhdGUgPSBfdGhpcy5kZWZhdWx0QWN0aXZhdGlvblN0YXRlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgTURDUmlwcGxlRm91bmRhdGlvbi5wcm90b3R5cGUuY2hlY2tFbGVtZW50TWFkZUFjdGl2ZSA9IGZ1bmN0aW9uIChldnQpIHtcbiAgICAgICAgcmV0dXJuIChldnQgIT09IHVuZGVmaW5lZCAmJiBldnQudHlwZSA9PT0gJ2tleWRvd24nKSA/XG4gICAgICAgICAgICB0aGlzLmFkYXB0ZXIuaXNTdXJmYWNlQWN0aXZlKCkgOlxuICAgICAgICAgICAgdHJ1ZTtcbiAgICB9O1xuICAgIE1EQ1JpcHBsZUZvdW5kYXRpb24ucHJvdG90eXBlLmFuaW1hdGVBY3RpdmF0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgX2EgPSBNRENSaXBwbGVGb3VuZGF0aW9uLnN0cmluZ3MsIFZBUl9GR19UUkFOU0xBVEVfU1RBUlQgPSBfYS5WQVJfRkdfVFJBTlNMQVRFX1NUQVJULCBWQVJfRkdfVFJBTlNMQVRFX0VORCA9IF9hLlZBUl9GR19UUkFOU0xBVEVfRU5EO1xuICAgICAgICB2YXIgX2IgPSBNRENSaXBwbGVGb3VuZGF0aW9uLmNzc0NsYXNzZXMsIEZHX0RFQUNUSVZBVElPTiA9IF9iLkZHX0RFQUNUSVZBVElPTiwgRkdfQUNUSVZBVElPTiA9IF9iLkZHX0FDVElWQVRJT047XG4gICAgICAgIHZhciBERUFDVElWQVRJT05fVElNRU9VVF9NUyA9IE1EQ1JpcHBsZUZvdW5kYXRpb24ubnVtYmVycy5ERUFDVElWQVRJT05fVElNRU9VVF9NUztcbiAgICAgICAgdGhpcy5sYXlvdXRJbnRlcm5hbCgpO1xuICAgICAgICB2YXIgdHJhbnNsYXRlU3RhcnQgPSAnJztcbiAgICAgICAgdmFyIHRyYW5zbGF0ZUVuZCA9ICcnO1xuICAgICAgICBpZiAoIXRoaXMuYWRhcHRlci5pc1VuYm91bmRlZCgpKSB7XG4gICAgICAgICAgICB2YXIgX2MgPSB0aGlzLmdldEZnVHJhbnNsYXRpb25Db29yZGluYXRlcygpLCBzdGFydFBvaW50ID0gX2Muc3RhcnRQb2ludCwgZW5kUG9pbnQgPSBfYy5lbmRQb2ludDtcbiAgICAgICAgICAgIHRyYW5zbGF0ZVN0YXJ0ID0gc3RhcnRQb2ludC54ICsgXCJweCwgXCIgKyBzdGFydFBvaW50LnkgKyBcInB4XCI7XG4gICAgICAgICAgICB0cmFuc2xhdGVFbmQgPSBlbmRQb2ludC54ICsgXCJweCwgXCIgKyBlbmRQb2ludC55ICsgXCJweFwiO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYWRhcHRlci51cGRhdGVDc3NWYXJpYWJsZShWQVJfRkdfVFJBTlNMQVRFX1NUQVJULCB0cmFuc2xhdGVTdGFydCk7XG4gICAgICAgIHRoaXMuYWRhcHRlci51cGRhdGVDc3NWYXJpYWJsZShWQVJfRkdfVFJBTlNMQVRFX0VORCwgdHJhbnNsYXRlRW5kKTtcbiAgICAgICAgLy8gQ2FuY2VsIGFueSBvbmdvaW5nIGFjdGl2YXRpb24vZGVhY3RpdmF0aW9uIGFuaW1hdGlvbnNcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuYWN0aXZhdGlvblRpbWVyKTtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuZmdEZWFjdGl2YXRpb25SZW1vdmFsVGltZXIpO1xuICAgICAgICB0aGlzLnJtQm91bmRlZEFjdGl2YXRpb25DbGFzc2VzKCk7XG4gICAgICAgIHRoaXMuYWRhcHRlci5yZW1vdmVDbGFzcyhGR19ERUFDVElWQVRJT04pO1xuICAgICAgICAvLyBGb3JjZSBsYXlvdXQgaW4gb3JkZXIgdG8gcmUtdHJpZ2dlciB0aGUgYW5pbWF0aW9uLlxuICAgICAgICB0aGlzLmFkYXB0ZXIuY29tcHV0ZUJvdW5kaW5nUmVjdCgpO1xuICAgICAgICB0aGlzLmFkYXB0ZXIuYWRkQ2xhc3MoRkdfQUNUSVZBVElPTik7XG4gICAgICAgIHRoaXMuYWN0aXZhdGlvblRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpcy5hY3RpdmF0aW9uVGltZXJDYWxsYmFjaygpO1xuICAgICAgICB9LCBERUFDVElWQVRJT05fVElNRU9VVF9NUyk7XG4gICAgfTtcbiAgICBNRENSaXBwbGVGb3VuZGF0aW9uLnByb3RvdHlwZS5nZXRGZ1RyYW5zbGF0aW9uQ29vcmRpbmF0ZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfYSA9IHRoaXMuYWN0aXZhdGlvblN0YXRlLCBhY3RpdmF0aW9uRXZlbnQgPSBfYS5hY3RpdmF0aW9uRXZlbnQsIHdhc0FjdGl2YXRlZEJ5UG9pbnRlciA9IF9hLndhc0FjdGl2YXRlZEJ5UG9pbnRlcjtcbiAgICAgICAgdmFyIHN0YXJ0UG9pbnQ7XG4gICAgICAgIGlmICh3YXNBY3RpdmF0ZWRCeVBvaW50ZXIpIHtcbiAgICAgICAgICAgIHN0YXJ0UG9pbnQgPSBnZXROb3JtYWxpemVkRXZlbnRDb29yZHMoYWN0aXZhdGlvbkV2ZW50LCB0aGlzLmFkYXB0ZXIuZ2V0V2luZG93UGFnZU9mZnNldCgpLCB0aGlzLmFkYXB0ZXIuY29tcHV0ZUJvdW5kaW5nUmVjdCgpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHN0YXJ0UG9pbnQgPSB7XG4gICAgICAgICAgICAgICAgeDogdGhpcy5mcmFtZS53aWR0aCAvIDIsXG4gICAgICAgICAgICAgICAgeTogdGhpcy5mcmFtZS5oZWlnaHQgLyAyLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICAvLyBDZW50ZXIgdGhlIGVsZW1lbnQgYXJvdW5kIHRoZSBzdGFydCBwb2ludC5cbiAgICAgICAgc3RhcnRQb2ludCA9IHtcbiAgICAgICAgICAgIHg6IHN0YXJ0UG9pbnQueCAtICh0aGlzLmluaXRpYWxTaXplIC8gMiksXG4gICAgICAgICAgICB5OiBzdGFydFBvaW50LnkgLSAodGhpcy5pbml0aWFsU2l6ZSAvIDIpLFxuICAgICAgICB9O1xuICAgICAgICB2YXIgZW5kUG9pbnQgPSB7XG4gICAgICAgICAgICB4OiAodGhpcy5mcmFtZS53aWR0aCAvIDIpIC0gKHRoaXMuaW5pdGlhbFNpemUgLyAyKSxcbiAgICAgICAgICAgIHk6ICh0aGlzLmZyYW1lLmhlaWdodCAvIDIpIC0gKHRoaXMuaW5pdGlhbFNpemUgLyAyKSxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHsgc3RhcnRQb2ludDogc3RhcnRQb2ludCwgZW5kUG9pbnQ6IGVuZFBvaW50IH07XG4gICAgfTtcbiAgICBNRENSaXBwbGVGb3VuZGF0aW9uLnByb3RvdHlwZS5ydW5EZWFjdGl2YXRpb25VWExvZ2ljSWZSZWFkeSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgLy8gVGhpcyBtZXRob2QgaXMgY2FsbGVkIGJvdGggd2hlbiBhIHBvaW50aW5nIGRldmljZSBpcyByZWxlYXNlZCwgYW5kIHdoZW4gdGhlIGFjdGl2YXRpb24gYW5pbWF0aW9uIGVuZHMuXG4gICAgICAgIC8vIFRoZSBkZWFjdGl2YXRpb24gYW5pbWF0aW9uIHNob3VsZCBvbmx5IHJ1biBhZnRlciBib3RoIG9mIHRob3NlIG9jY3VyLlxuICAgICAgICB2YXIgRkdfREVBQ1RJVkFUSU9OID0gTURDUmlwcGxlRm91bmRhdGlvbi5jc3NDbGFzc2VzLkZHX0RFQUNUSVZBVElPTjtcbiAgICAgICAgdmFyIF9hID0gdGhpcy5hY3RpdmF0aW9uU3RhdGUsIGhhc0RlYWN0aXZhdGlvblVYUnVuID0gX2EuaGFzRGVhY3RpdmF0aW9uVVhSdW4sIGlzQWN0aXZhdGVkID0gX2EuaXNBY3RpdmF0ZWQ7XG4gICAgICAgIHZhciBhY3RpdmF0aW9uSGFzRW5kZWQgPSBoYXNEZWFjdGl2YXRpb25VWFJ1biB8fCAhaXNBY3RpdmF0ZWQ7XG4gICAgICAgIGlmIChhY3RpdmF0aW9uSGFzRW5kZWQgJiYgdGhpcy5hY3RpdmF0aW9uQW5pbWF0aW9uSGFzRW5kZWQpIHtcbiAgICAgICAgICAgIHRoaXMucm1Cb3VuZGVkQWN0aXZhdGlvbkNsYXNzZXMoKTtcbiAgICAgICAgICAgIHRoaXMuYWRhcHRlci5hZGRDbGFzcyhGR19ERUFDVElWQVRJT04pO1xuICAgICAgICAgICAgdGhpcy5mZ0RlYWN0aXZhdGlvblJlbW92YWxUaW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIF90aGlzLmFkYXB0ZXIucmVtb3ZlQ2xhc3MoRkdfREVBQ1RJVkFUSU9OKTtcbiAgICAgICAgICAgIH0sIG51bWJlcnMuRkdfREVBQ1RJVkFUSU9OX01TKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgTURDUmlwcGxlRm91bmRhdGlvbi5wcm90b3R5cGUucm1Cb3VuZGVkQWN0aXZhdGlvbkNsYXNzZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBGR19BQ1RJVkFUSU9OID0gTURDUmlwcGxlRm91bmRhdGlvbi5jc3NDbGFzc2VzLkZHX0FDVElWQVRJT047XG4gICAgICAgIHRoaXMuYWRhcHRlci5yZW1vdmVDbGFzcyhGR19BQ1RJVkFUSU9OKTtcbiAgICAgICAgdGhpcy5hY3RpdmF0aW9uQW5pbWF0aW9uSGFzRW5kZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5hZGFwdGVyLmNvbXB1dGVCb3VuZGluZ1JlY3QoKTtcbiAgICB9O1xuICAgIE1EQ1JpcHBsZUZvdW5kYXRpb24ucHJvdG90eXBlLnJlc2V0QWN0aXZhdGlvblN0YXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLnByZXZpb3VzQWN0aXZhdGlvbkV2ZW50ID0gdGhpcy5hY3RpdmF0aW9uU3RhdGUuYWN0aXZhdGlvbkV2ZW50O1xuICAgICAgICB0aGlzLmFjdGl2YXRpb25TdGF0ZSA9IHRoaXMuZGVmYXVsdEFjdGl2YXRpb25TdGF0ZSgpO1xuICAgICAgICAvLyBUb3VjaCBkZXZpY2VzIG1heSBmaXJlIGFkZGl0aW9uYWwgZXZlbnRzIGZvciB0aGUgc2FtZSBpbnRlcmFjdGlvbiB3aXRoaW4gYSBzaG9ydCB0aW1lLlxuICAgICAgICAvLyBTdG9yZSB0aGUgcHJldmlvdXMgZXZlbnQgdW50aWwgaXQncyBzYWZlIHRvIGFzc3VtZSB0aGF0IHN1YnNlcXVlbnQgZXZlbnRzIGFyZSBmb3IgbmV3IGludGVyYWN0aW9ucy5cbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5wcmV2aW91c0FjdGl2YXRpb25FdmVudCA9IHVuZGVmaW5lZDsgfSwgTURDUmlwcGxlRm91bmRhdGlvbi5udW1iZXJzLlRBUF9ERUxBWV9NUyk7XG4gICAgfTtcbiAgICBNRENSaXBwbGVGb3VuZGF0aW9uLnByb3RvdHlwZS5kZWFjdGl2YXRlSW1wbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIGFjdGl2YXRpb25TdGF0ZSA9IHRoaXMuYWN0aXZhdGlvblN0YXRlO1xuICAgICAgICAvLyBUaGlzIGNhbiBoYXBwZW4gaW4gc2NlbmFyaW9zIHN1Y2ggYXMgd2hlbiB5b3UgaGF2ZSBhIGtleXVwIGV2ZW50IHRoYXQgYmx1cnMgdGhlIGVsZW1lbnQuXG4gICAgICAgIGlmICghYWN0aXZhdGlvblN0YXRlLmlzQWN0aXZhdGVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHN0YXRlID0gX19hc3NpZ24oe30sIGFjdGl2YXRpb25TdGF0ZSk7XG4gICAgICAgIGlmIChhY3RpdmF0aW9uU3RhdGUuaXNQcm9ncmFtbWF0aWMpIHtcbiAgICAgICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuYW5pbWF0ZURlYWN0aXZhdGlvbihzdGF0ZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMucmVzZXRBY3RpdmF0aW9uU3RhdGUoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZGVyZWdpc3RlckRlYWN0aXZhdGlvbkhhbmRsZXJzKCk7XG4gICAgICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIF90aGlzLmFjdGl2YXRpb25TdGF0ZS5oYXNEZWFjdGl2YXRpb25VWFJ1biA9IHRydWU7XG4gICAgICAgICAgICAgICAgX3RoaXMuYW5pbWF0ZURlYWN0aXZhdGlvbihzdGF0ZSk7XG4gICAgICAgICAgICAgICAgX3RoaXMucmVzZXRBY3RpdmF0aW9uU3RhdGUoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBNRENSaXBwbGVGb3VuZGF0aW9uLnByb3RvdHlwZS5hbmltYXRlRGVhY3RpdmF0aW9uID0gZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHZhciB3YXNBY3RpdmF0ZWRCeVBvaW50ZXIgPSBfYS53YXNBY3RpdmF0ZWRCeVBvaW50ZXIsIHdhc0VsZW1lbnRNYWRlQWN0aXZlID0gX2Eud2FzRWxlbWVudE1hZGVBY3RpdmU7XG4gICAgICAgIGlmICh3YXNBY3RpdmF0ZWRCeVBvaW50ZXIgfHwgd2FzRWxlbWVudE1hZGVBY3RpdmUpIHtcbiAgICAgICAgICAgIHRoaXMucnVuRGVhY3RpdmF0aW9uVVhMb2dpY0lmUmVhZHkoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgTURDUmlwcGxlRm91bmRhdGlvbi5wcm90b3R5cGUubGF5b3V0SW50ZXJuYWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuZnJhbWUgPSB0aGlzLmFkYXB0ZXIuY29tcHV0ZUJvdW5kaW5nUmVjdCgpO1xuICAgICAgICB2YXIgbWF4RGltID0gTWF0aC5tYXgodGhpcy5mcmFtZS5oZWlnaHQsIHRoaXMuZnJhbWUud2lkdGgpO1xuICAgICAgICAvLyBTdXJmYWNlIGRpYW1ldGVyIGlzIHRyZWF0ZWQgZGlmZmVyZW50bHkgZm9yIHVuYm91bmRlZCB2cy4gYm91bmRlZCByaXBwbGVzLlxuICAgICAgICAvLyBVbmJvdW5kZWQgcmlwcGxlIGRpYW1ldGVyIGlzIGNhbGN1bGF0ZWQgc21hbGxlciBzaW5jZSB0aGUgc3VyZmFjZSBpcyBleHBlY3RlZCB0byBhbHJlYWR5IGJlIHBhZGRlZCBhcHByb3ByaWF0ZWx5XG4gICAgICAgIC8vIHRvIGV4dGVuZCB0aGUgaGl0Ym94LCBhbmQgdGhlIHJpcHBsZSBpcyBleHBlY3RlZCB0byBtZWV0IHRoZSBlZGdlcyBvZiB0aGUgcGFkZGVkIGhpdGJveCAod2hpY2ggaXMgdHlwaWNhbGx5XG4gICAgICAgIC8vIHNxdWFyZSkuIEJvdW5kZWQgcmlwcGxlcywgb24gdGhlIG90aGVyIGhhbmQsIGFyZSBmdWxseSBleHBlY3RlZCB0byBleHBhbmQgYmV5b25kIHRoZSBzdXJmYWNlJ3MgbG9uZ2VzdCBkaWFtZXRlclxuICAgICAgICAvLyAoY2FsY3VsYXRlZCBiYXNlZCBvbiB0aGUgZGlhZ29uYWwgcGx1cyBhIGNvbnN0YW50IHBhZGRpbmcpLCBhbmQgYXJlIGNsaXBwZWQgYXQgdGhlIHN1cmZhY2UncyBib3JkZXIgdmlhXG4gICAgICAgIC8vIGBvdmVyZmxvdzogaGlkZGVuYC5cbiAgICAgICAgdmFyIGdldEJvdW5kZWRSYWRpdXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgaHlwb3RlbnVzZSA9IE1hdGguc3FydChNYXRoLnBvdyhfdGhpcy5mcmFtZS53aWR0aCwgMikgKyBNYXRoLnBvdyhfdGhpcy5mcmFtZS5oZWlnaHQsIDIpKTtcbiAgICAgICAgICAgIHJldHVybiBoeXBvdGVudXNlICsgTURDUmlwcGxlRm91bmRhdGlvbi5udW1iZXJzLlBBRERJTkc7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMubWF4UmFkaXVzID0gdGhpcy5hZGFwdGVyLmlzVW5ib3VuZGVkKCkgPyBtYXhEaW0gOiBnZXRCb3VuZGVkUmFkaXVzKCk7XG4gICAgICAgIC8vIFJpcHBsZSBpcyBzaXplZCBhcyBhIGZyYWN0aW9uIG9mIHRoZSBsYXJnZXN0IGRpbWVuc2lvbiBvZiB0aGUgc3VyZmFjZSwgdGhlbiBzY2FsZXMgdXAgdXNpbmcgYSBDU1Mgc2NhbGUgdHJhbnNmb3JtXG4gICAgICAgIHZhciBpbml0aWFsU2l6ZSA9IE1hdGguZmxvb3IobWF4RGltICogTURDUmlwcGxlRm91bmRhdGlvbi5udW1iZXJzLklOSVRJQUxfT1JJR0lOX1NDQUxFKTtcbiAgICAgICAgLy8gVW5ib3VuZGVkIHJpcHBsZSBzaXplIHNob3VsZCBhbHdheXMgYmUgZXZlbiBudW1iZXIgdG8gZXF1YWxseSBjZW50ZXIgYWxpZ24uXG4gICAgICAgIGlmICh0aGlzLmFkYXB0ZXIuaXNVbmJvdW5kZWQoKSAmJiBpbml0aWFsU2l6ZSAlIDIgIT09IDApIHtcbiAgICAgICAgICAgIHRoaXMuaW5pdGlhbFNpemUgPSBpbml0aWFsU2l6ZSAtIDE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmluaXRpYWxTaXplID0gaW5pdGlhbFNpemU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5mZ1NjYWxlID0gXCJcIiArIHRoaXMubWF4UmFkaXVzIC8gdGhpcy5pbml0aWFsU2l6ZTtcbiAgICAgICAgdGhpcy51cGRhdGVMYXlvdXRDc3NWYXJzKCk7XG4gICAgfTtcbiAgICBNRENSaXBwbGVGb3VuZGF0aW9uLnByb3RvdHlwZS51cGRhdGVMYXlvdXRDc3NWYXJzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX2EgPSBNRENSaXBwbGVGb3VuZGF0aW9uLnN0cmluZ3MsIFZBUl9GR19TSVpFID0gX2EuVkFSX0ZHX1NJWkUsIFZBUl9MRUZUID0gX2EuVkFSX0xFRlQsIFZBUl9UT1AgPSBfYS5WQVJfVE9QLCBWQVJfRkdfU0NBTEUgPSBfYS5WQVJfRkdfU0NBTEU7XG4gICAgICAgIHRoaXMuYWRhcHRlci51cGRhdGVDc3NWYXJpYWJsZShWQVJfRkdfU0laRSwgdGhpcy5pbml0aWFsU2l6ZSArIFwicHhcIik7XG4gICAgICAgIHRoaXMuYWRhcHRlci51cGRhdGVDc3NWYXJpYWJsZShWQVJfRkdfU0NBTEUsIHRoaXMuZmdTY2FsZSk7XG4gICAgICAgIGlmICh0aGlzLmFkYXB0ZXIuaXNVbmJvdW5kZWQoKSkge1xuICAgICAgICAgICAgdGhpcy51bmJvdW5kZWRDb29yZHMgPSB7XG4gICAgICAgICAgICAgICAgbGVmdDogTWF0aC5yb3VuZCgodGhpcy5mcmFtZS53aWR0aCAvIDIpIC0gKHRoaXMuaW5pdGlhbFNpemUgLyAyKSksXG4gICAgICAgICAgICAgICAgdG9wOiBNYXRoLnJvdW5kKCh0aGlzLmZyYW1lLmhlaWdodCAvIDIpIC0gKHRoaXMuaW5pdGlhbFNpemUgLyAyKSksXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGhpcy5hZGFwdGVyLnVwZGF0ZUNzc1ZhcmlhYmxlKFZBUl9MRUZULCB0aGlzLnVuYm91bmRlZENvb3Jkcy5sZWZ0ICsgXCJweFwiKTtcbiAgICAgICAgICAgIHRoaXMuYWRhcHRlci51cGRhdGVDc3NWYXJpYWJsZShWQVJfVE9QLCB0aGlzLnVuYm91bmRlZENvb3Jkcy50b3AgKyBcInB4XCIpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gTURDUmlwcGxlRm91bmRhdGlvbjtcbn0oTURDRm91bmRhdGlvbikpO1xuZXhwb3J0IHsgTURDUmlwcGxlRm91bmRhdGlvbiB9O1xuLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLWRlZmF1bHQtZXhwb3J0IE5lZWRlZCBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eSB3aXRoIE1EQyBXZWIgdjAuNDQuMCBhbmQgZWFybGllci5cbmV4cG9ydCBkZWZhdWx0IE1EQ1JpcHBsZUZvdW5kYXRpb247XG4vLyMgc291cmNlTWFwcGluZ1VSTD1mb3VuZGF0aW9uLmpzLm1hcCIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuXG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICpcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4gKiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbiAqIFRIRSBTT0ZUV0FSRS5cbiAqL1xuaW1wb3J0IHsgX19leHRlbmRzIH0gZnJvbSBcInRzbGliXCI7XG5pbXBvcnQgeyBNRENDb21wb25lbnQgfSBmcm9tICdAbWF0ZXJpYWwvYmFzZS9jb21wb25lbnQnO1xuaW1wb3J0IHsgYXBwbHlQYXNzaXZlIH0gZnJvbSAnQG1hdGVyaWFsL2RvbS9ldmVudHMnO1xuaW1wb3J0IHsgbWF0Y2hlcyB9IGZyb20gJ0BtYXRlcmlhbC9kb20vcG9ueWZpbGwnO1xuaW1wb3J0IHsgTURDUmlwcGxlRm91bmRhdGlvbiB9IGZyb20gJy4vZm91bmRhdGlvbic7XG5pbXBvcnQgKiBhcyB1dGlsIGZyb20gJy4vdXRpbCc7XG52YXIgTURDUmlwcGxlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhNRENSaXBwbGUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTURDUmlwcGxlKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuZGlzYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBNRENSaXBwbGUuYXR0YWNoVG8gPSBmdW5jdGlvbiAocm9vdCwgb3B0cykge1xuICAgICAgICBpZiAob3B0cyA9PT0gdm9pZCAwKSB7IG9wdHMgPSB7XG4gICAgICAgICAgICBpc1VuYm91bmRlZDogdW5kZWZpbmVkXG4gICAgICAgIH07IH1cbiAgICAgICAgdmFyIHJpcHBsZSA9IG5ldyBNRENSaXBwbGUocm9vdCk7XG4gICAgICAgIC8vIE9ubHkgb3ZlcnJpZGUgdW5ib3VuZGVkIGJlaGF2aW9yIGlmIG9wdGlvbiBpcyBleHBsaWNpdGx5IHNwZWNpZmllZFxuICAgICAgICBpZiAob3B0cy5pc1VuYm91bmRlZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByaXBwbGUudW5ib3VuZGVkID0gb3B0cy5pc1VuYm91bmRlZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmlwcGxlO1xuICAgIH07XG4gICAgTURDUmlwcGxlLmNyZWF0ZUFkYXB0ZXIgPSBmdW5jdGlvbiAoaW5zdGFuY2UpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGFkZENsYXNzOiBmdW5jdGlvbiAoY2xhc3NOYW1lKSB7IHJldHVybiBpbnN0YW5jZS5yb290LmNsYXNzTGlzdC5hZGQoY2xhc3NOYW1lKTsgfSxcbiAgICAgICAgICAgIGJyb3dzZXJTdXBwb3J0c0Nzc1ZhcnM6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHV0aWwuc3VwcG9ydHNDc3NWYXJpYWJsZXMod2luZG93KTsgfSxcbiAgICAgICAgICAgIGNvbXB1dGVCb3VuZGluZ1JlY3Q6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGluc3RhbmNlLnJvb3QuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7IH0sXG4gICAgICAgICAgICBjb250YWluc0V2ZW50VGFyZ2V0OiBmdW5jdGlvbiAodGFyZ2V0KSB7IHJldHVybiBpbnN0YW5jZS5yb290LmNvbnRhaW5zKHRhcmdldCk7IH0sXG4gICAgICAgICAgICBkZXJlZ2lzdGVyRG9jdW1lbnRJbnRlcmFjdGlvbkhhbmRsZXI6IGZ1bmN0aW9uIChldnRUeXBlLCBoYW5kbGVyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKGV2dFR5cGUsIGhhbmRsZXIsIGFwcGx5UGFzc2l2ZSgpKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkZXJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyOiBmdW5jdGlvbiAoZXZ0VHlwZSwgaGFuZGxlcikge1xuICAgICAgICAgICAgICAgIHJldHVybiBpbnN0YW5jZS5yb290XG4gICAgICAgICAgICAgICAgICAgIC5yZW1vdmVFdmVudExpc3RlbmVyKGV2dFR5cGUsIGhhbmRsZXIsIGFwcGx5UGFzc2l2ZSgpKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkZXJlZ2lzdGVyUmVzaXplSGFuZGxlcjogZnVuY3Rpb24gKGhhbmRsZXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIGhhbmRsZXIpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdldFdpbmRvd1BhZ2VPZmZzZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKHsgeDogd2luZG93LnBhZ2VYT2Zmc2V0LCB5OiB3aW5kb3cucGFnZVlPZmZzZXQgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaXNTdXJmYWNlQWN0aXZlOiBmdW5jdGlvbiAoKSB7IHJldHVybiBtYXRjaGVzKGluc3RhbmNlLnJvb3QsICc6YWN0aXZlJyk7IH0sXG4gICAgICAgICAgICBpc1N1cmZhY2VEaXNhYmxlZDogZnVuY3Rpb24gKCkgeyByZXR1cm4gQm9vbGVhbihpbnN0YW5jZS5kaXNhYmxlZCk7IH0sXG4gICAgICAgICAgICBpc1VuYm91bmRlZDogZnVuY3Rpb24gKCkgeyByZXR1cm4gQm9vbGVhbihpbnN0YW5jZS51bmJvdW5kZWQpOyB9LFxuICAgICAgICAgICAgcmVnaXN0ZXJEb2N1bWVudEludGVyYWN0aW9uSGFuZGxlcjogZnVuY3Rpb24gKGV2dFR5cGUsIGhhbmRsZXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoZXZ0VHlwZSwgaGFuZGxlciwgYXBwbHlQYXNzaXZlKCkpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyOiBmdW5jdGlvbiAoZXZ0VHlwZSwgaGFuZGxlcikge1xuICAgICAgICAgICAgICAgIHJldHVybiBpbnN0YW5jZS5yb290XG4gICAgICAgICAgICAgICAgICAgIC5hZGRFdmVudExpc3RlbmVyKGV2dFR5cGUsIGhhbmRsZXIsIGFwcGx5UGFzc2l2ZSgpKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICByZWdpc3RlclJlc2l6ZUhhbmRsZXI6IGZ1bmN0aW9uIChoYW5kbGVyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCBoYW5kbGVyKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICByZW1vdmVDbGFzczogZnVuY3Rpb24gKGNsYXNzTmFtZSkgeyByZXR1cm4gaW5zdGFuY2Uucm9vdC5jbGFzc0xpc3QucmVtb3ZlKGNsYXNzTmFtZSk7IH0sXG4gICAgICAgICAgICB1cGRhdGVDc3NWYXJpYWJsZTogZnVuY3Rpb24gKHZhck5hbWUsIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGluc3RhbmNlLnJvb3Quc3R5bGUuc2V0UHJvcGVydHkodmFyTmFtZSwgdmFsdWUpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNRENSaXBwbGUucHJvdG90eXBlLCBcInVuYm91bmRlZFwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIEJvb2xlYW4odGhpcy5pc1VuYm91bmRlZCk7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHVuYm91bmRlZCkge1xuICAgICAgICAgICAgdGhpcy5pc1VuYm91bmRlZCA9IEJvb2xlYW4odW5ib3VuZGVkKTtcbiAgICAgICAgICAgIHRoaXMuc2V0VW5ib3VuZGVkKCk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBNRENSaXBwbGUucHJvdG90eXBlLmFjdGl2YXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmZvdW5kYXRpb24uYWN0aXZhdGUoKTtcbiAgICB9O1xuICAgIE1EQ1JpcHBsZS5wcm90b3R5cGUuZGVhY3RpdmF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5mb3VuZGF0aW9uLmRlYWN0aXZhdGUoKTtcbiAgICB9O1xuICAgIE1EQ1JpcHBsZS5wcm90b3R5cGUubGF5b3V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmZvdW5kYXRpb24ubGF5b3V0KCk7XG4gICAgfTtcbiAgICBNRENSaXBwbGUucHJvdG90eXBlLmdldERlZmF1bHRGb3VuZGF0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gbmV3IE1EQ1JpcHBsZUZvdW5kYXRpb24oTURDUmlwcGxlLmNyZWF0ZUFkYXB0ZXIodGhpcykpO1xuICAgIH07XG4gICAgTURDUmlwcGxlLnByb3RvdHlwZS5pbml0aWFsU3luY1dpdGhET00gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciByb290ID0gdGhpcy5yb290O1xuICAgICAgICB0aGlzLmlzVW5ib3VuZGVkID0gJ21kY1JpcHBsZUlzVW5ib3VuZGVkJyBpbiByb290LmRhdGFzZXQ7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDbG9zdXJlIENvbXBpbGVyIHRocm93cyBhbiBhY2Nlc3MgY29udHJvbCBlcnJvciB3aGVuIGRpcmVjdGx5IGFjY2Vzc2luZyBhXG4gICAgICogcHJvdGVjdGVkIG9yIHByaXZhdGUgcHJvcGVydHkgaW5zaWRlIGEgZ2V0dGVyL3NldHRlciwgbGlrZSB1bmJvdW5kZWQgYWJvdmUuXG4gICAgICogQnkgYWNjZXNzaW5nIHRoZSBwcm90ZWN0ZWQgcHJvcGVydHkgaW5zaWRlIGEgbWV0aG9kLCB3ZSBzb2x2ZSB0aGF0IHByb2JsZW0uXG4gICAgICogVGhhdCdzIHdoeSB0aGlzIGZ1bmN0aW9uIGV4aXN0cy5cbiAgICAgKi9cbiAgICBNRENSaXBwbGUucHJvdG90eXBlLnNldFVuYm91bmRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5mb3VuZGF0aW9uLnNldFVuYm91bmRlZChCb29sZWFuKHRoaXMuaXNVbmJvdW5kZWQpKTtcbiAgICB9O1xuICAgIHJldHVybiBNRENSaXBwbGU7XG59KE1EQ0NvbXBvbmVudCkpO1xuZXhwb3J0IHsgTURDUmlwcGxlIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb21wb25lbnQuanMubWFwIiwiaW1wb3J0IHsgdXNlRWZmZWN0LCB1c2VSZWYgfSBmcm9tICdyZWFjdCc7XHJcbmltcG9ydCB7IE1EQ1JpcHBsZSB9IGZyb20gJ0BtYXRlcmlhbC9yaXBwbGUnO1xyXG5pbXBvcnQgY2xhc3NuYW1lcyBmcm9tICdjbGFzc25hbWVzJztcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIFJpcHBsZSh7XHJcbiAgICB1bmJvdW5kZWQgPSBmYWxzZSxcclxuICAgIGRpc2FibGVkID0gZmFsc2UsXHJcbiAgICBjbGFzc05hbWUsXHJcbiAgICBlbGVtZW50OiBFbGVtZW50ID0gJ3NwYW4nLFxyXG4gICAgLi4ucHJvcHNcclxufSkge1xyXG4gICAgY29uc3Qgcm9vdFJlZiA9IHVzZVJlZigpO1xyXG4gICAgY29uc3QgcmlwcGxlUmVmID0gdXNlUmVmKCk7XHJcblxyXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgICAgICBpZiAoZGlzYWJsZWQpIHJldHVybjtcclxuXHJcbiAgICAgICAgaWYgKCFyaXBwbGVSZWYuY3VycmVudCkge1xyXG4gICAgICAgICAgICByaXBwbGVSZWYuY3VycmVudCA9IG5ldyBNRENSaXBwbGUocm9vdFJlZi5jdXJyZW50LnBhcmVudE5vZGUpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmlwcGxlUmVmLmN1cnJlbnQudW5ib3VuZGVkID0gdW5ib3VuZGVkO1xyXG5cclxuICAgICAgICByZXR1cm4gKCkgPT4gcmlwcGxlUmVmLmN1cnJlbnQuZGVzdHJveSgpO1xyXG4gICAgfSwgW2Rpc2FibGVkLCB1bmJvdW5kZWRdKTtcclxuXHJcbiAgICBjb25zdCBjbGFzc05hbWVzID0gY2xhc3NuYW1lcyhjbGFzc05hbWUpO1xyXG5cclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgPEVsZW1lbnRcclxuICAgICAgICAgICAgcmVmPXtyb290UmVmfVxyXG4gICAgICAgICAgICBjbGFzc05hbWU9e2NsYXNzTmFtZXN9XHJcbiAgICAgICAgICAgIHsuLi5wcm9wc31cclxuICAgICAgICAvPlxyXG4gICAgKTtcclxufVxyXG5cclxuUmlwcGxlLmRpc3BsYXlOYW1lID0gJ01EQ1JpcHBsZSc7IiwiZXhwb3J0IGNvbnN0IGNzc0NsYXNzZXMgPSB7XHJcbiAgICBST09UOiAnbWRjLXJpcHBsZS11cGdyYWRlZCcsXHJcbiAgICBVTkJPVU5ERUQ6ICdtZGMtcmlwcGxlLXVwZ3JhZGVkLS11bmJvdW5kZWQnLFxyXG4gICAgQkdfRk9DVVNFRDogJ21kYy1yaXBwbGUtdXBncmFkZWQtLWJhY2tncm91bmQtZm9jdXNlZCcsXHJcbiAgICBGR19BQ1RJVkFUSU9OOiAnbWRjLXJpcHBsZS11cGdyYWRlZC0tZm9yZWdyb3VuZC1hY3RpdmF0aW9uJyxcclxuICAgIEZHX0RFQUNUSVZBVElPTjogJ21kYy1yaXBwbGUtdXBncmFkZWQtLWZvcmVncm91bmQtZGVhY3RpdmF0aW9uJyxcclxuXHJcbiAgICBTVVJGQUNFOiAnbWRjLXJpcHBsZS1zdXJmYWNlJyxcclxuICAgIFNVUkZBQ0VfUFJJTUFSWTogJ21kYy1yaXBwbGUtc3VyZmFjZS0tcHJpbWFyeScsXHJcbiAgICBTVVJGQUNFX0FDQ0VOVDogJ21kYy1yaXBwbGUtc3VyZmFjZS0tYWNjZW50J1xyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IHN0cmluZ3MgPSB7XHJcbiAgICBWQVJfRkdfU0NBTEU6ICctLW1kYy1yaXBwbGUtZmctc2NhbGUnLFxyXG4gICAgVkFSX0ZHX1NJWkU6ICctLW1kYy1yaXBwbGUtZmctc2l6ZScsXHJcbiAgICBWQVJfRkdfVFJBTlNMQVRFX0VORDogJy0tbWRjLXJpcHBsZS1mZy10cmFuc2xhdGUtZW5kJyxcclxuICAgIFZBUl9GR19UUkFOU0xBVEVfU1RBUlQ6ICctLW1kYy1yaXBwbGUtZmctdHJhbnNsYXRlLXN0YXJ0JyxcclxuICAgIFZBUl9MRUZUOiAnLS1tZGMtcmlwcGxlLWxlZnQnLFxyXG4gICAgVkFSX1RPUDogJy0tbWRjLXJpcHBsZS10b3AnLFxyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IG51bWJlcnMgPSB7XHJcbiAgICBERUFDVElWQVRJT05fVElNRU9VVF9NUzogMjI1LCAvLyBDb3JyZXNwb25kcyB0byAkbWRjLXJpcHBsZS10cmFuc2xhdGUtZHVyYXRpb24gKGkuZS4gYWN0aXZhdGlvbiBhbmltYXRpb24gZHVyYXRpb24pXHJcbiAgICBGR19ERUFDVElWQVRJT05fTVM6IDE1MCwgLy8gQ29ycmVzcG9uZHMgdG8gJG1kYy1yaXBwbGUtZmFkZS1vdXQtZHVyYXRpb24gKGkuZS4gZGVhY3RpdmF0aW9uIGFuaW1hdGlvbiBkdXJhdGlvbilcclxuICAgIElOSVRJQUxfT1JJR0lOX1NDQUxFOiAwLjYsXHJcbiAgICBQQURESU5HOiAxMCxcclxuICAgIFRBUF9ERUxBWV9NUzogMzAwLCAvLyBEZWxheSBiZXR3ZWVuIHRvdWNoIGFuZCBzaW11bGF0ZWQgbW91c2UgZXZlbnRzIG9uIHRvdWNoIGRldmljZXNcclxufTsiLCJpbXBvcnQgeyB1c2VFZmZlY3QsIHVzZVJlZiB9IGZyb20gJ3JlYWN0JztcclxuaW1wb3J0IHsgTURDUmlwcGxlIH0gZnJvbSAnQG1hdGVyaWFsL3JpcHBsZSc7XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gdXNlUmlwcGxlKHJvb3RSZWYsIHVuYm91bmRlZCA9IGZhbHNlKSB7XHJcbiAgICBjb25zdCByaXBwbGVSZWYgPSB1c2VSZWYoKTtcclxuXHJcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgICAgIGlmICghcmlwcGxlUmVmLmN1cnJlbnQpIHtcclxuICAgICAgICAgICAgcmlwcGxlUmVmLmN1cnJlbnQgPSBuZXcgTURDUmlwcGxlKHJvb3RSZWYuY3VycmVudCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByaXBwbGVSZWYuY3VycmVudC51bmJvdW5kZWQgPSB1bmJvdW5kZWQ7XHJcblxyXG4gICAgICAgIHJldHVybiAoKSA9PiByaXBwbGVSZWYuY3VycmVudC5kZXN0cm95KCk7XHJcbiAgICB9LCBbcm9vdFJlZiwgdW5ib3VuZGVkXSk7XHJcblxyXG4gICAgcmV0dXJuIHJpcHBsZVJlZi5jdXJyZW50O1xyXG59IiwiaW1wb3J0IHsgZm9yd2FyZFJlZiwgdXNlUmVmLCB1c2VJbXBlcmF0aXZlSGFuZGxlIH0gZnJvbSAncmVhY3QnO1xyXG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xyXG5pbXBvcnQgY2xhc3NuYW1lcyBmcm9tICdjbGFzc25hbWVzJztcclxuXHJcbmltcG9ydCB7IGNzc0NsYXNzZXMgfSBmcm9tICcuL2NvbnN0YW50cyc7XHJcbmltcG9ydCB7IHVzZVJpcHBsZSB9IGZyb20gJy4vaG9va3MnO1xyXG5cclxuY29uc3QgUmlwcGxlU3VyZmFjZSA9IGZvcndhcmRSZWYoKHtcclxuICAgIHByaW1hcnksXHJcbiAgICBhY2NlbnQsXHJcblxyXG4gICAgY2xhc3NOYW1lLFxyXG4gICAgZWxlbWVudDogRWxlbWVudCA9ICdkaXYnLFxyXG4gICAgLi4ucHJvcHNcclxufSwgcmVmKSA9PiB7XHJcbiAgICBjb25zdCByb290UmVmID0gdXNlUmVmKCk7XHJcblxyXG4gICAgdXNlSW1wZXJhdGl2ZUhhbmRsZShyZWYsICgpID0+IHJvb3RSZWYuY3VycmVudCk7XHJcbiAgICB1c2VSaXBwbGUocm9vdFJlZik7XHJcblxyXG4gICAgY29uc3QgY2xhc3NOYW1lcyA9IGNsYXNzbmFtZXMoY3NzQ2xhc3Nlcy5TVVJGQUNFLCB7XHJcbiAgICAgICAgW2Nzc0NsYXNzZXMuU1VSRkFDRV9QUklNQVJZXTogcHJpbWFyeSxcclxuICAgICAgICBbY3NzQ2xhc3Nlcy5TVVJGQUNFX0FDQ0VOVF06IGFjY2VudFxyXG4gICAgfSwgY2xhc3NOYW1lKTtcclxuXHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAgIDxFbGVtZW50XHJcbiAgICAgICAgICAgIHJlZj17cm9vdFJlZn1cclxuICAgICAgICAgICAgY2xhc3NOYW1lPXtjbGFzc05hbWVzfVxyXG4gICAgICAgICAgICB7Li4ucHJvcHN9XHJcbiAgICAgICAgLz5cclxuICAgICk7XHJcbn0pO1xyXG5cclxuUmlwcGxlU3VyZmFjZS5kaXNwbGF5TmFtZSA9ICdNRENSaXBwbGVTdXJmYWNlJztcclxuXHJcblJpcHBsZVN1cmZhY2UucHJvcFR5cGVzID0ge1xyXG4gICAgcHJpbWFyeTogUHJvcFR5cGVzLmJvb2wsXHJcbiAgICBhY2NlbnQ6IFByb3BUeXBlcy5ib29sXHJcbn07XHJcblxyXG5leHBvcnQgZGVmYXVsdCBSaXBwbGVTdXJmYWNlOyIsImV4cG9ydCB7IGRlZmF1bHQgYXMgUmlwcGxlIH0gZnJvbSAnLi9SaXBwbGUnO1xyXG5leHBvcnQgeyBkZWZhdWx0IGFzIFJpcHBsZVN1cmZhY2UgfSBmcm9tICcuL1JpcHBsZVN1cmZhY2UnO1xyXG5leHBvcnQgKiBmcm9tICcuL2hvb2tzJzsiLCJleHBvcnQgY29uc3QgY3NzQ2xhc3NlcyA9IHtcclxuICAgIFJPT1Q6ICdtZGMtc2VnbWVudGVkLWJ1dHRvbicsXHJcbiAgICBTSU5HTEVfU0VMRUNUOiAnbWRjLXNlZ21lbnRlZC1idXR0b24tLXNpbmdsZS1zZWxlY3QnLFxyXG5cclxuICAgIFNFR01FTlQ6ICdtZGMtc2VnbWVudGVkLWJ1dHRvbl9fc2VnbWVudCcsXHJcbiAgICBTRUdNRU5UX1NFTEVDVEVEOiAnbWRjLXNlZ21lbnRlZC1idXR0b25fX3NlZ21lbnQtLXNlbGVjdGVkJyxcclxuXHJcbiAgICBJQ09OOiAnbWRjLXNlZ21lbnRlZC1idXR0b25fX2ljb24nLFxyXG4gICAgTEFCRUw6ICdtZGMtc2VnbWVudGVkLWJ1dHRvbl9fbGFiZWwnLFxyXG4gICAgUklQUExFOiAnbWRjLXNlZ21lbnRlZC1idXR0b25fX3JpcHBsZScsXHJcbiAgICBUT1VDSDogJ21kYy1zZWdtZW50ZWQtYnV0dG9uLS10b3VjaCcsXHJcbiAgICBUT1VDSF9FTEVNRU5UOiAnbWRjLXNlZ21lbnRlZC1idXR0b25fX3RvdWNoJ1xyXG59OyIsImltcG9ydCB7IGZvcndhcmRSZWYgfSBmcm9tICdyZWFjdCc7XHJcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XHJcbmltcG9ydCBjbGFzc25hbWVzIGZyb20gJ2NsYXNzbmFtZXMnO1xyXG5cclxuaW1wb3J0IHsgQ2xvbmUgfSBmcm9tICcuLi9jb21wb25lbnQnO1xyXG5pbXBvcnQgSWNvbiBmcm9tICcuLi9pY29uJztcclxuXHJcbmltcG9ydCB7IGNzc0NsYXNzZXMgfSBmcm9tICcuL2NvbnN0YW50cyc7XHJcblxyXG5jb25zdCBTZWdtZW50ZWRCdXR0b25TZWdtZW50ID0gZm9yd2FyZFJlZigoe1xyXG4gICAgbGFiZWwsXHJcbiAgICBpY29uLFxyXG4gICAgc2VsZWN0ZWQsXHJcbiAgICB0b3VjaCxcclxuICAgIHJpcHBsZSxcclxuXHJcbiAgICBlbGVtZW50ID0gJ2J1dHRvbicsXHJcbiAgICBjb21wb25lbnQ6IEVsZW1lbnQgPSBlbGVtZW50LFxyXG4gICAgY2xhc3NOYW1lLFxyXG4gICAgY2hpbGRyZW4gPSBsYWJlbCxcclxuICAgIC4uLnByb3BzXHJcbn0sIHJlZikgPT4ge1xyXG4gICAgY29uc3QgY2xhc3NOYW1lcyA9IGNsYXNzbmFtZXMoY3NzQ2xhc3Nlcy5TRUdNRU5ULCB7XHJcbiAgICAgICAgW2Nzc0NsYXNzZXMuU0VHTUVOVF9TRUxFQ1RFRF06IHNlbGVjdGVkLFxyXG4gICAgICAgIFtjc3NDbGFzc2VzLlRPVUNIXTogdG91Y2hcclxuICAgIH0sIGNsYXNzTmFtZSk7XHJcblxyXG4gICAgcmV0dXJuIChcclxuICAgICAgICA8RWxlbWVudFxyXG4gICAgICAgICAgICByZWY9e3JlZn1cclxuICAgICAgICAgICAgY2xhc3NOYW1lPXtjbGFzc05hbWVzfVxyXG4gICAgICAgICAgICB7Li4ucHJvcHN9XHJcbiAgICAgICAgPlxyXG4gICAgICAgICAgICB7cmlwcGxlICYmXHJcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17Y3NzQ2xhc3Nlcy5SSVBQTEV9IC8+XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHt0b3VjaCAmJlxyXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9e2Nzc0NsYXNzZXMuVE9VQ0hfRUxFTUVOVH0gLz5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAge2ljb24gJiZcclxuICAgICAgICAgICAgICAgIDxDbG9uZVxyXG4gICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudD17aWNvbn1cclxuICAgICAgICAgICAgICAgICAgICBmYWxsYmFjaz17SWNvbn1cclxuICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU9e2Nzc0NsYXNzZXMuSUNPTn1cclxuICAgICAgICAgICAgICAgIC8+XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHtjaGlsZHJlbiAmJlxyXG4gICAgICAgICAgICAgICAgPHNwYW4gY2xhc3NOYW1lPXtjc3NDbGFzc2VzLkxBQkVMfT57Y2hpbGRyZW59PC9zcGFuPlxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgPC9FbGVtZW50PlxyXG4gICAgKTtcclxufSk7XHJcblxyXG5TZWdtZW50ZWRCdXR0b25TZWdtZW50LmRpc3BsYXlOYW1lID0gJ01EQ1NlZ21lbnRlZEJ1dHRvblNlZ21lbnQnO1xyXG5cclxuU2VnbWVudGVkQnV0dG9uU2VnbWVudC5wcm9wVHlwZXMgPSB7XHJcbiAgICBsYWJlbDogUHJvcFR5cGVzLnN0cmluZyxcclxuICAgIGljb246IFByb3BUeXBlcy5ub2RlLFxyXG4gICAgc2VsZWN0ZWQ6IFByb3BUeXBlcy5ib29sLFxyXG4gICAgcmlwcGxlOiBQcm9wVHlwZXMuYm9vbFxyXG59O1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgU2VnbWVudGVkQnV0dG9uU2VnbWVudDsiLCJpbXBvcnQgeyBmb3J3YXJkUmVmLCBDaGlsZHJlbiwgdXNlQ2FsbGJhY2sgfSBmcm9tICdyZWFjdCc7XHJcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XHJcbmltcG9ydCBjbGFzc25hbWVzIGZyb20gJ2NsYXNzbmFtZXMnO1xyXG5cclxuaW1wb3J0IHsgaXNVbmRlZmluZWQsIGlzQXJyYXkgfSBmcm9tICcuLi90eXBlcyc7XHJcbmltcG9ydCB7IGNyZWF0ZSwgY2xvbmUgfSBmcm9tICcuLi9jb21wb25lbnQnO1xyXG5cclxuaW1wb3J0IHsgY3NzQ2xhc3NlcyB9IGZyb20gJy4vY29uc3RhbnRzJztcclxuaW1wb3J0IFNlZ21lbnRlZEJ1dHRvblNlZ21lbnQgZnJvbSAnLi9TZWdtZW50ZWRCdXR0b25TZWdtZW50JztcclxuXHJcbmNvbnN0IFNlZ21lbnRlZEJ1dHRvbiA9IGZvcndhcmRSZWYoKHtcclxuICAgIHZhbHVlLFxyXG4gICAgc2VnbWVudHMsXHJcbiAgICBzaW5nbGVTZWxlY3QgPSAhaXNVbmRlZmluZWQodmFsdWUpICYmICFpc0FycmF5KHZhbHVlKSxcclxuICAgIHJpcHBsZSA9IHRydWUsXHJcbiAgICB0b3VjaCA9IGZhbHNlLFxyXG4gICAgb25DaGFuZ2UgPSBGdW5jdGlvbi5wcm90b3R5cGUsXHJcblxyXG4gICAgZWxlbWVudCA9ICdkaXYnLFxyXG4gICAgY29tcG9uZW50OiBFbGVtZW50ID0gZWxlbWVudCxcclxuICAgIGNsYXNzTmFtZSxcclxuICAgIGNoaWxkcmVuID0gc2VnbWVudHM/Lm1hcChzZWdtZW50ID0+IGNyZWF0ZShTZWdtZW50ZWRCdXR0b25TZWdtZW50LCBzZWdtZW50KSksXHJcbiAgICAuLi5wcm9wc1xyXG59LCByZWYpID0+IHtcclxuICAgIGNvbnN0IGhhbmRsZUNsaWNrID0gdXNlQ2FsbGJhY2soZXZlbnQgPT4ge1xyXG4gICAgICAgIGNvbnN0IHNlZ21lbnRWYWx1ZSA9IGV2ZW50LmN1cnJlbnRUYXJnZXQudmFsdWU7XHJcbiAgICAgICAgY29uc3QgbmV3VmFsdWUgPSBzaW5nbGVTZWxlY3QgPyBzZWdtZW50VmFsdWUgOlxyXG4gICAgICAgICAgICAodmFsdWUuaW5jbHVkZXMoc2VnbWVudFZhbHVlKSA/XHJcbiAgICAgICAgICAgICAgICB2YWx1ZS5maWx0ZXIodiA9PiB2ICE9PSBzZWdtZW50VmFsdWUpIDpcclxuICAgICAgICAgICAgICAgIHZhbHVlLmNvbmNhdChzZWdtZW50VmFsdWUpXHJcbiAgICAgICAgICAgICk7XHJcblxyXG4gICAgICAgIG9uQ2hhbmdlKG5ld1ZhbHVlKTtcclxuICAgIH0sIFt2YWx1ZSwgc2luZ2xlU2VsZWN0LCBvbkNoYW5nZV0pO1xyXG5cclxuICAgIGNvbnN0IGNsYXNzTmFtZXMgPSBjbGFzc25hbWVzKGNzc0NsYXNzZXMuUk9PVCwge1xyXG4gICAgICAgIFtjc3NDbGFzc2VzLlNJTkdMRV9TRUxFQ1RdOiBzaW5nbGVTZWxlY3RcclxuICAgIH0sIGNsYXNzTmFtZSk7XHJcblxyXG4gICAgcmV0dXJuIChcclxuICAgICAgICA8RWxlbWVudFxyXG4gICAgICAgICAgICByZWY9e3JlZn1cclxuICAgICAgICAgICAgY2xhc3NOYW1lPXtjbGFzc05hbWVzfVxyXG4gICAgICAgICAgICByb2xlPXtzaW5nbGVTZWxlY3QgPyAncmFkaW9ncm91cCcgOiAnZ3JvdXAnfVxyXG4gICAgICAgICAgICB7Li4ucHJvcHN9XHJcbiAgICAgICAgPlxyXG4gICAgICAgICAgICB7aXNVbmRlZmluZWQodmFsdWUpID8gY2hpbGRyZW4gOlxyXG4gICAgICAgICAgICAgICAgQ2hpbGRyZW4ubWFwKGNoaWxkcmVuLCBzZWdtZW50ID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBhcmlhUHJvcCA9IHNpbmdsZVNlbGVjdCA/ICdhcmlhLWNoZWNrZWQnIDogJ2FyaWEtcHJlc3NlZCc7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2VsZWN0ZWQgPSBzaW5nbGVTZWxlY3QgP1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9PT0gc2VnbWVudC5wcm9wcy52YWx1ZSA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlLmluY2x1ZGVzKHNlZ21lbnQucHJvcHMudmFsdWUpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2xvbmUoc2VnbWVudCwge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByaXBwbGUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvdWNoLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3RlZCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgcm9sZTogc2luZ2xlU2VsZWN0ID8gJ3JhZGlvJyA6IHVuZGVmaW5lZCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgW2FyaWFQcm9wXTogc2VsZWN0ZWQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2xpY2tDYXB0dXJlOiBoYW5kbGVDbGlja1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIDwvRWxlbWVudD5cclxuICAgICk7XHJcbn0pO1xyXG5cclxuU2VnbWVudGVkQnV0dG9uLmRpc3BsYXlOYW1lID0gJ01EQ1NlZ21lbnRlZEJ1dHRvbic7XHJcblxyXG5TZWdtZW50ZWRCdXR0b24ucHJvcFR5cGVzID0ge1xyXG4gICAgdmFsdWU6IFByb3BUeXBlcy5hbnksXHJcbiAgICBzZWdtZW50czogUHJvcFR5cGVzLmFycmF5T2YoUHJvcFR5cGVzLm9uZU9mVHlwZShbXHJcbiAgICAgICAgUHJvcFR5cGVzLm9iamVjdCxcclxuICAgICAgICBQcm9wVHlwZXMuZWxlbWVudFxyXG4gICAgXSkpLFxyXG4gICAgc2luZ2xlU2VsZWN0OiBQcm9wVHlwZXMuYm9vbCxcclxuICAgIHJpcHBsZTogUHJvcFR5cGVzLmJvb2wsXHJcbiAgICB0b3VjaDogUHJvcFR5cGVzLmJvb2wsXHJcbiAgICBvbkNoYW5nZTogUHJvcFR5cGVzLmZ1bmNcclxufTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IFNlZ21lbnRlZEJ1dHRvbjsiLCJpbXBvcnQgU2VnbWVudGVkQnV0dG9uIGZyb20gJy4vU2VnbWVudGVkQnV0dG9uJztcclxuaW1wb3J0IFNlZ21lbnRlZEJ1dHRvblNlZ21lbnQgZnJvbSAnLi9TZWdtZW50ZWRCdXR0b25TZWdtZW50JztcclxuXHJcblNlZ21lbnRlZEJ1dHRvbi5TZWdtZW50ID0gU2VnbWVudGVkQnV0dG9uU2VnbWVudDtcclxuXHJcbmV4cG9ydCB7XHJcbiAgICBTZWdtZW50ZWRCdXR0b24gYXMgZGVmYXVsdCxcclxuICAgIFNlZ21lbnRlZEJ1dHRvblNlZ21lbnRcclxufTsiLCJleHBvcnQgY29uc3QgbnVtYmVycyA9IHtcclxuICAgIEFOSU1BVElPTl9FTlRFUl9USU1FX01TOiAyNTAsXHJcbiAgICBBTklNQVRJT05fRVhJVF9USU1FX01TOiAyMDBcclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCBjc3NDbGFzc2VzID0ge1xyXG4gICAgUk9PVDogJ21kYy1zaWRlLXNoZWV0JyxcclxuICAgIERJU01JU1NJQkxFOiAnbWRjLXNpZGUtc2hlZXQtLWRpc21pc3NpYmxlJyxcclxuICAgIE1PREFMOiAnbWRjLXNpZGUtc2hlZXQtLW1vZGFsJyxcclxuICAgIE9QRU46ICdtZGMtc2lkZS1zaGVldC0tb3BlbicsXHJcbiAgICBBTklNQVRFOiAnbWRjLXNpZGUtc2hlZXQtLWFuaW1hdGUnLFxyXG4gICAgT1BFTklORzogJ21kYy1zaWRlLXNoZWV0LS1vcGVuaW5nJyxcclxuICAgIENMT1NJTkc6ICdtZGMtc2lkZS1zaGVldC0tY2xvc2luZycsXHJcblxyXG4gICAgQ09OVEVOVDogJ21kYy1zaWRlLXNoZWV0X19jb250ZW50JyxcclxuICAgIEhFQURFUjogJ21kYy1zaWRlLXNoZWV0X19oZWFkZXInLFxyXG4gICAgVElUTEU6ICdtZGMtc2lkZS1zaGVldF9fdGl0bGUnLFxyXG4gICAgQ0xPU0VfQlVUVE9OOiAnbWRjLXNpZGUtc2hlZXRfX2Nsb3NlLWJ1dHRvbicsXHJcblxyXG4gICAgQVBQX0NPTlRFTlQ6ICdtZGMtc2lkZS1zaGVldC1hcHAtY29udGVudCcsXHJcbiAgICBTQ1JJTTogJ21kYy1zaWRlLXNoZWV0LXNjcmltJyxcclxufTsiLCJpbXBvcnQgeyBmb3J3YXJkUmVmIH0gZnJvbSAncmVhY3QnO1xyXG5cclxuaW1wb3J0IHsgQ2xvbmUgfSBmcm9tICcuLi9jb21wb25lbnQnO1xyXG5pbXBvcnQgSWNvbkJ1dHRvbiBmcm9tICcuLi9pY29uLWJ1dHRvbic7XHJcblxyXG5pbXBvcnQgeyBjc3NDbGFzc2VzIH0gZnJvbSAnLi9jb25zdGFudHMnO1xyXG5cclxuY29uc3QgU2lkZVNoZWV0SGVhZGVyID0gZm9yd2FyZFJlZigoe1xyXG4gICAgdGl0bGUsXHJcbiAgICBjbG9zZUljb24sXHJcbiAgICBvbkNsb3NlLFxyXG5cclxuICAgIGVsZW1lbnQ6IEVsZW1lbnQgPSAnaGVhZGVyJyxcclxuICAgIC4uLnByb3BzXHJcbn0sIHJlZikgPT4ge1xyXG4gICAgcmV0dXJuIChcclxuICAgICAgICA8RWxlbWVudCByZWY9e3JlZn0gY2xhc3NOYW1lPXtjc3NDbGFzc2VzLkhFQURFUn0gey4uLnByb3BzfT5cclxuICAgICAgICAgICAge3RpdGxlICYmXHJcbiAgICAgICAgICAgICAgICA8Q2xvbmVcclxuICAgICAgICAgICAgICAgICAgICBjb21wb25lbnQ9e3RpdGxlfVxyXG4gICAgICAgICAgICAgICAgICAgIGZhbGxiYWNrPVwiaDNcIlxyXG4gICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT17Y3NzQ2xhc3Nlcy5USVRMRX1cclxuICAgICAgICAgICAgICAgIC8+XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHtjbG9zZUljb24gJiZcclxuICAgICAgICAgICAgICAgIDxDbG9uZVxyXG4gICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudD17Y2xvc2VJY29ufVxyXG4gICAgICAgICAgICAgICAgICAgIGZhbGxiYWNrPXtJY29uQnV0dG9ufVxyXG4gICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT17Y3NzQ2xhc3Nlcy5DTE9TRV9CVVRUT059XHJcbiAgICAgICAgICAgICAgICAgICAgb25DbGljaz17b25DbG9zZX1cclxuICAgICAgICAgICAgICAgIC8+XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICA8L0VsZW1lbnQ+XHJcbiAgICApO1xyXG59KTtcclxuXHJcblNpZGVTaGVldEhlYWRlci5kaXNwbGF5TmFtZSA9ICdNRENTaWRlU2hlZXRIZWFkZXInO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgU2lkZVNoZWV0SGVhZGVyOyIsImltcG9ydCB7IGZvcndhcmRSZWYgfSBmcm9tICdyZWFjdCc7XHJcblxyXG5pbXBvcnQgeyBjc3NDbGFzc2VzIH0gZnJvbSAnLi9jb25zdGFudHMnO1xyXG5cclxuY29uc3QgU2lkZVNoZWV0Q29udGVudCA9IGZvcndhcmRSZWYoKHsgZWxlbWVudDogRWxlbWVudCA9ICdkaXYnLCAuLi5wcm9wcyB9LCByZWYpID0+IHtcclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgPEVsZW1lbnQgcmVmPXtyZWZ9IGNsYXNzTmFtZT17Y3NzQ2xhc3Nlcy5DT05URU5UfSB7Li4ucHJvcHN9IC8+XHJcbiAgICApO1xyXG59KTtcclxuXHJcblNpZGVTaGVldENvbnRlbnQuZGlzcGxheU5hbWUgPSAnTURDU2lkZVNoZWV0Q29udGVudCc7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBTaWRlU2hlZXRDb250ZW50OyIsImltcG9ydCB7IGZvcndhcmRSZWYsIHVzZVJlZiwgdXNlSW1wZXJhdGl2ZUhhbmRsZSwgdXNlRWZmZWN0IH0gZnJvbSAncmVhY3QnO1xyXG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xyXG5pbXBvcnQgY2xhc3NuYW1lcyBmcm9tICdjbGFzc25hbWVzJztcclxuXHJcbmltcG9ydCBMYXllciBmcm9tICcuLi9sYXllcic7XHJcblxyXG5pbXBvcnQgeyBudW1iZXJzLCBjc3NDbGFzc2VzIH0gZnJvbSAnLi9jb25zdGFudHMnO1xyXG5pbXBvcnQgU2lkZVNoZWV0SGVhZGVyIGZyb20gJy4vU2lkZVNoZWV0SGVhZGVyJztcclxuaW1wb3J0IFNpZGVTaGVldENvbnRlbnQgZnJvbSAnLi9TaWRlU2hlZXRDb250ZW50JztcclxuXHJcbmNvbnN0IFNpZGVTaGVldCA9IGZvcndhcmRSZWYoKHtcclxuICAgIHRpdGxlLFxyXG4gICAgY29udGVudCxcclxuICAgIG9wZW4gPSBmYWxzZSxcclxuICAgIGFwcGVhciA9IGZhbHNlLFxyXG4gICAgZGlzbWlzc2libGUgPSBmYWxzZSxcclxuICAgIG1vZGFsID0gZmFsc2UsXHJcbiAgICBjbG9zZUljb24gPSBkaXNtaXNzaWJsZSAmJiAnY2xvc2UnLFxyXG4gICAgYXBwQ29udGVudFNlbGVjdG9yLFxyXG4gICAgb25DbG9zZSA9IEZ1bmN0aW9uLnByb3RvdHlwZSxcclxuXHJcbiAgICBlbGVtZW50ID0gJ2FzaWRlJyxcclxuICAgIGNvbXBvbmVudDogRWxlbWVudCA9IGVsZW1lbnQsXHJcbiAgICBjbGFzc05hbWUsXHJcbiAgICBjaGlsZHJlbixcclxuICAgIC4uLnByb3BzXHJcbn0sIHJlZikgPT4ge1xyXG4gICAgY29uc3Qgcm9vdFJlZiA9IHVzZVJlZigpO1xyXG5cclxuICAgIHVzZUltcGVyYXRpdmVIYW5kbGUocmVmLCAoKSA9PiByb290UmVmLmN1cnJlbnQpO1xyXG5cclxuICAgIHVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICAgICAgaWYgKCFkaXNtaXNzaWJsZSkgcmV0dXJuO1xyXG5cclxuICAgICAgICBjb25zdCBhcHBDb250ZW50RWxlbWVudCA9IGFwcENvbnRlbnRTZWxlY3RvciA/XHJcbiAgICAgICAgICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoYXBwQ29udGVudFNlbGVjdG9yKSA6XHJcbiAgICAgICAgICAgIHJvb3RSZWYuY3VycmVudC5uZXh0RWxlbWVudFNpYmxpbmc7XHJcblxyXG4gICAgICAgIGFwcENvbnRlbnRFbGVtZW50Py5jbGFzc0xpc3QuYWRkKGNzc0NsYXNzZXMuQVBQX0NPTlRFTlQpO1xyXG5cclxuICAgICAgICByZXR1cm4gKCkgPT4ge1xyXG4gICAgICAgICAgICBhcHBDb250ZW50RWxlbWVudD8uY2xhc3NMaXN0LnJlbW92ZShjc3NDbGFzc2VzLkFQUF9DT05URU5UKTtcclxuICAgICAgICB9O1xyXG4gICAgfSwgW2Rpc21pc3NpYmxlLCBhcHBDb250ZW50U2VsZWN0b3JdKTtcclxuXHJcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgICAgIGlmICghbW9kYWwpIHJldHVybjtcclxuXHJcbiAgICAgICAgZnVuY3Rpb24gaGFuZGxlRG9jdW1lbnRLZXlEb3duKGV2ZW50KSB7XHJcbiAgICAgICAgICAgIGlmIChldmVudC5rZXkgJiYgZXZlbnQua2V5ID09PSAnRXNjYXBlJyB8fCBldmVudC5rZXlDb2RlID09PSAyNykge1xyXG4gICAgICAgICAgICAgICAgb25DbG9zZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgaGFuZGxlRG9jdW1lbnRLZXlEb3duKTtcclxuXHJcbiAgICAgICAgcmV0dXJuICgpID0+IGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCBoYW5kbGVEb2N1bWVudEtleURvd24pO1xyXG4gICAgfSwgW21vZGFsLCBvbkNsb3NlXSk7XHJcblxyXG4gICAgY29uc3QgY2xhc3NOYW1lcyA9IGNsYXNzbmFtZXMoY3NzQ2xhc3Nlcy5ST09ULCB7XHJcbiAgICAgICAgW2Nzc0NsYXNzZXMuRElTTUlTU0lCTEVdOiBkaXNtaXNzaWJsZSxcclxuICAgICAgICBbY3NzQ2xhc3Nlcy5NT0RBTF06IG1vZGFsXHJcbiAgICB9LCBjbGFzc05hbWUpO1xyXG5cclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgPExheWVyXHJcbiAgICAgICAgICAgIGluPXtvcGVufVxyXG4gICAgICAgICAgICBhcHBlYXI9e2FwcGVhcn1cclxuICAgICAgICAgICAgbW9kYWw9e21vZGFsfVxyXG4gICAgICAgICAgICBmaXhlZD17bW9kYWx9XHJcbiAgICAgICAgICAgIHRpbWVvdXQ9e3tcclxuICAgICAgICAgICAgICAgIGVudGVyOiBudW1iZXJzLkFOSU1BVElPTl9FTlRFUl9USU1FX01TLFxyXG4gICAgICAgICAgICAgICAgZXhpdDogbnVtYmVycy5BTklNQVRJT05fRVhJVF9USU1FX01TXHJcbiAgICAgICAgICAgIH19XHJcbiAgICAgICAgICAgIGNsYXNzTmFtZXM9e3tcclxuICAgICAgICAgICAgICAgIGFwcGVhcjogY3NzQ2xhc3Nlcy5PUEVOLFxyXG4gICAgICAgICAgICAgICAgZW50ZXI6IGAke2Nzc0NsYXNzZXMuT1BFTn0gJHtjc3NDbGFzc2VzLkFOSU1BVEV9YCxcclxuICAgICAgICAgICAgICAgIGVudGVyQWN0aXZlOiBgJHtjc3NDbGFzc2VzLk9QRU59ICR7Y3NzQ2xhc3Nlcy5PUEVOSU5HfWAsXHJcbiAgICAgICAgICAgICAgICBlbnRlckRvbmU6IGNzc0NsYXNzZXMuT1BFTixcclxuICAgICAgICAgICAgICAgIGV4aXQ6IGAke2Nzc0NsYXNzZXMuT1BFTn0gJHtjc3NDbGFzc2VzLkNMT1NJTkd9YCxcclxuICAgICAgICAgICAgICAgIGV4aXRBY3RpdmU6IGNzc0NsYXNzZXMuQ0xPU0lOR1xyXG4gICAgICAgICAgICB9fVxyXG4gICAgICAgICAgICBtb3VudE9uRW50ZXI9e21vZGFsfVxyXG4gICAgICAgICAgICB1bm1vdW50T25FeGl0PXttb2RhbH1cclxuICAgICAgICA+XHJcbiAgICAgICAgICAgIDw+XHJcbiAgICAgICAgICAgICAgICA8RWxlbWVudFxyXG4gICAgICAgICAgICAgICAgICAgIHJlZj17cm9vdFJlZn1cclxuICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU9e2NsYXNzTmFtZXN9XHJcbiAgICAgICAgICAgICAgICAgICAgey4uLnByb3BzfVxyXG4gICAgICAgICAgICAgICAgPlxyXG4gICAgICAgICAgICAgICAgICAgIHsodGl0bGUgfHwgZGlzbWlzc2libGUpICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxTaWRlU2hlZXRIZWFkZXJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlPXt0aXRsZX1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2xvc2U9e29uQ2xvc2V9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbG9zZUljb249e2Nsb3NlSWNvbn1cclxuICAgICAgICAgICAgICAgICAgICAgICAgLz5cclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHtjb250ZW50ICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxTaWRlU2hlZXRDb250ZW50PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge2NvbnRlbnR9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDwvU2lkZVNoZWV0Q29udGVudD5cclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHtjaGlsZHJlbn1cclxuICAgICAgICAgICAgICAgIDwvRWxlbWVudD5cclxuXHJcbiAgICAgICAgICAgICAgICB7bW9kYWwgJiZcclxuICAgICAgICAgICAgICAgICAgICA8ZGl2XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT17Y3NzQ2xhc3Nlcy5TQ1JJTX1cclxuICAgICAgICAgICAgICAgICAgICAgICAgb25DbGljaz17b25DbG9zZX1cclxuICAgICAgICAgICAgICAgICAgICAvPlxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICA8Lz5cclxuICAgICAgICA8L0xheWVyPlxyXG4gICAgKTtcclxufSk7XHJcblxyXG5TaWRlU2hlZXQuZGlzcGxheU5hbWUgPSAnTURDU2lkZVNoZWV0JztcclxuXHJcblNpZGVTaGVldC5wcm9wVHlwZXMgPSB7XHJcbiAgICB0aXRsZTogUHJvcFR5cGVzLnN0cmluZyxcclxuICAgIGNvbnRlbnQ6IFByb3BUeXBlcy5ub2RlLFxyXG4gICAgY2xvc2VJY29uOiBQcm9wVHlwZXMubm9kZSxcclxuICAgIG9wZW46IFByb3BUeXBlcy5ib29sLFxyXG4gICAgYXBwZWFyOiBQcm9wVHlwZXMuYm9vbCxcclxuICAgIGRpc21pc3NpYmxlOiBQcm9wVHlwZXMuYm9vbCxcclxuICAgIG1vZGFsOiBQcm9wVHlwZXMuYm9vbCxcclxuICAgIGFwcENvbnRlbnRTZWxlY3RvcjogUHJvcFR5cGVzLnN0cmluZyxcclxuICAgIG9uQ2xvc2U6IFByb3BUeXBlcy5mdW5jXHJcbn07XHJcblxyXG5leHBvcnQgZGVmYXVsdCBTaWRlU2hlZXQ7IiwiaW1wb3J0IHsgZm9yd2FyZFJlZiB9IGZyb20gJ3JlYWN0JztcclxuaW1wb3J0IGNsYXNzbmFtZXMgZnJvbSAnY2xhc3NuYW1lcyc7XHJcblxyXG5pbXBvcnQgeyBjc3NDbGFzc2VzIH0gZnJvbSAnLi9jb25zdGFudHMnO1xyXG5cclxuY29uc3QgU2lkZVNoZWV0QXBwQ29udGVudCA9IGZvcndhcmRSZWYoKHsgZWxlbWVudDogRWxlbWVudCA9ICdkaXYnLCBjbGFzc05hbWUsIC4uLnByb3BzIH0sIHJlZikgPT4ge1xyXG4gICAgY29uc3QgY2xhc3NOYW1lcyA9IGNsYXNzbmFtZXMoY3NzQ2xhc3Nlcy5BUFBfQ09OVEVOVCwgY2xhc3NOYW1lKTtcclxuXHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAgIDxFbGVtZW50IHJlZj17cmVmfSBjbGFzc05hbWU9e2NsYXNzTmFtZXN9IHsuLi5wcm9wc30gLz5cclxuICAgICk7XHJcbn0pO1xyXG5cclxuU2lkZVNoZWV0QXBwQ29udGVudC5kaXNwbGF5TmFtZSA9ICdNRENTaWRlU2hlZXRBcHBDb250ZW50JztcclxuXHJcbmV4cG9ydCBkZWZhdWx0IFNpZGVTaGVldEFwcENvbnRlbnQ7IiwiaW1wb3J0IFNpZGVTaGVldCBmcm9tICcuL1NpZGVTaGVldCc7XHJcbmltcG9ydCBTaWRlU2hlZXRIZWFkZXIgZnJvbSAnLi9TaWRlU2hlZXRIZWFkZXInO1xyXG5pbXBvcnQgU2lkZVNoZWV0Q29udGVudCBmcm9tICcuL1NpZGVTaGVldENvbnRlbnQnO1xyXG5pbXBvcnQgU2lkZVNoZWV0QXBwQ29udGVudCBmcm9tICcuL1NpZGVTaGVldEFwcENvbnRlbnQnO1xyXG5cclxuU2lkZVNoZWV0LkhlYWRlciA9IFNpZGVTaGVldEhlYWRlcjtcclxuU2lkZVNoZWV0LkNvbnRlbnQgPSBTaWRlU2hlZXRDb250ZW50O1xyXG5TaWRlU2hlZXQuQXBwQ29udGVudCA9IFNpZGVTaGVldEFwcENvbnRlbnQ7XHJcblxyXG5leHBvcnQge1xyXG4gICAgU2lkZVNoZWV0IGFzIGRlZmF1bHQsXHJcbiAgICBTaWRlU2hlZXRIZWFkZXIsXHJcbiAgICBTaWRlU2hlZXRDb250ZW50LFxyXG4gICAgU2lkZVNoZWV0QXBwQ29udGVudFxyXG59OyIsImV4cG9ydCBjb25zdCBudW1iZXJzID0ge1xyXG4gICAgVEhVTUJfV0lEVEg6IDQ4XHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgY3NzQ2xhc3NlcyA9IHtcclxuICAgIFJPT1Q6ICdtZGMtc2xpZGVyJyxcclxuICAgIFJBTkdFOiAnbWRjLXNsaWRlci0tcmFuZ2UnLFxyXG4gICAgRElTQ1JFVEU6ICdtZGMtc2xpZGVyLS1kaXNjcmV0ZScsXHJcbiAgICBESVNBQkxFRDogJ21kYy1zbGlkZXItLWRpc2FibGVkJyxcclxuXHJcbiAgICBJTlBVVDogJ21kYy1zbGlkZXJfX2lucHV0JyxcclxuXHJcbiAgICBUUkFDSzogJ21kYy1zbGlkZXJfX3RyYWNrJyxcclxuICAgIFRSQUNLX0lOQUNUSVZFOiAnbWRjLXNsaWRlcl9fdHJhY2stLWluYWN0aXZlJyxcclxuICAgIFRSQUNLX0FDVElWRTogJ21kYy1zbGlkZXJfX3RyYWNrLS1hY3RpdmUnLFxyXG4gICAgVFJBQ0tfQUNUSVZFX0ZJTEw6ICdtZGMtc2xpZGVyX190cmFjay0tYWN0aXZlX2ZpbGwnLFxyXG5cclxuICAgIFRJQ0tfTUFSS1M6ICdtZGMtc2xpZGVyX190aWNrLW1hcmtzJyxcclxuICAgIFRJQ0tfTUFSS19BQ1RJVkU6ICdtZGMtc2xpZGVyX190aWNrLW1hcmstLWFjdGl2ZScsXHJcbiAgICBUSUNLX01BUktfSU5BQ1RJVkU6ICdtZGMtc2xpZGVyX190aWNrLW1hcmstLWluYWN0aXZlJyxcclxuXHJcbiAgICBUSFVNQjogJ21kYy1zbGlkZXJfX3RodW1iJyxcclxuICAgIFRIVU1CX1RPUDogJ21kYy1zbGlkZXJfX3RodW1iLS10b3AnLFxyXG4gICAgVEhVTUJfRk9DVVNFRDogJ21kYy1zbGlkZXJfX3RodW1iLS1mb2N1c2VkJyxcclxuICAgIFRIVU1CX1dJVEhfSU5ESUNBVE9SOiAnbWRjLXNsaWRlcl9fdGh1bWItLXdpdGgtaW5kaWNhdG9yJyxcclxuICAgIFRIVU1CX0tOT0I6ICdtZGMtc2xpZGVyX190aHVtYi1rbm9iJyxcclxuXHJcbiAgICBWQUxVRV9JTkRJQ0FUT1JfQ09OVEFJTkVSOiAnbWRjLXNsaWRlcl9fdmFsdWUtaW5kaWNhdG9yLWNvbnRhaW5lcicsXHJcbiAgICBWQUxVRV9JTkRJQ0FUT1I6ICdtZGMtc2xpZGVyX192YWx1ZS1pbmRpY2F0b3InLFxyXG4gICAgVkFMVUVfSU5ESUNBVE9SX1RFWFQ6ICdtZGMtc2xpZGVyX192YWx1ZS1pbmRpY2F0b3ItdGV4dCdcclxufTsiLCJpbXBvcnQgeyBLZXkgfSBmcm9tICcuLi9jb25zdGFudHMnO1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGdldFZhbHVlRm9yRXZlbnRLZXkoZXZlbnRLZXksIHZhbHVlLCBtaW4sIG1heCwgc3RlcCkge1xyXG4gICAgY29uc3QgZGVsdGEgPSBOdW1iZXIoc3RlcCkgfHwgKG1heCAtIG1pbikgLyAxMDA7XHJcblxyXG4gICAgc3dpdGNoIChldmVudEtleSkge1xyXG4gICAgICAgIGNhc2UgS2V5LkFSUk9XX0xFRlQ6XHJcbiAgICAgICAgY2FzZSBLZXkuQVJST1dfRE9XTjpcclxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlIC0gZGVsdGE7XHJcblxyXG4gICAgICAgIGNhc2UgS2V5LkFSUk9XX1JJR0hUOlxyXG4gICAgICAgIGNhc2UgS2V5LkFSUk9XX1VQOlxyXG4gICAgICAgICAgICByZXR1cm4gdmFsdWUgKyBkZWx0YTtcclxuXHJcbiAgICAgICAgY2FzZSBLZXkuSE9NRTpcclxuICAgICAgICAgICAgcmV0dXJuIG1pbjtcclxuXHJcbiAgICAgICAgY2FzZSBLZXkuRU5EOlxyXG4gICAgICAgICAgICByZXR1cm4gbWF4O1xyXG5cclxuICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICByZXR1cm4gTmFOO1xyXG4gICAgfVxyXG59IiwiaW1wb3J0IHsgZm9yd2FyZFJlZiB9IGZyb20gJ3JlYWN0JztcclxuXHJcbmltcG9ydCB7IGNzc0NsYXNzZXMgfSBmcm9tICcuL2NvbnN0YW50cyc7XHJcblxyXG5jb25zdCBJbnB1dCA9IGZvcndhcmRSZWYoKHtcclxuICAgIHZhbHVlLFxyXG4gICAgLi4ucHJvcHNcclxufSwgcmVmKSA9PiB7XHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAgIDxpbnB1dFxyXG4gICAgICAgICAgICByZWY9e3JlZn1cclxuICAgICAgICAgICAgY2xhc3NOYW1lPXtjc3NDbGFzc2VzLklOUFVUfVxyXG4gICAgICAgICAgICB0eXBlPVwicmFuZ2VcIlxyXG4gICAgICAgICAgICB2YWx1ZT17TWF0aC5yb3VuZCh2YWx1ZSl9XHJcbiAgICAgICAgICAgIG9uQ2hhbmdlPXtGdW5jdGlvbi5wcm90b3R5cGV9XHJcbiAgICAgICAgICAgIHsuLi5wcm9wc31cclxuICAgICAgICAvPlxyXG4gICAgKTtcclxufSk7XHJcblxyXG5JbnB1dC5kaXNwbGF5TmFtZSA9ICdNRENTbGlkZXJJbnB1dCc7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBJbnB1dDsiLCJpbXBvcnQgY2xhc3NuYW1lcyBmcm9tICdjbGFzc25hbWVzJztcclxuXHJcbmltcG9ydCB7IGNzc0NsYXNzZXMgfSBmcm9tICcuL2NvbnN0YW50cyc7XHJcblxyXG5jb25zdCBUaWNrTWFya3MgPSAoe1xyXG4gICAgdmFsdWUsXHJcbiAgICBtaW4sXHJcbiAgICBtYXgsXHJcbiAgICBzdGVwID0gMVxyXG59KSA9PiB7XHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPXtjc3NDbGFzc2VzLlRJQ0tfTUFSS1N9PlxyXG4gICAgICAgICAgICB7QXJyYXkuZnJvbShuZXcgQXJyYXkoKG1heCAtIG1pbikgLyBzdGVwICsgMSkpXHJcbiAgICAgICAgICAgICAgICAubWFwKChfLCBpKSA9PiBzdGVwICogaSArIE51bWJlcihtaW4pKVxyXG4gICAgICAgICAgICAgICAgLm1hcCh0aWNrVmFsdWUgPT5cclxuICAgICAgICAgICAgICAgICAgICA8ZGl2XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleT17dGlja1ZhbHVlfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhLXZhbHVlPXt0aWNrVmFsdWV9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT17XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGFzc25hbWVzKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbY3NzQ2xhc3Nlcy5USUNLX01BUktfQUNUSVZFXTogdGlja1ZhbHVlIDw9IHZhbHVlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtjc3NDbGFzc2VzLlRJQ0tfTUFSS19JTkFDVElWRV06IHRpY2tWYWx1ZSA+IHZhbHVlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgLz5cclxuICAgICAgICAgICAgICAgIClcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIDwvZGl2PlxyXG4gICAgKTtcclxufTtcclxuXHJcblRpY2tNYXJrcy5kaXNwbGF5TmFtZSA9ICdNRENTbGlkZXJUaWNrTWFya3MnO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgVGlja01hcmtzOyIsImltcG9ydCB7IGZvcndhcmRSZWYgfSBmcm9tICdyZWFjdCc7XHJcblxyXG5pbXBvcnQgeyBjc3NDbGFzc2VzIH0gZnJvbSAnLi9jb25zdGFudHMnO1xyXG5pbXBvcnQgVGlja01hcmtzIGZyb20gJy4vVGlja01hcmtzJztcclxuXHJcbmNvbnN0IFRyYWNrID0gZm9yd2FyZFJlZigoe1xyXG4gICAgdmFsdWUsXHJcbiAgICBtaW4sXHJcbiAgICBtYXgsXHJcbiAgICBzdGVwLFxyXG4gICAgZGlzY3JldGUsXHJcbiAgICB0aWNrTWFya3NcclxufSwgcmVmKSA9PiB7XHJcbiAgICBjb25zdCBzdHlsZSA9IHtcclxuICAgICAgICB0cmFuc2Zvcm06IGBzY2FsZVgoJHsodmFsdWUgLSBtaW4pIC8gKG1heCAtIG1pbil9KWBcclxuICAgIH07XHJcblxyXG4gICAgcmV0dXJuIChcclxuICAgICAgICA8ZGl2IHJlZj17cmVmfSBjbGFzc05hbWU9e2Nzc0NsYXNzZXMuVFJBQ0t9PlxyXG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17Y3NzQ2xhc3Nlcy5UUkFDS19JTkFDVElWRX0gLz5cclxuXHJcbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXtjc3NDbGFzc2VzLlRSQUNLX0FDVElWRX0+XHJcbiAgICAgICAgICAgICAgICA8ZGl2XHJcbiAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPXtjc3NDbGFzc2VzLlRSQUNLX0FDVElWRV9GSUxMfVxyXG4gICAgICAgICAgICAgICAgICAgIHN0eWxlPXtzdHlsZX1cclxuICAgICAgICAgICAgICAgIC8+XHJcbiAgICAgICAgICAgIDwvZGl2PlxyXG5cclxuICAgICAgICAgICAge2Rpc2NyZXRlICYmIHRpY2tNYXJrcyAmJlxyXG4gICAgICAgICAgICAgICAgPFRpY2tNYXJrc1xyXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlPXt2YWx1ZX1cclxuICAgICAgICAgICAgICAgICAgICBtaW49e21pbn1cclxuICAgICAgICAgICAgICAgICAgICBtYXg9e21heH1cclxuICAgICAgICAgICAgICAgICAgICBzdGVwPXtzdGVwfVxyXG4gICAgICAgICAgICAgICAgLz5cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIDwvZGl2PlxyXG4gICAgKTtcclxufSk7XHJcblxyXG5UcmFjay5kaXNwbGF5TmFtZSA9ICdNRENTbGlkZXJUcmFjayc7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBUcmFjazsiLCJpbXBvcnQgeyBmb3J3YXJkUmVmLCB1c2VTdGF0ZSwgdXNlQ2FsbGJhY2sgfSBmcm9tICdyZWFjdCc7XHJcbmltcG9ydCBjbGFzc25hbWVzIGZyb20gJ2NsYXNzbmFtZXMnO1xyXG5cclxuaW1wb3J0IHsgbnVtYmVycywgY3NzQ2xhc3NlcyB9IGZyb20gJy4vY29uc3RhbnRzJztcclxuXHJcbmNvbnN0IFRodW1iID0gZm9yd2FyZFJlZigoe1xyXG4gICAgdmFsdWUsXHJcbiAgICBtaW4sXHJcbiAgICBtYXgsXHJcbiAgICBkaXNjcmV0ZSxcclxuICAgIGRpc2FibGVkLFxyXG4gICAgb25TdGFydEludGVyYWN0aW9uLFxyXG4gICAgb25FbmRJbnRlcmFjdGlvbixcclxuICAgIC4uLnByb3BzXHJcbn0sIHJlZikgPT4ge1xyXG4gICAgY29uc3QgW2ZvY3VzZWQsIHNldEZvY3VzZWRdID0gdXNlU3RhdGUoZmFsc2UpO1xyXG5cclxuICAgIGNvbnN0IGhhbmRsZUZvY3VzID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xyXG4gICAgICAgIHNldEZvY3VzZWQodHJ1ZSk7XHJcbiAgICB9LCBbXSk7XHJcblxyXG4gICAgY29uc3QgaGFuZGxlQmx1ciA9IHVzZUNhbGxiYWNrKCgpID0+IHtcclxuICAgICAgICBzZXRGb2N1c2VkKGZhbHNlKTtcclxuICAgIH0sIFtdKTtcclxuXHJcbiAgICBjb25zdCBjbGFzc05hbWVzID0gY2xhc3NuYW1lcyhjc3NDbGFzc2VzLlRIVU1CLCB7XHJcbiAgICAgICAgW2Nzc0NsYXNzZXMuVEhVTUJfRk9DVVNFRF06IGZvY3VzZWQsXHJcbiAgICAgICAgW2Nzc0NsYXNzZXMuVEhVTUJfV0lUSF9JTkRJQ0FUT1JdOiBkaXNjcmV0ZSAmJiBmb2N1c2VkXHJcbiAgICB9KTtcclxuXHJcbiAgICBjb25zdCBzdHlsZSA9IHtcclxuICAgICAgICBsZWZ0OiBgY2FsYygkeyh2YWx1ZSAtIG1pbikgLyAobWF4IC0gbWluKSAqIDEwMH0lIC0gJHtudW1iZXJzLlRIVU1CX1dJRFRIICogMC41fXB4KWBcclxuICAgIH07XHJcblxyXG4gICAgcmV0dXJuIChcclxuICAgICAgICA8ZGl2XHJcbiAgICAgICAgICAgIHJlZj17cmVmfVxyXG4gICAgICAgICAgICBjbGFzc05hbWU9e2NsYXNzTmFtZXN9XHJcbiAgICAgICAgICAgIHJvbGU9XCJzbGlkZXJcIlxyXG4gICAgICAgICAgICB0YWJJbmRleD17ZGlzYWJsZWQgPyAnLTEnIDogJzAnfVxyXG4gICAgICAgICAgICBhcmlhLXZhbHVlbWluPVwiMFwiXHJcbiAgICAgICAgICAgIGFyaWEtdmFsdWVtYXg9XCIxMDBcIlxyXG4gICAgICAgICAgICBhcmlhLXZhbHVlbm93PVwiNTBcIlxyXG4gICAgICAgICAgICBhcmlhLWRpc2FibGVkPXtkaXNhYmxlZCB8fCB1bmRlZmluZWR9XHJcbiAgICAgICAgICAgIHN0eWxlPXtzdHlsZX1cclxuICAgICAgICAgICAgb25Gb2N1cz17aGFuZGxlRm9jdXN9XHJcbiAgICAgICAgICAgIG9uQmx1cj17aGFuZGxlQmx1cn1cclxuICAgICAgICAgICAgb25Nb3VzZURvd249e29uU3RhcnRJbnRlcmFjdGlvbn1cclxuICAgICAgICAgICAgb25Nb3VzZVVwPXtvbkVuZEludGVyYWN0aW9ufVxyXG4gICAgICAgICAgICBvblRvdWNoU3RhcnQ9e29uU3RhcnRJbnRlcmFjdGlvbn1cclxuICAgICAgICAgICAgb25Ub3VjaEVuZD17b25FbmRJbnRlcmFjdGlvbn1cclxuICAgICAgICAgICAgey4uLnByb3BzfVxyXG4gICAgICAgID5cclxuICAgICAgICAgICAge2Rpc2NyZXRlICYmXHJcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17Y3NzQ2xhc3Nlcy5WQUxVRV9JTkRJQ0FUT1JfQ09OVEFJTkVSfT5cclxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17Y3NzQ2xhc3Nlcy5WQUxVRV9JTkRJQ0FUT1J9PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9e2Nzc0NsYXNzZXMuVkFMVUVfSU5ESUNBVE9SX1RFWFR9Pnt2YWx1ZX08L3NwYW4+XHJcbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9e2Nzc0NsYXNzZXMuVEhVTUJfS05PQn0gLz5cclxuICAgICAgICA8L2Rpdj5cclxuICAgICk7XHJcbn0pO1xyXG5cclxuVGh1bWIuZGlzcGxheU5hbWUgPSAnTURDU2xpZGVyVGh1bWInO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgVGh1bWI7IiwiaW1wb3J0IHsgZm9yd2FyZFJlZiwgdXNlUmVmLCB1c2VTdGF0ZSwgdXNlQ2FsbGJhY2sgfSBmcm9tICdyZWFjdCc7XHJcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XHJcbmltcG9ydCBjbGFzc25hbWVzIGZyb20gJ2NsYXNzbmFtZXMnO1xyXG5cclxuaW1wb3J0IHsgdXNlVXBkYXRlZCB9IGZyb20gJy4uL2hvb2tzJztcclxuaW1wb3J0IHsgZ2V0RXZlbnRLZXksIGdldFBhZ2VYIH0gZnJvbSAnLi4vdXRpbHMnO1xyXG5cclxuaW1wb3J0IHsgY3NzQ2xhc3NlcyB9IGZyb20gJy4vY29uc3RhbnRzJztcclxuaW1wb3J0IHsgZ2V0VmFsdWVGb3JFdmVudEtleSB9IGZyb20gJy4vdXRpbHMnO1xyXG5pbXBvcnQgSW5wdXQgZnJvbSAnLi9JbnB1dCc7XHJcbmltcG9ydCBUcmFjayBmcm9tICcuL1RyYWNrJztcclxuaW1wb3J0IFRodW1iIGZyb20gJy4vVGh1bWInO1xyXG5cclxuY29uc3QgU2xpZGVyID0gZm9yd2FyZFJlZigoe1xyXG4gICAgbmFtZSxcclxuICAgIHZhbHVlID0gMCxcclxuICAgIG1pbiA9IDAsXHJcbiAgICBtYXggPSAxMDAsXHJcbiAgICBzdGVwLFxyXG4gICAgZGlzY3JldGUgPSBmYWxzZSxcclxuICAgIGRpc2FibGVkID0gZmFsc2UsXHJcbiAgICB0aWNrTWFya3MgPSBmYWxzZSxcclxuICAgIG9uQ2hhbmdlID0gRnVuY3Rpb24ucHJvdG90eXBlLFxyXG5cclxuICAgIGNsYXNzTmFtZSxcclxuICAgIC4uLnByb3BzXHJcbn0sIHJlZikgPT4ge1xyXG4gICAgY29uc3QgaW5wdXRSZWYgPSB1c2VSZWYoKTtcclxuICAgIGNvbnN0IHRyYWNrUmVmID0gdXNlUmVmKCk7XHJcblxyXG4gICAgY29uc3QgW2FjdGl2ZSwgc2V0QWN0aXZlXSA9IHVzZVN0YXRlKGZhbHNlKTtcclxuXHJcbiAgICB1c2VVcGRhdGVkKCgpID0+IHtcclxuICAgICAgICBpZiAoZGlzYWJsZWQpIHJldHVybjtcclxuXHJcbiAgICAgICAgaWYgKGFjdGl2ZSkge1xyXG4gICAgICAgICAgICBkb2N1bWVudC5ib2R5LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIGhhbmRsZU1vdmUpO1xyXG4gICAgICAgICAgICBkb2N1bWVudC5ib2R5LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIGhhbmRsZU1vdmUpO1xyXG4gICAgICAgICAgICBkb2N1bWVudC5ib2R5LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCBoYW5kbGVVcCk7XHJcbiAgICAgICAgICAgIGRvY3VtZW50LmJvZHkuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCBoYW5kbGVVcCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBoYW5kbGVNb3ZlKTtcclxuICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCBoYW5kbGVNb3ZlKTtcclxuICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgaGFuZGxlVXApO1xyXG4gICAgICAgICAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgaGFuZGxlVXApO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuICgpID0+IHtcclxuICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBoYW5kbGVNb3ZlKTtcclxuICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCBoYW5kbGVNb3ZlKTtcclxuICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgaGFuZGxlVXApO1xyXG4gICAgICAgICAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgaGFuZGxlVXApO1xyXG4gICAgICAgIH07XHJcbiAgICB9LCBbYWN0aXZlXSk7XHJcblxyXG4gICAgY29uc3QgdXBkYXRlVmFsdWUgPSB1c2VDYWxsYmFjayhuZXdWYWx1ZSA9PiB7XHJcbiAgICAgICAgaWYgKG5ld1ZhbHVlIDwgbWluKSB7XHJcbiAgICAgICAgICAgIG5ld1ZhbHVlID0gTnVtYmVyKG1pbik7XHJcbiAgICAgICAgfSBlbHNlIGlmIChuZXdWYWx1ZSA+IG1heCkge1xyXG4gICAgICAgICAgICBuZXdWYWx1ZSA9IE51bWJlcihtYXgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHN0ZXApIHtcclxuICAgICAgICAgICAgbmV3VmFsdWUgPSBNYXRoLnJvdW5kKG5ld1ZhbHVlIC8gc3RlcCkgKiBzdGVwO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgb25DaGFuZ2UobmV3VmFsdWUpO1xyXG4gICAgfSwgW21pbiwgbWF4LCBzdGVwLCBvbkNoYW5nZV0pO1xyXG5cclxuICAgIGNvbnN0IGhhbmRsZU1vdmUgPSB1c2VDYWxsYmFjayhldmVudCA9PiB7XHJcbiAgICAgICAgY29uc3QgdHJhY2tDbGllbnRSZWN0ID0gdHJhY2tSZWYuY3VycmVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcclxuICAgICAgICBjb25zdCBwYWdlWCA9IGdldFBhZ2VYKGV2ZW50KTtcclxuICAgICAgICBjb25zdCBvZmZzZXRYID0gcGFnZVggLSB0cmFja0NsaWVudFJlY3QubGVmdDtcclxuICAgICAgICBjb25zdCBwZXJjZW50ID0gb2Zmc2V0WCAvIHRyYWNrQ2xpZW50UmVjdC53aWR0aDtcclxuICAgICAgICBjb25zdCB2YWx1ZSA9IE51bWJlcihtaW4pICsgcGVyY2VudCAqIChtYXggLSBtaW4pO1xyXG5cclxuICAgICAgICB1cGRhdGVWYWx1ZSh2YWx1ZSk7XHJcbiAgICB9LCBbbWluLCBtYXgsIHVwZGF0ZVZhbHVlXSk7XHJcblxyXG4gICAgY29uc3QgaGFuZGxlS2V5RG93biA9IHVzZUNhbGxiYWNrKGV2ZW50ID0+IHtcclxuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xyXG5cclxuICAgICAgICBjb25zdCB2YWx1ZSA9IE51bWJlcihpbnB1dFJlZi5jdXJyZW50LnZhbHVlKTtcclxuICAgICAgICBjb25zdCBldmVudEtleSA9IGdldEV2ZW50S2V5KGV2ZW50KTtcclxuICAgICAgICBjb25zdCBuZXdWYWx1ZSA9IGdldFZhbHVlRm9yRXZlbnRLZXkoZXZlbnRLZXksIHZhbHVlLCBtaW4sIG1heCwgc3RlcCk7XHJcblxyXG4gICAgICAgIGlmIChpc05hTihuZXdWYWx1ZSkpIHJldHVybjtcclxuXHJcbiAgICAgICAgdXBkYXRlVmFsdWUobmV3VmFsdWUpO1xyXG4gICAgfSwgW21pbiwgbWF4LCBzdGVwLCB1cGRhdGVWYWx1ZV0pO1xyXG5cclxuICAgIGNvbnN0IGhhbmRsZVJvb3RJbnRlcmFjdGlvbiA9IHVzZUNhbGxiYWNrKGV2ZW50ID0+IHtcclxuICAgICAgICBoYW5kbGVNb3ZlKGV2ZW50KTtcclxuICAgIH0sIFtoYW5kbGVNb3ZlXSk7XHJcblxyXG4gICAgY29uc3QgaGFuZGxlVXAgPSB1c2VDYWxsYmFjaygoKSA9PiB7XHJcbiAgICAgICAgc2V0QWN0aXZlKGZhbHNlKTtcclxuICAgIH0sIFtdKTtcclxuXHJcbiAgICBjb25zdCBoYW5kbGVUaHVtYlN0YXJ0SW50ZXJhY3Rpb24gPSB1c2VDYWxsYmFjaygoKSA9PiB7XHJcbiAgICAgICAgc2V0QWN0aXZlKHRydWUpO1xyXG4gICAgfSwgW10pO1xyXG5cclxuICAgIGNvbnN0IGhhbmRsZVRodW1iRW5kSW50ZXJhY3Rpb24gPSB1c2VDYWxsYmFjaygoKSA9PiB7XHJcbiAgICAgICAgc2V0QWN0aXZlKGZhbHNlKTtcclxuICAgIH0sIFtdKTtcclxuXHJcbiAgICBjb25zdCBjbGFzc05hbWVzID0gY2xhc3NuYW1lcyhjc3NDbGFzc2VzLlJPT1QsIHtcclxuICAgICAgICBbY3NzQ2xhc3Nlcy5ESVNDUkVURV06IGRpc2NyZXRlLFxyXG4gICAgICAgIFtjc3NDbGFzc2VzLkRJU0FCTEVEXTogZGlzYWJsZWRcclxuICAgIH0sIGNsYXNzTmFtZSk7XHJcblxyXG4gICAgcmV0dXJuIChcclxuICAgICAgICA8ZGl2XHJcbiAgICAgICAgICAgIHJlZj17cmVmfVxyXG4gICAgICAgICAgICBjbGFzc05hbWU9e2NsYXNzTmFtZXN9XHJcbiAgICAgICAgICAgIG9uTW91c2VEb3duPXtoYW5kbGVSb290SW50ZXJhY3Rpb259XHJcbiAgICAgICAgICAgIG9uVG91Y2hTdGFydD17aGFuZGxlUm9vdEludGVyYWN0aW9ufVxyXG4gICAgICAgICAgICB7Li4ucHJvcHN9XHJcbiAgICAgICAgPlxyXG4gICAgICAgICAgICA8SW5wdXRcclxuICAgICAgICAgICAgICAgIHJlZj17aW5wdXRSZWZ9XHJcbiAgICAgICAgICAgICAgICBuYW1lPXtuYW1lfVxyXG4gICAgICAgICAgICAgICAgdmFsdWU9e3ZhbHVlfVxyXG4gICAgICAgICAgICAgICAgbWluPXttaW59XHJcbiAgICAgICAgICAgICAgICBtYXg9e21heH1cclxuICAgICAgICAgICAgICAgIHN0ZXA9e3N0ZXB9XHJcbiAgICAgICAgICAgICAgICBkaXNhYmxlZD17ZGlzYWJsZWR9XHJcbiAgICAgICAgICAgIC8+XHJcblxyXG4gICAgICAgICAgICA8VHJhY2tcclxuICAgICAgICAgICAgICAgIHJlZj17dHJhY2tSZWZ9XHJcbiAgICAgICAgICAgICAgICB2YWx1ZT17dmFsdWV9XHJcbiAgICAgICAgICAgICAgICBtaW49e21pbn1cclxuICAgICAgICAgICAgICAgIG1heD17bWF4fVxyXG4gICAgICAgICAgICAgICAgc3RlcD17c3RlcH1cclxuICAgICAgICAgICAgICAgIGRpc2NyZXRlPXtkaXNjcmV0ZX1cclxuICAgICAgICAgICAgICAgIHRpY2tNYXJrcz17dGlja01hcmtzfVxyXG4gICAgICAgICAgICAvPlxyXG5cclxuICAgICAgICAgICAgPFRodW1iXHJcbiAgICAgICAgICAgICAgICB2YWx1ZT17dmFsdWV9XHJcbiAgICAgICAgICAgICAgICBtaW49e21pbn1cclxuICAgICAgICAgICAgICAgIG1heD17bWF4fVxyXG4gICAgICAgICAgICAgICAgZGlzY3JldGU9e2Rpc2NyZXRlfVxyXG4gICAgICAgICAgICAgICAgb25TdGFydEludGVyYWN0aW9uPXtoYW5kbGVUaHVtYlN0YXJ0SW50ZXJhY3Rpb259XHJcbiAgICAgICAgICAgICAgICBvbkVuZEludGVyYWN0aW9uPXtoYW5kbGVUaHVtYkVuZEludGVyYWN0aW9ufVxyXG4gICAgICAgICAgICAgICAgb25LZXlEb3duPXtoYW5kbGVLZXlEb3dufVxyXG4gICAgICAgICAgICAvPlxyXG4gICAgICAgIDwvZGl2PlxyXG4gICAgKTtcclxufSk7XHJcblxyXG5TbGlkZXIuZGlzcGxheU5hbWUgPSAnTURDU2xpZGVyJztcclxuXHJcblNsaWRlci5wcm9wVHlwZXMgPSB7XHJcbiAgICB2YWx1ZTogUHJvcFR5cGVzLm9uZU9mVHlwZShbXHJcbiAgICAgICAgUHJvcFR5cGVzLm51bWJlcixcclxuICAgICAgICBQcm9wVHlwZXMuc3RyaW5nXHJcbiAgICBdKSxcclxuICAgIG1pbjogUHJvcFR5cGVzLm9uZU9mVHlwZShbXHJcbiAgICAgICAgUHJvcFR5cGVzLm51bWJlcixcclxuICAgICAgICBQcm9wVHlwZXMuc3RyaW5nXHJcbiAgICBdKSxcclxuICAgIG1heDogUHJvcFR5cGVzLm9uZU9mVHlwZShbXHJcbiAgICAgICAgUHJvcFR5cGVzLm51bWJlcixcclxuICAgICAgICBQcm9wVHlwZXMuc3RyaW5nXHJcbiAgICBdKSxcclxuICAgIHN0ZXA6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1xyXG4gICAgICAgIFByb3BUeXBlcy5udW1iZXIsXHJcbiAgICAgICAgUHJvcFR5cGVzLnN0cmluZ1xyXG4gICAgXSksXHJcbiAgICBkaXNjcmV0ZTogUHJvcFR5cGVzLmJvb2wsXHJcbiAgICBkaXNhYmxlZDogUHJvcFR5cGVzLmJvb2wsXHJcbiAgICB0aWNrTWFya3M6IFByb3BUeXBlcy5ib29sLFxyXG4gICAgb25DaGFuZ2U6IFByb3BUeXBlcy5mdW5jXHJcbn07XHJcblxyXG5leHBvcnQgZGVmYXVsdCBTbGlkZXI7IiwiZXhwb3J0IHsgZGVmYXVsdCB9IGZyb20gJy4vU2xpZGVyJzsiLCJleHBvcnQgY29uc3QgbnVtYmVycyA9IHtcclxuICAgIERFRkFVTFRfQVVUT19ESVNNSVNTX1RJTUVPVVRfTVM6IDUwMDAsXHJcbiAgICBBTklNQVRJT05fT1BFTl9USU1FX01TOiAxNTAsXHJcbiAgICBBTklNQVRJT05fQ0xPU0VfVElNRV9NUzogNzVcclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCBjc3NDbGFzc2VzID0ge1xyXG4gICAgUk9PVDogJ21kYy1zbmFja2JhcicsXHJcbiAgICBMRUFESU5HOiAnbWRjLXNuYWNrYmFyLS1sZWFkaW5nJyxcclxuICAgIFNUQUNLRUQ6ICdtZGMtc25hY2tiYXItLXN0YWNrZWQnLFxyXG4gICAgT1BFTklORzogJ21kYy1zbmFja2Jhci0tb3BlbmluZycsXHJcbiAgICBPUEVOOiAnbWRjLXNuYWNrYmFyLS1vcGVuJyxcclxuICAgIENMT1NJTkc6ICdtZGMtc25hY2tiYXItLWNsb3NpbmcnLFxyXG5cclxuICAgIFNVUkZBQ0U6ICdtZGMtc25hY2tiYXJfX3N1cmZhY2UnLFxyXG4gICAgTEFCRUw6ICdtZGMtc25hY2tiYXJfX2xhYmVsJyxcclxuICAgIEFDVElPTlM6ICdtZGMtc25hY2tiYXJfX2FjdGlvbnMnLFxyXG4gICAgQUNUSU9OOiAnbWRjLXNuYWNrYmFyX19hY3Rpb24nLFxyXG4gICAgRElTTUlTUzogJ21kYy1zbmFja2Jhcl9fZGlzbWlzcydcclxufTsiLCJpbXBvcnQgeyBmb3J3YXJkUmVmLCB1c2VSZWYsIHVzZUNhbGxiYWNrIH0gZnJvbSAncmVhY3QnO1xyXG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xyXG5pbXBvcnQgY2xhc3NuYW1lcyBmcm9tICdjbGFzc25hbWVzJztcclxuXHJcbmltcG9ydCB7IHVzZVVwZGF0ZWQgfSBmcm9tICcuLi9ob29rcyc7XHJcbmltcG9ydCB7IENsb25lIH0gZnJvbSAnLi4vY29tcG9uZW50JztcclxuaW1wb3J0IExheWVyIGZyb20gJy4uL2xheWVyJztcclxuaW1wb3J0IEljb25CdXR0b24gZnJvbSAnLi4vaWNvbi1idXR0b24nO1xyXG5cclxuaW1wb3J0IHsgbnVtYmVycywgY3NzQ2xhc3NlcyB9IGZyb20gJy4vY29uc3RhbnRzJztcclxuXHJcbmNvbnN0IFNuYWNrYmFyID0gZm9yd2FyZFJlZigoe1xyXG4gICAgbGFiZWwsXHJcbiAgICBhY3Rpb24sXHJcbiAgICBkaXNtaXNzSWNvbiA9ICdjbG9zZScsXHJcbiAgICBvcGVuID0gZmFsc2UsXHJcbiAgICBhcHBlYXIgPSBmYWxzZSxcclxuICAgIGxlYWRpbmcgPSBmYWxzZSxcclxuICAgIHN0YWNrZWQgPSBmYWxzZSxcclxuICAgIGRpc21pc3NpYmxlID0gdHJ1ZSxcclxuICAgIHRpbWVvdXQgPSBudW1iZXJzLkRFRkFVTFRfQVVUT19ESVNNSVNTX1RJTUVPVVRfTVMsXHJcbiAgICBjbG9zZU9uRXNjYXBlID0gdHJ1ZSxcclxuICAgIG9uQ2xvc2UgPSBGdW5jdGlvbi5wcm90b3R5cGUsXHJcblxyXG4gICAgZWxlbWVudDogRWxlbWVudCA9ICdkaXYnLFxyXG4gICAgY2xhc3NOYW1lLFxyXG4gICAgY2hpbGRyZW4gPSBsYWJlbCxcclxuICAgIC4uLnByb3BzXHJcbn0sIHJlZikgPT4ge1xyXG4gICAgY29uc3QgdGltZW91dFJlZiA9IHVzZVJlZigpO1xyXG5cclxuICAgIHVzZVVwZGF0ZWQoKCkgPT4ge1xyXG4gICAgICAgIGlmIChvcGVuKSB7XHJcbiAgICAgICAgICAgIHRpbWVvdXRSZWYuY3VycmVudCA9IHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgdGltZW91dFJlZi5jdXJyZW50ID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIG9uQ2xvc2UoKTtcclxuICAgICAgICAgICAgfSwgdGltZW91dCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgaWYgKHRpbWVvdXRSZWYuY3VycmVudCkge1xyXG4gICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRSZWYuY3VycmVudCk7XHJcbiAgICAgICAgICAgICAgICB0aW1lb3V0UmVmLmN1cnJlbnQgPSBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gKCkgPT4gY2xlYXJUaW1lb3V0KHRpbWVvdXRSZWYuY3VycmVudCk7XHJcbiAgICB9LCBbb3Blbl0pO1xyXG5cclxuICAgIGNvbnN0IGhhbmRsZUtleURvd24gPSB1c2VDYWxsYmFjayhldmVudCA9PiB7XHJcbiAgICAgICAgaWYgKGNsb3NlT25Fc2NhcGUgJiYgZXZlbnQua2V5ID09PSAnRXNjYXBlJyB8fCBldmVudC5rZXlDb2RlID09PSAyNykge1xyXG4gICAgICAgICAgICBvbkNsb3NlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfSwgW2Nsb3NlT25Fc2NhcGUsIG9uQ2xvc2VdKTtcclxuXHJcbiAgICBjb25zdCBjbGFzc05hbWVzID0gY2xhc3NuYW1lcyhjc3NDbGFzc2VzLlJPT1QsIHtcclxuICAgICAgICBbY3NzQ2xhc3Nlcy5MRUFESU5HXTogbGVhZGluZyxcclxuICAgICAgICBbY3NzQ2xhc3Nlcy5TVEFDS0VEXTogc3RhY2tlZFxyXG4gICAgfSwgY2xhc3NOYW1lKTtcclxuXHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAgIDxMYXllclxyXG4gICAgICAgICAgICBtb2RhbFxyXG4gICAgICAgICAgICBpbj17b3Blbn1cclxuICAgICAgICAgICAgYXBwZWFyPXthcHBlYXJ9XHJcbiAgICAgICAgICAgIHRpbWVvdXQ9e3tcclxuICAgICAgICAgICAgICAgIGVudGVyOiBudW1iZXJzLkFOSU1BVElPTl9PUEVOX1RJTUVfTVMsXHJcbiAgICAgICAgICAgICAgICBleGl0OiBudW1iZXJzLkFOSU1BVElPTl9DTE9TRV9USU1FX01TXHJcbiAgICAgICAgICAgIH19XHJcbiAgICAgICAgICAgIGNsYXNzTmFtZXM9e3tcclxuICAgICAgICAgICAgICAgIGFwcGVhcjogY3NzQ2xhc3Nlcy5PUEVOSU5HLFxyXG4gICAgICAgICAgICAgICAgYXBwZWFyQWN0aXZlOiBjc3NDbGFzc2VzLk9QRU4sXHJcbiAgICAgICAgICAgICAgICBlbnRlcjogY3NzQ2xhc3Nlcy5PUEVOSU5HLFxyXG4gICAgICAgICAgICAgICAgZW50ZXJBY3RpdmU6IGNzc0NsYXNzZXMuT1BFTixcclxuICAgICAgICAgICAgICAgIGVudGVyRG9uZTogY3NzQ2xhc3Nlcy5PUEVOLFxyXG4gICAgICAgICAgICAgICAgZXhpdDogY3NzQ2xhc3Nlcy5DTE9TSU5HXHJcbiAgICAgICAgICAgIH19XHJcbiAgICAgICAgICAgIG1vdW50T25FbnRlclxyXG4gICAgICAgICAgICB1bm1vdW50T25FeGl0XHJcbiAgICAgICAgPlxyXG4gICAgICAgICAgICA8RWxlbWVudFxyXG4gICAgICAgICAgICAgICAgcmVmPXtyZWZ9XHJcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU9e2NsYXNzTmFtZXN9XHJcbiAgICAgICAgICAgICAgICBvbktleURvd249e2hhbmRsZUtleURvd259XHJcbiAgICAgICAgICAgICAgICB7Li4ucHJvcHN9XHJcbiAgICAgICAgICAgID5cclxuICAgICAgICAgICAgICAgIDxkaXZcclxuICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU9e2Nzc0NsYXNzZXMuU1VSRkFDRX1cclxuICAgICAgICAgICAgICAgICAgICByb2xlPVwic3RhdHVzXCJcclxuICAgICAgICAgICAgICAgICAgICBhcmlhLXJlbGV2YW50PVwiYWRkaXRpb25zXCJcclxuICAgICAgICAgICAgICAgID5cclxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17Y3NzQ2xhc3Nlcy5MQUJFTH0gYXJpYS1hdG9taWM9XCJmYWxzZVwiPntjaGlsZHJlbn08L2Rpdj5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9e2Nzc0NsYXNzZXMuQUNUSU9OU30gYXJpYS1hdG9taWM9XCJ0cnVlXCI+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHthY3Rpb24gJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxDbG9uZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudD17YWN0aW9ufVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT17Y3NzQ2xhc3Nlcy5BQ1RJT059XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICB7ZGlzbWlzc2libGUgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxDbG9uZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudD17ZGlzbWlzc0ljb259XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmFsbGJhY2s9e0ljb25CdXR0b259XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPXtjc3NDbGFzc2VzLkRJU01JU1N9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb25DbGljaz17b25DbG9zZX1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICA8L0VsZW1lbnQ+XHJcbiAgICAgICAgPC9MYXllcj5cclxuICAgICk7XHJcbn0pO1xyXG5cclxuU25hY2tiYXIuZGlzcGxheU5hbWUgPSAnTURDU25hY2tiYXInO1xyXG5cclxuU25hY2tiYXIucHJvcFR5cGVzID0ge1xyXG4gICAgbGFiZWw6IFByb3BUeXBlcy5zdHJpbmcsXHJcbiAgICBhY3Rpb246IFByb3BUeXBlcy5lbGVtZW50LFxyXG4gICAgZGlzbWlzc0ljb246IFByb3BUeXBlcy5ub2RlLFxyXG4gICAgb3BlbjogUHJvcFR5cGVzLmJvb2wsXHJcbiAgICBhcHBlYXI6IFByb3BUeXBlcy5ib29sLFxyXG4gICAgbGVhZGluZzogUHJvcFR5cGVzLmJvb2wsXHJcbiAgICBzdGFja2VkOiBQcm9wVHlwZXMuYm9vbCxcclxuICAgIGRpc21pc3NpYmxlOiBQcm9wVHlwZXMuYm9vbCxcclxuICAgIHRpbWVvdXQ6IFByb3BUeXBlcy5udW1iZXIsXHJcbiAgICBjbG9zZU9uRXNjYXBlOiBQcm9wVHlwZXMuYm9vbCxcclxuICAgIG9uQ2xvc2U6IFByb3BUeXBlcy5mdW5jXHJcbn07XHJcblxyXG5leHBvcnQgZGVmYXVsdCBTbmFja2JhcjsiLCJleHBvcnQgeyBkZWZhdWx0IH0gZnJvbSAnLi9TbmFja2Jhcic7IiwiZXhwb3J0IGNvbnN0IGNzc0NsYXNzZXMgPSB7XHJcbiAgICBST09UOiAnbWRjLXN3aXRjaCcsXHJcbiAgICBTRUxFQ1RFRDogJ21kYy1zd2l0Y2gtLXNlbGVjdGVkJyxcclxuICAgIFVOU0VMRUNURUQ6ICdtZGMtc3dpdGNoLS11bnNlbGVjdGVkJyxcclxuXHJcbiAgICBUUkFDSzogJ21kYy1zd2l0Y2hfX3RyYWNrJyxcclxuICAgIEhBTkRMRV9UUkFDSzogJ21kYy1zd2l0Y2hfX2hhbmRsZS10cmFjaycsXHJcbiAgICBIQU5ETEU6ICdtZGMtc3dpdGNoX19oYW5kbGUnLFxyXG4gICAgU0hBRE9XOiAnbWRjLXN3aXRjaF9fc2hhZG93JyxcclxuICAgIEVMRVZBVElPTl9PVkVSTEFZOiAnbWRjLWVsZXZhdGlvbi1vdmVybGF5JyxcclxuICAgIFJJUFBMRTogJ21kYy1zd2l0Y2hfX3JpcHBsZScsXHJcbiAgICBJQ09OUzogJ21kYy1zd2l0Y2hfX2ljb25zJyxcclxuXHJcbiAgICBJQ09OOiAnbWRjLXN3aXRjaF9faWNvbicsXHJcbiAgICBJQ09OX09OOiAnbWRjLXN3aXRjaF9faWNvbi0tb24nLFxyXG4gICAgSUNPTl9PRkY6ICdtZGMtc3dpdGNoX19pY29uLS1vZmYnXHJcbn07IiwiaW1wb3J0IHsgZm9yd2FyZFJlZiwgdXNlQ2FsbGJhY2sgfSBmcm9tICdyZWFjdCc7XHJcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XHJcbmltcG9ydCBjbGFzc25hbWVzIGZyb20gJ2NsYXNzbmFtZXMnO1xyXG5cclxuaW1wb3J0IHsgY3NzQ2xhc3NlcyB9IGZyb20gJy4vY29uc3RhbnRzJztcclxuXHJcbmNvbnN0IFN3aXRjaCA9IGZvcndhcmRSZWYoKHtcclxuICAgIHNlbGVjdGVkID0gZmFsc2UsXHJcbiAgICBvbkNoYW5nZSA9IEZ1bmN0aW9uLnByb3RvdHlwZSxcclxuXHJcbiAgICBjbGFzc05hbWUsXHJcbiAgICAuLi5wcm9wc1xyXG59LCByZWYpID0+IHtcclxuICAgIGNvbnN0IGhhbmRsZUNsaWNrID0gdXNlQ2FsbGJhY2soZXZlbnQgPT4ge1xyXG4gICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xyXG4gICAgICAgIGV2ZW50LnRhcmdldCA9IGV2ZW50LmN1cnJlbnRUYXJnZXQ7XHJcblxyXG4gICAgICAgIG9uQ2hhbmdlKGV2ZW50LCAhc2VsZWN0ZWQsIGV2ZW50LmN1cnJlbnRUYXJnZXQpO1xyXG4gICAgfSwgW3NlbGVjdGVkLCBvbkNoYW5nZV0pO1xyXG5cclxuICAgIGNvbnN0IGNsYXNzTmFtZXMgPSBjbGFzc25hbWVzKGNzc0NsYXNzZXMuUk9PVCwge1xyXG4gICAgICAgIFtjc3NDbGFzc2VzLlNFTEVDVEVEXTogc2VsZWN0ZWQsXHJcbiAgICAgICAgW2Nzc0NsYXNzZXMuVU5TRUxFQ1RFRF06ICFzZWxlY3RlZFxyXG4gICAgfSwgY2xhc3NOYW1lKTtcclxuXHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAgIDxidXR0b25cclxuICAgICAgICAgICAgcmVmPXtyZWZ9XHJcbiAgICAgICAgICAgIHR5cGU9XCJidXR0b25cIlxyXG4gICAgICAgICAgICBjbGFzc05hbWU9e2NsYXNzTmFtZXN9XHJcbiAgICAgICAgICAgIHJvbGU9XCJzd2l0Y2hcIlxyXG4gICAgICAgICAgICBhcmlhLWNoZWNrZWQ9e3NlbGVjdGVkfVxyXG4gICAgICAgICAgICBvbkNsaWNrPXtoYW5kbGVDbGlja31cclxuICAgICAgICAgICAgey4uLnByb3BzfVxyXG4gICAgICAgID5cclxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9e2Nzc0NsYXNzZXMuVFJBQ0t9IC8+XHJcblxyXG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17Y3NzQ2xhc3Nlcy5IQU5ETEVfVFJBQ0t9PlxyXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9e2Nzc0NsYXNzZXMuSEFORExFfT5cclxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17Y3NzQ2xhc3Nlcy5TSEFET1d9PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17Y3NzQ2xhc3Nlcy5FTEVWQVRJT05fT1ZFUkxBWX0gLz5cclxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9e2Nzc0NsYXNzZXMuUklQUExFfSAvPlxyXG5cclxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17Y3NzQ2xhc3Nlcy5JQ09OU30+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxzdmcgY2xhc3NOYW1lPXtgJHtjc3NDbGFzc2VzLklDT059ICR7Y3NzQ2xhc3Nlcy5JQ09OX09OfWB9IHZpZXdCb3g9XCIwIDAgMjQgMjRcIj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxwYXRoIGQ9XCJNMTkuNjksNS4yM0w4Ljk2LDE1Ljk2bC00LjIzLTQuMjNMMi45NiwxMy41bDYsNkwyMS40Niw3TDE5LjY5LDUuMjN6XCIgLz5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPC9zdmc+XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8c3ZnIGNsYXNzTmFtZT17YCR7Y3NzQ2xhc3Nlcy5JQ09OfSAke2Nzc0NsYXNzZXMuSUNPTl9PRkZ9YH0gdmlld0JveD1cIjAgMCAyNCAyNFwiPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPHBhdGggZD1cIk0yMCAxM0g0di0yaDE2djJ6XCIgLz5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPC9zdmc+XHJcbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgPC9idXR0b24+XHJcbiAgICApO1xyXG59KTtcclxuXHJcblN3aXRjaC5kaXNwbGF5TmFtZSA9ICdNRENTd2l0Y2gnO1xyXG5cclxuU3dpdGNoLnByb3BUeXBlcyA9IHtcclxuICAgIHNlbGVjdGVkOiBQcm9wVHlwZXMuYm9vbCxcclxuICAgIGRpc2FibGVkOiBQcm9wVHlwZXMuYm9vbCxcclxuICAgIG9uQ2hhbmdlOiBQcm9wVHlwZXMuZnVuY1xyXG59O1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgU3dpdGNoOyIsImV4cG9ydCB7IGRlZmF1bHQgfSBmcm9tICcuL1N3aXRjaCc7IiwiZXhwb3J0IGNvbnN0IGNzc0NsYXNzZXMgPSB7XHJcbiAgICBST09UOiAnbWRjLXN5bWJvbCcsXHJcbiAgICBMSUdIVDogJ21kYy1zeW1ib2wtLWxpZ2h0JyxcclxuICAgIERBUks6ICdtZGMtc3ltYm9sLS1kYXJrJyxcclxuICAgIElOQUNUSVZFOiAnbWRjLXN5bWJvbC0taW5hY3RpdmUnXHJcbn07XHJcblxyXG5leHBvcnQgY29uc3Qgc2l6ZSA9IHtcclxuICAgIFNNQUxMRVI6IDE2LFxyXG4gICAgU01BTEw6IDE4LFxyXG4gICAgTUVESVVNOiAyNCxcclxuICAgIExBUkdFOiAzNixcclxuICAgIExBUkdFUjogNDhcclxufTsiLCJpbXBvcnQgeyBzaXplIH0gZnJvbSAnLi9jb25zdGFudHMnO1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGdldFNpemVWYWx1ZShhcmcpIHtcclxuICAgIGlmIChhcmcgPT09IHVuZGVmaW5lZCkgcmV0dXJuO1xyXG5cclxuICAgIGlmIChpc05hTihhcmcpKSB7XHJcbiAgICAgICAgcmV0dXJuIHNpemVbYXJnLnRvVXBwZXJDYXNlKCldO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBOdW1iZXIoYXJnKTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGdldEZvbnRWYXJpYXRpb25TZXR0aW5ncyhmaWxsLCB3Z2h0LCBncmFkLCBvcHN6KSB7XHJcbiAgICBsZXQgcGFydHMgPSBbXTtcclxuXHJcbiAgICBpZiAoZmlsbCkge1xyXG4gICAgICAgIHBhcnRzLnB1c2goJ1wiRklMTFwiIDEnKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoIWlzTmFOKHdnaHQpKSB7XHJcbiAgICAgICAgcGFydHMucHVzaCgnXCJ3Z2h0XCIgJyArIHdnaHQpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICghaXNOYU4oZ3JhZCkpIHtcclxuICAgICAgICBwYXJ0cy5wdXNoKCdcIkdSQURcIiAnICsgTnVtYmVyKGdyYWQpKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoIWlzTmFOKG9wc3opKSB7XHJcbiAgICAgICAgcGFydHMucHVzaCgnXCJvcHN6XCIgJyArIG9wc3opO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFwiRklMTFwiIDAsIFwid2dodFwiIDEwMCwgXCJHUkFEXCIgMCwgXCJvcHN6XCIgNDhcclxuICAgIHJldHVybiBwYXJ0cy5sZW5ndGggPiAwID8gcGFydHMuam9pbignLCAnKSA6IHVuZGVmaW5lZDtcclxufSIsImltcG9ydCB7IGZvcndhcmRSZWYgfSBmcm9tICdyZWFjdCc7XHJcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XHJcbmltcG9ydCBjbGFzc25hbWVzIGZyb20gJ2NsYXNzbmFtZXMnO1xyXG5cclxuaW1wb3J0IHsgY3NzQ2xhc3NlcyB9IGZyb20gJy4vY29uc3RhbnRzJztcclxuaW1wb3J0IHsgZ2V0U2l6ZVZhbHVlLCBnZXRGb250VmFyaWF0aW9uU2V0dGluZ3MgfSBmcm9tICcuL3V0aWxzJztcclxuXHJcbmNvbnN0IFN5bWJvbCA9IGZvcndhcmRSZWYoKHtcclxuICAgIG5hbWUsXHJcbiAgICB0eXBlID0gJ291dGxpbmVkJyxcclxuICAgIHNpemUsXHJcbiAgICB3ZWlnaHQsXHJcbiAgICBncmFkZSxcclxuICAgIGZpbGxlZCA9IGZhbHNlLFxyXG4gICAgbGlnaHQgPSBmYWxzZSxcclxuICAgIGRhcmsgPSBmYWxzZSxcclxuICAgIGluYWN0aXZlID0gZmFsc2UsXHJcblxyXG4gICAgZWxlbWVudCA9ICdpJyxcclxuICAgIGNvbXBvbmVudDogRWxlbWVudCA9IGVsZW1lbnQsXHJcbiAgICBjaGlsZHJlbiA9IG5hbWUsXHJcbiAgICBjbGFzc05hbWUsXHJcbiAgICAuLi5wcm9wc1xyXG59LCByZWYpID0+IHtcclxuICAgIGNvbnN0IGNsYXNzTmFtZXMgPSBjbGFzc25hbWVzKGNzc0NsYXNzZXMuUk9PVCwge1xyXG4gICAgICAgIFtgJHtjc3NDbGFzc2VzLlJPT1R9LS0ke3R5cGV9YF06IHR5cGUsXHJcbiAgICAgICAgW2Ake2Nzc0NsYXNzZXMuUk9PVH0tLSR7c2l6ZX1gXTogc2l6ZSxcclxuICAgICAgICBbY3NzQ2xhc3Nlcy5MSUdIVF06IGxpZ2h0LFxyXG4gICAgICAgIFtjc3NDbGFzc2VzLkRBUktdOiBkYXJrLFxyXG4gICAgICAgIFtjc3NDbGFzc2VzLklOQUNUSVZFXTogaW5hY3RpdmVcclxuICAgIH0sIGNsYXNzTmFtZSk7XHJcblxyXG4gICAgY29uc3QgZm9udFZhcmlhdGlvblNldHRpbmdzID0gZ2V0Rm9udFZhcmlhdGlvblNldHRpbmdzKGZpbGxlZCwgd2VpZ2h0LCBncmFkZSwgZ2V0U2l6ZVZhbHVlKHNpemUpKTtcclxuICAgIGNvbnN0IHN0eWxlID0gZm9udFZhcmlhdGlvblNldHRpbmdzID8ge1xyXG4gICAgICAgIGZvbnRWYXJpYXRpb25TZXR0aW5nc1xyXG4gICAgfSA6IHVuZGVmaW5lZDtcclxuXHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAgIDxFbGVtZW50XHJcbiAgICAgICAgICAgIHJlZj17cmVmfVxyXG4gICAgICAgICAgICBzdHlsZT17c3R5bGV9XHJcbiAgICAgICAgICAgIGNsYXNzTmFtZT17Y2xhc3NOYW1lc31cclxuICAgICAgICAgICAgey4uLnByb3BzfVxyXG4gICAgICAgID5cclxuICAgICAgICAgICAge2NoaWxkcmVufVxyXG4gICAgICAgIDwvRWxlbWVudD5cclxuICAgICk7XHJcbn0pO1xyXG5cclxuU3ltYm9sLmRpc3BsYXlOYW1lID0gJ01EQ1N5bWJvbCc7XHJcblxyXG5TeW1ib2wucHJvcFR5cGVzID0ge1xyXG4gICAgbmFtZTogUHJvcFR5cGVzLnN0cmluZyxcclxuICAgIHR5cGU6IFByb3BUeXBlcy5vbmVPZihbJ291dGxpbmVkJywgJ3JvdW5kZWQnLCAnc2hhcnAnXSksXHJcbiAgICBzaXplOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMubnVtYmVyLCBQcm9wVHlwZXMuc3RyaW5nXSksXHJcbiAgICB3ZWlnaHQ6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5udW1iZXIsIFByb3BUeXBlcy5zdHJpbmddKSxcclxuICAgIGdyYWRlOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMubnVtYmVyLCBQcm9wVHlwZXMuc3RyaW5nXSksXHJcbiAgICBmaWxsZWQ6IFByb3BUeXBlcy5ib29sLFxyXG4gICAgZGFyazogUHJvcFR5cGVzLmJvb2wsXHJcbiAgICBsaWdodDogUHJvcFR5cGVzLmJvb2wsXHJcbiAgICBpbmFjdGl2ZTogUHJvcFR5cGVzLmJvb2xcclxufTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IFN5bWJvbDsiLCJleHBvcnQgeyBkZWZhdWx0IH0gZnJvbSAnLi9TeW1ib2wnOyIsImV4cG9ydCBjb25zdCB0YWJDbGFzc05hbWVzID0ge1xyXG4gICAgUk9PVDogJ21kYy10YWInLFxyXG4gICAgQUNUSVZFOiAnbWRjLXRhYi0tYWN0aXZlJyxcclxuICAgIFNUQUNLRUQ6ICdtZGMtdGFiLS1zdGFja2VkJyxcclxuICAgIE1JTl9XSURUSDogJ21kYy10YWItLW1pbi13aWR0aCcsXHJcblxyXG4gICAgQ09OVEVOVDogJ21kYy10YWJfX2NvbnRlbnQnLFxyXG4gICAgSUNPTjogJ21kYy10YWJfX2ljb24nLFxyXG4gICAgTEFCRUw6ICdtZGMtdGFiX190ZXh0LWxhYmVsJyxcclxuICAgIFJJUFBMRTogJ21kYy10YWJfX3JpcHBsZSdcclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCBiYXJDc3NDbGFzc2VzID0ge1xyXG4gICAgUk9PVDogJ21kYy10YWItYmFyJ1xyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IHNjcm9sbGVyQ3NzQ2xhc3NlcyA9IHtcclxuICAgIFJPT1Q6ICdtZGMtdGFiLXNjcm9sbGVyJyxcclxuICAgIEFMSUdOOiAnbWRjLXRhYi1zY3JvbGxlci0tYWxpZ24nLFxyXG4gICAgQU5JTUFUSU5HOiAnbWRjLXRhYi1zY3JvbGxlci0tYW5pbWF0aW5nJyxcclxuXHJcbiAgICBTQ1JPTExfQVJFQTogJ21kYy10YWItc2Nyb2xsZXJfX3Njcm9sbC1hcmVhJyxcclxuICAgIFNDUk9MTF9BUkVBX1NDUk9MTDogJ21kYy10YWItc2Nyb2xsZXJfX3Njcm9sbC1hcmVhLS1zY3JvbGwnLFxyXG4gICAgU0NST0xMX0NPTlRFTlQ6ICdtZGMtdGFiLXNjcm9sbGVyX19zY3JvbGwtY29udGVudCdcclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCBpbmRpY2F0b3JDc3NDbGFzc2VzID0ge1xyXG4gICAgUk9PVDogJ21kYy10YWItaW5kaWNhdG9yJyxcclxuICAgIEFDVElWRTogJ21kYy10YWItaW5kaWNhdG9yLS1hY3RpdmUnLFxyXG4gICAgRkFERTogJ21kYy10YWItaW5kaWNhdG9yLS1mYWRlJyxcclxuICAgIE5PX1RSQU5TSVRJT046ICdtZGMtdGFiLWluZGljYXRvci0tbm8tdHJhbnNpdGlvbicsXHJcblxyXG4gICAgQ09OVEVOVDogJ21kYy10YWItaW5kaWNhdG9yX19jb250ZW50JyxcclxuICAgIENPTlRFTlRfSUNPTjogJ21kYy10YWItaW5kaWNhdG9yX19jb250ZW50LS1pY29uIG1hdGVyaWFsLWljb25zJyxcclxuICAgIENPTlRFTlRfVU5ERVJMSU5FOiAnbWRjLXRhYi1pbmRpY2F0b3JfX2NvbnRlbnQtLXVuZGVybGluZSdcclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCBBbGlnbiA9IHtcclxuICAgIFNUQVJUOiAnc3RhcnQnLFxyXG4gICAgQ0VOVEVSOiAnY2VudGVyJyxcclxuICAgIEVORDogJ2VuZCdcclxufTsiLCJpbXBvcnQgeyBjcmVhdGVDb250ZXh0IH0gZnJvbSAncmVhY3QnO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY3JlYXRlQ29udGV4dCh7fSk7IiwiaW1wb3J0IHsgZm9yd2FyZFJlZiwgdXNlQ29udGV4dCwgdXNlSW1wZXJhdGl2ZUhhbmRsZSwgdXNlUmVmIH0gZnJvbSAncmVhY3QnO1xyXG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xyXG5pbXBvcnQgY2xhc3NuYW1lcyBmcm9tICdjbGFzc25hbWVzJztcclxuXHJcbmltcG9ydCB7IHVzZVVwZGF0ZWRTeW5jIH0gZnJvbSAnLi4vaG9va3MnO1xyXG5cclxuaW1wb3J0IHsgaW5kaWNhdG9yQ3NzQ2xhc3NlcyBhcyBjc3NDbGFzc2VzIH0gZnJvbSAnLi9jb25zdGFudHMnO1xyXG5pbXBvcnQgVGFiQ29udGV4dCBmcm9tICcuL2NvbnRleHQnO1xyXG5cclxuY29uc3QgVGFiSW5kaWNhdG9yID0gZm9yd2FyZFJlZigoe1xyXG4gICAgaWNvbixcclxuICAgIGFjdGl2ZSA9IGZhbHNlLFxyXG4gICAgZmFkZSA9IGZhbHNlLFxyXG4gICAgdW5kZXJsaW5lID0gIWljb24sXHJcblxyXG4gICAgLi4ucHJvcHNcclxufSwgcmVmKSA9PiB7XHJcbiAgICBjb25zdCB7IHByZXZpb3VzVGFiIH0gPSB1c2VDb250ZXh0KFRhYkNvbnRleHQpO1xyXG5cclxuICAgIGNvbnN0IHJvb3RSZWYgPSB1c2VSZWYoKTtcclxuICAgIGNvbnN0IGNvbnRlbnRSZWYgPSB1c2VSZWYoKTtcclxuXHJcbiAgICB1c2VJbXBlcmF0aXZlSGFuZGxlKHJlZiwgKCkgPT4gcm9vdFJlZi5jdXJyZW50KTtcclxuXHJcbiAgICB1c2VVcGRhdGVkU3luYygoKSA9PiB7XHJcbiAgICAgICAgaWYgKGZhZGUgfHwgIWFjdGl2ZSB8fCAhcHJldmlvdXNUYWIpIHJldHVybjtcclxuXHJcbiAgICAgICAgY29uc3QgYWN0aXZlSW5kaWNhdG9yID0gcm9vdFJlZi5jdXJyZW50O1xyXG4gICAgICAgIGNvbnN0IHByZXZpb3VzSW5kaWNhdG9yID0gcHJldmlvdXNUYWIucXVlcnlTZWxlY3RvcignLm1kYy10YWItaW5kaWNhdG9yJyk7XHJcbiAgICAgICAgY29uc3QgcHJldmlvdXNJbmRpY2F0b3JDbGllbnRSZWN0ID0gcHJldmlvdXNJbmRpY2F0b3IuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XHJcbiAgICAgICAgY29uc3QgYWN0aXZlSW5kaWNhdG9yQ2xpZW50UmVjdCA9IGFjdGl2ZUluZGljYXRvci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcclxuXHJcbiAgICAgICAgY29uc3QgeFBvc2l0aW9uID0gcHJldmlvdXNJbmRpY2F0b3JDbGllbnRSZWN0LmxlZnQgLSBhY3RpdmVJbmRpY2F0b3JDbGllbnRSZWN0LmxlZnQ7XHJcbiAgICAgICAgY29uc3Qgd2lkdGhEZWx0YSA9IHByZXZpb3VzSW5kaWNhdG9yQ2xpZW50UmVjdC53aWR0aCAvIGFjdGl2ZUluZGljYXRvckNsaWVudFJlY3Qud2lkdGg7XHJcblxyXG4gICAgICAgIHJvb3RSZWYuY3VycmVudC5jbGFzc0xpc3QuYWRkKGNzc0NsYXNzZXMuTk9fVFJBTlNJVElPTik7XHJcbiAgICAgICAgY29udGVudFJlZi5jdXJyZW50LnN0eWxlLnRyYW5zZm9ybSA9IGB0cmFuc2xhdGVYKCR7eFBvc2l0aW9ufXB4KSBzY2FsZVgoJHt3aWR0aERlbHRhfSlgO1xyXG4gICAgICAgIC8vIEZvcmNlIHJlcGFpbnQgYmVmb3JlIHVwZGF0aW5nIGNsYXNzZXMgYW5kIHRyYW5zZm9ybSB0byBlbnN1cmUgdGhlIHRyYW5zZm9ybSBwcm9wZXJseSB0YWtlcyBlZmZlY3RcclxuICAgICAgICBjb250ZW50UmVmLmN1cnJlbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XHJcbiAgICAgICAgcm9vdFJlZi5jdXJyZW50LmNsYXNzTGlzdC5yZW1vdmUoY3NzQ2xhc3Nlcy5OT19UUkFOU0lUSU9OKTtcclxuICAgICAgICBjb250ZW50UmVmLmN1cnJlbnQuc3R5bGUudHJhbnNmb3JtID0gJyc7XHJcbiAgICB9LCBbZmFkZSwgYWN0aXZlXSk7XHJcblxyXG4gICAgY29uc3Qgcm9vdENsYXNzTmFtZXMgPSBjbGFzc25hbWVzKGNzc0NsYXNzZXMuUk9PVCwge1xyXG4gICAgICAgIFtjc3NDbGFzc2VzLkFDVElWRV06IGFjdGl2ZSxcclxuICAgICAgICBbY3NzQ2xhc3Nlcy5GQURFXTogZmFkZVxyXG4gICAgfSk7XHJcblxyXG4gICAgY29uc3QgY29udGVudENsYXNzTmFtZXMgPSBjbGFzc25hbWVzKGNzc0NsYXNzZXMuQ09OVEVOVCwge1xyXG4gICAgICAgIFtjc3NDbGFzc2VzLkNPTlRFTlRfSUNPTl06IGljb24sXHJcbiAgICAgICAgW2Nzc0NsYXNzZXMuQ09OVEVOVF9VTkRFUkxJTkVdOiB1bmRlcmxpbmVcclxuICAgIH0pO1xyXG5cclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgPHNwYW4gcmVmPXtyb290UmVmfSBjbGFzc05hbWU9e3Jvb3RDbGFzc05hbWVzfSB7Li4ucHJvcHN9PlxyXG4gICAgICAgICAgICA8c3BhblxyXG4gICAgICAgICAgICAgICAgcmVmPXtjb250ZW50UmVmfVxyXG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lPXtjb250ZW50Q2xhc3NOYW1lc31cclxuICAgICAgICAgICAgPlxyXG4gICAgICAgICAgICAgICAge2ljb259XHJcbiAgICAgICAgICAgIDwvc3Bhbj5cclxuICAgICAgICA8L3NwYW4+XHJcbiAgICApO1xyXG59KTtcclxuXHJcblRhYkluZGljYXRvci5kaXNwbGF5TmFtZSA9ICdNRENUYWJJbmRpY2F0b3InO1xyXG5cclxuVGFiSW5kaWNhdG9yLnByb3BUeXBlcyA9IHtcclxuICAgIGljb246IFByb3BUeXBlcy5ub2RlLFxyXG4gICAgYWN0aXZlOiBQcm9wVHlwZXMuYm9vbCxcclxuICAgIGZhZGU6IFByb3BUeXBlcy5ib29sLFxyXG4gICAgdW5kZXJsaW5lOiBQcm9wVHlwZXMuYm9vbFxyXG59O1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgVGFiSW5kaWNhdG9yOyIsImltcG9ydCB7IGZvcndhcmRSZWYsIHVzZVJlZiwgdXNlQ2FsbGJhY2ssIHVzZUltcGVyYXRpdmVIYW5kbGUgfSBmcm9tICdyZWFjdCc7XHJcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XHJcbmltcG9ydCBjbGFzc25hbWVzIGZyb20gJ2NsYXNzbmFtZXMnO1xyXG5cclxuaW1wb3J0IHsgQ2xvbmUgfSBmcm9tICcuLi9jb21wb25lbnQnO1xyXG5pbXBvcnQgSWNvbiBmcm9tICcuLi9pY29uJztcclxuXHJcbmltcG9ydCB7IHRhYkNsYXNzTmFtZXMgYXMgY3NzQ2xhc3NlcyB9IGZyb20gJy4vY29uc3RhbnRzJztcclxuaW1wb3J0IFRhYkluZGljYXRvciBmcm9tICcuL1RhYkluZGljYXRvcic7XHJcblxyXG5jb25zdCBUYWIgPSBmb3J3YXJkUmVmKCh7XHJcbiAgICB2YWx1ZSxcclxuICAgIGljb24sXHJcbiAgICBsYWJlbCxcclxuICAgIGluZGljYXRvckljb24sXHJcbiAgICBhY3RpdmUgPSBmYWxzZSxcclxuICAgIHN0YWNrZWQgPSBmYWxzZSxcclxuICAgIG1pbldpZHRoID0gZmFsc2UsXHJcbiAgICBtaW5XaWR0aEluZGljYXRvciA9IGZhbHNlLFxyXG4gICAgZmFkZSA9IGZhbHNlLFxyXG4gICAgdW5kZXJsaW5lID0gIWluZGljYXRvckljb24sXHJcbiAgICBvbkNsaWNrID0gRnVuY3Rpb24ucHJvdG90eXBlLFxyXG5cclxuICAgIGVsZW1lbnQgPSAnYnV0dG9uJyxcclxuICAgIGNvbXBvbmVudDogRWxlbWVudCA9IGVsZW1lbnQsXHJcbiAgICBjbGFzc05hbWUsXHJcbiAgICBjaGlsZHJlbiA9IGxhYmVsLFxyXG4gICAgLi4ucHJvcHNcclxufSwgcmVmKSA9PiB7XHJcbiAgICBjb25zdCByb290UmVmID0gdXNlUmVmKCk7XHJcblxyXG4gICAgdXNlSW1wZXJhdGl2ZUhhbmRsZShyZWYsICgpID0+IHJvb3RSZWYuY3VycmVudCk7XHJcblxyXG4gICAgY29uc3QgaGFuZGxlQ2xpY2sgPSB1c2VDYWxsYmFjaygoKSA9PiB7XHJcbiAgICAgICAgb25DbGljayhyb290UmVmLmN1cnJlbnQsIHZhbHVlKTtcclxuICAgIH0sIFt2YWx1ZSwgb25DbGlja10pO1xyXG5cclxuICAgIGNvbnN0IGNsYXNzTmFtZXMgPSBjbGFzc25hbWVzKGNzc0NsYXNzZXMuUk9PVCwge1xyXG4gICAgICAgIFtjc3NDbGFzc2VzLkFDVElWRV06IGFjdGl2ZSxcclxuICAgICAgICBbY3NzQ2xhc3Nlcy5TVEFDS0VEXTogc3RhY2tlZCxcclxuICAgICAgICBbY3NzQ2xhc3Nlcy5NSU5fV0lEVEhdOiBtaW5XaWR0aFxyXG4gICAgfSwgY2xhc3NOYW1lKTtcclxuXHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAgIDxFbGVtZW50XHJcbiAgICAgICAgICAgIHJlZj17cm9vdFJlZn1cclxuICAgICAgICAgICAgY2xhc3NOYW1lPXtjbGFzc05hbWVzfVxyXG4gICAgICAgICAgICBkYXRhLXZhbHVlPXt2YWx1ZX1cclxuICAgICAgICAgICAgcm9sZT1cInRhYlwiXHJcbiAgICAgICAgICAgIGFyaWEtc2VsZWN0ZWQ9e2FjdGl2ZSA/ICd0cnVlJyA6ICdmYWxzZSd9XHJcbiAgICAgICAgICAgIHRhYkluZGV4PXthY3RpdmUgPyAwIDogLTF9XHJcbiAgICAgICAgICAgIG9uQ2xpY2s9e2hhbmRsZUNsaWNrfVxyXG4gICAgICAgICAgICB7Li4ucHJvcHN9XHJcbiAgICAgICAgPlxyXG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17Y3NzQ2xhc3Nlcy5DT05URU5UfT5cclxuICAgICAgICAgICAgICAgIHtpY29uICYmXHJcbiAgICAgICAgICAgICAgICAgICAgPENsb25lXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudD17aWNvbn1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZmFsbGJhY2s9e0ljb259XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT17Y3NzQ2xhc3Nlcy5JQ09OfVxyXG4gICAgICAgICAgICAgICAgICAgIC8+XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAge2NoaWxkcmVuICYmXHJcbiAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3NOYW1lPXtjc3NDbGFzc2VzLkxBQkVMfT57Y2hpbGRyZW59PC9zcGFuPlxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHttaW5XaWR0aEluZGljYXRvciAmJlxyXG4gICAgICAgICAgICAgICAgICAgIDxUYWJJbmRpY2F0b3JcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWNvbj17aW5kaWNhdG9ySWNvbn1cclxuICAgICAgICAgICAgICAgICAgICAgICAgYWN0aXZlPXthY3RpdmV9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZhZGU9e2ZhZGV9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHVuZGVybGluZT17dW5kZXJsaW5lfVxyXG4gICAgICAgICAgICAgICAgICAgIC8+XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIDwvZGl2PlxyXG5cclxuICAgICAgICAgICAgeyFtaW5XaWR0aEluZGljYXRvciAmJlxyXG4gICAgICAgICAgICAgICAgPFRhYkluZGljYXRvclxyXG4gICAgICAgICAgICAgICAgICAgIGljb249e2luZGljYXRvckljb259XHJcbiAgICAgICAgICAgICAgICAgICAgYWN0aXZlPXthY3RpdmV9XHJcbiAgICAgICAgICAgICAgICAgICAgZmFkZT17ZmFkZX1cclxuICAgICAgICAgICAgICAgICAgICB1bmRlcmxpbmU9e3VuZGVybGluZX1cclxuICAgICAgICAgICAgICAgIC8+XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXtjc3NDbGFzc2VzLlJJUFBMRX0gLz5cclxuICAgICAgICA8L0VsZW1lbnQ+XHJcbiAgICApO1xyXG59KTtcclxuXHJcblRhYi5kaXNwbGF5TmFtZSA9ICdNRENUYWInO1xyXG5cclxuVGFiLnByb3BUeXBlcyA9IHtcclxuICAgIHZhbHVlOiBQcm9wVHlwZXMuYW55LFxyXG4gICAgaWNvbjogUHJvcFR5cGVzLm5vZGUsXHJcbiAgICBsYWJlbDogUHJvcFR5cGVzLm5vZGUsXHJcbiAgICBpbmRpY2F0b3JJY29uOiBQcm9wVHlwZXMubm9kZSxcclxuICAgIGFjdGl2ZTogUHJvcFR5cGVzLmJvb2wsXHJcbiAgICBzdGFja2VkOiBQcm9wVHlwZXMuYm9vbCxcclxuICAgIG1pbldpZHRoOiBQcm9wVHlwZXMuYm9vbCxcclxuICAgIG1pbldpZHRoSW5kaWNhdG9yOiBQcm9wVHlwZXMuYm9vbCxcclxuICAgIGZhZGU6IFByb3BUeXBlcy5ib29sLFxyXG4gICAgdW5kZXJsaW5lOiBQcm9wVHlwZXMuYm9vbCxcclxuICAgIG9uQWN0aXZhdGU6IFByb3BUeXBlcy5mdW5jXHJcbn07XHJcblxyXG5leHBvcnQgZGVmYXVsdCBUYWI7IiwiaW1wb3J0IHsgZm9yd2FyZFJlZiwgdXNlUmVmIH0gZnJvbSAncmVhY3QnO1xyXG5pbXBvcnQgY2xhc3NuYW1lcyBmcm9tICdjbGFzc25hbWVzJztcclxuXHJcbmltcG9ydCB7IHVzZU1vdW50ZWQsIHVzZVVwZGF0ZWQgfSBmcm9tICcuLi9ob29rcyc7XHJcblxyXG5pbXBvcnQgeyBzY3JvbGxlckNzc0NsYXNzZXMgYXMgY3NzQ2xhc3NlcyB9IGZyb20gJy4vY29uc3RhbnRzJztcclxuXHJcbmNvbnN0IFRhYlNjcm9sbGVyID0gZm9yd2FyZFJlZigoe1xyXG4gICAgYWxpZ24sXHJcbiAgICBhY3RpdmVUYWIsXHJcblxyXG4gICAgY2hpbGRyZW4sXHJcbiAgICAuLi5wcm9wc1xyXG59LCByZWYpID0+IHtcclxuICAgIGNvbnN0IHNjcm9sbEFyZWFSZWYgPSB1c2VSZWYoKTtcclxuICAgIGNvbnN0IHNjcm9sbENvbnRlbnRSZWYgPSB1c2VSZWYoKTtcclxuXHJcbiAgICB1c2VNb3VudGVkKCgpID0+IHtcclxuICAgICAgICBjb25zdCBzY3JvbGxBcmVhV2lkdGggPSBzY3JvbGxBcmVhUmVmLmN1cnJlbnQub2Zmc2V0V2lkdGg7XHJcbiAgICAgICAgY29uc3Qgc2Nyb2xsQ29udGVudFdpZHRoID0gc2Nyb2xsQ29udGVudFJlZi5jdXJyZW50Lm9mZnNldFdpZHRoO1xyXG5cclxuICAgICAgICBpZiAoc2Nyb2xsQ29udGVudFdpZHRoID4gc2Nyb2xsQXJlYVdpZHRoKSB7XHJcbiAgICAgICAgICAgIHNjcm9sbEFyZWFSZWYuY3VycmVudC5jbGFzc0xpc3QuYWRkKGNzc0NsYXNzZXMuU0NST0xMX0FSRUFfU0NST0xMKTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICB1c2VVcGRhdGVkKCgpID0+IHtcclxuICAgICAgICBpZiAoIWFjdGl2ZVRhYikgcmV0dXJuO1xyXG5cclxuICAgICAgICBjb25zdCBzY3JvbGxBcmVhV2lkdGggPSBzY3JvbGxBcmVhUmVmLmN1cnJlbnQub2Zmc2V0V2lkdGg7XHJcbiAgICAgICAgY29uc3QgdGFiV2lkdGggPSBhY3RpdmVUYWIub2Zmc2V0V2lkdGg7XHJcbiAgICAgICAgY29uc3QgdGFiSGFsZldpZHRoID0gdGFiV2lkdGggKiAwLjU7XHJcbiAgICAgICAgY29uc3Qgb2Zmc2V0TGVmdCA9IGFjdGl2ZVRhYi5vZmZzZXRMZWZ0IC0gc2Nyb2xsQXJlYVJlZi5jdXJyZW50LnNjcm9sbExlZnQ7XHJcbiAgICAgICAgY29uc3Qgb2Zmc2V0TGVmdERlbHRhID0gYWN0aXZlVGFiLm9mZnNldExlZnQgLSBzY3JvbGxBcmVhUmVmLmN1cnJlbnQuc2Nyb2xsTGVmdDtcclxuICAgICAgICBjb25zdCBvZmZzZXRSaWdodCA9IGFjdGl2ZVRhYi5vZmZzZXRMZWZ0ICsgdGFiV2lkdGggLSBzY3JvbGxBcmVhUmVmLmN1cnJlbnQuc2Nyb2xsTGVmdDtcclxuICAgICAgICBjb25zdCBvZmZzZXRSaWdodERlbHRhID0gc2Nyb2xsQXJlYVdpZHRoIC0gb2Zmc2V0UmlnaHQ7XHJcblxyXG4gICAgICAgIGlmIChvZmZzZXRSaWdodCA+IHNjcm9sbEFyZWFXaWR0aCB8fCBvZmZzZXRSaWdodERlbHRhIDwgdGFiSGFsZldpZHRoKSB7XHJcbiAgICAgICAgICAgIHNjcm9sbEFyZWFSZWYuY3VycmVudC5zY3JvbGxCeSh7XHJcbiAgICAgICAgICAgICAgICBsZWZ0OiBvZmZzZXRSaWdodCA+IHNjcm9sbEFyZWFXaWR0aCA/IE1hdGguYWJzKG9mZnNldFJpZ2h0RGVsdGEpICsgdGFiSGFsZldpZHRoIDogdGFiSGFsZldpZHRoIC0gb2Zmc2V0UmlnaHREZWx0YSxcclxuICAgICAgICAgICAgICAgIGJlaGF2aW9yOiAnc21vb3RoJ1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9IGVsc2UgaWYgKG9mZnNldExlZnQgPCAwIHx8IG9mZnNldExlZnREZWx0YSA8IHRhYkhhbGZXaWR0aCkge1xyXG4gICAgICAgICAgICBzY3JvbGxBcmVhUmVmLmN1cnJlbnQuc2Nyb2xsQnkoe1xyXG4gICAgICAgICAgICAgICAgbGVmdDogb2Zmc2V0TGVmdCA8IDAgPyBvZmZzZXRMZWZ0RGVsdGEgLSB0YWJIYWxmV2lkdGggOiAtKHRhYkhhbGZXaWR0aCAtIG9mZnNldExlZnREZWx0YSksXHJcbiAgICAgICAgICAgICAgICBiZWhhdmlvcjogJ3Ntb290aCdcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSwgW2FjdGl2ZVRhYl0pO1xyXG5cclxuICAgIGNvbnN0IGNsYXNzTmFtZXMgPSBjbGFzc25hbWVzKGNzc0NsYXNzZXMuUk9PVCwge1xyXG4gICAgICAgIFtgJHtjc3NDbGFzc2VzLkFMSUdOfS0ke2FsaWdufWBdOiBhbGlnblxyXG4gICAgfSk7XHJcblxyXG4gICAgcmV0dXJuIChcclxuICAgICAgICA8ZGl2IHJlZj17cmVmfSBjbGFzc05hbWU9e2NsYXNzTmFtZXN9IHsuLi5wcm9wc30+XHJcbiAgICAgICAgICAgIDxkaXYgcmVmPXtzY3JvbGxBcmVhUmVmfSBjbGFzc05hbWU9e2Nzc0NsYXNzZXMuU0NST0xMX0FSRUF9PlxyXG4gICAgICAgICAgICAgICAgPGRpdiByZWY9e3Njcm9sbENvbnRlbnRSZWZ9IGNsYXNzTmFtZT17Y3NzQ2xhc3Nlcy5TQ1JPTExfQ09OVEVOVH0+XHJcbiAgICAgICAgICAgICAgICAgICAge2NoaWxkcmVufVxyXG4gICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgIDwvZGl2PlxyXG4gICAgKTtcclxufSk7XHJcblxyXG5UYWJTY3JvbGxlci5kaXNwbGF5TmFtZSA9ICdNRENUYWJTY3JvbGxlcic7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBUYWJTY3JvbGxlcjsiLCJpbXBvcnQgeyBDaGlsZHJlbiwgZm9yd2FyZFJlZiwgdXNlQ2FsbGJhY2ssIHVzZUVmZmVjdCwgdXNlSW1wZXJhdGl2ZUhhbmRsZSwgdXNlUmVmIH0gZnJvbSAncmVhY3QnO1xyXG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xyXG5pbXBvcnQgY2xhc3NuYW1lcyBmcm9tICdjbGFzc25hbWVzJztcclxuXHJcbmltcG9ydCB7IGlzVW5kZWZpbmVkIH0gZnJvbSAnLi4vdHlwZXMnO1xyXG5pbXBvcnQgeyBjcmVhdGUsIGNsb25lIH0gZnJvbSAnLi4vY29tcG9uZW50JztcclxuXHJcbmltcG9ydCB7IGJhckNzc0NsYXNzZXMgYXMgY3NzQ2xhc3NlcywgdGFiQ2xhc3NOYW1lcywgQWxpZ24gfSBmcm9tICcuL2NvbnN0YW50cyc7XHJcbmltcG9ydCBUYWJDb250ZXh0IGZyb20gJy4vY29udGV4dCc7XHJcbmltcG9ydCBUYWIgZnJvbSAnLi9UYWInO1xyXG5pbXBvcnQgVGFiU2Nyb2xsZXIgZnJvbSAnLi9UYWJTY3JvbGxlcic7XHJcblxyXG5jb25zdCBUYWJCYXIgPSBmb3J3YXJkUmVmKCh7XHJcbiAgICB0YWJzLFxyXG4gICAgdmFsdWUsXHJcbiAgICBhbGlnbixcclxuICAgIGluZGljYXRvckljb24sXHJcbiAgICBzdGFja2VkID0gZmFsc2UsXHJcbiAgICBtaW5XaWR0aCA9IGZhbHNlLFxyXG4gICAgbWluV2lkdGhJbmRpY2F0b3IgPSBmYWxzZSxcclxuICAgIGZhZGUgPSBmYWxzZSxcclxuICAgIGljb25JbmRpY2F0b3IgPSBCb29sZWFuKGluZGljYXRvckljb24pLFxyXG4gICAgdW5kZXJsaW5lSW5kaWNhdG9yID0gIWljb25JbmRpY2F0b3IsXHJcbiAgICBvbkNoYW5nZSA9IEZ1bmN0aW9uLnByb3RvdHlwZSxcclxuXHJcbiAgICBlbGVtZW50ID0gJ2RpdicsXHJcbiAgICBjb21wb25lbnQ6IEVsZW1lbnQgPSBlbGVtZW50LFxyXG4gICAgY2xhc3NOYW1lLFxyXG4gICAgY2hpbGRyZW4gPSB0YWJzPy5tYXAodGFiID0+IGNyZWF0ZShUYWIsIHRhYikpLFxyXG4gICAgLi4ucHJvcHNcclxufSwgcmVmKSA9PiB7XHJcbiAgICBjb25zdCByb290UmVmID0gdXNlUmVmKCk7XHJcbiAgICBjb25zdCBhY3RpdmVUYWJSZWYgPSB1c2VSZWYoKTtcclxuICAgIGNvbnN0IHByZXZpb3VzVGFiUmVmID0gdXNlUmVmKCk7XHJcblxyXG4gICAgdXNlSW1wZXJhdGl2ZUhhbmRsZShyZWYsICgpID0+IHJvb3RSZWYuY3VycmVudCk7XHJcblxyXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgICAgICBhY3RpdmVUYWJSZWYuY3VycmVudCA9IHJvb3RSZWYuY3VycmVudC5xdWVyeVNlbGVjdG9yKGAuJHt0YWJDbGFzc05hbWVzLkFDVElWRX1gKTtcclxuICAgIH0sIFtdKTtcclxuXHJcbiAgICBjb25zdCBoYW5kbGVUYWJDbGljayA9IHVzZUNhbGxiYWNrKChlbGVtZW50LCB2YWx1ZSkgPT4ge1xyXG4gICAgICAgIHByZXZpb3VzVGFiUmVmLmN1cnJlbnQgPSBhY3RpdmVUYWJSZWYuY3VycmVudDtcclxuICAgICAgICBhY3RpdmVUYWJSZWYuY3VycmVudCA9IGVsZW1lbnQ7XHJcbiAgICAgICAgb25DaGFuZ2UodmFsdWUpO1xyXG4gICAgfSwgW29uQ2hhbmdlXSk7XHJcblxyXG4gICAgY29uc3QgY2xhc3NOYW1lcyA9IGNsYXNzbmFtZXMoY3NzQ2xhc3Nlcy5ST09ULCBjbGFzc05hbWUpO1xyXG5cclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgPEVsZW1lbnRcclxuICAgICAgICAgICAgcmVmPXtyb290UmVmfVxyXG4gICAgICAgICAgICBjbGFzc05hbWU9e2NsYXNzTmFtZXN9XHJcbiAgICAgICAgICAgIHJvbGU9XCJ0YWJsaXN0XCJcclxuICAgICAgICAgICAgey4uLnByb3BzfVxyXG4gICAgICAgID5cclxuICAgICAgICAgICAgeyFpc1VuZGVmaW5lZCh2YWx1ZSkgP1xyXG4gICAgICAgICAgICAgICAgPFRhYkNvbnRleHQuUHJvdmlkZXIgdmFsdWU9e3tcclxuICAgICAgICAgICAgICAgICAgICBhY3RpdmVUYWI6IGFjdGl2ZVRhYlJlZi5jdXJyZW50LFxyXG4gICAgICAgICAgICAgICAgICAgIHByZXZpb3VzVGFiOiBwcmV2aW91c1RhYlJlZi5jdXJyZW50XHJcbiAgICAgICAgICAgICAgICB9fT5cclxuICAgICAgICAgICAgICAgICAgICA8VGFiU2Nyb2xsZXJcclxuICAgICAgICAgICAgICAgICAgICAgICAgYWxpZ249e2FsaWdufVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBhY3RpdmVUYWI9e2FjdGl2ZVRhYlJlZi5jdXJyZW50fVxyXG4gICAgICAgICAgICAgICAgICAgID5cclxuICAgICAgICAgICAgICAgICAgICAgICAge0NoaWxkcmVuLm1hcChjaGlsZHJlbiwgKHRhYiwgaW5kZXgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHRhYlZhbHVlID0gaXNVbmRlZmluZWQodGFiLnByb3BzLnZhbHVlKSA/IGluZGV4IDogdGFiLnByb3BzLnZhbHVlO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjbG9uZSh0YWIsIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdGFiVmFsdWUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWN0aXZlOiB0YWJWYWx1ZSA9PT0gdmFsdWUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kaWNhdG9ySWNvbjogdGFiLnByb3BzLmluZGljYXRvckljb24gfHwgaW5kaWNhdG9ySWNvbixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFja2VkOiB0YWIucHJvcHMuc3RhY2tlZCB8fCBzdGFja2VkLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1pbldpZHRoOiB0YWIucHJvcHMubWluV2lkdGggfHwgbWluV2lkdGgsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWluV2lkdGhJbmRpY2F0b3I6IHRhYi5wcm9wcy5taW5XaWR0aEluZGljYXRvciB8fCBtaW5XaWR0aEluZGljYXRvcixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmYWRlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVuZGVybGluZTogdW5kZXJsaW5lSW5kaWNhdG9yLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2xpY2s6IGhhbmRsZVRhYkNsaWNrXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSl9XHJcbiAgICAgICAgICAgICAgICAgICAgPC9UYWJTY3JvbGxlcj5cclxuICAgICAgICAgICAgICAgIDwvVGFiQ29udGV4dC5Qcm92aWRlcj5cclxuICAgICAgICAgICAgICAgIDpcclxuICAgICAgICAgICAgICAgIGNoaWxkcmVuXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICA8L0VsZW1lbnQ+XHJcbiAgICApO1xyXG59KTtcclxuXHJcblRhYkJhci5kaXNwbGF5TmFtZSA9ICdNRENUYWJCYXInO1xyXG5cclxuVGFiQmFyLnByb3BUeXBlcyA9IHtcclxuICAgIGFsaWduOiBQcm9wVHlwZXMub25lT2YoT2JqZWN0LnZhbHVlcyhBbGlnbikpLFxyXG4gICAgaW5kaWNhdG9ySWNvbjogUHJvcFR5cGVzLm5vZGUsXHJcbiAgICBzdGFja2VkOiBQcm9wVHlwZXMuYm9vbCxcclxuICAgIG1pbldpZHRoOiBQcm9wVHlwZXMuYm9vbCxcclxuICAgIGZhZGU6IFByb3BUeXBlcy5ib29sLFxyXG4gICAgaWNvbkluZGljYXRvcjogUHJvcFR5cGVzLmJvb2wsXHJcbiAgICB1bmRlcmxpbmVJbmRpY2F0b3I6IFByb3BUeXBlcy5ib29sLFxyXG4gICAgb25DaGFuZ2U6IFByb3BUeXBlcy5mdW5jXHJcbn07XHJcblxyXG5UYWJCYXIuQWxpZ24gPSBBbGlnbjtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IFRhYkJhcjsiLCJpbXBvcnQgVGFiIGZyb20gJy4vVGFiJztcclxuaW1wb3J0IFRhYkJhciBmcm9tICcuL1RhYkJhcic7XHJcblxyXG5UYWIuQmFyID0gVGFiQmFyO1xyXG5cclxuZXhwb3J0IHtcclxuICAgIFRhYixcclxuICAgIFRhYkJhclxyXG59OyIsImV4cG9ydCBjb25zdCBudW1iZXJzID0ge1xyXG4gICAgQk9VTkRFRF9BTkNIT1JfR0FQOiA0LFxyXG4gICAgVU5CT1VOREVEX0FOQ0hPUl9HQVA6IDgsXHJcbiAgICBNSU5fVklFV1BPUlRfVE9PTFRJUF9USFJFU0hPTEQ6IDgsXHJcbiAgICBFTlRFUl9EVVJBVElPTl9NUzogMTUwLFxyXG4gICAgRVhJVF9EVVJBVElPTl9NUzogNzUsXHJcbiAgICBISURFX0RFTEFZX01TOiA2MDAsXHJcbiAgICBTSE9XX0RFTEFZX01TOiA1MDAsXHJcbiAgICBNSU5fSEVJR0hUOiAyNCxcclxuICAgIE1BWF9XSURUSDogMjAwLFxyXG4gICAgQ0FSRVRfSU5ERU5UQVRJT046IDI0LFxyXG4gICAgQU5JTUFUSU9OX1NDQUxFOiAwLjhcclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCBjc3NDbGFzc2VzID0ge1xyXG4gICAgUk9PVDogJ21kYy10b29sdGlwJyxcclxuICAgIFJJQ0g6ICdtZGMtdG9vbHRpcC0tcmljaCcsXHJcbiAgICBNVUxUSUxJTkU6ICdtZGMtdG9vbHRpcC0tbXVsdGlsaW5lJyxcclxuICAgIFNIT1dJTkc6ICdtZGMtdG9vbHRpcC0tc2hvd2luZycsXHJcbiAgICBBQ1RJT05TOiAnbWRjLXRvb2x0aXAtLXJpY2gtYWN0aW9ucycsXHJcbiAgICBTSE9XSU5HX1RSQU5TSVRJT046ICdtZGMtdG9vbHRpcC0tc2hvd2luZy10cmFuc2l0aW9uJyxcclxuICAgIFNIT1dOOiAnbWRjLXRvb2x0aXAtLXNob3duJyxcclxuICAgIEhJREU6ICdtZGMtdG9vbHRpcC0taGlkZScsXHJcbiAgICBISURFX1RSQU5TSVRJT046ICdtZGMtdG9vbHRpcC0taGlkZS10cmFuc2l0aW9uJyxcclxuXHJcbiAgICBTVVJGQUNFOiAnbWRjLXRvb2x0aXBfX3N1cmZhY2UnLFxyXG4gICAgU1VSRkFDRV9BTklNQVRJT046ICdtZGMtdG9vbHRpcF9fc3VyZmFjZS1hbmltYXRpb24nLFxyXG5cclxuICAgIFRJVExFOiAnbWRjLXRvb2x0aXBfX3RpdGxlJyxcclxuXHJcbiAgICBDT05URU5UOiAnbWRjLXRvb2x0aXBfX2NvbnRlbnQnLFxyXG4gICAgQ09OVEVOVF9MSU5LOiAnbWRjLXRvb2x0aXBfX2NvbnRlbnQtbGluaycsXHJcblxyXG4gICAgQUNUSU9OOiAnbWRjLXRvb2x0aXBfX2FjdGlvbicsXHJcblxyXG4gICAgQ0FSRVRfVE9QOiAnbWRjLXRvb2x0aXBfX2NhcmV0LXN1cmZhY2UtdG9wJyxcclxuICAgIENBUkVUX0JPVFRPTTogJ21kYy10b29sdGlwX19jYXJldC1zdXJmYWNlLWJvdHRvbSdcclxufTsiLCJpbXBvcnQgeyB1c2VSZWYsIHVzZVN0YXRlLCB1c2VFZmZlY3QsIHVzZUNhbGxiYWNrLCB1c2VJbXBlcmF0aXZlSGFuZGxlLCBmb3J3YXJkUmVmIH0gZnJvbSAncmVhY3QnO1xyXG5pbXBvcnQgY2xhc3NuYW1lcyBmcm9tICdjbGFzc25hbWVzJztcclxuXHJcbmltcG9ydCB7IENsb25lIH0gZnJvbSAnLi4vY29tcG9uZW50JztcclxuaW1wb3J0IExheWVyIGZyb20gJy4uL2xheWVyJztcclxuXHJcbmltcG9ydCB7IG51bWJlcnMsIGNzc0NsYXNzZXMgfSBmcm9tICcuL2NvbnN0YW50cyc7XHJcblxyXG5jb25zdCBUb29sdGlwID0gZm9yd2FyZFJlZigoe1xyXG4gICAgbGFiZWwsXHJcblxyXG4gICAgZWxlbWVudDogRWxlbWVudCA9ICdkaXYnLFxyXG4gICAgY2xhc3NOYW1lLFxyXG4gICAgY2hpbGRyZW5cclxufSwgcmVmKSA9PiB7XHJcbiAgICBjb25zdCB0b29sdGlwUmVmID0gdXNlUmVmKCk7XHJcbiAgICBjb25zdCB0YXJnZXRSZWYgPSB1c2VSZWYobnVsbCk7XHJcbiAgICBjb25zdCBbYWN0aXZlLCBzZXRBY3RpdmVdID0gdXNlU3RhdGUoZmFsc2UpO1xyXG5cclxuICAgIHVzZUltcGVyYXRpdmVIYW5kbGUocmVmLCAoKSA9PiB0b29sdGlwUmVmLmN1cnJlbnQpO1xyXG5cclxuICAgIHVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICAgICAgZnVuY3Rpb24gaGFuZGxlU2Nyb2xsKCkge1xyXG4gICAgICAgICAgICBzZXRBY3RpdmUoYWN0aXZlID0+IGFjdGl2ZSAmJiAhYWN0aXZlKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIGhhbmRsZVNjcm9sbCk7XHJcblxyXG4gICAgICAgIHJldHVybiAoKSA9PiB7XHJcbiAgICAgICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIGhhbmRsZVNjcm9sbCk7XHJcbiAgICAgICAgfTtcclxuICAgIH0sIFtdKTtcclxuXHJcbiAgICBjb25zdCBoYW5kbGVNb3VzZUVudGVyID0gdXNlQ2FsbGJhY2soZXZlbnQgPT4ge1xyXG4gICAgICAgIHRhcmdldFJlZi5jdXJyZW50ID0gZXZlbnQuY3VycmVudFRhcmdldDtcclxuICAgICAgICBzZXRBY3RpdmUodHJ1ZSk7XHJcbiAgICB9LCBbXSk7XHJcblxyXG4gICAgY29uc3QgaGFuZGxlTW91c2VMZWF2ZSA9IHVzZUNhbGxiYWNrKCgpID0+IHtcclxuICAgICAgICB0YXJnZXRSZWYuY3VycmVudCA9IG51bGw7XHJcbiAgICAgICAgc2V0QWN0aXZlKGZhbHNlKTtcclxuICAgIH0sIFtdKTtcclxuXHJcbiAgICBjb25zdCBoYW5kbGVFbnRlcmluZyA9IHVzZUNhbGxiYWNrKCgpID0+IHtcclxuICAgICAgICBjb25zdCB0b29sdGlwUmVjdCA9IHRvb2x0aXBSZWYuY3VycmVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcclxuICAgICAgICBjb25zdCB0YXJnZXRSZWN0ID0gdGFyZ2V0UmVmLmN1cnJlbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XHJcblxyXG4gICAgICAgIGNvbnN0IHRvcCA9ICh0YXJnZXRSZWN0LnRvcCArIHRhcmdldFJlY3QuaGVpZ2h0ICsgbnVtYmVycy5VTkJPVU5ERURfQU5DSE9SX0dBUCk7XHJcbiAgICAgICAgY29uc3QgbGVmdCA9ICh0YXJnZXRSZWN0LmxlZnQgKyB0YXJnZXRSZWN0LndpZHRoICogMC41IC0gdG9vbHRpcFJlY3Qud2lkdGggKiAwLjUpO1xyXG4gICAgICAgIGNvbnN0IHJpZ2h0ID0gbGVmdCArIHRvb2x0aXBSZWN0LndpZHRoO1xyXG4gICAgICAgIGNvbnN0IGJvdHRvbSA9IHRvcCArIHRvb2x0aXBSZWN0LmhlaWdodDtcclxuICAgICAgICBjb25zdCBvdmVyZmxvd0JvdHRvbSA9IHdpbmRvdy5pbm5lckhlaWdodCAtIGJvdHRvbTtcclxuICAgICAgICBjb25zdCBvdmVyZmxvd1JpZ2h0ID0gd2luZG93LmlubmVyV2lkdGggLSByaWdodDtcclxuXHJcbiAgICAgICAgaWYgKFxyXG4gICAgICAgICAgICB0b29sdGlwUmVjdC5oZWlnaHQgPiBudW1iZXJzLk1JTl9IRUlHSFQgJiZcclxuICAgICAgICAgICAgdG9vbHRpcFJlY3Qud2lkdGggPj0gbnVtYmVycy5NQVhfV0lEVEhcclxuICAgICAgICApIHtcclxuICAgICAgICAgICAgdG9vbHRpcFJlZi5jdXJyZW50LmNsYXNzTGlzdC5hZGQoY3NzQ2xhc3Nlcy5NVUxUSUxJTkUpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKG92ZXJmbG93Qm90dG9tIDwgMCkge1xyXG4gICAgICAgICAgICB0b29sdGlwUmVmLmN1cnJlbnQuc3R5bGUudG9wID0gYCR7dGFyZ2V0UmVjdC50b3AgLSB0b29sdGlwUmVjdC5oZWlnaHQgLSBudW1iZXJzLlVOQk9VTkRFRF9BTkNIT1JfR0FQfXB4YDtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0b29sdGlwUmVmLmN1cnJlbnQuc3R5bGUudG9wID0gYCR7dG9wfXB4YDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChvdmVyZmxvd1JpZ2h0IDwgMCkge1xyXG4gICAgICAgICAgICB0b29sdGlwUmVmLmN1cnJlbnQuc3R5bGUubGVmdCA9IGAke3RhcmdldFJlY3QucmlnaHQgLSB0b29sdGlwUmVjdC53aWR0aH1weGA7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdG9vbHRpcFJlZi5jdXJyZW50LnN0eWxlLmxlZnQgPSBgJHtsZWZ0IDwgMCA/IHRhcmdldFJlY3QubGVmdCA6IGxlZnR9cHhgO1xyXG4gICAgICAgIH1cclxuICAgIH0sIFtdKTtcclxuXHJcbiAgICBjb25zdCBjbGFzc05hbWVzID0gY2xhc3NuYW1lcyhjc3NDbGFzc2VzLlJPT1QsIGNsYXNzTmFtZSk7XHJcblxyXG4gICAgcmV0dXJuICg8PlxyXG4gICAgICAgIDxDbG9uZVxyXG4gICAgICAgICAgICBjb21wb25lbnQ9e2NoaWxkcmVufVxyXG4gICAgICAgICAgICBvbk1vdXNlRW50ZXI9e2hhbmRsZU1vdXNlRW50ZXJ9XHJcbiAgICAgICAgICAgIG9uTW91c2VMZWF2ZT17aGFuZGxlTW91c2VMZWF2ZX1cclxuICAgICAgICAvPlxyXG5cclxuICAgICAgICA8TGF5ZXJcclxuICAgICAgICAgICAgbW9kYWxcclxuICAgICAgICAgICAgaW49e2FjdGl2ZX1cclxuICAgICAgICAgICAgdGltZW91dD17e1xyXG4gICAgICAgICAgICAgICAgZW50ZXI6IG51bWJlcnMuU0hPV19ERUxBWV9NUyxcclxuICAgICAgICAgICAgICAgIGV4aXQ6IG51bWJlcnMuSElERV9ERUxBWV9NU1xyXG4gICAgICAgICAgICB9fVxyXG4gICAgICAgICAgICBjbGFzc05hbWVzPXt7XHJcbiAgICAgICAgICAgICAgICBlbnRlcjogY3NzQ2xhc3Nlcy5TSE9XSU5HX1RSQU5TSVRJT04sXHJcbiAgICAgICAgICAgICAgICBlbnRlckFjdGl2ZTogYCR7Y3NzQ2xhc3Nlcy5TSE9XSU5HX1RSQU5TSVRJT059ICR7Y3NzQ2xhc3Nlcy5TSE9XSU5HfWAsXHJcbiAgICAgICAgICAgICAgICBlbnRlckRvbmU6IGAke2Nzc0NsYXNzZXMuU0hPV0lOR19UUkFOU0lUSU9OfSAke2Nzc0NsYXNzZXMuU0hPV059YCxcclxuICAgICAgICAgICAgICAgIGV4aXQ6IGAke2Nzc0NsYXNzZXMuSElERV9UUkFOU0lUSU9OfSAke2Nzc0NsYXNzZXMuSElERX1gLFxyXG4gICAgICAgICAgICAgICAgZXhpdEFjdGl2ZTogYCR7Y3NzQ2xhc3Nlcy5ISURFX1RSQU5TSVRJT059ICR7Y3NzQ2xhc3Nlcy5ISURFfWBcclxuICAgICAgICAgICAgfX1cclxuICAgICAgICAgICAgb25FbnRlcmluZz17aGFuZGxlRW50ZXJpbmd9XHJcbiAgICAgICAgICAgIG1vdW50T25FbnRlclxyXG4gICAgICAgICAgICB1bm1vdW50T25FeGl0XHJcbiAgICAgICAgPlxyXG4gICAgICAgICAgICA8RWxlbWVudFxyXG4gICAgICAgICAgICAgICAgcmVmPXt0b29sdGlwUmVmfVxyXG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lPXtjbGFzc05hbWVzfVxyXG4gICAgICAgICAgICAgICAgcm9sZT1cInRvb2x0aXBcIlxyXG4gICAgICAgICAgICAgICAgYXJpYS1oaWRkZW49e2FjdGl2ZSA/IHVuZGVmaW5lZCA6ICd0cnVlJ31cclxuICAgICAgICAgICAgPlxyXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9e2Ake2Nzc0NsYXNzZXMuU1VSRkFDRX0gJHtjc3NDbGFzc2VzLlNVUkZBQ0VfQU5JTUFUSU9OfWB9PlxyXG4gICAgICAgICAgICAgICAgICAgIHtsYWJlbH1cclxuICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICA8L0VsZW1lbnQ+XHJcbiAgICAgICAgPC9MYXllcj5cclxuICAgIDwvPik7XHJcbn0pO1xyXG5cclxuVG9vbHRpcC5kaXNwbGF5TmFtZSA9ICdNRENUb29sdGlwJztcclxuXHJcbmV4cG9ydCBkZWZhdWx0IFRvb2x0aXA7IiwiaW1wb3J0IHsgQ2hpbGRyZW4sIGZvcndhcmRSZWYsIHVzZUNhbGxiYWNrLCB1c2VFZmZlY3QsIHVzZUltcGVyYXRpdmVIYW5kbGUsIHVzZVJlZiwgdXNlU3RhdGUgfSBmcm9tICdyZWFjdCc7XHJcbmltcG9ydCBjbGFzc25hbWVzIGZyb20gJ2NsYXNzbmFtZXMnO1xyXG5cclxuaW1wb3J0IHsgQ2xvbmUgfSBmcm9tICcuLi9jb21wb25lbnQnO1xyXG5pbXBvcnQgTGF5ZXIgZnJvbSAnLi4vbGF5ZXInO1xyXG5cclxuaW1wb3J0IHsgbnVtYmVycywgY3NzQ2xhc3NlcyB9IGZyb20gJy4vY29uc3RhbnRzJztcclxuXHJcbmNvbnN0IFJpY2hUb29sdGlwID0gZm9yd2FyZFJlZigoe1xyXG4gICAgdGl0bGUsXHJcbiAgICBjb250ZW50LFxyXG4gICAgYWN0aW9ucyxcclxuXHJcbiAgICBlbGVtZW50OiBFbGVtZW50ID0gJ2RpdicsXHJcbiAgICBjbGFzc05hbWUsXHJcbiAgICBjaGlsZHJlblxyXG59LCByZWYpID0+IHtcclxuICAgIGNvbnN0IHRvb2x0aXBSZWYgPSB1c2VSZWYoKTtcclxuICAgIGNvbnN0IHRhcmdldFJlZiA9IHVzZVJlZigpO1xyXG5cclxuICAgIGNvbnN0IFthY3RpdmUsIHNldEFjdGl2ZV0gPSB1c2VTdGF0ZShmYWxzZSk7XHJcblxyXG4gICAgdXNlSW1wZXJhdGl2ZUhhbmRsZShyZWYsICgpID0+IHRvb2x0aXBSZWYuY3VycmVudCk7XHJcblxyXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgICAgICBmdW5jdGlvbiBoYW5kbGVTY3JvbGwoKSB7XHJcbiAgICAgICAgICAgIHNldEFjdGl2ZShhY3RpdmUgPT4gYWN0aXZlICYmICFhY3RpdmUpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgaGFuZGxlU2Nyb2xsKTtcclxuXHJcbiAgICAgICAgcmV0dXJuICgpID0+IHtcclxuICAgICAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgaGFuZGxlU2Nyb2xsKTtcclxuICAgICAgICB9O1xyXG4gICAgfSwgW10pO1xyXG5cclxuICAgIGNvbnN0IGhhbmRsZVRhcmdldE1vdXNlRW50ZXIgPSB1c2VDYWxsYmFjaygoKSA9PiB7XHJcbiAgICAgICAgc2V0QWN0aXZlKHRydWUpO1xyXG4gICAgfSwgW10pO1xyXG5cclxuICAgIGNvbnN0IGhhbmRsZVRhcmdldE1vdXNlTGVhdmUgPSB1c2VDYWxsYmFjaygoKSA9PiB7XHJcbiAgICAgICAgc2V0QWN0aXZlKGZhbHNlKTtcclxuICAgIH0sIFtdKTtcclxuXHJcbiAgICBjb25zdCBoYW5kbGVUb29sdGlwTW91c2VFbnRlciA9IHVzZUNhbGxiYWNrKCgpID0+IHtcclxuICAgICAgICBzZXRBY3RpdmUodHJ1ZSk7XHJcbiAgICB9LCBbXSk7XHJcblxyXG4gICAgY29uc3QgaGFuZGxlVG9vbHRpcE1vdXNlTGVhdmUgPSB1c2VDYWxsYmFjaygoKSA9PiB7XHJcbiAgICAgICAgc2V0QWN0aXZlKGZhbHNlKTtcclxuICAgIH0sIFtdKTtcclxuXHJcbiAgICBjb25zdCBoYW5kbGVFbnRlcmluZyA9IHVzZUNhbGxiYWNrKCgpID0+IHtcclxuICAgICAgICBjb25zdCB0b29sdGlwUmVjdCA9IHRvb2x0aXBSZWYuY3VycmVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcclxuICAgICAgICBjb25zdCB0YXJnZXRSZWN0ID0gdGFyZ2V0UmVmLmN1cnJlbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XHJcblxyXG4gICAgICAgIGNvbnN0IHdpZHRoID0gdG9vbHRpcFJlZi5jdXJyZW50LmZpcnN0Q2hpbGQuY2xpZW50V2lkdGg7XHJcbiAgICAgICAgY29uc3QgaGVpZ2h0ID0gdG9vbHRpcFJlZi5jdXJyZW50LmZpcnN0Q2hpbGQuc2Nyb2xsSGVpZ2h0O1xyXG4gICAgICAgIGNvbnN0IHRvcCA9IHRhcmdldFJlY3QuYm90dG9tICsgd2luZG93LnNjcm9sbFkgKyBudW1iZXJzLlVOQk9VTkRFRF9BTkNIT1JfR0FQO1xyXG4gICAgICAgIGNvbnN0IGxlZnQgPSB0YXJnZXRSZWN0LnJpZ2h0ICsgd2luZG93LnNjcm9sbFggKyBudW1iZXJzLlVOQk9VTkRFRF9BTkNIT1JfR0FQO1xyXG4gICAgICAgIGNvbnN0IHJpZ2h0ID0gbGVmdCArIHdpZHRoICsgbnVtYmVycy5NSU5fVklFV1BPUlRfVE9PTFRJUF9USFJFU0hPTEQ7XHJcbiAgICAgICAgY29uc3QgYm90dG9tID0gdG9wICsgaGVpZ2h0ICsgbnVtYmVycy5NSU5fVklFV1BPUlRfVE9PTFRJUF9USFJFU0hPTEQ7XHJcbiAgICAgICAgY29uc3Qgb3ZlcmZsb3dCb3R0b20gPSB3aW5kb3cuaW5uZXJIZWlnaHQgLSBib3R0b207XHJcbiAgICAgICAgY29uc3Qgb3ZlcmZsb3dSaWdodCA9IHdpbmRvdy5pbm5lcldpZHRoIC0gcmlnaHQ7XHJcblxyXG4gICAgICAgIGlmIChvdmVyZmxvd0JvdHRvbSA8IDApIHtcclxuICAgICAgICAgICAgdG9vbHRpcFJlZi5jdXJyZW50LnN0eWxlLnRvcCA9IGAke3RvcCArIG92ZXJmbG93Qm90dG9tfXB4YDtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0b29sdGlwUmVmLmN1cnJlbnQuc3R5bGUudG9wID0gYCR7dG9wfXB4YDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChvdmVyZmxvd1JpZ2h0IDwgMCkge1xyXG4gICAgICAgICAgICB0b29sdGlwUmVmLmN1cnJlbnQuc3R5bGUubGVmdCA9IGAke3RhcmdldFJlY3QucmlnaHQgLSB0b29sdGlwUmVjdC53aWR0aH1weGA7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdG9vbHRpcFJlZi5jdXJyZW50LnN0eWxlLmxlZnQgPSBgJHtsZWZ0IDwgMCA/IHRhcmdldFJlY3QubGVmdCA6IGxlZnR9cHhgO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdG9vbHRpcFJlZi5jdXJyZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xyXG4gICAgfSwgW10pO1xyXG5cclxuICAgIGNvbnN0IGNsYXNzTmFtZXMgPSBjbGFzc25hbWVzKGNzc0NsYXNzZXMuUk9PVCwgY3NzQ2xhc3Nlcy5SSUNILCBjbGFzc05hbWUpO1xyXG5cclxuICAgIHJldHVybiAoPD5cclxuICAgICAgICA8Q2xvbmVcclxuICAgICAgICAgICAgY29tcG9uZW50PXtjaGlsZHJlbn1cclxuICAgICAgICAgICAgcmVmPXt0YXJnZXRSZWZ9XHJcbiAgICAgICAgICAgIG9uTW91c2VFbnRlcj17aGFuZGxlVGFyZ2V0TW91c2VFbnRlcn1cclxuICAgICAgICAgICAgb25Nb3VzZUxlYXZlPXtoYW5kbGVUYXJnZXRNb3VzZUxlYXZlfVxyXG4gICAgICAgIC8+XHJcblxyXG4gICAgICAgIDxMYXllclxyXG4gICAgICAgICAgICBtb2RhbFxyXG4gICAgICAgICAgICBpbj17YWN0aXZlfVxyXG4gICAgICAgICAgICB0aW1lb3V0PXt7XHJcbiAgICAgICAgICAgICAgICBlbnRlcjogbnVtYmVycy5TSE9XX0RFTEFZX01TLFxyXG4gICAgICAgICAgICAgICAgZXhpdDogbnVtYmVycy5ISURFX0RFTEFZX01TXHJcbiAgICAgICAgICAgIH19XHJcbiAgICAgICAgICAgIGNsYXNzTmFtZXM9e3tcclxuICAgICAgICAgICAgICAgIGVudGVyOiBjc3NDbGFzc2VzLlNIT1dJTkdfVFJBTlNJVElPTixcclxuICAgICAgICAgICAgICAgIGVudGVyQWN0aXZlOiBgJHtjc3NDbGFzc2VzLlNIT1dJTkdfVFJBTlNJVElPTn0gJHtjc3NDbGFzc2VzLlNIT1dJTkd9YCxcclxuICAgICAgICAgICAgICAgIGVudGVyRG9uZTogYCR7Y3NzQ2xhc3Nlcy5TSE9XSU5HX1RSQU5TSVRJT059ICR7Y3NzQ2xhc3Nlcy5TSE9XTn1gLFxyXG4gICAgICAgICAgICAgICAgZXhpdDogY3NzQ2xhc3Nlcy5TSE9XTixcclxuICAgICAgICAgICAgICAgIGV4aXRBY3RpdmU6IGAke2Nzc0NsYXNzZXMuSElERV9UUkFOU0lUSU9OfSAke2Nzc0NsYXNzZXMuU0hPV059YCxcclxuICAgICAgICAgICAgICAgIGV4aXREb25lOiBgJHtjc3NDbGFzc2VzLkhJREVfVFJBTlNJVElPTn0gJHtjc3NDbGFzc2VzLkhJREV9YFxyXG4gICAgICAgICAgICB9fVxyXG4gICAgICAgICAgICBtb3VudE9uRW50ZXJcclxuICAgICAgICAgICAgdW5tb3VudE9uRXhpdFxyXG4gICAgICAgICAgICBvbkVudGVyaW5nPXtoYW5kbGVFbnRlcmluZ31cclxuICAgICAgICA+XHJcbiAgICAgICAgICAgIDxFbGVtZW50XHJcbiAgICAgICAgICAgICAgICByZWY9e3Rvb2x0aXBSZWZ9XHJcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU9e2NsYXNzTmFtZXN9XHJcbiAgICAgICAgICAgICAgICByb2xlPVwidG9vbHRpcFwiXHJcbiAgICAgICAgICAgICAgICBhcmlhLWhpZGRlbj17YWN0aXZlID8gdW5kZWZpbmVkIDogJ3RydWUnfVxyXG4gICAgICAgICAgICAgICAgYXJpYS1leHBhbmRlZD17YWN0aXZlID8gJ3RydWUnIDogdW5kZWZpbmVkfVxyXG4gICAgICAgICAgICAgICAgb25Nb3VzZUVudGVyPXtoYW5kbGVUb29sdGlwTW91c2VFbnRlcn1cclxuICAgICAgICAgICAgICAgIG9uTW91c2VMZWF2ZT17aGFuZGxlVG9vbHRpcE1vdXNlTGVhdmV9XHJcbiAgICAgICAgICAgID5cclxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXtgJHtjc3NDbGFzc2VzLlNVUkZBQ0V9ICR7Y3NzQ2xhc3Nlcy5TVVJGQUNFX0FOSU1BVElPTn1gfT5cclxuICAgICAgICAgICAgICAgICAgICB7dGl0bGUgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgPGgyIGNsYXNzTmFtZT17Y3NzQ2xhc3Nlcy5USVRMRX0+e3RpdGxlfTwvaDI+XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICB7Y29udGVudCAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8cCBjbGFzc05hbWU9e2Nzc0NsYXNzZXMuQ09OVEVOVH0+e2NvbnRlbnR9PC9wPlxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAge2FjdGlvbnMgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9e2Nzc0NsYXNzZXMuQUNUSU9OU30+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7Q2hpbGRyZW4ubWFwKGFjdGlvbnMsIGFjdGlvbiA9PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxDbG9uZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21wb25lbnQ9e2FjdGlvbn1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJpYS1sYWJlbD1cImFjdGlvblwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLz5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICl9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICA8L0VsZW1lbnQ+XHJcbiAgICAgICAgPC9MYXllcj5cclxuICAgIDwvPik7XHJcbn0pO1xyXG5cclxuUmljaFRvb2x0aXAuZGlzcGxheU5hbWUgPSAnTURDUmljaFRvb2x0aXAnO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgUmljaFRvb2x0aXA7IiwiZXhwb3J0IHsgZGVmYXVsdCBhcyBUb29sdGlwIH0gZnJvbSAnLi9Ub29sdGlwJztcclxuZXhwb3J0IHsgZGVmYXVsdCBhcyBSaWNoVG9vbHRpcCB9IGZyb20gJy4vUmljaFRvb2x0aXAnOyIsImV4cG9ydCBjb25zdCBjc3NDbGFzc2VzID0ge1xyXG4gICAgUk9PVDogJ21kYy10ZXh0LWZpZWxkJyxcclxuICAgIEZJTExFRDogJ21kYy10ZXh0LWZpZWxkLS1maWxsZWQnLFxyXG4gICAgT1VUTElORUQ6ICdtZGMtdGV4dC1maWVsZC0tb3V0bGluZWQnLFxyXG4gICAgVEVYVEFSRUE6ICdtZGMtdGV4dC1maWVsZC0tdGV4dGFyZWEnLFxyXG4gICAgRElTQUJMRUQ6ICdtZGMtdGV4dC1maWVsZC0tZGlzYWJsZWQnLFxyXG4gICAgRk9DVVNFRDogJ21kYy10ZXh0LWZpZWxkLS1mb2N1c2VkJyxcclxuICAgIElOVkFMSUQ6ICdtZGMtdGV4dC1maWVsZC0taW52YWxpZCcsXHJcbiAgICBMQUJFTF9GTE9BVElORzogJ21kYy10ZXh0LWZpZWxkLS1sYWJlbC1mbG9hdGluZycsXHJcbiAgICBOT19MQUJFTDogJ21kYy10ZXh0LWZpZWxkLS1uby1sYWJlbCcsXHJcbiAgICBFTkRfQUxJR05FRDogJ21kYy10ZXh0LWZpZWxkLS1lbmQtYWxpZ25lZCcsXHJcbiAgICBXSVRIX0xFQURJTkdfSUNPTjogJ21kYy10ZXh0LWZpZWxkLS13aXRoLWxlYWRpbmctaWNvbicsXHJcbiAgICBXSVRIX1RSQUlMSU5HX0lDT046ICdtZGMtdGV4dC1maWVsZC0td2l0aC10cmFpbGluZy1pY29uJyxcclxuICAgIFdJVEhfSU5URVJOQUxfQ09VTlRFUjogJ21kYy10ZXh0LWZpZWxkLS13aXRoLWludGVybmFsLWNvdW50ZXInLFxyXG5cclxuICAgIElDT046ICdtZGMtdGV4dC1maWVsZF9faWNvbicsXHJcbiAgICBJQ09OX0xFQURJTkc6ICdtZGMtdGV4dC1maWVsZF9faWNvbi0tbGVhZGluZycsXHJcbiAgICBJQ09OX1RSQUlMSU5HOiAnbWRjLXRleHQtZmllbGRfX2ljb24tLXRyYWlsaW5nJyxcclxuXHJcbiAgICBJTlBVVDogJ21kYy10ZXh0LWZpZWxkX19pbnB1dCcsXHJcblxyXG4gICAgQUZGSVg6ICdtZGMtdGV4dC1maWVsZF9fYWZmaXgnLFxyXG4gICAgQUZGSVhfUFJFRklYOiAnbWRjLXRleHQtZmllbGRfX2FmZml4LS1wcmVmaXgnLFxyXG4gICAgQUZGSVhfU1VGRklYOiAnbWRjLXRleHQtZmllbGRfX2FmZml4LS1zdWZmaXgnLFxyXG5cclxuICAgIFJFU0laRVI6ICdtZGMtdGV4dC1maWVsZF9fcmVzaXplcicsXHJcblxyXG4gICAgUklQUExFOiAnbWRjLXRleHQtZmllbGRfX3JpcHBsZScsXHJcblxyXG4gICAgSEVMUEVSX0xJTkU6ICdtZGMtdGV4dC1maWVsZC1oZWxwZXItbGluZScsXHJcbiAgICBIRUxQRVJfVEVYVDogJ21kYy10ZXh0LWZpZWxkLWhlbHBlci10ZXh0JyxcclxuICAgIEhFTFBFUl9URVhUX1BFUlNJU1RFTlQ6ICdtZGMtdGV4dC1maWVsZC1oZWxwZXItdGV4dC0tcGVyc2lzdGVudCcsXHJcbiAgICBIRUxQRVJfVEVYVF9WQUxJREFUSU9OOiAnbWRjLXRleHQtZmllbGQtaGVscGVyLXRleHQtLXZhbGlkYXRpb24tbXNnJyxcclxuXHJcbiAgICBDSEFSQUNURVJfQ09VTlRFUjogJ21kYy10ZXh0LWZpZWxkLWNoYXJhY3Rlci1jb3VudGVyJyxcclxufTsiLCJpbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xyXG5pbXBvcnQgY2xhc3NuYW1lcyBmcm9tICdjbGFzc25hbWVzJztcclxuXHJcbmltcG9ydCB7IGNzc0NsYXNzZXMgfSBmcm9tICcuL2NvbnN0YW50cyc7XHJcblxyXG5jb25zdCBIZWxwZXJUZXh0ID0gKHtcclxuICAgIHBlcnNpc3RlbnQgPSBmYWxzZSxcclxuICAgIHZhbGlkYXRpb24gPSBmYWxzZSxcclxuXHJcbiAgICAuLi5wcm9wc1xyXG59KSA9PiB7XHJcbiAgICBjb25zdCBjbGFzc05hbWVzID0gY2xhc3NuYW1lcyhjc3NDbGFzc2VzLkhFTFBFUl9URVhULCB7XHJcbiAgICAgICAgW2Nzc0NsYXNzZXMuSEVMUEVSX1RFWFRfUEVSU0lTVEVOVF06IHBlcnNpc3RlbnQsXHJcbiAgICAgICAgW2Nzc0NsYXNzZXMuSEVMUEVSX1RFWFRfVkFMSURBVElPTl06IHZhbGlkYXRpb25cclxuICAgIH0pO1xyXG5cclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgPGRpdiBjbGFzc05hbWU9e2NsYXNzTmFtZXN9IHsuLi5wcm9wc30gLz5cclxuICAgICk7XHJcbn07XHJcblxyXG5IZWxwZXJUZXh0LmRpc3BsYXlOYW1lID0gJ01EQ1RleHRGaWVsZEhlbHBlclRleHQnO1xyXG5cclxuSGVscGVyVGV4dC5wcm9wVHlwZXMgPSB7XHJcbiAgICBwZXJzaXN0ZW50OiBQcm9wVHlwZXMuYm9vbCxcclxuICAgIHZhbGlkYXRpb246IFByb3BUeXBlcy5ib29sXHJcbn07XHJcblxyXG5leHBvcnQgZGVmYXVsdCBIZWxwZXJUZXh0OyIsImltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBDaGFyYWN0ZXJDb3VudGVyKHtcclxuICAgIHZhbHVlID0gMCxcclxuICAgIG1heFZhbHVlLFxyXG5cclxuICAgIC4uLnByb3BzXHJcbn0pIHtcclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJtZGMtdGV4dC1maWVsZC1jaGFyYWN0ZXItY291bnRlclwiIHsuLi5wcm9wc30+XHJcbiAgICAgICAgICAgIHt2YWx1ZSArIChtYXhWYWx1ZSA/IGAgLyAke21heFZhbHVlfWAgOiAnJyl9XHJcbiAgICAgICAgPC9kaXY+XHJcbiAgICApO1xyXG59XHJcblxyXG5DaGFyYWN0ZXJDb3VudGVyLmRpc3BsYXlOYW1lID0gJ01EQ1RleHRGaWVsZENoYXJhY3RlckNvdW50ZXInO1xyXG5cclxuQ2hhcmFjdGVyQ291bnRlci5wcm9wVHlwZXMgPSB7XHJcbiAgICB2YWx1ZTogUHJvcFR5cGVzLm51bWJlcixcclxuICAgIG1heFZhbHVlOiBQcm9wVHlwZXMubnVtYmVyXHJcbn07IiwiaW1wb3J0IHsgZm9yd2FyZFJlZiwgdXNlTGF5b3V0RWZmZWN0IH0gZnJvbSAncmVhY3QnO1xyXG5cclxuaW1wb3J0IHsgY3NzQ2xhc3NlcyB9IGZyb20gJy4vY29uc3RhbnRzJztcclxuXHJcbmNvbnN0IElucHV0ID0gZm9yd2FyZFJlZigoe1xyXG4gICAgdGV4dGFyZWEsXHJcbiAgICBhdXRvUmVzaXplLFxyXG4gICAgZWxlbWVudDogRWxlbWVudCA9IHRleHRhcmVhID8gJ3RleHRhcmVhJyA6ICdpbnB1dCcsXHJcbiAgICAuLi5wcm9wc1xyXG59LCByZWYpID0+IHtcclxuICAgIHVzZUxheW91dEVmZmVjdCgoKSA9PiB7XHJcbiAgICAgICAgaWYgKCFhdXRvUmVzaXplKSByZXR1cm47XHJcblxyXG4gICAgICAgIGNvbnN0IGVsZW1lbnQgPSByZWYuY3VycmVudDtcclxuXHJcbiAgICAgICAgZnVuY3Rpb24gc2V0SGVpZ2h0KCkge1xyXG4gICAgICAgICAgICBlbGVtZW50LnN0eWxlLmhlaWdodCA9ICcxcmVtJztcclxuICAgICAgICAgICAgZWxlbWVudC5zdHlsZS5oZWlnaHQgPSBgJHtlbGVtZW50LnNjcm9sbEhlaWdodH1weGA7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBzZXRIZWlnaHQoKTtcclxuXHJcbiAgICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdpbnB1dCcsIHNldEhlaWdodCk7XHJcblxyXG4gICAgICAgIHJldHVybiAoKSA9PiBlbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2lucHV0Jywgc2V0SGVpZ2h0KTtcclxuICAgIH0sIFthdXRvUmVzaXplLCByZWZdKTtcclxuXHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAgIDxFbGVtZW50XHJcbiAgICAgICAgICAgIHJlZj17cmVmfVxyXG4gICAgICAgICAgICBjbGFzc05hbWU9e2Nzc0NsYXNzZXMuSU5QVVR9XHJcbiAgICAgICAgICAgIHsuLi5wcm9wc31cclxuICAgICAgICAvPlxyXG4gICAgKTtcclxufSk7XHJcblxyXG5JbnB1dC5kaXNwbGF5TmFtZSA9ICdNRENUZXh0RmllbGRJbnB1dCc7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBJbnB1dDsiLCJpbXBvcnQgeyBjc3NDbGFzc2VzIH0gZnJvbSAnLi9jb25zdGFudHMnO1xyXG5cclxuY29uc3QgUmVzaXplciA9ICh7XHJcbiAgICB0ZXh0YXJlYSxcclxuICAgIGF1dG9SZXNpemUsXHJcbiAgICBjaGlsZHJlbixcclxuICAgIC4uLnByb3BzXHJcbn0pID0+IHtcclxuICAgIHJldHVybiAodGV4dGFyZWEgJiYgIWF1dG9SZXNpemUpID8gKFxyXG4gICAgICAgIDxzcGFuIGNsYXNzTmFtZT17Y3NzQ2xhc3Nlcy5SRVNJWkVSfSB7Li4ucHJvcHN9PlxyXG4gICAgICAgICAgICB7Y2hpbGRyZW59XHJcbiAgICAgICAgPC9zcGFuPlxyXG4gICAgKSA6IGNoaWxkcmVuO1xyXG59O1xyXG5cclxuUmVzaXplci5kaXNwbGF5TmFtZSA9ICdNRENUZXh0RmllbGRSZXNpemVyJztcclxuXHJcbmV4cG9ydCBkZWZhdWx0IFJlc2l6ZXI7IiwiaW1wb3J0IHsgZm9yd2FyZFJlZiwgdXNlUmVmLCB1c2VTdGF0ZSwgdXNlQ2FsbGJhY2sgfSBmcm9tICdyZWFjdCc7XHJcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XHJcbmltcG9ydCBjbGFzc25hbWVzIGZyb20gJ2NsYXNzbmFtZXMnO1xyXG5cclxuaW1wb3J0IHsgQ2xvbmUgfSBmcm9tICcuLi9jb21wb25lbnQnO1xyXG5pbXBvcnQgTm90Y2hlZE91dGxpbmUgZnJvbSAnLi4vbm90Y2hlZC1vdXRsaW5lJztcclxuaW1wb3J0IExpbmVSaXBwbGUgZnJvbSAnLi4vbGluZS1yaXBwbGUnO1xyXG5pbXBvcnQgRmxvYXRpbmdMYWJlbCBmcm9tICcuLi9mbG9hdGluZy1sYWJlbCc7XHJcbmltcG9ydCBJY29uIGZyb20gJy4uL2ljb24nO1xyXG5cclxuaW1wb3J0IHsgY3NzQ2xhc3NlcyB9IGZyb20gJy4vY29uc3RhbnRzJztcclxuaW1wb3J0IEhlbHBlclRleHQgZnJvbSAnLi9IZWxwZXJUZXh0JztcclxuaW1wb3J0IENoYXJhY3RlckNvdW50ZXIgZnJvbSAnLi9DaGFyYWN0ZXJDb3VudGVyJztcclxuaW1wb3J0IElucHV0IGZyb20gJy4vSW5wdXQnO1xyXG5pbXBvcnQgUmVzaXplciBmcm9tICcuL1Jlc2l6ZXInO1xyXG5cclxuY29uc3QgVGV4dEZpZWxkID0gZm9yd2FyZFJlZigoe1xyXG4gICAgdmFsdWUsXHJcbiAgICBkZWZhdWx0VmFsdWUsXHJcbiAgICBsYWJlbCxcclxuICAgIGxlYWRpbmdJY29uLFxyXG4gICAgdHJhaWxpbmdJY29uLFxyXG4gICAgcHJlZml4LFxyXG4gICAgc3VmZml4LFxyXG4gICAgcGVyc2lzdGVudEhlbHBlclRleHQsXHJcbiAgICBoZWxwZXJUZXh0ID0gcGVyc2lzdGVudEhlbHBlclRleHQsXHJcbiAgICB2YWxpZGF0aW9uTWVzc2FnZSxcclxuICAgIGZpbGxlZCA9IGZhbHNlLFxyXG4gICAgb3V0bGluZWQgPSBmYWxzZSxcclxuICAgIGZ1bGxXaWR0aCA9IGZhbHNlLFxyXG4gICAgZGlzYWJsZWQgPSBmYWxzZSxcclxuICAgIHRleHRhcmVhID0gZmFsc2UsXHJcbiAgICBlbmRBbGlnbmVkID0gZmFsc2UsXHJcbiAgICBhdXRvUmVzaXplID0gZmFsc2UsXHJcbiAgICBjaGFyYWN0ZXJDb3VudGVyID0gZmFsc2UsXHJcbiAgICBpbnRlcm5hbENoYXJhY3RlckNvdW50ZXIgPSBjaGFyYWN0ZXJDb3VudGVyID09PSAnaW50ZXJuYWwnLFxyXG5cclxuICAgIGNsYXNzTmFtZSxcclxuICAgIGVsZW1lbnQ6IEVsZW1lbnQgPSAnbGFiZWwnLFxyXG4gICAgb25Gb2N1cyA9IEZ1bmN0aW9uLnByb3RvdHlwZSxcclxuICAgIG9uQmx1ciA9IEZ1bmN0aW9uLnByb3RvdHlwZSxcclxuICAgIG9uQ2hhbmdlID0gRnVuY3Rpb24ucHJvdG90eXBlLFxyXG4gICAgLi4ucHJvcHNcclxufSwgcmVmKSA9PiB7XHJcbiAgICBjb25zdCBpbnB1dFJlZiA9IHVzZVJlZigpO1xyXG5cclxuICAgIGNvbnN0IFtmb2N1c2VkLCBzZXRGb2N1c2VkXSA9IHVzZVN0YXRlKGZhbHNlKTtcclxuICAgIGNvbnN0IFt0b3VjaGVkLCBzZXRUb3VjaGVkXSA9IHVzZVN0YXRlKGZhbHNlKTtcclxuICAgIGNvbnN0IFt2YWxpZCwgc2V0VmFsaWRdID0gdXNlU3RhdGUodHJ1ZSk7XHJcbiAgICBjb25zdCBbaW50ZXJhY3Rpb25Db29yZHMsIHNldEludGVyYWN0aW9uQ29vcmRzXSA9IHVzZVN0YXRlKCk7XHJcbiAgICBjb25zdCBbY291bnQsIHNldENvdW50XSA9IHVzZVN0YXRlKHZhbHVlPy5sZW5ndGggfHwgZGVmYXVsdFZhbHVlPy52YWx1ZSB8fCAwKTtcclxuXHJcbiAgICBjb25zdCBoYW5kbGVJbnRlcmFjdGlvbiA9IHVzZUNhbGxiYWNrKGV2ZW50ID0+IHtcclxuICAgICAgICBjb25zdCB0YXJnZXRDbGllbnRSZWN0ID0gZXZlbnQudGFyZ2V0LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xyXG5cclxuICAgICAgICBzZXRJbnRlcmFjdGlvbkNvb3Jkcyh7XHJcbiAgICAgICAgICAgIHg6IGV2ZW50LmNsaWVudFggLSB0YXJnZXRDbGllbnRSZWN0LmxlZnQsXHJcbiAgICAgICAgICAgIHk6IGV2ZW50LmNsaWVudFkgLSB0YXJnZXRDbGllbnRSZWN0LnRvcFxyXG4gICAgICAgIH0pO1xyXG4gICAgfSwgW10pO1xyXG5cclxuICAgIGNvbnN0IGhhbmRsZUlucHV0Rm9jdXMgPSB1c2VDYWxsYmFjayhldmVudCA9PiB7XHJcbiAgICAgICAgc2V0Rm9jdXNlZCh0cnVlKTtcclxuICAgICAgICBzZXRUb3VjaGVkKHRydWUpO1xyXG4gICAgICAgIG9uRm9jdXMoZXZlbnQpO1xyXG4gICAgfSwgW29uRm9jdXNdKTtcclxuXHJcbiAgICBjb25zdCBoYW5kbGVJbnB1dEJsdXIgPSB1c2VDYWxsYmFjayhldmVudCA9PiB7XHJcbiAgICAgICAgc2V0Rm9jdXNlZChmYWxzZSk7XHJcbiAgICAgICAgc2V0SW50ZXJhY3Rpb25Db29yZHMoKTtcclxuICAgICAgICBvbkJsdXIoZXZlbnQpO1xyXG4gICAgfSwgW29uQmx1cl0pO1xyXG5cclxuICAgIGNvbnN0IGhhbmRsZUlucHV0Q2hhbmdlID0gdXNlQ2FsbGJhY2soZXZlbnQgPT4ge1xyXG4gICAgICAgIGNvbnN0IHZhbHVlID0gaW5wdXRSZWYuY3VycmVudC52YWx1ZTtcclxuICAgICAgICBjb25zdCBpc1ZhbGlkID0gaW5wdXRSZWYuY3VycmVudD8udmFsaWRpdHkudmFsaWQ7XHJcblxyXG4gICAgICAgIHNldENvdW50KHZhbHVlLmxlbmd0aCk7XHJcbiAgICAgICAgc2V0VmFsaWQoaXNWYWxpZCk7XHJcbiAgICAgICAgb25DaGFuZ2UoZXZlbnQsIHZhbHVlKTtcclxuICAgIH0sIFtvbkNoYW5nZV0pO1xyXG5cclxuICAgIGNvbnN0IGZvY3VzZWRPckhhc1ZhbHVlID0gKFxyXG4gICAgICAgIGZvY3VzZWQgfHxcclxuICAgICAgICAodmFsdWUgIT09IHVuZGVmaW5lZCAmJiB2YWx1ZSAhPT0gbnVsbCAmJiB2YWx1ZSAhPT0gJycpIHx8XHJcbiAgICAgICAgKGRlZmF1bHRWYWx1ZSAhPT0gdW5kZWZpbmVkICYmIGRlZmF1bHRWYWx1ZSAhPT0gbnVsbCAmJiBkZWZhdWx0VmFsdWUgIT09ICcnKSB8fFxyXG4gICAgICAgIEJvb2xlYW4oaW5wdXRSZWYuY3VycmVudD8udmFsdWUpXHJcbiAgICApO1xyXG5cclxuICAgIGNvbnN0IGhhc0hlbHBlckxpbmUgPSBoZWxwZXJUZXh0IHx8IHZhbGlkYXRpb25NZXNzYWdlIHx8IGNoYXJhY3RlckNvdW50ZXI7XHJcblxyXG4gICAgY29uc3QgY2xhc3NOYW1lcyA9IGNsYXNzbmFtZXMoY3NzQ2xhc3Nlcy5ST09ULCB7XHJcbiAgICAgICAgW2Nzc0NsYXNzZXMuRklMTEVEXTogZmlsbGVkICYmICFmdWxsV2lkdGgsXHJcbiAgICAgICAgW2Nzc0NsYXNzZXMuT1VUTElORURdOiBvdXRsaW5lZCAmJiAhZnVsbFdpZHRoLFxyXG4gICAgICAgIFtjc3NDbGFzc2VzLlRFWFRBUkVBXTogdGV4dGFyZWEsXHJcbiAgICAgICAgW2Nzc0NsYXNzZXMuRElTQUJMRURdOiBkaXNhYmxlZCxcclxuICAgICAgICBbY3NzQ2xhc3Nlcy5GT0NVU0VEXTogZm9jdXNlZCxcclxuICAgICAgICBbY3NzQ2xhc3Nlcy5JTlZBTElEXTogIXZhbGlkICYmIHRvdWNoZWQsXHJcbiAgICAgICAgW2Nzc0NsYXNzZXMuTEFCRUxfRkxPQVRJTkddOiBmb2N1c2VkT3JIYXNWYWx1ZSxcclxuICAgICAgICBbY3NzQ2xhc3Nlcy5OT19MQUJFTF06ICFsYWJlbCxcclxuICAgICAgICBbY3NzQ2xhc3Nlcy5FTkRfQUxJR05FRF06IGVuZEFsaWduZWQsXHJcbiAgICAgICAgW2Nzc0NsYXNzZXMuV0lUSF9MRUFESU5HX0lDT05dOiBsZWFkaW5nSWNvbixcclxuICAgICAgICBbY3NzQ2xhc3Nlcy5XSVRIX1RSQUlMSU5HX0lDT05dOiB0cmFpbGluZ0ljb24sXHJcbiAgICAgICAgW2Nzc0NsYXNzZXMuV0lUSF9JTlRFUk5BTF9DT1VOVEVSXTogaW50ZXJuYWxDaGFyYWN0ZXJDb3VudGVyXHJcbiAgICB9LCBjbGFzc05hbWUpO1xyXG5cclxuICAgIHJldHVybiAoPD5cclxuICAgICAgICA8RWxlbWVudFxyXG4gICAgICAgICAgICByZWY9e3JlZn1cclxuICAgICAgICAgICAgY2xhc3NOYW1lPXtjbGFzc05hbWVzfVxyXG4gICAgICAgICAgICBvbk1vdXNlRG93bj17aGFuZGxlSW50ZXJhY3Rpb259XHJcbiAgICAgICAgICAgIG9uVG91Y2hTdGFydD17aGFuZGxlSW50ZXJhY3Rpb259XHJcbiAgICAgICAgPlxyXG4gICAgICAgICAgICB7ZmlsbGVkICYmXHJcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17Y3NzQ2xhc3Nlcy5SSVBQTEV9IC8+XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHtmaWxsZWQgJiYgbGFiZWwgJiZcclxuICAgICAgICAgICAgICAgIDxGbG9hdGluZ0xhYmVsXHJcbiAgICAgICAgICAgICAgICAgICAgbGFiZWw9e2xhYmVsfVxyXG4gICAgICAgICAgICAgICAgICAgIGZsb2F0PXtmb2N1c2VkT3JIYXNWYWx1ZX1cclxuICAgICAgICAgICAgICAgIC8+XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHtvdXRsaW5lZCAmJlxyXG4gICAgICAgICAgICAgICAgPE5vdGNoZWRPdXRsaW5lIG5vdGNoZWQ9e2ZvY3VzZWRPckhhc1ZhbHVlfT5cclxuICAgICAgICAgICAgICAgICAgICB7bGFiZWwgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgPEZsb2F0aW5nTGFiZWxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsPXtsYWJlbH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZsb2F0PXtmb2N1c2VkT3JIYXNWYWx1ZX1cclxuICAgICAgICAgICAgICAgICAgICAgICAgLz5cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICA8L05vdGNoZWRPdXRsaW5lPlxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB7bGVhZGluZ0ljb24gJiZcclxuICAgICAgICAgICAgICAgIDxDbG9uZVxyXG4gICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudD17bGVhZGluZ0ljb259XHJcbiAgICAgICAgICAgICAgICAgICAgZmFsbGJhY2s9e0ljb259XHJcbiAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPXtgJHtjc3NDbGFzc2VzLklDT059ICR7Y3NzQ2xhc3Nlcy5JQ09OX0xFQURJTkd9YH1cclxuICAgICAgICAgICAgICAgICAgICB0YWJJbmRleD1cIjBcIlxyXG4gICAgICAgICAgICAgICAgICAgIHJvbGU9XCJidXR0b25cIlxyXG4gICAgICAgICAgICAgICAgLz5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAge3ByZWZpeCAmJlxyXG4gICAgICAgICAgICAgICAgPHNwYW4gY2xhc3NOYW1lPXtgJHtjc3NDbGFzc2VzLkFGRklYfSAke2Nzc0NsYXNzZXMuQUZGSVhfUFJFRklYfWB9PntwcmVmaXh9PC9zcGFuPlxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICA8UmVzaXplclxyXG4gICAgICAgICAgICAgICAgdGV4dGFyZWE9e3RleHRhcmVhfVxyXG4gICAgICAgICAgICAgICAgYXV0b1Jlc2l6ZT17YXV0b1Jlc2l6ZX1cclxuICAgICAgICAgICAgPlxyXG4gICAgICAgICAgICAgICAgPElucHV0XHJcbiAgICAgICAgICAgICAgICAgICAgcmVmPXtpbnB1dFJlZn1cclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZT17dmFsdWV9XHJcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdFZhbHVlPXtkZWZhdWx0VmFsdWV9XHJcbiAgICAgICAgICAgICAgICAgICAgdGV4dGFyZWE9e3RleHRhcmVhfVxyXG4gICAgICAgICAgICAgICAgICAgIGF1dG9SZXNpemU9e2F1dG9SZXNpemV9XHJcbiAgICAgICAgICAgICAgICAgICAgZGlzYWJsZWQ9e2Rpc2FibGVkfVxyXG4gICAgICAgICAgICAgICAgICAgIG9uSW5wdXQ9e2hhbmRsZUlucHV0Q2hhbmdlfVxyXG4gICAgICAgICAgICAgICAgICAgIG9uRm9jdXM9e2hhbmRsZUlucHV0Rm9jdXN9XHJcbiAgICAgICAgICAgICAgICAgICAgb25CbHVyPXtoYW5kbGVJbnB1dEJsdXJ9XHJcbiAgICAgICAgICAgICAgICAgICAgey4uLnByb3BzfVxyXG4gICAgICAgICAgICAgICAgLz5cclxuXHJcbiAgICAgICAgICAgICAgICB7aW50ZXJuYWxDaGFyYWN0ZXJDb3VudGVyICYmXHJcbiAgICAgICAgICAgICAgICAgICAgPENoYXJhY3RlckNvdW50ZXJcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU9e2NvdW50fVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXhWYWx1ZT17cHJvcHMubWF4TGVuZ3RofVxyXG4gICAgICAgICAgICAgICAgICAgIC8+XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIDwvUmVzaXplcj5cclxuXHJcbiAgICAgICAgICAgIHtzdWZmaXggJiZcclxuICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT17YCR7Y3NzQ2xhc3Nlcy5BRkZJWH0gJHtjc3NDbGFzc2VzLkFGRklYX1NVRkZJWH1gfT57c3VmZml4fTwvc3Bhbj5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAge3RyYWlsaW5nSWNvbiAmJlxyXG4gICAgICAgICAgICAgICAgPENsb25lXHJcbiAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50PXt0cmFpbGluZ0ljb259XHJcbiAgICAgICAgICAgICAgICAgICAgZmFsbGJhY2s9e0ljb259XHJcbiAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPXtgJHtjc3NDbGFzc2VzLklDT059ICR7Y3NzQ2xhc3Nlcy5JQ09OX1RSQUlMSU5HfWB9XHJcbiAgICAgICAgICAgICAgICAgICAgdGFiSW5kZXg9XCIwXCJcclxuICAgICAgICAgICAgICAgICAgICByb2xlPVwiYnV0dG9uXCJcclxuICAgICAgICAgICAgICAgIC8+XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHtmaWxsZWQgJiZcclxuICAgICAgICAgICAgICAgIDxMaW5lUmlwcGxlXHJcbiAgICAgICAgICAgICAgICAgICAgYWN0aXZlPXtmb2N1c2VkfVxyXG4gICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybU9yaWdpbj17aW50ZXJhY3Rpb25Db29yZHM/Lnh9XHJcbiAgICAgICAgICAgICAgICAvPlxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgPC9FbGVtZW50PlxyXG5cclxuICAgICAgICB7aGFzSGVscGVyTGluZSAmJlxyXG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17Y3NzQ2xhc3Nlcy5IRUxQRVJfTElORX0+XHJcbiAgICAgICAgICAgICAgICB7aGVscGVyVGV4dCAmJlxyXG4gICAgICAgICAgICAgICAgICAgIDxIZWxwZXJUZXh0IHBlcnNpc3RlbnQ9e0Jvb2xlYW4ocGVyc2lzdGVudEhlbHBlclRleHQpfT57aGVscGVyVGV4dH08L0hlbHBlclRleHQ+XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgeyh2YWxpZGF0aW9uTWVzc2FnZSAmJiAhdmFsaWQpICYmXHJcbiAgICAgICAgICAgICAgICAgICAgPEhlbHBlclRleHQgdmFsaWRhdGlvbj57dHlwZW9mIHZhbGlkYXRpb25NZXNzYWdlID09PSAnc3RyaW5nJyA/IHZhbGlkYXRpb25NZXNzYWdlIDogaW5wdXRSZWYuY3VycmVudD8udmFsaWRhdGlvbk1lc3NhZ2V9PC9IZWxwZXJUZXh0PlxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHsoY2hhcmFjdGVyQ291bnRlciAmJiAhaW50ZXJuYWxDaGFyYWN0ZXJDb3VudGVyKSAmJlxyXG4gICAgICAgICAgICAgICAgICAgIDxDaGFyYWN0ZXJDb3VudGVyXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlPXtjb3VudH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgbWF4VmFsdWU9e3Byb3BzLm1heExlbmd0aH1cclxuICAgICAgICAgICAgICAgICAgICAvPlxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICB9XHJcbiAgICA8Lz4pO1xyXG59KTtcclxuXHJcblRleHRGaWVsZC5kaXNwbGF5TmFtZSA9ICdNRENUZXh0RmllbGQnO1xyXG5cclxuVGV4dEZpZWxkLnByb3BUeXBlcyA9IHtcclxuICAgIHZhbHVlOiBQcm9wVHlwZXMuYW55LFxyXG4gICAgbGFiZWw6IFByb3BUeXBlcy5zdHJpbmcsXHJcbiAgICBsZWFkaW5nSWNvbjogUHJvcFR5cGVzLm5vZGUsXHJcbiAgICB0cmFpbGluZ0ljb246IFByb3BUeXBlcy5ub2RlLFxyXG4gICAgcHJlZml4OiBQcm9wVHlwZXMuc3RyaW5nLFxyXG4gICAgc3VmZml4OiBQcm9wVHlwZXMuc3RyaW5nLFxyXG4gICAgb3V0bGluZTogUHJvcFR5cGVzLmJvb2wsXHJcbiAgICBmdWxsV2lkdGg6IFByb3BUeXBlcy5ib29sLFxyXG4gICAgdGV4dGFyZWE6IFByb3BUeXBlcy5ib29sLFxyXG4gICAgZGVuc2U6IFByb3BUeXBlcy5ib29sLFxyXG4gICAgZGlzYWJsZWQ6IFByb3BUeXBlcy5ib29sLFxyXG4gICAgaGVscGVyVGV4dDogUHJvcFR5cGVzLnN0cmluZyxcclxuICAgIHBlcnNpc3RlbnRIZWxwZXJUZXh0OiBQcm9wVHlwZXMuc3RyaW5nLFxyXG4gICAgdmFsaWRhdGlvbk1lc3NhZ2U6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5ib29sLCBQcm9wVHlwZXMuc3RyaW5nXSlcclxufTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IFRleHRGaWVsZDsiLCJleHBvcnQgeyBkZWZhdWx0IH0gZnJvbSAnLi9UZXh0RmllbGQnOyIsImV4cG9ydCBjb25zdCBudW1iZXJzID0ge1xyXG4gICAgREVCT1VOQ0VfVEhST1RUTEVfUkVTSVpFX1RJTUVfTVM6IDEwMCxcclxuICAgIE1BWF9UT1BfQVBQX0JBUl9IRUlHSFQ6IDEyOFxyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IGNzc0NsYXNzZXMgPSB7XHJcbiAgICBST09UOiAnbWRjLXRvcC1hcHAtYmFyJyxcclxuICAgIEZJWEVEOiAnbWRjLXRvcC1hcHAtYmFyLS1maXhlZCcsXHJcbiAgICBGSVhFRF9TQ1JPTExFRDogJ21kYy10b3AtYXBwLWJhci0tZml4ZWQtc2Nyb2xsZWQnLFxyXG4gICAgRklYRURfQURKVVNUOiAnbWRjLXRvcC1hcHAtYmFyLS1maXhlZC1hZGp1c3QnLFxyXG4gICAgUFJPTUlORU5UOiAnbWRjLXRvcC1hcHAtYmFyLS1wcm9taW5lbnQnLFxyXG4gICAgUFJPTUlORU5UX0ZJWEVEX0FESlVTVDogJ21kYy10b3AtYXBwLWJhci0tcHJvbWluZW50LWZpeGVkLWFkanVzdCcsXHJcbiAgICBERU5TRTogJ21kYy10b3AtYXBwLWJhci0tZGVuc2UnLFxyXG4gICAgREVOU0VfRklYRURfQURKVVNUOiAnbWRjLXRvcC1hcHAtYmFyLS1kZW5zZS1maXhlZC1hZGp1c3QnLFxyXG4gICAgREVOU0VfUFJPTUlORU5UX0ZJWEVEX0FESlVTVDogJ21kYy10b3AtYXBwLWJhci0tZGVuc2UtcHJvbWluZW50LWZpeGVkLWFkanVzdCcsXHJcbiAgICBTSE9SVDogJ21kYy10b3AtYXBwLWJhci0tc2hvcnQnLFxyXG4gICAgU0hPUlRfQ09MTEFQU0VEOiAnbWRjLXRvcC1hcHAtYmFyLS1zaG9ydC1jb2xsYXBzZWQnLFxyXG4gICAgU0hPUlRfRklYRURfQURKVVNUOiAnbWRjLXRvcC1hcHAtYmFyLS1zaG9ydC1maXhlZC1hZGp1c3QnLFxyXG4gICAgU1RJQ0tZOiAnbWRjLXRvcC1hcHAtYmFyLS1zdGlja3knLFxyXG4gICAgU1RJQ0tZX0hJRERFTjogJ21kYy10b3AtYXBwLWJhci0tc3RpY2t5LWhpZGRlbicsXHJcbiAgICBTVElDS1lfU0hPV046ICdtZGMtdG9wLWFwcC1iYXItLXN0aWNreS1zaG93bicsXHJcbiAgICBSQUlTRUQ6ICdtZGMtdG9wLWFwcC1iYXItLXJhaXNlZCcsXHJcblxyXG4gICAgUk9XOiAnbWRjLXRvcC1hcHAtYmFyX19yb3cnLFxyXG5cclxuICAgIFNFQ1RJT046ICdtZGMtdG9wLWFwcC1iYXJfX3NlY3Rpb24nLFxyXG4gICAgU0VDVElPTl9BTElHTl9TVEFSVDogJ21kYy10b3AtYXBwLWJhcl9fc2VjdGlvbi0tYWxpZ24tc3RhcnQnLFxyXG4gICAgU0VDVElPTl9BTElHTl9DRU5URVI6ICdtZGMtdG9wLWFwcC1iYXJfX3NlY3Rpb24tLWFsaWduLWNlbnRlcicsXHJcbiAgICBTRUNUSU9OX0FMSUdOX0VORDogJ21kYy10b3AtYXBwLWJhcl9fc2VjdGlvbi0tYWxpZ24tZW5kJyxcclxuXHJcbiAgICBOQVZJR0FUSU9OX0lDT046ICdtZGMtdG9wLWFwcC1iYXJfX25hdmlnYXRpb24taWNvbicsXHJcblxyXG4gICAgQUNUSU9OX0lURU06ICdtZGMtdG9wLWFwcC1iYXJfX2FjdGlvbi1pdGVtJyxcclxuXHJcbiAgICBUSVRMRTogJ21kYy10b3AtYXBwLWJhcl9fdGl0bGUnXHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgQWxpZ24gPSB7XHJcbiAgICBTVEFSVDogJ3N0YXJ0JyxcclxuICAgIENFTlRFUjogJ2NlbnRlcicsXHJcbiAgICBFTkQ6ICdlbmQnXHJcbn07IiwiaW1wb3J0IHsgZm9yd2FyZFJlZiB9IGZyb20gJ3JlYWN0JztcclxuaW1wb3J0IGNsYXNzbmFtZXMgZnJvbSAnY2xhc3NuYW1lcyc7XHJcblxyXG5pbXBvcnQgeyBjc3NDbGFzc2VzIH0gZnJvbSAnLi9jb25zdGFudHMnO1xyXG5cclxuY29uc3QgVG9wQXBwQmFyUm93ID0gZm9yd2FyZFJlZigoe1xyXG4gICAgZWxlbWVudDogRWxlbWVudCA9ICdkaXYnLFxyXG4gICAgY2xhc3NOYW1lLFxyXG4gICAgLi4ucHJvcHNcclxufSwgcmVmKSA9PiB7XHJcbiAgICBjb25zdCBjbGFzc05hbWVzID0gY2xhc3NuYW1lcyhjc3NDbGFzc2VzLlJPVywgY2xhc3NOYW1lKTtcclxuXHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAgIDxFbGVtZW50IHJlZj17cmVmfSBjbGFzc05hbWU9e2NsYXNzTmFtZXN9IHsuLi5wcm9wc30gLz5cclxuICAgICk7XHJcbn0pO1xyXG5cclxuVG9wQXBwQmFyUm93LmRpc3BsYXlOYW1lID0gJ01EQ1RvcEFwcEJhclJvdyc7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBUb3BBcHBCYXJSb3c7IiwiaW1wb3J0IHsgZm9yd2FyZFJlZiB9IGZyb20gJ3JlYWN0JztcclxuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcclxuaW1wb3J0IGNsYXNzbmFtZXMgZnJvbSAnY2xhc3NuYW1lcyc7XHJcblxyXG5pbXBvcnQgeyBjc3NDbGFzc2VzLCBBbGlnbiB9IGZyb20gJy4vY29uc3RhbnRzJztcclxuXHJcbmNvbnN0IFRvcEFwcEJhclNlY3Rpb24gPSBmb3J3YXJkUmVmKCh7XHJcbiAgICBhbGlnbixcclxuXHJcbiAgICBlbGVtZW50OiBFbGVtZW50ID0gJ3NlY3Rpb24nLFxyXG4gICAgY2xhc3NOYW1lLFxyXG4gICAgLi4ucHJvcHNcclxufSwgcmVmKSA9PiB7XHJcbiAgICBjb25zdCBjbGFzc05hbWVzID0gY2xhc3NuYW1lcyhjc3NDbGFzc2VzLlNFQ1RJT04sIHtcclxuICAgICAgICBbY3NzQ2xhc3Nlcy5TRUNUSU9OX0FMSUdOX1NUQVJUXTogYWxpZ24gPT09IEFsaWduLlNUQVJULFxyXG4gICAgICAgIFtjc3NDbGFzc2VzLlNFQ1RJT05fQUxJR05fQ0VOVEVSXTogYWxpZ24gPT09IEFsaWduLkNFTlRFUixcclxuICAgICAgICBbY3NzQ2xhc3Nlcy5TRUNUSU9OX0FMSUdOX0VORF06IGFsaWduID09PSBBbGlnbi5FTkRcclxuICAgIH0sIGNsYXNzTmFtZSk7XHJcblxyXG4gICAgcmV0dXJuIChcclxuICAgICAgICA8RWxlbWVudCByZWY9e3JlZn0gY2xhc3NOYW1lPXtjbGFzc05hbWVzfSB7Li4ucHJvcHN9IC8+XHJcbiAgICApO1xyXG59KTtcclxuXHJcblRvcEFwcEJhclNlY3Rpb24uZGlzcGxheU5hbWUgPSAnTURDVG9wQXBwQmFyU2VjdGlvbic7XHJcblxyXG5Ub3BBcHBCYXJTZWN0aW9uLnByb3BUeXBlcyA9IHtcclxuICAgIGFsaWduOiBQcm9wVHlwZXMub25lT2YoT2JqZWN0LnZhbHVlcyhBbGlnbikpXHJcbn07XHJcblxyXG5leHBvcnQgZGVmYXVsdCBUb3BBcHBCYXJTZWN0aW9uOyIsImltcG9ydCB7IGZvcndhcmRSZWYsIHVzZVJlZiwgdXNlU3RhdGUsIHVzZUVmZmVjdCwgdXNlSW1wZXJhdGl2ZUhhbmRsZSwgQ2hpbGRyZW4gfSBmcm9tICdyZWFjdCc7XHJcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XHJcbmltcG9ydCBjbGFzc25hbWVzIGZyb20gJ2NsYXNzbmFtZXMnO1xyXG5cclxuaW1wb3J0IHsgQ2xvbmUgfSBmcm9tICcuLi9jb21wb25lbnQnO1xyXG5pbXBvcnQgSWNvbkJ1dHRvbiBmcm9tICcuLi9pY29uLWJ1dHRvbic7XHJcblxyXG5pbXBvcnQgeyBjc3NDbGFzc2VzLCBBbGlnbiB9IGZyb20gJy4vY29uc3RhbnRzJztcclxuaW1wb3J0IFRvcEFwcEJhclJvdyBmcm9tICcuL1RvcEFwcEJhclJvdyc7XHJcbmltcG9ydCBUb3BBcHBCYXJTZWN0aW9uIGZyb20gJy4vVG9wQXBwQmFyU2VjdGlvbic7XHJcblxyXG5jb25zdCBUb3BBcHBCYXIgPSBmb3J3YXJkUmVmKCh7XHJcbiAgICB0aXRsZSxcclxuICAgIG5hdmlnYXRpb25JY29uLFxyXG4gICAgYWN0aW9uSXRlbXMsXHJcbiAgICBmaXhlZCA9IGZhbHNlLFxyXG4gICAgc3RpY2t5ID0gZmFsc2UsXHJcbiAgICBkZW5zZSA9IGZhbHNlLFxyXG4gICAgcHJvbWluZW50ID0gZmFsc2UsXHJcbiAgICBzaG9ydCA9IGZhbHNlLFxyXG4gICAgY29sbGFwc2VkID0gZmFsc2UsXHJcbiAgICByYWlzZWQgPSBmYWxzZSxcclxuICAgIG9uTmF2aWdhdGlvbkljb25DbGljayA9IEZ1bmN0aW9uLnByb3RvdHlwZSxcclxuXHJcbiAgICBlbGVtZW50ID0gJ2hlYWRlcicsXHJcbiAgICBjb21wb25lbnQ6IEVsZW1lbnQgPSBlbGVtZW50LFxyXG4gICAgY2xhc3NOYW1lLFxyXG4gICAgY2hpbGRyZW4sXHJcbiAgICAuLi5wcm9wc1xyXG59LCByZWYpID0+IHtcclxuICAgIGNvbnN0IHJvb3RSZWYgPSB1c2VSZWYoKTtcclxuICAgIGNvbnN0IFtzY3JvbGxlZCwgc2V0U2Nyb2xsZWRdID0gdXNlU3RhdGUoZmFsc2UpO1xyXG4gICAgY29uc3QgW2hpZGRlbiwgc2V0SGlkZGVuXSA9IHVzZVN0YXRlKGZhbHNlKTtcclxuXHJcbiAgICB1c2VJbXBlcmF0aXZlSGFuZGxlKHJlZiwgKCkgPT4gcm9vdFJlZi5jdXJyZW50KTtcclxuXHJcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgICAgIGxldCBsYXN0U2Nyb2xsUG9zaXRpb24gPSAwO1xyXG5cclxuICAgICAgICBmdW5jdGlvbiBoYW5kbGVTY3JvbGwoKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHNjcm9sbFZhbHVlID0gd2luZG93LnBhZ2VZT2Zmc2V0O1xyXG5cclxuICAgICAgICAgICAgaWYgKGZpeGVkKSB7XHJcbiAgICAgICAgICAgICAgICBzZXRTY3JvbGxlZChzY3JvbGxWYWx1ZSA+IDApO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHN0aWNreSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgY3VycmVudFNjcm9sbFBvc2l0aW9uID0gTWF0aC5tYXgoc2Nyb2xsVmFsdWUsIDApO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZGlmZiA9IGN1cnJlbnRTY3JvbGxQb3NpdGlvbiAtIGxhc3RTY3JvbGxQb3NpdGlvbjtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHNob3VsZEhpZGUgPSBkaWZmID4gMDtcclxuXHJcbiAgICAgICAgICAgICAgICBsYXN0U2Nyb2xsUG9zaXRpb24gPSBjdXJyZW50U2Nyb2xsUG9zaXRpb247XHJcblxyXG4gICAgICAgICAgICAgICAgc2V0SGlkZGVuKHNob3VsZEhpZGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgaGFuZGxlU2Nyb2xsKTtcclxuXHJcbiAgICAgICAgcmV0dXJuICgpID0+IHtcclxuICAgICAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIGhhbmRsZVNjcm9sbCk7XHJcbiAgICAgICAgfTtcclxuICAgIH0sIFtmaXhlZCwgc3RpY2t5XSk7XHJcblxyXG4gICAgY29uc3QgY2xhc3NOYW1lcyA9IGNsYXNzbmFtZXMoY3NzQ2xhc3Nlcy5ST09ULCB7XHJcbiAgICAgICAgW2Nzc0NsYXNzZXMuRklYRURdOiBmaXhlZCxcclxuICAgICAgICBbY3NzQ2xhc3Nlcy5TVElDS1ldOiBzdGlja3ksXHJcbiAgICAgICAgW2Nzc0NsYXNzZXMuREVOU0VdOiBkZW5zZSxcclxuICAgICAgICBbY3NzQ2xhc3Nlcy5QUk9NSU5FTlRdOiBwcm9taW5lbnQsXHJcbiAgICAgICAgW2Nzc0NsYXNzZXMuU0hPUlRdOiBzaG9ydCxcclxuICAgICAgICBbY3NzQ2xhc3Nlcy5TSE9SVF9DT0xMQVBTRURdOiBzaG9ydCAmJiBjb2xsYXBzZWQsXHJcbiAgICAgICAgW2Nzc0NsYXNzZXMuRklYRURfU0NST0xMRURdOiBmaXhlZCAmJiBzY3JvbGxlZCxcclxuICAgICAgICBbY3NzQ2xhc3Nlcy5TVElDS1lfSElEREVOXTogc3RpY2t5ICYmIGhpZGRlbixcclxuICAgICAgICBbY3NzQ2xhc3Nlcy5TVElDS1lfU0hPV05dOiBzdGlja3kgJiYgIWhpZGRlbixcclxuICAgICAgICBbY3NzQ2xhc3Nlcy5SQUlTRURdOiByYWlzZWRcclxuICAgIH0sIGNsYXNzTmFtZSk7XHJcblxyXG4gICAgcmV0dXJuIChcclxuICAgICAgICA8RWxlbWVudFxyXG4gICAgICAgICAgICByZWY9e3Jvb3RSZWZ9XHJcbiAgICAgICAgICAgIGNsYXNzTmFtZT17Y2xhc3NOYW1lc31cclxuICAgICAgICAgICAgey4uLnByb3BzfVxyXG4gICAgICAgID5cclxuICAgICAgICAgICAge2NoaWxkcmVuIHx8XHJcbiAgICAgICAgICAgICAgICA8VG9wQXBwQmFyUm93PlxyXG4gICAgICAgICAgICAgICAgICAgIHsodGl0bGUgfHwgbmF2aWdhdGlvbkljb24pICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxUb3BBcHBCYXJTZWN0aW9uIGFsaWduPXtBbGlnbi5TVEFSVH0+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7bmF2aWdhdGlvbkljb24gJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8Q2xvbmVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50PXtuYXZpZ2F0aW9uSWNvbn1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmFsbGJhY2s9e0ljb25CdXR0b259XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT17Y3NzQ2xhc3Nlcy5OQVZJR0FUSU9OX0lDT059XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2xpY2s9e29uTmF2aWdhdGlvbkljb25DbGlja31cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHt0aXRsZSAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxDbG9uZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21wb25lbnQ9e3RpdGxlfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmYWxsYmFjaz1cInNwYW5cIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU9e2Nzc0NsYXNzZXMuVElUTEV9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLz5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgPC9Ub3BBcHBCYXJTZWN0aW9uPlxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAge2FjdGlvbkl0ZW1zICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxUb3BBcHBCYXJTZWN0aW9uIGFsaWduPXtBbGlnbi5FTkR9PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge0NoaWxkcmVuLm1hcChhY3Rpb25JdGVtcywgaXRlbSA9PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxDbG9uZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21wb25lbnQ9e2l0ZW19XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT17Y3NzQ2xhc3Nlcy5BQ1RJT05fSVRFTX1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKX1cclxuICAgICAgICAgICAgICAgICAgICAgICAgPC9Ub3BBcHBCYXJTZWN0aW9uPlxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIDwvVG9wQXBwQmFyUm93PlxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgPC9FbGVtZW50PlxyXG4gICAgKTtcclxufSk7XHJcblxyXG5Ub3BBcHBCYXIuZGlzcGxheU5hbWUgPSAnTURDVG9wQXBwQmFyJztcclxuXHJcblRvcEFwcEJhci5wcm9wVHlwZXMgPSB7XHJcbiAgICB0aXRsZTogUHJvcFR5cGVzLm5vZGUsXHJcbiAgICBuYXZpZ2F0aW9uSWNvbjogUHJvcFR5cGVzLm5vZGUsXHJcbiAgICBhY3Rpb25JdGVtczogUHJvcFR5cGVzLm9uZU9mVHlwZShbXHJcbiAgICAgICAgUHJvcFR5cGVzLmVsZW1lbnQsXHJcbiAgICAgICAgUHJvcFR5cGVzLmFycmF5T2YoUHJvcFR5cGVzLmVsZW1lbnQpLFxyXG4gICAgXSksXHJcbiAgICBmaXhlZDogUHJvcFR5cGVzLmJvb2wsXHJcbiAgICBzdGlja3k6IFByb3BUeXBlcy5ib29sLFxyXG4gICAgZGVuc2U6IFByb3BUeXBlcy5ib29sLFxyXG4gICAgcHJvbWluZW50OiBQcm9wVHlwZXMuYm9vbCxcclxuICAgIHNob3J0OiBQcm9wVHlwZXMuYm9vbCxcclxuICAgIGNvbGxhcHNlZDogUHJvcFR5cGVzLmJvb2wsXHJcbiAgICByYWlzZWQ6IFByb3BUeXBlcy5ib29sXHJcbn07XHJcblxyXG5leHBvcnQgZGVmYXVsdCBUb3BBcHBCYXI7IiwiaW1wb3J0IHsgZm9yd2FyZFJlZiB9IGZyb20gJ3JlYWN0JztcclxuaW1wb3J0IGNsYXNzbmFtZXMgZnJvbSAnY2xhc3NuYW1lcyc7XHJcbmltcG9ydCB7IGNzc0NsYXNzZXMgfSBmcm9tICcuL2NvbnN0YW50cyc7XHJcblxyXG5jb25zdCBUb3BBcHBCYXJBY3Rpb25JdGVtID0gZm9yd2FyZFJlZigoe1xyXG4gICAgZWxlbWVudCA9ICdzcGFuJyxcclxuICAgIGNvbXBvbmVudDogRWxlbWVudCA9IGVsZW1lbnQsXHJcbiAgICBjbGFzc05hbWUsXHJcbiAgICAuLi5wcm9wc1xyXG59LCByZWYpID0+IHtcclxuICAgIGNvbnN0IGNsYXNzTmFtZXMgPSBjbGFzc25hbWVzKGNzc0NsYXNzZXMuQUNUSU9OX0lURU0sIGNsYXNzTmFtZSk7XHJcblxyXG4gICAgcmV0dXJuIChcclxuICAgICAgICA8RWxlbWVudCByZWY9e3JlZn0gY2xhc3NOYW1lPXtjbGFzc05hbWVzfSB7Li4ucHJvcHN9IC8+XHJcbiAgICApO1xyXG59KTtcclxuXHJcblRvcEFwcEJhckFjdGlvbkl0ZW0uZGlzcGxheU5hbWUgPSAnTURDVG9wQXBwQmFyQWN0aW9uSXRlbSc7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBUb3BBcHBCYXJBY3Rpb25JdGVtOyIsImltcG9ydCB7IGZvcndhcmRSZWYgfSBmcm9tICdyZWFjdCc7XHJcbmltcG9ydCBjbGFzc25hbWVzIGZyb20gJ2NsYXNzbmFtZXMnO1xyXG5cclxuaW1wb3J0IHsgY3NzQ2xhc3NlcyB9IGZyb20gJy4vY29uc3RhbnRzJztcclxuXHJcbmNvbnN0IFRvcEFwcEJhckZpeGVkQWRqdXN0ID0gZm9yd2FyZFJlZigoe1xyXG4gICAgZGVuc2UgPSBmYWxzZSxcclxuICAgIHByb21pbmVudCA9IGZhbHNlLFxyXG4gICAgc2hvcnQgPSBmYWxzZSxcclxuXHJcbiAgICBlbGVtZW50ID0gJ2RpdicsXHJcbiAgICBjb21wb25lbnQ6IEVsZW1lbnQgPSBlbGVtZW50LFxyXG4gICAgY2xhc3NOYW1lLFxyXG4gICAgLi4ucHJvcHNcclxufSwgcmVmKSA9PiB7XHJcbiAgICBjb25zdCBjbGFzc05hbWVzID0gY2xhc3NuYW1lcyhjc3NDbGFzc2VzLkZJWEVEX0FESlVTVCwge1xyXG4gICAgICAgIFtjc3NDbGFzc2VzLkRFTlNFX0ZJWEVEX0FESlVTVF06IGRlbnNlLFxyXG4gICAgICAgIFtjc3NDbGFzc2VzLlBST01JTkVOVF9GSVhFRF9BREpVU1RdOiBwcm9taW5lbnQsXHJcbiAgICAgICAgW2Nzc0NsYXNzZXMuREVOU0VfUFJPTUlORU5UX0ZJWEVEX0FESlVTVF06IGRlbnNlICYmIHByb21pbmVudCxcclxuICAgICAgICBbY3NzQ2xhc3Nlcy5TSE9SVF9GSVhFRF9BREpVU1RdOiBzaG9ydFxyXG4gICAgfSwgY2xhc3NOYW1lKTtcclxuXHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAgIDxFbGVtZW50IHJlZj17cmVmfSBjbGFzc05hbWU9e2NsYXNzTmFtZXN9IHsuLi5wcm9wc30gLz5cclxuICAgICk7XHJcbn0pO1xyXG5cclxuVG9wQXBwQmFyRml4ZWRBZGp1c3QuZGlzcGxheU5hbWUgPSAnTURDVG9wQXBwQmFyRml4ZWRBZGp1c3QnO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgVG9wQXBwQmFyRml4ZWRBZGp1c3Q7IiwiaW1wb3J0IHsgZm9yd2FyZFJlZiB9IGZyb20gJ3JlYWN0JztcclxuaW1wb3J0IGNsYXNzbmFtZXMgZnJvbSAnY2xhc3NuYW1lcyc7XHJcblxyXG5pbXBvcnQgSWNvbkJ1dHRvbiBmcm9tICcuLi9pY29uLWJ1dHRvbic7XHJcblxyXG5pbXBvcnQgeyBjc3NDbGFzc2VzIH0gZnJvbSAnLi9jb25zdGFudHMnO1xyXG5cclxuY29uc3QgVG9wQXBwQmFyTmF2aWdhdGlvbkljb24gPSBmb3J3YXJkUmVmKCh7IGNsYXNzTmFtZSwgLi4ucHJvcHMgfSwgcmVmKSA9PiB7XHJcbiAgICBjb25zdCBjbGFzc05hbWVzID0gY2xhc3NuYW1lcyhjc3NDbGFzc2VzLk5BVklHQVRJT05fSUNPTiwgY2xhc3NOYW1lKTtcclxuXHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAgIDxJY29uQnV0dG9uIHJlZj17cmVmfSBjbGFzc05hbWU9e2NsYXNzTmFtZXN9IHsuLi5wcm9wc30gLz5cclxuICAgICk7XHJcbn0pO1xyXG5cclxuVG9wQXBwQmFyTmF2aWdhdGlvbkljb24uZGlzcGxheU5hbWUgPSAnTURDVG9wQXBwQmFyTmF2aWdhdGlvbkljb24nO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgVG9wQXBwQmFyTmF2aWdhdGlvbkljb247IiwiaW1wb3J0IHsgZm9yd2FyZFJlZiB9IGZyb20gJ3JlYWN0JztcclxuaW1wb3J0IGNsYXNzbmFtZXMgZnJvbSAnY2xhc3NuYW1lcyc7XHJcblxyXG5pbXBvcnQgeyBjc3NDbGFzc2VzIH0gZnJvbSAnLi9jb25zdGFudHMnO1xyXG5cclxuY29uc3QgVG9wQXBwQmFyVGl0bGUgPSBmb3J3YXJkUmVmKCh7XHJcbiAgICBlbGVtZW50OiBFbGVtZW50ID0gJ3NwYW4nLFxyXG4gICAgY2xhc3NOYW1lLFxyXG4gICAgLi4ucHJvcHNcclxufSwgcmVmKSA9PiB7XHJcbiAgICBjb25zdCBjbGFzc05hbWVzID0gY2xhc3NuYW1lcyhjc3NDbGFzc2VzLlRJVExFLCBjbGFzc05hbWUpO1xyXG5cclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgPEVsZW1lbnQgcmVmPXtyZWZ9IGNsYXNzTmFtZT17Y2xhc3NOYW1lc30gey4uLnByb3BzfSAvPlxyXG4gICAgKTtcclxufSk7XHJcblxyXG5Ub3BBcHBCYXJUaXRsZS5kaXNwbGF5TmFtZSA9ICdNRENUb3BBcHBCYXJUaXRsZSc7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBUb3BBcHBCYXJUaXRsZTsiLCJpbXBvcnQgVG9wQXBwQmFyIGZyb20gJy4vVG9wQXBwQmFyJztcclxuaW1wb3J0IFRvcEFwcEJhckFjdGlvbkl0ZW0gZnJvbSAnLi9Ub3BBcHBCYXJBY3Rpb25JdGVtJztcclxuaW1wb3J0IFRvcEFwcEJhckZpeGVkQWRqdXN0IGZyb20gJy4vVG9wQXBwQmFyRml4ZWRBZGp1c3QnO1xyXG5pbXBvcnQgVG9wQXBwQmFyTmF2aWdhdGlvbkljb24gZnJvbSAnLi9Ub3BBcHBCYXJOYXZpZ2F0aW9uSWNvbic7XHJcbmltcG9ydCBUb3BBcHBCYXJSb3cgZnJvbSAnLi9Ub3BBcHBCYXJSb3cnO1xyXG5pbXBvcnQgVG9wQXBwQmFyU2VjdGlvbiBmcm9tICcuL1RvcEFwcEJhclNlY3Rpb24nO1xyXG5pbXBvcnQgVG9wQXBwQmFyVGl0bGUgZnJvbSAnLi9Ub3BBcHBCYXJUaXRsZSc7XHJcblxyXG5Ub3BBcHBCYXIuQWN0aW9uSXRlbSA9IFRvcEFwcEJhckFjdGlvbkl0ZW07XHJcblRvcEFwcEJhci5GaXhlZEFkanVzdCA9IFRvcEFwcEJhckZpeGVkQWRqdXN0O1xyXG5Ub3BBcHBCYXIuTmF2aWdhdGlvbkljb24gPSBUb3BBcHBCYXJOYXZpZ2F0aW9uSWNvbjtcclxuVG9wQXBwQmFyLlJvdyA9IFRvcEFwcEJhclJvdztcclxuVG9wQXBwQmFyLlNlY3Rpb24gPSBUb3BBcHBCYXJTZWN0aW9uO1xyXG5Ub3BBcHBCYXIuVGl0bGUgPSBUb3BBcHBCYXJUaXRsZTtcclxuXHJcbmV4cG9ydCB7XHJcbiAgICBUb3BBcHBCYXIgYXMgZGVmYXVsdCxcclxuICAgIFRvcEFwcEJhckFjdGlvbkl0ZW0sXHJcbiAgICBUb3BBcHBCYXJGaXhlZEFkanVzdCxcclxuICAgIFRvcEFwcEJhck5hdmlnYXRpb25JY29uLFxyXG4gICAgVG9wQXBwQmFyUm93LFxyXG4gICAgVG9wQXBwQmFyU2VjdGlvbixcclxuICAgIFRvcEFwcEJhclRpdGxlXHJcbn07IiwiZXhwb3J0IGNvbnN0IGVsZW1lbnRzQnlUeXBlID0ge1xyXG4gICAgaGVhZGxpbmUxOiAnaDEnLFxyXG4gICAgaGVhZGxpbmUyOiAnaDInLFxyXG4gICAgaGVhZGxpbmUzOiAnaDMnLFxyXG4gICAgaGVhZGxpbmU0OiAnaDQnLFxyXG4gICAgaGVhZGxpbmU1OiAnaDUnLFxyXG4gICAgaGVhZGxpbmU2OiAnaDYnLFxyXG4gICAgc3VidGl0bGUxOiAnaDUnLFxyXG4gICAgc3VidGl0bGUyOiAnaDYnLFxyXG4gICAgYm9keTE6ICdwJyxcclxuICAgIGJvZHkyOiAncCcsXHJcbiAgICBidXR0b246ICdzcGFuJyxcclxuICAgIGNhcHRpb246ICdzcGFuJyxcclxuICAgIG92ZXJsaW5lOiAnc3BhbidcclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCBjc3NDbGFzc2VzID0ge1xyXG4gICAgUk9PVDogJ21kYy10eXBvZ3JhcGh5JyxcclxuICAgIERJU1BMQVk6ICdtZGMtdHlwb2dyYXBoeS0tZGlzcGxheScsXHJcbiAgICBBTElHTjogJ21kYy10eXBvZ3JhcGh5LS1hbGlnbicsXHJcbiAgICBOT19NQVJHSU46ICdtZGMtdHlwb2dyYXBoeS0tbm8tbWFyZ2luJyxcclxuICAgIE5PX1dSQVA6ICdtZGMtdHlwb2dyYXBoeS0tbm8td3JhcCdcclxufTsiLCJpbXBvcnQgeyBmb3J3YXJkUmVmIH0gZnJvbSAncmVhY3QnO1xyXG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xyXG5pbXBvcnQgY2xhc3NuYW1lcyBmcm9tICdjbGFzc25hbWVzJztcclxuXHJcbmltcG9ydCB7IGVsZW1lbnRzQnlUeXBlLCBjc3NDbGFzc2VzIH0gZnJvbSAnLi9jb25zdGFudHMnO1xyXG5cclxuY29uc3QgVHlwb2dyYXBoeSA9IGZvcndhcmRSZWYoKHtcclxuICAgIHR5cGUgPSAnYm9keTEnLFxyXG4gICAgZGlzcGxheSxcclxuICAgIGFsaWduLFxyXG4gICAgbm9NYXJnaW4gPSBmYWxzZSxcclxuICAgIG5vV3JhcCA9IGZhbHNlLFxyXG5cclxuICAgIGVsZW1lbnQgPSBlbGVtZW50c0J5VHlwZVt0eXBlXSxcclxuICAgIGNvbXBvbmVudDogRWxlbWVudCA9IGVsZW1lbnQsXHJcbiAgICBjbGFzc05hbWUsXHJcbiAgICAuLi5wcm9wc1xyXG59LCByZWYpID0+IHtcclxuICAgIGNvbnN0IGNsYXNzTmFtZXMgPSBjbGFzc25hbWVzKGNzc0NsYXNzZXMuUk9PVCwgYCR7Y3NzQ2xhc3Nlcy5ST09UfS0tJHt0eXBlfWAsIHtcclxuICAgICAgICBbYCR7Y3NzQ2xhc3Nlcy5ESVNQTEFZfS0ke2Rpc3BsYXl9YF06IGRpc3BsYXksXHJcbiAgICAgICAgW2Ake2Nzc0NsYXNzZXMuQUxJR059LSR7YWxpZ259YF06IGFsaWduLFxyXG4gICAgICAgIFtjc3NDbGFzc2VzLk5PX01BUkdJTl06IG5vTWFyZ2luLFxyXG4gICAgICAgIFtjc3NDbGFzc2VzLk5PX1dSQVBdOiBub1dyYXBcclxuICAgIH0sIGNsYXNzTmFtZSk7XHJcblxyXG4gICAgcmV0dXJuIChcclxuICAgICAgICA8RWxlbWVudCByZWY9e3JlZn0gY2xhc3NOYW1lPXtjbGFzc05hbWVzfSB7Li4ucHJvcHN9IC8+XHJcbiAgICApO1xyXG59KTtcclxuXHJcblR5cG9ncmFwaHkuZGlzcGxheU5hbWUgPSAnTURDVHlwb2dyYXBoeSc7XHJcblxyXG5UeXBvZ3JhcGh5LnByb3BUeXBlcyA9IHtcclxuICAgIHR5cGU6IFByb3BUeXBlcy5vbmVPZihPYmplY3Qua2V5cyhlbGVtZW50c0J5VHlwZSkpLFxyXG4gICAgZGlzcGxheTogUHJvcFR5cGVzLm9uZU9mKFsnYmxvY2snLCAnaW5saW5lJywgJ2lubGluZS1ibG9jayddKSxcclxuICAgIGFsaWduOiBQcm9wVHlwZXMub25lT2YoWydsZWZ0JywgJ2NlbnRlcicsICdyaWdodCcsICdqdXN0aWZ5J10pLFxyXG4gICAgbm9NYXJnaW46IFByb3BUeXBlcy5ib29sLFxyXG4gICAgbm9XcmFwOiBQcm9wVHlwZXMuYm9vbFxyXG59O1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgVHlwb2dyYXBoeTsiLCJleHBvcnQgeyBkZWZhdWx0LCBkZWZhdWx0IGFzIFR5cG9ncmFwaHksIGRlZmF1bHQgYXMgVGV4dCB9IGZyb20gJy4vVHlwb2dyYXBoeSc7IiwiZXhwb3J0IHsgZGVmYXVsdCBhcyBBdmF0YXIgfSBmcm9tICcuL2F2YXRhcic7XHJcbmV4cG9ydCB7IGRlZmF1bHQgYXMgQmFkZ2UgfSBmcm9tICcuL2JhZGdlJztcclxuZXhwb3J0IHsgZGVmYXVsdCBhcyBCYW5uZXIgfSBmcm9tICcuL2Jhbm5lcic7XHJcbmV4cG9ydCB7IGRlZmF1bHQgYXMgQnV0dG9uIH0gZnJvbSAnLi9idXR0b24nO1xyXG5leHBvcnQgeyBkZWZhdWx0IGFzIENhcmQsIENhcmRBY3Rpb24sIENhcmRBY3Rpb25zLCBDYXJkQWN0aW9uQnV0dG9ucywgQ2FyZEFjdGlvbkljb25zLCBDYXJkSGVhZGVyLCBDYXJkTWVkaWEsIENhcmRQcmltYXJ5QWN0aW9uLCBDYXJkU2VjdGlvbiB9IGZyb20gJy4vY2FyZCc7XHJcbmV4cG9ydCB7IGRlZmF1bHQgYXMgQ2hlY2tib3ggfSBmcm9tICcuL2NoZWNrYm94JztcclxuZXhwb3J0IHsgQ2hpcCwgQ2hpcFNldCB9IGZyb20gJy4vY2hpcHMnO1xyXG5leHBvcnQgeyBkZWZhdWx0IGFzIENpcmN1bGFyUHJvZ3Jlc3MgfSBmcm9tICcuL2NpcmN1bGFyLXByb2dyZXNzJztcclxuZXhwb3J0IHsgZGVmYXVsdCBhcyBJY29uIH0gZnJvbSAnLi9pY29uJztcclxuZXhwb3J0IHsgZGVmYXVsdCBhcyBJY29uQnV0dG9uIH0gZnJvbSAnLi9pY29uLWJ1dHRvbic7XHJcbmV4cG9ydCB7IGRlZmF1bHQgYXMgRGF0YVRhYmxlLCBEYXRhVGFibGVIZWFkZXIsIERhdGFUYWJsZUhlYWRlclJvdywgRGF0YVRhYmxlSGVhZGVyQ2VsbCwgRGF0YVRhYmxlQ29udGVudCwgRGF0YVRhYmxlUm93LCBEYXRhVGFibGVDZWxsLCBEYXRhVGFibGVGb290ZXIgfSBmcm9tICcuL2RhdGEtdGFibGUnO1xyXG5leHBvcnQgeyBkZWZhdWx0IGFzIERpYWxvZywgRGlhbG9nSGVhZGVyLCBEaWFsb2dDb250ZW50LCBEaWFsb2dBY3Rpb25zIH0gZnJvbSAnLi9kaWFsb2cnO1xyXG5leHBvcnQgeyBkZWZhdWx0IGFzIERyYXdlciwgRHJhd2VySGVhZGVyLCBEcmF3ZXJDb250ZW50IH0gZnJvbSAnLi9kcmF3ZXInO1xyXG5leHBvcnQgeyBkZWZhdWx0IGFzIEVsZXZhdGlvbiB9IGZyb20gJy4vZWxldmF0aW9uJztcclxuZXhwb3J0IHsgZGVmYXVsdCBhcyBGQUIgfSBmcm9tICcuL2ZhYic7XHJcbmV4cG9ydCB7IGRlZmF1bHQgYXMgRmxvYXRpbmdMYWJlbCB9IGZyb20gJy4vZmxvYXRpbmctbGFiZWwnO1xyXG5leHBvcnQgeyBkZWZhdWx0IGFzIEZvcm1GaWVsZCB9IGZyb20gJy4vZm9ybS1maWVsZCc7XHJcbmV4cG9ydCB7IGRlZmF1bHQgYXMgSW1hZ2VMaXN0LCBJbWFnZUxpc3RJdGVtIH0gZnJvbSAnLi9pbWFnZS1saXN0JztcclxuZXhwb3J0IHsgZGVmYXVsdCBhcyBMYXlvdXQgfSBmcm9tICcuL2xheW91dCc7XHJcbmV4cG9ydCB7IGRlZmF1bHQgYXMgTGF5b3V0R3JpZCwgTGF5b3V0R3JpZENlbGwgfSBmcm9tICcuL2xheW91dC1ncmlkJztcclxuZXhwb3J0IHsgZGVmYXVsdCBhcyBMaW5lYXJQcm9ncmVzcyB9IGZyb20gJy4vbGluZWFyLXByb2dyZXNzJztcclxuZXhwb3J0IHsgZGVmYXVsdCBhcyBMaW5lUmlwcGxlIH0gZnJvbSAnLi9saW5lLXJpcHBsZSc7XHJcbmV4cG9ydCB7IGRlZmF1bHQgYXMgTGlzdCwgTGlzdERpdmlkZXIsIExpc3RJdGVtLCBMaXN0SXRlbUNvbnRlbnQsIExpc3RJdGVtRW5kLCBMaXN0SXRlbVN0YXJ0LCBMaXN0R3JvdXAsIExpc3RHcm91cFN1YmhlYWRlciB9IGZyb20gJy4vbGlzdCc7XHJcbmV4cG9ydCB7IGRlZmF1bHQgYXMgTWVudSwgTWVudUFuY2hvciwgTWVudUl0ZW0sIE1lbnVPcmlnaW4sIE1lbnVTdXJmYWNlLCBNZW51U2VsZWN0aW9uR3JvdXAsIE1lbnVTZWxlY3Rpb25Hcm91cEljb24gfSBmcm9tICcuL21lbnUnO1xyXG5leHBvcnQgeyBkZWZhdWx0IGFzIE5vdGNoZWRPdXRsaW5lIH0gZnJvbSAnLi9ub3RjaGVkLW91dGxpbmUnO1xyXG5leHBvcnQgeyBkZWZhdWx0IGFzIFJhZGlvIH0gZnJvbSAnLi9yYWRpbyc7XHJcbmV4cG9ydCB7IFJpcHBsZSwgUmlwcGxlU3VyZmFjZSB9IGZyb20gJy4vcmlwcGxlJztcclxuZXhwb3J0IHsgZGVmYXVsdCBhcyBTZWdtZW50ZWRCdXR0b24sIFNlZ21lbnRlZEJ1dHRvblNlZ21lbnQgfSBmcm9tICcuL3NlZ21lbnRlZC1idXR0b24nO1xyXG5leHBvcnQgeyBkZWZhdWx0IGFzIFNpZGVTaGVldCwgU2lkZVNoZWV0SGVhZGVyLCBTaWRlU2hlZXRDb250ZW50IH0gZnJvbSAnLi9zaWRlLXNoZWV0JztcclxuZXhwb3J0IHsgZGVmYXVsdCBhcyBTZWxlY3QsIFNlbGVjdE9wdGlvbiB9IGZyb20gJy4vc2VsZWN0JztcclxuZXhwb3J0IHsgZGVmYXVsdCBhcyBTbGlkZXIgfSBmcm9tICcuL3NsaWRlcic7XHJcbmV4cG9ydCB7IGRlZmF1bHQgYXMgU25hY2tiYXIgfSBmcm9tICcuL3NuYWNrYmFyJztcclxuZXhwb3J0IHsgZGVmYXVsdCBhcyBTd2l0Y2ggfSBmcm9tICcuL3N3aXRjaCc7XHJcbmV4cG9ydCB7IGRlZmF1bHQgYXMgU3ltYm9sIH0gZnJvbSAnLi9zeW1ib2wnO1xyXG5leHBvcnQgeyBUYWIsIFRhYkJhciB9IGZyb20gJy4vdGFicyc7XHJcbmV4cG9ydCB7IFRvb2x0aXAsIFJpY2hUb29sdGlwIH0gZnJvbSAnLi90b29sdGlwJztcclxuZXhwb3J0IHsgZGVmYXVsdCBhcyBUZXh0RmllbGQgfSBmcm9tICcuL3RleHQtZmllbGQnO1xyXG5leHBvcnQgeyBkZWZhdWx0IGFzIFRvcEFwcEJhciwgVG9wQXBwQmFyQWN0aW9uSXRlbSwgVG9wQXBwQmFyTmF2aWdhdGlvbkljb24sIFRvcEFwcEJhclJvdywgVG9wQXBwQmFyU2VjdGlvbiwgVG9wQXBwQmFyVGl0bGUgfSBmcm9tICcuL3RvcC1hcHAtYmFyJztcclxuZXhwb3J0IHsgZGVmYXVsdCBhcyBUeXBvZ3JhcGh5LCBkZWZhdWx0IGFzIFRleHQgfSBmcm9tICcuL3R5cG9ncmFwaHknOyIsImltcG9ydCB7IENoaWxkcmVuLCBpc1ZhbGlkRWxlbWVudCB9IGZyb20gJ3JlYWN0JztcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBqc3hUb0h0bWwocm9vdCkge1xyXG4gICAgcmV0dXJuIENoaWxkcmVuLnRvQXJyYXkocm9vdClcclxuICAgICAgICAubWFwKGl0ZW0gPT4gcHJpbnRDb21wb25lbnQoaXRlbSkpXHJcbiAgICAgICAgLmpvaW4oJ1xcbicpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gcHJpbnRDb21wb25lbnQoY29tcG9uZW50LCBkZXB0aCA9IDApIHtcclxuICAgIGNvbnN0IHR5cGUgPSB0eXBlb2YgY29tcG9uZW50LnR5cGUgPT09ICdzdHJpbmcnID8gY29tcG9uZW50LnR5cGUgOiBjb21wb25lbnQudHlwZS5kaXNwbGF5TmFtZS5yZXBsYWNlKCdNREMnLCAnJyk7XHJcbiAgICBjb25zdCBjaGlsZHJlbiA9IGNvbXBvbmVudC5wcm9wcy5jaGlsZHJlbjtcclxuICAgIGNvbnN0IHByb3BzID0gT2JqZWN0LmVudHJpZXMoY29tcG9uZW50LnByb3BzKS5maWx0ZXIoKFtrZXksIHZhbHVlXSkgPT4ga2V5ICE9PSAnY2hpbGRyZW4nICYmIHZhbHVlICE9PSB1bmRlZmluZWQpO1xyXG4gICAgY29uc3QgaW5kZW50ID0gJyAgJy5yZXBlYXQoZGVwdGgpO1xyXG5cclxuICAgIGxldCByZXN1bHQgPSBpbmRlbnQgKyBgPCR7dHlwZX1gO1xyXG5cclxuICAgIGlmICghaXNFbXB0eShwcm9wcykpIHtcclxuICAgICAgICByZXN1bHQgKz0gYCAke3ByaW50UHJvcHMocHJvcHMsIGRlcHRoICsgMSl9YDtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoIWNoaWxkcmVuKSB7XHJcbiAgICAgICAgcmVzdWx0ICs9IHJlc3VsdC5lbmRzV2l0aCgnXFxuJykgPyAoaW5kZW50ICsgJy8+JykgOiAnIC8+JztcclxuICAgIH0gZWxzZSBpZiAoaXNWYWxpZEVsZW1lbnQoY2hpbGRyZW4pKSB7XHJcbiAgICAgICAgcmVzdWx0ICs9IGA+XFxuJHtwcmludENvbXBvbmVudChjaGlsZHJlbiwgZGVwdGggKyAxKX1cXG4ke2luZGVudH08LyR7dHlwZX0+YDtcclxuICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShjaGlsZHJlbikpIHtcclxuICAgICAgICByZXN1bHQgKz0gcmVzdWx0LmVuZHNXaXRoKCdcXG4nKSA/IChpbmRlbnQgKyAnPlxcbicpIDogJz5cXG4nO1xyXG5cclxuICAgICAgICByZXN1bHQgKz0gY2hpbGRyZW4ubWFwKGNoaWxkID0+IHByaW50Q29tcG9uZW50KGNoaWxkLCBkZXB0aCArIDEpKS5qb2luKCdcXG4nKTtcclxuXHJcbiAgICAgICAgcmVzdWx0ICs9IGBcXG4ke2luZGVudH08LyR7dHlwZX0+YDtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcmVzdWx0ICs9IGA+JHtjaGlsZHJlbn08LyR7dHlwZX0+YDtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59XHJcblxyXG5mdW5jdGlvbiBwcmludFByb3BzKHByb3BzLCBkZXB0aCkge1xyXG4gICAgbGV0IHJlc3VsdCA9ICcnO1xyXG4gICAgY29uc3QgaW5kZW50ID0gJyAgJy5yZXBlYXQoZGVwdGgpO1xyXG5cclxuICAgIGlmIChwcm9wcy5sZW5ndGggPCAzKSB7XHJcbiAgICAgICAgcmVzdWx0ICs9IHByb3BzLm1hcChwcmludFByb3ApLmpvaW4oJyAnKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcmVzdWx0ICs9IGBcXG4ke2luZGVudH0ke3Byb3BzLm1hcChwcmludFByb3ApLmpvaW4oJ1xcbicgKyBpbmRlbnQpfVxcbmA7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufVxyXG5cclxuZnVuY3Rpb24gcHJpbnRQcm9wKFtrZXksIHZhbHVlXSkge1xyXG4gICAgaWYgKHZhbHVlID09PSB0cnVlKSB7XHJcbiAgICAgICAgcmV0dXJuIGtleTtcclxuICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgIHJldHVybiBgJHtrZXl9PVwiJHt2YWx1ZX1cImA7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIHJldHVybiBgJHtrZXl9PXske3ByaW50VmFsdWUodmFsdWUpfX1gO1xyXG4gICAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBwcmludFZhbHVlKHZhbHVlKSB7XHJcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgIHJldHVybiBgJyR7dmFsdWV9J2A7XHJcbiAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XHJcbiAgICAgICAgcmV0dXJuIGBbJHt2YWx1ZS5tYXAodiA9PiBwcmludFZhbHVlKHYpKS5qb2luKCcsICcpfV1gO1xyXG4gICAgfSBlbHNlIGlmIChpc1ZhbGlkRWxlbWVudCh2YWx1ZSkpIHtcclxuICAgICAgICByZXR1cm4gcHJpbnRDb21wb25lbnQodmFsdWUpO1xyXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICByZXR1cm4gYCR7dmFsdWUubmFtZSB8fCAnW0Z1bmN0aW9uXSd9YDtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBpc0VtcHR5KHZhbHVlKSB7XHJcbiAgICBpZiAoIXZhbHVlKSB7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XHJcbiAgICAgICAgcmV0dXJuIHZhbHVlLmxlbmd0aCA9PT0gMDtcclxuICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0Jykge1xyXG4gICAgICAgIHJldHVybiBPYmplY3Qua2V5cyh2YWx1ZSkubGVuZ3RoID09PSAwO1xyXG4gICAgfVxyXG59IiwiLy8gaHR0cHM6Ly9ub2RlanMub3JnL2FwaS9wYWNrYWdlcy5odG1sI3BhY2thZ2VzX3dyaXRpbmdfZHVhbF9wYWNrYWdlc193aGlsZV9hdm9pZGluZ19vcl9taW5pbWl6aW5nX2hhemFyZHNcbmltcG9ydCBobGpzIGZyb20gJy4uL2xpYi9jb3JlLmpzJztcbmV4cG9ydCBkZWZhdWx0IGhsanM7XG4iLCJjb25zdCBJREVOVF9SRSA9ICdbQS1aYS16JF9dWzAtOUEtWmEteiRfXSonO1xuY29uc3QgS0VZV09SRFMgPSBbXG4gIFwiYXNcIiwgLy8gZm9yIGV4cG9ydHNcbiAgXCJpblwiLFxuICBcIm9mXCIsXG4gIFwiaWZcIixcbiAgXCJmb3JcIixcbiAgXCJ3aGlsZVwiLFxuICBcImZpbmFsbHlcIixcbiAgXCJ2YXJcIixcbiAgXCJuZXdcIixcbiAgXCJmdW5jdGlvblwiLFxuICBcImRvXCIsXG4gIFwicmV0dXJuXCIsXG4gIFwidm9pZFwiLFxuICBcImVsc2VcIixcbiAgXCJicmVha1wiLFxuICBcImNhdGNoXCIsXG4gIFwiaW5zdGFuY2VvZlwiLFxuICBcIndpdGhcIixcbiAgXCJ0aHJvd1wiLFxuICBcImNhc2VcIixcbiAgXCJkZWZhdWx0XCIsXG4gIFwidHJ5XCIsXG4gIFwic3dpdGNoXCIsXG4gIFwiY29udGludWVcIixcbiAgXCJ0eXBlb2ZcIixcbiAgXCJkZWxldGVcIixcbiAgXCJsZXRcIixcbiAgXCJ5aWVsZFwiLFxuICBcImNvbnN0XCIsXG4gIFwiY2xhc3NcIixcbiAgLy8gSlMgaGFuZGxlcyB0aGVzZSB3aXRoIGEgc3BlY2lhbCBydWxlXG4gIC8vIFwiZ2V0XCIsXG4gIC8vIFwic2V0XCIsXG4gIFwiZGVidWdnZXJcIixcbiAgXCJhc3luY1wiLFxuICBcImF3YWl0XCIsXG4gIFwic3RhdGljXCIsXG4gIFwiaW1wb3J0XCIsXG4gIFwiZnJvbVwiLFxuICBcImV4cG9ydFwiLFxuICBcImV4dGVuZHNcIlxuXTtcbmNvbnN0IExJVEVSQUxTID0gW1xuICBcInRydWVcIixcbiAgXCJmYWxzZVwiLFxuICBcIm51bGxcIixcbiAgXCJ1bmRlZmluZWRcIixcbiAgXCJOYU5cIixcbiAgXCJJbmZpbml0eVwiXG5dO1xuXG5jb25zdCBUWVBFUyA9IFtcbiAgXCJJbnRsXCIsXG4gIFwiRGF0YVZpZXdcIixcbiAgXCJOdW1iZXJcIixcbiAgXCJNYXRoXCIsXG4gIFwiRGF0ZVwiLFxuICBcIlN0cmluZ1wiLFxuICBcIlJlZ0V4cFwiLFxuICBcIk9iamVjdFwiLFxuICBcIkZ1bmN0aW9uXCIsXG4gIFwiQm9vbGVhblwiLFxuICBcIkVycm9yXCIsXG4gIFwiU3ltYm9sXCIsXG4gIFwiU2V0XCIsXG4gIFwiTWFwXCIsXG4gIFwiV2Vha1NldFwiLFxuICBcIldlYWtNYXBcIixcbiAgXCJQcm94eVwiLFxuICBcIlJlZmxlY3RcIixcbiAgXCJKU09OXCIsXG4gIFwiUHJvbWlzZVwiLFxuICBcIkZsb2F0NjRBcnJheVwiLFxuICBcIkludDE2QXJyYXlcIixcbiAgXCJJbnQzMkFycmF5XCIsXG4gIFwiSW50OEFycmF5XCIsXG4gIFwiVWludDE2QXJyYXlcIixcbiAgXCJVaW50MzJBcnJheVwiLFxuICBcIkZsb2F0MzJBcnJheVwiLFxuICBcIkFycmF5XCIsXG4gIFwiVWludDhBcnJheVwiLFxuICBcIlVpbnQ4Q2xhbXBlZEFycmF5XCIsXG4gIFwiQXJyYXlCdWZmZXJcIixcbiAgXCJCaWdJbnQ2NEFycmF5XCIsXG4gIFwiQmlnVWludDY0QXJyYXlcIixcbiAgXCJCaWdJbnRcIlxuXTtcblxuY29uc3QgRVJST1JfVFlQRVMgPSBbXG4gIFwiRXZhbEVycm9yXCIsXG4gIFwiSW50ZXJuYWxFcnJvclwiLFxuICBcIlJhbmdlRXJyb3JcIixcbiAgXCJSZWZlcmVuY2VFcnJvclwiLFxuICBcIlN5bnRheEVycm9yXCIsXG4gIFwiVHlwZUVycm9yXCIsXG4gIFwiVVJJRXJyb3JcIlxuXTtcblxuY29uc3QgQlVJTFRfSU5fR0xPQkFMUyA9IFtcbiAgXCJzZXRJbnRlcnZhbFwiLFxuICBcInNldFRpbWVvdXRcIixcbiAgXCJjbGVhckludGVydmFsXCIsXG4gIFwiY2xlYXJUaW1lb3V0XCIsXG5cbiAgXCJyZXF1aXJlXCIsXG4gIFwiZXhwb3J0c1wiLFxuXG4gIFwiZXZhbFwiLFxuICBcImlzRmluaXRlXCIsXG4gIFwiaXNOYU5cIixcbiAgXCJwYXJzZUZsb2F0XCIsXG4gIFwicGFyc2VJbnRcIixcbiAgXCJkZWNvZGVVUklcIixcbiAgXCJkZWNvZGVVUklDb21wb25lbnRcIixcbiAgXCJlbmNvZGVVUklcIixcbiAgXCJlbmNvZGVVUklDb21wb25lbnRcIixcbiAgXCJlc2NhcGVcIixcbiAgXCJ1bmVzY2FwZVwiXG5dO1xuXG5jb25zdCBCVUlMVF9JTl9WQVJJQUJMRVMgPSBbXG4gIFwiYXJndW1lbnRzXCIsXG4gIFwidGhpc1wiLFxuICBcInN1cGVyXCIsXG4gIFwiY29uc29sZVwiLFxuICBcIndpbmRvd1wiLFxuICBcImRvY3VtZW50XCIsXG4gIFwibG9jYWxTdG9yYWdlXCIsXG4gIFwibW9kdWxlXCIsXG4gIFwiZ2xvYmFsXCIgLy8gTm9kZS5qc1xuXTtcblxuY29uc3QgQlVJTFRfSU5TID0gW10uY29uY2F0KFxuICBCVUlMVF9JTl9HTE9CQUxTLFxuICBUWVBFUyxcbiAgRVJST1JfVFlQRVNcbik7XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG4gKiBAcmV0dXJucyB7UmVnRXhwfVxuICogKi9cblxuLyoqXG4gKiBAcGFyYW0ge1JlZ0V4cCB8IHN0cmluZyB9IHJlXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBzb3VyY2UocmUpIHtcbiAgaWYgKCFyZSkgcmV0dXJuIG51bGw7XG4gIGlmICh0eXBlb2YgcmUgPT09IFwic3RyaW5nXCIpIHJldHVybiByZTtcblxuICByZXR1cm4gcmUuc291cmNlO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7UmVnRXhwIHwgc3RyaW5nIH0gcmVcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGxvb2thaGVhZChyZSkge1xuICByZXR1cm4gY29uY2F0KCcoPz0nLCByZSwgJyknKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0gey4uLihSZWdFeHAgfCBzdHJpbmcpIH0gYXJnc1xuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gY29uY2F0KC4uLmFyZ3MpIHtcbiAgY29uc3Qgam9pbmVkID0gYXJncy5tYXAoKHgpID0+IHNvdXJjZSh4KSkuam9pbihcIlwiKTtcbiAgcmV0dXJuIGpvaW5lZDtcbn1cblxuLypcbkxhbmd1YWdlOiBKYXZhU2NyaXB0XG5EZXNjcmlwdGlvbjogSmF2YVNjcmlwdCAoSlMpIGlzIGEgbGlnaHR3ZWlnaHQsIGludGVycHJldGVkLCBvciBqdXN0LWluLXRpbWUgY29tcGlsZWQgcHJvZ3JhbW1pbmcgbGFuZ3VhZ2Ugd2l0aCBmaXJzdC1jbGFzcyBmdW5jdGlvbnMuXG5DYXRlZ29yeTogY29tbW9uLCBzY3JpcHRpbmcsIHdlYlxuV2Vic2l0ZTogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdFxuKi9cblxuLyoqIEB0eXBlIExhbmd1YWdlRm4gKi9cbmZ1bmN0aW9uIGphdmFzY3JpcHQoaGxqcykge1xuICAvKipcbiAgICogVGFrZXMgYSBzdHJpbmcgbGlrZSBcIjxCb29nZXJcIiBhbmQgY2hlY2tzIHRvIHNlZVxuICAgKiBpZiB3ZSBjYW4gZmluZCBhIG1hdGNoaW5nIFwiPC9Cb29nZXJcIiBsYXRlciBpbiB0aGVcbiAgICogY29udGVudC5cbiAgICogQHBhcmFtIHtSZWdFeHBNYXRjaEFycmF5fSBtYXRjaFxuICAgKiBAcGFyYW0ge3thZnRlcjpudW1iZXJ9fSBwYXJhbTFcbiAgICovXG4gIGNvbnN0IGhhc0Nsb3NpbmdUYWcgPSAobWF0Y2gsIHsgYWZ0ZXIgfSkgPT4ge1xuICAgIGNvbnN0IHRhZyA9IFwiPC9cIiArIG1hdGNoWzBdLnNsaWNlKDEpO1xuICAgIGNvbnN0IHBvcyA9IG1hdGNoLmlucHV0LmluZGV4T2YodGFnLCBhZnRlcik7XG4gICAgcmV0dXJuIHBvcyAhPT0gLTE7XG4gIH07XG5cbiAgY29uc3QgSURFTlRfUkUkMSA9IElERU5UX1JFO1xuICBjb25zdCBGUkFHTUVOVCA9IHtcbiAgICBiZWdpbjogJzw+JyxcbiAgICBlbmQ6ICc8Lz4nXG4gIH07XG4gIGNvbnN0IFhNTF9UQUcgPSB7XG4gICAgYmVnaW46IC88W0EtWmEtejAtOVxcXFwuXzotXSsvLFxuICAgIGVuZDogL1xcL1tBLVphLXowLTlcXFxcLl86LV0rPnxcXC8+LyxcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1JlZ0V4cE1hdGNoQXJyYXl9IG1hdGNoXG4gICAgICogQHBhcmFtIHtDYWxsYmFja1Jlc3BvbnNlfSByZXNwb25zZVxuICAgICAqL1xuICAgIGlzVHJ1bHlPcGVuaW5nVGFnOiAobWF0Y2gsIHJlc3BvbnNlKSA9PiB7XG4gICAgICBjb25zdCBhZnRlck1hdGNoSW5kZXggPSBtYXRjaFswXS5sZW5ndGggKyBtYXRjaC5pbmRleDtcbiAgICAgIGNvbnN0IG5leHRDaGFyID0gbWF0Y2guaW5wdXRbYWZ0ZXJNYXRjaEluZGV4XTtcbiAgICAgIC8vIG5lc3RlZCB0eXBlP1xuICAgICAgLy8gSFRNTCBzaG91bGQgbm90IGluY2x1ZGUgYW5vdGhlciByYXcgYDxgIGluc2lkZSBhIHRhZ1xuICAgICAgLy8gQnV0IGEgdHlwZSBtaWdodDogYDxBcnJheTxBcnJheTxudW1iZXI+PmAsIGV0Yy5cbiAgICAgIGlmIChuZXh0Q2hhciA9PT0gXCI8XCIpIHtcbiAgICAgICAgcmVzcG9uc2UuaWdub3JlTWF0Y2goKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgLy8gPHNvbWV0aGluZz5cbiAgICAgIC8vIFRoaXMgaXMgbm93IGVpdGhlciBhIHRhZyBvciBhIHR5cGUuXG4gICAgICBpZiAobmV4dENoYXIgPT09IFwiPlwiKSB7XG4gICAgICAgIC8vIGlmIHdlIGNhbm5vdCBmaW5kIGEgbWF0Y2hpbmcgY2xvc2luZyB0YWcsIHRoZW4gd2VcbiAgICAgICAgLy8gd2lsbCBpZ25vcmUgaXRcbiAgICAgICAgaWYgKCFoYXNDbG9zaW5nVGFnKG1hdGNoLCB7IGFmdGVyOiBhZnRlck1hdGNoSW5kZXggfSkpIHtcbiAgICAgICAgICByZXNwb25zZS5pZ25vcmVNYXRjaCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xuICBjb25zdCBLRVlXT1JEUyQxID0ge1xuICAgICRwYXR0ZXJuOiBJREVOVF9SRSxcbiAgICBrZXl3b3JkOiBLRVlXT1JEUyxcbiAgICBsaXRlcmFsOiBMSVRFUkFMUyxcbiAgICBidWlsdF9pbjogQlVJTFRfSU5TLFxuICAgIFwidmFyaWFibGUubGFuZ3VhZ2VcIjogQlVJTFRfSU5fVkFSSUFCTEVTXG4gIH07XG5cbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1saXRlcmFscy1udW1lcmljLWxpdGVyYWxzXG4gIGNvbnN0IGRlY2ltYWxEaWdpdHMgPSAnWzAtOV0oXz9bMC05XSkqJztcbiAgY29uc3QgZnJhYyA9IGBcXFxcLigke2RlY2ltYWxEaWdpdHN9KWA7XG4gIC8vIERlY2ltYWxJbnRlZ2VyTGl0ZXJhbCwgaW5jbHVkaW5nIEFubmV4IEIgTm9uT2N0YWxEZWNpbWFsSW50ZWdlckxpdGVyYWxcbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hZGRpdGlvbmFsLXN5bnRheC1udW1lcmljLWxpdGVyYWxzXG4gIGNvbnN0IGRlY2ltYWxJbnRlZ2VyID0gYDB8WzEtOV0oXz9bMC05XSkqfDBbMC03XSpbODldWzAtOV0qYDtcbiAgY29uc3QgTlVNQkVSID0ge1xuICAgIGNsYXNzTmFtZTogJ251bWJlcicsXG4gICAgdmFyaWFudHM6IFtcbiAgICAgIC8vIERlY2ltYWxMaXRlcmFsXG4gICAgICB7IGJlZ2luOiBgKFxcXFxiKCR7ZGVjaW1hbEludGVnZXJ9KSgoJHtmcmFjfSl8XFxcXC4pP3woJHtmcmFjfSkpYCArXG4gICAgICAgIGBbZUVdWystXT8oJHtkZWNpbWFsRGlnaXRzfSlcXFxcYmAgfSxcbiAgICAgIHsgYmVnaW46IGBcXFxcYigke2RlY2ltYWxJbnRlZ2VyfSlcXFxcYigoJHtmcmFjfSlcXFxcYnxcXFxcLik/fCgke2ZyYWN9KVxcXFxiYCB9LFxuXG4gICAgICAvLyBEZWNpbWFsQmlnSW50ZWdlckxpdGVyYWxcbiAgICAgIHsgYmVnaW46IGBcXFxcYigwfFsxLTldKF8/WzAtOV0pKiluXFxcXGJgIH0sXG5cbiAgICAgIC8vIE5vbkRlY2ltYWxJbnRlZ2VyTGl0ZXJhbFxuICAgICAgeyBiZWdpbjogXCJcXFxcYjBbeFhdWzAtOWEtZkEtRl0oXz9bMC05YS1mQS1GXSkqbj9cXFxcYlwiIH0sXG4gICAgICB7IGJlZ2luOiBcIlxcXFxiMFtiQl1bMC0xXShfP1swLTFdKSpuP1xcXFxiXCIgfSxcbiAgICAgIHsgYmVnaW46IFwiXFxcXGIwW29PXVswLTddKF8/WzAtN10pKm4/XFxcXGJcIiB9LFxuXG4gICAgICAvLyBMZWdhY3lPY3RhbEludGVnZXJMaXRlcmFsIChkb2VzIG5vdCBpbmNsdWRlIHVuZGVyc2NvcmUgc2VwYXJhdG9ycylcbiAgICAgIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYWRkaXRpb25hbC1zeW50YXgtbnVtZXJpYy1saXRlcmFsc1xuICAgICAgeyBiZWdpbjogXCJcXFxcYjBbMC03XStuP1xcXFxiXCIgfSxcbiAgICBdLFxuICAgIHJlbGV2YW5jZTogMFxuICB9O1xuXG4gIGNvbnN0IFNVQlNUID0ge1xuICAgIGNsYXNzTmFtZTogJ3N1YnN0JyxcbiAgICBiZWdpbjogJ1xcXFwkXFxcXHsnLFxuICAgIGVuZDogJ1xcXFx9JyxcbiAgICBrZXl3b3JkczogS0VZV09SRFMkMSxcbiAgICBjb250YWluczogW10gLy8gZGVmaW5lZCBsYXRlclxuICB9O1xuICBjb25zdCBIVE1MX1RFTVBMQVRFID0ge1xuICAgIGJlZ2luOiAnaHRtbGAnLFxuICAgIGVuZDogJycsXG4gICAgc3RhcnRzOiB7XG4gICAgICBlbmQ6ICdgJyxcbiAgICAgIHJldHVybkVuZDogZmFsc2UsXG4gICAgICBjb250YWluczogW1xuICAgICAgICBobGpzLkJBQ0tTTEFTSF9FU0NBUEUsXG4gICAgICAgIFNVQlNUXG4gICAgICBdLFxuICAgICAgc3ViTGFuZ3VhZ2U6ICd4bWwnXG4gICAgfVxuICB9O1xuICBjb25zdCBDU1NfVEVNUExBVEUgPSB7XG4gICAgYmVnaW46ICdjc3NgJyxcbiAgICBlbmQ6ICcnLFxuICAgIHN0YXJ0czoge1xuICAgICAgZW5kOiAnYCcsXG4gICAgICByZXR1cm5FbmQ6IGZhbHNlLFxuICAgICAgY29udGFpbnM6IFtcbiAgICAgICAgaGxqcy5CQUNLU0xBU0hfRVNDQVBFLFxuICAgICAgICBTVUJTVFxuICAgICAgXSxcbiAgICAgIHN1Ykxhbmd1YWdlOiAnY3NzJ1xuICAgIH1cbiAgfTtcbiAgY29uc3QgVEVNUExBVEVfU1RSSU5HID0ge1xuICAgIGNsYXNzTmFtZTogJ3N0cmluZycsXG4gICAgYmVnaW46ICdgJyxcbiAgICBlbmQ6ICdgJyxcbiAgICBjb250YWluczogW1xuICAgICAgaGxqcy5CQUNLU0xBU0hfRVNDQVBFLFxuICAgICAgU1VCU1RcbiAgICBdXG4gIH07XG4gIGNvbnN0IEpTRE9DX0NPTU1FTlQgPSBobGpzLkNPTU1FTlQoXG4gICAgL1xcL1xcKlxcKig/IVxcLykvLFxuICAgICdcXFxcKi8nLFxuICAgIHtcbiAgICAgIHJlbGV2YW5jZTogMCxcbiAgICAgIGNvbnRhaW5zOiBbXG4gICAgICAgIHtcbiAgICAgICAgICBiZWdpbjogJyg/PUBbQS1aYS16XSspJyxcbiAgICAgICAgICByZWxldmFuY2U6IDAsXG4gICAgICAgICAgY29udGFpbnM6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgY2xhc3NOYW1lOiAnZG9jdGFnJyxcbiAgICAgICAgICAgICAgYmVnaW46ICdAW0EtWmEtel0rJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgY2xhc3NOYW1lOiAndHlwZScsXG4gICAgICAgICAgICAgIGJlZ2luOiAnXFxcXHsnLFxuICAgICAgICAgICAgICBlbmQ6ICdcXFxcfScsXG4gICAgICAgICAgICAgIGV4Y2x1ZGVFbmQ6IHRydWUsXG4gICAgICAgICAgICAgIGV4Y2x1ZGVCZWdpbjogdHJ1ZSxcbiAgICAgICAgICAgICAgcmVsZXZhbmNlOiAwXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBjbGFzc05hbWU6ICd2YXJpYWJsZScsXG4gICAgICAgICAgICAgIGJlZ2luOiBJREVOVF9SRSQxICsgJyg/PVxcXFxzKigtKXwkKScsXG4gICAgICAgICAgICAgIGVuZHNQYXJlbnQ6IHRydWUsXG4gICAgICAgICAgICAgIHJlbGV2YW5jZTogMFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIC8vIGVhdCBzcGFjZXMgKG5vdCBuZXdsaW5lcykgc28gd2UgY2FuIGZpbmRcbiAgICAgICAgICAgIC8vIHR5cGVzIG9yIHZhcmlhYmxlc1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBiZWdpbjogLyg/PVteXFxuXSlcXHMvLFxuICAgICAgICAgICAgICByZWxldmFuY2U6IDBcbiAgICAgICAgICAgIH1cbiAgICAgICAgICBdXG4gICAgICAgIH1cbiAgICAgIF1cbiAgICB9XG4gICk7XG4gIGNvbnN0IENPTU1FTlQgPSB7XG4gICAgY2xhc3NOYW1lOiBcImNvbW1lbnRcIixcbiAgICB2YXJpYW50czogW1xuICAgICAgSlNET0NfQ09NTUVOVCxcbiAgICAgIGhsanMuQ19CTE9DS19DT01NRU5UX01PREUsXG4gICAgICBobGpzLkNfTElORV9DT01NRU5UX01PREVcbiAgICBdXG4gIH07XG4gIGNvbnN0IFNVQlNUX0lOVEVSTkFMUyA9IFtcbiAgICBobGpzLkFQT1NfU1RSSU5HX01PREUsXG4gICAgaGxqcy5RVU9URV9TVFJJTkdfTU9ERSxcbiAgICBIVE1MX1RFTVBMQVRFLFxuICAgIENTU19URU1QTEFURSxcbiAgICBURU1QTEFURV9TVFJJTkcsXG4gICAgTlVNQkVSLFxuICAgIGhsanMuUkVHRVhQX01PREVcbiAgXTtcbiAgU1VCU1QuY29udGFpbnMgPSBTVUJTVF9JTlRFUk5BTFNcbiAgICAuY29uY2F0KHtcbiAgICAgIC8vIHdlIG5lZWQgdG8gcGFpciB1cCB7fSBpbnNpZGUgb3VyIHN1YnN0IHRvIHByZXZlbnRcbiAgICAgIC8vIGl0IGZyb20gZW5kaW5nIHRvbyBlYXJseSBieSBtYXRjaGluZyBhbm90aGVyIH1cbiAgICAgIGJlZ2luOiAvXFx7LyxcbiAgICAgIGVuZDogL1xcfS8sXG4gICAgICBrZXl3b3JkczogS0VZV09SRFMkMSxcbiAgICAgIGNvbnRhaW5zOiBbXG4gICAgICAgIFwic2VsZlwiXG4gICAgICBdLmNvbmNhdChTVUJTVF9JTlRFUk5BTFMpXG4gICAgfSk7XG4gIGNvbnN0IFNVQlNUX0FORF9DT01NRU5UUyA9IFtdLmNvbmNhdChDT01NRU5ULCBTVUJTVC5jb250YWlucyk7XG4gIGNvbnN0IFBBUkFNU19DT05UQUlOUyA9IFNVQlNUX0FORF9DT01NRU5UUy5jb25jYXQoW1xuICAgIC8vIGVhdCByZWN1cnNpdmUgcGFyZW5zIGluIHN1YiBleHByZXNzaW9uc1xuICAgIHtcbiAgICAgIGJlZ2luOiAvXFwoLyxcbiAgICAgIGVuZDogL1xcKS8sXG4gICAgICBrZXl3b3JkczogS0VZV09SRFMkMSxcbiAgICAgIGNvbnRhaW5zOiBbXCJzZWxmXCJdLmNvbmNhdChTVUJTVF9BTkRfQ09NTUVOVFMpXG4gICAgfVxuICBdKTtcbiAgY29uc3QgUEFSQU1TID0ge1xuICAgIGNsYXNzTmFtZTogJ3BhcmFtcycsXG4gICAgYmVnaW46IC9cXCgvLFxuICAgIGVuZDogL1xcKS8sXG4gICAgZXhjbHVkZUJlZ2luOiB0cnVlLFxuICAgIGV4Y2x1ZGVFbmQ6IHRydWUsXG4gICAga2V5d29yZHM6IEtFWVdPUkRTJDEsXG4gICAgY29udGFpbnM6IFBBUkFNU19DT05UQUlOU1xuICB9O1xuXG4gIC8vIEVTNiBjbGFzc2VzXG4gIGNvbnN0IENMQVNTX09SX0VYVEVORFMgPSB7XG4gICAgdmFyaWFudHM6IFtcbiAgICAgIHtcbiAgICAgICAgbWF0Y2g6IFtcbiAgICAgICAgICAvY2xhc3MvLFxuICAgICAgICAgIC9cXHMrLyxcbiAgICAgICAgICBJREVOVF9SRSQxXG4gICAgICAgIF0sXG4gICAgICAgIHNjb3BlOiB7XG4gICAgICAgICAgMTogXCJrZXl3b3JkXCIsXG4gICAgICAgICAgMzogXCJ0aXRsZS5jbGFzc1wiXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIG1hdGNoOiBbXG4gICAgICAgICAgL2V4dGVuZHMvLFxuICAgICAgICAgIC9cXHMrLyxcbiAgICAgICAgICBjb25jYXQoSURFTlRfUkUkMSwgXCIoXCIsIGNvbmNhdCgvXFwuLywgSURFTlRfUkUkMSksIFwiKSpcIilcbiAgICAgICAgXSxcbiAgICAgICAgc2NvcGU6IHtcbiAgICAgICAgICAxOiBcImtleXdvcmRcIixcbiAgICAgICAgICAzOiBcInRpdGxlLmNsYXNzLmluaGVyaXRlZFwiXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICBdXG4gIH07XG5cbiAgY29uc3QgQ0xBU1NfUkVGRVJFTkNFID0ge1xuICAgIHJlbGV2YW5jZTogMCxcbiAgICBtYXRjaDogL1xcYltBLVpdW2Etel0rKFtBLVpdW2Etel0rKSovLFxuICAgIGNsYXNzTmFtZTogXCJ0aXRsZS5jbGFzc1wiLFxuICAgIGtleXdvcmRzOiB7XG4gICAgICBfOiBbXG4gICAgICAgIC8vIHNlIHdlIHN0aWxsIGdldCByZWxldmFuY2UgY3JlZGl0IGZvciBKUyBsaWJyYXJ5IGNsYXNzZXNcbiAgICAgICAgLi4uVFlQRVMsXG4gICAgICAgIC4uLkVSUk9SX1RZUEVTXG4gICAgICBdXG4gICAgfVxuICB9O1xuXG4gIGNvbnN0IFVTRV9TVFJJQ1QgPSB7XG4gICAgbGFiZWw6IFwidXNlX3N0cmljdFwiLFxuICAgIGNsYXNzTmFtZTogJ21ldGEnLFxuICAgIHJlbGV2YW5jZTogMTAsXG4gICAgYmVnaW46IC9eXFxzKlsnXCJddXNlIChzdHJpY3R8YXNtKVsnXCJdL1xuICB9O1xuXG4gIGNvbnN0IEZVTkNUSU9OX0RFRklOSVRJT04gPSB7XG4gICAgdmFyaWFudHM6IFtcbiAgICAgIHtcbiAgICAgICAgbWF0Y2g6IFtcbiAgICAgICAgICAvZnVuY3Rpb24vLFxuICAgICAgICAgIC9cXHMrLyxcbiAgICAgICAgICBJREVOVF9SRSQxLFxuICAgICAgICAgIC8oPz1cXHMqXFwoKS9cbiAgICAgICAgXVxuICAgICAgfSxcbiAgICAgIC8vIGFub255bW91cyBmdW5jdGlvblxuICAgICAge1xuICAgICAgICBtYXRjaDogW1xuICAgICAgICAgIC9mdW5jdGlvbi8sXG4gICAgICAgICAgL1xccyooPz1cXCgpL1xuICAgICAgICBdXG4gICAgICB9XG4gICAgXSxcbiAgICBjbGFzc05hbWU6IHtcbiAgICAgIDE6IFwia2V5d29yZFwiLFxuICAgICAgMzogXCJ0aXRsZS5mdW5jdGlvblwiXG4gICAgfSxcbiAgICBsYWJlbDogXCJmdW5jLmRlZlwiLFxuICAgIGNvbnRhaW5zOiBbIFBBUkFNUyBdLFxuICAgIGlsbGVnYWw6IC8lL1xuICB9O1xuXG4gIGNvbnN0IFVQUEVSX0NBU0VfQ09OU1RBTlQgPSB7XG4gICAgcmVsZXZhbmNlOiAwLFxuICAgIG1hdGNoOiAvXFxiW0EtWl1bQS1aXzAtOV0rXFxiLyxcbiAgICBjbGFzc05hbWU6IFwidmFyaWFibGUuY29uc3RhbnRcIlxuICB9O1xuXG4gIGZ1bmN0aW9uIG5vbmVPZihsaXN0KSB7XG4gICAgcmV0dXJuIGNvbmNhdChcIig/IVwiLCBsaXN0LmpvaW4oXCJ8XCIpLCBcIilcIik7XG4gIH1cblxuICBjb25zdCBGVU5DVElPTl9DQUxMID0ge1xuICAgIG1hdGNoOiBjb25jYXQoXG4gICAgICAvXFxiLyxcbiAgICAgIG5vbmVPZihbXG4gICAgICAgIC4uLkJVSUxUX0lOX0dMT0JBTFMsXG4gICAgICAgIFwic3VwZXJcIlxuICAgICAgXSksXG4gICAgICBJREVOVF9SRSQxLCBsb29rYWhlYWQoL1xcKC8pKSxcbiAgICBjbGFzc05hbWU6IFwidGl0bGUuZnVuY3Rpb25cIixcbiAgICByZWxldmFuY2U6IDBcbiAgfTtcblxuICBjb25zdCBQUk9QRVJUWV9BQ0NFU1MgPSB7XG4gICAgYmVnaW46IGNvbmNhdCgvXFwuLywgbG9va2FoZWFkKFxuICAgICAgY29uY2F0KElERU5UX1JFJDEsIC8oPyFbMC05QS1aYS16JF8oXSkvKVxuICAgICkpLFxuICAgIGVuZDogSURFTlRfUkUkMSxcbiAgICBleGNsdWRlQmVnaW46IHRydWUsXG4gICAga2V5d29yZHM6IFwicHJvdG90eXBlXCIsXG4gICAgY2xhc3NOYW1lOiBcInByb3BlcnR5XCIsXG4gICAgcmVsZXZhbmNlOiAwXG4gIH07XG5cbiAgY29uc3QgR0VUVEVSX09SX1NFVFRFUiA9IHtcbiAgICBtYXRjaDogW1xuICAgICAgL2dldHxzZXQvLFxuICAgICAgL1xccysvLFxuICAgICAgSURFTlRfUkUkMSxcbiAgICAgIC8oPz1cXCgpL1xuICAgIF0sXG4gICAgY2xhc3NOYW1lOiB7XG4gICAgICAxOiBcImtleXdvcmRcIixcbiAgICAgIDM6IFwidGl0bGUuZnVuY3Rpb25cIlxuICAgIH0sXG4gICAgY29udGFpbnM6IFtcbiAgICAgIHsgLy8gZWF0IHRvIGF2b2lkIGVtcHR5IHBhcmFtc1xuICAgICAgICBiZWdpbjogL1xcKFxcKS9cbiAgICAgIH0sXG4gICAgICBQQVJBTVNcbiAgICBdXG4gIH07XG5cbiAgY29uc3QgRlVOQ19MRUFEX0lOX1JFID0gJyhcXFxcKCcgK1xuICAgICdbXigpXSooXFxcXCgnICtcbiAgICAnW14oKV0qKFxcXFwoJyArXG4gICAgJ1teKCldKicgK1xuICAgICdcXFxcKVteKCldKikqJyArXG4gICAgJ1xcXFwpW14oKV0qKSonICtcbiAgICAnXFxcXCl8JyArIGhsanMuVU5ERVJTQ09SRV9JREVOVF9SRSArICcpXFxcXHMqPT4nO1xuXG4gIGNvbnN0IEZVTkNUSU9OX1ZBUklBQkxFID0ge1xuICAgIG1hdGNoOiBbXG4gICAgICAvY29uc3R8dmFyfGxldC8sIC9cXHMrLyxcbiAgICAgIElERU5UX1JFJDEsIC9cXHMqLyxcbiAgICAgIC89XFxzKi8sXG4gICAgICBsb29rYWhlYWQoRlVOQ19MRUFEX0lOX1JFKVxuICAgIF0sXG4gICAgY2xhc3NOYW1lOiB7XG4gICAgICAxOiBcImtleXdvcmRcIixcbiAgICAgIDM6IFwidGl0bGUuZnVuY3Rpb25cIlxuICAgIH0sXG4gICAgY29udGFpbnM6IFtcbiAgICAgIFBBUkFNU1xuICAgIF1cbiAgfTtcblxuICByZXR1cm4ge1xuICAgIG5hbWU6ICdKYXZhc2NyaXB0JyxcbiAgICBhbGlhc2VzOiBbJ2pzJywgJ2pzeCcsICdtanMnLCAnY2pzJ10sXG4gICAga2V5d29yZHM6IEtFWVdPUkRTJDEsXG4gICAgLy8gdGhpcyB3aWxsIGJlIGV4dGVuZGVkIGJ5IFR5cGVTY3JpcHRcbiAgICBleHBvcnRzOiB7IFBBUkFNU19DT05UQUlOUyB9LFxuICAgIGlsbGVnYWw6IC8jKD8hWyRfQS16XSkvLFxuICAgIGNvbnRhaW5zOiBbXG4gICAgICBobGpzLlNIRUJBTkcoe1xuICAgICAgICBsYWJlbDogXCJzaGViYW5nXCIsXG4gICAgICAgIGJpbmFyeTogXCJub2RlXCIsXG4gICAgICAgIHJlbGV2YW5jZTogNVxuICAgICAgfSksXG4gICAgICBVU0VfU1RSSUNULFxuICAgICAgaGxqcy5BUE9TX1NUUklOR19NT0RFLFxuICAgICAgaGxqcy5RVU9URV9TVFJJTkdfTU9ERSxcbiAgICAgIEhUTUxfVEVNUExBVEUsXG4gICAgICBDU1NfVEVNUExBVEUsXG4gICAgICBURU1QTEFURV9TVFJJTkcsXG4gICAgICBDT01NRU5ULFxuICAgICAgTlVNQkVSLFxuICAgICAgQ0xBU1NfUkVGRVJFTkNFLFxuICAgICAge1xuICAgICAgICBjbGFzc05hbWU6ICdhdHRyJyxcbiAgICAgICAgYmVnaW46IElERU5UX1JFJDEgKyBsb29rYWhlYWQoJzonKSxcbiAgICAgICAgcmVsZXZhbmNlOiAwXG4gICAgICB9LFxuICAgICAgRlVOQ1RJT05fVkFSSUFCTEUsXG4gICAgICB7IC8vIFwidmFsdWVcIiBjb250YWluZXJcbiAgICAgICAgYmVnaW46ICcoJyArIGhsanMuUkVfU1RBUlRFUlNfUkUgKyAnfFxcXFxiKGNhc2V8cmV0dXJufHRocm93KVxcXFxiKVxcXFxzKicsXG4gICAgICAgIGtleXdvcmRzOiAncmV0dXJuIHRocm93IGNhc2UnLFxuICAgICAgICByZWxldmFuY2U6IDAsXG4gICAgICAgIGNvbnRhaW5zOiBbXG4gICAgICAgICAgQ09NTUVOVCxcbiAgICAgICAgICBobGpzLlJFR0VYUF9NT0RFLFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGNsYXNzTmFtZTogJ2Z1bmN0aW9uJyxcbiAgICAgICAgICAgIC8vIHdlIGhhdmUgdG8gY291bnQgdGhlIHBhcmVucyB0byBtYWtlIHN1cmUgd2UgYWN0dWFsbHkgaGF2ZSB0aGVcbiAgICAgICAgICAgIC8vIGNvcnJlY3QgYm91bmRpbmcgKCApIGJlZm9yZSB0aGUgPT4uICBUaGVyZSBjb3VsZCBiZSBhbnkgbnVtYmVyIG9mXG4gICAgICAgICAgICAvLyBzdWItZXhwcmVzc2lvbnMgaW5zaWRlIGFsc28gc3Vycm91bmRlZCBieSBwYXJlbnMuXG4gICAgICAgICAgICBiZWdpbjogRlVOQ19MRUFEX0lOX1JFLFxuICAgICAgICAgICAgcmV0dXJuQmVnaW46IHRydWUsXG4gICAgICAgICAgICBlbmQ6ICdcXFxccyo9PicsXG4gICAgICAgICAgICBjb250YWluczogW1xuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lOiAncGFyYW1zJyxcbiAgICAgICAgICAgICAgICB2YXJpYW50czogW1xuICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBiZWdpbjogaGxqcy5VTkRFUlNDT1JFX0lERU5UX1JFLFxuICAgICAgICAgICAgICAgICAgICByZWxldmFuY2U6IDBcbiAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgYmVnaW46IC9cXChcXHMqXFwpLyxcbiAgICAgICAgICAgICAgICAgICAgc2tpcDogdHJ1ZVxuICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgYmVnaW46IC9cXCgvLFxuICAgICAgICAgICAgICAgICAgICBlbmQ6IC9cXCkvLFxuICAgICAgICAgICAgICAgICAgICBleGNsdWRlQmVnaW46IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGV4Y2x1ZGVFbmQ6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGtleXdvcmRzOiBLRVlXT1JEUyQxLFxuICAgICAgICAgICAgICAgICAgICBjb250YWluczogUEFSQU1TX0NPTlRBSU5TXG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBdXG4gICAgICAgICAgfSxcbiAgICAgICAgICB7IC8vIGNvdWxkIGJlIGEgY29tbWEgZGVsaW1pdGVkIGxpc3Qgb2YgcGFyYW1zIHRvIGEgZnVuY3Rpb24gY2FsbFxuICAgICAgICAgICAgYmVnaW46IC8sLyxcbiAgICAgICAgICAgIHJlbGV2YW5jZTogMFxuICAgICAgICAgIH0sXG4gICAgICAgICAge1xuICAgICAgICAgICAgbWF0Y2g6IC9cXHMrLyxcbiAgICAgICAgICAgIHJlbGV2YW5jZTogMFxuICAgICAgICAgIH0sXG4gICAgICAgICAgeyAvLyBKU1hcbiAgICAgICAgICAgIHZhcmlhbnRzOiBbXG4gICAgICAgICAgICAgIHsgYmVnaW46IEZSQUdNRU5ULmJlZ2luLCBlbmQ6IEZSQUdNRU5ULmVuZCB9LFxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgYmVnaW46IFhNTF9UQUcuYmVnaW4sXG4gICAgICAgICAgICAgICAgLy8gd2UgY2FyZWZ1bGx5IGNoZWNrIHRoZSBvcGVuaW5nIHRhZyB0byBzZWUgaWYgaXQgdHJ1bHlcbiAgICAgICAgICAgICAgICAvLyBpcyBhIHRhZyBhbmQgbm90IGEgZmFsc2UgcG9zaXRpdmVcbiAgICAgICAgICAgICAgICAnb246YmVnaW4nOiBYTUxfVEFHLmlzVHJ1bHlPcGVuaW5nVGFnLFxuICAgICAgICAgICAgICAgIGVuZDogWE1MX1RBRy5lbmRcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIHN1Ykxhbmd1YWdlOiAneG1sJyxcbiAgICAgICAgICAgIGNvbnRhaW5zOiBbXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBiZWdpbjogWE1MX1RBRy5iZWdpbixcbiAgICAgICAgICAgICAgICBlbmQ6IFhNTF9UQUcuZW5kLFxuICAgICAgICAgICAgICAgIHNraXA6IHRydWUsXG4gICAgICAgICAgICAgICAgY29udGFpbnM6IFsnc2VsZiddXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF1cbiAgICAgICAgICB9XG4gICAgICAgIF0sXG4gICAgICB9LFxuICAgICAgRlVOQ1RJT05fREVGSU5JVElPTixcbiAgICAgIHtcbiAgICAgICAgLy8gcHJldmVudCB0aGlzIGZyb20gZ2V0dGluZyBzd2FsbG93ZWQgdXAgYnkgZnVuY3Rpb25cbiAgICAgICAgLy8gc2luY2UgdGhleSBhcHBlYXIgXCJmdW5jdGlvbiBsaWtlXCJcbiAgICAgICAgYmVnaW5LZXl3b3JkczogXCJ3aGlsZSBpZiBzd2l0Y2ggY2F0Y2ggZm9yXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIC8vIHdlIGhhdmUgdG8gY291bnQgdGhlIHBhcmVucyB0byBtYWtlIHN1cmUgd2UgYWN0dWFsbHkgaGF2ZSB0aGUgY29ycmVjdFxuICAgICAgICAvLyBib3VuZGluZyAoICkuICBUaGVyZSBjb3VsZCBiZSBhbnkgbnVtYmVyIG9mIHN1Yi1leHByZXNzaW9ucyBpbnNpZGVcbiAgICAgICAgLy8gYWxzbyBzdXJyb3VuZGVkIGJ5IHBhcmVucy5cbiAgICAgICAgYmVnaW46ICdcXFxcYig/IWZ1bmN0aW9uKScgKyBobGpzLlVOREVSU0NPUkVfSURFTlRfUkUgK1xuICAgICAgICAgICdcXFxcKCcgKyAvLyBmaXJzdCBwYXJlbnNcbiAgICAgICAgICAnW14oKV0qKFxcXFwoJyArXG4gICAgICAgICAgICAnW14oKV0qKFxcXFwoJyArXG4gICAgICAgICAgICAgICdbXigpXSonICtcbiAgICAgICAgICAgICdcXFxcKVteKCldKikqJyArXG4gICAgICAgICAgJ1xcXFwpW14oKV0qKSonICtcbiAgICAgICAgICAnXFxcXClcXFxccypcXFxceycsIC8vIGVuZCBwYXJlbnNcbiAgICAgICAgcmV0dXJuQmVnaW46dHJ1ZSxcbiAgICAgICAgbGFiZWw6IFwiZnVuYy5kZWZcIixcbiAgICAgICAgY29udGFpbnM6IFtcbiAgICAgICAgICBQQVJBTVMsXG4gICAgICAgICAgaGxqcy5pbmhlcml0KGhsanMuVElUTEVfTU9ERSwgeyBiZWdpbjogSURFTlRfUkUkMSwgY2xhc3NOYW1lOiBcInRpdGxlLmZ1bmN0aW9uXCIgfSlcbiAgICAgICAgXVxuICAgICAgfSxcbiAgICAgIC8vIGNhdGNoIC4uLiBzbyBpdCB3b24ndCB0cmlnZ2VyIHRoZSBwcm9wZXJ0eSBydWxlIGJlbG93XG4gICAgICB7XG4gICAgICAgIG1hdGNoOiAvXFwuXFwuXFwuLyxcbiAgICAgICAgcmVsZXZhbmNlOiAwXG4gICAgICB9LFxuICAgICAgUFJPUEVSVFlfQUNDRVNTLFxuICAgICAgLy8gaGFjazogcHJldmVudHMgZGV0ZWN0aW9uIG9mIGtleXdvcmRzIGluIHNvbWUgY2lyY3Vtc3RhbmNlc1xuICAgICAgLy8gLmtleXdvcmQoKVxuICAgICAgLy8gJGtleXdvcmQgPSB4XG4gICAgICB7XG4gICAgICAgIG1hdGNoOiAnXFxcXCQnICsgSURFTlRfUkUkMSxcbiAgICAgICAgcmVsZXZhbmNlOiAwXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBtYXRjaDogWyAvXFxiY29uc3RydWN0b3IoPz1cXHMqXFwoKS8gXSxcbiAgICAgICAgY2xhc3NOYW1lOiB7IDE6IFwidGl0bGUuZnVuY3Rpb25cIiB9LFxuICAgICAgICBjb250YWluczogWyBQQVJBTVMgXVxuICAgICAgfSxcbiAgICAgIEZVTkNUSU9OX0NBTEwsXG4gICAgICBVUFBFUl9DQVNFX0NPTlNUQU5ULFxuICAgICAgQ0xBU1NfT1JfRVhURU5EUyxcbiAgICAgIEdFVFRFUl9PUl9TRVRURVIsXG4gICAgICB7XG4gICAgICAgIG1hdGNoOiAvXFwkWyguXS8gLy8gcmVsZXZhbmNlIGJvb3N0ZXIgZm9yIGEgcGF0dGVybiBjb21tb24gdG8gSlMgbGliczogYCQoc29tZXRoaW5nKWAgYW5kIGAkLnNvbWV0aGluZ2BcbiAgICAgIH1cbiAgICBdXG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGphdmFzY3JpcHQ7XG4iLCJjb25zdCBNT0RFUyA9IChobGpzKSA9PiB7XG4gIHJldHVybiB7XG4gICAgSU1QT1JUQU5UOiB7XG4gICAgICBzY29wZTogJ21ldGEnLFxuICAgICAgYmVnaW46ICchaW1wb3J0YW50J1xuICAgIH0sXG4gICAgSEVYQ09MT1I6IHtcbiAgICAgIHNjb3BlOiAnbnVtYmVyJyxcbiAgICAgIGJlZ2luOiAnIyhbYS1mQS1GMC05XXs2fXxbYS1mQS1GMC05XXszfSknXG4gICAgfSxcbiAgICBBVFRSSUJVVEVfU0VMRUNUT1JfTU9ERToge1xuICAgICAgc2NvcGU6ICdzZWxlY3Rvci1hdHRyJyxcbiAgICAgIGJlZ2luOiAvXFxbLyxcbiAgICAgIGVuZDogL1xcXS8sXG4gICAgICBpbGxlZ2FsOiAnJCcsXG4gICAgICBjb250YWluczogW1xuICAgICAgICBobGpzLkFQT1NfU1RSSU5HX01PREUsXG4gICAgICAgIGhsanMuUVVPVEVfU1RSSU5HX01PREVcbiAgICAgIF1cbiAgICB9LFxuICAgIENTU19OVU1CRVJfTU9ERToge1xuICAgICAgc2NvcGU6ICdudW1iZXInLFxuICAgICAgYmVnaW46IGhsanMuTlVNQkVSX1JFICsgJygnICtcbiAgICAgICAgJyV8ZW18ZXh8Y2h8cmVtJyArXG4gICAgICAgICd8dnd8dmh8dm1pbnx2bWF4JyArXG4gICAgICAgICd8Y218bW18aW58cHR8cGN8cHgnICtcbiAgICAgICAgJ3xkZWd8Z3JhZHxyYWR8dHVybicgK1xuICAgICAgICAnfHN8bXMnICtcbiAgICAgICAgJ3xIenxrSHonICtcbiAgICAgICAgJ3xkcGl8ZHBjbXxkcHB4JyArXG4gICAgICAgICcpPycsXG4gICAgICByZWxldmFuY2U6IDBcbiAgICB9LFxuICAgIENTU19WQVJJQUJMRToge1xuICAgICAgY2xhc3NOYW1lOiBcImF0dHJcIixcbiAgICAgIGJlZ2luOiAvLS1bQS1aYS16XVtBLVphLXowLTlfLV0qL1xuICAgIH1cbiAgfTtcbn07XG5cbmNvbnN0IFRBR1MgPSBbXG4gICdhJyxcbiAgJ2FiYnInLFxuICAnYWRkcmVzcycsXG4gICdhcnRpY2xlJyxcbiAgJ2FzaWRlJyxcbiAgJ2F1ZGlvJyxcbiAgJ2InLFxuICAnYmxvY2txdW90ZScsXG4gICdib2R5JyxcbiAgJ2J1dHRvbicsXG4gICdjYW52YXMnLFxuICAnY2FwdGlvbicsXG4gICdjaXRlJyxcbiAgJ2NvZGUnLFxuICAnZGQnLFxuICAnZGVsJyxcbiAgJ2RldGFpbHMnLFxuICAnZGZuJyxcbiAgJ2RpdicsXG4gICdkbCcsXG4gICdkdCcsXG4gICdlbScsXG4gICdmaWVsZHNldCcsXG4gICdmaWdjYXB0aW9uJyxcbiAgJ2ZpZ3VyZScsXG4gICdmb290ZXInLFxuICAnZm9ybScsXG4gICdoMScsXG4gICdoMicsXG4gICdoMycsXG4gICdoNCcsXG4gICdoNScsXG4gICdoNicsXG4gICdoZWFkZXInLFxuICAnaGdyb3VwJyxcbiAgJ2h0bWwnLFxuICAnaScsXG4gICdpZnJhbWUnLFxuICAnaW1nJyxcbiAgJ2lucHV0JyxcbiAgJ2lucycsXG4gICdrYmQnLFxuICAnbGFiZWwnLFxuICAnbGVnZW5kJyxcbiAgJ2xpJyxcbiAgJ21haW4nLFxuICAnbWFyaycsXG4gICdtZW51JyxcbiAgJ25hdicsXG4gICdvYmplY3QnLFxuICAnb2wnLFxuICAncCcsXG4gICdxJyxcbiAgJ3F1b3RlJyxcbiAgJ3NhbXAnLFxuICAnc2VjdGlvbicsXG4gICdzcGFuJyxcbiAgJ3N0cm9uZycsXG4gICdzdW1tYXJ5JyxcbiAgJ3N1cCcsXG4gICd0YWJsZScsXG4gICd0Ym9keScsXG4gICd0ZCcsXG4gICd0ZXh0YXJlYScsXG4gICd0Zm9vdCcsXG4gICd0aCcsXG4gICd0aGVhZCcsXG4gICd0aW1lJyxcbiAgJ3RyJyxcbiAgJ3VsJyxcbiAgJ3ZhcicsXG4gICd2aWRlbydcbl07XG5cbmNvbnN0IE1FRElBX0ZFQVRVUkVTID0gW1xuICAnYW55LWhvdmVyJyxcbiAgJ2FueS1wb2ludGVyJyxcbiAgJ2FzcGVjdC1yYXRpbycsXG4gICdjb2xvcicsXG4gICdjb2xvci1nYW11dCcsXG4gICdjb2xvci1pbmRleCcsXG4gICdkZXZpY2UtYXNwZWN0LXJhdGlvJyxcbiAgJ2RldmljZS1oZWlnaHQnLFxuICAnZGV2aWNlLXdpZHRoJyxcbiAgJ2Rpc3BsYXktbW9kZScsXG4gICdmb3JjZWQtY29sb3JzJyxcbiAgJ2dyaWQnLFxuICAnaGVpZ2h0JyxcbiAgJ2hvdmVyJyxcbiAgJ2ludmVydGVkLWNvbG9ycycsXG4gICdtb25vY2hyb21lJyxcbiAgJ29yaWVudGF0aW9uJyxcbiAgJ292ZXJmbG93LWJsb2NrJyxcbiAgJ292ZXJmbG93LWlubGluZScsXG4gICdwb2ludGVyJyxcbiAgJ3ByZWZlcnMtY29sb3Itc2NoZW1lJyxcbiAgJ3ByZWZlcnMtY29udHJhc3QnLFxuICAncHJlZmVycy1yZWR1Y2VkLW1vdGlvbicsXG4gICdwcmVmZXJzLXJlZHVjZWQtdHJhbnNwYXJlbmN5JyxcbiAgJ3Jlc29sdXRpb24nLFxuICAnc2NhbicsXG4gICdzY3JpcHRpbmcnLFxuICAndXBkYXRlJyxcbiAgJ3dpZHRoJyxcbiAgLy8gVE9ETzogZmluZCBhIGJldHRlciBzb2x1dGlvbj9cbiAgJ21pbi13aWR0aCcsXG4gICdtYXgtd2lkdGgnLFxuICAnbWluLWhlaWdodCcsXG4gICdtYXgtaGVpZ2h0J1xuXTtcblxuLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQ1NTL1BzZXVkby1jbGFzc2VzXG5jb25zdCBQU0VVRE9fQ0xBU1NFUyA9IFtcbiAgJ2FjdGl2ZScsXG4gICdhbnktbGluaycsXG4gICdibGFuaycsXG4gICdjaGVja2VkJyxcbiAgJ2N1cnJlbnQnLFxuICAnZGVmYXVsdCcsXG4gICdkZWZpbmVkJyxcbiAgJ2RpcicsIC8vIGRpcigpXG4gICdkaXNhYmxlZCcsXG4gICdkcm9wJyxcbiAgJ2VtcHR5JyxcbiAgJ2VuYWJsZWQnLFxuICAnZmlyc3QnLFxuICAnZmlyc3QtY2hpbGQnLFxuICAnZmlyc3Qtb2YtdHlwZScsXG4gICdmdWxsc2NyZWVuJyxcbiAgJ2Z1dHVyZScsXG4gICdmb2N1cycsXG4gICdmb2N1cy12aXNpYmxlJyxcbiAgJ2ZvY3VzLXdpdGhpbicsXG4gICdoYXMnLCAvLyBoYXMoKVxuICAnaG9zdCcsIC8vIGhvc3Qgb3IgaG9zdCgpXG4gICdob3N0LWNvbnRleHQnLCAvLyBob3N0LWNvbnRleHQoKVxuICAnaG92ZXInLFxuICAnaW5kZXRlcm1pbmF0ZScsXG4gICdpbi1yYW5nZScsXG4gICdpbnZhbGlkJyxcbiAgJ2lzJywgLy8gaXMoKVxuICAnbGFuZycsIC8vIGxhbmcoKVxuICAnbGFzdC1jaGlsZCcsXG4gICdsYXN0LW9mLXR5cGUnLFxuICAnbGVmdCcsXG4gICdsaW5rJyxcbiAgJ2xvY2FsLWxpbmsnLFxuICAnbm90JywgLy8gbm90KClcbiAgJ250aC1jaGlsZCcsIC8vIG50aC1jaGlsZCgpXG4gICdudGgtY29sJywgLy8gbnRoLWNvbCgpXG4gICdudGgtbGFzdC1jaGlsZCcsIC8vIG50aC1sYXN0LWNoaWxkKClcbiAgJ250aC1sYXN0LWNvbCcsIC8vIG50aC1sYXN0LWNvbCgpXG4gICdudGgtbGFzdC1vZi10eXBlJywgLy9udGgtbGFzdC1vZi10eXBlKClcbiAgJ250aC1vZi10eXBlJywgLy9udGgtb2YtdHlwZSgpXG4gICdvbmx5LWNoaWxkJyxcbiAgJ29ubHktb2YtdHlwZScsXG4gICdvcHRpb25hbCcsXG4gICdvdXQtb2YtcmFuZ2UnLFxuICAncGFzdCcsXG4gICdwbGFjZWhvbGRlci1zaG93bicsXG4gICdyZWFkLW9ubHknLFxuICAncmVhZC13cml0ZScsXG4gICdyZXF1aXJlZCcsXG4gICdyaWdodCcsXG4gICdyb290JyxcbiAgJ3Njb3BlJyxcbiAgJ3RhcmdldCcsXG4gICd0YXJnZXQtd2l0aGluJyxcbiAgJ3VzZXItaW52YWxpZCcsXG4gICd2YWxpZCcsXG4gICd2aXNpdGVkJyxcbiAgJ3doZXJlJyAvLyB3aGVyZSgpXG5dO1xuXG4vLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9DU1MvUHNldWRvLWVsZW1lbnRzXG5jb25zdCBQU0VVRE9fRUxFTUVOVFMgPSBbXG4gICdhZnRlcicsXG4gICdiYWNrZHJvcCcsXG4gICdiZWZvcmUnLFxuICAnY3VlJyxcbiAgJ2N1ZS1yZWdpb24nLFxuICAnZmlyc3QtbGV0dGVyJyxcbiAgJ2ZpcnN0LWxpbmUnLFxuICAnZ3JhbW1hci1lcnJvcicsXG4gICdtYXJrZXInLFxuICAncGFydCcsXG4gICdwbGFjZWhvbGRlcicsXG4gICdzZWxlY3Rpb24nLFxuICAnc2xvdHRlZCcsXG4gICdzcGVsbGluZy1lcnJvcidcbl07XG5cbmNvbnN0IEFUVFJJQlVURVMgPSBbXG4gICdhbGlnbi1jb250ZW50JyxcbiAgJ2FsaWduLWl0ZW1zJyxcbiAgJ2FsaWduLXNlbGYnLFxuICAnYW5pbWF0aW9uJyxcbiAgJ2FuaW1hdGlvbi1kZWxheScsXG4gICdhbmltYXRpb24tZGlyZWN0aW9uJyxcbiAgJ2FuaW1hdGlvbi1kdXJhdGlvbicsXG4gICdhbmltYXRpb24tZmlsbC1tb2RlJyxcbiAgJ2FuaW1hdGlvbi1pdGVyYXRpb24tY291bnQnLFxuICAnYW5pbWF0aW9uLW5hbWUnLFxuICAnYW5pbWF0aW9uLXBsYXktc3RhdGUnLFxuICAnYW5pbWF0aW9uLXRpbWluZy1mdW5jdGlvbicsXG4gICdhdXRvJyxcbiAgJ2JhY2tmYWNlLXZpc2liaWxpdHknLFxuICAnYmFja2dyb3VuZCcsXG4gICdiYWNrZ3JvdW5kLWF0dGFjaG1lbnQnLFxuICAnYmFja2dyb3VuZC1jbGlwJyxcbiAgJ2JhY2tncm91bmQtY29sb3InLFxuICAnYmFja2dyb3VuZC1pbWFnZScsXG4gICdiYWNrZ3JvdW5kLW9yaWdpbicsXG4gICdiYWNrZ3JvdW5kLXBvc2l0aW9uJyxcbiAgJ2JhY2tncm91bmQtcmVwZWF0JyxcbiAgJ2JhY2tncm91bmQtc2l6ZScsXG4gICdib3JkZXInLFxuICAnYm9yZGVyLWJvdHRvbScsXG4gICdib3JkZXItYm90dG9tLWNvbG9yJyxcbiAgJ2JvcmRlci1ib3R0b20tbGVmdC1yYWRpdXMnLFxuICAnYm9yZGVyLWJvdHRvbS1yaWdodC1yYWRpdXMnLFxuICAnYm9yZGVyLWJvdHRvbS1zdHlsZScsXG4gICdib3JkZXItYm90dG9tLXdpZHRoJyxcbiAgJ2JvcmRlci1jb2xsYXBzZScsXG4gICdib3JkZXItY29sb3InLFxuICAnYm9yZGVyLWltYWdlJyxcbiAgJ2JvcmRlci1pbWFnZS1vdXRzZXQnLFxuICAnYm9yZGVyLWltYWdlLXJlcGVhdCcsXG4gICdib3JkZXItaW1hZ2Utc2xpY2UnLFxuICAnYm9yZGVyLWltYWdlLXNvdXJjZScsXG4gICdib3JkZXItaW1hZ2Utd2lkdGgnLFxuICAnYm9yZGVyLWxlZnQnLFxuICAnYm9yZGVyLWxlZnQtY29sb3InLFxuICAnYm9yZGVyLWxlZnQtc3R5bGUnLFxuICAnYm9yZGVyLWxlZnQtd2lkdGgnLFxuICAnYm9yZGVyLXJhZGl1cycsXG4gICdib3JkZXItcmlnaHQnLFxuICAnYm9yZGVyLXJpZ2h0LWNvbG9yJyxcbiAgJ2JvcmRlci1yaWdodC1zdHlsZScsXG4gICdib3JkZXItcmlnaHQtd2lkdGgnLFxuICAnYm9yZGVyLXNwYWNpbmcnLFxuICAnYm9yZGVyLXN0eWxlJyxcbiAgJ2JvcmRlci10b3AnLFxuICAnYm9yZGVyLXRvcC1jb2xvcicsXG4gICdib3JkZXItdG9wLWxlZnQtcmFkaXVzJyxcbiAgJ2JvcmRlci10b3AtcmlnaHQtcmFkaXVzJyxcbiAgJ2JvcmRlci10b3Atc3R5bGUnLFxuICAnYm9yZGVyLXRvcC13aWR0aCcsXG4gICdib3JkZXItd2lkdGgnLFxuICAnYm90dG9tJyxcbiAgJ2JveC1kZWNvcmF0aW9uLWJyZWFrJyxcbiAgJ2JveC1zaGFkb3cnLFxuICAnYm94LXNpemluZycsXG4gICdicmVhay1hZnRlcicsXG4gICdicmVhay1iZWZvcmUnLFxuICAnYnJlYWstaW5zaWRlJyxcbiAgJ2NhcHRpb24tc2lkZScsXG4gICdjbGVhcicsXG4gICdjbGlwJyxcbiAgJ2NsaXAtcGF0aCcsXG4gICdjb2xvcicsXG4gICdjb2x1bW4tY291bnQnLFxuICAnY29sdW1uLWZpbGwnLFxuICAnY29sdW1uLWdhcCcsXG4gICdjb2x1bW4tcnVsZScsXG4gICdjb2x1bW4tcnVsZS1jb2xvcicsXG4gICdjb2x1bW4tcnVsZS1zdHlsZScsXG4gICdjb2x1bW4tcnVsZS13aWR0aCcsXG4gICdjb2x1bW4tc3BhbicsXG4gICdjb2x1bW4td2lkdGgnLFxuICAnY29sdW1ucycsXG4gICdjb250ZW50JyxcbiAgJ2NvdW50ZXItaW5jcmVtZW50JyxcbiAgJ2NvdW50ZXItcmVzZXQnLFxuICAnY3Vyc29yJyxcbiAgJ2RpcmVjdGlvbicsXG4gICdkaXNwbGF5JyxcbiAgJ2VtcHR5LWNlbGxzJyxcbiAgJ2ZpbHRlcicsXG4gICdmbGV4JyxcbiAgJ2ZsZXgtYmFzaXMnLFxuICAnZmxleC1kaXJlY3Rpb24nLFxuICAnZmxleC1mbG93JyxcbiAgJ2ZsZXgtZ3JvdycsXG4gICdmbGV4LXNocmluaycsXG4gICdmbGV4LXdyYXAnLFxuICAnZmxvYXQnLFxuICAnZm9udCcsXG4gICdmb250LWRpc3BsYXknLFxuICAnZm9udC1mYW1pbHknLFxuICAnZm9udC1mZWF0dXJlLXNldHRpbmdzJyxcbiAgJ2ZvbnQta2VybmluZycsXG4gICdmb250LWxhbmd1YWdlLW92ZXJyaWRlJyxcbiAgJ2ZvbnQtc2l6ZScsXG4gICdmb250LXNpemUtYWRqdXN0JyxcbiAgJ2ZvbnQtc21vb3RoaW5nJyxcbiAgJ2ZvbnQtc3RyZXRjaCcsXG4gICdmb250LXN0eWxlJyxcbiAgJ2ZvbnQtdmFyaWFudCcsXG4gICdmb250LXZhcmlhbnQtbGlnYXR1cmVzJyxcbiAgJ2ZvbnQtdmFyaWF0aW9uLXNldHRpbmdzJyxcbiAgJ2ZvbnQtd2VpZ2h0JyxcbiAgJ2hlaWdodCcsXG4gICdoeXBoZW5zJyxcbiAgJ2ljb24nLFxuICAnaW1hZ2Utb3JpZW50YXRpb24nLFxuICAnaW1hZ2UtcmVuZGVyaW5nJyxcbiAgJ2ltYWdlLXJlc29sdXRpb24nLFxuICAnaW1lLW1vZGUnLFxuICAnaW5oZXJpdCcsXG4gICdpbml0aWFsJyxcbiAgJ2p1c3RpZnktY29udGVudCcsXG4gICdsZWZ0JyxcbiAgJ2xldHRlci1zcGFjaW5nJyxcbiAgJ2xpbmUtaGVpZ2h0JyxcbiAgJ2xpc3Qtc3R5bGUnLFxuICAnbGlzdC1zdHlsZS1pbWFnZScsXG4gICdsaXN0LXN0eWxlLXBvc2l0aW9uJyxcbiAgJ2xpc3Qtc3R5bGUtdHlwZScsXG4gICdtYXJnaW4nLFxuICAnbWFyZ2luLWJvdHRvbScsXG4gICdtYXJnaW4tbGVmdCcsXG4gICdtYXJnaW4tcmlnaHQnLFxuICAnbWFyZ2luLXRvcCcsXG4gICdtYXJrcycsXG4gICdtYXNrJyxcbiAgJ21heC1oZWlnaHQnLFxuICAnbWF4LXdpZHRoJyxcbiAgJ21pbi1oZWlnaHQnLFxuICAnbWluLXdpZHRoJyxcbiAgJ25hdi1kb3duJyxcbiAgJ25hdi1pbmRleCcsXG4gICduYXYtbGVmdCcsXG4gICduYXYtcmlnaHQnLFxuICAnbmF2LXVwJyxcbiAgJ25vbmUnLFxuICAnbm9ybWFsJyxcbiAgJ29iamVjdC1maXQnLFxuICAnb2JqZWN0LXBvc2l0aW9uJyxcbiAgJ29wYWNpdHknLFxuICAnb3JkZXInLFxuICAnb3JwaGFucycsXG4gICdvdXRsaW5lJyxcbiAgJ291dGxpbmUtY29sb3InLFxuICAnb3V0bGluZS1vZmZzZXQnLFxuICAnb3V0bGluZS1zdHlsZScsXG4gICdvdXRsaW5lLXdpZHRoJyxcbiAgJ292ZXJmbG93JyxcbiAgJ292ZXJmbG93LXdyYXAnLFxuICAnb3ZlcmZsb3cteCcsXG4gICdvdmVyZmxvdy15JyxcbiAgJ3BhZGRpbmcnLFxuICAncGFkZGluZy1ib3R0b20nLFxuICAncGFkZGluZy1sZWZ0JyxcbiAgJ3BhZGRpbmctcmlnaHQnLFxuICAncGFkZGluZy10b3AnLFxuICAncGFnZS1icmVhay1hZnRlcicsXG4gICdwYWdlLWJyZWFrLWJlZm9yZScsXG4gICdwYWdlLWJyZWFrLWluc2lkZScsXG4gICdwZXJzcGVjdGl2ZScsXG4gICdwZXJzcGVjdGl2ZS1vcmlnaW4nLFxuICAncG9pbnRlci1ldmVudHMnLFxuICAncG9zaXRpb24nLFxuICAncXVvdGVzJyxcbiAgJ3Jlc2l6ZScsXG4gICdyaWdodCcsXG4gICdzcmMnLCAvLyBAZm9udC1mYWNlXG4gICd0YWItc2l6ZScsXG4gICd0YWJsZS1sYXlvdXQnLFxuICAndGV4dC1hbGlnbicsXG4gICd0ZXh0LWFsaWduLWxhc3QnLFxuICAndGV4dC1kZWNvcmF0aW9uJyxcbiAgJ3RleHQtZGVjb3JhdGlvbi1jb2xvcicsXG4gICd0ZXh0LWRlY29yYXRpb24tbGluZScsXG4gICd0ZXh0LWRlY29yYXRpb24tc3R5bGUnLFxuICAndGV4dC1pbmRlbnQnLFxuICAndGV4dC1vdmVyZmxvdycsXG4gICd0ZXh0LXJlbmRlcmluZycsXG4gICd0ZXh0LXNoYWRvdycsXG4gICd0ZXh0LXRyYW5zZm9ybScsXG4gICd0ZXh0LXVuZGVybGluZS1wb3NpdGlvbicsXG4gICd0b3AnLFxuICAndHJhbnNmb3JtJyxcbiAgJ3RyYW5zZm9ybS1vcmlnaW4nLFxuICAndHJhbnNmb3JtLXN0eWxlJyxcbiAgJ3RyYW5zaXRpb24nLFxuICAndHJhbnNpdGlvbi1kZWxheScsXG4gICd0cmFuc2l0aW9uLWR1cmF0aW9uJyxcbiAgJ3RyYW5zaXRpb24tcHJvcGVydHknLFxuICAndHJhbnNpdGlvbi10aW1pbmctZnVuY3Rpb24nLFxuICAndW5pY29kZS1iaWRpJyxcbiAgJ3ZlcnRpY2FsLWFsaWduJyxcbiAgJ3Zpc2liaWxpdHknLFxuICAnd2hpdGUtc3BhY2UnLFxuICAnd2lkb3dzJyxcbiAgJ3dpZHRoJyxcbiAgJ3dvcmQtYnJlYWsnLFxuICAnd29yZC1zcGFjaW5nJyxcbiAgJ3dvcmQtd3JhcCcsXG4gICd6LWluZGV4J1xuICAvLyByZXZlcnNlIG1ha2VzIHN1cmUgbG9uZ2VyIGF0dHJpYnV0ZXMgYGZvbnQtd2VpZ2h0YCBhcmUgbWF0Y2hlZCBmdWxseVxuICAvLyBpbnN0ZWFkIG9mIGdldHRpbmcgZmFsc2UgcG9zaXRpdmVzIG9uIHNheSBgZm9udGBcbl0ucmV2ZXJzZSgpO1xuXG4vKlxuTGFuZ3VhZ2U6IFNDU1NcbkRlc2NyaXB0aW9uOiBTY3NzIGlzIGFuIGV4dGVuc2lvbiBvZiB0aGUgc3ludGF4IG9mIENTUy5cbkF1dGhvcjogS3VydCBFbWNoIDxrdXJ0QGt1cnRlbWNoLmNvbT5cbldlYnNpdGU6IGh0dHBzOi8vc2Fzcy1sYW5nLmNvbVxuQ2F0ZWdvcnk6IGNvbW1vbiwgY3NzLCB3ZWJcbiovXG5cbi8qKiBAdHlwZSBMYW5ndWFnZUZuICovXG5mdW5jdGlvbiBzY3NzKGhsanMpIHtcbiAgY29uc3QgbW9kZXMgPSBNT0RFUyhobGpzKTtcbiAgY29uc3QgUFNFVURPX0VMRU1FTlRTJDEgPSBQU0VVRE9fRUxFTUVOVFM7XG4gIGNvbnN0IFBTRVVET19DTEFTU0VTJDEgPSBQU0VVRE9fQ0xBU1NFUztcblxuICBjb25zdCBBVF9JREVOVElGSUVSID0gJ0BbYS16LV0rJzsgLy8gQGZvbnQtZmFjZVxuICBjb25zdCBBVF9NT0RJRklFUlMgPSBcImFuZCBvciBub3Qgb25seVwiO1xuICBjb25zdCBJREVOVF9SRSA9ICdbYS16QS1aLV1bYS16QS1aMC05Xy1dKic7XG4gIGNvbnN0IFZBUklBQkxFID0ge1xuICAgIGNsYXNzTmFtZTogJ3ZhcmlhYmxlJyxcbiAgICBiZWdpbjogJyhcXFxcJCcgKyBJREVOVF9SRSArICcpXFxcXGInXG4gIH07XG5cbiAgcmV0dXJuIHtcbiAgICBuYW1lOiAnU0NTUycsXG4gICAgY2FzZV9pbnNlbnNpdGl2ZTogdHJ1ZSxcbiAgICBpbGxlZ2FsOiAnWz0vfFxcJ10nLFxuICAgIGNvbnRhaW5zOiBbXG4gICAgICBobGpzLkNfTElORV9DT01NRU5UX01PREUsXG4gICAgICBobGpzLkNfQkxPQ0tfQ09NTUVOVF9NT0RFLFxuICAgICAge1xuICAgICAgICBjbGFzc05hbWU6ICdzZWxlY3Rvci1pZCcsXG4gICAgICAgIGJlZ2luOiAnI1tBLVphLXowLTlfLV0rJyxcbiAgICAgICAgcmVsZXZhbmNlOiAwXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBjbGFzc05hbWU6ICdzZWxlY3Rvci1jbGFzcycsXG4gICAgICAgIGJlZ2luOiAnXFxcXC5bQS1aYS16MC05Xy1dKycsXG4gICAgICAgIHJlbGV2YW5jZTogMFxuICAgICAgfSxcbiAgICAgIG1vZGVzLkFUVFJJQlVURV9TRUxFQ1RPUl9NT0RFLFxuICAgICAge1xuICAgICAgICBjbGFzc05hbWU6ICdzZWxlY3Rvci10YWcnLFxuICAgICAgICBiZWdpbjogJ1xcXFxiKCcgKyBUQUdTLmpvaW4oJ3wnKSArICcpXFxcXGInLFxuICAgICAgICAvLyB3YXMgdGhlcmUsIGJlZm9yZSwgYnV0IHdoeT9cbiAgICAgICAgcmVsZXZhbmNlOiAwXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBjbGFzc05hbWU6ICdzZWxlY3Rvci1wc2V1ZG8nLFxuICAgICAgICBiZWdpbjogJzooJyArIFBTRVVET19DTEFTU0VTJDEuam9pbignfCcpICsgJyknXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBjbGFzc05hbWU6ICdzZWxlY3Rvci1wc2V1ZG8nLFxuICAgICAgICBiZWdpbjogJzo6KCcgKyBQU0VVRE9fRUxFTUVOVFMkMS5qb2luKCd8JykgKyAnKSdcbiAgICAgIH0sXG4gICAgICBWQVJJQUJMRSxcbiAgICAgIHsgLy8gcHNldWRvLXNlbGVjdG9yIHBhcmFtc1xuICAgICAgICBiZWdpbjogL1xcKC8sXG4gICAgICAgIGVuZDogL1xcKS8sXG4gICAgICAgIGNvbnRhaW5zOiBbIG1vZGVzLkNTU19OVU1CRVJfTU9ERSBdXG4gICAgICB9LFxuICAgICAgbW9kZXMuQ1NTX1ZBUklBQkxFLFxuICAgICAge1xuICAgICAgICBjbGFzc05hbWU6ICdhdHRyaWJ1dGUnLFxuICAgICAgICBiZWdpbjogJ1xcXFxiKCcgKyBBVFRSSUJVVEVTLmpvaW4oJ3wnKSArICcpXFxcXGInXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBiZWdpbjogJ1xcXFxiKHdoaXRlc3BhY2V8d2FpdHx3LXJlc2l6ZXx2aXNpYmxlfHZlcnRpY2FsLXRleHR8dmVydGljYWwtaWRlb2dyYXBoaWN8dXBwZXJjYXNlfHVwcGVyLXJvbWFufHVwcGVyLWFscGhhfHVuZGVybGluZXx0cmFuc3BhcmVudHx0b3B8dGhpbnx0aGlja3x0ZXh0fHRleHQtdG9wfHRleHQtYm90dG9tfHRiLXJsfHRhYmxlLWhlYWRlci1ncm91cHx0YWJsZS1mb290ZXItZ3JvdXB8c3ctcmVzaXplfHN1cGVyfHN0cmljdHxzdGF0aWN8c3F1YXJlfHNvbGlkfHNtYWxsLWNhcHN8c2VwYXJhdGV8c2UtcmVzaXplfHNjcm9sbHxzLXJlc2l6ZXxydGx8cm93LXJlc2l6ZXxyaWRnZXxyaWdodHxyZXBlYXR8cmVwZWF0LXl8cmVwZWF0LXh8cmVsYXRpdmV8cHJvZ3Jlc3N8cG9pbnRlcnxvdmVybGluZXxvdXRzaWRlfG91dHNldHxvYmxpcXVlfG5vd3JhcHxub3QtYWxsb3dlZHxub3JtYWx8bm9uZXxudy1yZXNpemV8bm8tcmVwZWF0fG5vLWRyb3B8bmV3c3BhcGVyfG5lLXJlc2l6ZXxuLXJlc2l6ZXxtb3ZlfG1pZGRsZXxtZWRpdW18bHRyfGxyLXRifGxvd2VyY2FzZXxsb3dlci1yb21hbnxsb3dlci1hbHBoYXxsb29zZXxsaXN0LWl0ZW18bGluZXxsaW5lLXRocm91Z2h8bGluZS1lZGdlfGxpZ2h0ZXJ8bGVmdHxrZWVwLWFsbHxqdXN0aWZ5fGl0YWxpY3xpbnRlci13b3JkfGludGVyLWlkZW9ncmFwaHxpbnNpZGV8aW5zZXR8aW5saW5lfGlubGluZS1ibG9ja3xpbmhlcml0fGluYWN0aXZlfGlkZW9ncmFwaC1zcGFjZXxpZGVvZ3JhcGgtcGFyZW50aGVzaXN8aWRlb2dyYXBoLW51bWVyaWN8aWRlb2dyYXBoLWFscGhhfGhvcml6b250YWx8aGlkZGVufGhlbHB8aGFuZHxncm9vdmV8Zml4ZWR8ZWxsaXBzaXN8ZS1yZXNpemV8ZG91YmxlfGRvdHRlZHxkaXN0cmlidXRlfGRpc3RyaWJ1dGUtc3BhY2V8ZGlzdHJpYnV0ZS1sZXR0ZXJ8ZGlzdHJpYnV0ZS1hbGwtbGluZXN8ZGlzY3xkaXNhYmxlZHxkZWZhdWx0fGRlY2ltYWx8ZGFzaGVkfGNyb3NzaGFpcnxjb2xsYXBzZXxjb2wtcmVzaXplfGNpcmNsZXxjaGFyfGNlbnRlcnxjYXBpdGFsaXplfGJyZWFrLXdvcmR8YnJlYWstYWxsfGJvdHRvbXxib3RofGJvbGRlcnxib2xkfGJsb2NrfGJpZGktb3ZlcnJpZGV8YmVsb3d8YmFzZWxpbmV8YXV0b3xhbHdheXN8YWxsLXNjcm9sbHxhYnNvbHV0ZXx0YWJsZXx0YWJsZS1jZWxsKVxcXFxiJ1xuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgYmVnaW46ICc6JyxcbiAgICAgICAgZW5kOiAnOycsXG4gICAgICAgIGNvbnRhaW5zOiBbXG4gICAgICAgICAgVkFSSUFCTEUsXG4gICAgICAgICAgbW9kZXMuSEVYQ09MT1IsXG4gICAgICAgICAgbW9kZXMuQ1NTX05VTUJFUl9NT0RFLFxuICAgICAgICAgIGhsanMuUVVPVEVfU1RSSU5HX01PREUsXG4gICAgICAgICAgaGxqcy5BUE9TX1NUUklOR19NT0RFLFxuICAgICAgICAgIG1vZGVzLklNUE9SVEFOVFxuICAgICAgICBdXG4gICAgICB9LFxuICAgICAgLy8gbWF0Y2hpbmcgdGhlc2UgaGVyZSBhbGxvd3MgdXMgdG8gdHJlYXQgdGhlbSBtb3JlIGxpa2UgcmVndWxhciBDU1NcbiAgICAgIC8vIHJ1bGVzIHNvIGV2ZXJ5dGhpbmcgYmV0d2VlbiB0aGUge30gZ2V0cyByZWd1bGFyIHJ1bGUgaGlnaGxpZ2h0aW5nLFxuICAgICAgLy8gd2hpY2ggaXMgd2hhdCB3ZSB3YW50IGZvciBwYWdlIGFuZCBmb250LWZhY2VcbiAgICAgIHtcbiAgICAgICAgYmVnaW46ICdAKHBhZ2V8Zm9udC1mYWNlKScsXG4gICAgICAgIGtleXdvcmRzOiB7XG4gICAgICAgICAgJHBhdHRlcm46IEFUX0lERU5USUZJRVIsXG4gICAgICAgICAga2V5d29yZDogJ0BwYWdlIEBmb250LWZhY2UnXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGJlZ2luOiAnQCcsXG4gICAgICAgIGVuZDogJ1t7O10nLFxuICAgICAgICByZXR1cm5CZWdpbjogdHJ1ZSxcbiAgICAgICAga2V5d29yZHM6IHtcbiAgICAgICAgICAkcGF0dGVybjogL1thLXotXSsvLFxuICAgICAgICAgIGtleXdvcmQ6IEFUX01PRElGSUVSUyxcbiAgICAgICAgICBhdHRyaWJ1dGU6IE1FRElBX0ZFQVRVUkVTLmpvaW4oXCIgXCIpXG4gICAgICAgIH0sXG4gICAgICAgIGNvbnRhaW5zOiBbXG4gICAgICAgICAge1xuICAgICAgICAgICAgYmVnaW46IEFUX0lERU5USUZJRVIsXG4gICAgICAgICAgICBjbGFzc05hbWU6IFwia2V5d29yZFwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBiZWdpbjogL1thLXotXSsoPz06KS8sXG4gICAgICAgICAgICBjbGFzc05hbWU6IFwiYXR0cmlidXRlXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFZBUklBQkxFLFxuICAgICAgICAgIGhsanMuUVVPVEVfU1RSSU5HX01PREUsXG4gICAgICAgICAgaGxqcy5BUE9TX1NUUklOR19NT0RFLFxuICAgICAgICAgIG1vZGVzLkhFWENPTE9SLFxuICAgICAgICAgIG1vZGVzLkNTU19OVU1CRVJfTU9ERVxuICAgICAgICBdXG4gICAgICB9XG4gICAgXVxuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBzY3NzO1xuIiwiLypcbkxhbmd1YWdlOiBTaGVsbCBTZXNzaW9uXG5SZXF1aXJlczogYmFzaC5qc1xuQXV0aG9yOiBUU1VZVVNBVE8gS2l0c3VuZSA8bWFrZS5qdXN0Lm9uQGdtYWlsLmNvbT5cbkNhdGVnb3J5OiBjb21tb25cbkF1ZGl0OiAyMDIwXG4qL1xuXG4vKiogQHR5cGUgTGFuZ3VhZ2VGbiAqL1xuZnVuY3Rpb24gc2hlbGwoaGxqcykge1xuICByZXR1cm4ge1xuICAgIG5hbWU6ICdTaGVsbCBTZXNzaW9uJyxcbiAgICBhbGlhc2VzOiBbICdjb25zb2xlJywgJ3NoZWxsc2Vzc2lvbicgXSxcbiAgICBjb250YWluczogW1xuICAgICAge1xuICAgICAgICBjbGFzc05hbWU6ICdtZXRhJyxcbiAgICAgICAgLy8gV2UgY2Fubm90IGFkZCBcXHMgKHNwYWNlcykgaW4gdGhlIHJlZ3VsYXIgZXhwcmVzc2lvbiBvdGhlcndpc2UgaXQgd2lsbCBiZSB0b28gYnJvYWQgYW5kIHByb2R1Y2UgdW5leHBlY3RlZCByZXN1bHQuXG4gICAgICAgIC8vIEZvciBpbnN0YW5jZSwgaW4gdGhlIGZvbGxvd2luZyBleGFtcGxlLCBpdCB3b3VsZCBtYXRjaCBcImVjaG8gL3BhdGgvdG8vaG9tZSA+XCIgYXMgYSBwcm9tcHQ6XG4gICAgICAgIC8vIGVjaG8gL3BhdGgvdG8vaG9tZSA+IHQuZXhlXG4gICAgICAgIGJlZ2luOiAvXlxcc3swLDN9Wy9+XFx3XFxkW1xcXSgpQC1dKls+JSQjXVsgXT8vLFxuICAgICAgICBzdGFydHM6IHtcbiAgICAgICAgICBlbmQ6IC9bXlxcXFxdKD89XFxzKiQpLyxcbiAgICAgICAgICBzdWJMYW5ndWFnZTogJ2Jhc2gnXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICBdXG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IHNoZWxsO1xuIiwiLypcbkxhbmd1YWdlOiBQbGFpbiB0ZXh0XG5BdXRob3I6IEVnb3IgUm9nb3YgKGUucm9nb3ZAcG9zdGdyZXNwcm8ucnUpXG5EZXNjcmlwdGlvbjogUGxhaW4gdGV4dCB3aXRob3V0IGFueSBoaWdobGlnaHRpbmcuXG5DYXRlZ29yeTogY29tbW9uXG4qL1xuXG5mdW5jdGlvbiBwbGFpbnRleHQoaGxqcykge1xuICByZXR1cm4ge1xuICAgIG5hbWU6ICdQbGFpbiB0ZXh0JyxcbiAgICBhbGlhc2VzOiBbXG4gICAgICAndGV4dCcsXG4gICAgICAndHh0J1xuICAgIF0sXG4gICAgZGlzYWJsZUF1dG9kZXRlY3Q6IHRydWVcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgcGxhaW50ZXh0O1xuIiwiLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVcbiAqIEByZXR1cm5zIHtSZWdFeHB9XG4gKiAqL1xuXG4vKipcbiAqIEBwYXJhbSB7UmVnRXhwIHwgc3RyaW5nIH0gcmVcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIHNvdXJjZShyZSkge1xuICBpZiAoIXJlKSByZXR1cm4gbnVsbDtcbiAgaWYgKHR5cGVvZiByZSA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIHJlO1xuXG4gIHJldHVybiByZS5zb3VyY2U7XG59XG5cbi8qKlxuICogQHBhcmFtIHtSZWdFeHAgfCBzdHJpbmcgfSByZVxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gbG9va2FoZWFkKHJlKSB7XG4gIHJldHVybiBjb25jYXQoJyg/PScsIHJlLCAnKScpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7UmVnRXhwIHwgc3RyaW5nIH0gcmVcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIG9wdGlvbmFsKHJlKSB7XG4gIHJldHVybiBjb25jYXQoJyg/OicsIHJlLCAnKT8nKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0gey4uLihSZWdFeHAgfCBzdHJpbmcpIH0gYXJnc1xuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gY29uY2F0KC4uLmFyZ3MpIHtcbiAgY29uc3Qgam9pbmVkID0gYXJncy5tYXAoKHgpID0+IHNvdXJjZSh4KSkuam9pbihcIlwiKTtcbiAgcmV0dXJuIGpvaW5lZDtcbn1cblxuZnVuY3Rpb24gc3RyaXBPcHRpb25zRnJvbUFyZ3MoYXJncykge1xuICBjb25zdCBvcHRzID0gYXJnc1thcmdzLmxlbmd0aCAtIDFdO1xuXG4gIGlmICh0eXBlb2Ygb3B0cyA9PT0gJ29iamVjdCcgJiYgb3B0cy5jb25zdHJ1Y3RvciA9PT0gT2JqZWN0KSB7XG4gICAgYXJncy5zcGxpY2UoYXJncy5sZW5ndGggLSAxLCAxKTtcbiAgICByZXR1cm4gb3B0cztcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4ge307XG4gIH1cbn1cblxuLyoqXG4gKiBBbnkgb2YgdGhlIHBhc3NlZCBleHByZXNzc2lvbnMgbWF5IG1hdGNoXG4gKlxuICogQ3JlYXRlcyBhIGh1Z2UgdGhpcyB8IHRoaXMgfCB0aGF0IHwgdGhhdCBtYXRjaFxuICogQHBhcmFtIHsoUmVnRXhwIHwgc3RyaW5nKVtdIH0gYXJnc1xuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gZWl0aGVyKC4uLmFyZ3MpIHtcbiAgY29uc3Qgb3B0cyA9IHN0cmlwT3B0aW9uc0Zyb21BcmdzKGFyZ3MpO1xuICBjb25zdCBqb2luZWQgPSAnKCcgK1xuICAgIChvcHRzLmNhcHR1cmUgPyBcIlwiIDogXCI/OlwiKSArXG4gICAgYXJncy5tYXAoKHgpID0+IHNvdXJjZSh4KSkuam9pbihcInxcIikgKyBcIilcIjtcbiAgcmV0dXJuIGpvaW5lZDtcbn1cblxuLypcbkxhbmd1YWdlOiBIVE1MLCBYTUxcbldlYnNpdGU6IGh0dHBzOi8vd3d3LnczLm9yZy9YTUwvXG5DYXRlZ29yeTogY29tbW9uLCB3ZWJcbkF1ZGl0OiAyMDIwXG4qL1xuXG4vKiogQHR5cGUgTGFuZ3VhZ2VGbiAqL1xuZnVuY3Rpb24geG1sKGhsanMpIHtcbiAgLy8gRWxlbWVudCBuYW1lcyBjYW4gY29udGFpbiBsZXR0ZXJzLCBkaWdpdHMsIGh5cGhlbnMsIHVuZGVyc2NvcmVzLCBhbmQgcGVyaW9kc1xuICBjb25zdCBUQUdfTkFNRV9SRSA9IGNvbmNhdCgvW0EtWl9dLywgb3B0aW9uYWwoL1tBLVowLTlfLi1dKjovKSwgL1tBLVowLTlfLi1dKi8pO1xuICBjb25zdCBYTUxfSURFTlRfUkUgPSAvW0EtWmEtejAtOS5fOi1dKy87XG4gIGNvbnN0IFhNTF9FTlRJVElFUyA9IHtcbiAgICBjbGFzc05hbWU6ICdzeW1ib2wnLFxuICAgIGJlZ2luOiAvJlthLXpdKzt8JiNbMC05XSs7fCYjeFthLWYwLTldKzsvXG4gIH07XG4gIGNvbnN0IFhNTF9NRVRBX0tFWVdPUkRTID0ge1xuICAgIGJlZ2luOiAvXFxzLyxcbiAgICBjb250YWluczogW1xuICAgICAge1xuICAgICAgICBjbGFzc05hbWU6ICdrZXl3b3JkJyxcbiAgICAgICAgYmVnaW46IC8jP1thLXpfXVthLXoxLTlfLV0rLyxcbiAgICAgICAgaWxsZWdhbDogL1xcbi9cbiAgICAgIH1cbiAgICBdXG4gIH07XG4gIGNvbnN0IFhNTF9NRVRBX1BBUl9LRVlXT1JEUyA9IGhsanMuaW5oZXJpdChYTUxfTUVUQV9LRVlXT1JEUywge1xuICAgIGJlZ2luOiAvXFwoLyxcbiAgICBlbmQ6IC9cXCkvXG4gIH0pO1xuICBjb25zdCBBUE9TX01FVEFfU1RSSU5HX01PREUgPSBobGpzLmluaGVyaXQoaGxqcy5BUE9TX1NUUklOR19NT0RFLCB7XG4gICAgY2xhc3NOYW1lOiAnc3RyaW5nJ1xuICB9KTtcbiAgY29uc3QgUVVPVEVfTUVUQV9TVFJJTkdfTU9ERSA9IGhsanMuaW5oZXJpdChobGpzLlFVT1RFX1NUUklOR19NT0RFLCB7XG4gICAgY2xhc3NOYW1lOiAnc3RyaW5nJ1xuICB9KTtcbiAgY29uc3QgVEFHX0lOVEVSTkFMUyA9IHtcbiAgICBlbmRzV2l0aFBhcmVudDogdHJ1ZSxcbiAgICBpbGxlZ2FsOiAvPC8sXG4gICAgcmVsZXZhbmNlOiAwLFxuICAgIGNvbnRhaW5zOiBbXG4gICAgICB7XG4gICAgICAgIGNsYXNzTmFtZTogJ2F0dHInLFxuICAgICAgICBiZWdpbjogWE1MX0lERU5UX1JFLFxuICAgICAgICByZWxldmFuY2U6IDBcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGJlZ2luOiAvPVxccyovLFxuICAgICAgICByZWxldmFuY2U6IDAsXG4gICAgICAgIGNvbnRhaW5zOiBbXG4gICAgICAgICAge1xuICAgICAgICAgICAgY2xhc3NOYW1lOiAnc3RyaW5nJyxcbiAgICAgICAgICAgIGVuZHNQYXJlbnQ6IHRydWUsXG4gICAgICAgICAgICB2YXJpYW50czogW1xuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgYmVnaW46IC9cIi8sXG4gICAgICAgICAgICAgICAgZW5kOiAvXCIvLFxuICAgICAgICAgICAgICAgIGNvbnRhaW5zOiBbIFhNTF9FTlRJVElFUyBdXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBiZWdpbjogLycvLFxuICAgICAgICAgICAgICAgIGVuZDogLycvLFxuICAgICAgICAgICAgICAgIGNvbnRhaW5zOiBbIFhNTF9FTlRJVElFUyBdXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBiZWdpbjogL1teXFxzXCInPTw+YF0rL1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBdXG4gICAgICAgICAgfVxuICAgICAgICBdXG4gICAgICB9XG4gICAgXVxuICB9O1xuICByZXR1cm4ge1xuICAgIG5hbWU6ICdIVE1MLCBYTUwnLFxuICAgIGFsaWFzZXM6IFtcbiAgICAgICdodG1sJyxcbiAgICAgICd4aHRtbCcsXG4gICAgICAncnNzJyxcbiAgICAgICdhdG9tJyxcbiAgICAgICd4amInLFxuICAgICAgJ3hzZCcsXG4gICAgICAneHNsJyxcbiAgICAgICdwbGlzdCcsXG4gICAgICAnd3NmJyxcbiAgICAgICdzdmcnXG4gICAgXSxcbiAgICBjYXNlX2luc2Vuc2l0aXZlOiB0cnVlLFxuICAgIGNvbnRhaW5zOiBbXG4gICAgICB7XG4gICAgICAgIGNsYXNzTmFtZTogJ21ldGEnLFxuICAgICAgICBiZWdpbjogLzwhW2Etel0vLFxuICAgICAgICBlbmQ6IC8+LyxcbiAgICAgICAgcmVsZXZhbmNlOiAxMCxcbiAgICAgICAgY29udGFpbnM6IFtcbiAgICAgICAgICBYTUxfTUVUQV9LRVlXT1JEUyxcbiAgICAgICAgICBRVU9URV9NRVRBX1NUUklOR19NT0RFLFxuICAgICAgICAgIEFQT1NfTUVUQV9TVFJJTkdfTU9ERSxcbiAgICAgICAgICBYTUxfTUVUQV9QQVJfS0VZV09SRFMsXG4gICAgICAgICAge1xuICAgICAgICAgICAgYmVnaW46IC9cXFsvLFxuICAgICAgICAgICAgZW5kOiAvXFxdLyxcbiAgICAgICAgICAgIGNvbnRhaW5zOiBbXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU6ICdtZXRhJyxcbiAgICAgICAgICAgICAgICBiZWdpbjogLzwhW2Etel0vLFxuICAgICAgICAgICAgICAgIGVuZDogLz4vLFxuICAgICAgICAgICAgICAgIGNvbnRhaW5zOiBbXG4gICAgICAgICAgICAgICAgICBYTUxfTUVUQV9LRVlXT1JEUyxcbiAgICAgICAgICAgICAgICAgIFhNTF9NRVRBX1BBUl9LRVlXT1JEUyxcbiAgICAgICAgICAgICAgICAgIFFVT1RFX01FVEFfU1RSSU5HX01PREUsXG4gICAgICAgICAgICAgICAgICBBUE9TX01FVEFfU1RSSU5HX01PREVcbiAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF1cbiAgICAgICAgICB9XG4gICAgICAgIF1cbiAgICAgIH0sXG4gICAgICBobGpzLkNPTU1FTlQoXG4gICAgICAgIC88IS0tLyxcbiAgICAgICAgLy0tPi8sXG4gICAgICAgIHtcbiAgICAgICAgICByZWxldmFuY2U6IDEwXG4gICAgICAgIH1cbiAgICAgICksXG4gICAgICB7XG4gICAgICAgIGJlZ2luOiAvPCFcXFtDREFUQVxcWy8sXG4gICAgICAgIGVuZDogL1xcXVxcXT4vLFxuICAgICAgICByZWxldmFuY2U6IDEwXG4gICAgICB9LFxuICAgICAgWE1MX0VOVElUSUVTLFxuICAgICAge1xuICAgICAgICBjbGFzc05hbWU6ICdtZXRhJyxcbiAgICAgICAgYmVnaW46IC88XFw/eG1sLyxcbiAgICAgICAgZW5kOiAvXFw/Pi8sXG4gICAgICAgIHJlbGV2YW5jZTogMTBcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGNsYXNzTmFtZTogJ3RhZycsXG4gICAgICAgIC8qXG4gICAgICAgIFRoZSBsb29rYWhlYWQgcGF0dGVybiAoPz0uLi4pIGVuc3VyZXMgdGhhdCAnYmVnaW4nIG9ubHkgbWF0Y2hlc1xuICAgICAgICAnPHN0eWxlJyBhcyBhIHNpbmdsZSB3b3JkLCBmb2xsb3dlZCBieSBhIHdoaXRlc3BhY2Ugb3IgYW5cbiAgICAgICAgZW5kaW5nIGJyYWNrZXQuXG4gICAgICAgICovXG4gICAgICAgIGJlZ2luOiAvPHN0eWxlKD89XFxzfD4pLyxcbiAgICAgICAgZW5kOiAvPi8sXG4gICAgICAgIGtleXdvcmRzOiB7XG4gICAgICAgICAgbmFtZTogJ3N0eWxlJ1xuICAgICAgICB9LFxuICAgICAgICBjb250YWluczogWyBUQUdfSU5URVJOQUxTIF0sXG4gICAgICAgIHN0YXJ0czoge1xuICAgICAgICAgIGVuZDogLzxcXC9zdHlsZT4vLFxuICAgICAgICAgIHJldHVybkVuZDogdHJ1ZSxcbiAgICAgICAgICBzdWJMYW5ndWFnZTogW1xuICAgICAgICAgICAgJ2NzcycsXG4gICAgICAgICAgICAneG1sJ1xuICAgICAgICAgIF1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgY2xhc3NOYW1lOiAndGFnJyxcbiAgICAgICAgLy8gU2VlIHRoZSBjb21tZW50IGluIHRoZSA8c3R5bGUgdGFnIGFib3V0IHRoZSBsb29rYWhlYWQgcGF0dGVyblxuICAgICAgICBiZWdpbjogLzxzY3JpcHQoPz1cXHN8PikvLFxuICAgICAgICBlbmQ6IC8+LyxcbiAgICAgICAga2V5d29yZHM6IHtcbiAgICAgICAgICBuYW1lOiAnc2NyaXB0J1xuICAgICAgICB9LFxuICAgICAgICBjb250YWluczogWyBUQUdfSU5URVJOQUxTIF0sXG4gICAgICAgIHN0YXJ0czoge1xuICAgICAgICAgIGVuZDogLzxcXC9zY3JpcHQ+LyxcbiAgICAgICAgICByZXR1cm5FbmQ6IHRydWUsXG4gICAgICAgICAgc3ViTGFuZ3VhZ2U6IFtcbiAgICAgICAgICAgICdqYXZhc2NyaXB0JyxcbiAgICAgICAgICAgICdoYW5kbGViYXJzJyxcbiAgICAgICAgICAgICd4bWwnXG4gICAgICAgICAgXVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgLy8gd2UgbmVlZCB0aGlzIGZvciBub3cgZm9yIGpTWFxuICAgICAge1xuICAgICAgICBjbGFzc05hbWU6ICd0YWcnLFxuICAgICAgICBiZWdpbjogLzw+fDxcXC8+L1xuICAgICAgfSxcbiAgICAgIC8vIG9wZW4gdGFnXG4gICAgICB7XG4gICAgICAgIGNsYXNzTmFtZTogJ3RhZycsXG4gICAgICAgIGJlZ2luOiBjb25jYXQoXG4gICAgICAgICAgLzwvLFxuICAgICAgICAgIGxvb2thaGVhZChjb25jYXQoXG4gICAgICAgICAgICBUQUdfTkFNRV9SRSxcbiAgICAgICAgICAgIC8vIDx0YWcvPlxuICAgICAgICAgICAgLy8gPHRhZz5cbiAgICAgICAgICAgIC8vIDx0YWcgLi4uXG4gICAgICAgICAgICBlaXRoZXIoL1xcLz4vLCAvPi8sIC9cXHMvKVxuICAgICAgICAgICkpXG4gICAgICAgICksXG4gICAgICAgIGVuZDogL1xcLz8+LyxcbiAgICAgICAgY29udGFpbnM6IFtcbiAgICAgICAgICB7XG4gICAgICAgICAgICBjbGFzc05hbWU6ICduYW1lJyxcbiAgICAgICAgICAgIGJlZ2luOiBUQUdfTkFNRV9SRSxcbiAgICAgICAgICAgIHJlbGV2YW5jZTogMCxcbiAgICAgICAgICAgIHN0YXJ0czogVEFHX0lOVEVSTkFMU1xuICAgICAgICAgIH1cbiAgICAgICAgXVxuICAgICAgfSxcbiAgICAgIC8vIGNsb3NlIHRhZ1xuICAgICAge1xuICAgICAgICBjbGFzc05hbWU6ICd0YWcnLFxuICAgICAgICBiZWdpbjogY29uY2F0KFxuICAgICAgICAgIC88XFwvLyxcbiAgICAgICAgICBsb29rYWhlYWQoY29uY2F0KFxuICAgICAgICAgICAgVEFHX05BTUVfUkUsIC8+L1xuICAgICAgICAgICkpXG4gICAgICAgICksXG4gICAgICAgIGNvbnRhaW5zOiBbXG4gICAgICAgICAge1xuICAgICAgICAgICAgY2xhc3NOYW1lOiAnbmFtZScsXG4gICAgICAgICAgICBiZWdpbjogVEFHX05BTUVfUkUsXG4gICAgICAgICAgICByZWxldmFuY2U6IDBcbiAgICAgICAgICB9LFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGJlZ2luOiAvPi8sXG4gICAgICAgICAgICByZWxldmFuY2U6IDAsXG4gICAgICAgICAgICBlbmRzUGFyZW50OiB0cnVlXG4gICAgICAgICAgfVxuICAgICAgICBdXG4gICAgICB9XG4gICAgXVxuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCB4bWw7XG4iLCJpbXBvcnQgaGxqcyBmcm9tICdoaWdobGlnaHQuanMvbGliL2NvcmUnO1xyXG5pbXBvcnQgamF2YXNjcmlwdCBmcm9tICdoaWdobGlnaHQuanMvbGliL2xhbmd1YWdlcy9qYXZhc2NyaXB0JztcclxuaW1wb3J0IHNjc3MgZnJvbSAnaGlnaGxpZ2h0LmpzL2xpYi9sYW5ndWFnZXMvc2Nzcyc7XHJcbmltcG9ydCBzaGVsbCBmcm9tICdoaWdobGlnaHQuanMvbGliL2xhbmd1YWdlcy9zaGVsbCc7XHJcbmltcG9ydCBwbGFpbnRleHQgZnJvbSAnaGlnaGxpZ2h0LmpzL2xpYi9sYW5ndWFnZXMvcGxhaW50ZXh0JztcclxuaW1wb3J0IHhtbCBmcm9tICdoaWdobGlnaHQuanMvbGliL2xhbmd1YWdlcy94bWwnO1xyXG5cclxuaGxqcy5yZWdpc3Rlckxhbmd1YWdlKCdqYXZhc2NyaXB0JywgamF2YXNjcmlwdCk7XHJcbmhsanMucmVnaXN0ZXJMYW5ndWFnZSgnc2NzcycsIHNjc3MpO1xyXG5obGpzLnJlZ2lzdGVyTGFuZ3VhZ2UoJ3NoZWxsJywgc2hlbGwpO1xyXG5obGpzLnJlZ2lzdGVyTGFuZ3VhZ2UoJ3BsYWludGV4dCcsIHBsYWludGV4dCk7XHJcbmhsanMucmVnaXN0ZXJMYW5ndWFnZSgneG1sJywgeG1sKTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGhpZ2hsaWdodChjb2RlLCBsYW5nKSB7XHJcbiAgICBjb25zdCBsYW5ndWFnZSA9IGhsanMuZ2V0TGFuZ3VhZ2UobGFuZykgPyBsYW5nIDogJ3BsYWludGV4dCc7XHJcbiAgICByZXR1cm4gaGxqcy5oaWdobGlnaHQoY29kZSwgeyBsYW5ndWFnZSB9KS52YWx1ZTtcclxufSIsImltcG9ydCB7IGpzeFRvSHRtbCB9IGZyb20gJ0AvdXRpbHMvY29kZSc7XHJcbmltcG9ydCBoaWdobGlnaHQgZnJvbSAnQC91dGlscy9oaWdobGlnaHQnO1xyXG5cclxuaW1wb3J0ICcuL2luZGV4LnNjc3MnO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gQ29kZSh7IGxhbmcsIGNoaWxkcmVuIH0pIHtcclxuICAgIGNvbnN0IGh0bWwgPSBqc3hUb0h0bWwoY2hpbGRyZW4pO1xyXG5cclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJjb2RlXCI+XHJcbiAgICAgICAgICAgIDxwcmUgY2xhc3NOYW1lPXtgaGxqcyBsYW5ndWFnZS0ke2xhbmd9YH0+XHJcbiAgICAgICAgICAgICAgICA8Y29kZVxyXG4gICAgICAgICAgICAgICAgICAgIGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MPXt7IF9faHRtbDogaGlnaGxpZ2h0KGh0bWwsICdqc3gnKSB9fVxyXG4gICAgICAgICAgICAgICAgLz5cclxuICAgICAgICAgICAgPC9wcmU+XHJcbiAgICAgICAgPC9kaXY+XHJcbiAgICApO1xyXG59IiwiaW1wb3J0IHsgdXNlU3RhdGUgfSBmcm9tICdyZWFjdCc7XHJcbmltcG9ydCB7XHJcbiAgICBDYXJkLFxyXG4gICAgSWNvbkJ1dHRvbixcclxuICAgIFNpZGVTaGVldCxcclxuICAgIFR5cG9ncmFwaHlcclxufSBmcm9tICdtZGMtcmVhY3QnO1xyXG5pbXBvcnQgY2xhc3NuYW1lcyBmcm9tICdjbGFzc25hbWVzJztcclxuXHJcbmltcG9ydCBDb2RlIGZyb20gJ0AvY29tcG9uZW50cy9Db2RlJztcclxuXHJcbmltcG9ydCAnLi9pbmRleC5zY3NzJztcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIERlbW8oe1xyXG4gICAgdGl0bGUgPSAnRGVtbycsXHJcbiAgICBkZXNjcmlwdGlvbixcclxuICAgIHNldHVwLFxyXG4gICAgc2V0dGluZ3MsXHJcbiAgICBjb2RlLFxyXG4gICAgY2hpbGRyZW4gPSBjb2RlLFxyXG4gICAgLi4ucHJvcHNcclxufSkge1xyXG4gICAgY29uc3QgW2lzQ29kZU9wZW4sIHNldENvZGVPcGVuXSA9IHVzZVN0YXRlKGZhbHNlKTtcclxuICAgIGNvbnN0IFtpc1NldHRpbmdzT3Blbiwgc2V0U2V0dGluZ3NPcGVuXSA9IHVzZVN0YXRlKGZhbHNlKTtcclxuXHJcbiAgICBjb25zdCBjbGFzc05hbWVzID0gY2xhc3NuYW1lcygnZGVtbycsIHtcclxuICAgICAgICAnZGVtby0td2l0aC1zZXR0aW5ncyc6IHNldHRpbmdzXHJcbiAgICB9KTtcclxuXHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAgIDxDYXJkIGVsZW1lbnQ9XCJhcnRpY2xlXCIgY2xhc3NOYW1lPXtjbGFzc05hbWVzfSBvdXRsaW5lZCB7Li4ucHJvcHN9PlxyXG4gICAgICAgICAgICA8Q2FyZC5IZWFkZXJcclxuICAgICAgICAgICAgICAgIHRpdGxlPXt0aXRsZX1cclxuICAgICAgICAgICAgICAgIGFjdGlvbnM9e1tcclxuICAgICAgICAgICAgICAgICAgICA8SWNvbkJ1dHRvblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBrZXk9XCJjb2RlXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWNvbj17aXNDb2RlT3BlbiA/ICdjb2RlX29mZicgOiAnY29kZSd9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlPXtpc0NvZGVPcGVuID8gJ0hpZGUgY29kZScgOiAnU2hvdyBjb2RlJ30gb25DbGljaz17KCkgPT4gc2V0Q29kZU9wZW4odiA9PiAhdil9XHJcbiAgICAgICAgICAgICAgICAgICAgLz4sXHJcbiAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3MgP1xyXG4gICAgICAgICAgICAgICAgICAgICAgICA8SWNvbkJ1dHRvblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5PVwic2V0dGluZ3NcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWNvbj1cInNldHRpbmdzXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlPVwi0J3QsNGB0YLRgNC+0LnQutC4XCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2xpY2s9eygpID0+IHNldFNldHRpbmdzT3Blbih0cnVlKX1cclxuICAgICAgICAgICAgICAgICAgICAgICAgLz4gOiBudWxsXHJcbiAgICAgICAgICAgICAgICBdfVxyXG4gICAgICAgICAgICAvPlxyXG5cclxuICAgICAgICAgICAge2Rlc2NyaXB0aW9uICYmXHJcbiAgICAgICAgICAgICAgICA8Q2FyZC5TZWN0aW9uIHNlY29uZGFyeT5cclxuICAgICAgICAgICAgICAgICAgICA8VHlwb2dyYXBoeSBub01hcmdpbj57ZGVzY3JpcHRpb259PC9UeXBvZ3JhcGh5PlxyXG4gICAgICAgICAgICAgICAgPC9DYXJkLlNlY3Rpb24+XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIDxDYXJkLlNlY3Rpb24gcHJpbWFyeT5cclxuICAgICAgICAgICAgICAgIHtzZXR1cH1cclxuICAgICAgICAgICAgICAgIHtjaGlsZHJlbn1cclxuICAgICAgICAgICAgPC9DYXJkLlNlY3Rpb24+XHJcblxyXG4gICAgICAgICAgICB7aXNDb2RlT3BlbiAmJlxyXG4gICAgICAgICAgICAgICAgPENhcmQuU2VjdGlvbiBzZWNvbmRhcnk+XHJcbiAgICAgICAgICAgICAgICAgICAgPENvZGUgbGFuZz1cImpzeFwiPntjaGlsZHJlbn08L0NvZGU+XHJcbiAgICAgICAgICAgICAgICA8L0NhcmQuU2VjdGlvbj5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAge3NldHRpbmdzICYmXHJcbiAgICAgICAgICAgICAgICA8U2lkZVNoZWV0XHJcbiAgICAgICAgICAgICAgICAgICAgdGl0bGU9XCJTZXR0aW5nc1wiXHJcbiAgICAgICAgICAgICAgICAgICAgb3Blbj17aXNTZXR0aW5nc09wZW59XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gYXBwZWFyXHJcbiAgICAgICAgICAgICAgICAgICAgY2xvc2VJY29uPVwiY2xvc2VcIlxyXG4gICAgICAgICAgICAgICAgICAgIG9uQ2xvc2U9eygpID0+IHNldFNldHRpbmdzT3BlbihmYWxzZSl9XHJcbiAgICAgICAgICAgICAgICAgICAgZGlzbWlzc2libGVcclxuICAgICAgICAgICAgICAgID5cclxuICAgICAgICAgICAgICAgICAgICA8U2lkZVNoZWV0LkNvbnRlbnQ+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHtzZXR0aW5nc31cclxuICAgICAgICAgICAgICAgICAgICA8L1NpZGVTaGVldC5Db250ZW50PlxyXG4gICAgICAgICAgICAgICAgPC9TaWRlU2hlZXQ+XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICA8L0NhcmQ+XHJcbiAgICApO1xyXG59IiwiaW1wb3J0ICcuL2luZGV4LnNjc3MnO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gRmllbGRTZXQoeyBsZWdlbmQsIGNoaWxkcmVuIH0pIHtcclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgPGZpZWxkc2V0PlxyXG4gICAgICAgICAgICA8bGVnZW5kPntsZWdlbmR9PC9sZWdlbmQ+XHJcblxyXG4gICAgICAgICAgICB7Y2hpbGRyZW59XHJcbiAgICAgICAgPC9maWVsZHNldD5cclxuICAgICk7XHJcbn0iLCJpbXBvcnQgeyBMaXN0LCBUeXBvZ3JhcGh5IH0gZnJvbSAnbWRjLXJlYWN0JztcclxuXHJcbmltcG9ydCAnLi9pbmRleC5zY3NzJztcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIFBhZ2Uoe1xyXG4gICAgaWQsXHJcbiAgICB0aXRsZSxcclxuICAgIGRlc2NyaXB0aW9uLFxyXG4gICAgbGlua3MsXHJcblxyXG4gICAgY2hpbGRyZW4sXHJcbiAgICAuLi5wcm9wc1xyXG59KSB7XHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAgIDxhcnRpY2xlIGlkPXtgJHtpZH0tcGFnZWB9IGNsYXNzTmFtZT1cInBhZ2VcIiB7Li4ucHJvcHN9PlxyXG4gICAgICAgICAgICB7dGl0bGUgJiZcclxuICAgICAgICAgICAgICAgIDxoZWFkZXIgY2xhc3NOYW1lPVwicGFnZS1oZWFkZXJcIj5cclxuICAgICAgICAgICAgICAgICAgICA8VHlwb2dyYXBoeSBjbGFzc05hbWU9XCJwYWdlLXRpdGxlXCIgdHlwZT1cImhlYWRsaW5lNFwiIG5vTWFyZ2luPnt0aXRsZX08L1R5cG9ncmFwaHk+XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHtkZXNjcmlwdGlvbiAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8VHlwb2dyYXBoeSBjbGFzc05hbWU9XCJwYWdlLWRlc2NyaXB0aW9uXCIgdHlwZT1cImJvZHkxXCIgbm9NYXJnaW4+e2Rlc2NyaXB0aW9ufTwvVHlwb2dyYXBoeT5cclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHtsaW5rcyAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8dWw+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7bGlua3MuZ3VpZGUgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8bGk+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxhIGhyZWY9e2xpbmtzLmd1aWRlfSB0YXJnZXQ9XCJfYmxhbmtcIiByZWw9XCJub3JlZmVycmVyXCI+R3VpZGU8L2E+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9saT5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7bGlua3MuZG9jcyAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxsaT5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGEgaHJlZj17bGlua3MuZG9jc30gdGFyZ2V0PVwiX2JsYW5rXCIgcmVsPVwibm9yZWZlcnJlclwiPkRvY3M8L2E+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9saT5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgPC91bD5cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICA8L2hlYWRlcj5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJwYWdlLWNvbnRlbnRcIj5cclxuICAgICAgICAgICAgICAgIHtjaGlsZHJlbn1cclxuICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgPC9hcnRpY2xlPlxyXG4gICAgKTtcclxufSIsImltcG9ydCB7IHVzZVN0YXRlIH0gZnJvbSAncmVhY3QnO1xyXG5pbXBvcnQge1xyXG4gICAgQXZhdGFyLFxyXG4gICAgU2VnbWVudGVkQnV0dG9uXHJcbn0gZnJvbSAnbWRjLXJlYWN0JztcclxuXHJcbmltcG9ydCBEZW1vIGZyb20gJ0AvY29tcG9uZW50cy9EZW1vJztcclxuaW1wb3J0IEZpZWxkU2V0IGZyb20gJ0AvY29tcG9uZW50cy9GaWVsZFNldCc7XHJcbmltcG9ydCBQYWdlIGZyb20gJ0AvY29tcG9uZW50cy9QYWdlJztcclxuXHJcbmNvbnN0IGlkID0gJ2F2YXRhcic7XHJcbmNvbnN0IHRpdGxlID0gJ0F2YXRhcic7XHJcbmNvbnN0IGRlc2NyaXB0aW9uID0gJ0F2YXRhcnMgYXJlIGZvdW5kIHRocm91Z2hvdXQgbWF0ZXJpYWwgZGVzaWduIHdpdGggdXNlcyBpbiBldmVyeXRoaW5nIGZyb20gdGFibGVzIHRvIGRpYWxvZyBtZW51cy4nO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gQXZhdGFyUGFnZSgpIHtcclxuICAgIGNvbnN0IFtzaXplLCBzZXRTaXplXSA9IHVzZVN0YXRlKCdtZWRpdW0nKTtcclxuICAgIGNvbnN0IFtjb250ZW50LCBzZXRDb250ZW50XSA9IHVzZVN0YXRlKCdpbWFnZScpO1xyXG5cclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgPFBhZ2VcclxuICAgICAgICAgICAgaWQ9e2lkfVxyXG4gICAgICAgICAgICB0aXRsZT17dGl0bGV9XHJcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uPXtkZXNjcmlwdGlvbn1cclxuICAgICAgICA+XHJcbiAgICAgICAgICAgIDxEZW1vXHJcbiAgICAgICAgICAgICAgICB0aXRsZT1cIkRlbW9cIlxyXG4gICAgICAgICAgICAgICAgc2V0dGluZ3M9ezw+XHJcbiAgICAgICAgICAgICAgICAgICAgPEZpZWxkU2V0IGxlZ2VuZD1cIkNvbnRlbnRcIj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPFNlZ21lbnRlZEJ1dHRvblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VnbWVudHM9e1tcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7IHZhbHVlOiAnaW1hZ2UnLCBsYWJlbDogJ0ltYWdlJyB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgdmFsdWU6ICdpY29uJywgbGFiZWw6ICdJY29uJyB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgdmFsdWU6ICd0ZXh0JywgbGFiZWw6ICdUZXh0JyB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBdfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU9e2NvbnRlbnR9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbkNoYW5nZT17c2V0Q29udGVudH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgLz5cclxuICAgICAgICAgICAgICAgICAgICA8L0ZpZWxkU2V0PlxyXG5cclxuICAgICAgICAgICAgICAgICAgICA8RmllbGRTZXQgbGVnZW5kPVwiU2l6ZVwiPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8U2VnbWVudGVkQnV0dG9uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWdtZW50cz17W1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgdmFsdWU6ICdzbWFsbCcsIGxhYmVsOiAnU21hbGwnIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeyB2YWx1ZTogJ21lZGl1bScsIGxhYmVsOiAnTWVkaXVtJyB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgdmFsdWU6ICdsYXJnZScsIGxhYmVsOiAnTGFyZ2UnIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF19XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZT17c2l6ZX1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2hhbmdlPXtzZXRTaXplfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvPlxyXG4gICAgICAgICAgICAgICAgICAgIDwvRmllbGRTZXQ+XHJcbiAgICAgICAgICAgICAgICA8Lz59XHJcbiAgICAgICAgICAgID5cclxuICAgICAgICAgICAgICAgIDxBdmF0YXJcclxuICAgICAgICAgICAgICAgICAgICBpbWFnZT17Y29udGVudCA9PT0gJ2ltYWdlJyA/ICdodHRwczovL3BsYWNlaW1nLmNvbS8xMjgvMTI4L3Blb3BsZScgOiB1bmRlZmluZWR9XHJcbiAgICAgICAgICAgICAgICAgICAgaWNvbj17Y29udGVudCA9PT0gJ2ljb24nID8gJ3N0YXInIDogdW5kZWZpbmVkfVxyXG4gICAgICAgICAgICAgICAgICAgIHRleHQ9e2NvbnRlbnQgPT09ICd0ZXh0JyA/ICdNRCcgOiB1bmRlZmluZWR9XHJcbiAgICAgICAgICAgICAgICAgICAgc2l6ZT17c2l6ZX1cclxuICAgICAgICAgICAgICAgIC8+XHJcbiAgICAgICAgICAgIDwvRGVtbz5cclxuICAgICAgICA8L1BhZ2U+XHJcbiAgICApO1xyXG59IiwiaW1wb3J0IHsgdXNlU3RhdGUgfSBmcm9tICdyZWFjdCc7XHJcbmltcG9ydCB7XHJcbiAgICBBdmF0YXIsXHJcbiAgICBCYWRnZSxcclxuICAgIEJ1dHRvbixcclxuICAgIEZvcm1GaWVsZCxcclxuICAgIEljb24sXHJcbiAgICBJY29uQnV0dG9uLFxyXG4gICAgU2VnbWVudGVkQnV0dG9uLFxyXG4gICAgU3dpdGNoLFxyXG4gICAgVGV4dEZpZWxkXHJcbn0gZnJvbSAnbWRjLXJlYWN0JztcclxuXHJcbmltcG9ydCBEZW1vIGZyb20gJ0AvY29tcG9uZW50cy9EZW1vJztcclxuaW1wb3J0IEZpZWxkU2V0IGZyb20gJ0AvY29tcG9uZW50cy9GaWVsZFNldCc7XHJcbmltcG9ydCBQYWdlIGZyb20gJ0AvY29tcG9uZW50cy9QYWdlJztcclxuXHJcbmNvbnN0IGlkID0gJ2JhZGdlJztcclxuY29uc3QgdGl0bGUgPSAnQmFkZ2UnO1xyXG5jb25zdCBkZXNjcmlwdGlvbiA9ICdCYWRnZSBnZW5lcmF0ZXMgYSBzbWFsbCBiYWRnZSB0byB0aGUgdG9wLXJpZ2h0IG9mIGl0cyBjaGlsZChyZW4pLic7XHJcblxyXG5jb25zdCBjb250ZW50ID0ge1xyXG4gICAgYXZhdGFyOiA8QXZhdGFyIHRleHQ9XCJNRFwiIHNpemU9XCJtZWRpdW1cIiAvPixcclxuICAgIGJ1dHRvbjogPEJ1dHRvbiBvdXRsaW5lZD5CdXR0b248L0J1dHRvbj4sXHJcbiAgICBpY29uOiA8SWNvbj5zdGFyPC9JY29uPixcclxuICAgIGljb25CdXR0b246IDxJY29uQnV0dG9uIGljb249XCJzdGFyXCIgLz4sXHJcbiAgICB0ZXh0OiAnVGV4dCdcclxufTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIEJhZGdlUGFnZSgpIHtcclxuICAgIGNvbnN0IFt2YWx1ZSwgc2V0VmFsdWVdID0gdXNlU3RhdGUoMCk7XHJcbiAgICBjb25zdCBbdHlwZSwgc2V0VHlwZV0gPSB1c2VTdGF0ZSgnYXZhdGFyJyk7XHJcbiAgICBjb25zdCBbaW5zZXQsIHNldEluc2V0XSA9IHVzZVN0YXRlKGZhbHNlKTtcclxuICAgIGNvbnN0IFt0cmFuc3BhcmVudCwgc2V0VHJhbnNwYXJlbnRdID0gdXNlU3RhdGUoZmFsc2UpO1xyXG5cclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgPFBhZ2UgaWQ9e2lkfSB0aXRsZT17dGl0bGV9IGRlc2NyaXB0aW9uPXtkZXNjcmlwdGlvbn0+XHJcbiAgICAgICAgICAgIDxEZW1vXHJcbiAgICAgICAgICAgICAgICBzZXR0aW5ncz17W1xyXG4gICAgICAgICAgICAgICAgICAgIDxUZXh0RmllbGRcclxuICAgICAgICAgICAgICAgICAgICAgICAga2V5PVwidmFsdWVcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZT17dmFsdWV9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsPVwiVmFsdWVcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRsaW5lZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBvbkNoYW5nZT17KF8sIHZhbHVlKSA9PiBzZXRWYWx1ZSh2YWx1ZSl9XHJcbiAgICAgICAgICAgICAgICAgICAgLz4sXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIDxGaWVsZFNldCBrZXk9XCJjb250ZW50XCIgbGVnZW5kPVwiQ29udGVudFwiPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8U2VnbWVudGVkQnV0dG9uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWdtZW50cz17W1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgdmFsdWU6ICdhdmF0YXInLCBsYWJlbDogJ0F2YXRhcicgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7IHZhbHVlOiAnYnV0dG9uJywgbGFiZWw6ICdCdXR0b24nIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeyB2YWx1ZTogJ2ljb24nLCBsYWJlbDogJ0ljb24nIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeyB2YWx1ZTogJ2ljb25CdXR0b24nLCBsYWJlbDogJ0ljb24gQnV0dG9uJyB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgdmFsdWU6ICd0ZXh0JywgbGFiZWw6ICdUZXh0JyB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBdfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU9e3R5cGV9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbkNoYW5nZT17c2V0VHlwZX1cclxuICAgICAgICAgICAgICAgICAgICAgICAgLz5cclxuICAgICAgICAgICAgICAgICAgICA8L0ZpZWxkU2V0PixcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgPEZvcm1GaWVsZCBrZXk9XCJpbnNldFwiIGxhYmVsPVwiSW5zZXRcIiBhbGlnbkVuZCBzcGFjZUJldHdlZW4+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxTd2l0Y2hcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdGVkPXtpbnNldH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2hhbmdlPXsoKSA9PiBzZXRJbnNldCh2ID0+ICF2KX1cclxuICAgICAgICAgICAgICAgICAgICAgICAgLz5cclxuICAgICAgICAgICAgICAgICAgICA8L0Zvcm1GaWVsZD4sXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIDxGb3JtRmllbGQga2V5PVwidHJhbnNwYXJlbnRcIiBsYWJlbD1cIlRyYW5zcGFyZW50XCIgYWxpZ25FbmQgc3BhY2VCZXR3ZWVuPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8U3dpdGNoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3RlZD17dHJhbnNwYXJlbnR9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbkNoYW5nZT17KCkgPT4gc2V0VHJhbnNwYXJlbnQodiA9PiAhdil9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8+XHJcbiAgICAgICAgICAgICAgICAgICAgPC9Gb3JtRmllbGQ+XHJcbiAgICAgICAgICAgICAgICBdfVxyXG4gICAgICAgICAgICA+XHJcbiAgICAgICAgICAgICAgICA8QmFkZ2VcclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZT17dmFsdWV9XHJcbiAgICAgICAgICAgICAgICAgICAgaW5zZXQ9e2luc2V0IHx8IHVuZGVmaW5lZH1cclxuICAgICAgICAgICAgICAgICAgICB0cmFuc3BhcmVudD17dHJhbnNwYXJlbnQgfHwgdW5kZWZpbmVkfVxyXG4gICAgICAgICAgICAgICAgPlxyXG4gICAgICAgICAgICAgICAgICAgIHtjb250ZW50W3R5cGVdfVxyXG4gICAgICAgICAgICAgICAgPC9CYWRnZT5cclxuICAgICAgICAgICAgPC9EZW1vPlxyXG4gICAgICAgIDwvUGFnZT5cclxuICAgICk7XHJcbn0iLCJpbXBvcnQgeyB1c2VTdGF0ZSB9IGZyb20gJ3JlYWN0JztcclxuaW1wb3J0IHtcclxuICAgIEJhbm5lcixcclxuICAgIEJ1dHRvbixcclxuICAgIEZvcm1GaWVsZCxcclxuICAgIFN3aXRjaCxcclxuICAgIFRleHRGaWVsZCxcclxuICAgIFRvcEFwcEJhclxyXG59IGZyb20gJ21kYy1yZWFjdCc7XHJcblxyXG5pbXBvcnQgRGVtbyBmcm9tICdAL2NvbXBvbmVudHMvRGVtbyc7XHJcbmltcG9ydCBQYWdlIGZyb20gJ0AvY29tcG9uZW50cy9QYWdlJztcclxuXHJcbmltcG9ydCAnLi9pbmRleC5zY3NzJztcclxuXHJcbmNvbnN0IGlkID0gJ2Jhbm5lcic7XHJcbmNvbnN0IHRpdGxlID0gJ0Jhbm5lcic7XHJcbmNvbnN0IGRlc2NyaXB0aW9uID0gJ0EgYmFubmVyIGRpc3BsYXlzIGEgcHJvbWluZW50IG1lc3NhZ2UgYW5kIHJlbGF0ZWQgb3B0aW9uYWwgYWN0aW9ucy4nO1xyXG5jb25zdCBsaW5rcyA9IHtcclxuICAgIGRvY3M6ICdodHRwczovL2dpdGh1Yi5jb20vbWF0ZXJpYWwtY29tcG9uZW50cy9tYXRlcmlhbC1jb21wb25lbnRzLXdlYi90cmVlL21hc3Rlci9wYWNrYWdlcy9tZGMtYmFubmVyJyxcclxuICAgIGd1aWRlOiAnaHR0cHM6Ly9tYXRlcmlhbC5pby9jb21wb25lbnRzL2Jhbm5lcnMnXHJcbn07XHJcblxyXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBCYWRnZVBhZ2UoKSB7XHJcbiAgICBjb25zdCBbb3Blbiwgc2V0T3Blbl0gPSB1c2VTdGF0ZShmYWxzZSk7XHJcbiAgICBjb25zdCBbdGV4dCwgc2V0VGV4dF0gPSB1c2VTdGF0ZSgnTG9yZW0gaXBzdW0nKTtcclxuICAgIGNvbnN0IFtoYXNJY29uLCBzZXRIYXNJY29uXSA9IHVzZVN0YXRlKGZhbHNlKTtcclxuICAgIGNvbnN0IFtpY29uLCBzZXRJY29uXSA9IHVzZVN0YXRlKCcnKTtcclxuICAgIGNvbnN0IFtoYXNBY3Rpb24sIHNldEhhc0FjdGlvbl0gPSB1c2VTdGF0ZShmYWxzZSk7XHJcbiAgICBjb25zdCBbYWN0aW9uLCBzZXRBY3Rpb25dID0gdXNlU3RhdGUoJycpO1xyXG4gICAgY29uc3QgW2hhc1NlY29uZGFyeUFjdGlvbiwgc2V0SGFzU2Vjb25kYXJ5QWN0aW9uXSA9IHVzZVN0YXRlKGZhbHNlKTtcclxuICAgIGNvbnN0IFtzZWNvbmRhcnlBY3Rpb24sIHNldFNlY29uZGFyeUFjdGlvbl0gPSB1c2VTdGF0ZSgnJyk7XHJcbiAgICBjb25zdCBbY2VudGVyZWQsIHNldENlbnRlcmVkXSA9IHVzZVN0YXRlKGZhbHNlKTtcclxuICAgIGNvbnN0IFtmaXhlZCwgc2V0Rml4ZWRdID0gdXNlU3RhdGUoZmFsc2UpO1xyXG4gICAgY29uc3QgW21vYmlsZVN0YWNrZWQsIHNldE1vYmlsZVN0YWNrZWRdID0gdXNlU3RhdGUoZmFsc2UpO1xyXG5cclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgPFBhZ2UgaWQ9e2lkfSB0aXRsZT17dGl0bGV9IGRlc2NyaXB0aW9uPXtkZXNjcmlwdGlvbn0gbGlua3M9e2xpbmtzfT5cclxuICAgICAgICAgICAgPERlbW9cclxuICAgICAgICAgICAgICAgIHRpdGxlPVwiRGVtb1wiXHJcbiAgICAgICAgICAgICAgICBzZXR1cD17XHJcbiAgICAgICAgICAgICAgICAgICAgPFRvcEFwcEJhclxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aXRsZT1cIlRpdGxlXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgYWN0aW9uSXRlbXM9e1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPEJ1dHRvblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsPVwiVG9nZ2xlXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbkNsaWNrPXsoKSA9PiBzZXRPcGVuKHYgPT4gIXYpfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLz5cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByYWlzZWRcclxuICAgICAgICAgICAgICAgICAgICAvPlxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgc2V0dGluZ3M9ezw+XHJcbiAgICAgICAgICAgICAgICAgICAgPFRleHRGaWVsZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZT17dGV4dH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWw9XCJUZXh0XCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgb25DaGFuZ2U9eyhfLCB2YWx1ZSkgPT4gc2V0VGV4dCh2YWx1ZSl9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dGxpbmVkXHJcbiAgICAgICAgICAgICAgICAgICAgLz5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgPFRleHRGaWVsZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZT17aWNvbn1cclxuICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWw9XCJJY29uXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgdHJhaWxpbmdJY29uPXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxTd2l0Y2hcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3RlZD17aGFzSWNvbn1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbkNoYW5nZT17KCkgPT4gc2V0SGFzSWNvbih2ID0+ICF2KX1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgb3V0bGluZWRcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGlzYWJsZWQ9eyFoYXNJY29ufVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBvbkNoYW5nZT17KF8sIHZhbHVlKSA9PiBzZXRJY29uKHZhbHVlKX1cclxuICAgICAgICAgICAgICAgICAgICAvPlxyXG5cclxuICAgICAgICAgICAgICAgICAgICA8VGV4dEZpZWxkXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlPXthY3Rpb259XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsPVwiQWN0aW9uXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgdHJhaWxpbmdJY29uPXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxTd2l0Y2hcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3RlZD17aGFzQWN0aW9ufVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2hhbmdlPXsoKSA9PiBzZXRIYXNBY3Rpb24odiA9PiAhdil9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpc2FibGVkPXshaGFzQWN0aW9ufVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRsaW5lZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBvbkNoYW5nZT17KF8sIHZhbHVlKSA9PiBzZXRBY3Rpb24odmFsdWUpfVxyXG4gICAgICAgICAgICAgICAgICAgIC8+XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIDxUZXh0RmllbGRcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU9e3NlY29uZGFyeUFjdGlvbn1cclxuICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWw9XCJTZWNvbmRhcnkgYWN0aW9uXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgdHJhaWxpbmdJY29uPXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxTd2l0Y2hcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3RlZD17aGFzU2Vjb25kYXJ5QWN0aW9ufVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2hhbmdlPXsoKSA9PiBzZXRIYXNTZWNvbmRhcnlBY3Rpb24odiA9PiAhdil9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpc2FibGVkPXshaGFzU2Vjb25kYXJ5QWN0aW9ufVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRsaW5lZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBvbkNoYW5nZT17KF8sIHZhbHVlKSA9PiBzZXRTZWNvbmRhcnlBY3Rpb24odmFsdWUpfVxyXG4gICAgICAgICAgICAgICAgICAgIC8+XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIDxGb3JtRmllbGQgbGFiZWw9XCJDZW50ZXJlZFwiIGFsaWduRW5kIHNwYWNlQmV0d2Vlbj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPFN3aXRjaFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0ZWQ9e2NlbnRlcmVkfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb25DaGFuZ2U9eygpID0+IHNldENlbnRlcmVkKHYgPT4gIXYpfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvPlxyXG4gICAgICAgICAgICAgICAgICAgIDwvRm9ybUZpZWxkPlxyXG5cclxuICAgICAgICAgICAgICAgICAgICA8Rm9ybUZpZWxkIGxhYmVsPVwiRml4ZWRcIiBhbGlnbkVuZCBzcGFjZUJldHdlZW4+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxTd2l0Y2hcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdGVkPXtmaXhlZH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2hhbmdlPXsoKSA9PiBzZXRGaXhlZCh2ID0+ICF2KX1cclxuICAgICAgICAgICAgICAgICAgICAgICAgLz5cclxuICAgICAgICAgICAgICAgICAgICA8L0Zvcm1GaWVsZD5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgPEZvcm1GaWVsZCBsYWJlbD1cIk1vYmlsZSBzdGFja2VkXCIgYWxpZ25FbmQgc3BhY2VCZXR3ZWVuPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8U3dpdGNoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3RlZD17bW9iaWxlU3RhY2tlZH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2hhbmdlPXsoKSA9PiBzZXRNb2JpbGVTdGFja2VkKHYgPT4gIXYpfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvPlxyXG4gICAgICAgICAgICAgICAgICAgIDwvRm9ybUZpZWxkPlxyXG4gICAgICAgICAgICAgICAgPC8+fVxyXG4gICAgICAgICAgICA+XHJcbiAgICAgICAgICAgICAgICA8QmFubmVyXHJcbiAgICAgICAgICAgICAgICAgICAgdGV4dD17dGV4dH1cclxuICAgICAgICAgICAgICAgICAgICBpY29uPXtoYXNJY29uID8gaWNvbiA6IHVuZGVmaW5lZH1cclxuICAgICAgICAgICAgICAgICAgICBhY3Rpb249e2hhc0FjdGlvbiA/XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxCdXR0b24+e2FjdGlvbn08L0J1dHRvbj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB1bmRlZmluZWRcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgc2Vjb25kYXJ5QWN0aW9uPXtoYXNTZWNvbmRhcnlBY3Rpb24gP1xyXG4gICAgICAgICAgICAgICAgICAgICAgICA8QnV0dG9uPntzZWNvbmRhcnlBY3Rpb259PC9CdXR0b24+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgdW5kZWZpbmVkXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIG9wZW49e29wZW4gfHwgdW5kZWZpbmVkfVxyXG4gICAgICAgICAgICAgICAgICAgIGNlbnRlcmVkPXtjZW50ZXJlZCB8fCB1bmRlZmluZWR9XHJcbiAgICAgICAgICAgICAgICAgICAgZml4ZWQ9e2ZpeGVkIHx8IHVuZGVmaW5lZH1cclxuICAgICAgICAgICAgICAgICAgICBtb2JpbGVTdGFja2VkPXttb2JpbGVTdGFja2VkIHx8IHVuZGVmaW5lZH1cclxuICAgICAgICAgICAgICAgIC8+XHJcbiAgICAgICAgICAgIDwvRGVtbz5cclxuICAgICAgICA8L1BhZ2U+XHJcbiAgICApO1xyXG59IiwiaW1wb3J0IHsgdXNlU3RhdGUgfSBmcm9tICdyZWFjdCc7XHJcbmltcG9ydCB7XHJcbiAgICBCdXR0b24sXHJcbiAgICBTZWdtZW50ZWRCdXR0b24sXHJcbiAgICBTd2l0Y2gsXHJcbiAgICBUZXh0RmllbGRcclxufSBmcm9tICdtZGMtcmVhY3QnO1xyXG5cclxuaW1wb3J0IERlbW8gZnJvbSAnQC9jb21wb25lbnRzL0RlbW8nO1xyXG5pbXBvcnQgRmllbGRTZXQgZnJvbSAnQC9jb21wb25lbnRzL0ZpZWxkU2V0JztcclxuaW1wb3J0IFBhZ2UgZnJvbSAnQC9jb21wb25lbnRzL1BhZ2UnO1xyXG5cclxuY29uc3QgaWQgPSAnYnV0dG9uJztcclxuY29uc3QgdGl0bGUgPSAnQnV0dG9uJztcclxuY29uc3QgZGVzY3JpcHRpb24gPSAnQnV0dG9ucyBjb21tdW5pY2F0ZSBhbiBhY3Rpb24gYSB1c2VyIGNhbiB0YWtlLiBUaGV5IGFyZSB0eXBpY2FsbHkgcGxhY2VkIHRocm91Z2hvdXQgeW91ciBVSSwgaW4gcGxhY2VzIGxpa2UgZGlhbG9ncywgZm9ybXMsIGNhcmRzLCBhbmQgdG9vbGJhcnMuJztcclxuY29uc3QgbGlua3MgPSB7XHJcbiAgICBkb2NzOiAnaHR0cHM6Ly9naXRodWIuY29tL21hdGVyaWFsLWNvbXBvbmVudHMvbWF0ZXJpYWwtY29tcG9uZW50cy13ZWIvdHJlZS9tYXN0ZXIvcGFja2FnZXMvbWRjLWJ1dHRvbicsXHJcbiAgICBndWlkZTogJ2h0dHBzOi8vbWF0ZXJpYWwuaW8vY29tcG9uZW50cy9idXR0b25zJ1xyXG59O1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gQnV0dG9uUGFnZSgpIHtcclxuICAgIGNvbnN0IFtsYWJlbCwgc2V0TGFiZWxdID0gdXNlU3RhdGUoJ0J1dHRvbicpO1xyXG4gICAgY29uc3QgW2hhc0xlYWRpbmdJY29uLCBzZXRIYXNMZWFkaW5nSWNvbl0gPSB1c2VTdGF0ZShmYWxzZSk7XHJcbiAgICBjb25zdCBbbGVhZGluZ0ljb24sIHNldExlYWRpbmdJY29uXSA9IHVzZVN0YXRlKCdzYXZlJyk7XHJcbiAgICBjb25zdCBbaGFzVHJhaWxpbmdJY29uLCBzZXRIYXNUcmFpbGluZ0ljb25dID0gdXNlU3RhdGUoZmFsc2UpO1xyXG4gICAgY29uc3QgW3RyYWlsaW5nSWNvbiwgc2V0VHJhaWxpbmdJY29uXSA9IHVzZVN0YXRlKCdjbG9zZScpO1xyXG4gICAgY29uc3QgW3R5cGUsIHNldFR5cGVdID0gdXNlU3RhdGUoJ3BsYWluJyk7XHJcblxyXG4gICAgcmV0dXJuIChcclxuICAgICAgICA8UGFnZSBpZD17aWR9IHRpdGxlPXt0aXRsZX0gZGVzY3JpcHRpb249e2Rlc2NyaXB0aW9ufSBsaW5rcz17bGlua3N9PlxyXG4gICAgICAgICAgICA8RGVtb1xyXG4gICAgICAgICAgICAgICAgdGl0bGU9XCJEZW1vXCJcclxuICAgICAgICAgICAgICAgIHNldHRpbmdzPXs8PlxyXG4gICAgICAgICAgICAgICAgICAgIDxUZXh0RmllbGRcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU9e2xhYmVsfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBsYWJlbD1cIkxhYmVsXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgb3V0bGluZWRcclxuICAgICAgICAgICAgICAgICAgICAgICAgb25DaGFuZ2U9eyhfLCB2YWx1ZSkgPT4gc2V0TGFiZWwodmFsdWUpfVxyXG4gICAgICAgICAgICAgICAgICAgIC8+XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIDxUZXh0RmllbGRcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU9e2xlYWRpbmdJY29ufVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBsYWJlbD1cIkxlYWRpbmcgaWNvblwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYWlsaW5nSWNvbj17XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8U3dpdGNoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0ZWQ9e2hhc0xlYWRpbmdJY29ufVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2hhbmdlPXsoKSA9PiBzZXRIYXNMZWFkaW5nSWNvbih2ID0+ICF2KX1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgb3V0bGluZWRcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGlzYWJsZWQ9eyFoYXNMZWFkaW5nSWNvbn1cclxuICAgICAgICAgICAgICAgICAgICAgICAgb25DaGFuZ2U9eyhfLCB2YWx1ZSkgPT4gc2V0TGVhZGluZ0ljb24odmFsdWUpfVxyXG4gICAgICAgICAgICAgICAgICAgIC8+XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIDxUZXh0RmllbGRcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU9e3RyYWlsaW5nSWNvbn1cclxuICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWw9XCJUcmFpbGluZyBpY29uXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgdHJhaWxpbmdJY29uPXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxTd2l0Y2hcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3RlZD17aGFzVHJhaWxpbmdJY29ufVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2hhbmdlPXsoKSA9PiBzZXRIYXNUcmFpbGluZ0ljb24odiA9PiAhdil9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dGxpbmVkXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpc2FibGVkPXshaGFzVHJhaWxpbmdJY29ufVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBvbkNoYW5nZT17KF8sIHZhbHVlKSA9PiBzZXRUcmFpbGluZ0ljb24odmFsdWUpfVxyXG4gICAgICAgICAgICAgICAgICAgIC8+XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIDxGaWVsZFNldCBsZWdlbmQ9XCJUeXBlXCI+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxTZWdtZW50ZWRCdXR0b25cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlZ21lbnRzPXtbXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeyB2YWx1ZTogJ3BsYWluJywgbGFiZWw6ICdQbGFpbicgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7IHZhbHVlOiAnb3V0bGluZWQnLCBsYWJlbDogJ091dGxpbmVkJyB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgdmFsdWU6ICd1bmVsZXZhdGVkJywgbGFiZWw6ICdVbmVsZXZhdGVkJyB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgdmFsdWU6ICdyYWlzZWQnLCBsYWJlbDogJ1JhaXNlZCcgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXX1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlPXt0eXBlfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb25DaGFuZ2U9e3NldFR5cGV9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8+XHJcbiAgICAgICAgICAgICAgICAgICAgPC9GaWVsZFNldD5cclxuICAgICAgICAgICAgICAgIDwvPn1cclxuICAgICAgICAgICAgPlxyXG4gICAgICAgICAgICAgICAgPEJ1dHRvblxyXG4gICAgICAgICAgICAgICAgICAgIGxlYWRpbmdJY29uPXtoYXNMZWFkaW5nSWNvbiA/IGxlYWRpbmdJY29uIDogdW5kZWZpbmVkfVxyXG4gICAgICAgICAgICAgICAgICAgIHRyYWlsaW5nSWNvbj17aGFzVHJhaWxpbmdJY29uID8gdHJhaWxpbmdJY29uIDogdW5kZWZpbmVkfVxyXG4gICAgICAgICAgICAgICAgICAgIG91dGxpbmVkPXt0eXBlID09PSAnb3V0bGluZWQnIHx8IHVuZGVmaW5lZH1cclxuICAgICAgICAgICAgICAgICAgICB1bmVsZXZhdGVkPXt0eXBlID09PSAndW5lbGV2YXRlZCcgfHwgdW5kZWZpbmVkfVxyXG4gICAgICAgICAgICAgICAgICAgIHJhaXNlZD17dHlwZSA9PT0gJ3JhaXNlZCcgfHwgdW5kZWZpbmVkfVxyXG4gICAgICAgICAgICAgICAgPlxyXG4gICAgICAgICAgICAgICAgICAgIHtsYWJlbH1cclxuICAgICAgICAgICAgICAgIDwvQnV0dG9uPlxyXG4gICAgICAgICAgICA8L0RlbW8+XHJcbiAgICAgICAgPC9QYWdlPlxyXG4gICAgKTtcclxufSIsImltcG9ydCB7IHVzZVN0YXRlIH0gZnJvbSAncmVhY3QnO1xyXG5pbXBvcnQge1xyXG4gICAgQ2FyZCxcclxuICAgIFN3aXRjaCxcclxuICAgIFRleHRGaWVsZFxyXG59IGZyb20gJ21kYy1yZWFjdCc7XHJcblxyXG5pbXBvcnQgRGVtbyBmcm9tICdAL2NvbXBvbmVudHMvRGVtbyc7XHJcbmltcG9ydCBQYWdlIGZyb20gJ0AvY29tcG9uZW50cy9QYWdlJztcclxuXHJcbmNvbnN0IGlkID0gJ2NhcmQnO1xyXG5jb25zdCBwYWdlVGl0bGUgPSAnQ2FyZCc7XHJcbmNvbnN0IGRlc2NyaXB0aW9uID0gJ0NhcmRzIGNvbnRhaW4gY29udGVudCBhbmQgYWN0aW9ucyBhYm91dCBhIHNpbmdsZSBzdWJqZWN0Lic7XHJcbmNvbnN0IGxpbmtzID0ge1xyXG4gICAgZG9jczogJ2h0dHBzOi8vZ2l0aHViLmNvbS9tYXRlcmlhbC1jb21wb25lbnRzL21hdGVyaWFsLWNvbXBvbmVudHMtd2ViL3RyZWUvbWFzdGVyL3BhY2thZ2VzL21kYy1jYXJkJyxcclxuICAgIGd1aWRlOiAnaHR0cHM6Ly9tYXRlcmlhbC5pby9jb21wb25lbnRzL2NhcmRzJ1xyXG59OyAnJztcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIENhcmRQYWdlKCkge1xyXG4gICAgY29uc3QgW2hhc1RpdGxlLCBzZXRIYXNUaXRsZV0gPSB1c2VTdGF0ZSh0cnVlKTtcclxuICAgIGNvbnN0IFt0aXRsZSwgc2V0VGl0bGVdID0gdXNlU3RhdGUoJ1RpdGxlJyk7XHJcbiAgICBjb25zdCBbaGFzU3VidGl0bGUsIHNldEhhc1N1YnRpdGxlXSA9IHVzZVN0YXRlKHRydWUpO1xyXG4gICAgY29uc3QgW3N1YnRpdGxlLCBzZXRTdWJ0aXRsZV0gPSB1c2VTdGF0ZSgnU3VidGl0bGUnKTtcclxuXHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAgIDxQYWdlXHJcbiAgICAgICAgICAgIGlkPXtpZH1cclxuICAgICAgICAgICAgdGl0bGU9e3BhZ2VUaXRsZX1cclxuICAgICAgICAgICAgZGVzY3JpcHRpb249e2Rlc2NyaXB0aW9ufVxyXG4gICAgICAgICAgICBsaW5rcz17bGlua3N9XHJcbiAgICAgICAgPlxyXG4gICAgICAgICAgICA8RGVtb1xyXG4gICAgICAgICAgICAgICAgc2V0dGluZ3M9ezw+XHJcbiAgICAgICAgICAgICAgICAgICAgPFRleHRGaWVsZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZT17dGl0bGV9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsPVwiVGl0bGVcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0cmFpbGluZ0ljb249e1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPFN3aXRjaFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdGVkPXtoYXNUaXRsZX1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbkNoYW5nZT17KCkgPT4gc2V0SGFzVGl0bGUodiA9PiAhdil9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dGxpbmVkXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpc2FibGVkPXshaGFzVGl0bGV9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2hhbmdlPXsoXywgdmFsdWUpID0+IHNldFRpdGxlKHZhbHVlKX1cclxuICAgICAgICAgICAgICAgICAgICAvPlxyXG5cclxuICAgICAgICAgICAgICAgICAgICA8VGV4dEZpZWxkXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlPXtzdWJ0aXRsZX1cclxuICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWw9XCJTdWJ0aXRsZVwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYWlsaW5nSWNvbj17XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8U3dpdGNoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0ZWQ9e2hhc1N1YnRpdGxlfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2hhbmdlPXsoKSA9PiBzZXRIYXNTdWJ0aXRsZSh2ID0+ICF2KX1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgb3V0bGluZWRcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGlzYWJsZWQ9eyFoYXNTdWJ0aXRsZX1cclxuICAgICAgICAgICAgICAgICAgICAgICAgb25DaGFuZ2U9eyhfLCB2YWx1ZSkgPT4gc2V0U3VidGl0bGUodmFsdWUpfVxyXG4gICAgICAgICAgICAgICAgICAgIC8+XHJcbiAgICAgICAgICAgICAgICA8Lz59XHJcbiAgICAgICAgICAgID5cclxuICAgICAgICAgICAgICAgIDxDYXJkPlxyXG4gICAgICAgICAgICAgICAgICAgIDxDYXJkLkhlYWRlclxyXG4gICAgICAgICAgICAgICAgICAgICAgICBvdmVybGluZT1cIk92ZXJsaW5lXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGU9e2hhc1RpdGxlID8gdGl0bGUgOiB1bmRlZmluZWR9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1YnRpdGxlPXtoYXNTdWJ0aXRsZSA/IHN1YnRpdGxlIDogdW5kZWZpbmVkfVxyXG4gICAgICAgICAgICAgICAgICAgIC8+XHJcbiAgICAgICAgICAgICAgICA8L0NhcmQ+XHJcbiAgICAgICAgICAgIDwvRGVtbz5cclxuICAgICAgICA8L1BhZ2UgPlxyXG4gICAgKTtcclxufSIsImltcG9ydCB7IHVzZVN0YXRlIH0gZnJvbSAncmVhY3QnO1xyXG5pbXBvcnQgeyBDaGVja2JveCB9IGZyb20gJ21kYy1yZWFjdCc7XHJcblxyXG5pbXBvcnQgRGVtbyBmcm9tICdAL2NvbXBvbmVudHMvRGVtbyc7XHJcbmltcG9ydCBQYWdlIGZyb20gJ0AvY29tcG9uZW50cy9QYWdlJztcclxuXHJcbmNvbnN0IGlkID0gJ2NoZWNrYm94JztcclxuY29uc3QgdGl0bGUgPSAnQ2hlY2tib3gnO1xyXG5jb25zdCBkZXNjcmlwdGlvbiA9ICdDaGVja2JveGVzIGFsbG93IHRoZSB1c2VyIHRvIHNlbGVjdCBtdWx0aXBsZSBvcHRpb25zIGZyb20gYSBzZXQuJztcclxuY29uc3QgbGlua3MgPSB7XHJcbiAgICBkb2NzOiAnaHR0cHM6Ly9naXRodWIuY29tL21hdGVyaWFsLWNvbXBvbmVudHMvbWF0ZXJpYWwtY29tcG9uZW50cy13ZWIvdHJlZS9tYXN0ZXIvcGFja2FnZXMvbWRjLWNoZWNrYm94JyxcclxuICAgIGd1aWRlOiAnaHR0cHM6Ly9tYXRlcmlhbC5pby9jb21wb25lbnRzL2NoZWNrYm94ZXMnXHJcbn07XHJcblxyXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBDaGVja2JveFBhZ2UoKSB7XHJcbiAgICBjb25zdCBbY2hlY2tlZCwgc2V0Q2hlY2tlZF0gPSB1c2VTdGF0ZShmYWxzZSk7XHJcbiAgICBjb25zdCBbY29udHJvbGxlZCwgc2V0Q29udHJvbGxlZF0gPSB1c2VTdGF0ZSh0cnVlKTtcclxuICAgIGNvbnN0IFtpbmRldGVybWluYXRlLCBzZXRJbmRldGVybWluYXRlXSA9IHVzZVN0YXRlKCk7XHJcbiAgICBjb25zdCBbZGlzYWJsZWQsIHNldERpc2FibGVkXSA9IHVzZVN0YXRlKCk7XHJcblxyXG4gICAgcmV0dXJuIChcclxuICAgICAgICA8UGFnZSBpZD17aWR9IHRpdGxlPXt0aXRsZX0gZGVzY3JpcHRpb249e2Rlc2NyaXB0aW9ufSBsaW5rcz17bGlua3N9PlxyXG4gICAgICAgICAgICA8RGVtbz5cclxuICAgICAgICAgICAgICAgIDxDaGVja2JveFxyXG4gICAgICAgICAgICAgICAgICAgIGNoZWNrZWQ9e2NvbnRyb2xsZWQgPyBjaGVja2VkIDogdW5kZWZpbmVkfVxyXG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHRDaGVja2VkPXshY29udHJvbGxlZCA/IGZhbHNlIDogdW5kZWZpbmVkfVxyXG4gICAgICAgICAgICAgICAgICAgIGluZGV0ZXJtaW5hdGU9e2luZGV0ZXJtaW5hdGV9XHJcbiAgICAgICAgICAgICAgICAgICAgZGlzYWJsZWQ9e2Rpc2FibGVkfVxyXG4gICAgICAgICAgICAgICAgICAgIG9uQ2hhbmdlPXsoKSA9PiBzZXRDaGVja2VkKHYgPT4gIXYpfVxyXG4gICAgICAgICAgICAgICAgLz5cclxuICAgICAgICAgICAgPC9EZW1vPlxyXG4gICAgICAgIDwvUGFnZT5cclxuICAgICk7XHJcbn0iLCJpbXBvcnQgeyB1c2VTdGF0ZSB9IGZyb20gJ3JlYWN0JztcclxuaW1wb3J0IHtcclxuICAgIEF2YXRhcixcclxuICAgIENoaXBTZXQsIENoaXBcclxufSBmcm9tICdtZGMtcmVhY3QnO1xyXG5cclxuaW1wb3J0IERlbW8gZnJvbSAnQC9jb21wb25lbnRzL0RlbW8nO1xyXG5pbXBvcnQgUGFnZSBmcm9tICdAL2NvbXBvbmVudHMvUGFnZSc7XHJcblxyXG5jb25zdCBpZCA9ICdjaGlwcyc7XHJcbmNvbnN0IHRpdGxlID0gJ0NoaXBzJztcclxuY29uc3QgZGVzY3JpcHRpb24gPSAnQ2hpcHMgYXJlIGNvbXBhY3QgZWxlbWVudHMgdGhhdCBhbGxvdyB1c2VycyB0byBlbnRlciBpbmZvcm1hdGlvbiwgc2VsZWN0IGEgY2hvaWNlLCBmaWx0ZXIgY29udGVudCwgb3IgdHJpZ2dlciBhbiBhY3Rpb24uJztcclxuY29uc3QgbGlua3MgPSB7XHJcbiAgICBkb2NzOiAnaHR0cHM6Ly9naXRodWIuY29tL21hdGVyaWFsLWNvbXBvbmVudHMvbWF0ZXJpYWwtY29tcG9uZW50cy13ZWIvdHJlZS9tYXN0ZXIvcGFja2FnZXMvbWRjLWNoaXBzJyxcclxuICAgIGd1aWRlOiAnaHR0cHM6Ly9tYXRlcmlhbC5pby9jb21wb25lbnRzL2NoaXBzJ1xyXG59O1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gQ2hpcHNQYWdlKCkge1xyXG4gICAgY29uc3QgW2Nob2ljZUNoaXAsIHNldENob2ljZUNoaXBzXSA9IHVzZVN0YXRlKCdmb28nKTtcclxuICAgIGNvbnN0IFtmaWx0ZXJDaGlwcywgc2V0RmlsdGVyQ2hpcHNdID0gdXNlU3RhdGUoWydmb28nXSk7XHJcblxyXG4gICAgcmV0dXJuIChcclxuICAgICAgICA8UGFnZSBpZD17aWR9IHRpdGxlPXt0aXRsZX0gZGVzY3JpcHRpb249e2Rlc2NyaXB0aW9ufSBsaW5rcz17bGlua3N9PlxyXG4gICAgICAgICAgICA8RGVtbyB0aXRsZT1cIkJhc2ljIGNoaXBzXCI+XHJcbiAgICAgICAgICAgICAgICA8Q2hpcFNldD5cclxuICAgICAgICAgICAgICAgICAgICA8Q2hpcCB0ZXh0PVwiRm9vXCIgLz5cclxuICAgICAgICAgICAgICAgICAgICA8Q2hpcCB0ZXh0PVwiQmFyXCIgLz5cclxuICAgICAgICAgICAgICAgICAgICA8Q2hpcCB0ZXh0PVwiQmF6XCIgLz5cclxuICAgICAgICAgICAgICAgIDwvQ2hpcFNldD5cclxuICAgICAgICAgICAgPC9EZW1vPlxyXG5cclxuICAgICAgICAgICAgPERlbW8gdGl0bGU9XCJDaGlwcyB3aXRoIGljb25zXCI+XHJcbiAgICAgICAgICAgICAgICA8Q2hpcFNldD5cclxuICAgICAgICAgICAgICAgICAgICA8Q2hpcCB0ZXh0PVwiRm9vXCIgaWNvbj1cInN0YXJcIiAvPlxyXG4gICAgICAgICAgICAgICAgICAgIDxDaGlwIHRleHQ9XCJCYXJcIiBpY29uPVwic3RhclwiIC8+XHJcbiAgICAgICAgICAgICAgICAgICAgPENoaXAgdGV4dD1cIkJhelwiIGljb249XCJzdGFyXCIgLz5cclxuICAgICAgICAgICAgICAgIDwvQ2hpcFNldD5cclxuICAgICAgICAgICAgPC9EZW1vPlxyXG5cclxuICAgICAgICAgICAgPERlbW8gdGl0bGU9XCJDaGlwcyB3aXRoIHRyYWlsaW5nIGljb25zXCI+XHJcbiAgICAgICAgICAgICAgICA8Q2hpcFNldD5cclxuICAgICAgICAgICAgICAgICAgICA8Q2hpcCB0ZXh0PVwiRm9vXCIgdHJhaWxpbmdJY29uPVwiZGVsZXRlXCIgLz5cclxuICAgICAgICAgICAgICAgICAgICA8Q2hpcCB0ZXh0PVwiQmFyXCIgdHJhaWxpbmdJY29uPVwiZGVsZXRlXCIgLz5cclxuICAgICAgICAgICAgICAgICAgICA8Q2hpcCB0ZXh0PVwiQmF6XCIgdHJhaWxpbmdJY29uPVwiZGVsZXRlXCIgLz5cclxuICAgICAgICAgICAgICAgIDwvQ2hpcFNldD5cclxuICAgICAgICAgICAgPC9EZW1vPlxyXG5cclxuICAgICAgICAgICAgPERlbW8gdGl0bGU9XCJDaGlwcyB3aXRoIGF2YXRhcnNcIj5cclxuICAgICAgICAgICAgICAgIDxDaGlwU2V0PlxyXG4gICAgICAgICAgICAgICAgICAgIDxDaGlwIHRleHQ9XCJGb29cIiBhdmF0YXI9ezxBdmF0YXIgaW1hZ2U9XCJodHRwczovL3BsYWNlaW1nLmNvbS8xMjgvMTI4L3Blb3BsZVwiIHNpemU9XCJzbWFsbFwiIC8+fSAvPlxyXG4gICAgICAgICAgICAgICAgICAgIDxDaGlwIHRleHQ9XCJCYXJcIiBhdmF0YXI9ezxBdmF0YXIgaW1hZ2U9XCJodHRwczovL3BsYWNlaW1nLmNvbS8xMjgvMTI4L3Blb3BsZVwiIHNpemU9XCJzbWFsbFwiIC8+fSAvPlxyXG4gICAgICAgICAgICAgICAgICAgIDxDaGlwIHRleHQ9XCJCYXpcIiBhdmF0YXI9ezxBdmF0YXIgaW1hZ2U9XCJodHRwczovL3BsYWNlaW1nLmNvbS8xMjgvMTI4L3Blb3BsZVwiIHNpemU9XCJzbWFsbFwiIC8+fSAvPlxyXG4gICAgICAgICAgICAgICAgPC9DaGlwU2V0PlxyXG4gICAgICAgICAgICA8L0RlbW8+XHJcblxyXG4gICAgICAgICAgICA8RGVtbyB0aXRsZT1cIkNob2ljZSBjaGlwc1wiPlxyXG4gICAgICAgICAgICAgICAgPENoaXBTZXQgdmFsdWU9e2Nob2ljZUNoaXB9IG9uQ2hhbmdlPXt2YWx1ZSA9PiBzZXRDaG9pY2VDaGlwcyh2YWx1ZSl9PlxyXG4gICAgICAgICAgICAgICAgICAgIDxDaGlwIHZhbHVlPVwiZm9vXCIgdGV4dD1cIkZvb1wiIC8+XHJcbiAgICAgICAgICAgICAgICAgICAgPENoaXAgdmFsdWU9XCJiYXJcIiB0ZXh0PVwiQmFyXCIgLz5cclxuICAgICAgICAgICAgICAgICAgICA8Q2hpcCB2YWx1ZT1cImJhelwiIHRleHQ9XCJCYXpcIiAvPlxyXG4gICAgICAgICAgICAgICAgPC9DaGlwU2V0PlxyXG4gICAgICAgICAgICA8L0RlbW8+XHJcblxyXG4gICAgICAgICAgICA8RGVtbyB0aXRsZT1cIkZpbHRlciBjaGlwc1wiPlxyXG4gICAgICAgICAgICAgICAgPENoaXBTZXQgdmFsdWU9e2ZpbHRlckNoaXBzfSBvbkNoYW5nZT17dmFsdWUgPT4gc2V0RmlsdGVyQ2hpcHModmFsdWUpfT5cclxuICAgICAgICAgICAgICAgICAgICA8Q2hpcCB2YWx1ZT1cImZvb1wiIHRleHQ9XCJGb29cIiAvPlxyXG4gICAgICAgICAgICAgICAgICAgIDxDaGlwIHZhbHVlPVwiYmFyXCIgdGV4dD1cIkJhclwiIC8+XHJcbiAgICAgICAgICAgICAgICAgICAgPENoaXAgdmFsdWU9XCJiYXpcIiB0ZXh0PVwiQmF6XCIgLz5cclxuICAgICAgICAgICAgICAgIDwvQ2hpcFNldD5cclxuICAgICAgICAgICAgPC9EZW1vPlxyXG4gICAgICAgIDwvUGFnZT5cclxuICAgICk7XHJcbn0iLCJpbXBvcnQgeyB1c2VTdGF0ZSB9IGZyb20gJ3JlYWN0JztcclxuaW1wb3J0IHtcclxuICAgIEJ1dHRvbixcclxuICAgIENpcmN1bGFyUHJvZ3Jlc3MsXHJcbiAgICBTZWdtZW50ZWRCdXR0b24sXHJcbiAgICBGb3JtRmllbGQsXHJcbiAgICBTd2l0Y2gsXHJcbiAgICBUZXh0RmllbGRcclxufSBmcm9tICdtZGMtcmVhY3QnO1xyXG5cclxuaW1wb3J0IERlbW8gZnJvbSAnQC9jb21wb25lbnRzL0RlbW8nO1xyXG5pbXBvcnQgRmllbGRTZXQgZnJvbSAnQC9jb21wb25lbnRzL0ZpZWxkU2V0JztcclxuaW1wb3J0IFBhZ2UgZnJvbSAnQC9jb21wb25lbnRzL1BhZ2UnO1xyXG5cclxuY29uc3QgaWQgPSAnY2lyY3VsYXItcHJvZ3Jlc3MnO1xyXG5jb25zdCB0aXRsZSA9ICdDaXJjdWxhciBQcm9ncmVzcyc7XHJcbmNvbnN0IGRlc2NyaXB0aW9uID0gJ0NpcmN1bGFyIHByb2dyZXNzIGluZGljYXRvcnMgZGlzcGxheSBwcm9ncmVzcyBieSBhbmltYXRpbmcgYW4gaW5kaWNhdG9yIGFsb25nIGFuIGludmlzaWJsZSBjaXJjdWxhciB0cmFjayBpbiBhIGNsb2Nrd2lzZSBkaXJlY3Rpb24uJztcclxuY29uc3QgbGlua3MgPSB7XHJcbiAgICBkb2NzOiAnaHR0cHM6Ly9naXRodWIuY29tL21hdGVyaWFsLWNvbXBvbmVudHMvbWF0ZXJpYWwtY29tcG9uZW50cy13ZWIvdHJlZS9tYXN0ZXIvcGFja2FnZXMvbWRjLWNpcmN1bGFyLXByb2dyZXNzJyxcclxuICAgIGd1aWRlOiAnaHR0cHM6Ly9tYXRlcmlhbC5pby9jb21wb25lbnRzL3Byb2dyZXNzLWluZGljYXRvcnMjY2lyY3VsYXItcHJvZ3Jlc3MtaW5kaWNhdG9ycydcclxufTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIENpcmN1bGFyUHJvZ3Jlc3NQYWdlKCkge1xyXG4gICAgY29uc3QgW3ZhbHVlLCBzZXRWYWx1ZV0gPSB1c2VTdGF0ZSg0Mik7XHJcbiAgICBjb25zdCBbc2l6ZSwgc2V0U2l6ZV0gPSB1c2VTdGF0ZSgnbWVkaXVtJyk7XHJcbiAgICBjb25zdCBbaW5kZXRlcm1pbmF0ZSwgc2V0SW5kZXRlcm1pbmF0ZV0gPSB1c2VTdGF0ZShmYWxzZSk7XHJcbiAgICBjb25zdCBbY29sb3JmdWwsIHNldENvbG9yZnVsXSA9IHVzZVN0YXRlKGZhbHNlKTtcclxuICAgIGNvbnN0IFtjbG9zZWQsIHNldENsb3NlZF0gPSB1c2VTdGF0ZShmYWxzZSk7XHJcblxyXG4gICAgcmV0dXJuIChcclxuICAgICAgICA8UGFnZSBpZD17aWR9IHRpdGxlPXt0aXRsZX0gZGVzY3JpcHRpb249e2Rlc2NyaXB0aW9ufSBsaW5rcz17bGlua3N9PlxyXG4gICAgICAgICAgICA8RGVtb1xyXG4gICAgICAgICAgICAgICAgc2V0dGluZ3M9ezw+XHJcbiAgICAgICAgICAgICAgICAgICAgPFRleHRGaWVsZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZT17dmFsdWV9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsPVwiVmFsdWVcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRsaW5lZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBvbkNoYW5nZT17KF8sIHZhbHVlKSA9PiBzZXRWYWx1ZSh2YWx1ZSl9XHJcbiAgICAgICAgICAgICAgICAgICAgLz5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgPEZpZWxkU2V0IGxlZ2VuZD1cIlNpemVcIj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPFNlZ21lbnRlZEJ1dHRvblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VnbWVudHM9e1tcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7IHZhbHVlOiAnc21hbGwnLCBsYWJlbDogJ1NtYWxsJyB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgdmFsdWU6ICdtZWRpdW0nLCBsYWJlbDogJ01lZGl1bScgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7IHZhbHVlOiAnbGFyZ2UnLCBsYWJlbDogJ0xhcmdlJyB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBdfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU9e3NpemV9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbkNoYW5nZT17c2V0U2l6ZX1cclxuICAgICAgICAgICAgICAgICAgICAgICAgLz5cclxuICAgICAgICAgICAgICAgICAgICA8L0ZpZWxkU2V0PlxyXG5cclxuICAgICAgICAgICAgICAgICAgICA8Rm9ybUZpZWxkIGxhYmVsPVwiSW5kZXRlcm1pbmF0ZVwiIGFsaWduRW5kIHNwYWNlQmV0d2Vlbj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPFN3aXRjaFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0ZWQ9e2luZGV0ZXJtaW5hdGV9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbkNoYW5nZT17KCkgPT4gc2V0SW5kZXRlcm1pbmF0ZSh2ID0+ICF2KX1cclxuICAgICAgICAgICAgICAgICAgICAgICAgLz5cclxuICAgICAgICAgICAgICAgICAgICA8L0Zvcm1GaWVsZD5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgPEZvcm1GaWVsZCBsYWJlbD1cIkNvbG9yZnVsXCIgYWxpZ25FbmQgc3BhY2VCZXR3ZWVuPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8U3dpdGNoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3RlZD17Y29sb3JmdWx9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbkNoYW5nZT17KCkgPT4gc2V0Q29sb3JmdWwodiA9PiAhdil9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8+XHJcbiAgICAgICAgICAgICAgICAgICAgPC9Gb3JtRmllbGQ+XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIDxGb3JtRmllbGQgbGFiZWw9XCJDbG9zZWRcIiBhbGlnbkVuZCBzcGFjZUJldHdlZW4+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxTd2l0Y2hcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdGVkPXtjbG9zZWR9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbkNoYW5nZT17KCkgPT4gc2V0Q2xvc2VkKHYgPT4gIXYpfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvPlxyXG4gICAgICAgICAgICAgICAgICAgIDwvRm9ybUZpZWxkPlxyXG4gICAgICAgICAgICAgICAgPC8+fVxyXG4gICAgICAgICAgICA+XHJcbiAgICAgICAgICAgICAgICA8Q2lyY3VsYXJQcm9ncmVzc1xyXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlPXtpbmRldGVybWluYXRlID8gdW5kZWZpbmVkIDogdmFsdWV9XHJcbiAgICAgICAgICAgICAgICAgICAgc2l6ZT17c2l6ZX1cclxuICAgICAgICAgICAgICAgICAgICBpbmRldGVybWluYXRlPXtpbmRldGVybWluYXRlIHx8IHVuZGVmaW5lZH1cclxuICAgICAgICAgICAgICAgICAgICBjb2xvcmZ1bD17Y29sb3JmdWwgfHwgdW5kZWZpbmVkfVxyXG4gICAgICAgICAgICAgICAgICAgIGNsb3NlZD17Y2xvc2VkIHx8IHVuZGVmaW5lZH1cclxuICAgICAgICAgICAgICAgIC8+XHJcbiAgICAgICAgICAgIDwvRGVtbz5cclxuICAgICAgICA8L1BhZ2U+XHJcbiAgICApO1xyXG59IiwiaW1wb3J0IHsgdXNlQ2FsbGJhY2ssIHVzZVN0YXRlIH0gZnJvbSAncmVhY3QnO1xyXG5pbXBvcnQgeyBEYXRhVGFibGUgfSBmcm9tICdtZGMtcmVhY3QnO1xyXG5cclxuaW1wb3J0IERlbW8gZnJvbSAnQC9jb21wb25lbnRzL0RlbW8nO1xyXG5pbXBvcnQgUGFnZSBmcm9tICdAL2NvbXBvbmVudHMvUGFnZSc7XHJcblxyXG5jb25zdCBpZCA9ICdkYXRhLXRhYmxlJztcclxuY29uc3QgdGl0bGUgPSAnRGF0YSBUYWJsZSc7XHJcbmNvbnN0IGRlc2NyaXB0aW9uID0gJ0RhdGEgdGFibGVzIGRpc3BsYXkgc2V0cyBvZiBkYXRhIGFjcm9zcyByb3dzIGFuZCBjb2x1bW5zLic7XHJcbmNvbnN0IGxpbmtzID0ge1xyXG4gICAgZG9jczogJ2h0dHBzOi8vZ2l0aHViLmNvbS9tYXRlcmlhbC1jb21wb25lbnRzL21hdGVyaWFsLWNvbXBvbmVudHMtd2ViL3RyZWUvbWFzdGVyL3BhY2thZ2VzL21kYy1kYXRhLXRhYmxlJyxcclxuICAgIGd1aWRlOiAnaHR0cHM6Ly9tYXRlcmlhbC5pby9jb21wb25lbnRzL2RhdGEtdGFibGVzJ1xyXG59O1xyXG5cclxuY29uc3QgdGFibGUgPSBbXHJcbiAgICBbJ0Zyb3plbiB5b2d1cnQnLCAyNCwgNC4wLCAnU3VwZXIgdGFzdHknXSxcclxuICAgIFsnSWNlIGNyZWFtIHNhbmR3aWNoJywgMzcsIDQuMzMzMzMzMzMzMzMsICdJIGxpa2UgaWNlIGNyZWFtIG1vcmUnXSxcclxuICAgIFsnRWNsYWlyJywgMjQsIDYuMCwgJ05ldyBmaWxpbmcgZmxhdm9yJ11cclxuXTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIERhdGFUYWJsZVBhZ2UoKSB7XHJcbiAgICBjb25zdCBbZGF0YSwgc2V0RGF0YV0gPSB1c2VTdGF0ZSh0YWJsZSk7XHJcbiAgICBjb25zdCBbc29ydCwgc2V0U29ydF0gPSB1c2VTdGF0ZSgwKTtcclxuXHJcbiAgICBjb25zdCBoYW5kbGVTb3J0ID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xyXG4gICAgICAgIHNldFNvcnQoc29ydCA9PiB7XHJcbiAgICAgICAgICAgIGlmIChzb3J0ID09PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgc2V0RGF0YShkYXRhID0+IGRhdGEuc2xpY2UoKS5zb3J0KChhLCBiKSA9PiBhWzFdIC0gYlsxXSkpO1xyXG4gICAgICAgICAgICAgICAgc2V0U29ydCgxKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHNldERhdGEoZGF0YSA9PiBkYXRhLnNsaWNlKCkuc29ydCgoYSwgYikgPT4gYlsxXSAtIGFbMV0pKTtcclxuICAgICAgICAgICAgICAgIHNldFNvcnQoLTEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9LCBbXSk7XHJcblxyXG4gICAgcmV0dXJuIChcclxuICAgICAgICA8UGFnZSBpZD17aWR9IHRpdGxlPXt0aXRsZX0gZGVzY3JpcHRpb249e2Rlc2NyaXB0aW9ufSBsaW5rcz17bGlua3N9PlxyXG4gICAgICAgICAgICA8RGVtbyB0aXRsZT1cIlNvcnRhYmxlIGRhdGEgdGFibGVcIj5cclxuICAgICAgICAgICAgICAgIDxEYXRhVGFibGU+XHJcbiAgICAgICAgICAgICAgICAgICAgPERhdGFUYWJsZS5IZWFkZXI+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxEYXRhVGFibGUuSGVhZGVyUm93PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPERhdGFUYWJsZS5IZWFkZXJDZWxsPkRlc3NlcnQ8L0RhdGFUYWJsZS5IZWFkZXJDZWxsPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPERhdGFUYWJsZS5IZWFkZXJDZWxsIG51bWVyaWMgc29ydD17c29ydH0gb25Tb3J0PXtoYW5kbGVTb3J0fT5DYXJicyAoZyk8L0RhdGFUYWJsZS5IZWFkZXJDZWxsPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPERhdGFUYWJsZS5IZWFkZXJDZWxsIG51bWVyaWM+UHJvdGVpbiAoZyk8L0RhdGFUYWJsZS5IZWFkZXJDZWxsPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPERhdGFUYWJsZS5IZWFkZXJDZWxsPkNvbW1lbnRzPC9EYXRhVGFibGUuSGVhZGVyQ2VsbD5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPC9EYXRhVGFibGUuSGVhZGVyUm93PlxyXG4gICAgICAgICAgICAgICAgICAgIDwvRGF0YVRhYmxlLkhlYWRlcj5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgPERhdGFUYWJsZS5Db250ZW50PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB7ZGF0YS5tYXAoKHJvdywgaW5kZXgpID0+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8RGF0YVRhYmxlLlJvdyBrZXk9e2luZGV4fT5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7cm93Lm1hcCgodmFsdWUsIGluZGV4KSA9PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8RGF0YVRhYmxlLkNlbGwga2V5PXtpbmRleH0gc2NvcGU9e2luZGV4ID09PSAwID8gJ3JvdycgOiB1bmRlZmluZWR9IG51bWVyaWM9e3R5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgfHwgdW5kZWZpbmVkfT5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHt2YWx1ZX1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9EYXRhVGFibGUuQ2VsbD5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9EYXRhVGFibGUuUm93PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICApfVxyXG4gICAgICAgICAgICAgICAgICAgIDwvRGF0YVRhYmxlLkNvbnRlbnQ+XHJcbiAgICAgICAgICAgICAgICA8L0RhdGFUYWJsZT5cclxuICAgICAgICAgICAgPC9EZW1vPlxyXG4gICAgICAgIDwvUGFnZT5cclxuICAgICk7XHJcbn0iLCJpbXBvcnQgeyB1c2VTdGF0ZSB9IGZyb20gJ3JlYWN0JztcclxuaW1wb3J0IHtcclxuICAgIEJ1dHRvbixcclxuICAgIERpYWxvZ1xyXG59IGZyb20gJ21kYy1yZWFjdCc7XHJcblxyXG5pbXBvcnQgRGVtbyBmcm9tICdAL2NvbXBvbmVudHMvRGVtbyc7XHJcbmltcG9ydCBQYWdlIGZyb20gJ0AvY29tcG9uZW50cy9QYWdlJztcclxuXHJcbmNvbnN0IGlkID0gJ2RpYWxvZyc7XHJcbmNvbnN0IHRpdGxlID0gJ0RpYWxvZyc7XHJcbmNvbnN0IGRlc2NyaXB0aW9uID0gJ0RpYWxvZ3MgaW5mb3JtIHVzZXJzIGFib3V0IGEgc3BlY2lmaWMgdGFzayBhbmQgbWF5IGNvbnRhaW4gY3JpdGljYWwgaW5mb3JtYXRpb24sIHJlcXVpcmUgZGVjaXNpb25zLCBvciBpbnZvbHZlIG11bHRpcGxlIHRhc2tzLic7XHJcbmNvbnN0IGxpbmtzID0ge1xyXG4gICAgZG9jczogJ2h0dHBzOi8vZ2l0aHViLmNvbS9tYXRlcmlhbC1jb21wb25lbnRzL21hdGVyaWFsLWNvbXBvbmVudHMtd2ViL3RyZWUvbWFzdGVyL3BhY2thZ2VzL21kYy1kaWFsb2cnLFxyXG4gICAgZ3VpZGU6ICdodHRwczovL21hdGVyaWFsLmlvL2NvbXBvbmVudHMvZGlhbG9ncydcclxufTtcclxuXHJcbmNvbnN0IHNjcm9sbGFibGVDb250ZW50ID0gYFxyXG4gICAgTG9yZW0gaXBzdW0gZG9sb3Igc2l0IGFtZXQgY29uc2VjdGV0dXIgYWRpcGlzaWNpbmcgZWxpdC4gU3VudCBlYXJ1bSBxdWlidXNkYW0gZG9sb3IgaGljIGFjY3VzYW11cywgZGVzZXJ1bnQgbGliZXJvPyBEZWxlbml0aSByYXRpb25lIGxpYmVybywgZXZlbmlldCBuZXF1ZSBhbGlxdWFtIHJlcGVsbGF0IGRpY3RhIG9iY2FlY2F0aSBhdHF1ZSwgc2VxdWkgdm9sdXB0YXRlbSBleHBsaWNhYm8gYmVhdGFlIVxyXG5cclxuICAgIExvcmVtIGlwc3VtIGRvbG9yIHNpdCBhbWV0IGNvbnNlY3RldHVyIGFkaXBpc2ljaW5nIGVsaXQuIFZlcml0YXRpcyBhbmltaSB2ZWwgY3VwaWRpdGF0ZSBldmVuaWV0PyBMYXVkYW50aXVtIHJlY3VzYW5kYWUgaWxsbyBtaW51cyBzYWVwZSBpdGFxdWUgZG9sb3JlcyBmdWdpYXQsIHBlcmZlcmVuZGlzIG5vc3RydW0hIEFzc3VtZW5kYSBmdWdpYXQgZnVnYSBkZXNlcnVudCBvbW5pcyBvZGl0IGRpY3RhIVxyXG5cclxuICAgIExvcmVtIGlwc3VtIGRvbG9yIHNpdCBhbWV0IGNvbnNlY3RldHVyIGFkaXBpc2ljaW5nIGVsaXQuIE1pbnVzIGFjY3VzYW50aXVtIGEgcXVpc3F1YW0gaW4gcmVwdWRpYW5kYWUgZXQgdWxsYW0gY3VtIGRpZ25pc3NpbW9zIGV4ZXJjaXRhdGlvbmVtLCBibGFuZGl0aWlzIHBlcnNwaWNpYXRpcyBhbGlhcyBoaWMgdmVsLCBsYXVkYW50aXVtIGFsaXF1YW0gb21uaXMgcmVjdXNhbmRhZSBuZW1vIGFuaW1pLlxyXG5cclxuICAgIExvcmVtIGlwc3VtIGRvbG9yIHNpdCBhbWV0IGNvbnNlY3RldHVyIGFkaXBpc2ljaW5nIGVsaXQuIFN1bnQgZWFydW0gcXVpYnVzZGFtIGRvbG9yIGhpYyBhY2N1c2FtdXMsIGRlc2VydW50IGxpYmVybz8gRGVsZW5pdGkgcmF0aW9uZSBsaWJlcm8sIGV2ZW5pZXQgbmVxdWUgYWxpcXVhbSByZXBlbGxhdCBkaWN0YSBvYmNhZWNhdGkgYXRxdWUsIHNlcXVpIHZvbHVwdGF0ZW0gZXhwbGljYWJvIGJlYXRhZSFcclxuXHJcbiAgICBMb3JlbSBpcHN1bSBkb2xvciBzaXQgYW1ldCBjb25zZWN0ZXR1ciBhZGlwaXNpY2luZyBlbGl0LiBWZXJpdGF0aXMgYW5pbWkgdmVsIGN1cGlkaXRhdGUgZXZlbmlldD8gTGF1ZGFudGl1bSByZWN1c2FuZGFlIGlsbG8gbWludXMgc2FlcGUgaXRhcXVlIGRvbG9yZXMgZnVnaWF0LCBwZXJmZXJlbmRpcyBub3N0cnVtISBBc3N1bWVuZGEgZnVnaWF0IGZ1Z2EgZGVzZXJ1bnQgb21uaXMgb2RpdCBkaWN0YSFcclxuXHJcbiAgICBMb3JlbSBpcHN1bSBkb2xvciBzaXQgYW1ldCBjb25zZWN0ZXR1ciBhZGlwaXNpY2luZyBlbGl0LiBNaW51cyBhY2N1c2FudGl1bSBhIHF1aXNxdWFtIGluIHJlcHVkaWFuZGFlIGV0IHVsbGFtIGN1bSBkaWduaXNzaW1vcyBleGVyY2l0YXRpb25lbSwgYmxhbmRpdGlpcyBwZXJzcGljaWF0aXMgYWxpYXMgaGljIHZlbCwgbGF1ZGFudGl1bSBhbGlxdWFtIG9tbmlzIHJlY3VzYW5kYWUgbmVtbyBhbmltaS5cclxuXHJcbiAgICBMb3JlbSBpcHN1bSBkb2xvciBzaXQgYW1ldCBjb25zZWN0ZXR1ciBhZGlwaXNpY2luZyBlbGl0LiBTdW50IGVhcnVtIHF1aWJ1c2RhbSBkb2xvciBoaWMgYWNjdXNhbXVzLCBkZXNlcnVudCBsaWJlcm8/IERlbGVuaXRpIHJhdGlvbmUgbGliZXJvLCBldmVuaWV0IG5lcXVlIGFsaXF1YW0gcmVwZWxsYXQgZGljdGEgb2JjYWVjYXRpIGF0cXVlLCBzZXF1aSB2b2x1cHRhdGVtIGV4cGxpY2FibyBiZWF0YWUhXHJcblxyXG4gICAgTG9yZW0gaXBzdW0gZG9sb3Igc2l0IGFtZXQgY29uc2VjdGV0dXIgYWRpcGlzaWNpbmcgZWxpdC4gVmVyaXRhdGlzIGFuaW1pIHZlbCBjdXBpZGl0YXRlIGV2ZW5pZXQ/IExhdWRhbnRpdW0gcmVjdXNhbmRhZSBpbGxvIG1pbnVzIHNhZXBlIGl0YXF1ZSBkb2xvcmVzIGZ1Z2lhdCwgcGVyZmVyZW5kaXMgbm9zdHJ1bSEgQXNzdW1lbmRhIGZ1Z2lhdCBmdWdhIGRlc2VydW50IG9tbmlzIG9kaXQgZGljdGEhXHJcblxyXG4gICAgTG9yZW0gaXBzdW0gZG9sb3Igc2l0IGFtZXQgY29uc2VjdGV0dXIgYWRpcGlzaWNpbmcgZWxpdC4gTWludXMgYWNjdXNhbnRpdW0gYSBxdWlzcXVhbSBpbiByZXB1ZGlhbmRhZSBldCB1bGxhbSBjdW0gZGlnbmlzc2ltb3MgZXhlcmNpdGF0aW9uZW0sIGJsYW5kaXRpaXMgcGVyc3BpY2lhdGlzIGFsaWFzIGhpYyB2ZWwsIGxhdWRhbnRpdW0gYWxpcXVhbSBvbW5pcyByZWN1c2FuZGFlIG5lbW8gYW5pbWkuXHJcblxyXG4gICAgTG9yZW0gaXBzdW0gZG9sb3Igc2l0IGFtZXQgY29uc2VjdGV0dXIgYWRpcGlzaWNpbmcgZWxpdC4gU3VudCBlYXJ1bSBxdWlidXNkYW0gZG9sb3IgaGljIGFjY3VzYW11cywgZGVzZXJ1bnQgbGliZXJvPyBEZWxlbml0aSByYXRpb25lIGxpYmVybywgZXZlbmlldCBuZXF1ZSBhbGlxdWFtIHJlcGVsbGF0IGRpY3RhIG9iY2FlY2F0aSBhdHF1ZSwgc2VxdWkgdm9sdXB0YXRlbSBleHBsaWNhYm8gYmVhdGFlIVxyXG5cclxuICAgIExvcmVtIGlwc3VtIGRvbG9yIHNpdCBhbWV0IGNvbnNlY3RldHVyIGFkaXBpc2ljaW5nIGVsaXQuIFZlcml0YXRpcyBhbmltaSB2ZWwgY3VwaWRpdGF0ZSBldmVuaWV0PyBMYXVkYW50aXVtIHJlY3VzYW5kYWUgaWxsbyBtaW51cyBzYWVwZSBpdGFxdWUgZG9sb3JlcyBmdWdpYXQsIHBlcmZlcmVuZGlzIG5vc3RydW0hIEFzc3VtZW5kYSBmdWdpYXQgZnVnYSBkZXNlcnVudCBvbW5pcyBvZGl0IGRpY3RhIVxyXG5cclxuICAgIExvcmVtIGlwc3VtIGRvbG9yIHNpdCBhbWV0IGNvbnNlY3RldHVyIGFkaXBpc2ljaW5nIGVsaXQuIE1pbnVzIGFjY3VzYW50aXVtIGEgcXVpc3F1YW0gaW4gcmVwdWRpYW5kYWUgZXQgdWxsYW0gY3VtIGRpZ25pc3NpbW9zIGV4ZXJjaXRhdGlvbmVtLCBibGFuZGl0aWlzIHBlcnNwaWNpYXRpcyBhbGlhcyBoaWMgdmVsLCBsYXVkYW50aXVtIGFsaXF1YW0gb21uaXMgcmVjdXNhbmRhZSBuZW1vIGFuaW1pLlxyXG5cclxuICAgIExvcmVtIGlwc3VtIGRvbG9yIHNpdCBhbWV0IGNvbnNlY3RldHVyIGFkaXBpc2ljaW5nIGVsaXQuIFN1bnQgZWFydW0gcXVpYnVzZGFtIGRvbG9yIGhpYyBhY2N1c2FtdXMsIGRlc2VydW50IGxpYmVybz8gRGVsZW5pdGkgcmF0aW9uZSBsaWJlcm8sIGV2ZW5pZXQgbmVxdWUgYWxpcXVhbSByZXBlbGxhdCBkaWN0YSBvYmNhZWNhdGkgYXRxdWUsIHNlcXVpIHZvbHVwdGF0ZW0gZXhwbGljYWJvIGJlYXRhZSFcclxuXHJcbiAgICBMb3JlbSBpcHN1bSBkb2xvciBzaXQgYW1ldCBjb25zZWN0ZXR1ciBhZGlwaXNpY2luZyBlbGl0LiBWZXJpdGF0aXMgYW5pbWkgdmVsIGN1cGlkaXRhdGUgZXZlbmlldD8gTGF1ZGFudGl1bSByZWN1c2FuZGFlIGlsbG8gbWludXMgc2FlcGUgaXRhcXVlIGRvbG9yZXMgZnVnaWF0LCBwZXJmZXJlbmRpcyBub3N0cnVtISBBc3N1bWVuZGEgZnVnaWF0IGZ1Z2EgZGVzZXJ1bnQgb21uaXMgb2RpdCBkaWN0YSFcclxuXHJcbiAgICBMb3JlbSBpcHN1bSBkb2xvciBzaXQgYW1ldCBjb25zZWN0ZXR1ciBhZGlwaXNpY2luZyBlbGl0LiBNaW51cyBhY2N1c2FudGl1bSBhIHF1aXNxdWFtIGluIHJlcHVkaWFuZGFlIGV0IHVsbGFtIGN1bSBkaWduaXNzaW1vcyBleGVyY2l0YXRpb25lbSwgYmxhbmRpdGlpcyBwZXJzcGljaWF0aXMgYWxpYXMgaGljIHZlbCwgbGF1ZGFudGl1bSBhbGlxdWFtIG9tbmlzIHJlY3VzYW5kYWUgbmVtbyBhbmltaS5cclxuXHJcbiAgICBMb3JlbSBpcHN1bSBkb2xvciBzaXQgYW1ldCBjb25zZWN0ZXR1ciBhZGlwaXNpY2luZyBlbGl0LiBTdW50IGVhcnVtIHF1aWJ1c2RhbSBkb2xvciBoaWMgYWNjdXNhbXVzLCBkZXNlcnVudCBsaWJlcm8/IERlbGVuaXRpIHJhdGlvbmUgbGliZXJvLCBldmVuaWV0IG5lcXVlIGFsaXF1YW0gcmVwZWxsYXQgZGljdGEgb2JjYWVjYXRpIGF0cXVlLCBzZXF1aSB2b2x1cHRhdGVtIGV4cGxpY2FibyBiZWF0YWUhXHJcblxyXG4gICAgTG9yZW0gaXBzdW0gZG9sb3Igc2l0IGFtZXQgY29uc2VjdGV0dXIgYWRpcGlzaWNpbmcgZWxpdC4gVmVyaXRhdGlzIGFuaW1pIHZlbCBjdXBpZGl0YXRlIGV2ZW5pZXQ/IExhdWRhbnRpdW0gcmVjdXNhbmRhZSBpbGxvIG1pbnVzIHNhZXBlIGl0YXF1ZSBkb2xvcmVzIGZ1Z2lhdCwgcGVyZmVyZW5kaXMgbm9zdHJ1bSEgQXNzdW1lbmRhIGZ1Z2lhdCBmdWdhIGRlc2VydW50IG9tbmlzIG9kaXQgZGljdGEhXHJcblxyXG4gICAgTG9yZW0gaXBzdW0gZG9sb3Igc2l0IGFtZXQgY29uc2VjdGV0dXIgYWRpcGlzaWNpbmcgZWxpdC4gTWludXMgYWNjdXNhbnRpdW0gYSBxdWlzcXVhbSBpbiByZXB1ZGlhbmRhZSBldCB1bGxhbSBjdW0gZGlnbmlzc2ltb3MgZXhlcmNpdGF0aW9uZW0sIGJsYW5kaXRpaXMgcGVyc3BpY2lhdGlzIGFsaWFzIGhpYyB2ZWwsIGxhdWRhbnRpdW0gYWxpcXVhbSBvbW5pcyByZWN1c2FuZGFlIG5lbW8gYW5pbWkuXHJcbmA7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBEaWFsb2dQYWdlKCkge1xyXG4gICAgY29uc3QgW2lzQmFzaWNPcGVuLCBzZXRCYXNpY09wZW5dID0gdXNlU3RhdGUoZmFsc2UpO1xyXG4gICAgY29uc3QgW2lzQ29uZmlybWF0aW9uT3Blbiwgc2V0Q29uZmlybWF0aW9uT3Blbl0gPSB1c2VTdGF0ZShmYWxzZSk7XHJcbiAgICBjb25zdCBbaXNTdGFja2luZ09wZW4sIHNldFN0YWNraW5nT3Blbl0gPSB1c2VTdGF0ZShmYWxzZSk7XHJcbiAgICBjb25zdCBbaXNTY3JvbGxhYmxlT3Blbiwgc2V0U2Nyb2xsYWJsZU9wZW5dID0gdXNlU3RhdGUoZmFsc2UpO1xyXG4gICAgY29uc3QgW2lzRnVsbHNjcmVlbk9wZW4sIHNldEZ1bGxzY3JlZW5PcGVuXSA9IHVzZVN0YXRlKGZhbHNlKTtcclxuICAgIGNvbnN0IFtpc0Zsb2F0aW5nU2hlZXRPcGVuLCBzZXRGbG9hdGluZ1NoZWV0T3Blbl0gPSB1c2VTdGF0ZShmYWxzZSk7XHJcblxyXG4gICAgcmV0dXJuIChcclxuICAgICAgICA8UGFnZSBpZD17aWR9IHRpdGxlPXt0aXRsZX0gZGVzY3JpcHRpb249e2Rlc2NyaXB0aW9ufSBsaW5rcz17bGlua3N9PlxyXG4gICAgICAgICAgICA8RGVtb1xyXG4gICAgICAgICAgICAgICAgdGl0bGU9XCJCYXNpYyBkaWFsb2dcIlxyXG4gICAgICAgICAgICAgICAgc2V0dXA9e1xyXG4gICAgICAgICAgICAgICAgICAgIDxCdXR0b24gb25DbGljaz17KCkgPT4gc2V0QmFzaWNPcGVuKHYgPT4gIXYpfT5PcGVuPC9CdXR0b24+XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgID5cclxuICAgICAgICAgICAgICAgIDxEaWFsb2dcclxuICAgICAgICAgICAgICAgICAgICB0aXRsZT1cIlRpdGxlXCJcclxuICAgICAgICAgICAgICAgICAgICBjb250ZW50PVwiQ29udGVudFwiXHJcbiAgICAgICAgICAgICAgICAgICAgb3Blbj17aXNCYXNpY09wZW59XHJcbiAgICAgICAgICAgICAgICAgICAgb25DbG9zZT17KCkgPT4gc2V0QmFzaWNPcGVuKHYgPT4gIXYpfVxyXG4gICAgICAgICAgICAgICAgLz5cclxuICAgICAgICAgICAgPC9EZW1vPlxyXG5cclxuICAgICAgICAgICAgPERlbW9cclxuICAgICAgICAgICAgICAgIHRpdGxlPVwiQ29uZmlybWF0aW9uIGRpYWxvZ1wiXHJcbiAgICAgICAgICAgICAgICBzZXR1cD17XHJcbiAgICAgICAgICAgICAgICAgICAgPEJ1dHRvbiBvbkNsaWNrPXsoKSA9PiBzZXRDb25maXJtYXRpb25PcGVuKHYgPT4gIXYpfT5PcGVuPC9CdXR0b24+XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgID5cclxuICAgICAgICAgICAgICAgIDxEaWFsb2dcclxuICAgICAgICAgICAgICAgICAgICB0aXRsZT1cIlRpdGxlXCJcclxuICAgICAgICAgICAgICAgICAgICBjb250ZW50PVwiQXJlIHlvdSBzdXJlP1wiXHJcbiAgICAgICAgICAgICAgICAgICAgb3Blbj17aXNDb25maXJtYXRpb25PcGVufVxyXG4gICAgICAgICAgICAgICAgICAgIHBlcnNpc3RlbnRcclxuICAgICAgICAgICAgICAgICAgICBhY3Rpb25zPXtbXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxCdXR0b24ga2V5PVwiY2xvc2VcIiBvbkNsaWNrPXsoKSA9PiBzZXRDb25maXJtYXRpb25PcGVuKHYgPT4gIXYpfT5DbG9zZTwvQnV0dG9uPixcclxuICAgICAgICAgICAgICAgICAgICAgICAgPEJ1dHRvbiBrZXk9XCJjb25maXJtXCI+Q29uZmlybTwvQnV0dG9uPlxyXG4gICAgICAgICAgICAgICAgICAgIF19XHJcbiAgICAgICAgICAgICAgICAgICAgb25DbG9zZT17KCkgPT4gc2V0Q29uZmlybWF0aW9uT3Blbih2ID0+ICF2KX1cclxuICAgICAgICAgICAgICAgIC8+XHJcbiAgICAgICAgICAgIDwvRGVtbz5cclxuXHJcbiAgICAgICAgICAgIDxEZW1vXHJcbiAgICAgICAgICAgICAgICB0aXRsZT1cIkRpYWxvZyB3aXRoIHN0YWNraW5nIGJ1dHRvbnNcIlxyXG4gICAgICAgICAgICAgICAgc2V0dXA9e1xyXG4gICAgICAgICAgICAgICAgICAgIDxCdXR0b24gb25DbGljaz17KCkgPT4gc2V0U3RhY2tpbmdPcGVuKHYgPT4gIXYpfT5PcGVuPC9CdXR0b24+XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgID5cclxuICAgICAgICAgICAgICAgIDxEaWFsb2dcclxuICAgICAgICAgICAgICAgICAgICB0aXRsZT1cIlRpdGxlXCJcclxuICAgICAgICAgICAgICAgICAgICBjb250ZW50PVwiQ29udGVudFwiXHJcbiAgICAgICAgICAgICAgICAgICAgb3Blbj17aXNTdGFja2luZ09wZW59XHJcbiAgICAgICAgICAgICAgICAgICAgYXV0b1N0YWNrQnV0dG9uc1xyXG4gICAgICAgICAgICAgICAgICAgIGFjdGlvbnM9e1tcclxuICAgICAgICAgICAgICAgICAgICAgICAgPEJ1dHRvbiBrZXk9XCJjbG9zZVwiIG9uQ2xpY2s9eygpID0+IHNldFN0YWNraW5nT3Blbih2ID0+ICF2KX0+QSB2ZXJ5IHZlcnkgdmVyeSB2ZXJ5IHZlcnkgbG9uZyBidXR0b248L0J1dHRvbj4sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxCdXR0b24ga2V5PVwiY29uZmlybVwiPkEgdmVyeSB2ZXJ5IHZlcnkgdmVyeSB2ZXJ5IGxvbmcgYnV0dG9uPC9CdXR0b24+XHJcbiAgICAgICAgICAgICAgICAgICAgXX1cclxuICAgICAgICAgICAgICAgICAgICBvbkNsb3NlPXsoKSA9PiBzZXRTdGFja2luZ09wZW4odiA9PiAhdil9XHJcbiAgICAgICAgICAgICAgICAvPlxyXG4gICAgICAgICAgICA8L0RlbW8+XHJcblxyXG4gICAgICAgICAgICA8RGVtb1xyXG4gICAgICAgICAgICAgICAgdGl0bGU9XCJTY3JvbGxhYmxlIGRpYWxvZ1wiXHJcbiAgICAgICAgICAgICAgICBzZXR1cD17XHJcbiAgICAgICAgICAgICAgICAgICAgPEJ1dHRvbiBvbkNsaWNrPXsoKSA9PiBzZXRTY3JvbGxhYmxlT3Blbih2ID0+ICF2KX0+T3BlbjwvQnV0dG9uPlxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICA+XHJcbiAgICAgICAgICAgICAgICA8RGlhbG9nXHJcbiAgICAgICAgICAgICAgICAgICAgdGl0bGU9XCJUaXRsZVwiXHJcbiAgICAgICAgICAgICAgICAgICAgb3Blbj17aXNTY3JvbGxhYmxlT3Blbn1cclxuICAgICAgICAgICAgICAgICAgICBhY3Rpb25zPXtbXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxCdXR0b24ga2V5PVwiY2xvc2VcIiBvbkNsaWNrPXsoKSA9PiBzZXRTY3JvbGxhYmxlT3Blbih2ID0+ICF2KX0+Q2xvc2U8L0J1dHRvbj5cclxuICAgICAgICAgICAgICAgICAgICBdfVxyXG4gICAgICAgICAgICAgICAgICAgIG9uQ2xvc2U9eygpID0+IHNldFNjcm9sbGFibGVPcGVuKHYgPT4gIXYpfVxyXG4gICAgICAgICAgICAgICAgPlxyXG4gICAgICAgICAgICAgICAgICAgIHtzY3JvbGxhYmxlQ29udGVudH1cclxuICAgICAgICAgICAgICAgIDwvRGlhbG9nPlxyXG4gICAgICAgICAgICA8L0RlbW8+XHJcblxyXG4gICAgICAgICAgICA8RGVtb1xyXG4gICAgICAgICAgICAgICAgdGl0bGU9XCJGdWxsc2NyZWVuIGRpYWxvZ1wiXHJcbiAgICAgICAgICAgICAgICBzZXR1cD17XHJcbiAgICAgICAgICAgICAgICAgICAgPEJ1dHRvbiBvbkNsaWNrPXsoKSA9PiBzZXRGdWxsc2NyZWVuT3Blbih2ID0+ICF2KX0+T3BlbjwvQnV0dG9uPlxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICA+XHJcbiAgICAgICAgICAgICAgICA8RGlhbG9nXHJcbiAgICAgICAgICAgICAgICAgICAgdGl0bGU9XCJGdWxsc2NyZWVuIERpYWxvZ1wiXHJcbiAgICAgICAgICAgICAgICAgICAgb3Blbj17aXNGdWxsc2NyZWVuT3Blbn1cclxuICAgICAgICAgICAgICAgICAgICBmdWxsc2NyZWVuXHJcbiAgICAgICAgICAgICAgICAgICAgYWN0aW9ucz17PEJ1dHRvbiBrZXk9XCJjbG9zZVwiIG9uQ2xpY2s9eygpID0+IHNldEZ1bGxzY3JlZW5PcGVuKHYgPT4gIXYpfT5DbG9zZTwvQnV0dG9uPn1cclxuICAgICAgICAgICAgICAgICAgICBvbkNsb3NlPXsoKSA9PiBzZXRGdWxsc2NyZWVuT3Blbih2ID0+ICF2KX1cclxuICAgICAgICAgICAgICAgID5cclxuICAgICAgICAgICAgICAgICAgICB7c2Nyb2xsYWJsZUNvbnRlbnR9XHJcbiAgICAgICAgICAgICAgICA8L0RpYWxvZz5cclxuICAgICAgICAgICAgPC9EZW1vPlxyXG5cclxuICAgICAgICAgICAgPERlbW9cclxuICAgICAgICAgICAgICAgIHRpdGxlPVwiRmxvYXRpbmcgc2hlZXRcIlxyXG4gICAgICAgICAgICAgICAgc2V0dXA9e1xyXG4gICAgICAgICAgICAgICAgICAgIDxCdXR0b24gb25DbGljaz17KCkgPT4gc2V0RmxvYXRpbmdTaGVldE9wZW4odHJ1ZSl9Pk9wZW48L0J1dHRvbj5cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgPlxyXG4gICAgICAgICAgICAgICAgPERpYWxvZ1xyXG4gICAgICAgICAgICAgICAgICAgIG9wZW49e2lzRmxvYXRpbmdTaGVldE9wZW59XHJcbiAgICAgICAgICAgICAgICAgICAgc2hlZXRcclxuICAgICAgICAgICAgICAgICAgICBvbkNsb3NlPXsoKSA9PiBzZXRGbG9hdGluZ1NoZWV0T3BlbihmYWxzZSl9XHJcbiAgICAgICAgICAgICAgICA+XHJcbiAgICAgICAgICAgICAgICAgICAgPGgzPlNoZWV0czwvaDM+XHJcbiAgICAgICAgICAgICAgICAgICAgVGhlcmUgYXJlIG5vIGFjdGlvbiBidXR0b25zLiBBbnkgSFRNTCBjb250ZW50IGNhbiBnbyBoZXJlLiBUaXRsZSBpcyBhbHNvIGRlZmluZWQgdGhyb3VnaCBjb250ZW50LlxyXG4gICAgICAgICAgICAgICAgPC9EaWFsb2c+XHJcbiAgICAgICAgICAgIDwvRGVtbz5cclxuICAgICAgICA8L1BhZ2U+XHJcbiAgICApO1xyXG59IiwiaW1wb3J0IHsgdXNlU3RhdGUgfSBmcm9tICdyZWFjdCc7XHJcbmltcG9ydCB7IEJ1dHRvbiwgRHJhd2VyIH0gZnJvbSAnbWRjLXJlYWN0JztcclxuXHJcbmltcG9ydCBEZW1vIGZyb20gJ0AvY29tcG9uZW50cy9EZW1vJztcclxuaW1wb3J0IFBhZ2UgZnJvbSAnQC9jb21wb25lbnRzL1BhZ2UnO1xyXG5cclxuY29uc3QgaWQgPSAnZHJhd2VyJztcclxuY29uc3QgdGl0bGUgPSAnRHJhd2VyJztcclxuY29uc3QgZGVzY3JpcHRpb24gPSAnTmF2aWdhdGlvbiBkcmF3ZXJzIHByb3ZpZGUgYWNjZXNzIHRvIGRlc3RpbmF0aW9ucyBpbiB5b3VyIGFwcC4nO1xyXG5jb25zdCBsaW5rcyA9IHtcclxuICAgIGRvY3M6ICdodHRwczovL2dpdGh1Yi5jb20vbWF0ZXJpYWwtY29tcG9uZW50cy9tYXRlcmlhbC1jb21wb25lbnRzLXdlYi90cmVlL21hc3Rlci9wYWNrYWdlcy9tZGMtZHJhd2VyJyxcclxuICAgIGd1aWRlOiAnaHR0cHM6Ly9tYXRlcmlhbC5pby9jb21wb25lbnRzL25hdmlnYXRpb24tZHJhd2VyJ1xyXG59O1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gRHJhd2VyUGFnZSgpIHtcclxuICAgIGNvbnN0IFtpc0Rpc21pc3NpYmxlT3Blbiwgc2V0RGlzbWlzc2libGVPcGVuXSA9IHVzZVN0YXRlKGZhbHNlKTtcclxuICAgIGNvbnN0IFtpc01vZGFsT3Blbiwgc2V0TW9kYWxPcGVuXSA9IHVzZVN0YXRlKGZhbHNlKTtcclxuXHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAgIDxQYWdlIGlkPXtpZH0gdGl0bGU9e3RpdGxlfSBkZXNjcmlwdGlvbj17ZGVzY3JpcHRpb259IGxpbmtzPXtsaW5rc30+XHJcbiAgICAgICAgICAgIDxEZW1vIHRpdGxlPVwiUGVybWFuZW50IGRyYXdlclwiPlxyXG4gICAgICAgICAgICAgICAgPERyYXdlcj5cclxuICAgICAgICAgICAgICAgICAgICA8RHJhd2VyLkhlYWRlciB0aXRsZT1cIlRpdGxlXCIgLz5cclxuICAgICAgICAgICAgICAgIDwvRHJhd2VyPlxyXG4gICAgICAgICAgICA8L0RlbW8+XHJcblxyXG4gICAgICAgICAgICA8RGVtb1xyXG4gICAgICAgICAgICAgICAgdGl0bGU9XCJEaXNtaXNzaWJsZSBkcmF3ZXJcIlxyXG4gICAgICAgICAgICAgICAgc2V0dXA9e1xyXG4gICAgICAgICAgICAgICAgICAgIDxCdXR0b25cclxuICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWw9XCJUb2dnbGVcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBvbkNsaWNrPXsoKSA9PiBzZXREaXNtaXNzaWJsZU9wZW4odiA9PiAhdil9XHJcbiAgICAgICAgICAgICAgICAgICAgLz5cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgPlxyXG4gICAgICAgICAgICAgICAgPERyYXdlclxyXG4gICAgICAgICAgICAgICAgICAgIG9wZW49e2lzRGlzbWlzc2libGVPcGVufVxyXG4gICAgICAgICAgICAgICAgICAgIGRpc21pc3NpYmxlXHJcbiAgICAgICAgICAgICAgICA+XHJcbiAgICAgICAgICAgICAgICAgICAgPERyYXdlci5IZWFkZXIgdGl0bGU9XCJUaXRsZVwiIC8+XHJcbiAgICAgICAgICAgICAgICA8L0RyYXdlcj5cclxuICAgICAgICAgICAgPC9EZW1vPlxyXG5cclxuICAgICAgICAgICAgPERlbW9cclxuICAgICAgICAgICAgICAgIHRpdGxlPVwiTW9kYWwgZHJhd2VyXCJcclxuICAgICAgICAgICAgICAgIHNldHVwPXtcclxuICAgICAgICAgICAgICAgICAgICA8QnV0dG9uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsPVwiVG9nZ2xlXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgb25DbGljaz17KCkgPT4gc2V0TW9kYWxPcGVuKHYgPT4gIXYpfVxyXG4gICAgICAgICAgICAgICAgICAgIC8+XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgID5cclxuICAgICAgICAgICAgICAgIDxEcmF3ZXJcclxuICAgICAgICAgICAgICAgICAgICBvcGVuPXtpc01vZGFsT3Blbn1cclxuICAgICAgICAgICAgICAgICAgICBvbkNsb3NlPXsoKSA9PiBzZXRNb2RhbE9wZW4odiA9PiAhdil9XHJcbiAgICAgICAgICAgICAgICAgICAgbW9kYWxcclxuICAgICAgICAgICAgICAgID5cclxuICAgICAgICAgICAgICAgICAgICA8RHJhd2VyLkhlYWRlciB0aXRsZT1cIlRpdGxlXCIgLz5cclxuICAgICAgICAgICAgICAgIDwvRHJhd2VyPlxyXG4gICAgICAgICAgICA8L0RlbW8+XHJcbiAgICAgICAgPC9QYWdlPlxyXG4gICAgKTtcclxufSIsImltcG9ydCB7IHVzZUNhbGxiYWNrLCB1c2VTdGF0ZSB9IGZyb20gJ3JlYWN0JztcclxuaW1wb3J0IHsgRWxldmF0aW9uLCBTbGlkZXIgfSBmcm9tICdtZGMtcmVhY3QnO1xyXG5cclxuaW1wb3J0IERlbW8gZnJvbSAnQC9jb21wb25lbnRzL0RlbW8nO1xyXG5pbXBvcnQgUGFnZSBmcm9tICdAL2NvbXBvbmVudHMvUGFnZSc7XHJcblxyXG5pbXBvcnQgJy4vaW5kZXguc2Nzcyc7XHJcblxyXG5jb25zdCBpZCA9ICdlbGV2YXRpb24nO1xyXG5jb25zdCB0aXRsZSA9ICdFbGV2YXRpb24nO1xyXG5jb25zdCBkZXNjcmlwdGlvbiA9ICdFbGV2YXRpb24gaXMgdGhlIHJlbGF0aXZlIGRpc3RhbmNlIGJldHdlZW4gdHdvIHN1cmZhY2VzIGFsb25nIHRoZSB6LWF4aXMuJztcclxuY29uc3QgbGlua3MgPSB7XHJcbiAgICBkb2NzOiAnaHR0cHM6Ly9naXRodWIuY29tL21hdGVyaWFsLWNvbXBvbmVudHMvbWF0ZXJpYWwtY29tcG9uZW50cy13ZWIvdHJlZS9tYXN0ZXIvcGFja2FnZXMvbWRjLWVsZXZhdGlvbicsXHJcbiAgICBndWlkZTogJ2h0dHBzOi8vbWF0ZXJpYWwuaW8vZGVzaWduL2Vudmlyb25tZW50L2VsZXZhdGlvbidcclxufTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIEVsZXZhdGlvblBhZ2UoKSB7XHJcbiAgICBjb25zdCBbeiwgc2V0Wl0gPSB1c2VTdGF0ZSgwKTtcclxuXHJcbiAgICBjb25zdCBoYW5kbGVDaGFuZ2UgPSB1c2VDYWxsYmFjayh2YWx1ZSA9PiB7XHJcbiAgICAgICAgc2V0Wih2YWx1ZSk7XHJcbiAgICB9LCBbXSk7XHJcblxyXG4gICAgcmV0dXJuIChcclxuICAgICAgICA8UGFnZSBpZD17aWR9IHRpdGxlPXt0aXRsZX0gZGVzY3JpcHRpb249e2Rlc2NyaXB0aW9ufSBsaW5rcz17bGlua3N9PlxyXG4gICAgICAgICAgICA8RGVtb1xyXG4gICAgICAgICAgICAgICAgc2V0dXA9e1xyXG4gICAgICAgICAgICAgICAgICAgIDxTbGlkZXJcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU9e3p9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1pbj1cIjBcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXg9XCIyNFwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0ZXA9XCIxXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGlzY3JldGVcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGlja01hcmtzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2hhbmdlPXtoYW5kbGVDaGFuZ2V9XHJcbiAgICAgICAgICAgICAgICAgICAgLz5cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgPlxyXG4gICAgICAgICAgICAgICAgPEVsZXZhdGlvbiB6PXt6fSAvPlxyXG4gICAgICAgICAgICA8L0RlbW8+XHJcbiAgICAgICAgPC9QYWdlPlxyXG4gICAgKTtcclxufSIsImltcG9ydCB7IHVzZVN0YXRlIH0gZnJvbSAncmVhY3QnO1xyXG5pbXBvcnQgeyBCdXR0b24sIEZBQiB9IGZyb20gJ21kYy1yZWFjdCc7XHJcblxyXG5pbXBvcnQgRGVtbyBmcm9tICdAL2NvbXBvbmVudHMvRGVtbyc7XHJcbmltcG9ydCBQYWdlIGZyb20gJ0AvY29tcG9uZW50cy9QYWdlJztcclxuXHJcbmNvbnN0IGlkID0gJ2ZhYic7XHJcbmNvbnN0IHRpdGxlID0gJ0ZBQic7XHJcbmNvbnN0IGRlc2NyaXB0aW9uID0gJ0EgZmxvYXRpbmcgYWN0aW9uIGJ1dHRvbiAoRkFCKSByZXByZXNlbnRzIHRoZSBwcmltYXJ5IGFjdGlvbiBvZiBhIHNjcmVlbi4nO1xyXG5jb25zdCBsaW5rcyA9IHtcclxuICAgIGRvY3M6ICdodHRwczovL2dpdGh1Yi5jb20vbWF0ZXJpYWwtY29tcG9uZW50cy9tYXRlcmlhbC1jb21wb25lbnRzLXdlYi90cmVlL21hc3Rlci9wYWNrYWdlcy9tZGMtZmFiJyxcclxuICAgIGd1aWRlOiAnaHR0cHM6Ly9tYXRlcmlhbC5pby9jb21wb25lbnRzL2J1dHRvbnMtZmxvYXRpbmctYWN0aW9uLWJ1dHRvbidcclxufTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIEZBQlBhZ2UoKSB7XHJcbiAgICBjb25zdCBbaXNFeGl0ZWQsIHNldEV4aXRlZF0gPSB1c2VTdGF0ZShmYWxzZSk7XHJcblxyXG4gICAgcmV0dXJuIChcclxuICAgICAgICA8UGFnZSBpZD17aWR9IHRpdGxlPXt0aXRsZX0gZGVzY3JpcHRpb249e2Rlc2NyaXB0aW9ufSBsaW5rcz17bGlua3N9PlxyXG4gICAgICAgICAgICA8RGVtbyB0aXRsZT1cIkJhc2ljIEZBQlwiPlxyXG4gICAgICAgICAgICAgICAgPEZBQlxyXG4gICAgICAgICAgICAgICAgICAgIGljb249XCJzdGFyXCJcclxuICAgICAgICAgICAgICAgIC8+XHJcbiAgICAgICAgICAgIDwvRGVtbz5cclxuXHJcbiAgICAgICAgICAgIDxEZW1vIHRpdGxlPVwiTWluaSBGQUJcIj5cclxuICAgICAgICAgICAgICAgIDxGQUJcclxuICAgICAgICAgICAgICAgICAgICBpY29uPVwic3RhclwiXHJcbiAgICAgICAgICAgICAgICAgICAgbWluaVxyXG4gICAgICAgICAgICAgICAgLz5cclxuICAgICAgICAgICAgPC9EZW1vPlxyXG5cclxuICAgICAgICAgICAgPERlbW8gdGl0bGU9XCJFeHRlbmRlZCBGQUJcIj5cclxuICAgICAgICAgICAgICAgIDxGQUJcclxuICAgICAgICAgICAgICAgICAgICBpY29uPVwic3RhclwiXHJcbiAgICAgICAgICAgICAgICAgICAgbGFiZWw9XCJTdGFyXCJcclxuICAgICAgICAgICAgICAgIC8+XHJcbiAgICAgICAgICAgIDwvRGVtbz5cclxuXHJcbiAgICAgICAgICAgIDxEZW1vIHRpdGxlPVwiRXh0ZW5kZWQgRkFCIHdpdGggYSB0cmFpbGluZyBpY29uXCI+XHJcbiAgICAgICAgICAgICAgICA8RkFCXHJcbiAgICAgICAgICAgICAgICAgICAgbGFiZWw9XCJTdGFyXCJcclxuICAgICAgICAgICAgICAgICAgICB0cmFpbGluZ0ljb249XCJzdGFyXCJcclxuICAgICAgICAgICAgICAgIC8+XHJcbiAgICAgICAgICAgIDwvRGVtbz5cclxuXHJcbiAgICAgICAgICAgIDxEZW1vXHJcbiAgICAgICAgICAgICAgICB0aXRsZT1cIkFuaW1hdGVkIEZBQlwiXHJcbiAgICAgICAgICAgICAgICBzZXR1cD17XHJcbiAgICAgICAgICAgICAgICAgICAgPEJ1dHRvblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBsYWJlbD1cIlRvZ2dsZVwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2xpY2s9eygpID0+IHNldEV4aXRlZCh2ID0+ICF2KX1cclxuICAgICAgICAgICAgICAgICAgICAvPlxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICA+XHJcbiAgICAgICAgICAgICAgICA8RkFCXHJcbiAgICAgICAgICAgICAgICAgICAgaWNvbj1cInN0YXJcIlxyXG4gICAgICAgICAgICAgICAgICAgIGV4aXRlZD17aXNFeGl0ZWR9XHJcbiAgICAgICAgICAgICAgICAvPlxyXG4gICAgICAgICAgICA8L0RlbW8+XHJcbiAgICAgICAgPC9QYWdlPlxyXG4gICAgKTtcclxufSIsImltcG9ydCB7XHJcbiAgICBDaGVja2JveCxcclxuICAgIEZvcm1GaWVsZFxyXG59IGZyb20gJ21kYy1yZWFjdCc7XHJcblxyXG5pbXBvcnQgRGVtbyBmcm9tICdAL2NvbXBvbmVudHMvRGVtbyc7XHJcbmltcG9ydCBQYWdlIGZyb20gJ0AvY29tcG9uZW50cy9QYWdlJztcclxuXHJcbmltcG9ydCAnLi9pbmRleC5zY3NzJztcclxuXHJcbmNvbnN0IGlkID0gJ2Zvcm0tZmllbGQnO1xyXG5jb25zdCB0aXRsZSA9ICdGb3JtIEZpZWxkJztcclxuY29uc3QgZGVzY3JpcHRpb24gPSAnRm9ybSBGaWVsZCBhbGlnbnMgYSBmb3JtIGZpZWxkIChmb3IgZXhhbXBsZSwgYSBjaGVja2JveCkgd2l0aCBpdHMgbGFiZWwgYW5kIG1ha2VzIGl0IFJUTC1hd2FyZS4nO1xyXG5jb25zdCBsaW5rcyA9IHtcclxuICAgIGRvY3M6ICdodHRwczovL2dpdGh1Yi5jb20vbWF0ZXJpYWwtY29tcG9uZW50cy9tYXRlcmlhbC1jb21wb25lbnRzLXdlYi90cmVlL21hc3Rlci9wYWNrYWdlcy9tZGMtZm9ybS1maWVsZCdcclxufTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIEZvcm1GaWVsZFBhZ2UoKSB7XHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAgIDxQYWdlIGlkPXtpZH0gdGl0bGU9e3RpdGxlfSBkZXNjcmlwdGlvbj17ZGVzY3JpcHRpb259IGxpbmtzPXtsaW5rc30+XHJcbiAgICAgICAgICAgIDxEZW1vIHRpdGxlPVwiQmFzaWMgZm9ybSBmaWVsZFwiPlxyXG4gICAgICAgICAgICAgICAgPEZvcm1GaWVsZCBsYWJlbD1cIkxhYmVsXCI+XHJcbiAgICAgICAgICAgICAgICAgICAgPENoZWNrYm94IC8+XHJcbiAgICAgICAgICAgICAgICA8L0Zvcm1GaWVsZD5cclxuICAgICAgICAgICAgPC9EZW1vPlxyXG5cclxuICAgICAgICAgICAgPERlbW8gdGl0bGU9XCJGb3JtIGZpZWxkIHRoYXQgZ29lcyBiZWZvcmUgdGhlIGVsZW1lbnRcIj5cclxuICAgICAgICAgICAgICAgIDxGb3JtRmllbGQgbGFiZWw9XCJMYWJlbFwiIGFsaWduRW5kPlxyXG4gICAgICAgICAgICAgICAgICAgIDxDaGVja2JveCAvPlxyXG4gICAgICAgICAgICAgICAgPC9Gb3JtRmllbGQ+XHJcbiAgICAgICAgICAgIDwvRGVtbz5cclxuXHJcbiAgICAgICAgICAgIDxEZW1vIHRpdGxlPVwiTm8gd3JhcCBmb3JtIGZpZWxkXCI+XHJcbiAgICAgICAgICAgICAgICA8Rm9ybUZpZWxkIGxhYmVsPVwiTGFiZWxcIiBub3dyYXA+XHJcbiAgICAgICAgICAgICAgICAgICAgPENoZWNrYm94IC8+XHJcbiAgICAgICAgICAgICAgICA8L0Zvcm1GaWVsZD5cclxuICAgICAgICAgICAgPC9EZW1vPlxyXG5cclxuICAgICAgICAgICAgPERlbW8gdGl0bGU9XCJGb3JtIGZpZWxkIHdpdGggc3BhY2UgYmV0d2VlblwiPlxyXG4gICAgICAgICAgICAgICAgPEZvcm1GaWVsZCBsYWJlbD1cIkxhYmVsXCIgc3BhY2VCZXR3ZWVuPlxyXG4gICAgICAgICAgICAgICAgICAgIDxDaGVja2JveCAvPlxyXG4gICAgICAgICAgICAgICAgPC9Gb3JtRmllbGQ+XHJcbiAgICAgICAgICAgIDwvRGVtbz5cclxuXHJcbiAgICAgICAgICAgIDxEZW1vIHRpdGxlPVwiQmxvY2sgZm9ybSBmaWVsZFwiPlxyXG4gICAgICAgICAgICAgICAgPEZvcm1GaWVsZCBsYWJlbD1cIkxhYmVsXCIgYmxvY2s+XHJcbiAgICAgICAgICAgICAgICAgICAgPENoZWNrYm94IC8+XHJcbiAgICAgICAgICAgICAgICA8L0Zvcm1GaWVsZD5cclxuICAgICAgICAgICAgPC9EZW1vPlxyXG4gICAgICAgIDwvUGFnZT5cclxuICAgICk7XHJcbn0iLCJpbXBvcnQgbWFya2VkIGZyb20gJ21hcmtlZCc7XHJcblxyXG5pbXBvcnQgaGlnaGxpZ2h0IGZyb20gJy4vaGlnaGxpZ2h0JztcclxuXHJcbm1hcmtlZC5zZXRPcHRpb25zKHtcclxuICAgIGhpZ2hsaWdodCxcclxuICAgIGxhbmdQcmVmaXg6ICdobGpzIGxhbmd1YWdlLSdcclxufSk7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBtYXJrZWQ7IiwiaW1wb3J0IHsgVGV4dCB9IGZyb20gJ21kYy1yZWFjdCc7XHJcbmltcG9ydCBQYWdlIGZyb20gJ0AvY29tcG9uZW50cy9QYWdlJztcclxuaW1wb3J0IG1hcmtkb3duIGZyb20gJ0AvdXRpbHMvbWFya2Rvd24nO1xyXG5cclxuaW1wb3J0IHBja2cgZnJvbSAnLi4vLi4vLi4vLi4vcGFja2FnZS5qc29uJztcclxuaW1wb3J0IHJlYWRtZSBmcm9tICcuLi8uLi8uLi8uLi9SRUFETUUubWQnO1xyXG5cclxuaW1wb3J0ICcuL2luZGV4LnNjc3MnO1xyXG5cclxuY29uc3QgaHRtbCA9IG1hcmtkb3duKHJlYWRtZSk7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBIb21lUGFnZSgpIHtcclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgPFBhZ2UgaWQ9XCJob21lXCI+XHJcbiAgICAgICAgICAgIDxUZXh0IHR5cGU9XCJvdmVybGluZVwiPntwY2tnLnZlcnNpb259PC9UZXh0PlxyXG5cclxuICAgICAgICAgICAgPGFydGljbGVcclxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZT1cIm1hcmtkb3duXCJcclxuICAgICAgICAgICAgICAgIGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MPXt7IF9faHRtbDogaHRtbCB9fVxyXG4gICAgICAgICAgICAvPlxyXG4gICAgICAgIDwvUGFnZT5cclxuICAgICk7XHJcbn0iLCJpbXBvcnQgeyB1c2VTdGF0ZSB9IGZyb20gJ3JlYWN0JztcclxuaW1wb3J0IHtcclxuICAgIEZvcm1GaWVsZCxcclxuICAgIEljb24sXHJcbiAgICBTZWdtZW50ZWRCdXR0b24sXHJcbiAgICBTd2l0Y2gsXHJcbiAgICBUZXh0RmllbGRcclxufSBmcm9tICdtZGMtcmVhY3QnO1xyXG5cclxuaW1wb3J0IERlbW8gZnJvbSAnQC9jb21wb25lbnRzL0RlbW8nO1xyXG5pbXBvcnQgRmllbGRTZXQgZnJvbSAnQC9jb21wb25lbnRzL0ZpZWxkU2V0JztcclxuaW1wb3J0IFBhZ2UgZnJvbSAnQC9jb21wb25lbnRzL1BhZ2UnO1xyXG5cclxuaW1wb3J0ICcuL2luZGV4LnNjc3MnO1xyXG5cclxuY29uc3QgaWQgPSAnaWNvbic7XHJcbmNvbnN0IHRpdGxlID0gJ0ljb24nO1xyXG5jb25zdCBkZXNjcmlwdGlvbiA9ICdNYXRlcmlhbCBkZXNpZ24gc3lzdGVtIGljb25zIGFyZSBzaW1wbGUsIG1vZGVybiwgZnJpZW5kbHksIGFuZCBzb21ldGltZXMgcXVpcmt5LiBFYWNoIGljb24gaXMgY3JlYXRlZCB1c2luZyBvdXIgZGVzaWduIGd1aWRlbGluZXMgdG8gZGVwaWN0IGluIHNpbXBsZSBhbmQgbWluaW1hbCBmb3JtcyB0aGUgdW5pdmVyc2FsIGNvbmNlcHRzIHVzZWQgY29tbW9ubHkgdGhyb3VnaG91dCBhIFVJLic7XHJcbmNvbnN0IGxpbmtzID0ge1xyXG4gICAgZG9jczogJ2h0dHBzOi8vZGV2ZWxvcGVycy5nb29nbGUuY29tL2ZvbnRzL2RvY3MvbWF0ZXJpYWxfaWNvbnMnLFxyXG4gICAgZ3VpZGU6ICdodHRwczovL21hdGVyaWFsLmlvL2Rlc2lnbi9pY29ub2dyYXBoeSdcclxufTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIEljb25QYWdlKCkge1xyXG4gICAgY29uc3QgW25hbWUsIHNldE5hbWVdID0gdXNlU3RhdGUoJ2ZsYWcnKTtcclxuICAgIGNvbnN0IFtzaXplLCBzZXRTaXplXSA9IHVzZVN0YXRlKCcnKTtcclxuICAgIGNvbnN0IFt0eXBlLCBzZXRUeXBlXSA9IHVzZVN0YXRlKCcnKTtcclxuICAgIGNvbnN0IFt0b25lLCBzZXRUb25lXSA9IHVzZVN0YXRlKCcnKTtcclxuICAgIGNvbnN0IFtpbmFjdGl2ZSwgc2V0SW5hY3RpdmVdID0gdXNlU3RhdGUoZmFsc2UpO1xyXG5cclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgPFBhZ2UgaWQ9e2lkfSB0aXRsZT17dGl0bGV9IGRlc2NyaXB0aW9uPXtkZXNjcmlwdGlvbn0gbGlua3M9e2xpbmtzfT5cclxuICAgICAgICAgICAgPERlbW9cclxuICAgICAgICAgICAgICAgIHRpdGxlPVwiRGVtb1wiXHJcbiAgICAgICAgICAgICAgICBzZXR0aW5ncz17PD5cclxuICAgICAgICAgICAgICAgICAgICA8VGV4dEZpZWxkXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlPXtuYW1lfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBsYWJlbD1cIkxhYmVsXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgb3V0bGluZWRcclxuICAgICAgICAgICAgICAgICAgICAgICAgb25DaGFuZ2U9eyhfLCB2YWx1ZSkgPT4gc2V0TmFtZSh2YWx1ZSl9XHJcbiAgICAgICAgICAgICAgICAgICAgLz5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgPEZpZWxkU2V0IGxlZ2VuZD1cIlR5cGVcIj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPFNlZ21lbnRlZEJ1dHRvblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VnbWVudHM9e1tcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7IHZhbHVlOiAnZmlsbGVkJywgbGFiZWw6ICdGaWxsZWQnIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeyB2YWx1ZTogJ291dGxpbmVkJywgbGFiZWw6ICdPdXRsaW5lZCcgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7IHZhbHVlOiAncm91bmQnLCBsYWJlbDogJ1JvdW5kJyB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgdmFsdWU6ICdzaGFycCcsIGxhYmVsOiAnU2hhcnAnIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeyB2YWx1ZTogJ3R3by10b25lJywgbGFiZWw6ICdUd28gVG9uZScgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXX1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlPXt0eXBlfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb25DaGFuZ2U9e3NldFR5cGV9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8+XHJcbiAgICAgICAgICAgICAgICAgICAgPC9GaWVsZFNldD5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgPEZpZWxkU2V0IGxlZ2VuZD1cIlNpemVcIj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPFNlZ21lbnRlZEJ1dHRvblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VnbWVudHM9e1tcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7IHZhbHVlOiAnc21hbGxlcicsIGxhYmVsOiAnU21hbGxlcicgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7IHZhbHVlOiAnc21hbGwnLCBsYWJlbDogJ1NtYWxsJyB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgdmFsdWU6ICdtZWRpdW0nLCBsYWJlbDogJ01lZGl1bScgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7IHZhbHVlOiAnbGFyZ2UnLCBsYWJlbDogJ0xhcmdlJyB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgdmFsdWU6ICdsYXJnZXInLCBsYWJlbDogJ0xhcmdlcicgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXX1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlPXtzaXplfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb25DaGFuZ2U9e3NldFNpemV9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8+XHJcbiAgICAgICAgICAgICAgICAgICAgPC9GaWVsZFNldD5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgPEZpZWxkU2V0IGxlZ2VuZD1cIlRvbmVcIj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPFNlZ21lbnRlZEJ1dHRvblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VnbWVudHM9e1tcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7IHZhbHVlOiAnJywgbGFiZWw6ICdOb25lJyB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgdmFsdWU6ICdsaWdodCcsIGxhYmVsOiAnTGlnaHQnIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeyB2YWx1ZTogJ2RhcmsnLCBsYWJlbDogJ0RhcmsnIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF19XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZT17dG9uZX1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2hhbmdlPXtzZXRUb25lfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvPlxyXG4gICAgICAgICAgICAgICAgICAgIDwvRmllbGRTZXQ+XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIDxGb3JtRmllbGQgbGFiZWw9XCJJbmFjdGl2ZVwiIGFsaWduRW5kIHNwYWNlQmV0d2Vlbj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPFN3aXRjaFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0ZWQ9e2luYWN0aXZlfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb25DaGFuZ2U9eygpID0+IHNldEluYWN0aXZlKHYgPT4gIXYpfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvPlxyXG4gICAgICAgICAgICAgICAgICAgIDwvRm9ybUZpZWxkPlxyXG4gICAgICAgICAgICAgICAgPC8+fVxyXG4gICAgICAgICAgICA+XHJcbiAgICAgICAgICAgICAgICA8SWNvblxyXG4gICAgICAgICAgICAgICAgICAgIG5hbWU9e25hbWV9XHJcbiAgICAgICAgICAgICAgICAgICAgdHlwZT17dHlwZX1cclxuICAgICAgICAgICAgICAgICAgICBzaXplPXtzaXplfVxyXG4gICAgICAgICAgICAgICAgICAgIGxpZ2h0PXt0b25lID09PSAnbGlnaHQnfVxyXG4gICAgICAgICAgICAgICAgICAgIGRhcms9e3RvbmUgPT09ICdkYXJrJ31cclxuICAgICAgICAgICAgICAgICAgICBpbmFjdGl2ZT17aW5hY3RpdmV9XHJcbiAgICAgICAgICAgICAgICAvPlxyXG4gICAgICAgICAgICA8L0RlbW8+XHJcbiAgICAgICAgPC9QYWdlPlxyXG4gICAgKTtcclxufSIsImltcG9ydCB7IHVzZVN0YXRlIH0gZnJvbSAncmVhY3QnO1xyXG5pbXBvcnQge1xyXG4gICAgSWNvbkJ1dHRvbixcclxuICAgIFN5bWJvbFxyXG59IGZyb20gJ21kYy1yZWFjdCc7XHJcblxyXG5pbXBvcnQgRGVtbyBmcm9tICdAL2NvbXBvbmVudHMvRGVtbyc7XHJcbmltcG9ydCBGaWVsZFNldCBmcm9tICdAL2NvbXBvbmVudHMvRmllbGRTZXQnO1xyXG5pbXBvcnQgUGFnZSBmcm9tICdAL2NvbXBvbmVudHMvUGFnZSc7XHJcblxyXG5jb25zdCBpZCA9ICdpY29uLWJ1dHRvbic7XHJcbmNvbnN0IHRpdGxlID0gJ0ljb24gQnV0dG9uJztcclxuY29uc3QgZGVzY3JpcHRpb24gPSAnSWNvbiBidXR0b25zIGFsbG93IHVzZXJzIHRvIHRha2UgYWN0aW9ucywgYW5kIG1ha2UgY2hvaWNlcywgd2l0aCBhIHNpbmdsZSB0YXAuJztcclxuY29uc3QgbGlua3MgPSB7XHJcbiAgICBkb2NzOiAnaHR0cHM6Ly9naXRodWIuY29tL21hdGVyaWFsLWNvbXBvbmVudHMvbWF0ZXJpYWwtY29tcG9uZW50cy13ZWIvdHJlZS9tYXN0ZXIvcGFja2FnZXMvbWRjLWljb24tYnV0dG9uJyxcclxuICAgIGd1aWRlOiAnaHR0cHM6Ly9tYXRlcmlhbC5pby9jb21wb25lbnRzL2J1dHRvbnMnXHJcbn07XHJcblxyXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBJY29uQnV0dG9uUGFnZSgpIHtcclxuICAgIGNvbnN0IFtpc09uLCBzZXRPbl0gPSB1c2VTdGF0ZSh0cnVlKTtcclxuXHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAgIDxQYWdlIGlkPXtpZH0gdGl0bGU9e3RpdGxlfSBkZXNjcmlwdGlvbj17ZGVzY3JpcHRpb259IGxpbmtzPXtsaW5rc30+XHJcbiAgICAgICAgICAgIDxEZW1vIHRpdGxlPVwiQmFzaWMgaWNvbiBidXR0b25cIj5cclxuICAgICAgICAgICAgICAgIDxJY29uQnV0dG9uXHJcbiAgICAgICAgICAgICAgICAgICAgaWNvbj1cImZsYWdcIlxyXG4gICAgICAgICAgICAgICAgLz5cclxuICAgICAgICAgICAgPC9EZW1vPlxyXG5cclxuICAgICAgICAgICAgPERlbW8gdGl0bGU9XCJUb2dnbGluZyBpY29uIGJ1dHRvblwiPlxyXG4gICAgICAgICAgICAgICAgPEljb25CdXR0b25cclxuICAgICAgICAgICAgICAgICAgICBpY29uPXtpc09uID8gJ2Zhdm9yaXRlJyA6ICdmYXZvcml0ZV9vdXRsaW5lZCd9XHJcbiAgICAgICAgICAgICAgICAgICAgb25DbGljaz17KCkgPT4gc2V0T24odiA9PiAhdil9XHJcbiAgICAgICAgICAgICAgICAvPlxyXG4gICAgICAgICAgICA8L0RlbW8+XHJcblxyXG4gICAgICAgICAgICA8RGVtbyB0aXRsZT1cIldpdGggYSBzeW1ib2xcIj5cclxuICAgICAgICAgICAgICAgIDxJY29uQnV0dG9uXHJcbiAgICAgICAgICAgICAgICAgICAgaWNvbj17PFN5bWJvbD5mbGFnPC9TeW1ib2w+fVxyXG4gICAgICAgICAgICAgICAgLz5cclxuICAgICAgICAgICAgPC9EZW1vPlxyXG4gICAgICAgIDwvUGFnZT5cclxuICAgICk7XHJcbn0iLCJpbXBvcnQge1xyXG4gICAgSW1hZ2VMaXN0XHJcbn0gZnJvbSAnbWRjLXJlYWN0JztcclxuXHJcbmNvbnN0IGlkID0gJ2ltYWdlLWxpc3QnO1xyXG5jb25zdCB0aXRsZSA9ICdJbWFnZSBMaXN0JztcclxuY29uc3QgZGVzY3JpcHRpb24gPSAnSW1hZ2UgbGlzdHMgZGlzcGxheSBhIGNvbGxlY3Rpb24gb2YgaW1hZ2VzIGluIGFuIG9yZ2FuaXplZCBncmlkLic7XHJcbmNvbnN0IGxpbmtzID0ge1xyXG4gICAgZG9jczogJ2h0dHBzOi8vZ2l0aHViLmNvbS9tYXRlcmlhbC1jb21wb25lbnRzL21hdGVyaWFsLWNvbXBvbmVudHMtd2ViL3RyZWUvbWFzdGVyL3BhY2thZ2VzL21kYy1pbWFnZS1saXN0JyxcclxuICAgIGd1aWRlOiAnaHR0cHM6Ly9tYXRlcmlhbC5pby9jb21wb25lbnRzL2ltYWdlLWxpc3RzJ1xyXG59O1xyXG5cclxuaW1wb3J0IERlbW8gZnJvbSAnQC9jb21wb25lbnRzL0RlbW8nO1xyXG5pbXBvcnQgUGFnZSBmcm9tICdAL2NvbXBvbmVudHMvUGFnZSc7XHJcblxyXG5pbXBvcnQgJy4vaW5kZXguc2Nzcyc7XHJcblxyXG5jb25zdCBzdGFuZGFyZEl0ZW1zID0gbmV3IEFycmF5KDE1KS5maWxsKDEpLm1hcCgoKSA9PiAoe1xyXG4gICAgaW1hZ2VTcmM6ICdodHRwczovL3BsYWNlaW1nLmNvbS8zNjAvMzYwL2FueScsXHJcbiAgICBsYWJlbDogJ1RleHQgTGFiZWwnXHJcbn0pKTtcclxuXHJcbmNvbnN0IG1hc29ucnlJdGVtcyA9IG5ldyBBcnJheSgxNSkuZmlsbCgxKS5tYXAoKCkgPT4gKHtcclxuICAgIGltYWdlU3JjOiBgaHR0cHM6Ly9wbGFjZWltZy5jb20vJHtNYXRoLnJhbmRvbSgpID4gMC41ID8gJzQ4MC8zNjAnIDogJzM2MC80ODAnfS9hbnlgLFxyXG4gICAgbGFiZWw6ICdUZXh0IExhYmVsJ1xyXG59KSk7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBJbWFnZUxpc3RQYWdlKCkge1xyXG4gICAgcmV0dXJuIChcclxuICAgICAgICA8UGFnZSBpZD17aWR9IHRpdGxlPXt0aXRsZX0gZGVzY3JpcHRpb249e2Rlc2NyaXB0aW9ufSBsaW5rcz17bGlua3N9PlxyXG4gICAgICAgICAgICA8RGVtbyBpZD1cInN0YW5kYXJkLWltYWdlLWxpc3RcIiB0aXRsZT1cIlN0YW5kYXJkIEltYWdlIExpc3RcIj5cclxuICAgICAgICAgICAgICAgIDxJbWFnZUxpc3Q+XHJcbiAgICAgICAgICAgICAgICAgICAge3N0YW5kYXJkSXRlbXMubWFwKChpdGVtLCBpbmRleCkgPT5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPEltYWdlTGlzdC5JdGVtIGtleT17aW5kZXh9IHsuLi5pdGVtfSAvPlxyXG4gICAgICAgICAgICAgICAgICAgICl9XHJcbiAgICAgICAgICAgICAgICA8L0ltYWdlTGlzdD5cclxuICAgICAgICAgICAgPC9EZW1vPlxyXG5cclxuICAgICAgICAgICAgPERlbW8gaWQ9XCJzdGFuZGFyZC1pbWFnZS1saXN0XCIgdGl0bGU9XCJTdGFuZGFyZCBJbWFnZSBMaXN0IHdpdGggVGV4dCBQcm90ZWN0aW9uXCI+XHJcbiAgICAgICAgICAgICAgICA8SW1hZ2VMaXN0IHdpdGhUZXh0UHJvdGVjdGlvbj5cclxuICAgICAgICAgICAgICAgICAgICB7c3RhbmRhcmRJdGVtcy5tYXAoKGl0ZW0sIGluZGV4KSA9PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8SW1hZ2VMaXN0Lkl0ZW0ga2V5PXtpbmRleH0gey4uLml0ZW19IC8+XHJcbiAgICAgICAgICAgICAgICAgICAgKX1cclxuICAgICAgICAgICAgICAgIDwvSW1hZ2VMaXN0PlxyXG4gICAgICAgICAgICA8L0RlbW8+XHJcblxyXG4gICAgICAgICAgICA8RGVtbyBpZD1cIm1hc29ucnktaW1hZ2UtbGlzdFwiIHRpdGxlPVwiTWFzb25yeSBJbWFnZSBMaXN0XCI+XHJcbiAgICAgICAgICAgICAgICA8SW1hZ2VMaXN0IG1hc29ucnk+XHJcbiAgICAgICAgICAgICAgICAgICAge21hc29ucnlJdGVtcy5tYXAoKGl0ZW0sIGluZGV4KSA9PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8SW1hZ2VMaXN0Lkl0ZW0ga2V5PXtpbmRleH0gey4uLml0ZW19IC8+XHJcbiAgICAgICAgICAgICAgICAgICAgKX1cclxuICAgICAgICAgICAgICAgIDwvSW1hZ2VMaXN0PlxyXG4gICAgICAgICAgICA8L0RlbW8+XHJcblxyXG4gICAgICAgICAgICA8RGVtbyBpZD1cIm1hc29ucnktaW1hZ2UtbGlzdFwiIHRpdGxlPVwiTWFzb25yeSBJbWFnZSBMaXN0IHdpdGggVGV4dCBQcm90ZWN0aW9uXCI+XHJcbiAgICAgICAgICAgICAgICA8SW1hZ2VMaXN0IG1hc29ucnkgd2l0aFRleHRQcm90ZWN0aW9uPlxyXG4gICAgICAgICAgICAgICAgICAgIHttYXNvbnJ5SXRlbXMubWFwKChpdGVtLCBpbmRleCkgPT5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPEltYWdlTGlzdC5JdGVtIGtleT17aW5kZXh9IHsuLi5pdGVtfSAvPlxyXG4gICAgICAgICAgICAgICAgICAgICl9XHJcbiAgICAgICAgICAgICAgICA8L0ltYWdlTGlzdD5cclxuICAgICAgICAgICAgPC9EZW1vPlxyXG4gICAgICAgIDwvUGFnZT5cclxuICAgICk7XHJcbn0iLCJpbXBvcnQge1xyXG4gICAgTGF5b3V0R3JpZFxyXG59IGZyb20gJ21kYy1yZWFjdCc7XHJcblxyXG5pbXBvcnQgRGVtbyBmcm9tICdAL2NvbXBvbmVudHMvRGVtbyc7XHJcbmltcG9ydCBQYWdlIGZyb20gJ0AvY29tcG9uZW50cy9QYWdlJztcclxuXHJcbmltcG9ydCAnLi9pbmRleC5zY3NzJztcclxuXHJcbmNvbnN0IGlkID0gJ2xheW91dC1ncmlkJztcclxuY29uc3QgdGl0bGUgPSAnTGF5b3V0IEdyaWQnO1xyXG5jb25zdCBkZXNjcmlwdGlvbiA9ICdNYXRlcmlhbCBkZXNpZ27igJlzIHJlc3BvbnNpdmUgVUkgaXMgYmFzZWQgb24gYSAxMi1jb2x1bW4gZ3JpZCBsYXlvdXQuJztcclxuY29uc3QgbGlua3MgPSB7XHJcbiAgICBkb2NzOiAnaHR0cHM6Ly9naXRodWIuY29tL21hdGVyaWFsLWNvbXBvbmVudHMvbWF0ZXJpYWwtY29tcG9uZW50cy13ZWIvdHJlZS9tYXN0ZXIvcGFja2FnZXMvbWRjLWxheW91dC1ncmlkJyxcclxuICAgIGd1aWRlOiAnaHR0cHM6Ly9tYXRlcmlhbC5pby9kZXNpZ24vbGF5b3V0L3Jlc3BvbnNpdmUtbGF5b3V0LWdyaWQuaHRtbCdcclxufTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIExheW91dEdyaWRQYWdlKCkge1xyXG4gICAgcmV0dXJuIChcclxuICAgICAgICA8UGFnZSBpZD17aWR9IHRpdGxlPXt0aXRsZX0gZGVzY3JpcHRpb249e2Rlc2NyaXB0aW9ufSBsaW5rcz17bGlua3N9PlxyXG4gICAgICAgICAgICA8RGVtbyB0aXRsZT1cIkJhc2ljIGdyaWRcIj5cclxuICAgICAgICAgICAgICAgIDxMYXlvdXRHcmlkPlxyXG4gICAgICAgICAgICAgICAgICAgIDxMYXlvdXRHcmlkLkNlbGwgc3Bhbj1cIjZcIiAvPlxyXG4gICAgICAgICAgICAgICAgICAgIDxMYXlvdXRHcmlkLkNlbGwgc3Bhbj1cIjNcIiAvPlxyXG4gICAgICAgICAgICAgICAgICAgIDxMYXlvdXRHcmlkLkNlbGwgc3Bhbj1cIjJcIiAvPlxyXG4gICAgICAgICAgICAgICAgICAgIDxMYXlvdXRHcmlkLkNlbGwgc3Bhbj1cIjFcIiAvPlxyXG4gICAgICAgICAgICAgICAgICAgIDxMYXlvdXRHcmlkLkNlbGwgc3Bhbj1cIjNcIiAvPlxyXG4gICAgICAgICAgICAgICAgICAgIDxMYXlvdXRHcmlkLkNlbGwgc3Bhbj1cIjFcIiAvPlxyXG4gICAgICAgICAgICAgICAgICAgIDxMYXlvdXRHcmlkLkNlbGwgc3Bhbj1cIjhcIiAvPlxyXG4gICAgICAgICAgICAgICAgPC9MYXlvdXRHcmlkPlxyXG4gICAgICAgICAgICA8L0RlbW8+XHJcblxyXG4gICAgICAgICAgICA8RGVtbyB0aXRsZT1cIk5lc3RlZCBncmlkXCI+XHJcbiAgICAgICAgICAgICAgICA8TGF5b3V0R3JpZD5cclxuICAgICAgICAgICAgICAgICAgICA8TGF5b3V0R3JpZC5DZWxsIGdyaWQ+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxMYXlvdXRHcmlkLkNlbGwgLz5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPExheW91dEdyaWQuQ2VsbCAvPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8TGF5b3V0R3JpZC5DZWxsIC8+XHJcbiAgICAgICAgICAgICAgICAgICAgPC9MYXlvdXRHcmlkLkNlbGw+XHJcbiAgICAgICAgICAgICAgICAgICAgPExheW91dEdyaWQuQ2VsbCAvPlxyXG4gICAgICAgICAgICAgICAgICAgIDxMYXlvdXRHcmlkLkNlbGwgLz5cclxuICAgICAgICAgICAgICAgIDwvTGF5b3V0R3JpZD5cclxuICAgICAgICAgICAgPC9EZW1vPlxyXG4gICAgICAgIDwvUGFnZT5cclxuICAgICk7XHJcbn0iLCJpbXBvcnQgeyB1c2VTdGF0ZSB9IGZyb20gJ3JlYWN0JztcclxuaW1wb3J0IHtcclxuICAgIEJ1dHRvbixcclxuICAgIExpbmVhclByb2dyZXNzXHJcbn0gZnJvbSAnbWRjLXJlYWN0JztcclxuXHJcbmltcG9ydCBEZW1vIGZyb20gJ0AvY29tcG9uZW50cy9EZW1vJztcclxuaW1wb3J0IFBhZ2UgZnJvbSAnQC9jb21wb25lbnRzL1BhZ2UnO1xyXG5cclxuY29uc3QgaWQgPSAnbGluZWFyLXByb2dyZXNzJztcclxuY29uc3QgdGl0bGUgPSAnTGluZWFyIFByb2dyZXNzJztcclxuY29uc3QgZGVzY3JpcHRpb24gPSAnUHJvZ3Jlc3MgaW5kaWNhdG9ycyBkaXNwbGF5IHRoZSBsZW5ndGggb2YgYSBwcm9jZXNzIG9yIGV4cHJlc3MgYW4gdW5zcGVjaWZpZWQgd2FpdCB0aW1lLic7XHJcbmNvbnN0IGxpbmtzID0ge1xyXG4gICAgZG9jczogJycsXHJcbiAgICBndWlkZTogJydcclxufTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIExpbmVhclByb2dyZXNzUGFnZSgpIHtcclxuICAgIGNvbnN0IFtpc0Nsb3NlZCwgc2V0Q2xvc2VkXSA9IHVzZVN0YXRlKHRydWUpO1xyXG5cclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgPFBhZ2UgaWQ9e2lkfSB0aXRsZT17dGl0bGV9IGRlc2NyaXB0aW9uPXtkZXNjcmlwdGlvbn0gbGlua3M9e2xpbmtzfT5cclxuICAgICAgICAgICAgPERlbW8gdGl0bGU9XCJCYXNpYyBsaW5lYXIgcHJvZ3Jlc3NcIj5cclxuICAgICAgICAgICAgICAgIDxMaW5lYXJQcm9ncmVzcyB2YWx1ZT1cIjQyXCIgLz5cclxuICAgICAgICAgICAgPC9EZW1vPlxyXG5cclxuICAgICAgICAgICAgPERlbW8gdGl0bGU9XCJMaW5lYXIgcHJvZ3Jlc3Mgd2l0aCBhIGJ1ZmZlclwiPlxyXG4gICAgICAgICAgICAgICAgPExpbmVhclByb2dyZXNzIHZhbHVlPVwiNDJcIiBidWZmZXI9XCI4NFwiIC8+XHJcbiAgICAgICAgICAgIDwvRGVtbz5cclxuXHJcbiAgICAgICAgICAgIDxEZW1vIHRpdGxlPVwiSW5kZXRlcm1pbmF0ZSBsaW5lYXIgcHJvZ3Jlc3NcIj5cclxuICAgICAgICAgICAgICAgIDxMaW5lYXJQcm9ncmVzcyBpbmRldGVybWluYXRlIC8+XHJcbiAgICAgICAgICAgIDwvRGVtbz5cclxuXHJcbiAgICAgICAgICAgIDxEZW1vXHJcbiAgICAgICAgICAgICAgICB0aXRsZT1cIkNsb3NlZCBsaW5lYXIgcHJvZ3Jlc3NcIlxyXG4gICAgICAgICAgICAgICAgc2V0dXA9e1xyXG4gICAgICAgICAgICAgICAgICAgIDxCdXR0b24gb25DbGljaz17KCkgPT4gc2V0Q2xvc2VkKHYgPT4gIXYpfT5Ub2dnbGU8L0J1dHRvbj5cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgPlxyXG4gICAgICAgICAgICAgICAgPExpbmVhclByb2dyZXNzIGNsb3NlZD17aXNDbG9zZWR9IHZhbHVlPVwiNDJcIiAvPlxyXG4gICAgICAgICAgICA8L0RlbW8+XHJcbiAgICAgICAgPC9QYWdlPlxyXG4gICAgKTtcclxufSIsImltcG9ydCB7XHJcbiAgICBDaGVja2JveCxcclxuICAgIExpc3QsIExpc3RJdGVtLFxyXG4gICAgUmFkaW8sXHJcbiAgICBTd2l0Y2hcclxufSBmcm9tICdtZGMtcmVhY3QnO1xyXG5cclxuaW1wb3J0IERlbW8gZnJvbSAnQC9jb21wb25lbnRzL0RlbW8nO1xyXG5pbXBvcnQgUGFnZSBmcm9tICdAL2NvbXBvbmVudHMvUGFnZSc7XHJcblxyXG5jb25zdCBpZCA9ICdsaXN0JztcclxuY29uc3QgdGl0bGUgPSAnTGlzdCc7XHJcbmNvbnN0IGRlc2NyaXB0aW9uID0gJ0xpc3RzIHByZXNlbnQgbXVsdGlwbGUgbGluZSBpdGVtcyB2ZXJ0aWNhbGx5IGFzIGEgc2luZ2xlIGNvbnRpbnVvdXMgZWxlbWVudC4nO1xyXG5jb25zdCBsaW5rcyA9IHtcclxuICAgIGRvY3M6ICdodHRwczovL2dpdGh1Yi5jb20vbWF0ZXJpYWwtY29tcG9uZW50cy9tYXRlcmlhbC1jb21wb25lbnRzLXdlYi90cmVlL21hc3Rlci9wYWNrYWdlcy9tZGMtbGlzdCcsXHJcbiAgICBndWlkZTogJ2h0dHBzOi8vbWF0ZXJpYWwuaW8vY29tcG9uZW50cy9saXN0cydcclxufTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIExpc3RQYWdlKCkge1xyXG4gICAgcmV0dXJuIChcclxuICAgICAgICA8UGFnZSBpZD17aWR9IHRpdGxlPXt0aXRsZX0gZGVzY3JpcHRpb249e2Rlc2NyaXB0aW9ufSBsaW5rcz17bGlua3N9PlxyXG4gICAgICAgICAgICA8RGVtbyB0aXRsZT1cIlNpbmdsZS1saW5lIGxpc3RcIj5cclxuICAgICAgICAgICAgICAgIDxMaXN0PlxyXG4gICAgICAgICAgICAgICAgICAgIDxMaXN0SXRlbVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0PVwiSXRlbSAxXCJcclxuICAgICAgICAgICAgICAgICAgICAvPlxyXG5cclxuICAgICAgICAgICAgICAgICAgICA8TGlzdEl0ZW1cclxuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dD1cIkl0ZW0gMlwiXHJcbiAgICAgICAgICAgICAgICAgICAgLz5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgPExpc3RJdGVtXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ9XCJJdGVtIDNcIlxyXG4gICAgICAgICAgICAgICAgICAgIC8+XHJcbiAgICAgICAgICAgICAgICA8L0xpc3Q+XHJcbiAgICAgICAgICAgIDwvRGVtbz5cclxuXHJcbiAgICAgICAgICAgIDxEZW1vIHRpdGxlPVwiVHdvLWxpbmUgbGlzdFwiPlxyXG4gICAgICAgICAgICAgICAgPExpc3Q+XHJcbiAgICAgICAgICAgICAgICAgICAgPExpc3RJdGVtXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHByaW1hcnlUZXh0PVwiSXRlbSAxXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2Vjb25kYXJ5VGV4dD1cIlNlY29uZGFyeSB0ZXh0XCJcclxuICAgICAgICAgICAgICAgICAgICAvPlxyXG5cclxuICAgICAgICAgICAgICAgICAgICA8TGlzdEl0ZW1cclxuICAgICAgICAgICAgICAgICAgICAgICAgcHJpbWFyeVRleHQ9XCJJdGVtIDJcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWNvbmRhcnlUZXh0PVwiU2Vjb25kYXJ5IHRleHRcIlxyXG4gICAgICAgICAgICAgICAgICAgIC8+XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIDxMaXN0SXRlbVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwcmltYXJ5VGV4dD1cIkl0ZW0gM1wiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlY29uZGFyeVRleHQ9XCJTZWNvbmRhcnkgdGV4dFwiXHJcbiAgICAgICAgICAgICAgICAgICAgLz5cclxuICAgICAgICAgICAgICAgIDwvTGlzdD5cclxuXHJcbiAgICAgICAgICAgICAgICA8TGlzdD5cclxuICAgICAgICAgICAgICAgICAgICA8TGlzdEl0ZW1cclxuICAgICAgICAgICAgICAgICAgICAgICAgb3ZlcmxpbmVUZXh0PVwiT3ZlcmxpbmVcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwcmltYXJ5VGV4dD1cIkl0ZW0gMVwiXHJcbiAgICAgICAgICAgICAgICAgICAgLz5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgPExpc3RJdGVtXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG92ZXJsaW5lVGV4dD1cIk92ZXJsaW5lXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgcHJpbWFyeVRleHQ9XCJJdGVtIDJcIlxyXG4gICAgICAgICAgICAgICAgICAgIC8+XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIDxMaXN0SXRlbVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBvdmVybGluZVRleHQ9XCJPdmVybGluZVwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHByaW1hcnlUZXh0PVwiSXRlbSAzXCJcclxuICAgICAgICAgICAgICAgICAgICAvPlxyXG4gICAgICAgICAgICAgICAgPC9MaXN0PlxyXG4gICAgICAgICAgICA8L0RlbW8+XHJcblxyXG4gICAgICAgICAgICA8RGVtbyB0aXRsZT1cIlRocmVlLWxpbmUgbGlzdFwiPlxyXG4gICAgICAgICAgICAgICAgPExpc3Q+XHJcbiAgICAgICAgICAgICAgICAgICAgPExpc3RJdGVtXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG92ZXJsaW5lVGV4dD1cIk92ZXJsaW5lXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgcHJpbWFyeVRleHQ9XCJJdGVtIDFcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWNvbmRhcnlUZXh0PVwiU2Vjb25kYXJ5IHRleHRcIlxyXG4gICAgICAgICAgICAgICAgICAgIC8+XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIDxMaXN0SXRlbVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBvdmVybGluZVRleHQ9XCJPdmVybGluZVwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHByaW1hcnlUZXh0PVwiSXRlbSAyXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2Vjb25kYXJ5VGV4dD1cIlNlY29uZGFyeSB0ZXh0XCJcclxuICAgICAgICAgICAgICAgICAgICAvPlxyXG5cclxuICAgICAgICAgICAgICAgICAgICA8TGlzdEl0ZW1cclxuICAgICAgICAgICAgICAgICAgICAgICAgb3ZlcmxpbmVUZXh0PVwiT3ZlcmxpbmVcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwcmltYXJ5VGV4dD1cIkl0ZW0gM1wiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlY29uZGFyeVRleHQ9XCJTZWNvbmRhcnkgdGV4dFwiXHJcbiAgICAgICAgICAgICAgICAgICAgLz5cclxuICAgICAgICAgICAgICAgIDwvTGlzdD5cclxuICAgICAgICAgICAgPC9EZW1vPlxyXG5cclxuICAgICAgICAgICAgPERlbW8gdGl0bGU9XCJMaXN0IHdpdGggaWNvbnNcIj5cclxuICAgICAgICAgICAgICAgIDxMaXN0PlxyXG4gICAgICAgICAgICAgICAgICAgIDxMaXN0SXRlbVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpY29uPVwic3RhclwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ9XCJJdGVtIDFcIlxyXG4gICAgICAgICAgICAgICAgICAgIC8+XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIDxMaXN0SXRlbVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpY29uPVwic3RhclwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ9XCJJdGVtIDJcIlxyXG4gICAgICAgICAgICAgICAgICAgIC8+XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIDxMaXN0SXRlbVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpY29uPVwic3RhclwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ9XCJJdGVtIDNcIlxyXG4gICAgICAgICAgICAgICAgICAgIC8+XHJcbiAgICAgICAgICAgICAgICA8L0xpc3Q+XHJcbiAgICAgICAgICAgIDwvRGVtbz5cclxuXHJcbiAgICAgICAgICAgIDxEZW1vIHRpdGxlPVwiTGlzdCB3aXRoIGltYWdlc1wiPlxyXG4gICAgICAgICAgICAgICAgPExpc3Q+XHJcbiAgICAgICAgICAgICAgICAgICAgPExpc3RJdGVtXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGltYWdlPXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxpbWcgc3JjPVwiaHR0cHM6Ly9wbGFjZWltZy5jb20vNTYvNTYvYW55XCIgLz5cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0PVwiSXRlbSAxXCJcclxuICAgICAgICAgICAgICAgICAgICAvPlxyXG5cclxuICAgICAgICAgICAgICAgICAgICA8TGlzdEl0ZW1cclxuICAgICAgICAgICAgICAgICAgICAgICAgaW1hZ2U9e1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGltZyBzcmM9XCJodHRwczovL3BsYWNlaW1nLmNvbS81Ni81Ni9hbnlcIiAvPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ9XCJJdGVtIDJcIlxyXG4gICAgICAgICAgICAgICAgICAgIC8+XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIDxMaXN0SXRlbVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbWFnZT17XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8aW1nIHNyYz1cImh0dHBzOi8vcGxhY2VpbWcuY29tLzU2LzU2L2FueVwiIC8+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dD1cIkl0ZW0gM1wiXHJcbiAgICAgICAgICAgICAgICAgICAgLz5cclxuICAgICAgICAgICAgICAgIDwvTGlzdD5cclxuICAgICAgICAgICAgPC9EZW1vPlxyXG5cclxuICAgICAgICAgICAgPERlbW8gdGl0bGU9XCJMaXN0IHdpdGggdGh1bWJuYWlsc1wiPlxyXG4gICAgICAgICAgICAgICAgPExpc3Q+XHJcbiAgICAgICAgICAgICAgICAgICAgPExpc3RJdGVtXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRodW1ibmFpbD17XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8aW1nIHNyYz1cImh0dHBzOi8vcGxhY2VpbWcuY29tLzQwLzQwL3Blb3BsZVwiIC8+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dD1cIkl0ZW0gMVwiXHJcbiAgICAgICAgICAgICAgICAgICAgLz5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgPExpc3RJdGVtXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRodW1ibmFpbD17XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8aW1nIHNyYz1cImh0dHBzOi8vcGxhY2VpbWcuY29tLzQwLzQwL3Blb3BsZVwiIC8+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dD1cIkl0ZW0gMlwiXHJcbiAgICAgICAgICAgICAgICAgICAgLz5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgPExpc3RJdGVtXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRodW1ibmFpbD17XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8aW1nIHNyYz1cImh0dHBzOi8vcGxhY2VpbWcuY29tLzQwLzQwL3Blb3BsZVwiIC8+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dD1cIkl0ZW0gM1wiXHJcbiAgICAgICAgICAgICAgICAgICAgLz5cclxuICAgICAgICAgICAgICAgIDwvTGlzdD5cclxuICAgICAgICAgICAgPC9EZW1vPlxyXG5cclxuICAgICAgICAgICAgPERlbW8gdGl0bGU9XCJMaXN0IHdpdGggdmlkZW9zXCI+XHJcbiAgICAgICAgICAgICAgICA8TGlzdD5cclxuICAgICAgICAgICAgICAgICAgICA8TGlzdEl0ZW1cclxuICAgICAgICAgICAgICAgICAgICAgICAgdmlkZW89e1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGltZyBzcmM9XCJodHRwczovL3BsYWNlaW1nLmNvbS8xMDAvNTYvcGVvcGxlXCIgLz5cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0PVwiSXRlbSAxXCJcclxuICAgICAgICAgICAgICAgICAgICAvPlxyXG5cclxuICAgICAgICAgICAgICAgICAgICA8TGlzdEl0ZW1cclxuICAgICAgICAgICAgICAgICAgICAgICAgdmlkZW89e1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGltZyBzcmM9XCJodHRwczovL3BsYWNlaW1nLmNvbS8xMDAvNTYvcGVvcGxlXCIgLz5cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0PVwiSXRlbSAyXCJcclxuICAgICAgICAgICAgICAgICAgICAvPlxyXG5cclxuICAgICAgICAgICAgICAgICAgICA8TGlzdEl0ZW1cclxuICAgICAgICAgICAgICAgICAgICAgICAgdmlkZW89e1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGltZyBzcmM9XCJodHRwczovL3BsYWNlaW1nLmNvbS8xMDAvNTYvcGVvcGxlXCIgLz5cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0PVwiSXRlbSAzXCJcclxuICAgICAgICAgICAgICAgICAgICAvPlxyXG4gICAgICAgICAgICAgICAgPC9MaXN0PlxyXG4gICAgICAgICAgICA8L0RlbW8+XHJcblxyXG4gICAgICAgICAgICA8RGVtbyB0aXRsZT1cIkxpc3Qgd2l0aCBjaGVja2JveGVzXCI+XHJcbiAgICAgICAgICAgICAgICA8TGlzdD5cclxuICAgICAgICAgICAgICAgICAgICA8TGlzdEl0ZW1cclxuICAgICAgICAgICAgICAgICAgICAgICAgbGVhZGluZ0NoZWNrYm94PXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxDaGVja2JveCBkZWZhdWx0Q2hlY2tlZD17ZmFsc2V9IC8+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dD1cIkl0ZW0gMVwiXHJcbiAgICAgICAgICAgICAgICAgICAgLz5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgPExpc3RJdGVtXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlYWRpbmdDaGVja2JveD17XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8Q2hlY2tib3ggZGVmYXVsdENoZWNrZWQ9e2ZhbHNlfSAvPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ9XCJJdGVtIDJcIlxyXG4gICAgICAgICAgICAgICAgICAgIC8+XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIDxMaXN0SXRlbVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZWFkaW5nQ2hlY2tib3g9e1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPENoZWNrYm94IGRlZmF1bHRDaGVja2VkPXtmYWxzZX0gLz5cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0PVwiSXRlbSAzXCJcclxuICAgICAgICAgICAgICAgICAgICAvPlxyXG4gICAgICAgICAgICAgICAgPC9MaXN0PlxyXG4gICAgICAgICAgICA8L0RlbW8+XHJcblxyXG4gICAgICAgICAgICA8RGVtbyB0aXRsZT1cIkxpc3Qgd2l0aCByYWRpb3NcIj5cclxuICAgICAgICAgICAgICAgIDxMaXN0PlxyXG4gICAgICAgICAgICAgICAgICAgIDxMaXN0SXRlbVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZWFkaW5nUmFkaW89e1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPFJhZGlvIC8+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dD1cIkl0ZW0gMVwiXHJcbiAgICAgICAgICAgICAgICAgICAgLz5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgPExpc3RJdGVtXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlYWRpbmdSYWRpbz17XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8UmFkaW8gY2hlY2tlZCAvPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ9XCJJdGVtIDJcIlxyXG4gICAgICAgICAgICAgICAgICAgIC8+XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIDxMaXN0SXRlbVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZWFkaW5nUmFkaW89e1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPFJhZGlvIC8+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dD1cIkl0ZW0gM1wiXHJcbiAgICAgICAgICAgICAgICAgICAgLz5cclxuICAgICAgICAgICAgICAgIDwvTGlzdD5cclxuICAgICAgICAgICAgPC9EZW1vPlxyXG5cclxuICAgICAgICAgICAgPERlbW8gdGl0bGU9XCJMaXN0IHdpdGggc3dpdGNoZXNcIj5cclxuICAgICAgICAgICAgICAgIDxMaXN0PlxyXG4gICAgICAgICAgICAgICAgICAgIDxMaXN0SXRlbVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZWFkaW5nU3dpdGNoPXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxTd2l0Y2ggLz5cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0PVwiSXRlbSAxXCJcclxuICAgICAgICAgICAgICAgICAgICAvPlxyXG5cclxuICAgICAgICAgICAgICAgICAgICA8TGlzdEl0ZW1cclxuICAgICAgICAgICAgICAgICAgICAgICAgbGVhZGluZ1N3aXRjaD17XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8U3dpdGNoIGNoZWNrZWQgLz5cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0PVwiSXRlbSAyXCJcclxuICAgICAgICAgICAgICAgICAgICAvPlxyXG5cclxuICAgICAgICAgICAgICAgICAgICA8TGlzdEl0ZW1cclxuICAgICAgICAgICAgICAgICAgICAgICAgbGVhZGluZ1N3aXRjaD17XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8U3dpdGNoIC8+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dD1cIkl0ZW0gM1wiXHJcbiAgICAgICAgICAgICAgICAgICAgLz5cclxuICAgICAgICAgICAgICAgIDwvTGlzdD5cclxuICAgICAgICAgICAgPC9EZW1vPlxyXG5cclxuICAgICAgICAgICAgPERlbW8gdGl0bGU9XCJMaXN0IHdpdGggdHJhaWxpbmcgaWNvbnNcIj5cclxuICAgICAgICAgICAgICAgIDxMaXN0PlxyXG4gICAgICAgICAgICAgICAgICAgIDxMaXN0SXRlbVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0PVwiSXRlbSAxXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgdHJhaWxpbmdJY29uPVwiaW5mb1wiXHJcbiAgICAgICAgICAgICAgICAgICAgLz5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgPExpc3RJdGVtXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ9XCJJdGVtIDJcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0cmFpbGluZ0ljb249XCJpbmZvXCJcclxuICAgICAgICAgICAgICAgICAgICAvPlxyXG5cclxuICAgICAgICAgICAgICAgICAgICA8TGlzdEl0ZW1cclxuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dD1cIkl0ZW0gM1wiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYWlsaW5nSWNvbj1cImluZm9cIlxyXG4gICAgICAgICAgICAgICAgICAgIC8+XHJcbiAgICAgICAgICAgICAgICA8L0xpc3Q+XHJcbiAgICAgICAgICAgIDwvRGVtbz5cclxuXHJcbiAgICAgICAgICAgIDxEZW1vIHRpdGxlPVwiTGlzdCB3aXRoIHRyYWlsaW5nIG1ldGFcIj5cclxuICAgICAgICAgICAgICAgIDxMaXN0PlxyXG4gICAgICAgICAgICAgICAgICAgIDxMaXN0SXRlbVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0PVwiSXRlbSAxXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWV0YT1cIk1ldGFcIlxyXG4gICAgICAgICAgICAgICAgICAgIC8+XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIDxMaXN0SXRlbVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0PVwiSXRlbSAyXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWV0YT1cIk1ldGFcIlxyXG4gICAgICAgICAgICAgICAgICAgIC8+XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIDxMaXN0SXRlbVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0PVwiSXRlbSAzXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWV0YT1cIk1ldGFcIlxyXG4gICAgICAgICAgICAgICAgICAgIC8+XHJcbiAgICAgICAgICAgICAgICA8L0xpc3Q+XHJcbiAgICAgICAgICAgIDwvRGVtbz5cclxuXHJcbiAgICAgICAgICAgIDxEZW1vIHRpdGxlPVwiTGlzdCB3aXRoIHRyYWlsaW5nIGNoZWNrYm94ZXNcIj5cclxuICAgICAgICAgICAgICAgIDxMaXN0PlxyXG4gICAgICAgICAgICAgICAgICAgIDxMaXN0SXRlbVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0PVwiSXRlbSAxXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgdHJhaWxpbmdDaGVja2JveD17XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8Q2hlY2tib3ggLz5cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIC8+XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIDxMaXN0SXRlbVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0PVwiSXRlbSAyXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgdHJhaWxpbmdDaGVja2JveD17XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8Q2hlY2tib3ggY2hlY2tlZCAvPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgLz5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgPExpc3RJdGVtXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ9XCJJdGVtIDNcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0cmFpbGluZ0NoZWNrYm94PXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxDaGVja2JveCAvPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgLz5cclxuICAgICAgICAgICAgICAgIDwvTGlzdD5cclxuICAgICAgICAgICAgPC9EZW1vPlxyXG5cclxuICAgICAgICAgICAgPERlbW8gdGl0bGU9XCJMaXN0IHdpdGggdHJhaWxpbmcgcmFkaW9zXCI+XHJcbiAgICAgICAgICAgICAgICA8TGlzdD5cclxuICAgICAgICAgICAgICAgICAgICA8TGlzdEl0ZW1cclxuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dD1cIkl0ZW0gMVwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYWlsaW5nUmFkaW89e1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPFJhZGlvIC8+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAvPlxyXG5cclxuICAgICAgICAgICAgICAgICAgICA8TGlzdEl0ZW1cclxuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dD1cIkl0ZW0gMlwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYWlsaW5nUmFkaW89e1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPFJhZGlvIGNoZWNrZWQgLz5cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIC8+XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIDxMaXN0SXRlbVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0PVwiSXRlbSAzXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgdHJhaWxpbmdSYWRpbz17XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8UmFkaW8gLz5cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIC8+XHJcbiAgICAgICAgICAgICAgICA8L0xpc3Q+XHJcbiAgICAgICAgICAgIDwvRGVtbz5cclxuXHJcbiAgICAgICAgICAgIDxEZW1vIHRpdGxlPVwiTGlzdCB3aXRoIHRyYWlsaW5nIHN3aXRjaGVzXCI+XHJcbiAgICAgICAgICAgICAgICA8TGlzdD5cclxuICAgICAgICAgICAgICAgICAgICA8TGlzdEl0ZW1cclxuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dD1cIkl0ZW0gMVwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYWlsaW5nU3dpdGNoPXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxTd2l0Y2ggLz5cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIC8+XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIDxMaXN0SXRlbVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0PVwiSXRlbSAyXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgdHJhaWxpbmdTd2l0Y2g9e1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPFN3aXRjaCBzZWxlY3RlZCAvPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgLz5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgPExpc3RJdGVtXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ9XCJJdGVtIDNcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0cmFpbGluZ1N3aXRjaD17XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8U3dpdGNoIC8+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAvPlxyXG4gICAgICAgICAgICAgICAgPC9MaXN0PlxyXG4gICAgICAgICAgICA8L0RlbW8+XHJcbiAgICAgICAgPC9QYWdlPlxyXG4gICAgKTtcclxufSIsImltcG9ydCB7IHVzZUNhbGxiYWNrLCB1c2VTdGF0ZSB9IGZyb20gJ3JlYWN0JztcclxuaW1wb3J0IHtcclxuICAgIEJ1dHRvbixcclxuICAgIERpYWxvZyxcclxuICAgIEZvcm1GaWVsZCxcclxuICAgIE1lbnUsXHJcbiAgICBSYWRpb1xyXG59IGZyb20gJ21kYy1yZWFjdCc7XHJcblxyXG5pbXBvcnQgRGVtbyBmcm9tICdAL2NvbXBvbmVudHMvRGVtbyc7XHJcbmltcG9ydCBGaWVsZFNldCBmcm9tICdAL2NvbXBvbmVudHMvRmllbGRTZXQnO1xyXG5pbXBvcnQgUGFnZSBmcm9tICdAL2NvbXBvbmVudHMvUGFnZSc7XHJcblxyXG5pbXBvcnQgJy4vaW5kZXguc2Nzcyc7XHJcblxyXG5jb25zdCBpZCA9ICdtZW51JztcclxuY29uc3QgdGl0bGUgPSAnTWVudSc7XHJcbmNvbnN0IGRlc2NyaXB0aW9uID0gJ01lbnVzIGRpc3BsYXkgYSBsaXN0IG9mIGNob2ljZXMgb24gdGVtcG9yYXJ5IHN1cmZhY2VzLic7XHJcbmNvbnN0IGxpbmtzID0ge1xyXG4gICAgZG9jczogJ2h0dHBzOi8vZ2l0aHViLmNvbS9tYXRlcmlhbC1jb21wb25lbnRzL21hdGVyaWFsLWNvbXBvbmVudHMtd2ViL3RyZWUvbWFzdGVyL3BhY2thZ2VzL21kYy1tZW51JyxcclxuICAgIGd1aWRlOiAnaHR0cHM6Ly9tYXRlcmlhbC5pby9jb21wb25lbnRzL21lbnVzJ1xyXG59O1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gTWVudVBhZ2UoKSB7XHJcbiAgICBjb25zdCBbaXNCYXNpY09wZW4sIHNldEJhc2ljT3Blbl0gPSB1c2VTdGF0ZShmYWxzZSk7XHJcbiAgICBjb25zdCBbaXNRdWlja09wZW4sIHNldFF1aWNrT3Blbl0gPSB1c2VTdGF0ZShmYWxzZSk7XHJcbiAgICBjb25zdCBbaXNQZXJzaXN0ZW50T3Blbiwgc2V0UGVyc2lzdGVudE9wZW5dID0gdXNlU3RhdGUoZmFsc2UpO1xyXG4gICAgY29uc3QgW2lzQW5jaG9yZWRPcGVuLCBzZXRBbmNob3JlZE9wZW5dID0gdXNlU3RhdGUoZmFsc2UpO1xyXG4gICAgY29uc3QgW2FuY2hvclBvc2l0aW9uLCBzZXRBbmNob3JQb3NpdGlvbl0gPSB1c2VTdGF0ZShNZW51Lk9yaWdpbi5UT1BfTEVGVCk7XHJcbiAgICBjb25zdCBbYW5jaG9yT3JpZ2luLCBzZXRBbmNob3JPcmlnaW5dID0gdXNlU3RhdGUoTWVudS5PcmlnaW4uVE9QX0xFRlQpO1xyXG4gICAgY29uc3QgW3RyYW5zZm9ybU9yaWdpbiwgc2V0VHJhbnNmb3JtT3JpZ2luXSA9IHVzZVN0YXRlKE1lbnUuT3JpZ2luLlRPUF9MRUZUKTtcclxuICAgIGNvbnN0IFtpc01vZGFsT3Blbiwgc2V0TW9kYWxPcGVuXSA9IHVzZVN0YXRlKGZhbHNlKTtcclxuICAgIGNvbnN0IFtpc0RpYWxvZ09wZW4sIHNldERpYWxvZ09wZW5dID0gdXNlU3RhdGUoZmFsc2UpO1xyXG5cclxuICAgIGNvbnN0IGhhbmRsZUFuY2hvclBvc2l0aW9uQ2hhbmdlID0gdXNlQ2FsbGJhY2soKGV2ZW50LCB2YWx1ZSkgPT4ge1xyXG4gICAgICAgIHNldEFuY2hvclBvc2l0aW9uKHZhbHVlKTtcclxuICAgIH0sIFtdKTtcclxuXHJcbiAgICBjb25zdCBoYW5kbGVBbmNob3JPcmlnaW5DaGFuZ2UgPSB1c2VDYWxsYmFjaygoZXZlbnQsIHZhbHVlKSA9PiB7XHJcbiAgICAgICAgc2V0QW5jaG9yT3JpZ2luKHZhbHVlKTtcclxuICAgIH0sIFtdKTtcclxuXHJcbiAgICBjb25zdCBoYW5kbGVUcmFuc2Zvcm1PcmlnaW5DaGFuZ2UgPSB1c2VDYWxsYmFjaygoZXZlbnQsIHZhbHVlKSA9PiB7XHJcbiAgICAgICAgc2V0VHJhbnNmb3JtT3JpZ2luKHZhbHVlKTtcclxuICAgIH0sIFtdKTtcclxuXHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAgIDxQYWdlIGlkPXtpZH0gdGl0bGU9e3RpdGxlfSBkZXNjcmlwdGlvbj17ZGVzY3JpcHRpb259IGxpbmtzPXtsaW5rc30+XHJcbiAgICAgICAgICAgIDxEZW1vIHRpdGxlPVwiQmFzaWMgbWVudVwiPlxyXG4gICAgICAgICAgICAgICAgPE1lbnVcclxuICAgICAgICAgICAgICAgICAgICBhbmNob3I9e1xyXG4gICAgICAgICAgICAgICAgICAgICAgICA8QnV0dG9uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYWJlbD1cIk9wZW5cIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0bGluZWRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2xpY2s9eygpID0+IHNldEJhc2ljT3Blbih0cnVlKX1cclxuICAgICAgICAgICAgICAgICAgICAgICAgLz5cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgb3Blbj17aXNCYXNpY09wZW59XHJcbiAgICAgICAgICAgICAgICAgICAgb25DbG9zZT17KCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRCYXNpY09wZW4oZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgICAgIH19XHJcbiAgICAgICAgICAgICAgICA+XHJcbiAgICAgICAgICAgICAgICAgICAgPE1lbnUuSXRlbVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0PVwiRm9vXCJcclxuICAgICAgICAgICAgICAgICAgICAvPlxyXG5cclxuICAgICAgICAgICAgICAgICAgICA8TWVudS5JdGVtXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ9XCJCYXJcIlxyXG4gICAgICAgICAgICAgICAgICAgIC8+XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIDxNZW51Lkl0ZW1cclxuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dD1cIkJhelwiXHJcbiAgICAgICAgICAgICAgICAgICAgLz5cclxuICAgICAgICAgICAgICAgIDwvTWVudT5cclxuICAgICAgICAgICAgPC9EZW1vPlxyXG5cclxuICAgICAgICAgICAgPERlbW8gdGl0bGU9XCJRdWljayBtZW51XCI+XHJcbiAgICAgICAgICAgICAgICA8TWVudVxyXG4gICAgICAgICAgICAgICAgICAgIGFuY2hvcj17XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxCdXR0b25cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsPVwiT3BlblwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRsaW5lZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb25DbGljaz17KCkgPT4gc2V0UXVpY2tPcGVuKHRydWUpfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvPlxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBvcGVuPXtpc1F1aWNrT3Blbn1cclxuICAgICAgICAgICAgICAgICAgICBxdWlja1xyXG4gICAgICAgICAgICAgICAgICAgIG9uQ2xvc2U9eygpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2V0UXVpY2tPcGVuKGZhbHNlKTtcclxuICAgICAgICAgICAgICAgICAgICB9fVxyXG4gICAgICAgICAgICAgICAgPlxyXG4gICAgICAgICAgICAgICAgICAgIDxNZW51Lkl0ZW1cclxuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dD1cIkZvb1wiXHJcbiAgICAgICAgICAgICAgICAgICAgLz5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgPE1lbnUuSXRlbVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0PVwiQmFyXCJcclxuICAgICAgICAgICAgICAgICAgICAvPlxyXG5cclxuICAgICAgICAgICAgICAgICAgICA8TWVudS5JdGVtXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ9XCJCYXpcIlxyXG4gICAgICAgICAgICAgICAgICAgIC8+XHJcbiAgICAgICAgICAgICAgICA8L01lbnU+XHJcbiAgICAgICAgICAgIDwvRGVtbz5cclxuXHJcbiAgICAgICAgICAgIDxEZW1vIHRpdGxlPVwiUGVyc2lzdGVudCBtZW51XCI+XHJcbiAgICAgICAgICAgICAgICA8TWVudVxyXG4gICAgICAgICAgICAgICAgICAgIGFuY2hvcj17XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxCdXR0b25cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsPVwiT3BlblwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRsaW5lZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb25DbGljaz17KCkgPT4gc2V0UGVyc2lzdGVudE9wZW4odiA9PiAhdil9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8+XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIG9wZW49e2lzUGVyc2lzdGVudE9wZW59XHJcbiAgICAgICAgICAgICAgICAgICAgcGVyc2lzdGVudFxyXG4gICAgICAgICAgICAgICAgPlxyXG4gICAgICAgICAgICAgICAgICAgIDxNZW51Lkl0ZW1cclxuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dD1cIkZvb1wiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2xpY2s9eygpID0+IHNldFBlcnNpc3RlbnRPcGVuKGZhbHNlKX1cclxuICAgICAgICAgICAgICAgICAgICAvPlxyXG5cclxuICAgICAgICAgICAgICAgICAgICA8TWVudS5JdGVtXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ9XCJCYXJcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBvbkNsaWNrPXsoKSA9PiBzZXRQZXJzaXN0ZW50T3BlbihmYWxzZSl9XHJcbiAgICAgICAgICAgICAgICAgICAgLz5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgPE1lbnUuSXRlbVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0PVwiQmF6XCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgb25DbGljaz17KCkgPT4gc2V0UGVyc2lzdGVudE9wZW4oZmFsc2UpfVxyXG4gICAgICAgICAgICAgICAgICAgIC8+XHJcbiAgICAgICAgICAgICAgICA8L01lbnU+XHJcbiAgICAgICAgICAgIDwvRGVtbz5cclxuXHJcbiAgICAgICAgICAgIDxEZW1vIGlkPVwibWVudS1vcmlnaW5cIiBjbGFzc05hbWU9e2BvcmlnaW4tLSR7YW5jaG9yUG9zaXRpb24ucmVwbGFjZSgnICcsICctJyl9YH0gdGl0bGU9XCJNZW51IG9yaWdpblwiXHJcbiAgICAgICAgICAgICAgICBzZXR0aW5ncz17PD5cclxuICAgICAgICAgICAgICAgICAgICA8RmllbGRTZXQgbGVnZW5kPVwiQW5jaG9yIHBvc2l0aW9uXCI+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxGb3JtRmllbGQgbGFiZWw9XCJUb3AgbGVmdFwiPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPFJhZGlvXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU9e01lbnUuT3JpZ2luLlRPUF9MRUZUfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoZWNrZWQ9e2FuY2hvclBvc2l0aW9uID09PSBNZW51Lk9yaWdpbi5UT1BfTEVGVH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbkNoYW5nZT17aGFuZGxlQW5jaG9yUG9zaXRpb25DaGFuZ2V9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8L0Zvcm1GaWVsZD5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxGb3JtRmllbGQgbGFiZWw9XCJUb3AgcmlnaHRcIj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxSYWRpb1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlPXtNZW51Lk9yaWdpbi5UT1BfUklHSFR9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hlY2tlZD17YW5jaG9yUG9zaXRpb24gPT09IE1lbnUuT3JpZ2luLlRPUF9SSUdIVH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbkNoYW5nZT17aGFuZGxlQW5jaG9yUG9zaXRpb25DaGFuZ2V9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8L0Zvcm1GaWVsZD5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxGb3JtRmllbGQgbGFiZWw9XCJCb3R0b20gbGVmdFwiPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPFJhZGlvXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU9e01lbnUuT3JpZ2luLkJPVFRPTV9MRUZUfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoZWNrZWQ9e2FuY2hvclBvc2l0aW9uID09PSBNZW51Lk9yaWdpbi5CT1RUT01fTEVGVH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbkNoYW5nZT17aGFuZGxlQW5jaG9yUG9zaXRpb25DaGFuZ2V9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8L0Zvcm1GaWVsZD5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxGb3JtRmllbGQgbGFiZWw9XCJCb3R0b20gcmlnaHRcIj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxSYWRpb1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlPXtNZW51Lk9yaWdpbi5CT1RUT01fUklHSFR9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hlY2tlZD17YW5jaG9yUG9zaXRpb24gPT09IE1lbnUuT3JpZ2luLkJPVFRPTV9SSUdIVH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbkNoYW5nZT17aGFuZGxlQW5jaG9yUG9zaXRpb25DaGFuZ2V9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8L0Zvcm1GaWVsZD5cclxuICAgICAgICAgICAgICAgICAgICA8L0ZpZWxkU2V0PlxyXG5cclxuICAgICAgICAgICAgICAgICAgICA8RmllbGRTZXQgbGVnZW5kPVwiQW5jaG9yIG9yaWdpblwiPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8Rm9ybUZpZWxkIGxhYmVsPVwiVG9wIGxlZnRcIj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxSYWRpb1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlPXtNZW51Lk9yaWdpbi5UT1BfTEVGVH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGVja2VkPXthbmNob3JPcmlnaW4gPT09IE1lbnUuT3JpZ2luLlRPUF9MRUZUfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2hhbmdlPXtoYW5kbGVBbmNob3JPcmlnaW5DaGFuZ2V9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8L0Zvcm1GaWVsZD5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxGb3JtRmllbGQgbGFiZWw9XCJUb3AgcmlnaHRcIj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxSYWRpb1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlPXtNZW51Lk9yaWdpbi5UT1BfUklHSFR9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hlY2tlZD17YW5jaG9yT3JpZ2luID09PSBNZW51Lk9yaWdpbi5UT1BfUklHSFR9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb25DaGFuZ2U9e2hhbmRsZUFuY2hvck9yaWdpbkNoYW5nZX1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDwvRm9ybUZpZWxkPlxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPEZvcm1GaWVsZCBsYWJlbD1cIkJvdHRvbSBsZWZ0XCI+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8UmFkaW9cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZT17TWVudS5PcmlnaW4uQk9UVE9NX0xFRlR9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hlY2tlZD17YW5jaG9yT3JpZ2luID09PSBNZW51Lk9yaWdpbi5CT1RUT01fTEVGVH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbkNoYW5nZT17aGFuZGxlQW5jaG9yT3JpZ2luQ2hhbmdlfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLz5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPC9Gb3JtRmllbGQ+XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8Rm9ybUZpZWxkIGxhYmVsPVwiQm90dG9tIHJpZ2h0XCI+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8UmFkaW9cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZT17TWVudS5PcmlnaW4uQk9UVE9NX1JJR0hUfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoZWNrZWQ9e2FuY2hvck9yaWdpbiA9PT0gTWVudS5PcmlnaW4uQk9UVE9NX1JJR0hUfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2hhbmdlPXtoYW5kbGVBbmNob3JPcmlnaW5DaGFuZ2V9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8L0Zvcm1GaWVsZD5cclxuICAgICAgICAgICAgICAgICAgICA8L0ZpZWxkU2V0PlxyXG5cclxuICAgICAgICAgICAgICAgICAgICA8RmllbGRTZXQgbGVnZW5kPVwiVHJhbnNmb3JtIG9yaWdpblwiPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8Rm9ybUZpZWxkIGxhYmVsPVwiVG9wIGxlZnRcIj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxSYWRpb1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlPXtNZW51Lk9yaWdpbi5UT1BfTEVGVH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGVja2VkPXt0cmFuc2Zvcm1PcmlnaW4gPT09IE1lbnUuT3JpZ2luLlRPUF9MRUZUfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2hhbmdlPXtoYW5kbGVUcmFuc2Zvcm1PcmlnaW5DaGFuZ2V9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8L0Zvcm1GaWVsZD5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxGb3JtRmllbGQgbGFiZWw9XCJUb3AgcmlnaHRcIj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxSYWRpb1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlPXtNZW51Lk9yaWdpbi5UT1BfUklHSFR9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hlY2tlZD17dHJhbnNmb3JtT3JpZ2luID09PSBNZW51Lk9yaWdpbi5UT1BfUklHSFR9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb25DaGFuZ2U9e2hhbmRsZVRyYW5zZm9ybU9yaWdpbkNoYW5nZX1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDwvRm9ybUZpZWxkPlxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPEZvcm1GaWVsZCBsYWJlbD1cIkJvdHRvbSBsZWZ0XCI+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8UmFkaW9cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZT17TWVudS5PcmlnaW4uQk9UVE9NX0xFRlR9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hlY2tlZD17dHJhbnNmb3JtT3JpZ2luID09PSBNZW51Lk9yaWdpbi5CT1RUT01fTEVGVH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbkNoYW5nZT17aGFuZGxlVHJhbnNmb3JtT3JpZ2luQ2hhbmdlfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLz5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPC9Gb3JtRmllbGQ+XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8Rm9ybUZpZWxkIGxhYmVsPVwiQm90dG9tIHJpZ2h0XCI+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8UmFkaW9cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZT17TWVudS5PcmlnaW4uQk9UVE9NX1JJR0hUfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoZWNrZWQ9e3RyYW5zZm9ybU9yaWdpbiA9PT0gTWVudS5PcmlnaW4uQk9UVE9NX1JJR0hUfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2hhbmdlPXtoYW5kbGVUcmFuc2Zvcm1PcmlnaW5DaGFuZ2V9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8L0Zvcm1GaWVsZD5cclxuICAgICAgICAgICAgICAgICAgICA8L0ZpZWxkU2V0PlxyXG4gICAgICAgICAgICAgICAgPC8+fVxyXG4gICAgICAgICAgICA+XHJcbiAgICAgICAgICAgICAgICA8TWVudVxyXG4gICAgICAgICAgICAgICAgICAgIGFuY2hvcj17XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxCdXR0b25cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsPXtpc1BlcnNpc3RlbnRPcGVuID8gJ0Nsb3NlJyA6ICdPcGVuJ31cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dGxpbmVkXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbkNsaWNrPXsoKSA9PiBzZXRBbmNob3JlZE9wZW4odiA9PiAhdil9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8+XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGFuY2hvck9yaWdpbj17YW5jaG9yT3JpZ2lufVxyXG4gICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybU9yaWdpbj17dHJhbnNmb3JtT3JpZ2lufVxyXG4gICAgICAgICAgICAgICAgICAgIG9wZW49e2lzQW5jaG9yZWRPcGVufVxyXG4gICAgICAgICAgICAgICAgICAgIG9uQ2xvc2U9eygpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2V0QW5jaG9yZWRPcGVuKGZhbHNlKTtcclxuICAgICAgICAgICAgICAgICAgICB9fVxyXG4gICAgICAgICAgICAgICAgPlxyXG4gICAgICAgICAgICAgICAgICAgIDxNZW51Lkl0ZW1cclxuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dD1cIkZvb1wiXHJcbiAgICAgICAgICAgICAgICAgICAgLz5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgPE1lbnUuSXRlbVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0PVwiQmFyXCJcclxuICAgICAgICAgICAgICAgICAgICAvPlxyXG5cclxuICAgICAgICAgICAgICAgICAgICA8TWVudS5JdGVtXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ9XCJCYXpcIlxyXG4gICAgICAgICAgICAgICAgICAgIC8+XHJcbiAgICAgICAgICAgICAgICA8L01lbnU+XHJcbiAgICAgICAgICAgIDwvRGVtbz5cclxuXHJcbiAgICAgICAgICAgIDxEZW1vXHJcbiAgICAgICAgICAgICAgICB0aXRsZT1cIk1vZGFsIG1lbnVcIlxyXG4gICAgICAgICAgICAgICAgc2V0dXA9ezxCdXR0b24gb25DbGljaz17KCkgPT4gc2V0RGlhbG9nT3Blbih2ID0+ICF2KX0+T3BlbiBEaWFsb2c8L0J1dHRvbj59XHJcbiAgICAgICAgICAgID5cclxuICAgICAgICAgICAgICAgIDxEaWFsb2dcclxuICAgICAgICAgICAgICAgICAgICB0aXRsZT1cIkRpYWxvZ1wiXHJcbiAgICAgICAgICAgICAgICAgICAgb3Blbj17aXNEaWFsb2dPcGVufVxyXG4gICAgICAgICAgICAgICAgICAgIG9uQ2xvc2U9eygpID0+IHNldERpYWxvZ09wZW4odiA9PiAhdil9XHJcbiAgICAgICAgICAgICAgICA+XHJcbiAgICAgICAgICAgICAgICAgICAgPERpYWxvZy5Db250ZW50PlxyXG5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxNZW51XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbmNob3I9e1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxCdXR0b25cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWw9e2lzUGVyc2lzdGVudE9wZW4gPyAnQ2xvc2UnIDogJ09wZW4nfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRsaW5lZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbkNsaWNrPXsoKSA9PiBzZXRNb2RhbE9wZW4odiA9PiAhdil9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLz5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wZW49e2lzTW9kYWxPcGVufVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbW9kYWxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2xvc2U9eygpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRNb2RhbE9wZW4oZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfX1cclxuICAgICAgICAgICAgICAgICAgICAgICAgPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPE1lbnUuSXRlbVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ9XCJGb29cIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLz5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8TWVudS5JdGVtXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dD1cIkJhclwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvPlxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxNZW51Lkl0ZW1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0PVwiQmF6XCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDwvTWVudT5cclxuICAgICAgICAgICAgICAgICAgICA8L0RpYWxvZy5Db250ZW50PlxyXG4gICAgICAgICAgICAgICAgPC9EaWFsb2c+XHJcbiAgICAgICAgICAgIDwvRGVtbz5cclxuICAgICAgICA8L1BhZ2U+XHJcbiAgICApO1xyXG59IiwiaW1wb3J0IHsgdXNlQ2FsbGJhY2ssIHVzZVN0YXRlIH0gZnJvbSAncmVhY3QnO1xyXG5pbXBvcnQge1xyXG4gICAgRm9ybUZpZWxkLFxyXG4gICAgUmFkaW9cclxufSBmcm9tICdtZGMtcmVhY3QnO1xyXG5cclxuaW1wb3J0IERlbW8gZnJvbSAnQC9jb21wb25lbnRzL0RlbW8nO1xyXG5pbXBvcnQgUGFnZSBmcm9tICdAL2NvbXBvbmVudHMvUGFnZSc7XHJcblxyXG5jb25zdCBpZCA9ICdyYWRpbyc7XHJcbmNvbnN0IHRpdGxlID0gJ1JhZGlvJztcclxuY29uc3QgZGVzY3JpcHRpb24gPSAnUmFkaW8gYnV0dG9ucyBhbGxvdyB1c2VycyB0byBzZWxlY3Qgb25lIG9wdGlvbiBmcm9tIGEgc2V0Lic7XHJcbmNvbnN0IGxpbmtzID0ge1xyXG4gICAgZG9jczogJ2h0dHBzOi8vZ2l0aHViLmNvbS9tYXRlcmlhbC1jb21wb25lbnRzL21hdGVyaWFsLWNvbXBvbmVudHMtd2ViL3RyZWUvbWFzdGVyL3BhY2thZ2VzL21kYy1yYWRpbycsXHJcbiAgICBndWlkZTogJ2h0dHBzOi8vbWF0ZXJpYWwuaW8vY29tcG9uZW50cy9yYWRpby1idXR0b25zJ1xyXG59O1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gUmFkaW9QYWdlKCkge1xyXG4gICAgY29uc3QgW3ZhbHVlMSwgc2V0VmFsdWUxXSA9IHVzZVN0YXRlKCd5ZXMnKTtcclxuICAgIGNvbnN0IFt2YWx1ZTIsIHNldFZhbHVlMl0gPSB1c2VTdGF0ZSgneWVzJyk7XHJcblxyXG4gICAgY29uc3QgaGFuZGxlQ2hhbmdlMSA9IHVzZUNhbGxiYWNrKChldmVudCwgdmFsdWUpID0+IHtcclxuICAgICAgICBzZXRWYWx1ZTEodmFsdWUpO1xyXG4gICAgfSwgW10pO1xyXG5cclxuICAgIGNvbnN0IGhhbmRsZUNoYW5nZTIgPSB1c2VDYWxsYmFjaygoZXZlbnQsIHZhbHVlKSA9PiB7XHJcbiAgICAgICAgc2V0VmFsdWUyKHZhbHVlKTtcclxuICAgIH0sIFtdKTtcclxuXHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAgIDxQYWdlIGlkPXtpZH0gdGl0bGU9e3RpdGxlfSBkZXNjcmlwdGlvbj17ZGVzY3JpcHRpb259IGxpbmtzPXtsaW5rc30+XHJcbiAgICAgICAgICAgIDxEZW1vIHRpdGxlPVwiQmFzaWMgcmFkaW9cIj5cclxuICAgICAgICAgICAgICAgIDxGb3JtRmllbGQgbGFiZWw9XCJZZXNcIj5cclxuICAgICAgICAgICAgICAgICAgICA8UmFkaW9cclxuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZT1cImFuc3dlcjFcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZT1cInllc1wiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoZWNrZWQ9e3ZhbHVlMSA9PT0gJ3llcyd9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2hhbmdlPXtoYW5kbGVDaGFuZ2UxfVxyXG4gICAgICAgICAgICAgICAgICAgIC8+XHJcbiAgICAgICAgICAgICAgICA8L0Zvcm1GaWVsZD5cclxuXHJcbiAgICAgICAgICAgICAgICA8Rm9ybUZpZWxkIGxhYmVsPVwiTm9cIj5cclxuICAgICAgICAgICAgICAgICAgICA8UmFkaW9cclxuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZT1cImFuc3dlcjFcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZT1cIm5vXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2hlY2tlZD17dmFsdWUxID09PSAnbm8nfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBvbkNoYW5nZT17aGFuZGxlQ2hhbmdlMX1cclxuICAgICAgICAgICAgICAgICAgICAvPlxyXG4gICAgICAgICAgICAgICAgPC9Gb3JtRmllbGQ+XHJcblxyXG4gICAgICAgICAgICAgICAgPEZvcm1GaWVsZCBsYWJlbD1cIk1heWJlXCI+XHJcbiAgICAgICAgICAgICAgICAgICAgPFJhZGlvXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU9XCJhbnN3ZXIxXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU9XCJtYXliZVwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoZWNrZWQ9e3ZhbHVlMSA9PT0gJ21heWJlJ31cclxuICAgICAgICAgICAgICAgICAgICAgICAgb25DaGFuZ2U9e2hhbmRsZUNoYW5nZTF9XHJcbiAgICAgICAgICAgICAgICAgICAgLz5cclxuICAgICAgICAgICAgICAgIDwvRm9ybUZpZWxkPlxyXG4gICAgICAgICAgICA8L0RlbW8+XHJcblxyXG4gICAgICAgICAgICA8RGVtbyB0aXRsZT1cIkRpc2FibGVkIHJhZGlvXCI+XHJcbiAgICAgICAgICAgICAgICA8Rm9ybUZpZWxkIGxhYmVsPVwiWWVzXCI+XHJcbiAgICAgICAgICAgICAgICAgICAgPFJhZGlvXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU9XCJhbnN3ZXIyXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU9XCJ5ZXNcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjaGVja2VkPXt2YWx1ZTIgPT09ICd5ZXMnfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBvbkNoYW5nZT17aGFuZGxlQ2hhbmdlMn1cclxuICAgICAgICAgICAgICAgICAgICAvPlxyXG4gICAgICAgICAgICAgICAgPC9Gb3JtRmllbGQ+XHJcblxyXG4gICAgICAgICAgICAgICAgPEZvcm1GaWVsZCBsYWJlbD1cIk5vXCI+XHJcbiAgICAgICAgICAgICAgICAgICAgPFJhZGlvXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU9XCJhbnN3ZXIyXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU9XCJub1wiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoZWNrZWQ9e3ZhbHVlMiA9PT0gJ25vJ31cclxuICAgICAgICAgICAgICAgICAgICAgICAgb25DaGFuZ2U9e2hhbmRsZUNoYW5nZTJ9XHJcbiAgICAgICAgICAgICAgICAgICAgLz5cclxuICAgICAgICAgICAgICAgIDwvRm9ybUZpZWxkPlxyXG5cclxuICAgICAgICAgICAgICAgIDxGb3JtRmllbGQgbGFiZWw9XCJNYXliZVwiPlxyXG4gICAgICAgICAgICAgICAgICAgIDxSYWRpb1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lPVwiYW5zd2VyMlwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlPVwibWF5YmVcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjaGVja2VkPXt2YWx1ZTIgPT09ICdtYXliZSd9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpc2FibGVkXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2hhbmdlPXtoYW5kbGVDaGFuZ2UyfVxyXG4gICAgICAgICAgICAgICAgICAgIC8+XHJcbiAgICAgICAgICAgICAgICA8L0Zvcm1GaWVsZD5cclxuICAgICAgICAgICAgPC9EZW1vPlxyXG4gICAgICAgIDwvUGFnZT5cclxuICAgICk7XHJcbn0iLCJpbXBvcnQge1xyXG4gICAgRWxldmF0aW9uLFxyXG4gICAgUmlwcGxlU3VyZmFjZVxyXG59IGZyb20gJ21kYy1yZWFjdCc7XHJcblxyXG5pbXBvcnQgRGVtbyBmcm9tICdAL2NvbXBvbmVudHMvRGVtbyc7XHJcbmltcG9ydCBQYWdlIGZyb20gJ0AvY29tcG9uZW50cy9QYWdlJztcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIFJhZGlvUGFnZSgpIHtcclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgPFBhZ2UgdGl0bGU9XCJSaXBwbGVcIj5cclxuICAgICAgICAgICAgPERlbW8gdGl0bGU9XCJCYXNpYyByaXBwbGVcIj5cclxuICAgICAgICAgICAgICAgIDxFbGV2YXRpb24gej1cIjVcIj5cclxuICAgICAgICAgICAgICAgICAgICA8UmlwcGxlU3VyZmFjZSBzdHlsZT17eyBoZWlnaHQ6ICcxMDBweCcgfX0gLz5cclxuICAgICAgICAgICAgICAgIDwvRWxldmF0aW9uPlxyXG4gICAgICAgICAgICA8L0RlbW8+XHJcbiAgICAgICAgPC9QYWdlPlxyXG4gICAgKTtcclxufSIsImltcG9ydCB7IHVzZVN0YXRlIH0gZnJvbSAncmVhY3QnO1xyXG5pbXBvcnQge1xyXG4gICAgU2VnbWVudGVkQnV0dG9uXHJcbn0gZnJvbSAnbWRjLXJlYWN0JztcclxuXHJcbmltcG9ydCBEZW1vIGZyb20gJ0AvY29tcG9uZW50cy9EZW1vJztcclxuaW1wb3J0IFBhZ2UgZnJvbSAnQC9jb21wb25lbnRzL1BhZ2UnO1xyXG5cclxuY29uc3QgaWQgPSAnc2VnbWVudGVkLWJ1dHRvbic7XHJcbmNvbnN0IHRpdGxlID0gJ1NlZ21lbnRlZCBCdXR0b24nO1xyXG5jb25zdCBkZXNjcmlwdGlvbiA9ICdTZWdtZW50ZWQgYnV0dG9ucyBhbGxvdyB1c2VycyB0byB0b2dnbGUgdGhlIHNlbGVjdGVkIHN0YXRlcyBvZiBncm91cGVkIGJ1dHRvbnMuJztcclxuY29uc3QgbGlua3MgPSB7XHJcbiAgICBkb2NzOiAnaHR0cHM6Ly9naXRodWIuY29tL21hdGVyaWFsLWNvbXBvbmVudHMvbWF0ZXJpYWwtY29tcG9uZW50cy13ZWIvdHJlZS9tYXN0ZXIvcGFja2FnZXMvbWRjLXNlZ21lbnRlZC1idXR0b24nLFxyXG4gICAgZ3VpZGU6ICdodHRwczovL21hdGVyaWFsLmlvL2NvbXBvbmVudHMvYnV0dG9ucyN0b2dnbGUtYnV0dG9uJ1xyXG59O1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gU2VnbWVudGVkQnV0dG9uUGFnZSgpIHtcclxuICAgIGNvbnN0IFt2YWx1ZTEsIHNldFZhbHVlMV0gPSB1c2VTdGF0ZSgnc3RhcicpO1xyXG4gICAgY29uc3QgW3ZhbHVlMiwgc2V0VmFsdWUyXSA9IHVzZVN0YXRlKCdzdGFyJyk7XHJcbiAgICBjb25zdCBbdmFsdWUzLCBzZXRWYWx1ZTNdID0gdXNlU3RhdGUoJ3N0YXInKTtcclxuXHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAgIDxQYWdlIGlkPXtpZH0gdGl0bGU9e3RpdGxlfSBkZXNjcmlwdGlvbj17ZGVzY3JpcHRpb259IGxpbmtzPXtsaW5rc30+XHJcbiAgICAgICAgICAgIDxEZW1vIHRpdGxlPVwiVGV4dFwiPlxyXG4gICAgICAgICAgICAgICAgPFNlZ21lbnRlZEJ1dHRvbiB2YWx1ZT17dmFsdWUxfSBvbkNoYW5nZT17c2V0VmFsdWUxfT5cclxuICAgICAgICAgICAgICAgICAgICA8U2VnbWVudGVkQnV0dG9uLlNlZ21lbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU9XCJzdGFyXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWw9XCJzdGFyXCJcclxuICAgICAgICAgICAgICAgICAgICAvPlxyXG5cclxuICAgICAgICAgICAgICAgICAgICA8U2VnbWVudGVkQnV0dG9uLlNlZ21lbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU9XCJmYXZvcml0ZVwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsPVwiZmF2b3JpdGVcIlxyXG4gICAgICAgICAgICAgICAgICAgIC8+XHJcbiAgICAgICAgICAgICAgICA8L1NlZ21lbnRlZEJ1dHRvbj5cclxuICAgICAgICAgICAgPC9EZW1vPlxyXG5cclxuICAgICAgICAgICAgPERlbW8gdGl0bGU9XCJJY29uc1wiPlxyXG4gICAgICAgICAgICAgICAgPFNlZ21lbnRlZEJ1dHRvbiB2YWx1ZT17dmFsdWUyfSBvbkNoYW5nZT17c2V0VmFsdWUyfT5cclxuICAgICAgICAgICAgICAgICAgICA8U2VnbWVudGVkQnV0dG9uLlNlZ21lbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU9XCJzdGFyXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWNvbj1cInN0YXJcIlxyXG4gICAgICAgICAgICAgICAgICAgIC8+XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIDxTZWdtZW50ZWRCdXR0b24uU2VnbWVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZT1cImZhdm9yaXRlXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWNvbj1cImZhdm9yaXRlXCJcclxuICAgICAgICAgICAgICAgICAgICAvPlxyXG4gICAgICAgICAgICAgICAgPC9TZWdtZW50ZWRCdXR0b24+XHJcbiAgICAgICAgICAgIDwvRGVtbz5cclxuXHJcbiAgICAgICAgICAgIDxEZW1vIHRpdGxlPVwiVGV4dCB3aXRoIEljb25zXCI+XHJcbiAgICAgICAgICAgICAgICA8U2VnbWVudGVkQnV0dG9uIHZhbHVlPXt2YWx1ZTN9IG9uQ2hhbmdlPXtzZXRWYWx1ZTN9PlxyXG4gICAgICAgICAgICAgICAgICAgIDxTZWdtZW50ZWRCdXR0b24uU2VnbWVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZT1cInN0YXJcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpY29uPVwic3RhclwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsPVwic3RhclwiXHJcbiAgICAgICAgICAgICAgICAgICAgLz5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgPFNlZ21lbnRlZEJ1dHRvbi5TZWdtZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlPVwiZmF2b3JpdGVcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpY29uPVwiZmF2b3JpdGVcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBsYWJlbD1cImZhdm9yaXRlXCJcclxuICAgICAgICAgICAgICAgICAgICAvPlxyXG4gICAgICAgICAgICAgICAgPC9TZWdtZW50ZWRCdXR0b24+XHJcbiAgICAgICAgICAgIDwvRGVtbz5cclxuICAgICAgICA8L1BhZ2U+XHJcbiAgICApO1xyXG59IiwiaW1wb3J0IHsgdXNlU3RhdGUgfSBmcm9tICdyZWFjdCc7XHJcbmltcG9ydCB7XHJcbiAgICBTZWxlY3RcclxufSBmcm9tICdtZGMtcmVhY3QnO1xyXG5cclxuaW1wb3J0IERlbW8gZnJvbSAnQC9jb21wb25lbnRzL0RlbW8nO1xyXG5pbXBvcnQgUGFnZSBmcm9tICdAL2NvbXBvbmVudHMvUGFnZSc7XHJcblxyXG5pbXBvcnQgJy4vaW5kZXguc2Nzcyc7XHJcblxyXG5jb25zdCBpZCA9ICdzZWxlY3QnO1xyXG5jb25zdCB0aXRsZSA9ICdTZWxlY3QnO1xyXG5jb25zdCBkZXNjcmlwdGlvbiA9ICdTZWdtZW50ZWQgYnV0dG9ucyBhbGxvdyB1c2VycyB0byB0b2dnbGUgdGhlIHNlbGVjdGVkIHN0YXRlcyBvZiBncm91cGVkIGJ1dHRvbnMuJztcclxuY29uc3QgbGlua3MgPSB7XHJcbiAgICBkb2NzOiAnaHR0cHM6Ly9naXRodWIuY29tL21hdGVyaWFsLWNvbXBvbmVudHMvbWF0ZXJpYWwtY29tcG9uZW50cy13ZWIvdHJlZS9tYXN0ZXIvcGFja2FnZXMvbWRjLXNlbGVjdCdcclxufTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIFNlbGVjdFBhZ2UoKSB7XHJcbiAgICBjb25zdCBbZmlsbGVkLCBzZXRGaWxsZWRdID0gdXNlU3RhdGUoKTtcclxuICAgIGNvbnN0IFtvdXRsaW5lZCwgc2V0T3V0bGluZWRdID0gdXNlU3RhdGUoKTtcclxuICAgIGNvbnN0IFtwcmVzZWxlY3RlZCwgc2V0UHJlc2VsZWN0ZWRdID0gdXNlU3RhdGUoJ2ZvbycpO1xyXG4gICAgY29uc3QgW211bHRpcGxlLCBzZXRNdWx0aXBsZV0gPSB1c2VTdGF0ZShbXSk7XHJcbiAgICBjb25zdCBbaWNvbiwgc2V0SWNvbl0gPSB1c2VTdGF0ZSgpO1xyXG5cclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgPFBhZ2UgaWQ9e2lkfSB0aXRsZT17dGl0bGV9IGRlc2NyaXB0aW9uPXtkZXNjcmlwdGlvbn0gbGlua3M9e2xpbmtzfT5cclxuICAgICAgICAgICAgPERlbW8gdGl0bGU9XCJGaWxsZWQgc2VsZWN0XCI+XHJcbiAgICAgICAgICAgICAgICA8U2VsZWN0XHJcbiAgICAgICAgICAgICAgICAgICAgbGFiZWw9XCJDaG9vc2VcIlxyXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlPXtmaWxsZWR9XHJcbiAgICAgICAgICAgICAgICAgICAgZmlsbGVkXHJcbiAgICAgICAgICAgICAgICAgICAgb25DaGFuZ2U9eyhldmVudCwgdmFsdWUpID0+IHNldEZpbGxlZCh2YWx1ZSl9XHJcbiAgICAgICAgICAgICAgICA+XHJcbiAgICAgICAgICAgICAgICAgICAgPFNlbGVjdC5PcHRpb24gdmFsdWU9XCJmb29cIiB0ZXh0PVwiRm9vXCIgLz5cclxuICAgICAgICAgICAgICAgICAgICA8U2VsZWN0Lk9wdGlvbiB2YWx1ZT1cImJhclwiIHRleHQ9XCJCYXJcIiAvPlxyXG4gICAgICAgICAgICAgICAgICAgIDxTZWxlY3QuT3B0aW9uIHZhbHVlPVwiYmF6XCIgdGV4dD1cIkJhelwiIC8+XHJcbiAgICAgICAgICAgICAgICA8L1NlbGVjdD5cclxuICAgICAgICAgICAgPC9EZW1vPlxyXG5cclxuICAgICAgICAgICAgPERlbW8gdGl0bGU9XCJPdXRsaW5lZCBzZWxlY3RcIj5cclxuICAgICAgICAgICAgICAgIDxTZWxlY3RcclxuICAgICAgICAgICAgICAgICAgICBsYWJlbD1cIkNob29zZVwiXHJcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU9e291dGxpbmVkfVxyXG4gICAgICAgICAgICAgICAgICAgIG91dGxpbmVkXHJcbiAgICAgICAgICAgICAgICAgICAgb25DaGFuZ2U9eyhldmVudCwgdmFsdWUpID0+IHNldE91dGxpbmVkKHZhbHVlKX1cclxuICAgICAgICAgICAgICAgID5cclxuICAgICAgICAgICAgICAgICAgICA8U2VsZWN0Lk9wdGlvbiB2YWx1ZT1cImZvb1wiIHRleHQ9XCJGb29cIiAvPlxyXG4gICAgICAgICAgICAgICAgICAgIDxTZWxlY3QuT3B0aW9uIHZhbHVlPVwiYmFyXCIgdGV4dD1cIkJhclwiIC8+XHJcbiAgICAgICAgICAgICAgICAgICAgPFNlbGVjdC5PcHRpb24gdmFsdWU9XCJiYXpcIiB0ZXh0PVwiQmF6XCIgLz5cclxuICAgICAgICAgICAgICAgIDwvU2VsZWN0PlxyXG4gICAgICAgICAgICA8L0RlbW8+XHJcblxyXG4gICAgICAgICAgICA8RGVtbyB0aXRsZT1cIlByZXNlbGVjdGVkIHNlbGVjdFwiPlxyXG4gICAgICAgICAgICAgICAgPFNlbGVjdFxyXG4gICAgICAgICAgICAgICAgICAgIGxhYmVsPVwiQ2hvb3NlXCJcclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZT17cHJlc2VsZWN0ZWR9XHJcbiAgICAgICAgICAgICAgICAgICAgZmlsbGVkXHJcbiAgICAgICAgICAgICAgICAgICAgb25DaGFuZ2U9eyhldmVudCwgdmFsdWUpID0+IHNldFByZXNlbGVjdGVkKHZhbHVlKX1cclxuICAgICAgICAgICAgICAgID5cclxuICAgICAgICAgICAgICAgICAgICA8U2VsZWN0Lk9wdGlvbiB2YWx1ZT1cImZvb1wiIHRleHQ9XCJGb29cIiAvPlxyXG4gICAgICAgICAgICAgICAgICAgIDxTZWxlY3QuT3B0aW9uIHZhbHVlPVwiYmFyXCIgdGV4dD1cIkJhclwiIC8+XHJcbiAgICAgICAgICAgICAgICAgICAgPFNlbGVjdC5PcHRpb24gdmFsdWU9XCJiYXpcIiB0ZXh0PVwiQmF6XCIgLz5cclxuICAgICAgICAgICAgICAgIDwvU2VsZWN0PlxyXG4gICAgICAgICAgICA8L0RlbW8+XHJcblxyXG4gICAgICAgICAgICA8RGVtbyB0aXRsZT1cIk11bHRpcGxlIHNlbGVjdFwiPlxyXG4gICAgICAgICAgICAgICAgPFNlbGVjdFxyXG4gICAgICAgICAgICAgICAgICAgIGxhYmVsPVwiQ2hvb3NlXCJcclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZT17bXVsdGlwbGV9XHJcbiAgICAgICAgICAgICAgICAgICAgZmlsbGVkXHJcbiAgICAgICAgICAgICAgICAgICAgb25DaGFuZ2U9eyhldmVudCwgdmFsdWUpID0+IHNldE11bHRpcGxlKHZhbHVlKX1cclxuICAgICAgICAgICAgICAgID5cclxuICAgICAgICAgICAgICAgICAgICA8U2VsZWN0Lk9wdGlvbiB2YWx1ZT1cImZvb1wiIHRleHQ9XCJGb29cIiAvPlxyXG4gICAgICAgICAgICAgICAgICAgIDxTZWxlY3QuT3B0aW9uIHZhbHVlPVwiYmFyXCIgdGV4dD1cIkJhclwiIC8+XHJcbiAgICAgICAgICAgICAgICAgICAgPFNlbGVjdC5PcHRpb24gdmFsdWU9XCJiYXpcIiB0ZXh0PVwiQmF6XCIgLz5cclxuICAgICAgICAgICAgICAgIDwvU2VsZWN0PlxyXG4gICAgICAgICAgICA8L0RlbW8+XHJcblxyXG4gICAgICAgICAgICA8RGVtbyB0aXRsZT1cIlNlbGVjdCB3aXRoIGFuIGljb25cIj5cclxuICAgICAgICAgICAgICAgIDxTZWxlY3RcclxuICAgICAgICAgICAgICAgICAgICBsYWJlbD1cIkNob29zZVwiXHJcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU9e2ljb259XHJcbiAgICAgICAgICAgICAgICAgICAgaWNvbj1cInN0YXJcIlxyXG4gICAgICAgICAgICAgICAgICAgIGZpbGxlZFxyXG4gICAgICAgICAgICAgICAgICAgIG9uQ2hhbmdlPXsoZXZlbnQsIHZhbHVlKSA9PiBzZXRJY29uKHZhbHVlKX1cclxuICAgICAgICAgICAgICAgID5cclxuICAgICAgICAgICAgICAgICAgICA8U2VsZWN0Lk9wdGlvbiB2YWx1ZT1cImZvb1wiIHRleHQ9XCJGb29cIiAvPlxyXG4gICAgICAgICAgICAgICAgICAgIDxTZWxlY3QuT3B0aW9uIHZhbHVlPVwiYmFyXCIgdGV4dD1cIkJhclwiIC8+XHJcbiAgICAgICAgICAgICAgICAgICAgPFNlbGVjdC5PcHRpb24gdmFsdWU9XCJiYXpcIiB0ZXh0PVwiQmF6XCIgLz5cclxuICAgICAgICAgICAgICAgIDwvU2VsZWN0PlxyXG4gICAgICAgICAgICA8L0RlbW8+XHJcbiAgICAgICAgPC9QYWdlPlxyXG4gICAgKTtcclxufSIsImltcG9ydCB7IHVzZVN0YXRlIH0gZnJvbSAncmVhY3QnO1xyXG5pbXBvcnQge1xyXG4gICAgQnV0dG9uLFxyXG4gICAgU2lkZVNoZWV0XHJcbn0gZnJvbSAnbWRjLXJlYWN0JztcclxuXHJcbmltcG9ydCBEZW1vIGZyb20gJ0AvY29tcG9uZW50cy9EZW1vJztcclxuaW1wb3J0IEZpZWxkU2V0IGZyb20gJ0AvY29tcG9uZW50cy9GaWVsZFNldCc7XHJcbmltcG9ydCBQYWdlIGZyb20gJ0AvY29tcG9uZW50cy9QYWdlJztcclxuXHJcbmNvbnN0IGlkID0gJ3NpZGUtc2hlZXQnO1xyXG5jb25zdCB0aXRsZSA9ICdTaWRlIFNoZWV0JztcclxuY29uc3QgZGVzY3JpcHRpb24gPSAnU2lkZSBzaGVldHMgYXJlIHN1cmZhY2VzIGNvbnRhaW5pbmcgc3VwcGxlbWVudGFyeSBjb250ZW50IHRoYXQgYXJlIGFuY2hvcmVkIHRvIHRoZSBsZWZ0IG9yIHJpZ2h0IGVkZ2Ugb2YgdGhlIHNjcmVlbi4nO1xyXG5jb25zdCBsaW5rcyA9IHtcclxuICAgIGd1aWRlOiAnaHR0cHM6Ly9tYXRlcmlhbC5pby9jb21wb25lbnRzL3NoZWV0cy1zaWRlJ1xyXG59O1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gU2lkZVNoZWV0UGFnZSgpIHtcclxuICAgIGNvbnN0IFtpc0Rpc21pc3NpYmxlT3Blbiwgc2V0RGlzbWlzc2libGVPcGVuXSA9IHVzZVN0YXRlKGZhbHNlKTtcclxuICAgIGNvbnN0IFtpc01vZGFsT3Blbiwgc2V0TW9kYWxPcGVuXSA9IHVzZVN0YXRlKGZhbHNlKTtcclxuXHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAgIDxQYWdlIGlkPXtpZH0gdGl0bGU9e3RpdGxlfSBkZXNjcmlwdGlvbj17ZGVzY3JpcHRpb259IGxpbmtzPXtsaW5rc30+XHJcbiAgICAgICAgICAgIDxEZW1vIHRpdGxlPVwiQmFzaWMgc2lkZSBzaGVldFwiPlxyXG4gICAgICAgICAgICAgICAgPFNpZGVTaGVldCB0aXRsZT1cIlRpdGxlXCI+XHJcbiAgICAgICAgICAgICAgICAgICAgQ29udGVudFxyXG4gICAgICAgICAgICAgICAgPC9TaWRlU2hlZXQ+XHJcbiAgICAgICAgICAgIDwvRGVtbz5cclxuXHJcbiAgICAgICAgICAgIDxEZW1vIHRpdGxlPVwiRGlzbWlzc2libGUgc2lkZSBzaGVldFwiXHJcbiAgICAgICAgICAgICAgICBzZXR1cD17XHJcbiAgICAgICAgICAgICAgICAgICAgPEJ1dHRvblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBsYWJlbD1cIlRvZ2dsZVwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dGxpbmVkXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2xpY2s9eygpID0+IHNldERpc21pc3NpYmxlT3Blbih2ID0+ICF2KX1cclxuICAgICAgICAgICAgICAgICAgICAvPlxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICA+XHJcbiAgICAgICAgICAgICAgICA8U2lkZVNoZWV0XHJcbiAgICAgICAgICAgICAgICAgICAgdGl0bGU9XCJUaXRsZVwiXHJcbiAgICAgICAgICAgICAgICAgICAgY2xvc2VJY29uPVwiY2xvc2VcIlxyXG4gICAgICAgICAgICAgICAgICAgIG9wZW49e2lzRGlzbWlzc2libGVPcGVufVxyXG4gICAgICAgICAgICAgICAgICAgIGRpc21pc3NpYmxlXHJcbiAgICAgICAgICAgICAgICAgICAgb25DbG9zZT17KCkgPT4gc2V0RGlzbWlzc2libGVPcGVuKGZhbHNlKX1cclxuICAgICAgICAgICAgICAgID5cclxuICAgICAgICAgICAgICAgICAgICBDb250ZW50XHJcbiAgICAgICAgICAgICAgICA8L1NpZGVTaGVldD5cclxuICAgICAgICAgICAgPC9EZW1vPlxyXG5cclxuICAgICAgICAgICAgPERlbW9cclxuICAgICAgICAgICAgICAgIHRpdGxlPVwiTW9kYWwgc2lkZSBzaGVldFwiXHJcbiAgICAgICAgICAgICAgICBzZXR1cD17XHJcbiAgICAgICAgICAgICAgICAgICAgPEJ1dHRvblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBsYWJlbD1cIk9wZW5cIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRsaW5lZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBvbkNsaWNrPXsoKSA9PiBzZXRNb2RhbE9wZW4odHJ1ZSl9XHJcbiAgICAgICAgICAgICAgICAgICAgLz5cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgPlxyXG4gICAgICAgICAgICAgICAgPFNpZGVTaGVldFxyXG4gICAgICAgICAgICAgICAgICAgIHRpdGxlPVwiVGl0bGVcIlxyXG4gICAgICAgICAgICAgICAgICAgIGNsb3NlSWNvbj1cImNsb3NlXCJcclxuICAgICAgICAgICAgICAgICAgICBvcGVuPXtpc01vZGFsT3Blbn1cclxuICAgICAgICAgICAgICAgICAgICBtb2RhbFxyXG4gICAgICAgICAgICAgICAgICAgIG9uQ2xvc2U9eygpID0+IHNldE1vZGFsT3BlbihmYWxzZSl9XHJcbiAgICAgICAgICAgICAgICA+XHJcbiAgICAgICAgICAgICAgICAgICAgQ29udGVudFxyXG4gICAgICAgICAgICAgICAgPC9TaWRlU2hlZXQ+XHJcbiAgICAgICAgICAgIDwvRGVtbz5cclxuICAgICAgICA8L1BhZ2U+XHJcbiAgICApO1xyXG59IiwiaW1wb3J0IHsgdXNlU3RhdGUgfSBmcm9tICdyZWFjdCc7XHJcbmltcG9ydCB7XHJcbiAgICBTbGlkZXJcclxufSBmcm9tICdtZGMtcmVhY3QnO1xyXG5cclxuaW1wb3J0IERlbW8gZnJvbSAnQC9jb21wb25lbnRzL0RlbW8nO1xyXG5pbXBvcnQgRmllbGRTZXQgZnJvbSAnQC9jb21wb25lbnRzL0ZpZWxkU2V0JztcclxuaW1wb3J0IFBhZ2UgZnJvbSAnQC9jb21wb25lbnRzL1BhZ2UnO1xyXG5cclxuY29uc3QgaWQgPSAnc2xpZGVyJztcclxuY29uc3QgdGl0bGUgPSAnU2xpZGVyJztcclxuY29uc3QgZGVzY3JpcHRpb24gPSAnU2xpZGVycyBhbGxvdyB1c2VycyB0byBtYWtlIHNlbGVjdGlvbnMgZnJvbSBhIHJhbmdlIG9mIHZhbHVlcy4nO1xyXG5jb25zdCBsaW5rcyA9IHtcclxuICAgIGRvY3M6ICdodHRwczovL2dpdGh1Yi5jb20vbWF0ZXJpYWwtY29tcG9uZW50cy9tYXRlcmlhbC1jb21wb25lbnRzLXdlYi90cmVlL21hc3Rlci9wYWNrYWdlcy9tZGMtc2xpZGVyJyxcclxuICAgIGd1aWRlOiAnaHR0cHM6Ly9tYXRlcmlhbC5pby9jb21wb25lbnRzL3NsaWRlcnMnXHJcbn07XHJcblxyXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBTbGlkZXJQYWdlKCkge1xyXG4gICAgY29uc3QgW3ZhbHVlMSwgc2V0VmFsdWUxXSA9IHVzZVN0YXRlKDUwKTtcclxuICAgIGNvbnN0IFt2YWx1ZTIsIHNldFZhbHVlMl0gPSB1c2VTdGF0ZSg1MCk7XHJcbiAgICBjb25zdCBbdmFsdWUzLCBzZXRWYWx1ZTNdID0gdXNlU3RhdGUoNTApO1xyXG5cclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgPFBhZ2UgaWQ9e2lkfSB0aXRsZT17dGl0bGV9IGRlc2NyaXB0aW9uPXtkZXNjcmlwdGlvbn0gbGlua3M9e2xpbmtzfT5cclxuICAgICAgICAgICAgPERlbW8gdGl0bGU9XCJDb250aW51b3VzIHNsaWRlclwiPlxyXG4gICAgICAgICAgICAgICAgPFNsaWRlclxyXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlPXt2YWx1ZTF9XHJcbiAgICAgICAgICAgICAgICAgICAgb25DaGFuZ2U9e3NldFZhbHVlMX1cclxuICAgICAgICAgICAgICAgIC8+XHJcbiAgICAgICAgICAgIDwvRGVtbz5cclxuXHJcbiAgICAgICAgICAgIDxEZW1vIHRpdGxlPVwiRGlzY3JldGUgc2xpZGVyXCI+XHJcbiAgICAgICAgICAgICAgICA8U2xpZGVyXHJcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU9e3ZhbHVlMn1cclxuICAgICAgICAgICAgICAgICAgICBzdGVwPVwiMTBcIlxyXG4gICAgICAgICAgICAgICAgICAgIGRpc2NyZXRlXHJcbiAgICAgICAgICAgICAgICAgICAgb25DaGFuZ2U9e3NldFZhbHVlMn1cclxuICAgICAgICAgICAgICAgIC8+XHJcbiAgICAgICAgICAgIDwvRGVtbz5cclxuXHJcbiAgICAgICAgICAgIDxEZW1vIHRpdGxlPVwiRGlzY3JldGUgc2xpZGVyIHdpdGggdGljayBtYXJrc1wiPlxyXG4gICAgICAgICAgICAgICAgPFNsaWRlclxyXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlPXt2YWx1ZTN9XHJcbiAgICAgICAgICAgICAgICAgICAgc3RlcD1cIjEwXCJcclxuICAgICAgICAgICAgICAgICAgICBkaXNjcmV0ZVxyXG4gICAgICAgICAgICAgICAgICAgIHRpY2tNYXJrc1xyXG4gICAgICAgICAgICAgICAgICAgIG9uQ2hhbmdlPXtzZXRWYWx1ZTN9XHJcbiAgICAgICAgICAgICAgICAvPlxyXG4gICAgICAgICAgICA8L0RlbW8+XHJcblxyXG4gICAgICAgICAgICA8RGVtbyB0aXRsZT1cIkRpc2FibGVkIHNsaWRlclwiPlxyXG4gICAgICAgICAgICAgICAgPFNsaWRlclxyXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlPXs0Mn1cclxuICAgICAgICAgICAgICAgICAgICBkaXNhYmxlZFxyXG4gICAgICAgICAgICAgICAgLz5cclxuICAgICAgICAgICAgPC9EZW1vPlxyXG4gICAgICAgIDwvUGFnZT5cclxuICAgICk7XHJcbn0iLCJpbXBvcnQgeyB1c2VTdGF0ZSB9IGZyb20gJ3JlYWN0JztcclxuaW1wb3J0IHtcclxuICAgIEJ1dHRvbixcclxuICAgIExheW91dCxcclxuICAgIFNlZ21lbnRlZEJ1dHRvbixcclxuICAgIFNuYWNrYmFyLFxyXG4gICAgVGV4dEZpZWxkXHJcbn0gZnJvbSAnbWRjLXJlYWN0JztcclxuXHJcbmltcG9ydCBEZW1vIGZyb20gJ0AvY29tcG9uZW50cy9EZW1vJztcclxuaW1wb3J0IEZpZWxkU2V0IGZyb20gJ0AvY29tcG9uZW50cy9GaWVsZFNldCc7XHJcbmltcG9ydCBQYWdlIGZyb20gJ0AvY29tcG9uZW50cy9QYWdlJztcclxuXHJcbmNvbnN0IGlkID0gJ3NuYWNrYmFyJztcclxuY29uc3QgdGl0bGUgPSAnU25hY2tiYXInO1xyXG5jb25zdCBkZXNjcmlwdGlvbiA9ICdTbmFja2JhcnMgcHJvdmlkZSBicmllZiBtZXNzYWdlcyBhYm91dCBhcHAgcHJvY2Vzc2VzIGF0IHRoZSBib3R0b20gb2YgdGhlIHNjcmVlbi4nO1xyXG5jb25zdCBsaW5rcyA9IHtcclxuICAgIGRvY3M6ICdodHRwczovL2dpdGh1Yi5jb20vbWF0ZXJpYWwtY29tcG9uZW50cy9tYXRlcmlhbC1jb21wb25lbnRzLXdlYi90cmVlL21hc3Rlci9wYWNrYWdlcy9tZGMtc25hY2tiYXInLFxyXG4gICAgZ3VpZGU6ICdodHRwczovL21hdGVyaWFsLmlvL2NvbXBvbmVudHMvc25hY2tiYXJzJ1xyXG59O1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gU25hY2tiYXJQYWdlKCkge1xyXG4gICAgY29uc3QgW2lzT3Blbiwgc2V0T3Blbl0gPSB1c2VTdGF0ZShmYWxzZSk7XHJcbiAgICBjb25zdCBbdGltZW91dCwgc2V0VGltZW91dF0gPSB1c2VTdGF0ZSg1MDAwKTtcclxuICAgIGNvbnN0IFtoYXNBY3Rpb24sIHNldEhhc0FjdGlvbl0gPSB1c2VTdGF0ZShmYWxzZSk7XHJcbiAgICBjb25zdCBbaXNMZWFkaW5nLCBzZXRMZWFkaW5nXSA9IHVzZVN0YXRlKGZhbHNlKTtcclxuICAgIGNvbnN0IFtpc1N0YWNrZWQsIHNldFN0YWNrZWRdID0gdXNlU3RhdGUoZmFsc2UpO1xyXG5cclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgPFBhZ2UgaWQ9e2lkfSB0aXRsZT17dGl0bGV9IGRlc2NyaXB0aW9uPXtkZXNjcmlwdGlvbn0gbGlua3M9e2xpbmtzfT5cclxuICAgICAgICAgICAgPERlbW9cclxuICAgICAgICAgICAgICAgIHRpdGxlPVwiRGVtb1wiXHJcbiAgICAgICAgICAgICAgICBzZXR1cD17XHJcbiAgICAgICAgICAgICAgICAgICAgPEJ1dHRvblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBsYWJlbD1cIlNob3dcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRsaW5lZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBvbkNsaWNrPXsoKSA9PiBzZXRPcGVuKHRydWUpfVxyXG4gICAgICAgICAgICAgICAgICAgIC8+XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBzZXR0aW5ncz17PD5cclxuICAgICAgICAgICAgICAgICAgICA8RmllbGRTZXQgbGVnZW5kPVwiRWxlbWVudHNcIj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPFNlZ21lbnRlZEJ1dHRvbj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxTZWdtZW50ZWRCdXR0b24uU2VnbWVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsPVwiQWN0aW9uXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3RlZD17aGFzQWN0aW9ufVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2xpY2s9eygpID0+IHNldEhhc0FjdGlvbih2ID0+ICF2KX1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDwvU2VnbWVudGVkQnV0dG9uPlxyXG4gICAgICAgICAgICAgICAgICAgIDwvRmllbGRTZXQ+XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIDxGaWVsZFNldCBsZWdlbmQ9XCJWYXJpYW50c1wiPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8U2VnbWVudGVkQnV0dG9uPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPFNlZ21lbnRlZEJ1dHRvbi5TZWdtZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWw9XCJMZWFkaW5nXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3RlZD17aXNMZWFkaW5nfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2xpY2s9eygpID0+IHNldExlYWRpbmcodiA9PiAhdil9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvPlxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxTZWdtZW50ZWRCdXR0b24uU2VnbWVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsPVwiU3RhY2tlZFwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0ZWQ9e2lzU3RhY2tlZH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbkNsaWNrPXsoKSA9PiBzZXRTdGFja2VkKHYgPT4gIXYpfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLz5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPC9TZWdtZW50ZWRCdXR0b24+XHJcbiAgICAgICAgICAgICAgICAgICAgPC9GaWVsZFNldD5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgPFRleHRGaWVsZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBsYWJlbD1cIlRpbWVvdXRcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZT17dGltZW91dH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgc3VmZml4PVwibXNcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRsaW5lZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBvbkNoYW5nZT17KF8sIHZhbHVlKSA9PiBzZXRUaW1lb3V0KHZhbHVlKX1cclxuICAgICAgICAgICAgICAgICAgICAvPlxyXG4gICAgICAgICAgICAgICAgPC8+fVxyXG4gICAgICAgICAgICA+XHJcbiAgICAgICAgICAgICAgICA8U25hY2tiYXJcclxuICAgICAgICAgICAgICAgICAgICBvcGVuPXtpc09wZW59XHJcbiAgICAgICAgICAgICAgICAgICAgdGltZW91dD17dGltZW91dH1cclxuICAgICAgICAgICAgICAgICAgICBsYWJlbD1cIk1lc3NhZ2VcIlxyXG4gICAgICAgICAgICAgICAgICAgIGFjdGlvbj17aGFzQWN0aW9uID9cclxuICAgICAgICAgICAgICAgICAgICAgICAgPEJ1dHRvbj5BY3Rpb248L0J1dHRvbj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB1bmRlZmluZWRcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgbGVhZGluZz17aXNMZWFkaW5nIHx8IHVuZGVmaW5lZH1cclxuICAgICAgICAgICAgICAgICAgICBzdGFja2VkPXtpc1N0YWNrZWQgfHwgdW5kZWZpbmVkfVxyXG4gICAgICAgICAgICAgICAgICAgIG9uQ2xvc2U9eygpID0+IHNldE9wZW4odW5kZWZpbmVkKX1cclxuICAgICAgICAgICAgICAgIC8+XHJcbiAgICAgICAgICAgIDwvRGVtbz5cclxuICAgICAgICA8L1BhZ2U+XHJcbiAgICApO1xyXG59IiwiaW1wb3J0IHsgdXNlU3RhdGUgfSBmcm9tICdyZWFjdCc7XHJcbmltcG9ydCB7XHJcbiAgICBTd2l0Y2hcclxufSBmcm9tICdtZGMtcmVhY3QnO1xyXG5cclxuaW1wb3J0IERlbW8gZnJvbSAnQC9jb21wb25lbnRzL0RlbW8nO1xyXG5pbXBvcnQgUGFnZSBmcm9tICdAL2NvbXBvbmVudHMvUGFnZSc7XHJcblxyXG5jb25zdCBpZCA9ICdzd2l0Y2gnO1xyXG5jb25zdCB0aXRsZSA9ICdTd2l0Y2gnO1xyXG5jb25zdCBkZXNjcmlwdGlvbiA9ICdTd2l0Y2hlcyB0b2dnbGUgdGhlIHN0YXRlIG9mIGEgc2luZ2xlIGl0ZW0gb24gb3Igb2ZmLic7XHJcbmNvbnN0IGxpbmtzID0ge1xyXG4gICAgZG9jczogJ2h0dHBzOi8vZ2l0aHViLmNvbS9tYXRlcmlhbC1jb21wb25lbnRzL21hdGVyaWFsLWNvbXBvbmVudHMtd2ViL3RyZWUvbWFzdGVyL3BhY2thZ2VzL21kYy1zd2l0Y2gnLFxyXG4gICAgZ3VpZGU6ICdodHRwczovL21hdGVyaWFsLmlvL2NvbXBvbmVudHMvc3dpdGNoZXMnXHJcbn07XHJcblxyXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBTd2l0Y2hQYWdlKCkge1xyXG4gICAgY29uc3QgW2lzU2VsZWN0ZWQsIHNldFNlbGVjdGVkXSA9IHVzZVN0YXRlKGZhbHNlKTtcclxuXHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAgIDxQYWdlIGlkPXtpZH0gdGl0bGU9e3RpdGxlfSBkZXNjcmlwdGlvbj17ZGVzY3JpcHRpb259IGxpbmtzPXtsaW5rc30+XHJcbiAgICAgICAgICAgIDxEZW1vIHRpdGxlPVwiQmFzaWMgc3dpdGNoXCI+XHJcbiAgICAgICAgICAgICAgICA8U3dpdGNoXHJcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0ZWQ9e2lzU2VsZWN0ZWR9XHJcbiAgICAgICAgICAgICAgICAgICAgb25DaGFuZ2U9eygpID0+IHNldFNlbGVjdGVkKHYgPT4gIXYpfVxyXG4gICAgICAgICAgICAgICAgLz5cclxuICAgICAgICAgICAgPC9EZW1vPlxyXG5cclxuICAgICAgICAgICAgPERlbW8gdGl0bGU9XCJEaXNhYmxlZCBzd2l0Y2hcIj5cclxuICAgICAgICAgICAgICAgIDxTd2l0Y2ggZGlzYWJsZWQgLz5cclxuICAgICAgICAgICAgPC9EZW1vPlxyXG4gICAgICAgIDwvUGFnZT5cclxuICAgICk7XHJcbn0iLCJpbXBvcnQgeyB1c2VTdGF0ZSB9IGZyb20gJ3JlYWN0JztcclxuaW1wb3J0IHtcclxuICAgIEZvcm1GaWVsZCxcclxuICAgIFN5bWJvbCxcclxuICAgIFNlZ21lbnRlZEJ1dHRvbixcclxuICAgIFNsaWRlcixcclxuICAgIFN3aXRjaCxcclxuICAgIFRleHRGaWVsZFxyXG59IGZyb20gJ21kYy1yZWFjdCc7XHJcblxyXG5pbXBvcnQgRGVtbyBmcm9tICdAL2NvbXBvbmVudHMvRGVtbyc7XHJcbmltcG9ydCBGaWVsZFNldCBmcm9tICdAL2NvbXBvbmVudHMvRmllbGRTZXQnO1xyXG5pbXBvcnQgUGFnZSBmcm9tICdAL2NvbXBvbmVudHMvUGFnZSc7XHJcblxyXG5pbXBvcnQgJy4vaW5kZXguc2Nzcyc7XHJcblxyXG5jb25zdCBpZCA9ICdzeW1ib2wnO1xyXG5jb25zdCB0aXRsZSA9ICdTeW1ib2wnO1xyXG5jb25zdCBkZXNjcmlwdGlvbiA9ICdNYXRlcmlhbCBTeW1ib2xzIGFyZSBvdXIgbmV3ZXN0IGljb25zLCBjb25zb2xpZGF0aW5nIG92ZXIgMiw1MDAgZ2x5cGhzIGluIGEgc2luZ2xlIGZvbnQgZmlsZSB3aXRoIGEgd2lkZSByYW5nZSBvZiBkZXNpZ24gdmFyaWFudHMuIFN5bWJvbHMgYXJlIGF2YWlsYWJsZSBpbiB0aHJlZSBzdHlsZXMgYW5kIGZvdXIgYWRqdXN0YWJsZSB2YXJpYWJsZSBmb250IGF4ZXMgKGZpbGwsIHdlaWdodCwgZ3JhZGUsIGFuZCBvcHRpY2FsIHNpemUpLic7XHJcbmNvbnN0IGxpbmtzID0ge1xyXG4gICAgZG9jczogJ2h0dHBzOi8vZGV2ZWxvcGVycy5nb29nbGUuY29tL2ZvbnRzL2RvY3MvbWF0ZXJpYWxfc3ltYm9scycsXHJcbiAgICBndWlkZTogJ2h0dHBzOi8vbWF0ZXJpYWwuaW8vZGVzaWduL2ljb25vZ3JhcGh5J1xyXG59O1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gU3ltYm9sUGFnZSgpIHtcclxuICAgIGNvbnN0IFtuYW1lLCBzZXROYW1lXSA9IHVzZVN0YXRlKCdmbGFnJyk7XHJcbiAgICBjb25zdCBbc2l6ZSwgc2V0U2l6ZV0gPSB1c2VTdGF0ZSgnJyk7XHJcbiAgICBjb25zdCBbdHlwZSwgc2V0VHlwZV0gPSB1c2VTdGF0ZSgnb3V0bGluZWQnKTtcclxuICAgIGNvbnN0IFt0b25lLCBzZXRUb25lXSA9IHVzZVN0YXRlKCcnKTtcclxuICAgIGNvbnN0IFt3ZWlnaHQsIHNldFdlaWdodF0gPSB1c2VTdGF0ZSgzMDApO1xyXG4gICAgY29uc3QgW2dyYWRlLCBzZXRHcmFkZV0gPSB1c2VTdGF0ZSgwKTtcclxuICAgIGNvbnN0IFtmaWxsZWQsIHNldEZpbGxlZF0gPSB1c2VTdGF0ZShmYWxzZSk7XHJcbiAgICBjb25zdCBbaW5hY3RpdmUsIHNldEluYWN0aXZlXSA9IHVzZVN0YXRlKGZhbHNlKTtcclxuXHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAgIDxQYWdlIGlkPXtpZH0gdGl0bGU9e3RpdGxlfSBkZXNjcmlwdGlvbj17ZGVzY3JpcHRpb259IGxpbmtzPXtsaW5rc30+XHJcbiAgICAgICAgICAgIDxEZW1vXHJcbiAgICAgICAgICAgICAgICBzZXR0aW5ncz17PD5cclxuICAgICAgICAgICAgICAgICAgICA8VGV4dEZpZWxkXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlPXtuYW1lfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBsYWJlbD1cIkxhYmVsXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgb3V0bGluZWRcclxuICAgICAgICAgICAgICAgICAgICAgICAgb25DaGFuZ2U9eyhfLCB2YWx1ZSkgPT4gc2V0TmFtZSh2YWx1ZSl9XHJcbiAgICAgICAgICAgICAgICAgICAgLz5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgPEZpZWxkU2V0IGxlZ2VuZD1cIlR5cGVcIj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPFNlZ21lbnRlZEJ1dHRvblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VnbWVudHM9e1tcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7IHZhbHVlOiAnb3V0bGluZWQnLCBsYWJlbDogJ091dGxpbmVkJyB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgdmFsdWU6ICdyb3VuZGVkJywgbGFiZWw6ICdSb3VuZGVkJyB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgdmFsdWU6ICdzaGFycCcsIGxhYmVsOiAnU2hhcnAnIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF19XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZT17dHlwZX1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2hhbmdlPXtzZXRUeXBlfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvPlxyXG4gICAgICAgICAgICAgICAgICAgIDwvRmllbGRTZXQ+XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIDxGb3JtRmllbGQgbGFiZWw9XCJGaWxsZWRcIiBhbGlnbkVuZCBzcGFjZUJldHdlZW4+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxTd2l0Y2hcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdGVkPXtmaWxsZWR9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbkNoYW5nZT17KCkgPT4gc2V0RmlsbGVkKHYgPT4gIXYpfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvPlxyXG4gICAgICAgICAgICAgICAgICAgIDwvRm9ybUZpZWxkPlxyXG5cclxuICAgICAgICAgICAgICAgICAgICA8RmllbGRTZXQgbGVnZW5kPVwiU2l6ZVwiPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8U2VnbWVudGVkQnV0dG9uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWdtZW50cz17W1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgdmFsdWU6ICdzbWFsbGVyJywgbGFiZWw6ICdTbWFsbGVyJyB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgdmFsdWU6ICdzbWFsbCcsIGxhYmVsOiAnU21hbGwnIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeyB2YWx1ZTogJ21lZGl1bScsIGxhYmVsOiAnTWVkaXVtJyB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgdmFsdWU6ICdsYXJnZScsIGxhYmVsOiAnTGFyZ2UnIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeyB2YWx1ZTogJ2xhcmdlcicsIGxhYmVsOiAnTGFyZ2VyJyB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBdfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU9e3NpemV9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbkNoYW5nZT17c2V0U2l6ZX1cclxuICAgICAgICAgICAgICAgICAgICAgICAgLz5cclxuICAgICAgICAgICAgICAgICAgICA8L0ZpZWxkU2V0PlxyXG5cclxuICAgICAgICAgICAgICAgICAgICA8Rm9ybUZpZWxkIGxhYmVsPVwiV2VpZ2h0XCIgYmxvY2s+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxTbGlkZXJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlPXt3ZWlnaHR9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtaW49XCIxMDBcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF4PVwiNzAwXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0ZXA9XCIxMDBcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlzY3JldGVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpY2tNYXJrc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb25DaGFuZ2U9e3NldFdlaWdodH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgLz5cclxuICAgICAgICAgICAgICAgICAgICA8L0Zvcm1GaWVsZD5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgPEZpZWxkU2V0IGxlZ2VuZD1cIkdyYWRlXCI+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxTZWdtZW50ZWRCdXR0b25cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlZ21lbnRzPXtbXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeyB2YWx1ZTogLTI1LCBsYWJlbDogJ0xvdycgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7IHZhbHVlOiAwLCBsYWJlbDogJ05vcm1hbCcgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7IHZhbHVlOiAyMDAsIGxhYmVsOiAnSGlnaCcgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXX1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlPXtncmFkZX1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2hhbmdlPXtzZXRHcmFkZX1cclxuICAgICAgICAgICAgICAgICAgICAgICAgLz5cclxuICAgICAgICAgICAgICAgICAgICA8L0ZpZWxkU2V0PlxyXG5cclxuICAgICAgICAgICAgICAgICAgICA8RmllbGRTZXQgbGVnZW5kPVwiVG9uZVwiPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8U2VnbWVudGVkQnV0dG9uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWdtZW50cz17W1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgdmFsdWU6ICcnLCBsYWJlbDogJ05vbmUnIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeyB2YWx1ZTogJ2xpZ2h0JywgbGFiZWw6ICdMaWdodCcgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7IHZhbHVlOiAnZGFyaycsIGxhYmVsOiAnRGFyaycgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXX1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlPXt0b25lfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb25DaGFuZ2U9e3NldFRvbmV9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8+XHJcbiAgICAgICAgICAgICAgICAgICAgPC9GaWVsZFNldD5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgPEZvcm1GaWVsZCBsYWJlbD1cIkluYWN0aXZlXCIgYWxpZ25FbmQgc3BhY2VCZXR3ZWVuPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8U3dpdGNoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3RlZD17aW5hY3RpdmV9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbkNoYW5nZT17KCkgPT4gc2V0SW5hY3RpdmUodiA9PiAhdil9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8+XHJcbiAgICAgICAgICAgICAgICAgICAgPC9Gb3JtRmllbGQ+XHJcbiAgICAgICAgICAgICAgICA8Lz59XHJcbiAgICAgICAgICAgID5cclxuICAgICAgICAgICAgICAgIDxTeW1ib2xcclxuICAgICAgICAgICAgICAgICAgICBuYW1lPXtuYW1lfVxyXG4gICAgICAgICAgICAgICAgICAgIHR5cGU9e3R5cGV9XHJcbiAgICAgICAgICAgICAgICAgICAgc2l6ZT17c2l6ZX1cclxuICAgICAgICAgICAgICAgICAgICB3ZWlnaHQ9e3dlaWdodH1cclxuICAgICAgICAgICAgICAgICAgICBncmFkZT17Z3JhZGV9XHJcbiAgICAgICAgICAgICAgICAgICAgZmlsbGVkPXtmaWxsZWR9XHJcbiAgICAgICAgICAgICAgICAgICAgbGlnaHQ9e3RvbmUgPT09ICdsaWdodCd9XHJcbiAgICAgICAgICAgICAgICAgICAgZGFyaz17dG9uZSA9PT0gJ2RhcmsnfVxyXG4gICAgICAgICAgICAgICAgICAgIGluYWN0aXZlPXtpbmFjdGl2ZX1cclxuICAgICAgICAgICAgICAgIC8+XHJcbiAgICAgICAgICAgIDwvRGVtbz5cclxuICAgICAgICA8L1BhZ2U+XHJcbiAgICApO1xyXG59IiwiaW1wb3J0IHsgdXNlU3RhdGUgfSBmcm9tICdyZWFjdCc7XHJcbmltcG9ydCB7XHJcbiAgICBUYWJCYXIsIFRhYlxyXG59IGZyb20gJ21kYy1yZWFjdCc7XHJcblxyXG5pbXBvcnQgRGVtbyBmcm9tICdAL2NvbXBvbmVudHMvRGVtbyc7XHJcbmltcG9ydCBGaWVsZFNldCBmcm9tICdAL2NvbXBvbmVudHMvRmllbGRTZXQnO1xyXG5pbXBvcnQgUGFnZSBmcm9tICdAL2NvbXBvbmVudHMvUGFnZSc7XHJcblxyXG5jb25zdCBpZCA9ICd0YWJzJztcclxuY29uc3QgdGl0bGUgPSAnVGFicyc7XHJcbmNvbnN0IGRlc2NyaXB0aW9uID0gJ1RhYnMgb3JnYW5pemUgY29udGVudCBhY3Jvc3MgZGlmZmVyZW50IHNjcmVlbnMsIGRhdGEgc2V0cywgYW5kIG90aGVyIGludGVyYWN0aW9ucy4nO1xyXG5jb25zdCBsaW5rcyA9IHtcclxuICAgIGRvY3M6ICdodHRwczovL2dpdGh1Yi5jb20vbWF0ZXJpYWwtY29tcG9uZW50cy9tYXRlcmlhbC1jb21wb25lbnRzLXdlYi90cmVlL21hc3Rlci9wYWNrYWdlcy9tZGMtdGFiLWJhcicsXHJcbiAgICBndWlkZTogJ2h0dHBzOi8vbWF0ZXJpYWwuaW8vY29tcG9uZW50cy90YWJzJ1xyXG59O1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gU3dpdGNoUGFnZSgpIHtcclxuICAgIGNvbnN0IFtiYXNpYywgc2V0QmFzaWNdID0gdXNlU3RhdGUoMCk7XHJcbiAgICBjb25zdCBbbWluV2lkdGgsIHNldE1pbldpZHRoXSA9IHVzZVN0YXRlKDApO1xyXG4gICAgY29uc3QgW21pbldpZHRoSW5kaWNhdG9yLCBzZXRNaW5XaWR0aEluZGljYXRvcl0gPSB1c2VTdGF0ZSgwKTtcclxuICAgIGNvbnN0IFttaW5XaWR0aFdpdGhNaW5XaWR0aEluZGljYXRvciwgc2V0TWluV2lkdGhXaXRoTWluV2lkdGhJbmRpY2F0b3JdID0gdXNlU3RhdGUoMCk7XHJcbiAgICBjb25zdCBbZmFkZSwgc2V0RmFkZV0gPSB1c2VTdGF0ZSgwKTtcclxuICAgIGNvbnN0IFtpY29ucywgc2V0SWNvbnNdID0gdXNlU3RhdGUoMCk7XHJcbiAgICBjb25zdCBbc3RhY2tlZEljb25zLCBzZXRTdGFja2VkSWNvbnNdID0gdXNlU3RhdGUoMCk7XHJcbiAgICBjb25zdCBbb25seUljb25zLCBzZXRPbmx5SWNvbnNdID0gdXNlU3RhdGUoMCk7XHJcbiAgICBjb25zdCBbaWNvbkluZGljYXRvciwgc2V0SWNvbkluZGljYXRvcl0gPSB1c2VTdGF0ZSgwKTtcclxuICAgIGNvbnN0IFtzY3JvbGwsIHNldFNjcm9sbF0gPSB1c2VTdGF0ZSgwKTtcclxuXHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAgIDxQYWdlIGlkPXtpZH0gdGl0bGU9e3RpdGxlfSBkZXNjcmlwdGlvbj17ZGVzY3JpcHRpb259IGxpbmtzPXtsaW5rc30+XHJcbiAgICAgICAgICAgIDxEZW1vIHRpdGxlPVwiQmFzaWMgdGFic1wiPlxyXG4gICAgICAgICAgICAgICAgPFRhYkJhclxyXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlPXtiYXNpY31cclxuICAgICAgICAgICAgICAgICAgICBvbkNoYW5nZT17dmFsdWUgPT4gc2V0QmFzaWModmFsdWUpfVxyXG4gICAgICAgICAgICAgICAgPlxyXG4gICAgICAgICAgICAgICAgICAgIDxUYWIgbGFiZWw9XCJUYWIgMVwiIC8+XHJcbiAgICAgICAgICAgICAgICAgICAgPFRhYiBsYWJlbD1cIlRhYiAyXCIgLz5cclxuICAgICAgICAgICAgICAgICAgICA8VGFiIGxhYmVsPVwiVGFiIDNcIiAvPlxyXG4gICAgICAgICAgICAgICAgPC9UYWJCYXI+XHJcbiAgICAgICAgICAgIDwvRGVtbz5cclxuXHJcbiAgICAgICAgICAgIDxEZW1vIHRpdGxlPVwiTWluIHdpZHRoIHRhYnNcIj5cclxuICAgICAgICAgICAgICAgIDxUYWJCYXJcclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZT17bWluV2lkdGh9XHJcbiAgICAgICAgICAgICAgICAgICAgbWluV2lkdGhcclxuICAgICAgICAgICAgICAgICAgICBvbkNoYW5nZT17dmFsdWUgPT4gc2V0TWluV2lkdGgodmFsdWUpfVxyXG4gICAgICAgICAgICAgICAgPlxyXG4gICAgICAgICAgICAgICAgICAgIDxUYWIgbGFiZWw9XCJUYWIgMVwiIC8+XHJcbiAgICAgICAgICAgICAgICAgICAgPFRhYiBsYWJlbD1cIlRhYiAyXCIgLz5cclxuICAgICAgICAgICAgICAgICAgICA8VGFiIGxhYmVsPVwiVGFiIDNcIiAvPlxyXG4gICAgICAgICAgICAgICAgPC9UYWJCYXI+XHJcbiAgICAgICAgICAgIDwvRGVtbz5cclxuXHJcbiAgICAgICAgICAgIDxEZW1vIHRpdGxlPVwiVGFicyB3aXRoIG1pbiB3aWR0aCBpbmRpY2F0b3JcIj5cclxuICAgICAgICAgICAgICAgIDxUYWJCYXJcclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZT17bWluV2lkdGhJbmRpY2F0b3J9XHJcbiAgICAgICAgICAgICAgICAgICAgbWluV2lkdGhJbmRpY2F0b3JcclxuICAgICAgICAgICAgICAgICAgICBvbkNoYW5nZT17dmFsdWUgPT4gc2V0TWluV2lkdGhJbmRpY2F0b3IodmFsdWUpfVxyXG4gICAgICAgICAgICAgICAgPlxyXG4gICAgICAgICAgICAgICAgICAgIDxUYWIgbGFiZWw9XCJUYWIgMVwiIC8+XHJcbiAgICAgICAgICAgICAgICAgICAgPFRhYiBsYWJlbD1cIlRhYiAyXCIgLz5cclxuICAgICAgICAgICAgICAgICAgICA8VGFiIGxhYmVsPVwiVGFiIDNcIiAvPlxyXG4gICAgICAgICAgICAgICAgPC9UYWJCYXI+XHJcbiAgICAgICAgICAgIDwvRGVtbz5cclxuXHJcbiAgICAgICAgICAgIDxEZW1vIHRpdGxlPVwiTWluIHdpZHRoIHRhYnMgd2l0aCBtaW4gd2lkdGggaW5kaWNhdG9yXCI+XHJcbiAgICAgICAgICAgICAgICA8VGFiQmFyXHJcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU9e21pbldpZHRoV2l0aE1pbldpZHRoSW5kaWNhdG9yfVxyXG4gICAgICAgICAgICAgICAgICAgIG1pbldpZHRoXHJcbiAgICAgICAgICAgICAgICAgICAgbWluV2lkdGhJbmRpY2F0b3JcclxuICAgICAgICAgICAgICAgICAgICBvbkNoYW5nZT17dmFsdWUgPT4gc2V0TWluV2lkdGhXaXRoTWluV2lkdGhJbmRpY2F0b3IodmFsdWUpfVxyXG4gICAgICAgICAgICAgICAgPlxyXG4gICAgICAgICAgICAgICAgICAgIDxUYWIgbGFiZWw9XCJUYWIgMVwiIC8+XHJcbiAgICAgICAgICAgICAgICAgICAgPFRhYiBsYWJlbD1cIlRhYiAyXCIgLz5cclxuICAgICAgICAgICAgICAgICAgICA8VGFiIGxhYmVsPVwiVGFiIDNcIiAvPlxyXG4gICAgICAgICAgICAgICAgPC9UYWJCYXI+XHJcbiAgICAgICAgICAgIDwvRGVtbz5cclxuXHJcbiAgICAgICAgICAgIDxEZW1vIHRpdGxlPVwiVGFicyB3aXRoIGZhZGluZyBpbmRpY2F0b3JcIj5cclxuICAgICAgICAgICAgICAgIDxUYWJCYXJcclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZT17ZmFkZX1cclxuICAgICAgICAgICAgICAgICAgICBmYWRlXHJcbiAgICAgICAgICAgICAgICAgICAgb25DaGFuZ2U9e3ZhbHVlID0+IHNldEZhZGUodmFsdWUpfVxyXG4gICAgICAgICAgICAgICAgPlxyXG4gICAgICAgICAgICAgICAgICAgIDxUYWIgbGFiZWw9XCJUYWIgMVwiIC8+XHJcbiAgICAgICAgICAgICAgICAgICAgPFRhYiBsYWJlbD1cIlRhYiAyXCIgLz5cclxuICAgICAgICAgICAgICAgICAgICA8VGFiIGxhYmVsPVwiVGFiIDNcIiAvPlxyXG4gICAgICAgICAgICAgICAgPC9UYWJCYXI+XHJcbiAgICAgICAgICAgIDwvRGVtbz5cclxuXHJcbiAgICAgICAgICAgIDxEZW1vIHRpdGxlPVwiVGFicyB3aXRoIGljb25zXCI+XHJcbiAgICAgICAgICAgICAgICA8VGFiQmFyXHJcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU9e2ljb25zfVxyXG4gICAgICAgICAgICAgICAgICAgIG9uQ2hhbmdlPXt2YWx1ZSA9PiBzZXRJY29ucyh2YWx1ZSl9XHJcbiAgICAgICAgICAgICAgICA+XHJcbiAgICAgICAgICAgICAgICAgICAgPFRhYlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpY29uPVwic3RhclwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsPVwiVGFiIDFcIlxyXG4gICAgICAgICAgICAgICAgICAgIC8+XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIDxUYWJcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWNvbj1cImZhdm9yaXRlXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWw9XCJUYWIgMlwiXHJcbiAgICAgICAgICAgICAgICAgICAgLz5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgPFRhYlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpY29uPVwic2V0dGluZ3NcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBsYWJlbD1cIlRhYiAzXCJcclxuICAgICAgICAgICAgICAgICAgICAvPlxyXG4gICAgICAgICAgICAgICAgPC9UYWJCYXI+XHJcbiAgICAgICAgICAgIDwvRGVtbz5cclxuXHJcbiAgICAgICAgICAgIDxEZW1vIHRpdGxlPVwiVGFicyB3aXRoIHN0YWNrZWQgaWNvbnNcIj5cclxuICAgICAgICAgICAgICAgIDxUYWJCYXJcclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZT17c3RhY2tlZEljb25zfVxyXG4gICAgICAgICAgICAgICAgICAgIHN0YWNrZWRcclxuICAgICAgICAgICAgICAgICAgICBvbkNoYW5nZT17dmFsdWUgPT4gc2V0U3RhY2tlZEljb25zKHZhbHVlKX1cclxuICAgICAgICAgICAgICAgID5cclxuICAgICAgICAgICAgICAgICAgICA8VGFiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGljb249XCJzdGFyXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWw9XCJUYWIgMVwiXHJcbiAgICAgICAgICAgICAgICAgICAgLz5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgPFRhYlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpY29uPVwiZmF2b3JpdGVcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBsYWJlbD1cIlRhYiAyXCJcclxuICAgICAgICAgICAgICAgICAgICAvPlxyXG5cclxuICAgICAgICAgICAgICAgICAgICA8VGFiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGljb249XCJzZXR0aW5nc1wiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsPVwiVGFiIDNcIlxyXG4gICAgICAgICAgICAgICAgICAgIC8+XHJcbiAgICAgICAgICAgICAgICA8L1RhYkJhcj5cclxuICAgICAgICAgICAgPC9EZW1vPlxyXG5cclxuICAgICAgICAgICAgPERlbW8gdGl0bGU9XCJUYWJzIHdpdGggaWNvbnMgb25seVwiPlxyXG4gICAgICAgICAgICAgICAgPFRhYkJhclxyXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlPXtvbmx5SWNvbnN9XHJcbiAgICAgICAgICAgICAgICAgICAgaW5kaWNhdG9ySWNvbj1cInN0YXJcIlxyXG4gICAgICAgICAgICAgICAgICAgIG9uQ2hhbmdlPXt2YWx1ZSA9PiBzZXRPbmx5SWNvbnModmFsdWUpfVxyXG4gICAgICAgICAgICAgICAgPlxyXG4gICAgICAgICAgICAgICAgICAgIDxUYWJcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWNvbj1cInN0YXJcIlxyXG4gICAgICAgICAgICAgICAgICAgIC8+XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIDxUYWJcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWNvbj1cImZhdm9yaXRlXCJcclxuICAgICAgICAgICAgICAgICAgICAvPlxyXG5cclxuICAgICAgICAgICAgICAgICAgICA8VGFiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGljb249XCJzZXR0aW5nc1wiXHJcbiAgICAgICAgICAgICAgICAgICAgLz5cclxuICAgICAgICAgICAgICAgIDwvVGFiQmFyPlxyXG4gICAgICAgICAgICA8L0RlbW8+XHJcblxyXG4gICAgICAgICAgICA8RGVtbyB0aXRsZT1cIlRhYnMgd2l0aCBpY29uIGluZGljYXRvclwiPlxyXG4gICAgICAgICAgICAgICAgPFRhYkJhclxyXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlPXtpY29uSW5kaWNhdG9yfVxyXG4gICAgICAgICAgICAgICAgICAgIG9uQ2hhbmdlPXt2YWx1ZSA9PiBzZXRJY29uSW5kaWNhdG9yKHZhbHVlKX1cclxuICAgICAgICAgICAgICAgID5cclxuICAgICAgICAgICAgICAgICAgICA8VGFiIGxhYmVsPVwiVGFiIDFcIiAvPlxyXG4gICAgICAgICAgICAgICAgICAgIDxUYWIgbGFiZWw9XCJUYWIgMlwiIC8+XHJcbiAgICAgICAgICAgICAgICAgICAgPFRhYiBsYWJlbD1cIlRhYiAzXCIgLz5cclxuICAgICAgICAgICAgICAgIDwvVGFiQmFyPlxyXG4gICAgICAgICAgICA8L0RlbW8+XHJcblxyXG4gICAgICAgICAgICA8RGVtbyB0aXRsZT1cIlNjcm9sbGluZyB0YWJzXCI+XHJcbiAgICAgICAgICAgICAgICA8VGFiQmFyXHJcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU9e3Njcm9sbH1cclxuICAgICAgICAgICAgICAgICAgICBvbkNoYW5nZT17dmFsdWUgPT4gc2V0U2Nyb2xsKHZhbHVlKX1cclxuICAgICAgICAgICAgICAgID5cclxuICAgICAgICAgICAgICAgICAgICA8VGFiIGxhYmVsPVwiVGFiIDFcIiAvPlxyXG4gICAgICAgICAgICAgICAgICAgIDxUYWIgbGFiZWw9XCJUYWIgMlwiIC8+XHJcbiAgICAgICAgICAgICAgICAgICAgPFRhYiBsYWJlbD1cIlRhYiAzXCIgLz5cclxuICAgICAgICAgICAgICAgICAgICA8VGFiIGxhYmVsPVwiVGFiIDRcIiAvPlxyXG4gICAgICAgICAgICAgICAgICAgIDxUYWIgbGFiZWw9XCJUYWIgNVwiIC8+XHJcbiAgICAgICAgICAgICAgICAgICAgPFRhYiBsYWJlbD1cIlRhYiA2XCIgLz5cclxuICAgICAgICAgICAgICAgICAgICA8VGFiIGxhYmVsPVwiVGFiIDdcIiAvPlxyXG4gICAgICAgICAgICAgICAgICAgIDxUYWIgbGFiZWw9XCJUYWIgOFwiIC8+XHJcbiAgICAgICAgICAgICAgICAgICAgPFRhYiBsYWJlbD1cIlRhYiA5XCIgLz5cclxuICAgICAgICAgICAgICAgICAgICA8VGFiIGxhYmVsPVwiVGFiIDEwXCIgLz5cclxuICAgICAgICAgICAgICAgICAgICA8VGFiIGxhYmVsPVwiVGFiIDExXCIgLz5cclxuICAgICAgICAgICAgICAgICAgICA8VGFiIGxhYmVsPVwiVGFiIDEyXCIgLz5cclxuICAgICAgICAgICAgICAgICAgICA8VGFiIGxhYmVsPVwiVGFiIDEzXCIgLz5cclxuICAgICAgICAgICAgICAgICAgICA8VGFiIGxhYmVsPVwiVGFiIDE0XCIgLz5cclxuICAgICAgICAgICAgICAgICAgICA8VGFiIGxhYmVsPVwiVGFiIDE1XCIgLz5cclxuICAgICAgICAgICAgICAgIDwvVGFiQmFyPlxyXG4gICAgICAgICAgICA8L0RlbW8+XHJcbiAgICAgICAgPC9QYWdlPlxyXG4gICAgKTtcclxufSIsImltcG9ydCB7IHVzZVN0YXRlIH0gZnJvbSAncmVhY3QnO1xyXG5pbXBvcnQge1xyXG4gICAgVGFiQmFyLCBUYWIsXHJcbiAgICBUZXh0RmllbGRcclxufSBmcm9tICdtZGMtcmVhY3QnO1xyXG5cclxuaW1wb3J0IERlbW8gZnJvbSAnQC9jb21wb25lbnRzL0RlbW8nO1xyXG5pbXBvcnQgRmllbGRTZXQgZnJvbSAnQC9jb21wb25lbnRzL0ZpZWxkU2V0JztcclxuaW1wb3J0IFBhZ2UgZnJvbSAnQC9jb21wb25lbnRzL1BhZ2UnO1xyXG5cclxuY29uc3QgaWQgPSAndGV4dC1maWVsZCc7XHJcbmNvbnN0IHRpdGxlID0gJ1RleHQgRmllbGQnO1xyXG5jb25zdCBkZXNjcmlwdGlvbiA9ICdUZXh0IGZpZWxkcyBsZXQgdXNlcnMgZW50ZXIgYW5kIGVkaXQgdGV4dC4nO1xyXG5jb25zdCBsaW5rcyA9IHtcclxuICAgIGRvY3M6ICdodHRwczovL2dpdGh1Yi5jb20vbWF0ZXJpYWwtY29tcG9uZW50cy9tYXRlcmlhbC1jb21wb25lbnRzLXdlYi90cmVlL21hc3Rlci9wYWNrYWdlcy9tZGMtdGV4dGZpZWxkJyxcclxuICAgIGd1aWRlOiAnaHR0cHM6Ly9tYXRlcmlhbC5pby9jb21wb25lbnRzL3RleHQtZmllbGRzJ1xyXG59O1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gVHlwb2dyYXBoeVBhZ2UoKSB7XHJcbiAgICBjb25zdCBbdHlwZSwgc2V0VHlwZV0gPSB1c2VTdGF0ZSgnZmlsbGVkJyk7XHJcblxyXG4gICAgY29uc3QgaXNGaWxsZWQgPSB0eXBlID09PSAnZmlsbGVkJyB8fCB1bmRlZmluZWQ7XHJcbiAgICBjb25zdCBpc091dGxpbmVkID0gdHlwZSA9PT0gJ291dGxpbmVkJyB8fCB1bmRlZmluZWQ7XHJcblxyXG4gICAgcmV0dXJuIChcclxuICAgICAgICA8UGFnZSBpZD17aWR9IHRpdGxlPXt0aXRsZX0gZGVzY3JpcHRpb249e2Rlc2NyaXB0aW9ufSBsaW5rcz17bGlua3N9PlxyXG4gICAgICAgICAgICA8VGFiQmFyIHZhbHVlPXt0eXBlfSBvbkNoYW5nZT17c2V0VHlwZX0gbWluV2lkdGg+XHJcbiAgICAgICAgICAgICAgICA8VGFiXHJcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU9XCJmaWxsZWRcIlxyXG4gICAgICAgICAgICAgICAgICAgIGxhYmVsPVwiRmlsbGVkXCJcclxuICAgICAgICAgICAgICAgIC8+XHJcblxyXG4gICAgICAgICAgICAgICAgPFRhYlxyXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlPVwib3V0bGluZWRcIlxyXG4gICAgICAgICAgICAgICAgICAgIGxhYmVsPVwiT3V0bGluZWRcIlxyXG4gICAgICAgICAgICAgICAgLz5cclxuICAgICAgICAgICAgPC9UYWJCYXI+XHJcblxyXG4gICAgICAgICAgICA8RGVtbyB0aXRsZT1cIkJhc2ljIHRleHQgZmllbGRcIj5cclxuICAgICAgICAgICAgICAgIDxUZXh0RmllbGRcclxuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0VmFsdWU9XCJcIlxyXG4gICAgICAgICAgICAgICAgICAgIGZpbGxlZD17aXNGaWxsZWR9XHJcbiAgICAgICAgICAgICAgICAgICAgb3V0bGluZWQ9e2lzT3V0bGluZWR9XHJcbiAgICAgICAgICAgICAgICAvPlxyXG4gICAgICAgICAgICA8L0RlbW8+XHJcblxyXG4gICAgICAgICAgICA8RGVtbyB0aXRsZT1cIlRleHQgZmllbGQgd2l0aCBhIGxhYmVsXCI+XHJcbiAgICAgICAgICAgICAgICA8VGV4dEZpZWxkXHJcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdFZhbHVlPVwiXCJcclxuICAgICAgICAgICAgICAgICAgICBsYWJlbD1cIkxhYmVsXCJcclxuICAgICAgICAgICAgICAgICAgICBmaWxsZWQ9e2lzRmlsbGVkfVxyXG4gICAgICAgICAgICAgICAgICAgIG91dGxpbmVkPXtpc091dGxpbmVkfVxyXG4gICAgICAgICAgICAgICAgLz5cclxuICAgICAgICAgICAgPC9EZW1vPlxyXG5cclxuICAgICAgICAgICAgPERlbW8gdGl0bGU9XCJUZXh0YXJlYVwiPlxyXG4gICAgICAgICAgICAgICAgPFRleHRGaWVsZFxyXG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHRWYWx1ZT1cIlwiXHJcbiAgICAgICAgICAgICAgICAgICAgbGFiZWw9XCJMYWJlbFwiXHJcbiAgICAgICAgICAgICAgICAgICAgdGV4dGFyZWFcclxuICAgICAgICAgICAgICAgICAgICBmaWxsZWQ9e2lzRmlsbGVkfVxyXG4gICAgICAgICAgICAgICAgICAgIG91dGxpbmVkPXtpc091dGxpbmVkfVxyXG4gICAgICAgICAgICAgICAgLz5cclxuICAgICAgICAgICAgPC9EZW1vPlxyXG5cclxuICAgICAgICAgICAgPERlbW8gdGl0bGU9XCJBdXRvcmVzaXphYmxlIHRleHRhcmVhXCI+XHJcbiAgICAgICAgICAgICAgICA8VGV4dEZpZWxkXHJcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdFZhbHVlPVwiXCJcclxuICAgICAgICAgICAgICAgICAgICBsYWJlbD1cIkxhYmVsXCJcclxuICAgICAgICAgICAgICAgICAgICB0ZXh0YXJlYVxyXG4gICAgICAgICAgICAgICAgICAgIGF1dG9SZXNpemVcclxuICAgICAgICAgICAgICAgICAgICBmaWxsZWQ9e2lzRmlsbGVkfVxyXG4gICAgICAgICAgICAgICAgICAgIG91dGxpbmVkPXtpc091dGxpbmVkfVxyXG4gICAgICAgICAgICAgICAgLz5cclxuICAgICAgICAgICAgPC9EZW1vPlxyXG5cclxuICAgICAgICAgICAgPERlbW8gdGl0bGU9XCJQcmUtZmlsbGVkIHRleHQgZmllbGRcIj5cclxuICAgICAgICAgICAgICAgIDxUZXh0RmllbGRcclxuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0VmFsdWU9XCJTb21lIHRleHRcIlxyXG4gICAgICAgICAgICAgICAgICAgIGxhYmVsPVwiTGFiZWxcIlxyXG4gICAgICAgICAgICAgICAgICAgIGZpbGxlZD17aXNGaWxsZWR9XHJcbiAgICAgICAgICAgICAgICAgICAgb3V0bGluZWQ9e2lzT3V0bGluZWR9XHJcbiAgICAgICAgICAgICAgICAvPlxyXG4gICAgICAgICAgICA8L0RlbW8+XHJcblxyXG4gICAgICAgICAgICA8RGVtbyB0aXRsZT1cIldpdGggaGVscGVyIHRleHRcIj5cclxuICAgICAgICAgICAgICAgIDxUZXh0RmllbGRcclxuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0VmFsdWU9XCJcIlxyXG4gICAgICAgICAgICAgICAgICAgIGhlbHBlclRleHQ9XCJIZWxwZXIgdGV4dFwiXHJcbiAgICAgICAgICAgICAgICAgICAgZmlsbGVkPXtpc0ZpbGxlZH1cclxuICAgICAgICAgICAgICAgICAgICBvdXRsaW5lZD17aXNPdXRsaW5lZH1cclxuICAgICAgICAgICAgICAgIC8+XHJcbiAgICAgICAgICAgIDwvRGVtbz5cclxuXHJcbiAgICAgICAgICAgIDxEZW1vIHRpdGxlPVwiV2l0aCBwZXJzaXN0ZW50IGhlbHBlciB0ZXh0XCI+XHJcbiAgICAgICAgICAgICAgICA8VGV4dEZpZWxkXHJcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdFZhbHVlPVwiXCJcclxuICAgICAgICAgICAgICAgICAgICBwZXJzaXN0ZW50SGVscGVyVGV4dD1cIkhlbHBlciB0ZXh0XCJcclxuICAgICAgICAgICAgICAgICAgICBmaWxsZWQ9e2lzRmlsbGVkfVxyXG4gICAgICAgICAgICAgICAgICAgIG91dGxpbmVkPXtpc091dGxpbmVkfVxyXG4gICAgICAgICAgICAgICAgLz5cclxuICAgICAgICAgICAgPC9EZW1vPlxyXG5cclxuICAgICAgICAgICAgPERlbW8gdGl0bGU9XCJUZXh0IGZpZWxkIHdpdGggdmFsaWRhdGlvbiBtZXNzYWdlXCI+XHJcbiAgICAgICAgICAgICAgICA8VGV4dEZpZWxkXHJcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdFZhbHVlPVwiXCJcclxuICAgICAgICAgICAgICAgICAgICBsYWJlbD1cIkxhYmVsXCJcclxuICAgICAgICAgICAgICAgICAgICByZXF1aXJlZFxyXG4gICAgICAgICAgICAgICAgICAgIHZhbGlkYXRpb25NZXNzYWdlPVwiVmFsaWRhdGlvbiBtZXNzYWdlXCJcclxuICAgICAgICAgICAgICAgICAgICBmaWxsZWQ9e2lzRmlsbGVkfVxyXG4gICAgICAgICAgICAgICAgICAgIG91dGxpbmVkPXtpc091dGxpbmVkfVxyXG4gICAgICAgICAgICAgICAgLz5cclxuICAgICAgICAgICAgPC9EZW1vPlxyXG5cclxuICAgICAgICAgICAgPERlbW8gdGl0bGU9XCJUZXh0IGZpZWxkIHdpdGggYSBjaGFyYWN0ZXIgY291bnRlclwiPlxyXG4gICAgICAgICAgICAgICAgPFRleHRGaWVsZFxyXG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHRWYWx1ZT1cIlwiXHJcbiAgICAgICAgICAgICAgICAgICAgbGFiZWw9XCJMYWJlbFwiXHJcbiAgICAgICAgICAgICAgICAgICAgbWF4TGVuZ3RoPXsxMH1cclxuICAgICAgICAgICAgICAgICAgICBjaGFyYWN0ZXJDb3VudGVyXHJcbiAgICAgICAgICAgICAgICAgICAgZmlsbGVkPXtpc0ZpbGxlZH1cclxuICAgICAgICAgICAgICAgICAgICBvdXRsaW5lZD17aXNPdXRsaW5lZH1cclxuICAgICAgICAgICAgICAgIC8+XHJcbiAgICAgICAgICAgIDwvRGVtbz5cclxuXHJcbiAgICAgICAgICAgIDxEZW1vIHRpdGxlPVwiVGV4dCBmaWVsZCB3aXRoIGFuIGludGVybmFsIGNoYXJhY3RlciBjb3VudGVyXCI+XHJcbiAgICAgICAgICAgICAgICA8VGV4dEZpZWxkXHJcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdFZhbHVlPVwiXCJcclxuICAgICAgICAgICAgICAgICAgICBsYWJlbD1cIkxhYmVsXCJcclxuICAgICAgICAgICAgICAgICAgICBtYXhMZW5ndGg9ezEyMH1cclxuICAgICAgICAgICAgICAgICAgICBmaWxsZWQ9e2lzRmlsbGVkfVxyXG4gICAgICAgICAgICAgICAgICAgIG91dGxpbmVkPXtpc091dGxpbmVkfVxyXG4gICAgICAgICAgICAgICAgICAgIHRleHRhcmVhXHJcbiAgICAgICAgICAgICAgICAgICAgY2hhcmFjdGVyQ291bnRlcj1cImludGVybmFsXCJcclxuICAgICAgICAgICAgICAgIC8+XHJcbiAgICAgICAgICAgIDwvRGVtbz5cclxuXHJcbiAgICAgICAgICAgIDxEZW1vIHRpdGxlPVwiVGV4dCBmaWVsZCB3aXRoIGEgcHJlZml4XCI+XHJcbiAgICAgICAgICAgICAgICA8VGV4dEZpZWxkXHJcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdFZhbHVlPVwiXCJcclxuICAgICAgICAgICAgICAgICAgICBsYWJlbD1cIkxhYmVsXCJcclxuICAgICAgICAgICAgICAgICAgICBwcmVmaXg9XCJAXCJcclxuICAgICAgICAgICAgICAgICAgICBmaWxsZWQ9e2lzRmlsbGVkfVxyXG4gICAgICAgICAgICAgICAgICAgIG91dGxpbmVkPXtpc091dGxpbmVkfVxyXG4gICAgICAgICAgICAgICAgLz5cclxuICAgICAgICAgICAgPC9EZW1vPlxyXG5cclxuICAgICAgICAgICAgPERlbW8gdGl0bGU9XCJUZXh0IGZpZWxkIHdpdGggYSBzdWZmaXhcIj5cclxuICAgICAgICAgICAgICAgIDxUZXh0RmllbGRcclxuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0VmFsdWU9XCJcIlxyXG4gICAgICAgICAgICAgICAgICAgIGxhYmVsPVwiTGFiZWxcIlxyXG4gICAgICAgICAgICAgICAgICAgIHN1ZmZpeD1cIiRcIlxyXG4gICAgICAgICAgICAgICAgICAgIGZpbGxlZD17aXNGaWxsZWR9XHJcbiAgICAgICAgICAgICAgICAgICAgb3V0bGluZWQ9e2lzT3V0bGluZWR9XHJcbiAgICAgICAgICAgICAgICAvPlxyXG4gICAgICAgICAgICA8L0RlbW8+XHJcblxyXG4gICAgICAgICAgICA8RGVtbyB0aXRsZT1cIlRleHQgZmllbGQgd2l0aCBhIGxlYWRpbmcgaWNvblwiPlxyXG4gICAgICAgICAgICAgICAgPFRleHRGaWVsZFxyXG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHRWYWx1ZT1cIlwiXHJcbiAgICAgICAgICAgICAgICAgICAgbGVhZGluZ0ljb249XCJzdGFyXCJcclxuICAgICAgICAgICAgICAgICAgICBmaWxsZWQ9e2lzRmlsbGVkfVxyXG4gICAgICAgICAgICAgICAgICAgIG91dGxpbmVkPXtpc091dGxpbmVkfVxyXG4gICAgICAgICAgICAgICAgLz5cclxuICAgICAgICAgICAgPC9EZW1vPlxyXG5cclxuICAgICAgICAgICAgPERlbW8gdGl0bGU9XCJUZXh0IGZpZWxkIHdpdGggYSB0cmFpbGluZyBpY29uXCI+XHJcbiAgICAgICAgICAgICAgICA8VGV4dEZpZWxkXHJcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdFZhbHVlPVwiXCJcclxuICAgICAgICAgICAgICAgICAgICB0cmFpbGluZ0ljb249XCJlZGl0XCJcclxuICAgICAgICAgICAgICAgICAgICBmaWxsZWQ9e2lzRmlsbGVkfVxyXG4gICAgICAgICAgICAgICAgICAgIG91dGxpbmVkPXtpc091dGxpbmVkfVxyXG4gICAgICAgICAgICAgICAgLz5cclxuICAgICAgICAgICAgPC9EZW1vPlxyXG4gICAgICAgIDwvUGFnZT5cclxuICAgICk7XHJcbn0iLCJpbXBvcnQge1xyXG4gICAgSWNvbkJ1dHRvbixcclxuICAgIFRvb2x0aXAsIFJpY2hUb29sdGlwXHJcbn0gZnJvbSAnbWRjLXJlYWN0JztcclxuXHJcbmltcG9ydCBEZW1vIGZyb20gJ0AvY29tcG9uZW50cy9EZW1vJztcclxuaW1wb3J0IEZpZWxkU2V0IGZyb20gJ0AvY29tcG9uZW50cy9GaWVsZFNldCc7XHJcbmltcG9ydCBQYWdlIGZyb20gJ0AvY29tcG9uZW50cy9QYWdlJztcclxuXHJcbmNvbnN0IGlkID0gJ3Rvb2x0aXAnO1xyXG5jb25zdCB0aXRsZSA9ICdUb29sdGlwJztcclxuY29uc3QgZGVzY3JpcHRpb24gPSAnVG9vbHRpcHMgZGlzcGxheSBpbmZvcm1hdGl2ZSB0ZXh0IHdoZW4gdXNlcnMgaG92ZXIgb3ZlciwgZm9jdXMgb24sIG9yIHRhcCBhbiBlbGVtZW50Lic7XHJcbmNvbnN0IGxpbmtzID0ge1xyXG4gICAgZG9jczogJ2h0dHBzOi8vZ2l0aHViLmNvbS9tYXRlcmlhbC1jb21wb25lbnRzL21hdGVyaWFsLWNvbXBvbmVudHMtd2ViL3RyZWUvbWFzdGVyL3BhY2thZ2VzL21kYy10b29sdGlwJyxcclxuICAgIGd1aWRlOiAnaHR0cHM6Ly9tYXRlcmlhbC5pby9jb21wb25lbnRzL3Rvb2x0aXBzJ1xyXG59O1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gVG9vbHRpcFBhZ2UoKSB7XHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAgIDxQYWdlIGlkPXtpZH0gdGl0bGU9e3RpdGxlfSBkZXNjcmlwdGlvbj17ZGVzY3JpcHRpb259IGxpbmtzPXtsaW5rc30+XHJcbiAgICAgICAgICAgIDxEZW1vIHRpdGxlPVwiQmFzaWMgdG9vbHRpcFwiPlxyXG4gICAgICAgICAgICAgICAgPFRvb2x0aXAgbGFiZWw9XCJTdGFyXCI+XHJcbiAgICAgICAgICAgICAgICAgICAgPEljb25CdXR0b24gaWNvbj1cInN0YXJcIiAvPlxyXG4gICAgICAgICAgICAgICAgPC9Ub29sdGlwPlxyXG4gICAgICAgICAgICA8L0RlbW8+XHJcblxyXG4gICAgICAgICAgICA8RGVtbyB0aXRsZT1cIk11bHRpbGluZSB0b29sdGlwXCI+XHJcbiAgICAgICAgICAgICAgICA8VG9vbHRpcCBsYWJlbD1cIlRoaXMgaXMgYSBzdGFyIGljb24gYnV0dG9uLCB5b3Ugc2hvdWxkIGNsaWNrIG9uIGl0XCI+XHJcbiAgICAgICAgICAgICAgICAgICAgPEljb25CdXR0b24gaWNvbj1cInN0YXJcIiAvPlxyXG4gICAgICAgICAgICAgICAgPC9Ub29sdGlwPlxyXG4gICAgICAgICAgICA8L0RlbW8+XHJcblxyXG4gICAgICAgICAgICA8RGVtbyB0aXRsZT1cIlJpY2ggdG9vbHRpcFwiPlxyXG4gICAgICAgICAgICAgICAgPFJpY2hUb29sdGlwXHJcbiAgICAgICAgICAgICAgICAgICAgdGl0bGU9XCJUaXRsZVwiXHJcbiAgICAgICAgICAgICAgICAgICAgY29udGVudD1cIkRlZmF1bHQgcmljaCB0b29sdGlwcyBhcmUgc2hvd24gd2hlbiB1c2VycyBob3ZlciBvdmVyIG9yIGZvY3VzIG9uIHRoZWlyIGFuY2hvciBlbGVtZW50LiBUaGV5IHJlbWFpbiBzaG93biB3aGVuIHVzZXJzIGZvY3VzL2hvdmVyIG92ZXIgdGhlIGNvbnRlbnRzIG9mIHRoZSByaWNoIHRvb2x0aXAsIGJ1dCBiZWNvbWVzIGhpZGRlbiBpZiB0aGUgdXNlcnMgZm9jdXMvaG92ZXIgb3V0c2lkZSBvZiB0aGUgYW5jaG9yIGVsZW1lbnQgb3IgdGhlIHRvb2x0aXAgY29udGVudHMuIElmIHRoZSB1c2VyIGNsaWNrcyB3aXRoaW4gdGhlIGNvbnRlbnRzIG9mIHRoZSB0b29sdGlwLCB0aGUgdG9vbHRpcCB3aWxsIGFsc28gYmUgaGlkZGVuLlwiXHJcbiAgICAgICAgICAgICAgICA+XHJcbiAgICAgICAgICAgICAgICAgICAgPEljb25CdXR0b24gaWNvbj1cInN0YXJcIiAvPlxyXG4gICAgICAgICAgICAgICAgPC9SaWNoVG9vbHRpcD5cclxuICAgICAgICAgICAgPC9EZW1vPlxyXG4gICAgICAgIDwvUGFnZT5cclxuICAgICk7XHJcbn0iLCJpbXBvcnQgeyB1c2VTdGF0ZSB9IGZyb20gJ3JlYWN0JztcclxuaW1wb3J0IHtcclxuICAgIEljb25CdXR0b24sXHJcbiAgICBUb3BBcHBCYXJcclxufSBmcm9tICdtZGMtcmVhY3QnO1xyXG5cclxuaW1wb3J0IERlbW8gZnJvbSAnQC9jb21wb25lbnRzL0RlbW8nO1xyXG5pbXBvcnQgRmllbGRTZXQgZnJvbSAnQC9jb21wb25lbnRzL0ZpZWxkU2V0JztcclxuaW1wb3J0IFBhZ2UgZnJvbSAnQC9jb21wb25lbnRzL1BhZ2UnO1xyXG5cclxuaW1wb3J0ICcuL2luZGV4LnNjc3MnO1xyXG5cclxuY29uc3QgaWQgPSAndG9wLWFwcC1iYXInO1xyXG5jb25zdCB0aXRsZSA9ICdUb3AgQXBwIEJhcic7XHJcbmNvbnN0IGRlc2NyaXB0aW9uID0gJ1RoZSB0b3AgYXBwIGJhciBkaXNwbGF5cyBpbmZvcm1hdGlvbiBhbmQgYWN0aW9ucyByZWxhdGluZyB0byB0aGUgY3VycmVudCBzY3JlZW4uJztcclxuY29uc3QgbGlua3MgPSB7XHJcbiAgICBkb2NzOiAnaHR0cHM6Ly9naXRodWIuY29tL21hdGVyaWFsLWNvbXBvbmVudHMvbWF0ZXJpYWwtY29tcG9uZW50cy13ZWIvdHJlZS9tYXN0ZXIvcGFja2FnZXMvbWRjLXRvcC1hcHAtYmFyJyxcclxuICAgIGd1aWRlOiAnaHR0cHM6Ly9tYXRlcmlhbC5pby9jb21wb25lbnRzL2FwcC1iYXJzLXRvcCdcclxufTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIFRvcEFwcEJhclBhZ2UoKSB7XHJcbiAgICBjb25zdCBbaXNDb2xsYXBzZWQsIHNldENvbGxhcHNlZF0gPSB1c2VTdGF0ZShmYWxzZSk7XHJcblxyXG4gICAgY29uc3QgYWN0aW9uSXRlbXMgPSBbXHJcbiAgICAgICAgPEljb25CdXR0b24ga2V5PVwiYWRkXCIgaWNvbj1cImFkZFwiIC8+LFxyXG4gICAgICAgIDxJY29uQnV0dG9uIGtleT1cImVkaXRcIiBpY29uPVwiZWRpdFwiIC8+LFxyXG4gICAgICAgIDxJY29uQnV0dG9uIGtleT1cImRlbGV0ZVwiIGljb249XCJkZWxldGVcIiAvPlxyXG4gICAgXTtcclxuXHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAgIDxQYWdlIGlkPXtpZH0gdGl0bGU9e3RpdGxlfSBkZXNjcmlwdGlvbj17ZGVzY3JpcHRpb259IGxpbmtzPXtsaW5rc30+XHJcbiAgICAgICAgICAgIDxEZW1vPlxyXG4gICAgICAgICAgICAgICAgPFRvcEFwcEJhclxyXG4gICAgICAgICAgICAgICAgICAgIHRpdGxlPVwiQmFzaWNcIlxyXG4gICAgICAgICAgICAgICAgICAgIG5hdmlnYXRpb25JY29uPVwibWVudVwiXHJcbiAgICAgICAgICAgICAgICAgICAgYWN0aW9uSXRlbXM9e2FjdGlvbkl0ZW1zfVxyXG4gICAgICAgICAgICAgICAgLz5cclxuICAgICAgICAgICAgPC9EZW1vPlxyXG5cclxuICAgICAgICAgICAgPERlbW8+XHJcbiAgICAgICAgICAgICAgICA8VG9wQXBwQmFyXHJcbiAgICAgICAgICAgICAgICAgICAgdGl0bGU9XCJEZW5zZVwiXHJcbiAgICAgICAgICAgICAgICAgICAgbmF2aWdhdGlvbkljb249XCJtZW51XCJcclxuICAgICAgICAgICAgICAgICAgICBhY3Rpb25JdGVtcz17YWN0aW9uSXRlbXN9XHJcbiAgICAgICAgICAgICAgICAgICAgZGVuc2VcclxuICAgICAgICAgICAgICAgIC8+XHJcbiAgICAgICAgICAgIDwvRGVtbz5cclxuXHJcbiAgICAgICAgICAgIDxEZW1vPlxyXG4gICAgICAgICAgICAgICAgPFRvcEFwcEJhclxyXG4gICAgICAgICAgICAgICAgICAgIHRpdGxlPVwiUHJvbWluZW50XCJcclxuICAgICAgICAgICAgICAgICAgICBuYXZpZ2F0aW9uSWNvbj1cIm1lbnVcIlxyXG4gICAgICAgICAgICAgICAgICAgIGFjdGlvbkl0ZW1zPXthY3Rpb25JdGVtc31cclxuICAgICAgICAgICAgICAgICAgICBwcm9taW5lbnRcclxuICAgICAgICAgICAgICAgIC8+XHJcbiAgICAgICAgICAgIDwvRGVtbz5cclxuXHJcbiAgICAgICAgICAgIDxEZW1vPlxyXG4gICAgICAgICAgICAgICAgPFRvcEFwcEJhclxyXG4gICAgICAgICAgICAgICAgICAgIHRpdGxlPVwiU2hvcnRcIlxyXG4gICAgICAgICAgICAgICAgICAgIG5hdmlnYXRpb25JY29uPVwibWVudVwiXHJcbiAgICAgICAgICAgICAgICAgICAgc2hvcnRcclxuICAgICAgICAgICAgICAgICAgICBjb2xsYXBzZWQ9e2lzQ29sbGFwc2VkfVxyXG4gICAgICAgICAgICAgICAgICAgIG9uTmF2aWdhdGlvbkljb25DbGljaz17KCkgPT4gc2V0Q29sbGFwc2VkKHYgPT4gIXYpfVxyXG4gICAgICAgICAgICAgICAgLz5cclxuICAgICAgICAgICAgPC9EZW1vPlxyXG4gICAgICAgIDwvUGFnZT5cclxuICAgICk7XHJcbn0iLCJpbXBvcnQge1xyXG4gICAgVHlwb2dyYXBoeVxyXG59IGZyb20gJ21kYy1yZWFjdCc7XHJcblxyXG5pbXBvcnQgRGVtbyBmcm9tICdAL2NvbXBvbmVudHMvRGVtbyc7XHJcbmltcG9ydCBGaWVsZFNldCBmcm9tICdAL2NvbXBvbmVudHMvRmllbGRTZXQnO1xyXG5pbXBvcnQgUGFnZSBmcm9tICdAL2NvbXBvbmVudHMvUGFnZSc7XHJcblxyXG5jb25zdCBpZCA9ICd0eXBvZ3JhcGh5JztcclxuY29uc3QgdGl0bGUgPSAnVHlwb2dyYXBoeSc7XHJcbmNvbnN0IGRlc2NyaXB0aW9uID0gJ1R5cG9ncmFwaHkgZXhwcmVzc2VzIGhpZXJhcmNoeSBhbmQgYnJhbmQgcHJlc2VuY2UuJztcclxuY29uc3QgbGlua3MgPSB7XHJcbiAgICBkb2NzOiAnaHR0cHM6Ly9naXRodWIuY29tL21hdGVyaWFsLWNvbXBvbmVudHMvbWF0ZXJpYWwtY29tcG9uZW50cy13ZWIvdHJlZS9tYXN0ZXIvcGFja2FnZXMvbWRjLXR5cG9ncmFwaHknLFxyXG4gICAgZ3VpZGU6ICdodHRwczovL21hdGVyaWFsLmlvL2Rlc2lnbi90eXBvZ3JhcGh5J1xyXG59O1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gVHlwb2dyYXBoeVBhZ2UoKSB7XHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAgIDxQYWdlIGlkPXtpZH0gdGl0bGU9e3RpdGxlfSBkZXNjcmlwdGlvbj17ZGVzY3JpcHRpb259IGxpbmtzPXtsaW5rc30+XHJcbiAgICAgICAgICAgIDxEZW1vPlxyXG4gICAgICAgICAgICAgICAgPFR5cG9ncmFwaHkgdHlwZT1cImhlYWRsaW5lMVwiIG5vTWFyZ2luPkhlYWRsaW5lIDE8L1R5cG9ncmFwaHk+XHJcblxyXG4gICAgICAgICAgICAgICAgPFR5cG9ncmFwaHkgdHlwZT1cImhlYWRsaW5lMlwiIG5vTWFyZ2luPkhlYWRsaW5lIDI8L1R5cG9ncmFwaHk+XHJcblxyXG4gICAgICAgICAgICAgICAgPFR5cG9ncmFwaHkgdHlwZT1cImhlYWRsaW5lM1wiIG5vTWFyZ2luPkhlYWRsaW5lIDM8L1R5cG9ncmFwaHk+XHJcblxyXG4gICAgICAgICAgICAgICAgPFR5cG9ncmFwaHkgdHlwZT1cImhlYWRsaW5lNFwiIG5vTWFyZ2luPkhlYWRsaW5lIDQ8L1R5cG9ncmFwaHk+XHJcblxyXG4gICAgICAgICAgICAgICAgPFR5cG9ncmFwaHkgdHlwZT1cImhlYWRsaW5lNVwiIG5vTWFyZ2luPkhlYWRsaW5lIDU8L1R5cG9ncmFwaHk+XHJcblxyXG4gICAgICAgICAgICAgICAgPFR5cG9ncmFwaHkgdHlwZT1cImhlYWRsaW5lNlwiIG5vTWFyZ2luPkhlYWRsaW5lIDY8L1R5cG9ncmFwaHk+XHJcblxyXG4gICAgICAgICAgICAgICAgPFR5cG9ncmFwaHkgdHlwZT1cInN1YnRpdGxlMVwiIG5vTWFyZ2luPlN1YnRpdGxlIDE8L1R5cG9ncmFwaHk+XHJcblxyXG4gICAgICAgICAgICAgICAgPFR5cG9ncmFwaHkgdHlwZT1cInN1YnRpdGxlMlwiIG5vTWFyZ2luPlN1YnRpdGxlIDI8L1R5cG9ncmFwaHk+XHJcblxyXG4gICAgICAgICAgICAgICAgPFR5cG9ncmFwaHkgdHlwZT1cImJvZHkxXCIgbm9NYXJnaW4+Qm9keSAxPC9UeXBvZ3JhcGh5PlxyXG5cclxuICAgICAgICAgICAgICAgIDxUeXBvZ3JhcGh5IHR5cGU9XCJib2R5MlwiIG5vTWFyZ2luPkJvZHkgMjwvVHlwb2dyYXBoeT5cclxuXHJcbiAgICAgICAgICAgICAgICA8VHlwb2dyYXBoeSB0eXBlPVwiY2FwdGlvblwiPkNhcHRpb248L1R5cG9ncmFwaHk+XHJcblxyXG4gICAgICAgICAgICAgICAgPFR5cG9ncmFwaHkgdHlwZT1cImJ1dHRvblwiPkJ1dHRvbjwvVHlwb2dyYXBoeT5cclxuXHJcbiAgICAgICAgICAgICAgICA8VHlwb2dyYXBoeSB0eXBlPVwib3ZlcmxpbmVcIj5PdmVybGluZTwvVHlwb2dyYXBoeT5cclxuICAgICAgICAgICAgPC9EZW1vPlxyXG4gICAgICAgIDwvUGFnZT5cclxuICAgICk7XHJcbn0iLCJpbXBvcnQgQXZhdGFyIGZyb20gJy4vQXZhdGFyJztcclxuaW1wb3J0IEJhZGdlIGZyb20gJy4vQmFkZ2UnO1xyXG5pbXBvcnQgQmFubmVyIGZyb20gJy4vQmFubmVyJztcclxuaW1wb3J0IEJ1dHRvbiBmcm9tICcuL0J1dHRvbic7XHJcbmltcG9ydCBDYXJkIGZyb20gJy4vQ2FyZCc7XHJcbmltcG9ydCBDaGVja2JveCBmcm9tICcuL0NoZWNrYm94JztcclxuaW1wb3J0IENoaXBzIGZyb20gJy4vQ2hpcHMnO1xyXG5pbXBvcnQgQ2lyY3VsYXJQcm9ncmVzcyBmcm9tICcuL0NpcmN1bGFyUHJvZ3Jlc3MnO1xyXG5pbXBvcnQgRGF0YVRhYmxlIGZyb20gJy4vRGF0YVRhYmxlJztcclxuaW1wb3J0IERpYWxvZyBmcm9tICcuL0RpYWxvZyc7XHJcbmltcG9ydCBEcmF3ZXIgZnJvbSAnLi9EcmF3ZXInO1xyXG5pbXBvcnQgRWxldmF0aW9uIGZyb20gJy4vRWxldmF0aW9uJztcclxuaW1wb3J0IEZBQiBmcm9tICcuL0ZBQic7XHJcbmltcG9ydCBGb3JtRmllbGQgZnJvbSAnLi9Gb3JtRmllbGQnO1xyXG5pbXBvcnQgSG9tZSBmcm9tICcuL0hvbWUnO1xyXG5pbXBvcnQgSWNvbiBmcm9tICcuL0ljb24nO1xyXG5pbXBvcnQgSWNvbkJ1dHRvbiBmcm9tICcuL0ljb25CdXR0b24nO1xyXG5pbXBvcnQgSW1hZ2VMaXN0IGZyb20gJy4vSW1hZ2VMaXN0JztcclxuaW1wb3J0IExheW91dEdyaWQgZnJvbSAnLi9MYXlvdXRHcmlkJztcclxuaW1wb3J0IExpbmVhclByb2dyZXNzIGZyb20gJy4vTGluZWFyUHJvZ3Jlc3MnO1xyXG5pbXBvcnQgTGlzdCBmcm9tICcuL0xpc3QnO1xyXG5pbXBvcnQgTWVudSBmcm9tICcuL01lbnUnO1xyXG5pbXBvcnQgUmFkaW8gZnJvbSAnLi9SYWRpbyc7XHJcbmltcG9ydCBSaXBwbGUgZnJvbSAnLi9SaXBwbGUnO1xyXG5pbXBvcnQgU2VnbWVudGVkQnV0dG9uIGZyb20gJy4vU2VnbWVudGVkQnV0dG9uJztcclxuaW1wb3J0IFNlbGVjdCBmcm9tICcuL1NlbGVjdCc7XHJcbmltcG9ydCBTaWRlU2hlZXQgZnJvbSAnLi9TaWRlU2hlZXQnO1xyXG5pbXBvcnQgU2xpZGVyIGZyb20gJy4vU2xpZGVyJztcclxuaW1wb3J0IFNuYWNrYmFyIGZyb20gJy4vU25hY2tiYXInO1xyXG5pbXBvcnQgU3dpdGNoIGZyb20gJy4vU3dpdGNoJztcclxuaW1wb3J0IFN5bWJvbCBmcm9tICcuL1N5bWJvbCc7XHJcbmltcG9ydCBUYWJzIGZyb20gJy4vVGFicyc7XHJcbmltcG9ydCBUZXh0RmllbGQgZnJvbSAnLi9UZXh0RmllbGQnO1xyXG5pbXBvcnQgVG9vbHRpcCBmcm9tICcuL1Rvb2x0aXAnO1xyXG5pbXBvcnQgVG9wQXBwQmFyIGZyb20gJy4vVG9wQXBwQmFyJztcclxuaW1wb3J0IFR5cG9ncmFwaHkgZnJvbSAnLi9UeXBvZ3JhcGh5JztcclxuXHJcbmV4cG9ydCB7XHJcbiAgICBBdmF0YXIsXHJcbiAgICBCYWRnZSxcclxuICAgIEJhbm5lcixcclxuICAgIEJ1dHRvbixcclxuICAgIENhcmQsXHJcbiAgICBDaGVja2JveCxcclxuICAgIENoaXBzLFxyXG4gICAgQ2lyY3VsYXJQcm9ncmVzcyxcclxuICAgIERhdGFUYWJsZSxcclxuICAgIERpYWxvZyxcclxuICAgIERyYXdlcixcclxuICAgIEVsZXZhdGlvbixcclxuICAgIEZBQixcclxuICAgIEZvcm1GaWVsZCxcclxuICAgIEhvbWUsXHJcbiAgICBJY29uLFxyXG4gICAgSWNvbkJ1dHRvbixcclxuICAgIEltYWdlTGlzdCxcclxuICAgIExheW91dEdyaWQsXHJcbiAgICBMaW5lYXJQcm9ncmVzcyxcclxuICAgIExpc3QsXHJcbiAgICBNZW51LFxyXG4gICAgUmFkaW8sXHJcbiAgICBSaXBwbGUsXHJcbiAgICBTZWdtZW50ZWRCdXR0b24sXHJcbiAgICBTZWxlY3QsXHJcbiAgICBTaWRlU2hlZXQsXHJcbiAgICBTbGlkZXIsXHJcbiAgICBTbmFja2JhcixcclxuICAgIFN3aXRjaCxcclxuICAgIFN5bWJvbCxcclxuICAgIFRhYnMsXHJcbiAgICBUZXh0RmllbGQsXHJcbiAgICBUb29sdGlwLFxyXG4gICAgVG9wQXBwQmFyLFxyXG4gICAgVHlwb2dyYXBoeVxyXG59OyIsImltcG9ydCB7XHJcbiAgICBBdmF0YXIsXHJcbiAgICBCYWRnZSxcclxuICAgIEJhbm5lcixcclxuICAgIEJ1dHRvbixcclxuICAgIENhcmQsXHJcbiAgICBDaGVja2JveCxcclxuICAgIENoaXBzLFxyXG4gICAgQ2lyY3VsYXJQcm9ncmVzcyxcclxuICAgIERhdGFUYWJsZSxcclxuICAgIERpYWxvZyxcclxuICAgIERyYXdlcixcclxuICAgIEVsZXZhdGlvbixcclxuICAgIEZBQixcclxuICAgIEZvcm1GaWVsZCxcclxuICAgIEljb24sXHJcbiAgICBJY29uQnV0dG9uLFxyXG4gICAgSW1hZ2VMaXN0LFxyXG4gICAgTGF5b3V0R3JpZCxcclxuICAgIExpbmVhclByb2dyZXNzLFxyXG4gICAgTGlzdCxcclxuICAgIE1lbnUsXHJcbiAgICBSYWRpbyxcclxuICAgIFJpcHBsZSxcclxuICAgIFNlZ21lbnRlZEJ1dHRvbixcclxuICAgIFNlbGVjdCxcclxuICAgIFNpZGVTaGVldCxcclxuICAgIFNsaWRlcixcclxuICAgIFNuYWNrYmFyLFxyXG4gICAgU3dpdGNoLFxyXG4gICAgU3ltYm9sLFxyXG4gICAgVGFicyxcclxuICAgIFRleHRGaWVsZCxcclxuICAgIFRvb2x0aXAsXHJcbiAgICBUb3BBcHBCYXIsXHJcbiAgICBUeXBvZ3JhcGh5XHJcbn0gZnJvbSAnLi9wYWdlcyc7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBbXHJcbiAgICB7IHRpdGxlOiAnQXZhdGFyJywgdXJsOiAnL2F2YXRhcicsIGNvbXBvbmVudDogQXZhdGFyLCBpY29uOiAnYWNjb3VudF9jaXJjbGUnIH0sXHJcbiAgICB7IHRpdGxlOiAnQmFkZ2UnLCB1cmw6ICcvYmFkZ2UnLCBjb21wb25lbnQ6IEJhZGdlLCBpY29uOiAnbWFya19lbWFpbF91bnJlYWQnIH0sXHJcbiAgICB7IHRpdGxlOiAnQmFubmVyJywgdXJsOiAnL2Jhbm5lcicsIGNvbXBvbmVudDogQmFubmVyLCBpY29uOiAnZXJyb3Jfb3V0bGluZScsIGltYWdlVXJsOiAnaHR0cHM6Ly9saDMuZ29vZ2xldXNlcmNvbnRlbnQuY29tL3RPWmRXYmZXdEljNUdIVFdzVzBEYXFqNUk2bENDclVOOC1ZdUVWalNuODdKTk42eDZQRWpmbW5lLWdwQm80akhCSTRncUxtaTBrTFZwdWJGNDFaVDJtTThnbGtMem8yaVdnS18talk9dzc2MC1oMzgwJyB9LFxyXG4gICAgeyB0aXRsZTogJ0J1dHRvbicsIHVybDogJy9idXR0b24nLCBjb21wb25lbnQ6IEJ1dHRvbiwgaWNvbjogJ2Nyb3BfN181JywgaW1hZ2VVcmw6ICdodHRwczovL2xoMy5nb29nbGV1c2VyY29udGVudC5jb20vR0hSei01UzAwdTdXa1JHbDhpVW04ZXpvUjZlb0IyTkp6dHUtdHJKdjNyYU1EdnBTQUNlUTVPMEtPb0FHN1NSSEpORE1fbVQwNEhlaTFOd2pUTi1ac0lGbXNfYnNRNHp4Unl4ZFFRPXc3NjAtaDM4MCcgfSxcclxuICAgIHsgdGl0bGU6ICdDYXJkJywgdXJsOiAnL2NhcmQnLCBjb21wb25lbnQ6IENhcmQsIGljb246ICd3eXNpd3lnJywgaW1hZ2VVcmw6ICdodHRwczovL2xoMy5nb29nbGV1c2VyY29udGVudC5jb20vRnlFM3FqR3d3bm9lTWdpeU91SXhkeFRRUU05Q3IwZnROYWtPWE9BOGNwMTM3cktOMDlCRkhyYUVSbTFOUFVGQlRHeFZnY2hrZGw2VUFCYzExWmNKRE1MNHVpNDY2VzJCRkl4YzlRPXc3NjAtaDM4MCcgfSxcclxuICAgIHsgdGl0bGU6ICdDaGVja2JveCcsIHVybDogJy9jaGVja2JveCcsIGNvbXBvbmVudDogQ2hlY2tib3gsIGljb246ICdjaGVja19ib3gnIH0sXHJcbiAgICB7IHRpdGxlOiAnQ2hpcHMnLCB1cmw6ICcvY2hpcHMnLCBjb21wb25lbnQ6IENoaXBzLCBpY29uOiAnbGFiZWwnIH0sXHJcbiAgICB7IHRpdGxlOiAnQ2lyY3VsYXIgUHJvZ3Jlc3MnLCB1cmw6ICcvY2lyY3VsYXItcHJvZ3Jlc3MnLCBjb21wb25lbnQ6IENpcmN1bGFyUHJvZ3Jlc3MsIGljb246ICdjaXJjbGUnIH0sXHJcbiAgICB7IHRpdGxlOiAnRGF0YVRhYmxlJywgdXJsOiAnL2RhdGEtdGFibGUnLCBjb21wb25lbnQ6IERhdGFUYWJsZSwgaWNvbjogJ3RhYmxlX2NoYXJ0JyB9LFxyXG4gICAgeyB0aXRsZTogJ0RpYWxvZycsIHVybDogJy9kaWFsb2cnLCBjb21wb25lbnQ6IERpYWxvZywgaWNvbjogJ3ZpZGVvX2xhYmVsJyB9LFxyXG4gICAgeyB0aXRsZTogJ0RyYXdlcicsIHVybDogJy9kcmF3ZXInLCBjb21wb25lbnQ6IERyYXdlciwgaWNvbjogJ3ZpZXdfcXVpbHQnIH0sXHJcbiAgICB7IHRpdGxlOiAnRWxldmF0aW9uJywgdXJsOiAnL2VsZXZhdGlvbicsIGNvbXBvbmVudDogRWxldmF0aW9uLCBpY29uOiAnbGF5ZXJzJyB9LFxyXG4gICAgeyB0aXRsZTogJ0ZBQicsIHVybDogJy9mYWInLCBjb21wb25lbnQ6IEZBQiwgaWNvbjogJ2FkZF9jaXJjbGUnLCBpbWFnZVVybDogJ2h0dHBzOi8vbGgzLmdvb2dsZXVzZXJjb250ZW50LmNvbS9UOGRsWXphYVUyU1Y4Nng2bHFOTWpsSGNyRmRLdjg1UU1XMVVuSlNoR3drbFJReXVVcVpJa2xPam5FdXFyWnpGMWg4NG9ocnp6MklUYWpiVDlJZGxqb2ZORm1QNWNzRXE2RzdXPXc3NjAtaDM4MCcgfSxcclxuICAgIHsgdGl0bGU6ICdGb3JtIEZpZWxkJywgdXJsOiAnL2Zvcm0tZmllbGQnLCBjb21wb25lbnQ6IEZvcm1GaWVsZCwgaWNvbjogJ3Nob3J0X3RleHQnIH0sXHJcbiAgICB7IHRpdGxlOiAnSWNvbicsIHVybDogJy9pY29uJywgY29tcG9uZW50OiBJY29uLCBpY29uOiAnY2F0ZWdvcnknIH0sXHJcbiAgICB7IHRpdGxlOiAnSWNvbiBCdXR0b24nLCB1cmw6ICcvaWNvbi1idXR0b24nLCBjb21wb25lbnQ6IEljb25CdXR0b24sIGljb246ICdpbmZvJyB9LFxyXG4gICAgeyB0aXRsZTogJ0ltYWdlIExpc3QnLCB1cmw6ICcvaW1hZ2UtbGlzdCcsIGNvbXBvbmVudDogSW1hZ2VMaXN0LCBpY29uOiAnZGFzaGJvYXJkJyB9LFxyXG4gICAgeyB0aXRsZTogJ0xheW91dCBHcmlkJywgdXJsOiAnL2xheW91dC1ncmlkJywgY29tcG9uZW50OiBMYXlvdXRHcmlkLCBpY29uOiAnY2FsZW5kYXJfdmlld19tb250aCcgfSxcclxuICAgIHsgdGl0bGU6ICdMaW5lYXIgUHJvZ3Jlc3MnLCB1cmw6ICcvbGluZWFyLXByb2dyZXNzJywgY29tcG9uZW50OiBMaW5lYXJQcm9ncmVzcywgaWNvbjogJ2hvcml6b250YWxfcnVsZScgfSxcclxuICAgIHsgdGl0bGU6ICdMaXN0JywgdXJsOiAnL2xpc3QnLCBjb21wb25lbnQ6IExpc3QsIGljb246ICdmb3JtYXRfbGlzdF9idWxsZXRlZCcgfSxcclxuICAgIHsgdGl0bGU6ICdNZW51JywgdXJsOiAnL21lbnUnLCBjb21wb25lbnQ6IE1lbnUsIGljb246ICdsaXN0X2FsdCcgfSxcclxuICAgIHsgdGl0bGU6ICdSYWRpbycsIHVybDogJy9yYWRpbycsIGNvbXBvbmVudDogUmFkaW8sIGljb246ICdyYWRpb19idXR0b25fY2hlY2tlZCcgfSxcclxuICAgIHsgdGl0bGU6ICdSaXBwbGUnLCB1cmw6ICcvcmlwcGxlJywgY29tcG9uZW50OiBSaXBwbGUsIGljb246ICdhZHNfY2xpY2snIH0sXHJcbiAgICB7IHRpdGxlOiAnU2VnbWVudGVkIEJ1dHRvbicsIHVybDogJy9zZWdtZW50ZWQtYnV0dG9uJywgaWNvbjogJ2xpbmVhcl9zY2FsZScsIGNvbXBvbmVudDogU2VnbWVudGVkQnV0dG9uLCBpbWFnZVVybDogJycgfSxcclxuICAgIHsgdGl0bGU6ICdTZWxlY3QnLCB1cmw6ICcvc2VsZWN0JywgY29tcG9uZW50OiBTZWxlY3QsIGljb246ICdiYWxsb3QnLCBpbWFnZVVybDogJycgfSxcclxuICAgIHsgdGl0bGU6ICdTaWRlIFNoZWV0JywgdXJsOiAnL3NpZGUtc2hlZXQnLCBjb21wb25lbnQ6IFNpZGVTaGVldCwgaWNvbjogJ3ZpZXdfc2lkZWJhcicsIGltYWdlVXJsOiAnJyB9LFxyXG4gICAgeyB0aXRsZTogJ1NsaWRlcicsIHVybDogJy9zbGlkZXInLCBjb21wb25lbnQ6IFNsaWRlciwgaWNvbjogJ2NvbW1pdCcsIGltYWdlVXJsOiAnaHR0cHM6Ly9saDMuZ29vZ2xldXNlcmNvbnRlbnQuY29tL3c2bk5lTGNqcFh5cG8yVTZfZ3Z1blVlc2dUTk9BcXpFemI1Wnp4eFQ0QXlHSF9NX0xfRUhyeWJnOXNKTmc3OEJESHllQ1BJUUNlM0hrMnNUZ2xVMEVRZTdjT0JzcVVNRmljcTFsZz13NzYwLWgzODAnIH0sXHJcbiAgICB7IHRpdGxlOiAnU25hY2tiYXInLCB1cmw6ICcvc25hY2tiYXInLCBjb21wb25lbnQ6IFNuYWNrYmFyLCBpY29uOiAnY2FsbF90b19hY3Rpb24nLCBpbWFnZVVybDogJ2h0dHBzOi8vbGgzLmdvb2dsZXVzZXJjb250ZW50LmNvbS9mR2daUERPc3pURC0yUmVBQzg1bDVvcDd3Q0UzdXZuUHRhMTNBaWIyYlNsek44TFhvTllsREc2Zlk1RFkxcUtxYkxUYkdHbHg5VmdhaFVEZGpEZ2RqcThzSk5xb0lZNC1HUHhLUkE9dzc2MC1oMzgwJyB9LFxyXG4gICAgeyB0aXRsZTogJ1N3aXRjaCcsIHVybDogJy9zd2l0Y2gnLCBjb21wb25lbnQ6IFN3aXRjaCwgaWNvbjogJ3RvZ2dsZV9vbicgfSxcclxuICAgIHsgdGl0bGU6ICdTeW1ib2wnLCB1cmw6ICcvc3ltYm9sJywgY29tcG9uZW50OiBTeW1ib2wsIGljb246ICdjYXRlZ29yeScgfSxcclxuICAgIHsgdGl0bGU6ICdUYWJzJywgdXJsOiAnL3RhYnMnLCBjb21wb25lbnQ6IFRhYnMsIGljb246ICd0YWInLCBpbWFnZVVybDogJ2h0dHBzOi8vbGgzLmdvb2dsZXVzZXJjb250ZW50LmNvbS9BWUZwMlZtTW45bnNseDE4TTZFczlDNTdTN3AzemtpUVZMbDNQSHZNdS1PcGJ2SzFGbExKTjJNSGZGTlpmbWZNQ2sxZHJDdzg0RktlYno1U1RKN1FONjlJSGhIOVdGMUtrbGlyPXc3NjAtaDM4MCcgfSxcclxuICAgIHsgdGl0bGU6ICdUZXh0IEZpZWxkJywgdXJsOiAnL3RleHQtZmllbGQnLCBjb21wb25lbnQ6IFRleHRGaWVsZCwgaWNvbjogJ3RleHRfZmllbGRzJywgaW1hZ2VVcmw6ICdodHRwczovL2xoMy5nb29nbGV1c2VyY29udGVudC5jb20vTHhiX2paZlhrQVNaMURDek5oeVMzSUc3bUlzUGhCVm1hWDIwSG43WG53cFNfUG85d1FJQy01ckV3VXNZbGI1VGtnTWpxSTQ1LWoxdzRpNFdNNHdTbEEtYjBxS3RtSjY5aFYwaj13NzYwLWgzODAnIH0sXHJcbiAgICB7IHRpdGxlOiAnVG9vbHRpcCcsIHVybDogJy90b29sdGlwJywgY29tcG9uZW50OiBUb29sdGlwLCBpY29uOiAnZmlsdGVyX2ZyYW1lcycsIGltYWdlVXJsOiAnaHR0cHM6Ly9saDMuZ29vZ2xldXNlcmNvbnRlbnQuY29tL0FzbTFLSFBzVUQtR0REZ2xjSXR6dmwyTEtXc3lyTXpLTXJXREE1c2lIYUY3UEF2bmduaVM1N1BNWlRIRnNESGtIc2pUOWRQV0M1dEVwUkJHN2k1c3laN3NiUmlScEw5b0U4NEY9dzc2MC1oMzgwJyB9LFxyXG4gICAgeyB0aXRsZTogJ1RvcCBBcHAgQmFyJywgdXJsOiAnL3RvcC1hcHAtYmFyJywgY29tcG9uZW50OiBUb3BBcHBCYXIsIGljb246ICd2aWV3X2NvbXBhY3QnLCBpbWFnZVVybDogJ2h0dHBzOi8vbGgzLmdvb2dsZXVzZXJjb250ZW50LmNvbS9lb3Q5NmEtcWpBcjBReXBLS2YtNnFTSkdRUXFXMDg2LUdWMnZ2MEQ5RjM1OC1WRmlKU1dpZmc2LXEzOHZiSV9Kc3hDUG5iSk56akNIMTJPRkRYSkJ6U2NCM2hfX0hYTHdLV2tqWUE9dzc2MC1oMzgwJyB9LFxyXG4gICAgeyB0aXRsZTogJ1R5cG9ncmFwaHknLCB1cmw6ICcvdHlwb2dyYXBoeScsIGNvbXBvbmVudDogVHlwb2dyYXBoeSwgaWNvbjogJ3RpdGxlJyB9LFxyXG5dOyIsImltcG9ydCB7IHVzZUVmZmVjdCB9IGZyb20gJ3JlYWN0JztcclxuaW1wb3J0IHsgUm91dGUsIExpbmssIE5hdkxpbmssIFN3aXRjaCB9IGZyb20gJ3JlYWN0LXJvdXRlci1kb20nO1xyXG5pbXBvcnQge1xyXG4gICAgRHJhd2VyLFxyXG4gICAgSWNvbixcclxuICAgIEljb25CdXR0b24sXHJcbiAgICBMaXN0LFxyXG4gICAgVG9wQXBwQmFyXHJcbn0gZnJvbSAnbWRjLXJlYWN0JztcclxuXHJcbmltcG9ydCByb3V0ZXMgZnJvbSAnLi9yb3V0ZXMnO1xyXG5pbXBvcnQgeyBIb21lIH0gZnJvbSAnLi9wYWdlcyc7XHJcblxyXG5pbXBvcnQgJy4vQXBwLnNjc3MnO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gQXBwKCkge1xyXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgICAgICBjb25zdCBhY3RpdmVOYXZJdGVtID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLmFwcC1kcmF3ZXIgLm1kYy1saXN0LWl0ZW0tLWFjdGl2YXRlZCcpO1xyXG5cclxuICAgICAgICBpZiAoYWN0aXZlTmF2SXRlbSkge1xyXG4gICAgICAgICAgICBhY3RpdmVOYXZJdGVtLnNjcm9sbEludG9WaWV3KHsgYmVoYXZpb3I6ICdzbW9vdGgnLCBibG9jazogJ2NlbnRlcicgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSwgW10pO1xyXG5cclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJhcHAgbWRjLXR5cG9ncmFwaHkgbWRjLXRoZW1lLS1kYXJrXCI+XHJcbiAgICAgICAgICAgIDxUb3BBcHBCYXJcclxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZT1cImFwcC10b3AtYmFyXCJcclxuICAgICAgICAgICAgICAgIG5hdmlnYXRpb25JY29uPXtcclxuICAgICAgICAgICAgICAgICAgICA8SWNvbkJ1dHRvblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpY29uPXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxMaW5rIHRvPVwiL1wiPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxpbWcgc3JjPVwiaHR0cHM6Ly9tYXRlcmlhbC1jb21wb25lbnRzLmdpdGh1Yi5pby9tYXRlcmlhbC1jb21wb25lbnRzLXdlYi1jYXRhbG9nL3N0YXRpYy9tZWRpYS9pY19jb21wb25lbnRfMjRweF93aGl0ZS5zdmdcIiBhbHQ9XCJcIiAvPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9MaW5rPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgLz5cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRpdGxlPXs8TGluayB0bz1cIi9cIiBjbGFzc05hbWU9XCJhcHAtaG9tZS1saW5rXCI+TURDIFJlYWN0PC9MaW5rPn1cclxuICAgICAgICAgICAgICAgIGFjdGlvbkl0ZW1zPXtbXHJcbiAgICAgICAgICAgICAgICAgICAgPEljb25CdXR0b25cclxuICAgICAgICAgICAgICAgICAgICAgICAga2V5PVwiY29kZVwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnQ9XCJhXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgaHJlZj1cImh0dHBzOi8vZ2l0aHViLmNvbS9vbGVncG9seWFrb3YvbWRjLXJlYWN0XCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0PVwiX2JsYW5rXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWNvbj1cImNvZGVcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aXRsZT1cIkNvZGVcIlxyXG4gICAgICAgICAgICAgICAgICAgIC8+LFxyXG4gICAgICAgICAgICAgICAgICAgIDxJY29uQnV0dG9uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleT1cImlzc3Vlc1wiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnQ9XCJhXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgaHJlZj1cImh0dHBzOi8vZ2l0aHViLmNvbS9vbGVncG9seWFrb3YvbWRjLXJlYWN0L2lzc3Vlc1wiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldD1cIl9ibGFua1wiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGljb249XCJidWdfcmVwb3J0XCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGU9XCJJc3N1ZXNcIlxyXG4gICAgICAgICAgICAgICAgICAgIC8+LFxyXG4gICAgICAgICAgICAgICAgICAgIDxJY29uQnV0dG9uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleT1cImRpc2N1c3Npb25zXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudD1cImFcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBocmVmPVwiaHR0cHM6Ly9naXRodWIuY29tL29sZWdwb2x5YWtvdi9tZGMtcmVhY3QvZGlzY3Vzc2lvbnNcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXQ9XCJfYmxhbmtcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpY29uPVwiZm9ydW1cIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aXRsZT1cIkRpc2N1c3Npb25zXCJcclxuICAgICAgICAgICAgICAgICAgICAvPlxyXG4gICAgICAgICAgICAgICAgXX1cclxuICAgICAgICAgICAgLz5cclxuXHJcbiAgICAgICAgICAgIDxEcmF3ZXIgY2xhc3NOYW1lPVwiYXBwLWRyYXdlclwiIGRpc21pc3NpYmxlIG9wZW4+XHJcbiAgICAgICAgICAgICAgICA8RHJhd2VyLkNvbnRlbnQ+XHJcbiAgICAgICAgICAgICAgICAgICAgPExpc3QgZWxlbWVudD1cIm5hdlwiPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB7cm91dGVzLm1hcChyb3V0ZSA9PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPExpc3QuSXRlbVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleT17cm91dGUudXJsfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudD17TmF2TGlua31cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0bz17cm91dGUudXJsfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxlYWRpbmdJY29uPXs8SWNvbiB0eXBlPVwib3V0bGluZWRcIj57cm91dGUuaWNvbn08L0ljb24+fVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByaW1hcnlUZXh0PXtyb3V0ZS50aXRsZX1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhY3RpdmVDbGFzc05hbWU9XCJtZGMtbGlzdC1pdGVtLS1hY3RpdmF0ZWRcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLz5cclxuICAgICAgICAgICAgICAgICAgICAgICAgKX1cclxuICAgICAgICAgICAgICAgICAgICA8L0xpc3Q+XHJcbiAgICAgICAgICAgICAgICA8L0RyYXdlci5Db250ZW50PlxyXG4gICAgICAgICAgICA8L0RyYXdlcj5cclxuXHJcbiAgICAgICAgICAgIDxtYWluIGNsYXNzTmFtZT1cImFwcC1jb250ZW50IG1kYy1kcmF3ZXItYXBwLWNvbnRlbnRcIj5cclxuICAgICAgICAgICAgICAgIDxTd2l0Y2g+XHJcbiAgICAgICAgICAgICAgICAgICAgPFJvdXRlIGV4YWN0IHBhdGg9XCIvXCIgY29tcG9uZW50PXtIb21lfSAvPlxyXG5cclxuICAgICAgICAgICAgICAgICAgICB7cm91dGVzLm1hcChyb3V0ZSA9PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8Um91dGVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleT17cm91dGUudXJsfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGF0aD17cm91dGUudXJsfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhhY3Q9e3JvdXRlLmV4YWN0fVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50PXtyb3V0ZS5jb21wb25lbnR9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8+XHJcbiAgICAgICAgICAgICAgICAgICAgKX1cclxuICAgICAgICAgICAgICAgIDwvU3dpdGNoPlxyXG4gICAgICAgICAgICA8L21haW4+XHJcbiAgICAgICAgPC9kaXY+XHJcbiAgICApO1xyXG59IiwiaW1wb3J0IHsgQnJvd3NlclJvdXRlciBhcyBSb3V0ZXIgfSBmcm9tICdyZWFjdC1yb3V0ZXItZG9tJztcclxuaW1wb3J0IHsgcmVuZGVyIH0gZnJvbSAncmVhY3QtZG9tJztcclxuXHJcbmltcG9ydCBBcHAgZnJvbSAnLi9BcHAnO1xyXG5cclxuaW1wb3J0ICcuL2luZGV4LnNjc3MnO1xyXG5cclxuY29uc3QgYmFzZW5hbWUgPSBwcm9jZXNzLmVudi5FTlYucHJvZHVjdGlvbiA/ICdtZGMtcmVhY3QnIDogdW5kZWZpbmVkO1xyXG5cclxucmVuZGVyKFxyXG4gICAgPFJvdXRlciBiYXNlbmFtZT17YmFzZW5hbWV9PlxyXG4gICAgICAgIDxBcHAgLz5cclxuICAgIDwvUm91dGVyPixcclxuICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyNyb290JylcclxuKTsiXSwibmFtZXMiOlsiaXNWYWxpZEVsZW1lbnQiLCJmb3J3YXJkUmVmIiwiY2xvbmVFbGVtZW50IiwiY3JlYXRlRWxlbWVudCIsImNsYXNzbmFtZXMiLCJjcmVhdGVDb21wb25lbnQiLCJmbiIsImRpc3BsYXlOYW1lIiwicHJvcFR5cGVzIiwiZGVmYXVsdFByb3BzIiwiQ29tcG9uZW50IiwibGVuZ3RoIiwiQ2xvbmUiLCJyZWYiLCJjb21wb25lbnQiLCJmYWxsYmFjayIsImNsYXNzTmFtZSIsImNoaWxkcmVuIiwicHJvcHMiLCJpc0VsZW1lbnQiLCJjbG9uZSIsImNyZWF0ZSIsImNzc0NsYXNzZXMiLCJST09UIiwiTElHSFQiLCJEQVJLIiwiSU5BQ1RJVkUiLCJQcm9wVHlwZXMiLCJJY29uIiwibmFtZSIsInR5cGUiLCJzaXplIiwibGlnaHQiLCJkYXJrIiwiaW5hY3RpdmUiLCJlbGVtZW50IiwiRWxlbWVudCIsImNsYXNzTmFtZXMiLCJvbmVPZiIsInN0cmluZyIsImJvb2wiLCJkZWZhdWx0IiwiU01BTEwiLCJNRURJVU0iLCJMQVJHRSIsIklNQUdFIiwiSUNPTiIsIlRFWFQiLCJBdmF0YXIiLCJpbWFnZSIsImljb24iLCJ0ZXh0Iiwic3JjIiwiYWx0Iiwibm9kZSIsIklOU0VUIiwiVFJBTlNQQVJFTlQiLCJCYWRnZSIsInZhbHVlIiwiaW5zZXQiLCJ0cmFuc3BhcmVudCIsIm9uZU9mVHlwZSIsIm51bWJlciIsImlzUmVxdWlyZWQiLCJudW1iZXJzIiwiQkFOTkVSX0FOSU1BVElPTl9DTE9TRV9USU1FX01TIiwiQkFOTkVSX0FOSU1BVElPTl9PUEVOX1RJTUVfTVMiLCJGSVhFRCIsIkNFTlRFUkVEIiwiTU9CSUxFX1NUQUNLRUQiLCJBUFBFQVJJTkciLCJBUFBFQVJFRCIsIk9QRU5JTkciLCJPUEVOIiwiQ0xPU0lORyIsIkNPTlRFTlQiLCJHUkFQSElDX1RFWFRfV1JBUFBFUiIsIkdSQVBISUMiLCJBQ1RJT05TIiwiUFJJTUFSWV9BQ1RJT04iLCJTRUNPTkRBUllfQUNUSU9OIiwidXNlUmVmIiwidXNlQ2FsbGJhY2siLCJ1c2VJbXBlcmF0aXZlSGFuZGxlIiwiQ1NTVHJhbnNpdGlvbiIsIkJhbm5lciIsImdyYXBoaWMiLCJhY3Rpb24iLCJwcmltYXJ5QWN0aW9uIiwic2Vjb25kYXJ5QWN0aW9uIiwib3BlbiIsImNlbnRlcmVkIiwiZml4ZWQiLCJtb2JpbGVTdGFja2VkIiwicm9vdFJlZiIsImNvbnRlbnRSZWYiLCJjdXJyZW50IiwiaGFuZGxlRW50ZXJpbmciLCJpc0FwcGVhcmluZyIsInN0eWxlIiwiaGVpZ2h0Iiwib2Zmc2V0SGVpZ2h0IiwiaGFuZGxlRXhpdGluZyIsImNvbnRlbnQiLCJhcHBlYXIiLCJlbnRlciIsImV4aXQiLCJhcHBlYXJEb25lIiwiZW50ZXJBY3RpdmUiLCJlbnRlckRvbmUiLCJSQUlTRUQiLCJVTkVMRVZBVEVEIiwiT1VUTElORUQiLCJUT1VDSCIsIklDT05fTEVBRElORyIsIklDT05fVFJBSUxJTkciLCJSSVBQTEUiLCJMQUJFTCIsIlRPVUNIX0VMRU1FTlQiLCJCdXR0b24iLCJsYWJlbCIsImxlYWRpbmdJY29uIiwidHJhaWxpbmdJY29uIiwicmFpc2VkIiwidW5lbGV2YXRlZCIsIm91dGxpbmVkIiwidG91Y2giLCJCb29sZWFuIiwiVElUTEUiLCJTVUJUSVRMRSIsIk9WRVJMSU5FIiwiQUNUSU9OU19GVUxMX0JMRUVEIiwiQUNUSU9OX0JVVFRPTlMiLCJBQ1RJT05fSUNPTlMiLCJBQ1RJT04iLCJBQ1RJT05fQlVUVE9OIiwiQUNUSU9OX0lDT04iLCJIRUFERVIiLCJIRUFERVJfR1JBUEhJQyIsIkhFQURFUl9DT05URU5UIiwiSEVBREVSX0FDVElPTlMiLCJNRURJQSIsIk1FRElBX1NRVUFSRSIsIk1FRElBX1dJREUiLCJNRURJQV9DT05URU5UIiwiU0VDVElPTiIsIlNFQ1RJT05fUFJJTUFSWSIsIlNFQ1RJT05fU0VDT05EQVJZIiwiQ2FyZCIsIkNhcmRBY3Rpb24iLCJidXR0b24iLCJDYXJkQWN0aW9ucyIsImZ1bGxCbGVlZCIsIkNhcmRBY3Rpb25CdXR0b25zIiwiQ2FyZEFjdGlvbkljb25zIiwiQ2hpbGRyZW4iLCJDYXJkSGVhZGVyIiwidGl0bGUiLCJzdWJ0aXRsZSIsIm92ZXJsaW5lIiwiYWN0aW9ucyIsIm1hcCIsImFycmF5T2YiLCJDYXJkTWVkaWEiLCJpbWFnZVVybCIsInNxdWFyZSIsIndpZGUiLCJiYWNrZ3JvdW5kSW1hZ2UiLCJ1bmRlZmluZWQiLCJDYXJkUHJpbWFyeUFjdGlvbiIsIkNhcmRTZWN0aW9uIiwicHJpbWFyeSIsInNlY29uZGFyeSIsIkFjdGlvbiIsIkFjdGlvbnMiLCJBY3Rpb25CdXR0b25zIiwiQWN0aW9uSWNvbnMiLCJIZWFkZXIiLCJNZWRpYSIsIlByaW1hcnlBY3Rpb24iLCJTZWN0aW9uIiwiU0VMRUNURUQiLCJESVNBQkxFRCIsIkFOSU1fQ0hFQ0tFRF9JTkRFVEVSTUlOQVRFIiwiQU5JTV9DSEVDS0VEX1VOQ0hFQ0tFRCIsIkFOSU1fSU5ERVRFUk1JTkFURV9DSEVDS0VEIiwiQU5JTV9JTkRFVEVSTUlOQVRFX1VOQ0hFQ0tFRCIsIkFOSU1fVU5DSEVDS0VEX0NIRUNLRUQiLCJBTklNX1VOQ0hFQ0tFRF9JTkRFVEVSTUlOQVRFIiwiTkFUSVZFX0NPTlRST0wiLCJCQUNLR1JPVU5EIiwiQ0hFQ0tNQVJLIiwiQ0hFQ0tNQVJLX1BBVEgiLCJNSVhFRE1BUksiLCJ1c2VFZmZlY3QiLCJDaGVja2JveCIsImNoZWNrZWQiLCJpbmRldGVybWluYXRlIiwiZGlzYWJsZWQiLCJvbkNoYW5nZSIsIkZ1bmN0aW9uIiwicHJvdG90eXBlIiwiaW5wdXRSZWYiLCJoYW5kbGVDaGFuZ2UiLCJldmVudCIsInRhcmdldCIsImZ1bmMiLCJTRUxFQ1RJTkdfQU5JTUFUSU9OX01TIiwiREVTRUxFQ1RJTkdfQU5JTUFUSU9OX01TIiwiY2hpcFNldENzc0NsYXNzZXMiLCJPVkVSRkxPVyIsIkNISVBTIiwiY2hpcENzc0NsYXNzZXMiLCJGSUxURVIiLCJTRUxFQ1RBQkxFIiwiU0VMRUNUSU5HIiwiU0VMRUNUSU5HX1dJVEhfUFJJTUFSWV9JQ09OIiwiREVTRUxFQ1RJTkciLCJERVNFTEVDVElOR19XSVRIX1BSSU1BUllfSUNPTiIsIkVOVEVSIiwiRVhJVCIsIkhJRERFTiIsIldJVEhfUFJJTUFSWV9HUkFQSElDIiwiV0lUSF9QUklNQVJZX0lDT04iLCJXSVRIX1RSQUlMSU5HX0FDVElPTiIsIldJVEhfQVZBVEFSIiwiQ0VMTCIsIlBSSU1BUllfQ0VMTCIsIlRSQUlMSU5HX0NFTEwiLCJUUkFJTElOR19BQ1RJT04iLCJQUkVTRU5UQVRJT05BTF9BQ1RJT04iLCJBQ1RJT05fVE9VQ0giLCJQUklNQVJZX1JJUFBMRSIsIlRSQUlMSU5HX1JJUFBMRSIsIlBSSU1BUllfSUNPTiIsIlRSQUlMSU5HX0lDT04iLCJURVhUX0xBQkVMIiwiQ0hFQ0tNQVJLX1NWRyIsIkNoaXBQcmltYXJ5QWN0aW9uIiwicHJlc2VudGF0aW9uYWwiLCJzZWxlY3RhYmxlIiwic2VsZWN0ZWQiLCJpc0J1dHRvbiIsIkNoaXBUcmFpbGluZ0FjdGlvbiIsIkNoaXAiLCJhdmF0YXIiLCJwcmltYXJ5SWNvbiIsImZpbHRlciIsIndpdGhBdmF0YXIiLCJ3aXRoUHJpbWFyeUdyYXBoaWMiLCJ3aXRoUHJpbWFyeUljb24iLCJ3aXRoVHJhaWxpbmdBY3Rpb24iLCJzZWxlY3RpbmdDbGFzcyIsImRlc2VsZWN0aW5nQ2xhc3MiLCJleGl0QWN0aXZlIiwiYW55Iiwib25DbGljayIsImlzVW5kZWZpbmVkIiwiaXNOdWxsIiwiaXNCb29sZWFuIiwiaXNOdW1iZXIiLCJpc1N0cmluZyIsImlzQXJyYXkiLCJBcnJheSIsImlzT2JqZWN0IiwiQ2hpcFNldCIsImNoaXBzIiwiaW5wdXQiLCJjaG9pY2UiLCJvdmVyZmxvdyIsImNoaXAiLCJoYW5kbGVDbGljayIsImNoaXBWYWx1ZSIsImN1cnJlbnRUYXJnZXQiLCJkYXRhc2V0IiwibmV3VmFsdWUiLCJpbmNsdWRlcyIsInYiLCJjb25jYXQiLCJvbkNsaWNrQ2FwdHVyZSIsIlNldCIsInN0cmluZ3MiLCJYTUxOUyIsInNpemVQcm9wcyIsImxhcmdlIiwidmlld0JveCIsInJhZGl1cyIsInN0cm9rZVdpZHRoIiwiZ2FwUGF0Y2hTdHJva2VXaWR0aCIsInN0cm9rZURhc2hhcnJheSIsImluZGV0ZXJtaW5hdGVTdHJva2VEYXNob2Zmc2V0IiwibWVkaXVtIiwic21hbGwiLCJJTkRFVEVSTUlOQVRFIiwiQ0xPU0VEIiwiREVURVJNSU5BVEVfQ09OVEFJTkVSIiwiREVURVJNSU5BVEVfQ0lSQ0xFX0dSQVBISUMiLCJERVRFUk1JTkFURV9UUkFDSyIsIkRFVEVSTUlOQVRFX0NJUkNMRSIsIklOREVURVJNSU5BVEVfQ09OVEFJTkVSIiwiSU5ERVRFUk1JTkFURV9DSVJDTEVfR1JBUEhJQyIsIlNQSU5ORVJfTEFZRVIiLCJDT0xPUiIsIkNJUkNMRV9DTElQUEVSIiwiQ0lSQ0xFX0xFRlQiLCJDSVJDTEVfUklHSFQiLCJHQVBfUEFUQ0giLCJTaXplIiwiQ2lyY3VsYXJQcm9ncmVzcyIsImNsb3NlZCIsImNvbG9yZnVsIiwicHJvZ3Jlc3MiLCJOdW1iZXIiLCJjeCIsImN5Iiwic3Ryb2tlRGFzaG9mZnNldCIsIk1hdGgiLCJQSSIsIm4iLCJQUk9HUkVTU19DT0xPUiIsImljb25Dc3NDbGFzc2VzIiwiSWNvbkJ1dHRvbiIsIkFOSU1BVElPTl9SRUFEWSIsIkNMT1NFRF9BTklNQVRJT05fT0ZGIiwiQlVGRkVSIiwiQlVGRkVSX0JBUiIsIkJVRkZFUl9ET1RTIiwiQkFSIiwiUFJJTUFSWV9CQVIiLCJTRUNPTkRBUllfQkFSIiwiQkFSX0lOTkVSIiwiTGluZWFyUHJvZ3Jlc3MiLCJidWZmZXIiLCJwcmltYXJ5QmFyU3R5bGUiLCJ0cmFuc2Zvcm0iLCJidWZmZXJTdHlsZSIsImZsZXhCYXNpcyIsIlNUSUNLWV9IRUFERVIiLCJJTl9QUk9HUkVTUyIsIlRBQkxFX0NPTlRBSU5FUiIsIlRBQkxFIiwiSEVBREVSX1JPVyIsIkhFQURFUl9ST1dfQ0hFQ0tCT1giLCJIRUFERVJfQ0VMTCIsIkhFQURFUl9DRUxMX0NIRUNLQk9YIiwiSEVBREVSX0NFTExfTlVNRVJJQyIsIkhFQURFUl9DRUxMX1dJVEhfU09SVCIsIkhFQURFUl9DRUxMX1NPUlRFRCIsIkhFQURFUl9DRUxMX1NPUlRFRF9ERVNDIiwiSEVBREVSX0NFTExfV1JBUFBFUiIsIkhFQURFUl9DRUxMX0xBQkVMIiwiUk9XIiwiUk9XX0NIRUNLQk9YIiwiUk9XX1NFTEVDVEVEIiwiQ0VMTF9DSEVDS0JPWCIsIkNFTExfTlVNRVJJQyIsIlBBR0lOQVRJT04iLCJQQUdJTkFUSU9OX1RSQUlMSU5HIiwiUEFHSU5BVElPTl9ST1dTX1BFUl9QQUdFIiwiUEFHSU5BVElPTl9ST1dTX1BFUl9QQUdFX0xBQkVMIiwiUEFHSU5BVElPTl9ST1dTX1BFUl9QQUdFX1NFTEVDVCIsIlBBR0lOQVRJT05fTkFWSUdBVElPTiIsIlBBR0lOQVRJT05fVE9UQUwiLCJQQUdJTkFUSU9OX0JVVFRPTiIsIlNPUlRfSUNPTl9CVVRUT04iLCJTT1JUX1NUQVRVU19MQUJFTCIsIlBST0dSRVNTX0lORElDQVRPUiIsIlNDUklNIiwiRk9PVEVSIiwiTElORUFSX1BST0dSRVNTIiwiRGF0YVRhYmxlUHJvZ3Jlc3NJbmRpY2F0b3IiLCJGTE9BVCIsIlJFUVVJUkVEIiwiRmxvYXRpbmdMYWJlbCIsImZsb2F0IiwicmVxdWlyZWQiLCJBQ1RJVkUiLCJERUFDVElWQVRJTkciLCJMaW5lUmlwcGxlIiwiYWN0aXZlIiwidHJhbnNmb3JtT3JpZ2luIiwiS2V5IiwiQVJST1dfTEVGVCIsIkFSUk9XX1VQIiwiQVJST1dfUklHSFQiLCJBUlJPV19ET1dOIiwiSE9NRSIsIkVORCIsIlBBR0VfVVAiLCJQQUdFX0RPV04iLCJLZXlDb2RlIiwiZ2V0Q2xpZW50V2lkdGgiLCJvZmZzZXRQYXJlbnQiLCJjbGllbnRXaWR0aCIsImNsb25lTm9kZSIsInNldFByb3BlcnR5IiwiZG9jdW1lbnQiLCJkb2N1bWVudEVsZW1lbnQiLCJhcHBlbmRDaGlsZCIsInJlbW92ZUNoaWxkIiwiZ2V0Q2xpZW50SGVpZ2h0IiwiY2xpZW50SGVpZ2h0IiwiZ2V0RXZlbnRLZXkiLCJrZXkiLCJrZXlDb2RlIiwiZ2V0UGFnZVgiLCJ0YXJnZXRUb3VjaGVzIiwicGFnZVgiLCJnZXRQYWdlWSIsInBhZ2VZIiwiTk9UQ0hfU0laRV9GQUNUT1IiLCJOT1RDSF9QQURESU5HX1JJR0hUIiwiTk9UQ0hFRCIsIlVQR1JBREVEIiwiTk9fTEFCRUwiLCJMRUFESU5HIiwiTk9UQ0giLCJUUkFJTElORyIsInVzZUxheW91dEVmZmVjdCIsIk5vdGNoZWRPdXRsaW5lIiwibm90Y2hlZCIsIm5vdGNoUmVmIiwibm90Y2giLCJmbG9hdGluZ0xhYmVsIiwiZmlyc3RDaGlsZCIsIndpZHRoIiwiVFJBTlNJVElPTl9PUEVOX0RVUkFUSU9OIiwiVFJBTlNJVElPTl9DTE9TRV9EVVJBVElPTiIsIk1BUkdJTl9UT19FREdFIiwiQU5DSE9SX1RPX01FTlVfU1VSRkFDRV9XSURUSF9SQVRJTyIsIlRPVUNIX0VWRU5UX1dBSVRfTVMiLCJTVVJGQUNFIiwiU1VSRkFDRV9BTkNIT1IiLCJTVVJGQUNFX0ZJWEVEIiwiU1VSRkFDRV9PUEVOIiwiU1VSRkFDRV9BTklNQVRJTkdfT1BFTiIsIlNVUkZBQ0VfQU5JTUFUSU5HX0NMT1NFRCIsIlNVUkZBQ0VfQkVMT1dfQU5DSE9SIiwiSVRFTSIsIklURU1fU0VMRUNURUQiLCJTRUxFQ1RJT05fR1JPVVAiLCJTRUxFQ1RJT05fR1JPVVBfSUNPTiIsIk9yaWdpbiIsIlRPUF9MRUZUIiwiVE9QX0NFTlRFUiIsIlRPUF9SSUdIVCIsIkNFTlRFUl9MRUZUIiwiQ0VOVEVSIiwiQ0VOVEVSX1JJR0hUIiwiQk9UVE9NX0xFRlQiLCJCT1RUT01fQ0VOVEVSIiwiQk9UVE9NX1JJR0hUIiwidXNlU3RhdGUiLCJ1c2VDcmVhdGVkIiwiY3JlYXRlZCIsInNldENyZWF0ZWQiLCJ1c2VNb3VudGVkIiwidXNlVXBkYXRlZCIsImRlcHMiLCJtb3VudGVkIiwic2V0TW91bnRlZCIsInVzZVVwZGF0ZWRTeW5jIiwidXNlVW5tb3VudGVkIiwibGlzdENzc0NsYXNzZXMiLCJsaXN0SXRlbUNzc0NsYXNzZXMiLCJBQ1RJVkFURUQiLCJOT05fSU5URVJBQ1RJVkUiLCJPTkVfTElORSIsIlRXT19MSU5FUyIsIlRIUkVFX0xJTkVTIiwiTEVBRElOR19JQ09OIiwiTEVBRElOR19JTUFHRSIsIkxFQURJTkdfQVZBVEFSIiwiTEVBRElOR19USFVNQk5BSUwiLCJMRUFESU5HX1ZJREVPIiwiTEVBRElOR19DSEVDS0JPWCIsIkxFQURJTkdfUkFESU8iLCJMRUFESU5HX1NXSVRDSCIsIlRSQUlMSU5HX01FVEEiLCJUUkFJTElOR19DSEVDS0JPWCIsIlRSQUlMSU5HX1JBRElPIiwiVFJBSUxJTkdfU1dJVENIIiwiU1RBUlQiLCJPVkVSTElORV9URVhUIiwiUFJJTUFSWV9URVhUIiwiU0VDT05EQVJZX1RFWFQiLCJsaXN0R3JvdXBDc3NDbGFzc2VzIiwiU1VCSEVBREVSIiwibGlzdERpdmlkZXJDc3NDbGFzc2VzIiwiTEVBRElOR19URVhUIiwiTGlzdEl0ZW1Db250ZW50Iiwib3ZlcmxpbmVUZXh0IiwicHJpbWFyeVRleHQiLCJzZWNvbmRhcnlUZXh0IiwiTGlzdEl0ZW1FbmQiLCJMaXN0SXRlbVN0YXJ0IiwiTGlzdEl0ZW0iLCJzdGFydCIsImVuZCIsInRodW1ibmFpbCIsInZpZGVvIiwibGVhZGluZ0ltYWdlIiwibGVhZGluZ0F2YXRhciIsImxlYWRpbmdUaHVtYm5haWwiLCJsZWFkaW5nVmlkZW8iLCJsZWFkaW5nQ2hlY2tib3giLCJsZWFkaW5nUmFkaW8iLCJsZWFkaW5nU3dpdGNoIiwibWV0YSIsInRyYWlsaW5nTWV0YSIsInRyYWlsaW5nQ2hlY2tib3giLCJ0cmFpbGluZ1JhZGlvIiwidHJhaWxpbmdTd2l0Y2giLCJhY3RpdmF0ZWQiLCJub25JbnRlcmFjdGl2ZSIsIm9uZUxpbmUiLCJ0d29MaW5lcyIsInRocmVlTGluZXMiLCJ3aXRoTGVhZGluZ0ljb24iLCJ3aXRoTGVhZGluZ0ltYWdlIiwid2l0aExlYWRpbmdBdmF0YXIiLCJ3aXRoTGVhZGluZ1RodW1ibmFpbCIsIndpdGhMZWFkaW5nVmlkZW8iLCJ3aXRoTGVhZGluZ0NoZWNrYm94Iiwid2l0aExlYWRpbmdSYWRpbyIsIndpdGhMZWFkaW5nU3dpdGNoIiwid2l0aFRyYWlsaW5nTWV0YSIsIndpdGhUcmFpbGluZ0ljb24iLCJ3aXRoVHJhaWxpbmdDaGVja2JveCIsIndpdGhUcmFpbGluZ1JhZGlvIiwid2l0aFRyYWlsaW5nU3dpdGNoIiwibGluZXMiLCJoYXNTdGFydCIsImhhc0NvbnRlbnQiLCJoYXNFbmQiLCJMaXN0IiwiaXRlbXMiLCJpdGVtIiwiYXJyYXkiLCJMaXN0RGl2aWRlciIsIndpdGhMZWFkaW5nVGV4dCIsIkxpc3RHcm91cCIsIkxpc3RHcm91cFN1YmhlYWRlciIsIkl0ZW0iLCJEaXZpZGVyIiwiR3JvdXAiLCJTdWJoZWFkZXIiLCJDb250ZW50IiwiRW5kIiwiU3RhcnQiLCJNZW51SXRlbSIsImNyZWF0ZVBvcnRhbCIsIk1vZGFsIiwicm9vdCIsImFjdGl2ZUVsZW1lbnQiLCJjbGFzc0xpc3QiLCJhZGQiLCJib2R5IiwiZm9jdXMiLCJMYXllciIsIm1vZGFsIiwiZGVmYXVsdFZhbHVlcyIsInRvcCIsImJvdHRvbSIsImNlbnRlciIsImxlZnQiLCJyaWdodCIsImdldEFuY2hvck9yaWdpbiIsImFuY2hvck9yaWdpbiIsIk9iamVjdCIsImFzc2lnbiIsImtleXMiLCJzcGxpdCIsInZhbHVlcyIsInJlZHVjZSIsInJlc3VsdCIsIk1lbnVTdXJmYWNlIiwiYW5jaG9yIiwiX2FuY2hvclJlZiIsImFuY2hvclJlZiIsIl9hbmNob3JPcmlnaW4iLCJfdHJhbnNmb3JtT3JpZ2luIiwicXVpY2siLCJwZXJzaXN0ZW50IiwiZnVsbFdpZHRoIiwib25DbG9zZSIsIm9uS2V5RG93biIsImhhbmRsZUJvZHlDbGljayIsImFkZEV2ZW50TGlzdGVuZXIiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiYW5jaG9yQ2xpZW50UmVjdCIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsImFuY2hvckRpbWVuc2lvbnMiLCJvZmZzZXRUb3AiLCJvZmZzZXRMZWZ0Iiwib2Zmc2V0V2lkdGgiLCJtYXhXaWR0aCIsInBvc2l0aW9uIiwic2Nyb2xsWSIsIndpbmRvdyIsInNjcm9sbFgiLCJib3R0b21PdmVyZmxvdyIsImlubmVySGVpZ2h0IiwidG9wT3ZlcmZsb3ciLCJyaWdodE92ZXJmbG93IiwiaW5uZXJXaWR0aCIsImFicyIsImxlZnRPdmVyZmxvdyIsImhhbmRsZUtleURvd24iLCJzdG9wUHJvcGFnYXRpb24iLCJpc0JlbG93QW5jaG9yIiwib2JqZWN0IiwiTWVudSIsImxpc3RQcm9wcyIsImxpc3RSZWYiLCJmb2N1c2VkQ2hpbGRJbmRleCIsInNldEZvY3VzZWRDaGlsZEluZGV4IiwidG9BcnJheSIsImZpbmRJbmRleCIsImkiLCJwcmV2ZW50RGVmYXVsdCIsImluZGV4IiwibmV4dEluZGV4IiwiTWVudUFuY2hvciIsIndyYXAiLCJNZW51U2VsZWN0aW9uR3JvdXAiLCJNZW51U2VsZWN0aW9uR3JvdXBJY29uIiwiTWVudU9yaWdpbiIsIkFuY2hvciIsIlN1cmZhY2UiLCJTZWxlY3Rpb25Hcm91cCIsIlNlbGVjdGlvbkdyb3VwSWNvbiIsIkZJTExFRCIsIkZPQ1VTRUQiLCJJTlZBTElEIiwiV0lUSF9MRUFESU5HX0lDT04iLCJBTkNIT1IiLCJEUk9QRE9XTl9JQ09OIiwiRFJPUERPV05fSUNPTl9HUkFQSElDIiwiRFJPUERPV05fSUNPTl9JTkFDVElWRSIsIkRST1BET1dOX0lDT05fQUNUSVZFIiwiTUVOVSIsIk1FTlVfSU5WQUxJRCIsIlNFTEVDVEVEX1RFWFQiLCJTRUxFQ1RFRF9URVhUX0NPTlRBSU5FUiIsIkhFTFBFUl9URVhUIiwiVkFMSURBVElPTl9NRVNTQUdFIiwiVkFMSURBVElPTl9NRVNTQUdFX1BFUlNJU1RFTlQiLCJvcHRpb25Dc3NDbGFzc2VzIiwiVFdPX0xJTkUiLCJXSVRIX0xFQURJTkdfQ09OVEVOVCIsIldJVEhfTUVUQSIsIkRyb3Bkb3duSWNvbiIsIlNlbGVjdE9wdGlvbiIsImNoZWNrYm94IiwiaGFzTGVhZGluZ0NvbnRlbnQiLCJIZWxwZXJUZXh0IiwidmFsaWRhdGlvbiIsIlNlbGVjdCIsIm9wdGlvbnMiLCJoZWxwZXJUZXh0IiwiZmlsbGVkIiwibXVsdGlwbGUiLCJtZW51UHJvcHMiLCJoZWxwZXJUZXh0UHJvcHMiLCJvcHRpb24iLCJtZW51UmVmIiwic2V0QWN0aXZhdGVkIiwiZm9jdXNlZCIsInNldEZvY3VzZWQiLCJ0b3VjaGVkIiwic2V0VG91Y2hlZCIsInNlbGVjdGVkVGV4dCIsInNldFNlbGVjdGVkVGV4dCIsImludGVyYWN0aW9uQ29vcmRzIiwic2V0SW50ZXJhY3Rpb25Db29yZHMiLCJzZWxlY3RlZE9wdGlvbnMiLCJqb2luIiwic2VsZWN0ZWRPcHRpb24iLCJmaW5kIiwiaGFuZGxlQW5jaG9yQ2xpY2siLCJ0YXJnZXRDbGllbnRSZWN0IiwieCIsImNsaWVudFgiLCJ5IiwiY2xpZW50WSIsImhhbmRsZU9wdGlvbkludGVyYWN0aW9uIiwiaGFzIiwiaGFuZGxlTWVudUNsb3NlIiwicGF0aCIsImhhc1ZhbHVlIiwiZm9jdXNlZE9ySGFzVmFsdWUiLCJpc0ludmFsaWQiLCJvcHRpb25WYWx1ZSIsIk9wdGlvbiIsIkRhdGFUYWJsZVBhZ2luYXRpb24iLCJ0b3RhbENvdW50IiwiY3VycmVudFBhZ2UiLCJyb3dzUGVyUGFnZSIsIm9uRmlyc3RQYWdlIiwib25QcmV2UGFnZSIsIm9uTmV4dFBhZ2UiLCJvbkxhc3RQYWdlIiwiRGF0YVRhYmxlIiwic3RpY2t5SGVhZGVyIiwiaW5Qcm9ncmVzcyIsInBhZ2luYXRpb24iLCJEYXRhVGFibGVDZWxsIiwibnVtZXJpYyIsInNjb3BlIiwiRGF0YVRhYmxlQ29udGVudCIsIkRhdGFUYWJsZUZvb3RlciIsIkRhdGFUYWJsZUhlYWRlciIsIkRhdGFUYWJsZUhlYWRlckNlbGwiLCJzb3J0Iiwic29ydEljb25CdXR0b24iLCJvblNvcnQiLCJyb2xlIiwiaGFuZGxlU29ydEljb25DbGljayIsIndpdGhTb3J0IiwiRGF0YVRhYmxlSGVhZGVyUm93IiwiRGF0YVRhYmxlUm93IiwiQ2VsbCIsIkZvb3RlciIsIkhlYWRlckNlbGwiLCJIZWFkZXJSb3ciLCJQYWdpbmF0aW9uIiwiUm93IiwiRElBTE9HX0FOSU1BVElPTl9PUEVOX1RJTUVfTVMiLCJESUFMT0dfQU5JTUFUSU9OX0NMT1NFX1RJTUVfTVMiLCJERUZBVUxUX0FDVElPTlNfSEVJR0hUIiwiQ0xPU0UiLCJDT05UQUlORVIiLCJCVVRUT04iLCJGVUxMU0NSRUVOIiwiU0hFRVQiLCJTQ1JPTExBQkxFIiwiU1RBQ0tFRCIsIk5PX0NPTlRFTlRfUEFERElORyIsIlNDUk9MTF9ESVZJREVSX0hFQURFUiIsIlNDUk9MTF9ESVZJREVSX0ZPT1RFUiIsIlNDUk9MTF9MT0NLIiwiRGlhbG9nSGVhZGVyIiwiY2xvc2VJY29uIiwiZnVsbHNjcmVlbiIsIkRpYWxvZ0NvbnRlbnQiLCJEaWFsb2dBY3Rpb25zIiwiRGlhbG9nIiwiaGVhZGVyIiwic2hlZXQiLCJzdGFja2VkIiwiYXV0b1N0YWNrQnV0dG9ucyIsIm5vQ29udGVudFBhZGRpbmciLCJhY3Rpb25zUmVmIiwiaGFuZGxlRG9jdW1lbnRLZXlEb3duIiwiY29udGVudEVsZW1lbnQiLCJzaG91bGRTY3JvbGwiLCJzY3JvbGxIZWlnaHQiLCJhY3Rpb25zRWxlbWVudCIsImhhbmRsZVNjcm9sbCIsImlzU2Nyb2xsQXRUb3AiLCJzY3JvbGxUb3AiLCJpc1Njcm9sbEF0Qm90dG9tIiwiY2VpbCIsInRvZ2dsZSIsInJlbW92ZSIsImhhbmRsZUVudGVyIiwiaGFuZGxlRXhpdGVkIiwiaGFuZGxlU2NyaW1DbGljayIsImFwcGVhckFjdGl2ZSIsIkFOSU1BVElPTl9FTlRFUl9USU1FX01TIiwiQU5JTUFUSU9OX0VYSVRfVElNRV9NUyIsIkRJU01JU1NJQkxFIiwiTU9EQUwiLCJBTklNQVRFIiwiQVBQX0NPTlRFTlQiLCJEcmF3ZXIiLCJkaXNtaXNzaWJsZSIsImFwcENvbnRlbnRTZWxlY3RvciIsImFwcENvbnRlbnRFbGVtZW50IiwicXVlcnlTZWxlY3RvciIsIm5leHRFbGVtZW50U2libGluZyIsIkRyYXdlckhlYWRlciIsIkRyYXdlckNvbnRlbnQiLCJaIiwiVFJBTlNJVElPTiIsIkVsZXZhdGlvbiIsInoiLCJ0cmFuc2l0aW9uIiwiTUlOSSIsIkVYVEVOREVEIiwiRVhJVEVEIiwiRkFCIiwibWluaSIsImV4aXRlZCIsIkFMSUdOX0VORCIsIk5PV1JBUCIsIlNQQUNFX0JFVFdFRU4iLCJGb3JtRmllbGQiLCJhbGlnbkVuZCIsIm5vd3JhcCIsInNwYWNlQmV0d2VlbiIsImlkIiwiSU1BR0VfTElTVCIsIklNQUdFX0xJU1RfTUFTT05SWSIsIklNQUdFX0xJU1RfV0lUSF9URVhUX1BST1RFQ1RJT04iLCJJTUFHRV9MSVNUX0lURU0iLCJJTUFHRV9MSVNUX0lNQUdFX0FTUEVDVF9DT05UQUlORVIiLCJJTUFHRV9MSVNUX0lNQUdFIiwiSU1BR0VfTElTVF9TVVBQT1JUSU5HIiwiSU1BR0VfTElTVF9MQUJFTCIsIkltYWdlTGlzdEl0ZW0iLCJpbWFnZVNyYyIsImZpeGVkQXNwZWN0IiwiSW1hZ2VMaXN0IiwibWFzb25yeSIsIndpdGhUZXh0UHJvdGVjdGlvbiIsImNoaWxkIiwiQ09MVU1OIiwiRElSRUNUSU9OIiwiV1JBUCIsIldSQVBfUkVWRVJTRSIsIkFMSUdOX0lURU1TIiwiQUxJR05fU0VMRiIsIkpVU1RJRllfQ09OVEVOVCIsIkxheW91dCIsInJvdyIsImNvbHVtbiIsImRpcmVjdGlvbiIsImFsaWduSXRlbXMiLCJhbGlnblNlbGYiLCJqdXN0aWZ5Q29udGVudCIsIkFMSUdOIiwiRklYRURfQ09MVU1OX1dJRFRIIiwiSU5ORVIiLCJDRUxMX1NQQU4iLCJDRUxMX09SREVSIiwiQ0VMTF9BTElHTiIsIkxheW91dEdyaWQiLCJhbGlnbiIsImZpeGVkQ29sdW1uV2lkdGgiLCJMYXlvdXRHcmlkQ2VsbCIsInNwYW4iLCJkZXNrdG9wIiwidGFibGV0IiwibW9iaWxlIiwib3JkZXIiLCJncmlkIiwiT1VURVJfQ0lSQ0xFIiwiSU5ORVJfQ0lSQ0xFIiwiUmFkaW8iLCJNRENSaXBwbGUiLCJSaXBwbGUiLCJ1bmJvdW5kZWQiLCJyaXBwbGVSZWYiLCJwYXJlbnROb2RlIiwiZGVzdHJveSIsIlVOQk9VTkRFRCIsIkJHX0ZPQ1VTRUQiLCJGR19BQ1RJVkFUSU9OIiwiRkdfREVBQ1RJVkFUSU9OIiwiU1VSRkFDRV9QUklNQVJZIiwiU1VSRkFDRV9BQ0NFTlQiLCJWQVJfRkdfU0NBTEUiLCJWQVJfRkdfU0laRSIsIlZBUl9GR19UUkFOU0xBVEVfRU5EIiwiVkFSX0ZHX1RSQU5TTEFURV9TVEFSVCIsIlZBUl9MRUZUIiwiVkFSX1RPUCIsIkRFQUNUSVZBVElPTl9USU1FT1VUX01TIiwiRkdfREVBQ1RJVkFUSU9OX01TIiwiSU5JVElBTF9PUklHSU5fU0NBTEUiLCJQQURESU5HIiwiVEFQX0RFTEFZX01TIiwidXNlUmlwcGxlIiwiUmlwcGxlU3VyZmFjZSIsImFjY2VudCIsIlNJTkdMRV9TRUxFQ1QiLCJTRUdNRU5UIiwiU0VHTUVOVF9TRUxFQ1RFRCIsIlNlZ21lbnRlZEJ1dHRvblNlZ21lbnQiLCJyaXBwbGUiLCJTZWdtZW50ZWRCdXR0b24iLCJzZWdtZW50cyIsInNpbmdsZVNlbGVjdCIsInNlZ21lbnQiLCJzZWdtZW50VmFsdWUiLCJhcmlhUHJvcCIsIlNlZ21lbnQiLCJDTE9TRV9CVVRUT04iLCJTaWRlU2hlZXRIZWFkZXIiLCJTaWRlU2hlZXRDb250ZW50IiwiU2lkZVNoZWV0IiwiU2lkZVNoZWV0QXBwQ29udGVudCIsIkFwcENvbnRlbnQiLCJUSFVNQl9XSURUSCIsIlJBTkdFIiwiRElTQ1JFVEUiLCJJTlBVVCIsIlRSQUNLIiwiVFJBQ0tfSU5BQ1RJVkUiLCJUUkFDS19BQ1RJVkUiLCJUUkFDS19BQ1RJVkVfRklMTCIsIlRJQ0tfTUFSS1MiLCJUSUNLX01BUktfQUNUSVZFIiwiVElDS19NQVJLX0lOQUNUSVZFIiwiVEhVTUIiLCJUSFVNQl9UT1AiLCJUSFVNQl9GT0NVU0VEIiwiVEhVTUJfV0lUSF9JTkRJQ0FUT1IiLCJUSFVNQl9LTk9CIiwiVkFMVUVfSU5ESUNBVE9SX0NPTlRBSU5FUiIsIlZBTFVFX0lORElDQVRPUiIsIlZBTFVFX0lORElDQVRPUl9URVhUIiwiZ2V0VmFsdWVGb3JFdmVudEtleSIsImV2ZW50S2V5IiwibWluIiwibWF4Iiwic3RlcCIsImRlbHRhIiwiTmFOIiwiSW5wdXQiLCJyb3VuZCIsIlRpY2tNYXJrcyIsImZyb20iLCJfIiwidGlja1ZhbHVlIiwiVHJhY2siLCJkaXNjcmV0ZSIsInRpY2tNYXJrcyIsIlRodW1iIiwib25TdGFydEludGVyYWN0aW9uIiwib25FbmRJbnRlcmFjdGlvbiIsImhhbmRsZUZvY3VzIiwiaGFuZGxlQmx1ciIsIlNsaWRlciIsInRyYWNrUmVmIiwic2V0QWN0aXZlIiwiaGFuZGxlTW92ZSIsImhhbmRsZVVwIiwidXBkYXRlVmFsdWUiLCJ0cmFja0NsaWVudFJlY3QiLCJvZmZzZXRYIiwicGVyY2VudCIsImlzTmFOIiwiaGFuZGxlUm9vdEludGVyYWN0aW9uIiwiaGFuZGxlVGh1bWJTdGFydEludGVyYWN0aW9uIiwiaGFuZGxlVGh1bWJFbmRJbnRlcmFjdGlvbiIsIkRFRkFVTFRfQVVUT19ESVNNSVNTX1RJTUVPVVRfTVMiLCJBTklNQVRJT05fT1BFTl9USU1FX01TIiwiQU5JTUFUSU9OX0NMT1NFX1RJTUVfTVMiLCJESVNNSVNTIiwiU25hY2tiYXIiLCJkaXNtaXNzSWNvbiIsImxlYWRpbmciLCJ0aW1lb3V0IiwiY2xvc2VPbkVzY2FwZSIsInRpbWVvdXRSZWYiLCJzZXRUaW1lb3V0IiwiY2xlYXJUaW1lb3V0IiwiVU5TRUxFQ1RFRCIsIkhBTkRMRV9UUkFDSyIsIkhBTkRMRSIsIlNIQURPVyIsIkVMRVZBVElPTl9PVkVSTEFZIiwiSUNPTlMiLCJJQ09OX09OIiwiSUNPTl9PRkYiLCJTd2l0Y2giLCJTTUFMTEVSIiwiTEFSR0VSIiwiZ2V0U2l6ZVZhbHVlIiwiYXJnIiwidG9VcHBlckNhc2UiLCJnZXRGb250VmFyaWF0aW9uU2V0dGluZ3MiLCJmaWxsIiwid2dodCIsImdyYWQiLCJvcHN6IiwicGFydHMiLCJwdXNoIiwiU3ltYm9sIiwid2VpZ2h0IiwiZ3JhZGUiLCJmb250VmFyaWF0aW9uU2V0dGluZ3MiLCJ0YWJDbGFzc05hbWVzIiwiTUlOX1dJRFRIIiwiYmFyQ3NzQ2xhc3NlcyIsInNjcm9sbGVyQ3NzQ2xhc3NlcyIsIkFOSU1BVElORyIsIlNDUk9MTF9BUkVBIiwiU0NST0xMX0FSRUFfU0NST0xMIiwiU0NST0xMX0NPTlRFTlQiLCJpbmRpY2F0b3JDc3NDbGFzc2VzIiwiRkFERSIsIk5PX1RSQU5TSVRJT04iLCJDT05URU5UX0lDT04iLCJDT05URU5UX1VOREVSTElORSIsIkFsaWduIiwiY3JlYXRlQ29udGV4dCIsInVzZUNvbnRleHQiLCJUYWJDb250ZXh0IiwiVGFiSW5kaWNhdG9yIiwiZmFkZSIsInVuZGVybGluZSIsInByZXZpb3VzVGFiIiwiYWN0aXZlSW5kaWNhdG9yIiwicHJldmlvdXNJbmRpY2F0b3IiLCJwcmV2aW91c0luZGljYXRvckNsaWVudFJlY3QiLCJhY3RpdmVJbmRpY2F0b3JDbGllbnRSZWN0IiwieFBvc2l0aW9uIiwid2lkdGhEZWx0YSIsInJvb3RDbGFzc05hbWVzIiwiY29udGVudENsYXNzTmFtZXMiLCJUYWIiLCJpbmRpY2F0b3JJY29uIiwibWluV2lkdGgiLCJtaW5XaWR0aEluZGljYXRvciIsIm9uQWN0aXZhdGUiLCJUYWJTY3JvbGxlciIsImFjdGl2ZVRhYiIsInNjcm9sbEFyZWFSZWYiLCJzY3JvbGxDb250ZW50UmVmIiwic2Nyb2xsQXJlYVdpZHRoIiwic2Nyb2xsQ29udGVudFdpZHRoIiwidGFiV2lkdGgiLCJ0YWJIYWxmV2lkdGgiLCJzY3JvbGxMZWZ0Iiwib2Zmc2V0TGVmdERlbHRhIiwib2Zmc2V0UmlnaHQiLCJvZmZzZXRSaWdodERlbHRhIiwic2Nyb2xsQnkiLCJiZWhhdmlvciIsIlRhYkJhciIsInRhYnMiLCJpY29uSW5kaWNhdG9yIiwidW5kZXJsaW5lSW5kaWNhdG9yIiwidGFiIiwiYWN0aXZlVGFiUmVmIiwicHJldmlvdXNUYWJSZWYiLCJoYW5kbGVUYWJDbGljayIsInRhYlZhbHVlIiwiQmFyIiwiQk9VTkRFRF9BTkNIT1JfR0FQIiwiVU5CT1VOREVEX0FOQ0hPUl9HQVAiLCJNSU5fVklFV1BPUlRfVE9PTFRJUF9USFJFU0hPTEQiLCJFTlRFUl9EVVJBVElPTl9NUyIsIkVYSVRfRFVSQVRJT05fTVMiLCJISURFX0RFTEFZX01TIiwiU0hPV19ERUxBWV9NUyIsIk1JTl9IRUlHSFQiLCJNQVhfV0lEVEgiLCJDQVJFVF9JTkRFTlRBVElPTiIsIkFOSU1BVElPTl9TQ0FMRSIsIlJJQ0giLCJNVUxUSUxJTkUiLCJTSE9XSU5HIiwiU0hPV0lOR19UUkFOU0lUSU9OIiwiU0hPV04iLCJISURFIiwiSElERV9UUkFOU0lUSU9OIiwiU1VSRkFDRV9BTklNQVRJT04iLCJDT05URU5UX0xJTksiLCJDQVJFVF9UT1AiLCJDQVJFVF9CT1RUT00iLCJUb29sdGlwIiwidG9vbHRpcFJlZiIsInRhcmdldFJlZiIsImhhbmRsZU1vdXNlRW50ZXIiLCJoYW5kbGVNb3VzZUxlYXZlIiwidG9vbHRpcFJlY3QiLCJ0YXJnZXRSZWN0Iiwib3ZlcmZsb3dCb3R0b20iLCJvdmVyZmxvd1JpZ2h0IiwiUmljaFRvb2x0aXAiLCJoYW5kbGVUYXJnZXRNb3VzZUVudGVyIiwiaGFuZGxlVGFyZ2V0TW91c2VMZWF2ZSIsImhhbmRsZVRvb2x0aXBNb3VzZUVudGVyIiwiaGFuZGxlVG9vbHRpcE1vdXNlTGVhdmUiLCJleGl0RG9uZSIsIlRFWFRBUkVBIiwiTEFCRUxfRkxPQVRJTkciLCJFTkRfQUxJR05FRCIsIldJVEhfVFJBSUxJTkdfSUNPTiIsIldJVEhfSU5URVJOQUxfQ09VTlRFUiIsIkFGRklYIiwiQUZGSVhfUFJFRklYIiwiQUZGSVhfU1VGRklYIiwiUkVTSVpFUiIsIkhFTFBFUl9MSU5FIiwiSEVMUEVSX1RFWFRfUEVSU0lTVEVOVCIsIkhFTFBFUl9URVhUX1ZBTElEQVRJT04iLCJDSEFSQUNURVJfQ09VTlRFUiIsIkNoYXJhY3RlckNvdW50ZXIiLCJtYXhWYWx1ZSIsInRleHRhcmVhIiwiYXV0b1Jlc2l6ZSIsInNldEhlaWdodCIsIlJlc2l6ZXIiLCJUZXh0RmllbGQiLCJkZWZhdWx0VmFsdWUiLCJwcmVmaXgiLCJzdWZmaXgiLCJwZXJzaXN0ZW50SGVscGVyVGV4dCIsInZhbGlkYXRpb25NZXNzYWdlIiwiZW5kQWxpZ25lZCIsImNoYXJhY3RlckNvdW50ZXIiLCJpbnRlcm5hbENoYXJhY3RlckNvdW50ZXIiLCJvbkZvY3VzIiwib25CbHVyIiwidmFsaWQiLCJzZXRWYWxpZCIsImNvdW50Iiwic2V0Q291bnQiLCJoYW5kbGVJbnRlcmFjdGlvbiIsImhhbmRsZUlucHV0Rm9jdXMiLCJoYW5kbGVJbnB1dEJsdXIiLCJoYW5kbGVJbnB1dENoYW5nZSIsImlzVmFsaWQiLCJ2YWxpZGl0eSIsImhhc0hlbHBlckxpbmUiLCJtYXhMZW5ndGgiLCJvdXRsaW5lIiwiZGVuc2UiLCJERUJPVU5DRV9USFJPVFRMRV9SRVNJWkVfVElNRV9NUyIsIk1BWF9UT1BfQVBQX0JBUl9IRUlHSFQiLCJGSVhFRF9TQ1JPTExFRCIsIkZJWEVEX0FESlVTVCIsIlBST01JTkVOVCIsIlBST01JTkVOVF9GSVhFRF9BREpVU1QiLCJERU5TRSIsIkRFTlNFX0ZJWEVEX0FESlVTVCIsIkRFTlNFX1BST01JTkVOVF9GSVhFRF9BREpVU1QiLCJTSE9SVCIsIlNIT1JUX0NPTExBUFNFRCIsIlNIT1JUX0ZJWEVEX0FESlVTVCIsIlNUSUNLWSIsIlNUSUNLWV9ISURERU4iLCJTVElDS1lfU0hPV04iLCJTRUNUSU9OX0FMSUdOX1NUQVJUIiwiU0VDVElPTl9BTElHTl9DRU5URVIiLCJTRUNUSU9OX0FMSUdOX0VORCIsIk5BVklHQVRJT05fSUNPTiIsIkFDVElPTl9JVEVNIiwiVG9wQXBwQmFyUm93IiwiVG9wQXBwQmFyU2VjdGlvbiIsIlRvcEFwcEJhciIsIm5hdmlnYXRpb25JY29uIiwiYWN0aW9uSXRlbXMiLCJzdGlja3kiLCJwcm9taW5lbnQiLCJzaG9ydCIsImNvbGxhcHNlZCIsIm9uTmF2aWdhdGlvbkljb25DbGljayIsInNjcm9sbGVkIiwic2V0U2Nyb2xsZWQiLCJoaWRkZW4iLCJzZXRIaWRkZW4iLCJsYXN0U2Nyb2xsUG9zaXRpb24iLCJzY3JvbGxWYWx1ZSIsInBhZ2VZT2Zmc2V0IiwiY3VycmVudFNjcm9sbFBvc2l0aW9uIiwiZGlmZiIsInNob3VsZEhpZGUiLCJUb3BBcHBCYXJBY3Rpb25JdGVtIiwiVG9wQXBwQmFyRml4ZWRBZGp1c3QiLCJUb3BBcHBCYXJOYXZpZ2F0aW9uSWNvbiIsIlRvcEFwcEJhclRpdGxlIiwiQWN0aW9uSXRlbSIsIkZpeGVkQWRqdXN0IiwiTmF2aWdhdGlvbkljb24iLCJUaXRsZSIsImVsZW1lbnRzQnlUeXBlIiwiaGVhZGxpbmUxIiwiaGVhZGxpbmUyIiwiaGVhZGxpbmUzIiwiaGVhZGxpbmU0IiwiaGVhZGxpbmU1IiwiaGVhZGxpbmU2Iiwic3VidGl0bGUxIiwic3VidGl0bGUyIiwiYm9keTEiLCJib2R5MiIsImNhcHRpb24iLCJESVNQTEFZIiwiTk9fTUFSR0lOIiwiTk9fV1JBUCIsIlR5cG9ncmFwaHkiLCJkaXNwbGF5Iiwibm9NYXJnaW4iLCJub1dyYXAiLCJUZXh0IiwianN4VG9IdG1sIiwicHJpbnRDb21wb25lbnQiLCJkZXB0aCIsInJlcGxhY2UiLCJlbnRyaWVzIiwiaW5kZW50IiwicmVwZWF0IiwiaXNFbXB0eSIsInByaW50UHJvcHMiLCJlbmRzV2l0aCIsInByaW50UHJvcCIsInByaW50VmFsdWUiLCJobGpzIiwiamF2YXNjcmlwdCIsInNjc3MiLCJzaGVsbCIsInBsYWludGV4dCIsInhtbCIsInJlZ2lzdGVyTGFuZ3VhZ2UiLCJoaWdobGlnaHQiLCJjb2RlIiwibGFuZyIsImxhbmd1YWdlIiwiZ2V0TGFuZ3VhZ2UiLCJDb2RlIiwiaHRtbCIsIl9faHRtbCIsIkRlbW8iLCJkZXNjcmlwdGlvbiIsInNldHVwIiwic2V0dGluZ3MiLCJpc0NvZGVPcGVuIiwic2V0Q29kZU9wZW4iLCJpc1NldHRpbmdzT3BlbiIsInNldFNldHRpbmdzT3BlbiIsIkZpZWxkU2V0IiwibGVnZW5kIiwiUGFnZSIsImxpbmtzIiwiZ3VpZGUiLCJkb2NzIiwiQXZhdGFyUGFnZSIsInNldFNpemUiLCJzZXRDb250ZW50IiwiaWNvbkJ1dHRvbiIsIkJhZGdlUGFnZSIsInNldFZhbHVlIiwic2V0VHlwZSIsInNldEluc2V0Iiwic2V0VHJhbnNwYXJlbnQiLCJzZXRPcGVuIiwic2V0VGV4dCIsImhhc0ljb24iLCJzZXRIYXNJY29uIiwic2V0SWNvbiIsImhhc0FjdGlvbiIsInNldEhhc0FjdGlvbiIsInNldEFjdGlvbiIsImhhc1NlY29uZGFyeUFjdGlvbiIsInNldEhhc1NlY29uZGFyeUFjdGlvbiIsInNldFNlY29uZGFyeUFjdGlvbiIsInNldENlbnRlcmVkIiwic2V0Rml4ZWQiLCJzZXRNb2JpbGVTdGFja2VkIiwiQnV0dG9uUGFnZSIsInNldExhYmVsIiwiaGFzTGVhZGluZ0ljb24iLCJzZXRIYXNMZWFkaW5nSWNvbiIsInNldExlYWRpbmdJY29uIiwiaGFzVHJhaWxpbmdJY29uIiwic2V0SGFzVHJhaWxpbmdJY29uIiwic2V0VHJhaWxpbmdJY29uIiwicGFnZVRpdGxlIiwiQ2FyZFBhZ2UiLCJoYXNUaXRsZSIsInNldEhhc1RpdGxlIiwic2V0VGl0bGUiLCJoYXNTdWJ0aXRsZSIsInNldEhhc1N1YnRpdGxlIiwic2V0U3VidGl0bGUiLCJDaGVja2JveFBhZ2UiLCJzZXRDaGVja2VkIiwiY29udHJvbGxlZCIsInNldENvbnRyb2xsZWQiLCJzZXRJbmRldGVybWluYXRlIiwic2V0RGlzYWJsZWQiLCJDaGlwc1BhZ2UiLCJjaG9pY2VDaGlwIiwic2V0Q2hvaWNlQ2hpcHMiLCJmaWx0ZXJDaGlwcyIsInNldEZpbHRlckNoaXBzIiwiQ2lyY3VsYXJQcm9ncmVzc1BhZ2UiLCJzZXRDb2xvcmZ1bCIsInNldENsb3NlZCIsInRhYmxlIiwiRGF0YVRhYmxlUGFnZSIsImRhdGEiLCJzZXREYXRhIiwic2V0U29ydCIsImhhbmRsZVNvcnQiLCJzbGljZSIsImEiLCJiIiwic2Nyb2xsYWJsZUNvbnRlbnQiLCJEaWFsb2dQYWdlIiwiaXNCYXNpY09wZW4iLCJzZXRCYXNpY09wZW4iLCJpc0NvbmZpcm1hdGlvbk9wZW4iLCJzZXRDb25maXJtYXRpb25PcGVuIiwiaXNTdGFja2luZ09wZW4iLCJzZXRTdGFja2luZ09wZW4iLCJpc1Njcm9sbGFibGVPcGVuIiwic2V0U2Nyb2xsYWJsZU9wZW4iLCJpc0Z1bGxzY3JlZW5PcGVuIiwic2V0RnVsbHNjcmVlbk9wZW4iLCJpc0Zsb2F0aW5nU2hlZXRPcGVuIiwic2V0RmxvYXRpbmdTaGVldE9wZW4iLCJEcmF3ZXJQYWdlIiwiaXNEaXNtaXNzaWJsZU9wZW4iLCJzZXREaXNtaXNzaWJsZU9wZW4iLCJpc01vZGFsT3BlbiIsInNldE1vZGFsT3BlbiIsIkVsZXZhdGlvblBhZ2UiLCJzZXRaIiwiRkFCUGFnZSIsImlzRXhpdGVkIiwic2V0RXhpdGVkIiwiRm9ybUZpZWxkUGFnZSIsIm1hcmtlZCIsInNldE9wdGlvbnMiLCJsYW5nUHJlZml4IiwibWFya2Rvd24iLCJwY2tnIiwicmVhZG1lIiwiSG9tZVBhZ2UiLCJ2ZXJzaW9uIiwiSWNvblBhZ2UiLCJzZXROYW1lIiwidG9uZSIsInNldFRvbmUiLCJzZXRJbmFjdGl2ZSIsIkljb25CdXR0b25QYWdlIiwiaXNPbiIsInNldE9uIiwic3RhbmRhcmRJdGVtcyIsIm1hc29ucnlJdGVtcyIsInJhbmRvbSIsIkltYWdlTGlzdFBhZ2UiLCJMYXlvdXRHcmlkUGFnZSIsIkxpbmVhclByb2dyZXNzUGFnZSIsImlzQ2xvc2VkIiwiTGlzdFBhZ2UiLCJNZW51UGFnZSIsImlzUXVpY2tPcGVuIiwic2V0UXVpY2tPcGVuIiwiaXNQZXJzaXN0ZW50T3BlbiIsInNldFBlcnNpc3RlbnRPcGVuIiwiaXNBbmNob3JlZE9wZW4iLCJzZXRBbmNob3JlZE9wZW4iLCJhbmNob3JQb3NpdGlvbiIsInNldEFuY2hvclBvc2l0aW9uIiwic2V0QW5jaG9yT3JpZ2luIiwic2V0VHJhbnNmb3JtT3JpZ2luIiwiaXNEaWFsb2dPcGVuIiwic2V0RGlhbG9nT3BlbiIsImhhbmRsZUFuY2hvclBvc2l0aW9uQ2hhbmdlIiwiaGFuZGxlQW5jaG9yT3JpZ2luQ2hhbmdlIiwiaGFuZGxlVHJhbnNmb3JtT3JpZ2luQ2hhbmdlIiwiUmFkaW9QYWdlIiwidmFsdWUxIiwic2V0VmFsdWUxIiwidmFsdWUyIiwic2V0VmFsdWUyIiwiaGFuZGxlQ2hhbmdlMSIsImhhbmRsZUNoYW5nZTIiLCJTZWdtZW50ZWRCdXR0b25QYWdlIiwidmFsdWUzIiwic2V0VmFsdWUzIiwiU2VsZWN0UGFnZSIsInNldEZpbGxlZCIsInNldE91dGxpbmVkIiwicHJlc2VsZWN0ZWQiLCJzZXRQcmVzZWxlY3RlZCIsInNldE11bHRpcGxlIiwiU2lkZVNoZWV0UGFnZSIsIlNsaWRlclBhZ2UiLCJTbmFja2JhclBhZ2UiLCJpc09wZW4iLCJpc0xlYWRpbmciLCJzZXRMZWFkaW5nIiwiaXNTdGFja2VkIiwic2V0U3RhY2tlZCIsIlN3aXRjaFBhZ2UiLCJpc1NlbGVjdGVkIiwic2V0U2VsZWN0ZWQiLCJTeW1ib2xQYWdlIiwic2V0V2VpZ2h0Iiwic2V0R3JhZGUiLCJiYXNpYyIsInNldEJhc2ljIiwic2V0TWluV2lkdGgiLCJzZXRNaW5XaWR0aEluZGljYXRvciIsIm1pbldpZHRoV2l0aE1pbldpZHRoSW5kaWNhdG9yIiwic2V0TWluV2lkdGhXaXRoTWluV2lkdGhJbmRpY2F0b3IiLCJzZXRGYWRlIiwiaWNvbnMiLCJzZXRJY29ucyIsInN0YWNrZWRJY29ucyIsInNldFN0YWNrZWRJY29ucyIsIm9ubHlJY29ucyIsInNldE9ubHlJY29ucyIsInNldEljb25JbmRpY2F0b3IiLCJzY3JvbGwiLCJzZXRTY3JvbGwiLCJUeXBvZ3JhcGh5UGFnZSIsImlzRmlsbGVkIiwiaXNPdXRsaW5lZCIsIlRvb2x0aXBQYWdlIiwiVG9wQXBwQmFyUGFnZSIsImlzQ29sbGFwc2VkIiwic2V0Q29sbGFwc2VkIiwiQ2hpcHMiLCJIb21lIiwiVGFicyIsInVybCIsIlJvdXRlIiwiTGluayIsIk5hdkxpbmsiLCJyb3V0ZXMiLCJBcHAiLCJhY3RpdmVOYXZJdGVtIiwic2Nyb2xsSW50b1ZpZXciLCJibG9jayIsInJvdXRlIiwiZXhhY3QiLCJCcm93c2VyUm91dGVyIiwiUm91dGVyIiwicmVuZGVyIiwiYmFzZW5hbWUiLCJwcm9jZXNzIiwiZW52IiwiRU5WIiwicHJvZHVjdGlvbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///929\n')},184:(module,exports)=>{eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!\n  Copyright (c) 2018 Jed Watson.\n  Licensed under the MIT License (MIT), see\n  http://jedwatson.github.io/classnames\n*/\n/* global define */\n\n(function () {\n\t'use strict';\n\n\tvar hasOwn = {}.hasOwnProperty;\n\n\tfunction classNames() {\n\t\tvar classes = [];\n\n\t\tfor (var i = 0; i < arguments.length; i++) {\n\t\t\tvar arg = arguments[i];\n\t\t\tif (!arg) continue;\n\n\t\t\tvar argType = typeof arg;\n\n\t\t\tif (argType === 'string' || argType === 'number') {\n\t\t\t\tclasses.push(arg);\n\t\t\t} else if (Array.isArray(arg)) {\n\t\t\t\tif (arg.length) {\n\t\t\t\t\tvar inner = classNames.apply(null, arg);\n\t\t\t\t\tif (inner) {\n\t\t\t\t\t\tclasses.push(inner);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (argType === 'object') {\n\t\t\t\tif (arg.toString === Object.prototype.toString) {\n\t\t\t\t\tfor (var key in arg) {\n\t\t\t\t\t\tif (hasOwn.call(arg, key) && arg[key]) {\n\t\t\t\t\t\t\tclasses.push(key);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tclasses.push(arg.toString());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn classes.join(' ');\n\t}\n\n\tif ( true && module.exports) {\n\t\tclassNames.default = classNames;\n\t\tmodule.exports = classNames;\n\t} else if (true) {\n\t\t// register as 'classnames', consistent with npm package name\n\t\t!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function () {\n\t\t\treturn classNames;\n\t\t}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t} else {}\n}());\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTg0LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGdCQUFnQjs7QUFFaEI7QUFDQTs7QUFFQSxrQkFBa0Isc0JBQXNCO0FBQ3hDO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsS0FBSyxLQUE2QjtBQUNsQztBQUNBO0FBQ0EsR0FBRyxTQUFTLElBQTRFO0FBQ3hGO0FBQ0EsRUFBRSxpQ0FBcUIsRUFBRSxtQ0FBRTtBQUMzQjtBQUNBLEdBQUc7QUFBQSxrR0FBQztBQUNKLEdBQUcsS0FBSyxFQUVOO0FBQ0YsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL21kYy1yZWFjdC8uL25vZGVfbW9kdWxlcy9jbGFzc25hbWVzL2luZGV4LmpzPzRkMjYiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gIENvcHlyaWdodCAoYykgMjAxOCBKZWQgV2F0c29uLlxuICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UgKE1JVCksIHNlZVxuICBodHRwOi8vamVkd2F0c29uLmdpdGh1Yi5pby9jbGFzc25hbWVzXG4qL1xuLyogZ2xvYmFsIGRlZmluZSAqL1xuXG4oZnVuY3Rpb24gKCkge1xuXHQndXNlIHN0cmljdCc7XG5cblx0dmFyIGhhc093biA9IHt9Lmhhc093blByb3BlcnR5O1xuXG5cdGZ1bmN0aW9uIGNsYXNzTmFtZXMoKSB7XG5cdFx0dmFyIGNsYXNzZXMgPSBbXTtcblxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgYXJnID0gYXJndW1lbnRzW2ldO1xuXHRcdFx0aWYgKCFhcmcpIGNvbnRpbnVlO1xuXG5cdFx0XHR2YXIgYXJnVHlwZSA9IHR5cGVvZiBhcmc7XG5cblx0XHRcdGlmIChhcmdUeXBlID09PSAnc3RyaW5nJyB8fCBhcmdUeXBlID09PSAnbnVtYmVyJykge1xuXHRcdFx0XHRjbGFzc2VzLnB1c2goYXJnKTtcblx0XHRcdH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShhcmcpKSB7XG5cdFx0XHRcdGlmIChhcmcubGVuZ3RoKSB7XG5cdFx0XHRcdFx0dmFyIGlubmVyID0gY2xhc3NOYW1lcy5hcHBseShudWxsLCBhcmcpO1xuXHRcdFx0XHRcdGlmIChpbm5lcikge1xuXHRcdFx0XHRcdFx0Y2xhc3Nlcy5wdXNoKGlubmVyKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSBpZiAoYXJnVHlwZSA9PT0gJ29iamVjdCcpIHtcblx0XHRcdFx0aWYgKGFyZy50b1N0cmluZyA9PT0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZykge1xuXHRcdFx0XHRcdGZvciAodmFyIGtleSBpbiBhcmcpIHtcblx0XHRcdFx0XHRcdGlmIChoYXNPd24uY2FsbChhcmcsIGtleSkgJiYgYXJnW2tleV0pIHtcblx0XHRcdFx0XHRcdFx0Y2xhc3Nlcy5wdXNoKGtleSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGNsYXNzZXMucHVzaChhcmcudG9TdHJpbmcoKSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gY2xhc3Nlcy5qb2luKCcgJyk7XG5cdH1cblxuXHRpZiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgbW9kdWxlLmV4cG9ydHMpIHtcblx0XHRjbGFzc05hbWVzLmRlZmF1bHQgPSBjbGFzc05hbWVzO1xuXHRcdG1vZHVsZS5leHBvcnRzID0gY2xhc3NOYW1lcztcblx0fSBlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBkZWZpbmUuYW1kID09PSAnb2JqZWN0JyAmJiBkZWZpbmUuYW1kKSB7XG5cdFx0Ly8gcmVnaXN0ZXIgYXMgJ2NsYXNzbmFtZXMnLCBjb25zaXN0ZW50IHdpdGggbnBtIHBhY2thZ2UgbmFtZVxuXHRcdGRlZmluZSgnY2xhc3NuYW1lcycsIFtdLCBmdW5jdGlvbiAoKSB7XG5cdFx0XHRyZXR1cm4gY2xhc3NOYW1lcztcblx0XHR9KTtcblx0fSBlbHNlIHtcblx0XHR3aW5kb3cuY2xhc3NOYW1lcyA9IGNsYXNzTmFtZXM7XG5cdH1cbn0oKSk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///184\n")},679:(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("\n\nvar reactIs = __webpack_require__(864);\n\n/**\n * Copyright 2015, Yahoo! Inc.\n * Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.\n */\nvar REACT_STATICS = {\n  childContextTypes: true,\n  contextType: true,\n  contextTypes: true,\n  defaultProps: true,\n  displayName: true,\n  getDefaultProps: true,\n  getDerivedStateFromError: true,\n  getDerivedStateFromProps: true,\n  mixins: true,\n  propTypes: true,\n  type: true\n};\nvar KNOWN_STATICS = {\n  name: true,\n  length: true,\n  prototype: true,\n  caller: true,\n  callee: true,\n  arguments: true,\n  arity: true\n};\nvar FORWARD_REF_STATICS = {\n  '$$typeof': true,\n  render: true,\n  defaultProps: true,\n  displayName: true,\n  propTypes: true\n};\nvar MEMO_STATICS = {\n  '$$typeof': true,\n  compare: true,\n  defaultProps: true,\n  displayName: true,\n  propTypes: true,\n  type: true\n};\nvar TYPE_STATICS = {};\nTYPE_STATICS[reactIs.ForwardRef] = FORWARD_REF_STATICS;\nTYPE_STATICS[reactIs.Memo] = MEMO_STATICS;\n\nfunction getStatics(component) {\n  // React v16.11 and below\n  if (reactIs.isMemo(component)) {\n    return MEMO_STATICS;\n  } // React v16.12 and above\n\n\n  return TYPE_STATICS[component['$$typeof']] || REACT_STATICS;\n}\n\nvar defineProperty = Object.defineProperty;\nvar getOwnPropertyNames = Object.getOwnPropertyNames;\nvar getOwnPropertySymbols = Object.getOwnPropertySymbols;\nvar getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\nvar getPrototypeOf = Object.getPrototypeOf;\nvar objectPrototype = Object.prototype;\nfunction hoistNonReactStatics(targetComponent, sourceComponent, blacklist) {\n  if (typeof sourceComponent !== 'string') {\n    // don't hoist over string (html) components\n    if (objectPrototype) {\n      var inheritedComponent = getPrototypeOf(sourceComponent);\n\n      if (inheritedComponent && inheritedComponent !== objectPrototype) {\n        hoistNonReactStatics(targetComponent, inheritedComponent, blacklist);\n      }\n    }\n\n    var keys = getOwnPropertyNames(sourceComponent);\n\n    if (getOwnPropertySymbols) {\n      keys = keys.concat(getOwnPropertySymbols(sourceComponent));\n    }\n\n    var targetStatics = getStatics(targetComponent);\n    var sourceStatics = getStatics(sourceComponent);\n\n    for (var i = 0; i < keys.length; ++i) {\n      var key = keys[i];\n\n      if (!KNOWN_STATICS[key] && !(blacklist && blacklist[key]) && !(sourceStatics && sourceStatics[key]) && !(targetStatics && targetStatics[key])) {\n        var descriptor = getOwnPropertyDescriptor(sourceComponent, key);\n\n        try {\n          // Avoid failures from read-only properties\n          defineProperty(targetComponent, key, descriptor);\n        } catch (e) {}\n      }\n    }\n  }\n\n  return targetComponent;\n}\n\nmodule.exports = hoistNonReactStatics;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjc5LmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLGNBQWMsbUJBQU8sQ0FBQyxHQUFVOztBQUVoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLG9CQUFvQixpQkFBaUI7QUFDckM7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9ub2RlX21vZHVsZXMvaG9pc3Qtbm9uLXJlYWN0LXN0YXRpY3MvZGlzdC9ob2lzdC1ub24tcmVhY3Qtc3RhdGljcy5janMuanM/ZGE2YSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbnZhciByZWFjdElzID0gcmVxdWlyZSgncmVhY3QtaXMnKTtcblxuLyoqXG4gKiBDb3B5cmlnaHQgMjAxNSwgWWFob28hIEluYy5cbiAqIENvcHlyaWdodHMgbGljZW5zZWQgdW5kZXIgdGhlIE5ldyBCU0QgTGljZW5zZS4gU2VlIHRoZSBhY2NvbXBhbnlpbmcgTElDRU5TRSBmaWxlIGZvciB0ZXJtcy5cbiAqL1xudmFyIFJFQUNUX1NUQVRJQ1MgPSB7XG4gIGNoaWxkQ29udGV4dFR5cGVzOiB0cnVlLFxuICBjb250ZXh0VHlwZTogdHJ1ZSxcbiAgY29udGV4dFR5cGVzOiB0cnVlLFxuICBkZWZhdWx0UHJvcHM6IHRydWUsXG4gIGRpc3BsYXlOYW1lOiB0cnVlLFxuICBnZXREZWZhdWx0UHJvcHM6IHRydWUsXG4gIGdldERlcml2ZWRTdGF0ZUZyb21FcnJvcjogdHJ1ZSxcbiAgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzOiB0cnVlLFxuICBtaXhpbnM6IHRydWUsXG4gIHByb3BUeXBlczogdHJ1ZSxcbiAgdHlwZTogdHJ1ZVxufTtcbnZhciBLTk9XTl9TVEFUSUNTID0ge1xuICBuYW1lOiB0cnVlLFxuICBsZW5ndGg6IHRydWUsXG4gIHByb3RvdHlwZTogdHJ1ZSxcbiAgY2FsbGVyOiB0cnVlLFxuICBjYWxsZWU6IHRydWUsXG4gIGFyZ3VtZW50czogdHJ1ZSxcbiAgYXJpdHk6IHRydWVcbn07XG52YXIgRk9SV0FSRF9SRUZfU1RBVElDUyA9IHtcbiAgJyQkdHlwZW9mJzogdHJ1ZSxcbiAgcmVuZGVyOiB0cnVlLFxuICBkZWZhdWx0UHJvcHM6IHRydWUsXG4gIGRpc3BsYXlOYW1lOiB0cnVlLFxuICBwcm9wVHlwZXM6IHRydWVcbn07XG52YXIgTUVNT19TVEFUSUNTID0ge1xuICAnJCR0eXBlb2YnOiB0cnVlLFxuICBjb21wYXJlOiB0cnVlLFxuICBkZWZhdWx0UHJvcHM6IHRydWUsXG4gIGRpc3BsYXlOYW1lOiB0cnVlLFxuICBwcm9wVHlwZXM6IHRydWUsXG4gIHR5cGU6IHRydWVcbn07XG52YXIgVFlQRV9TVEFUSUNTID0ge307XG5UWVBFX1NUQVRJQ1NbcmVhY3RJcy5Gb3J3YXJkUmVmXSA9IEZPUldBUkRfUkVGX1NUQVRJQ1M7XG5UWVBFX1NUQVRJQ1NbcmVhY3RJcy5NZW1vXSA9IE1FTU9fU1RBVElDUztcblxuZnVuY3Rpb24gZ2V0U3RhdGljcyhjb21wb25lbnQpIHtcbiAgLy8gUmVhY3QgdjE2LjExIGFuZCBiZWxvd1xuICBpZiAocmVhY3RJcy5pc01lbW8oY29tcG9uZW50KSkge1xuICAgIHJldHVybiBNRU1PX1NUQVRJQ1M7XG4gIH0gLy8gUmVhY3QgdjE2LjEyIGFuZCBhYm92ZVxuXG5cbiAgcmV0dXJuIFRZUEVfU1RBVElDU1tjb21wb25lbnRbJyQkdHlwZW9mJ11dIHx8IFJFQUNUX1NUQVRJQ1M7XG59XG5cbnZhciBkZWZpbmVQcm9wZXJ0eSA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBnZXRPd25Qcm9wZXJ0eU5hbWVzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXM7XG52YXIgZ2V0T3duUHJvcGVydHlTeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scztcbnZhciBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xudmFyIGdldFByb3RvdHlwZU9mID0gT2JqZWN0LmdldFByb3RvdHlwZU9mO1xudmFyIG9iamVjdFByb3RvdHlwZSA9IE9iamVjdC5wcm90b3R5cGU7XG5mdW5jdGlvbiBob2lzdE5vblJlYWN0U3RhdGljcyh0YXJnZXRDb21wb25lbnQsIHNvdXJjZUNvbXBvbmVudCwgYmxhY2tsaXN0KSB7XG4gIGlmICh0eXBlb2Ygc291cmNlQ29tcG9uZW50ICE9PSAnc3RyaW5nJykge1xuICAgIC8vIGRvbid0IGhvaXN0IG92ZXIgc3RyaW5nIChodG1sKSBjb21wb25lbnRzXG4gICAgaWYgKG9iamVjdFByb3RvdHlwZSkge1xuICAgICAgdmFyIGluaGVyaXRlZENvbXBvbmVudCA9IGdldFByb3RvdHlwZU9mKHNvdXJjZUNvbXBvbmVudCk7XG5cbiAgICAgIGlmIChpbmhlcml0ZWRDb21wb25lbnQgJiYgaW5oZXJpdGVkQ29tcG9uZW50ICE9PSBvYmplY3RQcm90b3R5cGUpIHtcbiAgICAgICAgaG9pc3ROb25SZWFjdFN0YXRpY3ModGFyZ2V0Q29tcG9uZW50LCBpbmhlcml0ZWRDb21wb25lbnQsIGJsYWNrbGlzdCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGtleXMgPSBnZXRPd25Qcm9wZXJ0eU5hbWVzKHNvdXJjZUNvbXBvbmVudCk7XG5cbiAgICBpZiAoZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gICAgICBrZXlzID0ga2V5cy5jb25jYXQoZ2V0T3duUHJvcGVydHlTeW1ib2xzKHNvdXJjZUNvbXBvbmVudCkpO1xuICAgIH1cblxuICAgIHZhciB0YXJnZXRTdGF0aWNzID0gZ2V0U3RhdGljcyh0YXJnZXRDb21wb25lbnQpO1xuICAgIHZhciBzb3VyY2VTdGF0aWNzID0gZ2V0U3RhdGljcyhzb3VyY2VDb21wb25lbnQpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKSB7XG4gICAgICB2YXIga2V5ID0ga2V5c1tpXTtcblxuICAgICAgaWYgKCFLTk9XTl9TVEFUSUNTW2tleV0gJiYgIShibGFja2xpc3QgJiYgYmxhY2tsaXN0W2tleV0pICYmICEoc291cmNlU3RhdGljcyAmJiBzb3VyY2VTdGF0aWNzW2tleV0pICYmICEodGFyZ2V0U3RhdGljcyAmJiB0YXJnZXRTdGF0aWNzW2tleV0pKSB7XG4gICAgICAgIHZhciBkZXNjcmlwdG9yID0gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZUNvbXBvbmVudCwga2V5KTtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgIC8vIEF2b2lkIGZhaWx1cmVzIGZyb20gcmVhZC1vbmx5IHByb3BlcnRpZXNcbiAgICAgICAgICBkZWZpbmVQcm9wZXJ0eSh0YXJnZXRDb21wb25lbnQsIGtleSwgZGVzY3JpcHRvcik7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRhcmdldENvbXBvbmVudDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBob2lzdE5vblJlYWN0U3RhdGljcztcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///679\n")},826:module=>{eval("module.exports = Array.isArray || function (arr) {\n  return Object.prototype.toString.call(arr) == '[object Array]';\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODI2LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL21kYy1yZWFjdC8uL25vZGVfbW9kdWxlcy9pc2FycmF5L2luZGV4LmpzP2UzZGIiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uIChhcnIpIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChhcnIpID09ICdbb2JqZWN0IEFycmF5XSc7XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///826\n")},84:function(module){eval("/**\n * marked - a markdown parser\n * Copyright (c) 2011-2021, Christopher Jeffrey. (MIT Licensed)\n * https://github.com/markedjs/marked\n */\n\n/**\n * DO NOT EDIT THIS FILE\n * The code in this file is generated from files in ./src/\n */\n\n(function (global, factory) {\n   true ? module.exports = factory() :\n  0;\n})(this, (function () { 'use strict';\n\n  function _defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  function _createClass(Constructor, protoProps, staticProps) {\n    if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) _defineProperties(Constructor, staticProps);\n    return Constructor;\n  }\n\n  function _unsupportedIterableToArray(o, minLen) {\n    if (!o) return;\n    if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n    var n = Object.prototype.toString.call(o).slice(8, -1);\n    if (n === \"Object\" && o.constructor) n = o.constructor.name;\n    if (n === \"Map\" || n === \"Set\") return Array.from(o);\n    if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n  }\n\n  function _arrayLikeToArray(arr, len) {\n    if (len == null || len > arr.length) len = arr.length;\n\n    for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n\n    return arr2;\n  }\n\n  function _createForOfIteratorHelperLoose(o, allowArrayLike) {\n    var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"];\n    if (it) return (it = it.call(o)).next.bind(it);\n\n    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n      return function () {\n        if (i >= o.length) return {\n          done: true\n        };\n        return {\n          done: false,\n          value: o[i++]\n        };\n      };\n    }\n\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n\n  var defaults$5 = {exports: {}};\n\n  function getDefaults$1() {\n    return {\n      baseUrl: null,\n      breaks: false,\n      extensions: null,\n      gfm: true,\n      headerIds: true,\n      headerPrefix: '',\n      highlight: null,\n      langPrefix: 'language-',\n      mangle: true,\n      pedantic: false,\n      renderer: null,\n      sanitize: false,\n      sanitizer: null,\n      silent: false,\n      smartLists: false,\n      smartypants: false,\n      tokenizer: null,\n      walkTokens: null,\n      xhtml: false\n    };\n  }\n\n  function changeDefaults$1(newDefaults) {\n    defaults$5.exports.defaults = newDefaults;\n  }\n\n  defaults$5.exports = {\n    defaults: getDefaults$1(),\n    getDefaults: getDefaults$1,\n    changeDefaults: changeDefaults$1\n  };\n\n  /**\n   * Helpers\n   */\n  var escapeTest = /[&<>\"']/;\n  var escapeReplace = /[&<>\"']/g;\n  var escapeTestNoEncode = /[<>\"']|&(?!#?\\w+;)/;\n  var escapeReplaceNoEncode = /[<>\"']|&(?!#?\\w+;)/g;\n  var escapeReplacements = {\n    '&': '&amp;',\n    '<': '&lt;',\n    '>': '&gt;',\n    '\"': '&quot;',\n    \"'\": '&#39;'\n  };\n\n  var getEscapeReplacement = function getEscapeReplacement(ch) {\n    return escapeReplacements[ch];\n  };\n\n  function escape$2(html, encode) {\n    if (encode) {\n      if (escapeTest.test(html)) {\n        return html.replace(escapeReplace, getEscapeReplacement);\n      }\n    } else {\n      if (escapeTestNoEncode.test(html)) {\n        return html.replace(escapeReplaceNoEncode, getEscapeReplacement);\n      }\n    }\n\n    return html;\n  }\n\n  var unescapeTest = /&(#(?:\\d+)|(?:#x[0-9A-Fa-f]+)|(?:\\w+));?/ig;\n\n  function unescape$1(html) {\n    // explicitly match decimal, hex, and named HTML entities\n    return html.replace(unescapeTest, function (_, n) {\n      n = n.toLowerCase();\n      if (n === 'colon') return ':';\n\n      if (n.charAt(0) === '#') {\n        return n.charAt(1) === 'x' ? String.fromCharCode(parseInt(n.substring(2), 16)) : String.fromCharCode(+n.substring(1));\n      }\n\n      return '';\n    });\n  }\n\n  var caret = /(^|[^\\[])\\^/g;\n\n  function edit$1(regex, opt) {\n    regex = regex.source || regex;\n    opt = opt || '';\n    var obj = {\n      replace: function replace(name, val) {\n        val = val.source || val;\n        val = val.replace(caret, '$1');\n        regex = regex.replace(name, val);\n        return obj;\n      },\n      getRegex: function getRegex() {\n        return new RegExp(regex, opt);\n      }\n    };\n    return obj;\n  }\n\n  var nonWordAndColonTest = /[^\\w:]/g;\n  var originIndependentUrl = /^$|^[a-z][a-z0-9+.-]*:|^[?#]/i;\n\n  function cleanUrl$1(sanitize, base, href) {\n    if (sanitize) {\n      var prot;\n\n      try {\n        prot = decodeURIComponent(unescape$1(href)).replace(nonWordAndColonTest, '').toLowerCase();\n      } catch (e) {\n        return null;\n      }\n\n      if (prot.indexOf('javascript:') === 0 || prot.indexOf('vbscript:') === 0 || prot.indexOf('data:') === 0) {\n        return null;\n      }\n    }\n\n    if (base && !originIndependentUrl.test(href)) {\n      href = resolveUrl(base, href);\n    }\n\n    try {\n      href = encodeURI(href).replace(/%25/g, '%');\n    } catch (e) {\n      return null;\n    }\n\n    return href;\n  }\n\n  var baseUrls = {};\n  var justDomain = /^[^:]+:\\/*[^/]*$/;\n  var protocol = /^([^:]+:)[\\s\\S]*$/;\n  var domain = /^([^:]+:\\/*[^/]*)[\\s\\S]*$/;\n\n  function resolveUrl(base, href) {\n    if (!baseUrls[' ' + base]) {\n      // we can ignore everything in base after the last slash of its path component,\n      // but we might need to add _that_\n      // https://tools.ietf.org/html/rfc3986#section-3\n      if (justDomain.test(base)) {\n        baseUrls[' ' + base] = base + '/';\n      } else {\n        baseUrls[' ' + base] = rtrim$1(base, '/', true);\n      }\n    }\n\n    base = baseUrls[' ' + base];\n    var relativeBase = base.indexOf(':') === -1;\n\n    if (href.substring(0, 2) === '//') {\n      if (relativeBase) {\n        return href;\n      }\n\n      return base.replace(protocol, '$1') + href;\n    } else if (href.charAt(0) === '/') {\n      if (relativeBase) {\n        return href;\n      }\n\n      return base.replace(domain, '$1') + href;\n    } else {\n      return base + href;\n    }\n  }\n\n  var noopTest$1 = {\n    exec: function noopTest() {}\n  };\n\n  function merge$2(obj) {\n    var i = 1,\n        target,\n        key;\n\n    for (; i < arguments.length; i++) {\n      target = arguments[i];\n\n      for (key in target) {\n        if (Object.prototype.hasOwnProperty.call(target, key)) {\n          obj[key] = target[key];\n        }\n      }\n    }\n\n    return obj;\n  }\n\n  function splitCells$1(tableRow, count) {\n    // ensure that every cell-delimiting pipe has a space\n    // before it to distinguish it from an escaped pipe\n    var row = tableRow.replace(/\\|/g, function (match, offset, str) {\n      var escaped = false,\n          curr = offset;\n\n      while (--curr >= 0 && str[curr] === '\\\\') {\n        escaped = !escaped;\n      }\n\n      if (escaped) {\n        // odd number of slashes means | is escaped\n        // so we leave it alone\n        return '|';\n      } else {\n        // add space before unescaped |\n        return ' |';\n      }\n    }),\n        cells = row.split(/ \\|/);\n    var i = 0; // First/last cell in a row cannot be empty if it has no leading/trailing pipe\n\n    if (!cells[0].trim()) {\n      cells.shift();\n    }\n\n    if (!cells[cells.length - 1].trim()) {\n      cells.pop();\n    }\n\n    if (cells.length > count) {\n      cells.splice(count);\n    } else {\n      while (cells.length < count) {\n        cells.push('');\n      }\n    }\n\n    for (; i < cells.length; i++) {\n      // leading or trailing whitespace is ignored per the gfm spec\n      cells[i] = cells[i].trim().replace(/\\\\\\|/g, '|');\n    }\n\n    return cells;\n  } // Remove trailing 'c's. Equivalent to str.replace(/c*$/, '').\n  // /c*$/ is vulnerable to REDOS.\n  // invert: Remove suffix of non-c chars instead. Default falsey.\n\n\n  function rtrim$1(str, c, invert) {\n    var l = str.length;\n\n    if (l === 0) {\n      return '';\n    } // Length of suffix matching the invert condition.\n\n\n    var suffLen = 0; // Step left until we fail to match the invert condition.\n\n    while (suffLen < l) {\n      var currChar = str.charAt(l - suffLen - 1);\n\n      if (currChar === c && !invert) {\n        suffLen++;\n      } else if (currChar !== c && invert) {\n        suffLen++;\n      } else {\n        break;\n      }\n    }\n\n    return str.substr(0, l - suffLen);\n  }\n\n  function findClosingBracket$1(str, b) {\n    if (str.indexOf(b[1]) === -1) {\n      return -1;\n    }\n\n    var l = str.length;\n    var level = 0,\n        i = 0;\n\n    for (; i < l; i++) {\n      if (str[i] === '\\\\') {\n        i++;\n      } else if (str[i] === b[0]) {\n        level++;\n      } else if (str[i] === b[1]) {\n        level--;\n\n        if (level < 0) {\n          return i;\n        }\n      }\n    }\n\n    return -1;\n  }\n\n  function checkSanitizeDeprecation$1(opt) {\n    if (opt && opt.sanitize && !opt.silent) {\n      console.warn('marked(): sanitize and sanitizer parameters are deprecated since version 0.7.0, should not be used and will be removed in the future. Read more here: https://marked.js.org/#/USING_ADVANCED.md#options');\n    }\n  } // copied from https://stackoverflow.com/a/5450113/806777\n\n\n  function repeatString$1(pattern, count) {\n    if (count < 1) {\n      return '';\n    }\n\n    var result = '';\n\n    while (count > 1) {\n      if (count & 1) {\n        result += pattern;\n      }\n\n      count >>= 1;\n      pattern += pattern;\n    }\n\n    return result + pattern;\n  }\n\n  var helpers = {\n    escape: escape$2,\n    unescape: unescape$1,\n    edit: edit$1,\n    cleanUrl: cleanUrl$1,\n    resolveUrl: resolveUrl,\n    noopTest: noopTest$1,\n    merge: merge$2,\n    splitCells: splitCells$1,\n    rtrim: rtrim$1,\n    findClosingBracket: findClosingBracket$1,\n    checkSanitizeDeprecation: checkSanitizeDeprecation$1,\n    repeatString: repeatString$1\n  };\n\n  var defaults$4 = defaults$5.exports.defaults;\n  var rtrim = helpers.rtrim,\n      splitCells = helpers.splitCells,\n      _escape = helpers.escape,\n      findClosingBracket = helpers.findClosingBracket;\n\n  function outputLink(cap, link, raw, lexer) {\n    var href = link.href;\n    var title = link.title ? _escape(link.title) : null;\n    var text = cap[1].replace(/\\\\([\\[\\]])/g, '$1');\n\n    if (cap[0].charAt(0) !== '!') {\n      lexer.state.inLink = true;\n      var token = {\n        type: 'link',\n        raw: raw,\n        href: href,\n        title: title,\n        text: text,\n        tokens: lexer.inlineTokens(text, [])\n      };\n      lexer.state.inLink = false;\n      return token;\n    } else {\n      return {\n        type: 'image',\n        raw: raw,\n        href: href,\n        title: title,\n        text: _escape(text)\n      };\n    }\n  }\n\n  function indentCodeCompensation(raw, text) {\n    var matchIndentToCode = raw.match(/^(\\s+)(?:```)/);\n\n    if (matchIndentToCode === null) {\n      return text;\n    }\n\n    var indentToCode = matchIndentToCode[1];\n    return text.split('\\n').map(function (node) {\n      var matchIndentInNode = node.match(/^\\s+/);\n\n      if (matchIndentInNode === null) {\n        return node;\n      }\n\n      var indentInNode = matchIndentInNode[0];\n\n      if (indentInNode.length >= indentToCode.length) {\n        return node.slice(indentToCode.length);\n      }\n\n      return node;\n    }).join('\\n');\n  }\n  /**\n   * Tokenizer\n   */\n\n\n  var Tokenizer_1 = /*#__PURE__*/function () {\n    function Tokenizer(options) {\n      this.options = options || defaults$4;\n    }\n\n    var _proto = Tokenizer.prototype;\n\n    _proto.space = function space(src) {\n      var cap = this.rules.block.newline.exec(src);\n\n      if (cap) {\n        if (cap[0].length > 1) {\n          return {\n            type: 'space',\n            raw: cap[0]\n          };\n        }\n\n        return {\n          raw: '\\n'\n        };\n      }\n    };\n\n    _proto.code = function code(src) {\n      var cap = this.rules.block.code.exec(src);\n\n      if (cap) {\n        var text = cap[0].replace(/^ {1,4}/gm, '');\n        return {\n          type: 'code',\n          raw: cap[0],\n          codeBlockStyle: 'indented',\n          text: !this.options.pedantic ? rtrim(text, '\\n') : text\n        };\n      }\n    };\n\n    _proto.fences = function fences(src) {\n      var cap = this.rules.block.fences.exec(src);\n\n      if (cap) {\n        var raw = cap[0];\n        var text = indentCodeCompensation(raw, cap[3] || '');\n        return {\n          type: 'code',\n          raw: raw,\n          lang: cap[2] ? cap[2].trim() : cap[2],\n          text: text\n        };\n      }\n    };\n\n    _proto.heading = function heading(src) {\n      var cap = this.rules.block.heading.exec(src);\n\n      if (cap) {\n        var text = cap[2].trim(); // remove trailing #s\n\n        if (/#$/.test(text)) {\n          var trimmed = rtrim(text, '#');\n\n          if (this.options.pedantic) {\n            text = trimmed.trim();\n          } else if (!trimmed || / $/.test(trimmed)) {\n            // CommonMark requires space before trailing #s\n            text = trimmed.trim();\n          }\n        }\n\n        var token = {\n          type: 'heading',\n          raw: cap[0],\n          depth: cap[1].length,\n          text: text,\n          tokens: []\n        };\n        this.lexer.inline(token.text, token.tokens);\n        return token;\n      }\n    };\n\n    _proto.hr = function hr(src) {\n      var cap = this.rules.block.hr.exec(src);\n\n      if (cap) {\n        return {\n          type: 'hr',\n          raw: cap[0]\n        };\n      }\n    };\n\n    _proto.blockquote = function blockquote(src) {\n      var cap = this.rules.block.blockquote.exec(src);\n\n      if (cap) {\n        var text = cap[0].replace(/^ *> ?/gm, '');\n        return {\n          type: 'blockquote',\n          raw: cap[0],\n          tokens: this.lexer.blockTokens(text, []),\n          text: text\n        };\n      }\n    };\n\n    _proto.list = function list(src) {\n      var cap = this.rules.block.list.exec(src);\n\n      if (cap) {\n        var raw, istask, ischecked, indent, i, blankLine, endsWithBlankLine, line, lines, itemContents;\n        var bull = cap[1].trim();\n        var isordered = bull.length > 1;\n        var list = {\n          type: 'list',\n          raw: '',\n          ordered: isordered,\n          start: isordered ? +bull.slice(0, -1) : '',\n          loose: false,\n          items: []\n        };\n        bull = isordered ? \"\\\\d{1,9}\\\\\" + bull.slice(-1) : \"\\\\\" + bull;\n\n        if (this.options.pedantic) {\n          bull = isordered ? bull : '[*+-]';\n        } // Get next list item\n\n\n        var itemRegex = new RegExp(\"^( {0,3}\" + bull + \")((?: [^\\\\n]*| *)(?:\\\\n[^\\\\n]*)*(?:\\\\n|$))\"); // Get each top-level item\n\n        while (src) {\n          if (this.rules.block.hr.test(src)) {\n            // End list if we encounter an HR (possibly move into itemRegex?)\n            break;\n          }\n\n          if (!(cap = itemRegex.exec(src))) {\n            break;\n          }\n\n          lines = cap[2].split('\\n');\n\n          if (this.options.pedantic) {\n            indent = 2;\n            itemContents = lines[0].trimLeft();\n          } else {\n            indent = cap[2].search(/[^ ]/); // Find first non-space char\n\n            indent = cap[1].length + (indent > 4 ? 1 : indent); // intented code blocks after 4 spaces; indent is always 1\n\n            itemContents = lines[0].slice(indent - cap[1].length);\n          }\n\n          blankLine = false;\n          raw = cap[0];\n\n          if (!lines[0] && /^ *$/.test(lines[1])) {\n            // items begin with at most one blank line\n            raw = cap[1] + lines.slice(0, 2).join('\\n') + '\\n';\n            list.loose = true;\n            lines = [];\n          }\n\n          var nextBulletRegex = new RegExp(\"^ {0,\" + Math.min(3, indent - 1) + \"}(?:[*+-]|\\\\d{1,9}[.)])\");\n\n          for (i = 1; i < lines.length; i++) {\n            line = lines[i];\n\n            if (this.options.pedantic) {\n              // Re-align to follow commonmark nesting rules\n              line = line.replace(/^ {1,4}(?=( {4})*[^ ])/g, '  ');\n            } // End list item if found start of new bullet\n\n\n            if (nextBulletRegex.test(line)) {\n              raw = cap[1] + lines.slice(0, i).join('\\n') + '\\n';\n              break;\n            } // Until we encounter a blank line, item contents do not need indentation\n\n\n            if (!blankLine) {\n              if (!line.trim()) {\n                // Check if current line is empty\n                blankLine = true;\n              } // Dedent if possible\n\n\n              if (line.search(/[^ ]/) >= indent) {\n                itemContents += '\\n' + line.slice(indent);\n              } else {\n                itemContents += '\\n' + line;\n              }\n\n              continue;\n            } // Dedent this line\n\n\n            if (line.search(/[^ ]/) >= indent || !line.trim()) {\n              itemContents += '\\n' + line.slice(indent);\n              continue;\n            } else {\n              // Line was not properly indented; end of this item\n              raw = cap[1] + lines.slice(0, i).join('\\n') + '\\n';\n              break;\n            }\n          }\n\n          if (!list.loose) {\n            // If the previous item ended with a blank line, the list is loose\n            if (endsWithBlankLine) {\n              list.loose = true;\n            } else if (/\\n *\\n *$/.test(raw)) {\n              endsWithBlankLine = true;\n            }\n          } // Check for task list items\n\n\n          if (this.options.gfm) {\n            istask = /^\\[[ xX]\\] /.exec(itemContents);\n\n            if (istask) {\n              ischecked = istask[0] !== '[ ] ';\n              itemContents = itemContents.replace(/^\\[[ xX]\\] +/, '');\n            }\n          }\n\n          list.items.push({\n            type: 'list_item',\n            raw: raw,\n            task: !!istask,\n            checked: ischecked,\n            loose: false,\n            text: itemContents\n          });\n          list.raw += raw;\n          src = src.slice(raw.length);\n        } // Do not consume newlines at end of final item. Alternatively, make itemRegex *start* with any newlines to simplify/speed up endsWithBlankLine logic\n\n\n        list.items[list.items.length - 1].raw = raw.trimRight();\n        list.items[list.items.length - 1].text = itemContents.trimRight();\n        list.raw = list.raw.trimRight();\n        var l = list.items.length; // Item child tokens handled here at end because we needed to have the final item to trim it first\n\n        for (i = 0; i < l; i++) {\n          this.lexer.state.top = false;\n          list.items[i].tokens = this.lexer.blockTokens(list.items[i].text, []);\n\n          if (list.items[i].tokens.some(function (t) {\n            return t.type === 'space';\n          })) {\n            list.loose = true;\n            list.items[i].loose = true;\n          }\n        }\n\n        return list;\n      }\n    };\n\n    _proto.html = function html(src) {\n      var cap = this.rules.block.html.exec(src);\n\n      if (cap) {\n        var token = {\n          type: 'html',\n          raw: cap[0],\n          pre: !this.options.sanitizer && (cap[1] === 'pre' || cap[1] === 'script' || cap[1] === 'style'),\n          text: cap[0]\n        };\n\n        if (this.options.sanitize) {\n          token.type = 'paragraph';\n          token.text = this.options.sanitizer ? this.options.sanitizer(cap[0]) : _escape(cap[0]);\n          token.tokens = [];\n          this.lexer.inline(token.text, token.tokens);\n        }\n\n        return token;\n      }\n    };\n\n    _proto.def = function def(src) {\n      var cap = this.rules.block.def.exec(src);\n\n      if (cap) {\n        if (cap[3]) cap[3] = cap[3].substring(1, cap[3].length - 1);\n        var tag = cap[1].toLowerCase().replace(/\\s+/g, ' ');\n        return {\n          type: 'def',\n          tag: tag,\n          raw: cap[0],\n          href: cap[2],\n          title: cap[3]\n        };\n      }\n    };\n\n    _proto.table = function table(src) {\n      var cap = this.rules.block.table.exec(src);\n\n      if (cap) {\n        var item = {\n          type: 'table',\n          header: splitCells(cap[1]).map(function (c) {\n            return {\n              text: c\n            };\n          }),\n          align: cap[2].replace(/^ *|\\| *$/g, '').split(/ *\\| */),\n          rows: cap[3] ? cap[3].replace(/\\n$/, '').split('\\n') : []\n        };\n\n        if (item.header.length === item.align.length) {\n          item.raw = cap[0];\n          var l = item.align.length;\n          var i, j, k, row;\n\n          for (i = 0; i < l; i++) {\n            if (/^ *-+: *$/.test(item.align[i])) {\n              item.align[i] = 'right';\n            } else if (/^ *:-+: *$/.test(item.align[i])) {\n              item.align[i] = 'center';\n            } else if (/^ *:-+ *$/.test(item.align[i])) {\n              item.align[i] = 'left';\n            } else {\n              item.align[i] = null;\n            }\n          }\n\n          l = item.rows.length;\n\n          for (i = 0; i < l; i++) {\n            item.rows[i] = splitCells(item.rows[i], item.header.length).map(function (c) {\n              return {\n                text: c\n              };\n            });\n          } // parse child tokens inside headers and cells\n          // header child tokens\n\n\n          l = item.header.length;\n\n          for (j = 0; j < l; j++) {\n            item.header[j].tokens = [];\n            this.lexer.inlineTokens(item.header[j].text, item.header[j].tokens);\n          } // cell child tokens\n\n\n          l = item.rows.length;\n\n          for (j = 0; j < l; j++) {\n            row = item.rows[j];\n\n            for (k = 0; k < row.length; k++) {\n              row[k].tokens = [];\n              this.lexer.inlineTokens(row[k].text, row[k].tokens);\n            }\n          }\n\n          return item;\n        }\n      }\n    };\n\n    _proto.lheading = function lheading(src) {\n      var cap = this.rules.block.lheading.exec(src);\n\n      if (cap) {\n        var token = {\n          type: 'heading',\n          raw: cap[0],\n          depth: cap[2].charAt(0) === '=' ? 1 : 2,\n          text: cap[1],\n          tokens: []\n        };\n        this.lexer.inline(token.text, token.tokens);\n        return token;\n      }\n    };\n\n    _proto.paragraph = function paragraph(src) {\n      var cap = this.rules.block.paragraph.exec(src);\n\n      if (cap) {\n        var token = {\n          type: 'paragraph',\n          raw: cap[0],\n          text: cap[1].charAt(cap[1].length - 1) === '\\n' ? cap[1].slice(0, -1) : cap[1],\n          tokens: []\n        };\n        this.lexer.inline(token.text, token.tokens);\n        return token;\n      }\n    };\n\n    _proto.text = function text(src) {\n      var cap = this.rules.block.text.exec(src);\n\n      if (cap) {\n        var token = {\n          type: 'text',\n          raw: cap[0],\n          text: cap[0],\n          tokens: []\n        };\n        this.lexer.inline(token.text, token.tokens);\n        return token;\n      }\n    };\n\n    _proto.escape = function escape(src) {\n      var cap = this.rules.inline.escape.exec(src);\n\n      if (cap) {\n        return {\n          type: 'escape',\n          raw: cap[0],\n          text: _escape(cap[1])\n        };\n      }\n    };\n\n    _proto.tag = function tag(src) {\n      var cap = this.rules.inline.tag.exec(src);\n\n      if (cap) {\n        if (!this.lexer.state.inLink && /^<a /i.test(cap[0])) {\n          this.lexer.state.inLink = true;\n        } else if (this.lexer.state.inLink && /^<\\/a>/i.test(cap[0])) {\n          this.lexer.state.inLink = false;\n        }\n\n        if (!this.lexer.state.inRawBlock && /^<(pre|code|kbd|script)(\\s|>)/i.test(cap[0])) {\n          this.lexer.state.inRawBlock = true;\n        } else if (this.lexer.state.inRawBlock && /^<\\/(pre|code|kbd|script)(\\s|>)/i.test(cap[0])) {\n          this.lexer.state.inRawBlock = false;\n        }\n\n        return {\n          type: this.options.sanitize ? 'text' : 'html',\n          raw: cap[0],\n          inLink: this.lexer.state.inLink,\n          inRawBlock: this.lexer.state.inRawBlock,\n          text: this.options.sanitize ? this.options.sanitizer ? this.options.sanitizer(cap[0]) : _escape(cap[0]) : cap[0]\n        };\n      }\n    };\n\n    _proto.link = function link(src) {\n      var cap = this.rules.inline.link.exec(src);\n\n      if (cap) {\n        var trimmedUrl = cap[2].trim();\n\n        if (!this.options.pedantic && /^</.test(trimmedUrl)) {\n          // commonmark requires matching angle brackets\n          if (!/>$/.test(trimmedUrl)) {\n            return;\n          } // ending angle bracket cannot be escaped\n\n\n          var rtrimSlash = rtrim(trimmedUrl.slice(0, -1), '\\\\');\n\n          if ((trimmedUrl.length - rtrimSlash.length) % 2 === 0) {\n            return;\n          }\n        } else {\n          // find closing parenthesis\n          var lastParenIndex = findClosingBracket(cap[2], '()');\n\n          if (lastParenIndex > -1) {\n            var start = cap[0].indexOf('!') === 0 ? 5 : 4;\n            var linkLen = start + cap[1].length + lastParenIndex;\n            cap[2] = cap[2].substring(0, lastParenIndex);\n            cap[0] = cap[0].substring(0, linkLen).trim();\n            cap[3] = '';\n          }\n        }\n\n        var href = cap[2];\n        var title = '';\n\n        if (this.options.pedantic) {\n          // split pedantic href and title\n          var link = /^([^'\"]*[^\\s])\\s+(['\"])(.*)\\2/.exec(href);\n\n          if (link) {\n            href = link[1];\n            title = link[3];\n          }\n        } else {\n          title = cap[3] ? cap[3].slice(1, -1) : '';\n        }\n\n        href = href.trim();\n\n        if (/^</.test(href)) {\n          if (this.options.pedantic && !/>$/.test(trimmedUrl)) {\n            // pedantic allows starting angle bracket without ending angle bracket\n            href = href.slice(1);\n          } else {\n            href = href.slice(1, -1);\n          }\n        }\n\n        return outputLink(cap, {\n          href: href ? href.replace(this.rules.inline._escapes, '$1') : href,\n          title: title ? title.replace(this.rules.inline._escapes, '$1') : title\n        }, cap[0], this.lexer);\n      }\n    };\n\n    _proto.reflink = function reflink(src, links) {\n      var cap;\n\n      if ((cap = this.rules.inline.reflink.exec(src)) || (cap = this.rules.inline.nolink.exec(src))) {\n        var link = (cap[2] || cap[1]).replace(/\\s+/g, ' ');\n        link = links[link.toLowerCase()];\n\n        if (!link || !link.href) {\n          var text = cap[0].charAt(0);\n          return {\n            type: 'text',\n            raw: text,\n            text: text\n          };\n        }\n\n        return outputLink(cap, link, cap[0], this.lexer);\n      }\n    };\n\n    _proto.emStrong = function emStrong(src, maskedSrc, prevChar) {\n      if (prevChar === void 0) {\n        prevChar = '';\n      }\n\n      var match = this.rules.inline.emStrong.lDelim.exec(src);\n      if (!match) return; // _ can't be between two alphanumerics. \\p{L}\\p{N} includes non-english alphabet/numbers as well\n\n      if (match[3] && prevChar.match(/(?:[0-9A-Za-z\\xAA\\xB2\\xB3\\xB5\\xB9\\xBA\\xBC-\\xBE\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0370-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u037F\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u048A-\\u052F\\u0531-\\u0556\\u0559\\u0560-\\u0588\\u05D0-\\u05EA\\u05EF-\\u05F2\\u0620-\\u064A\\u0660-\\u0669\\u066E\\u066F\\u0671-\\u06D3\\u06D5\\u06E5\\u06E6\\u06EE-\\u06FC\\u06FF\\u0710\\u0712-\\u072F\\u074D-\\u07A5\\u07B1\\u07C0-\\u07EA\\u07F4\\u07F5\\u07FA\\u0800-\\u0815\\u081A\\u0824\\u0828\\u0840-\\u0858\\u0860-\\u086A\\u08A0-\\u08B4\\u08B6-\\u08C7\\u0904-\\u0939\\u093D\\u0950\\u0958-\\u0961\\u0966-\\u096F\\u0971-\\u0980\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BD\\u09CE\\u09DC\\u09DD\\u09DF-\\u09E1\\u09E6-\\u09F1\\u09F4-\\u09F9\\u09FC\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A59-\\u0A5C\\u0A5E\\u0A66-\\u0A6F\\u0A72-\\u0A74\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABD\\u0AD0\\u0AE0\\u0AE1\\u0AE6-\\u0AEF\\u0AF9\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3D\\u0B5C\\u0B5D\\u0B5F-\\u0B61\\u0B66-\\u0B6F\\u0B71-\\u0B77\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BD0\\u0BE6-\\u0BF2\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C39\\u0C3D\\u0C58-\\u0C5A\\u0C60\\u0C61\\u0C66-\\u0C6F\\u0C78-\\u0C7E\\u0C80\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBD\\u0CDE\\u0CE0\\u0CE1\\u0CE6-\\u0CEF\\u0CF1\\u0CF2\\u0D04-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D\\u0D4E\\u0D54-\\u0D56\\u0D58-\\u0D61\\u0D66-\\u0D78\\u0D7A-\\u0D7F\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0DE6-\\u0DEF\\u0E01-\\u0E30\\u0E32\\u0E33\\u0E40-\\u0E46\\u0E50-\\u0E59\\u0E81\\u0E82\\u0E84\\u0E86-\\u0E8A\\u0E8C-\\u0EA3\\u0EA5\\u0EA7-\\u0EB0\\u0EB2\\u0EB3\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0ED0-\\u0ED9\\u0EDC-\\u0EDF\\u0F00\\u0F20-\\u0F33\\u0F40-\\u0F47\\u0F49-\\u0F6C\\u0F88-\\u0F8C\\u1000-\\u102A\\u103F-\\u1049\\u1050-\\u1055\\u105A-\\u105D\\u1061\\u1065\\u1066\\u106E-\\u1070\\u1075-\\u1081\\u108E\\u1090-\\u1099\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u1369-\\u137C\\u1380-\\u138F\\u13A0-\\u13F5\\u13F8-\\u13FD\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16EE-\\u16F8\\u1700-\\u170C\\u170E-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176C\\u176E-\\u1770\\u1780-\\u17B3\\u17D7\\u17DC\\u17E0-\\u17E9\\u17F0-\\u17F9\\u1810-\\u1819\\u1820-\\u1878\\u1880-\\u1884\\u1887-\\u18A8\\u18AA\\u18B0-\\u18F5\\u1900-\\u191E\\u1946-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19B0-\\u19C9\\u19D0-\\u19DA\\u1A00-\\u1A16\\u1A20-\\u1A54\\u1A80-\\u1A89\\u1A90-\\u1A99\\u1AA7\\u1B05-\\u1B33\\u1B45-\\u1B4B\\u1B50-\\u1B59\\u1B83-\\u1BA0\\u1BAE-\\u1BE5\\u1C00-\\u1C23\\u1C40-\\u1C49\\u1C4D-\\u1C7D\\u1C80-\\u1C88\\u1C90-\\u1CBA\\u1CBD-\\u1CBF\\u1CE9-\\u1CEC\\u1CEE-\\u1CF3\\u1CF5\\u1CF6\\u1CFA\\u1D00-\\u1DBF\\u1E00-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u2070\\u2071\\u2074-\\u2079\\u207F-\\u2089\\u2090-\\u209C\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2119-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u212D\\u212F-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2150-\\u2189\\u2460-\\u249B\\u24EA-\\u24FF\\u2776-\\u2793\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2CE4\\u2CEB-\\u2CEE\\u2CF2\\u2CF3\\u2CFD\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D80-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u2E2F\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303C\\u3041-\\u3096\\u309D-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312F\\u3131-\\u318E\\u3192-\\u3195\\u31A0-\\u31BF\\u31F0-\\u31FF\\u3220-\\u3229\\u3248-\\u324F\\u3251-\\u325F\\u3280-\\u3289\\u32B1-\\u32BF\\u3400-\\u4DBF\\u4E00-\\u9FFC\\uA000-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA62B\\uA640-\\uA66E\\uA67F-\\uA69D\\uA6A0-\\uA6EF\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA7BF\\uA7C2-\\uA7CA\\uA7F5-\\uA801\\uA803-\\uA805\\uA807-\\uA80A\\uA80C-\\uA822\\uA830-\\uA835\\uA840-\\uA873\\uA882-\\uA8B3\\uA8D0-\\uA8D9\\uA8F2-\\uA8F7\\uA8FB\\uA8FD\\uA8FE\\uA900-\\uA925\\uA930-\\uA946\\uA960-\\uA97C\\uA984-\\uA9B2\\uA9CF-\\uA9D9\\uA9E0-\\uA9E4\\uA9E6-\\uA9FE\\uAA00-\\uAA28\\uAA40-\\uAA42\\uAA44-\\uAA4B\\uAA50-\\uAA59\\uAA60-\\uAA76\\uAA7A\\uAA7E-\\uAAAF\\uAAB1\\uAAB5\\uAAB6\\uAAB9-\\uAABD\\uAAC0\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEA\\uAAF2-\\uAAF4\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uAB30-\\uAB5A\\uAB5C-\\uAB69\\uAB70-\\uABE2\\uABF0-\\uABF9\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D\\uFB1F-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF10-\\uFF19\\uFF21-\\uFF3A\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]|\\uD800[\\uDC00-\\uDC0B\\uDC0D-\\uDC26\\uDC28-\\uDC3A\\uDC3C\\uDC3D\\uDC3F-\\uDC4D\\uDC50-\\uDC5D\\uDC80-\\uDCFA\\uDD07-\\uDD33\\uDD40-\\uDD78\\uDD8A\\uDD8B\\uDE80-\\uDE9C\\uDEA0-\\uDED0\\uDEE1-\\uDEFB\\uDF00-\\uDF23\\uDF2D-\\uDF4A\\uDF50-\\uDF75\\uDF80-\\uDF9D\\uDFA0-\\uDFC3\\uDFC8-\\uDFCF\\uDFD1-\\uDFD5]|\\uD801[\\uDC00-\\uDC9D\\uDCA0-\\uDCA9\\uDCB0-\\uDCD3\\uDCD8-\\uDCFB\\uDD00-\\uDD27\\uDD30-\\uDD63\\uDE00-\\uDF36\\uDF40-\\uDF55\\uDF60-\\uDF67]|\\uD802[\\uDC00-\\uDC05\\uDC08\\uDC0A-\\uDC35\\uDC37\\uDC38\\uDC3C\\uDC3F-\\uDC55\\uDC58-\\uDC76\\uDC79-\\uDC9E\\uDCA7-\\uDCAF\\uDCE0-\\uDCF2\\uDCF4\\uDCF5\\uDCFB-\\uDD1B\\uDD20-\\uDD39\\uDD80-\\uDDB7\\uDDBC-\\uDDCF\\uDDD2-\\uDE00\\uDE10-\\uDE13\\uDE15-\\uDE17\\uDE19-\\uDE35\\uDE40-\\uDE48\\uDE60-\\uDE7E\\uDE80-\\uDE9F\\uDEC0-\\uDEC7\\uDEC9-\\uDEE4\\uDEEB-\\uDEEF\\uDF00-\\uDF35\\uDF40-\\uDF55\\uDF58-\\uDF72\\uDF78-\\uDF91\\uDFA9-\\uDFAF]|\\uD803[\\uDC00-\\uDC48\\uDC80-\\uDCB2\\uDCC0-\\uDCF2\\uDCFA-\\uDD23\\uDD30-\\uDD39\\uDE60-\\uDE7E\\uDE80-\\uDEA9\\uDEB0\\uDEB1\\uDF00-\\uDF27\\uDF30-\\uDF45\\uDF51-\\uDF54\\uDFB0-\\uDFCB\\uDFE0-\\uDFF6]|\\uD804[\\uDC03-\\uDC37\\uDC52-\\uDC6F\\uDC83-\\uDCAF\\uDCD0-\\uDCE8\\uDCF0-\\uDCF9\\uDD03-\\uDD26\\uDD36-\\uDD3F\\uDD44\\uDD47\\uDD50-\\uDD72\\uDD76\\uDD83-\\uDDB2\\uDDC1-\\uDDC4\\uDDD0-\\uDDDA\\uDDDC\\uDDE1-\\uDDF4\\uDE00-\\uDE11\\uDE13-\\uDE2B\\uDE80-\\uDE86\\uDE88\\uDE8A-\\uDE8D\\uDE8F-\\uDE9D\\uDE9F-\\uDEA8\\uDEB0-\\uDEDE\\uDEF0-\\uDEF9\\uDF05-\\uDF0C\\uDF0F\\uDF10\\uDF13-\\uDF28\\uDF2A-\\uDF30\\uDF32\\uDF33\\uDF35-\\uDF39\\uDF3D\\uDF50\\uDF5D-\\uDF61]|\\uD805[\\uDC00-\\uDC34\\uDC47-\\uDC4A\\uDC50-\\uDC59\\uDC5F-\\uDC61\\uDC80-\\uDCAF\\uDCC4\\uDCC5\\uDCC7\\uDCD0-\\uDCD9\\uDD80-\\uDDAE\\uDDD8-\\uDDDB\\uDE00-\\uDE2F\\uDE44\\uDE50-\\uDE59\\uDE80-\\uDEAA\\uDEB8\\uDEC0-\\uDEC9\\uDF00-\\uDF1A\\uDF30-\\uDF3B]|\\uD806[\\uDC00-\\uDC2B\\uDCA0-\\uDCF2\\uDCFF-\\uDD06\\uDD09\\uDD0C-\\uDD13\\uDD15\\uDD16\\uDD18-\\uDD2F\\uDD3F\\uDD41\\uDD50-\\uDD59\\uDDA0-\\uDDA7\\uDDAA-\\uDDD0\\uDDE1\\uDDE3\\uDE00\\uDE0B-\\uDE32\\uDE3A\\uDE50\\uDE5C-\\uDE89\\uDE9D\\uDEC0-\\uDEF8]|\\uD807[\\uDC00-\\uDC08\\uDC0A-\\uDC2E\\uDC40\\uDC50-\\uDC6C\\uDC72-\\uDC8F\\uDD00-\\uDD06\\uDD08\\uDD09\\uDD0B-\\uDD30\\uDD46\\uDD50-\\uDD59\\uDD60-\\uDD65\\uDD67\\uDD68\\uDD6A-\\uDD89\\uDD98\\uDDA0-\\uDDA9\\uDEE0-\\uDEF2\\uDFB0\\uDFC0-\\uDFD4]|\\uD808[\\uDC00-\\uDF99]|\\uD809[\\uDC00-\\uDC6E\\uDC80-\\uDD43]|[\\uD80C\\uD81C-\\uD820\\uD822\\uD840-\\uD868\\uD86A-\\uD86C\\uD86F-\\uD872\\uD874-\\uD879\\uD880-\\uD883][\\uDC00-\\uDFFF]|\\uD80D[\\uDC00-\\uDC2E]|\\uD811[\\uDC00-\\uDE46]|\\uD81A[\\uDC00-\\uDE38\\uDE40-\\uDE5E\\uDE60-\\uDE69\\uDED0-\\uDEED\\uDF00-\\uDF2F\\uDF40-\\uDF43\\uDF50-\\uDF59\\uDF5B-\\uDF61\\uDF63-\\uDF77\\uDF7D-\\uDF8F]|\\uD81B[\\uDE40-\\uDE96\\uDF00-\\uDF4A\\uDF50\\uDF93-\\uDF9F\\uDFE0\\uDFE1\\uDFE3]|\\uD821[\\uDC00-\\uDFF7]|\\uD823[\\uDC00-\\uDCD5\\uDD00-\\uDD08]|\\uD82C[\\uDC00-\\uDD1E\\uDD50-\\uDD52\\uDD64-\\uDD67\\uDD70-\\uDEFB]|\\uD82F[\\uDC00-\\uDC6A\\uDC70-\\uDC7C\\uDC80-\\uDC88\\uDC90-\\uDC99]|\\uD834[\\uDEE0-\\uDEF3\\uDF60-\\uDF78]|\\uD835[\\uDC00-\\uDC54\\uDC56-\\uDC9C\\uDC9E\\uDC9F\\uDCA2\\uDCA5\\uDCA6\\uDCA9-\\uDCAC\\uDCAE-\\uDCB9\\uDCBB\\uDCBD-\\uDCC3\\uDCC5-\\uDD05\\uDD07-\\uDD0A\\uDD0D-\\uDD14\\uDD16-\\uDD1C\\uDD1E-\\uDD39\\uDD3B-\\uDD3E\\uDD40-\\uDD44\\uDD46\\uDD4A-\\uDD50\\uDD52-\\uDEA5\\uDEA8-\\uDEC0\\uDEC2-\\uDEDA\\uDEDC-\\uDEFA\\uDEFC-\\uDF14\\uDF16-\\uDF34\\uDF36-\\uDF4E\\uDF50-\\uDF6E\\uDF70-\\uDF88\\uDF8A-\\uDFA8\\uDFAA-\\uDFC2\\uDFC4-\\uDFCB\\uDFCE-\\uDFFF]|\\uD838[\\uDD00-\\uDD2C\\uDD37-\\uDD3D\\uDD40-\\uDD49\\uDD4E\\uDEC0-\\uDEEB\\uDEF0-\\uDEF9]|\\uD83A[\\uDC00-\\uDCC4\\uDCC7-\\uDCCF\\uDD00-\\uDD43\\uDD4B\\uDD50-\\uDD59]|\\uD83B[\\uDC71-\\uDCAB\\uDCAD-\\uDCAF\\uDCB1-\\uDCB4\\uDD01-\\uDD2D\\uDD2F-\\uDD3D\\uDE00-\\uDE03\\uDE05-\\uDE1F\\uDE21\\uDE22\\uDE24\\uDE27\\uDE29-\\uDE32\\uDE34-\\uDE37\\uDE39\\uDE3B\\uDE42\\uDE47\\uDE49\\uDE4B\\uDE4D-\\uDE4F\\uDE51\\uDE52\\uDE54\\uDE57\\uDE59\\uDE5B\\uDE5D\\uDE5F\\uDE61\\uDE62\\uDE64\\uDE67-\\uDE6A\\uDE6C-\\uDE72\\uDE74-\\uDE77\\uDE79-\\uDE7C\\uDE7E\\uDE80-\\uDE89\\uDE8B-\\uDE9B\\uDEA1-\\uDEA3\\uDEA5-\\uDEA9\\uDEAB-\\uDEBB]|\\uD83C[\\uDD00-\\uDD0C]|\\uD83E[\\uDFF0-\\uDFF9]|\\uD869[\\uDC00-\\uDEDD\\uDF00-\\uDFFF]|\\uD86D[\\uDC00-\\uDF34\\uDF40-\\uDFFF]|\\uD86E[\\uDC00-\\uDC1D\\uDC20-\\uDFFF]|\\uD873[\\uDC00-\\uDEA1\\uDEB0-\\uDFFF]|\\uD87A[\\uDC00-\\uDFE0]|\\uD87E[\\uDC00-\\uDE1D]|\\uD884[\\uDC00-\\uDF4A])/)) return;\n      var nextChar = match[1] || match[2] || '';\n\n      if (!nextChar || nextChar && (prevChar === '' || this.rules.inline.punctuation.exec(prevChar))) {\n        var lLength = match[0].length - 1;\n        var rDelim,\n            rLength,\n            delimTotal = lLength,\n            midDelimTotal = 0;\n        var endReg = match[0][0] === '*' ? this.rules.inline.emStrong.rDelimAst : this.rules.inline.emStrong.rDelimUnd;\n        endReg.lastIndex = 0; // Clip maskedSrc to same section of string as src (move to lexer?)\n\n        maskedSrc = maskedSrc.slice(-1 * src.length + lLength);\n\n        while ((match = endReg.exec(maskedSrc)) != null) {\n          rDelim = match[1] || match[2] || match[3] || match[4] || match[5] || match[6];\n          if (!rDelim) continue; // skip single * in __abc*abc__\n\n          rLength = rDelim.length;\n\n          if (match[3] || match[4]) {\n            // found another Left Delim\n            delimTotal += rLength;\n            continue;\n          } else if (match[5] || match[6]) {\n            // either Left or Right Delim\n            if (lLength % 3 && !((lLength + rLength) % 3)) {\n              midDelimTotal += rLength;\n              continue; // CommonMark Emphasis Rules 9-10\n            }\n          }\n\n          delimTotal -= rLength;\n          if (delimTotal > 0) continue; // Haven't found enough closing delimiters\n          // Remove extra characters. *a*** -> *a*\n\n          rLength = Math.min(rLength, rLength + delimTotal + midDelimTotal); // Create `em` if smallest delimiter has odd char count. *a***\n\n          if (Math.min(lLength, rLength) % 2) {\n            var _text = src.slice(1, lLength + match.index + rLength);\n\n            return {\n              type: 'em',\n              raw: src.slice(0, lLength + match.index + rLength + 1),\n              text: _text,\n              tokens: this.lexer.inlineTokens(_text, [])\n            };\n          } // Create 'strong' if smallest delimiter has even char count. **a***\n\n\n          var text = src.slice(2, lLength + match.index + rLength - 1);\n          return {\n            type: 'strong',\n            raw: src.slice(0, lLength + match.index + rLength + 1),\n            text: text,\n            tokens: this.lexer.inlineTokens(text, [])\n          };\n        }\n      }\n    };\n\n    _proto.codespan = function codespan(src) {\n      var cap = this.rules.inline.code.exec(src);\n\n      if (cap) {\n        var text = cap[2].replace(/\\n/g, ' ');\n        var hasNonSpaceChars = /[^ ]/.test(text);\n        var hasSpaceCharsOnBothEnds = /^ /.test(text) && / $/.test(text);\n\n        if (hasNonSpaceChars && hasSpaceCharsOnBothEnds) {\n          text = text.substring(1, text.length - 1);\n        }\n\n        text = _escape(text, true);\n        return {\n          type: 'codespan',\n          raw: cap[0],\n          text: text\n        };\n      }\n    };\n\n    _proto.br = function br(src) {\n      var cap = this.rules.inline.br.exec(src);\n\n      if (cap) {\n        return {\n          type: 'br',\n          raw: cap[0]\n        };\n      }\n    };\n\n    _proto.del = function del(src) {\n      var cap = this.rules.inline.del.exec(src);\n\n      if (cap) {\n        return {\n          type: 'del',\n          raw: cap[0],\n          text: cap[2],\n          tokens: this.lexer.inlineTokens(cap[2], [])\n        };\n      }\n    };\n\n    _proto.autolink = function autolink(src, mangle) {\n      var cap = this.rules.inline.autolink.exec(src);\n\n      if (cap) {\n        var text, href;\n\n        if (cap[2] === '@') {\n          text = _escape(this.options.mangle ? mangle(cap[1]) : cap[1]);\n          href = 'mailto:' + text;\n        } else {\n          text = _escape(cap[1]);\n          href = text;\n        }\n\n        return {\n          type: 'link',\n          raw: cap[0],\n          text: text,\n          href: href,\n          tokens: [{\n            type: 'text',\n            raw: text,\n            text: text\n          }]\n        };\n      }\n    };\n\n    _proto.url = function url(src, mangle) {\n      var cap;\n\n      if (cap = this.rules.inline.url.exec(src)) {\n        var text, href;\n\n        if (cap[2] === '@') {\n          text = _escape(this.options.mangle ? mangle(cap[0]) : cap[0]);\n          href = 'mailto:' + text;\n        } else {\n          // do extended autolink path validation\n          var prevCapZero;\n\n          do {\n            prevCapZero = cap[0];\n            cap[0] = this.rules.inline._backpedal.exec(cap[0])[0];\n          } while (prevCapZero !== cap[0]);\n\n          text = _escape(cap[0]);\n\n          if (cap[1] === 'www.') {\n            href = 'http://' + text;\n          } else {\n            href = text;\n          }\n        }\n\n        return {\n          type: 'link',\n          raw: cap[0],\n          text: text,\n          href: href,\n          tokens: [{\n            type: 'text',\n            raw: text,\n            text: text\n          }]\n        };\n      }\n    };\n\n    _proto.inlineText = function inlineText(src, smartypants) {\n      var cap = this.rules.inline.text.exec(src);\n\n      if (cap) {\n        var text;\n\n        if (this.lexer.state.inRawBlock) {\n          text = this.options.sanitize ? this.options.sanitizer ? this.options.sanitizer(cap[0]) : _escape(cap[0]) : cap[0];\n        } else {\n          text = _escape(this.options.smartypants ? smartypants(cap[0]) : cap[0]);\n        }\n\n        return {\n          type: 'text',\n          raw: cap[0],\n          text: text\n        };\n      }\n    };\n\n    return Tokenizer;\n  }();\n\n  var noopTest = helpers.noopTest,\n      edit = helpers.edit,\n      merge$1 = helpers.merge;\n  /**\n   * Block-Level Grammar\n   */\n\n  var block$1 = {\n    newline: /^(?: *(?:\\n|$))+/,\n    code: /^( {4}[^\\n]+(?:\\n(?: *(?:\\n|$))*)?)+/,\n    fences: /^ {0,3}(`{3,}(?=[^`\\n]*\\n)|~{3,})([^\\n]*)\\n(?:|([\\s\\S]*?)\\n)(?: {0,3}\\1[~`]* *(?=\\n|$)|$)/,\n    hr: /^ {0,3}((?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|$)/,\n    heading: /^ {0,3}(#{1,6})(?=\\s|$)(.*)(?:\\n+|$)/,\n    blockquote: /^( {0,3}> ?(paragraph|[^\\n]*)(?:\\n|$))+/,\n    list: /^( {0,3}bull)( [^\\n]+?)?(?:\\n|$)/,\n    html: '^ {0,3}(?:' // optional indentation\n    + '<(script|pre|style|textarea)[\\\\s>][\\\\s\\\\S]*?(?:</\\\\1>[^\\\\n]*\\\\n+|$)' // (1)\n    + '|comment[^\\\\n]*(\\\\n+|$)' // (2)\n    + '|<\\\\?[\\\\s\\\\S]*?(?:\\\\?>\\\\n*|$)' // (3)\n    + '|<![A-Z][\\\\s\\\\S]*?(?:>\\\\n*|$)' // (4)\n    + '|<!\\\\[CDATA\\\\[[\\\\s\\\\S]*?(?:\\\\]\\\\]>\\\\n*|$)' // (5)\n    + '|</?(tag)(?: +|\\\\n|/?>)[\\\\s\\\\S]*?(?:(?:\\\\n *)+\\\\n|$)' // (6)\n    + '|<(?!script|pre|style|textarea)([a-z][\\\\w-]*)(?:attribute)*? */?>(?=[ \\\\t]*(?:\\\\n|$))[\\\\s\\\\S]*?(?:(?:\\\\n *)+\\\\n|$)' // (7) open tag\n    + '|</(?!script|pre|style|textarea)[a-z][\\\\w-]*\\\\s*>(?=[ \\\\t]*(?:\\\\n|$))[\\\\s\\\\S]*?(?:(?:\\\\n *)+\\\\n|$)' // (7) closing tag\n    + ')',\n    def: /^ {0,3}\\[(label)\\]: *\\n? *<?([^\\s>]+)>?(?:(?: +\\n? *| *\\n *)(title))? *(?:\\n+|$)/,\n    table: noopTest,\n    lheading: /^([^\\n]+)\\n {0,3}(=+|-+) *(?:\\n+|$)/,\n    // regex template, placeholders will be replaced according to different paragraph\n    // interruption rules of commonmark and the original markdown spec:\n    _paragraph: /^([^\\n]+(?:\\n(?!hr|heading|lheading|blockquote|fences|list|html| +\\n)[^\\n]+)*)/,\n    text: /^[^\\n]+/\n  };\n  block$1._label = /(?!\\s*\\])(?:\\\\[\\[\\]]|[^\\[\\]])+/;\n  block$1._title = /(?:\"(?:\\\\\"?|[^\"\\\\])*\"|'[^'\\n]*(?:\\n[^'\\n]+)*\\n?'|\\([^()]*\\))/;\n  block$1.def = edit(block$1.def).replace('label', block$1._label).replace('title', block$1._title).getRegex();\n  block$1.bullet = /(?:[*+-]|\\d{1,9}[.)])/;\n  block$1.listItemStart = edit(/^( *)(bull) */).replace('bull', block$1.bullet).getRegex();\n  block$1.list = edit(block$1.list).replace(/bull/g, block$1.bullet).replace('hr', '\\\\n+(?=\\\\1?(?:(?:- *){3,}|(?:_ *){3,}|(?:\\\\* *){3,})(?:\\\\n+|$))').replace('def', '\\\\n+(?=' + block$1.def.source + ')').getRegex();\n  block$1._tag = 'address|article|aside|base|basefont|blockquote|body|caption' + '|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption' + '|figure|footer|form|frame|frameset|h[1-6]|head|header|hr|html|iframe' + '|legend|li|link|main|menu|menuitem|meta|nav|noframes|ol|optgroup|option' + '|p|param|section|source|summary|table|tbody|td|tfoot|th|thead|title|tr' + '|track|ul';\n  block$1._comment = /\x3c!--(?!-?>)[\\s\\S]*?(?:--\x3e|$)/;\n  block$1.html = edit(block$1.html, 'i').replace('comment', block$1._comment).replace('tag', block$1._tag).replace('attribute', / +[a-zA-Z:_][\\w.:-]*(?: *= *\"[^\"\\n]*\"| *= *'[^'\\n]*'| *= *[^\\s\"'=<>`]+)?/).getRegex();\n  block$1.paragraph = edit(block$1._paragraph).replace('hr', block$1.hr).replace('heading', ' {0,3}#{1,6} ').replace('|lheading', '') // setex headings don't interrupt commonmark paragraphs\n  .replace('blockquote', ' {0,3}>').replace('fences', ' {0,3}(?:`{3,}(?=[^`\\\\n]*\\\\n)|~{3,})[^\\\\n]*\\\\n').replace('list', ' {0,3}(?:[*+-]|1[.)]) ') // only lists starting from 1 can interrupt\n  .replace('html', '</?(?:tag)(?: +|\\\\n|/?>)|<(?:script|pre|style|textarea|!--)').replace('tag', block$1._tag) // pars can be interrupted by type (6) html blocks\n  .getRegex();\n  block$1.blockquote = edit(block$1.blockquote).replace('paragraph', block$1.paragraph).getRegex();\n  /**\n   * Normal Block Grammar\n   */\n\n  block$1.normal = merge$1({}, block$1);\n  /**\n   * GFM Block Grammar\n   */\n\n  block$1.gfm = merge$1({}, block$1.normal, {\n    table: '^ *([^\\\\n ].*\\\\|.*)\\\\n' // Header\n    + ' {0,3}(?:\\\\| *)?(:?-+:? *(?:\\\\| *:?-+:? *)*)(?:\\\\| *)?' // Align\n    + '(?:\\\\n((?:(?! *\\\\n|hr|heading|blockquote|code|fences|list|html).*(?:\\\\n|$))*)\\\\n*|$)' // Cells\n\n  });\n  block$1.gfm.table = edit(block$1.gfm.table).replace('hr', block$1.hr).replace('heading', ' {0,3}#{1,6} ').replace('blockquote', ' {0,3}>').replace('code', ' {4}[^\\\\n]').replace('fences', ' {0,3}(?:`{3,}(?=[^`\\\\n]*\\\\n)|~{3,})[^\\\\n]*\\\\n').replace('list', ' {0,3}(?:[*+-]|1[.)]) ') // only lists starting from 1 can interrupt\n  .replace('html', '</?(?:tag)(?: +|\\\\n|/?>)|<(?:script|pre|style|textarea|!--)').replace('tag', block$1._tag) // tables can be interrupted by type (6) html blocks\n  .getRegex();\n  /**\n   * Pedantic grammar (original John Gruber's loose markdown specification)\n   */\n\n  block$1.pedantic = merge$1({}, block$1.normal, {\n    html: edit('^ *(?:comment *(?:\\\\n|\\\\s*$)' + '|<(tag)[\\\\s\\\\S]+?</\\\\1> *(?:\\\\n{2,}|\\\\s*$)' // closed tag\n    + '|<tag(?:\"[^\"]*\"|\\'[^\\']*\\'|\\\\s[^\\'\"/>\\\\s]*)*?/?> *(?:\\\\n{2,}|\\\\s*$))').replace('comment', block$1._comment).replace(/tag/g, '(?!(?:' + 'a|em|strong|small|s|cite|q|dfn|abbr|data|time|code|var|samp|kbd|sub' + '|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo|span|br|wbr|ins|del|img)' + '\\\\b)\\\\w+(?!:|[^\\\\w\\\\s@]*@)\\\\b').getRegex(),\n    def: /^ *\\[([^\\]]+)\\]: *<?([^\\s>]+)>?(?: +([\"(][^\\n]+[\")]))? *(?:\\n+|$)/,\n    heading: /^(#{1,6})(.*)(?:\\n+|$)/,\n    fences: noopTest,\n    // fences not supported\n    paragraph: edit(block$1.normal._paragraph).replace('hr', block$1.hr).replace('heading', ' *#{1,6} *[^\\n]').replace('lheading', block$1.lheading).replace('blockquote', ' {0,3}>').replace('|fences', '').replace('|list', '').replace('|html', '').getRegex()\n  });\n  /**\n   * Inline-Level Grammar\n   */\n\n  var inline$1 = {\n    escape: /^\\\\([!\"#$%&'()*+,\\-./:;<=>?@\\[\\]\\\\^_`{|}~])/,\n    autolink: /^<(scheme:[^\\s\\x00-\\x1f<>]*|email)>/,\n    url: noopTest,\n    tag: '^comment' + '|^</[a-zA-Z][\\\\w:-]*\\\\s*>' // self-closing tag\n    + '|^<[a-zA-Z][\\\\w-]*(?:attribute)*?\\\\s*/?>' // open tag\n    + '|^<\\\\?[\\\\s\\\\S]*?\\\\?>' // processing instruction, e.g. <?php ?>\n    + '|^<![a-zA-Z]+\\\\s[\\\\s\\\\S]*?>' // declaration, e.g. <!DOCTYPE html>\n    + '|^<!\\\\[CDATA\\\\[[\\\\s\\\\S]*?\\\\]\\\\]>',\n    // CDATA section\n    link: /^!?\\[(label)\\]\\(\\s*(href)(?:\\s+(title))?\\s*\\)/,\n    reflink: /^!?\\[(label)\\]\\[(?!\\s*\\])((?:\\\\[\\[\\]]?|[^\\[\\]\\\\])+)\\]/,\n    nolink: /^!?\\[(?!\\s*\\])((?:\\[[^\\[\\]]*\\]|\\\\[\\[\\]]|[^\\[\\]])*)\\](?:\\[\\])?/,\n    reflinkSearch: 'reflink|nolink(?!\\\\()',\n    emStrong: {\n      lDelim: /^(?:\\*+(?:([punct_])|[^\\s*]))|^_+(?:([punct*])|([^\\s_]))/,\n      //        (1) and (2) can only be a Right Delimiter. (3) and (4) can only be Left.  (5) and (6) can be either Left or Right.\n      //        () Skip orphan delim inside strong    (1) #***                (2) a***#, a***                   (3) #***a, ***a                 (4) ***#              (5) #***#                 (6) a***a\n      rDelimAst: /^[^_*]*?\\_\\_[^_*]*?\\*[^_*]*?(?=\\_\\_)|[punct_](\\*+)(?=[\\s]|$)|[^punct*_\\s](\\*+)(?=[punct_\\s]|$)|[punct_\\s](\\*+)(?=[^punct*_\\s])|[\\s](\\*+)(?=[punct_])|[punct_](\\*+)(?=[punct_])|[^punct*_\\s](\\*+)(?=[^punct*_\\s])/,\n      rDelimUnd: /^[^_*]*?\\*\\*[^_*]*?\\_[^_*]*?(?=\\*\\*)|[punct*](\\_+)(?=[\\s]|$)|[^punct*_\\s](\\_+)(?=[punct*\\s]|$)|[punct*\\s](\\_+)(?=[^punct*_\\s])|[\\s](\\_+)(?=[punct*])|[punct*](\\_+)(?=[punct*])/ // ^- Not allowed for _\n\n    },\n    code: /^(`+)([^`]|[^`][\\s\\S]*?[^`])\\1(?!`)/,\n    br: /^( {2,}|\\\\)\\n(?!\\s*$)/,\n    del: noopTest,\n    text: /^(`+|[^`])(?:(?= {2,}\\n)|[\\s\\S]*?(?:(?=[\\\\<!\\[`*_]|\\b_|$)|[^ ](?= {2,}\\n)))/,\n    punctuation: /^([\\spunctuation])/\n  }; // list of punctuation marks from CommonMark spec\n  // without * and _ to handle the different emphasis markers * and _\n\n  inline$1._punctuation = '!\"#$%&\\'()+\\\\-.,/:;<=>?@\\\\[\\\\]`^{|}~';\n  inline$1.punctuation = edit(inline$1.punctuation).replace(/punctuation/g, inline$1._punctuation).getRegex(); // sequences em should skip over [title](link), `code`, <html>\n\n  inline$1.blockSkip = /\\[[^\\]]*?\\]\\([^\\)]*?\\)|`[^`]*?`|<[^>]*?>/g;\n  inline$1.escapedEmSt = /\\\\\\*|\\\\_/g;\n  inline$1._comment = edit(block$1._comment).replace('(?:--\x3e|$)', '--\x3e').getRegex();\n  inline$1.emStrong.lDelim = edit(inline$1.emStrong.lDelim).replace(/punct/g, inline$1._punctuation).getRegex();\n  inline$1.emStrong.rDelimAst = edit(inline$1.emStrong.rDelimAst, 'g').replace(/punct/g, inline$1._punctuation).getRegex();\n  inline$1.emStrong.rDelimUnd = edit(inline$1.emStrong.rDelimUnd, 'g').replace(/punct/g, inline$1._punctuation).getRegex();\n  inline$1._escapes = /\\\\([!\"#$%&'()*+,\\-./:;<=>?@\\[\\]\\\\^_`{|}~])/g;\n  inline$1._scheme = /[a-zA-Z][a-zA-Z0-9+.-]{1,31}/;\n  inline$1._email = /[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+(@)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(?![-_])/;\n  inline$1.autolink = edit(inline$1.autolink).replace('scheme', inline$1._scheme).replace('email', inline$1._email).getRegex();\n  inline$1._attribute = /\\s+[a-zA-Z:_][\\w.:-]*(?:\\s*=\\s*\"[^\"]*\"|\\s*=\\s*'[^']*'|\\s*=\\s*[^\\s\"'=<>`]+)?/;\n  inline$1.tag = edit(inline$1.tag).replace('comment', inline$1._comment).replace('attribute', inline$1._attribute).getRegex();\n  inline$1._label = /(?:\\[(?:\\\\.|[^\\[\\]\\\\])*\\]|\\\\.|`[^`]*`|[^\\[\\]\\\\`])*?/;\n  inline$1._href = /<(?:\\\\.|[^\\n<>\\\\])+>|[^\\s\\x00-\\x1f]*/;\n  inline$1._title = /\"(?:\\\\\"?|[^\"\\\\])*\"|'(?:\\\\'?|[^'\\\\])*'|\\((?:\\\\\\)?|[^)\\\\])*\\)/;\n  inline$1.link = edit(inline$1.link).replace('label', inline$1._label).replace('href', inline$1._href).replace('title', inline$1._title).getRegex();\n  inline$1.reflink = edit(inline$1.reflink).replace('label', inline$1._label).getRegex();\n  inline$1.reflinkSearch = edit(inline$1.reflinkSearch, 'g').replace('reflink', inline$1.reflink).replace('nolink', inline$1.nolink).getRegex();\n  /**\n   * Normal Inline Grammar\n   */\n\n  inline$1.normal = merge$1({}, inline$1);\n  /**\n   * Pedantic Inline Grammar\n   */\n\n  inline$1.pedantic = merge$1({}, inline$1.normal, {\n    strong: {\n      start: /^__|\\*\\*/,\n      middle: /^__(?=\\S)([\\s\\S]*?\\S)__(?!_)|^\\*\\*(?=\\S)([\\s\\S]*?\\S)\\*\\*(?!\\*)/,\n      endAst: /\\*\\*(?!\\*)/g,\n      endUnd: /__(?!_)/g\n    },\n    em: {\n      start: /^_|\\*/,\n      middle: /^()\\*(?=\\S)([\\s\\S]*?\\S)\\*(?!\\*)|^_(?=\\S)([\\s\\S]*?\\S)_(?!_)/,\n      endAst: /\\*(?!\\*)/g,\n      endUnd: /_(?!_)/g\n    },\n    link: edit(/^!?\\[(label)\\]\\((.*?)\\)/).replace('label', inline$1._label).getRegex(),\n    reflink: edit(/^!?\\[(label)\\]\\s*\\[([^\\]]*)\\]/).replace('label', inline$1._label).getRegex()\n  });\n  /**\n   * GFM Inline Grammar\n   */\n\n  inline$1.gfm = merge$1({}, inline$1.normal, {\n    escape: edit(inline$1.escape).replace('])', '~|])').getRegex(),\n    _extended_email: /[A-Za-z0-9._+-]+(@)[a-zA-Z0-9-_]+(?:\\.[a-zA-Z0-9-_]*[a-zA-Z0-9])+(?![-_])/,\n    url: /^((?:ftp|https?):\\/\\/|www\\.)(?:[a-zA-Z0-9\\-]+\\.?)+[^\\s<]*|^email/,\n    _backpedal: /(?:[^?!.,:;*_~()&]+|\\([^)]*\\)|&(?![a-zA-Z0-9]+;$)|[?!.,:;*_~)]+(?!$))+/,\n    del: /^(~~?)(?=[^\\s~])([\\s\\S]*?[^\\s~])\\1(?=[^~]|$)/,\n    text: /^([`~]+|[^`~])(?:(?= {2,}\\n)|(?=[a-zA-Z0-9.!#$%&'*+\\/=?_`{\\|}~-]+@)|[\\s\\S]*?(?:(?=[\\\\<!\\[`*~_]|\\b_|https?:\\/\\/|ftp:\\/\\/|www\\.|$)|[^ ](?= {2,}\\n)|[^a-zA-Z0-9.!#$%&'*+\\/=?_`{\\|}~-](?=[a-zA-Z0-9.!#$%&'*+\\/=?_`{\\|}~-]+@)))/\n  });\n  inline$1.gfm.url = edit(inline$1.gfm.url, 'i').replace('email', inline$1.gfm._extended_email).getRegex();\n  /**\n   * GFM + Line Breaks Inline Grammar\n   */\n\n  inline$1.breaks = merge$1({}, inline$1.gfm, {\n    br: edit(inline$1.br).replace('{2,}', '*').getRegex(),\n    text: edit(inline$1.gfm.text).replace('\\\\b_', '\\\\b_| {2,}\\\\n').replace(/\\{2,\\}/g, '*').getRegex()\n  });\n  var rules = {\n    block: block$1,\n    inline: inline$1\n  };\n\n  var Tokenizer$1 = Tokenizer_1;\n  var defaults$3 = defaults$5.exports.defaults;\n  var block = rules.block,\n      inline = rules.inline;\n  var repeatString = helpers.repeatString;\n  /**\n   * smartypants text replacement\n   */\n\n  function smartypants(text) {\n    return text // em-dashes\n    .replace(/---/g, \"\\u2014\") // en-dashes\n    .replace(/--/g, \"\\u2013\") // opening singles\n    .replace(/(^|[-\\u2014/(\\[{\"\\s])'/g, \"$1\\u2018\") // closing singles & apostrophes\n    .replace(/'/g, \"\\u2019\") // opening doubles\n    .replace(/(^|[-\\u2014/(\\[{\\u2018\\s])\"/g, \"$1\\u201C\") // closing doubles\n    .replace(/\"/g, \"\\u201D\") // ellipses\n    .replace(/\\.{3}/g, \"\\u2026\");\n  }\n  /**\n   * mangle email addresses\n   */\n\n\n  function mangle(text) {\n    var out = '',\n        i,\n        ch;\n    var l = text.length;\n\n    for (i = 0; i < l; i++) {\n      ch = text.charCodeAt(i);\n\n      if (Math.random() > 0.5) {\n        ch = 'x' + ch.toString(16);\n      }\n\n      out += '&#' + ch + ';';\n    }\n\n    return out;\n  }\n  /**\n   * Block Lexer\n   */\n\n\n  var Lexer_1 = /*#__PURE__*/function () {\n    function Lexer(options) {\n      this.tokens = [];\n      this.tokens.links = Object.create(null);\n      this.options = options || defaults$3;\n      this.options.tokenizer = this.options.tokenizer || new Tokenizer$1();\n      this.tokenizer = this.options.tokenizer;\n      this.tokenizer.options = this.options;\n      this.tokenizer.lexer = this;\n      this.inlineQueue = [];\n      this.state = {\n        inLink: false,\n        inRawBlock: false,\n        top: true\n      };\n      var rules = {\n        block: block.normal,\n        inline: inline.normal\n      };\n\n      if (this.options.pedantic) {\n        rules.block = block.pedantic;\n        rules.inline = inline.pedantic;\n      } else if (this.options.gfm) {\n        rules.block = block.gfm;\n\n        if (this.options.breaks) {\n          rules.inline = inline.breaks;\n        } else {\n          rules.inline = inline.gfm;\n        }\n      }\n\n      this.tokenizer.rules = rules;\n    }\n    /**\n     * Expose Rules\n     */\n\n\n    /**\n     * Static Lex Method\n     */\n    Lexer.lex = function lex(src, options) {\n      var lexer = new Lexer(options);\n      return lexer.lex(src);\n    }\n    /**\n     * Static Lex Inline Method\n     */\n    ;\n\n    Lexer.lexInline = function lexInline(src, options) {\n      var lexer = new Lexer(options);\n      return lexer.inlineTokens(src);\n    }\n    /**\n     * Preprocessing\n     */\n    ;\n\n    var _proto = Lexer.prototype;\n\n    _proto.lex = function lex(src) {\n      src = src.replace(/\\r\\n|\\r/g, '\\n').replace(/\\t/g, '    ');\n      this.blockTokens(src, this.tokens);\n      var next;\n\n      while (next = this.inlineQueue.shift()) {\n        this.inlineTokens(next.src, next.tokens);\n      }\n\n      return this.tokens;\n    }\n    /**\n     * Lexing\n     */\n    ;\n\n    _proto.blockTokens = function blockTokens(src, tokens) {\n      var _this = this;\n\n      if (tokens === void 0) {\n        tokens = [];\n      }\n\n      if (this.options.pedantic) {\n        src = src.replace(/^ +$/gm, '');\n      }\n\n      var token, lastToken, cutSrc, lastParagraphClipped;\n\n      while (src) {\n        if (this.options.extensions && this.options.extensions.block && this.options.extensions.block.some(function (extTokenizer) {\n          if (token = extTokenizer.call({\n            lexer: _this\n          }, src, tokens)) {\n            src = src.substring(token.raw.length);\n            tokens.push(token);\n            return true;\n          }\n\n          return false;\n        })) {\n          continue;\n        } // newline\n\n\n        if (token = this.tokenizer.space(src)) {\n          src = src.substring(token.raw.length);\n\n          if (token.type) {\n            tokens.push(token);\n          }\n\n          continue;\n        } // code\n\n\n        if (token = this.tokenizer.code(src)) {\n          src = src.substring(token.raw.length);\n          lastToken = tokens[tokens.length - 1]; // An indented code block cannot interrupt a paragraph.\n\n          if (lastToken && (lastToken.type === 'paragraph' || lastToken.type === 'text')) {\n            lastToken.raw += '\\n' + token.raw;\n            lastToken.text += '\\n' + token.text;\n            this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;\n          } else {\n            tokens.push(token);\n          }\n\n          continue;\n        } // fences\n\n\n        if (token = this.tokenizer.fences(src)) {\n          src = src.substring(token.raw.length);\n          tokens.push(token);\n          continue;\n        } // heading\n\n\n        if (token = this.tokenizer.heading(src)) {\n          src = src.substring(token.raw.length);\n          tokens.push(token);\n          continue;\n        } // hr\n\n\n        if (token = this.tokenizer.hr(src)) {\n          src = src.substring(token.raw.length);\n          tokens.push(token);\n          continue;\n        } // blockquote\n\n\n        if (token = this.tokenizer.blockquote(src)) {\n          src = src.substring(token.raw.length);\n          tokens.push(token);\n          continue;\n        } // list\n\n\n        if (token = this.tokenizer.list(src)) {\n          src = src.substring(token.raw.length);\n          tokens.push(token);\n          continue;\n        } // html\n\n\n        if (token = this.tokenizer.html(src)) {\n          src = src.substring(token.raw.length);\n          tokens.push(token);\n          continue;\n        } // def\n\n\n        if (token = this.tokenizer.def(src)) {\n          src = src.substring(token.raw.length);\n          lastToken = tokens[tokens.length - 1];\n\n          if (lastToken && (lastToken.type === 'paragraph' || lastToken.type === 'text')) {\n            lastToken.raw += '\\n' + token.raw;\n            lastToken.text += '\\n' + token.raw;\n            this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;\n          } else if (!this.tokens.links[token.tag]) {\n            this.tokens.links[token.tag] = {\n              href: token.href,\n              title: token.title\n            };\n          }\n\n          continue;\n        } // table (gfm)\n\n\n        if (token = this.tokenizer.table(src)) {\n          src = src.substring(token.raw.length);\n          tokens.push(token);\n          continue;\n        } // lheading\n\n\n        if (token = this.tokenizer.lheading(src)) {\n          src = src.substring(token.raw.length);\n          tokens.push(token);\n          continue;\n        } // top-level paragraph\n        // prevent paragraph consuming extensions by clipping 'src' to extension start\n\n\n        cutSrc = src;\n\n        if (this.options.extensions && this.options.extensions.startBlock) {\n          (function () {\n            var startIndex = Infinity;\n            var tempSrc = src.slice(1);\n            var tempStart = void 0;\n\n            _this.options.extensions.startBlock.forEach(function (getStartIndex) {\n              tempStart = getStartIndex.call({\n                lexer: this\n              }, tempSrc);\n\n              if (typeof tempStart === 'number' && tempStart >= 0) {\n                startIndex = Math.min(startIndex, tempStart);\n              }\n            });\n\n            if (startIndex < Infinity && startIndex >= 0) {\n              cutSrc = src.substring(0, startIndex + 1);\n            }\n          })();\n        }\n\n        if (this.state.top && (token = this.tokenizer.paragraph(cutSrc))) {\n          lastToken = tokens[tokens.length - 1];\n\n          if (lastParagraphClipped && lastToken.type === 'paragraph') {\n            lastToken.raw += '\\n' + token.raw;\n            lastToken.text += '\\n' + token.text;\n            this.inlineQueue.pop();\n            this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;\n          } else {\n            tokens.push(token);\n          }\n\n          lastParagraphClipped = cutSrc.length !== src.length;\n          src = src.substring(token.raw.length);\n          continue;\n        } // text\n\n\n        if (token = this.tokenizer.text(src)) {\n          src = src.substring(token.raw.length);\n          lastToken = tokens[tokens.length - 1];\n\n          if (lastToken && lastToken.type === 'text') {\n            lastToken.raw += '\\n' + token.raw;\n            lastToken.text += '\\n' + token.text;\n            this.inlineQueue.pop();\n            this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;\n          } else {\n            tokens.push(token);\n          }\n\n          continue;\n        }\n\n        if (src) {\n          var errMsg = 'Infinite loop on byte: ' + src.charCodeAt(0);\n\n          if (this.options.silent) {\n            console.error(errMsg);\n            break;\n          } else {\n            throw new Error(errMsg);\n          }\n        }\n      }\n\n      this.state.top = true;\n      return tokens;\n    };\n\n    _proto.inline = function inline(src, tokens) {\n      this.inlineQueue.push({\n        src: src,\n        tokens: tokens\n      });\n    }\n    /**\n     * Lexing/Compiling\n     */\n    ;\n\n    _proto.inlineTokens = function inlineTokens(src, tokens) {\n      var _this2 = this;\n\n      if (tokens === void 0) {\n        tokens = [];\n      }\n\n      var token, lastToken, cutSrc; // String with links masked to avoid interference with em and strong\n\n      var maskedSrc = src;\n      var match;\n      var keepPrevChar, prevChar; // Mask out reflinks\n\n      if (this.tokens.links) {\n        var links = Object.keys(this.tokens.links);\n\n        if (links.length > 0) {\n          while ((match = this.tokenizer.rules.inline.reflinkSearch.exec(maskedSrc)) != null) {\n            if (links.includes(match[0].slice(match[0].lastIndexOf('[') + 1, -1))) {\n              maskedSrc = maskedSrc.slice(0, match.index) + '[' + repeatString('a', match[0].length - 2) + ']' + maskedSrc.slice(this.tokenizer.rules.inline.reflinkSearch.lastIndex);\n            }\n          }\n        }\n      } // Mask out other blocks\n\n\n      while ((match = this.tokenizer.rules.inline.blockSkip.exec(maskedSrc)) != null) {\n        maskedSrc = maskedSrc.slice(0, match.index) + '[' + repeatString('a', match[0].length - 2) + ']' + maskedSrc.slice(this.tokenizer.rules.inline.blockSkip.lastIndex);\n      } // Mask out escaped em & strong delimiters\n\n\n      while ((match = this.tokenizer.rules.inline.escapedEmSt.exec(maskedSrc)) != null) {\n        maskedSrc = maskedSrc.slice(0, match.index) + '++' + maskedSrc.slice(this.tokenizer.rules.inline.escapedEmSt.lastIndex);\n      }\n\n      while (src) {\n        if (!keepPrevChar) {\n          prevChar = '';\n        }\n\n        keepPrevChar = false; // extensions\n\n        if (this.options.extensions && this.options.extensions.inline && this.options.extensions.inline.some(function (extTokenizer) {\n          if (token = extTokenizer.call({\n            lexer: _this2\n          }, src, tokens)) {\n            src = src.substring(token.raw.length);\n            tokens.push(token);\n            return true;\n          }\n\n          return false;\n        })) {\n          continue;\n        } // escape\n\n\n        if (token = this.tokenizer.escape(src)) {\n          src = src.substring(token.raw.length);\n          tokens.push(token);\n          continue;\n        } // tag\n\n\n        if (token = this.tokenizer.tag(src)) {\n          src = src.substring(token.raw.length);\n          lastToken = tokens[tokens.length - 1];\n\n          if (lastToken && token.type === 'text' && lastToken.type === 'text') {\n            lastToken.raw += token.raw;\n            lastToken.text += token.text;\n          } else {\n            tokens.push(token);\n          }\n\n          continue;\n        } // link\n\n\n        if (token = this.tokenizer.link(src)) {\n          src = src.substring(token.raw.length);\n          tokens.push(token);\n          continue;\n        } // reflink, nolink\n\n\n        if (token = this.tokenizer.reflink(src, this.tokens.links)) {\n          src = src.substring(token.raw.length);\n          lastToken = tokens[tokens.length - 1];\n\n          if (lastToken && token.type === 'text' && lastToken.type === 'text') {\n            lastToken.raw += token.raw;\n            lastToken.text += token.text;\n          } else {\n            tokens.push(token);\n          }\n\n          continue;\n        } // em & strong\n\n\n        if (token = this.tokenizer.emStrong(src, maskedSrc, prevChar)) {\n          src = src.substring(token.raw.length);\n          tokens.push(token);\n          continue;\n        } // code\n\n\n        if (token = this.tokenizer.codespan(src)) {\n          src = src.substring(token.raw.length);\n          tokens.push(token);\n          continue;\n        } // br\n\n\n        if (token = this.tokenizer.br(src)) {\n          src = src.substring(token.raw.length);\n          tokens.push(token);\n          continue;\n        } // del (gfm)\n\n\n        if (token = this.tokenizer.del(src)) {\n          src = src.substring(token.raw.length);\n          tokens.push(token);\n          continue;\n        } // autolink\n\n\n        if (token = this.tokenizer.autolink(src, mangle)) {\n          src = src.substring(token.raw.length);\n          tokens.push(token);\n          continue;\n        } // url (gfm)\n\n\n        if (!this.state.inLink && (token = this.tokenizer.url(src, mangle))) {\n          src = src.substring(token.raw.length);\n          tokens.push(token);\n          continue;\n        } // text\n        // prevent inlineText consuming extensions by clipping 'src' to extension start\n\n\n        cutSrc = src;\n\n        if (this.options.extensions && this.options.extensions.startInline) {\n          (function () {\n            var startIndex = Infinity;\n            var tempSrc = src.slice(1);\n            var tempStart = void 0;\n\n            _this2.options.extensions.startInline.forEach(function (getStartIndex) {\n              tempStart = getStartIndex.call({\n                lexer: this\n              }, tempSrc);\n\n              if (typeof tempStart === 'number' && tempStart >= 0) {\n                startIndex = Math.min(startIndex, tempStart);\n              }\n            });\n\n            if (startIndex < Infinity && startIndex >= 0) {\n              cutSrc = src.substring(0, startIndex + 1);\n            }\n          })();\n        }\n\n        if (token = this.tokenizer.inlineText(cutSrc, smartypants)) {\n          src = src.substring(token.raw.length);\n\n          if (token.raw.slice(-1) !== '_') {\n            // Track prevChar before string of ____ started\n            prevChar = token.raw.slice(-1);\n          }\n\n          keepPrevChar = true;\n          lastToken = tokens[tokens.length - 1];\n\n          if (lastToken && lastToken.type === 'text') {\n            lastToken.raw += token.raw;\n            lastToken.text += token.text;\n          } else {\n            tokens.push(token);\n          }\n\n          continue;\n        }\n\n        if (src) {\n          var errMsg = 'Infinite loop on byte: ' + src.charCodeAt(0);\n\n          if (this.options.silent) {\n            console.error(errMsg);\n            break;\n          } else {\n            throw new Error(errMsg);\n          }\n        }\n      }\n\n      return tokens;\n    };\n\n    _createClass(Lexer, null, [{\n      key: \"rules\",\n      get: function get() {\n        return {\n          block: block,\n          inline: inline\n        };\n      }\n    }]);\n\n    return Lexer;\n  }();\n\n  var defaults$2 = defaults$5.exports.defaults;\n  var cleanUrl = helpers.cleanUrl,\n      escape$1 = helpers.escape;\n  /**\n   * Renderer\n   */\n\n  var Renderer_1 = /*#__PURE__*/function () {\n    function Renderer(options) {\n      this.options = options || defaults$2;\n    }\n\n    var _proto = Renderer.prototype;\n\n    _proto.code = function code(_code, infostring, escaped) {\n      var lang = (infostring || '').match(/\\S*/)[0];\n\n      if (this.options.highlight) {\n        var out = this.options.highlight(_code, lang);\n\n        if (out != null && out !== _code) {\n          escaped = true;\n          _code = out;\n        }\n      }\n\n      _code = _code.replace(/\\n$/, '') + '\\n';\n\n      if (!lang) {\n        return '<pre><code>' + (escaped ? _code : escape$1(_code, true)) + '</code></pre>\\n';\n      }\n\n      return '<pre><code class=\"' + this.options.langPrefix + escape$1(lang, true) + '\">' + (escaped ? _code : escape$1(_code, true)) + '</code></pre>\\n';\n    };\n\n    _proto.blockquote = function blockquote(quote) {\n      return '<blockquote>\\n' + quote + '</blockquote>\\n';\n    };\n\n    _proto.html = function html(_html) {\n      return _html;\n    };\n\n    _proto.heading = function heading(text, level, raw, slugger) {\n      if (this.options.headerIds) {\n        return '<h' + level + ' id=\"' + this.options.headerPrefix + slugger.slug(raw) + '\">' + text + '</h' + level + '>\\n';\n      } // ignore IDs\n\n\n      return '<h' + level + '>' + text + '</h' + level + '>\\n';\n    };\n\n    _proto.hr = function hr() {\n      return this.options.xhtml ? '<hr/>\\n' : '<hr>\\n';\n    };\n\n    _proto.list = function list(body, ordered, start) {\n      var type = ordered ? 'ol' : 'ul',\n          startatt = ordered && start !== 1 ? ' start=\"' + start + '\"' : '';\n      return '<' + type + startatt + '>\\n' + body + '</' + type + '>\\n';\n    };\n\n    _proto.listitem = function listitem(text) {\n      return '<li>' + text + '</li>\\n';\n    };\n\n    _proto.checkbox = function checkbox(checked) {\n      return '<input ' + (checked ? 'checked=\"\" ' : '') + 'disabled=\"\" type=\"checkbox\"' + (this.options.xhtml ? ' /' : '') + '> ';\n    };\n\n    _proto.paragraph = function paragraph(text) {\n      return '<p>' + text + '</p>\\n';\n    };\n\n    _proto.table = function table(header, body) {\n      if (body) body = '<tbody>' + body + '</tbody>';\n      return '<table>\\n' + '<thead>\\n' + header + '</thead>\\n' + body + '</table>\\n';\n    };\n\n    _proto.tablerow = function tablerow(content) {\n      return '<tr>\\n' + content + '</tr>\\n';\n    };\n\n    _proto.tablecell = function tablecell(content, flags) {\n      var type = flags.header ? 'th' : 'td';\n      var tag = flags.align ? '<' + type + ' align=\"' + flags.align + '\">' : '<' + type + '>';\n      return tag + content + '</' + type + '>\\n';\n    } // span level renderer\n    ;\n\n    _proto.strong = function strong(text) {\n      return '<strong>' + text + '</strong>';\n    };\n\n    _proto.em = function em(text) {\n      return '<em>' + text + '</em>';\n    };\n\n    _proto.codespan = function codespan(text) {\n      return '<code>' + text + '</code>';\n    };\n\n    _proto.br = function br() {\n      return this.options.xhtml ? '<br/>' : '<br>';\n    };\n\n    _proto.del = function del(text) {\n      return '<del>' + text + '</del>';\n    };\n\n    _proto.link = function link(href, title, text) {\n      href = cleanUrl(this.options.sanitize, this.options.baseUrl, href);\n\n      if (href === null) {\n        return text;\n      }\n\n      var out = '<a href=\"' + escape$1(href) + '\"';\n\n      if (title) {\n        out += ' title=\"' + title + '\"';\n      }\n\n      out += '>' + text + '</a>';\n      return out;\n    };\n\n    _proto.image = function image(href, title, text) {\n      href = cleanUrl(this.options.sanitize, this.options.baseUrl, href);\n\n      if (href === null) {\n        return text;\n      }\n\n      var out = '<img src=\"' + href + '\" alt=\"' + text + '\"';\n\n      if (title) {\n        out += ' title=\"' + title + '\"';\n      }\n\n      out += this.options.xhtml ? '/>' : '>';\n      return out;\n    };\n\n    _proto.text = function text(_text) {\n      return _text;\n    };\n\n    return Renderer;\n  }();\n\n  /**\n   * TextRenderer\n   * returns only the textual part of the token\n   */\n\n  var TextRenderer_1 = /*#__PURE__*/function () {\n    function TextRenderer() {}\n\n    var _proto = TextRenderer.prototype;\n\n    // no need for block level renderers\n    _proto.strong = function strong(text) {\n      return text;\n    };\n\n    _proto.em = function em(text) {\n      return text;\n    };\n\n    _proto.codespan = function codespan(text) {\n      return text;\n    };\n\n    _proto.del = function del(text) {\n      return text;\n    };\n\n    _proto.html = function html(text) {\n      return text;\n    };\n\n    _proto.text = function text(_text) {\n      return _text;\n    };\n\n    _proto.link = function link(href, title, text) {\n      return '' + text;\n    };\n\n    _proto.image = function image(href, title, text) {\n      return '' + text;\n    };\n\n    _proto.br = function br() {\n      return '';\n    };\n\n    return TextRenderer;\n  }();\n\n  /**\n   * Slugger generates header id\n   */\n\n  var Slugger_1 = /*#__PURE__*/function () {\n    function Slugger() {\n      this.seen = {};\n    }\n\n    var _proto = Slugger.prototype;\n\n    _proto.serialize = function serialize(value) {\n      return value.toLowerCase().trim() // remove html tags\n      .replace(/<[!\\/a-z].*?>/ig, '') // remove unwanted chars\n      .replace(/[\\u2000-\\u206F\\u2E00-\\u2E7F\\\\'!\"#$%&()*+,./:;<=>?@[\\]^`{|}~]/g, '').replace(/\\s/g, '-');\n    }\n    /**\n     * Finds the next safe (unique) slug to use\n     */\n    ;\n\n    _proto.getNextSafeSlug = function getNextSafeSlug(originalSlug, isDryRun) {\n      var slug = originalSlug;\n      var occurenceAccumulator = 0;\n\n      if (this.seen.hasOwnProperty(slug)) {\n        occurenceAccumulator = this.seen[originalSlug];\n\n        do {\n          occurenceAccumulator++;\n          slug = originalSlug + '-' + occurenceAccumulator;\n        } while (this.seen.hasOwnProperty(slug));\n      }\n\n      if (!isDryRun) {\n        this.seen[originalSlug] = occurenceAccumulator;\n        this.seen[slug] = 0;\n      }\n\n      return slug;\n    }\n    /**\n     * Convert string to unique id\n     * @param {object} options\n     * @param {boolean} options.dryrun Generates the next unique slug without updating the internal accumulator.\n     */\n    ;\n\n    _proto.slug = function slug(value, options) {\n      if (options === void 0) {\n        options = {};\n      }\n\n      var slug = this.serialize(value);\n      return this.getNextSafeSlug(slug, options.dryrun);\n    };\n\n    return Slugger;\n  }();\n\n  var Renderer$1 = Renderer_1;\n  var TextRenderer$1 = TextRenderer_1;\n  var Slugger$1 = Slugger_1;\n  var defaults$1 = defaults$5.exports.defaults;\n  var unescape = helpers.unescape;\n  /**\n   * Parsing & Compiling\n   */\n\n  var Parser_1 = /*#__PURE__*/function () {\n    function Parser(options) {\n      this.options = options || defaults$1;\n      this.options.renderer = this.options.renderer || new Renderer$1();\n      this.renderer = this.options.renderer;\n      this.renderer.options = this.options;\n      this.textRenderer = new TextRenderer$1();\n      this.slugger = new Slugger$1();\n    }\n    /**\n     * Static Parse Method\n     */\n\n\n    Parser.parse = function parse(tokens, options) {\n      var parser = new Parser(options);\n      return parser.parse(tokens);\n    }\n    /**\n     * Static Parse Inline Method\n     */\n    ;\n\n    Parser.parseInline = function parseInline(tokens, options) {\n      var parser = new Parser(options);\n      return parser.parseInline(tokens);\n    }\n    /**\n     * Parse Loop\n     */\n    ;\n\n    var _proto = Parser.prototype;\n\n    _proto.parse = function parse(tokens, top) {\n      if (top === void 0) {\n        top = true;\n      }\n\n      var out = '',\n          i,\n          j,\n          k,\n          l2,\n          l3,\n          row,\n          cell,\n          header,\n          body,\n          token,\n          ordered,\n          start,\n          loose,\n          itemBody,\n          item,\n          checked,\n          task,\n          checkbox,\n          ret;\n      var l = tokens.length;\n\n      for (i = 0; i < l; i++) {\n        token = tokens[i]; // Run any renderer extensions\n\n        if (this.options.extensions && this.options.extensions.renderers && this.options.extensions.renderers[token.type]) {\n          ret = this.options.extensions.renderers[token.type].call({\n            parser: this\n          }, token);\n\n          if (ret !== false || !['space', 'hr', 'heading', 'code', 'table', 'blockquote', 'list', 'html', 'paragraph', 'text'].includes(token.type)) {\n            out += ret || '';\n            continue;\n          }\n        }\n\n        switch (token.type) {\n          case 'space':\n            {\n              continue;\n            }\n\n          case 'hr':\n            {\n              out += this.renderer.hr();\n              continue;\n            }\n\n          case 'heading':\n            {\n              out += this.renderer.heading(this.parseInline(token.tokens), token.depth, unescape(this.parseInline(token.tokens, this.textRenderer)), this.slugger);\n              continue;\n            }\n\n          case 'code':\n            {\n              out += this.renderer.code(token.text, token.lang, token.escaped);\n              continue;\n            }\n\n          case 'table':\n            {\n              header = ''; // header\n\n              cell = '';\n              l2 = token.header.length;\n\n              for (j = 0; j < l2; j++) {\n                cell += this.renderer.tablecell(this.parseInline(token.header[j].tokens), {\n                  header: true,\n                  align: token.align[j]\n                });\n              }\n\n              header += this.renderer.tablerow(cell);\n              body = '';\n              l2 = token.rows.length;\n\n              for (j = 0; j < l2; j++) {\n                row = token.rows[j];\n                cell = '';\n                l3 = row.length;\n\n                for (k = 0; k < l3; k++) {\n                  cell += this.renderer.tablecell(this.parseInline(row[k].tokens), {\n                    header: false,\n                    align: token.align[k]\n                  });\n                }\n\n                body += this.renderer.tablerow(cell);\n              }\n\n              out += this.renderer.table(header, body);\n              continue;\n            }\n\n          case 'blockquote':\n            {\n              body = this.parse(token.tokens);\n              out += this.renderer.blockquote(body);\n              continue;\n            }\n\n          case 'list':\n            {\n              ordered = token.ordered;\n              start = token.start;\n              loose = token.loose;\n              l2 = token.items.length;\n              body = '';\n\n              for (j = 0; j < l2; j++) {\n                item = token.items[j];\n                checked = item.checked;\n                task = item.task;\n                itemBody = '';\n\n                if (item.task) {\n                  checkbox = this.renderer.checkbox(checked);\n\n                  if (loose) {\n                    if (item.tokens.length > 0 && item.tokens[0].type === 'paragraph') {\n                      item.tokens[0].text = checkbox + ' ' + item.tokens[0].text;\n\n                      if (item.tokens[0].tokens && item.tokens[0].tokens.length > 0 && item.tokens[0].tokens[0].type === 'text') {\n                        item.tokens[0].tokens[0].text = checkbox + ' ' + item.tokens[0].tokens[0].text;\n                      }\n                    } else {\n                      item.tokens.unshift({\n                        type: 'text',\n                        text: checkbox\n                      });\n                    }\n                  } else {\n                    itemBody += checkbox;\n                  }\n                }\n\n                itemBody += this.parse(item.tokens, loose);\n                body += this.renderer.listitem(itemBody, task, checked);\n              }\n\n              out += this.renderer.list(body, ordered, start);\n              continue;\n            }\n\n          case 'html':\n            {\n              // TODO parse inline content if parameter markdown=1\n              out += this.renderer.html(token.text);\n              continue;\n            }\n\n          case 'paragraph':\n            {\n              out += this.renderer.paragraph(this.parseInline(token.tokens));\n              continue;\n            }\n\n          case 'text':\n            {\n              body = token.tokens ? this.parseInline(token.tokens) : token.text;\n\n              while (i + 1 < l && tokens[i + 1].type === 'text') {\n                token = tokens[++i];\n                body += '\\n' + (token.tokens ? this.parseInline(token.tokens) : token.text);\n              }\n\n              out += top ? this.renderer.paragraph(body) : body;\n              continue;\n            }\n\n          default:\n            {\n              var errMsg = 'Token with \"' + token.type + '\" type was not found.';\n\n              if (this.options.silent) {\n                console.error(errMsg);\n                return;\n              } else {\n                throw new Error(errMsg);\n              }\n            }\n        }\n      }\n\n      return out;\n    }\n    /**\n     * Parse Inline Tokens\n     */\n    ;\n\n    _proto.parseInline = function parseInline(tokens, renderer) {\n      renderer = renderer || this.renderer;\n      var out = '',\n          i,\n          token,\n          ret;\n      var l = tokens.length;\n\n      for (i = 0; i < l; i++) {\n        token = tokens[i]; // Run any renderer extensions\n\n        if (this.options.extensions && this.options.extensions.renderers && this.options.extensions.renderers[token.type]) {\n          ret = this.options.extensions.renderers[token.type].call({\n            parser: this\n          }, token);\n\n          if (ret !== false || !['escape', 'html', 'link', 'image', 'strong', 'em', 'codespan', 'br', 'del', 'text'].includes(token.type)) {\n            out += ret || '';\n            continue;\n          }\n        }\n\n        switch (token.type) {\n          case 'escape':\n            {\n              out += renderer.text(token.text);\n              break;\n            }\n\n          case 'html':\n            {\n              out += renderer.html(token.text);\n              break;\n            }\n\n          case 'link':\n            {\n              out += renderer.link(token.href, token.title, this.parseInline(token.tokens, renderer));\n              break;\n            }\n\n          case 'image':\n            {\n              out += renderer.image(token.href, token.title, token.text);\n              break;\n            }\n\n          case 'strong':\n            {\n              out += renderer.strong(this.parseInline(token.tokens, renderer));\n              break;\n            }\n\n          case 'em':\n            {\n              out += renderer.em(this.parseInline(token.tokens, renderer));\n              break;\n            }\n\n          case 'codespan':\n            {\n              out += renderer.codespan(token.text);\n              break;\n            }\n\n          case 'br':\n            {\n              out += renderer.br();\n              break;\n            }\n\n          case 'del':\n            {\n              out += renderer.del(this.parseInline(token.tokens, renderer));\n              break;\n            }\n\n          case 'text':\n            {\n              out += renderer.text(token.text);\n              break;\n            }\n\n          default:\n            {\n              var errMsg = 'Token with \"' + token.type + '\" type was not found.';\n\n              if (this.options.silent) {\n                console.error(errMsg);\n                return;\n              } else {\n                throw new Error(errMsg);\n              }\n            }\n        }\n      }\n\n      return out;\n    };\n\n    return Parser;\n  }();\n\n  var Lexer = Lexer_1;\n  var Parser = Parser_1;\n  var Tokenizer = Tokenizer_1;\n  var Renderer = Renderer_1;\n  var TextRenderer = TextRenderer_1;\n  var Slugger = Slugger_1;\n  var merge = helpers.merge,\n      checkSanitizeDeprecation = helpers.checkSanitizeDeprecation,\n      escape = helpers.escape;\n  var getDefaults = defaults$5.exports.getDefaults,\n      changeDefaults = defaults$5.exports.changeDefaults,\n      defaults = defaults$5.exports.defaults;\n  /**\n   * Marked\n   */\n\n  function marked(src, opt, callback) {\n    // throw error in case of non string input\n    if (typeof src === 'undefined' || src === null) {\n      throw new Error('marked(): input parameter is undefined or null');\n    }\n\n    if (typeof src !== 'string') {\n      throw new Error('marked(): input parameter is of type ' + Object.prototype.toString.call(src) + ', string expected');\n    }\n\n    if (typeof opt === 'function') {\n      callback = opt;\n      opt = null;\n    }\n\n    opt = merge({}, marked.defaults, opt || {});\n    checkSanitizeDeprecation(opt);\n\n    if (callback) {\n      var highlight = opt.highlight;\n      var tokens;\n\n      try {\n        tokens = Lexer.lex(src, opt);\n      } catch (e) {\n        return callback(e);\n      }\n\n      var done = function done(err) {\n        var out;\n\n        if (!err) {\n          try {\n            if (opt.walkTokens) {\n              marked.walkTokens(tokens, opt.walkTokens);\n            }\n\n            out = Parser.parse(tokens, opt);\n          } catch (e) {\n            err = e;\n          }\n        }\n\n        opt.highlight = highlight;\n        return err ? callback(err) : callback(null, out);\n      };\n\n      if (!highlight || highlight.length < 3) {\n        return done();\n      }\n\n      delete opt.highlight;\n      if (!tokens.length) return done();\n      var pending = 0;\n      marked.walkTokens(tokens, function (token) {\n        if (token.type === 'code') {\n          pending++;\n          setTimeout(function () {\n            highlight(token.text, token.lang, function (err, code) {\n              if (err) {\n                return done(err);\n              }\n\n              if (code != null && code !== token.text) {\n                token.text = code;\n                token.escaped = true;\n              }\n\n              pending--;\n\n              if (pending === 0) {\n                done();\n              }\n            });\n          }, 0);\n        }\n      });\n\n      if (pending === 0) {\n        done();\n      }\n\n      return;\n    }\n\n    try {\n      var _tokens = Lexer.lex(src, opt);\n\n      if (opt.walkTokens) {\n        marked.walkTokens(_tokens, opt.walkTokens);\n      }\n\n      return Parser.parse(_tokens, opt);\n    } catch (e) {\n      e.message += '\\nPlease report this to https://github.com/markedjs/marked.';\n\n      if (opt.silent) {\n        return '<p>An error occurred:</p><pre>' + escape(e.message + '', true) + '</pre>';\n      }\n\n      throw e;\n    }\n  }\n  /**\n   * Options\n   */\n\n\n  marked.options = marked.setOptions = function (opt) {\n    merge(marked.defaults, opt);\n    changeDefaults(marked.defaults);\n    return marked;\n  };\n\n  marked.getDefaults = getDefaults;\n  marked.defaults = defaults;\n  /**\n   * Use Extension\n   */\n\n  marked.use = function () {\n    var _this = this;\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    var opts = merge.apply(void 0, [{}].concat(args));\n    var extensions = marked.defaults.extensions || {\n      renderers: {},\n      childTokens: {}\n    };\n    var hasExtensions;\n    args.forEach(function (pack) {\n      // ==-- Parse \"addon\" extensions --== //\n      if (pack.extensions) {\n        hasExtensions = true;\n        pack.extensions.forEach(function (ext) {\n          if (!ext.name) {\n            throw new Error('extension name required');\n          }\n\n          if (ext.renderer) {\n            // Renderer extensions\n            var prevRenderer = extensions.renderers ? extensions.renderers[ext.name] : null;\n\n            if (prevRenderer) {\n              // Replace extension with func to run new extension but fall back if false\n              extensions.renderers[ext.name] = function () {\n                for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n                  args[_key2] = arguments[_key2];\n                }\n\n                var ret = ext.renderer.apply(this, args);\n\n                if (ret === false) {\n                  ret = prevRenderer.apply(this, args);\n                }\n\n                return ret;\n              };\n            } else {\n              extensions.renderers[ext.name] = ext.renderer;\n            }\n          }\n\n          if (ext.tokenizer) {\n            // Tokenizer Extensions\n            if (!ext.level || ext.level !== 'block' && ext.level !== 'inline') {\n              throw new Error(\"extension level must be 'block' or 'inline'\");\n            }\n\n            if (extensions[ext.level]) {\n              extensions[ext.level].unshift(ext.tokenizer);\n            } else {\n              extensions[ext.level] = [ext.tokenizer];\n            }\n\n            if (ext.start) {\n              // Function to check for start of token\n              if (ext.level === 'block') {\n                if (extensions.startBlock) {\n                  extensions.startBlock.push(ext.start);\n                } else {\n                  extensions.startBlock = [ext.start];\n                }\n              } else if (ext.level === 'inline') {\n                if (extensions.startInline) {\n                  extensions.startInline.push(ext.start);\n                } else {\n                  extensions.startInline = [ext.start];\n                }\n              }\n            }\n          }\n\n          if (ext.childTokens) {\n            // Child tokens to be visited by walkTokens\n            extensions.childTokens[ext.name] = ext.childTokens;\n          }\n        });\n      } // ==-- Parse \"overwrite\" extensions --== //\n\n\n      if (pack.renderer) {\n        (function () {\n          var renderer = marked.defaults.renderer || new Renderer();\n\n          var _loop = function _loop(prop) {\n            var prevRenderer = renderer[prop]; // Replace renderer with func to run extension, but fall back if false\n\n            renderer[prop] = function () {\n              for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n                args[_key3] = arguments[_key3];\n              }\n\n              var ret = pack.renderer[prop].apply(renderer, args);\n\n              if (ret === false) {\n                ret = prevRenderer.apply(renderer, args);\n              }\n\n              return ret;\n            };\n          };\n\n          for (var prop in pack.renderer) {\n            _loop(prop);\n          }\n\n          opts.renderer = renderer;\n        })();\n      }\n\n      if (pack.tokenizer) {\n        (function () {\n          var tokenizer = marked.defaults.tokenizer || new Tokenizer();\n\n          var _loop2 = function _loop2(prop) {\n            var prevTokenizer = tokenizer[prop]; // Replace tokenizer with func to run extension, but fall back if false\n\n            tokenizer[prop] = function () {\n              for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n                args[_key4] = arguments[_key4];\n              }\n\n              var ret = pack.tokenizer[prop].apply(tokenizer, args);\n\n              if (ret === false) {\n                ret = prevTokenizer.apply(tokenizer, args);\n              }\n\n              return ret;\n            };\n          };\n\n          for (var prop in pack.tokenizer) {\n            _loop2(prop);\n          }\n\n          opts.tokenizer = tokenizer;\n        })();\n      } // ==-- Parse WalkTokens extensions --== //\n\n\n      if (pack.walkTokens) {\n        var walkTokens = marked.defaults.walkTokens;\n\n        opts.walkTokens = function (token) {\n          pack.walkTokens.call(_this, token);\n\n          if (walkTokens) {\n            walkTokens(token);\n          }\n        };\n      }\n\n      if (hasExtensions) {\n        opts.extensions = extensions;\n      }\n\n      marked.setOptions(opts);\n    });\n  };\n  /**\n   * Run callback for every token\n   */\n\n\n  marked.walkTokens = function (tokens, callback) {\n    var _loop3 = function _loop3() {\n      var token = _step.value;\n      callback(token);\n\n      switch (token.type) {\n        case 'table':\n          {\n            for (var _iterator2 = _createForOfIteratorHelperLoose(token.header), _step2; !(_step2 = _iterator2()).done;) {\n              var cell = _step2.value;\n              marked.walkTokens(cell.tokens, callback);\n            }\n\n            for (var _iterator3 = _createForOfIteratorHelperLoose(token.rows), _step3; !(_step3 = _iterator3()).done;) {\n              var row = _step3.value;\n\n              for (var _iterator4 = _createForOfIteratorHelperLoose(row), _step4; !(_step4 = _iterator4()).done;) {\n                var _cell = _step4.value;\n                marked.walkTokens(_cell.tokens, callback);\n              }\n            }\n\n            break;\n          }\n\n        case 'list':\n          {\n            marked.walkTokens(token.items, callback);\n            break;\n          }\n\n        default:\n          {\n            if (marked.defaults.extensions && marked.defaults.extensions.childTokens && marked.defaults.extensions.childTokens[token.type]) {\n              // Walk any extensions\n              marked.defaults.extensions.childTokens[token.type].forEach(function (childTokens) {\n                marked.walkTokens(token[childTokens], callback);\n              });\n            } else if (token.tokens) {\n              marked.walkTokens(token.tokens, callback);\n            }\n          }\n      }\n    };\n\n    for (var _iterator = _createForOfIteratorHelperLoose(tokens), _step; !(_step = _iterator()).done;) {\n      _loop3();\n    }\n  };\n  /**\n   * Parse Inline\n   */\n\n\n  marked.parseInline = function (src, opt) {\n    // throw error in case of non string input\n    if (typeof src === 'undefined' || src === null) {\n      throw new Error('marked.parseInline(): input parameter is undefined or null');\n    }\n\n    if (typeof src !== 'string') {\n      throw new Error('marked.parseInline(): input parameter is of type ' + Object.prototype.toString.call(src) + ', string expected');\n    }\n\n    opt = merge({}, marked.defaults, opt || {});\n    checkSanitizeDeprecation(opt);\n\n    try {\n      var tokens = Lexer.lexInline(src, opt);\n\n      if (opt.walkTokens) {\n        marked.walkTokens(tokens, opt.walkTokens);\n      }\n\n      return Parser.parseInline(tokens, opt);\n    } catch (e) {\n      e.message += '\\nPlease report this to https://github.com/markedjs/marked.';\n\n      if (opt.silent) {\n        return '<p>An error occurred:</p><pre>' + escape(e.message + '', true) + '</pre>';\n      }\n\n      throw e;\n    }\n  };\n  /**\n   * Expose\n   */\n\n\n  marked.Parser = Parser;\n  marked.parser = Parser.parse;\n  marked.Renderer = Renderer;\n  marked.TextRenderer = TextRenderer;\n  marked.Lexer = Lexer;\n  marked.lexer = Lexer.lex;\n  marked.Tokenizer = Tokenizer;\n  marked.Slugger = Slugger;\n  marked.parse = marked;\n  var marked_1 = marked;\n\n  return marked_1;\n\n}));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esc0NBQXNDLElBQUk7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGtDQUFrQzs7QUFFbEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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O0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxVQUFVOzs7QUFHVjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFVBQVU7OztBQUdWO0FBQ0E7QUFDQSxpREFBaUQ7O0FBRWpEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQSxVQUFVOzs7QUFHVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7OztBQUdWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTs7O0FBR1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVOzs7QUFHVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7OztBQUdWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTs7O0FBR1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVOzs7QUFHVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFVBQVU7OztBQUdWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTs7O0FBR1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZTs7QUFFZjtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVOzs7QUFHVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsb0NBQW9DOztBQUVwQztBQUNBO0FBQ0Esa0NBQWtDOztBQUVsQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTs7O0FBR1I7QUFDQTtBQUNBLFFBQVE7OztBQUdSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw4QkFBOEI7O0FBRTlCO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFVBQVU7OztBQUdWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTs7O0FBR1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0EsVUFBVTs7O0FBR1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVOzs7QUFHVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQSxVQUFVOzs7QUFHVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7OztBQUdWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTs7O0FBR1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVOzs7QUFHVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7OztBQUdWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTs7O0FBR1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZTs7QUFFZjtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFROzs7QUFHUjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RCxXQUFXLEVBQUU7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVM7QUFDVCxRQUFROzs7QUFHUjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHlGQUF5Riw4QkFBOEI7QUFDdkg7QUFDQTtBQUNBOztBQUVBLHVGQUF1Riw4QkFBOEI7QUFDckg7O0FBRUEsa0ZBQWtGLDhCQUE4QjtBQUNoSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHlFQUF5RSw0QkFBNEI7QUFDckc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0IsNEJBQTRCO0FBQzlDOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBTTtBQUNOOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9ub2RlX21vZHVsZXMvbWFya2VkL2xpYi9tYXJrZWQuanM/MGU1NCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIG1hcmtlZCAtIGEgbWFya2Rvd24gcGFyc2VyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTEtMjAyMSwgQ2hyaXN0b3BoZXIgSmVmZnJleS4gKE1JVCBMaWNlbnNlZClcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9tYXJrZWRqcy9tYXJrZWRcbiAqL1xuXG4vKipcbiAqIERPIE5PVCBFRElUIFRISVMgRklMRVxuICogVGhlIGNvZGUgaW4gdGhpcyBmaWxlIGlzIGdlbmVyYXRlZCBmcm9tIGZpbGVzIGluIC4vc3JjL1xuICovXG5cbihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG4gIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpIDpcbiAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKGZhY3RvcnkpIDpcbiAgKGdsb2JhbCA9IHR5cGVvZiBnbG9iYWxUaGlzICE9PSAndW5kZWZpbmVkJyA/IGdsb2JhbFRoaXMgOiBnbG9iYWwgfHwgc2VsZiwgZ2xvYmFsLm1hcmtlZCA9IGZhY3RvcnkoKSk7XG59KSh0aGlzLCAoZnVuY3Rpb24gKCkgeyAndXNlIHN0cmljdCc7XG5cbiAgZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07XG4gICAgICBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7XG4gICAgICBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7XG4gICAgICBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHtcbiAgICBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTtcbiAgICBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7XG4gICAgcmV0dXJuIENvbnN0cnVjdG9yO1xuICB9XG5cbiAgZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8sIG1pbkxlbikge1xuICAgIGlmICghbykgcmV0dXJuO1xuICAgIGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7XG4gICAgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpO1xuICAgIGlmIChuID09PSBcIk9iamVjdFwiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7XG4gICAgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIEFycmF5LmZyb20obyk7XG4gICAgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pO1xuICB9XG5cbiAgZnVuY3Rpb24gX2FycmF5TGlrZVRvQXJyYXkoYXJyLCBsZW4pIHtcbiAgICBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDtcblxuICAgIGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKykgYXJyMltpXSA9IGFycltpXTtcblxuICAgIHJldHVybiBhcnIyO1xuICB9XG5cbiAgZnVuY3Rpb24gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXJMb29zZShvLCBhbGxvd0FycmF5TGlrZSkge1xuICAgIHZhciBpdCA9IHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdIHx8IG9bXCJAQGl0ZXJhdG9yXCJdO1xuICAgIGlmIChpdCkgcmV0dXJuIChpdCA9IGl0LmNhbGwobykpLm5leHQuYmluZChpdCk7XG5cbiAgICBpZiAoQXJyYXkuaXNBcnJheShvKSB8fCAoaXQgPSBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobykpIHx8IGFsbG93QXJyYXlMaWtlICYmIG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09PSBcIm51bWJlclwiKSB7XG4gICAgICBpZiAoaXQpIG8gPSBpdDtcbiAgICAgIHZhciBpID0gMDtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChpID49IG8ubGVuZ3RoKSByZXR1cm4ge1xuICAgICAgICAgIGRvbmU6IHRydWVcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBkb25lOiBmYWxzZSxcbiAgICAgICAgICB2YWx1ZTogb1tpKytdXG4gICAgICAgIH07XG4gICAgICB9O1xuICAgIH1cblxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gaXRlcmF0ZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTtcbiAgfVxuXG4gIHZhciBkZWZhdWx0cyQ1ID0ge2V4cG9ydHM6IHt9fTtcblxuICBmdW5jdGlvbiBnZXREZWZhdWx0cyQxKCkge1xuICAgIHJldHVybiB7XG4gICAgICBiYXNlVXJsOiBudWxsLFxuICAgICAgYnJlYWtzOiBmYWxzZSxcbiAgICAgIGV4dGVuc2lvbnM6IG51bGwsXG4gICAgICBnZm06IHRydWUsXG4gICAgICBoZWFkZXJJZHM6IHRydWUsXG4gICAgICBoZWFkZXJQcmVmaXg6ICcnLFxuICAgICAgaGlnaGxpZ2h0OiBudWxsLFxuICAgICAgbGFuZ1ByZWZpeDogJ2xhbmd1YWdlLScsXG4gICAgICBtYW5nbGU6IHRydWUsXG4gICAgICBwZWRhbnRpYzogZmFsc2UsXG4gICAgICByZW5kZXJlcjogbnVsbCxcbiAgICAgIHNhbml0aXplOiBmYWxzZSxcbiAgICAgIHNhbml0aXplcjogbnVsbCxcbiAgICAgIHNpbGVudDogZmFsc2UsXG4gICAgICBzbWFydExpc3RzOiBmYWxzZSxcbiAgICAgIHNtYXJ0eXBhbnRzOiBmYWxzZSxcbiAgICAgIHRva2VuaXplcjogbnVsbCxcbiAgICAgIHdhbGtUb2tlbnM6IG51bGwsXG4gICAgICB4aHRtbDogZmFsc2VcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gY2hhbmdlRGVmYXVsdHMkMShuZXdEZWZhdWx0cykge1xuICAgIGRlZmF1bHRzJDUuZXhwb3J0cy5kZWZhdWx0cyA9IG5ld0RlZmF1bHRzO1xuICB9XG5cbiAgZGVmYXVsdHMkNS5leHBvcnRzID0ge1xuICAgIGRlZmF1bHRzOiBnZXREZWZhdWx0cyQxKCksXG4gICAgZ2V0RGVmYXVsdHM6IGdldERlZmF1bHRzJDEsXG4gICAgY2hhbmdlRGVmYXVsdHM6IGNoYW5nZURlZmF1bHRzJDFcbiAgfTtcblxuICAvKipcbiAgICogSGVscGVyc1xuICAgKi9cbiAgdmFyIGVzY2FwZVRlc3QgPSAvWyY8PlwiJ10vO1xuICB2YXIgZXNjYXBlUmVwbGFjZSA9IC9bJjw+XCInXS9nO1xuICB2YXIgZXNjYXBlVGVzdE5vRW5jb2RlID0gL1s8PlwiJ118Jig/ISM/XFx3KzspLztcbiAgdmFyIGVzY2FwZVJlcGxhY2VOb0VuY29kZSA9IC9bPD5cIiddfCYoPyEjP1xcdys7KS9nO1xuICB2YXIgZXNjYXBlUmVwbGFjZW1lbnRzID0ge1xuICAgICcmJzogJyZhbXA7JyxcbiAgICAnPCc6ICcmbHQ7JyxcbiAgICAnPic6ICcmZ3Q7JyxcbiAgICAnXCInOiAnJnF1b3Q7JyxcbiAgICBcIidcIjogJyYjMzk7J1xuICB9O1xuXG4gIHZhciBnZXRFc2NhcGVSZXBsYWNlbWVudCA9IGZ1bmN0aW9uIGdldEVzY2FwZVJlcGxhY2VtZW50KGNoKSB7XG4gICAgcmV0dXJuIGVzY2FwZVJlcGxhY2VtZW50c1tjaF07XG4gIH07XG5cbiAgZnVuY3Rpb24gZXNjYXBlJDIoaHRtbCwgZW5jb2RlKSB7XG4gICAgaWYgKGVuY29kZSkge1xuICAgICAgaWYgKGVzY2FwZVRlc3QudGVzdChodG1sKSkge1xuICAgICAgICByZXR1cm4gaHRtbC5yZXBsYWNlKGVzY2FwZVJlcGxhY2UsIGdldEVzY2FwZVJlcGxhY2VtZW50KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGVzY2FwZVRlc3ROb0VuY29kZS50ZXN0KGh0bWwpKSB7XG4gICAgICAgIHJldHVybiBodG1sLnJlcGxhY2UoZXNjYXBlUmVwbGFjZU5vRW5jb2RlLCBnZXRFc2NhcGVSZXBsYWNlbWVudCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGh0bWw7XG4gIH1cblxuICB2YXIgdW5lc2NhcGVUZXN0ID0gLyYoIyg/OlxcZCspfCg/OiN4WzAtOUEtRmEtZl0rKXwoPzpcXHcrKSk7Py9pZztcblxuICBmdW5jdGlvbiB1bmVzY2FwZSQxKGh0bWwpIHtcbiAgICAvLyBleHBsaWNpdGx5IG1hdGNoIGRlY2ltYWwsIGhleCwgYW5kIG5hbWVkIEhUTUwgZW50aXRpZXNcbiAgICByZXR1cm4gaHRtbC5yZXBsYWNlKHVuZXNjYXBlVGVzdCwgZnVuY3Rpb24gKF8sIG4pIHtcbiAgICAgIG4gPSBuLnRvTG93ZXJDYXNlKCk7XG4gICAgICBpZiAobiA9PT0gJ2NvbG9uJykgcmV0dXJuICc6JztcblxuICAgICAgaWYgKG4uY2hhckF0KDApID09PSAnIycpIHtcbiAgICAgICAgcmV0dXJuIG4uY2hhckF0KDEpID09PSAneCcgPyBTdHJpbmcuZnJvbUNoYXJDb2RlKHBhcnNlSW50KG4uc3Vic3RyaW5nKDIpLCAxNikpIDogU3RyaW5nLmZyb21DaGFyQ29kZSgrbi5zdWJzdHJpbmcoMSkpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gJyc7XG4gICAgfSk7XG4gIH1cblxuICB2YXIgY2FyZXQgPSAvKF58W15cXFtdKVxcXi9nO1xuXG4gIGZ1bmN0aW9uIGVkaXQkMShyZWdleCwgb3B0KSB7XG4gICAgcmVnZXggPSByZWdleC5zb3VyY2UgfHwgcmVnZXg7XG4gICAgb3B0ID0gb3B0IHx8ICcnO1xuICAgIHZhciBvYmogPSB7XG4gICAgICByZXBsYWNlOiBmdW5jdGlvbiByZXBsYWNlKG5hbWUsIHZhbCkge1xuICAgICAgICB2YWwgPSB2YWwuc291cmNlIHx8IHZhbDtcbiAgICAgICAgdmFsID0gdmFsLnJlcGxhY2UoY2FyZXQsICckMScpO1xuICAgICAgICByZWdleCA9IHJlZ2V4LnJlcGxhY2UobmFtZSwgdmFsKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgIH0sXG4gICAgICBnZXRSZWdleDogZnVuY3Rpb24gZ2V0UmVnZXgoKSB7XG4gICAgICAgIHJldHVybiBuZXcgUmVnRXhwKHJlZ2V4LCBvcHQpO1xuICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIG9iajtcbiAgfVxuXG4gIHZhciBub25Xb3JkQW5kQ29sb25UZXN0ID0gL1teXFx3Ol0vZztcbiAgdmFyIG9yaWdpbkluZGVwZW5kZW50VXJsID0gL14kfF5bYS16XVthLXowLTkrLi1dKjp8Xls/I10vaTtcblxuICBmdW5jdGlvbiBjbGVhblVybCQxKHNhbml0aXplLCBiYXNlLCBocmVmKSB7XG4gICAgaWYgKHNhbml0aXplKSB7XG4gICAgICB2YXIgcHJvdDtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgcHJvdCA9IGRlY29kZVVSSUNvbXBvbmVudCh1bmVzY2FwZSQxKGhyZWYpKS5yZXBsYWNlKG5vbldvcmRBbmRDb2xvblRlc3QsICcnKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgaWYgKHByb3QuaW5kZXhPZignamF2YXNjcmlwdDonKSA9PT0gMCB8fCBwcm90LmluZGV4T2YoJ3Zic2NyaXB0OicpID09PSAwIHx8IHByb3QuaW5kZXhPZignZGF0YTonKSA9PT0gMCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoYmFzZSAmJiAhb3JpZ2luSW5kZXBlbmRlbnRVcmwudGVzdChocmVmKSkge1xuICAgICAgaHJlZiA9IHJlc29sdmVVcmwoYmFzZSwgaHJlZik7XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIGhyZWYgPSBlbmNvZGVVUkkoaHJlZikucmVwbGFjZSgvJTI1L2csICclJyk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIGhyZWY7XG4gIH1cblxuICB2YXIgYmFzZVVybHMgPSB7fTtcbiAgdmFyIGp1c3REb21haW4gPSAvXlteOl0rOlxcLypbXi9dKiQvO1xuICB2YXIgcHJvdG9jb2wgPSAvXihbXjpdKzopW1xcc1xcU10qJC87XG4gIHZhciBkb21haW4gPSAvXihbXjpdKzpcXC8qW14vXSopW1xcc1xcU10qJC87XG5cbiAgZnVuY3Rpb24gcmVzb2x2ZVVybChiYXNlLCBocmVmKSB7XG4gICAgaWYgKCFiYXNlVXJsc1snICcgKyBiYXNlXSkge1xuICAgICAgLy8gd2UgY2FuIGlnbm9yZSBldmVyeXRoaW5nIGluIGJhc2UgYWZ0ZXIgdGhlIGxhc3Qgc2xhc2ggb2YgaXRzIHBhdGggY29tcG9uZW50LFxuICAgICAgLy8gYnV0IHdlIG1pZ2h0IG5lZWQgdG8gYWRkIF90aGF0X1xuICAgICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzM5ODYjc2VjdGlvbi0zXG4gICAgICBpZiAoanVzdERvbWFpbi50ZXN0KGJhc2UpKSB7XG4gICAgICAgIGJhc2VVcmxzWycgJyArIGJhc2VdID0gYmFzZSArICcvJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJhc2VVcmxzWycgJyArIGJhc2VdID0gcnRyaW0kMShiYXNlLCAnLycsIHRydWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGJhc2UgPSBiYXNlVXJsc1snICcgKyBiYXNlXTtcbiAgICB2YXIgcmVsYXRpdmVCYXNlID0gYmFzZS5pbmRleE9mKCc6JykgPT09IC0xO1xuXG4gICAgaWYgKGhyZWYuc3Vic3RyaW5nKDAsIDIpID09PSAnLy8nKSB7XG4gICAgICBpZiAocmVsYXRpdmVCYXNlKSB7XG4gICAgICAgIHJldHVybiBocmVmO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gYmFzZS5yZXBsYWNlKHByb3RvY29sLCAnJDEnKSArIGhyZWY7XG4gICAgfSBlbHNlIGlmIChocmVmLmNoYXJBdCgwKSA9PT0gJy8nKSB7XG4gICAgICBpZiAocmVsYXRpdmVCYXNlKSB7XG4gICAgICAgIHJldHVybiBocmVmO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gYmFzZS5yZXBsYWNlKGRvbWFpbiwgJyQxJykgKyBocmVmO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gYmFzZSArIGhyZWY7XG4gICAgfVxuICB9XG5cbiAgdmFyIG5vb3BUZXN0JDEgPSB7XG4gICAgZXhlYzogZnVuY3Rpb24gbm9vcFRlc3QoKSB7fVxuICB9O1xuXG4gIGZ1bmN0aW9uIG1lcmdlJDIob2JqKSB7XG4gICAgdmFyIGkgPSAxLFxuICAgICAgICB0YXJnZXQsXG4gICAgICAgIGtleTtcblxuICAgIGZvciAoOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0YXJnZXQgPSBhcmd1bWVudHNbaV07XG5cbiAgICAgIGZvciAoa2V5IGluIHRhcmdldCkge1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRhcmdldCwga2V5KSkge1xuICAgICAgICAgIG9ialtrZXldID0gdGFyZ2V0W2tleV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gb2JqO1xuICB9XG5cbiAgZnVuY3Rpb24gc3BsaXRDZWxscyQxKHRhYmxlUm93LCBjb3VudCkge1xuICAgIC8vIGVuc3VyZSB0aGF0IGV2ZXJ5IGNlbGwtZGVsaW1pdGluZyBwaXBlIGhhcyBhIHNwYWNlXG4gICAgLy8gYmVmb3JlIGl0IHRvIGRpc3Rpbmd1aXNoIGl0IGZyb20gYW4gZXNjYXBlZCBwaXBlXG4gICAgdmFyIHJvdyA9IHRhYmxlUm93LnJlcGxhY2UoL1xcfC9nLCBmdW5jdGlvbiAobWF0Y2gsIG9mZnNldCwgc3RyKSB7XG4gICAgICB2YXIgZXNjYXBlZCA9IGZhbHNlLFxuICAgICAgICAgIGN1cnIgPSBvZmZzZXQ7XG5cbiAgICAgIHdoaWxlICgtLWN1cnIgPj0gMCAmJiBzdHJbY3Vycl0gPT09ICdcXFxcJykge1xuICAgICAgICBlc2NhcGVkID0gIWVzY2FwZWQ7XG4gICAgICB9XG5cbiAgICAgIGlmIChlc2NhcGVkKSB7XG4gICAgICAgIC8vIG9kZCBudW1iZXIgb2Ygc2xhc2hlcyBtZWFucyB8IGlzIGVzY2FwZWRcbiAgICAgICAgLy8gc28gd2UgbGVhdmUgaXQgYWxvbmVcbiAgICAgICAgcmV0dXJuICd8JztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGFkZCBzcGFjZSBiZWZvcmUgdW5lc2NhcGVkIHxcbiAgICAgICAgcmV0dXJuICcgfCc7XG4gICAgICB9XG4gICAgfSksXG4gICAgICAgIGNlbGxzID0gcm93LnNwbGl0KC8gXFx8Lyk7XG4gICAgdmFyIGkgPSAwOyAvLyBGaXJzdC9sYXN0IGNlbGwgaW4gYSByb3cgY2Fubm90IGJlIGVtcHR5IGlmIGl0IGhhcyBubyBsZWFkaW5nL3RyYWlsaW5nIHBpcGVcblxuICAgIGlmICghY2VsbHNbMF0udHJpbSgpKSB7XG4gICAgICBjZWxscy5zaGlmdCgpO1xuICAgIH1cblxuICAgIGlmICghY2VsbHNbY2VsbHMubGVuZ3RoIC0gMV0udHJpbSgpKSB7XG4gICAgICBjZWxscy5wb3AoKTtcbiAgICB9XG5cbiAgICBpZiAoY2VsbHMubGVuZ3RoID4gY291bnQpIHtcbiAgICAgIGNlbGxzLnNwbGljZShjb3VudCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHdoaWxlIChjZWxscy5sZW5ndGggPCBjb3VudCkge1xuICAgICAgICBjZWxscy5wdXNoKCcnKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKDsgaSA8IGNlbGxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAvLyBsZWFkaW5nIG9yIHRyYWlsaW5nIHdoaXRlc3BhY2UgaXMgaWdub3JlZCBwZXIgdGhlIGdmbSBzcGVjXG4gICAgICBjZWxsc1tpXSA9IGNlbGxzW2ldLnRyaW0oKS5yZXBsYWNlKC9cXFxcXFx8L2csICd8Jyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNlbGxzO1xuICB9IC8vIFJlbW92ZSB0cmFpbGluZyAnYydzLiBFcXVpdmFsZW50IHRvIHN0ci5yZXBsYWNlKC9jKiQvLCAnJykuXG4gIC8vIC9jKiQvIGlzIHZ1bG5lcmFibGUgdG8gUkVET1MuXG4gIC8vIGludmVydDogUmVtb3ZlIHN1ZmZpeCBvZiBub24tYyBjaGFycyBpbnN0ZWFkLiBEZWZhdWx0IGZhbHNleS5cblxuXG4gIGZ1bmN0aW9uIHJ0cmltJDEoc3RyLCBjLCBpbnZlcnQpIHtcbiAgICB2YXIgbCA9IHN0ci5sZW5ndGg7XG5cbiAgICBpZiAobCA9PT0gMCkge1xuICAgICAgcmV0dXJuICcnO1xuICAgIH0gLy8gTGVuZ3RoIG9mIHN1ZmZpeCBtYXRjaGluZyB0aGUgaW52ZXJ0IGNvbmRpdGlvbi5cblxuXG4gICAgdmFyIHN1ZmZMZW4gPSAwOyAvLyBTdGVwIGxlZnQgdW50aWwgd2UgZmFpbCB0byBtYXRjaCB0aGUgaW52ZXJ0IGNvbmRpdGlvbi5cblxuICAgIHdoaWxlIChzdWZmTGVuIDwgbCkge1xuICAgICAgdmFyIGN1cnJDaGFyID0gc3RyLmNoYXJBdChsIC0gc3VmZkxlbiAtIDEpO1xuXG4gICAgICBpZiAoY3VyckNoYXIgPT09IGMgJiYgIWludmVydCkge1xuICAgICAgICBzdWZmTGVuKys7XG4gICAgICB9IGVsc2UgaWYgKGN1cnJDaGFyICE9PSBjICYmIGludmVydCkge1xuICAgICAgICBzdWZmTGVuKys7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gc3RyLnN1YnN0cigwLCBsIC0gc3VmZkxlbik7XG4gIH1cblxuICBmdW5jdGlvbiBmaW5kQ2xvc2luZ0JyYWNrZXQkMShzdHIsIGIpIHtcbiAgICBpZiAoc3RyLmluZGV4T2YoYlsxXSkgPT09IC0xKSB7XG4gICAgICByZXR1cm4gLTE7XG4gICAgfVxuXG4gICAgdmFyIGwgPSBzdHIubGVuZ3RoO1xuICAgIHZhciBsZXZlbCA9IDAsXG4gICAgICAgIGkgPSAwO1xuXG4gICAgZm9yICg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGlmIChzdHJbaV0gPT09ICdcXFxcJykge1xuICAgICAgICBpKys7XG4gICAgICB9IGVsc2UgaWYgKHN0cltpXSA9PT0gYlswXSkge1xuICAgICAgICBsZXZlbCsrO1xuICAgICAgfSBlbHNlIGlmIChzdHJbaV0gPT09IGJbMV0pIHtcbiAgICAgICAgbGV2ZWwtLTtcblxuICAgICAgICBpZiAobGV2ZWwgPCAwKSB7XG4gICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gLTE7XG4gIH1cblxuICBmdW5jdGlvbiBjaGVja1Nhbml0aXplRGVwcmVjYXRpb24kMShvcHQpIHtcbiAgICBpZiAob3B0ICYmIG9wdC5zYW5pdGl6ZSAmJiAhb3B0LnNpbGVudCkge1xuICAgICAgY29uc29sZS53YXJuKCdtYXJrZWQoKTogc2FuaXRpemUgYW5kIHNhbml0aXplciBwYXJhbWV0ZXJzIGFyZSBkZXByZWNhdGVkIHNpbmNlIHZlcnNpb24gMC43LjAsIHNob3VsZCBub3QgYmUgdXNlZCBhbmQgd2lsbCBiZSByZW1vdmVkIGluIHRoZSBmdXR1cmUuIFJlYWQgbW9yZSBoZXJlOiBodHRwczovL21hcmtlZC5qcy5vcmcvIy9VU0lOR19BRFZBTkNFRC5tZCNvcHRpb25zJyk7XG4gICAgfVxuICB9IC8vIGNvcGllZCBmcm9tIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS81NDUwMTEzLzgwNjc3N1xuXG5cbiAgZnVuY3Rpb24gcmVwZWF0U3RyaW5nJDEocGF0dGVybiwgY291bnQpIHtcbiAgICBpZiAoY291bnQgPCAxKSB7XG4gICAgICByZXR1cm4gJyc7XG4gICAgfVxuXG4gICAgdmFyIHJlc3VsdCA9ICcnO1xuXG4gICAgd2hpbGUgKGNvdW50ID4gMSkge1xuICAgICAgaWYgKGNvdW50ICYgMSkge1xuICAgICAgICByZXN1bHQgKz0gcGF0dGVybjtcbiAgICAgIH1cblxuICAgICAgY291bnQgPj49IDE7XG4gICAgICBwYXR0ZXJuICs9IHBhdHRlcm47XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdCArIHBhdHRlcm47XG4gIH1cblxuICB2YXIgaGVscGVycyA9IHtcbiAgICBlc2NhcGU6IGVzY2FwZSQyLFxuICAgIHVuZXNjYXBlOiB1bmVzY2FwZSQxLFxuICAgIGVkaXQ6IGVkaXQkMSxcbiAgICBjbGVhblVybDogY2xlYW5VcmwkMSxcbiAgICByZXNvbHZlVXJsOiByZXNvbHZlVXJsLFxuICAgIG5vb3BUZXN0OiBub29wVGVzdCQxLFxuICAgIG1lcmdlOiBtZXJnZSQyLFxuICAgIHNwbGl0Q2VsbHM6IHNwbGl0Q2VsbHMkMSxcbiAgICBydHJpbTogcnRyaW0kMSxcbiAgICBmaW5kQ2xvc2luZ0JyYWNrZXQ6IGZpbmRDbG9zaW5nQnJhY2tldCQxLFxuICAgIGNoZWNrU2FuaXRpemVEZXByZWNhdGlvbjogY2hlY2tTYW5pdGl6ZURlcHJlY2F0aW9uJDEsXG4gICAgcmVwZWF0U3RyaW5nOiByZXBlYXRTdHJpbmckMVxuICB9O1xuXG4gIHZhciBkZWZhdWx0cyQ0ID0gZGVmYXVsdHMkNS5leHBvcnRzLmRlZmF1bHRzO1xuICB2YXIgcnRyaW0gPSBoZWxwZXJzLnJ0cmltLFxuICAgICAgc3BsaXRDZWxscyA9IGhlbHBlcnMuc3BsaXRDZWxscyxcbiAgICAgIF9lc2NhcGUgPSBoZWxwZXJzLmVzY2FwZSxcbiAgICAgIGZpbmRDbG9zaW5nQnJhY2tldCA9IGhlbHBlcnMuZmluZENsb3NpbmdCcmFja2V0O1xuXG4gIGZ1bmN0aW9uIG91dHB1dExpbmsoY2FwLCBsaW5rLCByYXcsIGxleGVyKSB7XG4gICAgdmFyIGhyZWYgPSBsaW5rLmhyZWY7XG4gICAgdmFyIHRpdGxlID0gbGluay50aXRsZSA/IF9lc2NhcGUobGluay50aXRsZSkgOiBudWxsO1xuICAgIHZhciB0ZXh0ID0gY2FwWzFdLnJlcGxhY2UoL1xcXFwoW1xcW1xcXV0pL2csICckMScpO1xuXG4gICAgaWYgKGNhcFswXS5jaGFyQXQoMCkgIT09ICchJykge1xuICAgICAgbGV4ZXIuc3RhdGUuaW5MaW5rID0gdHJ1ZTtcbiAgICAgIHZhciB0b2tlbiA9IHtcbiAgICAgICAgdHlwZTogJ2xpbmsnLFxuICAgICAgICByYXc6IHJhdyxcbiAgICAgICAgaHJlZjogaHJlZixcbiAgICAgICAgdGl0bGU6IHRpdGxlLFxuICAgICAgICB0ZXh0OiB0ZXh0LFxuICAgICAgICB0b2tlbnM6IGxleGVyLmlubGluZVRva2Vucyh0ZXh0LCBbXSlcbiAgICAgIH07XG4gICAgICBsZXhlci5zdGF0ZS5pbkxpbmsgPSBmYWxzZTtcbiAgICAgIHJldHVybiB0b2tlbjtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogJ2ltYWdlJyxcbiAgICAgICAgcmF3OiByYXcsXG4gICAgICAgIGhyZWY6IGhyZWYsXG4gICAgICAgIHRpdGxlOiB0aXRsZSxcbiAgICAgICAgdGV4dDogX2VzY2FwZSh0ZXh0KVxuICAgICAgfTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpbmRlbnRDb2RlQ29tcGVuc2F0aW9uKHJhdywgdGV4dCkge1xuICAgIHZhciBtYXRjaEluZGVudFRvQ29kZSA9IHJhdy5tYXRjaCgvXihcXHMrKSg/OmBgYCkvKTtcblxuICAgIGlmIChtYXRjaEluZGVudFRvQ29kZSA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHRleHQ7XG4gICAgfVxuXG4gICAgdmFyIGluZGVudFRvQ29kZSA9IG1hdGNoSW5kZW50VG9Db2RlWzFdO1xuICAgIHJldHVybiB0ZXh0LnNwbGl0KCdcXG4nKS5tYXAoZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgIHZhciBtYXRjaEluZGVudEluTm9kZSA9IG5vZGUubWF0Y2goL15cXHMrLyk7XG5cbiAgICAgIGlmIChtYXRjaEluZGVudEluTm9kZSA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgIH1cblxuICAgICAgdmFyIGluZGVudEluTm9kZSA9IG1hdGNoSW5kZW50SW5Ob2RlWzBdO1xuXG4gICAgICBpZiAoaW5kZW50SW5Ob2RlLmxlbmd0aCA+PSBpbmRlbnRUb0NvZGUubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBub2RlLnNsaWNlKGluZGVudFRvQ29kZS5sZW5ndGgpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbm9kZTtcbiAgICB9KS5qb2luKCdcXG4nKTtcbiAgfVxuICAvKipcbiAgICogVG9rZW5pemVyXG4gICAqL1xuXG5cbiAgdmFyIFRva2VuaXplcl8xID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBUb2tlbml6ZXIob3B0aW9ucykge1xuICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucyB8fCBkZWZhdWx0cyQ0O1xuICAgIH1cblxuICAgIHZhciBfcHJvdG8gPSBUb2tlbml6ZXIucHJvdG90eXBlO1xuXG4gICAgX3Byb3RvLnNwYWNlID0gZnVuY3Rpb24gc3BhY2Uoc3JjKSB7XG4gICAgICB2YXIgY2FwID0gdGhpcy5ydWxlcy5ibG9jay5uZXdsaW5lLmV4ZWMoc3JjKTtcblxuICAgICAgaWYgKGNhcCkge1xuICAgICAgICBpZiAoY2FwWzBdLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogJ3NwYWNlJyxcbiAgICAgICAgICAgIHJhdzogY2FwWzBdXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgcmF3OiAnXFxuJ1xuICAgICAgICB9O1xuICAgICAgfVxuICAgIH07XG5cbiAgICBfcHJvdG8uY29kZSA9IGZ1bmN0aW9uIGNvZGUoc3JjKSB7XG4gICAgICB2YXIgY2FwID0gdGhpcy5ydWxlcy5ibG9jay5jb2RlLmV4ZWMoc3JjKTtcblxuICAgICAgaWYgKGNhcCkge1xuICAgICAgICB2YXIgdGV4dCA9IGNhcFswXS5yZXBsYWNlKC9eIHsxLDR9L2dtLCAnJyk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdHlwZTogJ2NvZGUnLFxuICAgICAgICAgIHJhdzogY2FwWzBdLFxuICAgICAgICAgIGNvZGVCbG9ja1N0eWxlOiAnaW5kZW50ZWQnLFxuICAgICAgICAgIHRleHQ6ICF0aGlzLm9wdGlvbnMucGVkYW50aWMgPyBydHJpbSh0ZXh0LCAnXFxuJykgOiB0ZXh0XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfTtcblxuICAgIF9wcm90by5mZW5jZXMgPSBmdW5jdGlvbiBmZW5jZXMoc3JjKSB7XG4gICAgICB2YXIgY2FwID0gdGhpcy5ydWxlcy5ibG9jay5mZW5jZXMuZXhlYyhzcmMpO1xuXG4gICAgICBpZiAoY2FwKSB7XG4gICAgICAgIHZhciByYXcgPSBjYXBbMF07XG4gICAgICAgIHZhciB0ZXh0ID0gaW5kZW50Q29kZUNvbXBlbnNhdGlvbihyYXcsIGNhcFszXSB8fCAnJyk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdHlwZTogJ2NvZGUnLFxuICAgICAgICAgIHJhdzogcmF3LFxuICAgICAgICAgIGxhbmc6IGNhcFsyXSA/IGNhcFsyXS50cmltKCkgOiBjYXBbMl0sXG4gICAgICAgICAgdGV4dDogdGV4dFxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH07XG5cbiAgICBfcHJvdG8uaGVhZGluZyA9IGZ1bmN0aW9uIGhlYWRpbmcoc3JjKSB7XG4gICAgICB2YXIgY2FwID0gdGhpcy5ydWxlcy5ibG9jay5oZWFkaW5nLmV4ZWMoc3JjKTtcblxuICAgICAgaWYgKGNhcCkge1xuICAgICAgICB2YXIgdGV4dCA9IGNhcFsyXS50cmltKCk7IC8vIHJlbW92ZSB0cmFpbGluZyAjc1xuXG4gICAgICAgIGlmICgvIyQvLnRlc3QodGV4dCkpIHtcbiAgICAgICAgICB2YXIgdHJpbW1lZCA9IHJ0cmltKHRleHQsICcjJyk7XG5cbiAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLnBlZGFudGljKSB7XG4gICAgICAgICAgICB0ZXh0ID0gdHJpbW1lZC50cmltKCk7XG4gICAgICAgICAgfSBlbHNlIGlmICghdHJpbW1lZCB8fCAvICQvLnRlc3QodHJpbW1lZCkpIHtcbiAgICAgICAgICAgIC8vIENvbW1vbk1hcmsgcmVxdWlyZXMgc3BhY2UgYmVmb3JlIHRyYWlsaW5nICNzXG4gICAgICAgICAgICB0ZXh0ID0gdHJpbW1lZC50cmltKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHRva2VuID0ge1xuICAgICAgICAgIHR5cGU6ICdoZWFkaW5nJyxcbiAgICAgICAgICByYXc6IGNhcFswXSxcbiAgICAgICAgICBkZXB0aDogY2FwWzFdLmxlbmd0aCxcbiAgICAgICAgICB0ZXh0OiB0ZXh0LFxuICAgICAgICAgIHRva2VuczogW11cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5sZXhlci5pbmxpbmUodG9rZW4udGV4dCwgdG9rZW4udG9rZW5zKTtcbiAgICAgICAgcmV0dXJuIHRva2VuO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBfcHJvdG8uaHIgPSBmdW5jdGlvbiBocihzcmMpIHtcbiAgICAgIHZhciBjYXAgPSB0aGlzLnJ1bGVzLmJsb2NrLmhyLmV4ZWMoc3JjKTtcblxuICAgICAgaWYgKGNhcCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHR5cGU6ICdocicsXG4gICAgICAgICAgcmF3OiBjYXBbMF1cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgX3Byb3RvLmJsb2NrcXVvdGUgPSBmdW5jdGlvbiBibG9ja3F1b3RlKHNyYykge1xuICAgICAgdmFyIGNhcCA9IHRoaXMucnVsZXMuYmxvY2suYmxvY2txdW90ZS5leGVjKHNyYyk7XG5cbiAgICAgIGlmIChjYXApIHtcbiAgICAgICAgdmFyIHRleHQgPSBjYXBbMF0ucmVwbGFjZSgvXiAqPiA/L2dtLCAnJyk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdHlwZTogJ2Jsb2NrcXVvdGUnLFxuICAgICAgICAgIHJhdzogY2FwWzBdLFxuICAgICAgICAgIHRva2VuczogdGhpcy5sZXhlci5ibG9ja1Rva2Vucyh0ZXh0LCBbXSksXG4gICAgICAgICAgdGV4dDogdGV4dFxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH07XG5cbiAgICBfcHJvdG8ubGlzdCA9IGZ1bmN0aW9uIGxpc3Qoc3JjKSB7XG4gICAgICB2YXIgY2FwID0gdGhpcy5ydWxlcy5ibG9jay5saXN0LmV4ZWMoc3JjKTtcblxuICAgICAgaWYgKGNhcCkge1xuICAgICAgICB2YXIgcmF3LCBpc3Rhc2ssIGlzY2hlY2tlZCwgaW5kZW50LCBpLCBibGFua0xpbmUsIGVuZHNXaXRoQmxhbmtMaW5lLCBsaW5lLCBsaW5lcywgaXRlbUNvbnRlbnRzO1xuICAgICAgICB2YXIgYnVsbCA9IGNhcFsxXS50cmltKCk7XG4gICAgICAgIHZhciBpc29yZGVyZWQgPSBidWxsLmxlbmd0aCA+IDE7XG4gICAgICAgIHZhciBsaXN0ID0ge1xuICAgICAgICAgIHR5cGU6ICdsaXN0JyxcbiAgICAgICAgICByYXc6ICcnLFxuICAgICAgICAgIG9yZGVyZWQ6IGlzb3JkZXJlZCxcbiAgICAgICAgICBzdGFydDogaXNvcmRlcmVkID8gK2J1bGwuc2xpY2UoMCwgLTEpIDogJycsXG4gICAgICAgICAgbG9vc2U6IGZhbHNlLFxuICAgICAgICAgIGl0ZW1zOiBbXVxuICAgICAgICB9O1xuICAgICAgICBidWxsID0gaXNvcmRlcmVkID8gXCJcXFxcZHsxLDl9XFxcXFwiICsgYnVsbC5zbGljZSgtMSkgOiBcIlxcXFxcIiArIGJ1bGw7XG5cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5wZWRhbnRpYykge1xuICAgICAgICAgIGJ1bGwgPSBpc29yZGVyZWQgPyBidWxsIDogJ1sqKy1dJztcbiAgICAgICAgfSAvLyBHZXQgbmV4dCBsaXN0IGl0ZW1cblxuXG4gICAgICAgIHZhciBpdGVtUmVnZXggPSBuZXcgUmVnRXhwKFwiXiggezAsM31cIiArIGJ1bGwgKyBcIikoKD86IFteXFxcXG5dKnwgKikoPzpcXFxcblteXFxcXG5dKikqKD86XFxcXG58JCkpXCIpOyAvLyBHZXQgZWFjaCB0b3AtbGV2ZWwgaXRlbVxuXG4gICAgICAgIHdoaWxlIChzcmMpIHtcbiAgICAgICAgICBpZiAodGhpcy5ydWxlcy5ibG9jay5oci50ZXN0KHNyYykpIHtcbiAgICAgICAgICAgIC8vIEVuZCBsaXN0IGlmIHdlIGVuY291bnRlciBhbiBIUiAocG9zc2libHkgbW92ZSBpbnRvIGl0ZW1SZWdleD8pXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoIShjYXAgPSBpdGVtUmVnZXguZXhlYyhzcmMpKSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbGluZXMgPSBjYXBbMl0uc3BsaXQoJ1xcbicpO1xuXG4gICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5wZWRhbnRpYykge1xuICAgICAgICAgICAgaW5kZW50ID0gMjtcbiAgICAgICAgICAgIGl0ZW1Db250ZW50cyA9IGxpbmVzWzBdLnRyaW1MZWZ0KCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGluZGVudCA9IGNhcFsyXS5zZWFyY2goL1teIF0vKTsgLy8gRmluZCBmaXJzdCBub24tc3BhY2UgY2hhclxuXG4gICAgICAgICAgICBpbmRlbnQgPSBjYXBbMV0ubGVuZ3RoICsgKGluZGVudCA+IDQgPyAxIDogaW5kZW50KTsgLy8gaW50ZW50ZWQgY29kZSBibG9ja3MgYWZ0ZXIgNCBzcGFjZXM7IGluZGVudCBpcyBhbHdheXMgMVxuXG4gICAgICAgICAgICBpdGVtQ29udGVudHMgPSBsaW5lc1swXS5zbGljZShpbmRlbnQgLSBjYXBbMV0ubGVuZ3RoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBibGFua0xpbmUgPSBmYWxzZTtcbiAgICAgICAgICByYXcgPSBjYXBbMF07XG5cbiAgICAgICAgICBpZiAoIWxpbmVzWzBdICYmIC9eICokLy50ZXN0KGxpbmVzWzFdKSkge1xuICAgICAgICAgICAgLy8gaXRlbXMgYmVnaW4gd2l0aCBhdCBtb3N0IG9uZSBibGFuayBsaW5lXG4gICAgICAgICAgICByYXcgPSBjYXBbMV0gKyBsaW5lcy5zbGljZSgwLCAyKS5qb2luKCdcXG4nKSArICdcXG4nO1xuICAgICAgICAgICAgbGlzdC5sb29zZSA9IHRydWU7XG4gICAgICAgICAgICBsaW5lcyA9IFtdO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBuZXh0QnVsbGV0UmVnZXggPSBuZXcgUmVnRXhwKFwiXiB7MCxcIiArIE1hdGgubWluKDMsIGluZGVudCAtIDEpICsgXCJ9KD86WyorLV18XFxcXGR7MSw5fVsuKV0pXCIpO1xuXG4gICAgICAgICAgZm9yIChpID0gMTsgaSA8IGxpbmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsaW5lID0gbGluZXNbaV07XG5cbiAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMucGVkYW50aWMpIHtcbiAgICAgICAgICAgICAgLy8gUmUtYWxpZ24gdG8gZm9sbG93IGNvbW1vbm1hcmsgbmVzdGluZyBydWxlc1xuICAgICAgICAgICAgICBsaW5lID0gbGluZS5yZXBsYWNlKC9eIHsxLDR9KD89KCB7NH0pKlteIF0pL2csICcgICcpO1xuICAgICAgICAgICAgfSAvLyBFbmQgbGlzdCBpdGVtIGlmIGZvdW5kIHN0YXJ0IG9mIG5ldyBidWxsZXRcblxuXG4gICAgICAgICAgICBpZiAobmV4dEJ1bGxldFJlZ2V4LnRlc3QobGluZSkpIHtcbiAgICAgICAgICAgICAgcmF3ID0gY2FwWzFdICsgbGluZXMuc2xpY2UoMCwgaSkuam9pbignXFxuJykgKyAnXFxuJztcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9IC8vIFVudGlsIHdlIGVuY291bnRlciBhIGJsYW5rIGxpbmUsIGl0ZW0gY29udGVudHMgZG8gbm90IG5lZWQgaW5kZW50YXRpb25cblxuXG4gICAgICAgICAgICBpZiAoIWJsYW5rTGluZSkge1xuICAgICAgICAgICAgICBpZiAoIWxpbmUudHJpbSgpKSB7XG4gICAgICAgICAgICAgICAgLy8gQ2hlY2sgaWYgY3VycmVudCBsaW5lIGlzIGVtcHR5XG4gICAgICAgICAgICAgICAgYmxhbmtMaW5lID0gdHJ1ZTtcbiAgICAgICAgICAgICAgfSAvLyBEZWRlbnQgaWYgcG9zc2libGVcblxuXG4gICAgICAgICAgICAgIGlmIChsaW5lLnNlYXJjaCgvW14gXS8pID49IGluZGVudCkge1xuICAgICAgICAgICAgICAgIGl0ZW1Db250ZW50cyArPSAnXFxuJyArIGxpbmUuc2xpY2UoaW5kZW50KTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpdGVtQ29udGVudHMgKz0gJ1xcbicgKyBsaW5lO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9IC8vIERlZGVudCB0aGlzIGxpbmVcblxuXG4gICAgICAgICAgICBpZiAobGluZS5zZWFyY2goL1teIF0vKSA+PSBpbmRlbnQgfHwgIWxpbmUudHJpbSgpKSB7XG4gICAgICAgICAgICAgIGl0ZW1Db250ZW50cyArPSAnXFxuJyArIGxpbmUuc2xpY2UoaW5kZW50KTtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyBMaW5lIHdhcyBub3QgcHJvcGVybHkgaW5kZW50ZWQ7IGVuZCBvZiB0aGlzIGl0ZW1cbiAgICAgICAgICAgICAgcmF3ID0gY2FwWzFdICsgbGluZXMuc2xpY2UoMCwgaSkuam9pbignXFxuJykgKyAnXFxuJztcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKCFsaXN0Lmxvb3NlKSB7XG4gICAgICAgICAgICAvLyBJZiB0aGUgcHJldmlvdXMgaXRlbSBlbmRlZCB3aXRoIGEgYmxhbmsgbGluZSwgdGhlIGxpc3QgaXMgbG9vc2VcbiAgICAgICAgICAgIGlmIChlbmRzV2l0aEJsYW5rTGluZSkge1xuICAgICAgICAgICAgICBsaXN0Lmxvb3NlID0gdHJ1ZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoL1xcbiAqXFxuICokLy50ZXN0KHJhdykpIHtcbiAgICAgICAgICAgICAgZW5kc1dpdGhCbGFua0xpbmUgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gLy8gQ2hlY2sgZm9yIHRhc2sgbGlzdCBpdGVtc1xuXG5cbiAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLmdmbSkge1xuICAgICAgICAgICAgaXN0YXNrID0gL15cXFtbIHhYXVxcXSAvLmV4ZWMoaXRlbUNvbnRlbnRzKTtcblxuICAgICAgICAgICAgaWYgKGlzdGFzaykge1xuICAgICAgICAgICAgICBpc2NoZWNrZWQgPSBpc3Rhc2tbMF0gIT09ICdbIF0gJztcbiAgICAgICAgICAgICAgaXRlbUNvbnRlbnRzID0gaXRlbUNvbnRlbnRzLnJlcGxhY2UoL15cXFtbIHhYXVxcXSArLywgJycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGxpc3QuaXRlbXMucHVzaCh7XG4gICAgICAgICAgICB0eXBlOiAnbGlzdF9pdGVtJyxcbiAgICAgICAgICAgIHJhdzogcmF3LFxuICAgICAgICAgICAgdGFzazogISFpc3Rhc2ssXG4gICAgICAgICAgICBjaGVja2VkOiBpc2NoZWNrZWQsXG4gICAgICAgICAgICBsb29zZTogZmFsc2UsXG4gICAgICAgICAgICB0ZXh0OiBpdGVtQ29udGVudHNcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBsaXN0LnJhdyArPSByYXc7XG4gICAgICAgICAgc3JjID0gc3JjLnNsaWNlKHJhdy5sZW5ndGgpO1xuICAgICAgICB9IC8vIERvIG5vdCBjb25zdW1lIG5ld2xpbmVzIGF0IGVuZCBvZiBmaW5hbCBpdGVtLiBBbHRlcm5hdGl2ZWx5LCBtYWtlIGl0ZW1SZWdleCAqc3RhcnQqIHdpdGggYW55IG5ld2xpbmVzIHRvIHNpbXBsaWZ5L3NwZWVkIHVwIGVuZHNXaXRoQmxhbmtMaW5lIGxvZ2ljXG5cblxuICAgICAgICBsaXN0Lml0ZW1zW2xpc3QuaXRlbXMubGVuZ3RoIC0gMV0ucmF3ID0gcmF3LnRyaW1SaWdodCgpO1xuICAgICAgICBsaXN0Lml0ZW1zW2xpc3QuaXRlbXMubGVuZ3RoIC0gMV0udGV4dCA9IGl0ZW1Db250ZW50cy50cmltUmlnaHQoKTtcbiAgICAgICAgbGlzdC5yYXcgPSBsaXN0LnJhdy50cmltUmlnaHQoKTtcbiAgICAgICAgdmFyIGwgPSBsaXN0Lml0ZW1zLmxlbmd0aDsgLy8gSXRlbSBjaGlsZCB0b2tlbnMgaGFuZGxlZCBoZXJlIGF0IGVuZCBiZWNhdXNlIHdlIG5lZWRlZCB0byBoYXZlIHRoZSBmaW5hbCBpdGVtIHRvIHRyaW0gaXQgZmlyc3RcblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgdGhpcy5sZXhlci5zdGF0ZS50b3AgPSBmYWxzZTtcbiAgICAgICAgICBsaXN0Lml0ZW1zW2ldLnRva2VucyA9IHRoaXMubGV4ZXIuYmxvY2tUb2tlbnMobGlzdC5pdGVtc1tpXS50ZXh0LCBbXSk7XG5cbiAgICAgICAgICBpZiAobGlzdC5pdGVtc1tpXS50b2tlbnMuc29tZShmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgcmV0dXJuIHQudHlwZSA9PT0gJ3NwYWNlJztcbiAgICAgICAgICB9KSkge1xuICAgICAgICAgICAgbGlzdC5sb29zZSA9IHRydWU7XG4gICAgICAgICAgICBsaXN0Lml0ZW1zW2ldLmxvb3NlID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbGlzdDtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgX3Byb3RvLmh0bWwgPSBmdW5jdGlvbiBodG1sKHNyYykge1xuICAgICAgdmFyIGNhcCA9IHRoaXMucnVsZXMuYmxvY2suaHRtbC5leGVjKHNyYyk7XG5cbiAgICAgIGlmIChjYXApIHtcbiAgICAgICAgdmFyIHRva2VuID0ge1xuICAgICAgICAgIHR5cGU6ICdodG1sJyxcbiAgICAgICAgICByYXc6IGNhcFswXSxcbiAgICAgICAgICBwcmU6ICF0aGlzLm9wdGlvbnMuc2FuaXRpemVyICYmIChjYXBbMV0gPT09ICdwcmUnIHx8IGNhcFsxXSA9PT0gJ3NjcmlwdCcgfHwgY2FwWzFdID09PSAnc3R5bGUnKSxcbiAgICAgICAgICB0ZXh0OiBjYXBbMF1cbiAgICAgICAgfTtcblxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnNhbml0aXplKSB7XG4gICAgICAgICAgdG9rZW4udHlwZSA9ICdwYXJhZ3JhcGgnO1xuICAgICAgICAgIHRva2VuLnRleHQgPSB0aGlzLm9wdGlvbnMuc2FuaXRpemVyID8gdGhpcy5vcHRpb25zLnNhbml0aXplcihjYXBbMF0pIDogX2VzY2FwZShjYXBbMF0pO1xuICAgICAgICAgIHRva2VuLnRva2VucyA9IFtdO1xuICAgICAgICAgIHRoaXMubGV4ZXIuaW5saW5lKHRva2VuLnRleHQsIHRva2VuLnRva2Vucyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdG9rZW47XG4gICAgICB9XG4gICAgfTtcblxuICAgIF9wcm90by5kZWYgPSBmdW5jdGlvbiBkZWYoc3JjKSB7XG4gICAgICB2YXIgY2FwID0gdGhpcy5ydWxlcy5ibG9jay5kZWYuZXhlYyhzcmMpO1xuXG4gICAgICBpZiAoY2FwKSB7XG4gICAgICAgIGlmIChjYXBbM10pIGNhcFszXSA9IGNhcFszXS5zdWJzdHJpbmcoMSwgY2FwWzNdLmxlbmd0aCAtIDEpO1xuICAgICAgICB2YXIgdGFnID0gY2FwWzFdLnRvTG93ZXJDYXNlKCkucmVwbGFjZSgvXFxzKy9nLCAnICcpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHR5cGU6ICdkZWYnLFxuICAgICAgICAgIHRhZzogdGFnLFxuICAgICAgICAgIHJhdzogY2FwWzBdLFxuICAgICAgICAgIGhyZWY6IGNhcFsyXSxcbiAgICAgICAgICB0aXRsZTogY2FwWzNdXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfTtcblxuICAgIF9wcm90by50YWJsZSA9IGZ1bmN0aW9uIHRhYmxlKHNyYykge1xuICAgICAgdmFyIGNhcCA9IHRoaXMucnVsZXMuYmxvY2sudGFibGUuZXhlYyhzcmMpO1xuXG4gICAgICBpZiAoY2FwKSB7XG4gICAgICAgIHZhciBpdGVtID0ge1xuICAgICAgICAgIHR5cGU6ICd0YWJsZScsXG4gICAgICAgICAgaGVhZGVyOiBzcGxpdENlbGxzKGNhcFsxXSkubWFwKGZ1bmN0aW9uIChjKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICB0ZXh0OiBjXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH0pLFxuICAgICAgICAgIGFsaWduOiBjYXBbMl0ucmVwbGFjZSgvXiAqfFxcfCAqJC9nLCAnJykuc3BsaXQoLyAqXFx8ICovKSxcbiAgICAgICAgICByb3dzOiBjYXBbM10gPyBjYXBbM10ucmVwbGFjZSgvXFxuJC8sICcnKS5zcGxpdCgnXFxuJykgOiBbXVxuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChpdGVtLmhlYWRlci5sZW5ndGggPT09IGl0ZW0uYWxpZ24ubGVuZ3RoKSB7XG4gICAgICAgICAgaXRlbS5yYXcgPSBjYXBbMF07XG4gICAgICAgICAgdmFyIGwgPSBpdGVtLmFsaWduLmxlbmd0aDtcbiAgICAgICAgICB2YXIgaSwgaiwgaywgcm93O1xuXG4gICAgICAgICAgZm9yIChpID0gMDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgaWYgKC9eICotKzogKiQvLnRlc3QoaXRlbS5hbGlnbltpXSkpIHtcbiAgICAgICAgICAgICAgaXRlbS5hbGlnbltpXSA9ICdyaWdodCc7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKC9eICo6LSs6ICokLy50ZXN0KGl0ZW0uYWxpZ25baV0pKSB7XG4gICAgICAgICAgICAgIGl0ZW0uYWxpZ25baV0gPSAnY2VudGVyJztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoL14gKjotKyAqJC8udGVzdChpdGVtLmFsaWduW2ldKSkge1xuICAgICAgICAgICAgICBpdGVtLmFsaWduW2ldID0gJ2xlZnQnO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgaXRlbS5hbGlnbltpXSA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbCA9IGl0ZW0ucm93cy5sZW5ndGg7XG5cbiAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICBpdGVtLnJvd3NbaV0gPSBzcGxpdENlbGxzKGl0ZW0ucm93c1tpXSwgaXRlbS5oZWFkZXIubGVuZ3RoKS5tYXAoZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0ZXh0OiBjXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IC8vIHBhcnNlIGNoaWxkIHRva2VucyBpbnNpZGUgaGVhZGVycyBhbmQgY2VsbHNcbiAgICAgICAgICAvLyBoZWFkZXIgY2hpbGQgdG9rZW5zXG5cblxuICAgICAgICAgIGwgPSBpdGVtLmhlYWRlci5sZW5ndGg7XG5cbiAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgbDsgaisrKSB7XG4gICAgICAgICAgICBpdGVtLmhlYWRlcltqXS50b2tlbnMgPSBbXTtcbiAgICAgICAgICAgIHRoaXMubGV4ZXIuaW5saW5lVG9rZW5zKGl0ZW0uaGVhZGVyW2pdLnRleHQsIGl0ZW0uaGVhZGVyW2pdLnRva2Vucyk7XG4gICAgICAgICAgfSAvLyBjZWxsIGNoaWxkIHRva2Vuc1xuXG5cbiAgICAgICAgICBsID0gaXRlbS5yb3dzLmxlbmd0aDtcblxuICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBsOyBqKyspIHtcbiAgICAgICAgICAgIHJvdyA9IGl0ZW0ucm93c1tqXTtcblxuICAgICAgICAgICAgZm9yIChrID0gMDsgayA8IHJvdy5sZW5ndGg7IGsrKykge1xuICAgICAgICAgICAgICByb3dba10udG9rZW5zID0gW107XG4gICAgICAgICAgICAgIHRoaXMubGV4ZXIuaW5saW5lVG9rZW5zKHJvd1trXS50ZXh0LCByb3dba10udG9rZW5zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gaXRlbTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICBfcHJvdG8ubGhlYWRpbmcgPSBmdW5jdGlvbiBsaGVhZGluZyhzcmMpIHtcbiAgICAgIHZhciBjYXAgPSB0aGlzLnJ1bGVzLmJsb2NrLmxoZWFkaW5nLmV4ZWMoc3JjKTtcblxuICAgICAgaWYgKGNhcCkge1xuICAgICAgICB2YXIgdG9rZW4gPSB7XG4gICAgICAgICAgdHlwZTogJ2hlYWRpbmcnLFxuICAgICAgICAgIHJhdzogY2FwWzBdLFxuICAgICAgICAgIGRlcHRoOiBjYXBbMl0uY2hhckF0KDApID09PSAnPScgPyAxIDogMixcbiAgICAgICAgICB0ZXh0OiBjYXBbMV0sXG4gICAgICAgICAgdG9rZW5zOiBbXVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmxleGVyLmlubGluZSh0b2tlbi50ZXh0LCB0b2tlbi50b2tlbnMpO1xuICAgICAgICByZXR1cm4gdG9rZW47XG4gICAgICB9XG4gICAgfTtcblxuICAgIF9wcm90by5wYXJhZ3JhcGggPSBmdW5jdGlvbiBwYXJhZ3JhcGgoc3JjKSB7XG4gICAgICB2YXIgY2FwID0gdGhpcy5ydWxlcy5ibG9jay5wYXJhZ3JhcGguZXhlYyhzcmMpO1xuXG4gICAgICBpZiAoY2FwKSB7XG4gICAgICAgIHZhciB0b2tlbiA9IHtcbiAgICAgICAgICB0eXBlOiAncGFyYWdyYXBoJyxcbiAgICAgICAgICByYXc6IGNhcFswXSxcbiAgICAgICAgICB0ZXh0OiBjYXBbMV0uY2hhckF0KGNhcFsxXS5sZW5ndGggLSAxKSA9PT0gJ1xcbicgPyBjYXBbMV0uc2xpY2UoMCwgLTEpIDogY2FwWzFdLFxuICAgICAgICAgIHRva2VuczogW11cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5sZXhlci5pbmxpbmUodG9rZW4udGV4dCwgdG9rZW4udG9rZW5zKTtcbiAgICAgICAgcmV0dXJuIHRva2VuO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBfcHJvdG8udGV4dCA9IGZ1bmN0aW9uIHRleHQoc3JjKSB7XG4gICAgICB2YXIgY2FwID0gdGhpcy5ydWxlcy5ibG9jay50ZXh0LmV4ZWMoc3JjKTtcblxuICAgICAgaWYgKGNhcCkge1xuICAgICAgICB2YXIgdG9rZW4gPSB7XG4gICAgICAgICAgdHlwZTogJ3RleHQnLFxuICAgICAgICAgIHJhdzogY2FwWzBdLFxuICAgICAgICAgIHRleHQ6IGNhcFswXSxcbiAgICAgICAgICB0b2tlbnM6IFtdXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMubGV4ZXIuaW5saW5lKHRva2VuLnRleHQsIHRva2VuLnRva2Vucyk7XG4gICAgICAgIHJldHVybiB0b2tlbjtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgX3Byb3RvLmVzY2FwZSA9IGZ1bmN0aW9uIGVzY2FwZShzcmMpIHtcbiAgICAgIHZhciBjYXAgPSB0aGlzLnJ1bGVzLmlubGluZS5lc2NhcGUuZXhlYyhzcmMpO1xuXG4gICAgICBpZiAoY2FwKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdHlwZTogJ2VzY2FwZScsXG4gICAgICAgICAgcmF3OiBjYXBbMF0sXG4gICAgICAgICAgdGV4dDogX2VzY2FwZShjYXBbMV0pXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfTtcblxuICAgIF9wcm90by50YWcgPSBmdW5jdGlvbiB0YWcoc3JjKSB7XG4gICAgICB2YXIgY2FwID0gdGhpcy5ydWxlcy5pbmxpbmUudGFnLmV4ZWMoc3JjKTtcblxuICAgICAgaWYgKGNhcCkge1xuICAgICAgICBpZiAoIXRoaXMubGV4ZXIuc3RhdGUuaW5MaW5rICYmIC9ePGEgL2kudGVzdChjYXBbMF0pKSB7XG4gICAgICAgICAgdGhpcy5sZXhlci5zdGF0ZS5pbkxpbmsgPSB0cnVlO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMubGV4ZXIuc3RhdGUuaW5MaW5rICYmIC9ePFxcL2E+L2kudGVzdChjYXBbMF0pKSB7XG4gICAgICAgICAgdGhpcy5sZXhlci5zdGF0ZS5pbkxpbmsgPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdGhpcy5sZXhlci5zdGF0ZS5pblJhd0Jsb2NrICYmIC9ePChwcmV8Y29kZXxrYmR8c2NyaXB0KShcXHN8PikvaS50ZXN0KGNhcFswXSkpIHtcbiAgICAgICAgICB0aGlzLmxleGVyLnN0YXRlLmluUmF3QmxvY2sgPSB0cnVlO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMubGV4ZXIuc3RhdGUuaW5SYXdCbG9jayAmJiAvXjxcXC8ocHJlfGNvZGV8a2JkfHNjcmlwdCkoXFxzfD4pL2kudGVzdChjYXBbMF0pKSB7XG4gICAgICAgICAgdGhpcy5sZXhlci5zdGF0ZS5pblJhd0Jsb2NrID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHR5cGU6IHRoaXMub3B0aW9ucy5zYW5pdGl6ZSA/ICd0ZXh0JyA6ICdodG1sJyxcbiAgICAgICAgICByYXc6IGNhcFswXSxcbiAgICAgICAgICBpbkxpbms6IHRoaXMubGV4ZXIuc3RhdGUuaW5MaW5rLFxuICAgICAgICAgIGluUmF3QmxvY2s6IHRoaXMubGV4ZXIuc3RhdGUuaW5SYXdCbG9jayxcbiAgICAgICAgICB0ZXh0OiB0aGlzLm9wdGlvbnMuc2FuaXRpemUgPyB0aGlzLm9wdGlvbnMuc2FuaXRpemVyID8gdGhpcy5vcHRpb25zLnNhbml0aXplcihjYXBbMF0pIDogX2VzY2FwZShjYXBbMF0pIDogY2FwWzBdXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfTtcblxuICAgIF9wcm90by5saW5rID0gZnVuY3Rpb24gbGluayhzcmMpIHtcbiAgICAgIHZhciBjYXAgPSB0aGlzLnJ1bGVzLmlubGluZS5saW5rLmV4ZWMoc3JjKTtcblxuICAgICAgaWYgKGNhcCkge1xuICAgICAgICB2YXIgdHJpbW1lZFVybCA9IGNhcFsyXS50cmltKCk7XG5cbiAgICAgICAgaWYgKCF0aGlzLm9wdGlvbnMucGVkYW50aWMgJiYgL148Ly50ZXN0KHRyaW1tZWRVcmwpKSB7XG4gICAgICAgICAgLy8gY29tbW9ubWFyayByZXF1aXJlcyBtYXRjaGluZyBhbmdsZSBicmFja2V0c1xuICAgICAgICAgIGlmICghLz4kLy50ZXN0KHRyaW1tZWRVcmwpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfSAvLyBlbmRpbmcgYW5nbGUgYnJhY2tldCBjYW5ub3QgYmUgZXNjYXBlZFxuXG5cbiAgICAgICAgICB2YXIgcnRyaW1TbGFzaCA9IHJ0cmltKHRyaW1tZWRVcmwuc2xpY2UoMCwgLTEpLCAnXFxcXCcpO1xuXG4gICAgICAgICAgaWYgKCh0cmltbWVkVXJsLmxlbmd0aCAtIHJ0cmltU2xhc2gubGVuZ3RoKSAlIDIgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gZmluZCBjbG9zaW5nIHBhcmVudGhlc2lzXG4gICAgICAgICAgdmFyIGxhc3RQYXJlbkluZGV4ID0gZmluZENsb3NpbmdCcmFja2V0KGNhcFsyXSwgJygpJyk7XG5cbiAgICAgICAgICBpZiAobGFzdFBhcmVuSW5kZXggPiAtMSkge1xuICAgICAgICAgICAgdmFyIHN0YXJ0ID0gY2FwWzBdLmluZGV4T2YoJyEnKSA9PT0gMCA/IDUgOiA0O1xuICAgICAgICAgICAgdmFyIGxpbmtMZW4gPSBzdGFydCArIGNhcFsxXS5sZW5ndGggKyBsYXN0UGFyZW5JbmRleDtcbiAgICAgICAgICAgIGNhcFsyXSA9IGNhcFsyXS5zdWJzdHJpbmcoMCwgbGFzdFBhcmVuSW5kZXgpO1xuICAgICAgICAgICAgY2FwWzBdID0gY2FwWzBdLnN1YnN0cmluZygwLCBsaW5rTGVuKS50cmltKCk7XG4gICAgICAgICAgICBjYXBbM10gPSAnJztcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaHJlZiA9IGNhcFsyXTtcbiAgICAgICAgdmFyIHRpdGxlID0gJyc7XG5cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5wZWRhbnRpYykge1xuICAgICAgICAgIC8vIHNwbGl0IHBlZGFudGljIGhyZWYgYW5kIHRpdGxlXG4gICAgICAgICAgdmFyIGxpbmsgPSAvXihbXidcIl0qW15cXHNdKVxccysoWydcIl0pKC4qKVxcMi8uZXhlYyhocmVmKTtcblxuICAgICAgICAgIGlmIChsaW5rKSB7XG4gICAgICAgICAgICBocmVmID0gbGlua1sxXTtcbiAgICAgICAgICAgIHRpdGxlID0gbGlua1szXTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGl0bGUgPSBjYXBbM10gPyBjYXBbM10uc2xpY2UoMSwgLTEpIDogJyc7XG4gICAgICAgIH1cblxuICAgICAgICBocmVmID0gaHJlZi50cmltKCk7XG5cbiAgICAgICAgaWYgKC9ePC8udGVzdChocmVmKSkge1xuICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMucGVkYW50aWMgJiYgIS8+JC8udGVzdCh0cmltbWVkVXJsKSkge1xuICAgICAgICAgICAgLy8gcGVkYW50aWMgYWxsb3dzIHN0YXJ0aW5nIGFuZ2xlIGJyYWNrZXQgd2l0aG91dCBlbmRpbmcgYW5nbGUgYnJhY2tldFxuICAgICAgICAgICAgaHJlZiA9IGhyZWYuc2xpY2UoMSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGhyZWYgPSBocmVmLnNsaWNlKDEsIC0xKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gb3V0cHV0TGluayhjYXAsIHtcbiAgICAgICAgICBocmVmOiBocmVmID8gaHJlZi5yZXBsYWNlKHRoaXMucnVsZXMuaW5saW5lLl9lc2NhcGVzLCAnJDEnKSA6IGhyZWYsXG4gICAgICAgICAgdGl0bGU6IHRpdGxlID8gdGl0bGUucmVwbGFjZSh0aGlzLnJ1bGVzLmlubGluZS5fZXNjYXBlcywgJyQxJykgOiB0aXRsZVxuICAgICAgICB9LCBjYXBbMF0sIHRoaXMubGV4ZXIpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBfcHJvdG8ucmVmbGluayA9IGZ1bmN0aW9uIHJlZmxpbmsoc3JjLCBsaW5rcykge1xuICAgICAgdmFyIGNhcDtcblxuICAgICAgaWYgKChjYXAgPSB0aGlzLnJ1bGVzLmlubGluZS5yZWZsaW5rLmV4ZWMoc3JjKSkgfHwgKGNhcCA9IHRoaXMucnVsZXMuaW5saW5lLm5vbGluay5leGVjKHNyYykpKSB7XG4gICAgICAgIHZhciBsaW5rID0gKGNhcFsyXSB8fCBjYXBbMV0pLnJlcGxhY2UoL1xccysvZywgJyAnKTtcbiAgICAgICAgbGluayA9IGxpbmtzW2xpbmsudG9Mb3dlckNhc2UoKV07XG5cbiAgICAgICAgaWYgKCFsaW5rIHx8ICFsaW5rLmhyZWYpIHtcbiAgICAgICAgICB2YXIgdGV4dCA9IGNhcFswXS5jaGFyQXQoMCk7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6ICd0ZXh0JyxcbiAgICAgICAgICAgIHJhdzogdGV4dCxcbiAgICAgICAgICAgIHRleHQ6IHRleHRcbiAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG91dHB1dExpbmsoY2FwLCBsaW5rLCBjYXBbMF0sIHRoaXMubGV4ZXIpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBfcHJvdG8uZW1TdHJvbmcgPSBmdW5jdGlvbiBlbVN0cm9uZyhzcmMsIG1hc2tlZFNyYywgcHJldkNoYXIpIHtcbiAgICAgIGlmIChwcmV2Q2hhciA9PT0gdm9pZCAwKSB7XG4gICAgICAgIHByZXZDaGFyID0gJyc7XG4gICAgICB9XG5cbiAgICAgIHZhciBtYXRjaCA9IHRoaXMucnVsZXMuaW5saW5lLmVtU3Ryb25nLmxEZWxpbS5leGVjKHNyYyk7XG4gICAgICBpZiAoIW1hdGNoKSByZXR1cm47IC8vIF8gY2FuJ3QgYmUgYmV0d2VlbiB0d28gYWxwaGFudW1lcmljcy4gXFxwe0x9XFxwe059IGluY2x1ZGVzIG5vbi1lbmdsaXNoIGFscGhhYmV0L251bWJlcnMgYXMgd2VsbFxuXG4gICAgICBpZiAobWF0Y2hbM10gJiYgcHJldkNoYXIubWF0Y2goLyg/OlswLTlBLVphLXpcXHhBQVxceEIyXFx4QjNcXHhCNVxceEI5XFx4QkFcXHhCQy1cXHhCRVxceEMwLVxceEQ2XFx4RDgtXFx4RjZcXHhGOC1cXHUwMkMxXFx1MDJDNi1cXHUwMkQxXFx1MDJFMC1cXHUwMkU0XFx1MDJFQ1xcdTAyRUVcXHUwMzcwLVxcdTAzNzRcXHUwMzc2XFx1MDM3N1xcdTAzN0EtXFx1MDM3RFxcdTAzN0ZcXHUwMzg2XFx1MDM4OC1cXHUwMzhBXFx1MDM4Q1xcdTAzOEUtXFx1MDNBMVxcdTAzQTMtXFx1MDNGNVxcdTAzRjctXFx1MDQ4MVxcdTA0OEEtXFx1MDUyRlxcdTA1MzEtXFx1MDU1NlxcdTA1NTlcXHUwNTYwLVxcdTA1ODhcXHUwNUQwLVxcdTA1RUFcXHUwNUVGLVxcdTA1RjJcXHUwNjIwLVxcdTA2NEFcXHUwNjYwLVxcdTA2NjlcXHUwNjZFXFx1MDY2RlxcdTA2NzEtXFx1MDZEM1xcdTA2RDVcXHUwNkU1XFx1MDZFNlxcdTA2RUUtXFx1MDZGQ1xcdTA2RkZcXHUwNzEwXFx1MDcxMi1cXHUwNzJGXFx1MDc0RC1cXHUwN0E1XFx1MDdCMVxcdTA3QzAtXFx1MDdFQVxcdTA3RjRcXHUwN0Y1XFx1MDdGQVxcdTA4MDAtXFx1MDgxNVxcdTA4MUFcXHUwODI0XFx1MDgyOFxcdTA4NDAtXFx1MDg1OFxcdTA4NjAtXFx1MDg2QVxcdTA4QTAtXFx1MDhCNFxcdTA4QjYtXFx1MDhDN1xcdTA5MDQtXFx1MDkzOVxcdTA5M0RcXHUwOTUwXFx1MDk1OC1cXHUwOTYxXFx1MDk2Ni1cXHUwOTZGXFx1MDk3MS1cXHUwOTgwXFx1MDk4NS1cXHUwOThDXFx1MDk4RlxcdTA5OTBcXHUwOTkzLVxcdTA5QThcXHUwOUFBLVxcdTA5QjBcXHUwOUIyXFx1MDlCNi1cXHUwOUI5XFx1MDlCRFxcdTA5Q0VcXHUwOURDXFx1MDlERFxcdTA5REYtXFx1MDlFMVxcdTA5RTYtXFx1MDlGMVxcdTA5RjQtXFx1MDlGOVxcdTA5RkNcXHUwQTA1LVxcdTBBMEFcXHUwQTBGXFx1MEExMFxcdTBBMTMtXFx1MEEyOFxcdTBBMkEtXFx1MEEzMFxcdTBBMzJcXHUwQTMzXFx1MEEzNVxcdTBBMzZcXHUwQTM4XFx1MEEzOVxcdTBBNTktXFx1MEE1Q1xcdTBBNUVcXHUwQTY2LVxcdTBBNkZcXHUwQTcyLVxcdTBBNzRcXHUwQTg1LVxcdTBBOERcXHUwQThGLVxcdTBBOTFcXHUwQTkzLVxcdTBBQThcXHUwQUFBLVxcdTBBQjBcXHUwQUIyXFx1MEFCM1xcdTBBQjUtXFx1MEFCOVxcdTBBQkRcXHUwQUQwXFx1MEFFMFxcdTBBRTFcXHUwQUU2LVxcdTBBRUZcXHUwQUY5XFx1MEIwNS1cXHUwQjBDXFx1MEIwRlxcdTBCMTBcXHUwQjEzLVxcdTBCMjhcXHUwQjJBLVxcdTBCMzBcXHUwQjMyXFx1MEIzM1xcdTBCMzUtXFx1MEIzOVxcdTBCM0RcXHUwQjVDXFx1MEI1RFxcdTBCNUYtXFx1MEI2MVxcdTBCNjYtXFx1MEI2RlxcdTBCNzEtXFx1MEI3N1xcdTBCODNcXHUwQjg1LVxcdTBCOEFcXHUwQjhFLVxcdTBCOTBcXHUwQjkyLVxcdTBCOTVcXHUwQjk5XFx1MEI5QVxcdTBCOUNcXHUwQjlFXFx1MEI5RlxcdTBCQTNcXHUwQkE0XFx1MEJBOC1cXHUwQkFBXFx1MEJBRS1cXHUwQkI5XFx1MEJEMFxcdTBCRTYtXFx1MEJGMlxcdTBDMDUtXFx1MEMwQ1xcdTBDMEUtXFx1MEMxMFxcdTBDMTItXFx1MEMyOFxcdTBDMkEtXFx1MEMzOVxcdTBDM0RcXHUwQzU4LVxcdTBDNUFcXHUwQzYwXFx1MEM2MVxcdTBDNjYtXFx1MEM2RlxcdTBDNzgtXFx1MEM3RVxcdTBDODBcXHUwQzg1LVxcdTBDOENcXHUwQzhFLVxcdTBDOTBcXHUwQzkyLVxcdTBDQThcXHUwQ0FBLVxcdTBDQjNcXHUwQ0I1LVxcdTBDQjlcXHUwQ0JEXFx1MENERVxcdTBDRTBcXHUwQ0UxXFx1MENFNi1cXHUwQ0VGXFx1MENGMVxcdTBDRjJcXHUwRDA0LVxcdTBEMENcXHUwRDBFLVxcdTBEMTBcXHUwRDEyLVxcdTBEM0FcXHUwRDNEXFx1MEQ0RVxcdTBENTQtXFx1MEQ1NlxcdTBENTgtXFx1MEQ2MVxcdTBENjYtXFx1MEQ3OFxcdTBEN0EtXFx1MEQ3RlxcdTBEODUtXFx1MEQ5NlxcdTBEOUEtXFx1MERCMVxcdTBEQjMtXFx1MERCQlxcdTBEQkRcXHUwREMwLVxcdTBEQzZcXHUwREU2LVxcdTBERUZcXHUwRTAxLVxcdTBFMzBcXHUwRTMyXFx1MEUzM1xcdTBFNDAtXFx1MEU0NlxcdTBFNTAtXFx1MEU1OVxcdTBFODFcXHUwRTgyXFx1MEU4NFxcdTBFODYtXFx1MEU4QVxcdTBFOEMtXFx1MEVBM1xcdTBFQTVcXHUwRUE3LVxcdTBFQjBcXHUwRUIyXFx1MEVCM1xcdTBFQkRcXHUwRUMwLVxcdTBFQzRcXHUwRUM2XFx1MEVEMC1cXHUwRUQ5XFx1MEVEQy1cXHUwRURGXFx1MEYwMFxcdTBGMjAtXFx1MEYzM1xcdTBGNDAtXFx1MEY0N1xcdTBGNDktXFx1MEY2Q1xcdTBGODgtXFx1MEY4Q1xcdTEwMDAtXFx1MTAyQVxcdTEwM0YtXFx1MTA0OVxcdTEwNTAtXFx1MTA1NVxcdTEwNUEtXFx1MTA1RFxcdTEwNjFcXHUxMDY1XFx1MTA2NlxcdTEwNkUtXFx1MTA3MFxcdTEwNzUtXFx1MTA4MVxcdTEwOEVcXHUxMDkwLVxcdTEwOTlcXHUxMEEwLVxcdTEwQzVcXHUxMEM3XFx1MTBDRFxcdTEwRDAtXFx1MTBGQVxcdTEwRkMtXFx1MTI0OFxcdTEyNEEtXFx1MTI0RFxcdTEyNTAtXFx1MTI1NlxcdTEyNThcXHUxMjVBLVxcdTEyNURcXHUxMjYwLVxcdTEyODhcXHUxMjhBLVxcdTEyOERcXHUxMjkwLVxcdTEyQjBcXHUxMkIyLVxcdTEyQjVcXHUxMkI4LVxcdTEyQkVcXHUxMkMwXFx1MTJDMi1cXHUxMkM1XFx1MTJDOC1cXHUxMkQ2XFx1MTJEOC1cXHUxMzEwXFx1MTMxMi1cXHUxMzE1XFx1MTMxOC1cXHUxMzVBXFx1MTM2OS1cXHUxMzdDXFx1MTM4MC1cXHUxMzhGXFx1MTNBMC1cXHUxM0Y1XFx1MTNGOC1cXHUxM0ZEXFx1MTQwMS1cXHUxNjZDXFx1MTY2Ri1cXHUxNjdGXFx1MTY4MS1cXHUxNjlBXFx1MTZBMC1cXHUxNkVBXFx1MTZFRS1cXHUxNkY4XFx1MTcwMC1cXHUxNzBDXFx1MTcwRS1cXHUxNzExXFx1MTcyMC1cXHUxNzMxXFx1MTc0MC1cXHUxNzUxXFx1MTc2MC1cXHUxNzZDXFx1MTc2RS1cXHUxNzcwXFx1MTc4MC1cXHUxN0IzXFx1MTdEN1xcdTE3RENcXHUxN0UwLVxcdTE3RTlcXHUxN0YwLVxcdTE3RjlcXHUxODEwLVxcdTE4MTlcXHUxODIwLVxcdTE4NzhcXHUxODgwLVxcdTE4ODRcXHUxODg3LVxcdTE4QThcXHUxOEFBXFx1MThCMC1cXHUxOEY1XFx1MTkwMC1cXHUxOTFFXFx1MTk0Ni1cXHUxOTZEXFx1MTk3MC1cXHUxOTc0XFx1MTk4MC1cXHUxOUFCXFx1MTlCMC1cXHUxOUM5XFx1MTlEMC1cXHUxOURBXFx1MUEwMC1cXHUxQTE2XFx1MUEyMC1cXHUxQTU0XFx1MUE4MC1cXHUxQTg5XFx1MUE5MC1cXHUxQTk5XFx1MUFBN1xcdTFCMDUtXFx1MUIzM1xcdTFCNDUtXFx1MUI0QlxcdTFCNTAtXFx1MUI1OVxcdTFCODMtXFx1MUJBMFxcdTFCQUUtXFx1MUJFNVxcdTFDMDAtXFx1MUMyM1xcdTFDNDAtXFx1MUM0OVxcdTFDNEQtXFx1MUM3RFxcdTFDODAtXFx1MUM4OFxcdTFDOTAtXFx1MUNCQVxcdTFDQkQtXFx1MUNCRlxcdTFDRTktXFx1MUNFQ1xcdTFDRUUtXFx1MUNGM1xcdTFDRjVcXHUxQ0Y2XFx1MUNGQVxcdTFEMDAtXFx1MURCRlxcdTFFMDAtXFx1MUYxNVxcdTFGMTgtXFx1MUYxRFxcdTFGMjAtXFx1MUY0NVxcdTFGNDgtXFx1MUY0RFxcdTFGNTAtXFx1MUY1N1xcdTFGNTlcXHUxRjVCXFx1MUY1RFxcdTFGNUYtXFx1MUY3RFxcdTFGODAtXFx1MUZCNFxcdTFGQjYtXFx1MUZCQ1xcdTFGQkVcXHUxRkMyLVxcdTFGQzRcXHUxRkM2LVxcdTFGQ0NcXHUxRkQwLVxcdTFGRDNcXHUxRkQ2LVxcdTFGREJcXHUxRkUwLVxcdTFGRUNcXHUxRkYyLVxcdTFGRjRcXHUxRkY2LVxcdTFGRkNcXHUyMDcwXFx1MjA3MVxcdTIwNzQtXFx1MjA3OVxcdTIwN0YtXFx1MjA4OVxcdTIwOTAtXFx1MjA5Q1xcdTIxMDJcXHUyMTA3XFx1MjEwQS1cXHUyMTEzXFx1MjExNVxcdTIxMTktXFx1MjExRFxcdTIxMjRcXHUyMTI2XFx1MjEyOFxcdTIxMkEtXFx1MjEyRFxcdTIxMkYtXFx1MjEzOVxcdTIxM0MtXFx1MjEzRlxcdTIxNDUtXFx1MjE0OVxcdTIxNEVcXHUyMTUwLVxcdTIxODlcXHUyNDYwLVxcdTI0OUJcXHUyNEVBLVxcdTI0RkZcXHUyNzc2LVxcdTI3OTNcXHUyQzAwLVxcdTJDMkVcXHUyQzMwLVxcdTJDNUVcXHUyQzYwLVxcdTJDRTRcXHUyQ0VCLVxcdTJDRUVcXHUyQ0YyXFx1MkNGM1xcdTJDRkRcXHUyRDAwLVxcdTJEMjVcXHUyRDI3XFx1MkQyRFxcdTJEMzAtXFx1MkQ2N1xcdTJENkZcXHUyRDgwLVxcdTJEOTZcXHUyREEwLVxcdTJEQTZcXHUyREE4LVxcdTJEQUVcXHUyREIwLVxcdTJEQjZcXHUyREI4LVxcdTJEQkVcXHUyREMwLVxcdTJEQzZcXHUyREM4LVxcdTJEQ0VcXHUyREQwLVxcdTJERDZcXHUyREQ4LVxcdTJEREVcXHUyRTJGXFx1MzAwNS1cXHUzMDA3XFx1MzAyMS1cXHUzMDI5XFx1MzAzMS1cXHUzMDM1XFx1MzAzOC1cXHUzMDNDXFx1MzA0MS1cXHUzMDk2XFx1MzA5RC1cXHUzMDlGXFx1MzBBMS1cXHUzMEZBXFx1MzBGQy1cXHUzMEZGXFx1MzEwNS1cXHUzMTJGXFx1MzEzMS1cXHUzMThFXFx1MzE5Mi1cXHUzMTk1XFx1MzFBMC1cXHUzMUJGXFx1MzFGMC1cXHUzMUZGXFx1MzIyMC1cXHUzMjI5XFx1MzI0OC1cXHUzMjRGXFx1MzI1MS1cXHUzMjVGXFx1MzI4MC1cXHUzMjg5XFx1MzJCMS1cXHUzMkJGXFx1MzQwMC1cXHU0REJGXFx1NEUwMC1cXHU5RkZDXFx1QTAwMC1cXHVBNDhDXFx1QTREMC1cXHVBNEZEXFx1QTUwMC1cXHVBNjBDXFx1QTYxMC1cXHVBNjJCXFx1QTY0MC1cXHVBNjZFXFx1QTY3Ri1cXHVBNjlEXFx1QTZBMC1cXHVBNkVGXFx1QTcxNy1cXHVBNzFGXFx1QTcyMi1cXHVBNzg4XFx1QTc4Qi1cXHVBN0JGXFx1QTdDMi1cXHVBN0NBXFx1QTdGNS1cXHVBODAxXFx1QTgwMy1cXHVBODA1XFx1QTgwNy1cXHVBODBBXFx1QTgwQy1cXHVBODIyXFx1QTgzMC1cXHVBODM1XFx1QTg0MC1cXHVBODczXFx1QTg4Mi1cXHVBOEIzXFx1QThEMC1cXHVBOEQ5XFx1QThGMi1cXHVBOEY3XFx1QThGQlxcdUE4RkRcXHVBOEZFXFx1QTkwMC1cXHVBOTI1XFx1QTkzMC1cXHVBOTQ2XFx1QTk2MC1cXHVBOTdDXFx1QTk4NC1cXHVBOUIyXFx1QTlDRi1cXHVBOUQ5XFx1QTlFMC1cXHVBOUU0XFx1QTlFNi1cXHVBOUZFXFx1QUEwMC1cXHVBQTI4XFx1QUE0MC1cXHVBQTQyXFx1QUE0NC1cXHVBQTRCXFx1QUE1MC1cXHVBQTU5XFx1QUE2MC1cXHVBQTc2XFx1QUE3QVxcdUFBN0UtXFx1QUFBRlxcdUFBQjFcXHVBQUI1XFx1QUFCNlxcdUFBQjktXFx1QUFCRFxcdUFBQzBcXHVBQUMyXFx1QUFEQi1cXHVBQUREXFx1QUFFMC1cXHVBQUVBXFx1QUFGMi1cXHVBQUY0XFx1QUIwMS1cXHVBQjA2XFx1QUIwOS1cXHVBQjBFXFx1QUIxMS1cXHVBQjE2XFx1QUIyMC1cXHVBQjI2XFx1QUIyOC1cXHVBQjJFXFx1QUIzMC1cXHVBQjVBXFx1QUI1Qy1cXHVBQjY5XFx1QUI3MC1cXHVBQkUyXFx1QUJGMC1cXHVBQkY5XFx1QUMwMC1cXHVEN0EzXFx1RDdCMC1cXHVEN0M2XFx1RDdDQi1cXHVEN0ZCXFx1RjkwMC1cXHVGQTZEXFx1RkE3MC1cXHVGQUQ5XFx1RkIwMC1cXHVGQjA2XFx1RkIxMy1cXHVGQjE3XFx1RkIxRFxcdUZCMUYtXFx1RkIyOFxcdUZCMkEtXFx1RkIzNlxcdUZCMzgtXFx1RkIzQ1xcdUZCM0VcXHVGQjQwXFx1RkI0MVxcdUZCNDNcXHVGQjQ0XFx1RkI0Ni1cXHVGQkIxXFx1RkJEMy1cXHVGRDNEXFx1RkQ1MC1cXHVGRDhGXFx1RkQ5Mi1cXHVGREM3XFx1RkRGMC1cXHVGREZCXFx1RkU3MC1cXHVGRTc0XFx1RkU3Ni1cXHVGRUZDXFx1RkYxMC1cXHVGRjE5XFx1RkYyMS1cXHVGRjNBXFx1RkY0MS1cXHVGRjVBXFx1RkY2Ni1cXHVGRkJFXFx1RkZDMi1cXHVGRkM3XFx1RkZDQS1cXHVGRkNGXFx1RkZEMi1cXHVGRkQ3XFx1RkZEQS1cXHVGRkRDXXxcXHVEODAwW1xcdURDMDAtXFx1REMwQlxcdURDMEQtXFx1REMyNlxcdURDMjgtXFx1REMzQVxcdURDM0NcXHVEQzNEXFx1REMzRi1cXHVEQzREXFx1REM1MC1cXHVEQzVEXFx1REM4MC1cXHVEQ0ZBXFx1REQwNy1cXHVERDMzXFx1REQ0MC1cXHVERDc4XFx1REQ4QVxcdUREOEJcXHVERTgwLVxcdURFOUNcXHVERUEwLVxcdURFRDBcXHVERUUxLVxcdURFRkJcXHVERjAwLVxcdURGMjNcXHVERjJELVxcdURGNEFcXHVERjUwLVxcdURGNzVcXHVERjgwLVxcdURGOURcXHVERkEwLVxcdURGQzNcXHVERkM4LVxcdURGQ0ZcXHVERkQxLVxcdURGRDVdfFxcdUQ4MDFbXFx1REMwMC1cXHVEQzlEXFx1RENBMC1cXHVEQ0E5XFx1RENCMC1cXHVEQ0QzXFx1RENEOC1cXHVEQ0ZCXFx1REQwMC1cXHVERDI3XFx1REQzMC1cXHVERDYzXFx1REUwMC1cXHVERjM2XFx1REY0MC1cXHVERjU1XFx1REY2MC1cXHVERjY3XXxcXHVEODAyW1xcdURDMDAtXFx1REMwNVxcdURDMDhcXHVEQzBBLVxcdURDMzVcXHVEQzM3XFx1REMzOFxcdURDM0NcXHVEQzNGLVxcdURDNTVcXHVEQzU4LVxcdURDNzZcXHVEQzc5LVxcdURDOUVcXHVEQ0E3LVxcdURDQUZcXHVEQ0UwLVxcdURDRjJcXHVEQ0Y0XFx1RENGNVxcdURDRkItXFx1REQxQlxcdUREMjAtXFx1REQzOVxcdUREODAtXFx1RERCN1xcdUREQkMtXFx1RERDRlxcdURERDItXFx1REUwMFxcdURFMTAtXFx1REUxM1xcdURFMTUtXFx1REUxN1xcdURFMTktXFx1REUzNVxcdURFNDAtXFx1REU0OFxcdURFNjAtXFx1REU3RVxcdURFODAtXFx1REU5RlxcdURFQzAtXFx1REVDN1xcdURFQzktXFx1REVFNFxcdURFRUItXFx1REVFRlxcdURGMDAtXFx1REYzNVxcdURGNDAtXFx1REY1NVxcdURGNTgtXFx1REY3MlxcdURGNzgtXFx1REY5MVxcdURGQTktXFx1REZBRl18XFx1RDgwM1tcXHVEQzAwLVxcdURDNDhcXHVEQzgwLVxcdURDQjJcXHVEQ0MwLVxcdURDRjJcXHVEQ0ZBLVxcdUREMjNcXHVERDMwLVxcdUREMzlcXHVERTYwLVxcdURFN0VcXHVERTgwLVxcdURFQTlcXHVERUIwXFx1REVCMVxcdURGMDAtXFx1REYyN1xcdURGMzAtXFx1REY0NVxcdURGNTEtXFx1REY1NFxcdURGQjAtXFx1REZDQlxcdURGRTAtXFx1REZGNl18XFx1RDgwNFtcXHVEQzAzLVxcdURDMzdcXHVEQzUyLVxcdURDNkZcXHVEQzgzLVxcdURDQUZcXHVEQ0QwLVxcdURDRThcXHVEQ0YwLVxcdURDRjlcXHVERDAzLVxcdUREMjZcXHVERDM2LVxcdUREM0ZcXHVERDQ0XFx1REQ0N1xcdURENTAtXFx1REQ3MlxcdURENzZcXHVERDgzLVxcdUREQjJcXHVEREMxLVxcdUREQzRcXHVEREQwLVxcdUREREFcXHVERERDXFx1RERFMS1cXHVEREY0XFx1REUwMC1cXHVERTExXFx1REUxMy1cXHVERTJCXFx1REU4MC1cXHVERTg2XFx1REU4OFxcdURFOEEtXFx1REU4RFxcdURFOEYtXFx1REU5RFxcdURFOUYtXFx1REVBOFxcdURFQjAtXFx1REVERVxcdURFRjAtXFx1REVGOVxcdURGMDUtXFx1REYwQ1xcdURGMEZcXHVERjEwXFx1REYxMy1cXHVERjI4XFx1REYyQS1cXHVERjMwXFx1REYzMlxcdURGMzNcXHVERjM1LVxcdURGMzlcXHVERjNEXFx1REY1MFxcdURGNUQtXFx1REY2MV18XFx1RDgwNVtcXHVEQzAwLVxcdURDMzRcXHVEQzQ3LVxcdURDNEFcXHVEQzUwLVxcdURDNTlcXHVEQzVGLVxcdURDNjFcXHVEQzgwLVxcdURDQUZcXHVEQ0M0XFx1RENDNVxcdURDQzdcXHVEQ0QwLVxcdURDRDlcXHVERDgwLVxcdUREQUVcXHVEREQ4LVxcdUREREJcXHVERTAwLVxcdURFMkZcXHVERTQ0XFx1REU1MC1cXHVERTU5XFx1REU4MC1cXHVERUFBXFx1REVCOFxcdURFQzAtXFx1REVDOVxcdURGMDAtXFx1REYxQVxcdURGMzAtXFx1REYzQl18XFx1RDgwNltcXHVEQzAwLVxcdURDMkJcXHVEQ0EwLVxcdURDRjJcXHVEQ0ZGLVxcdUREMDZcXHVERDA5XFx1REQwQy1cXHVERDEzXFx1REQxNVxcdUREMTZcXHVERDE4LVxcdUREMkZcXHVERDNGXFx1REQ0MVxcdURENTAtXFx1REQ1OVxcdUREQTAtXFx1RERBN1xcdUREQUEtXFx1REREMFxcdURERTFcXHVEREUzXFx1REUwMFxcdURFMEItXFx1REUzMlxcdURFM0FcXHVERTUwXFx1REU1Qy1cXHVERTg5XFx1REU5RFxcdURFQzAtXFx1REVGOF18XFx1RDgwN1tcXHVEQzAwLVxcdURDMDhcXHVEQzBBLVxcdURDMkVcXHVEQzQwXFx1REM1MC1cXHVEQzZDXFx1REM3Mi1cXHVEQzhGXFx1REQwMC1cXHVERDA2XFx1REQwOFxcdUREMDlcXHVERDBCLVxcdUREMzBcXHVERDQ2XFx1REQ1MC1cXHVERDU5XFx1REQ2MC1cXHVERDY1XFx1REQ2N1xcdURENjhcXHVERDZBLVxcdUREODlcXHVERDk4XFx1RERBMC1cXHVEREE5XFx1REVFMC1cXHVERUYyXFx1REZCMFxcdURGQzAtXFx1REZENF18XFx1RDgwOFtcXHVEQzAwLVxcdURGOTldfFxcdUQ4MDlbXFx1REMwMC1cXHVEQzZFXFx1REM4MC1cXHVERDQzXXxbXFx1RDgwQ1xcdUQ4MUMtXFx1RDgyMFxcdUQ4MjJcXHVEODQwLVxcdUQ4NjhcXHVEODZBLVxcdUQ4NkNcXHVEODZGLVxcdUQ4NzJcXHVEODc0LVxcdUQ4NzlcXHVEODgwLVxcdUQ4ODNdW1xcdURDMDAtXFx1REZGRl18XFx1RDgwRFtcXHVEQzAwLVxcdURDMkVdfFxcdUQ4MTFbXFx1REMwMC1cXHVERTQ2XXxcXHVEODFBW1xcdURDMDAtXFx1REUzOFxcdURFNDAtXFx1REU1RVxcdURFNjAtXFx1REU2OVxcdURFRDAtXFx1REVFRFxcdURGMDAtXFx1REYyRlxcdURGNDAtXFx1REY0M1xcdURGNTAtXFx1REY1OVxcdURGNUItXFx1REY2MVxcdURGNjMtXFx1REY3N1xcdURGN0QtXFx1REY4Rl18XFx1RDgxQltcXHVERTQwLVxcdURFOTZcXHVERjAwLVxcdURGNEFcXHVERjUwXFx1REY5My1cXHVERjlGXFx1REZFMFxcdURGRTFcXHVERkUzXXxcXHVEODIxW1xcdURDMDAtXFx1REZGN118XFx1RDgyM1tcXHVEQzAwLVxcdURDRDVcXHVERDAwLVxcdUREMDhdfFxcdUQ4MkNbXFx1REMwMC1cXHVERDFFXFx1REQ1MC1cXHVERDUyXFx1REQ2NC1cXHVERDY3XFx1REQ3MC1cXHVERUZCXXxcXHVEODJGW1xcdURDMDAtXFx1REM2QVxcdURDNzAtXFx1REM3Q1xcdURDODAtXFx1REM4OFxcdURDOTAtXFx1REM5OV18XFx1RDgzNFtcXHVERUUwLVxcdURFRjNcXHVERjYwLVxcdURGNzhdfFxcdUQ4MzVbXFx1REMwMC1cXHVEQzU0XFx1REM1Ni1cXHVEQzlDXFx1REM5RVxcdURDOUZcXHVEQ0EyXFx1RENBNVxcdURDQTZcXHVEQ0E5LVxcdURDQUNcXHVEQ0FFLVxcdURDQjlcXHVEQ0JCXFx1RENCRC1cXHVEQ0MzXFx1RENDNS1cXHVERDA1XFx1REQwNy1cXHVERDBBXFx1REQwRC1cXHVERDE0XFx1REQxNi1cXHVERDFDXFx1REQxRS1cXHVERDM5XFx1REQzQi1cXHVERDNFXFx1REQ0MC1cXHVERDQ0XFx1REQ0NlxcdURENEEtXFx1REQ1MFxcdURENTItXFx1REVBNVxcdURFQTgtXFx1REVDMFxcdURFQzItXFx1REVEQVxcdURFREMtXFx1REVGQVxcdURFRkMtXFx1REYxNFxcdURGMTYtXFx1REYzNFxcdURGMzYtXFx1REY0RVxcdURGNTAtXFx1REY2RVxcdURGNzAtXFx1REY4OFxcdURGOEEtXFx1REZBOFxcdURGQUEtXFx1REZDMlxcdURGQzQtXFx1REZDQlxcdURGQ0UtXFx1REZGRl18XFx1RDgzOFtcXHVERDAwLVxcdUREMkNcXHVERDM3LVxcdUREM0RcXHVERDQwLVxcdURENDlcXHVERDRFXFx1REVDMC1cXHVERUVCXFx1REVGMC1cXHVERUY5XXxcXHVEODNBW1xcdURDMDAtXFx1RENDNFxcdURDQzctXFx1RENDRlxcdUREMDAtXFx1REQ0M1xcdURENEJcXHVERDUwLVxcdURENTldfFxcdUQ4M0JbXFx1REM3MS1cXHVEQ0FCXFx1RENBRC1cXHVEQ0FGXFx1RENCMS1cXHVEQ0I0XFx1REQwMS1cXHVERDJEXFx1REQyRi1cXHVERDNEXFx1REUwMC1cXHVERTAzXFx1REUwNS1cXHVERTFGXFx1REUyMVxcdURFMjJcXHVERTI0XFx1REUyN1xcdURFMjktXFx1REUzMlxcdURFMzQtXFx1REUzN1xcdURFMzlcXHVERTNCXFx1REU0MlxcdURFNDdcXHVERTQ5XFx1REU0QlxcdURFNEQtXFx1REU0RlxcdURFNTFcXHVERTUyXFx1REU1NFxcdURFNTdcXHVERTU5XFx1REU1QlxcdURFNURcXHVERTVGXFx1REU2MVxcdURFNjJcXHVERTY0XFx1REU2Ny1cXHVERTZBXFx1REU2Qy1cXHVERTcyXFx1REU3NC1cXHVERTc3XFx1REU3OS1cXHVERTdDXFx1REU3RVxcdURFODAtXFx1REU4OVxcdURFOEItXFx1REU5QlxcdURFQTEtXFx1REVBM1xcdURFQTUtXFx1REVBOVxcdURFQUItXFx1REVCQl18XFx1RDgzQ1tcXHVERDAwLVxcdUREMENdfFxcdUQ4M0VbXFx1REZGMC1cXHVERkY5XXxcXHVEODY5W1xcdURDMDAtXFx1REVERFxcdURGMDAtXFx1REZGRl18XFx1RDg2RFtcXHVEQzAwLVxcdURGMzRcXHVERjQwLVxcdURGRkZdfFxcdUQ4NkVbXFx1REMwMC1cXHVEQzFEXFx1REMyMC1cXHVERkZGXXxcXHVEODczW1xcdURDMDAtXFx1REVBMVxcdURFQjAtXFx1REZGRl18XFx1RDg3QVtcXHVEQzAwLVxcdURGRTBdfFxcdUQ4N0VbXFx1REMwMC1cXHVERTFEXXxcXHVEODg0W1xcdURDMDAtXFx1REY0QV0pLykpIHJldHVybjtcbiAgICAgIHZhciBuZXh0Q2hhciA9IG1hdGNoWzFdIHx8IG1hdGNoWzJdIHx8ICcnO1xuXG4gICAgICBpZiAoIW5leHRDaGFyIHx8IG5leHRDaGFyICYmIChwcmV2Q2hhciA9PT0gJycgfHwgdGhpcy5ydWxlcy5pbmxpbmUucHVuY3R1YXRpb24uZXhlYyhwcmV2Q2hhcikpKSB7XG4gICAgICAgIHZhciBsTGVuZ3RoID0gbWF0Y2hbMF0ubGVuZ3RoIC0gMTtcbiAgICAgICAgdmFyIHJEZWxpbSxcbiAgICAgICAgICAgIHJMZW5ndGgsXG4gICAgICAgICAgICBkZWxpbVRvdGFsID0gbExlbmd0aCxcbiAgICAgICAgICAgIG1pZERlbGltVG90YWwgPSAwO1xuICAgICAgICB2YXIgZW5kUmVnID0gbWF0Y2hbMF1bMF0gPT09ICcqJyA/IHRoaXMucnVsZXMuaW5saW5lLmVtU3Ryb25nLnJEZWxpbUFzdCA6IHRoaXMucnVsZXMuaW5saW5lLmVtU3Ryb25nLnJEZWxpbVVuZDtcbiAgICAgICAgZW5kUmVnLmxhc3RJbmRleCA9IDA7IC8vIENsaXAgbWFza2VkU3JjIHRvIHNhbWUgc2VjdGlvbiBvZiBzdHJpbmcgYXMgc3JjIChtb3ZlIHRvIGxleGVyPylcblxuICAgICAgICBtYXNrZWRTcmMgPSBtYXNrZWRTcmMuc2xpY2UoLTEgKiBzcmMubGVuZ3RoICsgbExlbmd0aCk7XG5cbiAgICAgICAgd2hpbGUgKChtYXRjaCA9IGVuZFJlZy5leGVjKG1hc2tlZFNyYykpICE9IG51bGwpIHtcbiAgICAgICAgICByRGVsaW0gPSBtYXRjaFsxXSB8fCBtYXRjaFsyXSB8fCBtYXRjaFszXSB8fCBtYXRjaFs0XSB8fCBtYXRjaFs1XSB8fCBtYXRjaFs2XTtcbiAgICAgICAgICBpZiAoIXJEZWxpbSkgY29udGludWU7IC8vIHNraXAgc2luZ2xlICogaW4gX19hYmMqYWJjX19cblxuICAgICAgICAgIHJMZW5ndGggPSByRGVsaW0ubGVuZ3RoO1xuXG4gICAgICAgICAgaWYgKG1hdGNoWzNdIHx8IG1hdGNoWzRdKSB7XG4gICAgICAgICAgICAvLyBmb3VuZCBhbm90aGVyIExlZnQgRGVsaW1cbiAgICAgICAgICAgIGRlbGltVG90YWwgKz0gckxlbmd0aDtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH0gZWxzZSBpZiAobWF0Y2hbNV0gfHwgbWF0Y2hbNl0pIHtcbiAgICAgICAgICAgIC8vIGVpdGhlciBMZWZ0IG9yIFJpZ2h0IERlbGltXG4gICAgICAgICAgICBpZiAobExlbmd0aCAlIDMgJiYgISgobExlbmd0aCArIHJMZW5ndGgpICUgMykpIHtcbiAgICAgICAgICAgICAgbWlkRGVsaW1Ub3RhbCArPSByTGVuZ3RoO1xuICAgICAgICAgICAgICBjb250aW51ZTsgLy8gQ29tbW9uTWFyayBFbXBoYXNpcyBSdWxlcyA5LTEwXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZGVsaW1Ub3RhbCAtPSByTGVuZ3RoO1xuICAgICAgICAgIGlmIChkZWxpbVRvdGFsID4gMCkgY29udGludWU7IC8vIEhhdmVuJ3QgZm91bmQgZW5vdWdoIGNsb3NpbmcgZGVsaW1pdGVyc1xuICAgICAgICAgIC8vIFJlbW92ZSBleHRyYSBjaGFyYWN0ZXJzLiAqYSoqKiAtPiAqYSpcblxuICAgICAgICAgIHJMZW5ndGggPSBNYXRoLm1pbihyTGVuZ3RoLCByTGVuZ3RoICsgZGVsaW1Ub3RhbCArIG1pZERlbGltVG90YWwpOyAvLyBDcmVhdGUgYGVtYCBpZiBzbWFsbGVzdCBkZWxpbWl0ZXIgaGFzIG9kZCBjaGFyIGNvdW50LiAqYSoqKlxuXG4gICAgICAgICAgaWYgKE1hdGgubWluKGxMZW5ndGgsIHJMZW5ndGgpICUgMikge1xuICAgICAgICAgICAgdmFyIF90ZXh0ID0gc3JjLnNsaWNlKDEsIGxMZW5ndGggKyBtYXRjaC5pbmRleCArIHJMZW5ndGgpO1xuXG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICB0eXBlOiAnZW0nLFxuICAgICAgICAgICAgICByYXc6IHNyYy5zbGljZSgwLCBsTGVuZ3RoICsgbWF0Y2guaW5kZXggKyByTGVuZ3RoICsgMSksXG4gICAgICAgICAgICAgIHRleHQ6IF90ZXh0LFxuICAgICAgICAgICAgICB0b2tlbnM6IHRoaXMubGV4ZXIuaW5saW5lVG9rZW5zKF90ZXh0LCBbXSlcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfSAvLyBDcmVhdGUgJ3N0cm9uZycgaWYgc21hbGxlc3QgZGVsaW1pdGVyIGhhcyBldmVuIGNoYXIgY291bnQuICoqYSoqKlxuXG5cbiAgICAgICAgICB2YXIgdGV4dCA9IHNyYy5zbGljZSgyLCBsTGVuZ3RoICsgbWF0Y2guaW5kZXggKyByTGVuZ3RoIC0gMSk7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6ICdzdHJvbmcnLFxuICAgICAgICAgICAgcmF3OiBzcmMuc2xpY2UoMCwgbExlbmd0aCArIG1hdGNoLmluZGV4ICsgckxlbmd0aCArIDEpLFxuICAgICAgICAgICAgdGV4dDogdGV4dCxcbiAgICAgICAgICAgIHRva2VuczogdGhpcy5sZXhlci5pbmxpbmVUb2tlbnModGV4dCwgW10pXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICBfcHJvdG8uY29kZXNwYW4gPSBmdW5jdGlvbiBjb2Rlc3BhbihzcmMpIHtcbiAgICAgIHZhciBjYXAgPSB0aGlzLnJ1bGVzLmlubGluZS5jb2RlLmV4ZWMoc3JjKTtcblxuICAgICAgaWYgKGNhcCkge1xuICAgICAgICB2YXIgdGV4dCA9IGNhcFsyXS5yZXBsYWNlKC9cXG4vZywgJyAnKTtcbiAgICAgICAgdmFyIGhhc05vblNwYWNlQ2hhcnMgPSAvW14gXS8udGVzdCh0ZXh0KTtcbiAgICAgICAgdmFyIGhhc1NwYWNlQ2hhcnNPbkJvdGhFbmRzID0gL14gLy50ZXN0KHRleHQpICYmIC8gJC8udGVzdCh0ZXh0KTtcblxuICAgICAgICBpZiAoaGFzTm9uU3BhY2VDaGFycyAmJiBoYXNTcGFjZUNoYXJzT25Cb3RoRW5kcykge1xuICAgICAgICAgIHRleHQgPSB0ZXh0LnN1YnN0cmluZygxLCB0ZXh0Lmxlbmd0aCAtIDEpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGV4dCA9IF9lc2NhcGUodGV4dCwgdHJ1ZSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdHlwZTogJ2NvZGVzcGFuJyxcbiAgICAgICAgICByYXc6IGNhcFswXSxcbiAgICAgICAgICB0ZXh0OiB0ZXh0XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfTtcblxuICAgIF9wcm90by5iciA9IGZ1bmN0aW9uIGJyKHNyYykge1xuICAgICAgdmFyIGNhcCA9IHRoaXMucnVsZXMuaW5saW5lLmJyLmV4ZWMoc3JjKTtcblxuICAgICAgaWYgKGNhcCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHR5cGU6ICdicicsXG4gICAgICAgICAgcmF3OiBjYXBbMF1cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgX3Byb3RvLmRlbCA9IGZ1bmN0aW9uIGRlbChzcmMpIHtcbiAgICAgIHZhciBjYXAgPSB0aGlzLnJ1bGVzLmlubGluZS5kZWwuZXhlYyhzcmMpO1xuXG4gICAgICBpZiAoY2FwKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdHlwZTogJ2RlbCcsXG4gICAgICAgICAgcmF3OiBjYXBbMF0sXG4gICAgICAgICAgdGV4dDogY2FwWzJdLFxuICAgICAgICAgIHRva2VuczogdGhpcy5sZXhlci5pbmxpbmVUb2tlbnMoY2FwWzJdLCBbXSlcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgX3Byb3RvLmF1dG9saW5rID0gZnVuY3Rpb24gYXV0b2xpbmsoc3JjLCBtYW5nbGUpIHtcbiAgICAgIHZhciBjYXAgPSB0aGlzLnJ1bGVzLmlubGluZS5hdXRvbGluay5leGVjKHNyYyk7XG5cbiAgICAgIGlmIChjYXApIHtcbiAgICAgICAgdmFyIHRleHQsIGhyZWY7XG5cbiAgICAgICAgaWYgKGNhcFsyXSA9PT0gJ0AnKSB7XG4gICAgICAgICAgdGV4dCA9IF9lc2NhcGUodGhpcy5vcHRpb25zLm1hbmdsZSA/IG1hbmdsZShjYXBbMV0pIDogY2FwWzFdKTtcbiAgICAgICAgICBocmVmID0gJ21haWx0bzonICsgdGV4dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0ZXh0ID0gX2VzY2FwZShjYXBbMV0pO1xuICAgICAgICAgIGhyZWYgPSB0ZXh0O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0eXBlOiAnbGluaycsXG4gICAgICAgICAgcmF3OiBjYXBbMF0sXG4gICAgICAgICAgdGV4dDogdGV4dCxcbiAgICAgICAgICBocmVmOiBocmVmLFxuICAgICAgICAgIHRva2VuczogW3tcbiAgICAgICAgICAgIHR5cGU6ICd0ZXh0JyxcbiAgICAgICAgICAgIHJhdzogdGV4dCxcbiAgICAgICAgICAgIHRleHQ6IHRleHRcbiAgICAgICAgICB9XVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH07XG5cbiAgICBfcHJvdG8udXJsID0gZnVuY3Rpb24gdXJsKHNyYywgbWFuZ2xlKSB7XG4gICAgICB2YXIgY2FwO1xuXG4gICAgICBpZiAoY2FwID0gdGhpcy5ydWxlcy5pbmxpbmUudXJsLmV4ZWMoc3JjKSkge1xuICAgICAgICB2YXIgdGV4dCwgaHJlZjtcblxuICAgICAgICBpZiAoY2FwWzJdID09PSAnQCcpIHtcbiAgICAgICAgICB0ZXh0ID0gX2VzY2FwZSh0aGlzLm9wdGlvbnMubWFuZ2xlID8gbWFuZ2xlKGNhcFswXSkgOiBjYXBbMF0pO1xuICAgICAgICAgIGhyZWYgPSAnbWFpbHRvOicgKyB0ZXh0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIGRvIGV4dGVuZGVkIGF1dG9saW5rIHBhdGggdmFsaWRhdGlvblxuICAgICAgICAgIHZhciBwcmV2Q2FwWmVybztcblxuICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgIHByZXZDYXBaZXJvID0gY2FwWzBdO1xuICAgICAgICAgICAgY2FwWzBdID0gdGhpcy5ydWxlcy5pbmxpbmUuX2JhY2twZWRhbC5leGVjKGNhcFswXSlbMF07XG4gICAgICAgICAgfSB3aGlsZSAocHJldkNhcFplcm8gIT09IGNhcFswXSk7XG5cbiAgICAgICAgICB0ZXh0ID0gX2VzY2FwZShjYXBbMF0pO1xuXG4gICAgICAgICAgaWYgKGNhcFsxXSA9PT0gJ3d3dy4nKSB7XG4gICAgICAgICAgICBocmVmID0gJ2h0dHA6Ly8nICsgdGV4dDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaHJlZiA9IHRleHQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0eXBlOiAnbGluaycsXG4gICAgICAgICAgcmF3OiBjYXBbMF0sXG4gICAgICAgICAgdGV4dDogdGV4dCxcbiAgICAgICAgICBocmVmOiBocmVmLFxuICAgICAgICAgIHRva2VuczogW3tcbiAgICAgICAgICAgIHR5cGU6ICd0ZXh0JyxcbiAgICAgICAgICAgIHJhdzogdGV4dCxcbiAgICAgICAgICAgIHRleHQ6IHRleHRcbiAgICAgICAgICB9XVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH07XG5cbiAgICBfcHJvdG8uaW5saW5lVGV4dCA9IGZ1bmN0aW9uIGlubGluZVRleHQoc3JjLCBzbWFydHlwYW50cykge1xuICAgICAgdmFyIGNhcCA9IHRoaXMucnVsZXMuaW5saW5lLnRleHQuZXhlYyhzcmMpO1xuXG4gICAgICBpZiAoY2FwKSB7XG4gICAgICAgIHZhciB0ZXh0O1xuXG4gICAgICAgIGlmICh0aGlzLmxleGVyLnN0YXRlLmluUmF3QmxvY2spIHtcbiAgICAgICAgICB0ZXh0ID0gdGhpcy5vcHRpb25zLnNhbml0aXplID8gdGhpcy5vcHRpb25zLnNhbml0aXplciA/IHRoaXMub3B0aW9ucy5zYW5pdGl6ZXIoY2FwWzBdKSA6IF9lc2NhcGUoY2FwWzBdKSA6IGNhcFswXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0ZXh0ID0gX2VzY2FwZSh0aGlzLm9wdGlvbnMuc21hcnR5cGFudHMgPyBzbWFydHlwYW50cyhjYXBbMF0pIDogY2FwWzBdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdHlwZTogJ3RleHQnLFxuICAgICAgICAgIHJhdzogY2FwWzBdLFxuICAgICAgICAgIHRleHQ6IHRleHRcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgcmV0dXJuIFRva2VuaXplcjtcbiAgfSgpO1xuXG4gIHZhciBub29wVGVzdCA9IGhlbHBlcnMubm9vcFRlc3QsXG4gICAgICBlZGl0ID0gaGVscGVycy5lZGl0LFxuICAgICAgbWVyZ2UkMSA9IGhlbHBlcnMubWVyZ2U7XG4gIC8qKlxuICAgKiBCbG9jay1MZXZlbCBHcmFtbWFyXG4gICAqL1xuXG4gIHZhciBibG9jayQxID0ge1xuICAgIG5ld2xpbmU6IC9eKD86ICooPzpcXG58JCkpKy8sXG4gICAgY29kZTogL14oIHs0fVteXFxuXSsoPzpcXG4oPzogKig/OlxcbnwkKSkqKT8pKy8sXG4gICAgZmVuY2VzOiAvXiB7MCwzfShgezMsfSg/PVteYFxcbl0qXFxuKXx+ezMsfSkoW15cXG5dKilcXG4oPzp8KFtcXHNcXFNdKj8pXFxuKSg/OiB7MCwzfVxcMVt+YF0qICooPz1cXG58JCl8JCkvLFxuICAgIGhyOiAvXiB7MCwzfSgoPzotICopezMsfXwoPzpfICopezMsfXwoPzpcXCogKil7Myx9KSg/Olxcbit8JCkvLFxuICAgIGhlYWRpbmc6IC9eIHswLDN9KCN7MSw2fSkoPz1cXHN8JCkoLiopKD86XFxuK3wkKS8sXG4gICAgYmxvY2txdW90ZTogL14oIHswLDN9PiA/KHBhcmFncmFwaHxbXlxcbl0qKSg/OlxcbnwkKSkrLyxcbiAgICBsaXN0OiAvXiggezAsM31idWxsKSggW15cXG5dKz8pPyg/OlxcbnwkKS8sXG4gICAgaHRtbDogJ14gezAsM30oPzonIC8vIG9wdGlvbmFsIGluZGVudGF0aW9uXG4gICAgKyAnPChzY3JpcHR8cHJlfHN0eWxlfHRleHRhcmVhKVtcXFxccz5dW1xcXFxzXFxcXFNdKj8oPzo8L1xcXFwxPlteXFxcXG5dKlxcXFxuK3wkKScgLy8gKDEpXG4gICAgKyAnfGNvbW1lbnRbXlxcXFxuXSooXFxcXG4rfCQpJyAvLyAoMilcbiAgICArICd8PFxcXFw/W1xcXFxzXFxcXFNdKj8oPzpcXFxcPz5cXFxcbip8JCknIC8vICgzKVxuICAgICsgJ3w8IVtBLVpdW1xcXFxzXFxcXFNdKj8oPzo+XFxcXG4qfCQpJyAvLyAoNClcbiAgICArICd8PCFcXFxcW0NEQVRBXFxcXFtbXFxcXHNcXFxcU10qPyg/OlxcXFxdXFxcXF0+XFxcXG4qfCQpJyAvLyAoNSlcbiAgICArICd8PC8/KHRhZykoPzogK3xcXFxcbnwvPz4pW1xcXFxzXFxcXFNdKj8oPzooPzpcXFxcbiAqKStcXFxcbnwkKScgLy8gKDYpXG4gICAgKyAnfDwoPyFzY3JpcHR8cHJlfHN0eWxlfHRleHRhcmVhKShbYS16XVtcXFxcdy1dKikoPzphdHRyaWJ1dGUpKj8gKi8/Pig/PVsgXFxcXHRdKig/OlxcXFxufCQpKVtcXFxcc1xcXFxTXSo/KD86KD86XFxcXG4gKikrXFxcXG58JCknIC8vICg3KSBvcGVuIHRhZ1xuICAgICsgJ3w8Lyg/IXNjcmlwdHxwcmV8c3R5bGV8dGV4dGFyZWEpW2Etel1bXFxcXHctXSpcXFxccyo+KD89WyBcXFxcdF0qKD86XFxcXG58JCkpW1xcXFxzXFxcXFNdKj8oPzooPzpcXFxcbiAqKStcXFxcbnwkKScgLy8gKDcpIGNsb3NpbmcgdGFnXG4gICAgKyAnKScsXG4gICAgZGVmOiAvXiB7MCwzfVxcWyhsYWJlbClcXF06ICpcXG4/ICo8PyhbXlxccz5dKyk+Pyg/Oig/OiArXFxuPyAqfCAqXFxuICopKHRpdGxlKSk/ICooPzpcXG4rfCQpLyxcbiAgICB0YWJsZTogbm9vcFRlc3QsXG4gICAgbGhlYWRpbmc6IC9eKFteXFxuXSspXFxuIHswLDN9KD0rfC0rKSAqKD86XFxuK3wkKS8sXG4gICAgLy8gcmVnZXggdGVtcGxhdGUsIHBsYWNlaG9sZGVycyB3aWxsIGJlIHJlcGxhY2VkIGFjY29yZGluZyB0byBkaWZmZXJlbnQgcGFyYWdyYXBoXG4gICAgLy8gaW50ZXJydXB0aW9uIHJ1bGVzIG9mIGNvbW1vbm1hcmsgYW5kIHRoZSBvcmlnaW5hbCBtYXJrZG93biBzcGVjOlxuICAgIF9wYXJhZ3JhcGg6IC9eKFteXFxuXSsoPzpcXG4oPyFocnxoZWFkaW5nfGxoZWFkaW5nfGJsb2NrcXVvdGV8ZmVuY2VzfGxpc3R8aHRtbHwgK1xcbilbXlxcbl0rKSopLyxcbiAgICB0ZXh0OiAvXlteXFxuXSsvXG4gIH07XG4gIGJsb2NrJDEuX2xhYmVsID0gLyg/IVxccypcXF0pKD86XFxcXFtcXFtcXF1dfFteXFxbXFxdXSkrLztcbiAgYmxvY2skMS5fdGl0bGUgPSAvKD86XCIoPzpcXFxcXCI/fFteXCJcXFxcXSkqXCJ8J1teJ1xcbl0qKD86XFxuW14nXFxuXSspKlxcbj8nfFxcKFteKCldKlxcKSkvO1xuICBibG9jayQxLmRlZiA9IGVkaXQoYmxvY2skMS5kZWYpLnJlcGxhY2UoJ2xhYmVsJywgYmxvY2skMS5fbGFiZWwpLnJlcGxhY2UoJ3RpdGxlJywgYmxvY2skMS5fdGl0bGUpLmdldFJlZ2V4KCk7XG4gIGJsb2NrJDEuYnVsbGV0ID0gLyg/OlsqKy1dfFxcZHsxLDl9Wy4pXSkvO1xuICBibG9jayQxLmxpc3RJdGVtU3RhcnQgPSBlZGl0KC9eKCAqKShidWxsKSAqLykucmVwbGFjZSgnYnVsbCcsIGJsb2NrJDEuYnVsbGV0KS5nZXRSZWdleCgpO1xuICBibG9jayQxLmxpc3QgPSBlZGl0KGJsb2NrJDEubGlzdCkucmVwbGFjZSgvYnVsbC9nLCBibG9jayQxLmJ1bGxldCkucmVwbGFjZSgnaHInLCAnXFxcXG4rKD89XFxcXDE/KD86KD86LSAqKXszLH18KD86XyAqKXszLH18KD86XFxcXCogKil7Myx9KSg/OlxcXFxuK3wkKSknKS5yZXBsYWNlKCdkZWYnLCAnXFxcXG4rKD89JyArIGJsb2NrJDEuZGVmLnNvdXJjZSArICcpJykuZ2V0UmVnZXgoKTtcbiAgYmxvY2skMS5fdGFnID0gJ2FkZHJlc3N8YXJ0aWNsZXxhc2lkZXxiYXNlfGJhc2Vmb250fGJsb2NrcXVvdGV8Ym9keXxjYXB0aW9uJyArICd8Y2VudGVyfGNvbHxjb2xncm91cHxkZHxkZXRhaWxzfGRpYWxvZ3xkaXJ8ZGl2fGRsfGR0fGZpZWxkc2V0fGZpZ2NhcHRpb24nICsgJ3xmaWd1cmV8Zm9vdGVyfGZvcm18ZnJhbWV8ZnJhbWVzZXR8aFsxLTZdfGhlYWR8aGVhZGVyfGhyfGh0bWx8aWZyYW1lJyArICd8bGVnZW5kfGxpfGxpbmt8bWFpbnxtZW51fG1lbnVpdGVtfG1ldGF8bmF2fG5vZnJhbWVzfG9sfG9wdGdyb3VwfG9wdGlvbicgKyAnfHB8cGFyYW18c2VjdGlvbnxzb3VyY2V8c3VtbWFyeXx0YWJsZXx0Ym9keXx0ZHx0Zm9vdHx0aHx0aGVhZHx0aXRsZXx0cicgKyAnfHRyYWNrfHVsJztcbiAgYmxvY2skMS5fY29tbWVudCA9IC88IS0tKD8hLT8+KVtcXHNcXFNdKj8oPzotLT58JCkvO1xuICBibG9jayQxLmh0bWwgPSBlZGl0KGJsb2NrJDEuaHRtbCwgJ2knKS5yZXBsYWNlKCdjb21tZW50JywgYmxvY2skMS5fY29tbWVudCkucmVwbGFjZSgndGFnJywgYmxvY2skMS5fdGFnKS5yZXBsYWNlKCdhdHRyaWJ1dGUnLCAvICtbYS16QS1aOl9dW1xcdy46LV0qKD86ICo9ICpcIlteXCJcXG5dKlwifCAqPSAqJ1teJ1xcbl0qJ3wgKj0gKlteXFxzXCInPTw+YF0rKT8vKS5nZXRSZWdleCgpO1xuICBibG9jayQxLnBhcmFncmFwaCA9IGVkaXQoYmxvY2skMS5fcGFyYWdyYXBoKS5yZXBsYWNlKCdocicsIGJsb2NrJDEuaHIpLnJlcGxhY2UoJ2hlYWRpbmcnLCAnIHswLDN9I3sxLDZ9ICcpLnJlcGxhY2UoJ3xsaGVhZGluZycsICcnKSAvLyBzZXRleCBoZWFkaW5ncyBkb24ndCBpbnRlcnJ1cHQgY29tbW9ubWFyayBwYXJhZ3JhcGhzXG4gIC5yZXBsYWNlKCdibG9ja3F1b3RlJywgJyB7MCwzfT4nKS5yZXBsYWNlKCdmZW5jZXMnLCAnIHswLDN9KD86YHszLH0oPz1bXmBcXFxcbl0qXFxcXG4pfH57Myx9KVteXFxcXG5dKlxcXFxuJykucmVwbGFjZSgnbGlzdCcsICcgezAsM30oPzpbKistXXwxWy4pXSkgJykgLy8gb25seSBsaXN0cyBzdGFydGluZyBmcm9tIDEgY2FuIGludGVycnVwdFxuICAucmVwbGFjZSgnaHRtbCcsICc8Lz8oPzp0YWcpKD86ICt8XFxcXG58Lz8+KXw8KD86c2NyaXB0fHByZXxzdHlsZXx0ZXh0YXJlYXwhLS0pJykucmVwbGFjZSgndGFnJywgYmxvY2skMS5fdGFnKSAvLyBwYXJzIGNhbiBiZSBpbnRlcnJ1cHRlZCBieSB0eXBlICg2KSBodG1sIGJsb2Nrc1xuICAuZ2V0UmVnZXgoKTtcbiAgYmxvY2skMS5ibG9ja3F1b3RlID0gZWRpdChibG9jayQxLmJsb2NrcXVvdGUpLnJlcGxhY2UoJ3BhcmFncmFwaCcsIGJsb2NrJDEucGFyYWdyYXBoKS5nZXRSZWdleCgpO1xuICAvKipcbiAgICogTm9ybWFsIEJsb2NrIEdyYW1tYXJcbiAgICovXG5cbiAgYmxvY2skMS5ub3JtYWwgPSBtZXJnZSQxKHt9LCBibG9jayQxKTtcbiAgLyoqXG4gICAqIEdGTSBCbG9jayBHcmFtbWFyXG4gICAqL1xuXG4gIGJsb2NrJDEuZ2ZtID0gbWVyZ2UkMSh7fSwgYmxvY2skMS5ub3JtYWwsIHtcbiAgICB0YWJsZTogJ14gKihbXlxcXFxuIF0uKlxcXFx8LiopXFxcXG4nIC8vIEhlYWRlclxuICAgICsgJyB7MCwzfSg/OlxcXFx8ICopPyg6Py0rOj8gKig/OlxcXFx8ICo6Py0rOj8gKikqKSg/OlxcXFx8ICopPycgLy8gQWxpZ25cbiAgICArICcoPzpcXFxcbigoPzooPyEgKlxcXFxufGhyfGhlYWRpbmd8YmxvY2txdW90ZXxjb2RlfGZlbmNlc3xsaXN0fGh0bWwpLiooPzpcXFxcbnwkKSkqKVxcXFxuKnwkKScgLy8gQ2VsbHNcblxuICB9KTtcbiAgYmxvY2skMS5nZm0udGFibGUgPSBlZGl0KGJsb2NrJDEuZ2ZtLnRhYmxlKS5yZXBsYWNlKCdocicsIGJsb2NrJDEuaHIpLnJlcGxhY2UoJ2hlYWRpbmcnLCAnIHswLDN9I3sxLDZ9ICcpLnJlcGxhY2UoJ2Jsb2NrcXVvdGUnLCAnIHswLDN9PicpLnJlcGxhY2UoJ2NvZGUnLCAnIHs0fVteXFxcXG5dJykucmVwbGFjZSgnZmVuY2VzJywgJyB7MCwzfSg/OmB7Myx9KD89W15gXFxcXG5dKlxcXFxuKXx+ezMsfSlbXlxcXFxuXSpcXFxcbicpLnJlcGxhY2UoJ2xpc3QnLCAnIHswLDN9KD86WyorLV18MVsuKV0pICcpIC8vIG9ubHkgbGlzdHMgc3RhcnRpbmcgZnJvbSAxIGNhbiBpbnRlcnJ1cHRcbiAgLnJlcGxhY2UoJ2h0bWwnLCAnPC8/KD86dGFnKSg/OiArfFxcXFxufC8/Pil8PCg/OnNjcmlwdHxwcmV8c3R5bGV8dGV4dGFyZWF8IS0tKScpLnJlcGxhY2UoJ3RhZycsIGJsb2NrJDEuX3RhZykgLy8gdGFibGVzIGNhbiBiZSBpbnRlcnJ1cHRlZCBieSB0eXBlICg2KSBodG1sIGJsb2Nrc1xuICAuZ2V0UmVnZXgoKTtcbiAgLyoqXG4gICAqIFBlZGFudGljIGdyYW1tYXIgKG9yaWdpbmFsIEpvaG4gR3J1YmVyJ3MgbG9vc2UgbWFya2Rvd24gc3BlY2lmaWNhdGlvbilcbiAgICovXG5cbiAgYmxvY2skMS5wZWRhbnRpYyA9IG1lcmdlJDEoe30sIGJsb2NrJDEubm9ybWFsLCB7XG4gICAgaHRtbDogZWRpdCgnXiAqKD86Y29tbWVudCAqKD86XFxcXG58XFxcXHMqJCknICsgJ3w8KHRhZylbXFxcXHNcXFxcU10rPzwvXFxcXDE+ICooPzpcXFxcbnsyLH18XFxcXHMqJCknIC8vIGNsb3NlZCB0YWdcbiAgICArICd8PHRhZyg/OlwiW15cIl0qXCJ8XFwnW15cXCddKlxcJ3xcXFxcc1teXFwnXCIvPlxcXFxzXSopKj8vPz4gKig/OlxcXFxuezIsfXxcXFxccyokKSknKS5yZXBsYWNlKCdjb21tZW50JywgYmxvY2skMS5fY29tbWVudCkucmVwbGFjZSgvdGFnL2csICcoPyEoPzonICsgJ2F8ZW18c3Ryb25nfHNtYWxsfHN8Y2l0ZXxxfGRmbnxhYmJyfGRhdGF8dGltZXxjb2RlfHZhcnxzYW1wfGtiZHxzdWInICsgJ3xzdXB8aXxifHV8bWFya3xydWJ5fHJ0fHJwfGJkaXxiZG98c3Bhbnxicnx3YnJ8aW5zfGRlbHxpbWcpJyArICdcXFxcYilcXFxcdysoPyE6fFteXFxcXHdcXFxcc0BdKkApXFxcXGInKS5nZXRSZWdleCgpLFxuICAgIGRlZjogL14gKlxcWyhbXlxcXV0rKVxcXTogKjw/KFteXFxzPl0rKT4/KD86ICsoW1wiKF1bXlxcbl0rW1wiKV0pKT8gKig/Olxcbit8JCkvLFxuICAgIGhlYWRpbmc6IC9eKCN7MSw2fSkoLiopKD86XFxuK3wkKS8sXG4gICAgZmVuY2VzOiBub29wVGVzdCxcbiAgICAvLyBmZW5jZXMgbm90IHN1cHBvcnRlZFxuICAgIHBhcmFncmFwaDogZWRpdChibG9jayQxLm5vcm1hbC5fcGFyYWdyYXBoKS5yZXBsYWNlKCdocicsIGJsb2NrJDEuaHIpLnJlcGxhY2UoJ2hlYWRpbmcnLCAnICojezEsNn0gKlteXFxuXScpLnJlcGxhY2UoJ2xoZWFkaW5nJywgYmxvY2skMS5saGVhZGluZykucmVwbGFjZSgnYmxvY2txdW90ZScsICcgezAsM30+JykucmVwbGFjZSgnfGZlbmNlcycsICcnKS5yZXBsYWNlKCd8bGlzdCcsICcnKS5yZXBsYWNlKCd8aHRtbCcsICcnKS5nZXRSZWdleCgpXG4gIH0pO1xuICAvKipcbiAgICogSW5saW5lLUxldmVsIEdyYW1tYXJcbiAgICovXG5cbiAgdmFyIGlubGluZSQxID0ge1xuICAgIGVzY2FwZTogL15cXFxcKFshXCIjJCUmJygpKissXFwtLi86Ozw9Pj9AXFxbXFxdXFxcXF5fYHt8fX5dKS8sXG4gICAgYXV0b2xpbms6IC9ePChzY2hlbWU6W15cXHNcXHgwMC1cXHgxZjw+XSp8ZW1haWwpPi8sXG4gICAgdXJsOiBub29wVGVzdCxcbiAgICB0YWc6ICdeY29tbWVudCcgKyAnfF48L1thLXpBLVpdW1xcXFx3Oi1dKlxcXFxzKj4nIC8vIHNlbGYtY2xvc2luZyB0YWdcbiAgICArICd8XjxbYS16QS1aXVtcXFxcdy1dKig/OmF0dHJpYnV0ZSkqP1xcXFxzKi8/PicgLy8gb3BlbiB0YWdcbiAgICArICd8XjxcXFxcP1tcXFxcc1xcXFxTXSo/XFxcXD8+JyAvLyBwcm9jZXNzaW5nIGluc3RydWN0aW9uLCBlLmcuIDw/cGhwID8+XG4gICAgKyAnfF48IVthLXpBLVpdK1xcXFxzW1xcXFxzXFxcXFNdKj8+JyAvLyBkZWNsYXJhdGlvbiwgZS5nLiA8IURPQ1RZUEUgaHRtbD5cbiAgICArICd8XjwhXFxcXFtDREFUQVxcXFxbW1xcXFxzXFxcXFNdKj9cXFxcXVxcXFxdPicsXG4gICAgLy8gQ0RBVEEgc2VjdGlvblxuICAgIGxpbms6IC9eIT9cXFsobGFiZWwpXFxdXFwoXFxzKihocmVmKSg/OlxccysodGl0bGUpKT9cXHMqXFwpLyxcbiAgICByZWZsaW5rOiAvXiE/XFxbKGxhYmVsKVxcXVxcWyg/IVxccypcXF0pKCg/OlxcXFxbXFxbXFxdXT98W15cXFtcXF1cXFxcXSkrKVxcXS8sXG4gICAgbm9saW5rOiAvXiE/XFxbKD8hXFxzKlxcXSkoKD86XFxbW15cXFtcXF1dKlxcXXxcXFxcW1xcW1xcXV18W15cXFtcXF1dKSopXFxdKD86XFxbXFxdKT8vLFxuICAgIHJlZmxpbmtTZWFyY2g6ICdyZWZsaW5rfG5vbGluayg/IVxcXFwoKScsXG4gICAgZW1TdHJvbmc6IHtcbiAgICAgIGxEZWxpbTogL14oPzpcXCorKD86KFtwdW5jdF9dKXxbXlxccypdKSl8Xl8rKD86KFtwdW5jdCpdKXwoW15cXHNfXSkpLyxcbiAgICAgIC8vICAgICAgICAoMSkgYW5kICgyKSBjYW4gb25seSBiZSBhIFJpZ2h0IERlbGltaXRlci4gKDMpIGFuZCAoNCkgY2FuIG9ubHkgYmUgTGVmdC4gICg1KSBhbmQgKDYpIGNhbiBiZSBlaXRoZXIgTGVmdCBvciBSaWdodC5cbiAgICAgIC8vICAgICAgICAoKSBTa2lwIG9ycGhhbiBkZWxpbSBpbnNpZGUgc3Ryb25nICAgICgxKSAjKioqICAgICAgICAgICAgICAgICgyKSBhKioqIywgYSoqKiAgICAgICAgICAgICAgICAgICAoMykgIyoqKmEsICoqKmEgICAgICAgICAgICAgICAgICg0KSAqKiojICAgICAgICAgICAgICAoNSkgIyoqKiMgICAgICAgICAgICAgICAgICg2KSBhKioqYVxuICAgICAgckRlbGltQXN0OiAvXlteXypdKj9cXF9cXF9bXl8qXSo/XFwqW15fKl0qPyg/PVxcX1xcXyl8W3B1bmN0X10oXFwqKykoPz1bXFxzXXwkKXxbXnB1bmN0Kl9cXHNdKFxcKispKD89W3B1bmN0X1xcc118JCl8W3B1bmN0X1xcc10oXFwqKykoPz1bXnB1bmN0Kl9cXHNdKXxbXFxzXShcXCorKSg/PVtwdW5jdF9dKXxbcHVuY3RfXShcXCorKSg/PVtwdW5jdF9dKXxbXnB1bmN0Kl9cXHNdKFxcKispKD89W15wdW5jdCpfXFxzXSkvLFxuICAgICAgckRlbGltVW5kOiAvXlteXypdKj9cXCpcXCpbXl8qXSo/XFxfW15fKl0qPyg/PVxcKlxcKil8W3B1bmN0Kl0oXFxfKykoPz1bXFxzXXwkKXxbXnB1bmN0Kl9cXHNdKFxcXyspKD89W3B1bmN0Klxcc118JCl8W3B1bmN0Klxcc10oXFxfKykoPz1bXnB1bmN0Kl9cXHNdKXxbXFxzXShcXF8rKSg/PVtwdW5jdCpdKXxbcHVuY3QqXShcXF8rKSg/PVtwdW5jdCpdKS8gLy8gXi0gTm90IGFsbG93ZWQgZm9yIF9cblxuICAgIH0sXG4gICAgY29kZTogL14oYCspKFteYF18W15gXVtcXHNcXFNdKj9bXmBdKVxcMSg/IWApLyxcbiAgICBicjogL14oIHsyLH18XFxcXClcXG4oPyFcXHMqJCkvLFxuICAgIGRlbDogbm9vcFRlc3QsXG4gICAgdGV4dDogL14oYCt8W15gXSkoPzooPz0gezIsfVxcbil8W1xcc1xcU10qPyg/Oig/PVtcXFxcPCFcXFtgKl9dfFxcYl98JCl8W14gXSg/PSB7Mix9XFxuKSkpLyxcbiAgICBwdW5jdHVhdGlvbjogL14oW1xcc3B1bmN0dWF0aW9uXSkvXG4gIH07IC8vIGxpc3Qgb2YgcHVuY3R1YXRpb24gbWFya3MgZnJvbSBDb21tb25NYXJrIHNwZWNcbiAgLy8gd2l0aG91dCAqIGFuZCBfIHRvIGhhbmRsZSB0aGUgZGlmZmVyZW50IGVtcGhhc2lzIG1hcmtlcnMgKiBhbmQgX1xuXG4gIGlubGluZSQxLl9wdW5jdHVhdGlvbiA9ICchXCIjJCUmXFwnKCkrXFxcXC0uLC86Ozw9Pj9AXFxcXFtcXFxcXWBee3x9fic7XG4gIGlubGluZSQxLnB1bmN0dWF0aW9uID0gZWRpdChpbmxpbmUkMS5wdW5jdHVhdGlvbikucmVwbGFjZSgvcHVuY3R1YXRpb24vZywgaW5saW5lJDEuX3B1bmN0dWF0aW9uKS5nZXRSZWdleCgpOyAvLyBzZXF1ZW5jZXMgZW0gc2hvdWxkIHNraXAgb3ZlciBbdGl0bGVdKGxpbmspLCBgY29kZWAsIDxodG1sPlxuXG4gIGlubGluZSQxLmJsb2NrU2tpcCA9IC9cXFtbXlxcXV0qP1xcXVxcKFteXFwpXSo/XFwpfGBbXmBdKj9gfDxbXj5dKj8+L2c7XG4gIGlubGluZSQxLmVzY2FwZWRFbVN0ID0gL1xcXFxcXCp8XFxcXF8vZztcbiAgaW5saW5lJDEuX2NvbW1lbnQgPSBlZGl0KGJsb2NrJDEuX2NvbW1lbnQpLnJlcGxhY2UoJyg/Oi0tPnwkKScsICctLT4nKS5nZXRSZWdleCgpO1xuICBpbmxpbmUkMS5lbVN0cm9uZy5sRGVsaW0gPSBlZGl0KGlubGluZSQxLmVtU3Ryb25nLmxEZWxpbSkucmVwbGFjZSgvcHVuY3QvZywgaW5saW5lJDEuX3B1bmN0dWF0aW9uKS5nZXRSZWdleCgpO1xuICBpbmxpbmUkMS5lbVN0cm9uZy5yRGVsaW1Bc3QgPSBlZGl0KGlubGluZSQxLmVtU3Ryb25nLnJEZWxpbUFzdCwgJ2cnKS5yZXBsYWNlKC9wdW5jdC9nLCBpbmxpbmUkMS5fcHVuY3R1YXRpb24pLmdldFJlZ2V4KCk7XG4gIGlubGluZSQxLmVtU3Ryb25nLnJEZWxpbVVuZCA9IGVkaXQoaW5saW5lJDEuZW1TdHJvbmcuckRlbGltVW5kLCAnZycpLnJlcGxhY2UoL3B1bmN0L2csIGlubGluZSQxLl9wdW5jdHVhdGlvbikuZ2V0UmVnZXgoKTtcbiAgaW5saW5lJDEuX2VzY2FwZXMgPSAvXFxcXChbIVwiIyQlJicoKSorLFxcLS4vOjs8PT4/QFxcW1xcXVxcXFxeX2B7fH1+XSkvZztcbiAgaW5saW5lJDEuX3NjaGVtZSA9IC9bYS16QS1aXVthLXpBLVowLTkrLi1dezEsMzF9LztcbiAgaW5saW5lJDEuX2VtYWlsID0gL1thLXpBLVowLTkuISMkJSYnKisvPT9eX2B7fH1+LV0rKEApW2EtekEtWjAtOV0oPzpbYS16QS1aMC05LV17MCw2MX1bYS16QS1aMC05XSk/KD86XFwuW2EtekEtWjAtOV0oPzpbYS16QS1aMC05LV17MCw2MX1bYS16QS1aMC05XSk/KSsoPyFbLV9dKS87XG4gIGlubGluZSQxLmF1dG9saW5rID0gZWRpdChpbmxpbmUkMS5hdXRvbGluaykucmVwbGFjZSgnc2NoZW1lJywgaW5saW5lJDEuX3NjaGVtZSkucmVwbGFjZSgnZW1haWwnLCBpbmxpbmUkMS5fZW1haWwpLmdldFJlZ2V4KCk7XG4gIGlubGluZSQxLl9hdHRyaWJ1dGUgPSAvXFxzK1thLXpBLVo6X11bXFx3LjotXSooPzpcXHMqPVxccypcIlteXCJdKlwifFxccyo9XFxzKidbXiddKid8XFxzKj1cXHMqW15cXHNcIic9PD5gXSspPy87XG4gIGlubGluZSQxLnRhZyA9IGVkaXQoaW5saW5lJDEudGFnKS5yZXBsYWNlKCdjb21tZW50JywgaW5saW5lJDEuX2NvbW1lbnQpLnJlcGxhY2UoJ2F0dHJpYnV0ZScsIGlubGluZSQxLl9hdHRyaWJ1dGUpLmdldFJlZ2V4KCk7XG4gIGlubGluZSQxLl9sYWJlbCA9IC8oPzpcXFsoPzpcXFxcLnxbXlxcW1xcXVxcXFxdKSpcXF18XFxcXC58YFteYF0qYHxbXlxcW1xcXVxcXFxgXSkqPy87XG4gIGlubGluZSQxLl9ocmVmID0gLzwoPzpcXFxcLnxbXlxcbjw+XFxcXF0pKz58W15cXHNcXHgwMC1cXHgxZl0qLztcbiAgaW5saW5lJDEuX3RpdGxlID0gL1wiKD86XFxcXFwiP3xbXlwiXFxcXF0pKlwifCcoPzpcXFxcJz98W14nXFxcXF0pKid8XFwoKD86XFxcXFxcKT98W14pXFxcXF0pKlxcKS87XG4gIGlubGluZSQxLmxpbmsgPSBlZGl0KGlubGluZSQxLmxpbmspLnJlcGxhY2UoJ2xhYmVsJywgaW5saW5lJDEuX2xhYmVsKS5yZXBsYWNlKCdocmVmJywgaW5saW5lJDEuX2hyZWYpLnJlcGxhY2UoJ3RpdGxlJywgaW5saW5lJDEuX3RpdGxlKS5nZXRSZWdleCgpO1xuICBpbmxpbmUkMS5yZWZsaW5rID0gZWRpdChpbmxpbmUkMS5yZWZsaW5rKS5yZXBsYWNlKCdsYWJlbCcsIGlubGluZSQxLl9sYWJlbCkuZ2V0UmVnZXgoKTtcbiAgaW5saW5lJDEucmVmbGlua1NlYXJjaCA9IGVkaXQoaW5saW5lJDEucmVmbGlua1NlYXJjaCwgJ2cnKS5yZXBsYWNlKCdyZWZsaW5rJywgaW5saW5lJDEucmVmbGluaykucmVwbGFjZSgnbm9saW5rJywgaW5saW5lJDEubm9saW5rKS5nZXRSZWdleCgpO1xuICAvKipcbiAgICogTm9ybWFsIElubGluZSBHcmFtbWFyXG4gICAqL1xuXG4gIGlubGluZSQxLm5vcm1hbCA9IG1lcmdlJDEoe30sIGlubGluZSQxKTtcbiAgLyoqXG4gICAqIFBlZGFudGljIElubGluZSBHcmFtbWFyXG4gICAqL1xuXG4gIGlubGluZSQxLnBlZGFudGljID0gbWVyZ2UkMSh7fSwgaW5saW5lJDEubm9ybWFsLCB7XG4gICAgc3Ryb25nOiB7XG4gICAgICBzdGFydDogL15fX3xcXCpcXCovLFxuICAgICAgbWlkZGxlOiAvXl9fKD89XFxTKShbXFxzXFxTXSo/XFxTKV9fKD8hXyl8XlxcKlxcKig/PVxcUykoW1xcc1xcU10qP1xcUylcXCpcXCooPyFcXCopLyxcbiAgICAgIGVuZEFzdDogL1xcKlxcKig/IVxcKikvZyxcbiAgICAgIGVuZFVuZDogL19fKD8hXykvZ1xuICAgIH0sXG4gICAgZW06IHtcbiAgICAgIHN0YXJ0OiAvXl98XFwqLyxcbiAgICAgIG1pZGRsZTogL14oKVxcKig/PVxcUykoW1xcc1xcU10qP1xcUylcXCooPyFcXCopfF5fKD89XFxTKShbXFxzXFxTXSo/XFxTKV8oPyFfKS8sXG4gICAgICBlbmRBc3Q6IC9cXCooPyFcXCopL2csXG4gICAgICBlbmRVbmQ6IC9fKD8hXykvZ1xuICAgIH0sXG4gICAgbGluazogZWRpdCgvXiE/XFxbKGxhYmVsKVxcXVxcKCguKj8pXFwpLykucmVwbGFjZSgnbGFiZWwnLCBpbmxpbmUkMS5fbGFiZWwpLmdldFJlZ2V4KCksXG4gICAgcmVmbGluazogZWRpdCgvXiE/XFxbKGxhYmVsKVxcXVxccypcXFsoW15cXF1dKilcXF0vKS5yZXBsYWNlKCdsYWJlbCcsIGlubGluZSQxLl9sYWJlbCkuZ2V0UmVnZXgoKVxuICB9KTtcbiAgLyoqXG4gICAqIEdGTSBJbmxpbmUgR3JhbW1hclxuICAgKi9cblxuICBpbmxpbmUkMS5nZm0gPSBtZXJnZSQxKHt9LCBpbmxpbmUkMS5ub3JtYWwsIHtcbiAgICBlc2NhcGU6IGVkaXQoaW5saW5lJDEuZXNjYXBlKS5yZXBsYWNlKCddKScsICd+fF0pJykuZ2V0UmVnZXgoKSxcbiAgICBfZXh0ZW5kZWRfZW1haWw6IC9bQS1aYS16MC05Ll8rLV0rKEApW2EtekEtWjAtOS1fXSsoPzpcXC5bYS16QS1aMC05LV9dKlthLXpBLVowLTldKSsoPyFbLV9dKS8sXG4gICAgdXJsOiAvXigoPzpmdHB8aHR0cHM/KTpcXC9cXC98d3d3XFwuKSg/OlthLXpBLVowLTlcXC1dK1xcLj8pK1teXFxzPF0qfF5lbWFpbC8sXG4gICAgX2JhY2twZWRhbDogLyg/OltePyEuLDo7Kl9+KCkmXSt8XFwoW14pXSpcXCl8Jig/IVthLXpBLVowLTldKzskKXxbPyEuLDo7Kl9+KV0rKD8hJCkpKy8sXG4gICAgZGVsOiAvXih+fj8pKD89W15cXHN+XSkoW1xcc1xcU10qP1teXFxzfl0pXFwxKD89W15+XXwkKS8sXG4gICAgdGV4dDogL14oW2B+XSt8W15gfl0pKD86KD89IHsyLH1cXG4pfCg/PVthLXpBLVowLTkuISMkJSYnKitcXC89P19ge1xcfH1+LV0rQCl8W1xcc1xcU10qPyg/Oig/PVtcXFxcPCFcXFtgKn5fXXxcXGJffGh0dHBzPzpcXC9cXC98ZnRwOlxcL1xcL3x3d3dcXC58JCl8W14gXSg/PSB7Mix9XFxuKXxbXmEtekEtWjAtOS4hIyQlJicqK1xcLz0/X2B7XFx8fX4tXSg/PVthLXpBLVowLTkuISMkJSYnKitcXC89P19ge1xcfH1+LV0rQCkpKS9cbiAgfSk7XG4gIGlubGluZSQxLmdmbS51cmwgPSBlZGl0KGlubGluZSQxLmdmbS51cmwsICdpJykucmVwbGFjZSgnZW1haWwnLCBpbmxpbmUkMS5nZm0uX2V4dGVuZGVkX2VtYWlsKS5nZXRSZWdleCgpO1xuICAvKipcbiAgICogR0ZNICsgTGluZSBCcmVha3MgSW5saW5lIEdyYW1tYXJcbiAgICovXG5cbiAgaW5saW5lJDEuYnJlYWtzID0gbWVyZ2UkMSh7fSwgaW5saW5lJDEuZ2ZtLCB7XG4gICAgYnI6IGVkaXQoaW5saW5lJDEuYnIpLnJlcGxhY2UoJ3syLH0nLCAnKicpLmdldFJlZ2V4KCksXG4gICAgdGV4dDogZWRpdChpbmxpbmUkMS5nZm0udGV4dCkucmVwbGFjZSgnXFxcXGJfJywgJ1xcXFxiX3wgezIsfVxcXFxuJykucmVwbGFjZSgvXFx7MixcXH0vZywgJyonKS5nZXRSZWdleCgpXG4gIH0pO1xuICB2YXIgcnVsZXMgPSB7XG4gICAgYmxvY2s6IGJsb2NrJDEsXG4gICAgaW5saW5lOiBpbmxpbmUkMVxuICB9O1xuXG4gIHZhciBUb2tlbml6ZXIkMSA9IFRva2VuaXplcl8xO1xuICB2YXIgZGVmYXVsdHMkMyA9IGRlZmF1bHRzJDUuZXhwb3J0cy5kZWZhdWx0cztcbiAgdmFyIGJsb2NrID0gcnVsZXMuYmxvY2ssXG4gICAgICBpbmxpbmUgPSBydWxlcy5pbmxpbmU7XG4gIHZhciByZXBlYXRTdHJpbmcgPSBoZWxwZXJzLnJlcGVhdFN0cmluZztcbiAgLyoqXG4gICAqIHNtYXJ0eXBhbnRzIHRleHQgcmVwbGFjZW1lbnRcbiAgICovXG5cbiAgZnVuY3Rpb24gc21hcnR5cGFudHModGV4dCkge1xuICAgIHJldHVybiB0ZXh0IC8vIGVtLWRhc2hlc1xuICAgIC5yZXBsYWNlKC8tLS0vZywgXCJcXHUyMDE0XCIpIC8vIGVuLWRhc2hlc1xuICAgIC5yZXBsYWNlKC8tLS9nLCBcIlxcdTIwMTNcIikgLy8gb3BlbmluZyBzaW5nbGVzXG4gICAgLnJlcGxhY2UoLyhefFstXFx1MjAxNC8oXFxbe1wiXFxzXSknL2csIFwiJDFcXHUyMDE4XCIpIC8vIGNsb3Npbmcgc2luZ2xlcyAmIGFwb3N0cm9waGVzXG4gICAgLnJlcGxhY2UoLycvZywgXCJcXHUyMDE5XCIpIC8vIG9wZW5pbmcgZG91Ymxlc1xuICAgIC5yZXBsYWNlKC8oXnxbLVxcdTIwMTQvKFxcW3tcXHUyMDE4XFxzXSlcIi9nLCBcIiQxXFx1MjAxQ1wiKSAvLyBjbG9zaW5nIGRvdWJsZXNcbiAgICAucmVwbGFjZSgvXCIvZywgXCJcXHUyMDFEXCIpIC8vIGVsbGlwc2VzXG4gICAgLnJlcGxhY2UoL1xcLnszfS9nLCBcIlxcdTIwMjZcIik7XG4gIH1cbiAgLyoqXG4gICAqIG1hbmdsZSBlbWFpbCBhZGRyZXNzZXNcbiAgICovXG5cblxuICBmdW5jdGlvbiBtYW5nbGUodGV4dCkge1xuICAgIHZhciBvdXQgPSAnJyxcbiAgICAgICAgaSxcbiAgICAgICAgY2g7XG4gICAgdmFyIGwgPSB0ZXh0Lmxlbmd0aDtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBsOyBpKyspIHtcbiAgICAgIGNoID0gdGV4dC5jaGFyQ29kZUF0KGkpO1xuXG4gICAgICBpZiAoTWF0aC5yYW5kb20oKSA+IDAuNSkge1xuICAgICAgICBjaCA9ICd4JyArIGNoLnRvU3RyaW5nKDE2KTtcbiAgICAgIH1cblxuICAgICAgb3V0ICs9ICcmIycgKyBjaCArICc7JztcbiAgICB9XG5cbiAgICByZXR1cm4gb3V0O1xuICB9XG4gIC8qKlxuICAgKiBCbG9jayBMZXhlclxuICAgKi9cblxuXG4gIHZhciBMZXhlcl8xID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBMZXhlcihvcHRpb25zKSB7XG4gICAgICB0aGlzLnRva2VucyA9IFtdO1xuICAgICAgdGhpcy50b2tlbnMubGlua3MgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucyB8fCBkZWZhdWx0cyQzO1xuICAgICAgdGhpcy5vcHRpb25zLnRva2VuaXplciA9IHRoaXMub3B0aW9ucy50b2tlbml6ZXIgfHwgbmV3IFRva2VuaXplciQxKCk7XG4gICAgICB0aGlzLnRva2VuaXplciA9IHRoaXMub3B0aW9ucy50b2tlbml6ZXI7XG4gICAgICB0aGlzLnRva2VuaXplci5vcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgICAgdGhpcy50b2tlbml6ZXIubGV4ZXIgPSB0aGlzO1xuICAgICAgdGhpcy5pbmxpbmVRdWV1ZSA9IFtdO1xuICAgICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgICAgaW5MaW5rOiBmYWxzZSxcbiAgICAgICAgaW5SYXdCbG9jazogZmFsc2UsXG4gICAgICAgIHRvcDogdHJ1ZVxuICAgICAgfTtcbiAgICAgIHZhciBydWxlcyA9IHtcbiAgICAgICAgYmxvY2s6IGJsb2NrLm5vcm1hbCxcbiAgICAgICAgaW5saW5lOiBpbmxpbmUubm9ybWFsXG4gICAgICB9O1xuXG4gICAgICBpZiAodGhpcy5vcHRpb25zLnBlZGFudGljKSB7XG4gICAgICAgIHJ1bGVzLmJsb2NrID0gYmxvY2sucGVkYW50aWM7XG4gICAgICAgIHJ1bGVzLmlubGluZSA9IGlubGluZS5wZWRhbnRpYztcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5vcHRpb25zLmdmbSkge1xuICAgICAgICBydWxlcy5ibG9jayA9IGJsb2NrLmdmbTtcblxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmJyZWFrcykge1xuICAgICAgICAgIHJ1bGVzLmlubGluZSA9IGlubGluZS5icmVha3M7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcnVsZXMuaW5saW5lID0gaW5saW5lLmdmbTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0aGlzLnRva2VuaXplci5ydWxlcyA9IHJ1bGVzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFeHBvc2UgUnVsZXNcbiAgICAgKi9cblxuXG4gICAgLyoqXG4gICAgICogU3RhdGljIExleCBNZXRob2RcbiAgICAgKi9cbiAgICBMZXhlci5sZXggPSBmdW5jdGlvbiBsZXgoc3JjLCBvcHRpb25zKSB7XG4gICAgICB2YXIgbGV4ZXIgPSBuZXcgTGV4ZXIob3B0aW9ucyk7XG4gICAgICByZXR1cm4gbGV4ZXIubGV4KHNyYyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN0YXRpYyBMZXggSW5saW5lIE1ldGhvZFxuICAgICAqL1xuICAgIDtcblxuICAgIExleGVyLmxleElubGluZSA9IGZ1bmN0aW9uIGxleElubGluZShzcmMsIG9wdGlvbnMpIHtcbiAgICAgIHZhciBsZXhlciA9IG5ldyBMZXhlcihvcHRpb25zKTtcbiAgICAgIHJldHVybiBsZXhlci5pbmxpbmVUb2tlbnMoc3JjKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUHJlcHJvY2Vzc2luZ1xuICAgICAqL1xuICAgIDtcblxuICAgIHZhciBfcHJvdG8gPSBMZXhlci5wcm90b3R5cGU7XG5cbiAgICBfcHJvdG8ubGV4ID0gZnVuY3Rpb24gbGV4KHNyYykge1xuICAgICAgc3JjID0gc3JjLnJlcGxhY2UoL1xcclxcbnxcXHIvZywgJ1xcbicpLnJlcGxhY2UoL1xcdC9nLCAnICAgICcpO1xuICAgICAgdGhpcy5ibG9ja1Rva2VucyhzcmMsIHRoaXMudG9rZW5zKTtcbiAgICAgIHZhciBuZXh0O1xuXG4gICAgICB3aGlsZSAobmV4dCA9IHRoaXMuaW5saW5lUXVldWUuc2hpZnQoKSkge1xuICAgICAgICB0aGlzLmlubGluZVRva2VucyhuZXh0LnNyYywgbmV4dC50b2tlbnMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy50b2tlbnM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExleGluZ1xuICAgICAqL1xuICAgIDtcblxuICAgIF9wcm90by5ibG9ja1Rva2VucyA9IGZ1bmN0aW9uIGJsb2NrVG9rZW5zKHNyYywgdG9rZW5zKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICBpZiAodG9rZW5zID09PSB2b2lkIDApIHtcbiAgICAgICAgdG9rZW5zID0gW107XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMucGVkYW50aWMpIHtcbiAgICAgICAgc3JjID0gc3JjLnJlcGxhY2UoL14gKyQvZ20sICcnKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHRva2VuLCBsYXN0VG9rZW4sIGN1dFNyYywgbGFzdFBhcmFncmFwaENsaXBwZWQ7XG5cbiAgICAgIHdoaWxlIChzcmMpIHtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5leHRlbnNpb25zICYmIHRoaXMub3B0aW9ucy5leHRlbnNpb25zLmJsb2NrICYmIHRoaXMub3B0aW9ucy5leHRlbnNpb25zLmJsb2NrLnNvbWUoZnVuY3Rpb24gKGV4dFRva2VuaXplcikge1xuICAgICAgICAgIGlmICh0b2tlbiA9IGV4dFRva2VuaXplci5jYWxsKHtcbiAgICAgICAgICAgIGxleGVyOiBfdGhpc1xuICAgICAgICAgIH0sIHNyYywgdG9rZW5zKSkge1xuICAgICAgICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyh0b2tlbi5yYXcubGVuZ3RoKTtcbiAgICAgICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSkpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfSAvLyBuZXdsaW5lXG5cblxuICAgICAgICBpZiAodG9rZW4gPSB0aGlzLnRva2VuaXplci5zcGFjZShzcmMpKSB7XG4gICAgICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyh0b2tlbi5yYXcubGVuZ3RoKTtcblxuICAgICAgICAgIGlmICh0b2tlbi50eXBlKSB7XG4gICAgICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH0gLy8gY29kZVxuXG5cbiAgICAgICAgaWYgKHRva2VuID0gdGhpcy50b2tlbml6ZXIuY29kZShzcmMpKSB7XG4gICAgICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyh0b2tlbi5yYXcubGVuZ3RoKTtcbiAgICAgICAgICBsYXN0VG9rZW4gPSB0b2tlbnNbdG9rZW5zLmxlbmd0aCAtIDFdOyAvLyBBbiBpbmRlbnRlZCBjb2RlIGJsb2NrIGNhbm5vdCBpbnRlcnJ1cHQgYSBwYXJhZ3JhcGguXG5cbiAgICAgICAgICBpZiAobGFzdFRva2VuICYmIChsYXN0VG9rZW4udHlwZSA9PT0gJ3BhcmFncmFwaCcgfHwgbGFzdFRva2VuLnR5cGUgPT09ICd0ZXh0JykpIHtcbiAgICAgICAgICAgIGxhc3RUb2tlbi5yYXcgKz0gJ1xcbicgKyB0b2tlbi5yYXc7XG4gICAgICAgICAgICBsYXN0VG9rZW4udGV4dCArPSAnXFxuJyArIHRva2VuLnRleHQ7XG4gICAgICAgICAgICB0aGlzLmlubGluZVF1ZXVlW3RoaXMuaW5saW5lUXVldWUubGVuZ3RoIC0gMV0uc3JjID0gbGFzdFRva2VuLnRleHQ7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfSAvLyBmZW5jZXNcblxuXG4gICAgICAgIGlmICh0b2tlbiA9IHRoaXMudG9rZW5pemVyLmZlbmNlcyhzcmMpKSB7XG4gICAgICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyh0b2tlbi5yYXcubGVuZ3RoKTtcbiAgICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH0gLy8gaGVhZGluZ1xuXG5cbiAgICAgICAgaWYgKHRva2VuID0gdGhpcy50b2tlbml6ZXIuaGVhZGluZyhzcmMpKSB7XG4gICAgICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyh0b2tlbi5yYXcubGVuZ3RoKTtcbiAgICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH0gLy8gaHJcblxuXG4gICAgICAgIGlmICh0b2tlbiA9IHRoaXMudG9rZW5pemVyLmhyKHNyYykpIHtcbiAgICAgICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKHRva2VuLnJhdy5sZW5ndGgpO1xuICAgICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfSAvLyBibG9ja3F1b3RlXG5cblxuICAgICAgICBpZiAodG9rZW4gPSB0aGlzLnRva2VuaXplci5ibG9ja3F1b3RlKHNyYykpIHtcbiAgICAgICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKHRva2VuLnJhdy5sZW5ndGgpO1xuICAgICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfSAvLyBsaXN0XG5cblxuICAgICAgICBpZiAodG9rZW4gPSB0aGlzLnRva2VuaXplci5saXN0KHNyYykpIHtcbiAgICAgICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKHRva2VuLnJhdy5sZW5ndGgpO1xuICAgICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfSAvLyBodG1sXG5cblxuICAgICAgICBpZiAodG9rZW4gPSB0aGlzLnRva2VuaXplci5odG1sKHNyYykpIHtcbiAgICAgICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKHRva2VuLnJhdy5sZW5ndGgpO1xuICAgICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfSAvLyBkZWZcblxuXG4gICAgICAgIGlmICh0b2tlbiA9IHRoaXMudG9rZW5pemVyLmRlZihzcmMpKSB7XG4gICAgICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyh0b2tlbi5yYXcubGVuZ3RoKTtcbiAgICAgICAgICBsYXN0VG9rZW4gPSB0b2tlbnNbdG9rZW5zLmxlbmd0aCAtIDFdO1xuXG4gICAgICAgICAgaWYgKGxhc3RUb2tlbiAmJiAobGFzdFRva2VuLnR5cGUgPT09ICdwYXJhZ3JhcGgnIHx8IGxhc3RUb2tlbi50eXBlID09PSAndGV4dCcpKSB7XG4gICAgICAgICAgICBsYXN0VG9rZW4ucmF3ICs9ICdcXG4nICsgdG9rZW4ucmF3O1xuICAgICAgICAgICAgbGFzdFRva2VuLnRleHQgKz0gJ1xcbicgKyB0b2tlbi5yYXc7XG4gICAgICAgICAgICB0aGlzLmlubGluZVF1ZXVlW3RoaXMuaW5saW5lUXVldWUubGVuZ3RoIC0gMV0uc3JjID0gbGFzdFRva2VuLnRleHQ7XG4gICAgICAgICAgfSBlbHNlIGlmICghdGhpcy50b2tlbnMubGlua3NbdG9rZW4udGFnXSkge1xuICAgICAgICAgICAgdGhpcy50b2tlbnMubGlua3NbdG9rZW4udGFnXSA9IHtcbiAgICAgICAgICAgICAgaHJlZjogdG9rZW4uaHJlZixcbiAgICAgICAgICAgICAgdGl0bGU6IHRva2VuLnRpdGxlXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9IC8vIHRhYmxlIChnZm0pXG5cblxuICAgICAgICBpZiAodG9rZW4gPSB0aGlzLnRva2VuaXplci50YWJsZShzcmMpKSB7XG4gICAgICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyh0b2tlbi5yYXcubGVuZ3RoKTtcbiAgICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH0gLy8gbGhlYWRpbmdcblxuXG4gICAgICAgIGlmICh0b2tlbiA9IHRoaXMudG9rZW5pemVyLmxoZWFkaW5nKHNyYykpIHtcbiAgICAgICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKHRva2VuLnJhdy5sZW5ndGgpO1xuICAgICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfSAvLyB0b3AtbGV2ZWwgcGFyYWdyYXBoXG4gICAgICAgIC8vIHByZXZlbnQgcGFyYWdyYXBoIGNvbnN1bWluZyBleHRlbnNpb25zIGJ5IGNsaXBwaW5nICdzcmMnIHRvIGV4dGVuc2lvbiBzdGFydFxuXG5cbiAgICAgICAgY3V0U3JjID0gc3JjO1xuXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuZXh0ZW5zaW9ucyAmJiB0aGlzLm9wdGlvbnMuZXh0ZW5zaW9ucy5zdGFydEJsb2NrKSB7XG4gICAgICAgICAgKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBzdGFydEluZGV4ID0gSW5maW5pdHk7XG4gICAgICAgICAgICB2YXIgdGVtcFNyYyA9IHNyYy5zbGljZSgxKTtcbiAgICAgICAgICAgIHZhciB0ZW1wU3RhcnQgPSB2b2lkIDA7XG5cbiAgICAgICAgICAgIF90aGlzLm9wdGlvbnMuZXh0ZW5zaW9ucy5zdGFydEJsb2NrLmZvckVhY2goZnVuY3Rpb24gKGdldFN0YXJ0SW5kZXgpIHtcbiAgICAgICAgICAgICAgdGVtcFN0YXJ0ID0gZ2V0U3RhcnRJbmRleC5jYWxsKHtcbiAgICAgICAgICAgICAgICBsZXhlcjogdGhpc1xuICAgICAgICAgICAgICB9LCB0ZW1wU3JjKTtcblxuICAgICAgICAgICAgICBpZiAodHlwZW9mIHRlbXBTdGFydCA9PT0gJ251bWJlcicgJiYgdGVtcFN0YXJ0ID49IDApIHtcbiAgICAgICAgICAgICAgICBzdGFydEluZGV4ID0gTWF0aC5taW4oc3RhcnRJbmRleCwgdGVtcFN0YXJ0KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGlmIChzdGFydEluZGV4IDwgSW5maW5pdHkgJiYgc3RhcnRJbmRleCA+PSAwKSB7XG4gICAgICAgICAgICAgIGN1dFNyYyA9IHNyYy5zdWJzdHJpbmcoMCwgc3RhcnRJbmRleCArIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5zdGF0ZS50b3AgJiYgKHRva2VuID0gdGhpcy50b2tlbml6ZXIucGFyYWdyYXBoKGN1dFNyYykpKSB7XG4gICAgICAgICAgbGFzdFRva2VuID0gdG9rZW5zW3Rva2Vucy5sZW5ndGggLSAxXTtcblxuICAgICAgICAgIGlmIChsYXN0UGFyYWdyYXBoQ2xpcHBlZCAmJiBsYXN0VG9rZW4udHlwZSA9PT0gJ3BhcmFncmFwaCcpIHtcbiAgICAgICAgICAgIGxhc3RUb2tlbi5yYXcgKz0gJ1xcbicgKyB0b2tlbi5yYXc7XG4gICAgICAgICAgICBsYXN0VG9rZW4udGV4dCArPSAnXFxuJyArIHRva2VuLnRleHQ7XG4gICAgICAgICAgICB0aGlzLmlubGluZVF1ZXVlLnBvcCgpO1xuICAgICAgICAgICAgdGhpcy5pbmxpbmVRdWV1ZVt0aGlzLmlubGluZVF1ZXVlLmxlbmd0aCAtIDFdLnNyYyA9IGxhc3RUb2tlbi50ZXh0O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbGFzdFBhcmFncmFwaENsaXBwZWQgPSBjdXRTcmMubGVuZ3RoICE9PSBzcmMubGVuZ3RoO1xuICAgICAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcodG9rZW4ucmF3Lmxlbmd0aCk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH0gLy8gdGV4dFxuXG5cbiAgICAgICAgaWYgKHRva2VuID0gdGhpcy50b2tlbml6ZXIudGV4dChzcmMpKSB7XG4gICAgICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyh0b2tlbi5yYXcubGVuZ3RoKTtcbiAgICAgICAgICBsYXN0VG9rZW4gPSB0b2tlbnNbdG9rZW5zLmxlbmd0aCAtIDFdO1xuXG4gICAgICAgICAgaWYgKGxhc3RUb2tlbiAmJiBsYXN0VG9rZW4udHlwZSA9PT0gJ3RleHQnKSB7XG4gICAgICAgICAgICBsYXN0VG9rZW4ucmF3ICs9ICdcXG4nICsgdG9rZW4ucmF3O1xuICAgICAgICAgICAgbGFzdFRva2VuLnRleHQgKz0gJ1xcbicgKyB0b2tlbi50ZXh0O1xuICAgICAgICAgICAgdGhpcy5pbmxpbmVRdWV1ZS5wb3AoKTtcbiAgICAgICAgICAgIHRoaXMuaW5saW5lUXVldWVbdGhpcy5pbmxpbmVRdWV1ZS5sZW5ndGggLSAxXS5zcmMgPSBsYXN0VG9rZW4udGV4dDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNyYykge1xuICAgICAgICAgIHZhciBlcnJNc2cgPSAnSW5maW5pdGUgbG9vcCBvbiBieXRlOiAnICsgc3JjLmNoYXJDb2RlQXQoMCk7XG5cbiAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLnNpbGVudCkge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihlcnJNc2cpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJNc2cpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0aGlzLnN0YXRlLnRvcCA9IHRydWU7XG4gICAgICByZXR1cm4gdG9rZW5zO1xuICAgIH07XG5cbiAgICBfcHJvdG8uaW5saW5lID0gZnVuY3Rpb24gaW5saW5lKHNyYywgdG9rZW5zKSB7XG4gICAgICB0aGlzLmlubGluZVF1ZXVlLnB1c2goe1xuICAgICAgICBzcmM6IHNyYyxcbiAgICAgICAgdG9rZW5zOiB0b2tlbnNcbiAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBMZXhpbmcvQ29tcGlsaW5nXG4gICAgICovXG4gICAgO1xuXG4gICAgX3Byb3RvLmlubGluZVRva2VucyA9IGZ1bmN0aW9uIGlubGluZVRva2VucyhzcmMsIHRva2Vucykge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIGlmICh0b2tlbnMgPT09IHZvaWQgMCkge1xuICAgICAgICB0b2tlbnMgPSBbXTtcbiAgICAgIH1cblxuICAgICAgdmFyIHRva2VuLCBsYXN0VG9rZW4sIGN1dFNyYzsgLy8gU3RyaW5nIHdpdGggbGlua3MgbWFza2VkIHRvIGF2b2lkIGludGVyZmVyZW5jZSB3aXRoIGVtIGFuZCBzdHJvbmdcblxuICAgICAgdmFyIG1hc2tlZFNyYyA9IHNyYztcbiAgICAgIHZhciBtYXRjaDtcbiAgICAgIHZhciBrZWVwUHJldkNoYXIsIHByZXZDaGFyOyAvLyBNYXNrIG91dCByZWZsaW5rc1xuXG4gICAgICBpZiAodGhpcy50b2tlbnMubGlua3MpIHtcbiAgICAgICAgdmFyIGxpbmtzID0gT2JqZWN0LmtleXModGhpcy50b2tlbnMubGlua3MpO1xuXG4gICAgICAgIGlmIChsaW5rcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgd2hpbGUgKChtYXRjaCA9IHRoaXMudG9rZW5pemVyLnJ1bGVzLmlubGluZS5yZWZsaW5rU2VhcmNoLmV4ZWMobWFza2VkU3JjKSkgIT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKGxpbmtzLmluY2x1ZGVzKG1hdGNoWzBdLnNsaWNlKG1hdGNoWzBdLmxhc3RJbmRleE9mKCdbJykgKyAxLCAtMSkpKSB7XG4gICAgICAgICAgICAgIG1hc2tlZFNyYyA9IG1hc2tlZFNyYy5zbGljZSgwLCBtYXRjaC5pbmRleCkgKyAnWycgKyByZXBlYXRTdHJpbmcoJ2EnLCBtYXRjaFswXS5sZW5ndGggLSAyKSArICddJyArIG1hc2tlZFNyYy5zbGljZSh0aGlzLnRva2VuaXplci5ydWxlcy5pbmxpbmUucmVmbGlua1NlYXJjaC5sYXN0SW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSAvLyBNYXNrIG91dCBvdGhlciBibG9ja3NcblxuXG4gICAgICB3aGlsZSAoKG1hdGNoID0gdGhpcy50b2tlbml6ZXIucnVsZXMuaW5saW5lLmJsb2NrU2tpcC5leGVjKG1hc2tlZFNyYykpICE9IG51bGwpIHtcbiAgICAgICAgbWFza2VkU3JjID0gbWFza2VkU3JjLnNsaWNlKDAsIG1hdGNoLmluZGV4KSArICdbJyArIHJlcGVhdFN0cmluZygnYScsIG1hdGNoWzBdLmxlbmd0aCAtIDIpICsgJ10nICsgbWFza2VkU3JjLnNsaWNlKHRoaXMudG9rZW5pemVyLnJ1bGVzLmlubGluZS5ibG9ja1NraXAubGFzdEluZGV4KTtcbiAgICAgIH0gLy8gTWFzayBvdXQgZXNjYXBlZCBlbSAmIHN0cm9uZyBkZWxpbWl0ZXJzXG5cblxuICAgICAgd2hpbGUgKChtYXRjaCA9IHRoaXMudG9rZW5pemVyLnJ1bGVzLmlubGluZS5lc2NhcGVkRW1TdC5leGVjKG1hc2tlZFNyYykpICE9IG51bGwpIHtcbiAgICAgICAgbWFza2VkU3JjID0gbWFza2VkU3JjLnNsaWNlKDAsIG1hdGNoLmluZGV4KSArICcrKycgKyBtYXNrZWRTcmMuc2xpY2UodGhpcy50b2tlbml6ZXIucnVsZXMuaW5saW5lLmVzY2FwZWRFbVN0Lmxhc3RJbmRleCk7XG4gICAgICB9XG5cbiAgICAgIHdoaWxlIChzcmMpIHtcbiAgICAgICAgaWYgKCFrZWVwUHJldkNoYXIpIHtcbiAgICAgICAgICBwcmV2Q2hhciA9ICcnO1xuICAgICAgICB9XG5cbiAgICAgICAga2VlcFByZXZDaGFyID0gZmFsc2U7IC8vIGV4dGVuc2lvbnNcblxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmV4dGVuc2lvbnMgJiYgdGhpcy5vcHRpb25zLmV4dGVuc2lvbnMuaW5saW5lICYmIHRoaXMub3B0aW9ucy5leHRlbnNpb25zLmlubGluZS5zb21lKGZ1bmN0aW9uIChleHRUb2tlbml6ZXIpIHtcbiAgICAgICAgICBpZiAodG9rZW4gPSBleHRUb2tlbml6ZXIuY2FsbCh7XG4gICAgICAgICAgICBsZXhlcjogX3RoaXMyXG4gICAgICAgICAgfSwgc3JjLCB0b2tlbnMpKSB7XG4gICAgICAgICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKHRva2VuLnJhdy5sZW5ndGgpO1xuICAgICAgICAgICAgdG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9KSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9IC8vIGVzY2FwZVxuXG5cbiAgICAgICAgaWYgKHRva2VuID0gdGhpcy50b2tlbml6ZXIuZXNjYXBlKHNyYykpIHtcbiAgICAgICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKHRva2VuLnJhdy5sZW5ndGgpO1xuICAgICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfSAvLyB0YWdcblxuXG4gICAgICAgIGlmICh0b2tlbiA9IHRoaXMudG9rZW5pemVyLnRhZyhzcmMpKSB7XG4gICAgICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyh0b2tlbi5yYXcubGVuZ3RoKTtcbiAgICAgICAgICBsYXN0VG9rZW4gPSB0b2tlbnNbdG9rZW5zLmxlbmd0aCAtIDFdO1xuXG4gICAgICAgICAgaWYgKGxhc3RUb2tlbiAmJiB0b2tlbi50eXBlID09PSAndGV4dCcgJiYgbGFzdFRva2VuLnR5cGUgPT09ICd0ZXh0Jykge1xuICAgICAgICAgICAgbGFzdFRva2VuLnJhdyArPSB0b2tlbi5yYXc7XG4gICAgICAgICAgICBsYXN0VG9rZW4udGV4dCArPSB0b2tlbi50ZXh0O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH0gLy8gbGlua1xuXG5cbiAgICAgICAgaWYgKHRva2VuID0gdGhpcy50b2tlbml6ZXIubGluayhzcmMpKSB7XG4gICAgICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyh0b2tlbi5yYXcubGVuZ3RoKTtcbiAgICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH0gLy8gcmVmbGluaywgbm9saW5rXG5cblxuICAgICAgICBpZiAodG9rZW4gPSB0aGlzLnRva2VuaXplci5yZWZsaW5rKHNyYywgdGhpcy50b2tlbnMubGlua3MpKSB7XG4gICAgICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyh0b2tlbi5yYXcubGVuZ3RoKTtcbiAgICAgICAgICBsYXN0VG9rZW4gPSB0b2tlbnNbdG9rZW5zLmxlbmd0aCAtIDFdO1xuXG4gICAgICAgICAgaWYgKGxhc3RUb2tlbiAmJiB0b2tlbi50eXBlID09PSAndGV4dCcgJiYgbGFzdFRva2VuLnR5cGUgPT09ICd0ZXh0Jykge1xuICAgICAgICAgICAgbGFzdFRva2VuLnJhdyArPSB0b2tlbi5yYXc7XG4gICAgICAgICAgICBsYXN0VG9rZW4udGV4dCArPSB0b2tlbi50ZXh0O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH0gLy8gZW0gJiBzdHJvbmdcblxuXG4gICAgICAgIGlmICh0b2tlbiA9IHRoaXMudG9rZW5pemVyLmVtU3Ryb25nKHNyYywgbWFza2VkU3JjLCBwcmV2Q2hhcikpIHtcbiAgICAgICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKHRva2VuLnJhdy5sZW5ndGgpO1xuICAgICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfSAvLyBjb2RlXG5cblxuICAgICAgICBpZiAodG9rZW4gPSB0aGlzLnRva2VuaXplci5jb2Rlc3BhbihzcmMpKSB7XG4gICAgICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyh0b2tlbi5yYXcubGVuZ3RoKTtcbiAgICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH0gLy8gYnJcblxuXG4gICAgICAgIGlmICh0b2tlbiA9IHRoaXMudG9rZW5pemVyLmJyKHNyYykpIHtcbiAgICAgICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKHRva2VuLnJhdy5sZW5ndGgpO1xuICAgICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfSAvLyBkZWwgKGdmbSlcblxuXG4gICAgICAgIGlmICh0b2tlbiA9IHRoaXMudG9rZW5pemVyLmRlbChzcmMpKSB7XG4gICAgICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyh0b2tlbi5yYXcubGVuZ3RoKTtcbiAgICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH0gLy8gYXV0b2xpbmtcblxuXG4gICAgICAgIGlmICh0b2tlbiA9IHRoaXMudG9rZW5pemVyLmF1dG9saW5rKHNyYywgbWFuZ2xlKSkge1xuICAgICAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcodG9rZW4ucmF3Lmxlbmd0aCk7XG4gICAgICAgICAgdG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9IC8vIHVybCAoZ2ZtKVxuXG5cbiAgICAgICAgaWYgKCF0aGlzLnN0YXRlLmluTGluayAmJiAodG9rZW4gPSB0aGlzLnRva2VuaXplci51cmwoc3JjLCBtYW5nbGUpKSkge1xuICAgICAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcodG9rZW4ucmF3Lmxlbmd0aCk7XG4gICAgICAgICAgdG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9IC8vIHRleHRcbiAgICAgICAgLy8gcHJldmVudCBpbmxpbmVUZXh0IGNvbnN1bWluZyBleHRlbnNpb25zIGJ5IGNsaXBwaW5nICdzcmMnIHRvIGV4dGVuc2lvbiBzdGFydFxuXG5cbiAgICAgICAgY3V0U3JjID0gc3JjO1xuXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuZXh0ZW5zaW9ucyAmJiB0aGlzLm9wdGlvbnMuZXh0ZW5zaW9ucy5zdGFydElubGluZSkge1xuICAgICAgICAgIChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgc3RhcnRJbmRleCA9IEluZmluaXR5O1xuICAgICAgICAgICAgdmFyIHRlbXBTcmMgPSBzcmMuc2xpY2UoMSk7XG4gICAgICAgICAgICB2YXIgdGVtcFN0YXJ0ID0gdm9pZCAwO1xuXG4gICAgICAgICAgICBfdGhpczIub3B0aW9ucy5leHRlbnNpb25zLnN0YXJ0SW5saW5lLmZvckVhY2goZnVuY3Rpb24gKGdldFN0YXJ0SW5kZXgpIHtcbiAgICAgICAgICAgICAgdGVtcFN0YXJ0ID0gZ2V0U3RhcnRJbmRleC5jYWxsKHtcbiAgICAgICAgICAgICAgICBsZXhlcjogdGhpc1xuICAgICAgICAgICAgICB9LCB0ZW1wU3JjKTtcblxuICAgICAgICAgICAgICBpZiAodHlwZW9mIHRlbXBTdGFydCA9PT0gJ251bWJlcicgJiYgdGVtcFN0YXJ0ID49IDApIHtcbiAgICAgICAgICAgICAgICBzdGFydEluZGV4ID0gTWF0aC5taW4oc3RhcnRJbmRleCwgdGVtcFN0YXJ0KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGlmIChzdGFydEluZGV4IDwgSW5maW5pdHkgJiYgc3RhcnRJbmRleCA+PSAwKSB7XG4gICAgICAgICAgICAgIGN1dFNyYyA9IHNyYy5zdWJzdHJpbmcoMCwgc3RhcnRJbmRleCArIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodG9rZW4gPSB0aGlzLnRva2VuaXplci5pbmxpbmVUZXh0KGN1dFNyYywgc21hcnR5cGFudHMpKSB7XG4gICAgICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyh0b2tlbi5yYXcubGVuZ3RoKTtcblxuICAgICAgICAgIGlmICh0b2tlbi5yYXcuc2xpY2UoLTEpICE9PSAnXycpIHtcbiAgICAgICAgICAgIC8vIFRyYWNrIHByZXZDaGFyIGJlZm9yZSBzdHJpbmcgb2YgX19fXyBzdGFydGVkXG4gICAgICAgICAgICBwcmV2Q2hhciA9IHRva2VuLnJhdy5zbGljZSgtMSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAga2VlcFByZXZDaGFyID0gdHJ1ZTtcbiAgICAgICAgICBsYXN0VG9rZW4gPSB0b2tlbnNbdG9rZW5zLmxlbmd0aCAtIDFdO1xuXG4gICAgICAgICAgaWYgKGxhc3RUb2tlbiAmJiBsYXN0VG9rZW4udHlwZSA9PT0gJ3RleHQnKSB7XG4gICAgICAgICAgICBsYXN0VG9rZW4ucmF3ICs9IHRva2VuLnJhdztcbiAgICAgICAgICAgIGxhc3RUb2tlbi50ZXh0ICs9IHRva2VuLnRleHQ7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzcmMpIHtcbiAgICAgICAgICB2YXIgZXJyTXNnID0gJ0luZmluaXRlIGxvb3Agb24gYnl0ZTogJyArIHNyYy5jaGFyQ29kZUF0KDApO1xuXG4gICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5zaWxlbnQpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyTXNnKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyTXNnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRva2VucztcbiAgICB9O1xuXG4gICAgX2NyZWF0ZUNsYXNzKExleGVyLCBudWxsLCBbe1xuICAgICAga2V5OiBcInJ1bGVzXCIsXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBibG9jazogYmxvY2ssXG4gICAgICAgICAgaW5saW5lOiBpbmxpbmVcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XSk7XG5cbiAgICByZXR1cm4gTGV4ZXI7XG4gIH0oKTtcblxuICB2YXIgZGVmYXVsdHMkMiA9IGRlZmF1bHRzJDUuZXhwb3J0cy5kZWZhdWx0cztcbiAgdmFyIGNsZWFuVXJsID0gaGVscGVycy5jbGVhblVybCxcbiAgICAgIGVzY2FwZSQxID0gaGVscGVycy5lc2NhcGU7XG4gIC8qKlxuICAgKiBSZW5kZXJlclxuICAgKi9cblxuICB2YXIgUmVuZGVyZXJfMSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUmVuZGVyZXIob3B0aW9ucykge1xuICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucyB8fCBkZWZhdWx0cyQyO1xuICAgIH1cblxuICAgIHZhciBfcHJvdG8gPSBSZW5kZXJlci5wcm90b3R5cGU7XG5cbiAgICBfcHJvdG8uY29kZSA9IGZ1bmN0aW9uIGNvZGUoX2NvZGUsIGluZm9zdHJpbmcsIGVzY2FwZWQpIHtcbiAgICAgIHZhciBsYW5nID0gKGluZm9zdHJpbmcgfHwgJycpLm1hdGNoKC9cXFMqLylbMF07XG5cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuaGlnaGxpZ2h0KSB7XG4gICAgICAgIHZhciBvdXQgPSB0aGlzLm9wdGlvbnMuaGlnaGxpZ2h0KF9jb2RlLCBsYW5nKTtcblxuICAgICAgICBpZiAob3V0ICE9IG51bGwgJiYgb3V0ICE9PSBfY29kZSkge1xuICAgICAgICAgIGVzY2FwZWQgPSB0cnVlO1xuICAgICAgICAgIF9jb2RlID0gb3V0O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIF9jb2RlID0gX2NvZGUucmVwbGFjZSgvXFxuJC8sICcnKSArICdcXG4nO1xuXG4gICAgICBpZiAoIWxhbmcpIHtcbiAgICAgICAgcmV0dXJuICc8cHJlPjxjb2RlPicgKyAoZXNjYXBlZCA/IF9jb2RlIDogZXNjYXBlJDEoX2NvZGUsIHRydWUpKSArICc8L2NvZGU+PC9wcmU+XFxuJztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuICc8cHJlPjxjb2RlIGNsYXNzPVwiJyArIHRoaXMub3B0aW9ucy5sYW5nUHJlZml4ICsgZXNjYXBlJDEobGFuZywgdHJ1ZSkgKyAnXCI+JyArIChlc2NhcGVkID8gX2NvZGUgOiBlc2NhcGUkMShfY29kZSwgdHJ1ZSkpICsgJzwvY29kZT48L3ByZT5cXG4nO1xuICAgIH07XG5cbiAgICBfcHJvdG8uYmxvY2txdW90ZSA9IGZ1bmN0aW9uIGJsb2NrcXVvdGUocXVvdGUpIHtcbiAgICAgIHJldHVybiAnPGJsb2NrcXVvdGU+XFxuJyArIHF1b3RlICsgJzwvYmxvY2txdW90ZT5cXG4nO1xuICAgIH07XG5cbiAgICBfcHJvdG8uaHRtbCA9IGZ1bmN0aW9uIGh0bWwoX2h0bWwpIHtcbiAgICAgIHJldHVybiBfaHRtbDtcbiAgICB9O1xuXG4gICAgX3Byb3RvLmhlYWRpbmcgPSBmdW5jdGlvbiBoZWFkaW5nKHRleHQsIGxldmVsLCByYXcsIHNsdWdnZXIpIHtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuaGVhZGVySWRzKSB7XG4gICAgICAgIHJldHVybiAnPGgnICsgbGV2ZWwgKyAnIGlkPVwiJyArIHRoaXMub3B0aW9ucy5oZWFkZXJQcmVmaXggKyBzbHVnZ2VyLnNsdWcocmF3KSArICdcIj4nICsgdGV4dCArICc8L2gnICsgbGV2ZWwgKyAnPlxcbic7XG4gICAgICB9IC8vIGlnbm9yZSBJRHNcblxuXG4gICAgICByZXR1cm4gJzxoJyArIGxldmVsICsgJz4nICsgdGV4dCArICc8L2gnICsgbGV2ZWwgKyAnPlxcbic7XG4gICAgfTtcblxuICAgIF9wcm90by5ociA9IGZ1bmN0aW9uIGhyKCkge1xuICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy54aHRtbCA/ICc8aHIvPlxcbicgOiAnPGhyPlxcbic7XG4gICAgfTtcblxuICAgIF9wcm90by5saXN0ID0gZnVuY3Rpb24gbGlzdChib2R5LCBvcmRlcmVkLCBzdGFydCkge1xuICAgICAgdmFyIHR5cGUgPSBvcmRlcmVkID8gJ29sJyA6ICd1bCcsXG4gICAgICAgICAgc3RhcnRhdHQgPSBvcmRlcmVkICYmIHN0YXJ0ICE9PSAxID8gJyBzdGFydD1cIicgKyBzdGFydCArICdcIicgOiAnJztcbiAgICAgIHJldHVybiAnPCcgKyB0eXBlICsgc3RhcnRhdHQgKyAnPlxcbicgKyBib2R5ICsgJzwvJyArIHR5cGUgKyAnPlxcbic7XG4gICAgfTtcblxuICAgIF9wcm90by5saXN0aXRlbSA9IGZ1bmN0aW9uIGxpc3RpdGVtKHRleHQpIHtcbiAgICAgIHJldHVybiAnPGxpPicgKyB0ZXh0ICsgJzwvbGk+XFxuJztcbiAgICB9O1xuXG4gICAgX3Byb3RvLmNoZWNrYm94ID0gZnVuY3Rpb24gY2hlY2tib3goY2hlY2tlZCkge1xuICAgICAgcmV0dXJuICc8aW5wdXQgJyArIChjaGVja2VkID8gJ2NoZWNrZWQ9XCJcIiAnIDogJycpICsgJ2Rpc2FibGVkPVwiXCIgdHlwZT1cImNoZWNrYm94XCInICsgKHRoaXMub3B0aW9ucy54aHRtbCA/ICcgLycgOiAnJykgKyAnPiAnO1xuICAgIH07XG5cbiAgICBfcHJvdG8ucGFyYWdyYXBoID0gZnVuY3Rpb24gcGFyYWdyYXBoKHRleHQpIHtcbiAgICAgIHJldHVybiAnPHA+JyArIHRleHQgKyAnPC9wPlxcbic7XG4gICAgfTtcblxuICAgIF9wcm90by50YWJsZSA9IGZ1bmN0aW9uIHRhYmxlKGhlYWRlciwgYm9keSkge1xuICAgICAgaWYgKGJvZHkpIGJvZHkgPSAnPHRib2R5PicgKyBib2R5ICsgJzwvdGJvZHk+JztcbiAgICAgIHJldHVybiAnPHRhYmxlPlxcbicgKyAnPHRoZWFkPlxcbicgKyBoZWFkZXIgKyAnPC90aGVhZD5cXG4nICsgYm9keSArICc8L3RhYmxlPlxcbic7XG4gICAgfTtcblxuICAgIF9wcm90by50YWJsZXJvdyA9IGZ1bmN0aW9uIHRhYmxlcm93KGNvbnRlbnQpIHtcbiAgICAgIHJldHVybiAnPHRyPlxcbicgKyBjb250ZW50ICsgJzwvdHI+XFxuJztcbiAgICB9O1xuXG4gICAgX3Byb3RvLnRhYmxlY2VsbCA9IGZ1bmN0aW9uIHRhYmxlY2VsbChjb250ZW50LCBmbGFncykge1xuICAgICAgdmFyIHR5cGUgPSBmbGFncy5oZWFkZXIgPyAndGgnIDogJ3RkJztcbiAgICAgIHZhciB0YWcgPSBmbGFncy5hbGlnbiA/ICc8JyArIHR5cGUgKyAnIGFsaWduPVwiJyArIGZsYWdzLmFsaWduICsgJ1wiPicgOiAnPCcgKyB0eXBlICsgJz4nO1xuICAgICAgcmV0dXJuIHRhZyArIGNvbnRlbnQgKyAnPC8nICsgdHlwZSArICc+XFxuJztcbiAgICB9IC8vIHNwYW4gbGV2ZWwgcmVuZGVyZXJcbiAgICA7XG5cbiAgICBfcHJvdG8uc3Ryb25nID0gZnVuY3Rpb24gc3Ryb25nKHRleHQpIHtcbiAgICAgIHJldHVybiAnPHN0cm9uZz4nICsgdGV4dCArICc8L3N0cm9uZz4nO1xuICAgIH07XG5cbiAgICBfcHJvdG8uZW0gPSBmdW5jdGlvbiBlbSh0ZXh0KSB7XG4gICAgICByZXR1cm4gJzxlbT4nICsgdGV4dCArICc8L2VtPic7XG4gICAgfTtcblxuICAgIF9wcm90by5jb2Rlc3BhbiA9IGZ1bmN0aW9uIGNvZGVzcGFuKHRleHQpIHtcbiAgICAgIHJldHVybiAnPGNvZGU+JyArIHRleHQgKyAnPC9jb2RlPic7XG4gICAgfTtcblxuICAgIF9wcm90by5iciA9IGZ1bmN0aW9uIGJyKCkge1xuICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy54aHRtbCA/ICc8YnIvPicgOiAnPGJyPic7XG4gICAgfTtcblxuICAgIF9wcm90by5kZWwgPSBmdW5jdGlvbiBkZWwodGV4dCkge1xuICAgICAgcmV0dXJuICc8ZGVsPicgKyB0ZXh0ICsgJzwvZGVsPic7XG4gICAgfTtcblxuICAgIF9wcm90by5saW5rID0gZnVuY3Rpb24gbGluayhocmVmLCB0aXRsZSwgdGV4dCkge1xuICAgICAgaHJlZiA9IGNsZWFuVXJsKHRoaXMub3B0aW9ucy5zYW5pdGl6ZSwgdGhpcy5vcHRpb25zLmJhc2VVcmwsIGhyZWYpO1xuXG4gICAgICBpZiAoaHJlZiA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gdGV4dDtcbiAgICAgIH1cblxuICAgICAgdmFyIG91dCA9ICc8YSBocmVmPVwiJyArIGVzY2FwZSQxKGhyZWYpICsgJ1wiJztcblxuICAgICAgaWYgKHRpdGxlKSB7XG4gICAgICAgIG91dCArPSAnIHRpdGxlPVwiJyArIHRpdGxlICsgJ1wiJztcbiAgICAgIH1cblxuICAgICAgb3V0ICs9ICc+JyArIHRleHQgKyAnPC9hPic7XG4gICAgICByZXR1cm4gb3V0O1xuICAgIH07XG5cbiAgICBfcHJvdG8uaW1hZ2UgPSBmdW5jdGlvbiBpbWFnZShocmVmLCB0aXRsZSwgdGV4dCkge1xuICAgICAgaHJlZiA9IGNsZWFuVXJsKHRoaXMub3B0aW9ucy5zYW5pdGl6ZSwgdGhpcy5vcHRpb25zLmJhc2VVcmwsIGhyZWYpO1xuXG4gICAgICBpZiAoaHJlZiA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gdGV4dDtcbiAgICAgIH1cblxuICAgICAgdmFyIG91dCA9ICc8aW1nIHNyYz1cIicgKyBocmVmICsgJ1wiIGFsdD1cIicgKyB0ZXh0ICsgJ1wiJztcblxuICAgICAgaWYgKHRpdGxlKSB7XG4gICAgICAgIG91dCArPSAnIHRpdGxlPVwiJyArIHRpdGxlICsgJ1wiJztcbiAgICAgIH1cblxuICAgICAgb3V0ICs9IHRoaXMub3B0aW9ucy54aHRtbCA/ICcvPicgOiAnPic7XG4gICAgICByZXR1cm4gb3V0O1xuICAgIH07XG5cbiAgICBfcHJvdG8udGV4dCA9IGZ1bmN0aW9uIHRleHQoX3RleHQpIHtcbiAgICAgIHJldHVybiBfdGV4dDtcbiAgICB9O1xuXG4gICAgcmV0dXJuIFJlbmRlcmVyO1xuICB9KCk7XG5cbiAgLyoqXG4gICAqIFRleHRSZW5kZXJlclxuICAgKiByZXR1cm5zIG9ubHkgdGhlIHRleHR1YWwgcGFydCBvZiB0aGUgdG9rZW5cbiAgICovXG5cbiAgdmFyIFRleHRSZW5kZXJlcl8xID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBUZXh0UmVuZGVyZXIoKSB7fVxuXG4gICAgdmFyIF9wcm90byA9IFRleHRSZW5kZXJlci5wcm90b3R5cGU7XG5cbiAgICAvLyBubyBuZWVkIGZvciBibG9jayBsZXZlbCByZW5kZXJlcnNcbiAgICBfcHJvdG8uc3Ryb25nID0gZnVuY3Rpb24gc3Ryb25nKHRleHQpIHtcbiAgICAgIHJldHVybiB0ZXh0O1xuICAgIH07XG5cbiAgICBfcHJvdG8uZW0gPSBmdW5jdGlvbiBlbSh0ZXh0KSB7XG4gICAgICByZXR1cm4gdGV4dDtcbiAgICB9O1xuXG4gICAgX3Byb3RvLmNvZGVzcGFuID0gZnVuY3Rpb24gY29kZXNwYW4odGV4dCkge1xuICAgICAgcmV0dXJuIHRleHQ7XG4gICAgfTtcblxuICAgIF9wcm90by5kZWwgPSBmdW5jdGlvbiBkZWwodGV4dCkge1xuICAgICAgcmV0dXJuIHRleHQ7XG4gICAgfTtcblxuICAgIF9wcm90by5odG1sID0gZnVuY3Rpb24gaHRtbCh0ZXh0KSB7XG4gICAgICByZXR1cm4gdGV4dDtcbiAgICB9O1xuXG4gICAgX3Byb3RvLnRleHQgPSBmdW5jdGlvbiB0ZXh0KF90ZXh0KSB7XG4gICAgICByZXR1cm4gX3RleHQ7XG4gICAgfTtcblxuICAgIF9wcm90by5saW5rID0gZnVuY3Rpb24gbGluayhocmVmLCB0aXRsZSwgdGV4dCkge1xuICAgICAgcmV0dXJuICcnICsgdGV4dDtcbiAgICB9O1xuXG4gICAgX3Byb3RvLmltYWdlID0gZnVuY3Rpb24gaW1hZ2UoaHJlZiwgdGl0bGUsIHRleHQpIHtcbiAgICAgIHJldHVybiAnJyArIHRleHQ7XG4gICAgfTtcblxuICAgIF9wcm90by5iciA9IGZ1bmN0aW9uIGJyKCkge1xuICAgICAgcmV0dXJuICcnO1xuICAgIH07XG5cbiAgICByZXR1cm4gVGV4dFJlbmRlcmVyO1xuICB9KCk7XG5cbiAgLyoqXG4gICAqIFNsdWdnZXIgZ2VuZXJhdGVzIGhlYWRlciBpZFxuICAgKi9cblxuICB2YXIgU2x1Z2dlcl8xID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTbHVnZ2VyKCkge1xuICAgICAgdGhpcy5zZWVuID0ge307XG4gICAgfVxuXG4gICAgdmFyIF9wcm90byA9IFNsdWdnZXIucHJvdG90eXBlO1xuXG4gICAgX3Byb3RvLnNlcmlhbGl6ZSA9IGZ1bmN0aW9uIHNlcmlhbGl6ZSh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlLnRvTG93ZXJDYXNlKCkudHJpbSgpIC8vIHJlbW92ZSBodG1sIHRhZ3NcbiAgICAgIC5yZXBsYWNlKC88WyFcXC9hLXpdLio/Pi9pZywgJycpIC8vIHJlbW92ZSB1bndhbnRlZCBjaGFyc1xuICAgICAgLnJlcGxhY2UoL1tcXHUyMDAwLVxcdTIwNkZcXHUyRTAwLVxcdTJFN0ZcXFxcJyFcIiMkJSYoKSorLC4vOjs8PT4/QFtcXF1eYHt8fX5dL2csICcnKS5yZXBsYWNlKC9cXHMvZywgJy0nKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRmluZHMgdGhlIG5leHQgc2FmZSAodW5pcXVlKSBzbHVnIHRvIHVzZVxuICAgICAqL1xuICAgIDtcblxuICAgIF9wcm90by5nZXROZXh0U2FmZVNsdWcgPSBmdW5jdGlvbiBnZXROZXh0U2FmZVNsdWcob3JpZ2luYWxTbHVnLCBpc0RyeVJ1bikge1xuICAgICAgdmFyIHNsdWcgPSBvcmlnaW5hbFNsdWc7XG4gICAgICB2YXIgb2NjdXJlbmNlQWNjdW11bGF0b3IgPSAwO1xuXG4gICAgICBpZiAodGhpcy5zZWVuLmhhc093blByb3BlcnR5KHNsdWcpKSB7XG4gICAgICAgIG9jY3VyZW5jZUFjY3VtdWxhdG9yID0gdGhpcy5zZWVuW29yaWdpbmFsU2x1Z107XG5cbiAgICAgICAgZG8ge1xuICAgICAgICAgIG9jY3VyZW5jZUFjY3VtdWxhdG9yKys7XG4gICAgICAgICAgc2x1ZyA9IG9yaWdpbmFsU2x1ZyArICctJyArIG9jY3VyZW5jZUFjY3VtdWxhdG9yO1xuICAgICAgICB9IHdoaWxlICh0aGlzLnNlZW4uaGFzT3duUHJvcGVydHkoc2x1ZykpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWlzRHJ5UnVuKSB7XG4gICAgICAgIHRoaXMuc2VlbltvcmlnaW5hbFNsdWddID0gb2NjdXJlbmNlQWNjdW11bGF0b3I7XG4gICAgICAgIHRoaXMuc2VlbltzbHVnXSA9IDA7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzbHVnO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0IHN0cmluZyB0byB1bmlxdWUgaWRcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gb3B0aW9ucy5kcnlydW4gR2VuZXJhdGVzIHRoZSBuZXh0IHVuaXF1ZSBzbHVnIHdpdGhvdXQgdXBkYXRpbmcgdGhlIGludGVybmFsIGFjY3VtdWxhdG9yLlxuICAgICAqL1xuICAgIDtcblxuICAgIF9wcm90by5zbHVnID0gZnVuY3Rpb24gc2x1Zyh2YWx1ZSwgb3B0aW9ucykge1xuICAgICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgICAgICBvcHRpb25zID0ge307XG4gICAgICB9XG5cbiAgICAgIHZhciBzbHVnID0gdGhpcy5zZXJpYWxpemUodmFsdWUpO1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0TmV4dFNhZmVTbHVnKHNsdWcsIG9wdGlvbnMuZHJ5cnVuKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIFNsdWdnZXI7XG4gIH0oKTtcblxuICB2YXIgUmVuZGVyZXIkMSA9IFJlbmRlcmVyXzE7XG4gIHZhciBUZXh0UmVuZGVyZXIkMSA9IFRleHRSZW5kZXJlcl8xO1xuICB2YXIgU2x1Z2dlciQxID0gU2x1Z2dlcl8xO1xuICB2YXIgZGVmYXVsdHMkMSA9IGRlZmF1bHRzJDUuZXhwb3J0cy5kZWZhdWx0cztcbiAgdmFyIHVuZXNjYXBlID0gaGVscGVycy51bmVzY2FwZTtcbiAgLyoqXG4gICAqIFBhcnNpbmcgJiBDb21waWxpbmdcbiAgICovXG5cbiAgdmFyIFBhcnNlcl8xID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBQYXJzZXIob3B0aW9ucykge1xuICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucyB8fCBkZWZhdWx0cyQxO1xuICAgICAgdGhpcy5vcHRpb25zLnJlbmRlcmVyID0gdGhpcy5vcHRpb25zLnJlbmRlcmVyIHx8IG5ldyBSZW5kZXJlciQxKCk7XG4gICAgICB0aGlzLnJlbmRlcmVyID0gdGhpcy5vcHRpb25zLnJlbmRlcmVyO1xuICAgICAgdGhpcy5yZW5kZXJlci5vcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgICAgdGhpcy50ZXh0UmVuZGVyZXIgPSBuZXcgVGV4dFJlbmRlcmVyJDEoKTtcbiAgICAgIHRoaXMuc2x1Z2dlciA9IG5ldyBTbHVnZ2VyJDEoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3RhdGljIFBhcnNlIE1ldGhvZFxuICAgICAqL1xuXG5cbiAgICBQYXJzZXIucGFyc2UgPSBmdW5jdGlvbiBwYXJzZSh0b2tlbnMsIG9wdGlvbnMpIHtcbiAgICAgIHZhciBwYXJzZXIgPSBuZXcgUGFyc2VyKG9wdGlvbnMpO1xuICAgICAgcmV0dXJuIHBhcnNlci5wYXJzZSh0b2tlbnMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdGF0aWMgUGFyc2UgSW5saW5lIE1ldGhvZFxuICAgICAqL1xuICAgIDtcblxuICAgIFBhcnNlci5wYXJzZUlubGluZSA9IGZ1bmN0aW9uIHBhcnNlSW5saW5lKHRva2Vucywgb3B0aW9ucykge1xuICAgICAgdmFyIHBhcnNlciA9IG5ldyBQYXJzZXIob3B0aW9ucyk7XG4gICAgICByZXR1cm4gcGFyc2VyLnBhcnNlSW5saW5lKHRva2Vucyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBhcnNlIExvb3BcbiAgICAgKi9cbiAgICA7XG5cbiAgICB2YXIgX3Byb3RvID0gUGFyc2VyLnByb3RvdHlwZTtcblxuICAgIF9wcm90by5wYXJzZSA9IGZ1bmN0aW9uIHBhcnNlKHRva2VucywgdG9wKSB7XG4gICAgICBpZiAodG9wID09PSB2b2lkIDApIHtcbiAgICAgICAgdG9wID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgdmFyIG91dCA9ICcnLFxuICAgICAgICAgIGksXG4gICAgICAgICAgaixcbiAgICAgICAgICBrLFxuICAgICAgICAgIGwyLFxuICAgICAgICAgIGwzLFxuICAgICAgICAgIHJvdyxcbiAgICAgICAgICBjZWxsLFxuICAgICAgICAgIGhlYWRlcixcbiAgICAgICAgICBib2R5LFxuICAgICAgICAgIHRva2VuLFxuICAgICAgICAgIG9yZGVyZWQsXG4gICAgICAgICAgc3RhcnQsXG4gICAgICAgICAgbG9vc2UsXG4gICAgICAgICAgaXRlbUJvZHksXG4gICAgICAgICAgaXRlbSxcbiAgICAgICAgICBjaGVja2VkLFxuICAgICAgICAgIHRhc2ssXG4gICAgICAgICAgY2hlY2tib3gsXG4gICAgICAgICAgcmV0O1xuICAgICAgdmFyIGwgPSB0b2tlbnMubGVuZ3RoO1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIHRva2VuID0gdG9rZW5zW2ldOyAvLyBSdW4gYW55IHJlbmRlcmVyIGV4dGVuc2lvbnNcblxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmV4dGVuc2lvbnMgJiYgdGhpcy5vcHRpb25zLmV4dGVuc2lvbnMucmVuZGVyZXJzICYmIHRoaXMub3B0aW9ucy5leHRlbnNpb25zLnJlbmRlcmVyc1t0b2tlbi50eXBlXSkge1xuICAgICAgICAgIHJldCA9IHRoaXMub3B0aW9ucy5leHRlbnNpb25zLnJlbmRlcmVyc1t0b2tlbi50eXBlXS5jYWxsKHtcbiAgICAgICAgICAgIHBhcnNlcjogdGhpc1xuICAgICAgICAgIH0sIHRva2VuKTtcblxuICAgICAgICAgIGlmIChyZXQgIT09IGZhbHNlIHx8ICFbJ3NwYWNlJywgJ2hyJywgJ2hlYWRpbmcnLCAnY29kZScsICd0YWJsZScsICdibG9ja3F1b3RlJywgJ2xpc3QnLCAnaHRtbCcsICdwYXJhZ3JhcGgnLCAndGV4dCddLmluY2x1ZGVzKHRva2VuLnR5cGUpKSB7XG4gICAgICAgICAgICBvdXQgKz0gcmV0IHx8ICcnO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgc3dpdGNoICh0b2tlbi50eXBlKSB7XG4gICAgICAgICAgY2FzZSAnc3BhY2UnOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIGNhc2UgJ2hyJzpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgb3V0ICs9IHRoaXMucmVuZGVyZXIuaHIoKTtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICBjYXNlICdoZWFkaW5nJzpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgb3V0ICs9IHRoaXMucmVuZGVyZXIuaGVhZGluZyh0aGlzLnBhcnNlSW5saW5lKHRva2VuLnRva2VucyksIHRva2VuLmRlcHRoLCB1bmVzY2FwZSh0aGlzLnBhcnNlSW5saW5lKHRva2VuLnRva2VucywgdGhpcy50ZXh0UmVuZGVyZXIpKSwgdGhpcy5zbHVnZ2VyKTtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICBjYXNlICdjb2RlJzpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgb3V0ICs9IHRoaXMucmVuZGVyZXIuY29kZSh0b2tlbi50ZXh0LCB0b2tlbi5sYW5nLCB0b2tlbi5lc2NhcGVkKTtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICBjYXNlICd0YWJsZSc6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGhlYWRlciA9ICcnOyAvLyBoZWFkZXJcblxuICAgICAgICAgICAgICBjZWxsID0gJyc7XG4gICAgICAgICAgICAgIGwyID0gdG9rZW4uaGVhZGVyLmxlbmd0aDtcblxuICAgICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgbDI7IGorKykge1xuICAgICAgICAgICAgICAgIGNlbGwgKz0gdGhpcy5yZW5kZXJlci50YWJsZWNlbGwodGhpcy5wYXJzZUlubGluZSh0b2tlbi5oZWFkZXJbal0udG9rZW5zKSwge1xuICAgICAgICAgICAgICAgICAgaGVhZGVyOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgYWxpZ246IHRva2VuLmFsaWduW2pdXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBoZWFkZXIgKz0gdGhpcy5yZW5kZXJlci50YWJsZXJvdyhjZWxsKTtcbiAgICAgICAgICAgICAgYm9keSA9ICcnO1xuICAgICAgICAgICAgICBsMiA9IHRva2VuLnJvd3MubGVuZ3RoO1xuXG4gICAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBsMjsgaisrKSB7XG4gICAgICAgICAgICAgICAgcm93ID0gdG9rZW4ucm93c1tqXTtcbiAgICAgICAgICAgICAgICBjZWxsID0gJyc7XG4gICAgICAgICAgICAgICAgbDMgPSByb3cubGVuZ3RoO1xuXG4gICAgICAgICAgICAgICAgZm9yIChrID0gMDsgayA8IGwzOyBrKyspIHtcbiAgICAgICAgICAgICAgICAgIGNlbGwgKz0gdGhpcy5yZW5kZXJlci50YWJsZWNlbGwodGhpcy5wYXJzZUlubGluZShyb3dba10udG9rZW5zKSwge1xuICAgICAgICAgICAgICAgICAgICBoZWFkZXI6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBhbGlnbjogdG9rZW4uYWxpZ25ba11cbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGJvZHkgKz0gdGhpcy5yZW5kZXJlci50YWJsZXJvdyhjZWxsKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIG91dCArPSB0aGlzLnJlbmRlcmVyLnRhYmxlKGhlYWRlciwgYm9keSk7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgY2FzZSAnYmxvY2txdW90ZSc6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGJvZHkgPSB0aGlzLnBhcnNlKHRva2VuLnRva2Vucyk7XG4gICAgICAgICAgICAgIG91dCArPSB0aGlzLnJlbmRlcmVyLmJsb2NrcXVvdGUoYm9keSk7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgY2FzZSAnbGlzdCc6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIG9yZGVyZWQgPSB0b2tlbi5vcmRlcmVkO1xuICAgICAgICAgICAgICBzdGFydCA9IHRva2VuLnN0YXJ0O1xuICAgICAgICAgICAgICBsb29zZSA9IHRva2VuLmxvb3NlO1xuICAgICAgICAgICAgICBsMiA9IHRva2VuLml0ZW1zLmxlbmd0aDtcbiAgICAgICAgICAgICAgYm9keSA9ICcnO1xuXG4gICAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBsMjsgaisrKSB7XG4gICAgICAgICAgICAgICAgaXRlbSA9IHRva2VuLml0ZW1zW2pdO1xuICAgICAgICAgICAgICAgIGNoZWNrZWQgPSBpdGVtLmNoZWNrZWQ7XG4gICAgICAgICAgICAgICAgdGFzayA9IGl0ZW0udGFzaztcbiAgICAgICAgICAgICAgICBpdGVtQm9keSA9ICcnO1xuXG4gICAgICAgICAgICAgICAgaWYgKGl0ZW0udGFzaykge1xuICAgICAgICAgICAgICAgICAgY2hlY2tib3ggPSB0aGlzLnJlbmRlcmVyLmNoZWNrYm94KGNoZWNrZWQpO1xuXG4gICAgICAgICAgICAgICAgICBpZiAobG9vc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGl0ZW0udG9rZW5zLmxlbmd0aCA+IDAgJiYgaXRlbS50b2tlbnNbMF0udHlwZSA9PT0gJ3BhcmFncmFwaCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICBpdGVtLnRva2Vuc1swXS50ZXh0ID0gY2hlY2tib3ggKyAnICcgKyBpdGVtLnRva2Vuc1swXS50ZXh0O1xuXG4gICAgICAgICAgICAgICAgICAgICAgaWYgKGl0ZW0udG9rZW5zWzBdLnRva2VucyAmJiBpdGVtLnRva2Vuc1swXS50b2tlbnMubGVuZ3RoID4gMCAmJiBpdGVtLnRva2Vuc1swXS50b2tlbnNbMF0udHlwZSA9PT0gJ3RleHQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpdGVtLnRva2Vuc1swXS50b2tlbnNbMF0udGV4dCA9IGNoZWNrYm94ICsgJyAnICsgaXRlbS50b2tlbnNbMF0udG9rZW5zWzBdLnRleHQ7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgIGl0ZW0udG9rZW5zLnVuc2hpZnQoe1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3RleHQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dDogY2hlY2tib3hcbiAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaXRlbUJvZHkgKz0gY2hlY2tib3g7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaXRlbUJvZHkgKz0gdGhpcy5wYXJzZShpdGVtLnRva2VucywgbG9vc2UpO1xuICAgICAgICAgICAgICAgIGJvZHkgKz0gdGhpcy5yZW5kZXJlci5saXN0aXRlbShpdGVtQm9keSwgdGFzaywgY2hlY2tlZCk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBvdXQgKz0gdGhpcy5yZW5kZXJlci5saXN0KGJvZHksIG9yZGVyZWQsIHN0YXJ0KTtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICBjYXNlICdodG1sJzpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgLy8gVE9ETyBwYXJzZSBpbmxpbmUgY29udGVudCBpZiBwYXJhbWV0ZXIgbWFya2Rvd249MVxuICAgICAgICAgICAgICBvdXQgKz0gdGhpcy5yZW5kZXJlci5odG1sKHRva2VuLnRleHQpO1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIGNhc2UgJ3BhcmFncmFwaCc6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIG91dCArPSB0aGlzLnJlbmRlcmVyLnBhcmFncmFwaCh0aGlzLnBhcnNlSW5saW5lKHRva2VuLnRva2VucykpO1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIGNhc2UgJ3RleHQnOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBib2R5ID0gdG9rZW4udG9rZW5zID8gdGhpcy5wYXJzZUlubGluZSh0b2tlbi50b2tlbnMpIDogdG9rZW4udGV4dDtcblxuICAgICAgICAgICAgICB3aGlsZSAoaSArIDEgPCBsICYmIHRva2Vuc1tpICsgMV0udHlwZSA9PT0gJ3RleHQnKSB7XG4gICAgICAgICAgICAgICAgdG9rZW4gPSB0b2tlbnNbKytpXTtcbiAgICAgICAgICAgICAgICBib2R5ICs9ICdcXG4nICsgKHRva2VuLnRva2VucyA/IHRoaXMucGFyc2VJbmxpbmUodG9rZW4udG9rZW5zKSA6IHRva2VuLnRleHQpO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgb3V0ICs9IHRvcCA/IHRoaXMucmVuZGVyZXIucGFyYWdyYXBoKGJvZHkpIDogYm9keTtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICB2YXIgZXJyTXNnID0gJ1Rva2VuIHdpdGggXCInICsgdG9rZW4udHlwZSArICdcIiB0eXBlIHdhcyBub3QgZm91bmQuJztcblxuICAgICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLnNpbGVudCkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyTXNnKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVyck1zZyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gb3V0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQYXJzZSBJbmxpbmUgVG9rZW5zXG4gICAgICovXG4gICAgO1xuXG4gICAgX3Byb3RvLnBhcnNlSW5saW5lID0gZnVuY3Rpb24gcGFyc2VJbmxpbmUodG9rZW5zLCByZW5kZXJlcikge1xuICAgICAgcmVuZGVyZXIgPSByZW5kZXJlciB8fCB0aGlzLnJlbmRlcmVyO1xuICAgICAgdmFyIG91dCA9ICcnLFxuICAgICAgICAgIGksXG4gICAgICAgICAgdG9rZW4sXG4gICAgICAgICAgcmV0O1xuICAgICAgdmFyIGwgPSB0b2tlbnMubGVuZ3RoO1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIHRva2VuID0gdG9rZW5zW2ldOyAvLyBSdW4gYW55IHJlbmRlcmVyIGV4dGVuc2lvbnNcblxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmV4dGVuc2lvbnMgJiYgdGhpcy5vcHRpb25zLmV4dGVuc2lvbnMucmVuZGVyZXJzICYmIHRoaXMub3B0aW9ucy5leHRlbnNpb25zLnJlbmRlcmVyc1t0b2tlbi50eXBlXSkge1xuICAgICAgICAgIHJldCA9IHRoaXMub3B0aW9ucy5leHRlbnNpb25zLnJlbmRlcmVyc1t0b2tlbi50eXBlXS5jYWxsKHtcbiAgICAgICAgICAgIHBhcnNlcjogdGhpc1xuICAgICAgICAgIH0sIHRva2VuKTtcblxuICAgICAgICAgIGlmIChyZXQgIT09IGZhbHNlIHx8ICFbJ2VzY2FwZScsICdodG1sJywgJ2xpbmsnLCAnaW1hZ2UnLCAnc3Ryb25nJywgJ2VtJywgJ2NvZGVzcGFuJywgJ2JyJywgJ2RlbCcsICd0ZXh0J10uaW5jbHVkZXModG9rZW4udHlwZSkpIHtcbiAgICAgICAgICAgIG91dCArPSByZXQgfHwgJyc7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBzd2l0Y2ggKHRva2VuLnR5cGUpIHtcbiAgICAgICAgICBjYXNlICdlc2NhcGUnOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBvdXQgKz0gcmVuZGVyZXIudGV4dCh0b2tlbi50ZXh0KTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICBjYXNlICdodG1sJzpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgb3V0ICs9IHJlbmRlcmVyLmh0bWwodG9rZW4udGV4dCk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgY2FzZSAnbGluayc6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIG91dCArPSByZW5kZXJlci5saW5rKHRva2VuLmhyZWYsIHRva2VuLnRpdGxlLCB0aGlzLnBhcnNlSW5saW5lKHRva2VuLnRva2VucywgcmVuZGVyZXIpKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICBjYXNlICdpbWFnZSc6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIG91dCArPSByZW5kZXJlci5pbWFnZSh0b2tlbi5ocmVmLCB0b2tlbi50aXRsZSwgdG9rZW4udGV4dCk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgY2FzZSAnc3Ryb25nJzpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgb3V0ICs9IHJlbmRlcmVyLnN0cm9uZyh0aGlzLnBhcnNlSW5saW5lKHRva2VuLnRva2VucywgcmVuZGVyZXIpKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICBjYXNlICdlbSc6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIG91dCArPSByZW5kZXJlci5lbSh0aGlzLnBhcnNlSW5saW5lKHRva2VuLnRva2VucywgcmVuZGVyZXIpKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICBjYXNlICdjb2Rlc3Bhbic6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIG91dCArPSByZW5kZXJlci5jb2Rlc3Bhbih0b2tlbi50ZXh0KTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICBjYXNlICdicic6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIG91dCArPSByZW5kZXJlci5icigpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIGNhc2UgJ2RlbCc6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIG91dCArPSByZW5kZXJlci5kZWwodGhpcy5wYXJzZUlubGluZSh0b2tlbi50b2tlbnMsIHJlbmRlcmVyKSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgY2FzZSAndGV4dCc6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIG91dCArPSByZW5kZXJlci50ZXh0KHRva2VuLnRleHQpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHZhciBlcnJNc2cgPSAnVG9rZW4gd2l0aCBcIicgKyB0b2tlbi50eXBlICsgJ1wiIHR5cGUgd2FzIG5vdCBmb3VuZC4nO1xuXG4gICAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuc2lsZW50KSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihlcnJNc2cpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyTXNnKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBvdXQ7XG4gICAgfTtcblxuICAgIHJldHVybiBQYXJzZXI7XG4gIH0oKTtcblxuICB2YXIgTGV4ZXIgPSBMZXhlcl8xO1xuICB2YXIgUGFyc2VyID0gUGFyc2VyXzE7XG4gIHZhciBUb2tlbml6ZXIgPSBUb2tlbml6ZXJfMTtcbiAgdmFyIFJlbmRlcmVyID0gUmVuZGVyZXJfMTtcbiAgdmFyIFRleHRSZW5kZXJlciA9IFRleHRSZW5kZXJlcl8xO1xuICB2YXIgU2x1Z2dlciA9IFNsdWdnZXJfMTtcbiAgdmFyIG1lcmdlID0gaGVscGVycy5tZXJnZSxcbiAgICAgIGNoZWNrU2FuaXRpemVEZXByZWNhdGlvbiA9IGhlbHBlcnMuY2hlY2tTYW5pdGl6ZURlcHJlY2F0aW9uLFxuICAgICAgZXNjYXBlID0gaGVscGVycy5lc2NhcGU7XG4gIHZhciBnZXREZWZhdWx0cyA9IGRlZmF1bHRzJDUuZXhwb3J0cy5nZXREZWZhdWx0cyxcbiAgICAgIGNoYW5nZURlZmF1bHRzID0gZGVmYXVsdHMkNS5leHBvcnRzLmNoYW5nZURlZmF1bHRzLFxuICAgICAgZGVmYXVsdHMgPSBkZWZhdWx0cyQ1LmV4cG9ydHMuZGVmYXVsdHM7XG4gIC8qKlxuICAgKiBNYXJrZWRcbiAgICovXG5cbiAgZnVuY3Rpb24gbWFya2VkKHNyYywgb3B0LCBjYWxsYmFjaykge1xuICAgIC8vIHRocm93IGVycm9yIGluIGNhc2Ugb2Ygbm9uIHN0cmluZyBpbnB1dFxuICAgIGlmICh0eXBlb2Ygc3JjID09PSAndW5kZWZpbmVkJyB8fCBzcmMgPT09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignbWFya2VkKCk6IGlucHV0IHBhcmFtZXRlciBpcyB1bmRlZmluZWQgb3IgbnVsbCcpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2Ygc3JjICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdtYXJrZWQoKTogaW5wdXQgcGFyYW1ldGVyIGlzIG9mIHR5cGUgJyArIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChzcmMpICsgJywgc3RyaW5nIGV4cGVjdGVkJyk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBvcHQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNhbGxiYWNrID0gb3B0O1xuICAgICAgb3B0ID0gbnVsbDtcbiAgICB9XG5cbiAgICBvcHQgPSBtZXJnZSh7fSwgbWFya2VkLmRlZmF1bHRzLCBvcHQgfHwge30pO1xuICAgIGNoZWNrU2FuaXRpemVEZXByZWNhdGlvbihvcHQpO1xuXG4gICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICB2YXIgaGlnaGxpZ2h0ID0gb3B0LmhpZ2hsaWdodDtcbiAgICAgIHZhciB0b2tlbnM7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHRva2VucyA9IExleGVyLmxleChzcmMsIG9wdCk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjayhlKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGRvbmUgPSBmdW5jdGlvbiBkb25lKGVycikge1xuICAgICAgICB2YXIgb3V0O1xuXG4gICAgICAgIGlmICghZXJyKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmIChvcHQud2Fsa1Rva2Vucykge1xuICAgICAgICAgICAgICBtYXJrZWQud2Fsa1Rva2Vucyh0b2tlbnMsIG9wdC53YWxrVG9rZW5zKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgb3V0ID0gUGFyc2VyLnBhcnNlKHRva2Vucywgb3B0KTtcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBlcnIgPSBlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIG9wdC5oaWdobGlnaHQgPSBoaWdobGlnaHQ7XG4gICAgICAgIHJldHVybiBlcnIgPyBjYWxsYmFjayhlcnIpIDogY2FsbGJhY2sobnVsbCwgb3V0KTtcbiAgICAgIH07XG5cbiAgICAgIGlmICghaGlnaGxpZ2h0IHx8IGhpZ2hsaWdodC5sZW5ndGggPCAzKSB7XG4gICAgICAgIHJldHVybiBkb25lKCk7XG4gICAgICB9XG5cbiAgICAgIGRlbGV0ZSBvcHQuaGlnaGxpZ2h0O1xuICAgICAgaWYgKCF0b2tlbnMubGVuZ3RoKSByZXR1cm4gZG9uZSgpO1xuICAgICAgdmFyIHBlbmRpbmcgPSAwO1xuICAgICAgbWFya2VkLndhbGtUb2tlbnModG9rZW5zLCBmdW5jdGlvbiAodG9rZW4pIHtcbiAgICAgICAgaWYgKHRva2VuLnR5cGUgPT09ICdjb2RlJykge1xuICAgICAgICAgIHBlbmRpbmcrKztcbiAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGhpZ2hsaWdodCh0b2tlbi50ZXh0LCB0b2tlbi5sYW5nLCBmdW5jdGlvbiAoZXJyLCBjb2RlKSB7XG4gICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZG9uZShlcnIpO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaWYgKGNvZGUgIT0gbnVsbCAmJiBjb2RlICE9PSB0b2tlbi50ZXh0KSB7XG4gICAgICAgICAgICAgICAgdG9rZW4udGV4dCA9IGNvZGU7XG4gICAgICAgICAgICAgICAgdG9rZW4uZXNjYXBlZCA9IHRydWU7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBwZW5kaW5nLS07XG5cbiAgICAgICAgICAgICAgaWYgKHBlbmRpbmcgPT09IDApIHtcbiAgICAgICAgICAgICAgICBkb25lKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0sIDApO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgaWYgKHBlbmRpbmcgPT09IDApIHtcbiAgICAgICAgZG9uZSgpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIHZhciBfdG9rZW5zID0gTGV4ZXIubGV4KHNyYywgb3B0KTtcblxuICAgICAgaWYgKG9wdC53YWxrVG9rZW5zKSB7XG4gICAgICAgIG1hcmtlZC53YWxrVG9rZW5zKF90b2tlbnMsIG9wdC53YWxrVG9rZW5zKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIFBhcnNlci5wYXJzZShfdG9rZW5zLCBvcHQpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGUubWVzc2FnZSArPSAnXFxuUGxlYXNlIHJlcG9ydCB0aGlzIHRvIGh0dHBzOi8vZ2l0aHViLmNvbS9tYXJrZWRqcy9tYXJrZWQuJztcblxuICAgICAgaWYgKG9wdC5zaWxlbnQpIHtcbiAgICAgICAgcmV0dXJuICc8cD5BbiBlcnJvciBvY2N1cnJlZDo8L3A+PHByZT4nICsgZXNjYXBlKGUubWVzc2FnZSArICcnLCB0cnVlKSArICc8L3ByZT4nO1xuICAgICAgfVxuXG4gICAgICB0aHJvdyBlO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogT3B0aW9uc1xuICAgKi9cblxuXG4gIG1hcmtlZC5vcHRpb25zID0gbWFya2VkLnNldE9wdGlvbnMgPSBmdW5jdGlvbiAob3B0KSB7XG4gICAgbWVyZ2UobWFya2VkLmRlZmF1bHRzLCBvcHQpO1xuICAgIGNoYW5nZURlZmF1bHRzKG1hcmtlZC5kZWZhdWx0cyk7XG4gICAgcmV0dXJuIG1hcmtlZDtcbiAgfTtcblxuICBtYXJrZWQuZ2V0RGVmYXVsdHMgPSBnZXREZWZhdWx0cztcbiAgbWFya2VkLmRlZmF1bHRzID0gZGVmYXVsdHM7XG4gIC8qKlxuICAgKiBVc2UgRXh0ZW5zaW9uXG4gICAqL1xuXG4gIG1hcmtlZC51c2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICB2YXIgb3B0cyA9IG1lcmdlLmFwcGx5KHZvaWQgMCwgW3t9XS5jb25jYXQoYXJncykpO1xuICAgIHZhciBleHRlbnNpb25zID0gbWFya2VkLmRlZmF1bHRzLmV4dGVuc2lvbnMgfHwge1xuICAgICAgcmVuZGVyZXJzOiB7fSxcbiAgICAgIGNoaWxkVG9rZW5zOiB7fVxuICAgIH07XG4gICAgdmFyIGhhc0V4dGVuc2lvbnM7XG4gICAgYXJncy5mb3JFYWNoKGZ1bmN0aW9uIChwYWNrKSB7XG4gICAgICAvLyA9PS0tIFBhcnNlIFwiYWRkb25cIiBleHRlbnNpb25zIC0tPT0gLy9cbiAgICAgIGlmIChwYWNrLmV4dGVuc2lvbnMpIHtcbiAgICAgICAgaGFzRXh0ZW5zaW9ucyA9IHRydWU7XG4gICAgICAgIHBhY2suZXh0ZW5zaW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChleHQpIHtcbiAgICAgICAgICBpZiAoIWV4dC5uYW1lKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2V4dGVuc2lvbiBuYW1lIHJlcXVpcmVkJyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGV4dC5yZW5kZXJlcikge1xuICAgICAgICAgICAgLy8gUmVuZGVyZXIgZXh0ZW5zaW9uc1xuICAgICAgICAgICAgdmFyIHByZXZSZW5kZXJlciA9IGV4dGVuc2lvbnMucmVuZGVyZXJzID8gZXh0ZW5zaW9ucy5yZW5kZXJlcnNbZXh0Lm5hbWVdIDogbnVsbDtcblxuICAgICAgICAgICAgaWYgKHByZXZSZW5kZXJlcikge1xuICAgICAgICAgICAgICAvLyBSZXBsYWNlIGV4dGVuc2lvbiB3aXRoIGZ1bmMgdG8gcnVuIG5ldyBleHRlbnNpb24gYnV0IGZhbGwgYmFjayBpZiBmYWxzZVxuICAgICAgICAgICAgICBleHRlbnNpb25zLnJlbmRlcmVyc1tleHQubmFtZV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4yKSwgX2tleTIgPSAwOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgICAgICAgICAgICAgICBhcmdzW19rZXkyXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIHJldCA9IGV4dC5yZW5kZXJlci5hcHBseSh0aGlzLCBhcmdzKTtcblxuICAgICAgICAgICAgICAgIGlmIChyZXQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICByZXQgPSBwcmV2UmVuZGVyZXIuYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGV4dGVuc2lvbnMucmVuZGVyZXJzW2V4dC5uYW1lXSA9IGV4dC5yZW5kZXJlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoZXh0LnRva2VuaXplcikge1xuICAgICAgICAgICAgLy8gVG9rZW5pemVyIEV4dGVuc2lvbnNcbiAgICAgICAgICAgIGlmICghZXh0LmxldmVsIHx8IGV4dC5sZXZlbCAhPT0gJ2Jsb2NrJyAmJiBleHQubGV2ZWwgIT09ICdpbmxpbmUnKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImV4dGVuc2lvbiBsZXZlbCBtdXN0IGJlICdibG9jaycgb3IgJ2lubGluZSdcIik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChleHRlbnNpb25zW2V4dC5sZXZlbF0pIHtcbiAgICAgICAgICAgICAgZXh0ZW5zaW9uc1tleHQubGV2ZWxdLnVuc2hpZnQoZXh0LnRva2VuaXplcik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBleHRlbnNpb25zW2V4dC5sZXZlbF0gPSBbZXh0LnRva2VuaXplcl07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChleHQuc3RhcnQpIHtcbiAgICAgICAgICAgICAgLy8gRnVuY3Rpb24gdG8gY2hlY2sgZm9yIHN0YXJ0IG9mIHRva2VuXG4gICAgICAgICAgICAgIGlmIChleHQubGV2ZWwgPT09ICdibG9jaycpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXh0ZW5zaW9ucy5zdGFydEJsb2NrKSB7XG4gICAgICAgICAgICAgICAgICBleHRlbnNpb25zLnN0YXJ0QmxvY2sucHVzaChleHQuc3RhcnQpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBleHRlbnNpb25zLnN0YXJ0QmxvY2sgPSBbZXh0LnN0YXJ0XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoZXh0LmxldmVsID09PSAnaW5saW5lJykge1xuICAgICAgICAgICAgICAgIGlmIChleHRlbnNpb25zLnN0YXJ0SW5saW5lKSB7XG4gICAgICAgICAgICAgICAgICBleHRlbnNpb25zLnN0YXJ0SW5saW5lLnB1c2goZXh0LnN0YXJ0KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgZXh0ZW5zaW9ucy5zdGFydElubGluZSA9IFtleHQuc3RhcnRdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChleHQuY2hpbGRUb2tlbnMpIHtcbiAgICAgICAgICAgIC8vIENoaWxkIHRva2VucyB0byBiZSB2aXNpdGVkIGJ5IHdhbGtUb2tlbnNcbiAgICAgICAgICAgIGV4dGVuc2lvbnMuY2hpbGRUb2tlbnNbZXh0Lm5hbWVdID0gZXh0LmNoaWxkVG9rZW5zO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9IC8vID09LS0gUGFyc2UgXCJvdmVyd3JpdGVcIiBleHRlbnNpb25zIC0tPT0gLy9cblxuXG4gICAgICBpZiAocGFjay5yZW5kZXJlcikge1xuICAgICAgICAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciByZW5kZXJlciA9IG1hcmtlZC5kZWZhdWx0cy5yZW5kZXJlciB8fCBuZXcgUmVuZGVyZXIoKTtcblxuICAgICAgICAgIHZhciBfbG9vcCA9IGZ1bmN0aW9uIF9sb29wKHByb3ApIHtcbiAgICAgICAgICAgIHZhciBwcmV2UmVuZGVyZXIgPSByZW5kZXJlcltwcm9wXTsgLy8gUmVwbGFjZSByZW5kZXJlciB3aXRoIGZ1bmMgdG8gcnVuIGV4dGVuc2lvbiwgYnV0IGZhbGwgYmFjayBpZiBmYWxzZVxuXG4gICAgICAgICAgICByZW5kZXJlcltwcm9wXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgZm9yICh2YXIgX2xlbjMgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4zKSwgX2tleTMgPSAwOyBfa2V5MyA8IF9sZW4zOyBfa2V5MysrKSB7XG4gICAgICAgICAgICAgICAgYXJnc1tfa2V5M10gPSBhcmd1bWVudHNbX2tleTNdO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgdmFyIHJldCA9IHBhY2sucmVuZGVyZXJbcHJvcF0uYXBwbHkocmVuZGVyZXIsIGFyZ3MpO1xuXG4gICAgICAgICAgICAgIGlmIChyZXQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgcmV0ID0gcHJldlJlbmRlcmVyLmFwcGx5KHJlbmRlcmVyLCBhcmdzKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH07XG5cbiAgICAgICAgICBmb3IgKHZhciBwcm9wIGluIHBhY2sucmVuZGVyZXIpIHtcbiAgICAgICAgICAgIF9sb29wKHByb3ApO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIG9wdHMucmVuZGVyZXIgPSByZW5kZXJlcjtcbiAgICAgICAgfSkoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHBhY2sudG9rZW5pemVyKSB7XG4gICAgICAgIChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyIHRva2VuaXplciA9IG1hcmtlZC5kZWZhdWx0cy50b2tlbml6ZXIgfHwgbmV3IFRva2VuaXplcigpO1xuXG4gICAgICAgICAgdmFyIF9sb29wMiA9IGZ1bmN0aW9uIF9sb29wMihwcm9wKSB7XG4gICAgICAgICAgICB2YXIgcHJldlRva2VuaXplciA9IHRva2VuaXplcltwcm9wXTsgLy8gUmVwbGFjZSB0b2tlbml6ZXIgd2l0aCBmdW5jIHRvIHJ1biBleHRlbnNpb24sIGJ1dCBmYWxsIGJhY2sgaWYgZmFsc2VcblxuICAgICAgICAgICAgdG9rZW5pemVyW3Byb3BdID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICBmb3IgKHZhciBfbGVuNCA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjQpLCBfa2V5NCA9IDA7IF9rZXk0IDwgX2xlbjQ7IF9rZXk0KyspIHtcbiAgICAgICAgICAgICAgICBhcmdzW19rZXk0XSA9IGFyZ3VtZW50c1tfa2V5NF07XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICB2YXIgcmV0ID0gcGFjay50b2tlbml6ZXJbcHJvcF0uYXBwbHkodG9rZW5pemVyLCBhcmdzKTtcblxuICAgICAgICAgICAgICBpZiAocmV0ID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIHJldCA9IHByZXZUb2tlbml6ZXIuYXBwbHkodG9rZW5pemVyLCBhcmdzKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH07XG5cbiAgICAgICAgICBmb3IgKHZhciBwcm9wIGluIHBhY2sudG9rZW5pemVyKSB7XG4gICAgICAgICAgICBfbG9vcDIocHJvcCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgb3B0cy50b2tlbml6ZXIgPSB0b2tlbml6ZXI7XG4gICAgICAgIH0pKCk7XG4gICAgICB9IC8vID09LS0gUGFyc2UgV2Fsa1Rva2VucyBleHRlbnNpb25zIC0tPT0gLy9cblxuXG4gICAgICBpZiAocGFjay53YWxrVG9rZW5zKSB7XG4gICAgICAgIHZhciB3YWxrVG9rZW5zID0gbWFya2VkLmRlZmF1bHRzLndhbGtUb2tlbnM7XG5cbiAgICAgICAgb3B0cy53YWxrVG9rZW5zID0gZnVuY3Rpb24gKHRva2VuKSB7XG4gICAgICAgICAgcGFjay53YWxrVG9rZW5zLmNhbGwoX3RoaXMsIHRva2VuKTtcblxuICAgICAgICAgIGlmICh3YWxrVG9rZW5zKSB7XG4gICAgICAgICAgICB3YWxrVG9rZW5zKHRva2VuKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIGlmIChoYXNFeHRlbnNpb25zKSB7XG4gICAgICAgIG9wdHMuZXh0ZW5zaW9ucyA9IGV4dGVuc2lvbnM7XG4gICAgICB9XG5cbiAgICAgIG1hcmtlZC5zZXRPcHRpb25zKG9wdHMpO1xuICAgIH0pO1xuICB9O1xuICAvKipcbiAgICogUnVuIGNhbGxiYWNrIGZvciBldmVyeSB0b2tlblxuICAgKi9cblxuXG4gIG1hcmtlZC53YWxrVG9rZW5zID0gZnVuY3Rpb24gKHRva2VucywgY2FsbGJhY2spIHtcbiAgICB2YXIgX2xvb3AzID0gZnVuY3Rpb24gX2xvb3AzKCkge1xuICAgICAgdmFyIHRva2VuID0gX3N0ZXAudmFsdWU7XG4gICAgICBjYWxsYmFjayh0b2tlbik7XG5cbiAgICAgIHN3aXRjaCAodG9rZW4udHlwZSkge1xuICAgICAgICBjYXNlICd0YWJsZSc6XG4gICAgICAgICAge1xuICAgICAgICAgICAgZm9yICh2YXIgX2l0ZXJhdG9yMiA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyTG9vc2UodG9rZW4uaGVhZGVyKSwgX3N0ZXAyOyAhKF9zdGVwMiA9IF9pdGVyYXRvcjIoKSkuZG9uZTspIHtcbiAgICAgICAgICAgICAgdmFyIGNlbGwgPSBfc3RlcDIudmFsdWU7XG4gICAgICAgICAgICAgIG1hcmtlZC53YWxrVG9rZW5zKGNlbGwudG9rZW5zLCBjYWxsYmFjayk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvciAodmFyIF9pdGVyYXRvcjMgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlckxvb3NlKHRva2VuLnJvd3MpLCBfc3RlcDM7ICEoX3N0ZXAzID0gX2l0ZXJhdG9yMygpKS5kb25lOykge1xuICAgICAgICAgICAgICB2YXIgcm93ID0gX3N0ZXAzLnZhbHVlO1xuXG4gICAgICAgICAgICAgIGZvciAodmFyIF9pdGVyYXRvcjQgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlckxvb3NlKHJvdyksIF9zdGVwNDsgIShfc3RlcDQgPSBfaXRlcmF0b3I0KCkpLmRvbmU7KSB7XG4gICAgICAgICAgICAgICAgdmFyIF9jZWxsID0gX3N0ZXA0LnZhbHVlO1xuICAgICAgICAgICAgICAgIG1hcmtlZC53YWxrVG9rZW5zKF9jZWxsLnRva2VucywgY2FsbGJhY2spO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlICdsaXN0JzpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBtYXJrZWQud2Fsa1Rva2Vucyh0b2tlbi5pdGVtcywgY2FsbGJhY2spO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAge1xuICAgICAgICAgICAgaWYgKG1hcmtlZC5kZWZhdWx0cy5leHRlbnNpb25zICYmIG1hcmtlZC5kZWZhdWx0cy5leHRlbnNpb25zLmNoaWxkVG9rZW5zICYmIG1hcmtlZC5kZWZhdWx0cy5leHRlbnNpb25zLmNoaWxkVG9rZW5zW3Rva2VuLnR5cGVdKSB7XG4gICAgICAgICAgICAgIC8vIFdhbGsgYW55IGV4dGVuc2lvbnNcbiAgICAgICAgICAgICAgbWFya2VkLmRlZmF1bHRzLmV4dGVuc2lvbnMuY2hpbGRUb2tlbnNbdG9rZW4udHlwZV0uZm9yRWFjaChmdW5jdGlvbiAoY2hpbGRUb2tlbnMpIHtcbiAgICAgICAgICAgICAgICBtYXJrZWQud2Fsa1Rva2Vucyh0b2tlbltjaGlsZFRva2Vuc10sIGNhbGxiYWNrKTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRva2VuLnRva2Vucykge1xuICAgICAgICAgICAgICBtYXJrZWQud2Fsa1Rva2Vucyh0b2tlbi50b2tlbnMsIGNhbGxiYWNrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIGZvciAodmFyIF9pdGVyYXRvciA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyTG9vc2UodG9rZW5zKSwgX3N0ZXA7ICEoX3N0ZXAgPSBfaXRlcmF0b3IoKSkuZG9uZTspIHtcbiAgICAgIF9sb29wMygpO1xuICAgIH1cbiAgfTtcbiAgLyoqXG4gICAqIFBhcnNlIElubGluZVxuICAgKi9cblxuXG4gIG1hcmtlZC5wYXJzZUlubGluZSA9IGZ1bmN0aW9uIChzcmMsIG9wdCkge1xuICAgIC8vIHRocm93IGVycm9yIGluIGNhc2Ugb2Ygbm9uIHN0cmluZyBpbnB1dFxuICAgIGlmICh0eXBlb2Ygc3JjID09PSAndW5kZWZpbmVkJyB8fCBzcmMgPT09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignbWFya2VkLnBhcnNlSW5saW5lKCk6IGlucHV0IHBhcmFtZXRlciBpcyB1bmRlZmluZWQgb3IgbnVsbCcpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2Ygc3JjICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdtYXJrZWQucGFyc2VJbmxpbmUoKTogaW5wdXQgcGFyYW1ldGVyIGlzIG9mIHR5cGUgJyArIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChzcmMpICsgJywgc3RyaW5nIGV4cGVjdGVkJyk7XG4gICAgfVxuXG4gICAgb3B0ID0gbWVyZ2Uoe30sIG1hcmtlZC5kZWZhdWx0cywgb3B0IHx8IHt9KTtcbiAgICBjaGVja1Nhbml0aXplRGVwcmVjYXRpb24ob3B0KTtcblxuICAgIHRyeSB7XG4gICAgICB2YXIgdG9rZW5zID0gTGV4ZXIubGV4SW5saW5lKHNyYywgb3B0KTtcblxuICAgICAgaWYgKG9wdC53YWxrVG9rZW5zKSB7XG4gICAgICAgIG1hcmtlZC53YWxrVG9rZW5zKHRva2Vucywgb3B0LndhbGtUb2tlbnMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gUGFyc2VyLnBhcnNlSW5saW5lKHRva2Vucywgb3B0KTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBlLm1lc3NhZ2UgKz0gJ1xcblBsZWFzZSByZXBvcnQgdGhpcyB0byBodHRwczovL2dpdGh1Yi5jb20vbWFya2VkanMvbWFya2VkLic7XG5cbiAgICAgIGlmIChvcHQuc2lsZW50KSB7XG4gICAgICAgIHJldHVybiAnPHA+QW4gZXJyb3Igb2NjdXJyZWQ6PC9wPjxwcmU+JyArIGVzY2FwZShlLm1lc3NhZ2UgKyAnJywgdHJ1ZSkgKyAnPC9wcmU+JztcbiAgICAgIH1cblxuICAgICAgdGhyb3cgZTtcbiAgICB9XG4gIH07XG4gIC8qKlxuICAgKiBFeHBvc2VcbiAgICovXG5cblxuICBtYXJrZWQuUGFyc2VyID0gUGFyc2VyO1xuICBtYXJrZWQucGFyc2VyID0gUGFyc2VyLnBhcnNlO1xuICBtYXJrZWQuUmVuZGVyZXIgPSBSZW5kZXJlcjtcbiAgbWFya2VkLlRleHRSZW5kZXJlciA9IFRleHRSZW5kZXJlcjtcbiAgbWFya2VkLkxleGVyID0gTGV4ZXI7XG4gIG1hcmtlZC5sZXhlciA9IExleGVyLmxleDtcbiAgbWFya2VkLlRva2VuaXplciA9IFRva2VuaXplcjtcbiAgbWFya2VkLlNsdWdnZXIgPSBTbHVnZ2VyO1xuICBtYXJrZWQucGFyc2UgPSBtYXJrZWQ7XG4gIHZhciBtYXJrZWRfMSA9IG1hcmtlZDtcblxuICByZXR1cm4gbWFya2VkXzE7XG5cbn0pKTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///84\n")},418:module=>{"use strict";eval("/*\nobject-assign\n(c) Sindre Sorhus\n@license MIT\n*/\n\n\n/* eslint-disable no-unused-vars */\nvar getOwnPropertySymbols = Object.getOwnPropertySymbols;\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\nvar propIsEnumerable = Object.prototype.propertyIsEnumerable;\n\nfunction toObject(val) {\n\tif (val === null || val === undefined) {\n\t\tthrow new TypeError('Object.assign cannot be called with null or undefined');\n\t}\n\n\treturn Object(val);\n}\n\nfunction shouldUseNative() {\n\ttry {\n\t\tif (!Object.assign) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Detect buggy property enumeration order in older V8 versions.\n\n\t\t// https://bugs.chromium.org/p/v8/issues/detail?id=4118\n\t\tvar test1 = new String('abc');  // eslint-disable-line no-new-wrappers\n\t\ttest1[5] = 'de';\n\t\tif (Object.getOwnPropertyNames(test1)[0] === '5') {\n\t\t\treturn false;\n\t\t}\n\n\t\t// https://bugs.chromium.org/p/v8/issues/detail?id=3056\n\t\tvar test2 = {};\n\t\tfor (var i = 0; i < 10; i++) {\n\t\t\ttest2['_' + String.fromCharCode(i)] = i;\n\t\t}\n\t\tvar order2 = Object.getOwnPropertyNames(test2).map(function (n) {\n\t\t\treturn test2[n];\n\t\t});\n\t\tif (order2.join('') !== '0123456789') {\n\t\t\treturn false;\n\t\t}\n\n\t\t// https://bugs.chromium.org/p/v8/issues/detail?id=3056\n\t\tvar test3 = {};\n\t\t'abcdefghijklmnopqrst'.split('').forEach(function (letter) {\n\t\t\ttest3[letter] = letter;\n\t\t});\n\t\tif (Object.keys(Object.assign({}, test3)).join('') !==\n\t\t\t\t'abcdefghijklmnopqrst') {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t} catch (err) {\n\t\t// We don't expect any of the above to throw, but better to be safe.\n\t\treturn false;\n\t}\n}\n\nmodule.exports = shouldUseNative() ? Object.assign : function (target, source) {\n\tvar from;\n\tvar to = toObject(target);\n\tvar symbols;\n\n\tfor (var s = 1; s < arguments.length; s++) {\n\t\tfrom = Object(arguments[s]);\n\n\t\tfor (var key in from) {\n\t\t\tif (hasOwnProperty.call(from, key)) {\n\t\t\t\tto[key] = from[key];\n\t\t\t}\n\t\t}\n\n\t\tif (getOwnPropertySymbols) {\n\t\t\tsymbols = getOwnPropertySymbols(from);\n\t\t\tfor (var i = 0; i < symbols.length; i++) {\n\t\t\t\tif (propIsEnumerable.call(from, symbols[i])) {\n\t\t\t\t\tto[symbols[i]] = from[symbols[i]];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn to;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDE4LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQixRQUFRO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlCQUFpQixzQkFBc0I7QUFDdkM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUJBQW1CLG9CQUFvQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL21kYy1yZWFjdC8uL25vZGVfbW9kdWxlcy9vYmplY3QtYXNzaWduL2luZGV4LmpzPzMyMGMiXSwic291cmNlc0NvbnRlbnQiOlsiLypcbm9iamVjdC1hc3NpZ25cbihjKSBTaW5kcmUgU29yaHVzXG5AbGljZW5zZSBNSVRcbiovXG5cbid1c2Ugc3RyaWN0Jztcbi8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC12YXJzICovXG52YXIgZ2V0T3duUHJvcGVydHlTeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scztcbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgcHJvcElzRW51bWVyYWJsZSA9IE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGU7XG5cbmZ1bmN0aW9uIHRvT2JqZWN0KHZhbCkge1xuXHRpZiAodmFsID09PSBudWxsIHx8IHZhbCA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignT2JqZWN0LmFzc2lnbiBjYW5ub3QgYmUgY2FsbGVkIHdpdGggbnVsbCBvciB1bmRlZmluZWQnKTtcblx0fVxuXG5cdHJldHVybiBPYmplY3QodmFsKTtcbn1cblxuZnVuY3Rpb24gc2hvdWxkVXNlTmF0aXZlKCkge1xuXHR0cnkge1xuXHRcdGlmICghT2JqZWN0LmFzc2lnbikge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdC8vIERldGVjdCBidWdneSBwcm9wZXJ0eSBlbnVtZXJhdGlvbiBvcmRlciBpbiBvbGRlciBWOCB2ZXJzaW9ucy5cblxuXHRcdC8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTQxMThcblx0XHR2YXIgdGVzdDEgPSBuZXcgU3RyaW5nKCdhYmMnKTsgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmV3LXdyYXBwZXJzXG5cdFx0dGVzdDFbNV0gPSAnZGUnO1xuXHRcdGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0ZXN0MSlbMF0gPT09ICc1Jykge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdC8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTMwNTZcblx0XHR2YXIgdGVzdDIgPSB7fTtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IDEwOyBpKyspIHtcblx0XHRcdHRlc3QyWydfJyArIFN0cmluZy5mcm9tQ2hhckNvZGUoaSldID0gaTtcblx0XHR9XG5cdFx0dmFyIG9yZGVyMiA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRlc3QyKS5tYXAoZnVuY3Rpb24gKG4pIHtcblx0XHRcdHJldHVybiB0ZXN0MltuXTtcblx0XHR9KTtcblx0XHRpZiAob3JkZXIyLmpvaW4oJycpICE9PSAnMDEyMzQ1Njc4OScpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHQvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD0zMDU2XG5cdFx0dmFyIHRlc3QzID0ge307XG5cdFx0J2FiY2RlZmdoaWprbG1ub3BxcnN0Jy5zcGxpdCgnJykuZm9yRWFjaChmdW5jdGlvbiAobGV0dGVyKSB7XG5cdFx0XHR0ZXN0M1tsZXR0ZXJdID0gbGV0dGVyO1xuXHRcdH0pO1xuXHRcdGlmIChPYmplY3Qua2V5cyhPYmplY3QuYXNzaWduKHt9LCB0ZXN0MykpLmpvaW4oJycpICE9PVxuXHRcdFx0XHQnYWJjZGVmZ2hpamtsbW5vcHFyc3QnKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRydWU7XG5cdH0gY2F0Y2ggKGVycikge1xuXHRcdC8vIFdlIGRvbid0IGV4cGVjdCBhbnkgb2YgdGhlIGFib3ZlIHRvIHRocm93LCBidXQgYmV0dGVyIHRvIGJlIHNhZmUuXG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc2hvdWxkVXNlTmF0aXZlKCkgPyBPYmplY3QuYXNzaWduIDogZnVuY3Rpb24gKHRhcmdldCwgc291cmNlKSB7XG5cdHZhciBmcm9tO1xuXHR2YXIgdG8gPSB0b09iamVjdCh0YXJnZXQpO1xuXHR2YXIgc3ltYm9scztcblxuXHRmb3IgKHZhciBzID0gMTsgcyA8IGFyZ3VtZW50cy5sZW5ndGg7IHMrKykge1xuXHRcdGZyb20gPSBPYmplY3QoYXJndW1lbnRzW3NdKTtcblxuXHRcdGZvciAodmFyIGtleSBpbiBmcm9tKSB7XG5cdFx0XHRpZiAoaGFzT3duUHJvcGVydHkuY2FsbChmcm9tLCBrZXkpKSB7XG5cdFx0XHRcdHRvW2tleV0gPSBmcm9tW2tleV07XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKGdldE93blByb3BlcnR5U3ltYm9scykge1xuXHRcdFx0c3ltYm9scyA9IGdldE93blByb3BlcnR5U3ltYm9scyhmcm9tKTtcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgc3ltYm9scy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRpZiAocHJvcElzRW51bWVyYWJsZS5jYWxsKGZyb20sIHN5bWJvbHNbaV0pKSB7XG5cdFx0XHRcdFx0dG9bc3ltYm9sc1tpXV0gPSBmcm9tW3N5bWJvbHNbaV1dO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIHRvO1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///418\n")},779:(module,__unused_webpack_exports,__webpack_require__)=>{eval("var isarray = __webpack_require__(826)\n\n/**\n * Expose `pathToRegexp`.\n */\nmodule.exports = pathToRegexp\nmodule.exports.parse = parse\nmodule.exports.compile = compile\nmodule.exports.tokensToFunction = tokensToFunction\nmodule.exports.tokensToRegExp = tokensToRegExp\n\n/**\n * The main path matching regexp utility.\n *\n * @type {RegExp}\n */\nvar PATH_REGEXP = new RegExp([\n  // Match escaped characters that would otherwise appear in future matches.\n  // This allows the user to escape special characters that won't transform.\n  '(\\\\\\\\.)',\n  // Match Express-style parameters and un-named parameters with a prefix\n  // and optional suffixes. Matches appear as:\n  //\n  // \"/:test(\\\\d+)?\" => [\"/\", \"test\", \"\\d+\", undefined, \"?\", undefined]\n  // \"/route(\\\\d+)\"  => [undefined, undefined, undefined, \"\\d+\", undefined, undefined]\n  // \"/*\"            => [\"/\", undefined, undefined, undefined, undefined, \"*\"]\n  '([\\\\/.])?(?:(?:\\\\:(\\\\w+)(?:\\\\(((?:\\\\\\\\.|[^\\\\\\\\()])+)\\\\))?|\\\\(((?:\\\\\\\\.|[^\\\\\\\\()])+)\\\\))([+*?])?|(\\\\*))'\n].join('|'), 'g')\n\n/**\n * Parse a string for the raw tokens.\n *\n * @param  {string}  str\n * @param  {Object=} options\n * @return {!Array}\n */\nfunction parse (str, options) {\n  var tokens = []\n  var key = 0\n  var index = 0\n  var path = ''\n  var defaultDelimiter = options && options.delimiter || '/'\n  var res\n\n  while ((res = PATH_REGEXP.exec(str)) != null) {\n    var m = res[0]\n    var escaped = res[1]\n    var offset = res.index\n    path += str.slice(index, offset)\n    index = offset + m.length\n\n    // Ignore already escaped sequences.\n    if (escaped) {\n      path += escaped[1]\n      continue\n    }\n\n    var next = str[index]\n    var prefix = res[2]\n    var name = res[3]\n    var capture = res[4]\n    var group = res[5]\n    var modifier = res[6]\n    var asterisk = res[7]\n\n    // Push the current path onto the tokens.\n    if (path) {\n      tokens.push(path)\n      path = ''\n    }\n\n    var partial = prefix != null && next != null && next !== prefix\n    var repeat = modifier === '+' || modifier === '*'\n    var optional = modifier === '?' || modifier === '*'\n    var delimiter = res[2] || defaultDelimiter\n    var pattern = capture || group\n\n    tokens.push({\n      name: name || key++,\n      prefix: prefix || '',\n      delimiter: delimiter,\n      optional: optional,\n      repeat: repeat,\n      partial: partial,\n      asterisk: !!asterisk,\n      pattern: pattern ? escapeGroup(pattern) : (asterisk ? '.*' : '[^' + escapeString(delimiter) + ']+?')\n    })\n  }\n\n  // Match any characters still remaining.\n  if (index < str.length) {\n    path += str.substr(index)\n  }\n\n  // If the path exists, push it onto the end.\n  if (path) {\n    tokens.push(path)\n  }\n\n  return tokens\n}\n\n/**\n * Compile a string to a template function for the path.\n *\n * @param  {string}             str\n * @param  {Object=}            options\n * @return {!function(Object=, Object=)}\n */\nfunction compile (str, options) {\n  return tokensToFunction(parse(str, options), options)\n}\n\n/**\n * Prettier encoding of URI path segments.\n *\n * @param  {string}\n * @return {string}\n */\nfunction encodeURIComponentPretty (str) {\n  return encodeURI(str).replace(/[\\/?#]/g, function (c) {\n    return '%' + c.charCodeAt(0).toString(16).toUpperCase()\n  })\n}\n\n/**\n * Encode the asterisk parameter. Similar to `pretty`, but allows slashes.\n *\n * @param  {string}\n * @return {string}\n */\nfunction encodeAsterisk (str) {\n  return encodeURI(str).replace(/[?#]/g, function (c) {\n    return '%' + c.charCodeAt(0).toString(16).toUpperCase()\n  })\n}\n\n/**\n * Expose a method for transforming tokens into the path function.\n */\nfunction tokensToFunction (tokens, options) {\n  // Compile all the tokens into regexps.\n  var matches = new Array(tokens.length)\n\n  // Compile all the patterns before compilation.\n  for (var i = 0; i < tokens.length; i++) {\n    if (typeof tokens[i] === 'object') {\n      matches[i] = new RegExp('^(?:' + tokens[i].pattern + ')$', flags(options))\n    }\n  }\n\n  return function (obj, opts) {\n    var path = ''\n    var data = obj || {}\n    var options = opts || {}\n    var encode = options.pretty ? encodeURIComponentPretty : encodeURIComponent\n\n    for (var i = 0; i < tokens.length; i++) {\n      var token = tokens[i]\n\n      if (typeof token === 'string') {\n        path += token\n\n        continue\n      }\n\n      var value = data[token.name]\n      var segment\n\n      if (value == null) {\n        if (token.optional) {\n          // Prepend partial segment prefixes.\n          if (token.partial) {\n            path += token.prefix\n          }\n\n          continue\n        } else {\n          throw new TypeError('Expected \"' + token.name + '\" to be defined')\n        }\n      }\n\n      if (isarray(value)) {\n        if (!token.repeat) {\n          throw new TypeError('Expected \"' + token.name + '\" to not repeat, but received `' + JSON.stringify(value) + '`')\n        }\n\n        if (value.length === 0) {\n          if (token.optional) {\n            continue\n          } else {\n            throw new TypeError('Expected \"' + token.name + '\" to not be empty')\n          }\n        }\n\n        for (var j = 0; j < value.length; j++) {\n          segment = encode(value[j])\n\n          if (!matches[i].test(segment)) {\n            throw new TypeError('Expected all \"' + token.name + '\" to match \"' + token.pattern + '\", but received `' + JSON.stringify(segment) + '`')\n          }\n\n          path += (j === 0 ? token.prefix : token.delimiter) + segment\n        }\n\n        continue\n      }\n\n      segment = token.asterisk ? encodeAsterisk(value) : encode(value)\n\n      if (!matches[i].test(segment)) {\n        throw new TypeError('Expected \"' + token.name + '\" to match \"' + token.pattern + '\", but received \"' + segment + '\"')\n      }\n\n      path += token.prefix + segment\n    }\n\n    return path\n  }\n}\n\n/**\n * Escape a regular expression string.\n *\n * @param  {string} str\n * @return {string}\n */\nfunction escapeString (str) {\n  return str.replace(/([.+*?=^!:${}()[\\]|\\/\\\\])/g, '\\\\$1')\n}\n\n/**\n * Escape the capturing group by escaping special characters and meaning.\n *\n * @param  {string} group\n * @return {string}\n */\nfunction escapeGroup (group) {\n  return group.replace(/([=!:$\\/()])/g, '\\\\$1')\n}\n\n/**\n * Attach the keys as a property of the regexp.\n *\n * @param  {!RegExp} re\n * @param  {Array}   keys\n * @return {!RegExp}\n */\nfunction attachKeys (re, keys) {\n  re.keys = keys\n  return re\n}\n\n/**\n * Get the flags for a regexp from the options.\n *\n * @param  {Object} options\n * @return {string}\n */\nfunction flags (options) {\n  return options && options.sensitive ? '' : 'i'\n}\n\n/**\n * Pull out keys from a regexp.\n *\n * @param  {!RegExp} path\n * @param  {!Array}  keys\n * @return {!RegExp}\n */\nfunction regexpToRegexp (path, keys) {\n  // Use a negative lookahead to match only capturing groups.\n  var groups = path.source.match(/\\((?!\\?)/g)\n\n  if (groups) {\n    for (var i = 0; i < groups.length; i++) {\n      keys.push({\n        name: i,\n        prefix: null,\n        delimiter: null,\n        optional: false,\n        repeat: false,\n        partial: false,\n        asterisk: false,\n        pattern: null\n      })\n    }\n  }\n\n  return attachKeys(path, keys)\n}\n\n/**\n * Transform an array into a regexp.\n *\n * @param  {!Array}  path\n * @param  {Array}   keys\n * @param  {!Object} options\n * @return {!RegExp}\n */\nfunction arrayToRegexp (path, keys, options) {\n  var parts = []\n\n  for (var i = 0; i < path.length; i++) {\n    parts.push(pathToRegexp(path[i], keys, options).source)\n  }\n\n  var regexp = new RegExp('(?:' + parts.join('|') + ')', flags(options))\n\n  return attachKeys(regexp, keys)\n}\n\n/**\n * Create a path regexp from string input.\n *\n * @param  {string}  path\n * @param  {!Array}  keys\n * @param  {!Object} options\n * @return {!RegExp}\n */\nfunction stringToRegexp (path, keys, options) {\n  return tokensToRegExp(parse(path, options), keys, options)\n}\n\n/**\n * Expose a function for taking tokens and returning a RegExp.\n *\n * @param  {!Array}          tokens\n * @param  {(Array|Object)=} keys\n * @param  {Object=}         options\n * @return {!RegExp}\n */\nfunction tokensToRegExp (tokens, keys, options) {\n  if (!isarray(keys)) {\n    options = /** @type {!Object} */ (keys || options)\n    keys = []\n  }\n\n  options = options || {}\n\n  var strict = options.strict\n  var end = options.end !== false\n  var route = ''\n\n  // Iterate over the tokens and create our regexp string.\n  for (var i = 0; i < tokens.length; i++) {\n    var token = tokens[i]\n\n    if (typeof token === 'string') {\n      route += escapeString(token)\n    } else {\n      var prefix = escapeString(token.prefix)\n      var capture = '(?:' + token.pattern + ')'\n\n      keys.push(token)\n\n      if (token.repeat) {\n        capture += '(?:' + prefix + capture + ')*'\n      }\n\n      if (token.optional) {\n        if (!token.partial) {\n          capture = '(?:' + prefix + '(' + capture + '))?'\n        } else {\n          capture = prefix + '(' + capture + ')?'\n        }\n      } else {\n        capture = prefix + '(' + capture + ')'\n      }\n\n      route += capture\n    }\n  }\n\n  var delimiter = escapeString(options.delimiter || '/')\n  var endsWithDelimiter = route.slice(-delimiter.length) === delimiter\n\n  // In non-strict mode we allow a slash at the end of match. If the path to\n  // match already ends with a slash, we remove it for consistency. The slash\n  // is valid at the end of a path match, not in the middle. This is important\n  // in non-ending mode, where \"/test/\" shouldn't match \"/test//route\".\n  if (!strict) {\n    route = (endsWithDelimiter ? route.slice(0, -delimiter.length) : route) + '(?:' + delimiter + '(?=$))?'\n  }\n\n  if (end) {\n    route += '$'\n  } else {\n    // In non-ending mode, we need the capturing groups to match as much as\n    // possible by using a positive lookahead to the end or next path segment.\n    route += strict && endsWithDelimiter ? '' : '(?=' + delimiter + '|$)'\n  }\n\n  return attachKeys(new RegExp('^' + route, flags(options)), keys)\n}\n\n/**\n * Normalize the given path string, returning a regular expression.\n *\n * An empty array can be passed in for the keys, which will hold the\n * placeholder key descriptions. For example, using `/user/:id`, `keys` will\n * contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.\n *\n * @param  {(string|RegExp|Array)} path\n * @param  {(Array|Object)=}       keys\n * @param  {Object=}               options\n * @return {!RegExp}\n */\nfunction pathToRegexp (path, keys, options) {\n  if (!isarray(keys)) {\n    options = /** @type {!Object} */ (keys || options)\n    keys = []\n  }\n\n  options = options || {}\n\n  if (path instanceof RegExp) {\n    return regexpToRegexp(path, /** @type {!Array} */ (keys))\n  }\n\n  if (isarray(path)) {\n    return arrayToRegexp(/** @type {!Array} */ (path), /** @type {!Array} */ (keys), options)\n  }\n\n  return stringToRegexp(/** @type {string} */ (path), /** @type {!Array} */ (keys), options)\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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O0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWSxTQUFTO0FBQ3JCLFlBQVksU0FBUztBQUNyQixZQUFZLFNBQVM7QUFDckIsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVksaUJBQWlCO0FBQzdCLFlBQVksaUJBQWlCO0FBQzdCLFlBQVksaUJBQWlCO0FBQzdCLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsU0FBUztBQUNsQztBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQixtQkFBbUI7QUFDckM7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSw0REFBNEQ7QUFDM0U7QUFDQSxZQUFZLHVCQUF1QjtBQUNuQyxZQUFZLHVCQUF1QjtBQUNuQyxZQUFZLHVCQUF1QjtBQUNuQyxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLFNBQVM7QUFDbEM7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLDJDQUEyQyxRQUFRO0FBQ25EOztBQUVBO0FBQ0Esb0NBQW9DLFFBQVEsc0JBQXNCLFFBQVE7QUFDMUU7O0FBRUEsbUNBQW1DLFFBQVEsc0JBQXNCLFFBQVE7QUFDekUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9ub2RlX21vZHVsZXMvcGF0aC10by1yZWdleHAvaW5kZXguanM/YmQxMSJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgaXNhcnJheSA9IHJlcXVpcmUoJ2lzYXJyYXknKVxuXG4vKipcbiAqIEV4cG9zZSBgcGF0aFRvUmVnZXhwYC5cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBwYXRoVG9SZWdleHBcbm1vZHVsZS5leHBvcnRzLnBhcnNlID0gcGFyc2Vcbm1vZHVsZS5leHBvcnRzLmNvbXBpbGUgPSBjb21waWxlXG5tb2R1bGUuZXhwb3J0cy50b2tlbnNUb0Z1bmN0aW9uID0gdG9rZW5zVG9GdW5jdGlvblxubW9kdWxlLmV4cG9ydHMudG9rZW5zVG9SZWdFeHAgPSB0b2tlbnNUb1JlZ0V4cFxuXG4vKipcbiAqIFRoZSBtYWluIHBhdGggbWF0Y2hpbmcgcmVnZXhwIHV0aWxpdHkuXG4gKlxuICogQHR5cGUge1JlZ0V4cH1cbiAqL1xudmFyIFBBVEhfUkVHRVhQID0gbmV3IFJlZ0V4cChbXG4gIC8vIE1hdGNoIGVzY2FwZWQgY2hhcmFjdGVycyB0aGF0IHdvdWxkIG90aGVyd2lzZSBhcHBlYXIgaW4gZnV0dXJlIG1hdGNoZXMuXG4gIC8vIFRoaXMgYWxsb3dzIHRoZSB1c2VyIHRvIGVzY2FwZSBzcGVjaWFsIGNoYXJhY3RlcnMgdGhhdCB3b24ndCB0cmFuc2Zvcm0uXG4gICcoXFxcXFxcXFwuKScsXG4gIC8vIE1hdGNoIEV4cHJlc3Mtc3R5bGUgcGFyYW1ldGVycyBhbmQgdW4tbmFtZWQgcGFyYW1ldGVycyB3aXRoIGEgcHJlZml4XG4gIC8vIGFuZCBvcHRpb25hbCBzdWZmaXhlcy4gTWF0Y2hlcyBhcHBlYXIgYXM6XG4gIC8vXG4gIC8vIFwiLzp0ZXN0KFxcXFxkKyk/XCIgPT4gW1wiL1wiLCBcInRlc3RcIiwgXCJcXGQrXCIsIHVuZGVmaW5lZCwgXCI/XCIsIHVuZGVmaW5lZF1cbiAgLy8gXCIvcm91dGUoXFxcXGQrKVwiICA9PiBbdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgXCJcXGQrXCIsIHVuZGVmaW5lZCwgdW5kZWZpbmVkXVxuICAvLyBcIi8qXCIgICAgICAgICAgICA9PiBbXCIvXCIsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgXCIqXCJdXG4gICcoW1xcXFwvLl0pPyg/Oig/OlxcXFw6KFxcXFx3KykoPzpcXFxcKCgoPzpcXFxcXFxcXC58W15cXFxcXFxcXCgpXSkrKVxcXFwpKT98XFxcXCgoKD86XFxcXFxcXFwufFteXFxcXFxcXFwoKV0pKylcXFxcKSkoWysqP10pP3woXFxcXCopKSdcbl0uam9pbignfCcpLCAnZycpXG5cbi8qKlxuICogUGFyc2UgYSBzdHJpbmcgZm9yIHRoZSByYXcgdG9rZW5zLlxuICpcbiAqIEBwYXJhbSAge3N0cmluZ30gIHN0clxuICogQHBhcmFtICB7T2JqZWN0PX0gb3B0aW9uc1xuICogQHJldHVybiB7IUFycmF5fVxuICovXG5mdW5jdGlvbiBwYXJzZSAoc3RyLCBvcHRpb25zKSB7XG4gIHZhciB0b2tlbnMgPSBbXVxuICB2YXIga2V5ID0gMFxuICB2YXIgaW5kZXggPSAwXG4gIHZhciBwYXRoID0gJydcbiAgdmFyIGRlZmF1bHREZWxpbWl0ZXIgPSBvcHRpb25zICYmIG9wdGlvbnMuZGVsaW1pdGVyIHx8ICcvJ1xuICB2YXIgcmVzXG5cbiAgd2hpbGUgKChyZXMgPSBQQVRIX1JFR0VYUC5leGVjKHN0cikpICE9IG51bGwpIHtcbiAgICB2YXIgbSA9IHJlc1swXVxuICAgIHZhciBlc2NhcGVkID0gcmVzWzFdXG4gICAgdmFyIG9mZnNldCA9IHJlcy5pbmRleFxuICAgIHBhdGggKz0gc3RyLnNsaWNlKGluZGV4LCBvZmZzZXQpXG4gICAgaW5kZXggPSBvZmZzZXQgKyBtLmxlbmd0aFxuXG4gICAgLy8gSWdub3JlIGFscmVhZHkgZXNjYXBlZCBzZXF1ZW5jZXMuXG4gICAgaWYgKGVzY2FwZWQpIHtcbiAgICAgIHBhdGggKz0gZXNjYXBlZFsxXVxuICAgICAgY29udGludWVcbiAgICB9XG5cbiAgICB2YXIgbmV4dCA9IHN0cltpbmRleF1cbiAgICB2YXIgcHJlZml4ID0gcmVzWzJdXG4gICAgdmFyIG5hbWUgPSByZXNbM11cbiAgICB2YXIgY2FwdHVyZSA9IHJlc1s0XVxuICAgIHZhciBncm91cCA9IHJlc1s1XVxuICAgIHZhciBtb2RpZmllciA9IHJlc1s2XVxuICAgIHZhciBhc3RlcmlzayA9IHJlc1s3XVxuXG4gICAgLy8gUHVzaCB0aGUgY3VycmVudCBwYXRoIG9udG8gdGhlIHRva2Vucy5cbiAgICBpZiAocGF0aCkge1xuICAgICAgdG9rZW5zLnB1c2gocGF0aClcbiAgICAgIHBhdGggPSAnJ1xuICAgIH1cblxuICAgIHZhciBwYXJ0aWFsID0gcHJlZml4ICE9IG51bGwgJiYgbmV4dCAhPSBudWxsICYmIG5leHQgIT09IHByZWZpeFxuICAgIHZhciByZXBlYXQgPSBtb2RpZmllciA9PT0gJysnIHx8IG1vZGlmaWVyID09PSAnKidcbiAgICB2YXIgb3B0aW9uYWwgPSBtb2RpZmllciA9PT0gJz8nIHx8IG1vZGlmaWVyID09PSAnKidcbiAgICB2YXIgZGVsaW1pdGVyID0gcmVzWzJdIHx8IGRlZmF1bHREZWxpbWl0ZXJcbiAgICB2YXIgcGF0dGVybiA9IGNhcHR1cmUgfHwgZ3JvdXBcblxuICAgIHRva2Vucy5wdXNoKHtcbiAgICAgIG5hbWU6IG5hbWUgfHwga2V5KyssXG4gICAgICBwcmVmaXg6IHByZWZpeCB8fCAnJyxcbiAgICAgIGRlbGltaXRlcjogZGVsaW1pdGVyLFxuICAgICAgb3B0aW9uYWw6IG9wdGlvbmFsLFxuICAgICAgcmVwZWF0OiByZXBlYXQsXG4gICAgICBwYXJ0aWFsOiBwYXJ0aWFsLFxuICAgICAgYXN0ZXJpc2s6ICEhYXN0ZXJpc2ssXG4gICAgICBwYXR0ZXJuOiBwYXR0ZXJuID8gZXNjYXBlR3JvdXAocGF0dGVybikgOiAoYXN0ZXJpc2sgPyAnLionIDogJ1teJyArIGVzY2FwZVN0cmluZyhkZWxpbWl0ZXIpICsgJ10rPycpXG4gICAgfSlcbiAgfVxuXG4gIC8vIE1hdGNoIGFueSBjaGFyYWN0ZXJzIHN0aWxsIHJlbWFpbmluZy5cbiAgaWYgKGluZGV4IDwgc3RyLmxlbmd0aCkge1xuICAgIHBhdGggKz0gc3RyLnN1YnN0cihpbmRleClcbiAgfVxuXG4gIC8vIElmIHRoZSBwYXRoIGV4aXN0cywgcHVzaCBpdCBvbnRvIHRoZSBlbmQuXG4gIGlmIChwYXRoKSB7XG4gICAgdG9rZW5zLnB1c2gocGF0aClcbiAgfVxuXG4gIHJldHVybiB0b2tlbnNcbn1cblxuLyoqXG4gKiBDb21waWxlIGEgc3RyaW5nIHRvIGEgdGVtcGxhdGUgZnVuY3Rpb24gZm9yIHRoZSBwYXRoLlxuICpcbiAqIEBwYXJhbSAge3N0cmluZ30gICAgICAgICAgICAgc3RyXG4gKiBAcGFyYW0gIHtPYmplY3Q9fSAgICAgICAgICAgIG9wdGlvbnNcbiAqIEByZXR1cm4geyFmdW5jdGlvbihPYmplY3Q9LCBPYmplY3Q9KX1cbiAqL1xuZnVuY3Rpb24gY29tcGlsZSAoc3RyLCBvcHRpb25zKSB7XG4gIHJldHVybiB0b2tlbnNUb0Z1bmN0aW9uKHBhcnNlKHN0ciwgb3B0aW9ucyksIG9wdGlvbnMpXG59XG5cbi8qKlxuICogUHJldHRpZXIgZW5jb2Rpbmcgb2YgVVJJIHBhdGggc2VnbWVudHMuXG4gKlxuICogQHBhcmFtICB7c3RyaW5nfVxuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBlbmNvZGVVUklDb21wb25lbnRQcmV0dHkgKHN0cikge1xuICByZXR1cm4gZW5jb2RlVVJJKHN0cikucmVwbGFjZSgvW1xcLz8jXS9nLCBmdW5jdGlvbiAoYykge1xuICAgIHJldHVybiAnJScgKyBjLmNoYXJDb2RlQXQoMCkudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKClcbiAgfSlcbn1cblxuLyoqXG4gKiBFbmNvZGUgdGhlIGFzdGVyaXNrIHBhcmFtZXRlci4gU2ltaWxhciB0byBgcHJldHR5YCwgYnV0IGFsbG93cyBzbGFzaGVzLlxuICpcbiAqIEBwYXJhbSAge3N0cmluZ31cbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gZW5jb2RlQXN0ZXJpc2sgKHN0cikge1xuICByZXR1cm4gZW5jb2RlVVJJKHN0cikucmVwbGFjZSgvWz8jXS9nLCBmdW5jdGlvbiAoYykge1xuICAgIHJldHVybiAnJScgKyBjLmNoYXJDb2RlQXQoMCkudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKClcbiAgfSlcbn1cblxuLyoqXG4gKiBFeHBvc2UgYSBtZXRob2QgZm9yIHRyYW5zZm9ybWluZyB0b2tlbnMgaW50byB0aGUgcGF0aCBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gdG9rZW5zVG9GdW5jdGlvbiAodG9rZW5zLCBvcHRpb25zKSB7XG4gIC8vIENvbXBpbGUgYWxsIHRoZSB0b2tlbnMgaW50byByZWdleHBzLlxuICB2YXIgbWF0Y2hlcyA9IG5ldyBBcnJheSh0b2tlbnMubGVuZ3RoKVxuXG4gIC8vIENvbXBpbGUgYWxsIHRoZSBwYXR0ZXJucyBiZWZvcmUgY29tcGlsYXRpb24uXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdG9rZW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKHR5cGVvZiB0b2tlbnNbaV0gPT09ICdvYmplY3QnKSB7XG4gICAgICBtYXRjaGVzW2ldID0gbmV3IFJlZ0V4cCgnXig/OicgKyB0b2tlbnNbaV0ucGF0dGVybiArICcpJCcsIGZsYWdzKG9wdGlvbnMpKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiAob2JqLCBvcHRzKSB7XG4gICAgdmFyIHBhdGggPSAnJ1xuICAgIHZhciBkYXRhID0gb2JqIHx8IHt9XG4gICAgdmFyIG9wdGlvbnMgPSBvcHRzIHx8IHt9XG4gICAgdmFyIGVuY29kZSA9IG9wdGlvbnMucHJldHR5ID8gZW5jb2RlVVJJQ29tcG9uZW50UHJldHR5IDogZW5jb2RlVVJJQ29tcG9uZW50XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRva2Vucy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHRva2VuID0gdG9rZW5zW2ldXG5cbiAgICAgIGlmICh0eXBlb2YgdG9rZW4gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHBhdGggKz0gdG9rZW5cblxuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICB2YXIgdmFsdWUgPSBkYXRhW3Rva2VuLm5hbWVdXG4gICAgICB2YXIgc2VnbWVudFxuXG4gICAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgICBpZiAodG9rZW4ub3B0aW9uYWwpIHtcbiAgICAgICAgICAvLyBQcmVwZW5kIHBhcnRpYWwgc2VnbWVudCBwcmVmaXhlcy5cbiAgICAgICAgICBpZiAodG9rZW4ucGFydGlhbCkge1xuICAgICAgICAgICAgcGF0aCArPSB0b2tlbi5wcmVmaXhcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0V4cGVjdGVkIFwiJyArIHRva2VuLm5hbWUgKyAnXCIgdG8gYmUgZGVmaW5lZCcpXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGlzYXJyYXkodmFsdWUpKSB7XG4gICAgICAgIGlmICghdG9rZW4ucmVwZWF0KSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgXCInICsgdG9rZW4ubmFtZSArICdcIiB0byBub3QgcmVwZWF0LCBidXQgcmVjZWl2ZWQgYCcgKyBKU09OLnN0cmluZ2lmeSh2YWx1ZSkgKyAnYCcpXG4gICAgICAgIH1cblxuICAgICAgICBpZiAodmFsdWUubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgaWYgKHRva2VuLm9wdGlvbmFsKSB7XG4gICAgICAgICAgICBjb250aW51ZVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdFeHBlY3RlZCBcIicgKyB0b2tlbi5uYW1lICsgJ1wiIHRvIG5vdCBiZSBlbXB0eScpXG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB2YWx1ZS5sZW5ndGg7IGorKykge1xuICAgICAgICAgIHNlZ21lbnQgPSBlbmNvZGUodmFsdWVbal0pXG5cbiAgICAgICAgICBpZiAoIW1hdGNoZXNbaV0udGVzdChzZWdtZW50KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgYWxsIFwiJyArIHRva2VuLm5hbWUgKyAnXCIgdG8gbWF0Y2ggXCInICsgdG9rZW4ucGF0dGVybiArICdcIiwgYnV0IHJlY2VpdmVkIGAnICsgSlNPTi5zdHJpbmdpZnkoc2VnbWVudCkgKyAnYCcpXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcGF0aCArPSAoaiA9PT0gMCA/IHRva2VuLnByZWZpeCA6IHRva2VuLmRlbGltaXRlcikgKyBzZWdtZW50XG4gICAgICAgIH1cblxuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICBzZWdtZW50ID0gdG9rZW4uYXN0ZXJpc2sgPyBlbmNvZGVBc3Rlcmlzayh2YWx1ZSkgOiBlbmNvZGUodmFsdWUpXG5cbiAgICAgIGlmICghbWF0Y2hlc1tpXS50ZXN0KHNlZ21lbnQpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0V4cGVjdGVkIFwiJyArIHRva2VuLm5hbWUgKyAnXCIgdG8gbWF0Y2ggXCInICsgdG9rZW4ucGF0dGVybiArICdcIiwgYnV0IHJlY2VpdmVkIFwiJyArIHNlZ21lbnQgKyAnXCInKVxuICAgICAgfVxuXG4gICAgICBwYXRoICs9IHRva2VuLnByZWZpeCArIHNlZ21lbnRcbiAgICB9XG5cbiAgICByZXR1cm4gcGF0aFxuICB9XG59XG5cbi8qKlxuICogRXNjYXBlIGEgcmVndWxhciBleHByZXNzaW9uIHN0cmluZy5cbiAqXG4gKiBAcGFyYW0gIHtzdHJpbmd9IHN0clxuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBlc2NhcGVTdHJpbmcgKHN0cikge1xuICByZXR1cm4gc3RyLnJlcGxhY2UoLyhbLisqPz1eIToke30oKVtcXF18XFwvXFxcXF0pL2csICdcXFxcJDEnKVxufVxuXG4vKipcbiAqIEVzY2FwZSB0aGUgY2FwdHVyaW5nIGdyb3VwIGJ5IGVzY2FwaW5nIHNwZWNpYWwgY2hhcmFjdGVycyBhbmQgbWVhbmluZy5cbiAqXG4gKiBAcGFyYW0gIHtzdHJpbmd9IGdyb3VwXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGVzY2FwZUdyb3VwIChncm91cCkge1xuICByZXR1cm4gZ3JvdXAucmVwbGFjZSgvKFs9ITokXFwvKCldKS9nLCAnXFxcXCQxJylcbn1cblxuLyoqXG4gKiBBdHRhY2ggdGhlIGtleXMgYXMgYSBwcm9wZXJ0eSBvZiB0aGUgcmVnZXhwLlxuICpcbiAqIEBwYXJhbSAgeyFSZWdFeHB9IHJlXG4gKiBAcGFyYW0gIHtBcnJheX0gICBrZXlzXG4gKiBAcmV0dXJuIHshUmVnRXhwfVxuICovXG5mdW5jdGlvbiBhdHRhY2hLZXlzIChyZSwga2V5cykge1xuICByZS5rZXlzID0ga2V5c1xuICByZXR1cm4gcmVcbn1cblxuLyoqXG4gKiBHZXQgdGhlIGZsYWdzIGZvciBhIHJlZ2V4cCBmcm9tIHRoZSBvcHRpb25zLlxuICpcbiAqIEBwYXJhbSAge09iamVjdH0gb3B0aW9uc1xuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBmbGFncyAob3B0aW9ucykge1xuICByZXR1cm4gb3B0aW9ucyAmJiBvcHRpb25zLnNlbnNpdGl2ZSA/ICcnIDogJ2knXG59XG5cbi8qKlxuICogUHVsbCBvdXQga2V5cyBmcm9tIGEgcmVnZXhwLlxuICpcbiAqIEBwYXJhbSAgeyFSZWdFeHB9IHBhdGhcbiAqIEBwYXJhbSAgeyFBcnJheX0gIGtleXNcbiAqIEByZXR1cm4geyFSZWdFeHB9XG4gKi9cbmZ1bmN0aW9uIHJlZ2V4cFRvUmVnZXhwIChwYXRoLCBrZXlzKSB7XG4gIC8vIFVzZSBhIG5lZ2F0aXZlIGxvb2thaGVhZCB0byBtYXRjaCBvbmx5IGNhcHR1cmluZyBncm91cHMuXG4gIHZhciBncm91cHMgPSBwYXRoLnNvdXJjZS5tYXRjaCgvXFwoKD8hXFw/KS9nKVxuXG4gIGlmIChncm91cHMpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGdyb3Vwcy5sZW5ndGg7IGkrKykge1xuICAgICAga2V5cy5wdXNoKHtcbiAgICAgICAgbmFtZTogaSxcbiAgICAgICAgcHJlZml4OiBudWxsLFxuICAgICAgICBkZWxpbWl0ZXI6IG51bGwsXG4gICAgICAgIG9wdGlvbmFsOiBmYWxzZSxcbiAgICAgICAgcmVwZWF0OiBmYWxzZSxcbiAgICAgICAgcGFydGlhbDogZmFsc2UsXG4gICAgICAgIGFzdGVyaXNrOiBmYWxzZSxcbiAgICAgICAgcGF0dGVybjogbnVsbFxuICAgICAgfSlcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYXR0YWNoS2V5cyhwYXRoLCBrZXlzKVxufVxuXG4vKipcbiAqIFRyYW5zZm9ybSBhbiBhcnJheSBpbnRvIGEgcmVnZXhwLlxuICpcbiAqIEBwYXJhbSAgeyFBcnJheX0gIHBhdGhcbiAqIEBwYXJhbSAge0FycmF5fSAgIGtleXNcbiAqIEBwYXJhbSAgeyFPYmplY3R9IG9wdGlvbnNcbiAqIEByZXR1cm4geyFSZWdFeHB9XG4gKi9cbmZ1bmN0aW9uIGFycmF5VG9SZWdleHAgKHBhdGgsIGtleXMsIG9wdGlvbnMpIHtcbiAgdmFyIHBhcnRzID0gW11cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHBhdGgubGVuZ3RoOyBpKyspIHtcbiAgICBwYXJ0cy5wdXNoKHBhdGhUb1JlZ2V4cChwYXRoW2ldLCBrZXlzLCBvcHRpb25zKS5zb3VyY2UpXG4gIH1cblxuICB2YXIgcmVnZXhwID0gbmV3IFJlZ0V4cCgnKD86JyArIHBhcnRzLmpvaW4oJ3wnKSArICcpJywgZmxhZ3Mob3B0aW9ucykpXG5cbiAgcmV0dXJuIGF0dGFjaEtleXMocmVnZXhwLCBrZXlzKVxufVxuXG4vKipcbiAqIENyZWF0ZSBhIHBhdGggcmVnZXhwIGZyb20gc3RyaW5nIGlucHV0LlxuICpcbiAqIEBwYXJhbSAge3N0cmluZ30gIHBhdGhcbiAqIEBwYXJhbSAgeyFBcnJheX0gIGtleXNcbiAqIEBwYXJhbSAgeyFPYmplY3R9IG9wdGlvbnNcbiAqIEByZXR1cm4geyFSZWdFeHB9XG4gKi9cbmZ1bmN0aW9uIHN0cmluZ1RvUmVnZXhwIChwYXRoLCBrZXlzLCBvcHRpb25zKSB7XG4gIHJldHVybiB0b2tlbnNUb1JlZ0V4cChwYXJzZShwYXRoLCBvcHRpb25zKSwga2V5cywgb3B0aW9ucylcbn1cblxuLyoqXG4gKiBFeHBvc2UgYSBmdW5jdGlvbiBmb3IgdGFraW5nIHRva2VucyBhbmQgcmV0dXJuaW5nIGEgUmVnRXhwLlxuICpcbiAqIEBwYXJhbSAgeyFBcnJheX0gICAgICAgICAgdG9rZW5zXG4gKiBAcGFyYW0gIHsoQXJyYXl8T2JqZWN0KT19IGtleXNcbiAqIEBwYXJhbSAge09iamVjdD19ICAgICAgICAgb3B0aW9uc1xuICogQHJldHVybiB7IVJlZ0V4cH1cbiAqL1xuZnVuY3Rpb24gdG9rZW5zVG9SZWdFeHAgKHRva2Vucywga2V5cywgb3B0aW9ucykge1xuICBpZiAoIWlzYXJyYXkoa2V5cykpIHtcbiAgICBvcHRpb25zID0gLyoqIEB0eXBlIHshT2JqZWN0fSAqLyAoa2V5cyB8fCBvcHRpb25zKVxuICAgIGtleXMgPSBbXVxuICB9XG5cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge31cblxuICB2YXIgc3RyaWN0ID0gb3B0aW9ucy5zdHJpY3RcbiAgdmFyIGVuZCA9IG9wdGlvbnMuZW5kICE9PSBmYWxzZVxuICB2YXIgcm91dGUgPSAnJ1xuXG4gIC8vIEl0ZXJhdGUgb3ZlciB0aGUgdG9rZW5zIGFuZCBjcmVhdGUgb3VyIHJlZ2V4cCBzdHJpbmcuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdG9rZW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHRva2VuID0gdG9rZW5zW2ldXG5cbiAgICBpZiAodHlwZW9mIHRva2VuID09PSAnc3RyaW5nJykge1xuICAgICAgcm91dGUgKz0gZXNjYXBlU3RyaW5nKHRva2VuKVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgcHJlZml4ID0gZXNjYXBlU3RyaW5nKHRva2VuLnByZWZpeClcbiAgICAgIHZhciBjYXB0dXJlID0gJyg/OicgKyB0b2tlbi5wYXR0ZXJuICsgJyknXG5cbiAgICAgIGtleXMucHVzaCh0b2tlbilcblxuICAgICAgaWYgKHRva2VuLnJlcGVhdCkge1xuICAgICAgICBjYXB0dXJlICs9ICcoPzonICsgcHJlZml4ICsgY2FwdHVyZSArICcpKidcbiAgICAgIH1cblxuICAgICAgaWYgKHRva2VuLm9wdGlvbmFsKSB7XG4gICAgICAgIGlmICghdG9rZW4ucGFydGlhbCkge1xuICAgICAgICAgIGNhcHR1cmUgPSAnKD86JyArIHByZWZpeCArICcoJyArIGNhcHR1cmUgKyAnKSk/J1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNhcHR1cmUgPSBwcmVmaXggKyAnKCcgKyBjYXB0dXJlICsgJyk/J1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjYXB0dXJlID0gcHJlZml4ICsgJygnICsgY2FwdHVyZSArICcpJ1xuICAgICAgfVxuXG4gICAgICByb3V0ZSArPSBjYXB0dXJlXG4gICAgfVxuICB9XG5cbiAgdmFyIGRlbGltaXRlciA9IGVzY2FwZVN0cmluZyhvcHRpb25zLmRlbGltaXRlciB8fCAnLycpXG4gIHZhciBlbmRzV2l0aERlbGltaXRlciA9IHJvdXRlLnNsaWNlKC1kZWxpbWl0ZXIubGVuZ3RoKSA9PT0gZGVsaW1pdGVyXG5cbiAgLy8gSW4gbm9uLXN0cmljdCBtb2RlIHdlIGFsbG93IGEgc2xhc2ggYXQgdGhlIGVuZCBvZiBtYXRjaC4gSWYgdGhlIHBhdGggdG9cbiAgLy8gbWF0Y2ggYWxyZWFkeSBlbmRzIHdpdGggYSBzbGFzaCwgd2UgcmVtb3ZlIGl0IGZvciBjb25zaXN0ZW5jeS4gVGhlIHNsYXNoXG4gIC8vIGlzIHZhbGlkIGF0IHRoZSBlbmQgb2YgYSBwYXRoIG1hdGNoLCBub3QgaW4gdGhlIG1pZGRsZS4gVGhpcyBpcyBpbXBvcnRhbnRcbiAgLy8gaW4gbm9uLWVuZGluZyBtb2RlLCB3aGVyZSBcIi90ZXN0L1wiIHNob3VsZG4ndCBtYXRjaCBcIi90ZXN0Ly9yb3V0ZVwiLlxuICBpZiAoIXN0cmljdCkge1xuICAgIHJvdXRlID0gKGVuZHNXaXRoRGVsaW1pdGVyID8gcm91dGUuc2xpY2UoMCwgLWRlbGltaXRlci5sZW5ndGgpIDogcm91dGUpICsgJyg/OicgKyBkZWxpbWl0ZXIgKyAnKD89JCkpPydcbiAgfVxuXG4gIGlmIChlbmQpIHtcbiAgICByb3V0ZSArPSAnJCdcbiAgfSBlbHNlIHtcbiAgICAvLyBJbiBub24tZW5kaW5nIG1vZGUsIHdlIG5lZWQgdGhlIGNhcHR1cmluZyBncm91cHMgdG8gbWF0Y2ggYXMgbXVjaCBhc1xuICAgIC8vIHBvc3NpYmxlIGJ5IHVzaW5nIGEgcG9zaXRpdmUgbG9va2FoZWFkIHRvIHRoZSBlbmQgb3IgbmV4dCBwYXRoIHNlZ21lbnQuXG4gICAgcm91dGUgKz0gc3RyaWN0ICYmIGVuZHNXaXRoRGVsaW1pdGVyID8gJycgOiAnKD89JyArIGRlbGltaXRlciArICd8JCknXG4gIH1cblxuICByZXR1cm4gYXR0YWNoS2V5cyhuZXcgUmVnRXhwKCdeJyArIHJvdXRlLCBmbGFncyhvcHRpb25zKSksIGtleXMpXG59XG5cbi8qKlxuICogTm9ybWFsaXplIHRoZSBnaXZlbiBwYXRoIHN0cmluZywgcmV0dXJuaW5nIGEgcmVndWxhciBleHByZXNzaW9uLlxuICpcbiAqIEFuIGVtcHR5IGFycmF5IGNhbiBiZSBwYXNzZWQgaW4gZm9yIHRoZSBrZXlzLCB3aGljaCB3aWxsIGhvbGQgdGhlXG4gKiBwbGFjZWhvbGRlciBrZXkgZGVzY3JpcHRpb25zLiBGb3IgZXhhbXBsZSwgdXNpbmcgYC91c2VyLzppZGAsIGBrZXlzYCB3aWxsXG4gKiBjb250YWluIGBbeyBuYW1lOiAnaWQnLCBkZWxpbWl0ZXI6ICcvJywgb3B0aW9uYWw6IGZhbHNlLCByZXBlYXQ6IGZhbHNlIH1dYC5cbiAqXG4gKiBAcGFyYW0gIHsoc3RyaW5nfFJlZ0V4cHxBcnJheSl9IHBhdGhcbiAqIEBwYXJhbSAgeyhBcnJheXxPYmplY3QpPX0gICAgICAga2V5c1xuICogQHBhcmFtICB7T2JqZWN0PX0gICAgICAgICAgICAgICBvcHRpb25zXG4gKiBAcmV0dXJuIHshUmVnRXhwfVxuICovXG5mdW5jdGlvbiBwYXRoVG9SZWdleHAgKHBhdGgsIGtleXMsIG9wdGlvbnMpIHtcbiAgaWYgKCFpc2FycmF5KGtleXMpKSB7XG4gICAgb3B0aW9ucyA9IC8qKiBAdHlwZSB7IU9iamVjdH0gKi8gKGtleXMgfHwgb3B0aW9ucylcbiAgICBrZXlzID0gW11cbiAgfVxuXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9XG5cbiAgaWYgKHBhdGggaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICByZXR1cm4gcmVnZXhwVG9SZWdleHAocGF0aCwgLyoqIEB0eXBlIHshQXJyYXl9ICovIChrZXlzKSlcbiAgfVxuXG4gIGlmIChpc2FycmF5KHBhdGgpKSB7XG4gICAgcmV0dXJuIGFycmF5VG9SZWdleHAoLyoqIEB0eXBlIHshQXJyYXl9ICovIChwYXRoKSwgLyoqIEB0eXBlIHshQXJyYXl9ICovIChrZXlzKSwgb3B0aW9ucylcbiAgfVxuXG4gIHJldHVybiBzdHJpbmdUb1JlZ2V4cCgvKiogQHR5cGUge3N0cmluZ30gKi8gKHBhdGgpLCAvKiogQHR5cGUgeyFBcnJheX0gKi8gKGtleXMpLCBvcHRpb25zKVxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///779\n")},703:(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n\nvar ReactPropTypesSecret = __webpack_require__(414);\n\nfunction emptyFunction() {}\nfunction emptyFunctionWithReset() {}\nemptyFunctionWithReset.resetWarningCache = emptyFunction;\n\nmodule.exports = function() {\n  function shim(props, propName, componentName, location, propFullName, secret) {\n    if (secret === ReactPropTypesSecret) {\n      // It is still safe when called from React.\n      return;\n    }\n    var err = new Error(\n      'Calling PropTypes validators directly is not supported by the `prop-types` package. ' +\n      'Use PropTypes.checkPropTypes() to call them. ' +\n      'Read more at http://fb.me/use-check-prop-types'\n    );\n    err.name = 'Invariant Violation';\n    throw err;\n  };\n  shim.isRequired = shim;\n  function getShim() {\n    return shim;\n  };\n  // Important!\n  // Keep this list in sync with production version in `./factoryWithTypeCheckers.js`.\n  var ReactPropTypes = {\n    array: shim,\n    bool: shim,\n    func: shim,\n    number: shim,\n    object: shim,\n    string: shim,\n    symbol: shim,\n\n    any: shim,\n    arrayOf: getShim,\n    element: shim,\n    elementType: shim,\n    instanceOf: getShim,\n    node: shim,\n    objectOf: getShim,\n    oneOf: getShim,\n    oneOfType: getShim,\n    shape: getShim,\n    exact: getShim,\n\n    checkPropTypes: emptyFunctionWithReset,\n    resetWarningCache: emptyFunction\n  };\n\n  ReactPropTypes.PropTypes = ReactPropTypes;\n\n  return ReactPropTypes;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzAzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFYTs7QUFFYiwyQkFBMkIsbUJBQU8sQ0FBQyxHQUE0Qjs7QUFFL0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9ub2RlX21vZHVsZXMvcHJvcC10eXBlcy9mYWN0b3J5V2l0aFRocm93aW5nU2hpbXMuanM/ZDdhMCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0UHJvcFR5cGVzU2VjcmV0ID0gcmVxdWlyZSgnLi9saWIvUmVhY3RQcm9wVHlwZXNTZWNyZXQnKTtcblxuZnVuY3Rpb24gZW1wdHlGdW5jdGlvbigpIHt9XG5mdW5jdGlvbiBlbXB0eUZ1bmN0aW9uV2l0aFJlc2V0KCkge31cbmVtcHR5RnVuY3Rpb25XaXRoUmVzZXQucmVzZXRXYXJuaW5nQ2FjaGUgPSBlbXB0eUZ1bmN0aW9uO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKCkge1xuICBmdW5jdGlvbiBzaGltKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSwgc2VjcmV0KSB7XG4gICAgaWYgKHNlY3JldCA9PT0gUmVhY3RQcm9wVHlwZXNTZWNyZXQpIHtcbiAgICAgIC8vIEl0IGlzIHN0aWxsIHNhZmUgd2hlbiBjYWxsZWQgZnJvbSBSZWFjdC5cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIGVyciA9IG5ldyBFcnJvcihcbiAgICAgICdDYWxsaW5nIFByb3BUeXBlcyB2YWxpZGF0b3JzIGRpcmVjdGx5IGlzIG5vdCBzdXBwb3J0ZWQgYnkgdGhlIGBwcm9wLXR5cGVzYCBwYWNrYWdlLiAnICtcbiAgICAgICdVc2UgUHJvcFR5cGVzLmNoZWNrUHJvcFR5cGVzKCkgdG8gY2FsbCB0aGVtLiAnICtcbiAgICAgICdSZWFkIG1vcmUgYXQgaHR0cDovL2ZiLm1lL3VzZS1jaGVjay1wcm9wLXR5cGVzJ1xuICAgICk7XG4gICAgZXJyLm5hbWUgPSAnSW52YXJpYW50IFZpb2xhdGlvbic7XG4gICAgdGhyb3cgZXJyO1xuICB9O1xuICBzaGltLmlzUmVxdWlyZWQgPSBzaGltO1xuICBmdW5jdGlvbiBnZXRTaGltKCkge1xuICAgIHJldHVybiBzaGltO1xuICB9O1xuICAvLyBJbXBvcnRhbnQhXG4gIC8vIEtlZXAgdGhpcyBsaXN0IGluIHN5bmMgd2l0aCBwcm9kdWN0aW9uIHZlcnNpb24gaW4gYC4vZmFjdG9yeVdpdGhUeXBlQ2hlY2tlcnMuanNgLlxuICB2YXIgUmVhY3RQcm9wVHlwZXMgPSB7XG4gICAgYXJyYXk6IHNoaW0sXG4gICAgYm9vbDogc2hpbSxcbiAgICBmdW5jOiBzaGltLFxuICAgIG51bWJlcjogc2hpbSxcbiAgICBvYmplY3Q6IHNoaW0sXG4gICAgc3RyaW5nOiBzaGltLFxuICAgIHN5bWJvbDogc2hpbSxcblxuICAgIGFueTogc2hpbSxcbiAgICBhcnJheU9mOiBnZXRTaGltLFxuICAgIGVsZW1lbnQ6IHNoaW0sXG4gICAgZWxlbWVudFR5cGU6IHNoaW0sXG4gICAgaW5zdGFuY2VPZjogZ2V0U2hpbSxcbiAgICBub2RlOiBzaGltLFxuICAgIG9iamVjdE9mOiBnZXRTaGltLFxuICAgIG9uZU9mOiBnZXRTaGltLFxuICAgIG9uZU9mVHlwZTogZ2V0U2hpbSxcbiAgICBzaGFwZTogZ2V0U2hpbSxcbiAgICBleGFjdDogZ2V0U2hpbSxcblxuICAgIGNoZWNrUHJvcFR5cGVzOiBlbXB0eUZ1bmN0aW9uV2l0aFJlc2V0LFxuICAgIHJlc2V0V2FybmluZ0NhY2hlOiBlbXB0eUZ1bmN0aW9uXG4gIH07XG5cbiAgUmVhY3RQcm9wVHlwZXMuUHJvcFR5cGVzID0gUmVhY3RQcm9wVHlwZXM7XG5cbiAgcmV0dXJuIFJlYWN0UHJvcFR5cGVzO1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///703\n")},697:(module,__unused_webpack_exports,__webpack_require__)=>{eval("/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nif (false) { var throwOnDirectAccess, ReactIs; } else {\n  // By explicitly using `prop-types` you are opting into new production behavior.\n  // http://fb.me/prop-types-in-prod\n  module.exports = __webpack_require__(703)();\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjk3LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxJQUFJLEtBQXFDLEVBQUUscUNBTzFDLENBQUM7QUFDRjtBQUNBO0FBQ0EsbUJBQW1CLG1CQUFPLENBQUMsR0FBNEI7QUFDdkQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9ub2RlX21vZHVsZXMvcHJvcC10eXBlcy9pbmRleC5qcz9kN2JjIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgdmFyIFJlYWN0SXMgPSByZXF1aXJlKCdyZWFjdC1pcycpO1xuXG4gIC8vIEJ5IGV4cGxpY2l0bHkgdXNpbmcgYHByb3AtdHlwZXNgIHlvdSBhcmUgb3B0aW5nIGludG8gbmV3IGRldmVsb3BtZW50IGJlaGF2aW9yLlxuICAvLyBodHRwOi8vZmIubWUvcHJvcC10eXBlcy1pbi1wcm9kXG4gIHZhciB0aHJvd09uRGlyZWN0QWNjZXNzID0gdHJ1ZTtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2ZhY3RvcnlXaXRoVHlwZUNoZWNrZXJzJykoUmVhY3RJcy5pc0VsZW1lbnQsIHRocm93T25EaXJlY3RBY2Nlc3MpO1xufSBlbHNlIHtcbiAgLy8gQnkgZXhwbGljaXRseSB1c2luZyBgcHJvcC10eXBlc2AgeW91IGFyZSBvcHRpbmcgaW50byBuZXcgcHJvZHVjdGlvbiBiZWhhdmlvci5cbiAgLy8gaHR0cDovL2ZiLm1lL3Byb3AtdHlwZXMtaW4tcHJvZFxuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vZmFjdG9yeVdpdGhUaHJvd2luZ1NoaW1zJykoKTtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///697\n")},414:module=>{"use strict";eval("/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n\nvar ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';\n\nmodule.exports = ReactPropTypesSecret;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDE0LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFYTs7QUFFYjs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL21kYy1yZWFjdC8uL25vZGVfbW9kdWxlcy9wcm9wLXR5cGVzL2xpYi9SZWFjdFByb3BUeXBlc1NlY3JldC5qcz81OWIwIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3RQcm9wVHlwZXNTZWNyZXQgPSAnU0VDUkVUX0RPX05PVF9QQVNTX1RISVNfT1JfWU9VX1dJTExfQkVfRklSRUQnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0UHJvcFR5cGVzU2VjcmV0O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///414\n")},448:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('/** @license React v17.0.2\n * react-dom.production.min.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n/*\n Modernizr 3.0.0pre (Custom Build) | MIT\n*/\nvar aa=__webpack_require__(294),m=__webpack_require__(418),r=__webpack_require__(840);function y(a){for(var b="https://reactjs.org/docs/error-decoder.html?invariant="+a,c=1;c<arguments.length;c++)b+="&args[]="+encodeURIComponent(arguments[c]);return"Minified React error #"+a+"; visit "+b+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}if(!aa)throw Error(y(227));var ba=new Set,ca={};function da(a,b){ea(a,b);ea(a+"Capture",b)}\nfunction ea(a,b){ca[a]=b;for(a=0;a<b.length;a++)ba.add(b[a])}\nvar fa=!("undefined"===typeof window||"undefined"===typeof window.document||"undefined"===typeof window.document.createElement),ha=/^[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$/,ia=Object.prototype.hasOwnProperty,\nja={},ka={};function la(a){if(ia.call(ka,a))return!0;if(ia.call(ja,a))return!1;if(ha.test(a))return ka[a]=!0;ja[a]=!0;return!1}function ma(a,b,c,d){if(null!==c&&0===c.type)return!1;switch(typeof b){case "function":case "symbol":return!0;case "boolean":if(d)return!1;if(null!==c)return!c.acceptsBooleans;a=a.toLowerCase().slice(0,5);return"data-"!==a&&"aria-"!==a;default:return!1}}\nfunction na(a,b,c,d){if(null===b||"undefined"===typeof b||ma(a,b,c,d))return!0;if(d)return!1;if(null!==c)switch(c.type){case 3:return!b;case 4:return!1===b;case 5:return isNaN(b);case 6:return isNaN(b)||1>b}return!1}function B(a,b,c,d,e,f,g){this.acceptsBooleans=2===b||3===b||4===b;this.attributeName=d;this.attributeNamespace=e;this.mustUseProperty=c;this.propertyName=a;this.type=b;this.sanitizeURL=f;this.removeEmptyString=g}var D={};\n"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(a){D[a]=new B(a,0,!1,a,null,!1,!1)});[["acceptCharset","accept-charset"],["className","class"],["htmlFor","for"],["httpEquiv","http-equiv"]].forEach(function(a){var b=a[0];D[b]=new B(b,1,!1,a[1],null,!1,!1)});["contentEditable","draggable","spellCheck","value"].forEach(function(a){D[a]=new B(a,2,!1,a.toLowerCase(),null,!1,!1)});\n["autoReverse","externalResourcesRequired","focusable","preserveAlpha"].forEach(function(a){D[a]=new B(a,2,!1,a,null,!1,!1)});"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(a){D[a]=new B(a,3,!1,a.toLowerCase(),null,!1,!1)});\n["checked","multiple","muted","selected"].forEach(function(a){D[a]=new B(a,3,!0,a,null,!1,!1)});["capture","download"].forEach(function(a){D[a]=new B(a,4,!1,a,null,!1,!1)});["cols","rows","size","span"].forEach(function(a){D[a]=new B(a,6,!1,a,null,!1,!1)});["rowSpan","start"].forEach(function(a){D[a]=new B(a,5,!1,a.toLowerCase(),null,!1,!1)});var oa=/[\\-:]([a-z])/g;function pa(a){return a[1].toUpperCase()}\n"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(a){var b=a.replace(oa,\npa);D[b]=new B(b,1,!1,a,null,!1,!1)});"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(a){var b=a.replace(oa,pa);D[b]=new B(b,1,!1,a,"http://www.w3.org/1999/xlink",!1,!1)});["xml:base","xml:lang","xml:space"].forEach(function(a){var b=a.replace(oa,pa);D[b]=new B(b,1,!1,a,"http://www.w3.org/XML/1998/namespace",!1,!1)});["tabIndex","crossOrigin"].forEach(function(a){D[a]=new B(a,1,!1,a.toLowerCase(),null,!1,!1)});\nD.xlinkHref=new B("xlinkHref",1,!1,"xlink:href","http://www.w3.org/1999/xlink",!0,!1);["src","href","action","formAction"].forEach(function(a){D[a]=new B(a,1,!1,a.toLowerCase(),null,!0,!0)});\nfunction qa(a,b,c,d){var e=D.hasOwnProperty(b)?D[b]:null;var f=null!==e?0===e.type:d?!1:!(2<b.length)||"o"!==b[0]&&"O"!==b[0]||"n"!==b[1]&&"N"!==b[1]?!1:!0;f||(na(b,c,e,d)&&(c=null),d||null===e?la(b)&&(null===c?a.removeAttribute(b):a.setAttribute(b,""+c)):e.mustUseProperty?a[e.propertyName]=null===c?3===e.type?!1:"":c:(b=e.attributeName,d=e.attributeNamespace,null===c?a.removeAttribute(b):(e=e.type,c=3===e||4===e&&!0===c?"":""+c,d?a.setAttributeNS(d,b,c):a.setAttribute(b,c))))}\nvar ra=aa.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,sa=60103,ta=60106,ua=60107,wa=60108,xa=60114,ya=60109,za=60110,Aa=60112,Ba=60113,Ca=60120,Da=60115,Ea=60116,Fa=60121,Ga=60128,Ha=60129,Ia=60130,Ja=60131;\nif("function"===typeof Symbol&&Symbol.for){var E=Symbol.for;sa=E("react.element");ta=E("react.portal");ua=E("react.fragment");wa=E("react.strict_mode");xa=E("react.profiler");ya=E("react.provider");za=E("react.context");Aa=E("react.forward_ref");Ba=E("react.suspense");Ca=E("react.suspense_list");Da=E("react.memo");Ea=E("react.lazy");Fa=E("react.block");E("react.scope");Ga=E("react.opaque.id");Ha=E("react.debug_trace_mode");Ia=E("react.offscreen");Ja=E("react.legacy_hidden")}\nvar Ka="function"===typeof Symbol&&Symbol.iterator;function La(a){if(null===a||"object"!==typeof a)return null;a=Ka&&a[Ka]||a["@@iterator"];return"function"===typeof a?a:null}var Ma;function Na(a){if(void 0===Ma)try{throw Error();}catch(c){var b=c.stack.trim().match(/\\n( *(at )?)/);Ma=b&&b[1]||""}return"\\n"+Ma+a}var Oa=!1;\nfunction Pa(a,b){if(!a||Oa)return"";Oa=!0;var c=Error.prepareStackTrace;Error.prepareStackTrace=void 0;try{if(b)if(b=function(){throw Error();},Object.defineProperty(b.prototype,"props",{set:function(){throw Error();}}),"object"===typeof Reflect&&Reflect.construct){try{Reflect.construct(b,[])}catch(k){var d=k}Reflect.construct(a,[],b)}else{try{b.call()}catch(k){d=k}a.call(b.prototype)}else{try{throw Error();}catch(k){d=k}a()}}catch(k){if(k&&d&&"string"===typeof k.stack){for(var e=k.stack.split("\\n"),\nf=d.stack.split("\\n"),g=e.length-1,h=f.length-1;1<=g&&0<=h&&e[g]!==f[h];)h--;for(;1<=g&&0<=h;g--,h--)if(e[g]!==f[h]){if(1!==g||1!==h){do if(g--,h--,0>h||e[g]!==f[h])return"\\n"+e[g].replace(" at new "," at ");while(1<=g&&0<=h)}break}}}finally{Oa=!1,Error.prepareStackTrace=c}return(a=a?a.displayName||a.name:"")?Na(a):""}\nfunction Qa(a){switch(a.tag){case 5:return Na(a.type);case 16:return Na("Lazy");case 13:return Na("Suspense");case 19:return Na("SuspenseList");case 0:case 2:case 15:return a=Pa(a.type,!1),a;case 11:return a=Pa(a.type.render,!1),a;case 22:return a=Pa(a.type._render,!1),a;case 1:return a=Pa(a.type,!0),a;default:return""}}\nfunction Ra(a){if(null==a)return null;if("function"===typeof a)return a.displayName||a.name||null;if("string"===typeof a)return a;switch(a){case ua:return"Fragment";case ta:return"Portal";case xa:return"Profiler";case wa:return"StrictMode";case Ba:return"Suspense";case Ca:return"SuspenseList"}if("object"===typeof a)switch(a.$$typeof){case za:return(a.displayName||"Context")+".Consumer";case ya:return(a._context.displayName||"Context")+".Provider";case Aa:var b=a.render;b=b.displayName||b.name||"";\nreturn a.displayName||(""!==b?"ForwardRef("+b+")":"ForwardRef");case Da:return Ra(a.type);case Fa:return Ra(a._render);case Ea:b=a._payload;a=a._init;try{return Ra(a(b))}catch(c){}}return null}function Sa(a){switch(typeof a){case "boolean":case "number":case "object":case "string":case "undefined":return a;default:return""}}function Ta(a){var b=a.type;return(a=a.nodeName)&&"input"===a.toLowerCase()&&("checkbox"===b||"radio"===b)}\nfunction Ua(a){var b=Ta(a)?"checked":"value",c=Object.getOwnPropertyDescriptor(a.constructor.prototype,b),d=""+a[b];if(!a.hasOwnProperty(b)&&"undefined"!==typeof c&&"function"===typeof c.get&&"function"===typeof c.set){var e=c.get,f=c.set;Object.defineProperty(a,b,{configurable:!0,get:function(){return e.call(this)},set:function(a){d=""+a;f.call(this,a)}});Object.defineProperty(a,b,{enumerable:c.enumerable});return{getValue:function(){return d},setValue:function(a){d=""+a},stopTracking:function(){a._valueTracker=\nnull;delete a[b]}}}}function Va(a){a._valueTracker||(a._valueTracker=Ua(a))}function Wa(a){if(!a)return!1;var b=a._valueTracker;if(!b)return!0;var c=b.getValue();var d="";a&&(d=Ta(a)?a.checked?"true":"false":a.value);a=d;return a!==c?(b.setValue(a),!0):!1}function Xa(a){a=a||("undefined"!==typeof document?document:void 0);if("undefined"===typeof a)return null;try{return a.activeElement||a.body}catch(b){return a.body}}\nfunction Ya(a,b){var c=b.checked;return m({},b,{defaultChecked:void 0,defaultValue:void 0,value:void 0,checked:null!=c?c:a._wrapperState.initialChecked})}function Za(a,b){var c=null==b.defaultValue?"":b.defaultValue,d=null!=b.checked?b.checked:b.defaultChecked;c=Sa(null!=b.value?b.value:c);a._wrapperState={initialChecked:d,initialValue:c,controlled:"checkbox"===b.type||"radio"===b.type?null!=b.checked:null!=b.value}}function $a(a,b){b=b.checked;null!=b&&qa(a,"checked",b,!1)}\nfunction ab(a,b){$a(a,b);var c=Sa(b.value),d=b.type;if(null!=c)if("number"===d){if(0===c&&""===a.value||a.value!=c)a.value=""+c}else a.value!==""+c&&(a.value=""+c);else if("submit"===d||"reset"===d){a.removeAttribute("value");return}b.hasOwnProperty("value")?bb(a,b.type,c):b.hasOwnProperty("defaultValue")&&bb(a,b.type,Sa(b.defaultValue));null==b.checked&&null!=b.defaultChecked&&(a.defaultChecked=!!b.defaultChecked)}\nfunction cb(a,b,c){if(b.hasOwnProperty("value")||b.hasOwnProperty("defaultValue")){var d=b.type;if(!("submit"!==d&&"reset"!==d||void 0!==b.value&&null!==b.value))return;b=""+a._wrapperState.initialValue;c||b===a.value||(a.value=b);a.defaultValue=b}c=a.name;""!==c&&(a.name="");a.defaultChecked=!!a._wrapperState.initialChecked;""!==c&&(a.name=c)}\nfunction bb(a,b,c){if("number"!==b||Xa(a.ownerDocument)!==a)null==c?a.defaultValue=""+a._wrapperState.initialValue:a.defaultValue!==""+c&&(a.defaultValue=""+c)}function db(a){var b="";aa.Children.forEach(a,function(a){null!=a&&(b+=a)});return b}function eb(a,b){a=m({children:void 0},b);if(b=db(b.children))a.children=b;return a}\nfunction fb(a,b,c,d){a=a.options;if(b){b={};for(var e=0;e<c.length;e++)b["$"+c[e]]=!0;for(c=0;c<a.length;c++)e=b.hasOwnProperty("$"+a[c].value),a[c].selected!==e&&(a[c].selected=e),e&&d&&(a[c].defaultSelected=!0)}else{c=""+Sa(c);b=null;for(e=0;e<a.length;e++){if(a[e].value===c){a[e].selected=!0;d&&(a[e].defaultSelected=!0);return}null!==b||a[e].disabled||(b=a[e])}null!==b&&(b.selected=!0)}}\nfunction gb(a,b){if(null!=b.dangerouslySetInnerHTML)throw Error(y(91));return m({},b,{value:void 0,defaultValue:void 0,children:""+a._wrapperState.initialValue})}function hb(a,b){var c=b.value;if(null==c){c=b.children;b=b.defaultValue;if(null!=c){if(null!=b)throw Error(y(92));if(Array.isArray(c)){if(!(1>=c.length))throw Error(y(93));c=c[0]}b=c}null==b&&(b="");c=b}a._wrapperState={initialValue:Sa(c)}}\nfunction ib(a,b){var c=Sa(b.value),d=Sa(b.defaultValue);null!=c&&(c=""+c,c!==a.value&&(a.value=c),null==b.defaultValue&&a.defaultValue!==c&&(a.defaultValue=c));null!=d&&(a.defaultValue=""+d)}function jb(a){var b=a.textContent;b===a._wrapperState.initialValue&&""!==b&&null!==b&&(a.value=b)}var kb={html:"http://www.w3.org/1999/xhtml",mathml:"http://www.w3.org/1998/Math/MathML",svg:"http://www.w3.org/2000/svg"};\nfunction lb(a){switch(a){case "svg":return"http://www.w3.org/2000/svg";case "math":return"http://www.w3.org/1998/Math/MathML";default:return"http://www.w3.org/1999/xhtml"}}function mb(a,b){return null==a||"http://www.w3.org/1999/xhtml"===a?lb(b):"http://www.w3.org/2000/svg"===a&&"foreignObject"===b?"http://www.w3.org/1999/xhtml":a}\nvar nb,ob=function(a){return"undefined"!==typeof MSApp&&MSApp.execUnsafeLocalFunction?function(b,c,d,e){MSApp.execUnsafeLocalFunction(function(){return a(b,c,d,e)})}:a}(function(a,b){if(a.namespaceURI!==kb.svg||"innerHTML"in a)a.innerHTML=b;else{nb=nb||document.createElement("div");nb.innerHTML="<svg>"+b.valueOf().toString()+"</svg>";for(b=nb.firstChild;a.firstChild;)a.removeChild(a.firstChild);for(;b.firstChild;)a.appendChild(b.firstChild)}});\nfunction pb(a,b){if(b){var c=a.firstChild;if(c&&c===a.lastChild&&3===c.nodeType){c.nodeValue=b;return}}a.textContent=b}\nvar qb={animationIterationCount:!0,borderImageOutset:!0,borderImageSlice:!0,borderImageWidth:!0,boxFlex:!0,boxFlexGroup:!0,boxOrdinalGroup:!0,columnCount:!0,columns:!0,flex:!0,flexGrow:!0,flexPositive:!0,flexShrink:!0,flexNegative:!0,flexOrder:!0,gridArea:!0,gridRow:!0,gridRowEnd:!0,gridRowSpan:!0,gridRowStart:!0,gridColumn:!0,gridColumnEnd:!0,gridColumnSpan:!0,gridColumnStart:!0,fontWeight:!0,lineClamp:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,tabSize:!0,widows:!0,zIndex:!0,zoom:!0,fillOpacity:!0,\nfloodOpacity:!0,stopOpacity:!0,strokeDasharray:!0,strokeDashoffset:!0,strokeMiterlimit:!0,strokeOpacity:!0,strokeWidth:!0},rb=["Webkit","ms","Moz","O"];Object.keys(qb).forEach(function(a){rb.forEach(function(b){b=b+a.charAt(0).toUpperCase()+a.substring(1);qb[b]=qb[a]})});function sb(a,b,c){return null==b||"boolean"===typeof b||""===b?"":c||"number"!==typeof b||0===b||qb.hasOwnProperty(a)&&qb[a]?(""+b).trim():b+"px"}\nfunction tb(a,b){a=a.style;for(var c in b)if(b.hasOwnProperty(c)){var d=0===c.indexOf("--"),e=sb(c,b[c],d);"float"===c&&(c="cssFloat");d?a.setProperty(c,e):a[c]=e}}var ub=m({menuitem:!0},{area:!0,base:!0,br:!0,col:!0,embed:!0,hr:!0,img:!0,input:!0,keygen:!0,link:!0,meta:!0,param:!0,source:!0,track:!0,wbr:!0});\nfunction vb(a,b){if(b){if(ub[a]&&(null!=b.children||null!=b.dangerouslySetInnerHTML))throw Error(y(137,a));if(null!=b.dangerouslySetInnerHTML){if(null!=b.children)throw Error(y(60));if(!("object"===typeof b.dangerouslySetInnerHTML&&"__html"in b.dangerouslySetInnerHTML))throw Error(y(61));}if(null!=b.style&&"object"!==typeof b.style)throw Error(y(62));}}\nfunction wb(a,b){if(-1===a.indexOf("-"))return"string"===typeof b.is;switch(a){case "annotation-xml":case "color-profile":case "font-face":case "font-face-src":case "font-face-uri":case "font-face-format":case "font-face-name":case "missing-glyph":return!1;default:return!0}}function xb(a){a=a.target||a.srcElement||window;a.correspondingUseElement&&(a=a.correspondingUseElement);return 3===a.nodeType?a.parentNode:a}var yb=null,zb=null,Ab=null;\nfunction Bb(a){if(a=Cb(a)){if("function"!==typeof yb)throw Error(y(280));var b=a.stateNode;b&&(b=Db(b),yb(a.stateNode,a.type,b))}}function Eb(a){zb?Ab?Ab.push(a):Ab=[a]:zb=a}function Fb(){if(zb){var a=zb,b=Ab;Ab=zb=null;Bb(a);if(b)for(a=0;a<b.length;a++)Bb(b[a])}}function Gb(a,b){return a(b)}function Hb(a,b,c,d,e){return a(b,c,d,e)}function Ib(){}var Jb=Gb,Kb=!1,Lb=!1;function Mb(){if(null!==zb||null!==Ab)Ib(),Fb()}\nfunction Nb(a,b,c){if(Lb)return a(b,c);Lb=!0;try{return Jb(a,b,c)}finally{Lb=!1,Mb()}}\nfunction Ob(a,b){var c=a.stateNode;if(null===c)return null;var d=Db(c);if(null===d)return null;c=d[b];a:switch(b){case "onClick":case "onClickCapture":case "onDoubleClick":case "onDoubleClickCapture":case "onMouseDown":case "onMouseDownCapture":case "onMouseMove":case "onMouseMoveCapture":case "onMouseUp":case "onMouseUpCapture":case "onMouseEnter":(d=!d.disabled)||(a=a.type,d=!("button"===a||"input"===a||"select"===a||"textarea"===a));a=!d;break a;default:a=!1}if(a)return null;if(c&&"function"!==\ntypeof c)throw Error(y(231,b,typeof c));return c}var Pb=!1;if(fa)try{var Qb={};Object.defineProperty(Qb,"passive",{get:function(){Pb=!0}});window.addEventListener("test",Qb,Qb);window.removeEventListener("test",Qb,Qb)}catch(a){Pb=!1}function Rb(a,b,c,d,e,f,g,h,k){var l=Array.prototype.slice.call(arguments,3);try{b.apply(c,l)}catch(n){this.onError(n)}}var Sb=!1,Tb=null,Ub=!1,Vb=null,Wb={onError:function(a){Sb=!0;Tb=a}};function Xb(a,b,c,d,e,f,g,h,k){Sb=!1;Tb=null;Rb.apply(Wb,arguments)}\nfunction Yb(a,b,c,d,e,f,g,h,k){Xb.apply(this,arguments);if(Sb){if(Sb){var l=Tb;Sb=!1;Tb=null}else throw Error(y(198));Ub||(Ub=!0,Vb=l)}}function Zb(a){var b=a,c=a;if(a.alternate)for(;b.return;)b=b.return;else{a=b;do b=a,0!==(b.flags&1026)&&(c=b.return),a=b.return;while(a)}return 3===b.tag?c:null}function $b(a){if(13===a.tag){var b=a.memoizedState;null===b&&(a=a.alternate,null!==a&&(b=a.memoizedState));if(null!==b)return b.dehydrated}return null}function ac(a){if(Zb(a)!==a)throw Error(y(188));}\nfunction bc(a){var b=a.alternate;if(!b){b=Zb(a);if(null===b)throw Error(y(188));return b!==a?null:a}for(var c=a,d=b;;){var e=c.return;if(null===e)break;var f=e.alternate;if(null===f){d=e.return;if(null!==d){c=d;continue}break}if(e.child===f.child){for(f=e.child;f;){if(f===c)return ac(e),a;if(f===d)return ac(e),b;f=f.sibling}throw Error(y(188));}if(c.return!==d.return)c=e,d=f;else{for(var g=!1,h=e.child;h;){if(h===c){g=!0;c=e;d=f;break}if(h===d){g=!0;d=e;c=f;break}h=h.sibling}if(!g){for(h=f.child;h;){if(h===\nc){g=!0;c=f;d=e;break}if(h===d){g=!0;d=f;c=e;break}h=h.sibling}if(!g)throw Error(y(189));}}if(c.alternate!==d)throw Error(y(190));}if(3!==c.tag)throw Error(y(188));return c.stateNode.current===c?a:b}function cc(a){a=bc(a);if(!a)return null;for(var b=a;;){if(5===b.tag||6===b.tag)return b;if(b.child)b.child.return=b,b=b.child;else{if(b===a)break;for(;!b.sibling;){if(!b.return||b.return===a)return null;b=b.return}b.sibling.return=b.return;b=b.sibling}}return null}\nfunction dc(a,b){for(var c=a.alternate;null!==b;){if(b===a||b===c)return!0;b=b.return}return!1}var ec,fc,gc,hc,ic=!1,jc=[],kc=null,lc=null,mc=null,nc=new Map,oc=new Map,pc=[],qc="mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");\nfunction rc(a,b,c,d,e){return{blockedOn:a,domEventName:b,eventSystemFlags:c|16,nativeEvent:e,targetContainers:[d]}}function sc(a,b){switch(a){case "focusin":case "focusout":kc=null;break;case "dragenter":case "dragleave":lc=null;break;case "mouseover":case "mouseout":mc=null;break;case "pointerover":case "pointerout":nc.delete(b.pointerId);break;case "gotpointercapture":case "lostpointercapture":oc.delete(b.pointerId)}}\nfunction tc(a,b,c,d,e,f){if(null===a||a.nativeEvent!==f)return a=rc(b,c,d,e,f),null!==b&&(b=Cb(b),null!==b&&fc(b)),a;a.eventSystemFlags|=d;b=a.targetContainers;null!==e&&-1===b.indexOf(e)&&b.push(e);return a}\nfunction uc(a,b,c,d,e){switch(b){case "focusin":return kc=tc(kc,a,b,c,d,e),!0;case "dragenter":return lc=tc(lc,a,b,c,d,e),!0;case "mouseover":return mc=tc(mc,a,b,c,d,e),!0;case "pointerover":var f=e.pointerId;nc.set(f,tc(nc.get(f)||null,a,b,c,d,e));return!0;case "gotpointercapture":return f=e.pointerId,oc.set(f,tc(oc.get(f)||null,a,b,c,d,e)),!0}return!1}\nfunction vc(a){var b=wc(a.target);if(null!==b){var c=Zb(b);if(null!==c)if(b=c.tag,13===b){if(b=$b(c),null!==b){a.blockedOn=b;hc(a.lanePriority,function(){r.unstable_runWithPriority(a.priority,function(){gc(c)})});return}}else if(3===b&&c.stateNode.hydrate){a.blockedOn=3===c.tag?c.stateNode.containerInfo:null;return}}a.blockedOn=null}\nfunction xc(a){if(null!==a.blockedOn)return!1;for(var b=a.targetContainers;0<b.length;){var c=yc(a.domEventName,a.eventSystemFlags,b[0],a.nativeEvent);if(null!==c)return b=Cb(c),null!==b&&fc(b),a.blockedOn=c,!1;b.shift()}return!0}function zc(a,b,c){xc(a)&&c.delete(b)}\nfunction Ac(){for(ic=!1;0<jc.length;){var a=jc[0];if(null!==a.blockedOn){a=Cb(a.blockedOn);null!==a&&ec(a);break}for(var b=a.targetContainers;0<b.length;){var c=yc(a.domEventName,a.eventSystemFlags,b[0],a.nativeEvent);if(null!==c){a.blockedOn=c;break}b.shift()}null===a.blockedOn&&jc.shift()}null!==kc&&xc(kc)&&(kc=null);null!==lc&&xc(lc)&&(lc=null);null!==mc&&xc(mc)&&(mc=null);nc.forEach(zc);oc.forEach(zc)}\nfunction Bc(a,b){a.blockedOn===b&&(a.blockedOn=null,ic||(ic=!0,r.unstable_scheduleCallback(r.unstable_NormalPriority,Ac)))}\nfunction Cc(a){function b(b){return Bc(b,a)}if(0<jc.length){Bc(jc[0],a);for(var c=1;c<jc.length;c++){var d=jc[c];d.blockedOn===a&&(d.blockedOn=null)}}null!==kc&&Bc(kc,a);null!==lc&&Bc(lc,a);null!==mc&&Bc(mc,a);nc.forEach(b);oc.forEach(b);for(c=0;c<pc.length;c++)d=pc[c],d.blockedOn===a&&(d.blockedOn=null);for(;0<pc.length&&(c=pc[0],null===c.blockedOn);)vc(c),null===c.blockedOn&&pc.shift()}\nfunction Dc(a,b){var c={};c[a.toLowerCase()]=b.toLowerCase();c["Webkit"+a]="webkit"+b;c["Moz"+a]="moz"+b;return c}var Ec={animationend:Dc("Animation","AnimationEnd"),animationiteration:Dc("Animation","AnimationIteration"),animationstart:Dc("Animation","AnimationStart"),transitionend:Dc("Transition","TransitionEnd")},Fc={},Gc={};\nfa&&(Gc=document.createElement("div").style,"AnimationEvent"in window||(delete Ec.animationend.animation,delete Ec.animationiteration.animation,delete Ec.animationstart.animation),"TransitionEvent"in window||delete Ec.transitionend.transition);function Hc(a){if(Fc[a])return Fc[a];if(!Ec[a])return a;var b=Ec[a],c;for(c in b)if(b.hasOwnProperty(c)&&c in Gc)return Fc[a]=b[c];return a}\nvar Ic=Hc("animationend"),Jc=Hc("animationiteration"),Kc=Hc("animationstart"),Lc=Hc("transitionend"),Mc=new Map,Nc=new Map,Oc=["abort","abort",Ic,"animationEnd",Jc,"animationIteration",Kc,"animationStart","canplay","canPlay","canplaythrough","canPlayThrough","durationchange","durationChange","emptied","emptied","encrypted","encrypted","ended","ended","error","error","gotpointercapture","gotPointerCapture","load","load","loadeddata","loadedData","loadedmetadata","loadedMetadata","loadstart","loadStart",\n"lostpointercapture","lostPointerCapture","playing","playing","progress","progress","seeking","seeking","stalled","stalled","suspend","suspend","timeupdate","timeUpdate",Lc,"transitionEnd","waiting","waiting"];function Pc(a,b){for(var c=0;c<a.length;c+=2){var d=a[c],e=a[c+1];e="on"+(e[0].toUpperCase()+e.slice(1));Nc.set(d,b);Mc.set(d,e);da(e,[d])}}var Qc=r.unstable_now;Qc();var F=8;\nfunction Rc(a){if(0!==(1&a))return F=15,1;if(0!==(2&a))return F=14,2;if(0!==(4&a))return F=13,4;var b=24&a;if(0!==b)return F=12,b;if(0!==(a&32))return F=11,32;b=192&a;if(0!==b)return F=10,b;if(0!==(a&256))return F=9,256;b=3584&a;if(0!==b)return F=8,b;if(0!==(a&4096))return F=7,4096;b=4186112&a;if(0!==b)return F=6,b;b=62914560&a;if(0!==b)return F=5,b;if(a&67108864)return F=4,67108864;if(0!==(a&134217728))return F=3,134217728;b=805306368&a;if(0!==b)return F=2,b;if(0!==(1073741824&a))return F=1,1073741824;\nF=8;return a}function Sc(a){switch(a){case 99:return 15;case 98:return 10;case 97:case 96:return 8;case 95:return 2;default:return 0}}function Tc(a){switch(a){case 15:case 14:return 99;case 13:case 12:case 11:case 10:return 98;case 9:case 8:case 7:case 6:case 4:case 5:return 97;case 3:case 2:case 1:return 95;case 0:return 90;default:throw Error(y(358,a));}}\nfunction Uc(a,b){var c=a.pendingLanes;if(0===c)return F=0;var d=0,e=0,f=a.expiredLanes,g=a.suspendedLanes,h=a.pingedLanes;if(0!==f)d=f,e=F=15;else if(f=c&134217727,0!==f){var k=f&~g;0!==k?(d=Rc(k),e=F):(h&=f,0!==h&&(d=Rc(h),e=F))}else f=c&~g,0!==f?(d=Rc(f),e=F):0!==h&&(d=Rc(h),e=F);if(0===d)return 0;d=31-Vc(d);d=c&((0>d?0:1<<d)<<1)-1;if(0!==b&&b!==d&&0===(b&g)){Rc(b);if(e<=F)return b;F=e}b=a.entangledLanes;if(0!==b)for(a=a.entanglements,b&=d;0<b;)c=31-Vc(b),e=1<<c,d|=a[c],b&=~e;return d}\nfunction Wc(a){a=a.pendingLanes&-1073741825;return 0!==a?a:a&1073741824?1073741824:0}function Xc(a,b){switch(a){case 15:return 1;case 14:return 2;case 12:return a=Yc(24&~b),0===a?Xc(10,b):a;case 10:return a=Yc(192&~b),0===a?Xc(8,b):a;case 8:return a=Yc(3584&~b),0===a&&(a=Yc(4186112&~b),0===a&&(a=512)),a;case 2:return b=Yc(805306368&~b),0===b&&(b=268435456),b}throw Error(y(358,a));}function Yc(a){return a&-a}function Zc(a){for(var b=[],c=0;31>c;c++)b.push(a);return b}\nfunction $c(a,b,c){a.pendingLanes|=b;var d=b-1;a.suspendedLanes&=d;a.pingedLanes&=d;a=a.eventTimes;b=31-Vc(b);a[b]=c}var Vc=Math.clz32?Math.clz32:ad,bd=Math.log,cd=Math.LN2;function ad(a){return 0===a?32:31-(bd(a)/cd|0)|0}var dd=r.unstable_UserBlockingPriority,ed=r.unstable_runWithPriority,fd=!0;function gd(a,b,c,d){Kb||Ib();var e=hd,f=Kb;Kb=!0;try{Hb(e,a,b,c,d)}finally{(Kb=f)||Mb()}}function id(a,b,c,d){ed(dd,hd.bind(null,a,b,c,d))}\nfunction hd(a,b,c,d){if(fd){var e;if((e=0===(b&4))&&0<jc.length&&-1<qc.indexOf(a))a=rc(null,a,b,c,d),jc.push(a);else{var f=yc(a,b,c,d);if(null===f)e&&sc(a,d);else{if(e){if(-1<qc.indexOf(a)){a=rc(f,a,b,c,d);jc.push(a);return}if(uc(f,a,b,c,d))return;sc(a,d)}jd(a,b,d,null,c)}}}}\nfunction yc(a,b,c,d){var e=xb(d);e=wc(e);if(null!==e){var f=Zb(e);if(null===f)e=null;else{var g=f.tag;if(13===g){e=$b(f);if(null!==e)return e;e=null}else if(3===g){if(f.stateNode.hydrate)return 3===f.tag?f.stateNode.containerInfo:null;e=null}else f!==e&&(e=null)}}jd(a,b,d,e,c);return null}var kd=null,ld=null,md=null;\nfunction nd(){if(md)return md;var a,b=ld,c=b.length,d,e="value"in kd?kd.value:kd.textContent,f=e.length;for(a=0;a<c&&b[a]===e[a];a++);var g=c-a;for(d=1;d<=g&&b[c-d]===e[f-d];d++);return md=e.slice(a,1<d?1-d:void 0)}function od(a){var b=a.keyCode;"charCode"in a?(a=a.charCode,0===a&&13===b&&(a=13)):a=b;10===a&&(a=13);return 32<=a||13===a?a:0}function pd(){return!0}function qd(){return!1}\nfunction rd(a){function b(b,d,e,f,g){this._reactName=b;this._targetInst=e;this.type=d;this.nativeEvent=f;this.target=g;this.currentTarget=null;for(var c in a)a.hasOwnProperty(c)&&(b=a[c],this[c]=b?b(f):f[c]);this.isDefaultPrevented=(null!=f.defaultPrevented?f.defaultPrevented:!1===f.returnValue)?pd:qd;this.isPropagationStopped=qd;return this}m(b.prototype,{preventDefault:function(){this.defaultPrevented=!0;var a=this.nativeEvent;a&&(a.preventDefault?a.preventDefault():"unknown"!==typeof a.returnValue&&\n(a.returnValue=!1),this.isDefaultPrevented=pd)},stopPropagation:function(){var a=this.nativeEvent;a&&(a.stopPropagation?a.stopPropagation():"unknown"!==typeof a.cancelBubble&&(a.cancelBubble=!0),this.isPropagationStopped=pd)},persist:function(){},isPersistent:pd});return b}\nvar sd={eventPhase:0,bubbles:0,cancelable:0,timeStamp:function(a){return a.timeStamp||Date.now()},defaultPrevented:0,isTrusted:0},td=rd(sd),ud=m({},sd,{view:0,detail:0}),vd=rd(ud),wd,xd,yd,Ad=m({},ud,{screenX:0,screenY:0,clientX:0,clientY:0,pageX:0,pageY:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,getModifierState:zd,button:0,buttons:0,relatedTarget:function(a){return void 0===a.relatedTarget?a.fromElement===a.srcElement?a.toElement:a.fromElement:a.relatedTarget},movementX:function(a){if("movementX"in\na)return a.movementX;a!==yd&&(yd&&"mousemove"===a.type?(wd=a.screenX-yd.screenX,xd=a.screenY-yd.screenY):xd=wd=0,yd=a);return wd},movementY:function(a){return"movementY"in a?a.movementY:xd}}),Bd=rd(Ad),Cd=m({},Ad,{dataTransfer:0}),Dd=rd(Cd),Ed=m({},ud,{relatedTarget:0}),Fd=rd(Ed),Gd=m({},sd,{animationName:0,elapsedTime:0,pseudoElement:0}),Hd=rd(Gd),Id=m({},sd,{clipboardData:function(a){return"clipboardData"in a?a.clipboardData:window.clipboardData}}),Jd=rd(Id),Kd=m({},sd,{data:0}),Ld=rd(Kd),Md={Esc:"Escape",\nSpacebar:" ",Left:"ArrowLeft",Up:"ArrowUp",Right:"ArrowRight",Down:"ArrowDown",Del:"Delete",Win:"OS",Menu:"ContextMenu",Apps:"ContextMenu",Scroll:"ScrollLock",MozPrintableKey:"Unidentified"},Nd={8:"Backspace",9:"Tab",12:"Clear",13:"Enter",16:"Shift",17:"Control",18:"Alt",19:"Pause",20:"CapsLock",27:"Escape",32:" ",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"ArrowLeft",38:"ArrowUp",39:"ArrowRight",40:"ArrowDown",45:"Insert",46:"Delete",112:"F1",113:"F2",114:"F3",115:"F4",116:"F5",117:"F6",118:"F7",\n119:"F8",120:"F9",121:"F10",122:"F11",123:"F12",144:"NumLock",145:"ScrollLock",224:"Meta"},Od={Alt:"altKey",Control:"ctrlKey",Meta:"metaKey",Shift:"shiftKey"};function Pd(a){var b=this.nativeEvent;return b.getModifierState?b.getModifierState(a):(a=Od[a])?!!b[a]:!1}function zd(){return Pd}\nvar Qd=m({},ud,{key:function(a){if(a.key){var b=Md[a.key]||a.key;if("Unidentified"!==b)return b}return"keypress"===a.type?(a=od(a),13===a?"Enter":String.fromCharCode(a)):"keydown"===a.type||"keyup"===a.type?Nd[a.keyCode]||"Unidentified":""},code:0,location:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,repeat:0,locale:0,getModifierState:zd,charCode:function(a){return"keypress"===a.type?od(a):0},keyCode:function(a){return"keydown"===a.type||"keyup"===a.type?a.keyCode:0},which:function(a){return"keypress"===\na.type?od(a):"keydown"===a.type||"keyup"===a.type?a.keyCode:0}}),Rd=rd(Qd),Sd=m({},Ad,{pointerId:0,width:0,height:0,pressure:0,tangentialPressure:0,tiltX:0,tiltY:0,twist:0,pointerType:0,isPrimary:0}),Td=rd(Sd),Ud=m({},ud,{touches:0,targetTouches:0,changedTouches:0,altKey:0,metaKey:0,ctrlKey:0,shiftKey:0,getModifierState:zd}),Vd=rd(Ud),Wd=m({},sd,{propertyName:0,elapsedTime:0,pseudoElement:0}),Xd=rd(Wd),Yd=m({},Ad,{deltaX:function(a){return"deltaX"in a?a.deltaX:"wheelDeltaX"in a?-a.wheelDeltaX:0},\ndeltaY:function(a){return"deltaY"in a?a.deltaY:"wheelDeltaY"in a?-a.wheelDeltaY:"wheelDelta"in a?-a.wheelDelta:0},deltaZ:0,deltaMode:0}),Zd=rd(Yd),$d=[9,13,27,32],ae=fa&&"CompositionEvent"in window,be=null;fa&&"documentMode"in document&&(be=document.documentMode);var ce=fa&&"TextEvent"in window&&!be,de=fa&&(!ae||be&&8<be&&11>=be),ee=String.fromCharCode(32),fe=!1;\nfunction ge(a,b){switch(a){case "keyup":return-1!==$d.indexOf(b.keyCode);case "keydown":return 229!==b.keyCode;case "keypress":case "mousedown":case "focusout":return!0;default:return!1}}function he(a){a=a.detail;return"object"===typeof a&&"data"in a?a.data:null}var ie=!1;function je(a,b){switch(a){case "compositionend":return he(b);case "keypress":if(32!==b.which)return null;fe=!0;return ee;case "textInput":return a=b.data,a===ee&&fe?null:a;default:return null}}\nfunction ke(a,b){if(ie)return"compositionend"===a||!ae&&ge(a,b)?(a=nd(),md=ld=kd=null,ie=!1,a):null;switch(a){case "paste":return null;case "keypress":if(!(b.ctrlKey||b.altKey||b.metaKey)||b.ctrlKey&&b.altKey){if(b.char&&1<b.char.length)return b.char;if(b.which)return String.fromCharCode(b.which)}return null;case "compositionend":return de&&"ko"!==b.locale?null:b.data;default:return null}}\nvar le={color:!0,date:!0,datetime:!0,"datetime-local":!0,email:!0,month:!0,number:!0,password:!0,range:!0,search:!0,tel:!0,text:!0,time:!0,url:!0,week:!0};function me(a){var b=a&&a.nodeName&&a.nodeName.toLowerCase();return"input"===b?!!le[a.type]:"textarea"===b?!0:!1}function ne(a,b,c,d){Eb(d);b=oe(b,"onChange");0<b.length&&(c=new td("onChange","change",null,c,d),a.push({event:c,listeners:b}))}var pe=null,qe=null;function re(a){se(a,0)}function te(a){var b=ue(a);if(Wa(b))return a}\nfunction ve(a,b){if("change"===a)return b}var we=!1;if(fa){var xe;if(fa){var ye="oninput"in document;if(!ye){var ze=document.createElement("div");ze.setAttribute("oninput","return;");ye="function"===typeof ze.oninput}xe=ye}else xe=!1;we=xe&&(!document.documentMode||9<document.documentMode)}function Ae(){pe&&(pe.detachEvent("onpropertychange",Be),qe=pe=null)}function Be(a){if("value"===a.propertyName&&te(qe)){var b=[];ne(b,qe,a,xb(a));a=re;if(Kb)a(b);else{Kb=!0;try{Gb(a,b)}finally{Kb=!1,Mb()}}}}\nfunction Ce(a,b,c){"focusin"===a?(Ae(),pe=b,qe=c,pe.attachEvent("onpropertychange",Be)):"focusout"===a&&Ae()}function De(a){if("selectionchange"===a||"keyup"===a||"keydown"===a)return te(qe)}function Ee(a,b){if("click"===a)return te(b)}function Fe(a,b){if("input"===a||"change"===a)return te(b)}function Ge(a,b){return a===b&&(0!==a||1/a===1/b)||a!==a&&b!==b}var He="function"===typeof Object.is?Object.is:Ge,Ie=Object.prototype.hasOwnProperty;\nfunction Je(a,b){if(He(a,b))return!0;if("object"!==typeof a||null===a||"object"!==typeof b||null===b)return!1;var c=Object.keys(a),d=Object.keys(b);if(c.length!==d.length)return!1;for(d=0;d<c.length;d++)if(!Ie.call(b,c[d])||!He(a[c[d]],b[c[d]]))return!1;return!0}function Ke(a){for(;a&&a.firstChild;)a=a.firstChild;return a}\nfunction Le(a,b){var c=Ke(a);a=0;for(var d;c;){if(3===c.nodeType){d=a+c.textContent.length;if(a<=b&&d>=b)return{node:c,offset:b-a};a=d}a:{for(;c;){if(c.nextSibling){c=c.nextSibling;break a}c=c.parentNode}c=void 0}c=Ke(c)}}function Me(a,b){return a&&b?a===b?!0:a&&3===a.nodeType?!1:b&&3===b.nodeType?Me(a,b.parentNode):"contains"in a?a.contains(b):a.compareDocumentPosition?!!(a.compareDocumentPosition(b)&16):!1:!1}\nfunction Ne(){for(var a=window,b=Xa();b instanceof a.HTMLIFrameElement;){try{var c="string"===typeof b.contentWindow.location.href}catch(d){c=!1}if(c)a=b.contentWindow;else break;b=Xa(a.document)}return b}function Oe(a){var b=a&&a.nodeName&&a.nodeName.toLowerCase();return b&&("input"===b&&("text"===a.type||"search"===a.type||"tel"===a.type||"url"===a.type||"password"===a.type)||"textarea"===b||"true"===a.contentEditable)}\nvar Pe=fa&&"documentMode"in document&&11>=document.documentMode,Qe=null,Re=null,Se=null,Te=!1;\nfunction Ue(a,b,c){var d=c.window===c?c.document:9===c.nodeType?c:c.ownerDocument;Te||null==Qe||Qe!==Xa(d)||(d=Qe,"selectionStart"in d&&Oe(d)?d={start:d.selectionStart,end:d.selectionEnd}:(d=(d.ownerDocument&&d.ownerDocument.defaultView||window).getSelection(),d={anchorNode:d.anchorNode,anchorOffset:d.anchorOffset,focusNode:d.focusNode,focusOffset:d.focusOffset}),Se&&Je(Se,d)||(Se=d,d=oe(Re,"onSelect"),0<d.length&&(b=new td("onSelect","select",null,b,c),a.push({event:b,listeners:d}),b.target=Qe)))}\nPc("cancel cancel click click close close contextmenu contextMenu copy copy cut cut auxclick auxClick dblclick doubleClick dragend dragEnd dragstart dragStart drop drop focusin focus focusout blur input input invalid invalid keydown keyDown keypress keyPress keyup keyUp mousedown mouseDown mouseup mouseUp paste paste pause pause play play pointercancel pointerCancel pointerdown pointerDown pointerup pointerUp ratechange rateChange reset reset seeked seeked submit submit touchcancel touchCancel touchend touchEnd touchstart touchStart volumechange volumeChange".split(" "),\n0);Pc("drag drag dragenter dragEnter dragexit dragExit dragleave dragLeave dragover dragOver mousemove mouseMove mouseout mouseOut mouseover mouseOver pointermove pointerMove pointerout pointerOut pointerover pointerOver scroll scroll toggle toggle touchmove touchMove wheel wheel".split(" "),1);Pc(Oc,2);for(var Ve="change selectionchange textInput compositionstart compositionend compositionupdate".split(" "),We=0;We<Ve.length;We++)Nc.set(Ve[We],0);ea("onMouseEnter",["mouseout","mouseover"]);\nea("onMouseLeave",["mouseout","mouseover"]);ea("onPointerEnter",["pointerout","pointerover"]);ea("onPointerLeave",["pointerout","pointerover"]);da("onChange","change click focusin focusout input keydown keyup selectionchange".split(" "));da("onSelect","focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" "));da("onBeforeInput",["compositionend","keypress","textInput","paste"]);da("onCompositionEnd","compositionend focusout keydown keypress keyup mousedown".split(" "));\nda("onCompositionStart","compositionstart focusout keydown keypress keyup mousedown".split(" "));da("onCompositionUpdate","compositionupdate focusout keydown keypress keyup mousedown".split(" "));var Xe="abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),Ye=new Set("cancel close invalid load scroll toggle".split(" ").concat(Xe));\nfunction Ze(a,b,c){var d=a.type||"unknown-event";a.currentTarget=c;Yb(d,b,void 0,a);a.currentTarget=null}\nfunction se(a,b){b=0!==(b&4);for(var c=0;c<a.length;c++){var d=a[c],e=d.event;d=d.listeners;a:{var f=void 0;if(b)for(var g=d.length-1;0<=g;g--){var h=d[g],k=h.instance,l=h.currentTarget;h=h.listener;if(k!==f&&e.isPropagationStopped())break a;Ze(e,h,l);f=k}else for(g=0;g<d.length;g++){h=d[g];k=h.instance;l=h.currentTarget;h=h.listener;if(k!==f&&e.isPropagationStopped())break a;Ze(e,h,l);f=k}}}if(Ub)throw a=Vb,Ub=!1,Vb=null,a;}\nfunction G(a,b){var c=$e(b),d=a+"__bubble";c.has(d)||(af(b,a,2,!1),c.add(d))}var bf="_reactListening"+Math.random().toString(36).slice(2);function cf(a){a[bf]||(a[bf]=!0,ba.forEach(function(b){Ye.has(b)||df(b,!1,a,null);df(b,!0,a,null)}))}\nfunction df(a,b,c,d){var e=4<arguments.length&&void 0!==arguments[4]?arguments[4]:0,f=c;"selectionchange"===a&&9!==c.nodeType&&(f=c.ownerDocument);if(null!==d&&!b&&Ye.has(a)){if("scroll"!==a)return;e|=2;f=d}var g=$e(f),h=a+"__"+(b?"capture":"bubble");g.has(h)||(b&&(e|=4),af(f,a,e,b),g.add(h))}\nfunction af(a,b,c,d){var e=Nc.get(b);switch(void 0===e?2:e){case 0:e=gd;break;case 1:e=id;break;default:e=hd}c=e.bind(null,b,c,a);e=void 0;!Pb||"touchstart"!==b&&"touchmove"!==b&&"wheel"!==b||(e=!0);d?void 0!==e?a.addEventListener(b,c,{capture:!0,passive:e}):a.addEventListener(b,c,!0):void 0!==e?a.addEventListener(b,c,{passive:e}):a.addEventListener(b,c,!1)}\nfunction jd(a,b,c,d,e){var f=d;if(0===(b&1)&&0===(b&2)&&null!==d)a:for(;;){if(null===d)return;var g=d.tag;if(3===g||4===g){var h=d.stateNode.containerInfo;if(h===e||8===h.nodeType&&h.parentNode===e)break;if(4===g)for(g=d.return;null!==g;){var k=g.tag;if(3===k||4===k)if(k=g.stateNode.containerInfo,k===e||8===k.nodeType&&k.parentNode===e)return;g=g.return}for(;null!==h;){g=wc(h);if(null===g)return;k=g.tag;if(5===k||6===k){d=f=g;continue a}h=h.parentNode}}d=d.return}Nb(function(){var d=f,e=xb(c),g=[];\na:{var h=Mc.get(a);if(void 0!==h){var k=td,x=a;switch(a){case "keypress":if(0===od(c))break a;case "keydown":case "keyup":k=Rd;break;case "focusin":x="focus";k=Fd;break;case "focusout":x="blur";k=Fd;break;case "beforeblur":case "afterblur":k=Fd;break;case "click":if(2===c.button)break a;case "auxclick":case "dblclick":case "mousedown":case "mousemove":case "mouseup":case "mouseout":case "mouseover":case "contextmenu":k=Bd;break;case "drag":case "dragend":case "dragenter":case "dragexit":case "dragleave":case "dragover":case "dragstart":case "drop":k=\nDd;break;case "touchcancel":case "touchend":case "touchmove":case "touchstart":k=Vd;break;case Ic:case Jc:case Kc:k=Hd;break;case Lc:k=Xd;break;case "scroll":k=vd;break;case "wheel":k=Zd;break;case "copy":case "cut":case "paste":k=Jd;break;case "gotpointercapture":case "lostpointercapture":case "pointercancel":case "pointerdown":case "pointermove":case "pointerout":case "pointerover":case "pointerup":k=Td}var w=0!==(b&4),z=!w&&"scroll"===a,u=w?null!==h?h+"Capture":null:h;w=[];for(var t=d,q;null!==\nt;){q=t;var v=q.stateNode;5===q.tag&&null!==v&&(q=v,null!==u&&(v=Ob(t,u),null!=v&&w.push(ef(t,v,q))));if(z)break;t=t.return}0<w.length&&(h=new k(h,x,null,c,e),g.push({event:h,listeners:w}))}}if(0===(b&7)){a:{h="mouseover"===a||"pointerover"===a;k="mouseout"===a||"pointerout"===a;if(h&&0===(b&16)&&(x=c.relatedTarget||c.fromElement)&&(wc(x)||x[ff]))break a;if(k||h){h=e.window===e?e:(h=e.ownerDocument)?h.defaultView||h.parentWindow:window;if(k){if(x=c.relatedTarget||c.toElement,k=d,x=x?wc(x):null,null!==\nx&&(z=Zb(x),x!==z||5!==x.tag&&6!==x.tag))x=null}else k=null,x=d;if(k!==x){w=Bd;v="onMouseLeave";u="onMouseEnter";t="mouse";if("pointerout"===a||"pointerover"===a)w=Td,v="onPointerLeave",u="onPointerEnter",t="pointer";z=null==k?h:ue(k);q=null==x?h:ue(x);h=new w(v,t+"leave",k,c,e);h.target=z;h.relatedTarget=q;v=null;wc(e)===d&&(w=new w(u,t+"enter",x,c,e),w.target=q,w.relatedTarget=z,v=w);z=v;if(k&&x)b:{w=k;u=x;t=0;for(q=w;q;q=gf(q))t++;q=0;for(v=u;v;v=gf(v))q++;for(;0<t-q;)w=gf(w),t--;for(;0<q-t;)u=\ngf(u),q--;for(;t--;){if(w===u||null!==u&&w===u.alternate)break b;w=gf(w);u=gf(u)}w=null}else w=null;null!==k&&hf(g,h,k,w,!1);null!==x&&null!==z&&hf(g,z,x,w,!0)}}}a:{h=d?ue(d):window;k=h.nodeName&&h.nodeName.toLowerCase();if("select"===k||"input"===k&&"file"===h.type)var J=ve;else if(me(h))if(we)J=Fe;else{J=De;var K=Ce}else(k=h.nodeName)&&"input"===k.toLowerCase()&&("checkbox"===h.type||"radio"===h.type)&&(J=Ee);if(J&&(J=J(a,d))){ne(g,J,c,e);break a}K&&K(a,h,d);"focusout"===a&&(K=h._wrapperState)&&\nK.controlled&&"number"===h.type&&bb(h,"number",h.value)}K=d?ue(d):window;switch(a){case "focusin":if(me(K)||"true"===K.contentEditable)Qe=K,Re=d,Se=null;break;case "focusout":Se=Re=Qe=null;break;case "mousedown":Te=!0;break;case "contextmenu":case "mouseup":case "dragend":Te=!1;Ue(g,c,e);break;case "selectionchange":if(Pe)break;case "keydown":case "keyup":Ue(g,c,e)}var Q;if(ae)b:{switch(a){case "compositionstart":var L="onCompositionStart";break b;case "compositionend":L="onCompositionEnd";break b;\ncase "compositionupdate":L="onCompositionUpdate";break b}L=void 0}else ie?ge(a,c)&&(L="onCompositionEnd"):"keydown"===a&&229===c.keyCode&&(L="onCompositionStart");L&&(de&&"ko"!==c.locale&&(ie||"onCompositionStart"!==L?"onCompositionEnd"===L&&ie&&(Q=nd()):(kd=e,ld="value"in kd?kd.value:kd.textContent,ie=!0)),K=oe(d,L),0<K.length&&(L=new Ld(L,a,null,c,e),g.push({event:L,listeners:K}),Q?L.data=Q:(Q=he(c),null!==Q&&(L.data=Q))));if(Q=ce?je(a,c):ke(a,c))d=oe(d,"onBeforeInput"),0<d.length&&(e=new Ld("onBeforeInput",\n"beforeinput",null,c,e),g.push({event:e,listeners:d}),e.data=Q)}se(g,b)})}function ef(a,b,c){return{instance:a,listener:b,currentTarget:c}}function oe(a,b){for(var c=b+"Capture",d=[];null!==a;){var e=a,f=e.stateNode;5===e.tag&&null!==f&&(e=f,f=Ob(a,c),null!=f&&d.unshift(ef(a,f,e)),f=Ob(a,b),null!=f&&d.push(ef(a,f,e)));a=a.return}return d}function gf(a){if(null===a)return null;do a=a.return;while(a&&5!==a.tag);return a?a:null}\nfunction hf(a,b,c,d,e){for(var f=b._reactName,g=[];null!==c&&c!==d;){var h=c,k=h.alternate,l=h.stateNode;if(null!==k&&k===d)break;5===h.tag&&null!==l&&(h=l,e?(k=Ob(c,f),null!=k&&g.unshift(ef(c,k,h))):e||(k=Ob(c,f),null!=k&&g.push(ef(c,k,h))));c=c.return}0!==g.length&&a.push({event:b,listeners:g})}function jf(){}var kf=null,lf=null;function mf(a,b){switch(a){case "button":case "input":case "select":case "textarea":return!!b.autoFocus}return!1}\nfunction nf(a,b){return"textarea"===a||"option"===a||"noscript"===a||"string"===typeof b.children||"number"===typeof b.children||"object"===typeof b.dangerouslySetInnerHTML&&null!==b.dangerouslySetInnerHTML&&null!=b.dangerouslySetInnerHTML.__html}var of="function"===typeof setTimeout?setTimeout:void 0,pf="function"===typeof clearTimeout?clearTimeout:void 0;function qf(a){1===a.nodeType?a.textContent="":9===a.nodeType&&(a=a.body,null!=a&&(a.textContent=""))}\nfunction rf(a){for(;null!=a;a=a.nextSibling){var b=a.nodeType;if(1===b||3===b)break}return a}function sf(a){a=a.previousSibling;for(var b=0;a;){if(8===a.nodeType){var c=a.data;if("$"===c||"$!"===c||"$?"===c){if(0===b)return a;b--}else"/$"===c&&b++}a=a.previousSibling}return null}var tf=0;function uf(a){return{$$typeof:Ga,toString:a,valueOf:a}}var vf=Math.random().toString(36).slice(2),wf="__reactFiber$"+vf,xf="__reactProps$"+vf,ff="__reactContainer$"+vf,yf="__reactEvents$"+vf;\nfunction wc(a){var b=a[wf];if(b)return b;for(var c=a.parentNode;c;){if(b=c[ff]||c[wf]){c=b.alternate;if(null!==b.child||null!==c&&null!==c.child)for(a=sf(a);null!==a;){if(c=a[wf])return c;a=sf(a)}return b}a=c;c=a.parentNode}return null}function Cb(a){a=a[wf]||a[ff];return!a||5!==a.tag&&6!==a.tag&&13!==a.tag&&3!==a.tag?null:a}function ue(a){if(5===a.tag||6===a.tag)return a.stateNode;throw Error(y(33));}function Db(a){return a[xf]||null}\nfunction $e(a){var b=a[yf];void 0===b&&(b=a[yf]=new Set);return b}var zf=[],Af=-1;function Bf(a){return{current:a}}function H(a){0>Af||(a.current=zf[Af],zf[Af]=null,Af--)}function I(a,b){Af++;zf[Af]=a.current;a.current=b}var Cf={},M=Bf(Cf),N=Bf(!1),Df=Cf;\nfunction Ef(a,b){var c=a.type.contextTypes;if(!c)return Cf;var d=a.stateNode;if(d&&d.__reactInternalMemoizedUnmaskedChildContext===b)return d.__reactInternalMemoizedMaskedChildContext;var e={},f;for(f in c)e[f]=b[f];d&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=b,a.__reactInternalMemoizedMaskedChildContext=e);return e}function Ff(a){a=a.childContextTypes;return null!==a&&void 0!==a}function Gf(){H(N);H(M)}function Hf(a,b,c){if(M.current!==Cf)throw Error(y(168));I(M,b);I(N,c)}\nfunction If(a,b,c){var d=a.stateNode;a=b.childContextTypes;if("function"!==typeof d.getChildContext)return c;d=d.getChildContext();for(var e in d)if(!(e in a))throw Error(y(108,Ra(b)||"Unknown",e));return m({},c,d)}function Jf(a){a=(a=a.stateNode)&&a.__reactInternalMemoizedMergedChildContext||Cf;Df=M.current;I(M,a);I(N,N.current);return!0}function Kf(a,b,c){var d=a.stateNode;if(!d)throw Error(y(169));c?(a=If(a,b,Df),d.__reactInternalMemoizedMergedChildContext=a,H(N),H(M),I(M,a)):H(N);I(N,c)}\nvar Lf=null,Mf=null,Nf=r.unstable_runWithPriority,Of=r.unstable_scheduleCallback,Pf=r.unstable_cancelCallback,Qf=r.unstable_shouldYield,Rf=r.unstable_requestPaint,Sf=r.unstable_now,Tf=r.unstable_getCurrentPriorityLevel,Uf=r.unstable_ImmediatePriority,Vf=r.unstable_UserBlockingPriority,Wf=r.unstable_NormalPriority,Xf=r.unstable_LowPriority,Yf=r.unstable_IdlePriority,Zf={},$f=void 0!==Rf?Rf:function(){},ag=null,bg=null,cg=!1,dg=Sf(),O=1E4>dg?Sf:function(){return Sf()-dg};\nfunction eg(){switch(Tf()){case Uf:return 99;case Vf:return 98;case Wf:return 97;case Xf:return 96;case Yf:return 95;default:throw Error(y(332));}}function fg(a){switch(a){case 99:return Uf;case 98:return Vf;case 97:return Wf;case 96:return Xf;case 95:return Yf;default:throw Error(y(332));}}function gg(a,b){a=fg(a);return Nf(a,b)}function hg(a,b,c){a=fg(a);return Of(a,b,c)}function ig(){if(null!==bg){var a=bg;bg=null;Pf(a)}jg()}\nfunction jg(){if(!cg&&null!==ag){cg=!0;var a=0;try{var b=ag;gg(99,function(){for(;a<b.length;a++){var c=b[a];do c=c(!0);while(null!==c)}});ag=null}catch(c){throw null!==ag&&(ag=ag.slice(a+1)),Of(Uf,ig),c;}finally{cg=!1}}}var kg=ra.ReactCurrentBatchConfig;function lg(a,b){if(a&&a.defaultProps){b=m({},b);a=a.defaultProps;for(var c in a)void 0===b[c]&&(b[c]=a[c]);return b}return b}var mg=Bf(null),ng=null,og=null,pg=null;function qg(){pg=og=ng=null}\nfunction rg(a){var b=mg.current;H(mg);a.type._context._currentValue=b}function sg(a,b){for(;null!==a;){var c=a.alternate;if((a.childLanes&b)===b)if(null===c||(c.childLanes&b)===b)break;else c.childLanes|=b;else a.childLanes|=b,null!==c&&(c.childLanes|=b);a=a.return}}function tg(a,b){ng=a;pg=og=null;a=a.dependencies;null!==a&&null!==a.firstContext&&(0!==(a.lanes&b)&&(ug=!0),a.firstContext=null)}\nfunction vg(a,b){if(pg!==a&&!1!==b&&0!==b){if("number"!==typeof b||1073741823===b)pg=a,b=1073741823;b={context:a,observedBits:b,next:null};if(null===og){if(null===ng)throw Error(y(308));og=b;ng.dependencies={lanes:0,firstContext:b,responders:null}}else og=og.next=b}return a._currentValue}var wg=!1;function xg(a){a.updateQueue={baseState:a.memoizedState,firstBaseUpdate:null,lastBaseUpdate:null,shared:{pending:null},effects:null}}\nfunction yg(a,b){a=a.updateQueue;b.updateQueue===a&&(b.updateQueue={baseState:a.baseState,firstBaseUpdate:a.firstBaseUpdate,lastBaseUpdate:a.lastBaseUpdate,shared:a.shared,effects:a.effects})}function zg(a,b){return{eventTime:a,lane:b,tag:0,payload:null,callback:null,next:null}}function Ag(a,b){a=a.updateQueue;if(null!==a){a=a.shared;var c=a.pending;null===c?b.next=b:(b.next=c.next,c.next=b);a.pending=b}}\nfunction Bg(a,b){var c=a.updateQueue,d=a.alternate;if(null!==d&&(d=d.updateQueue,c===d)){var e=null,f=null;c=c.firstBaseUpdate;if(null!==c){do{var g={eventTime:c.eventTime,lane:c.lane,tag:c.tag,payload:c.payload,callback:c.callback,next:null};null===f?e=f=g:f=f.next=g;c=c.next}while(null!==c);null===f?e=f=b:f=f.next=b}else e=f=b;c={baseState:d.baseState,firstBaseUpdate:e,lastBaseUpdate:f,shared:d.shared,effects:d.effects};a.updateQueue=c;return}a=c.lastBaseUpdate;null===a?c.firstBaseUpdate=b:a.next=\nb;c.lastBaseUpdate=b}\nfunction Cg(a,b,c,d){var e=a.updateQueue;wg=!1;var f=e.firstBaseUpdate,g=e.lastBaseUpdate,h=e.shared.pending;if(null!==h){e.shared.pending=null;var k=h,l=k.next;k.next=null;null===g?f=l:g.next=l;g=k;var n=a.alternate;if(null!==n){n=n.updateQueue;var A=n.lastBaseUpdate;A!==g&&(null===A?n.firstBaseUpdate=l:A.next=l,n.lastBaseUpdate=k)}}if(null!==f){A=e.baseState;g=0;n=l=k=null;do{h=f.lane;var p=f.eventTime;if((d&h)===h){null!==n&&(n=n.next={eventTime:p,lane:0,tag:f.tag,payload:f.payload,callback:f.callback,\nnext:null});a:{var C=a,x=f;h=b;p=c;switch(x.tag){case 1:C=x.payload;if("function"===typeof C){A=C.call(p,A,h);break a}A=C;break a;case 3:C.flags=C.flags&-4097|64;case 0:C=x.payload;h="function"===typeof C?C.call(p,A,h):C;if(null===h||void 0===h)break a;A=m({},A,h);break a;case 2:wg=!0}}null!==f.callback&&(a.flags|=32,h=e.effects,null===h?e.effects=[f]:h.push(f))}else p={eventTime:p,lane:h,tag:f.tag,payload:f.payload,callback:f.callback,next:null},null===n?(l=n=p,k=A):n=n.next=p,g|=h;f=f.next;if(null===\nf)if(h=e.shared.pending,null===h)break;else f=h.next,h.next=null,e.lastBaseUpdate=h,e.shared.pending=null}while(1);null===n&&(k=A);e.baseState=k;e.firstBaseUpdate=l;e.lastBaseUpdate=n;Dg|=g;a.lanes=g;a.memoizedState=A}}function Eg(a,b,c){a=b.effects;b.effects=null;if(null!==a)for(b=0;b<a.length;b++){var d=a[b],e=d.callback;if(null!==e){d.callback=null;d=c;if("function"!==typeof e)throw Error(y(191,e));e.call(d)}}}var Fg=(new aa.Component).refs;\nfunction Gg(a,b,c,d){b=a.memoizedState;c=c(d,b);c=null===c||void 0===c?b:m({},b,c);a.memoizedState=c;0===a.lanes&&(a.updateQueue.baseState=c)}\nvar Kg={isMounted:function(a){return(a=a._reactInternals)?Zb(a)===a:!1},enqueueSetState:function(a,b,c){a=a._reactInternals;var d=Hg(),e=Ig(a),f=zg(d,e);f.payload=b;void 0!==c&&null!==c&&(f.callback=c);Ag(a,f);Jg(a,e,d)},enqueueReplaceState:function(a,b,c){a=a._reactInternals;var d=Hg(),e=Ig(a),f=zg(d,e);f.tag=1;f.payload=b;void 0!==c&&null!==c&&(f.callback=c);Ag(a,f);Jg(a,e,d)},enqueueForceUpdate:function(a,b){a=a._reactInternals;var c=Hg(),d=Ig(a),e=zg(c,d);e.tag=2;void 0!==b&&null!==b&&(e.callback=\nb);Ag(a,e);Jg(a,d,c)}};function Lg(a,b,c,d,e,f,g){a=a.stateNode;return"function"===typeof a.shouldComponentUpdate?a.shouldComponentUpdate(d,f,g):b.prototype&&b.prototype.isPureReactComponent?!Je(c,d)||!Je(e,f):!0}\nfunction Mg(a,b,c){var d=!1,e=Cf;var f=b.contextType;"object"===typeof f&&null!==f?f=vg(f):(e=Ff(b)?Df:M.current,d=b.contextTypes,f=(d=null!==d&&void 0!==d)?Ef(a,e):Cf);b=new b(c,f);a.memoizedState=null!==b.state&&void 0!==b.state?b.state:null;b.updater=Kg;a.stateNode=b;b._reactInternals=a;d&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=e,a.__reactInternalMemoizedMaskedChildContext=f);return b}\nfunction Ng(a,b,c,d){a=b.state;"function"===typeof b.componentWillReceiveProps&&b.componentWillReceiveProps(c,d);"function"===typeof b.UNSAFE_componentWillReceiveProps&&b.UNSAFE_componentWillReceiveProps(c,d);b.state!==a&&Kg.enqueueReplaceState(b,b.state,null)}\nfunction Og(a,b,c,d){var e=a.stateNode;e.props=c;e.state=a.memoizedState;e.refs=Fg;xg(a);var f=b.contextType;"object"===typeof f&&null!==f?e.context=vg(f):(f=Ff(b)?Df:M.current,e.context=Ef(a,f));Cg(a,c,e,d);e.state=a.memoizedState;f=b.getDerivedStateFromProps;"function"===typeof f&&(Gg(a,b,f,c),e.state=a.memoizedState);"function"===typeof b.getDerivedStateFromProps||"function"===typeof e.getSnapshotBeforeUpdate||"function"!==typeof e.UNSAFE_componentWillMount&&"function"!==typeof e.componentWillMount||\n(b=e.state,"function"===typeof e.componentWillMount&&e.componentWillMount(),"function"===typeof e.UNSAFE_componentWillMount&&e.UNSAFE_componentWillMount(),b!==e.state&&Kg.enqueueReplaceState(e,e.state,null),Cg(a,c,e,d),e.state=a.memoizedState);"function"===typeof e.componentDidMount&&(a.flags|=4)}var Pg=Array.isArray;\nfunction Qg(a,b,c){a=c.ref;if(null!==a&&"function"!==typeof a&&"object"!==typeof a){if(c._owner){c=c._owner;if(c){if(1!==c.tag)throw Error(y(309));var d=c.stateNode}if(!d)throw Error(y(147,a));var e=""+a;if(null!==b&&null!==b.ref&&"function"===typeof b.ref&&b.ref._stringRef===e)return b.ref;b=function(a){var b=d.refs;b===Fg&&(b=d.refs={});null===a?delete b[e]:b[e]=a};b._stringRef=e;return b}if("string"!==typeof a)throw Error(y(284));if(!c._owner)throw Error(y(290,a));}return a}\nfunction Rg(a,b){if("textarea"!==a.type)throw Error(y(31,"[object Object]"===Object.prototype.toString.call(b)?"object with keys {"+Object.keys(b).join(", ")+"}":b));}\nfunction Sg(a){function b(b,c){if(a){var d=b.lastEffect;null!==d?(d.nextEffect=c,b.lastEffect=c):b.firstEffect=b.lastEffect=c;c.nextEffect=null;c.flags=8}}function c(c,d){if(!a)return null;for(;null!==d;)b(c,d),d=d.sibling;return null}function d(a,b){for(a=new Map;null!==b;)null!==b.key?a.set(b.key,b):a.set(b.index,b),b=b.sibling;return a}function e(a,b){a=Tg(a,b);a.index=0;a.sibling=null;return a}function f(b,c,d){b.index=d;if(!a)return c;d=b.alternate;if(null!==d)return d=d.index,d<c?(b.flags=2,\nc):d;b.flags=2;return c}function g(b){a&&null===b.alternate&&(b.flags=2);return b}function h(a,b,c,d){if(null===b||6!==b.tag)return b=Ug(c,a.mode,d),b.return=a,b;b=e(b,c);b.return=a;return b}function k(a,b,c,d){if(null!==b&&b.elementType===c.type)return d=e(b,c.props),d.ref=Qg(a,b,c),d.return=a,d;d=Vg(c.type,c.key,c.props,null,a.mode,d);d.ref=Qg(a,b,c);d.return=a;return d}function l(a,b,c,d){if(null===b||4!==b.tag||b.stateNode.containerInfo!==c.containerInfo||b.stateNode.implementation!==c.implementation)return b=\nWg(c,a.mode,d),b.return=a,b;b=e(b,c.children||[]);b.return=a;return b}function n(a,b,c,d,f){if(null===b||7!==b.tag)return b=Xg(c,a.mode,d,f),b.return=a,b;b=e(b,c);b.return=a;return b}function A(a,b,c){if("string"===typeof b||"number"===typeof b)return b=Ug(""+b,a.mode,c),b.return=a,b;if("object"===typeof b&&null!==b){switch(b.$$typeof){case sa:return c=Vg(b.type,b.key,b.props,null,a.mode,c),c.ref=Qg(a,null,b),c.return=a,c;case ta:return b=Wg(b,a.mode,c),b.return=a,b}if(Pg(b)||La(b))return b=Xg(b,\na.mode,c,null),b.return=a,b;Rg(a,b)}return null}function p(a,b,c,d){var e=null!==b?b.key:null;if("string"===typeof c||"number"===typeof c)return null!==e?null:h(a,b,""+c,d);if("object"===typeof c&&null!==c){switch(c.$$typeof){case sa:return c.key===e?c.type===ua?n(a,b,c.props.children,d,e):k(a,b,c,d):null;case ta:return c.key===e?l(a,b,c,d):null}if(Pg(c)||La(c))return null!==e?null:n(a,b,c,d,null);Rg(a,c)}return null}function C(a,b,c,d,e){if("string"===typeof d||"number"===typeof d)return a=a.get(c)||\nnull,h(b,a,""+d,e);if("object"===typeof d&&null!==d){switch(d.$$typeof){case sa:return a=a.get(null===d.key?c:d.key)||null,d.type===ua?n(b,a,d.props.children,e,d.key):k(b,a,d,e);case ta:return a=a.get(null===d.key?c:d.key)||null,l(b,a,d,e)}if(Pg(d)||La(d))return a=a.get(c)||null,n(b,a,d,e,null);Rg(b,d)}return null}function x(e,g,h,k){for(var l=null,t=null,u=g,z=g=0,q=null;null!==u&&z<h.length;z++){u.index>z?(q=u,u=null):q=u.sibling;var n=p(e,u,h[z],k);if(null===n){null===u&&(u=q);break}a&&u&&null===\nn.alternate&&b(e,u);g=f(n,g,z);null===t?l=n:t.sibling=n;t=n;u=q}if(z===h.length)return c(e,u),l;if(null===u){for(;z<h.length;z++)u=A(e,h[z],k),null!==u&&(g=f(u,g,z),null===t?l=u:t.sibling=u,t=u);return l}for(u=d(e,u);z<h.length;z++)q=C(u,e,z,h[z],k),null!==q&&(a&&null!==q.alternate&&u.delete(null===q.key?z:q.key),g=f(q,g,z),null===t?l=q:t.sibling=q,t=q);a&&u.forEach(function(a){return b(e,a)});return l}function w(e,g,h,k){var l=La(h);if("function"!==typeof l)throw Error(y(150));h=l.call(h);if(null==\nh)throw Error(y(151));for(var t=l=null,u=g,z=g=0,q=null,n=h.next();null!==u&&!n.done;z++,n=h.next()){u.index>z?(q=u,u=null):q=u.sibling;var w=p(e,u,n.value,k);if(null===w){null===u&&(u=q);break}a&&u&&null===w.alternate&&b(e,u);g=f(w,g,z);null===t?l=w:t.sibling=w;t=w;u=q}if(n.done)return c(e,u),l;if(null===u){for(;!n.done;z++,n=h.next())n=A(e,n.value,k),null!==n&&(g=f(n,g,z),null===t?l=n:t.sibling=n,t=n);return l}for(u=d(e,u);!n.done;z++,n=h.next())n=C(u,e,z,n.value,k),null!==n&&(a&&null!==n.alternate&&\nu.delete(null===n.key?z:n.key),g=f(n,g,z),null===t?l=n:t.sibling=n,t=n);a&&u.forEach(function(a){return b(e,a)});return l}return function(a,d,f,h){var k="object"===typeof f&&null!==f&&f.type===ua&&null===f.key;k&&(f=f.props.children);var l="object"===typeof f&&null!==f;if(l)switch(f.$$typeof){case sa:a:{l=f.key;for(k=d;null!==k;){if(k.key===l){switch(k.tag){case 7:if(f.type===ua){c(a,k.sibling);d=e(k,f.props.children);d.return=a;a=d;break a}break;default:if(k.elementType===f.type){c(a,k.sibling);\nd=e(k,f.props);d.ref=Qg(a,k,f);d.return=a;a=d;break a}}c(a,k);break}else b(a,k);k=k.sibling}f.type===ua?(d=Xg(f.props.children,a.mode,h,f.key),d.return=a,a=d):(h=Vg(f.type,f.key,f.props,null,a.mode,h),h.ref=Qg(a,d,f),h.return=a,a=h)}return g(a);case ta:a:{for(k=f.key;null!==d;){if(d.key===k)if(4===d.tag&&d.stateNode.containerInfo===f.containerInfo&&d.stateNode.implementation===f.implementation){c(a,d.sibling);d=e(d,f.children||[]);d.return=a;a=d;break a}else{c(a,d);break}else b(a,d);d=d.sibling}d=\nWg(f,a.mode,h);d.return=a;a=d}return g(a)}if("string"===typeof f||"number"===typeof f)return f=""+f,null!==d&&6===d.tag?(c(a,d.sibling),d=e(d,f),d.return=a,a=d):(c(a,d),d=Ug(f,a.mode,h),d.return=a,a=d),g(a);if(Pg(f))return x(a,d,f,h);if(La(f))return w(a,d,f,h);l&&Rg(a,f);if("undefined"===typeof f&&!k)switch(a.tag){case 1:case 22:case 0:case 11:case 15:throw Error(y(152,Ra(a.type)||"Component"));}return c(a,d)}}var Yg=Sg(!0),Zg=Sg(!1),$g={},ah=Bf($g),bh=Bf($g),ch=Bf($g);\nfunction dh(a){if(a===$g)throw Error(y(174));return a}function eh(a,b){I(ch,b);I(bh,a);I(ah,$g);a=b.nodeType;switch(a){case 9:case 11:b=(b=b.documentElement)?b.namespaceURI:mb(null,"");break;default:a=8===a?b.parentNode:b,b=a.namespaceURI||null,a=a.tagName,b=mb(b,a)}H(ah);I(ah,b)}function fh(){H(ah);H(bh);H(ch)}function gh(a){dh(ch.current);var b=dh(ah.current);var c=mb(b,a.type);b!==c&&(I(bh,a),I(ah,c))}function hh(a){bh.current===a&&(H(ah),H(bh))}var P=Bf(0);\nfunction ih(a){for(var b=a;null!==b;){if(13===b.tag){var c=b.memoizedState;if(null!==c&&(c=c.dehydrated,null===c||"$?"===c.data||"$!"===c.data))return b}else if(19===b.tag&&void 0!==b.memoizedProps.revealOrder){if(0!==(b.flags&64))return b}else if(null!==b.child){b.child.return=b;b=b.child;continue}if(b===a)break;for(;null===b.sibling;){if(null===b.return||b.return===a)return null;b=b.return}b.sibling.return=b.return;b=b.sibling}return null}var jh=null,kh=null,lh=!1;\nfunction mh(a,b){var c=nh(5,null,null,0);c.elementType="DELETED";c.type="DELETED";c.stateNode=b;c.return=a;c.flags=8;null!==a.lastEffect?(a.lastEffect.nextEffect=c,a.lastEffect=c):a.firstEffect=a.lastEffect=c}function oh(a,b){switch(a.tag){case 5:var c=a.type;b=1!==b.nodeType||c.toLowerCase()!==b.nodeName.toLowerCase()?null:b;return null!==b?(a.stateNode=b,!0):!1;case 6:return b=""===a.pendingProps||3!==b.nodeType?null:b,null!==b?(a.stateNode=b,!0):!1;case 13:return!1;default:return!1}}\nfunction ph(a){if(lh){var b=kh;if(b){var c=b;if(!oh(a,b)){b=rf(c.nextSibling);if(!b||!oh(a,b)){a.flags=a.flags&-1025|2;lh=!1;jh=a;return}mh(jh,c)}jh=a;kh=rf(b.firstChild)}else a.flags=a.flags&-1025|2,lh=!1,jh=a}}function qh(a){for(a=a.return;null!==a&&5!==a.tag&&3!==a.tag&&13!==a.tag;)a=a.return;jh=a}\nfunction rh(a){if(a!==jh)return!1;if(!lh)return qh(a),lh=!0,!1;var b=a.type;if(5!==a.tag||"head"!==b&&"body"!==b&&!nf(b,a.memoizedProps))for(b=kh;b;)mh(a,b),b=rf(b.nextSibling);qh(a);if(13===a.tag){a=a.memoizedState;a=null!==a?a.dehydrated:null;if(!a)throw Error(y(317));a:{a=a.nextSibling;for(b=0;a;){if(8===a.nodeType){var c=a.data;if("/$"===c){if(0===b){kh=rf(a.nextSibling);break a}b--}else"$"!==c&&"$!"!==c&&"$?"!==c||b++}a=a.nextSibling}kh=null}}else kh=jh?rf(a.stateNode.nextSibling):null;return!0}\nfunction sh(){kh=jh=null;lh=!1}var th=[];function uh(){for(var a=0;a<th.length;a++)th[a]._workInProgressVersionPrimary=null;th.length=0}var vh=ra.ReactCurrentDispatcher,wh=ra.ReactCurrentBatchConfig,xh=0,R=null,S=null,T=null,yh=!1,zh=!1;function Ah(){throw Error(y(321));}function Bh(a,b){if(null===b)return!1;for(var c=0;c<b.length&&c<a.length;c++)if(!He(a[c],b[c]))return!1;return!0}\nfunction Ch(a,b,c,d,e,f){xh=f;R=b;b.memoizedState=null;b.updateQueue=null;b.lanes=0;vh.current=null===a||null===a.memoizedState?Dh:Eh;a=c(d,e);if(zh){f=0;do{zh=!1;if(!(25>f))throw Error(y(301));f+=1;T=S=null;b.updateQueue=null;vh.current=Fh;a=c(d,e)}while(zh)}vh.current=Gh;b=null!==S&&null!==S.next;xh=0;T=S=R=null;yh=!1;if(b)throw Error(y(300));return a}function Hh(){var a={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};null===T?R.memoizedState=T=a:T=T.next=a;return T}\nfunction Ih(){if(null===S){var a=R.alternate;a=null!==a?a.memoizedState:null}else a=S.next;var b=null===T?R.memoizedState:T.next;if(null!==b)T=b,S=a;else{if(null===a)throw Error(y(310));S=a;a={memoizedState:S.memoizedState,baseState:S.baseState,baseQueue:S.baseQueue,queue:S.queue,next:null};null===T?R.memoizedState=T=a:T=T.next=a}return T}function Jh(a,b){return"function"===typeof b?b(a):b}\nfunction Kh(a){var b=Ih(),c=b.queue;if(null===c)throw Error(y(311));c.lastRenderedReducer=a;var d=S,e=d.baseQueue,f=c.pending;if(null!==f){if(null!==e){var g=e.next;e.next=f.next;f.next=g}d.baseQueue=e=f;c.pending=null}if(null!==e){e=e.next;d=d.baseState;var h=g=f=null,k=e;do{var l=k.lane;if((xh&l)===l)null!==h&&(h=h.next={lane:0,action:k.action,eagerReducer:k.eagerReducer,eagerState:k.eagerState,next:null}),d=k.eagerReducer===a?k.eagerState:a(d,k.action);else{var n={lane:l,action:k.action,eagerReducer:k.eagerReducer,\neagerState:k.eagerState,next:null};null===h?(g=h=n,f=d):h=h.next=n;R.lanes|=l;Dg|=l}k=k.next}while(null!==k&&k!==e);null===h?f=d:h.next=g;He(d,b.memoizedState)||(ug=!0);b.memoizedState=d;b.baseState=f;b.baseQueue=h;c.lastRenderedState=d}return[b.memoizedState,c.dispatch]}\nfunction Lh(a){var b=Ih(),c=b.queue;if(null===c)throw Error(y(311));c.lastRenderedReducer=a;var d=c.dispatch,e=c.pending,f=b.memoizedState;if(null!==e){c.pending=null;var g=e=e.next;do f=a(f,g.action),g=g.next;while(g!==e);He(f,b.memoizedState)||(ug=!0);b.memoizedState=f;null===b.baseQueue&&(b.baseState=f);c.lastRenderedState=f}return[f,d]}\nfunction Mh(a,b,c){var d=b._getVersion;d=d(b._source);var e=b._workInProgressVersionPrimary;if(null!==e)a=e===d;else if(a=a.mutableReadLanes,a=(xh&a)===a)b._workInProgressVersionPrimary=d,th.push(b);if(a)return c(b._source);th.push(b);throw Error(y(350));}\nfunction Nh(a,b,c,d){var e=U;if(null===e)throw Error(y(349));var f=b._getVersion,g=f(b._source),h=vh.current,k=h.useState(function(){return Mh(e,b,c)}),l=k[1],n=k[0];k=T;var A=a.memoizedState,p=A.refs,C=p.getSnapshot,x=A.source;A=A.subscribe;var w=R;a.memoizedState={refs:p,source:b,subscribe:d};h.useEffect(function(){p.getSnapshot=c;p.setSnapshot=l;var a=f(b._source);if(!He(g,a)){a=c(b._source);He(n,a)||(l(a),a=Ig(w),e.mutableReadLanes|=a&e.pendingLanes);a=e.mutableReadLanes;e.entangledLanes|=a;for(var d=\ne.entanglements,h=a;0<h;){var k=31-Vc(h),v=1<<k;d[k]|=a;h&=~v}}},[c,b,d]);h.useEffect(function(){return d(b._source,function(){var a=p.getSnapshot,c=p.setSnapshot;try{c(a(b._source));var d=Ig(w);e.mutableReadLanes|=d&e.pendingLanes}catch(q){c(function(){throw q;})}})},[b,d]);He(C,c)&&He(x,b)&&He(A,d)||(a={pending:null,dispatch:null,lastRenderedReducer:Jh,lastRenderedState:n},a.dispatch=l=Oh.bind(null,R,a),k.queue=a,k.baseQueue=null,n=Mh(e,b,c),k.memoizedState=k.baseState=n);return n}\nfunction Ph(a,b,c){var d=Ih();return Nh(d,a,b,c)}function Qh(a){var b=Hh();"function"===typeof a&&(a=a());b.memoizedState=b.baseState=a;a=b.queue={pending:null,dispatch:null,lastRenderedReducer:Jh,lastRenderedState:a};a=a.dispatch=Oh.bind(null,R,a);return[b.memoizedState,a]}\nfunction Rh(a,b,c,d){a={tag:a,create:b,destroy:c,deps:d,next:null};b=R.updateQueue;null===b?(b={lastEffect:null},R.updateQueue=b,b.lastEffect=a.next=a):(c=b.lastEffect,null===c?b.lastEffect=a.next=a:(d=c.next,c.next=a,a.next=d,b.lastEffect=a));return a}function Sh(a){var b=Hh();a={current:a};return b.memoizedState=a}function Th(){return Ih().memoizedState}function Uh(a,b,c,d){var e=Hh();R.flags|=a;e.memoizedState=Rh(1|b,c,void 0,void 0===d?null:d)}\nfunction Vh(a,b,c,d){var e=Ih();d=void 0===d?null:d;var f=void 0;if(null!==S){var g=S.memoizedState;f=g.destroy;if(null!==d&&Bh(d,g.deps)){Rh(b,c,f,d);return}}R.flags|=a;e.memoizedState=Rh(1|b,c,f,d)}function Wh(a,b){return Uh(516,4,a,b)}function Xh(a,b){return Vh(516,4,a,b)}function Yh(a,b){return Vh(4,2,a,b)}function Zh(a,b){if("function"===typeof b)return a=a(),b(a),function(){b(null)};if(null!==b&&void 0!==b)return a=a(),b.current=a,function(){b.current=null}}\nfunction $h(a,b,c){c=null!==c&&void 0!==c?c.concat([a]):null;return Vh(4,2,Zh.bind(null,b,a),c)}function ai(){}function bi(a,b){var c=Ih();b=void 0===b?null:b;var d=c.memoizedState;if(null!==d&&null!==b&&Bh(b,d[1]))return d[0];c.memoizedState=[a,b];return a}function ci(a,b){var c=Ih();b=void 0===b?null:b;var d=c.memoizedState;if(null!==d&&null!==b&&Bh(b,d[1]))return d[0];a=a();c.memoizedState=[a,b];return a}\nfunction di(a,b){var c=eg();gg(98>c?98:c,function(){a(!0)});gg(97<c?97:c,function(){var c=wh.transition;wh.transition=1;try{a(!1),b()}finally{wh.transition=c}})}\nfunction Oh(a,b,c){var d=Hg(),e=Ig(a),f={lane:e,action:c,eagerReducer:null,eagerState:null,next:null},g=b.pending;null===g?f.next=f:(f.next=g.next,g.next=f);b.pending=f;g=a.alternate;if(a===R||null!==g&&g===R)zh=yh=!0;else{if(0===a.lanes&&(null===g||0===g.lanes)&&(g=b.lastRenderedReducer,null!==g))try{var h=b.lastRenderedState,k=g(h,c);f.eagerReducer=g;f.eagerState=k;if(He(k,h))return}catch(l){}finally{}Jg(a,e,d)}}\nvar Gh={readContext:vg,useCallback:Ah,useContext:Ah,useEffect:Ah,useImperativeHandle:Ah,useLayoutEffect:Ah,useMemo:Ah,useReducer:Ah,useRef:Ah,useState:Ah,useDebugValue:Ah,useDeferredValue:Ah,useTransition:Ah,useMutableSource:Ah,useOpaqueIdentifier:Ah,unstable_isNewReconciler:!1},Dh={readContext:vg,useCallback:function(a,b){Hh().memoizedState=[a,void 0===b?null:b];return a},useContext:vg,useEffect:Wh,useImperativeHandle:function(a,b,c){c=null!==c&&void 0!==c?c.concat([a]):null;return Uh(4,2,Zh.bind(null,\nb,a),c)},useLayoutEffect:function(a,b){return Uh(4,2,a,b)},useMemo:function(a,b){var c=Hh();b=void 0===b?null:b;a=a();c.memoizedState=[a,b];return a},useReducer:function(a,b,c){var d=Hh();b=void 0!==c?c(b):b;d.memoizedState=d.baseState=b;a=d.queue={pending:null,dispatch:null,lastRenderedReducer:a,lastRenderedState:b};a=a.dispatch=Oh.bind(null,R,a);return[d.memoizedState,a]},useRef:Sh,useState:Qh,useDebugValue:ai,useDeferredValue:function(a){var b=Qh(a),c=b[0],d=b[1];Wh(function(){var b=wh.transition;\nwh.transition=1;try{d(a)}finally{wh.transition=b}},[a]);return c},useTransition:function(){var a=Qh(!1),b=a[0];a=di.bind(null,a[1]);Sh(a);return[a,b]},useMutableSource:function(a,b,c){var d=Hh();d.memoizedState={refs:{getSnapshot:b,setSnapshot:null},source:a,subscribe:c};return Nh(d,a,b,c)},useOpaqueIdentifier:function(){if(lh){var a=!1,b=uf(function(){a||(a=!0,c("r:"+(tf++).toString(36)));throw Error(y(355));}),c=Qh(b)[1];0===(R.mode&2)&&(R.flags|=516,Rh(5,function(){c("r:"+(tf++).toString(36))},\nvoid 0,null));return b}b="r:"+(tf++).toString(36);Qh(b);return b},unstable_isNewReconciler:!1},Eh={readContext:vg,useCallback:bi,useContext:vg,useEffect:Xh,useImperativeHandle:$h,useLayoutEffect:Yh,useMemo:ci,useReducer:Kh,useRef:Th,useState:function(){return Kh(Jh)},useDebugValue:ai,useDeferredValue:function(a){var b=Kh(Jh),c=b[0],d=b[1];Xh(function(){var b=wh.transition;wh.transition=1;try{d(a)}finally{wh.transition=b}},[a]);return c},useTransition:function(){var a=Kh(Jh)[0];return[Th().current,\na]},useMutableSource:Ph,useOpaqueIdentifier:function(){return Kh(Jh)[0]},unstable_isNewReconciler:!1},Fh={readContext:vg,useCallback:bi,useContext:vg,useEffect:Xh,useImperativeHandle:$h,useLayoutEffect:Yh,useMemo:ci,useReducer:Lh,useRef:Th,useState:function(){return Lh(Jh)},useDebugValue:ai,useDeferredValue:function(a){var b=Lh(Jh),c=b[0],d=b[1];Xh(function(){var b=wh.transition;wh.transition=1;try{d(a)}finally{wh.transition=b}},[a]);return c},useTransition:function(){var a=Lh(Jh)[0];return[Th().current,\na]},useMutableSource:Ph,useOpaqueIdentifier:function(){return Lh(Jh)[0]},unstable_isNewReconciler:!1},ei=ra.ReactCurrentOwner,ug=!1;function fi(a,b,c,d){b.child=null===a?Zg(b,null,c,d):Yg(b,a.child,c,d)}function gi(a,b,c,d,e){c=c.render;var f=b.ref;tg(b,e);d=Ch(a,b,c,d,f,e);if(null!==a&&!ug)return b.updateQueue=a.updateQueue,b.flags&=-517,a.lanes&=~e,hi(a,b,e);b.flags|=1;fi(a,b,d,e);return b.child}\nfunction ii(a,b,c,d,e,f){if(null===a){var g=c.type;if("function"===typeof g&&!ji(g)&&void 0===g.defaultProps&&null===c.compare&&void 0===c.defaultProps)return b.tag=15,b.type=g,ki(a,b,g,d,e,f);a=Vg(c.type,null,d,b,b.mode,f);a.ref=b.ref;a.return=b;return b.child=a}g=a.child;if(0===(e&f)&&(e=g.memoizedProps,c=c.compare,c=null!==c?c:Je,c(e,d)&&a.ref===b.ref))return hi(a,b,f);b.flags|=1;a=Tg(g,d);a.ref=b.ref;a.return=b;return b.child=a}\nfunction ki(a,b,c,d,e,f){if(null!==a&&Je(a.memoizedProps,d)&&a.ref===b.ref)if(ug=!1,0!==(f&e))0!==(a.flags&16384)&&(ug=!0);else return b.lanes=a.lanes,hi(a,b,f);return li(a,b,c,d,f)}\nfunction mi(a,b,c){var d=b.pendingProps,e=d.children,f=null!==a?a.memoizedState:null;if("hidden"===d.mode||"unstable-defer-without-hiding"===d.mode)if(0===(b.mode&4))b.memoizedState={baseLanes:0},ni(b,c);else if(0!==(c&1073741824))b.memoizedState={baseLanes:0},ni(b,null!==f?f.baseLanes:c);else return a=null!==f?f.baseLanes|c:c,b.lanes=b.childLanes=1073741824,b.memoizedState={baseLanes:a},ni(b,a),null;else null!==f?(d=f.baseLanes|c,b.memoizedState=null):d=c,ni(b,d);fi(a,b,e,c);return b.child}\nfunction oi(a,b){var c=b.ref;if(null===a&&null!==c||null!==a&&a.ref!==c)b.flags|=128}function li(a,b,c,d,e){var f=Ff(c)?Df:M.current;f=Ef(b,f);tg(b,e);c=Ch(a,b,c,d,f,e);if(null!==a&&!ug)return b.updateQueue=a.updateQueue,b.flags&=-517,a.lanes&=~e,hi(a,b,e);b.flags|=1;fi(a,b,c,e);return b.child}\nfunction pi(a,b,c,d,e){if(Ff(c)){var f=!0;Jf(b)}else f=!1;tg(b,e);if(null===b.stateNode)null!==a&&(a.alternate=null,b.alternate=null,b.flags|=2),Mg(b,c,d),Og(b,c,d,e),d=!0;else if(null===a){var g=b.stateNode,h=b.memoizedProps;g.props=h;var k=g.context,l=c.contextType;"object"===typeof l&&null!==l?l=vg(l):(l=Ff(c)?Df:M.current,l=Ef(b,l));var n=c.getDerivedStateFromProps,A="function"===typeof n||"function"===typeof g.getSnapshotBeforeUpdate;A||"function"!==typeof g.UNSAFE_componentWillReceiveProps&&\n"function"!==typeof g.componentWillReceiveProps||(h!==d||k!==l)&&Ng(b,g,d,l);wg=!1;var p=b.memoizedState;g.state=p;Cg(b,d,g,e);k=b.memoizedState;h!==d||p!==k||N.current||wg?("function"===typeof n&&(Gg(b,c,n,d),k=b.memoizedState),(h=wg||Lg(b,c,h,d,p,k,l))?(A||"function"!==typeof g.UNSAFE_componentWillMount&&"function"!==typeof g.componentWillMount||("function"===typeof g.componentWillMount&&g.componentWillMount(),"function"===typeof g.UNSAFE_componentWillMount&&g.UNSAFE_componentWillMount()),"function"===\ntypeof g.componentDidMount&&(b.flags|=4)):("function"===typeof g.componentDidMount&&(b.flags|=4),b.memoizedProps=d,b.memoizedState=k),g.props=d,g.state=k,g.context=l,d=h):("function"===typeof g.componentDidMount&&(b.flags|=4),d=!1)}else{g=b.stateNode;yg(a,b);h=b.memoizedProps;l=b.type===b.elementType?h:lg(b.type,h);g.props=l;A=b.pendingProps;p=g.context;k=c.contextType;"object"===typeof k&&null!==k?k=vg(k):(k=Ff(c)?Df:M.current,k=Ef(b,k));var C=c.getDerivedStateFromProps;(n="function"===typeof C||\n"function"===typeof g.getSnapshotBeforeUpdate)||"function"!==typeof g.UNSAFE_componentWillReceiveProps&&"function"!==typeof g.componentWillReceiveProps||(h!==A||p!==k)&&Ng(b,g,d,k);wg=!1;p=b.memoizedState;g.state=p;Cg(b,d,g,e);var x=b.memoizedState;h!==A||p!==x||N.current||wg?("function"===typeof C&&(Gg(b,c,C,d),x=b.memoizedState),(l=wg||Lg(b,c,l,d,p,x,k))?(n||"function"!==typeof g.UNSAFE_componentWillUpdate&&"function"!==typeof g.componentWillUpdate||("function"===typeof g.componentWillUpdate&&g.componentWillUpdate(d,\nx,k),"function"===typeof g.UNSAFE_componentWillUpdate&&g.UNSAFE_componentWillUpdate(d,x,k)),"function"===typeof g.componentDidUpdate&&(b.flags|=4),"function"===typeof g.getSnapshotBeforeUpdate&&(b.flags|=256)):("function"!==typeof g.componentDidUpdate||h===a.memoizedProps&&p===a.memoizedState||(b.flags|=4),"function"!==typeof g.getSnapshotBeforeUpdate||h===a.memoizedProps&&p===a.memoizedState||(b.flags|=256),b.memoizedProps=d,b.memoizedState=x),g.props=d,g.state=x,g.context=k,d=l):("function"!==typeof g.componentDidUpdate||\nh===a.memoizedProps&&p===a.memoizedState||(b.flags|=4),"function"!==typeof g.getSnapshotBeforeUpdate||h===a.memoizedProps&&p===a.memoizedState||(b.flags|=256),d=!1)}return qi(a,b,c,d,f,e)}\nfunction qi(a,b,c,d,e,f){oi(a,b);var g=0!==(b.flags&64);if(!d&&!g)return e&&Kf(b,c,!1),hi(a,b,f);d=b.stateNode;ei.current=b;var h=g&&"function"!==typeof c.getDerivedStateFromError?null:d.render();b.flags|=1;null!==a&&g?(b.child=Yg(b,a.child,null,f),b.child=Yg(b,null,h,f)):fi(a,b,h,f);b.memoizedState=d.state;e&&Kf(b,c,!0);return b.child}function ri(a){var b=a.stateNode;b.pendingContext?Hf(a,b.pendingContext,b.pendingContext!==b.context):b.context&&Hf(a,b.context,!1);eh(a,b.containerInfo)}\nvar si={dehydrated:null,retryLane:0};\nfunction ti(a,b,c){var d=b.pendingProps,e=P.current,f=!1,g;(g=0!==(b.flags&64))||(g=null!==a&&null===a.memoizedState?!1:0!==(e&2));g?(f=!0,b.flags&=-65):null!==a&&null===a.memoizedState||void 0===d.fallback||!0===d.unstable_avoidThisFallback||(e|=1);I(P,e&1);if(null===a){void 0!==d.fallback&&ph(b);a=d.children;e=d.fallback;if(f)return a=ui(b,a,e,c),b.child.memoizedState={baseLanes:c},b.memoizedState=si,a;if("number"===typeof d.unstable_expectedLoadTime)return a=ui(b,a,e,c),b.child.memoizedState={baseLanes:c},\nb.memoizedState=si,b.lanes=33554432,a;c=vi({mode:"visible",children:a},b.mode,c,null);c.return=b;return b.child=c}if(null!==a.memoizedState){if(f)return d=wi(a,b,d.children,d.fallback,c),f=b.child,e=a.child.memoizedState,f.memoizedState=null===e?{baseLanes:c}:{baseLanes:e.baseLanes|c},f.childLanes=a.childLanes&~c,b.memoizedState=si,d;c=xi(a,b,d.children,c);b.memoizedState=null;return c}if(f)return d=wi(a,b,d.children,d.fallback,c),f=b.child,e=a.child.memoizedState,f.memoizedState=null===e?{baseLanes:c}:\n{baseLanes:e.baseLanes|c},f.childLanes=a.childLanes&~c,b.memoizedState=si,d;c=xi(a,b,d.children,c);b.memoizedState=null;return c}function ui(a,b,c,d){var e=a.mode,f=a.child;b={mode:"hidden",children:b};0===(e&2)&&null!==f?(f.childLanes=0,f.pendingProps=b):f=vi(b,e,0,null);c=Xg(c,e,d,null);f.return=a;c.return=a;f.sibling=c;a.child=f;return c}\nfunction xi(a,b,c,d){var e=a.child;a=e.sibling;c=Tg(e,{mode:"visible",children:c});0===(b.mode&2)&&(c.lanes=d);c.return=b;c.sibling=null;null!==a&&(a.nextEffect=null,a.flags=8,b.firstEffect=b.lastEffect=a);return b.child=c}\nfunction wi(a,b,c,d,e){var f=b.mode,g=a.child;a=g.sibling;var h={mode:"hidden",children:c};0===(f&2)&&b.child!==g?(c=b.child,c.childLanes=0,c.pendingProps=h,g=c.lastEffect,null!==g?(b.firstEffect=c.firstEffect,b.lastEffect=g,g.nextEffect=null):b.firstEffect=b.lastEffect=null):c=Tg(g,h);null!==a?d=Tg(a,d):(d=Xg(d,f,e,null),d.flags|=2);d.return=b;c.return=b;c.sibling=d;b.child=c;return d}function yi(a,b){a.lanes|=b;var c=a.alternate;null!==c&&(c.lanes|=b);sg(a.return,b)}\nfunction zi(a,b,c,d,e,f){var g=a.memoizedState;null===g?a.memoizedState={isBackwards:b,rendering:null,renderingStartTime:0,last:d,tail:c,tailMode:e,lastEffect:f}:(g.isBackwards=b,g.rendering=null,g.renderingStartTime=0,g.last=d,g.tail=c,g.tailMode=e,g.lastEffect=f)}\nfunction Ai(a,b,c){var d=b.pendingProps,e=d.revealOrder,f=d.tail;fi(a,b,d.children,c);d=P.current;if(0!==(d&2))d=d&1|2,b.flags|=64;else{if(null!==a&&0!==(a.flags&64))a:for(a=b.child;null!==a;){if(13===a.tag)null!==a.memoizedState&&yi(a,c);else if(19===a.tag)yi(a,c);else if(null!==a.child){a.child.return=a;a=a.child;continue}if(a===b)break a;for(;null===a.sibling;){if(null===a.return||a.return===b)break a;a=a.return}a.sibling.return=a.return;a=a.sibling}d&=1}I(P,d);if(0===(b.mode&2))b.memoizedState=\nnull;else switch(e){case "forwards":c=b.child;for(e=null;null!==c;)a=c.alternate,null!==a&&null===ih(a)&&(e=c),c=c.sibling;c=e;null===c?(e=b.child,b.child=null):(e=c.sibling,c.sibling=null);zi(b,!1,e,c,f,b.lastEffect);break;case "backwards":c=null;e=b.child;for(b.child=null;null!==e;){a=e.alternate;if(null!==a&&null===ih(a)){b.child=e;break}a=e.sibling;e.sibling=c;c=e;e=a}zi(b,!0,c,null,f,b.lastEffect);break;case "together":zi(b,!1,null,null,void 0,b.lastEffect);break;default:b.memoizedState=null}return b.child}\nfunction hi(a,b,c){null!==a&&(b.dependencies=a.dependencies);Dg|=b.lanes;if(0!==(c&b.childLanes)){if(null!==a&&b.child!==a.child)throw Error(y(153));if(null!==b.child){a=b.child;c=Tg(a,a.pendingProps);b.child=c;for(c.return=b;null!==a.sibling;)a=a.sibling,c=c.sibling=Tg(a,a.pendingProps),c.return=b;c.sibling=null}return b.child}return null}var Bi,Ci,Di,Ei;\nBi=function(a,b){for(var c=b.child;null!==c;){if(5===c.tag||6===c.tag)a.appendChild(c.stateNode);else if(4!==c.tag&&null!==c.child){c.child.return=c;c=c.child;continue}if(c===b)break;for(;null===c.sibling;){if(null===c.return||c.return===b)return;c=c.return}c.sibling.return=c.return;c=c.sibling}};Ci=function(){};\nDi=function(a,b,c,d){var e=a.memoizedProps;if(e!==d){a=b.stateNode;dh(ah.current);var f=null;switch(c){case "input":e=Ya(a,e);d=Ya(a,d);f=[];break;case "option":e=eb(a,e);d=eb(a,d);f=[];break;case "select":e=m({},e,{value:void 0});d=m({},d,{value:void 0});f=[];break;case "textarea":e=gb(a,e);d=gb(a,d);f=[];break;default:"function"!==typeof e.onClick&&"function"===typeof d.onClick&&(a.onclick=jf)}vb(c,d);var g;c=null;for(l in e)if(!d.hasOwnProperty(l)&&e.hasOwnProperty(l)&&null!=e[l])if("style"===\nl){var h=e[l];for(g in h)h.hasOwnProperty(g)&&(c||(c={}),c[g]="")}else"dangerouslySetInnerHTML"!==l&&"children"!==l&&"suppressContentEditableWarning"!==l&&"suppressHydrationWarning"!==l&&"autoFocus"!==l&&(ca.hasOwnProperty(l)?f||(f=[]):(f=f||[]).push(l,null));for(l in d){var k=d[l];h=null!=e?e[l]:void 0;if(d.hasOwnProperty(l)&&k!==h&&(null!=k||null!=h))if("style"===l)if(h){for(g in h)!h.hasOwnProperty(g)||k&&k.hasOwnProperty(g)||(c||(c={}),c[g]="");for(g in k)k.hasOwnProperty(g)&&h[g]!==k[g]&&(c||\n(c={}),c[g]=k[g])}else c||(f||(f=[]),f.push(l,c)),c=k;else"dangerouslySetInnerHTML"===l?(k=k?k.__html:void 0,h=h?h.__html:void 0,null!=k&&h!==k&&(f=f||[]).push(l,k)):"children"===l?"string"!==typeof k&&"number"!==typeof k||(f=f||[]).push(l,""+k):"suppressContentEditableWarning"!==l&&"suppressHydrationWarning"!==l&&(ca.hasOwnProperty(l)?(null!=k&&"onScroll"===l&&G("scroll",a),f||h===k||(f=[])):"object"===typeof k&&null!==k&&k.$$typeof===Ga?k.toString():(f=f||[]).push(l,k))}c&&(f=f||[]).push("style",\nc);var l=f;if(b.updateQueue=l)b.flags|=4}};Ei=function(a,b,c,d){c!==d&&(b.flags|=4)};function Fi(a,b){if(!lh)switch(a.tailMode){case "hidden":b=a.tail;for(var c=null;null!==b;)null!==b.alternate&&(c=b),b=b.sibling;null===c?a.tail=null:c.sibling=null;break;case "collapsed":c=a.tail;for(var d=null;null!==c;)null!==c.alternate&&(d=c),c=c.sibling;null===d?b||null===a.tail?a.tail=null:a.tail.sibling=null:d.sibling=null}}\nfunction Gi(a,b,c){var d=b.pendingProps;switch(b.tag){case 2:case 16:case 15:case 0:case 11:case 7:case 8:case 12:case 9:case 14:return null;case 1:return Ff(b.type)&&Gf(),null;case 3:fh();H(N);H(M);uh();d=b.stateNode;d.pendingContext&&(d.context=d.pendingContext,d.pendingContext=null);if(null===a||null===a.child)rh(b)?b.flags|=4:d.hydrate||(b.flags|=256);Ci(b);return null;case 5:hh(b);var e=dh(ch.current);c=b.type;if(null!==a&&null!=b.stateNode)Di(a,b,c,d,e),a.ref!==b.ref&&(b.flags|=128);else{if(!d){if(null===\nb.stateNode)throw Error(y(166));return null}a=dh(ah.current);if(rh(b)){d=b.stateNode;c=b.type;var f=b.memoizedProps;d[wf]=b;d[xf]=f;switch(c){case "dialog":G("cancel",d);G("close",d);break;case "iframe":case "object":case "embed":G("load",d);break;case "video":case "audio":for(a=0;a<Xe.length;a++)G(Xe[a],d);break;case "source":G("error",d);break;case "img":case "image":case "link":G("error",d);G("load",d);break;case "details":G("toggle",d);break;case "input":Za(d,f);G("invalid",d);break;case "select":d._wrapperState=\n{wasMultiple:!!f.multiple};G("invalid",d);break;case "textarea":hb(d,f),G("invalid",d)}vb(c,f);a=null;for(var g in f)f.hasOwnProperty(g)&&(e=f[g],"children"===g?"string"===typeof e?d.textContent!==e&&(a=["children",e]):"number"===typeof e&&d.textContent!==""+e&&(a=["children",""+e]):ca.hasOwnProperty(g)&&null!=e&&"onScroll"===g&&G("scroll",d));switch(c){case "input":Va(d);cb(d,f,!0);break;case "textarea":Va(d);jb(d);break;case "select":case "option":break;default:"function"===typeof f.onClick&&(d.onclick=\njf)}d=a;b.updateQueue=d;null!==d&&(b.flags|=4)}else{g=9===e.nodeType?e:e.ownerDocument;a===kb.html&&(a=lb(c));a===kb.html?"script"===c?(a=g.createElement("div"),a.innerHTML="<script>\\x3c/script>",a=a.removeChild(a.firstChild)):"string"===typeof d.is?a=g.createElement(c,{is:d.is}):(a=g.createElement(c),"select"===c&&(g=a,d.multiple?g.multiple=!0:d.size&&(g.size=d.size))):a=g.createElementNS(a,c);a[wf]=b;a[xf]=d;Bi(a,b,!1,!1);b.stateNode=a;g=wb(c,d);switch(c){case "dialog":G("cancel",a);G("close",a);\ne=d;break;case "iframe":case "object":case "embed":G("load",a);e=d;break;case "video":case "audio":for(e=0;e<Xe.length;e++)G(Xe[e],a);e=d;break;case "source":G("error",a);e=d;break;case "img":case "image":case "link":G("error",a);G("load",a);e=d;break;case "details":G("toggle",a);e=d;break;case "input":Za(a,d);e=Ya(a,d);G("invalid",a);break;case "option":e=eb(a,d);break;case "select":a._wrapperState={wasMultiple:!!d.multiple};e=m({},d,{value:void 0});G("invalid",a);break;case "textarea":hb(a,d);e=\ngb(a,d);G("invalid",a);break;default:e=d}vb(c,e);var h=e;for(f in h)if(h.hasOwnProperty(f)){var k=h[f];"style"===f?tb(a,k):"dangerouslySetInnerHTML"===f?(k=k?k.__html:void 0,null!=k&&ob(a,k)):"children"===f?"string"===typeof k?("textarea"!==c||""!==k)&&pb(a,k):"number"===typeof k&&pb(a,""+k):"suppressContentEditableWarning"!==f&&"suppressHydrationWarning"!==f&&"autoFocus"!==f&&(ca.hasOwnProperty(f)?null!=k&&"onScroll"===f&&G("scroll",a):null!=k&&qa(a,f,k,g))}switch(c){case "input":Va(a);cb(a,d,!1);\nbreak;case "textarea":Va(a);jb(a);break;case "option":null!=d.value&&a.setAttribute("value",""+Sa(d.value));break;case "select":a.multiple=!!d.multiple;f=d.value;null!=f?fb(a,!!d.multiple,f,!1):null!=d.defaultValue&&fb(a,!!d.multiple,d.defaultValue,!0);break;default:"function"===typeof e.onClick&&(a.onclick=jf)}mf(c,d)&&(b.flags|=4)}null!==b.ref&&(b.flags|=128)}return null;case 6:if(a&&null!=b.stateNode)Ei(a,b,a.memoizedProps,d);else{if("string"!==typeof d&&null===b.stateNode)throw Error(y(166));\nc=dh(ch.current);dh(ah.current);rh(b)?(d=b.stateNode,c=b.memoizedProps,d[wf]=b,d.nodeValue!==c&&(b.flags|=4)):(d=(9===c.nodeType?c:c.ownerDocument).createTextNode(d),d[wf]=b,b.stateNode=d)}return null;case 13:H(P);d=b.memoizedState;if(0!==(b.flags&64))return b.lanes=c,b;d=null!==d;c=!1;null===a?void 0!==b.memoizedProps.fallback&&rh(b):c=null!==a.memoizedState;if(d&&!c&&0!==(b.mode&2))if(null===a&&!0!==b.memoizedProps.unstable_avoidThisFallback||0!==(P.current&1))0===V&&(V=3);else{if(0===V||3===V)V=\n4;null===U||0===(Dg&134217727)&&0===(Hi&134217727)||Ii(U,W)}if(d||c)b.flags|=4;return null;case 4:return fh(),Ci(b),null===a&&cf(b.stateNode.containerInfo),null;case 10:return rg(b),null;case 17:return Ff(b.type)&&Gf(),null;case 19:H(P);d=b.memoizedState;if(null===d)return null;f=0!==(b.flags&64);g=d.rendering;if(null===g)if(f)Fi(d,!1);else{if(0!==V||null!==a&&0!==(a.flags&64))for(a=b.child;null!==a;){g=ih(a);if(null!==g){b.flags|=64;Fi(d,!1);f=g.updateQueue;null!==f&&(b.updateQueue=f,b.flags|=4);\nnull===d.lastEffect&&(b.firstEffect=null);b.lastEffect=d.lastEffect;d=c;for(c=b.child;null!==c;)f=c,a=d,f.flags&=2,f.nextEffect=null,f.firstEffect=null,f.lastEffect=null,g=f.alternate,null===g?(f.childLanes=0,f.lanes=a,f.child=null,f.memoizedProps=null,f.memoizedState=null,f.updateQueue=null,f.dependencies=null,f.stateNode=null):(f.childLanes=g.childLanes,f.lanes=g.lanes,f.child=g.child,f.memoizedProps=g.memoizedProps,f.memoizedState=g.memoizedState,f.updateQueue=g.updateQueue,f.type=g.type,a=g.dependencies,\nf.dependencies=null===a?null:{lanes:a.lanes,firstContext:a.firstContext}),c=c.sibling;I(P,P.current&1|2);return b.child}a=a.sibling}null!==d.tail&&O()>Ji&&(b.flags|=64,f=!0,Fi(d,!1),b.lanes=33554432)}else{if(!f)if(a=ih(g),null!==a){if(b.flags|=64,f=!0,c=a.updateQueue,null!==c&&(b.updateQueue=c,b.flags|=4),Fi(d,!0),null===d.tail&&"hidden"===d.tailMode&&!g.alternate&&!lh)return b=b.lastEffect=d.lastEffect,null!==b&&(b.nextEffect=null),null}else 2*O()-d.renderingStartTime>Ji&&1073741824!==c&&(b.flags|=\n64,f=!0,Fi(d,!1),b.lanes=33554432);d.isBackwards?(g.sibling=b.child,b.child=g):(c=d.last,null!==c?c.sibling=g:b.child=g,d.last=g)}return null!==d.tail?(c=d.tail,d.rendering=c,d.tail=c.sibling,d.lastEffect=b.lastEffect,d.renderingStartTime=O(),c.sibling=null,b=P.current,I(P,f?b&1|2:b&1),c):null;case 23:case 24:return Ki(),null!==a&&null!==a.memoizedState!==(null!==b.memoizedState)&&"unstable-defer-without-hiding"!==d.mode&&(b.flags|=4),null}throw Error(y(156,b.tag));}\nfunction Li(a){switch(a.tag){case 1:Ff(a.type)&&Gf();var b=a.flags;return b&4096?(a.flags=b&-4097|64,a):null;case 3:fh();H(N);H(M);uh();b=a.flags;if(0!==(b&64))throw Error(y(285));a.flags=b&-4097|64;return a;case 5:return hh(a),null;case 13:return H(P),b=a.flags,b&4096?(a.flags=b&-4097|64,a):null;case 19:return H(P),null;case 4:return fh(),null;case 10:return rg(a),null;case 23:case 24:return Ki(),null;default:return null}}\nfunction Mi(a,b){try{var c="",d=b;do c+=Qa(d),d=d.return;while(d);var e=c}catch(f){e="\\nError generating stack: "+f.message+"\\n"+f.stack}return{value:a,source:b,stack:e}}function Ni(a,b){try{console.error(b.value)}catch(c){setTimeout(function(){throw c;})}}var Oi="function"===typeof WeakMap?WeakMap:Map;function Pi(a,b,c){c=zg(-1,c);c.tag=3;c.payload={element:null};var d=b.value;c.callback=function(){Qi||(Qi=!0,Ri=d);Ni(a,b)};return c}\nfunction Si(a,b,c){c=zg(-1,c);c.tag=3;var d=a.type.getDerivedStateFromError;if("function"===typeof d){var e=b.value;c.payload=function(){Ni(a,b);return d(e)}}var f=a.stateNode;null!==f&&"function"===typeof f.componentDidCatch&&(c.callback=function(){"function"!==typeof d&&(null===Ti?Ti=new Set([this]):Ti.add(this),Ni(a,b));var c=b.stack;this.componentDidCatch(b.value,{componentStack:null!==c?c:""})});return c}var Ui="function"===typeof WeakSet?WeakSet:Set;\nfunction Vi(a){var b=a.ref;if(null!==b)if("function"===typeof b)try{b(null)}catch(c){Wi(a,c)}else b.current=null}function Xi(a,b){switch(b.tag){case 0:case 11:case 15:case 22:return;case 1:if(b.flags&256&&null!==a){var c=a.memoizedProps,d=a.memoizedState;a=b.stateNode;b=a.getSnapshotBeforeUpdate(b.elementType===b.type?c:lg(b.type,c),d);a.__reactInternalSnapshotBeforeUpdate=b}return;case 3:b.flags&256&&qf(b.stateNode.containerInfo);return;case 5:case 6:case 4:case 17:return}throw Error(y(163));}\nfunction Yi(a,b,c){switch(c.tag){case 0:case 11:case 15:case 22:b=c.updateQueue;b=null!==b?b.lastEffect:null;if(null!==b){a=b=b.next;do{if(3===(a.tag&3)){var d=a.create;a.destroy=d()}a=a.next}while(a!==b)}b=c.updateQueue;b=null!==b?b.lastEffect:null;if(null!==b){a=b=b.next;do{var e=a;d=e.next;e=e.tag;0!==(e&4)&&0!==(e&1)&&(Zi(c,a),$i(c,a));a=d}while(a!==b)}return;case 1:a=c.stateNode;c.flags&4&&(null===b?a.componentDidMount():(d=c.elementType===c.type?b.memoizedProps:lg(c.type,b.memoizedProps),a.componentDidUpdate(d,\nb.memoizedState,a.__reactInternalSnapshotBeforeUpdate)));b=c.updateQueue;null!==b&&Eg(c,b,a);return;case 3:b=c.updateQueue;if(null!==b){a=null;if(null!==c.child)switch(c.child.tag){case 5:a=c.child.stateNode;break;case 1:a=c.child.stateNode}Eg(c,b,a)}return;case 5:a=c.stateNode;null===b&&c.flags&4&&mf(c.type,c.memoizedProps)&&a.focus();return;case 6:return;case 4:return;case 12:return;case 13:null===c.memoizedState&&(c=c.alternate,null!==c&&(c=c.memoizedState,null!==c&&(c=c.dehydrated,null!==c&&Cc(c))));\nreturn;case 19:case 17:case 20:case 21:case 23:case 24:return}throw Error(y(163));}\nfunction aj(a,b){for(var c=a;;){if(5===c.tag){var d=c.stateNode;if(b)d=d.style,"function"===typeof d.setProperty?d.setProperty("display","none","important"):d.display="none";else{d=c.stateNode;var e=c.memoizedProps.style;e=void 0!==e&&null!==e&&e.hasOwnProperty("display")?e.display:null;d.style.display=sb("display",e)}}else if(6===c.tag)c.stateNode.nodeValue=b?"":c.memoizedProps;else if((23!==c.tag&&24!==c.tag||null===c.memoizedState||c===a)&&null!==c.child){c.child.return=c;c=c.child;continue}if(c===\na)break;for(;null===c.sibling;){if(null===c.return||c.return===a)return;c=c.return}c.sibling.return=c.return;c=c.sibling}}\nfunction bj(a,b){if(Mf&&"function"===typeof Mf.onCommitFiberUnmount)try{Mf.onCommitFiberUnmount(Lf,b)}catch(f){}switch(b.tag){case 0:case 11:case 14:case 15:case 22:a=b.updateQueue;if(null!==a&&(a=a.lastEffect,null!==a)){var c=a=a.next;do{var d=c,e=d.destroy;d=d.tag;if(void 0!==e)if(0!==(d&4))Zi(b,c);else{d=b;try{e()}catch(f){Wi(d,f)}}c=c.next}while(c!==a)}break;case 1:Vi(b);a=b.stateNode;if("function"===typeof a.componentWillUnmount)try{a.props=b.memoizedProps,a.state=b.memoizedState,a.componentWillUnmount()}catch(f){Wi(b,\nf)}break;case 5:Vi(b);break;case 4:cj(a,b)}}function dj(a){a.alternate=null;a.child=null;a.dependencies=null;a.firstEffect=null;a.lastEffect=null;a.memoizedProps=null;a.memoizedState=null;a.pendingProps=null;a.return=null;a.updateQueue=null}function ej(a){return 5===a.tag||3===a.tag||4===a.tag}\nfunction fj(a){a:{for(var b=a.return;null!==b;){if(ej(b))break a;b=b.return}throw Error(y(160));}var c=b;b=c.stateNode;switch(c.tag){case 5:var d=!1;break;case 3:b=b.containerInfo;d=!0;break;case 4:b=b.containerInfo;d=!0;break;default:throw Error(y(161));}c.flags&16&&(pb(b,""),c.flags&=-17);a:b:for(c=a;;){for(;null===c.sibling;){if(null===c.return||ej(c.return)){c=null;break a}c=c.return}c.sibling.return=c.return;for(c=c.sibling;5!==c.tag&&6!==c.tag&&18!==c.tag;){if(c.flags&2)continue b;if(null===\nc.child||4===c.tag)continue b;else c.child.return=c,c=c.child}if(!(c.flags&2)){c=c.stateNode;break a}}d?gj(a,c,b):hj(a,c,b)}\nfunction gj(a,b,c){var d=a.tag,e=5===d||6===d;if(e)a=e?a.stateNode:a.stateNode.instance,b?8===c.nodeType?c.parentNode.insertBefore(a,b):c.insertBefore(a,b):(8===c.nodeType?(b=c.parentNode,b.insertBefore(a,c)):(b=c,b.appendChild(a)),c=c._reactRootContainer,null!==c&&void 0!==c||null!==b.onclick||(b.onclick=jf));else if(4!==d&&(a=a.child,null!==a))for(gj(a,b,c),a=a.sibling;null!==a;)gj(a,b,c),a=a.sibling}\nfunction hj(a,b,c){var d=a.tag,e=5===d||6===d;if(e)a=e?a.stateNode:a.stateNode.instance,b?c.insertBefore(a,b):c.appendChild(a);else if(4!==d&&(a=a.child,null!==a))for(hj(a,b,c),a=a.sibling;null!==a;)hj(a,b,c),a=a.sibling}\nfunction cj(a,b){for(var c=b,d=!1,e,f;;){if(!d){d=c.return;a:for(;;){if(null===d)throw Error(y(160));e=d.stateNode;switch(d.tag){case 5:f=!1;break a;case 3:e=e.containerInfo;f=!0;break a;case 4:e=e.containerInfo;f=!0;break a}d=d.return}d=!0}if(5===c.tag||6===c.tag){a:for(var g=a,h=c,k=h;;)if(bj(g,k),null!==k.child&&4!==k.tag)k.child.return=k,k=k.child;else{if(k===h)break a;for(;null===k.sibling;){if(null===k.return||k.return===h)break a;k=k.return}k.sibling.return=k.return;k=k.sibling}f?(g=e,h=c.stateNode,\n8===g.nodeType?g.parentNode.removeChild(h):g.removeChild(h)):e.removeChild(c.stateNode)}else if(4===c.tag){if(null!==c.child){e=c.stateNode.containerInfo;f=!0;c.child.return=c;c=c.child;continue}}else if(bj(a,c),null!==c.child){c.child.return=c;c=c.child;continue}if(c===b)break;for(;null===c.sibling;){if(null===c.return||c.return===b)return;c=c.return;4===c.tag&&(d=!1)}c.sibling.return=c.return;c=c.sibling}}\nfunction ij(a,b){switch(b.tag){case 0:case 11:case 14:case 15:case 22:var c=b.updateQueue;c=null!==c?c.lastEffect:null;if(null!==c){var d=c=c.next;do 3===(d.tag&3)&&(a=d.destroy,d.destroy=void 0,void 0!==a&&a()),d=d.next;while(d!==c)}return;case 1:return;case 5:c=b.stateNode;if(null!=c){d=b.memoizedProps;var e=null!==a?a.memoizedProps:d;a=b.type;var f=b.updateQueue;b.updateQueue=null;if(null!==f){c[xf]=d;"input"===a&&"radio"===d.type&&null!=d.name&&$a(c,d);wb(a,e);b=wb(a,d);for(e=0;e<f.length;e+=\n2){var g=f[e],h=f[e+1];"style"===g?tb(c,h):"dangerouslySetInnerHTML"===g?ob(c,h):"children"===g?pb(c,h):qa(c,g,h,b)}switch(a){case "input":ab(c,d);break;case "textarea":ib(c,d);break;case "select":a=c._wrapperState.wasMultiple,c._wrapperState.wasMultiple=!!d.multiple,f=d.value,null!=f?fb(c,!!d.multiple,f,!1):a!==!!d.multiple&&(null!=d.defaultValue?fb(c,!!d.multiple,d.defaultValue,!0):fb(c,!!d.multiple,d.multiple?[]:"",!1))}}}return;case 6:if(null===b.stateNode)throw Error(y(162));b.stateNode.nodeValue=\nb.memoizedProps;return;case 3:c=b.stateNode;c.hydrate&&(c.hydrate=!1,Cc(c.containerInfo));return;case 12:return;case 13:null!==b.memoizedState&&(jj=O(),aj(b.child,!0));kj(b);return;case 19:kj(b);return;case 17:return;case 23:case 24:aj(b,null!==b.memoizedState);return}throw Error(y(163));}function kj(a){var b=a.updateQueue;if(null!==b){a.updateQueue=null;var c=a.stateNode;null===c&&(c=a.stateNode=new Ui);b.forEach(function(b){var d=lj.bind(null,a,b);c.has(b)||(c.add(b),b.then(d,d))})}}\nfunction mj(a,b){return null!==a&&(a=a.memoizedState,null===a||null!==a.dehydrated)?(b=b.memoizedState,null!==b&&null===b.dehydrated):!1}var nj=Math.ceil,oj=ra.ReactCurrentDispatcher,pj=ra.ReactCurrentOwner,X=0,U=null,Y=null,W=0,qj=0,rj=Bf(0),V=0,sj=null,tj=0,Dg=0,Hi=0,uj=0,vj=null,jj=0,Ji=Infinity;function wj(){Ji=O()+500}var Z=null,Qi=!1,Ri=null,Ti=null,xj=!1,yj=null,zj=90,Aj=[],Bj=[],Cj=null,Dj=0,Ej=null,Fj=-1,Gj=0,Hj=0,Ij=null,Jj=!1;function Hg(){return 0!==(X&48)?O():-1!==Fj?Fj:Fj=O()}\nfunction Ig(a){a=a.mode;if(0===(a&2))return 1;if(0===(a&4))return 99===eg()?1:2;0===Gj&&(Gj=tj);if(0!==kg.transition){0!==Hj&&(Hj=null!==vj?vj.pendingLanes:0);a=Gj;var b=4186112&~Hj;b&=-b;0===b&&(a=4186112&~a,b=a&-a,0===b&&(b=8192));return b}a=eg();0!==(X&4)&&98===a?a=Xc(12,Gj):(a=Sc(a),a=Xc(a,Gj));return a}\nfunction Jg(a,b,c){if(50<Dj)throw Dj=0,Ej=null,Error(y(185));a=Kj(a,b);if(null===a)return null;$c(a,b,c);a===U&&(Hi|=b,4===V&&Ii(a,W));var d=eg();1===b?0!==(X&8)&&0===(X&48)?Lj(a):(Mj(a,c),0===X&&(wj(),ig())):(0===(X&4)||98!==d&&99!==d||(null===Cj?Cj=new Set([a]):Cj.add(a)),Mj(a,c));vj=a}function Kj(a,b){a.lanes|=b;var c=a.alternate;null!==c&&(c.lanes|=b);c=a;for(a=a.return;null!==a;)a.childLanes|=b,c=a.alternate,null!==c&&(c.childLanes|=b),c=a,a=a.return;return 3===c.tag?c.stateNode:null}\nfunction Mj(a,b){for(var c=a.callbackNode,d=a.suspendedLanes,e=a.pingedLanes,f=a.expirationTimes,g=a.pendingLanes;0<g;){var h=31-Vc(g),k=1<<h,l=f[h];if(-1===l){if(0===(k&d)||0!==(k&e)){l=b;Rc(k);var n=F;f[h]=10<=n?l+250:6<=n?l+5E3:-1}}else l<=b&&(a.expiredLanes|=k);g&=~k}d=Uc(a,a===U?W:0);b=F;if(0===d)null!==c&&(c!==Zf&&Pf(c),a.callbackNode=null,a.callbackPriority=0);else{if(null!==c){if(a.callbackPriority===b)return;c!==Zf&&Pf(c)}15===b?(c=Lj.bind(null,a),null===ag?(ag=[c],bg=Of(Uf,jg)):ag.push(c),\nc=Zf):14===b?c=hg(99,Lj.bind(null,a)):(c=Tc(b),c=hg(c,Nj.bind(null,a)));a.callbackPriority=b;a.callbackNode=c}}\nfunction Nj(a){Fj=-1;Hj=Gj=0;if(0!==(X&48))throw Error(y(327));var b=a.callbackNode;if(Oj()&&a.callbackNode!==b)return null;var c=Uc(a,a===U?W:0);if(0===c)return null;var d=c;var e=X;X|=16;var f=Pj();if(U!==a||W!==d)wj(),Qj(a,d);do try{Rj();break}catch(h){Sj(a,h)}while(1);qg();oj.current=f;X=e;null!==Y?d=0:(U=null,W=0,d=V);if(0!==(tj&Hi))Qj(a,0);else if(0!==d){2===d&&(X|=64,a.hydrate&&(a.hydrate=!1,qf(a.containerInfo)),c=Wc(a),0!==c&&(d=Tj(a,c)));if(1===d)throw b=sj,Qj(a,0),Ii(a,c),Mj(a,O()),b;a.finishedWork=\na.current.alternate;a.finishedLanes=c;switch(d){case 0:case 1:throw Error(y(345));case 2:Uj(a);break;case 3:Ii(a,c);if((c&62914560)===c&&(d=jj+500-O(),10<d)){if(0!==Uc(a,0))break;e=a.suspendedLanes;if((e&c)!==c){Hg();a.pingedLanes|=a.suspendedLanes&e;break}a.timeoutHandle=of(Uj.bind(null,a),d);break}Uj(a);break;case 4:Ii(a,c);if((c&4186112)===c)break;d=a.eventTimes;for(e=-1;0<c;){var g=31-Vc(c);f=1<<g;g=d[g];g>e&&(e=g);c&=~f}c=e;c=O()-c;c=(120>c?120:480>c?480:1080>c?1080:1920>c?1920:3E3>c?3E3:4320>\nc?4320:1960*nj(c/1960))-c;if(10<c){a.timeoutHandle=of(Uj.bind(null,a),c);break}Uj(a);break;case 5:Uj(a);break;default:throw Error(y(329));}}Mj(a,O());return a.callbackNode===b?Nj.bind(null,a):null}function Ii(a,b){b&=~uj;b&=~Hi;a.suspendedLanes|=b;a.pingedLanes&=~b;for(a=a.expirationTimes;0<b;){var c=31-Vc(b),d=1<<c;a[c]=-1;b&=~d}}\nfunction Lj(a){if(0!==(X&48))throw Error(y(327));Oj();if(a===U&&0!==(a.expiredLanes&W)){var b=W;var c=Tj(a,b);0!==(tj&Hi)&&(b=Uc(a,b),c=Tj(a,b))}else b=Uc(a,0),c=Tj(a,b);0!==a.tag&&2===c&&(X|=64,a.hydrate&&(a.hydrate=!1,qf(a.containerInfo)),b=Wc(a),0!==b&&(c=Tj(a,b)));if(1===c)throw c=sj,Qj(a,0),Ii(a,b),Mj(a,O()),c;a.finishedWork=a.current.alternate;a.finishedLanes=b;Uj(a);Mj(a,O());return null}\nfunction Vj(){if(null!==Cj){var a=Cj;Cj=null;a.forEach(function(a){a.expiredLanes|=24&a.pendingLanes;Mj(a,O())})}ig()}function Wj(a,b){var c=X;X|=1;try{return a(b)}finally{X=c,0===X&&(wj(),ig())}}function Xj(a,b){var c=X;X&=-2;X|=8;try{return a(b)}finally{X=c,0===X&&(wj(),ig())}}function ni(a,b){I(rj,qj);qj|=b;tj|=b}function Ki(){qj=rj.current;H(rj)}\nfunction Qj(a,b){a.finishedWork=null;a.finishedLanes=0;var c=a.timeoutHandle;-1!==c&&(a.timeoutHandle=-1,pf(c));if(null!==Y)for(c=Y.return;null!==c;){var d=c;switch(d.tag){case 1:d=d.type.childContextTypes;null!==d&&void 0!==d&&Gf();break;case 3:fh();H(N);H(M);uh();break;case 5:hh(d);break;case 4:fh();break;case 13:H(P);break;case 19:H(P);break;case 10:rg(d);break;case 23:case 24:Ki()}c=c.return}U=a;Y=Tg(a.current,null);W=qj=tj=b;V=0;sj=null;uj=Hi=Dg=0}\nfunction Sj(a,b){do{var c=Y;try{qg();vh.current=Gh;if(yh){for(var d=R.memoizedState;null!==d;){var e=d.queue;null!==e&&(e.pending=null);d=d.next}yh=!1}xh=0;T=S=R=null;zh=!1;pj.current=null;if(null===c||null===c.return){V=1;sj=b;Y=null;break}a:{var f=a,g=c.return,h=c,k=b;b=W;h.flags|=2048;h.firstEffect=h.lastEffect=null;if(null!==k&&"object"===typeof k&&"function"===typeof k.then){var l=k;if(0===(h.mode&2)){var n=h.alternate;n?(h.updateQueue=n.updateQueue,h.memoizedState=n.memoizedState,h.lanes=n.lanes):\n(h.updateQueue=null,h.memoizedState=null)}var A=0!==(P.current&1),p=g;do{var C;if(C=13===p.tag){var x=p.memoizedState;if(null!==x)C=null!==x.dehydrated?!0:!1;else{var w=p.memoizedProps;C=void 0===w.fallback?!1:!0!==w.unstable_avoidThisFallback?!0:A?!1:!0}}if(C){var z=p.updateQueue;if(null===z){var u=new Set;u.add(l);p.updateQueue=u}else z.add(l);if(0===(p.mode&2)){p.flags|=64;h.flags|=16384;h.flags&=-2981;if(1===h.tag)if(null===h.alternate)h.tag=17;else{var t=zg(-1,1);t.tag=2;Ag(h,t)}h.lanes|=1;break a}k=\nvoid 0;h=b;var q=f.pingCache;null===q?(q=f.pingCache=new Oi,k=new Set,q.set(l,k)):(k=q.get(l),void 0===k&&(k=new Set,q.set(l,k)));if(!k.has(h)){k.add(h);var v=Yj.bind(null,f,l,h);l.then(v,v)}p.flags|=4096;p.lanes=b;break a}p=p.return}while(null!==p);k=Error((Ra(h.type)||"A React component")+" suspended while rendering, but no fallback UI was specified.\\n\\nAdd a <Suspense fallback=...> component higher in the tree to provide a loading indicator or placeholder to display.")}5!==V&&(V=2);k=Mi(k,h);p=\ng;do{switch(p.tag){case 3:f=k;p.flags|=4096;b&=-b;p.lanes|=b;var J=Pi(p,f,b);Bg(p,J);break a;case 1:f=k;var K=p.type,Q=p.stateNode;if(0===(p.flags&64)&&("function"===typeof K.getDerivedStateFromError||null!==Q&&"function"===typeof Q.componentDidCatch&&(null===Ti||!Ti.has(Q)))){p.flags|=4096;b&=-b;p.lanes|=b;var L=Si(p,f,b);Bg(p,L);break a}}p=p.return}while(null!==p)}Zj(c)}catch(va){b=va;Y===c&&null!==c&&(Y=c=c.return);continue}break}while(1)}\nfunction Pj(){var a=oj.current;oj.current=Gh;return null===a?Gh:a}function Tj(a,b){var c=X;X|=16;var d=Pj();U===a&&W===b||Qj(a,b);do try{ak();break}catch(e){Sj(a,e)}while(1);qg();X=c;oj.current=d;if(null!==Y)throw Error(y(261));U=null;W=0;return V}function ak(){for(;null!==Y;)bk(Y)}function Rj(){for(;null!==Y&&!Qf();)bk(Y)}function bk(a){var b=ck(a.alternate,a,qj);a.memoizedProps=a.pendingProps;null===b?Zj(a):Y=b;pj.current=null}\nfunction Zj(a){var b=a;do{var c=b.alternate;a=b.return;if(0===(b.flags&2048)){c=Gi(c,b,qj);if(null!==c){Y=c;return}c=b;if(24!==c.tag&&23!==c.tag||null===c.memoizedState||0!==(qj&1073741824)||0===(c.mode&4)){for(var d=0,e=c.child;null!==e;)d|=e.lanes|e.childLanes,e=e.sibling;c.childLanes=d}null!==a&&0===(a.flags&2048)&&(null===a.firstEffect&&(a.firstEffect=b.firstEffect),null!==b.lastEffect&&(null!==a.lastEffect&&(a.lastEffect.nextEffect=b.firstEffect),a.lastEffect=b.lastEffect),1<b.flags&&(null!==\na.lastEffect?a.lastEffect.nextEffect=b:a.firstEffect=b,a.lastEffect=b))}else{c=Li(b);if(null!==c){c.flags&=2047;Y=c;return}null!==a&&(a.firstEffect=a.lastEffect=null,a.flags|=2048)}b=b.sibling;if(null!==b){Y=b;return}Y=b=a}while(null!==b);0===V&&(V=5)}function Uj(a){var b=eg();gg(99,dk.bind(null,a,b));return null}\nfunction dk(a,b){do Oj();while(null!==yj);if(0!==(X&48))throw Error(y(327));var c=a.finishedWork;if(null===c)return null;a.finishedWork=null;a.finishedLanes=0;if(c===a.current)throw Error(y(177));a.callbackNode=null;var d=c.lanes|c.childLanes,e=d,f=a.pendingLanes&~e;a.pendingLanes=e;a.suspendedLanes=0;a.pingedLanes=0;a.expiredLanes&=e;a.mutableReadLanes&=e;a.entangledLanes&=e;e=a.entanglements;for(var g=a.eventTimes,h=a.expirationTimes;0<f;){var k=31-Vc(f),l=1<<k;e[k]=0;g[k]=-1;h[k]=-1;f&=~l}null!==\nCj&&0===(d&24)&&Cj.has(a)&&Cj.delete(a);a===U&&(Y=U=null,W=0);1<c.flags?null!==c.lastEffect?(c.lastEffect.nextEffect=c,d=c.firstEffect):d=c:d=c.firstEffect;if(null!==d){e=X;X|=32;pj.current=null;kf=fd;g=Ne();if(Oe(g)){if("selectionStart"in g)h={start:g.selectionStart,end:g.selectionEnd};else a:if(h=(h=g.ownerDocument)&&h.defaultView||window,(l=h.getSelection&&h.getSelection())&&0!==l.rangeCount){h=l.anchorNode;f=l.anchorOffset;k=l.focusNode;l=l.focusOffset;try{h.nodeType,k.nodeType}catch(va){h=null;\nbreak a}var n=0,A=-1,p=-1,C=0,x=0,w=g,z=null;b:for(;;){for(var u;;){w!==h||0!==f&&3!==w.nodeType||(A=n+f);w!==k||0!==l&&3!==w.nodeType||(p=n+l);3===w.nodeType&&(n+=w.nodeValue.length);if(null===(u=w.firstChild))break;z=w;w=u}for(;;){if(w===g)break b;z===h&&++C===f&&(A=n);z===k&&++x===l&&(p=n);if(null!==(u=w.nextSibling))break;w=z;z=w.parentNode}w=u}h=-1===A||-1===p?null:{start:A,end:p}}else h=null;h=h||{start:0,end:0}}else h=null;lf={focusedElem:g,selectionRange:h};fd=!1;Ij=null;Jj=!1;Z=d;do try{ek()}catch(va){if(null===\nZ)throw Error(y(330));Wi(Z,va);Z=Z.nextEffect}while(null!==Z);Ij=null;Z=d;do try{for(g=a;null!==Z;){var t=Z.flags;t&16&&pb(Z.stateNode,"");if(t&128){var q=Z.alternate;if(null!==q){var v=q.ref;null!==v&&("function"===typeof v?v(null):v.current=null)}}switch(t&1038){case 2:fj(Z);Z.flags&=-3;break;case 6:fj(Z);Z.flags&=-3;ij(Z.alternate,Z);break;case 1024:Z.flags&=-1025;break;case 1028:Z.flags&=-1025;ij(Z.alternate,Z);break;case 4:ij(Z.alternate,Z);break;case 8:h=Z;cj(g,h);var J=h.alternate;dj(h);null!==\nJ&&dj(J)}Z=Z.nextEffect}}catch(va){if(null===Z)throw Error(y(330));Wi(Z,va);Z=Z.nextEffect}while(null!==Z);v=lf;q=Ne();t=v.focusedElem;g=v.selectionRange;if(q!==t&&t&&t.ownerDocument&&Me(t.ownerDocument.documentElement,t)){null!==g&&Oe(t)&&(q=g.start,v=g.end,void 0===v&&(v=q),"selectionStart"in t?(t.selectionStart=q,t.selectionEnd=Math.min(v,t.value.length)):(v=(q=t.ownerDocument||document)&&q.defaultView||window,v.getSelection&&(v=v.getSelection(),h=t.textContent.length,J=Math.min(g.start,h),g=void 0===\ng.end?J:Math.min(g.end,h),!v.extend&&J>g&&(h=g,g=J,J=h),h=Le(t,J),f=Le(t,g),h&&f&&(1!==v.rangeCount||v.anchorNode!==h.node||v.anchorOffset!==h.offset||v.focusNode!==f.node||v.focusOffset!==f.offset)&&(q=q.createRange(),q.setStart(h.node,h.offset),v.removeAllRanges(),J>g?(v.addRange(q),v.extend(f.node,f.offset)):(q.setEnd(f.node,f.offset),v.addRange(q))))));q=[];for(v=t;v=v.parentNode;)1===v.nodeType&&q.push({element:v,left:v.scrollLeft,top:v.scrollTop});"function"===typeof t.focus&&t.focus();for(t=\n0;t<q.length;t++)v=q[t],v.element.scrollLeft=v.left,v.element.scrollTop=v.top}fd=!!kf;lf=kf=null;a.current=c;Z=d;do try{for(t=a;null!==Z;){var K=Z.flags;K&36&&Yi(t,Z.alternate,Z);if(K&128){q=void 0;var Q=Z.ref;if(null!==Q){var L=Z.stateNode;switch(Z.tag){case 5:q=L;break;default:q=L}"function"===typeof Q?Q(q):Q.current=q}}Z=Z.nextEffect}}catch(va){if(null===Z)throw Error(y(330));Wi(Z,va);Z=Z.nextEffect}while(null!==Z);Z=null;$f();X=e}else a.current=c;if(xj)xj=!1,yj=a,zj=b;else for(Z=d;null!==Z;)b=\nZ.nextEffect,Z.nextEffect=null,Z.flags&8&&(K=Z,K.sibling=null,K.stateNode=null),Z=b;d=a.pendingLanes;0===d&&(Ti=null);1===d?a===Ej?Dj++:(Dj=0,Ej=a):Dj=0;c=c.stateNode;if(Mf&&"function"===typeof Mf.onCommitFiberRoot)try{Mf.onCommitFiberRoot(Lf,c,void 0,64===(c.current.flags&64))}catch(va){}Mj(a,O());if(Qi)throw Qi=!1,a=Ri,Ri=null,a;if(0!==(X&8))return null;ig();return null}\nfunction ek(){for(;null!==Z;){var a=Z.alternate;Jj||null===Ij||(0!==(Z.flags&8)?dc(Z,Ij)&&(Jj=!0):13===Z.tag&&mj(a,Z)&&dc(Z,Ij)&&(Jj=!0));var b=Z.flags;0!==(b&256)&&Xi(a,Z);0===(b&512)||xj||(xj=!0,hg(97,function(){Oj();return null}));Z=Z.nextEffect}}function Oj(){if(90!==zj){var a=97<zj?97:zj;zj=90;return gg(a,fk)}return!1}function $i(a,b){Aj.push(b,a);xj||(xj=!0,hg(97,function(){Oj();return null}))}function Zi(a,b){Bj.push(b,a);xj||(xj=!0,hg(97,function(){Oj();return null}))}\nfunction fk(){if(null===yj)return!1;var a=yj;yj=null;if(0!==(X&48))throw Error(y(331));var b=X;X|=32;var c=Bj;Bj=[];for(var d=0;d<c.length;d+=2){var e=c[d],f=c[d+1],g=e.destroy;e.destroy=void 0;if("function"===typeof g)try{g()}catch(k){if(null===f)throw Error(y(330));Wi(f,k)}}c=Aj;Aj=[];for(d=0;d<c.length;d+=2){e=c[d];f=c[d+1];try{var h=e.create;e.destroy=h()}catch(k){if(null===f)throw Error(y(330));Wi(f,k)}}for(h=a.current.firstEffect;null!==h;)a=h.nextEffect,h.nextEffect=null,h.flags&8&&(h.sibling=\nnull,h.stateNode=null),h=a;X=b;ig();return!0}function gk(a,b,c){b=Mi(c,b);b=Pi(a,b,1);Ag(a,b);b=Hg();a=Kj(a,1);null!==a&&($c(a,1,b),Mj(a,b))}\nfunction Wi(a,b){if(3===a.tag)gk(a,a,b);else for(var c=a.return;null!==c;){if(3===c.tag){gk(c,a,b);break}else if(1===c.tag){var d=c.stateNode;if("function"===typeof c.type.getDerivedStateFromError||"function"===typeof d.componentDidCatch&&(null===Ti||!Ti.has(d))){a=Mi(b,a);var e=Si(c,a,1);Ag(c,e);e=Hg();c=Kj(c,1);if(null!==c)$c(c,1,e),Mj(c,e);else if("function"===typeof d.componentDidCatch&&(null===Ti||!Ti.has(d)))try{d.componentDidCatch(b,a)}catch(f){}break}}c=c.return}}\nfunction Yj(a,b,c){var d=a.pingCache;null!==d&&d.delete(b);b=Hg();a.pingedLanes|=a.suspendedLanes&c;U===a&&(W&c)===c&&(4===V||3===V&&(W&62914560)===W&&500>O()-jj?Qj(a,0):uj|=c);Mj(a,b)}function lj(a,b){var c=a.stateNode;null!==c&&c.delete(b);b=0;0===b&&(b=a.mode,0===(b&2)?b=1:0===(b&4)?b=99===eg()?1:2:(0===Gj&&(Gj=tj),b=Yc(62914560&~Gj),0===b&&(b=4194304)));c=Hg();a=Kj(a,b);null!==a&&($c(a,b,c),Mj(a,c))}var ck;\nck=function(a,b,c){var d=b.lanes;if(null!==a)if(a.memoizedProps!==b.pendingProps||N.current)ug=!0;else if(0!==(c&d))ug=0!==(a.flags&16384)?!0:!1;else{ug=!1;switch(b.tag){case 3:ri(b);sh();break;case 5:gh(b);break;case 1:Ff(b.type)&&Jf(b);break;case 4:eh(b,b.stateNode.containerInfo);break;case 10:d=b.memoizedProps.value;var e=b.type._context;I(mg,e._currentValue);e._currentValue=d;break;case 13:if(null!==b.memoizedState){if(0!==(c&b.child.childLanes))return ti(a,b,c);I(P,P.current&1);b=hi(a,b,c);return null!==\nb?b.sibling:null}I(P,P.current&1);break;case 19:d=0!==(c&b.childLanes);if(0!==(a.flags&64)){if(d)return Ai(a,b,c);b.flags|=64}e=b.memoizedState;null!==e&&(e.rendering=null,e.tail=null,e.lastEffect=null);I(P,P.current);if(d)break;else return null;case 23:case 24:return b.lanes=0,mi(a,b,c)}return hi(a,b,c)}else ug=!1;b.lanes=0;switch(b.tag){case 2:d=b.type;null!==a&&(a.alternate=null,b.alternate=null,b.flags|=2);a=b.pendingProps;e=Ef(b,M.current);tg(b,c);e=Ch(null,b,d,a,e,c);b.flags|=1;if("object"===\ntypeof e&&null!==e&&"function"===typeof e.render&&void 0===e.$$typeof){b.tag=1;b.memoizedState=null;b.updateQueue=null;if(Ff(d)){var f=!0;Jf(b)}else f=!1;b.memoizedState=null!==e.state&&void 0!==e.state?e.state:null;xg(b);var g=d.getDerivedStateFromProps;"function"===typeof g&&Gg(b,d,g,a);e.updater=Kg;b.stateNode=e;e._reactInternals=b;Og(b,d,a,c);b=qi(null,b,d,!0,f,c)}else b.tag=0,fi(null,b,e,c),b=b.child;return b;case 16:e=b.elementType;a:{null!==a&&(a.alternate=null,b.alternate=null,b.flags|=2);\na=b.pendingProps;f=e._init;e=f(e._payload);b.type=e;f=b.tag=hk(e);a=lg(e,a);switch(f){case 0:b=li(null,b,e,a,c);break a;case 1:b=pi(null,b,e,a,c);break a;case 11:b=gi(null,b,e,a,c);break a;case 14:b=ii(null,b,e,lg(e.type,a),d,c);break a}throw Error(y(306,e,""));}return b;case 0:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:lg(d,e),li(a,b,d,e,c);case 1:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:lg(d,e),pi(a,b,d,e,c);case 3:ri(b);d=b.updateQueue;if(null===a||null===d)throw Error(y(282));\nd=b.pendingProps;e=b.memoizedState;e=null!==e?e.element:null;yg(a,b);Cg(b,d,null,c);d=b.memoizedState.element;if(d===e)sh(),b=hi(a,b,c);else{e=b.stateNode;if(f=e.hydrate)kh=rf(b.stateNode.containerInfo.firstChild),jh=b,f=lh=!0;if(f){a=e.mutableSourceEagerHydrationData;if(null!=a)for(e=0;e<a.length;e+=2)f=a[e],f._workInProgressVersionPrimary=a[e+1],th.push(f);c=Zg(b,null,d,c);for(b.child=c;c;)c.flags=c.flags&-3|1024,c=c.sibling}else fi(a,b,d,c),sh();b=b.child}return b;case 5:return gh(b),null===a&&\nph(b),d=b.type,e=b.pendingProps,f=null!==a?a.memoizedProps:null,g=e.children,nf(d,e)?g=null:null!==f&&nf(d,f)&&(b.flags|=16),oi(a,b),fi(a,b,g,c),b.child;case 6:return null===a&&ph(b),null;case 13:return ti(a,b,c);case 4:return eh(b,b.stateNode.containerInfo),d=b.pendingProps,null===a?b.child=Yg(b,null,d,c):fi(a,b,d,c),b.child;case 11:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:lg(d,e),gi(a,b,d,e,c);case 7:return fi(a,b,b.pendingProps,c),b.child;case 8:return fi(a,b,b.pendingProps.children,\nc),b.child;case 12:return fi(a,b,b.pendingProps.children,c),b.child;case 10:a:{d=b.type._context;e=b.pendingProps;g=b.memoizedProps;f=e.value;var h=b.type._context;I(mg,h._currentValue);h._currentValue=f;if(null!==g)if(h=g.value,f=He(h,f)?0:("function"===typeof d._calculateChangedBits?d._calculateChangedBits(h,f):1073741823)|0,0===f){if(g.children===e.children&&!N.current){b=hi(a,b,c);break a}}else for(h=b.child,null!==h&&(h.return=b);null!==h;){var k=h.dependencies;if(null!==k){g=h.child;for(var l=\nk.firstContext;null!==l;){if(l.context===d&&0!==(l.observedBits&f)){1===h.tag&&(l=zg(-1,c&-c),l.tag=2,Ag(h,l));h.lanes|=c;l=h.alternate;null!==l&&(l.lanes|=c);sg(h.return,c);k.lanes|=c;break}l=l.next}}else g=10===h.tag?h.type===b.type?null:h.child:h.child;if(null!==g)g.return=h;else for(g=h;null!==g;){if(g===b){g=null;break}h=g.sibling;if(null!==h){h.return=g.return;g=h;break}g=g.return}h=g}fi(a,b,e.children,c);b=b.child}return b;case 9:return e=b.type,f=b.pendingProps,d=f.children,tg(b,c),e=vg(e,\nf.unstable_observedBits),d=d(e),b.flags|=1,fi(a,b,d,c),b.child;case 14:return e=b.type,f=lg(e,b.pendingProps),f=lg(e.type,f),ii(a,b,e,f,d,c);case 15:return ki(a,b,b.type,b.pendingProps,d,c);case 17:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:lg(d,e),null!==a&&(a.alternate=null,b.alternate=null,b.flags|=2),b.tag=1,Ff(d)?(a=!0,Jf(b)):a=!1,tg(b,c),Mg(b,d,e),Og(b,d,e,c),qi(null,b,d,!0,a,c);case 19:return Ai(a,b,c);case 23:return mi(a,b,c);case 24:return mi(a,b,c)}throw Error(y(156,b.tag));\n};function ik(a,b,c,d){this.tag=a;this.key=c;this.sibling=this.child=this.return=this.stateNode=this.type=this.elementType=null;this.index=0;this.ref=null;this.pendingProps=b;this.dependencies=this.memoizedState=this.updateQueue=this.memoizedProps=null;this.mode=d;this.flags=0;this.lastEffect=this.firstEffect=this.nextEffect=null;this.childLanes=this.lanes=0;this.alternate=null}function nh(a,b,c,d){return new ik(a,b,c,d)}function ji(a){a=a.prototype;return!(!a||!a.isReactComponent)}\nfunction hk(a){if("function"===typeof a)return ji(a)?1:0;if(void 0!==a&&null!==a){a=a.$$typeof;if(a===Aa)return 11;if(a===Da)return 14}return 2}\nfunction Tg(a,b){var c=a.alternate;null===c?(c=nh(a.tag,b,a.key,a.mode),c.elementType=a.elementType,c.type=a.type,c.stateNode=a.stateNode,c.alternate=a,a.alternate=c):(c.pendingProps=b,c.type=a.type,c.flags=0,c.nextEffect=null,c.firstEffect=null,c.lastEffect=null);c.childLanes=a.childLanes;c.lanes=a.lanes;c.child=a.child;c.memoizedProps=a.memoizedProps;c.memoizedState=a.memoizedState;c.updateQueue=a.updateQueue;b=a.dependencies;c.dependencies=null===b?null:{lanes:b.lanes,firstContext:b.firstContext};\nc.sibling=a.sibling;c.index=a.index;c.ref=a.ref;return c}\nfunction Vg(a,b,c,d,e,f){var g=2;d=a;if("function"===typeof a)ji(a)&&(g=1);else if("string"===typeof a)g=5;else a:switch(a){case ua:return Xg(c.children,e,f,b);case Ha:g=8;e|=16;break;case wa:g=8;e|=1;break;case xa:return a=nh(12,c,b,e|8),a.elementType=xa,a.type=xa,a.lanes=f,a;case Ba:return a=nh(13,c,b,e),a.type=Ba,a.elementType=Ba,a.lanes=f,a;case Ca:return a=nh(19,c,b,e),a.elementType=Ca,a.lanes=f,a;case Ia:return vi(c,e,f,b);case Ja:return a=nh(24,c,b,e),a.elementType=Ja,a.lanes=f,a;default:if("object"===\ntypeof a&&null!==a)switch(a.$$typeof){case ya:g=10;break a;case za:g=9;break a;case Aa:g=11;break a;case Da:g=14;break a;case Ea:g=16;d=null;break a;case Fa:g=22;break a}throw Error(y(130,null==a?a:typeof a,""));}b=nh(g,c,b,e);b.elementType=a;b.type=d;b.lanes=f;return b}function Xg(a,b,c,d){a=nh(7,a,d,b);a.lanes=c;return a}function vi(a,b,c,d){a=nh(23,a,d,b);a.elementType=Ia;a.lanes=c;return a}function Ug(a,b,c){a=nh(6,a,null,b);a.lanes=c;return a}\nfunction Wg(a,b,c){b=nh(4,null!==a.children?a.children:[],a.key,b);b.lanes=c;b.stateNode={containerInfo:a.containerInfo,pendingChildren:null,implementation:a.implementation};return b}\nfunction jk(a,b,c){this.tag=b;this.containerInfo=a;this.finishedWork=this.pingCache=this.current=this.pendingChildren=null;this.timeoutHandle=-1;this.pendingContext=this.context=null;this.hydrate=c;this.callbackNode=null;this.callbackPriority=0;this.eventTimes=Zc(0);this.expirationTimes=Zc(-1);this.entangledLanes=this.finishedLanes=this.mutableReadLanes=this.expiredLanes=this.pingedLanes=this.suspendedLanes=this.pendingLanes=0;this.entanglements=Zc(0);this.mutableSourceEagerHydrationData=null}\nfunction kk(a,b,c){var d=3<arguments.length&&void 0!==arguments[3]?arguments[3]:null;return{$$typeof:ta,key:null==d?null:""+d,children:a,containerInfo:b,implementation:c}}\nfunction lk(a,b,c,d){var e=b.current,f=Hg(),g=Ig(e);a:if(c){c=c._reactInternals;b:{if(Zb(c)!==c||1!==c.tag)throw Error(y(170));var h=c;do{switch(h.tag){case 3:h=h.stateNode.context;break b;case 1:if(Ff(h.type)){h=h.stateNode.__reactInternalMemoizedMergedChildContext;break b}}h=h.return}while(null!==h);throw Error(y(171));}if(1===c.tag){var k=c.type;if(Ff(k)){c=If(c,k,h);break a}}c=h}else c=Cf;null===b.context?b.context=c:b.pendingContext=c;b=zg(f,g);b.payload={element:a};d=void 0===d?null:d;null!==\nd&&(b.callback=d);Ag(e,b);Jg(e,g,f);return g}function mk(a){a=a.current;if(!a.child)return null;switch(a.child.tag){case 5:return a.child.stateNode;default:return a.child.stateNode}}function nk(a,b){a=a.memoizedState;if(null!==a&&null!==a.dehydrated){var c=a.retryLane;a.retryLane=0!==c&&c<b?c:b}}function ok(a,b){nk(a,b);(a=a.alternate)&&nk(a,b)}function pk(){return null}\nfunction qk(a,b,c){var d=null!=c&&null!=c.hydrationOptions&&c.hydrationOptions.mutableSources||null;c=new jk(a,b,null!=c&&!0===c.hydrate);b=nh(3,null,null,2===b?7:1===b?3:0);c.current=b;b.stateNode=c;xg(b);a[ff]=c.current;cf(8===a.nodeType?a.parentNode:a);if(d)for(a=0;a<d.length;a++){b=d[a];var e=b._getVersion;e=e(b._source);null==c.mutableSourceEagerHydrationData?c.mutableSourceEagerHydrationData=[b,e]:c.mutableSourceEagerHydrationData.push(b,e)}this._internalRoot=c}\nqk.prototype.render=function(a){lk(a,this._internalRoot,null,null)};qk.prototype.unmount=function(){var a=this._internalRoot,b=a.containerInfo;lk(null,a,null,function(){b[ff]=null})};function rk(a){return!(!a||1!==a.nodeType&&9!==a.nodeType&&11!==a.nodeType&&(8!==a.nodeType||" react-mount-point-unstable "!==a.nodeValue))}\nfunction sk(a,b){b||(b=a?9===a.nodeType?a.documentElement:a.firstChild:null,b=!(!b||1!==b.nodeType||!b.hasAttribute("data-reactroot")));if(!b)for(var c;c=a.lastChild;)a.removeChild(c);return new qk(a,0,b?{hydrate:!0}:void 0)}\nfunction tk(a,b,c,d,e){var f=c._reactRootContainer;if(f){var g=f._internalRoot;if("function"===typeof e){var h=e;e=function(){var a=mk(g);h.call(a)}}lk(b,g,a,e)}else{f=c._reactRootContainer=sk(c,d);g=f._internalRoot;if("function"===typeof e){var k=e;e=function(){var a=mk(g);k.call(a)}}Xj(function(){lk(b,g,a,e)})}return mk(g)}ec=function(a){if(13===a.tag){var b=Hg();Jg(a,4,b);ok(a,4)}};fc=function(a){if(13===a.tag){var b=Hg();Jg(a,67108864,b);ok(a,67108864)}};\ngc=function(a){if(13===a.tag){var b=Hg(),c=Ig(a);Jg(a,c,b);ok(a,c)}};hc=function(a,b){return b()};\nyb=function(a,b,c){switch(b){case "input":ab(a,c);b=c.name;if("radio"===c.type&&null!=b){for(c=a;c.parentNode;)c=c.parentNode;c=c.querySelectorAll("input[name="+JSON.stringify(""+b)+\'][type="radio"]\');for(b=0;b<c.length;b++){var d=c[b];if(d!==a&&d.form===a.form){var e=Db(d);if(!e)throw Error(y(90));Wa(d);ab(d,e)}}}break;case "textarea":ib(a,c);break;case "select":b=c.value,null!=b&&fb(a,!!c.multiple,b,!1)}};Gb=Wj;\nHb=function(a,b,c,d,e){var f=X;X|=4;try{return gg(98,a.bind(null,b,c,d,e))}finally{X=f,0===X&&(wj(),ig())}};Ib=function(){0===(X&49)&&(Vj(),Oj())};Jb=function(a,b){var c=X;X|=2;try{return a(b)}finally{X=c,0===X&&(wj(),ig())}};function uk(a,b){var c=2<arguments.length&&void 0!==arguments[2]?arguments[2]:null;if(!rk(b))throw Error(y(200));return kk(a,b,null,c)}var vk={Events:[Cb,ue,Db,Eb,Fb,Oj,{current:!1}]},wk={findFiberByHostInstance:wc,bundleType:0,version:"17.0.2",rendererPackageName:"react-dom"};\nvar xk={bundleType:wk.bundleType,version:wk.version,rendererPackageName:wk.rendererPackageName,rendererConfig:wk.rendererConfig,overrideHookState:null,overrideHookStateDeletePath:null,overrideHookStateRenamePath:null,overrideProps:null,overridePropsDeletePath:null,overridePropsRenamePath:null,setSuspenseHandler:null,scheduleUpdate:null,currentDispatcherRef:ra.ReactCurrentDispatcher,findHostInstanceByFiber:function(a){a=cc(a);return null===a?null:a.stateNode},findFiberByHostInstance:wk.findFiberByHostInstance||\npk,findHostInstancesForRefresh:null,scheduleRefresh:null,scheduleRoot:null,setRefreshHandler:null,getCurrentFiber:null};if("undefined"!==typeof __REACT_DEVTOOLS_GLOBAL_HOOK__){var yk=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(!yk.isDisabled&&yk.supportsFiber)try{Lf=yk.inject(xk),Mf=yk}catch(a){}}exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=vk;exports.createPortal=uk;\nexports.findDOMNode=function(a){if(null==a)return null;if(1===a.nodeType)return a;var b=a._reactInternals;if(void 0===b){if("function"===typeof a.render)throw Error(y(188));throw Error(y(268,Object.keys(a)));}a=cc(b);a=null===a?null:a.stateNode;return a};exports.flushSync=function(a,b){var c=X;if(0!==(c&48))return a(b);X|=1;try{if(a)return gg(99,a.bind(null,b))}finally{X=c,ig()}};exports.hydrate=function(a,b,c){if(!rk(b))throw Error(y(200));return tk(null,a,b,!0,c)};\nexports.render=function(a,b,c){if(!rk(b))throw Error(y(200));return tk(null,a,b,!1,c)};exports.unmountComponentAtNode=function(a){if(!rk(a))throw Error(y(40));return a._reactRootContainer?(Xj(function(){tk(null,null,a,!1,function(){a._reactRootContainer=null;a[ff]=null})}),!0):!1};exports.unstable_batchedUpdates=Wj;exports.unstable_createPortal=function(a,b){return uk(a,b,2<arguments.length&&void 0!==arguments[2]?arguments[2]:null)};\nexports.unstable_renderSubtreeIntoContainer=function(a,b,c,d){if(!rk(c))throw Error(y(200));if(null==a||void 0===a._reactInternals)throw Error(y(38));return tk(a,b,c,!1,d)};exports.version="17.0.2";\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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cy9yZWFjdC1kb20vY2pzL3JlYWN0LWRvbS5wcm9kdWN0aW9uLm1pbi5qcz9jYTVkIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKiBAbGljZW5zZSBSZWFjdCB2MTcuMC4yXG4gKiByZWFjdC1kb20ucHJvZHVjdGlvbi5taW4uanNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuLypcbiBNb2Rlcm5penIgMy4wLjBwcmUgKEN1c3RvbSBCdWlsZCkgfCBNSVRcbiovXG4ndXNlIHN0cmljdCc7dmFyIGFhPXJlcXVpcmUoXCJyZWFjdFwiKSxtPXJlcXVpcmUoXCJvYmplY3QtYXNzaWduXCIpLHI9cmVxdWlyZShcInNjaGVkdWxlclwiKTtmdW5jdGlvbiB5KGEpe2Zvcih2YXIgYj1cImh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9lcnJvci1kZWNvZGVyLmh0bWw/aW52YXJpYW50PVwiK2EsYz0xO2M8YXJndW1lbnRzLmxlbmd0aDtjKyspYis9XCImYXJnc1tdPVwiK2VuY29kZVVSSUNvbXBvbmVudChhcmd1bWVudHNbY10pO3JldHVyblwiTWluaWZpZWQgUmVhY3QgZXJyb3IgI1wiK2ErXCI7IHZpc2l0IFwiK2IrXCIgZm9yIHRoZSBmdWxsIG1lc3NhZ2Ugb3IgdXNlIHRoZSBub24tbWluaWZpZWQgZGV2IGVudmlyb25tZW50IGZvciBmdWxsIGVycm9ycyBhbmQgYWRkaXRpb25hbCBoZWxwZnVsIHdhcm5pbmdzLlwifWlmKCFhYSl0aHJvdyBFcnJvcih5KDIyNykpO3ZhciBiYT1uZXcgU2V0LGNhPXt9O2Z1bmN0aW9uIGRhKGEsYil7ZWEoYSxiKTtlYShhK1wiQ2FwdHVyZVwiLGIpfVxuZnVuY3Rpb24gZWEoYSxiKXtjYVthXT1iO2ZvcihhPTA7YTxiLmxlbmd0aDthKyspYmEuYWRkKGJbYV0pfVxudmFyIGZhPSEoXCJ1bmRlZmluZWRcIj09PXR5cGVvZiB3aW5kb3d8fFwidW5kZWZpbmVkXCI9PT10eXBlb2Ygd2luZG93LmRvY3VtZW50fHxcInVuZGVmaW5lZFwiPT09dHlwZW9mIHdpbmRvdy5kb2N1bWVudC5jcmVhdGVFbGVtZW50KSxoYT0vXls6QS1aX2EtelxcdTAwQzAtXFx1MDBENlxcdTAwRDgtXFx1MDBGNlxcdTAwRjgtXFx1MDJGRlxcdTAzNzAtXFx1MDM3RFxcdTAzN0YtXFx1MUZGRlxcdTIwMEMtXFx1MjAwRFxcdTIwNzAtXFx1MjE4RlxcdTJDMDAtXFx1MkZFRlxcdTMwMDEtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZGRF1bOkEtWl9hLXpcXHUwMEMwLVxcdTAwRDZcXHUwMEQ4LVxcdTAwRjZcXHUwMEY4LVxcdTAyRkZcXHUwMzcwLVxcdTAzN0RcXHUwMzdGLVxcdTFGRkZcXHUyMDBDLVxcdTIwMERcXHUyMDcwLVxcdTIxOEZcXHUyQzAwLVxcdTJGRUZcXHUzMDAxLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRkRcXC0uMC05XFx1MDBCN1xcdTAzMDAtXFx1MDM2RlxcdTIwM0YtXFx1MjA0MF0qJC8saWE9T2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSxcbmphPXt9LGthPXt9O2Z1bmN0aW9uIGxhKGEpe2lmKGlhLmNhbGwoa2EsYSkpcmV0dXJuITA7aWYoaWEuY2FsbChqYSxhKSlyZXR1cm4hMTtpZihoYS50ZXN0KGEpKXJldHVybiBrYVthXT0hMDtqYVthXT0hMDtyZXR1cm4hMX1mdW5jdGlvbiBtYShhLGIsYyxkKXtpZihudWxsIT09YyYmMD09PWMudHlwZSlyZXR1cm4hMTtzd2l0Y2godHlwZW9mIGIpe2Nhc2UgXCJmdW5jdGlvblwiOmNhc2UgXCJzeW1ib2xcIjpyZXR1cm4hMDtjYXNlIFwiYm9vbGVhblwiOmlmKGQpcmV0dXJuITE7aWYobnVsbCE9PWMpcmV0dXJuIWMuYWNjZXB0c0Jvb2xlYW5zO2E9YS50b0xvd2VyQ2FzZSgpLnNsaWNlKDAsNSk7cmV0dXJuXCJkYXRhLVwiIT09YSYmXCJhcmlhLVwiIT09YTtkZWZhdWx0OnJldHVybiExfX1cbmZ1bmN0aW9uIG5hKGEsYixjLGQpe2lmKG51bGw9PT1ifHxcInVuZGVmaW5lZFwiPT09dHlwZW9mIGJ8fG1hKGEsYixjLGQpKXJldHVybiEwO2lmKGQpcmV0dXJuITE7aWYobnVsbCE9PWMpc3dpdGNoKGMudHlwZSl7Y2FzZSAzOnJldHVybiFiO2Nhc2UgNDpyZXR1cm4hMT09PWI7Y2FzZSA1OnJldHVybiBpc05hTihiKTtjYXNlIDY6cmV0dXJuIGlzTmFOKGIpfHwxPmJ9cmV0dXJuITF9ZnVuY3Rpb24gQihhLGIsYyxkLGUsZixnKXt0aGlzLmFjY2VwdHNCb29sZWFucz0yPT09Ynx8Mz09PWJ8fDQ9PT1iO3RoaXMuYXR0cmlidXRlTmFtZT1kO3RoaXMuYXR0cmlidXRlTmFtZXNwYWNlPWU7dGhpcy5tdXN0VXNlUHJvcGVydHk9Yzt0aGlzLnByb3BlcnR5TmFtZT1hO3RoaXMudHlwZT1iO3RoaXMuc2FuaXRpemVVUkw9Zjt0aGlzLnJlbW92ZUVtcHR5U3RyaW5nPWd9dmFyIEQ9e307XG5cImNoaWxkcmVuIGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MIGRlZmF1bHRWYWx1ZSBkZWZhdWx0Q2hlY2tlZCBpbm5lckhUTUwgc3VwcHJlc3NDb250ZW50RWRpdGFibGVXYXJuaW5nIHN1cHByZXNzSHlkcmF0aW9uV2FybmluZyBzdHlsZVwiLnNwbGl0KFwiIFwiKS5mb3JFYWNoKGZ1bmN0aW9uKGEpe0RbYV09bmV3IEIoYSwwLCExLGEsbnVsbCwhMSwhMSl9KTtbW1wiYWNjZXB0Q2hhcnNldFwiLFwiYWNjZXB0LWNoYXJzZXRcIl0sW1wiY2xhc3NOYW1lXCIsXCJjbGFzc1wiXSxbXCJodG1sRm9yXCIsXCJmb3JcIl0sW1wiaHR0cEVxdWl2XCIsXCJodHRwLWVxdWl2XCJdXS5mb3JFYWNoKGZ1bmN0aW9uKGEpe3ZhciBiPWFbMF07RFtiXT1uZXcgQihiLDEsITEsYVsxXSxudWxsLCExLCExKX0pO1tcImNvbnRlbnRFZGl0YWJsZVwiLFwiZHJhZ2dhYmxlXCIsXCJzcGVsbENoZWNrXCIsXCJ2YWx1ZVwiXS5mb3JFYWNoKGZ1bmN0aW9uKGEpe0RbYV09bmV3IEIoYSwyLCExLGEudG9Mb3dlckNhc2UoKSxudWxsLCExLCExKX0pO1xuW1wiYXV0b1JldmVyc2VcIixcImV4dGVybmFsUmVzb3VyY2VzUmVxdWlyZWRcIixcImZvY3VzYWJsZVwiLFwicHJlc2VydmVBbHBoYVwiXS5mb3JFYWNoKGZ1bmN0aW9uKGEpe0RbYV09bmV3IEIoYSwyLCExLGEsbnVsbCwhMSwhMSl9KTtcImFsbG93RnVsbFNjcmVlbiBhc3luYyBhdXRvRm9jdXMgYXV0b1BsYXkgY29udHJvbHMgZGVmYXVsdCBkZWZlciBkaXNhYmxlZCBkaXNhYmxlUGljdHVyZUluUGljdHVyZSBkaXNhYmxlUmVtb3RlUGxheWJhY2sgZm9ybU5vVmFsaWRhdGUgaGlkZGVuIGxvb3Agbm9Nb2R1bGUgbm9WYWxpZGF0ZSBvcGVuIHBsYXlzSW5saW5lIHJlYWRPbmx5IHJlcXVpcmVkIHJldmVyc2VkIHNjb3BlZCBzZWFtbGVzcyBpdGVtU2NvcGVcIi5zcGxpdChcIiBcIikuZm9yRWFjaChmdW5jdGlvbihhKXtEW2FdPW5ldyBCKGEsMywhMSxhLnRvTG93ZXJDYXNlKCksbnVsbCwhMSwhMSl9KTtcbltcImNoZWNrZWRcIixcIm11bHRpcGxlXCIsXCJtdXRlZFwiLFwic2VsZWN0ZWRcIl0uZm9yRWFjaChmdW5jdGlvbihhKXtEW2FdPW5ldyBCKGEsMywhMCxhLG51bGwsITEsITEpfSk7W1wiY2FwdHVyZVwiLFwiZG93bmxvYWRcIl0uZm9yRWFjaChmdW5jdGlvbihhKXtEW2FdPW5ldyBCKGEsNCwhMSxhLG51bGwsITEsITEpfSk7W1wiY29sc1wiLFwicm93c1wiLFwic2l6ZVwiLFwic3BhblwiXS5mb3JFYWNoKGZ1bmN0aW9uKGEpe0RbYV09bmV3IEIoYSw2LCExLGEsbnVsbCwhMSwhMSl9KTtbXCJyb3dTcGFuXCIsXCJzdGFydFwiXS5mb3JFYWNoKGZ1bmN0aW9uKGEpe0RbYV09bmV3IEIoYSw1LCExLGEudG9Mb3dlckNhc2UoKSxudWxsLCExLCExKX0pO3ZhciBvYT0vW1xcLTpdKFthLXpdKS9nO2Z1bmN0aW9uIHBhKGEpe3JldHVybiBhWzFdLnRvVXBwZXJDYXNlKCl9XG5cImFjY2VudC1oZWlnaHQgYWxpZ25tZW50LWJhc2VsaW5lIGFyYWJpYy1mb3JtIGJhc2VsaW5lLXNoaWZ0IGNhcC1oZWlnaHQgY2xpcC1wYXRoIGNsaXAtcnVsZSBjb2xvci1pbnRlcnBvbGF0aW9uIGNvbG9yLWludGVycG9sYXRpb24tZmlsdGVycyBjb2xvci1wcm9maWxlIGNvbG9yLXJlbmRlcmluZyBkb21pbmFudC1iYXNlbGluZSBlbmFibGUtYmFja2dyb3VuZCBmaWxsLW9wYWNpdHkgZmlsbC1ydWxlIGZsb29kLWNvbG9yIGZsb29kLW9wYWNpdHkgZm9udC1mYW1pbHkgZm9udC1zaXplIGZvbnQtc2l6ZS1hZGp1c3QgZm9udC1zdHJldGNoIGZvbnQtc3R5bGUgZm9udC12YXJpYW50IGZvbnQtd2VpZ2h0IGdseXBoLW5hbWUgZ2x5cGgtb3JpZW50YXRpb24taG9yaXpvbnRhbCBnbHlwaC1vcmllbnRhdGlvbi12ZXJ0aWNhbCBob3Jpei1hZHYteCBob3Jpei1vcmlnaW4teCBpbWFnZS1yZW5kZXJpbmcgbGV0dGVyLXNwYWNpbmcgbGlnaHRpbmctY29sb3IgbWFya2VyLWVuZCBtYXJrZXItbWlkIG1hcmtlci1zdGFydCBvdmVybGluZS1wb3NpdGlvbiBvdmVybGluZS10aGlja25lc3MgcGFpbnQtb3JkZXIgcGFub3NlLTEgcG9pbnRlci1ldmVudHMgcmVuZGVyaW5nLWludGVudCBzaGFwZS1yZW5kZXJpbmcgc3RvcC1jb2xvciBzdG9wLW9wYWNpdHkgc3RyaWtldGhyb3VnaC1wb3NpdGlvbiBzdHJpa2V0aHJvdWdoLXRoaWNrbmVzcyBzdHJva2UtZGFzaGFycmF5IHN0cm9rZS1kYXNob2Zmc2V0IHN0cm9rZS1saW5lY2FwIHN0cm9rZS1saW5lam9pbiBzdHJva2UtbWl0ZXJsaW1pdCBzdHJva2Utb3BhY2l0eSBzdHJva2Utd2lkdGggdGV4dC1hbmNob3IgdGV4dC1kZWNvcmF0aW9uIHRleHQtcmVuZGVyaW5nIHVuZGVybGluZS1wb3NpdGlvbiB1bmRlcmxpbmUtdGhpY2tuZXNzIHVuaWNvZGUtYmlkaSB1bmljb2RlLXJhbmdlIHVuaXRzLXBlci1lbSB2LWFscGhhYmV0aWMgdi1oYW5naW5nIHYtaWRlb2dyYXBoaWMgdi1tYXRoZW1hdGljYWwgdmVjdG9yLWVmZmVjdCB2ZXJ0LWFkdi15IHZlcnQtb3JpZ2luLXggdmVydC1vcmlnaW4teSB3b3JkLXNwYWNpbmcgd3JpdGluZy1tb2RlIHhtbG5zOnhsaW5rIHgtaGVpZ2h0XCIuc3BsaXQoXCIgXCIpLmZvckVhY2goZnVuY3Rpb24oYSl7dmFyIGI9YS5yZXBsYWNlKG9hLFxucGEpO0RbYl09bmV3IEIoYiwxLCExLGEsbnVsbCwhMSwhMSl9KTtcInhsaW5rOmFjdHVhdGUgeGxpbms6YXJjcm9sZSB4bGluazpyb2xlIHhsaW5rOnNob3cgeGxpbms6dGl0bGUgeGxpbms6dHlwZVwiLnNwbGl0KFwiIFwiKS5mb3JFYWNoKGZ1bmN0aW9uKGEpe3ZhciBiPWEucmVwbGFjZShvYSxwYSk7RFtiXT1uZXcgQihiLDEsITEsYSxcImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmtcIiwhMSwhMSl9KTtbXCJ4bWw6YmFzZVwiLFwieG1sOmxhbmdcIixcInhtbDpzcGFjZVwiXS5mb3JFYWNoKGZ1bmN0aW9uKGEpe3ZhciBiPWEucmVwbGFjZShvYSxwYSk7RFtiXT1uZXcgQihiLDEsITEsYSxcImh0dHA6Ly93d3cudzMub3JnL1hNTC8xOTk4L25hbWVzcGFjZVwiLCExLCExKX0pO1tcInRhYkluZGV4XCIsXCJjcm9zc09yaWdpblwiXS5mb3JFYWNoKGZ1bmN0aW9uKGEpe0RbYV09bmV3IEIoYSwxLCExLGEudG9Mb3dlckNhc2UoKSxudWxsLCExLCExKX0pO1xuRC54bGlua0hyZWY9bmV3IEIoXCJ4bGlua0hyZWZcIiwxLCExLFwieGxpbms6aHJlZlwiLFwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGlua1wiLCEwLCExKTtbXCJzcmNcIixcImhyZWZcIixcImFjdGlvblwiLFwiZm9ybUFjdGlvblwiXS5mb3JFYWNoKGZ1bmN0aW9uKGEpe0RbYV09bmV3IEIoYSwxLCExLGEudG9Mb3dlckNhc2UoKSxudWxsLCEwLCEwKX0pO1xuZnVuY3Rpb24gcWEoYSxiLGMsZCl7dmFyIGU9RC5oYXNPd25Qcm9wZXJ0eShiKT9EW2JdOm51bGw7dmFyIGY9bnVsbCE9PWU/MD09PWUudHlwZTpkPyExOiEoMjxiLmxlbmd0aCl8fFwib1wiIT09YlswXSYmXCJPXCIhPT1iWzBdfHxcIm5cIiE9PWJbMV0mJlwiTlwiIT09YlsxXT8hMTohMDtmfHwobmEoYixjLGUsZCkmJihjPW51bGwpLGR8fG51bGw9PT1lP2xhKGIpJiYobnVsbD09PWM/YS5yZW1vdmVBdHRyaWJ1dGUoYik6YS5zZXRBdHRyaWJ1dGUoYixcIlwiK2MpKTplLm11c3RVc2VQcm9wZXJ0eT9hW2UucHJvcGVydHlOYW1lXT1udWxsPT09Yz8zPT09ZS50eXBlPyExOlwiXCI6YzooYj1lLmF0dHJpYnV0ZU5hbWUsZD1lLmF0dHJpYnV0ZU5hbWVzcGFjZSxudWxsPT09Yz9hLnJlbW92ZUF0dHJpYnV0ZShiKTooZT1lLnR5cGUsYz0zPT09ZXx8ND09PWUmJiEwPT09Yz9cIlwiOlwiXCIrYyxkP2Euc2V0QXR0cmlidXRlTlMoZCxiLGMpOmEuc2V0QXR0cmlidXRlKGIsYykpKSl9XG52YXIgcmE9YWEuX19TRUNSRVRfSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfWU9VX1dJTExfQkVfRklSRUQsc2E9NjAxMDMsdGE9NjAxMDYsdWE9NjAxMDcsd2E9NjAxMDgseGE9NjAxMTQseWE9NjAxMDksemE9NjAxMTAsQWE9NjAxMTIsQmE9NjAxMTMsQ2E9NjAxMjAsRGE9NjAxMTUsRWE9NjAxMTYsRmE9NjAxMjEsR2E9NjAxMjgsSGE9NjAxMjksSWE9NjAxMzAsSmE9NjAxMzE7XG5pZihcImZ1bmN0aW9uXCI9PT10eXBlb2YgU3ltYm9sJiZTeW1ib2wuZm9yKXt2YXIgRT1TeW1ib2wuZm9yO3NhPUUoXCJyZWFjdC5lbGVtZW50XCIpO3RhPUUoXCJyZWFjdC5wb3J0YWxcIik7dWE9RShcInJlYWN0LmZyYWdtZW50XCIpO3dhPUUoXCJyZWFjdC5zdHJpY3RfbW9kZVwiKTt4YT1FKFwicmVhY3QucHJvZmlsZXJcIik7eWE9RShcInJlYWN0LnByb3ZpZGVyXCIpO3phPUUoXCJyZWFjdC5jb250ZXh0XCIpO0FhPUUoXCJyZWFjdC5mb3J3YXJkX3JlZlwiKTtCYT1FKFwicmVhY3Quc3VzcGVuc2VcIik7Q2E9RShcInJlYWN0LnN1c3BlbnNlX2xpc3RcIik7RGE9RShcInJlYWN0Lm1lbW9cIik7RWE9RShcInJlYWN0LmxhenlcIik7RmE9RShcInJlYWN0LmJsb2NrXCIpO0UoXCJyZWFjdC5zY29wZVwiKTtHYT1FKFwicmVhY3Qub3BhcXVlLmlkXCIpO0hhPUUoXCJyZWFjdC5kZWJ1Z190cmFjZV9tb2RlXCIpO0lhPUUoXCJyZWFjdC5vZmZzY3JlZW5cIik7SmE9RShcInJlYWN0LmxlZ2FjeV9oaWRkZW5cIil9XG52YXIgS2E9XCJmdW5jdGlvblwiPT09dHlwZW9mIFN5bWJvbCYmU3ltYm9sLml0ZXJhdG9yO2Z1bmN0aW9uIExhKGEpe2lmKG51bGw9PT1hfHxcIm9iamVjdFwiIT09dHlwZW9mIGEpcmV0dXJuIG51bGw7YT1LYSYmYVtLYV18fGFbXCJAQGl0ZXJhdG9yXCJdO3JldHVyblwiZnVuY3Rpb25cIj09PXR5cGVvZiBhP2E6bnVsbH12YXIgTWE7ZnVuY3Rpb24gTmEoYSl7aWYodm9pZCAwPT09TWEpdHJ5e3Rocm93IEVycm9yKCk7fWNhdGNoKGMpe3ZhciBiPWMuc3RhY2sudHJpbSgpLm1hdGNoKC9cXG4oICooYXQgKT8pLyk7TWE9YiYmYlsxXXx8XCJcIn1yZXR1cm5cIlxcblwiK01hK2F9dmFyIE9hPSExO1xuZnVuY3Rpb24gUGEoYSxiKXtpZighYXx8T2EpcmV0dXJuXCJcIjtPYT0hMDt2YXIgYz1FcnJvci5wcmVwYXJlU3RhY2tUcmFjZTtFcnJvci5wcmVwYXJlU3RhY2tUcmFjZT12b2lkIDA7dHJ5e2lmKGIpaWYoYj1mdW5jdGlvbigpe3Rocm93IEVycm9yKCk7fSxPYmplY3QuZGVmaW5lUHJvcGVydHkoYi5wcm90b3R5cGUsXCJwcm9wc1wiLHtzZXQ6ZnVuY3Rpb24oKXt0aHJvdyBFcnJvcigpO319KSxcIm9iamVjdFwiPT09dHlwZW9mIFJlZmxlY3QmJlJlZmxlY3QuY29uc3RydWN0KXt0cnl7UmVmbGVjdC5jb25zdHJ1Y3QoYixbXSl9Y2F0Y2goayl7dmFyIGQ9a31SZWZsZWN0LmNvbnN0cnVjdChhLFtdLGIpfWVsc2V7dHJ5e2IuY2FsbCgpfWNhdGNoKGspe2Q9a31hLmNhbGwoYi5wcm90b3R5cGUpfWVsc2V7dHJ5e3Rocm93IEVycm9yKCk7fWNhdGNoKGspe2Q9a31hKCl9fWNhdGNoKGspe2lmKGsmJmQmJlwic3RyaW5nXCI9PT10eXBlb2Ygay5zdGFjayl7Zm9yKHZhciBlPWsuc3RhY2suc3BsaXQoXCJcXG5cIiksXG5mPWQuc3RhY2suc3BsaXQoXCJcXG5cIiksZz1lLmxlbmd0aC0xLGg9Zi5sZW5ndGgtMTsxPD1nJiYwPD1oJiZlW2ddIT09ZltoXTspaC0tO2Zvcig7MTw9ZyYmMDw9aDtnLS0saC0tKWlmKGVbZ10hPT1mW2hdKXtpZigxIT09Z3x8MSE9PWgpe2RvIGlmKGctLSxoLS0sMD5ofHxlW2ddIT09ZltoXSlyZXR1cm5cIlxcblwiK2VbZ10ucmVwbGFjZShcIiBhdCBuZXcgXCIsXCIgYXQgXCIpO3doaWxlKDE8PWcmJjA8PWgpfWJyZWFrfX19ZmluYWxseXtPYT0hMSxFcnJvci5wcmVwYXJlU3RhY2tUcmFjZT1jfXJldHVybihhPWE/YS5kaXNwbGF5TmFtZXx8YS5uYW1lOlwiXCIpP05hKGEpOlwiXCJ9XG5mdW5jdGlvbiBRYShhKXtzd2l0Y2goYS50YWcpe2Nhc2UgNTpyZXR1cm4gTmEoYS50eXBlKTtjYXNlIDE2OnJldHVybiBOYShcIkxhenlcIik7Y2FzZSAxMzpyZXR1cm4gTmEoXCJTdXNwZW5zZVwiKTtjYXNlIDE5OnJldHVybiBOYShcIlN1c3BlbnNlTGlzdFwiKTtjYXNlIDA6Y2FzZSAyOmNhc2UgMTU6cmV0dXJuIGE9UGEoYS50eXBlLCExKSxhO2Nhc2UgMTE6cmV0dXJuIGE9UGEoYS50eXBlLnJlbmRlciwhMSksYTtjYXNlIDIyOnJldHVybiBhPVBhKGEudHlwZS5fcmVuZGVyLCExKSxhO2Nhc2UgMTpyZXR1cm4gYT1QYShhLnR5cGUsITApLGE7ZGVmYXVsdDpyZXR1cm5cIlwifX1cbmZ1bmN0aW9uIFJhKGEpe2lmKG51bGw9PWEpcmV0dXJuIG51bGw7aWYoXCJmdW5jdGlvblwiPT09dHlwZW9mIGEpcmV0dXJuIGEuZGlzcGxheU5hbWV8fGEubmFtZXx8bnVsbDtpZihcInN0cmluZ1wiPT09dHlwZW9mIGEpcmV0dXJuIGE7c3dpdGNoKGEpe2Nhc2UgdWE6cmV0dXJuXCJGcmFnbWVudFwiO2Nhc2UgdGE6cmV0dXJuXCJQb3J0YWxcIjtjYXNlIHhhOnJldHVyblwiUHJvZmlsZXJcIjtjYXNlIHdhOnJldHVyblwiU3RyaWN0TW9kZVwiO2Nhc2UgQmE6cmV0dXJuXCJTdXNwZW5zZVwiO2Nhc2UgQ2E6cmV0dXJuXCJTdXNwZW5zZUxpc3RcIn1pZihcIm9iamVjdFwiPT09dHlwZW9mIGEpc3dpdGNoKGEuJCR0eXBlb2Ype2Nhc2UgemE6cmV0dXJuKGEuZGlzcGxheU5hbWV8fFwiQ29udGV4dFwiKStcIi5Db25zdW1lclwiO2Nhc2UgeWE6cmV0dXJuKGEuX2NvbnRleHQuZGlzcGxheU5hbWV8fFwiQ29udGV4dFwiKStcIi5Qcm92aWRlclwiO2Nhc2UgQWE6dmFyIGI9YS5yZW5kZXI7Yj1iLmRpc3BsYXlOYW1lfHxiLm5hbWV8fFwiXCI7XG5yZXR1cm4gYS5kaXNwbGF5TmFtZXx8KFwiXCIhPT1iP1wiRm9yd2FyZFJlZihcIitiK1wiKVwiOlwiRm9yd2FyZFJlZlwiKTtjYXNlIERhOnJldHVybiBSYShhLnR5cGUpO2Nhc2UgRmE6cmV0dXJuIFJhKGEuX3JlbmRlcik7Y2FzZSBFYTpiPWEuX3BheWxvYWQ7YT1hLl9pbml0O3RyeXtyZXR1cm4gUmEoYShiKSl9Y2F0Y2goYyl7fX1yZXR1cm4gbnVsbH1mdW5jdGlvbiBTYShhKXtzd2l0Y2godHlwZW9mIGEpe2Nhc2UgXCJib29sZWFuXCI6Y2FzZSBcIm51bWJlclwiOmNhc2UgXCJvYmplY3RcIjpjYXNlIFwic3RyaW5nXCI6Y2FzZSBcInVuZGVmaW5lZFwiOnJldHVybiBhO2RlZmF1bHQ6cmV0dXJuXCJcIn19ZnVuY3Rpb24gVGEoYSl7dmFyIGI9YS50eXBlO3JldHVybihhPWEubm9kZU5hbWUpJiZcImlucHV0XCI9PT1hLnRvTG93ZXJDYXNlKCkmJihcImNoZWNrYm94XCI9PT1ifHxcInJhZGlvXCI9PT1iKX1cbmZ1bmN0aW9uIFVhKGEpe3ZhciBiPVRhKGEpP1wiY2hlY2tlZFwiOlwidmFsdWVcIixjPU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoYS5jb25zdHJ1Y3Rvci5wcm90b3R5cGUsYiksZD1cIlwiK2FbYl07aWYoIWEuaGFzT3duUHJvcGVydHkoYikmJlwidW5kZWZpbmVkXCIhPT10eXBlb2YgYyYmXCJmdW5jdGlvblwiPT09dHlwZW9mIGMuZ2V0JiZcImZ1bmN0aW9uXCI9PT10eXBlb2YgYy5zZXQpe3ZhciBlPWMuZ2V0LGY9Yy5zZXQ7T2JqZWN0LmRlZmluZVByb3BlcnR5KGEsYix7Y29uZmlndXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiBlLmNhbGwodGhpcyl9LHNldDpmdW5jdGlvbihhKXtkPVwiXCIrYTtmLmNhbGwodGhpcyxhKX19KTtPYmplY3QuZGVmaW5lUHJvcGVydHkoYSxiLHtlbnVtZXJhYmxlOmMuZW51bWVyYWJsZX0pO3JldHVybntnZXRWYWx1ZTpmdW5jdGlvbigpe3JldHVybiBkfSxzZXRWYWx1ZTpmdW5jdGlvbihhKXtkPVwiXCIrYX0sc3RvcFRyYWNraW5nOmZ1bmN0aW9uKCl7YS5fdmFsdWVUcmFja2VyPVxubnVsbDtkZWxldGUgYVtiXX19fX1mdW5jdGlvbiBWYShhKXthLl92YWx1ZVRyYWNrZXJ8fChhLl92YWx1ZVRyYWNrZXI9VWEoYSkpfWZ1bmN0aW9uIFdhKGEpe2lmKCFhKXJldHVybiExO3ZhciBiPWEuX3ZhbHVlVHJhY2tlcjtpZighYilyZXR1cm4hMDt2YXIgYz1iLmdldFZhbHVlKCk7dmFyIGQ9XCJcIjthJiYoZD1UYShhKT9hLmNoZWNrZWQ/XCJ0cnVlXCI6XCJmYWxzZVwiOmEudmFsdWUpO2E9ZDtyZXR1cm4gYSE9PWM/KGIuc2V0VmFsdWUoYSksITApOiExfWZ1bmN0aW9uIFhhKGEpe2E9YXx8KFwidW5kZWZpbmVkXCIhPT10eXBlb2YgZG9jdW1lbnQ/ZG9jdW1lbnQ6dm9pZCAwKTtpZihcInVuZGVmaW5lZFwiPT09dHlwZW9mIGEpcmV0dXJuIG51bGw7dHJ5e3JldHVybiBhLmFjdGl2ZUVsZW1lbnR8fGEuYm9keX1jYXRjaChiKXtyZXR1cm4gYS5ib2R5fX1cbmZ1bmN0aW9uIFlhKGEsYil7dmFyIGM9Yi5jaGVja2VkO3JldHVybiBtKHt9LGIse2RlZmF1bHRDaGVja2VkOnZvaWQgMCxkZWZhdWx0VmFsdWU6dm9pZCAwLHZhbHVlOnZvaWQgMCxjaGVja2VkOm51bGwhPWM/YzphLl93cmFwcGVyU3RhdGUuaW5pdGlhbENoZWNrZWR9KX1mdW5jdGlvbiBaYShhLGIpe3ZhciBjPW51bGw9PWIuZGVmYXVsdFZhbHVlP1wiXCI6Yi5kZWZhdWx0VmFsdWUsZD1udWxsIT1iLmNoZWNrZWQ/Yi5jaGVja2VkOmIuZGVmYXVsdENoZWNrZWQ7Yz1TYShudWxsIT1iLnZhbHVlP2IudmFsdWU6Yyk7YS5fd3JhcHBlclN0YXRlPXtpbml0aWFsQ2hlY2tlZDpkLGluaXRpYWxWYWx1ZTpjLGNvbnRyb2xsZWQ6XCJjaGVja2JveFwiPT09Yi50eXBlfHxcInJhZGlvXCI9PT1iLnR5cGU/bnVsbCE9Yi5jaGVja2VkOm51bGwhPWIudmFsdWV9fWZ1bmN0aW9uICRhKGEsYil7Yj1iLmNoZWNrZWQ7bnVsbCE9YiYmcWEoYSxcImNoZWNrZWRcIixiLCExKX1cbmZ1bmN0aW9uIGFiKGEsYil7JGEoYSxiKTt2YXIgYz1TYShiLnZhbHVlKSxkPWIudHlwZTtpZihudWxsIT1jKWlmKFwibnVtYmVyXCI9PT1kKXtpZigwPT09YyYmXCJcIj09PWEudmFsdWV8fGEudmFsdWUhPWMpYS52YWx1ZT1cIlwiK2N9ZWxzZSBhLnZhbHVlIT09XCJcIitjJiYoYS52YWx1ZT1cIlwiK2MpO2Vsc2UgaWYoXCJzdWJtaXRcIj09PWR8fFwicmVzZXRcIj09PWQpe2EucmVtb3ZlQXR0cmlidXRlKFwidmFsdWVcIik7cmV0dXJufWIuaGFzT3duUHJvcGVydHkoXCJ2YWx1ZVwiKT9iYihhLGIudHlwZSxjKTpiLmhhc093blByb3BlcnR5KFwiZGVmYXVsdFZhbHVlXCIpJiZiYihhLGIudHlwZSxTYShiLmRlZmF1bHRWYWx1ZSkpO251bGw9PWIuY2hlY2tlZCYmbnVsbCE9Yi5kZWZhdWx0Q2hlY2tlZCYmKGEuZGVmYXVsdENoZWNrZWQ9ISFiLmRlZmF1bHRDaGVja2VkKX1cbmZ1bmN0aW9uIGNiKGEsYixjKXtpZihiLmhhc093blByb3BlcnR5KFwidmFsdWVcIil8fGIuaGFzT3duUHJvcGVydHkoXCJkZWZhdWx0VmFsdWVcIikpe3ZhciBkPWIudHlwZTtpZighKFwic3VibWl0XCIhPT1kJiZcInJlc2V0XCIhPT1kfHx2b2lkIDAhPT1iLnZhbHVlJiZudWxsIT09Yi52YWx1ZSkpcmV0dXJuO2I9XCJcIithLl93cmFwcGVyU3RhdGUuaW5pdGlhbFZhbHVlO2N8fGI9PT1hLnZhbHVlfHwoYS52YWx1ZT1iKTthLmRlZmF1bHRWYWx1ZT1ifWM9YS5uYW1lO1wiXCIhPT1jJiYoYS5uYW1lPVwiXCIpO2EuZGVmYXVsdENoZWNrZWQ9ISFhLl93cmFwcGVyU3RhdGUuaW5pdGlhbENoZWNrZWQ7XCJcIiE9PWMmJihhLm5hbWU9Yyl9XG5mdW5jdGlvbiBiYihhLGIsYyl7aWYoXCJudW1iZXJcIiE9PWJ8fFhhKGEub3duZXJEb2N1bWVudCkhPT1hKW51bGw9PWM/YS5kZWZhdWx0VmFsdWU9XCJcIithLl93cmFwcGVyU3RhdGUuaW5pdGlhbFZhbHVlOmEuZGVmYXVsdFZhbHVlIT09XCJcIitjJiYoYS5kZWZhdWx0VmFsdWU9XCJcIitjKX1mdW5jdGlvbiBkYihhKXt2YXIgYj1cIlwiO2FhLkNoaWxkcmVuLmZvckVhY2goYSxmdW5jdGlvbihhKXtudWxsIT1hJiYoYis9YSl9KTtyZXR1cm4gYn1mdW5jdGlvbiBlYihhLGIpe2E9bSh7Y2hpbGRyZW46dm9pZCAwfSxiKTtpZihiPWRiKGIuY2hpbGRyZW4pKWEuY2hpbGRyZW49YjtyZXR1cm4gYX1cbmZ1bmN0aW9uIGZiKGEsYixjLGQpe2E9YS5vcHRpb25zO2lmKGIpe2I9e307Zm9yKHZhciBlPTA7ZTxjLmxlbmd0aDtlKyspYltcIiRcIitjW2VdXT0hMDtmb3IoYz0wO2M8YS5sZW5ndGg7YysrKWU9Yi5oYXNPd25Qcm9wZXJ0eShcIiRcIithW2NdLnZhbHVlKSxhW2NdLnNlbGVjdGVkIT09ZSYmKGFbY10uc2VsZWN0ZWQ9ZSksZSYmZCYmKGFbY10uZGVmYXVsdFNlbGVjdGVkPSEwKX1lbHNle2M9XCJcIitTYShjKTtiPW51bGw7Zm9yKGU9MDtlPGEubGVuZ3RoO2UrKyl7aWYoYVtlXS52YWx1ZT09PWMpe2FbZV0uc2VsZWN0ZWQ9ITA7ZCYmKGFbZV0uZGVmYXVsdFNlbGVjdGVkPSEwKTtyZXR1cm59bnVsbCE9PWJ8fGFbZV0uZGlzYWJsZWR8fChiPWFbZV0pfW51bGwhPT1iJiYoYi5zZWxlY3RlZD0hMCl9fVxuZnVuY3Rpb24gZ2IoYSxiKXtpZihudWxsIT1iLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MKXRocm93IEVycm9yKHkoOTEpKTtyZXR1cm4gbSh7fSxiLHt2YWx1ZTp2b2lkIDAsZGVmYXVsdFZhbHVlOnZvaWQgMCxjaGlsZHJlbjpcIlwiK2EuX3dyYXBwZXJTdGF0ZS5pbml0aWFsVmFsdWV9KX1mdW5jdGlvbiBoYihhLGIpe3ZhciBjPWIudmFsdWU7aWYobnVsbD09Yyl7Yz1iLmNoaWxkcmVuO2I9Yi5kZWZhdWx0VmFsdWU7aWYobnVsbCE9Yyl7aWYobnVsbCE9Yil0aHJvdyBFcnJvcih5KDkyKSk7aWYoQXJyYXkuaXNBcnJheShjKSl7aWYoISgxPj1jLmxlbmd0aCkpdGhyb3cgRXJyb3IoeSg5MykpO2M9Y1swXX1iPWN9bnVsbD09YiYmKGI9XCJcIik7Yz1ifWEuX3dyYXBwZXJTdGF0ZT17aW5pdGlhbFZhbHVlOlNhKGMpfX1cbmZ1bmN0aW9uIGliKGEsYil7dmFyIGM9U2EoYi52YWx1ZSksZD1TYShiLmRlZmF1bHRWYWx1ZSk7bnVsbCE9YyYmKGM9XCJcIitjLGMhPT1hLnZhbHVlJiYoYS52YWx1ZT1jKSxudWxsPT1iLmRlZmF1bHRWYWx1ZSYmYS5kZWZhdWx0VmFsdWUhPT1jJiYoYS5kZWZhdWx0VmFsdWU9YykpO251bGwhPWQmJihhLmRlZmF1bHRWYWx1ZT1cIlwiK2QpfWZ1bmN0aW9uIGpiKGEpe3ZhciBiPWEudGV4dENvbnRlbnQ7Yj09PWEuX3dyYXBwZXJTdGF0ZS5pbml0aWFsVmFsdWUmJlwiXCIhPT1iJiZudWxsIT09YiYmKGEudmFsdWU9Yil9dmFyIGtiPXtodG1sOlwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbFwiLG1hdGhtbDpcImh0dHA6Ly93d3cudzMub3JnLzE5OTgvTWF0aC9NYXRoTUxcIixzdmc6XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wifTtcbmZ1bmN0aW9uIGxiKGEpe3N3aXRjaChhKXtjYXNlIFwic3ZnXCI6cmV0dXJuXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiO2Nhc2UgXCJtYXRoXCI6cmV0dXJuXCJodHRwOi8vd3d3LnczLm9yZy8xOTk4L01hdGgvTWF0aE1MXCI7ZGVmYXVsdDpyZXR1cm5cImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWxcIn19ZnVuY3Rpb24gbWIoYSxiKXtyZXR1cm4gbnVsbD09YXx8XCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sXCI9PT1hP2xiKGIpOlwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIj09PWEmJlwiZm9yZWlnbk9iamVjdFwiPT09Yj9cImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWxcIjphfVxudmFyIG5iLG9iPWZ1bmN0aW9uKGEpe3JldHVyblwidW5kZWZpbmVkXCIhPT10eXBlb2YgTVNBcHAmJk1TQXBwLmV4ZWNVbnNhZmVMb2NhbEZ1bmN0aW9uP2Z1bmN0aW9uKGIsYyxkLGUpe01TQXBwLmV4ZWNVbnNhZmVMb2NhbEZ1bmN0aW9uKGZ1bmN0aW9uKCl7cmV0dXJuIGEoYixjLGQsZSl9KX06YX0oZnVuY3Rpb24oYSxiKXtpZihhLm5hbWVzcGFjZVVSSSE9PWtiLnN2Z3x8XCJpbm5lckhUTUxcImluIGEpYS5pbm5lckhUTUw9YjtlbHNle25iPW5ifHxkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO25iLmlubmVySFRNTD1cIjxzdmc+XCIrYi52YWx1ZU9mKCkudG9TdHJpbmcoKStcIjwvc3ZnPlwiO2ZvcihiPW5iLmZpcnN0Q2hpbGQ7YS5maXJzdENoaWxkOylhLnJlbW92ZUNoaWxkKGEuZmlyc3RDaGlsZCk7Zm9yKDtiLmZpcnN0Q2hpbGQ7KWEuYXBwZW5kQ2hpbGQoYi5maXJzdENoaWxkKX19KTtcbmZ1bmN0aW9uIHBiKGEsYil7aWYoYil7dmFyIGM9YS5maXJzdENoaWxkO2lmKGMmJmM9PT1hLmxhc3RDaGlsZCYmMz09PWMubm9kZVR5cGUpe2Mubm9kZVZhbHVlPWI7cmV0dXJufX1hLnRleHRDb250ZW50PWJ9XG52YXIgcWI9e2FuaW1hdGlvbkl0ZXJhdGlvbkNvdW50OiEwLGJvcmRlckltYWdlT3V0c2V0OiEwLGJvcmRlckltYWdlU2xpY2U6ITAsYm9yZGVySW1hZ2VXaWR0aDohMCxib3hGbGV4OiEwLGJveEZsZXhHcm91cDohMCxib3hPcmRpbmFsR3JvdXA6ITAsY29sdW1uQ291bnQ6ITAsY29sdW1uczohMCxmbGV4OiEwLGZsZXhHcm93OiEwLGZsZXhQb3NpdGl2ZTohMCxmbGV4U2hyaW5rOiEwLGZsZXhOZWdhdGl2ZTohMCxmbGV4T3JkZXI6ITAsZ3JpZEFyZWE6ITAsZ3JpZFJvdzohMCxncmlkUm93RW5kOiEwLGdyaWRSb3dTcGFuOiEwLGdyaWRSb3dTdGFydDohMCxncmlkQ29sdW1uOiEwLGdyaWRDb2x1bW5FbmQ6ITAsZ3JpZENvbHVtblNwYW46ITAsZ3JpZENvbHVtblN0YXJ0OiEwLGZvbnRXZWlnaHQ6ITAsbGluZUNsYW1wOiEwLGxpbmVIZWlnaHQ6ITAsb3BhY2l0eTohMCxvcmRlcjohMCxvcnBoYW5zOiEwLHRhYlNpemU6ITAsd2lkb3dzOiEwLHpJbmRleDohMCx6b29tOiEwLGZpbGxPcGFjaXR5OiEwLFxuZmxvb2RPcGFjaXR5OiEwLHN0b3BPcGFjaXR5OiEwLHN0cm9rZURhc2hhcnJheTohMCxzdHJva2VEYXNob2Zmc2V0OiEwLHN0cm9rZU1pdGVybGltaXQ6ITAsc3Ryb2tlT3BhY2l0eTohMCxzdHJva2VXaWR0aDohMH0scmI9W1wiV2Via2l0XCIsXCJtc1wiLFwiTW96XCIsXCJPXCJdO09iamVjdC5rZXlzKHFiKS5mb3JFYWNoKGZ1bmN0aW9uKGEpe3JiLmZvckVhY2goZnVuY3Rpb24oYil7Yj1iK2EuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkrYS5zdWJzdHJpbmcoMSk7cWJbYl09cWJbYV19KX0pO2Z1bmN0aW9uIHNiKGEsYixjKXtyZXR1cm4gbnVsbD09Ynx8XCJib29sZWFuXCI9PT10eXBlb2YgYnx8XCJcIj09PWI/XCJcIjpjfHxcIm51bWJlclwiIT09dHlwZW9mIGJ8fDA9PT1ifHxxYi5oYXNPd25Qcm9wZXJ0eShhKSYmcWJbYV0/KFwiXCIrYikudHJpbSgpOmIrXCJweFwifVxuZnVuY3Rpb24gdGIoYSxiKXthPWEuc3R5bGU7Zm9yKHZhciBjIGluIGIpaWYoYi5oYXNPd25Qcm9wZXJ0eShjKSl7dmFyIGQ9MD09PWMuaW5kZXhPZihcIi0tXCIpLGU9c2IoYyxiW2NdLGQpO1wiZmxvYXRcIj09PWMmJihjPVwiY3NzRmxvYXRcIik7ZD9hLnNldFByb3BlcnR5KGMsZSk6YVtjXT1lfX12YXIgdWI9bSh7bWVudWl0ZW06ITB9LHthcmVhOiEwLGJhc2U6ITAsYnI6ITAsY29sOiEwLGVtYmVkOiEwLGhyOiEwLGltZzohMCxpbnB1dDohMCxrZXlnZW46ITAsbGluazohMCxtZXRhOiEwLHBhcmFtOiEwLHNvdXJjZTohMCx0cmFjazohMCx3YnI6ITB9KTtcbmZ1bmN0aW9uIHZiKGEsYil7aWYoYil7aWYodWJbYV0mJihudWxsIT1iLmNoaWxkcmVufHxudWxsIT1iLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MKSl0aHJvdyBFcnJvcih5KDEzNyxhKSk7aWYobnVsbCE9Yi5kYW5nZXJvdXNseVNldElubmVySFRNTCl7aWYobnVsbCE9Yi5jaGlsZHJlbil0aHJvdyBFcnJvcih5KDYwKSk7aWYoIShcIm9iamVjdFwiPT09dHlwZW9mIGIuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwmJlwiX19odG1sXCJpbiBiLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MKSl0aHJvdyBFcnJvcih5KDYxKSk7fWlmKG51bGwhPWIuc3R5bGUmJlwib2JqZWN0XCIhPT10eXBlb2YgYi5zdHlsZSl0aHJvdyBFcnJvcih5KDYyKSk7fX1cbmZ1bmN0aW9uIHdiKGEsYil7aWYoLTE9PT1hLmluZGV4T2YoXCItXCIpKXJldHVyblwic3RyaW5nXCI9PT10eXBlb2YgYi5pcztzd2l0Y2goYSl7Y2FzZSBcImFubm90YXRpb24teG1sXCI6Y2FzZSBcImNvbG9yLXByb2ZpbGVcIjpjYXNlIFwiZm9udC1mYWNlXCI6Y2FzZSBcImZvbnQtZmFjZS1zcmNcIjpjYXNlIFwiZm9udC1mYWNlLXVyaVwiOmNhc2UgXCJmb250LWZhY2UtZm9ybWF0XCI6Y2FzZSBcImZvbnQtZmFjZS1uYW1lXCI6Y2FzZSBcIm1pc3NpbmctZ2x5cGhcIjpyZXR1cm4hMTtkZWZhdWx0OnJldHVybiEwfX1mdW5jdGlvbiB4YihhKXthPWEudGFyZ2V0fHxhLnNyY0VsZW1lbnR8fHdpbmRvdzthLmNvcnJlc3BvbmRpbmdVc2VFbGVtZW50JiYoYT1hLmNvcnJlc3BvbmRpbmdVc2VFbGVtZW50KTtyZXR1cm4gMz09PWEubm9kZVR5cGU/YS5wYXJlbnROb2RlOmF9dmFyIHliPW51bGwsemI9bnVsbCxBYj1udWxsO1xuZnVuY3Rpb24gQmIoYSl7aWYoYT1DYihhKSl7aWYoXCJmdW5jdGlvblwiIT09dHlwZW9mIHliKXRocm93IEVycm9yKHkoMjgwKSk7dmFyIGI9YS5zdGF0ZU5vZGU7YiYmKGI9RGIoYikseWIoYS5zdGF0ZU5vZGUsYS50eXBlLGIpKX19ZnVuY3Rpb24gRWIoYSl7emI/QWI/QWIucHVzaChhKTpBYj1bYV06emI9YX1mdW5jdGlvbiBGYigpe2lmKHpiKXt2YXIgYT16YixiPUFiO0FiPXpiPW51bGw7QmIoYSk7aWYoYilmb3IoYT0wO2E8Yi5sZW5ndGg7YSsrKUJiKGJbYV0pfX1mdW5jdGlvbiBHYihhLGIpe3JldHVybiBhKGIpfWZ1bmN0aW9uIEhiKGEsYixjLGQsZSl7cmV0dXJuIGEoYixjLGQsZSl9ZnVuY3Rpb24gSWIoKXt9dmFyIEpiPUdiLEtiPSExLExiPSExO2Z1bmN0aW9uIE1iKCl7aWYobnVsbCE9PXpifHxudWxsIT09QWIpSWIoKSxGYigpfVxuZnVuY3Rpb24gTmIoYSxiLGMpe2lmKExiKXJldHVybiBhKGIsYyk7TGI9ITA7dHJ5e3JldHVybiBKYihhLGIsYyl9ZmluYWxseXtMYj0hMSxNYigpfX1cbmZ1bmN0aW9uIE9iKGEsYil7dmFyIGM9YS5zdGF0ZU5vZGU7aWYobnVsbD09PWMpcmV0dXJuIG51bGw7dmFyIGQ9RGIoYyk7aWYobnVsbD09PWQpcmV0dXJuIG51bGw7Yz1kW2JdO2E6c3dpdGNoKGIpe2Nhc2UgXCJvbkNsaWNrXCI6Y2FzZSBcIm9uQ2xpY2tDYXB0dXJlXCI6Y2FzZSBcIm9uRG91YmxlQ2xpY2tcIjpjYXNlIFwib25Eb3VibGVDbGlja0NhcHR1cmVcIjpjYXNlIFwib25Nb3VzZURvd25cIjpjYXNlIFwib25Nb3VzZURvd25DYXB0dXJlXCI6Y2FzZSBcIm9uTW91c2VNb3ZlXCI6Y2FzZSBcIm9uTW91c2VNb3ZlQ2FwdHVyZVwiOmNhc2UgXCJvbk1vdXNlVXBcIjpjYXNlIFwib25Nb3VzZVVwQ2FwdHVyZVwiOmNhc2UgXCJvbk1vdXNlRW50ZXJcIjooZD0hZC5kaXNhYmxlZCl8fChhPWEudHlwZSxkPSEoXCJidXR0b25cIj09PWF8fFwiaW5wdXRcIj09PWF8fFwic2VsZWN0XCI9PT1hfHxcInRleHRhcmVhXCI9PT1hKSk7YT0hZDticmVhayBhO2RlZmF1bHQ6YT0hMX1pZihhKXJldHVybiBudWxsO2lmKGMmJlwiZnVuY3Rpb25cIiE9PVxudHlwZW9mIGMpdGhyb3cgRXJyb3IoeSgyMzEsYix0eXBlb2YgYykpO3JldHVybiBjfXZhciBQYj0hMTtpZihmYSl0cnl7dmFyIFFiPXt9O09iamVjdC5kZWZpbmVQcm9wZXJ0eShRYixcInBhc3NpdmVcIix7Z2V0OmZ1bmN0aW9uKCl7UGI9ITB9fSk7d2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJ0ZXN0XCIsUWIsUWIpO3dpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwidGVzdFwiLFFiLFFiKX1jYXRjaChhKXtQYj0hMX1mdW5jdGlvbiBSYihhLGIsYyxkLGUsZixnLGgsayl7dmFyIGw9QXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLDMpO3RyeXtiLmFwcGx5KGMsbCl9Y2F0Y2gobil7dGhpcy5vbkVycm9yKG4pfX12YXIgU2I9ITEsVGI9bnVsbCxVYj0hMSxWYj1udWxsLFdiPXtvbkVycm9yOmZ1bmN0aW9uKGEpe1NiPSEwO1RiPWF9fTtmdW5jdGlvbiBYYihhLGIsYyxkLGUsZixnLGgsayl7U2I9ITE7VGI9bnVsbDtSYi5hcHBseShXYixhcmd1bWVudHMpfVxuZnVuY3Rpb24gWWIoYSxiLGMsZCxlLGYsZyxoLGspe1hiLmFwcGx5KHRoaXMsYXJndW1lbnRzKTtpZihTYil7aWYoU2Ipe3ZhciBsPVRiO1NiPSExO1RiPW51bGx9ZWxzZSB0aHJvdyBFcnJvcih5KDE5OCkpO1VifHwoVWI9ITAsVmI9bCl9fWZ1bmN0aW9uIFpiKGEpe3ZhciBiPWEsYz1hO2lmKGEuYWx0ZXJuYXRlKWZvcig7Yi5yZXR1cm47KWI9Yi5yZXR1cm47ZWxzZXthPWI7ZG8gYj1hLDAhPT0oYi5mbGFncyYxMDI2KSYmKGM9Yi5yZXR1cm4pLGE9Yi5yZXR1cm47d2hpbGUoYSl9cmV0dXJuIDM9PT1iLnRhZz9jOm51bGx9ZnVuY3Rpb24gJGIoYSl7aWYoMTM9PT1hLnRhZyl7dmFyIGI9YS5tZW1vaXplZFN0YXRlO251bGw9PT1iJiYoYT1hLmFsdGVybmF0ZSxudWxsIT09YSYmKGI9YS5tZW1vaXplZFN0YXRlKSk7aWYobnVsbCE9PWIpcmV0dXJuIGIuZGVoeWRyYXRlZH1yZXR1cm4gbnVsbH1mdW5jdGlvbiBhYyhhKXtpZihaYihhKSE9PWEpdGhyb3cgRXJyb3IoeSgxODgpKTt9XG5mdW5jdGlvbiBiYyhhKXt2YXIgYj1hLmFsdGVybmF0ZTtpZighYil7Yj1aYihhKTtpZihudWxsPT09Yil0aHJvdyBFcnJvcih5KDE4OCkpO3JldHVybiBiIT09YT9udWxsOmF9Zm9yKHZhciBjPWEsZD1iOzspe3ZhciBlPWMucmV0dXJuO2lmKG51bGw9PT1lKWJyZWFrO3ZhciBmPWUuYWx0ZXJuYXRlO2lmKG51bGw9PT1mKXtkPWUucmV0dXJuO2lmKG51bGwhPT1kKXtjPWQ7Y29udGludWV9YnJlYWt9aWYoZS5jaGlsZD09PWYuY2hpbGQpe2ZvcihmPWUuY2hpbGQ7Zjspe2lmKGY9PT1jKXJldHVybiBhYyhlKSxhO2lmKGY9PT1kKXJldHVybiBhYyhlKSxiO2Y9Zi5zaWJsaW5nfXRocm93IEVycm9yKHkoMTg4KSk7fWlmKGMucmV0dXJuIT09ZC5yZXR1cm4pYz1lLGQ9ZjtlbHNle2Zvcih2YXIgZz0hMSxoPWUuY2hpbGQ7aDspe2lmKGg9PT1jKXtnPSEwO2M9ZTtkPWY7YnJlYWt9aWYoaD09PWQpe2c9ITA7ZD1lO2M9ZjticmVha31oPWguc2libGluZ31pZighZyl7Zm9yKGg9Zi5jaGlsZDtoOyl7aWYoaD09PVxuYyl7Zz0hMDtjPWY7ZD1lO2JyZWFrfWlmKGg9PT1kKXtnPSEwO2Q9ZjtjPWU7YnJlYWt9aD1oLnNpYmxpbmd9aWYoIWcpdGhyb3cgRXJyb3IoeSgxODkpKTt9fWlmKGMuYWx0ZXJuYXRlIT09ZCl0aHJvdyBFcnJvcih5KDE5MCkpO31pZigzIT09Yy50YWcpdGhyb3cgRXJyb3IoeSgxODgpKTtyZXR1cm4gYy5zdGF0ZU5vZGUuY3VycmVudD09PWM/YTpifWZ1bmN0aW9uIGNjKGEpe2E9YmMoYSk7aWYoIWEpcmV0dXJuIG51bGw7Zm9yKHZhciBiPWE7Oyl7aWYoNT09PWIudGFnfHw2PT09Yi50YWcpcmV0dXJuIGI7aWYoYi5jaGlsZCliLmNoaWxkLnJldHVybj1iLGI9Yi5jaGlsZDtlbHNle2lmKGI9PT1hKWJyZWFrO2Zvcig7IWIuc2libGluZzspe2lmKCFiLnJldHVybnx8Yi5yZXR1cm49PT1hKXJldHVybiBudWxsO2I9Yi5yZXR1cm59Yi5zaWJsaW5nLnJldHVybj1iLnJldHVybjtiPWIuc2libGluZ319cmV0dXJuIG51bGx9XG5mdW5jdGlvbiBkYyhhLGIpe2Zvcih2YXIgYz1hLmFsdGVybmF0ZTtudWxsIT09Yjspe2lmKGI9PT1hfHxiPT09YylyZXR1cm4hMDtiPWIucmV0dXJufXJldHVybiExfXZhciBlYyxmYyxnYyxoYyxpYz0hMSxqYz1bXSxrYz1udWxsLGxjPW51bGwsbWM9bnVsbCxuYz1uZXcgTWFwLG9jPW5ldyBNYXAscGM9W10scWM9XCJtb3VzZWRvd24gbW91c2V1cCB0b3VjaGNhbmNlbCB0b3VjaGVuZCB0b3VjaHN0YXJ0IGF1eGNsaWNrIGRibGNsaWNrIHBvaW50ZXJjYW5jZWwgcG9pbnRlcmRvd24gcG9pbnRlcnVwIGRyYWdlbmQgZHJhZ3N0YXJ0IGRyb3AgY29tcG9zaXRpb25lbmQgY29tcG9zaXRpb25zdGFydCBrZXlkb3duIGtleXByZXNzIGtleXVwIGlucHV0IHRleHRJbnB1dCBjb3B5IGN1dCBwYXN0ZSBjbGljayBjaGFuZ2UgY29udGV4dG1lbnUgcmVzZXQgc3VibWl0XCIuc3BsaXQoXCIgXCIpO1xuZnVuY3Rpb24gcmMoYSxiLGMsZCxlKXtyZXR1cm57YmxvY2tlZE9uOmEsZG9tRXZlbnROYW1lOmIsZXZlbnRTeXN0ZW1GbGFnczpjfDE2LG5hdGl2ZUV2ZW50OmUsdGFyZ2V0Q29udGFpbmVyczpbZF19fWZ1bmN0aW9uIHNjKGEsYil7c3dpdGNoKGEpe2Nhc2UgXCJmb2N1c2luXCI6Y2FzZSBcImZvY3Vzb3V0XCI6a2M9bnVsbDticmVhaztjYXNlIFwiZHJhZ2VudGVyXCI6Y2FzZSBcImRyYWdsZWF2ZVwiOmxjPW51bGw7YnJlYWs7Y2FzZSBcIm1vdXNlb3ZlclwiOmNhc2UgXCJtb3VzZW91dFwiOm1jPW51bGw7YnJlYWs7Y2FzZSBcInBvaW50ZXJvdmVyXCI6Y2FzZSBcInBvaW50ZXJvdXRcIjpuYy5kZWxldGUoYi5wb2ludGVySWQpO2JyZWFrO2Nhc2UgXCJnb3Rwb2ludGVyY2FwdHVyZVwiOmNhc2UgXCJsb3N0cG9pbnRlcmNhcHR1cmVcIjpvYy5kZWxldGUoYi5wb2ludGVySWQpfX1cbmZ1bmN0aW9uIHRjKGEsYixjLGQsZSxmKXtpZihudWxsPT09YXx8YS5uYXRpdmVFdmVudCE9PWYpcmV0dXJuIGE9cmMoYixjLGQsZSxmKSxudWxsIT09YiYmKGI9Q2IoYiksbnVsbCE9PWImJmZjKGIpKSxhO2EuZXZlbnRTeXN0ZW1GbGFnc3w9ZDtiPWEudGFyZ2V0Q29udGFpbmVycztudWxsIT09ZSYmLTE9PT1iLmluZGV4T2YoZSkmJmIucHVzaChlKTtyZXR1cm4gYX1cbmZ1bmN0aW9uIHVjKGEsYixjLGQsZSl7c3dpdGNoKGIpe2Nhc2UgXCJmb2N1c2luXCI6cmV0dXJuIGtjPXRjKGtjLGEsYixjLGQsZSksITA7Y2FzZSBcImRyYWdlbnRlclwiOnJldHVybiBsYz10YyhsYyxhLGIsYyxkLGUpLCEwO2Nhc2UgXCJtb3VzZW92ZXJcIjpyZXR1cm4gbWM9dGMobWMsYSxiLGMsZCxlKSwhMDtjYXNlIFwicG9pbnRlcm92ZXJcIjp2YXIgZj1lLnBvaW50ZXJJZDtuYy5zZXQoZix0YyhuYy5nZXQoZil8fG51bGwsYSxiLGMsZCxlKSk7cmV0dXJuITA7Y2FzZSBcImdvdHBvaW50ZXJjYXB0dXJlXCI6cmV0dXJuIGY9ZS5wb2ludGVySWQsb2Muc2V0KGYsdGMob2MuZ2V0KGYpfHxudWxsLGEsYixjLGQsZSkpLCEwfXJldHVybiExfVxuZnVuY3Rpb24gdmMoYSl7dmFyIGI9d2MoYS50YXJnZXQpO2lmKG51bGwhPT1iKXt2YXIgYz1aYihiKTtpZihudWxsIT09YylpZihiPWMudGFnLDEzPT09Yil7aWYoYj0kYihjKSxudWxsIT09Yil7YS5ibG9ja2VkT249YjtoYyhhLmxhbmVQcmlvcml0eSxmdW5jdGlvbigpe3IudW5zdGFibGVfcnVuV2l0aFByaW9yaXR5KGEucHJpb3JpdHksZnVuY3Rpb24oKXtnYyhjKX0pfSk7cmV0dXJufX1lbHNlIGlmKDM9PT1iJiZjLnN0YXRlTm9kZS5oeWRyYXRlKXthLmJsb2NrZWRPbj0zPT09Yy50YWc/Yy5zdGF0ZU5vZGUuY29udGFpbmVySW5mbzpudWxsO3JldHVybn19YS5ibG9ja2VkT249bnVsbH1cbmZ1bmN0aW9uIHhjKGEpe2lmKG51bGwhPT1hLmJsb2NrZWRPbilyZXR1cm4hMTtmb3IodmFyIGI9YS50YXJnZXRDb250YWluZXJzOzA8Yi5sZW5ndGg7KXt2YXIgYz15YyhhLmRvbUV2ZW50TmFtZSxhLmV2ZW50U3lzdGVtRmxhZ3MsYlswXSxhLm5hdGl2ZUV2ZW50KTtpZihudWxsIT09YylyZXR1cm4gYj1DYihjKSxudWxsIT09YiYmZmMoYiksYS5ibG9ja2VkT249YywhMTtiLnNoaWZ0KCl9cmV0dXJuITB9ZnVuY3Rpb24gemMoYSxiLGMpe3hjKGEpJiZjLmRlbGV0ZShiKX1cbmZ1bmN0aW9uIEFjKCl7Zm9yKGljPSExOzA8amMubGVuZ3RoOyl7dmFyIGE9amNbMF07aWYobnVsbCE9PWEuYmxvY2tlZE9uKXthPUNiKGEuYmxvY2tlZE9uKTtudWxsIT09YSYmZWMoYSk7YnJlYWt9Zm9yKHZhciBiPWEudGFyZ2V0Q29udGFpbmVyczswPGIubGVuZ3RoOyl7dmFyIGM9eWMoYS5kb21FdmVudE5hbWUsYS5ldmVudFN5c3RlbUZsYWdzLGJbMF0sYS5uYXRpdmVFdmVudCk7aWYobnVsbCE9PWMpe2EuYmxvY2tlZE9uPWM7YnJlYWt9Yi5zaGlmdCgpfW51bGw9PT1hLmJsb2NrZWRPbiYmamMuc2hpZnQoKX1udWxsIT09a2MmJnhjKGtjKSYmKGtjPW51bGwpO251bGwhPT1sYyYmeGMobGMpJiYobGM9bnVsbCk7bnVsbCE9PW1jJiZ4YyhtYykmJihtYz1udWxsKTtuYy5mb3JFYWNoKHpjKTtvYy5mb3JFYWNoKHpjKX1cbmZ1bmN0aW9uIEJjKGEsYil7YS5ibG9ja2VkT249PT1iJiYoYS5ibG9ja2VkT249bnVsbCxpY3x8KGljPSEwLHIudW5zdGFibGVfc2NoZWR1bGVDYWxsYmFjayhyLnVuc3RhYmxlX05vcm1hbFByaW9yaXR5LEFjKSkpfVxuZnVuY3Rpb24gQ2MoYSl7ZnVuY3Rpb24gYihiKXtyZXR1cm4gQmMoYixhKX1pZigwPGpjLmxlbmd0aCl7QmMoamNbMF0sYSk7Zm9yKHZhciBjPTE7YzxqYy5sZW5ndGg7YysrKXt2YXIgZD1qY1tjXTtkLmJsb2NrZWRPbj09PWEmJihkLmJsb2NrZWRPbj1udWxsKX19bnVsbCE9PWtjJiZCYyhrYyxhKTtudWxsIT09bGMmJkJjKGxjLGEpO251bGwhPT1tYyYmQmMobWMsYSk7bmMuZm9yRWFjaChiKTtvYy5mb3JFYWNoKGIpO2ZvcihjPTA7YzxwYy5sZW5ndGg7YysrKWQ9cGNbY10sZC5ibG9ja2VkT249PT1hJiYoZC5ibG9ja2VkT249bnVsbCk7Zm9yKDswPHBjLmxlbmd0aCYmKGM9cGNbMF0sbnVsbD09PWMuYmxvY2tlZE9uKTspdmMoYyksbnVsbD09PWMuYmxvY2tlZE9uJiZwYy5zaGlmdCgpfVxuZnVuY3Rpb24gRGMoYSxiKXt2YXIgYz17fTtjW2EudG9Mb3dlckNhc2UoKV09Yi50b0xvd2VyQ2FzZSgpO2NbXCJXZWJraXRcIithXT1cIndlYmtpdFwiK2I7Y1tcIk1velwiK2FdPVwibW96XCIrYjtyZXR1cm4gY312YXIgRWM9e2FuaW1hdGlvbmVuZDpEYyhcIkFuaW1hdGlvblwiLFwiQW5pbWF0aW9uRW5kXCIpLGFuaW1hdGlvbml0ZXJhdGlvbjpEYyhcIkFuaW1hdGlvblwiLFwiQW5pbWF0aW9uSXRlcmF0aW9uXCIpLGFuaW1hdGlvbnN0YXJ0OkRjKFwiQW5pbWF0aW9uXCIsXCJBbmltYXRpb25TdGFydFwiKSx0cmFuc2l0aW9uZW5kOkRjKFwiVHJhbnNpdGlvblwiLFwiVHJhbnNpdGlvbkVuZFwiKX0sRmM9e30sR2M9e307XG5mYSYmKEdjPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIikuc3R5bGUsXCJBbmltYXRpb25FdmVudFwiaW4gd2luZG93fHwoZGVsZXRlIEVjLmFuaW1hdGlvbmVuZC5hbmltYXRpb24sZGVsZXRlIEVjLmFuaW1hdGlvbml0ZXJhdGlvbi5hbmltYXRpb24sZGVsZXRlIEVjLmFuaW1hdGlvbnN0YXJ0LmFuaW1hdGlvbiksXCJUcmFuc2l0aW9uRXZlbnRcImluIHdpbmRvd3x8ZGVsZXRlIEVjLnRyYW5zaXRpb25lbmQudHJhbnNpdGlvbik7ZnVuY3Rpb24gSGMoYSl7aWYoRmNbYV0pcmV0dXJuIEZjW2FdO2lmKCFFY1thXSlyZXR1cm4gYTt2YXIgYj1FY1thXSxjO2ZvcihjIGluIGIpaWYoYi5oYXNPd25Qcm9wZXJ0eShjKSYmYyBpbiBHYylyZXR1cm4gRmNbYV09YltjXTtyZXR1cm4gYX1cbnZhciBJYz1IYyhcImFuaW1hdGlvbmVuZFwiKSxKYz1IYyhcImFuaW1hdGlvbml0ZXJhdGlvblwiKSxLYz1IYyhcImFuaW1hdGlvbnN0YXJ0XCIpLExjPUhjKFwidHJhbnNpdGlvbmVuZFwiKSxNYz1uZXcgTWFwLE5jPW5ldyBNYXAsT2M9W1wiYWJvcnRcIixcImFib3J0XCIsSWMsXCJhbmltYXRpb25FbmRcIixKYyxcImFuaW1hdGlvbkl0ZXJhdGlvblwiLEtjLFwiYW5pbWF0aW9uU3RhcnRcIixcImNhbnBsYXlcIixcImNhblBsYXlcIixcImNhbnBsYXl0aHJvdWdoXCIsXCJjYW5QbGF5VGhyb3VnaFwiLFwiZHVyYXRpb25jaGFuZ2VcIixcImR1cmF0aW9uQ2hhbmdlXCIsXCJlbXB0aWVkXCIsXCJlbXB0aWVkXCIsXCJlbmNyeXB0ZWRcIixcImVuY3J5cHRlZFwiLFwiZW5kZWRcIixcImVuZGVkXCIsXCJlcnJvclwiLFwiZXJyb3JcIixcImdvdHBvaW50ZXJjYXB0dXJlXCIsXCJnb3RQb2ludGVyQ2FwdHVyZVwiLFwibG9hZFwiLFwibG9hZFwiLFwibG9hZGVkZGF0YVwiLFwibG9hZGVkRGF0YVwiLFwibG9hZGVkbWV0YWRhdGFcIixcImxvYWRlZE1ldGFkYXRhXCIsXCJsb2Fkc3RhcnRcIixcImxvYWRTdGFydFwiLFxuXCJsb3N0cG9pbnRlcmNhcHR1cmVcIixcImxvc3RQb2ludGVyQ2FwdHVyZVwiLFwicGxheWluZ1wiLFwicGxheWluZ1wiLFwicHJvZ3Jlc3NcIixcInByb2dyZXNzXCIsXCJzZWVraW5nXCIsXCJzZWVraW5nXCIsXCJzdGFsbGVkXCIsXCJzdGFsbGVkXCIsXCJzdXNwZW5kXCIsXCJzdXNwZW5kXCIsXCJ0aW1ldXBkYXRlXCIsXCJ0aW1lVXBkYXRlXCIsTGMsXCJ0cmFuc2l0aW9uRW5kXCIsXCJ3YWl0aW5nXCIsXCJ3YWl0aW5nXCJdO2Z1bmN0aW9uIFBjKGEsYil7Zm9yKHZhciBjPTA7YzxhLmxlbmd0aDtjKz0yKXt2YXIgZD1hW2NdLGU9YVtjKzFdO2U9XCJvblwiKyhlWzBdLnRvVXBwZXJDYXNlKCkrZS5zbGljZSgxKSk7TmMuc2V0KGQsYik7TWMuc2V0KGQsZSk7ZGEoZSxbZF0pfX12YXIgUWM9ci51bnN0YWJsZV9ub3c7UWMoKTt2YXIgRj04O1xuZnVuY3Rpb24gUmMoYSl7aWYoMCE9PSgxJmEpKXJldHVybiBGPTE1LDE7aWYoMCE9PSgyJmEpKXJldHVybiBGPTE0LDI7aWYoMCE9PSg0JmEpKXJldHVybiBGPTEzLDQ7dmFyIGI9MjQmYTtpZigwIT09YilyZXR1cm4gRj0xMixiO2lmKDAhPT0oYSYzMikpcmV0dXJuIEY9MTEsMzI7Yj0xOTImYTtpZigwIT09YilyZXR1cm4gRj0xMCxiO2lmKDAhPT0oYSYyNTYpKXJldHVybiBGPTksMjU2O2I9MzU4NCZhO2lmKDAhPT1iKXJldHVybiBGPTgsYjtpZigwIT09KGEmNDA5NikpcmV0dXJuIEY9Nyw0MDk2O2I9NDE4NjExMiZhO2lmKDAhPT1iKXJldHVybiBGPTYsYjtiPTYyOTE0NTYwJmE7aWYoMCE9PWIpcmV0dXJuIEY9NSxiO2lmKGEmNjcxMDg4NjQpcmV0dXJuIEY9NCw2NzEwODg2NDtpZigwIT09KGEmMTM0MjE3NzI4KSlyZXR1cm4gRj0zLDEzNDIxNzcyODtiPTgwNTMwNjM2OCZhO2lmKDAhPT1iKXJldHVybiBGPTIsYjtpZigwIT09KDEwNzM3NDE4MjQmYSkpcmV0dXJuIEY9MSwxMDczNzQxODI0O1xuRj04O3JldHVybiBhfWZ1bmN0aW9uIFNjKGEpe3N3aXRjaChhKXtjYXNlIDk5OnJldHVybiAxNTtjYXNlIDk4OnJldHVybiAxMDtjYXNlIDk3OmNhc2UgOTY6cmV0dXJuIDg7Y2FzZSA5NTpyZXR1cm4gMjtkZWZhdWx0OnJldHVybiAwfX1mdW5jdGlvbiBUYyhhKXtzd2l0Y2goYSl7Y2FzZSAxNTpjYXNlIDE0OnJldHVybiA5OTtjYXNlIDEzOmNhc2UgMTI6Y2FzZSAxMTpjYXNlIDEwOnJldHVybiA5ODtjYXNlIDk6Y2FzZSA4OmNhc2UgNzpjYXNlIDY6Y2FzZSA0OmNhc2UgNTpyZXR1cm4gOTc7Y2FzZSAzOmNhc2UgMjpjYXNlIDE6cmV0dXJuIDk1O2Nhc2UgMDpyZXR1cm4gOTA7ZGVmYXVsdDp0aHJvdyBFcnJvcih5KDM1OCxhKSk7fX1cbmZ1bmN0aW9uIFVjKGEsYil7dmFyIGM9YS5wZW5kaW5nTGFuZXM7aWYoMD09PWMpcmV0dXJuIEY9MDt2YXIgZD0wLGU9MCxmPWEuZXhwaXJlZExhbmVzLGc9YS5zdXNwZW5kZWRMYW5lcyxoPWEucGluZ2VkTGFuZXM7aWYoMCE9PWYpZD1mLGU9Rj0xNTtlbHNlIGlmKGY9YyYxMzQyMTc3MjcsMCE9PWYpe3ZhciBrPWYmfmc7MCE9PWs/KGQ9UmMoayksZT1GKTooaCY9ZiwwIT09aCYmKGQ9UmMoaCksZT1GKSl9ZWxzZSBmPWMmfmcsMCE9PWY/KGQ9UmMoZiksZT1GKTowIT09aCYmKGQ9UmMoaCksZT1GKTtpZigwPT09ZClyZXR1cm4gMDtkPTMxLVZjKGQpO2Q9YyYoKDA+ZD8wOjE8PGQpPDwxKS0xO2lmKDAhPT1iJiZiIT09ZCYmMD09PShiJmcpKXtSYyhiKTtpZihlPD1GKXJldHVybiBiO0Y9ZX1iPWEuZW50YW5nbGVkTGFuZXM7aWYoMCE9PWIpZm9yKGE9YS5lbnRhbmdsZW1lbnRzLGImPWQ7MDxiOyljPTMxLVZjKGIpLGU9MTw8YyxkfD1hW2NdLGImPX5lO3JldHVybiBkfVxuZnVuY3Rpb24gV2MoYSl7YT1hLnBlbmRpbmdMYW5lcyYtMTA3Mzc0MTgyNTtyZXR1cm4gMCE9PWE/YTphJjEwNzM3NDE4MjQ/MTA3Mzc0MTgyNDowfWZ1bmN0aW9uIFhjKGEsYil7c3dpdGNoKGEpe2Nhc2UgMTU6cmV0dXJuIDE7Y2FzZSAxNDpyZXR1cm4gMjtjYXNlIDEyOnJldHVybiBhPVljKDI0Jn5iKSwwPT09YT9YYygxMCxiKTphO2Nhc2UgMTA6cmV0dXJuIGE9WWMoMTkyJn5iKSwwPT09YT9YYyg4LGIpOmE7Y2FzZSA4OnJldHVybiBhPVljKDM1ODQmfmIpLDA9PT1hJiYoYT1ZYyg0MTg2MTEyJn5iKSwwPT09YSYmKGE9NTEyKSksYTtjYXNlIDI6cmV0dXJuIGI9WWMoODA1MzA2MzY4Jn5iKSwwPT09YiYmKGI9MjY4NDM1NDU2KSxifXRocm93IEVycm9yKHkoMzU4LGEpKTt9ZnVuY3Rpb24gWWMoYSl7cmV0dXJuIGEmLWF9ZnVuY3Rpb24gWmMoYSl7Zm9yKHZhciBiPVtdLGM9MDszMT5jO2MrKyliLnB1c2goYSk7cmV0dXJuIGJ9XG5mdW5jdGlvbiAkYyhhLGIsYyl7YS5wZW5kaW5nTGFuZXN8PWI7dmFyIGQ9Yi0xO2Euc3VzcGVuZGVkTGFuZXMmPWQ7YS5waW5nZWRMYW5lcyY9ZDthPWEuZXZlbnRUaW1lcztiPTMxLVZjKGIpO2FbYl09Y312YXIgVmM9TWF0aC5jbHozMj9NYXRoLmNsejMyOmFkLGJkPU1hdGgubG9nLGNkPU1hdGguTE4yO2Z1bmN0aW9uIGFkKGEpe3JldHVybiAwPT09YT8zMjozMS0oYmQoYSkvY2R8MCl8MH12YXIgZGQ9ci51bnN0YWJsZV9Vc2VyQmxvY2tpbmdQcmlvcml0eSxlZD1yLnVuc3RhYmxlX3J1bldpdGhQcmlvcml0eSxmZD0hMDtmdW5jdGlvbiBnZChhLGIsYyxkKXtLYnx8SWIoKTt2YXIgZT1oZCxmPUtiO0tiPSEwO3RyeXtIYihlLGEsYixjLGQpfWZpbmFsbHl7KEtiPWYpfHxNYigpfX1mdW5jdGlvbiBpZChhLGIsYyxkKXtlZChkZCxoZC5iaW5kKG51bGwsYSxiLGMsZCkpfVxuZnVuY3Rpb24gaGQoYSxiLGMsZCl7aWYoZmQpe3ZhciBlO2lmKChlPTA9PT0oYiY0KSkmJjA8amMubGVuZ3RoJiYtMTxxYy5pbmRleE9mKGEpKWE9cmMobnVsbCxhLGIsYyxkKSxqYy5wdXNoKGEpO2Vsc2V7dmFyIGY9eWMoYSxiLGMsZCk7aWYobnVsbD09PWYpZSYmc2MoYSxkKTtlbHNle2lmKGUpe2lmKC0xPHFjLmluZGV4T2YoYSkpe2E9cmMoZixhLGIsYyxkKTtqYy5wdXNoKGEpO3JldHVybn1pZih1YyhmLGEsYixjLGQpKXJldHVybjtzYyhhLGQpfWpkKGEsYixkLG51bGwsYyl9fX19XG5mdW5jdGlvbiB5YyhhLGIsYyxkKXt2YXIgZT14YihkKTtlPXdjKGUpO2lmKG51bGwhPT1lKXt2YXIgZj1aYihlKTtpZihudWxsPT09ZillPW51bGw7ZWxzZXt2YXIgZz1mLnRhZztpZigxMz09PWcpe2U9JGIoZik7aWYobnVsbCE9PWUpcmV0dXJuIGU7ZT1udWxsfWVsc2UgaWYoMz09PWcpe2lmKGYuc3RhdGVOb2RlLmh5ZHJhdGUpcmV0dXJuIDM9PT1mLnRhZz9mLnN0YXRlTm9kZS5jb250YWluZXJJbmZvOm51bGw7ZT1udWxsfWVsc2UgZiE9PWUmJihlPW51bGwpfX1qZChhLGIsZCxlLGMpO3JldHVybiBudWxsfXZhciBrZD1udWxsLGxkPW51bGwsbWQ9bnVsbDtcbmZ1bmN0aW9uIG5kKCl7aWYobWQpcmV0dXJuIG1kO3ZhciBhLGI9bGQsYz1iLmxlbmd0aCxkLGU9XCJ2YWx1ZVwiaW4ga2Q/a2QudmFsdWU6a2QudGV4dENvbnRlbnQsZj1lLmxlbmd0aDtmb3IoYT0wO2E8YyYmYlthXT09PWVbYV07YSsrKTt2YXIgZz1jLWE7Zm9yKGQ9MTtkPD1nJiZiW2MtZF09PT1lW2YtZF07ZCsrKTtyZXR1cm4gbWQ9ZS5zbGljZShhLDE8ZD8xLWQ6dm9pZCAwKX1mdW5jdGlvbiBvZChhKXt2YXIgYj1hLmtleUNvZGU7XCJjaGFyQ29kZVwiaW4gYT8oYT1hLmNoYXJDb2RlLDA9PT1hJiYxMz09PWImJihhPTEzKSk6YT1iOzEwPT09YSYmKGE9MTMpO3JldHVybiAzMjw9YXx8MTM9PT1hP2E6MH1mdW5jdGlvbiBwZCgpe3JldHVybiEwfWZ1bmN0aW9uIHFkKCl7cmV0dXJuITF9XG5mdW5jdGlvbiByZChhKXtmdW5jdGlvbiBiKGIsZCxlLGYsZyl7dGhpcy5fcmVhY3ROYW1lPWI7dGhpcy5fdGFyZ2V0SW5zdD1lO3RoaXMudHlwZT1kO3RoaXMubmF0aXZlRXZlbnQ9Zjt0aGlzLnRhcmdldD1nO3RoaXMuY3VycmVudFRhcmdldD1udWxsO2Zvcih2YXIgYyBpbiBhKWEuaGFzT3duUHJvcGVydHkoYykmJihiPWFbY10sdGhpc1tjXT1iP2IoZik6ZltjXSk7dGhpcy5pc0RlZmF1bHRQcmV2ZW50ZWQ9KG51bGwhPWYuZGVmYXVsdFByZXZlbnRlZD9mLmRlZmF1bHRQcmV2ZW50ZWQ6ITE9PT1mLnJldHVyblZhbHVlKT9wZDpxZDt0aGlzLmlzUHJvcGFnYXRpb25TdG9wcGVkPXFkO3JldHVybiB0aGlzfW0oYi5wcm90b3R5cGUse3ByZXZlbnREZWZhdWx0OmZ1bmN0aW9uKCl7dGhpcy5kZWZhdWx0UHJldmVudGVkPSEwO3ZhciBhPXRoaXMubmF0aXZlRXZlbnQ7YSYmKGEucHJldmVudERlZmF1bHQ/YS5wcmV2ZW50RGVmYXVsdCgpOlwidW5rbm93blwiIT09dHlwZW9mIGEucmV0dXJuVmFsdWUmJlxuKGEucmV0dXJuVmFsdWU9ITEpLHRoaXMuaXNEZWZhdWx0UHJldmVudGVkPXBkKX0sc3RvcFByb3BhZ2F0aW9uOmZ1bmN0aW9uKCl7dmFyIGE9dGhpcy5uYXRpdmVFdmVudDthJiYoYS5zdG9wUHJvcGFnYXRpb24/YS5zdG9wUHJvcGFnYXRpb24oKTpcInVua25vd25cIiE9PXR5cGVvZiBhLmNhbmNlbEJ1YmJsZSYmKGEuY2FuY2VsQnViYmxlPSEwKSx0aGlzLmlzUHJvcGFnYXRpb25TdG9wcGVkPXBkKX0scGVyc2lzdDpmdW5jdGlvbigpe30saXNQZXJzaXN0ZW50OnBkfSk7cmV0dXJuIGJ9XG52YXIgc2Q9e2V2ZW50UGhhc2U6MCxidWJibGVzOjAsY2FuY2VsYWJsZTowLHRpbWVTdGFtcDpmdW5jdGlvbihhKXtyZXR1cm4gYS50aW1lU3RhbXB8fERhdGUubm93KCl9LGRlZmF1bHRQcmV2ZW50ZWQ6MCxpc1RydXN0ZWQ6MH0sdGQ9cmQoc2QpLHVkPW0oe30sc2Qse3ZpZXc6MCxkZXRhaWw6MH0pLHZkPXJkKHVkKSx3ZCx4ZCx5ZCxBZD1tKHt9LHVkLHtzY3JlZW5YOjAsc2NyZWVuWTowLGNsaWVudFg6MCxjbGllbnRZOjAscGFnZVg6MCxwYWdlWTowLGN0cmxLZXk6MCxzaGlmdEtleTowLGFsdEtleTowLG1ldGFLZXk6MCxnZXRNb2RpZmllclN0YXRlOnpkLGJ1dHRvbjowLGJ1dHRvbnM6MCxyZWxhdGVkVGFyZ2V0OmZ1bmN0aW9uKGEpe3JldHVybiB2b2lkIDA9PT1hLnJlbGF0ZWRUYXJnZXQ/YS5mcm9tRWxlbWVudD09PWEuc3JjRWxlbWVudD9hLnRvRWxlbWVudDphLmZyb21FbGVtZW50OmEucmVsYXRlZFRhcmdldH0sbW92ZW1lbnRYOmZ1bmN0aW9uKGEpe2lmKFwibW92ZW1lbnRYXCJpblxuYSlyZXR1cm4gYS5tb3ZlbWVudFg7YSE9PXlkJiYoeWQmJlwibW91c2Vtb3ZlXCI9PT1hLnR5cGU/KHdkPWEuc2NyZWVuWC15ZC5zY3JlZW5YLHhkPWEuc2NyZWVuWS15ZC5zY3JlZW5ZKTp4ZD13ZD0wLHlkPWEpO3JldHVybiB3ZH0sbW92ZW1lbnRZOmZ1bmN0aW9uKGEpe3JldHVyblwibW92ZW1lbnRZXCJpbiBhP2EubW92ZW1lbnRZOnhkfX0pLEJkPXJkKEFkKSxDZD1tKHt9LEFkLHtkYXRhVHJhbnNmZXI6MH0pLERkPXJkKENkKSxFZD1tKHt9LHVkLHtyZWxhdGVkVGFyZ2V0OjB9KSxGZD1yZChFZCksR2Q9bSh7fSxzZCx7YW5pbWF0aW9uTmFtZTowLGVsYXBzZWRUaW1lOjAscHNldWRvRWxlbWVudDowfSksSGQ9cmQoR2QpLElkPW0oe30sc2Qse2NsaXBib2FyZERhdGE6ZnVuY3Rpb24oYSl7cmV0dXJuXCJjbGlwYm9hcmREYXRhXCJpbiBhP2EuY2xpcGJvYXJkRGF0YTp3aW5kb3cuY2xpcGJvYXJkRGF0YX19KSxKZD1yZChJZCksS2Q9bSh7fSxzZCx7ZGF0YTowfSksTGQ9cmQoS2QpLE1kPXtFc2M6XCJFc2NhcGVcIixcblNwYWNlYmFyOlwiIFwiLExlZnQ6XCJBcnJvd0xlZnRcIixVcDpcIkFycm93VXBcIixSaWdodDpcIkFycm93UmlnaHRcIixEb3duOlwiQXJyb3dEb3duXCIsRGVsOlwiRGVsZXRlXCIsV2luOlwiT1NcIixNZW51OlwiQ29udGV4dE1lbnVcIixBcHBzOlwiQ29udGV4dE1lbnVcIixTY3JvbGw6XCJTY3JvbGxMb2NrXCIsTW96UHJpbnRhYmxlS2V5OlwiVW5pZGVudGlmaWVkXCJ9LE5kPXs4OlwiQmFja3NwYWNlXCIsOTpcIlRhYlwiLDEyOlwiQ2xlYXJcIiwxMzpcIkVudGVyXCIsMTY6XCJTaGlmdFwiLDE3OlwiQ29udHJvbFwiLDE4OlwiQWx0XCIsMTk6XCJQYXVzZVwiLDIwOlwiQ2Fwc0xvY2tcIiwyNzpcIkVzY2FwZVwiLDMyOlwiIFwiLDMzOlwiUGFnZVVwXCIsMzQ6XCJQYWdlRG93blwiLDM1OlwiRW5kXCIsMzY6XCJIb21lXCIsMzc6XCJBcnJvd0xlZnRcIiwzODpcIkFycm93VXBcIiwzOTpcIkFycm93UmlnaHRcIiw0MDpcIkFycm93RG93blwiLDQ1OlwiSW5zZXJ0XCIsNDY6XCJEZWxldGVcIiwxMTI6XCJGMVwiLDExMzpcIkYyXCIsMTE0OlwiRjNcIiwxMTU6XCJGNFwiLDExNjpcIkY1XCIsMTE3OlwiRjZcIiwxMTg6XCJGN1wiLFxuMTE5OlwiRjhcIiwxMjA6XCJGOVwiLDEyMTpcIkYxMFwiLDEyMjpcIkYxMVwiLDEyMzpcIkYxMlwiLDE0NDpcIk51bUxvY2tcIiwxNDU6XCJTY3JvbGxMb2NrXCIsMjI0OlwiTWV0YVwifSxPZD17QWx0OlwiYWx0S2V5XCIsQ29udHJvbDpcImN0cmxLZXlcIixNZXRhOlwibWV0YUtleVwiLFNoaWZ0Olwic2hpZnRLZXlcIn07ZnVuY3Rpb24gUGQoYSl7dmFyIGI9dGhpcy5uYXRpdmVFdmVudDtyZXR1cm4gYi5nZXRNb2RpZmllclN0YXRlP2IuZ2V0TW9kaWZpZXJTdGF0ZShhKTooYT1PZFthXSk/ISFiW2FdOiExfWZ1bmN0aW9uIHpkKCl7cmV0dXJuIFBkfVxudmFyIFFkPW0oe30sdWQse2tleTpmdW5jdGlvbihhKXtpZihhLmtleSl7dmFyIGI9TWRbYS5rZXldfHxhLmtleTtpZihcIlVuaWRlbnRpZmllZFwiIT09YilyZXR1cm4gYn1yZXR1cm5cImtleXByZXNzXCI9PT1hLnR5cGU/KGE9b2QoYSksMTM9PT1hP1wiRW50ZXJcIjpTdHJpbmcuZnJvbUNoYXJDb2RlKGEpKTpcImtleWRvd25cIj09PWEudHlwZXx8XCJrZXl1cFwiPT09YS50eXBlP05kW2Eua2V5Q29kZV18fFwiVW5pZGVudGlmaWVkXCI6XCJcIn0sY29kZTowLGxvY2F0aW9uOjAsY3RybEtleTowLHNoaWZ0S2V5OjAsYWx0S2V5OjAsbWV0YUtleTowLHJlcGVhdDowLGxvY2FsZTowLGdldE1vZGlmaWVyU3RhdGU6emQsY2hhckNvZGU6ZnVuY3Rpb24oYSl7cmV0dXJuXCJrZXlwcmVzc1wiPT09YS50eXBlP29kKGEpOjB9LGtleUNvZGU6ZnVuY3Rpb24oYSl7cmV0dXJuXCJrZXlkb3duXCI9PT1hLnR5cGV8fFwia2V5dXBcIj09PWEudHlwZT9hLmtleUNvZGU6MH0sd2hpY2g6ZnVuY3Rpb24oYSl7cmV0dXJuXCJrZXlwcmVzc1wiPT09XG5hLnR5cGU/b2QoYSk6XCJrZXlkb3duXCI9PT1hLnR5cGV8fFwia2V5dXBcIj09PWEudHlwZT9hLmtleUNvZGU6MH19KSxSZD1yZChRZCksU2Q9bSh7fSxBZCx7cG9pbnRlcklkOjAsd2lkdGg6MCxoZWlnaHQ6MCxwcmVzc3VyZTowLHRhbmdlbnRpYWxQcmVzc3VyZTowLHRpbHRYOjAsdGlsdFk6MCx0d2lzdDowLHBvaW50ZXJUeXBlOjAsaXNQcmltYXJ5OjB9KSxUZD1yZChTZCksVWQ9bSh7fSx1ZCx7dG91Y2hlczowLHRhcmdldFRvdWNoZXM6MCxjaGFuZ2VkVG91Y2hlczowLGFsdEtleTowLG1ldGFLZXk6MCxjdHJsS2V5OjAsc2hpZnRLZXk6MCxnZXRNb2RpZmllclN0YXRlOnpkfSksVmQ9cmQoVWQpLFdkPW0oe30sc2Qse3Byb3BlcnR5TmFtZTowLGVsYXBzZWRUaW1lOjAscHNldWRvRWxlbWVudDowfSksWGQ9cmQoV2QpLFlkPW0oe30sQWQse2RlbHRhWDpmdW5jdGlvbihhKXtyZXR1cm5cImRlbHRhWFwiaW4gYT9hLmRlbHRhWDpcIndoZWVsRGVsdGFYXCJpbiBhPy1hLndoZWVsRGVsdGFYOjB9LFxuZGVsdGFZOmZ1bmN0aW9uKGEpe3JldHVyblwiZGVsdGFZXCJpbiBhP2EuZGVsdGFZOlwid2hlZWxEZWx0YVlcImluIGE/LWEud2hlZWxEZWx0YVk6XCJ3aGVlbERlbHRhXCJpbiBhPy1hLndoZWVsRGVsdGE6MH0sZGVsdGFaOjAsZGVsdGFNb2RlOjB9KSxaZD1yZChZZCksJGQ9WzksMTMsMjcsMzJdLGFlPWZhJiZcIkNvbXBvc2l0aW9uRXZlbnRcImluIHdpbmRvdyxiZT1udWxsO2ZhJiZcImRvY3VtZW50TW9kZVwiaW4gZG9jdW1lbnQmJihiZT1kb2N1bWVudC5kb2N1bWVudE1vZGUpO3ZhciBjZT1mYSYmXCJUZXh0RXZlbnRcImluIHdpbmRvdyYmIWJlLGRlPWZhJiYoIWFlfHxiZSYmODxiZSYmMTE+PWJlKSxlZT1TdHJpbmcuZnJvbUNoYXJDb2RlKDMyKSxmZT0hMTtcbmZ1bmN0aW9uIGdlKGEsYil7c3dpdGNoKGEpe2Nhc2UgXCJrZXl1cFwiOnJldHVybi0xIT09JGQuaW5kZXhPZihiLmtleUNvZGUpO2Nhc2UgXCJrZXlkb3duXCI6cmV0dXJuIDIyOSE9PWIua2V5Q29kZTtjYXNlIFwia2V5cHJlc3NcIjpjYXNlIFwibW91c2Vkb3duXCI6Y2FzZSBcImZvY3Vzb3V0XCI6cmV0dXJuITA7ZGVmYXVsdDpyZXR1cm4hMX19ZnVuY3Rpb24gaGUoYSl7YT1hLmRldGFpbDtyZXR1cm5cIm9iamVjdFwiPT09dHlwZW9mIGEmJlwiZGF0YVwiaW4gYT9hLmRhdGE6bnVsbH12YXIgaWU9ITE7ZnVuY3Rpb24gamUoYSxiKXtzd2l0Y2goYSl7Y2FzZSBcImNvbXBvc2l0aW9uZW5kXCI6cmV0dXJuIGhlKGIpO2Nhc2UgXCJrZXlwcmVzc1wiOmlmKDMyIT09Yi53aGljaClyZXR1cm4gbnVsbDtmZT0hMDtyZXR1cm4gZWU7Y2FzZSBcInRleHRJbnB1dFwiOnJldHVybiBhPWIuZGF0YSxhPT09ZWUmJmZlP251bGw6YTtkZWZhdWx0OnJldHVybiBudWxsfX1cbmZ1bmN0aW9uIGtlKGEsYil7aWYoaWUpcmV0dXJuXCJjb21wb3NpdGlvbmVuZFwiPT09YXx8IWFlJiZnZShhLGIpPyhhPW5kKCksbWQ9bGQ9a2Q9bnVsbCxpZT0hMSxhKTpudWxsO3N3aXRjaChhKXtjYXNlIFwicGFzdGVcIjpyZXR1cm4gbnVsbDtjYXNlIFwia2V5cHJlc3NcIjppZighKGIuY3RybEtleXx8Yi5hbHRLZXl8fGIubWV0YUtleSl8fGIuY3RybEtleSYmYi5hbHRLZXkpe2lmKGIuY2hhciYmMTxiLmNoYXIubGVuZ3RoKXJldHVybiBiLmNoYXI7aWYoYi53aGljaClyZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShiLndoaWNoKX1yZXR1cm4gbnVsbDtjYXNlIFwiY29tcG9zaXRpb25lbmRcIjpyZXR1cm4gZGUmJlwia29cIiE9PWIubG9jYWxlP251bGw6Yi5kYXRhO2RlZmF1bHQ6cmV0dXJuIG51bGx9fVxudmFyIGxlPXtjb2xvcjohMCxkYXRlOiEwLGRhdGV0aW1lOiEwLFwiZGF0ZXRpbWUtbG9jYWxcIjohMCxlbWFpbDohMCxtb250aDohMCxudW1iZXI6ITAscGFzc3dvcmQ6ITAscmFuZ2U6ITAsc2VhcmNoOiEwLHRlbDohMCx0ZXh0OiEwLHRpbWU6ITAsdXJsOiEwLHdlZWs6ITB9O2Z1bmN0aW9uIG1lKGEpe3ZhciBiPWEmJmEubm9kZU5hbWUmJmEubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtyZXR1cm5cImlucHV0XCI9PT1iPyEhbGVbYS50eXBlXTpcInRleHRhcmVhXCI9PT1iPyEwOiExfWZ1bmN0aW9uIG5lKGEsYixjLGQpe0ViKGQpO2I9b2UoYixcIm9uQ2hhbmdlXCIpOzA8Yi5sZW5ndGgmJihjPW5ldyB0ZChcIm9uQ2hhbmdlXCIsXCJjaGFuZ2VcIixudWxsLGMsZCksYS5wdXNoKHtldmVudDpjLGxpc3RlbmVyczpifSkpfXZhciBwZT1udWxsLHFlPW51bGw7ZnVuY3Rpb24gcmUoYSl7c2UoYSwwKX1mdW5jdGlvbiB0ZShhKXt2YXIgYj11ZShhKTtpZihXYShiKSlyZXR1cm4gYX1cbmZ1bmN0aW9uIHZlKGEsYil7aWYoXCJjaGFuZ2VcIj09PWEpcmV0dXJuIGJ9dmFyIHdlPSExO2lmKGZhKXt2YXIgeGU7aWYoZmEpe3ZhciB5ZT1cIm9uaW5wdXRcImluIGRvY3VtZW50O2lmKCF5ZSl7dmFyIHplPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7emUuc2V0QXR0cmlidXRlKFwib25pbnB1dFwiLFwicmV0dXJuO1wiKTt5ZT1cImZ1bmN0aW9uXCI9PT10eXBlb2YgemUub25pbnB1dH14ZT15ZX1lbHNlIHhlPSExO3dlPXhlJiYoIWRvY3VtZW50LmRvY3VtZW50TW9kZXx8OTxkb2N1bWVudC5kb2N1bWVudE1vZGUpfWZ1bmN0aW9uIEFlKCl7cGUmJihwZS5kZXRhY2hFdmVudChcIm9ucHJvcGVydHljaGFuZ2VcIixCZSkscWU9cGU9bnVsbCl9ZnVuY3Rpb24gQmUoYSl7aWYoXCJ2YWx1ZVwiPT09YS5wcm9wZXJ0eU5hbWUmJnRlKHFlKSl7dmFyIGI9W107bmUoYixxZSxhLHhiKGEpKTthPXJlO2lmKEtiKWEoYik7ZWxzZXtLYj0hMDt0cnl7R2IoYSxiKX1maW5hbGx5e0tiPSExLE1iKCl9fX19XG5mdW5jdGlvbiBDZShhLGIsYyl7XCJmb2N1c2luXCI9PT1hPyhBZSgpLHBlPWIscWU9YyxwZS5hdHRhY2hFdmVudChcIm9ucHJvcGVydHljaGFuZ2VcIixCZSkpOlwiZm9jdXNvdXRcIj09PWEmJkFlKCl9ZnVuY3Rpb24gRGUoYSl7aWYoXCJzZWxlY3Rpb25jaGFuZ2VcIj09PWF8fFwia2V5dXBcIj09PWF8fFwia2V5ZG93blwiPT09YSlyZXR1cm4gdGUocWUpfWZ1bmN0aW9uIEVlKGEsYil7aWYoXCJjbGlja1wiPT09YSlyZXR1cm4gdGUoYil9ZnVuY3Rpb24gRmUoYSxiKXtpZihcImlucHV0XCI9PT1hfHxcImNoYW5nZVwiPT09YSlyZXR1cm4gdGUoYil9ZnVuY3Rpb24gR2UoYSxiKXtyZXR1cm4gYT09PWImJigwIT09YXx8MS9hPT09MS9iKXx8YSE9PWEmJmIhPT1ifXZhciBIZT1cImZ1bmN0aW9uXCI9PT10eXBlb2YgT2JqZWN0LmlzP09iamVjdC5pczpHZSxJZT1PYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuZnVuY3Rpb24gSmUoYSxiKXtpZihIZShhLGIpKXJldHVybiEwO2lmKFwib2JqZWN0XCIhPT10eXBlb2YgYXx8bnVsbD09PWF8fFwib2JqZWN0XCIhPT10eXBlb2YgYnx8bnVsbD09PWIpcmV0dXJuITE7dmFyIGM9T2JqZWN0LmtleXMoYSksZD1PYmplY3Qua2V5cyhiKTtpZihjLmxlbmd0aCE9PWQubGVuZ3RoKXJldHVybiExO2ZvcihkPTA7ZDxjLmxlbmd0aDtkKyspaWYoIUllLmNhbGwoYixjW2RdKXx8IUhlKGFbY1tkXV0sYltjW2RdXSkpcmV0dXJuITE7cmV0dXJuITB9ZnVuY3Rpb24gS2UoYSl7Zm9yKDthJiZhLmZpcnN0Q2hpbGQ7KWE9YS5maXJzdENoaWxkO3JldHVybiBhfVxuZnVuY3Rpb24gTGUoYSxiKXt2YXIgYz1LZShhKTthPTA7Zm9yKHZhciBkO2M7KXtpZigzPT09Yy5ub2RlVHlwZSl7ZD1hK2MudGV4dENvbnRlbnQubGVuZ3RoO2lmKGE8PWImJmQ+PWIpcmV0dXJue25vZGU6YyxvZmZzZXQ6Yi1hfTthPWR9YTp7Zm9yKDtjOyl7aWYoYy5uZXh0U2libGluZyl7Yz1jLm5leHRTaWJsaW5nO2JyZWFrIGF9Yz1jLnBhcmVudE5vZGV9Yz12b2lkIDB9Yz1LZShjKX19ZnVuY3Rpb24gTWUoYSxiKXtyZXR1cm4gYSYmYj9hPT09Yj8hMDphJiYzPT09YS5ub2RlVHlwZT8hMTpiJiYzPT09Yi5ub2RlVHlwZT9NZShhLGIucGFyZW50Tm9kZSk6XCJjb250YWluc1wiaW4gYT9hLmNvbnRhaW5zKGIpOmEuY29tcGFyZURvY3VtZW50UG9zaXRpb24/ISEoYS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbihiKSYxNik6ITE6ITF9XG5mdW5jdGlvbiBOZSgpe2Zvcih2YXIgYT13aW5kb3csYj1YYSgpO2IgaW5zdGFuY2VvZiBhLkhUTUxJRnJhbWVFbGVtZW50Oyl7dHJ5e3ZhciBjPVwic3RyaW5nXCI9PT10eXBlb2YgYi5jb250ZW50V2luZG93LmxvY2F0aW9uLmhyZWZ9Y2F0Y2goZCl7Yz0hMX1pZihjKWE9Yi5jb250ZW50V2luZG93O2Vsc2UgYnJlYWs7Yj1YYShhLmRvY3VtZW50KX1yZXR1cm4gYn1mdW5jdGlvbiBPZShhKXt2YXIgYj1hJiZhLm5vZGVOYW1lJiZhLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7cmV0dXJuIGImJihcImlucHV0XCI9PT1iJiYoXCJ0ZXh0XCI9PT1hLnR5cGV8fFwic2VhcmNoXCI9PT1hLnR5cGV8fFwidGVsXCI9PT1hLnR5cGV8fFwidXJsXCI9PT1hLnR5cGV8fFwicGFzc3dvcmRcIj09PWEudHlwZSl8fFwidGV4dGFyZWFcIj09PWJ8fFwidHJ1ZVwiPT09YS5jb250ZW50RWRpdGFibGUpfVxudmFyIFBlPWZhJiZcImRvY3VtZW50TW9kZVwiaW4gZG9jdW1lbnQmJjExPj1kb2N1bWVudC5kb2N1bWVudE1vZGUsUWU9bnVsbCxSZT1udWxsLFNlPW51bGwsVGU9ITE7XG5mdW5jdGlvbiBVZShhLGIsYyl7dmFyIGQ9Yy53aW5kb3c9PT1jP2MuZG9jdW1lbnQ6OT09PWMubm9kZVR5cGU/YzpjLm93bmVyRG9jdW1lbnQ7VGV8fG51bGw9PVFlfHxRZSE9PVhhKGQpfHwoZD1RZSxcInNlbGVjdGlvblN0YXJ0XCJpbiBkJiZPZShkKT9kPXtzdGFydDpkLnNlbGVjdGlvblN0YXJ0LGVuZDpkLnNlbGVjdGlvbkVuZH06KGQ9KGQub3duZXJEb2N1bWVudCYmZC5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3fHx3aW5kb3cpLmdldFNlbGVjdGlvbigpLGQ9e2FuY2hvck5vZGU6ZC5hbmNob3JOb2RlLGFuY2hvck9mZnNldDpkLmFuY2hvck9mZnNldCxmb2N1c05vZGU6ZC5mb2N1c05vZGUsZm9jdXNPZmZzZXQ6ZC5mb2N1c09mZnNldH0pLFNlJiZKZShTZSxkKXx8KFNlPWQsZD1vZShSZSxcIm9uU2VsZWN0XCIpLDA8ZC5sZW5ndGgmJihiPW5ldyB0ZChcIm9uU2VsZWN0XCIsXCJzZWxlY3RcIixudWxsLGIsYyksYS5wdXNoKHtldmVudDpiLGxpc3RlbmVyczpkfSksYi50YXJnZXQ9UWUpKSl9XG5QYyhcImNhbmNlbCBjYW5jZWwgY2xpY2sgY2xpY2sgY2xvc2UgY2xvc2UgY29udGV4dG1lbnUgY29udGV4dE1lbnUgY29weSBjb3B5IGN1dCBjdXQgYXV4Y2xpY2sgYXV4Q2xpY2sgZGJsY2xpY2sgZG91YmxlQ2xpY2sgZHJhZ2VuZCBkcmFnRW5kIGRyYWdzdGFydCBkcmFnU3RhcnQgZHJvcCBkcm9wIGZvY3VzaW4gZm9jdXMgZm9jdXNvdXQgYmx1ciBpbnB1dCBpbnB1dCBpbnZhbGlkIGludmFsaWQga2V5ZG93biBrZXlEb3duIGtleXByZXNzIGtleVByZXNzIGtleXVwIGtleVVwIG1vdXNlZG93biBtb3VzZURvd24gbW91c2V1cCBtb3VzZVVwIHBhc3RlIHBhc3RlIHBhdXNlIHBhdXNlIHBsYXkgcGxheSBwb2ludGVyY2FuY2VsIHBvaW50ZXJDYW5jZWwgcG9pbnRlcmRvd24gcG9pbnRlckRvd24gcG9pbnRlcnVwIHBvaW50ZXJVcCByYXRlY2hhbmdlIHJhdGVDaGFuZ2UgcmVzZXQgcmVzZXQgc2Vla2VkIHNlZWtlZCBzdWJtaXQgc3VibWl0IHRvdWNoY2FuY2VsIHRvdWNoQ2FuY2VsIHRvdWNoZW5kIHRvdWNoRW5kIHRvdWNoc3RhcnQgdG91Y2hTdGFydCB2b2x1bWVjaGFuZ2Ugdm9sdW1lQ2hhbmdlXCIuc3BsaXQoXCIgXCIpLFxuMCk7UGMoXCJkcmFnIGRyYWcgZHJhZ2VudGVyIGRyYWdFbnRlciBkcmFnZXhpdCBkcmFnRXhpdCBkcmFnbGVhdmUgZHJhZ0xlYXZlIGRyYWdvdmVyIGRyYWdPdmVyIG1vdXNlbW92ZSBtb3VzZU1vdmUgbW91c2VvdXQgbW91c2VPdXQgbW91c2VvdmVyIG1vdXNlT3ZlciBwb2ludGVybW92ZSBwb2ludGVyTW92ZSBwb2ludGVyb3V0IHBvaW50ZXJPdXQgcG9pbnRlcm92ZXIgcG9pbnRlck92ZXIgc2Nyb2xsIHNjcm9sbCB0b2dnbGUgdG9nZ2xlIHRvdWNobW92ZSB0b3VjaE1vdmUgd2hlZWwgd2hlZWxcIi5zcGxpdChcIiBcIiksMSk7UGMoT2MsMik7Zm9yKHZhciBWZT1cImNoYW5nZSBzZWxlY3Rpb25jaGFuZ2UgdGV4dElucHV0IGNvbXBvc2l0aW9uc3RhcnQgY29tcG9zaXRpb25lbmQgY29tcG9zaXRpb251cGRhdGVcIi5zcGxpdChcIiBcIiksV2U9MDtXZTxWZS5sZW5ndGg7V2UrKylOYy5zZXQoVmVbV2VdLDApO2VhKFwib25Nb3VzZUVudGVyXCIsW1wibW91c2VvdXRcIixcIm1vdXNlb3ZlclwiXSk7XG5lYShcIm9uTW91c2VMZWF2ZVwiLFtcIm1vdXNlb3V0XCIsXCJtb3VzZW92ZXJcIl0pO2VhKFwib25Qb2ludGVyRW50ZXJcIixbXCJwb2ludGVyb3V0XCIsXCJwb2ludGVyb3ZlclwiXSk7ZWEoXCJvblBvaW50ZXJMZWF2ZVwiLFtcInBvaW50ZXJvdXRcIixcInBvaW50ZXJvdmVyXCJdKTtkYShcIm9uQ2hhbmdlXCIsXCJjaGFuZ2UgY2xpY2sgZm9jdXNpbiBmb2N1c291dCBpbnB1dCBrZXlkb3duIGtleXVwIHNlbGVjdGlvbmNoYW5nZVwiLnNwbGl0KFwiIFwiKSk7ZGEoXCJvblNlbGVjdFwiLFwiZm9jdXNvdXQgY29udGV4dG1lbnUgZHJhZ2VuZCBmb2N1c2luIGtleWRvd24ga2V5dXAgbW91c2Vkb3duIG1vdXNldXAgc2VsZWN0aW9uY2hhbmdlXCIuc3BsaXQoXCIgXCIpKTtkYShcIm9uQmVmb3JlSW5wdXRcIixbXCJjb21wb3NpdGlvbmVuZFwiLFwia2V5cHJlc3NcIixcInRleHRJbnB1dFwiLFwicGFzdGVcIl0pO2RhKFwib25Db21wb3NpdGlvbkVuZFwiLFwiY29tcG9zaXRpb25lbmQgZm9jdXNvdXQga2V5ZG93biBrZXlwcmVzcyBrZXl1cCBtb3VzZWRvd25cIi5zcGxpdChcIiBcIikpO1xuZGEoXCJvbkNvbXBvc2l0aW9uU3RhcnRcIixcImNvbXBvc2l0aW9uc3RhcnQgZm9jdXNvdXQga2V5ZG93biBrZXlwcmVzcyBrZXl1cCBtb3VzZWRvd25cIi5zcGxpdChcIiBcIikpO2RhKFwib25Db21wb3NpdGlvblVwZGF0ZVwiLFwiY29tcG9zaXRpb251cGRhdGUgZm9jdXNvdXQga2V5ZG93biBrZXlwcmVzcyBrZXl1cCBtb3VzZWRvd25cIi5zcGxpdChcIiBcIikpO3ZhciBYZT1cImFib3J0IGNhbnBsYXkgY2FucGxheXRocm91Z2ggZHVyYXRpb25jaGFuZ2UgZW1wdGllZCBlbmNyeXB0ZWQgZW5kZWQgZXJyb3IgbG9hZGVkZGF0YSBsb2FkZWRtZXRhZGF0YSBsb2Fkc3RhcnQgcGF1c2UgcGxheSBwbGF5aW5nIHByb2dyZXNzIHJhdGVjaGFuZ2Ugc2Vla2VkIHNlZWtpbmcgc3RhbGxlZCBzdXNwZW5kIHRpbWV1cGRhdGUgdm9sdW1lY2hhbmdlIHdhaXRpbmdcIi5zcGxpdChcIiBcIiksWWU9bmV3IFNldChcImNhbmNlbCBjbG9zZSBpbnZhbGlkIGxvYWQgc2Nyb2xsIHRvZ2dsZVwiLnNwbGl0KFwiIFwiKS5jb25jYXQoWGUpKTtcbmZ1bmN0aW9uIFplKGEsYixjKXt2YXIgZD1hLnR5cGV8fFwidW5rbm93bi1ldmVudFwiO2EuY3VycmVudFRhcmdldD1jO1liKGQsYix2b2lkIDAsYSk7YS5jdXJyZW50VGFyZ2V0PW51bGx9XG5mdW5jdGlvbiBzZShhLGIpe2I9MCE9PShiJjQpO2Zvcih2YXIgYz0wO2M8YS5sZW5ndGg7YysrKXt2YXIgZD1hW2NdLGU9ZC5ldmVudDtkPWQubGlzdGVuZXJzO2E6e3ZhciBmPXZvaWQgMDtpZihiKWZvcih2YXIgZz1kLmxlbmd0aC0xOzA8PWc7Zy0tKXt2YXIgaD1kW2ddLGs9aC5pbnN0YW5jZSxsPWguY3VycmVudFRhcmdldDtoPWgubGlzdGVuZXI7aWYoayE9PWYmJmUuaXNQcm9wYWdhdGlvblN0b3BwZWQoKSlicmVhayBhO1plKGUsaCxsKTtmPWt9ZWxzZSBmb3IoZz0wO2c8ZC5sZW5ndGg7ZysrKXtoPWRbZ107az1oLmluc3RhbmNlO2w9aC5jdXJyZW50VGFyZ2V0O2g9aC5saXN0ZW5lcjtpZihrIT09ZiYmZS5pc1Byb3BhZ2F0aW9uU3RvcHBlZCgpKWJyZWFrIGE7WmUoZSxoLGwpO2Y9a319fWlmKFViKXRocm93IGE9VmIsVWI9ITEsVmI9bnVsbCxhO31cbmZ1bmN0aW9uIEcoYSxiKXt2YXIgYz0kZShiKSxkPWErXCJfX2J1YmJsZVwiO2MuaGFzKGQpfHwoYWYoYixhLDIsITEpLGMuYWRkKGQpKX12YXIgYmY9XCJfcmVhY3RMaXN0ZW5pbmdcIitNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zbGljZSgyKTtmdW5jdGlvbiBjZihhKXthW2JmXXx8KGFbYmZdPSEwLGJhLmZvckVhY2goZnVuY3Rpb24oYil7WWUuaGFzKGIpfHxkZihiLCExLGEsbnVsbCk7ZGYoYiwhMCxhLG51bGwpfSkpfVxuZnVuY3Rpb24gZGYoYSxiLGMsZCl7dmFyIGU9NDxhcmd1bWVudHMubGVuZ3RoJiZ2b2lkIDAhPT1hcmd1bWVudHNbNF0/YXJndW1lbnRzWzRdOjAsZj1jO1wic2VsZWN0aW9uY2hhbmdlXCI9PT1hJiY5IT09Yy5ub2RlVHlwZSYmKGY9Yy5vd25lckRvY3VtZW50KTtpZihudWxsIT09ZCYmIWImJlllLmhhcyhhKSl7aWYoXCJzY3JvbGxcIiE9PWEpcmV0dXJuO2V8PTI7Zj1kfXZhciBnPSRlKGYpLGg9YStcIl9fXCIrKGI/XCJjYXB0dXJlXCI6XCJidWJibGVcIik7Zy5oYXMoaCl8fChiJiYoZXw9NCksYWYoZixhLGUsYiksZy5hZGQoaCkpfVxuZnVuY3Rpb24gYWYoYSxiLGMsZCl7dmFyIGU9TmMuZ2V0KGIpO3N3aXRjaCh2b2lkIDA9PT1lPzI6ZSl7Y2FzZSAwOmU9Z2Q7YnJlYWs7Y2FzZSAxOmU9aWQ7YnJlYWs7ZGVmYXVsdDplPWhkfWM9ZS5iaW5kKG51bGwsYixjLGEpO2U9dm9pZCAwOyFQYnx8XCJ0b3VjaHN0YXJ0XCIhPT1iJiZcInRvdWNobW92ZVwiIT09YiYmXCJ3aGVlbFwiIT09Ynx8KGU9ITApO2Q/dm9pZCAwIT09ZT9hLmFkZEV2ZW50TGlzdGVuZXIoYixjLHtjYXB0dXJlOiEwLHBhc3NpdmU6ZX0pOmEuYWRkRXZlbnRMaXN0ZW5lcihiLGMsITApOnZvaWQgMCE9PWU/YS5hZGRFdmVudExpc3RlbmVyKGIsYyx7cGFzc2l2ZTplfSk6YS5hZGRFdmVudExpc3RlbmVyKGIsYywhMSl9XG5mdW5jdGlvbiBqZChhLGIsYyxkLGUpe3ZhciBmPWQ7aWYoMD09PShiJjEpJiYwPT09KGImMikmJm51bGwhPT1kKWE6Zm9yKDs7KXtpZihudWxsPT09ZClyZXR1cm47dmFyIGc9ZC50YWc7aWYoMz09PWd8fDQ9PT1nKXt2YXIgaD1kLnN0YXRlTm9kZS5jb250YWluZXJJbmZvO2lmKGg9PT1lfHw4PT09aC5ub2RlVHlwZSYmaC5wYXJlbnROb2RlPT09ZSlicmVhaztpZig0PT09Zylmb3IoZz1kLnJldHVybjtudWxsIT09Zzspe3ZhciBrPWcudGFnO2lmKDM9PT1rfHw0PT09aylpZihrPWcuc3RhdGVOb2RlLmNvbnRhaW5lckluZm8saz09PWV8fDg9PT1rLm5vZGVUeXBlJiZrLnBhcmVudE5vZGU9PT1lKXJldHVybjtnPWcucmV0dXJufWZvcig7bnVsbCE9PWg7KXtnPXdjKGgpO2lmKG51bGw9PT1nKXJldHVybjtrPWcudGFnO2lmKDU9PT1rfHw2PT09ayl7ZD1mPWc7Y29udGludWUgYX1oPWgucGFyZW50Tm9kZX19ZD1kLnJldHVybn1OYihmdW5jdGlvbigpe3ZhciBkPWYsZT14YihjKSxnPVtdO1xuYTp7dmFyIGg9TWMuZ2V0KGEpO2lmKHZvaWQgMCE9PWgpe3ZhciBrPXRkLHg9YTtzd2l0Y2goYSl7Y2FzZSBcImtleXByZXNzXCI6aWYoMD09PW9kKGMpKWJyZWFrIGE7Y2FzZSBcImtleWRvd25cIjpjYXNlIFwia2V5dXBcIjprPVJkO2JyZWFrO2Nhc2UgXCJmb2N1c2luXCI6eD1cImZvY3VzXCI7az1GZDticmVhaztjYXNlIFwiZm9jdXNvdXRcIjp4PVwiYmx1clwiO2s9RmQ7YnJlYWs7Y2FzZSBcImJlZm9yZWJsdXJcIjpjYXNlIFwiYWZ0ZXJibHVyXCI6az1GZDticmVhaztjYXNlIFwiY2xpY2tcIjppZigyPT09Yy5idXR0b24pYnJlYWsgYTtjYXNlIFwiYXV4Y2xpY2tcIjpjYXNlIFwiZGJsY2xpY2tcIjpjYXNlIFwibW91c2Vkb3duXCI6Y2FzZSBcIm1vdXNlbW92ZVwiOmNhc2UgXCJtb3VzZXVwXCI6Y2FzZSBcIm1vdXNlb3V0XCI6Y2FzZSBcIm1vdXNlb3ZlclwiOmNhc2UgXCJjb250ZXh0bWVudVwiOms9QmQ7YnJlYWs7Y2FzZSBcImRyYWdcIjpjYXNlIFwiZHJhZ2VuZFwiOmNhc2UgXCJkcmFnZW50ZXJcIjpjYXNlIFwiZHJhZ2V4aXRcIjpjYXNlIFwiZHJhZ2xlYXZlXCI6Y2FzZSBcImRyYWdvdmVyXCI6Y2FzZSBcImRyYWdzdGFydFwiOmNhc2UgXCJkcm9wXCI6az1cbkRkO2JyZWFrO2Nhc2UgXCJ0b3VjaGNhbmNlbFwiOmNhc2UgXCJ0b3VjaGVuZFwiOmNhc2UgXCJ0b3VjaG1vdmVcIjpjYXNlIFwidG91Y2hzdGFydFwiOms9VmQ7YnJlYWs7Y2FzZSBJYzpjYXNlIEpjOmNhc2UgS2M6az1IZDticmVhaztjYXNlIExjOms9WGQ7YnJlYWs7Y2FzZSBcInNjcm9sbFwiOms9dmQ7YnJlYWs7Y2FzZSBcIndoZWVsXCI6az1aZDticmVhaztjYXNlIFwiY29weVwiOmNhc2UgXCJjdXRcIjpjYXNlIFwicGFzdGVcIjprPUpkO2JyZWFrO2Nhc2UgXCJnb3Rwb2ludGVyY2FwdHVyZVwiOmNhc2UgXCJsb3N0cG9pbnRlcmNhcHR1cmVcIjpjYXNlIFwicG9pbnRlcmNhbmNlbFwiOmNhc2UgXCJwb2ludGVyZG93blwiOmNhc2UgXCJwb2ludGVybW92ZVwiOmNhc2UgXCJwb2ludGVyb3V0XCI6Y2FzZSBcInBvaW50ZXJvdmVyXCI6Y2FzZSBcInBvaW50ZXJ1cFwiOms9VGR9dmFyIHc9MCE9PShiJjQpLHo9IXcmJlwic2Nyb2xsXCI9PT1hLHU9dz9udWxsIT09aD9oK1wiQ2FwdHVyZVwiOm51bGw6aDt3PVtdO2Zvcih2YXIgdD1kLHE7bnVsbCE9PVxudDspe3E9dDt2YXIgdj1xLnN0YXRlTm9kZTs1PT09cS50YWcmJm51bGwhPT12JiYocT12LG51bGwhPT11JiYodj1PYih0LHUpLG51bGwhPXYmJncucHVzaChlZih0LHYscSkpKSk7aWYoeilicmVhazt0PXQucmV0dXJufTA8dy5sZW5ndGgmJihoPW5ldyBrKGgseCxudWxsLGMsZSksZy5wdXNoKHtldmVudDpoLGxpc3RlbmVyczp3fSkpfX1pZigwPT09KGImNykpe2E6e2g9XCJtb3VzZW92ZXJcIj09PWF8fFwicG9pbnRlcm92ZXJcIj09PWE7az1cIm1vdXNlb3V0XCI9PT1hfHxcInBvaW50ZXJvdXRcIj09PWE7aWYoaCYmMD09PShiJjE2KSYmKHg9Yy5yZWxhdGVkVGFyZ2V0fHxjLmZyb21FbGVtZW50KSYmKHdjKHgpfHx4W2ZmXSkpYnJlYWsgYTtpZihrfHxoKXtoPWUud2luZG93PT09ZT9lOihoPWUub3duZXJEb2N1bWVudCk/aC5kZWZhdWx0Vmlld3x8aC5wYXJlbnRXaW5kb3c6d2luZG93O2lmKGspe2lmKHg9Yy5yZWxhdGVkVGFyZ2V0fHxjLnRvRWxlbWVudCxrPWQseD14P3djKHgpOm51bGwsbnVsbCE9PVxueCYmKHo9WmIoeCkseCE9PXp8fDUhPT14LnRhZyYmNiE9PXgudGFnKSl4PW51bGx9ZWxzZSBrPW51bGwseD1kO2lmKGshPT14KXt3PUJkO3Y9XCJvbk1vdXNlTGVhdmVcIjt1PVwib25Nb3VzZUVudGVyXCI7dD1cIm1vdXNlXCI7aWYoXCJwb2ludGVyb3V0XCI9PT1hfHxcInBvaW50ZXJvdmVyXCI9PT1hKXc9VGQsdj1cIm9uUG9pbnRlckxlYXZlXCIsdT1cIm9uUG9pbnRlckVudGVyXCIsdD1cInBvaW50ZXJcIjt6PW51bGw9PWs/aDp1ZShrKTtxPW51bGw9PXg/aDp1ZSh4KTtoPW5ldyB3KHYsdCtcImxlYXZlXCIsayxjLGUpO2gudGFyZ2V0PXo7aC5yZWxhdGVkVGFyZ2V0PXE7dj1udWxsO3djKGUpPT09ZCYmKHc9bmV3IHcodSx0K1wiZW50ZXJcIix4LGMsZSksdy50YXJnZXQ9cSx3LnJlbGF0ZWRUYXJnZXQ9eix2PXcpO3o9djtpZihrJiZ4KWI6e3c9azt1PXg7dD0wO2ZvcihxPXc7cTtxPWdmKHEpKXQrKztxPTA7Zm9yKHY9dTt2O3Y9Z2YodikpcSsrO2Zvcig7MDx0LXE7KXc9Z2YodyksdC0tO2Zvcig7MDxxLXQ7KXU9XG5nZih1KSxxLS07Zm9yKDt0LS07KXtpZih3PT09dXx8bnVsbCE9PXUmJnc9PT11LmFsdGVybmF0ZSlicmVhayBiO3c9Z2Yodyk7dT1nZih1KX13PW51bGx9ZWxzZSB3PW51bGw7bnVsbCE9PWsmJmhmKGcsaCxrLHcsITEpO251bGwhPT14JiZudWxsIT09eiYmaGYoZyx6LHgsdywhMCl9fX1hOntoPWQ/dWUoZCk6d2luZG93O2s9aC5ub2RlTmFtZSYmaC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO2lmKFwic2VsZWN0XCI9PT1rfHxcImlucHV0XCI9PT1rJiZcImZpbGVcIj09PWgudHlwZSl2YXIgSj12ZTtlbHNlIGlmKG1lKGgpKWlmKHdlKUo9RmU7ZWxzZXtKPURlO3ZhciBLPUNlfWVsc2Uoaz1oLm5vZGVOYW1lKSYmXCJpbnB1dFwiPT09ay50b0xvd2VyQ2FzZSgpJiYoXCJjaGVja2JveFwiPT09aC50eXBlfHxcInJhZGlvXCI9PT1oLnR5cGUpJiYoSj1FZSk7aWYoSiYmKEo9SihhLGQpKSl7bmUoZyxKLGMsZSk7YnJlYWsgYX1LJiZLKGEsaCxkKTtcImZvY3Vzb3V0XCI9PT1hJiYoSz1oLl93cmFwcGVyU3RhdGUpJiZcbksuY29udHJvbGxlZCYmXCJudW1iZXJcIj09PWgudHlwZSYmYmIoaCxcIm51bWJlclwiLGgudmFsdWUpfUs9ZD91ZShkKTp3aW5kb3c7c3dpdGNoKGEpe2Nhc2UgXCJmb2N1c2luXCI6aWYobWUoSyl8fFwidHJ1ZVwiPT09Sy5jb250ZW50RWRpdGFibGUpUWU9SyxSZT1kLFNlPW51bGw7YnJlYWs7Y2FzZSBcImZvY3Vzb3V0XCI6U2U9UmU9UWU9bnVsbDticmVhaztjYXNlIFwibW91c2Vkb3duXCI6VGU9ITA7YnJlYWs7Y2FzZSBcImNvbnRleHRtZW51XCI6Y2FzZSBcIm1vdXNldXBcIjpjYXNlIFwiZHJhZ2VuZFwiOlRlPSExO1VlKGcsYyxlKTticmVhaztjYXNlIFwic2VsZWN0aW9uY2hhbmdlXCI6aWYoUGUpYnJlYWs7Y2FzZSBcImtleWRvd25cIjpjYXNlIFwia2V5dXBcIjpVZShnLGMsZSl9dmFyIFE7aWYoYWUpYjp7c3dpdGNoKGEpe2Nhc2UgXCJjb21wb3NpdGlvbnN0YXJ0XCI6dmFyIEw9XCJvbkNvbXBvc2l0aW9uU3RhcnRcIjticmVhayBiO2Nhc2UgXCJjb21wb3NpdGlvbmVuZFwiOkw9XCJvbkNvbXBvc2l0aW9uRW5kXCI7YnJlYWsgYjtcbmNhc2UgXCJjb21wb3NpdGlvbnVwZGF0ZVwiOkw9XCJvbkNvbXBvc2l0aW9uVXBkYXRlXCI7YnJlYWsgYn1MPXZvaWQgMH1lbHNlIGllP2dlKGEsYykmJihMPVwib25Db21wb3NpdGlvbkVuZFwiKTpcImtleWRvd25cIj09PWEmJjIyOT09PWMua2V5Q29kZSYmKEw9XCJvbkNvbXBvc2l0aW9uU3RhcnRcIik7TCYmKGRlJiZcImtvXCIhPT1jLmxvY2FsZSYmKGllfHxcIm9uQ29tcG9zaXRpb25TdGFydFwiIT09TD9cIm9uQ29tcG9zaXRpb25FbmRcIj09PUwmJmllJiYoUT1uZCgpKTooa2Q9ZSxsZD1cInZhbHVlXCJpbiBrZD9rZC52YWx1ZTprZC50ZXh0Q29udGVudCxpZT0hMCkpLEs9b2UoZCxMKSwwPEsubGVuZ3RoJiYoTD1uZXcgTGQoTCxhLG51bGwsYyxlKSxnLnB1c2goe2V2ZW50OkwsbGlzdGVuZXJzOkt9KSxRP0wuZGF0YT1ROihRPWhlKGMpLG51bGwhPT1RJiYoTC5kYXRhPVEpKSkpO2lmKFE9Y2U/amUoYSxjKTprZShhLGMpKWQ9b2UoZCxcIm9uQmVmb3JlSW5wdXRcIiksMDxkLmxlbmd0aCYmKGU9bmV3IExkKFwib25CZWZvcmVJbnB1dFwiLFxuXCJiZWZvcmVpbnB1dFwiLG51bGwsYyxlKSxnLnB1c2goe2V2ZW50OmUsbGlzdGVuZXJzOmR9KSxlLmRhdGE9USl9c2UoZyxiKX0pfWZ1bmN0aW9uIGVmKGEsYixjKXtyZXR1cm57aW5zdGFuY2U6YSxsaXN0ZW5lcjpiLGN1cnJlbnRUYXJnZXQ6Y319ZnVuY3Rpb24gb2UoYSxiKXtmb3IodmFyIGM9YitcIkNhcHR1cmVcIixkPVtdO251bGwhPT1hOyl7dmFyIGU9YSxmPWUuc3RhdGVOb2RlOzU9PT1lLnRhZyYmbnVsbCE9PWYmJihlPWYsZj1PYihhLGMpLG51bGwhPWYmJmQudW5zaGlmdChlZihhLGYsZSkpLGY9T2IoYSxiKSxudWxsIT1mJiZkLnB1c2goZWYoYSxmLGUpKSk7YT1hLnJldHVybn1yZXR1cm4gZH1mdW5jdGlvbiBnZihhKXtpZihudWxsPT09YSlyZXR1cm4gbnVsbDtkbyBhPWEucmV0dXJuO3doaWxlKGEmJjUhPT1hLnRhZyk7cmV0dXJuIGE/YTpudWxsfVxuZnVuY3Rpb24gaGYoYSxiLGMsZCxlKXtmb3IodmFyIGY9Yi5fcmVhY3ROYW1lLGc9W107bnVsbCE9PWMmJmMhPT1kOyl7dmFyIGg9YyxrPWguYWx0ZXJuYXRlLGw9aC5zdGF0ZU5vZGU7aWYobnVsbCE9PWsmJms9PT1kKWJyZWFrOzU9PT1oLnRhZyYmbnVsbCE9PWwmJihoPWwsZT8oaz1PYihjLGYpLG51bGwhPWsmJmcudW5zaGlmdChlZihjLGssaCkpKTplfHwoaz1PYihjLGYpLG51bGwhPWsmJmcucHVzaChlZihjLGssaCkpKSk7Yz1jLnJldHVybn0wIT09Zy5sZW5ndGgmJmEucHVzaCh7ZXZlbnQ6YixsaXN0ZW5lcnM6Z30pfWZ1bmN0aW9uIGpmKCl7fXZhciBrZj1udWxsLGxmPW51bGw7ZnVuY3Rpb24gbWYoYSxiKXtzd2l0Y2goYSl7Y2FzZSBcImJ1dHRvblwiOmNhc2UgXCJpbnB1dFwiOmNhc2UgXCJzZWxlY3RcIjpjYXNlIFwidGV4dGFyZWFcIjpyZXR1cm4hIWIuYXV0b0ZvY3VzfXJldHVybiExfVxuZnVuY3Rpb24gbmYoYSxiKXtyZXR1cm5cInRleHRhcmVhXCI9PT1hfHxcIm9wdGlvblwiPT09YXx8XCJub3NjcmlwdFwiPT09YXx8XCJzdHJpbmdcIj09PXR5cGVvZiBiLmNoaWxkcmVufHxcIm51bWJlclwiPT09dHlwZW9mIGIuY2hpbGRyZW58fFwib2JqZWN0XCI9PT10eXBlb2YgYi5kYW5nZXJvdXNseVNldElubmVySFRNTCYmbnVsbCE9PWIuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwmJm51bGwhPWIuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwuX19odG1sfXZhciBvZj1cImZ1bmN0aW9uXCI9PT10eXBlb2Ygc2V0VGltZW91dD9zZXRUaW1lb3V0OnZvaWQgMCxwZj1cImZ1bmN0aW9uXCI9PT10eXBlb2YgY2xlYXJUaW1lb3V0P2NsZWFyVGltZW91dDp2b2lkIDA7ZnVuY3Rpb24gcWYoYSl7MT09PWEubm9kZVR5cGU/YS50ZXh0Q29udGVudD1cIlwiOjk9PT1hLm5vZGVUeXBlJiYoYT1hLmJvZHksbnVsbCE9YSYmKGEudGV4dENvbnRlbnQ9XCJcIikpfVxuZnVuY3Rpb24gcmYoYSl7Zm9yKDtudWxsIT1hO2E9YS5uZXh0U2libGluZyl7dmFyIGI9YS5ub2RlVHlwZTtpZigxPT09Ynx8Mz09PWIpYnJlYWt9cmV0dXJuIGF9ZnVuY3Rpb24gc2YoYSl7YT1hLnByZXZpb3VzU2libGluZztmb3IodmFyIGI9MDthOyl7aWYoOD09PWEubm9kZVR5cGUpe3ZhciBjPWEuZGF0YTtpZihcIiRcIj09PWN8fFwiJCFcIj09PWN8fFwiJD9cIj09PWMpe2lmKDA9PT1iKXJldHVybiBhO2ItLX1lbHNlXCIvJFwiPT09YyYmYisrfWE9YS5wcmV2aW91c1NpYmxpbmd9cmV0dXJuIG51bGx9dmFyIHRmPTA7ZnVuY3Rpb24gdWYoYSl7cmV0dXJueyQkdHlwZW9mOkdhLHRvU3RyaW5nOmEsdmFsdWVPZjphfX12YXIgdmY9TWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc2xpY2UoMiksd2Y9XCJfX3JlYWN0RmliZXIkXCIrdmYseGY9XCJfX3JlYWN0UHJvcHMkXCIrdmYsZmY9XCJfX3JlYWN0Q29udGFpbmVyJFwiK3ZmLHlmPVwiX19yZWFjdEV2ZW50cyRcIit2ZjtcbmZ1bmN0aW9uIHdjKGEpe3ZhciBiPWFbd2ZdO2lmKGIpcmV0dXJuIGI7Zm9yKHZhciBjPWEucGFyZW50Tm9kZTtjOyl7aWYoYj1jW2ZmXXx8Y1t3Zl0pe2M9Yi5hbHRlcm5hdGU7aWYobnVsbCE9PWIuY2hpbGR8fG51bGwhPT1jJiZudWxsIT09Yy5jaGlsZClmb3IoYT1zZihhKTtudWxsIT09YTspe2lmKGM9YVt3Zl0pcmV0dXJuIGM7YT1zZihhKX1yZXR1cm4gYn1hPWM7Yz1hLnBhcmVudE5vZGV9cmV0dXJuIG51bGx9ZnVuY3Rpb24gQ2IoYSl7YT1hW3dmXXx8YVtmZl07cmV0dXJuIWF8fDUhPT1hLnRhZyYmNiE9PWEudGFnJiYxMyE9PWEudGFnJiYzIT09YS50YWc/bnVsbDphfWZ1bmN0aW9uIHVlKGEpe2lmKDU9PT1hLnRhZ3x8Nj09PWEudGFnKXJldHVybiBhLnN0YXRlTm9kZTt0aHJvdyBFcnJvcih5KDMzKSk7fWZ1bmN0aW9uIERiKGEpe3JldHVybiBhW3hmXXx8bnVsbH1cbmZ1bmN0aW9uICRlKGEpe3ZhciBiPWFbeWZdO3ZvaWQgMD09PWImJihiPWFbeWZdPW5ldyBTZXQpO3JldHVybiBifXZhciB6Zj1bXSxBZj0tMTtmdW5jdGlvbiBCZihhKXtyZXR1cm57Y3VycmVudDphfX1mdW5jdGlvbiBIKGEpezA+QWZ8fChhLmN1cnJlbnQ9emZbQWZdLHpmW0FmXT1udWxsLEFmLS0pfWZ1bmN0aW9uIEkoYSxiKXtBZisrO3pmW0FmXT1hLmN1cnJlbnQ7YS5jdXJyZW50PWJ9dmFyIENmPXt9LE09QmYoQ2YpLE49QmYoITEpLERmPUNmO1xuZnVuY3Rpb24gRWYoYSxiKXt2YXIgYz1hLnR5cGUuY29udGV4dFR5cGVzO2lmKCFjKXJldHVybiBDZjt2YXIgZD1hLnN0YXRlTm9kZTtpZihkJiZkLl9fcmVhY3RJbnRlcm5hbE1lbW9pemVkVW5tYXNrZWRDaGlsZENvbnRleHQ9PT1iKXJldHVybiBkLl9fcmVhY3RJbnRlcm5hbE1lbW9pemVkTWFza2VkQ2hpbGRDb250ZXh0O3ZhciBlPXt9LGY7Zm9yKGYgaW4gYyllW2ZdPWJbZl07ZCYmKGE9YS5zdGF0ZU5vZGUsYS5fX3JlYWN0SW50ZXJuYWxNZW1vaXplZFVubWFza2VkQ2hpbGRDb250ZXh0PWIsYS5fX3JlYWN0SW50ZXJuYWxNZW1vaXplZE1hc2tlZENoaWxkQ29udGV4dD1lKTtyZXR1cm4gZX1mdW5jdGlvbiBGZihhKXthPWEuY2hpbGRDb250ZXh0VHlwZXM7cmV0dXJuIG51bGwhPT1hJiZ2b2lkIDAhPT1hfWZ1bmN0aW9uIEdmKCl7SChOKTtIKE0pfWZ1bmN0aW9uIEhmKGEsYixjKXtpZihNLmN1cnJlbnQhPT1DZil0aHJvdyBFcnJvcih5KDE2OCkpO0koTSxiKTtJKE4sYyl9XG5mdW5jdGlvbiBJZihhLGIsYyl7dmFyIGQ9YS5zdGF0ZU5vZGU7YT1iLmNoaWxkQ29udGV4dFR5cGVzO2lmKFwiZnVuY3Rpb25cIiE9PXR5cGVvZiBkLmdldENoaWxkQ29udGV4dClyZXR1cm4gYztkPWQuZ2V0Q2hpbGRDb250ZXh0KCk7Zm9yKHZhciBlIGluIGQpaWYoIShlIGluIGEpKXRocm93IEVycm9yKHkoMTA4LFJhKGIpfHxcIlVua25vd25cIixlKSk7cmV0dXJuIG0oe30sYyxkKX1mdW5jdGlvbiBKZihhKXthPShhPWEuc3RhdGVOb2RlKSYmYS5fX3JlYWN0SW50ZXJuYWxNZW1vaXplZE1lcmdlZENoaWxkQ29udGV4dHx8Q2Y7RGY9TS5jdXJyZW50O0koTSxhKTtJKE4sTi5jdXJyZW50KTtyZXR1cm4hMH1mdW5jdGlvbiBLZihhLGIsYyl7dmFyIGQ9YS5zdGF0ZU5vZGU7aWYoIWQpdGhyb3cgRXJyb3IoeSgxNjkpKTtjPyhhPUlmKGEsYixEZiksZC5fX3JlYWN0SW50ZXJuYWxNZW1vaXplZE1lcmdlZENoaWxkQ29udGV4dD1hLEgoTiksSChNKSxJKE0sYSkpOkgoTik7SShOLGMpfVxudmFyIExmPW51bGwsTWY9bnVsbCxOZj1yLnVuc3RhYmxlX3J1bldpdGhQcmlvcml0eSxPZj1yLnVuc3RhYmxlX3NjaGVkdWxlQ2FsbGJhY2ssUGY9ci51bnN0YWJsZV9jYW5jZWxDYWxsYmFjayxRZj1yLnVuc3RhYmxlX3Nob3VsZFlpZWxkLFJmPXIudW5zdGFibGVfcmVxdWVzdFBhaW50LFNmPXIudW5zdGFibGVfbm93LFRmPXIudW5zdGFibGVfZ2V0Q3VycmVudFByaW9yaXR5TGV2ZWwsVWY9ci51bnN0YWJsZV9JbW1lZGlhdGVQcmlvcml0eSxWZj1yLnVuc3RhYmxlX1VzZXJCbG9ja2luZ1ByaW9yaXR5LFdmPXIudW5zdGFibGVfTm9ybWFsUHJpb3JpdHksWGY9ci51bnN0YWJsZV9Mb3dQcmlvcml0eSxZZj1yLnVuc3RhYmxlX0lkbGVQcmlvcml0eSxaZj17fSwkZj12b2lkIDAhPT1SZj9SZjpmdW5jdGlvbigpe30sYWc9bnVsbCxiZz1udWxsLGNnPSExLGRnPVNmKCksTz0xRTQ+ZGc/U2Y6ZnVuY3Rpb24oKXtyZXR1cm4gU2YoKS1kZ307XG5mdW5jdGlvbiBlZygpe3N3aXRjaChUZigpKXtjYXNlIFVmOnJldHVybiA5OTtjYXNlIFZmOnJldHVybiA5ODtjYXNlIFdmOnJldHVybiA5NztjYXNlIFhmOnJldHVybiA5NjtjYXNlIFlmOnJldHVybiA5NTtkZWZhdWx0OnRocm93IEVycm9yKHkoMzMyKSk7fX1mdW5jdGlvbiBmZyhhKXtzd2l0Y2goYSl7Y2FzZSA5OTpyZXR1cm4gVWY7Y2FzZSA5ODpyZXR1cm4gVmY7Y2FzZSA5NzpyZXR1cm4gV2Y7Y2FzZSA5NjpyZXR1cm4gWGY7Y2FzZSA5NTpyZXR1cm4gWWY7ZGVmYXVsdDp0aHJvdyBFcnJvcih5KDMzMikpO319ZnVuY3Rpb24gZ2coYSxiKXthPWZnKGEpO3JldHVybiBOZihhLGIpfWZ1bmN0aW9uIGhnKGEsYixjKXthPWZnKGEpO3JldHVybiBPZihhLGIsYyl9ZnVuY3Rpb24gaWcoKXtpZihudWxsIT09Ymcpe3ZhciBhPWJnO2JnPW51bGw7UGYoYSl9amcoKX1cbmZ1bmN0aW9uIGpnKCl7aWYoIWNnJiZudWxsIT09YWcpe2NnPSEwO3ZhciBhPTA7dHJ5e3ZhciBiPWFnO2dnKDk5LGZ1bmN0aW9uKCl7Zm9yKDthPGIubGVuZ3RoO2ErKyl7dmFyIGM9YlthXTtkbyBjPWMoITApO3doaWxlKG51bGwhPT1jKX19KTthZz1udWxsfWNhdGNoKGMpe3Rocm93IG51bGwhPT1hZyYmKGFnPWFnLnNsaWNlKGErMSkpLE9mKFVmLGlnKSxjO31maW5hbGx5e2NnPSExfX19dmFyIGtnPXJhLlJlYWN0Q3VycmVudEJhdGNoQ29uZmlnO2Z1bmN0aW9uIGxnKGEsYil7aWYoYSYmYS5kZWZhdWx0UHJvcHMpe2I9bSh7fSxiKTthPWEuZGVmYXVsdFByb3BzO2Zvcih2YXIgYyBpbiBhKXZvaWQgMD09PWJbY10mJihiW2NdPWFbY10pO3JldHVybiBifXJldHVybiBifXZhciBtZz1CZihudWxsKSxuZz1udWxsLG9nPW51bGwscGc9bnVsbDtmdW5jdGlvbiBxZygpe3BnPW9nPW5nPW51bGx9XG5mdW5jdGlvbiByZyhhKXt2YXIgYj1tZy5jdXJyZW50O0gobWcpO2EudHlwZS5fY29udGV4dC5fY3VycmVudFZhbHVlPWJ9ZnVuY3Rpb24gc2coYSxiKXtmb3IoO251bGwhPT1hOyl7dmFyIGM9YS5hbHRlcm5hdGU7aWYoKGEuY2hpbGRMYW5lcyZiKT09PWIpaWYobnVsbD09PWN8fChjLmNoaWxkTGFuZXMmYik9PT1iKWJyZWFrO2Vsc2UgYy5jaGlsZExhbmVzfD1iO2Vsc2UgYS5jaGlsZExhbmVzfD1iLG51bGwhPT1jJiYoYy5jaGlsZExhbmVzfD1iKTthPWEucmV0dXJufX1mdW5jdGlvbiB0ZyhhLGIpe25nPWE7cGc9b2c9bnVsbDthPWEuZGVwZW5kZW5jaWVzO251bGwhPT1hJiZudWxsIT09YS5maXJzdENvbnRleHQmJigwIT09KGEubGFuZXMmYikmJih1Zz0hMCksYS5maXJzdENvbnRleHQ9bnVsbCl9XG5mdW5jdGlvbiB2ZyhhLGIpe2lmKHBnIT09YSYmITEhPT1iJiYwIT09Yil7aWYoXCJudW1iZXJcIiE9PXR5cGVvZiBifHwxMDczNzQxODIzPT09YilwZz1hLGI9MTA3Mzc0MTgyMztiPXtjb250ZXh0OmEsb2JzZXJ2ZWRCaXRzOmIsbmV4dDpudWxsfTtpZihudWxsPT09b2cpe2lmKG51bGw9PT1uZyl0aHJvdyBFcnJvcih5KDMwOCkpO29nPWI7bmcuZGVwZW5kZW5jaWVzPXtsYW5lczowLGZpcnN0Q29udGV4dDpiLHJlc3BvbmRlcnM6bnVsbH19ZWxzZSBvZz1vZy5uZXh0PWJ9cmV0dXJuIGEuX2N1cnJlbnRWYWx1ZX12YXIgd2c9ITE7ZnVuY3Rpb24geGcoYSl7YS51cGRhdGVRdWV1ZT17YmFzZVN0YXRlOmEubWVtb2l6ZWRTdGF0ZSxmaXJzdEJhc2VVcGRhdGU6bnVsbCxsYXN0QmFzZVVwZGF0ZTpudWxsLHNoYXJlZDp7cGVuZGluZzpudWxsfSxlZmZlY3RzOm51bGx9fVxuZnVuY3Rpb24geWcoYSxiKXthPWEudXBkYXRlUXVldWU7Yi51cGRhdGVRdWV1ZT09PWEmJihiLnVwZGF0ZVF1ZXVlPXtiYXNlU3RhdGU6YS5iYXNlU3RhdGUsZmlyc3RCYXNlVXBkYXRlOmEuZmlyc3RCYXNlVXBkYXRlLGxhc3RCYXNlVXBkYXRlOmEubGFzdEJhc2VVcGRhdGUsc2hhcmVkOmEuc2hhcmVkLGVmZmVjdHM6YS5lZmZlY3RzfSl9ZnVuY3Rpb24gemcoYSxiKXtyZXR1cm57ZXZlbnRUaW1lOmEsbGFuZTpiLHRhZzowLHBheWxvYWQ6bnVsbCxjYWxsYmFjazpudWxsLG5leHQ6bnVsbH19ZnVuY3Rpb24gQWcoYSxiKXthPWEudXBkYXRlUXVldWU7aWYobnVsbCE9PWEpe2E9YS5zaGFyZWQ7dmFyIGM9YS5wZW5kaW5nO251bGw9PT1jP2IubmV4dD1iOihiLm5leHQ9Yy5uZXh0LGMubmV4dD1iKTthLnBlbmRpbmc9Yn19XG5mdW5jdGlvbiBCZyhhLGIpe3ZhciBjPWEudXBkYXRlUXVldWUsZD1hLmFsdGVybmF0ZTtpZihudWxsIT09ZCYmKGQ9ZC51cGRhdGVRdWV1ZSxjPT09ZCkpe3ZhciBlPW51bGwsZj1udWxsO2M9Yy5maXJzdEJhc2VVcGRhdGU7aWYobnVsbCE9PWMpe2Rve3ZhciBnPXtldmVudFRpbWU6Yy5ldmVudFRpbWUsbGFuZTpjLmxhbmUsdGFnOmMudGFnLHBheWxvYWQ6Yy5wYXlsb2FkLGNhbGxiYWNrOmMuY2FsbGJhY2ssbmV4dDpudWxsfTtudWxsPT09Zj9lPWY9ZzpmPWYubmV4dD1nO2M9Yy5uZXh0fXdoaWxlKG51bGwhPT1jKTtudWxsPT09Zj9lPWY9YjpmPWYubmV4dD1ifWVsc2UgZT1mPWI7Yz17YmFzZVN0YXRlOmQuYmFzZVN0YXRlLGZpcnN0QmFzZVVwZGF0ZTplLGxhc3RCYXNlVXBkYXRlOmYsc2hhcmVkOmQuc2hhcmVkLGVmZmVjdHM6ZC5lZmZlY3RzfTthLnVwZGF0ZVF1ZXVlPWM7cmV0dXJufWE9Yy5sYXN0QmFzZVVwZGF0ZTtudWxsPT09YT9jLmZpcnN0QmFzZVVwZGF0ZT1iOmEubmV4dD1cbmI7Yy5sYXN0QmFzZVVwZGF0ZT1ifVxuZnVuY3Rpb24gQ2coYSxiLGMsZCl7dmFyIGU9YS51cGRhdGVRdWV1ZTt3Zz0hMTt2YXIgZj1lLmZpcnN0QmFzZVVwZGF0ZSxnPWUubGFzdEJhc2VVcGRhdGUsaD1lLnNoYXJlZC5wZW5kaW5nO2lmKG51bGwhPT1oKXtlLnNoYXJlZC5wZW5kaW5nPW51bGw7dmFyIGs9aCxsPWsubmV4dDtrLm5leHQ9bnVsbDtudWxsPT09Zz9mPWw6Zy5uZXh0PWw7Zz1rO3ZhciBuPWEuYWx0ZXJuYXRlO2lmKG51bGwhPT1uKXtuPW4udXBkYXRlUXVldWU7dmFyIEE9bi5sYXN0QmFzZVVwZGF0ZTtBIT09ZyYmKG51bGw9PT1BP24uZmlyc3RCYXNlVXBkYXRlPWw6QS5uZXh0PWwsbi5sYXN0QmFzZVVwZGF0ZT1rKX19aWYobnVsbCE9PWYpe0E9ZS5iYXNlU3RhdGU7Zz0wO249bD1rPW51bGw7ZG97aD1mLmxhbmU7dmFyIHA9Zi5ldmVudFRpbWU7aWYoKGQmaCk9PT1oKXtudWxsIT09biYmKG49bi5uZXh0PXtldmVudFRpbWU6cCxsYW5lOjAsdGFnOmYudGFnLHBheWxvYWQ6Zi5wYXlsb2FkLGNhbGxiYWNrOmYuY2FsbGJhY2ssXG5uZXh0Om51bGx9KTthOnt2YXIgQz1hLHg9ZjtoPWI7cD1jO3N3aXRjaCh4LnRhZyl7Y2FzZSAxOkM9eC5wYXlsb2FkO2lmKFwiZnVuY3Rpb25cIj09PXR5cGVvZiBDKXtBPUMuY2FsbChwLEEsaCk7YnJlYWsgYX1BPUM7YnJlYWsgYTtjYXNlIDM6Qy5mbGFncz1DLmZsYWdzJi00MDk3fDY0O2Nhc2UgMDpDPXgucGF5bG9hZDtoPVwiZnVuY3Rpb25cIj09PXR5cGVvZiBDP0MuY2FsbChwLEEsaCk6QztpZihudWxsPT09aHx8dm9pZCAwPT09aClicmVhayBhO0E9bSh7fSxBLGgpO2JyZWFrIGE7Y2FzZSAyOndnPSEwfX1udWxsIT09Zi5jYWxsYmFjayYmKGEuZmxhZ3N8PTMyLGg9ZS5lZmZlY3RzLG51bGw9PT1oP2UuZWZmZWN0cz1bZl06aC5wdXNoKGYpKX1lbHNlIHA9e2V2ZW50VGltZTpwLGxhbmU6aCx0YWc6Zi50YWcscGF5bG9hZDpmLnBheWxvYWQsY2FsbGJhY2s6Zi5jYWxsYmFjayxuZXh0Om51bGx9LG51bGw9PT1uPyhsPW49cCxrPUEpOm49bi5uZXh0PXAsZ3w9aDtmPWYubmV4dDtpZihudWxsPT09XG5mKWlmKGg9ZS5zaGFyZWQucGVuZGluZyxudWxsPT09aClicmVhaztlbHNlIGY9aC5uZXh0LGgubmV4dD1udWxsLGUubGFzdEJhc2VVcGRhdGU9aCxlLnNoYXJlZC5wZW5kaW5nPW51bGx9d2hpbGUoMSk7bnVsbD09PW4mJihrPUEpO2UuYmFzZVN0YXRlPWs7ZS5maXJzdEJhc2VVcGRhdGU9bDtlLmxhc3RCYXNlVXBkYXRlPW47RGd8PWc7YS5sYW5lcz1nO2EubWVtb2l6ZWRTdGF0ZT1BfX1mdW5jdGlvbiBFZyhhLGIsYyl7YT1iLmVmZmVjdHM7Yi5lZmZlY3RzPW51bGw7aWYobnVsbCE9PWEpZm9yKGI9MDtiPGEubGVuZ3RoO2IrKyl7dmFyIGQ9YVtiXSxlPWQuY2FsbGJhY2s7aWYobnVsbCE9PWUpe2QuY2FsbGJhY2s9bnVsbDtkPWM7aWYoXCJmdW5jdGlvblwiIT09dHlwZW9mIGUpdGhyb3cgRXJyb3IoeSgxOTEsZSkpO2UuY2FsbChkKX19fXZhciBGZz0obmV3IGFhLkNvbXBvbmVudCkucmVmcztcbmZ1bmN0aW9uIEdnKGEsYixjLGQpe2I9YS5tZW1vaXplZFN0YXRlO2M9YyhkLGIpO2M9bnVsbD09PWN8fHZvaWQgMD09PWM/YjptKHt9LGIsYyk7YS5tZW1vaXplZFN0YXRlPWM7MD09PWEubGFuZXMmJihhLnVwZGF0ZVF1ZXVlLmJhc2VTdGF0ZT1jKX1cbnZhciBLZz17aXNNb3VudGVkOmZ1bmN0aW9uKGEpe3JldHVybihhPWEuX3JlYWN0SW50ZXJuYWxzKT9aYihhKT09PWE6ITF9LGVucXVldWVTZXRTdGF0ZTpmdW5jdGlvbihhLGIsYyl7YT1hLl9yZWFjdEludGVybmFsczt2YXIgZD1IZygpLGU9SWcoYSksZj16ZyhkLGUpO2YucGF5bG9hZD1iO3ZvaWQgMCE9PWMmJm51bGwhPT1jJiYoZi5jYWxsYmFjaz1jKTtBZyhhLGYpO0pnKGEsZSxkKX0sZW5xdWV1ZVJlcGxhY2VTdGF0ZTpmdW5jdGlvbihhLGIsYyl7YT1hLl9yZWFjdEludGVybmFsczt2YXIgZD1IZygpLGU9SWcoYSksZj16ZyhkLGUpO2YudGFnPTE7Zi5wYXlsb2FkPWI7dm9pZCAwIT09YyYmbnVsbCE9PWMmJihmLmNhbGxiYWNrPWMpO0FnKGEsZik7SmcoYSxlLGQpfSxlbnF1ZXVlRm9yY2VVcGRhdGU6ZnVuY3Rpb24oYSxiKXthPWEuX3JlYWN0SW50ZXJuYWxzO3ZhciBjPUhnKCksZD1JZyhhKSxlPXpnKGMsZCk7ZS50YWc9Mjt2b2lkIDAhPT1iJiZudWxsIT09YiYmKGUuY2FsbGJhY2s9XG5iKTtBZyhhLGUpO0pnKGEsZCxjKX19O2Z1bmN0aW9uIExnKGEsYixjLGQsZSxmLGcpe2E9YS5zdGF0ZU5vZGU7cmV0dXJuXCJmdW5jdGlvblwiPT09dHlwZW9mIGEuc2hvdWxkQ29tcG9uZW50VXBkYXRlP2Euc2hvdWxkQ29tcG9uZW50VXBkYXRlKGQsZixnKTpiLnByb3RvdHlwZSYmYi5wcm90b3R5cGUuaXNQdXJlUmVhY3RDb21wb25lbnQ/IUplKGMsZCl8fCFKZShlLGYpOiEwfVxuZnVuY3Rpb24gTWcoYSxiLGMpe3ZhciBkPSExLGU9Q2Y7dmFyIGY9Yi5jb250ZXh0VHlwZTtcIm9iamVjdFwiPT09dHlwZW9mIGYmJm51bGwhPT1mP2Y9dmcoZik6KGU9RmYoYik/RGY6TS5jdXJyZW50LGQ9Yi5jb250ZXh0VHlwZXMsZj0oZD1udWxsIT09ZCYmdm9pZCAwIT09ZCk/RWYoYSxlKTpDZik7Yj1uZXcgYihjLGYpO2EubWVtb2l6ZWRTdGF0ZT1udWxsIT09Yi5zdGF0ZSYmdm9pZCAwIT09Yi5zdGF0ZT9iLnN0YXRlOm51bGw7Yi51cGRhdGVyPUtnO2Euc3RhdGVOb2RlPWI7Yi5fcmVhY3RJbnRlcm5hbHM9YTtkJiYoYT1hLnN0YXRlTm9kZSxhLl9fcmVhY3RJbnRlcm5hbE1lbW9pemVkVW5tYXNrZWRDaGlsZENvbnRleHQ9ZSxhLl9fcmVhY3RJbnRlcm5hbE1lbW9pemVkTWFza2VkQ2hpbGRDb250ZXh0PWYpO3JldHVybiBifVxuZnVuY3Rpb24gTmcoYSxiLGMsZCl7YT1iLnN0YXRlO1wiZnVuY3Rpb25cIj09PXR5cGVvZiBiLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMmJmIuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhjLGQpO1wiZnVuY3Rpb25cIj09PXR5cGVvZiBiLlVOU0FGRV9jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzJiZiLlVOU0FGRV9jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKGMsZCk7Yi5zdGF0ZSE9PWEmJktnLmVucXVldWVSZXBsYWNlU3RhdGUoYixiLnN0YXRlLG51bGwpfVxuZnVuY3Rpb24gT2coYSxiLGMsZCl7dmFyIGU9YS5zdGF0ZU5vZGU7ZS5wcm9wcz1jO2Uuc3RhdGU9YS5tZW1vaXplZFN0YXRlO2UucmVmcz1GZzt4ZyhhKTt2YXIgZj1iLmNvbnRleHRUeXBlO1wib2JqZWN0XCI9PT10eXBlb2YgZiYmbnVsbCE9PWY/ZS5jb250ZXh0PXZnKGYpOihmPUZmKGIpP0RmOk0uY3VycmVudCxlLmNvbnRleHQ9RWYoYSxmKSk7Q2coYSxjLGUsZCk7ZS5zdGF0ZT1hLm1lbW9pemVkU3RhdGU7Zj1iLmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcztcImZ1bmN0aW9uXCI9PT10eXBlb2YgZiYmKEdnKGEsYixmLGMpLGUuc3RhdGU9YS5tZW1vaXplZFN0YXRlKTtcImZ1bmN0aW9uXCI9PT10eXBlb2YgYi5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHN8fFwiZnVuY3Rpb25cIj09PXR5cGVvZiBlLmdldFNuYXBzaG90QmVmb3JlVXBkYXRlfHxcImZ1bmN0aW9uXCIhPT10eXBlb2YgZS5VTlNBRkVfY29tcG9uZW50V2lsbE1vdW50JiZcImZ1bmN0aW9uXCIhPT10eXBlb2YgZS5jb21wb25lbnRXaWxsTW91bnR8fFxuKGI9ZS5zdGF0ZSxcImZ1bmN0aW9uXCI9PT10eXBlb2YgZS5jb21wb25lbnRXaWxsTW91bnQmJmUuY29tcG9uZW50V2lsbE1vdW50KCksXCJmdW5jdGlvblwiPT09dHlwZW9mIGUuVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudCYmZS5VTlNBRkVfY29tcG9uZW50V2lsbE1vdW50KCksYiE9PWUuc3RhdGUmJktnLmVucXVldWVSZXBsYWNlU3RhdGUoZSxlLnN0YXRlLG51bGwpLENnKGEsYyxlLGQpLGUuc3RhdGU9YS5tZW1vaXplZFN0YXRlKTtcImZ1bmN0aW9uXCI9PT10eXBlb2YgZS5jb21wb25lbnREaWRNb3VudCYmKGEuZmxhZ3N8PTQpfXZhciBQZz1BcnJheS5pc0FycmF5O1xuZnVuY3Rpb24gUWcoYSxiLGMpe2E9Yy5yZWY7aWYobnVsbCE9PWEmJlwiZnVuY3Rpb25cIiE9PXR5cGVvZiBhJiZcIm9iamVjdFwiIT09dHlwZW9mIGEpe2lmKGMuX293bmVyKXtjPWMuX293bmVyO2lmKGMpe2lmKDEhPT1jLnRhZyl0aHJvdyBFcnJvcih5KDMwOSkpO3ZhciBkPWMuc3RhdGVOb2RlfWlmKCFkKXRocm93IEVycm9yKHkoMTQ3LGEpKTt2YXIgZT1cIlwiK2E7aWYobnVsbCE9PWImJm51bGwhPT1iLnJlZiYmXCJmdW5jdGlvblwiPT09dHlwZW9mIGIucmVmJiZiLnJlZi5fc3RyaW5nUmVmPT09ZSlyZXR1cm4gYi5yZWY7Yj1mdW5jdGlvbihhKXt2YXIgYj1kLnJlZnM7Yj09PUZnJiYoYj1kLnJlZnM9e30pO251bGw9PT1hP2RlbGV0ZSBiW2VdOmJbZV09YX07Yi5fc3RyaW5nUmVmPWU7cmV0dXJuIGJ9aWYoXCJzdHJpbmdcIiE9PXR5cGVvZiBhKXRocm93IEVycm9yKHkoMjg0KSk7aWYoIWMuX293bmVyKXRocm93IEVycm9yKHkoMjkwLGEpKTt9cmV0dXJuIGF9XG5mdW5jdGlvbiBSZyhhLGIpe2lmKFwidGV4dGFyZWFcIiE9PWEudHlwZSl0aHJvdyBFcnJvcih5KDMxLFwiW29iamVjdCBPYmplY3RdXCI9PT1PYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoYik/XCJvYmplY3Qgd2l0aCBrZXlzIHtcIitPYmplY3Qua2V5cyhiKS5qb2luKFwiLCBcIikrXCJ9XCI6YikpO31cbmZ1bmN0aW9uIFNnKGEpe2Z1bmN0aW9uIGIoYixjKXtpZihhKXt2YXIgZD1iLmxhc3RFZmZlY3Q7bnVsbCE9PWQ/KGQubmV4dEVmZmVjdD1jLGIubGFzdEVmZmVjdD1jKTpiLmZpcnN0RWZmZWN0PWIubGFzdEVmZmVjdD1jO2MubmV4dEVmZmVjdD1udWxsO2MuZmxhZ3M9OH19ZnVuY3Rpb24gYyhjLGQpe2lmKCFhKXJldHVybiBudWxsO2Zvcig7bnVsbCE9PWQ7KWIoYyxkKSxkPWQuc2libGluZztyZXR1cm4gbnVsbH1mdW5jdGlvbiBkKGEsYil7Zm9yKGE9bmV3IE1hcDtudWxsIT09YjspbnVsbCE9PWIua2V5P2Euc2V0KGIua2V5LGIpOmEuc2V0KGIuaW5kZXgsYiksYj1iLnNpYmxpbmc7cmV0dXJuIGF9ZnVuY3Rpb24gZShhLGIpe2E9VGcoYSxiKTthLmluZGV4PTA7YS5zaWJsaW5nPW51bGw7cmV0dXJuIGF9ZnVuY3Rpb24gZihiLGMsZCl7Yi5pbmRleD1kO2lmKCFhKXJldHVybiBjO2Q9Yi5hbHRlcm5hdGU7aWYobnVsbCE9PWQpcmV0dXJuIGQ9ZC5pbmRleCxkPGM/KGIuZmxhZ3M9MixcbmMpOmQ7Yi5mbGFncz0yO3JldHVybiBjfWZ1bmN0aW9uIGcoYil7YSYmbnVsbD09PWIuYWx0ZXJuYXRlJiYoYi5mbGFncz0yKTtyZXR1cm4gYn1mdW5jdGlvbiBoKGEsYixjLGQpe2lmKG51bGw9PT1ifHw2IT09Yi50YWcpcmV0dXJuIGI9VWcoYyxhLm1vZGUsZCksYi5yZXR1cm49YSxiO2I9ZShiLGMpO2IucmV0dXJuPWE7cmV0dXJuIGJ9ZnVuY3Rpb24gayhhLGIsYyxkKXtpZihudWxsIT09YiYmYi5lbGVtZW50VHlwZT09PWMudHlwZSlyZXR1cm4gZD1lKGIsYy5wcm9wcyksZC5yZWY9UWcoYSxiLGMpLGQucmV0dXJuPWEsZDtkPVZnKGMudHlwZSxjLmtleSxjLnByb3BzLG51bGwsYS5tb2RlLGQpO2QucmVmPVFnKGEsYixjKTtkLnJldHVybj1hO3JldHVybiBkfWZ1bmN0aW9uIGwoYSxiLGMsZCl7aWYobnVsbD09PWJ8fDQhPT1iLnRhZ3x8Yi5zdGF0ZU5vZGUuY29udGFpbmVySW5mbyE9PWMuY29udGFpbmVySW5mb3x8Yi5zdGF0ZU5vZGUuaW1wbGVtZW50YXRpb24hPT1jLmltcGxlbWVudGF0aW9uKXJldHVybiBiPVxuV2coYyxhLm1vZGUsZCksYi5yZXR1cm49YSxiO2I9ZShiLGMuY2hpbGRyZW58fFtdKTtiLnJldHVybj1hO3JldHVybiBifWZ1bmN0aW9uIG4oYSxiLGMsZCxmKXtpZihudWxsPT09Ynx8NyE9PWIudGFnKXJldHVybiBiPVhnKGMsYS5tb2RlLGQsZiksYi5yZXR1cm49YSxiO2I9ZShiLGMpO2IucmV0dXJuPWE7cmV0dXJuIGJ9ZnVuY3Rpb24gQShhLGIsYyl7aWYoXCJzdHJpbmdcIj09PXR5cGVvZiBifHxcIm51bWJlclwiPT09dHlwZW9mIGIpcmV0dXJuIGI9VWcoXCJcIitiLGEubW9kZSxjKSxiLnJldHVybj1hLGI7aWYoXCJvYmplY3RcIj09PXR5cGVvZiBiJiZudWxsIT09Yil7c3dpdGNoKGIuJCR0eXBlb2Ype2Nhc2Ugc2E6cmV0dXJuIGM9VmcoYi50eXBlLGIua2V5LGIucHJvcHMsbnVsbCxhLm1vZGUsYyksYy5yZWY9UWcoYSxudWxsLGIpLGMucmV0dXJuPWEsYztjYXNlIHRhOnJldHVybiBiPVdnKGIsYS5tb2RlLGMpLGIucmV0dXJuPWEsYn1pZihQZyhiKXx8TGEoYikpcmV0dXJuIGI9WGcoYixcbmEubW9kZSxjLG51bGwpLGIucmV0dXJuPWEsYjtSZyhhLGIpfXJldHVybiBudWxsfWZ1bmN0aW9uIHAoYSxiLGMsZCl7dmFyIGU9bnVsbCE9PWI/Yi5rZXk6bnVsbDtpZihcInN0cmluZ1wiPT09dHlwZW9mIGN8fFwibnVtYmVyXCI9PT10eXBlb2YgYylyZXR1cm4gbnVsbCE9PWU/bnVsbDpoKGEsYixcIlwiK2MsZCk7aWYoXCJvYmplY3RcIj09PXR5cGVvZiBjJiZudWxsIT09Yyl7c3dpdGNoKGMuJCR0eXBlb2Ype2Nhc2Ugc2E6cmV0dXJuIGMua2V5PT09ZT9jLnR5cGU9PT11YT9uKGEsYixjLnByb3BzLmNoaWxkcmVuLGQsZSk6ayhhLGIsYyxkKTpudWxsO2Nhc2UgdGE6cmV0dXJuIGMua2V5PT09ZT9sKGEsYixjLGQpOm51bGx9aWYoUGcoYyl8fExhKGMpKXJldHVybiBudWxsIT09ZT9udWxsOm4oYSxiLGMsZCxudWxsKTtSZyhhLGMpfXJldHVybiBudWxsfWZ1bmN0aW9uIEMoYSxiLGMsZCxlKXtpZihcInN0cmluZ1wiPT09dHlwZW9mIGR8fFwibnVtYmVyXCI9PT10eXBlb2YgZClyZXR1cm4gYT1hLmdldChjKXx8XG5udWxsLGgoYixhLFwiXCIrZCxlKTtpZihcIm9iamVjdFwiPT09dHlwZW9mIGQmJm51bGwhPT1kKXtzd2l0Y2goZC4kJHR5cGVvZil7Y2FzZSBzYTpyZXR1cm4gYT1hLmdldChudWxsPT09ZC5rZXk/YzpkLmtleSl8fG51bGwsZC50eXBlPT09dWE/bihiLGEsZC5wcm9wcy5jaGlsZHJlbixlLGQua2V5KTprKGIsYSxkLGUpO2Nhc2UgdGE6cmV0dXJuIGE9YS5nZXQobnVsbD09PWQua2V5P2M6ZC5rZXkpfHxudWxsLGwoYixhLGQsZSl9aWYoUGcoZCl8fExhKGQpKXJldHVybiBhPWEuZ2V0KGMpfHxudWxsLG4oYixhLGQsZSxudWxsKTtSZyhiLGQpfXJldHVybiBudWxsfWZ1bmN0aW9uIHgoZSxnLGgsayl7Zm9yKHZhciBsPW51bGwsdD1udWxsLHU9Zyx6PWc9MCxxPW51bGw7bnVsbCE9PXUmJno8aC5sZW5ndGg7eisrKXt1LmluZGV4Pno/KHE9dSx1PW51bGwpOnE9dS5zaWJsaW5nO3ZhciBuPXAoZSx1LGhbel0sayk7aWYobnVsbD09PW4pe251bGw9PT11JiYodT1xKTticmVha31hJiZ1JiZudWxsPT09XG5uLmFsdGVybmF0ZSYmYihlLHUpO2c9ZihuLGcseik7bnVsbD09PXQ/bD1uOnQuc2libGluZz1uO3Q9bjt1PXF9aWYoej09PWgubGVuZ3RoKXJldHVybiBjKGUsdSksbDtpZihudWxsPT09dSl7Zm9yKDt6PGgubGVuZ3RoO3orKyl1PUEoZSxoW3pdLGspLG51bGwhPT11JiYoZz1mKHUsZyx6KSxudWxsPT09dD9sPXU6dC5zaWJsaW5nPXUsdD11KTtyZXR1cm4gbH1mb3IodT1kKGUsdSk7ejxoLmxlbmd0aDt6KyspcT1DKHUsZSx6LGhbel0sayksbnVsbCE9PXEmJihhJiZudWxsIT09cS5hbHRlcm5hdGUmJnUuZGVsZXRlKG51bGw9PT1xLmtleT96OnEua2V5KSxnPWYocSxnLHopLG51bGw9PT10P2w9cTp0LnNpYmxpbmc9cSx0PXEpO2EmJnUuZm9yRWFjaChmdW5jdGlvbihhKXtyZXR1cm4gYihlLGEpfSk7cmV0dXJuIGx9ZnVuY3Rpb24gdyhlLGcsaCxrKXt2YXIgbD1MYShoKTtpZihcImZ1bmN0aW9uXCIhPT10eXBlb2YgbCl0aHJvdyBFcnJvcih5KDE1MCkpO2g9bC5jYWxsKGgpO2lmKG51bGw9PVxuaCl0aHJvdyBFcnJvcih5KDE1MSkpO2Zvcih2YXIgdD1sPW51bGwsdT1nLHo9Zz0wLHE9bnVsbCxuPWgubmV4dCgpO251bGwhPT11JiYhbi5kb25lO3orKyxuPWgubmV4dCgpKXt1LmluZGV4Pno/KHE9dSx1PW51bGwpOnE9dS5zaWJsaW5nO3ZhciB3PXAoZSx1LG4udmFsdWUsayk7aWYobnVsbD09PXcpe251bGw9PT11JiYodT1xKTticmVha31hJiZ1JiZudWxsPT09dy5hbHRlcm5hdGUmJmIoZSx1KTtnPWYodyxnLHopO251bGw9PT10P2w9dzp0LnNpYmxpbmc9dzt0PXc7dT1xfWlmKG4uZG9uZSlyZXR1cm4gYyhlLHUpLGw7aWYobnVsbD09PXUpe2Zvcig7IW4uZG9uZTt6Kyssbj1oLm5leHQoKSluPUEoZSxuLnZhbHVlLGspLG51bGwhPT1uJiYoZz1mKG4sZyx6KSxudWxsPT09dD9sPW46dC5zaWJsaW5nPW4sdD1uKTtyZXR1cm4gbH1mb3IodT1kKGUsdSk7IW4uZG9uZTt6Kyssbj1oLm5leHQoKSluPUModSxlLHosbi52YWx1ZSxrKSxudWxsIT09biYmKGEmJm51bGwhPT1uLmFsdGVybmF0ZSYmXG51LmRlbGV0ZShudWxsPT09bi5rZXk/ejpuLmtleSksZz1mKG4sZyx6KSxudWxsPT09dD9sPW46dC5zaWJsaW5nPW4sdD1uKTthJiZ1LmZvckVhY2goZnVuY3Rpb24oYSl7cmV0dXJuIGIoZSxhKX0pO3JldHVybiBsfXJldHVybiBmdW5jdGlvbihhLGQsZixoKXt2YXIgaz1cIm9iamVjdFwiPT09dHlwZW9mIGYmJm51bGwhPT1mJiZmLnR5cGU9PT11YSYmbnVsbD09PWYua2V5O2smJihmPWYucHJvcHMuY2hpbGRyZW4pO3ZhciBsPVwib2JqZWN0XCI9PT10eXBlb2YgZiYmbnVsbCE9PWY7aWYobClzd2l0Y2goZi4kJHR5cGVvZil7Y2FzZSBzYTphOntsPWYua2V5O2ZvcihrPWQ7bnVsbCE9PWs7KXtpZihrLmtleT09PWwpe3N3aXRjaChrLnRhZyl7Y2FzZSA3OmlmKGYudHlwZT09PXVhKXtjKGEsay5zaWJsaW5nKTtkPWUoayxmLnByb3BzLmNoaWxkcmVuKTtkLnJldHVybj1hO2E9ZDticmVhayBhfWJyZWFrO2RlZmF1bHQ6aWYoay5lbGVtZW50VHlwZT09PWYudHlwZSl7YyhhLGsuc2libGluZyk7XG5kPWUoayxmLnByb3BzKTtkLnJlZj1RZyhhLGssZik7ZC5yZXR1cm49YTthPWQ7YnJlYWsgYX19YyhhLGspO2JyZWFrfWVsc2UgYihhLGspO2s9ay5zaWJsaW5nfWYudHlwZT09PXVhPyhkPVhnKGYucHJvcHMuY2hpbGRyZW4sYS5tb2RlLGgsZi5rZXkpLGQucmV0dXJuPWEsYT1kKTooaD1WZyhmLnR5cGUsZi5rZXksZi5wcm9wcyxudWxsLGEubW9kZSxoKSxoLnJlZj1RZyhhLGQsZiksaC5yZXR1cm49YSxhPWgpfXJldHVybiBnKGEpO2Nhc2UgdGE6YTp7Zm9yKGs9Zi5rZXk7bnVsbCE9PWQ7KXtpZihkLmtleT09PWspaWYoND09PWQudGFnJiZkLnN0YXRlTm9kZS5jb250YWluZXJJbmZvPT09Zi5jb250YWluZXJJbmZvJiZkLnN0YXRlTm9kZS5pbXBsZW1lbnRhdGlvbj09PWYuaW1wbGVtZW50YXRpb24pe2MoYSxkLnNpYmxpbmcpO2Q9ZShkLGYuY2hpbGRyZW58fFtdKTtkLnJldHVybj1hO2E9ZDticmVhayBhfWVsc2V7YyhhLGQpO2JyZWFrfWVsc2UgYihhLGQpO2Q9ZC5zaWJsaW5nfWQ9XG5XZyhmLGEubW9kZSxoKTtkLnJldHVybj1hO2E9ZH1yZXR1cm4gZyhhKX1pZihcInN0cmluZ1wiPT09dHlwZW9mIGZ8fFwibnVtYmVyXCI9PT10eXBlb2YgZilyZXR1cm4gZj1cIlwiK2YsbnVsbCE9PWQmJjY9PT1kLnRhZz8oYyhhLGQuc2libGluZyksZD1lKGQsZiksZC5yZXR1cm49YSxhPWQpOihjKGEsZCksZD1VZyhmLGEubW9kZSxoKSxkLnJldHVybj1hLGE9ZCksZyhhKTtpZihQZyhmKSlyZXR1cm4geChhLGQsZixoKTtpZihMYShmKSlyZXR1cm4gdyhhLGQsZixoKTtsJiZSZyhhLGYpO2lmKFwidW5kZWZpbmVkXCI9PT10eXBlb2YgZiYmIWspc3dpdGNoKGEudGFnKXtjYXNlIDE6Y2FzZSAyMjpjYXNlIDA6Y2FzZSAxMTpjYXNlIDE1OnRocm93IEVycm9yKHkoMTUyLFJhKGEudHlwZSl8fFwiQ29tcG9uZW50XCIpKTt9cmV0dXJuIGMoYSxkKX19dmFyIFlnPVNnKCEwKSxaZz1TZyghMSksJGc9e30sYWg9QmYoJGcpLGJoPUJmKCRnKSxjaD1CZigkZyk7XG5mdW5jdGlvbiBkaChhKXtpZihhPT09JGcpdGhyb3cgRXJyb3IoeSgxNzQpKTtyZXR1cm4gYX1mdW5jdGlvbiBlaChhLGIpe0koY2gsYik7SShiaCxhKTtJKGFoLCRnKTthPWIubm9kZVR5cGU7c3dpdGNoKGEpe2Nhc2UgOTpjYXNlIDExOmI9KGI9Yi5kb2N1bWVudEVsZW1lbnQpP2IubmFtZXNwYWNlVVJJOm1iKG51bGwsXCJcIik7YnJlYWs7ZGVmYXVsdDphPTg9PT1hP2IucGFyZW50Tm9kZTpiLGI9YS5uYW1lc3BhY2VVUkl8fG51bGwsYT1hLnRhZ05hbWUsYj1tYihiLGEpfUgoYWgpO0koYWgsYil9ZnVuY3Rpb24gZmgoKXtIKGFoKTtIKGJoKTtIKGNoKX1mdW5jdGlvbiBnaChhKXtkaChjaC5jdXJyZW50KTt2YXIgYj1kaChhaC5jdXJyZW50KTt2YXIgYz1tYihiLGEudHlwZSk7YiE9PWMmJihJKGJoLGEpLEkoYWgsYykpfWZ1bmN0aW9uIGhoKGEpe2JoLmN1cnJlbnQ9PT1hJiYoSChhaCksSChiaCkpfXZhciBQPUJmKDApO1xuZnVuY3Rpb24gaWgoYSl7Zm9yKHZhciBiPWE7bnVsbCE9PWI7KXtpZigxMz09PWIudGFnKXt2YXIgYz1iLm1lbW9pemVkU3RhdGU7aWYobnVsbCE9PWMmJihjPWMuZGVoeWRyYXRlZCxudWxsPT09Y3x8XCIkP1wiPT09Yy5kYXRhfHxcIiQhXCI9PT1jLmRhdGEpKXJldHVybiBifWVsc2UgaWYoMTk9PT1iLnRhZyYmdm9pZCAwIT09Yi5tZW1vaXplZFByb3BzLnJldmVhbE9yZGVyKXtpZigwIT09KGIuZmxhZ3MmNjQpKXJldHVybiBifWVsc2UgaWYobnVsbCE9PWIuY2hpbGQpe2IuY2hpbGQucmV0dXJuPWI7Yj1iLmNoaWxkO2NvbnRpbnVlfWlmKGI9PT1hKWJyZWFrO2Zvcig7bnVsbD09PWIuc2libGluZzspe2lmKG51bGw9PT1iLnJldHVybnx8Yi5yZXR1cm49PT1hKXJldHVybiBudWxsO2I9Yi5yZXR1cm59Yi5zaWJsaW5nLnJldHVybj1iLnJldHVybjtiPWIuc2libGluZ31yZXR1cm4gbnVsbH12YXIgamg9bnVsbCxraD1udWxsLGxoPSExO1xuZnVuY3Rpb24gbWgoYSxiKXt2YXIgYz1uaCg1LG51bGwsbnVsbCwwKTtjLmVsZW1lbnRUeXBlPVwiREVMRVRFRFwiO2MudHlwZT1cIkRFTEVURURcIjtjLnN0YXRlTm9kZT1iO2MucmV0dXJuPWE7Yy5mbGFncz04O251bGwhPT1hLmxhc3RFZmZlY3Q/KGEubGFzdEVmZmVjdC5uZXh0RWZmZWN0PWMsYS5sYXN0RWZmZWN0PWMpOmEuZmlyc3RFZmZlY3Q9YS5sYXN0RWZmZWN0PWN9ZnVuY3Rpb24gb2goYSxiKXtzd2l0Y2goYS50YWcpe2Nhc2UgNTp2YXIgYz1hLnR5cGU7Yj0xIT09Yi5ub2RlVHlwZXx8Yy50b0xvd2VyQ2FzZSgpIT09Yi5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpP251bGw6YjtyZXR1cm4gbnVsbCE9PWI/KGEuc3RhdGVOb2RlPWIsITApOiExO2Nhc2UgNjpyZXR1cm4gYj1cIlwiPT09YS5wZW5kaW5nUHJvcHN8fDMhPT1iLm5vZGVUeXBlP251bGw6YixudWxsIT09Yj8oYS5zdGF0ZU5vZGU9YiwhMCk6ITE7Y2FzZSAxMzpyZXR1cm4hMTtkZWZhdWx0OnJldHVybiExfX1cbmZ1bmN0aW9uIHBoKGEpe2lmKGxoKXt2YXIgYj1raDtpZihiKXt2YXIgYz1iO2lmKCFvaChhLGIpKXtiPXJmKGMubmV4dFNpYmxpbmcpO2lmKCFifHwhb2goYSxiKSl7YS5mbGFncz1hLmZsYWdzJi0xMDI1fDI7bGg9ITE7amg9YTtyZXR1cm59bWgoamgsYyl9amg9YTtraD1yZihiLmZpcnN0Q2hpbGQpfWVsc2UgYS5mbGFncz1hLmZsYWdzJi0xMDI1fDIsbGg9ITEsamg9YX19ZnVuY3Rpb24gcWgoYSl7Zm9yKGE9YS5yZXR1cm47bnVsbCE9PWEmJjUhPT1hLnRhZyYmMyE9PWEudGFnJiYxMyE9PWEudGFnOylhPWEucmV0dXJuO2poPWF9XG5mdW5jdGlvbiByaChhKXtpZihhIT09amgpcmV0dXJuITE7aWYoIWxoKXJldHVybiBxaChhKSxsaD0hMCwhMTt2YXIgYj1hLnR5cGU7aWYoNSE9PWEudGFnfHxcImhlYWRcIiE9PWImJlwiYm9keVwiIT09YiYmIW5mKGIsYS5tZW1vaXplZFByb3BzKSlmb3IoYj1raDtiOyltaChhLGIpLGI9cmYoYi5uZXh0U2libGluZyk7cWgoYSk7aWYoMTM9PT1hLnRhZyl7YT1hLm1lbW9pemVkU3RhdGU7YT1udWxsIT09YT9hLmRlaHlkcmF0ZWQ6bnVsbDtpZighYSl0aHJvdyBFcnJvcih5KDMxNykpO2E6e2E9YS5uZXh0U2libGluZztmb3IoYj0wO2E7KXtpZig4PT09YS5ub2RlVHlwZSl7dmFyIGM9YS5kYXRhO2lmKFwiLyRcIj09PWMpe2lmKDA9PT1iKXtraD1yZihhLm5leHRTaWJsaW5nKTticmVhayBhfWItLX1lbHNlXCIkXCIhPT1jJiZcIiQhXCIhPT1jJiZcIiQ/XCIhPT1jfHxiKyt9YT1hLm5leHRTaWJsaW5nfWtoPW51bGx9fWVsc2Uga2g9amg/cmYoYS5zdGF0ZU5vZGUubmV4dFNpYmxpbmcpOm51bGw7cmV0dXJuITB9XG5mdW5jdGlvbiBzaCgpe2toPWpoPW51bGw7bGg9ITF9dmFyIHRoPVtdO2Z1bmN0aW9uIHVoKCl7Zm9yKHZhciBhPTA7YTx0aC5sZW5ndGg7YSsrKXRoW2FdLl93b3JrSW5Qcm9ncmVzc1ZlcnNpb25QcmltYXJ5PW51bGw7dGgubGVuZ3RoPTB9dmFyIHZoPXJhLlJlYWN0Q3VycmVudERpc3BhdGNoZXIsd2g9cmEuUmVhY3RDdXJyZW50QmF0Y2hDb25maWcseGg9MCxSPW51bGwsUz1udWxsLFQ9bnVsbCx5aD0hMSx6aD0hMTtmdW5jdGlvbiBBaCgpe3Rocm93IEVycm9yKHkoMzIxKSk7fWZ1bmN0aW9uIEJoKGEsYil7aWYobnVsbD09PWIpcmV0dXJuITE7Zm9yKHZhciBjPTA7YzxiLmxlbmd0aCYmYzxhLmxlbmd0aDtjKyspaWYoIUhlKGFbY10sYltjXSkpcmV0dXJuITE7cmV0dXJuITB9XG5mdW5jdGlvbiBDaChhLGIsYyxkLGUsZil7eGg9ZjtSPWI7Yi5tZW1vaXplZFN0YXRlPW51bGw7Yi51cGRhdGVRdWV1ZT1udWxsO2IubGFuZXM9MDt2aC5jdXJyZW50PW51bGw9PT1hfHxudWxsPT09YS5tZW1vaXplZFN0YXRlP0RoOkVoO2E9YyhkLGUpO2lmKHpoKXtmPTA7ZG97emg9ITE7aWYoISgyNT5mKSl0aHJvdyBFcnJvcih5KDMwMSkpO2YrPTE7VD1TPW51bGw7Yi51cGRhdGVRdWV1ZT1udWxsO3ZoLmN1cnJlbnQ9Rmg7YT1jKGQsZSl9d2hpbGUoemgpfXZoLmN1cnJlbnQ9R2g7Yj1udWxsIT09UyYmbnVsbCE9PVMubmV4dDt4aD0wO1Q9Uz1SPW51bGw7eWg9ITE7aWYoYil0aHJvdyBFcnJvcih5KDMwMCkpO3JldHVybiBhfWZ1bmN0aW9uIEhoKCl7dmFyIGE9e21lbW9pemVkU3RhdGU6bnVsbCxiYXNlU3RhdGU6bnVsbCxiYXNlUXVldWU6bnVsbCxxdWV1ZTpudWxsLG5leHQ6bnVsbH07bnVsbD09PVQ/Ui5tZW1vaXplZFN0YXRlPVQ9YTpUPVQubmV4dD1hO3JldHVybiBUfVxuZnVuY3Rpb24gSWgoKXtpZihudWxsPT09Uyl7dmFyIGE9Ui5hbHRlcm5hdGU7YT1udWxsIT09YT9hLm1lbW9pemVkU3RhdGU6bnVsbH1lbHNlIGE9Uy5uZXh0O3ZhciBiPW51bGw9PT1UP1IubWVtb2l6ZWRTdGF0ZTpULm5leHQ7aWYobnVsbCE9PWIpVD1iLFM9YTtlbHNle2lmKG51bGw9PT1hKXRocm93IEVycm9yKHkoMzEwKSk7Uz1hO2E9e21lbW9pemVkU3RhdGU6Uy5tZW1vaXplZFN0YXRlLGJhc2VTdGF0ZTpTLmJhc2VTdGF0ZSxiYXNlUXVldWU6Uy5iYXNlUXVldWUscXVldWU6Uy5xdWV1ZSxuZXh0Om51bGx9O251bGw9PT1UP1IubWVtb2l6ZWRTdGF0ZT1UPWE6VD1ULm5leHQ9YX1yZXR1cm4gVH1mdW5jdGlvbiBKaChhLGIpe3JldHVyblwiZnVuY3Rpb25cIj09PXR5cGVvZiBiP2IoYSk6Yn1cbmZ1bmN0aW9uIEtoKGEpe3ZhciBiPUloKCksYz1iLnF1ZXVlO2lmKG51bGw9PT1jKXRocm93IEVycm9yKHkoMzExKSk7Yy5sYXN0UmVuZGVyZWRSZWR1Y2VyPWE7dmFyIGQ9UyxlPWQuYmFzZVF1ZXVlLGY9Yy5wZW5kaW5nO2lmKG51bGwhPT1mKXtpZihudWxsIT09ZSl7dmFyIGc9ZS5uZXh0O2UubmV4dD1mLm5leHQ7Zi5uZXh0PWd9ZC5iYXNlUXVldWU9ZT1mO2MucGVuZGluZz1udWxsfWlmKG51bGwhPT1lKXtlPWUubmV4dDtkPWQuYmFzZVN0YXRlO3ZhciBoPWc9Zj1udWxsLGs9ZTtkb3t2YXIgbD1rLmxhbmU7aWYoKHhoJmwpPT09bCludWxsIT09aCYmKGg9aC5uZXh0PXtsYW5lOjAsYWN0aW9uOmsuYWN0aW9uLGVhZ2VyUmVkdWNlcjprLmVhZ2VyUmVkdWNlcixlYWdlclN0YXRlOmsuZWFnZXJTdGF0ZSxuZXh0Om51bGx9KSxkPWsuZWFnZXJSZWR1Y2VyPT09YT9rLmVhZ2VyU3RhdGU6YShkLGsuYWN0aW9uKTtlbHNle3ZhciBuPXtsYW5lOmwsYWN0aW9uOmsuYWN0aW9uLGVhZ2VyUmVkdWNlcjprLmVhZ2VyUmVkdWNlcixcbmVhZ2VyU3RhdGU6ay5lYWdlclN0YXRlLG5leHQ6bnVsbH07bnVsbD09PWg/KGc9aD1uLGY9ZCk6aD1oLm5leHQ9bjtSLmxhbmVzfD1sO0RnfD1sfWs9ay5uZXh0fXdoaWxlKG51bGwhPT1rJiZrIT09ZSk7bnVsbD09PWg/Zj1kOmgubmV4dD1nO0hlKGQsYi5tZW1vaXplZFN0YXRlKXx8KHVnPSEwKTtiLm1lbW9pemVkU3RhdGU9ZDtiLmJhc2VTdGF0ZT1mO2IuYmFzZVF1ZXVlPWg7Yy5sYXN0UmVuZGVyZWRTdGF0ZT1kfXJldHVybltiLm1lbW9pemVkU3RhdGUsYy5kaXNwYXRjaF19XG5mdW5jdGlvbiBMaChhKXt2YXIgYj1JaCgpLGM9Yi5xdWV1ZTtpZihudWxsPT09Yyl0aHJvdyBFcnJvcih5KDMxMSkpO2MubGFzdFJlbmRlcmVkUmVkdWNlcj1hO3ZhciBkPWMuZGlzcGF0Y2gsZT1jLnBlbmRpbmcsZj1iLm1lbW9pemVkU3RhdGU7aWYobnVsbCE9PWUpe2MucGVuZGluZz1udWxsO3ZhciBnPWU9ZS5uZXh0O2RvIGY9YShmLGcuYWN0aW9uKSxnPWcubmV4dDt3aGlsZShnIT09ZSk7SGUoZixiLm1lbW9pemVkU3RhdGUpfHwodWc9ITApO2IubWVtb2l6ZWRTdGF0ZT1mO251bGw9PT1iLmJhc2VRdWV1ZSYmKGIuYmFzZVN0YXRlPWYpO2MubGFzdFJlbmRlcmVkU3RhdGU9Zn1yZXR1cm5bZixkXX1cbmZ1bmN0aW9uIE1oKGEsYixjKXt2YXIgZD1iLl9nZXRWZXJzaW9uO2Q9ZChiLl9zb3VyY2UpO3ZhciBlPWIuX3dvcmtJblByb2dyZXNzVmVyc2lvblByaW1hcnk7aWYobnVsbCE9PWUpYT1lPT09ZDtlbHNlIGlmKGE9YS5tdXRhYmxlUmVhZExhbmVzLGE9KHhoJmEpPT09YSliLl93b3JrSW5Qcm9ncmVzc1ZlcnNpb25QcmltYXJ5PWQsdGgucHVzaChiKTtpZihhKXJldHVybiBjKGIuX3NvdXJjZSk7dGgucHVzaChiKTt0aHJvdyBFcnJvcih5KDM1MCkpO31cbmZ1bmN0aW9uIE5oKGEsYixjLGQpe3ZhciBlPVU7aWYobnVsbD09PWUpdGhyb3cgRXJyb3IoeSgzNDkpKTt2YXIgZj1iLl9nZXRWZXJzaW9uLGc9ZihiLl9zb3VyY2UpLGg9dmguY3VycmVudCxrPWgudXNlU3RhdGUoZnVuY3Rpb24oKXtyZXR1cm4gTWgoZSxiLGMpfSksbD1rWzFdLG49a1swXTtrPVQ7dmFyIEE9YS5tZW1vaXplZFN0YXRlLHA9QS5yZWZzLEM9cC5nZXRTbmFwc2hvdCx4PUEuc291cmNlO0E9QS5zdWJzY3JpYmU7dmFyIHc9UjthLm1lbW9pemVkU3RhdGU9e3JlZnM6cCxzb3VyY2U6YixzdWJzY3JpYmU6ZH07aC51c2VFZmZlY3QoZnVuY3Rpb24oKXtwLmdldFNuYXBzaG90PWM7cC5zZXRTbmFwc2hvdD1sO3ZhciBhPWYoYi5fc291cmNlKTtpZighSGUoZyxhKSl7YT1jKGIuX3NvdXJjZSk7SGUobixhKXx8KGwoYSksYT1JZyh3KSxlLm11dGFibGVSZWFkTGFuZXN8PWEmZS5wZW5kaW5nTGFuZXMpO2E9ZS5tdXRhYmxlUmVhZExhbmVzO2UuZW50YW5nbGVkTGFuZXN8PWE7Zm9yKHZhciBkPVxuZS5lbnRhbmdsZW1lbnRzLGg9YTswPGg7KXt2YXIgaz0zMS1WYyhoKSx2PTE8PGs7ZFtrXXw9YTtoJj1+dn19fSxbYyxiLGRdKTtoLnVzZUVmZmVjdChmdW5jdGlvbigpe3JldHVybiBkKGIuX3NvdXJjZSxmdW5jdGlvbigpe3ZhciBhPXAuZ2V0U25hcHNob3QsYz1wLnNldFNuYXBzaG90O3RyeXtjKGEoYi5fc291cmNlKSk7dmFyIGQ9SWcodyk7ZS5tdXRhYmxlUmVhZExhbmVzfD1kJmUucGVuZGluZ0xhbmVzfWNhdGNoKHEpe2MoZnVuY3Rpb24oKXt0aHJvdyBxO30pfX0pfSxbYixkXSk7SGUoQyxjKSYmSGUoeCxiKSYmSGUoQSxkKXx8KGE9e3BlbmRpbmc6bnVsbCxkaXNwYXRjaDpudWxsLGxhc3RSZW5kZXJlZFJlZHVjZXI6SmgsbGFzdFJlbmRlcmVkU3RhdGU6bn0sYS5kaXNwYXRjaD1sPU9oLmJpbmQobnVsbCxSLGEpLGsucXVldWU9YSxrLmJhc2VRdWV1ZT1udWxsLG49TWgoZSxiLGMpLGsubWVtb2l6ZWRTdGF0ZT1rLmJhc2VTdGF0ZT1uKTtyZXR1cm4gbn1cbmZ1bmN0aW9uIFBoKGEsYixjKXt2YXIgZD1JaCgpO3JldHVybiBOaChkLGEsYixjKX1mdW5jdGlvbiBRaChhKXt2YXIgYj1IaCgpO1wiZnVuY3Rpb25cIj09PXR5cGVvZiBhJiYoYT1hKCkpO2IubWVtb2l6ZWRTdGF0ZT1iLmJhc2VTdGF0ZT1hO2E9Yi5xdWV1ZT17cGVuZGluZzpudWxsLGRpc3BhdGNoOm51bGwsbGFzdFJlbmRlcmVkUmVkdWNlcjpKaCxsYXN0UmVuZGVyZWRTdGF0ZTphfTthPWEuZGlzcGF0Y2g9T2guYmluZChudWxsLFIsYSk7cmV0dXJuW2IubWVtb2l6ZWRTdGF0ZSxhXX1cbmZ1bmN0aW9uIFJoKGEsYixjLGQpe2E9e3RhZzphLGNyZWF0ZTpiLGRlc3Ryb3k6YyxkZXBzOmQsbmV4dDpudWxsfTtiPVIudXBkYXRlUXVldWU7bnVsbD09PWI/KGI9e2xhc3RFZmZlY3Q6bnVsbH0sUi51cGRhdGVRdWV1ZT1iLGIubGFzdEVmZmVjdD1hLm5leHQ9YSk6KGM9Yi5sYXN0RWZmZWN0LG51bGw9PT1jP2IubGFzdEVmZmVjdD1hLm5leHQ9YTooZD1jLm5leHQsYy5uZXh0PWEsYS5uZXh0PWQsYi5sYXN0RWZmZWN0PWEpKTtyZXR1cm4gYX1mdW5jdGlvbiBTaChhKXt2YXIgYj1IaCgpO2E9e2N1cnJlbnQ6YX07cmV0dXJuIGIubWVtb2l6ZWRTdGF0ZT1hfWZ1bmN0aW9uIFRoKCl7cmV0dXJuIEloKCkubWVtb2l6ZWRTdGF0ZX1mdW5jdGlvbiBVaChhLGIsYyxkKXt2YXIgZT1IaCgpO1IuZmxhZ3N8PWE7ZS5tZW1vaXplZFN0YXRlPVJoKDF8YixjLHZvaWQgMCx2b2lkIDA9PT1kP251bGw6ZCl9XG5mdW5jdGlvbiBWaChhLGIsYyxkKXt2YXIgZT1JaCgpO2Q9dm9pZCAwPT09ZD9udWxsOmQ7dmFyIGY9dm9pZCAwO2lmKG51bGwhPT1TKXt2YXIgZz1TLm1lbW9pemVkU3RhdGU7Zj1nLmRlc3Ryb3k7aWYobnVsbCE9PWQmJkJoKGQsZy5kZXBzKSl7UmgoYixjLGYsZCk7cmV0dXJufX1SLmZsYWdzfD1hO2UubWVtb2l6ZWRTdGF0ZT1SaCgxfGIsYyxmLGQpfWZ1bmN0aW9uIFdoKGEsYil7cmV0dXJuIFVoKDUxNiw0LGEsYil9ZnVuY3Rpb24gWGgoYSxiKXtyZXR1cm4gVmgoNTE2LDQsYSxiKX1mdW5jdGlvbiBZaChhLGIpe3JldHVybiBWaCg0LDIsYSxiKX1mdW5jdGlvbiBaaChhLGIpe2lmKFwiZnVuY3Rpb25cIj09PXR5cGVvZiBiKXJldHVybiBhPWEoKSxiKGEpLGZ1bmN0aW9uKCl7YihudWxsKX07aWYobnVsbCE9PWImJnZvaWQgMCE9PWIpcmV0dXJuIGE9YSgpLGIuY3VycmVudD1hLGZ1bmN0aW9uKCl7Yi5jdXJyZW50PW51bGx9fVxuZnVuY3Rpb24gJGgoYSxiLGMpe2M9bnVsbCE9PWMmJnZvaWQgMCE9PWM/Yy5jb25jYXQoW2FdKTpudWxsO3JldHVybiBWaCg0LDIsWmguYmluZChudWxsLGIsYSksYyl9ZnVuY3Rpb24gYWkoKXt9ZnVuY3Rpb24gYmkoYSxiKXt2YXIgYz1JaCgpO2I9dm9pZCAwPT09Yj9udWxsOmI7dmFyIGQ9Yy5tZW1vaXplZFN0YXRlO2lmKG51bGwhPT1kJiZudWxsIT09YiYmQmgoYixkWzFdKSlyZXR1cm4gZFswXTtjLm1lbW9pemVkU3RhdGU9W2EsYl07cmV0dXJuIGF9ZnVuY3Rpb24gY2koYSxiKXt2YXIgYz1JaCgpO2I9dm9pZCAwPT09Yj9udWxsOmI7dmFyIGQ9Yy5tZW1vaXplZFN0YXRlO2lmKG51bGwhPT1kJiZudWxsIT09YiYmQmgoYixkWzFdKSlyZXR1cm4gZFswXTthPWEoKTtjLm1lbW9pemVkU3RhdGU9W2EsYl07cmV0dXJuIGF9XG5mdW5jdGlvbiBkaShhLGIpe3ZhciBjPWVnKCk7Z2coOTg+Yz85ODpjLGZ1bmN0aW9uKCl7YSghMCl9KTtnZyg5NzxjPzk3OmMsZnVuY3Rpb24oKXt2YXIgYz13aC50cmFuc2l0aW9uO3doLnRyYW5zaXRpb249MTt0cnl7YSghMSksYigpfWZpbmFsbHl7d2gudHJhbnNpdGlvbj1jfX0pfVxuZnVuY3Rpb24gT2goYSxiLGMpe3ZhciBkPUhnKCksZT1JZyhhKSxmPXtsYW5lOmUsYWN0aW9uOmMsZWFnZXJSZWR1Y2VyOm51bGwsZWFnZXJTdGF0ZTpudWxsLG5leHQ6bnVsbH0sZz1iLnBlbmRpbmc7bnVsbD09PWc/Zi5uZXh0PWY6KGYubmV4dD1nLm5leHQsZy5uZXh0PWYpO2IucGVuZGluZz1mO2c9YS5hbHRlcm5hdGU7aWYoYT09PVJ8fG51bGwhPT1nJiZnPT09Uil6aD15aD0hMDtlbHNle2lmKDA9PT1hLmxhbmVzJiYobnVsbD09PWd8fDA9PT1nLmxhbmVzKSYmKGc9Yi5sYXN0UmVuZGVyZWRSZWR1Y2VyLG51bGwhPT1nKSl0cnl7dmFyIGg9Yi5sYXN0UmVuZGVyZWRTdGF0ZSxrPWcoaCxjKTtmLmVhZ2VyUmVkdWNlcj1nO2YuZWFnZXJTdGF0ZT1rO2lmKEhlKGssaCkpcmV0dXJufWNhdGNoKGwpe31maW5hbGx5e31KZyhhLGUsZCl9fVxudmFyIEdoPXtyZWFkQ29udGV4dDp2Zyx1c2VDYWxsYmFjazpBaCx1c2VDb250ZXh0OkFoLHVzZUVmZmVjdDpBaCx1c2VJbXBlcmF0aXZlSGFuZGxlOkFoLHVzZUxheW91dEVmZmVjdDpBaCx1c2VNZW1vOkFoLHVzZVJlZHVjZXI6QWgsdXNlUmVmOkFoLHVzZVN0YXRlOkFoLHVzZURlYnVnVmFsdWU6QWgsdXNlRGVmZXJyZWRWYWx1ZTpBaCx1c2VUcmFuc2l0aW9uOkFoLHVzZU11dGFibGVTb3VyY2U6QWgsdXNlT3BhcXVlSWRlbnRpZmllcjpBaCx1bnN0YWJsZV9pc05ld1JlY29uY2lsZXI6ITF9LERoPXtyZWFkQ29udGV4dDp2Zyx1c2VDYWxsYmFjazpmdW5jdGlvbihhLGIpe0hoKCkubWVtb2l6ZWRTdGF0ZT1bYSx2b2lkIDA9PT1iP251bGw6Yl07cmV0dXJuIGF9LHVzZUNvbnRleHQ6dmcsdXNlRWZmZWN0OldoLHVzZUltcGVyYXRpdmVIYW5kbGU6ZnVuY3Rpb24oYSxiLGMpe2M9bnVsbCE9PWMmJnZvaWQgMCE9PWM/Yy5jb25jYXQoW2FdKTpudWxsO3JldHVybiBVaCg0LDIsWmguYmluZChudWxsLFxuYixhKSxjKX0sdXNlTGF5b3V0RWZmZWN0OmZ1bmN0aW9uKGEsYil7cmV0dXJuIFVoKDQsMixhLGIpfSx1c2VNZW1vOmZ1bmN0aW9uKGEsYil7dmFyIGM9SGgoKTtiPXZvaWQgMD09PWI/bnVsbDpiO2E9YSgpO2MubWVtb2l6ZWRTdGF0ZT1bYSxiXTtyZXR1cm4gYX0sdXNlUmVkdWNlcjpmdW5jdGlvbihhLGIsYyl7dmFyIGQ9SGgoKTtiPXZvaWQgMCE9PWM/YyhiKTpiO2QubWVtb2l6ZWRTdGF0ZT1kLmJhc2VTdGF0ZT1iO2E9ZC5xdWV1ZT17cGVuZGluZzpudWxsLGRpc3BhdGNoOm51bGwsbGFzdFJlbmRlcmVkUmVkdWNlcjphLGxhc3RSZW5kZXJlZFN0YXRlOmJ9O2E9YS5kaXNwYXRjaD1PaC5iaW5kKG51bGwsUixhKTtyZXR1cm5bZC5tZW1vaXplZFN0YXRlLGFdfSx1c2VSZWY6U2gsdXNlU3RhdGU6UWgsdXNlRGVidWdWYWx1ZTphaSx1c2VEZWZlcnJlZFZhbHVlOmZ1bmN0aW9uKGEpe3ZhciBiPVFoKGEpLGM9YlswXSxkPWJbMV07V2goZnVuY3Rpb24oKXt2YXIgYj13aC50cmFuc2l0aW9uO1xud2gudHJhbnNpdGlvbj0xO3RyeXtkKGEpfWZpbmFsbHl7d2gudHJhbnNpdGlvbj1ifX0sW2FdKTtyZXR1cm4gY30sdXNlVHJhbnNpdGlvbjpmdW5jdGlvbigpe3ZhciBhPVFoKCExKSxiPWFbMF07YT1kaS5iaW5kKG51bGwsYVsxXSk7U2goYSk7cmV0dXJuW2EsYl19LHVzZU11dGFibGVTb3VyY2U6ZnVuY3Rpb24oYSxiLGMpe3ZhciBkPUhoKCk7ZC5tZW1vaXplZFN0YXRlPXtyZWZzOntnZXRTbmFwc2hvdDpiLHNldFNuYXBzaG90Om51bGx9LHNvdXJjZTphLHN1YnNjcmliZTpjfTtyZXR1cm4gTmgoZCxhLGIsYyl9LHVzZU9wYXF1ZUlkZW50aWZpZXI6ZnVuY3Rpb24oKXtpZihsaCl7dmFyIGE9ITEsYj11ZihmdW5jdGlvbigpe2F8fChhPSEwLGMoXCJyOlwiKyh0ZisrKS50b1N0cmluZygzNikpKTt0aHJvdyBFcnJvcih5KDM1NSkpO30pLGM9UWgoYilbMV07MD09PShSLm1vZGUmMikmJihSLmZsYWdzfD01MTYsUmgoNSxmdW5jdGlvbigpe2MoXCJyOlwiKyh0ZisrKS50b1N0cmluZygzNikpfSxcbnZvaWQgMCxudWxsKSk7cmV0dXJuIGJ9Yj1cInI6XCIrKHRmKyspLnRvU3RyaW5nKDM2KTtRaChiKTtyZXR1cm4gYn0sdW5zdGFibGVfaXNOZXdSZWNvbmNpbGVyOiExfSxFaD17cmVhZENvbnRleHQ6dmcsdXNlQ2FsbGJhY2s6YmksdXNlQ29udGV4dDp2Zyx1c2VFZmZlY3Q6WGgsdXNlSW1wZXJhdGl2ZUhhbmRsZTokaCx1c2VMYXlvdXRFZmZlY3Q6WWgsdXNlTWVtbzpjaSx1c2VSZWR1Y2VyOktoLHVzZVJlZjpUaCx1c2VTdGF0ZTpmdW5jdGlvbigpe3JldHVybiBLaChKaCl9LHVzZURlYnVnVmFsdWU6YWksdXNlRGVmZXJyZWRWYWx1ZTpmdW5jdGlvbihhKXt2YXIgYj1LaChKaCksYz1iWzBdLGQ9YlsxXTtYaChmdW5jdGlvbigpe3ZhciBiPXdoLnRyYW5zaXRpb247d2gudHJhbnNpdGlvbj0xO3RyeXtkKGEpfWZpbmFsbHl7d2gudHJhbnNpdGlvbj1ifX0sW2FdKTtyZXR1cm4gY30sdXNlVHJhbnNpdGlvbjpmdW5jdGlvbigpe3ZhciBhPUtoKEpoKVswXTtyZXR1cm5bVGgoKS5jdXJyZW50LFxuYV19LHVzZU11dGFibGVTb3VyY2U6UGgsdXNlT3BhcXVlSWRlbnRpZmllcjpmdW5jdGlvbigpe3JldHVybiBLaChKaClbMF19LHVuc3RhYmxlX2lzTmV3UmVjb25jaWxlcjohMX0sRmg9e3JlYWRDb250ZXh0OnZnLHVzZUNhbGxiYWNrOmJpLHVzZUNvbnRleHQ6dmcsdXNlRWZmZWN0OlhoLHVzZUltcGVyYXRpdmVIYW5kbGU6JGgsdXNlTGF5b3V0RWZmZWN0OlloLHVzZU1lbW86Y2ksdXNlUmVkdWNlcjpMaCx1c2VSZWY6VGgsdXNlU3RhdGU6ZnVuY3Rpb24oKXtyZXR1cm4gTGgoSmgpfSx1c2VEZWJ1Z1ZhbHVlOmFpLHVzZURlZmVycmVkVmFsdWU6ZnVuY3Rpb24oYSl7dmFyIGI9TGgoSmgpLGM9YlswXSxkPWJbMV07WGgoZnVuY3Rpb24oKXt2YXIgYj13aC50cmFuc2l0aW9uO3doLnRyYW5zaXRpb249MTt0cnl7ZChhKX1maW5hbGx5e3doLnRyYW5zaXRpb249Yn19LFthXSk7cmV0dXJuIGN9LHVzZVRyYW5zaXRpb246ZnVuY3Rpb24oKXt2YXIgYT1MaChKaClbMF07cmV0dXJuW1RoKCkuY3VycmVudCxcbmFdfSx1c2VNdXRhYmxlU291cmNlOlBoLHVzZU9wYXF1ZUlkZW50aWZpZXI6ZnVuY3Rpb24oKXtyZXR1cm4gTGgoSmgpWzBdfSx1bnN0YWJsZV9pc05ld1JlY29uY2lsZXI6ITF9LGVpPXJhLlJlYWN0Q3VycmVudE93bmVyLHVnPSExO2Z1bmN0aW9uIGZpKGEsYixjLGQpe2IuY2hpbGQ9bnVsbD09PWE/WmcoYixudWxsLGMsZCk6WWcoYixhLmNoaWxkLGMsZCl9ZnVuY3Rpb24gZ2koYSxiLGMsZCxlKXtjPWMucmVuZGVyO3ZhciBmPWIucmVmO3RnKGIsZSk7ZD1DaChhLGIsYyxkLGYsZSk7aWYobnVsbCE9PWEmJiF1ZylyZXR1cm4gYi51cGRhdGVRdWV1ZT1hLnVwZGF0ZVF1ZXVlLGIuZmxhZ3MmPS01MTcsYS5sYW5lcyY9fmUsaGkoYSxiLGUpO2IuZmxhZ3N8PTE7ZmkoYSxiLGQsZSk7cmV0dXJuIGIuY2hpbGR9XG5mdW5jdGlvbiBpaShhLGIsYyxkLGUsZil7aWYobnVsbD09PWEpe3ZhciBnPWMudHlwZTtpZihcImZ1bmN0aW9uXCI9PT10eXBlb2YgZyYmIWppKGcpJiZ2b2lkIDA9PT1nLmRlZmF1bHRQcm9wcyYmbnVsbD09PWMuY29tcGFyZSYmdm9pZCAwPT09Yy5kZWZhdWx0UHJvcHMpcmV0dXJuIGIudGFnPTE1LGIudHlwZT1nLGtpKGEsYixnLGQsZSxmKTthPVZnKGMudHlwZSxudWxsLGQsYixiLm1vZGUsZik7YS5yZWY9Yi5yZWY7YS5yZXR1cm49YjtyZXR1cm4gYi5jaGlsZD1hfWc9YS5jaGlsZDtpZigwPT09KGUmZikmJihlPWcubWVtb2l6ZWRQcm9wcyxjPWMuY29tcGFyZSxjPW51bGwhPT1jP2M6SmUsYyhlLGQpJiZhLnJlZj09PWIucmVmKSlyZXR1cm4gaGkoYSxiLGYpO2IuZmxhZ3N8PTE7YT1UZyhnLGQpO2EucmVmPWIucmVmO2EucmV0dXJuPWI7cmV0dXJuIGIuY2hpbGQ9YX1cbmZ1bmN0aW9uIGtpKGEsYixjLGQsZSxmKXtpZihudWxsIT09YSYmSmUoYS5tZW1vaXplZFByb3BzLGQpJiZhLnJlZj09PWIucmVmKWlmKHVnPSExLDAhPT0oZiZlKSkwIT09KGEuZmxhZ3MmMTYzODQpJiYodWc9ITApO2Vsc2UgcmV0dXJuIGIubGFuZXM9YS5sYW5lcyxoaShhLGIsZik7cmV0dXJuIGxpKGEsYixjLGQsZil9XG5mdW5jdGlvbiBtaShhLGIsYyl7dmFyIGQ9Yi5wZW5kaW5nUHJvcHMsZT1kLmNoaWxkcmVuLGY9bnVsbCE9PWE/YS5tZW1vaXplZFN0YXRlOm51bGw7aWYoXCJoaWRkZW5cIj09PWQubW9kZXx8XCJ1bnN0YWJsZS1kZWZlci13aXRob3V0LWhpZGluZ1wiPT09ZC5tb2RlKWlmKDA9PT0oYi5tb2RlJjQpKWIubWVtb2l6ZWRTdGF0ZT17YmFzZUxhbmVzOjB9LG5pKGIsYyk7ZWxzZSBpZigwIT09KGMmMTA3Mzc0MTgyNCkpYi5tZW1vaXplZFN0YXRlPXtiYXNlTGFuZXM6MH0sbmkoYixudWxsIT09Zj9mLmJhc2VMYW5lczpjKTtlbHNlIHJldHVybiBhPW51bGwhPT1mP2YuYmFzZUxhbmVzfGM6YyxiLmxhbmVzPWIuY2hpbGRMYW5lcz0xMDczNzQxODI0LGIubWVtb2l6ZWRTdGF0ZT17YmFzZUxhbmVzOmF9LG5pKGIsYSksbnVsbDtlbHNlIG51bGwhPT1mPyhkPWYuYmFzZUxhbmVzfGMsYi5tZW1vaXplZFN0YXRlPW51bGwpOmQ9YyxuaShiLGQpO2ZpKGEsYixlLGMpO3JldHVybiBiLmNoaWxkfVxuZnVuY3Rpb24gb2koYSxiKXt2YXIgYz1iLnJlZjtpZihudWxsPT09YSYmbnVsbCE9PWN8fG51bGwhPT1hJiZhLnJlZiE9PWMpYi5mbGFnc3w9MTI4fWZ1bmN0aW9uIGxpKGEsYixjLGQsZSl7dmFyIGY9RmYoYyk/RGY6TS5jdXJyZW50O2Y9RWYoYixmKTt0ZyhiLGUpO2M9Q2goYSxiLGMsZCxmLGUpO2lmKG51bGwhPT1hJiYhdWcpcmV0dXJuIGIudXBkYXRlUXVldWU9YS51cGRhdGVRdWV1ZSxiLmZsYWdzJj0tNTE3LGEubGFuZXMmPX5lLGhpKGEsYixlKTtiLmZsYWdzfD0xO2ZpKGEsYixjLGUpO3JldHVybiBiLmNoaWxkfVxuZnVuY3Rpb24gcGkoYSxiLGMsZCxlKXtpZihGZihjKSl7dmFyIGY9ITA7SmYoYil9ZWxzZSBmPSExO3RnKGIsZSk7aWYobnVsbD09PWIuc3RhdGVOb2RlKW51bGwhPT1hJiYoYS5hbHRlcm5hdGU9bnVsbCxiLmFsdGVybmF0ZT1udWxsLGIuZmxhZ3N8PTIpLE1nKGIsYyxkKSxPZyhiLGMsZCxlKSxkPSEwO2Vsc2UgaWYobnVsbD09PWEpe3ZhciBnPWIuc3RhdGVOb2RlLGg9Yi5tZW1vaXplZFByb3BzO2cucHJvcHM9aDt2YXIgaz1nLmNvbnRleHQsbD1jLmNvbnRleHRUeXBlO1wib2JqZWN0XCI9PT10eXBlb2YgbCYmbnVsbCE9PWw/bD12ZyhsKToobD1GZihjKT9EZjpNLmN1cnJlbnQsbD1FZihiLGwpKTt2YXIgbj1jLmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyxBPVwiZnVuY3Rpb25cIj09PXR5cGVvZiBufHxcImZ1bmN0aW9uXCI9PT10eXBlb2YgZy5nZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZTtBfHxcImZ1bmN0aW9uXCIhPT10eXBlb2YgZy5VTlNBRkVfY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyYmXG5cImZ1bmN0aW9uXCIhPT10eXBlb2YgZy5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzfHwoaCE9PWR8fGshPT1sKSYmTmcoYixnLGQsbCk7d2c9ITE7dmFyIHA9Yi5tZW1vaXplZFN0YXRlO2cuc3RhdGU9cDtDZyhiLGQsZyxlKTtrPWIubWVtb2l6ZWRTdGF0ZTtoIT09ZHx8cCE9PWt8fE4uY3VycmVudHx8d2c/KFwiZnVuY3Rpb25cIj09PXR5cGVvZiBuJiYoR2coYixjLG4sZCksaz1iLm1lbW9pemVkU3RhdGUpLChoPXdnfHxMZyhiLGMsaCxkLHAsayxsKSk/KEF8fFwiZnVuY3Rpb25cIiE9PXR5cGVvZiBnLlVOU0FGRV9jb21wb25lbnRXaWxsTW91bnQmJlwiZnVuY3Rpb25cIiE9PXR5cGVvZiBnLmNvbXBvbmVudFdpbGxNb3VudHx8KFwiZnVuY3Rpb25cIj09PXR5cGVvZiBnLmNvbXBvbmVudFdpbGxNb3VudCYmZy5jb21wb25lbnRXaWxsTW91bnQoKSxcImZ1bmN0aW9uXCI9PT10eXBlb2YgZy5VTlNBRkVfY29tcG9uZW50V2lsbE1vdW50JiZnLlVOU0FGRV9jb21wb25lbnRXaWxsTW91bnQoKSksXCJmdW5jdGlvblwiPT09XG50eXBlb2YgZy5jb21wb25lbnREaWRNb3VudCYmKGIuZmxhZ3N8PTQpKTooXCJmdW5jdGlvblwiPT09dHlwZW9mIGcuY29tcG9uZW50RGlkTW91bnQmJihiLmZsYWdzfD00KSxiLm1lbW9pemVkUHJvcHM9ZCxiLm1lbW9pemVkU3RhdGU9ayksZy5wcm9wcz1kLGcuc3RhdGU9ayxnLmNvbnRleHQ9bCxkPWgpOihcImZ1bmN0aW9uXCI9PT10eXBlb2YgZy5jb21wb25lbnREaWRNb3VudCYmKGIuZmxhZ3N8PTQpLGQ9ITEpfWVsc2V7Zz1iLnN0YXRlTm9kZTt5ZyhhLGIpO2g9Yi5tZW1vaXplZFByb3BzO2w9Yi50eXBlPT09Yi5lbGVtZW50VHlwZT9oOmxnKGIudHlwZSxoKTtnLnByb3BzPWw7QT1iLnBlbmRpbmdQcm9wcztwPWcuY29udGV4dDtrPWMuY29udGV4dFR5cGU7XCJvYmplY3RcIj09PXR5cGVvZiBrJiZudWxsIT09az9rPXZnKGspOihrPUZmKGMpP0RmOk0uY3VycmVudCxrPUVmKGIsaykpO3ZhciBDPWMuZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzOyhuPVwiZnVuY3Rpb25cIj09PXR5cGVvZiBDfHxcblwiZnVuY3Rpb25cIj09PXR5cGVvZiBnLmdldFNuYXBzaG90QmVmb3JlVXBkYXRlKXx8XCJmdW5jdGlvblwiIT09dHlwZW9mIGcuVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMmJlwiZnVuY3Rpb25cIiE9PXR5cGVvZiBnLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHN8fChoIT09QXx8cCE9PWspJiZOZyhiLGcsZCxrKTt3Zz0hMTtwPWIubWVtb2l6ZWRTdGF0ZTtnLnN0YXRlPXA7Q2coYixkLGcsZSk7dmFyIHg9Yi5tZW1vaXplZFN0YXRlO2ghPT1BfHxwIT09eHx8Ti5jdXJyZW50fHx3Zz8oXCJmdW5jdGlvblwiPT09dHlwZW9mIEMmJihHZyhiLGMsQyxkKSx4PWIubWVtb2l6ZWRTdGF0ZSksKGw9d2d8fExnKGIsYyxsLGQscCx4LGspKT8obnx8XCJmdW5jdGlvblwiIT09dHlwZW9mIGcuVU5TQUZFX2NvbXBvbmVudFdpbGxVcGRhdGUmJlwiZnVuY3Rpb25cIiE9PXR5cGVvZiBnLmNvbXBvbmVudFdpbGxVcGRhdGV8fChcImZ1bmN0aW9uXCI9PT10eXBlb2YgZy5jb21wb25lbnRXaWxsVXBkYXRlJiZnLmNvbXBvbmVudFdpbGxVcGRhdGUoZCxcbngsayksXCJmdW5jdGlvblwiPT09dHlwZW9mIGcuVU5TQUZFX2NvbXBvbmVudFdpbGxVcGRhdGUmJmcuVU5TQUZFX2NvbXBvbmVudFdpbGxVcGRhdGUoZCx4LGspKSxcImZ1bmN0aW9uXCI9PT10eXBlb2YgZy5jb21wb25lbnREaWRVcGRhdGUmJihiLmZsYWdzfD00KSxcImZ1bmN0aW9uXCI9PT10eXBlb2YgZy5nZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSYmKGIuZmxhZ3N8PTI1NikpOihcImZ1bmN0aW9uXCIhPT10eXBlb2YgZy5jb21wb25lbnREaWRVcGRhdGV8fGg9PT1hLm1lbW9pemVkUHJvcHMmJnA9PT1hLm1lbW9pemVkU3RhdGV8fChiLmZsYWdzfD00KSxcImZ1bmN0aW9uXCIhPT10eXBlb2YgZy5nZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZXx8aD09PWEubWVtb2l6ZWRQcm9wcyYmcD09PWEubWVtb2l6ZWRTdGF0ZXx8KGIuZmxhZ3N8PTI1NiksYi5tZW1vaXplZFByb3BzPWQsYi5tZW1vaXplZFN0YXRlPXgpLGcucHJvcHM9ZCxnLnN0YXRlPXgsZy5jb250ZXh0PWssZD1sKTooXCJmdW5jdGlvblwiIT09dHlwZW9mIGcuY29tcG9uZW50RGlkVXBkYXRlfHxcbmg9PT1hLm1lbW9pemVkUHJvcHMmJnA9PT1hLm1lbW9pemVkU3RhdGV8fChiLmZsYWdzfD00KSxcImZ1bmN0aW9uXCIhPT10eXBlb2YgZy5nZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZXx8aD09PWEubWVtb2l6ZWRQcm9wcyYmcD09PWEubWVtb2l6ZWRTdGF0ZXx8KGIuZmxhZ3N8PTI1NiksZD0hMSl9cmV0dXJuIHFpKGEsYixjLGQsZixlKX1cbmZ1bmN0aW9uIHFpKGEsYixjLGQsZSxmKXtvaShhLGIpO3ZhciBnPTAhPT0oYi5mbGFncyY2NCk7aWYoIWQmJiFnKXJldHVybiBlJiZLZihiLGMsITEpLGhpKGEsYixmKTtkPWIuc3RhdGVOb2RlO2VpLmN1cnJlbnQ9Yjt2YXIgaD1nJiZcImZ1bmN0aW9uXCIhPT10eXBlb2YgYy5nZXREZXJpdmVkU3RhdGVGcm9tRXJyb3I/bnVsbDpkLnJlbmRlcigpO2IuZmxhZ3N8PTE7bnVsbCE9PWEmJmc/KGIuY2hpbGQ9WWcoYixhLmNoaWxkLG51bGwsZiksYi5jaGlsZD1ZZyhiLG51bGwsaCxmKSk6ZmkoYSxiLGgsZik7Yi5tZW1vaXplZFN0YXRlPWQuc3RhdGU7ZSYmS2YoYixjLCEwKTtyZXR1cm4gYi5jaGlsZH1mdW5jdGlvbiByaShhKXt2YXIgYj1hLnN0YXRlTm9kZTtiLnBlbmRpbmdDb250ZXh0P0hmKGEsYi5wZW5kaW5nQ29udGV4dCxiLnBlbmRpbmdDb250ZXh0IT09Yi5jb250ZXh0KTpiLmNvbnRleHQmJkhmKGEsYi5jb250ZXh0LCExKTtlaChhLGIuY29udGFpbmVySW5mbyl9XG52YXIgc2k9e2RlaHlkcmF0ZWQ6bnVsbCxyZXRyeUxhbmU6MH07XG5mdW5jdGlvbiB0aShhLGIsYyl7dmFyIGQ9Yi5wZW5kaW5nUHJvcHMsZT1QLmN1cnJlbnQsZj0hMSxnOyhnPTAhPT0oYi5mbGFncyY2NCkpfHwoZz1udWxsIT09YSYmbnVsbD09PWEubWVtb2l6ZWRTdGF0ZT8hMTowIT09KGUmMikpO2c/KGY9ITAsYi5mbGFncyY9LTY1KTpudWxsIT09YSYmbnVsbD09PWEubWVtb2l6ZWRTdGF0ZXx8dm9pZCAwPT09ZC5mYWxsYmFja3x8ITA9PT1kLnVuc3RhYmxlX2F2b2lkVGhpc0ZhbGxiYWNrfHwoZXw9MSk7SShQLGUmMSk7aWYobnVsbD09PWEpe3ZvaWQgMCE9PWQuZmFsbGJhY2smJnBoKGIpO2E9ZC5jaGlsZHJlbjtlPWQuZmFsbGJhY2s7aWYoZilyZXR1cm4gYT11aShiLGEsZSxjKSxiLmNoaWxkLm1lbW9pemVkU3RhdGU9e2Jhc2VMYW5lczpjfSxiLm1lbW9pemVkU3RhdGU9c2ksYTtpZihcIm51bWJlclwiPT09dHlwZW9mIGQudW5zdGFibGVfZXhwZWN0ZWRMb2FkVGltZSlyZXR1cm4gYT11aShiLGEsZSxjKSxiLmNoaWxkLm1lbW9pemVkU3RhdGU9e2Jhc2VMYW5lczpjfSxcbmIubWVtb2l6ZWRTdGF0ZT1zaSxiLmxhbmVzPTMzNTU0NDMyLGE7Yz12aSh7bW9kZTpcInZpc2libGVcIixjaGlsZHJlbjphfSxiLm1vZGUsYyxudWxsKTtjLnJldHVybj1iO3JldHVybiBiLmNoaWxkPWN9aWYobnVsbCE9PWEubWVtb2l6ZWRTdGF0ZSl7aWYoZilyZXR1cm4gZD13aShhLGIsZC5jaGlsZHJlbixkLmZhbGxiYWNrLGMpLGY9Yi5jaGlsZCxlPWEuY2hpbGQubWVtb2l6ZWRTdGF0ZSxmLm1lbW9pemVkU3RhdGU9bnVsbD09PWU/e2Jhc2VMYW5lczpjfTp7YmFzZUxhbmVzOmUuYmFzZUxhbmVzfGN9LGYuY2hpbGRMYW5lcz1hLmNoaWxkTGFuZXMmfmMsYi5tZW1vaXplZFN0YXRlPXNpLGQ7Yz14aShhLGIsZC5jaGlsZHJlbixjKTtiLm1lbW9pemVkU3RhdGU9bnVsbDtyZXR1cm4gY31pZihmKXJldHVybiBkPXdpKGEsYixkLmNoaWxkcmVuLGQuZmFsbGJhY2ssYyksZj1iLmNoaWxkLGU9YS5jaGlsZC5tZW1vaXplZFN0YXRlLGYubWVtb2l6ZWRTdGF0ZT1udWxsPT09ZT97YmFzZUxhbmVzOmN9Olxue2Jhc2VMYW5lczplLmJhc2VMYW5lc3xjfSxmLmNoaWxkTGFuZXM9YS5jaGlsZExhbmVzJn5jLGIubWVtb2l6ZWRTdGF0ZT1zaSxkO2M9eGkoYSxiLGQuY2hpbGRyZW4sYyk7Yi5tZW1vaXplZFN0YXRlPW51bGw7cmV0dXJuIGN9ZnVuY3Rpb24gdWkoYSxiLGMsZCl7dmFyIGU9YS5tb2RlLGY9YS5jaGlsZDtiPXttb2RlOlwiaGlkZGVuXCIsY2hpbGRyZW46Yn07MD09PShlJjIpJiZudWxsIT09Zj8oZi5jaGlsZExhbmVzPTAsZi5wZW5kaW5nUHJvcHM9Yik6Zj12aShiLGUsMCxudWxsKTtjPVhnKGMsZSxkLG51bGwpO2YucmV0dXJuPWE7Yy5yZXR1cm49YTtmLnNpYmxpbmc9YzthLmNoaWxkPWY7cmV0dXJuIGN9XG5mdW5jdGlvbiB4aShhLGIsYyxkKXt2YXIgZT1hLmNoaWxkO2E9ZS5zaWJsaW5nO2M9VGcoZSx7bW9kZTpcInZpc2libGVcIixjaGlsZHJlbjpjfSk7MD09PShiLm1vZGUmMikmJihjLmxhbmVzPWQpO2MucmV0dXJuPWI7Yy5zaWJsaW5nPW51bGw7bnVsbCE9PWEmJihhLm5leHRFZmZlY3Q9bnVsbCxhLmZsYWdzPTgsYi5maXJzdEVmZmVjdD1iLmxhc3RFZmZlY3Q9YSk7cmV0dXJuIGIuY2hpbGQ9Y31cbmZ1bmN0aW9uIHdpKGEsYixjLGQsZSl7dmFyIGY9Yi5tb2RlLGc9YS5jaGlsZDthPWcuc2libGluZzt2YXIgaD17bW9kZTpcImhpZGRlblwiLGNoaWxkcmVuOmN9OzA9PT0oZiYyKSYmYi5jaGlsZCE9PWc/KGM9Yi5jaGlsZCxjLmNoaWxkTGFuZXM9MCxjLnBlbmRpbmdQcm9wcz1oLGc9Yy5sYXN0RWZmZWN0LG51bGwhPT1nPyhiLmZpcnN0RWZmZWN0PWMuZmlyc3RFZmZlY3QsYi5sYXN0RWZmZWN0PWcsZy5uZXh0RWZmZWN0PW51bGwpOmIuZmlyc3RFZmZlY3Q9Yi5sYXN0RWZmZWN0PW51bGwpOmM9VGcoZyxoKTtudWxsIT09YT9kPVRnKGEsZCk6KGQ9WGcoZCxmLGUsbnVsbCksZC5mbGFnc3w9Mik7ZC5yZXR1cm49YjtjLnJldHVybj1iO2Muc2libGluZz1kO2IuY2hpbGQ9YztyZXR1cm4gZH1mdW5jdGlvbiB5aShhLGIpe2EubGFuZXN8PWI7dmFyIGM9YS5hbHRlcm5hdGU7bnVsbCE9PWMmJihjLmxhbmVzfD1iKTtzZyhhLnJldHVybixiKX1cbmZ1bmN0aW9uIHppKGEsYixjLGQsZSxmKXt2YXIgZz1hLm1lbW9pemVkU3RhdGU7bnVsbD09PWc/YS5tZW1vaXplZFN0YXRlPXtpc0JhY2t3YXJkczpiLHJlbmRlcmluZzpudWxsLHJlbmRlcmluZ1N0YXJ0VGltZTowLGxhc3Q6ZCx0YWlsOmMsdGFpbE1vZGU6ZSxsYXN0RWZmZWN0OmZ9OihnLmlzQmFja3dhcmRzPWIsZy5yZW5kZXJpbmc9bnVsbCxnLnJlbmRlcmluZ1N0YXJ0VGltZT0wLGcubGFzdD1kLGcudGFpbD1jLGcudGFpbE1vZGU9ZSxnLmxhc3RFZmZlY3Q9Zil9XG5mdW5jdGlvbiBBaShhLGIsYyl7dmFyIGQ9Yi5wZW5kaW5nUHJvcHMsZT1kLnJldmVhbE9yZGVyLGY9ZC50YWlsO2ZpKGEsYixkLmNoaWxkcmVuLGMpO2Q9UC5jdXJyZW50O2lmKDAhPT0oZCYyKSlkPWQmMXwyLGIuZmxhZ3N8PTY0O2Vsc2V7aWYobnVsbCE9PWEmJjAhPT0oYS5mbGFncyY2NCkpYTpmb3IoYT1iLmNoaWxkO251bGwhPT1hOyl7aWYoMTM9PT1hLnRhZyludWxsIT09YS5tZW1vaXplZFN0YXRlJiZ5aShhLGMpO2Vsc2UgaWYoMTk9PT1hLnRhZyl5aShhLGMpO2Vsc2UgaWYobnVsbCE9PWEuY2hpbGQpe2EuY2hpbGQucmV0dXJuPWE7YT1hLmNoaWxkO2NvbnRpbnVlfWlmKGE9PT1iKWJyZWFrIGE7Zm9yKDtudWxsPT09YS5zaWJsaW5nOyl7aWYobnVsbD09PWEucmV0dXJufHxhLnJldHVybj09PWIpYnJlYWsgYTthPWEucmV0dXJufWEuc2libGluZy5yZXR1cm49YS5yZXR1cm47YT1hLnNpYmxpbmd9ZCY9MX1JKFAsZCk7aWYoMD09PShiLm1vZGUmMikpYi5tZW1vaXplZFN0YXRlPVxubnVsbDtlbHNlIHN3aXRjaChlKXtjYXNlIFwiZm9yd2FyZHNcIjpjPWIuY2hpbGQ7Zm9yKGU9bnVsbDtudWxsIT09YzspYT1jLmFsdGVybmF0ZSxudWxsIT09YSYmbnVsbD09PWloKGEpJiYoZT1jKSxjPWMuc2libGluZztjPWU7bnVsbD09PWM/KGU9Yi5jaGlsZCxiLmNoaWxkPW51bGwpOihlPWMuc2libGluZyxjLnNpYmxpbmc9bnVsbCk7emkoYiwhMSxlLGMsZixiLmxhc3RFZmZlY3QpO2JyZWFrO2Nhc2UgXCJiYWNrd2FyZHNcIjpjPW51bGw7ZT1iLmNoaWxkO2ZvcihiLmNoaWxkPW51bGw7bnVsbCE9PWU7KXthPWUuYWx0ZXJuYXRlO2lmKG51bGwhPT1hJiZudWxsPT09aWgoYSkpe2IuY2hpbGQ9ZTticmVha31hPWUuc2libGluZztlLnNpYmxpbmc9YztjPWU7ZT1hfXppKGIsITAsYyxudWxsLGYsYi5sYXN0RWZmZWN0KTticmVhaztjYXNlIFwidG9nZXRoZXJcIjp6aShiLCExLG51bGwsbnVsbCx2b2lkIDAsYi5sYXN0RWZmZWN0KTticmVhaztkZWZhdWx0OmIubWVtb2l6ZWRTdGF0ZT1udWxsfXJldHVybiBiLmNoaWxkfVxuZnVuY3Rpb24gaGkoYSxiLGMpe251bGwhPT1hJiYoYi5kZXBlbmRlbmNpZXM9YS5kZXBlbmRlbmNpZXMpO0RnfD1iLmxhbmVzO2lmKDAhPT0oYyZiLmNoaWxkTGFuZXMpKXtpZihudWxsIT09YSYmYi5jaGlsZCE9PWEuY2hpbGQpdGhyb3cgRXJyb3IoeSgxNTMpKTtpZihudWxsIT09Yi5jaGlsZCl7YT1iLmNoaWxkO2M9VGcoYSxhLnBlbmRpbmdQcm9wcyk7Yi5jaGlsZD1jO2ZvcihjLnJldHVybj1iO251bGwhPT1hLnNpYmxpbmc7KWE9YS5zaWJsaW5nLGM9Yy5zaWJsaW5nPVRnKGEsYS5wZW5kaW5nUHJvcHMpLGMucmV0dXJuPWI7Yy5zaWJsaW5nPW51bGx9cmV0dXJuIGIuY2hpbGR9cmV0dXJuIG51bGx9dmFyIEJpLENpLERpLEVpO1xuQmk9ZnVuY3Rpb24oYSxiKXtmb3IodmFyIGM9Yi5jaGlsZDtudWxsIT09Yzspe2lmKDU9PT1jLnRhZ3x8Nj09PWMudGFnKWEuYXBwZW5kQ2hpbGQoYy5zdGF0ZU5vZGUpO2Vsc2UgaWYoNCE9PWMudGFnJiZudWxsIT09Yy5jaGlsZCl7Yy5jaGlsZC5yZXR1cm49YztjPWMuY2hpbGQ7Y29udGludWV9aWYoYz09PWIpYnJlYWs7Zm9yKDtudWxsPT09Yy5zaWJsaW5nOyl7aWYobnVsbD09PWMucmV0dXJufHxjLnJldHVybj09PWIpcmV0dXJuO2M9Yy5yZXR1cm59Yy5zaWJsaW5nLnJldHVybj1jLnJldHVybjtjPWMuc2libGluZ319O0NpPWZ1bmN0aW9uKCl7fTtcbkRpPWZ1bmN0aW9uKGEsYixjLGQpe3ZhciBlPWEubWVtb2l6ZWRQcm9wcztpZihlIT09ZCl7YT1iLnN0YXRlTm9kZTtkaChhaC5jdXJyZW50KTt2YXIgZj1udWxsO3N3aXRjaChjKXtjYXNlIFwiaW5wdXRcIjplPVlhKGEsZSk7ZD1ZYShhLGQpO2Y9W107YnJlYWs7Y2FzZSBcIm9wdGlvblwiOmU9ZWIoYSxlKTtkPWViKGEsZCk7Zj1bXTticmVhaztjYXNlIFwic2VsZWN0XCI6ZT1tKHt9LGUse3ZhbHVlOnZvaWQgMH0pO2Q9bSh7fSxkLHt2YWx1ZTp2b2lkIDB9KTtmPVtdO2JyZWFrO2Nhc2UgXCJ0ZXh0YXJlYVwiOmU9Z2IoYSxlKTtkPWdiKGEsZCk7Zj1bXTticmVhaztkZWZhdWx0OlwiZnVuY3Rpb25cIiE9PXR5cGVvZiBlLm9uQ2xpY2smJlwiZnVuY3Rpb25cIj09PXR5cGVvZiBkLm9uQ2xpY2smJihhLm9uY2xpY2s9amYpfXZiKGMsZCk7dmFyIGc7Yz1udWxsO2ZvcihsIGluIGUpaWYoIWQuaGFzT3duUHJvcGVydHkobCkmJmUuaGFzT3duUHJvcGVydHkobCkmJm51bGwhPWVbbF0paWYoXCJzdHlsZVwiPT09XG5sKXt2YXIgaD1lW2xdO2ZvcihnIGluIGgpaC5oYXNPd25Qcm9wZXJ0eShnKSYmKGN8fChjPXt9KSxjW2ddPVwiXCIpfWVsc2VcImRhbmdlcm91c2x5U2V0SW5uZXJIVE1MXCIhPT1sJiZcImNoaWxkcmVuXCIhPT1sJiZcInN1cHByZXNzQ29udGVudEVkaXRhYmxlV2FybmluZ1wiIT09bCYmXCJzdXBwcmVzc0h5ZHJhdGlvbldhcm5pbmdcIiE9PWwmJlwiYXV0b0ZvY3VzXCIhPT1sJiYoY2EuaGFzT3duUHJvcGVydHkobCk/Znx8KGY9W10pOihmPWZ8fFtdKS5wdXNoKGwsbnVsbCkpO2ZvcihsIGluIGQpe3ZhciBrPWRbbF07aD1udWxsIT1lP2VbbF06dm9pZCAwO2lmKGQuaGFzT3duUHJvcGVydHkobCkmJmshPT1oJiYobnVsbCE9a3x8bnVsbCE9aCkpaWYoXCJzdHlsZVwiPT09bClpZihoKXtmb3IoZyBpbiBoKSFoLmhhc093blByb3BlcnR5KGcpfHxrJiZrLmhhc093blByb3BlcnR5KGcpfHwoY3x8KGM9e30pLGNbZ109XCJcIik7Zm9yKGcgaW4gaylrLmhhc093blByb3BlcnR5KGcpJiZoW2ddIT09a1tnXSYmKGN8fFxuKGM9e30pLGNbZ109a1tnXSl9ZWxzZSBjfHwoZnx8KGY9W10pLGYucHVzaChsLGMpKSxjPWs7ZWxzZVwiZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxcIj09PWw/KGs9az9rLl9faHRtbDp2b2lkIDAsaD1oP2guX19odG1sOnZvaWQgMCxudWxsIT1rJiZoIT09ayYmKGY9Znx8W10pLnB1c2gobCxrKSk6XCJjaGlsZHJlblwiPT09bD9cInN0cmluZ1wiIT09dHlwZW9mIGsmJlwibnVtYmVyXCIhPT10eXBlb2Yga3x8KGY9Znx8W10pLnB1c2gobCxcIlwiK2spOlwic3VwcHJlc3NDb250ZW50RWRpdGFibGVXYXJuaW5nXCIhPT1sJiZcInN1cHByZXNzSHlkcmF0aW9uV2FybmluZ1wiIT09bCYmKGNhLmhhc093blByb3BlcnR5KGwpPyhudWxsIT1rJiZcIm9uU2Nyb2xsXCI9PT1sJiZHKFwic2Nyb2xsXCIsYSksZnx8aD09PWt8fChmPVtdKSk6XCJvYmplY3RcIj09PXR5cGVvZiBrJiZudWxsIT09ayYmay4kJHR5cGVvZj09PUdhP2sudG9TdHJpbmcoKTooZj1mfHxbXSkucHVzaChsLGspKX1jJiYoZj1mfHxbXSkucHVzaChcInN0eWxlXCIsXG5jKTt2YXIgbD1mO2lmKGIudXBkYXRlUXVldWU9bCliLmZsYWdzfD00fX07RWk9ZnVuY3Rpb24oYSxiLGMsZCl7YyE9PWQmJihiLmZsYWdzfD00KX07ZnVuY3Rpb24gRmkoYSxiKXtpZighbGgpc3dpdGNoKGEudGFpbE1vZGUpe2Nhc2UgXCJoaWRkZW5cIjpiPWEudGFpbDtmb3IodmFyIGM9bnVsbDtudWxsIT09YjspbnVsbCE9PWIuYWx0ZXJuYXRlJiYoYz1iKSxiPWIuc2libGluZztudWxsPT09Yz9hLnRhaWw9bnVsbDpjLnNpYmxpbmc9bnVsbDticmVhaztjYXNlIFwiY29sbGFwc2VkXCI6Yz1hLnRhaWw7Zm9yKHZhciBkPW51bGw7bnVsbCE9PWM7KW51bGwhPT1jLmFsdGVybmF0ZSYmKGQ9YyksYz1jLnNpYmxpbmc7bnVsbD09PWQ/Ynx8bnVsbD09PWEudGFpbD9hLnRhaWw9bnVsbDphLnRhaWwuc2libGluZz1udWxsOmQuc2libGluZz1udWxsfX1cbmZ1bmN0aW9uIEdpKGEsYixjKXt2YXIgZD1iLnBlbmRpbmdQcm9wcztzd2l0Y2goYi50YWcpe2Nhc2UgMjpjYXNlIDE2OmNhc2UgMTU6Y2FzZSAwOmNhc2UgMTE6Y2FzZSA3OmNhc2UgODpjYXNlIDEyOmNhc2UgOTpjYXNlIDE0OnJldHVybiBudWxsO2Nhc2UgMTpyZXR1cm4gRmYoYi50eXBlKSYmR2YoKSxudWxsO2Nhc2UgMzpmaCgpO0goTik7SChNKTt1aCgpO2Q9Yi5zdGF0ZU5vZGU7ZC5wZW5kaW5nQ29udGV4dCYmKGQuY29udGV4dD1kLnBlbmRpbmdDb250ZXh0LGQucGVuZGluZ0NvbnRleHQ9bnVsbCk7aWYobnVsbD09PWF8fG51bGw9PT1hLmNoaWxkKXJoKGIpP2IuZmxhZ3N8PTQ6ZC5oeWRyYXRlfHwoYi5mbGFnc3w9MjU2KTtDaShiKTtyZXR1cm4gbnVsbDtjYXNlIDU6aGgoYik7dmFyIGU9ZGgoY2guY3VycmVudCk7Yz1iLnR5cGU7aWYobnVsbCE9PWEmJm51bGwhPWIuc3RhdGVOb2RlKURpKGEsYixjLGQsZSksYS5yZWYhPT1iLnJlZiYmKGIuZmxhZ3N8PTEyOCk7ZWxzZXtpZighZCl7aWYobnVsbD09PVxuYi5zdGF0ZU5vZGUpdGhyb3cgRXJyb3IoeSgxNjYpKTtyZXR1cm4gbnVsbH1hPWRoKGFoLmN1cnJlbnQpO2lmKHJoKGIpKXtkPWIuc3RhdGVOb2RlO2M9Yi50eXBlO3ZhciBmPWIubWVtb2l6ZWRQcm9wcztkW3dmXT1iO2RbeGZdPWY7c3dpdGNoKGMpe2Nhc2UgXCJkaWFsb2dcIjpHKFwiY2FuY2VsXCIsZCk7RyhcImNsb3NlXCIsZCk7YnJlYWs7Y2FzZSBcImlmcmFtZVwiOmNhc2UgXCJvYmplY3RcIjpjYXNlIFwiZW1iZWRcIjpHKFwibG9hZFwiLGQpO2JyZWFrO2Nhc2UgXCJ2aWRlb1wiOmNhc2UgXCJhdWRpb1wiOmZvcihhPTA7YTxYZS5sZW5ndGg7YSsrKUcoWGVbYV0sZCk7YnJlYWs7Y2FzZSBcInNvdXJjZVwiOkcoXCJlcnJvclwiLGQpO2JyZWFrO2Nhc2UgXCJpbWdcIjpjYXNlIFwiaW1hZ2VcIjpjYXNlIFwibGlua1wiOkcoXCJlcnJvclwiLGQpO0coXCJsb2FkXCIsZCk7YnJlYWs7Y2FzZSBcImRldGFpbHNcIjpHKFwidG9nZ2xlXCIsZCk7YnJlYWs7Y2FzZSBcImlucHV0XCI6WmEoZCxmKTtHKFwiaW52YWxpZFwiLGQpO2JyZWFrO2Nhc2UgXCJzZWxlY3RcIjpkLl93cmFwcGVyU3RhdGU9XG57d2FzTXVsdGlwbGU6ISFmLm11bHRpcGxlfTtHKFwiaW52YWxpZFwiLGQpO2JyZWFrO2Nhc2UgXCJ0ZXh0YXJlYVwiOmhiKGQsZiksRyhcImludmFsaWRcIixkKX12YihjLGYpO2E9bnVsbDtmb3IodmFyIGcgaW4gZilmLmhhc093blByb3BlcnR5KGcpJiYoZT1mW2ddLFwiY2hpbGRyZW5cIj09PWc/XCJzdHJpbmdcIj09PXR5cGVvZiBlP2QudGV4dENvbnRlbnQhPT1lJiYoYT1bXCJjaGlsZHJlblwiLGVdKTpcIm51bWJlclwiPT09dHlwZW9mIGUmJmQudGV4dENvbnRlbnQhPT1cIlwiK2UmJihhPVtcImNoaWxkcmVuXCIsXCJcIitlXSk6Y2EuaGFzT3duUHJvcGVydHkoZykmJm51bGwhPWUmJlwib25TY3JvbGxcIj09PWcmJkcoXCJzY3JvbGxcIixkKSk7c3dpdGNoKGMpe2Nhc2UgXCJpbnB1dFwiOlZhKGQpO2NiKGQsZiwhMCk7YnJlYWs7Y2FzZSBcInRleHRhcmVhXCI6VmEoZCk7amIoZCk7YnJlYWs7Y2FzZSBcInNlbGVjdFwiOmNhc2UgXCJvcHRpb25cIjpicmVhaztkZWZhdWx0OlwiZnVuY3Rpb25cIj09PXR5cGVvZiBmLm9uQ2xpY2smJihkLm9uY2xpY2s9XG5qZil9ZD1hO2IudXBkYXRlUXVldWU9ZDtudWxsIT09ZCYmKGIuZmxhZ3N8PTQpfWVsc2V7Zz05PT09ZS5ub2RlVHlwZT9lOmUub3duZXJEb2N1bWVudDthPT09a2IuaHRtbCYmKGE9bGIoYykpO2E9PT1rYi5odG1sP1wic2NyaXB0XCI9PT1jPyhhPWcuY3JlYXRlRWxlbWVudChcImRpdlwiKSxhLmlubmVySFRNTD1cIjxzY3JpcHQ+XFx4M2Mvc2NyaXB0PlwiLGE9YS5yZW1vdmVDaGlsZChhLmZpcnN0Q2hpbGQpKTpcInN0cmluZ1wiPT09dHlwZW9mIGQuaXM/YT1nLmNyZWF0ZUVsZW1lbnQoYyx7aXM6ZC5pc30pOihhPWcuY3JlYXRlRWxlbWVudChjKSxcInNlbGVjdFwiPT09YyYmKGc9YSxkLm11bHRpcGxlP2cubXVsdGlwbGU9ITA6ZC5zaXplJiYoZy5zaXplPWQuc2l6ZSkpKTphPWcuY3JlYXRlRWxlbWVudE5TKGEsYyk7YVt3Zl09YjthW3hmXT1kO0JpKGEsYiwhMSwhMSk7Yi5zdGF0ZU5vZGU9YTtnPXdiKGMsZCk7c3dpdGNoKGMpe2Nhc2UgXCJkaWFsb2dcIjpHKFwiY2FuY2VsXCIsYSk7RyhcImNsb3NlXCIsYSk7XG5lPWQ7YnJlYWs7Y2FzZSBcImlmcmFtZVwiOmNhc2UgXCJvYmplY3RcIjpjYXNlIFwiZW1iZWRcIjpHKFwibG9hZFwiLGEpO2U9ZDticmVhaztjYXNlIFwidmlkZW9cIjpjYXNlIFwiYXVkaW9cIjpmb3IoZT0wO2U8WGUubGVuZ3RoO2UrKylHKFhlW2VdLGEpO2U9ZDticmVhaztjYXNlIFwic291cmNlXCI6RyhcImVycm9yXCIsYSk7ZT1kO2JyZWFrO2Nhc2UgXCJpbWdcIjpjYXNlIFwiaW1hZ2VcIjpjYXNlIFwibGlua1wiOkcoXCJlcnJvclwiLGEpO0coXCJsb2FkXCIsYSk7ZT1kO2JyZWFrO2Nhc2UgXCJkZXRhaWxzXCI6RyhcInRvZ2dsZVwiLGEpO2U9ZDticmVhaztjYXNlIFwiaW5wdXRcIjpaYShhLGQpO2U9WWEoYSxkKTtHKFwiaW52YWxpZFwiLGEpO2JyZWFrO2Nhc2UgXCJvcHRpb25cIjplPWViKGEsZCk7YnJlYWs7Y2FzZSBcInNlbGVjdFwiOmEuX3dyYXBwZXJTdGF0ZT17d2FzTXVsdGlwbGU6ISFkLm11bHRpcGxlfTtlPW0oe30sZCx7dmFsdWU6dm9pZCAwfSk7RyhcImludmFsaWRcIixhKTticmVhaztjYXNlIFwidGV4dGFyZWFcIjpoYihhLGQpO2U9XG5nYihhLGQpO0coXCJpbnZhbGlkXCIsYSk7YnJlYWs7ZGVmYXVsdDplPWR9dmIoYyxlKTt2YXIgaD1lO2ZvcihmIGluIGgpaWYoaC5oYXNPd25Qcm9wZXJ0eShmKSl7dmFyIGs9aFtmXTtcInN0eWxlXCI9PT1mP3RiKGEsayk6XCJkYW5nZXJvdXNseVNldElubmVySFRNTFwiPT09Zj8oaz1rP2suX19odG1sOnZvaWQgMCxudWxsIT1rJiZvYihhLGspKTpcImNoaWxkcmVuXCI9PT1mP1wic3RyaW5nXCI9PT10eXBlb2Ygaz8oXCJ0ZXh0YXJlYVwiIT09Y3x8XCJcIiE9PWspJiZwYihhLGspOlwibnVtYmVyXCI9PT10eXBlb2YgayYmcGIoYSxcIlwiK2spOlwic3VwcHJlc3NDb250ZW50RWRpdGFibGVXYXJuaW5nXCIhPT1mJiZcInN1cHByZXNzSHlkcmF0aW9uV2FybmluZ1wiIT09ZiYmXCJhdXRvRm9jdXNcIiE9PWYmJihjYS5oYXNPd25Qcm9wZXJ0eShmKT9udWxsIT1rJiZcIm9uU2Nyb2xsXCI9PT1mJiZHKFwic2Nyb2xsXCIsYSk6bnVsbCE9ayYmcWEoYSxmLGssZykpfXN3aXRjaChjKXtjYXNlIFwiaW5wdXRcIjpWYShhKTtjYihhLGQsITEpO1xuYnJlYWs7Y2FzZSBcInRleHRhcmVhXCI6VmEoYSk7amIoYSk7YnJlYWs7Y2FzZSBcIm9wdGlvblwiOm51bGwhPWQudmFsdWUmJmEuc2V0QXR0cmlidXRlKFwidmFsdWVcIixcIlwiK1NhKGQudmFsdWUpKTticmVhaztjYXNlIFwic2VsZWN0XCI6YS5tdWx0aXBsZT0hIWQubXVsdGlwbGU7Zj1kLnZhbHVlO251bGwhPWY/ZmIoYSwhIWQubXVsdGlwbGUsZiwhMSk6bnVsbCE9ZC5kZWZhdWx0VmFsdWUmJmZiKGEsISFkLm11bHRpcGxlLGQuZGVmYXVsdFZhbHVlLCEwKTticmVhaztkZWZhdWx0OlwiZnVuY3Rpb25cIj09PXR5cGVvZiBlLm9uQ2xpY2smJihhLm9uY2xpY2s9amYpfW1mKGMsZCkmJihiLmZsYWdzfD00KX1udWxsIT09Yi5yZWYmJihiLmZsYWdzfD0xMjgpfXJldHVybiBudWxsO2Nhc2UgNjppZihhJiZudWxsIT1iLnN0YXRlTm9kZSlFaShhLGIsYS5tZW1vaXplZFByb3BzLGQpO2Vsc2V7aWYoXCJzdHJpbmdcIiE9PXR5cGVvZiBkJiZudWxsPT09Yi5zdGF0ZU5vZGUpdGhyb3cgRXJyb3IoeSgxNjYpKTtcbmM9ZGgoY2guY3VycmVudCk7ZGgoYWguY3VycmVudCk7cmgoYik/KGQ9Yi5zdGF0ZU5vZGUsYz1iLm1lbW9pemVkUHJvcHMsZFt3Zl09YixkLm5vZGVWYWx1ZSE9PWMmJihiLmZsYWdzfD00KSk6KGQ9KDk9PT1jLm5vZGVUeXBlP2M6Yy5vd25lckRvY3VtZW50KS5jcmVhdGVUZXh0Tm9kZShkKSxkW3dmXT1iLGIuc3RhdGVOb2RlPWQpfXJldHVybiBudWxsO2Nhc2UgMTM6SChQKTtkPWIubWVtb2l6ZWRTdGF0ZTtpZigwIT09KGIuZmxhZ3MmNjQpKXJldHVybiBiLmxhbmVzPWMsYjtkPW51bGwhPT1kO2M9ITE7bnVsbD09PWE/dm9pZCAwIT09Yi5tZW1vaXplZFByb3BzLmZhbGxiYWNrJiZyaChiKTpjPW51bGwhPT1hLm1lbW9pemVkU3RhdGU7aWYoZCYmIWMmJjAhPT0oYi5tb2RlJjIpKWlmKG51bGw9PT1hJiYhMCE9PWIubWVtb2l6ZWRQcm9wcy51bnN0YWJsZV9hdm9pZFRoaXNGYWxsYmFja3x8MCE9PShQLmN1cnJlbnQmMSkpMD09PVYmJihWPTMpO2Vsc2V7aWYoMD09PVZ8fDM9PT1WKVY9XG40O251bGw9PT1VfHwwPT09KERnJjEzNDIxNzcyNykmJjA9PT0oSGkmMTM0MjE3NzI3KXx8SWkoVSxXKX1pZihkfHxjKWIuZmxhZ3N8PTQ7cmV0dXJuIG51bGw7Y2FzZSA0OnJldHVybiBmaCgpLENpKGIpLG51bGw9PT1hJiZjZihiLnN0YXRlTm9kZS5jb250YWluZXJJbmZvKSxudWxsO2Nhc2UgMTA6cmV0dXJuIHJnKGIpLG51bGw7Y2FzZSAxNzpyZXR1cm4gRmYoYi50eXBlKSYmR2YoKSxudWxsO2Nhc2UgMTk6SChQKTtkPWIubWVtb2l6ZWRTdGF0ZTtpZihudWxsPT09ZClyZXR1cm4gbnVsbDtmPTAhPT0oYi5mbGFncyY2NCk7Zz1kLnJlbmRlcmluZztpZihudWxsPT09ZylpZihmKUZpKGQsITEpO2Vsc2V7aWYoMCE9PVZ8fG51bGwhPT1hJiYwIT09KGEuZmxhZ3MmNjQpKWZvcihhPWIuY2hpbGQ7bnVsbCE9PWE7KXtnPWloKGEpO2lmKG51bGwhPT1nKXtiLmZsYWdzfD02NDtGaShkLCExKTtmPWcudXBkYXRlUXVldWU7bnVsbCE9PWYmJihiLnVwZGF0ZVF1ZXVlPWYsYi5mbGFnc3w9NCk7XG5udWxsPT09ZC5sYXN0RWZmZWN0JiYoYi5maXJzdEVmZmVjdD1udWxsKTtiLmxhc3RFZmZlY3Q9ZC5sYXN0RWZmZWN0O2Q9Yztmb3IoYz1iLmNoaWxkO251bGwhPT1jOylmPWMsYT1kLGYuZmxhZ3MmPTIsZi5uZXh0RWZmZWN0PW51bGwsZi5maXJzdEVmZmVjdD1udWxsLGYubGFzdEVmZmVjdD1udWxsLGc9Zi5hbHRlcm5hdGUsbnVsbD09PWc/KGYuY2hpbGRMYW5lcz0wLGYubGFuZXM9YSxmLmNoaWxkPW51bGwsZi5tZW1vaXplZFByb3BzPW51bGwsZi5tZW1vaXplZFN0YXRlPW51bGwsZi51cGRhdGVRdWV1ZT1udWxsLGYuZGVwZW5kZW5jaWVzPW51bGwsZi5zdGF0ZU5vZGU9bnVsbCk6KGYuY2hpbGRMYW5lcz1nLmNoaWxkTGFuZXMsZi5sYW5lcz1nLmxhbmVzLGYuY2hpbGQ9Zy5jaGlsZCxmLm1lbW9pemVkUHJvcHM9Zy5tZW1vaXplZFByb3BzLGYubWVtb2l6ZWRTdGF0ZT1nLm1lbW9pemVkU3RhdGUsZi51cGRhdGVRdWV1ZT1nLnVwZGF0ZVF1ZXVlLGYudHlwZT1nLnR5cGUsYT1nLmRlcGVuZGVuY2llcyxcbmYuZGVwZW5kZW5jaWVzPW51bGw9PT1hP251bGw6e2xhbmVzOmEubGFuZXMsZmlyc3RDb250ZXh0OmEuZmlyc3RDb250ZXh0fSksYz1jLnNpYmxpbmc7SShQLFAuY3VycmVudCYxfDIpO3JldHVybiBiLmNoaWxkfWE9YS5zaWJsaW5nfW51bGwhPT1kLnRhaWwmJk8oKT5KaSYmKGIuZmxhZ3N8PTY0LGY9ITAsRmkoZCwhMSksYi5sYW5lcz0zMzU1NDQzMil9ZWxzZXtpZighZilpZihhPWloKGcpLG51bGwhPT1hKXtpZihiLmZsYWdzfD02NCxmPSEwLGM9YS51cGRhdGVRdWV1ZSxudWxsIT09YyYmKGIudXBkYXRlUXVldWU9YyxiLmZsYWdzfD00KSxGaShkLCEwKSxudWxsPT09ZC50YWlsJiZcImhpZGRlblwiPT09ZC50YWlsTW9kZSYmIWcuYWx0ZXJuYXRlJiYhbGgpcmV0dXJuIGI9Yi5sYXN0RWZmZWN0PWQubGFzdEVmZmVjdCxudWxsIT09YiYmKGIubmV4dEVmZmVjdD1udWxsKSxudWxsfWVsc2UgMipPKCktZC5yZW5kZXJpbmdTdGFydFRpbWU+SmkmJjEwNzM3NDE4MjQhPT1jJiYoYi5mbGFnc3w9XG42NCxmPSEwLEZpKGQsITEpLGIubGFuZXM9MzM1NTQ0MzIpO2QuaXNCYWNrd2FyZHM/KGcuc2libGluZz1iLmNoaWxkLGIuY2hpbGQ9Zyk6KGM9ZC5sYXN0LG51bGwhPT1jP2Muc2libGluZz1nOmIuY2hpbGQ9ZyxkLmxhc3Q9Zyl9cmV0dXJuIG51bGwhPT1kLnRhaWw/KGM9ZC50YWlsLGQucmVuZGVyaW5nPWMsZC50YWlsPWMuc2libGluZyxkLmxhc3RFZmZlY3Q9Yi5sYXN0RWZmZWN0LGQucmVuZGVyaW5nU3RhcnRUaW1lPU8oKSxjLnNpYmxpbmc9bnVsbCxiPVAuY3VycmVudCxJKFAsZj9iJjF8MjpiJjEpLGMpOm51bGw7Y2FzZSAyMzpjYXNlIDI0OnJldHVybiBLaSgpLG51bGwhPT1hJiZudWxsIT09YS5tZW1vaXplZFN0YXRlIT09KG51bGwhPT1iLm1lbW9pemVkU3RhdGUpJiZcInVuc3RhYmxlLWRlZmVyLXdpdGhvdXQtaGlkaW5nXCIhPT1kLm1vZGUmJihiLmZsYWdzfD00KSxudWxsfXRocm93IEVycm9yKHkoMTU2LGIudGFnKSk7fVxuZnVuY3Rpb24gTGkoYSl7c3dpdGNoKGEudGFnKXtjYXNlIDE6RmYoYS50eXBlKSYmR2YoKTt2YXIgYj1hLmZsYWdzO3JldHVybiBiJjQwOTY/KGEuZmxhZ3M9YiYtNDA5N3w2NCxhKTpudWxsO2Nhc2UgMzpmaCgpO0goTik7SChNKTt1aCgpO2I9YS5mbGFncztpZigwIT09KGImNjQpKXRocm93IEVycm9yKHkoMjg1KSk7YS5mbGFncz1iJi00MDk3fDY0O3JldHVybiBhO2Nhc2UgNTpyZXR1cm4gaGgoYSksbnVsbDtjYXNlIDEzOnJldHVybiBIKFApLGI9YS5mbGFncyxiJjQwOTY/KGEuZmxhZ3M9YiYtNDA5N3w2NCxhKTpudWxsO2Nhc2UgMTk6cmV0dXJuIEgoUCksbnVsbDtjYXNlIDQ6cmV0dXJuIGZoKCksbnVsbDtjYXNlIDEwOnJldHVybiByZyhhKSxudWxsO2Nhc2UgMjM6Y2FzZSAyNDpyZXR1cm4gS2koKSxudWxsO2RlZmF1bHQ6cmV0dXJuIG51bGx9fVxuZnVuY3Rpb24gTWkoYSxiKXt0cnl7dmFyIGM9XCJcIixkPWI7ZG8gYys9UWEoZCksZD1kLnJldHVybjt3aGlsZShkKTt2YXIgZT1jfWNhdGNoKGYpe2U9XCJcXG5FcnJvciBnZW5lcmF0aW5nIHN0YWNrOiBcIitmLm1lc3NhZ2UrXCJcXG5cIitmLnN0YWNrfXJldHVybnt2YWx1ZTphLHNvdXJjZTpiLHN0YWNrOmV9fWZ1bmN0aW9uIE5pKGEsYil7dHJ5e2NvbnNvbGUuZXJyb3IoYi52YWx1ZSl9Y2F0Y2goYyl7c2V0VGltZW91dChmdW5jdGlvbigpe3Rocm93IGM7fSl9fXZhciBPaT1cImZ1bmN0aW9uXCI9PT10eXBlb2YgV2Vha01hcD9XZWFrTWFwOk1hcDtmdW5jdGlvbiBQaShhLGIsYyl7Yz16ZygtMSxjKTtjLnRhZz0zO2MucGF5bG9hZD17ZWxlbWVudDpudWxsfTt2YXIgZD1iLnZhbHVlO2MuY2FsbGJhY2s9ZnVuY3Rpb24oKXtRaXx8KFFpPSEwLFJpPWQpO05pKGEsYil9O3JldHVybiBjfVxuZnVuY3Rpb24gU2koYSxiLGMpe2M9emcoLTEsYyk7Yy50YWc9Mzt2YXIgZD1hLnR5cGUuZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yO2lmKFwiZnVuY3Rpb25cIj09PXR5cGVvZiBkKXt2YXIgZT1iLnZhbHVlO2MucGF5bG9hZD1mdW5jdGlvbigpe05pKGEsYik7cmV0dXJuIGQoZSl9fXZhciBmPWEuc3RhdGVOb2RlO251bGwhPT1mJiZcImZ1bmN0aW9uXCI9PT10eXBlb2YgZi5jb21wb25lbnREaWRDYXRjaCYmKGMuY2FsbGJhY2s9ZnVuY3Rpb24oKXtcImZ1bmN0aW9uXCIhPT10eXBlb2YgZCYmKG51bGw9PT1UaT9UaT1uZXcgU2V0KFt0aGlzXSk6VGkuYWRkKHRoaXMpLE5pKGEsYikpO3ZhciBjPWIuc3RhY2s7dGhpcy5jb21wb25lbnREaWRDYXRjaChiLnZhbHVlLHtjb21wb25lbnRTdGFjazpudWxsIT09Yz9jOlwiXCJ9KX0pO3JldHVybiBjfXZhciBVaT1cImZ1bmN0aW9uXCI9PT10eXBlb2YgV2Vha1NldD9XZWFrU2V0OlNldDtcbmZ1bmN0aW9uIFZpKGEpe3ZhciBiPWEucmVmO2lmKG51bGwhPT1iKWlmKFwiZnVuY3Rpb25cIj09PXR5cGVvZiBiKXRyeXtiKG51bGwpfWNhdGNoKGMpe1dpKGEsYyl9ZWxzZSBiLmN1cnJlbnQ9bnVsbH1mdW5jdGlvbiBYaShhLGIpe3N3aXRjaChiLnRhZyl7Y2FzZSAwOmNhc2UgMTE6Y2FzZSAxNTpjYXNlIDIyOnJldHVybjtjYXNlIDE6aWYoYi5mbGFncyYyNTYmJm51bGwhPT1hKXt2YXIgYz1hLm1lbW9pemVkUHJvcHMsZD1hLm1lbW9pemVkU3RhdGU7YT1iLnN0YXRlTm9kZTtiPWEuZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUoYi5lbGVtZW50VHlwZT09PWIudHlwZT9jOmxnKGIudHlwZSxjKSxkKTthLl9fcmVhY3RJbnRlcm5hbFNuYXBzaG90QmVmb3JlVXBkYXRlPWJ9cmV0dXJuO2Nhc2UgMzpiLmZsYWdzJjI1NiYmcWYoYi5zdGF0ZU5vZGUuY29udGFpbmVySW5mbyk7cmV0dXJuO2Nhc2UgNTpjYXNlIDY6Y2FzZSA0OmNhc2UgMTc6cmV0dXJufXRocm93IEVycm9yKHkoMTYzKSk7fVxuZnVuY3Rpb24gWWkoYSxiLGMpe3N3aXRjaChjLnRhZyl7Y2FzZSAwOmNhc2UgMTE6Y2FzZSAxNTpjYXNlIDIyOmI9Yy51cGRhdGVRdWV1ZTtiPW51bGwhPT1iP2IubGFzdEVmZmVjdDpudWxsO2lmKG51bGwhPT1iKXthPWI9Yi5uZXh0O2Rve2lmKDM9PT0oYS50YWcmMykpe3ZhciBkPWEuY3JlYXRlO2EuZGVzdHJveT1kKCl9YT1hLm5leHR9d2hpbGUoYSE9PWIpfWI9Yy51cGRhdGVRdWV1ZTtiPW51bGwhPT1iP2IubGFzdEVmZmVjdDpudWxsO2lmKG51bGwhPT1iKXthPWI9Yi5uZXh0O2Rve3ZhciBlPWE7ZD1lLm5leHQ7ZT1lLnRhZzswIT09KGUmNCkmJjAhPT0oZSYxKSYmKFppKGMsYSksJGkoYyxhKSk7YT1kfXdoaWxlKGEhPT1iKX1yZXR1cm47Y2FzZSAxOmE9Yy5zdGF0ZU5vZGU7Yy5mbGFncyY0JiYobnVsbD09PWI/YS5jb21wb25lbnREaWRNb3VudCgpOihkPWMuZWxlbWVudFR5cGU9PT1jLnR5cGU/Yi5tZW1vaXplZFByb3BzOmxnKGMudHlwZSxiLm1lbW9pemVkUHJvcHMpLGEuY29tcG9uZW50RGlkVXBkYXRlKGQsXG5iLm1lbW9pemVkU3RhdGUsYS5fX3JlYWN0SW50ZXJuYWxTbmFwc2hvdEJlZm9yZVVwZGF0ZSkpKTtiPWMudXBkYXRlUXVldWU7bnVsbCE9PWImJkVnKGMsYixhKTtyZXR1cm47Y2FzZSAzOmI9Yy51cGRhdGVRdWV1ZTtpZihudWxsIT09Yil7YT1udWxsO2lmKG51bGwhPT1jLmNoaWxkKXN3aXRjaChjLmNoaWxkLnRhZyl7Y2FzZSA1OmE9Yy5jaGlsZC5zdGF0ZU5vZGU7YnJlYWs7Y2FzZSAxOmE9Yy5jaGlsZC5zdGF0ZU5vZGV9RWcoYyxiLGEpfXJldHVybjtjYXNlIDU6YT1jLnN0YXRlTm9kZTtudWxsPT09YiYmYy5mbGFncyY0JiZtZihjLnR5cGUsYy5tZW1vaXplZFByb3BzKSYmYS5mb2N1cygpO3JldHVybjtjYXNlIDY6cmV0dXJuO2Nhc2UgNDpyZXR1cm47Y2FzZSAxMjpyZXR1cm47Y2FzZSAxMzpudWxsPT09Yy5tZW1vaXplZFN0YXRlJiYoYz1jLmFsdGVybmF0ZSxudWxsIT09YyYmKGM9Yy5tZW1vaXplZFN0YXRlLG51bGwhPT1jJiYoYz1jLmRlaHlkcmF0ZWQsbnVsbCE9PWMmJkNjKGMpKSkpO1xucmV0dXJuO2Nhc2UgMTk6Y2FzZSAxNzpjYXNlIDIwOmNhc2UgMjE6Y2FzZSAyMzpjYXNlIDI0OnJldHVybn10aHJvdyBFcnJvcih5KDE2MykpO31cbmZ1bmN0aW9uIGFqKGEsYil7Zm9yKHZhciBjPWE7Oyl7aWYoNT09PWMudGFnKXt2YXIgZD1jLnN0YXRlTm9kZTtpZihiKWQ9ZC5zdHlsZSxcImZ1bmN0aW9uXCI9PT10eXBlb2YgZC5zZXRQcm9wZXJ0eT9kLnNldFByb3BlcnR5KFwiZGlzcGxheVwiLFwibm9uZVwiLFwiaW1wb3J0YW50XCIpOmQuZGlzcGxheT1cIm5vbmVcIjtlbHNle2Q9Yy5zdGF0ZU5vZGU7dmFyIGU9Yy5tZW1vaXplZFByb3BzLnN0eWxlO2U9dm9pZCAwIT09ZSYmbnVsbCE9PWUmJmUuaGFzT3duUHJvcGVydHkoXCJkaXNwbGF5XCIpP2UuZGlzcGxheTpudWxsO2Quc3R5bGUuZGlzcGxheT1zYihcImRpc3BsYXlcIixlKX19ZWxzZSBpZig2PT09Yy50YWcpYy5zdGF0ZU5vZGUubm9kZVZhbHVlPWI/XCJcIjpjLm1lbW9pemVkUHJvcHM7ZWxzZSBpZigoMjMhPT1jLnRhZyYmMjQhPT1jLnRhZ3x8bnVsbD09PWMubWVtb2l6ZWRTdGF0ZXx8Yz09PWEpJiZudWxsIT09Yy5jaGlsZCl7Yy5jaGlsZC5yZXR1cm49YztjPWMuY2hpbGQ7Y29udGludWV9aWYoYz09PVxuYSlicmVhaztmb3IoO251bGw9PT1jLnNpYmxpbmc7KXtpZihudWxsPT09Yy5yZXR1cm58fGMucmV0dXJuPT09YSlyZXR1cm47Yz1jLnJldHVybn1jLnNpYmxpbmcucmV0dXJuPWMucmV0dXJuO2M9Yy5zaWJsaW5nfX1cbmZ1bmN0aW9uIGJqKGEsYil7aWYoTWYmJlwiZnVuY3Rpb25cIj09PXR5cGVvZiBNZi5vbkNvbW1pdEZpYmVyVW5tb3VudCl0cnl7TWYub25Db21taXRGaWJlclVubW91bnQoTGYsYil9Y2F0Y2goZil7fXN3aXRjaChiLnRhZyl7Y2FzZSAwOmNhc2UgMTE6Y2FzZSAxNDpjYXNlIDE1OmNhc2UgMjI6YT1iLnVwZGF0ZVF1ZXVlO2lmKG51bGwhPT1hJiYoYT1hLmxhc3RFZmZlY3QsbnVsbCE9PWEpKXt2YXIgYz1hPWEubmV4dDtkb3t2YXIgZD1jLGU9ZC5kZXN0cm95O2Q9ZC50YWc7aWYodm9pZCAwIT09ZSlpZigwIT09KGQmNCkpWmkoYixjKTtlbHNle2Q9Yjt0cnl7ZSgpfWNhdGNoKGYpe1dpKGQsZil9fWM9Yy5uZXh0fXdoaWxlKGMhPT1hKX1icmVhaztjYXNlIDE6VmkoYik7YT1iLnN0YXRlTm9kZTtpZihcImZ1bmN0aW9uXCI9PT10eXBlb2YgYS5jb21wb25lbnRXaWxsVW5tb3VudCl0cnl7YS5wcm9wcz1iLm1lbW9pemVkUHJvcHMsYS5zdGF0ZT1iLm1lbW9pemVkU3RhdGUsYS5jb21wb25lbnRXaWxsVW5tb3VudCgpfWNhdGNoKGYpe1dpKGIsXG5mKX1icmVhaztjYXNlIDU6VmkoYik7YnJlYWs7Y2FzZSA0OmNqKGEsYil9fWZ1bmN0aW9uIGRqKGEpe2EuYWx0ZXJuYXRlPW51bGw7YS5jaGlsZD1udWxsO2EuZGVwZW5kZW5jaWVzPW51bGw7YS5maXJzdEVmZmVjdD1udWxsO2EubGFzdEVmZmVjdD1udWxsO2EubWVtb2l6ZWRQcm9wcz1udWxsO2EubWVtb2l6ZWRTdGF0ZT1udWxsO2EucGVuZGluZ1Byb3BzPW51bGw7YS5yZXR1cm49bnVsbDthLnVwZGF0ZVF1ZXVlPW51bGx9ZnVuY3Rpb24gZWooYSl7cmV0dXJuIDU9PT1hLnRhZ3x8Mz09PWEudGFnfHw0PT09YS50YWd9XG5mdW5jdGlvbiBmaihhKXthOntmb3IodmFyIGI9YS5yZXR1cm47bnVsbCE9PWI7KXtpZihlaihiKSlicmVhayBhO2I9Yi5yZXR1cm59dGhyb3cgRXJyb3IoeSgxNjApKTt9dmFyIGM9YjtiPWMuc3RhdGVOb2RlO3N3aXRjaChjLnRhZyl7Y2FzZSA1OnZhciBkPSExO2JyZWFrO2Nhc2UgMzpiPWIuY29udGFpbmVySW5mbztkPSEwO2JyZWFrO2Nhc2UgNDpiPWIuY29udGFpbmVySW5mbztkPSEwO2JyZWFrO2RlZmF1bHQ6dGhyb3cgRXJyb3IoeSgxNjEpKTt9Yy5mbGFncyYxNiYmKHBiKGIsXCJcIiksYy5mbGFncyY9LTE3KTthOmI6Zm9yKGM9YTs7KXtmb3IoO251bGw9PT1jLnNpYmxpbmc7KXtpZihudWxsPT09Yy5yZXR1cm58fGVqKGMucmV0dXJuKSl7Yz1udWxsO2JyZWFrIGF9Yz1jLnJldHVybn1jLnNpYmxpbmcucmV0dXJuPWMucmV0dXJuO2ZvcihjPWMuc2libGluZzs1IT09Yy50YWcmJjYhPT1jLnRhZyYmMTghPT1jLnRhZzspe2lmKGMuZmxhZ3MmMiljb250aW51ZSBiO2lmKG51bGw9PT1cbmMuY2hpbGR8fDQ9PT1jLnRhZyljb250aW51ZSBiO2Vsc2UgYy5jaGlsZC5yZXR1cm49YyxjPWMuY2hpbGR9aWYoIShjLmZsYWdzJjIpKXtjPWMuc3RhdGVOb2RlO2JyZWFrIGF9fWQ/Z2ooYSxjLGIpOmhqKGEsYyxiKX1cbmZ1bmN0aW9uIGdqKGEsYixjKXt2YXIgZD1hLnRhZyxlPTU9PT1kfHw2PT09ZDtpZihlKWE9ZT9hLnN0YXRlTm9kZTphLnN0YXRlTm9kZS5pbnN0YW5jZSxiPzg9PT1jLm5vZGVUeXBlP2MucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoYSxiKTpjLmluc2VydEJlZm9yZShhLGIpOig4PT09Yy5ub2RlVHlwZT8oYj1jLnBhcmVudE5vZGUsYi5pbnNlcnRCZWZvcmUoYSxjKSk6KGI9YyxiLmFwcGVuZENoaWxkKGEpKSxjPWMuX3JlYWN0Um9vdENvbnRhaW5lcixudWxsIT09YyYmdm9pZCAwIT09Y3x8bnVsbCE9PWIub25jbGlja3x8KGIub25jbGljaz1qZikpO2Vsc2UgaWYoNCE9PWQmJihhPWEuY2hpbGQsbnVsbCE9PWEpKWZvcihnaihhLGIsYyksYT1hLnNpYmxpbmc7bnVsbCE9PWE7KWdqKGEsYixjKSxhPWEuc2libGluZ31cbmZ1bmN0aW9uIGhqKGEsYixjKXt2YXIgZD1hLnRhZyxlPTU9PT1kfHw2PT09ZDtpZihlKWE9ZT9hLnN0YXRlTm9kZTphLnN0YXRlTm9kZS5pbnN0YW5jZSxiP2MuaW5zZXJ0QmVmb3JlKGEsYik6Yy5hcHBlbmRDaGlsZChhKTtlbHNlIGlmKDQhPT1kJiYoYT1hLmNoaWxkLG51bGwhPT1hKSlmb3IoaGooYSxiLGMpLGE9YS5zaWJsaW5nO251bGwhPT1hOyloaihhLGIsYyksYT1hLnNpYmxpbmd9XG5mdW5jdGlvbiBjaihhLGIpe2Zvcih2YXIgYz1iLGQ9ITEsZSxmOzspe2lmKCFkKXtkPWMucmV0dXJuO2E6Zm9yKDs7KXtpZihudWxsPT09ZCl0aHJvdyBFcnJvcih5KDE2MCkpO2U9ZC5zdGF0ZU5vZGU7c3dpdGNoKGQudGFnKXtjYXNlIDU6Zj0hMTticmVhayBhO2Nhc2UgMzplPWUuY29udGFpbmVySW5mbztmPSEwO2JyZWFrIGE7Y2FzZSA0OmU9ZS5jb250YWluZXJJbmZvO2Y9ITA7YnJlYWsgYX1kPWQucmV0dXJufWQ9ITB9aWYoNT09PWMudGFnfHw2PT09Yy50YWcpe2E6Zm9yKHZhciBnPWEsaD1jLGs9aDs7KWlmKGJqKGcsayksbnVsbCE9PWsuY2hpbGQmJjQhPT1rLnRhZylrLmNoaWxkLnJldHVybj1rLGs9ay5jaGlsZDtlbHNle2lmKGs9PT1oKWJyZWFrIGE7Zm9yKDtudWxsPT09ay5zaWJsaW5nOyl7aWYobnVsbD09PWsucmV0dXJufHxrLnJldHVybj09PWgpYnJlYWsgYTtrPWsucmV0dXJufWsuc2libGluZy5yZXR1cm49ay5yZXR1cm47az1rLnNpYmxpbmd9Zj8oZz1lLGg9Yy5zdGF0ZU5vZGUsXG44PT09Zy5ub2RlVHlwZT9nLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoaCk6Zy5yZW1vdmVDaGlsZChoKSk6ZS5yZW1vdmVDaGlsZChjLnN0YXRlTm9kZSl9ZWxzZSBpZig0PT09Yy50YWcpe2lmKG51bGwhPT1jLmNoaWxkKXtlPWMuc3RhdGVOb2RlLmNvbnRhaW5lckluZm87Zj0hMDtjLmNoaWxkLnJldHVybj1jO2M9Yy5jaGlsZDtjb250aW51ZX19ZWxzZSBpZihiaihhLGMpLG51bGwhPT1jLmNoaWxkKXtjLmNoaWxkLnJldHVybj1jO2M9Yy5jaGlsZDtjb250aW51ZX1pZihjPT09YilicmVhaztmb3IoO251bGw9PT1jLnNpYmxpbmc7KXtpZihudWxsPT09Yy5yZXR1cm58fGMucmV0dXJuPT09YilyZXR1cm47Yz1jLnJldHVybjs0PT09Yy50YWcmJihkPSExKX1jLnNpYmxpbmcucmV0dXJuPWMucmV0dXJuO2M9Yy5zaWJsaW5nfX1cbmZ1bmN0aW9uIGlqKGEsYil7c3dpdGNoKGIudGFnKXtjYXNlIDA6Y2FzZSAxMTpjYXNlIDE0OmNhc2UgMTU6Y2FzZSAyMjp2YXIgYz1iLnVwZGF0ZVF1ZXVlO2M9bnVsbCE9PWM/Yy5sYXN0RWZmZWN0Om51bGw7aWYobnVsbCE9PWMpe3ZhciBkPWM9Yy5uZXh0O2RvIDM9PT0oZC50YWcmMykmJihhPWQuZGVzdHJveSxkLmRlc3Ryb3k9dm9pZCAwLHZvaWQgMCE9PWEmJmEoKSksZD1kLm5leHQ7d2hpbGUoZCE9PWMpfXJldHVybjtjYXNlIDE6cmV0dXJuO2Nhc2UgNTpjPWIuc3RhdGVOb2RlO2lmKG51bGwhPWMpe2Q9Yi5tZW1vaXplZFByb3BzO3ZhciBlPW51bGwhPT1hP2EubWVtb2l6ZWRQcm9wczpkO2E9Yi50eXBlO3ZhciBmPWIudXBkYXRlUXVldWU7Yi51cGRhdGVRdWV1ZT1udWxsO2lmKG51bGwhPT1mKXtjW3hmXT1kO1wiaW5wdXRcIj09PWEmJlwicmFkaW9cIj09PWQudHlwZSYmbnVsbCE9ZC5uYW1lJiYkYShjLGQpO3diKGEsZSk7Yj13YihhLGQpO2ZvcihlPTA7ZTxmLmxlbmd0aDtlKz1cbjIpe3ZhciBnPWZbZV0saD1mW2UrMV07XCJzdHlsZVwiPT09Zz90YihjLGgpOlwiZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxcIj09PWc/b2IoYyxoKTpcImNoaWxkcmVuXCI9PT1nP3BiKGMsaCk6cWEoYyxnLGgsYil9c3dpdGNoKGEpe2Nhc2UgXCJpbnB1dFwiOmFiKGMsZCk7YnJlYWs7Y2FzZSBcInRleHRhcmVhXCI6aWIoYyxkKTticmVhaztjYXNlIFwic2VsZWN0XCI6YT1jLl93cmFwcGVyU3RhdGUud2FzTXVsdGlwbGUsYy5fd3JhcHBlclN0YXRlLndhc011bHRpcGxlPSEhZC5tdWx0aXBsZSxmPWQudmFsdWUsbnVsbCE9Zj9mYihjLCEhZC5tdWx0aXBsZSxmLCExKTphIT09ISFkLm11bHRpcGxlJiYobnVsbCE9ZC5kZWZhdWx0VmFsdWU/ZmIoYywhIWQubXVsdGlwbGUsZC5kZWZhdWx0VmFsdWUsITApOmZiKGMsISFkLm11bHRpcGxlLGQubXVsdGlwbGU/W106XCJcIiwhMSkpfX19cmV0dXJuO2Nhc2UgNjppZihudWxsPT09Yi5zdGF0ZU5vZGUpdGhyb3cgRXJyb3IoeSgxNjIpKTtiLnN0YXRlTm9kZS5ub2RlVmFsdWU9XG5iLm1lbW9pemVkUHJvcHM7cmV0dXJuO2Nhc2UgMzpjPWIuc3RhdGVOb2RlO2MuaHlkcmF0ZSYmKGMuaHlkcmF0ZT0hMSxDYyhjLmNvbnRhaW5lckluZm8pKTtyZXR1cm47Y2FzZSAxMjpyZXR1cm47Y2FzZSAxMzpudWxsIT09Yi5tZW1vaXplZFN0YXRlJiYoamo9TygpLGFqKGIuY2hpbGQsITApKTtraihiKTtyZXR1cm47Y2FzZSAxOTpraihiKTtyZXR1cm47Y2FzZSAxNzpyZXR1cm47Y2FzZSAyMzpjYXNlIDI0OmFqKGIsbnVsbCE9PWIubWVtb2l6ZWRTdGF0ZSk7cmV0dXJufXRocm93IEVycm9yKHkoMTYzKSk7fWZ1bmN0aW9uIGtqKGEpe3ZhciBiPWEudXBkYXRlUXVldWU7aWYobnVsbCE9PWIpe2EudXBkYXRlUXVldWU9bnVsbDt2YXIgYz1hLnN0YXRlTm9kZTtudWxsPT09YyYmKGM9YS5zdGF0ZU5vZGU9bmV3IFVpKTtiLmZvckVhY2goZnVuY3Rpb24oYil7dmFyIGQ9bGouYmluZChudWxsLGEsYik7Yy5oYXMoYil8fChjLmFkZChiKSxiLnRoZW4oZCxkKSl9KX19XG5mdW5jdGlvbiBtaihhLGIpe3JldHVybiBudWxsIT09YSYmKGE9YS5tZW1vaXplZFN0YXRlLG51bGw9PT1hfHxudWxsIT09YS5kZWh5ZHJhdGVkKT8oYj1iLm1lbW9pemVkU3RhdGUsbnVsbCE9PWImJm51bGw9PT1iLmRlaHlkcmF0ZWQpOiExfXZhciBuaj1NYXRoLmNlaWwsb2o9cmEuUmVhY3RDdXJyZW50RGlzcGF0Y2hlcixwaj1yYS5SZWFjdEN1cnJlbnRPd25lcixYPTAsVT1udWxsLFk9bnVsbCxXPTAscWo9MCxyaj1CZigwKSxWPTAsc2o9bnVsbCx0aj0wLERnPTAsSGk9MCx1aj0wLHZqPW51bGwsamo9MCxKaT1JbmZpbml0eTtmdW5jdGlvbiB3aigpe0ppPU8oKSs1MDB9dmFyIFo9bnVsbCxRaT0hMSxSaT1udWxsLFRpPW51bGwseGo9ITEseWo9bnVsbCx6aj05MCxBaj1bXSxCaj1bXSxDaj1udWxsLERqPTAsRWo9bnVsbCxGaj0tMSxHaj0wLEhqPTAsSWo9bnVsbCxKaj0hMTtmdW5jdGlvbiBIZygpe3JldHVybiAwIT09KFgmNDgpP08oKTotMSE9PUZqP0ZqOkZqPU8oKX1cbmZ1bmN0aW9uIElnKGEpe2E9YS5tb2RlO2lmKDA9PT0oYSYyKSlyZXR1cm4gMTtpZigwPT09KGEmNCkpcmV0dXJuIDk5PT09ZWcoKT8xOjI7MD09PUdqJiYoR2o9dGopO2lmKDAhPT1rZy50cmFuc2l0aW9uKXswIT09SGomJihIaj1udWxsIT09dmo/dmoucGVuZGluZ0xhbmVzOjApO2E9R2o7dmFyIGI9NDE4NjExMiZ+SGo7YiY9LWI7MD09PWImJihhPTQxODYxMTImfmEsYj1hJi1hLDA9PT1iJiYoYj04MTkyKSk7cmV0dXJuIGJ9YT1lZygpOzAhPT0oWCY0KSYmOTg9PT1hP2E9WGMoMTIsR2opOihhPVNjKGEpLGE9WGMoYSxHaikpO3JldHVybiBhfVxuZnVuY3Rpb24gSmcoYSxiLGMpe2lmKDUwPERqKXRocm93IERqPTAsRWo9bnVsbCxFcnJvcih5KDE4NSkpO2E9S2ooYSxiKTtpZihudWxsPT09YSlyZXR1cm4gbnVsbDskYyhhLGIsYyk7YT09PVUmJihIaXw9Yiw0PT09ViYmSWkoYSxXKSk7dmFyIGQ9ZWcoKTsxPT09Yj8wIT09KFgmOCkmJjA9PT0oWCY0OCk/TGooYSk6KE1qKGEsYyksMD09PVgmJih3aigpLGlnKCkpKTooMD09PShYJjQpfHw5OCE9PWQmJjk5IT09ZHx8KG51bGw9PT1Daj9Daj1uZXcgU2V0KFthXSk6Q2ouYWRkKGEpKSxNaihhLGMpKTt2aj1hfWZ1bmN0aW9uIEtqKGEsYil7YS5sYW5lc3w9Yjt2YXIgYz1hLmFsdGVybmF0ZTtudWxsIT09YyYmKGMubGFuZXN8PWIpO2M9YTtmb3IoYT1hLnJldHVybjtudWxsIT09YTspYS5jaGlsZExhbmVzfD1iLGM9YS5hbHRlcm5hdGUsbnVsbCE9PWMmJihjLmNoaWxkTGFuZXN8PWIpLGM9YSxhPWEucmV0dXJuO3JldHVybiAzPT09Yy50YWc/Yy5zdGF0ZU5vZGU6bnVsbH1cbmZ1bmN0aW9uIE1qKGEsYil7Zm9yKHZhciBjPWEuY2FsbGJhY2tOb2RlLGQ9YS5zdXNwZW5kZWRMYW5lcyxlPWEucGluZ2VkTGFuZXMsZj1hLmV4cGlyYXRpb25UaW1lcyxnPWEucGVuZGluZ0xhbmVzOzA8Zzspe3ZhciBoPTMxLVZjKGcpLGs9MTw8aCxsPWZbaF07aWYoLTE9PT1sKXtpZigwPT09KGsmZCl8fDAhPT0oayZlKSl7bD1iO1JjKGspO3ZhciBuPUY7ZltoXT0xMDw9bj9sKzI1MDo2PD1uP2wrNUUzOi0xfX1lbHNlIGw8PWImJihhLmV4cGlyZWRMYW5lc3w9ayk7ZyY9fmt9ZD1VYyhhLGE9PT1VP1c6MCk7Yj1GO2lmKDA9PT1kKW51bGwhPT1jJiYoYyE9PVpmJiZQZihjKSxhLmNhbGxiYWNrTm9kZT1udWxsLGEuY2FsbGJhY2tQcmlvcml0eT0wKTtlbHNle2lmKG51bGwhPT1jKXtpZihhLmNhbGxiYWNrUHJpb3JpdHk9PT1iKXJldHVybjtjIT09WmYmJlBmKGMpfTE1PT09Yj8oYz1Mai5iaW5kKG51bGwsYSksbnVsbD09PWFnPyhhZz1bY10sYmc9T2YoVWYsamcpKTphZy5wdXNoKGMpLFxuYz1aZik6MTQ9PT1iP2M9aGcoOTksTGouYmluZChudWxsLGEpKTooYz1UYyhiKSxjPWhnKGMsTmouYmluZChudWxsLGEpKSk7YS5jYWxsYmFja1ByaW9yaXR5PWI7YS5jYWxsYmFja05vZGU9Y319XG5mdW5jdGlvbiBOaihhKXtGaj0tMTtIaj1Haj0wO2lmKDAhPT0oWCY0OCkpdGhyb3cgRXJyb3IoeSgzMjcpKTt2YXIgYj1hLmNhbGxiYWNrTm9kZTtpZihPaigpJiZhLmNhbGxiYWNrTm9kZSE9PWIpcmV0dXJuIG51bGw7dmFyIGM9VWMoYSxhPT09VT9XOjApO2lmKDA9PT1jKXJldHVybiBudWxsO3ZhciBkPWM7dmFyIGU9WDtYfD0xNjt2YXIgZj1QaigpO2lmKFUhPT1hfHxXIT09ZCl3aigpLFFqKGEsZCk7ZG8gdHJ5e1JqKCk7YnJlYWt9Y2F0Y2goaCl7U2ooYSxoKX13aGlsZSgxKTtxZygpO29qLmN1cnJlbnQ9ZjtYPWU7bnVsbCE9PVk/ZD0wOihVPW51bGwsVz0wLGQ9Vik7aWYoMCE9PSh0aiZIaSkpUWooYSwwKTtlbHNlIGlmKDAhPT1kKXsyPT09ZCYmKFh8PTY0LGEuaHlkcmF0ZSYmKGEuaHlkcmF0ZT0hMSxxZihhLmNvbnRhaW5lckluZm8pKSxjPVdjKGEpLDAhPT1jJiYoZD1UaihhLGMpKSk7aWYoMT09PWQpdGhyb3cgYj1zaixRaihhLDApLElpKGEsYyksTWooYSxPKCkpLGI7YS5maW5pc2hlZFdvcms9XG5hLmN1cnJlbnQuYWx0ZXJuYXRlO2EuZmluaXNoZWRMYW5lcz1jO3N3aXRjaChkKXtjYXNlIDA6Y2FzZSAxOnRocm93IEVycm9yKHkoMzQ1KSk7Y2FzZSAyOlVqKGEpO2JyZWFrO2Nhc2UgMzpJaShhLGMpO2lmKChjJjYyOTE0NTYwKT09PWMmJihkPWpqKzUwMC1PKCksMTA8ZCkpe2lmKDAhPT1VYyhhLDApKWJyZWFrO2U9YS5zdXNwZW5kZWRMYW5lcztpZigoZSZjKSE9PWMpe0hnKCk7YS5waW5nZWRMYW5lc3w9YS5zdXNwZW5kZWRMYW5lcyZlO2JyZWFrfWEudGltZW91dEhhbmRsZT1vZihVai5iaW5kKG51bGwsYSksZCk7YnJlYWt9VWooYSk7YnJlYWs7Y2FzZSA0OklpKGEsYyk7aWYoKGMmNDE4NjExMik9PT1jKWJyZWFrO2Q9YS5ldmVudFRpbWVzO2ZvcihlPS0xOzA8Yzspe3ZhciBnPTMxLVZjKGMpO2Y9MTw8ZztnPWRbZ107Zz5lJiYoZT1nKTtjJj1+Zn1jPWU7Yz1PKCktYztjPSgxMjA+Yz8xMjA6NDgwPmM/NDgwOjEwODA+Yz8xMDgwOjE5MjA+Yz8xOTIwOjNFMz5jPzNFMzo0MzIwPlxuYz80MzIwOjE5NjAqbmooYy8xOTYwKSktYztpZigxMDxjKXthLnRpbWVvdXRIYW5kbGU9b2YoVWouYmluZChudWxsLGEpLGMpO2JyZWFrfVVqKGEpO2JyZWFrO2Nhc2UgNTpVaihhKTticmVhaztkZWZhdWx0OnRocm93IEVycm9yKHkoMzI5KSk7fX1NaihhLE8oKSk7cmV0dXJuIGEuY2FsbGJhY2tOb2RlPT09Yj9Oai5iaW5kKG51bGwsYSk6bnVsbH1mdW5jdGlvbiBJaShhLGIpe2ImPX51ajtiJj1+SGk7YS5zdXNwZW5kZWRMYW5lc3w9YjthLnBpbmdlZExhbmVzJj1+Yjtmb3IoYT1hLmV4cGlyYXRpb25UaW1lczswPGI7KXt2YXIgYz0zMS1WYyhiKSxkPTE8PGM7YVtjXT0tMTtiJj1+ZH19XG5mdW5jdGlvbiBMaihhKXtpZigwIT09KFgmNDgpKXRocm93IEVycm9yKHkoMzI3KSk7T2ooKTtpZihhPT09VSYmMCE9PShhLmV4cGlyZWRMYW5lcyZXKSl7dmFyIGI9Vzt2YXIgYz1UaihhLGIpOzAhPT0odGomSGkpJiYoYj1VYyhhLGIpLGM9VGooYSxiKSl9ZWxzZSBiPVVjKGEsMCksYz1UaihhLGIpOzAhPT1hLnRhZyYmMj09PWMmJihYfD02NCxhLmh5ZHJhdGUmJihhLmh5ZHJhdGU9ITEscWYoYS5jb250YWluZXJJbmZvKSksYj1XYyhhKSwwIT09YiYmKGM9VGooYSxiKSkpO2lmKDE9PT1jKXRocm93IGM9c2osUWooYSwwKSxJaShhLGIpLE1qKGEsTygpKSxjO2EuZmluaXNoZWRXb3JrPWEuY3VycmVudC5hbHRlcm5hdGU7YS5maW5pc2hlZExhbmVzPWI7VWooYSk7TWooYSxPKCkpO3JldHVybiBudWxsfVxuZnVuY3Rpb24gVmooKXtpZihudWxsIT09Q2ope3ZhciBhPUNqO0NqPW51bGw7YS5mb3JFYWNoKGZ1bmN0aW9uKGEpe2EuZXhwaXJlZExhbmVzfD0yNCZhLnBlbmRpbmdMYW5lcztNaihhLE8oKSl9KX1pZygpfWZ1bmN0aW9uIFdqKGEsYil7dmFyIGM9WDtYfD0xO3RyeXtyZXR1cm4gYShiKX1maW5hbGx5e1g9YywwPT09WCYmKHdqKCksaWcoKSl9fWZ1bmN0aW9uIFhqKGEsYil7dmFyIGM9WDtYJj0tMjtYfD04O3RyeXtyZXR1cm4gYShiKX1maW5hbGx5e1g9YywwPT09WCYmKHdqKCksaWcoKSl9fWZ1bmN0aW9uIG5pKGEsYil7SShyaixxaik7cWp8PWI7dGp8PWJ9ZnVuY3Rpb24gS2koKXtxaj1yai5jdXJyZW50O0gocmopfVxuZnVuY3Rpb24gUWooYSxiKXthLmZpbmlzaGVkV29yaz1udWxsO2EuZmluaXNoZWRMYW5lcz0wO3ZhciBjPWEudGltZW91dEhhbmRsZTstMSE9PWMmJihhLnRpbWVvdXRIYW5kbGU9LTEscGYoYykpO2lmKG51bGwhPT1ZKWZvcihjPVkucmV0dXJuO251bGwhPT1jOyl7dmFyIGQ9Yztzd2l0Y2goZC50YWcpe2Nhc2UgMTpkPWQudHlwZS5jaGlsZENvbnRleHRUeXBlcztudWxsIT09ZCYmdm9pZCAwIT09ZCYmR2YoKTticmVhaztjYXNlIDM6ZmgoKTtIKE4pO0goTSk7dWgoKTticmVhaztjYXNlIDU6aGgoZCk7YnJlYWs7Y2FzZSA0OmZoKCk7YnJlYWs7Y2FzZSAxMzpIKFApO2JyZWFrO2Nhc2UgMTk6SChQKTticmVhaztjYXNlIDEwOnJnKGQpO2JyZWFrO2Nhc2UgMjM6Y2FzZSAyNDpLaSgpfWM9Yy5yZXR1cm59VT1hO1k9VGcoYS5jdXJyZW50LG51bGwpO1c9cWo9dGo9YjtWPTA7c2o9bnVsbDt1aj1IaT1EZz0wfVxuZnVuY3Rpb24gU2ooYSxiKXtkb3t2YXIgYz1ZO3RyeXtxZygpO3ZoLmN1cnJlbnQ9R2g7aWYoeWgpe2Zvcih2YXIgZD1SLm1lbW9pemVkU3RhdGU7bnVsbCE9PWQ7KXt2YXIgZT1kLnF1ZXVlO251bGwhPT1lJiYoZS5wZW5kaW5nPW51bGwpO2Q9ZC5uZXh0fXloPSExfXhoPTA7VD1TPVI9bnVsbDt6aD0hMTtwai5jdXJyZW50PW51bGw7aWYobnVsbD09PWN8fG51bGw9PT1jLnJldHVybil7Vj0xO3NqPWI7WT1udWxsO2JyZWFrfWE6e3ZhciBmPWEsZz1jLnJldHVybixoPWMsaz1iO2I9VztoLmZsYWdzfD0yMDQ4O2guZmlyc3RFZmZlY3Q9aC5sYXN0RWZmZWN0PW51bGw7aWYobnVsbCE9PWsmJlwib2JqZWN0XCI9PT10eXBlb2YgayYmXCJmdW5jdGlvblwiPT09dHlwZW9mIGsudGhlbil7dmFyIGw9aztpZigwPT09KGgubW9kZSYyKSl7dmFyIG49aC5hbHRlcm5hdGU7bj8oaC51cGRhdGVRdWV1ZT1uLnVwZGF0ZVF1ZXVlLGgubWVtb2l6ZWRTdGF0ZT1uLm1lbW9pemVkU3RhdGUsaC5sYW5lcz1uLmxhbmVzKTpcbihoLnVwZGF0ZVF1ZXVlPW51bGwsaC5tZW1vaXplZFN0YXRlPW51bGwpfXZhciBBPTAhPT0oUC5jdXJyZW50JjEpLHA9Zztkb3t2YXIgQztpZihDPTEzPT09cC50YWcpe3ZhciB4PXAubWVtb2l6ZWRTdGF0ZTtpZihudWxsIT09eClDPW51bGwhPT14LmRlaHlkcmF0ZWQ/ITA6ITE7ZWxzZXt2YXIgdz1wLm1lbW9pemVkUHJvcHM7Qz12b2lkIDA9PT13LmZhbGxiYWNrPyExOiEwIT09dy51bnN0YWJsZV9hdm9pZFRoaXNGYWxsYmFjaz8hMDpBPyExOiEwfX1pZihDKXt2YXIgej1wLnVwZGF0ZVF1ZXVlO2lmKG51bGw9PT16KXt2YXIgdT1uZXcgU2V0O3UuYWRkKGwpO3AudXBkYXRlUXVldWU9dX1lbHNlIHouYWRkKGwpO2lmKDA9PT0ocC5tb2RlJjIpKXtwLmZsYWdzfD02NDtoLmZsYWdzfD0xNjM4NDtoLmZsYWdzJj0tMjk4MTtpZigxPT09aC50YWcpaWYobnVsbD09PWguYWx0ZXJuYXRlKWgudGFnPTE3O2Vsc2V7dmFyIHQ9emcoLTEsMSk7dC50YWc9MjtBZyhoLHQpfWgubGFuZXN8PTE7YnJlYWsgYX1rPVxudm9pZCAwO2g9Yjt2YXIgcT1mLnBpbmdDYWNoZTtudWxsPT09cT8ocT1mLnBpbmdDYWNoZT1uZXcgT2ksaz1uZXcgU2V0LHEuc2V0KGwsaykpOihrPXEuZ2V0KGwpLHZvaWQgMD09PWsmJihrPW5ldyBTZXQscS5zZXQobCxrKSkpO2lmKCFrLmhhcyhoKSl7ay5hZGQoaCk7dmFyIHY9WWouYmluZChudWxsLGYsbCxoKTtsLnRoZW4odix2KX1wLmZsYWdzfD00MDk2O3AubGFuZXM9YjticmVhayBhfXA9cC5yZXR1cm59d2hpbGUobnVsbCE9PXApO2s9RXJyb3IoKFJhKGgudHlwZSl8fFwiQSBSZWFjdCBjb21wb25lbnRcIikrXCIgc3VzcGVuZGVkIHdoaWxlIHJlbmRlcmluZywgYnV0IG5vIGZhbGxiYWNrIFVJIHdhcyBzcGVjaWZpZWQuXFxuXFxuQWRkIGEgPFN1c3BlbnNlIGZhbGxiYWNrPS4uLj4gY29tcG9uZW50IGhpZ2hlciBpbiB0aGUgdHJlZSB0byBwcm92aWRlIGEgbG9hZGluZyBpbmRpY2F0b3Igb3IgcGxhY2Vob2xkZXIgdG8gZGlzcGxheS5cIil9NSE9PVYmJihWPTIpO2s9TWkoayxoKTtwPVxuZztkb3tzd2l0Y2gocC50YWcpe2Nhc2UgMzpmPWs7cC5mbGFnc3w9NDA5NjtiJj0tYjtwLmxhbmVzfD1iO3ZhciBKPVBpKHAsZixiKTtCZyhwLEopO2JyZWFrIGE7Y2FzZSAxOmY9azt2YXIgSz1wLnR5cGUsUT1wLnN0YXRlTm9kZTtpZigwPT09KHAuZmxhZ3MmNjQpJiYoXCJmdW5jdGlvblwiPT09dHlwZW9mIEsuZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yfHxudWxsIT09USYmXCJmdW5jdGlvblwiPT09dHlwZW9mIFEuY29tcG9uZW50RGlkQ2F0Y2gmJihudWxsPT09VGl8fCFUaS5oYXMoUSkpKSl7cC5mbGFnc3w9NDA5NjtiJj0tYjtwLmxhbmVzfD1iO3ZhciBMPVNpKHAsZixiKTtCZyhwLEwpO2JyZWFrIGF9fXA9cC5yZXR1cm59d2hpbGUobnVsbCE9PXApfVpqKGMpfWNhdGNoKHZhKXtiPXZhO1k9PT1jJiZudWxsIT09YyYmKFk9Yz1jLnJldHVybik7Y29udGludWV9YnJlYWt9d2hpbGUoMSl9XG5mdW5jdGlvbiBQaigpe3ZhciBhPW9qLmN1cnJlbnQ7b2ouY3VycmVudD1HaDtyZXR1cm4gbnVsbD09PWE/R2g6YX1mdW5jdGlvbiBUaihhLGIpe3ZhciBjPVg7WHw9MTY7dmFyIGQ9UGooKTtVPT09YSYmVz09PWJ8fFFqKGEsYik7ZG8gdHJ5e2FrKCk7YnJlYWt9Y2F0Y2goZSl7U2ooYSxlKX13aGlsZSgxKTtxZygpO1g9Yztvai5jdXJyZW50PWQ7aWYobnVsbCE9PVkpdGhyb3cgRXJyb3IoeSgyNjEpKTtVPW51bGw7Vz0wO3JldHVybiBWfWZ1bmN0aW9uIGFrKCl7Zm9yKDtudWxsIT09WTspYmsoWSl9ZnVuY3Rpb24gUmooKXtmb3IoO251bGwhPT1ZJiYhUWYoKTspYmsoWSl9ZnVuY3Rpb24gYmsoYSl7dmFyIGI9Y2soYS5hbHRlcm5hdGUsYSxxaik7YS5tZW1vaXplZFByb3BzPWEucGVuZGluZ1Byb3BzO251bGw9PT1iP1pqKGEpOlk9Yjtwai5jdXJyZW50PW51bGx9XG5mdW5jdGlvbiBaaihhKXt2YXIgYj1hO2Rve3ZhciBjPWIuYWx0ZXJuYXRlO2E9Yi5yZXR1cm47aWYoMD09PShiLmZsYWdzJjIwNDgpKXtjPUdpKGMsYixxaik7aWYobnVsbCE9PWMpe1k9YztyZXR1cm59Yz1iO2lmKDI0IT09Yy50YWcmJjIzIT09Yy50YWd8fG51bGw9PT1jLm1lbW9pemVkU3RhdGV8fDAhPT0ocWomMTA3Mzc0MTgyNCl8fDA9PT0oYy5tb2RlJjQpKXtmb3IodmFyIGQ9MCxlPWMuY2hpbGQ7bnVsbCE9PWU7KWR8PWUubGFuZXN8ZS5jaGlsZExhbmVzLGU9ZS5zaWJsaW5nO2MuY2hpbGRMYW5lcz1kfW51bGwhPT1hJiYwPT09KGEuZmxhZ3MmMjA0OCkmJihudWxsPT09YS5maXJzdEVmZmVjdCYmKGEuZmlyc3RFZmZlY3Q9Yi5maXJzdEVmZmVjdCksbnVsbCE9PWIubGFzdEVmZmVjdCYmKG51bGwhPT1hLmxhc3RFZmZlY3QmJihhLmxhc3RFZmZlY3QubmV4dEVmZmVjdD1iLmZpcnN0RWZmZWN0KSxhLmxhc3RFZmZlY3Q9Yi5sYXN0RWZmZWN0KSwxPGIuZmxhZ3MmJihudWxsIT09XG5hLmxhc3RFZmZlY3Q/YS5sYXN0RWZmZWN0Lm5leHRFZmZlY3Q9YjphLmZpcnN0RWZmZWN0PWIsYS5sYXN0RWZmZWN0PWIpKX1lbHNle2M9TGkoYik7aWYobnVsbCE9PWMpe2MuZmxhZ3MmPTIwNDc7WT1jO3JldHVybn1udWxsIT09YSYmKGEuZmlyc3RFZmZlY3Q9YS5sYXN0RWZmZWN0PW51bGwsYS5mbGFnc3w9MjA0OCl9Yj1iLnNpYmxpbmc7aWYobnVsbCE9PWIpe1k9YjtyZXR1cm59WT1iPWF9d2hpbGUobnVsbCE9PWIpOzA9PT1WJiYoVj01KX1mdW5jdGlvbiBVaihhKXt2YXIgYj1lZygpO2dnKDk5LGRrLmJpbmQobnVsbCxhLGIpKTtyZXR1cm4gbnVsbH1cbmZ1bmN0aW9uIGRrKGEsYil7ZG8gT2ooKTt3aGlsZShudWxsIT09eWopO2lmKDAhPT0oWCY0OCkpdGhyb3cgRXJyb3IoeSgzMjcpKTt2YXIgYz1hLmZpbmlzaGVkV29yaztpZihudWxsPT09YylyZXR1cm4gbnVsbDthLmZpbmlzaGVkV29yaz1udWxsO2EuZmluaXNoZWRMYW5lcz0wO2lmKGM9PT1hLmN1cnJlbnQpdGhyb3cgRXJyb3IoeSgxNzcpKTthLmNhbGxiYWNrTm9kZT1udWxsO3ZhciBkPWMubGFuZXN8Yy5jaGlsZExhbmVzLGU9ZCxmPWEucGVuZGluZ0xhbmVzJn5lO2EucGVuZGluZ0xhbmVzPWU7YS5zdXNwZW5kZWRMYW5lcz0wO2EucGluZ2VkTGFuZXM9MDthLmV4cGlyZWRMYW5lcyY9ZTthLm11dGFibGVSZWFkTGFuZXMmPWU7YS5lbnRhbmdsZWRMYW5lcyY9ZTtlPWEuZW50YW5nbGVtZW50cztmb3IodmFyIGc9YS5ldmVudFRpbWVzLGg9YS5leHBpcmF0aW9uVGltZXM7MDxmOyl7dmFyIGs9MzEtVmMoZiksbD0xPDxrO2Vba109MDtnW2tdPS0xO2hba109LTE7ZiY9fmx9bnVsbCE9PVxuQ2omJjA9PT0oZCYyNCkmJkNqLmhhcyhhKSYmQ2ouZGVsZXRlKGEpO2E9PT1VJiYoWT1VPW51bGwsVz0wKTsxPGMuZmxhZ3M/bnVsbCE9PWMubGFzdEVmZmVjdD8oYy5sYXN0RWZmZWN0Lm5leHRFZmZlY3Q9YyxkPWMuZmlyc3RFZmZlY3QpOmQ9YzpkPWMuZmlyc3RFZmZlY3Q7aWYobnVsbCE9PWQpe2U9WDtYfD0zMjtwai5jdXJyZW50PW51bGw7a2Y9ZmQ7Zz1OZSgpO2lmKE9lKGcpKXtpZihcInNlbGVjdGlvblN0YXJ0XCJpbiBnKWg9e3N0YXJ0Omcuc2VsZWN0aW9uU3RhcnQsZW5kOmcuc2VsZWN0aW9uRW5kfTtlbHNlIGE6aWYoaD0oaD1nLm93bmVyRG9jdW1lbnQpJiZoLmRlZmF1bHRWaWV3fHx3aW5kb3csKGw9aC5nZXRTZWxlY3Rpb24mJmguZ2V0U2VsZWN0aW9uKCkpJiYwIT09bC5yYW5nZUNvdW50KXtoPWwuYW5jaG9yTm9kZTtmPWwuYW5jaG9yT2Zmc2V0O2s9bC5mb2N1c05vZGU7bD1sLmZvY3VzT2Zmc2V0O3RyeXtoLm5vZGVUeXBlLGsubm9kZVR5cGV9Y2F0Y2godmEpe2g9bnVsbDtcbmJyZWFrIGF9dmFyIG49MCxBPS0xLHA9LTEsQz0wLHg9MCx3PWcsej1udWxsO2I6Zm9yKDs7KXtmb3IodmFyIHU7Oyl7dyE9PWh8fDAhPT1mJiYzIT09dy5ub2RlVHlwZXx8KEE9bitmKTt3IT09a3x8MCE9PWwmJjMhPT13Lm5vZGVUeXBlfHwocD1uK2wpOzM9PT13Lm5vZGVUeXBlJiYobis9dy5ub2RlVmFsdWUubGVuZ3RoKTtpZihudWxsPT09KHU9dy5maXJzdENoaWxkKSlicmVhazt6PXc7dz11fWZvcig7Oyl7aWYodz09PWcpYnJlYWsgYjt6PT09aCYmKytDPT09ZiYmKEE9bik7ej09PWsmJisreD09PWwmJihwPW4pO2lmKG51bGwhPT0odT13Lm5leHRTaWJsaW5nKSlicmVhazt3PXo7ej13LnBhcmVudE5vZGV9dz11fWg9LTE9PT1BfHwtMT09PXA/bnVsbDp7c3RhcnQ6QSxlbmQ6cH19ZWxzZSBoPW51bGw7aD1ofHx7c3RhcnQ6MCxlbmQ6MH19ZWxzZSBoPW51bGw7bGY9e2ZvY3VzZWRFbGVtOmcsc2VsZWN0aW9uUmFuZ2U6aH07ZmQ9ITE7SWo9bnVsbDtKaj0hMTtaPWQ7ZG8gdHJ5e2VrKCl9Y2F0Y2godmEpe2lmKG51bGw9PT1cblopdGhyb3cgRXJyb3IoeSgzMzApKTtXaShaLHZhKTtaPVoubmV4dEVmZmVjdH13aGlsZShudWxsIT09Wik7SWo9bnVsbDtaPWQ7ZG8gdHJ5e2ZvcihnPWE7bnVsbCE9PVo7KXt2YXIgdD1aLmZsYWdzO3QmMTYmJnBiKFouc3RhdGVOb2RlLFwiXCIpO2lmKHQmMTI4KXt2YXIgcT1aLmFsdGVybmF0ZTtpZihudWxsIT09cSl7dmFyIHY9cS5yZWY7bnVsbCE9PXYmJihcImZ1bmN0aW9uXCI9PT10eXBlb2Ygdj92KG51bGwpOnYuY3VycmVudD1udWxsKX19c3dpdGNoKHQmMTAzOCl7Y2FzZSAyOmZqKFopO1ouZmxhZ3MmPS0zO2JyZWFrO2Nhc2UgNjpmaihaKTtaLmZsYWdzJj0tMztpaihaLmFsdGVybmF0ZSxaKTticmVhaztjYXNlIDEwMjQ6Wi5mbGFncyY9LTEwMjU7YnJlYWs7Y2FzZSAxMDI4OlouZmxhZ3MmPS0xMDI1O2lqKFouYWx0ZXJuYXRlLFopO2JyZWFrO2Nhc2UgNDppaihaLmFsdGVybmF0ZSxaKTticmVhaztjYXNlIDg6aD1aO2NqKGcsaCk7dmFyIEo9aC5hbHRlcm5hdGU7ZGooaCk7bnVsbCE9PVxuSiYmZGooSil9Wj1aLm5leHRFZmZlY3R9fWNhdGNoKHZhKXtpZihudWxsPT09Wil0aHJvdyBFcnJvcih5KDMzMCkpO1dpKFosdmEpO1o9Wi5uZXh0RWZmZWN0fXdoaWxlKG51bGwhPT1aKTt2PWxmO3E9TmUoKTt0PXYuZm9jdXNlZEVsZW07Zz12LnNlbGVjdGlvblJhbmdlO2lmKHEhPT10JiZ0JiZ0Lm93bmVyRG9jdW1lbnQmJk1lKHQub3duZXJEb2N1bWVudC5kb2N1bWVudEVsZW1lbnQsdCkpe251bGwhPT1nJiZPZSh0KSYmKHE9Zy5zdGFydCx2PWcuZW5kLHZvaWQgMD09PXYmJih2PXEpLFwic2VsZWN0aW9uU3RhcnRcImluIHQ/KHQuc2VsZWN0aW9uU3RhcnQ9cSx0LnNlbGVjdGlvbkVuZD1NYXRoLm1pbih2LHQudmFsdWUubGVuZ3RoKSk6KHY9KHE9dC5vd25lckRvY3VtZW50fHxkb2N1bWVudCkmJnEuZGVmYXVsdFZpZXd8fHdpbmRvdyx2LmdldFNlbGVjdGlvbiYmKHY9di5nZXRTZWxlY3Rpb24oKSxoPXQudGV4dENvbnRlbnQubGVuZ3RoLEo9TWF0aC5taW4oZy5zdGFydCxoKSxnPXZvaWQgMD09PVxuZy5lbmQ/SjpNYXRoLm1pbihnLmVuZCxoKSwhdi5leHRlbmQmJko+ZyYmKGg9ZyxnPUosSj1oKSxoPUxlKHQsSiksZj1MZSh0LGcpLGgmJmYmJigxIT09di5yYW5nZUNvdW50fHx2LmFuY2hvck5vZGUhPT1oLm5vZGV8fHYuYW5jaG9yT2Zmc2V0IT09aC5vZmZzZXR8fHYuZm9jdXNOb2RlIT09Zi5ub2RlfHx2LmZvY3VzT2Zmc2V0IT09Zi5vZmZzZXQpJiYocT1xLmNyZWF0ZVJhbmdlKCkscS5zZXRTdGFydChoLm5vZGUsaC5vZmZzZXQpLHYucmVtb3ZlQWxsUmFuZ2VzKCksSj5nPyh2LmFkZFJhbmdlKHEpLHYuZXh0ZW5kKGYubm9kZSxmLm9mZnNldCkpOihxLnNldEVuZChmLm5vZGUsZi5vZmZzZXQpLHYuYWRkUmFuZ2UocSkpKSkpKTtxPVtdO2Zvcih2PXQ7dj12LnBhcmVudE5vZGU7KTE9PT12Lm5vZGVUeXBlJiZxLnB1c2goe2VsZW1lbnQ6dixsZWZ0OnYuc2Nyb2xsTGVmdCx0b3A6di5zY3JvbGxUb3B9KTtcImZ1bmN0aW9uXCI9PT10eXBlb2YgdC5mb2N1cyYmdC5mb2N1cygpO2Zvcih0PVxuMDt0PHEubGVuZ3RoO3QrKyl2PXFbdF0sdi5lbGVtZW50LnNjcm9sbExlZnQ9di5sZWZ0LHYuZWxlbWVudC5zY3JvbGxUb3A9di50b3B9ZmQ9ISFrZjtsZj1rZj1udWxsO2EuY3VycmVudD1jO1o9ZDtkbyB0cnl7Zm9yKHQ9YTtudWxsIT09Wjspe3ZhciBLPVouZmxhZ3M7SyYzNiYmWWkodCxaLmFsdGVybmF0ZSxaKTtpZihLJjEyOCl7cT12b2lkIDA7dmFyIFE9Wi5yZWY7aWYobnVsbCE9PVEpe3ZhciBMPVouc3RhdGVOb2RlO3N3aXRjaChaLnRhZyl7Y2FzZSA1OnE9TDticmVhaztkZWZhdWx0OnE9TH1cImZ1bmN0aW9uXCI9PT10eXBlb2YgUT9RKHEpOlEuY3VycmVudD1xfX1aPVoubmV4dEVmZmVjdH19Y2F0Y2godmEpe2lmKG51bGw9PT1aKXRocm93IEVycm9yKHkoMzMwKSk7V2koWix2YSk7Wj1aLm5leHRFZmZlY3R9d2hpbGUobnVsbCE9PVopO1o9bnVsbDskZigpO1g9ZX1lbHNlIGEuY3VycmVudD1jO2lmKHhqKXhqPSExLHlqPWEsemo9YjtlbHNlIGZvcihaPWQ7bnVsbCE9PVo7KWI9XG5aLm5leHRFZmZlY3QsWi5uZXh0RWZmZWN0PW51bGwsWi5mbGFncyY4JiYoSz1aLEsuc2libGluZz1udWxsLEsuc3RhdGVOb2RlPW51bGwpLFo9YjtkPWEucGVuZGluZ0xhbmVzOzA9PT1kJiYoVGk9bnVsbCk7MT09PWQ/YT09PUVqP0RqKys6KERqPTAsRWo9YSk6RGo9MDtjPWMuc3RhdGVOb2RlO2lmKE1mJiZcImZ1bmN0aW9uXCI9PT10eXBlb2YgTWYub25Db21taXRGaWJlclJvb3QpdHJ5e01mLm9uQ29tbWl0RmliZXJSb290KExmLGMsdm9pZCAwLDY0PT09KGMuY3VycmVudC5mbGFncyY2NCkpfWNhdGNoKHZhKXt9TWooYSxPKCkpO2lmKFFpKXRocm93IFFpPSExLGE9UmksUmk9bnVsbCxhO2lmKDAhPT0oWCY4KSlyZXR1cm4gbnVsbDtpZygpO3JldHVybiBudWxsfVxuZnVuY3Rpb24gZWsoKXtmb3IoO251bGwhPT1aOyl7dmFyIGE9Wi5hbHRlcm5hdGU7Smp8fG51bGw9PT1Janx8KDAhPT0oWi5mbGFncyY4KT9kYyhaLElqKSYmKEpqPSEwKToxMz09PVoudGFnJiZtaihhLFopJiZkYyhaLElqKSYmKEpqPSEwKSk7dmFyIGI9Wi5mbGFnczswIT09KGImMjU2KSYmWGkoYSxaKTswPT09KGImNTEyKXx8eGp8fCh4aj0hMCxoZyg5NyxmdW5jdGlvbigpe09qKCk7cmV0dXJuIG51bGx9KSk7Wj1aLm5leHRFZmZlY3R9fWZ1bmN0aW9uIE9qKCl7aWYoOTAhPT16ail7dmFyIGE9OTc8emo/OTc6emo7emo9OTA7cmV0dXJuIGdnKGEsZmspfXJldHVybiExfWZ1bmN0aW9uICRpKGEsYil7QWoucHVzaChiLGEpO3hqfHwoeGo9ITAsaGcoOTcsZnVuY3Rpb24oKXtPaigpO3JldHVybiBudWxsfSkpfWZ1bmN0aW9uIFppKGEsYil7QmoucHVzaChiLGEpO3hqfHwoeGo9ITAsaGcoOTcsZnVuY3Rpb24oKXtPaigpO3JldHVybiBudWxsfSkpfVxuZnVuY3Rpb24gZmsoKXtpZihudWxsPT09eWopcmV0dXJuITE7dmFyIGE9eWo7eWo9bnVsbDtpZigwIT09KFgmNDgpKXRocm93IEVycm9yKHkoMzMxKSk7dmFyIGI9WDtYfD0zMjt2YXIgYz1CajtCaj1bXTtmb3IodmFyIGQ9MDtkPGMubGVuZ3RoO2QrPTIpe3ZhciBlPWNbZF0sZj1jW2QrMV0sZz1lLmRlc3Ryb3k7ZS5kZXN0cm95PXZvaWQgMDtpZihcImZ1bmN0aW9uXCI9PT10eXBlb2YgZyl0cnl7ZygpfWNhdGNoKGspe2lmKG51bGw9PT1mKXRocm93IEVycm9yKHkoMzMwKSk7V2koZixrKX19Yz1BajtBaj1bXTtmb3IoZD0wO2Q8Yy5sZW5ndGg7ZCs9Mil7ZT1jW2RdO2Y9Y1tkKzFdO3RyeXt2YXIgaD1lLmNyZWF0ZTtlLmRlc3Ryb3k9aCgpfWNhdGNoKGspe2lmKG51bGw9PT1mKXRocm93IEVycm9yKHkoMzMwKSk7V2koZixrKX19Zm9yKGg9YS5jdXJyZW50LmZpcnN0RWZmZWN0O251bGwhPT1oOylhPWgubmV4dEVmZmVjdCxoLm5leHRFZmZlY3Q9bnVsbCxoLmZsYWdzJjgmJihoLnNpYmxpbmc9XG5udWxsLGguc3RhdGVOb2RlPW51bGwpLGg9YTtYPWI7aWcoKTtyZXR1cm4hMH1mdW5jdGlvbiBnayhhLGIsYyl7Yj1NaShjLGIpO2I9UGkoYSxiLDEpO0FnKGEsYik7Yj1IZygpO2E9S2ooYSwxKTtudWxsIT09YSYmKCRjKGEsMSxiKSxNaihhLGIpKX1cbmZ1bmN0aW9uIFdpKGEsYil7aWYoMz09PWEudGFnKWdrKGEsYSxiKTtlbHNlIGZvcih2YXIgYz1hLnJldHVybjtudWxsIT09Yzspe2lmKDM9PT1jLnRhZyl7Z2soYyxhLGIpO2JyZWFrfWVsc2UgaWYoMT09PWMudGFnKXt2YXIgZD1jLnN0YXRlTm9kZTtpZihcImZ1bmN0aW9uXCI9PT10eXBlb2YgYy50eXBlLmdldERlcml2ZWRTdGF0ZUZyb21FcnJvcnx8XCJmdW5jdGlvblwiPT09dHlwZW9mIGQuY29tcG9uZW50RGlkQ2F0Y2gmJihudWxsPT09VGl8fCFUaS5oYXMoZCkpKXthPU1pKGIsYSk7dmFyIGU9U2koYyxhLDEpO0FnKGMsZSk7ZT1IZygpO2M9S2ooYywxKTtpZihudWxsIT09YykkYyhjLDEsZSksTWooYyxlKTtlbHNlIGlmKFwiZnVuY3Rpb25cIj09PXR5cGVvZiBkLmNvbXBvbmVudERpZENhdGNoJiYobnVsbD09PVRpfHwhVGkuaGFzKGQpKSl0cnl7ZC5jb21wb25lbnREaWRDYXRjaChiLGEpfWNhdGNoKGYpe31icmVha319Yz1jLnJldHVybn19XG5mdW5jdGlvbiBZaihhLGIsYyl7dmFyIGQ9YS5waW5nQ2FjaGU7bnVsbCE9PWQmJmQuZGVsZXRlKGIpO2I9SGcoKTthLnBpbmdlZExhbmVzfD1hLnN1c3BlbmRlZExhbmVzJmM7VT09PWEmJihXJmMpPT09YyYmKDQ9PT1WfHwzPT09ViYmKFcmNjI5MTQ1NjApPT09VyYmNTAwPk8oKS1qaj9RaihhLDApOnVqfD1jKTtNaihhLGIpfWZ1bmN0aW9uIGxqKGEsYil7dmFyIGM9YS5zdGF0ZU5vZGU7bnVsbCE9PWMmJmMuZGVsZXRlKGIpO2I9MDswPT09YiYmKGI9YS5tb2RlLDA9PT0oYiYyKT9iPTE6MD09PShiJjQpP2I9OTk9PT1lZygpPzE6MjooMD09PUdqJiYoR2o9dGopLGI9WWMoNjI5MTQ1NjAmfkdqKSwwPT09YiYmKGI9NDE5NDMwNCkpKTtjPUhnKCk7YT1LaihhLGIpO251bGwhPT1hJiYoJGMoYSxiLGMpLE1qKGEsYykpfXZhciBjaztcbmNrPWZ1bmN0aW9uKGEsYixjKXt2YXIgZD1iLmxhbmVzO2lmKG51bGwhPT1hKWlmKGEubWVtb2l6ZWRQcm9wcyE9PWIucGVuZGluZ1Byb3BzfHxOLmN1cnJlbnQpdWc9ITA7ZWxzZSBpZigwIT09KGMmZCkpdWc9MCE9PShhLmZsYWdzJjE2Mzg0KT8hMDohMTtlbHNle3VnPSExO3N3aXRjaChiLnRhZyl7Y2FzZSAzOnJpKGIpO3NoKCk7YnJlYWs7Y2FzZSA1OmdoKGIpO2JyZWFrO2Nhc2UgMTpGZihiLnR5cGUpJiZKZihiKTticmVhaztjYXNlIDQ6ZWgoYixiLnN0YXRlTm9kZS5jb250YWluZXJJbmZvKTticmVhaztjYXNlIDEwOmQ9Yi5tZW1vaXplZFByb3BzLnZhbHVlO3ZhciBlPWIudHlwZS5fY29udGV4dDtJKG1nLGUuX2N1cnJlbnRWYWx1ZSk7ZS5fY3VycmVudFZhbHVlPWQ7YnJlYWs7Y2FzZSAxMzppZihudWxsIT09Yi5tZW1vaXplZFN0YXRlKXtpZigwIT09KGMmYi5jaGlsZC5jaGlsZExhbmVzKSlyZXR1cm4gdGkoYSxiLGMpO0koUCxQLmN1cnJlbnQmMSk7Yj1oaShhLGIsYyk7cmV0dXJuIG51bGwhPT1cbmI/Yi5zaWJsaW5nOm51bGx9SShQLFAuY3VycmVudCYxKTticmVhaztjYXNlIDE5OmQ9MCE9PShjJmIuY2hpbGRMYW5lcyk7aWYoMCE9PShhLmZsYWdzJjY0KSl7aWYoZClyZXR1cm4gQWkoYSxiLGMpO2IuZmxhZ3N8PTY0fWU9Yi5tZW1vaXplZFN0YXRlO251bGwhPT1lJiYoZS5yZW5kZXJpbmc9bnVsbCxlLnRhaWw9bnVsbCxlLmxhc3RFZmZlY3Q9bnVsbCk7SShQLFAuY3VycmVudCk7aWYoZClicmVhaztlbHNlIHJldHVybiBudWxsO2Nhc2UgMjM6Y2FzZSAyNDpyZXR1cm4gYi5sYW5lcz0wLG1pKGEsYixjKX1yZXR1cm4gaGkoYSxiLGMpfWVsc2UgdWc9ITE7Yi5sYW5lcz0wO3N3aXRjaChiLnRhZyl7Y2FzZSAyOmQ9Yi50eXBlO251bGwhPT1hJiYoYS5hbHRlcm5hdGU9bnVsbCxiLmFsdGVybmF0ZT1udWxsLGIuZmxhZ3N8PTIpO2E9Yi5wZW5kaW5nUHJvcHM7ZT1FZihiLE0uY3VycmVudCk7dGcoYixjKTtlPUNoKG51bGwsYixkLGEsZSxjKTtiLmZsYWdzfD0xO2lmKFwib2JqZWN0XCI9PT1cbnR5cGVvZiBlJiZudWxsIT09ZSYmXCJmdW5jdGlvblwiPT09dHlwZW9mIGUucmVuZGVyJiZ2b2lkIDA9PT1lLiQkdHlwZW9mKXtiLnRhZz0xO2IubWVtb2l6ZWRTdGF0ZT1udWxsO2IudXBkYXRlUXVldWU9bnVsbDtpZihGZihkKSl7dmFyIGY9ITA7SmYoYil9ZWxzZSBmPSExO2IubWVtb2l6ZWRTdGF0ZT1udWxsIT09ZS5zdGF0ZSYmdm9pZCAwIT09ZS5zdGF0ZT9lLnN0YXRlOm51bGw7eGcoYik7dmFyIGc9ZC5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHM7XCJmdW5jdGlvblwiPT09dHlwZW9mIGcmJkdnKGIsZCxnLGEpO2UudXBkYXRlcj1LZztiLnN0YXRlTm9kZT1lO2UuX3JlYWN0SW50ZXJuYWxzPWI7T2coYixkLGEsYyk7Yj1xaShudWxsLGIsZCwhMCxmLGMpfWVsc2UgYi50YWc9MCxmaShudWxsLGIsZSxjKSxiPWIuY2hpbGQ7cmV0dXJuIGI7Y2FzZSAxNjplPWIuZWxlbWVudFR5cGU7YTp7bnVsbCE9PWEmJihhLmFsdGVybmF0ZT1udWxsLGIuYWx0ZXJuYXRlPW51bGwsYi5mbGFnc3w9Mik7XG5hPWIucGVuZGluZ1Byb3BzO2Y9ZS5faW5pdDtlPWYoZS5fcGF5bG9hZCk7Yi50eXBlPWU7Zj1iLnRhZz1oayhlKTthPWxnKGUsYSk7c3dpdGNoKGYpe2Nhc2UgMDpiPWxpKG51bGwsYixlLGEsYyk7YnJlYWsgYTtjYXNlIDE6Yj1waShudWxsLGIsZSxhLGMpO2JyZWFrIGE7Y2FzZSAxMTpiPWdpKG51bGwsYixlLGEsYyk7YnJlYWsgYTtjYXNlIDE0OmI9aWkobnVsbCxiLGUsbGcoZS50eXBlLGEpLGQsYyk7YnJlYWsgYX10aHJvdyBFcnJvcih5KDMwNixlLFwiXCIpKTt9cmV0dXJuIGI7Y2FzZSAwOnJldHVybiBkPWIudHlwZSxlPWIucGVuZGluZ1Byb3BzLGU9Yi5lbGVtZW50VHlwZT09PWQ/ZTpsZyhkLGUpLGxpKGEsYixkLGUsYyk7Y2FzZSAxOnJldHVybiBkPWIudHlwZSxlPWIucGVuZGluZ1Byb3BzLGU9Yi5lbGVtZW50VHlwZT09PWQ/ZTpsZyhkLGUpLHBpKGEsYixkLGUsYyk7Y2FzZSAzOnJpKGIpO2Q9Yi51cGRhdGVRdWV1ZTtpZihudWxsPT09YXx8bnVsbD09PWQpdGhyb3cgRXJyb3IoeSgyODIpKTtcbmQ9Yi5wZW5kaW5nUHJvcHM7ZT1iLm1lbW9pemVkU3RhdGU7ZT1udWxsIT09ZT9lLmVsZW1lbnQ6bnVsbDt5ZyhhLGIpO0NnKGIsZCxudWxsLGMpO2Q9Yi5tZW1vaXplZFN0YXRlLmVsZW1lbnQ7aWYoZD09PWUpc2goKSxiPWhpKGEsYixjKTtlbHNle2U9Yi5zdGF0ZU5vZGU7aWYoZj1lLmh5ZHJhdGUpa2g9cmYoYi5zdGF0ZU5vZGUuY29udGFpbmVySW5mby5maXJzdENoaWxkKSxqaD1iLGY9bGg9ITA7aWYoZil7YT1lLm11dGFibGVTb3VyY2VFYWdlckh5ZHJhdGlvbkRhdGE7aWYobnVsbCE9YSlmb3IoZT0wO2U8YS5sZW5ndGg7ZSs9MilmPWFbZV0sZi5fd29ya0luUHJvZ3Jlc3NWZXJzaW9uUHJpbWFyeT1hW2UrMV0sdGgucHVzaChmKTtjPVpnKGIsbnVsbCxkLGMpO2ZvcihiLmNoaWxkPWM7YzspYy5mbGFncz1jLmZsYWdzJi0zfDEwMjQsYz1jLnNpYmxpbmd9ZWxzZSBmaShhLGIsZCxjKSxzaCgpO2I9Yi5jaGlsZH1yZXR1cm4gYjtjYXNlIDU6cmV0dXJuIGdoKGIpLG51bGw9PT1hJiZcbnBoKGIpLGQ9Yi50eXBlLGU9Yi5wZW5kaW5nUHJvcHMsZj1udWxsIT09YT9hLm1lbW9pemVkUHJvcHM6bnVsbCxnPWUuY2hpbGRyZW4sbmYoZCxlKT9nPW51bGw6bnVsbCE9PWYmJm5mKGQsZikmJihiLmZsYWdzfD0xNiksb2koYSxiKSxmaShhLGIsZyxjKSxiLmNoaWxkO2Nhc2UgNjpyZXR1cm4gbnVsbD09PWEmJnBoKGIpLG51bGw7Y2FzZSAxMzpyZXR1cm4gdGkoYSxiLGMpO2Nhc2UgNDpyZXR1cm4gZWgoYixiLnN0YXRlTm9kZS5jb250YWluZXJJbmZvKSxkPWIucGVuZGluZ1Byb3BzLG51bGw9PT1hP2IuY2hpbGQ9WWcoYixudWxsLGQsYyk6ZmkoYSxiLGQsYyksYi5jaGlsZDtjYXNlIDExOnJldHVybiBkPWIudHlwZSxlPWIucGVuZGluZ1Byb3BzLGU9Yi5lbGVtZW50VHlwZT09PWQ/ZTpsZyhkLGUpLGdpKGEsYixkLGUsYyk7Y2FzZSA3OnJldHVybiBmaShhLGIsYi5wZW5kaW5nUHJvcHMsYyksYi5jaGlsZDtjYXNlIDg6cmV0dXJuIGZpKGEsYixiLnBlbmRpbmdQcm9wcy5jaGlsZHJlbixcbmMpLGIuY2hpbGQ7Y2FzZSAxMjpyZXR1cm4gZmkoYSxiLGIucGVuZGluZ1Byb3BzLmNoaWxkcmVuLGMpLGIuY2hpbGQ7Y2FzZSAxMDphOntkPWIudHlwZS5fY29udGV4dDtlPWIucGVuZGluZ1Byb3BzO2c9Yi5tZW1vaXplZFByb3BzO2Y9ZS52YWx1ZTt2YXIgaD1iLnR5cGUuX2NvbnRleHQ7SShtZyxoLl9jdXJyZW50VmFsdWUpO2guX2N1cnJlbnRWYWx1ZT1mO2lmKG51bGwhPT1nKWlmKGg9Zy52YWx1ZSxmPUhlKGgsZik/MDooXCJmdW5jdGlvblwiPT09dHlwZW9mIGQuX2NhbGN1bGF0ZUNoYW5nZWRCaXRzP2QuX2NhbGN1bGF0ZUNoYW5nZWRCaXRzKGgsZik6MTA3Mzc0MTgyMyl8MCwwPT09Zil7aWYoZy5jaGlsZHJlbj09PWUuY2hpbGRyZW4mJiFOLmN1cnJlbnQpe2I9aGkoYSxiLGMpO2JyZWFrIGF9fWVsc2UgZm9yKGg9Yi5jaGlsZCxudWxsIT09aCYmKGgucmV0dXJuPWIpO251bGwhPT1oOyl7dmFyIGs9aC5kZXBlbmRlbmNpZXM7aWYobnVsbCE9PWspe2c9aC5jaGlsZDtmb3IodmFyIGw9XG5rLmZpcnN0Q29udGV4dDtudWxsIT09bDspe2lmKGwuY29udGV4dD09PWQmJjAhPT0obC5vYnNlcnZlZEJpdHMmZikpezE9PT1oLnRhZyYmKGw9emcoLTEsYyYtYyksbC50YWc9MixBZyhoLGwpKTtoLmxhbmVzfD1jO2w9aC5hbHRlcm5hdGU7bnVsbCE9PWwmJihsLmxhbmVzfD1jKTtzZyhoLnJldHVybixjKTtrLmxhbmVzfD1jO2JyZWFrfWw9bC5uZXh0fX1lbHNlIGc9MTA9PT1oLnRhZz9oLnR5cGU9PT1iLnR5cGU/bnVsbDpoLmNoaWxkOmguY2hpbGQ7aWYobnVsbCE9PWcpZy5yZXR1cm49aDtlbHNlIGZvcihnPWg7bnVsbCE9PWc7KXtpZihnPT09Yil7Zz1udWxsO2JyZWFrfWg9Zy5zaWJsaW5nO2lmKG51bGwhPT1oKXtoLnJldHVybj1nLnJldHVybjtnPWg7YnJlYWt9Zz1nLnJldHVybn1oPWd9ZmkoYSxiLGUuY2hpbGRyZW4sYyk7Yj1iLmNoaWxkfXJldHVybiBiO2Nhc2UgOTpyZXR1cm4gZT1iLnR5cGUsZj1iLnBlbmRpbmdQcm9wcyxkPWYuY2hpbGRyZW4sdGcoYixjKSxlPXZnKGUsXG5mLnVuc3RhYmxlX29ic2VydmVkQml0cyksZD1kKGUpLGIuZmxhZ3N8PTEsZmkoYSxiLGQsYyksYi5jaGlsZDtjYXNlIDE0OnJldHVybiBlPWIudHlwZSxmPWxnKGUsYi5wZW5kaW5nUHJvcHMpLGY9bGcoZS50eXBlLGYpLGlpKGEsYixlLGYsZCxjKTtjYXNlIDE1OnJldHVybiBraShhLGIsYi50eXBlLGIucGVuZGluZ1Byb3BzLGQsYyk7Y2FzZSAxNzpyZXR1cm4gZD1iLnR5cGUsZT1iLnBlbmRpbmdQcm9wcyxlPWIuZWxlbWVudFR5cGU9PT1kP2U6bGcoZCxlKSxudWxsIT09YSYmKGEuYWx0ZXJuYXRlPW51bGwsYi5hbHRlcm5hdGU9bnVsbCxiLmZsYWdzfD0yKSxiLnRhZz0xLEZmKGQpPyhhPSEwLEpmKGIpKTphPSExLHRnKGIsYyksTWcoYixkLGUpLE9nKGIsZCxlLGMpLHFpKG51bGwsYixkLCEwLGEsYyk7Y2FzZSAxOTpyZXR1cm4gQWkoYSxiLGMpO2Nhc2UgMjM6cmV0dXJuIG1pKGEsYixjKTtjYXNlIDI0OnJldHVybiBtaShhLGIsYyl9dGhyb3cgRXJyb3IoeSgxNTYsYi50YWcpKTtcbn07ZnVuY3Rpb24gaWsoYSxiLGMsZCl7dGhpcy50YWc9YTt0aGlzLmtleT1jO3RoaXMuc2libGluZz10aGlzLmNoaWxkPXRoaXMucmV0dXJuPXRoaXMuc3RhdGVOb2RlPXRoaXMudHlwZT10aGlzLmVsZW1lbnRUeXBlPW51bGw7dGhpcy5pbmRleD0wO3RoaXMucmVmPW51bGw7dGhpcy5wZW5kaW5nUHJvcHM9Yjt0aGlzLmRlcGVuZGVuY2llcz10aGlzLm1lbW9pemVkU3RhdGU9dGhpcy51cGRhdGVRdWV1ZT10aGlzLm1lbW9pemVkUHJvcHM9bnVsbDt0aGlzLm1vZGU9ZDt0aGlzLmZsYWdzPTA7dGhpcy5sYXN0RWZmZWN0PXRoaXMuZmlyc3RFZmZlY3Q9dGhpcy5uZXh0RWZmZWN0PW51bGw7dGhpcy5jaGlsZExhbmVzPXRoaXMubGFuZXM9MDt0aGlzLmFsdGVybmF0ZT1udWxsfWZ1bmN0aW9uIG5oKGEsYixjLGQpe3JldHVybiBuZXcgaWsoYSxiLGMsZCl9ZnVuY3Rpb24gamkoYSl7YT1hLnByb3RvdHlwZTtyZXR1cm4hKCFhfHwhYS5pc1JlYWN0Q29tcG9uZW50KX1cbmZ1bmN0aW9uIGhrKGEpe2lmKFwiZnVuY3Rpb25cIj09PXR5cGVvZiBhKXJldHVybiBqaShhKT8xOjA7aWYodm9pZCAwIT09YSYmbnVsbCE9PWEpe2E9YS4kJHR5cGVvZjtpZihhPT09QWEpcmV0dXJuIDExO2lmKGE9PT1EYSlyZXR1cm4gMTR9cmV0dXJuIDJ9XG5mdW5jdGlvbiBUZyhhLGIpe3ZhciBjPWEuYWx0ZXJuYXRlO251bGw9PT1jPyhjPW5oKGEudGFnLGIsYS5rZXksYS5tb2RlKSxjLmVsZW1lbnRUeXBlPWEuZWxlbWVudFR5cGUsYy50eXBlPWEudHlwZSxjLnN0YXRlTm9kZT1hLnN0YXRlTm9kZSxjLmFsdGVybmF0ZT1hLGEuYWx0ZXJuYXRlPWMpOihjLnBlbmRpbmdQcm9wcz1iLGMudHlwZT1hLnR5cGUsYy5mbGFncz0wLGMubmV4dEVmZmVjdD1udWxsLGMuZmlyc3RFZmZlY3Q9bnVsbCxjLmxhc3RFZmZlY3Q9bnVsbCk7Yy5jaGlsZExhbmVzPWEuY2hpbGRMYW5lcztjLmxhbmVzPWEubGFuZXM7Yy5jaGlsZD1hLmNoaWxkO2MubWVtb2l6ZWRQcm9wcz1hLm1lbW9pemVkUHJvcHM7Yy5tZW1vaXplZFN0YXRlPWEubWVtb2l6ZWRTdGF0ZTtjLnVwZGF0ZVF1ZXVlPWEudXBkYXRlUXVldWU7Yj1hLmRlcGVuZGVuY2llcztjLmRlcGVuZGVuY2llcz1udWxsPT09Yj9udWxsOntsYW5lczpiLmxhbmVzLGZpcnN0Q29udGV4dDpiLmZpcnN0Q29udGV4dH07XG5jLnNpYmxpbmc9YS5zaWJsaW5nO2MuaW5kZXg9YS5pbmRleDtjLnJlZj1hLnJlZjtyZXR1cm4gY31cbmZ1bmN0aW9uIFZnKGEsYixjLGQsZSxmKXt2YXIgZz0yO2Q9YTtpZihcImZ1bmN0aW9uXCI9PT10eXBlb2YgYSlqaShhKSYmKGc9MSk7ZWxzZSBpZihcInN0cmluZ1wiPT09dHlwZW9mIGEpZz01O2Vsc2UgYTpzd2l0Y2goYSl7Y2FzZSB1YTpyZXR1cm4gWGcoYy5jaGlsZHJlbixlLGYsYik7Y2FzZSBIYTpnPTg7ZXw9MTY7YnJlYWs7Y2FzZSB3YTpnPTg7ZXw9MTticmVhaztjYXNlIHhhOnJldHVybiBhPW5oKDEyLGMsYixlfDgpLGEuZWxlbWVudFR5cGU9eGEsYS50eXBlPXhhLGEubGFuZXM9ZixhO2Nhc2UgQmE6cmV0dXJuIGE9bmgoMTMsYyxiLGUpLGEudHlwZT1CYSxhLmVsZW1lbnRUeXBlPUJhLGEubGFuZXM9ZixhO2Nhc2UgQ2E6cmV0dXJuIGE9bmgoMTksYyxiLGUpLGEuZWxlbWVudFR5cGU9Q2EsYS5sYW5lcz1mLGE7Y2FzZSBJYTpyZXR1cm4gdmkoYyxlLGYsYik7Y2FzZSBKYTpyZXR1cm4gYT1uaCgyNCxjLGIsZSksYS5lbGVtZW50VHlwZT1KYSxhLmxhbmVzPWYsYTtkZWZhdWx0OmlmKFwib2JqZWN0XCI9PT1cbnR5cGVvZiBhJiZudWxsIT09YSlzd2l0Y2goYS4kJHR5cGVvZil7Y2FzZSB5YTpnPTEwO2JyZWFrIGE7Y2FzZSB6YTpnPTk7YnJlYWsgYTtjYXNlIEFhOmc9MTE7YnJlYWsgYTtjYXNlIERhOmc9MTQ7YnJlYWsgYTtjYXNlIEVhOmc9MTY7ZD1udWxsO2JyZWFrIGE7Y2FzZSBGYTpnPTIyO2JyZWFrIGF9dGhyb3cgRXJyb3IoeSgxMzAsbnVsbD09YT9hOnR5cGVvZiBhLFwiXCIpKTt9Yj1uaChnLGMsYixlKTtiLmVsZW1lbnRUeXBlPWE7Yi50eXBlPWQ7Yi5sYW5lcz1mO3JldHVybiBifWZ1bmN0aW9uIFhnKGEsYixjLGQpe2E9bmgoNyxhLGQsYik7YS5sYW5lcz1jO3JldHVybiBhfWZ1bmN0aW9uIHZpKGEsYixjLGQpe2E9bmgoMjMsYSxkLGIpO2EuZWxlbWVudFR5cGU9SWE7YS5sYW5lcz1jO3JldHVybiBhfWZ1bmN0aW9uIFVnKGEsYixjKXthPW5oKDYsYSxudWxsLGIpO2EubGFuZXM9YztyZXR1cm4gYX1cbmZ1bmN0aW9uIFdnKGEsYixjKXtiPW5oKDQsbnVsbCE9PWEuY2hpbGRyZW4/YS5jaGlsZHJlbjpbXSxhLmtleSxiKTtiLmxhbmVzPWM7Yi5zdGF0ZU5vZGU9e2NvbnRhaW5lckluZm86YS5jb250YWluZXJJbmZvLHBlbmRpbmdDaGlsZHJlbjpudWxsLGltcGxlbWVudGF0aW9uOmEuaW1wbGVtZW50YXRpb259O3JldHVybiBifVxuZnVuY3Rpb24gamsoYSxiLGMpe3RoaXMudGFnPWI7dGhpcy5jb250YWluZXJJbmZvPWE7dGhpcy5maW5pc2hlZFdvcms9dGhpcy5waW5nQ2FjaGU9dGhpcy5jdXJyZW50PXRoaXMucGVuZGluZ0NoaWxkcmVuPW51bGw7dGhpcy50aW1lb3V0SGFuZGxlPS0xO3RoaXMucGVuZGluZ0NvbnRleHQ9dGhpcy5jb250ZXh0PW51bGw7dGhpcy5oeWRyYXRlPWM7dGhpcy5jYWxsYmFja05vZGU9bnVsbDt0aGlzLmNhbGxiYWNrUHJpb3JpdHk9MDt0aGlzLmV2ZW50VGltZXM9WmMoMCk7dGhpcy5leHBpcmF0aW9uVGltZXM9WmMoLTEpO3RoaXMuZW50YW5nbGVkTGFuZXM9dGhpcy5maW5pc2hlZExhbmVzPXRoaXMubXV0YWJsZVJlYWRMYW5lcz10aGlzLmV4cGlyZWRMYW5lcz10aGlzLnBpbmdlZExhbmVzPXRoaXMuc3VzcGVuZGVkTGFuZXM9dGhpcy5wZW5kaW5nTGFuZXM9MDt0aGlzLmVudGFuZ2xlbWVudHM9WmMoMCk7dGhpcy5tdXRhYmxlU291cmNlRWFnZXJIeWRyYXRpb25EYXRhPW51bGx9XG5mdW5jdGlvbiBrayhhLGIsYyl7dmFyIGQ9Mzxhcmd1bWVudHMubGVuZ3RoJiZ2b2lkIDAhPT1hcmd1bWVudHNbM10/YXJndW1lbnRzWzNdOm51bGw7cmV0dXJueyQkdHlwZW9mOnRhLGtleTpudWxsPT1kP251bGw6XCJcIitkLGNoaWxkcmVuOmEsY29udGFpbmVySW5mbzpiLGltcGxlbWVudGF0aW9uOmN9fVxuZnVuY3Rpb24gbGsoYSxiLGMsZCl7dmFyIGU9Yi5jdXJyZW50LGY9SGcoKSxnPUlnKGUpO2E6aWYoYyl7Yz1jLl9yZWFjdEludGVybmFscztiOntpZihaYihjKSE9PWN8fDEhPT1jLnRhZyl0aHJvdyBFcnJvcih5KDE3MCkpO3ZhciBoPWM7ZG97c3dpdGNoKGgudGFnKXtjYXNlIDM6aD1oLnN0YXRlTm9kZS5jb250ZXh0O2JyZWFrIGI7Y2FzZSAxOmlmKEZmKGgudHlwZSkpe2g9aC5zdGF0ZU5vZGUuX19yZWFjdEludGVybmFsTWVtb2l6ZWRNZXJnZWRDaGlsZENvbnRleHQ7YnJlYWsgYn19aD1oLnJldHVybn13aGlsZShudWxsIT09aCk7dGhyb3cgRXJyb3IoeSgxNzEpKTt9aWYoMT09PWMudGFnKXt2YXIgaz1jLnR5cGU7aWYoRmYoaykpe2M9SWYoYyxrLGgpO2JyZWFrIGF9fWM9aH1lbHNlIGM9Q2Y7bnVsbD09PWIuY29udGV4dD9iLmNvbnRleHQ9YzpiLnBlbmRpbmdDb250ZXh0PWM7Yj16ZyhmLGcpO2IucGF5bG9hZD17ZWxlbWVudDphfTtkPXZvaWQgMD09PWQ/bnVsbDpkO251bGwhPT1cbmQmJihiLmNhbGxiYWNrPWQpO0FnKGUsYik7SmcoZSxnLGYpO3JldHVybiBnfWZ1bmN0aW9uIG1rKGEpe2E9YS5jdXJyZW50O2lmKCFhLmNoaWxkKXJldHVybiBudWxsO3N3aXRjaChhLmNoaWxkLnRhZyl7Y2FzZSA1OnJldHVybiBhLmNoaWxkLnN0YXRlTm9kZTtkZWZhdWx0OnJldHVybiBhLmNoaWxkLnN0YXRlTm9kZX19ZnVuY3Rpb24gbmsoYSxiKXthPWEubWVtb2l6ZWRTdGF0ZTtpZihudWxsIT09YSYmbnVsbCE9PWEuZGVoeWRyYXRlZCl7dmFyIGM9YS5yZXRyeUxhbmU7YS5yZXRyeUxhbmU9MCE9PWMmJmM8Yj9jOmJ9fWZ1bmN0aW9uIG9rKGEsYil7bmsoYSxiKTsoYT1hLmFsdGVybmF0ZSkmJm5rKGEsYil9ZnVuY3Rpb24gcGsoKXtyZXR1cm4gbnVsbH1cbmZ1bmN0aW9uIHFrKGEsYixjKXt2YXIgZD1udWxsIT1jJiZudWxsIT1jLmh5ZHJhdGlvbk9wdGlvbnMmJmMuaHlkcmF0aW9uT3B0aW9ucy5tdXRhYmxlU291cmNlc3x8bnVsbDtjPW5ldyBqayhhLGIsbnVsbCE9YyYmITA9PT1jLmh5ZHJhdGUpO2I9bmgoMyxudWxsLG51bGwsMj09PWI/NzoxPT09Yj8zOjApO2MuY3VycmVudD1iO2Iuc3RhdGVOb2RlPWM7eGcoYik7YVtmZl09Yy5jdXJyZW50O2NmKDg9PT1hLm5vZGVUeXBlP2EucGFyZW50Tm9kZTphKTtpZihkKWZvcihhPTA7YTxkLmxlbmd0aDthKyspe2I9ZFthXTt2YXIgZT1iLl9nZXRWZXJzaW9uO2U9ZShiLl9zb3VyY2UpO251bGw9PWMubXV0YWJsZVNvdXJjZUVhZ2VySHlkcmF0aW9uRGF0YT9jLm11dGFibGVTb3VyY2VFYWdlckh5ZHJhdGlvbkRhdGE9W2IsZV06Yy5tdXRhYmxlU291cmNlRWFnZXJIeWRyYXRpb25EYXRhLnB1c2goYixlKX10aGlzLl9pbnRlcm5hbFJvb3Q9Y31cbnFrLnByb3RvdHlwZS5yZW5kZXI9ZnVuY3Rpb24oYSl7bGsoYSx0aGlzLl9pbnRlcm5hbFJvb3QsbnVsbCxudWxsKX07cWsucHJvdG90eXBlLnVubW91bnQ9ZnVuY3Rpb24oKXt2YXIgYT10aGlzLl9pbnRlcm5hbFJvb3QsYj1hLmNvbnRhaW5lckluZm87bGsobnVsbCxhLG51bGwsZnVuY3Rpb24oKXtiW2ZmXT1udWxsfSl9O2Z1bmN0aW9uIHJrKGEpe3JldHVybiEoIWF8fDEhPT1hLm5vZGVUeXBlJiY5IT09YS5ub2RlVHlwZSYmMTEhPT1hLm5vZGVUeXBlJiYoOCE9PWEubm9kZVR5cGV8fFwiIHJlYWN0LW1vdW50LXBvaW50LXVuc3RhYmxlIFwiIT09YS5ub2RlVmFsdWUpKX1cbmZ1bmN0aW9uIHNrKGEsYil7Ynx8KGI9YT85PT09YS5ub2RlVHlwZT9hLmRvY3VtZW50RWxlbWVudDphLmZpcnN0Q2hpbGQ6bnVsbCxiPSEoIWJ8fDEhPT1iLm5vZGVUeXBlfHwhYi5oYXNBdHRyaWJ1dGUoXCJkYXRhLXJlYWN0cm9vdFwiKSkpO2lmKCFiKWZvcih2YXIgYztjPWEubGFzdENoaWxkOylhLnJlbW92ZUNoaWxkKGMpO3JldHVybiBuZXcgcWsoYSwwLGI/e2h5ZHJhdGU6ITB9OnZvaWQgMCl9XG5mdW5jdGlvbiB0ayhhLGIsYyxkLGUpe3ZhciBmPWMuX3JlYWN0Um9vdENvbnRhaW5lcjtpZihmKXt2YXIgZz1mLl9pbnRlcm5hbFJvb3Q7aWYoXCJmdW5jdGlvblwiPT09dHlwZW9mIGUpe3ZhciBoPWU7ZT1mdW5jdGlvbigpe3ZhciBhPW1rKGcpO2guY2FsbChhKX19bGsoYixnLGEsZSl9ZWxzZXtmPWMuX3JlYWN0Um9vdENvbnRhaW5lcj1zayhjLGQpO2c9Zi5faW50ZXJuYWxSb290O2lmKFwiZnVuY3Rpb25cIj09PXR5cGVvZiBlKXt2YXIgaz1lO2U9ZnVuY3Rpb24oKXt2YXIgYT1tayhnKTtrLmNhbGwoYSl9fVhqKGZ1bmN0aW9uKCl7bGsoYixnLGEsZSl9KX1yZXR1cm4gbWsoZyl9ZWM9ZnVuY3Rpb24oYSl7aWYoMTM9PT1hLnRhZyl7dmFyIGI9SGcoKTtKZyhhLDQsYik7b2soYSw0KX19O2ZjPWZ1bmN0aW9uKGEpe2lmKDEzPT09YS50YWcpe3ZhciBiPUhnKCk7SmcoYSw2NzEwODg2NCxiKTtvayhhLDY3MTA4ODY0KX19O1xuZ2M9ZnVuY3Rpb24oYSl7aWYoMTM9PT1hLnRhZyl7dmFyIGI9SGcoKSxjPUlnKGEpO0pnKGEsYyxiKTtvayhhLGMpfX07aGM9ZnVuY3Rpb24oYSxiKXtyZXR1cm4gYigpfTtcbnliPWZ1bmN0aW9uKGEsYixjKXtzd2l0Y2goYil7Y2FzZSBcImlucHV0XCI6YWIoYSxjKTtiPWMubmFtZTtpZihcInJhZGlvXCI9PT1jLnR5cGUmJm51bGwhPWIpe2ZvcihjPWE7Yy5wYXJlbnROb2RlOyljPWMucGFyZW50Tm9kZTtjPWMucXVlcnlTZWxlY3RvckFsbChcImlucHV0W25hbWU9XCIrSlNPTi5zdHJpbmdpZnkoXCJcIitiKSsnXVt0eXBlPVwicmFkaW9cIl0nKTtmb3IoYj0wO2I8Yy5sZW5ndGg7YisrKXt2YXIgZD1jW2JdO2lmKGQhPT1hJiZkLmZvcm09PT1hLmZvcm0pe3ZhciBlPURiKGQpO2lmKCFlKXRocm93IEVycm9yKHkoOTApKTtXYShkKTthYihkLGUpfX19YnJlYWs7Y2FzZSBcInRleHRhcmVhXCI6aWIoYSxjKTticmVhaztjYXNlIFwic2VsZWN0XCI6Yj1jLnZhbHVlLG51bGwhPWImJmZiKGEsISFjLm11bHRpcGxlLGIsITEpfX07R2I9V2o7XG5IYj1mdW5jdGlvbihhLGIsYyxkLGUpe3ZhciBmPVg7WHw9NDt0cnl7cmV0dXJuIGdnKDk4LGEuYmluZChudWxsLGIsYyxkLGUpKX1maW5hbGx5e1g9ZiwwPT09WCYmKHdqKCksaWcoKSl9fTtJYj1mdW5jdGlvbigpezA9PT0oWCY0OSkmJihWaigpLE9qKCkpfTtKYj1mdW5jdGlvbihhLGIpe3ZhciBjPVg7WHw9Mjt0cnl7cmV0dXJuIGEoYil9ZmluYWxseXtYPWMsMD09PVgmJih3aigpLGlnKCkpfX07ZnVuY3Rpb24gdWsoYSxiKXt2YXIgYz0yPGFyZ3VtZW50cy5sZW5ndGgmJnZvaWQgMCE9PWFyZ3VtZW50c1syXT9hcmd1bWVudHNbMl06bnVsbDtpZighcmsoYikpdGhyb3cgRXJyb3IoeSgyMDApKTtyZXR1cm4ga2soYSxiLG51bGwsYyl9dmFyIHZrPXtFdmVudHM6W0NiLHVlLERiLEViLEZiLE9qLHtjdXJyZW50OiExfV19LHdrPXtmaW5kRmliZXJCeUhvc3RJbnN0YW5jZTp3YyxidW5kbGVUeXBlOjAsdmVyc2lvbjpcIjE3LjAuMlwiLHJlbmRlcmVyUGFja2FnZU5hbWU6XCJyZWFjdC1kb21cIn07XG52YXIgeGs9e2J1bmRsZVR5cGU6d2suYnVuZGxlVHlwZSx2ZXJzaW9uOndrLnZlcnNpb24scmVuZGVyZXJQYWNrYWdlTmFtZTp3ay5yZW5kZXJlclBhY2thZ2VOYW1lLHJlbmRlcmVyQ29uZmlnOndrLnJlbmRlcmVyQ29uZmlnLG92ZXJyaWRlSG9va1N0YXRlOm51bGwsb3ZlcnJpZGVIb29rU3RhdGVEZWxldGVQYXRoOm51bGwsb3ZlcnJpZGVIb29rU3RhdGVSZW5hbWVQYXRoOm51bGwsb3ZlcnJpZGVQcm9wczpudWxsLG92ZXJyaWRlUHJvcHNEZWxldGVQYXRoOm51bGwsb3ZlcnJpZGVQcm9wc1JlbmFtZVBhdGg6bnVsbCxzZXRTdXNwZW5zZUhhbmRsZXI6bnVsbCxzY2hlZHVsZVVwZGF0ZTpudWxsLGN1cnJlbnREaXNwYXRjaGVyUmVmOnJhLlJlYWN0Q3VycmVudERpc3BhdGNoZXIsZmluZEhvc3RJbnN0YW5jZUJ5RmliZXI6ZnVuY3Rpb24oYSl7YT1jYyhhKTtyZXR1cm4gbnVsbD09PWE/bnVsbDphLnN0YXRlTm9kZX0sZmluZEZpYmVyQnlIb3N0SW5zdGFuY2U6d2suZmluZEZpYmVyQnlIb3N0SW5zdGFuY2V8fFxucGssZmluZEhvc3RJbnN0YW5jZXNGb3JSZWZyZXNoOm51bGwsc2NoZWR1bGVSZWZyZXNoOm51bGwsc2NoZWR1bGVSb290Om51bGwsc2V0UmVmcmVzaEhhbmRsZXI6bnVsbCxnZXRDdXJyZW50RmliZXI6bnVsbH07aWYoXCJ1bmRlZmluZWRcIiE9PXR5cGVvZiBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18pe3ZhciB5az1fX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX187aWYoIXlrLmlzRGlzYWJsZWQmJnlrLnN1cHBvcnRzRmliZXIpdHJ5e0xmPXlrLmluamVjdCh4ayksTWY9eWt9Y2F0Y2goYSl7fX1leHBvcnRzLl9fU0VDUkVUX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0ZJUkVEPXZrO2V4cG9ydHMuY3JlYXRlUG9ydGFsPXVrO1xuZXhwb3J0cy5maW5kRE9NTm9kZT1mdW5jdGlvbihhKXtpZihudWxsPT1hKXJldHVybiBudWxsO2lmKDE9PT1hLm5vZGVUeXBlKXJldHVybiBhO3ZhciBiPWEuX3JlYWN0SW50ZXJuYWxzO2lmKHZvaWQgMD09PWIpe2lmKFwiZnVuY3Rpb25cIj09PXR5cGVvZiBhLnJlbmRlcil0aHJvdyBFcnJvcih5KDE4OCkpO3Rocm93IEVycm9yKHkoMjY4LE9iamVjdC5rZXlzKGEpKSk7fWE9Y2MoYik7YT1udWxsPT09YT9udWxsOmEuc3RhdGVOb2RlO3JldHVybiBhfTtleHBvcnRzLmZsdXNoU3luYz1mdW5jdGlvbihhLGIpe3ZhciBjPVg7aWYoMCE9PShjJjQ4KSlyZXR1cm4gYShiKTtYfD0xO3RyeXtpZihhKXJldHVybiBnZyg5OSxhLmJpbmQobnVsbCxiKSl9ZmluYWxseXtYPWMsaWcoKX19O2V4cG9ydHMuaHlkcmF0ZT1mdW5jdGlvbihhLGIsYyl7aWYoIXJrKGIpKXRocm93IEVycm9yKHkoMjAwKSk7cmV0dXJuIHRrKG51bGwsYSxiLCEwLGMpfTtcbmV4cG9ydHMucmVuZGVyPWZ1bmN0aW9uKGEsYixjKXtpZighcmsoYikpdGhyb3cgRXJyb3IoeSgyMDApKTtyZXR1cm4gdGsobnVsbCxhLGIsITEsYyl9O2V4cG9ydHMudW5tb3VudENvbXBvbmVudEF0Tm9kZT1mdW5jdGlvbihhKXtpZighcmsoYSkpdGhyb3cgRXJyb3IoeSg0MCkpO3JldHVybiBhLl9yZWFjdFJvb3RDb250YWluZXI/KFhqKGZ1bmN0aW9uKCl7dGsobnVsbCxudWxsLGEsITEsZnVuY3Rpb24oKXthLl9yZWFjdFJvb3RDb250YWluZXI9bnVsbDthW2ZmXT1udWxsfSl9KSwhMCk6ITF9O2V4cG9ydHMudW5zdGFibGVfYmF0Y2hlZFVwZGF0ZXM9V2o7ZXhwb3J0cy51bnN0YWJsZV9jcmVhdGVQb3J0YWw9ZnVuY3Rpb24oYSxiKXtyZXR1cm4gdWsoYSxiLDI8YXJndW1lbnRzLmxlbmd0aCYmdm9pZCAwIT09YXJndW1lbnRzWzJdP2FyZ3VtZW50c1syXTpudWxsKX07XG5leHBvcnRzLnVuc3RhYmxlX3JlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyPWZ1bmN0aW9uKGEsYixjLGQpe2lmKCFyayhjKSl0aHJvdyBFcnJvcih5KDIwMCkpO2lmKG51bGw9PWF8fHZvaWQgMD09PWEuX3JlYWN0SW50ZXJuYWxzKXRocm93IEVycm9yKHkoMzgpKTtyZXR1cm4gdGsoYSxiLGMsITEsZCl9O2V4cG9ydHMudmVyc2lvbj1cIjE3LjAuMlwiO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///448\n')},935:(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("\n\nfunction checkDCE() {\n  /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */\n  if (\n    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === 'undefined' ||\n    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== 'function'\n  ) {\n    return;\n  }\n  if (false) {}\n  try {\n    // Verify that the code above has been dead code eliminated (DCE'd).\n    __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);\n  } catch (err) {\n    // DevTools shouldn't crash React, no matter what.\n    // We should still report in case we break this code.\n    console.error(err);\n  }\n}\n\nif (true) {\n  // DCE check should happen before ReactDOM bundle executes so that\n  // DevTools can report bad minification during injection.\n  checkDCE();\n  module.exports = __webpack_require__(448);\n} else {}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTM1LmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLEtBQXFDLEVBQUUsRUFTMUM7QUFDSDtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxJQUFJLElBQXFDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBLEVBQUUseUNBQTZEO0FBQy9ELEVBQUUsS0FBSyxFQUVOIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbWRjLXJlYWN0Ly4vbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9pbmRleC5qcz84YmM4Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gY2hlY2tEQ0UoKSB7XG4gIC8qIGdsb2JhbCBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18gKi9cbiAgaWYgKFxuICAgIHR5cGVvZiBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18gPT09ICd1bmRlZmluZWQnIHx8XG4gICAgdHlwZW9mIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXy5jaGVja0RDRSAhPT0gJ2Z1bmN0aW9uJ1xuICApIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAvLyBUaGlzIGJyYW5jaCBpcyB1bnJlYWNoYWJsZSBiZWNhdXNlIHRoaXMgZnVuY3Rpb24gaXMgb25seSBjYWxsZWRcbiAgICAvLyBpbiBwcm9kdWN0aW9uLCBidXQgdGhlIGNvbmRpdGlvbiBpcyB0cnVlIG9ubHkgaW4gZGV2ZWxvcG1lbnQuXG4gICAgLy8gVGhlcmVmb3JlIGlmIHRoZSBicmFuY2ggaXMgc3RpbGwgaGVyZSwgZGVhZCBjb2RlIGVsaW1pbmF0aW9uIHdhc24ndFxuICAgIC8vIHByb3Blcmx5IGFwcGxpZWQuXG4gICAgLy8gRG9uJ3QgY2hhbmdlIHRoZSBtZXNzYWdlLiBSZWFjdCBEZXZUb29scyByZWxpZXMgb24gaXQuIEFsc28gbWFrZSBzdXJlXG4gICAgLy8gdGhpcyBtZXNzYWdlIGRvZXNuJ3Qgb2NjdXIgZWxzZXdoZXJlIGluIHRoaXMgZnVuY3Rpb24sIG9yIGl0IHdpbGwgY2F1c2VcbiAgICAvLyBhIGZhbHNlIHBvc2l0aXZlLlxuICAgIHRocm93IG5ldyBFcnJvcignXl9eJyk7XG4gIH1cbiAgdHJ5IHtcbiAgICAvLyBWZXJpZnkgdGhhdCB0aGUgY29kZSBhYm92ZSBoYXMgYmVlbiBkZWFkIGNvZGUgZWxpbWluYXRlZCAoRENFJ2QpLlxuICAgIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXy5jaGVja0RDRShjaGVja0RDRSk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIC8vIERldlRvb2xzIHNob3VsZG4ndCBjcmFzaCBSZWFjdCwgbm8gbWF0dGVyIHdoYXQuXG4gICAgLy8gV2Ugc2hvdWxkIHN0aWxsIHJlcG9ydCBpbiBjYXNlIHdlIGJyZWFrIHRoaXMgY29kZS5cbiAgICBjb25zb2xlLmVycm9yKGVycik7XG4gIH1cbn1cblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcbiAgLy8gRENFIGNoZWNrIHNob3VsZCBoYXBwZW4gYmVmb3JlIFJlYWN0RE9NIGJ1bmRsZSBleGVjdXRlcyBzbyB0aGF0XG4gIC8vIERldlRvb2xzIGNhbiByZXBvcnQgYmFkIG1pbmlmaWNhdGlvbiBkdXJpbmcgaW5qZWN0aW9uLlxuICBjaGVja0RDRSgpO1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3JlYWN0LWRvbS5wcm9kdWN0aW9uLm1pbi5qcycpO1xufSBlbHNlIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9yZWFjdC1kb20uZGV2ZWxvcG1lbnQuanMnKTtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///935\n")},921:(__unused_webpack_module,exports)=>{"use strict";eval('/** @license React v16.13.1\n * react-is.production.min.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nvar b="function"===typeof Symbol&&Symbol.for,c=b?Symbol.for("react.element"):60103,d=b?Symbol.for("react.portal"):60106,e=b?Symbol.for("react.fragment"):60107,f=b?Symbol.for("react.strict_mode"):60108,g=b?Symbol.for("react.profiler"):60114,h=b?Symbol.for("react.provider"):60109,k=b?Symbol.for("react.context"):60110,l=b?Symbol.for("react.async_mode"):60111,m=b?Symbol.for("react.concurrent_mode"):60111,n=b?Symbol.for("react.forward_ref"):60112,p=b?Symbol.for("react.suspense"):60113,q=b?\nSymbol.for("react.suspense_list"):60120,r=b?Symbol.for("react.memo"):60115,t=b?Symbol.for("react.lazy"):60116,v=b?Symbol.for("react.block"):60121,w=b?Symbol.for("react.fundamental"):60117,x=b?Symbol.for("react.responder"):60118,y=b?Symbol.for("react.scope"):60119;\nfunction z(a){if("object"===typeof a&&null!==a){var u=a.$$typeof;switch(u){case c:switch(a=a.type,a){case l:case m:case e:case g:case f:case p:return a;default:switch(a=a&&a.$$typeof,a){case k:case n:case t:case r:case h:return a;default:return u}}case d:return u}}}function A(a){return z(a)===m}exports.AsyncMode=l;exports.ConcurrentMode=m;exports.ContextConsumer=k;exports.ContextProvider=h;exports.Element=c;exports.ForwardRef=n;exports.Fragment=e;exports.Lazy=t;exports.Memo=r;exports.Portal=d;\nexports.Profiler=g;exports.StrictMode=f;exports.Suspense=p;exports.isAsyncMode=function(a){return A(a)||z(a)===l};exports.isConcurrentMode=A;exports.isContextConsumer=function(a){return z(a)===k};exports.isContextProvider=function(a){return z(a)===h};exports.isElement=function(a){return"object"===typeof a&&null!==a&&a.$$typeof===c};exports.isForwardRef=function(a){return z(a)===n};exports.isFragment=function(a){return z(a)===e};exports.isLazy=function(a){return z(a)===t};\nexports.isMemo=function(a){return z(a)===r};exports.isPortal=function(a){return z(a)===d};exports.isProfiler=function(a){return z(a)===g};exports.isStrictMode=function(a){return z(a)===f};exports.isSuspense=function(a){return z(a)===p};\nexports.isValidElementType=function(a){return"string"===typeof a||"function"===typeof a||a===e||a===m||a===g||a===f||a===p||a===q||"object"===typeof a&&null!==a&&(a.$$typeof===t||a.$$typeof===r||a.$$typeof===h||a.$$typeof===k||a.$$typeof===n||a.$$typeof===w||a.$$typeof===x||a.$$typeof===y||a.$$typeof===v)};exports.typeOf=z;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTIxLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWE7QUFDYjtBQUNBLGNBQWMsa0NBQWtDLGlCQUFpQixVQUFVLDBCQUEwQixtREFBbUQsa0NBQWtDLDRDQUE0QyxrQkFBa0Isa0JBQWtCLGNBQWMsZ0JBQWdCLGlCQUFpQixHQUFHLHNCQUFzQixHQUFHLHVCQUF1QixHQUFHLHVCQUF1QixHQUFHLGVBQWUsR0FBRyxrQkFBa0IsR0FBRyxnQkFBZ0IsR0FBRyxZQUFZLEdBQUcsWUFBWSxHQUFHLGNBQWM7QUFDL2UsZ0JBQWdCLEdBQUcsa0JBQWtCLEdBQUcsZ0JBQWdCLEdBQUcsbUJBQW1CLGFBQWEsdUJBQXVCLHdCQUF3QixHQUFHLHlCQUF5QixhQUFhLGlCQUFpQix5QkFBeUIsYUFBYSxpQkFBaUIsaUJBQWlCLGFBQWEscURBQXFELG9CQUFvQixhQUFhLGlCQUFpQixrQkFBa0IsYUFBYSxpQkFBaUIsY0FBYyxhQUFhO0FBQzNjLGNBQWMsYUFBYSxpQkFBaUIsZ0JBQWdCLGFBQWEsaUJBQWlCLGtCQUFrQixhQUFhLGlCQUFpQixvQkFBb0IsYUFBYSxpQkFBaUIsa0JBQWtCLGFBQWE7QUFDM04sMEJBQTBCLGFBQWEsNlFBQTZRLGNBQWMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9ub2RlX21vZHVsZXMvcmVhY3QtaXMvY2pzL3JlYWN0LWlzLnByb2R1Y3Rpb24ubWluLmpzP2E5M2QiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqIEBsaWNlbnNlIFJlYWN0IHYxNi4xMy4xXG4gKiByZWFjdC1pcy5wcm9kdWN0aW9uLm1pbi5qc1xuICpcbiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbid1c2Ugc3RyaWN0Jzt2YXIgYj1cImZ1bmN0aW9uXCI9PT10eXBlb2YgU3ltYm9sJiZTeW1ib2wuZm9yLGM9Yj9TeW1ib2wuZm9yKFwicmVhY3QuZWxlbWVudFwiKTo2MDEwMyxkPWI/U3ltYm9sLmZvcihcInJlYWN0LnBvcnRhbFwiKTo2MDEwNixlPWI/U3ltYm9sLmZvcihcInJlYWN0LmZyYWdtZW50XCIpOjYwMTA3LGY9Yj9TeW1ib2wuZm9yKFwicmVhY3Quc3RyaWN0X21vZGVcIik6NjAxMDgsZz1iP1N5bWJvbC5mb3IoXCJyZWFjdC5wcm9maWxlclwiKTo2MDExNCxoPWI/U3ltYm9sLmZvcihcInJlYWN0LnByb3ZpZGVyXCIpOjYwMTA5LGs9Yj9TeW1ib2wuZm9yKFwicmVhY3QuY29udGV4dFwiKTo2MDExMCxsPWI/U3ltYm9sLmZvcihcInJlYWN0LmFzeW5jX21vZGVcIik6NjAxMTEsbT1iP1N5bWJvbC5mb3IoXCJyZWFjdC5jb25jdXJyZW50X21vZGVcIik6NjAxMTEsbj1iP1N5bWJvbC5mb3IoXCJyZWFjdC5mb3J3YXJkX3JlZlwiKTo2MDExMixwPWI/U3ltYm9sLmZvcihcInJlYWN0LnN1c3BlbnNlXCIpOjYwMTEzLHE9Yj9cblN5bWJvbC5mb3IoXCJyZWFjdC5zdXNwZW5zZV9saXN0XCIpOjYwMTIwLHI9Yj9TeW1ib2wuZm9yKFwicmVhY3QubWVtb1wiKTo2MDExNSx0PWI/U3ltYm9sLmZvcihcInJlYWN0LmxhenlcIik6NjAxMTYsdj1iP1N5bWJvbC5mb3IoXCJyZWFjdC5ibG9ja1wiKTo2MDEyMSx3PWI/U3ltYm9sLmZvcihcInJlYWN0LmZ1bmRhbWVudGFsXCIpOjYwMTE3LHg9Yj9TeW1ib2wuZm9yKFwicmVhY3QucmVzcG9uZGVyXCIpOjYwMTE4LHk9Yj9TeW1ib2wuZm9yKFwicmVhY3Quc2NvcGVcIik6NjAxMTk7XG5mdW5jdGlvbiB6KGEpe2lmKFwib2JqZWN0XCI9PT10eXBlb2YgYSYmbnVsbCE9PWEpe3ZhciB1PWEuJCR0eXBlb2Y7c3dpdGNoKHUpe2Nhc2UgYzpzd2l0Y2goYT1hLnR5cGUsYSl7Y2FzZSBsOmNhc2UgbTpjYXNlIGU6Y2FzZSBnOmNhc2UgZjpjYXNlIHA6cmV0dXJuIGE7ZGVmYXVsdDpzd2l0Y2goYT1hJiZhLiQkdHlwZW9mLGEpe2Nhc2UgazpjYXNlIG46Y2FzZSB0OmNhc2UgcjpjYXNlIGg6cmV0dXJuIGE7ZGVmYXVsdDpyZXR1cm4gdX19Y2FzZSBkOnJldHVybiB1fX19ZnVuY3Rpb24gQShhKXtyZXR1cm4geihhKT09PW19ZXhwb3J0cy5Bc3luY01vZGU9bDtleHBvcnRzLkNvbmN1cnJlbnRNb2RlPW07ZXhwb3J0cy5Db250ZXh0Q29uc3VtZXI9aztleHBvcnRzLkNvbnRleHRQcm92aWRlcj1oO2V4cG9ydHMuRWxlbWVudD1jO2V4cG9ydHMuRm9yd2FyZFJlZj1uO2V4cG9ydHMuRnJhZ21lbnQ9ZTtleHBvcnRzLkxhenk9dDtleHBvcnRzLk1lbW89cjtleHBvcnRzLlBvcnRhbD1kO1xuZXhwb3J0cy5Qcm9maWxlcj1nO2V4cG9ydHMuU3RyaWN0TW9kZT1mO2V4cG9ydHMuU3VzcGVuc2U9cDtleHBvcnRzLmlzQXN5bmNNb2RlPWZ1bmN0aW9uKGEpe3JldHVybiBBKGEpfHx6KGEpPT09bH07ZXhwb3J0cy5pc0NvbmN1cnJlbnRNb2RlPUE7ZXhwb3J0cy5pc0NvbnRleHRDb25zdW1lcj1mdW5jdGlvbihhKXtyZXR1cm4geihhKT09PWt9O2V4cG9ydHMuaXNDb250ZXh0UHJvdmlkZXI9ZnVuY3Rpb24oYSl7cmV0dXJuIHooYSk9PT1ofTtleHBvcnRzLmlzRWxlbWVudD1mdW5jdGlvbihhKXtyZXR1cm5cIm9iamVjdFwiPT09dHlwZW9mIGEmJm51bGwhPT1hJiZhLiQkdHlwZW9mPT09Y307ZXhwb3J0cy5pc0ZvcndhcmRSZWY9ZnVuY3Rpb24oYSl7cmV0dXJuIHooYSk9PT1ufTtleHBvcnRzLmlzRnJhZ21lbnQ9ZnVuY3Rpb24oYSl7cmV0dXJuIHooYSk9PT1lfTtleHBvcnRzLmlzTGF6eT1mdW5jdGlvbihhKXtyZXR1cm4geihhKT09PXR9O1xuZXhwb3J0cy5pc01lbW89ZnVuY3Rpb24oYSl7cmV0dXJuIHooYSk9PT1yfTtleHBvcnRzLmlzUG9ydGFsPWZ1bmN0aW9uKGEpe3JldHVybiB6KGEpPT09ZH07ZXhwb3J0cy5pc1Byb2ZpbGVyPWZ1bmN0aW9uKGEpe3JldHVybiB6KGEpPT09Z307ZXhwb3J0cy5pc1N0cmljdE1vZGU9ZnVuY3Rpb24oYSl7cmV0dXJuIHooYSk9PT1mfTtleHBvcnRzLmlzU3VzcGVuc2U9ZnVuY3Rpb24oYSl7cmV0dXJuIHooYSk9PT1wfTtcbmV4cG9ydHMuaXNWYWxpZEVsZW1lbnRUeXBlPWZ1bmN0aW9uKGEpe3JldHVyblwic3RyaW5nXCI9PT10eXBlb2YgYXx8XCJmdW5jdGlvblwiPT09dHlwZW9mIGF8fGE9PT1lfHxhPT09bXx8YT09PWd8fGE9PT1mfHxhPT09cHx8YT09PXF8fFwib2JqZWN0XCI9PT10eXBlb2YgYSYmbnVsbCE9PWEmJihhLiQkdHlwZW9mPT09dHx8YS4kJHR5cGVvZj09PXJ8fGEuJCR0eXBlb2Y9PT1ofHxhLiQkdHlwZW9mPT09a3x8YS4kJHR5cGVvZj09PW58fGEuJCR0eXBlb2Y9PT13fHxhLiQkdHlwZW9mPT09eHx8YS4kJHR5cGVvZj09PXl8fGEuJCR0eXBlb2Y9PT12KX07ZXhwb3J0cy50eXBlT2Y9ejtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///921\n')},864:(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("\n\nif (true) {\n  module.exports = __webpack_require__(921);\n} else {}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODY0LmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLElBQUksSUFBcUM7QUFDekMsRUFBRSx5Q0FBNEQ7QUFDOUQsRUFBRSxLQUFLLEVBRU4iLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9ub2RlX21vZHVsZXMvcmVhY3QtaXMvaW5kZXguanM/NGNlYyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtaXMucHJvZHVjdGlvbi5taW4uanMnKTtcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtaXMuZGV2ZWxvcG1lbnQuanMnKTtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///864\n")},251:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('/** @license React v17.0.2\n * react-jsx-runtime.production.min.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n__webpack_require__(418);var f=__webpack_require__(294),g=60103;exports.Fragment=60107;if("function"===typeof Symbol&&Symbol.for){var h=Symbol.for;g=h("react.element");exports.Fragment=h("react.fragment")}var m=f.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner,n=Object.prototype.hasOwnProperty,p={key:!0,ref:!0,__self:!0,__source:!0};\nfunction q(c,a,k){var b,d={},e=null,l=null;void 0!==k&&(e=""+k);void 0!==a.key&&(e=""+a.key);void 0!==a.ref&&(l=a.ref);for(b in a)n.call(a,b)&&!p.hasOwnProperty(b)&&(d[b]=a[b]);if(c&&c.defaultProps)for(b in a=c.defaultProps,a)void 0===d[b]&&(d[b]=a[b]);return{$$typeof:g,type:c,key:e,ref:l,props:d,_owner:m.current}}exports.jsx=q;exports.jsxs=q;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjUxLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDYSxtQkFBTyxDQUFDLEdBQWUsRUFBRSxNQUFNLG1CQUFPLENBQUMsR0FBTyxVQUFVLGdCQUFnQixPQUFPLDJDQUEyQyxpQkFBaUIscUJBQXFCLGdCQUFnQixxQkFBcUIsa0hBQWtIO0FBQ3BVLGtCQUFrQixVQUFVLGVBQWUscUJBQXFCLDZCQUE2QiwwQkFBMEIsMERBQTBELDRFQUE0RSxPQUFPLHdEQUF3RCxXQUFXLEdBQUcsWUFBWSIsInNvdXJjZXMiOlsid2VicGFjazovL21kYy1yZWFjdC8uL25vZGVfbW9kdWxlcy9yZWFjdC9janMvcmVhY3QtanN4LXJ1bnRpbWUucHJvZHVjdGlvbi5taW4uanM/ZDMxZCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiogQGxpY2Vuc2UgUmVhY3QgdjE3LjAuMlxuICogcmVhY3QtanN4LXJ1bnRpbWUucHJvZHVjdGlvbi5taW4uanNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuJ3VzZSBzdHJpY3QnO3JlcXVpcmUoXCJvYmplY3QtYXNzaWduXCIpO3ZhciBmPXJlcXVpcmUoXCJyZWFjdFwiKSxnPTYwMTAzO2V4cG9ydHMuRnJhZ21lbnQ9NjAxMDc7aWYoXCJmdW5jdGlvblwiPT09dHlwZW9mIFN5bWJvbCYmU3ltYm9sLmZvcil7dmFyIGg9U3ltYm9sLmZvcjtnPWgoXCJyZWFjdC5lbGVtZW50XCIpO2V4cG9ydHMuRnJhZ21lbnQ9aChcInJlYWN0LmZyYWdtZW50XCIpfXZhciBtPWYuX19TRUNSRVRfSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfWU9VX1dJTExfQkVfRklSRUQuUmVhY3RDdXJyZW50T3duZXIsbj1PYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LHA9e2tleTohMCxyZWY6ITAsX19zZWxmOiEwLF9fc291cmNlOiEwfTtcbmZ1bmN0aW9uIHEoYyxhLGspe3ZhciBiLGQ9e30sZT1udWxsLGw9bnVsbDt2b2lkIDAhPT1rJiYoZT1cIlwiK2spO3ZvaWQgMCE9PWEua2V5JiYoZT1cIlwiK2Eua2V5KTt2b2lkIDAhPT1hLnJlZiYmKGw9YS5yZWYpO2ZvcihiIGluIGEpbi5jYWxsKGEsYikmJiFwLmhhc093blByb3BlcnR5KGIpJiYoZFtiXT1hW2JdKTtpZihjJiZjLmRlZmF1bHRQcm9wcylmb3IoYiBpbiBhPWMuZGVmYXVsdFByb3BzLGEpdm9pZCAwPT09ZFtiXSYmKGRbYl09YVtiXSk7cmV0dXJueyQkdHlwZW9mOmcsdHlwZTpjLGtleTplLHJlZjpsLHByb3BzOmQsX293bmVyOm0uY3VycmVudH19ZXhwb3J0cy5qc3g9cTtleHBvcnRzLmpzeHM9cTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///251\n')},408:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('/** @license React v17.0.2\n * react.production.min.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nvar l=__webpack_require__(418),n=60103,p=60106;exports.Fragment=60107;exports.StrictMode=60108;exports.Profiler=60114;var q=60109,r=60110,t=60112;exports.Suspense=60113;var u=60115,v=60116;\nif("function"===typeof Symbol&&Symbol.for){var w=Symbol.for;n=w("react.element");p=w("react.portal");exports.Fragment=w("react.fragment");exports.StrictMode=w("react.strict_mode");exports.Profiler=w("react.profiler");q=w("react.provider");r=w("react.context");t=w("react.forward_ref");exports.Suspense=w("react.suspense");u=w("react.memo");v=w("react.lazy")}var x="function"===typeof Symbol&&Symbol.iterator;\nfunction y(a){if(null===a||"object"!==typeof a)return null;a=x&&a[x]||a["@@iterator"];return"function"===typeof a?a:null}function z(a){for(var b="https://reactjs.org/docs/error-decoder.html?invariant="+a,c=1;c<arguments.length;c++)b+="&args[]="+encodeURIComponent(arguments[c]);return"Minified React error #"+a+"; visit "+b+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}\nvar A={isMounted:function(){return!1},enqueueForceUpdate:function(){},enqueueReplaceState:function(){},enqueueSetState:function(){}},B={};function C(a,b,c){this.props=a;this.context=b;this.refs=B;this.updater=c||A}C.prototype.isReactComponent={};C.prototype.setState=function(a,b){if("object"!==typeof a&&"function"!==typeof a&&null!=a)throw Error(z(85));this.updater.enqueueSetState(this,a,b,"setState")};C.prototype.forceUpdate=function(a){this.updater.enqueueForceUpdate(this,a,"forceUpdate")};\nfunction D(){}D.prototype=C.prototype;function E(a,b,c){this.props=a;this.context=b;this.refs=B;this.updater=c||A}var F=E.prototype=new D;F.constructor=E;l(F,C.prototype);F.isPureReactComponent=!0;var G={current:null},H=Object.prototype.hasOwnProperty,I={key:!0,ref:!0,__self:!0,__source:!0};\nfunction J(a,b,c){var e,d={},k=null,h=null;if(null!=b)for(e in void 0!==b.ref&&(h=b.ref),void 0!==b.key&&(k=""+b.key),b)H.call(b,e)&&!I.hasOwnProperty(e)&&(d[e]=b[e]);var g=arguments.length-2;if(1===g)d.children=c;else if(1<g){for(var f=Array(g),m=0;m<g;m++)f[m]=arguments[m+2];d.children=f}if(a&&a.defaultProps)for(e in g=a.defaultProps,g)void 0===d[e]&&(d[e]=g[e]);return{$$typeof:n,type:a,key:k,ref:h,props:d,_owner:G.current}}\nfunction K(a,b){return{$$typeof:n,type:a.type,key:b,ref:a.ref,props:a.props,_owner:a._owner}}function L(a){return"object"===typeof a&&null!==a&&a.$$typeof===n}function escape(a){var b={"=":"=0",":":"=2"};return"$"+a.replace(/[=:]/g,function(a){return b[a]})}var M=/\\/+/g;function N(a,b){return"object"===typeof a&&null!==a&&null!=a.key?escape(""+a.key):b.toString(36)}\nfunction O(a,b,c,e,d){var k=typeof a;if("undefined"===k||"boolean"===k)a=null;var h=!1;if(null===a)h=!0;else switch(k){case "string":case "number":h=!0;break;case "object":switch(a.$$typeof){case n:case p:h=!0}}if(h)return h=a,d=d(h),a=""===e?"."+N(h,0):e,Array.isArray(d)?(c="",null!=a&&(c=a.replace(M,"$&/")+"/"),O(d,b,c,"",function(a){return a})):null!=d&&(L(d)&&(d=K(d,c+(!d.key||h&&h.key===d.key?"":(""+d.key).replace(M,"$&/")+"/")+a)),b.push(d)),1;h=0;e=""===e?".":e+":";if(Array.isArray(a))for(var g=\n0;g<a.length;g++){k=a[g];var f=e+N(k,g);h+=O(k,b,c,f,d)}else if(f=y(a),"function"===typeof f)for(a=f.call(a),g=0;!(k=a.next()).done;)k=k.value,f=e+N(k,g++),h+=O(k,b,c,f,d);else if("object"===k)throw b=""+a,Error(z(31,"[object Object]"===b?"object with keys {"+Object.keys(a).join(", ")+"}":b));return h}function P(a,b,c){if(null==a)return a;var e=[],d=0;O(a,e,"","",function(a){return b.call(c,a,d++)});return e}\nfunction Q(a){if(-1===a._status){var b=a._result;b=b();a._status=0;a._result=b;b.then(function(b){0===a._status&&(b=b.default,a._status=1,a._result=b)},function(b){0===a._status&&(a._status=2,a._result=b)})}if(1===a._status)return a._result;throw a._result;}var R={current:null};function S(){var a=R.current;if(null===a)throw Error(z(321));return a}var T={ReactCurrentDispatcher:R,ReactCurrentBatchConfig:{transition:0},ReactCurrentOwner:G,IsSomeRendererActing:{current:!1},assign:l};\nexports.Children={map:P,forEach:function(a,b,c){P(a,function(){b.apply(this,arguments)},c)},count:function(a){var b=0;P(a,function(){b++});return b},toArray:function(a){return P(a,function(a){return a})||[]},only:function(a){if(!L(a))throw Error(z(143));return a}};exports.Component=C;exports.PureComponent=E;exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=T;\nexports.cloneElement=function(a,b,c){if(null===a||void 0===a)throw Error(z(267,a));var e=l({},a.props),d=a.key,k=a.ref,h=a._owner;if(null!=b){void 0!==b.ref&&(k=b.ref,h=G.current);void 0!==b.key&&(d=""+b.key);if(a.type&&a.type.defaultProps)var g=a.type.defaultProps;for(f in b)H.call(b,f)&&!I.hasOwnProperty(f)&&(e[f]=void 0===b[f]&&void 0!==g?g[f]:b[f])}var f=arguments.length-2;if(1===f)e.children=c;else if(1<f){g=Array(f);for(var m=0;m<f;m++)g[m]=arguments[m+2];e.children=g}return{$$typeof:n,type:a.type,\nkey:d,ref:k,props:e,_owner:h}};exports.createContext=function(a,b){void 0===b&&(b=null);a={$$typeof:r,_calculateChangedBits:b,_currentValue:a,_currentValue2:a,_threadCount:0,Provider:null,Consumer:null};a.Provider={$$typeof:q,_context:a};return a.Consumer=a};exports.createElement=J;exports.createFactory=function(a){var b=J.bind(null,a);b.type=a;return b};exports.createRef=function(){return{current:null}};exports.forwardRef=function(a){return{$$typeof:t,render:a}};exports.isValidElement=L;\nexports.lazy=function(a){return{$$typeof:v,_payload:{_status:-1,_result:a},_init:Q}};exports.memo=function(a,b){return{$$typeof:u,type:a,compare:void 0===b?null:b}};exports.useCallback=function(a,b){return S().useCallback(a,b)};exports.useContext=function(a,b){return S().useContext(a,b)};exports.useDebugValue=function(){};exports.useEffect=function(a,b){return S().useEffect(a,b)};exports.useImperativeHandle=function(a,b,c){return S().useImperativeHandle(a,b,c)};\nexports.useLayoutEffect=function(a,b){return S().useLayoutEffect(a,b)};exports.useMemo=function(a,b){return S().useMemo(a,b)};exports.useReducer=function(a,b,c){return S().useReducer(a,b,c)};exports.useRef=function(a){return S().useRef(a)};exports.useState=function(a){return S().useState(a)};exports.version="17.0.2";\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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Ly9tZGMtcmVhY3QvLi9ub2RlX21vZHVsZXMvcmVhY3QvY2pzL3JlYWN0LnByb2R1Y3Rpb24ubWluLmpzP2JlMjQiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqIEBsaWNlbnNlIFJlYWN0IHYxNy4wLjJcbiAqIHJlYWN0LnByb2R1Y3Rpb24ubWluLmpzXG4gKlxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cbid1c2Ugc3RyaWN0Jzt2YXIgbD1yZXF1aXJlKFwib2JqZWN0LWFzc2lnblwiKSxuPTYwMTAzLHA9NjAxMDY7ZXhwb3J0cy5GcmFnbWVudD02MDEwNztleHBvcnRzLlN0cmljdE1vZGU9NjAxMDg7ZXhwb3J0cy5Qcm9maWxlcj02MDExNDt2YXIgcT02MDEwOSxyPTYwMTEwLHQ9NjAxMTI7ZXhwb3J0cy5TdXNwZW5zZT02MDExMzt2YXIgdT02MDExNSx2PTYwMTE2O1xuaWYoXCJmdW5jdGlvblwiPT09dHlwZW9mIFN5bWJvbCYmU3ltYm9sLmZvcil7dmFyIHc9U3ltYm9sLmZvcjtuPXcoXCJyZWFjdC5lbGVtZW50XCIpO3A9dyhcInJlYWN0LnBvcnRhbFwiKTtleHBvcnRzLkZyYWdtZW50PXcoXCJyZWFjdC5mcmFnbWVudFwiKTtleHBvcnRzLlN0cmljdE1vZGU9dyhcInJlYWN0LnN0cmljdF9tb2RlXCIpO2V4cG9ydHMuUHJvZmlsZXI9dyhcInJlYWN0LnByb2ZpbGVyXCIpO3E9dyhcInJlYWN0LnByb3ZpZGVyXCIpO3I9dyhcInJlYWN0LmNvbnRleHRcIik7dD13KFwicmVhY3QuZm9yd2FyZF9yZWZcIik7ZXhwb3J0cy5TdXNwZW5zZT13KFwicmVhY3Quc3VzcGVuc2VcIik7dT13KFwicmVhY3QubWVtb1wiKTt2PXcoXCJyZWFjdC5sYXp5XCIpfXZhciB4PVwiZnVuY3Rpb25cIj09PXR5cGVvZiBTeW1ib2wmJlN5bWJvbC5pdGVyYXRvcjtcbmZ1bmN0aW9uIHkoYSl7aWYobnVsbD09PWF8fFwib2JqZWN0XCIhPT10eXBlb2YgYSlyZXR1cm4gbnVsbDthPXgmJmFbeF18fGFbXCJAQGl0ZXJhdG9yXCJdO3JldHVyblwiZnVuY3Rpb25cIj09PXR5cGVvZiBhP2E6bnVsbH1mdW5jdGlvbiB6KGEpe2Zvcih2YXIgYj1cImh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9lcnJvci1kZWNvZGVyLmh0bWw/aW52YXJpYW50PVwiK2EsYz0xO2M8YXJndW1lbnRzLmxlbmd0aDtjKyspYis9XCImYXJnc1tdPVwiK2VuY29kZVVSSUNvbXBvbmVudChhcmd1bWVudHNbY10pO3JldHVyblwiTWluaWZpZWQgUmVhY3QgZXJyb3IgI1wiK2ErXCI7IHZpc2l0IFwiK2IrXCIgZm9yIHRoZSBmdWxsIG1lc3NhZ2Ugb3IgdXNlIHRoZSBub24tbWluaWZpZWQgZGV2IGVudmlyb25tZW50IGZvciBmdWxsIGVycm9ycyBhbmQgYWRkaXRpb25hbCBoZWxwZnVsIHdhcm5pbmdzLlwifVxudmFyIEE9e2lzTW91bnRlZDpmdW5jdGlvbigpe3JldHVybiExfSxlbnF1ZXVlRm9yY2VVcGRhdGU6ZnVuY3Rpb24oKXt9LGVucXVldWVSZXBsYWNlU3RhdGU6ZnVuY3Rpb24oKXt9LGVucXVldWVTZXRTdGF0ZTpmdW5jdGlvbigpe319LEI9e307ZnVuY3Rpb24gQyhhLGIsYyl7dGhpcy5wcm9wcz1hO3RoaXMuY29udGV4dD1iO3RoaXMucmVmcz1CO3RoaXMudXBkYXRlcj1jfHxBfUMucHJvdG90eXBlLmlzUmVhY3RDb21wb25lbnQ9e307Qy5wcm90b3R5cGUuc2V0U3RhdGU9ZnVuY3Rpb24oYSxiKXtpZihcIm9iamVjdFwiIT09dHlwZW9mIGEmJlwiZnVuY3Rpb25cIiE9PXR5cGVvZiBhJiZudWxsIT1hKXRocm93IEVycm9yKHooODUpKTt0aGlzLnVwZGF0ZXIuZW5xdWV1ZVNldFN0YXRlKHRoaXMsYSxiLFwic2V0U3RhdGVcIil9O0MucHJvdG90eXBlLmZvcmNlVXBkYXRlPWZ1bmN0aW9uKGEpe3RoaXMudXBkYXRlci5lbnF1ZXVlRm9yY2VVcGRhdGUodGhpcyxhLFwiZm9yY2VVcGRhdGVcIil9O1xuZnVuY3Rpb24gRCgpe31ELnByb3RvdHlwZT1DLnByb3RvdHlwZTtmdW5jdGlvbiBFKGEsYixjKXt0aGlzLnByb3BzPWE7dGhpcy5jb250ZXh0PWI7dGhpcy5yZWZzPUI7dGhpcy51cGRhdGVyPWN8fEF9dmFyIEY9RS5wcm90b3R5cGU9bmV3IEQ7Ri5jb25zdHJ1Y3Rvcj1FO2woRixDLnByb3RvdHlwZSk7Ri5pc1B1cmVSZWFjdENvbXBvbmVudD0hMDt2YXIgRz17Y3VycmVudDpudWxsfSxIPU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHksST17a2V5OiEwLHJlZjohMCxfX3NlbGY6ITAsX19zb3VyY2U6ITB9O1xuZnVuY3Rpb24gSihhLGIsYyl7dmFyIGUsZD17fSxrPW51bGwsaD1udWxsO2lmKG51bGwhPWIpZm9yKGUgaW4gdm9pZCAwIT09Yi5yZWYmJihoPWIucmVmKSx2b2lkIDAhPT1iLmtleSYmKGs9XCJcIitiLmtleSksYilILmNhbGwoYixlKSYmIUkuaGFzT3duUHJvcGVydHkoZSkmJihkW2VdPWJbZV0pO3ZhciBnPWFyZ3VtZW50cy5sZW5ndGgtMjtpZigxPT09ZylkLmNoaWxkcmVuPWM7ZWxzZSBpZigxPGcpe2Zvcih2YXIgZj1BcnJheShnKSxtPTA7bTxnO20rKylmW21dPWFyZ3VtZW50c1ttKzJdO2QuY2hpbGRyZW49Zn1pZihhJiZhLmRlZmF1bHRQcm9wcylmb3IoZSBpbiBnPWEuZGVmYXVsdFByb3BzLGcpdm9pZCAwPT09ZFtlXSYmKGRbZV09Z1tlXSk7cmV0dXJueyQkdHlwZW9mOm4sdHlwZTphLGtleTprLHJlZjpoLHByb3BzOmQsX293bmVyOkcuY3VycmVudH19XG5mdW5jdGlvbiBLKGEsYil7cmV0dXJueyQkdHlwZW9mOm4sdHlwZTphLnR5cGUsa2V5OmIscmVmOmEucmVmLHByb3BzOmEucHJvcHMsX293bmVyOmEuX293bmVyfX1mdW5jdGlvbiBMKGEpe3JldHVyblwib2JqZWN0XCI9PT10eXBlb2YgYSYmbnVsbCE9PWEmJmEuJCR0eXBlb2Y9PT1ufWZ1bmN0aW9uIGVzY2FwZShhKXt2YXIgYj17XCI9XCI6XCI9MFwiLFwiOlwiOlwiPTJcIn07cmV0dXJuXCIkXCIrYS5yZXBsYWNlKC9bPTpdL2csZnVuY3Rpb24oYSl7cmV0dXJuIGJbYV19KX12YXIgTT0vXFwvKy9nO2Z1bmN0aW9uIE4oYSxiKXtyZXR1cm5cIm9iamVjdFwiPT09dHlwZW9mIGEmJm51bGwhPT1hJiZudWxsIT1hLmtleT9lc2NhcGUoXCJcIithLmtleSk6Yi50b1N0cmluZygzNil9XG5mdW5jdGlvbiBPKGEsYixjLGUsZCl7dmFyIGs9dHlwZW9mIGE7aWYoXCJ1bmRlZmluZWRcIj09PWt8fFwiYm9vbGVhblwiPT09aylhPW51bGw7dmFyIGg9ITE7aWYobnVsbD09PWEpaD0hMDtlbHNlIHN3aXRjaChrKXtjYXNlIFwic3RyaW5nXCI6Y2FzZSBcIm51bWJlclwiOmg9ITA7YnJlYWs7Y2FzZSBcIm9iamVjdFwiOnN3aXRjaChhLiQkdHlwZW9mKXtjYXNlIG46Y2FzZSBwOmg9ITB9fWlmKGgpcmV0dXJuIGg9YSxkPWQoaCksYT1cIlwiPT09ZT9cIi5cIitOKGgsMCk6ZSxBcnJheS5pc0FycmF5KGQpPyhjPVwiXCIsbnVsbCE9YSYmKGM9YS5yZXBsYWNlKE0sXCIkJi9cIikrXCIvXCIpLE8oZCxiLGMsXCJcIixmdW5jdGlvbihhKXtyZXR1cm4gYX0pKTpudWxsIT1kJiYoTChkKSYmKGQ9SyhkLGMrKCFkLmtleXx8aCYmaC5rZXk9PT1kLmtleT9cIlwiOihcIlwiK2Qua2V5KS5yZXBsYWNlKE0sXCIkJi9cIikrXCIvXCIpK2EpKSxiLnB1c2goZCkpLDE7aD0wO2U9XCJcIj09PWU/XCIuXCI6ZStcIjpcIjtpZihBcnJheS5pc0FycmF5KGEpKWZvcih2YXIgZz1cbjA7ZzxhLmxlbmd0aDtnKyspe2s9YVtnXTt2YXIgZj1lK04oayxnKTtoKz1PKGssYixjLGYsZCl9ZWxzZSBpZihmPXkoYSksXCJmdW5jdGlvblwiPT09dHlwZW9mIGYpZm9yKGE9Zi5jYWxsKGEpLGc9MDshKGs9YS5uZXh0KCkpLmRvbmU7KWs9ay52YWx1ZSxmPWUrTihrLGcrKyksaCs9TyhrLGIsYyxmLGQpO2Vsc2UgaWYoXCJvYmplY3RcIj09PWspdGhyb3cgYj1cIlwiK2EsRXJyb3IoeigzMSxcIltvYmplY3QgT2JqZWN0XVwiPT09Yj9cIm9iamVjdCB3aXRoIGtleXMge1wiK09iamVjdC5rZXlzKGEpLmpvaW4oXCIsIFwiKStcIn1cIjpiKSk7cmV0dXJuIGh9ZnVuY3Rpb24gUChhLGIsYyl7aWYobnVsbD09YSlyZXR1cm4gYTt2YXIgZT1bXSxkPTA7TyhhLGUsXCJcIixcIlwiLGZ1bmN0aW9uKGEpe3JldHVybiBiLmNhbGwoYyxhLGQrKyl9KTtyZXR1cm4gZX1cbmZ1bmN0aW9uIFEoYSl7aWYoLTE9PT1hLl9zdGF0dXMpe3ZhciBiPWEuX3Jlc3VsdDtiPWIoKTthLl9zdGF0dXM9MDthLl9yZXN1bHQ9YjtiLnRoZW4oZnVuY3Rpb24oYil7MD09PWEuX3N0YXR1cyYmKGI9Yi5kZWZhdWx0LGEuX3N0YXR1cz0xLGEuX3Jlc3VsdD1iKX0sZnVuY3Rpb24oYil7MD09PWEuX3N0YXR1cyYmKGEuX3N0YXR1cz0yLGEuX3Jlc3VsdD1iKX0pfWlmKDE9PT1hLl9zdGF0dXMpcmV0dXJuIGEuX3Jlc3VsdDt0aHJvdyBhLl9yZXN1bHQ7fXZhciBSPXtjdXJyZW50Om51bGx9O2Z1bmN0aW9uIFMoKXt2YXIgYT1SLmN1cnJlbnQ7aWYobnVsbD09PWEpdGhyb3cgRXJyb3IoeigzMjEpKTtyZXR1cm4gYX12YXIgVD17UmVhY3RDdXJyZW50RGlzcGF0Y2hlcjpSLFJlYWN0Q3VycmVudEJhdGNoQ29uZmlnOnt0cmFuc2l0aW9uOjB9LFJlYWN0Q3VycmVudE93bmVyOkcsSXNTb21lUmVuZGVyZXJBY3Rpbmc6e2N1cnJlbnQ6ITF9LGFzc2lnbjpsfTtcbmV4cG9ydHMuQ2hpbGRyZW49e21hcDpQLGZvckVhY2g6ZnVuY3Rpb24oYSxiLGMpe1AoYSxmdW5jdGlvbigpe2IuYXBwbHkodGhpcyxhcmd1bWVudHMpfSxjKX0sY291bnQ6ZnVuY3Rpb24oYSl7dmFyIGI9MDtQKGEsZnVuY3Rpb24oKXtiKyt9KTtyZXR1cm4gYn0sdG9BcnJheTpmdW5jdGlvbihhKXtyZXR1cm4gUChhLGZ1bmN0aW9uKGEpe3JldHVybiBhfSl8fFtdfSxvbmx5OmZ1bmN0aW9uKGEpe2lmKCFMKGEpKXRocm93IEVycm9yKHooMTQzKSk7cmV0dXJuIGF9fTtleHBvcnRzLkNvbXBvbmVudD1DO2V4cG9ydHMuUHVyZUNvbXBvbmVudD1FO2V4cG9ydHMuX19TRUNSRVRfSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfWU9VX1dJTExfQkVfRklSRUQ9VDtcbmV4cG9ydHMuY2xvbmVFbGVtZW50PWZ1bmN0aW9uKGEsYixjKXtpZihudWxsPT09YXx8dm9pZCAwPT09YSl0aHJvdyBFcnJvcih6KDI2NyxhKSk7dmFyIGU9bCh7fSxhLnByb3BzKSxkPWEua2V5LGs9YS5yZWYsaD1hLl9vd25lcjtpZihudWxsIT1iKXt2b2lkIDAhPT1iLnJlZiYmKGs9Yi5yZWYsaD1HLmN1cnJlbnQpO3ZvaWQgMCE9PWIua2V5JiYoZD1cIlwiK2Iua2V5KTtpZihhLnR5cGUmJmEudHlwZS5kZWZhdWx0UHJvcHMpdmFyIGc9YS50eXBlLmRlZmF1bHRQcm9wcztmb3IoZiBpbiBiKUguY2FsbChiLGYpJiYhSS5oYXNPd25Qcm9wZXJ0eShmKSYmKGVbZl09dm9pZCAwPT09YltmXSYmdm9pZCAwIT09Zz9nW2ZdOmJbZl0pfXZhciBmPWFyZ3VtZW50cy5sZW5ndGgtMjtpZigxPT09ZillLmNoaWxkcmVuPWM7ZWxzZSBpZigxPGYpe2c9QXJyYXkoZik7Zm9yKHZhciBtPTA7bTxmO20rKylnW21dPWFyZ3VtZW50c1ttKzJdO2UuY2hpbGRyZW49Z31yZXR1cm57JCR0eXBlb2Y6bix0eXBlOmEudHlwZSxcbmtleTpkLHJlZjprLHByb3BzOmUsX293bmVyOmh9fTtleHBvcnRzLmNyZWF0ZUNvbnRleHQ9ZnVuY3Rpb24oYSxiKXt2b2lkIDA9PT1iJiYoYj1udWxsKTthPXskJHR5cGVvZjpyLF9jYWxjdWxhdGVDaGFuZ2VkQml0czpiLF9jdXJyZW50VmFsdWU6YSxfY3VycmVudFZhbHVlMjphLF90aHJlYWRDb3VudDowLFByb3ZpZGVyOm51bGwsQ29uc3VtZXI6bnVsbH07YS5Qcm92aWRlcj17JCR0eXBlb2Y6cSxfY29udGV4dDphfTtyZXR1cm4gYS5Db25zdW1lcj1hfTtleHBvcnRzLmNyZWF0ZUVsZW1lbnQ9SjtleHBvcnRzLmNyZWF0ZUZhY3Rvcnk9ZnVuY3Rpb24oYSl7dmFyIGI9Si5iaW5kKG51bGwsYSk7Yi50eXBlPWE7cmV0dXJuIGJ9O2V4cG9ydHMuY3JlYXRlUmVmPWZ1bmN0aW9uKCl7cmV0dXJue2N1cnJlbnQ6bnVsbH19O2V4cG9ydHMuZm9yd2FyZFJlZj1mdW5jdGlvbihhKXtyZXR1cm57JCR0eXBlb2Y6dCxyZW5kZXI6YX19O2V4cG9ydHMuaXNWYWxpZEVsZW1lbnQ9TDtcbmV4cG9ydHMubGF6eT1mdW5jdGlvbihhKXtyZXR1cm57JCR0eXBlb2Y6dixfcGF5bG9hZDp7X3N0YXR1czotMSxfcmVzdWx0OmF9LF9pbml0OlF9fTtleHBvcnRzLm1lbW89ZnVuY3Rpb24oYSxiKXtyZXR1cm57JCR0eXBlb2Y6dSx0eXBlOmEsY29tcGFyZTp2b2lkIDA9PT1iP251bGw6Yn19O2V4cG9ydHMudXNlQ2FsbGJhY2s9ZnVuY3Rpb24oYSxiKXtyZXR1cm4gUygpLnVzZUNhbGxiYWNrKGEsYil9O2V4cG9ydHMudXNlQ29udGV4dD1mdW5jdGlvbihhLGIpe3JldHVybiBTKCkudXNlQ29udGV4dChhLGIpfTtleHBvcnRzLnVzZURlYnVnVmFsdWU9ZnVuY3Rpb24oKXt9O2V4cG9ydHMudXNlRWZmZWN0PWZ1bmN0aW9uKGEsYil7cmV0dXJuIFMoKS51c2VFZmZlY3QoYSxiKX07ZXhwb3J0cy51c2VJbXBlcmF0aXZlSGFuZGxlPWZ1bmN0aW9uKGEsYixjKXtyZXR1cm4gUygpLnVzZUltcGVyYXRpdmVIYW5kbGUoYSxiLGMpfTtcbmV4cG9ydHMudXNlTGF5b3V0RWZmZWN0PWZ1bmN0aW9uKGEsYil7cmV0dXJuIFMoKS51c2VMYXlvdXRFZmZlY3QoYSxiKX07ZXhwb3J0cy51c2VNZW1vPWZ1bmN0aW9uKGEsYil7cmV0dXJuIFMoKS51c2VNZW1vKGEsYil9O2V4cG9ydHMudXNlUmVkdWNlcj1mdW5jdGlvbihhLGIsYyl7cmV0dXJuIFMoKS51c2VSZWR1Y2VyKGEsYixjKX07ZXhwb3J0cy51c2VSZWY9ZnVuY3Rpb24oYSl7cmV0dXJuIFMoKS51c2VSZWYoYSl9O2V4cG9ydHMudXNlU3RhdGU9ZnVuY3Rpb24oYSl7cmV0dXJuIFMoKS51c2VTdGF0ZShhKX07ZXhwb3J0cy52ZXJzaW9uPVwiMTcuMC4yXCI7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///408\n')},294:(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("\n\nif (true) {\n  module.exports = __webpack_require__(408);\n} else {}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjk0LmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLElBQUksSUFBcUM7QUFDekMsRUFBRSx5Q0FBeUQ7QUFDM0QsRUFBRSxLQUFLLEVBRU4iLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9ub2RlX21vZHVsZXMvcmVhY3QvaW5kZXguanM/YWI1YiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QucHJvZHVjdGlvbi5taW4uanMnKTtcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QuZGV2ZWxvcG1lbnQuanMnKTtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///294\n")},893:(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("\n\nif (true) {\n  module.exports = __webpack_require__(251);\n} else {}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODkzLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLElBQUksSUFBcUM7QUFDekMsRUFBRSx5Q0FBcUU7QUFDdkUsRUFBRSxLQUFLLEVBRU4iLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9ub2RlX21vZHVsZXMvcmVhY3QvanN4LXJ1bnRpbWUuanM/OWNhNSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtanN4LXJ1bnRpbWUucHJvZHVjdGlvbi5taW4uanMnKTtcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtanN4LXJ1bnRpbWUuZGV2ZWxvcG1lbnQuanMnKTtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///893\n")},53:(__unused_webpack_module,exports)=>{"use strict";eval('/** @license React v0.20.2\n * scheduler.production.min.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nvar f,g,h,k;if("object"===typeof performance&&"function"===typeof performance.now){var l=performance;exports.unstable_now=function(){return l.now()}}else{var p=Date,q=p.now();exports.unstable_now=function(){return p.now()-q}}\nif("undefined"===typeof window||"function"!==typeof MessageChannel){var t=null,u=null,w=function(){if(null!==t)try{var a=exports.unstable_now();t(!0,a);t=null}catch(b){throw setTimeout(w,0),b;}};f=function(a){null!==t?setTimeout(f,0,a):(t=a,setTimeout(w,0))};g=function(a,b){u=setTimeout(a,b)};h=function(){clearTimeout(u)};exports.unstable_shouldYield=function(){return!1};k=exports.unstable_forceFrameRate=function(){}}else{var x=window.setTimeout,y=window.clearTimeout;if("undefined"!==typeof console){var z=\nwindow.cancelAnimationFrame;"function"!==typeof window.requestAnimationFrame&&console.error("This browser doesn\'t support requestAnimationFrame. Make sure that you load a polyfill in older browsers. https://reactjs.org/link/react-polyfills");"function"!==typeof z&&console.error("This browser doesn\'t support cancelAnimationFrame. Make sure that you load a polyfill in older browsers. https://reactjs.org/link/react-polyfills")}var A=!1,B=null,C=-1,D=5,E=0;exports.unstable_shouldYield=function(){return exports.unstable_now()>=\nE};k=function(){};exports.unstable_forceFrameRate=function(a){0>a||125<a?console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"):D=0<a?Math.floor(1E3/a):5};var F=new MessageChannel,G=F.port2;F.port1.onmessage=function(){if(null!==B){var a=exports.unstable_now();E=a+D;try{B(!0,a)?G.postMessage(null):(A=!1,B=null)}catch(b){throw G.postMessage(null),b;}}else A=!1};f=function(a){B=a;A||(A=!0,G.postMessage(null))};g=function(a,b){C=\nx(function(){a(exports.unstable_now())},b)};h=function(){y(C);C=-1}}function H(a,b){var c=a.length;a.push(b);a:for(;;){var d=c-1>>>1,e=a[d];if(void 0!==e&&0<I(e,b))a[d]=b,a[c]=e,c=d;else break a}}function J(a){a=a[0];return void 0===a?null:a}\nfunction K(a){var b=a[0];if(void 0!==b){var c=a.pop();if(c!==b){a[0]=c;a:for(var d=0,e=a.length;d<e;){var m=2*(d+1)-1,n=a[m],v=m+1,r=a[v];if(void 0!==n&&0>I(n,c))void 0!==r&&0>I(r,n)?(a[d]=r,a[v]=c,d=v):(a[d]=n,a[m]=c,d=m);else if(void 0!==r&&0>I(r,c))a[d]=r,a[v]=c,d=v;else break a}}return b}return null}function I(a,b){var c=a.sortIndex-b.sortIndex;return 0!==c?c:a.id-b.id}var L=[],M=[],N=1,O=null,P=3,Q=!1,R=!1,S=!1;\nfunction T(a){for(var b=J(M);null!==b;){if(null===b.callback)K(M);else if(b.startTime<=a)K(M),b.sortIndex=b.expirationTime,H(L,b);else break;b=J(M)}}function U(a){S=!1;T(a);if(!R)if(null!==J(L))R=!0,f(V);else{var b=J(M);null!==b&&g(U,b.startTime-a)}}\nfunction V(a,b){R=!1;S&&(S=!1,h());Q=!0;var c=P;try{T(b);for(O=J(L);null!==O&&(!(O.expirationTime>b)||a&&!exports.unstable_shouldYield());){var d=O.callback;if("function"===typeof d){O.callback=null;P=O.priorityLevel;var e=d(O.expirationTime<=b);b=exports.unstable_now();"function"===typeof e?O.callback=e:O===J(L)&&K(L);T(b)}else K(L);O=J(L)}if(null!==O)var m=!0;else{var n=J(M);null!==n&&g(U,n.startTime-b);m=!1}return m}finally{O=null,P=c,Q=!1}}var W=k;exports.unstable_IdlePriority=5;\nexports.unstable_ImmediatePriority=1;exports.unstable_LowPriority=4;exports.unstable_NormalPriority=3;exports.unstable_Profiling=null;exports.unstable_UserBlockingPriority=2;exports.unstable_cancelCallback=function(a){a.callback=null};exports.unstable_continueExecution=function(){R||Q||(R=!0,f(V))};exports.unstable_getCurrentPriorityLevel=function(){return P};exports.unstable_getFirstCallbackNode=function(){return J(L)};\nexports.unstable_next=function(a){switch(P){case 1:case 2:case 3:var b=3;break;default:b=P}var c=P;P=b;try{return a()}finally{P=c}};exports.unstable_pauseExecution=function(){};exports.unstable_requestPaint=W;exports.unstable_runWithPriority=function(a,b){switch(a){case 1:case 2:case 3:case 4:case 5:break;default:a=3}var c=P;P=a;try{return b()}finally{P=c}};\nexports.unstable_scheduleCallback=function(a,b,c){var d=exports.unstable_now();"object"===typeof c&&null!==c?(c=c.delay,c="number"===typeof c&&0<c?d+c:d):c=d;switch(a){case 1:var e=-1;break;case 2:e=250;break;case 5:e=1073741823;break;case 4:e=1E4;break;default:e=5E3}e=c+e;a={id:N++,callback:b,priorityLevel:a,startTime:c,expirationTime:e,sortIndex:-1};c>d?(a.sortIndex=c,H(M,a),null===J(L)&&a===J(M)&&(S?h():S=!0,g(U,c-d))):(a.sortIndex=e,H(L,a),R||Q||(R=!0,f(V)));return a};\nexports.unstable_wrapCallback=function(a){var b=P;return function(){var c=P;P=b;try{return a.apply(this,arguments)}finally{P=c}}};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNhLFlBQVksdUVBQXVFLGtCQUFrQixvQkFBb0IsWUFBWSxnQkFBZ0IsS0FBSyxxQkFBcUIsb0JBQW9CLFlBQVk7QUFDNU4sb0VBQW9FLCtCQUErQixnQkFBZ0IsNkJBQTZCLFFBQVEsT0FBTyxTQUFTLDJCQUEyQixjQUFjLGtEQUFrRCxnQkFBZ0IsbUJBQW1CLGFBQWEsaUJBQWlCLDRCQUE0QixZQUFZLFVBQVUsRUFBRSwrQkFBK0IsY0FBYyxLQUFLLDhDQUE4QyxpQ0FBaUM7QUFDemYsNEJBQTRCLHNOQUFzTiwwTEFBMEwsNkJBQTZCLDRCQUE0QixZQUFZO0FBQ2pmLEdBQUcsZUFBZSwrQkFBK0IsYUFBYSx1S0FBdUssbUNBQW1DLDZCQUE2QixhQUFhLDZCQUE2QixNQUFNLElBQUksMENBQTBDLFNBQVMsOEJBQThCLFdBQVcsY0FBYyxJQUFJLCtCQUErQixnQkFBZ0I7QUFDdGYsYUFBYSwwQkFBMEIsS0FBSyxhQUFhLEtBQUssTUFBTSxnQkFBZ0IsZUFBZSxVQUFVLFFBQVEsRUFBRSxxQkFBcUIsMENBQTBDLGNBQWMsY0FBYyxPQUFPO0FBQ3pOLGNBQWMsV0FBVyxlQUFlLGNBQWMsVUFBVSxPQUFPLHlCQUF5QixJQUFJLEVBQUUsb0NBQW9DLHFGQUFxRiwrQ0FBK0MsY0FBYyxTQUFTLFlBQVksZ0JBQWdCLDhCQUE4Qix5QkFBeUI7QUFDeFgsY0FBYyxlQUFlLFNBQVMsRUFBRSwwQkFBMEIsZ0VBQWdFLFdBQVcsUUFBUSxjQUFjLEtBQUssS0FBSywrQkFBK0IsS0FBSyxXQUFXO0FBQzVOLGdCQUFnQixLQUFLLGNBQWMsS0FBSyxRQUFRLElBQUksS0FBSyxXQUFXLHNFQUFzRSxFQUFFLGlCQUFpQiwwQkFBMEIsZ0JBQWdCLGtCQUFrQiw2QkFBNkIseUJBQXlCLGtEQUFrRCxLQUFLLFVBQVUsT0FBTyxxQkFBcUIsS0FBSyxXQUFXLDZCQUE2QixLQUFLLFNBQVMsUUFBUSxpQkFBaUIsUUFBUSw2QkFBNkI7QUFDcmUsa0NBQWtDLEdBQUcsNEJBQTRCLEdBQUcsK0JBQStCLEdBQUcsMEJBQTBCLE1BQU0scUNBQXFDLEdBQUcsK0JBQStCLGFBQWEsaUJBQWlCLGtDQUFrQyxZQUFZLG1CQUFtQix3Q0FBd0MsWUFBWSxVQUFVLHFDQUFxQyxZQUFZO0FBQzNaLHFCQUFxQixhQUFhLFVBQVUsNkJBQTZCLE1BQU0sWUFBWSxRQUFRLElBQUksSUFBSSxXQUFXLFFBQVEsTUFBTSwrQkFBK0IsY0FBYyw2QkFBNkIsR0FBRyxnQ0FBZ0MsZUFBZSxVQUFVLHlDQUF5QyxZQUFZLFFBQVEsSUFBSSxJQUFJLFdBQVcsUUFBUTtBQUNsVyxpQ0FBaUMsaUJBQWlCLDZCQUE2QiwrRUFBK0UsVUFBVSxnQkFBZ0IsTUFBTSxhQUFhLE1BQU0sb0JBQW9CLE1BQU0sYUFBYSxNQUFNLGNBQWMsTUFBTSxHQUFHLDZFQUE2RSxpSEFBaUg7QUFDbmQsNkJBQTZCLGFBQWEsUUFBUSxrQkFBa0IsUUFBUSxJQUFJLElBQUksK0JBQStCLFFBQVEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9ub2RlX21vZHVsZXMvc2NoZWR1bGVyL2Nqcy9zY2hlZHVsZXIucHJvZHVjdGlvbi5taW4uanM/ZmIwNyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiogQGxpY2Vuc2UgUmVhY3QgdjAuMjAuMlxuICogc2NoZWR1bGVyLnByb2R1Y3Rpb24ubWluLmpzXG4gKlxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cbid1c2Ugc3RyaWN0Jzt2YXIgZixnLGgsaztpZihcIm9iamVjdFwiPT09dHlwZW9mIHBlcmZvcm1hbmNlJiZcImZ1bmN0aW9uXCI9PT10eXBlb2YgcGVyZm9ybWFuY2Uubm93KXt2YXIgbD1wZXJmb3JtYW5jZTtleHBvcnRzLnVuc3RhYmxlX25vdz1mdW5jdGlvbigpe3JldHVybiBsLm5vdygpfX1lbHNle3ZhciBwPURhdGUscT1wLm5vdygpO2V4cG9ydHMudW5zdGFibGVfbm93PWZ1bmN0aW9uKCl7cmV0dXJuIHAubm93KCktcX19XG5pZihcInVuZGVmaW5lZFwiPT09dHlwZW9mIHdpbmRvd3x8XCJmdW5jdGlvblwiIT09dHlwZW9mIE1lc3NhZ2VDaGFubmVsKXt2YXIgdD1udWxsLHU9bnVsbCx3PWZ1bmN0aW9uKCl7aWYobnVsbCE9PXQpdHJ5e3ZhciBhPWV4cG9ydHMudW5zdGFibGVfbm93KCk7dCghMCxhKTt0PW51bGx9Y2F0Y2goYil7dGhyb3cgc2V0VGltZW91dCh3LDApLGI7fX07Zj1mdW5jdGlvbihhKXtudWxsIT09dD9zZXRUaW1lb3V0KGYsMCxhKToodD1hLHNldFRpbWVvdXQodywwKSl9O2c9ZnVuY3Rpb24oYSxiKXt1PXNldFRpbWVvdXQoYSxiKX07aD1mdW5jdGlvbigpe2NsZWFyVGltZW91dCh1KX07ZXhwb3J0cy51bnN0YWJsZV9zaG91bGRZaWVsZD1mdW5jdGlvbigpe3JldHVybiExfTtrPWV4cG9ydHMudW5zdGFibGVfZm9yY2VGcmFtZVJhdGU9ZnVuY3Rpb24oKXt9fWVsc2V7dmFyIHg9d2luZG93LnNldFRpbWVvdXQseT13aW5kb3cuY2xlYXJUaW1lb3V0O2lmKFwidW5kZWZpbmVkXCIhPT10eXBlb2YgY29uc29sZSl7dmFyIHo9XG53aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWU7XCJmdW5jdGlvblwiIT09dHlwZW9mIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUmJmNvbnNvbGUuZXJyb3IoXCJUaGlzIGJyb3dzZXIgZG9lc24ndCBzdXBwb3J0IHJlcXVlc3RBbmltYXRpb25GcmFtZS4gTWFrZSBzdXJlIHRoYXQgeW91IGxvYWQgYSBwb2x5ZmlsbCBpbiBvbGRlciBicm93c2Vycy4gaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3JlYWN0LXBvbHlmaWxsc1wiKTtcImZ1bmN0aW9uXCIhPT10eXBlb2YgeiYmY29uc29sZS5lcnJvcihcIlRoaXMgYnJvd3NlciBkb2Vzbid0IHN1cHBvcnQgY2FuY2VsQW5pbWF0aW9uRnJhbWUuIE1ha2Ugc3VyZSB0aGF0IHlvdSBsb2FkIGEgcG9seWZpbGwgaW4gb2xkZXIgYnJvd3NlcnMuIGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9yZWFjdC1wb2x5ZmlsbHNcIil9dmFyIEE9ITEsQj1udWxsLEM9LTEsRD01LEU9MDtleHBvcnRzLnVuc3RhYmxlX3Nob3VsZFlpZWxkPWZ1bmN0aW9uKCl7cmV0dXJuIGV4cG9ydHMudW5zdGFibGVfbm93KCk+PVxuRX07az1mdW5jdGlvbigpe307ZXhwb3J0cy51bnN0YWJsZV9mb3JjZUZyYW1lUmF0ZT1mdW5jdGlvbihhKXswPmF8fDEyNTxhP2NvbnNvbGUuZXJyb3IoXCJmb3JjZUZyYW1lUmF0ZSB0YWtlcyBhIHBvc2l0aXZlIGludCBiZXR3ZWVuIDAgYW5kIDEyNSwgZm9yY2luZyBmcmFtZSByYXRlcyBoaWdoZXIgdGhhbiAxMjUgZnBzIGlzIG5vdCBzdXBwb3J0ZWRcIik6RD0wPGE/TWF0aC5mbG9vcigxRTMvYSk6NX07dmFyIEY9bmV3IE1lc3NhZ2VDaGFubmVsLEc9Ri5wb3J0MjtGLnBvcnQxLm9ubWVzc2FnZT1mdW5jdGlvbigpe2lmKG51bGwhPT1CKXt2YXIgYT1leHBvcnRzLnVuc3RhYmxlX25vdygpO0U9YStEO3RyeXtCKCEwLGEpP0cucG9zdE1lc3NhZ2UobnVsbCk6KEE9ITEsQj1udWxsKX1jYXRjaChiKXt0aHJvdyBHLnBvc3RNZXNzYWdlKG51bGwpLGI7fX1lbHNlIEE9ITF9O2Y9ZnVuY3Rpb24oYSl7Qj1hO0F8fChBPSEwLEcucG9zdE1lc3NhZ2UobnVsbCkpfTtnPWZ1bmN0aW9uKGEsYil7Qz1cbngoZnVuY3Rpb24oKXthKGV4cG9ydHMudW5zdGFibGVfbm93KCkpfSxiKX07aD1mdW5jdGlvbigpe3koQyk7Qz0tMX19ZnVuY3Rpb24gSChhLGIpe3ZhciBjPWEubGVuZ3RoO2EucHVzaChiKTthOmZvcig7Oyl7dmFyIGQ9Yy0xPj4+MSxlPWFbZF07aWYodm9pZCAwIT09ZSYmMDxJKGUsYikpYVtkXT1iLGFbY109ZSxjPWQ7ZWxzZSBicmVhayBhfX1mdW5jdGlvbiBKKGEpe2E9YVswXTtyZXR1cm4gdm9pZCAwPT09YT9udWxsOmF9XG5mdW5jdGlvbiBLKGEpe3ZhciBiPWFbMF07aWYodm9pZCAwIT09Yil7dmFyIGM9YS5wb3AoKTtpZihjIT09Yil7YVswXT1jO2E6Zm9yKHZhciBkPTAsZT1hLmxlbmd0aDtkPGU7KXt2YXIgbT0yKihkKzEpLTEsbj1hW21dLHY9bSsxLHI9YVt2XTtpZih2b2lkIDAhPT1uJiYwPkkobixjKSl2b2lkIDAhPT1yJiYwPkkocixuKT8oYVtkXT1yLGFbdl09YyxkPXYpOihhW2RdPW4sYVttXT1jLGQ9bSk7ZWxzZSBpZih2b2lkIDAhPT1yJiYwPkkocixjKSlhW2RdPXIsYVt2XT1jLGQ9djtlbHNlIGJyZWFrIGF9fXJldHVybiBifXJldHVybiBudWxsfWZ1bmN0aW9uIEkoYSxiKXt2YXIgYz1hLnNvcnRJbmRleC1iLnNvcnRJbmRleDtyZXR1cm4gMCE9PWM/YzphLmlkLWIuaWR9dmFyIEw9W10sTT1bXSxOPTEsTz1udWxsLFA9MyxRPSExLFI9ITEsUz0hMTtcbmZ1bmN0aW9uIFQoYSl7Zm9yKHZhciBiPUooTSk7bnVsbCE9PWI7KXtpZihudWxsPT09Yi5jYWxsYmFjaylLKE0pO2Vsc2UgaWYoYi5zdGFydFRpbWU8PWEpSyhNKSxiLnNvcnRJbmRleD1iLmV4cGlyYXRpb25UaW1lLEgoTCxiKTtlbHNlIGJyZWFrO2I9SihNKX19ZnVuY3Rpb24gVShhKXtTPSExO1QoYSk7aWYoIVIpaWYobnVsbCE9PUooTCkpUj0hMCxmKFYpO2Vsc2V7dmFyIGI9SihNKTtudWxsIT09YiYmZyhVLGIuc3RhcnRUaW1lLWEpfX1cbmZ1bmN0aW9uIFYoYSxiKXtSPSExO1MmJihTPSExLGgoKSk7UT0hMDt2YXIgYz1QO3RyeXtUKGIpO2ZvcihPPUooTCk7bnVsbCE9PU8mJighKE8uZXhwaXJhdGlvblRpbWU+Yil8fGEmJiFleHBvcnRzLnVuc3RhYmxlX3Nob3VsZFlpZWxkKCkpOyl7dmFyIGQ9Ty5jYWxsYmFjaztpZihcImZ1bmN0aW9uXCI9PT10eXBlb2YgZCl7Ty5jYWxsYmFjaz1udWxsO1A9Ty5wcmlvcml0eUxldmVsO3ZhciBlPWQoTy5leHBpcmF0aW9uVGltZTw9Yik7Yj1leHBvcnRzLnVuc3RhYmxlX25vdygpO1wiZnVuY3Rpb25cIj09PXR5cGVvZiBlP08uY2FsbGJhY2s9ZTpPPT09SihMKSYmSyhMKTtUKGIpfWVsc2UgSyhMKTtPPUooTCl9aWYobnVsbCE9PU8pdmFyIG09ITA7ZWxzZXt2YXIgbj1KKE0pO251bGwhPT1uJiZnKFUsbi5zdGFydFRpbWUtYik7bT0hMX1yZXR1cm4gbX1maW5hbGx5e089bnVsbCxQPWMsUT0hMX19dmFyIFc9aztleHBvcnRzLnVuc3RhYmxlX0lkbGVQcmlvcml0eT01O1xuZXhwb3J0cy51bnN0YWJsZV9JbW1lZGlhdGVQcmlvcml0eT0xO2V4cG9ydHMudW5zdGFibGVfTG93UHJpb3JpdHk9NDtleHBvcnRzLnVuc3RhYmxlX05vcm1hbFByaW9yaXR5PTM7ZXhwb3J0cy51bnN0YWJsZV9Qcm9maWxpbmc9bnVsbDtleHBvcnRzLnVuc3RhYmxlX1VzZXJCbG9ja2luZ1ByaW9yaXR5PTI7ZXhwb3J0cy51bnN0YWJsZV9jYW5jZWxDYWxsYmFjaz1mdW5jdGlvbihhKXthLmNhbGxiYWNrPW51bGx9O2V4cG9ydHMudW5zdGFibGVfY29udGludWVFeGVjdXRpb249ZnVuY3Rpb24oKXtSfHxRfHwoUj0hMCxmKFYpKX07ZXhwb3J0cy51bnN0YWJsZV9nZXRDdXJyZW50UHJpb3JpdHlMZXZlbD1mdW5jdGlvbigpe3JldHVybiBQfTtleHBvcnRzLnVuc3RhYmxlX2dldEZpcnN0Q2FsbGJhY2tOb2RlPWZ1bmN0aW9uKCl7cmV0dXJuIEooTCl9O1xuZXhwb3J0cy51bnN0YWJsZV9uZXh0PWZ1bmN0aW9uKGEpe3N3aXRjaChQKXtjYXNlIDE6Y2FzZSAyOmNhc2UgMzp2YXIgYj0zO2JyZWFrO2RlZmF1bHQ6Yj1QfXZhciBjPVA7UD1iO3RyeXtyZXR1cm4gYSgpfWZpbmFsbHl7UD1jfX07ZXhwb3J0cy51bnN0YWJsZV9wYXVzZUV4ZWN1dGlvbj1mdW5jdGlvbigpe307ZXhwb3J0cy51bnN0YWJsZV9yZXF1ZXN0UGFpbnQ9VztleHBvcnRzLnVuc3RhYmxlX3J1bldpdGhQcmlvcml0eT1mdW5jdGlvbihhLGIpe3N3aXRjaChhKXtjYXNlIDE6Y2FzZSAyOmNhc2UgMzpjYXNlIDQ6Y2FzZSA1OmJyZWFrO2RlZmF1bHQ6YT0zfXZhciBjPVA7UD1hO3RyeXtyZXR1cm4gYigpfWZpbmFsbHl7UD1jfX07XG5leHBvcnRzLnVuc3RhYmxlX3NjaGVkdWxlQ2FsbGJhY2s9ZnVuY3Rpb24oYSxiLGMpe3ZhciBkPWV4cG9ydHMudW5zdGFibGVfbm93KCk7XCJvYmplY3RcIj09PXR5cGVvZiBjJiZudWxsIT09Yz8oYz1jLmRlbGF5LGM9XCJudW1iZXJcIj09PXR5cGVvZiBjJiYwPGM/ZCtjOmQpOmM9ZDtzd2l0Y2goYSl7Y2FzZSAxOnZhciBlPS0xO2JyZWFrO2Nhc2UgMjplPTI1MDticmVhaztjYXNlIDU6ZT0xMDczNzQxODIzO2JyZWFrO2Nhc2UgNDplPTFFNDticmVhaztkZWZhdWx0OmU9NUUzfWU9YytlO2E9e2lkOk4rKyxjYWxsYmFjazpiLHByaW9yaXR5TGV2ZWw6YSxzdGFydFRpbWU6YyxleHBpcmF0aW9uVGltZTplLHNvcnRJbmRleDotMX07Yz5kPyhhLnNvcnRJbmRleD1jLEgoTSxhKSxudWxsPT09SihMKSYmYT09PUooTSkmJihTP2goKTpTPSEwLGcoVSxjLWQpKSk6KGEuc29ydEluZGV4PWUsSChMLGEpLFJ8fFF8fChSPSEwLGYoVikpKTtyZXR1cm4gYX07XG5leHBvcnRzLnVuc3RhYmxlX3dyYXBDYWxsYmFjaz1mdW5jdGlvbihhKXt2YXIgYj1QO3JldHVybiBmdW5jdGlvbigpe3ZhciBjPVA7UD1iO3RyeXtyZXR1cm4gYS5hcHBseSh0aGlzLGFyZ3VtZW50cyl9ZmluYWxseXtQPWN9fX07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///53\n')},840:(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("\n\nif (true) {\n  module.exports = __webpack_require__(53);\n} else {}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODQwLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLElBQUksSUFBcUM7QUFDekMsRUFBRSx3Q0FBNkQ7QUFDL0QsRUFBRSxLQUFLLEVBRU4iLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9tZGMtcmVhY3QvLi9ub2RlX21vZHVsZXMvc2NoZWR1bGVyL2luZGV4LmpzPzQwMjkiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJykge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3NjaGVkdWxlci5wcm9kdWN0aW9uLm1pbi5qcycpO1xufSBlbHNlIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9zY2hlZHVsZXIuZGV2ZWxvcG1lbnQuanMnKTtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///840\n")},390:module=>{eval("var deepFreezeEs6 = {exports: {}};\n\nfunction deepFreeze(obj) {\n    if (obj instanceof Map) {\n        obj.clear = obj.delete = obj.set = function () {\n            throw new Error('map is read-only');\n        };\n    } else if (obj instanceof Set) {\n        obj.add = obj.clear = obj.delete = function () {\n            throw new Error('set is read-only');\n        };\n    }\n\n    // Freeze self\n    Object.freeze(obj);\n\n    Object.getOwnPropertyNames(obj).forEach(function (name) {\n        var prop = obj[name];\n\n        // Freeze prop if it is an object\n        if (typeof prop == 'object' && !Object.isFrozen(prop)) {\n            deepFreeze(prop);\n        }\n    });\n\n    return obj;\n}\n\ndeepFreezeEs6.exports = deepFreeze;\ndeepFreezeEs6.exports.default = deepFreeze;\n\nvar deepFreeze$1 = deepFreezeEs6.exports;\n\n/** @typedef {import('highlight.js').CallbackResponse} CallbackResponse */\n/** @typedef {import('highlight.js').CompiledMode} CompiledMode */\n/** @implements CallbackResponse */\n\nclass Response {\n  /**\n   * @param {CompiledMode} mode\n   */\n  constructor(mode) {\n    // eslint-disable-next-line no-undefined\n    if (mode.data === undefined) mode.data = {};\n\n    this.data = mode.data;\n    this.isMatchIgnored = false;\n  }\n\n  ignoreMatch() {\n    this.isMatchIgnored = true;\n  }\n}\n\n/**\n * @param {string} value\n * @returns {string}\n */\nfunction escapeHTML(value) {\n  return value\n    .replace(/&/g, '&amp;')\n    .replace(/</g, '&lt;')\n    .replace(/>/g, '&gt;')\n    .replace(/\"/g, '&quot;')\n    .replace(/'/g, '&#x27;');\n}\n\n/**\n * performs a shallow merge of multiple objects into one\n *\n * @template T\n * @param {T} original\n * @param {Record<string,any>[]} objects\n * @returns {T} a single new object\n */\nfunction inherit$1(original, ...objects) {\n  /** @type Record<string,any> */\n  const result = Object.create(null);\n\n  for (const key in original) {\n    result[key] = original[key];\n  }\n  objects.forEach(function(obj) {\n    for (const key in obj) {\n      result[key] = obj[key];\n    }\n  });\n  return /** @type {T} */ (result);\n}\n\n/**\n * @typedef {object} Renderer\n * @property {(text: string) => void} addText\n * @property {(node: Node) => void} openNode\n * @property {(node: Node) => void} closeNode\n * @property {() => string} value\n */\n\n/** @typedef {{kind?: string, sublanguage?: boolean}} Node */\n/** @typedef {{walk: (r: Renderer) => void}} Tree */\n/** */\n\nconst SPAN_CLOSE = '</span>';\n\n/**\n * Determines if a node needs to be wrapped in <span>\n *\n * @param {Node} node */\nconst emitsWrappingTags = (node) => {\n  return !!node.kind;\n};\n\n/**\n *\n * @param {string} name\n * @param {{prefix:string}} options\n */\nconst expandScopeName = (name, { prefix }) => {\n  if (name.includes(\".\")) {\n    const pieces = name.split(\".\");\n    return [\n      `${prefix}${pieces.shift()}`,\n      ...(pieces.map((x, i) => `${x}${\"_\".repeat(i + 1)}`))\n    ].join(\" \");\n  }\n  return `${prefix}${name}`;\n};\n\n/** @type {Renderer} */\nclass HTMLRenderer {\n  /**\n   * Creates a new HTMLRenderer\n   *\n   * @param {Tree} parseTree - the parse tree (must support `walk` API)\n   * @param {{classPrefix: string}} options\n   */\n  constructor(parseTree, options) {\n    this.buffer = \"\";\n    this.classPrefix = options.classPrefix;\n    parseTree.walk(this);\n  }\n\n  /**\n   * Adds texts to the output stream\n   *\n   * @param {string} text */\n  addText(text) {\n    this.buffer += escapeHTML(text);\n  }\n\n  /**\n   * Adds a node open to the output stream (if needed)\n   *\n   * @param {Node} node */\n  openNode(node) {\n    if (!emitsWrappingTags(node)) return;\n\n    let scope = node.kind;\n    if (node.sublanguage) {\n      scope = `language-${scope}`;\n    } else {\n      scope = expandScopeName(scope, { prefix: this.classPrefix });\n    }\n    this.span(scope);\n  }\n\n  /**\n   * Adds a node close to the output stream (if needed)\n   *\n   * @param {Node} node */\n  closeNode(node) {\n    if (!emitsWrappingTags(node)) return;\n\n    this.buffer += SPAN_CLOSE;\n  }\n\n  /**\n   * returns the accumulated buffer\n  */\n  value() {\n    return this.buffer;\n  }\n\n  // helpers\n\n  /**\n   * Builds a span element\n   *\n   * @param {string} className */\n  span(className) {\n    this.buffer += `<span class=\"${className}\">`;\n  }\n}\n\n/** @typedef {{kind?: string, sublanguage?: boolean, children: Node[]} | string} Node */\n/** @typedef {{kind?: string, sublanguage?: boolean, children: Node[]} } DataNode */\n/** @typedef {import('highlight.js').Emitter} Emitter */\n/**  */\n\nclass TokenTree {\n  constructor() {\n    /** @type DataNode */\n    this.rootNode = { children: [] };\n    this.stack = [this.rootNode];\n  }\n\n  get top() {\n    return this.stack[this.stack.length - 1];\n  }\n\n  get root() { return this.rootNode; }\n\n  /** @param {Node} node */\n  add(node) {\n    this.top.children.push(node);\n  }\n\n  /** @param {string} kind */\n  openNode(kind) {\n    /** @type Node */\n    const node = { kind, children: [] };\n    this.add(node);\n    this.stack.push(node);\n  }\n\n  closeNode() {\n    if (this.stack.length > 1) {\n      return this.stack.pop();\n    }\n    // eslint-disable-next-line no-undefined\n    return undefined;\n  }\n\n  closeAllNodes() {\n    while (this.closeNode());\n  }\n\n  toJSON() {\n    return JSON.stringify(this.rootNode, null, 4);\n  }\n\n  /**\n   * @typedef { import(\"./html_renderer\").Renderer } Renderer\n   * @param {Renderer} builder\n   */\n  walk(builder) {\n    // this does not\n    return this.constructor._walk(builder, this.rootNode);\n    // this works\n    // return TokenTree._walk(builder, this.rootNode);\n  }\n\n  /**\n   * @param {Renderer} builder\n   * @param {Node} node\n   */\n  static _walk(builder, node) {\n    if (typeof node === \"string\") {\n      builder.addText(node);\n    } else if (node.children) {\n      builder.openNode(node);\n      node.children.forEach((child) => this._walk(builder, child));\n      builder.closeNode(node);\n    }\n    return builder;\n  }\n\n  /**\n   * @param {Node} node\n   */\n  static _collapse(node) {\n    if (typeof node === \"string\") return;\n    if (!node.children) return;\n\n    if (node.children.every(el => typeof el === \"string\")) {\n      // node.text = node.children.join(\"\");\n      // delete node.children;\n      node.children = [node.children.join(\"\")];\n    } else {\n      node.children.forEach((child) => {\n        TokenTree._collapse(child);\n      });\n    }\n  }\n}\n\n/**\n  Currently this is all private API, but this is the minimal API necessary\n  that an Emitter must implement to fully support the parser.\n\n  Minimal interface:\n\n  - addKeyword(text, kind)\n  - addText(text)\n  - addSublanguage(emitter, subLanguageName)\n  - finalize()\n  - openNode(kind)\n  - closeNode()\n  - closeAllNodes()\n  - toHTML()\n\n*/\n\n/**\n * @implements {Emitter}\n */\nclass TokenTreeEmitter extends TokenTree {\n  /**\n   * @param {*} options\n   */\n  constructor(options) {\n    super();\n    this.options = options;\n  }\n\n  /**\n   * @param {string} text\n   * @param {string} kind\n   */\n  addKeyword(text, kind) {\n    if (text === \"\") { return; }\n\n    this.openNode(kind);\n    this.addText(text);\n    this.closeNode();\n  }\n\n  /**\n   * @param {string} text\n   */\n  addText(text) {\n    if (text === \"\") { return; }\n\n    this.add(text);\n  }\n\n  /**\n   * @param {Emitter & {root: DataNode}} emitter\n   * @param {string} name\n   */\n  addSublanguage(emitter, name) {\n    /** @type DataNode */\n    const node = emitter.root;\n    node.kind = name;\n    node.sublanguage = true;\n    this.add(node);\n  }\n\n  toHTML() {\n    const renderer = new HTMLRenderer(this, this.options);\n    return renderer.value();\n  }\n\n  finalize() {\n    return true;\n  }\n}\n\n/**\n * @param {string} value\n * @returns {RegExp}\n * */\n\n/**\n * @param {RegExp | string } re\n * @returns {string}\n */\nfunction source(re) {\n  if (!re) return null;\n  if (typeof re === \"string\") return re;\n\n  return re.source;\n}\n\n/**\n * @param {RegExp | string } re\n * @returns {string}\n */\nfunction lookahead(re) {\n  return concat('(?=', re, ')');\n}\n\n/**\n * @param {...(RegExp | string) } args\n * @returns {string}\n */\nfunction concat(...args) {\n  const joined = args.map((x) => source(x)).join(\"\");\n  return joined;\n}\n\nfunction stripOptionsFromArgs(args) {\n  const opts = args[args.length - 1];\n\n  if (typeof opts === 'object' && opts.constructor === Object) {\n    args.splice(args.length - 1, 1);\n    return opts;\n  } else {\n    return {};\n  }\n}\n\n/**\n * Any of the passed expresssions may match\n *\n * Creates a huge this | this | that | that match\n * @param {(RegExp | string)[] } args\n * @returns {string}\n */\nfunction either(...args) {\n  const opts = stripOptionsFromArgs(args);\n  const joined = '(' +\n    (opts.capture ? \"\" : \"?:\") +\n    args.map((x) => source(x)).join(\"|\") + \")\";\n  return joined;\n}\n\n/**\n * @param {RegExp} re\n * @returns {number}\n */\nfunction countMatchGroups(re) {\n  return (new RegExp(re.toString() + '|')).exec('').length - 1;\n}\n\n/**\n * Does lexeme start with a regular expression match at the beginning\n * @param {RegExp} re\n * @param {string} lexeme\n */\nfunction startsWith(re, lexeme) {\n  const match = re && re.exec(lexeme);\n  return match && match.index === 0;\n}\n\n// BACKREF_RE matches an open parenthesis or backreference. To avoid\n// an incorrect parse, it additionally matches the following:\n// - [...] elements, where the meaning of parentheses and escapes change\n// - other escape sequences, so we do not misparse escape sequences as\n//   interesting elements\n// - non-matching or lookahead parentheses, which do not capture. These\n//   follow the '(' with a '?'.\nconst BACKREF_RE = /\\[(?:[^\\\\\\]]|\\\\.)*\\]|\\(\\??|\\\\([1-9][0-9]*)|\\\\./;\n\n// **INTERNAL** Not intended for outside usage\n// join logically computes regexps.join(separator), but fixes the\n// backreferences so they continue to match.\n// it also places each individual regular expression into it's own\n// match group, keeping track of the sequencing of those match groups\n// is currently an exercise for the caller. :-)\n/**\n * @param {(string | RegExp)[]} regexps\n * @param {{joinWith: string}} opts\n * @returns {string}\n */\nfunction _rewriteBackreferences(regexps, { joinWith }) {\n  let numCaptures = 0;\n\n  return regexps.map((regex) => {\n    numCaptures += 1;\n    const offset = numCaptures;\n    let re = source(regex);\n    let out = '';\n\n    while (re.length > 0) {\n      const match = BACKREF_RE.exec(re);\n      if (!match) {\n        out += re;\n        break;\n      }\n      out += re.substring(0, match.index);\n      re = re.substring(match.index + match[0].length);\n      if (match[0][0] === '\\\\' && match[1]) {\n        // Adjust the backreference.\n        out += '\\\\' + String(Number(match[1]) + offset);\n      } else {\n        out += match[0];\n        if (match[0] === '(') {\n          numCaptures++;\n        }\n      }\n    }\n    return out;\n  }).map(re => `(${re})`).join(joinWith);\n}\n\n/** @typedef {import('highlight.js').Mode} Mode */\n/** @typedef {import('highlight.js').ModeCallback} ModeCallback */\n\n// Common regexps\nconst MATCH_NOTHING_RE = /\\b\\B/;\nconst IDENT_RE = '[a-zA-Z]\\\\w*';\nconst UNDERSCORE_IDENT_RE = '[a-zA-Z_]\\\\w*';\nconst NUMBER_RE = '\\\\b\\\\d+(\\\\.\\\\d+)?';\nconst C_NUMBER_RE = '(-?)(\\\\b0[xX][a-fA-F0-9]+|(\\\\b\\\\d+(\\\\.\\\\d*)?|\\\\.\\\\d+)([eE][-+]?\\\\d+)?)'; // 0x..., 0..., decimal, float\nconst BINARY_NUMBER_RE = '\\\\b(0b[01]+)'; // 0b...\nconst RE_STARTERS_RE = '!|!=|!==|%|%=|&|&&|&=|\\\\*|\\\\*=|\\\\+|\\\\+=|,|-|-=|/=|/|:|;|<<|<<=|<=|<|===|==|=|>>>=|>>=|>=|>>>|>>|>|\\\\?|\\\\[|\\\\{|\\\\(|\\\\^|\\\\^=|\\\\||\\\\|=|\\\\|\\\\||~';\n\n/**\n* @param { Partial<Mode> & {binary?: string | RegExp} } opts\n*/\nconst SHEBANG = (opts = {}) => {\n  const beginShebang = /^#![ ]*\\//;\n  if (opts.binary) {\n    opts.begin = concat(\n      beginShebang,\n      /.*\\b/,\n      opts.binary,\n      /\\b.*/);\n  }\n  return inherit$1({\n    scope: 'meta',\n    begin: beginShebang,\n    end: /$/,\n    relevance: 0,\n    /** @type {ModeCallback} */\n    \"on:begin\": (m, resp) => {\n      if (m.index !== 0) resp.ignoreMatch();\n    }\n  }, opts);\n};\n\n// Common modes\nconst BACKSLASH_ESCAPE = {\n  begin: '\\\\\\\\[\\\\s\\\\S]', relevance: 0\n};\nconst APOS_STRING_MODE = {\n  scope: 'string',\n  begin: '\\'',\n  end: '\\'',\n  illegal: '\\\\n',\n  contains: [BACKSLASH_ESCAPE]\n};\nconst QUOTE_STRING_MODE = {\n  scope: 'string',\n  begin: '\"',\n  end: '\"',\n  illegal: '\\\\n',\n  contains: [BACKSLASH_ESCAPE]\n};\nconst PHRASAL_WORDS_MODE = {\n  begin: /\\b(a|an|the|are|I'm|isn't|don't|doesn't|won't|but|just|should|pretty|simply|enough|gonna|going|wtf|so|such|will|you|your|they|like|more)\\b/\n};\n/**\n * Creates a comment mode\n *\n * @param {string | RegExp} begin\n * @param {string | RegExp} end\n * @param {Mode | {}} [modeOptions]\n * @returns {Partial<Mode>}\n */\nconst COMMENT = function(begin, end, modeOptions = {}) {\n  const mode = inherit$1(\n    {\n      scope: 'comment',\n      begin,\n      end,\n      contains: []\n    },\n    modeOptions\n  );\n  mode.contains.push({\n    scope: 'doctag',\n    // hack to avoid the space from being included. the space is necessary to\n    // match here to prevent the plain text rule below from gobbling up doctags\n    begin: '[ ]*(?=(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):)',\n    end: /(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):/,\n    excludeBegin: true,\n    relevance: 0\n  });\n  const ENGLISH_WORD = either(\n    // list of common 1 and 2 letter words in English\n    \"I\",\n    \"a\",\n    \"is\",\n    \"so\",\n    \"us\",\n    \"to\",\n    \"at\",\n    \"if\",\n    \"in\",\n    \"it\",\n    \"on\",\n    // note: this is not an exhaustive list of contractions, just popular ones\n    /[A-Za-z]+['](d|ve|re|ll|t|s|n)/, // contractions - can't we'd they're let's, etc\n    /[A-Za-z]+[-][a-z]+/, // `no-way`, etc.\n    /[A-Za-z][a-z]{2,}/ // allow capitalized words at beginning of sentences\n  );\n  // looking like plain text, more likely to be a comment\n  mode.contains.push(\n    {\n      // TODO: how to include \", (, ) without breaking grammars that use these for\n      // comment delimiters?\n      // begin: /[ ]+([()\"]?([A-Za-z'-]{3,}|is|a|I|so|us|[tT][oO]|at|if|in|it|on)[.]?[()\":]?([.][ ]|[ ]|\\))){3}/\n      // ---\n\n      // this tries to find sequences of 3 english words in a row (without any\n      // \"programming\" type syntax) this gives us a strong signal that we've\n      // TRULY found a comment - vs perhaps scanning with the wrong language.\n      // It's possible to find something that LOOKS like the start of the\n      // comment - but then if there is no readable text - good chance it is a\n      // false match and not a comment.\n      //\n      // for a visual example please see:\n      // https://github.com/highlightjs/highlight.js/issues/2827\n\n      begin: concat(\n        /[ ]+/, // necessary to prevent us gobbling up doctags like /* @author Bob Mcgill */\n        '(',\n        ENGLISH_WORD,\n        /[.]?[:]?([.][ ]|[ ])/,\n        '){3}') // look for 3 words in a row\n    }\n  );\n  return mode;\n};\nconst C_LINE_COMMENT_MODE = COMMENT('//', '$');\nconst C_BLOCK_COMMENT_MODE = COMMENT('/\\\\*', '\\\\*/');\nconst HASH_COMMENT_MODE = COMMENT('#', '$');\nconst NUMBER_MODE = {\n  scope: 'number',\n  begin: NUMBER_RE,\n  relevance: 0\n};\nconst C_NUMBER_MODE = {\n  scope: 'number',\n  begin: C_NUMBER_RE,\n  relevance: 0\n};\nconst BINARY_NUMBER_MODE = {\n  scope: 'number',\n  begin: BINARY_NUMBER_RE,\n  relevance: 0\n};\nconst REGEXP_MODE = {\n  // this outer rule makes sure we actually have a WHOLE regex and not simply\n  // an expression such as:\n  //\n  //     3 / something\n  //\n  // (which will then blow up when regex's `illegal` sees the newline)\n  begin: /(?=\\/[^/\\n]*\\/)/,\n  contains: [{\n    scope: 'regexp',\n    begin: /\\//,\n    end: /\\/[gimuy]*/,\n    illegal: /\\n/,\n    contains: [\n      BACKSLASH_ESCAPE,\n      {\n        begin: /\\[/,\n        end: /\\]/,\n        relevance: 0,\n        contains: [BACKSLASH_ESCAPE]\n      }\n    ]\n  }]\n};\nconst TITLE_MODE = {\n  scope: 'title',\n  begin: IDENT_RE,\n  relevance: 0\n};\nconst UNDERSCORE_TITLE_MODE = {\n  scope: 'title',\n  begin: UNDERSCORE_IDENT_RE,\n  relevance: 0\n};\nconst METHOD_GUARD = {\n  // excludes method names from keyword processing\n  begin: '\\\\.\\\\s*' + UNDERSCORE_IDENT_RE,\n  relevance: 0\n};\n\n/**\n * Adds end same as begin mechanics to a mode\n *\n * Your mode must include at least a single () match group as that first match\n * group is what is used for comparison\n * @param {Partial<Mode>} mode\n */\nconst END_SAME_AS_BEGIN = function(mode) {\n  return Object.assign(mode,\n    {\n      /** @type {ModeCallback} */\n      'on:begin': (m, resp) => { resp.data._beginMatch = m[1]; },\n      /** @type {ModeCallback} */\n      'on:end': (m, resp) => { if (resp.data._beginMatch !== m[1]) resp.ignoreMatch(); }\n    });\n};\n\nvar MODES = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    MATCH_NOTHING_RE: MATCH_NOTHING_RE,\n    IDENT_RE: IDENT_RE,\n    UNDERSCORE_IDENT_RE: UNDERSCORE_IDENT_RE,\n    NUMBER_RE: NUMBER_RE,\n    C_NUMBER_RE: C_NUMBER_RE,\n    BINARY_NUMBER_RE: BINARY_NUMBER_RE,\n    RE_STARTERS_RE: RE_STARTERS_RE,\n    SHEBANG: SHEBANG,\n    BACKSLASH_ESCAPE: BACKSLASH_ESCAPE,\n    APOS_STRING_MODE: APOS_STRING_MODE,\n    QUOTE_STRING_MODE: QUOTE_STRING_MODE,\n    PHRASAL_WORDS_MODE: PHRASAL_WORDS_MODE,\n    COMMENT: COMMENT,\n    C_LINE_COMMENT_MODE: C_LINE_COMMENT_MODE,\n    C_BLOCK_COMMENT_MODE: C_BLOCK_COMMENT_MODE,\n    HASH_COMMENT_MODE: HASH_COMMENT_MODE,\n    NUMBER_MODE: NUMBER_MODE,\n    C_NUMBER_MODE: C_NUMBER_MODE,\n    BINARY_NUMBER_MODE: BINARY_NUMBER_MODE,\n    REGEXP_MODE: REGEXP_MODE,\n    TITLE_MODE: TITLE_MODE,\n    UNDERSCORE_TITLE_MODE: UNDERSCORE_TITLE_MODE,\n    METHOD_GUARD: METHOD_GUARD,\n    END_SAME_AS_BEGIN: END_SAME_AS_BEGIN\n});\n\n/**\n@typedef {import('highlight.js').CallbackResponse} CallbackResponse\n@typedef {import('highlight.js').CompilerExt} CompilerExt\n*/\n\n// Grammar extensions / plugins\n// See: https://github.com/highlightjs/highlight.js/issues/2833\n\n// Grammar extensions allow \"syntactic sugar\" to be added to the grammar modes\n// without requiring any underlying changes to the compiler internals.\n\n// `compileMatch` being the perfect small example of now allowing a grammar\n// author to write `match` when they desire to match a single expression rather\n// than being forced to use `begin`.  The extension then just moves `match` into\n// `begin` when it runs.  Ie, no features have been added, but we've just made\n// the experience of writing (and reading grammars) a little bit nicer.\n\n// ------\n\n// TODO: We need negative look-behind support to do this properly\n/**\n * Skip a match if it has a preceding dot\n *\n * This is used for `beginKeywords` to prevent matching expressions such as\n * `bob.keyword.do()`. The mode compiler automatically wires this up as a\n * special _internal_ 'on:begin' callback for modes with `beginKeywords`\n * @param {RegExpMatchArray} match\n * @param {CallbackResponse} response\n */\nfunction skipIfHasPrecedingDot(match, response) {\n  const before = match.input[match.index - 1];\n  if (before === \".\") {\n    response.ignoreMatch();\n  }\n}\n\n/**\n *\n * @type {CompilerExt}\n */\nfunction scopeClassName(mode, _parent) {\n  // eslint-disable-next-line no-undefined\n  if (mode.className !== undefined) {\n    mode.scope = mode.className;\n    delete mode.className;\n  }\n}\n\n/**\n * `beginKeywords` syntactic sugar\n * @type {CompilerExt}\n */\nfunction beginKeywords(mode, parent) {\n  if (!parent) return;\n  if (!mode.beginKeywords) return;\n\n  // for languages with keywords that include non-word characters checking for\n  // a word boundary is not sufficient, so instead we check for a word boundary\n  // or whitespace - this does no harm in any case since our keyword engine\n  // doesn't allow spaces in keywords anyways and we still check for the boundary\n  // first\n  mode.begin = '\\\\b(' + mode.beginKeywords.split(' ').join('|') + ')(?!\\\\.)(?=\\\\b|\\\\s)';\n  mode.__beforeBegin = skipIfHasPrecedingDot;\n  mode.keywords = mode.keywords || mode.beginKeywords;\n  delete mode.beginKeywords;\n\n  // prevents double relevance, the keywords themselves provide\n  // relevance, the mode doesn't need to double it\n  // eslint-disable-next-line no-undefined\n  if (mode.relevance === undefined) mode.relevance = 0;\n}\n\n/**\n * Allow `illegal` to contain an array of illegal values\n * @type {CompilerExt}\n */\nfunction compileIllegal(mode, _parent) {\n  if (!Array.isArray(mode.illegal)) return;\n\n  mode.illegal = either(...mode.illegal);\n}\n\n/**\n * `match` to match a single expression for readability\n * @type {CompilerExt}\n */\nfunction compileMatch(mode, _parent) {\n  if (!mode.match) return;\n  if (mode.begin || mode.end) throw new Error(\"begin & end are not supported with match\");\n\n  mode.begin = mode.match;\n  delete mode.match;\n}\n\n/**\n * provides the default 1 relevance to all modes\n * @type {CompilerExt}\n */\nfunction compileRelevance(mode, _parent) {\n  // eslint-disable-next-line no-undefined\n  if (mode.relevance === undefined) mode.relevance = 1;\n}\n\n// allow beforeMatch to act as a \"qualifier\" for the match\n// the full match begin must be [beforeMatch][begin]\nconst beforeMatchExt = (mode, parent) => {\n  if (!mode.beforeMatch) return;\n  // starts conflicts with endsParent which we need to make sure the child\n  // rule is not matched multiple times\n  if (mode.starts) throw new Error(\"beforeMatch cannot be used with starts\");\n\n  const originalMode = Object.assign({}, mode);\n  Object.keys(mode).forEach((key) => { delete mode[key]; });\n\n  mode.keywords = originalMode.keywords;\n  mode.begin = concat(originalMode.beforeMatch, lookahead(originalMode.begin));\n  mode.starts = {\n    relevance: 0,\n    contains: [\n      Object.assign(originalMode, { endsParent: true })\n    ]\n  };\n  mode.relevance = 0;\n\n  delete originalMode.beforeMatch;\n};\n\n// keywords that should have no default relevance value\nconst COMMON_KEYWORDS = [\n  'of',\n  'and',\n  'for',\n  'in',\n  'not',\n  'or',\n  'if',\n  'then',\n  'parent', // common variable name\n  'list', // common variable name\n  'value' // common variable name\n];\n\nconst DEFAULT_KEYWORD_SCOPE = \"keyword\";\n\n/**\n * Given raw keywords from a language definition, compile them.\n *\n * @param {string | Record<string,string|string[]> | Array<string>} rawKeywords\n * @param {boolean} caseInsensitive\n */\nfunction compileKeywords(rawKeywords, caseInsensitive, scopeName = DEFAULT_KEYWORD_SCOPE) {\n  /** @type KeywordDict */\n  const compiledKeywords = Object.create(null);\n\n  // input can be a string of keywords, an array of keywords, or a object with\n  // named keys representing scopeName (which can then point to a string or array)\n  if (typeof rawKeywords === 'string') {\n    compileList(scopeName, rawKeywords.split(\" \"));\n  } else if (Array.isArray(rawKeywords)) {\n    compileList(scopeName, rawKeywords);\n  } else {\n    Object.keys(rawKeywords).forEach(function(scopeName) {\n      // collapse all our objects back into the parent object\n      Object.assign(\n        compiledKeywords,\n        compileKeywords(rawKeywords[scopeName], caseInsensitive, scopeName)\n      );\n    });\n  }\n  return compiledKeywords;\n\n  // ---\n\n  /**\n   * Compiles an individual list of keywords\n   *\n   * Ex: \"for if when while|5\"\n   *\n   * @param {string} scopeName\n   * @param {Array<string>} keywordList\n   */\n  function compileList(scopeName, keywordList) {\n    if (caseInsensitive) {\n      keywordList = keywordList.map(x => x.toLowerCase());\n    }\n    keywordList.forEach(function(keyword) {\n      const pair = keyword.split('|');\n      compiledKeywords[pair[0]] = [scopeName, scoreForKeyword(pair[0], pair[1])];\n    });\n  }\n}\n\n/**\n * Returns the proper score for a given keyword\n *\n * Also takes into account comment keywords, which will be scored 0 UNLESS\n * another score has been manually assigned.\n * @param {string} keyword\n * @param {string} [providedScore]\n */\nfunction scoreForKeyword(keyword, providedScore) {\n  // manual scores always win over common keywords\n  // so you can force a score of 1 if you really insist\n  if (providedScore) {\n    return Number(providedScore);\n  }\n\n  return commonKeyword(keyword) ? 0 : 1;\n}\n\n/**\n * Determines if a given keyword is common or not\n *\n * @param {string} keyword */\nfunction commonKeyword(keyword) {\n  return COMMON_KEYWORDS.includes(keyword.toLowerCase());\n}\n\n/*\n\nFor the reasoning behind this please see:\nhttps://github.com/highlightjs/highlight.js/issues/2880#issuecomment-747275419\n\n*/\n\n/**\n * @type {Record<string, boolean>}\n */\nconst seenDeprecations = {};\n\n/**\n * @param {string} message\n */\nconst error = (message) => {\n  console.error(message);\n};\n\n/**\n * @param {string} message\n * @param {any} args\n */\nconst warn = (message, ...args) => {\n  console.log(`WARN: ${message}`, ...args);\n};\n\n/**\n * @param {string} version\n * @param {string} message\n */\nconst deprecated = (version, message) => {\n  if (seenDeprecations[`${version}/${message}`]) return;\n\n  console.log(`Deprecated as of ${version}. ${message}`);\n  seenDeprecations[`${version}/${message}`] = true;\n};\n\n/* eslint-disable no-throw-literal */\n\n/**\n@typedef {import('highlight.js').CompiledMode} CompiledMode\n*/\n\nconst MultiClassError = new Error();\n\n/**\n * Renumbers labeled scope names to account for additional inner match\n * groups that otherwise would break everything.\n *\n * Lets say we 3 match scopes:\n *\n *   { 1 => ..., 2 => ..., 3 => ... }\n *\n * So what we need is a clean match like this:\n *\n *   (a)(b)(c) => [ \"a\", \"b\", \"c\" ]\n *\n * But this falls apart with inner match groups:\n *\n * (a)(((b)))(c) => [\"a\", \"b\", \"b\", \"b\", \"c\" ]\n *\n * Our scopes are now \"out of alignment\" and we're repeating `b` 3 times.\n * What needs to happen is the numbers are remapped:\n *\n *   { 1 => ..., 2 => ..., 5 => ... }\n *\n * We also need to know that the ONLY groups that should be output\n * are 1, 2, and 5.  This function handles this behavior.\n *\n * @param {CompiledMode} mode\n * @param {Array<RegExp>} regexes\n * @param {{key: \"beginScope\"|\"endScope\"}} opts\n */\nfunction remapScopeNames(mode, regexes, { key }) {\n  let offset = 0;\n  const scopeNames = mode[key];\n  /** @type Record<number,boolean> */\n  const emit = {};\n  /** @type Record<number,string> */\n  const positions = {};\n\n  for (let i = 1; i <= regexes.length; i++) {\n    positions[i + offset] = scopeNames[i];\n    emit[i + offset] = true;\n    offset += countMatchGroups(regexes[i - 1]);\n  }\n  // we use _emit to keep track of which match groups are \"top-level\" to avoid double\n  // output from inside match groups\n  mode[key] = positions;\n  mode[key]._emit = emit;\n  mode[key]._multi = true;\n}\n\n/**\n * @param {CompiledMode} mode\n */\nfunction beginMultiClass(mode) {\n  if (!Array.isArray(mode.begin)) return;\n\n  if (mode.skip || mode.excludeBegin || mode.returnBegin) {\n    error(\"skip, excludeBegin, returnBegin not compatible with beginScope: {}\");\n    throw MultiClassError;\n  }\n\n  if (typeof mode.beginScope !== \"object\" || mode.beginScope === null) {\n    error(\"beginScope must be object\");\n    throw MultiClassError;\n  }\n\n  remapScopeNames(mode, mode.begin, {key: \"beginScope\"});\n  mode.begin = _rewriteBackreferences(mode.begin, { joinWith: \"\" });\n}\n\n/**\n * @param {CompiledMode} mode\n */\nfunction endMultiClass(mode) {\n  if (!Array.isArray(mode.end)) return;\n\n  if (mode.skip || mode.excludeEnd || mode.returnEnd) {\n    error(\"skip, excludeEnd, returnEnd not compatible with endScope: {}\");\n    throw MultiClassError;\n  }\n\n  if (typeof mode.endScope !== \"object\" || mode.endScope === null) {\n    error(\"endScope must be object\");\n    throw MultiClassError;\n  }\n\n  remapScopeNames(mode, mode.end, {key: \"endScope\"});\n  mode.end = _rewriteBackreferences(mode.end, { joinWith: \"\" });\n}\n\n/**\n * this exists only to allow `scope: {}` to be used beside `match:`\n * Otherwise `beginScope` would necessary and that would look weird\n\n  {\n    match: [ /def/, /\\w+/ ]\n    scope: { 1: \"keyword\" , 2: \"title\" }\n  }\n\n * @param {CompiledMode} mode\n */\nfunction scopeSugar(mode) {\n  if (mode.scope && typeof mode.scope === \"object\" && mode.scope !== null) {\n    mode.beginScope = mode.scope;\n    delete mode.scope;\n  }\n}\n\n/**\n * @param {CompiledMode} mode\n */\nfunction MultiClass(mode) {\n  scopeSugar(mode);\n\n  if (typeof mode.beginScope === \"string\") {\n    mode.beginScope = { _wrap: mode.beginScope };\n  }\n  if (typeof mode.endScope === \"string\") {\n    mode.endScope = { _wrap: mode.endScope };\n  }\n\n  beginMultiClass(mode);\n  endMultiClass(mode);\n}\n\n/**\n@typedef {import('highlight.js').Mode} Mode\n@typedef {import('highlight.js').CompiledMode} CompiledMode\n@typedef {import('highlight.js').Language} Language\n@typedef {import('highlight.js').HLJSPlugin} HLJSPlugin\n@typedef {import('highlight.js').CompiledLanguage} CompiledLanguage\n*/\n\n// compilation\n\n/**\n * Compiles a language definition result\n *\n * Given the raw result of a language definition (Language), compiles this so\n * that it is ready for highlighting code.\n * @param {Language} language\n * @returns {CompiledLanguage}\n */\nfunction compileLanguage(language) {\n  /**\n   * Builds a regex with the case sensitivity of the current language\n   *\n   * @param {RegExp | string} value\n   * @param {boolean} [global]\n   */\n  function langRe(value, global) {\n    return new RegExp(\n      source(value),\n      'm' + (language.case_insensitive ? 'i' : '') + (global ? 'g' : '')\n    );\n  }\n\n  /**\n    Stores multiple regular expressions and allows you to quickly search for\n    them all in a string simultaneously - returning the first match.  It does\n    this by creating a huge (a|b|c) regex - each individual item wrapped with ()\n    and joined by `|` - using match groups to track position.  When a match is\n    found checking which position in the array has content allows us to figure\n    out which of the original regexes / match groups triggered the match.\n\n    The match object itself (the result of `Regex.exec`) is returned but also\n    enhanced by merging in any meta-data that was registered with the regex.\n    This is how we keep track of which mode matched, and what type of rule\n    (`illegal`, `begin`, end, etc).\n  */\n  class MultiRegex {\n    constructor() {\n      this.matchIndexes = {};\n      // @ts-ignore\n      this.regexes = [];\n      this.matchAt = 1;\n      this.position = 0;\n    }\n\n    // @ts-ignore\n    addRule(re, opts) {\n      opts.position = this.position++;\n      // @ts-ignore\n      this.matchIndexes[this.matchAt] = opts;\n      this.regexes.push([opts, re]);\n      this.matchAt += countMatchGroups(re) + 1;\n    }\n\n    compile() {\n      if (this.regexes.length === 0) {\n        // avoids the need to check length every time exec is called\n        // @ts-ignore\n        this.exec = () => null;\n      }\n      const terminators = this.regexes.map(el => el[1]);\n      this.matcherRe = langRe(_rewriteBackreferences(terminators, { joinWith: '|' }), true);\n      this.lastIndex = 0;\n    }\n\n    /** @param {string} s */\n    exec(s) {\n      this.matcherRe.lastIndex = this.lastIndex;\n      const match = this.matcherRe.exec(s);\n      if (!match) { return null; }\n\n      // eslint-disable-next-line no-undefined\n      const i = match.findIndex((el, i) => i > 0 && el !== undefined);\n      // @ts-ignore\n      const matchData = this.matchIndexes[i];\n      // trim off any earlier non-relevant match groups (ie, the other regex\n      // match groups that make up the multi-matcher)\n      match.splice(0, i);\n\n      return Object.assign(match, matchData);\n    }\n  }\n\n  /*\n    Created to solve the key deficiently with MultiRegex - there is no way to\n    test for multiple matches at a single location.  Why would we need to do\n    that?  In the future a more dynamic engine will allow certain matches to be\n    ignored.  An example: if we matched say the 3rd regex in a large group but\n    decided to ignore it - we'd need to started testing again at the 4th\n    regex... but MultiRegex itself gives us no real way to do that.\n\n    So what this class creates MultiRegexs on the fly for whatever search\n    position they are needed.\n\n    NOTE: These additional MultiRegex objects are created dynamically.  For most\n    grammars most of the time we will never actually need anything more than the\n    first MultiRegex - so this shouldn't have too much overhead.\n\n    Say this is our search group, and we match regex3, but wish to ignore it.\n\n      regex1 | regex2 | regex3 | regex4 | regex5    ' ie, startAt = 0\n\n    What we need is a new MultiRegex that only includes the remaining\n    possibilities:\n\n      regex4 | regex5                               ' ie, startAt = 3\n\n    This class wraps all that complexity up in a simple API... `startAt` decides\n    where in the array of expressions to start doing the matching. It\n    auto-increments, so if a match is found at position 2, then startAt will be\n    set to 3.  If the end is reached startAt will return to 0.\n\n    MOST of the time the parser will be setting startAt manually to 0.\n  */\n  class ResumableMultiRegex {\n    constructor() {\n      // @ts-ignore\n      this.rules = [];\n      // @ts-ignore\n      this.multiRegexes = [];\n      this.count = 0;\n\n      this.lastIndex = 0;\n      this.regexIndex = 0;\n    }\n\n    // @ts-ignore\n    getMatcher(index) {\n      if (this.multiRegexes[index]) return this.multiRegexes[index];\n\n      const matcher = new MultiRegex();\n      this.rules.slice(index).forEach(([re, opts]) => matcher.addRule(re, opts));\n      matcher.compile();\n      this.multiRegexes[index] = matcher;\n      return matcher;\n    }\n\n    resumingScanAtSamePosition() {\n      return this.regexIndex !== 0;\n    }\n\n    considerAll() {\n      this.regexIndex = 0;\n    }\n\n    // @ts-ignore\n    addRule(re, opts) {\n      this.rules.push([re, opts]);\n      if (opts.type === \"begin\") this.count++;\n    }\n\n    /** @param {string} s */\n    exec(s) {\n      const m = this.getMatcher(this.regexIndex);\n      m.lastIndex = this.lastIndex;\n      let result = m.exec(s);\n\n      // The following is because we have no easy way to say \"resume scanning at the\n      // existing position but also skip the current rule ONLY\". What happens is\n      // all prior rules are also skipped which can result in matching the wrong\n      // thing. Example of matching \"booger\":\n\n      // our matcher is [string, \"booger\", number]\n      //\n      // ....booger....\n\n      // if \"booger\" is ignored then we'd really need a regex to scan from the\n      // SAME position for only: [string, number] but ignoring \"booger\" (if it\n      // was the first match), a simple resume would scan ahead who knows how\n      // far looking only for \"number\", ignoring potential string matches (or\n      // future \"booger\" matches that might be valid.)\n\n      // So what we do: We execute two matchers, one resuming at the same\n      // position, but the second full matcher starting at the position after:\n\n      //     /--- resume first regex match here (for [number])\n      //     |/---- full match here for [string, \"booger\", number]\n      //     vv\n      // ....booger....\n\n      // Which ever results in a match first is then used. So this 3-4 step\n      // process essentially allows us to say \"match at this position, excluding\n      // a prior rule that was ignored\".\n      //\n      // 1. Match \"booger\" first, ignore. Also proves that [string] does non match.\n      // 2. Resume matching for [number]\n      // 3. Match at index + 1 for [string, \"booger\", number]\n      // 4. If #2 and #3 result in matches, which came first?\n      if (this.resumingScanAtSamePosition()) {\n        if (result && result.index === this.lastIndex) ; else { // use the second matcher result\n          const m2 = this.getMatcher(0);\n          m2.lastIndex = this.lastIndex + 1;\n          result = m2.exec(s);\n        }\n      }\n\n      if (result) {\n        this.regexIndex += result.position + 1;\n        if (this.regexIndex === this.count) {\n          // wrap-around to considering all matches again\n          this.considerAll();\n        }\n      }\n\n      return result;\n    }\n  }\n\n  /**\n   * Given a mode, builds a huge ResumableMultiRegex that can be used to walk\n   * the content and find matches.\n   *\n   * @param {CompiledMode} mode\n   * @returns {ResumableMultiRegex}\n   */\n  function buildModeRegex(mode) {\n    const mm = new ResumableMultiRegex();\n\n    mode.contains.forEach(term => mm.addRule(term.begin, { rule: term, type: \"begin\" }));\n\n    if (mode.terminatorEnd) {\n      mm.addRule(mode.terminatorEnd, { type: \"end\" });\n    }\n    if (mode.illegal) {\n      mm.addRule(mode.illegal, { type: \"illegal\" });\n    }\n\n    return mm;\n  }\n\n  /** skip vs abort vs ignore\n   *\n   * @skip   - The mode is still entered and exited normally (and contains rules apply),\n   *           but all content is held and added to the parent buffer rather than being\n   *           output when the mode ends.  Mostly used with `sublanguage` to build up\n   *           a single large buffer than can be parsed by sublanguage.\n   *\n   *             - The mode begin ands ends normally.\n   *             - Content matched is added to the parent mode buffer.\n   *             - The parser cursor is moved forward normally.\n   *\n   * @abort  - A hack placeholder until we have ignore.  Aborts the mode (as if it\n   *           never matched) but DOES NOT continue to match subsequent `contains`\n   *           modes.  Abort is bad/suboptimal because it can result in modes\n   *           farther down not getting applied because an earlier rule eats the\n   *           content but then aborts.\n   *\n   *             - The mode does not begin.\n   *             - Content matched by `begin` is added to the mode buffer.\n   *             - The parser cursor is moved forward accordingly.\n   *\n   * @ignore - Ignores the mode (as if it never matched) and continues to match any\n   *           subsequent `contains` modes.  Ignore isn't technically possible with\n   *           the current parser implementation.\n   *\n   *             - The mode does not begin.\n   *             - Content matched by `begin` is ignored.\n   *             - The parser cursor is not moved forward.\n   */\n\n  /**\n   * Compiles an individual mode\n   *\n   * This can raise an error if the mode contains certain detectable known logic\n   * issues.\n   * @param {Mode} mode\n   * @param {CompiledMode | null} [parent]\n   * @returns {CompiledMode | never}\n   */\n  function compileMode(mode, parent) {\n    const cmode = /** @type CompiledMode */ (mode);\n    if (mode.isCompiled) return cmode;\n\n    [\n      scopeClassName,\n      // do this early so compiler extensions generally don't have to worry about\n      // the distinction between match/begin\n      compileMatch,\n      MultiClass,\n      beforeMatchExt\n    ].forEach(ext => ext(mode, parent));\n\n    language.compilerExtensions.forEach(ext => ext(mode, parent));\n\n    // __beforeBegin is considered private API, internal use only\n    mode.__beforeBegin = null;\n\n    [\n      beginKeywords,\n      // do this later so compiler extensions that come earlier have access to the\n      // raw array if they wanted to perhaps manipulate it, etc.\n      compileIllegal,\n      // default to 1 relevance if not specified\n      compileRelevance\n    ].forEach(ext => ext(mode, parent));\n\n    mode.isCompiled = true;\n\n    let keywordPattern = null;\n    if (typeof mode.keywords === \"object\" && mode.keywords.$pattern) {\n      // we need a copy because keywords might be compiled multiple times\n      // so we can't go deleting $pattern from the original on the first\n      // pass\n      mode.keywords = Object.assign({}, mode.keywords);\n      keywordPattern = mode.keywords.$pattern;\n      delete mode.keywords.$pattern;\n    }\n    keywordPattern = keywordPattern || /\\w+/;\n\n    if (mode.keywords) {\n      mode.keywords = compileKeywords(mode.keywords, language.case_insensitive);\n    }\n\n    cmode.keywordPatternRe = langRe(keywordPattern, true);\n\n    if (parent) {\n      if (!mode.begin) mode.begin = /\\B|\\b/;\n      cmode.beginRe = langRe(mode.begin);\n      if (!mode.end && !mode.endsWithParent) mode.end = /\\B|\\b/;\n      if (mode.end) cmode.endRe = langRe(mode.end);\n      cmode.terminatorEnd = source(mode.end) || '';\n      if (mode.endsWithParent && parent.terminatorEnd) {\n        cmode.terminatorEnd += (mode.end ? '|' : '') + parent.terminatorEnd;\n      }\n    }\n    if (mode.illegal) cmode.illegalRe = langRe(/** @type {RegExp | string} */ (mode.illegal));\n    if (!mode.contains) mode.contains = [];\n\n    mode.contains = [].concat(...mode.contains.map(function(c) {\n      return expandOrCloneMode(c === 'self' ? mode : c);\n    }));\n    mode.contains.forEach(function(c) { compileMode(/** @type Mode */ (c), cmode); });\n\n    if (mode.starts) {\n      compileMode(mode.starts, parent);\n    }\n\n    cmode.matcher = buildModeRegex(cmode);\n    return cmode;\n  }\n\n  if (!language.compilerExtensions) language.compilerExtensions = [];\n\n  // self is not valid at the top-level\n  if (language.contains && language.contains.includes('self')) {\n    throw new Error(\"ERR: contains `self` is not supported at the top-level of a language.  See documentation.\");\n  }\n\n  // we need a null object, which inherit will guarantee\n  language.classNameAliases = inherit$1(language.classNameAliases || {});\n\n  return compileMode(/** @type Mode */ (language));\n}\n\n/**\n * Determines if a mode has a dependency on it's parent or not\n *\n * If a mode does have a parent dependency then often we need to clone it if\n * it's used in multiple places so that each copy points to the correct parent,\n * where-as modes without a parent can often safely be re-used at the bottom of\n * a mode chain.\n *\n * @param {Mode | null} mode\n * @returns {boolean} - is there a dependency on the parent?\n * */\nfunction dependencyOnParent(mode) {\n  if (!mode) return false;\n\n  return mode.endsWithParent || dependencyOnParent(mode.starts);\n}\n\n/**\n * Expands a mode or clones it if necessary\n *\n * This is necessary for modes with parental dependenceis (see notes on\n * `dependencyOnParent`) and for nodes that have `variants` - which must then be\n * exploded into their own individual modes at compile time.\n *\n * @param {Mode} mode\n * @returns {Mode | Mode[]}\n * */\nfunction expandOrCloneMode(mode) {\n  if (mode.variants && !mode.cachedVariants) {\n    mode.cachedVariants = mode.variants.map(function(variant) {\n      return inherit$1(mode, { variants: null }, variant);\n    });\n  }\n\n  // EXPAND\n  // if we have variants then essentially \"replace\" the mode with the variants\n  // this happens in compileMode, where this function is called from\n  if (mode.cachedVariants) {\n    return mode.cachedVariants;\n  }\n\n  // CLONE\n  // if we have dependencies on parents then we need a unique\n  // instance of ourselves, so we can be reused with many\n  // different parents without issue\n  if (dependencyOnParent(mode)) {\n    return inherit$1(mode, { starts: mode.starts ? inherit$1(mode.starts) : null });\n  }\n\n  if (Object.isFrozen(mode)) {\n    return inherit$1(mode);\n  }\n\n  // no special dependency issues, just return ourselves\n  return mode;\n}\n\nvar version = \"11.2.0\";\n\n/*\nSyntax highlighting with language autodetection.\nhttps://highlightjs.org/\n*/\n\n/**\n@typedef {import('highlight.js').Mode} Mode\n@typedef {import('highlight.js').CompiledMode} CompiledMode\n@typedef {import('highlight.js').Language} Language\n@typedef {import('highlight.js').HLJSApi} HLJSApi\n@typedef {import('highlight.js').HLJSPlugin} HLJSPlugin\n@typedef {import('highlight.js').PluginEvent} PluginEvent\n@typedef {import('highlight.js').HLJSOptions} HLJSOptions\n@typedef {import('highlight.js').LanguageFn} LanguageFn\n@typedef {import('highlight.js').HighlightedHTMLElement} HighlightedHTMLElement\n@typedef {import('highlight.js').BeforeHighlightContext} BeforeHighlightContext\n@typedef {import('highlight.js/private').MatchType} MatchType\n@typedef {import('highlight.js/private').KeywordData} KeywordData\n@typedef {import('highlight.js/private').EnhancedMatch} EnhancedMatch\n@typedef {import('highlight.js/private').AnnotatedError} AnnotatedError\n@typedef {import('highlight.js').AutoHighlightResult} AutoHighlightResult\n@typedef {import('highlight.js').HighlightOptions} HighlightOptions\n@typedef {import('highlight.js').HighlightResult} HighlightResult\n*/\n\n\nconst escape = escapeHTML;\nconst inherit = inherit$1;\nconst NO_MATCH = Symbol(\"nomatch\");\nconst MAX_KEYWORD_HITS = 7;\n\n/**\n * @param {any} hljs - object that is extended (legacy)\n * @returns {HLJSApi}\n */\nconst HLJS = function(hljs) {\n  // Global internal variables used within the highlight.js library.\n  /** @type {Record<string, Language>} */\n  const languages = Object.create(null);\n  /** @type {Record<string, string>} */\n  const aliases = Object.create(null);\n  /** @type {HLJSPlugin[]} */\n  const plugins = [];\n\n  // safe/production mode - swallows more errors, tries to keep running\n  // even if a single syntax or parse hits a fatal error\n  let SAFE_MODE = true;\n  const LANGUAGE_NOT_FOUND = \"Could not find the language '{}', did you forget to load/include a language module?\";\n  /** @type {Language} */\n  const PLAINTEXT_LANGUAGE = { disableAutodetect: true, name: 'Plain text', contains: [] };\n\n  // Global options used when within external APIs. This is modified when\n  // calling the `hljs.configure` function.\n  /** @type HLJSOptions */\n  let options = {\n    ignoreUnescapedHTML: false,\n    noHighlightRe: /^(no-?highlight)$/i,\n    languageDetectRe: /\\blang(?:uage)?-([\\w-]+)\\b/i,\n    classPrefix: 'hljs-',\n    cssSelector: 'pre code',\n    languages: null,\n    // beta configuration options, subject to change, welcome to discuss\n    // https://github.com/highlightjs/highlight.js/issues/1086\n    __emitter: TokenTreeEmitter\n  };\n\n  /* Utility functions */\n\n  /**\n   * Tests a language name to see if highlighting should be skipped\n   * @param {string} languageName\n   */\n  function shouldNotHighlight(languageName) {\n    return options.noHighlightRe.test(languageName);\n  }\n\n  /**\n   * @param {HighlightedHTMLElement} block - the HTML element to determine language for\n   */\n  function blockLanguage(block) {\n    let classes = block.className + ' ';\n\n    classes += block.parentNode ? block.parentNode.className : '';\n\n    // language-* takes precedence over non-prefixed class names.\n    const match = options.languageDetectRe.exec(classes);\n    if (match) {\n      const language = getLanguage(match[1]);\n      if (!language) {\n        warn(LANGUAGE_NOT_FOUND.replace(\"{}\", match[1]));\n        warn(\"Falling back to no-highlight mode for this block.\", block);\n      }\n      return language ? match[1] : 'no-highlight';\n    }\n\n    return classes\n      .split(/\\s+/)\n      .find((_class) => shouldNotHighlight(_class) || getLanguage(_class));\n  }\n\n  /**\n   * Core highlighting function.\n   *\n   * OLD API\n   * highlight(lang, code, ignoreIllegals, continuation)\n   *\n   * NEW API\n   * highlight(code, {lang, ignoreIllegals})\n   *\n   * @param {string} codeOrLanguageName - the language to use for highlighting\n   * @param {string | HighlightOptions} optionsOrCode - the code to highlight\n   * @param {boolean} [ignoreIllegals] - whether to ignore illegal matches, default is to bail\n   *\n   * @returns {HighlightResult} Result - an object that represents the result\n   * @property {string} language - the language name\n   * @property {number} relevance - the relevance score\n   * @property {string} value - the highlighted HTML code\n   * @property {string} code - the original raw code\n   * @property {CompiledMode} top - top of the current mode stack\n   * @property {boolean} illegal - indicates whether any illegal matches were found\n  */\n  function highlight(codeOrLanguageName, optionsOrCode, ignoreIllegals) {\n    let code = \"\";\n    let languageName = \"\";\n    if (typeof optionsOrCode === \"object\") {\n      code = codeOrLanguageName;\n      ignoreIllegals = optionsOrCode.ignoreIllegals;\n      languageName = optionsOrCode.language;\n    } else {\n      // old API\n      deprecated(\"10.7.0\", \"highlight(lang, code, ...args) has been deprecated.\");\n      deprecated(\"10.7.0\", \"Please use highlight(code, options) instead.\\nhttps://github.com/highlightjs/highlight.js/issues/2277\");\n      languageName = codeOrLanguageName;\n      code = optionsOrCode;\n    }\n\n    // https://github.com/highlightjs/highlight.js/issues/3149\n    // eslint-disable-next-line no-undefined\n    if (ignoreIllegals === undefined) { ignoreIllegals = true; }\n\n    /** @type {BeforeHighlightContext} */\n    const context = {\n      code,\n      language: languageName\n    };\n    // the plugin can change the desired language or the code to be highlighted\n    // just be changing the object it was passed\n    fire(\"before:highlight\", context);\n\n    // a before plugin can usurp the result completely by providing it's own\n    // in which case we don't even need to call highlight\n    const result = context.result\n      ? context.result\n      : _highlight(context.language, context.code, ignoreIllegals);\n\n    result.code = context.code;\n    // the plugin can change anything in result to suite it\n    fire(\"after:highlight\", result);\n\n    return result;\n  }\n\n  /**\n   * private highlight that's used internally and does not fire callbacks\n   *\n   * @param {string} languageName - the language to use for highlighting\n   * @param {string} codeToHighlight - the code to highlight\n   * @param {boolean?} [ignoreIllegals] - whether to ignore illegal matches, default is to bail\n   * @param {CompiledMode?} [continuation] - current continuation mode, if any\n   * @returns {HighlightResult} - result of the highlight operation\n  */\n  function _highlight(languageName, codeToHighlight, ignoreIllegals, continuation) {\n    const keywordHits = Object.create(null);\n\n    /**\n     * Return keyword data if a match is a keyword\n     * @param {CompiledMode} mode - current mode\n     * @param {string} matchText - the textual match\n     * @returns {KeywordData | false}\n     */\n    function keywordData(mode, matchText) {\n      return mode.keywords[matchText];\n    }\n\n    function processKeywords() {\n      if (!top.keywords) {\n        emitter.addText(modeBuffer);\n        return;\n      }\n\n      let lastIndex = 0;\n      top.keywordPatternRe.lastIndex = 0;\n      let match = top.keywordPatternRe.exec(modeBuffer);\n      let buf = \"\";\n\n      while (match) {\n        buf += modeBuffer.substring(lastIndex, match.index);\n        const word = language.case_insensitive ? match[0].toLowerCase() : match[0];\n        const data = keywordData(top, word);\n        if (data) {\n          const [kind, keywordRelevance] = data;\n          emitter.addText(buf);\n          buf = \"\";\n\n          keywordHits[word] = (keywordHits[word] || 0) + 1;\n          if (keywordHits[word] <= MAX_KEYWORD_HITS) relevance += keywordRelevance;\n          if (kind.startsWith(\"_\")) {\n            // _ implied for relevance only, do not highlight\n            // by applying a class name\n            buf += match[0];\n          } else {\n            const cssClass = language.classNameAliases[kind] || kind;\n            emitter.addKeyword(match[0], cssClass);\n          }\n        } else {\n          buf += match[0];\n        }\n        lastIndex = top.keywordPatternRe.lastIndex;\n        match = top.keywordPatternRe.exec(modeBuffer);\n      }\n      buf += modeBuffer.substr(lastIndex);\n      emitter.addText(buf);\n    }\n\n    function processSubLanguage() {\n      if (modeBuffer === \"\") return;\n      /** @type HighlightResult */\n      let result = null;\n\n      if (typeof top.subLanguage === 'string') {\n        if (!languages[top.subLanguage]) {\n          emitter.addText(modeBuffer);\n          return;\n        }\n        result = _highlight(top.subLanguage, modeBuffer, true, continuations[top.subLanguage]);\n        continuations[top.subLanguage] = /** @type {CompiledMode} */ (result._top);\n      } else {\n        result = highlightAuto(modeBuffer, top.subLanguage.length ? top.subLanguage : null);\n      }\n\n      // Counting embedded language score towards the host language may be disabled\n      // with zeroing the containing mode relevance. Use case in point is Markdown that\n      // allows XML everywhere and makes every XML snippet to have a much larger Markdown\n      // score.\n      if (top.relevance > 0) {\n        relevance += result.relevance;\n      }\n      emitter.addSublanguage(result._emitter, result.language);\n    }\n\n    function processBuffer() {\n      if (top.subLanguage != null) {\n        processSubLanguage();\n      } else {\n        processKeywords();\n      }\n      modeBuffer = '';\n    }\n\n    /**\n     * @param {CompiledMode} mode\n     * @param {RegExpMatchArray} match\n     */\n    function emitMultiClass(scope, match) {\n      let i = 1;\n      // eslint-disable-next-line no-undefined\n      while (match[i] !== undefined) {\n        if (!scope._emit[i]) { i++; continue; }\n        const klass = language.classNameAliases[scope[i]] || scope[i];\n        const text = match[i];\n        if (klass) {\n          emitter.addKeyword(text, klass);\n        } else {\n          modeBuffer = text;\n          processKeywords();\n          modeBuffer = \"\";\n        }\n        i++;\n      }\n    }\n\n    /**\n     * @param {CompiledMode} mode - new mode to start\n     * @param {RegExpMatchArray} match\n     */\n    function startNewMode(mode, match) {\n      if (mode.scope && typeof mode.scope === \"string\") {\n        emitter.openNode(language.classNameAliases[mode.scope] || mode.scope);\n      }\n      if (mode.beginScope) {\n        // beginScope just wraps the begin match itself in a scope\n        if (mode.beginScope._wrap) {\n          emitter.addKeyword(modeBuffer, language.classNameAliases[mode.beginScope._wrap] || mode.beginScope._wrap);\n          modeBuffer = \"\";\n        } else if (mode.beginScope._multi) {\n          // at this point modeBuffer should just be the match\n          emitMultiClass(mode.beginScope, match);\n          modeBuffer = \"\";\n        }\n      }\n\n      top = Object.create(mode, { parent: { value: top } });\n      return top;\n    }\n\n    /**\n     * @param {CompiledMode } mode - the mode to potentially end\n     * @param {RegExpMatchArray} match - the latest match\n     * @param {string} matchPlusRemainder - match plus remainder of content\n     * @returns {CompiledMode | void} - the next mode, or if void continue on in current mode\n     */\n    function endOfMode(mode, match, matchPlusRemainder) {\n      let matched = startsWith(mode.endRe, matchPlusRemainder);\n\n      if (matched) {\n        if (mode[\"on:end\"]) {\n          const resp = new Response(mode);\n          mode[\"on:end\"](match, resp);\n          if (resp.isMatchIgnored) matched = false;\n        }\n\n        if (matched) {\n          while (mode.endsParent && mode.parent) {\n            mode = mode.parent;\n          }\n          return mode;\n        }\n      }\n      // even if on:end fires an `ignore` it's still possible\n      // that we might trigger the end node because of a parent mode\n      if (mode.endsWithParent) {\n        return endOfMode(mode.parent, match, matchPlusRemainder);\n      }\n    }\n\n    /**\n     * Handle matching but then ignoring a sequence of text\n     *\n     * @param {string} lexeme - string containing full match text\n     */\n    function doIgnore(lexeme) {\n      if (top.matcher.regexIndex === 0) {\n        // no more regexes to potentially match here, so we move the cursor forward one\n        // space\n        modeBuffer += lexeme[0];\n        return 1;\n      } else {\n        // no need to move the cursor, we still have additional regexes to try and\n        // match at this very spot\n        resumeScanAtSamePosition = true;\n        return 0;\n      }\n    }\n\n    /**\n     * Handle the start of a new potential mode match\n     *\n     * @param {EnhancedMatch} match - the current match\n     * @returns {number} how far to advance the parse cursor\n     */\n    function doBeginMatch(match) {\n      const lexeme = match[0];\n      const newMode = match.rule;\n\n      const resp = new Response(newMode);\n      // first internal before callbacks, then the public ones\n      const beforeCallbacks = [newMode.__beforeBegin, newMode[\"on:begin\"]];\n      for (const cb of beforeCallbacks) {\n        if (!cb) continue;\n        cb(match, resp);\n        if (resp.isMatchIgnored) return doIgnore(lexeme);\n      }\n\n      if (newMode.skip) {\n        modeBuffer += lexeme;\n      } else {\n        if (newMode.excludeBegin) {\n          modeBuffer += lexeme;\n        }\n        processBuffer();\n        if (!newMode.returnBegin && !newMode.excludeBegin) {\n          modeBuffer = lexeme;\n        }\n      }\n      startNewMode(newMode, match);\n      return newMode.returnBegin ? 0 : lexeme.length;\n    }\n\n    /**\n     * Handle the potential end of mode\n     *\n     * @param {RegExpMatchArray} match - the current match\n     */\n    function doEndMatch(match) {\n      const lexeme = match[0];\n      const matchPlusRemainder = codeToHighlight.substr(match.index);\n\n      const endMode = endOfMode(top, match, matchPlusRemainder);\n      if (!endMode) { return NO_MATCH; }\n\n      const origin = top;\n      if (top.endScope && top.endScope._wrap) {\n        processBuffer();\n        emitter.addKeyword(lexeme, top.endScope._wrap);\n      } else if (top.endScope && top.endScope._multi) {\n        processBuffer();\n        emitMultiClass(top.endScope, match);\n      } else if (origin.skip) {\n        modeBuffer += lexeme;\n      } else {\n        if (!(origin.returnEnd || origin.excludeEnd)) {\n          modeBuffer += lexeme;\n        }\n        processBuffer();\n        if (origin.excludeEnd) {\n          modeBuffer = lexeme;\n        }\n      }\n      do {\n        if (top.scope) {\n          emitter.closeNode();\n        }\n        if (!top.skip && !top.subLanguage) {\n          relevance += top.relevance;\n        }\n        top = top.parent;\n      } while (top !== endMode.parent);\n      if (endMode.starts) {\n        startNewMode(endMode.starts, match);\n      }\n      return origin.returnEnd ? 0 : lexeme.length;\n    }\n\n    function processContinuations() {\n      const list = [];\n      for (let current = top; current !== language; current = current.parent) {\n        if (current.scope) {\n          list.unshift(current.scope);\n        }\n      }\n      list.forEach(item => emitter.openNode(item));\n    }\n\n    /** @type {{type?: MatchType, index?: number, rule?: Mode}}} */\n    let lastMatch = {};\n\n    /**\n     *  Process an individual match\n     *\n     * @param {string} textBeforeMatch - text preceding the match (since the last match)\n     * @param {EnhancedMatch} [match] - the match itself\n     */\n    function processLexeme(textBeforeMatch, match) {\n      const lexeme = match && match[0];\n\n      // add non-matched text to the current mode buffer\n      modeBuffer += textBeforeMatch;\n\n      if (lexeme == null) {\n        processBuffer();\n        return 0;\n      }\n\n      // we've found a 0 width match and we're stuck, so we need to advance\n      // this happens when we have badly behaved rules that have optional matchers to the degree that\n      // sometimes they can end up matching nothing at all\n      // Ref: https://github.com/highlightjs/highlight.js/issues/2140\n      if (lastMatch.type === \"begin\" && match.type === \"end\" && lastMatch.index === match.index && lexeme === \"\") {\n        // spit the \"skipped\" character that our regex choked on back into the output sequence\n        modeBuffer += codeToHighlight.slice(match.index, match.index + 1);\n        if (!SAFE_MODE) {\n          /** @type {AnnotatedError} */\n          const err = new Error(`0 width match regex (${languageName})`);\n          err.languageName = languageName;\n          err.badRule = lastMatch.rule;\n          throw err;\n        }\n        return 1;\n      }\n      lastMatch = match;\n\n      if (match.type === \"begin\") {\n        return doBeginMatch(match);\n      } else if (match.type === \"illegal\" && !ignoreIllegals) {\n        // illegal match, we do not continue processing\n        /** @type {AnnotatedError} */\n        const err = new Error('Illegal lexeme \"' + lexeme + '\" for mode \"' + (top.scope || '<unnamed>') + '\"');\n        err.mode = top;\n        throw err;\n      } else if (match.type === \"end\") {\n        const processed = doEndMatch(match);\n        if (processed !== NO_MATCH) {\n          return processed;\n        }\n      }\n\n      // edge case for when illegal matches $ (end of line) which is technically\n      // a 0 width match but not a begin/end match so it's not caught by the\n      // first handler (when ignoreIllegals is true)\n      if (match.type === \"illegal\" && lexeme === \"\") {\n        // advance so we aren't stuck in an infinite loop\n        return 1;\n      }\n\n      // infinite loops are BAD, this is a last ditch catch all. if we have a\n      // decent number of iterations yet our index (cursor position in our\n      // parsing) still 3x behind our index then something is very wrong\n      // so we bail\n      if (iterations > 100000 && iterations > match.index * 3) {\n        const err = new Error('potential infinite loop, way more iterations than matches');\n        throw err;\n      }\n\n      /*\n      Why might be find ourselves here?  An potential end match that was\n      triggered but could not be completed.  IE, `doEndMatch` returned NO_MATCH.\n      (this could be because a callback requests the match be ignored, etc)\n\n      This causes no real harm other than stopping a few times too many.\n      */\n\n      modeBuffer += lexeme;\n      return lexeme.length;\n    }\n\n    const language = getLanguage(languageName);\n    if (!language) {\n      error(LANGUAGE_NOT_FOUND.replace(\"{}\", languageName));\n      throw new Error('Unknown language: \"' + languageName + '\"');\n    }\n\n    const md = compileLanguage(language);\n    let result = '';\n    /** @type {CompiledMode} */\n    let top = continuation || md;\n    /** @type Record<string,CompiledMode> */\n    const continuations = {}; // keep continuations for sub-languages\n    const emitter = new options.__emitter(options);\n    processContinuations();\n    let modeBuffer = '';\n    let relevance = 0;\n    let index = 0;\n    let iterations = 0;\n    let resumeScanAtSamePosition = false;\n\n    try {\n      top.matcher.considerAll();\n\n      for (;;) {\n        iterations++;\n        if (resumeScanAtSamePosition) {\n          // only regexes not matched previously will now be\n          // considered for a potential match\n          resumeScanAtSamePosition = false;\n        } else {\n          top.matcher.considerAll();\n        }\n        top.matcher.lastIndex = index;\n\n        const match = top.matcher.exec(codeToHighlight);\n        // console.log(\"match\", match[0], match.rule && match.rule.begin)\n\n        if (!match) break;\n\n        const beforeMatch = codeToHighlight.substring(index, match.index);\n        const processedCount = processLexeme(beforeMatch, match);\n        index = match.index + processedCount;\n      }\n      processLexeme(codeToHighlight.substr(index));\n      emitter.closeAllNodes();\n      emitter.finalize();\n      result = emitter.toHTML();\n\n      return {\n        language: languageName,\n        value: result,\n        relevance: relevance,\n        illegal: false,\n        _emitter: emitter,\n        _top: top\n      };\n    } catch (err) {\n      if (err.message && err.message.includes('Illegal')) {\n        return {\n          language: languageName,\n          value: escape(codeToHighlight),\n          illegal: true,\n          relevance: 0,\n          _illegalBy: {\n            message: err.message,\n            index: index,\n            context: codeToHighlight.slice(index - 100, index + 100),\n            mode: err.mode,\n            resultSoFar: result\n          },\n          _emitter: emitter\n        };\n      } else if (SAFE_MODE) {\n        return {\n          language: languageName,\n          value: escape(codeToHighlight),\n          illegal: false,\n          relevance: 0,\n          errorRaised: err,\n          _emitter: emitter,\n          _top: top\n        };\n      } else {\n        throw err;\n      }\n    }\n  }\n\n  /**\n   * returns a valid highlight result, without actually doing any actual work,\n   * auto highlight starts with this and it's possible for small snippets that\n   * auto-detection may not find a better match\n   * @param {string} code\n   * @returns {HighlightResult}\n   */\n  function justTextHighlightResult(code) {\n    const result = {\n      value: escape(code),\n      illegal: false,\n      relevance: 0,\n      _top: PLAINTEXT_LANGUAGE,\n      _emitter: new options.__emitter(options)\n    };\n    result._emitter.addText(code);\n    return result;\n  }\n\n  /**\n  Highlighting with language detection. Accepts a string with the code to\n  highlight. Returns an object with the following properties:\n\n  - language (detected language)\n  - relevance (int)\n  - value (an HTML string with highlighting markup)\n  - secondBest (object with the same structure for second-best heuristically\n    detected language, may be absent)\n\n    @param {string} code\n    @param {Array<string>} [languageSubset]\n    @returns {AutoHighlightResult}\n  */\n  function highlightAuto(code, languageSubset) {\n    languageSubset = languageSubset || options.languages || Object.keys(languages);\n    const plaintext = justTextHighlightResult(code);\n\n    const results = languageSubset.filter(getLanguage).filter(autoDetection).map(name =>\n      _highlight(name, code, false)\n    );\n    results.unshift(plaintext); // plaintext is always an option\n\n    const sorted = results.sort((a, b) => {\n      // sort base on relevance\n      if (a.relevance !== b.relevance) return b.relevance - a.relevance;\n\n      // always award the tie to the base language\n      // ie if C++ and Arduino are tied, it's more likely to be C++\n      if (a.language && b.language) {\n        if (getLanguage(a.language).supersetOf === b.language) {\n          return 1;\n        } else if (getLanguage(b.language).supersetOf === a.language) {\n          return -1;\n        }\n      }\n\n      // otherwise say they are equal, which has the effect of sorting on\n      // relevance while preserving the original ordering - which is how ties\n      // have historically been settled, ie the language that comes first always\n      // wins in the case of a tie\n      return 0;\n    });\n\n    const [best, secondBest] = sorted;\n\n    /** @type {AutoHighlightResult} */\n    const result = best;\n    result.secondBest = secondBest;\n\n    return result;\n  }\n\n  /**\n   * Builds new class name for block given the language name\n   *\n   * @param {HTMLElement} element\n   * @param {string} [currentLang]\n   * @param {string} [resultLang]\n   */\n  function updateClassName(element, currentLang, resultLang) {\n    const language = (currentLang && aliases[currentLang]) || resultLang;\n\n    element.classList.add(\"hljs\");\n    element.classList.add(`language-${language}`);\n  }\n\n  /**\n   * Applies highlighting to a DOM node containing code.\n   *\n   * @param {HighlightedHTMLElement} element - the HTML element to highlight\n  */\n  function highlightElement(element) {\n    /** @type HTMLElement */\n    let node = null;\n    const language = blockLanguage(element);\n\n    if (shouldNotHighlight(language)) return;\n\n    fire(\"before:highlightElement\",\n      { el: element, language: language });\n\n    // we should be all text, no child nodes\n    if (!options.ignoreUnescapedHTML && element.children.length > 0) {\n      console.warn(\"One of your code blocks includes unescaped HTML. This is a potentially serious security risk.\");\n      console.warn(\"https://github.com/highlightjs/highlight.js/issues/2886\");\n      console.warn(element);\n    }\n\n    node = element;\n    const text = node.textContent;\n    const result = language ? highlight(text, { language, ignoreIllegals: true }) : highlightAuto(text);\n\n    element.innerHTML = result.value;\n    updateClassName(element, language, result.language);\n    element.result = {\n      language: result.language,\n      // TODO: remove with version 11.0\n      re: result.relevance,\n      relevance: result.relevance\n    };\n    if (result.secondBest) {\n      element.secondBest = {\n        language: result.secondBest.language,\n        relevance: result.secondBest.relevance\n      };\n    }\n\n    fire(\"after:highlightElement\", { el: element, result, text });\n  }\n\n  /**\n   * Updates highlight.js global options with the passed options\n   *\n   * @param {Partial<HLJSOptions>} userOptions\n   */\n  function configure(userOptions) {\n    options = inherit(options, userOptions);\n  }\n\n  // TODO: remove v12, deprecated\n  const initHighlighting = () => {\n    highlightAll();\n    deprecated(\"10.6.0\", \"initHighlighting() deprecated.  Use highlightAll() now.\");\n  };\n\n  // TODO: remove v12, deprecated\n  function initHighlightingOnLoad() {\n    highlightAll();\n    deprecated(\"10.6.0\", \"initHighlightingOnLoad() deprecated.  Use highlightAll() now.\");\n  }\n\n  let wantsHighlight = false;\n\n  /**\n   * auto-highlights all pre>code elements on the page\n   */\n  function highlightAll() {\n    // if we are called too early in the loading process\n    if (document.readyState === \"loading\") {\n      wantsHighlight = true;\n      return;\n    }\n\n    const blocks = document.querySelectorAll(options.cssSelector);\n    blocks.forEach(highlightElement);\n  }\n\n  function boot() {\n    // if a highlight was requested before DOM was loaded, do now\n    if (wantsHighlight) highlightAll();\n  }\n\n  // make sure we are in the browser environment\n  if (typeof window !== 'undefined' && window.addEventListener) {\n    window.addEventListener('DOMContentLoaded', boot, false);\n  }\n\n  /**\n   * Register a language grammar module\n   *\n   * @param {string} languageName\n   * @param {LanguageFn} languageDefinition\n   */\n  function registerLanguage(languageName, languageDefinition) {\n    let lang = null;\n    try {\n      lang = languageDefinition(hljs);\n    } catch (error$1) {\n      error(\"Language definition for '{}' could not be registered.\".replace(\"{}\", languageName));\n      // hard or soft error\n      if (!SAFE_MODE) { throw error$1; } else { error(error$1); }\n      // languages that have serious errors are replaced with essentially a\n      // \"plaintext\" stand-in so that the code blocks will still get normal\n      // css classes applied to them - and one bad language won't break the\n      // entire highlighter\n      lang = PLAINTEXT_LANGUAGE;\n    }\n    // give it a temporary name if it doesn't have one in the meta-data\n    if (!lang.name) lang.name = languageName;\n    languages[languageName] = lang;\n    lang.rawDefinition = languageDefinition.bind(null, hljs);\n\n    if (lang.aliases) {\n      registerAliases(lang.aliases, { languageName });\n    }\n  }\n\n  /**\n   * Remove a language grammar module\n   *\n   * @param {string} languageName\n   */\n  function unregisterLanguage(languageName) {\n    delete languages[languageName];\n    for (const alias of Object.keys(aliases)) {\n      if (aliases[alias] === languageName) {\n        delete aliases[alias];\n      }\n    }\n  }\n\n  /**\n   * @returns {string[]} List of language internal names\n   */\n  function listLanguages() {\n    return Object.keys(languages);\n  }\n\n  /**\n   * @param {string} name - name of the language to retrieve\n   * @returns {Language | undefined}\n   */\n  function getLanguage(name) {\n    name = (name || '').toLowerCase();\n    return languages[name] || languages[aliases[name]];\n  }\n\n  /**\n   *\n   * @param {string|string[]} aliasList - single alias or list of aliases\n   * @param {{languageName: string}} opts\n   */\n  function registerAliases(aliasList, { languageName }) {\n    if (typeof aliasList === 'string') {\n      aliasList = [aliasList];\n    }\n    aliasList.forEach(alias => { aliases[alias.toLowerCase()] = languageName; });\n  }\n\n  /**\n   * Determines if a given language has auto-detection enabled\n   * @param {string} name - name of the language\n   */\n  function autoDetection(name) {\n    const lang = getLanguage(name);\n    return lang && !lang.disableAutodetect;\n  }\n\n  /**\n   * Upgrades the old highlightBlock plugins to the new\n   * highlightElement API\n   * @param {HLJSPlugin} plugin\n   */\n  function upgradePluginAPI(plugin) {\n    // TODO: remove with v12\n    if (plugin[\"before:highlightBlock\"] && !plugin[\"before:highlightElement\"]) {\n      plugin[\"before:highlightElement\"] = (data) => {\n        plugin[\"before:highlightBlock\"](\n          Object.assign({ block: data.el }, data)\n        );\n      };\n    }\n    if (plugin[\"after:highlightBlock\"] && !plugin[\"after:highlightElement\"]) {\n      plugin[\"after:highlightElement\"] = (data) => {\n        plugin[\"after:highlightBlock\"](\n          Object.assign({ block: data.el }, data)\n        );\n      };\n    }\n  }\n\n  /**\n   * @param {HLJSPlugin} plugin\n   */\n  function addPlugin(plugin) {\n    upgradePluginAPI(plugin);\n    plugins.push(plugin);\n  }\n\n  /**\n   *\n   * @param {PluginEvent} event\n   * @param {any} args\n   */\n  function fire(event, args) {\n    const cb = event;\n    plugins.forEach(function(plugin) {\n      if (plugin[cb]) {\n        plugin[cb](args);\n      }\n    });\n  }\n\n  /**\n   * DEPRECATED\n   * @param {HighlightedHTMLElement} el\n   */\n  function deprecateHighlightBlock(el) {\n    deprecated(\"10.7.0\", \"highlightBlock will be removed entirely in v12.0\");\n    deprecated(\"10.7.0\", \"Please use highlightElement now.\");\n\n    return highlightElement(el);\n  }\n\n  /* Interface definition */\n  Object.assign(hljs, {\n    highlight,\n    highlightAuto,\n    highlightAll,\n    highlightElement,\n    // TODO: Remove with v12 API\n    highlightBlock: deprecateHighlightBlock,\n    configure,\n    initHighlighting,\n    initHighlightingOnLoad,\n    registerLanguage,\n    unregisterLanguage,\n    listLanguages,\n    getLanguage,\n    registerAliases,\n    autoDetection,\n    inherit,\n    addPlugin\n  });\n\n  hljs.debugMode = function() { SAFE_MODE = false; };\n  hljs.safeMode = function() { SAFE_MODE = true; };\n  hljs.versionString = version;\n\n  for (const key in MODES) {\n    // @ts-ignore\n    if (typeof MODES[key] === \"object\") {\n      // @ts-ignore\n      deepFreeze$1(MODES[key]);\n    }\n  }\n\n  // merge all the modes/regexes into our main object\n  Object.assign(hljs, MODES);\n\n  return hljs;\n};\n\n// export an \"instance\" of the highlighter\nvar highlight = HLJS({});\n\nmodule.exports = highlight;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFlBQVk7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGdCQUFnQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsZ0JBQWdCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSxZQUFZO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsYUFBYTtBQUMxQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBLGFBQWEsd0JBQXdCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVILGdDQUFnQztBQUNoQywrQkFBK0I7QUFDL0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsdUJBQXVCOztBQUV2QiIsInNvdXJjZXMiOlsid2VicGFjazovL21kYy1yZWFjdC8uL25vZGVfbW9kdWxlcy9oaWdobGlnaHQuanMvbGliL2NvcmUuanM/YzQyYSJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgZGVlcEZyZWV6ZUVzNiA9IHtleHBvcnRzOiB7fX07XG5cbmZ1bmN0aW9uIGRlZXBGcmVlemUob2JqKSB7XG4gICAgaWYgKG9iaiBpbnN0YW5jZW9mIE1hcCkge1xuICAgICAgICBvYmouY2xlYXIgPSBvYmouZGVsZXRlID0gb2JqLnNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignbWFwIGlzIHJlYWQtb25seScpO1xuICAgICAgICB9O1xuICAgIH0gZWxzZSBpZiAob2JqIGluc3RhbmNlb2YgU2V0KSB7XG4gICAgICAgIG9iai5hZGQgPSBvYmouY2xlYXIgPSBvYmouZGVsZXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzZXQgaXMgcmVhZC1vbmx5Jyk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gRnJlZXplIHNlbGZcbiAgICBPYmplY3QuZnJlZXplKG9iaik7XG5cbiAgICBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhvYmopLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgdmFyIHByb3AgPSBvYmpbbmFtZV07XG5cbiAgICAgICAgLy8gRnJlZXplIHByb3AgaWYgaXQgaXMgYW4gb2JqZWN0XG4gICAgICAgIGlmICh0eXBlb2YgcHJvcCA9PSAnb2JqZWN0JyAmJiAhT2JqZWN0LmlzRnJvemVuKHByb3ApKSB7XG4gICAgICAgICAgICBkZWVwRnJlZXplKHByb3ApO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gb2JqO1xufVxuXG5kZWVwRnJlZXplRXM2LmV4cG9ydHMgPSBkZWVwRnJlZXplO1xuZGVlcEZyZWV6ZUVzNi5leHBvcnRzLmRlZmF1bHQgPSBkZWVwRnJlZXplO1xuXG52YXIgZGVlcEZyZWV6ZSQxID0gZGVlcEZyZWV6ZUVzNi5leHBvcnRzO1xuXG4vKiogQHR5cGVkZWYge2ltcG9ydCgnaGlnaGxpZ2h0LmpzJykuQ2FsbGJhY2tSZXNwb25zZX0gQ2FsbGJhY2tSZXNwb25zZSAqL1xuLyoqIEB0eXBlZGVmIHtpbXBvcnQoJ2hpZ2hsaWdodC5qcycpLkNvbXBpbGVkTW9kZX0gQ29tcGlsZWRNb2RlICovXG4vKiogQGltcGxlbWVudHMgQ2FsbGJhY2tSZXNwb25zZSAqL1xuXG5jbGFzcyBSZXNwb25zZSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge0NvbXBpbGVkTW9kZX0gbW9kZVxuICAgKi9cbiAgY29uc3RydWN0b3IobW9kZSkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlZmluZWRcbiAgICBpZiAobW9kZS5kYXRhID09PSB1bmRlZmluZWQpIG1vZGUuZGF0YSA9IHt9O1xuXG4gICAgdGhpcy5kYXRhID0gbW9kZS5kYXRhO1xuICAgIHRoaXMuaXNNYXRjaElnbm9yZWQgPSBmYWxzZTtcbiAgfVxuXG4gIGlnbm9yZU1hdGNoKCkge1xuICAgIHRoaXMuaXNNYXRjaElnbm9yZWQgPSB0cnVlO1xuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBlc2NhcGVIVE1MKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZVxuICAgIC5yZXBsYWNlKC8mL2csICcmYW1wOycpXG4gICAgLnJlcGxhY2UoLzwvZywgJyZsdDsnKVxuICAgIC5yZXBsYWNlKC8+L2csICcmZ3Q7JylcbiAgICAucmVwbGFjZSgvXCIvZywgJyZxdW90OycpXG4gICAgLnJlcGxhY2UoLycvZywgJyYjeDI3OycpO1xufVxuXG4vKipcbiAqIHBlcmZvcm1zIGEgc2hhbGxvdyBtZXJnZSBvZiBtdWx0aXBsZSBvYmplY3RzIGludG8gb25lXG4gKlxuICogQHRlbXBsYXRlIFRcbiAqIEBwYXJhbSB7VH0gb3JpZ2luYWxcbiAqIEBwYXJhbSB7UmVjb3JkPHN0cmluZyxhbnk+W119IG9iamVjdHNcbiAqIEByZXR1cm5zIHtUfSBhIHNpbmdsZSBuZXcgb2JqZWN0XG4gKi9cbmZ1bmN0aW9uIGluaGVyaXQkMShvcmlnaW5hbCwgLi4ub2JqZWN0cykge1xuICAvKiogQHR5cGUgUmVjb3JkPHN0cmluZyxhbnk+ICovXG4gIGNvbnN0IHJlc3VsdCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbiAgZm9yIChjb25zdCBrZXkgaW4gb3JpZ2luYWwpIHtcbiAgICByZXN1bHRba2V5XSA9IG9yaWdpbmFsW2tleV07XG4gIH1cbiAgb2JqZWN0cy5mb3JFYWNoKGZ1bmN0aW9uKG9iaikge1xuICAgIGZvciAoY29uc3Qga2V5IGluIG9iaikge1xuICAgICAgcmVzdWx0W2tleV0gPSBvYmpba2V5XTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gLyoqIEB0eXBlIHtUfSAqLyAocmVzdWx0KTtcbn1cblxuLyoqXG4gKiBAdHlwZWRlZiB7b2JqZWN0fSBSZW5kZXJlclxuICogQHByb3BlcnR5IHsodGV4dDogc3RyaW5nKSA9PiB2b2lkfSBhZGRUZXh0XG4gKiBAcHJvcGVydHkgeyhub2RlOiBOb2RlKSA9PiB2b2lkfSBvcGVuTm9kZVxuICogQHByb3BlcnR5IHsobm9kZTogTm9kZSkgPT4gdm9pZH0gY2xvc2VOb2RlXG4gKiBAcHJvcGVydHkgeygpID0+IHN0cmluZ30gdmFsdWVcbiAqL1xuXG4vKiogQHR5cGVkZWYge3traW5kPzogc3RyaW5nLCBzdWJsYW5ndWFnZT86IGJvb2xlYW59fSBOb2RlICovXG4vKiogQHR5cGVkZWYge3t3YWxrOiAocjogUmVuZGVyZXIpID0+IHZvaWR9fSBUcmVlICovXG4vKiogKi9cblxuY29uc3QgU1BBTl9DTE9TRSA9ICc8L3NwYW4+JztcblxuLyoqXG4gKiBEZXRlcm1pbmVzIGlmIGEgbm9kZSBuZWVkcyB0byBiZSB3cmFwcGVkIGluIDxzcGFuPlxuICpcbiAqIEBwYXJhbSB7Tm9kZX0gbm9kZSAqL1xuY29uc3QgZW1pdHNXcmFwcGluZ1RhZ3MgPSAobm9kZSkgPT4ge1xuICByZXR1cm4gISFub2RlLmtpbmQ7XG59O1xuXG4vKipcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICogQHBhcmFtIHt7cHJlZml4OnN0cmluZ319IG9wdGlvbnNcbiAqL1xuY29uc3QgZXhwYW5kU2NvcGVOYW1lID0gKG5hbWUsIHsgcHJlZml4IH0pID0+IHtcbiAgaWYgKG5hbWUuaW5jbHVkZXMoXCIuXCIpKSB7XG4gICAgY29uc3QgcGllY2VzID0gbmFtZS5zcGxpdChcIi5cIik7XG4gICAgcmV0dXJuIFtcbiAgICAgIGAke3ByZWZpeH0ke3BpZWNlcy5zaGlmdCgpfWAsXG4gICAgICAuLi4ocGllY2VzLm1hcCgoeCwgaSkgPT4gYCR7eH0ke1wiX1wiLnJlcGVhdChpICsgMSl9YCkpXG4gICAgXS5qb2luKFwiIFwiKTtcbiAgfVxuICByZXR1cm4gYCR7cHJlZml4fSR7bmFtZX1gO1xufTtcblxuLyoqIEB0eXBlIHtSZW5kZXJlcn0gKi9cbmNsYXNzIEhUTUxSZW5kZXJlciB7XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IEhUTUxSZW5kZXJlclxuICAgKlxuICAgKiBAcGFyYW0ge1RyZWV9IHBhcnNlVHJlZSAtIHRoZSBwYXJzZSB0cmVlIChtdXN0IHN1cHBvcnQgYHdhbGtgIEFQSSlcbiAgICogQHBhcmFtIHt7Y2xhc3NQcmVmaXg6IHN0cmluZ319IG9wdGlvbnNcbiAgICovXG4gIGNvbnN0cnVjdG9yKHBhcnNlVHJlZSwgb3B0aW9ucykge1xuICAgIHRoaXMuYnVmZmVyID0gXCJcIjtcbiAgICB0aGlzLmNsYXNzUHJlZml4ID0gb3B0aW9ucy5jbGFzc1ByZWZpeDtcbiAgICBwYXJzZVRyZWUud2Fsayh0aGlzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIHRleHRzIHRvIHRoZSBvdXRwdXQgc3RyZWFtXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0ICovXG4gIGFkZFRleHQodGV4dCkge1xuICAgIHRoaXMuYnVmZmVyICs9IGVzY2FwZUhUTUwodGV4dCk7XG4gIH1cblxuICAvKipcbiAgICogQWRkcyBhIG5vZGUgb3BlbiB0byB0aGUgb3V0cHV0IHN0cmVhbSAoaWYgbmVlZGVkKVxuICAgKlxuICAgKiBAcGFyYW0ge05vZGV9IG5vZGUgKi9cbiAgb3Blbk5vZGUobm9kZSkge1xuICAgIGlmICghZW1pdHNXcmFwcGluZ1RhZ3Mobm9kZSkpIHJldHVybjtcblxuICAgIGxldCBzY29wZSA9IG5vZGUua2luZDtcbiAgICBpZiAobm9kZS5zdWJsYW5ndWFnZSkge1xuICAgICAgc2NvcGUgPSBgbGFuZ3VhZ2UtJHtzY29wZX1gO1xuICAgIH0gZWxzZSB7XG4gICAgICBzY29wZSA9IGV4cGFuZFNjb3BlTmFtZShzY29wZSwgeyBwcmVmaXg6IHRoaXMuY2xhc3NQcmVmaXggfSk7XG4gICAgfVxuICAgIHRoaXMuc3BhbihzY29wZSk7XG4gIH1cblxuICAvKipcbiAgICogQWRkcyBhIG5vZGUgY2xvc2UgdG8gdGhlIG91dHB1dCBzdHJlYW0gKGlmIG5lZWRlZClcbiAgICpcbiAgICogQHBhcmFtIHtOb2RlfSBub2RlICovXG4gIGNsb3NlTm9kZShub2RlKSB7XG4gICAgaWYgKCFlbWl0c1dyYXBwaW5nVGFncyhub2RlKSkgcmV0dXJuO1xuXG4gICAgdGhpcy5idWZmZXIgKz0gU1BBTl9DTE9TRTtcbiAgfVxuXG4gIC8qKlxuICAgKiByZXR1cm5zIHRoZSBhY2N1bXVsYXRlZCBidWZmZXJcbiAgKi9cbiAgdmFsdWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuYnVmZmVyO1xuICB9XG5cbiAgLy8gaGVscGVyc1xuXG4gIC8qKlxuICAgKiBCdWlsZHMgYSBzcGFuIGVsZW1lbnRcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNsYXNzTmFtZSAqL1xuICBzcGFuKGNsYXNzTmFtZSkge1xuICAgIHRoaXMuYnVmZmVyICs9IGA8c3BhbiBjbGFzcz1cIiR7Y2xhc3NOYW1lfVwiPmA7XG4gIH1cbn1cblxuLyoqIEB0eXBlZGVmIHt7a2luZD86IHN0cmluZywgc3VibGFuZ3VhZ2U/OiBib29sZWFuLCBjaGlsZHJlbjogTm9kZVtdfSB8IHN0cmluZ30gTm9kZSAqL1xuLyoqIEB0eXBlZGVmIHt7a2luZD86IHN0cmluZywgc3VibGFuZ3VhZ2U/OiBib29sZWFuLCBjaGlsZHJlbjogTm9kZVtdfSB9IERhdGFOb2RlICovXG4vKiogQHR5cGVkZWYge2ltcG9ydCgnaGlnaGxpZ2h0LmpzJykuRW1pdHRlcn0gRW1pdHRlciAqL1xuLyoqICAqL1xuXG5jbGFzcyBUb2tlblRyZWUge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICAvKiogQHR5cGUgRGF0YU5vZGUgKi9cbiAgICB0aGlzLnJvb3ROb2RlID0geyBjaGlsZHJlbjogW10gfTtcbiAgICB0aGlzLnN0YWNrID0gW3RoaXMucm9vdE5vZGVdO1xuICB9XG5cbiAgZ2V0IHRvcCgpIHtcbiAgICByZXR1cm4gdGhpcy5zdGFja1t0aGlzLnN0YWNrLmxlbmd0aCAtIDFdO1xuICB9XG5cbiAgZ2V0IHJvb3QoKSB7IHJldHVybiB0aGlzLnJvb3ROb2RlOyB9XG5cbiAgLyoqIEBwYXJhbSB7Tm9kZX0gbm9kZSAqL1xuICBhZGQobm9kZSkge1xuICAgIHRoaXMudG9wLmNoaWxkcmVuLnB1c2gobm9kZSk7XG4gIH1cblxuICAvKiogQHBhcmFtIHtzdHJpbmd9IGtpbmQgKi9cbiAgb3Blbk5vZGUoa2luZCkge1xuICAgIC8qKiBAdHlwZSBOb2RlICovXG4gICAgY29uc3Qgbm9kZSA9IHsga2luZCwgY2hpbGRyZW46IFtdIH07XG4gICAgdGhpcy5hZGQobm9kZSk7XG4gICAgdGhpcy5zdGFjay5wdXNoKG5vZGUpO1xuICB9XG5cbiAgY2xvc2VOb2RlKCkge1xuICAgIGlmICh0aGlzLnN0YWNrLmxlbmd0aCA+IDEpIHtcbiAgICAgIHJldHVybiB0aGlzLnN0YWNrLnBvcCgpO1xuICAgIH1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5kZWZpbmVkXG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuXG4gIGNsb3NlQWxsTm9kZXMoKSB7XG4gICAgd2hpbGUgKHRoaXMuY2xvc2VOb2RlKCkpO1xuICB9XG5cbiAgdG9KU09OKCkge1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh0aGlzLnJvb3ROb2RlLCBudWxsLCA0KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAdHlwZWRlZiB7IGltcG9ydChcIi4vaHRtbF9yZW5kZXJlclwiKS5SZW5kZXJlciB9IFJlbmRlcmVyXG4gICAqIEBwYXJhbSB7UmVuZGVyZXJ9IGJ1aWxkZXJcbiAgICovXG4gIHdhbGsoYnVpbGRlcikge1xuICAgIC8vIHRoaXMgZG9lcyBub3RcbiAgICByZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci5fd2FsayhidWlsZGVyLCB0aGlzLnJvb3ROb2RlKTtcbiAgICAvLyB0aGlzIHdvcmtzXG4gICAgLy8gcmV0dXJuIFRva2VuVHJlZS5fd2FsayhidWlsZGVyLCB0aGlzLnJvb3ROb2RlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1JlbmRlcmVyfSBidWlsZGVyXG4gICAqIEBwYXJhbSB7Tm9kZX0gbm9kZVxuICAgKi9cbiAgc3RhdGljIF93YWxrKGJ1aWxkZXIsIG5vZGUpIHtcbiAgICBpZiAodHlwZW9mIG5vZGUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIGJ1aWxkZXIuYWRkVGV4dChub2RlKTtcbiAgICB9IGVsc2UgaWYgKG5vZGUuY2hpbGRyZW4pIHtcbiAgICAgIGJ1aWxkZXIub3Blbk5vZGUobm9kZSk7XG4gICAgICBub2RlLmNoaWxkcmVuLmZvckVhY2goKGNoaWxkKSA9PiB0aGlzLl93YWxrKGJ1aWxkZXIsIGNoaWxkKSk7XG4gICAgICBidWlsZGVyLmNsb3NlTm9kZShub2RlKTtcbiAgICB9XG4gICAgcmV0dXJuIGJ1aWxkZXI7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtOb2RlfSBub2RlXG4gICAqL1xuICBzdGF0aWMgX2NvbGxhcHNlKG5vZGUpIHtcbiAgICBpZiAodHlwZW9mIG5vZGUgPT09IFwic3RyaW5nXCIpIHJldHVybjtcbiAgICBpZiAoIW5vZGUuY2hpbGRyZW4pIHJldHVybjtcblxuICAgIGlmIChub2RlLmNoaWxkcmVuLmV2ZXJ5KGVsID0+IHR5cGVvZiBlbCA9PT0gXCJzdHJpbmdcIikpIHtcbiAgICAgIC8vIG5vZGUudGV4dCA9IG5vZGUuY2hpbGRyZW4uam9pbihcIlwiKTtcbiAgICAgIC8vIGRlbGV0ZSBub2RlLmNoaWxkcmVuO1xuICAgICAgbm9kZS5jaGlsZHJlbiA9IFtub2RlLmNoaWxkcmVuLmpvaW4oXCJcIildO1xuICAgIH0gZWxzZSB7XG4gICAgICBub2RlLmNoaWxkcmVuLmZvckVhY2goKGNoaWxkKSA9PiB7XG4gICAgICAgIFRva2VuVHJlZS5fY29sbGFwc2UoY2hpbGQpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICBDdXJyZW50bHkgdGhpcyBpcyBhbGwgcHJpdmF0ZSBBUEksIGJ1dCB0aGlzIGlzIHRoZSBtaW5pbWFsIEFQSSBuZWNlc3NhcnlcbiAgdGhhdCBhbiBFbWl0dGVyIG11c3QgaW1wbGVtZW50IHRvIGZ1bGx5IHN1cHBvcnQgdGhlIHBhcnNlci5cblxuICBNaW5pbWFsIGludGVyZmFjZTpcblxuICAtIGFkZEtleXdvcmQodGV4dCwga2luZClcbiAgLSBhZGRUZXh0KHRleHQpXG4gIC0gYWRkU3VibGFuZ3VhZ2UoZW1pdHRlciwgc3ViTGFuZ3VhZ2VOYW1lKVxuICAtIGZpbmFsaXplKClcbiAgLSBvcGVuTm9kZShraW5kKVxuICAtIGNsb3NlTm9kZSgpXG4gIC0gY2xvc2VBbGxOb2RlcygpXG4gIC0gdG9IVE1MKClcblxuKi9cblxuLyoqXG4gKiBAaW1wbGVtZW50cyB7RW1pdHRlcn1cbiAqL1xuY2xhc3MgVG9rZW5UcmVlRW1pdHRlciBleHRlbmRzIFRva2VuVHJlZSB7XG4gIC8qKlxuICAgKiBAcGFyYW0geyp9IG9wdGlvbnNcbiAgICovXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRleHRcbiAgICogQHBhcmFtIHtzdHJpbmd9IGtpbmRcbiAgICovXG4gIGFkZEtleXdvcmQodGV4dCwga2luZCkge1xuICAgIGlmICh0ZXh0ID09PSBcIlwiKSB7IHJldHVybjsgfVxuXG4gICAgdGhpcy5vcGVuTm9kZShraW5kKTtcbiAgICB0aGlzLmFkZFRleHQodGV4dCk7XG4gICAgdGhpcy5jbG9zZU5vZGUoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dFxuICAgKi9cbiAgYWRkVGV4dCh0ZXh0KSB7XG4gICAgaWYgKHRleHQgPT09IFwiXCIpIHsgcmV0dXJuOyB9XG5cbiAgICB0aGlzLmFkZCh0ZXh0KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0VtaXR0ZXIgJiB7cm9vdDogRGF0YU5vZGV9fSBlbWl0dGVyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAqL1xuICBhZGRTdWJsYW5ndWFnZShlbWl0dGVyLCBuYW1lKSB7XG4gICAgLyoqIEB0eXBlIERhdGFOb2RlICovXG4gICAgY29uc3Qgbm9kZSA9IGVtaXR0ZXIucm9vdDtcbiAgICBub2RlLmtpbmQgPSBuYW1lO1xuICAgIG5vZGUuc3VibGFuZ3VhZ2UgPSB0cnVlO1xuICAgIHRoaXMuYWRkKG5vZGUpO1xuICB9XG5cbiAgdG9IVE1MKCkge1xuICAgIGNvbnN0IHJlbmRlcmVyID0gbmV3IEhUTUxSZW5kZXJlcih0aGlzLCB0aGlzLm9wdGlvbnMpO1xuICAgIHJldHVybiByZW5kZXJlci52YWx1ZSgpO1xuICB9XG5cbiAgZmluYWxpemUoKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVcbiAqIEByZXR1cm5zIHtSZWdFeHB9XG4gKiAqL1xuXG4vKipcbiAqIEBwYXJhbSB7UmVnRXhwIHwgc3RyaW5nIH0gcmVcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIHNvdXJjZShyZSkge1xuICBpZiAoIXJlKSByZXR1cm4gbnVsbDtcbiAgaWYgKHR5cGVvZiByZSA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIHJlO1xuXG4gIHJldHVybiByZS5zb3VyY2U7XG59XG5cbi8qKlxuICogQHBhcmFtIHtSZWdFeHAgfCBzdHJpbmcgfSByZVxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gbG9va2FoZWFkKHJlKSB7XG4gIHJldHVybiBjb25jYXQoJyg/PScsIHJlLCAnKScpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7Li4uKFJlZ0V4cCB8IHN0cmluZykgfSBhcmdzXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBjb25jYXQoLi4uYXJncykge1xuICBjb25zdCBqb2luZWQgPSBhcmdzLm1hcCgoeCkgPT4gc291cmNlKHgpKS5qb2luKFwiXCIpO1xuICByZXR1cm4gam9pbmVkO1xufVxuXG5mdW5jdGlvbiBzdHJpcE9wdGlvbnNGcm9tQXJncyhhcmdzKSB7XG4gIGNvbnN0IG9wdHMgPSBhcmdzW2FyZ3MubGVuZ3RoIC0gMV07XG5cbiAgaWYgKHR5cGVvZiBvcHRzID09PSAnb2JqZWN0JyAmJiBvcHRzLmNvbnN0cnVjdG9yID09PSBPYmplY3QpIHtcbiAgICBhcmdzLnNwbGljZShhcmdzLmxlbmd0aCAtIDEsIDEpO1xuICAgIHJldHVybiBvcHRzO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB7fTtcbiAgfVxufVxuXG4vKipcbiAqIEFueSBvZiB0aGUgcGFzc2VkIGV4cHJlc3NzaW9ucyBtYXkgbWF0Y2hcbiAqXG4gKiBDcmVhdGVzIGEgaHVnZSB0aGlzIHwgdGhpcyB8IHRoYXQgfCB0aGF0IG1hdGNoXG4gKiBAcGFyYW0geyhSZWdFeHAgfCBzdHJpbmcpW10gfSBhcmdzXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBlaXRoZXIoLi4uYXJncykge1xuICBjb25zdCBvcHRzID0gc3RyaXBPcHRpb25zRnJvbUFyZ3MoYXJncyk7XG4gIGNvbnN0IGpvaW5lZCA9ICcoJyArXG4gICAgKG9wdHMuY2FwdHVyZSA/IFwiXCIgOiBcIj86XCIpICtcbiAgICBhcmdzLm1hcCgoeCkgPT4gc291cmNlKHgpKS5qb2luKFwifFwiKSArIFwiKVwiO1xuICByZXR1cm4gam9pbmVkO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7UmVnRXhwfSByZVxuICogQHJldHVybnMge251bWJlcn1cbiAqL1xuZnVuY3Rpb24gY291bnRNYXRjaEdyb3VwcyhyZSkge1xuICByZXR1cm4gKG5ldyBSZWdFeHAocmUudG9TdHJpbmcoKSArICd8JykpLmV4ZWMoJycpLmxlbmd0aCAtIDE7XG59XG5cbi8qKlxuICogRG9lcyBsZXhlbWUgc3RhcnQgd2l0aCBhIHJlZ3VsYXIgZXhwcmVzc2lvbiBtYXRjaCBhdCB0aGUgYmVnaW5uaW5nXG4gKiBAcGFyYW0ge1JlZ0V4cH0gcmVcbiAqIEBwYXJhbSB7c3RyaW5nfSBsZXhlbWVcbiAqL1xuZnVuY3Rpb24gc3RhcnRzV2l0aChyZSwgbGV4ZW1lKSB7XG4gIGNvbnN0IG1hdGNoID0gcmUgJiYgcmUuZXhlYyhsZXhlbWUpO1xuICByZXR1cm4gbWF0Y2ggJiYgbWF0Y2guaW5kZXggPT09IDA7XG59XG5cbi8vIEJBQ0tSRUZfUkUgbWF0Y2hlcyBhbiBvcGVuIHBhcmVudGhlc2lzIG9yIGJhY2tyZWZlcmVuY2UuIFRvIGF2b2lkXG4vLyBhbiBpbmNvcnJlY3QgcGFyc2UsIGl0IGFkZGl0aW9uYWxseSBtYXRjaGVzIHRoZSBmb2xsb3dpbmc6XG4vLyAtIFsuLi5dIGVsZW1lbnRzLCB3aGVyZSB0aGUgbWVhbmluZyBvZiBwYXJlbnRoZXNlcyBhbmQgZXNjYXBlcyBjaGFuZ2Vcbi8vIC0gb3RoZXIgZXNjYXBlIHNlcXVlbmNlcywgc28gd2UgZG8gbm90IG1pc3BhcnNlIGVzY2FwZSBzZXF1ZW5jZXMgYXNcbi8vICAgaW50ZXJlc3RpbmcgZWxlbWVudHNcbi8vIC0gbm9uLW1hdGNoaW5nIG9yIGxvb2thaGVhZCBwYXJlbnRoZXNlcywgd2hpY2ggZG8gbm90IGNhcHR1cmUuIFRoZXNlXG4vLyAgIGZvbGxvdyB0aGUgJygnIHdpdGggYSAnPycuXG5jb25zdCBCQUNLUkVGX1JFID0gL1xcWyg/OlteXFxcXFxcXV18XFxcXC4pKlxcXXxcXChcXD8/fFxcXFwoWzEtOV1bMC05XSopfFxcXFwuLztcblxuLy8gKipJTlRFUk5BTCoqIE5vdCBpbnRlbmRlZCBmb3Igb3V0c2lkZSB1c2FnZVxuLy8gam9pbiBsb2dpY2FsbHkgY29tcHV0ZXMgcmVnZXhwcy5qb2luKHNlcGFyYXRvciksIGJ1dCBmaXhlcyB0aGVcbi8vIGJhY2tyZWZlcmVuY2VzIHNvIHRoZXkgY29udGludWUgdG8gbWF0Y2guXG4vLyBpdCBhbHNvIHBsYWNlcyBlYWNoIGluZGl2aWR1YWwgcmVndWxhciBleHByZXNzaW9uIGludG8gaXQncyBvd25cbi8vIG1hdGNoIGdyb3VwLCBrZWVwaW5nIHRyYWNrIG9mIHRoZSBzZXF1ZW5jaW5nIG9mIHRob3NlIG1hdGNoIGdyb3Vwc1xuLy8gaXMgY3VycmVudGx5IGFuIGV4ZXJjaXNlIGZvciB0aGUgY2FsbGVyLiA6LSlcbi8qKlxuICogQHBhcmFtIHsoc3RyaW5nIHwgUmVnRXhwKVtdfSByZWdleHBzXG4gKiBAcGFyYW0ge3tqb2luV2l0aDogc3RyaW5nfX0gb3B0c1xuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gX3Jld3JpdGVCYWNrcmVmZXJlbmNlcyhyZWdleHBzLCB7IGpvaW5XaXRoIH0pIHtcbiAgbGV0IG51bUNhcHR1cmVzID0gMDtcblxuICByZXR1cm4gcmVnZXhwcy5tYXAoKHJlZ2V4KSA9PiB7XG4gICAgbnVtQ2FwdHVyZXMgKz0gMTtcbiAgICBjb25zdCBvZmZzZXQgPSBudW1DYXB0dXJlcztcbiAgICBsZXQgcmUgPSBzb3VyY2UocmVnZXgpO1xuICAgIGxldCBvdXQgPSAnJztcblxuICAgIHdoaWxlIChyZS5sZW5ndGggPiAwKSB7XG4gICAgICBjb25zdCBtYXRjaCA9IEJBQ0tSRUZfUkUuZXhlYyhyZSk7XG4gICAgICBpZiAoIW1hdGNoKSB7XG4gICAgICAgIG91dCArPSByZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBvdXQgKz0gcmUuc3Vic3RyaW5nKDAsIG1hdGNoLmluZGV4KTtcbiAgICAgIHJlID0gcmUuc3Vic3RyaW5nKG1hdGNoLmluZGV4ICsgbWF0Y2hbMF0ubGVuZ3RoKTtcbiAgICAgIGlmIChtYXRjaFswXVswXSA9PT0gJ1xcXFwnICYmIG1hdGNoWzFdKSB7XG4gICAgICAgIC8vIEFkanVzdCB0aGUgYmFja3JlZmVyZW5jZS5cbiAgICAgICAgb3V0ICs9ICdcXFxcJyArIFN0cmluZyhOdW1iZXIobWF0Y2hbMV0pICsgb2Zmc2V0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG91dCArPSBtYXRjaFswXTtcbiAgICAgICAgaWYgKG1hdGNoWzBdID09PSAnKCcpIHtcbiAgICAgICAgICBudW1DYXB0dXJlcysrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvdXQ7XG4gIH0pLm1hcChyZSA9PiBgKCR7cmV9KWApLmpvaW4oam9pbldpdGgpO1xufVxuXG4vKiogQHR5cGVkZWYge2ltcG9ydCgnaGlnaGxpZ2h0LmpzJykuTW9kZX0gTW9kZSAqL1xuLyoqIEB0eXBlZGVmIHtpbXBvcnQoJ2hpZ2hsaWdodC5qcycpLk1vZGVDYWxsYmFja30gTW9kZUNhbGxiYWNrICovXG5cbi8vIENvbW1vbiByZWdleHBzXG5jb25zdCBNQVRDSF9OT1RISU5HX1JFID0gL1xcYlxcQi87XG5jb25zdCBJREVOVF9SRSA9ICdbYS16QS1aXVxcXFx3Kic7XG5jb25zdCBVTkRFUlNDT1JFX0lERU5UX1JFID0gJ1thLXpBLVpfXVxcXFx3Kic7XG5jb25zdCBOVU1CRVJfUkUgPSAnXFxcXGJcXFxcZCsoXFxcXC5cXFxcZCspPyc7XG5jb25zdCBDX05VTUJFUl9SRSA9ICcoLT8pKFxcXFxiMFt4WF1bYS1mQS1GMC05XSt8KFxcXFxiXFxcXGQrKFxcXFwuXFxcXGQqKT98XFxcXC5cXFxcZCspKFtlRV1bLStdP1xcXFxkKyk/KSc7IC8vIDB4Li4uLCAwLi4uLCBkZWNpbWFsLCBmbG9hdFxuY29uc3QgQklOQVJZX05VTUJFUl9SRSA9ICdcXFxcYigwYlswMV0rKSc7IC8vIDBiLi4uXG5jb25zdCBSRV9TVEFSVEVSU19SRSA9ICchfCE9fCE9PXwlfCU9fCZ8JiZ8Jj18XFxcXCp8XFxcXCo9fFxcXFwrfFxcXFwrPXwsfC18LT18Lz18L3w6fDt8PDx8PDw9fDw9fDx8PT09fD09fD18Pj4+PXw+Pj18Pj18Pj4+fD4+fD58XFxcXD98XFxcXFt8XFxcXHt8XFxcXCh8XFxcXF58XFxcXF49fFxcXFx8fFxcXFx8PXxcXFxcfFxcXFx8fH4nO1xuXG4vKipcbiogQHBhcmFtIHsgUGFydGlhbDxNb2RlPiAmIHtiaW5hcnk/OiBzdHJpbmcgfCBSZWdFeHB9IH0gb3B0c1xuKi9cbmNvbnN0IFNIRUJBTkcgPSAob3B0cyA9IHt9KSA9PiB7XG4gIGNvbnN0IGJlZ2luU2hlYmFuZyA9IC9eIyFbIF0qXFwvLztcbiAgaWYgKG9wdHMuYmluYXJ5KSB7XG4gICAgb3B0cy5iZWdpbiA9IGNvbmNhdChcbiAgICAgIGJlZ2luU2hlYmFuZyxcbiAgICAgIC8uKlxcYi8sXG4gICAgICBvcHRzLmJpbmFyeSxcbiAgICAgIC9cXGIuKi8pO1xuICB9XG4gIHJldHVybiBpbmhlcml0JDEoe1xuICAgIHNjb3BlOiAnbWV0YScsXG4gICAgYmVnaW46IGJlZ2luU2hlYmFuZyxcbiAgICBlbmQ6IC8kLyxcbiAgICByZWxldmFuY2U6IDAsXG4gICAgLyoqIEB0eXBlIHtNb2RlQ2FsbGJhY2t9ICovXG4gICAgXCJvbjpiZWdpblwiOiAobSwgcmVzcCkgPT4ge1xuICAgICAgaWYgKG0uaW5kZXggIT09IDApIHJlc3AuaWdub3JlTWF0Y2goKTtcbiAgICB9XG4gIH0sIG9wdHMpO1xufTtcblxuLy8gQ29tbW9uIG1vZGVzXG5jb25zdCBCQUNLU0xBU0hfRVNDQVBFID0ge1xuICBiZWdpbjogJ1xcXFxcXFxcW1xcXFxzXFxcXFNdJywgcmVsZXZhbmNlOiAwXG59O1xuY29uc3QgQVBPU19TVFJJTkdfTU9ERSA9IHtcbiAgc2NvcGU6ICdzdHJpbmcnLFxuICBiZWdpbjogJ1xcJycsXG4gIGVuZDogJ1xcJycsXG4gIGlsbGVnYWw6ICdcXFxcbicsXG4gIGNvbnRhaW5zOiBbQkFDS1NMQVNIX0VTQ0FQRV1cbn07XG5jb25zdCBRVU9URV9TVFJJTkdfTU9ERSA9IHtcbiAgc2NvcGU6ICdzdHJpbmcnLFxuICBiZWdpbjogJ1wiJyxcbiAgZW5kOiAnXCInLFxuICBpbGxlZ2FsOiAnXFxcXG4nLFxuICBjb250YWluczogW0JBQ0tTTEFTSF9FU0NBUEVdXG59O1xuY29uc3QgUEhSQVNBTF9XT1JEU19NT0RFID0ge1xuICBiZWdpbjogL1xcYihhfGFufHRoZXxhcmV8SSdtfGlzbid0fGRvbid0fGRvZXNuJ3R8d29uJ3R8YnV0fGp1c3R8c2hvdWxkfHByZXR0eXxzaW1wbHl8ZW5vdWdofGdvbm5hfGdvaW5nfHd0Znxzb3xzdWNofHdpbGx8eW91fHlvdXJ8dGhleXxsaWtlfG1vcmUpXFxiL1xufTtcbi8qKlxuICogQ3JlYXRlcyBhIGNvbW1lbnQgbW9kZVxuICpcbiAqIEBwYXJhbSB7c3RyaW5nIHwgUmVnRXhwfSBiZWdpblxuICogQHBhcmFtIHtzdHJpbmcgfCBSZWdFeHB9IGVuZFxuICogQHBhcmFtIHtNb2RlIHwge319IFttb2RlT3B0aW9uc11cbiAqIEByZXR1cm5zIHtQYXJ0aWFsPE1vZGU+fVxuICovXG5jb25zdCBDT01NRU5UID0gZnVuY3Rpb24oYmVnaW4sIGVuZCwgbW9kZU9wdGlvbnMgPSB7fSkge1xuICBjb25zdCBtb2RlID0gaW5oZXJpdCQxKFxuICAgIHtcbiAgICAgIHNjb3BlOiAnY29tbWVudCcsXG4gICAgICBiZWdpbixcbiAgICAgIGVuZCxcbiAgICAgIGNvbnRhaW5zOiBbXVxuICAgIH0sXG4gICAgbW9kZU9wdGlvbnNcbiAgKTtcbiAgbW9kZS5jb250YWlucy5wdXNoKHtcbiAgICBzY29wZTogJ2RvY3RhZycsXG4gICAgLy8gaGFjayB0byBhdm9pZCB0aGUgc3BhY2UgZnJvbSBiZWluZyBpbmNsdWRlZC4gdGhlIHNwYWNlIGlzIG5lY2Vzc2FyeSB0b1xuICAgIC8vIG1hdGNoIGhlcmUgdG8gcHJldmVudCB0aGUgcGxhaW4gdGV4dCBydWxlIGJlbG93IGZyb20gZ29iYmxpbmcgdXAgZG9jdGFnc1xuICAgIGJlZ2luOiAnWyBdKig/PShUT0RPfEZJWE1FfE5PVEV8QlVHfE9QVElNSVpFfEhBQ0t8WFhYKTopJyxcbiAgICBlbmQ6IC8oVE9ET3xGSVhNRXxOT1RFfEJVR3xPUFRJTUlaRXxIQUNLfFhYWCk6LyxcbiAgICBleGNsdWRlQmVnaW46IHRydWUsXG4gICAgcmVsZXZhbmNlOiAwXG4gIH0pO1xuICBjb25zdCBFTkdMSVNIX1dPUkQgPSBlaXRoZXIoXG4gICAgLy8gbGlzdCBvZiBjb21tb24gMSBhbmQgMiBsZXR0ZXIgd29yZHMgaW4gRW5nbGlzaFxuICAgIFwiSVwiLFxuICAgIFwiYVwiLFxuICAgIFwiaXNcIixcbiAgICBcInNvXCIsXG4gICAgXCJ1c1wiLFxuICAgIFwidG9cIixcbiAgICBcImF0XCIsXG4gICAgXCJpZlwiLFxuICAgIFwiaW5cIixcbiAgICBcIml0XCIsXG4gICAgXCJvblwiLFxuICAgIC8vIG5vdGU6IHRoaXMgaXMgbm90IGFuIGV4aGF1c3RpdmUgbGlzdCBvZiBjb250cmFjdGlvbnMsIGp1c3QgcG9wdWxhciBvbmVzXG4gICAgL1tBLVphLXpdK1snXShkfHZlfHJlfGxsfHR8c3xuKS8sIC8vIGNvbnRyYWN0aW9ucyAtIGNhbid0IHdlJ2QgdGhleSdyZSBsZXQncywgZXRjXG4gICAgL1tBLVphLXpdK1stXVthLXpdKy8sIC8vIGBuby13YXlgLCBldGMuXG4gICAgL1tBLVphLXpdW2Etel17Mix9LyAvLyBhbGxvdyBjYXBpdGFsaXplZCB3b3JkcyBhdCBiZWdpbm5pbmcgb2Ygc2VudGVuY2VzXG4gICk7XG4gIC8vIGxvb2tpbmcgbGlrZSBwbGFpbiB0ZXh0LCBtb3JlIGxpa2VseSB0byBiZSBhIGNvbW1lbnRcbiAgbW9kZS5jb250YWlucy5wdXNoKFxuICAgIHtcbiAgICAgIC8vIFRPRE86IGhvdyB0byBpbmNsdWRlIFwiLCAoLCApIHdpdGhvdXQgYnJlYWtpbmcgZ3JhbW1hcnMgdGhhdCB1c2UgdGhlc2UgZm9yXG4gICAgICAvLyBjb21tZW50IGRlbGltaXRlcnM/XG4gICAgICAvLyBiZWdpbjogL1sgXSsoWygpXCJdPyhbQS1aYS16Jy1dezMsfXxpc3xhfEl8c298dXN8W3RUXVtvT118YXR8aWZ8aW58aXR8b24pWy5dP1soKVwiOl0/KFsuXVsgXXxbIF18XFwpKSl7M30vXG4gICAgICAvLyAtLS1cblxuICAgICAgLy8gdGhpcyB0cmllcyB0byBmaW5kIHNlcXVlbmNlcyBvZiAzIGVuZ2xpc2ggd29yZHMgaW4gYSByb3cgKHdpdGhvdXQgYW55XG4gICAgICAvLyBcInByb2dyYW1taW5nXCIgdHlwZSBzeW50YXgpIHRoaXMgZ2l2ZXMgdXMgYSBzdHJvbmcgc2lnbmFsIHRoYXQgd2UndmVcbiAgICAgIC8vIFRSVUxZIGZvdW5kIGEgY29tbWVudCAtIHZzIHBlcmhhcHMgc2Nhbm5pbmcgd2l0aCB0aGUgd3JvbmcgbGFuZ3VhZ2UuXG4gICAgICAvLyBJdCdzIHBvc3NpYmxlIHRvIGZpbmQgc29tZXRoaW5nIHRoYXQgTE9PS1MgbGlrZSB0aGUgc3RhcnQgb2YgdGhlXG4gICAgICAvLyBjb21tZW50IC0gYnV0IHRoZW4gaWYgdGhlcmUgaXMgbm8gcmVhZGFibGUgdGV4dCAtIGdvb2QgY2hhbmNlIGl0IGlzIGFcbiAgICAgIC8vIGZhbHNlIG1hdGNoIGFuZCBub3QgYSBjb21tZW50LlxuICAgICAgLy9cbiAgICAgIC8vIGZvciBhIHZpc3VhbCBleGFtcGxlIHBsZWFzZSBzZWU6XG4gICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vaGlnaGxpZ2h0anMvaGlnaGxpZ2h0LmpzL2lzc3Vlcy8yODI3XG5cbiAgICAgIGJlZ2luOiBjb25jYXQoXG4gICAgICAgIC9bIF0rLywgLy8gbmVjZXNzYXJ5IHRvIHByZXZlbnQgdXMgZ29iYmxpbmcgdXAgZG9jdGFncyBsaWtlIC8qIEBhdXRob3IgQm9iIE1jZ2lsbCAqL1xuICAgICAgICAnKCcsXG4gICAgICAgIEVOR0xJU0hfV09SRCxcbiAgICAgICAgL1suXT9bOl0/KFsuXVsgXXxbIF0pLyxcbiAgICAgICAgJyl7M30nKSAvLyBsb29rIGZvciAzIHdvcmRzIGluIGEgcm93XG4gICAgfVxuICApO1xuICByZXR1cm4gbW9kZTtcbn07XG5jb25zdCBDX0xJTkVfQ09NTUVOVF9NT0RFID0gQ09NTUVOVCgnLy8nLCAnJCcpO1xuY29uc3QgQ19CTE9DS19DT01NRU5UX01PREUgPSBDT01NRU5UKCcvXFxcXConLCAnXFxcXCovJyk7XG5jb25zdCBIQVNIX0NPTU1FTlRfTU9ERSA9IENPTU1FTlQoJyMnLCAnJCcpO1xuY29uc3QgTlVNQkVSX01PREUgPSB7XG4gIHNjb3BlOiAnbnVtYmVyJyxcbiAgYmVnaW46IE5VTUJFUl9SRSxcbiAgcmVsZXZhbmNlOiAwXG59O1xuY29uc3QgQ19OVU1CRVJfTU9ERSA9IHtcbiAgc2NvcGU6ICdudW1iZXInLFxuICBiZWdpbjogQ19OVU1CRVJfUkUsXG4gIHJlbGV2YW5jZTogMFxufTtcbmNvbnN0IEJJTkFSWV9OVU1CRVJfTU9ERSA9IHtcbiAgc2NvcGU6ICdudW1iZXInLFxuICBiZWdpbjogQklOQVJZX05VTUJFUl9SRSxcbiAgcmVsZXZhbmNlOiAwXG59O1xuY29uc3QgUkVHRVhQX01PREUgPSB7XG4gIC8vIHRoaXMgb3V0ZXIgcnVsZSBtYWtlcyBzdXJlIHdlIGFjdHVhbGx5IGhhdmUgYSBXSE9MRSByZWdleCBhbmQgbm90IHNpbXBseVxuICAvLyBhbiBleHByZXNzaW9uIHN1Y2ggYXM6XG4gIC8vXG4gIC8vICAgICAzIC8gc29tZXRoaW5nXG4gIC8vXG4gIC8vICh3aGljaCB3aWxsIHRoZW4gYmxvdyB1cCB3aGVuIHJlZ2V4J3MgYGlsbGVnYWxgIHNlZXMgdGhlIG5ld2xpbmUpXG4gIGJlZ2luOiAvKD89XFwvW14vXFxuXSpcXC8pLyxcbiAgY29udGFpbnM6IFt7XG4gICAgc2NvcGU6ICdyZWdleHAnLFxuICAgIGJlZ2luOiAvXFwvLyxcbiAgICBlbmQ6IC9cXC9bZ2ltdXldKi8sXG4gICAgaWxsZWdhbDogL1xcbi8sXG4gICAgY29udGFpbnM6IFtcbiAgICAgIEJBQ0tTTEFTSF9FU0NBUEUsXG4gICAgICB7XG4gICAgICAgIGJlZ2luOiAvXFxbLyxcbiAgICAgICAgZW5kOiAvXFxdLyxcbiAgICAgICAgcmVsZXZhbmNlOiAwLFxuICAgICAgICBjb250YWluczogW0JBQ0tTTEFTSF9FU0NBUEVdXG4gICAgICB9XG4gICAgXVxuICB9XVxufTtcbmNvbnN0IFRJVExFX01PREUgPSB7XG4gIHNjb3BlOiAndGl0bGUnLFxuICBiZWdpbjogSURFTlRfUkUsXG4gIHJlbGV2YW5jZTogMFxufTtcbmNvbnN0IFVOREVSU0NPUkVfVElUTEVfTU9ERSA9IHtcbiAgc2NvcGU6ICd0aXRsZScsXG4gIGJlZ2luOiBVTkRFUlNDT1JFX0lERU5UX1JFLFxuICByZWxldmFuY2U6IDBcbn07XG5jb25zdCBNRVRIT0RfR1VBUkQgPSB7XG4gIC8vIGV4Y2x1ZGVzIG1ldGhvZCBuYW1lcyBmcm9tIGtleXdvcmQgcHJvY2Vzc2luZ1xuICBiZWdpbjogJ1xcXFwuXFxcXHMqJyArIFVOREVSU0NPUkVfSURFTlRfUkUsXG4gIHJlbGV2YW5jZTogMFxufTtcblxuLyoqXG4gKiBBZGRzIGVuZCBzYW1lIGFzIGJlZ2luIG1lY2hhbmljcyB0byBhIG1vZGVcbiAqXG4gKiBZb3VyIG1vZGUgbXVzdCBpbmNsdWRlIGF0IGxlYXN0IGEgc2luZ2xlICgpIG1hdGNoIGdyb3VwIGFzIHRoYXQgZmlyc3QgbWF0Y2hcbiAqIGdyb3VwIGlzIHdoYXQgaXMgdXNlZCBmb3IgY29tcGFyaXNvblxuICogQHBhcmFtIHtQYXJ0aWFsPE1vZGU+fSBtb2RlXG4gKi9cbmNvbnN0IEVORF9TQU1FX0FTX0JFR0lOID0gZnVuY3Rpb24obW9kZSkge1xuICByZXR1cm4gT2JqZWN0LmFzc2lnbihtb2RlLFxuICAgIHtcbiAgICAgIC8qKiBAdHlwZSB7TW9kZUNhbGxiYWNrfSAqL1xuICAgICAgJ29uOmJlZ2luJzogKG0sIHJlc3ApID0+IHsgcmVzcC5kYXRhLl9iZWdpbk1hdGNoID0gbVsxXTsgfSxcbiAgICAgIC8qKiBAdHlwZSB7TW9kZUNhbGxiYWNrfSAqL1xuICAgICAgJ29uOmVuZCc6IChtLCByZXNwKSA9PiB7IGlmIChyZXNwLmRhdGEuX2JlZ2luTWF0Y2ggIT09IG1bMV0pIHJlc3AuaWdub3JlTWF0Y2goKTsgfVxuICAgIH0pO1xufTtcblxudmFyIE1PREVTID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuICAgIF9fcHJvdG9fXzogbnVsbCxcbiAgICBNQVRDSF9OT1RISU5HX1JFOiBNQVRDSF9OT1RISU5HX1JFLFxuICAgIElERU5UX1JFOiBJREVOVF9SRSxcbiAgICBVTkRFUlNDT1JFX0lERU5UX1JFOiBVTkRFUlNDT1JFX0lERU5UX1JFLFxuICAgIE5VTUJFUl9SRTogTlVNQkVSX1JFLFxuICAgIENfTlVNQkVSX1JFOiBDX05VTUJFUl9SRSxcbiAgICBCSU5BUllfTlVNQkVSX1JFOiBCSU5BUllfTlVNQkVSX1JFLFxuICAgIFJFX1NUQVJURVJTX1JFOiBSRV9TVEFSVEVSU19SRSxcbiAgICBTSEVCQU5HOiBTSEVCQU5HLFxuICAgIEJBQ0tTTEFTSF9FU0NBUEU6IEJBQ0tTTEFTSF9FU0NBUEUsXG4gICAgQVBPU19TVFJJTkdfTU9ERTogQVBPU19TVFJJTkdfTU9ERSxcbiAgICBRVU9URV9TVFJJTkdfTU9ERTogUVVPVEVfU1RSSU5HX01PREUsXG4gICAgUEhSQVNBTF9XT1JEU19NT0RFOiBQSFJBU0FMX1dPUkRTX01PREUsXG4gICAgQ09NTUVOVDogQ09NTUVOVCxcbiAgICBDX0xJTkVfQ09NTUVOVF9NT0RFOiBDX0xJTkVfQ09NTUVOVF9NT0RFLFxuICAgIENfQkxPQ0tfQ09NTUVOVF9NT0RFOiBDX0JMT0NLX0NPTU1FTlRfTU9ERSxcbiAgICBIQVNIX0NPTU1FTlRfTU9ERTogSEFTSF9DT01NRU5UX01PREUsXG4gICAgTlVNQkVSX01PREU6IE5VTUJFUl9NT0RFLFxuICAgIENfTlVNQkVSX01PREU6IENfTlVNQkVSX01PREUsXG4gICAgQklOQVJZX05VTUJFUl9NT0RFOiBCSU5BUllfTlVNQkVSX01PREUsXG4gICAgUkVHRVhQX01PREU6IFJFR0VYUF9NT0RFLFxuICAgIFRJVExFX01PREU6IFRJVExFX01PREUsXG4gICAgVU5ERVJTQ09SRV9USVRMRV9NT0RFOiBVTkRFUlNDT1JFX1RJVExFX01PREUsXG4gICAgTUVUSE9EX0dVQVJEOiBNRVRIT0RfR1VBUkQsXG4gICAgRU5EX1NBTUVfQVNfQkVHSU46IEVORF9TQU1FX0FTX0JFR0lOXG59KTtcblxuLyoqXG5AdHlwZWRlZiB7aW1wb3J0KCdoaWdobGlnaHQuanMnKS5DYWxsYmFja1Jlc3BvbnNlfSBDYWxsYmFja1Jlc3BvbnNlXG5AdHlwZWRlZiB7aW1wb3J0KCdoaWdobGlnaHQuanMnKS5Db21waWxlckV4dH0gQ29tcGlsZXJFeHRcbiovXG5cbi8vIEdyYW1tYXIgZXh0ZW5zaW9ucyAvIHBsdWdpbnNcbi8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2hpZ2hsaWdodGpzL2hpZ2hsaWdodC5qcy9pc3N1ZXMvMjgzM1xuXG4vLyBHcmFtbWFyIGV4dGVuc2lvbnMgYWxsb3cgXCJzeW50YWN0aWMgc3VnYXJcIiB0byBiZSBhZGRlZCB0byB0aGUgZ3JhbW1hciBtb2Rlc1xuLy8gd2l0aG91dCByZXF1aXJpbmcgYW55IHVuZGVybHlpbmcgY2hhbmdlcyB0byB0aGUgY29tcGlsZXIgaW50ZXJuYWxzLlxuXG4vLyBgY29tcGlsZU1hdGNoYCBiZWluZyB0aGUgcGVyZmVjdCBzbWFsbCBleGFtcGxlIG9mIG5vdyBhbGxvd2luZyBhIGdyYW1tYXJcbi8vIGF1dGhvciB0byB3cml0ZSBgbWF0Y2hgIHdoZW4gdGhleSBkZXNpcmUgdG8gbWF0Y2ggYSBzaW5nbGUgZXhwcmVzc2lvbiByYXRoZXJcbi8vIHRoYW4gYmVpbmcgZm9yY2VkIHRvIHVzZSBgYmVnaW5gLiAgVGhlIGV4dGVuc2lvbiB0aGVuIGp1c3QgbW92ZXMgYG1hdGNoYCBpbnRvXG4vLyBgYmVnaW5gIHdoZW4gaXQgcnVucy4gIEllLCBubyBmZWF0dXJlcyBoYXZlIGJlZW4gYWRkZWQsIGJ1dCB3ZSd2ZSBqdXN0IG1hZGVcbi8vIHRoZSBleHBlcmllbmNlIG9mIHdyaXRpbmcgKGFuZCByZWFkaW5nIGdyYW1tYXJzKSBhIGxpdHRsZSBiaXQgbmljZXIuXG5cbi8vIC0tLS0tLVxuXG4vLyBUT0RPOiBXZSBuZWVkIG5lZ2F0aXZlIGxvb2stYmVoaW5kIHN1cHBvcnQgdG8gZG8gdGhpcyBwcm9wZXJseVxuLyoqXG4gKiBTa2lwIGEgbWF0Y2ggaWYgaXQgaGFzIGEgcHJlY2VkaW5nIGRvdFxuICpcbiAqIFRoaXMgaXMgdXNlZCBmb3IgYGJlZ2luS2V5d29yZHNgIHRvIHByZXZlbnQgbWF0Y2hpbmcgZXhwcmVzc2lvbnMgc3VjaCBhc1xuICogYGJvYi5rZXl3b3JkLmRvKClgLiBUaGUgbW9kZSBjb21waWxlciBhdXRvbWF0aWNhbGx5IHdpcmVzIHRoaXMgdXAgYXMgYVxuICogc3BlY2lhbCBfaW50ZXJuYWxfICdvbjpiZWdpbicgY2FsbGJhY2sgZm9yIG1vZGVzIHdpdGggYGJlZ2luS2V5d29yZHNgXG4gKiBAcGFyYW0ge1JlZ0V4cE1hdGNoQXJyYXl9IG1hdGNoXG4gKiBAcGFyYW0ge0NhbGxiYWNrUmVzcG9uc2V9IHJlc3BvbnNlXG4gKi9cbmZ1bmN0aW9uIHNraXBJZkhhc1ByZWNlZGluZ0RvdChtYXRjaCwgcmVzcG9uc2UpIHtcbiAgY29uc3QgYmVmb3JlID0gbWF0Y2guaW5wdXRbbWF0Y2guaW5kZXggLSAxXTtcbiAgaWYgKGJlZm9yZSA9PT0gXCIuXCIpIHtcbiAgICByZXNwb25zZS5pZ25vcmVNYXRjaCgpO1xuICB9XG59XG5cbi8qKlxuICpcbiAqIEB0eXBlIHtDb21waWxlckV4dH1cbiAqL1xuZnVuY3Rpb24gc2NvcGVDbGFzc05hbWUobW9kZSwgX3BhcmVudCkge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5kZWZpbmVkXG4gIGlmIChtb2RlLmNsYXNzTmFtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgbW9kZS5zY29wZSA9IG1vZGUuY2xhc3NOYW1lO1xuICAgIGRlbGV0ZSBtb2RlLmNsYXNzTmFtZTtcbiAgfVxufVxuXG4vKipcbiAqIGBiZWdpbktleXdvcmRzYCBzeW50YWN0aWMgc3VnYXJcbiAqIEB0eXBlIHtDb21waWxlckV4dH1cbiAqL1xuZnVuY3Rpb24gYmVnaW5LZXl3b3Jkcyhtb2RlLCBwYXJlbnQpIHtcbiAgaWYgKCFwYXJlbnQpIHJldHVybjtcbiAgaWYgKCFtb2RlLmJlZ2luS2V5d29yZHMpIHJldHVybjtcblxuICAvLyBmb3IgbGFuZ3VhZ2VzIHdpdGgga2V5d29yZHMgdGhhdCBpbmNsdWRlIG5vbi13b3JkIGNoYXJhY3RlcnMgY2hlY2tpbmcgZm9yXG4gIC8vIGEgd29yZCBib3VuZGFyeSBpcyBub3Qgc3VmZmljaWVudCwgc28gaW5zdGVhZCB3ZSBjaGVjayBmb3IgYSB3b3JkIGJvdW5kYXJ5XG4gIC8vIG9yIHdoaXRlc3BhY2UgLSB0aGlzIGRvZXMgbm8gaGFybSBpbiBhbnkgY2FzZSBzaW5jZSBvdXIga2V5d29yZCBlbmdpbmVcbiAgLy8gZG9lc24ndCBhbGxvdyBzcGFjZXMgaW4ga2V5d29yZHMgYW55d2F5cyBhbmQgd2Ugc3RpbGwgY2hlY2sgZm9yIHRoZSBib3VuZGFyeVxuICAvLyBmaXJzdFxuICBtb2RlLmJlZ2luID0gJ1xcXFxiKCcgKyBtb2RlLmJlZ2luS2V5d29yZHMuc3BsaXQoJyAnKS5qb2luKCd8JykgKyAnKSg/IVxcXFwuKSg/PVxcXFxifFxcXFxzKSc7XG4gIG1vZGUuX19iZWZvcmVCZWdpbiA9IHNraXBJZkhhc1ByZWNlZGluZ0RvdDtcbiAgbW9kZS5rZXl3b3JkcyA9IG1vZGUua2V5d29yZHMgfHwgbW9kZS5iZWdpbktleXdvcmRzO1xuICBkZWxldGUgbW9kZS5iZWdpbktleXdvcmRzO1xuXG4gIC8vIHByZXZlbnRzIGRvdWJsZSByZWxldmFuY2UsIHRoZSBrZXl3b3JkcyB0aGVtc2VsdmVzIHByb3ZpZGVcbiAgLy8gcmVsZXZhbmNlLCB0aGUgbW9kZSBkb2Vzbid0IG5lZWQgdG8gZG91YmxlIGl0XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlZmluZWRcbiAgaWYgKG1vZGUucmVsZXZhbmNlID09PSB1bmRlZmluZWQpIG1vZGUucmVsZXZhbmNlID0gMDtcbn1cblxuLyoqXG4gKiBBbGxvdyBgaWxsZWdhbGAgdG8gY29udGFpbiBhbiBhcnJheSBvZiBpbGxlZ2FsIHZhbHVlc1xuICogQHR5cGUge0NvbXBpbGVyRXh0fVxuICovXG5mdW5jdGlvbiBjb21waWxlSWxsZWdhbChtb2RlLCBfcGFyZW50KSB7XG4gIGlmICghQXJyYXkuaXNBcnJheShtb2RlLmlsbGVnYWwpKSByZXR1cm47XG5cbiAgbW9kZS5pbGxlZ2FsID0gZWl0aGVyKC4uLm1vZGUuaWxsZWdhbCk7XG59XG5cbi8qKlxuICogYG1hdGNoYCB0byBtYXRjaCBhIHNpbmdsZSBleHByZXNzaW9uIGZvciByZWFkYWJpbGl0eVxuICogQHR5cGUge0NvbXBpbGVyRXh0fVxuICovXG5mdW5jdGlvbiBjb21waWxlTWF0Y2gobW9kZSwgX3BhcmVudCkge1xuICBpZiAoIW1vZGUubWF0Y2gpIHJldHVybjtcbiAgaWYgKG1vZGUuYmVnaW4gfHwgbW9kZS5lbmQpIHRocm93IG5ldyBFcnJvcihcImJlZ2luICYgZW5kIGFyZSBub3Qgc3VwcG9ydGVkIHdpdGggbWF0Y2hcIik7XG5cbiAgbW9kZS5iZWdpbiA9IG1vZGUubWF0Y2g7XG4gIGRlbGV0ZSBtb2RlLm1hdGNoO1xufVxuXG4vKipcbiAqIHByb3ZpZGVzIHRoZSBkZWZhdWx0IDEgcmVsZXZhbmNlIHRvIGFsbCBtb2Rlc1xuICogQHR5cGUge0NvbXBpbGVyRXh0fVxuICovXG5mdW5jdGlvbiBjb21waWxlUmVsZXZhbmNlKG1vZGUsIF9wYXJlbnQpIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVmaW5lZFxuICBpZiAobW9kZS5yZWxldmFuY2UgPT09IHVuZGVmaW5lZCkgbW9kZS5yZWxldmFuY2UgPSAxO1xufVxuXG4vLyBhbGxvdyBiZWZvcmVNYXRjaCB0byBhY3QgYXMgYSBcInF1YWxpZmllclwiIGZvciB0aGUgbWF0Y2hcbi8vIHRoZSBmdWxsIG1hdGNoIGJlZ2luIG11c3QgYmUgW2JlZm9yZU1hdGNoXVtiZWdpbl1cbmNvbnN0IGJlZm9yZU1hdGNoRXh0ID0gKG1vZGUsIHBhcmVudCkgPT4ge1xuICBpZiAoIW1vZGUuYmVmb3JlTWF0Y2gpIHJldHVybjtcbiAgLy8gc3RhcnRzIGNvbmZsaWN0cyB3aXRoIGVuZHNQYXJlbnQgd2hpY2ggd2UgbmVlZCB0byBtYWtlIHN1cmUgdGhlIGNoaWxkXG4gIC8vIHJ1bGUgaXMgbm90IG1hdGNoZWQgbXVsdGlwbGUgdGltZXNcbiAgaWYgKG1vZGUuc3RhcnRzKSB0aHJvdyBuZXcgRXJyb3IoXCJiZWZvcmVNYXRjaCBjYW5ub3QgYmUgdXNlZCB3aXRoIHN0YXJ0c1wiKTtcblxuICBjb25zdCBvcmlnaW5hbE1vZGUgPSBPYmplY3QuYXNzaWduKHt9LCBtb2RlKTtcbiAgT2JqZWN0LmtleXMobW9kZSkuZm9yRWFjaCgoa2V5KSA9PiB7IGRlbGV0ZSBtb2RlW2tleV07IH0pO1xuXG4gIG1vZGUua2V5d29yZHMgPSBvcmlnaW5hbE1vZGUua2V5d29yZHM7XG4gIG1vZGUuYmVnaW4gPSBjb25jYXQob3JpZ2luYWxNb2RlLmJlZm9yZU1hdGNoLCBsb29rYWhlYWQob3JpZ2luYWxNb2RlLmJlZ2luKSk7XG4gIG1vZGUuc3RhcnRzID0ge1xuICAgIHJlbGV2YW5jZTogMCxcbiAgICBjb250YWluczogW1xuICAgICAgT2JqZWN0LmFzc2lnbihvcmlnaW5hbE1vZGUsIHsgZW5kc1BhcmVudDogdHJ1ZSB9KVxuICAgIF1cbiAgfTtcbiAgbW9kZS5yZWxldmFuY2UgPSAwO1xuXG4gIGRlbGV0ZSBvcmlnaW5hbE1vZGUuYmVmb3JlTWF0Y2g7XG59O1xuXG4vLyBrZXl3b3JkcyB0aGF0IHNob3VsZCBoYXZlIG5vIGRlZmF1bHQgcmVsZXZhbmNlIHZhbHVlXG5jb25zdCBDT01NT05fS0VZV09SRFMgPSBbXG4gICdvZicsXG4gICdhbmQnLFxuICAnZm9yJyxcbiAgJ2luJyxcbiAgJ25vdCcsXG4gICdvcicsXG4gICdpZicsXG4gICd0aGVuJyxcbiAgJ3BhcmVudCcsIC8vIGNvbW1vbiB2YXJpYWJsZSBuYW1lXG4gICdsaXN0JywgLy8gY29tbW9uIHZhcmlhYmxlIG5hbWVcbiAgJ3ZhbHVlJyAvLyBjb21tb24gdmFyaWFibGUgbmFtZVxuXTtcblxuY29uc3QgREVGQVVMVF9LRVlXT1JEX1NDT1BFID0gXCJrZXl3b3JkXCI7XG5cbi8qKlxuICogR2l2ZW4gcmF3IGtleXdvcmRzIGZyb20gYSBsYW5ndWFnZSBkZWZpbml0aW9uLCBjb21waWxlIHRoZW0uXG4gKlxuICogQHBhcmFtIHtzdHJpbmcgfCBSZWNvcmQ8c3RyaW5nLHN0cmluZ3xzdHJpbmdbXT4gfCBBcnJheTxzdHJpbmc+fSByYXdLZXl3b3Jkc1xuICogQHBhcmFtIHtib29sZWFufSBjYXNlSW5zZW5zaXRpdmVcbiAqL1xuZnVuY3Rpb24gY29tcGlsZUtleXdvcmRzKHJhd0tleXdvcmRzLCBjYXNlSW5zZW5zaXRpdmUsIHNjb3BlTmFtZSA9IERFRkFVTFRfS0VZV09SRF9TQ09QRSkge1xuICAvKiogQHR5cGUgS2V5d29yZERpY3QgKi9cbiAgY29uc3QgY29tcGlsZWRLZXl3b3JkcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbiAgLy8gaW5wdXQgY2FuIGJlIGEgc3RyaW5nIG9mIGtleXdvcmRzLCBhbiBhcnJheSBvZiBrZXl3b3Jkcywgb3IgYSBvYmplY3Qgd2l0aFxuICAvLyBuYW1lZCBrZXlzIHJlcHJlc2VudGluZyBzY29wZU5hbWUgKHdoaWNoIGNhbiB0aGVuIHBvaW50IHRvIGEgc3RyaW5nIG9yIGFycmF5KVxuICBpZiAodHlwZW9mIHJhd0tleXdvcmRzID09PSAnc3RyaW5nJykge1xuICAgIGNvbXBpbGVMaXN0KHNjb3BlTmFtZSwgcmF3S2V5d29yZHMuc3BsaXQoXCIgXCIpKTtcbiAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHJhd0tleXdvcmRzKSkge1xuICAgIGNvbXBpbGVMaXN0KHNjb3BlTmFtZSwgcmF3S2V5d29yZHMpO1xuICB9IGVsc2Uge1xuICAgIE9iamVjdC5rZXlzKHJhd0tleXdvcmRzKS5mb3JFYWNoKGZ1bmN0aW9uKHNjb3BlTmFtZSkge1xuICAgICAgLy8gY29sbGFwc2UgYWxsIG91ciBvYmplY3RzIGJhY2sgaW50byB0aGUgcGFyZW50IG9iamVjdFxuICAgICAgT2JqZWN0LmFzc2lnbihcbiAgICAgICAgY29tcGlsZWRLZXl3b3JkcyxcbiAgICAgICAgY29tcGlsZUtleXdvcmRzKHJhd0tleXdvcmRzW3Njb3BlTmFtZV0sIGNhc2VJbnNlbnNpdGl2ZSwgc2NvcGVOYW1lKVxuICAgICAgKTtcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gY29tcGlsZWRLZXl3b3JkcztcblxuICAvLyAtLS1cblxuICAvKipcbiAgICogQ29tcGlsZXMgYW4gaW5kaXZpZHVhbCBsaXN0IG9mIGtleXdvcmRzXG4gICAqXG4gICAqIEV4OiBcImZvciBpZiB3aGVuIHdoaWxlfDVcIlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gc2NvcGVOYW1lXG4gICAqIEBwYXJhbSB7QXJyYXk8c3RyaW5nPn0ga2V5d29yZExpc3RcbiAgICovXG4gIGZ1bmN0aW9uIGNvbXBpbGVMaXN0KHNjb3BlTmFtZSwga2V5d29yZExpc3QpIHtcbiAgICBpZiAoY2FzZUluc2Vuc2l0aXZlKSB7XG4gICAgICBrZXl3b3JkTGlzdCA9IGtleXdvcmRMaXN0Lm1hcCh4ID0+IHgudG9Mb3dlckNhc2UoKSk7XG4gICAgfVxuICAgIGtleXdvcmRMaXN0LmZvckVhY2goZnVuY3Rpb24oa2V5d29yZCkge1xuICAgICAgY29uc3QgcGFpciA9IGtleXdvcmQuc3BsaXQoJ3wnKTtcbiAgICAgIGNvbXBpbGVkS2V5d29yZHNbcGFpclswXV0gPSBbc2NvcGVOYW1lLCBzY29yZUZvcktleXdvcmQocGFpclswXSwgcGFpclsxXSldO1xuICAgIH0pO1xuICB9XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgcHJvcGVyIHNjb3JlIGZvciBhIGdpdmVuIGtleXdvcmRcbiAqXG4gKiBBbHNvIHRha2VzIGludG8gYWNjb3VudCBjb21tZW50IGtleXdvcmRzLCB3aGljaCB3aWxsIGJlIHNjb3JlZCAwIFVOTEVTU1xuICogYW5vdGhlciBzY29yZSBoYXMgYmVlbiBtYW51YWxseSBhc3NpZ25lZC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXl3b3JkXG4gKiBAcGFyYW0ge3N0cmluZ30gW3Byb3ZpZGVkU2NvcmVdXG4gKi9cbmZ1bmN0aW9uIHNjb3JlRm9yS2V5d29yZChrZXl3b3JkLCBwcm92aWRlZFNjb3JlKSB7XG4gIC8vIG1hbnVhbCBzY29yZXMgYWx3YXlzIHdpbiBvdmVyIGNvbW1vbiBrZXl3b3Jkc1xuICAvLyBzbyB5b3UgY2FuIGZvcmNlIGEgc2NvcmUgb2YgMSBpZiB5b3UgcmVhbGx5IGluc2lzdFxuICBpZiAocHJvdmlkZWRTY29yZSkge1xuICAgIHJldHVybiBOdW1iZXIocHJvdmlkZWRTY29yZSk7XG4gIH1cblxuICByZXR1cm4gY29tbW9uS2V5d29yZChrZXl3b3JkKSA/IDAgOiAxO1xufVxuXG4vKipcbiAqIERldGVybWluZXMgaWYgYSBnaXZlbiBrZXl3b3JkIGlzIGNvbW1vbiBvciBub3RcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5d29yZCAqL1xuZnVuY3Rpb24gY29tbW9uS2V5d29yZChrZXl3b3JkKSB7XG4gIHJldHVybiBDT01NT05fS0VZV09SRFMuaW5jbHVkZXMoa2V5d29yZC50b0xvd2VyQ2FzZSgpKTtcbn1cblxuLypcblxuRm9yIHRoZSByZWFzb25pbmcgYmVoaW5kIHRoaXMgcGxlYXNlIHNlZTpcbmh0dHBzOi8vZ2l0aHViLmNvbS9oaWdobGlnaHRqcy9oaWdobGlnaHQuanMvaXNzdWVzLzI4ODAjaXNzdWVjb21tZW50LTc0NzI3NTQxOVxuXG4qL1xuXG4vKipcbiAqIEB0eXBlIHtSZWNvcmQ8c3RyaW5nLCBib29sZWFuPn1cbiAqL1xuY29uc3Qgc2VlbkRlcHJlY2F0aW9ucyA9IHt9O1xuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBtZXNzYWdlXG4gKi9cbmNvbnN0IGVycm9yID0gKG1lc3NhZ2UpID0+IHtcbiAgY29uc29sZS5lcnJvcihtZXNzYWdlKTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IG1lc3NhZ2VcbiAqIEBwYXJhbSB7YW55fSBhcmdzXG4gKi9cbmNvbnN0IHdhcm4gPSAobWVzc2FnZSwgLi4uYXJncykgPT4ge1xuICBjb25zb2xlLmxvZyhgV0FSTjogJHttZXNzYWdlfWAsIC4uLmFyZ3MpO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gdmVyc2lvblxuICogQHBhcmFtIHtzdHJpbmd9IG1lc3NhZ2VcbiAqL1xuY29uc3QgZGVwcmVjYXRlZCA9ICh2ZXJzaW9uLCBtZXNzYWdlKSA9PiB7XG4gIGlmIChzZWVuRGVwcmVjYXRpb25zW2Ake3ZlcnNpb259LyR7bWVzc2FnZX1gXSkgcmV0dXJuO1xuXG4gIGNvbnNvbGUubG9nKGBEZXByZWNhdGVkIGFzIG9mICR7dmVyc2lvbn0uICR7bWVzc2FnZX1gKTtcbiAgc2VlbkRlcHJlY2F0aW9uc1tgJHt2ZXJzaW9ufS8ke21lc3NhZ2V9YF0gPSB0cnVlO1xufTtcblxuLyogZXNsaW50LWRpc2FibGUgbm8tdGhyb3ctbGl0ZXJhbCAqL1xuXG4vKipcbkB0eXBlZGVmIHtpbXBvcnQoJ2hpZ2hsaWdodC5qcycpLkNvbXBpbGVkTW9kZX0gQ29tcGlsZWRNb2RlXG4qL1xuXG5jb25zdCBNdWx0aUNsYXNzRXJyb3IgPSBuZXcgRXJyb3IoKTtcblxuLyoqXG4gKiBSZW51bWJlcnMgbGFiZWxlZCBzY29wZSBuYW1lcyB0byBhY2NvdW50IGZvciBhZGRpdGlvbmFsIGlubmVyIG1hdGNoXG4gKiBncm91cHMgdGhhdCBvdGhlcndpc2Ugd291bGQgYnJlYWsgZXZlcnl0aGluZy5cbiAqXG4gKiBMZXRzIHNheSB3ZSAzIG1hdGNoIHNjb3BlczpcbiAqXG4gKiAgIHsgMSA9PiAuLi4sIDIgPT4gLi4uLCAzID0+IC4uLiB9XG4gKlxuICogU28gd2hhdCB3ZSBuZWVkIGlzIGEgY2xlYW4gbWF0Y2ggbGlrZSB0aGlzOlxuICpcbiAqICAgKGEpKGIpKGMpID0+IFsgXCJhXCIsIFwiYlwiLCBcImNcIiBdXG4gKlxuICogQnV0IHRoaXMgZmFsbHMgYXBhcnQgd2l0aCBpbm5lciBtYXRjaCBncm91cHM6XG4gKlxuICogKGEpKCgoYikpKShjKSA9PiBbXCJhXCIsIFwiYlwiLCBcImJcIiwgXCJiXCIsIFwiY1wiIF1cbiAqXG4gKiBPdXIgc2NvcGVzIGFyZSBub3cgXCJvdXQgb2YgYWxpZ25tZW50XCIgYW5kIHdlJ3JlIHJlcGVhdGluZyBgYmAgMyB0aW1lcy5cbiAqIFdoYXQgbmVlZHMgdG8gaGFwcGVuIGlzIHRoZSBudW1iZXJzIGFyZSByZW1hcHBlZDpcbiAqXG4gKiAgIHsgMSA9PiAuLi4sIDIgPT4gLi4uLCA1ID0+IC4uLiB9XG4gKlxuICogV2UgYWxzbyBuZWVkIHRvIGtub3cgdGhhdCB0aGUgT05MWSBncm91cHMgdGhhdCBzaG91bGQgYmUgb3V0cHV0XG4gKiBhcmUgMSwgMiwgYW5kIDUuICBUaGlzIGZ1bmN0aW9uIGhhbmRsZXMgdGhpcyBiZWhhdmlvci5cbiAqXG4gKiBAcGFyYW0ge0NvbXBpbGVkTW9kZX0gbW9kZVxuICogQHBhcmFtIHtBcnJheTxSZWdFeHA+fSByZWdleGVzXG4gKiBAcGFyYW0ge3trZXk6IFwiYmVnaW5TY29wZVwifFwiZW5kU2NvcGVcIn19IG9wdHNcbiAqL1xuZnVuY3Rpb24gcmVtYXBTY29wZU5hbWVzKG1vZGUsIHJlZ2V4ZXMsIHsga2V5IH0pIHtcbiAgbGV0IG9mZnNldCA9IDA7XG4gIGNvbnN0IHNjb3BlTmFtZXMgPSBtb2RlW2tleV07XG4gIC8qKiBAdHlwZSBSZWNvcmQ8bnVtYmVyLGJvb2xlYW4+ICovXG4gIGNvbnN0IGVtaXQgPSB7fTtcbiAgLyoqIEB0eXBlIFJlY29yZDxudW1iZXIsc3RyaW5nPiAqL1xuICBjb25zdCBwb3NpdGlvbnMgPSB7fTtcblxuICBmb3IgKGxldCBpID0gMTsgaSA8PSByZWdleGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgcG9zaXRpb25zW2kgKyBvZmZzZXRdID0gc2NvcGVOYW1lc1tpXTtcbiAgICBlbWl0W2kgKyBvZmZzZXRdID0gdHJ1ZTtcbiAgICBvZmZzZXQgKz0gY291bnRNYXRjaEdyb3VwcyhyZWdleGVzW2kgLSAxXSk7XG4gIH1cbiAgLy8gd2UgdXNlIF9lbWl0IHRvIGtlZXAgdHJhY2sgb2Ygd2hpY2ggbWF0Y2ggZ3JvdXBzIGFyZSBcInRvcC1sZXZlbFwiIHRvIGF2b2lkIGRvdWJsZVxuICAvLyBvdXRwdXQgZnJvbSBpbnNpZGUgbWF0Y2ggZ3JvdXBzXG4gIG1vZGVba2V5XSA9IHBvc2l0aW9ucztcbiAgbW9kZVtrZXldLl9lbWl0ID0gZW1pdDtcbiAgbW9kZVtrZXldLl9tdWx0aSA9IHRydWU7XG59XG5cbi8qKlxuICogQHBhcmFtIHtDb21waWxlZE1vZGV9IG1vZGVcbiAqL1xuZnVuY3Rpb24gYmVnaW5NdWx0aUNsYXNzKG1vZGUpIHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KG1vZGUuYmVnaW4pKSByZXR1cm47XG5cbiAgaWYgKG1vZGUuc2tpcCB8fCBtb2RlLmV4Y2x1ZGVCZWdpbiB8fCBtb2RlLnJldHVybkJlZ2luKSB7XG4gICAgZXJyb3IoXCJza2lwLCBleGNsdWRlQmVnaW4sIHJldHVybkJlZ2luIG5vdCBjb21wYXRpYmxlIHdpdGggYmVnaW5TY29wZToge31cIik7XG4gICAgdGhyb3cgTXVsdGlDbGFzc0Vycm9yO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBtb2RlLmJlZ2luU2NvcGUgIT09IFwib2JqZWN0XCIgfHwgbW9kZS5iZWdpblNjb3BlID09PSBudWxsKSB7XG4gICAgZXJyb3IoXCJiZWdpblNjb3BlIG11c3QgYmUgb2JqZWN0XCIpO1xuICAgIHRocm93IE11bHRpQ2xhc3NFcnJvcjtcbiAgfVxuXG4gIHJlbWFwU2NvcGVOYW1lcyhtb2RlLCBtb2RlLmJlZ2luLCB7a2V5OiBcImJlZ2luU2NvcGVcIn0pO1xuICBtb2RlLmJlZ2luID0gX3Jld3JpdGVCYWNrcmVmZXJlbmNlcyhtb2RlLmJlZ2luLCB7IGpvaW5XaXRoOiBcIlwiIH0pO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7Q29tcGlsZWRNb2RlfSBtb2RlXG4gKi9cbmZ1bmN0aW9uIGVuZE11bHRpQ2xhc3MobW9kZSkge1xuICBpZiAoIUFycmF5LmlzQXJyYXkobW9kZS5lbmQpKSByZXR1cm47XG5cbiAgaWYgKG1vZGUuc2tpcCB8fCBtb2RlLmV4Y2x1ZGVFbmQgfHwgbW9kZS5yZXR1cm5FbmQpIHtcbiAgICBlcnJvcihcInNraXAsIGV4Y2x1ZGVFbmQsIHJldHVybkVuZCBub3QgY29tcGF0aWJsZSB3aXRoIGVuZFNjb3BlOiB7fVwiKTtcbiAgICB0aHJvdyBNdWx0aUNsYXNzRXJyb3I7XG4gIH1cblxuICBpZiAodHlwZW9mIG1vZGUuZW5kU2NvcGUgIT09IFwib2JqZWN0XCIgfHwgbW9kZS5lbmRTY29wZSA9PT0gbnVsbCkge1xuICAgIGVycm9yKFwiZW5kU2NvcGUgbXVzdCBiZSBvYmplY3RcIik7XG4gICAgdGhyb3cgTXVsdGlDbGFzc0Vycm9yO1xuICB9XG5cbiAgcmVtYXBTY29wZU5hbWVzKG1vZGUsIG1vZGUuZW5kLCB7a2V5OiBcImVuZFNjb3BlXCJ9KTtcbiAgbW9kZS5lbmQgPSBfcmV3cml0ZUJhY2tyZWZlcmVuY2VzKG1vZGUuZW5kLCB7IGpvaW5XaXRoOiBcIlwiIH0pO1xufVxuXG4vKipcbiAqIHRoaXMgZXhpc3RzIG9ubHkgdG8gYWxsb3cgYHNjb3BlOiB7fWAgdG8gYmUgdXNlZCBiZXNpZGUgYG1hdGNoOmBcbiAqIE90aGVyd2lzZSBgYmVnaW5TY29wZWAgd291bGQgbmVjZXNzYXJ5IGFuZCB0aGF0IHdvdWxkIGxvb2sgd2VpcmRcblxuICB7XG4gICAgbWF0Y2g6IFsgL2RlZi8sIC9cXHcrLyBdXG4gICAgc2NvcGU6IHsgMTogXCJrZXl3b3JkXCIgLCAyOiBcInRpdGxlXCIgfVxuICB9XG5cbiAqIEBwYXJhbSB7Q29tcGlsZWRNb2RlfSBtb2RlXG4gKi9cbmZ1bmN0aW9uIHNjb3BlU3VnYXIobW9kZSkge1xuICBpZiAobW9kZS5zY29wZSAmJiB0eXBlb2YgbW9kZS5zY29wZSA9PT0gXCJvYmplY3RcIiAmJiBtb2RlLnNjb3BlICE9PSBudWxsKSB7XG4gICAgbW9kZS5iZWdpblNjb3BlID0gbW9kZS5zY29wZTtcbiAgICBkZWxldGUgbW9kZS5zY29wZTtcbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7Q29tcGlsZWRNb2RlfSBtb2RlXG4gKi9cbmZ1bmN0aW9uIE11bHRpQ2xhc3MobW9kZSkge1xuICBzY29wZVN1Z2FyKG1vZGUpO1xuXG4gIGlmICh0eXBlb2YgbW9kZS5iZWdpblNjb3BlID09PSBcInN0cmluZ1wiKSB7XG4gICAgbW9kZS5iZWdpblNjb3BlID0geyBfd3JhcDogbW9kZS5iZWdpblNjb3BlIH07XG4gIH1cbiAgaWYgKHR5cGVvZiBtb2RlLmVuZFNjb3BlID09PSBcInN0cmluZ1wiKSB7XG4gICAgbW9kZS5lbmRTY29wZSA9IHsgX3dyYXA6IG1vZGUuZW5kU2NvcGUgfTtcbiAgfVxuXG4gIGJlZ2luTXVsdGlDbGFzcyhtb2RlKTtcbiAgZW5kTXVsdGlDbGFzcyhtb2RlKTtcbn1cblxuLyoqXG5AdHlwZWRlZiB7aW1wb3J0KCdoaWdobGlnaHQuanMnKS5Nb2RlfSBNb2RlXG5AdHlwZWRlZiB7aW1wb3J0KCdoaWdobGlnaHQuanMnKS5Db21waWxlZE1vZGV9IENvbXBpbGVkTW9kZVxuQHR5cGVkZWYge2ltcG9ydCgnaGlnaGxpZ2h0LmpzJykuTGFuZ3VhZ2V9IExhbmd1YWdlXG5AdHlwZWRlZiB7aW1wb3J0KCdoaWdobGlnaHQuanMnKS5ITEpTUGx1Z2lufSBITEpTUGx1Z2luXG5AdHlwZWRlZiB7aW1wb3J0KCdoaWdobGlnaHQuanMnKS5Db21waWxlZExhbmd1YWdlfSBDb21waWxlZExhbmd1YWdlXG4qL1xuXG4vLyBjb21waWxhdGlvblxuXG4vKipcbiAqIENvbXBpbGVzIGEgbGFuZ3VhZ2UgZGVmaW5pdGlvbiByZXN1bHRcbiAqXG4gKiBHaXZlbiB0aGUgcmF3IHJlc3VsdCBvZiBhIGxhbmd1YWdlIGRlZmluaXRpb24gKExhbmd1YWdlKSwgY29tcGlsZXMgdGhpcyBzb1xuICogdGhhdCBpdCBpcyByZWFkeSBmb3IgaGlnaGxpZ2h0aW5nIGNvZGUuXG4gKiBAcGFyYW0ge0xhbmd1YWdlfSBsYW5ndWFnZVxuICogQHJldHVybnMge0NvbXBpbGVkTGFuZ3VhZ2V9XG4gKi9cbmZ1bmN0aW9uIGNvbXBpbGVMYW5ndWFnZShsYW5ndWFnZSkge1xuICAvKipcbiAgICogQnVpbGRzIGEgcmVnZXggd2l0aCB0aGUgY2FzZSBzZW5zaXRpdml0eSBvZiB0aGUgY3VycmVudCBsYW5ndWFnZVxuICAgKlxuICAgKiBAcGFyYW0ge1JlZ0V4cCB8IHN0cmluZ30gdmFsdWVcbiAgICogQHBhcmFtIHtib29sZWFufSBbZ2xvYmFsXVxuICAgKi9cbiAgZnVuY3Rpb24gbGFuZ1JlKHZhbHVlLCBnbG9iYWwpIHtcbiAgICByZXR1cm4gbmV3IFJlZ0V4cChcbiAgICAgIHNvdXJjZSh2YWx1ZSksXG4gICAgICAnbScgKyAobGFuZ3VhZ2UuY2FzZV9pbnNlbnNpdGl2ZSA/ICdpJyA6ICcnKSArIChnbG9iYWwgPyAnZycgOiAnJylcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAgU3RvcmVzIG11bHRpcGxlIHJlZ3VsYXIgZXhwcmVzc2lvbnMgYW5kIGFsbG93cyB5b3UgdG8gcXVpY2tseSBzZWFyY2ggZm9yXG4gICAgdGhlbSBhbGwgaW4gYSBzdHJpbmcgc2ltdWx0YW5lb3VzbHkgLSByZXR1cm5pbmcgdGhlIGZpcnN0IG1hdGNoLiAgSXQgZG9lc1xuICAgIHRoaXMgYnkgY3JlYXRpbmcgYSBodWdlIChhfGJ8YykgcmVnZXggLSBlYWNoIGluZGl2aWR1YWwgaXRlbSB3cmFwcGVkIHdpdGggKClcbiAgICBhbmQgam9pbmVkIGJ5IGB8YCAtIHVzaW5nIG1hdGNoIGdyb3VwcyB0byB0cmFjayBwb3NpdGlvbi4gIFdoZW4gYSBtYXRjaCBpc1xuICAgIGZvdW5kIGNoZWNraW5nIHdoaWNoIHBvc2l0aW9uIGluIHRoZSBhcnJheSBoYXMgY29udGVudCBhbGxvd3MgdXMgdG8gZmlndXJlXG4gICAgb3V0IHdoaWNoIG9mIHRoZSBvcmlnaW5hbCByZWdleGVzIC8gbWF0Y2ggZ3JvdXBzIHRyaWdnZXJlZCB0aGUgbWF0Y2guXG5cbiAgICBUaGUgbWF0Y2ggb2JqZWN0IGl0c2VsZiAodGhlIHJlc3VsdCBvZiBgUmVnZXguZXhlY2ApIGlzIHJldHVybmVkIGJ1dCBhbHNvXG4gICAgZW5oYW5jZWQgYnkgbWVyZ2luZyBpbiBhbnkgbWV0YS1kYXRhIHRoYXQgd2FzIHJlZ2lzdGVyZWQgd2l0aCB0aGUgcmVnZXguXG4gICAgVGhpcyBpcyBob3cgd2Uga2VlcCB0cmFjayBvZiB3aGljaCBtb2RlIG1hdGNoZWQsIGFuZCB3aGF0IHR5cGUgb2YgcnVsZVxuICAgIChgaWxsZWdhbGAsIGBiZWdpbmAsIGVuZCwgZXRjKS5cbiAgKi9cbiAgY2xhc3MgTXVsdGlSZWdleCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICB0aGlzLm1hdGNoSW5kZXhlcyA9IHt9O1xuICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgdGhpcy5yZWdleGVzID0gW107XG4gICAgICB0aGlzLm1hdGNoQXQgPSAxO1xuICAgICAgdGhpcy5wb3NpdGlvbiA9IDA7XG4gICAgfVxuXG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIGFkZFJ1bGUocmUsIG9wdHMpIHtcbiAgICAgIG9wdHMucG9zaXRpb24gPSB0aGlzLnBvc2l0aW9uKys7XG4gICAgICAvLyBAdHMtaWdub3JlXG4gICAgICB0aGlzLm1hdGNoSW5kZXhlc1t0aGlzLm1hdGNoQXRdID0gb3B0cztcbiAgICAgIHRoaXMucmVnZXhlcy5wdXNoKFtvcHRzLCByZV0pO1xuICAgICAgdGhpcy5tYXRjaEF0ICs9IGNvdW50TWF0Y2hHcm91cHMocmUpICsgMTtcbiAgICB9XG5cbiAgICBjb21waWxlKCkge1xuICAgICAgaWYgKHRoaXMucmVnZXhlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgLy8gYXZvaWRzIHRoZSBuZWVkIHRvIGNoZWNrIGxlbmd0aCBldmVyeSB0aW1lIGV4ZWMgaXMgY2FsbGVkXG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgdGhpcy5leGVjID0gKCkgPT4gbnVsbDtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHRlcm1pbmF0b3JzID0gdGhpcy5yZWdleGVzLm1hcChlbCA9PiBlbFsxXSk7XG4gICAgICB0aGlzLm1hdGNoZXJSZSA9IGxhbmdSZShfcmV3cml0ZUJhY2tyZWZlcmVuY2VzKHRlcm1pbmF0b3JzLCB7IGpvaW5XaXRoOiAnfCcgfSksIHRydWUpO1xuICAgICAgdGhpcy5sYXN0SW5kZXggPSAwO1xuICAgIH1cblxuICAgIC8qKiBAcGFyYW0ge3N0cmluZ30gcyAqL1xuICAgIGV4ZWMocykge1xuICAgICAgdGhpcy5tYXRjaGVyUmUubGFzdEluZGV4ID0gdGhpcy5sYXN0SW5kZXg7XG4gICAgICBjb25zdCBtYXRjaCA9IHRoaXMubWF0Y2hlclJlLmV4ZWMocyk7XG4gICAgICBpZiAoIW1hdGNoKSB7IHJldHVybiBudWxsOyB9XG5cbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlZmluZWRcbiAgICAgIGNvbnN0IGkgPSBtYXRjaC5maW5kSW5kZXgoKGVsLCBpKSA9PiBpID4gMCAmJiBlbCAhPT0gdW5kZWZpbmVkKTtcbiAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgIGNvbnN0IG1hdGNoRGF0YSA9IHRoaXMubWF0Y2hJbmRleGVzW2ldO1xuICAgICAgLy8gdHJpbSBvZmYgYW55IGVhcmxpZXIgbm9uLXJlbGV2YW50IG1hdGNoIGdyb3VwcyAoaWUsIHRoZSBvdGhlciByZWdleFxuICAgICAgLy8gbWF0Y2ggZ3JvdXBzIHRoYXQgbWFrZSB1cCB0aGUgbXVsdGktbWF0Y2hlcilcbiAgICAgIG1hdGNoLnNwbGljZSgwLCBpKTtcblxuICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24obWF0Y2gsIG1hdGNoRGF0YSk7XG4gICAgfVxuICB9XG5cbiAgLypcbiAgICBDcmVhdGVkIHRvIHNvbHZlIHRoZSBrZXkgZGVmaWNpZW50bHkgd2l0aCBNdWx0aVJlZ2V4IC0gdGhlcmUgaXMgbm8gd2F5IHRvXG4gICAgdGVzdCBmb3IgbXVsdGlwbGUgbWF0Y2hlcyBhdCBhIHNpbmdsZSBsb2NhdGlvbi4gIFdoeSB3b3VsZCB3ZSBuZWVkIHRvIGRvXG4gICAgdGhhdD8gIEluIHRoZSBmdXR1cmUgYSBtb3JlIGR5bmFtaWMgZW5naW5lIHdpbGwgYWxsb3cgY2VydGFpbiBtYXRjaGVzIHRvIGJlXG4gICAgaWdub3JlZC4gIEFuIGV4YW1wbGU6IGlmIHdlIG1hdGNoZWQgc2F5IHRoZSAzcmQgcmVnZXggaW4gYSBsYXJnZSBncm91cCBidXRcbiAgICBkZWNpZGVkIHRvIGlnbm9yZSBpdCAtIHdlJ2QgbmVlZCB0byBzdGFydGVkIHRlc3RpbmcgYWdhaW4gYXQgdGhlIDR0aFxuICAgIHJlZ2V4Li4uIGJ1dCBNdWx0aVJlZ2V4IGl0c2VsZiBnaXZlcyB1cyBubyByZWFsIHdheSB0byBkbyB0aGF0LlxuXG4gICAgU28gd2hhdCB0aGlzIGNsYXNzIGNyZWF0ZXMgTXVsdGlSZWdleHMgb24gdGhlIGZseSBmb3Igd2hhdGV2ZXIgc2VhcmNoXG4gICAgcG9zaXRpb24gdGhleSBhcmUgbmVlZGVkLlxuXG4gICAgTk9URTogVGhlc2UgYWRkaXRpb25hbCBNdWx0aVJlZ2V4IG9iamVjdHMgYXJlIGNyZWF0ZWQgZHluYW1pY2FsbHkuICBGb3IgbW9zdFxuICAgIGdyYW1tYXJzIG1vc3Qgb2YgdGhlIHRpbWUgd2Ugd2lsbCBuZXZlciBhY3R1YWxseSBuZWVkIGFueXRoaW5nIG1vcmUgdGhhbiB0aGVcbiAgICBmaXJzdCBNdWx0aVJlZ2V4IC0gc28gdGhpcyBzaG91bGRuJ3QgaGF2ZSB0b28gbXVjaCBvdmVyaGVhZC5cblxuICAgIFNheSB0aGlzIGlzIG91ciBzZWFyY2ggZ3JvdXAsIGFuZCB3ZSBtYXRjaCByZWdleDMsIGJ1dCB3aXNoIHRvIGlnbm9yZSBpdC5cblxuICAgICAgcmVnZXgxIHwgcmVnZXgyIHwgcmVnZXgzIHwgcmVnZXg0IHwgcmVnZXg1ICAgICcgaWUsIHN0YXJ0QXQgPSAwXG5cbiAgICBXaGF0IHdlIG5lZWQgaXMgYSBuZXcgTXVsdGlSZWdleCB0aGF0IG9ubHkgaW5jbHVkZXMgdGhlIHJlbWFpbmluZ1xuICAgIHBvc3NpYmlsaXRpZXM6XG5cbiAgICAgIHJlZ2V4NCB8IHJlZ2V4NSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnIGllLCBzdGFydEF0ID0gM1xuXG4gICAgVGhpcyBjbGFzcyB3cmFwcyBhbGwgdGhhdCBjb21wbGV4aXR5IHVwIGluIGEgc2ltcGxlIEFQSS4uLiBgc3RhcnRBdGAgZGVjaWRlc1xuICAgIHdoZXJlIGluIHRoZSBhcnJheSBvZiBleHByZXNzaW9ucyB0byBzdGFydCBkb2luZyB0aGUgbWF0Y2hpbmcuIEl0XG4gICAgYXV0by1pbmNyZW1lbnRzLCBzbyBpZiBhIG1hdGNoIGlzIGZvdW5kIGF0IHBvc2l0aW9uIDIsIHRoZW4gc3RhcnRBdCB3aWxsIGJlXG4gICAgc2V0IHRvIDMuICBJZiB0aGUgZW5kIGlzIHJlYWNoZWQgc3RhcnRBdCB3aWxsIHJldHVybiB0byAwLlxuXG4gICAgTU9TVCBvZiB0aGUgdGltZSB0aGUgcGFyc2VyIHdpbGwgYmUgc2V0dGluZyBzdGFydEF0IG1hbnVhbGx5IHRvIDAuXG4gICovXG4gIGNsYXNzIFJlc3VtYWJsZU11bHRpUmVnZXgge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgdGhpcy5ydWxlcyA9IFtdO1xuICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgdGhpcy5tdWx0aVJlZ2V4ZXMgPSBbXTtcbiAgICAgIHRoaXMuY291bnQgPSAwO1xuXG4gICAgICB0aGlzLmxhc3RJbmRleCA9IDA7XG4gICAgICB0aGlzLnJlZ2V4SW5kZXggPSAwO1xuICAgIH1cblxuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBnZXRNYXRjaGVyKGluZGV4KSB7XG4gICAgICBpZiAodGhpcy5tdWx0aVJlZ2V4ZXNbaW5kZXhdKSByZXR1cm4gdGhpcy5tdWx0aVJlZ2V4ZXNbaW5kZXhdO1xuXG4gICAgICBjb25zdCBtYXRjaGVyID0gbmV3IE11bHRpUmVnZXgoKTtcbiAgICAgIHRoaXMucnVsZXMuc2xpY2UoaW5kZXgpLmZvckVhY2goKFtyZSwgb3B0c10pID0+IG1hdGNoZXIuYWRkUnVsZShyZSwgb3B0cykpO1xuICAgICAgbWF0Y2hlci5jb21waWxlKCk7XG4gICAgICB0aGlzLm11bHRpUmVnZXhlc1tpbmRleF0gPSBtYXRjaGVyO1xuICAgICAgcmV0dXJuIG1hdGNoZXI7XG4gICAgfVxuXG4gICAgcmVzdW1pbmdTY2FuQXRTYW1lUG9zaXRpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5yZWdleEluZGV4ICE9PSAwO1xuICAgIH1cblxuICAgIGNvbnNpZGVyQWxsKCkge1xuICAgICAgdGhpcy5yZWdleEluZGV4ID0gMDtcbiAgICB9XG5cbiAgICAvLyBAdHMtaWdub3JlXG4gICAgYWRkUnVsZShyZSwgb3B0cykge1xuICAgICAgdGhpcy5ydWxlcy5wdXNoKFtyZSwgb3B0c10pO1xuICAgICAgaWYgKG9wdHMudHlwZSA9PT0gXCJiZWdpblwiKSB0aGlzLmNvdW50Kys7XG4gICAgfVxuXG4gICAgLyoqIEBwYXJhbSB7c3RyaW5nfSBzICovXG4gICAgZXhlYyhzKSB7XG4gICAgICBjb25zdCBtID0gdGhpcy5nZXRNYXRjaGVyKHRoaXMucmVnZXhJbmRleCk7XG4gICAgICBtLmxhc3RJbmRleCA9IHRoaXMubGFzdEluZGV4O1xuICAgICAgbGV0IHJlc3VsdCA9IG0uZXhlYyhzKTtcblxuICAgICAgLy8gVGhlIGZvbGxvd2luZyBpcyBiZWNhdXNlIHdlIGhhdmUgbm8gZWFzeSB3YXkgdG8gc2F5IFwicmVzdW1lIHNjYW5uaW5nIGF0IHRoZVxuICAgICAgLy8gZXhpc3RpbmcgcG9zaXRpb24gYnV0IGFsc28gc2tpcCB0aGUgY3VycmVudCBydWxlIE9OTFlcIi4gV2hhdCBoYXBwZW5zIGlzXG4gICAgICAvLyBhbGwgcHJpb3IgcnVsZXMgYXJlIGFsc28gc2tpcHBlZCB3aGljaCBjYW4gcmVzdWx0IGluIG1hdGNoaW5nIHRoZSB3cm9uZ1xuICAgICAgLy8gdGhpbmcuIEV4YW1wbGUgb2YgbWF0Y2hpbmcgXCJib29nZXJcIjpcblxuICAgICAgLy8gb3VyIG1hdGNoZXIgaXMgW3N0cmluZywgXCJib29nZXJcIiwgbnVtYmVyXVxuICAgICAgLy9cbiAgICAgIC8vIC4uLi5ib29nZXIuLi4uXG5cbiAgICAgIC8vIGlmIFwiYm9vZ2VyXCIgaXMgaWdub3JlZCB0aGVuIHdlJ2QgcmVhbGx5IG5lZWQgYSByZWdleCB0byBzY2FuIGZyb20gdGhlXG4gICAgICAvLyBTQU1FIHBvc2l0aW9uIGZvciBvbmx5OiBbc3RyaW5nLCBudW1iZXJdIGJ1dCBpZ25vcmluZyBcImJvb2dlclwiIChpZiBpdFxuICAgICAgLy8gd2FzIHRoZSBmaXJzdCBtYXRjaCksIGEgc2ltcGxlIHJlc3VtZSB3b3VsZCBzY2FuIGFoZWFkIHdobyBrbm93cyBob3dcbiAgICAgIC8vIGZhciBsb29raW5nIG9ubHkgZm9yIFwibnVtYmVyXCIsIGlnbm9yaW5nIHBvdGVudGlhbCBzdHJpbmcgbWF0Y2hlcyAob3JcbiAgICAgIC8vIGZ1dHVyZSBcImJvb2dlclwiIG1hdGNoZXMgdGhhdCBtaWdodCBiZSB2YWxpZC4pXG5cbiAgICAgIC8vIFNvIHdoYXQgd2UgZG86IFdlIGV4ZWN1dGUgdHdvIG1hdGNoZXJzLCBvbmUgcmVzdW1pbmcgYXQgdGhlIHNhbWVcbiAgICAgIC8vIHBvc2l0aW9uLCBidXQgdGhlIHNlY29uZCBmdWxsIG1hdGNoZXIgc3RhcnRpbmcgYXQgdGhlIHBvc2l0aW9uIGFmdGVyOlxuXG4gICAgICAvLyAgICAgLy0tLSByZXN1bWUgZmlyc3QgcmVnZXggbWF0Y2ggaGVyZSAoZm9yIFtudW1iZXJdKVxuICAgICAgLy8gICAgIHwvLS0tLSBmdWxsIG1hdGNoIGhlcmUgZm9yIFtzdHJpbmcsIFwiYm9vZ2VyXCIsIG51bWJlcl1cbiAgICAgIC8vICAgICB2dlxuICAgICAgLy8gLi4uLmJvb2dlci4uLi5cblxuICAgICAgLy8gV2hpY2ggZXZlciByZXN1bHRzIGluIGEgbWF0Y2ggZmlyc3QgaXMgdGhlbiB1c2VkLiBTbyB0aGlzIDMtNCBzdGVwXG4gICAgICAvLyBwcm9jZXNzIGVzc2VudGlhbGx5IGFsbG93cyB1cyB0byBzYXkgXCJtYXRjaCBhdCB0aGlzIHBvc2l0aW9uLCBleGNsdWRpbmdcbiAgICAgIC8vIGEgcHJpb3IgcnVsZSB0aGF0IHdhcyBpZ25vcmVkXCIuXG4gICAgICAvL1xuICAgICAgLy8gMS4gTWF0Y2ggXCJib29nZXJcIiBmaXJzdCwgaWdub3JlLiBBbHNvIHByb3ZlcyB0aGF0IFtzdHJpbmddIGRvZXMgbm9uIG1hdGNoLlxuICAgICAgLy8gMi4gUmVzdW1lIG1hdGNoaW5nIGZvciBbbnVtYmVyXVxuICAgICAgLy8gMy4gTWF0Y2ggYXQgaW5kZXggKyAxIGZvciBbc3RyaW5nLCBcImJvb2dlclwiLCBudW1iZXJdXG4gICAgICAvLyA0LiBJZiAjMiBhbmQgIzMgcmVzdWx0IGluIG1hdGNoZXMsIHdoaWNoIGNhbWUgZmlyc3Q/XG4gICAgICBpZiAodGhpcy5yZXN1bWluZ1NjYW5BdFNhbWVQb3NpdGlvbigpKSB7XG4gICAgICAgIGlmIChyZXN1bHQgJiYgcmVzdWx0LmluZGV4ID09PSB0aGlzLmxhc3RJbmRleCkgOyBlbHNlIHsgLy8gdXNlIHRoZSBzZWNvbmQgbWF0Y2hlciByZXN1bHRcbiAgICAgICAgICBjb25zdCBtMiA9IHRoaXMuZ2V0TWF0Y2hlcigwKTtcbiAgICAgICAgICBtMi5sYXN0SW5kZXggPSB0aGlzLmxhc3RJbmRleCArIDE7XG4gICAgICAgICAgcmVzdWx0ID0gbTIuZXhlYyhzKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgIHRoaXMucmVnZXhJbmRleCArPSByZXN1bHQucG9zaXRpb24gKyAxO1xuICAgICAgICBpZiAodGhpcy5yZWdleEluZGV4ID09PSB0aGlzLmNvdW50KSB7XG4gICAgICAgICAgLy8gd3JhcC1hcm91bmQgdG8gY29uc2lkZXJpbmcgYWxsIG1hdGNoZXMgYWdhaW5cbiAgICAgICAgICB0aGlzLmNvbnNpZGVyQWxsKCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogR2l2ZW4gYSBtb2RlLCBidWlsZHMgYSBodWdlIFJlc3VtYWJsZU11bHRpUmVnZXggdGhhdCBjYW4gYmUgdXNlZCB0byB3YWxrXG4gICAqIHRoZSBjb250ZW50IGFuZCBmaW5kIG1hdGNoZXMuXG4gICAqXG4gICAqIEBwYXJhbSB7Q29tcGlsZWRNb2RlfSBtb2RlXG4gICAqIEByZXR1cm5zIHtSZXN1bWFibGVNdWx0aVJlZ2V4fVxuICAgKi9cbiAgZnVuY3Rpb24gYnVpbGRNb2RlUmVnZXgobW9kZSkge1xuICAgIGNvbnN0IG1tID0gbmV3IFJlc3VtYWJsZU11bHRpUmVnZXgoKTtcblxuICAgIG1vZGUuY29udGFpbnMuZm9yRWFjaCh0ZXJtID0+IG1tLmFkZFJ1bGUodGVybS5iZWdpbiwgeyBydWxlOiB0ZXJtLCB0eXBlOiBcImJlZ2luXCIgfSkpO1xuXG4gICAgaWYgKG1vZGUudGVybWluYXRvckVuZCkge1xuICAgICAgbW0uYWRkUnVsZShtb2RlLnRlcm1pbmF0b3JFbmQsIHsgdHlwZTogXCJlbmRcIiB9KTtcbiAgICB9XG4gICAgaWYgKG1vZGUuaWxsZWdhbCkge1xuICAgICAgbW0uYWRkUnVsZShtb2RlLmlsbGVnYWwsIHsgdHlwZTogXCJpbGxlZ2FsXCIgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG1tO1xuICB9XG5cbiAgLyoqIHNraXAgdnMgYWJvcnQgdnMgaWdub3JlXG4gICAqXG4gICAqIEBza2lwICAgLSBUaGUgbW9kZSBpcyBzdGlsbCBlbnRlcmVkIGFuZCBleGl0ZWQgbm9ybWFsbHkgKGFuZCBjb250YWlucyBydWxlcyBhcHBseSksXG4gICAqICAgICAgICAgICBidXQgYWxsIGNvbnRlbnQgaXMgaGVsZCBhbmQgYWRkZWQgdG8gdGhlIHBhcmVudCBidWZmZXIgcmF0aGVyIHRoYW4gYmVpbmdcbiAgICogICAgICAgICAgIG91dHB1dCB3aGVuIHRoZSBtb2RlIGVuZHMuICBNb3N0bHkgdXNlZCB3aXRoIGBzdWJsYW5ndWFnZWAgdG8gYnVpbGQgdXBcbiAgICogICAgICAgICAgIGEgc2luZ2xlIGxhcmdlIGJ1ZmZlciB0aGFuIGNhbiBiZSBwYXJzZWQgYnkgc3VibGFuZ3VhZ2UuXG4gICAqXG4gICAqICAgICAgICAgICAgIC0gVGhlIG1vZGUgYmVnaW4gYW5kcyBlbmRzIG5vcm1hbGx5LlxuICAgKiAgICAgICAgICAgICAtIENvbnRlbnQgbWF0Y2hlZCBpcyBhZGRlZCB0byB0aGUgcGFyZW50IG1vZGUgYnVmZmVyLlxuICAgKiAgICAgICAgICAgICAtIFRoZSBwYXJzZXIgY3Vyc29yIGlzIG1vdmVkIGZvcndhcmQgbm9ybWFsbHkuXG4gICAqXG4gICAqIEBhYm9ydCAgLSBBIGhhY2sgcGxhY2Vob2xkZXIgdW50aWwgd2UgaGF2ZSBpZ25vcmUuICBBYm9ydHMgdGhlIG1vZGUgKGFzIGlmIGl0XG4gICAqICAgICAgICAgICBuZXZlciBtYXRjaGVkKSBidXQgRE9FUyBOT1QgY29udGludWUgdG8gbWF0Y2ggc3Vic2VxdWVudCBgY29udGFpbnNgXG4gICAqICAgICAgICAgICBtb2Rlcy4gIEFib3J0IGlzIGJhZC9zdWJvcHRpbWFsIGJlY2F1c2UgaXQgY2FuIHJlc3VsdCBpbiBtb2Rlc1xuICAgKiAgICAgICAgICAgZmFydGhlciBkb3duIG5vdCBnZXR0aW5nIGFwcGxpZWQgYmVjYXVzZSBhbiBlYXJsaWVyIHJ1bGUgZWF0cyB0aGVcbiAgICogICAgICAgICAgIGNvbnRlbnQgYnV0IHRoZW4gYWJvcnRzLlxuICAgKlxuICAgKiAgICAgICAgICAgICAtIFRoZSBtb2RlIGRvZXMgbm90IGJlZ2luLlxuICAgKiAgICAgICAgICAgICAtIENvbnRlbnQgbWF0Y2hlZCBieSBgYmVnaW5gIGlzIGFkZGVkIHRvIHRoZSBtb2RlIGJ1ZmZlci5cbiAgICogICAgICAgICAgICAgLSBUaGUgcGFyc2VyIGN1cnNvciBpcyBtb3ZlZCBmb3J3YXJkIGFjY29yZGluZ2x5LlxuICAgKlxuICAgKiBAaWdub3JlIC0gSWdub3JlcyB0aGUgbW9kZSAoYXMgaWYgaXQgbmV2ZXIgbWF0Y2hlZCkgYW5kIGNvbnRpbnVlcyB0byBtYXRjaCBhbnlcbiAgICogICAgICAgICAgIHN1YnNlcXVlbnQgYGNvbnRhaW5zYCBtb2Rlcy4gIElnbm9yZSBpc24ndCB0ZWNobmljYWxseSBwb3NzaWJsZSB3aXRoXG4gICAqICAgICAgICAgICB0aGUgY3VycmVudCBwYXJzZXIgaW1wbGVtZW50YXRpb24uXG4gICAqXG4gICAqICAgICAgICAgICAgIC0gVGhlIG1vZGUgZG9lcyBub3QgYmVnaW4uXG4gICAqICAgICAgICAgICAgIC0gQ29udGVudCBtYXRjaGVkIGJ5IGBiZWdpbmAgaXMgaWdub3JlZC5cbiAgICogICAgICAgICAgICAgLSBUaGUgcGFyc2VyIGN1cnNvciBpcyBub3QgbW92ZWQgZm9yd2FyZC5cbiAgICovXG5cbiAgLyoqXG4gICAqIENvbXBpbGVzIGFuIGluZGl2aWR1YWwgbW9kZVxuICAgKlxuICAgKiBUaGlzIGNhbiByYWlzZSBhbiBlcnJvciBpZiB0aGUgbW9kZSBjb250YWlucyBjZXJ0YWluIGRldGVjdGFibGUga25vd24gbG9naWNcbiAgICogaXNzdWVzLlxuICAgKiBAcGFyYW0ge01vZGV9IG1vZGVcbiAgICogQHBhcmFtIHtDb21waWxlZE1vZGUgfCBudWxsfSBbcGFyZW50XVxuICAgKiBAcmV0dXJucyB7Q29tcGlsZWRNb2RlIHwgbmV2ZXJ9XG4gICAqL1xuICBmdW5jdGlvbiBjb21waWxlTW9kZShtb2RlLCBwYXJlbnQpIHtcbiAgICBjb25zdCBjbW9kZSA9IC8qKiBAdHlwZSBDb21waWxlZE1vZGUgKi8gKG1vZGUpO1xuICAgIGlmIChtb2RlLmlzQ29tcGlsZWQpIHJldHVybiBjbW9kZTtcblxuICAgIFtcbiAgICAgIHNjb3BlQ2xhc3NOYW1lLFxuICAgICAgLy8gZG8gdGhpcyBlYXJseSBzbyBjb21waWxlciBleHRlbnNpb25zIGdlbmVyYWxseSBkb24ndCBoYXZlIHRvIHdvcnJ5IGFib3V0XG4gICAgICAvLyB0aGUgZGlzdGluY3Rpb24gYmV0d2VlbiBtYXRjaC9iZWdpblxuICAgICAgY29tcGlsZU1hdGNoLFxuICAgICAgTXVsdGlDbGFzcyxcbiAgICAgIGJlZm9yZU1hdGNoRXh0XG4gICAgXS5mb3JFYWNoKGV4dCA9PiBleHQobW9kZSwgcGFyZW50KSk7XG5cbiAgICBsYW5ndWFnZS5jb21waWxlckV4dGVuc2lvbnMuZm9yRWFjaChleHQgPT4gZXh0KG1vZGUsIHBhcmVudCkpO1xuXG4gICAgLy8gX19iZWZvcmVCZWdpbiBpcyBjb25zaWRlcmVkIHByaXZhdGUgQVBJLCBpbnRlcm5hbCB1c2Ugb25seVxuICAgIG1vZGUuX19iZWZvcmVCZWdpbiA9IG51bGw7XG5cbiAgICBbXG4gICAgICBiZWdpbktleXdvcmRzLFxuICAgICAgLy8gZG8gdGhpcyBsYXRlciBzbyBjb21waWxlciBleHRlbnNpb25zIHRoYXQgY29tZSBlYXJsaWVyIGhhdmUgYWNjZXNzIHRvIHRoZVxuICAgICAgLy8gcmF3IGFycmF5IGlmIHRoZXkgd2FudGVkIHRvIHBlcmhhcHMgbWFuaXB1bGF0ZSBpdCwgZXRjLlxuICAgICAgY29tcGlsZUlsbGVnYWwsXG4gICAgICAvLyBkZWZhdWx0IHRvIDEgcmVsZXZhbmNlIGlmIG5vdCBzcGVjaWZpZWRcbiAgICAgIGNvbXBpbGVSZWxldmFuY2VcbiAgICBdLmZvckVhY2goZXh0ID0+IGV4dChtb2RlLCBwYXJlbnQpKTtcblxuICAgIG1vZGUuaXNDb21waWxlZCA9IHRydWU7XG5cbiAgICBsZXQga2V5d29yZFBhdHRlcm4gPSBudWxsO1xuICAgIGlmICh0eXBlb2YgbW9kZS5rZXl3b3JkcyA9PT0gXCJvYmplY3RcIiAmJiBtb2RlLmtleXdvcmRzLiRwYXR0ZXJuKSB7XG4gICAgICAvLyB3ZSBuZWVkIGEgY29weSBiZWNhdXNlIGtleXdvcmRzIG1pZ2h0IGJlIGNvbXBpbGVkIG11bHRpcGxlIHRpbWVzXG4gICAgICAvLyBzbyB3ZSBjYW4ndCBnbyBkZWxldGluZyAkcGF0dGVybiBmcm9tIHRoZSBvcmlnaW5hbCBvbiB0aGUgZmlyc3RcbiAgICAgIC8vIHBhc3NcbiAgICAgIG1vZGUua2V5d29yZHMgPSBPYmplY3QuYXNzaWduKHt9LCBtb2RlLmtleXdvcmRzKTtcbiAgICAgIGtleXdvcmRQYXR0ZXJuID0gbW9kZS5rZXl3b3Jkcy4kcGF0dGVybjtcbiAgICAgIGRlbGV0ZSBtb2RlLmtleXdvcmRzLiRwYXR0ZXJuO1xuICAgIH1cbiAgICBrZXl3b3JkUGF0dGVybiA9IGtleXdvcmRQYXR0ZXJuIHx8IC9cXHcrLztcblxuICAgIGlmIChtb2RlLmtleXdvcmRzKSB7XG4gICAgICBtb2RlLmtleXdvcmRzID0gY29tcGlsZUtleXdvcmRzKG1vZGUua2V5d29yZHMsIGxhbmd1YWdlLmNhc2VfaW5zZW5zaXRpdmUpO1xuICAgIH1cblxuICAgIGNtb2RlLmtleXdvcmRQYXR0ZXJuUmUgPSBsYW5nUmUoa2V5d29yZFBhdHRlcm4sIHRydWUpO1xuXG4gICAgaWYgKHBhcmVudCkge1xuICAgICAgaWYgKCFtb2RlLmJlZ2luKSBtb2RlLmJlZ2luID0gL1xcQnxcXGIvO1xuICAgICAgY21vZGUuYmVnaW5SZSA9IGxhbmdSZShtb2RlLmJlZ2luKTtcbiAgICAgIGlmICghbW9kZS5lbmQgJiYgIW1vZGUuZW5kc1dpdGhQYXJlbnQpIG1vZGUuZW5kID0gL1xcQnxcXGIvO1xuICAgICAgaWYgKG1vZGUuZW5kKSBjbW9kZS5lbmRSZSA9IGxhbmdSZShtb2RlLmVuZCk7XG4gICAgICBjbW9kZS50ZXJtaW5hdG9yRW5kID0gc291cmNlKG1vZGUuZW5kKSB8fCAnJztcbiAgICAgIGlmIChtb2RlLmVuZHNXaXRoUGFyZW50ICYmIHBhcmVudC50ZXJtaW5hdG9yRW5kKSB7XG4gICAgICAgIGNtb2RlLnRlcm1pbmF0b3JFbmQgKz0gKG1vZGUuZW5kID8gJ3wnIDogJycpICsgcGFyZW50LnRlcm1pbmF0b3JFbmQ7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChtb2RlLmlsbGVnYWwpIGNtb2RlLmlsbGVnYWxSZSA9IGxhbmdSZSgvKiogQHR5cGUge1JlZ0V4cCB8IHN0cmluZ30gKi8gKG1vZGUuaWxsZWdhbCkpO1xuICAgIGlmICghbW9kZS5jb250YWlucykgbW9kZS5jb250YWlucyA9IFtdO1xuXG4gICAgbW9kZS5jb250YWlucyA9IFtdLmNvbmNhdCguLi5tb2RlLmNvbnRhaW5zLm1hcChmdW5jdGlvbihjKSB7XG4gICAgICByZXR1cm4gZXhwYW5kT3JDbG9uZU1vZGUoYyA9PT0gJ3NlbGYnID8gbW9kZSA6IGMpO1xuICAgIH0pKTtcbiAgICBtb2RlLmNvbnRhaW5zLmZvckVhY2goZnVuY3Rpb24oYykgeyBjb21waWxlTW9kZSgvKiogQHR5cGUgTW9kZSAqLyAoYyksIGNtb2RlKTsgfSk7XG5cbiAgICBpZiAobW9kZS5zdGFydHMpIHtcbiAgICAgIGNvbXBpbGVNb2RlKG1vZGUuc3RhcnRzLCBwYXJlbnQpO1xuICAgIH1cblxuICAgIGNtb2RlLm1hdGNoZXIgPSBidWlsZE1vZGVSZWdleChjbW9kZSk7XG4gICAgcmV0dXJuIGNtb2RlO1xuICB9XG5cbiAgaWYgKCFsYW5ndWFnZS5jb21waWxlckV4dGVuc2lvbnMpIGxhbmd1YWdlLmNvbXBpbGVyRXh0ZW5zaW9ucyA9IFtdO1xuXG4gIC8vIHNlbGYgaXMgbm90IHZhbGlkIGF0IHRoZSB0b3AtbGV2ZWxcbiAgaWYgKGxhbmd1YWdlLmNvbnRhaW5zICYmIGxhbmd1YWdlLmNvbnRhaW5zLmluY2x1ZGVzKCdzZWxmJykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJFUlI6IGNvbnRhaW5zIGBzZWxmYCBpcyBub3Qgc3VwcG9ydGVkIGF0IHRoZSB0b3AtbGV2ZWwgb2YgYSBsYW5ndWFnZS4gIFNlZSBkb2N1bWVudGF0aW9uLlwiKTtcbiAgfVxuXG4gIC8vIHdlIG5lZWQgYSBudWxsIG9iamVjdCwgd2hpY2ggaW5oZXJpdCB3aWxsIGd1YXJhbnRlZVxuICBsYW5ndWFnZS5jbGFzc05hbWVBbGlhc2VzID0gaW5oZXJpdCQxKGxhbmd1YWdlLmNsYXNzTmFtZUFsaWFzZXMgfHwge30pO1xuXG4gIHJldHVybiBjb21waWxlTW9kZSgvKiogQHR5cGUgTW9kZSAqLyAobGFuZ3VhZ2UpKTtcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmVzIGlmIGEgbW9kZSBoYXMgYSBkZXBlbmRlbmN5IG9uIGl0J3MgcGFyZW50IG9yIG5vdFxuICpcbiAqIElmIGEgbW9kZSBkb2VzIGhhdmUgYSBwYXJlbnQgZGVwZW5kZW5jeSB0aGVuIG9mdGVuIHdlIG5lZWQgdG8gY2xvbmUgaXQgaWZcbiAqIGl0J3MgdXNlZCBpbiBtdWx0aXBsZSBwbGFjZXMgc28gdGhhdCBlYWNoIGNvcHkgcG9pbnRzIHRvIHRoZSBjb3JyZWN0IHBhcmVudCxcbiAqIHdoZXJlLWFzIG1vZGVzIHdpdGhvdXQgYSBwYXJlbnQgY2FuIG9mdGVuIHNhZmVseSBiZSByZS11c2VkIGF0IHRoZSBib3R0b20gb2ZcbiAqIGEgbW9kZSBjaGFpbi5cbiAqXG4gKiBAcGFyYW0ge01vZGUgfCBudWxsfSBtb2RlXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gLSBpcyB0aGVyZSBhIGRlcGVuZGVuY3kgb24gdGhlIHBhcmVudD9cbiAqICovXG5mdW5jdGlvbiBkZXBlbmRlbmN5T25QYXJlbnQobW9kZSkge1xuICBpZiAoIW1vZGUpIHJldHVybiBmYWxzZTtcblxuICByZXR1cm4gbW9kZS5lbmRzV2l0aFBhcmVudCB8fCBkZXBlbmRlbmN5T25QYXJlbnQobW9kZS5zdGFydHMpO1xufVxuXG4vKipcbiAqIEV4cGFuZHMgYSBtb2RlIG9yIGNsb25lcyBpdCBpZiBuZWNlc3NhcnlcbiAqXG4gKiBUaGlzIGlzIG5lY2Vzc2FyeSBmb3IgbW9kZXMgd2l0aCBwYXJlbnRhbCBkZXBlbmRlbmNlaXMgKHNlZSBub3RlcyBvblxuICogYGRlcGVuZGVuY3lPblBhcmVudGApIGFuZCBmb3Igbm9kZXMgdGhhdCBoYXZlIGB2YXJpYW50c2AgLSB3aGljaCBtdXN0IHRoZW4gYmVcbiAqIGV4cGxvZGVkIGludG8gdGhlaXIgb3duIGluZGl2aWR1YWwgbW9kZXMgYXQgY29tcGlsZSB0aW1lLlxuICpcbiAqIEBwYXJhbSB7TW9kZX0gbW9kZVxuICogQHJldHVybnMge01vZGUgfCBNb2RlW119XG4gKiAqL1xuZnVuY3Rpb24gZXhwYW5kT3JDbG9uZU1vZGUobW9kZSkge1xuICBpZiAobW9kZS52YXJpYW50cyAmJiAhbW9kZS5jYWNoZWRWYXJpYW50cykge1xuICAgIG1vZGUuY2FjaGVkVmFyaWFudHMgPSBtb2RlLnZhcmlhbnRzLm1hcChmdW5jdGlvbih2YXJpYW50KSB7XG4gICAgICByZXR1cm4gaW5oZXJpdCQxKG1vZGUsIHsgdmFyaWFudHM6IG51bGwgfSwgdmFyaWFudCk7XG4gICAgfSk7XG4gIH1cblxuICAvLyBFWFBBTkRcbiAgLy8gaWYgd2UgaGF2ZSB2YXJpYW50cyB0aGVuIGVzc2VudGlhbGx5IFwicmVwbGFjZVwiIHRoZSBtb2RlIHdpdGggdGhlIHZhcmlhbnRzXG4gIC8vIHRoaXMgaGFwcGVucyBpbiBjb21waWxlTW9kZSwgd2hlcmUgdGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQgZnJvbVxuICBpZiAobW9kZS5jYWNoZWRWYXJpYW50cykge1xuICAgIHJldHVybiBtb2RlLmNhY2hlZFZhcmlhbnRzO1xuICB9XG5cbiAgLy8gQ0xPTkVcbiAgLy8gaWYgd2UgaGF2ZSBkZXBlbmRlbmNpZXMgb24gcGFyZW50cyB0aGVuIHdlIG5lZWQgYSB1bmlxdWVcbiAgLy8gaW5zdGFuY2Ugb2Ygb3Vyc2VsdmVzLCBzbyB3ZSBjYW4gYmUgcmV1c2VkIHdpdGggbWFueVxuICAvLyBkaWZmZXJlbnQgcGFyZW50cyB3aXRob3V0IGlzc3VlXG4gIGlmIChkZXBlbmRlbmN5T25QYXJlbnQobW9kZSkpIHtcbiAgICByZXR1cm4gaW5oZXJpdCQxKG1vZGUsIHsgc3RhcnRzOiBtb2RlLnN0YXJ0cyA/IGluaGVyaXQkMShtb2RlLnN0YXJ0cykgOiBudWxsIH0pO1xuICB9XG5cbiAgaWYgKE9iamVjdC5pc0Zyb3plbihtb2RlKSkge1xuICAgIHJldHVybiBpbmhlcml0JDEobW9kZSk7XG4gIH1cblxuICAvLyBubyBzcGVjaWFsIGRlcGVuZGVuY3kgaXNzdWVzLCBqdXN0IHJldHVybiBvdXJzZWx2ZXNcbiAgcmV0dXJuIG1vZGU7XG59XG5cbnZhciB2ZXJzaW9uID0gXCIxMS4yLjBcIjtcblxuLypcblN5bnRheCBoaWdobGlnaHRpbmcgd2l0aCBsYW5ndWFnZSBhdXRvZGV0ZWN0aW9uLlxuaHR0cHM6Ly9oaWdobGlnaHRqcy5vcmcvXG4qL1xuXG4vKipcbkB0eXBlZGVmIHtpbXBvcnQoJ2hpZ2hsaWdodC5qcycpLk1vZGV9IE1vZGVcbkB0eXBlZGVmIHtpbXBvcnQoJ2hpZ2hsaWdodC5qcycpLkNvbXBpbGVkTW9kZX0gQ29tcGlsZWRNb2RlXG5AdHlwZWRlZiB7aW1wb3J0KCdoaWdobGlnaHQuanMnKS5MYW5ndWFnZX0gTGFuZ3VhZ2VcbkB0eXBlZGVmIHtpbXBvcnQoJ2hpZ2hsaWdodC5qcycpLkhMSlNBcGl9IEhMSlNBcGlcbkB0eXBlZGVmIHtpbXBvcnQoJ2hpZ2hsaWdodC5qcycpLkhMSlNQbHVnaW59IEhMSlNQbHVnaW5cbkB0eXBlZGVmIHtpbXBvcnQoJ2hpZ2hsaWdodC5qcycpLlBsdWdpbkV2ZW50fSBQbHVnaW5FdmVudFxuQHR5cGVkZWYge2ltcG9ydCgnaGlnaGxpZ2h0LmpzJykuSExKU09wdGlvbnN9IEhMSlNPcHRpb25zXG5AdHlwZWRlZiB7aW1wb3J0KCdoaWdobGlnaHQuanMnKS5MYW5ndWFnZUZufSBMYW5ndWFnZUZuXG5AdHlwZWRlZiB7aW1wb3J0KCdoaWdobGlnaHQuanMnKS5IaWdobGlnaHRlZEhUTUxFbGVtZW50fSBIaWdobGlnaHRlZEhUTUxFbGVtZW50XG5AdHlwZWRlZiB7aW1wb3J0KCdoaWdobGlnaHQuanMnKS5CZWZvcmVIaWdobGlnaHRDb250ZXh0fSBCZWZvcmVIaWdobGlnaHRDb250ZXh0XG5AdHlwZWRlZiB7aW1wb3J0KCdoaWdobGlnaHQuanMvcHJpdmF0ZScpLk1hdGNoVHlwZX0gTWF0Y2hUeXBlXG5AdHlwZWRlZiB7aW1wb3J0KCdoaWdobGlnaHQuanMvcHJpdmF0ZScpLktleXdvcmREYXRhfSBLZXl3b3JkRGF0YVxuQHR5cGVkZWYge2ltcG9ydCgnaGlnaGxpZ2h0LmpzL3ByaXZhdGUnKS5FbmhhbmNlZE1hdGNofSBFbmhhbmNlZE1hdGNoXG5AdHlwZWRlZiB7aW1wb3J0KCdoaWdobGlnaHQuanMvcHJpdmF0ZScpLkFubm90YXRlZEVycm9yfSBBbm5vdGF0ZWRFcnJvclxuQHR5cGVkZWYge2ltcG9ydCgnaGlnaGxpZ2h0LmpzJykuQXV0b0hpZ2hsaWdodFJlc3VsdH0gQXV0b0hpZ2hsaWdodFJlc3VsdFxuQHR5cGVkZWYge2ltcG9ydCgnaGlnaGxpZ2h0LmpzJykuSGlnaGxpZ2h0T3B0aW9uc30gSGlnaGxpZ2h0T3B0aW9uc1xuQHR5cGVkZWYge2ltcG9ydCgnaGlnaGxpZ2h0LmpzJykuSGlnaGxpZ2h0UmVzdWx0fSBIaWdobGlnaHRSZXN1bHRcbiovXG5cblxuY29uc3QgZXNjYXBlID0gZXNjYXBlSFRNTDtcbmNvbnN0IGluaGVyaXQgPSBpbmhlcml0JDE7XG5jb25zdCBOT19NQVRDSCA9IFN5bWJvbChcIm5vbWF0Y2hcIik7XG5jb25zdCBNQVhfS0VZV09SRF9ISVRTID0gNztcblxuLyoqXG4gKiBAcGFyYW0ge2FueX0gaGxqcyAtIG9iamVjdCB0aGF0IGlzIGV4dGVuZGVkIChsZWdhY3kpXG4gKiBAcmV0dXJucyB7SExKU0FwaX1cbiAqL1xuY29uc3QgSExKUyA9IGZ1bmN0aW9uKGhsanMpIHtcbiAgLy8gR2xvYmFsIGludGVybmFsIHZhcmlhYmxlcyB1c2VkIHdpdGhpbiB0aGUgaGlnaGxpZ2h0LmpzIGxpYnJhcnkuXG4gIC8qKiBAdHlwZSB7UmVjb3JkPHN0cmluZywgTGFuZ3VhZ2U+fSAqL1xuICBjb25zdCBsYW5ndWFnZXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAvKiogQHR5cGUge1JlY29yZDxzdHJpbmcsIHN0cmluZz59ICovXG4gIGNvbnN0IGFsaWFzZXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAvKiogQHR5cGUge0hMSlNQbHVnaW5bXX0gKi9cbiAgY29uc3QgcGx1Z2lucyA9IFtdO1xuXG4gIC8vIHNhZmUvcHJvZHVjdGlvbiBtb2RlIC0gc3dhbGxvd3MgbW9yZSBlcnJvcnMsIHRyaWVzIHRvIGtlZXAgcnVubmluZ1xuICAvLyBldmVuIGlmIGEgc2luZ2xlIHN5bnRheCBvciBwYXJzZSBoaXRzIGEgZmF0YWwgZXJyb3JcbiAgbGV0IFNBRkVfTU9ERSA9IHRydWU7XG4gIGNvbnN0IExBTkdVQUdFX05PVF9GT1VORCA9IFwiQ291bGQgbm90IGZpbmQgdGhlIGxhbmd1YWdlICd7fScsIGRpZCB5b3UgZm9yZ2V0IHRvIGxvYWQvaW5jbHVkZSBhIGxhbmd1YWdlIG1vZHVsZT9cIjtcbiAgLyoqIEB0eXBlIHtMYW5ndWFnZX0gKi9cbiAgY29uc3QgUExBSU5URVhUX0xBTkdVQUdFID0geyBkaXNhYmxlQXV0b2RldGVjdDogdHJ1ZSwgbmFtZTogJ1BsYWluIHRleHQnLCBjb250YWluczogW10gfTtcblxuICAvLyBHbG9iYWwgb3B0aW9ucyB1c2VkIHdoZW4gd2l0aGluIGV4dGVybmFsIEFQSXMuIFRoaXMgaXMgbW9kaWZpZWQgd2hlblxuICAvLyBjYWxsaW5nIHRoZSBgaGxqcy5jb25maWd1cmVgIGZ1bmN0aW9uLlxuICAvKiogQHR5cGUgSExKU09wdGlvbnMgKi9cbiAgbGV0IG9wdGlvbnMgPSB7XG4gICAgaWdub3JlVW5lc2NhcGVkSFRNTDogZmFsc2UsXG4gICAgbm9IaWdobGlnaHRSZTogL14obm8tP2hpZ2hsaWdodCkkL2ksXG4gICAgbGFuZ3VhZ2VEZXRlY3RSZTogL1xcYmxhbmcoPzp1YWdlKT8tKFtcXHctXSspXFxiL2ksXG4gICAgY2xhc3NQcmVmaXg6ICdobGpzLScsXG4gICAgY3NzU2VsZWN0b3I6ICdwcmUgY29kZScsXG4gICAgbGFuZ3VhZ2VzOiBudWxsLFxuICAgIC8vIGJldGEgY29uZmlndXJhdGlvbiBvcHRpb25zLCBzdWJqZWN0IHRvIGNoYW5nZSwgd2VsY29tZSB0byBkaXNjdXNzXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2hpZ2hsaWdodGpzL2hpZ2hsaWdodC5qcy9pc3N1ZXMvMTA4NlxuICAgIF9fZW1pdHRlcjogVG9rZW5UcmVlRW1pdHRlclxuICB9O1xuXG4gIC8qIFV0aWxpdHkgZnVuY3Rpb25zICovXG5cbiAgLyoqXG4gICAqIFRlc3RzIGEgbGFuZ3VhZ2UgbmFtZSB0byBzZWUgaWYgaGlnaGxpZ2h0aW5nIHNob3VsZCBiZSBza2lwcGVkXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBsYW5ndWFnZU5hbWVcbiAgICovXG4gIGZ1bmN0aW9uIHNob3VsZE5vdEhpZ2hsaWdodChsYW5ndWFnZU5hbWUpIHtcbiAgICByZXR1cm4gb3B0aW9ucy5ub0hpZ2hsaWdodFJlLnRlc3QobGFuZ3VhZ2VOYW1lKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0hpZ2hsaWdodGVkSFRNTEVsZW1lbnR9IGJsb2NrIC0gdGhlIEhUTUwgZWxlbWVudCB0byBkZXRlcm1pbmUgbGFuZ3VhZ2UgZm9yXG4gICAqL1xuICBmdW5jdGlvbiBibG9ja0xhbmd1YWdlKGJsb2NrKSB7XG4gICAgbGV0IGNsYXNzZXMgPSBibG9jay5jbGFzc05hbWUgKyAnICc7XG5cbiAgICBjbGFzc2VzICs9IGJsb2NrLnBhcmVudE5vZGUgPyBibG9jay5wYXJlbnROb2RlLmNsYXNzTmFtZSA6ICcnO1xuXG4gICAgLy8gbGFuZ3VhZ2UtKiB0YWtlcyBwcmVjZWRlbmNlIG92ZXIgbm9uLXByZWZpeGVkIGNsYXNzIG5hbWVzLlxuICAgIGNvbnN0IG1hdGNoID0gb3B0aW9ucy5sYW5ndWFnZURldGVjdFJlLmV4ZWMoY2xhc3Nlcyk7XG4gICAgaWYgKG1hdGNoKSB7XG4gICAgICBjb25zdCBsYW5ndWFnZSA9IGdldExhbmd1YWdlKG1hdGNoWzFdKTtcbiAgICAgIGlmICghbGFuZ3VhZ2UpIHtcbiAgICAgICAgd2FybihMQU5HVUFHRV9OT1RfRk9VTkQucmVwbGFjZShcInt9XCIsIG1hdGNoWzFdKSk7XG4gICAgICAgIHdhcm4oXCJGYWxsaW5nIGJhY2sgdG8gbm8taGlnaGxpZ2h0IG1vZGUgZm9yIHRoaXMgYmxvY2suXCIsIGJsb2NrKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBsYW5ndWFnZSA/IG1hdGNoWzFdIDogJ25vLWhpZ2hsaWdodCc7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNsYXNzZXNcbiAgICAgIC5zcGxpdCgvXFxzKy8pXG4gICAgICAuZmluZCgoX2NsYXNzKSA9PiBzaG91bGROb3RIaWdobGlnaHQoX2NsYXNzKSB8fCBnZXRMYW5ndWFnZShfY2xhc3MpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb3JlIGhpZ2hsaWdodGluZyBmdW5jdGlvbi5cbiAgICpcbiAgICogT0xEIEFQSVxuICAgKiBoaWdobGlnaHQobGFuZywgY29kZSwgaWdub3JlSWxsZWdhbHMsIGNvbnRpbnVhdGlvbilcbiAgICpcbiAgICogTkVXIEFQSVxuICAgKiBoaWdobGlnaHQoY29kZSwge2xhbmcsIGlnbm9yZUlsbGVnYWxzfSlcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNvZGVPckxhbmd1YWdlTmFtZSAtIHRoZSBsYW5ndWFnZSB0byB1c2UgZm9yIGhpZ2hsaWdodGluZ1xuICAgKiBAcGFyYW0ge3N0cmluZyB8IEhpZ2hsaWdodE9wdGlvbnN9IG9wdGlvbnNPckNvZGUgLSB0aGUgY29kZSB0byBoaWdobGlnaHRcbiAgICogQHBhcmFtIHtib29sZWFufSBbaWdub3JlSWxsZWdhbHNdIC0gd2hldGhlciB0byBpZ25vcmUgaWxsZWdhbCBtYXRjaGVzLCBkZWZhdWx0IGlzIHRvIGJhaWxcbiAgICpcbiAgICogQHJldHVybnMge0hpZ2hsaWdodFJlc3VsdH0gUmVzdWx0IC0gYW4gb2JqZWN0IHRoYXQgcmVwcmVzZW50cyB0aGUgcmVzdWx0XG4gICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBsYW5ndWFnZSAtIHRoZSBsYW5ndWFnZSBuYW1lXG4gICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSByZWxldmFuY2UgLSB0aGUgcmVsZXZhbmNlIHNjb3JlXG4gICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSB2YWx1ZSAtIHRoZSBoaWdobGlnaHRlZCBIVE1MIGNvZGVcbiAgICogQHByb3BlcnR5IHtzdHJpbmd9IGNvZGUgLSB0aGUgb3JpZ2luYWwgcmF3IGNvZGVcbiAgICogQHByb3BlcnR5IHtDb21waWxlZE1vZGV9IHRvcCAtIHRvcCBvZiB0aGUgY3VycmVudCBtb2RlIHN0YWNrXG4gICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gaWxsZWdhbCAtIGluZGljYXRlcyB3aGV0aGVyIGFueSBpbGxlZ2FsIG1hdGNoZXMgd2VyZSBmb3VuZFxuICAqL1xuICBmdW5jdGlvbiBoaWdobGlnaHQoY29kZU9yTGFuZ3VhZ2VOYW1lLCBvcHRpb25zT3JDb2RlLCBpZ25vcmVJbGxlZ2Fscykge1xuICAgIGxldCBjb2RlID0gXCJcIjtcbiAgICBsZXQgbGFuZ3VhZ2VOYW1lID0gXCJcIjtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnNPckNvZGUgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgIGNvZGUgPSBjb2RlT3JMYW5ndWFnZU5hbWU7XG4gICAgICBpZ25vcmVJbGxlZ2FscyA9IG9wdGlvbnNPckNvZGUuaWdub3JlSWxsZWdhbHM7XG4gICAgICBsYW5ndWFnZU5hbWUgPSBvcHRpb25zT3JDb2RlLmxhbmd1YWdlO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBvbGQgQVBJXG4gICAgICBkZXByZWNhdGVkKFwiMTAuNy4wXCIsIFwiaGlnaGxpZ2h0KGxhbmcsIGNvZGUsIC4uLmFyZ3MpIGhhcyBiZWVuIGRlcHJlY2F0ZWQuXCIpO1xuICAgICAgZGVwcmVjYXRlZChcIjEwLjcuMFwiLCBcIlBsZWFzZSB1c2UgaGlnaGxpZ2h0KGNvZGUsIG9wdGlvbnMpIGluc3RlYWQuXFxuaHR0cHM6Ly9naXRodWIuY29tL2hpZ2hsaWdodGpzL2hpZ2hsaWdodC5qcy9pc3N1ZXMvMjI3N1wiKTtcbiAgICAgIGxhbmd1YWdlTmFtZSA9IGNvZGVPckxhbmd1YWdlTmFtZTtcbiAgICAgIGNvZGUgPSBvcHRpb25zT3JDb2RlO1xuICAgIH1cblxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9oaWdobGlnaHRqcy9oaWdobGlnaHQuanMvaXNzdWVzLzMxNDlcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5kZWZpbmVkXG4gICAgaWYgKGlnbm9yZUlsbGVnYWxzID09PSB1bmRlZmluZWQpIHsgaWdub3JlSWxsZWdhbHMgPSB0cnVlOyB9XG5cbiAgICAvKiogQHR5cGUge0JlZm9yZUhpZ2hsaWdodENvbnRleHR9ICovXG4gICAgY29uc3QgY29udGV4dCA9IHtcbiAgICAgIGNvZGUsXG4gICAgICBsYW5ndWFnZTogbGFuZ3VhZ2VOYW1lXG4gICAgfTtcbiAgICAvLyB0aGUgcGx1Z2luIGNhbiBjaGFuZ2UgdGhlIGRlc2lyZWQgbGFuZ3VhZ2Ugb3IgdGhlIGNvZGUgdG8gYmUgaGlnaGxpZ2h0ZWRcbiAgICAvLyBqdXN0IGJlIGNoYW5naW5nIHRoZSBvYmplY3QgaXQgd2FzIHBhc3NlZFxuICAgIGZpcmUoXCJiZWZvcmU6aGlnaGxpZ2h0XCIsIGNvbnRleHQpO1xuXG4gICAgLy8gYSBiZWZvcmUgcGx1Z2luIGNhbiB1c3VycCB0aGUgcmVzdWx0IGNvbXBsZXRlbHkgYnkgcHJvdmlkaW5nIGl0J3Mgb3duXG4gICAgLy8gaW4gd2hpY2ggY2FzZSB3ZSBkb24ndCBldmVuIG5lZWQgdG8gY2FsbCBoaWdobGlnaHRcbiAgICBjb25zdCByZXN1bHQgPSBjb250ZXh0LnJlc3VsdFxuICAgICAgPyBjb250ZXh0LnJlc3VsdFxuICAgICAgOiBfaGlnaGxpZ2h0KGNvbnRleHQubGFuZ3VhZ2UsIGNvbnRleHQuY29kZSwgaWdub3JlSWxsZWdhbHMpO1xuXG4gICAgcmVzdWx0LmNvZGUgPSBjb250ZXh0LmNvZGU7XG4gICAgLy8gdGhlIHBsdWdpbiBjYW4gY2hhbmdlIGFueXRoaW5nIGluIHJlc3VsdCB0byBzdWl0ZSBpdFxuICAgIGZpcmUoXCJhZnRlcjpoaWdobGlnaHRcIiwgcmVzdWx0KTtcblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogcHJpdmF0ZSBoaWdobGlnaHQgdGhhdCdzIHVzZWQgaW50ZXJuYWxseSBhbmQgZG9lcyBub3QgZmlyZSBjYWxsYmFja3NcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGxhbmd1YWdlTmFtZSAtIHRoZSBsYW5ndWFnZSB0byB1c2UgZm9yIGhpZ2hsaWdodGluZ1xuICAgKiBAcGFyYW0ge3N0cmluZ30gY29kZVRvSGlnaGxpZ2h0IC0gdGhlIGNvZGUgdG8gaGlnaGxpZ2h0XG4gICAqIEBwYXJhbSB7Ym9vbGVhbj99IFtpZ25vcmVJbGxlZ2Fsc10gLSB3aGV0aGVyIHRvIGlnbm9yZSBpbGxlZ2FsIG1hdGNoZXMsIGRlZmF1bHQgaXMgdG8gYmFpbFxuICAgKiBAcGFyYW0ge0NvbXBpbGVkTW9kZT99IFtjb250aW51YXRpb25dIC0gY3VycmVudCBjb250aW51YXRpb24gbW9kZSwgaWYgYW55XG4gICAqIEByZXR1cm5zIHtIaWdobGlnaHRSZXN1bHR9IC0gcmVzdWx0IG9mIHRoZSBoaWdobGlnaHQgb3BlcmF0aW9uXG4gICovXG4gIGZ1bmN0aW9uIF9oaWdobGlnaHQobGFuZ3VhZ2VOYW1lLCBjb2RlVG9IaWdobGlnaHQsIGlnbm9yZUlsbGVnYWxzLCBjb250aW51YXRpb24pIHtcbiAgICBjb25zdCBrZXl3b3JkSGl0cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4ga2V5d29yZCBkYXRhIGlmIGEgbWF0Y2ggaXMgYSBrZXl3b3JkXG4gICAgICogQHBhcmFtIHtDb21waWxlZE1vZGV9IG1vZGUgLSBjdXJyZW50IG1vZGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbWF0Y2hUZXh0IC0gdGhlIHRleHR1YWwgbWF0Y2hcbiAgICAgKiBAcmV0dXJucyB7S2V5d29yZERhdGEgfCBmYWxzZX1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBrZXl3b3JkRGF0YShtb2RlLCBtYXRjaFRleHQpIHtcbiAgICAgIHJldHVybiBtb2RlLmtleXdvcmRzW21hdGNoVGV4dF07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcHJvY2Vzc0tleXdvcmRzKCkge1xuICAgICAgaWYgKCF0b3Aua2V5d29yZHMpIHtcbiAgICAgICAgZW1pdHRlci5hZGRUZXh0KG1vZGVCdWZmZXIpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGxldCBsYXN0SW5kZXggPSAwO1xuICAgICAgdG9wLmtleXdvcmRQYXR0ZXJuUmUubGFzdEluZGV4ID0gMDtcbiAgICAgIGxldCBtYXRjaCA9IHRvcC5rZXl3b3JkUGF0dGVyblJlLmV4ZWMobW9kZUJ1ZmZlcik7XG4gICAgICBsZXQgYnVmID0gXCJcIjtcblxuICAgICAgd2hpbGUgKG1hdGNoKSB7XG4gICAgICAgIGJ1ZiArPSBtb2RlQnVmZmVyLnN1YnN0cmluZyhsYXN0SW5kZXgsIG1hdGNoLmluZGV4KTtcbiAgICAgICAgY29uc3Qgd29yZCA9IGxhbmd1YWdlLmNhc2VfaW5zZW5zaXRpdmUgPyBtYXRjaFswXS50b0xvd2VyQ2FzZSgpIDogbWF0Y2hbMF07XG4gICAgICAgIGNvbnN0IGRhdGEgPSBrZXl3b3JkRGF0YSh0b3AsIHdvcmQpO1xuICAgICAgICBpZiAoZGF0YSkge1xuICAgICAgICAgIGNvbnN0IFtraW5kLCBrZXl3b3JkUmVsZXZhbmNlXSA9IGRhdGE7XG4gICAgICAgICAgZW1pdHRlci5hZGRUZXh0KGJ1Zik7XG4gICAgICAgICAgYnVmID0gXCJcIjtcblxuICAgICAgICAgIGtleXdvcmRIaXRzW3dvcmRdID0gKGtleXdvcmRIaXRzW3dvcmRdIHx8IDApICsgMTtcbiAgICAgICAgICBpZiAoa2V5d29yZEhpdHNbd29yZF0gPD0gTUFYX0tFWVdPUkRfSElUUykgcmVsZXZhbmNlICs9IGtleXdvcmRSZWxldmFuY2U7XG4gICAgICAgICAgaWYgKGtpbmQuc3RhcnRzV2l0aChcIl9cIikpIHtcbiAgICAgICAgICAgIC8vIF8gaW1wbGllZCBmb3IgcmVsZXZhbmNlIG9ubHksIGRvIG5vdCBoaWdobGlnaHRcbiAgICAgICAgICAgIC8vIGJ5IGFwcGx5aW5nIGEgY2xhc3MgbmFtZVxuICAgICAgICAgICAgYnVmICs9IG1hdGNoWzBdO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBjc3NDbGFzcyA9IGxhbmd1YWdlLmNsYXNzTmFtZUFsaWFzZXNba2luZF0gfHwga2luZDtcbiAgICAgICAgICAgIGVtaXR0ZXIuYWRkS2V5d29yZChtYXRjaFswXSwgY3NzQ2xhc3MpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBidWYgKz0gbWF0Y2hbMF07XG4gICAgICAgIH1cbiAgICAgICAgbGFzdEluZGV4ID0gdG9wLmtleXdvcmRQYXR0ZXJuUmUubGFzdEluZGV4O1xuICAgICAgICBtYXRjaCA9IHRvcC5rZXl3b3JkUGF0dGVyblJlLmV4ZWMobW9kZUJ1ZmZlcik7XG4gICAgICB9XG4gICAgICBidWYgKz0gbW9kZUJ1ZmZlci5zdWJzdHIobGFzdEluZGV4KTtcbiAgICAgIGVtaXR0ZXIuYWRkVGV4dChidWYpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHByb2Nlc3NTdWJMYW5ndWFnZSgpIHtcbiAgICAgIGlmIChtb2RlQnVmZmVyID09PSBcIlwiKSByZXR1cm47XG4gICAgICAvKiogQHR5cGUgSGlnaGxpZ2h0UmVzdWx0ICovXG4gICAgICBsZXQgcmVzdWx0ID0gbnVsbDtcblxuICAgICAgaWYgKHR5cGVvZiB0b3Auc3ViTGFuZ3VhZ2UgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGlmICghbGFuZ3VhZ2VzW3RvcC5zdWJMYW5ndWFnZV0pIHtcbiAgICAgICAgICBlbWl0dGVyLmFkZFRleHQobW9kZUJ1ZmZlcik7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdCA9IF9oaWdobGlnaHQodG9wLnN1Ykxhbmd1YWdlLCBtb2RlQnVmZmVyLCB0cnVlLCBjb250aW51YXRpb25zW3RvcC5zdWJMYW5ndWFnZV0pO1xuICAgICAgICBjb250aW51YXRpb25zW3RvcC5zdWJMYW5ndWFnZV0gPSAvKiogQHR5cGUge0NvbXBpbGVkTW9kZX0gKi8gKHJlc3VsdC5fdG9wKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdCA9IGhpZ2hsaWdodEF1dG8obW9kZUJ1ZmZlciwgdG9wLnN1Ykxhbmd1YWdlLmxlbmd0aCA/IHRvcC5zdWJMYW5ndWFnZSA6IG51bGwpO1xuICAgICAgfVxuXG4gICAgICAvLyBDb3VudGluZyBlbWJlZGRlZCBsYW5ndWFnZSBzY29yZSB0b3dhcmRzIHRoZSBob3N0IGxhbmd1YWdlIG1heSBiZSBkaXNhYmxlZFxuICAgICAgLy8gd2l0aCB6ZXJvaW5nIHRoZSBjb250YWluaW5nIG1vZGUgcmVsZXZhbmNlLiBVc2UgY2FzZSBpbiBwb2ludCBpcyBNYXJrZG93biB0aGF0XG4gICAgICAvLyBhbGxvd3MgWE1MIGV2ZXJ5d2hlcmUgYW5kIG1ha2VzIGV2ZXJ5IFhNTCBzbmlwcGV0IHRvIGhhdmUgYSBtdWNoIGxhcmdlciBNYXJrZG93blxuICAgICAgLy8gc2NvcmUuXG4gICAgICBpZiAodG9wLnJlbGV2YW5jZSA+IDApIHtcbiAgICAgICAgcmVsZXZhbmNlICs9IHJlc3VsdC5yZWxldmFuY2U7XG4gICAgICB9XG4gICAgICBlbWl0dGVyLmFkZFN1Ymxhbmd1YWdlKHJlc3VsdC5fZW1pdHRlciwgcmVzdWx0Lmxhbmd1YWdlKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwcm9jZXNzQnVmZmVyKCkge1xuICAgICAgaWYgKHRvcC5zdWJMYW5ndWFnZSAhPSBudWxsKSB7XG4gICAgICAgIHByb2Nlc3NTdWJMYW5ndWFnZSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHJvY2Vzc0tleXdvcmRzKCk7XG4gICAgICB9XG4gICAgICBtb2RlQnVmZmVyID0gJyc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtDb21waWxlZE1vZGV9IG1vZGVcbiAgICAgKiBAcGFyYW0ge1JlZ0V4cE1hdGNoQXJyYXl9IG1hdGNoXG4gICAgICovXG4gICAgZnVuY3Rpb24gZW1pdE11bHRpQ2xhc3Moc2NvcGUsIG1hdGNoKSB7XG4gICAgICBsZXQgaSA9IDE7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5kZWZpbmVkXG4gICAgICB3aGlsZSAobWF0Y2hbaV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAoIXNjb3BlLl9lbWl0W2ldKSB7IGkrKzsgY29udGludWU7IH1cbiAgICAgICAgY29uc3Qga2xhc3MgPSBsYW5ndWFnZS5jbGFzc05hbWVBbGlhc2VzW3Njb3BlW2ldXSB8fCBzY29wZVtpXTtcbiAgICAgICAgY29uc3QgdGV4dCA9IG1hdGNoW2ldO1xuICAgICAgICBpZiAoa2xhc3MpIHtcbiAgICAgICAgICBlbWl0dGVyLmFkZEtleXdvcmQodGV4dCwga2xhc3MpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG1vZGVCdWZmZXIgPSB0ZXh0O1xuICAgICAgICAgIHByb2Nlc3NLZXl3b3JkcygpO1xuICAgICAgICAgIG1vZGVCdWZmZXIgPSBcIlwiO1xuICAgICAgICB9XG4gICAgICAgIGkrKztcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0NvbXBpbGVkTW9kZX0gbW9kZSAtIG5ldyBtb2RlIHRvIHN0YXJ0XG4gICAgICogQHBhcmFtIHtSZWdFeHBNYXRjaEFycmF5fSBtYXRjaFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHN0YXJ0TmV3TW9kZShtb2RlLCBtYXRjaCkge1xuICAgICAgaWYgKG1vZGUuc2NvcGUgJiYgdHlwZW9mIG1vZGUuc2NvcGUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgZW1pdHRlci5vcGVuTm9kZShsYW5ndWFnZS5jbGFzc05hbWVBbGlhc2VzW21vZGUuc2NvcGVdIHx8IG1vZGUuc2NvcGUpO1xuICAgICAgfVxuICAgICAgaWYgKG1vZGUuYmVnaW5TY29wZSkge1xuICAgICAgICAvLyBiZWdpblNjb3BlIGp1c3Qgd3JhcHMgdGhlIGJlZ2luIG1hdGNoIGl0c2VsZiBpbiBhIHNjb3BlXG4gICAgICAgIGlmIChtb2RlLmJlZ2luU2NvcGUuX3dyYXApIHtcbiAgICAgICAgICBlbWl0dGVyLmFkZEtleXdvcmQobW9kZUJ1ZmZlciwgbGFuZ3VhZ2UuY2xhc3NOYW1lQWxpYXNlc1ttb2RlLmJlZ2luU2NvcGUuX3dyYXBdIHx8IG1vZGUuYmVnaW5TY29wZS5fd3JhcCk7XG4gICAgICAgICAgbW9kZUJ1ZmZlciA9IFwiXCI7XG4gICAgICAgIH0gZWxzZSBpZiAobW9kZS5iZWdpblNjb3BlLl9tdWx0aSkge1xuICAgICAgICAgIC8vIGF0IHRoaXMgcG9pbnQgbW9kZUJ1ZmZlciBzaG91bGQganVzdCBiZSB0aGUgbWF0Y2hcbiAgICAgICAgICBlbWl0TXVsdGlDbGFzcyhtb2RlLmJlZ2luU2NvcGUsIG1hdGNoKTtcbiAgICAgICAgICBtb2RlQnVmZmVyID0gXCJcIjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0b3AgPSBPYmplY3QuY3JlYXRlKG1vZGUsIHsgcGFyZW50OiB7IHZhbHVlOiB0b3AgfSB9KTtcbiAgICAgIHJldHVybiB0b3A7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtDb21waWxlZE1vZGUgfSBtb2RlIC0gdGhlIG1vZGUgdG8gcG90ZW50aWFsbHkgZW5kXG4gICAgICogQHBhcmFtIHtSZWdFeHBNYXRjaEFycmF5fSBtYXRjaCAtIHRoZSBsYXRlc3QgbWF0Y2hcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbWF0Y2hQbHVzUmVtYWluZGVyIC0gbWF0Y2ggcGx1cyByZW1haW5kZXIgb2YgY29udGVudFxuICAgICAqIEByZXR1cm5zIHtDb21waWxlZE1vZGUgfCB2b2lkfSAtIHRoZSBuZXh0IG1vZGUsIG9yIGlmIHZvaWQgY29udGludWUgb24gaW4gY3VycmVudCBtb2RlXG4gICAgICovXG4gICAgZnVuY3Rpb24gZW5kT2ZNb2RlKG1vZGUsIG1hdGNoLCBtYXRjaFBsdXNSZW1haW5kZXIpIHtcbiAgICAgIGxldCBtYXRjaGVkID0gc3RhcnRzV2l0aChtb2RlLmVuZFJlLCBtYXRjaFBsdXNSZW1haW5kZXIpO1xuXG4gICAgICBpZiAobWF0Y2hlZCkge1xuICAgICAgICBpZiAobW9kZVtcIm9uOmVuZFwiXSkge1xuICAgICAgICAgIGNvbnN0IHJlc3AgPSBuZXcgUmVzcG9uc2UobW9kZSk7XG4gICAgICAgICAgbW9kZVtcIm9uOmVuZFwiXShtYXRjaCwgcmVzcCk7XG4gICAgICAgICAgaWYgKHJlc3AuaXNNYXRjaElnbm9yZWQpIG1hdGNoZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtYXRjaGVkKSB7XG4gICAgICAgICAgd2hpbGUgKG1vZGUuZW5kc1BhcmVudCAmJiBtb2RlLnBhcmVudCkge1xuICAgICAgICAgICAgbW9kZSA9IG1vZGUucGFyZW50O1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbW9kZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gZXZlbiBpZiBvbjplbmQgZmlyZXMgYW4gYGlnbm9yZWAgaXQncyBzdGlsbCBwb3NzaWJsZVxuICAgICAgLy8gdGhhdCB3ZSBtaWdodCB0cmlnZ2VyIHRoZSBlbmQgbm9kZSBiZWNhdXNlIG9mIGEgcGFyZW50IG1vZGVcbiAgICAgIGlmIChtb2RlLmVuZHNXaXRoUGFyZW50KSB7XG4gICAgICAgIHJldHVybiBlbmRPZk1vZGUobW9kZS5wYXJlbnQsIG1hdGNoLCBtYXRjaFBsdXNSZW1haW5kZXIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEhhbmRsZSBtYXRjaGluZyBidXQgdGhlbiBpZ25vcmluZyBhIHNlcXVlbmNlIG9mIHRleHRcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBsZXhlbWUgLSBzdHJpbmcgY29udGFpbmluZyBmdWxsIG1hdGNoIHRleHRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBkb0lnbm9yZShsZXhlbWUpIHtcbiAgICAgIGlmICh0b3AubWF0Y2hlci5yZWdleEluZGV4ID09PSAwKSB7XG4gICAgICAgIC8vIG5vIG1vcmUgcmVnZXhlcyB0byBwb3RlbnRpYWxseSBtYXRjaCBoZXJlLCBzbyB3ZSBtb3ZlIHRoZSBjdXJzb3IgZm9yd2FyZCBvbmVcbiAgICAgICAgLy8gc3BhY2VcbiAgICAgICAgbW9kZUJ1ZmZlciArPSBsZXhlbWVbMF07XG4gICAgICAgIHJldHVybiAxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gbm8gbmVlZCB0byBtb3ZlIHRoZSBjdXJzb3IsIHdlIHN0aWxsIGhhdmUgYWRkaXRpb25hbCByZWdleGVzIHRvIHRyeSBhbmRcbiAgICAgICAgLy8gbWF0Y2ggYXQgdGhpcyB2ZXJ5IHNwb3RcbiAgICAgICAgcmVzdW1lU2NhbkF0U2FtZVBvc2l0aW9uID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSGFuZGxlIHRoZSBzdGFydCBvZiBhIG5ldyBwb3RlbnRpYWwgbW9kZSBtYXRjaFxuICAgICAqXG4gICAgICogQHBhcmFtIHtFbmhhbmNlZE1hdGNofSBtYXRjaCAtIHRoZSBjdXJyZW50IG1hdGNoXG4gICAgICogQHJldHVybnMge251bWJlcn0gaG93IGZhciB0byBhZHZhbmNlIHRoZSBwYXJzZSBjdXJzb3JcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBkb0JlZ2luTWF0Y2gobWF0Y2gpIHtcbiAgICAgIGNvbnN0IGxleGVtZSA9IG1hdGNoWzBdO1xuICAgICAgY29uc3QgbmV3TW9kZSA9IG1hdGNoLnJ1bGU7XG5cbiAgICAgIGNvbnN0IHJlc3AgPSBuZXcgUmVzcG9uc2UobmV3TW9kZSk7XG4gICAgICAvLyBmaXJzdCBpbnRlcm5hbCBiZWZvcmUgY2FsbGJhY2tzLCB0aGVuIHRoZSBwdWJsaWMgb25lc1xuICAgICAgY29uc3QgYmVmb3JlQ2FsbGJhY2tzID0gW25ld01vZGUuX19iZWZvcmVCZWdpbiwgbmV3TW9kZVtcIm9uOmJlZ2luXCJdXTtcbiAgICAgIGZvciAoY29uc3QgY2Igb2YgYmVmb3JlQ2FsbGJhY2tzKSB7XG4gICAgICAgIGlmICghY2IpIGNvbnRpbnVlO1xuICAgICAgICBjYihtYXRjaCwgcmVzcCk7XG4gICAgICAgIGlmIChyZXNwLmlzTWF0Y2hJZ25vcmVkKSByZXR1cm4gZG9JZ25vcmUobGV4ZW1lKTtcbiAgICAgIH1cblxuICAgICAgaWYgKG5ld01vZGUuc2tpcCkge1xuICAgICAgICBtb2RlQnVmZmVyICs9IGxleGVtZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChuZXdNb2RlLmV4Y2x1ZGVCZWdpbikge1xuICAgICAgICAgIG1vZGVCdWZmZXIgKz0gbGV4ZW1lO1xuICAgICAgICB9XG4gICAgICAgIHByb2Nlc3NCdWZmZXIoKTtcbiAgICAgICAgaWYgKCFuZXdNb2RlLnJldHVybkJlZ2luICYmICFuZXdNb2RlLmV4Y2x1ZGVCZWdpbikge1xuICAgICAgICAgIG1vZGVCdWZmZXIgPSBsZXhlbWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHN0YXJ0TmV3TW9kZShuZXdNb2RlLCBtYXRjaCk7XG4gICAgICByZXR1cm4gbmV3TW9kZS5yZXR1cm5CZWdpbiA/IDAgOiBsZXhlbWUubGVuZ3RoO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEhhbmRsZSB0aGUgcG90ZW50aWFsIGVuZCBvZiBtb2RlXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1JlZ0V4cE1hdGNoQXJyYXl9IG1hdGNoIC0gdGhlIGN1cnJlbnQgbWF0Y2hcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBkb0VuZE1hdGNoKG1hdGNoKSB7XG4gICAgICBjb25zdCBsZXhlbWUgPSBtYXRjaFswXTtcbiAgICAgIGNvbnN0IG1hdGNoUGx1c1JlbWFpbmRlciA9IGNvZGVUb0hpZ2hsaWdodC5zdWJzdHIobWF0Y2guaW5kZXgpO1xuXG4gICAgICBjb25zdCBlbmRNb2RlID0gZW5kT2ZNb2RlKHRvcCwgbWF0Y2gsIG1hdGNoUGx1c1JlbWFpbmRlcik7XG4gICAgICBpZiAoIWVuZE1vZGUpIHsgcmV0dXJuIE5PX01BVENIOyB9XG5cbiAgICAgIGNvbnN0IG9yaWdpbiA9IHRvcDtcbiAgICAgIGlmICh0b3AuZW5kU2NvcGUgJiYgdG9wLmVuZFNjb3BlLl93cmFwKSB7XG4gICAgICAgIHByb2Nlc3NCdWZmZXIoKTtcbiAgICAgICAgZW1pdHRlci5hZGRLZXl3b3JkKGxleGVtZSwgdG9wLmVuZFNjb3BlLl93cmFwKTtcbiAgICAgIH0gZWxzZSBpZiAodG9wLmVuZFNjb3BlICYmIHRvcC5lbmRTY29wZS5fbXVsdGkpIHtcbiAgICAgICAgcHJvY2Vzc0J1ZmZlcigpO1xuICAgICAgICBlbWl0TXVsdGlDbGFzcyh0b3AuZW5kU2NvcGUsIG1hdGNoKTtcbiAgICAgIH0gZWxzZSBpZiAob3JpZ2luLnNraXApIHtcbiAgICAgICAgbW9kZUJ1ZmZlciArPSBsZXhlbWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoIShvcmlnaW4ucmV0dXJuRW5kIHx8IG9yaWdpbi5leGNsdWRlRW5kKSkge1xuICAgICAgICAgIG1vZGVCdWZmZXIgKz0gbGV4ZW1lO1xuICAgICAgICB9XG4gICAgICAgIHByb2Nlc3NCdWZmZXIoKTtcbiAgICAgICAgaWYgKG9yaWdpbi5leGNsdWRlRW5kKSB7XG4gICAgICAgICAgbW9kZUJ1ZmZlciA9IGxleGVtZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZG8ge1xuICAgICAgICBpZiAodG9wLnNjb3BlKSB7XG4gICAgICAgICAgZW1pdHRlci5jbG9zZU5vZGUoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRvcC5za2lwICYmICF0b3Auc3ViTGFuZ3VhZ2UpIHtcbiAgICAgICAgICByZWxldmFuY2UgKz0gdG9wLnJlbGV2YW5jZTtcbiAgICAgICAgfVxuICAgICAgICB0b3AgPSB0b3AucGFyZW50O1xuICAgICAgfSB3aGlsZSAodG9wICE9PSBlbmRNb2RlLnBhcmVudCk7XG4gICAgICBpZiAoZW5kTW9kZS5zdGFydHMpIHtcbiAgICAgICAgc3RhcnROZXdNb2RlKGVuZE1vZGUuc3RhcnRzLCBtYXRjaCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gb3JpZ2luLnJldHVybkVuZCA/IDAgOiBsZXhlbWUubGVuZ3RoO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHByb2Nlc3NDb250aW51YXRpb25zKCkge1xuICAgICAgY29uc3QgbGlzdCA9IFtdO1xuICAgICAgZm9yIChsZXQgY3VycmVudCA9IHRvcDsgY3VycmVudCAhPT0gbGFuZ3VhZ2U7IGN1cnJlbnQgPSBjdXJyZW50LnBhcmVudCkge1xuICAgICAgICBpZiAoY3VycmVudC5zY29wZSkge1xuICAgICAgICAgIGxpc3QudW5zaGlmdChjdXJyZW50LnNjb3BlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgbGlzdC5mb3JFYWNoKGl0ZW0gPT4gZW1pdHRlci5vcGVuTm9kZShpdGVtKSk7XG4gICAgfVxuXG4gICAgLyoqIEB0eXBlIHt7dHlwZT86IE1hdGNoVHlwZSwgaW5kZXg/OiBudW1iZXIsIHJ1bGU/OiBNb2RlfX19ICovXG4gICAgbGV0IGxhc3RNYXRjaCA9IHt9O1xuXG4gICAgLyoqXG4gICAgICogIFByb2Nlc3MgYW4gaW5kaXZpZHVhbCBtYXRjaFxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRleHRCZWZvcmVNYXRjaCAtIHRleHQgcHJlY2VkaW5nIHRoZSBtYXRjaCAoc2luY2UgdGhlIGxhc3QgbWF0Y2gpXG4gICAgICogQHBhcmFtIHtFbmhhbmNlZE1hdGNofSBbbWF0Y2hdIC0gdGhlIG1hdGNoIGl0c2VsZlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHByb2Nlc3NMZXhlbWUodGV4dEJlZm9yZU1hdGNoLCBtYXRjaCkge1xuICAgICAgY29uc3QgbGV4ZW1lID0gbWF0Y2ggJiYgbWF0Y2hbMF07XG5cbiAgICAgIC8vIGFkZCBub24tbWF0Y2hlZCB0ZXh0IHRvIHRoZSBjdXJyZW50IG1vZGUgYnVmZmVyXG4gICAgICBtb2RlQnVmZmVyICs9IHRleHRCZWZvcmVNYXRjaDtcblxuICAgICAgaWYgKGxleGVtZSA9PSBudWxsKSB7XG4gICAgICAgIHByb2Nlc3NCdWZmZXIoKTtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9XG5cbiAgICAgIC8vIHdlJ3ZlIGZvdW5kIGEgMCB3aWR0aCBtYXRjaCBhbmQgd2UncmUgc3R1Y2ssIHNvIHdlIG5lZWQgdG8gYWR2YW5jZVxuICAgICAgLy8gdGhpcyBoYXBwZW5zIHdoZW4gd2UgaGF2ZSBiYWRseSBiZWhhdmVkIHJ1bGVzIHRoYXQgaGF2ZSBvcHRpb25hbCBtYXRjaGVycyB0byB0aGUgZGVncmVlIHRoYXRcbiAgICAgIC8vIHNvbWV0aW1lcyB0aGV5IGNhbiBlbmQgdXAgbWF0Y2hpbmcgbm90aGluZyBhdCBhbGxcbiAgICAgIC8vIFJlZjogaHR0cHM6Ly9naXRodWIuY29tL2hpZ2hsaWdodGpzL2hpZ2hsaWdodC5qcy9pc3N1ZXMvMjE0MFxuICAgICAgaWYgKGxhc3RNYXRjaC50eXBlID09PSBcImJlZ2luXCIgJiYgbWF0Y2gudHlwZSA9PT0gXCJlbmRcIiAmJiBsYXN0TWF0Y2guaW5kZXggPT09IG1hdGNoLmluZGV4ICYmIGxleGVtZSA9PT0gXCJcIikge1xuICAgICAgICAvLyBzcGl0IHRoZSBcInNraXBwZWRcIiBjaGFyYWN0ZXIgdGhhdCBvdXIgcmVnZXggY2hva2VkIG9uIGJhY2sgaW50byB0aGUgb3V0cHV0IHNlcXVlbmNlXG4gICAgICAgIG1vZGVCdWZmZXIgKz0gY29kZVRvSGlnaGxpZ2h0LnNsaWNlKG1hdGNoLmluZGV4LCBtYXRjaC5pbmRleCArIDEpO1xuICAgICAgICBpZiAoIVNBRkVfTU9ERSkge1xuICAgICAgICAgIC8qKiBAdHlwZSB7QW5ub3RhdGVkRXJyb3J9ICovXG4gICAgICAgICAgY29uc3QgZXJyID0gbmV3IEVycm9yKGAwIHdpZHRoIG1hdGNoIHJlZ2V4ICgke2xhbmd1YWdlTmFtZX0pYCk7XG4gICAgICAgICAgZXJyLmxhbmd1YWdlTmFtZSA9IGxhbmd1YWdlTmFtZTtcbiAgICAgICAgICBlcnIuYmFkUnVsZSA9IGxhc3RNYXRjaC5ydWxlO1xuICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gMTtcbiAgICAgIH1cbiAgICAgIGxhc3RNYXRjaCA9IG1hdGNoO1xuXG4gICAgICBpZiAobWF0Y2gudHlwZSA9PT0gXCJiZWdpblwiKSB7XG4gICAgICAgIHJldHVybiBkb0JlZ2luTWF0Y2gobWF0Y2gpO1xuICAgICAgfSBlbHNlIGlmIChtYXRjaC50eXBlID09PSBcImlsbGVnYWxcIiAmJiAhaWdub3JlSWxsZWdhbHMpIHtcbiAgICAgICAgLy8gaWxsZWdhbCBtYXRjaCwgd2UgZG8gbm90IGNvbnRpbnVlIHByb2Nlc3NpbmdcbiAgICAgICAgLyoqIEB0eXBlIHtBbm5vdGF0ZWRFcnJvcn0gKi9cbiAgICAgICAgY29uc3QgZXJyID0gbmV3IEVycm9yKCdJbGxlZ2FsIGxleGVtZSBcIicgKyBsZXhlbWUgKyAnXCIgZm9yIG1vZGUgXCInICsgKHRvcC5zY29wZSB8fCAnPHVubmFtZWQ+JykgKyAnXCInKTtcbiAgICAgICAgZXJyLm1vZGUgPSB0b3A7XG4gICAgICAgIHRocm93IGVycjtcbiAgICAgIH0gZWxzZSBpZiAobWF0Y2gudHlwZSA9PT0gXCJlbmRcIikge1xuICAgICAgICBjb25zdCBwcm9jZXNzZWQgPSBkb0VuZE1hdGNoKG1hdGNoKTtcbiAgICAgICAgaWYgKHByb2Nlc3NlZCAhPT0gTk9fTUFUQ0gpIHtcbiAgICAgICAgICByZXR1cm4gcHJvY2Vzc2VkO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIGVkZ2UgY2FzZSBmb3Igd2hlbiBpbGxlZ2FsIG1hdGNoZXMgJCAoZW5kIG9mIGxpbmUpIHdoaWNoIGlzIHRlY2huaWNhbGx5XG4gICAgICAvLyBhIDAgd2lkdGggbWF0Y2ggYnV0IG5vdCBhIGJlZ2luL2VuZCBtYXRjaCBzbyBpdCdzIG5vdCBjYXVnaHQgYnkgdGhlXG4gICAgICAvLyBmaXJzdCBoYW5kbGVyICh3aGVuIGlnbm9yZUlsbGVnYWxzIGlzIHRydWUpXG4gICAgICBpZiAobWF0Y2gudHlwZSA9PT0gXCJpbGxlZ2FsXCIgJiYgbGV4ZW1lID09PSBcIlwiKSB7XG4gICAgICAgIC8vIGFkdmFuY2Ugc28gd2UgYXJlbid0IHN0dWNrIGluIGFuIGluZmluaXRlIGxvb3BcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgICB9XG5cbiAgICAgIC8vIGluZmluaXRlIGxvb3BzIGFyZSBCQUQsIHRoaXMgaXMgYSBsYXN0IGRpdGNoIGNhdGNoIGFsbC4gaWYgd2UgaGF2ZSBhXG4gICAgICAvLyBkZWNlbnQgbnVtYmVyIG9mIGl0ZXJhdGlvbnMgeWV0IG91ciBpbmRleCAoY3Vyc29yIHBvc2l0aW9uIGluIG91clxuICAgICAgLy8gcGFyc2luZykgc3RpbGwgM3ggYmVoaW5kIG91ciBpbmRleCB0aGVuIHNvbWV0aGluZyBpcyB2ZXJ5IHdyb25nXG4gICAgICAvLyBzbyB3ZSBiYWlsXG4gICAgICBpZiAoaXRlcmF0aW9ucyA+IDEwMDAwMCAmJiBpdGVyYXRpb25zID4gbWF0Y2guaW5kZXggKiAzKSB7XG4gICAgICAgIGNvbnN0IGVyciA9IG5ldyBFcnJvcigncG90ZW50aWFsIGluZmluaXRlIGxvb3AsIHdheSBtb3JlIGl0ZXJhdGlvbnMgdGhhbiBtYXRjaGVzJyk7XG4gICAgICAgIHRocm93IGVycjtcbiAgICAgIH1cblxuICAgICAgLypcbiAgICAgIFdoeSBtaWdodCBiZSBmaW5kIG91cnNlbHZlcyBoZXJlPyAgQW4gcG90ZW50aWFsIGVuZCBtYXRjaCB0aGF0IHdhc1xuICAgICAgdHJpZ2dlcmVkIGJ1dCBjb3VsZCBub3QgYmUgY29tcGxldGVkLiAgSUUsIGBkb0VuZE1hdGNoYCByZXR1cm5lZCBOT19NQVRDSC5cbiAgICAgICh0aGlzIGNvdWxkIGJlIGJlY2F1c2UgYSBjYWxsYmFjayByZXF1ZXN0cyB0aGUgbWF0Y2ggYmUgaWdub3JlZCwgZXRjKVxuXG4gICAgICBUaGlzIGNhdXNlcyBubyByZWFsIGhhcm0gb3RoZXIgdGhhbiBzdG9wcGluZyBhIGZldyB0aW1lcyB0b28gbWFueS5cbiAgICAgICovXG5cbiAgICAgIG1vZGVCdWZmZXIgKz0gbGV4ZW1lO1xuICAgICAgcmV0dXJuIGxleGVtZS5sZW5ndGg7XG4gICAgfVxuXG4gICAgY29uc3QgbGFuZ3VhZ2UgPSBnZXRMYW5ndWFnZShsYW5ndWFnZU5hbWUpO1xuICAgIGlmICghbGFuZ3VhZ2UpIHtcbiAgICAgIGVycm9yKExBTkdVQUdFX05PVF9GT1VORC5yZXBsYWNlKFwie31cIiwgbGFuZ3VhZ2VOYW1lKSk7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gbGFuZ3VhZ2U6IFwiJyArIGxhbmd1YWdlTmFtZSArICdcIicpO1xuICAgIH1cblxuICAgIGNvbnN0IG1kID0gY29tcGlsZUxhbmd1YWdlKGxhbmd1YWdlKTtcbiAgICBsZXQgcmVzdWx0ID0gJyc7XG4gICAgLyoqIEB0eXBlIHtDb21waWxlZE1vZGV9ICovXG4gICAgbGV0IHRvcCA9IGNvbnRpbnVhdGlvbiB8fCBtZDtcbiAgICAvKiogQHR5cGUgUmVjb3JkPHN0cmluZyxDb21waWxlZE1vZGU+ICovXG4gICAgY29uc3QgY29udGludWF0aW9ucyA9IHt9OyAvLyBrZWVwIGNvbnRpbnVhdGlvbnMgZm9yIHN1Yi1sYW5ndWFnZXNcbiAgICBjb25zdCBlbWl0dGVyID0gbmV3IG9wdGlvbnMuX19lbWl0dGVyKG9wdGlvbnMpO1xuICAgIHByb2Nlc3NDb250aW51YXRpb25zKCk7XG4gICAgbGV0IG1vZGVCdWZmZXIgPSAnJztcbiAgICBsZXQgcmVsZXZhbmNlID0gMDtcbiAgICBsZXQgaW5kZXggPSAwO1xuICAgIGxldCBpdGVyYXRpb25zID0gMDtcbiAgICBsZXQgcmVzdW1lU2NhbkF0U2FtZVBvc2l0aW9uID0gZmFsc2U7XG5cbiAgICB0cnkge1xuICAgICAgdG9wLm1hdGNoZXIuY29uc2lkZXJBbGwoKTtcblxuICAgICAgZm9yICg7Oykge1xuICAgICAgICBpdGVyYXRpb25zKys7XG4gICAgICAgIGlmIChyZXN1bWVTY2FuQXRTYW1lUG9zaXRpb24pIHtcbiAgICAgICAgICAvLyBvbmx5IHJlZ2V4ZXMgbm90IG1hdGNoZWQgcHJldmlvdXNseSB3aWxsIG5vdyBiZVxuICAgICAgICAgIC8vIGNvbnNpZGVyZWQgZm9yIGEgcG90ZW50aWFsIG1hdGNoXG4gICAgICAgICAgcmVzdW1lU2NhbkF0U2FtZVBvc2l0aW9uID0gZmFsc2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdG9wLm1hdGNoZXIuY29uc2lkZXJBbGwoKTtcbiAgICAgICAgfVxuICAgICAgICB0b3AubWF0Y2hlci5sYXN0SW5kZXggPSBpbmRleDtcblxuICAgICAgICBjb25zdCBtYXRjaCA9IHRvcC5tYXRjaGVyLmV4ZWMoY29kZVRvSGlnaGxpZ2h0KTtcbiAgICAgICAgLy8gY29uc29sZS5sb2coXCJtYXRjaFwiLCBtYXRjaFswXSwgbWF0Y2gucnVsZSAmJiBtYXRjaC5ydWxlLmJlZ2luKVxuXG4gICAgICAgIGlmICghbWF0Y2gpIGJyZWFrO1xuXG4gICAgICAgIGNvbnN0IGJlZm9yZU1hdGNoID0gY29kZVRvSGlnaGxpZ2h0LnN1YnN0cmluZyhpbmRleCwgbWF0Y2guaW5kZXgpO1xuICAgICAgICBjb25zdCBwcm9jZXNzZWRDb3VudCA9IHByb2Nlc3NMZXhlbWUoYmVmb3JlTWF0Y2gsIG1hdGNoKTtcbiAgICAgICAgaW5kZXggPSBtYXRjaC5pbmRleCArIHByb2Nlc3NlZENvdW50O1xuICAgICAgfVxuICAgICAgcHJvY2Vzc0xleGVtZShjb2RlVG9IaWdobGlnaHQuc3Vic3RyKGluZGV4KSk7XG4gICAgICBlbWl0dGVyLmNsb3NlQWxsTm9kZXMoKTtcbiAgICAgIGVtaXR0ZXIuZmluYWxpemUoKTtcbiAgICAgIHJlc3VsdCA9IGVtaXR0ZXIudG9IVE1MKCk7XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGxhbmd1YWdlOiBsYW5ndWFnZU5hbWUsXG4gICAgICAgIHZhbHVlOiByZXN1bHQsXG4gICAgICAgIHJlbGV2YW5jZTogcmVsZXZhbmNlLFxuICAgICAgICBpbGxlZ2FsOiBmYWxzZSxcbiAgICAgICAgX2VtaXR0ZXI6IGVtaXR0ZXIsXG4gICAgICAgIF90b3A6IHRvcFxuICAgICAgfTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGlmIChlcnIubWVzc2FnZSAmJiBlcnIubWVzc2FnZS5pbmNsdWRlcygnSWxsZWdhbCcpKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbGFuZ3VhZ2U6IGxhbmd1YWdlTmFtZSxcbiAgICAgICAgICB2YWx1ZTogZXNjYXBlKGNvZGVUb0hpZ2hsaWdodCksXG4gICAgICAgICAgaWxsZWdhbDogdHJ1ZSxcbiAgICAgICAgICByZWxldmFuY2U6IDAsXG4gICAgICAgICAgX2lsbGVnYWxCeToge1xuICAgICAgICAgICAgbWVzc2FnZTogZXJyLm1lc3NhZ2UsXG4gICAgICAgICAgICBpbmRleDogaW5kZXgsXG4gICAgICAgICAgICBjb250ZXh0OiBjb2RlVG9IaWdobGlnaHQuc2xpY2UoaW5kZXggLSAxMDAsIGluZGV4ICsgMTAwKSxcbiAgICAgICAgICAgIG1vZGU6IGVyci5tb2RlLFxuICAgICAgICAgICAgcmVzdWx0U29GYXI6IHJlc3VsdFxuICAgICAgICAgIH0sXG4gICAgICAgICAgX2VtaXR0ZXI6IGVtaXR0ZXJcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSBpZiAoU0FGRV9NT0RFKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbGFuZ3VhZ2U6IGxhbmd1YWdlTmFtZSxcbiAgICAgICAgICB2YWx1ZTogZXNjYXBlKGNvZGVUb0hpZ2hsaWdodCksXG4gICAgICAgICAgaWxsZWdhbDogZmFsc2UsXG4gICAgICAgICAgcmVsZXZhbmNlOiAwLFxuICAgICAgICAgIGVycm9yUmFpc2VkOiBlcnIsXG4gICAgICAgICAgX2VtaXR0ZXI6IGVtaXR0ZXIsXG4gICAgICAgICAgX3RvcDogdG9wXG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBlcnI7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIHJldHVybnMgYSB2YWxpZCBoaWdobGlnaHQgcmVzdWx0LCB3aXRob3V0IGFjdHVhbGx5IGRvaW5nIGFueSBhY3R1YWwgd29yayxcbiAgICogYXV0byBoaWdobGlnaHQgc3RhcnRzIHdpdGggdGhpcyBhbmQgaXQncyBwb3NzaWJsZSBmb3Igc21hbGwgc25pcHBldHMgdGhhdFxuICAgKiBhdXRvLWRldGVjdGlvbiBtYXkgbm90IGZpbmQgYSBiZXR0ZXIgbWF0Y2hcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNvZGVcbiAgICogQHJldHVybnMge0hpZ2hsaWdodFJlc3VsdH1cbiAgICovXG4gIGZ1bmN0aW9uIGp1c3RUZXh0SGlnaGxpZ2h0UmVzdWx0KGNvZGUpIHtcbiAgICBjb25zdCByZXN1bHQgPSB7XG4gICAgICB2YWx1ZTogZXNjYXBlKGNvZGUpLFxuICAgICAgaWxsZWdhbDogZmFsc2UsXG4gICAgICByZWxldmFuY2U6IDAsXG4gICAgICBfdG9wOiBQTEFJTlRFWFRfTEFOR1VBR0UsXG4gICAgICBfZW1pdHRlcjogbmV3IG9wdGlvbnMuX19lbWl0dGVyKG9wdGlvbnMpXG4gICAgfTtcbiAgICByZXN1bHQuX2VtaXR0ZXIuYWRkVGV4dChjb2RlKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gIEhpZ2hsaWdodGluZyB3aXRoIGxhbmd1YWdlIGRldGVjdGlvbi4gQWNjZXB0cyBhIHN0cmluZyB3aXRoIHRoZSBjb2RlIHRvXG4gIGhpZ2hsaWdodC4gUmV0dXJucyBhbiBvYmplY3Qgd2l0aCB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG5cbiAgLSBsYW5ndWFnZSAoZGV0ZWN0ZWQgbGFuZ3VhZ2UpXG4gIC0gcmVsZXZhbmNlIChpbnQpXG4gIC0gdmFsdWUgKGFuIEhUTUwgc3RyaW5nIHdpdGggaGlnaGxpZ2h0aW5nIG1hcmt1cClcbiAgLSBzZWNvbmRCZXN0IChvYmplY3Qgd2l0aCB0aGUgc2FtZSBzdHJ1Y3R1cmUgZm9yIHNlY29uZC1iZXN0IGhldXJpc3RpY2FsbHlcbiAgICBkZXRlY3RlZCBsYW5ndWFnZSwgbWF5IGJlIGFic2VudClcblxuICAgIEBwYXJhbSB7c3RyaW5nfSBjb2RlXG4gICAgQHBhcmFtIHtBcnJheTxzdHJpbmc+fSBbbGFuZ3VhZ2VTdWJzZXRdXG4gICAgQHJldHVybnMge0F1dG9IaWdobGlnaHRSZXN1bHR9XG4gICovXG4gIGZ1bmN0aW9uIGhpZ2hsaWdodEF1dG8oY29kZSwgbGFuZ3VhZ2VTdWJzZXQpIHtcbiAgICBsYW5ndWFnZVN1YnNldCA9IGxhbmd1YWdlU3Vic2V0IHx8IG9wdGlvbnMubGFuZ3VhZ2VzIHx8IE9iamVjdC5rZXlzKGxhbmd1YWdlcyk7XG4gICAgY29uc3QgcGxhaW50ZXh0ID0ganVzdFRleHRIaWdobGlnaHRSZXN1bHQoY29kZSk7XG5cbiAgICBjb25zdCByZXN1bHRzID0gbGFuZ3VhZ2VTdWJzZXQuZmlsdGVyKGdldExhbmd1YWdlKS5maWx0ZXIoYXV0b0RldGVjdGlvbikubWFwKG5hbWUgPT5cbiAgICAgIF9oaWdobGlnaHQobmFtZSwgY29kZSwgZmFsc2UpXG4gICAgKTtcbiAgICByZXN1bHRzLnVuc2hpZnQocGxhaW50ZXh0KTsgLy8gcGxhaW50ZXh0IGlzIGFsd2F5cyBhbiBvcHRpb25cblxuICAgIGNvbnN0IHNvcnRlZCA9IHJlc3VsdHMuc29ydCgoYSwgYikgPT4ge1xuICAgICAgLy8gc29ydCBiYXNlIG9uIHJlbGV2YW5jZVxuICAgICAgaWYgKGEucmVsZXZhbmNlICE9PSBiLnJlbGV2YW5jZSkgcmV0dXJuIGIucmVsZXZhbmNlIC0gYS5yZWxldmFuY2U7XG5cbiAgICAgIC8vIGFsd2F5cyBhd2FyZCB0aGUgdGllIHRvIHRoZSBiYXNlIGxhbmd1YWdlXG4gICAgICAvLyBpZSBpZiBDKysgYW5kIEFyZHVpbm8gYXJlIHRpZWQsIGl0J3MgbW9yZSBsaWtlbHkgdG8gYmUgQysrXG4gICAgICBpZiAoYS5sYW5ndWFnZSAmJiBiLmxhbmd1YWdlKSB7XG4gICAgICAgIGlmIChnZXRMYW5ndWFnZShhLmxhbmd1YWdlKS5zdXBlcnNldE9mID09PSBiLmxhbmd1YWdlKSB7XG4gICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH0gZWxzZSBpZiAoZ2V0TGFuZ3VhZ2UoYi5sYW5ndWFnZSkuc3VwZXJzZXRPZiA9PT0gYS5sYW5ndWFnZSkge1xuICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBvdGhlcndpc2Ugc2F5IHRoZXkgYXJlIGVxdWFsLCB3aGljaCBoYXMgdGhlIGVmZmVjdCBvZiBzb3J0aW5nIG9uXG4gICAgICAvLyByZWxldmFuY2Ugd2hpbGUgcHJlc2VydmluZyB0aGUgb3JpZ2luYWwgb3JkZXJpbmcgLSB3aGljaCBpcyBob3cgdGllc1xuICAgICAgLy8gaGF2ZSBoaXN0b3JpY2FsbHkgYmVlbiBzZXR0bGVkLCBpZSB0aGUgbGFuZ3VhZ2UgdGhhdCBjb21lcyBmaXJzdCBhbHdheXNcbiAgICAgIC8vIHdpbnMgaW4gdGhlIGNhc2Ugb2YgYSB0aWVcbiAgICAgIHJldHVybiAwO1xuICAgIH0pO1xuXG4gICAgY29uc3QgW2Jlc3QsIHNlY29uZEJlc3RdID0gc29ydGVkO1xuXG4gICAgLyoqIEB0eXBlIHtBdXRvSGlnaGxpZ2h0UmVzdWx0fSAqL1xuICAgIGNvbnN0IHJlc3VsdCA9IGJlc3Q7XG4gICAgcmVzdWx0LnNlY29uZEJlc3QgPSBzZWNvbmRCZXN0O1xuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBCdWlsZHMgbmV3IGNsYXNzIG5hbWUgZm9yIGJsb2NrIGdpdmVuIHRoZSBsYW5ndWFnZSBuYW1lXG4gICAqXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnRcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtjdXJyZW50TGFuZ11cbiAgICogQHBhcmFtIHtzdHJpbmd9IFtyZXN1bHRMYW5nXVxuICAgKi9cbiAgZnVuY3Rpb24gdXBkYXRlQ2xhc3NOYW1lKGVsZW1lbnQsIGN1cnJlbnRMYW5nLCByZXN1bHRMYW5nKSB7XG4gICAgY29uc3QgbGFuZ3VhZ2UgPSAoY3VycmVudExhbmcgJiYgYWxpYXNlc1tjdXJyZW50TGFuZ10pIHx8IHJlc3VsdExhbmc7XG5cbiAgICBlbGVtZW50LmNsYXNzTGlzdC5hZGQoXCJobGpzXCIpO1xuICAgIGVsZW1lbnQuY2xhc3NMaXN0LmFkZChgbGFuZ3VhZ2UtJHtsYW5ndWFnZX1gKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBcHBsaWVzIGhpZ2hsaWdodGluZyB0byBhIERPTSBub2RlIGNvbnRhaW5pbmcgY29kZS5cbiAgICpcbiAgICogQHBhcmFtIHtIaWdobGlnaHRlZEhUTUxFbGVtZW50fSBlbGVtZW50IC0gdGhlIEhUTUwgZWxlbWVudCB0byBoaWdobGlnaHRcbiAgKi9cbiAgZnVuY3Rpb24gaGlnaGxpZ2h0RWxlbWVudChlbGVtZW50KSB7XG4gICAgLyoqIEB0eXBlIEhUTUxFbGVtZW50ICovXG4gICAgbGV0IG5vZGUgPSBudWxsO1xuICAgIGNvbnN0IGxhbmd1YWdlID0gYmxvY2tMYW5ndWFnZShlbGVtZW50KTtcblxuICAgIGlmIChzaG91bGROb3RIaWdobGlnaHQobGFuZ3VhZ2UpKSByZXR1cm47XG5cbiAgICBmaXJlKFwiYmVmb3JlOmhpZ2hsaWdodEVsZW1lbnRcIixcbiAgICAgIHsgZWw6IGVsZW1lbnQsIGxhbmd1YWdlOiBsYW5ndWFnZSB9KTtcblxuICAgIC8vIHdlIHNob3VsZCBiZSBhbGwgdGV4dCwgbm8gY2hpbGQgbm9kZXNcbiAgICBpZiAoIW9wdGlvbnMuaWdub3JlVW5lc2NhcGVkSFRNTCAmJiBlbGVtZW50LmNoaWxkcmVuLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnNvbGUud2FybihcIk9uZSBvZiB5b3VyIGNvZGUgYmxvY2tzIGluY2x1ZGVzIHVuZXNjYXBlZCBIVE1MLiBUaGlzIGlzIGEgcG90ZW50aWFsbHkgc2VyaW91cyBzZWN1cml0eSByaXNrLlwiKTtcbiAgICAgIGNvbnNvbGUud2FybihcImh0dHBzOi8vZ2l0aHViLmNvbS9oaWdobGlnaHRqcy9oaWdobGlnaHQuanMvaXNzdWVzLzI4ODZcIik7XG4gICAgICBjb25zb2xlLndhcm4oZWxlbWVudCk7XG4gICAgfVxuXG4gICAgbm9kZSA9IGVsZW1lbnQ7XG4gICAgY29uc3QgdGV4dCA9IG5vZGUudGV4dENvbnRlbnQ7XG4gICAgY29uc3QgcmVzdWx0ID0gbGFuZ3VhZ2UgPyBoaWdobGlnaHQodGV4dCwgeyBsYW5ndWFnZSwgaWdub3JlSWxsZWdhbHM6IHRydWUgfSkgOiBoaWdobGlnaHRBdXRvKHRleHQpO1xuXG4gICAgZWxlbWVudC5pbm5lckhUTUwgPSByZXN1bHQudmFsdWU7XG4gICAgdXBkYXRlQ2xhc3NOYW1lKGVsZW1lbnQsIGxhbmd1YWdlLCByZXN1bHQubGFuZ3VhZ2UpO1xuICAgIGVsZW1lbnQucmVzdWx0ID0ge1xuICAgICAgbGFuZ3VhZ2U6IHJlc3VsdC5sYW5ndWFnZSxcbiAgICAgIC8vIFRPRE86IHJlbW92ZSB3aXRoIHZlcnNpb24gMTEuMFxuICAgICAgcmU6IHJlc3VsdC5yZWxldmFuY2UsXG4gICAgICByZWxldmFuY2U6IHJlc3VsdC5yZWxldmFuY2VcbiAgICB9O1xuICAgIGlmIChyZXN1bHQuc2Vjb25kQmVzdCkge1xuICAgICAgZWxlbWVudC5zZWNvbmRCZXN0ID0ge1xuICAgICAgICBsYW5ndWFnZTogcmVzdWx0LnNlY29uZEJlc3QubGFuZ3VhZ2UsXG4gICAgICAgIHJlbGV2YW5jZTogcmVzdWx0LnNlY29uZEJlc3QucmVsZXZhbmNlXG4gICAgICB9O1xuICAgIH1cblxuICAgIGZpcmUoXCJhZnRlcjpoaWdobGlnaHRFbGVtZW50XCIsIHsgZWw6IGVsZW1lbnQsIHJlc3VsdCwgdGV4dCB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGVzIGhpZ2hsaWdodC5qcyBnbG9iYWwgb3B0aW9ucyB3aXRoIHRoZSBwYXNzZWQgb3B0aW9uc1xuICAgKlxuICAgKiBAcGFyYW0ge1BhcnRpYWw8SExKU09wdGlvbnM+fSB1c2VyT3B0aW9uc1xuICAgKi9cbiAgZnVuY3Rpb24gY29uZmlndXJlKHVzZXJPcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IGluaGVyaXQob3B0aW9ucywgdXNlck9wdGlvbnMpO1xuICB9XG5cbiAgLy8gVE9ETzogcmVtb3ZlIHYxMiwgZGVwcmVjYXRlZFxuICBjb25zdCBpbml0SGlnaGxpZ2h0aW5nID0gKCkgPT4ge1xuICAgIGhpZ2hsaWdodEFsbCgpO1xuICAgIGRlcHJlY2F0ZWQoXCIxMC42LjBcIiwgXCJpbml0SGlnaGxpZ2h0aW5nKCkgZGVwcmVjYXRlZC4gIFVzZSBoaWdobGlnaHRBbGwoKSBub3cuXCIpO1xuICB9O1xuXG4gIC8vIFRPRE86IHJlbW92ZSB2MTIsIGRlcHJlY2F0ZWRcbiAgZnVuY3Rpb24gaW5pdEhpZ2hsaWdodGluZ09uTG9hZCgpIHtcbiAgICBoaWdobGlnaHRBbGwoKTtcbiAgICBkZXByZWNhdGVkKFwiMTAuNi4wXCIsIFwiaW5pdEhpZ2hsaWdodGluZ09uTG9hZCgpIGRlcHJlY2F0ZWQuICBVc2UgaGlnaGxpZ2h0QWxsKCkgbm93LlwiKTtcbiAgfVxuXG4gIGxldCB3YW50c0hpZ2hsaWdodCA9IGZhbHNlO1xuXG4gIC8qKlxuICAgKiBhdXRvLWhpZ2hsaWdodHMgYWxsIHByZT5jb2RlIGVsZW1lbnRzIG9uIHRoZSBwYWdlXG4gICAqL1xuICBmdW5jdGlvbiBoaWdobGlnaHRBbGwoKSB7XG4gICAgLy8gaWYgd2UgYXJlIGNhbGxlZCB0b28gZWFybHkgaW4gdGhlIGxvYWRpbmcgcHJvY2Vzc1xuICAgIGlmIChkb2N1bWVudC5yZWFkeVN0YXRlID09PSBcImxvYWRpbmdcIikge1xuICAgICAgd2FudHNIaWdobGlnaHQgPSB0cnVlO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGJsb2NrcyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwob3B0aW9ucy5jc3NTZWxlY3Rvcik7XG4gICAgYmxvY2tzLmZvckVhY2goaGlnaGxpZ2h0RWxlbWVudCk7XG4gIH1cblxuICBmdW5jdGlvbiBib290KCkge1xuICAgIC8vIGlmIGEgaGlnaGxpZ2h0IHdhcyByZXF1ZXN0ZWQgYmVmb3JlIERPTSB3YXMgbG9hZGVkLCBkbyBub3dcbiAgICBpZiAod2FudHNIaWdobGlnaHQpIGhpZ2hsaWdodEFsbCgpO1xuICB9XG5cbiAgLy8gbWFrZSBzdXJlIHdlIGFyZSBpbiB0aGUgYnJvd3NlciBlbnZpcm9ubWVudFxuICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignRE9NQ29udGVudExvYWRlZCcsIGJvb3QsIGZhbHNlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWdpc3RlciBhIGxhbmd1YWdlIGdyYW1tYXIgbW9kdWxlXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBsYW5ndWFnZU5hbWVcbiAgICogQHBhcmFtIHtMYW5ndWFnZUZufSBsYW5ndWFnZURlZmluaXRpb25cbiAgICovXG4gIGZ1bmN0aW9uIHJlZ2lzdGVyTGFuZ3VhZ2UobGFuZ3VhZ2VOYW1lLCBsYW5ndWFnZURlZmluaXRpb24pIHtcbiAgICBsZXQgbGFuZyA9IG51bGw7XG4gICAgdHJ5IHtcbiAgICAgIGxhbmcgPSBsYW5ndWFnZURlZmluaXRpb24oaGxqcyk7XG4gICAgfSBjYXRjaCAoZXJyb3IkMSkge1xuICAgICAgZXJyb3IoXCJMYW5ndWFnZSBkZWZpbml0aW9uIGZvciAne30nIGNvdWxkIG5vdCBiZSByZWdpc3RlcmVkLlwiLnJlcGxhY2UoXCJ7fVwiLCBsYW5ndWFnZU5hbWUpKTtcbiAgICAgIC8vIGhhcmQgb3Igc29mdCBlcnJvclxuICAgICAgaWYgKCFTQUZFX01PREUpIHsgdGhyb3cgZXJyb3IkMTsgfSBlbHNlIHsgZXJyb3IoZXJyb3IkMSk7IH1cbiAgICAgIC8vIGxhbmd1YWdlcyB0aGF0IGhhdmUgc2VyaW91cyBlcnJvcnMgYXJlIHJlcGxhY2VkIHdpdGggZXNzZW50aWFsbHkgYVxuICAgICAgLy8gXCJwbGFpbnRleHRcIiBzdGFuZC1pbiBzbyB0aGF0IHRoZSBjb2RlIGJsb2NrcyB3aWxsIHN0aWxsIGdldCBub3JtYWxcbiAgICAgIC8vIGNzcyBjbGFzc2VzIGFwcGxpZWQgdG8gdGhlbSAtIGFuZCBvbmUgYmFkIGxhbmd1YWdlIHdvbid0IGJyZWFrIHRoZVxuICAgICAgLy8gZW50aXJlIGhpZ2hsaWdodGVyXG4gICAgICBsYW5nID0gUExBSU5URVhUX0xBTkdVQUdFO1xuICAgIH1cbiAgICAvLyBnaXZlIGl0IGEgdGVtcG9yYXJ5IG5hbWUgaWYgaXQgZG9lc24ndCBoYXZlIG9uZSBpbiB0aGUgbWV0YS1kYXRhXG4gICAgaWYgKCFsYW5nLm5hbWUpIGxhbmcubmFtZSA9IGxhbmd1YWdlTmFtZTtcbiAgICBsYW5ndWFnZXNbbGFuZ3VhZ2VOYW1lXSA9IGxhbmc7XG4gICAgbGFuZy5yYXdEZWZpbml0aW9uID0gbGFuZ3VhZ2VEZWZpbml0aW9uLmJpbmQobnVsbCwgaGxqcyk7XG5cbiAgICBpZiAobGFuZy5hbGlhc2VzKSB7XG4gICAgICByZWdpc3RlckFsaWFzZXMobGFuZy5hbGlhc2VzLCB7IGxhbmd1YWdlTmFtZSB9KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlIGEgbGFuZ3VhZ2UgZ3JhbW1hciBtb2R1bGVcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGxhbmd1YWdlTmFtZVxuICAgKi9cbiAgZnVuY3Rpb24gdW5yZWdpc3Rlckxhbmd1YWdlKGxhbmd1YWdlTmFtZSkge1xuICAgIGRlbGV0ZSBsYW5ndWFnZXNbbGFuZ3VhZ2VOYW1lXTtcbiAgICBmb3IgKGNvbnN0IGFsaWFzIG9mIE9iamVjdC5rZXlzKGFsaWFzZXMpKSB7XG4gICAgICBpZiAoYWxpYXNlc1thbGlhc10gPT09IGxhbmd1YWdlTmFtZSkge1xuICAgICAgICBkZWxldGUgYWxpYXNlc1thbGlhc107XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm5zIHtzdHJpbmdbXX0gTGlzdCBvZiBsYW5ndWFnZSBpbnRlcm5hbCBuYW1lc1xuICAgKi9cbiAgZnVuY3Rpb24gbGlzdExhbmd1YWdlcygpIHtcbiAgICByZXR1cm4gT2JqZWN0LmtleXMobGFuZ3VhZ2VzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSAtIG5hbWUgb2YgdGhlIGxhbmd1YWdlIHRvIHJldHJpZXZlXG4gICAqIEByZXR1cm5zIHtMYW5ndWFnZSB8IHVuZGVmaW5lZH1cbiAgICovXG4gIGZ1bmN0aW9uIGdldExhbmd1YWdlKG5hbWUpIHtcbiAgICBuYW1lID0gKG5hbWUgfHwgJycpLnRvTG93ZXJDYXNlKCk7XG4gICAgcmV0dXJuIGxhbmd1YWdlc1tuYW1lXSB8fCBsYW5ndWFnZXNbYWxpYXNlc1tuYW1lXV07XG4gIH1cblxuICAvKipcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd8c3RyaW5nW119IGFsaWFzTGlzdCAtIHNpbmdsZSBhbGlhcyBvciBsaXN0IG9mIGFsaWFzZXNcbiAgICogQHBhcmFtIHt7bGFuZ3VhZ2VOYW1lOiBzdHJpbmd9fSBvcHRzXG4gICAqL1xuICBmdW5jdGlvbiByZWdpc3RlckFsaWFzZXMoYWxpYXNMaXN0LCB7IGxhbmd1YWdlTmFtZSB9KSB7XG4gICAgaWYgKHR5cGVvZiBhbGlhc0xpc3QgPT09ICdzdHJpbmcnKSB7XG4gICAgICBhbGlhc0xpc3QgPSBbYWxpYXNMaXN0XTtcbiAgICB9XG4gICAgYWxpYXNMaXN0LmZvckVhY2goYWxpYXMgPT4geyBhbGlhc2VzW2FsaWFzLnRvTG93ZXJDYXNlKCldID0gbGFuZ3VhZ2VOYW1lOyB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXRlcm1pbmVzIGlmIGEgZ2l2ZW4gbGFuZ3VhZ2UgaGFzIGF1dG8tZGV0ZWN0aW9uIGVuYWJsZWRcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgLSBuYW1lIG9mIHRoZSBsYW5ndWFnZVxuICAgKi9cbiAgZnVuY3Rpb24gYXV0b0RldGVjdGlvbihuYW1lKSB7XG4gICAgY29uc3QgbGFuZyA9IGdldExhbmd1YWdlKG5hbWUpO1xuICAgIHJldHVybiBsYW5nICYmICFsYW5nLmRpc2FibGVBdXRvZGV0ZWN0O1xuICB9XG5cbiAgLyoqXG4gICAqIFVwZ3JhZGVzIHRoZSBvbGQgaGlnaGxpZ2h0QmxvY2sgcGx1Z2lucyB0byB0aGUgbmV3XG4gICAqIGhpZ2hsaWdodEVsZW1lbnQgQVBJXG4gICAqIEBwYXJhbSB7SExKU1BsdWdpbn0gcGx1Z2luXG4gICAqL1xuICBmdW5jdGlvbiB1cGdyYWRlUGx1Z2luQVBJKHBsdWdpbikge1xuICAgIC8vIFRPRE86IHJlbW92ZSB3aXRoIHYxMlxuICAgIGlmIChwbHVnaW5bXCJiZWZvcmU6aGlnaGxpZ2h0QmxvY2tcIl0gJiYgIXBsdWdpbltcImJlZm9yZTpoaWdobGlnaHRFbGVtZW50XCJdKSB7XG4gICAgICBwbHVnaW5bXCJiZWZvcmU6aGlnaGxpZ2h0RWxlbWVudFwiXSA9IChkYXRhKSA9PiB7XG4gICAgICAgIHBsdWdpbltcImJlZm9yZTpoaWdobGlnaHRCbG9ja1wiXShcbiAgICAgICAgICBPYmplY3QuYXNzaWduKHsgYmxvY2s6IGRhdGEuZWwgfSwgZGF0YSlcbiAgICAgICAgKTtcbiAgICAgIH07XG4gICAgfVxuICAgIGlmIChwbHVnaW5bXCJhZnRlcjpoaWdobGlnaHRCbG9ja1wiXSAmJiAhcGx1Z2luW1wiYWZ0ZXI6aGlnaGxpZ2h0RWxlbWVudFwiXSkge1xuICAgICAgcGx1Z2luW1wiYWZ0ZXI6aGlnaGxpZ2h0RWxlbWVudFwiXSA9IChkYXRhKSA9PiB7XG4gICAgICAgIHBsdWdpbltcImFmdGVyOmhpZ2hsaWdodEJsb2NrXCJdKFxuICAgICAgICAgIE9iamVjdC5hc3NpZ24oeyBibG9jazogZGF0YS5lbCB9LCBkYXRhKVxuICAgICAgICApO1xuICAgICAgfTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtITEpTUGx1Z2lufSBwbHVnaW5cbiAgICovXG4gIGZ1bmN0aW9uIGFkZFBsdWdpbihwbHVnaW4pIHtcbiAgICB1cGdyYWRlUGx1Z2luQVBJKHBsdWdpbik7XG4gICAgcGx1Z2lucy5wdXNoKHBsdWdpbik7XG4gIH1cblxuICAvKipcbiAgICpcbiAgICogQHBhcmFtIHtQbHVnaW5FdmVudH0gZXZlbnRcbiAgICogQHBhcmFtIHthbnl9IGFyZ3NcbiAgICovXG4gIGZ1bmN0aW9uIGZpcmUoZXZlbnQsIGFyZ3MpIHtcbiAgICBjb25zdCBjYiA9IGV2ZW50O1xuICAgIHBsdWdpbnMuZm9yRWFjaChmdW5jdGlvbihwbHVnaW4pIHtcbiAgICAgIGlmIChwbHVnaW5bY2JdKSB7XG4gICAgICAgIHBsdWdpbltjYl0oYXJncyk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogREVQUkVDQVRFRFxuICAgKiBAcGFyYW0ge0hpZ2hsaWdodGVkSFRNTEVsZW1lbnR9IGVsXG4gICAqL1xuICBmdW5jdGlvbiBkZXByZWNhdGVIaWdobGlnaHRCbG9jayhlbCkge1xuICAgIGRlcHJlY2F0ZWQoXCIxMC43LjBcIiwgXCJoaWdobGlnaHRCbG9jayB3aWxsIGJlIHJlbW92ZWQgZW50aXJlbHkgaW4gdjEyLjBcIik7XG4gICAgZGVwcmVjYXRlZChcIjEwLjcuMFwiLCBcIlBsZWFzZSB1c2UgaGlnaGxpZ2h0RWxlbWVudCBub3cuXCIpO1xuXG4gICAgcmV0dXJuIGhpZ2hsaWdodEVsZW1lbnQoZWwpO1xuICB9XG5cbiAgLyogSW50ZXJmYWNlIGRlZmluaXRpb24gKi9cbiAgT2JqZWN0LmFzc2lnbihobGpzLCB7XG4gICAgaGlnaGxpZ2h0LFxuICAgIGhpZ2hsaWdodEF1dG8sXG4gICAgaGlnaGxpZ2h0QWxsLFxuICAgIGhpZ2hsaWdodEVsZW1lbnQsXG4gICAgLy8gVE9ETzogUmVtb3ZlIHdpdGggdjEyIEFQSVxuICAgIGhpZ2hsaWdodEJsb2NrOiBkZXByZWNhdGVIaWdobGlnaHRCbG9jayxcbiAgICBjb25maWd1cmUsXG4gICAgaW5pdEhpZ2hsaWdodGluZyxcbiAgICBpbml0SGlnaGxpZ2h0aW5nT25Mb2FkLFxuICAgIHJlZ2lzdGVyTGFuZ3VhZ2UsXG4gICAgdW5yZWdpc3Rlckxhbmd1YWdlLFxuICAgIGxpc3RMYW5ndWFnZXMsXG4gICAgZ2V0TGFuZ3VhZ2UsXG4gICAgcmVnaXN0ZXJBbGlhc2VzLFxuICAgIGF1dG9EZXRlY3Rpb24sXG4gICAgaW5oZXJpdCxcbiAgICBhZGRQbHVnaW5cbiAgfSk7XG5cbiAgaGxqcy5kZWJ1Z01vZGUgPSBmdW5jdGlvbigpIHsgU0FGRV9NT0RFID0gZmFsc2U7IH07XG4gIGhsanMuc2FmZU1vZGUgPSBmdW5jdGlvbigpIHsgU0FGRV9NT0RFID0gdHJ1ZTsgfTtcbiAgaGxqcy52ZXJzaW9uU3RyaW5nID0gdmVyc2lvbjtcblxuICBmb3IgKGNvbnN0IGtleSBpbiBNT0RFUykge1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBpZiAodHlwZW9mIE1PREVTW2tleV0gPT09IFwib2JqZWN0XCIpIHtcbiAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgIGRlZXBGcmVlemUkMShNT0RFU1trZXldKTtcbiAgICB9XG4gIH1cblxuICAvLyBtZXJnZSBhbGwgdGhlIG1vZGVzL3JlZ2V4ZXMgaW50byBvdXIgbWFpbiBvYmplY3RcbiAgT2JqZWN0LmFzc2lnbihobGpzLCBNT0RFUyk7XG5cbiAgcmV0dXJuIGhsanM7XG59O1xuXG4vLyBleHBvcnQgYW4gXCJpbnN0YW5jZVwiIG9mIHRoZSBoaWdobGlnaHRlclxudmFyIGhpZ2hsaWdodCA9IEhMSlMoe30pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGhpZ2hsaWdodDtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///390\n")}},__webpack_module_cache__={};function __webpack_require__(e){var n=__webpack_module_cache__[e];if(void 0!==n)return n.exports;var t=__webpack_module_cache__[e]={exports:{}};return __webpack_modules__[e].call(t.exports,t,t.exports,__webpack_require__),t.exports}__webpack_require__.n=e=>{var n=e&&e.__esModule?()=>e.default:()=>e;return __webpack_require__.d(n,{a:n}),n},__webpack_require__.d=(e,n)=>{for(var t in n)__webpack_require__.o(n,t)&&!__webpack_require__.o(e,t)&&Object.defineProperty(e,t,{enumerable:!0,get:n[t]})},__webpack_require__.g=function(){if("object"==typeof globalThis)return globalThis;try{return this||new Function("return this")()}catch(e){if("object"==typeof window)return window}}(),__webpack_require__.o=(e,n)=>Object.prototype.hasOwnProperty.call(e,n);var __webpack_exports__=__webpack_require__(929)})();